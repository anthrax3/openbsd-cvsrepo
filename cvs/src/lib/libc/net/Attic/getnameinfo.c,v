head	1.34;
access;
symbols
	OPENBSD_5_4:1.33.0.28
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.26
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.24
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.22
	OPENBSD_5_0:1.33.0.20
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.18
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.16
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.12
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.14
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.10
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.8
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.6
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.4
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.31.0.6
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.34
date	2013.11.12.20.37.15;	author eric;	state dead;
branches;
next	1.33;

1.33
date	2007.02.15.04.25.35;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.19.04.44.34;	author marcm;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2004.09.15.19.01.28;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.07.21.11.23;	author marc;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.21.23.17.53;	author marc;	state Exp;
branches;
next	1.26;

1.26
date	2003.01.28.04.58.00;	author marc;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.27.09.24.28;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.22.04.31.14;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.17.19.42.23;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.15.04.56.15;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.14.02.31.57;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.20.02.23.33;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.25.22.52.57;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.12.04.28.22;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.12.03.50.50;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.15.10.50.39;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.26.16.08.12;	author itojun;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2000.04.26.14.46.47;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.13.02.22.12;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.13.02.18.36;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.17.17.09.41;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.16.12.53.35;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.09.12.22.09;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.17.08.15.27;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.05.04.50.48;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	99.12.30.08.54.20;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.07.03.21.45.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.06.23.23.04.50;	author cmetz;	state Exp;
branches;
next	1.2;

1.2
date	99.06.23.22.38.52;	author cmetz;	state Exp;
branches;
next	1.1;

1.1
date	99.06.23.21.55.29;	author cmetz;	state Exp;
branches;
next	;

1.14.2.1
date	2000.06.15.03.35.50;	author jason;	state Exp;
branches;
next	;


desc
@@


1.34
log
@remove dead files

ok deraadt@@
@
text
@/*	$OpenBSD: getnameinfo.c,v 1.33 2007/02/15 04:25:35 ray Exp $	*/
/*	$KAME: getnameinfo.c,v 1.45 2000/09/25 22:43:56 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Issues to be discussed:
 * - Thread safe-ness must be checked
 * - RFC2553 says that we should raise error on short buffer.  X/Open says
 *   we need to truncate the result.  We obey RFC2553 (and X/Open should be
 *   modified).  ipngwg rough consensus seems to follow RFC2553.
 * - What is "local" in NI_FQDN?
 * - NI_NAMEREQD and NI_NUMERICHOST conflict with each other.
 * - (KAME extension) always attach textual scopeid (fe80::1%lo0), if
 *   sin6_scope_id is filled - standardization status?
 *   XXX breaks backward compat for code that expects no scopeid.
 *   beware on merge.
 */

#ifndef INET6
#define INET6
#endif

#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>
#include <resolv.h>
#include <string.h>
#include <stddef.h>

#include "thread_private.h"

static const struct afd {
	int a_af;
	int a_addrlen;
	int a_socklen;
	int a_off;
} afdl [] = {
#ifdef INET6
	{PF_INET6, sizeof(struct in6_addr), sizeof(struct sockaddr_in6),
		offsetof(struct sockaddr_in6, sin6_addr)},
#endif
	{PF_INET, sizeof(struct in_addr), sizeof(struct sockaddr_in),
		offsetof(struct sockaddr_in, sin_addr)},
	{0, 0, 0},
};

struct sockinet {
	u_char	si_len;
	u_char	si_family;
	u_short	si_port;
};

#ifdef INET6
static int ip6_parsenumeric(const struct sockaddr *, const char *, char *,
    size_t, int);
static int ip6_sa2str(const struct sockaddr_in6 *, char *, size_t, int);
#endif

void *__THREAD_NAME(serv_mutex);

int
getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host,
    size_t hostlen, char *serv, size_t servlen, int flags)
{
	const struct afd *afd;
	struct hostent *hp;
	u_short port;
	int family, i;
	const char *addr;
	u_int32_t v4a;
	char numserv[512];
	char numaddr[512];

	if (sa == NULL)
		return EAI_FAIL;

	family = sa->sa_family;
	for (i = 0; afdl[i].a_af; i++)
		if (afdl[i].a_af == family) {
			afd = &afdl[i];
			goto found;
		}
	return EAI_FAMILY;

 found:
	if (salen != afd->a_socklen)
		return EAI_FAIL;

	/* network byte order */
	port = ((const struct sockinet *)sa)->si_port;
	addr = (const char *)sa + afd->a_off;

	if (serv == NULL || servlen == 0) {
		/*
		 * do nothing in this case.
		 * in case you are wondering if "&&" is more correct than
		 * "||" here: rfc2553bis-03 says that serv == NULL OR
		 * servlen == 0 means that the caller does not want the result.
		 */
	} else if (!(flags & NI_NUMERICSERV)) {
		struct servent sp;
		struct servent_data sd;

		(void)memset(&sd, 0, sizeof(sd));
		if (getservbyport_r(port,
		    (flags & NI_DGRAM) ? "udp" : "tcp", &sp, &sd) == -1)
			goto numeric;

		if (strlen(sp.s_name) + 1 > servlen) {
			endservent_r(&sd);
			return EAI_MEMORY;
		}
		strlcpy(serv, sp.s_name, servlen);
		endservent_r(&sd);
	} else {
 numeric:
		i = snprintf(numserv, sizeof(numserv), "%u", ntohs(port));
		if (i < 0 || i >= servlen || i >= sizeof(numserv))
			return EAI_MEMORY;
		strlcpy(serv, numserv, servlen);
	}

	switch (sa->sa_family) {
	case AF_INET:
		v4a = (u_int32_t)
		    ntohl(((const struct sockaddr_in *)sa)->sin_addr.s_addr);
		if (IN_MULTICAST(v4a) || IN_EXPERIMENTAL(v4a))
			flags |= NI_NUMERICHOST;
		v4a >>= IN_CLASSA_NSHIFT;
		if (v4a == 0)
			flags |= NI_NUMERICHOST;			
		break;
#ifdef INET6
	case AF_INET6:
	    {
		const struct sockaddr_in6 *sin6;
		sin6 = (const struct sockaddr_in6 *)sa;
		switch (sin6->sin6_addr.s6_addr[0]) {
		case 0x00:
			if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
				;
			else if (IN6_IS_ADDR_LOOPBACK(&sin6->sin6_addr))
				;
			else
				flags |= NI_NUMERICHOST;
			break;
		default:
			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr)) {
				flags |= NI_NUMERICHOST;
			}
			else if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr))
				flags |= NI_NUMERICHOST;
			break;
		}
	    }
		break;
#endif
	}
	if (host == NULL || hostlen == 0) {
		/*
		 * do nothing in this case.
		 * in case you are wondering if "&&" is more correct than
		 * "||" here: rfc2553bis-03 says that host == NULL or
		 * hostlen == 0 means that the caller does not want the result.
		 */
	} else if (flags & NI_NUMERICHOST) {
		int numaddrlen;

		/* NUMERICHOST and NAMEREQD conflicts with each other */
		if (flags & NI_NAMEREQD)
			return EAI_NONAME;

		switch(afd->a_af) {
#ifdef INET6
		case AF_INET6:
		{
			int error;

			if ((error = ip6_parsenumeric(sa, addr, host,
						      hostlen, flags)) != 0)
				return(error);
			break;
		}
#endif
		default:
			if (inet_ntop(afd->a_af, addr, numaddr, sizeof(numaddr))
			    == NULL)
				return EAI_SYSTEM;
			numaddrlen = strlen(numaddr);
			if (numaddrlen + 1 > hostlen) /* don't forget terminator */
				return EAI_MEMORY;
			strlcpy(host, numaddr, hostlen);
			break;
		}
	} else {
		_THREAD_PRIVATE_MUTEX_LOCK(serv_mutex);
		hp = gethostbyaddr(addr, afd->a_addrlen, afd->a_af);
		_THREAD_PRIVATE_MUTEX_UNLOCK(serv_mutex);

		if (hp) {
#if 0
			/*
			 * commented out, since "for local host" is not
			 * implemented here - see RFC2553 p30
			 */
			if (flags & NI_NOFQDN) {
				char *p;
				p = strchr(hp->h_name, '.');
				if (p)
					*p = '\0';
			}
#endif
			if (strlen(hp->h_name) + 1 > hostlen) {
				return EAI_MEMORY;
			}
			strlcpy(host, hp->h_name, hostlen);
		} else {
			if (flags & NI_NAMEREQD)
				return EAI_NONAME;
			switch(afd->a_af) {
#ifdef INET6
			case AF_INET6:
			{
				int error;

				if ((error = ip6_parsenumeric(sa, addr, host,
							      hostlen,
							      flags)) != 0)
					return(error);
				break;
			}
#endif
			default:
				if (inet_ntop(afd->a_af, addr, host,
				    hostlen) == NULL)
					return EAI_SYSTEM;
				break;
			}
		}
	}
	return(0);
}

#ifdef INET6
static int
ip6_parsenumeric(const struct sockaddr *sa, const char *addr, char *host,
    size_t hostlen, int flags)
{
	int numaddrlen;
	char numaddr[512];

	if (inet_ntop(AF_INET6, addr, numaddr, sizeof(numaddr)) == NULL)
		return EAI_SYSTEM;

	numaddrlen = strlen(numaddr);
	if (numaddrlen + 1 > hostlen) /* don't forget terminator */
		return EAI_MEMORY;
	strlcpy(host, numaddr, hostlen);

	if (((const struct sockaddr_in6 *)sa)->sin6_scope_id) {
		char zonebuf[MAXHOSTNAMELEN];
		int zonelen;

		zonelen = ip6_sa2str(
		    (const struct sockaddr_in6 *)(const void *)sa,
		    zonebuf, sizeof(zonebuf), flags);
		if (zonelen < 0)
			return EAI_MEMORY;
		if (zonelen + 1 + numaddrlen + 1 > hostlen)
			return EAI_MEMORY;

		/* construct <numeric-addr><delim><zoneid> */
		memcpy(host + numaddrlen + 1, zonebuf,
		    (size_t)zonelen);
		host[numaddrlen] = SCOPE_DELIMITER;
		host[numaddrlen + 1 + zonelen] = '\0';
	}

	return 0;
}

/* ARGSUSED */
static int
ip6_sa2str(const struct sockaddr_in6 *sa6, char *buf, size_t bufsiz, int flags)
{
	unsigned int ifindex;
	const struct in6_addr *a6;
	int n;

	ifindex = (unsigned int)sa6->sin6_scope_id;
	a6 = &sa6->sin6_addr;

#ifdef notdef
	if ((flags & NI_NUMERICSCOPE) != 0) {
		n = snprintf(buf, bufsiz, "%u", sa6->sin6_scope_id);
		if (n < 0 || n >= bufsiz)
			return -1;
		else
			return n;
	}
#endif

	/* if_indextoname() does not take buffer size.  not a good api... */
	if ((IN6_IS_ADDR_LINKLOCAL(a6) || IN6_IS_ADDR_MC_LINKLOCAL(a6) ||
	    IN6_IS_ADDR_MC_INTFACELOCAL(a6)) && bufsiz >= IF_NAMESIZE) {
		char *p = if_indextoname(ifindex, buf);
		if (p) {
			return(strlen(p));
		}
	}

	/* last resort */
	n = snprintf(buf, bufsiz, "%u", sa6->sin6_scope_id);
	if (n < 0 || n >= bufsiz)
		return -1;
	else
		return n;
}
#endif /* INET6 */
@


1.33
log
@Remove two mutexes by replacing getservbyname() and getservbyport()
calls with their reentrant versions.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.32 2006/11/17 01:11:23 itojun Exp $	*/
@


1.32
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.31 2005/06/19 04:44:34 marcm Exp $	*/
a90 3
/*
 * this mutex is also used by get_port in getaddrinfo.c
 */
a97 1
	struct servent *sp;
d132 15
d148 5
a152 18
		if (flags & NI_NUMERICSERV)
			sp = NULL;
		else {
			_THREAD_PRIVATE_MUTEX_LOCK(serv_mutex);
			sp = getservbyport(port,
			    (flags & NI_DGRAM) ? "udp" : "tcp");
			_THREAD_PRIVATE_MUTEX_UNLOCK(serv_mutex);
		}
		if (sp) {
			if (strlen(sp->s_name) + 1 > servlen)
				return EAI_MEMORY;
			strlcpy(serv, sp->s_name, servlen);
		} else {
			snprintf(numserv, sizeof(numserv), "%u", ntohs(port));
			if (strlen(numserv) + 1 > servlen)
				return EAI_MEMORY;
			strlcpy(serv, numserv, servlen);
		}
@


1.31
log
@Remove a check about whether sa->sa_len is equal to salen from
getnameinfo(3).  POSIX doesn't require this and it breaks code that
doesn't handle it.

"I think this is safe" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.30 2005/03/25 13:24:12 otto Exp $	*/
d338 2
a339 2
	if ((IN6_IS_ADDR_LINKLOCAL(a6) || IN6_IS_ADDR_MC_LINKLOCAL(a6)) &&
	    bufsiz >= IF_NAMESIZE) {
@


1.30
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.29 2004/09/15 19:01:28 deraadt Exp $	*/
a112 3
	if (sa->sa_len != salen)
		return EAI_FAIL;
	
@


1.29
log
@unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.28 2004/06/07 21:11:23 marc Exp $	*/
d97 2
a98 8
getnameinfo(sa, salen, host, hostlen, serv, servlen, flags)
	const struct sockaddr *sa;
	socklen_t salen;
	char *host;
	size_t hostlen;
	char *serv;
	size_t servlen;
	int flags;
d283 2
a284 6
ip6_parsenumeric(sa, addr, host, hostlen, flags)
	const struct sockaddr *sa;
	const char *addr;
	char *host;
	size_t hostlen;
	int flags;
d321 1
a321 5
ip6_sa2str(sa6, buf, bufsiz, flags)
	const struct sockaddr_in6 *sa6;
	char *buf;
	size_t bufsiz;
	int flags;
@


1.28
log
@
major bump to libc and libpthread to break the dependency of a
particular implementation of libpthread for libc.  libc no longer
needs pthread.h to compile.
OK millert@@, brad@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.27 2003/07/21 23:17:53 marc Exp $	*/
a112 1
	int h_error;
a241 1
		h_error = h_errno;
@


1.27
log
@bug library/3297: lib/libc/net/get{addr,name}info should share mutex
'Looks right' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.26 2003/01/28 04:58:00 marc Exp $	*/
d94 1
a94 1
pthread_mutex_t __THREAD_MUTEX_NAME(serv_mutex) = PTHREAD_MUTEX_INITIALIZER;
@


1.26
log
@
thread safer libc (note: safer, not safe)
Access to the global _res structure replaced by pointers to a
per thread instance.  If unthreaded the pointer is to the
global structure.

Also replaced a 64k stack array with malloc-ed memory so
threaded aps (with a default 64k stack) have a chance at working.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.25 2002/06/27 09:24:28 itojun Exp $	*/
d91 5
a115 1
	_THREAD_PRIVATE_MUTEX(serv_mutex);
@


1.25
log
@ntohs() returns unsigned value
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.24 2002/05/22 04:31:14 deraadt Exp $	*/
d62 2
d111 1
d146 1
d149 1
d236 1
d238 1
@


1.24
log
@more strlcpy and snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.23 2002/02/17 19:42:23 millert Exp $	*/
d151 1
a151 1
			snprintf(numserv, sizeof(numserv), "%d", ntohs(port));
@


1.23
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.22 2002/02/16 21:27:23 millert Exp $	*/
d144 1
a144 1
				(flags & NI_DGRAM) ? "udp" : "tcp");
d149 1
a149 1
			strcpy(serv, sp->s_name);
d154 1
a154 1
			strcpy(serv, numserv);
d227 1
a227 1
			strcpy(host, numaddr);
d250 1
a250 1
			strcpy(host, hp->h_name);
d296 1
a296 1
	strcpy(host, numaddr);
@


1.22
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.21 2001/11/15 04:56:15 itojun Exp $	*/
d84 2
a85 2
static int ip6_parsenumeric __P((const struct sockaddr *, const char *, char *,
				 size_t, int));
@


1.21
log
@make NI_WITHSCOPEID a default (always on), to synchronize with recent 2553bis.
sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.20 2001/11/14 02:31:57 itojun Exp $	*/
d86 1
a86 1
static int ip6_sa2str __P((const struct sockaddr_in6 *, char *, size_t, int));
@


1.20
log
@sync with kame better.  open some renaming #defines (ENI_xx).
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.19 2001/08/20 02:23:33 itojun Exp $	*/
d41 4
a44 2
 * - (KAME extension) NI_WITHSCOPEID when called with global address,
 *   and sin6_scope_id filled
a297 1
#ifdef NI_WITHSCOPEID
d299 2
a300 4
		if (flags & NI_WITHSCOPEID)
		{
			char scopebuf[MAXHOSTNAMELEN];
			int scopelen;
d302 13
a314 15
			scopelen = ip6_sa2str(
			    (const struct sockaddr_in6 *)(const void *)sa,
			    scopebuf, sizeof(scopebuf), 0);
			if (scopelen < 0)
				return EAI_MEMORY;
			if (scopelen + 1 + numaddrlen + 1 > hostlen)
				return EAI_MEMORY;
			/*
			 * construct <numeric-addr><delim><scopeid>
			 */
			memcpy(host + numaddrlen + 1, scopebuf,
			    (size_t)scopelen);
			host[numaddrlen] = SCOPE_DELIMITER;
			host[numaddrlen + 1 + scopelen] = '\0';
		}
a315 1
#endif /* NI_WITHSCOPEID */
@


1.19
log
@cope with negative return value from snprintf.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.18 2000/09/25 22:52:57 itojun Exp $	*/
d60 1
a60 6
#define SUCCESS 0
#define ANY 0
#define YES 1
#define NO  0

static struct afd {
a86 9
/* 2553bis: use EAI_xx for getnameinfo */
#define ENI_NOSOCKET 	EAI_FAIL		/*XXX*/
#define ENI_NOSERVNAME	EAI_NONAME
#define ENI_NOHOSTNAME	EAI_NONAME
#define ENI_MEMORY	EAI_MEMORY
#define ENI_SYSTEM	EAI_SYSTEM
#define ENI_FAMILY	EAI_FAMILY
#define ENI_SALEN	EAI_FAMILY

d97 1
a97 1
	struct afd *afd;
d109 1
a109 1
		return ENI_NOSOCKET;
d112 1
a112 1
		return ENI_SALEN;
d120 2
a121 2
	return ENI_FAMILY;
	
d124 2
a125 2
		return ENI_SALEN;
	
d134 2
a135 2
		 * "||" here: RFC2553 says that serv == NULL OR servlen == 0
		 * means that the caller does not want the result.
d146 1
a146 1
				return ENI_MEMORY;
d151 1
a151 1
				return ENI_MEMORY;
d196 2
a197 2
		 * "||" here: RFC2553 says that host == NULL OR hostlen == 0
		 * means that the caller does not want the result.
d204 1
a204 1
			return ENI_NOHOSTNAME;
d221 1
a221 1
				return ENI_SYSTEM;
d224 1
a224 1
				return ENI_MEMORY;
d246 1
a246 1
				return ENI_MEMORY;
d251 1
a251 1
				return ENI_NOHOSTNAME;
d268 1
a268 1
					return ENI_SYSTEM;
d273 1
a273 1
	return SUCCESS;
d288 2
a289 3
	if (inet_ntop(AF_INET6, addr, numaddr, sizeof(numaddr))
	    == NULL)
		return ENI_SYSTEM;
d293 1
a293 1
		return ENI_MEMORY;
d307 1
a307 1
				return ENI_MEMORY;
d309 1
a309 1
				return ENI_MEMORY;
@


1.18
log
@fix off-by-1 error.
From: Pavel Kankovsky <peak@@argo.troja.mff.cuni.cz>
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.17 2000/06/12 04:28:22 itojun Exp $	*/
d318 5
a322 4
			/* ip6_sa2str never fails */
			scopelen = ip6_sa2str((const struct sockaddr_in6 *)sa,
					      scopebuf, sizeof(scopebuf),
					      flags);
d329 1
a329 1
			       scopelen);
d347 14
a360 6
	unsigned int ifindex = (unsigned int)sa6->sin6_scope_id;
	const struct in6_addr *a6 = &sa6->sin6_addr;

#ifdef notyet
	if (flags & NI_NUMERICSCOPE) {
		return(snprintf(buf, bufsiz, "%d", sa6->sin6_scope_id));
d374 5
a378 1
	return(snprintf(buf, bufsiz, "%u", sa6->sin6_scope_id));
@


1.17
log
@correct ENI_SALEN case to meet rfc2553bis.
@
text
@d1 2
a2 2
/*	$OpenBSD: getnameinfo.c,v 1.16 2000/06/12 03:50:50 itojun Exp $	*/
/*	$KAME: getnameinfo.c,v 1.43 2000/06/12 04:27:03 itojun Exp $	*/
a35 2
 * - Return values.  There seems to be no standard for return value (RFC2553)
 *   but INRIA implementation returns EAI_xxx defined for getaddrinfo().
d38 1
a38 1
 *   modified).
d92 1
d159 1
a159 1
			if (strlen(sp->s_name) > servlen)
d164 1
a164 1
			if (strlen(numserv) > servlen)
d259 1
a259 1
			if (strlen(hp->h_name) > hostlen) {
d321 1
a321 1
					      0);
@


1.16
log
@correct behavior against invalid sockaddr.  previous code may return 0
(success) on invalid sockaddr.
sync with rfc2553bis regarding to getnameinfo error code.  (sync with kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: getnameinfo.c,v 1.15 2000/05/15 10:50:39 itojun Exp $	*/
/*	$KAME: getnameinfo.c,v 1.42 2000/06/12 02:51:06 itojun Exp $	*/
d100 1
a100 1
#define ENI_SALEN	EAI_FAIL		/*XXX*/
@


1.15
log
@correct type of 2nd argument to meet RFC2553. (this should raise no ABI
problem due to type promotion).  PR 1228.
@
text
@d1 2
a2 2
/*	$OpenBSD: getnameinfo.c,v 1.14 2000/04/26 16:08:12 itojun Exp $	*/
/*	$KAME: getnameinfo.c,v 1.38 2000/04/26 15:58:50 itojun Exp $	*/
d94 7
a100 7
#define ENI_NOSOCKET 	0
#define ENI_NOSERVNAME	1
#define ENI_NOHOSTNAME	2
#define ENI_MEMORY	3
#define ENI_SYSTEM	4
#define ENI_FAMILY	5
#define ENI_SALEN	6
@


1.14
log
@const poisoning
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.13 2000/04/26 14:46:47 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d92 1
a92 1
#endif 
d105 1
a105 1
	size_t salen;
d355 1
a355 1
 
@


1.14.2.1
log
@Pull in patch from current (itojun):
correct behavior against invalid sockaddr.  previous code may return 0
(success) on invalid sockaddr.
sync with rfc2553bis regarding to getnameinfo error code.  (sync with kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: getnameinfo.c,v 1.16 2000/06/12 03:50:50 itojun Exp $	*/
/*	$KAME: getnameinfo.c,v 1.42 2000/06/12 02:51:06 itojun Exp $	*/
d94 7
a100 7
#define ENI_NOSOCKET 	EAI_FAIL		/*XXX*/
#define ENI_NOSERVNAME	EAI_NONAME
#define ENI_NOHOSTNAME	EAI_NONAME
#define ENI_MEMORY	EAI_MEMORY
#define ENI_SYSTEM	EAI_SYSTEM
#define ENI_FAMILY	EAI_FAMILY
#define ENI_SALEN	EAI_FAIL		/*XXX*/
@


1.13
log
@bring in latest KAME implementation.
conforms to draft-ietf-ipngwg-scopedaddr-format-01.txt.
behavior change: returns numeric scopeid if we can't convert to string
removed #if 0'ed portion which we will never revisit.
@
text
@d1 2
a2 1
/*	$OpenBSD: getnameinfo.c,v 1.12 2000/03/13 02:22:12 itojun Exp $	*/
d89 3
a91 3
static int ip6_parsenumeric __P((const struct sockaddr *, char *, char *,
				 int, int));
static int ip6_sa2str __P((struct sockaddr_in6 *, char *, size_t, int));
d117 1
a117 1
	char *addr;
d141 3
a143 2
	port = ((struct sockinet *)sa)->si_port; /* network byte order */
	addr = (char *)sa + afd->a_off;
d174 1
a174 1
			ntohl(((struct sockaddr_in *)sa)->sin_addr.s_addr);
d184 2
a185 2
		struct sockaddr_in6 *sin6;
		sin6 = (struct sockaddr_in6 *)sa;
d254 1
d295 4
a298 2
	char *addr, *host;
	int flags, hostlen;
d313 1
a313 1
	if (((struct sockaddr_in6 *)sa)->sin6_scope_id) {
d320 1
a320 1
			scopelen = ip6_sa2str((struct sockaddr_in6 *)sa,
d342 1
a342 1
	struct sockaddr_in6 *sa6;
d348 1
a348 1
	struct in6_addr *a6 = &sa6->sin6_addr;
@


1.12
log
@avoid unused variable by #ifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.11 2000/03/13 02:18:36 itojun Exp $	*/
d40 4
d46 1
d48 1
d88 3
a90 1
static char *ip6_sa2str __P((struct sockaddr_in6 *, char *, int));
a217 18
		if (inet_ntop(afd->a_af, addr, numaddr, sizeof(numaddr))
		    == NULL)
			return ENI_SYSTEM;
		numaddrlen = strlen(numaddr);
		if (numaddrlen + 1 > hostlen) /* don't forget terminator */
			return ENI_MEMORY;
		strcpy(host, numaddr);
#if defined(INET6) && defined(NI_WITHSCOPEID)
		if (afd->a_af == AF_INET6 &&
		    (IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)addr) ||
		     IN6_IS_ADDR_MULTICAST((struct in6_addr *)addr)) &&
		    ((struct sockaddr_in6 *)sa)->sin6_scope_id) {
#ifndef ALWAYS_WITHSCOPE
			if (flags & NI_WITHSCOPEID)
#endif /* !ALWAYS_WITHSCOPE */
			{
				char scopebuf[MAXHOSTNAMELEN], *s;
				int scopelen;
d219 11
a229 31
				if ((s = ip6_sa2str((struct sockaddr_in6 *)sa,
						    scopebuf, 0)) == NULL)
					/* XXX what should we do? */
					strcpy(scopebuf, "0");

				scopelen = strlen(scopebuf);
				if (scopelen + 1 + numaddrlen + 1 > hostlen)
					return ENI_MEMORY;

#if 0
				/*
				 * construct <scopeid><delim><numeric-addr>
				 */
				/*
				 * Shift the host string to allocate
				 * space for the scope ID part.
				 */
				memmove(host + scopelen + 1, host,
					numaddrlen);
				/* copy the scope ID and the delimiter */
				memcpy(host, scopebuf, scopelen);
				host[scopelen] = SCOPE_DELIMITER;
				host[scopelen + 1 + numaddrlen] = '\0';
#else
				/*
				 * construct <numeric-addr><delim><scopeid>
				 */
				memcpy(host + numaddrlen + 1, scopebuf,
				    scopelen);
				host[numaddrlen] = SCOPE_DELIMITER;
				host[numaddrlen + 1 + scopelen] = '\0';
d231 9
a239 1
			}
a240 1
#endif /* INET6 */
d247 4
a251 2
				char *p;

d264 19
a282 6
			if (inet_ntop(afd->a_af, addr, numaddr, sizeof(numaddr))
			    == NULL)
				return ENI_NOHOSTNAME;
			if (strlen(numaddr) > hostlen)
				return ENI_MEMORY;
			strcpy(host, numaddr);
d289 45
d335 2
a336 2
static char *
ip6_sa2str(sa6, buf, flags)
d339 1
d347 1
a347 2
		sprintf(buf, "%d", sa6->sin6_scope_id);
		return(buf);
d351 8
a358 7
	if (IN6_IS_ADDR_LINKLOCAL(a6) || IN6_IS_ADDR_MC_LINKLOCAL(a6))
		return(if_indextoname(ifindex, buf));

	if (IN6_IS_ADDR_SITELOCAL(a6) || IN6_IS_ADDR_MC_SITELOCAL(a6))
		return(NULL);	/* XXX */
	if (IN6_IS_ADDR_MC_ORGLOCAL(a6))
		return(NULL);	/* XXX */
d360 2
a361 1
	return(NULL);		/* XXX */
d363 1
a363 1
#endif 
@


1.11
log
@don't process NI_NOFQDN, since the currently coded behavior is not specwise
correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.10 2000/02/17 17:09:41 itojun Exp $	*/
d108 1
a108 1
	char *addr, *p;
d271 2
d274 2
a275 1
				if (p) *p = '\0';
@


1.10
log
@to synchronize with progress of discussion for post
draft-ietf-ipngwg-scopedaddr-format-00.txt (will be 01),
use "address%interface" notation for extended scoped IPv6 address.

NOTE: the change affects link-local addresses only.  I hope it to be
the final change on it.....
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.9 2000/02/16 12:53:35 itojun Exp $	*/
d269 1
d274 1
@


1.9
log
@add more comments from recent kame.

prepare to swap extended scoped address notation.  fe80::1%de0 is the
most promised candidate, but since it is still very draft, i'm not sure
when to switch - if you have any idea please let me know.  in other words,
do i allowed to change it every week? :-P  (NOTE it is only for "extended"
scoped address notation, which is not for daily use)
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.8 2000/02/09 12:22:09 itojun Exp $	*/
d238 1
a238 1
#if 1
@


1.8
log
@revise extended scoped address format support.  delimiter and the order
is changed, based on discussion in ipngwg scoped address cabal.
past code:	fe80::1@@de0
now:		de0%fe80::1
this will be in sync with next extended address format proposal
(which should be final - I don't want to make this kind of change again).
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.7 2000/01/17 08:15:27 itojun Exp $	*/
d238 4
d252 9
@


1.7
log
@remove #if 0'ed part.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.6 2000/01/05 04:50:48 itojun Exp $	*/
d81 4
d205 2
d213 2
a214 1
		if (strlen(numaddr) > hostlen)
d226 2
a227 3
				char *ep = strchr(host, '\0');
				unsigned int ifindex =
					((struct sockaddr_in6 *)sa)->sin6_scope_id;
d229 2
a230 2
				*ep = SCOPE_DELIMITER;
				if ((if_indextoname(ifindex, ep + 1)) == NULL)
d232 16
a247 1
					strncpy(ep + 1, "???", 3);
a251 3
#ifdef USE_GETIPNODEBY
		hp = getipnodebyaddr(addr, afd->a_addrlen, afd->a_af, &h_error);
#else
a253 1
#endif
a260 3
#ifdef USE_GETIPNODEBY
				freehostent(hp);
#endif
a263 3
#ifdef USE_GETIPNODEBY
			freehostent(hp);
#endif
d277 30
@


1.6
log
@allow reverse lookup for v4 loopbacknet (127.0.0.0/8).
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.5 1999/12/30 08:54:20 itojun Exp $	*/
a41 6
#if 0
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif 
#else
#define HAVE_SA_LEN
a42 1
#endif
a54 10
#if 0
#ifndef HAVE_PORTABLE_PROTOTYPE
#include "cdecl_ext.h"
#endif 

#ifndef HAVE_ADDRINFO
#include "addrinfo.h"
#endif
#endif

a112 1
#ifdef HAVE_SA_LEN	/*XXX*/
a114 1
#endif
a163 3
#if 0
		if (v4a == 0 || v4a == IN_LOOPBACKNET)
#else
a164 1
#endif
@


1.5
log
@replace NRL get{addr,name}info with KAME get{addr,name}info.

removed functionality:
	new code will not return AF_LOCAL addrinfo struct.
added funtionality:
	SOCK_RAW is permitted as ai_socktype (no servname allowed).
	draft-ietf-ipngwg-scopedaddr-format-00.txt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d183 1
d185 3
@


1.4
log
@cleaned up
@
text
@d1 2
d4 3
a6 3
 * %%% copyright-cmetz-96-bsd
 * Copyright (c) 1996-1999, Craig Metz, All rights reserved.
 *
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Craig Metz and
 *      by other contributors.
 * 4. Neither the name of the author nor the names of contributors
d18 2
a19 2
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d22 1
a22 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
a29 1
 *
d32 18
a49 1
/* getnameinfo() v1.38 */
d53 1
d55 2
a56 2
#include <sys/un.h>
#include <sys/utsname.h>
d58 1
a58 2
#include <arpa/inet.h>
#include <errno.h>
d60 1
a60 1
#include <resolv.h>
d62 53
a114 7
#ifndef min
#define min(x,y) (((x) > (y)) ? (y) : (x))
#endif				/* min */

static int 
netdb_lookup_name(int family, void *addr, int addrlen, char *name,
    int namelen, int flags)
d116 57
a172 18
	struct hostent *hostent;
	char   *c, *c2;
	int     i;

	if (!(hostent = gethostbyaddr(addr, addrlen, family))) {
		switch (h_errno) {
		case NETDB_INTERNAL:
			return(EAI_SYSTEM);
		case HOST_NOT_FOUND:
			return(1);
		case TRY_AGAIN:
			return(EAI_AGAIN);
		case NO_RECOVERY:
			return(EAI_FAIL);
		case NO_DATA:
			return(1);
		default:
			return(EAI_FAIL);
d176 23
a198 73
	endhostent();

	c = hostent->h_name;
	if ((flags & NI_NOFQDN) && (_res.options & RES_INIT) && _res.defdname[0] &&
	    (c2 = strstr(c + 1, _res.defdname)) && (*(--c2) == '.')) {
		*c2 = 0;
		i = min(c2 - c, namelen);
		strlcpy(name, c, i);
	} else
		strlcpy(name, c, namelen);
	return 0;
}

int 
getnameinfo(const struct sockaddr *sa, size_t addrlen, char *host,
    size_t hostlen, char *serv, size_t servlen, int flags)
{
	int     rval;
	int     saved_errno;

	if (sa == NULL || addrlen != sa->sa_len)
		return EAI_FAIL;
	saved_errno = errno;

	if (host && hostlen > 0) {
		switch (sa->sa_family) {
		case AF_INET6:
		    {
			struct sockaddr_in6 *sin6 = (void *)sa;

			if (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
				if (flags & NI_NUMERICHOST)
					goto inet6_noname;
				strlcpy(host, "*", hostlen);
				break;
			}

			if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
				struct sockaddr_in sin;

				memset(&sin, 0, sizeof(struct sockaddr_in));
				sin.sin_len = sizeof(struct sockaddr_in);
				sin.sin_family = AF_INET;
				sin.sin_port = sin6->sin6_port;
				sin.sin_addr.s_addr =
				    ((u_int32_t *)&sin6->sin6_addr)[3];
				if (!(rval = getnameinfo((struct sockaddr *)&sin,
				    sizeof(struct sockaddr_in), host, hostlen,
				    serv, servlen, flags | NI_NAMEREQD)))
					goto ret;
				if (rval != EAI_NONAME)
					goto ret;
				goto inet6_noname;
			}

			if (flags & NI_NUMERICHOST)
				goto inet6_noname;
			if ((rval = netdb_lookup_name(AF_INET6,
			    &sin6->sin6_addr, sizeof(struct in6_addr),
			    host, hostlen, flags)) < 0)
				goto ret;

			if (!rval)
				break;
	inet6_noname:
			if (flags & NI_NAMEREQD) {
				rval = EAI_NONAME;
				goto ret;
			}
			if (!inet_ntop(AF_INET6, &sin6->sin6_addr, host, hostlen)) {
				rval = EAI_NONAME;
				goto ret;
			}
d200 3
a202 28
		    }
		case AF_INET:
		    {
			struct sockaddr_in *sin = (void *)sa;

			if (flags & NI_NUMERICHOST)
				goto inet_noname;

			if (sin->sin_addr.s_addr == 0) {
				strlcpy(host, "*", hostlen);
				break;
			}

			if ((rval = netdb_lookup_name(AF_INET,
			    &sin->sin_addr, sizeof(struct in_addr),
			    host, hostlen, flags)) < 0)
				goto ret;

			if (!rval)
				break;
	inet_noname:
			if (flags & NI_NAMEREQD) {
				rval = EAI_NONAME;
				goto ret;
			}
			if (!inet_ntop(AF_INET, &sin->sin_addr, host, hostlen)) {
				rval = EAI_NONAME;
				goto ret;
d204 2
a206 21
		    }
		case AF_LOCAL:
			if (!(flags & NI_NUMERICHOST)) {
				struct utsname utsname;

				if (!uname(&utsname)) {
					strlcpy(host, utsname.nodename, hostlen);
					break;
				}
			}

			if (flags & NI_NAMEREQD) {
				rval = EAI_NONAME;
				goto ret;
			}

			strlcpy(host, "localhost", hostlen);
			break;
		default:
			rval = EAI_FAMILY;
			goto ret;
d208 3
d212 34
a245 19

	if (serv && servlen > 0) {
		switch (sa->sa_family) {
		case AF_INET:
		    {
			struct sockaddr_in *sin = (void *)sa;
			struct servent *s;

			if ((flags & NI_NUMERICSERV) == 0) {
				s = getservbyport(sin->sin_port,
				    (flags & NI_DGRAM) ? "udp" : "tcp");
				if (s) {
					strlcpy(serv, s->s_name, servlen);
					break;
				}
				if (sin->sin_port == 0) {
					strlcpy(serv, "*", servlen);
					break;
				}
d247 34
a280 31
			snprintf(serv, servlen, "%d", ntohs(sin->sin_port));
			break;
		    }
		case AF_INET6:
		    {
			struct sockaddr_in6 *sin6 = (void *)sa;
			struct servent *s;

			if ((flags & NI_NUMERICSERV) == 0) {

				s = getservbyport(sin6->sin6_port,
				    (flags & NI_DGRAM) ? "udp" : "tcp");
				if (s) {
					strlcpy(serv, s->s_name, servlen);
					break;
				}
				if (sin6->sin6_port == 0) {
					strlcpy(serv, "*", servlen);
					break;
				}
			}
			snprintf(serv, servlen, "%d", ntohs(sin6->sin6_port));
			break;
		    }
		case AF_LOCAL:
		    {
			struct sockaddr_un *sun = (void *)sa;

			strlcpy(serv, sun->sun_path, servlen);
			break;
		    }
d283 1
a283 7
	rval = 0;

ret:
	if (rval == 1)
		rval = EAI_FAIL;
	errno = saved_errno;
	return (rval);
@


1.3
log
@Fixed compilation problems.
@
text
@d4 1
a4 1
 * 
d20 1
a20 1
 * 
a38 1

d43 1
d48 1
a48 5
#ifndef AF_LOCAL
#define AF_LOCAL AF_UNIX
#endif /* AF_LOCAL */

#ifndef min 
d50 1
a50 6
#endif /* min */

#define RETURN_ERROR(x) do { \
    rval = (x); \
    goto ret; \
    } while(0)
d52 3
a54 2
static int netdb_lookup_name(int family, void *addr, int addrlen, char *name,
	int namelen, int flags)
d56 32
a87 36
  struct hostent *hostent;
  char *c, *c2;
  int rval, i;

  if (!(hostent = gethostbyaddr(addr, addrlen, family))) {
    switch(h_errno) {
      case NETDB_INTERNAL:
        RETURN_ERROR(EAI_SYSTEM);
      case HOST_NOT_FOUND:
        RETURN_ERROR(1);
      case TRY_AGAIN:
        RETURN_ERROR(EAI_AGAIN);
      case NO_RECOVERY:
        RETURN_ERROR(EAI_FAIL);
      case NO_DATA:
        RETURN_ERROR(1);
      default:
        RETURN_ERROR(EAI_FAIL);
    };
  };

  endhostent();

  c = hostent->h_name;
  if ((flags & NI_NOFQDN) && (_res.options & RES_INIT) && _res.defdname[0] &&
  	(c2 = strstr(c + 1, _res.defdname)) && (*(--c2) == '.')) {
    *c2 = 0;
    i = min(c2 - c, namelen) - 1;
    strncpy(name, c, i);
  } else
    strncpy(name, c, namelen - 1);

  rval = 0;

ret:
  return rval;
d90 3
a92 1
int getnameinfo(const struct sockaddr *sa, size_t addrlen, char *host, size_t hostlen, char *serv, size_t servlen, int flags)
d94 2
a95 5
  int rval;
  int serrno = errno;

  if (!sa || (addrlen != SA_LEN(sa)))
    RETURN_ERROR(EAI_FAIL);
d97 161
a257 114
  if (host && (hostlen > 0))
    switch(sa->sa_family) {
      case AF_INET6:
        if (IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)sa)->sin6_addr)) {
	  if (flags & NI_NUMERICHOST)
	    goto inet6_noname;
	  else
            strncpy(host, "*", hostlen - 1);
          break;
        };

	if (IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)sa)->sin6_addr)) {
	  struct sockaddr_in sin;
	  memset(&sin, 0, sizeof(struct sockaddr_in));
	  sin.sin_len = sizeof(struct sockaddr_in);
	  sin.sin_family = AF_INET;
	  sin.sin_port = ((struct sockaddr_in6 *)sa)->sin6_port;
	  sin.sin_addr.s_addr = ((u_int32_t *)&((struct sockaddr_in6 *)sa)->sin6_addr)[3];
	  if (!(rval = getnameinfo((struct sockaddr *)&sin, sizeof(struct sockaddr_in), host, hostlen, serv, servlen, flags | NI_NAMEREQD)))
	    goto ret;
	  if (rval != EAI_NONAME)
	    goto ret;
	  goto inet6_noname;
	};

	if (flags & NI_NUMERICHOST)
	  goto inet6_noname;

	if ((rval = netdb_lookup_name(AF_INET6,
	    &((struct sockaddr_in6 *)sa)->sin6_addr, sizeof(struct in6_addr),
	    host, hostlen, flags)) < 0)
	  goto ret;
					      
	if (!rval)
	  break;

inet6_noname:
	if (flags & NI_NAMEREQD)
	  RETURN_ERROR(EAI_NONAME);
	
	if (!inet_ntop(AF_INET6, &((struct sockaddr_in6 *)sa)->sin6_addr, host, hostlen))
	  RETURN_ERROR(EAI_NONAME);

	break;
      case AF_INET:
	if (flags & NI_NUMERICHOST)
	  goto inet_noname;

        if (!((struct sockaddr_in *)sa)->sin_addr.s_addr) {
          strncpy(host, "*", hostlen - 1);
          break;
        };

	if ((rval = netdb_lookup_name(AF_INET,
	    &((struct sockaddr_in *)sa)->sin_addr, sizeof(struct in_addr),
	    host, hostlen, flags)) < 0)
	  goto ret;

	if (!rval)
	  break;
inet_noname:
	if (flags & NI_NAMEREQD)
	  RETURN_ERROR(EAI_NONAME);
	
	if (!inet_ntop(AF_INET, &((struct sockaddr_in *)sa)->sin_addr, host, hostlen))
	  RETURN_ERROR(EAI_NONAME);

	break;
      case AF_LOCAL:
	if (!(flags & NI_NUMERICHOST)) {
	  struct utsname utsname;
	  
	  if (!uname(&utsname)) {
	    strncpy(host, utsname.nodename, hostlen - 1);
	    break;
	  };
	};
	
	if (flags & NI_NAMEREQD)
	  RETURN_ERROR(EAI_NONAME);
	
	strncpy(host, "localhost", hostlen - 1);
	break;
      default:
        RETURN_ERROR(EAI_FAMILY);
    };

  if (serv && (servlen > 0))
    switch(sa->sa_family) {
      case AF_INET:
      case AF_INET6:
	if (!(flags & NI_NUMERICSERV)) {
	  struct servent *s;
	  if (s = getservbyport(((struct sockaddr_in *)sa)->sin_port, (flags & NI_DGRAM) ? "udp" : "tcp")) {
	    strncpy(serv, s->s_name, servlen - 1);
	    break;
	  };
          if (!((struct sockaddr_in *)sa)->sin_port) {
            strncpy(serv, "*", servlen - 1);
            break;
          };
	};
	snprintf(serv, servlen - 1, "%d", ntohs(((struct sockaddr_in *)sa)->sin_port));
	break;
      case AF_LOCAL:
	strncpy(serv, ((struct sockaddr_un *)sa)->sun_path, servlen - 1);
	break;
    };

  if (host && (hostlen > 0))
    host[hostlen-1] = 0;
  if (serv && (servlen > 0))
    serv[servlen-1] = 0;
  rval = 0;
d260 5
a264 7
  if (rval == 1)
    rval = EAI_FAIL;

  errno = serrno;

  return rval;
};
@


1.2
log
@Removed portability ifdefs.
@
text
@d46 1
d62 1
a62 1
	int namelen)
@


1.1
log
@Added some protocol independent interfaces (supposedly IPv6 support APIs, but
ones that are useful for all protocols, not just IPv6).
@
text
@a32 55
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Craig Metz and
 *      by other contributors.
 * 4. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Craig Metz and
 *      by other contributors.
 * 4. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a36 16
/* To enable debugging support (REQUIRES NRL support library), define: */
/* #define DEBUG 1 */

#ifdef __OpenBSD__
#define HAVE_POSIX1G_TYPES 1
#define INET6 1
#define LOCAL 1
#define NETDB 1
#define SALEN 1
#undef RESOLVER
#undef HOSTTABLE
#undef DEBUG
#undef HAVE_GETSERVBYNAME_R
#undef HAVE_GETHOSTBYNAME2_R
#endif /* __OpenBSD__ */

a40 1
#if LOCAL
a42 1
#endif /* LOCAL */
a45 6
#if RESOLVER
#include <arpa/nameser.h>
#include <resolv.h>
#endif /* RESOLVER */

#include "support.h"
a54 10
#if DEBUG
#if RESOLVER
#define DEBUG_MESSAGES (_res.options & RES_DEBUG)
#else /* RESOLVER */
int __getnameinfo_debug = 0;
#define DEBUG_MESSAGES (__getnameinfo_debug)
#endif /* RESOLVER */
#endif /* DEBUG */

#if DEBUG
a55 2
    if (DEBUG_MESSAGES) \
      fprintf(stderr, "%s:%d: returning %s\n", __FILE__, __LINE__, #x); \
a58 6
#else /* DEBUG */
#define RETURN_ERROR(x) do { \
    rval = (x); \
    goto ret; \
    } while(0)
#endif /* DEBUG */
a59 185
#if HOSTTABLE
static int hosttable_lookup_name(int family, void *addr, char *name, int namelen, int flags)
{
  int rval;
  FILE *f;
  char buffer[1024];
  char addrbuf[16];
  char *c, *c2;
  int i;
  char *prevcname = NULL;

  if (!(f = fopen("/etc/hosts", "r")))
    RETURN_ERROR(EAI_SYSTEM);

  while(fgets(buffer, sizeof(buffer), f)) {
    if (c = strchr(buffer, '#'))
      *c = 0;

    c = buffer;
    while(*c && !isspace(*c)) c++;
    if (!*c)
      continue;

    *(c++) = 0;

    if (family == AF_INET)
      if (inet_pton(AF_INET, buffer, addrbuf) > 0)
	if (!memcmp(addrbuf, addr, sizeof(struct in_addr)))
	  goto build;

#if INET6
    if (family == AF_INET6)
      if (inet_pton(AF_INET6, buffer, addrbuf) > 0)
	if (!memcmp(addrbuf, addr, sizeof(struct in6_addr)))
	  goto build;
#endif /* INET6 */

    continue;

build:
    while(*c && isspace(*c)) c++;
    if (!*c)
      continue;

    c2 = c;
    while(*c2 && !isspace(*c2)) c2++;
    if (!*c2)
      continue;
    *c2 = 0;

    if ((flags & NI_NOFQDN) && (_res.options & RES_INIT) && _res.defdname[0] && (c2 = strstr(c + 1, _res.defdname)) && (*(--c2) == '.')) {
      *c2 = 0;
      i = min(c2 - c, namelen) - 1;
      strncpy(name, c, i);
    } else
      strncpy(name, c, namelen - 1);

    rval = 0;
    goto ret;
  };

  RETURN_ERROR(1);

ret:
  fclose(f);
  return rval;
};
#endif /* HOSTTABLE */

#if RESOLVER
#if INET6
static char hextab[] = { '0', '1', '2', '3', '4', '5', '6', '7',
                         '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
#endif /* INET6 */

struct rrheader {
  int16_t type;
  int16_t class;
  u_int32_t ttl;
  int16_t size;
};
#define RRHEADER_SZ 10

int resolver_lookup_name(const char *ptrname, char *name, int namelen, int flags)
{
  int rval;
  char answer[PACKETSZ];
  int answerlen;
  char dn[MAXDNAME];
  char *prevcname = NULL;
  void *p, *ep;
  int answers, i;
  uint16_t rtype, rclass;

  if ((answerlen = res_search(ptrname, C_IN, T_PTR, answer, sizeof(answer))) < 0) {
    switch(h_errno) {
      case NETDB_INTERNAL:
        RETURN_ERROR(EAI_SYSTEM);
      case HOST_NOT_FOUND:
        RETURN_ERROR(1);
      case TRY_AGAIN:
        RETURN_ERROR(EAI_AGAIN);
      case NO_RECOVERY:
        RETURN_ERROR(EAI_FAIL);
      case NO_DATA:
        RETURN_ERROR(1);
      default:
        RETURN_ERROR(EAI_FAIL);
    };
  };

  p = answer;
  ep = answer + answerlen;
  
  if (answerlen < sizeof(HEADER))
    RETURN_ERROR(EAI_FAIL);

  {
    HEADER *h = (HEADER *)p;
    if (!h->qr || (h->opcode != QUERY) || (h->qdcount != htons(1)) || !h->ancount)
      RETURN_ERROR(EAI_FAIL);

    answers = ntohs(h->ancount);
  };
  p += sizeof(HEADER);

  if ((i = dn_expand(answer, ep, p, dn, sizeof(dn))) < 0)
    RETURN_ERROR(EAI_FAIL);

  p += i;

  if (p + 2*sizeof(u_int16_t) >= ep)
    RETURN_ERROR(EAI_FAIL);

  GETSHORT(rtype, p);
  GETSHORT(rclass, p);

  if ((rtype != T_PTR) || (rclass != C_IN))
    RETURN_ERROR(EAI_FAIL);

  while(answers--) {
    if ((i = dn_expand(answer, ep, p, dn, sizeof(dn))) < 0)
      RETURN_ERROR(EAI_FAIL);

    p += i;
  
    if (p + RRHEADER_SZ >= ep)
      RETURN_ERROR(EAI_FAIL);

    GETSHORT(rtype, p);
    GETSHORT(rclass, p);
    p += sizeof(uint32_t);
    if (rclass != C_IN)
      RETURN_ERROR(EAI_FAIL);
    GETSHORT(rclass, p);
    i = rclass;

    if (p + i > ep)
      RETURN_ERROR(EAI_FAIL);

    if (rtype == T_PTR) {
      if (dn_expand(answer, ep, p, dn, sizeof(dn)) != i)
        RETURN_ERROR(EAI_FAIL);

      {
      char *c2;

      if ((flags & NI_NOFQDN) && (_res.options & RES_INIT) && _res.defdname[0] && (c2 = strstr(dn + 1, _res.defdname)) && (*(--c2) == '.')) {
        *c2 = 0;
        strncpy(name, dn, min(c2 - dn, namelen) - 1);
      } else
        strncpy(name, dn, namelen - 1);
      };
    };
    p += i;
  };

  rval = 0;

ret:
  return rval;
};
#endif /* RESOLVER */

#if NETDB
a99 1
#endif /* NETDB */
a110 1
#if INET6
a122 1
#if SALEN
a123 1
#endif /* SALEN */
d137 3
a139 2
#if HOSTTABLE
	if ((rval = hosttable_lookup_name(AF_INET6, &((struct sockaddr_in6 *)sa)->sin6_addr, host, hostlen, flags)) < 0)
d141 1
a141 1
	
a143 25
#endif /* HOSTTABLE */
#if RESOLVER
	{
	  char ptrname[sizeof("0.1.2.3.4.5.6.7.8.9.a.b.c.d.e.f.0.1.2.3.4.5.6.7.8.9.a.b.c.d.e.f.ip6.int.")];
	  {
	    int i;
	    char *c = ptrname;
	    u_int8_t *p = (u_int8_t *)&((struct sockaddr_in6 *)sa)->sin6_addr + sizeof(struct in6_addr) - 1;
	    
	    for (i = sizeof(struct in6_addr) / sizeof(u_int8_t); i > 0; i--, p--) {
	      *(c++) = hextab[*p & 0x0f];
	      *(c++) = '.';
	      *(c++) = hextab[(*p & 0xf0) >> 4];
	      *(c++) = '.';
	    };
	    strcpy(c, "ip6.int.");
	  };
	  
	  if ((rval = resolver_lookup_name(ptrname, host, hostlen, flags)) < 0)
	    goto ret;
	  
	  if (!rval)
	    break;
	};
#endif /* RESOLVER */
a152 1
#endif /* INET6 */
d162 3
a164 2
#if HOSTTABLE
	if ((rval = hosttable_lookup_name(AF_INET, &((struct sockaddr_in *)sa)->sin_addr, host, hostlen, flags)) < 0)
a168 15
#endif /* HOSTTABLE */
#if RESOLVER
	{
	  char ptrname[30];
	  u_int8_t *p = (u_int8_t *)&((struct sockaddr_in *)sa)->sin_addr;
	  sprintf(ptrname, "%d.%d.%d.%d.in-addr.arpa.", p[3], p[2], p[1], p[0]);
	  
	  if ((rval = resolver_lookup_name(ptrname, host, hostlen, flags)) < 0)
	    goto ret;

	  if (!rval)
	    break;
	};
#endif /* RESOLVER */

a176 1
#if LOCAL
a191 1
#endif /* LOCAL */
a198 1
#if INET6
a199 1
#endif /* INET6 */
a212 1
#if LOCAL
a215 1
#endif /* LOCAL */
@

