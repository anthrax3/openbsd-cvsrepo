head	1.23;
access;
symbols
	OPENBSD_5_4:1.22.0.24
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.22
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.20
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.18
	OPENBSD_5_0:1.22.0.16
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.14
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.12
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.8
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.10
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.6
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.10
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.8
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.6
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.4
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.10
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2013.11.12.20.37.15;	author eric;	state dead;
branches;
next	1.22;

1.22
date	2007.10.11.18.36.41;	author jakob;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.06.20.30.04;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.30.02.58.28;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.06.16.17.23;	author moritz;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.20.18.36;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.04.00.29.17;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.28.04.58.00;	author marc;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.25.21.55.30;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.27.10.14.02;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.24.21.22.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.11.10.05.59;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.07.20.59.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.03.19.00.30.06;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.09.01.08.51;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.04.30.05.54.43;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.04.05.21.13.16;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.03.13.19.07.37;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.09.31.18;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.29.44;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.02.19.19.53.25;	author dm;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@remove dead files

ok deraadt@@
@
text
@/*	$OpenBSD: res_debug.c,v 1.22 2007/10/11 18:36:41 jakob Exp $	*/

/*
 * ++Copyright++ 1985, 1990, 1993
 * -
 * Copyright (c) 1985, 1990, 1993
 *    The Regents of the University of California.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * -
 * Portions Copyright (c) 1993 by Digital Equipment Corporation.
 * 
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies, and that
 * the name of Digital Equipment Corporation not be used in advertising or
 * publicity pertaining to distribution of the document or software without
 * specific, written prior permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
 * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 * -
 * Portions Copyright (c) 1995 by International Business Machines, Inc.
 *
 * International Business Machines, Inc. (hereinafter called IBM) grants
 * permission under its copyrights to use, copy, modify, and distribute this
 * Software with or without fee, provided that the above copyright notice and
 * all paragraphs of this notice appear in all copies, and that the name of IBM
 * not be used in connection with the marketing of any product incorporating
 * the Software or modifications thereof, without specific, written prior
 * permission.
 *
 * To the extent it has a right to do so, IBM grants an immunity from suit
 * under its patents, if any, for the use, sale or manufacture of products to
 * the extent that such products are used for performing Domain Name System
 * dynamic updates in TCP/IP networks by means of the Software.  No immunity is
 * granted for any product per se or for any other function of any product.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,
 * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN
 * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * --Copyright--
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>

#include <ctype.h>
#include <netdb.h>
#include <resolv.h>
#include <stdio.h>
#include <time.h>

#include <stdlib.h>
#include <string.h>

#include "thread_private.h"

extern const char *_res_opcodes[];
extern const char *_res_resultcodes[];

static const char *loc_ntoal(const u_char *binary, char *ascii, int ascii_len);

/* XXX: we should use getservbyport() instead. */
static const char *
dewks(int wks)
{
	static char nbuf[20];

	switch (wks) {
	case 5: return "rje";
	case 7: return "echo";
	case 9: return "discard";
	case 11: return "systat";
	case 13: return "daytime";
	case 15: return "netstat";
	case 17: return "qotd";
	case 19: return "chargen";
	case 20: return "ftp-data";
	case 21: return "ftp";
	case 23: return "telnet";
	case 25: return "smtp";
	case 37: return "time";
	case 39: return "rlp";
	case 42: return "name";
	case 43: return "whois";
	case 53: return "domain";
	case 57: return "apts";
	case 59: return "apfs";
	case 67: return "bootps";
	case 68: return "bootpc";
	case 69: return "tftp";
	case 77: return "rje";
	case 79: return "finger";
	case 87: return "link";
	case 95: return "supdup";
	case 100: return "newacct";
	case 101: return "hostnames";
	case 102: return "iso-tsap";
	case 103: return "x400";
	case 104: return "x400-snd";
	case 105: return "csnet-ns";
	case 109: return "pop-2";
	case 111: return "sunrpc";
	case 113: return "auth";
	case 115: return "sftp";
	case 117: return "uucp-path";
	case 119: return "nntp";
	case 121: return "erpc";
	case 123: return "ntp";
	case 133: return "statsrv";
	case 136: return "profile";
	case 144: return "NeWS";
	case 161: return "snmp";
	case 162: return "snmp-trap";
	case 170: return "print-srv";
	default:
		(void) snprintf(nbuf, sizeof nbuf, "%d", wks);
		return (nbuf);
	}
}

/* XXX: we should use getprotobynumber() instead. */
static const char *
deproto(int protonum)
{
	static char nbuf[20];

	switch (protonum) {
	case 1: return "icmp";
	case 2: return "igmp";
	case 3: return "ggp";
	case 5: return "st";
	case 6: return "tcp";
	case 7: return "ucl";
	case 8: return "egp";
	case 9: return "igp";
	case 11: return "nvp-II";
	case 12: return "pup";
	case 16: return "chaos";
	case 17: return "udp";
	default:
		(void) snprintf(nbuf, sizeof nbuf, "%d", protonum);
		return (nbuf);
	}
}

static const u_char *
do_rrset(const u_char *msg, int len, const u_char *cp, int cnt, int pflag,
    FILE *file, const char *hs)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	int n;
	int sflag;

	/*
	 * Print answer records.
	 */
	sflag = (_resp->pfcode & pflag);
	if ((n = ntohs(cnt))) {
		if ((!_resp->pfcode) ||
		    ((sflag) && (_resp->pfcode & RES_PRF_HEAD1)))
			fprintf(file, "%s", hs);
		while (--n >= 0) {
			if ((!_resp->pfcode) || sflag) {
				cp = p_rr(cp, msg, file);
			} else {
				unsigned int dlen;
				cp += __dn_skipname(cp, cp + MAXCDNAME);
				cp += INT16SZ;
				cp += INT16SZ;
				cp += INT32SZ;
				dlen = _getshort((u_char*)cp);
				cp += INT16SZ;
				cp += dlen;
			}
			if ((cp - msg) > len)
				return (NULL);
		}
		if ((!_resp->pfcode) ||
		    ((sflag) && (_resp->pfcode & RES_PRF_HEAD1)))
			putc('\n', file);
	}
	return (cp);
}

void
__p_query(const u_char *msg)
{
	__fp_query(msg, stdout);
}

/*
 * Print the current options.
 * This is intended to be primarily a debugging routine.
 */
void
__fp_resstat(struct __res_state *statp, FILE *file)
{
	u_long mask;

	fprintf(file, ";; res options:");
	if (!statp)
		statp = &_res;
	for (mask = 1;  mask != 0;  mask <<= 1)
		if (statp->options & mask)
			fprintf(file, " %s", p_option(mask));
	putc('\n', file);
}

/*
 * Print the contents of a query.
 * This is intended to be primarily a debugging routine.
 */
void
__fp_nquery(const u_char *msg, int len, FILE *file)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	const u_char *cp, *endMark;
	const HEADER *hp;
	int n;

	if (_res_init(0) == -1)
		return;

#define TruncTest(x) if (x > endMark) goto trunc
#define	ErrorTest(x) if (x == NULL) goto error

	/*
	 * Print header fields.
	 */
	hp = (HEADER *)msg;
	cp = msg + HFIXEDSZ;
	endMark = msg + len;
	if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_HEADX) || hp->rcode) {
		fprintf(file, ";; ->>HEADER<<- opcode: %s, status: %s, id: %u",
			_res_opcodes[hp->opcode],
			_res_resultcodes[hp->rcode],
			ntohs(hp->id));
		putc('\n', file);
	}
	if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_HEADX))
		putc(';', file);
	if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_HEAD2)) {
		fprintf(file, "; flags:");
		if (hp->qr)
			fprintf(file, " qr");
		if (hp->aa)
			fprintf(file, " aa");
		if (hp->tc)
			fprintf(file, " tc");
		if (hp->rd)
			fprintf(file, " rd");
		if (hp->ra)
			fprintf(file, " ra");
		if (hp->unused)
			fprintf(file, " UNUSED-BIT-ON");
		if (hp->ad)
			fprintf(file, " ad");
		if (hp->cd)
			fprintf(file, " cd");
	}
	if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_HEAD1)) {
		fprintf(file, "; Ques: %u", ntohs(hp->qdcount));
		fprintf(file, ", Ans: %u", ntohs(hp->ancount));
		fprintf(file, ", Auth: %u", ntohs(hp->nscount));
		fprintf(file, ", Addit: %u", ntohs(hp->arcount));
	}
	if ((!_resp->pfcode) || (_resp->pfcode & 
		(RES_PRF_HEADX | RES_PRF_HEAD2 | RES_PRF_HEAD1))) {
		putc('\n',file);
	}
	/*
	 * Print question records.
	 */
	if ((n = ntohs(hp->qdcount))) {
		if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_QUES))
			fprintf(file, ";; QUESTIONS:\n");
		while (--n >= 0) {
			if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_QUES))
				fprintf(file, ";;\t");
			TruncTest(cp);
			if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_QUES))
				cp = p_cdnname(cp, msg, len, file);
			else {
				int n;
				char name[MAXDNAME];

				if ((n = dn_expand(msg, msg+len, cp, name,
						sizeof name)) < 0)
					cp = NULL;
				else
					cp += n;
			}
			ErrorTest(cp);
			TruncTest(cp);
			if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_QUES))
				fprintf(file, ", type = %s",
					__p_type(_getshort((u_char*)cp)));
			cp += INT16SZ;
			TruncTest(cp);
			if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_QUES))
				fprintf(file, ", class = %s\n",
					__p_class(_getshort((u_char*)cp)));
			cp += INT16SZ;
			if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_QUES))
				putc('\n', file);
		}
	}
	/*
	 * Print authoritative answer records
	 */
	TruncTest(cp);
	cp = do_rrset(msg, len, cp, hp->ancount, RES_PRF_ANS, file,
		      ";; ANSWERS:\n");
	ErrorTest(cp);

	/*
	 * print name server records
	 */
	TruncTest(cp);
	cp = do_rrset(msg, len, cp, hp->nscount, RES_PRF_AUTH, file,
		      ";; AUTHORITY RECORDS:\n");
	ErrorTest(cp);

	TruncTest(cp);
	/*
	 * print additional records
	 */
	cp = do_rrset(msg, len, cp, hp->arcount, RES_PRF_ADD, file,
		      ";; ADDITIONAL RECORDS:\n");
	ErrorTest(cp);
	return;
 trunc:
	fprintf(file, "\n;; ...truncated\n");
	return;
 error:
	fprintf(file, "\n;; ...malformed\n");
}

void
__fp_query(const u_char *msg, FILE *file)
{
	fp_nquery(msg, PACKETSZ, file);
}

const u_char *
__p_cdnname(const u_char *cp, const u_char *msg, int len, FILE *file)
{
	char name[MAXDNAME];
	int n;

	if ((n = dn_expand(msg, msg + len, cp, name, sizeof name)) < 0)
		return (NULL);
	if (name[0] == '\0')
		putc('.', file);
	else
		fputs(name, file);
	return (cp + n);
}

const u_char *
__p_cdname(const u_char *cp, const u_char *msg, FILE *file)
{
	return (p_cdnname(cp, msg, PACKETSZ, file));
}


/* Return a fully-qualified domain name from a compressed name (with
   length supplied).  */

const u_char *
__p_fqnname(const u_char *cp, const u_char *msg, int msglen, char *name, int namelen)
{
	int n, newlen;

	if ((n = dn_expand(msg, cp + msglen, cp, name, namelen)) < 0)
		return (NULL);
	newlen = strlen(name);
	if (newlen == 0 || name[newlen - 1] != '.') {
		if (newlen + 1 >= namelen)	/* Lack space for final dot */
			return (NULL);
		else
			strlcpy(name + newlen, ".", namelen - newlen);
	}
	return (cp + n);
}

/* XXX:	the rest of these functions need to become length-limited, too. (vix)
 */

const u_char *
__p_fqname(const u_char *cp, const u_char *msg, FILE *file)
{
	char name[MAXDNAME];
	const u_char *n;

	n = __p_fqnname(cp, msg, MAXCDNAME, name, sizeof name);
	if (n == NULL)
		return (NULL);
	fputs(name, file);
	return (n);
}

/*
 * Print resource record fields in human readable form.
 */
const u_char *
__p_rr(const u_char *cp, const u_char *msg, FILE *file)
{
	struct __res_state *_resp = _THREAD_PRIVATE(_res, _res, &_res);
	int type, class, dlen, n, c;
	struct in_addr inaddr;
	const u_char *cp1, *cp2;
	u_int32_t tmpttl, t;
	int lcnt;
	u_int16_t keyflags;
	char rrname[MAXDNAME];		/* The fqdn of this RR */
	char base64_key[MAX_KEY_BASE64];

	if (_res_init(0) == -1) {
		h_errno = NETDB_INTERNAL;
		return (NULL);
	}
	cp = __p_fqnname(cp, msg, MAXCDNAME, rrname, sizeof rrname);
	if (!cp)
		return (NULL);			/* compression error */
	fputs(rrname, file);
	
	type = _getshort((u_char*)cp);
	cp += INT16SZ;
	class = _getshort((u_char*)cp);
	cp += INT16SZ;
	tmpttl = _getlong((u_char*)cp);
	cp += INT32SZ;
	dlen = _getshort((u_char*)cp);
	cp += INT16SZ;
	cp1 = cp;
	if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_TTLID))
		fprintf(file, "\t%lu", (u_long)tmpttl);
	if ((!_resp->pfcode) || (_resp->pfcode & RES_PRF_CLASS))
		fprintf(file, "\t%s", __p_class(class));
	fprintf(file, "\t%s", __p_type(type));
	/*
	 * Print type specific data, if appropriate
	 */
	switch (type) {
	case T_A:
		switch (class) {
		case C_IN:
		case C_HS:
			bcopy(cp, (char *)&inaddr, INADDRSZ);
			if (dlen == 4) {
				fprintf(file, "\t%s", inet_ntoa(inaddr));
				cp += dlen;
			} else if (dlen == 7) {
				char *address;
				u_char protocol;
				in_port_t port;

				address = inet_ntoa(inaddr);
				cp += INADDRSZ;
				protocol = *(u_char*)cp;
				cp += sizeof (u_char);
				port = _getshort((u_char*)cp);
				cp += INT16SZ;
				fprintf(file, "\t%s\t; proto %u, port %u",
					address, protocol, port);
			}
			break;
		default:
			cp += dlen;
		}
		break;
	case T_CNAME:
	case T_MB:
	case T_MG:
	case T_MR:
	case T_NS:
	case T_PTR:
		putc('\t', file);
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		break;

	case T_HINFO:
	case T_ISDN:
		cp2 = cp + dlen;
		(void) fputs("\t\"", file);
		if ((n = (unsigned char) *cp++) != 0) {
			for (c = n; c > 0 && cp < cp2; c--) {
				if (strchr("\n\"\\", *cp))
					(void) putc('\\', file);
				(void) putc(*cp++, file);
			}
		}
		putc('"', file);
		if (cp < cp2 && (n = (unsigned char) *cp++) != 0) {
			(void) fputs ("\t\"", file);
			for (c = n; c > 0 && cp < cp2; c--) {
				if (strchr("\n\"\\", *cp))
					(void) putc('\\', file);
				(void) putc(*cp++, file);
			}
			putc('"', file);
		} else if (type == T_HINFO) {
			(void) fputs("\"?\"", file);
			fprintf(file, "\n;; *** Warning *** OS-type missing");
		}
		break;

	case T_SOA:
		putc('\t', file);
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		putc(' ', file);
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		fputs(" (\n", file);
		t = _getlong((u_char*)cp);  cp += INT32SZ;
		fprintf(file, "\t\t\t%lu\t; serial\n", (u_long)t);
		t = _getlong((u_char*)cp);  cp += INT32SZ;
		fprintf(file, "\t\t\t%lu\t; refresh (%s)\n",
			(u_long)t, __p_time(t));
		t = _getlong((u_char*)cp);  cp += INT32SZ;
		fprintf(file, "\t\t\t%lu\t; retry (%s)\n",
			(u_long)t, __p_time(t));
		t = _getlong((u_char*)cp);  cp += INT32SZ;
		fprintf(file, "\t\t\t%lu\t; expire (%s)\n",
			(u_long)t, __p_time(t));
		t = _getlong((u_char*)cp);  cp += INT32SZ;
		fprintf(file, "\t\t\t%lu )\t; minimum (%s)",
			(u_long)t, __p_time(t));
		break;

	case T_MX:
	case T_AFSDB:
	case T_RT:
		fprintf(file, "\t%u ", _getshort((u_char*)cp));
		cp += INT16SZ;
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		break;

	case T_PX:
		fprintf(file, "\t%u ", _getshort((u_char*)cp));
		cp += INT16SZ;
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		putc(' ', file);
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		break;

	case T_X25:
		cp2 = cp + dlen;
		(void) fputs("\t\"", file);
		if ((n = (unsigned char) *cp++) != 0) {
			for (c = n; c > 0 && cp < cp2; c--) {
				if (strchr("\n\"\\", *cp))
					(void) putc('\\', file);
				(void) putc(*cp++, file);
			}
		}
		putc('"', file);
		break;

	case T_TXT:
		(void) putc('\t', file);
		cp2 = cp1 + dlen;
		while (cp < cp2) {
			putc('"', file);
			if ((n = (unsigned char) *cp++)) {
				for (c = n; c > 0 && cp < cp2; c--) {
					if (strchr("\n\"\\", *cp))
						(void) putc('\\', file);
					(void) putc(*cp++, file);
				}
			}
			putc('"', file);
			if (cp < cp2)
				putc(' ', file);
		}
		break;

	case T_NSAP:
		(void) fprintf(file, "\t%s", inet_nsap_ntoa(dlen, cp, NULL));
		cp += dlen;
		break;

	case T_AAAA: {
		char t[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"];

		fprintf(file, "\t%s", inet_ntop(AF_INET6, cp, t, sizeof t));
		cp += dlen;
		break;
	    }

	case T_LOC: {
		char t[255];

		fprintf(file, "\t%s", loc_ntoal(cp, t, sizeof t));
		cp += dlen;
		break;
	    }

	case T_NAPTR: {
		u_int order, preference;

		order = _getshort(cp);  cp += INT16SZ;
		preference   = _getshort(cp);  cp += INT16SZ;
		fprintf(file, "\t%u %u ",order, preference);
		/* Flags */
		n = *cp++;
		fprintf(file,"\"%.*s\" ", (int)n, cp);
		cp += n;
		/* Service */
		n = *cp++;
		fprintf(file,"\"%.*s\" ", (int)n, cp);
		cp += n;
		/* Regexp */
		n = *cp++;
		fprintf(file,"\"%.*s\" ", (int)n, cp);
		cp += n;
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		break;
	    }

	case T_SRV: {
		u_int priority, weight, port;

		priority = _getshort(cp);  cp += INT16SZ;
		weight   = _getshort(cp);  cp += INT16SZ;
		port     = _getshort(cp);  cp += INT16SZ;
		fprintf(file, "\t%u %u %u ", priority, weight, port);
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		break;
	    }

	case T_MINFO:
	case T_RP:
		putc('\t', file);
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		putc(' ', file);
		if ((cp = p_fqname(cp, msg, file)) == NULL)
			return (NULL);
		break;

	case T_UINFO:
		putc('\t', file);
		fputs((char *)cp, file);
		cp += dlen;
		break;

	case T_UID:
	case T_GID:
		if (dlen == 4) {
			fprintf(file, "\t%u", _getlong((u_char*)cp));
			cp += INT32SZ;
		}
		break;

	case T_WKS:
		if (dlen < INT32SZ + 1)
			break;
		bcopy(cp, (char *)&inaddr, INADDRSZ);
		cp += INT32SZ;
		fprintf(file, "\t%s %s ( ",
			inet_ntoa(inaddr),
			deproto((int) *cp));
		cp += sizeof (u_char);
		n = 0;
		lcnt = 0;
		while (cp < cp1 + dlen) {
			c = *cp++;
			do {
				if (c & 0200) {
					if (lcnt == 0) {
						fputs("\n\t\t\t", file);
						lcnt = 5;
					}
					fputs(dewks(n), file);
					putc(' ', file);
					lcnt--;
				}
				c <<= 1;
			} while (++n & 07);
		}
		putc(')', file);
		break;

	case T_KEY:
		putc('\t', file);
		keyflags = _getshort(cp);
		cp += 2;
		fprintf(file,"0x%04x", keyflags );	/* flags */
		fprintf(file," %u", *cp++);	/* protocol */
		fprintf(file," %u (", *cp++);	/* algorithm */

		n = b64_ntop(cp, (cp1 + dlen) - cp,
			     base64_key, sizeof base64_key);
		for (c = 0; c < n; ++c) {
			if (0 == (c & 0x3F))
				fprintf(file, "\n\t");
			putc(base64_key[c], file);  /* public key data */
		}

		fprintf(file, " )");
		if (n < 0)
			fprintf(file, "\t; BAD BASE64");
		fflush(file);
		cp = cp1 + dlen;
		break;

	case T_SIG:
	case T_RRSIG:
	        type = _getshort((u_char*)cp);
		cp += INT16SZ;
		fprintf(file, " %s", p_type(type));
		fprintf(file, "\t%u", *cp++);	/* algorithm */
		/* Check label value and print error if wrong. */
		n = *cp++;
		c = dn_count_labels (rrname);
		if (n != c)
			fprintf(file, "\t; LABELS WRONG (%d should be %d)\n\t",
				n, c);
		/* orig ttl */
		n = _getlong((u_char*)cp);
		if (n != tmpttl)
			fprintf(file, " %u", n);
		cp += INT32SZ;
		/* sig expire */
		fprintf(file, " (\n\t%s",
				     __p_secstodate(_getlong((u_char*)cp)));
		cp += INT32SZ;
		/* time signed */
		fprintf(file, " %s", __p_secstodate(_getlong((u_char*)cp)));
		cp += INT32SZ;
		/* sig footprint */
		fprintf(file," %u ", _getshort((u_char*)cp));
		cp += INT16SZ;
		/* signer's name */
		cp = p_fqname(cp, msg, file);
		n = b64_ntop(cp, (cp1 + dlen) - cp,
			     base64_key, sizeof base64_key);
		for (c = 0; c < n; c++) {
			if (0 == (c & 0x3F))
				fprintf (file, "\n\t");
			putc(base64_key[c], file);		/* signature */
		}
		/* Clean up... */
		fprintf(file, " )");
		if (n < 0)
			fprintf(file, "\t; BAD BASE64");
		fflush(file);
		cp = cp1+dlen;
		break;

#ifdef ALLOW_T_UNSPEC
	case T_UNSPEC:
		{
			int NumBytes = 8;
			u_char *DataPtr;
			int i;

			if (dlen < NumBytes) NumBytes = dlen;
			fprintf(file, "\tFirst %d bytes of hex data:",
				NumBytes);
			for (i = 0, DataPtr = cp; i < NumBytes; i++, DataPtr++)
				fprintf(file, " %x", *DataPtr);
			cp += dlen;
		}
		break;
#endif /* ALLOW_T_UNSPEC */

	default:
		fprintf(file, "\t?%d?", type);
		cp += dlen;
	}
#if 0
	fprintf(file, "\t; dlen=%d, ttl %s\n", dlen, __p_time(tmpttl));
#else
	putc('\n', file);
#endif
	if (cp - cp1 != dlen) {
		fprintf(file, ";; packet size error (found %ld, dlen was %d)\n",
			(long)(cp - cp1), dlen);
		cp = NULL;
	}
	return (cp);
}

int
__sym_ston(const struct res_sym *syms, char *name, int *success)
{
	for (; syms->name != 0; syms++) {
		if (strcasecmp (name, syms->name) == 0) {
			if (success)
				*success = 1;
			return (syms->number);
		}
	}
	if (success)
		*success = 0;
	return (syms->number);		/* The default value. */
}


const char *
__sym_ntop(const struct res_sym *syms, int number, int *success)
{
	static char unname[20];

	for (; syms->name != 0; syms++) {
		if (number == syms->number) {
			if (success)
				*success = 1;
			return (syms->humanname);
		}
	}
	snprintf(unname, sizeof unname, "%d", number);
	if (success)
		*success = 0;
	return (unname);
}

/*
 * Return a mnemonic for an option
 */
const char *
__p_option(u_long option)
{
	static char nbuf[40];

	switch (option) {
	case RES_INIT:		return "init";
	case RES_DEBUG:		return "debug";
	case RES_AAONLY:	return "aaonly(unimpl)";
	case RES_USEVC:		return "usevc";
	case RES_PRIMARY:	return "primry(unimpl)";
	case RES_IGNTC:		return "igntc";
	case RES_RECURSE:	return "recurs";
	case RES_DEFNAMES:	return "defnam";
	case RES_STAYOPEN:	return "styopn";
	case RES_DNSRCH:	return "dnsrch";
	case RES_INSECURE1:	return "insecure1";
	case RES_INSECURE2:	return "insecure2";
	case RES_USE_INET6:	return "inet6";
	case RES_USE_EDNS0:	return "edns0";
	default:
		snprintf(nbuf, sizeof nbuf, "?0x%lx?", (u_long)option);
		return (nbuf);
	}
}

/*
 * Return a mnemonic for a time to live
 */
const char *
p_time(u_int32_t value)
{
	static char nbuf[40];
	char *ebuf;
	int secs, mins, hours, days;
	char *p;
	int tmp;

	if (value == 0) {
		strlcpy(nbuf, "0 secs", sizeof nbuf);
		return (nbuf);
	}

	secs = value % 60;
	value /= 60;
	mins = value % 60;
	value /= 60;
	hours = value % 24;
	value /= 24;
	days = value;
	value = 0;

#define	PLURALIZE(x)	x, (x == 1) ? "" : "s"
	p = nbuf;
	ebuf = nbuf + sizeof(nbuf);
	if (days) {
		if ((tmp = snprintf(p, ebuf - p, "%d day%s",
		    PLURALIZE(days))) >= ebuf - p || tmp < 0)
			goto full;
		p += tmp;
	}
	if (hours) {
		if (days)
			*p++ = ' ';
		if (p >= ebuf)
			goto full;
		if ((tmp = snprintf(p, ebuf - p, "%d hour%s",
		    PLURALIZE(hours))) >= ebuf - p || tmp < 0)
			goto full;
		p += tmp;
	}
	if (mins) {
		if (days || hours)
			*p++ = ' ';
		if (p >= ebuf)
			goto full;
		if ((tmp = snprintf(p, ebuf - p, "%d min%s",
		    PLURALIZE(mins))) >= ebuf - p || tmp < 0)
			goto full;
		p += tmp;
	}
	if (secs || ! (days || hours || mins)) {
		if (days || hours || mins)
			*p++ = ' ';
		if (p >= ebuf)
			goto full;
		if ((tmp = snprintf(p, ebuf - p, "%d sec%s",
		    PLURALIZE(secs))) >= ebuf - p || tmp < 0)
			goto full;
	}
	return (nbuf);
full:
	p = nbuf + sizeof(nbuf) - 4;
	*p++ = '.';
	*p++ = '.';
	*p++ = '.';
	*p++ = '\0';
	return (nbuf);
}

/*
 * routines to convert between on-the-wire RR format and zone file format.
 * Does not contain conversion to/from decimal degrees; divide or multiply
 * by 60*60*1000 for that.
 */

static unsigned int poweroften[10] = {1, 10, 100, 1000, 10000, 100000,
				      1000000,10000000,100000000,1000000000};

/* takes an XeY precision/size value, returns a string representation. */
static const char *
precsize_ntoa(u_int8_t prec)
{
	static char retbuf[sizeof "90000000.00"];
	unsigned long val;
	int mantissa, exponent;

	mantissa = (int)((prec >> 4) & 0x0f) % 10;
	exponent = (int)((prec >> 0) & 0x0f) % 10;

	val = mantissa * poweroften[exponent];

	(void) snprintf(retbuf, sizeof retbuf, "%ld.%.2ld", val/100, val%100);
	return (retbuf);
}

/* converts ascii size/precision X * 10**Y(cm) to 0xXY.  moves pointer. */
static u_int8_t
precsize_aton(char **strptr)
{
	unsigned int mval = 0, cmval = 0;
	u_int8_t retval = 0;
	char *cp;
	int exponent;
	int mantissa;

	cp = *strptr;

	while (isdigit(*cp))
		mval = mval * 10 + (*cp++ - '0');

	if (*cp == '.') {		/* centimeters */
		cp++;
		if (isdigit(*cp)) {
			cmval = (*cp++ - '0') * 10;
			if (isdigit(*cp)) {
				cmval += (*cp++ - '0');
			}
		}
	}
	cmval = (mval * 100) + cmval;

	for (exponent = 0; exponent < 9; exponent++)
		if (cmval < poweroften[exponent+1])
			break;

	mantissa = cmval / poweroften[exponent];
	if (mantissa > 9)
		mantissa = 9;

	retval = (mantissa << 4) | exponent;

	*strptr = cp;

	return (retval);
}

/* converts ascii lat/lon to unsigned encoded 32-bit number.  moves pointer. */
static u_int32_t
latlon2ul(char **latlonstrptr, int *which)
{
	char *cp;
	u_int32_t retval;
	int deg = 0, min = 0, secs = 0, secsfrac = 0;

	cp = *latlonstrptr;

	while (isdigit(*cp))
		deg = deg * 10 + (*cp++ - '0');

	while (isspace(*cp))
		cp++;

	if (!(isdigit(*cp)))
		goto fndhemi;

	while (isdigit(*cp))
		min = min * 10 + (*cp++ - '0');

	while (isspace(*cp))
		cp++;

	if (!(isdigit(*cp)))
		goto fndhemi;

	while (isdigit(*cp))
		secs = secs * 10 + (*cp++ - '0');

	if (*cp == '.') {		/* decimal seconds */
		cp++;
		if (isdigit(*cp)) {
			secsfrac = (*cp++ - '0') * 100;
			if (isdigit(*cp)) {
				secsfrac += (*cp++ - '0') * 10;
				if (isdigit(*cp)) {
					secsfrac += (*cp++ - '0');
				}
			}
		}
	}

	while (!isspace(*cp))	/* if any trailing garbage */
		cp++;

	while (isspace(*cp))
		cp++;

 fndhemi:
	switch (*cp) {
	case 'N': case 'n':
	case 'E': case 'e':
		retval = ((unsigned)1<<31)
			+ (((((deg * 60) + min) * 60) + secs) * 1000)
			+ secsfrac;
		break;
	case 'S': case 's':
	case 'W': case 'w':
		retval = ((unsigned)1<<31)
			- (((((deg * 60) + min) * 60) + secs) * 1000)
			- secsfrac;
		break;
	default:
		retval = 0;	/* invalid value -- indicates error */
		break;
	}

	switch (*cp) {
	case 'N': case 'n':
	case 'S': case 's':
		*which = 1;	/* latitude */
		break;
	case 'E': case 'e':
	case 'W': case 'w':
		*which = 2;	/* longitude */
		break;
	default:
		*which = 0;	/* error */
		break;
	}

	cp++;			/* skip the hemisphere */

	while (!isspace(*cp))	/* if any trailing garbage */
		cp++;

	while (isspace(*cp))	/* move to next field */
		cp++;

	*latlonstrptr = cp;

	return (retval);
}

/* converts a zone file representation in a string to an RDATA on-the-wire
 * representation. */
int
loc_aton(const char *ascii, u_char *binary)
{
	const char *maxcp;
	u_char *bcp;
	char *cp;

	u_int32_t latit = 0, longit = 0, alt = 0;
	u_int32_t lltemp1 = 0, lltemp2 = 0;
	int altmeters = 0, altfrac = 0, altsign = 1;
	u_int8_t hp = 0x16;	/* default = 1e6 cm = 10000.00m = 10km */
	u_int8_t vp = 0x13;	/* default = 1e3 cm = 10.00m */
	u_int8_t siz = 0x12;	/* default = 1e2 cm = 1.00m */
	int which1 = 0, which2 = 0;

	cp = (char *)ascii;
	maxcp = cp + strlen(ascii);

	lltemp1 = latlon2ul(&cp, &which1);

	lltemp2 = latlon2ul(&cp, &which2);

	switch (which1 + which2) {
	case 3:			/* 1 + 2, the only valid combination */
		if ((which1 == 1) && (which2 == 2)) { /* normal case */
			latit = lltemp1;
			longit = lltemp2;
		} else if ((which1 == 2) && (which2 == 1)) { /* reversed */
			longit = lltemp1;
			latit = lltemp2;
		} else {	/* some kind of brokenness */
			return (0);
		}
		break;
	default:		/* we didn't get one of each */
		return (0);
	}

	/* altitude */
	if (*cp == '-') {
		altsign = -1;
		cp++;
	}
    
	if (*cp == '+')
		cp++;

	while (isdigit(*cp))
		altmeters = altmeters * 10 + (*cp++ - '0');

	if (*cp == '.') {		/* decimal meters */
		cp++;
		if (isdigit(*cp)) {
			altfrac = (*cp++ - '0') * 10;
			if (isdigit(*cp)) {
				altfrac += (*cp++ - '0');
			}
		}
	}

	alt = (10000000 + (altsign * (altmeters * 100 + altfrac)));

	while (!isspace(*cp) && (cp < maxcp)) /* if trailing garbage or m */
		cp++;

	while (isspace(*cp) && (cp < maxcp))
		cp++;

	if (cp >= maxcp)
		goto defaults;

	siz = precsize_aton(&cp);
	
	while (!isspace(*cp) && (cp < maxcp))	/* if trailing garbage or m */
		cp++;

	while (isspace(*cp) && (cp < maxcp))
		cp++;

	if (cp >= maxcp)
		goto defaults;

	hp = precsize_aton(&cp);

	while (!isspace(*cp) && (cp < maxcp))	/* if trailing garbage or m */
		cp++;

	while (isspace(*cp) && (cp < maxcp))
		cp++;

	if (cp >= maxcp)
		goto defaults;

	vp = precsize_aton(&cp);

 defaults:

	bcp = binary;
	*bcp++ = (u_int8_t) 0;	/* version byte */
	*bcp++ = siz;
	*bcp++ = hp;
	*bcp++ = vp;
	PUTLONG(latit,bcp);
	PUTLONG(longit,bcp);
	PUTLONG(alt,bcp);
    
	return (16);		/* size of RR in octets */
}

const char *
loc_ntoa(const u_char *binary, char *ascii)
{
	return loc_ntoal(binary, ascii, 255);
}

/* takes an on-the-wire LOC RR and formats it in a human readable format. */
static const char *
loc_ntoal(const u_char *binary, char *ascii, int ascii_len)
{
	static char *error = "?";
	const u_char *cp = binary;

	int latdeg, latmin, latsec, latsecfrac;
	int longdeg, longmin, longsec, longsecfrac;
	char northsouth, eastwest;
	int altmeters, altfrac, altsign;

	const int referencealt = 100000 * 100;

	int32_t latval, longval, altval;
	u_int32_t templ;
	u_int8_t sizeval, hpval, vpval, versionval;
    
	char *sizestr, *hpstr, *vpstr;

	versionval = *cp++;

	if (versionval) {
		snprintf(ascii, ascii_len, "; error: unknown LOC RR version");
		return (ascii);
	}

	sizeval = *cp++;

	hpval = *cp++;
	vpval = *cp++;

	GETLONG(templ, cp);
	latval = (templ - ((unsigned)1<<31));

	GETLONG(templ, cp);
	longval = (templ - ((unsigned)1<<31));

	GETLONG(templ, cp);
	if (templ < referencealt) { /* below WGS 84 spheroid */
		altval = referencealt - templ;
		altsign = -1;
	} else {
		altval = templ - referencealt;
		altsign = 1;
	}

	if (latval < 0) {
		northsouth = 'S';
		latval = -latval;
	} else
		northsouth = 'N';

	latsecfrac = latval % 1000;
	latval = latval / 1000;
	latsec = latval % 60;
	latval = latval / 60;
	latmin = latval % 60;
	latval = latval / 60;
	latdeg = latval;

	if (longval < 0) {
		eastwest = 'W';
		longval = -longval;
	} else
		eastwest = 'E';

	longsecfrac = longval % 1000;
	longval = longval / 1000;
	longsec = longval % 60;
	longval = longval / 60;
	longmin = longval % 60;
	longval = longval / 60;
	longdeg = longval;

	altfrac = altval % 100;
	altmeters = (altval / 100) * altsign;

	if ((sizestr = strdup(precsize_ntoa(sizeval))) == NULL)
		sizestr = error;
	if ((hpstr = strdup(precsize_ntoa(hpval))) == NULL)
		hpstr = error;
	if ((vpstr = strdup(precsize_ntoa(vpval))) == NULL)
		vpstr = error;

	snprintf(ascii, ascii_len,
	      "%d %.2d %.2d.%.3d %c %d %.2d %.2d.%.3d %c %d.%.2dm %sm %sm %sm",
		latdeg, latmin, latsec, latsecfrac, northsouth,
		longdeg, longmin, longsec, longsecfrac, eastwest,
		altmeters, altfrac, sizestr, hpstr, vpstr);

	if (sizestr != error)
		free(sizestr);
	if (hpstr != error)
		free(hpstr);
	if (vpstr != error)
		free(vpstr);

	return (ascii);
}


/* Return the number of DNS hierarchy levels in the name. */
int
__dn_count_labels(char *name)
{
	int i, len, count;

	len = strlen(name);

	for(i = 0, count = 0; i < len; i++) {
		if (name[i] == '.')
			count++;
	}

	/* don't count initial wildcard */
	if (name[0] == '*')
		if (count)
			count--;

	/* don't count the null label for root. */
	/* if terminating '.' not found, must adjust */
	/* count to include last label */
	if (len > 0 && name[len-1] != '.')
		count++;
	return (count);
}


/* 
 * Make dates expressed in seconds-since-Jan-1-1970 easy to read.  
 * SIG records are required to be printed like this, by the Secure DNS RFC.
 */
char *
__p_secstodate (long unsigned int secs)
{
	static char output[15];		/* YYYYMMDDHHMMSS and null */
	time_t clock = secs;
	struct tm *time;
	
	time = gmtime(&clock);
	time->tm_year += 1900;
	time->tm_mon += 1;
	snprintf(output, sizeof output, "%04d%02d%02d%02d%02d%02d",
		time->tm_year, time->tm_mon, time->tm_mday,
		time->tm_hour, time->tm_min, time->tm_sec);
	return (output);
}
@


1.22
log
@use RRSIG instead of SIG for DNSSEC. ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.21 2005/08/06 20:30:04 espie Exp $	*/
@


1.21
log
@zap rcsid.
split functions off res_debug.c so that getnetnamadr.c does not pull it
all when it's used.

okay deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.20 2005/03/30 02:58:28 tedu Exp $	*/
d754 1
@


1.20
log
@make the resolver stat resolv.conf and update if it changes.
useful feedback and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.19 2005/03/25 13:24:12 otto Exp $	*/
a75 9
#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)res_debug.c	8.1 (Berkeley) 6/4/93";
static char rcsid[] = "$From: res_debug.c,v 8.19 1996/11/26 10:11:23 vixie Exp $";
#else
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.19 2005/03/25 13:24:12 otto Exp $";
#endif
#endif /* LIBC_SCCS and not lint */

a829 69
/*
 * Names of RR classes and qclasses.  Classes and qclasses are the same, except
 * that C_ANY is a qclass but not a class.  (You can ask for records of class
 * C_ANY, but you can't have any records of that class in the database.)
 */
const struct res_sym __p_class_syms[] = {
	{C_IN,		"IN"},
	{C_CHAOS,	"CHAOS"},
	{C_HS,		"HS"},
	{C_HS,		"HESIOD"},
	{C_ANY,		"ANY"},
	{C_IN, 		(char *)0}
};

/*
 * Names of RR types and qtypes.  Types and qtypes are the same, except
 * that T_ANY is a qtype but not a type.  (You can ask for records of type
 * T_ANY, but you can't have any records of that type in the database.)
 */
const struct res_sym __p_type_syms[] = {
	{T_A,		"A",		"address"},
	{T_NS,		"NS",		"name server"},
	{T_MD,		"MD",		"mail destination (deprecated)"},
	{T_MF,		"MF",		"mail forwarder (deprecated)"},
	{T_CNAME,	"CNAME",	"canonical name"},
	{T_SOA,		"SOA",		"start of authority"},
	{T_MB,		"MB",		"mailbox"},
	{T_MG,		"MG",		"mail group member"},
	{T_MR,		"MR",		"mail rename"},
	{T_NULL,	"NULL",		"null"},
	{T_WKS,		"WKS",		"well-known service (deprecated)"},
	{T_PTR,		"PTR",		"domain name pointer"},
	{T_HINFO,	"HINFO",	"host information"},
	{T_MINFO,	"MINFO",	"mailbox information"},
	{T_MX,		"MX",		"mail exchanger"},
	{T_TXT,		"TXT",		"text"},
	{T_RP,		"RP",		"responsible person"},
	{T_AFSDB,	"AFSDB",	"DCE or AFS server"},
	{T_X25,		"X25",		"X25 address"},
	{T_ISDN,	"ISDN",		"ISDN address"},
	{T_RT,		"RT",		"router"},
	{T_NSAP,	"NSAP",		"nsap address"},
	{T_NSAP_PTR,	"NSAP_PTR",	"domain name pointer"},
	{T_SIG,		"SIG",		"signature"},
	{T_KEY,		"KEY",		"key"},
	{T_PX,		"PX",		"mapping information"},
	{T_GPOS,	"GPOS",		"geographical position (withdrawn)"},
	{T_AAAA,	"AAAA",		"IPv6 address"},
	{T_LOC,		"LOC",		"location"},
	{T_NXT,		"NXT",		"next valid name (unimplemented)"},
	{T_EID,		"EID",		"endpoint identifier (unimplemented)"},
	{T_NIMLOC,	"NIMLOC",	"NIMROD locator (unimplemented)"},
	{T_SRV,		"SRV",		"server selection"},
	{T_ATMA,	"ATMA",		"ATM address (unimplemented)"},
	{T_IXFR,	"IXFR",		"incremental zone transfer"},
	{T_AXFR,	"AXFR",		"zone transfer"},
	{T_MAILB,	"MAILB",	"mailbox-related data (deprecated)"},
	{T_MAILA,	"MAILA",	"mail agent (deprecated)"},
	{T_UINFO,	"UINFO",	"user information (nonstandard)"},
	{T_UID,		"UID",		"user ID (nonstandard)"},
	{T_GID,		"GID",		"group ID (nonstandard)"},
	{T_NAPTR,	"NAPTR",	"URN Naming Authority"},
#ifdef ALLOW_T_UNSPEC
	{T_UNSPEC,	"UNSPEC",	"unspecified data (nonstandard)"},
#endif /* ALLOW_T_UNSPEC */
	{T_ANY,		"ANY",		"\"any\""},
	{0, 		NULL,		NULL}
};

a844 19
const char *
__sym_ntos(const struct res_sym *syms, int number, int *success)
{
	static char unname[20];

	for (; syms->name != 0; syms++) {
		if (number == syms->number) {
			if (success)
				*success = 1;
			return (syms->name);
		}
	}

	snprintf(unname, sizeof unname, "%d", number);
	if (success)
		*success = 0;
	return (unname);
}

a861 18
}

/*
 * Return a string for the type
 */
const char *
__p_type(int type)
{
	return (__sym_ntos (__p_type_syms, type, (int *)0));
}

/*
 * Return a mnemonic for class
 */
const char *
__p_class(int class)
{
	return (__sym_ntos (__p_class_syms, class, (int *)0));
@


1.19
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.18 2005/03/06 16:17:23 moritz Exp $	*/
d81 1
a81 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.18 2005/03/06 16:17:23 moritz Exp $";
d267 1
a267 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1)
d465 1
a465 1
	if ((_resp->options & RES_INIT) == 0 && res_init() == -1) {
@


1.18
log
@correct snprintf return value checks, where the wrong ptr
was used for calculating the buffer size.

ok tedu@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.17 2003/06/02 20:18:36 millert Exp $	*/
d81 1
a81 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.17 2003/06/02 20:18:36 millert Exp $";
d110 1
a110 2
dewks(wks)
	int wks;
d169 1
a169 2
deproto(protonum)
	int protonum;
d193 2
a194 5
do_rrset(msg, len, cp, cnt, pflag, file, hs)
	int cnt, pflag, len;
	const u_char *cp, *msg;
	const char *hs;
	FILE *file;
d232 1
a232 2
__p_query(msg)
	const u_char *msg;
d242 1
a242 3
__fp_resstat(statp, file)
	struct __res_state *statp;
	FILE *file;
d244 1
a244 1
	register u_long mask;
d260 1
a260 4
__fp_nquery(msg, len, file)
	const u_char *msg;
	int len;
	FILE *file;
d263 3
a265 3
	register const u_char *cp, *endMark;
	register const HEADER *hp;
	register int n;
d386 1
a386 3
__fp_query(msg, file)
	const u_char *msg;
	FILE *file;
d392 1
a392 4
__p_cdnname(cp, msg, len, file)
	const u_char *cp, *msg;
	int len;
	FILE *file;
d407 1
a407 3
__p_cdname(cp, msg, file)
	const u_char *cp, *msg;
	FILE *file;
d417 1
a417 5
__p_fqnname(cp, msg, msglen, name, namelen)
	const u_char *cp, *msg;
	int msglen;
	char *name;
	int namelen;
d437 1
a437 3
__p_fqname(cp, msg, file)
	const u_char *cp, *msg;
	FILE *file;
d453 1
a453 3
__p_rr(cp, msg, file)
	const u_char *cp, *msg;
	FILE *file;
d909 1
a909 4
__sym_ston(syms, name, success)
	const struct res_sym *syms;
	char *name;
	int *success;
d924 1
a924 4
__sym_ntos(syms, number, success)
	const struct res_sym *syms;
	int number;
	int *success;
d944 1
a944 4
__sym_ntop(syms, number, success)
	const struct res_sym *syms;
	int number;
	int *success;
d965 1
a965 2
__p_type(type)
	int type;
d974 1
a974 2
__p_class(class)
	int class;
d983 1
a983 2
__p_option(option)
	u_long option;
d1012 1
a1012 2
p_time(value)
	u_int32_t value;
d1017 1
a1017 1
	register char *p;
d1093 1
a1093 2
precsize_ntoa(prec)
	u_int8_t prec;
d1110 1
a1110 2
precsize_aton(strptr)
	char **strptr;
d1114 3
a1116 3
	register char *cp;
	register int exponent;
	register int mantissa;
d1151 1
a1151 3
latlon2ul(latlonstrptr,which)
	char **latlonstrptr;
	int *which;
d1153 1
a1153 1
	register char *cp;
d1248 1
a1248 3
loc_aton(ascii, binary)
	const char *ascii;
	u_char *binary;
d1357 1
a1357 3
loc_ntoa(binary, ascii)
	const u_char *binary;
	char *ascii;
d1364 1
a1364 4
loc_ntoal(binary, ascii, ascii_len)
	const u_char *binary;
	char *ascii;
	int ascii_len;
d1367 1
a1367 1
	register const u_char *cp = binary;
d1466 1
a1466 2
__dn_count_labels(name)
	char *name;
d1496 1
a1496 2
__p_secstodate (secs)
	unsigned long secs;
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.16 2003/03/04 00:29:17 itojun Exp $	*/
d81 1
a81 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.16 2003/03/04 00:29:17 itojun Exp $";
d1078 1
a1078 1
		    PLURALIZE(days))) >= ebuf - nbuf || tmp < 0)
d1088 1
a1088 1
		    PLURALIZE(hours))) >= ebuf - nbuf || tmp < 0)
d1098 1
a1098 1
		    PLURALIZE(mins))) >= ebuf - nbuf || tmp < 0)
d1108 1
a1108 1
		    PLURALIZE(secs))) >= ebuf - nbuf || tmp < 0)
@


1.16
log
@strlcpy, check retval from sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.15 2003/01/28 04:58:00 marc Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d81 1
a81 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.15 2003/01/28 04:58:00 marc Exp $";
@


1.15
log
@
thread safer libc (note: safer, not safe)
Access to the global _res structure replaced by pointers to a
per thread instance.  If unthreaded the pointer is to the
global structure.

Also replaced a 64k stack array with malloc-ed memory so
threaded aps (with a default 64k stack) have a chance at working.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.14 2002/07/25 21:55:30 deraadt Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.14 2002/07/25 21:55:30 deraadt Exp $";
d451 1
a451 1
		if (newlen+1 >= namelen)	/* Lack space for final dot */
d454 1
a454 1
			strcpy(name + newlen, ".");
@


1.14
log
@more snprintf and strlcpy; help from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.13 2002/06/27 10:14:02 itojun Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.13 2002/06/27 10:14:02 itojun Exp $";
d105 2
d205 1
d212 1
a212 1
	sflag = (_res.pfcode & pflag);
d214 2
a215 2
		if ((!_res.pfcode) ||
		    ((sflag) && (_res.pfcode & RES_PRF_HEAD1)))
d218 1
a218 1
			if ((!_res.pfcode) || sflag) {
d233 2
a234 2
		if ((!_res.pfcode) ||
		    ((sflag) && (_res.pfcode & RES_PRF_HEAD1)))
d277 1
d282 1
a282 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1)
d294 1
a294 1
	if ((!_res.pfcode) || (_res.pfcode & RES_PRF_HEADX) || hp->rcode) {
d301 1
a301 1
	if ((!_res.pfcode) || (_res.pfcode & RES_PRF_HEADX))
d303 1
a303 1
	if ((!_res.pfcode) || (_res.pfcode & RES_PRF_HEAD2)) {
d322 1
a322 1
	if ((!_res.pfcode) || (_res.pfcode & RES_PRF_HEAD1)) {
d328 1
a328 1
	if ((!_res.pfcode) || (_res.pfcode & 
d336 1
a336 1
		if ((!_res.pfcode) || (_res.pfcode & RES_PRF_QUES))
d339 1
a339 1
			if ((!_res.pfcode) || (_res.pfcode & RES_PRF_QUES))
d342 1
a342 1
			if ((!_res.pfcode) || (_res.pfcode & RES_PRF_QUES))
d356 1
a356 1
			if ((!_res.pfcode) || (_res.pfcode & RES_PRF_QUES))
d361 1
a361 1
			if ((!_res.pfcode) || (_res.pfcode & RES_PRF_QUES))
d365 1
a365 1
			if ((!_res.pfcode) || (_res.pfcode & RES_PRF_QUES))
d485 1
d495 1
a495 1
	if ((_res.options & RES_INIT) == 0 && res_init() == -1) {
d513 1
a513 1
	if ((!_res.pfcode) || (_res.pfcode & RES_PRF_TTLID))
d515 1
a515 1
	if ((!_res.pfcode) || (_res.pfcode & RES_PRF_CLASS))
@


1.13
log
@%d -> %u.  mostly in #ifdef DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.12 2002/05/24 21:22:37 deraadt Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.12 2002/05/24 21:22:37 deraadt Exp $";
d108 2
d671 1
a671 1
		fprintf(file, "\t%s", loc_ntoa(cp, t));
d1053 1
d1056 1
d1074 1
d1076 4
a1079 2
		(void)sprintf(p, "%d day%s", PLURALIZE(days));
		while (*++p);
d1084 6
a1089 2
		(void)sprintf(p, "%d hour%s", PLURALIZE(hours));
		while (*++p);
d1094 6
a1099 2
		(void)sprintf(p, "%d min%s", PLURALIZE(mins));
		while (*++p);
d1104 5
a1108 1
		(void)sprintf(p, "%d sec%s", PLURALIZE(secs));
d1111 7
a1399 1
/* takes an on-the-wire LOC RR and formats it in a human readable format. */
d1405 10
d1434 1
a1434 1
		sprintf(ascii, "; error: unknown LOC RR version");
d1496 1
a1496 1
	sprintf(ascii,
@


1.12
log
@try to use strlcpy and snprintf more; ok various
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.11 2001/06/11 10:05:59 itojun Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.11 2001/06/11 10:05:59 itojun Exp $";
d289 1
a289 1
		fprintf(file, ";; ->>HEADER<<- opcode: %s, status: %s, id: %d",
d317 4
a320 4
		fprintf(file, "; Ques: %d", ntohs(hp->qdcount));
		fprintf(file, ", Ans: %d", ntohs(hp->ancount));
		fprintf(file, ", Auth: %d", ntohs(hp->nscount));
		fprintf(file, ", Addit: %d", ntohs(hp->arcount));
d534 1
a534 1
				fprintf(file, "\t%s\t; proto %d, port %d",
d606 1
a606 1
		fprintf(file, "\t%d ", _getshort((u_char*)cp));
d613 1
a613 1
		fprintf(file, "\t%d ", _getshort((u_char*)cp));
d789 1
a789 1
		fprintf(file, "\t%d", *cp++);	/* algorithm */
@


1.11
log
@support EDNS0 (RFC2671) buffer size notification on DNS queries.
"options edns0" in /etc/resolv.conf will enable the behavior.  no behavior
change if you don't have the line.  see resolv.conf(5) for more details.

EDNS0 is useful for avoiding TCP DNS queries/replies on larger DNS responses.
also, draft-ietf-dnsext-message-size-* plans to mandate EDNS0 support for DNS
clients that support IPv6 transport.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.10 2000/07/07 20:59:47 deraadt Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.10 2000/07/07 20:59:47 deraadt Exp $";
d162 3
a164 1
	default: (void) sprintf(nbuf, "%d", wks); return (nbuf);
d188 3
a190 1
	default: (void) sprintf(nbuf, "%d", protonum); return (nbuf);
d443 1
a443 1
	newlen = strlen (name);
d965 1
a965 1
	sprintf (unname, "%d", number);
d987 1
a987 1
	sprintf(unname, "%d", number);
d1037 3
a1039 2
	default:		sprintf(nbuf, "?0x%lx?", (u_long)option);
				return (nbuf);
d1055 1
a1055 1
		strcpy(nbuf, "0 secs");
d1117 1
a1117 1
	(void) sprintf(retbuf, "%ld.%.2ld", val/100, val%100);
d1521 1
a1521 1
	sprintf(output, "%04d%02d%02d%02d%02d%02d",
@


1.10
log
@use %s with fprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.9 1998/03/19 00:30:06 millert Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.9 1998/03/19 00:30:06 millert Exp $";
d1031 2
@


1.9
log
@some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.8 1997/07/09 01:08:51 millert Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.8 1997/07/09 01:08:51 millert Exp $";
d207 1
a207 1
			fprintf(file, hs);
@


1.8
log
@Clean up some -Wall flowers.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.7 1997/04/30 05:54:43 tholo Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.7 1997/04/30 05:54:43 tholo Exp $";
d440 1
a440 1
	if (newlen == 0 || name[newlen - 1] != '.')
d445 1
@


1.7
log
@Remove unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.6 1997/04/05 21:13:16 millert Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.6 1997/04/05 21:13:16 millert Exp $";
d204 1
a204 1
	if (n = ntohs(cnt)) {
d325 1
a325 1
	if (n = ntohs(hp->qdcount)) {
d635 1
a635 1
			if (n = (unsigned char) *cp++) {
d850 2
a851 2
		fprintf(file, ";; packet size error (found %d, dlen was %d)\n",
			cp - cp1, dlen);
d932 1
a932 1
	for (NULL; syms->name != 0; syms++) {
d952 1
a952 1
	for (NULL; syms->name != 0; syms++) {
d975 1
a975 1
	for (NULL; syms->name != 0; syms++) {
@


1.6
log
@Use in_addr_t not u_long and use in_port_t in some cases instead
of u_short or u_int16_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.5 1997/03/13 19:07:37 downsj Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.5 1997/03/13 19:07:37 downsj Exp $";
d1260 1
a1260 1
	const char *cp, *maxcp;
d1262 1
d1272 1
a1272 1
	cp = ascii;
@


1.5
log
@Integrate BIND 4.9.5 resolver and associated routines.

Includes the DNS aware getnetby*() routines and IPv6 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.1 1997/03/12 10:42:09 downsj Exp $	*/
d85 1
a85 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.1 1997/03/12 10:42:09 downsj Exp $";
d521 1
a521 1
				u_short port;
@


1.4
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d1 5
a5 1
/*-
d7 2
a8 2
 *	The Regents of the University of California.  All rights reserved.
 *
d55 22
d81 6
a86 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.3 1996/08/19 08:29:44 tholo Exp $";
d90 2
d95 3
d100 3
a103 1
#include <netdb.h>
d105 2
a106 1
void __fp_query();
d108 2
a109 39
char *_res_opcodes[] = {
	"QUERY",
	"IQUERY",
	"CQUERYM",
	"CQUERYU",	/* experimental */
	"NOTIFY",	/* experimental */
	"5",
	"6",
	"7",
	"8",
	"UPDATEA",
	"UPDATED",
	"UPDATEDA",
	"UPDATEM",
	"UPDATEMA",
	"ZONEINIT",
	"ZONEREF",
};

char *_res_resultcodes[] = {
	"NOERROR",
	"FORMERR",
	"SERVFAIL",
	"NXDOMAIN",
	"NOTIMP",
	"REFUSED",
	"6",
	"7",
	"8",
	"9",
	"10",
	"11",
	"12",
	"13",
	"14",
	"NOCHANGE",
};

static char *
d205 2
a206 1
		if ((!_res.pfcode) || ((sflag) && (_res.pfcode & RES_PRF_HEAD1)))
d214 3
a216 3
				cp += sizeof(u_int16_t);
				cp += sizeof(u_int16_t);
				cp += sizeof(u_int32_t);
d218 1
a218 1
				cp += sizeof(u_int16_t);
d224 2
a225 1
		if ((!_res.pfcode) || ((sflag) && (_res.pfcode & RES_PRF_HEAD1)))
d228 1
a228 1
	return(cp);
d275 1
a275 1
#define TruncTest(x) if (x >= endMark) goto trunc
d283 1
a283 1
	endMark = cp + len;
d285 1
a285 1
		fprintf(file,";; ->>HEADER<<- opcode: %s, status: %s, id: %d",
d294 1
a294 1
		fprintf(file,"; flags:");
d296 1
a296 1
			fprintf(file," qr");
d298 1
a298 1
			fprintf(file," aa");
d300 1
a300 1
			fprintf(file," tc");
d302 1
a302 1
			fprintf(file," rd");
d304 7
a310 1
			fprintf(file," ra");
d313 3
a315 3
		fprintf(file,"; Ques: %d", ntohs(hp->qdcount));
		fprintf(file,", Ans: %d", ntohs(hp->ancount));
		fprintf(file,", Auth: %d", ntohs(hp->nscount));
d327 1
a327 1
			fprintf(file,";; QUESTIONS:\n");
d330 1
a330 1
			fprintf(file,";;\t");
d385 1
a385 1
		return;
d424 24
d457 1
a457 1
	int n;
d459 2
a460 1
	if ((n = dn_expand(msg, cp + MAXCDNAME, cp, name, sizeof name)) < 0)
d462 2
a463 8
	if (name[0] == '\0') {
		putc('.', file);
	} else {
		fputs(name, file);
		if (name[strlen(name) - 1] != '.')
			putc('.', file);
	}
	return (cp + n);
d479 3
d487 2
a488 1
	if ((cp = p_fqname(cp, msg, file)) == NULL)
d490 10
a499 8
	type = _getshort(cp);
	cp += sizeof(u_int16_t);
	class = _getshort(cp);
	cp += sizeof(u_int16_t);
	tmpttl = _getlong(cp);
	cp += sizeof(u_int32_t);
	dlen = _getshort(cp);
	cp += sizeof(u_int16_t);
d514 1
a514 1
			bcopy(cp, (char *)&inaddr, sizeof(inaddr));
d516 1
a516 1
				fprintf(file,"\t%s", inet_ntoa(inaddr));
d524 5
a528 5
				cp += sizeof(inaddr);
				protocol = *cp;
				cp += sizeof(u_char);
				port = _getshort(cp);
				cp += sizeof(u_int16_t);
d551 19
a569 8
		if (n = *cp++) {
			fprintf(file,"\t%.*s", n, cp);
			cp += n;
		}
		if ((cp < cp2) && (n = *cp++)) {
			fprintf(file,"\t%.*s", n, cp);
			cp += n;
		} else if (type == T_HINFO)
d571 1
d582 1
a582 1
		t = _getlong(cp);  cp += sizeof(u_int32_t);
d584 1
a584 1
		t = _getlong(cp);  cp += sizeof(u_int32_t);
d587 1
a587 1
		t = _getlong(cp);  cp += sizeof(u_int32_t);
d590 1
a590 1
		t = _getlong(cp);  cp += sizeof(u_int32_t);
d593 1
a593 1
		t = _getlong(cp);  cp += sizeof(u_int32_t);
d601 1
a601 1
		fprintf(file, "\t%d ", _getshort(cp));
d608 1
a608 1
		fprintf(file, "\t%d ", _getshort(cp));
a616 1
  	case T_TXT:
d618 1
d620 12
d634 1
d636 5
a640 6
				for (c = n; c > 0 && cp < cp2; c--)
					if ((*cp == '\n') || (*cp == '"')) {
					    (void) putc('\\', file);
					    (void) putc(*cp++, file);
					} else
					    (void) putc(*cp++, file);
d642 3
d646 1
a646 2
		putc('"', file);
  		break;
d653 51
d716 1
a716 1
		fputs((char *) cp, file);
d723 2
a724 2
			fprintf(file,"\t%u", _getlong(cp));
			cp += sizeof(int32_t);
d729 1
a729 1
		if (dlen < sizeof(u_int32_t) + 1)
d731 2
a732 2
		bcopy(cp, (char *)&inaddr, sizeof(inaddr));
		cp += sizeof(u_int32_t);
d736 1
a736 1
		cp += sizeof(u_char);
d742 1
a742 1
 				if (c & 0200) {
d751 1
a751 1
 				c <<= 1;
d757 66
d841 1
a841 1
		fprintf(file,"\t?%d?", type);
d850 1
a850 1
		fprintf(file,";; packet size error (found %d, dlen was %d)\n",
d858 131
d995 1
a995 42
	static char nbuf[20];

	switch (type) {
	case T_A:	return "A";
	case T_NS:	return "NS";
	case T_CNAME:	return "CNAME";
	case T_SOA:	return "SOA";
	case T_MB:	return "MB";
	case T_MG:	return "MG";
	case T_MR:	return "MR";
	case T_NULL:	return "NULL";
	case T_WKS:	return "WKS";
	case T_PTR:	return "PTR";
	case T_HINFO:	return "HINFO";
	case T_MINFO:	return "MINFO";
	case T_MX:	return "MX";
	case T_TXT:	return "TXT";
	case T_RP:	return "RP";
	case T_AFSDB:	return "AFSDB";
	case T_X25:	return "X25";
	case T_ISDN:	return "ISDN";
	case T_RT:	return "RT";
	case T_NSAP:	return "NSAP";
	case T_NSAP_PTR: return "NSAP_PTR";
	case T_SIG:	return "SIG";
	case T_KEY:	return "KEY";
	case T_PX:	return "PX";
	case T_GPOS:	return "GPOS";
	case T_AAAA:	return "AAAA";
	case T_LOC:	return "LOC";
	case T_AXFR:	return "AXFR";
	case T_MAILB:	return "MAILB";
	case T_MAILA:	return "MAILA";
	case T_ANY:	return "ANY";
	case T_UINFO:	return "UINFO";
	case T_UID:	return "UID";
	case T_GID:	return "GID";
#ifdef ALLOW_T_UNSPEC
	case T_UNSPEC:	return "UNSPEC";
#endif /* ALLOW_T_UNSPEC */
	default:	(void)sprintf(nbuf, "%d", type); return (nbuf);
	}
d1005 1
a1005 8
	static char nbuf[20];

	switch (class) {
	case C_IN:	return "IN";
	case C_HS:	return "HS";
	case C_ANY:	return "ANY";
	default:	(void)sprintf(nbuf, "%d", class); return (nbuf);
	}
d1038 2
a1039 2
char *
__p_time(value)
d1048 1
a1048 1
		return(nbuf);
d1083 433
a1515 1
	return(nbuf);
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d55 1
a55 1
static char rcsid[] = "$OpenBSD: res_debug.c,v 1.8 1996/02/02 15:22:27 mrg Exp $";
d604 1
a604 1
		fputs(cp, file);
@


1.2
log
@netbsd: bind 4.9.3
@
text
@a0 2
/*	$NetBSD: res_debug.c,v 1.8 1996/02/02 15:22:27 mrg Exp $	*/

d55 1
a55 6
#if 0
static char sccsid[] = "@@(#)res_debug.c	8.1 (Berkeley) 6/4/93";
static char rcsid[] = "$Id: res_debug.c,v 8.7 1995/12/22 10:20:39 vixie Exp ";
#else
static char rcsid[] = "$NetBSD: res_debug.c,v 1.8 1996/02/02 15:22:27 mrg Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: res_debug.c,v 1.7 1995/02/25 06:20:56 cgd Exp $	*/
d59 1
d61 1
a61 1
static char rcsid[] = "$NetBSD: res_debug.c,v 1.7 1995/02/25 06:20:56 cgd Exp $";
d72 1
a74 3
char *__p_class(), *__p_time(), *__p_type();
char *p_cdname(), *p_fqname(), *p_rr();
static char *p_option __P((u_int32_t));
d80 2
a81 2
	"CQUERYU",
	"4",
a113 2
static char retbuf[16];

d118 2
d121 47
a167 47
	case 5: return("rje");
	case 7: return("echo");
	case 9: return("discard");
	case 11: return("systat");
	case 13: return("daytime");
	case 15: return("netstat");
	case 17: return("qotd");
	case 19: return("chargen");
	case 20: return("ftp-data");
	case 21: return("ftp");
	case 23: return("telnet");
	case 25: return("smtp");
	case 37: return("time");
	case 39: return("rlp");
	case 42: return("name");
	case 43: return("whois");
	case 53: return("domain");
	case 57: return("apts");
	case 59: return("apfs");
	case 67: return("bootps");
	case 68: return("bootpc");
	case 69: return("tftp");
	case 77: return("rje");
	case 79: return("finger");
	case 87: return("link");
	case 95: return("supdup");
	case 100: return("newacct");
	case 101: return("hostnames");
	case 102: return("iso-tsap");
	case 103: return("x400");
	case 104: return("x400-snd");
	case 105: return("csnet-ns");
	case 109: return("pop-2");
	case 111: return("sunrpc");
	case 113: return("auth");
	case 115: return("sftp");
	case 117: return("uucp-path");
	case 119: return("nntp");
	case 121: return("erpc");
	case 123: return("ntp");
	case 133: return("statsrv");
	case 136: return("profile");
	case 144: return("NeWS");
	case 161: return("snmp");
	case 162: return("snmp-trap");
	case 170: return("print-srv");
	default: (void) sprintf(retbuf, "%d", wks); return(retbuf);
d171 2
a172 1
static char *
d176 2
d179 13
a191 13
	case 1: return("icmp");
	case 2: return("igmp");
	case 3: return("ggp");
	case 5: return("st");
	case 6: return("tcp");
	case 7: return("ucl");
	case 8: return("egp");
	case 9: return("igp");
	case 11: return("nvp-II");
	case 12: return("pup");
	case 16: return("chaos");
	case 17: return("udp");
	default: (void) sprintf(retbuf, "%d", protonum); return(retbuf);
d195 5
a199 4
static char *
do_rrset(msg, cp, cnt, pflag, file, hs)
	int cnt, pflag;
	char *cp,*msg, *hs;
d204 1
d206 1
a206 1
	 * Print  answer records
d213 13
a225 2
			cp = p_rr(cp, msg, file);
			if ((cp-msg) > PACKETSZ)
d234 1
d236 1
a236 1
	char *msg;
d250 1
a250 1
	int bit;
d255 3
a257 4
	for (bit = 0;  bit < 32;  bit++) {	/* XXX 32 - bad assumption! */
		if (statp->options & (1<<bit))
			fprintf(file, " %s", p_option(1<<bit));
	}
d266 3
a268 2
__fp_query(msg,file)
	char *msg;
d271 2
a272 2
	register char *cp;
	register HEADER *hp;
d275 6
d285 2
a286 1
	cp = msg + sizeof(HEADER);
d294 2
a295 1
	putc(';', file);
a307 2
		if (hp->pr)
			fprintf(file," pr");
d313 1
a313 1
		fprintf(file,", Addit: %d\n", ntohs(hp->arcount));
d315 2
a316 2
#if 0
	if (_res.pfcode & (RES_PRF_HEADX | RES_PRF_HEAD2 | RES_PRF_HEAD1)) {
a318 1
#endif
d326 1
d328 15
a342 3
			cp = p_cdname(cp, msg, file);
			if (cp == NULL)
				return;
d345 7
a351 2
					__p_type(_getshort(cp)));
			cp += sizeof(u_int16_t);
d353 1
a353 3
				fprintf(file, ", class = %s\n\n",
					__p_class(_getshort(cp)));
			cp += sizeof(u_int16_t);
d359 2
a360 1
	cp = do_rrset(msg, cp, hp->ancount, RES_PRF_ANS, file,
d362 1
a362 2
	if (cp == NULL)
		return;
d367 2
a368 1
	cp = do_rrset(msg, cp, hp->nscount, RES_PRF_AUTH, file,
d370 1
a370 2
	if (!cp)
		return;
d372 1
d376 1
a376 1
	cp = do_rrset(msg, cp, hp->arcount, RES_PRF_ADD, file,
d378 4
a381 1
	if (!cp)
d383 2
d387 12
a398 3
char *
p_cdname(cp, msg, file)
	char *cp, *msg;
d404 1
a404 2
	if ((n = dn_expand((u_char *)msg, (u_char *)cp + MAXCDNAME,
	    (u_char *)cp, (u_char *)name, sizeof(name))) < 0)
d413 14
a426 3
char *
p_fqname(cp, msg, file)
	char *cp, *msg;
d430 1
a430 1
	int n, len;
d432 1
a432 2
	if ((n = dn_expand((u_char *)msg, (u_char *)cp + MAXCDNAME,
	    (u_char *)cp, (u_char *)name, sizeof(name))) < 0)
d447 3
a449 3
char *
p_rr(cp, msg, file)
	char *cp, *msg;
d454 1
a454 1
	char *cp1, *cp2;
d458 4
d474 1
a474 1
		fprintf(file, "\t%lu", tmpttl);
d497 1
a497 1
				protocol = *(u_char*)cp;
d516 2
a517 1
		cp = p_fqname(cp, msg, file);
d521 2
d527 1
a527 1
		if (n = *cp++) {
d530 2
a531 1
		}
d536 2
a537 1
		cp = p_fqname(cp, msg, file);	/* origin */
d539 2
a540 1
		cp = p_fqname(cp, msg, file);	/* mail addr */
d543 1
a543 1
		fprintf(file,"\t\t\t%lu\t; serial\n", t);
d545 2
a546 1
		fprintf(file,"\t\t\t%lu\t; refresh (%s)\n", t, __p_time(t));
d548 2
a549 1
		fprintf(file,"\t\t\t%lu\t; retry (%s)\n", t, __p_time(t));
d551 2
a552 1
		fprintf(file,"\t\t\t%lu\t; expire (%s)\n", t, __p_time(t));
d554 2
a555 1
		fprintf(file,"\t\t\t%lu )\t; minimum (%s)", t, __p_time(t));
d560 15
a574 3
		fprintf(file,"\t%d ", _getshort(cp));
		cp += sizeof(u_int16_t);
		cp = p_fqname(cp, msg, file);
d578 1
d584 1
a584 1
					if (*cp == '\n') {
d594 5
d602 2
a603 1
		cp = p_fqname(cp, msg, file);
d605 2
a606 1
		cp = p_fqname(cp, msg, file);
d656 1
a656 1
			char *DataPtr;
a685 2
static	char nbuf[40];

d689 1
a689 1
char *
d693 2
d696 34
a729 46
	case T_A:
		return("A");
	case T_NS:		/* authoritative server */
		return("NS");
	case T_CNAME:		/* canonical name */
		return("CNAME");
	case T_SOA:		/* start of authority zone */
		return("SOA");
	case T_MB:		/* mailbox domain name */
		return("MB");
	case T_MG:		/* mail group member */
		return("MG");
	case T_MR:		/* mail rename name */
		return("MR");
	case T_NULL:		/* null resource record */
		return("NULL");
	case T_WKS:		/* well known service */
		return("WKS");
	case T_PTR:		/* domain name pointer */
		return("PTR");
	case T_HINFO:		/* host information */
		return("HINFO");
	case T_MINFO:		/* mailbox information */
		return("MINFO");
	case T_MX:		/* mail routing info */
		return("MX");
	case T_TXT:		/* text */
		return("TXT");
	case T_RP:		/* responsible person */
		return("RP");
	case T_AFSDB:		/* AFS cell database */
		return("AFSDB");
	case T_AXFR:		/* zone transfer */
		return("AXFR");
	case T_MAILB:		/* mail box */
		return("MAILB");
	case T_MAILA:		/* mail address */
		return("MAILA");
	case T_ANY:		/* matches any type */
		return("ANY");
	case T_UINFO:
		return("UINFO");
	case T_UID:
		return("UID");
	case T_GID:
		return("GID");
d731 1
a731 2
	case T_UNSPEC:
		return("UNSPEC");
d733 1
a733 4

	default:
		(void)sprintf(nbuf, "%d", type);
		return(nbuf);
d740 1
a740 1
char *
d744 1
d747 4
a750 9
	case C_IN:		/* internet class */
		return("IN");
	case C_HS:		/* hesiod class */
		return("HS");
	case C_ANY:		/* matches any class */
		return("ANY");
	default:
		(void)sprintf(nbuf, "%d", class);
		return(nbuf);
d757 3
a759 3
static char *
p_option(option)
	u_int32_t option;
d761 2
d766 1
a766 1
	case RES_AAONLY:	return "aaonly";
d768 1
a768 1
	case RES_PRIMARY:	return "primry";
d774 4
a777 1
	default:		sprintf(nbuf, "?0x%x?", option); return nbuf;
d788 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

