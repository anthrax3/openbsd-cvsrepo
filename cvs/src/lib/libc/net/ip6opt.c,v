head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.4.0.28
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.26
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.24
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.22
	OPENBSD_5_0:1.4.0.20
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.18
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.16
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.12
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.14
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.10
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.8
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.6
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.4
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.1.0.22
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.20
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.18
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.16
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.14
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.12
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.10
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.8
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.6
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.4
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	0DYulI8hhujBHMcR;

1.7
date	2014.06.13.15.41.06;	author chrisz;	state Exp;
branches;
next	1.6;
commitid	2pcnaP7uM5ZWrvRB;

1.6
date	2014.02.17.21.05.39;	author stsp;	state Exp;
branches;
next	1.5;

1.5
date	2014.02.07.09.50.04;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.08.21.32.59;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	99.12.11.08.09.11;	author itojun;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@/*	$OpenBSD: ip6opt.c,v 1.7 2014/06/13 15:41:06 chrisz Exp $	*/
/*	$KAME: ip6opt.c,v 1.18 2005/06/15 07:11:35 keiichi Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <netinet/ip6.h>

#include <string.h>
#include <stdio.h>

static int ip6optlen(u_int8_t *opt, u_int8_t *lim);

/*
 * Calculate the length of a given IPv6 option. Also checks
 * if the option is safely stored in user's buffer according to the
 * calculated length and the limitation of the buffer.
 */
static int
ip6optlen(u_int8_t *opt, u_int8_t *lim)
{
	int optlen;

	if (*opt == IP6OPT_PAD1)
		optlen = 1;
	else {
		/* is there enough space to store type and len? */
		if (opt + 2 > lim)
			return (0);
		optlen = *(opt + 1) + 2;
	}
	if (opt + optlen <= lim)
		return (optlen);

	return (0);
}

/*
 * The following functions are defined in RFC3542, which is a successor
 * of RFC2292.
 */

int
inet6_opt_init(void *extbuf, socklen_t extlen)
{
	struct ip6_ext *ext = (struct ip6_ext *)extbuf;

	if (ext) {
		if (extlen <= 0 || (extlen % 8))
			return (-1);
		ext->ip6e_len = (extlen >> 3) - 1;
	}

	return (2);		/* sizeof the next and the length fields */
}

int
inet6_opt_append(void *extbuf, socklen_t extlen, int offset, u_int8_t type,
		 socklen_t len, u_int8_t align, void **databufp)
{
	int currentlen = offset, padlen = 0;

	/*
	 * The option type must have a value from 2 to 255, inclusive.
	 * (0 and 1 are reserved for the Pad1 and PadN options, respectively.)
	 */
#if 0 /* always false */
	if (type < 2 || type > 255)
#else
	if (type < 2)
#endif
		return (-1);

	/*
	 * The option data length must have a value between 0 and 255,
	 * inclusive, and is the length of the option data that follows.
	 */
	if (len < 0 || len > 255)
		return (-1);

	/*
	 * The align parameter must have a value of 1, 2, 4, or 8.
	 * The align value can not exceed the value of len.
	 */
	if (align != 1 && align != 2 && align != 4 && align != 8)
		return (-1);
	if (align > len)
		return (-1);

	/* Calculate the padding length. */
	currentlen += 2 + len;	/* 2 means "type + len" */
	if (currentlen % align)
		padlen = align - (currentlen % align);

	/* The option must fit in the extension header buffer. */
	currentlen += padlen;
	if (extlen &&		/* XXX: right? */
	    currentlen > extlen)
		return (-1);

	if (extbuf) {
		u_int8_t *optp = (u_int8_t *)extbuf + offset;

		if (padlen == 1) {
			/* insert a Pad1 option */
			*optp = IP6OPT_PAD1;
			optp++;
		} else if (padlen > 0) {
			/* insert a PadN option for alignment */
			*optp++ = IP6OPT_PADN;
			*optp++ = padlen - 2;
			memset(optp, 0, padlen - 2);
			optp += (padlen - 2);
		}

		*optp++ = type;
		*optp++ = len;

		*databufp = optp;
	}

	return (currentlen);
}

int
inet6_opt_finish(void *extbuf, socklen_t extlen, int offset)
{
	int updatelen = offset > 0 ? (1 + ((offset - 1) | 7)) : 0;;

	if (extbuf) {
		u_int8_t *padp;
		int padlen = updatelen - offset;

		if (updatelen > extlen)
			return (-1);

		padp = (u_int8_t *)extbuf + offset;
		if (padlen == 1)
			*padp = IP6OPT_PAD1;
		else if (padlen > 0) {
			*padp++ = IP6OPT_PADN;
			*padp++ = (padlen - 2);
			memset(padp, 0, padlen - 2);
		}
	}

	return (updatelen);
}

int
inet6_opt_set_val(void *databuf, int offset, void *val, socklen_t vallen)
{

	memcpy((u_int8_t *)databuf + offset, val, vallen);
	return (offset + vallen);
}

int
inet6_opt_next(void *extbuf, socklen_t extlen, int offset, u_int8_t *typep,
	       socklen_t *lenp, void **databufp)
{
	u_int8_t *optp, *lim;
	int optlen;

	/* Validate extlen. XXX: is the variable really necessary?? */
	if (extlen == 0 || (extlen % 8))
		return (-1);
	lim = (u_int8_t *)extbuf + extlen;

	/*
	 * If this is the first time this function called for this options
	 * header, simply return the 1st option.
	 * Otherwise, search the option list for the next option.
	 */
	if (offset == 0)
		optp = (u_int8_t *)((struct ip6_hbh *)extbuf + 1);
	else
		optp = (u_int8_t *)extbuf + offset;

	/* Find the next option skipping any padding options. */
	while (optp < lim) {
		switch(*optp) {
		case IP6OPT_PAD1:
			optp++;
			break;
		case IP6OPT_PADN:
			if ((optlen = ip6optlen(optp, lim)) == 0)
				goto optend;
			optp += optlen;
			break;
		default:	/* found */
			if ((optlen = ip6optlen(optp, lim)) == 0)
				goto optend;
			*typep = *optp;
			*lenp = optlen - 2;
			*databufp = optp + 2;
			return (optp + optlen - (u_int8_t *)extbuf);
		}
	}

  optend:
	*databufp = NULL; /* for safety */
	return (-1);
}

int
inet6_opt_find(void *extbuf, socklen_t extlen, int offset, u_int8_t type,
	       socklen_t *lenp, void **databufp)
{
	u_int8_t *optp, *lim;
	int optlen;

	/* Validate extlen. XXX: is the variable really necessary?? */
	if (extlen == 0 || (extlen % 8))
		return (-1);
	lim = (u_int8_t *)extbuf + extlen;

	/*
	 * If this is the first time this function called for this options
	 * header, simply return the 1st option.
	 * Otherwise, search the option list for the next option.
	 */
	if (offset == 0)
		optp = (u_int8_t *)((struct ip6_hbh *)extbuf + 1);
	else
		optp = (u_int8_t *)extbuf + offset;

	/* Find the specified option */
	while (optp < lim) {
		if ((optlen = ip6optlen(optp, lim)) == 0)
			goto optend;

		if (*optp == type) { /* found */
			*lenp = optlen - 2;
			*databufp = optp + 2;
			return (optp + optlen - (u_int8_t *)extbuf);
		}

		optp += optlen;
	}

  optend:
	*databufp = NULL; /* for safety */
	return (-1);
}

int
inet6_opt_get_val(void *databuf, int offset, void *val, socklen_t vallen)
{

	/* we can't assume alignment here */
	memcpy(val, (u_int8_t *)databuf + offset, vallen);

	return (offset + vallen);
}
@


1.7
log
@Remove deprecated RFC2292 ancillary data convenience functions.
They are obsoleted by the RFC3542 api.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6opt.c,v 1.6 2014/02/17 21:05:39 stsp Exp $	*/
a32 1
#include <sys/param.h>
@


1.6
log
@replace spaces with tabs for indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6opt.c,v 1.5 2014/02/07 09:50:04 mpi Exp $	*/
a43 290
static void inet6_insert_padopt(u_char *p, int len);

/*
 * This function returns the number of bytes required to hold an option
 * when it is stored as ancillary data, including the cmsghdr structure
 * at the beginning, and any padding at the end (to make its size a
 * multiple of 8 bytes).  The argument is the size of the structure
 * defining the option, which must include any pad bytes at the
 * beginning (the value y in the alignment term "xn + y"), the type
 * byte, the length byte, and the option data.
 */
int
inet6_option_space(int nbytes)
{
	nbytes += 2;	/* we need space for nxt-hdr and length fields */
	return (CMSG_SPACE((nbytes + 7) & ~7));
}

/*
 * This function is called once per ancillary data object that will
 * contain either Hop-by-Hop or Destination options.  It returns 0 on
 * success or -1 on an error.
 */
int
inet6_option_init(void *bp, struct cmsghdr **cmsgp, int type)
{
	struct cmsghdr *ch = (struct cmsghdr *)bp;

	/* argument validation */
	if (type != IPV6_HOPOPTS && type != IPV6_DSTOPTS)
		return (-1);
	
	ch->cmsg_level = IPPROTO_IPV6;
	ch->cmsg_type = type;
	ch->cmsg_len = CMSG_LEN(0);

	*cmsgp = ch;
	return (0);
}

/*
 * This function appends a Hop-by-Hop option or a Destination option
 * into an ancillary data object that has been initialized by
 * inet6_option_init().  This function returns 0 if it succeeds or -1 on
 * an error.
 * multx is the value x in the alignment term "xn + y" described
 * earlier.  It must have a value of 1, 2, 4, or 8.
 * plusy is the value y in the alignment term "xn + y" described
 * earlier.  It must have a value between 0 and 7, inclusive.
 */
int
inet6_option_append(struct cmsghdr *cmsg, const u_int8_t *typep, int multx,
    int plusy)
{
	int padlen, optlen, off;
	u_char *bp = (u_char *)cmsg + cmsg->cmsg_len;
	struct ip6_ext *eh = (struct ip6_ext *)CMSG_DATA(cmsg);

	/* argument validation */
	if (multx != 1 && multx != 2 && multx != 4 && multx != 8)
		return (-1);
	if (plusy < 0 || plusy > 7)
		return (-1);
#if 0
	if (typep[0] > 255)
		return (-1);
#endif

	/*
	 * If this is the first option, allocate space for the
	 * first 2 bytes(for next header and length fields) of
	 * the option header.
	 */
	if (bp == (u_char *)eh) {
		bp += 2;
		cmsg->cmsg_len += 2;
	}

	/* calculate pad length before the option. */
	off = bp - (u_char *)eh;
	padlen = (((off % multx) + (multx - 1)) & ~(multx - 1)) -
		(off % multx);
	padlen += plusy;
	padlen %= multx;	/* keep the pad as short as possible */
	/* insert padding */
	inet6_insert_padopt(bp, padlen);
	cmsg->cmsg_len += padlen;
	bp += padlen;

	/* copy the option */
	if (typep[0] == IP6OPT_PAD1)
		optlen = 1;
	else
		optlen = typep[1] + 2;
	memcpy(bp, typep, optlen);
	bp += optlen;
	cmsg->cmsg_len += optlen;

	/* calculate pad length after the option and insert the padding */
	off = bp - (u_char *)eh;
	padlen = ((off + 7) & ~7) - off;
	inet6_insert_padopt(bp, padlen);
	bp += padlen;
	cmsg->cmsg_len += padlen;

	/* update the length field of the ip6 option header */
	eh->ip6e_len = ((bp - (u_char *)eh) >> 3) - 1;

	return (0);
}

/*
 * This function appends a Hop-by-Hop option or a Destination option
 * into an ancillary data object that has been initialized by
 * inet6_option_init().  This function returns a pointer to the 8-bit
 * option type field that starts the option on success, or NULL on an
 * error.
 * The difference between this function and inet6_option_append() is
 * that the latter copies the contents of a previously built option into
 * the ancillary data object while the current function returns a
 * pointer to the space in the data object where the option's TLV must
 * then be built by the caller.
 * 
 */
u_int8_t *
inet6_option_alloc(struct cmsghdr *cmsg, int datalen, int multx, int plusy)
{
	int padlen, off;
	u_int8_t *bp = (u_char *)cmsg + cmsg->cmsg_len;
	u_int8_t *retval;
	struct ip6_ext *eh = (struct ip6_ext *)CMSG_DATA(cmsg);

	/* argument validation */
	if (multx != 1 && multx != 2 && multx != 4 && multx != 8)
		return (NULL);
	if (plusy < 0 || plusy > 7)
		return (NULL);

	/*
	 * If this is the first option, allocate space for the
	 * first 2 bytes(for next header and length fields) of
	 * the option header.
	 */
	if (bp == (u_char *)eh) {
		bp += 2;
		cmsg->cmsg_len += 2;
	}

	/* calculate pad length before the option. */
	off = bp - (u_char *)eh;
	padlen = (((off % multx) + (multx - 1)) & ~(multx - 1)) -
		(off % multx);
	padlen += plusy;
	padlen %= multx;	/* keep the pad as short as possible */
	/* insert padding */
	inet6_insert_padopt(bp, padlen);
	cmsg->cmsg_len += padlen;
	bp += padlen;

	/* keep space to store specified length of data */
	retval = bp;
	bp += datalen;
	cmsg->cmsg_len += datalen;

	/* calculate pad length after the option and insert the padding */
	off = bp - (u_char *)eh;
	padlen = ((off + 7) & ~7) - off;
	inet6_insert_padopt(bp, padlen);
	bp += padlen;
	cmsg->cmsg_len += padlen;

	/* update the length field of the ip6 option header */
	eh->ip6e_len = ((bp - (u_char *)eh) >> 3) - 1;

	return (retval);
}

/*
 * This function processes the next Hop-by-Hop option or Destination
 * option in an ancillary data object.  If another option remains to be
 * processed, the return value of the function is 0 and *tptrp points to
 * the 8-bit option type field (which is followed by the 8-bit option
 * data length, followed by the option data).  If no more options remain
 * to be processed, the return value is -1 and *tptrp is NULL.  If an
 * error occurs, the return value is -1 and *tptrp is not NULL.
 * (RFC 2292, 6.3.5)
 */
int
inet6_option_next(const struct cmsghdr *cmsg, u_int8_t **tptrp)
{
	struct ip6_ext *ip6e;
	int hdrlen, optlen;
	u_int8_t *lim;

	if (cmsg->cmsg_level != IPPROTO_IPV6 ||
	    (cmsg->cmsg_type != IPV6_HOPOPTS &&
	     cmsg->cmsg_type != IPV6_DSTOPTS))
		return (-1);

	/* message length validation */
	if (cmsg->cmsg_len < CMSG_SPACE(sizeof(struct ip6_ext)))
		return (-1);
	ip6e = (struct ip6_ext *)CMSG_DATA(cmsg);
	hdrlen = (ip6e->ip6e_len + 1) << 3;
	if (cmsg->cmsg_len < CMSG_SPACE(hdrlen))
		return (-1);

	/*
	 * If the caller does not specify the starting point,
	 * simply return the 1st option.
	 * Otherwise, search the option list for the next option.
	 */
	lim = (u_int8_t *)ip6e + hdrlen;
	if (*tptrp == NULL)
		*tptrp = (u_int8_t *)(ip6e + 1);
	else {
		if ((optlen = ip6optlen(*tptrp, lim)) == 0)
			return (-1);

		*tptrp = *tptrp + optlen;
	}
	if (*tptrp >= lim) {	/* there is no option */
		*tptrp = NULL;
		return (-1);
	}
	/*
	 * Finally, checks if the next option is safely stored in the
	 * cmsg data.
	 */
	if (ip6optlen(*tptrp, lim) == 0)
		return (-1);
	else
		return (0);
}

/*
 * This function is similar to the inet6_option_next() function,
 * except this function lets the caller specify the option type to be
 * searched for, instead of always returning the next option in the
 * ancillary data object.
 * Note: RFC 2292 says the type of tptrp is u_int8_t *, but we think
 *       it's a typo. The variable should be type of u_int8_t **.
 */
int
inet6_option_find(const struct cmsghdr *cmsg, u_int8_t **tptrp, int type)
{
	struct ip6_ext *ip6e;
	int hdrlen, optlen;
	u_int8_t *optp, *lim;

	if (cmsg->cmsg_level != IPPROTO_IPV6 ||
	    (cmsg->cmsg_type != IPV6_HOPOPTS &&
	     cmsg->cmsg_type != IPV6_DSTOPTS))
		return (-1);

	/* message length validation */
	if (cmsg->cmsg_len < CMSG_SPACE(sizeof(struct ip6_ext)))
		return (-1);
	ip6e = (struct ip6_ext *)CMSG_DATA(cmsg);
	hdrlen = (ip6e->ip6e_len + 1) << 3;
	if (cmsg->cmsg_len < CMSG_SPACE(hdrlen))
		return (-1);	

	/*
	 * If the caller does not specify the starting point,
	 * search from the beginning of the option list.
	 * Otherwise, search from *the next option* of the specified point.
	 */
	lim = (u_int8_t *)ip6e + hdrlen;
	if (*tptrp == NULL)
		*tptrp = (u_int8_t *)(ip6e + 1);
	else {
		if ((optlen = ip6optlen(*tptrp, lim)) == 0)
			return (-1);

		*tptrp = *tptrp + optlen;
	}
	for (optp = *tptrp; optp < lim; optp += optlen) {
		if (*optp == type) {
			*tptrp = optp;
			return (0);
		}
		if ((optlen = ip6optlen(optp, lim)) == 0)
			return (-1);
	}

	/* search failed */
	*tptrp = NULL;
	return (-1);
}
a66 17
}

static void
inet6_insert_padopt(u_char *p, int len)
{
	switch(len) {
	 case 0:
		 return;
	 case 1:
		 p[0] = IP6OPT_PAD1;
		 return;
	 default:
		 p[0] = IP6OPT_PADN;
		 p[1] = len - 2; 
		 memset(&p[2], 0, len - 2);
		 return;
	}
@


1.5
log
@Fix inet6_opt_init() to only check extlen when extbuff is not NULL
as per RFC 3542, from DragonFlyBSD via Eitan Adler.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6opt.c,v 1.4 2006/12/09 01:12:28 itojun Exp $	*/
d387 1
a387 1
               if (extlen <= 0 || (extlen % 8))
@


1.4
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6opt.c,v 1.3 2006/12/08 21:32:59 itojun Exp $	*/
a385 3
	if (extlen < 0 || (extlen % 8))
		return (-1);

d387 1
a387 1
		if (extlen == 0)
@


1.3
log
@return is not a function. (cosmetic)
@
text
@d1 2
a2 1
/*	$OpenBSD: ip6opt.c,v 1.2 2005/03/25 13:24:12 otto Exp $	*/
d107 1
d110 1
d374 222
@


1.2
log
@ansify. ok deraadt@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6opt.c,v 1.1 1999/12/11 08:09:11 itojun Exp $	*/
d58 1
a58 1
	return(CMSG_SPACE((nbytes + 7) & ~7));
d73 1
a73 1
		return(-1);
d80 1
a80 1
	return(0);
d103 1
a103 1
		return(-1);
d105 1
a105 1
		return(-1);
d107 1
a107 1
		return(-1);
d149 1
a149 1
	return(0);
d175 1
a175 1
		return(NULL);
d177 1
a177 1
		return(NULL);
d215 1
a215 1
	return(retval);
d238 1
a238 1
		return(-1);
d242 1
a242 1
		return(-1);
d246 1
a246 1
		return(-1);
d258 1
a258 1
			return(-1);
d264 1
a264 1
		return(-1);
d271 1
a271 1
		return(-1);
d273 1
a273 1
		return(0);
d294 1
a294 1
		return(-1);
d298 1
a298 1
		return(-1);
d302 1
a302 1
		return(-1);	
d314 1
a314 1
			return(-1);
d321 1
a321 1
			return(0);
d324 1
a324 1
			return(-1);
d329 1
a329 1
	return(-1);
d347 1
a347 1
			return(0);
d351 1
a351 1
		return(optlen);
d353 1
a353 1
	return(0);
@


1.1
log
@add inet6_option_* and inet6_rthdr_*.
increase shlib minor.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 2
inet6_option_space(nbytes)
	int nbytes;
d67 1
a67 4
inet6_option_init(bp, cmsgp, type)
	void *bp;
	struct cmsghdr **cmsgp;
	int type;
d69 1
a69 1
	register struct cmsghdr *ch = (struct cmsghdr *)bp;
d94 2
a95 5
inet6_option_append(cmsg, typep, multx, plusy)
	struct cmsghdr *cmsg;
	const u_int8_t *typep;
	int multx;
	int plusy;
d98 1
a98 1
	register u_char *bp = (u_char *)cmsg + cmsg->cmsg_len;
d166 1
a166 5
inet6_option_alloc(cmsg, datalen, multx, plusy)
	struct cmsghdr *cmsg;
	int datalen;
	int multx;
	int plusy;
d169 1
a169 1
	register u_int8_t *bp = (u_char *)cmsg + cmsg->cmsg_len;
d229 1
a229 3
inet6_option_next(cmsg, tptrp)
	const struct cmsghdr *cmsg;
	u_int8_t **tptrp;
d285 1
a285 4
inet6_option_find(cmsg, tptrp, type)
	const struct cmsghdr *cmsg;
	u_int8_t **tptrp;
	int type;
d338 1
a338 2
ip6optlen(opt, lim)
	u_int8_t *opt, *lim;
@

