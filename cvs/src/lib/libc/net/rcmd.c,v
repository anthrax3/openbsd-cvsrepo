head	1.63;
access;
symbols
	OPENBSD_6_1:1.63.0.6
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.63.0.4
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.56.0.22
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.56.0.20
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.56.0.16
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.56.0.14
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.56.0.12
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.10
	OPENBSD_5_0:1.56.0.8
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.56.0.6
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.56.0.4
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.55.0.10
	OPENBSD_4_6_BASE:1.55
	OPENBSD_4_5:1.55.0.6
	OPENBSD_4_5_BASE:1.55
	OPENBSD_4_4:1.55.0.4
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.54.0.6
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.54.0.4
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.53.0.4
	OPENBSD_3_9_BASE:1.53
	OPENBSD_3_8:1.53.0.2
	OPENBSD_3_8_BASE:1.53
	OPENBSD_3_7:1.51.0.2
	OPENBSD_3_7_BASE:1.51
	OPENBSD_3_6:1.48.0.4
	OPENBSD_3_6_BASE:1.48
	OPENBSD_3_5:1.48.0.2
	OPENBSD_3_5_BASE:1.48
	OPENBSD_3_4:1.47.0.2
	OPENBSD_3_4_BASE:1.47
	OPENBSD_3_3:1.45.0.2
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.44.0.2
	OPENBSD_3_2_BASE:1.44
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	OPENBSD_3_0:1.39.0.2
	OPENBSD_3_0_BASE:1.39
	OPENBSD_2_9:1.37.0.2
	OPENBSD_2_9_BASE:1.37
	OPENBSD_2_8:1.36.0.4
	OPENBSD_2_8_BASE:1.36
	OPENBSD_2_7:1.36.0.2
	OPENBSD_2_7_BASE:1.36
	OPENBSD_2_6:1.31.0.8
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.31.0.6
	OPENBSD_2_5_BASE:1.31
	OPENBSD_2_4:1.31.0.4
	OPENBSD_2_4_BASE:1.31
	OPENBSD_2_3:1.31.0.2
	OPENBSD_2_3_BASE:1.31
	OPENBSD_2_2:1.26.0.2
	OPENBSD_2_2_BASE:1.26
	OPENBSD_2_1:1.20.0.2
	OPENBSD_2_1_BASE:1.20
	OPENBSD_2_0:1.18.0.2
	OPENBSD_2_0_BASE:1.18
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.63
date	2015.09.12.14.56.50;	author guenther;	state Exp;
branches;
next	1.62;
commitid	BXATo6E2rFBuIXKr;

1.62
date	2015.08.30.05.45.43;	author guenther;	state Exp;
branches;
next	1.61;
commitid	ygfQwdR4sHXWXJBJ;

1.61
date	2015.03.22.22.32.03;	author halex;	state Exp;
branches;
next	1.60;
commitid	rQQjK2VGIQxkQcP0;

1.60
date	2015.03.22.00.58.16;	author halex;	state Exp;
branches;
next	1.59;
commitid	vpvCCc8Jsa22NdAy;

1.59
date	2015.03.19.22.05.28;	author halex;	state Exp;
branches;
next	1.58;
commitid	D6shDuLU1kp5IqBK;

1.58
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	0DYulI8hhujBHMcR;

1.57
date	2014.10.10.13.14.50;	author dlg;	state Exp;
branches;
next	1.56;
commitid	LusyWSyJfPC4qmcV;

1.56
date	2009.11.18.07.43.22;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.17.07.07.23;	author moritz;	state Exp;
branches;
next	1.54;

1.54
date	2006.03.31.04.46.09;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2005.08.06.20.30.03;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2005.03.25.13.24.12;	author otto;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.08.18.34.42;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.07.20.00.15;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2004.11.17.01.42.26;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.25.21.14.46;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2003.07.11.22.39.21;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.03.20.49.27;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2002.12.15.13.27.06;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.06.18.35.12;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.24.21.22.37;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.22.04.31.14;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.17.19.42.23;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.04.23.35.58;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.27.00.58.55;	author lebel;	state Exp;
branches;
next	1.37;

1.37
date	2001.02.10.21.55.07;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2000.02.25.04.39.08;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2000.02.18.04.12.20;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2000.01.30.05.17.49;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2000.01.27.05.18.47;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	99.12.16.21.30.34;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	98.03.19.00.30.05;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	98.02.12.02.21.19;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.02.12.00.48.09;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.02.11.05.28.52;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.02.11.02.26.15;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.07.09.01.08.47;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.07.06.07.55.58;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.06.29.06.02.48;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.06.04.03.18.40;	author dm;	state Exp;
branches;
next	1.22;

1.22
date	97.06.03.22.43.42;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.05.28.21.40.11;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.04.05.21.13.15;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.01.25.21.30.37;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.09.05.02.37.27;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	96.09.03.10.53.37;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.09.02.21.26.09;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	96.09.01.18.31.29;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.08.31.17.56.52;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.08.30.16.32.08;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.08.30.04.07.43;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.08.19.08.29.39;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	96.08.07.18.01.05;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.05.00.34.46;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.29.06.15.29;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.07.29.05.48.39;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.22.10.01.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.22.03.44.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.20.00.27.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.06.31.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.22.10.36.45;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.04;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Wrap <unistd.h> so that internal calls go direct and they're all weak symbols
Delete unused 'fd' argument from internal function oldttyname()
@
text
@/*
 * Copyright (c) 1995, 1996, 1998 Theo de Raadt.  All rights reserved.
 * Copyright (c) 1983, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <signal.h>
#include <fcntl.h>
#include <netdb.h>
#include <unistd.h>
#include <limits.h>
#include <pwd.h>
#include <errno.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <stdlib.h>
#include <poll.h>

int
rcmd(char **ahost, int rport, const char *locuser, const char *remuser,
    const char *cmd, int *fd2p)
{
	return rcmd_af(ahost, rport, locuser, remuser, cmd, fd2p, AF_INET);
}

int
rcmd_af(char **ahost, int porta, const char *locuser, const char *remuser,
    const char *cmd, int *fd2p, int af)
{
	static char hbuf[HOST_NAME_MAX+1];
	char pbuf[NI_MAXSERV];
	struct addrinfo hints, *res, *r;
	int error;
	struct sockaddr_storage from;
	sigset_t oldmask, mask;
	pid_t pid;
	int s, lport;
	struct timespec timo;
	char c, *p;
	int refused;
	in_port_t rport = porta;
	int numread;

	/* call rcmdsh() with specified remote shell if appropriate. */
	if (!issetugid() && (p = getenv("RSH")) && *p) {
		struct servent *sp = getservbyname("shell", "tcp");

		if (sp && sp->s_port == rport)
			return (rcmdsh(ahost, rport, locuser, remuser,
			    cmd, p));
	}

	/* use rsh(1) if non-root and remote port is shell. */
	if (geteuid()) {
		struct servent *sp = getservbyname("shell", "tcp");

		if (sp && sp->s_port == rport)
			return (rcmdsh(ahost, rport, locuser, remuser,
			    cmd, NULL));
	}

	pid = getpid();
	snprintf(pbuf, sizeof(pbuf), "%u", ntohs(rport));
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = af;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_CANONNAME;
	error = getaddrinfo(*ahost, pbuf, &hints, &res);
	if (error) {
		(void)fprintf(stderr, "rcmd: %s: %s\n", *ahost,
		    gai_strerror(error));
		return (-1);
	}
	if (res->ai_canonname) {
		strlcpy(hbuf, res->ai_canonname, sizeof(hbuf));
		*ahost = hbuf;
	} else
		; /*XXX*/

	r = res;
	refused = 0;
	timespecclear(&timo);
	sigemptyset(&mask);
	sigaddset(&mask, SIGURG);
	sigprocmask(SIG_BLOCK, &mask, &oldmask);
	for (timo.tv_sec = 1, lport = IPPORT_RESERVED - 1;;) {
		s = rresvport_af(&lport, r->ai_family);
		if (s < 0) {
			if (errno == EAGAIN)
				(void)fprintf(stderr,
				    "rcmd: socket: All ports in use\n");
			else
				(void)fprintf(stderr, "rcmd: socket: %s\n",
				    strerror(errno));
			if (r->ai_next) {
				r = r->ai_next;
				continue;
			} else {
				sigprocmask(SIG_SETMASK, &oldmask, NULL);
				freeaddrinfo(res);
				return (-1);
			}
		}
		fcntl(s, F_SETOWN, pid);
		if (connect(s, r->ai_addr, r->ai_addrlen) >= 0)
			break;
		(void)close(s);
		if (errno == EADDRINUSE) {
			lport--;
			continue;
		}
		if (errno == ECONNREFUSED)
			refused++;
		if (r->ai_next) {
			int oerrno = errno;
			char hbuf[NI_MAXHOST];
			const int niflags = NI_NUMERICHOST;

			hbuf[0] = '\0';
			if (getnameinfo(r->ai_addr, r->ai_addrlen,
			    hbuf, sizeof(hbuf), NULL, 0, niflags) != 0)
				strlcpy(hbuf, "(invalid)", sizeof hbuf);
			(void)fprintf(stderr, "connect to address %s: ", hbuf);
			errno = oerrno;
			perror(0);
			r = r->ai_next;
			hbuf[0] = '\0';
			if (getnameinfo(r->ai_addr, r->ai_addrlen,
			    hbuf, sizeof(hbuf), NULL, 0, niflags) != 0)
				strlcpy(hbuf, "(invalid)", sizeof hbuf);
			(void)fprintf(stderr, "Trying %s...\n", hbuf);
			continue;
		}
		if (refused && timo.tv_sec <= 16) {
			(void)nanosleep(&timo, NULL);
			timo.tv_sec *= 2;
			r = res;
			refused = 0;
			continue;
		}
		(void)fprintf(stderr, "%s: %s\n", res->ai_canonname,
		    strerror(errno));
		sigprocmask(SIG_SETMASK, &oldmask, NULL);
		freeaddrinfo(res);
		return (-1);
	}
	/* given "af" can be PF_UNSPEC, we need the real af for "s" */
	af = r->ai_family;
	freeaddrinfo(res);
	if (fd2p == 0) {
		write(s, "", 1);
		lport = 0;
	} else {
		struct pollfd pfd[2];
		char num[8];
		int s2 = rresvport_af(&lport, af), s3;
		socklen_t len = sizeof(from);

		if (s2 < 0)
			goto bad;

		listen(s2, 1);
		(void)snprintf(num, sizeof(num), "%d", lport);
		if (write(s, num, strlen(num)+1) != strlen(num)+1) {
			(void)fprintf(stderr,
			    "rcmd: write (setting up stderr): %s\n",
			    strerror(errno));
			(void)close(s2);
			goto bad;
		}
again:
		pfd[0].fd = s;
		pfd[0].events = POLLIN;
		pfd[1].fd = s2;
		pfd[1].events = POLLIN;

		errno = 0;
		if (poll(pfd, 2, INFTIM) < 1 ||
		    (pfd[1].revents & (POLLIN|POLLHUP)) == 0) {
			if (errno != 0)
				(void)fprintf(stderr,
				    "rcmd: poll (setting up stderr): %s\n",
				    strerror(errno));
			else
				(void)fprintf(stderr,
				"poll: protocol failure in circuit setup\n");
			(void)close(s2);
			goto bad;
		}
		s3 = accept(s2, (struct sockaddr *)&from, &len);
		if (s3 < 0) {
			(void)fprintf(stderr,
			    "rcmd: accept: %s\n", strerror(errno));
			lport = 0;
			close(s2);
			goto bad;
		}

		/*
		 * XXX careful for ftp bounce attacks. If discovered, shut them
		 * down and check for the real auxiliary channel to connect.
		 */
		switch (from.ss_family) {
		case AF_INET:
		case AF_INET6:
			if (getnameinfo((struct sockaddr *)&from, len,
			    NULL, 0, num, sizeof(num), NI_NUMERICSERV) == 0 &&
			    atoi(num) != 20) {
				break;
			}
			close(s3);
			goto again;
		default:
			break;
		}
		(void)close(s2);

		*fd2p = s3;
		switch (from.ss_family) {
		case AF_INET:
		case AF_INET6:
			if (getnameinfo((struct sockaddr *)&from, len,
			    NULL, 0, num, sizeof(num), NI_NUMERICSERV) != 0 ||
			    (atoi(num) >= IPPORT_RESERVED ||
			     atoi(num) < IPPORT_RESERVED / 2)) {
				(void)fprintf(stderr,
				    "socket: protocol failure in circuit setup.\n");
				goto bad2;
			}
			break;
		default:
			break;
		}
	}
	(void)write(s, locuser, strlen(locuser)+1);
	(void)write(s, remuser, strlen(remuser)+1);
	(void)write(s, cmd, strlen(cmd)+1);
	if ((numread = read(s, &c, 1)) != 1) {
		(void)fprintf(stderr,
		    "rcmd: %s: %s\n", *ahost,
		    numread == -1 ? strerror(errno) : "Short read");
		goto bad2;
	}
	if (c != 0) {
		while (read(s, &c, 1) == 1) {
			(void)write(STDERR_FILENO, &c, 1);
			if (c == '\n')
				break;
		}
		goto bad2;
	}
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
	return (s);
bad2:
	if (lport)
		(void)close(*fd2p);
bad:
	(void)close(s);
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
	return (-1);
}
DEF_WEAK(rcmd_af);

@


1.62
log
@Use nanosleep instead of sleep to avoid the extra layer and simplify later
symbol hiding

ok w/tweak deraadt@@
@
text
@d295 1
@


1.61
log
@differentiate between a failed read, returning -1, and encountering
end-of-file, returning 0, in order not to print an unrelated
strerror(errno) in the latter case

ok millert@@
@
text
@d48 1
d70 2
a71 1
	int s, lport, timo;
d115 1
d119 1
a119 1
	for (timo = 1, lport = IPPORT_RESERVED - 1;;) {
d167 3
a169 3
		if (refused && timo <= 16) {
			(void)sleep(timo);
			timo *= 2;
@


1.60
log
@unmute rcmd hostname lookup failure

ok millert@@ jung@@
@
text
@d73 1
d268 1
a268 1
	if (read(s, &c, 1) != 1) {
d270 2
a271 1
		    "rcmd: %s: %s\n", *ahost, strerror(errno));
@


1.59
log
@zap #if 0'd code that's been dead since '96

ok todd@@
@
text
@d100 2
a101 3
#if 0
		warnx("%s: %s", *ahost, gai_strerror(error));
#endif
@


1.58
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@a179 7
#if 0
	/*
	 * try to rresvport() to the same port. This will make rresvport()
	 * fail it's first bind, resulting in it choosing a random port.
	 */
	lport--;
#endif
@


1.57
log
@replace select with equiv poll usage.

looks good deraadt@@
tweaks and ok millert@@
@
text
@a30 1
#include <sys/param.h>
d41 1
d62 1
a62 1
	static char hbuf[MAXHOSTNAMELEN];
@


1.56
log
@More shrinkage, a bit for ramdisks but mostly for static binaries:
- wrap with #ifndef NO_LOG_BAD_DNS_RESPONSES libc code that uses
  p_class() and p_type() for diagnostics, then add that define to
  libstub to avoid pulling in res_debug_syms.o
- split rcmd() and ruserok() into separate files, as nothing uses both
- split readdir_r() to its own file
- split syslog_r() from syslog(), as the latter needs localtime(); many
  binaries no longer need to pull in all the time code after this; switch
  from usleep() to nanosleep() while we're at it

(The profit of analysis of -Wl,-M,--cref output)

Chops 888kB from /bin and /sbin on i386

ok deraadt@@, miod@@
@
text
@d49 1
a66 1
	fd_set *readsp = NULL;
d191 1
a194 1
		int fdssize = howmany(MAX(s, s2)+1, NFDBITS) * sizeof(fd_mask);
d198 1
a198 5
		readsp = (fd_set *)malloc(fdssize);
		if (readsp == NULL) {
			close(s2);
			goto bad;
		}
d209 5
a213 3
		bzero(readsp, fdssize);
		FD_SET(s, readsp);
		FD_SET(s2, readsp);
d215 2
a216 2
		if (select(MAX(s, s2) + 1, readsp, 0, 0, 0) < 1 ||
		    !FD_ISSET(s2, readsp)) {
d219 1
a219 1
				    "rcmd: select (setting up stderr): %s\n",
d223 1
a223 1
				"select: protocol failure in circuit setup\n");
a288 1
	free(readsp);
a293 2
	if (readsp)
		free(readsp);
@


1.55
log
@Check snprintf(3) return value for error or truncation.
Mostly path construction, where truncation could be bad.

ok and input from deraadt@@ millert@@ ray@@
@
text
@a48 7
#include <netgroup.h>

int	__ivaliduser(FILE *, in_addr_t, const char *, const char *);
int	__ivaliduser_sa(FILE *, struct sockaddr *, socklen_t,
	    const char *, const char *);
static int __icheckhost(struct sockaddr *, socklen_t, const char *);
static char *__gethostloop(struct sockaddr *, socklen_t);
a303 381
int	__check_rhosts_file = 1;
char	*__rcmd_errstr;

int
ruserok(const char *rhost, int superuser, const char *ruser, const char *luser)
{
	struct addrinfo hints, *res, *r;
	int error;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	error = getaddrinfo(rhost, "0", &hints, &res);
	if (error)
		return (-1);

	for (r = res; r; r = r->ai_next) {
		if (iruserok_sa(r->ai_addr, r->ai_addrlen, superuser, ruser,
		    luser) == 0) {
			freeaddrinfo(res);
			return (0);
		}
	}
	freeaddrinfo(res);
	return (-1);
}

/*
 * New .rhosts strategy: We are passed an ip address. We spin through
 * hosts.equiv and .rhosts looking for a match. When the .rhosts only
 * has ip addresses, we don't have to trust a nameserver.  When it
 * contains hostnames, we spin through the list of addresses the nameserver
 * gives us and look for a match.
 *
 * Returns 0 if ok, -1 if not ok.
 */
int
iruserok(u_int32_t raddr, int superuser, const char *ruser, const char *luser)
{
	struct sockaddr_in sin;

	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_len = sizeof(struct sockaddr_in);
	memcpy(&sin.sin_addr, &raddr, sizeof(sin.sin_addr));
	return iruserok_sa(&sin, sizeof(struct sockaddr_in), superuser, ruser,
		    luser);
}

int
iruserok_sa(const void *raddr, int rlen, int superuser, const char *ruser,
    const char *luser)
{
	struct sockaddr *sa;
	char *cp;
	struct stat sbuf;
	struct passwd *pwd;
	FILE *hostf;
	uid_t uid;
	int first;
	char pbuf[MAXPATHLEN];

	sa = (struct sockaddr *)raddr;
	first = 1;
	hostf = superuser ? NULL : fopen(_PATH_HEQUIV, "r");
again:
	if (hostf) {
		if (__ivaliduser_sa(hostf, sa, rlen, luser, ruser) == 0) {
			(void)fclose(hostf);
			return (0);
		}
		(void)fclose(hostf);
	}
	if (first == 1 && (__check_rhosts_file || superuser)) {
		int len;

		first = 0;
		if ((pwd = getpwnam(luser)) == NULL)
			return (-1);
		len = snprintf(pbuf, sizeof pbuf, "%s/.rhosts", pwd->pw_dir);
		if (len < 0 || len >= sizeof pbuf)
			return (-1);

		/*
		 * Change effective uid while opening .rhosts.  If root and
		 * reading an NFS mounted file system, can't read files that
		 * are protected read/write owner only.
		 */
		uid = geteuid();
		(void)seteuid(pwd->pw_uid);
		hostf = fopen(pbuf, "r");
		(void)seteuid(uid);

		if (hostf == NULL)
			return (-1);
		/*
		 * If not a regular file, or is owned by someone other than
		 * user or root or if writeable by anyone but the owner, quit.
		 */
		cp = NULL;
		if (lstat(pbuf, &sbuf) < 0)
			cp = ".rhosts lstat failed";
		else if (!S_ISREG(sbuf.st_mode))
			cp = ".rhosts not regular file";
		else if (fstat(fileno(hostf), &sbuf) < 0)
			cp = ".rhosts fstat failed";
		else if (sbuf.st_uid && sbuf.st_uid != pwd->pw_uid)
			cp = "bad .rhosts owner";
		else if (sbuf.st_mode & (S_IWGRP|S_IWOTH))
			cp = ".rhosts writable by other than owner";
		/* If there were any problems, quit. */
		if (cp) {
			__rcmd_errstr = cp;
			(void)fclose(hostf);
			return (-1);
		}
		goto again;
	}
	return (-1);
}

/*
 * XXX
 * Don't make static, used by lpd(8).
 *
 * Returns 0 if ok, -1 if not ok.
 */
int
__ivaliduser(FILE *hostf, in_addr_t raddrl, const char *luser,
    const char *ruser)
{
	struct sockaddr_in sin;

	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_len = sizeof(struct sockaddr_in);
	memcpy(&sin.sin_addr, &raddrl, sizeof(sin.sin_addr));
	return __ivaliduser_sa(hostf, (struct sockaddr *)&sin, sin.sin_len,
		    luser, ruser);
}

int
__ivaliduser_sa(FILE *hostf, struct sockaddr *raddr, socklen_t salen,
    const char *luser, const char *ruser)
{
	char *user, *p;
	char *buf;
	const char *auser, *ahost;
	int hostok, userok;
	char *rhost = (char *)-1;
	char domain[MAXHOSTNAMELEN];
	size_t buflen;

	getdomainname(domain, sizeof(domain));

	while ((buf = fgetln(hostf, &buflen))) {
		p = buf;
		if (*p == '#')
			continue;
		while (p < buf + buflen && *p != '\n' && *p != ' ' && *p != '\t') {
			if (!isprint(*p))
				goto bail;
			*p = isupper(*p) ? tolower(*p) : *p;
			p++;
		}
		if (p >= buf + buflen)
			continue;
		if (*p == ' ' || *p == '\t') {
			*p++ = '\0';
			while (p < buf + buflen && (*p == ' ' || *p == '\t'))
				p++;
			if (p >= buf + buflen)
				continue;
			user = p;
			while (p < buf + buflen && *p != '\n' && *p != ' ' &&
			    *p != '\t') {
				if (!isprint(*p))
					goto bail;
				p++;
			}
		} else
			user = p;
		*p = '\0';

		if (p == buf)
			continue;

		auser = *user ? user : luser;
		ahost = buf;

		if (strlen(ahost) >= MAXHOSTNAMELEN)
			continue;

		/*
		 * innetgr() must lookup a hostname (we do not attempt
		 * to change the semantics so that netgroups may have
		 * #.#.#.# addresses in the list.)
		 */
		if (ahost[0] == '+')
			switch (ahost[1]) {
			case '\0':
				hostok = 1;
				break;
			case '@@':
				if (rhost == (char *)-1)
					rhost = __gethostloop(raddr, salen);
				hostok = 0;
				if (rhost)
					hostok = innetgr(&ahost[2], rhost,
					    NULL, domain);
				break;
			default:
				hostok = __icheckhost(raddr, salen, &ahost[1]);
				break;
			}
		else if (ahost[0] == '-')
			switch (ahost[1]) {
			case '\0':
				hostok = -1;
				break;
			case '@@':
				if (rhost == (char *)-1)
					rhost = __gethostloop(raddr, salen);
				hostok = 0;
				if (rhost)
					hostok = -innetgr(&ahost[2], rhost,
					    NULL, domain);
				break;
			default:
				hostok = -__icheckhost(raddr, salen, &ahost[1]);
				break;
			}
		else
			hostok = __icheckhost(raddr, salen, ahost);


		if (auser[0] == '+')
			switch (auser[1]) {
			case '\0':
				userok = 1;
				break;
			case '@@':
				userok = innetgr(&auser[2], NULL, ruser,
				    domain);
				break;
			default:
				userok = strcmp(ruser, &auser[1]) ? 0 : 1;
				break;
			}
		else if (auser[0] == '-')
			switch (auser[1]) {
			case '\0':
				userok = -1;
				break;
			case '@@':
				userok = -innetgr(&auser[2], NULL, ruser,
				    domain);
				break;
			default:
				userok = strcmp(ruser, &auser[1]) ? 0 : -1;
				break;
			}
		else
			userok = strcmp(ruser, auser) ? 0 : 1;

		/* Check if one component did not match */
		if (hostok == 0 || userok == 0)
			continue;

		/* Check if we got a forbidden pair */
		if (userok <= -1 || hostok <= -1)
			return (-1);

		/* Check if we got a valid pair */
		if (hostok >= 1 && userok >= 1)
			return (0);
	}
bail:
	return (-1);
}

/*
 * Returns "true" if match, 0 if no match.  If we do not find any
 * semblance of an A->PTR->A loop, allow a simple #.#.#.# match to work.
 */
static int
__icheckhost(struct sockaddr *raddr, socklen_t salen, const char *lhost)
{
	struct addrinfo hints, *res, *r;
	char h1[NI_MAXHOST], h2[NI_MAXHOST];
	int error;
	const int niflags = NI_NUMERICHOST;

	h1[0] = '\0';
	if (getnameinfo(raddr, salen, h1, sizeof(h1), NULL, 0,
	    niflags) != 0)
		return (0);

	/* Resolve laddr into sockaddr */
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = raddr->sa_family;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	res = NULL;
	error = getaddrinfo(lhost, "0", &hints, &res);
	if (error)
		return (0);

	/*
	 * Try string comparisons between raddr and laddr.
	 */
	for (r = res; r; r = r->ai_next) {
		h2[0] = '\0';
		if (getnameinfo(r->ai_addr, r->ai_addrlen, h2, sizeof(h2),
		    NULL, 0, niflags) != 0)
			continue;
		if (strcmp(h1, h2) == 0) {
			freeaddrinfo(res);
			return (1);
		}
	}

	/* No match. */
	freeaddrinfo(res);
	return (0);
}

/*
 * Return the hostname associated with the supplied address.
 * Do a reverse lookup as well for security. If a loop cannot
 * be found, pack the result of inet_ntoa() into the string.
 */
static char *
__gethostloop(struct sockaddr *raddr, socklen_t salen)
{
	static char remotehost[NI_MAXHOST];
	char h1[NI_MAXHOST], h2[NI_MAXHOST];
	struct addrinfo hints, *res, *r;
	int error;
	const int niflags = NI_NUMERICHOST;

	h1[0] = remotehost[0] = '\0';
	if (getnameinfo(raddr, salen, remotehost, sizeof(remotehost),
	    NULL, 0, NI_NAMEREQD) != 0)
		return (NULL);
	if (getnameinfo(raddr, salen, h1, sizeof(h1), NULL, 0,
	    niflags) != 0)
		return (NULL);

	/*
	 * Look up the name and check that the supplied
	 * address is in the list
	 */
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = raddr->sa_family;
	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
	hints.ai_flags = AI_CANONNAME;
	res = NULL;
	error = getaddrinfo(remotehost, "0", &hints, &res);
	if (error)
		return (NULL);

	for (r = res; r; r = r->ai_next) {
		h2[0] = '\0';
		if (getnameinfo(r->ai_addr, r->ai_addrlen, h2, sizeof(h2),
		    NULL, 0, niflags) != 0)
			continue;
		if (strcmp(h1, h2) == 0) {
			freeaddrinfo(res);
			return (remotehost);
		}
	}

	/*
	 * either the DNS adminstrator has made a configuration
	 * mistake, or someone has attempted to spoof us
	 */
	syslog(LOG_NOTICE, "rcmd: address %s not listed for host %s",
	    h1, res->ai_canonname ? res->ai_canonname : remotehost);
	freeaddrinfo(res);
	return (NULL);
}
@


1.54
log
@oldmask = sigprocmask(SIG_BLOCK, &mask, &oldmask);
is not valid code; found by lint
@
text
@d385 2
d390 3
a392 1
		snprintf(pbuf, sizeof pbuf, "%s/.rhosts", pwd->pw_dir);
@


1.53
log
@zap rcsid.
split functions off res_debug.c so that getnetnamadr.c does not pull it
all when it's used.

okay deraadt@@, krw@@
@
text
@d122 1
a122 1
	oldmask = sigprocmask(SIG_BLOCK, &mask, &oldmask);
@


1.52
log
@ansify. ok deraadt@@ moritz@@
@
text
@a30 4
#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: rcmd.c,v 1.51 2005/03/08 18:34:42 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */

@


1.51
log
@do not trash errno before using it, do not pass garbage args to getnameinfo
ok henning andrushock@@korovino.net
@
text
@d32 1
a32 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.50 2005/03/07 20:00:15 deraadt Exp $";
d62 2
a63 5
rcmd(ahost, rport, locuser, remuser, cmd, fd2p)
	char **ahost;
	in_port_t rport;
	const char *locuser, *remuser, *cmd;
	int *fd2p;
d69 2
a70 6
rcmd_af(ahost, rport, locuser, remuser, cmd, fd2p, af)
	char **ahost;
	in_port_t rport;
	const char *locuser, *remuser, *cmd;
	int *fd2p;
	int af;
d83 1
d319 1
a319 3
ruserok(rhost, superuser, ruser, luser)
	const char *rhost, *ruser, *luser;
	int superuser;
d352 1
a352 4
iruserok(raddr, superuser, ruser, luser)
	u_int32_t raddr;
	int superuser;
	const char *ruser, *luser;
d365 2
a366 5
iruserok_sa(raddr, rlen, superuser, ruser, luser)
	const void *raddr;
	int rlen;
	int superuser;
	const char *ruser, *luser;
d369 1
a369 1
	register char *cp;
d439 2
a440 4
__ivaliduser(hostf, raddrl, luser, ruser)
	FILE *hostf;
	in_addr_t raddrl;
	const char *luser, *ruser;
d453 2
a454 5
__ivaliduser_sa(hostf, raddr, salen, luser, ruser)
	FILE *hostf;
	struct sockaddr *raddr;
	socklen_t salen;
	const char *luser, *ruser;
d456 1
a456 1
	register char *user, *p;
d597 1
a597 4
__icheckhost(raddr, salen, lhost)
	struct sockaddr *raddr;
	socklen_t salen;
	const char *lhost;
d643 1
a643 3
__gethostloop(raddr, salen)
	struct sockaddr *raddr;
	socklen_t salen;
@


1.50
log
@fd leak; andrushock@@korovino.net
@
text
@d32 1
a32 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.49 2004/11/17 01:42:26 itojun Exp $";
d247 8
d273 1
a273 6
		if (s3 < 0) {
			(void)fprintf(stderr,
			    "rcmd: accept: %s\n", strerror(errno));
			lport = 0;
			goto bad;
		}
@


1.49
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d32 1
a32 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.48 2003/09/25 21:14:46 millert Exp $";
d216 2
a217 1
		if (readsp == NULL)
d219 1
@


1.48
log
@Do check for current pointer vs. buffer end before touching any
elements in the buffer.  Fixes an out of bounds access.
From aaron@@; OK deraadt@@
@
text
@d32 1
a32 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.47 2003/07/11 22:39:21 deraadt Exp $";
a163 3
#ifdef NI_WITHSCOPEID
			const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
a164 1
#endif
a608 3
 *
 * NI_WITHSCOPEID is useful for comparing sin6_scope_id portion
 * if af == AF_INET6.
a618 3
#ifdef NI_WITHSCOPEID
	const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
a619 1
#endif
a657 3
 *
 * NI_WITHSCOPEID is useful for comparing sin6_scope_id portion
 * if af == AF_INET6.
a667 3
#ifdef NI_WITHSCOPEID
	const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
#else
a668 1
#endif
@


1.47
log
@license oops; from tedu
@
text
@d32 1
a32 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.46 2003/06/03 20:49:27 deraadt Exp $";
d488 1
a488 1
		while (*p != '\n' && *p != ' ' && *p != '\t' && p < buf + buflen) {
d498 1
a498 1
			while ((*p == ' ' || *p == '\t') && p < buf + buflen)
d503 2
a504 2
			while (*p != '\n' && *p != ' ' &&
			    *p != '\t' && p < buf + buflen) {
@


1.46
log
@fix various 3/4 licenses according to "terms" file
@
text
@d14 3
d32 1
a32 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.45 2002/12/15 13:27:06 henning Exp $";
@


1.45
log
@more writeable -> writable by torh
@
text
@a13 8
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed by Theo de Raadt.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d29 1
a29 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.44 2002/09/06 18:35:12 deraadt Exp $";
@


1.44
log
@use socklen_t where needed; henning pvalchev ok
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.43 2002/05/24 21:22:37 deraadt Exp $";
d438 1
a438 1
			cp = ".rhosts writeable by other than owner";
@


1.43
log
@try to use strlcpy and snprintf more; ok various
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.42 2002/05/22 04:31:14 deraadt Exp $";
d219 1
a219 1
		int len = sizeof(from);
@


1.42
log
@more strlcpy and snprintf
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.41 2002/02/17 19:42:23 millert Exp $";
d410 1
a410 2
		(void)strcpy(pbuf, pwd->pw_dir);
		(void)strcat(pbuf, "/.rhosts");
@


1.41
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.40 2002/02/16 21:27:23 millert Exp $";
d178 1
a178 1
				strcpy(hbuf, "(invalid)");
d186 1
a186 1
				strcpy(hbuf, "(invalid)");
@


1.40
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.39 2001/09/04 23:35:58 millert Exp $";
d61 2
a62 2
int	__ivaliduser_sa __P((FILE *, struct sockaddr *, socklen_t,
		const char *, const char *));
@


1.39
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.38 2001/06/27 00:58:55 lebel Exp $";
d60 1
a60 1
int	__ivaliduser __P((FILE *, in_addr_t, const char *, const char *));
d63 2
a64 2
static int __icheckhost __P((struct sockaddr *, socklen_t, const char *));
static char *__gethostloop __P((struct sockaddr *, socklen_t));
@


1.38
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.37 2001/02/10 21:55:07 millert Exp $";
d90 1
a90 1
	int oldmask;
d135 3
a137 1
	oldmask = sigblock(sigmask(SIGURG));
d151 1
a151 1
				sigsetmask(oldmask);
d199 1
a199 1
		sigsetmask(oldmask);
d311 1
a311 1
	sigsetmask(oldmask);
d321 1
a321 1
	sigsetmask(oldmask);
@


1.37
log
@Make sure $RSH is not the empty string.
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.36 2000/02/25 04:39:08 itojun Exp $";
d128 1
a128 2
		strncpy(hbuf, res->ai_canonname, sizeof(hbuf) - 1);
		hbuf[sizeof(hbuf) - 1] = '\0';
@


1.36
log
@always pass salen as separate argument, so that it can be friendly with
systems with pre-4.2 sockaddrs.
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.35 2000/02/18 04:12:20 itojun Exp $";
d97 1
a97 1
	if (!issetugid() && (p = getenv("RSH"))) {
@


1.35
log
@do not perform sleep() every time we get ECONNREFUSED.
try all the set of addresses before go to sleep() and retry.

not sure if we still need sleep() - retry logic.  why is it so persistent?
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.34 2000/01/30 05:17:49 itojun Exp $";
d61 4
a64 3
int	__ivaliduser_sa __P((FILE *, struct sockaddr *, const char *, const char *));
static int __icheckhost __P((struct sockaddr *, const char *));
static char *__gethostloop __P((struct sockaddr *));
a394 3
#ifdef lint
	rlen = rlen;
#endif
d399 1
a399 1
		if (__ivaliduser_sa(hostf, sa, luser, ruser) == 0) {
d468 2
a469 1
	return __ivaliduser_sa(hostf, (struct sockaddr *)&sin, luser, ruser);
d473 1
a473 1
__ivaliduser_sa(hostf, raddr, luser, ruser)
d476 1
d539 1
a539 1
					rhost = __gethostloop(raddr);
d546 1
a546 1
				hostok = __icheckhost(raddr, &ahost[1]);
d556 1
a556 1
					rhost = __gethostloop(raddr);
d563 1
a563 1
				hostok = -__icheckhost(raddr, &ahost[1]);
d567 1
a567 1
			hostok = __icheckhost(raddr, ahost);
d623 1
a623 1
__icheckhost(raddr, lhost)
d625 1
d638 1
a638 1
	if (getnameinfo(raddr, raddr->sa_len, h1, sizeof(h1), NULL, 0,
d679 1
a679 1
__gethostloop(raddr)
d681 1
d694 1
a694 1
	if (getnameinfo(raddr, raddr->sa_len, remotehost, sizeof(remotehost),
d697 1
a697 1
	if (getnameinfo(raddr, raddr->sa_len, h1, sizeof(h1), NULL, 0,
@


1.34
log
@visit next addrinfo structure when rresvport_af() fails.
this should fix situation like:
- try to rcmd() to dual stack node from IPv4-only node/kernel
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.33 2000/01/27 05:18:47 itojun Exp $";
d93 1
d134 1
d162 2
a163 5
		if (errno == ECONNREFUSED && timo <= 16) {
			(void)sleep(timo);
			timo *= 2;
			continue;
		}
d186 7
@


1.33
log
@add IPv6-ready rcmd() friends.
	rcmd(): IPv4 only
	rcmd_af(): af independent
	ruserok(): af independent
	iruserok(): IPv4 only
	iruserok_sa(): af independent
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.32 1999/12/16 21:30:34 deraadt Exp $";
d143 8
a150 3
			sigsetmask(oldmask);
			freeaddrinfo(res);
			return (-1);
@


1.32
log
@rresvport_af() and bindresvport_af()
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.31 1998/03/19 00:30:05 millert Exp $";
d61 3
a63 2
static int __icheckhost __P((u_int32_t, const char *));
static char *__gethostloop __P((u_int32_t));
d72 16
a87 2
	struct hostent *hp;
	struct sockaddr_in sin, from;
d113 10
a122 3
	hp = gethostbyname(*ahost);
	if (hp == NULL) {
		herror(*ahost);
d125 6
a130 1
	*ahost = hp->h_name;
d132 1
d135 1
a135 1
		s = rresvport(&lport);
d144 1
d148 1
a148 6
		bzero(&sin, sizeof sin);
		sin.sin_len = sizeof(struct sockaddr_in);
		sin.sin_family = hp->h_addrtype;
		sin.sin_port = rport;
		bcopy(hp->h_addr_list[0], &sin.sin_addr, hp->h_length);
		if (connect(s, (struct sockaddr *)&sin, sizeof(sin)) >= 0)
d160 1
a160 1
		if (hp->h_addr_list[1] != NULL) {
d162 6
d169 5
a173 2
			(void)fprintf(stderr, "connect to address %s: ",
			    inet_ntoa(sin.sin_addr));
d176 6
a181 4
			hp->h_addr_list++;
			bcopy(hp->h_addr_list[0], &sin.sin_addr, hp->h_length);
			(void)fprintf(stderr, "Trying %s...\n",
			    inet_ntoa(sin.sin_addr));
d184 2
a185 1
		(void)fprintf(stderr, "%s: %s\n", hp->h_name, strerror(errno));
d187 1
d190 3
d205 1
a205 1
		int s2 = rresvport(&lport), s3;
d245 8
a252 1
		if (from.sin_family == AF_INET && from.sin_port == htons(20)) {
d255 2
d266 14
a279 7
		from.sin_port = ntohs(from.sin_port);
		if (from.sin_family != AF_INET ||
		    from.sin_port >= IPPORT_RESERVED ||
		    from.sin_port < IPPORT_RESERVED / 2) {
			(void)fprintf(stderr,
			    "socket: protocol failure in circuit setup.\n");
			goto bad2;
d320 2
a321 5
	struct hostent *hp;
	char **ap;
	int i;
#define MAXADDRS	35
	u_int32_t addrs[MAXADDRS + 1];
d323 5
a327 1
	if ((hp = gethostbyname(rhost)) == NULL)
a328 3
	for (i = 0, ap = hp->h_addr_list; *ap && i < MAXADDRS; ++ap, ++i)
		bcopy(*ap, &addrs[i], sizeof(addrs[i]));
	addrs[i] = 0;
d330 4
a333 2
	for (i = 0; i < MAXADDRS && addrs[i]; i++)
		if (iruserok((in_addr_t)addrs[i], superuser, ruser, luser) == 0)
d335 3
d356 18
d382 4
d390 1
a390 1
		if (__ivaliduser(hostf, raddr, luser, ruser) == 0) {
d453 15
a473 1
	u_int32_t raddr = (u_int32_t)raddrl;
d607 3
d613 1
a613 1
	u_int32_t raddr;
d616 35
a650 10
	register struct hostent *hp;
	register char **pp;
	struct in_addr in;

	hp = gethostbyname(lhost);
	if (hp != NULL) {
		/* Spin through ip addresses. */
		for (pp = hp->h_addr_list; *pp; ++pp)
			if (!bcmp(&raddr, *pp, sizeof(raddr)))
				return (1);
d653 2
a654 3
	in.s_addr = raddr;
	if (strcmp(lhost, inet_ntoa(in)) == 0)
		return (1);
d662 3
d668 1
a668 1
	u_int32_t raddr;
d670 9
a678 3
	static char remotehost[MAXHOSTNAMELEN];
	struct hostent *hp;
	struct in_addr in;
d680 6
a685 2
	hp = gethostbyaddr((char *) &raddr, sizeof(raddr), AF_INET);
	if (hp == NULL)
d692 7
a698 4
	strncpy(remotehost, hp->h_name, sizeof(remotehost) - 1);
	remotehost[sizeof(remotehost) - 1] = '\0';
	hp = gethostbyname(remotehost);
	if (hp == NULL)
d701 7
a707 2
	for (; hp->h_addr_list[0] != NULL; hp->h_addr_list++)
		if (!bcmp(hp->h_addr_list[0], (caddr_t)&raddr, sizeof(raddr)))
d709 2
a715 1
	in.s_addr = raddr;
d717 2
a718 1
	    inet_ntoa(in), hp->h_name);
@


1.31
log
@some -Wall
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.30 1998/02/12 02:21:19 deraadt Exp $";
a253 32
}

int
rresvport(alport)
	int *alport;
{
	struct sockaddr_in sin;
	int s;

	bzero(&sin, sizeof sin);
	sin.sin_len = sizeof(struct sockaddr_in);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;
	s = socket(AF_INET, SOCK_STREAM, 0);
	if (s < 0)
		return (-1);
	sin.sin_port = htons((in_port_t)*alport);
	if (*alport < IPPORT_RESERVED - 1) {
		if (bind(s, (struct sockaddr *)&sin, sizeof(sin)) >= 0)
			return (s);
		if (errno != EADDRINUSE) {
			(void)close(s);
			return (-1);
		}
	}
	sin.sin_port = 0;
	if (bindresvport(s, &sin) == -1) {
		(void)close(s);
		return (-1);
	}
	*alport = (int)ntohs(sin.sin_port);
	return (s);
@


1.30
log
@correct bounds check
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.29 1998/02/12 00:48:09 deraadt Exp $";
a404 1
	int ch;
d429 1
a429 1
			while (*p == ' ' || *p == '\t' && p < buf + buflen)
@


1.29
log
@copyright
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.28 1998/02/11 05:28:52 deraadt Exp $";
d451 1
a451 1
		if (strlen(ahost) > MAXHOSTNAMELEN)
@


1.28
log
@use fgetln() instead of fgets() so that we can catch \0 in the .rhosts
file. Thanks to fc@@parkone.ci.oakland.ca.us for lots of testing and
diagnosis help.
@
text
@d2 1
a2 1
 * Copyright (c) 1995, 1996 Theo de Raadt.  All rights reserved.
d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.27 1998/02/11 02:26:15 deraadt Exp $";
@


1.27
log
@increased paranoia about .rhosts validity
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.26 1997/07/09 01:08:47 millert Exp $";
d406 1
a406 1
	char buf[MAXHOSTNAMELEN + 128];		/* host + login */
d412 1
d416 1
a416 1
	while (fgets(buf, sizeof(buf), hostf)) {
a417 7
		/* Skip lines that are too long. */
		if (strchr(p, '\n') == NULL) {
			while ((ch = getc(hostf)) != '\n' && ch != EOF)
				if (!isprint(ch))
					goto bail;
			continue;
		}
d420 1
a420 1
		while (*p != '\n' && *p != ' ' && *p != '\t' && *p != '\0') {
d426 2
d430 1
a430 1
			while (*p == ' ' || *p == '\t')
d432 2
d436 1
a436 1
			    *p != '\t' && *p != '\0') {
d450 3
@


1.26
log
@Clean up some -Wall flowers.
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.25 1997/07/06 07:55:58 deraadt Exp $";
d420 2
a421 1
				;
d438 3
a440 1
			    *p != '\t' && *p != '\0')
d442 1
@


1.25
log
@if we find an unprintable char, bail totally
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.24 1997/06/29 06:02:48 deraadt Exp $";
d58 1
@


1.24
log
@indent
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.23 1997/06/04 03:18:40 dm Exp $";
d425 2
d532 1
@


1.23
log
@use bzero instead of FD_ZERO
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.22 1997/06/03 22:43:42 deraadt Exp $";
d183 1
a183 1
		bzero(readsp,fdssize);
@


1.22
log
@howmany(x+1, NFDBITS)
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.21 1997/05/28 21:40:11 deraadt Exp $";
d166 1
d170 1
a170 2
		readsp = (fd_set *)malloc(howmany(MAX(s, s2)+1, NFDBITS) *
		    sizeof(fd_mask));
d183 1
a183 1
		FD_ZERO(readsp);
@


1.21
log
@malloc fd_set dynamically, for very large fd uses
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.20 1997/04/05 21:13:15 millert Exp $";
d169 1
a169 1
		readsp = (fd_set *)malloc(howmany(MAX(s, s2), NFDBITS) *
@


1.20
log
@Use in_addr_t not u_long and use in_port_t in some cases instead
of u_short or u_int16_t.
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.19 1997/01/25 21:30:37 deraadt Exp $";
d72 1
a72 1
	fd_set reads;
d169 4
d183 3
a185 3
		FD_ZERO(&reads);
		FD_SET(s, &reads);
		FD_SET(s2, &reads);
d187 2
a188 2
		if (select(MAX(s, s2) + 1, &reads, 0, 0, 0) < 1 ||
		    !FD_ISSET(s2, &reads)) {
d242 1
d248 2
@


1.19
log
@never hand over a nonresv port, even if asked. problem reported by gmeinerj@@ZUMtOBEL.co.at
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.18 1996/09/05 02:37:27 millert Exp $";
d59 1
a59 1
int	__ivaliduser __P((FILE *, u_long, const char *, const char *));
d66 1
a66 1
	u_short rport;
d262 1
a262 1
	sin.sin_port = htons((u_short)*alport);
d301 1
a301 1
		if (iruserok((u_long)addrs[i], superuser, ruser, luser) == 0)
d393 1
a393 1
	u_long raddrl;
@


1.18
log
@ignore $RSH if we are setuid
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.17 1996/09/03 10:53:37 deraadt Exp $";
d263 1
a263 1
	if (*alport != IPPORT_RESERVED - 1) {
@


1.17
log
@proper types
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.16 1996/09/02 21:26:09 millert Exp $";
d79 1
a79 1
	if ((p = getenv("RSH"))) {
@


1.16
log
@Looks at RSH envariable and calls rcmdsh() with that value if set.
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.15 1996/09/01 18:31:29 deraadt Exp $";
d57 1
@


1.15
log
@i have changed this enough to put copyright on it
@
text
@d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.14 1996/08/31 17:56:52 deraadt Exp $";
d75 10
a84 1
	char c;
@


1.14
log
@check right variable
@
text
@d2 1
d18 1
d37 1
a37 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.13 1996/08/30 16:32:08 deraadt Exp $";
@


1.13
log
@avoid port 1023 more
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.12 1996/08/30 04:07:43 millert Exp $";
d251 1
a251 1
	if (alport != IPPORT_RESERVED - 1) {
@


1.12
log
@call rcmdsh() if euid != 0 and port is shell/tcp.  This lets us
get away with fewer setuid binaries.
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.11 1996/08/19 08:29:39 tholo Exp $";
d78 1
d80 2
a81 1
			return(rcmdsh(ahost, rport, locuser, remuser, cmd, NULL));
d251 7
a257 5
	if (bind(s, (struct sockaddr *)&sin, sizeof(sin)) >= 0)
		return (s);
	if (errno != EADDRINUSE) {
		(void)close(s);
		return (-1);
@


1.11
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: rcmd.c,v 1.12 1995/06/03 22:33:34 mycroft Exp $";
d75 7
d89 1
@


1.10
log
@seed rresvport() for aux channel with a known taken port; do not ask for
next lower port because we might get it (and be predictable!)
@
text
@a0 2
/*	$NetBSD: rcmd.c,v 1.12 1995/06/03 22:33:34 mycroft Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)rcmd.c	8.3 (Berkeley) 3/26/94";
#else
static char *rcsid = "$NetBSD: rcmd.c,v 1.12 1995/06/03 22:33:34 mycroft Exp $";
#endif
@


1.9
log
@if port 20 incoming, kill it and try again
@
text
@d136 5
d142 1
@


1.8
log
@ensure bindresvport() is told to find a port
@
text
@d156 1
d174 8
@


1.7
log
@rresvport() in terms of bind() & bindresvport()
@
text
@d238 1
@


1.6
log
@bzero sockaddr_in
@
text
@d231 6
a236 14
	for (;;) {
		sin.sin_port = htons((u_short)*alport);
		if (bind(s, (struct sockaddr *)&sin, sizeof(sin)) >= 0)
			return (s);
		if (errno != EADDRINUSE) {
			(void)close(s);
			return (-1);
		}
		(*alport)--;
		if (*alport == IPPORT_RESERVED/2) {
			(void)close(s);
			errno = EAGAIN;		/* close */
			return (-1);
		}
d238 6
@


1.5
log
@bzero sockaddr before use
@
text
@d102 1
@


1.4
log
@support # comments
@
text
@d223 1
@


1.3
log
@iruserok() can finally safely use a u_int32_t for the ip addr
@
text
@d381 2
@


1.2
log
@fix long/u_int32_t botch; do gethostbyname() only if netgroups are going to
be used and do not abort; check for A->PTR->A loop otherwise only match on
#.#.#.# addresses; do not assume !0 is 1 as in ANSI C. netbsd pr#1683 led to
finding these problems.
@
text
@d76 1
a76 1
	long oldmask;
d283 1
a283 1
	u_long raddr;
@


1.1
log
@Initial revision
@
text
@d60 1
d63 2
a64 1
static int __icheckhost __P((u_long, const char *));
d258 1
a258 1
	u_long addrs[MAXADDRS + 1];
d267 1
a267 1
		if (iruserok(addrs[i], superuser, ruser, luser) == 0)
d357 1
a357 1
__ivaliduser(hostf, raddr, luser, ruser)
d359 1
a359 1
	u_long raddr;
d367 1
a367 2
	char rhost[MAXHOSTNAMELEN];
	struct hostent *hp;
d369 1
d377 2
a378 1
			while ((ch = getc(hostf)) != '\n' && ch != EOF);
d403 5
a407 8
		if ((hp = gethostbyaddr((char *) &raddr,
					sizeof(raddr), AF_INET)) == NULL) {
			abort();
			return -1;
		}
		(void) strncpy(rhost, hp->h_name, sizeof(rhost));
		rhost[sizeof(rhost) - 1] = '\0';

a412 1

d414 6
a419 2
				hostok = innetgr(&ahost[2], rhost, NULL,
						 domain);
a420 1

a429 1

d431 6
a436 2
				hostok = -innetgr(&ahost[2], rhost, NULL,
						  domain);
a437 1

a450 1

d453 1
a453 1
						 domain);
a454 1

d456 1
a456 1
				userok = strcmp(ruser, &auser[1]) == 0;
a463 1

d466 1
a466 1
						  domain);
a467 1

d469 1
a469 1
				userok = -(strcmp(ruser, &auser[1]) == 0);
d473 1
a473 1
			userok = strcmp(ruser, auser) == 0;
d480 2
a481 2
		if (userok == -1 || hostok == -1)
			return -1;
d484 2
a485 2
		if (hostok == 1 && userok == 1)
			return 0;
d487 1
a487 1
	return -1;
d491 2
a492 1
 * Returns "true" if match, 0 if no match.
d496 1
a496 1
	u_long raddr;
a499 1
	register u_long laddr;
d501 1
d503 7
a509 12
	/* Try for raw ip address first. */
	if (isdigit(*lhost) && (long)(laddr = inet_addr(lhost)) != -1)
		return (raddr == laddr);

	/* Better be a hostname. */
	if ((hp = gethostbyname(lhost)) == NULL)
		return (0);

	/* Spin through ip addresses. */
	for (pp = hp->h_addr_list; *pp; ++pp)
		if (!bcmp(&raddr, *pp, sizeof(u_long)))
			return (1);
d511 3
a513 1
	/* No match. */
d515 41
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

