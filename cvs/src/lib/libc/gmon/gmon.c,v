head	1.30;
access;
symbols
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.2
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.10
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.8
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.20.0.28
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.26
	OPENBSD_5_0:1.20.0.24
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.22
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.20
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.16
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.18
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.14
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.12
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.10
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.8
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.6
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.14
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.6
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.8.0.4
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.29;
commitid	pqjnYVtACzQ9ctai;

1.29
date	2016.05.07.19.30.52;	author guenther;	state Exp;
branches;
next	1.28;
commitid	JQ2dTBX74hL8uXnI;

1.28
date	2016.03.14.14.48.02;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	6QPXRsk9BXtBq2ys;

1.27
date	2016.03.13.18.34.20;	author guenther;	state Exp;
branches;
next	1.26;
commitid	AStIlKdF20sYXV6x;

1.26
date	2016.01.19.20.32.29;	author mmcc;	state Exp;
branches;
next	1.25;
commitid	irEdUhgNer2P73mr;

1.25
date	2015.09.14.14.17.10;	author guenther;	state Exp;
branches;
next	1.24;
commitid	tJJYhoJiiYi33C89;

1.24
date	2015.05.06.23.52.49;	author jsg;	state Exp;
branches;
next	1.23;
commitid	4zD1g8QtveDZZngX;

1.23
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	0DYulI8hhujBHMcR;

1.22
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2013.02.12.07.31.13;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.20.17.06.06;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.21.00.09.01;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.23.19.32.09;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.25.21.16.47;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.20.18.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.24.07.26.43;	author cloder;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.25.09.11.02;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.07.15.18.59.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.07.15.18.46.25;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.07.05.18.36.52;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.21.11.27;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.09.15.09.31.12;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.09.05.12.29.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.19.08.28.02;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.06.18.10.07.41;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.25.22.11.05;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.02.15.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@/*	$OpenBSD: gmon.c,v 1.29 2016/05/07 19:30:52 guenther Exp $ */
/*-
 * Copyright (c) 1983, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/time.h>
#include <sys/gmon.h>
#include <sys/mman.h>
#include <sys/sysctl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <limits.h>
#include <unistd.h>

struct gmonparam _gmonparam = { GMON_PROF_OFF };

static int	s_scale;
/* see profil(2) where this is describe (incorrectly) */
#define		SCALE_1_TO_1	0x10000L

#define ERR(s) write(STDERR_FILENO, s, sizeof(s))

PROTO_NORMAL(moncontrol);
PROTO_DEPRECATED(monstartup);
static int hertz(void);

void
monstartup(u_long lowpc, u_long highpc)
{
	int o;
	void *addr;
	struct gmonparam *p = &_gmonparam;

	/*
	 * round lowpc and highpc to multiples of the density we're using
	 * so the rest of the scaling (here and in gprof) stays in ints.
	 */
	p->lowpc = ROUNDDOWN(lowpc, HISTFRACTION * sizeof(HISTCOUNTER));
	p->highpc = ROUNDUP(highpc, HISTFRACTION * sizeof(HISTCOUNTER));
	p->textsize = p->highpc - p->lowpc;
	p->kcountsize = p->textsize / HISTFRACTION;
	p->hashfraction = HASHFRACTION;
	p->fromssize = p->textsize / p->hashfraction;
	p->tolimit = p->textsize * ARCDENSITY / 100;
	if (p->tolimit < MINARCS)
		p->tolimit = MINARCS;
	else if (p->tolimit > MAXARCS)
		p->tolimit = MAXARCS;
	p->tossize = p->tolimit * sizeof(struct tostruct);

	addr = mmap(NULL, p->kcountsize,  PROT_READ|PROT_WRITE,
	    MAP_ANON|MAP_PRIVATE, -1, 0);
	if (addr == MAP_FAILED)
		goto mapfailed;
	p->kcount = addr;

	addr = mmap(NULL, p->fromssize,  PROT_READ|PROT_WRITE,
	    MAP_ANON|MAP_PRIVATE, -1, 0);
	if (addr == MAP_FAILED)
		goto mapfailed;
	p->froms = addr;

	addr = mmap(NULL, p->tossize,  PROT_READ|PROT_WRITE,
	    MAP_ANON|MAP_PRIVATE, -1, 0);
	if (addr == MAP_FAILED)
		goto mapfailed;
	p->tos = addr;
	p->tos[0].link = 0;

	o = p->highpc - p->lowpc;
	if (p->kcountsize < o) {
#ifndef notdef
		s_scale = ((float)p->kcountsize / o ) * SCALE_1_TO_1;
#else /* avoid floating point */
		int quot = o / p->kcountsize;

		if (quot >= 0x10000)
			s_scale = 1;
		else if (quot >= 0x100)
			s_scale = 0x10000 / quot;
		else if (o >= 0x800000)
			s_scale = 0x1000000 / (o / (p->kcountsize >> 8));
		else
			s_scale = 0x1000000 / ((o << 8) / p->kcountsize);
#endif
	} else
		s_scale = SCALE_1_TO_1;

	moncontrol(1);
	return;

mapfailed:
	if (p->kcount != NULL) {
		munmap(p->kcount, p->kcountsize);
		p->kcount = NULL;
	}
	if (p->froms != NULL) {
		munmap(p->froms, p->fromssize);
		p->froms = NULL;
	}
	if (p->tos != NULL) {
		munmap(p->tos, p->tossize);
		p->tos = NULL;
	}
	ERR("monstartup: out of memory\n");
}
__strong_alias(_monstartup,monstartup);

void
_mcleanup(void)
{
	int fd;
	int fromindex;
	int endfrom;
	u_long frompc;
	int toindex;
	struct rawarc rawarc;
	struct gmonparam *p = &_gmonparam;
	struct gmonhdr gmonhdr, *hdr;
	struct clockinfo clockinfo;
	int mib[2];
	size_t size;
	char *profdir;
	char *proffile;
	char  buf[PATH_MAX];
#ifdef DEBUG
	int log, len;
	char dbuf[200];
#endif

	if (p->state == GMON_PROF_ERROR)
		ERR("_mcleanup: tos overflow\n");

	size = sizeof(clockinfo);
	mib[0] = CTL_KERN;
	mib[1] = KERN_CLOCKRATE;
	if (sysctl(mib, 2, &clockinfo, &size, NULL, 0) < 0) {
		/*
		 * Best guess
		 */
		clockinfo.profhz = hertz();
	} else if (clockinfo.profhz == 0) {
		if (clockinfo.hz != 0)
			clockinfo.profhz = clockinfo.hz;
		else
			clockinfo.profhz = hertz();
	}

	moncontrol(0);

	if (issetugid() == 0 && (profdir = getenv("PROFDIR")) != NULL) {
		char *s, *t, *limit;
		pid_t pid;
		long divisor;

		/* If PROFDIR contains a null value, no profiling
		   output is produced */
		if (*profdir == '\0') {
			return;
		}

		limit = buf + sizeof buf - 1 - 10 - 1 -
		    strlen(__progname) - 1;
		t = buf;
		s = profdir;
		while((*t = *s) != '\0' && t < limit) {
			t++;
			s++;
		}
		*t++ = '/';

		/*
		 * Copy and convert pid from a pid_t to a string.  For
		 * best performance, divisor should be initialized to
		 * the largest power of 10 less than PID_MAX.
		 */
		pid = getpid();
		divisor=10000;
		while (divisor > pid) divisor /= 10;	/* skip leading zeros */
		do {
			*t++ = (pid/divisor) + '0';
			pid %= divisor;
		} while (divisor /= 10);
		*t++ = '.';

		s = __progname;
		while ((*t++ = *s++) != '\0')
			;

		proffile = buf;
	} else {
		proffile = "gmon.out";
	}

	fd = open(proffile , O_CREAT|O_TRUNC|O_WRONLY, 0664);
	if (fd < 0) {
		perror( proffile );
		return;
	}
#ifdef DEBUG
	log = open("gmon.log", O_CREAT|O_TRUNC|O_WRONLY, 0664);
	if (log < 0) {
		perror("mcount: gmon.log");
		close(fd);
		return;
	}
	snprintf(dbuf, sizeof dbuf, "[mcleanup1] kcount 0x%x ssiz %d\n",
	    p->kcount, p->kcountsize);
	write(log, dbuf, strlen(dbuf));
#endif
	hdr = (struct gmonhdr *)&gmonhdr;
	bzero(hdr, sizeof(*hdr));
	hdr->lpc = p->lowpc;
	hdr->hpc = p->highpc;
	hdr->ncnt = p->kcountsize + sizeof(gmonhdr);
	hdr->version = GMONVERSION;
	hdr->profrate = clockinfo.profhz;
	write(fd, (char *)hdr, sizeof *hdr);
	write(fd, p->kcount, p->kcountsize);
	endfrom = p->fromssize / sizeof(*p->froms);
	for (fromindex = 0; fromindex < endfrom; fromindex++) {
		if (p->froms[fromindex] == 0)
			continue;

		frompc = p->lowpc;
		frompc += fromindex * p->hashfraction * sizeof(*p->froms);
		for (toindex = p->froms[fromindex]; toindex != 0;
		     toindex = p->tos[toindex].link) {
#ifdef DEBUG
			(void) snprintf(dbuf, sizeof dbuf,
			"[mcleanup2] frompc 0x%x selfpc 0x%x count %d\n" ,
				frompc, p->tos[toindex].selfpc,
				p->tos[toindex].count);
			write(log, dbuf, strlen(dbuf));
#endif
			rawarc.raw_frompc = frompc;
			rawarc.raw_selfpc = p->tos[toindex].selfpc;
			rawarc.raw_count = p->tos[toindex].count;
			write(fd, &rawarc, sizeof rawarc);
		}
	}
	close(fd);
#ifdef notyet
	if (p->kcount != NULL) {
		munmap(p->kcount, p->kcountsize);
		p->kcount = NULL;
	}
	if (p->froms != NULL) {
		munmap(p->froms, p->fromssize);
		p->froms = NULL;
	}
	if (p->tos != NULL) {
		munmap(p->tos, p->tossize);
		p->tos = NULL;
	}
#endif
}

/*
 * Control profiling
 *	profiling is what mcount checks to see if
 *	all the data structures are ready.
 */
void
moncontrol(int mode)
{
	struct gmonparam *p = &_gmonparam;

	if (mode) {
		/* start */
		profil((char *)p->kcount, p->kcountsize, p->lowpc,
		    s_scale);
		p->state = GMON_PROF_ON;
	} else {
		/* stop */
		profil(NULL, 0, 0, 0);
		p->state = GMON_PROF_OFF;
	}
}
DEF_WEAK(moncontrol);

/*
 * discover the tick frequency of the machine
 * if something goes wrong, we return 0, an impossible hertz.
 */
static int
hertz(void)
{
	struct itimerval tim;

	tim.it_interval.tv_sec = 0;
	tim.it_interval.tv_usec = 1;
	tim.it_value.tv_sec = 0;
	tim.it_value.tv_usec = 0;
	setitimer(ITIMER_REAL, &tim, 0);
	setitimer(ITIMER_REAL, 0, &tim);
	if (tim.it_interval.tv_usec < 2)
		return(0);
	return (1000000 / tim.it_interval.tv_usec);
}
@


1.29
log
@Declare moncontrol(3) APIs in <sys/gmon.h>
Export _gmonparam again.
Make gcrt0.o use an reserved name for _monstartup()

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gmon.c,v 1.28 2016/03/14 14:48:02 mmcc Exp $ */
d80 1
a80 1
	    MAP_ANON|MAP_PRIVATE, -1, (off_t)0);
d86 1
a86 1
	    MAP_ANON|MAP_PRIVATE, -1, (off_t)0);
d92 1
a92 1
	    MAP_ANON|MAP_PRIVATE, -1, (off_t)0);
@


1.28
log
@(char *)0 -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: gmon.c,v 1.27 2016/03/13 18:34:20 guenther Exp $ */
a50 1
void	moncontrol(int);
d52 1
a53 2
void	monstartup(u_long lowpc, u_long highpc);
void	_mcleanup(void);
d135 1
@


1.27
log
@environ and __progname are not declared in a public header; declare them
in libc's hidden/stdlib.h instead of in each .c file that needs one

ok deraadt@@ gsoares@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gmon.c,v 1.26 2016/01/19 20:32:29 mmcc Exp $ */
d305 1
a305 1
		profil((char *)0, 0, 0, 0);
@


1.26
log
@replace (void *)0 with NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: gmon.c,v 1.25 2015/09/14 14:17:10 guenther Exp $ */
a180 1
		extern char *__progname;
@


1.25
log
@Wrap moncontrol() so that internal calls go direct and it's a weak symbol
@
text
@d1 1
a1 1
/*	$OpenBSD: gmon.c,v 1.24 2015/05/06 23:52:49 jsg Exp $ */
d81 1
a81 1
	addr = mmap((void *)0, p->kcountsize,  PROT_READ|PROT_WRITE,
d87 1
a87 1
	addr = mmap((void *)0, p->fromssize,  PROT_READ|PROT_WRITE,
d93 1
a93 1
	addr = mmap((void *)0, p->tossize,  PROT_READ|PROT_WRITE,
@


1.24
log
@fix a fd leak in an error path in code under #ifdef DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: gmon.c,v 1.23 2015/01/16 16:48:51 deraadt Exp $ */
d52 1
d310 1
@


1.23
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: gmon.c,v 1.22 2013/02/12 08:06:22 mpi Exp $ */
d233 1
@


1.22
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: gmon.c,v 1.20 2005/11/20 17:06:06 millert Exp $ */
a30 1
#include <sys/param.h>
@


1.21
log
@Unbreak the tree by adding missing defines. Forgot to sync in previous
spotted by todd@@.
@
text
@a49 3
#define ROUNDDOWN(x,y)(((x)/(y))*(y))
#define ROUNDUP(x,y)((((x)+(y)-1)/(y))*(y))

@


1.20
log
@Allocate space for profiling data using mmap instead of sbrk.
Tested by myself and pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gmon.c,v 1.19 2005/08/08 08:05:34 espie Exp $ */
d49 3
@


1.19
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d34 1
a43 2
extern char *minbrk __asm ("minbrk");

d61 1
a61 1
	char *cp;
d81 17
a97 15
	cp = sbrk(p->kcountsize + p->fromssize + p->tossize);
	if (cp == (char *)-1) {
		ERR("monstartup: out of memory\n");
		return;
	}
#ifdef notdef
	bzero(cp, p->kcountsize + p->fromssize + p->tossize);
#endif
	p->tos = (struct tostruct *)cp;
	cp += p->tossize;
	p->kcount = (u_short *)cp;
	cp += p->kcountsize;
	p->froms = (u_short *)cp;

	minbrk = sbrk(0);
d120 16
d272 14
a328 2


@


1.18
log
@be more careful about snprintf return value; ok beck cloder
@
text
@d1 1
a29 4

#if !defined(lint) && defined(LIBC_SCCS)
static char rcsid[] = "$OpenBSD: gmon.c,v 1.17 2005/03/23 19:32:09 otto Exp $";
#endif
@


1.17
log
@deregister & ansify. ok deraad@@ marco@@ cloder@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.16 2003/06/25 21:16:47 deraadt Exp $";
d222 1
a222 1
	len = snprintf(dbuf, sizeof dbuf, "[mcleanup1] kcount 0x%x ssiz %d\n",
d224 1
a224 1
	write(log, dbuf, len);
d245 1
a245 1
			len = snprintf(dbuf, sizeof dbuf,
d249 1
a249 1
			write(log, dbuf, len);
@


1.16
log
@protos
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.15 2003/06/02 20:18:35 millert Exp $";
d62 1
a62 3
monstartup(lowpc, highpc)
	u_long lowpc;
	u_long highpc;
d64 1
a64 1
	register int o;
d266 1
a266 2
moncontrol(mode)
	int mode;
d287 1
a287 1
hertz()
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.14 2002/11/24 07:26:43 cloder Exp $";
d58 2
d127 1
a127 1
_mcleanup()
@


1.14
log
@Zero out the reserved fields of struct gmonhdr rather than leaving
stack garbage in them.  From FreeBSD.

OK deraadt@@
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.13 2002/05/25 09:11:02 deraadt Exp $";
@


1.13
log
@remaining easy snprintf conversions
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.12 2002/02/16 21:27:23 millert Exp $";
d231 1
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.11 1998/07/15 18:59:04 millert Exp $";
d226 1
a226 1
	len = sprintf(dbuf, "[mcleanup1] kcount 0x%x ssiz %d\n",
d248 1
a248 1
			len = sprintf(dbuf,
@


1.11
log
@make that 0664 until we find out why umask is not being applied
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.10 1998/07/15 18:46:25 millert Exp $";
d60 2
a61 2
void	moncontrol __P((int));
static int hertz __P((void));
@


1.10
log
@open gmon.out mode 0644, not 0666
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.9 1998/07/05 18:36:52 deraadt Exp $";
d215 1
a215 1
	fd = open(proffile , O_CREAT|O_TRUNC|O_WRONLY, 0644);
@


1.9
log
@use STDERR_FILENO; kleink
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.8 1997/07/23 21:11:27 kstailey Exp $";
d215 1
a215 1
	fd = open(proffile , O_CREAT|O_TRUNC|O_WRONLY, 0666);
@


1.8
log
@tabify + trailing blanks
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.7 1996/09/15 09:31:12 tholo Exp $";
d58 1
a58 1
#define ERR(s) write(2, s, sizeof(s))
@


1.7
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.6 1996/09/05 12:29:12 deraadt Exp $";
d112 1
a112 1
		
d176 1
a176 1
		/* If PROFDIR contains a null value, no profiling 
d181 1
a181 1
		
d192 2
a193 2
		/* 
		 * Copy and convert pid from a pid_t to a string.  For 
d294 1
a294 1
	
@


1.6
log
@protect getenv, do not oflow, fix unused debug; bitblt and deraadt
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.5 1996/08/19 08:28:02 tholo Exp $";
d45 1
@


1.5
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: gmon.c,v 1.5.4.1 1996/06/12 04:20:16 cgd Exp $";
d146 1
a146 1
	char buf[200];
d169 1
a169 1
	if ((profdir = getenv("PROFDIR")) != NULL) {
d171 1
a171 1
		char *s, *t;
d181 2
d185 1
a185 1
		while((*t = *s) != '\0') {
d225 1
a225 1
	len = sprintf(buf, "[mcleanup1] kcount 0x%x ssiz %d\n",
d227 1
a227 1
	write(log, buf, len);
d247 1
a247 1
			len = sprintf(buf,
d251 1
a251 1
			write(log, buf, len);
@


1.4
log
@use p->hashfraction when doing non-time-critical calculations, rather than
using HASHFRACTION directly.  in time-critical calculations, if HASHFRACTION
is a power of two, check that p->hashfraction == HASHFRACTION and if so do
the calculation with the compiled-in value so that the compiler can optimize
out (potentially) expensive divisions.  if p->hashfraction != HASHFRACTION,
actually do the division.  This has the result that on machines with slow
division, the division can be optimized out of the common case, but that
if HASHFRACTION changes from the compiled-in value (for whatever reason),
profiling will still work.  Changes suggested by Chris Torek.
@
text
@a0 2
/*	$NetBSD: gmon.c,v 1.5.4.1 1996/06/12 04:20:16 cgd Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)gmon.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: gmon.c,v 1.5.4.1 1996/06/12 04:20:16 cgd Exp $";
#endif
@


1.3
log
@Protect internal mcount symbol from lint(1)
Use __asm, not asm
@
text
@d1 1
a1 1
/*	$NetBSD: gmon.c,v 1.5 1995/11/21 22:23:47 jtc Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: gmon.c,v 1.5 1995/11/21 22:23:47 jtc Exp $";
d86 1
a86 1
	p->fromssize = p->textsize / HASHFRACTION;
@


1.2
log
@from cgd@@netbsd:
kill a gratuitous cast of lowpc to an int
Add support for PROFDIR environment variable
@
text
@d55 1
a55 1
extern char *minbrk asm ("minbrk");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: gmon.c,v 1.3 1995/02/27 12:54:39 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: gmon.c,v 1.3 1995/02/27 12:54:39 cgd Exp $";
d50 1
d52 1
d147 3
d174 45
a218 1
	fd = open("gmon.out", O_CREAT|O_TRUNC|O_WRONLY, 0666);
d220 1
a220 1
		perror("mcount: gmon.out");
d279 1
a279 1
		profil((char *)p->kcount, p->kcountsize, (int)p->lowpc,
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
