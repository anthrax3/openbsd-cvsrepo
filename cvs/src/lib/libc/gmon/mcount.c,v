head	1.15;
access;
symbols
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.12
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.8
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.8
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.18
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.20
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.16
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.14
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.12
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.10
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.8
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.6
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.18
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.16
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	0DYulI8hhujBHMcR;

1.14
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.13;

1.13
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.12;

1.12
date	2013.02.11.17.17.03;	author mpi;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.09.15.56.08;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.23.19.32.09;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.20.18.35;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.23.21.11.27;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.01.30.05.05.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.08.28.04;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.06.18.10.07.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.22.11.06;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@/*	$OpenBSD: mcount.c,v 1.14 2013/03/12 09:37:16 mpi Exp $ */
/*-
 * Copyright (c) 1983, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/gmon.h>

/*
 * mcount is called on entry to each function compiled with the profiling
 * switch set.  _mcount(), which is declared in a machine-dependent way
 * with _MCOUNT_DECL, does the actual work and is either inlined into a
 * C routine or called by an assembly stub.  In any case, this magic is
 * taken care of by the MCOUNT definition in <machine/profile.h>.
 *
 * _mcount updates data structures that represent traversals of the
 * program's call graph edges.  frompc and selfpc are the return
 * address and function address that represents the given call graph edge.
 */
_MCOUNT_DECL(u_long frompc, u_long selfpc) __used;
/* _mcount; may be static, inline, etc */
_MCOUNT_DECL(u_long frompc, u_long selfpc)
{
	u_short *frompcindex;
	struct tostruct *top, *prevtop;
	struct gmonparam *p;
	long toindex;
#ifdef _KERNEL
	int s;

	/*
	 * Do not profile execution if memory for the current CPU
	 * desciptor and profiling buffers has not yet been allocated
	 * or if the CPU we are running on has not yet set its trap
	 * handler.
	 */
	if (gmoninit == 0)
		return;

	if ((p = curcpu()->ci_gmon) == NULL)
		return;
#else
	p = &_gmonparam;
#endif
	/*
	 * check that we are profiling
	 * and that we aren't recursively invoked.
	 */
	if (p->state != GMON_PROF_ON)
		return;
#ifdef _KERNEL
	MCOUNT_ENTER;
#else
	p->state = GMON_PROF_BUSY;
#endif
	/*
	 * check that frompcindex is a reasonable pc value.
	 * for example:	signal catchers get called from the stack,
	 *		not from text space.  too bad.
	 */
	frompc -= p->lowpc;
	if (frompc > p->textsize)
		goto done;

#if (HASHFRACTION & (HASHFRACTION - 1)) == 0
	if (p->hashfraction == HASHFRACTION)
		frompcindex =
		    &p->froms[frompc / (HASHFRACTION * sizeof(*p->froms))];
	else
#endif
		frompcindex =
		    &p->froms[frompc / (p->hashfraction * sizeof(*p->froms))];
	toindex = *frompcindex;
	if (toindex == 0) {
		/*
		 *	first time traversing this arc
		 */
		toindex = ++p->tos[0].link;
		if (toindex >= p->tolimit)
			/* halt further profiling */
			goto overflow;

		*frompcindex = toindex;
		top = &p->tos[toindex];
		top->selfpc = selfpc;
		top->count = 1;
		top->link = 0;
		goto done;
	}
	top = &p->tos[toindex];
	if (top->selfpc == selfpc) {
		/*
		 * arc at front of chain; usual case.
		 */
		top->count++;
		goto done;
	}
	/*
	 * have to go looking down chain for it.
	 * top points to what we are looking at,
	 * prevtop points to previous top.
	 * we know it is not at the head of the chain.
	 */
	for (; /* goto done */; ) {
		if (top->link == 0) {
			/*
			 * top is end of the chain and none of the chain
			 * had top->selfpc == selfpc.
			 * so we allocate a new tostruct
			 * and link it to the head of the chain.
			 */
			toindex = ++p->tos[0].link;
			if (toindex >= p->tolimit)
				goto overflow;

			top = &p->tos[toindex];
			top->selfpc = selfpc;
			top->count = 1;
			top->link = *frompcindex;
			*frompcindex = toindex;
			goto done;
		}
		/*
		 * otherwise, check the next arc on the chain.
		 */
		prevtop = top;
		top = &p->tos[top->link];
		if (top->selfpc == selfpc) {
			/*
			 * there it is.
			 * increment its count
			 * move it to the head of the chain.
			 */
			top->count++;
			toindex = prevtop->link;
			prevtop->link = top->link;
			top->link = *frompcindex;
			*frompcindex = toindex;
			goto done;
		}
	}
done:
#ifdef _KERNEL
	MCOUNT_EXIT;
#else
	p->state = GMON_PROF_ON;
#endif
	return;
overflow:
	p->state = GMON_PROF_ERROR;
#ifdef _KERNEL
	MCOUNT_EXIT;
#endif
	return;
}

/*
 * Actual definition of mcount function.  Defined in <machine/profile.h>,
 * which is included by <sys/gmon.h>.
 */
MCOUNT
@


1.14
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.13 2013/02/12 08:06:22 mpi Exp $ */
d31 1
a31 1
#include <sys/param.h>
@


1.13
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.11 2010/05/09 15:56:08 kettenis Exp $ */
a43 4
 *
 * Note: the original BSD code used the same variable (frompcindex) for
 * both frompcindex and frompc.  Any reasonable, modern compiler will
 * perform this optimization.
a54 1
#endif
d56 12
d69 1
a181 1
#ifndef lint
a186 1
#endif
@


1.12
log
@Sync with libkern's copy. No functional change.
@
text
@a1 1

d44 4
d59 1
a60 12
	/*
	 * Do not profile execution if memory for the current CPU
	 * desciptor and profiling buffers has not yet been allocated
	 * or if the CPU we are running on has not yet set its trap
	 * handler.
	 */
	if (gmoninit == 0)
		return;

	if ((p = curcpu()->ci_gmon) == NULL)
		return;
#else
a61 1
#endif
d174 1
d180 1
@


1.11
log
@Mark _MCOUNT_DECL as __used to prevent gcc4 from optimizing it away when it
is only referenced from inline asm.

ok jsg@@
@
text
@d1 2
a2 1
/*	$OpenBSD: mcount.c,v 1.10 2005/08/08 08:05:34 espie Exp $ */
a44 4
 *
 * Note: the original BSD code used the same variable (frompcindex) for
 * both frompcindex and frompc.  Any reasonable, modern compiler will
 * perform this optimization.
a55 1
#endif
d57 12
d70 1
a182 1
#ifndef lint
a187 1
#endif
@


1.10
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d49 1
a49 1
_MCOUNT_DECL(u_long frompc, u_long selfpc);
@


1.9
log
@deregister & ansify. ok deraad@@ marco@@ cloder@@
@
text
@d1 1
a29 4

#if !defined(lint) && !defined(_KERNEL) && defined(LIBC_SCCS)
static char rcsid[] = "$OpenBSD: mcount.c,v 1.8 2003/06/02 20:18:35 millert Exp $";
#endif
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.7 2002/02/16 21:27:23 millert Exp $";
d53 2
a54 2
_MCOUNT_DECL(frompc, selfpc)	/* _mcount; may be static, inline, etc */
	register u_long frompc, selfpc;
d56 4
a59 4
	register u_short *frompcindex;
	register struct tostruct *top, *prevtop;
	register struct gmonparam *p;
	register long toindex;
d61 1
a61 1
	register int s;
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.6 1997/07/23 21:11:27 kstailey Exp $";
@


1.6
log
@tabify + trailing blanks
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.5 1997/01/30 05:05:00 deraadt Exp $";
d56 1
a56 1
_MCOUNT_DECL __P((u_long frompc, u_long selfpc));
@


1.5
log
@proto; felix@@mamba.pond.sub.org
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.4 1996/08/19 08:28:04 tholo Exp $";
d51 1
a51 1
 * 
a164 1
		
@


1.4
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.3.6.2 1996/06/12 04:20:17 cgd Exp $";
d56 1
@


1.3
log
@use p->hashfraction when doing non-time-critical calculations, rather than
using HASHFRACTION directly.  in time-critical calculations, if HASHFRACTION
is a power of two, check that p->hashfraction == HASHFRACTION and if so do
the calculation with the compiled-in value so that the compiler can optimize
out (potentially) expensive divisions.  if p->hashfraction != HASHFRACTION,
actually do the division.  This has the result that on machines with slow
division, the division can be optimized out of the common case, but that
if HASHFRACTION changes from the compiled-in value (for whatever reason),
profiling will still work.  Changes suggested by Chris Torek.
@
text
@a0 2
/*	$NetBSD: mcount.c,v 1.3.6.2 1996/06/12 04:20:17 cgd Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)mcount.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: mcount.c,v 1.3.6.2 1996/06/12 04:20:17 cgd Exp $";
#endif
@


1.2
log
@Protect internal mcount symbol from lint(1)
Use __asm, not asm
@
text
@d1 1
a1 1
/*	$NetBSD: mcount.c,v 1.3 1995/02/27 12:54:42 cgd Exp $	*/
d36 1
a36 1
#if !defined(lint) && !defined(KERNEL) && defined(LIBC_SCCS)
d40 1
a40 1
static char rcsid[] = "$NetBSD: mcount.c,v 1.3 1995/02/27 12:54:42 cgd Exp $";
d69 1
a69 1
#ifdef KERNEL
d80 1
a80 1
#ifdef KERNEL
d94 8
a101 1
	frompcindex = &p->froms[frompc / (p->hashfraction * sizeof(*p->froms))];
d173 1
a173 1
#ifdef KERNEL
d181 1
a181 1
#ifdef KERNEL
@


1.1
log
@Initial revision
@
text
@d180 1
d186 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
