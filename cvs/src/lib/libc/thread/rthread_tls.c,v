head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.2
	OPENBSD_6_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.4
date	2017.09.05.02.40.54;	author guenther;	state Exp;
branches;
next	1.3;
commitid	5DW3WOQF0YGGx8lJ;

1.3
date	2017.08.15.07.06.29;	author guenther;	state Exp;
branches;
next	1.2;
commitid	mJt2tgNK0YgfUXy0;

1.2
date	2017.08.15.06.38.41;	author guenther;	state Exp;
branches;
next	1.1;
commitid	TU99Y0Z5Kx7X2p3e;

1.1
date	2017.08.15.06.13.24;	author guenther;	state Exp;
branches;
next	;
commitid	2ly112pNJTEbf5qJ;


desc
@@


1.4
log
@Move mutex, condvar, and thread-specific data routes, pthread_once, and
pthread_exit from libpthread to libc, along with low-level bits to
support them.  Major bump to both libc and libpthread.

Requested by libressl team.  Ports testing by naddy@@
ok kettenis@@
@
text
@/*	$OpenBSD: rthread_tls.c,v 1.3 2017/08/15 07:06:29 guenther Exp $ */
/*
 * Copyright (c) 2004,2005 Ted Unangst <tedu@@openbsd.org>
 * All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * thread specific storage
 */

#include <errno.h>
#include <pthread.h>
#include <stdlib.h>

#include <pthread.h>
#include <stdlib.h>

#include "rthread.h"


struct rthread_key {
	int used;
	void (*destructor)(void *);
};

static struct rthread_key rkeys[PTHREAD_KEYS_MAX];
static _atomic_lock_t rkeyslock = _SPINLOCK_UNLOCKED;

int
pthread_key_create(pthread_key_t *key, void (*destructor)(void*))
{
	static int hint;
	int i;

	_spinlock(&rkeyslock);
	if (rkeys[hint].used) {
		for (i = 0; i < PTHREAD_KEYS_MAX; i++) {
			if (!rkeys[i].used)
				break;
		}
		if (i == PTHREAD_KEYS_MAX) {
			_spinunlock(&rkeyslock);
			return (EAGAIN);
		}
		hint = i;
	}
	rkeys[hint].used = 1;
	rkeys[hint].destructor = destructor;

	*key = hint++;
	if (hint >= PTHREAD_KEYS_MAX)
		hint = 0;
	_spinunlock(&rkeyslock);

	return (0);
}
DEF_STRONG(pthread_key_create);

int
pthread_key_delete(pthread_key_t key)
{
	struct rthread_storage *rs;
	int rv = 0;

	if (key < 0 || key >= PTHREAD_KEYS_MAX)
		return (EINVAL);

	_spinlock(&rkeyslock);
	if (!rkeys[key].used) {
		rv = EINVAL;
		goto out;
	}

	rkeys[key].used = 0;
	rkeys[key].destructor = NULL;
	if (_thread_cb.tc_thread_key_zero != NULL)
		_thread_cb.tc_thread_key_zero(key);
	else {
		for (rs = _initial_thread.local_storage; rs; rs = rs->next) {
			if (rs->keyid == key)
				rs->data = NULL;
		}
	}

out:
	_spinunlock(&rkeyslock);
	return (rv);
}

static struct rthread_storage *
_rthread_findstorage(pthread_key_t key)
{
	struct rthread_storage *rs;
	pthread_t self;

	if (!rkeys[key].used) {
		rs = NULL;
		goto out;
	}

	self = pthread_self();

	for (rs = self->local_storage; rs; rs = rs->next) {
		if (rs->keyid == key)
			break;
	}
	if (!rs) {
		rs = calloc(1, sizeof(*rs));
		if (!rs)
			goto out;
		rs->keyid = key;
		rs->data = NULL;
		rs->next = self->local_storage;
		self->local_storage = rs;
	}

out:
	return (rs);
}

void *
pthread_getspecific(pthread_key_t key)
{
	struct rthread_storage *rs;

	if (key < 0 || key >= PTHREAD_KEYS_MAX)
		return (NULL);

	rs = _rthread_findstorage(key);
	if (!rs)
		return (NULL);

	return (rs->data);
}
DEF_STRONG(pthread_getspecific);

int
pthread_setspecific(pthread_key_t key, const void *data)
{
	struct rthread_storage *rs;

	if (key < 0 || key >= PTHREAD_KEYS_MAX)
		return (EINVAL);

	rs = _rthread_findstorage(key);
	if (!rs)
		return (ENOMEM);
	rs->data = (void *)data;

	return (0);
}
DEF_STRONG(pthread_setspecific);

void
_rthread_tls_destructors(pthread_t thread)
{
	struct rthread_storage *rs;
	int i;

	_spinlock(&rkeyslock);
	for (i = 0; i < PTHREAD_DESTRUCTOR_ITERATIONS; i++) {
		for (rs = thread->local_storage; rs; rs = rs->next) {
			if (!rs->data)
				continue;
			if (rkeys[rs->keyid].destructor) {
				void (*destructor)(void *) =
				    rkeys[rs->keyid].destructor;
				void *data = rs->data;
				rs->data = NULL;
				_spinunlock(&rkeyslock);
				destructor(data);
				_spinlock(&rkeyslock);
			}
		}
	}
	for (rs = thread->local_storage; rs; rs = thread->local_storage) {
		thread->local_storage = rs->next;
		free(rs);
	}
	_spinunlock(&rkeyslock);
}
@


1.3
log
@s/DEF_STD/DEF_STRONG/ to match namespace.h differences between librthread
and libc
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_tls.c,v 1.2 2017/08/15 06:38:41 guenther Exp $ */
d26 3
d31 6
a72 1
	pthread_t thread;
d87 4
a90 3
	_spinlock(&_thread_lock);
	LIST_FOREACH(thread, &_thread_list, threads) {
		for (rs = thread->local_storage; rs; rs = rs->next) {
a94 1
	_spinunlock(&_thread_lock);
@


1.2
log
@Sort headers per style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_tls.c,v 1.1 2017/08/15 06:13:24 guenther Exp $ */
d59 1
a59 1
DEF_STD(pthread_key_create);
d138 1
a138 1
DEF_STD(pthread_getspecific);
d155 1
a155 1
DEF_STD(pthread_setspecific);
@


1.1
log
@Copy files from ../librthread in preparation for moving functionality
from libpthread to libc.  No changes to the build yet, just making it
easier to review the substantive diffs.

ok beck@@ kettenis@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rthread_tls.c,v 1.18 2016/09/04 10:13:35 akfaew Exp $ */
a21 1
#include <stdlib.h>
a22 1

d24 1
@

