head	1.1;
access;
symbols
	OPENBSD_6_2:1.1.0.8
	OPENBSD_6_2_BASE:1.1
	OPENBSD_6_1:1.1.0.6
	OPENBSD_6_1_BASE:1.1
	OPENBSD_6_0:1.1.0.2
	OPENBSD_6_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.1
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	;
commitid	d9R7VGw9CHTkwXE1;


desc
@@


1.1
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@/*	$OpenBSD$ */
/*
 * Copyright (c) 2016 Philip Guenther <guenther@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <tib.h>

#ifndef PIC
# include <stdlib.h>		/* malloc and free */
#endif

#define ELF_ROUND(x,malign)	(((x) + (malign)-1) & ~((malign)-1))


/*
 * The functions here are weak so that the ld.so versions are used
 * in dynamic links, whether or not libc is static
 */
void	*_dl_allocate_tib(size_t _extra) __attribute__((weak));
void	_dl_free_tib(void *_tib, size_t _extra) __attribute__((weak));

/*
 * Allocate a TIB for passing to __tfork for a new thread.  'extra'
 * is the amount of space to allocate on the side of the TIB opposite
 * of the TLS data: before the TIB for variant 1 and after the TIB
 * for variant 2.  If non-zero, tib_thread is set to point to that area.
 */
void *
_dl_allocate_tib(size_t extra)
{
#ifdef PIC
	return NULL;			/* overriden by ld.so */
#else
	char *base;
	char *thread;
	struct tib *tib;

# if TLS_VARIANT == 1
	/* round up the extra size to align the tib after it */
	extra = ELF_ROUND(extra, sizeof(void *));
	base = malloc(extra + sizeof(struct tib) + _static_tls_size);
	tib = (struct tib *)(base + extra);
	thread = base;

# elif TLS_VARIANT == 2
	/* round up the tib size to align the extra area after it */
	base = malloc(ELF_ROUND(sizeof(struct tib), TIB_EXTRA_ALIGN) +
	    extra + _static_tls_size);
	tib = (struct tib *)(base + _static_tls_size);
	thread = (char *)tib + ELF_ROUND(sizeof(struct tib), TIB_EXTRA_ALIGN);
# endif

	_static_tls_init(base);
	TIB_INIT(tib, NULL, thread);

	return (tib);
#endif /* !PIC */
}

void
_dl_free_tib(void *tib, size_t extra)
{
#ifndef PIC
	size_t tib_offset;

# if TLS_VARIANT == 1
	tib_offset = ELF_ROUND(extra, sizeof(void *));
# elif TLS_VARIANT == 2
	tib_offset = _static_tls_size;
# endif

	free((char *)tib - tib_offset);
#endif /* !PIC */
}
@
