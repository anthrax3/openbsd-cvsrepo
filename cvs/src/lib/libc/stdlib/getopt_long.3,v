head	1.21;
access;
symbols
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.12
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.8
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.6
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.15.0.14
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.10
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.12
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.8
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.6
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.4
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5;
locks; strict;
comment	@.\" @;


1.21
date	2016.01.04.19.43.13;	author tb;	state Exp;
branches;
next	1.20;
commitid	tlE9New8zMPEA5xe;

1.20
date	2013.06.05.03.39.23;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2011.03.21.13.41.50;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.05.22.10.11;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2011.01.24.01.50.25;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.19.22.22.13;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.03.12.06.07;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.31.19.19.31;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.06.20.07.15;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.11.01.23.41;	author jaredy;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.26.04.17.44;	author jaredy;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.06.23.44.28;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.02.18.24.21;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.20.18.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.03.49.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.10.06.48.30;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.24.03.09.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.10.21.51.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.05.21.02.19;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.04.21.42.22;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.03.20.24.30;	author millert;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Follow style(9) and drop lint /* NOTREACHED */ annotations from
the examples.

Diff from Juuso Lapinlampi < wub () partyvan ! eu >, thanks!

ok schwarze@@
@
text
@.\"	$OpenBSD: getopt_long.3,v 1.20 2013/06/05 03:39:23 tedu Exp $
.\"	$NetBSD: getopt_long.3,v 1.11 2002/10/02 10:54:19 wiz Exp $
.\"
.\" Copyright (c) 1988, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @@(#)getopt.3	8.5 (Berkeley) 4/27/95
.\"
.Dd $Mdocdate: June 5 2013 $
.Dt GETOPT_LONG 3
.Os
.Sh NAME
.Nm getopt_long ,
.Nm getopt_long_only
.Nd get long options from command line argument list
.Sh SYNOPSIS
.In getopt.h
.Vt extern char *optarg;
.Vt extern int optind;
.Vt extern int optopt;
.Vt extern int opterr;
.Vt extern int optreset;
.Ft int
.Fn getopt_long "int argc" "char * const *argv" "const char *optstring" "const struct option *longopts" "int *longindex"
.Ft int
.Fn getopt_long_only "int argc" "char * const *argv" "const char *optstring" "const struct option *longopts" "int *longindex"
.Sh DESCRIPTION
The
.Fn getopt_long
function is similar to
.Xr getopt 3
but it accepts options in two forms: words and characters.
The
.Fn getopt_long
function provides a superset of the functionality of
.Xr getopt 3 .
.Fn getopt_long
can be used in two ways.
In the first way, every long option understood by the program has a
corresponding short option, and the option structure is only used to
translate from long options to short options.
When used in this fashion,
.Fn getopt_long
behaves identically to
.Xr getopt 3 .
This is a good way to add long option processing to an existing program
with the minimum of rewriting.
.Pp
In the second mechanism, a long option sets a flag in the
.Fa option
structure passed, or will store a pointer to the command line argument
in the
.Fa option
structure passed to it for options that take arguments.
Additionally, the long option's argument may be specified as a single
argument with an equal sign, e.g.
.Bd -literal -offset indent
$ myprogram --myoption=somevalue
.Ed
.Pp
When a long option is processed, the call to
.Fn getopt_long
will return 0.
For this reason, long option processing without
shortcuts is not backwards compatible with
.Xr getopt 3 .
.Pp
It is possible to combine these methods, providing for long options
processing with short option equivalents for some options.
Less frequently used options would be processed as long options only.
.Pp
Abbreviated long option names are accepted when
.Fn getopt_long
processes long options if the abbreviation is unique.
An exact match is always preferred for a defined long option.
.Pp
The
.Fn getopt_long
call requires an array to be initialized describing the long
options.
Each element of the array is a structure:
.Bd -literal -offset indent
struct option {
	char *name;
	int has_arg;
	int *flag;
	int val;
};
.Ed
.Pp
The
.Fa name
field should contain the option name without the leading double dash.
.Pp
The
.Fa has_arg
field should be one of:
.Pp
.Bl -tag -width "optional_argument" -compact -offset indent
.It Dv no_argument
no argument to the option is expected.
.It Dv required_argument
an argument to the option is required.
.It Dv optional_argument
an argument to the option may be presented.
.El
.Pp
If
.Fa flag
is not
.Dv NULL ,
then the integer pointed to by it will be set to the value in the
.Fa val
field.
If the
.Fa flag
field is
.Dv NULL ,
then the
.Fa val
field will be returned.
Setting
.Fa flag
to
.Dv NULL
and setting
.Fa val
to the corresponding short option will make this function act just
like
.Xr getopt 3 .
.Pp
If the
.Fa longindex
field is not
.Dv NULL ,
then the integer pointed to by it will be set to the index of the long
option relative to
.Fa longopts .
.Pp
The last element of the
.Fa longopts
array has to be filled with zeroes.
.Pp
The
.Fn getopt_long_only
function behaves identically to
.Fn getopt_long
with the exception that long options may start with
.Sq -
in addition to
.Sq -- .
If an option starting with
.Sq -
does not match a long option but does match a single-character option,
the single-character option is returned.
.Sh RETURN VALUES
If the
.Fa flag
field in
.Li struct option
is
.Dv NULL ,
.Fn getopt_long
and
.Fn getopt_long_only
return the value specified in the
.Fa val
field, which is usually just the corresponding short option.
If
.Fa flag
is not
.Dv NULL ,
these functions return 0 and store
.Fa val
in the location pointed to by
.Fa flag .
These functions return
.Sq \&:
if there was a missing option argument,
.Sq \&?
if the user specified an unknown or ambiguous option, and
\-1 when the argument list has been exhausted.
.Sh IMPLEMENTATION DIFFERENCES
This section describes differences to the GNU implementation
found in glibc-2.1.3:
.Bl -bullet
.It
handling of
.Ql -
within the option string (not the first character):
.Bl -tag -width "OpenBSD"
.It GNU
treats a
.Ql -
on the command line as a non-argument.
.It OpenBSD
a
.Ql -
within the option string matches a
.Ql -
(single dash) on the command line.
This functionality is provided for backward compatibility with
programs, such as
.Xr su 1 ,
that use
.Ql -
as an option flag.
This practice is wrong, and should not be used in any current development.
.El
.It
handling of
.Ql ::
in the option string in the presence of
.Ev POSIXLY_CORRECT :
.Bl -tag -width "OpenBSD"
.It Both
GNU and
.Ox
ignore
.Ev POSIXLY_CORRECT
here and take
.Ql ::
to mean the preceding option takes an optional argument.
.El
.It
return value in case of missing argument if first character
(after
.Ql +
or
.Ql - )
in the option string is not
.Ql \&: :
.Bl -tag -width "OpenBSD"
.It GNU
returns
.Ql \&?
.It OpenBSD
returns
.Ql \&:
(since
.Ox Ns 's
.Xr getopt 3
does).
.El
.It
handling of
.Ql --a
in
.Xr getopt 3 :
.Bl -tag -width "OpenBSD"
.It GNU
parses this as option
.Ql - ,
option
.Ql a .
.It OpenBSD
parses this as
.Ql -- ,
and returns \-1 (ignoring the
.Ql a )
(because the original
.Fn getopt
did.)
.El
.It
setting of
.Va optopt
for long options with
.Va flag
.No non- Ns Dv NULL :
.Bl -tag -width "OpenBSD"
.It GNU
sets
.Va optopt
to
.Va val .
.It OpenBSD
sets
.Va optopt
to 0 (since
.Va val
would never be returned).
.El
.It
handling of
.Ql -W
with
.Ql W;
in the option string in
.Xr getopt 3
(not
.Fn getopt_long ) :
.Bl -tag -width "OpenBSD"
.It GNU
causes a segmentation fault.
.It OpenBSD
no special handling is done;
.Ql W;
is interpreted as two separate options, neither of which take an argument.
.El
.It
setting of
.Va optarg
for long options without an argument that are invoked via
.Ql -W
(with
.Ql W;
in the option string):
.Bl -tag -width "OpenBSD"
.It GNU
sets
.Va optarg
to the option name (the argument of
.Ql -W ) .
.It OpenBSD
sets
.Va optarg
to
.Dv NULL
(the argument of the long option).
.El
.It
handling of
.Ql -W
with an argument that is not (a prefix to) a known long option
(with
.Ql W;
in the option string):
.Bl -tag -width "OpenBSD"
.It GNU
returns
.Ql -W
with
.Va optarg
set to the unknown option.
.It OpenBSD
treats this as an error (unknown option) and returns
.Ql \&?
with
.Va optopt
set to 0 and
.Va optarg
set to
.Dv NULL
(as GNU's man page documents).
.El
.It
The error messages are different.
.It
.Ox
does not permute the argument vector at the same points in
the calling sequence as GNU does.
The aspects normally used by the caller
(ordering after \-1 is returned, value of
.Va optind
relative to current positions) are the same, though.
(We do fewer variable swaps.)
.El
.Sh ENVIRONMENT
.Bl -tag -width Ev
.It Ev POSIXLY_CORRECT
If set, option processing stops when the first non-option is found and
a leading
.Sq +
in the
.Ar optstring
is ignored.
.El
.Sh EXAMPLES
.Bd -literal
int bflag, ch, fd;
int daggerset;

/* options descriptor */
static struct option longopts[] = {
	{ "buffy",	no_argument,		NULL, 		'b' },
	{ "fluoride",	required_argument,	NULL, 	       	'f' },
	{ "daggerset",	no_argument,		&daggerset,	1 },
	{ NULL, 	0,			NULL, 		0 }
};

bflag = 0;
while ((ch = getopt_long(argc, argv, "bf:", longopts, NULL)) != -1)
	switch (ch) {
	case 'b':
		bflag = 1;
		break;
	case 'f':
		if ((fd = open(optarg, O_RDONLY, 0)) == -1)
			err(1, "unable to open %s", optarg);
		break;
	case 0:
		if (daggerset)
			fprintf(stderr, "Buffy will use her dagger to "
			    "apply fluoride to dracula's teeth\en");
		break;
	default:
		usage();
	}
argc -= optind;
argv += optind;
.Ed
.Sh SEE ALSO
.Xr getopt 3
.Sh HISTORY
The
.Fn getopt_long
and
.Fn getopt_long_only
functions first appeared in GNU libiberty.
This implementation first appeared in
.Ox 3.3 .
.Sh BUGS
The
.Ar argv
argument is not really
.Dv const
as its elements may be permuted (unless
.Ev POSIXLY_CORRECT
is set).
@


1.20
log
@Use the fancy .In macro for includes. From Jan Klemkow. ok jmc schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.19 2011/03/21 13:41:50 espie Exp $
d33 1
a33 1
.Dd $Mdocdate: March 21 2011 $
a422 1
		/* NOTREACHED */
@


1.19
log
@tweak for clarity, ok millert@@, jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.18 2011/03/05 22:10:11 guenther Exp $
d33 1
a33 1
.Dd $Mdocdate: March 5 2011 $
d41 1
a41 1
.Fd #include <getopt.h>
@


1.18
log
@Fix PR 6267: recheck POSIXLY_CORRECT each time getopt_long() starts a new
argv and don't suppress the handling of leading '-' in optstring when
POSIXLY_CORRECT is set.

Based on patch from Eric Blake.
ok and manpage update from millert@@, manpage ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.17 2011/01/24 01:50:25 schwarze Exp $
d33 1
a33 1
.Dd $Mdocdate: January 24 2011 $
d103 1
a103 1
call requires a structure to be initialized describing the long
d105 1
a105 1
The structure is:
@


1.17
log
@Correctly escape a literal colon in an enclosure;
the \: roff escape is an optional line break.
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.16 2010/09/19 22:22:13 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: September 19 2010 $
a213 17
as the first character of the option string in the presence of the
environment variable
.Ev POSIXLY_CORRECT :
.Bl -tag -width "OpenBSD"
.It GNU
ignores
.Ev POSIXLY_CORRECT
and returns non-options as arguments to option
.Ql \e1 .
.It OpenBSD
honors
.Ev POSIXLY_CORRECT
and stops at the first non-option.
.El
.It
handling of
.Ql -
a387 2
.Sq -
or
@


1.16
log
@more wacky macro fixing;
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.15 2007/07/03 12:06:07 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: July 3 2007 $
d202 1
a202 1
.Sq \:
@


1.15
log
@from ginsbach@@netbsd, -r1.18:
Document that getopt_long(3) can and will accept unique abbreviated long
option names.  This feature has been present since getopt_long(3) was first
released in NetBSD 1.5.  This is also standard GNU getopt_long(3) behavior.

ok millert
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.14 2007/05/31 19:19:31 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate$
a206 35
.Sh EXAMPLES
.Bd -literal
int bflag, ch, fd;
int daggerset;

/* options descriptor */
static struct option longopts[] = {
	{ "buffy",	no_argument,		NULL, 		'b' },
	{ "fluoride",	required_argument,	NULL, 	       	'f' },
	{ "daggerset",	no_argument,		&daggerset,	1 },
	{ NULL, 	0,			NULL, 		0 }
};

bflag = 0;
while ((ch = getopt_long(argc, argv, "bf:", longopts, NULL)) != -1)
	switch (ch) {
	case 'b':
		bflag = 1;
		break;
	case 'f':
		if ((fd = open(optarg, O_RDONLY, 0)) == -1)
			err(1, "unable to open %s", optarg);
		break;
	case 0:
		if (daggerset)
			fprintf(stderr, "Buffy will use her dagger to "
			    "apply fluoride to dracula's teeth\en");
		break;
	default:
		usage();
		/* NOTREACHED */
	}
argc -= optind;
argv += optind;
.Ed
d412 35
@


1.14
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.13 2007/02/06 20:07:15 jmc Exp $
d95 5
@


1.13
log
@fix some dodgy displays;
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.12 2005/10/11 01:23:41 jaredy Exp $
d33 1
a33 1
.Dd April 1, 2000
@


1.12
log
@tidy up examples
- use err() for error handling
- add lint hints
- spacing nits and missing braces

ok otto
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.11 2005/07/26 04:17:44 jaredy Exp $
d203 1
a203 1
.Bd -literal -compact
@


1.11
log
@- typos, grammar, punctuation, layout tweaks
- use `$' for command prompts
- clean up: use a bullet list instead of adding junk to denote list
  items

ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.10 2004/01/06 23:44:28 fgsch Exp $
d226 2
a227 2
		if (daggerset) {
			fprintf(stderr,"Buffy will use her dagger to "
a228 1
		}
d232 2
a233 1
}
@


1.10
log
@- Rename index to longindex and explain its use.
- Talk about zeroing the last element of the longopts array.
- Remove '?' from the switch and some KNF to the code.
- Change 0's to NULL where appropriate.

jmc@@ ok.
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.9 2003/09/02 18:24:21 jmc Exp $
d81 2
a82 2
.Bd -literal
myprogram --myoption=somevalue
d85 1
a85 1
When a long option is processed the call to
d101 1
a101 1
.Bd -literal
d117 5
a121 4
.Bl -tag -width "optional_argument"
.It Li no_argument
no argument to the option is expect.
.It Li required_argument
d123 1
a123 1
.It Li optional_argument
d240 7
a246 4
.Bl -tag -width "xxx"
.It Li o
handling of - as first char of option string in presence of
environment variable POSIXLY_CORRECT:
d248 9
a256 5
.It Li GNU
ignores POSIXLY_CORRECT and returns non-options as
arguments to option '\e1'.
.It Li OpenBSD
honors POSIXLY_CORRECT and stops at the first non-option.
d258 4
a261 2
.It Li o
handling of - within the option string (not the first character):
d263 1
a263 1
.It Li GNU
d267 1
a267 1
.It Li OpenBSD
d281 5
a285 2
.It Li o
handling of :: in options string in presence of POSIXLY_CORRECT:
d287 8
a294 3
.It Li Both
GNU and OpenBSD ignore POSIXLY_CORRECT here and take :: to
mean the preceding option takes an optional argument.
d296 1
a296 1
.It Li o
d298 6
a303 1
(after + or -) in option string is not ':':
d305 3
a307 2
.It Li GNU
returns '?'
d309 6
a314 1
returns ':' (since OpenBSD's getopt does).
d316 5
a320 2
.It Li o
handling of --a in getopt:
d322 20
a341 9
.It Li GNU
parses this as option '-', option 'a'.
.It Li OpenBSD
parses this as '--', and returns \-1 (ignoring the a).
(Because the original getopt does.)
.El
.It Li o
setting of optopt for long options with flag !=
.Dv NULL :
d343 21
a363 7
.It Li GNU
sets optopt to val.
.It Li OpenBSD
sets optopt to 0 (since val would never be returned).
.El
.It Li o
handling of -W with W; in option string in getopt (not getopt_long):
d365 3
a367 3
.It Li GNU
causes a segfault.
.It Li OpenBSD
d369 1
a369 1
.Dq W;
d372 8
a379 3
.It Li o
setting of optarg for long options without an argument that are
invoked via -W (W; in option string):
d381 9
a389 4
.It Li GNU
sets optarg to the option name (the argument of -W).
.It Li OpenBSD
sets optarg to
d393 7
a399 3
.It Li o
handling of -W with an argument that is not (a prefix to) a known
long option (W; in option string):
d401 14
a414 5
.It Li GNU
returns -W with optarg set to the unknown option.
.It Li OpenBSD
treats this as an error (unknown option) and returns '?' with
optopt set to 0 and optarg set to
d418 1
a418 1
.It Li o
d420 3
a422 2
.It Li o
OpenBSD does not permute the argument vector at the same points in
d425 3
a427 2
(ordering after \-1 is returned, value of optind relative
to current positions) are the same, though.
d431 1
a431 1
.Bl -tag -width POSIXLY_CORRECT
@


1.9
log
@escape punctuation;
ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.8 2003/06/02 20:18:37 millert Exp $
d48 1
a48 1
.Fn getopt_long "int argc" "char * const *argv" "const char *optstring" "const struct option *longopts" "int *index"
d50 1
a50 1
.Fn getopt_long_only "int argc" "char * const *argv" "const char *optstring" "const struct option *longopts" "int *index"
d150 12
d208 2
a209 2
	{ "buffy",	no_argument,		0, 		'b' },
	{ "fluoride",	required_argument,	0, 	       	'f' },
d211 1
a211 1
	{ 0, 		0,			0, 		0 }
d216 1
a216 1
	switch(ch) {
d227 1
a227 1
				       "apply fluoride to dracula's teeth\en");
a229 1
	case '?':
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.7 2003/06/02 03:49:39 millert Exp $
d186 1
a186 1
.Sq ?
@


1.7
log
@Remove some lies
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.6 2003/05/10 06:48:30 jmc Exp $
d15 1
a15 5
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@typos;
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.5 2003/02/24 03:09:07 deraadt Exp $
a370 3
.Pp
In a future release, this implementation should completely replace
.Xr getopt 3 .
@


1.5
log
@of of
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.4 2002/12/10 21:51:38 millert Exp $
d47 4
a50 4
.Vt extern int   optind;
.Vt extern int   optopt;
.Vt extern int   opterr;
.Vt extern int   optreset;
d244 1
a244 1
handling of - within the option string (not the first character).
d286 2
a287 2
parses this as '--', and returns -1 (ignoring the a).  (Because
the original getopt does.)
@


1.4
log
@Document BSD behavior of accepting '-' within optstring as long as
it is not the fist character of optstring (since that would conflict
with GNU semantics).

Update the bit on "W;" within optstring when called as getopt (not
getopt_long) to current reality.
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.3 2002/12/05 21:02:19 millert Exp $
d63 1
a63 1
function provides a superset of of the functionality of
@


1.3
log
@make getopt_long and getopt_long_only protos match getopt.h
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.2 2002/12/04 21:42:22 millert Exp $
d244 21
d304 3
a306 4
returns \-1, with optind pointing past the argument of -W
(as if `-W arg' were `--arg', and thus '--' had been found).
.\" How should we treat W; in the option string when called via
.\" getopt?  Ignore the ';' or treat it as a ':'? Issue a warning?
@


1.2
log
@Add "RETURN VALUES" sections
@
text
@d1 1
a1 1
.\"	$OpenBSD: getopt_long.3,v 1.1 2002/12/03 20:24:30 millert Exp $
d52 1
a52 1
.Fn getopt_long "int argc" "char * const *argv" "const char *optstring" "struct option *long options" "int *index"
d54 1
a54 1
.Fn getopt_long_only "int argc" "char * const *argv" "const char *optstring" "struct option *long options" "int *index"
@


1.1
log
@GNU-like getopt_long() from NetBSD with changes by me to support
getopt_long_only().  At some point this should replace the BSD
getopt(3) but we are not there yet.

While I am here add protection from the multiple getopt() definitions
due to conflicting standards.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d166 27
@

