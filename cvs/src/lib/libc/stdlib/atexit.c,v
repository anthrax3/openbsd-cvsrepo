head	1.24;
access;
symbols
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.14
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.12
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.8
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.10
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.12.0.8
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.11.10.04.14.03;	author guenther;	state Exp;
branches;
next	1.23;
commitid	SlaqG0vnitmMjAjz;

1.23
date	2015.10.25.18.03.17;	author guenther;	state Exp;
branches;
next	1.22;
commitid	fJGaTiQAM4lxdg3P;

1.22
date	2015.10.25.18.01.24;	author guenther;	state Exp;
branches;
next	1.21;
commitid	psI2iCtxmQHDheCH;

1.21
date	2015.04.07.01.27.07;	author guenther;	state Exp;
branches;
next	1.20;
commitid	oQvh7XA3Kql35r0J;

1.20
date	2014.07.11.09.51.37;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	xGmDudHAQ8rZ9cWP;

1.19
date	2014.07.10.21.14.22;	author tedu;	state Exp;
branches;
next	1.18;
commitid	Zq34iacGn4A1pW0G;

1.18
date	2014.06.18.19.01.10;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	mzNWHuut8FFaBZJD;

1.17
date	2013.12.28.18.38.42;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.02.21.08.36;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.02.18.34.05;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.05.20.47.47;	author chl;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.03.14.40.16;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.22.07.16.32;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.26.18.55.26;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.08.08.05.36;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.17.21.38.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.30.18.51.49;	author pat;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.14.22.03.14;	author dhartmei;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.06.22.48.34;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.30.07.58.07;	author dhartmei;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.31.18.13.16;	author dhartmei;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.29.19.54.42;	author dhartmei;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.33.22;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.16;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@libc.so can't be unloaded, so move the hidden atexit() and pthread_atfork()
stubs for the executable from crtbegin.o into libc, which lets them be
excluded from static links that don't use them.
For this, drop the normal crt{begin,end}S.o from libc.so: the .init and .fini
sections for libc aren't called at the right times anyway, so it's good that
they're unused.  libc.so just needs __guard_local and the .note.openbsd.ident
section, so add them to stack_protector.c for now (this will be improved)

"good time" deraadt@@
@
text
@/*	$OpenBSD: atexit.c,v 1.23 2015/10/25 18:03:17 guenther Exp $ */
/*
 * Copyright (c) 2002 Daniel Hartmeier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "atexit.h"
#include "atfork.h"
#include "thread_private.h"

struct atexit *__atexit;
static int restartloop;

/* define and initialize the list */
struct atfork_listhead _atfork_list = TAILQ_HEAD_INITIALIZER(_atfork_list);


/*
 * Function pointers are stored in a linked list of pages. The list
 * is initially empty, and pages are allocated on demand. The first
 * function pointer in the first allocated page (the last one in
 * the linked list) is reserved for the cleanup function.
 *
 * Outside the following functions, all pages are mprotect()'ed
 * to prevent unintentional/malicious corruption.
 */

/*
 * Register a function to be performed at exit or when a shared object
 * with the given dso handle is unloaded dynamically.  Also used as
 * the backend for atexit().  For more info on this API, see:
 *
 *	http://www.codesourcery.com/cxx-abi/abi.html#dso-dtor
 */
int
__cxa_atexit(void (*func)(void *), void *arg, void *dso)
{
	struct atexit *p = __atexit;
	struct atexit_fn *fnp;
	int pgsize = getpagesize();
	int ret = -1;

	if (pgsize < sizeof(*p))
		return (-1);
	_ATEXIT_LOCK();
	p = __atexit;
	if (p != NULL) {
		if (p->ind + 1 >= p->max)
			p = NULL;
		else if (mprotect(p, pgsize, PROT_READ | PROT_WRITE))
			goto unlock;
	}
	if (p == NULL) {
		p = mmap(NULL, pgsize, PROT_READ | PROT_WRITE,
		    MAP_ANON | MAP_PRIVATE, -1, 0);
		if (p == MAP_FAILED)
			goto unlock;
		if (__atexit == NULL) {
			memset(&p->fns[0], 0, sizeof(p->fns[0]));
			p->ind = 1;
		} else
			p->ind = 0;
		p->max = (pgsize - ((char *)&p->fns[0] - (char *)p)) /
		    sizeof(p->fns[0]);
		p->next = __atexit;
		__atexit = p;
	}
	fnp = &p->fns[p->ind++];
	fnp->fn_ptr = func;
	fnp->fn_arg = arg;
	fnp->fn_dso = dso;
	if (mprotect(p, pgsize, PROT_READ))
		goto unlock;
	restartloop = 1;
	ret = 0;
unlock:
	_ATEXIT_UNLOCK();
	return (ret);
}
DEF_STRONG(__cxa_atexit);

/*
 * Copy of atexit() used by libc and anything staticly linked into the
 * executable.  This passes NULL for the dso, so the callbacks are only
 * invoked by exit() and not dlclose()
 */
int
atexit(void (*fn)(void))
{
	return (__cxa_atexit((void (*)(void *))fn, NULL, NULL));
}
DEF_STRONG(atexit);

/*
 * Call all handlers registered with __cxa_atexit() for the shared
 * object owning 'dso'.
 * Note: if 'dso' is NULL, then all remaining handlers are called.
 */
void
__cxa_finalize(void *dso)
{
	struct atexit *p, *q;
	struct atexit_fn fn;
	int n, pgsize = getpagesize();
	static int call_depth;

	_ATEXIT_LOCK();
	call_depth++;

restart:
	restartloop = 0;
	for (p = __atexit; p != NULL; p = p->next) {
		for (n = p->ind; --n >= 0;) {
			if (p->fns[n].fn_ptr == NULL)
				continue;	/* already called */
			if (dso != NULL && dso != p->fns[n].fn_dso)
				continue;	/* wrong DSO */

			/*
			 * Mark handler as having been already called to avoid
			 * dupes and loops, then call the appropriate function.
			 */
			fn = p->fns[n];
			if (mprotect(p, pgsize, PROT_READ | PROT_WRITE) == 0) {
				p->fns[n].fn_ptr = NULL;
				mprotect(p, pgsize, PROT_READ);
			}
			_ATEXIT_UNLOCK();
			(*fn.fn_ptr)(fn.fn_arg);
			_ATEXIT_LOCK();
			if (restartloop)
				goto restart;
		}
	}

	call_depth--;

	/*
	 * If called via exit(), unmap the pages since we have now run
	 * all the handlers.  We defer this until calldepth == 0 so that
	 * we don't unmap things prematurely if called recursively.
	 */
	if (dso == NULL && call_depth == 0) {
		for (p = __atexit; p != NULL; ) {
			q = p;
			p = p->next;
			munmap(q, pgsize);
		}
		__atexit = NULL;
	}
	_ATEXIT_UNLOCK();

	/*
	 * If unloading a DSO, unregister any atfork handlers registered
	 * by it.  Skip the locking if the list is currently empty.
	 */
	if (dso != NULL && TAILQ_FIRST(&_atfork_list) != NULL) {
		struct atfork_fn *af, *afnext;

		_ATFORK_LOCK();
		TAILQ_FOREACH_SAFE(af, &_atfork_list, fn_next, afnext)
			if (af->fn_dso == dso) {
				TAILQ_REMOVE(&_atfork_list, af, fn_next);
				free(af);
			}
		_ATFORK_UNLOCK();

	}
}
DEF_STRONG(__cxa_finalize);

/*
 * Register the cleanup function
 */
void
__atexit_register_cleanup(void (*func)(void))
{
	struct atexit *p;
	int pgsize = getpagesize();

	if (pgsize < sizeof(*p))
		return;
	_ATEXIT_LOCK();
	p = __atexit;
	while (p != NULL && p->next != NULL)
		p = p->next;
	if (p == NULL) {
		p = mmap(NULL, pgsize, PROT_READ | PROT_WRITE,
		    MAP_ANON | MAP_PRIVATE, -1, 0);
		if (p == MAP_FAILED)
			goto unlock;
		p->ind = 1;
		p->max = (pgsize - ((char *)&p->fns[0] - (char *)p)) /
		    sizeof(p->fns[0]);
		p->next = NULL;
		__atexit = p;
	} else {
		if (mprotect(p, pgsize, PROT_READ | PROT_WRITE))
			goto unlock;
	}
	p->fns[0].fn_ptr = (void (*)(void *))func;
	p->fns[0].fn_arg = NULL;
	p->fns[0].fn_dso = NULL;
	mprotect(p, pgsize, PROT_READ);
	restartloop = 1;
unlock:
	_ATEXIT_UNLOCK();
}
@


1.23
log
@Move the _atfork_list definition to atexit.c so that the fork syscall stub
doesn't get pulled into all static executables

ok millert@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.22 2015/10/25 18:01:24 guenther Exp $ */
d111 12
@


1.22
log
@Hide __atexit and __atexit_register_cleanup()
Wrap __cxa_{atexit,finalize}() so the call from exit() goes direct
Switch regress/lib/libc/atexit/ to be built with -static so that it can
  still access __atexit*

ok millert@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.21 2015/04/07 01:27:07 guenther Exp $ */
d43 4
@


1.21
log
@Make pthread_atfork() track the DSO that called it like atexit() does,
unregistering callbacks if the DSO is unloaded.  Move the callback
handling from libpthread to libc, though libpthread still overrides the
inner call to handle locking and thread-library reinitialization.
Major version bump for both libc and libpthread.

verification that this fixes various ports ajacoutot@@
asm assistance miod@@; ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.20 2014/07/11 09:51:37 kettenis Exp $ */
d106 1
d184 1
@


1.20
log
@Add locking for __cxa_finalize() as it modifies the page permissions of the
__atexit tables and touches global variables.  From Srinavasa Nagaraju
through Android/Elliott Hughes.

ok tedu@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.19 2014/07/10 21:14:22 tedu Exp $ */
d38 1
d165 17
@


1.19
log
@as noted by google/android via kettenis, atexit handlers can install new
handlers. if this happens, restart the loop.
ok kettenis matthew millert miod
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.18 2014/06/18 19:01:10 kettenis Exp $ */
d119 1
d140 1
d142 1
d163 1
@


1.18
log
@Always call atexit handlers as if they were registered with __cxa_atexit.
The extra argument doesn't hurt genuine atexit handlers and this fixes a
bug where we didn't provide the argument (effectively passing garbage) for
functions registered with __cxa_atexit in the main executable.

Pointed out by Dmitriy Ivanov <dimitry@@google.com> and Elliott Hughes
<enh@@google.com>.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.17 2013/12/28 18:38:42 kettenis Exp $ */
d41 1
d99 1
d121 2
d140 2
d195 1
@


1.17
log
@Move atexit(3) into crtbegin.c and certbeginS.c such that we can pass the
right __dso_handle and have dlopen'ed shared objects run their atexit handlers
when they get unloaded.  This is what Linux does, and several ports depend on
this behaviour (and will crash upon exit without this chang).

Based on an earlier diff from matthew@@
Tested by ajacoutot@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.16 2013/06/02 21:08:36 matthew Exp $ */
d93 1
a93 1
	fnp->fn_ptr.cxa_func = func;
d121 1
a121 1
			if (p->fns[n].fn_ptr.cxa_func == NULL)
d132 1
a132 1
				p->fns[n].fn_ptr.cxa_func = NULL;
d135 1
a135 4
			if (fn.fn_dso != NULL)
				(*fn.fn_ptr.cxa_func)(fn.fn_arg);
			else
				(*fn.fn_ptr.std_func)();
d185 1
a185 1
	p->fns[0].fn_ptr.std_func = func;
@


1.16
log
@Two small cleanups to atexit: remove unneeded __atexit_invalid, and
move the call_depth decrement so it happens unconditionally and can
still return to 0 when called with dso!=NULL.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.15 2011/03/02 18:34:05 matthew Exp $ */
a101 9
}

/*
 * Register a function to be performed at exit.
 */
int
atexit(void (*func)(void))
{
	return (__cxa_atexit((void (*)(void *))func, NULL, NULL));
@


1.15
log
@Fix __cxa_finalize() so that calling __cxa_finalize(NULL) properly
invokes handlers registered with __cxa_atexit().

"seems right" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.14 2007/09/05 20:47:47 chl Exp $ */
a39 1
int __atexit_invalid = 1;
a90 2
		if (__atexit_invalid)
			__atexit_invalid = 0;
a125 3
	if (__atexit_invalid)
		return;

d151 2
d158 1
a158 1
	if (dso == NULL && --call_depth == 0) {
a192 2
		if (__atexit_invalid)
			__atexit_invalid = 0;
@


1.14
log
@Add missing header to avoid warning

ok millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.13 2007/09/03 14:40:16 millert Exp $ */
d150 1
a150 1
			if (dso != NULL)
@


1.13
log
@Add __cxa_atexit() support for gcc3.  This provides support for shared object destructors called at dlclose() time.  Inspired by similar changes in FreeBSD and NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.12 2006/02/22 07:16:32 otto Exp $ */
d35 1
@


1.12
log
@Avouid a race in atexit() handling by introducing a lock. Problem
originally reported by Gergely Kovacs; help from dhartmei@@;
ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.11 2005/10/26 18:55:26 otto Exp $ */
d48 1
a48 1
 * Outside the following two functions, all pages are mprotect()'ed
d53 5
a57 1
 * Register a function to be performed at exit.
d60 1
a60 1
atexit(void (*fn)(void))
d62 2
a63 1
	struct atexit *p;
d83 1
a83 1
			p->fns[0] = NULL;
d94 4
a97 1
	p->fns[p->ind++] = fn;
d107 65
d175 1
a175 1
__atexit_register_cleanup(void (*fn)(void))
d202 3
a204 1
	p->fns[0] = fn;
@


1.11
log
@Remove obsolete comment. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atexit.c,v 1.10 2005/08/08 08:05:36 espie Exp $ */
d37 1
d58 1
a58 1
	struct atexit *p = __atexit;
d60 1
d64 2
d70 1
a70 1
			return (-1);
d76 1
a76 1
			return (-1);
d91 5
a95 2
		return (-1);
	return (0);
d104 1
a104 1
	struct atexit *p = __atexit;
d109 2
d117 1
a117 1
			return;
d127 1
a127 1
		    return;
d131 2
@


1.10
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a48 4
 *
 * The free(malloc(1)) is a workaround causing malloc_init() to
 * ensure that malloc.c gets the first mmap() call for its sbrk()
 * games.
@


1.9
log
@no longer a need for the free(malloc(1)) hack, because the brk stuff
no longer needs initializing (we use mmap for malloc entirely now)
noticed by kjell, ok dhartmei, tested by me
@
text
@d1 1
a30 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: atexit.c,v 1.8 2005/03/30 18:51:49 pat Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.8
log
@ansi + de-register

ok otto deraadt
@
text
@d32 1
a32 1
static char *rcsid = "$OpenBSD: atexit.c,v 1.7 2002/09/14 22:03:14 dhartmei Exp $";
a75 4
		if (__atexit_invalid) {
			free(malloc(1));
			__atexit_invalid = 0;
		}
d89 2
a111 4
		if (__atexit_invalid) {
			free(malloc(1));
			__atexit_invalid = 0;
		}
d121 2
@


1.7
log
@Move __cleanup into mprotect'ed page to prevent unintentional modifications
similar to the atexit handlers. Idea and help deraadt@@, ok deraadt@@
@
text
@d32 1
a32 1
static char *rcsid = "$OpenBSD: atexit.c,v 1.6 2002/09/06 22:48:34 henning Exp $";
d62 1
a62 2
atexit(fn)
	void (*fn)();
d64 2
a65 2
	register struct atexit *p = __atexit;
	register int pgsize = getpagesize();
d104 1
a104 2
__atexit_register_cleanup(fn)
	void (*fn)();
d106 2
a107 2
	register struct atexit *p = __atexit;
	register int pgsize = getpagesize();
@


1.6
log
@missing include, ok theo
@
text
@d32 1
a32 1
static char *rcsid = "$OpenBSD: atexit.c,v 1.5 2002/08/30 07:58:07 dhartmei Exp $";
d45 14
a77 3
			/* malloc.c wants the first mmap() for sbrk()
			   games ('nice hack'), so enforce
			   malloc_init() with a dummy call.  */
d85 5
a89 1
		p->ind = 0;
d99 36
@


1.5
log
@re-enable function pointer table protection, this time make sure that
malloc.c gets the first mmap() call (since it depends on that, for its
sbrk(0) use). ok deraadt@@
@
text
@d32 1
a32 1
static char *rcsid = "$OpenBSD: atexit.c,v 1.3 2002/07/29 19:54:42 dhartmei Exp $";
d38 1
@


1.4
log
@Back it out, it breaks something in perl (seen with spamassassin), debug
first.
@
text
@d1 2
a2 2
/*-
 * Copyright (c) 1990 The Regents of the University of California.
a4 3
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
a7 12
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d9 20
a28 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d32 1
a32 1
static char *rcsid = "$OpenBSD: atexit.c,v 1.2 1996/08/19 08:33:22 tholo Exp $";
d35 2
d40 1
d50 2
a51 2
	static struct atexit __atexit0;	/* one guaranteed table */
	register struct atexit *p;
d53 19
a71 4
	if ((p = __atexit) == NULL)
		__atexit = p = &__atexit0;
	else if (p->ind >= ATEXIT_SIZE) {
		if ((p = malloc(sizeof(*p))) == NULL)
d74 2
d80 2
@


1.3
log
@Replace atexit handler. mprotect() the pages so an attempt to modify the
function pointers from the outside will segfault. Idea, hints and feedback
from deraadt. ok deraadt.
@
text
@d1 2
a2 2
/*
 * Copyright (c) 2002 Daniel Hartmeier
d5 3
d11 12
d24 11
a34 20
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
a40 2
#include <sys/types.h>
#include <sys/mman.h>
a43 1
int __atexit_invalid = 1;
d53 2
a54 2
	register struct atexit *p = __atexit;
	register int pgsize = getpagesize();
d56 4
a59 12
	if (pgsize < sizeof(*p))
		return (-1);
	if (p != NULL) {
		if (p->ind + 1 >= p->max)
			p = NULL;
		else if (mprotect(p, pgsize, PROT_READ | PROT_WRITE))
			return (-1);
	}
	if (p == NULL) {
		p = mmap(NULL, pgsize, PROT_READ | PROT_WRITE,
		    MAP_ANON | MAP_PRIVATE, -1, 0);
		if (p == MAP_FAILED)
a61 2
		p->max = (pgsize - ((char *)&p->fns[0] - (char *)p)) /
		    sizeof(p->fns[0]);
a63 2
		if (__atexit_invalid)
			__atexit_invalid = 0;
a65 2
	if (mprotect(p, pgsize, PROT_READ))
		return (-1);
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 2
a2 2
/*-
 * Copyright (c) 1990 The Regents of the University of California.
a4 3
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
a7 12
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d9 20
a28 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d32 1
a32 1
static char *rcsid = "$OpenBSD: atexit.c,v 1.1.1.1 1995/10/18 08:42:16 deraadt Exp $";
d35 2
d40 1
d50 2
a51 2
	static struct atexit __atexit0;	/* one guaranteed table */
	register struct atexit *p;
d53 12
a64 4
	if ((p = __atexit) == NULL)
		__atexit = p = &__atexit0;
	else if (p->ind >= ATEXIT_SIZE) {
		if ((p = malloc(sizeof(*p))) == NULL)
d67 2
d71 2
d75 2
@


1.1
log
@Initial revision
@
text
@d38 1
a38 2
/*static char *sccsid = "from: @@(#)atexit.c	5.2 (Berkeley) 11/14/90";*/
static char *rcsid = "$Id: atexit.c,v 1.5 1995/06/14 05:17:53 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
