head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.16.0.8
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.24
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.22
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.18
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.20
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.16
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.14
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.12
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.08.28.04.08.59;	author guenther;	state Exp;
branches;
next	1.20;
commitid	tBeW1Sm4FsZRKPgy;

1.20
date	2015.10.13.20.55.37;	author millert;	state Exp;
branches;
next	1.19;
commitid	X39sl5ay1czgFIgp;

1.19
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	0DYulI8hhujBHMcR;

1.18
date	2014.10.19.03.56.28;	author doug;	state Exp;
branches;
next	1.17;
commitid	U6QxmtbXrGoc02S5;

1.17
date	2014.10.18.20.43.52;	author doug;	state Exp;
branches;
next	1.16;
commitid	I74hI1tVZtsspKEt;

1.16
date	2013.04.05.12.59.54;	author kurt;	state Exp;
branches;
next	1.15;

1.15
date	2012.09.13.15.39.05;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.24.21.03.00;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.08.08.05.37;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.29.19.34.14;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.30.15.12.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.01.21.04.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.20.18.38;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.04.22.47.43;	author hin;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.24.21.22.37;	author deraadt;	state Exp;
branches
	1.7.2.1
	1.7.4.1;
next	1.6;

1.6
date	2002.01.12.16.24.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.27.00.58.56;	author lebel;	state Exp;
branches;
next	1.4;

1.4
date	98.05.18.09.55.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.06.20.20.37.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.33.47;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.19;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2003.08.03.02.29.29;	author brad;	state Exp;
branches;
next	;

1.7.4.1
date	2003.08.03.02.17.03;	author brad;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Don't call lstat() before readlink() just to see if it's a symlink,
as readlink() will tell you that more cheaply.

ok millert@@
@
text
@/*	$OpenBSD: realpath.c,v 1.20 2015/10/13 20:55:37 millert Exp $ */
/*
 * Copyright (c) 2003 Constantin S. Svintsoff <kostik@@iclub.nsu.ru>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The names of the authors may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

/* A slightly modified copy of this file exists in libexec/ld.so */

/*
 * char *realpath(const char *path, char resolved[PATH_MAX]);
 *
 * Find the real name of path, by removing all ".", ".." and symlink
 * components.  Returns (resolved) on success, or (NULL) on failure,
 * in which case the path which caused trouble is left in (resolved).
 */
char *
realpath(const char *path, char *resolved)
{
	char *p, *q, *s;
	size_t left_len, resolved_len;
	unsigned symlinks;
	int serrno, slen, mem_allocated;
	char left[PATH_MAX], next_token[PATH_MAX], symlink[PATH_MAX];

	if (path[0] == '\0') {
		errno = ENOENT;
		return (NULL);
	}

	serrno = errno;

	if (resolved == NULL) {
		resolved = malloc(PATH_MAX);
		if (resolved == NULL)
			return (NULL);
		mem_allocated = 1;
	} else
		mem_allocated = 0;

	symlinks = 0;
	if (path[0] == '/') {
		resolved[0] = '/';
		resolved[1] = '\0';
		if (path[1] == '\0')
			return (resolved);
		resolved_len = 1;
		left_len = strlcpy(left, path + 1, sizeof(left));
	} else {
		if (getcwd(resolved, PATH_MAX) == NULL) {
			if (mem_allocated)
				free(resolved);
			else
				strlcpy(resolved, ".", PATH_MAX);
			return (NULL);
		}
		resolved_len = strlen(resolved);
		left_len = strlcpy(left, path, sizeof(left));
	}
	if (left_len >= sizeof(left) || resolved_len >= PATH_MAX) {
		errno = ENAMETOOLONG;
		goto err;
	}

	/*
	 * Iterate over path components in `left'.
	 */
	while (left_len != 0) {
		/*
		 * Extract the next path component and adjust `left'
		 * and its length.
		 */
		p = strchr(left, '/');
		s = p ? p : left + left_len;
		if (s - left >= sizeof(next_token)) {
			errno = ENAMETOOLONG;
			goto err;
		}
		memcpy(next_token, left, s - left);
		next_token[s - left] = '\0';
		left_len -= s - left;
		if (p != NULL)
			memmove(left, s + 1, left_len + 1);
		if (resolved[resolved_len - 1] != '/') {
			if (resolved_len + 1 >= PATH_MAX) {
				errno = ENAMETOOLONG;
				goto err;
			}
			resolved[resolved_len++] = '/';
			resolved[resolved_len] = '\0';
		}
		if (next_token[0] == '\0')
			continue;
		else if (strcmp(next_token, ".") == 0)
			continue;
		else if (strcmp(next_token, "..") == 0) {
			/*
			 * Strip the last path component except when we have
			 * single "/"
			 */
			if (resolved_len > 1) {
				resolved[resolved_len - 1] = '\0';
				q = strrchr(resolved, '/') + 1;
				*q = '\0';
				resolved_len = q - resolved;
			}
			continue;
		}

		/*
		 * Append the next path component and lstat() it. If
		 * lstat() fails we still can return successfully if
		 * there are no more path components left.
		 */
		resolved_len = strlcat(resolved, next_token, PATH_MAX);
		if (resolved_len >= PATH_MAX) {
			errno = ENAMETOOLONG;
			goto err;
		}
		slen = readlink(resolved, symlink, sizeof(symlink) - 1);
		if (slen < 0) {
			switch (errno) {
			case EINVAL:
				/* not a symlink, continue to next component */
				continue;
			case ENOENT:
				if (p == NULL) {
					errno = serrno;
					return (resolved);
				}
				/* FALLTHROUGH */
			default:
				goto err;
			}
		} else {
			if (symlinks++ > SYMLOOP_MAX) {
				errno = ELOOP;
				goto err;
			}

			symlink[slen] = '\0';
			if (symlink[0] == '/') {
				resolved[1] = 0;
				resolved_len = 1;
			} else if (resolved_len > 1) {
				/* Strip the last path component. */
				resolved[resolved_len - 1] = '\0';
				q = strrchr(resolved, '/') + 1;
				*q = '\0';
				resolved_len = q - resolved;
			}

			/*
			 * If there are any path components left, then
			 * append them to symlink. The result is placed
			 * in `left'.
			 */
			if (p != NULL) {
				if (symlink[slen - 1] != '/') {
					if (slen + 1 >= sizeof(symlink)) {
						errno = ENAMETOOLONG;
						goto err;
					}
					symlink[slen] = '/';
					symlink[slen + 1] = 0;
				}
				left_len = strlcat(symlink, left, sizeof(symlink));
				if (left_len >= sizeof(symlink)) {
					errno = ENAMETOOLONG;
					goto err;
				}
			}
			left_len = strlcpy(left, symlink, sizeof(left));
		}
	}

	/*
	 * Remove trailing slash except when the resolved pathname
	 * is a single "/".
	 */
	if (resolved_len > 1 && resolved[resolved_len - 1] == '/')
		resolved[resolved_len - 1] = '\0';
	return (resolved);

err:
	if (mem_allocated)
		free(resolved);
	return (NULL);
}
@


1.20
log
@In rev 1.15 the sizeof argument was fixed in a strlcat() call but
the truncation check immediately following it was not updated to
match.  Not an issue in practice since the buffers are the same
size.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: realpath.c,v 1.19 2015/01/16 16:48:51 deraadt Exp $ */
a29 2
#include <sys/stat.h>

a47 1
	struct stat sb;
d148 14
a161 4
		if (lstat(resolved, &sb) != 0) {
			if (errno == ENOENT && p == NULL) {
				errno = serrno;
				return (resolved);
d163 1
a163 3
			goto err;
		}
		if (S_ISLNK(sb.st_mode)) {
d168 1
a168 3
			slen = readlink(resolved, symlink, sizeof(symlink) - 1);
			if (slen < 0)
				goto err;
@


1.19
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: realpath.c,v 1.18 2014/10/19 03:56:28 doug Exp $ */
d193 1
a193 1
				if (left_len >= sizeof(left)) {
@


1.18
log
@Revert last commit due to changed semantics found by make release.
@
text
@d1 1
a1 1
/*	$OpenBSD: realpath.c,v 1.16 2013/04/05 12:59:54 kurt Exp $ */
a29 1
#include <sys/param.h>
d36 1
d159 1
a159 1
			if (symlinks++ > MAXSYMLINKS) {
@


1.17
log
@Better POSIX compliance in realpath(3).

millert@@ made changes to realpath.c based on FreeBSD's version.  I merged
Todd's changes into dl_realpath.c.

ok millert@@, guenther@@
@
text
@a56 4
	if (path == NULL) {
		errno = EINVAL;
		return (NULL);
	}
d142 3
a144 1
		 * Append the next path component and lstat() it.
d151 5
a155 1
		if (lstat(resolved, &sb) != 0)
d157 1
a198 3
		} else if (!S_ISDIR(sb.st_mode) && p != NULL) {
			errno = ENOTDIR;
			goto err;
@


1.16
log
@- Add comments regarding copies of these files also in libexec/ld.so
okay guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: realpath.c,v 1.15 2012/09/13 15:39:05 deraadt Exp $ */
d57 4
d146 1
a146 3
		 * Append the next path component and lstat() it. If
		 * lstat() fails we still can return successfully if
		 * there are no more path components left.
d153 1
a153 5
		if (lstat(resolved, &sb) != 0) {
			if (errno == ENOENT && p == NULL) {
				errno = serrno;
				return (resolved);
			}
a154 1
		}
d196 3
@


1.15
log
@specify the bounds of the dst to strlcat (both values were static and
equal, but it is more correct)
from Michal Mazurek
@
text
@d1 1
a1 1
/*	$OpenBSD: realpath.c,v 1.14 2011/07/24 21:03:00 miod Exp $ */
d37 2
@


1.14
log
@Recent Single Unix will malloc memory if the second argument of realpath()
is NULL, and third-party software is starting to rely upon this.
Adapted from FreeBSD via Jona Joachim (jaj ; hcl-club , .lu), with minor
tweaks from nicm@@ and yours truly.
@
text
@d1 1
a1 1
/*	$OpenBSD: realpath.c,v 1.13 2005/08/08 08:05:37 espie Exp $ */
d190 1
a190 1
				left_len = strlcat(symlink, left, sizeof(left));
@


1.13
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d46 1
a46 1
realpath(const char *path, char resolved[PATH_MAX])
d52 1
a52 1
	int serrno, slen;
d55 5
d61 9
d80 4
a83 1
			strlcpy(resolved, ".", PATH_MAX);
d91 1
a91 1
		return (NULL);
d106 1
a106 1
			return (NULL);
d116 1
a116 1
				return (NULL);
d147 1
a147 1
			return (NULL);
d154 1
a154 1
			return (NULL);
d159 1
a159 1
				return (NULL);
d163 1
a163 1
				return (NULL);
d185 1
a185 1
						return (NULL);
d193 1
a193 1
					return (NULL);
d207 5
@


1.12
log
@Make realpath() thread-safe. New implementation does not use chdir(2) at all.

From: FreeBSD by Constantin S. Svintsoff <kostik (at) iclub.nsu.ru>

ok otto@@ millert@@
@
text
@d1 1
a28 9

#if 0
#include <sys/cdefs.h>
__FBSDID("$FreeBSD: /usr/local/www/cvsroot/FreeBSD/src/lib/libc/stdlib/realpath.c,v 1.9.2.1 2003/05/22 17:11:44 fjoe Exp $");
#endif

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: realpath.c,v 1.11 2004/11/30 15:12:59 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.11
log
@Check strlc{py,at} return value and return NULL upon truncation instead
of silently truncating.  OK deraadt@@ otto@@
@
text
@d2 1
a2 5
 * Copyright (c) 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Jan-Simon Pendry.
d12 3
a14 3
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d16 1
a16 1
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
d19 1
a19 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d29 5
d35 1
a35 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.10 2003/08/01 21:04:59 millert Exp $";
a41 1
#include <fcntl.h>
d47 1
a47 1
 * char *realpath(const char *path, char resolved_path[MAXPATHLEN]);
d54 1
a54 3
realpath(path, resolved)
	const char *path;
	char *resolved;
d57 10
a66 7
	int fd, n, needslash, serrno;
	char *p, *q, wbuf[MAXPATHLEN];
	int symlinks = 0;

	/* Save the starting point. */
	if ((fd = open(".", O_RDONLY)) < 0) {
		resolved[0] = '.';
d68 8
a75 53
		return (NULL);
	}

	/* Convert "." -> "" to optimize away a needless lstat() and chdir() */
	if (path[0] == '.' && path[1] == '\0')
		path = "";

	/*
	 * Find the dirname and basename from the path to be resolved.
	 * Change directory to the dirname component.
	 * lstat the basename part.
	 *     if it is a symlink, read in the value and loop.
	 *     if it is a directory, then change to that directory.
	 * get the current directory name and append the basename.
	 */
	if (strlcpy(resolved, path, MAXPATHLEN) >= MAXPATHLEN) {
		serrno = ENAMETOOLONG;
		goto err2;
	}
loop:
	q = strrchr(resolved, '/');
	if (q != NULL) {
		p = q + 1;
		if (q == resolved)
			q = "/";
		else {
			do {
				--q;
			} while (q > resolved && *q == '/');
			q[1] = '\0';
			q = resolved;
		}
		if (chdir(q) < 0)
			goto err1;
	} else
		p = resolved;

	/* Deal with the last component. */
	if (*p != '\0' && lstat(p, &sb) == 0) {
		if (S_ISLNK(sb.st_mode)) {
			if (++symlinks > MAXSYMLINKS) {
				errno = ELOOP;
				goto err1;
			}
			if ((n = readlink(p, resolved, MAXPATHLEN-1)) < 0)
				goto err1;
			resolved[n] = '\0';
			goto loop;
		}
		if (S_ISDIR(sb.st_mode)) {
			if (chdir(p) < 0)
				goto err1;
			p = "";
d77 2
d80 1
a80 6

	/*
	 * Save the last component name and get the full pathname of
	 * the current directory.
	 */
	if (strlcpy(wbuf, p, sizeof(wbuf)) >= sizeof(wbuf)) {
d82 1
a82 1
		goto err1;
a83 2
	if (getcwd(resolved, MAXPATHLEN) == NULL)
		goto err1;
d86 1
a86 2
	 * Join the two strings together, ensuring that the right thing
	 * happens if the last component is empty, or the dirname is root.
d88 8
a95 7
	if (resolved[0] == '/' && resolved[1] == '\0')
		needslash = 0;
	else
		needslash = 1;

	if (*wbuf) {
		if (strlen(resolved) + strlen(wbuf) + needslash >= MAXPATHLEN) {
d97 1
a97 1
			goto err1;
d99 7
a105 2
		if (needslash) {
			if (strlcat(resolved, "/", MAXPATHLEN) >= MAXPATHLEN) {
d107 19
a125 1
				goto err1;
d127 1
d129 8
a136 1
		if (strlcat(resolved, wbuf, MAXPATHLEN) >= MAXPATHLEN) {
d138 1
a138 1
			goto err1;
d140 26
a165 1
	}
d167 22
a188 4
	/* Go back to where we came from. */
	if (fchdir(fd) < 0) {
		serrno = errno;
		goto err2;
d191 6
a196 2
	/* It's okay if the close fails, what's an fd more or less? */
	(void)close(fd);
a197 6

err1:	serrno = errno;
	(void)fchdir(fd);
err2:	(void)close(fd);
	errno = serrno;
	return (NULL);
@


1.10
log
@Rename rootd to needslash and invert its value.  This fixes the check
for ENAMETOOLONG, though since we use strlcpy() and strlcat() this
is not a big deal.  Problem found by vincent@@
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.9 2003/06/02 20:18:38 millert Exp $";
d65 2
a66 1
		(void)strlcpy(resolved, ".", MAXPATHLEN);
d82 4
a85 1
	strlcpy(resolved, path, MAXPATHLEN);
d111 1
a111 2
			n = readlink(p, resolved, MAXPATHLEN-1);
			if (n < 0)
d127 5
a131 2
	(void)strlcpy(wbuf, p, sizeof wbuf);
	if (getcwd(resolved, MAXPATHLEN) == 0)
d148 10
a157 3
		if (needslash)
			strlcat(resolved, "/", MAXPATHLEN);
		strlcat(resolved, wbuf, MAXPATHLEN);
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.8 2003/04/04 22:47:43 hin Exp $";
d59 1
a59 1
	int fd, n, rootd, serrno;
d133 1
a133 1
		rootd = 1;
d135 1
a135 1
		rootd = 0;
d138 1
a138 1
		if (strlen(resolved) + strlen(wbuf) + rootd + 1 > MAXPATHLEN) {
d142 1
a142 1
		if (rootd == 0)
@


1.8
log
@strcat -> strlcat
ok deraadt@@ tedu@@ tdeval@@
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.7 2002/05/24 21:22:37 deraadt Exp $";
@


1.7
log
@try to use strlcpy and snprintf more; ok various
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.6 2002/01/12 16:24:35 millert Exp $";
d147 2
a148 2
			(void)strcat(resolved, "/");
		(void)strcat(resolved, wbuf);
@


1.7.2.1
log
@MFC:
Fix by millert@@

Rename rootd to needslash and invert its value.  This fixes the check
for ENAMETOOLONG, though since we use strlcpy() and strlcat() this
is not a big deal.  Problem found by vincent@@

ok deraadt@@
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.7 2002/05/24 21:22:37 deraadt Exp $";
d63 1
a63 1
	int fd, n, needslash, serrno;
d137 1
a137 1
		needslash = 0;
d139 1
a139 1
		needslash = 1;
d142 1
a142 1
		if (strlen(resolved) + strlen(wbuf) + needslash >= MAXPATHLEN) {
d146 3
a148 3
		if (needslash)
			(void)strlcat(resolved, "/", MAXPATHLEN);
		(void)strlcat(resolved, wbuf, MAXPATHLEN);
@


1.7.4.1
log
@MFC:
Fix by millert@@

Rename rootd to needslash and invert its value.  This fixes the check
for ENAMETOOLONG, though since we use strlcpy() and strlcat() this
is not a big deal.  Problem found by vincent@@

ok deraadt@@
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.7 2002/05/24 21:22:37 deraadt Exp $";
d63 1
a63 1
	int fd, n, needslash, serrno;
d137 1
a137 1
		needslash = 0;
d139 1
a139 1
		needslash = 1;
d142 1
a142 1
		if (strlen(resolved) + strlen(wbuf) + needslash >= MAXPATHLEN) {
d146 3
a148 3
		if (needslash)
			(void)strlcat(resolved, "/", MAXPATHLEN);
		(void)strlcat(resolved, wbuf, MAXPATHLEN);
@


1.6
log
@If the user passes in "" as the string to resolve the lstat() will
fail anyway so check for that.  Also convert "." to "" since that
way we avoid the lstat() (which we don't need) and the subsequent
chdir() and some dir checks.
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.5 2001/06/27 00:58:56 lebel Exp $";
d69 1
a69 1
		(void)strcpy(resolved, ".");
d128 1
a128 1
	(void)strcpy(wbuf, p);
@


1.5
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.4 1998/05/18 09:55:19 deraadt Exp $";
d73 4
d105 1
a105 1
	if (lstat(p, &sb) == 0) {
@


1.4
log
@readlink(path, buf, sizeof buf-1).  Never forget that -1.
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.3 1997/06/20 20:37:45 deraadt Exp $";
d81 1
a81 2
	(void)strncpy(resolved, path, MAXPATHLEN - 1);
	resolved[MAXPATHLEN - 1] = '\0';
@


1.3
log
@add ELOOP support; shigio@@wafu.netgate.net
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.2 1996/08/19 08:33:47 tholo Exp $";
d108 1
a108 1
			n = readlink(p, resolved, MAXPATHLEN);
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: realpath.c,v 1.1.1.1 1995/10/18 08:42:19 deraadt Exp $";
d65 1
d104 4
@


1.1
log
@Initial revision
@
text
@d38 1
a38 2
/*static char sccsid[] = "from: @@(#)realpath.c	8.1 (Berkeley) 2/16/94";*/
static char *rcsid = "$Id: realpath.c,v 1.1.1.1 1994/05/17 12:42:31 mycroft Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
