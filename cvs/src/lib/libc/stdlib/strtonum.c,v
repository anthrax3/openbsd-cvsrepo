head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.12
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.8
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.36
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.34
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.32
	OPENBSD_5_0:1.6.0.30
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.28
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.26
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.22
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.24
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.20
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.18
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.16
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.14
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.12
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.10
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.8
date	2015.09.13.08.31.48;	author guenther;	state Exp;
branches;
next	1.7;
commitid	QZ177IcjQzeRxHAC;

1.7
date	2013.04.17.18.40.58;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.03.19.38.01;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.16.18.36.05;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.16.16.03.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.21.23.12.25;	author marc;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.03.20.53.34;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.03.17.09.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Wrap <stdlib.h> so that calls go direct and the symbols not in the
C standard are all weak.
Apply __{BEGIN,END}_HIDDEN_DECLS to gdtoa{,imp}.h, hiding the
arch-specific __strtorx, __ULtox_D2A, __strtorQ, __ULtoQ_D2A symbols.
@
text
@/*	$OpenBSD: strtonum.c,v 1.7 2013/04/17 18:40:58 tedu Exp $	*/

/*
 * Copyright (c) 2004 Ted Unangst and Todd Miller
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <limits.h>
#include <stdlib.h>

#define	INVALID		1
#define	TOOSMALL	2
#define	TOOLARGE	3

long long
strtonum(const char *numstr, long long minval, long long maxval,
    const char **errstrp)
{
	long long ll = 0;
	int error = 0;
	char *ep;
	struct errval {
		const char *errstr;
		int err;
	} ev[4] = {
		{ NULL,		0 },
		{ "invalid",	EINVAL },
		{ "too small",	ERANGE },
		{ "too large",	ERANGE },
	};

	ev[0].err = errno;
	errno = 0;
	if (minval > maxval) {
		error = INVALID;
	} else {
		ll = strtoll(numstr, &ep, 10);
		if (numstr == ep || *ep != '\0')
			error = INVALID;
		else if ((ll == LLONG_MIN && errno == ERANGE) || ll < minval)
			error = TOOSMALL;
		else if ((ll == LLONG_MAX && errno == ERANGE) || ll > maxval)
			error = TOOLARGE;
	}
	if (errstrp != NULL)
		*errstrp = ev[error].errstr;
	errno = ev[error].err;
	if (error)
		ll = 0;

	return (ll);
}
DEF_WEAK(strtonum);
@


1.7
log
@the tiniest of style tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: strtonum.c,v 1.6 2004/08/03 19:38:01 millert Exp $	*/
d66 1
@


1.6
log
@It's not really possible to make strtonum() deal with unsigned long
long values properly so don't bother trying.  This greatly simplifies
the code.  tedu@@ OK with input from otto@@ and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: strtonum.c,v 1.5 2004/07/16 18:36:05 otto Exp $	*/
d24 3
a26 3
#define INVALID 	1
#define TOOSMALL 	2
#define TOOLARGE 	3
d33 1
a34 1
	int error = 0;
d47 1
a47 1
	if (minval > maxval)
d49 1
a49 1
	else {
@


1.5
log
@Do not forget to test the lower bound if the upper bound > LLONG_MAX.
ok millert@@
@
text
@d1 2
a2 1
/* $OpenBSD: strtonum.c,v 1.4 2004/07/16 16:03:36 millert Exp $ */
d28 2
a29 2
unsigned long long
strtonum(const char *numstr, long long minval, unsigned long long umaxval,
d32 1
a32 2
	long long ll, maxval = (long long)umaxval;
	unsigned long long ull = 0;
d47 3
a49 18
	if (umaxval > LLONG_MAX ) {
		if (minval < 0) {
			error = INVALID;
			goto done;
		}
		ull = strtoull(numstr, &ep, 10);
		if (numstr == ep || *ep != '\0')
			error = INVALID;
		else if ((ull == ULLONG_MAX && errno == ERANGE) ||
		    ull > umaxval)
			error = TOOLARGE;
		else if (ull < minval)
			error = TOOSMALL;
	} else {
		if (minval > maxval || maxval < minval) {
			error = INVALID;
			goto done;
		}
a56 1
		ull = (unsigned long long)ll;
a57 1
done:
d62 1
a62 1
		ull = 0;
d64 1
a64 1
	return (ull);
@


1.4
log
@Avoid comparing unsigned and signed long longs since the signed
one will get implicitly cast to unsigned.  Fixes a bug with negative
minval noticed by mjc@@.  Similar to a diff from miod@@.  OK miod@@.
@
text
@d1 1
a1 1
/* $OpenBSD: strtonum.c,v 1.3 2004/06/21 23:12:25 marc Exp $ */
d58 2
@


1.3
log
@errno -> err in a structure.  OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: strtonum.c,v 1.2 2004/05/03 20:53:34 millert Exp $ */
d28 1
a28 1
strtonum(const char *numstr, long long minval, unsigned long long maxval,
d31 2
a32 1
	unsigned long long ull;
d34 1
a34 1
	int error;
d47 5
a51 6
	error = 0;
	ull = 0;
	if (minval > maxval || maxval < minval ||
	    (minval < 0 && maxval > LLONG_MAX))
		error = INVALID;
	else if (maxval > LLONG_MAX ) {
d55 2
a56 1
		else if ((ull == ULLONG_MAX && errno == ERANGE) || ull > maxval)
d59 5
a63 1
		long long ll = strtoll(numstr, &ep, 10);
d72 1
@


1.2
log
@Be smarter about signed vs. unsigned (produces better error messages).
OK otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: strtonum.c,v 1.1 2004/05/03 17:09:24 tedu Exp $ */
d36 1
a36 1
		int errno;
d44 1
a44 1
	ev[0].errno = errno;
d69 1
a69 1
	errno = ev[error].errno;
@


1.1
log
@strtonum, a nicer version of strtoll, by millert and myself.
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d51 1
a51 1
	else if (minval >= 0) {
@

