head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.6
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.8
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.26.0.12
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.4
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.8
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.8
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.8
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11;
locks; strict;
comment	@ * @;


1.29
date	2015.10.01.02.32.07;	author guenther;	state Exp;
branches;
next	1.28;
commitid	DA03ltgCTpoknko0;

1.28
date	2015.09.19.04.02.21;	author guenther;	state Exp;
branches;
next	1.27;
commitid	xONsWdI5wUyoKz4N;

1.27
date	2015.09.12.14.48.14;	author guenther;	state Exp;
branches;
next	1.26;
commitid	OV2EPnrDmkHwdaE3;

1.26
date	2013.06.08.22.47.56;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.05.22.10.11;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.22.19.31.53;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.31.12.34.57;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.04.21.29.04;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.22.17.22.05;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.25.15.49.37;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.08.08.05.36;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.30.18.51.49;	author pat;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.03.18.46.52;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.04.18.17.25;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.22.23.45.22;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.17.21.56.24;	author millert;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2003.06.03.01.52.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.03.46.43;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.10.17.51.42;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.08.17.52.26;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.08.17.07.46;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.08.07.23.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.07.19.48.32;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.07.19.15.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.06.16.03.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.05.22.26.04;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.05.21.45.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.03.20.28.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.03.20.24.30;	author millert;	state Exp;
branches;
next	;

1.14.2.1
date	2004.02.13.07.14.52;	author brad;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Eliminate the last of the LINTEDn and PRINTFLIKEn comments.  In one
case, by deleting some useless '& of an array' we also eliminate the need
for the casts which prompted the original lint warnings

ok deraadt@@
@
text
@/*	$OpenBSD: getopt_long.c,v 1.28 2015/09/19 04:02:21 guenther Exp $	*/
/*	$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $	*/

/*
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */
/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Dieter Baron and Thomas Klausner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <err.h>
#include <errno.h>
#include <getopt.h>
#include <stdlib.h>
#include <string.h>

int	opterr = 1;		/* if error message should be printed */
int	optind = 1;		/* index into parent argv vector */
int	optopt = '?';		/* character checked for validity */
int	optreset;		/* reset getopt */
char    *optarg;		/* argument associated with option */

#if 0
/* DEF_* only work on initialized (non-COMMON) variables */
DEF_WEAK(opterr);
DEF_WEAK(optind);
DEF_WEAK(optopt);
#endif

#define PRINT_ERROR	((opterr) && (*options != ':'))

#define FLAG_PERMUTE	0x01	/* permute non-options to the end of argv */
#define FLAG_ALLARGS	0x02	/* treat non-options as args to option "-1" */
#define FLAG_LONGONLY	0x04	/* operate as getopt_long_only */

/* return values */
#define	BADCH		(int)'?'
#define	BADARG		((*options == ':') ? (int)':' : (int)'?')
#define	INORDER 	(int)1

#define	EMSG		""

static int getopt_internal(int, char * const *, const char *,
			   const struct option *, int *, int);
static int parse_long_options(char * const *, const char *,
			      const struct option *, int *, int, int);
static int gcd(int, int);
static void permute_args(int, int, int, char * const *);

static char *place = EMSG; /* option letter processing */

/* XXX: set optreset to 1 rather than these two */
static int nonopt_start = -1; /* first non option argument (for permute) */
static int nonopt_end = -1;   /* first option after non options (for permute) */

/* Error messages */
static const char recargchar[] = "option requires an argument -- %c";
static const char recargstring[] = "option requires an argument -- %s";
static const char ambig[] = "ambiguous option -- %.*s";
static const char noarg[] = "option doesn't take an argument -- %.*s";
static const char illoptchar[] = "unknown option -- %c";
static const char illoptstring[] = "unknown option -- %s";

/*
 * Compute the greatest common divisor of a and b.
 */
static int
gcd(int a, int b)
{
	int c;

	c = a % b;
	while (c != 0) {
		a = b;
		b = c;
		c = a % b;
	}

	return (b);
}

/*
 * Exchange the block from nonopt_start to nonopt_end with the block
 * from nonopt_end to opt_end (keeping the same order of arguments
 * in each block).
 */
static void
permute_args(int panonopt_start, int panonopt_end, int opt_end,
	char * const *nargv)
{
	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
	char *swap;

	/*
	 * compute lengths of blocks and number and size of cycles
	 */
	nnonopts = panonopt_end - panonopt_start;
	nopts = opt_end - panonopt_end;
	ncycle = gcd(nnonopts, nopts);
	cyclelen = (opt_end - panonopt_start) / ncycle;

	for (i = 0; i < ncycle; i++) {
		cstart = panonopt_end+i;
		pos = cstart;
		for (j = 0; j < cyclelen; j++) {
			if (pos >= panonopt_end)
				pos -= nnonopts;
			else
				pos += nopts;
			swap = nargv[pos];
			((char **)nargv)[pos] = nargv[cstart];
			((char **)nargv)[cstart] = swap;
		}
	}
}

/*
 * parse_long_options --
 *	Parse long options in argc/argv argument vector.
 * Returns -1 if short_too is set and the option does not match long_options.
 */
static int
parse_long_options(char * const *nargv, const char *options,
	const struct option *long_options, int *idx, int short_too, int flags)
{
	char *current_argv, *has_equal;
	size_t current_argv_len;
	int i, match, exact_match, second_partial_match;

	current_argv = place;
	match = -1;
	exact_match = 0;
	second_partial_match = 0;

	optind++;

	if ((has_equal = strchr(current_argv, '=')) != NULL) {
		/* argument found (--option=arg) */
		current_argv_len = has_equal - current_argv;
		has_equal++;
	} else
		current_argv_len = strlen(current_argv);

	for (i = 0; long_options[i].name; i++) {
		/* find matching long option */
		if (strncmp(current_argv, long_options[i].name,
		    current_argv_len))
			continue;

		if (strlen(long_options[i].name) == current_argv_len) {
			/* exact match */
			match = i;
			exact_match = 1;
			break;
		}
		/*
		 * If this is a known short option, don't allow
		 * a partial match of a single character.
		 */
		if (short_too && current_argv_len == 1)
			continue;

		if (match == -1)	/* first partial match */
			match = i;
		else if ((flags & FLAG_LONGONLY) ||
		    long_options[i].has_arg != long_options[match].has_arg ||
		    long_options[i].flag != long_options[match].flag ||
		    long_options[i].val != long_options[match].val)
			second_partial_match = 1;
	}
	if (!exact_match && second_partial_match) {
		/* ambiguous abbreviation */
		if (PRINT_ERROR)
			warnx(ambig, (int)current_argv_len, current_argv);
		optopt = 0;
		return (BADCH);
	}
	if (match != -1) {		/* option found */
		if (long_options[match].has_arg == no_argument
		    && has_equal) {
			if (PRINT_ERROR)
				warnx(noarg, (int)current_argv_len,
				     current_argv);
			/*
			 * XXX: GNU sets optopt to val regardless of flag
			 */
			if (long_options[match].flag == NULL)
				optopt = long_options[match].val;
			else
				optopt = 0;
			return (BADARG);
		}
		if (long_options[match].has_arg == required_argument ||
		    long_options[match].has_arg == optional_argument) {
			if (has_equal)
				optarg = has_equal;
			else if (long_options[match].has_arg ==
			    required_argument) {
				/*
				 * optional argument doesn't use next nargv
				 */
				optarg = nargv[optind++];
			}
		}
		if ((long_options[match].has_arg == required_argument)
		    && (optarg == NULL)) {
			/*
			 * Missing argument; leading ':' indicates no error
			 * should be generated.
			 */
			if (PRINT_ERROR)
				warnx(recargstring,
				    current_argv);
			/*
			 * XXX: GNU sets optopt to val regardless of flag
			 */
			if (long_options[match].flag == NULL)
				optopt = long_options[match].val;
			else
				optopt = 0;
			--optind;
			return (BADARG);
		}
	} else {			/* unknown option */
		if (short_too) {
			--optind;
			return (-1);
		}
		if (PRINT_ERROR)
			warnx(illoptstring, current_argv);
		optopt = 0;
		return (BADCH);
	}
	if (idx)
		*idx = match;
	if (long_options[match].flag) {
		*long_options[match].flag = long_options[match].val;
		return (0);
	} else
		return (long_options[match].val);
}

/*
 * getopt_internal --
 *	Parse argc/argv argument vector.  Called by user level routines.
 */
static int
getopt_internal(int nargc, char * const *nargv, const char *options,
	const struct option *long_options, int *idx, int flags)
{
	char *oli;				/* option letter list index */
	int optchar, short_too;
	static int posixly_correct = -1;

	if (options == NULL)
		return (-1);

	/*
	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
	 * XXX using optreset.  Work around this braindamage.
	 */
	if (optind == 0)
		optind = optreset = 1;

	/*
	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
	 * string begins with a '+'.
	 */
	if (posixly_correct == -1 || optreset)
		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);
	if (*options == '-')
		flags |= FLAG_ALLARGS;
	else if (posixly_correct || *options == '+')
		flags &= ~FLAG_PERMUTE;
	if (*options == '+' || *options == '-')
		options++;

	optarg = NULL;
	if (optreset)
		nonopt_start = nonopt_end = -1;
start:
	if (optreset || !*place) {		/* update scanning pointer */
		optreset = 0;
		if (optind >= nargc) {          /* end of argument vector */
			place = EMSG;
			if (nonopt_end != -1) {
				/* do permutation, if we have to */
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				optind -= nonopt_end - nonopt_start;
			}
			else if (nonopt_start != -1) {
				/*
				 * If we skipped non-options, set optind
				 * to the first of them.
				 */
				optind = nonopt_start;
			}
			nonopt_start = nonopt_end = -1;
			return (-1);
		}
		if (*(place = nargv[optind]) != '-' ||
		    (place[1] == '\0' && strchr(options, '-') == NULL)) {
			place = EMSG;		/* found non-option */
			if (flags & FLAG_ALLARGS) {
				/*
				 * GNU extension:
				 * return non-option as argument to option 1
				 */
				optarg = nargv[optind++];
				return (INORDER);
			}
			if (!(flags & FLAG_PERMUTE)) {
				/*
				 * If no permutation wanted, stop parsing
				 * at first non-option.
				 */
				return (-1);
			}
			/* do permutation */
			if (nonopt_start == -1)
				nonopt_start = optind;
			else if (nonopt_end != -1) {
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				nonopt_start = optind -
				    (nonopt_end - nonopt_start);
				nonopt_end = -1;
			}
			optind++;
			/* process next argument */
			goto start;
		}
		if (nonopt_start != -1 && nonopt_end == -1)
			nonopt_end = optind;

		/*
		 * If we have "-" do nothing, if "--" we are done.
		 */
		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
			optind++;
			place = EMSG;
			/*
			 * We found an option (--), so if we skipped
			 * non-options, we have to permute.
			 */
			if (nonopt_end != -1) {
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				optind -= nonopt_end - nonopt_start;
			}
			nonopt_start = nonopt_end = -1;
			return (-1);
		}
	}

	/*
	 * Check long options if:
	 *  1) we were passed some
	 *  2) the arg is not just "-"
	 *  3) either the arg starts with -- we are getopt_long_only()
	 */
	if (long_options != NULL && place != nargv[optind] &&
	    (*place == '-' || (flags & FLAG_LONGONLY))) {
		short_too = 0;
		if (*place == '-')
			place++;		/* --foo long option */
		else if (*place != ':' && strchr(options, *place) != NULL)
			short_too = 1;		/* could be short option too */

		optchar = parse_long_options(nargv, options, long_options,
		    idx, short_too, flags);
		if (optchar != -1) {
			place = EMSG;
			return (optchar);
		}
	}

	if ((optchar = (int)*place++) == (int)':' ||
	    (optchar == (int)'-' && *place != '\0') ||
	    (oli = strchr(options, optchar)) == NULL) {
		/*
		 * If the user specified "-" and  '-' isn't listed in
		 * options, return -1 (non-option) as per POSIX.
		 * Otherwise, it is an unknown option character (or ':').
		 */
		if (optchar == (int)'-' && *place == '\0')
			return (-1);
		if (!*place)
			++optind;
		if (PRINT_ERROR)
			warnx(illoptchar, optchar);
		optopt = optchar;
		return (BADCH);
	}
	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {
		/* -W long-option */
		if (*place)			/* no space */
			/* NOTHING */;
		else if (++optind >= nargc) {	/* no arg */
			place = EMSG;
			if (PRINT_ERROR)
				warnx(recargchar, optchar);
			optopt = optchar;
			return (BADARG);
		} else				/* white space */
			place = nargv[optind];
		optchar = parse_long_options(nargv, options, long_options,
		    idx, 0, flags);
		place = EMSG;
		return (optchar);
	}
	if (*++oli != ':') {			/* doesn't take argument */
		if (!*place)
			++optind;
	} else {				/* takes (optional) argument */
		optarg = NULL;
		if (*place)			/* no white space */
			optarg = place;
		else if (oli[1] != ':') {	/* arg not optional */
			if (++optind >= nargc) {	/* no arg */
				place = EMSG;
				if (PRINT_ERROR)
					warnx(recargchar, optchar);
				optopt = optchar;
				return (BADARG);
			} else
				optarg = nargv[optind];
		}
		place = EMSG;
		++optind;
	}
	/* dump back option letter */
	return (optchar);
}

/*
 * getopt --
 *	Parse argc/argv argument vector.
 *
 * [eventually this will replace the BSD getopt]
 */
int
getopt(int nargc, char * const *nargv, const char *options)
{

	/*
	 * We don't pass FLAG_PERMUTE to getopt_internal() since
	 * the BSD getopt(3) (unlike GNU) has never done this.
	 *
	 * Furthermore, since many privileged programs call getopt()
	 * before dropping privileges it makes sense to keep things
	 * as simple (and bug-free) as possible.
	 */
	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));
}

/*
 * getopt_long --
 *	Parse argc/argv argument vector.
 */
int
getopt_long(int nargc, char * const *nargv, const char *options,
    const struct option *long_options, int *idx)
{

	return (getopt_internal(nargc, nargv, options, long_options, idx,
	    FLAG_PERMUTE));
}

/*
 * getopt_long_only --
 *	Parse argc/argv argument vector.
 */
int
getopt_long_only(int nargc, char * const *nargv, const char *options,
    const struct option *long_options, int *idx)
{

	return (getopt_internal(nargc, nargv, options, long_options, idx,
	    FLAG_PERMUTE|FLAG_LONGONLY));
}
@


1.28
log
@Don't wrap initialized variables: binutils appears to be mishandling them
on arm and m88k

problems with optind observed by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.27 2015/09/12 14:48:14 guenther Exp $	*/
d152 1
a152 3
			/* LINTED const cast */
			((char **) nargv)[pos] = nargv[cstart];
			/* LINTED const cast */
@


1.27
log
@Wrap <getopt.h> to make the functions weak and make access to the initialized
variables go direct.  (Common variables cannot be aliased.)
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.26 2013/06/08 22:47:56 millert Exp $	*/
d64 1
d69 1
@


1.26
log
@Fix parsing of ambiguous options, the whole loop must be processed.
From FreeBSD.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.25 2011/03/05 22:10:11 guenther Exp $	*/
d63 5
@


1.25
log
@Fix PR 6267: recheck POSIXLY_CORRECT each time getopt_long() starts a new
argv and don't suppress the handling of leading '-' in optstring when
POSIXLY_CORRECT is set.

Based on patch from Eric Blake.
ok and manpage update from millert@@, manpage ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.24 2010/07/22 19:31:53 blambert Exp $	*/
d80 1
a80 1
			      const struct option *, int *, int);
d160 1
a160 1
	const struct option *long_options, int *idx, int short_too)
d164 1
a164 1
	int i, match;
d168 2
d189 1
d199 1
a199 1
		if (match == -1)	/* partial match */
d201 12
a212 8
		else {
			/* ambiguous abbreviation */
			if (PRINT_ERROR)
				warnx(ambig, (int)current_argv_len,
				     current_argv);
			optopt = 0;
			return (BADCH);
		}
d408 1
a408 1
		    idx, short_too);
d445 1
a445 1
		    idx, 0);
@


1.24
log
@getopt_long.c replaced getopt.c 6+ years ago; we can retire
the REPLACE_GETOPT macro, at long last

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.23 2007/10/31 12:34:57 chl Exp $	*/
d288 7
d298 1
a298 1
	if (posixly_correct == -1)
d300 3
a302 1
	if (posixly_correct || *options == '+')
a303 2
	else if (*options == '-')
		flags |= FLAG_ALLARGS;
a305 7

	/*
	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
	 * XXX using optreset.  Work around this braindamage.
	 */
	if (optind == 0)
		optind = optreset = 1;
@


1.23
log
@Add parentheses to avoid warning:
"suggest parentheses around && within ||"

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.22 2006/10/04 21:29:04 jmc Exp $	*/
a57 3
#define	REPLACE_GETOPT		/* use this getopt as the system getopt(3) */

#ifdef REPLACE_GETOPT
a62 1
#endif
a465 1
#ifdef REPLACE_GETOPT
a485 1
#endif /* REPLACE_GETOPT */
@


1.22
log
@from wiz@@netbsd:

Log Message:
Switch from 4-clause to 2-clause BSD license.
Ok dillo@@, board@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.21 2006/09/22 17:22:05 millert Exp $	*/
d413 1
a413 1
	    optchar == (int)'-' && *place != '\0' ||
@


1.21
log
@Back out change in rev 1.15 of to allow whitespace to separate a
flag from its optional argument if permutation is disabled.  The
idea was that since "r:" would match "-r foo" then "r::" should
match "-r foo" too as long as we know that things have not been
reshuffled.  Unfortunately, this causes incompatibilities with GNU
getopt_long when the POSIXLY_CORRECT environment variable is set.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.20 2005/10/25 15:49:37 jmc Exp $	*/
a37 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.20
log
@dont' -> don't in comments;
from ray lai;
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.19 2005/08/08 08:05:36 espie Exp $	*/
a459 1
		/* XXX: disable test for :: if PC? (GNU doesn't) */
a468 8
		} else if (!(flags & FLAG_PERMUTE)) {
			/*
			 * If permutation is disabled, we can accept an
			 * optional arg separated by whitespace so long
			 * as it does not start with a dash (-).
			 */
			if (optind + 1 < nargc && *nargv[optind + 1] != '-')
				optarg = nargv[++optind];
@


1.19
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.18 2005/03/30 18:51:49 pat Exp $	*/
d498 1
a498 1
	 * We dont' pass FLAG_PERMUTE to getopt_internal() since
@


1.18
log
@ansi + de-register

ok otto deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.17 2004/06/03 18:46:52 millert Exp $	*/
a57 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.17 2004/06/03 18:46:52 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.17
log
@An optional argument cannot start with '-', even if permutation is
disabled.  Magne Oestlyngen.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.16 2004/02/04 18:17:25 millert Exp $	*/
d60 1
a60 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.16 2004/02/04 18:17:25 millert Exp $";
d518 2
a519 6
getopt_long(nargc, nargv, options, long_options, idx)
	int nargc;
	char * const *nargv;
	const char *options;
	const struct option *long_options;
	int *idx;
d531 2
a532 6
getopt_long_only(nargc, nargv, options, long_options, idx)
	int nargc;
	char * const *nargv;
	const char *options;
	const struct option *long_options;
	int *idx;
@


1.16
log
@Traditionally, getopt(3) has treated "--foo" the same as "--".  However,
this can cause confusion when a user tries to use a long option with
a program that only supports short options.  Furthermore, it appears
to be in violation of POSIX, which states that "--" shall indicate
the end of argument processing, not any string that begins with "--".
OK otto@@ and closes PR 3666.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.15 2003/09/22 23:45:22 millert Exp $	*/
d60 1
a60 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.15 2003/09/22 23:45:22 millert Exp $";
d477 2
a478 1
			 * optional arg separated by whitespace.
d480 1
a480 1
			if (optind + 1 < nargc)
@


1.15
log
@If permutation is disabled (as it is via getopt(3) or when POSIXLY_CORRECT
is set), we can accept an optional arg separated by whitespace.  Previously,
the optional arg needed to be adjacent to the option character.
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.14 2003/06/17 21:56:24 millert Exp $	*/
d60 1
a60 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.14 2003/06/17 21:56:24 millert Exp $";
d382 1
a382 2
		 * Check for "--" or "--foo" with no long options
		 * but if place is simply "-" leave it unmolested.
d384 1
a384 2
		if (place[1] != '\0' && *++place == '-' &&
		    (place[1] == '\0' || long_options == NULL)) {
d424 1
d427 3
a429 2
		 * If the user didn't specify '-' as an option,
		 * assume it means -1 as POSIX specifies.
d431 1
a431 1
		if (optchar == (int)'-')
a432 1
		/* option letter unknown or ':' */
@


1.14
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.13 2003/06/03 01:52:40 millert Exp $	*/
d60 1
a60 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.13 2003/06/03 01:52:40 millert Exp $";
d475 7
@


1.14.2.1
log
@MFC:
Fix by millert@@

Traditionally, getopt(3) has treated "--foo" the same as "--".  However,
this can cause confusion when a user tries to use a long option with
a program that only supports short options.  Furthermore, it appears
to be in violation of POSIX, which states that "--" shall indicate
the end of argument processing, not any string that begins with "--".
OK otto@@ and closes PR 3666.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.14 2003/06/17 21:56:24 millert Exp $	*/
d60 1
a60 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.14 2003/06/17 21:56:24 millert Exp $";
d382 2
a383 1
		 * If we have "-" do nothing, if "--" we are done.
d385 2
a386 1
		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {
a425 1
	    optchar == (int)'-' && *place != '\0' ||
d428 2
a429 3
		 * If the user specified "-" and  '-' isn't listed in
		 * options, return -1 (non-option) as per POSIX.
		 * Otherwise, it is an unknown option character (or ':').
d431 1
a431 1
		if (optchar == (int)'-' && *place == '\0')
d433 1
@


1.13
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.12 2003/06/02 03:46:43 millert Exp $	*/
d11 11
a21 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d60 1
a60 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.12 2003/06/02 03:46:43 millert Exp $";
@


1.12
log
@Use the getopt() in getopt_long.c which supports some GNU extensions.
getopt.c is no longer compiled and will eventually be removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.11 2002/12/10 17:51:42 millert Exp $	*/
a5 1
 * All rights reserved.
d7 3
a9 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d11 7
a17 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d56 1
a56 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.11 2002/12/10 17:51:42 millert Exp $";
@


1.11
log
@When doing permutation, only treat "-" as an option if it was specified
in optstring.  Problem noticed by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.10 2002/12/08 17:52:26 millert Exp $	*/
d67 1
a67 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.10 2002/12/08 17:52:26 millert Exp $";
d75 2
@


1.10
log
@SUS (and apparently 1003.1-2001) say to check optstring for NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.9 2002/12/08 17:07:46 millert Exp $	*/
d67 1
a67 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.9 2002/12/08 17:07:46 millert Exp $";
d351 3
a353 2
		if (*(place = nargv[optind]) != '-') {	/* found non-option */
			place = EMSG;
@


1.9
log
@If we are passed "-" in argv and the user didn't specify '-' in optstring,
return -1 like POSIX requires.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.8 2002/12/08 07:23:09 millert Exp $	*/
d67 1
a67 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.8 2002/12/08 07:23:09 millert Exp $";
d304 2
a305 1
	optarg = NULL;
d327 1
@


1.8
log
@BSD getopt() supports '-' in the optstring so we should too.
This is used by a few programs such as man and su.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.7 2002/12/07 19:48:32 millert Exp $	*/
d67 1
a67 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.7 2002/12/07 19:48:32 millert Exp $";
d323 2
a324 4
	if (optind == 0) {
		optind = 1;
		optreset = 1;
	}
d429 6
@


1.7
log
@Fix pasto in last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.6 2002/12/07 19:15:59 millert Exp $	*/
d67 1
a67 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.6 2002/12/07 19:15:59 millert Exp $";
d351 1
a351 2
		if ((*(place = nargv[optind]) != '-')
		    || (place[1] == '\0')) {    /* found non-option */
d385 5
a389 2
		/* check for "--" or "--foo" with no long options */
		if (*++place == '-' &&
d407 7
a413 2
	/* check long options if we have any */
	if (long_options != NULL &&
@


1.6
log
@For getopt_long_only() we *do* want to match single-character options
as shortcuts for long ones, but only if this would not conflict with
a short option in optstring.  Now binutils gas works.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.5 2002/12/06 16:03:29 millert Exp $	*/
d67 1
a67 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.5 2002/12/06 16:03:29 millert Exp $";
d411 1
a411 1
		else if (*place != ':' && strchr(options, optchar) != NULL)
@


1.5
log
@Fix two compatibility issues with our getopt_long_only() vs. the GNU version:
o Check for long options even when not at the beginning of an option.
  For instance, if -a is a short option w/o an arg and -static is a
  boolean long option then -astatic is valid for getopt_long_only().
o If a potential long argument does not match longopts and the first
  character is not a short option, print a warning and skip the rest
  of the argument.

Also clean up some trailing whitespace and change return value of
parse_long_options() from -2 to -1 when unmatched and in long_only mode.

With these fixes the binutils ld seems happy with our getopt_long_only()
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.4 2002/12/05 22:26:04 millert Exp $	*/
d67 1
a67 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.4 2002/12/05 22:26:04 millert Exp $";
d176 1
a176 2
 *  Returns -1 if long_only is set and the current option could be a short
 *	(single character) option instead.
d180 1
a180 1
	const struct option *long_options, int *idx, int long_only)
d210 2
a211 3
		 * Don't try a partial match of a short option when in
		 * long_only mode.  Otherwise there is a potential conflict
		 * between partial matches and short options.
d213 1
a213 1
		if (long_only && current_argv_len == 1)
d274 1
a274 1
		if (long_only) {
d301 1
a301 2
	int optchar;
	int long_only;
d320 2
a321 3
	 * XXX Some programs (like rsyncd) expect to be able to
	 * XXX re-initialize optind to 0 and have getopt_long(3)
	 * XXX properly function again.  Work around this braindamage.
d323 1
a323 1
	if (optind == 0)
d325 2
d385 4
a388 1
		if (strcmp(place, "--") == 0) {
a402 1
		place++;
d405 14
a418 13
	/* Check long options if we have any */
	long_only = 0;
	if (long_options != NULL) {
		if (*place == '-' ||
		    (long_only = (flags & FLAG_LONGONLY))) {
			if (!long_only)
				place++;
			optchar = parse_long_options(nargv, options,
			    long_options, idx, long_only);
			if (optchar != -1) {
				place = EMSG;
				return (optchar);
			}
d421 1
d425 1
a425 7
		if (PRINT_ERROR) {
			if (long_only)
				warnx(illoptstring, place - 1);
			else
				warnx(illoptchar, optchar);
		}
		if (!*place || long_only) {
d427 2
a428 3
			if (*place)
				place = EMSG;
		}
@


1.4
log
@Correctly handle -Wlong_arg (no space between -W and long_arg) when "W;"
is in optstring.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.3 2002/12/05 21:45:01 millert Exp $	*/
d4 26
d67 1
a67 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.3 2002/12/05 21:45:01 millert Exp $";
d99 1
a99 1
static int parse_long_options(int, char * const *, const char *,
d132 1
a132 1
	   
d176 1
a176 1
 *  Returns -2 if long_only is set and the current option could be a short
d180 1
a180 1
parse_long_options(int nargc, char * const *nargv, const char *options,
d278 1
a278 1
			return (-2);
d290 1
a290 1
	} else 
d304 1
d358 1
a358 1
				 * GNU extension: 
d403 1
d405 12
a416 14
		/* Check long options if we have any */
		if (long_options != NULL) {
			int long_only = 0;

			if (*place == '-' ||
			    (long_only = (flags & FLAG_LONGONLY))) {
				if (!long_only)
					place++;
				optchar = parse_long_options(nargc, nargv,
				    options, long_options, idx, long_only);
				if (optchar != -2) {
					place = EMSG;
					return (optchar);
				}
d423 7
a429 1
		if (!*place)
d431 3
a433 2
		if (PRINT_ERROR)
			warnx(illoptchar, optchar);
d449 2
a450 2
		optchar = parse_long_options(nargc, nargv, options,
		    long_options, idx, 0);
@


1.3
log
@Reorganize this so that getopt_only_only() works correctly.
In order for getopt_only_only() to work we need to check for long
options before short ones.  I have merged getopt_internal and
getopt_long_internal into a single function with the actual long
args parsing broken out into a separate function.
This also simplifies the flow of control.
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.2 2002/12/03 20:28:12 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.2 2002/12/03 20:28:12 millert Exp $";
d65 1
a65 1
#define	BADCH	(int)'?'
d67 1
a67 1
#define INORDER (int)1
d69 1
a69 1
#define	EMSG	""
d406 3
a408 1
		if (++optind >= nargc) {	/* no arg */
@


1.2
log
@Whoops, add missing #ifdef REPLACE_GETOPT
@
text
@d1 1
a1 1
/*	$OpenBSD: getopt_long.c,v 1.1 2002/12/03 20:24:30 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: getopt_long.c,v 1.1 2002/12/03 20:24:30 millert Exp $";
d60 3
a62 3
#define FLAG_PERMUTE	0x01
#define FLAG_ALLARGS	0x02
#define FLAG_LONGONLY	0x04
d71 4
a74 3
static int getopt_internal(int, char * const *, const char *, int);
static int getopt_long_internal(int, char * const *, const char *,
				const struct option *, int *, int);
d96 1
a96 3
gcd(a, b)
	int a;
	int b;
d107 1
a107 1
	return b;
d116 2
a117 5
permute_args(panonopt_start, panonopt_end, opt_end, nargv)
	int panonopt_start;
	int panonopt_end;
	int opt_end;
	char * const *nargv;
d148 121
a270 1
 *  Returns -2 if -- is found (can be long option or end of options marker).
d273 2
a274 5
getopt_internal(nargc, nargv, options, flags)
	int nargc;
	char * const *nargv;
	const char *options;
	int flags;
d278 1
d283 13
d324 1
a324 1
			return -1;
d335 1
a335 1
				return INORDER;
d342 1
a342 1
				return -1;
d360 32
a391 3
		if (place[1] && *++place == '-') {	/* found "--" */
			place++;
			return -2;
a395 3
		/* could it be a long option with a single '-'? */
		if (flags & FLAG_LONGONLY)
			return -2;
d402 1
a402 1
		return BADCH;
d404 2
a405 5
	if (optchar == 'W' && oli[1] == ';') {		/* -W long-option */
		/* XXX: what if no long options provided (called by getopt)? */
		if (*place) 
			return -2;

d411 1
a411 1
			return BADARG;
d414 4
a417 5
		/*
		 * Handle -W arg the same as --arg (which causes getopt to
		 * stop parsing).
		 */
		return -2;
d433 1
a433 1
				return BADARG;
d441 1
a441 1
	return optchar;
d452 1
a452 4
getopt(nargc, nargv, options)
	int nargc;
	char * const *nargv;
	const char *options;
a453 34
	int retval;

	if ((retval = getopt_internal(nargc, nargv, options, 0)) == -2) {
		++optind;
		/*
		 * We found an option (--), so if we skipped non-options,
		 * we have to permute.
		 */
		if (nonopt_end != -1) {
			permute_args(nonopt_start, nonopt_end, optind,
				       nargv);
			optind -= nonopt_end - nonopt_start;
		}
		nonopt_start = nonopt_end = -1;
		retval = -1;
	}
	return retval;
}
#endif /* REPLACE_GETOPT */

/*
 * getopt_long_internal --
 *	Parse argc/argv argument vector.
 */
static int
getopt_long_internal(nargc, nargv, options, long_options, idx, flags)
	int nargc;
	char * const *nargv;
	const char *options;
	const struct option *long_options;
	int *idx;
	int flags;
{
	int retval;
d456 6
a461 2
	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
	 * string begins with a '+'.
d463 1
a463 132
	if (getenv("POSIXLY_CORRECT")) {
		if (*options == '+' || *options == '-')
			options++;
	} else {
		if (*options == '+') {
			options++;
		} else {
			flags |= FLAG_PERMUTE;
			if (*options == '-') {
				flags |= FLAG_ALLARGS;
				options++;
			}
		}
	}

	if ((retval = getopt_internal(nargc, nargv, options, flags)) == -2) {
		char *current_argv, *has_equal;
		size_t current_argv_len;
		int i, match;

		current_argv = place;
		match = -1;

		optind++;
		place = EMSG;

		if (*current_argv == '\0') {		/* found "--" */
			/*
			 * We found an option (--), so if we skipped
			 * non-options, we have to permute.
			 */
			if (nonopt_end != -1) {
				permute_args(nonopt_start, nonopt_end,
				    optind, nargv);
				optind -= nonopt_end - nonopt_start;
			}
			nonopt_start = nonopt_end = -1;
			return -1;
		}
		if ((has_equal = strchr(current_argv, '=')) != NULL) {
			/* argument found (--option=arg) */
			current_argv_len = has_equal - current_argv;
			has_equal++;
		} else
			current_argv_len = strlen(current_argv);
	    
		for (i = 0; long_options[i].name; i++) {
			/* find matching long option */
			if (strncmp(current_argv, long_options[i].name,
			    current_argv_len))
				continue;

			if (strlen(long_options[i].name) ==
			    (unsigned)current_argv_len) {
				/* exact match */
				match = i;
				break;
			}
			if (match == -1)		/* partial match */
				match = i;
			else {
				/* ambiguous abbreviation */
				if (PRINT_ERROR)
					warnx(ambig, (int)current_argv_len,
					     current_argv);
				optopt = 0;
				return BADCH;
			}
		}
		if (match != -1) {			/* option found */
		        if (long_options[match].has_arg == no_argument
			    && has_equal) {
				if (PRINT_ERROR)
					warnx(noarg, (int)current_argv_len,
					     current_argv);
				/*
				 * XXX: GNU sets optopt to val regardless of
				 * flag
				 */
				if (long_options[match].flag == NULL)
					optopt = long_options[match].val;
				else
					optopt = 0;
				return BADARG;
			}
			if (long_options[match].has_arg == required_argument ||
			    long_options[match].has_arg == optional_argument) {
				if (has_equal)
					optarg = has_equal;
				else if (long_options[match].has_arg ==
				    required_argument) {
					/*
					 * optional argument doesn't use
					 * next nargv
					 */
					optarg = nargv[optind++];
				}
			}
			if ((long_options[match].has_arg == required_argument)
			    && (optarg == NULL)) {
				/*
				 * Missing argument; leading ':'
				 * indicates no error should be generated
				 */
				if (PRINT_ERROR)
					warnx(recargstring, current_argv);
				/*
				 * XXX: GNU sets optopt to val regardless
				 * of flag
				 */
				if (long_options[match].flag == NULL)
					optopt = long_options[match].val;
				else
					optopt = 0;
				--optind;
				return BADARG;
			}
		} else {			/* unknown option */
			if (PRINT_ERROR)
				warnx(illoptstring, current_argv);
			optopt = 0;
			return BADCH;
		}
		if (long_options[match].flag) {
			*long_options[match].flag = long_options[match].val;
			retval = 0;
		} else 
			retval = long_options[match].val;
		if (idx)
			*idx = match;
	}
	return retval;
d465 1
d480 2
a481 1
	return getopt_long_internal(nargc, nargv, options, long_options, idx, 0);
d497 2
a498 2
	return getopt_long_internal(nargc, nargv, options, long_options, idx,
	    FLAG_LONGONLY);
@


1.1
log
@GNU-like getopt_long() from NetBSD with changes by me to support
getopt_long_only().  At some point this should replace the BSD
getopt(3) but we are not there yet.

While I am here add protection from the multiple getopt() definitions
due to conflicting standards.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD$";
d50 1
d56 1
@

