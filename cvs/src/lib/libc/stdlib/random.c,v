head	1.30;
access;
symbols
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.4
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.26
	OPENBSD_5_0:1.15.0.24
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.22
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.20
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.16
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.18
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.14
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.12
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.10
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.8
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.6
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.12
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.10
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.04.05.04.29.21;	author guenther;	state Exp;
branches;
next	1.29;
commitid	INw7kjfUlnrMbBig;

1.29
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	0DYulI8hhujBHMcR;

1.28
date	2014.12.16.20.51.32;	author sthen;	state Exp;
branches;
next	1.27;
commitid	SqyMDOCYHCT24HZd;

1.27
date	2014.12.16.20.42.36;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	Xrw5RjA7uoPKRQFS;

1.26
date	2014.12.09.08.00.53;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	9m2M2bgieE6DWdc2;

1.25
date	2014.12.08.21.45.20;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	HpI1xDivwwEoN4ET;

1.24
date	2014.10.13.20.54.13;	author chl;	state Exp;
branches;
next	1.23;
commitid	2KTBk64mZZLHwKn3;

1.23
date	2014.07.13.14.21.14;	author tedu;	state Exp;
branches;
next	1.22;
commitid	Updmmwmz9ihKvkjk;

1.22
date	2014.06.15.05.10.58;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	vPHuZr9pfICSafoT;

1.21
date	2014.06.15.01.49.06;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	WD3Gl9VvZF3m4QF3;

1.20
date	2014.06.13.15.35.34;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	nmCG3X16YNVn4SGO;

1.19
date	2013.08.01.19.42.08;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.15.19.07.53;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2012.06.01.01.01.57;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.21.12.36.49;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.30.07.51.02;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.08.08.05.37;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.30.18.51.49;	author pat;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.18.38;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.28.21.27.44;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.06.17.43.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.04.14.27.00;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.04.13.38.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.03.23.23.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.02.07.02.16.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.02.06.01.49.08;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.09.31.51;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.33.46;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.30.10.01.47;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.19;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Prefer _MUTEX_*LOCK over _THREAD_PRIVATE_MUTEX_*LOCK() when thread-specific
data isn't necessary.

ok mpi@@, ok&tweak natano@@
@
text
@/*	$OpenBSD: random.c,v 1.29 2015/01/16 16:48:51 deraadt Exp $ */
/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "thread_private.h"

/*
 * random.c:
 *
 * An improved random number generation package.  In addition to the standard
 * rand()/srand() like interface, this package also has a special state info
 * interface.  The initstate() routine is called with a seed, an array of
 * bytes, and a count of how many bytes are being passed in; this array is
 * then initialized to contain information for random number generation with
 * that much state information.  Good sizes for the amount of state
 * information are 32, 64, 128, and 256 bytes.  The state can be switched by
 * calling the setstate() routine with the same array as was initiallized
 * with initstate().  By default, the package runs with 128 bytes of state
 * information and generates far better random numbers than a linear
 * congruential generator.  If the amount of state information is less than
 * 32 bytes, a simple linear congruential R.N.G. is used.
 *
 * Internally, the state information is treated as an array of int32_t; the
 * zeroeth element of the array is the type of R.N.G. being used (small
 * integer); the remainder of the array is the state information for the
 * R.N.G.  Thus, 32 bytes of state information will give 7 int32_ts worth of
 * state information, which will allow a degree seven polynomial.  (Note:
 * the zeroeth word of state information also has some other information
 * stored in it -- see setstate() for details).
 * 
 * The random number generation technique is a linear feedback shift register
 * approach, employing trinomials (since there are fewer terms to sum up that
 * way).  In this approach, the least significant bit of all the numbers in
 * the state table will act as a linear feedback shift register, and will
 * have period 2^deg - 1 (where deg is the degree of the polynomial being
 * used, assuming that the polynomial is irreducible and primitive).  The
 * higher order bits will have longer periods, since their values are also
 * influenced by pseudo-random carries out of the lower bits.  The total
 * period of the generator is approximately deg*(2**deg - 1); thus doubling
 * the amount of state information has a vast influence on the period of the
 * generator.  Note: the deg*(2**deg - 1) is an approximation only good for
 * large deg, when the period of the shift register is the dominant factor.
 * With deg equal to seven, the period is actually much longer than the
 * 7*(2**7 - 1) predicted by this formula.
 */

/*
 * For each of the currently supported random number generators, we have a
 * break value on the amount of state information (you need at least this
 * many bytes of state info to support this random number generator), a degree
 * for the polynomial (actually a trinomial) that the R.N.G. is based on, and
 * the separation between the two lower order coefficients of the trinomial.
 */
#define	TYPE_0		0		/* linear congruential */
#define	BREAK_0		8
#define	DEG_0		0
#define	SEP_0		0

#define	TYPE_1		1		/* x**7 + x**3 + 1 */
#define	BREAK_1		32
#define	DEG_1		7
#define	SEP_1		3

#define	TYPE_2		2		/* x**15 + x + 1 */
#define	BREAK_2		64
#define	DEG_2		15
#define	SEP_2		1

#define	TYPE_3		3		/* x**31 + x**3 + 1 */
#define	BREAK_3		128
#define	DEG_3		31
#define	SEP_3		3

#define	TYPE_4		4		/* x**63 + x + 1 */
#define	BREAK_4		256
#define	DEG_4		63
#define	SEP_4		1

/*
 * Array versions of the above information to make code run faster --
 * relies on fact that TYPE_i == i.
 */
#define	MAX_TYPES	5		/* max number of types above */

static int degrees[MAX_TYPES] =	{ DEG_0, DEG_1, DEG_2, DEG_3, DEG_4 };
static int seps [MAX_TYPES] =	{ SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 };

/*
 * Initially, everything is set up as if from:
 *
 *	initstate(1, &randtbl, 128);
 *
 * Note that this initialization takes advantage of the fact that srandom()
 * advances the front and rear pointers 10*rand_deg times, and hence the
 * rear pointer which starts at 0 will also end up at zero; thus the zeroeth
 * element of the state information, which contains info about the current
 * position of the rear pointer is just
 *
 *	MAX_TYPES * (rptr - state) + TYPE_3 == TYPE_3.
 */

static int32_t randtbl[DEG_3 + 1] = {
	TYPE_3,
	0x991539b1, 0x16a5bce3, 0x6774a4cd, 0x3e01511e, 0x4e508aaa, 0x61048c05, 
	0xf5500617, 0x846b7115, 0x6a19892c, 0x896a97af, 0xdb48f936, 0x14898454, 
	0x37ffd106, 0xb58bff9c, 0x59e17104, 0xcf918a49, 0x09378c83, 0x52c7a471, 
	0x8d293ea9, 0x1f4fc301, 0xc3db71be, 0x39b44e1c, 0xf8a44ef9, 0x4c8b80b1, 
	0x19edc328, 0x87bf4bdd, 0xc9b240e5, 0xe9ee4b1b, 0x4382aee7, 0x535b6b41, 
	0xf3bec5da,
};

/*
 * fptr and rptr are two pointers into the state info, a front and a rear
 * pointer.  These two pointers are always rand_sep places aparts, as they
 * cycle cyclically through the state information.  (Yes, this does mean we
 * could get away with just one pointer, but the code for random() is more
 * efficient this way).  The pointers are left positioned as they would be
 * from the call
 *
 *	initstate(1, randtbl, 128);
 *
 * (The position of the rear pointer, rptr, is really 0 (as explained above
 * in the initialization of randtbl) because the state table pointer is set
 * to point to randtbl[1] (as explained below).
 */
static int32_t *fptr = &randtbl[SEP_3 + 1];
static int32_t *rptr = &randtbl[1];

/*
 * The following things are the pointer to the state information table, the
 * type of the current generator, the degree of the current polynomial being
 * used, and the separation between the two pointers.  Note that for efficiency
 * of random(), we remember the first location of the state information, not
 * the zeroeth.  Hence it is valid to access state[-1], which is used to
 * store the type of the R.N.G.  Also, we remember the last location, since
 * this is more efficient than indexing every time to find the address of
 * the last element to see if the front and rear pointers have wrapped.
 */
static int32_t *state = &randtbl[1];
static int32_t *end_ptr = &randtbl[DEG_3 + 1];
static int rand_type = TYPE_3;
static int rand_deg = DEG_3;
static int rand_sep = SEP_3;

static int random_deterministic;

static void *random_mutex;
static long random_l(void);

#define LOCK()		_MUTEX_LOCK(&random_mutex)
#define UNLOCK()	_MUTEX_UNLOCK(&random_mutex)

/*
 * srandom:
 *
 * Initialize the random number generator based on the given seed.  If the
 * type is the trivial no-state-information type, just remember the seed.
 * Otherwise, initializes state[] based on the given "seed" via a linear
 * congruential generator.  Then, the pointers are set to known locations
 * that are exactly rand_sep places apart.  Lastly, it cycles the state
 * information a given number of times to get rid of any initial dependencies
 * introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]
 * for default usage relies on values produced by this routine.
 */
static void
srandom_l(unsigned int x)
{
	int i;
	int32_t test;
	div_t val;

	random_deterministic = 1;
	if (rand_type == TYPE_0)
		state[0] = x;
	else {
		/* A seed of 0 would result in state[] always being zero. */
		state[0] = x ? x : 1;
		for (i = 1; i < rand_deg; i++) {
			/*
			 * Implement the following, without overflowing 31 bits:
			 *
			 *	state[i] = (16807 * state[i - 1]) % 2147483647;
			 *
			 *	2^31-1 (prime) = 2147483647 = 127773*16807+2836
			 */
			val = div(state[i-1], 127773);
			test = 16807 * val.rem - 2836 * val.quot;
			state[i] = test + (test < 0 ? 2147483647 : 0);
		}
		fptr = &state[rand_sep];
		rptr = &state[0];
		for (i = 0; i < 10 * rand_deg; i++)
			(void)random_l();
	}
}

void
srandom(unsigned int x)
{
	random_deterministic = 0;
}

void
srandomdev(void)
{
	random_deterministic = 0;	/* back to the default */
}

void
srandom_deterministic(unsigned int x)
{
	LOCK();
	srandom_l(x);
	UNLOCK();
}

/*
 * initstate:
 *
 * Initialize the state information in the given array of n bytes for future
 * random number generation.  Based on the number of bytes we are given, and
 * the break values for the different R.N.G.'s, we choose the best (largest)
 * one we can and set things up for it.  srandom() is then called to
 * initialize the state information.
 * 
 * Note that on return from srandom(), we set state[-1] to be the type
 * multiplexed with the current value of the rear pointer; this is so
 * successive calls to initstate() won't lose this information and will be
 * able to restart with setstate().
 * 
 * Note: the first thing we do is save the current state, if any, just like
 * setstate() so that it doesn't matter when initstate is called.
 *
 * Returns a pointer to the old state.
 */
char *
initstate(u_int seed, char *arg_state, size_t n)
{
	char *ostate = (char *)(&state[-1]);

	LOCK();
	random_deterministic = 1;
	if (rand_type == TYPE_0)
		state[-1] = rand_type;
	else
		state[-1] = MAX_TYPES * (rptr - state) + rand_type;
	if (n < BREAK_0) {
		UNLOCK();
		return(NULL);
	}
	if (n < BREAK_1) {
		rand_type = TYPE_0;
		rand_deg = DEG_0;
		rand_sep = SEP_0;
	} else if (n < BREAK_2) {
		rand_type = TYPE_1;
		rand_deg = DEG_1;
		rand_sep = SEP_1;
	} else if (n < BREAK_3) {
		rand_type = TYPE_2;
		rand_deg = DEG_2;
		rand_sep = SEP_2;
	} else if (n < BREAK_4) {
		rand_type = TYPE_3;
		rand_deg = DEG_3;
		rand_sep = SEP_3;
	} else {
		rand_type = TYPE_4;
		rand_deg = DEG_4;
		rand_sep = SEP_4;
	}
	state = &(((int32_t *)arg_state)[1]);	/* first location */
	end_ptr = &state[rand_deg];	/* must set end_ptr before srandom */
	srandom_l(seed);
	if (rand_type == TYPE_0)
		state[-1] = rand_type;
	else
		state[-1] = MAX_TYPES*(rptr - state) + rand_type;
	UNLOCK();
	return(ostate);
}

/*
 * setstate:
 *
 * Restore the state from the given state array.
 *
 * Note: it is important that we also remember the locations of the pointers
 * in the current state information, and restore the locations of the pointers
 * from the old state information.  This is done by multiplexing the pointer
 * location into the zeroeth word of the state information.
 *
 * Note that due to the order in which things are done, it is OK to call
 * setstate() with the same state as the current state.
 *
 * Returns a pointer to the old state information.
 */
char *
setstate(char *arg_state)
{
	int32_t *new_state = (int32_t *)arg_state;
	int32_t type = new_state[0] % MAX_TYPES;
	int32_t rear = new_state[0] / MAX_TYPES;
	char *ostate = (char *)(&state[-1]);

	LOCK();
	random_deterministic = 1;
	if (rand_type == TYPE_0)
		state[-1] = rand_type;
	else
		state[-1] = MAX_TYPES * (rptr - state) + rand_type;
	switch(type) {
	case TYPE_0:
	case TYPE_1:
	case TYPE_2:
	case TYPE_3:
	case TYPE_4:
		rand_type = type;
		rand_deg = degrees[type];
		rand_sep = seps[type];
		break;
	default:
		UNLOCK();
		return(NULL);
	}
	state = &new_state[1];
	if (rand_type != TYPE_0) {
		rptr = &state[rear];
		fptr = &state[(rear + rand_sep) % rand_deg];
	}
	end_ptr = &state[rand_deg];		/* set end_ptr too */
	UNLOCK();
	return(ostate);
}

/*
 * random:
 *
 * If we are using the trivial TYPE_0 R.N.G., just do the old linear
 * congruential bit.  Otherwise, we do our fancy trinomial stuff, which is
 * the same in all the other cases due to all the global variables that have
 * been set up.  The basic operation is to add the number at the rear pointer
 * into the one at the front pointer.  Then both pointers are advanced to
 * the next location cyclically in the table.  The value returned is the sum
 * generated, reduced to 31 bits by throwing away the "least random" low bit.
 *
 * Note: the code takes advantage of the fact that both the front and
 * rear pointers can't wrap on the same call by not testing the rear
 * pointer if the front one has wrapped.
 *
 * Returns a 31-bit random number.
 */
static long
random_l(void)
{
	int32_t i;

	if (random_deterministic == 0)
		return arc4random() & 0x7fffffff;

	if (rand_type == TYPE_0)
		i = state[0] = (state[0] * 1103515245 + 12345) & 0x7fffffff;
	else {
		*fptr += *rptr;
		i = (*fptr >> 1) & 0x7fffffff;	/* chucking least random bit */
		if (++fptr >= end_ptr) {
			fptr = state;
			++rptr;
		} else if (++rptr >= end_ptr)
			rptr = state;
	}
	return((long)i);
}

long
random(void)
{
	long r;
	LOCK();
	r = random_l();
	UNLOCK();
	return r;
}

#if defined(APIWARN)
__warn_references(random,
    "warning: random() may return deterministic values, is that what you want?");
#endif
@


1.29
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.28 2014/12/16 20:51:32 sthen Exp $ */
d178 1
a178 1
_THREAD_PRIVATE_MUTEX(random);
d181 2
a182 2
#define LOCK() _THREAD_PRIVATE_MUTEX_LOCK(random)
#define UNLOCK() _THREAD_PRIVATE_MUTEX_UNLOCK(random)
@


1.28
log
@typo; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.27 2014/12/16 20:42:36 deraadt Exp $ */
a30 3
#include <sys/param.h>
#include <sys/sysctl.h>
#include <sys/time.h>
@


1.27
log
@warn for correct symbol
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.26 2014/12/09 08:00:53 deraadt Exp $ */
d421 1
a421 1
    "warning: random() may return determinstic values, is that what you want?");
@


1.26
log
@improve warnings from rand_r(), rand(), and random()
It may take a few iterations to get the tone right.
previously discussed with millert
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.25 2014/12/08 21:45:20 deraadt Exp $ */
d420 1
a420 1
__warn_references(rand,
@


1.25
log
@Change rand(), random(), drand48(), lrand48(), mrand48(), and srand48()
to returning strong random by default, source from arc4random(3).
Parameters to the seeding functions are ignored, and the subsystems remain
in strong random mode.  If you wish the standardized deterministic mode,
call srand_deterministic(), srandom_determistic(), srand48_deterministic(),
seed48_deterministic() or lcong48_deterministic() instead.
The re-entrant functions rand_r(), erand48(), nrand48(), jrand48() are
unaffected by this change and remain in deterministic mode (for now).

Verified as a good roadmap forward by auditing 8800 pieces of software.
Roughly 60 pieces of software will need adaptation to request the
deterministic mode.

Violates POSIX and C89, which violate best practice in this century.
ok guenther tedu millert
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.24 2014/10/13 20:54:13 chl Exp $ */
d418 5
@


1.24
log
@remove unused variable

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.23 2014/07/13 14:21:14 tedu Exp $ */
d179 1
a179 1
static int use_arc4random;
d206 1
a206 1
	use_arc4random = 0;
d234 1
a234 3
	LOCK();
	srandom_l(x);
	UNLOCK();
d237 5
a241 4
#if defined(APIWARN)
__warn_references(srandom,
    "warning: srandom() seed choices are invariably poor");
#endif
a242 10
/*
 * srandomdev:
 *
 * Many programs choose the seed value in a totally predictable manner.
 * This often causes problems.  We seed the generator using random data.
 * Note that this particular seeding procedure can generate states
 * which are impossible to reproduce by calling srandom() with any
 * value, since the succeeding terms in the state buffer are no longer
 * derived from the LC algorithm applied to a fixed seed.
 */
d244 1
a244 1
srandomdev(void)
d247 1
a247 1
	use_arc4random = 1;
a250 5
#if defined(APIWARN)
__warn_references(srandomdev,
    "warning: srandomdev() usage; consider switching to arc4random()");
#endif

d276 1
a276 1
	use_arc4random = 0;
d341 1
a341 1
	use_arc4random = 0;
d392 1
a392 1
	if (use_arc4random)
a417 5

#if defined(APIWARN)
__warn_references(random,
    "warning: random() isn't random; consider using arc4random()");
#endif
@


1.23
log
@once srandomdev() is called, switch to using arc4random() but mask off the
high bit as required by posix. wouldn't want to break any standards.
idea and ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.22 2014/06/15 05:10:58 deraadt Exp $ */
a256 2
	size_t len;

@


1.22
log
@oops, typo. James Hartley is fast at trying -current
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.21 2014/06/15 01:49:06 deraadt Exp $ */
d179 2
d206 1
d260 1
a260 11
	if (rand_type == TYPE_0)
		len = sizeof(state[0]);
	else
		len = rand_deg * sizeof(state[0]);

	arc4random_buf(state, len);

	if (rand_type != TYPE_0) {
		fptr = &state[rand_sep];
		rptr = &state[0];
	}
d294 1
d359 1
d409 3
@


1.21
log
@In srandomdev(), use arc4random_buf() instead of from the kernel.
discussion with matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.20 2014/06/13 15:35:34 deraadt Exp $ */
d262 1
a262 1
	arc4random_buf(buf, len);
@


1.20
log
@use getentropy; from matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.19 2013/08/01 19:42:08 kettenis Exp $ */
d245 1
a245 2
 * This often causes problems.  We seed the generator using random
 * data from the kernel.
d262 1
a262 1
	getentropy(state, len);
@


1.19
log
@Add linker warnings for rand() and random() and various related functions.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.18 2013/03/15 19:07:53 tedu Exp $ */
a254 1
	int mib[2];
d263 1
a263 3
	mib[0] = CTL_KERN;
	mib[1] = KERN_ARND;
	sysctl(mib, 2, state, &len, NULL, 0);
@


1.18
log
@threadsafe random().
reported by ajacoutot and (much earlier, sorry) by Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.17 2012/06/01 01:01:57 guenther Exp $ */
d236 5
d275 5
d442 5
@


1.17
log
@Improve standards conformance: ecvt(), fcvt(), gcvt(), mktemp(), ttyslot(),
and valloc() are not in the current version, while posix_memalign() mkstemp(),
and mkdtemp() are, and setstate()'s argument has lost a bogus 'const'.

ok millert@@ jmc@@ espie@@ kettenis@@; ports build testing by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.16 2012/03/21 12:36:49 millert Exp $ */
d39 2
d179 6
d197 2
a198 2
void
srandom(unsigned int x)
d224 1
a224 1
			(void)random();
d228 8
d253 1
d267 1
d294 1
d299 2
a300 1
	if (n < BREAK_0)
d302 1
d326 1
a326 1
	srandom(seed);
d331 1
d358 1
d374 1
d383 1
d404 2
a405 2
long
random(void)
d421 10
@


1.16
log
@Fix a bug where random() always returns 0 when srandom() is seeded
with 0.  Use 1 and not 0 as the first element of the state array,
similar to what glibc does.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.15 2005/11/30 07:51:02 otto Exp $ */
d329 1
a329 1
setstate(const char *arg_state)
@


1.15
log
@Use sysctl(KERN_ARND) to get n bytes, instead of just 4 at a time
and remove fallback code. If somebody is dumb enough to make the
sysctl fail using systrace, he deserves what he gets. Saves 7 syscalls
on process startup.
looks good miod@@ ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: random.c,v 1.14 2005/08/08 08:05:37 espie Exp $ */
d199 2
a200 1
		state[0] = x;
@


1.14
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d223 6
a228 6
 * This often causes problems.  We seed the generator using the much more
 * secure arandom(4) interface.  Note that this particular seeding
 * procedure can generate states which are impossible to reproduce by
 * calling srandom() with any value, since the succeeding terms in the
 * state buffer are no longer derived from the LC algorithm applied to
 * a fixed seed.
d233 1
a233 1
	int fd, i, mib[2], n;
d241 3
a243 30
	/*
	 * To get seed data, first try reading from /dev/arandom.
	 * If that fails, try the KERN_ARND sysctl() (one int at a time).
	 * As a last resort, call srandom().
	 */
	if ((fd = open("/dev/arandom", O_RDONLY, 0)) != -1 &&
	    read(fd, (void *) state, len) == (ssize_t) len) {
		close(fd);
	} else {
		if (fd != -1)
			close(fd);
		mib[0] = CTL_KERN;
		mib[1] = KERN_ARND;
		n = len / sizeof(int);
		len = sizeof(int);
		for (i = 0; i < n; i++) {
			if (sysctl(mib, 2, (char *)((int *)state + i), &len,
			    NULL, 0) == -1)
				break;
		}
		if (i != n) {
			struct timeval tv;
			u_int junk;

			/* XXX - this could be better */
			gettimeofday(&tv, NULL);
			srandom(getpid() ^ tv.tv_sec ^ tv.tv_usec ^ junk);
			return;
		}
	}
@


1.13
log
@ansi + de-register

ok otto deraadt
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: random.c,v 1.12 2003/06/02 20:18:38 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char *rcsid = "$OpenBSD: random.c,v 1.11 2003/02/28 21:27:44 millert Exp $";
d193 1
a193 2
srandom(x)
	unsigned int x;
d234 1
a234 1
srandomdev()
d301 1
a301 4
initstate(seed, arg_state, n)
	u_int seed;			/* seed for R.N.G. */
	char *arg_state;		/* pointer to state array */
	size_t n;			/* # bytes of state info */
d358 1
a358 2
setstate(arg_state)
	const char *arg_state;
d409 1
a409 1
random()
@


1.11
log
@Use int32_t, not long since this deals with 32bit quantities.
Inspired by a change in NetBSD and reported by Jan Johansson.
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char *rcsid = "$OpenBSD: random.c,v 1.10 2002/12/06 17:43:34 millert Exp $";
@


1.10
log
@In srandomdev(), if we can't access /dev/arandom, use the sysctl() instead.
We don't want to use the sysctl() by default since we are reading more
than just a few bytes of entropy when setting up the state.
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: random.c,v 1.9 2000/04/04 14:27:00 millert Exp $";
d62 1
a62 1
 * Internally, the state information is treated as an array of longs; the
d65 1
a65 1
 * R.N.G.  Thus, 32 bytes of state information will give 7 longs worth of
d141 1
a141 1
static long randtbl[DEG_3 + 1] = {
d165 2
a166 2
static long *fptr = &randtbl[SEP_3 + 1];
static long *rptr = &randtbl[1];
d178 2
a179 1
static long *state = &randtbl[1];
a182 1
static long *end_ptr = &randtbl[DEG_3 + 1];
d198 1
a198 1
	u_int x;
d200 3
a202 3
	register long int test;
	register int i;
	ldiv_t val;
d216 1
a216 1
			val = ldiv(state[i-1], 127773);
d311 1
a311 1
	register char *ostate = (char *)(&state[-1]);
d340 1
a340 1
	state = &(((long *)arg_state)[1]);	/* first location */
d369 3
a371 3
	register long *new_state = (long *)arg_state;
	register int type = new_state[0] % MAX_TYPES;
	register int rear = new_state[0] / MAX_TYPES;
d420 1
a420 1
	long i;
d433 1
a433 1
	return(i);
@


1.9
log
@Fix the leak for real (that's what I get for hacking when i can't sleep).
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: random.c,v 1.8 2000/04/04 13:38:24 millert Exp $";
d38 2
a39 1
#include <sys/types.h>
d241 1
a241 1
	int fd;
d249 5
a257 6
		struct timeval tv;
		u_int junk;

		/* XXX - this could be better */
		gettimeofday(&tv, NULL);
		srandom(getpid() ^ tv.tv_sec ^ tv.tv_usec ^ junk);
d260 18
a277 1
		return;
@


1.8
log
@Fix an fd leak if the read from /dev/arandom fails.  Pointed out by
Markus Friedl.
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: random.c,v 1.7 2000/04/03 23:23:48 millert Exp $";
d248 4
a251 2
	if ((fd = open("/dev/arandom", O_RDONLY, 0)) == -1 ||
	    read(fd, (void *) state, len) != (ssize_t) len) {
d258 2
a261 2
	if (fd != -1)
		close(fd);
@


1.7
log
@Add srandomdev() from FreeBSD for use by sendmail and others.
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: random.c,v 1.6 1998/02/07 02:16:25 millert Exp $";
d248 2
a249 4
	if ((fd = open("/dev/arandom", O_RDONLY, 0)) != -1 &&
	    read(fd, (void *) state, len) == (ssize_t) len) {
		close(fd);
	} else {
d258 2
@


1.6
log
@More XPG4.2 --
  setstate takes a const parameter
  don't ever spew to stderr, just return NULL
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: random.c,v 1.5 1998/02/06 01:49:08 deraadt Exp $";
d38 3
d43 1
d223 41
@


1.5
log
@size_t n in initstate(); XPG
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: random.c,v 1.4 1996/09/15 09:31:51 tholo Exp $";
d253 2
a254 5
	if (n < BREAK_0) {
		(void)fprintf(stderr,
		    "random: not enough state (%d bytes); ignored.\n", n);
		return(0);
	}
d303 1
a303 1
	char *arg_state;
d325 1
a325 2
		(void)fprintf(stderr,
		    "random: state info corrupted; not changed.\n");
@


1.4
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: random.c,v 1.3 1996/08/19 08:33:46 tholo Exp $";
d245 1
a245 1
	int n;				/* # bytes of state info */
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char *rcsid = "$OpenBSD: random.c,v 1.2 1996/03/30 10:01:47 tholo Exp $";
d196 1
a196 1
	register int i, j;
a201 1
		j = 1;
@


1.2
log
@Substantially improve random number generation by using the largest prime
that fits inside 32 bits as the denominator; take care not to overflow.
Regenerate initial seed after replacing the generator
@
text
@d35 1
a35 2
/*static char *sccsid = "from: @@(#)random.c	5.9 (Berkeley) 2/23/91";*/
static char *rcsid = "$Id: random.c,v 1.1.1.1 1995/10/18 08:42:19 deraadt Exp $";
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static char *rcsid = "$Id: random.c,v 1.3 1993/08/26 00:48:10 jtc Exp $";
d139 6
a144 6
	0x9a319039, 0x32d9c024, 0x9b663182, 0x5da1f342, 0xde3b81e0, 0xdf0a6fb5,
	0xf103bc02, 0x48f340fb, 0x7449e56b, 0xbeb1dbb0, 0xab5c5918, 0x946554fd,
	0x8c2e680f, 0xeb3d799f, 0xb11ee0b7, 0x2d436b86, 0xda672e2a, 0x1588ca88,
	0xe369735d, 0x904f35f7, 0xd7158fd6, 0x6fa6f051, 0x616e6b96, 0xac94efdc,
	0x36413f93, 0xc622c298, 0xf5a42ab8, 0x8a88d77b, 0xf5ad9d0e, 0x8999220b,
	0x27fb47b9,
d196 1
d198 1
d205 12
a216 2
		for (i = 1; i < rand_deg; i++)
			state[i] = 1103515245 * state[i - 1] + 12345;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
