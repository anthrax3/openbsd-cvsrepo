head	1.54;
access;
symbols
	OPENBSD_6_1_BASE:1.54
	OPENBSD_6_0:1.54.0.4
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.52.0.6
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.50.0.4
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.54
date	2015.09.13.08.31.47;	author guenther;	state Exp;
branches;
next	1.53;
commitid	QZ177IcjQzeRxHAC;

1.53
date	2015.09.10.18.53.50;	author bcook;	state Exp;
branches;
next	1.52;
commitid	s8asmmkDjMzxGDUO;

1.52
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	0DYulI8hhujBHMcR;

1.51
date	2015.01.15.06.57.18;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	tyVERtGyihL3aYUT;

1.50
date	2014.07.21.18.13.12;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	2bghmfmb1qGlooAw;

1.49
date	2014.07.20.20.51.13;	author bcook;	state Exp;
branches;
next	1.48;
commitid	99nqJdTNZvoMsFK8;

1.48
date	2014.07.19.00.08.41;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	FxTsJE4zngOJloti;

1.47
date	2014.07.18.02.05.55;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	Po6pVMKYRqxYo64p;

1.46
date	2014.07.17.14.30.41;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	SqgZJb2JkEHM24Cz;

1.45
date	2014.07.16.00.18.54;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	V27e5O1s4TnsN3kx;

1.44
date	2014.07.16.00.15.35;	author bcook;	state Exp;
branches;
next	1.43;
commitid	Q1bgylbEqQg6Ib45;

1.43
date	2014.07.13.09.32.42;	author beck;	state Exp;
branches;
next	1.42;
commitid	8oRhHeyOsGAG4hBw;

1.42
date	2014.07.12.18.57.41;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	95mcXkO7py9NMT1R;

1.41
date	2014.07.12.13.24.54;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	tFieA8IV4MiGXT0e;

1.40
date	2014.07.09.16.52.09;	author bcook;	state Exp;
branches;
next	1.39;
commitid	ggW7ERNnyE8mpp6U;

1.39
date	2014.06.27.21.31.12;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	YPHeryOqEsE88Czp;

1.38
date	2014.06.26.19.23.15;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	rcMFNdxTX9AaaJIi;

1.37
date	2014.06.25.04.22.08;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	On4SEBpkD9iqNbyE;

1.36
date	2014.06.20.00.02.12;	author matthew;	state Exp;
branches;
next	1.35;
commitid	B7g1a5StKzgFuV7s;

1.35
date	2014.06.19.00.13.22;	author matthew;	state Exp;
branches;
next	1.34;
commitid	MuTGMkmPDs1Zo425;

1.34
date	2014.06.17.00.37.07;	author matthew;	state Exp;
branches;
next	1.33;
commitid	bycpAiPvoKkW8vV4;

1.33
date	2014.06.13.18.58.58;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	bNi4hpJRffcCOuHc;

1.32
date	2014.06.13.15.36.37;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	udqec1yMQHNqYfcE;

1.31
date	2014.05.31.10.32.12;	author jca;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.06.16.06.33;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.06.15.37.57;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.06.02.31.45;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.05.04.20.40.08;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.21.20.33.23;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.01.18.34.57;	author markus;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.11.16.59.50;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2012.06.24.18.25.12;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.22.08.23.42;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.15.18.19.06;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.03.18.46.04;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.04.00.50.23;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.16.19.47.43;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.01.00.43.39;	author kurt;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.12.19.58.47;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.30.07.51.02;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.06.14.57.59;	author kjell;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.06.04.54.28;	author kjell;	state Exp;
branches;
next	1.12;

1.12
date	2005.06.04.05.13.13;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.02.11.07.13;	author hshoexer;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.26.21.40.08;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.16.19.07.40;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.11.21.03.10;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.14.17.12.54;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.05.05.05.38;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	99.09.28.01.24.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.06.29.23.54.05;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	98.03.22.19.01.16;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.07.09.01.08.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.12.28.06.33.01;	author dm;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Wrap <stdlib.h> so that calls go direct and the symbols not in the
C standard are all weak.
Apply __{BEGIN,END}_HIDDEN_DECLS to gdtoa{,imp}.h, hiding the
arch-specific __strtorx, __ULtox_D2A, __strtorQ, __ULtoQ_D2A symbols.
@
text
@/*	$OpenBSD: arc4random.c,v 1.53 2015/09/10 18:53:50 bcook Exp $	*/

/*
 * Copyright (c) 1996, David Mazieres <dm@@uun.org>
 * Copyright (c) 2008, Damien Miller <djm@@openbsd.org>
 * Copyright (c) 2013, Markus Friedl <markus@@openbsd.org>
 * Copyright (c) 2014, Theo de Raadt <deraadt@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * ChaCha based random number generator for OpenBSD.
 */

#include <fcntl.h>
#include <limits.h>
#include <signal.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/time.h>

#define KEYSTREAM_ONLY
#include "chacha_private.h"

#define minimum(a, b) ((a) < (b) ? (a) : (b))

#if defined(__GNUC__) || defined(_MSC_VER)
#define inline __inline
#else				/* __GNUC__ || _MSC_VER */
#define inline
#endif				/* !__GNUC__ && !_MSC_VER */

#define KEYSZ	32
#define IVSZ	8
#define BLOCKSZ	64
#define RSBUFSZ	(16*BLOCKSZ)

/* Marked MAP_INHERIT_ZERO, so zero'd out in fork children. */
static struct _rs {
	size_t		rs_have;	/* valid bytes at end of rs_buf */
	size_t		rs_count;	/* bytes till reseed */
} *rs;

/* Maybe be preserved in fork children, if _rs_allocate() decides. */
static struct _rsx {
	chacha_ctx	rs_chacha;	/* chacha context for random keystream */
	u_char		rs_buf[RSBUFSZ];	/* keystream blocks */
} *rsx;

static inline int _rs_allocate(struct _rs **, struct _rsx **);
static inline void _rs_forkdetect(void);
#include "arc4random.h"

static inline void _rs_rekey(u_char *dat, size_t datlen);

static inline void
_rs_init(u_char *buf, size_t n)
{
	if (n < KEYSZ + IVSZ)
		return;

	if (rs == NULL) {
		if (_rs_allocate(&rs, &rsx) == -1)
			abort();
	}

	chacha_keysetup(&rsx->rs_chacha, buf, KEYSZ * 8, 0);
	chacha_ivsetup(&rsx->rs_chacha, buf + KEYSZ);
}

static void
_rs_stir(void)
{
	u_char rnd[KEYSZ + IVSZ];

	if (getentropy(rnd, sizeof rnd) == -1)
		_getentropy_fail();

	if (!rs)
		_rs_init(rnd, sizeof(rnd));
	else
		_rs_rekey(rnd, sizeof(rnd));
	explicit_bzero(rnd, sizeof(rnd));	/* discard source seed */

	/* invalidate rs_buf */
	rs->rs_have = 0;
	memset(rsx->rs_buf, 0, sizeof(rsx->rs_buf));

	rs->rs_count = 1600000;
}

static inline void
_rs_stir_if_needed(size_t len)
{
	_rs_forkdetect();
	if (!rs || rs->rs_count <= len)
		_rs_stir();
	if (rs->rs_count <= len)
		rs->rs_count = 0;
	else
		rs->rs_count -= len;
}

static inline void
_rs_rekey(u_char *dat, size_t datlen)
{
#ifndef KEYSTREAM_ONLY
	memset(rsx->rs_buf, 0, sizeof(rsx->rs_buf));
#endif
	/* fill rs_buf with the keystream */
	chacha_encrypt_bytes(&rsx->rs_chacha, rsx->rs_buf,
	    rsx->rs_buf, sizeof(rsx->rs_buf));
	/* mix in optional user provided data */
	if (dat) {
		size_t i, m;

		m = minimum(datlen, KEYSZ + IVSZ);
		for (i = 0; i < m; i++)
			rsx->rs_buf[i] ^= dat[i];
	}
	/* immediately reinit for backtracking resistance */
	_rs_init(rsx->rs_buf, KEYSZ + IVSZ);
	memset(rsx->rs_buf, 0, KEYSZ + IVSZ);
	rs->rs_have = sizeof(rsx->rs_buf) - KEYSZ - IVSZ;
}

static inline void
_rs_random_buf(void *_buf, size_t n)
{
	u_char *buf = (u_char *)_buf;
	u_char *keystream;
	size_t m;

	_rs_stir_if_needed(n);
	while (n > 0) {
		if (rs->rs_have > 0) {
			m = minimum(n, rs->rs_have);
			keystream = rsx->rs_buf + sizeof(rsx->rs_buf)
			    - rs->rs_have;
			memcpy(buf, keystream, m);
			memset(keystream, 0, m);
			buf += m;
			n -= m;
			rs->rs_have -= m;
		}
		if (rs->rs_have == 0)
			_rs_rekey(NULL, 0);
	}
}

static inline void
_rs_random_u32(uint32_t *val)
{
	u_char *keystream;

	_rs_stir_if_needed(sizeof(*val));
	if (rs->rs_have < sizeof(*val))
		_rs_rekey(NULL, 0);
	keystream = rsx->rs_buf + sizeof(rsx->rs_buf) - rs->rs_have;
	memcpy(val, keystream, sizeof(*val));
	memset(keystream, 0, sizeof(*val));
	rs->rs_have -= sizeof(*val);
}

uint32_t
arc4random(void)
{
	uint32_t val;

	_ARC4_LOCK();
	_rs_random_u32(&val);
	_ARC4_UNLOCK();
	return val;
}
DEF_WEAK(arc4random);

void
arc4random_buf(void *buf, size_t n)
{
	_ARC4_LOCK();
	_rs_random_buf(buf, n);
	_ARC4_UNLOCK();
}
DEF_WEAK(arc4random_buf);
@


1.53
log
@Add support for building arc4random with MSVC.

By default, MSVC's stdlib.h defines min(), so we need to spell out something
less common to avoid picking it up.

ok deraadt@@ beck@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.52 2015/01/16 16:48:51 deraadt Exp $	*/
d189 1
d198 1
@


1.52
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.51 2015/01/15 06:57:18 deraadt Exp $	*/
d39 3
a41 2
#define min(a, b) ((a) < (b) ? (a) : (b))
#ifdef __GNUC__
d43 1
a43 1
#else				/* !__GNUC__ */
d45 1
a45 1
#endif				/* !__GNUC__ */
d131 1
a131 1
		m = min(datlen, KEYSZ + IVSZ);
d151 1
a151 1
			m = min(n, rs->rs_have);
@


1.51
log
@back in september I did the large abstraction refactoring to allow these
other systems to fit into the same mold, so add copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.50 2014/07/21 18:13:12 deraadt Exp $	*/
a33 1
#include <sys/param.h>
@


1.50
log
@missing newline
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.49 2014/07/20 20:51:13 bcook Exp $	*/
d7 1
@


1.49
log
@Move more OS-specific functionality to arc4random.h headers.

Move <sys/mman.h> and raise(SIGKILL) calls to OS-specific headers.
On OpenBSD, move thread_private.h as well to arc4random.h.
On Windows, use TerminateProcess on getentropy failure.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.48 2014/07/19 00:08:41 deraadt Exp $	*/
d168 1
@


1.48
log
@Change _rs_allocate so it can combine the two regions (rs and rsx)
into one if a system has an awesome getentropy().  In that case it
is valid to totally throw away the rsx state in the child.  If the
getentropy() is not very good and has a lazy reseed operation, this
combining is a bad idea, and the reseed should probably continue to
use the "something old, something new" mix.  _rs_allocate() can
accomodate either method, but not on the fly.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.47 2014/07/18 02:05:55 deraadt Exp $	*/
a34 3
#include <sys/mman.h>

#include "thread_private.h"
d90 1
a90 1
		raise(SIGKILL);
@


1.47
log
@Seperate arc4random's os-dependent parts into static inline functions,
making it much easier for libressl -portable to fill in the gaps.
ok bcook beck
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.46 2014/07/17 14:30:41 deraadt Exp $	*/
d60 2
a61 7
static inline void *_rs_allocate(size_t len);
static inline void _rs_forkdetect(void);
static inline void _rs_forkdetectsetup(struct _rs *buf, size_t len);
#include "arc4random.h"

/* Preserved in fork children. */
static struct {
d66 4
d79 1
a79 6
		if ((rs = _rs_allocate(sizeof(*rs))) == NULL)
			abort();
		_rs_forkdetectsetup(rs, sizeof(*rs));
	}
	if (rsx == NULL) {
		if ((rsx = _rs_allocate(sizeof(*rsx))) == NULL)
@


1.46
log
@"Race-free because we're running single-threaded in a new
address space, and once allocated rs is never deallocated."
document the forkhandler to save reviewers time, with matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.45 2014/07/16 00:18:54 deraadt Exp $	*/
d55 1
a55 1
static struct {
d60 5
a72 13
#ifndef MAP_INHERIT_ZERO
static inline void
_rs_forkhandler(void)
{
	/*
	 * Race-free because we're running single-threaded in a new
	 * address space, and once allocated rs is never deallocated.
	 */
	if (rs)
		rs->rs_count = 0;
}
#endif /* MAP_INHERIT_ZERO */

d80 1
a80 2
		if ((rs = mmap(NULL, sizeof(*rs), PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED)
d82 1
a82 6
#ifdef MAP_INHERIT_ZERO
		if (minherit(rs, sizeof(*rs), MAP_INHERIT_ZERO) == -1)
			abort();
#else
		_ARC4_ATFORK(_rs_forkhandler);
#endif
d85 1
a85 2
		if ((rsx = mmap(NULL, sizeof(*rsx), PROT_READ|PROT_WRITE,
		    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED)
d117 1
a117 11
#ifndef MAP_INHERIT_ZERO
	static pid_t _rs_pid = 0;
	pid_t pid = getpid();

	/* If a system lacks MAP_INHERIT_ZERO, resort to getpid() */
	if (_rs_pid == 0 || _rs_pid != pid) {
		_rs_pid = pid;
		if (rs)
			rs->rs_count = 0;
	}
#endif
@


1.45
log
@#ifdef wrap the _rs_forkhandler
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.44 2014/07/16 00:15:35 bcook Exp $	*/
d72 4
@


1.44
log
@added handler for an atfork hook from kettenis@@

ok deraadt@@ beck@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.43 2014/07/13 09:32:42 beck Exp $	*/
d68 1
d75 1
@


1.43
log
@While we thought this would make portable life easier it actually
makes it much harder.
ok bcook@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.42 2014/07/12 18:57:41 deraadt Exp $	*/
d69 7
d88 2
@


1.42
log
@Wrap "thread_private.h" with #ifdef __OpenBSD__ so that other systems
can copy this file (plus chacha_private.h) directly and reuse it
trivially.  Well, as long as they have a getentropy() as well..
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.41 2014/07/12 13:24:54 deraadt Exp $	*/
a36 1
#ifdef __OpenBSD__
a37 1
#endif /* __OpenBSD__ */
@


1.41
log
@Split arc4random_uniform into it's own file, to assist other projects
now using this as upstream code.  The particular problem is systems
that contain older arc4random derivations lacking arc4random_uniform().
ok tedu miod
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.40 2014/07/09 16:52:09 bcook Exp $	*/
d37 1
d39 1
@


1.40
log
@changes to improve portability

ok beck@@ deraadt@@ jsing@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.38 2014/06/26 19:23:15 deraadt Exp $	*/
a212 36
}

/*
 * Calculate a uniformly distributed random number less than upper_bound
 * avoiding "modulo bias".
 *
 * Uniformity is achieved by generating new random numbers until the one
 * returned is outside the range [0, 2**32 % upper_bound).  This
 * guarantees the selected random number will be inside
 * [2**32 % upper_bound, 2**32) which maps back to [0, upper_bound)
 * after reduction modulo upper_bound.
 */
uint32_t
arc4random_uniform(uint32_t upper_bound)
{
	uint32_t r, min;

	if (upper_bound < 2)
		return 0;

	/* 2**32 % x == (2**32 - x) % x */
	min = -upper_bound % upper_bound;

	/*
	 * This could theoretically loop forever but each retry has
	 * p > 0.5 (worst case, usually far better) of selecting a
	 * number inside the range we need, so it should rarely need
	 * to re-roll.
	 */
	for (;;) {
		r = arc4random();
		if (r >= min)
			break;
	}

	return r % upper_bound;
@


1.39
log
@re-init and init code paths are now more shared, so the getpid()-based
portable code path must handle that; with brent cook
@
text
@d28 1
a34 1
#include <sys/sysctl.h>
d42 1
d149 1
a149 1
		m = MIN(datlen, KEYSZ + IVSZ);
d169 1
a169 1
			m = MIN(n, rs->rs_have);
d184 1
a184 1
_rs_random_u32(u_int32_t *val)
d196 1
a196 1
u_int32_t
d199 1
a199 1
	u_int32_t val;
d225 2
a226 2
u_int32_t
arc4random_uniform(u_int32_t upper_bound)
d228 1
a228 1
	u_int32_t r, min;
@


1.38
log
@Add back an #ifndef MAP_INHERIT_ZERO chunk to support the old getpid()
mechanism, to aid in portability to other systems as requested.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.37 2014/06/25 04:22:08 deraadt Exp $	*/
d123 2
a124 1
		rs->rs_count = 0;
@


1.37
log
@document why we explicit_bzero
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.36 2014/06/20 00:02:12 matthew Exp $	*/
d77 1
d80 1
d116 10
@


1.36
log
@arc4random: hard fail with raise(SIGKILL) if getentropy() returns -1

Allow other non-zero return values in case we change our mind to
return an ssize_t byte count instead of simple success/fail.

ok deraadt, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.35 2014/06/19 00:13:22 matthew Exp $	*/
d102 1
a102 1
	explicit_bzero(rnd, sizeof(rnd));
@


1.35
log
@Move rs_chacha and rs_buf into the same memory page and don't mark it
MAP_INHERIT_ZERO anymore.  This restores arc4random's previous
behavior where fork children would mix in some randomness from the
parent process.

New behavior noticed by deraadt
ok deraadt, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.34 2014/06/17 00:37:07 matthew Exp $	*/
d27 1
d95 2
a96 2
	/* XXX */
	(void) getentropy(rnd, sizeof rnd);
@


1.34
log
@Use MAP_INHERIT_ZERO in arc4random(3)

Now instead of calling getpid() each time a user invokes arc4random(),
we're able to rely on the kernel zero'ing out the RNG state if the
process forks.

ok deraadt, djm
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.33 2014/06/13 18:58:58 deraadt Exp $	*/
d52 1
d56 4
d61 2
a62 2
} *rs;
static u_char *rs_buf;		/* keystream blocks */
d74 1
a74 1
		    MAP_ANON, -1, 0)) == MAP_FAILED)
d79 3
a81 5
	if (rs_buf == NULL) {
		if ((rs_buf = mmap(NULL, RSBUFSZ, PROT_READ|PROT_WRITE,
		    MAP_ANON, -1, 0)) == MAP_FAILED)
			abort();
		if (minherit(rs_buf, RSBUFSZ, MAP_INHERIT_ZERO) == -1)
d85 2
a86 2
	chacha_keysetup(&rs->rs_chacha, buf, KEYSZ * 8, 0);
	chacha_ivsetup(&rs->rs_chacha, buf + KEYSZ);
d105 1
a105 1
	memset(rs_buf, 0, RSBUFSZ);
d125 1
a125 1
	memset(rs_buf, 0,RSBUFSZ);
d128 2
a129 1
	chacha_encrypt_bytes(&rs->rs_chacha, rs_buf, rs_buf, RSBUFSZ);
d136 1
a136 1
			rs_buf[i] ^= dat[i];
d139 3
a141 3
	_rs_init(rs_buf, KEYSZ + IVSZ);
	memset(rs_buf, 0, KEYSZ + IVSZ);
	rs->rs_have = RSBUFSZ - KEYSZ - IVSZ;
d148 1
d155 4
a158 2
			memcpy(buf, rs_buf + RSBUFSZ - rs->rs_have, m);
			memset(rs_buf + RSBUFSZ - rs->rs_have, 0, m);
d171 1
d175 3
a177 2
	memcpy(val, rs_buf + RSBUFSZ - rs->rs_have, sizeof(*val));
	memset(rs_buf + RSBUFSZ - rs->rs_have, 0, sizeof(*val));
@


1.33
log
@For now... assume success of getentropy() just like we assumed success
of sysctl().  Mark it with XXX while we consider.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.32 2014/06/13 15:36:37 deraadt Exp $	*/
d51 6
a56 3
static int rs_initialized;
static pid_t rs_stir_pid;
static chacha_ctx *rs;		/* chacha context for random keystream */
a57 2
static size_t rs_have;		/* valid bytes at end of rs_buf */
static size_t rs_count;		/* bytes till reseed */
d67 14
a80 6
	if (rs == NULL && (rs = mmap(NULL, sizeof(*rs), PROT_READ|PROT_WRITE,
	    MAP_ANON, -1, 0)) == MAP_FAILED)
		abort();
	if (rs_buf == NULL && (rs_buf = mmap(NULL, RSBUFSZ, PROT_READ|PROT_WRITE,
	    MAP_ANON, -1, 0)) == MAP_FAILED)
		abort();
d82 2
a83 2
	chacha_keysetup(rs, buf, KEYSZ * 8, 0);
	chacha_ivsetup(rs, buf + KEYSZ);
d94 1
a94 2
	if (!rs_initialized) {
		rs_initialized = 1;
d96 1
a96 1
	} else
d101 1
a101 1
	rs_have = 0;
d104 1
a104 1
	rs_count = 1600000;
d110 1
a110 4
	pid_t pid = getpid();

	if (rs_count <= len || !rs_initialized || rs_stir_pid != pid) {
		rs_stir_pid = pid;
d112 4
a115 2
	} else
		rs_count -= len;
d125 1
a125 1
	chacha_encrypt_bytes(rs, rs_buf, rs_buf, RSBUFSZ);
d137 1
a137 1
	rs_have = RSBUFSZ - KEYSZ - IVSZ;
d148 4
a151 4
		if (rs_have > 0) {
			m = MIN(n, rs_have);
			memcpy(buf, rs_buf + RSBUFSZ - rs_have, m);
			memset(rs_buf + RSBUFSZ - rs_have, 0, m);
d154 1
a154 1
			rs_have -= m;
d156 1
a156 1
		if (rs_have == 0)
d165 1
a165 1
	if (rs_have < sizeof(*val))
d167 3
a169 3
	memcpy(val, rs_buf + RSBUFSZ - rs_have, sizeof(*val));
	memset(rs_buf + RSBUFSZ - rs_have, 0, sizeof(*val));
	rs_have -= sizeof(*val);
@


1.32
log
@use getgentropy() call.  If it fails, things are pretty bad --
call abort().
this direction discussed at length with miod beck tedu matthew etc
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.31 2014/05/31 10:32:12 jca Exp $	*/
d82 2
a83 2
	if (getentropy(rnd, sizeof rnd) == -1)
		abort();
@


1.31
log
@Delete the extraneous "return" statement at the end of a void function.
From Fritjof Bornebusch.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.30 2014/05/06 16:06:33 tedu Exp $	*/
a79 2
	int     mib[2];
	size_t	len;
d82 2
a83 5
	mib[0] = CTL_KERN;
	mib[1] = KERN_ARND;

	len = sizeof(rnd);
	sysctl(mib, 2, rnd, &len, NULL, 0);
@


1.30
log
@missing NULL checks to see if init is needed. found hard way by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.29 2014/05/06 15:37:57 tedu Exp $	*/
a167 1
	return;
@


1.29
log
@clear a stack buffer with explicit_bzero
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.28 2014/05/06 02:31:45 tedu Exp $	*/
d66 1
a66 1
	if ((rs = mmap(NULL, sizeof(*rs), PROT_READ|PROT_WRITE,
d69 1
a69 1
	if ((rs_buf = mmap(NULL, RSBUFSZ, PROT_READ|PROT_WRITE,
@


1.28
log
@move chacha context and buffer out of bss and allow mmap to place them
wherever it decides it would like them. first step. ok deraadt dlg djm
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.27 2014/05/04 20:40:08 deraadt Exp $	*/
d95 1
a95 1
	memset(rnd, 0, sizeof(rnd));
@


1.27
log
@delete useless test code
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.26 2013/10/21 20:33:23 deraadt Exp $	*/
d34 2
d53 2
a54 2
static chacha_ctx rs;		/* chacha context for random keystream */
static u_char rs_buf[RSBUFSZ];	/* keystream blocks */
d65 10
a74 2
	chacha_keysetup(&rs, buf, KEYSZ * 8, 0);
	chacha_ivsetup(&rs, buf + KEYSZ);
d123 1
a123 1
	chacha_encrypt_bytes(&rs, rs_buf, rs_buf, RSBUFSZ);
@


1.26
log
@Remove arc4random_stir() and arc4random_addrandom(), which none should
be using directly.  Well, a few rare people cloned it upstream and it
will take a bit of time for them to learn.
ok various
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.25 2013/10/01 18:34:57 markus Exp $	*/
a214 22

#if 0
/*-------- Test code for i386 --------*/
#include <stdio.h>
#include <machine/pctr.h>
int
main(int argc, char **argv)
{
	const int iter = 1000000;
	int     i;
	pctrval v;

	v = rdtsc();
	for (i = 0; i < iter; i++)
		arc4random();
	v = rdtsc() - v;
	v /= iter;

	printf("%qd cycles\n", v);
	exit(0);
}
#endif
@


1.25
log
@replace rc4 with ChaCha20; inspired by Nick Mathewson's work on libottery;
feedback and ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.23 2012/06/24 18:25:12 matthew Exp $	*/
a158 25
}

void
arc4random_stir(void)
{
	_ARC4_LOCK();
	_rs_stir();
	_ARC4_UNLOCK();
}

void
arc4random_addrandom(u_char *dat, int datlen)
{
	int m;

	_ARC4_LOCK();
	if (!rs_initialized)
		_rs_stir();
	while (datlen > 0) {
		m = MIN(datlen, KEYSZ + IVSZ);
		_rs_rekey(dat, m);
		dat += m;
		datlen -= m;
	}
	_ARC4_UNLOCK();
@


1.24
log
@spacing
@
text
@d6 1
d22 1
a22 9
 * Arc4 random number generator for OpenBSD.
 *
 * This code is derived from section 17.1 of Applied Cryptography,
 * second edition, which describes a stream cipher allegedly
 * compatible with RSA Labs "RC4" cipher (the actual description of
 * which is a trade secret).  The same algorithm is used as a stream
 * cipher called "arcfour" in Tatu Ylonen's ssh package.
 *
 * RC4 is a registered trademark of RSA Laboratories.
d28 1
d36 3
d45 4
a48 6
struct arc4_stream {
	u_int8_t i;
	u_int8_t j;
	u_int8_t s[256];
};

d50 5
a54 5
static struct arc4_stream rs;
static pid_t arc4_stir_pid;
static int arc4_count;

static inline u_int8_t arc4_getbyte(void);
d56 1
a56 10
static inline void
arc4_init(void)
{
	int     n;

	for (n = 0; n < 256; n++)
		rs.s[n] = n;
	rs.i = 0;
	rs.j = 0;
}
d59 1
a59 1
arc4_addrandom(u_char *dat, int datlen)
d61 4
a64 12
	int     n;
	u_int8_t si;

	rs.i--;
	for (n = 0; n < 256; n++) {
		rs.i = (rs.i + 1);
		si = rs.s[rs.i];
		rs.j = (rs.j + si + dat[n % datlen]);
		rs.s[rs.i] = rs.s[rs.j];
		rs.s[rs.j] = si;
	}
	rs.j = rs.i;
d68 1
a68 1
arc4_stir(void)
d70 1
a70 1
	int     i, mib[2];
d72 1
a72 6
	u_char rnd[128];

	if (!rs_initialized) {
		arc4_init();
		rs_initialized = 1;
	}
d80 10
a89 1
	arc4_addrandom(rnd, sizeof(rnd));
d91 1
a91 7
	/*
	 * Discard early keystream, as per recommendations in:
	 * http://www.wisdom.weizmann.ac.il/~itsik/RC4/Papers/Rc4_ksa.ps
	 */
	for (i = 0; i < 256; i++)
		(void)arc4_getbyte();
	arc4_count = 1600000;
d94 2
a95 2
static void
arc4_stir_if_needed(void)
d99 22
a120 3
	if (arc4_count <= 0 || !rs_initialized || arc4_stir_pid != pid) {
		arc4_stir_pid = pid;
		arc4_stir();
d122 4
d128 2
a129 2
static inline u_int8_t
arc4_getbyte(void)
d131 2
a132 1
	u_int8_t si, sj;
d134 13
a146 7
	rs.i = (rs.i + 1);
	si = rs.s[rs.i];
	rs.j = (rs.j + si);
	sj = rs.s[rs.j];
	rs.s[rs.i] = sj;
	rs.s[rs.j] = si;
	return (rs.s[(si + sj) & 0xff]);
d149 2
a150 2
static inline u_int32_t
arc4_getword(void)
d152 7
a158 6
	u_int32_t val;
	val = arc4_getbyte() << 24;
	val |= arc4_getbyte() << 16;
	val |= arc4_getbyte() << 8;
	val |= arc4_getbyte();
	return val;
d165 1
a165 1
	arc4_stir();
d172 2
d176 7
a182 2
		arc4_stir();
	arc4_addrandom(dat, datlen);
d190 1
d192 1
a192 3
	arc4_count -= 4;
	arc4_stir_if_needed();
	val = arc4_getword();
d198 1
a198 1
arc4random_buf(void *_buf, size_t n)
a199 1
	u_char *buf = (u_char *)_buf;
d201 1
a201 6
	arc4_stir_if_needed();
	while (n--) {
		if (--arc4_count <= 0)
			arc4_stir();
		buf[n] = arc4_getbyte();
	}
d259 1
@


1.23
log
@Change arc4random_uniform() to calculate ``2**32 % upper_bound'' as
``-upper_bound % upper_bound''.  Simplifies the code and makes it the
same on both ILP32 and LP64 architectures, and also slightly faster on
LP64 architectures by using a 32-bit remainder instead of a 64-bit
remainder.

Pointed out by Jorden Verwer on tech@@
ok deraadt; no objections from djm or otto
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.22 2010/12/22 08:23:42 otto Exp $	*/
d123 1
a123 2
	if (arc4_count <= 0 || !rs_initialized || arc4_stir_pid != pid)
	{
@


1.22
log
@remove comment that hasn't been true for quite a while now;
ok deraadt@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.21 2009/12/15 18:19:06 guenther Exp $	*/
d217 2
a218 11
#if (ULONG_MAX > 0xffffffffUL)
	min = 0x100000000UL % upper_bound;
#else
	/* Calculate (2**32 % upper_bound) avoiding 64-bit math */
	if (upper_bound > 0x80000000)
		min = 1 + ~upper_bound;		/* 2**32 - upper_bound */
	else {
		/* (2**32 - (x * 2)) % x == 2**32 % x when x <= 2**31 */
		min = ((0xffffffff - (upper_bound * 2)) + 1) % upper_bound;
	}
#endif
@


1.21
log
@No point in refreshing the pid from inside arc4_stir() when that
doesn't test it, so factor out the two places that test it into a
routine and do the refreshing there.  With this, arch4random_buf()
doesn't trigger superfluous calls to getpid() when filling large
buffers.

ok deraadt@@, "looks nicer indeed" otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.20 2008/10/03 18:46:04 otto Exp $	*/
a27 5
 *
 * Here the stream cipher has been modified always to include the time
 * when initializing the state.  That makes it impossible to
 * regenerate the same random sequence twice, so this can't be used
 * for encryption, but will generate good random numbers.
@


1.20
log
@zap __arc4_getbyte(), it was only used by the old malloc; ok millert@@
kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.19 2008/06/04 00:50:23 djm Exp $	*/
a111 1
	arc4_stir_pid = getpid();
d123 12
d184 1
a184 2
	if (arc4_count <= 0 || !rs_initialized || arc4_stir_pid != getpid())
		arc4_stir();
d195 1
a195 2
	if (!rs_initialized || arc4_stir_pid != getpid())
		arc4_stir();
@


1.19
log
@fix math screwup that reintroduced a bias for upper_bounds in range
(2^30,2^31). Nothing in the tree yet requests random numbers bounded
by this range.

report jakob!deraadt; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.18 2008/03/16 19:47:43 otto Exp $	*/
a135 13
}

u_int8_t
__arc4_getbyte(void)
{
	u_int8_t val;

	_ARC4_LOCK();
	if (--arc4_count == 0 || !rs_initialized)
		arc4_stir();
	val = arc4_getbyte();
	_ARC4_UNLOCK();
	return val;
@


1.18
log
@diff from djm@@ committed at his request:

introduce two new APIs for requesting strong random numbers:

arc4random_buf() - fill an arbitrary memory range with random numbers

arc4random_uniform() - return a uniformly distributed random number
below
a specified upper bound, avoiding the bias that comes from a naive
"arc4random() % upper_bound" construction.

these mirror similarly-named functions in the kernel;
lots of discussion deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.17 2008/01/01 00:43:39 kurt Exp $	*/
d234 1
a234 1
		min = ((0xffffffff - (upper_bound << 2)) + 1) % upper_bound;
@


1.17
log
@- make arc4random*() functions thread safe. Use a custom spinlock function
instead of the generic pthread macros since free(3) uses __arc4_getbyte()
when freeing small sized allocations and the generic pthread macros call
malloc(3).
- eliminate passing pointers to a static variable with global scope (rs)
for additional code clarity and reduction.
- shlib minor bumps for libc and libpthread due to new functions.
From andreas@@ with some bits from me. okay tedu@@ marc@@ w/some spot
checking from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.16 2007/02/12 19:58:47 otto Exp $	*/
d5 1
d38 1
d191 60
@


1.16
log
@provide an libc internal interface to get random bytes, to be used by malloc
to get random data without calling getpid(), ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.15 2005/11/30 07:51:02 otto Exp $	*/
d43 1
d62 1
a62 1
static inline u_int8_t arc4_getbyte(struct arc4_stream *);
d65 1
a65 1
arc4_init(struct arc4_stream *as)
d70 3
a72 3
		as->s[n] = n;
	as->i = 0;
	as->j = 0;
d76 1
a76 1
arc4_addrandom(struct arc4_stream *as, u_char *dat, int datlen)
d81 1
a81 1
	as->i--;
d83 5
a87 5
		as->i = (as->i + 1);
		si = as->s[as->i];
		as->j = (as->j + si + dat[n % datlen]);
		as->s[as->i] = as->s[as->j];
		as->s[as->j] = si;
d89 1
a89 1
	as->j = as->i;
d93 1
a93 1
arc4_stir(struct arc4_stream *as)
d99 5
d111 1
a111 1
	arc4_addrandom(as, rnd, sizeof(rnd));
d118 1
a118 1
		(void)arc4_getbyte(as);
d123 1
a123 1
arc4_getbyte(struct arc4_stream *as)
d127 7
a133 7
	as->i = (as->i + 1);
	si = as->s[as->i];
	as->j = (as->j + si);
	sj = as->s[as->j];
	as->s[as->i] = sj;
	as->s[as->j] = si;
	return (as->s[(si + sj) & 0xff]);
d139 3
d143 4
a146 2
		arc4random_stir();
	return arc4_getbyte(&rs);
d150 1
a150 1
arc4_getword(struct arc4_stream *as)
d153 4
a156 4
	val = arc4_getbyte(as) << 24;
	val |= arc4_getbyte(as) << 16;
	val |= arc4_getbyte(as) << 8;
	val |= arc4_getbyte(as);
d163 3
a165 5
	if (!rs_initialized) {
		arc4_init(&rs);
		rs_initialized = 1;
	}
	arc4_stir(&rs);
d171 1
d173 3
a175 2
		arc4random_stir();
	arc4_addrandom(&rs, dat, datlen);
d181 2
d185 4
a188 2
		arc4random_stir();
	return arc4_getword(&rs);
@


1.15
log
@Use sysctl(KERN_ARND) to get n bytes, instead of just 4 at a time
and remove fallback code. If somebody is dumb enough to make the
sysctl fail using systrace, he deserves what he gets. Saves 7 syscalls
on process startup.
looks good miod@@ ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.14 2005/06/06 14:57:59 kjell Exp $	*/
d113 1
a113 1
	arc4_count = 400000;
d130 8
d170 2
a171 1
	if (--arc4_count == 0 || !rs_initialized || arc4_stir_pid != getpid())
@


1.14
log
@Change email address for author, at his request.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.13 2005/06/06 04:54:28 kjell Exp $	*/
d102 1
a102 8
	if (sysctl(mib, 2, rnd, &len, NULL, 0) == -1) {
		for (i = 0; i < sizeof(rnd) / sizeof(u_int); i ++) {
			len = sizeof(u_int);
			if (sysctl(mib, 2, &rnd[i * sizeof(u_int)], &len,
			    NULL, 0) == -1)
				break;
		}
	}
@


1.13
log
@Change license to standard OpenBSD boilerplate, with permission
from original author (David Mazieres)
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.12 2005/06/04 05:13:13 tedu Exp $	*/
d4 1
a4 1
 * Copyright (c) 1996, David Mazieres <dm@@lcs.mit.edu>
@


1.12
log
@use the new fat random sysctl to get initial state. (fallback to looping).
stir after eating 400000 words.  ok + input deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.11 2004/11/02 11:07:13 hshoexer Exp $	*/
d4 5
a8 2
 * Arc4 random number generator for OpenBSD.
 * Copyright 1996 David Mazieres <dm@@lcs.mit.edu>.
d10 7
a16 3
 * Modification and redistribution in source and binary forms is
 * permitted provided that due credit is given to the author and the
 * OpenBSD project by leaving this copyright notice intact.
d20 2
@


1.11
log
@kill spaces

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.10 2003/11/26 21:40:08 djm Exp $	*/
d50 1
d87 1
a87 4
	struct {
		struct timeval tv;
		u_int rnd[(128 - sizeof(struct timeval)) / sizeof(u_int)];
	}       rdat;
a88 1
	gettimeofday(&rdat.tv, NULL);
d92 8
a99 4
	for (i = 0; i < sizeof(rdat.rnd) / sizeof(u_int); i ++) {
		len = sizeof(u_int);
		if (sysctl(mib, 2, &rdat.rnd[i], &len, NULL, 0) == -1)
			break;
d103 1
a103 1
	arc4_addrandom(as, (void *)&rdat, sizeof(rdat));
d111 1
d160 1
a160 1
	if (!rs_initialized || arc4_stir_pid != getpid())
@


1.10
log
@Discard first 256 bytes of keystream, as per recommendation in
"Weaknesses in the Key Scheduling Algorithm of RC4", Fluhrer, Mantin and
Shamir. ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.9 2003/08/16 19:07:40 tedu Exp $	*/
d102 1
a102 1
	arc4_addrandom(as, (void *) &rdat, sizeof(rdat));
d109 1
a109 1
		(void) arc4_getbyte(as);
@


1.9
log
@just use sysctl for stirring.  thread safe and can't fail.
ok deraadt and co.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.8 2003/06/11 21:03:10 deraadt Exp $	*/
d51 2
d103 7
@


1.8
log
@ansification; checked by pval
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.7 2003/02/14 17:12:54 deraadt Exp $	*/
d82 2
a83 1
	int     fd;
d90 7
a96 19
	fd = open("/dev/arandom", O_RDONLY);
	if (fd != -1) {
		read(fd, rdat.rnd, sizeof(rdat.rnd));
		close(fd);
	} else {
		int i, mib[2];
		size_t len;

		/* Device could not be opened, we might be chrooted, take
		 * randomness from sysctl. */

		mib[0] = CTL_KERN;
		mib[1] = KERN_ARND;

		for (i = 0; i < sizeof(rdat.rnd) / sizeof(u_int); i ++) {
			len = sizeof(u_int);
			if (sysctl(mib, 2, &rdat.rnd[i], &len, NULL, 0) == -1)
				break;
		}
a97 2
	/* fd < 0 or failed sysctl ?  Ah, what the heck. We'll just take
	 * whatever was on the stack... */
@


1.7
log
@re-stir if pid changes; markus & me
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.6 2001/06/05 05:05:38 pvalchev Exp $	*/
d52 1
a52 2
arc4_init(as)
	struct arc4_stream *as;
d63 1
a63 4
arc4_addrandom(as, dat, datlen)
	struct arc4_stream *as;
	u_char *dat;
	int     datlen;
d80 1
a80 2
arc4_stir(as)
	struct arc4_stream *as;
d117 1
a117 2
arc4_getbyte(as)
	struct arc4_stream *as;
d131 1
a131 2
arc4_getword(as)
	struct arc4_stream *as;
d142 1
a142 1
arc4random_stir()
d152 1
a152 3
arc4random_addrandom(dat, datlen)
	u_char *dat;
	int     datlen;
d160 1
a160 1
arc4random()
@


1.6
log
@License clarification from David Mazieres, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.5 1999/09/28 01:24:48 deraadt Exp $	*/
d47 1
a47 1
int     rs_initialized;
d49 1
d117 1
d171 1
a171 1
	if (!rs_initialized)
@


1.5
log
@Set j = i after arc4random key schedule to be more like arc4 stream cipher;
from conversations between various people
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.4 1999/06/29 23:54:05 provos Exp $	*/
d9 1
a9 2
 * OpenBSD project (for instance by leaving this copyright notice
 * intact).
@


1.4
log
@if /dev/arandom is not available for seeding, use data from sysctl
kern.arandom.
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.3 1998/03/22 19:01:16 niklas Exp $	*/
d80 1
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: arc4random.c,v 1.2 1997/07/09 01:08:16 millert Exp $	*/
d32 1
d34 1
d89 1
a89 1
		u_int8_t rnd[128 - sizeof(struct timeval)];
d94 1
a94 1
	if (fd >= 0) {
d97 15
d113 2
a114 2
	/* fd < 0?  Ah, what the heck. We'll just take whatever was on the
	 * stack... */
@


1.2
log
@Clean up some -Wall flowers.
@
text
@d1 1
a1 1
/* $Id: arc4random.c,v 1.1 1996/12/28 06:33:01 dm Exp $ */
@


1.1
log
@arc4random() number generator, for use with things like RPC xid's.
@
text
@d1 1
a1 1
/* $Id$ */
d28 1
d30 1
a30 1
#include <fcntl.h>
@
