head	1.57;
access;
symbols
	OPENBSD_6_0:1.56.0.2
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.53.0.4
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.18
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.16
	OPENBSD_5_0:1.24.0.14
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.12
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.10
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.6
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.6
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.6
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.57
date	2016.08.26.08.25.02;	author guenther;	state Exp;
branches;
next	1.56;
commitid	soIWsnqpwqzKvuqy;

1.56
date	2016.06.26.21.04.08;	author tedu;	state Exp;
branches;
next	1.55;
commitid	PHYNvj6tZTZppCu5;

1.55
date	2015.09.13.15.33.48;	author guenther;	state Exp;
branches;
next	1.54;
commitid	zxB6o2cNPYznqLwP;

1.54
date	2015.09.13.12.42.39;	author millert;	state Exp;
branches;
next	1.53;
commitid	Cq3vItq0EWYVdJDn;

1.53
date	2015.07.18.00.56.37;	author tedu;	state Exp;
branches;
next	1.52;
commitid	uDDTiJuP3LiHZt6Q;

1.52
date	2015.01.28.23.33.52;	author tedu;	state Exp;
branches;
next	1.51;
commitid	3J8hkFaME1kltL5o;

1.51
date	2015.01.12.03.20.04;	author tedu;	state Exp;
branches;
next	1.50;
commitid	hRrkKecgVFC5qxn4;

1.50
date	2015.01.07.16.05.28;	author tedu;	state Exp;
branches;
next	1.49;
commitid	IQqF8xlcQUCiOkRY;

1.49
date	2015.01.07.15.46.23;	author tedu;	state Exp;
branches;
next	1.48;
commitid	BmUkXG2RHuwyHKCo;

1.48
date	2015.01.05.13.10.10;	author tedu;	state Exp;
branches;
next	1.47;
commitid	vq8WyaZcQYAVTonh;

1.47
date	2014.12.30.10.27.24;	author tedu;	state Exp;
branches;
next	1.46;
commitid	4gbIoNOMzvJiT9mX;

1.46
date	2014.11.24.22.47.01;	author tedu;	state Exp;
branches;
next	1.45;
commitid	e7jkybsjSTd8iWGQ;

1.45
date	2014.07.20.04.22.34;	author guenther;	state Exp;
branches;
next	1.44;
commitid	x7aBoxPF8nZvW5Z0;

1.44
date	2014.05.17.15.18.06;	author chl;	state Exp;
branches;
next	1.43;

1.43
date	2014.05.06.15.59.24;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.06.15.38.49;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2014.05.03.17.12.53;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2014.05.03.16.33.35;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.19.15.19.20;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2014.04.19.15.17.59;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2014.04.08.20.14.25;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2014.03.24.00.00.29;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2014.03.23.23.27.52;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.23.23.25.05;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.23.23.20.12;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.03.23.23.19.21;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2014.03.22.23.02.03;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.03.19.02.43.03;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.02.24.19.45.43;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2014.02.17.09.00.20;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.02.17.08.58.50;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2013.12.19.14.31.07;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2012.09.04.22.16.17;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2008.04.02.19.54.05;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.19.05.18.32;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.20.01.44.16;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.04.19.06.00;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.03.19.55.49;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.22.17.33.25;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.07.00.28.45;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.25.21.16.47;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.21;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.04.21.45.30;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.02.15.09.41;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	98.08.10.18.33.07;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	98.02.18.16.10.53;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	97.09.10.23.15.42;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.25.20.29.59;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.20.58.26;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.07.09.01.08.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.01.20.12.43;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.04.30.05.57.04;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	97.03.27.01.09.38;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	97.02.16.20.58.15;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.02.14.18.40.14;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	97.02.13.16.31.16;	author provos;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Pull in <time.h> for clock_gettime()

ok deraadt@@
@
text
@/*	$OpenBSD: bcrypt.c,v 1.56 2016/06/26 21:04:08 tedu Exp $	*/

/*
 * Copyright (c) 2014 Ted Unangst <tedu@@openbsd.org>
 * Copyright (c) 1997 Niels Provos <provos@@umich.edu>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/* This password hashing algorithm was designed by David Mazieres
 * <dm@@lcs.mit.edu> and works as follows:
 *
 * 1. state := InitState ()
 * 2. state := ExpandKey (state, salt, password)
 * 3. REPEAT rounds:
 *      state := ExpandKey (state, 0, password)
 *	state := ExpandKey (state, 0, salt)
 * 4. ctext := "OrpheanBeholderScryDoubt"
 * 5. REPEAT 64:
 * 	ctext := Encrypt_ECB (state, ctext);
 * 6. RETURN Concatenate (salt, ctext);
 *
 */

#include <sys/types.h>
#include <blf.h>
#include <ctype.h>
#include <errno.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* This implementation is adaptable to current computing power.
 * You can have up to 2^31 rounds which should be enough for some
 * time to come.
 */

#define BCRYPT_VERSION '2'
#define BCRYPT_MAXSALT 16	/* Precomputation is just so nice */
#define BCRYPT_WORDS 6		/* Ciphertext words */
#define BCRYPT_MINLOGROUNDS 4	/* we have log2(rounds) in salt */

#define	BCRYPT_SALTSPACE	(7 + (BCRYPT_MAXSALT * 4 + 2) / 3 + 1)
#define	BCRYPT_HASHSPACE	61

char   *bcrypt_gensalt(u_int8_t);

static int encode_base64(char *, const u_int8_t *, size_t);
static int decode_base64(u_int8_t *, size_t, const char *);

/*
 * Generates a salt for this version of crypt.
 */
static int
bcrypt_initsalt(int log_rounds, uint8_t *salt, size_t saltbuflen)
{
	uint8_t csalt[BCRYPT_MAXSALT];

	if (saltbuflen < BCRYPT_SALTSPACE) {
		errno = EINVAL;
		return -1;
	}

	arc4random_buf(csalt, sizeof(csalt));

	if (log_rounds < 4)
		log_rounds = 4;
	else if (log_rounds > 31)
		log_rounds = 31;

	snprintf(salt, saltbuflen, "$2b$%2.2u$", log_rounds);
	encode_base64(salt + 7, csalt, sizeof(csalt));

	return 0;
}

/*
 * the core bcrypt function
 */
static int
bcrypt_hashpass(const char *key, const char *salt, char *encrypted,
    size_t encryptedlen)
{
	blf_ctx state;
	u_int32_t rounds, i, k;
	u_int16_t j;
	size_t key_len;
	u_int8_t salt_len, logr, minor;
	u_int8_t ciphertext[4 * BCRYPT_WORDS] = "OrpheanBeholderScryDoubt";
	u_int8_t csalt[BCRYPT_MAXSALT];
	u_int32_t cdata[BCRYPT_WORDS];

	if (encryptedlen < BCRYPT_HASHSPACE)
		goto inval;

	/* Check and discard "$" identifier */
	if (salt[0] != '$')
		goto inval;
	salt += 1;

	if (salt[0] != BCRYPT_VERSION)
		goto inval;

	/* Check for minor versions */
	switch ((minor = salt[1])) {
	case 'a':
		key_len = (u_int8_t)(strlen(key) + 1);
		break;
	case 'b':
		/* strlen() returns a size_t, but the function calls
		 * below result in implicit casts to a narrower integer
		 * type, so cap key_len at the actual maximum supported
		 * length here to avoid integer wraparound */
		key_len = strlen(key);
		if (key_len > 72)
			key_len = 72;
		key_len++; /* include the NUL */
		break;
	default:
		 goto inval;
	}
	if (salt[2] != '$')
		goto inval;
	/* Discard version + "$" identifier */
	salt += 3;

	/* Check and parse num rounds */
	if (!isdigit((unsigned char)salt[0]) ||
	    !isdigit((unsigned char)salt[1]) || salt[2] != '$')
		goto inval;
	logr = (salt[1] - '0') + ((salt[0] - '0') * 10);
	if (logr < BCRYPT_MINLOGROUNDS || logr > 31)
		goto inval;
	/* Computer power doesn't increase linearly, 2^x should be fine */
	rounds = 1U << logr;

	/* Discard num rounds + "$" identifier */
	salt += 3;

	if (strlen(salt) * 3 / 4 < BCRYPT_MAXSALT)
		goto inval;

	/* We dont want the base64 salt but the raw data */
	if (decode_base64(csalt, BCRYPT_MAXSALT, salt))
		goto inval;
	salt_len = BCRYPT_MAXSALT;

	/* Setting up S-Boxes and Subkeys */
	Blowfish_initstate(&state);
	Blowfish_expandstate(&state, csalt, salt_len,
	    (u_int8_t *) key, key_len);
	for (k = 0; k < rounds; k++) {
		Blowfish_expand0state(&state, (u_int8_t *) key, key_len);
		Blowfish_expand0state(&state, csalt, salt_len);
	}

	/* This can be precomputed later */
	j = 0;
	for (i = 0; i < BCRYPT_WORDS; i++)
		cdata[i] = Blowfish_stream2word(ciphertext, 4 * BCRYPT_WORDS, &j);

	/* Now do the encryption */
	for (k = 0; k < 64; k++)
		blf_enc(&state, cdata, BCRYPT_WORDS / 2);

	for (i = 0; i < BCRYPT_WORDS; i++) {
		ciphertext[4 * i + 3] = cdata[i] & 0xff;
		cdata[i] = cdata[i] >> 8;
		ciphertext[4 * i + 2] = cdata[i] & 0xff;
		cdata[i] = cdata[i] >> 8;
		ciphertext[4 * i + 1] = cdata[i] & 0xff;
		cdata[i] = cdata[i] >> 8;
		ciphertext[4 * i + 0] = cdata[i] & 0xff;
	}


	snprintf(encrypted, 8, "$2%c$%2.2u$", minor, logr);
	encode_base64(encrypted + 7, csalt, BCRYPT_MAXSALT);
	encode_base64(encrypted + 7 + 22, ciphertext, 4 * BCRYPT_WORDS - 1);
	explicit_bzero(&state, sizeof(state));
	explicit_bzero(ciphertext, sizeof(ciphertext));
	explicit_bzero(csalt, sizeof(csalt));
	explicit_bzero(cdata, sizeof(cdata));
	return 0;

inval:
	errno = EINVAL;
	return -1;
}

/*
 * user friendly functions
 */
int
bcrypt_newhash(const char *pass, int log_rounds, char *hash, size_t hashlen)
{
	char salt[BCRYPT_SALTSPACE];

	if (bcrypt_initsalt(log_rounds, salt, sizeof(salt)) != 0)
		return -1;

	if (bcrypt_hashpass(pass, salt, hash, hashlen) != 0)
		return -1;

	explicit_bzero(salt, sizeof(salt));
	return 0;
}
DEF_WEAK(bcrypt_newhash);

int
bcrypt_checkpass(const char *pass, const char *goodhash)
{
	char hash[BCRYPT_HASHSPACE];

	if (bcrypt_hashpass(pass, goodhash, hash, sizeof(hash)) != 0)
		return -1;
	if (strlen(hash) != strlen(goodhash) ||
	    timingsafe_bcmp(hash, goodhash, strlen(goodhash)) != 0) {
		errno = EACCES;
		return -1;
	}

	explicit_bzero(hash, sizeof(hash));
	return 0;
}
DEF_WEAK(bcrypt_checkpass);

/*
 * Measure this system's performance by measuring the time for 8 rounds.
 * We are aiming for something that takes around 0.1s, but not too much over.
 */
int
_bcrypt_autorounds(void)
{
	struct timespec before, after;
	int r = 8;
	char buf[_PASSWORD_LEN];
	int duration;

	clock_gettime(CLOCK_THREAD_CPUTIME_ID, &before);
	bcrypt_newhash("testpassword", r, buf, sizeof(buf));
	clock_gettime(CLOCK_THREAD_CPUTIME_ID, &after);

	duration = after.tv_sec - before.tv_sec;
	duration *= 1000000;
	duration += (after.tv_nsec - before.tv_nsec) / 1000;

	/* too quick? slow it down. */
	while (r < 16 && duration <= 60000) {
		r += 1;
		duration *= 2;
	}
	/* too slow? speed it up. */
	while (r > 6 && duration > 120000) {
		r -= 1;
		duration /= 2;
	}

	return r;
}

/*
 * internal utilities
 */
static const u_int8_t Base64Code[] =
"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

static const u_int8_t index_64[128] = {
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 0, 1, 54, 55,
	56, 57, 58, 59, 60, 61, 62, 63, 255, 255,
	255, 255, 255, 255, 255, 2, 3, 4, 5, 6,
	7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
	17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
	255, 255, 255, 255, 255, 255, 28, 29, 30,
	31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
	51, 52, 53, 255, 255, 255, 255, 255
};
#define CHAR64(c)  ( (c) > 127 ? 255 : index_64[(c)])

/*
 * read buflen (after decoding) bytes of data from b64data
 */
static int
decode_base64(u_int8_t *buffer, size_t len, const char *b64data)
{
	u_int8_t *bp = buffer;
	const u_int8_t *p = b64data;
	u_int8_t c1, c2, c3, c4;

	while (bp < buffer + len) {
		c1 = CHAR64(*p);
		/* Invalid data */
		if (c1 == 255)
			return -1;

		c2 = CHAR64(*(p + 1));
		if (c2 == 255)
			return -1;

		*bp++ = (c1 << 2) | ((c2 & 0x30) >> 4);
		if (bp >= buffer + len)
			break;

		c3 = CHAR64(*(p + 2));
		if (c3 == 255)
			return -1;

		*bp++ = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2);
		if (bp >= buffer + len)
			break;

		c4 = CHAR64(*(p + 3));
		if (c4 == 255)
			return -1;
		*bp++ = ((c3 & 0x03) << 6) | c4;

		p += 4;
	}
	return 0;
}

/*
 * Turn len bytes of data into base64 encoded data.
 * This works without = padding.
 */
static int
encode_base64(char *b64buffer, const u_int8_t *data, size_t len)
{
	u_int8_t *bp = b64buffer;
	const u_int8_t *p = data;
	u_int8_t c1, c2;

	while (p < data + len) {
		c1 = *p++;
		*bp++ = Base64Code[(c1 >> 2)];
		c1 = (c1 & 0x03) << 4;
		if (p >= data + len) {
			*bp++ = Base64Code[c1];
			break;
		}
		c2 = *p++;
		c1 |= (c2 >> 4) & 0x0f;
		*bp++ = Base64Code[c1];
		c1 = (c2 & 0x0f) << 2;
		if (p >= data + len) {
			*bp++ = Base64Code[c1];
			break;
		}
		c2 = *p++;
		c1 |= (c2 >> 6) & 0x03;
		*bp++ = Base64Code[c1];
		*bp++ = Base64Code[c2 & 0x3f];
	}
	*bp = '\0';
	return 0;
}

/*
 * classic interface
 */
char *
bcrypt_gensalt(u_int8_t log_rounds)
{
	static char    gsalt[BCRYPT_SALTSPACE];

	bcrypt_initsalt(log_rounds, gsalt, sizeof(gsalt));

	return gsalt;
}

char *
bcrypt(const char *pass, const char *salt)
{
	static char    gencrypted[BCRYPT_HASHSPACE];

	if (bcrypt_hashpass(pass, salt, gencrypted, sizeof(gencrypted)) != 0)
		return NULL;

	return gencrypted;
}
DEF_WEAK(bcrypt);
@


1.56
log
@increase the minimum for auto rounds to 6. that was the previous low bound
for login.conf, and we don't want to go lower.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.55 2015/09/13 15:33:48 guenther Exp $	*/
d42 1
@


1.55
log
@Wrap <pwd.h> so that calls go direct and the symbols are all weak.
Hide bcrypt_autorounds(), prefixing with an underbar for static builds.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.54 2015/09/13 12:42:39 millert Exp $	*/
d264 1
a264 1
	while (r > 4 && duration > 120000) {
@


1.54
log
@The number of rounds is just two digits in the salt.  We've already
verified that they are there via isdigit() so we can convert from
ASCII to an int without using atoi().  OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.53 2015/07/18 00:56:37 tedu Exp $	*/
d218 1
d236 1
d243 1
a243 1
bcrypt_autorounds(void)
d396 1
@


1.53
log
@standards compliant error return (null). will make ruby happier, at least.
ok deraadt jeremy
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.52 2015/01/28 23:33:52 tedu Exp $	*/
d141 1
a141 1
	logr = atoi(salt);
@


1.52
log
@dial the time back to about 0.1s, closer to the original targets and
friendlier for users. requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.51 2015/01/12 03:20:04 tedu Exp $	*/
a387 1
	static char    gerror[2];
a388 2
	/* How do I handle errors ? Return ':' */
	strlcpy(gerror, ":", sizeof(gerror));
d390 1
a390 1
		return gerror;
@


1.51
log
@rename blocks to words. bcrypt "blocks" are unrelated to blowfish blocks,
nor are they the same size.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.50 2015/01/07 16:05:28 tedu Exp $	*/
d238 1
a238 1
 * We are aiming for something that takes between 0.25 and 0.5 seconds.
d257 1
a257 1
	while (r < 16 && duration <= 1000000 / 4) {
d262 1
a262 1
	while (r > 4 && duration > 1000000 / 2) {
@


1.50
log
@stupid me. need errno.h
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.49 2015/01/07 15:46:23 tedu Exp $	*/
d50 1
a50 1
#define BCRYPT_BLOCKS 6		/* Ciphertext blocks */
d99 1
a99 1
	u_int8_t ciphertext[4 * BCRYPT_BLOCKS] = "OrpheanBeholderScryDoubt";
d101 1
a101 1
	u_int32_t cdata[BCRYPT_BLOCKS];
d169 2
a170 2
	for (i = 0; i < BCRYPT_BLOCKS; i++)
		cdata[i] = Blowfish_stream2word(ciphertext, 4 * BCRYPT_BLOCKS, &j);
d174 1
a174 1
		blf_enc(&state, cdata, BCRYPT_BLOCKS / 2);
d176 1
a176 1
	for (i = 0; i < BCRYPT_BLOCKS; i++) {
d189 1
a189 1
	encode_base64(encrypted + 7 + 22, ciphertext, 4 * BCRYPT_BLOCKS - 1);
@


1.49
log
@set errno = EINVAL for invalid salts and hashes in most functions.
remember to set EACCES in bcrypt_checkpass for hash differences.
the higher level crypt_checkpass function will reset errno to EACCES in
all cases, which is probably the right behavior, but this change gives code
working with the lower level functions the correct errno if they care.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.48 2015/01/05 13:10:10 tedu Exp $	*/
d37 1
@


1.48
log
@convert clock() to clock_gettime() for improved precision (and accuracy?)
guenther suggested using thread time, which actually may improve accuracy
if somebody puts this in a threaded program.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.47 2014/12/30 10:27:24 tedu Exp $	*/
d68 2
a69 1
	if (saltbuflen < BCRYPT_SALTSPACE)
d71 1
d103 1
a103 1
		return -1;
d107 1
a107 1
		return -1;
d111 1
a111 1
		return -1;
d129 1
a129 1
		 return -1;
d132 1
a132 1
		return -1;
d139 1
a139 1
		return -1;
d142 1
a142 1
		return -1;
d150 1
a150 1
		return -1;
d154 1
a154 1
		return -1;
d194 4
d226 2
a227 1
	    timingsafe_bcmp(hash, goodhash, strlen(goodhash)) != 0)
d229 1
@


1.47
log
@copy bcrypt autotune from encrypt(1) and expose via crypt_newhash
ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.46 2014/11/24 22:47:01 tedu Exp $	*/
d234 1
a234 1
	clock_t before, after;
d239 1
a239 1
	before = clock();
d241 1
a241 1
	after = clock();
d243 3
a245 1
	duration = after - before;
d248 1
a248 1
	while (r < 16 && duration <= CLOCKS_PER_SEC / 4) {
d253 1
a253 1
	while (r > 4 && duration > CLOCKS_PER_SEC / 2) {
@


1.46
log
@introduce a hashspace define and check that there's enough space to
write out a hash. also simplify writing out the hash.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.45 2014/07/20 04:22:34 guenther Exp $	*/
d225 32
@


1.45
log
@From ISO/IEC 9899:1999 and 9899:201x,
6.11.5 - Storage-class specifiers:
    The placement of a storage-class specifier other than at the
    beginning of the declaration specifiers in a declaration is
    an obsolescent feature.

Diff from Jean-Philippe Ouellet (jean-philippe (at) ouellet.biz)
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.44 2014/05/17 15:18:06 chl Exp $	*/
d53 1
d100 3
d184 3
a186 11
	i = 0;
	encrypted[i++] = '$';
	encrypted[i++] = BCRYPT_VERSION;
	encrypted[i++] = minor;
	encrypted[i++] = '$';

	snprintf(encrypted + i, 4, "%2.2u$", logr);

	encode_base64(encrypted + i + 3, csalt, BCRYPT_MAXSALT);
	encode_base64(encrypted + strlen(encrypted), ciphertext,
	    4 * BCRYPT_BLOCKS - 1);
d215 1
a215 1
	char hash[_PASSWORD_LEN];
d344 1
a344 1
	static char    gencrypted[_PASSWORD_LEN];
a353 1

@


1.44
log
@Add missing header needed by isdigit().
While there, sort headers.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.43 2014/05/06 15:59:24 tedu Exp $	*/
d234 1
a234 1
const static u_int8_t Base64Code[] =
d237 1
a237 1
const static u_int8_t index_64[128] = {
@


1.43
log
@fix stupid commit
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.42 2014/05/06 15:38:49 tedu Exp $	*/
d34 4
a39 1
#include <sys/types.h>
a40 2
#include <pwd.h>
#include <blf.h>
@


1.42
log
@use explicit_bzero
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.41 2014/05/03 17:12:53 tedu Exp $	*/
d190 4
a193 4
	explicit_bzero(&state, 0, sizeof(state));
	explicit_bzero(ciphertext, 0, sizeof(ciphertext));
	explicit_bzero(csalt, 0, sizeof(csalt));
	explicit_bzero(cdata, 0, sizeof(cdata));
@


1.41
log
@now that 5.5 has been released with compatibility for 2b hashes,
switch to generating them by default. prodded by deraadt and sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.40 2014/05/03 16:33:35 tedu Exp $	*/
d190 4
a193 4
	memset(&state, 0, sizeof(state));
	memset(ciphertext, 0, sizeof(ciphertext));
	memset(csalt, 0, sizeof(csalt));
	memset(cdata, 0, sizeof(cdata));
@


1.40
log
@1. Drop support for no minor. This variant doesn't exist anymore.
2. Pull up the actual minor processing code into the switch that
parses it.
3. atoi is actually simpler than strtonum in this case, but check the
input beforehand so we don't get unexpected results.
4. Slightly more consistent style between various parse and check and
increment operations on salt.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.39 2014/04/19 15:19:20 tedu Exp $	*/
d76 1
a76 1
	snprintf(salt, saltbuflen, "$2a$%2.2u$", log_rounds);
@


1.39
log
@one small tweak to avoid ever going off the end of a string.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.38 2014/04/19 15:17:59 tedu Exp $	*/
a96 1
	char arounds[3];
d98 2
a99 2
	/* Discard "$" identifier */
	if (*salt != '$')
d101 1
a101 1
	salt++;
d103 1
a103 1
	if (*salt != BCRYPT_VERSION)
d107 17
a123 18
	if (salt[1] != '$') {
		 switch (salt[1]) {
		 case 'a':	/* 'ab' should not yield the same as 'abab' */
		 case 'b':	/* cap input length at 72 bytes */
			 minor = salt[1];
			 salt++;
			 if (salt[1] != '$')
				 return -1;
			 break;
		 default:
			 return -1;
		 }
	} else
		 minor = 0;

	/* Discard version + "$" identifier */
	salt += 2;

a124 1
		/* Out of sync with passwd entry */
d126 2
d129 3
a131 2
	memcpy(arounds, salt, sizeof(arounds));
	if (arounds[sizeof(arounds) - 1] != '$')
d133 2
a134 3
	arounds[sizeof(arounds) - 1] = 0;
	logr = strtonum(arounds, BCRYPT_MINLOGROUNDS, 31, NULL);
	if (logr == 0)
a148 12
	if (minor <= 'a')
		key_len = (u_int8_t)(strlen(key) + (minor >= 'a' ? 1 : 0));
	else {
		/* strlen() returns a size_t, but the function calls
		 * below result in implicit casts to a narrower integer
		 * type, so cap key_len at the actual maximum supported
		 * length here to avoid integer wraparound */
		key_len = strlen(key);
		if (key_len > 72)
			key_len = 72;
		key_len++; /* include the NUL */
	}
d182 1
a182 2
	if (minor)
		encrypted[i++] = minor;
@


1.38
log
@improved checking for invalid hashes. from solar designer
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.37 2014/04/08 20:14:25 tedu Exp $	*/
d279 4
d284 1
a284 3

		/* Invalid data */
		if (c1 == 255 || c2 == 255)
@


1.37
log
@use char * for strings, saving casts. add return codes to base64 functions
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.36 2014/03/24 00:00:29 tedu Exp $	*/
d100 2
d104 1
a104 1
	if (*salt > BCRYPT_VERSION) {
a105 1
	}
d114 2
d147 2
a148 1
	decode_base64(csalt, BCRYPT_MAXSALT, salt);
d291 1
a291 1
			break;
d299 1
a299 1
			break;
@


1.36
log
@oops, merge error
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.35 2014/03/23 23:27:52 tedu Exp $	*/
d55 2
a56 2
static void encode_base64(u_int8_t *, u_int8_t *, u_int16_t);
static void decode_base64(u_int8_t *, u_int16_t, u_int8_t *);
d77 1
a77 1
	encode_base64((uint8_t *)salt + 7, csalt, sizeof(csalt));
d144 1
a144 1
	decode_base64(csalt, BCRYPT_MAXSALT, (u_int8_t *) salt);
d197 2
a198 2
	encode_base64((u_int8_t *) encrypted + i + 3, csalt, BCRYPT_MAXSALT);
	encode_base64((u_int8_t *) encrypted + strlen(encrypted), ciphertext,
d263 5
a267 2
static void
decode_base64(u_int8_t *buffer, u_int16_t len, u_int8_t *data)
d270 1
a270 1
	u_int8_t *p = data;
d272 1
d279 1
a279 1
			break;
d300 1
d303 6
a308 2
static void
encode_base64(u_int8_t *buffer, u_int8_t *data, u_int16_t len)
d310 2
a311 2
	u_int8_t *bp = buffer;
	u_int8_t *p = data;
d313 1
d336 1
@


1.35
log
@clear stack variables, suggested by djm
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.34 2014/03/23 23:25:05 tedu Exp $	*/
d76 1
a76 1
	snprintf(salt, 4, "$2a$%2.2u$", log_rounds);
@


1.34
log
@some improvements suggested by djm.
use better constant for salt size.
always copy ":" to gerror, in case somebody is dumb enough to overwrite it
timingsafe_bcmp before somebody whines about strcmp
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.33 2014/03/23 23:20:12 tedu Exp $	*/
d221 1
d235 2
@


1.33
log
@two functions don't need to be exported
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.32 2014/03/23 23:19:21 tedu Exp $	*/
d231 2
a232 1
	if (strcmp(hash, goodhash) != 0)
d331 1
a331 1
	static char    gsalt[7 + (BCRYPT_MAXSALT * 4 + 2) / 3 + 1];
d342 1
a342 1
	static char    gerror[] = ":";
d345 1
@


1.32
log
@minimal change to implementation of bcrypt to not require static globals.
add some friendlier functions.
move the classic static data api into wrapper functions.
a few more changes to come...
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.31 2014/03/22 23:02:03 tedu Exp $	*/
d61 1
a61 1
int
d85 1
a85 1
int
@


1.31
log
@switch to shorter ISC license. this was ok with Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.30 2014/03/19 02:43:03 tedu Exp $	*/
d4 1
d51 2
a54 1
static void encode_salt(char *, u_int8_t *, u_int16_t, u_int8_t);
d58 5
a62 6
static char    encrypted[_PASSWORD_LEN];
static char    gsalt[7 + (BCRYPT_MAXSALT * 4 + 2) / 3 + 1];
static char    error[] = ":";

static void
encode_salt(char *salt, u_int8_t *csalt, u_int16_t clen, u_int8_t logr)
d64 1
a64 6
	salt[0] = '$';
	salt[1] = BCRYPT_VERSION;
	salt[2] = 'a';
	salt[3] = '$';

	snprintf(salt + 4, 4, "%2.2u$", logr);
d66 2
a67 11
	encode_base64((u_int8_t *) salt + 7, csalt, clen);
}
/* Generates a salt for this version of crypt.
   Since versions may change. Keeping this here
   seems sensible.
 */

char *
bcrypt_gensalt(u_int8_t log_rounds)
{
	u_int8_t csalt[BCRYPT_MAXSALT];
d76 4
a79 2
	encode_salt(gsalt, csalt, BCRYPT_MAXSALT, log_rounds);
	return gsalt;
a80 2
/* We handle $Vers$log2(NumRounds)$salt+passwd$
   i.e. $2$04$iwouldntknowwhattosayetKdJ6iFtacBqJdKe6aW7ou */
d82 6
a87 2
char   *
bcrypt(const char *key, const char *salt)
d103 1
a103 2
		/* How do I handle errors ? Return ':' */
		return error;
d115 1
a115 1
			 return error;
d125 1
a125 1
		return error;
d129 1
a129 1
		return error;
d133 1
a133 1
		return error;
d141 1
a141 1
		return error;
d204 30
a233 1
	return encrypted;
d236 3
d323 27
@


1.30
log
@consolidate the base64 code in one place, and remove inadequate test code
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.29 2014/02/24 19:45:43 tedu Exp $	*/
d4 1
a4 2
 * Copyright 1997 Niels Provos <provos@@physnet.uni-hamburg.de>
 * All rights reserved.
d6 3
a8 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a17 1

@


1.29
log
@solar's testsuite revealed insufficient validation of invalid input hashes.
add a more complete check for the rounds parameter. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.28 2014/02/17 09:00:20 tedu Exp $	*/
a74 55
const static u_int8_t Base64Code[] =
"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

const static u_int8_t index_64[128] = {
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 0, 1, 54, 55,
	56, 57, 58, 59, 60, 61, 62, 63, 255, 255,
	255, 255, 255, 255, 255, 2, 3, 4, 5, 6,
	7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
	17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
	255, 255, 255, 255, 255, 255, 28, 29, 30,
	31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
	51, 52, 53, 255, 255, 255, 255, 255
};
#define CHAR64(c)  ( (c) > 127 ? 255 : index_64[(c)])

static void
decode_base64(u_int8_t *buffer, u_int16_t len, u_int8_t *data)
{
	u_int8_t *bp = buffer;
	u_int8_t *p = data;
	u_int8_t c1, c2, c3, c4;
	while (bp < buffer + len) {
		c1 = CHAR64(*p);
		c2 = CHAR64(*(p + 1));

		/* Invalid data */
		if (c1 == 255 || c2 == 255)
			break;

		*bp++ = (c1 << 2) | ((c2 & 0x30) >> 4);
		if (bp >= buffer + len)
			break;

		c3 = CHAR64(*(p + 2));
		if (c3 == 255)
			break;

		*bp++ = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2);
		if (bp >= buffer + len)
			break;

		c4 = CHAR64(*(p + 3));
		if (c4 == 255)
			break;
		*bp++ = ((c3 & 0x03) << 6) | c4;

		p += 4;
	}
}

d232 55
a315 30
#if 0
void
main()
{
	char    blubber[73];
	char    salt[100];
	char   *p;
	salt[0] = '$';
	salt[1] = BCRYPT_VERSION;
	salt[2] = '$';

	snprintf(salt + 3, 4, "%2.2u$", 5);

	printf("24 bytes of salt: ");
	fgets(salt + 6, sizeof(salt) - 6, stdin);
	salt[99] = 0;
	printf("72 bytes of password: ");
	fpurge(stdin);
	fgets(blubber, sizeof(blubber), stdin);
	blubber[72] = 0;

	p = crypt(blubber, salt);
	printf("Passwd entry: %s\n\n", p);

	p = bcrypt_gensalt(5);
	printf("Generated salt: %s\n", p);
	p = crypt(blubber, p);
	printf("Passwd entry: %s\n", p);
}
#endif
@


1.28
log
@remove redundant test
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.27 2014/02/17 08:58:50 tedu Exp $	*/
d63 1
a63 1
#define BCRYPT_MINROUNDS 16	/* we have log2(rounds) in salt */
d176 1
a176 1
	int n;
d207 2
a208 3
	/* Computer power doesn't increase linear, 2^x should be fine */
	n = atoi(salt);
	if (n > 31 || n < 0)
d210 3
a212 2
	logr = (u_int8_t)n;
	if ((rounds = (u_int32_t) 1 << logr) < BCRYPT_MINROUNDS)
d214 2
@


1.27
log
@sticking strlen into a char leads to wraparound at 256. fix this and
introduce a new 'b' hash minor. still generate 'a' minors for now.
reported by solar designer. diff by some combination of solar and jca.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.26 2013/12/19 14:31:07 deraadt Exp $	*/
d234 1
a234 2
		if (minor >= 'a')
			key_len++; /* include the NUL */
@


1.26
log
@pseudo-code corrections from Solar Designer <solar@@openwall.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.25 2012/09/04 22:16:17 tedu Exp $	*/
d171 2
a172 1
	u_int8_t key_len, salt_len, logr, minor;
d189 2
a190 2
		 case 'a':
			 /* 'ab' should not yield the same as 'abab' */
d224 13
a236 1
	key_len = strlen(key) + (minor >= 'a' ? 1 : 0);
@


1.25
log
@arc4random_buf is the easy way to fill a buffer now.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.24 2008/04/02 19:54:05 millert Exp $	*/
d37 3
a39 2
 * 2. state := ExpandKey (state, salt, password) 3.
 * REPEAT rounds:
a40 1
 *      state := ExpandKey(state, 0, password)
@


1.24
log
@Zero state buffers on return.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.23 2007/03/19 05:18:32 ray Exp $	*/
a150 2
	u_int16_t i;
	u_int32_t seed = 0;
d152 1
a152 6
	for (i = 0; i < BCRYPT_MAXSALT; i++) {
		if (i % 4 == 0)
			seed = arc4random();
		csalt[i] = seed & 0xff;
		seed = seed >> 8;
	}
@


1.23
log
@Get rid of useless #if 0 block, especially since the code is included
immediately after.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.22 2007/02/20 01:44:16 ray Exp $	*/
d273 4
@


1.22
log
@Change hard coded numbers to sizeof(buf).  Also change some
sizeof(buf) - 1 to sizeof(buf), since fgets takes the whole buffer size.

Based on diff from Charles Longeau <chl at tuxfamily dot org> long ago.

OK millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.21 2006/07/04 19:06:00 otto Exp $	*/
a46 4

#if 0
#include <stdio.h>
#endif
@


1.21
log
@allocate gsalt large enough; from Matthew R. Dempsky <mrd at alkemio
dot org>; ok djm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.20 2006/04/03 19:55:49 deraadt Exp $	*/
d323 1
a323 1
	fgets(salt + 6, 94, stdin);
d327 1
a327 1
	fgets(blubber, 73, stdin);
@


1.20
log
@be more careful with atoi() result; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.19 2004/12/22 17:33:25 otto Exp $	*/
d76 1
a76 1
static char    gsalt[BCRYPT_MAXSALT * 4 / 3 + 1];
@


1.19
log
@Test the upper limit for the max # of rounds to, to avoid wrapping and ending
up with a low number of rounds. Spotted by mpech@@; ok mpech@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.18 2003/08/07 00:28:45 deraadt Exp $	*/
d186 1
d218 2
a219 2
	logr = atoi(salt);
	if (logr > 31)
d221 1
@


1.18
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.17 2003/06/25 21:16:47 deraadt Exp $	*/
d167 2
d217 4
a220 1
	if ((rounds = (u_int32_t) 1 << (logr = atoi(salt))) < BCRYPT_MINROUNDS)
@


1.17
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.16 2002/02/19 19:39:36 millert Exp $	*/
d82 1
a82 2
const static u_int8_t index_64[128] =
{
a173 2
char   *bcrypt(const char *key, const char *salt);

d175 1
a175 3
bcrypt(key, salt)
	const char   *key;
	const char   *salt;
@


1.16
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.15 2002/02/16 21:27:21 millert Exp $	*/
d174 2
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.14 2001/01/04 21:45:30 todd Exp $	*/
a99 1
#ifdef __STDC__
a101 7
#else
static void
decode_base64(buffer, len, data)
	u_int8_t *buffer;
	u_int16_t len;
	u_int8_t *data;
#endif
a134 1
#ifdef __STDC__
a136 8
#else
static void
encode_salt(salt, csalt, clen, logr)
	char   *salt;
	u_int8_t *csalt;
	u_int16_t clen;
	u_int8_t logr;
#endif
a151 1
#ifdef __STDC__
a153 5
#else
char *
bcrypt_gensalt(log_rounds)
	u_int8_t log_rounds;
#endif
a275 1
#ifdef __STDC__
a277 7
#else
static void
encode_base64(buffer, data, len)
	u_int8_t *buffer;
	u_int8_t *data;
	u_int16_t len;
#endif
@


1.14
log
@grammer/spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.13 2000/08/02 15:09:41 provos Exp $	*/
d69 1
a69 1
char   *bcrypt_gensalt __P((u_int8_t));
d71 3
a73 3
static void encode_salt __P((char *, u_int8_t *, u_int16_t, u_int8_t));
static void encode_base64 __P((u_int8_t *, u_int8_t *, u_int16_t));
static void decode_base64 __P((u_int8_t *, u_int16_t, u_int8_t *));
@


1.13
log
@return error if salt is too small; pr 1336
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.12 1998/08/10 18:33:07 provos Exp $	*/
d240 1
a240 1
	/* Computer power doesnt increase linear, 2^x should be fine */
@


1.12
log
@fix base64 encoding, this problem was reported by
Solar Designer <solar@@false.com> some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.11 1998/02/18 16:10:53 provos Exp $	*/
d246 3
@


1.11
log
@#if __STDC__ -> #ifdef __STDC__, now all of them.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.10 1997/09/10 23:15:42 deraadt Exp $	*/
d48 1
a48 1
#ifdef TEST
d292 1
a292 1
	    4 * BCRYPT_BLOCKS);
a313 1
		c2 = *p++;
d318 1
a321 1
		c2 = *p++;
d326 1
d333 1
a333 1
#ifdef TEST
@


1.10
log
@indentation cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.9 1997/07/25 20:29:59 mickey Exp $	*/
d143 1
a143 1
#if __STDC__
d169 1
a169 1
#if __STDC__
d296 1
a296 1
#if __STDC__
@


1.9
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.8 1997/07/23 20:58:26 kstailey Exp $	*/
d221 1
a221 1
		 switch(salt[1]) {
@


1.8
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.7 1997/07/09 01:08:18 millert Exp $	*/
d100 1
a100 1
#if __STDC__
@


1.7
log
@Clean up some -Wall flowers.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcrypt.c,v 1.6 1997/07/01 20:12:43 provos Exp $	*/
d221 1
a221 1
	         switch(salt[1]) {
d223 2
a224 2
		         /* 'ab' should not yield the same as 'abab' */
		         minor = salt[1];
d228 1
a228 1
		         return error;
d231 1
a231 1
	         minor = 0;
d285 1
a285 1
	        encrypted[i++] = minor;
@


1.6
log
@fix that repeating passwords yield same hash + increment minor
@
text
@d1 2
a2 1
/* $OpenBSD: bcrypt.c,v 1.5 1997/04/30 05:57:04 tholo Exp $ */
d52 1
@


1.5
log
@Be more careful about possible type promotion
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt.c,v 1.4 1997/03/27 01:09:38 provos Exp $ */
d155 2
a156 1
	salt[2] = '$';
d158 1
a158 1
	snprintf(salt + 3, 4, "%2.2u$", logr);
d160 1
a160 1
	encode_base64((u_int8_t *) salt + 6, csalt, clen);
d204 1
a204 1
	u_int8_t key_len, salt_len, logr;
d208 1
d216 15
d234 1
a234 1
	if (*(salt + 2) != '$')
d248 1
a248 1
	key_len = strlen(key);
d279 6
a284 3
	encrypted[0] = '$';
	encrypted[1] = BCRYPT_VERSION;
	encrypted[2] = '$';
d286 1
a286 1
	snprintf(encrypted + 3, 4, "%2.2u$", logr);
d288 1
a288 1
	encode_base64((u_int8_t *) encrypted + 6, csalt, BCRYPT_MAXSALT);
@


1.4
log
@yet another random() converted to arc4random()
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt.c,v 1.3 1997/02/16 20:58:15 provos Exp $ */
d98 4
d107 1
d141 4
d151 1
d166 5
a170 1
char   *
d173 1
d197 2
a198 2
	char   *key;
	char   *salt;
d274 4
d283 1
@


1.3
log
@prelim manpage, cleanup, fixed crippled plaintext: sed does a nice
job on replacing everything, just wouldnt skip it
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt.c,v 1.2 1997/02/14 18:40:14 provos Exp $ */
a51 1
#include <time.h>
d163 1
a163 1
	(void) srandom((int) time((time_t *) NULL));
d166 1
a166 1
			seed = random();
@


1.2
log
@header update
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt.c,v 1.1 1997/02/13 16:31:16 provos Exp $ */
d16 1
a16 1
 *      This product includes software developed by Theo de Raadt.
d40 1
a40 1
 * 4. ctext := "OpenBSDbcrypthashfunc"
d190 1
a190 1
	u_int8_t ciphertext[4 * BCRYPT_BLOCKS] = "OpenBSDbcrypthashfunc";
@


1.1
log
@password hashing algorithm using blowfish
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d4 1
d6 24
a29 4
 * Modification and redistribution in source and binary forms is
 * permitted provided that due credit is given to the author and the
 * OpenBSD project (for instance by leaving this copyright notice
 * intact).
@
