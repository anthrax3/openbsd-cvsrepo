head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.50
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.46
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.42
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.44
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.36
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.40
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.38
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.34
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.32
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.30
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.28
	OPENBSD_5_0:1.5.0.26
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.24
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.22
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.18
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.20
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.16
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.14
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.12
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.10
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.8
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.6
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.28
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.26
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.27.17.46.46;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.02.20.18.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.30.38;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.06;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.06;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@/*	$OpenBSD$ */
/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "quad.h"

/*
 * Multiply two quads.
 *
 * Our algorithm is based on the following.  Split incoming quad values
 * u and v (where u,v >= 0) into
 *
 *	u = 2^n u1  *  u0	(n = number of bits in `u_int', usu. 32)
 *
 * and 
 *
 *	v = 2^n v1  *  v0
 *
 * Then
 *
 *	uv = 2^2n u1 v1  +  2^n u1 v0  +  2^n v1 u0  +  u0 v0
 *	   = 2^2n u1 v1  +     2^n (u1 v0 + v1 u0)   +  u0 v0
 *
 * Now add 2^n u1 v1 to the first term and subtract it from the middle,
 * and add 2^n u0 v0 to the last term and subtract it from the middle.
 * This gives:
 *
 *	uv = (2^2n + 2^n) (u1 v1)  +
 *	         (2^n)    (u1 v0 - u1 v1 + u0 v1 - u0 v0)  +
 *	       (2^n + 1)  (u0 v0)
 *
 * Factoring the middle a bit gives us:
 *
 *	uv = (2^2n + 2^n) (u1 v1)  +			[u1v1 = high]
 *		 (2^n)    (u1 - u0) (v0 - v1)  +	[(u1-u0)... = mid]
 *	       (2^n + 1)  (u0 v0)			[u0v0 = low]
 *
 * The terms (u1 v1), (u1 - u0) (v0 - v1), and (u0 v0) can all be done
 * in just half the precision of the original.  (Note that either or both
 * of (u1 - u0) or (v0 - v1) may be negative.)
 *
 * This algorithm is from Knuth vol. 2 (2nd ed), section 4.3.3, p. 278.
 *
 * Since C does not give us a `int * int = quad' operator, we split
 * our input quads into two ints, then split the two ints into two
 * shorts.  We can then calculate `short * short = int' in native
 * arithmetic.
 *
 * Our product should, strictly speaking, be a `long quad', with 128
 * bits, but we are going to discard the upper 64.  In other words,
 * we are not interested in uv, but rather in (uv mod 2^2n).  This
 * makes some of the terms above vanish, and we get:
 *
 *	(2^n)(high) + (2^n)(mid) + (2^n + 1)(low)
 *
 * or
 *
 *	(2^n)(high + mid + low) + low
 *
 * Furthermore, `high' and `mid' can be computed mod 2^n, as any factor
 * of 2^n in either one will also vanish.  Only `low' need be computed
 * mod 2^2n, and only because of the final term above.
 */
static quad_t __lmulq(u_int, u_int);

quad_t
__muldi3(a, b)
	quad_t a, b;
{
	union uu u, v, low, prod;
	u_int high, mid, udiff, vdiff;
	int negall, negmid;
#define	u1	u.ul[H]
#define	u0	u.ul[L]
#define	v1	v.ul[H]
#define	v0	v.ul[L]

	/*
	 * Get u and v such that u, v >= 0.  When this is finished,
	 * u1, u0, v1, and v0 will be directly accessible through the
	 * int fields.
	 */
	if (a >= 0)
		u.q = a, negall = 0;
	else
		u.q = -a, negall = 1;
	if (b >= 0)
		v.q = b;
	else
		v.q = -b, negall ^= 1;

	if (u1 == 0 && v1 == 0) {
		/*
		 * An (I hope) important optimization occurs when u1 and v1
		 * are both 0.  This should be common since most numbers
		 * are small.  Here the product is just u0*v0.
		 */
		prod.q = __lmulq(u0, v0);
	} else {
		/*
		 * Compute the three intermediate products, remembering
		 * whether the middle term is negative.  We can discard
		 * any upper bits in high and mid, so we can use native
		 * u_int * u_int => u_int arithmetic.
		 */
		low.q = __lmulq(u0, v0);

		if (u1 >= u0)
			negmid = 0, udiff = u1 - u0;
		else
			negmid = 1, udiff = u0 - u1;
		if (v0 >= v1)
			vdiff = v0 - v1;
		else
			vdiff = v1 - v0, negmid ^= 1;
		mid = udiff * vdiff;

		high = u1 * v1;

		/*
		 * Assemble the final product.
		 */
		prod.ul[H] = high + (negmid ? -mid : mid) + low.ul[L] +
		    low.ul[H];
		prod.ul[L] = low.ul[L];
	}
	return (negall ? -prod.q : prod.q);
#undef u1
#undef u0
#undef v1
#undef v0
}

/*
 * Multiply two 2N-bit ints to produce a 4N-bit quad, where N is half
 * the number of bits in an int (whatever that is---the code below
 * does not care as long as quad.h does its part of the bargain---but
 * typically N==16).
 *
 * We use the same algorithm from Knuth, but this time the modulo refinement
 * does not apply.  On the other hand, since N is half the size of an int,
 * we can get away with native multiplication---none of our input terms
 * exceeds (UINT_MAX >> 1).
 *
 * Note that, for u_int l, the quad-precision result
 *
 *	l << N
 *
 * splits into high and low ints as HHALF(l) and LHUP(l) respectively.
 */
static quad_t
__lmulq(u_int u, u_int v)
{
	u_int u1, u0, v1, v0, udiff, vdiff, high, mid, low;
	u_int prodh, prodl, was;
	union uu prod;
	int neg;

	u1 = HHALF(u);
	u0 = LHALF(u);
	v1 = HHALF(v);
	v0 = LHALF(v);

	low = u0 * v0;

	/* This is the same small-number optimization as before. */
	if (u1 == 0 && v1 == 0)
		return (low);

	if (u1 >= u0)
		udiff = u1 - u0, neg = 0;
	else
		udiff = u0 - u1, neg = 1;
	if (v0 >= v1)
		vdiff = v0 - v1;
	else
		vdiff = v1 - v0, neg ^= 1;
	mid = udiff * vdiff;

	high = u1 * v1;

	/* prod = (high << 2N) + (high << N); */
	prodh = high + HHALF(high);
	prodl = LHUP(high);

	/* if (neg) prod -= mid << N; else prod += mid << N; */
	if (neg) {
		was = prodl;
		prodl -= LHUP(mid);
		prodh -= HHALF(mid) + (prodl > was);
	} else {
		was = prodl;
		prodl += LHUP(mid);
		prodh += HHALF(mid) + (prodl < was);
	}

	/* prod += low << N */
	was = prodl;
	prodl += LHUP(low);
	prodh += HHALF(low) + (prodl < was);
	/* ... + low; */
	if ((prodl += low) < low)
		prodh++;

	/* return 4N-bit product */
	prod.ul[H] = prodh;
	prod.ul[L] = prodl;
	return (prod.q);
}
@


1.4
log
@A quad is two ints, not two longs. Also fix some problems with
conversions from floating point to quad. Problem reported by Marcus
Holland-Moritz. From NetBSD.

ok millert@@
@
text
@d1 1
a33 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: muldi3.c,v 1.3 2003/06/02 20:18:36 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.3
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: muldi3.c,v 1.2 1996/08/19 08:30:38 tholo Exp $";
d46 1
a46 1
 *	u = 2^n u1  *  u0	(n = number of bits in `u_long', usu. 32)
d77 3
a79 3
 * Since C does not give us a `long * long = quad' operator, we split
 * our input quads into two longs, then split the two longs into two
 * shorts.  We can then calculate `short * short = long' in native
d97 1
a97 1
static quad_t __lmulq(u_long, u_long);
d104 2
a105 2
	register u_long high, mid, udiff, vdiff;
	register int negall, negmid;
d114 1
a114 1
	 * longword fields.
d137 1
a137 1
		 * u_long * u_long => u_long arithmetic.
d168 2
a169 2
 * Multiply two 2N-bit longs to produce a 4N-bit quad, where N is half
 * the number of bits in a long (whatever that is---the code below
d174 1
a174 1
 * does not apply.  On the other hand, since N is half the size of a long,
d176 1
a176 1
 * exceeds (ULONG_MAX >> 1).
d178 1
a178 1
 * Note that, for u_long l, the quad-precision result
d182 1
a182 1
 * splits into high and low longs as HHALF(l) and LHUP(l) respectively.
d185 1
a185 1
__lmulq(u_long u, u_long v)
d187 2
a188 2
	u_long u1, u0, v1, v0, udiff, vdiff, high, mid, low;
	u_long prodh, prodl, was;
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
static char rcsid[] = "$OpenBSD: muldi3.c,v 1.2 1995/02/27 17:30:39 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: muldi3.c,v 1.2 1995/02/27 17:30:39 cgd Exp $	*/

d39 1
a39 5
#if 0
static char sccsid[] = "@@(#)muldi3.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: muldi3.c,v 1.2 1995/02/27 17:30:39 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
