head	1.39;
access;
symbols
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.18
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.16
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.14
	OPENBSD_5_0:1.26.0.12
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.10
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.8
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.4
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.6
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@.\" @;


1.39
date	2016.09.01.10.08.03;	author tedu;	state Exp;
branches;
next	1.38;
commitid	8LqCEzqjppzk7u86;

1.38
date	2016.05.31.19.10.28;	author tedu;	state Exp;
branches;
next	1.37;
commitid	oBqZmAbdCD4tGQ2z;

1.37
date	2016.03.10.08.44.32;	author jmc;	state Exp;
branches;
next	1.36;
commitid	jH93cz7PyB3LZi4h;

1.36
date	2016.03.06.05.29.30;	author guenther;	state Exp;
branches;
next	1.35;
commitid	Kzh87AC1ZF2AkfUL;

1.35
date	2015.12.01.07.50.03;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Rh8AZFtVMVCiwPts;

1.34
date	2015.09.24.23.09.16;	author tedu;	state Exp;
branches;
next	1.33;
commitid	jrcnCfHYL3r8x8gY;

1.33
date	2015.09.10.17.55.21;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	PeV7Ql0T6htfMjhP;

1.32
date	2015.08.02.21.54.21;	author jmc;	state Exp;
branches;
next	1.31;
commitid	Q0R9D4HRbk5nsPfB;

1.31
date	2015.01.25.19.31.38;	author tedu;	state Exp;
branches;
next	1.30;
commitid	LtSRwnCPVdwy7P75;

1.30
date	2014.11.16.18.52.27;	author jmc;	state Exp;
branches;
next	1.29;
commitid	UFpUn0IFQ5t4TKlI;

1.29
date	2014.03.18.22.36.30;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.21.03.15.45;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2013.07.17.05.42.11;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2008.09.16.19.41.06;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.31.19.19.33;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.15.21.12.45;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.09.21.17.13;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.17.20.26.25;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.15.14.07.40;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.14.20.55.59;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.20.21.51.36;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.16.17.47.56;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.16.14.02.47;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.04.19.12.25;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.26.13.31.36;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.26.08.33.57;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.09.22.46.26;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.27.07.55.34;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.10.17.31.59;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.12.14.38.12;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.11.14.36.27;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.18.05.12.11;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.06.29.14.10.14;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.05.27.16.54.23;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	99.05.12.13.26.48;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	99.02.01.08.13.01;	author d;	state Exp;
branches;
next	1.3;

1.3
date	96.10.08.01.20.12;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.03.19.23.15.18;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.28;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.39
log
@remove references to sparc
@
text
@.\"	$OpenBSD: ptrace.2,v 1.38 2016/05/31 19:10:28 tedu Exp $
.\"	$NetBSD: ptrace.2,v 1.3 1996/02/23 01:39:41 jtc Exp $
.\"
.\" This file is in the public domain.
.Dd $Mdocdate: May 31 2016 $
.Dt PTRACE 2
.Os
.Sh NAME
.Nm ptrace
.Nd process tracing and debugging
.Sh SYNOPSIS
.In sys/types.h
.In sys/ptrace.h
.Ft int
.Fn ptrace "int request" "pid_t pid" "caddr_t addr" "int data"
.Sh DESCRIPTION
.Fn ptrace
provides tracing and debugging facilities.
It allows one process (the
.Em tracing
process) to control another (the
.Em traced
process).
Most of the time, the traced process runs normally, but when
it receives a signal
.Po
see
.Xr sigaction 2
.Pc ,
it stops.
The tracing process is expected to notice this via
.Xr wait 2
or the delivery of a
.Dv SIGCHLD
signal, examine the state of the stopped process, and cause it to
terminate or continue as appropriate.
.Fn ptrace
is the mechanism by which all this happens.
.Fn ptrace
is only available on kernels compiled with the
.Cm PTRACE
option.
.Pp
The
.Fa request
argument specifies what operation is being performed; the meaning of
the rest of the arguments depends on the operation, but except for one
special case noted below, all
.Fn ptrace
calls are made by the tracing process, and the
.Fa pid
argument specifies the process ID of the traced process.
.Fa request
can be:
.Bl -tag -width 12n
.It Dv PT_TRACE_ME
This request is the only one used by the traced process; it declares
that the process expects to be traced by its parent.
All the other arguments are ignored.
(If the parent process does not expect to trace the child, it will
probably be rather confused by the results; once the traced process stops,
it cannot be made to continue except via
.Fn ptrace . )
When a process has used this request and calls
.Xr execve 2
or any of the routines built on it
.Po
such as
.Xr execv 3
.Pc ,
it will stop before executing the first instruction of the new image.
Also, any setuid or setgid bits on the executable being executed will
be ignored.
.It Dv PT_READ_I , Dv PT_READ_D
These requests read a single
.Li int
of data from the traced process' address space.
Traditionally,
.Fn ptrace
has allowed for machines with distinct address spaces for instruction
and data, which is why there are two requests: conceptually,
.Dv PT_READ_I
reads from the instruction space and
.Dv PT_READ_D
reads from the data space.
In the current
.Ox
implementation, these two requests operate in the same address space.
The
.Fa addr
argument specifies the address (in the traced process' virtual address
space) at which the read is to be done.
This address does not have to meet any alignment constraints.
The value read is returned as the return value from
.Fn ptrace .
.It Dv PT_WRITE_I , Dv PT_WRITE_D
These requests parallel
.Dv PT_READ_I
and
.Dv PT_READ_D ,
except that they write rather than read.
.Dv PT_WRITE_I
may be necessary to ensure that instruction caches are flushed appropriately.
The
.Fa data
argument supplies the value to be written.
.\" .It Dv PT_READ_U
.\" This request reads an
.\" .Li int
.\" from the traced process' user structure.
.\" The
.\" .Fa addr
.\" argument specifies the location of the int relative to the base of the
.\" user structure; it will usually be an integer value cast to
.\" .Li caddr_t
.\" either explicitly or via the presence of a prototype for
.\" .Fn ptrace .
.\" Unlike
.\" .Dv PT_READ_I
.\" and
.\" .Dv PT_READ_D ,
.\" .Fa addr
.\" must be aligned on an
.\" .Li int
.\" boundary.
.\" The value read is returned as the return value from
.\" .Fn ptrace .
.\" .It Dv PT_WRITE_U
.\" This request writes an
.\" .Li int
.\" into the traced process' user structure.
.\" .Fa addr
.\" specifies the offset, just as for
.\" .Dv PT_READ_U ,
.\" and
.\" .Fa data
.\" specifies the value to be written, just as for
.\" .Dv PT_WRITE_I
.\" and
.\" .Dv PT_WRITE_D .
.It Dv PT_CONTINUE
The traced process continues execution.
.Fa addr
is an address specifying the place where execution is to be resumed (a
new value for the program counter), or
.Li (caddr_t)1
to indicate that execution is to pick up where it left off.
.Fa data
provides a signal number to be delivered to the traced process as it
resumes execution, or 0 if no signal is to be sent.
.It Dv PT_KILL
The traced process terminates, as if
.Dv PT_CONTINUE
had been used with
.Dv SIGKILL
given as the signal to be delivered.
.It Dv PT_ATTACH
This request allows a process to gain control of an otherwise unrelated
process and begin tracing it.
It does not need any cooperation from the to-be-traced process.
In this case,
.Fa pid
specifies the process ID of the to-be-traced process, and the other two
arguments are ignored.
This request requires that the target process must have the same real UID
as the tracing process, and that it must not be executing a set-user-ID
or set-group-ID executable.
Additionally, if the
.Dv kern.global_ptrace
sysctl is 0, then the target process must be a descendant of the tracing
process.
(If the tracing process is running as root, these restrictions do not apply.)
The tracing process will see the newly traced process stop and may then
control it as if it had been traced all along.
.It Dv PT_DETACH
This request is like
.Dv PT_CONTINUE ,
except that it does not allow
specifying an alternate place to continue execution, and after it
succeeds, the traced process is no longer traced and continues
execution normally.
.It Dv PT_IO
This request is a more general interface that can be used instead of
.Dv PT_READ_D ,
.Dv PT_WRITE_D ,
.Dv PT_READ_I
and
.Dv PT_WRITE_I .
The I/O request is encoded in a
.Dq Li "struct ptrace_io_desc"
defined as:
.Bd -literal -offset indent
struct ptrace_io_desc {
	int     piod_op;
	void    *piod_offs;
	void    *piod_addr;
	size_t  piod_len;
};
.Ed
.Pp
Where
.Fa piod_offs
is the offset within the traced process where the I/O operation should be
made,
.Fa piod_addr
is the buffer in the parent and
.Fa piod_len
is the length of the I/O request.
The
.Fa piod_op
member specifies what operation needs to be done.
Possible values are:
.Pp
.Bl -tag -width Ds -offset indent -compact
.It PIOD_READ_D
.It PIOD_WRITE_D
.It PIOD_READ_I
.It PIOD_WRITE_I
.It PIOD_READ_AUXV
.El
.Pp
See also the description of
.Dv PT_READ_I
for the difference between D and I spaces.
The
.Dv PIOD_READ_AUXV
operation can be used to read from the ELF auxiliary vector.
A pointer to the descriptor is passed in
.Fa addr .
On return the
.Fa piod_len
field in the descriptor will be updated with the actual number of bytes
transferred.
If the requested I/O couldn't be successfully performed
.Fn ptrace
will return
.Li -1
and set
.Va errno .
.It Dv PT_SET_EVENT_MASK
This request can be used to specify which events in the traced process
should be reported to the tracing process.
These events are specified in a
.Dq Li "struct ptrace_event"
defined as:
.Bd -literal -offset indent
typedef struct ptrace_event {
	int	pe_set_event;
} ptrace_event_t;
.Ed
.Pp
Where
.Fa pe_set_event
is the set of events to be reported.
This set is formed by OR'ing together the following values:
.Bl -tag -width 18n
.It PTRACE_FORK
Report
.Xr fork 2 .
.El
.Pp
A pointer to this structure is passed in
.Fa addr .
The
.Fa data
argument should be set to
.Li sizeof(struct ptrace_event) .
.It Dv PT_GET_EVENT_MASK
This request can be used to determine which events in the traced
process will be reported.
The information is read into the
.Dq Li struct ptrace_event
pointed to by
.Fa addr .
The
.Fa data
argument should be set to
.Li sizeof(struct ptrace_event) .
.It Dv PT_GET_PROCESS_STATE
This request reads the state information associated with the event
that stopped the traced process.
The information is reported in a
.Dq Li "struct ptrace_state"
defined as:
.Bd -literal -offset indent
typedef struct ptrace_state {
	int	pe_report_event;
	pid_t	pe_other_pid;
} ptrace_state_t;
.Ed
.Pp
Where
.Fa pe_report_event
is the event being reported.
If the event being reported is
.Dv PTRACE_FORK ,
.Fa pe_other_pid
will be set to the process ID of the other end of the fork.
A pointer to this structure is passed in
.Fa addr .
The
.Fa data
argument should be set to
.Li sizeof(struct ptrace_state) .
.It Dv PT_GET_THREAD_FIRST
This request reads the thread ID of the traced process' first thread into the
.Dq Li struct ptrace_thread_state
pointed to by
.Fa addr .
The
.Fa data
argument should be set to
.Li sizeof(struct ptrace_thread_state) .
.It Dv PT_GET_THREAD_NEXT
This request is just like
.Dv PT_GET_THREAD_FIRST ,
except it returns the thread ID of the subsequent thread.
The
.Dq Li struct ptrace_thread_state
pointed to by
.Fa addr
must be initialized by a previous
.Dv PT_GET_THREAD_FIRST
or
.Dv PT_GET_THREAD_NEXT
request.
.El
.Pp
Additionally, machine-specific requests can exist.
Depending on the architecture, the following requests may be available
under
.Ox :
.Bl -tag -width 12n
.It Dv PT_GETREGS Pq all platforms
This request reads the traced process' machine registers into the
.Dq Li struct reg
(defined in
.In machine/reg.h )
pointed to by
.Fa addr .
.It Dv PT_SETREGS Pq all platforms
This request is the converse of
.Dv PT_GETREGS ;
it loads the traced process' machine registers from the
.Dq Li struct reg
(defined in
.In machine/reg.h )
pointed to by
.Fa addr .
.\" .It Dv PT_SYSCALL
.\" This request is like
.\" .Dv PT_CONTINUE
.\" except that the process will stop next time it executes any system
.\" call.
.\" Information about the system call can be examined with
.\" .Dv PT_READ_U
.\" and potentially modified with
.\" .Dv PT_WRITE_U
.\" through the
.\" .Li u_kproc.kp_proc.p_md
.\" element of the user structure (see below).
.\" If the process is continued with another
.\" .Dv PT_SYSCALL
.\" request, it will stop again on exit from the syscall, at which point
.\" the return values can be examined and potentially changed.
.\" The
.\" .Li u_kproc.kp_proc.p_md
.\" element is of type
.\" .Dq Li struct mdproc ,
.\" which should be declared by including
.\" .In sys/param.h ,
.\" .In sys/user.h ,
.\" and
.\" .In machine/proc.h ,
.\" and contains the following fields (among others):
.\" .Bl -item -compact -offset indent
.\" .It
.\" .Li syscall_num
.\" .It
.\" .Li syscall_nargs
.\" .It
.\" .Li syscall_args[8]
.\" .It
.\" .Li syscall_err
.\" .It
.\" .Li syscall_rv[2]
.\" .El
.\" When a process stops on entry to a syscall,
.\" .Li syscall_num
.\" holds the number of the syscall,
.\" .Li syscall_nargs
.\" holds the number of arguments it expects, and
.\" .Li syscall_args
.\" holds the arguments themselves.
.\" (Only the first
.\" .Li syscall_nargs
.\" elements of
.\" .Li syscall_args
.\" are guaranteed to be useful.)  When a process stops on exit from a
.\" syscall,
.\" .Li syscall_num
.\" is
.\" .Li -1 ,
.\" .Li syscall_err
.\" holds the error number
.\" .Po
.\" see
.\" .Xr errno 2
.\" .Pc ,
.\" or 0 if no error occurred, and
.\" .Li syscall_rv
.\" holds the return values.
.\" (If the syscall returns only one value, only
.\" .Li syscall_rv[0]
.\" is useful.)
.\" The tracing process can modify any of these with
.\" .Dv PT_WRITE_U ;
.\" only some modifications are useful.
.\" .Pp
.\" On entry to a syscall,
.\" .Li syscall_num
.\" can be changed, and the syscall actually performed will correspond to
.\" the new number (it is the responsibility of the tracing process to fill
.\" in
.\" .Li syscall_args
.\" appropriately for the new call, but there is no need to modify
.\" .Li syscall_nargs ) .
.\" If the new syscall number is 0, no syscall is actually performed;
.\" instead,
.\" .Li syscall_err
.\" and
.\" .Li syscall_rv
.\" are passed back to the traced process directly (and therefore should be
.\" filled in).
.\" If the syscall number is otherwise out of range, a dummy
.\" syscall which simply produces an
.\" .Er ENOSYS
.\" error is effectively performed.
.\" .Pp
.\" On exit from a syscall, only
.\" .Li syscall_err
.\" and
.\" .Li syscall_rv
.\" can usefully be changed; they are set to the values returned by the
.\" syscall and will be passed back to the traced process by the normal
.\" syscall return mechanism.
.It Xo Dv PT_STEP
.No (not available on sparc64)
.Xc
The traced process continues execution, as in request
.Dv PT_CONTINUE ;
however, execution stops as soon as possible after execution of at least
one instruction
.Pq single-step .
.\" mips64 (fp registers in the main reg structure)
.It Xo Dv PT_GETFPREGS
.No (not available on luna88k or sgi)
.Xc
This request reads the traced process' floating-point registers into
the
.Dq Li struct fpreg
(defined in
.In machine/reg.h )
pointed to by
.Fa addr .
.It Xo Dv PT_SETFPREGS
.No (not available on luna88k or sgi)
.Xc
This request is the converse of
.Dv PT_GETFPREGS ;
it loads the traced process' floating-point registers from the
.Dq Li struct fpreg
(defined in
.In machine/reg.h )
pointed to by
.Fa addr .
.It Dv PT_GETXMMREGS Pq i386 only
This request reads the traced process' XMM registers into the
.Dq Li struct xmmregs
(defined in
.In machine/reg.h )
pointed to by
.Fa addr .
.It Dv PT_SETXMMREGS Pq i386 only
This request is the converse of
.Dv PT_GETXMMREGS ;
it loads the traced process' XMM registers from the
.Dq Li struct xmmregs
(defined in
.In machine/reg.h )
pointed to by
.Fa addr .
.It Dv PT_WCOOKIE Pq sparc64 only
This request reads the traced process'
.Sq window cookie
into the
.Li int
pointed to by
.Fa addr .
The window cookie needs to be
.Sq XOR'ed
to stack-saved program counters.
.El
.Sh ERRORS
Some requests can cause
.Fn ptrace
to return
.Li -1
as a non-error value; to disambiguate,
.Va errno
is set to zero and this should be checked.
The possible errors are:
.Bl -tag -width 4n
.It Bq Er ESRCH
No process having the specified process ID exists.
.It Bq Er EINVAL
.Bl -bullet -compact
.It
A process attempted to use
.Dv PT_ATTACH
on itself.
.It
The
.Fa request
was not one of the legal requests.
.\" .It
.\" The
.\" .Fa addr
.\" to
.\" .Dv PT_READ_U
.\" or
.\" .Dv PT_WRITE_U
.\" was not
.\" .Li int Ns \&-aligned.
.It
The signal number (in
.Fa data )
to
.Dv PT_CONTINUE
.\" or
.\" .Dv PT_SYSCALL
was neither 0 nor a legal signal number.
.It
.Dv PT_GETREGS ,
.Dv PT_SETREGS ,
.Dv PT_GETFPREGS ,
or
.Dv PT_SETFPREGS
was attempted on a process with no valid register set.
(This is normally true only of system processes.)
.El
.It Bq Er EBUSY
.Bl -bullet -compact
.It
.Dv PT_ATTACH
was attempted on a process that was already being traced.
.It
A request attempted to manipulate a process that was being traced by
some process other than the one making the request.
.It
A request (other than
.Dv PT_ATTACH )
specified a process that wasn't stopped and waited for.
.El
.It Bq Er EPERM
.Bl -bullet -compact
.It
A request (other than
.Dv PT_ATTACH )
attempted to manipulate a process that wasn't being traced at all.
.It
An attempt was made to use
.Dv PT_ATTACH
on a process in violation of the requirements listed under
.Dv PT_ATTACH
above.
.It
An attempt was made to use
.Dv PT_ATTACH
on a system process.
.El
.El
.Sh HISTORY
The
.Fn ptrace
system call first appeared in
.At v6 .
.Sh BUGS
On several RISC architectures (such as luna88k and sparc64),
the PC is set to the provided PC value for
.Dv PT_CONTINUE
and similar calls, and the remainder of the execution pipeline registers
are set to the following instructions, even if the instruction at PC
is a branch instruction.
Using
.Dv PT_GETREGS
and
.Dv PT_SETREGS
to modify the PC, passing
.Li (caddr_t)1
to
.Fn ptrace ,
should be able to sidestep this.
.\" .Pp
.\" When using
.\" .Dv PT_SYSCALL ,
.\" there is no easy way to tell whether the traced process stopped because
.\" it made a syscall or because a signal was sent at a moment that it just
.\" happened to have valid-looking garbage in its
.\" .Dq Li struct mdproc .
@


1.38
log
@correct documentation for PT_WRITE_I. it may be necessary to flush icache.
after explanation from kettenis
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.37 2016/03/10 08:44:32 jmc Exp $
d5 1
a5 1
.Dd $Mdocdate: March 10 2016 $
d448 1
a448 1
.No (not available on sparc or sparc64)
d493 1
a493 1
.It Dv PT_WCOOKIE Pq sparc and sparc64 only
d589 1
a589 1
On several RISC architectures (such as luna88k, sparc and sparc64),
@


1.37
log
@un-vax;
i've also changed some "and" to "no", since i think it reads better;
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.36 2016/03/06 05:29:30 guenther Exp $
d5 1
a5 1
.Dd $Mdocdate: March 6 2016 $
d88 1
a88 2
implementation, these
two requests are completely identical.
d102 2
@


1.36
log
@Document the PT_GET_THREAD_{FIRST,NEXT} requests

From Michal Mazurek (akfaew (at) jasminek.net)
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.35 2015/12/01 07:50:03 deraadt Exp $
d5 1
a5 1
.Dd $Mdocdate: December 1 2015 $
d447 1
a447 1
.No (not available on sparc and sparc64)
a453 1
.\" m88k - vax (no general fp registers)
d456 1
a456 1
.No (not available on luna88k, sgi and vax)
d466 1
a466 1
.No (not available on luna88k, sgi and vax)
@


1.35
log
@Send Aviion to same place as Nova II
discussed with jsg
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.34 2015/09/24 23:09:16 tedu Exp $
d5 1
a5 1
.Dd $Mdocdate: September 24 2015 $
d304 22
@


1.34
log
@add a small hint that you'll get EBUSY if you forget to wait. ok guenther
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.33 2015/09/10 17:55:21 schwarze Exp $
d5 1
a5 1
.Dd $Mdocdate: September 10 2015 $
d435 1
a435 1
.No (not available on aviion, luna88k, sgi and vax)
d445 1
a445 1
.No (not available on aviion, luna88k, sgi and vax)
d567 1
a567 1
On several RISC architectures (such as aviion, luna88k, sparc and sparc64),
@


1.33
log
@use .In rather than .Fd #include
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.32 2015/08/02 21:54:21 jmc Exp $
d5 1
a5 1
.Dd $Mdocdate: August 2 2015 $
d541 1
a541 1
specified a process that wasn't stopped.
@


1.32
log
@spelling; ok deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.31 2015/01/25 19:31:38 tedu Exp $
d5 1
a5 1
.Dd $Mdocdate: January 25 2015 $
d12 2
a13 2
.Fd #include <sys/types.h>
.Fd #include <sys/ptrace.h>
@


1.31
log
@mention that the kern.global_ptrace sysctl also affects PT_ATTACH
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.30 2014/11/16 18:52:27 jmc Exp $
d5 1
a5 1
.Dd $Mdocdate: November 16 2014 $
d169 1
a169 1
sysctl is 0, then the target process must be a descendent of the tracing
@


1.30
log
@zap some wacky Eo/Ec stuff, and start sentences on new lines; ok schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.29 2014/03/18 22:36:30 miod Exp $
d5 1
a5 1
.Dd $Mdocdate: March 18 2014 $
d167 4
@


1.29
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.28 2014/01/21 03:15:45 schwarze Exp $
d5 1
a5 1
.Dd $Mdocdate: January 21 2014 $
d63 1
a63 3
.Eo \&
.Fn ptrace
.Ec \&.)
d96 1
a96 3
.Eo \&
.Fn ptrace
.Ec .
d109 2
a110 1
.\" from the traced process' user structure.  The
d116 1
a116 3
.\" .Eo \&
.\" .Fn ptrace
.\" .Ec .
d124 3
a126 4
.\" boundary.  The value read is returned as the return value from
.\" .Eo \&
.\" .Fn ptrace
.\" .Ec .
d327 2
a328 1
.\" call.  Information about the system call can be examined with
d334 2
a335 2
.\" element of the user structure (see below).  If the process is continued
.\" with another
d338 2
a339 1
.\" the return values can be examined and potentially changed.  The
d367 2
a368 1
.\" holds the arguments themselves.  (Only the first
d376 1
a376 3
.\" .Eo \&
.\" .Li -1
.\" .Ec ,
d385 2
a386 1
.\" holds the return values.  (If the syscall returns only one value, only
d388 2
a389 1
.\" is useful.)  The tracing process can modify any of these with
d400 1
a400 3
.\" .Eo \&
.\" .Li syscall_nargs
.\" .Ec ).
d407 2
a408 1
.\" filled in).  If the syscall number is otherwise out of range, a dummy
d576 1
a576 3
.Eo \&
.Fn ptrace
.Ec ,
@


1.28
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.27 2013/07/17 05:42:11 schwarze Exp $
d5 1
a5 1
.Dd $Mdocdate: July 17 2013 $
d435 1
a435 1
.No (not available on aviion, luna88k, mvme88k, sgi and vax)
d445 1
a445 1
.No (not available on aviion, luna88k, mvme88k, sgi and vax)
d567 1
a567 2
On several RISC architectures (such as aviion, luna88k, mvme88k, sparc
and sparc64),
@


1.27
log
@more library history
facts checked by sobrado@@
style tweaks and ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.26 2008/09/16 19:41:06 kettenis Exp $
d5 1
a5 1
.Dd $Mdocdate: September 16 2008 $
d317 1
a317 1
.Aq Pa machine/reg.h )
d326 1
a326 1
.Aq Pa machine/reg.h )
d348 2
a349 2
.\" .Aq Pa sys/param.h ,
.\" .Aq Pa sys/user.h ,
d351 1
a351 1
.\" .Aq Pa machine/proc.h ,
d441 1
a441 1
.Aq Pa machine/reg.h )
d452 1
a452 1
.Aq Pa machine/reg.h )
d459 1
a459 1
.Aq Pa machine/reg.h )
d468 1
a468 1
.Aq Pa machine/reg.h )
@


1.26
log
@Add PIOD_READ_AUXV, a way to get the ELF auxilliary vector through ptrace(2).

ok miod@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.25 2007/05/31 19:19:33 jmc Exp $
d5 1
a5 1
.Dd $Mdocdate: May 31 2007 $
d561 5
@


1.25
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.24 2006/05/15 21:12:45 kettenis Exp $
d5 1
a5 1
.Dd $Mdocdate$
d220 1
d226 3
@


1.24
log
@Adjust now that powerpc has PT_{GET|SET}FPREGS.
reminded by miod@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.23 2006/05/09 21:17:13 miod Exp $
d5 1
a5 1
.Dd March 2, 2004
@


1.23
log
@Administrative changes for aviion, ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.22 2005/12/17 20:26:25 miod Exp $
d429 1
a429 1
.\" mips64 - powerpc (fp registers in the main reg structure)
d431 1
a431 1
.No (not available on aviion, luna88k, macppc, mvme88k, sgi and vax)
d441 1
a441 1
.No (not available on aviion, luna88k, macppc, mvme88k, sgi and vax)
@


1.22
log
@Document PT_STEP (better late than never), and group the machine-dependent
request with a (fixed) list of arches for each; tweaks and ok jmc@@ kettenis@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.21 2005/09/15 14:07:40 jmc Exp $
d431 1
a431 1
.No (not available on luna88k, macppc, mvme88k, sgi and vax)
d441 1
a441 1
.No (not available on luna88k, macppc, mvme88k, sgi and vax)
d558 2
a559 1
On several RISC architectures (such as luna88k, mvme88k, sparc and sparc64),
@


1.21
log
@tidy up lists and displays...
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.20 2005/09/14 20:55:59 kettenis Exp $
d305 3
a307 3
All
.Ox
platforms support the following requests:
d309 1
a309 1
.It Dv PT_GETREGS
d316 1
a316 1
.It Dv PT_SETREGS
d420 13
a432 6
.El
.Pp
In addition, all platforms but luna88k, mvme88k, sgi and vax
support these additional requests:
.Bl -tag -width 12n
.It Dv PT_GETFPREGS
d440 3
a442 1
.It Dv PT_SETFPREGS
d451 1
a451 5
.El
.Pp
The following requests are available on i386:
.Bl -tag -width 12n
.It Dv PT_GETXMMREGS
d458 1
a458 1
.It Dv PT_SETXMMREGS
d467 1
a467 5
.El
.Pp
Finally, the following request is available on sparc and sparc64:
.Bl -tag -width 12n
.It Dv PT_WCOOKIE
d558 2
a559 1
On the SPARC, the PC is set to the provided PC value for
d561 3
a563 2
and similar calls, but the NPC is set willy-nilly to 4 greater than the
PC value.
a574 2
.Pp
Single-stepping is not available.
@


1.20
log
@ptrace(2) following fork(2)
ok miod@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.19 2005/07/20 21:51:36 miod Exp $
d193 1
a193 1
.Bd -literal -offset indent -compact
d201 1
d214 2
a215 1
.Bl -tag -width 18n
d248 1
d288 1
@


1.19
log
@No PT_[GS]ETFPREGS on mips.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.18 2005/05/16 17:47:56 miod Exp $
d235 63
@


1.18
log
@PT_WCOOKIE is available on sparc64 too.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.17 2005/05/16 14:02:47 miod Exp $
d355 1
a355 1
In addition, all platforms but luna88k, mvme88k and vax
@


1.17
log
@Mention no more PT_[GS]ETFPREGS on m88k.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.16 2005/04/04 19:12:25 kettenis Exp $
d397 1
a397 1
Finally, the following request is available on sparc:
@


1.16
log
@Document PT_[GS]ETXMMREGS.
ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.15 2005/03/26 13:31:36 jmc Exp $
d355 2
a356 1
In addition, all platforms but vax support these additional requests:
@


1.15
log
@- use .Cm rather than .Nm for kernel options
- no space needed before full stops here
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.14 2005/03/26 08:33:57 tedu Exp $
d244 1
a244 1
.Dq Li "struct reg"
d253 1
a253 1
.Dq Li "struct reg"
d275 1
a275 1
.\" .Dq Li "struct mdproc" ,
d360 1
a360 1
.Dq Li "struct fpreg"
d369 21
a389 1
.Dq Li "struct fpreg"
d512 1
a512 1
.\" .Dq Li "struct mdproc" .
@


1.14
log
@acct, ktrace, and ptrace are only available if the kernel option is there.
say so.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.13 2004/03/09 22:46:26 miod Exp $
d41 2
a42 2
.Nm PTRACE
option .
@


1.13
log
@A better description of the machine-dependent PT commands.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.12 2003/02/27 07:55:34 jmc Exp $
d39 4
@


1.12
log
@typos;
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.11 2002/04/10 17:31:59 fgsch Exp $
d5 1
a5 1
.Dd November 7, 1994
d234 3
a236 1
On the SPARC, these are:
a253 17
.It Dv PT_GETFPREGS
This request reads the traced process' floating-point registers into
the
.Dq Li "struct fpreg"
(defined in
.Aq Pa machine/reg.h )
pointed to by
.Fa addr .
.It Dv PT_SETFPREGS
This request is the converse of
.Dv PT_GETFPREGS ;
it loads the traced process' floating-point registers from the
.Dq Li "struct fpreg"
(defined in
.Aq Pa machine/reg.h )
pointed to by
.Fa addr .
d349 35
@


1.11
log
@don't attach to system processes.
art@@ niklas@@ markus@@ millert@@ deraadt@@ ok.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.10 2002/03/12 14:38:12 art Exp $
d203 2
a204 1
.Fa piod_len is the length of the I/O request.
d207 1
a207 1
member specifies what operation that needs to be done.
@


1.10
log
@Document reality.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.9 2002/03/11 14:36:27 art Exp $
d437 4
@


1.9
log
@Document PT_IO
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.8 2000/10/18 05:12:11 aaron Exp $
d209 4
a212 4
.It PIOD_OP_READ_DATA
.It PIOD_OP_WRITE_DATA
.It PIOD_OP_READ_TEXT
.It PIOD_OP_WRITE_TEXT
d214 1
d217 13
a229 1
for the difference between DATA and TEXT spaces.
@


1.8
log
@Another round of man page cleanup, this time to remove more hard sentence
breaks and getting rid of short lines, making these files easier to work with.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.7 1999/06/29 14:10:14 aaron Exp $
d179 38
@


1.7
log
@- change references to nil to null; tschroed@@acm.org
- remove trailing spaces from end of lines
- add some .Dv
- change -1 to \-1, so `-' is taken as a negative sign
- other misc formatting fixes
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.6 1999/05/27 16:54:23 aaron Exp $
d18 2
a19 1
provides tracing and debugging facilities.  It allows one process (the
d23 2
a24 1
process).  Most of the time, the traced process runs normally, but when
d30 2
a31 1
it stops.  The tracing process is expected to notice this via
d54 5
a58 4
that the process expects to be traced by its parent.  All the other
arguments are ignored.  (If the parent process does not expect to trace
the child, it will probably be rather confused by the results; once the
traced process stops, it cannot be made to continue except via
d75 2
a76 1
of data from the traced process' address space.  Traditionally,
d83 6
a88 2
reads from the data space.  In the current OpenBSD implementation, these
two requests are completely identical.  The
d91 3
a93 3
space) at which the read is to be done.  This address does not have to
meet any alignment constraints.  The value read is returned as the
return value from
d102 2
a103 1
except that they write rather than read.  The
d160 3
a162 2
process and begin tracing it.  It does not need any cooperation from
the to-be-traced process.  In this case,
d165 6
a170 5
arguments are ignored.  This request requires that the target process
must have the same real UID as the tracing process, and that it must
not be executing a setuid or setgid executable.  (If the tracing
process is running as root, these restrictions do not apply.)  The
tracing process will see the newly traced process stop and may then
d181 2
a182 2
Additionally, machine-specific requests can exist.  On the SPARC, these
are:
d320 2
a321 2
is set to zero and this should be checked.  The possible
errors are:
d358 2
a359 2
was attempted on a process with no valid register set.  (This is
normally true only of system processes.)
d392 2
a393 1
PC value.  Using
@


1.6
log
@add missing .El macros (which properly terminate .Bl macro lists)
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.5 1999/05/12 13:26:48 aaron Exp $
d161 3
a163 1
This request is like PT_CONTINUE, except that it does not allow
@


1.5
log
@grammar police: do not hyphenate compound words that act as adjectives if the
first word ends in -ly

i.e., fully-qualified, newly-created, globally-visible, etc. are wrong
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.4 1999/02/01 08:13:01 d Exp $
d372 1
@


1.4
log
@mi ptrace
@
text
@d1 1
a1 1
.\"	$OpenBSD: ptrace.2,v 1.3 1996/10/08 01:20:12 michaels Exp $
d158 1
a158 1
tracing process will see the newly-traced process stop and may then
@


1.3
log
@Attempt at cleanup.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d306 1
a306 1
can be set to 0 before the call and checked afterwards.  The possible
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d7 1
a7 1
.Os NetBSD 1.0BETA
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
.\"	$NetBSD: ptrace.2,v 1.2 1995/02/27 12:35:37 cgd Exp $
d78 1
a78 1
reads from the data space.  In the current NetBSD implementation, these
d96 36
a131 36
.It Dv PT_READ_U
This request reads an
.Li int
from the traced process' user structure.  The
.Fa addr
argument specifies the location of the int relative to the base of the
user structure; it will usually be an integer value cast to
.Li caddr_t
either explicitly or via the presence of a prototype for
.Eo \&
.Fn ptrace
.Ec .
Unlike
.Dv PT_READ_I
and
.Dv PT_READ_D ,
.Fa addr
must be aligned on an
.Li int
boundary.  The value read is returned as the return value from
.Eo \&
.Fn ptrace
.Ec .
.It Dv PT_WRITE_U
This request writes an
.Li int
into the traced process' user structure.
.Fa addr
specifies the offset, just as for
.Dv PT_READ_U ,
and
.Fa data
specifies the value to be written, just as for
.Dv PT_WRITE_I
and
.Dv PT_WRITE_D .
d203 95
a297 95
.It Dv PT_SYSCALL
This request is like
.Dv PT_CONTINUE
except that the process will stop next time it executes any system
call.  Information about the system call can be examined with
.Dv PT_READ_U
and potentially modified with
.Dv PT_WRITE_U
through the
.Li u_kproc.kp_proc.p_md
element of the user structure (see below).  If the process is continued
with another
.Dv PT_SYSCALL
request, it will stop again on exit from the syscall, at which point
the return values can be examined and potentially changed.  The
.Li u_kproc.kp_proc.p_md
element is of type
.Dq Li "struct mdproc" ,
which should be declared by including
.Aq Pa sys/param.h ,
.Aq Pa sys/user.h ,
and
.Aq Pa machine/proc.h ,
and contains the following fields (among others):
.Bl -item -compact -offset indent
.It
.Li syscall_num
.It
.Li syscall_nargs
.It
.Li syscall_args[8]
.It
.Li syscall_err
.It
.Li syscall_rv[2]
.El
When a process stops on entry to a syscall,
.Li syscall_num
holds the number of the syscall,
.Li syscall_nargs
holds the number of arguments it expects, and
.Li syscall_args
holds the arguments themselves.  (Only the first
.Li syscall_nargs
elements of
.Li syscall_args
are guaranteed to be useful.)  When a process stops on exit from a
syscall,
.Li syscall_num
is
.Eo \&
.Li -1
.Ec ,
.Li syscall_err
holds the error number
.Po
see
.Xr errno 2
.Pc ,
or 0 if no error occurred, and
.Li syscall_rv
holds the return values.  (If the syscall returns only one value, only
.Li syscall_rv[0]
is useful.)  The tracing process can modify any of these with
.Dv PT_WRITE_U ;
only some modifications are useful.
.Pp
On entry to a syscall,
.Li syscall_num
can be changed, and the syscall actually performed will correspond to
the new number (it is the responsibility of the tracing process to fill
in
.Li syscall_args
appropriately for the new call, but there is no need to modify
.Eo \&
.Li syscall_nargs
.Ec ).
If the new syscall number is 0, no syscall is actually performed;
instead,
.Li syscall_err
and
.Li syscall_rv
are passed back to the traced process directly (and therefore should be
filled in).  If the syscall number is otherwise out of range, a dummy
syscall which simply produces an
.Er ENOSYS
error is effectively performed.
.Pp
On exit from a syscall, only
.Li syscall_err
and
.Li syscall_rv
can usefully be changed; they are set to the values returned by the
syscall and will be passed back to the traced process by the normal
syscall return mechanism.
d321 9
a329 9
.It
The
.Fa addr
to
.Dv PT_READ_U
or
.Dv PT_WRITE_U
was not
.Li int Ns \&-aligned.
d335 2
a336 2
or
.Dv PT_SYSCALL
d390 7
a396 7
.Pp
When using
.Dv PT_SYSCALL ,
there is no easy way to tell whether the traced process stopped because
it made a syscall or because a signal was sent at a moment that it just
happened to have valid-looking garbage in its
.Dq Li "struct mdproc" .
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
