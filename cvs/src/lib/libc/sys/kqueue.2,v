head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.25.0.4
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.2
	OPENBSD_5_0:1.22.0.18
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.16
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.14
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.10
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.12
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.8
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.20.0.6
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6;
locks; strict;
comment	@.\" @;


1.33
date	2016.08.13.17.05.02;	author tedu;	state Exp;
branches;
next	1.32;
commitid	ARqCXM2sKlLkxGcT;

1.32
date	2015.11.07.22.57.52;	author jmc;	state Exp;
branches;
next	1.31;
commitid	NJ1naRj4HulCkLlB;

1.31
date	2015.09.10.17.55.21;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	PeV7Ql0T6htfMjhP;

1.30
date	2015.01.20.11.56.33;	author reyk;	state Exp;
branches;
next	1.29;
commitid	7e9Fnm2J4FZIR6iU;

1.29
date	2014.01.21.03.15.45;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2013.08.14.10.06.02;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2013.07.16.15.21.11;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.31.19.01.56;	author yasuoka;	state Exp;
branches;
next	1.25;

1.25
date	2012.04.12.14.25.57;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2012.02.18.08.19.38;	author ajacoutot;	state Exp;
branches;
next	1.23;

1.23
date	2011.10.16.08.07.23;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.31.19.19.32;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.30.00.23.48;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.01.22.46.44;	author marc;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.23.06.54.54;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.23.03.32.16;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.06.05.26.34;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.02.17.49.31;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.02.17.42.06;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.22.21.31.21;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.17.12.03.05;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.17.02.43.58;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.02.19.00.26;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.24.02.56.55;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.30.16.31.42;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.02.21.47.16;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.22.00.46.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.11.05.02.29;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.20.56.37;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.21.22.30.07;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.18.23.44.54;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.17.18.16.49;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.16.20.33.03;	author provos;	state Exp;
branches;
next	;


desc
@@


1.33
log
@modern interfaces should use modern speelings, so spell quad_t as int64_t.
@
text
@.\"	$OpenBSD: kqueue.2,v 1.32 2015/11/07 22:57:52 jmc Exp $
.\"
.\" Copyright (c) 2000 Jonathan Lemon
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\" $FreeBSD: src/lib/libc/sys/kqueue.2,v 1.18 2001/02/14 08:48:35 guido Exp $
.\"
.Dd $Mdocdate: November 7 2015 $
.Dt KQUEUE 2
.Os
.Sh NAME
.Nm kqueue ,
.Nm kevent ,
.Nm EV_SET
.Nd kernel event notification mechanism
.Sh SYNOPSIS
.In sys/types.h
.In sys/event.h
.In sys/time.h
.Ft int
.Fn kqueue "void"
.Ft int
.Fn kevent "int kq" "const struct kevent *changelist" "int nchanges" "struct kevent *eventlist" "int nevents" "const struct timespec *timeout"
.Fn EV_SET "&kev" ident filter flags fflags data udata
.Sh DESCRIPTION
.Fn kqueue
provides a generic method of notifying the user when an event
happens or a condition holds, based on the results of small
pieces of kernel code termed
.Dq filters .
A kevent is identified by the (ident, filter) pair; there may only
be one unique kevent per kqueue.
.Pp
The filter is executed upon the initial registration of a kevent
in order to detect whether a preexisting condition is present, and is also
executed whenever an event is passed to the filter for evaluation.
If the filter determines that the condition should be reported,
then the kevent is placed on the kqueue for the user to retrieve.
.Pp
The filter is also run when the user attempts to retrieve the kevent
from the kqueue.
If the filter indicates that the condition that triggered
the event no longer holds, the kevent is removed from the kqueue and
is not returned.
.Pp
Multiple events which trigger the filter do not result in multiple
kevents being placed on the kqueue; instead, the filter will aggregate
the events into a single
.Li struct kevent .
Calling
.Fn close
on a file descriptor will remove any kevents that reference the descriptor.
.Pp
.Fn kqueue
creates a new kernel event queue and returns a descriptor.
The queue is not inherited by a child created with
.Xr fork 2 .
Similarly, kqueues cannot be passed across UNIX-domain sockets.
.Pp
.Fn kevent
is used to register events with the queue, and return any pending
events to the user.
.Fa changelist
is a pointer to an array of
.Va kevent
structures, as defined in
.In sys/event.h .
All changes contained in the
.Fa changelist
are applied before any pending events are read from the queue.
.Fa nchanges
gives the size of
.Fa changelist .
.Fa eventlist
is a pointer to an array of kevent structures.
.Fa nevents
determines the size of
.Fa eventlist .
When
.Fa nevents
is zero,
.Fn kevent
will return immediately even if there is a
.Fa timeout
specified unlike
.Xr select 2 .
If
.Fa timeout
is a non-null pointer, it specifies a maximum interval to wait
for an event, which will be interpreted as a
.Li struct timespec .
If
.Fa timeout
is a null pointer,
.Fn kevent
waits indefinitely.
To effect a poll, the
.Fa timeout
argument should be non-null, pointing to a zero-valued
.Va timespec
structure.
The same array may be used for the
.Fa changelist
and
.Fa eventlist .
.Pp
.Fn EV_SET
is a macro which is provided for ease of initializing a
kevent structure.
.Pp
The
.Va kevent
structure is defined as:
.Bd -literal
struct kevent {
	uintptr_t  ident;	/* identifier for this event */
	short	   filter;	/* filter for event */
	u_short	   flags;	/* action flags for kqueue */
	u_int	   fflags;	/* filter flag value */
	int64_t	   data;	/* filter data value */
	void	   *udata;	/* opaque user data identifier */
};
.Ed
.Pp
The fields of
.Li struct kevent
are:
.Bl -tag -width XXXfilter
.It ident
Value used to identify this event.
The exact interpretation is determined by the attached filter,
but often is a file descriptor.
.It filter
Identifies the kernel filter used to process this event.
The pre-defined system filters are described below.
.It flags
Actions to perform on the event.
.It fflags
Filter-specific flags.
.It data
Filter-specific data value.
.It udata
Opaque user-defined value passed through the kernel unchanged.
.El
.Pp
The
.Va flags
field can contain the following values:
.Bl -tag -width XXXEV_ONESHOT
.It Dv EV_ADD
Adds the event to the kqueue.
Re-adding an existing event will modify the parameters of the original event,
and not result in a duplicate entry.
Adding an event automatically enables it, unless overridden by the
.Dv EV_DISABLE
flag.
.It Dv EV_ENABLE
Permit
.Fn kevent
to return the event if it is triggered.
.It Dv EV_DISABLE
Disable the event so
.Fn kevent
will not return it.
The filter itself is not disabled.
.It Dv EV_DELETE
Removes the event from the kqueue.
Events which are attached to file descriptors are automatically deleted
on the last close of the descriptor.
.It Dv EV_ONESHOT
Causes the event to return only the first occurrence of the filter
being triggered.
After the user retrieves the event from the kqueue, it is deleted.
.It Dv EV_CLEAR
After the event is retrieved by the user, its state is reset.
This is useful for filters which report state transitions
instead of the current state.
Note that some filters may automatically set this flag internally.
.It Dv EV_EOF
Filters may set this flag to indicate filter-specific EOF condition.
.It Dv EV_ERROR
See
.Sx RETURN VALUES
below.
.El
.Pp
The predefined system filters are listed below.
Arguments may be passed to and from the filter via the
.Va fflags
and
.Va data
fields in the kevent structure.
.Bl -tag -width EVFILT_SIGNAL
.It Dv EVFILT_READ
Takes a descriptor as the identifier, and returns whenever
there is data available to read.
The behavior of the filter is slightly different depending
on the descriptor type.
.Bl -tag -width 2n
.It Sockets
Sockets which have previously been passed to
.Fn listen
return when there is an incoming connection pending.
.Va data
contains the size of the listen backlog.
.Pp
Other socket descriptors return when there is data to be read,
subject to the
.Dv SO_RCVLOWAT
value of the socket buffer.
This may be overridden with a per-filter low water mark at the
time the filter is added by setting the
.Dv NOTE_LOWAT
flag in
.Va fflags ,
and specifying the new low water mark in
.Va data .
On return,
.Va data
contains the number of bytes in the socket buffer.
.Pp
If the read direction of the socket has shutdown, then the filter
also sets
.Dv EV_EOF
in
.Va flags ,
and returns the socket error (if any) in
.Va fflags .
It is possible for EOF to be returned (indicating the connection is gone)
while there is still data pending in the socket buffer.
.It Vnodes
Returns when the file pointer is not at the end of file.
.Va data
contains the offset from current position to end of file,
and may be negative.
If
.Dv NOTE_EOF
is set in
.Va fflags ,
.Fn kevent
will also return when the file pointer is at the end of file.
The end of file condition is indicated by the presence of
.Dv NOTE_EOF
in
.Va fflags
on return.
.It "Fifos, Pipes"
Returns when there is data to read;
.Va data
contains the number of bytes available.
.Pp
When the last writer disconnects, the filter will set
.Dv EV_EOF
in
.Va flags .
This may be cleared by passing in
.Dv EV_CLEAR ,
at which point the filter will resume waiting for data to become
available before returning.
.It "BPF devices"
Returns when the BPF buffer is full, the BPF timeout has expired, or
when the BPF has
.Dq immediate mode
enabled and there is any data to read;
.Va data
contains the number of bytes available.
.El
.It Dv EVFILT_WRITE
Takes a descriptor as the identifier, and returns whenever
it is possible to write to the descriptor.
For sockets, pipes, and FIFOs,
.Va data
will contain the amount of space remaining in the write buffer.
The filter will set
.Dv EV_EOF
when the reader disconnects, and for the FIFO case,
this may be cleared by use of
.Dv EV_CLEAR .
Note that this filter is not supported for vnodes or BPF devices.
.Pp
For sockets, the low water mark and socket error handling is
identical to the
.Dv EVFILT_READ
case.
.\".It Dv EVFILT_AIO
.\"The sigevent portion of the AIO request is filled in, with
.\".Va sigev_notify_kqueue
.\"containing the descriptor of the kqueue that the event should
.\"be attached to,
.\".Va sigev_value
.\"containing the udata value, and
.\".Va sigev_notify
.\"set to
.\".Dv SIGEV_KEVENT .
.\"When the aio_* function is called, the event will be registered
.\"with the specified kqueue, and the
.\".Va ident
.\"argument set to the
.\".Li struct aiocb
.\"returned by the aio_* function.
.\"The filter returns under the same conditions as aio_error.
.\".Pp
.\"Alternatively, a kevent structure may be initialized, with
.\".Va ident
.\"containing the descriptor of the kqueue, and the
.\"address of the kevent structure placed in the
.\".Va aio_lio_opcode
.\"field of the AIO request.
.\"However, this approach will not work on architectures with 64-bit pointers,
.\"and should be considered deprecated.
.It Dv EVFILT_VNODE
Takes a file descriptor as the identifier and the events to watch for in
.Va fflags ,
and returns when one or more of the requested events occurs on the descriptor.
The events to monitor are:
.Bl -tag -width XXNOTE_RENAME
.It Dv NOTE_DELETE
.Fn unlink
was called on the file referenced by the descriptor.
.It Dv NOTE_WRITE
A write occurred on the file referenced by the descriptor.
.It Dv NOTE_EXTEND
The file referenced by the descriptor was extended.
.It Dv NOTE_TRUNCATE
The file referenced by the descriptor was truncated.
.It Dv NOTE_ATTRIB
The file referenced by the descriptor had its attributes changed.
.It Dv NOTE_LINK
The link count on the file changed.
.It Dv NOTE_RENAME
The file referenced by the descriptor was renamed.
.It Dv NOTE_REVOKE
Access to the file was revoked via
.Xr revoke 2
or the underlying file system was unmounted.
.El
.Pp
On return,
.Va fflags
contains the events which triggered the filter.
.It Dv EVFILT_PROC
Takes the process ID to monitor as the identifier and the events to watch for
in
.Va fflags ,
and returns when the process performs one or more of the requested events.
If a process can normally see another process, it can attach an event to it.
The events to monitor are:
.Bl -tag -width XXNOTE_TRACKERR
.It Dv NOTE_EXIT
The process has exited.
The exit status will be stored in
.Va data
in the same format as the status set by
.Xr wait 2 .
.It Dv NOTE_FORK
The process has called
.Fn fork .
.It Dv NOTE_EXEC
The process has executed a new process via
.Xr execve 2
or similar call.
.It Dv NOTE_TRACK
Follow a process across
.Fn fork
calls.
The parent process will return with
.Dv NOTE_FORK
set in the
.Va fflags
field, while the child process will return with
.Dv NOTE_CHILD
set in
.Va fflags
and the parent PID in
.Va data .
.It Dv NOTE_TRACKERR
This flag is returned if the system was unable to attach an event to
the child process, usually due to resource limitations.
.El
.Pp
On return,
.Va fflags
contains the events which triggered the filter.
.It Dv EVFILT_SIGNAL
Takes the signal number to monitor as the identifier and returns
when the given signal is delivered to the process.
This coexists with the
.Fn signal
and
.Fn sigaction
facilities, and has a lower precedence.
The filter will record all attempts to deliver a signal to a process,
even if the signal has been marked as
.Dv SIG_IGN .
Event notification happens after normal signal delivery processing.
.Va data
returns the number of times the signal has occurred since the last call to
.Fn kevent .
This filter automatically sets the
.Dv EV_CLEAR
flag internally.
.It Dv EVFILT_TIMER
Establishes an arbitrary timer identified by
.Va ident .
When adding a timer,
.Va data
specifies the timeout period in milliseconds.
The timer will be periodic unless
.Dv EV_ONESHOT
is specified.
On return,
.Va data
contains the number of times the timeout has expired since the last call to
.Fn kevent .
This filter automatically sets the
.Dv EV_CLEAR
flag internally.
.El
.Sh RETURN VALUES
.Fn kqueue
creates a new kernel event queue and returns a file descriptor.
If there was an error creating the kernel event queue, a value of -1 is
returned and errno set.
.Pp
.Fn kevent
returns the number of events placed in the
.Fa eventlist ,
up to the value given by
.Fa nevents .
If an error occurs while processing an element of the
.Fa changelist
and there is enough room in the
.Fa eventlist ,
then the event will be placed in the
.Fa eventlist
with
.Dv EV_ERROR
set in
.Va flags
and the system error in
.Va data .
Otherwise,
.Dv -1
will be returned, and
.Dv errno
will be set to indicate the error condition.
If the time limit expires, then
.Fn kevent
returns 0.
.Sh ERRORS
The
.Fn kqueue
function fails if:
.Bl -tag -width Er
.It Bq Er ENOMEM
The kernel failed to allocate enough memory for the kernel queue.
.It Bq Er EMFILE
The per-process descriptor table is full.
.It Bq Er ENFILE
The system file table is full.
.El
.Pp
The
.Fn kevent
function fails if:
.Bl -tag -width Er
.It Bq Er EACCES
The process does not have permission to register a filter.
.It Bq Er EFAULT
There was an error reading or writing the
.Va kevent
structure.
.It Bq Er EBADF
The specified descriptor is invalid.
.It Bq Er EINTR
A signal was delivered before the timeout expired and before any
events were placed on the kqueue for return.
.It Bq Er EINVAL
The specified time limit or filter is invalid.
.It Bq Er ENOENT
The event could not be found to be modified or deleted.
.It Bq Er ENOMEM
No memory was available to register the event.
.It Bq Er ESRCH
The specified process to attach to does not exist.
.El
.Sh SEE ALSO
.Xr poll 2 ,
.Xr read 2 ,
.Xr select 2 ,
.Xr sigaction 2 ,
.Xr wait 2 ,
.Xr write 2 ,
.Xr signal 3
.Sh HISTORY
The
.Fn kqueue
and
.Fn kevent
functions first appeared in
.Fx 4.1 .
.Sh AUTHORS
The
.Fn kqueue
system and this manual page were written by
.An Jonathan Lemon Aq Mt jlemon@@FreeBSD.org .
.Sh BUGS
It is currently not possible to watch FIFOs or AIO that reside
on anything but a UFS file system.
Watching a vnode is possible on UFS, NFS and MS-DOS file systems.
.Pp
The
.Fa timeout
value is limited to 24 hours; longer timeouts will be silently
reinterpreted as 24 hours.
@


1.32
log
@add missing NAME entries;
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.31 2015/09/10 17:55:21 schwarze Exp $
d29 1
a29 1
.Dd $Mdocdate: September 10 2015 $
d141 1
a141 1
	quad_t	   data;	/* filter data value */
@


1.31
log
@use .In rather than .Fd #include
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.30 2015/01/20 11:56:33 reyk Exp $
d29 1
a29 1
.Dd $Mdocdate: January 20 2015 $
d34 2
a35 1
.Nm kevent
@


1.30
log
@We do not support AIO, so comment it out in the kqueue(2) manpage for now.

OK jmc@@ guenther@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.29 2014/01/21 03:15:45 schwarze Exp $
d29 1
a29 1
.Dd $Mdocdate: January 21 2014 $
d37 3
a39 3
.Fd #include <sys/types.h>
.Fd #include <sys/event.h>
.Fd #include <sys/time.h>
@


1.29
log
@obvious .Pa fixes; found with mandocdb(8)
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.28 2013/08/14 10:06:02 guenther Exp $
d29 1
a29 1
.Dd $Mdocdate: August 14 2013 $
d305 26
a330 26
.It Dv EVFILT_AIO
The sigevent portion of the AIO request is filled in, with
.Va sigev_notify_kqueue
containing the descriptor of the kqueue that the event should
be attached to,
.Va sigev_value
containing the udata value, and
.Va sigev_notify
set to
.Dv SIGEV_KEVENT .
When the aio_* function is called, the event will be registered
with the specified kqueue, and the
.Va ident
argument set to the
.Li struct aiocb
returned by the aio_* function.
The filter returns under the same conditions as aio_error.
.Pp
Alternatively, a kevent structure may be initialized, with
.Va ident
containing the descriptor of the kqueue, and the
address of the kevent structure placed in the
.Va aio_lio_opcode
field of the AIO request.
However, this approach will not work on architectures with 64-bit pointers,
and should be considered deprecated.
@


1.28
log
@ident and data members of struct kevent changed types: ident to
uintptr_t, so it can hold pointers for EVFILT_TIMER and _AIO, and
data to quad_t, so it can hold file offets.
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.27 2013/07/16 15:21:11 schwarze Exp $
d29 1
a29 1
.Dd $Mdocdate: July 16 2013 $
d87 1
a87 1
.Aq Pa sys/event.h .
@


1.27
log
@use .Mt for email addresses; from Jan Stary <hans at stare dot cz>; ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.26 2013/05/31 19:01:56 yasuoka Exp $
d29 1
a29 1
.Dd $Mdocdate: May 31 2013 $
d136 6
a141 6
	u_int	ident;		/* identifier for this event */
	short	filter;		/* filter for event */
	u_short	flags;		/* action flags for kqueue */
	u_int	fflags;		/* filter flag value */
	int	data;		/* filter data value */
	void	*udata;		/* opaque user data identifier */
@


1.26
log
@On NOTE_EXIT event of EVFILT_PROC, store the exit status in kn_data.

ok guenther tedu deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.25 2012/04/12 14:25:57 deraadt Exp $
d29 1
a29 1
.Dd $Mdocdate: April 12 2012 $
d526 1
a526 1
.An Jonathan Lemon Aq jlemon@@FreeBSD.org .
@


1.25
log
@more rfork mop-up
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.24 2012/02/18 08:19:38 ajacoutot Exp $
d29 1
a29 1
.Dd $Mdocdate: February 18 2012 $
d371 4
d512 1
@


1.24
log
@Extend after recent msdos support.

input/ok krw@@ thib@@ jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.23 2011/10/16 08:07:23 guenther Exp $
d29 1
a29 1
.Dd $Mdocdate: October 16 2011 $
a77 6
However, if
.Xr rfork 2
is called without the
.Dv RFFDG
flag, then the descriptor table is shared,
which will allow sharing of the kqueue between two processes.
@


1.23
log
@Note a restriction that is actually enforced in 5.0
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.22 2007/05/31 19:19:32 jmc Exp $
d29 1
a29 1
.Dd $Mdocdate: May 31 2007 $
d529 3
a531 2
It is currently not possible to watch FIFOs, AIO, or a vnode that
resides on anything but a UFS file system.
@


1.22
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.21 2007/05/30 00:23:48 tedu Exp $
d29 1
a29 1
.Dd $Mdocdate$
d84 1
@


1.21
log
@add a new kevent filter type for timers.  this allows processes to create
a series of oneshot or periodic timers.  capped to a global limit.
from freebsd via brad.
ok art pedro
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.20 2006/01/01 22:46:44 marc Exp $
d29 1
a29 1
.Dd April 14, 2000
@


1.20
log
@fix desc of struct kevent, OK millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.19 2004/09/23 06:54:54 brad Exp $
d419 16
@


1.19
log
@really mention BPF this time around.
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.18 2004/09/23 03:32:16 brad Exp $
d141 6
a146 6
	uintptr_t ident;	/* identifier for this event */
	short	  filter;	/* filter for event */
	u_short	  flags;	/* action flags for kqueue */
	u_int	  fflags;	/* filter flag value */
	intptr_t  data;		/* filter data value */
	void	  *udata;	/* opaque user data identifier */
@


1.18
log
@mention support for BPF.

From: FreeBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.17 2004/09/06 05:26:34 brad Exp $
d245 1
a245 1
contains the number of bytes of protocol data available to read.
d285 7
d304 1
a304 1
Note that this filter is not supported for vnodes.
@


1.17
log
@- Spelling fix.
- Add mention of the fact that timeouts are silently limited to 24 hours.
- Document the fact that kqueue will immediately return and not timeout
  when nevents is 0.

From FreeBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.16 2004/08/02 17:49:31 brad Exp $
d245 1
a245 1
contains the number of bytes in the socket buffer.
@


1.16
log
@Fix typo (SIGEV_EVENT -> SIGEV_KEVENT)

From FreeBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.15 2004/08/02 17:42:06 brad Exp $
d104 8
d353 1
a353 1
or the underlying fileystem was unmounted.
d507 5
@


1.15
log
@s/kqueue/kevent/ in correct place.

From FreeBSD
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.14 2004/07/22 21:31:21 jmc Exp $
d304 1
a304 1
.Dv SIGEV_EVENT .
@


1.14
log
@typo;
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.13 2003/12/17 12:03:05 jmc Exp $
d404 1
a404 1
.Fn kqueue .
@


1.13
log
@- new sentence, new line
- kill whitespace at EOL
- remove unnecessary .Pp
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.12 2003/12/17 02:43:58 tedu Exp $
d320 1
a320 1
and should be considered depreciated.
@


1.12
log
@new options from marius@@monkey
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.11 2003/04/02 19:00:26 jmc Exp $
a215 1
.Pp
d252 2
a253 1
and may be negative.  If
d255 1
a255 1
is set in 
d258 2
a259 2
will also return when the file pointer is at the end of file.  The end
of file condition is indicated by the presence of 
d261 2
a262 2
in 
.Va fflags 
@


1.11
log
@fifo -> FIFO

ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.10 2003/02/24 02:56:55 deraadt Exp $
d253 11
a263 1
and may be negative.
d334 2
@


1.10
log
@the the
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.9 2002/04/30 16:31:42 mpech Exp $
d271 1
a271 1
For sockets, pipes, and fifos,
d276 1
a276 1
when the reader disconnects, and for the fifo case,
d485 1
a485 1
It is currently not possible to watch fifos, AIO, or a vnode that
@


1.9
log
@Initial cleanup:
o) remove extra space in the end of line;
o) remove extra blank lines in the end of file;
o) remove .Pp before .Ss;
o) CAVEAT -> CAVEATS;
o) fix usage of .Fa;
o) <blank-line> -> .Pp;
o) wrap long lines;

millert@@ ok
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.8 2002/03/02 21:47:16 art Exp $
d255 1
a255 1
Returns when the there is data to read;
@


1.8
log
@Document how NOTE_TRACK behaves.
When the documentation and implementation are inconsistent the smallest
change wins. To correct the implementation was a big change, to correct
the documentation was a one word fix.
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.7 2001/07/22 00:46:29 deraadt Exp $
d90 1
a90 1
.Va kevent 
d93 1
a93 1
All changes contained in the 
d121 1
a121 1
and 
d205 1
a205 1
Arguments may be passed to and from the filter via the 
d230 3
a232 3
time the filter is added by setting the 
.Dv NOTE_LOWAT 
flag in 
d245 1
a245 1
and returns the socket error (if any) in 
d281 1
a281 1
For sockets, the low water mark and socket error handling is 
d287 1
a287 1
.Va sigev_notify_kqueue 
d291 1
a291 1
containing the udata value, and 
d303 1
a303 1
Alternatively, a kevent structure may be initialized, with 
d312 1
a312 1
Takes a file descriptor as the identifier and the events to watch for in 
d331 1
a331 1
Access to the file was revoked via 
d340 1
a340 1
Takes the process ID to monitor as the identifier and the events to watch for 
d353 1
a353 1
The process has executed a new process via 
d368 1
a368 1
and the parent PID in 
d383 1
a383 1
and 
d448 1
a448 1
There was an error reading or writing the 
@


1.7
log
@typo; david@@phobia.ms
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.6 2001/03/11 05:02:29 aaron Exp $
d361 1
a361 1
.Dv NOTE_TRACK
@


1.6
log
@mdoc police.
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.5 2001/03/01 20:56:37 provos Exp $
d92 1
a92 1
.Aq Pa event.h .
@


1.5
log
@describe a few new flags; jlemon@@freebsd.org
@
text
@d1 2
a2 1
.\"	$OpenBSD: kqueue.2,v 1.4 2000/11/21 22:30:07 provos Exp $
d49 2
a50 1
pieces of kernel code termed filters.
d64 1
a64 1
is not returned. 
d68 2
a69 1
the events into a single struct kevent.
d100 1
a100 1
is a pointer to an array of kevent structures. 
d106 4
a109 2
is a non-NULL pointer, it specifies a maximum interval to wait
for an event, which will be interpreted as a struct timespec.  If
d111 1
a111 1
is a NULL pointer,
d113 2
a114 1
waits indefinitely.  To effect a poll, the
d116 1
a116 1
argument should be non-NULL, pointing to a zero-valued
d118 2
a119 1
structure.  The same array may be used for the
d143 1
a143 1
.Fa struct kevent
d151 2
a152 2
Identifies the kernel filter used to process this event.  The pre-defined
system filters are described below.
d158 1
a158 1
Filter-specific data value. 
d167 8
a174 6
.It EV_ADD
Adds the event to the kqueue.  Re-adding an existing event
will modify the parameters of the original event, and not result
in a duplicate entry.  Adding an event automatically enables it,
unless overridden by the EV_DISABLE flag.
.It EV_ENABLE
d178 1
a178 1
.It EV_DISABLE
d181 7
a187 6
will not return it.  The filter itself is not disabled.
.It EV_DELETE
Removes the event from the kqueue.  Events which are attached to 
file descriptors are automatically deleted on the last close of 
the descriptor.
.It EV_ONESHOT
d189 3
a191 3
being triggered.  After the user retrieves the event from the kqueue,
it is deleted.
.It EV_CLEAR
d194 3
a196 3
instead of the current state.  Note that some filters may automatically
set this flag internally.
.It EV_EOF
d198 1
a198 1
.It EV_ERROR
d211 1
a211 1
.It EVFILT_READ
d231 1
a231 1
NOTE_LOWAT 
d241 3
a243 1
also sets EV_EOF in
d259 3
a261 1
When the last writer disconnects, the filter will set EV_EOF in
d263 4
a266 3
This may be cleared by passing in EV_CLEAR, at which point the
filter will resume waiting for data to become available before
returning.
d268 1
a268 1
.It EVFILT_WRITE
d270 2
a271 2
it is possible to write to the descriptor.  For sockets, pipes
and fifos, 
d274 5
a278 2
The filter will set EV_EOF when the reader disconnects, and for
the fifo case, this may be cleared by use of EV_CLEAR.
d282 4
a285 2
identical to the EVFILT_READ case.
.It EVFILT_AIO
d293 2
a294 1
set to SIGEV_EVENT.
d299 1
a299 1
.Fa struct aiocb
d308 4
a311 3
field of the AIO request.  However, this approach will not work on
architectures with 64-bit pointers, and should be considered depreciated.
.It EVFILT_VNODE
d317 1
a317 1
.It NOTE_DELETE
d320 1
a320 1
.It NOTE_WRITE
d322 1
a322 1
.It NOTE_EXTEND
d324 1
a324 1
.It NOTE_ATTRIB
d326 1
a326 1
.It NOTE_LINK
d328 1
a328 1
.It NOTE_RENAME
d330 1
a330 1
.It NOTE_REVOKE
d339 1
a339 1
.It EVFILT_PROC
d347 1
a347 1
.It NOTE_EXIT
d349 1
a349 1
.It NOTE_FORK
d352 1
a352 1
.It NOTE_EXEC
d356 1
a356 1
.It NOTE_TRACK
d359 4
a362 1
calls.  The parent process will return with NOTE_TRACK set in the
d364 3
a366 1
field, while the child process will return with NOTE_CHILD set in
d370 1
a370 1
.It NOTE_TRACKERR
d378 1
a378 1
.It EVFILT_SIGNAL
d385 5
a389 4
facilities, and has a lower precedence.  The filter will record
all attempts to deliver a signal to a process, even if the signal has
been marked as SIG_IGN.  Event notification happens after normal
signal delivery processing.
d393 3
a395 1
This filter automatically sets the EV_CLEAR flag internally.
d450 1
a450 1
structure. 
d485 1
a485 1
It is currently not possible to watch fifos, AIO or a vnode that
@


1.4
log
@update
@
text
@d1 1
a1 1
.\"	$OpenBSD: kqueue.2,v 1.3 2000/11/18 23:44:54 aaron Exp $
d26 1
a26 1
.\" $FreeBSD: src/lib/libc/sys/kqueue.2,v 1.12 2000/07/24 18:03:53 sheldonh Exp $
d38 1
d43 1
d77 1
a77 1
is called with the
d79 1
a79 1
flag, the descriptor table is shared,
d104 1
a104 1
for an event.  If
d112 8
a119 1
structure.
d200 1
a200 1
.Bl -tag
d206 2
a207 1
.Bl -tag
d216 11
a226 1
subject to the SO_RCVLOWAT value of the socket buffer.
d232 3
a234 1
.Va flags .
a236 2
.El
.Bl -tag
d242 1
a242 3
.El
.Bl -tag
.It Fifos, Pipes
a252 2
.El
.Bl -tag
d262 3
a264 2
.El
.Bl -tag
d266 10
a275 7
A kevent structure is initialized, with
.Va ident
containing the descriptor of the kqueue that the event should be
attached to.  The address of the kevent structure is then placed in the
.Va aio_lio_opcode
field of the AIO request, and the aio_* function is then called.
The event will be registered with the specified kqueue, and the
d282 7
a288 3
NOTE: this interface is unstable and subject to change.
.El
.Bl -tag
d308 4
a316 2
.El
.Bl -tag
d415 1
a415 1
.It Bq Er EACCESS
@


1.3
log
@OpenBSD does not support non-standard mdoc macros like .Lb.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d429 2
a430 1
It is currently not possible to watch vnodes, fifos or AIO.
@


1.2
log
@remove non-existing manual references.
@
text
@d1 1
a34 2
.Sh LIBRARY
.Lb libc
@


1.1
log
@forgot manpage
@
text
@a410 3
.Xr aio_error 2 ,
.Xr aio_read 2 ,
.Xr aio_return 2 ,
d430 1
a430 4
It is currently not possible to watch a
.Xr vnode 9
that resides on anything but
a UFS file system.
@

