head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.2
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.16
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.14
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.12
	OPENBSD_5_0:1.13.0.10
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.8
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.6
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.11.0.14
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.12
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.10
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.25
date	2016.09.03.16.25.03;	author tedu;	state Exp;
branches;
next	1.24;
commitid	KRhF60sCd55H0FTx;

1.24
date	2015.09.11.09.18.27;	author guenther;	state Exp;
branches;
next	1.23;
commitid	Ug7ZHdkfaIoV0KLN;

1.23
date	2015.01.15.13.05.59;	author millert;	state Exp;
branches;
next	1.22;
commitid	gkpEJvpVgT62ZVxP;

1.22
date	2014.12.19.15.14.04;	author tedu;	state Exp;
branches;
next	1.21;
commitid	BZ7OsdaJWB0aCAfw;

1.21
date	2014.12.19.14.30.44;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	cgArQR1S5KcbVFRj;

1.20
date	2014.12.18.20.29.08;	author tedu;	state Exp;
branches;
next	1.19;
commitid	lb9kNSjnA5wxP5Il;

1.19
date	2014.12.17.19.42.44;	author tedu;	state Exp;
branches;
next	1.18;
commitid	LK74PqXMX8tucYX8;

1.18
date	2014.07.20.04.22.34;	author guenther;	state Exp;
branches;
next	1.17;
commitid	x7aBoxPF8nZvW5Z0;

1.17
date	2014.01.08.06.14.57;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.08.04.35.34;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.12.22.22.55.51;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2013.04.15.15.54.17;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.15.00.55.52;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.00.19;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.28.15.10.27;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.07.14.34.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.05.17.39.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.03.17.30.15;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.03.02.57.47;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.02.23.53.47;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.29.14.13.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.28.22.06.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.08.00.00.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.08.23.34.55;	author millert;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Add functions for SHA512/256. The standard says you're supposed to start
with different magic numbers, so we need to add some functions instead
of just asking the user to truncate as desired. Sigh.
SHA512 is quite a bit faster than SHA256 on 64 bit CPUs,
but 256 bit hashes are usually quite sufficient. Best of both.
ok deraadt tom
@
text
@/*	$OpenBSD: sha2.c,v 1.24 2015/09/11 09:18:27 guenther Exp $	*/

/*
 * FILE:	sha2.c
 * AUTHOR:	Aaron D. Gifford <me@@aarongifford.com>
 * 
 * Copyright (c) 2000-2001, Aaron D. Gifford
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTOR(S) ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTOR(S) BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $From: sha2.c,v 1.1 2001/11/08 00:01:51 adg Exp adg $
 */

#include <sys/types.h>

#include <string.h>
#include <sha2.h>

/*
 * UNROLLED TRANSFORM LOOP NOTE:
 * You can define SHA2_UNROLL_TRANSFORM to use the unrolled transform
 * loop version for the hash transform rounds (defined using macros
 * later in this file).  Either define on the command line, for example:
 *
 *   cc -DSHA2_UNROLL_TRANSFORM -o sha2 sha2.c sha2prog.c
 *
 * or define below:
 *
 *   #define SHA2_UNROLL_TRANSFORM
 *
 */
#ifndef SHA2_SMALL
#if defined(__amd64__) || defined(__i386__)
#define SHA2_UNROLL_TRANSFORM
#endif
#endif

/*** SHA-224/256/384/512 Machine Architecture Definitions *****************/
/*
 * BYTE_ORDER NOTE:
 *
 * Please make sure that your system defines BYTE_ORDER.  If your
 * architecture is little-endian, make sure it also defines
 * LITTLE_ENDIAN and that the two (BYTE_ORDER and LITTLE_ENDIAN) are
 * equivilent.
 *
 * If your system does not define the above, then you can do so by
 * hand like this:
 *
 *   #define LITTLE_ENDIAN 1234
 *   #define BIG_ENDIAN    4321
 *
 * And for little-endian machines, add:
 *
 *   #define BYTE_ORDER LITTLE_ENDIAN 
 *
 * Or for big-endian machines:
 *
 *   #define BYTE_ORDER BIG_ENDIAN
 *
 * The FreeBSD machine this was written on defines BYTE_ORDER
 * appropriately by including <sys/types.h> (which in turn includes
 * <machine/endian.h> where the appropriate definitions are actually
 * made).
 */
#if !defined(BYTE_ORDER) || (BYTE_ORDER != LITTLE_ENDIAN && BYTE_ORDER != BIG_ENDIAN)
#error Define BYTE_ORDER to be equal to either LITTLE_ENDIAN or BIG_ENDIAN
#endif


/*** SHA-224/256/384/512 Various Length Definitions ***********************/
/* NOTE: Most of these are in sha2.h */
#define SHA224_SHORT_BLOCK_LENGTH	(SHA224_BLOCK_LENGTH - 8)
#define SHA256_SHORT_BLOCK_LENGTH	(SHA256_BLOCK_LENGTH - 8)
#define SHA384_SHORT_BLOCK_LENGTH	(SHA384_BLOCK_LENGTH - 16)
#define SHA512_SHORT_BLOCK_LENGTH	(SHA512_BLOCK_LENGTH - 16)

/*** ENDIAN SPECIFIC COPY MACROS **************************************/
#define BE_8_TO_32(dst, cp) do {					\
	(dst) = (u_int32_t)(cp)[3] | ((u_int32_t)(cp)[2] << 8) |	\
	    ((u_int32_t)(cp)[1] << 16) | ((u_int32_t)(cp)[0] << 24);	\
} while(0)

#define BE_8_TO_64(dst, cp) do {					\
	(dst) = (u_int64_t)(cp)[7] | ((u_int64_t)(cp)[6] << 8) |	\
	    ((u_int64_t)(cp)[5] << 16) | ((u_int64_t)(cp)[4] << 24) |	\
	    ((u_int64_t)(cp)[3] << 32) | ((u_int64_t)(cp)[2] << 40) |	\
	    ((u_int64_t)(cp)[1] << 48) | ((u_int64_t)(cp)[0] << 56);	\
} while (0)

#define BE_64_TO_8(cp, src) do {					\
	(cp)[0] = (src) >> 56;						\
        (cp)[1] = (src) >> 48;						\
	(cp)[2] = (src) >> 40;						\
	(cp)[3] = (src) >> 32;						\
	(cp)[4] = (src) >> 24;						\
	(cp)[5] = (src) >> 16;						\
	(cp)[6] = (src) >> 8;						\
	(cp)[7] = (src);						\
} while (0)

#define BE_32_TO_8(cp, src) do {					\
	(cp)[0] = (src) >> 24;						\
	(cp)[1] = (src) >> 16;						\
	(cp)[2] = (src) >> 8;						\
	(cp)[3] = (src);						\
} while (0)

/*
 * Macro for incrementally adding the unsigned 64-bit integer n to the
 * unsigned 128-bit integer (represented using a two-element array of
 * 64-bit words):
 */
#define ADDINC128(w,n) do {						\
	(w)[0] += (u_int64_t)(n);					\
	if ((w)[0] < (n)) {						\
		(w)[1]++;						\
	}								\
} while (0)

/*** THE SIX LOGICAL FUNCTIONS ****************************************/
/*
 * Bit shifting and rotation (used by the six SHA-XYZ logical functions:
 *
 *   NOTE:  The naming of R and S appears backwards here (R is a SHIFT and
 *   S is a ROTATION) because the SHA-224/256/384/512 description document
 *   (see http://csrc.nist.gov/cryptval/shs/sha256-384-512.pdf) uses this
 *   same "backwards" definition.
 */
/* Shift-right (used in SHA-224, SHA-256, SHA-384, and SHA-512): */
#define R(b,x) 		((x) >> (b))
/* 32-bit Rotate-right (used in SHA-224 and SHA-256): */
#define S32(b,x)	(((x) >> (b)) | ((x) << (32 - (b))))
/* 64-bit Rotate-right (used in SHA-384 and SHA-512): */
#define S64(b,x)	(((x) >> (b)) | ((x) << (64 - (b))))

/* Two of six logical functions used in SHA-224, SHA-256, SHA-384, and SHA-512: */
#define Ch(x,y,z)	(((x) & (y)) ^ ((~(x)) & (z)))
#define Maj(x,y,z)	(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

/* Four of six logical functions used in SHA-224 and SHA-256: */
#define Sigma0_256(x)	(S32(2,  (x)) ^ S32(13, (x)) ^ S32(22, (x)))
#define Sigma1_256(x)	(S32(6,  (x)) ^ S32(11, (x)) ^ S32(25, (x)))
#define sigma0_256(x)	(S32(7,  (x)) ^ S32(18, (x)) ^ R(3 ,   (x)))
#define sigma1_256(x)	(S32(17, (x)) ^ S32(19, (x)) ^ R(10,   (x)))

/* Four of six logical functions used in SHA-384 and SHA-512: */
#define Sigma0_512(x)	(S64(28, (x)) ^ S64(34, (x)) ^ S64(39, (x)))
#define Sigma1_512(x)	(S64(14, (x)) ^ S64(18, (x)) ^ S64(41, (x)))
#define sigma0_512(x)	(S64( 1, (x)) ^ S64( 8, (x)) ^ R( 7,   (x)))
#define sigma1_512(x)	(S64(19, (x)) ^ S64(61, (x)) ^ R( 6,   (x)))


/*** SHA-XYZ INITIAL HASH VALUES AND CONSTANTS ************************/
/* Hash constant words K for SHA-224 and SHA-256: */
static const u_int32_t K256[64] = {
	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL,
	0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,
	0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL,
	0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,
	0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,
	0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL,
	0xc6e00bf3UL, 0xd5a79147UL, 0x06ca6351UL, 0x14292967UL,
	0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL,
	0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL,
	0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,
	0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL,
	0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,
	0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
};

/* Initial hash value H for SHA-224: */
static const u_int32_t sha224_initial_hash_value[8] = {
	0xc1059ed8UL,
	0x367cd507UL,
	0x3070dd17UL,
	0xf70e5939UL,
	0xffc00b31UL,
	0x68581511UL,
	0x64f98fa7UL,
	0xbefa4fa4UL
};

/* Initial hash value H for SHA-256: */
static const u_int32_t sha256_initial_hash_value[8] = {
	0x6a09e667UL,
	0xbb67ae85UL,
	0x3c6ef372UL,
	0xa54ff53aUL,
	0x510e527fUL,
	0x9b05688cUL,
	0x1f83d9abUL,
	0x5be0cd19UL
};

/* Hash constant words K for SHA-384 and SHA-512: */
static const u_int64_t K512[80] = {
	0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
	0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
	0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
	0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
	0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
	0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
	0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
	0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
	0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
	0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
	0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
	0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
	0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
	0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
	0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
	0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
	0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
	0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
	0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
	0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
	0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
	0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
	0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
	0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
	0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
	0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
	0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
	0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
	0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
	0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
	0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
	0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
	0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
	0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
	0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
	0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
	0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
	0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
	0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
	0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
};

/* Initial hash value H for SHA-512 */
static const u_int64_t sha512_initial_hash_value[8] = {
	0x6a09e667f3bcc908ULL,
	0xbb67ae8584caa73bULL,
	0x3c6ef372fe94f82bULL,
	0xa54ff53a5f1d36f1ULL,
	0x510e527fade682d1ULL,
	0x9b05688c2b3e6c1fULL,
	0x1f83d9abfb41bd6bULL,
	0x5be0cd19137e2179ULL
};

#if !defined(SHA2_SMALL)
/* Initial hash value H for SHA-384 */
static const u_int64_t sha384_initial_hash_value[8] = {
	0xcbbb9d5dc1059ed8ULL,
	0x629a292a367cd507ULL,
	0x9159015a3070dd17ULL,
	0x152fecd8f70e5939ULL,
	0x67332667ffc00b31ULL,
	0x8eb44a8768581511ULL,
	0xdb0c2e0d64f98fa7ULL,
	0x47b5481dbefa4fa4ULL
};

/* Initial hash value H for SHA-512-256 */
static const u_int64_t sha512_256_initial_hash_value[8] = {
	0x22312194fc2bf72cULL,
	0x9f555fa3c84c64c2ULL,
	0x2393b86b6f53b151ULL,
	0x963877195940eabdULL,
	0x96283ee2a88effe3ULL,
	0xbe5e1e2553863992ULL,
	0x2b0199fc2c85b8aaULL,
	0x0eb72ddc81c52ca2ULL
};

/*** SHA-224: *********************************************************/
void
SHA224Init(SHA2_CTX *context)
{
	memcpy(context->state.st32, sha224_initial_hash_value,
	    sizeof(sha224_initial_hash_value));
	memset(context->buffer, 0, sizeof(context->buffer));
	context->bitcount[0] = 0;
}
DEF_WEAK(SHA224Init);

MAKE_CLONE(SHA224Transform, SHA256Transform);
MAKE_CLONE(SHA224Update, SHA256Update);
MAKE_CLONE(SHA224Pad, SHA256Pad);
DEF_WEAK(SHA224Transform);
DEF_WEAK(SHA224Update);
DEF_WEAK(SHA224Pad);

void
SHA224Final(u_int8_t digest[SHA224_DIGEST_LENGTH], SHA2_CTX *context)
{
	SHA224Pad(context);

#if BYTE_ORDER == LITTLE_ENDIAN
	int	i;

	/* Convert TO host byte order */
	for (i = 0; i < 7; i++)
		BE_32_TO_8(digest + i * 4, context->state.st32[i]);
#else
	memcpy(digest, context->state.st32, SHA224_DIGEST_LENGTH);
#endif
	explicit_bzero(context, sizeof(*context));
}
DEF_WEAK(SHA224Final);
#endif /* !defined(SHA2_SMALL) */

/*** SHA-256: *********************************************************/
void
SHA256Init(SHA2_CTX *context)
{
	memcpy(context->state.st32, sha256_initial_hash_value,
	    sizeof(sha256_initial_hash_value));
	memset(context->buffer, 0, sizeof(context->buffer));
	context->bitcount[0] = 0;
}
DEF_WEAK(SHA256Init);

#ifdef SHA2_UNROLL_TRANSFORM

/* Unrolled SHA-256 round macros: */

#define ROUND256_0_TO_15(a,b,c,d,e,f,g,h) do {				    \
	BE_8_TO_32(W256[j], data);					    \
	data += 4;							    \
	T1 = (h) + Sigma1_256((e)) + Ch((e), (f), (g)) + K256[j] + W256[j]; \
	(d) += T1;							    \
	(h) = T1 + Sigma0_256((a)) + Maj((a), (b), (c));		    \
	j++;								    \
} while(0)

#define ROUND256(a,b,c,d,e,f,g,h) do {					    \
	s0 = W256[(j+1)&0x0f];						    \
	s0 = sigma0_256(s0);						    \
	s1 = W256[(j+14)&0x0f];						    \
	s1 = sigma1_256(s1);						    \
	T1 = (h) + Sigma1_256((e)) + Ch((e), (f), (g)) + K256[j] +	    \
	     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);		    \
	(d) += T1;							    \
	(h) = T1 + Sigma0_256((a)) + Maj((a), (b), (c));		    \
	j++;								    \
} while(0)

void
SHA256Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])
{
	u_int32_t	a, b, c, d, e, f, g, h, s0, s1;
	u_int32_t	T1, W256[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];
	f = state[5];
	g = state[6];
	h = state[7];

	j = 0;
	do {
		/* Rounds 0 to 15 (unrolled): */
		ROUND256_0_TO_15(a,b,c,d,e,f,g,h);
		ROUND256_0_TO_15(h,a,b,c,d,e,f,g);
		ROUND256_0_TO_15(g,h,a,b,c,d,e,f);
		ROUND256_0_TO_15(f,g,h,a,b,c,d,e);
		ROUND256_0_TO_15(e,f,g,h,a,b,c,d);
		ROUND256_0_TO_15(d,e,f,g,h,a,b,c);
		ROUND256_0_TO_15(c,d,e,f,g,h,a,b);
		ROUND256_0_TO_15(b,c,d,e,f,g,h,a);
	} while (j < 16);

	/* Now for the remaining rounds up to 63: */
	do {
		ROUND256(a,b,c,d,e,f,g,h);
		ROUND256(h,a,b,c,d,e,f,g);
		ROUND256(g,h,a,b,c,d,e,f);
		ROUND256(f,g,h,a,b,c,d,e);
		ROUND256(e,f,g,h,a,b,c,d);
		ROUND256(d,e,f,g,h,a,b,c);
		ROUND256(c,d,e,f,g,h,a,b);
		ROUND256(b,c,d,e,f,g,h,a);
	} while (j < 64);

	/* Compute the current intermediate hash value */
	state[0] += a;
	state[1] += b;
	state[2] += c;
	state[3] += d;
	state[4] += e;
	state[5] += f;
	state[6] += g;
	state[7] += h;

	/* Clean up */
	a = b = c = d = e = f = g = h = T1 = 0;
}

#else /* SHA2_UNROLL_TRANSFORM */

void
SHA256Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])
{
	u_int32_t	a, b, c, d, e, f, g, h, s0, s1;
	u_int32_t	T1, T2, W256[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];
	f = state[5];
	g = state[6];
	h = state[7];

	j = 0;
	do {
		BE_8_TO_32(W256[j], data);
		data += 4;
		/* Apply the SHA-256 compression function to update a..h */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];
		T2 = Sigma0_256(a) + Maj(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		j++;
	} while (j < 16);

	do {
		/* Part of the message block expansion: */
		s0 = W256[(j+1)&0x0f];
		s0 = sigma0_256(s0);
		s1 = W256[(j+14)&0x0f];	
		s1 = sigma1_256(s1);

		/* Apply the SHA-256 compression function to update a..h */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + 
		     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);
		T2 = Sigma0_256(a) + Maj(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		j++;
	} while (j < 64);

	/* Compute the current intermediate hash value */
	state[0] += a;
	state[1] += b;
	state[2] += c;
	state[3] += d;
	state[4] += e;
	state[5] += f;
	state[6] += g;
	state[7] += h;

	/* Clean up */
	a = b = c = d = e = f = g = h = T1 = T2 = 0;
}

#endif /* SHA2_UNROLL_TRANSFORM */
DEF_WEAK(SHA256Transform);

void
SHA256Update(SHA2_CTX *context, const u_int8_t *data, size_t len)
{
	size_t	freespace, usedspace;

	/* Calling with no data is valid (we do nothing) */
	if (len == 0)
		return;

	usedspace = (context->bitcount[0] >> 3) % SHA256_BLOCK_LENGTH;
	if (usedspace > 0) {
		/* Calculate how much free space is available in the buffer */
		freespace = SHA256_BLOCK_LENGTH - usedspace;

		if (len >= freespace) {
			/* Fill the buffer completely and process it */
			memcpy(&context->buffer[usedspace], data, freespace);
			context->bitcount[0] += freespace << 3;
			len -= freespace;
			data += freespace;
			SHA256Transform(context->state.st32, context->buffer);
		} else {
			/* The buffer is not yet full */
			memcpy(&context->buffer[usedspace], data, len);
			context->bitcount[0] += len << 3;
			/* Clean up: */
			usedspace = freespace = 0;
			return;
		}
	}
	while (len >= SHA256_BLOCK_LENGTH) {
		/* Process as many complete blocks as we can */
		SHA256Transform(context->state.st32, data);
		context->bitcount[0] += SHA256_BLOCK_LENGTH << 3;
		len -= SHA256_BLOCK_LENGTH;
		data += SHA256_BLOCK_LENGTH;
	}
	if (len > 0) {
		/* There's left-overs, so save 'em */
		memcpy(context->buffer, data, len);
		context->bitcount[0] += len << 3;
	}
	/* Clean up: */
	usedspace = freespace = 0;
}
DEF_WEAK(SHA256Update);

void
SHA256Pad(SHA2_CTX *context)
{
	unsigned int	usedspace;

	usedspace = (context->bitcount[0] >> 3) % SHA256_BLOCK_LENGTH;
	if (usedspace > 0) {
		/* Begin padding with a 1 bit: */
		context->buffer[usedspace++] = 0x80;

		if (usedspace <= SHA256_SHORT_BLOCK_LENGTH) {
			/* Set-up for the last transform: */
			memset(&context->buffer[usedspace], 0,
			    SHA256_SHORT_BLOCK_LENGTH - usedspace);
		} else {
			if (usedspace < SHA256_BLOCK_LENGTH) {
				memset(&context->buffer[usedspace], 0,
				    SHA256_BLOCK_LENGTH - usedspace);
			}
			/* Do second-to-last transform: */
			SHA256Transform(context->state.st32, context->buffer);

			/* Prepare for last transform: */
			memset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);
		}
	} else {
		/* Set-up for the last transform: */
		memset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);

		/* Begin padding with a 1 bit: */
		*context->buffer = 0x80;
	}
	/* Store the length of input data (in bits) in big endian format: */
	BE_64_TO_8(&context->buffer[SHA256_SHORT_BLOCK_LENGTH],
	    context->bitcount[0]);

	/* Final transform: */
	SHA256Transform(context->state.st32, context->buffer);

	/* Clean up: */
	usedspace = 0;
}
DEF_WEAK(SHA256Pad);

void
SHA256Final(u_int8_t digest[SHA256_DIGEST_LENGTH], SHA2_CTX *context)
{
	SHA256Pad(context);

#if BYTE_ORDER == LITTLE_ENDIAN
	int	i;

	/* Convert TO host byte order */
	for (i = 0; i < 8; i++)
		BE_32_TO_8(digest + i * 4, context->state.st32[i]);
#else
	memcpy(digest, context->state.st32, SHA256_DIGEST_LENGTH);
#endif
	explicit_bzero(context, sizeof(*context));
}
DEF_WEAK(SHA256Final);


/*** SHA-512: *********************************************************/
void
SHA512Init(SHA2_CTX *context)
{
	memcpy(context->state.st64, sha512_initial_hash_value,
	    sizeof(sha512_initial_hash_value));
	memset(context->buffer, 0, sizeof(context->buffer));
	context->bitcount[0] = context->bitcount[1] =  0;
}
DEF_WEAK(SHA512Init);

#ifdef SHA2_UNROLL_TRANSFORM

/* Unrolled SHA-512 round macros: */

#define ROUND512_0_TO_15(a,b,c,d,e,f,g,h) do {				    \
	BE_8_TO_64(W512[j], data);					    \
	data += 8;							    \
	T1 = (h) + Sigma1_512((e)) + Ch((e), (f), (g)) + K512[j] + W512[j]; \
	(d) += T1;							    \
	(h) = T1 + Sigma0_512((a)) + Maj((a), (b), (c));		    \
	j++;								    \
} while(0)


#define ROUND512(a,b,c,d,e,f,g,h) do {					    \
	s0 = W512[(j+1)&0x0f];						    \
	s0 = sigma0_512(s0);						    \
	s1 = W512[(j+14)&0x0f];						    \
	s1 = sigma1_512(s1);						    \
	T1 = (h) + Sigma1_512((e)) + Ch((e), (f), (g)) + K512[j] +	    \
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);		    \
	(d) += T1;							    \
	(h) = T1 + Sigma0_512((a)) + Maj((a), (b), (c));		    \
	j++;								    \
} while(0)

void
SHA512Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])
{
	u_int64_t	a, b, c, d, e, f, g, h, s0, s1;
	u_int64_t	T1, W512[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];
	f = state[5];
	g = state[6];
	h = state[7];

	j = 0;
	do {
		/* Rounds 0 to 15 (unrolled): */
		ROUND512_0_TO_15(a,b,c,d,e,f,g,h);
		ROUND512_0_TO_15(h,a,b,c,d,e,f,g);
		ROUND512_0_TO_15(g,h,a,b,c,d,e,f);
		ROUND512_0_TO_15(f,g,h,a,b,c,d,e);
		ROUND512_0_TO_15(e,f,g,h,a,b,c,d);
		ROUND512_0_TO_15(d,e,f,g,h,a,b,c);
		ROUND512_0_TO_15(c,d,e,f,g,h,a,b);
		ROUND512_0_TO_15(b,c,d,e,f,g,h,a);
	} while (j < 16);

	/* Now for the remaining rounds up to 79: */
	do {
		ROUND512(a,b,c,d,e,f,g,h);
		ROUND512(h,a,b,c,d,e,f,g);
		ROUND512(g,h,a,b,c,d,e,f);
		ROUND512(f,g,h,a,b,c,d,e);
		ROUND512(e,f,g,h,a,b,c,d);
		ROUND512(d,e,f,g,h,a,b,c);
		ROUND512(c,d,e,f,g,h,a,b);
		ROUND512(b,c,d,e,f,g,h,a);
	} while (j < 80);

	/* Compute the current intermediate hash value */
	state[0] += a;
	state[1] += b;
	state[2] += c;
	state[3] += d;
	state[4] += e;
	state[5] += f;
	state[6] += g;
	state[7] += h;

	/* Clean up */
	a = b = c = d = e = f = g = h = T1 = 0;
}

#else /* SHA2_UNROLL_TRANSFORM */

void
SHA512Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])
{
	u_int64_t	a, b, c, d, e, f, g, h, s0, s1;
	u_int64_t	T1, T2, W512[16];
	int		j;

	/* Initialize registers with the prev. intermediate value */
	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];
	f = state[5];
	g = state[6];
	h = state[7];

	j = 0;
	do {
		BE_8_TO_64(W512[j], data);
		data += 8;
		/* Apply the SHA-512 compression function to update a..h */
		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];
		T2 = Sigma0_512(a) + Maj(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		j++;
	} while (j < 16);

	do {
		/* Part of the message block expansion: */
		s0 = W512[(j+1)&0x0f];
		s0 = sigma0_512(s0);
		s1 = W512[(j+14)&0x0f];
		s1 =  sigma1_512(s1);

		/* Apply the SHA-512 compression function to update a..h */
		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +
		     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
		T2 = Sigma0_512(a) + Maj(a, b, c);
		h = g;
		g = f;
		f = e;
		e = d + T1;
		d = c;
		c = b;
		b = a;
		a = T1 + T2;

		j++;
	} while (j < 80);

	/* Compute the current intermediate hash value */
	state[0] += a;
	state[1] += b;
	state[2] += c;
	state[3] += d;
	state[4] += e;
	state[5] += f;
	state[6] += g;
	state[7] += h;

	/* Clean up */
	a = b = c = d = e = f = g = h = T1 = T2 = 0;
}

#endif /* SHA2_UNROLL_TRANSFORM */
DEF_WEAK(SHA512Transform);

void
SHA512Update(SHA2_CTX *context, const u_int8_t *data, size_t len)
{
	size_t	freespace, usedspace;

	/* Calling with no data is valid (we do nothing) */
	if (len == 0)
		return;

	usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
	if (usedspace > 0) {
		/* Calculate how much free space is available in the buffer */
		freespace = SHA512_BLOCK_LENGTH - usedspace;

		if (len >= freespace) {
			/* Fill the buffer completely and process it */
			memcpy(&context->buffer[usedspace], data, freespace);
			ADDINC128(context->bitcount, freespace << 3);
			len -= freespace;
			data += freespace;
			SHA512Transform(context->state.st64, context->buffer);
		} else {
			/* The buffer is not yet full */
			memcpy(&context->buffer[usedspace], data, len);
			ADDINC128(context->bitcount, len << 3);
			/* Clean up: */
			usedspace = freespace = 0;
			return;
		}
	}
	while (len >= SHA512_BLOCK_LENGTH) {
		/* Process as many complete blocks as we can */
		SHA512Transform(context->state.st64, data);
		ADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);
		len -= SHA512_BLOCK_LENGTH;
		data += SHA512_BLOCK_LENGTH;
	}
	if (len > 0) {
		/* There's left-overs, so save 'em */
		memcpy(context->buffer, data, len);
		ADDINC128(context->bitcount, len << 3);
	}
	/* Clean up: */
	usedspace = freespace = 0;
}
DEF_WEAK(SHA512Update);

void
SHA512Pad(SHA2_CTX *context)
{
	unsigned int	usedspace;

	usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
	if (usedspace > 0) {
		/* Begin padding with a 1 bit: */
		context->buffer[usedspace++] = 0x80;

		if (usedspace <= SHA512_SHORT_BLOCK_LENGTH) {
			/* Set-up for the last transform: */
			memset(&context->buffer[usedspace], 0, SHA512_SHORT_BLOCK_LENGTH - usedspace);
		} else {
			if (usedspace < SHA512_BLOCK_LENGTH) {
				memset(&context->buffer[usedspace], 0, SHA512_BLOCK_LENGTH - usedspace);
			}
			/* Do second-to-last transform: */
			SHA512Transform(context->state.st64, context->buffer);

			/* And set-up for the last transform: */
			memset(context->buffer, 0, SHA512_BLOCK_LENGTH - 2);
		}
	} else {
		/* Prepare for final transform: */
		memset(context->buffer, 0, SHA512_SHORT_BLOCK_LENGTH);

		/* Begin padding with a 1 bit: */
		*context->buffer = 0x80;
	}
	/* Store the length of input data (in bits) in big endian format: */
	BE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH],
	    context->bitcount[1]);
	BE_64_TO_8(&context->buffer[SHA512_SHORT_BLOCK_LENGTH + 8],
	    context->bitcount[0]);

	/* Final transform: */
	SHA512Transform(context->state.st64, context->buffer);

	/* Clean up: */
	usedspace = 0;
}
DEF_WEAK(SHA512Pad);

void
SHA512Final(u_int8_t digest[SHA512_DIGEST_LENGTH], SHA2_CTX *context)
{
	SHA512Pad(context);

#if BYTE_ORDER == LITTLE_ENDIAN
	int	i;

	/* Convert TO host byte order */
	for (i = 0; i < 8; i++)
		BE_64_TO_8(digest + i * 8, context->state.st64[i]);
#else
	memcpy(digest, context->state.st64, SHA512_DIGEST_LENGTH);
#endif
	explicit_bzero(context, sizeof(*context));
}
DEF_WEAK(SHA512Final);

#if !defined(SHA2_SMALL)

/*** SHA-384: *********************************************************/
void
SHA384Init(SHA2_CTX *context)
{
	memcpy(context->state.st64, sha384_initial_hash_value,
	    sizeof(sha384_initial_hash_value));
	memset(context->buffer, 0, sizeof(context->buffer));
	context->bitcount[0] = context->bitcount[1] = 0;
}
DEF_WEAK(SHA384Init);

MAKE_CLONE(SHA384Transform, SHA512Transform);
MAKE_CLONE(SHA384Update, SHA512Update);
MAKE_CLONE(SHA384Pad, SHA512Pad);
DEF_WEAK(SHA384Transform);
DEF_WEAK(SHA384Update);
DEF_WEAK(SHA384Pad);

void
SHA384Final(u_int8_t digest[SHA384_DIGEST_LENGTH], SHA2_CTX *context)
{
	SHA384Pad(context);

#if BYTE_ORDER == LITTLE_ENDIAN
	int	i;

	/* Convert TO host byte order */
	for (i = 0; i < 6; i++)
		BE_64_TO_8(digest + i * 8, context->state.st64[i]);
#else
	memcpy(digest, context->state.st64, SHA384_DIGEST_LENGTH);
#endif
	/* Zero out state data */
	explicit_bzero(context, sizeof(*context));
}
DEF_WEAK(SHA384Final);

/*** SHA-512/256: *********************************************************/
void
SHA512_256Init(SHA2_CTX *context)
{
	memcpy(context->state.st64, sha512_256_initial_hash_value,
	    sizeof(sha512_256_initial_hash_value));
	memset(context->buffer, 0, sizeof(context->buffer));
	context->bitcount[0] = context->bitcount[1] = 0;
}
DEF_WEAK(SHA512_256Init);

MAKE_CLONE(SHA512_256Transform, SHA512Transform);
MAKE_CLONE(SHA512_256Update, SHA512Update);
MAKE_CLONE(SHA512_256Pad, SHA512Pad);
DEF_WEAK(SHA512_256Transform);
DEF_WEAK(SHA512_256Update);
DEF_WEAK(SHA512_256Pad);

void
SHA512_256Final(u_int8_t digest[SHA512_256_DIGEST_LENGTH], SHA2_CTX *context)
{
	SHA512_256Pad(context);

#if BYTE_ORDER == LITTLE_ENDIAN
	int	i;

	/* Convert TO host byte order */
	for (i = 0; i < 4; i++)
		BE_64_TO_8(digest + i * 8, context->state.st64[i]);
#else
	memcpy(digest, context->state.st64, SHA512_256_DIGEST_LENGTH);
#endif
	/* Zero out state data */
	explicit_bzero(context, sizeof(*context));
}
DEF_WEAK(SHA512_256Final);
#endif /* !defined(SHA2_SMALL) */
@


1.24
log
@Wrap blowfish, sha*, md5, and rmd160 so that internal calls go direct

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.23 2015/01/15 13:05:59 millert Exp $	*/
d291 12
d938 37
@


1.23
log
@Use explicit_bzero instead of memset in hash Final and End functions.
OK deraadt@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.22 2014/12/19 15:14:04 tedu Exp $	*/
d300 1
d302 6
a307 3
__weak_alias(SHA224Transform, SHA256Transform);
__weak_alias(SHA224Update, SHA256Update);
__weak_alias(SHA224Pad, SHA256Pad);
d325 1
d337 1
d496 1
d543 1
d587 1
d605 1
d617 1
d777 1
d824 1
d868 1
d886 1
d899 1
d901 6
a906 3
__weak_alias(SHA384Transform, SHA512Transform);
__weak_alias(SHA384Update, SHA512Update);
__weak_alias(SHA384Pad, SHA512Pad);
d925 1
@


1.22
log
@be like the kernel and only unroll if not small
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.21 2014/12/19 14:30:44 deraadt Exp $	*/
d319 1
a319 1
	memset(context, 0, sizeof(*context));
d594 1
a594 1
	memset(context, 0, sizeof(*context));
d870 1
a870 1
	memset(context, 0, sizeof(*context));
d904 1
a904 1
	memset(context, 0, sizeof(*context));
@


1.21
log
@i386 unrolling blows up the media in a big way, due to -Os for
ramdisk libc builds.  there has to be a better way without #ifdef's
in gross places, but I don't see it yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.20 2014/12/18 20:29:08 tedu Exp $	*/
d55 2
a56 1
#if defined(__amd64__)
d58 1
@


1.20
log
@only unroll on i386 and amd64 (where confirmed to be much faster).
naddy found sparc64 gets a little slower when unrolled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.19 2014/12/17 19:42:44 tedu Exp $	*/
d55 1
a55 1
#if defined(__amd64__) || defined(__i386__)
@


1.19
log
@unroll loops. much faster on amd64. ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.18 2014/07/20 04:22:34 guenther Exp $	*/
d55 1
d57 1
@


1.18
log
@From ISO/IEC 9899:1999 and 9899:201x,
6.11.5 - Storage-class specifiers:
    The placement of a storage-class specifier other than at the
    beginning of the declaration specifiers in a declaration is
    an obsolescent feature.

Diff from Jean-Philippe Ouellet (jean-philippe (at) ouellet.biz)
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.17 2014/01/08 06:14:57 tedu Exp $	*/
d55 1
@


1.17
log
@calling HashFinal with a null digest should crash, not be silently ignored
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.16 2014/01/08 04:35:34 deraadt Exp $	*/
d174 1
a174 1
const static u_int32_t K256[64] = {
d194 1
a194 1
const static u_int32_t sha224_initial_hash_value[8] = {
d206 1
a206 1
const static u_int32_t sha256_initial_hash_value[8] = {
d218 1
a218 1
const static u_int64_t K512[80] = {
d262 1
a262 1
const static u_int64_t sha512_initial_hash_value[8] = {
d275 1
a275 1
const static u_int64_t sha384_initial_hash_value[8] = {
@


1.16
log
@rename SHA256_ONLY to SHA2_SMALL; changing things so that sha512 support
is also pulled in
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.15 2013/12/22 22:55:51 tedu Exp $	*/
a304 2
	/* If no digest buffer is passed, we don't bother doing this: */
	if (digest != NULL) {
d306 1
a306 1
		int	i;
d308 3
a310 3
		/* Convert TO host byte order */
		for (i = 0; i < 7; i++)
			BE_32_TO_8(digest + i * 4, context->state.st32[i]);
d312 1
a312 1
		memcpy(digest, context->state.st32, SHA224_DIGEST_LENGTH);
d314 1
a314 2
		memset(context, 0, sizeof(*context));
	}
a579 2
	/* If no digest buffer is passed, we don't bother doing this: */
	if (digest != NULL) {
d581 1
a581 1
		int	i;
d583 3
a585 3
		/* Convert TO host byte order */
		for (i = 0; i < 8; i++)
			BE_32_TO_8(digest + i * 4, context->state.st32[i]);
d587 1
a587 1
		memcpy(digest, context->state.st32, SHA256_DIGEST_LENGTH);
d589 1
a589 2
		memset(context, 0, sizeof(*context));
	}
a855 2
	/* If no digest buffer is passed, we don't bother doing this: */
	if (digest != NULL) {
d857 1
a857 1
		int	i;
d859 3
a861 3
		/* Convert TO host byte order */
		for (i = 0; i < 8; i++)
			BE_64_TO_8(digest + i * 8, context->state.st64[i]);
d863 1
a863 1
		memcpy(digest, context->state.st64, SHA512_DIGEST_LENGTH);
d865 1
a865 2
		memset(context, 0, sizeof(*context));
	}
a888 2
	/* If no digest buffer is passed, we don't bother doing this: */
	if (digest != NULL) {
d890 1
a890 1
		int	i;
d892 3
a894 3
		/* Convert TO host byte order */
		for (i = 0; i < 6; i++)
			BE_64_TO_8(digest + i * 8, context->state.st64[i]);
d896 1
a896 1
		memcpy(digest, context->state.st64, SHA384_DIGEST_LENGTH);
a897 2
	}

@


1.15
log
@remove unneeded check for null context. ok deraadt gilles millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.14 2013/04/15 15:54:17 millert Exp $	*/
a216 1
#ifndef SHA256_ONLY
d261 13
a285 12
/* Initial hash value H for SHA-512 */
const static u_int64_t sha512_initial_hash_value[8] = {
	0x6a09e667f3bcc908ULL,
	0xbb67ae8584caa73bULL,
	0x3c6ef372fe94f82bULL,
	0xa54ff53a5f1d36f1ULL,
	0x510e527fade682d1ULL,
	0x9b05688c2b3e6c1fULL,
	0x1f83d9abfb41bd6bULL,
	0x5be0cd19137e2179ULL
};

d319 1
a319 1
#endif /* SHA256_ONLY */
a598 1
#ifndef SHA256_ONLY
d877 1
d914 1
a914 1
#endif /* SHA256_ONLY */
@


1.14
log
@SHA-224 is to SHA-256 as SHA-384 is to SHA-512.  It was added in a
later revision of FIPS-180.  OK miod@@ jmc@@ guenther@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.13 2009/04/15 00:55:52 djm Exp $	*/
a289 2
	if (context == NULL)
		return;
a324 2
	if (context == NULL)
		return;
a603 2
	if (context == NULL)
		return;
a882 2
	if (context == NULL)
		return;
@


1.13
log
@allow building without SHA384 and SHA512 (i.e. SHA256 only) with
-DSHA256_ONLY in order to save space; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.12 2008/09/06 12:00:19 djm Exp $	*/
d56 1
a56 1
/*** SHA-256/384/512 Machine Architecture Definitions *****************/
d89 1
a89 1
/*** SHA-256/384/512 Various Length Definitions ***********************/
d91 1
d144 1
a144 1
 *   S is a ROTATION) because the SHA-256/384/512 description document
d148 1
a148 1
/* Shift-right (used in SHA-256, SHA-384, and SHA-512): */
d150 1
a150 1
/* 32-bit Rotate-right (used in SHA-256): */
d155 1
a155 1
/* Two of six logical functions used in SHA-256, SHA-384, and SHA-512: */
d159 1
a159 1
/* Four of six logical functions used in SHA-256: */
d173 1
a173 1
/* Hash constant words K for SHA-256: */
d193 12
d285 36
@


1.12
log
@Rename SHA256/384/512 API to avoid namespace collisions with
forthcoming OpenSSL update.

Function names lose their underscore (SHA256_Init => SHA256Init) and
the various SHA256_CTX, SHA512_CTX are merged into a single SHA2_CTX
that is used for all these hashes.

ok millert@@ manpage bits jmc@@ "please commit" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.11 2005/08/08 08:05:35 espie Exp $	*/
d204 1
d272 1
a272 1

d554 1
d873 1
@


1.11
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.10 2004/05/28 15:10:27 millert Exp $	*/
d275 1
a275 1
SHA256_Init(SHA256_CTX *context)
d279 1
a279 1
	memcpy(context->state, sha256_initial_hash_value,
d282 1
a282 1
	context->bitcount = 0;
d311 1
a311 1
SHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])
d369 1
a369 1
SHA256_Transform(u_int32_t state[8], const u_int8_t data[SHA256_BLOCK_LENGTH])
d444 1
a444 1
SHA256_Update(SHA256_CTX *context, const u_int8_t *data, size_t len)
d452 1
a452 1
	usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
d460 1
a460 1
			context->bitcount += freespace << 3;
d463 1
a463 1
			SHA256_Transform(context->state, context->buffer);
d467 1
a467 1
			context->bitcount += len << 3;
d475 2
a476 2
		SHA256_Transform(context->state, data);
		context->bitcount += SHA256_BLOCK_LENGTH << 3;
d483 1
a483 1
		context->bitcount += len << 3;
d490 1
a490 1
SHA256_Pad(SHA256_CTX *context)
d494 1
a494 1
	usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
d509 1
a509 1
			SHA256_Transform(context->state, context->buffer);
d523 1
a523 1
	    context->bitcount);
d526 1
a526 1
	SHA256_Transform(context->state, context->buffer);
d533 1
a533 1
SHA256_Final(u_int8_t digest[SHA256_DIGEST_LENGTH], SHA256_CTX *context)
d535 1
a535 1
	SHA256_Pad(context);
d544 1
a544 1
			BE_32_TO_8(digest + i * 4, context->state[i]);
d546 1
a546 1
		memcpy(digest, context->state, SHA256_DIGEST_LENGTH);
d555 1
a555 1
SHA512_Init(SHA512_CTX *context)
d559 1
a559 1
	memcpy(context->state, sha512_initial_hash_value,
d592 1
a592 1
SHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])
d650 1
a650 1
SHA512_Transform(u_int64_t state[8], const u_int8_t data[SHA512_BLOCK_LENGTH])
d725 1
a725 1
SHA512_Update(SHA512_CTX *context, const u_int8_t *data, size_t len)
d744 1
a744 1
			SHA512_Transform(context->state, context->buffer);
d756 1
a756 1
		SHA512_Transform(context->state, data);
d771 1
a771 1
SHA512_Pad(SHA512_CTX *context)
d788 1
a788 1
			SHA512_Transform(context->state, context->buffer);
d807 1
a807 1
	SHA512_Transform(context->state, context->buffer);
d814 1
a814 1
SHA512_Final(u_int8_t digest[SHA512_DIGEST_LENGTH], SHA512_CTX *context)
d816 1
a816 1
	SHA512_Pad(context);
d825 1
a825 1
			BE_64_TO_8(digest + i * 8, context->state[i]);
d827 1
a827 1
		memcpy(digest, context->state, SHA512_DIGEST_LENGTH);
d836 1
a836 1
SHA384_Init(SHA384_CTX *context)
d840 1
a840 1
	memcpy(context->state, sha384_initial_hash_value,
d846 3
a848 3
__weak_alias(SHA384_Transform, SHA512_Transform);
__weak_alias(SHA384_Update, SHA512_Update);
__weak_alias(SHA384_Pad, SHA512_Pad);
d851 1
a851 1
SHA384_Final(u_int8_t digest[SHA384_DIGEST_LENGTH], SHA384_CTX *context)
d853 1
a853 1
	SHA384_Pad(context);
d862 1
a862 1
			BE_64_TO_8(digest + i * 8, context->state[i]);
d864 1
a864 1
		memcpy(digest, context->state, SHA384_DIGEST_LENGTH);
@


1.10
log
@In the Final function, move the context zeroing into the digest != NULL
scope so that passing a NULL digest is equivalent to the Pad function
(like it used to be).  Fixes skey w/ sha1 as noticed by David Krause.
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.9 2004/05/07 14:34:40 millert Exp $	*/
a35 4

#if defined(LIBC_SCCS) && !defined(lint)
static const char rcsid[] = "$OpenBSD: sha2.c,v 1.9 2004/05/07 14:34:40 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.9
log
@Simpler byte order flipping.  Now the only place we explicitly check
for the host byte order is when we copy the final digest (and that
is just an optimization).
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.8 2004/05/05 17:39:47 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: sha2.c,v 1.8 2004/05/05 17:39:47 millert Exp $";
d552 1
a553 3

	/* Zero out state data */
	memset(context, 0, sizeof(*context));
d833 1
a834 3

	/* Zero out state data */
	memset(context, 0, sizeof(*context));
@


1.8
log
@Make the Transform functions match the other hash types and document them.
Use sizeof() in the Init functions where it makes sense.
Use weak aliases instead of wrapper functions.

Probably should have gone in before the major bump but as these are only
used internally by the sha2 functions themselves there should be no problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.7 2004/05/03 17:30:15 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: sha2.c,v 1.7 2004/05/03 17:30:15 millert Exp $";
a59 1

d99 5
d105 24
a128 16
/*** ENDIAN REVERSAL MACROS *******************************************/
#if BYTE_ORDER == LITTLE_ENDIAN
#define REVERSE32(w,x)	{ \
	u_int32_t tmp = (w); \
	tmp = (tmp >> 16) | (tmp << 16); \
	(x) = ((tmp & 0xff00ff00UL) >> 8) | ((tmp & 0x00ff00ffUL) << 8); \
}
#define REVERSE64(w,x)	{ \
	u_int64_t tmp = (w); \
	tmp = (tmp >> 32) | (tmp << 32); \
	tmp = ((tmp & 0xff00ff00ff00ff00ULL) >> 8) | \
	      ((tmp & 0x00ff00ff00ff00ffULL) << 8); \
	(x) = ((tmp & 0xffff0000ffff0000ULL) >> 16) | \
	      ((tmp & 0x0000ffff0000ffffULL) << 16); \
}
#endif /* BYTE_ORDER == LITTLE_ENDIAN */
d135 6
a140 6
#define ADDINC128(w,n)	{ \
	(w)[0] += (u_int64_t)(n); \
	if ((w)[0] < (n)) { \
		(w)[1]++; \
	} \
}
d294 1
a294 2
	W256[j] = (u_int32_t)data[3] | ((u_int32_t)data[2] << 8) |	    \
	    ((u_int32_t)data[1] << 16) | ((u_int32_t)data[0] << 24);	    \
d391 1
a391 2
		W256[j] = (u_int32_t)data[3] | ((u_int32_t)data[2] << 8) |
		    ((u_int32_t)data[1] << 16) | ((u_int32_t)data[0] << 24);
a498 4
#if BYTE_ORDER == LITTLE_ENDIAN
	/* Convert FROM host byte order */
	REVERSE64(context->bitcount, context->bitcount);
#endif
d525 3
a527 2
	/* Store the length of input data (in bits): */
	*(u_int64_t *)&context->buffer[SHA256_SHORT_BLOCK_LENGTH] = context->bitcount;
d537 1
a537 1
SHA256_Final(u_int8_t digest[], SHA256_CTX *context)
a538 2
	u_int32_t	*d = (u_int32_t *)digest;

d544 2
d547 2
a548 5
		int	j;
		for (j = 0; j < 8; j++) {
			REVERSE32(context->state[j], context->state[j]);
			*d++ = context->state[j];
		}
d550 1
a550 1
		memcpy(d, context->state, SHA256_DIGEST_LENGTH);
d576 1
a576 4
	W512[j] = (u_int64_t)data[7] | ((u_int64_t)data[6] << 8) |	    \
	    ((u_int64_t)data[5] << 16) | ((u_int64_t)data[4] << 24) |	    \
	    ((u_int64_t)data[3] << 32) | ((u_int64_t)data[2] << 40) |	    \
	    ((u_int64_t)data[1] << 48) | ((u_int64_t)data[0] << 56);	    \
d674 1
a674 4
		W512[j] = (u_int64_t)data[7] | ((u_int64_t)data[6] << 8) |
		    ((u_int64_t)data[5] << 16) | ((u_int64_t)data[4] << 24) |
		    ((u_int64_t)data[3] << 32) | ((u_int64_t)data[2] << 40) |
		    ((u_int64_t)data[1] << 48) | ((u_int64_t)data[0] << 56);
a781 5
#if BYTE_ORDER == LITTLE_ENDIAN
	/* Convert FROM host byte order */
	REVERSE64(context->bitcount[0],context->bitcount[0]);
	REVERSE64(context->bitcount[1],context->bitcount[1]);
#endif
d806 5
a810 3
	/* Store the length of input data (in bits): */
	*(u_int64_t *)&context->buffer[SHA512_SHORT_BLOCK_LENGTH] = context->bitcount[1];
	*(u_int64_t *)&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8] = context->bitcount[0];
d820 1
a820 1
SHA512_Final(u_int8_t digest[], SHA512_CTX *context)
a821 2
	u_int64_t	*d = (u_int64_t *)digest;

d827 2
d830 2
a831 5
		int	j;
		for (j = 0; j < 8; j++) {
			REVERSE64(context->state[j],context->state[j]);
			*d++ = context->state[j];
		}
d833 1
a833 1
		memcpy(d, context->state, SHA512_DIGEST_LENGTH);
d859 1
a859 1
SHA384_Final(u_int8_t digest[], SHA384_CTX *context)
a860 2
	u_int64_t	*d = (u_int64_t *)digest;

d866 2
d869 2
a870 5
		int	j;
		for (j = 0; j < 6; j++) {
			REVERSE64(context->state[j],context->state[j]);
			*d++ = context->state[j];
		}
d872 1
a872 1
		memcpy(d, context->state, SHA384_DIGEST_LENGTH);
@


1.7
log
@Add Pad and FileChunk functions for each family of hash functions.
The Pad function does padding like in Final but does not finish processing.
The FileChunk function creates a digest from a portion of a file.
Also made the length parameters consistent (and size_t).
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.6 2004/05/03 02:57:47 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: sha2.c,v 1.6 2004/05/03 02:57:47 millert Exp $";
a161 8
/*** INTERNAL FUNCTION PROTOTYPES *************************************/
/* NOTE: These should not be accessed directly from outside this
 * library -- they are intended for private internal visibility/use
 * only.
 */
void SHA256_Transform(SHA256_CTX *, const u_int8_t *);
void SHA512_Transform(SHA512_CTX *, const u_int8_t *);

d271 3
a273 2
	memcpy(context->state, sha256_initial_hash_value, SHA256_DIGEST_LENGTH);
	memset(context->buffer, 0, SHA256_BLOCK_LENGTH);
d304 1
a304 1
SHA256_Transform(SHA256_CTX *context, const u_int8_t *data)
d307 1
a307 1
	u_int32_t	T1, *W256;
a309 2
	W256 = (u_int32_t *)context->buffer;

d311 8
a318 8
	a = context->state[0];
	b = context->state[1];
	c = context->state[2];
	d = context->state[3];
	e = context->state[4];
	f = context->state[5];
	g = context->state[6];
	h = context->state[7];
d346 8
a353 8
	context->state[0] += a;
	context->state[1] += b;
	context->state[2] += c;
	context->state[3] += d;
	context->state[4] += e;
	context->state[5] += f;
	context->state[6] += g;
	context->state[7] += h;
d362 1
a362 1
SHA256_Transform(SHA256_CTX *context, const u_int8_t *data)
d365 1
a365 1
	u_int32_t	T1, T2, *W256;
a367 2
	W256 = (u_int32_t *)context->buffer;

d369 8
a376 8
	a = context->state[0];
	b = context->state[1];
	c = context->state[2];
	d = context->state[3];
	e = context->state[4];
	f = context->state[5];
	g = context->state[6];
	h = context->state[7];
d422 8
a429 8
	context->state[0] += a;
	context->state[1] += b;
	context->state[2] += c;
	context->state[3] += d;
	context->state[4] += e;
	context->state[5] += f;
	context->state[6] += g;
	context->state[7] += h;
d457 1
a457 1
			SHA256_Transform(context, context->buffer);
d469 1
a469 1
		SHA256_Transform(context, data);
d507 1
a507 1
			SHA256_Transform(context, context->buffer);
d523 1
a523 1
	SHA256_Transform(context, context->buffer);
d561 3
a563 2
	memcpy(context->state, sha512_initial_hash_value, SHA512_DIGEST_LENGTH);
	memset(context->buffer, 0, SHA512_BLOCK_LENGTH);
d597 1
a597 1
SHA512_Transform(SHA512_CTX *context, const u_int8_t *data)
d600 1
a600 1
	u_int64_t	T1, *W512;
a602 2
	W512 = (u_int64_t *)context->buffer;

d604 8
a611 8
	a = context->state[0];
	b = context->state[1];
	c = context->state[2];
	d = context->state[3];
	e = context->state[4];
	f = context->state[5];
	g = context->state[6];
	h = context->state[7];
d639 8
a646 8
	context->state[0] += a;
	context->state[1] += b;
	context->state[2] += c;
	context->state[3] += d;
	context->state[4] += e;
	context->state[5] += f;
	context->state[6] += g;
	context->state[7] += h;
d655 1
a655 1
SHA512_Transform(SHA512_CTX *context, const u_int8_t *data)
d658 1
a658 1
	u_int64_t	T1, T2, *W512;
a660 2
	W512 = (u_int64_t *)context->buffer;

d662 8
a669 8
	a = context->state[0];
	b = context->state[1];
	c = context->state[2];
	d = context->state[3];
	e = context->state[4];
	f = context->state[5];
	g = context->state[6];
	h = context->state[7];
d717 8
a724 8
	context->state[0] += a;
	context->state[1] += b;
	context->state[2] += c;
	context->state[3] += d;
	context->state[4] += e;
	context->state[5] += f;
	context->state[6] += g;
	context->state[7] += h;
d752 1
a752 1
			SHA512_Transform(context, context->buffer);
d764 1
a764 1
		SHA512_Transform(context, data);
d801 1
a801 1
			SHA512_Transform(context, context->buffer);
d818 1
a818 1
	SHA512_Transform(context, context->buffer);
d856 3
a858 2
	memcpy(context->state, sha384_initial_hash_value, SHA512_DIGEST_LENGTH);
	memset(context->buffer, 0, SHA384_BLOCK_LENGTH);
d862 2
a863 6
void
SHA384_Update(SHA384_CTX *context, const u_int8_t *data, size_t len)
{
	SHA512_Update((SHA512_CTX *)context, data, len);
}

@


1.6
log
@Rev 1.4 was bogus (committed from the wrong tree), this repairs it.
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.3 2004/04/28 22:06:02 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: sha2.c,v 1.5 2004/05/02 23:53:47 millert Exp $";
a166 1
void SHA512_Last(SHA512_CTX *);
d342 1
a342 1
	/* Now for the remaining rounds to 64: */
d495 1
a495 1
SHA256_Final(u_int8_t digest[], SHA256_CTX *context)
a496 1
	u_int32_t	*d = (u_int32_t *)digest;
d499 1
a499 3
	/* If no digest buffer is passed, we don't bother doing this: */
	if (digest != NULL) {
		usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
d501 2
a502 2
		/* Convert FROM host byte order */
		REVERSE64(context->bitcount,context->bitcount);
d504 3
a506 13
		if (usedspace > 0) {
			/* Begin padding with a 1 bit: */
			context->buffer[usedspace++] = 0x80;

			if (usedspace <= SHA256_SHORT_BLOCK_LENGTH) {
				/* Set-up for the last transform: */
				memset(&context->buffer[usedspace], 0, SHA256_SHORT_BLOCK_LENGTH - usedspace);
			} else {
				if (usedspace < SHA256_BLOCK_LENGTH) {
					memset(&context->buffer[usedspace], 0, SHA256_BLOCK_LENGTH - usedspace);
				}
				/* Do second-to-last transform: */
				SHA256_Transform(context, context->buffer);
d508 8
a515 2
				/* And set-up for the last transform: */
				memset(context->buffer, 0, SHA256_SHORT_BLOCK_LENGTH);
d517 4
a520 2
		} else {
			/* Set-up for the last transform: */
d522 17
d540 4
a543 5
			/* Begin padding with a 1 bit: */
			*context->buffer = 0x80;
		}
		/* Set the bit count: */
		*(u_int64_t *)&context->buffer[SHA256_SHORT_BLOCK_LENGTH] = context->bitcount;
d545 1
a545 2
		/* Final transform: */
		SHA256_Transform(context, context->buffer);
d547 2
d550 5
a554 7
		{
			/* Convert TO host byte order */
			int	j;
			for (j = 0; j < 8; j++) {
				REVERSE32(context->state[j],context->state[j]);
				*d++ = context->state[j];
			}
d561 1
a561 1
	/* Clean up state data: */
a562 1
	usedspace = 0;
d610 1
a610 1
	u_int64_t	T1, *W512 = (u_int64_t *)context->buffer;
d613 2
d627 1
d670 1
a670 1
	u_int64_t	T1, T2, *W512 = (u_int64_t *)context->buffer;
d673 2
d793 1
a793 1
SHA512_Last(SHA512_CTX *context)
d833 3
d843 2
a846 3
		SHA512_Last(context);

		/* Save the hash data for output: */
d848 5
a852 7
		{
			/* Convert TO host byte order */
			int	j;
			for (j = 0; j < 8; j++) {
				REVERSE64(context->state[j],context->state[j]);
				*d++ = context->state[j];
			}
d881 2
d888 2
a891 3
		SHA512_Last((SHA512_CTX *)context);

		/* Save the hash data for output: */
d893 5
a897 7
		{
			/* Convert TO host byte order */
			int	j;
			for (j = 0; j < 6; j++) {
				REVERSE64(context->state[j],context->state[j]);
				*d++ = context->state[j];
			}
@


1.5
log
@some minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.4 2004/04/29 14:13:17 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: sha2.c,v 1.4 2004/04/29 14:13:17 millert Exp $";
d168 2
a169 2
void SHA256_Transform(SHA256_CTX *, const u_int32_t *);
void SHA512_Transform(SHA512_CTX *, const u_int64_t *);
d289 21
a309 32
#if BYTE_ORDER == LITTLE_ENDIAN

#define ROUND256_0_TO_15(a,b,c,d,e,f,g,h)	\
	REVERSE32(*data++, W256[j]); \
	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + \
             K256[j] + W256[j]; \
	(d) += T1; \
	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
	j++


#else /* BYTE_ORDER == LITTLE_ENDIAN */

#define ROUND256_0_TO_15(a,b,c,d,e,f,g,h)	\
	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + \
	     K256[j] + (W256[j] = *data++); \
	(d) += T1; \
	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
	j++

#endif /* BYTE_ORDER == LITTLE_ENDIAN */

#define ROUND256(a,b,c,d,e,f,g,h)	\
	s0 = W256[(j+1)&0x0f]; \
	s0 = sigma0_256(s0); \
	s1 = W256[(j+14)&0x0f]; \
	s1 = sigma1_256(s1); \
	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + K256[j] + \
	     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0); \
	(d) += T1; \
	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
	j++
d312 1
a312 1
SHA256_Transform(SHA256_CTX *context, const u_int32_t *data)
d372 1
a372 1
SHA256_Transform(SHA256_CTX *context, const u_int32_t *data)
d392 3
a394 3
#if BYTE_ORDER == LITTLE_ENDIAN
		/* Copy data while converting to host byte order */
		REVERSE32(*data++, W256[j]);
a396 4
#else /* BYTE_ORDER == LITTLE_ENDIAN */
		/* Apply the SHA-256 compression function to update a..h with copy */
		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + (W256[j] = *data++);
#endif /* BYTE_ORDER == LITTLE_ENDIAN */
d469 1
a469 1
			SHA256_Transform(context, (u_int32_t *)context->buffer);
d481 1
a481 1
		SHA256_Transform(context, (const u_int32_t *)data);
d520 1
a520 1
				SHA256_Transform(context, (u_int32_t *)context->buffer);
d536 1
a536 1
		SHA256_Transform(context, (u_int32_t *)context->buffer);
a571 21
#if BYTE_ORDER == LITTLE_ENDIAN

#define ROUND512_0_TO_15(a,b,c,d,e,f,g,h)	\
	REVERSE64(*data++, W512[j]); \
	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + \
             K512[j] + W512[j]; \
	(d) += T1, \
	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)), \
	j++


#else /* BYTE_ORDER == LITTLE_ENDIAN */

#define ROUND512_0_TO_15(a,b,c,d,e,f,g,h)	\
	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + \
             K512[j] + (W512[j] = *data++); \
	(d) += T1; \
	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
	j++

#endif /* BYTE_ORDER == LITTLE_ENDIAN */
d573 24
a596 10
#define ROUND512(a,b,c,d,e,f,g,h)	\
	s0 = W512[(j+1)&0x0f]; \
	s0 = sigma0_512(s0); \
	s1 = W512[(j+14)&0x0f]; \
	s1 = sigma1_512(s1); \
	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + K512[j] + \
             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0); \
	(d) += T1; \
	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
	j++
d599 1
a599 1
SHA512_Transform(SHA512_CTX *context, const u_int64_t *data)
d656 1
a656 1
SHA512_Transform(SHA512_CTX *context, const u_int64_t *data)
d678 1
a678 1
		data++;
d753 1
a753 1
			SHA512_Transform(context, (u_int64_t *)context->buffer);
d765 1
a765 1
		SHA512_Transform(context, (const u_int64_t *)data);
d802 1
a802 1
			SHA512_Transform(context, (u_int64_t *)context->buffer);
d819 1
a819 1
	SHA512_Transform(context, (u_int64_t *)context->buffer);
@


1.4
log
@The data pointer passed to the transform function may not be properly
aligned so copy it in a way that a) is endian indepenent and b) does
not rely on alignment.  Problem found and solution tested by hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.3 2004/04/28 22:06:02 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: sha2.c,v 1.3 2004/04/28 22:06:02 millert Exp $";
d276 3
a278 2
SHA256_Init(SHA256_CTX *context) {
	if (context == (SHA256_CTX *)0) {
a279 1
	}
d323 2
a324 1
SHA256_Transform(SHA256_CTX *context, const u_int32_t *data) {
d383 2
a384 1
SHA256_Transform(SHA256_CTX *context, const u_int32_t *data) {
d465 3
a467 2
SHA256_Update(SHA256_CTX *context, const u_int8_t *data, size_t len) {
	unsigned int	freespace, usedspace;
d469 2
a470 2
	if (len == 0) {
		/* Calling with no data is valid - we do nothing */
a471 1
	}
d511 2
a512 1
SHA256_Final(u_int8_t digest[], SHA256_CTX *context) {
d517 1
a517 1
	if (digest != (u_int8_t *)0) {
d575 3
a577 2
SHA512_Init(SHA512_CTX *context) {
	if (context == (SHA512_CTX *)0) {
a578 1
	}
d621 2
a622 1
SHA512_Transform(SHA512_CTX *context, const u_int64_t *data) {
d678 2
a679 1
SHA512_Transform(SHA512_CTX *context, const u_int64_t *data) {
d756 3
a758 2
SHA512_Update(SHA512_CTX *context, const u_int8_t *data, size_t len) {
	unsigned int	freespace, usedspace;
d760 2
a761 2
	if (len == 0) {
		/* Calling with no data is valid - we do nothing */
a762 1
	}
d802 2
a803 1
SHA512_Last(SHA512_CTX *context) {
d845 2
a846 1
SHA512_Final(u_int8_t digest[], SHA512_CTX *context) {
d850 1
a850 1
	if (digest != (u_int8_t *)0) {
d875 3
a877 2
SHA384_Init(SHA384_CTX *context) {
	if (context == (SHA384_CTX *)0) {
a878 1
	}
d885 2
a886 1
SHA384_Update(SHA384_CTX *context, const u_int8_t *data, size_t len) {
d891 2
a892 1
SHA384_Final(u_int8_t digest[], SHA384_CTX *context) {
d896 1
a896 1
	if (digest != (u_int8_t *)0) {
@


1.3
log
@KNF: function names should be at column 0 for easier grepping.
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.2 2003/09/08 00:00:47 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: sha2.c,v 1.2 2003/09/08 00:00:47 millert Exp $";
d691 5
a695 3
#if BYTE_ORDER == LITTLE_ENDIAN
		/* Convert TO host byte order */
		REVERSE64(*data++, W512[j]);
a697 4
#else /* BYTE_ORDER == LITTLE_ENDIAN */
		/* Apply the SHA-512 compression function to update a..h with copy */
		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + (W512[j] = *data++);
#endif /* BYTE_ORDER == LITTLE_ENDIAN */
@


1.2
log
@Zap context correctly, from Juergen Buchmueller <pullmoll at stop1984 dot com>
Same as sys/crypto/sha2.c revision 1.2
@
text
@d1 1
a1 1
/*	$OpenBSD: sha2.c,v 1.1 2003/05/08 23:34:55 millert Exp $	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD: sha2.c,v 1.1 2003/05/08 23:34:55 millert Exp $";
d275 2
a276 1
void SHA256_Init(SHA256_CTX *context) {
d322 2
a323 1
void SHA256_Transform(SHA256_CTX *context, const u_int32_t *data) {
d381 2
a382 1
void SHA256_Transform(SHA256_CTX *context, const u_int32_t *data) {
d462 2
a463 1
void SHA256_Update(SHA256_CTX *context, const u_int8_t *data, size_t len) {
d508 2
a509 1
void SHA256_Final(u_int8_t digest[], SHA256_CTX *context) {
d571 2
a572 1
void SHA512_Init(SHA512_CTX *context) {
d617 2
a618 1
void SHA512_Transform(SHA512_CTX *context, const u_int64_t *data) {
d673 2
a674 1
void SHA512_Transform(SHA512_CTX *context, const u_int64_t *data) {
d752 2
a753 1
void SHA512_Update(SHA512_CTX *context, const u_int8_t *data, size_t len) {
d798 2
a799 1
void SHA512_Last(SHA512_CTX *context) {
d840 2
a841 1
void SHA512_Final(u_int8_t digest[], SHA512_CTX *context) {
d869 2
a870 1
void SHA384_Init(SHA384_CTX *context) {
d879 2
a880 1
void SHA384_Update(SHA384_CTX *context, const u_int8_t *data, size_t len) {
d884 2
a885 1
void SHA384_Final(u_int8_t digest[], SHA384_CTX *context) {
@


1.1
log
@Add sha2 routines based on code by Aaron D. Gifford with minor
massaging and a man page by me.  I used the phk-derived stuff for
sha2hl.c instead of Aaron's for consistency with our other hash
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
static const char rcsid[] = "$OpenBSD$";
d560 1
a560 1
	memset(context, 0, sizeof(context));
d853 1
a853 1
	memset(context, 0, sizeof(context));
d894 1
a894 1
	memset(context, 0, sizeof(context));
@

