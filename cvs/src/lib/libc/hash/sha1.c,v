head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.10
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.8
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.18
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.16
	OPENBSD_5_0:1.21.0.14
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.12
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.10
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.6
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.12
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.10
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.8
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.22
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.20
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.18
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.16
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.10
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.26
date	2015.09.11.09.18.27;	author guenther;	state Exp;
branches;
next	1.25;
commitid	Ug7ZHdkfaIoV0KLN;

1.25
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	0DYulI8hhujBHMcR;

1.24
date	2015.01.15.13.05.59;	author millert;	state Exp;
branches;
next	1.23;
commitid	gkpEJvpVgT62ZVxP;

1.23
date	2014.01.08.06.14.57;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2012.08.27.21.05.43;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.29.19.32.50;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.28.15.10.27;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.05.17.09.46;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.03.18.05.08;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.03.17.30.15;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.27.15.54.56;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.26.19.38.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.31.23.41.53;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.21.20.37.08;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.08.19.53.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.23.04.33.31;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.07.23.21.12.32;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.07.15.01.54.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.07.12.00.51.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.07.11.04.17.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.10.22.52.59;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.30.23.27.05;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.30.04.01.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.09.29.17.18.17;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.09.29.16.15.05;	author millert;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Wrap blowfish, sha*, md5, and rmd160 so that internal calls go direct

ok deraadt@@
@
text
@/*	$OpenBSD: sha1.c,v 1.25 2015/01/16 16:48:51 deraadt Exp $	*/

/*
 * SHA-1 in C
 * By Steve Reid <steve@@edmweb.com>
 * 100% Public Domain
 *
 * Test Vectors (from FIPS PUB 180-1)
 * "abc"
 *   A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
 * "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
 *   84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
 * A million repetitions of "a"
 *   34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
 */

#include <sys/types.h>
#include <string.h>
#include <sha1.h>

#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

/*
 * blk0() and blk() perform the initial expand.
 * I got the idea of expanding during the round function from SSLeay
 */
#if BYTE_ORDER == LITTLE_ENDIAN
# define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
    |(rol(block->l[i],8)&0x00FF00FF))
#else
# define blk0(i) block->l[i]
#endif
#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
    ^block->l[(i+2)&15]^block->l[i&15],1))

/*
 * (R0+R1), R2, R3, R4 are the different operations (rounds) used in SHA1
 */
#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);

typedef union {
	u_int8_t c[64];
	u_int32_t l[16];
} CHAR64LONG16;

/*
 * Hash a single 512-bit block. This is the core of the algorithm.
 */
void
SHA1Transform(u_int32_t state[5], const u_int8_t buffer[SHA1_BLOCK_LENGTH])
{
	u_int32_t a, b, c, d, e;
	u_int8_t workspace[SHA1_BLOCK_LENGTH];
	CHAR64LONG16 *block = (CHAR64LONG16 *)workspace;

	(void)memcpy(block, buffer, SHA1_BLOCK_LENGTH);

	/* Copy context->state[] to working vars */
	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];

	/* 4 rounds of 20 operations each. Loop unrolled. */
	R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
	R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
	R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
	R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
	R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
	R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
	R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
	R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
	R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
	R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
	R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
	R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
	R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
	R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
	R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
	R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
	R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
	R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
	R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
	R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);

	/* Add the working vars back into context.state[] */
	state[0] += a;
	state[1] += b;
	state[2] += c;
	state[3] += d;
	state[4] += e;

	/* Wipe variables */
	a = b = c = d = e = 0;
}
DEF_WEAK(SHA1Transform);


/*
 * SHA1Init - Initialize new context
 */
void
SHA1Init(SHA1_CTX *context)
{

	/* SHA1 initialization constants */
	context->count = 0;
	context->state[0] = 0x67452301;
	context->state[1] = 0xEFCDAB89;
	context->state[2] = 0x98BADCFE;
	context->state[3] = 0x10325476;
	context->state[4] = 0xC3D2E1F0;
}
DEF_WEAK(SHA1Init);


/*
 * Run your data through this.
 */
void
SHA1Update(SHA1_CTX *context, const u_int8_t *data, size_t len)
{
	size_t i, j;

	j = (size_t)((context->count >> 3) & 63);
	context->count += (len << 3);
	if ((j + len) > 63) {
		(void)memcpy(&context->buffer[j], data, (i = 64-j));
		SHA1Transform(context->state, context->buffer);
		for ( ; i + 63 < len; i += 64)
			SHA1Transform(context->state, (u_int8_t *)&data[i]);
		j = 0;
	} else {
		i = 0;
	}
	(void)memcpy(&context->buffer[j], &data[i], len - i);
}
DEF_WEAK(SHA1Update);


/*
 * Add padding and return the message digest.
 */
void
SHA1Pad(SHA1_CTX *context)
{
	u_int8_t finalcount[8];
	u_int i;

	for (i = 0; i < 8; i++) {
		finalcount[i] = (u_int8_t)((context->count >>
		    ((7 - (i & 7)) * 8)) & 255);	/* Endian independent */
	}
	SHA1Update(context, (u_int8_t *)"\200", 1);
	while ((context->count & 504) != 448)
		SHA1Update(context, (u_int8_t *)"\0", 1);
	SHA1Update(context, finalcount, 8); /* Should cause a SHA1Transform() */
}
DEF_WEAK(SHA1Pad);

void
SHA1Final(u_int8_t digest[SHA1_DIGEST_LENGTH], SHA1_CTX *context)
{
	u_int i;

	SHA1Pad(context);
	for (i = 0; i < SHA1_DIGEST_LENGTH; i++) {
		digest[i] = (u_int8_t)
		   ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
	}
	explicit_bzero(context, sizeof(*context));
}
DEF_WEAK(SHA1Final);
@


1.25
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.24 2015/01/15 13:05:59 millert Exp $	*/
d101 1
d119 1
d143 1
d164 1
d178 1
@


1.24
log
@Use explicit_bzero instead of memset in hash Final and End functions.
OK deraadt@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.23 2014/01/08 06:14:57 tedu Exp $	*/
d17 1
a17 1
#include <sys/param.h>
@


1.23
log
@calling HashFinal with a null digest should crash, not be silently ignored
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.22 2012/08/27 21:05:43 miod Exp $	*/
d172 1
a172 1
	memset(context, 0, sizeof(*context));
@


1.22
log
@Remove landisk gcc 3 compiler workaround. Reminded by martynas@@ and brad
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.21 2008/07/29 19:32:50 miod Exp $	*/
d168 3
a170 6
	if (digest) {
		for (i = 0; i < SHA1_DIGEST_LENGTH; i++) {
			digest[i] = (u_int8_t)
			   ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
		}
		memset(context, 0, sizeof(*context));
d172 1
@


1.21
log
@Split SHA1Transform() back into smaller pieces when compiling on landisk,
to defeat gcc optimization bugs. Similar to what had been done on sparc64
in the past.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.20 2005/08/08 08:05:35 espie Exp $	*/
a49 53
#ifdef __sh__
static void do_R01(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *);
static void do_R2(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *);
static void do_R3(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *);
static void do_R4(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *);

#define nR0(v,w,x,y,z,i) R0(*v,*w,*x,*y,*z,i)
#define nR1(v,w,x,y,z,i) R1(*v,*w,*x,*y,*z,i)
#define nR2(v,w,x,y,z,i) R2(*v,*w,*x,*y,*z,i)
#define nR3(v,w,x,y,z,i) R3(*v,*w,*x,*y,*z,i)
#define nR4(v,w,x,y,z,i) R4(*v,*w,*x,*y,*z,i)

static void
do_R01(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)
{
    nR0(a,b,c,d,e, 0); nR0(e,a,b,c,d, 1); nR0(d,e,a,b,c, 2); nR0(c,d,e,a,b, 3);
    nR0(b,c,d,e,a, 4); nR0(a,b,c,d,e, 5); nR0(e,a,b,c,d, 6); nR0(d,e,a,b,c, 7);
    nR0(c,d,e,a,b, 8); nR0(b,c,d,e,a, 9); nR0(a,b,c,d,e,10); nR0(e,a,b,c,d,11);
    nR0(d,e,a,b,c,12); nR0(c,d,e,a,b,13); nR0(b,c,d,e,a,14); nR0(a,b,c,d,e,15);
    nR1(e,a,b,c,d,16); nR1(d,e,a,b,c,17); nR1(c,d,e,a,b,18); nR1(b,c,d,e,a,19);
}

static void
do_R2(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)
{
    nR2(a,b,c,d,e,20); nR2(e,a,b,c,d,21); nR2(d,e,a,b,c,22); nR2(c,d,e,a,b,23);
    nR2(b,c,d,e,a,24); nR2(a,b,c,d,e,25); nR2(e,a,b,c,d,26); nR2(d,e,a,b,c,27);
    nR2(c,d,e,a,b,28); nR2(b,c,d,e,a,29); nR2(a,b,c,d,e,30); nR2(e,a,b,c,d,31);
    nR2(d,e,a,b,c,32); nR2(c,d,e,a,b,33); nR2(b,c,d,e,a,34); nR2(a,b,c,d,e,35);
    nR2(e,a,b,c,d,36); nR2(d,e,a,b,c,37); nR2(c,d,e,a,b,38); nR2(b,c,d,e,a,39);
}

static void
do_R3(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)
{
    nR3(a,b,c,d,e,40); nR3(e,a,b,c,d,41); nR3(d,e,a,b,c,42); nR3(c,d,e,a,b,43);
    nR3(b,c,d,e,a,44); nR3(a,b,c,d,e,45); nR3(e,a,b,c,d,46); nR3(d,e,a,b,c,47);
    nR3(c,d,e,a,b,48); nR3(b,c,d,e,a,49); nR3(a,b,c,d,e,50); nR3(e,a,b,c,d,51);
    nR3(d,e,a,b,c,52); nR3(c,d,e,a,b,53); nR3(b,c,d,e,a,54); nR3(a,b,c,d,e,55);
    nR3(e,a,b,c,d,56); nR3(d,e,a,b,c,57); nR3(c,d,e,a,b,58); nR3(b,c,d,e,a,59);
}

static void
do_R4(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)
{
    nR4(a,b,c,d,e,60); nR4(e,a,b,c,d,61); nR4(d,e,a,b,c,62); nR4(c,d,e,a,b,63);
    nR4(b,c,d,e,a,64); nR4(a,b,c,d,e,65); nR4(e,a,b,c,d,66); nR4(d,e,a,b,c,67);
    nR4(c,d,e,a,b,68); nR4(b,c,d,e,a,69); nR4(a,b,c,d,e,70); nR4(e,a,b,c,d,71);
    nR4(d,e,a,b,c,72); nR4(c,d,e,a,b,73); nR4(b,c,d,e,a,74); nR4(a,b,c,d,e,75);
    nR4(e,a,b,c,d,76); nR4(d,e,a,b,c,77); nR4(c,d,e,a,b,78); nR4(b,c,d,e,a,79);
}
#endif

a68 6
#ifdef __sh__
	do_R01(&a, &b, &c, &d, &e, block);
	do_R2(&a, &b, &c, &d, &e, block);
	do_R3(&a, &b, &c, &d, &e, block);
	do_R4(&a, &b, &c, &d, &e, block);
#else
a89 1
#endif
@


1.20
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.19 2004/05/28 15:10:27 millert Exp $	*/
d45 58
a110 4
	typedef union {
		u_int8_t c[64];
		u_int32_t l[16];
	} CHAR64LONG16;
d122 6
d149 1
@


1.19
log
@In the Final function, move the context zeroing into the digest != NULL
scope so that passing a NULL digest is equivalent to the Pad function
(like it used to be).  Fixes skey w/ sha1 as noticed by David Krause.
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.18 2004/05/05 17:09:46 millert Exp $	*/
a15 4

#if defined(LIBC_SCCS) && !defined(lint)
static const char rcsid[] = "$OpenBSD: sha1.c,v 1.18 2004/05/05 17:09:46 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.18
log
@Make the 2nd arg to SHA1Transform const again and unifdef SHA1HANDSOFF.
It was defined before and there is no need to for this knob...
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.17 2004/05/03 18:05:08 millert Exp $	*/
d18 1
a18 1
static const char rcsid[] = "$OpenBSD: sha1.c,v 1.17 2004/05/03 18:05:08 millert Exp $";
d176 1
a177 1
	memset(context, 0, sizeof(*context));
@


1.17
log
@Use KNF indentation style and do some u_char -> u_int8_t conversion
I missed earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.16 2004/05/03 17:30:15 millert Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: sha1.c,v 1.16 2004/05/03 17:30:15 millert Exp $";
a20 2
#define SHA1HANDSOFF		/* Copies data before messing with it. */

d53 1
a53 1
SHA1Transform(u_int32_t state[5], u_int8_t buffer[SHA1_BLOCK_LENGTH])
d56 1
d61 1
a61 1
	CHAR64LONG16 *block;
a62 3
#ifdef SHA1HANDSOFF
	u_int8_t workspace[SHA1_BLOCK_LENGTH];
	block = (CHAR64LONG16 *)workspace;
a63 3
#else
	block = (CHAR64LONG16 *)buffer;
#endif
@


1.16
log
@Add Pad and FileChunk functions for each family of hash functions.
The Pad function does padding like in Final but does not finish processing.
The FileChunk function creates a digest from a portion of a file.
Also made the length parameters consistent (and size_t).
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.15 2004/04/27 15:54:56 millert Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: sha1.c,v 1.15 2004/04/27 15:54:56 millert Exp $";
d55 1
a55 1
SHA1Transform(u_int32_t state[5], const u_char buffer[SHA1_BLOCK_LENGTH])
d57 6
a62 6
    u_int32_t a, b, c, d, e;
    typedef union {
	u_char c[64];
	u_int l[16];
    } CHAR64LONG16;
    CHAR64LONG16 *block;
d65 3
a67 3
    u_char workspace[SHA1_BLOCK_LENGTH];
    block = (CHAR64LONG16 *)workspace;
    (void)memcpy(block, buffer, SHA1_BLOCK_LENGTH);
d69 1
a69 1
    block = (CHAR64LONG16 *)buffer;
d72 35
a106 35
    /* Copy context->state[] to working vars */
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];

    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);

    /* Add the working vars back into context.state[] */
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    state[4] += e;
d108 2
a109 2
    /* Wipe variables */
    a = b = c = d = e = 0;
d120 7
a126 7
    /* SHA1 initialization constants */
    context->count = 0;
    context->state[0] = 0x67452301;
    context->state[1] = 0xEFCDAB89;
    context->state[2] = 0x98BADCFE;
    context->state[3] = 0x10325476;
    context->state[4] = 0xC3D2E1F0;
d134 1
a134 1
SHA1Update(SHA1_CTX *context, const u_char *data, size_t len)
d136 1
a136 1
    size_t i, j;
d138 12
a149 12
    j = (size_t)((context->count >> 3) & 63);
    context->count += (len << 3);
    if ((j + len) > 63) {
	(void)memcpy(&context->buffer[j], data, (i = 64-j));
	SHA1Transform(context->state, context->buffer);
	for ( ; i + 63 < len; i += 64)
	    SHA1Transform(context->state, &data[i]);
	j = 0;
    } else {
	i = 0;
    }
    (void)memcpy(&context->buffer[j], &data[i], len - i);
d159 2
a160 2
    u_int8_t finalcount[8];
    u_int i;
d162 8
a169 8
    for (i = 0; i < 8; i++) {
	finalcount[i] = (u_char)((context->count >>
	    ((7 - (i & 7)) * 8)) & 255);	 /* Endian independent */
    }
    SHA1Update(context, (u_char *)"\200", 1);
    while ((context->count & 504) != 448)
	SHA1Update(context, (u_char *)"\0", 1);
    SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform() */
d173 1
a173 1
SHA1Final(u_char digest[SHA1_DIGEST_LENGTH], SHA1_CTX *context)
d175 1
a175 1
    u_int i;
d177 8
a184 7
    SHA1Pad(context);
    if (digest) {
	for (i = 0; i < SHA1_DIGEST_LENGTH; i++)
	    digest[i] = (u_char)
		((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
    }
    memset(context, 0, sizeof(*context));
@


1.15
log
@Make the bit count u_int64_t instead of two u_int32_t.  Adapted from
changes Niklas made to the md5 code long ago.  OK hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.14 2004/04/26 19:38:12 millert Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: sha1.c,v 1.14 2004/04/26 19:38:12 millert Exp $";
d134 1
a134 1
SHA1Update(SHA1_CTX *context, const u_char *data, u_int len)
d136 1
a136 1
    u_int i, j;
d138 1
a138 1
    j = (u_int32_t)((context->count >> 3) & 63);
d157 1
a157 1
SHA1Final(u_char digest[SHA1_DIGEST_LENGTH], SHA1_CTX *context)
d159 1
a160 1
    u_char finalcount[8];
d170 6
d177 1
d183 1
@


1.14
log
@Use a common source file for all the hash helper functions that
previously lived in foohl.c.  The foohl.c files are now generated
via sed, though perhaps cpp could be used in the future.

Use u_int8_t instead of unsigned char for the buffers struct fooContext.
Add constants for buffer lengths and use them in function prototypes
and the man pages.

This is basically cosmetic surgery; there should be no functional changes.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.13 2004/03/31 23:41:53 brad Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: sha1.c,v 1.13 2004/03/31 23:41:53 brad Exp $";
d121 1
a126 1
    context->count[0] = context->count[1] = 0;
d138 2
a139 4
    j = context->count[0];
    if ((context->count[0] += len << 3) < j)
	context->count[1] += (len>>29)+1;
    j = (j >> 3) & 63;
d163 2
a164 2
	finalcount[i] = (u_char)((context->count[(i >= 4 ? 0 : 1)]
	 >> ((3-(i & 3)) * 8) ) & 255);	 /* Endian independent */
d167 1
a167 1
    while ((context->count[0] & 504) != 448)
@


1.13
log
@remove sparc64/gcc2 workaround.

ok millert@@ deraadt@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.12 2003/07/21 20:37:08 millert Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: sha1.c,v 1.12 2003/07/21 20:37:08 millert Exp $";
d55 1
a55 1
SHA1Transform(u_int32_t state[5], const u_char buffer[64])
d65 1
a65 1
    u_char workspace[64];
d67 1
a67 1
    (void)memcpy(block, buffer, 64);
d159 1
a159 1
SHA1Final(u_char digest[20], SHA1_CTX *context)
d174 1
a174 1
	for (i = 0; i < 20; i++)
@


1.12
log
@Remove bogus static; from Hiroki Sato
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.11 2003/01/08 19:53:59 millert Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: sha1.c,v 1.11 2003/01/08 19:53:59 millert Exp $";
a50 58
typedef union {
    u_char c[64];
    u_int l[16];
} CHAR64LONG16;

#ifdef __sparc_v9__
static void do_R01(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *);
static void do_R2(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *);
static void do_R3(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *);
static void do_R4(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *);

#define nR0(v,w,x,y,z,i) R0(*v,*w,*x,*y,*z,i)
#define nR1(v,w,x,y,z,i) R1(*v,*w,*x,*y,*z,i)
#define nR2(v,w,x,y,z,i) R2(*v,*w,*x,*y,*z,i)
#define nR3(v,w,x,y,z,i) R3(*v,*w,*x,*y,*z,i)
#define nR4(v,w,x,y,z,i) R4(*v,*w,*x,*y,*z,i)

static void
do_R01(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)
{
    nR0(a,b,c,d,e, 0); nR0(e,a,b,c,d, 1); nR0(d,e,a,b,c, 2); nR0(c,d,e,a,b, 3);
    nR0(b,c,d,e,a, 4); nR0(a,b,c,d,e, 5); nR0(e,a,b,c,d, 6); nR0(d,e,a,b,c, 7);
    nR0(c,d,e,a,b, 8); nR0(b,c,d,e,a, 9); nR0(a,b,c,d,e,10); nR0(e,a,b,c,d,11);
    nR0(d,e,a,b,c,12); nR0(c,d,e,a,b,13); nR0(b,c,d,e,a,14); nR0(a,b,c,d,e,15);
    nR1(e,a,b,c,d,16); nR1(d,e,a,b,c,17); nR1(c,d,e,a,b,18); nR1(b,c,d,e,a,19);
}

static void
do_R2(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)
{
    nR2(a,b,c,d,e,20); nR2(e,a,b,c,d,21); nR2(d,e,a,b,c,22); nR2(c,d,e,a,b,23);
    nR2(b,c,d,e,a,24); nR2(a,b,c,d,e,25); nR2(e,a,b,c,d,26); nR2(d,e,a,b,c,27);
    nR2(c,d,e,a,b,28); nR2(b,c,d,e,a,29); nR2(a,b,c,d,e,30); nR2(e,a,b,c,d,31);
    nR2(d,e,a,b,c,32); nR2(c,d,e,a,b,33); nR2(b,c,d,e,a,34); nR2(a,b,c,d,e,35);
    nR2(e,a,b,c,d,36); nR2(d,e,a,b,c,37); nR2(c,d,e,a,b,38); nR2(b,c,d,e,a,39);
}

static void
do_R3(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)
{
    nR3(a,b,c,d,e,40); nR3(e,a,b,c,d,41); nR3(d,e,a,b,c,42); nR3(c,d,e,a,b,43);
    nR3(b,c,d,e,a,44); nR3(a,b,c,d,e,45); nR3(e,a,b,c,d,46); nR3(d,e,a,b,c,47);
    nR3(c,d,e,a,b,48); nR3(b,c,d,e,a,49); nR3(a,b,c,d,e,50); nR3(e,a,b,c,d,51);
    nR3(d,e,a,b,c,52); nR3(c,d,e,a,b,53); nR3(b,c,d,e,a,54); nR3(a,b,c,d,e,55);
    nR3(e,a,b,c,d,56); nR3(d,e,a,b,c,57); nR3(c,d,e,a,b,58); nR3(b,c,d,e,a,59);
}

static void
do_R4(u_int32_t *a, u_int32_t *b, u_int32_t *c, u_int32_t *d, u_int32_t *e, CHAR64LONG16 *block)
{
    nR4(a,b,c,d,e,60); nR4(e,a,b,c,d,61); nR4(d,e,a,b,c,62); nR4(c,d,e,a,b,63);
    nR4(b,c,d,e,a,64); nR4(a,b,c,d,e,65); nR4(e,a,b,c,d,66); nR4(d,e,a,b,c,67);
    nR4(c,d,e,a,b,68); nR4(b,c,d,e,a,69); nR4(a,b,c,d,e,70); nR4(e,a,b,c,d,71);
    nR4(d,e,a,b,c,72); nR4(c,d,e,a,b,73); nR4(b,c,d,e,a,74); nR4(a,b,c,d,e,75);
    nR4(e,a,b,c,d,76); nR4(d,e,a,b,c,77); nR4(c,d,e,a,b,78); nR4(b,c,d,e,a,79);
}
#endif

d58 4
d65 2
a66 2
    CHAR64LONG16 workspace;
    block = &workspace;
a78 6
#ifdef __sparc_v9__
    do_R01(&a, &b, &c, &d, &e, block);
    do_R2(&a, &b, &c, &d, &e, block);
    do_R3(&a, &b, &c, &d, &e, block);
    do_R4(&a, &b, &c, &d, &e, block);
#else
a99 1
#endif
@


1.11
log
@Move the rounds into separate functions on sparc64 so gcc's optimizer
doesn't blow up.  This is a hack but is better than compiling sha1.c
with -O0 on sparc64.  From NetBSD (mrg).
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.10 2002/12/23 04:33:31 millert Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: sha1.c,v 1.10 2002/12/23 04:33:31 millert Exp $";
d119 1
a119 1
    static CHAR64LONG16 workspace;
@


1.10
log
@o Ansi function headers
o Add __BEGIN_DECLS/__END_DECLS to include files
o Safe macros
o Remove useless variable assignment in the End function of *hl.c
o Some minor KNF, needs more
From Dan Weeks
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.9 1997/07/23 21:12:32 kstailey Exp $	*/
d18 1
a18 1
static char rcsid[] = "$OpenBSD: $";
d51 57
a115 4
    typedef union {
	u_char c[64];
	u_int l[16];
    } CHAR64LONG16;
d119 2
a120 2
    static u_char workspace[64];
    block = (CHAR64LONG16 *)workspace;
d133 6
d160 1
@


1.9
log
@tabify + trailing blanks
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.8 1997/07/15 01:54:24 millert Exp $	*/
d17 4
d55 2
a56 3
void SHA1Transform(state, buffer)
    u_int32_t state[5];
    const u_char buffer[64];
d117 2
a118 2
void SHA1Init(context)
    SHA1_CTX *context;
d134 2
a135 4
void SHA1Update(context, data, len)
    SHA1_CTX *context;
    const u_char *data;
    u_int len;
d159 2
a160 3
void SHA1Final(digest, context)
    u_char digest[20];
    SHA1_CTX* context;
@


1.8
log
@Add a missing const
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.7 1997/07/12 00:51:18 millert Exp $	*/
d7 1
a7 1
 * 
d143 5
a147 5
        (void)memcpy(&context->buffer[j], data, (i = 64-j));
        SHA1Transform(context->state, context->buffer);
        for ( ; i + 63 < len; i += 64)
            SHA1Transform(context->state, &data[i]);
        j = 0;
d166 2
a167 2
        finalcount[i] = (u_char)((context->count[(i >= 4 ? 0 : 1)]
         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
d171 1
a171 1
        SHA1Update(context, (u_char *)"\0", 1);
@


1.7
log
@Minor style points.
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.6 1997/07/11 04:17:10 millert Exp $	*/
d53 1
a53 1
    u_char buffer[64];
d133 1
a133 1
    u_char *data;
@


1.6
log
@#include <sha1.h> not #include "sha1.h"
@
text
@d1 1
a1 1
/*	$OpenBSD: sha1.c,v 1.5 1997/07/10 22:52:59 millert Exp $	*/
d48 3
a50 2
/* Hash a single 512-bit block. This is the core of the algorithm. */

d60 1
a60 1
    CHAR64LONG16* block;
d64 2
a65 2
    block = (CHAR64LONG16*)workspace;
    memcpy(block, buffer, 64);
d67 1
a67 1
    block = (CHAR64LONG16*)buffer;
d117 1
d136 1
a136 2
    u_int i;
    u_int j;
d143 1
a143 1
        memcpy(&context->buffer[j], data, (i = 64-j));
d151 1
a151 1
    memcpy(&context->buffer[j], &data[i], len - i);
@


1.5
log
@Different sha1 functions (taken from netinet's if_sha1.c) that
are more consistent with md4/md5 functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_sha1.c,v 1.6 1997/06/21 00:09:20 deraadt Exp $	*/
d21 1
a21 1
#include "sha1.h"
@


1.4
log
@export byte swapping routine.
@
text
@d1 1
a1 3
#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: sha1.c,v 1.3 1996/09/30 04:01:30 millert Exp $";
#endif /* LIBC_SCCS and not lint */
d4 11
a14 7
 * sha1.c
 *
 *	signature function hook for SHA1.
 *
 * Gene Kim
 * Purdue University
 * August 10, 1993
d17 1
a17 1
/* --------------------------------- SHA1.C ------------------------------- */
d19 3
a21 1
/* NIST proposed Secure Hash Standard.
d23 1
a23 2
   Written 2 September 1992, Peter C. Gutmann.
   This implementation placed in the public domain.
d25 9
a33 9
   Comments to pgut1@@cs.aukuni.ac.nz */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sha1.h>
#ifdef TEST
#include <time.h>
d35 2
d38 27
a64 35
/* Useful defines/typedefs */
  
typedef unsigned char   BYTE;
typedef u_int32_t       LONG;

/* The SHA1 f()-functions */

#define f1(x,y,z)   ( ( x & y ) | ( ~x & z ) )              /* Rounds  0-19 */
#define f2(x,y,z)   ( x ^ y ^ z )                           /* Rounds 20-39 */
#define f3(x,y,z)   ( ( x & y ) | ( x & z ) | ( y & z ) )   /* Rounds 40-59 */
#define f4(x,y,z)   ( x ^ y ^ z )                           /* Rounds 60-79 */

/* The SHA1 Mysterious Constants */

#define K1  0x5A827999L     /* Rounds  0-19 */
#define K2  0x6ED9EBA1L     /* Rounds 20-39 */
#define K3  0x8F1BBCDCL     /* Rounds 40-59 */
#define K4  0xCA62C1D6L     /* Rounds 60-79 */

/* SHA1 initial values */

#define h0init  0x67452301L
#define h1init  0xEFCDAB89L
#define h2init  0x98BADCFEL
#define h3init  0x10325476L
#define h4init  0xC3D2E1F0L

/* 32-bit rotate - kludged with shifts */

#define S(n,X)  ( ( X << n ) | ( X >> ( 32 - n ) ) )

/* The initial expanding function */

#ifdef NEW_SHA1
#define expand(count)   temp = W[ count - 3 ] ^ W[ count - 8 ] ^ W[ count - 14 ] ^ W[ count - 16 ];W[ count ] = S(1, temp)
d66 1
a66 1
#define expand(count)   W[ count ] = W[ count - 3 ] ^ W[ count - 8 ] ^ W[ count - 14 ] ^ W[ count - 16 ]
d69 39
a107 1
/* The four SHA1 sub-rounds */
a108 9
#define subRound1(count)    \
    { \
    temp = S( 5, A ) + f1( B, C, D ) + E + W[ count ] + K1; \
    E = D; \
    D = C; \
    C = S( 30, B ); \
    B = A; \
    A = temp; \
    }
d110 14
a123 9
#define subRound2(count)    \
    { \
    temp = S( 5, A ) + f2( B, C, D ) + E + W[ count ] + K2; \
    E = D; \
    D = C; \
    C = S( 30, B ); \
    B = A; \
    A = temp; \
    }
a124 9
#define subRound3(count)    \
    { \
    temp = S( 5, A ) + f3( B, C, D ) + E + W[ count ] + K3; \
    E = D; \
    D = C; \
    C = S( 30, B ); \
    B = A; \
    A = temp; \
    }
d126 23
a148 8
#define subRound4(count)    \
    { \
    temp = S( 5, A ) + f4( B, C, D ) + E + W[ count ] + K4; \
    E = D; \
    D = C; \
    C = S( 30, B ); \
    B = A; \
    A = temp; \
d150 2
a152 1
/* The two buffers of 5 32-bit words */
d154 23
a176 247
LONG h0, h1, h2, h3, h4;
LONG A, B, C, D, E;

/* Initialize the SHA1 values */

void sha1Init(sha1Info)
    SHA1_INFO *sha1Info;
    {
    /* Set the h-vars to their initial values */
    sha1Info->digest[ 0 ] = h0init;
    sha1Info->digest[ 1 ] = h1init;
    sha1Info->digest[ 2 ] = h2init;
    sha1Info->digest[ 3 ] = h3init;
    sha1Info->digest[ 4 ] = h4init;

    /* Initialise bit count */
    sha1Info->countLo = sha1Info->countHi = 0L;
    }

/* Perform the SHA1 transformation.  Note that this code, like MD5, seems to
   break some optimizing compilers - it may be necessary to split it into
   sections, eg based on the four subrounds */

void sha1Transform(sha1Info)
    SHA1_INFO *sha1Info;
    {
    LONG W[ 80 ], temp;
    int i;

    /* Step A.  Copy the data buffer into the local work buffer */
    for( i = 0; i < 16; i++ )
	W[ i ] = sha1Info->data[ i ];

    /* Step B.  Expand the 16 words into 64 temporary data words */
    expand( 16 ); expand( 17 ); expand( 18 ); expand( 19 ); expand( 20 );
    expand( 21 ); expand( 22 ); expand( 23 ); expand( 24 ); expand( 25 );
    expand( 26 ); expand( 27 ); expand( 28 ); expand( 29 ); expand( 30 );
    expand( 31 ); expand( 32 ); expand( 33 ); expand( 34 ); expand( 35 );
    expand( 36 ); expand( 37 ); expand( 38 ); expand( 39 ); expand( 40 );
    expand( 41 ); expand( 42 ); expand( 43 ); expand( 44 ); expand( 45 );
    expand( 46 ); expand( 47 ); expand( 48 ); expand( 49 ); expand( 50 );
    expand( 51 ); expand( 52 ); expand( 53 ); expand( 54 ); expand( 55 );
    expand( 56 ); expand( 57 ); expand( 58 ); expand( 59 ); expand( 60 );
    expand( 61 ); expand( 62 ); expand( 63 ); expand( 64 ); expand( 65 );
    expand( 66 ); expand( 67 ); expand( 68 ); expand( 69 ); expand( 70 );
    expand( 71 ); expand( 72 ); expand( 73 ); expand( 74 ); expand( 75 );
    expand( 76 ); expand( 77 ); expand( 78 ); expand( 79 );

    /* Step C.  Set up first buffer */
    A = sha1Info->digest[ 0 ];
    B = sha1Info->digest[ 1 ];
    C = sha1Info->digest[ 2 ];
    D = sha1Info->digest[ 3 ];
    E = sha1Info->digest[ 4 ];

    /* Step D.  Serious mangling, divided into four sub-rounds */
    subRound1( 0 ); subRound1( 1 ); subRound1( 2 ); subRound1( 3 );
    subRound1( 4 ); subRound1( 5 ); subRound1( 6 ); subRound1( 7 );
    subRound1( 8 ); subRound1( 9 ); subRound1( 10 ); subRound1( 11 );
    subRound1( 12 ); subRound1( 13 ); subRound1( 14 ); subRound1( 15 );
    subRound1( 16 ); subRound1( 17 ); subRound1( 18 ); subRound1( 19 );
    subRound2( 20 ); subRound2( 21 ); subRound2( 22 ); subRound2( 23 );
    subRound2( 24 ); subRound2( 25 ); subRound2( 26 ); subRound2( 27 );
    subRound2( 28 ); subRound2( 29 ); subRound2( 30 ); subRound2( 31 );
    subRound2( 32 ); subRound2( 33 ); subRound2( 34 ); subRound2( 35 );
    subRound2( 36 ); subRound2( 37 ); subRound2( 38 ); subRound2( 39 );
    subRound3( 40 ); subRound3( 41 ); subRound3( 42 ); subRound3( 43 );
    subRound3( 44 ); subRound3( 45 ); subRound3( 46 ); subRound3( 47 );
    subRound3( 48 ); subRound3( 49 ); subRound3( 50 ); subRound3( 51 );
    subRound3( 52 ); subRound3( 53 ); subRound3( 54 ); subRound3( 55 );
    subRound3( 56 ); subRound3( 57 ); subRound3( 58 ); subRound3( 59 );
    subRound4( 60 ); subRound4( 61 ); subRound4( 62 ); subRound4( 63 );
    subRound4( 64 ); subRound4( 65 ); subRound4( 66 ); subRound4( 67 );
    subRound4( 68 ); subRound4( 69 ); subRound4( 70 ); subRound4( 71 );
    subRound4( 72 ); subRound4( 73 ); subRound4( 74 ); subRound4( 75 );
    subRound4( 76 ); subRound4( 77 ); subRound4( 78 ); subRound4( 79 );

    /* Step E.  Build message digest */
    sha1Info->digest[ 0 ] += A;
    sha1Info->digest[ 1 ] += B;
    sha1Info->digest[ 2 ] += C;
    sha1Info->digest[ 3 ] += D;
    sha1Info->digest[ 4 ] += E;
    }

#if BYTE_ORDER == LITTLE_ENDIAN

/* When run on a little-endian CPU we need to perform byte reversal on an
   array of longwords.  It is possible to make the code endianness-
   independant by fiddling around with data at the byte level, but this
   makes for very slow code, so we rely on the user to sort out endianness
   at compile time */

void sha1ByteReverse(buffer, byteCount)
    LONG *buffer;
    int byteCount;
    {
    LONG value;
    int count;

    byteCount /= sizeof( LONG );
    for( count = 0; count < byteCount; count++ )
	{
	value = ( buffer[ count ] << 16 ) | ( buffer[ count ] >> 16 );
	buffer[ count ] = ( ( value & 0xFF00FF00L ) >> 8 ) | ( ( value & 0x00FF00FFL ) << 8 );
	}
    }
#endif /* LITTLE_ENDIAN */

/* Update SHA1 for a block of data.  This code assumes that the buffer size
   is a multiple of SHA1_BLOCKSIZE bytes long, which makes the code a lot
   more efficient since it does away with the need to handle partial blocks
   between calls to sha1Update() */

void sha1Update(sha1Info, buffer, count)
    SHA1_INFO *sha1Info;
    BYTE *buffer; 
    int count;
    {
    /* Update bitcount */
    if( ( sha1Info->countLo + ( ( LONG ) count << 3 ) ) < sha1Info->countLo )
	sha1Info->countHi++; /* Carry from low to high bitCount */
    sha1Info->countLo += ( ( LONG ) count << 3 );
    sha1Info->countHi += ( ( LONG ) count >> 29 );

    /* Process data in SHA1_BLOCKSIZE chunks */
    while( count >= SHA1_BLOCKSIZE )
	{
	memcpy( (void *) sha1Info->data, (void *) buffer, SHA1_BLOCKSIZE );
#if BYTE_ORDER == LITTLE_ENDIAN
	sha1ByteReverse( sha1Info->data, SHA1_BLOCKSIZE );
#endif /* LITTLE_ENDIAN */
	sha1Transform( sha1Info );
	buffer += SHA1_BLOCKSIZE;
	count -= SHA1_BLOCKSIZE;
	}

    /* Handle any remaining bytes of data.  This should only happen once
       on the final lot of data */
    memcpy( (void *) sha1Info->data, (void *) buffer, count );
    }

void sha1Final(sha1Info)
    SHA1_INFO *sha1Info;
    {
    int count;
    LONG lowBitcount = sha1Info->countLo, highBitcount = sha1Info->countHi;

    /* Compute number of bytes mod 64 */
    count = ( int ) ( ( sha1Info->countLo >> 3 ) & 0x3F );

    /* Set the first char of padding to 0x80.  This is safe since there is
       always at least one byte free */
    ( ( BYTE * ) sha1Info->data )[ count++ ] = 0x80;

    /* Pad out to 56 mod 64 */
    if( count > 56 )
	{
	/* Two lots of padding:  Pad the first block to 64 bytes */
	memset( ( char * ) sha1Info->data + count, 0, 64 - count );
#if BYTE_ORDER == LITTLE_ENDIAN
	sha1ByteReverse( sha1Info->data, SHA1_BLOCKSIZE );
#endif /* LITTLE_ENDIAN */
	sha1Transform( sha1Info );

	/* Now fill the next block with 56 bytes */
	memset( (void *) sha1Info->data, 0, 56 );
	}
    else
	/* Pad block to 56 bytes */
	memset( ( char * ) sha1Info->data + count, 0, 56 - count );
#if BYTE_ORDER == LITTLE_ENDIAN
    sha1ByteReverse( sha1Info->data, SHA1_BLOCKSIZE );
#endif /* LITTLE_ENDIAN */

    /* Append length in bits and transform */
    sha1Info->data[ 14 ] = highBitcount;
    sha1Info->data[ 15 ] = lowBitcount;

    sha1Transform( sha1Info );
#if BYTE_ORDER == LITTLE_ENDIAN
    sha1ByteReverse( sha1Info->data, SHA1_DIGESTSIZE );
#endif /* LITTLE_ENDIAN */
    }

#ifdef TEST

/* ----------------------------- SHA1 Test code --------------------------- */

/* Size of buffer for SHA1 speed test data */

#define TEST_BLOCK_SIZE     ( SHA1_DIGESTSIZE * 100 )

/* Number of bytes of test data to process */

#define TEST_BYTES          10000000L
#define TEST_BLOCKS         ( TEST_BYTES / TEST_BLOCK_SIZE )

void main()
    {
    SHA1_INFO sha1Info;
    time_t endTime, startTime;
    BYTE data[ TEST_BLOCK_SIZE ];
    long i;

    /* Test output data (this is the only test data given in the SHA1
       document, but chances are if it works for this it'll work for
       anything) */
    sha1Init( &sha1Info );
    sha1Update( &sha1Info, ( BYTE * ) "abc", 3 );
    sha1Final( &sha1Info );
#ifdef NEW_SHA1
    if(	sha1Info.digest[ 0 ] != 0xA9993E36L ||
	sha1Info.digest[ 1 ] != 0x4706816AL ||
	sha1Info.digest[ 2 ] != 0xBA3E2571L ||
	sha1Info.digest[ 3 ] != 0x7850C26CL ||
	sha1Info.digest[ 4 ] != 0x9CD0D89DL )
#else
    if( sha1Info.digest[ 0 ] != 0x0164B8A9L ||
	sha1Info.digest[ 1 ] != 0x14CD2A5EL ||
	sha1Info.digest[ 2 ] != 0x74C4F7FFL ||
	sha1Info.digest[ 3 ] != 0x082C4D97L ||
	sha1Info.digest[ 4 ] != 0xF1EDF880L )
#endif
	{
	puts( "Error in SHA1 implementation" );
	exit( -1 );
	}

    /* Now perform time trial, generating MD for 10MB of data.  First,
       initialize the test data */
    memset( ( void * ) data, 0, TEST_BLOCK_SIZE );

    /* Get start time */
    printf( "SHA1 time trial.  Processing %ld characters...\n", TEST_BYTES );
    time( &startTime );

    /* Calculate SHA1 message digest in TEST_BLOCK_SIZE byte blocks */
    sha1Init( &sha1Info );
    for( i = TEST_BLOCKS; i > 0; i-- )
	sha1Update( &sha1Info, data, TEST_BLOCK_SIZE );
    sha1Final( &sha1Info );

    /* Get finish time and time difference */
    time( &endTime );
    printf( "Seconds to process test input: %ld\n", endTime - startTime );
    printf( "Characters processed per second: %ld\n", TEST_BYTES / ( endTime - startTime ) );
d178 1
a178 2

#endif
@


1.3
log
@Moved definitions of BYTE and LONG in from header file.
@
text
@d2 1
a2 1
static char rcsid[] = "$OpenBSD: sha1.c,v 1.2 1996/09/29 17:18:17 millert Exp $";
d209 1
a209 1
static void byteReverse(buffer, byteCount)
d246 1
a246 1
	byteReverse( sha1Info->data, SHA1_BLOCKSIZE );
d275 1
a275 1
	memset( ( void * ) sha1Info->data + count, 0, 64 - count );
d277 1
a277 1
	byteReverse( sha1Info->data, SHA1_BLOCKSIZE );
d286 1
a286 1
	memset( ( void * ) sha1Info->data + count, 0, 56 - count );
d288 1
a288 1
    byteReverse( sha1Info->data, SHA1_BLOCKSIZE );
d297 1
a297 1
    byteReverse( sha1Info->data, SHA1_DIGESTSIZE );
d347 1
a347 1
    memset( data, 0, TEST_BLOCK_SIZE );
@


1.2
log
@Fixed standalone test mode for NEW_SHA1.
@
text
@d2 1
a2 1
static char rcsid[] = "$OpenBSD: sha1.c,v 1.1 1996/09/29 16:15:05 millert Exp $";
d33 4
@


1.1
log
@added sha1 (secure hash function).
@
text
@d2 1
a2 1
static char rcsid[] = "$OpenBSD: $";
d323 7
d335 1
@
