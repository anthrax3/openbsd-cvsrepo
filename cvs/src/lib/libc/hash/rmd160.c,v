head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.34
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.32
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.30
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.28
	OPENBSD_5_0:1.18.0.26
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.24
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.22
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.18
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.20
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.16
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.14
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.12
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.10
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.8
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.6
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.8
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6;
locks; strict;
comment	@ * @;


1.22
date	2015.09.11.09.18.27;	author guenther;	state Exp;
branches;
next	1.21;
commitid	Ug7ZHdkfaIoV0KLN;

1.21
date	2015.01.15.13.05.59;	author millert;	state Exp;
branches;
next	1.20;
commitid	gkpEJvpVgT62ZVxP;

1.20
date	2014.07.21.01.51.10;	author guenther;	state Exp;
branches;
next	1.19;
commitid	ro8JUTvBpvQMiFY9;

1.19
date	2014.01.08.06.14.57;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.28.15.10.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.03.18.07.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.03.17.30.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.26.19.38.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.14.11.22.35;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.23.04.33.31;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.01.20.36.17;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	99.08.16.10.02.41;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.09.09.22.30.00;	author janjaap;	state Exp;
branches;
next	1.8;

1.8
date	98.06.02.16.15.28;	author janjaap;	state Exp;
branches;
next	1.7;

1.7
date	98.03.23.12.49.29;	author janjaap;	state Exp;
branches;
next	1.6;

1.6
date	97.08.24.21.25.47;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.21.12.31;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.07.18.04.07.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.07.17.06.25.28;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.07.17.05.57.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.07.17.05.37.00;	author millert;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Wrap blowfish, sha*, md5, and rmd160 so that internal calls go direct

ok deraadt@@
@
text
@/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Preneel, Bosselaers, Dobbertin, "The Cryptographic Hash Function RIPEMD-160",
 * RSA Laboratories, CryptoBytes, Volume 3, Number 2, Autumn 1997,
 * ftp://ftp.rsasecurity.com/pub/cryptobytes/crypto3n2.pdf
 */
#include <sys/types.h>
#include <endian.h>
#include <string.h>
#include <rmd160.h>

#define PUT_64BIT_LE(cp, value) do {                                    \
	(cp)[7] = (value) >> 56;                                        \
	(cp)[6] = (value) >> 48;                                        \
	(cp)[5] = (value) >> 40;                                        \
	(cp)[4] = (value) >> 32;                                        \
	(cp)[3] = (value) >> 24;                                        \
	(cp)[2] = (value) >> 16;                                        \
	(cp)[1] = (value) >> 8;                                         \
	(cp)[0] = (value); } while (0)

#define PUT_32BIT_LE(cp, value) do {                                    \
	(cp)[3] = (value) >> 24;                                        \
	(cp)[2] = (value) >> 16;                                        \
	(cp)[1] = (value) >> 8;                                         \
	(cp)[0] = (value); } while (0)

#define	H0	0x67452301U
#define	H1	0xEFCDAB89U
#define	H2	0x98BADCFEU
#define	H3	0x10325476U
#define	H4	0xC3D2E1F0U

#define	K0	0x00000000U
#define	K1	0x5A827999U
#define	K2	0x6ED9EBA1U
#define	K3	0x8F1BBCDCU
#define	K4	0xA953FD4EU

#define	KK0	0x50A28BE6U
#define	KK1	0x5C4DD124U
#define	KK2	0x6D703EF3U
#define	KK3	0x7A6D76E9U
#define	KK4	0x00000000U

/* rotate x left n bits.  */
#define ROL(n, x) (((x) << (n)) | ((x) >> (32-(n))))

#define F0(x, y, z) ((x) ^ (y) ^ (z))
#define F1(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define F2(x, y, z) (((x) | (~y)) ^ (z))
#define F3(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define F4(x, y, z) ((x) ^ ((y) | (~z)))

#define R(a, b, c, d, e, Fj, Kj, sj, rj)                                \
	do {                                                            \
		a = ROL(sj, a + Fj(b,c,d) + X(rj) + Kj) + e;            \
		c = ROL(10, c);                                         \
	} while(0)

#define X(i)	x[i]

static u_int8_t PADDING[RMD160_BLOCK_LENGTH] = {
	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void
RMD160Init(RMD160_CTX *ctx)
{
	ctx->count = 0;
	ctx->state[0] = H0;
	ctx->state[1] = H1;
	ctx->state[2] = H2;
	ctx->state[3] = H3;
	ctx->state[4] = H4;
}
DEF_WEAK(RMD160Init);

void
RMD160Update(RMD160_CTX *ctx, const u_int8_t *input, size_t len)
{
	size_t have, off, need;

	have = (ctx->count / 8) % RMD160_BLOCK_LENGTH;
	need = RMD160_BLOCK_LENGTH - have;
	ctx->count += 8 * len;
	off = 0;

	if (len >= need) {
		if (have) {
			memcpy(ctx->buffer + have, input, need);
			RMD160Transform(ctx->state, ctx->buffer);
			off = need;
			have = 0;
		}
		/* now the buffer is empty */
		while (off + RMD160_BLOCK_LENGTH <= len) {
			RMD160Transform(ctx->state, input+off);
			off += RMD160_BLOCK_LENGTH;
		}
	}
	if (off < len)
		memcpy(ctx->buffer + have, input+off, len-off);
}
DEF_WEAK(RMD160Update);

void
RMD160Pad(RMD160_CTX *ctx)
{
	u_int8_t size[8];
	size_t padlen;

	PUT_64BIT_LE(size, ctx->count);

	/*
	 * pad to RMD160_BLOCK_LENGTH byte blocks, at least one byte from
	 * PADDING plus 8 bytes for the size
	 */
	padlen = RMD160_BLOCK_LENGTH - ((ctx->count / 8) % RMD160_BLOCK_LENGTH);
	if (padlen < 1 + 8)
		padlen += RMD160_BLOCK_LENGTH;
	RMD160Update(ctx, PADDING, padlen - 8);		/* padlen - 8 <= 64 */
	RMD160Update(ctx, size, 8);
}
DEF_WEAK(RMD160Pad);

void
RMD160Final(u_int8_t digest[RMD160_DIGEST_LENGTH], RMD160_CTX *ctx)
{
	int i;

	RMD160Pad(ctx);
	for (i = 0; i < 5; i++)
		PUT_32BIT_LE(digest + i*4, ctx->state[i]);
	explicit_bzero(ctx, sizeof (*ctx));
}
DEF_WEAK(RMD160Final);

void
RMD160Transform(u_int32_t state[5], const u_int8_t block[RMD160_BLOCK_LENGTH])
{
	u_int32_t a, b, c, d, e, aa, bb, cc, dd, ee, t, x[16];

#if BYTE_ORDER == LITTLE_ENDIAN
	memcpy(x, block, RMD160_BLOCK_LENGTH);
#else
	int i;

	for (i = 0; i < 16; i++)
		x[i] = (u_int32_t)(
		    (u_int32_t)(block[i*4 + 0]) |
		    (u_int32_t)(block[i*4 + 1]) <<  8 |
		    (u_int32_t)(block[i*4 + 2]) << 16 |
		    (u_int32_t)(block[i*4 + 3]) << 24);
#endif

	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];

	/* Round 1 */
	R(a, b, c, d, e, F0, K0, 11,  0);
	R(e, a, b, c, d, F0, K0, 14,  1);
	R(d, e, a, b, c, F0, K0, 15,  2);
	R(c, d, e, a, b, F0, K0, 12,  3);
	R(b, c, d, e, a, F0, K0,  5,  4);
	R(a, b, c, d, e, F0, K0,  8,  5);
	R(e, a, b, c, d, F0, K0,  7,  6);
	R(d, e, a, b, c, F0, K0,  9,  7);
	R(c, d, e, a, b, F0, K0, 11,  8);
	R(b, c, d, e, a, F0, K0, 13,  9);
	R(a, b, c, d, e, F0, K0, 14, 10);
	R(e, a, b, c, d, F0, K0, 15, 11);
	R(d, e, a, b, c, F0, K0,  6, 12);
	R(c, d, e, a, b, F0, K0,  7, 13);
	R(b, c, d, e, a, F0, K0,  9, 14);
	R(a, b, c, d, e, F0, K0,  8, 15); /* #15 */
	/* Round 2 */
	R(e, a, b, c, d, F1, K1,  7,  7);
	R(d, e, a, b, c, F1, K1,  6,  4);
	R(c, d, e, a, b, F1, K1,  8, 13);
	R(b, c, d, e, a, F1, K1, 13,  1);
	R(a, b, c, d, e, F1, K1, 11, 10);
	R(e, a, b, c, d, F1, K1,  9,  6);
	R(d, e, a, b, c, F1, K1,  7, 15);
	R(c, d, e, a, b, F1, K1, 15,  3);
	R(b, c, d, e, a, F1, K1,  7, 12);
	R(a, b, c, d, e, F1, K1, 12,  0);
	R(e, a, b, c, d, F1, K1, 15,  9);
	R(d, e, a, b, c, F1, K1,  9,  5);
	R(c, d, e, a, b, F1, K1, 11,  2);
	R(b, c, d, e, a, F1, K1,  7, 14);
	R(a, b, c, d, e, F1, K1, 13, 11);
	R(e, a, b, c, d, F1, K1, 12,  8); /* #31 */
	/* Round 3 */
	R(d, e, a, b, c, F2, K2, 11,  3);
	R(c, d, e, a, b, F2, K2, 13, 10);
	R(b, c, d, e, a, F2, K2,  6, 14);
	R(a, b, c, d, e, F2, K2,  7,  4);
	R(e, a, b, c, d, F2, K2, 14,  9);
	R(d, e, a, b, c, F2, K2,  9, 15);
	R(c, d, e, a, b, F2, K2, 13,  8);
	R(b, c, d, e, a, F2, K2, 15,  1);
	R(a, b, c, d, e, F2, K2, 14,  2);
	R(e, a, b, c, d, F2, K2,  8,  7);
	R(d, e, a, b, c, F2, K2, 13,  0);
	R(c, d, e, a, b, F2, K2,  6,  6);
	R(b, c, d, e, a, F2, K2,  5, 13);
	R(a, b, c, d, e, F2, K2, 12, 11);
	R(e, a, b, c, d, F2, K2,  7,  5);
	R(d, e, a, b, c, F2, K2,  5, 12); /* #47 */
	/* Round 4 */
	R(c, d, e, a, b, F3, K3, 11,  1);
	R(b, c, d, e, a, F3, K3, 12,  9);
	R(a, b, c, d, e, F3, K3, 14, 11);
	R(e, a, b, c, d, F3, K3, 15, 10);
	R(d, e, a, b, c, F3, K3, 14,  0);
	R(c, d, e, a, b, F3, K3, 15,  8);
	R(b, c, d, e, a, F3, K3,  9, 12);
	R(a, b, c, d, e, F3, K3,  8,  4);
	R(e, a, b, c, d, F3, K3,  9, 13);
	R(d, e, a, b, c, F3, K3, 14,  3);
	R(c, d, e, a, b, F3, K3,  5,  7);
	R(b, c, d, e, a, F3, K3,  6, 15);
	R(a, b, c, d, e, F3, K3,  8, 14);
	R(e, a, b, c, d, F3, K3,  6,  5);
	R(d, e, a, b, c, F3, K3,  5,  6);
	R(c, d, e, a, b, F3, K3, 12,  2); /* #63 */
	/* Round 5 */
	R(b, c, d, e, a, F4, K4,  9,  4);
	R(a, b, c, d, e, F4, K4, 15,  0);
	R(e, a, b, c, d, F4, K4,  5,  5);
	R(d, e, a, b, c, F4, K4, 11,  9);
	R(c, d, e, a, b, F4, K4,  6,  7);
	R(b, c, d, e, a, F4, K4,  8, 12);
	R(a, b, c, d, e, F4, K4, 13,  2);
	R(e, a, b, c, d, F4, K4, 12, 10);
	R(d, e, a, b, c, F4, K4,  5, 14);
	R(c, d, e, a, b, F4, K4, 12,  1);
	R(b, c, d, e, a, F4, K4, 13,  3);
	R(a, b, c, d, e, F4, K4, 14,  8);
	R(e, a, b, c, d, F4, K4, 11, 11);
	R(d, e, a, b, c, F4, K4,  8,  6);
	R(c, d, e, a, b, F4, K4,  5, 15);
	R(b, c, d, e, a, F4, K4,  6, 13); /* #79 */

	aa = a ; bb = b; cc = c; dd = d; ee = e;

	a = state[0];
	b = state[1];
	c = state[2];
	d = state[3];
	e = state[4];

	/* Parallel round 1 */
	R(a, b, c, d, e, F4, KK0,  8,  5);
	R(e, a, b, c, d, F4, KK0,  9, 14);
	R(d, e, a, b, c, F4, KK0,  9,  7);
	R(c, d, e, a, b, F4, KK0, 11,  0);
	R(b, c, d, e, a, F4, KK0, 13,  9);
	R(a, b, c, d, e, F4, KK0, 15,  2);
	R(e, a, b, c, d, F4, KK0, 15, 11);
	R(d, e, a, b, c, F4, KK0,  5,  4);
	R(c, d, e, a, b, F4, KK0,  7, 13);
	R(b, c, d, e, a, F4, KK0,  7,  6);
	R(a, b, c, d, e, F4, KK0,  8, 15);
	R(e, a, b, c, d, F4, KK0, 11,  8);
	R(d, e, a, b, c, F4, KK0, 14,  1);
	R(c, d, e, a, b, F4, KK0, 14, 10);
	R(b, c, d, e, a, F4, KK0, 12,  3);
	R(a, b, c, d, e, F4, KK0,  6, 12); /* #15 */
	/* Parallel round 2 */
	R(e, a, b, c, d, F3, KK1,  9,  6);
	R(d, e, a, b, c, F3, KK1, 13, 11);
	R(c, d, e, a, b, F3, KK1, 15,  3);
	R(b, c, d, e, a, F3, KK1,  7,  7);
	R(a, b, c, d, e, F3, KK1, 12,  0);
	R(e, a, b, c, d, F3, KK1,  8, 13);
	R(d, e, a, b, c, F3, KK1,  9,  5);
	R(c, d, e, a, b, F3, KK1, 11, 10);
	R(b, c, d, e, a, F3, KK1,  7, 14);
	R(a, b, c, d, e, F3, KK1,  7, 15);
	R(e, a, b, c, d, F3, KK1, 12,  8);
	R(d, e, a, b, c, F3, KK1,  7, 12);
	R(c, d, e, a, b, F3, KK1,  6,  4);
	R(b, c, d, e, a, F3, KK1, 15,  9);
	R(a, b, c, d, e, F3, KK1, 13,  1);
	R(e, a, b, c, d, F3, KK1, 11,  2); /* #31 */
	/* Parallel round 3 */
	R(d, e, a, b, c, F2, KK2,  9, 15);
	R(c, d, e, a, b, F2, KK2,  7,  5);
	R(b, c, d, e, a, F2, KK2, 15,  1);
	R(a, b, c, d, e, F2, KK2, 11,  3);
	R(e, a, b, c, d, F2, KK2,  8,  7);
	R(d, e, a, b, c, F2, KK2,  6, 14);
	R(c, d, e, a, b, F2, KK2,  6,  6);
	R(b, c, d, e, a, F2, KK2, 14,  9);
	R(a, b, c, d, e, F2, KK2, 12, 11);
	R(e, a, b, c, d, F2, KK2, 13,  8);
	R(d, e, a, b, c, F2, KK2,  5, 12);
	R(c, d, e, a, b, F2, KK2, 14,  2);
	R(b, c, d, e, a, F2, KK2, 13, 10);
	R(a, b, c, d, e, F2, KK2, 13,  0);
	R(e, a, b, c, d, F2, KK2,  7,  4);
	R(d, e, a, b, c, F2, KK2,  5, 13); /* #47 */
	/* Parallel round 4 */
	R(c, d, e, a, b, F1, KK3, 15,  8);
	R(b, c, d, e, a, F1, KK3,  5,  6);
	R(a, b, c, d, e, F1, KK3,  8,  4);
	R(e, a, b, c, d, F1, KK3, 11,  1);
	R(d, e, a, b, c, F1, KK3, 14,  3);
	R(c, d, e, a, b, F1, KK3, 14, 11);
	R(b, c, d, e, a, F1, KK3,  6, 15);
	R(a, b, c, d, e, F1, KK3, 14,  0);
	R(e, a, b, c, d, F1, KK3,  6,  5);
	R(d, e, a, b, c, F1, KK3,  9, 12);
	R(c, d, e, a, b, F1, KK3, 12,  2);
	R(b, c, d, e, a, F1, KK3,  9, 13);
	R(a, b, c, d, e, F1, KK3, 12,  9);
	R(e, a, b, c, d, F1, KK3,  5,  7);
	R(d, e, a, b, c, F1, KK3, 15, 10);
	R(c, d, e, a, b, F1, KK3,  8, 14); /* #63 */
	/* Parallel round 5 */
	R(b, c, d, e, a, F0, KK4,  8, 12);
	R(a, b, c, d, e, F0, KK4,  5, 15);
	R(e, a, b, c, d, F0, KK4, 12, 10);
	R(d, e, a, b, c, F0, KK4,  9,  4);
	R(c, d, e, a, b, F0, KK4, 12,  1);
	R(b, c, d, e, a, F0, KK4,  5,  5);
	R(a, b, c, d, e, F0, KK4, 14,  8);
	R(e, a, b, c, d, F0, KK4,  6,  7);
	R(d, e, a, b, c, F0, KK4,  8,  6);
	R(c, d, e, a, b, F0, KK4, 13,  2);
	R(b, c, d, e, a, F0, KK4,  6, 13);
	R(a, b, c, d, e, F0, KK4,  5, 14);
	R(e, a, b, c, d, F0, KK4, 15,  0);
	R(d, e, a, b, c, F0, KK4, 13,  3);
	R(c, d, e, a, b, F0, KK4, 11,  9);
	R(b, c, d, e, a, F0, KK4, 11, 11); /* #79 */

	t =        state[1] + cc + d;
	state[1] = state[2] + dd + e;
	state[2] = state[3] + ee + a;
	state[3] = state[4] + aa + b;
	state[4] = state[0] + bb + c;
	state[0] = t;
}
DEF_WEAK(RMD160Transform);
@


1.21
log
@Use explicit_bzero instead of memset in hash Final and End functions.
OK deraadt@@ djm@@
@
text
@d101 1
d129 1
d149 1
d161 1
d374 1
@


1.20
log
@Switch from <sys/endian.h> or <machine/endian.h> to the new,
being-standardized <endian.h>

ok deraadt@@ millert@@ beck@@
@
text
@d156 1
a156 1
	memset(ctx, 0, sizeof (*ctx));
@


1.19
log
@calling HashFinal with a null digest should crash, not be silently ignored
@
text
@d29 2
a31 2
#include <sys/types.h>
#include <sys/endian.h>
@


1.18
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d154 3
a156 5
	if (digest != NULL) {
		for (i = 0; i < 5; i++)
			PUT_32BIT_LE(digest + i*4, ctx->state[i]);
		memset(ctx, 0, sizeof (*ctx));
	}
@


1.17
log
@In the Final function, move the context zeroing into the digest != NULL
scope so that passing a NULL digest is equivalent to the Pad function
(like it used to be).  Fixes skey w/ sha1 as noticed by David Krause.
@
text
@a33 4
#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: rmd160.c,v 1.16 2004/05/03 18:07:07 millert Exp $";
#endif /* LIBC_SCCS and not lint */

@


1.16
log
@Some u_char -> u_int8_t conversion I missed earlier.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: rmd160.c,v 1.15 2004/05/03 17:30:15 millert Exp $";
d158 1
a158 1
	if (digest != NULL)
d161 2
a162 2

	memset(ctx, 0, sizeof (*ctx));
@


1.15
log
@Add Pad and FileChunk functions for each family of hash functions.
The Pad function does padding like in Final but does not finish processing.
The FileChunk function creates a digest from a portion of a file.
Also made the length parameters consistent (and size_t).
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: rmd160.c,v 1.14 2004/04/26 19:38:12 millert Exp $";
d89 1
a89 1
static u_char PADDING[RMD160_BLOCK_LENGTH] = {
d107 1
a107 1
RMD160Update(RMD160_CTX *ctx, const u_char *input, size_t len)
d153 1
a153 1
RMD160Final(u_char digest[RMD160_DIGEST_LENGTH], RMD160_CTX *ctx)
d166 1
a166 1
RMD160Transform(u_int32_t state[5], const u_char block[RMD160_BLOCK_LENGTH])
@


1.14
log
@Use a common source file for all the hash helper functions that
previously lived in foohl.c.  The foohl.c files are now generated
via sed, though perhaps cpp could be used in the future.

Use u_int8_t instead of unsigned char for the buffers struct fooContext.
Add constants for buffer lengths and use them in function prototypes
and the man pages.

This is basically cosmetic surgery; there should be no functional changes.

OK deraadt@@
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: rmd160.c,v 1.13 2003/12/14 11:22:35 markus Exp $";
d107 1
a107 1
RMD160Update(RMD160_CTX *ctx, const u_char *input, u_int32_t len)
d109 1
a109 1
	u_int32_t have, off, need;
d134 1
a134 1
RMD160Final(u_char digest[RMD160_DIGEST_LENGTH], RMD160_CTX *ctx)
d136 2
a137 3
	int i;
	u_char size[8];
	u_int32_t padlen;
d150 6
d157 1
@


1.13
log
@alignment fixes (e.g sparc 64); from Daniel Lucq; ok millert, henning
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: rmd160.c,v 1.12 2002/12/23 04:33:31 millert Exp $";
d89 1
a89 1
static u_char PADDING[64] = {
d111 2
a112 2
	have = (ctx->count/8) % 64;
	need = 64 - have;
d124 1
a124 1
		while (off + 64 <= len) {
d126 1
a126 1
			off += 64;
d134 1
a134 1
RMD160Final(u_char digest[20], RMD160_CTX *ctx)
d143 2
a144 2
	 * pad to 64 byte blocks, at least one byte from PADDING plus 8 bytes
	 * for the size
d146 1
a146 1
	padlen = 64 - ((ctx->count/8) % 64);
d148 1
a148 1
		padlen += 64;
d160 1
a160 1
RMD160Transform(u_int32_t state[5], const u_char block[64])
d165 1
a165 1
	memcpy(x, block, 64);
@


1.12
log
@o Ansi function headers
o Add __BEGIN_DECLS/__END_DECLS to include files
o Safe macros
o Remove useless variable assignment in the End function of *hl.c
o Some minor KNF, needs more
From Dan Weeks
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: rmd160.c,v 1.11 2001/10/01 20:36:17 markus Exp $";
d170 5
a174 1
		x[i] = swap32(*(u_int32_t*)(block+i*4));
@


1.11
log
@new rmd160 implementation.  based on
ftp://ftp.rsasecurity.com/pub/cryptobytes/crypto3n2.pdf, ok deraadt@@
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: $";
d38 8
a45 8
#define PUT_64BIT_LE(cp, value) do { \
	(cp)[7] = (value) >> 56; \
	(cp)[6] = (value) >> 48; \
	(cp)[5] = (value) >> 40; \
	(cp)[4] = (value) >> 32; \
	(cp)[3] = (value) >> 24; \
	(cp)[2] = (value) >> 16; \
	(cp)[1] = (value) >> 8; \
d48 4
a51 4
#define PUT_32BIT_LE(cp, value) do { \
	(cp)[3] = (value) >> 24; \
	(cp)[2] = (value) >> 16; \
	(cp)[1] = (value) >> 8; \
d81 4
a84 4
#define R(a, b, c, d, e, Fj, Kj, sj, rj) \
	do { \
		a = ROL(sj, a + Fj(b,c,d) + X(rj) + Kj) + e; \
		c = ROL(10, c); \
@


1.10
log
@Explicitly include <sys/types.h> and some minor style points.
@
text
@d1 2
a2 1
/********************************************************************\
d4 8
a11 1
 *      FILE:     rmd160.c
d13 16
a28 17
 *      CONTENTS: A sample C-implementation of the RIPEMD-160
 *		  hash-function.
 *      TARGET:   any computer with an ANSI C compiler
 *
 *      AUTHOR:   Antoon Bosselaers, ESAT-COSIC
 *		  (Arranged for libc by Todd C. Miller)
 *      DATE:     1 March 1996
 *      VERSION:  1.0
 *
 *      Copyright (c) Katholieke Universiteit Leuven
 *      1996, All Rights Reserved
 *
\********************************************************************/

/* header files */
#include <stdio.h>
#include <stdlib.h>
d31 1
d34 60
a93 75
/********************************************************************/

/* macro definitions */

/* collect four bytes into one word: */
#define BYTES_TO_DWORD(strptr)			\
    (((u_int32_t) *((strptr)+3) << 24) |	\
    ((u_int32_t) *((strptr)+2) << 16) |		\
    ((u_int32_t) *((strptr)+1) <<  8) |		\
    ((u_int32_t) *(strptr)))

/* ROL(x, n) cyclically rotates x over n bits to the left */
/* x must be of an unsigned 32 bits type and 0 <= n < 32. */
#define ROL(x, n)	(((x) << (n)) | ((x) >> (32-(n))))

/* the three basic functions F(), G() and H() */
#define F(x, y, z)	((x) ^ (y) ^ (z))
#define G(x, y, z)	(((x) & (y)) | (~(x) & (z)))
#define H(x, y, z)	(((x) | ~(y)) ^ (z))
#define I(x, y, z)	(((x) & (z)) | ((y) & ~(z)))
#define J(x, y, z)	((x) ^ ((y) | ~(z)))

/* the eight basic operations FF() through III() */
#define FF(a, b, c, d, e, x, s)	{			\
      (a) += F((b), (c), (d)) + (x);			\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}
#define GG(a, b, c, d, e, x, s)	{			\
      (a) += G((b), (c), (d)) + (x) + 0x5a827999U;	\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}
#define HH(a, b, c, d, e, x, s)	{			\
      (a) += H((b), (c), (d)) + (x) + 0x6ed9eba1U;	\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}
#define II(a, b, c, d, e, x, s)	{			\
      (a) += I((b), (c), (d)) + (x) + 0x8f1bbcdcU;	\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}
#define JJ(a, b, c, d, e, x, s)	{			\
      (a) += J((b), (c), (d)) + (x) + 0xa953fd4eU;	\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}
#define FFF(a, b, c, d, e, x, s)	{		\
      (a) += F((b), (c), (d)) + (x);			\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}
#define GGG(a, b, c, d, e, x, s)	{		\
      (a) += G((b), (c), (d)) + (x) + 0x7a6d76e9U;	\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}
#define HHH(a, b, c, d, e, x, s)	{		\
      (a) += H((b), (c), (d)) + (x) + 0x6d703ef3U;	\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}
#define III(a, b, c, d, e, x, s)	{		\
      (a) += I((b), (c), (d)) + (x) + 0x5c4dd124U;	\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}
#define JJJ(a, b, c, d, e, x, s)	{		\
      (a) += J((b), (c), (d)) + (x) + 0x50a28be6U;	\
      (a) = ROL((a), (s)) + (e);			\
      (c) = ROL((c), 10);				\
}

/********************************************************************/
d96 1
a96 2
RMD160Init(context)
	RMD160_CTX *context;
d98 6
a103 9

	/* ripemd-160 initialization constants */
	context->state[0] = 0x67452301U;
	context->state[1] = 0xefcdab89U;
	context->state[2] = 0x98badcfeU;
	context->state[3] = 0x10325476U;
	context->state[4] = 0xc3d2e1f0U;
	context->length[0] = context->length[1] = 0;
	context->buflen = 0;
a105 2
/********************************************************************/

d107 1
a107 3
RMD160Transform(state, block)
	u_int32_t state[5];
	const u_int32_t block[16];
d109 22
a130 192
	u_int32_t aa = state[0],  bb = state[1],  cc = state[2],
	    dd = state[3],  ee = state[4];
	u_int32_t aaa = state[0], bbb = state[1], ccc = state[2],
	    ddd = state[3], eee = state[4];

	/* round 1 */
	FF(aa, bb, cc, dd, ee, block[ 0], 11);
	FF(ee, aa, bb, cc, dd, block[ 1], 14);
	FF(dd, ee, aa, bb, cc, block[ 2], 15);
	FF(cc, dd, ee, aa, bb, block[ 3], 12);
	FF(bb, cc, dd, ee, aa, block[ 4],  5);
	FF(aa, bb, cc, dd, ee, block[ 5],  8);
	FF(ee, aa, bb, cc, dd, block[ 6],  7);
	FF(dd, ee, aa, bb, cc, block[ 7],  9);
	FF(cc, dd, ee, aa, bb, block[ 8], 11);
	FF(bb, cc, dd, ee, aa, block[ 9], 13);
	FF(aa, bb, cc, dd, ee, block[10], 14);
	FF(ee, aa, bb, cc, dd, block[11], 15);
	FF(dd, ee, aa, bb, cc, block[12],  6);
	FF(cc, dd, ee, aa, bb, block[13],  7);
	FF(bb, cc, dd, ee, aa, block[14],  9);
	FF(aa, bb, cc, dd, ee, block[15],  8);

	/* round 2 */
	GG(ee, aa, bb, cc, dd, block[ 7],  7);
	GG(dd, ee, aa, bb, cc, block[ 4],  6);
	GG(cc, dd, ee, aa, bb, block[13],  8);
	GG(bb, cc, dd, ee, aa, block[ 1], 13);
	GG(aa, bb, cc, dd, ee, block[10], 11);
	GG(ee, aa, bb, cc, dd, block[ 6],  9);
	GG(dd, ee, aa, bb, cc, block[15],  7);
	GG(cc, dd, ee, aa, bb, block[ 3], 15);
	GG(bb, cc, dd, ee, aa, block[12],  7);
	GG(aa, bb, cc, dd, ee, block[ 0], 12);
	GG(ee, aa, bb, cc, dd, block[ 9], 15);
	GG(dd, ee, aa, bb, cc, block[ 5],  9);
	GG(cc, dd, ee, aa, bb, block[ 2], 11);
	GG(bb, cc, dd, ee, aa, block[14],  7);
	GG(aa, bb, cc, dd, ee, block[11], 13);
	GG(ee, aa, bb, cc, dd, block[ 8], 12);

	/* round 3 */
	HH(dd, ee, aa, bb, cc, block[ 3], 11);
	HH(cc, dd, ee, aa, bb, block[10], 13);
	HH(bb, cc, dd, ee, aa, block[14],  6);
	HH(aa, bb, cc, dd, ee, block[ 4],  7);
	HH(ee, aa, bb, cc, dd, block[ 9], 14);
	HH(dd, ee, aa, bb, cc, block[15],  9);
	HH(cc, dd, ee, aa, bb, block[ 8], 13);
	HH(bb, cc, dd, ee, aa, block[ 1], 15);
	HH(aa, bb, cc, dd, ee, block[ 2], 14);
	HH(ee, aa, bb, cc, dd, block[ 7],  8);
	HH(dd, ee, aa, bb, cc, block[ 0], 13);
	HH(cc, dd, ee, aa, bb, block[ 6],  6);
	HH(bb, cc, dd, ee, aa, block[13],  5);
	HH(aa, bb, cc, dd, ee, block[11], 12);
	HH(ee, aa, bb, cc, dd, block[ 5],  7);
	HH(dd, ee, aa, bb, cc, block[12],  5);

	/* round 4 */
	II(cc, dd, ee, aa, bb, block[ 1], 11);
	II(bb, cc, dd, ee, aa, block[ 9], 12);
	II(aa, bb, cc, dd, ee, block[11], 14);
	II(ee, aa, bb, cc, dd, block[10], 15);
	II(dd, ee, aa, bb, cc, block[ 0], 14);
	II(cc, dd, ee, aa, bb, block[ 8], 15);
	II(bb, cc, dd, ee, aa, block[12],  9);
	II(aa, bb, cc, dd, ee, block[ 4],  8);
	II(ee, aa, bb, cc, dd, block[13],  9);
	II(dd, ee, aa, bb, cc, block[ 3], 14);
	II(cc, dd, ee, aa, bb, block[ 7],  5);
	II(bb, cc, dd, ee, aa, block[15],  6);
	II(aa, bb, cc, dd, ee, block[14],  8);
	II(ee, aa, bb, cc, dd, block[ 5],  6);
	II(dd, ee, aa, bb, cc, block[ 6],  5);
	II(cc, dd, ee, aa, bb, block[ 2], 12);

	/* round 5 */
	JJ(bb, cc, dd, ee, aa, block[ 4],  9);
	JJ(aa, bb, cc, dd, ee, block[ 0], 15);
	JJ(ee, aa, bb, cc, dd, block[ 5],  5);
	JJ(dd, ee, aa, bb, cc, block[ 9], 11);
	JJ(cc, dd, ee, aa, bb, block[ 7],  6);
	JJ(bb, cc, dd, ee, aa, block[12],  8);
	JJ(aa, bb, cc, dd, ee, block[ 2], 13);
	JJ(ee, aa, bb, cc, dd, block[10], 12);
	JJ(dd, ee, aa, bb, cc, block[14],  5);
	JJ(cc, dd, ee, aa, bb, block[ 1], 12);
	JJ(bb, cc, dd, ee, aa, block[ 3], 13);
	JJ(aa, bb, cc, dd, ee, block[ 8], 14);
	JJ(ee, aa, bb, cc, dd, block[11], 11);
	JJ(dd, ee, aa, bb, cc, block[ 6],  8);
	JJ(cc, dd, ee, aa, bb, block[15],  5);
	JJ(bb, cc, dd, ee, aa, block[13],  6);

	/* parallel round 1 */
	JJJ(aaa, bbb, ccc, ddd, eee, block[ 5],  8);
	JJJ(eee, aaa, bbb, ccc, ddd, block[14],  9);
	JJJ(ddd, eee, aaa, bbb, ccc, block[ 7],  9);
	JJJ(ccc, ddd, eee, aaa, bbb, block[ 0], 11);
	JJJ(bbb, ccc, ddd, eee, aaa, block[ 9], 13);
	JJJ(aaa, bbb, ccc, ddd, eee, block[ 2], 15);
	JJJ(eee, aaa, bbb, ccc, ddd, block[11], 15);
	JJJ(ddd, eee, aaa, bbb, ccc, block[ 4],  5);
	JJJ(ccc, ddd, eee, aaa, bbb, block[13],  7);
	JJJ(bbb, ccc, ddd, eee, aaa, block[ 6],  7);
	JJJ(aaa, bbb, ccc, ddd, eee, block[15],  8);
	JJJ(eee, aaa, bbb, ccc, ddd, block[ 8], 11);
	JJJ(ddd, eee, aaa, bbb, ccc, block[ 1], 14);
	JJJ(ccc, ddd, eee, aaa, bbb, block[10], 14);
	JJJ(bbb, ccc, ddd, eee, aaa, block[ 3], 12);
	JJJ(aaa, bbb, ccc, ddd, eee, block[12],  6);

	/* parallel round 2 */
	III(eee, aaa, bbb, ccc, ddd, block[ 6],  9);
	III(ddd, eee, aaa, bbb, ccc, block[11], 13);
	III(ccc, ddd, eee, aaa, bbb, block[ 3], 15);
	III(bbb, ccc, ddd, eee, aaa, block[ 7],  7);
	III(aaa, bbb, ccc, ddd, eee, block[ 0], 12);
	III(eee, aaa, bbb, ccc, ddd, block[13],  8);
	III(ddd, eee, aaa, bbb, ccc, block[ 5],  9);
	III(ccc, ddd, eee, aaa, bbb, block[10], 11);
	III(bbb, ccc, ddd, eee, aaa, block[14],  7);
	III(aaa, bbb, ccc, ddd, eee, block[15],  7);
	III(eee, aaa, bbb, ccc, ddd, block[ 8], 12);
	III(ddd, eee, aaa, bbb, ccc, block[12],  7);
	III(ccc, ddd, eee, aaa, bbb, block[ 4],  6);
	III(bbb, ccc, ddd, eee, aaa, block[ 9], 15);
	III(aaa, bbb, ccc, ddd, eee, block[ 1], 13);
	III(eee, aaa, bbb, ccc, ddd, block[ 2], 11);

	/* parallel round 3 */
	HHH(ddd, eee, aaa, bbb, ccc, block[15],  9);
	HHH(ccc, ddd, eee, aaa, bbb, block[ 5],  7);
	HHH(bbb, ccc, ddd, eee, aaa, block[ 1], 15);
	HHH(aaa, bbb, ccc, ddd, eee, block[ 3], 11);
	HHH(eee, aaa, bbb, ccc, ddd, block[ 7],  8);
	HHH(ddd, eee, aaa, bbb, ccc, block[14],  6);
	HHH(ccc, ddd, eee, aaa, bbb, block[ 6],  6);
	HHH(bbb, ccc, ddd, eee, aaa, block[ 9], 14);
	HHH(aaa, bbb, ccc, ddd, eee, block[11], 12);
	HHH(eee, aaa, bbb, ccc, ddd, block[ 8], 13);
	HHH(ddd, eee, aaa, bbb, ccc, block[12],  5);
	HHH(ccc, ddd, eee, aaa, bbb, block[ 2], 14);
	HHH(bbb, ccc, ddd, eee, aaa, block[10], 13);
	HHH(aaa, bbb, ccc, ddd, eee, block[ 0], 13);
	HHH(eee, aaa, bbb, ccc, ddd, block[ 4],  7);
	HHH(ddd, eee, aaa, bbb, ccc, block[13],  5);

	/* parallel round 4 */
	GGG(ccc, ddd, eee, aaa, bbb, block[ 8], 15);
	GGG(bbb, ccc, ddd, eee, aaa, block[ 6],  5);
	GGG(aaa, bbb, ccc, ddd, eee, block[ 4],  8);
	GGG(eee, aaa, bbb, ccc, ddd, block[ 1], 11);
	GGG(ddd, eee, aaa, bbb, ccc, block[ 3], 14);
	GGG(ccc, ddd, eee, aaa, bbb, block[11], 14);
	GGG(bbb, ccc, ddd, eee, aaa, block[15],  6);
	GGG(aaa, bbb, ccc, ddd, eee, block[ 0], 14);
	GGG(eee, aaa, bbb, ccc, ddd, block[ 5],  6);
	GGG(ddd, eee, aaa, bbb, ccc, block[12],  9);
	GGG(ccc, ddd, eee, aaa, bbb, block[ 2], 12);
	GGG(bbb, ccc, ddd, eee, aaa, block[13],  9);
	GGG(aaa, bbb, ccc, ddd, eee, block[ 9], 12);
	GGG(eee, aaa, bbb, ccc, ddd, block[ 7],  5);
	GGG(ddd, eee, aaa, bbb, ccc, block[10], 15);
	GGG(ccc, ddd, eee, aaa, bbb, block[14],  8);

	/* parallel round 5 */
	FFF(bbb, ccc, ddd, eee, aaa, block[12] ,  8);
	FFF(aaa, bbb, ccc, ddd, eee, block[15] ,  5);
	FFF(eee, aaa, bbb, ccc, ddd, block[10] , 12);
	FFF(ddd, eee, aaa, bbb, ccc, block[ 4] ,  9);
	FFF(ccc, ddd, eee, aaa, bbb, block[ 1] , 12);
	FFF(bbb, ccc, ddd, eee, aaa, block[ 5] ,  5);
	FFF(aaa, bbb, ccc, ddd, eee, block[ 8] , 14);
	FFF(eee, aaa, bbb, ccc, ddd, block[ 7] ,  6);
	FFF(ddd, eee, aaa, bbb, ccc, block[ 6] ,  8);
	FFF(ccc, ddd, eee, aaa, bbb, block[ 2] , 13);
	FFF(bbb, ccc, ddd, eee, aaa, block[13] ,  6);
	FFF(aaa, bbb, ccc, ddd, eee, block[14] ,  5);
	FFF(eee, aaa, bbb, ccc, ddd, block[ 0] , 15);
	FFF(ddd, eee, aaa, bbb, ccc, block[ 3] , 13);
	FFF(ccc, ddd, eee, aaa, bbb, block[ 9] , 11);
	FFF(bbb, ccc, ddd, eee, aaa, block[11] , 11);

	/* combine results */
	ddd += cc + state[1];		/* final result for state[0] */
	state[1] = state[2] + dd + eee;
	state[2] = state[3] + ee + aaa;
	state[3] = state[4] + aa + bbb;
	state[4] = state[0] + bb + ccc;
	state[0] = ddd;
a132 2
/********************************************************************/

d134 1
a134 4
RMD160Update(context, data, nbytes)
	RMD160_CTX *context;
	const u_char *data;
	u_int32_t nbytes;
d136 19
a154 43
	u_int32_t X[16];
	u_int32_t ofs = 0;
	u_int32_t i;
#if BYTE_ORDER != LITTLE_ENDIAN
	u_int32_t j;
#endif

	/* update length[] */
	if (context->length[0] + nbytes < context->length[0])
		context->length[1]++;		/* overflow to msb of length */
	context->length[0] += nbytes;

	(void)memset(X, 0, sizeof(X));

        if ( context->buflen + nbytes < 64 )
        {
                (void)memcpy(context->bbuffer + context->buflen, data, nbytes);
                context->buflen += nbytes;
        }
        else
        {
                /* process first block */
                ofs = 64 - context->buflen;
                (void)memcpy(context->bbuffer + context->buflen, data, ofs);
#if BYTE_ORDER == LITTLE_ENDIAN
                (void)memcpy(X, context->bbuffer, sizeof(X));
#else
                for (j=0; j < 16; j++)
                        X[j] = BYTES_TO_DWORD(context->bbuffer + (4 * j));
#endif
                RMD160Transform(context->state, X);
                nbytes -= ofs;

                /* process remaining complete blocks */
                for (i = 0; i < (nbytes >> 6); i++) {
#if BYTE_ORDER == LITTLE_ENDIAN
                        (void)memcpy(X, data + (64 * i) + ofs, sizeof(X));
#else
                        for (j=0; j < 16; j++)
                                X[j] = BYTES_TO_DWORD(data + (64 * i) + (4 * j) + ofs);
#endif
                        RMD160Transform(context->state, X);
                }
d156 1
a156 6
                /*
                 * Put last bytes from data into context's buffer
                 */
                context->buflen = nbytes & 63;
                memcpy(context->bbuffer, data + (64 * i) + ofs, context->buflen);
        }
a158 2
/********************************************************************/

d160 1
a160 3
RMD160Final(digest, context)
	u_char digest[20];
	RMD160_CTX *context;
d162 1
a162 8
	u_int32_t i;
	u_int32_t X[16];
#if BYTE_ORDER != LITTLE_ENDIAN
	u_int32_t j;
#endif

	/* append the bit m_n == 1 */
	context->bbuffer[context->buflen] = '\200';
a163 2
	(void)memset(context->bbuffer + context->buflen + 1, 0,
		63 - context->buflen);
d165 1
a165 1
	(void)memcpy(X, context->bbuffer, sizeof(X));
d167 4
a170 2
	for (j=0; j < 16; j++)
		X[j] = BYTES_TO_DWORD(context->bbuffer + (4 * j));
a171 5
	if ((context->buflen) > 55) {
		/* length goes to next block */
		RMD160Transform(context->state, X);
		(void)memset(X, 0, sizeof(X));
	}
d173 192
a364 15
	/* append length in bits */
	X[14] = context->length[0] << 3;
	X[15] = (context->length[0] >> 29) |
	    (context->length[1] << 3);
	RMD160Transform(context->state, X);

	if (digest != NULL) {
		for (i = 0; i < 20; i += 4) {
			/* extracts the 8 least significant bits. */
			digest[i]     =  context->state[i>>2];
			digest[i + 1] = (context->state[i>>2] >>  8);
			digest[i + 2] = (context->state[i>>2] >> 16);
			digest[i + 3] = (context->state[i>>2] >> 24);
		}
	}
a365 2

/************************ end of file rmd160.c **********************/
@


1.9
log
@Make RMD160Update a little less overzealous when fed small crumbs.
@
text
@d19 1
a19 1
/*  header files */
d23 1
d102 2
a103 1
void RMD160Init(context)
d119 2
a120 1
void RMD160Transform(state, block)
d320 2
a321 1
void RMD160Update(context, data, nbytes)
d380 2
a381 1
void RMD160Final(digest, context)
@


1.8
log
@nbytes - ofs should never be less than 0 (Oops on me)
@
text
@d336 10
a345 5
	if (context->buflen > 0) {
		ofs = 64 - context->buflen;
		if ( ofs > nbytes )
			ofs = nbytes;
		(void)memcpy(context->bbuffer + context->buflen, data, ofs);
d347 1
a347 1
		(void)memcpy(X, context->bbuffer, sizeof(X));
d349 2
a350 2
		for (j=0; j < 16; j++)
			X[j] = BYTES_TO_DWORD(context->bbuffer + (4 * j));
d352 2
a353 3
		RMD160Transform(context->state, X);
		nbytes -= ofs;
	}
d355 2
a356 2
	/* process all complete blocks */
	for (i = 0; i < (nbytes >> 6); i++) {
d358 1
a358 1
		(void)memcpy(X, data + (64 * i) + ofs, sizeof(X));
d360 2
a361 2
		for (j=0; j < 16; j++)
			X[j] = BYTES_TO_DWORD(data + (64 * i) + (4 * j) + ofs);
d363 2
a364 2
		RMD160Transform(context->state, X);
	}
d366 6
a371 5
	/*
	 * Put bytes from data into context's buffer
	 */
	context->buflen = nbytes & 63;
	memcpy(context->bbuffer, data + (64 * i) + ofs, context->buflen);
@


1.7
log
@teach rmd160 not to throw leftovers out the window
@
text
@d338 2
@


1.6
log
@Fix compiler warnings.
@
text
@d112 1
d323 1
d328 6
d336 13
d352 1
a352 1
		(void)memcpy(X, data, sizeof(X));
d355 1
a355 1
			X[j] = BYTES_TO_DWORD(data + (64 * i) + (4 * j));
a359 5
	/* update length[] */
	if (context->length[0] + nbytes < context->length[0])
		context->length[1]++;		/* overflow to msb of length */
	context->length[0] += nbytes;

d363 2
a364 7
	(void)memset(context->buffer, 0, 16 * sizeof(u_int32_t));
	/* extract bytes 6 to 10 inclusive */
	data += (context->length[0] & 0x3C0);
	for (i = 0; i < (context->length[0] & 63); i++) {
		/* byte i goes into word buffer[i div 4] at pos.  8*(i mod 4) */
		context->buffer[i>>2] ^= (u_int32_t) *data++ << (8 * (i & 3));
	}
d374 4
d380 1
a380 2
	context->buffer[(context->length[0] >> 2) & 15] ^=
	    1U << (8 * (context->length[0] & 3) + 7);
d382 9
a390 1
	if ((context->length[0] & 63) > 55) {
d392 2
a393 2
		RMD160Transform(context->state, context->buffer);
		(void)memset(context->buffer, 0, 16 * sizeof(u_int32_t));
d397 2
a398 2
	context->buffer[14] = context->length[0] << 3;
	context->buffer[15] = (context->length[0] >> 29) |
d400 1
a400 1
	RMD160Transform(context->state, context->buffer);
@


1.5
log
@tabify + trailing blanks
@
text
@d321 5
a325 2
	u_int32_t i, j, X[16];

@


1.4
log
@Converting u_char[] -> u_int[] is easy on little endian machines :-)
@
text
@d6 1
a6 1
 *                hash-function.
d10 1
a10 1
 *                (Arranged for libc by Todd C. Miller)
@


1.3
log
@Use u_int32_t not size_t.
@
text
@d323 1
a323 1
	(void)memset(X, 0, 16 * sizeof(u_int32_t));
d327 3
d332 1
@


1.2
log
@Allow passing of a NULL digest to RMD160Final(3).
@
text
@d319 1
a319 1
	size_t nbytes;
d321 1
a321 2
	u_int32_t	X[16];
	size_t	i, j;
@


1.1
log
@mdX(3)-like interface to RIPEMD-160 hash function.  Code by
Antoon Bosselaers and massaged by me to fit the mdX(3) API.
@
text
@d374 8
a381 6
	for (i = 0; i < 20; i += 4) {
		/* extracts the 8 least significant bits. */
		digest[i]     =  context->state[i>>2];
		digest[i + 1] = (context->state[i>>2] >>  8);
		digest[i + 2] = (context->state[i>>2] >> 16);
		digest[i + 3] = (context->state[i>>2] >> 24);
@
