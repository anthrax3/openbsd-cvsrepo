head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.6
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.8
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.16.0.8
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.12
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.10
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	OPENBSD_5_0:1.15.0.6
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.10
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.12
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.8
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.6
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.14
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.12
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.10
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@.\" @;


1.22
date	2015.09.14.20.06.58;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	r87YNrjEWwl7OkJ0;

1.21
date	2015.02.28.21.51.57;	author bentley;	state Exp;
branches;
next	1.20;
commitid	NNu2UZnsd5zmNVYD;

1.20
date	2014.12.09.15.37.14;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	tNzoEq4pb5PMsxy6;

1.19
date	2014.12.09.14.39.37;	author jmc;	state Exp;
branches;
next	1.18;
commitid	TCQvmwwDbfRJCZSU;

1.18
date	2014.09.10.15.10.19;	author jmc;	state Exp;
branches;
next	1.17;
commitid	qjl31Z6cdVfbbk1K;

1.17
date	2014.09.10.11.25.32;	author jsg;	state Exp;
branches;
next	1.16;
commitid	TSieH1HZfZlNLrIR;

1.16
date	2013.06.05.22.05.29;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.15.20.51.38;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.31.19.19.30;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.05.19.40.22;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.28.20.56.00;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.07.14.49.53;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.18.36;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.18.03.01.33;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.14.21.31.45;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.07.09.13.35.22;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.05.23.14.11.02;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	97.07.29.02.29.09;	author flipk;	state Exp;
branches;
next	1.4;

1.4
date	97.07.17.05.20.53;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.04.28.20.44.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.31.08;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.08;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Avoid .Ns right after .Pf, it's pointless.
In some cases, do additional cleanup in the immediate vicinity.
@
text
@.\"	$OpenBSD: re_format.7,v 1.21 2015/02/28 21:51:57 bentley Exp $
.\"
.\" Copyright (c) 1997, Phillip F Knaack. All rights reserved.
.\"
.\" Copyright (c) 1992, 1993, 1994 Henry Spencer.
.\" Copyright (c) 1992, 1993, 1994
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Henry Spencer.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@@(#)re_format.7	8.3 (Berkeley) 3/20/94
.\"
.Dd $Mdocdate: February 28 2015 $
.Dt RE_FORMAT 7
.Os
.Sh NAME
.Nm re_format
.Nd POSIX regular expressions
.Sh DESCRIPTION
Regular expressions (REs),
as defined in
.St -p1003.1-2004 ,
come in two forms:
basic regular expressions
(BREs)
and extended regular expressions
(EREs).
Both forms of regular expressions are supported
by the interfaces described in
.Xr regex 3 .
Applications dealing with regular expressions
may use one or the other form
(or indeed both).
For example,
.Xr ed 1
uses BREs,
whilst
.Xr egrep 1
talks EREs.
Consult the manual page for the specific application to find out which
it uses.
.Pp
POSIX leaves some aspects of RE syntax and semantics open;
.Sq **
marks decisions on these aspects that
may not be fully portable to other POSIX implementations.
.Pp
This manual page first describes regular expressions in general,
specifically extended regular expressions,
and then discusses differences between them and basic regular expressions.
.Sh EXTENDED REGULAR EXPRESSIONS
An ERE is one** or more non-empty**
.Em branches ,
separated by
.Sq | .
It matches anything that matches one of the branches.
.Pp
A branch is one** or more
.Em pieces ,
concatenated.
It matches a match for the first, followed by a match for the second, etc.
.Pp
A piece is an
.Em atom
possibly followed by a single**
.Sq * ,
.Sq + ,
.Sq ?\& ,
or
.Em bound .
An atom followed by
.Sq *
matches a sequence of 0 or more matches of the atom.
An atom followed by
.Sq +
matches a sequence of 1 or more matches of the atom.
An atom followed by
.Sq ?\&
matches a sequence of 0 or 1 matches of the atom.
.Pp
A bound is
.Sq {
followed by an unsigned decimal integer,
possibly followed by
.Sq ,\&
possibly followed by another unsigned decimal integer,
always followed by
.Sq } .
The integers must lie between 0 and
.Dv RE_DUP_MAX
(255**) inclusive,
and if there are two of them, the first may not exceed the second.
An atom followed by a bound containing one integer
.Ar i
and no comma matches
a sequence of exactly
.Ar i
matches of the atom.
An atom followed by a bound
containing one integer
.Ar i
and a comma matches
a sequence of
.Ar i
or more matches of the atom.
An atom followed by a bound
containing two integers
.Ar i
and
.Ar j
matches a sequence of
.Ar i
through
.Ar j
(inclusive) matches of the atom.
.Pp
An atom is a regular expression enclosed in
.Sq ()
(matching a part of the regular expression),
an empty set of
.Sq ()
(matching the null string)**,
a
.Em bracket expression
(see below),
.Sq .\&
(matching any single character),
.Sq ^
(matching the null string at the beginning of a line),
.Sq $
(matching the null string at the end of a line),
a
.Sq \e
followed by one of the characters
.Sq ^.[$()|*+?{\e
(matching that character taken as an ordinary character),
a
.Sq \e
followed by any other character**
(matching that character taken as an ordinary character,
as if the
.Sq \e
had not been present**),
or a single character with no other significance (matching that character).
A
.Sq {
followed by a character other than a digit is an ordinary character,
not the beginning of a bound**.
It is illegal to end an RE with
.Sq \e .
.Pp
A bracket expression is a list of characters enclosed in
.Sq [] .
It normally matches any single character from the list (but see below).
If the list begins with
.Sq ^ ,
it matches any single character
.Em not
from the rest of the list
(but see below).
If two characters in the list are separated by
.Sq - ,
this is shorthand for the full
.Em range
of characters between those two (inclusive) in the
collating sequence, e.g.\&
.Sq [0-9]
in ASCII matches any decimal digit.
It is illegal** for two ranges to share an endpoint, e.g.\&
.Sq a-c-e .
Ranges are very collating-sequence-dependent,
and portable programs should avoid relying on them.
.Pp
To include a literal
.Sq ]\&
in the list, make it the first character
(following a possible
.Sq ^ ) .
To include a literal
.Sq - ,
make it the first or last character,
or the second endpoint of a range.
To use a literal
.Sq -
as the first endpoint of a range,
enclose it in
.Sq [.
and
.Sq .]
to make it a collating element (see below).
With the exception of these and some combinations using
.Sq \&[
(see next paragraphs),
all other special characters, including
.Sq \e ,
lose their special significance within a bracket expression.
.Pp
Within a bracket expression, a collating element
(a character,
a multi-character sequence that collates as if it were a single character,
or a collating-sequence name for either)
enclosed in
.Sq [.
and
.Sq .]
stands for the sequence of characters of that collating element.
The sequence is a single element of the bracket expression's list.
A bracket expression containing a multi-character collating element
can thus match more than one character,
e.g. if the collating sequence includes a
.Sq ch
collating element,
then the RE
.Sq [[.ch.]]*c
matches the first five characters of
.Sq chchcc .
.Pp
Within a bracket expression, a collating element enclosed in
.Sq [=
and
.Sq =]
is an equivalence class, standing for the sequences of characters
of all collating elements equivalent to that one, including itself.
(If there are no other equivalent collating elements,
the treatment is as if the enclosing delimiters were
.Sq [.
and
.Sq .] . )
For example, if
.Sq x
and
.Sq y
are the members of an equivalence class,
then
.Sq [[=x=]] ,
.Sq [[=y=]] ,
and
.Sq [xy]
are all synonymous.
An equivalence class may not** be an endpoint of a range.
.Pp
Within a bracket expression, the name of a
.Em character class
enclosed
in
.Sq [:
and
.Sq :]
stands for the list of all characters belonging to that class.
Standard character class names are:
.Bd -literal -offset indent
alnum	digit	punct
alpha	graph	space
blank	lower	upper
cntrl	print	xdigit
.Ed
.Pp
These stand for the character classes defined in
.Xr isalnum 3 ,
.Xr isalpha 3 ,
and so on.
A character class may not be used as an endpoint of a range.
.Pp
There are two special cases** of bracket expressions:
the bracket expressions
.Sq [[:<:]]
and
.Sq [[:>:]]
match the null string at the beginning and end of a word, respectively.
A word is defined as a sequence of
characters starting and ending with a word character
which is neither preceded nor followed by
word characters.
A word character is an
.Em alnum
character (as defined by
.Xr isalnum 3 )
or an underscore.
This is an extension,
compatible with but not specified by POSIX,
and should be used with
caution in software intended to be portable to other systems.
The additional word delimiters
.Ql \e<
and
.Ql \e>
are provided to ease compatibility with traditional SVR4
systems but are not portable and should be avoided.
.Pp
In the event that an RE could match more than one substring of a given
string,
the RE matches the one starting earliest in the string.
If the RE could match more than one substring starting at that point,
it matches the longest.
Subexpressions also match the longest possible substrings, subject to
the constraint that the whole match be as long as possible,
with subexpressions starting earlier in the RE taking priority over
ones starting later.
Note that higher-level subexpressions thus take priority over
their lower-level component subexpressions.
.Pp
Match lengths are measured in characters, not collating elements.
A null string is considered longer than no match at all.
For example,
.Sq bb*
matches the three middle characters of
.Sq abbbc ;
.Sq (wee|week)(knights|nights)
matches all ten characters of
.Sq weeknights ;
when
.Sq (.*).*
is matched against
.Sq abc ,
the parenthesized subexpression matches all three characters;
and when
.Sq (a*)*
is matched against
.Sq bc ,
both the whole RE and the parenthesized subexpression match the null string.
.Pp
If case-independent matching is specified,
the effect is much as if all case distinctions had vanished from the
alphabet.
When an alphabetic that exists in multiple cases appears as an
ordinary character outside a bracket expression, it is effectively
transformed into a bracket expression containing both cases,
e.g.\&
.Sq x
becomes
.Sq [xX] .
When it appears inside a bracket expression,
all case counterparts of it are added to the bracket expression,
so that, for example,
.Sq [x]
becomes
.Sq [xX]
and
.Sq [^x]
becomes
.Sq [^xX] .
.Pp
No particular limit is imposed on the length of REs**.
Programs intended to be portable should not employ REs longer
than 256 bytes,
as an implementation can refuse to accept such REs and remain
POSIX-compliant.
.Pp
The following is a list of extended regular expressions:
.Bl -tag -width Ds
.It Ar c
Any character
.Ar c
not listed below matches itself.
.It \e Ns Ar c
Any backslash-escaped character
.Ar c
matches itself.
.It \&.
Matches any single character that is not a newline
.Pq Sq \en .
.It Bq Ar char-class
Matches any single character in
.Ar char-class .
To include a
.Ql \&]
in
.Ar char-class ,
it must be the first character.
A range of characters may be specified by separating the end characters
of the range with a
.Ql - ;
e.g.\&
.Ar a-z
specifies the lower case characters.
The following literal expressions can also be used in
.Ar char-class
to specify sets of characters:
.Bd -unfilled -offset indent
[:alnum:] [:cntrl:] [:lower:] [:space:]
[:alpha:] [:digit:] [:print:] [:upper:]
[:blank:] [:graph:] [:punct:] [:xdigit:]
.Ed
.Pp
If
.Ql -
appears as the first or last character of
.Ar char-class ,
then it matches itself.
All other characters in
.Ar char-class
match themselves.
.Pp
Patterns in
.Ar char-class
of the form
.Eo [.
.Ar col-elm
.Ec .]\&
or
.Eo [=
.Ar col-elm
.Ec =]\& ,
where
.Ar col-elm
is a collating element, are interpreted according to
.Xr setlocale 3
.Pq not currently supported .
.It Bq ^ Ns Ar char-class
Matches any single character, other than newline, not in
.Ar char-class .
.Ar char-class
is defined as above.
.It ^
If
.Sq ^
is the first character of a regular expression, then it
anchors the regular expression to the beginning of a line.
Otherwise, it matches itself.
.It $
If
.Sq $
is the last character of a regular expression,
it anchors the regular expression to the end of a line.
Otherwise, it matches itself.
.It [[:<:]]
Anchors the single character regular expression or subexpression
immediately following it to the beginning of a word.
.It [[:>:]]
Anchors the single character regular expression or subexpression
immediately preceding it to the end of a word.
.It Pq Ar re
Defines a subexpression
.Ar re .
Any set of characters enclosed in parentheses
matches whatever the set of characters without parentheses matches
(that is a long-winded way of saying the constructs
.Sq (re)
and
.Sq re
match identically).
.It *
Matches the single character regular expression or subexpression
immediately preceding it zero or more times.
If
.Sq *
is the first character of a regular expression or subexpression,
then it matches itself.
The
.Sq *
operator sometimes yields unexpected results.
For example, the regular expression
.Ar b*
matches the beginning of the string
.Qq abbb
(as opposed to the substring
.Qq bbb ) ,
since a null match is the only leftmost match.
.It +
Matches the singular character regular expression
or subexpression immediately preceding it
one or more times.
.It ?
Matches the singular character regular expression
or subexpression immediately preceding it
0 or 1 times.
.Sm off
.It Xo
.Pf { Ar n , m No }\ \&
.Pf { Ar n , No }\ \&
.Pf { Ar n No }
.Xc
.Sm on
Matches the single character regular expression or subexpression
immediately preceding it at least
.Ar n
and at most
.Ar m
times.
If
.Ar m
is omitted, then it matches at least
.Ar n
times.
If the comma is also omitted, then it matches exactly
.Ar n
times.
.It |
Used to separate patterns.
For example,
the pattern
.Sq cat|dog
matches either
.Sq cat
or
.Sq dog .
.El
.Sh BASIC REGULAR EXPRESSIONS
Basic regular expressions differ in several respects:
.Bl -bullet -offset 3n
.It
.Sq | ,
.Sq + ,
and
.Sq ?\&
are ordinary characters and there is no equivalent
for their functionality.
.It
The delimiters for bounds are
.Sq \e{
and
.Sq \e} ,
with
.Sq {
and
.Sq }
by themselves ordinary characters.
.It
The parentheses for nested subexpressions are
.Sq \e(
and
.Sq \e) ,
with
.Sq \&(
and
.Sq )\&
by themselves ordinary characters.
.It
.Sq ^
is an ordinary character except at the beginning of the
RE or** the beginning of a parenthesized subexpression.
.It
.Sq $
is an ordinary character except at the end of the
RE or** the end of a parenthesized subexpression.
.It
.Sq *
is an ordinary character if it appears at the beginning of the
RE or the beginning of a parenthesized subexpression
(after a possible leading
.Sq ^ ) .
.It
Finally, there is one new type of atom, a
.Em back-reference :
.Sq \e
followed by a non-zero decimal digit
.Ar d
matches the same sequence of characters matched by the
.Ar d Ns th
parenthesized subexpression
(numbering subexpressions by the positions of their opening parentheses,
left to right),
so that, for example,
.Sq \e([bc]\e)\e1
matches
.Sq bb\&
or
.Sq cc
but not
.Sq bc .
.El
.Pp
The following is a list of basic regular expressions:
.Bl -tag -width Ds
.It Ar c
Any character
.Ar c
not listed below matches itself.
.It \e Ns Ar c
Any backslash-escaped character
.Ar c ,
except for
.Sq { ,
.Sq } ,
.Sq \&( ,
and
.Sq \&) ,
matches itself.
.It \&.
Matches any single character that is not a newline
.Pq Sq \en .
.It Bq Ar char-class
Matches any single character in
.Ar char-class .
To include a
.Ql \&]
in
.Ar char-class ,
it must be the first character.
A range of characters may be specified by separating the end characters
of the range with a
.Ql - ;
e.g.\&
.Ar a-z
specifies the lower case characters.
The following literal expressions can also be used in
.Ar char-class
to specify sets of characters:
.Bd -unfilled -offset indent
[:alnum:] [:cntrl:] [:lower:] [:space:]
[:alpha:] [:digit:] [:print:] [:upper:]
[:blank:] [:graph:] [:punct:] [:xdigit:]
.Ed
.Pp
If
.Ql -
appears as the first or last character of
.Ar char-class ,
then it matches itself.
All other characters in
.Ar char-class
match themselves.
.Pp
Patterns in
.Ar char-class
of the form
.Eo [.
.Ar col-elm
.Ec .]\&
or
.Eo [=
.Ar col-elm
.Ec =]\& ,
where
.Ar col-elm
is a collating element, are interpreted according to
.Xr setlocale 3
.Pq not currently supported .
.It Bq ^ Ns Ar char-class
Matches any single character, other than newline, not in
.Ar char-class .
.Ar char-class
is defined as above.
.It ^
If
.Sq ^
is the first character of a regular expression, then it
anchors the regular expression to the beginning of a line.
Otherwise, it matches itself.
.It $
If
.Sq $
is the last character of a regular expression,
it anchors the regular expression to the end of a line.
Otherwise, it matches itself.
.It [[:<:]]
Anchors the single character regular expression or subexpression
immediately following it to the beginning of a word.
.It [[:>:]]
Anchors the single character regular expression or subexpression
immediately following it to the end of a word.
.It \e( Ns Ar re Ns \e)
Defines a subexpression
.Ar re .
Subexpressions may be nested.
A subsequent backreference of the form
.Pf \e Ar n ,
where
.Ar n
is a number in the range [1,9], expands to the text matched by the
.Ar n Ns th
subexpression.
For example, the regular expression
.Ar \e(.*\e)\e1
matches any string consisting of identical adjacent substrings.
Subexpressions are ordered relative to their left delimiter.
.It *
Matches the single character regular expression or subexpression
immediately preceding it zero or more times.
If
.Sq *
is the first character of a regular expression or subexpression,
then it matches itself.
The
.Sq *
operator sometimes yields unexpected results.
For example, the regular expression
.Ar b*
matches the beginning of the string
.Qq abbb
(as opposed to the substring
.Qq bbb ) ,
since a null match is the only leftmost match.
.Sm off
.It Xo
.Pf \e{ Ar n , m No \e}\ \&
.Pf \e{ Ar n , No \e}\ \&
.Pf \e{ Ar n No \e}
.Xc
.Sm on
Matches the single character regular expression or subexpression
immediately preceding it at least
.Ar n
and at most
.Ar m
times.
If
.Ar m
is omitted, then it matches at least
.Ar n
times.
If the comma is also omitted, then it matches exactly
.Ar n
times.
.El
.Sh SEE ALSO
.Xr regex 3
.Sh STANDARDS
.St -p1003.1-2004 :
Base Definitions, Chapter 9 (Regular Expressions).
.Sh BUGS
Having two kinds of REs is a botch.
.Pp
The current POSIX spec says that
.Sq )\&
is an ordinary character in the absence of an unmatched
.Sq \&( ;
this was an unintentional result of a wording error,
and change is likely.
Avoid relying on it.
.Pp
Back-references are a dreadful botch,
posing major problems for efficient implementations.
They are also somewhat vaguely defined
(does
.Sq a\e(\e(b\e)*\e2\e)*d
match
.Sq abbbd ? ) .
Avoid using them.
.Pp
POSIX's specification of case-independent matching is vague.
The
.Dq one case implies all cases
definition given above
is the current consensus among implementors as to the right interpretation.
.Pp
The syntax for word boundaries is incredibly ugly.
@


1.21
log
@Reduce usage of predefined strings in manpages.

Predefined strings are not very portable across troff implementations,
and they make the source much harder to read. Usually the intended
character can be written directly.

No output changes, except for two instances where the incorrect escape
was used in the first place.

tweaks + ok schwarze@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.20 2014/12/09 15:37:14 schwarze Exp $
d38 1
a38 1
.Dd $Mdocdate: December 9 2014 $
d682 1
a682 1
.Pf \e Ns Ar n ,
@


1.20
log
@put back some information what the character classes actually mean;
while here, remove the lie that regex(3) character classes would
depend on the locale;
ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.19 2014/12/09 14:39:37 jmc Exp $
d80 1
a80 1
.Sq \*(Ba .
d513 1
a513 1
.It \*(Ba
d517 1
a517 1
.Sq cat\*(Badog
d527 1
a527 1
.Sq \*(Ba ,
@


1.19
log
@no more ctype(3);
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.18 2014/09/10 15:10:19 jmc Exp $
d38 1
a38 1
.Dd $Mdocdate: September 10 2014 $
d283 4
a286 1
A locale may provide other character classes.
@


1.18
log
@zap trailing whitespace;
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.17 2014/09/10 11:25:32 jsg Exp $
d283 1
a283 3
These stand for the character classes defined in
.Xr ctype 3 .
A locale may provide others.
d299 1
a299 1
.Xr ctype 3 )
a728 1
.Xr ctype 3 ,
@


1.17
log
@document \<word\> as being non standard
from Pedro F. Giffuni in FreeBSD pr 153257
ok millert@@ tedu@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.16 2013/06/05 22:05:29 jmc Exp $
d38 1
a38 1
.Dd $Mdocdate: June 5 2013 $
d307 1
a307 1
The additional word delimiters  
d310 1
a310 1
.Ql \e> 
@


1.16
log
@[[:>:]] anchors the character preceding it to end of word, not the
character following it;

From: Peter Fraser
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.15 2010/07/15 20:51:38 schwarze Exp $
d38 1
a38 1
.Dd $Mdocdate: July 15 2010 $
d307 6
@


1.15
log
@More delimiters that need quoting inside macros, hunted down by jmc@@,
who asked me to commit because he is just running out of the door.
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.14 2007/05/31 19:19:30 jmc Exp $
d38 1
a38 1
.Dd $Mdocdate: May 31 2007 $
d449 1
a449 1
immediately following it to the end of a word.
@


1.14
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.13 2005/06/05 19:40:22 jmc Exp $
d38 1
a38 1
.Dd $Mdocdate$
d217 1
a217 1
.Sq [
d542 1
a542 1
.Sq (
d736 1
a736 1
.Sq ( ;
@


1.13
log
@s/-p1003.1-2003/-p1003.1-2004/g
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.12 2004/09/28 20:56:00 jmc Exp $
d38 1
a38 1
.Dd March 20, 1994
@


1.12
log
@various fixes to make this page more readable/helpful;
also split into 2 sections (ere and bre) and add a list of the
expressions supported (nicked/adapted from ed(1));

includes fixes/feedback from otto and jared;
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.11 2004/05/07 14:49:53 otto Exp $
d47 1
a47 1
.St -p1003.1-2003 ,
d728 1
a728 1
.St -p1003.1-2003 :
@


1.11
log
@Describe more accurate what word boundaries are.
ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.10 2003/06/02 20:18:36 millert Exp $
d43 1
a43 1
.Nd POSIX 1003.2 regular expressions
d45 33
a77 15
Regular expressions (``RE''s),
as defined in POSIX 1003.2, come in two forms:
modern REs (roughly those of
.Xr egrep 1 ;
1003.2 calls these ``extended'' REs)
and obsolete REs (roughly those of
.Xr ed 1 ;
1003.2 ``basic'' REs).
Obsolete REs mostly exist for backward compatibility in some old programs;
they will be discussed at the end.
1003.2 leaves some aspects of RE syntax and semantics open;
`\(dg' marks decisions on these aspects that
may not be fully portable to other 1003.2 implementations.
.Pp
A (modern) RE is one\(dg or more non-empty\(dg
d79 2
a80 1
separated by `|'.
d83 1
a83 1
A branch is one\(dg or more
d90 5
a94 1
possibly followed by a single\(dg `*', `+', `?', or
d96 15
a110 8
An atom followed by `*' matches a sequence of 0 or more matches of the atom.
An atom followed by `+' matches a sequence of 1 or more matches of the atom.
An atom followed by `?' matches a sequence of 0 or 1 matches of the atom.
.Pp
A
.Em bound
is `{' followed by an unsigned decimal integer,
possibly followed by `,'
d112 5
a116 2
always followed by `}'.
The integers must lie between 0 and RE_DUP_MAX (255\(dg) inclusive,
d118 2
a119 1
An atom followed by a bound containing one integer \fIi\fR
d121 3
a123 1
a sequence of exactly \fIi\fR matches of the atom.
d125 6
a130 2
containing one integer \fIi\fR and a comma matches
a sequence of \fIi\fR or more matches of the atom.
d132 25
a156 8
containing two integers \fIi\fR and \fIj\fR matches
a sequence of \fIi\fR through \fIj\fR (inclusive) matches of the atom.
.Pp
An
.Em atom
is a regular expression enclosed in `()'
(matching a match for the regular expression),
an empty set of `()' (matching the null string)\(dg,
d158 3
a160 6
.Em "bracket expression"
(see below), `.'
(matching any single character), `^' (matching the null string at the
beginning of a line), `$' (matching the null string at the
end of a line), a `\e' followed by one of the characters
`^.[$()|*+?{\e'
d162 3
a164 1
a `\e' followed by any other character\(dg
d166 3
a168 1
as if the `\e' had not been present\(dg),
d170 6
a175 3
A `{' followed by a character other than a digit is an ordinary
character, not the beginning of a bound\(dg.
It is illegal to end an RE with `\e'.
d177 2
a178 3
A
.Em "bracket expression"
is a list of characters enclosed in `[]'.
d180 2
a181 1
If the list begins with `^',
a182 1
(but see below)
d184 5
a188 3
from the rest of the list.
If two characters in the list are separated by `\-', this is shorthand
for the full
d191 5
a195 4
collating sequence,
e.g., `[0-9]' in ASCII matches any decimal digit.
It is illegal\(dg for two ranges to share an
endpoint, e.g., `a-c-e'.
d199 8
a206 3
To include a literal `]' in the list, make it the first character
(following a possible `^').
To include a literal `\-', make it the first or last character,
d208 14
a221 5
To use a literal `\-' as the first endpoint of a range,
enclose it in `[.' and `.]' to make it a collating element (see below).
With the exception of these and some combinations using `[' (see next
paragraphs), all other special characters, including `\e', lose their
special significance within a bracket expression.
d223 2
a224 1
Within a bracket expression, a collating element (a character,
d227 5
a231 2
enclosed in `[.' and `.]' stands for the
sequence of characters of that collating element.
d235 13
a247 6
e.g., if the collating sequence includes a `ch' collating element,
then the RE `[[.ch.]]*c' matches the first five characters
of `chchcc'.
.Pp
Within a bracket expression, a collating element enclosed in `[=' and
`=]' is an equivalence class, standing for the sequences of characters
d250 16
a265 5
the treatment is as if the enclosing delimiters were `[.' and `.]'.)
For example, if o and \o'o^' are the members of an equivalence class,
then `[[=o=]]', `[[=\o'o^'=]]', and `[o\o'o^']' are all synonymous.
An equivalence class may not\(dg be an endpoint
of a range.
d268 1
a268 1
.Em "character class"
d270 5
a274 2
in `[:' and `:]' stands for the list of all characters belonging to that
class.
d276 1
a276 3
.Pp
.Bl -item -compact -offset indent
.It
a277 1
.It
a278 1
.It
a279 1
.It
d281 1
a281 1
.El
d288 6
a293 3
There are two special cases\(dg of bracket expressions:
the bracket expressions `[[:<:]]' and `[[:>:]]' match the null string at
the beginning and end of a word respectively.
d304 1
a304 1
compatible with but not specified by POSIX 1003.2,
d323 16
a338 6
`bb*' matches the three middle characters of `abbbc',
`(wee|week)(knights|nights)' matches all ten characters of `weeknights',
when `(.*).*' is matched against `abc' the parenthesized subexpression
matches all three characters, and
when `(a*)*' is matched against `bc' both the whole RE and the parenthesized
subexpression match the null string.
d346 14
a359 4
e.g., `x' becomes `[xX]'.
When it appears inside a bracket expression, all case counterparts
of it are added to the bracket expression, so that (e.g.) `[x]'
becomes `[xX]' and `[^x]' becomes `[^xX]'.
d361 1
a361 1
No particular limit is imposed on the length of REs\(dg.
d367 158
a524 2
Obsolete (``basic'') regular expressions differ in several respects.
`|', `+', and `?' are ordinary characters and there is no equivalent
d526 31
a556 9
The delimiters for bounds are `\e{' and `\e}',
with `{' and `}' by themselves ordinary characters.
The parentheses for nested subexpressions are `\e(' and `\e)',
with `(' and `)' by themselves ordinary characters.
`^' is an ordinary character except at the beginning of the
RE or\(dg the beginning of a parenthesized subexpression,
`$' is an ordinary character except at the end of the
RE or\(dg the end of a parenthesized subexpression,
and `*' is an ordinary character if it appears at the beginning of the
d558 3
a560 1
(after a possible leading `^').
d562 6
a567 6
.Em "back reference" :
`\e' followed by a non-zero decimal digit
.Em d
matches the same sequence of characters
matched by the
.Em d Ns th
d571 153
a723 1
so that (e.g.) `\e([bc]\e)\e1' matches `bb' or `cc' but not `bc'.
d725 1
d727 3
a729 2
.Pp
POSIX 1003.2, section 2.8 (Regular Expression Notation).
d733 4
a736 2
The current 1003.2 spec says that `)' is an ordinary character in
the absence of an unmatched `(';
d741 1
a741 1
Back references are a dreadful botch,
d745 3
a747 1
`a\e(\e(b\e)*\e2\e)*d' match `abbbd'?).
d750 5
a754 3
1003.2's specification of case-independent matching is vague.
The ``one case implies all cases'' definition given above
is current consensus among implementors as to the right interpretation.
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.9 2000/04/18 03:01:33 aaron Exp $
d195 1
a195 1
word characters
@


1.9
log
@Repairs, mostly removing hard sentence breaks.
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.8 2000/03/14 21:31:45 aaron Exp $
d20 1
a20 5
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Suffix "i.e." and "e.g." with a comma. Just another really picky man page
commit, as we want our documentation to be as consistently formatted as
possible (it's getting there :-)).
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.7 1999/07/09 13:35:22 aaron Exp $
d65 2
a66 1
separated by `|'. It matches anything that matches one of the branches.
@


1.7
log
@- remove all trailing whitespace
     * except when it is escaped with a `\' at the end of the line
- fix remaining .Nm usage as well
- this is from a patch I received from kwesterback@@home.com, who has been
  working on some scripts for fixing formatting errors in mdoc'd man pages

Ok, so there could be a cost/benefit debate with this commit, but since I have
the patch we might as well commit it...
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.6 1999/05/23 14:11:02 aaron Exp $
d133 1
a133 1
e.g. `[0-9]' in ASCII matches any decimal digit.
d135 1
a135 1
endpoint, e.g. `a-c-e'.
d157 1
a157 1
e.g. if the collating sequence includes a `ch' collating element,
d239 1
a239 1
e.g. `x' becomes `[xX]'.
@


1.6
log
@remove argument from .Os macros so value in /usr/share/tmac/mdoc/doc-common
is used instead; kwesterback@@home.com
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.5 1997/07/29 02:29:09 flipk Exp $
d63 1
a63 1
A (modern) RE is one\(dg or more non-empty\(dg 
d67 1
a67 1
A branch is one\(dg or more 
d74 1
a74 1
possibly followed by a single\(dg `*', `+', `?', or 
d80 1
a80 1
A 
d98 1
a98 1
An 
d103 1
a103 1
a 
d119 1
a119 1
A 
d129 1
a129 1
for the full 
d155 1
a155 1
A bracket expression containing a multi-character collating element 
d171 1
a171 1
Within a bracket expression, the name of a 
d264 1
a264 1
Finally, there is one new type of atom, a 
@


1.5
log
@convert to mdoc format
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.4 1997/07/17 05:20:53 mickey Exp $
d44 1
a44 1
.Os OpenBSD
@


1.4
log
@formatting
@
text
@d1 3
a3 1
.\"	$OpenBSD: re_format.7,v 1.3 1997/04/28 20:44:58 millert Exp $
d42 7
a48 4
.TH RE_FORMAT 7 "March 20, 1994"
.SH NAME
re_format \- POSIX 1003.2 regular expressions
.SH DESCRIPTION
d52 1
a52 1
.IR egrep ;
d55 1
a55 1
.IR ed ;
d62 8
a69 6
.PP
A (modern) RE is one\(dg or more non-empty\(dg \fIbranches\fR,
separated by `|'.
It matches anything that matches one of the branches.
.PP
A branch is one\(dg or more \fIpieces\fR, concatenated.
d71 5
a75 3
.PP
A piece is an \fIatom\fR possibly followed
by a single\(dg `*', `+', `?', or \fIbound\fR.
d79 4
a82 2
.PP
A \fIbound\fR is `{' followed by an unsigned decimal integer,
d97 4
a100 2
.PP
An \fIatom\fR is a regular expression enclosed in `()'
d103 3
a105 1
a \fIbracket expression\fR (see below), `.'
d118 4
a121 2
.PP
A \fIbracket expression\fR is a list of characters enclosed in `[]'.
d125 3
a127 1
(but see below) \fInot\fR from the rest of the list.
d129 3
a131 1
for the full \fIrange\fR of characters between those two (inclusive) in the
d138 1
a138 1
.PP
d148 1
a148 1
.PP
d160 1
a160 1
.PP
d170 4
a173 2
.PP
Within a bracket expression, the name of a \fIcharacter class\fR enclosed
d177 3
a179 4
.PP
.RS
.nf
.ta 3c 6c 9c
d181 1
d183 1
d185 1
d187 2
a188 3
.fi
.RE
.PP
d190 1
a190 1
.IR ctype (3).
d193 1
a193 1
.PP
d202 1
a202 1
.I alnum
d204 1
a204 1
.IR ctype (3))
d210 1
a210 1
.PP
d222 1
a222 1
.PP
d232 1
a232 1
.PP
d243 1
a243 1
.PP
d249 1
a249 1
.PP
d264 4
a267 2
Finally, there is one new type of atom, a \fIback reference\fR:
`\e' followed by a non-zero decimal digit \fId\fR
d269 3
a271 1
matched by the \fId\fRth parenthesized subexpression
d275 3
a277 3
.SH SEE ALSO
regex(3)
.PP
d279 1
a279 1
.SH BUGS
d281 1
a281 1
.PP
d287 1
a287 1
.PP
d294 1
a294 1
.PP
d298 1
a298 1
.PP
@


1.3
log
@- cast usages of *printf() to void since we don't check return val
- move an assert to be *before* a strcpy() where it can do some good.
- integrate NetBSD fixes for 64-bit machines (NetBSD PR #3450, Ross Harvey)
- add lite2 tags
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.2 1996/08/19 08:31:08 tholo Exp $
d87 2
a88 2
An atom is a regular expression enclosed in `()' (matching a match for the
regular expression),
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 1
a1 1
.\"	$OpenBSD: re_format.7,v 1.5 1995/02/27 13:28:52 cgd Exp $
d37 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
.\"	$NetBSD: re_format.7,v 1.5 1995/02/27 13:28:52 cgd Exp $
a36 2
.\"
.\"	@@(#)re_format.7	8.3 (Berkeley) 3/20/94
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
