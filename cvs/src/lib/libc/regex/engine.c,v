head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.2
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.32
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.30
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.28
	OPENBSD_5_0:1.15.0.26
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.24
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.22
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.18
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.20
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.16
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.14
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.12
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.20
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.18
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.16
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.23;
commitid	pqjnYVtACzQ9ctai;

1.23
date	2016.05.26.05.46.44;	author martijn;	state Exp;
branches;
next	1.22;
commitid	B6rfRcrBE1F6XXDC;

1.22
date	2016.05.25.21.01.11;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	MOMotxMudei6coRf;

1.21
date	2016.05.25.20.48.22;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	F4O3uAueLcd91PEH;

1.20
date	2016.05.17.22.03.18;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	8rISYKEud1GaRyQc;

1.19
date	2015.12.28.23.01.22;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	LdsrMvtiH1WCDQiz;

1.18
date	2014.10.09.02.50.16;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	JNTWwzkeAdMVngOo;

1.17
date	2013.11.28.05.09.45;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.17.17.39.29;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.05.13.03.00;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.03.19.51.14;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.30.17.04.23;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.29.16.49.50;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.17.17.58.54;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.13.14.52.49;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.02.18.34.33;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.30.20.36.07;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.20.18.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.25.09.11.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.24;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.04.28.20.44.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.04.12.18.22.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.31.06;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@/*	$OpenBSD: engine.c,v 1.23 2016/05/26 05:46:44 martijn Exp $	*/

/*-
 * Copyright (c) 1992, 1993, 1994 Henry Spencer.
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Henry Spencer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)engine.c	8.5 (Berkeley) 3/20/94
 */

/*
 * The matching engine and friends.  This file is #included by regexec.c
 * after suitable #defines of a variety of macros used herein, so that
 * different state representations can be used without duplicating masses
 * of code.
 */

#ifdef SNAMES
#define	matcher	smatcher
#define	fast	sfast
#define	slow	sslow
#define	dissect	sdissect
#define	backref	sbackref
#define	step	sstep
#define	print	sprint
#define	at	sat
#define	match	smat
#define	nope	snope
#endif
#ifdef LNAMES
#define	matcher	lmatcher
#define	fast	lfast
#define	slow	lslow
#define	dissect	ldissect
#define	backref	lbackref
#define	step	lstep
#define	print	lprint
#define	at	lat
#define	match	lmat
#define	nope	lnope
#endif

/* another structure passed up and down to avoid zillions of parameters */
struct match {
	struct re_guts *g;
	int eflags;
	regmatch_t *pmatch;	/* [nsub+1] (0 element unused) */
	char *offp;		/* offsets work from here */
	char *beginp;		/* start of string -- virtual NUL precedes */
	char *endp;		/* end of string -- virtual NUL here */
	char *coldp;		/* can be no match starting before here */
	char **lastpos;		/* [nplus+1] */
	STATEVARS;
	states st;		/* current states */
	states fresh;		/* states for a fresh start */
	states tmp;		/* temporary */
	states empty;		/* empty set of states */
};

static int matcher(struct re_guts *, char *, size_t, regmatch_t[], int);
static char *dissect(struct match *, char *, char *, sopno, sopno);
static char *backref(struct match *, char *, char *, sopno, sopno, sopno, int);
static char *fast(struct match *, char *, char *, sopno, sopno);
static char *slow(struct match *, char *, char *, sopno, sopno);
static states step(struct re_guts *, sopno, sopno, states, int, states);
#define MAX_RECURSION	100
#define	BOL	(OUT+1)
#define	EOL	(BOL+1)
#define	BOLEOL	(BOL+2)
#define	NOTHING	(BOL+3)
#define	BOW	(BOL+4)
#define	EOW	(BOL+5)
/* update nonchars[] array below when adding fake chars here */
#define	CODEMAX	(BOL+5)		/* highest code used */
#define	NONCHAR(c)	((c) > CHAR_MAX)
#define	NNONCHAR	(CODEMAX-CHAR_MAX)
#ifdef REDEBUG
static void print(struct match *, char *, states, int, FILE *);
#endif
#ifdef REDEBUG
static void at(struct match *, char *, char *, char *, sopno, sopno);
#endif
#ifdef REDEBUG
static const char *pchar(int);
#endif

#ifdef REDEBUG
#define	SP(t, s, c)	print(m, t, s, c, stdout)
#define	AT(t, p1, p2, s1, s2)	at(m, t, p1, p2, s1, s2)
#define	NOTE(str)	{ if (m->eflags&REG_TRACE) (void)printf("=%s\n", (str)); }
static int nope = 0;
#else
#define	SP(t, s, c)	/* nothing */
#define	AT(t, p1, p2, s1, s2)	/* nothing */
#define	NOTE(s)	/* nothing */
#endif

/*
 - matcher - the actual matching engine
 */
static int			/* 0 success, REG_NOMATCH failure */
matcher(struct re_guts *g, char *string, size_t nmatch, regmatch_t pmatch[],
    int eflags)
{
	char *endp;
	int i;
	struct match mv;
	struct match *m = &mv;
	char *dp;
	const sopno gf = g->firststate+1;	/* +1 for OEND */
	const sopno gl = g->laststate;
	char *start;
	char *stop;

	/* simplify the situation where possible */
	if (g->cflags&REG_NOSUB)
		nmatch = 0;
	if (eflags&REG_STARTEND) {
		start = string + pmatch[0].rm_so;
		stop = string + pmatch[0].rm_eo;
	} else {
		start = string;
		stop = start + strlen(start);
	}
	if (stop < start)
		return(REG_INVARG);

	/* prescreening; this does wonders for this rather slow code */
	if (g->must != NULL) {
		for (dp = start; dp < stop; dp++)
			if (*dp == g->must[0] && stop - dp >= g->mlen &&
			    memcmp(dp, g->must, g->mlen) == 0)
				break;
		if (dp == stop)		/* we didn't find g->must */
			return(REG_NOMATCH);
	}

	/* match struct setup */
	m->g = g;
	m->eflags = eflags;
	m->pmatch = NULL;
	m->lastpos = NULL;
	m->offp = string;
	m->beginp = start;
	m->endp = stop;
	STATESETUP(m, 4);
	SETUP(m->st);
	SETUP(m->fresh);
	SETUP(m->tmp);
	SETUP(m->empty);
	CLEAR(m->empty);

	/* this loop does only one repetition except for backrefs */
	for (;;) {
		endp = fast(m, start, stop, gf, gl);
		if (endp == NULL) {		/* a miss */
			free(m->pmatch);
			free(m->lastpos);
			STATETEARDOWN(m);
			return(REG_NOMATCH);
		}
		if (nmatch == 0 && !g->backrefs)
			break;		/* no further info needed */

		/* where? */
		assert(m->coldp != NULL);
		for (;;) {
			NOTE("finding start");
			endp = slow(m, m->coldp, stop, gf, gl);
			if (endp != NULL)
				break;
			assert(m->coldp < m->endp);
			m->coldp++;
		}
		if (nmatch == 1 && !g->backrefs)
			break;		/* no further info needed */

		/* oh my, he wants the subexpressions... */
		if (m->pmatch == NULL)
			m->pmatch = reallocarray(NULL, m->g->nsub + 1,
			    sizeof(regmatch_t));
		if (m->pmatch == NULL) {
			STATETEARDOWN(m);
			return(REG_ESPACE);
		}
		for (i = 1; i <= m->g->nsub; i++)
			m->pmatch[i].rm_so = m->pmatch[i].rm_eo = -1;
		if (!g->backrefs && !(m->eflags&REG_BACKR)) {
			NOTE("dissecting");
			dp = dissect(m, m->coldp, endp, gf, gl);
		} else {
			if (g->nplus > 0 && m->lastpos == NULL)
				m->lastpos = reallocarray(NULL,
				    g->nplus+1, sizeof(char *));
			if (g->nplus > 0 && m->lastpos == NULL) {
				free(m->pmatch);
				STATETEARDOWN(m);
				return(REG_ESPACE);
			}
			NOTE("backref dissect");
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0, 0);
		}
		if (dp != NULL)
			break;

		/* uh-oh... we couldn't find a subexpression-level match */
		assert(g->backrefs);	/* must be back references doing it */
		assert(g->nplus == 0 || m->lastpos != NULL);
		for (;;) {
			if (dp != NULL || endp <= m->coldp)
				break;		/* defeat */
			NOTE("backoff");
			endp = slow(m, m->coldp, endp-1, gf, gl);
			if (endp == NULL)
				break;		/* defeat */
			/* try it on a shorter possibility */
#ifndef NDEBUG
			for (i = 1; i <= m->g->nsub; i++) {
				assert(m->pmatch[i].rm_so == -1);
				assert(m->pmatch[i].rm_eo == -1);
			}
#endif
			NOTE("backoff dissect");
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0, 0);
		}
		assert(dp == NULL || dp == endp);
		if (dp != NULL)		/* found a shorter one */
			break;

		/* despite initial appearances, there is no match here */
		NOTE("false alarm");
		if (m->coldp == stop)
			break;
		start = m->coldp + 1;	/* recycle starting later */
	}

	/* fill in the details if requested */
	if (nmatch > 0) {
		pmatch[0].rm_so = m->coldp - m->offp;
		pmatch[0].rm_eo = endp - m->offp;
	}
	if (nmatch > 1) {
		assert(m->pmatch != NULL);
		for (i = 1; i < nmatch; i++)
			if (i <= m->g->nsub)
				pmatch[i] = m->pmatch[i];
			else {
				pmatch[i].rm_so = -1;
				pmatch[i].rm_eo = -1;
			}
	}

	free(m->pmatch);
	free(m->lastpos);
	STATETEARDOWN(m);
	return(0);
}

/*
 - dissect - figure out what matched what, no back references
 */
static char *			/* == stop (success) always */
dissect(struct match *m, char *start, char *stop, sopno startst, sopno stopst)
{
	int i;
	sopno ss;	/* start sop of current subRE */
	sopno es;	/* end sop of current subRE */
	char *sp;	/* start of string matched by it */
	char *stp;	/* string matched by it cannot pass here */
	char *rest;	/* start of rest of string */
	char *tail;	/* string unmatched by rest of RE */
	sopno ssub;	/* start sop of subsubRE */
	sopno esub;	/* end sop of subsubRE */
	char *ssp;	/* start of string matched by subsubRE */
	char *sep;	/* end of string matched by subsubRE */
	char *oldssp;	/* previous ssp */
	char *dp;

	AT("diss", start, stop, startst, stopst);
	sp = start;
	for (ss = startst; ss < stopst; ss = es) {
		/* identify end of subRE */
		es = ss;
		switch (OP(m->g->strip[es])) {
		case OPLUS_:
		case OQUEST_:
			es += OPND(m->g->strip[es]);
			break;
		case OCH_:
			while (OP(m->g->strip[es]) != O_CH)
				es += OPND(m->g->strip[es]);
			break;
		}
		es++;

		/* figure out what it matched */
		switch (OP(m->g->strip[ss])) {
		case OEND:
			assert(nope);
			break;
		case OCHAR:
			sp++;
			break;
		case OBOL:
		case OEOL:
		case OBOW:
		case OEOW:
			break;
		case OANY:
		case OANYOF:
			sp++;
			break;
		case OBACK_:
		case O_BACK:
			assert(nope);
			break;
		/* cases where length of match is hard to find */
		case OQUEST_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = es - 1;
			/* did innards match? */
			if (slow(m, sp, rest, ssub, esub) != NULL) {
				dp = dissect(m, sp, rest, ssub, esub);
				assert(dp == rest);
			} else		/* no */
				assert(sp == rest);
			sp = rest;
			break;
		case OPLUS_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = es - 1;
			ssp = sp;
			oldssp = ssp;
			for (;;) {	/* find last match of innards */
				sep = slow(m, ssp, rest, ssub, esub);
				if (sep == NULL || sep == ssp)
					break;	/* failed or matched null */
				oldssp = ssp;	/* on to next try */
				ssp = sep;
			}
			if (sep == NULL) {
				/* last successful match */
				sep = ssp;
				ssp = oldssp;
			}
			assert(sep == rest);	/* must exhaust substring */
			assert(slow(m, ssp, sep, ssub, esub) == rest);
			dp = dissect(m, ssp, sep, ssub, esub);
			assert(dp == sep);
			sp = rest;
			break;
		case OCH_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = ss + OPND(m->g->strip[ss]) - 1;
			assert(OP(m->g->strip[esub]) == OOR1);
			for (;;) {	/* find first matching branch */
				if (slow(m, sp, rest, ssub, esub) == rest)
					break;	/* it matched all of it */
				/* that one missed, try next one */
				assert(OP(m->g->strip[esub]) == OOR1);
				esub++;
				assert(OP(m->g->strip[esub]) == OOR2);
				ssub = esub + 1;
				esub += OPND(m->g->strip[esub]);
				if (OP(m->g->strip[esub]) == OOR2)
					esub--;
				else
					assert(OP(m->g->strip[esub]) == O_CH);
			}
			dp = dissect(m, sp, rest, ssub, esub);
			assert(dp == rest);
			sp = rest;
			break;
		case O_PLUS:
		case O_QUEST:
		case OOR1:
		case OOR2:
		case O_CH:
			assert(nope);
			break;
		case OLPAREN:
			i = OPND(m->g->strip[ss]);
			assert(0 < i && i <= m->g->nsub);
			m->pmatch[i].rm_so = sp - m->offp;
			break;
		case ORPAREN:
			i = OPND(m->g->strip[ss]);
			assert(0 < i && i <= m->g->nsub);
			m->pmatch[i].rm_eo = sp - m->offp;
			break;
		default:		/* uh oh */
			assert(nope);
			break;
		}
	}

	assert(sp == stop);
	return(sp);
}

/*
 - backref - figure out what matched what, figuring in back references
 */
static char *			/* == stop (success) or NULL (failure) */
backref(struct match *m, char *start, char *stop, sopno startst, sopno stopst,
    sopno lev, int rec)			/* PLUS nesting level */
{
	int i;
	sopno ss;	/* start sop of current subRE */
	char *sp;	/* start of string matched by it */
	sopno ssub;	/* start sop of subsubRE */
	sopno esub;	/* end sop of subsubRE */
	char *ssp;	/* start of string matched by subsubRE */
	char *dp;
	size_t len;
	int hard;
	sop s;
	regoff_t offsave;
	cset *cs;

	AT("back", start, stop, startst, stopst);
	sp = start;

	/* get as far as we can with easy stuff */
	hard = 0;
	for (ss = startst; !hard && ss < stopst; ss++)
		switch (OP(s = m->g->strip[ss])) {
		case OCHAR:
			if (sp == stop || *sp++ != (char)OPND(s))
				return(NULL);
			break;
		case OANY:
			if (sp == stop)
				return(NULL);
			sp++;
			break;
		case OANYOF:
			cs = &m->g->sets[OPND(s)];
			if (sp == stop || !CHIN(cs, *sp++))
				return(NULL);
			break;
		case OBOL:
			if ((sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
			    (sp > m->offp && sp < m->endp &&
			     *(sp-1) == '\n' && (m->g->cflags&REG_NEWLINE)))
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OEOL:
			if ( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
					(sp < m->endp && *sp == '\n' &&
						(m->g->cflags&REG_NEWLINE)) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OBOW:
			if (sp < m->endp && ISWORD(*sp) &&
			    ((sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
			     (sp > m->offp && !ISWORD(*(sp-1)))))
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OEOW:
			if (( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
					(sp < m->endp && *sp == '\n' &&
						(m->g->cflags&REG_NEWLINE)) ||
					(sp < m->endp && !ISWORD(*sp)) ) &&
					(sp > m->beginp && ISWORD(*(sp-1))) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case O_QUEST:
			break;
		case OOR1:	/* matches null but needs to skip */
			ss++;
			s = m->g->strip[ss];
			do {
				assert(OP(s) == OOR2);
				ss += OPND(s);
			} while (OP(s = m->g->strip[ss]) != O_CH);
			/* note that the ss++ gets us past the O_CH */
			break;
		default:	/* have to make a choice */
			hard = 1;
			break;
		}
	if (!hard) {		/* that was it! */
		if (sp != stop)
			return(NULL);
		return(sp);
	}
	ss--;			/* adjust for the for's final increment */

	/* the hard stuff */
	AT("hard", sp, stop, ss, stopst);
	s = m->g->strip[ss];
	switch (OP(s)) {
	case OBACK_:		/* the vilest depths */
		i = OPND(s);
		assert(0 < i && i <= m->g->nsub);
		if (m->pmatch[i].rm_eo == -1)
			return(NULL);
		assert(m->pmatch[i].rm_so != -1);
		len = m->pmatch[i].rm_eo - m->pmatch[i].rm_so;
		if (len == 0 && rec++ > MAX_RECURSION)
			return(NULL);
		assert(stop - m->beginp >= len);
		if (sp > stop - len)
			return(NULL);	/* not enough left to match */
		ssp = m->offp + m->pmatch[i].rm_so;
		if (memcmp(sp, ssp, len) != 0)
			return(NULL);
		while (m->g->strip[ss] != SOP(O_BACK, i))
			ss++;
		return(backref(m, sp+len, stop, ss+1, stopst, lev, rec));
		break;
	case OQUEST_:		/* to null or not */
		dp = backref(m, sp, stop, ss+1, stopst, lev, rec);
		if (dp != NULL)
			return(dp);	/* not */
		return(backref(m, sp, stop, ss+OPND(s)+1, stopst, lev, rec));
		break;
	case OPLUS_:
		assert(m->lastpos != NULL);
		assert(lev+1 <= m->g->nplus);
		m->lastpos[lev+1] = sp;
		return(backref(m, sp, stop, ss+1, stopst, lev+1, rec));
		break;
	case O_PLUS:
		if (sp == m->lastpos[lev])	/* last pass matched null */
			return(backref(m, sp, stop, ss+1, stopst, lev-1, rec));
		/* try another pass */
		m->lastpos[lev] = sp;
		dp = backref(m, sp, stop, ss-OPND(s)+1, stopst, lev, rec);
		if (dp == NULL)
			return(backref(m, sp, stop, ss+1, stopst, lev-1, rec));
		else
			return(dp);
		break;
	case OCH_:		/* find the right one, if any */
		ssub = ss + 1;
		esub = ss + OPND(s) - 1;
		assert(OP(m->g->strip[esub]) == OOR1);
		for (;;) {	/* find first matching branch */
			dp = backref(m, sp, stop, ssub, esub, lev, rec);
			if (dp != NULL)
				return(dp);
			/* that one missed, try next one */
			if (OP(m->g->strip[esub]) == O_CH)
				return(NULL);	/* there is none */
			esub++;
			assert(OP(m->g->strip[esub]) == OOR2);
			ssub = esub + 1;
			esub += OPND(m->g->strip[esub]);
			if (OP(m->g->strip[esub]) == OOR2)
				esub--;
			else
				assert(OP(m->g->strip[esub]) == O_CH);
		}
		break;
	case OLPAREN:		/* must undo assignment if rest fails */
		i = OPND(s);
		assert(0 < i && i <= m->g->nsub);
		offsave = m->pmatch[i].rm_so;
		m->pmatch[i].rm_so = sp - m->offp;
		dp = backref(m, sp, stop, ss+1, stopst, lev, rec);
		if (dp != NULL)
			return(dp);
		m->pmatch[i].rm_so = offsave;
		return(NULL);
		break;
	case ORPAREN:		/* must undo assignment if rest fails */
		i = OPND(s);
		assert(0 < i && i <= m->g->nsub);
		offsave = m->pmatch[i].rm_eo;
		m->pmatch[i].rm_eo = sp - m->offp;
		dp = backref(m, sp, stop, ss+1, stopst, lev, rec);
		if (dp != NULL)
			return(dp);
		m->pmatch[i].rm_eo = offsave;
		return(NULL);
		break;
	default:		/* uh oh */
		assert(nope);
		break;
	}

	/* "can't happen" */
	assert(nope);
	/* NOTREACHED */
	return NULL;
}

/*
 - fast - step through the string at top speed
 */
static char *			/* where tentative match ended, or NULL */
fast(struct match *m, char *start, char *stop, sopno startst, sopno stopst)
{
	states st = m->st;
	states fresh = m->fresh;
	states tmp = m->tmp;
	char *p = start;
	int c;
	int lastc;	/* previous c */
	int flagch;
	int i;
	char *coldp;	/* last p after which no match was underway */

	if (start == m->offp || (start == m->beginp && !(m->eflags&REG_NOTBOL)))
		c = OUT;
	else
		c = *(start-1);

	CLEAR(st);
	SET1(st, startst);
	st = step(m->g, startst, stopst, st, NOTHING, st);
	ASSIGN(fresh, st);
	SP("start", st, *p);
	coldp = NULL;
	for (;;) {
		/* next character */
		lastc = c;
		c = (p == m->endp) ? OUT : *p;
		if (EQ(st, fresh))
			coldp = p;

		/* is there an EOL and/or BOL between lastc and c? */
		flagch = '\0';
		i = 0;
		if ((lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
		    (lastc == OUT && !(m->eflags&REG_NOTBOL))) {
			flagch = BOL;
			i = m->g->nbol;
		}
		if ((c == '\n' && m->g->cflags&REG_NEWLINE) ||
		    (c == OUT && !(m->eflags&REG_NOTEOL)) ) {
			flagch = (flagch == BOL) ? BOLEOL : EOL;
			i += m->g->neol;
		}
		if (i != 0) {
			for (; i > 0; i--)
				st = step(m->g, startst, stopst,
				    st, flagch, st);
			SP("boleol", st, c);
		}

		/* how about a word boundary? */
		if ((flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
		    (c != OUT && ISWORD(c)))
			flagch = BOW;
		if ((lastc != OUT && ISWORD(lastc)) &&
		    (flagch == EOL || (c != OUT && !ISWORD(c))))
			flagch = EOW;
		if (flagch == BOW || flagch == EOW) {
			st = step(m->g, startst, stopst, st, flagch, st);
			SP("boweow", st, c);
		}

		/* are we done? */
		if (ISSET(st, stopst) || p == stop)
			break;		/* NOTE BREAK OUT */

		/* no, we must deal with this character */
		ASSIGN(tmp, st);
		ASSIGN(st, fresh);
		assert(c != OUT);
		st = step(m->g, startst, stopst, tmp, c, st);
		SP("aft", st, c);
		assert(EQ(step(m->g, startst, stopst, st, NOTHING, st), st));
		p++;
	}

	assert(coldp != NULL);
	m->coldp = coldp;
	if (ISSET(st, stopst))
		return(p+1);
	else
		return(NULL);
}

/*
 - slow - step through the string more deliberately
 */
static char *			/* where it ended */
slow(struct match *m, char *start, char *stop, sopno startst, sopno stopst)
{
	states st = m->st;
	states empty = m->empty;
	states tmp = m->tmp;
	char *p = start;
	int c;
	int lastc;	/* previous c */
	int flagch;
	int i;
	char *matchp;	/* last p at which a match ended */

	if (start == m->offp || (start == m->beginp && !(m->eflags&REG_NOTBOL)))
		c = OUT;
	else
		c = *(start-1);

	AT("slow", start, stop, startst, stopst);
	CLEAR(st);
	SET1(st, startst);
	SP("sstart", st, *p);
	st = step(m->g, startst, stopst, st, NOTHING, st);
	matchp = NULL;
	for (;;) {
		/* next character */
		lastc = c;
		c = (p == m->endp) ? OUT : *p;

		/* is there an EOL and/or BOL between lastc and c? */
		flagch = '\0';
		i = 0;
		if ((lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
		    (lastc == OUT && !(m->eflags&REG_NOTBOL))) {
			flagch = BOL;
			i = m->g->nbol;
		}
		if ((c == '\n' && m->g->cflags&REG_NEWLINE) ||
		    (c == OUT && !(m->eflags&REG_NOTEOL))) {
			flagch = (flagch == BOL) ? BOLEOL : EOL;
			i += m->g->neol;
		}
		if (i != 0) {
			for (; i > 0; i--)
				st = step(m->g, startst, stopst,
				    st, flagch, st);
			SP("sboleol", st, c);
		}

		/* how about a word boundary? */
		if ((flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
		    (c != OUT && ISWORD(c)))
			flagch = BOW;
		if ((lastc != OUT && ISWORD(lastc)) &&
		    (flagch == EOL || (c != OUT && !ISWORD(c))))
			flagch = EOW;
		if (flagch == BOW || flagch == EOW) {
			st = step(m->g, startst, stopst, st, flagch, st);
			SP("sboweow", st, c);
		}

		/* are we done? */
		if (ISSET(st, stopst))
			matchp = p;
		if (EQ(st, empty) || p == stop)
			break;		/* NOTE BREAK OUT */

		/* no, we must deal with this character */
		ASSIGN(tmp, st);
		ASSIGN(st, empty);
		assert(c != OUT);
		st = step(m->g, startst, stopst, tmp, c, st);
		SP("saft", st, c);
		assert(EQ(step(m->g, startst, stopst, st, NOTHING, st), st));
		p++;
	}

	return(matchp);
}


/*
 - step - map set of states reachable before char to set reachable after
 */
static states
step(struct re_guts *g,
    sopno start,		/* start state within strip */
    sopno stop,			/* state after stop state within strip */
    states bef,			/* states reachable before */
    int ch,			/* character or NONCHAR code */
    states aft)			/* states already known reachable after */
{
	cset *cs;
	sop s;
	sopno pc;
	onestate here;		/* note, macros know this name */
	sopno look;
	int i;

	for (pc = start, INIT(here, pc); pc != stop; pc++, INC(here)) {
		s = g->strip[pc];
		switch (OP(s)) {
		case OEND:
			assert(pc == stop-1);
			break;
		case OCHAR:
			/* only characters can match */
			assert(!NONCHAR(ch) || ch != (char)OPND(s));
			if (ch == (char)OPND(s))
				FWD(aft, bef, 1);
			break;
		case OBOL:
			if (ch == BOL || ch == BOLEOL)
				FWD(aft, bef, 1);
			break;
		case OEOL:
			if (ch == EOL || ch == BOLEOL)
				FWD(aft, bef, 1);
			break;
		case OBOW:
			if (ch == BOW)
				FWD(aft, bef, 1);
			break;
		case OEOW:
			if (ch == EOW)
				FWD(aft, bef, 1);
			break;
		case OANY:
			if (!NONCHAR(ch))
				FWD(aft, bef, 1);
			break;
		case OANYOF:
			cs = &g->sets[OPND(s)];
			if (!NONCHAR(ch) && CHIN(cs, ch))
				FWD(aft, bef, 1);
			break;
		case OBACK_:		/* ignored here */
		case O_BACK:
			FWD(aft, aft, 1);
			break;
		case OPLUS_:		/* forward, this is just an empty */
			FWD(aft, aft, 1);
			break;
		case O_PLUS:		/* both forward and back */
			FWD(aft, aft, 1);
			i = ISSETBACK(aft, OPND(s));
			BACK(aft, aft, OPND(s));
			if (!i && ISSETBACK(aft, OPND(s))) {
				/* oho, must reconsider loop body */
				pc -= OPND(s) + 1;
				INIT(here, pc);
			}
			break;
		case OQUEST_:		/* two branches, both forward */
			FWD(aft, aft, 1);
			FWD(aft, aft, OPND(s));
			break;
		case O_QUEST:		/* just an empty */
			FWD(aft, aft, 1);
			break;
		case OLPAREN:		/* not significant here */
		case ORPAREN:
			FWD(aft, aft, 1);
			break;
		case OCH_:		/* mark the first two branches */
			FWD(aft, aft, 1);
			assert(OP(g->strip[pc+OPND(s)]) == OOR2);
			FWD(aft, aft, OPND(s));
			break;
		case OOR1:		/* done a branch, find the O_CH */
			if (ISSTATEIN(aft, here)) {
				for (look = 1;
				    OP(s = g->strip[pc+look]) != O_CH;
				    look += OPND(s))
					assert(OP(s) == OOR2);
				FWD(aft, aft, look);
			}
			break;
		case OOR2:		/* propagate OCH_'s marking */
			FWD(aft, aft, 1);
			if (OP(g->strip[pc+OPND(s)]) != O_CH) {
				assert(OP(g->strip[pc+OPND(s)]) == OOR2);
				FWD(aft, aft, OPND(s));
			}
			break;
		case O_CH:		/* just empty */
			FWD(aft, aft, 1);
			break;
		default:		/* ooooops... */
			assert(nope);
			break;
		}
	}

	return(aft);
}

#ifdef REDEBUG
/*
 - print - print a set of states
 */
static void
print(struct match *m, char *caption, states st, int ch, FILE *d)
{
	struct re_guts *g = m->g;
	int i;
	int first = 1;

	if (!(m->eflags&REG_TRACE))
		return;

	(void)fprintf(d, "%s", caption);
	(void)fprintf(d, " %s", pchar(ch));
	for (i = 0; i < g->nstates; i++) {
		if (ISSET(st, i)) {
			(void)fprintf(d, "%s%d", (first) ? "\t" : ", ", i);
			first = 0;
		}
	}
	(void)fprintf(d, "\n");
}

/* 
 - at - print current situation
 */
static void
at(struct match *m, char *title, char *start, char *stop, sopno startst,
    sopno stopst)
{
	if (!(m->eflags&REG_TRACE))
		return;

	(void)printf("%s %s-", title, pchar(*start));
	(void)printf("%s ", pchar(*stop));
	(void)printf("%ld-%ld\n", (long)startst, (long)stopst);
}

#ifndef PCHARDONE
#define	PCHARDONE	/* never again */
static const char *nonchars[] =
    { "OUT", "BOL", "EOL", "BOLEOL", "NOTHING", "BOW", "EOW" };
#define	PNONCHAR(c)						\
	((c) - OUT < (sizeof(nonchars)/sizeof(nonchars[0]))	\
	    ? nonchars[(c) - OUT] : "invalid")

/*
 - pchar - make a character printable
 *
 * Is this identical to regchar() over in debug.c?  Well, yes.  But a
 * duplicate here avoids having a debugging-capable regexec.o tied to
 * a matching debug.o, and this is convenient.  It all disappears in
 * the non-debug compilation anyway, so it doesn't matter much.
 */
static const char *		/* -> representation */
pchar(int ch)
{
	static char pbuf[10];

	if (NONCHAR(ch)) {
		if (ch - OUT < (sizeof(nonchars)/sizeof(nonchars[0])))
			return nonchars[ch - OUT];
		return "invalid";
	}
	if (isprint((unsigned char)ch) || ch == ' ')
		(void)snprintf(pbuf, sizeof pbuf, "%c", ch);
	else
		(void)snprintf(pbuf, sizeof pbuf, "\\%o", ch);
	return(pbuf);
}
#endif
#endif

#undef	matcher
#undef	fast
#undef	slow
#undef	dissect
#undef	backref
#undef	step
#undef	print
#undef	at
#undef	match
#undef	nope
@


1.23
log
@Change the way regexec handles REG_STARTEND combined with REG_NOTBOL.
The new code sees this combination as a continuation of string at offset
pmatch[0].rm_so, instead of a new string which starts at that offset.
This change fixes a search quirk in vi and is needed for upcoming fixes in
ed/sed/vi.

This new behaviour is also used in gnu regex.

Lots of help from schwarze@@
Manpage bits by schwarze@@
OK schwarze@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.22 2016/05/25 21:01:11 schwarze Exp $	*/
d159 1
a159 1
			    memcmp(dp, g->must, (size_t)g->mlen) == 0)
@


1.22
log
@KNF with respect to indentation; no code change
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.21 2016/05/25 20:48:22 schwarze Exp $	*/
d674 1
a674 1
	int c = (start == m->beginp) ? OUT : *(start-1);
d680 5
d762 1
a762 1
	int c = (start == m->beginp) ? OUT : *(start-1);
d767 5
@


1.21
log
@Fix another one-byte buffer underflow (read access only).
This change touches code that only runs when REG_BASIC is given and the
regular expression is anchored with [[:<:]] or \< _and_ uses backreferences.

Simplify the logic while here, already looking at the previous character
if REG_STARTEND and REG_NOTBOL are both in use, in anticipation of
martijn@@'s upcoming patch which will further improve REG_STARTEND.

OK millert@@ martijn@@
Also tested by Pedro Giffuni (pfg) on FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.20 2016/05/17 22:03:18 schwarze Exp $	*/
d159 1
a159 1
				memcmp(dp, g->must, (size_t)g->mlen) == 0)
d208 1
a208 1
					sizeof(regmatch_t));
d696 2
a697 2
		if ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
d701 2
a702 2
		if ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
				(c == OUT && !(m->eflags&REG_NOTEOL)) ) {
d708 2
a709 1
				st = step(m->g, startst, stopst, st, flagch, st);
d714 2
a715 2
		if ( (flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
					(c != OUT && ISWORD(c)) ) {
d717 2
a718 3
		}
		if ( (lastc != OUT && ISWORD(lastc)) &&
				(flagch == EOL || (c != OUT && !ISWORD(c))) ) {
a719 1
		}
d777 2
a778 2
		if ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
d782 2
a783 2
		if ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
				(c == OUT && !(m->eflags&REG_NOTEOL)) ) {
d789 2
a790 1
				st = step(m->g, startst, stopst, st, flagch, st);
d795 2
a796 2
		if ( (flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
					(c != OUT && ISWORD(c)) ) {
d798 2
a799 3
		}
		if ( (lastc != OUT && ISWORD(lastc)) &&
				(flagch == EOL || (c != OUT && !ISWORD(c))) ) {
a800 1
		}
d917 2
a918 2
						OP(s = g->strip[pc+look]) != O_CH;
						look += OPND(s))
d958 1
a958 1
	for (i = 0; i < g->nstates; i++)
d963 1
@


1.20
log
@Fix a one-byte buffer underflow (read access only).
This change touches code that only runs when REG_BASIC is given and
the regular expression is anchored with ^ _and_ uses backreferences.
The segfault could only be triggered when the ^ anchor was inside
a leading () subexpression quantified with *.

OK martijn@@
Patch also proofread by Pedro Giffuni <pfg at FreeBSD dot org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.19 2015/12/28 23:01:22 mmcc Exp $	*/
d525 3
a527 6
			if (( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
					(sp < m->endp && *(sp-1) == '\n' &&
						(m->g->cflags&REG_NEWLINE)) ||
					(sp > m->beginp &&
							!ISWORD(*(sp-1))) ) &&
					(sp < m->endp && ISWORD(*sp)) )
@


1.19
log
@Remove NULL-checks before free() and needless argument casts.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.18 2014/10/09 02:50:16 deraadt Exp $	*/
d509 3
a511 3
			if ( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
					(sp < m->endp && *(sp-1) == '\n' &&
						(m->g->cflags&REG_NEWLINE)) )
@


1.18
log
@use reallocarray(NULL, a, b) instead of malloc(a, b), which gives us
proper mult int overflow detection.  The existing code already handles
malloc failure properly, of course.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.17 2013/11/28 05:09:45 guenther Exp $	*/
d280 2
a281 4
	if (m->pmatch != NULL)
		free((char *)m->pmatch);
	if (m->lastpos != NULL)
		free((char *)m->lastpos);
@


1.17
log
@The print() routine here can be passed at least some of the non-characters
OUT to EOW, making its domain CHAR_MIN...CODEMAX.  It makes sense to have
pchar() take the same domain and output those non-characters appropriately,
so the (unsigned char) cast for isprint() goes in pchar().  Constipate
pchar() while we're here, and let print() pass through NUL to it, as it
knows how to output it unambiguously.

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.16 2013/04/17 17:39:29 tedu Exp $	*/
d207 2
a208 2
			m->pmatch = (regmatch_t *)malloc((m->g->nsub + 1) *
							sizeof(regmatch_t));
d220 2
a221 2
				m->lastpos = (char **)malloc((g->nplus+1) *
							sizeof(char *));
@


1.16
log
@silence some warnings by adding prototypes, casts, and headers as
appropriate. in regex, stop using the struct hack for a fixed size array
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.15 2005/08/05 13:03:00 espie Exp $	*/
d100 1
d111 1
a111 1
static char *pchar(int);
d964 1
a964 2
	if (ch != '\0')
		(void)fprintf(d, " %s", pchar(ch));
d990 6
d1004 1
a1004 1
static char *			/* -> representation */
d1009 6
a1014 1
	if (isprint(ch) || ch == ' ')
@


1.15
log
@zap rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.14 2005/01/03 19:51:14 otto Exp $	*/
d665 1
@


1.14
log
@Plug a mem leak. Now you can run hanoi.sed witt a lot of pegs and not
run out of mem! From FreeBSD PR 75656.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.13 2004/11/30 17:04:23 otto Exp $	*/
a36 4

#if defined(SNAMES) && defined(LIBC_SCCS) && !defined(lint)
static char enginercsid[] = "$OpenBSD: engine.c,v 1.13 2004/11/30 17:04:23 otto Exp $";
#endif /* SNAMES and LIBC_SCCS and not lint */
@


1.13
log
@remove useless comments, once used for header file generation and delete
parameter names from prototypes. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.12 2004/11/29 16:49:50 otto Exp $	*/
d39 1
a39 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.12 2004/11/29 16:49:50 otto Exp $";
d187 2
@


1.12
log
@Better fix for the "unbounded recursion case", for example
\(b*\)\(a*\1\)*, more cases in regress/lib/libc/regexp/test.
Only stop evaluation of a back reference if the match lenght is
zero and the recursion level is too deep. With help from jaredy@@
Problem case found by Andrew Brown in NetBSD PR 28126.
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.11 2004/10/17 17:58:54 otto Exp $	*/
d39 1
a39 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.11 2004/10/17 17:58:54 otto Exp $";
d91 6
a96 12
/* ========= begin header generated by ./mkh ========= */
#ifdef __cplusplus
extern "C" {
#endif

/* === engine.c === */
static int matcher(struct re_guts *g, char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
static char *dissect(struct match *m, char *start, char *stop, sopno startst, sopno stopst);
static char *backref(struct match *m, char *start, char *stop, sopno startst, sopno stopst, sopno lev, int);
static char *fast(struct match *m, char *start, char *stop, sopno startst, sopno stopst);
static char *slow(struct match *m, char *start, char *stop, sopno startst, sopno stopst);
static states step(struct re_guts *g, sopno start, sopno stop, states bef, int ch, states aft);
d108 1
a108 1
static void print(struct match *m, char *caption, states st, int ch, FILE *d);
d111 1
a111 1
static void at(struct match *m, char *title, char *start, char *stop, sopno startst, sopno stopst);
d114 1
a114 5
static char *pchar(int ch);
#endif

#ifdef __cplusplus
}
a115 1
/* ========= end header generated by ./mkh ========= */
a129 2
 == static int matcher(struct re_guts *g, char *string, \
 ==	size_t nmatch, regmatch_t pmatch[], int eflags);
a290 2
 == static char *dissect(struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst);
a471 2
 == static char *backref(struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst, sopno lev);
a670 2
 == static char *fast(struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst);
a754 2
 == static char *slow(struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst);
a834 11
 == static states step(struct re_guts *g, sopno start, sopno stop, \
 ==	states bef, int ch, states aft);
 == #define	BOL	(OUT+1)
 == #define	EOL	(BOL+1)
 == #define	BOLEOL	(BOL+2)
 == #define	NOTHING	(BOL+3)
 == #define	BOW	(BOL+4)
 == #define	EOW	(BOL+5)
 == #define	CODEMAX	(BOL+5)		// highest code used
 == #define	NONCHAR(c)	((c) > CHAR_MAX)
 == #define	NNONCHAR	(CODEMAX-CHAR_MAX)
a951 4
 == #ifdef REDEBUG
 == static void print(struct match *m, char *caption, states st, \
 ==	int ch, FILE *d);
 == #endif
a975 4
 == #ifdef REDEBUG
 == static void at(struct match *m, char *title, char *start, char *stop, \
 ==						sopno startst, sopno stopst);
 == #endif
a992 3
 == #ifdef REDEBUG
 == static char *pchar(int ch);
 == #endif
@


1.11
log
@ansify and deregister; no change in obj code. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.10 2004/08/13 14:52:49 millert Exp $	*/
d39 1
a39 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.10 2004/08/13 14:52:49 millert Exp $";
d99 1
a99 1
static char *backref(struct match *m, char *start, char *stop, sopno startst, sopno stopst, sopno lev);
d103 1
d242 1
a242 1
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0);
d265 1
a265 1
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0);
d492 1
a492 1
    sopno lev)			/* PLUS nesting level */
d598 1
a598 1
		if (len == 0)
d608 1
a608 1
		return(backref(m, sp+len, stop, ss+1, stopst, lev));
d611 1
a611 1
		dp = backref(m, sp, stop, ss+1, stopst, lev);
d614 1
a614 1
		return(backref(m, sp, stop, ss+OPND(s)+1, stopst, lev));
d620 1
a620 1
		return(backref(m, sp, stop, ss+1, stopst, lev+1));
d624 1
a624 1
			return(backref(m, sp, stop, ss+1, stopst, lev-1));
d627 1
a627 1
		dp = backref(m, sp, stop, ss-OPND(s)+1, stopst, lev);
d629 1
a629 1
			return(backref(m, sp, stop, ss+1, stopst, lev-1));
d638 1
a638 1
			dp = backref(m, sp, stop, ssub, esub, lev);
d659 1
a659 1
		dp = backref(m, sp, stop, ss+1, stopst, lev);
d670 1
a670 1
		dp = backref(m, sp, stop, ss+1, stopst, lev);
@


1.10
log
@Change an assert into a loop termination condition.  Fixes a core
dump found by jmc@@.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.9 2004/04/02 18:34:33 otto Exp $	*/
d39 1
a39 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.9 2004/04/02 18:34:33 otto Exp $";
d140 1
a140 1
 == static int matcher(register struct re_guts *g, char *string, \
d144 2
a145 6
matcher(g, string, nmatch, pmatch, eflags)
register struct re_guts *g;
char *string;
size_t nmatch;
regmatch_t pmatch[];
int eflags;
d147 2
a148 2
	register char *endp;
	register int i;
d150 4
a153 4
	register struct match *m = &mv;
	register char *dp;
	const register sopno gf = g->firststate+1;	/* +1 for OEND */
	const register sopno gl = g->laststate;
d303 1
a303 1
 == static char *dissect(register struct match *m, char *start, \
d307 1
a307 6
dissect(m, start, stop, startst, stopst)
register struct match *m;
char *start;
char *stop;
sopno startst;
sopno stopst;
d309 13
a321 13
	register int i;
	register sopno ss;	/* start sop of current subRE */
	register sopno es;	/* end sop of current subRE */
	register char *sp;	/* start of string matched by it */
	register char *stp;	/* string matched by it cannot pass here */
	register char *rest;	/* start of rest of string */
	register char *tail;	/* string unmatched by rest of RE */
	register sopno ssub;	/* start sop of subsubRE */
	register sopno esub;	/* end sop of subsubRE */
	register char *ssp;	/* start of string matched by subsubRE */
	register char *sep;	/* end of string matched by subsubRE */
	register char *oldssp;	/* previous ssp */
	register char *dp;
d486 1
a486 1
 == static char *backref(register struct match *m, char *start, \
d490 2
a491 7
backref(m, start, stop, startst, stopst, lev)
register struct match *m;
char *start;
char *stop;
sopno startst;
sopno stopst;
sopno lev;			/* PLUS nesting level */
d493 12
a504 12
	register int i;
	register sopno ss;	/* start sop of current subRE */
	register char *sp;	/* start of string matched by it */
	register sopno ssub;	/* start sop of subsubRE */
	register sopno esub;	/* end sop of subsubRE */
	register char *ssp;	/* start of string matched by subsubRE */
	register char *dp;
	register size_t len;
	register int hard;
	register sop s;
	register regoff_t offsave;
	register cset *cs;
d687 1
a687 1
 == static char *fast(register struct match *m, char *start, \
d691 1
a691 6
fast(m, start, stop, startst, stopst)
register struct match *m;
char *start;
char *stop;
sopno startst;
sopno stopst;
d693 9
a701 9
	register states st = m->st;
	register states fresh = m->fresh;
	register states tmp = m->tmp;
	register char *p = start;
	register int c = (start == m->beginp) ? OUT : *(start-1);
	register int lastc;	/* previous c */
	register int flagch;
	register int i;
	register char *coldp;	/* last p after which no match was underway */
d773 1
a773 1
 == static char *slow(register struct match *m, char *start, \
d777 1
a777 6
slow(m, start, stop, startst, stopst)
register struct match *m;
char *start;
char *stop;
sopno startst;
sopno stopst;
d779 9
a787 9
	register states st = m->st;
	register states empty = m->empty;
	register states tmp = m->tmp;
	register char *p = start;
	register int c = (start == m->beginp) ? OUT : *(start-1);
	register int lastc;	/* previous c */
	register int flagch;
	register int i;
	register char *matchp;	/* last p at which a match ended */
d855 2
a856 2
 == static states step(register struct re_guts *g, sopno start, sopno stop, \
 ==	register states bef, int ch, register states aft);
d868 6
a873 7
step(g, start, stop, bef, ch, aft)
register struct re_guts *g;
sopno start;			/* start state within strip */
sopno stop;			/* state after stop state within strip */
register states bef;		/* states reachable before */
int ch;				/* character or NONCHAR code */
register states aft;		/* states already known reachable after */
d875 6
a880 6
	register cset *cs;
	register sop s;
	register sopno pc;
	register onestate here;		/* note, macros know this name */
	register sopno look;
	register int i;
d989 1
a989 6
print(m, caption, st, ch, d)
struct match *m;
char *caption;
states st;
int ch;
FILE *d;
d991 3
a993 3
	register struct re_guts *g = m->g;
	register int i;
	register int first = 1;
d1017 2
a1018 7
at(m, title, start, stop, startst, stopst)
struct match *m;
char *title;
char *start;
char *stop;
sopno startst;
sopno stopst;
d1042 1
a1042 2
pchar(ch)
int ch;
@


1.9
log
@Avoid unbounded recursion in some expressions involving back references.
For example:
echo "foo foo bar bar bar baz" | sed 's/\([^ ]*\)\( *\1\)*/\1/g'
Test case found by dhartmei@@
ok millert@@ dhartmei@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.8 2004/03/30 20:36:07 millert Exp $	*/
d39 1
a39 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.8 2004/03/30 20:36:07 millert Exp $";
d276 2
a278 1
		assert(start <= stop);
@


1.8
log
@Allow compilation w/ -DREDEBUG; non-debug compilation is unaffected.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.7 2003/06/02 20:18:36 millert Exp $	*/
d39 1
a39 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.7 2003/06/02 20:18:36 millert Exp $";
d610 2
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.6 2002/05/25 09:11:02 deraadt Exp $	*/
d39 1
a39 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.6 2002/05/25 09:11:02 deraadt Exp $";
d59 1
d71 1
d131 1
d1097 1
@


1.6
log
@remaining easy snprintf conversions
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.5 2002/02/16 21:27:24 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.5 2002/02/16 21:27:24 millert Exp $";
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.4 1997/04/28 20:44:57 millert Exp $	*/
d43 1
a43 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.4 1997/04/28 20:44:57 millert Exp $";
d1081 1
a1081 1
		(void)sprintf(pbuf, "%c", ch);
d1083 1
a1083 1
		(void)sprintf(pbuf, "\\%o", ch);
@


1.4
log
@- cast usages of *printf() to void since we don't check return val
- move an assert to be *before* a strcpy() where it can do some good.
- integrate NetBSD fixes for 64-bit machines (NetBSD PR #3450, Ross Harvey)
- add lite2 tags
@
text
@d1 1
a1 1
/*	$OpenBSD: engine.c,v 1.2 1996/08/19 08:31:06 tholo Exp $	*/
d43 1
a43 1
static char enginercsid[] = "$OpenBSD: engine.c,v 1.2 1996/08/19 08:31:06 tholo Exp $";
d99 6
a104 6
static int matcher __P((struct re_guts *g, char *string, size_t nmatch, regmatch_t pmatch[], int eflags));
static char *dissect __P((struct match *m, char *start, char *stop, sopno startst, sopno stopst));
static char *backref __P((struct match *m, char *start, char *stop, sopno startst, sopno stopst, sopno lev));
static char *fast __P((struct match *m, char *start, char *stop, sopno startst, sopno stopst));
static char *slow __P((struct match *m, char *start, char *stop, sopno startst, sopno stopst));
static states step __P((struct re_guts *g, sopno start, sopno stop, states bef, int ch, states aft));
d115 1
a115 1
static void print __P((struct match *m, char *caption, states st, int ch, FILE *d));
d118 1
a118 1
static void at __P((struct match *m, char *title, char *start, char *stop, sopno startst, sopno stopst));
d121 1
a121 1
static char *pchar __P((int ch));
@


1.3
log
@long -> int to fix 64bit issues.  This breaks 16bit machines but since we don't have any 16bit ports...) The alternative is to use int32_t's but then this code will break when/if int > 32bits which is not so unlikely.  Fixes NetBSD PR #3450 from Ross Harvey (but in a different way)
@
text
@d1 2
d38 2
d132 1
a132 1
#define	NOTE(str)	{ if (m->eflags&REG_TRACE) printf("=%s\n", (str)); }
d1026 1
a1026 1
	fprintf(d, "%s", caption);
d1028 1
a1028 1
		fprintf(d, " %s", pchar(ch));
d1031 1
a1031 1
			fprintf(d, "%s%d", (first) ? "\t" : ", ", i);
d1034 1
a1034 1
	fprintf(d, "\n");
d1056 3
a1058 3
	printf("%s %s-", title, pchar(*start));
	printf("%s ", pchar(*stop));
	printf("%d-%d\n", startst, stopst);
d1081 1
a1081 1
		sprintf(pbuf, "%c", ch);
d1083 1
a1083 1
		sprintf(pbuf, "\\%o", ch);
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d39 1
a39 1
static char enginercsid[] = "$OpenBSD$";
d1054 1
a1054 1
	printf("%ld-%ld\n", (long)startst, (long)stopst);
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: engine.c,v 1.5 1995/02/27 13:28:39 cgd Exp $	*/

a35 2
 *
 *	@@(#)engine.c	8.5 (Berkeley) 3/20/94
d37 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
