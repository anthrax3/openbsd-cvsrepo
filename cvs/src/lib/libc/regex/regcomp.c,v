head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.2
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.6
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.4
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.2
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.12
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.8
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.6.0.14
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.12.22.00.09.07;	author krw;	state Exp;
branches;
next	1.30;
commitid	I83BB0iKkaOS5kpv;

1.30
date	2016.12.21.15.13.50;	author krw;	state Exp;
branches;
next	1.29;
commitid	42CnNAJTwl0VUF9z;

1.29
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.28;
commitid	pqjnYVtACzQ9ctai;

1.28
date	2015.12.28.22.08.18;	author mmcc;	state Exp;
branches;
next	1.27;
commitid	0uXuF2O13NH9q2e1;

1.27
date	2015.11.01.03.45.29;	author guenther;	state Exp;
branches;
next	1.26;
commitid	CfNWDWdDpm7mVO8i;

1.26
date	2014.10.18.04.12.28;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	6lgJd1d8owi5wqqq;

1.25
date	2014.09.08.15.45.20;	author tedu;	state Exp;
branches;
next	1.24;
commitid	DwK2wfTRPje34F0N;

1.24
date	2014.05.06.15.48.38;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.26.13.16.18;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.04.17.17.39.29;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2011.11.07.09.58.27;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2010.11.21.00.02.30;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2008.02.23.08.13.07;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.10.21.23.44;	author chl;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.02.15.19.17;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.31.05.36.36;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.05.13.03.00;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.30.17.04.23;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.17.17.58.54;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.08.06.33.41;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.07.06.17.17;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.18.36;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.05.00.43.20;	author tdeval;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.01.23.27.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.08.14.21.39.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.04.30.05.51.09;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	97.04.28.20.44.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.09.31.25;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.31.10;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.08;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Clarify code by eliminating unused #define's MUSTSEE, MUSTNOTSEE and inlining
MUSTEAT.

ok tom@@
@
text
@/*	$OpenBSD: regcomp.c,v 1.30 2016/12/21 15:13:50 krw Exp $ */
/*-
 * Copyright (c) 1992, 1993, 1994 Henry Spencer.
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Henry Spencer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)regcomp.c	8.5 (Berkeley) 3/20/94
 */

#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <stdlib.h>
#include <regex.h>

#include "utils.h"
#include "regex2.h"

#include "cclass.h"
#include "cname.h"

/*
 * parse structure, passed up and down to avoid global variables and
 * other clumsinesses
 */
struct parse {
	char *next;		/* next character in RE */
	char *end;		/* end of string (-> NUL normally) */
	int error;		/* has an error been seen? */
	sop *strip;		/* malloced strip */
	sopno ssize;		/* malloced strip size (allocated) */
	sopno slen;		/* malloced strip length (used) */
	int ncsalloc;		/* number of csets allocated */
	struct re_guts *g;
#	define	NPAREN	10	/* we need to remember () 1-9 for back refs */
	sopno pbegin[NPAREN];	/* -> ( ([0] unused) */
	sopno pend[NPAREN];	/* -> ) ([0] unused) */
};

static void p_ere(struct parse *, int);
static void p_ere_exp(struct parse *);
static void p_str(struct parse *);
static void p_bre(struct parse *, int, int);
static int p_simp_re(struct parse *, int);
static int p_count(struct parse *);
static void p_bracket(struct parse *);
static void p_b_term(struct parse *, cset *);
static void p_b_cclass(struct parse *, cset *);
static void p_b_eclass(struct parse *, cset *);
static char p_b_symbol(struct parse *);
static char p_b_coll_elem(struct parse *, int);
static char othercase(int);
static void bothcases(struct parse *, int);
static void ordinary(struct parse *, int);
static void backslash(struct parse *, int);
static void nonnewline(struct parse *);
static void repeat(struct parse *, sopno, int, int);
static int seterr(struct parse *, int);
static cset *allocset(struct parse *);
static void freeset(struct parse *, cset *);
static int freezeset(struct parse *, cset *);
static int firstch(struct parse *, cset *);
static int nch(struct parse *, cset *);
static void mcadd(struct parse *, cset *, char *);
static void mcinvert(struct parse *, cset *);
static void mccase(struct parse *, cset *);
static int isinsets(struct re_guts *, int);
static int samesets(struct re_guts *, int, int);
static void categorize(struct parse *, struct re_guts *);
static sopno dupl(struct parse *, sopno, sopno);
static void doemit(struct parse *, sop, size_t);
static void doinsert(struct parse *, sop, size_t, sopno);
static void dofwd(struct parse *, sopno, sop);
static int enlarge(struct parse *, sopno);
static void stripsnug(struct parse *, struct re_guts *);
static void findmust(struct parse *, struct re_guts *);
static sopno pluscount(struct parse *, struct re_guts *);

static char nuls[10];		/* place to point scanner in event of error */

/*
 * macros for use with parse structure
 * BEWARE:  these know that the parse structure is named `p' !!!
 */
#define	PEEK()	(*p->next)
#define	PEEK2()	(*(p->next+1))
#define	MORE()	(p->next < p->end)
#define	MORE2()	(p->next+1 < p->end)
#define	SEE(c)	(MORE() && PEEK() == (c))
#define	SEETWO(a, b)	(MORE() && MORE2() && PEEK() == (a) && PEEK2() == (b))
#define	EAT(c)	((SEE(c)) ? (NEXT(), 1) : 0)
#define	EATTWO(a, b)	((SEETWO(a, b)) ? (NEXT2(), 1) : 0)
#define	NEXT()	(p->next++)
#define	NEXT2()	(p->next += 2)
#define	NEXTn(n)	(p->next += (n))
#define	GETNEXT()	(*p->next++)
#define	SETERROR(e)	seterr(p, (e))
#define	REQUIRE(co, e)	(void) ((co) || SETERROR(e))
#define	EMIT(op, sopnd)	doemit(p, (sop)(op), (size_t)(sopnd))
#define	INSERT(op, pos)	doinsert(p, (sop)(op), HERE()-(pos)+1, pos)
#define	AHEAD(pos)		dofwd(p, pos, HERE()-(pos))
#define	ASTERN(sop, pos)	EMIT(sop, HERE()-pos)
#define	HERE()		(p->slen)
#define	THERE()		(p->slen - 1)
#define	THERETHERE()	(p->slen - 2)
#define	DROP(n)	(p->slen -= (n))

#ifndef NDEBUG
static int never = 0;		/* for use in asserts; shuts lint up */
#else
#define	never	0		/* some <assert.h>s have bugs too */
#endif

/*
 - regcomp - interface for parser and compilation
 */
int				/* 0 success, otherwise REG_something */
regcomp(regex_t *preg, const char *pattern, int cflags)
{
	struct parse pa;
	struct re_guts *g;
	struct parse *p = &pa;
	int i;
	size_t len;
#ifdef REDEBUG
#	define	GOODFLAGS(f)	(f)
#else
#	define	GOODFLAGS(f)	((f)&~REG_DUMP)
#endif

	cflags = GOODFLAGS(cflags);
	if ((cflags&REG_EXTENDED) && (cflags&REG_NOSPEC))
		return(REG_INVARG);

	if (cflags&REG_PEND) {
		if (preg->re_endp < pattern)
			return(REG_INVARG);
		len = preg->re_endp - pattern;
	} else
		len = strlen((char *)pattern);

	/* do the mallocs early so failure handling is easy */
	g = malloc(sizeof(struct re_guts));
	if (g == NULL)
		return(REG_ESPACE);
	p->ssize = len/(size_t)2*(size_t)3 + (size_t)1;	/* ugh */
	p->strip = reallocarray(NULL, p->ssize, sizeof(sop));
	p->slen = 0;
	if (p->strip == NULL) {
		free(g);
		return(REG_ESPACE);
	}

	/* set things up */
	p->g = g;
	p->next = (char *)pattern;	/* convenience; we do not modify it */
	p->end = p->next + len;
	p->error = 0;
	p->ncsalloc = 0;
	for (i = 0; i < NPAREN; i++) {
		p->pbegin[i] = 0;
		p->pend[i] = 0;
	}
	g->csetsize = NC;
	g->sets = NULL;
	g->setbits = NULL;
	g->ncsets = 0;
	g->cflags = cflags;
	g->iflags = 0;
	g->nbol = 0;
	g->neol = 0;
	g->must = NULL;
	g->mlen = 0;
	g->nsub = 0;
	g->ncategories = 1;	/* category 0 is "everything else" */
	g->categories = &g->catspace[-(CHAR_MIN)];
	memset(g->catspace, 0, sizeof(g->catspace));
	g->backrefs = 0;

	/* do it */
	EMIT(OEND, 0);
	g->firststate = THERE();
	if (cflags&REG_EXTENDED)
		p_ere(p, OUT);
	else if (cflags&REG_NOSPEC)
		p_str(p);
	else
		p_bre(p, OUT, OUT);
	EMIT(OEND, 0);
	g->laststate = THERE();

	/* tidy up loose ends and fill things in */
	categorize(p, g);
	stripsnug(p, g);
	findmust(p, g);
	g->nplus = pluscount(p, g);
	g->magic = MAGIC2;
	preg->re_nsub = g->nsub;
	preg->re_g = g;
	preg->re_magic = MAGIC1;
#ifndef REDEBUG
	/* not debugging, so can't rely on the assert() in regexec() */
	if (g->iflags&BAD)
		SETERROR(REG_ASSERT);
#endif

	/* win or lose, we're done */
	if (p->error != 0)	/* lose */
		regfree(preg);
	return(p->error);
}

/*
 - p_ere - ERE parser top level, concatenation and alternation
 */
static void
p_ere(struct parse *p, int stop)	/* character this ERE should end at */
{
	char c;
	sopno prevback;
	sopno prevfwd;
	sopno conc;
	int first = 1;		/* is this the first alternative? */

	for (;;) {
		/* do a bunch of concatenated expressions */
		conc = HERE();
		while (MORE() && (c = PEEK()) != '|' && c != stop)
			p_ere_exp(p);
		REQUIRE(HERE() != conc, REG_EMPTY);	/* require nonempty */

		if (!EAT('|'))
			break;		/* NOTE BREAK OUT */

		if (first) {
			INSERT(OCH_, conc);	/* offset is wrong */
			prevfwd = conc;
			prevback = conc;
			first = 0;
		}
		ASTERN(OOR1, prevback);
		prevback = THERE();
		AHEAD(prevfwd);			/* fix previous offset */
		prevfwd = HERE();
		EMIT(OOR2, 0);			/* offset is very wrong */
	}

	if (!first) {		/* tail-end fixups */
		AHEAD(prevfwd);
		ASTERN(O_CH, prevback);
	}

	assert(!MORE() || SEE(stop));
}

/*
 - p_ere_exp - parse one subERE, an atom possibly followed by a repetition op
 */
static void
p_ere_exp(struct parse *p)
{
	char c;
	sopno pos;
	int count;
	int count2;
	sopno subno;
	int wascaret = 0;

	assert(MORE());		/* caller should have ensured this */
	c = GETNEXT();

	pos = HERE();
	switch (c) {
	case '(':
		REQUIRE(MORE(), REG_EPAREN);
		p->g->nsub++;
		subno = p->g->nsub;
		if (subno < NPAREN)
			p->pbegin[subno] = HERE();
		EMIT(OLPAREN, subno);
		if (!SEE(')'))
			p_ere(p, ')');
		if (subno < NPAREN) {
			p->pend[subno] = HERE();
			assert(p->pend[subno] != 0);
		}
		EMIT(ORPAREN, subno);
		REQUIRE(MORE() && GETNEXT() == ')', REG_EPAREN);
		break;
	case '^':
		EMIT(OBOL, 0);
		p->g->iflags |= USEBOL;
		p->g->nbol++;
		wascaret = 1;
		break;
	case '$':
		EMIT(OEOL, 0);
		p->g->iflags |= USEEOL;
		p->g->neol++;
		break;
	case '|':
		SETERROR(REG_EMPTY);
		break;
	case '*':
	case '+':
	case '?':
		SETERROR(REG_BADRPT);
		break;
	case '.':
		if (p->g->cflags&REG_NEWLINE)
			nonnewline(p);
		else
			EMIT(OANY, 0);
		break;
	case '[':
		p_bracket(p);
		break;
	case '\\':
		REQUIRE(MORE(), REG_EESCAPE);
		c = GETNEXT();
		backslash(p, c);
		break;
	case '{':		/* okay as ordinary except if digit follows */
		REQUIRE(!MORE() || !isdigit((uch)PEEK()), REG_BADRPT);
		/* FALLTHROUGH */
	default:
		ordinary(p, c);
		break;
	}

	if (!MORE())
		return;
	c = PEEK();
	/* we call { a repetition if followed by a digit */
	if (!( c == '*' || c == '+' || c == '?' ||
				(c == '{' && MORE2() && isdigit((uch)PEEK2())) ))
		return;		/* no repetition, we're done */
	NEXT();

	REQUIRE(!wascaret, REG_BADRPT);
	switch (c) {
	case '*':	/* implemented as +? */
		/* this case does not require the (y|) trick, noKLUDGE */
		INSERT(OPLUS_, pos);
		ASTERN(O_PLUS, pos);
		INSERT(OQUEST_, pos);
		ASTERN(O_QUEST, pos);
		break;
	case '+':
		INSERT(OPLUS_, pos);
		ASTERN(O_PLUS, pos);
		break;
	case '?':
		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
		INSERT(OCH_, pos);		/* offset slightly wrong */
		ASTERN(OOR1, pos);		/* this one's right */
		AHEAD(pos);			/* fix the OCH_ */
		EMIT(OOR2, 0);			/* offset very wrong... */
		AHEAD(THERE());			/* ...so fix it */
		ASTERN(O_CH, THERETHERE());
		break;
	case '{':
		count = p_count(p);
		if (EAT(',')) {
			if (isdigit((uch)PEEK())) {
				count2 = p_count(p);
				REQUIRE(count <= count2, REG_BADBR);
			} else		/* single number with comma */
				count2 = INFINITY;
		} else		/* just a single number */
			count2 = count;
		repeat(p, pos, count, count2);
		if (!EAT('}')) {	/* error heuristics */
			while (MORE() && PEEK() != '}')
				NEXT();
			REQUIRE(MORE(), REG_EBRACE);
			SETERROR(REG_BADBR);
		}
		break;
	}

	if (!MORE())
		return;
	c = PEEK();
	if (!( c == '*' || c == '+' || c == '?' ||
				(c == '{' && MORE2() && isdigit((uch)PEEK2())) ) )
		return;
	SETERROR(REG_BADRPT);
}

/*
 - p_str - string (no metacharacters) "parser"
 */
static void
p_str(struct parse *p)
{
	REQUIRE(MORE(), REG_EMPTY);
	while (MORE())
		ordinary(p, GETNEXT());
}

/*
 - p_bre - BRE parser top level, anchoring and concatenation
 * Giving end1 as OUT essentially eliminates the end1/end2 check.
 *
 * This implementation is a bit of a kludge, in that a trailing $ is first
 * taken as an ordinary character and then revised to be an anchor.  The
 * only undesirable side effect is that '$' gets included as a character
 * category in such cases.  This is fairly harmless; not worth fixing.
 * The amount of lookahead needed to avoid this kludge is excessive.
 */
static void
p_bre(struct parse *p,
    int end1,		/* first terminating character */
    int end2)		/* second terminating character */
{
	sopno start = HERE();
	int first = 1;			/* first subexpression? */
	int wasdollar = 0;

	if (EAT('^')) {
		EMIT(OBOL, 0);
		p->g->iflags |= USEBOL;
		p->g->nbol++;
	}
	while (MORE() && !SEETWO(end1, end2)) {
		wasdollar = p_simp_re(p, first);
		first = 0;
	}
	if (wasdollar) {	/* oops, that was a trailing anchor */
		DROP(1);
		EMIT(OEOL, 0);
		p->g->iflags |= USEEOL;
		p->g->neol++;
	}

	REQUIRE(HERE() != start, REG_EMPTY);	/* require nonempty */
}

/*
 - p_simp_re - parse a simple RE, an atom possibly followed by a repetition
 */
static int			/* was the simple RE an unbackslashed $? */
p_simp_re(struct parse *p,
    int starordinary)		/* is a leading * an ordinary character? */
{
	int c;
	int count;
	int count2;
	sopno pos;
	int i;
	sopno subno;
#	define	BACKSL	(1<<CHAR_BIT)

	pos = HERE();		/* repetion op, if any, covers from here */

	assert(MORE());		/* caller should have ensured this */
	c = GETNEXT();
	if (c == '\\') {
		REQUIRE(MORE(), REG_EESCAPE);
		c = BACKSL | GETNEXT();
	}
	switch (c) {
	case '.':
		if (p->g->cflags&REG_NEWLINE)
			nonnewline(p);
		else
			EMIT(OANY, 0);
		break;
	case '[':
		p_bracket(p);
		break;
	case BACKSL|'<':
		EMIT(OBOW, 0);
		break;
	case BACKSL|'>':
		EMIT(OEOW, 0);
		break;
	case BACKSL|'{':
		SETERROR(REG_BADRPT);
		break;
	case BACKSL|'(':
		p->g->nsub++;
		subno = p->g->nsub;
		if (subno < NPAREN)
			p->pbegin[subno] = HERE();
		EMIT(OLPAREN, subno);
		/* the MORE here is an error heuristic */
		if (MORE() && !SEETWO('\\', ')'))
			p_bre(p, '\\', ')');
		if (subno < NPAREN) {
			p->pend[subno] = HERE();
			assert(p->pend[subno] != 0);
		}
		EMIT(ORPAREN, subno);
		REQUIRE(EATTWO('\\', ')'), REG_EPAREN);
		break;
	case BACKSL|')':	/* should not get here -- must be user */
	case BACKSL|'}':
		SETERROR(REG_EPAREN);
		break;
	case BACKSL|'1':
	case BACKSL|'2':
	case BACKSL|'3':
	case BACKSL|'4':
	case BACKSL|'5':
	case BACKSL|'6':
	case BACKSL|'7':
	case BACKSL|'8':
	case BACKSL|'9':
		i = (c&~BACKSL) - '0';
		assert(i < NPAREN);
		if (p->pend[i] != 0) {
			assert(i <= p->g->nsub);
			EMIT(OBACK_, i);
			assert(p->pbegin[i] != 0);
			assert(OP(p->strip[p->pbegin[i]]) == OLPAREN);
			assert(OP(p->strip[p->pend[i]]) == ORPAREN);
			(void) dupl(p, p->pbegin[i]+1, p->pend[i]);
			EMIT(O_BACK, i);
		} else
			SETERROR(REG_ESUBREG);
		p->g->backrefs = 1;
		break;
	case '*':
		REQUIRE(starordinary, REG_BADRPT);
		/* FALLTHROUGH */
	default:
		ordinary(p, (char)c);
		break;
	}

	if (EAT('*')) {		/* implemented as +? */
		/* this case does not require the (y|) trick, noKLUDGE */
		INSERT(OPLUS_, pos);
		ASTERN(O_PLUS, pos);
		INSERT(OQUEST_, pos);
		ASTERN(O_QUEST, pos);
	} else if (EATTWO('\\', '{')) {
		count = p_count(p);
		if (EAT(',')) {
			if (MORE() && isdigit((uch)PEEK())) {
				count2 = p_count(p);
				REQUIRE(count <= count2, REG_BADBR);
			} else		/* single number with comma */
				count2 = INFINITY;
		} else		/* just a single number */
			count2 = count;
		repeat(p, pos, count, count2);
		if (!EATTWO('\\', '}')) {	/* error heuristics */
			while (MORE() && !SEETWO('\\', '}'))
				NEXT();
			REQUIRE(MORE(), REG_EBRACE);
			SETERROR(REG_BADBR);
		}
	} else if (c == '$')	/* $ (but not \$) ends it */
		return(1);

	return(0);
}

/*
 - p_count - parse a repetition count
 */
static int			/* the value */
p_count(struct parse *p)
{
	int count = 0;
	int ndigits = 0;

	while (MORE() && isdigit((uch)PEEK()) && count <= DUPMAX) {
		count = count*10 + (GETNEXT() - '0');
		ndigits++;
	}

	REQUIRE(ndigits > 0 && count <= DUPMAX, REG_BADBR);
	return(count);
}

/*
 - p_bracket - parse a bracketed character list
 *
 * Note a significant property of this code:  if the allocset() did SETERROR,
 * no set operations are done.
 */
static void
p_bracket(struct parse *p)
{
	cset *cs;
	int invert = 0;

	/* Dept of Truly Sickening Special-Case Kludges */
	if (p->next + 5 < p->end && strncmp(p->next, "[:<:]]", 6) == 0) {
		EMIT(OBOW, 0);
		NEXTn(6);
		return;
	}
	if (p->next + 5 < p->end && strncmp(p->next, "[:>:]]", 6) == 0) {
		EMIT(OEOW, 0);
		NEXTn(6);
		return;
	}

	if ((cs = allocset(p)) == NULL) {
		/* allocset did set error status in p */
		return;
	}

	if (EAT('^'))
		invert++;	/* make note to invert set at end */
	if (EAT(']'))
		CHadd(cs, ']');
	else if (EAT('-'))
		CHadd(cs, '-');
	while (MORE() && PEEK() != ']' && !SEETWO('-', ']'))
		p_b_term(p, cs);
	if (EAT('-'))
		CHadd(cs, '-');
	REQUIRE(MORE() && GETNEXT() == ']', REG_EBRACK);

	if (p->error != 0) {	/* don't mess things up further */
		freeset(p, cs);
		return;
	}

	if (p->g->cflags&REG_ICASE) {
		int i;
		int ci;

		for (i = p->g->csetsize - 1; i >= 0; i--)
			if (CHIN(cs, i) && isalpha(i)) {
				ci = othercase(i);
				if (ci != i)
					CHadd(cs, ci);
			}
		if (cs->multis != NULL)
			mccase(p, cs);
	}
	if (invert) {
		int i;

		for (i = p->g->csetsize - 1; i >= 0; i--)
			if (CHIN(cs, i))
				CHsub(cs, i);
			else
				CHadd(cs, i);
		if (p->g->cflags&REG_NEWLINE)
			CHsub(cs, '\n');
		if (cs->multis != NULL)
			mcinvert(p, cs);
	}

	assert(cs->multis == NULL);		/* xxx */

	if (nch(p, cs) == 1) {		/* optimize singleton sets */
		ordinary(p, firstch(p, cs));
		freeset(p, cs);
	} else
		EMIT(OANYOF, freezeset(p, cs));
}

/*
 - p_b_term - parse one term of a bracketed character list
 */
static void
p_b_term(struct parse *p, cset *cs)
{
	char c;
	char start, finish;
	int i;

	/* classify what we've got */
	switch ((MORE()) ? PEEK() : '\0') {
	case '[':
		c = (MORE2()) ? PEEK2() : '\0';
		break;
	case '-':
		SETERROR(REG_ERANGE);
		return;			/* NOTE RETURN */
		break;
	default:
		c = '\0';
		break;
	}

	switch (c) {
	case ':':		/* character class */
		NEXT2();
		REQUIRE(MORE(), REG_EBRACK);
		c = PEEK();
		REQUIRE(c != '-' && c != ']', REG_ECTYPE);
		p_b_cclass(p, cs);
		REQUIRE(MORE(), REG_EBRACK);
		REQUIRE(EATTWO(':', ']'), REG_ECTYPE);
		break;
	case '=':		/* equivalence class */
		NEXT2();
		REQUIRE(MORE(), REG_EBRACK);
		c = PEEK();
		REQUIRE(c != '-' && c != ']', REG_ECOLLATE);
		p_b_eclass(p, cs);
		REQUIRE(MORE(), REG_EBRACK);
		REQUIRE(EATTWO('=', ']'), REG_ECOLLATE);
		break;
	default:		/* symbol, ordinary character, or range */
/* xxx revision needed for multichar stuff */
		start = p_b_symbol(p);
		if (SEE('-') && MORE2() && PEEK2() != ']') {
			/* range */
			NEXT();
			if (EAT('-'))
				finish = '-';
			else
				finish = p_b_symbol(p);
		} else
			finish = start;
/* xxx what about signed chars here... */
		REQUIRE(start <= finish, REG_ERANGE);
		for (i = start; i <= finish; i++)
			CHadd(cs, i);
		break;
	}
}

/*
 - p_b_cclass - parse a character-class name and deal with it
 */
static void
p_b_cclass(struct parse *p, cset *cs)
{
	char *sp = p->next;
	struct cclass *cp;
	size_t len;
	char *u;
	char c;

	while (MORE() && isalpha((uch)PEEK()))
		NEXT();
	len = p->next - sp;
	for (cp = cclasses; cp->name != NULL; cp++)
		if (strncmp(cp->name, sp, len) == 0 && cp->name[len] == '\0')
			break;
	if (cp->name == NULL) {
		/* oops, didn't find it */
		SETERROR(REG_ECTYPE);
		return;
	}

	u = cp->chars;
	while ((c = *u++) != '\0')
		CHadd(cs, c);
	for (u = cp->multis; *u != '\0'; u += strlen(u) + 1)
		MCadd(p, cs, u);
}

/*
 - p_b_eclass - parse an equivalence-class name and deal with it
 *
 * This implementation is incomplete. xxx
 */
static void
p_b_eclass(struct parse *p, cset *cs)
{
	char c;

	c = p_b_coll_elem(p, '=');
	CHadd(cs, c);
}

/*
 - p_b_symbol - parse a character or [..]ed multicharacter collating symbol
 */
static char			/* value of symbol */
p_b_symbol(struct parse *p)
{
	char value;

	REQUIRE(MORE(), REG_EBRACK);
	if (!EATTWO('[', '.'))
		return(GETNEXT());

	/* collating symbol */
	value = p_b_coll_elem(p, '.');
	REQUIRE(EATTWO('.', ']'), REG_ECOLLATE);
	return(value);
}

/*
 - p_b_coll_elem - parse a collating-element name and look it up
 */
static char			/* value of collating element */
p_b_coll_elem(struct parse *p,
    int endc)			/* name ended by endc,']' */
{
	char *sp = p->next;
	struct cname *cp;
	int len;

	while (MORE() && !SEETWO(endc, ']'))
		NEXT();
	if (!MORE()) {
		SETERROR(REG_EBRACK);
		return(0);
	}
	len = p->next - sp;
	for (cp = cnames; cp->name != NULL; cp++)
		if (strncmp(cp->name, sp, len) == 0 && cp->name[len] == '\0')
			return(cp->code);	/* known name */
	if (len == 1)
		return(*sp);	/* single character */
	SETERROR(REG_ECOLLATE);			/* neither */
	return(0);
}

/*
 - othercase - return the case counterpart of an alphabetic
 */
static char			/* if no counterpart, return ch */
othercase(int ch)
{
	ch = (uch)ch;
	assert(isalpha(ch));
	if (isupper(ch))
		return ((uch)tolower(ch));
	else if (islower(ch))
		return ((uch)toupper(ch));
	else			/* peculiar, but could happen */
		return(ch);
}

/*
 - bothcases - emit a dualcase version of a two-case character
 *
 * Boy, is this implementation ever a kludge...
 */
static void
bothcases(struct parse *p, int ch)
{
	char *oldnext = p->next;
	char *oldend = p->end;
	char bracket[3];

	ch = (uch)ch;
	assert(othercase(ch) != ch);	/* p_bracket() would recurse */
	p->next = bracket;
	p->end = bracket+2;
	bracket[0] = ch;
	bracket[1] = ']';
	bracket[2] = '\0';
	p_bracket(p);
	assert(p->next == bracket+2);
	p->next = oldnext;
	p->end = oldend;
}

/*
 - ordinary - emit an ordinary character
 */
static void
ordinary(struct parse *p, int ch)
{
	cat_t *cap = p->g->categories;

	if ((p->g->cflags&REG_ICASE) && isalpha((uch)ch) && othercase(ch) != ch)
		bothcases(p, ch);
	else {
		EMIT(OCHAR, (uch)ch);
		if (cap[ch] == 0)
			cap[ch] = p->g->ncategories++;
	}
}

/*
 * do something magic with this character, but only if it's extra magic
 */
static void
backslash(struct parse *p, int ch)
{
	switch (ch) {
	case '<':
		EMIT(OBOW, 0);
		break;
	case '>':
		EMIT(OEOW, 0);
		break;
	default:
		ordinary(p, ch);
		break;
	}
}

/*
 - nonnewline - emit REG_NEWLINE version of OANY
 *
 * Boy, is this implementation ever a kludge...
 */
static void
nonnewline(struct parse *p)
{
	char *oldnext = p->next;
	char *oldend = p->end;
	char bracket[4];

	p->next = bracket;
	p->end = bracket+3;
	bracket[0] = '^';
	bracket[1] = '\n';
	bracket[2] = ']';
	bracket[3] = '\0';
	p_bracket(p);
	assert(p->next == bracket+3);
	p->next = oldnext;
	p->end = oldend;
}

/*
 - repeat - generate code for a bounded repetition, recursively if needed
 */
static void
repeat(struct parse *p,
    sopno start,		/* operand from here to end of strip */
    int from,			/* repeated from this number */
    int to)			/* to this number of times (maybe INFINITY) */
{
	sopno finish = HERE();
#	define	N	2
#	define	INF	3
#	define	REP(f, t)	((f)*8 + (t))
#	define	MAP(n)	(((n) <= 1) ? (n) : ((n) == INFINITY) ? INF : N)
	sopno copy;

	if (p->error != 0)	/* head off possible runaway recursion */
		return;

	assert(from <= to);

	switch (REP(MAP(from), MAP(to))) {
	case REP(0, 0):			/* must be user doing this */
		DROP(finish-start);	/* drop the operand */
		break;
	case REP(0, 1):			/* as x{1,1}? */
	case REP(0, N):			/* as x{1,n}? */
	case REP(0, INF):		/* as x{1,}? */
		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
		INSERT(OCH_, start);		/* offset is wrong... */
		repeat(p, start+1, 1, to);
		ASTERN(OOR1, start);
		AHEAD(start);			/* ... fix it */
		EMIT(OOR2, 0);
		AHEAD(THERE());
		ASTERN(O_CH, THERETHERE());
		break;
	case REP(1, 1):			/* trivial case */
		/* done */
		break;
	case REP(1, N):			/* as x?x{1,n-1} */
		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
		INSERT(OCH_, start);
		ASTERN(OOR1, start);
		AHEAD(start);
		EMIT(OOR2, 0);			/* offset very wrong... */
		AHEAD(THERE());			/* ...so fix it */
		ASTERN(O_CH, THERETHERE());
		copy = dupl(p, start+1, finish+1);
		assert(copy == finish+4);
		repeat(p, copy, 1, to-1);
		break;
	case REP(1, INF):		/* as x+ */
		INSERT(OPLUS_, start);
		ASTERN(O_PLUS, start);
		break;
	case REP(N, N):			/* as xx{m-1,n-1} */
		copy = dupl(p, start, finish);
		repeat(p, copy, from-1, to-1);
		break;
	case REP(N, INF):		/* as xx{n-1,INF} */
		copy = dupl(p, start, finish);
		repeat(p, copy, from-1, to);
		break;
	default:			/* "can't happen" */
		SETERROR(REG_ASSERT);	/* just in case */
		break;
	}
}

/*
 - seterr - set an error condition
 */
static int			/* useless but makes type checking happy */
seterr(struct parse *p, int e)
{
	if (p->error == 0)	/* keep earliest error condition */
		p->error = e;
	p->next = nuls;		/* try to bring things to a halt */
	p->end = nuls;
	return(0);		/* make the return value well-defined */
}

/*
 - allocset - allocate a set of characters for []
 */
static cset *
allocset(struct parse *p)
{
	int no = p->g->ncsets++;
	size_t nc;
	size_t nbytes;
	cset *cs;
	size_t css = (size_t)p->g->csetsize;
	int i;

	if (no >= p->ncsalloc) {	/* need another column of space */
		void *ptr;

		p->ncsalloc += CHAR_BIT;
		nc = p->ncsalloc;
		assert(nc % CHAR_BIT == 0);

		ptr = reallocarray(p->g->sets, nc, sizeof(cset));
		if (ptr == NULL)
			goto nomem;
		p->g->sets = ptr;

		ptr = reallocarray(p->g->setbits, nc / CHAR_BIT, css);
		if (ptr == NULL)
			goto nomem;
		nbytes = (nc / CHAR_BIT) * css;
		p->g->setbits = ptr;

		for (i = 0; i < no; i++)
			p->g->sets[i].ptr = p->g->setbits + css*(i/CHAR_BIT);

		(void) memset((char *)p->g->setbits + (nbytes - css), 0, css);
	}
	/* XXX should not happen */
	if (p->g->sets == NULL || p->g->setbits == NULL)
		goto nomem;

	cs = &p->g->sets[no];
	cs->ptr = p->g->setbits + css*((no)/CHAR_BIT);
	cs->mask = 1 << ((no) % CHAR_BIT);
	cs->hash = 0;
	cs->smultis = 0;
	cs->multis = NULL;

	return(cs);
nomem:
	free(p->g->sets);
	p->g->sets = NULL;
	free(p->g->setbits);
	p->g->setbits = NULL;

	SETERROR(REG_ESPACE);
	/* caller's responsibility not to do set ops */
	return(NULL);
}

/*
 - freeset - free a now-unused set
 */
static void
freeset(struct parse *p, cset *cs)
{
	int i;
	cset *top = &p->g->sets[p->g->ncsets];
	size_t css = (size_t)p->g->csetsize;

	for (i = 0; i < css; i++)
		CHsub(cs, i);
	if (cs == top-1)	/* recover only the easy case */
		p->g->ncsets--;
}

/*
 - freezeset - final processing on a set of characters
 *
 * The main task here is merging identical sets.  This is usually a waste
 * of time (although the hash code minimizes the overhead), but can win
 * big if REG_ICASE is being used.  REG_ICASE, by the way, is why the hash
 * is done using addition rather than xor -- all ASCII [aA] sets xor to
 * the same value!
 */
static int			/* set number */
freezeset(struct parse *p, cset *cs)
{
	uch h = cs->hash;
	int i;
	cset *top = &p->g->sets[p->g->ncsets];
	cset *cs2;
	size_t css = (size_t)p->g->csetsize;

	/* look for an earlier one which is the same */
	for (cs2 = &p->g->sets[0]; cs2 < top; cs2++)
		if (cs2->hash == h && cs2 != cs) {
			/* maybe */
			for (i = 0; i < css; i++)
				if (!!CHIN(cs2, i) != !!CHIN(cs, i))
					break;		/* no */
			if (i == css)
				break;			/* yes */
		}

	if (cs2 < top) {	/* found one */
		freeset(p, cs);
		cs = cs2;
	}

	return((int)(cs - p->g->sets));
}

/*
 - firstch - return first character in a set (which must have at least one)
 */
static int			/* character; there is no "none" value */
firstch(struct parse *p, cset *cs)
{
	int i;
	size_t css = (size_t)p->g->csetsize;

	for (i = 0; i < css; i++)
		if (CHIN(cs, i))
			return((char)i);
	assert(never);
	return(0);		/* arbitrary */
}

/*
 - nch - number of characters in a set
 */
static int
nch(struct parse *p, cset *cs)
{
	int i;
	size_t css = (size_t)p->g->csetsize;
	int n = 0;

	for (i = 0; i < css; i++)
		if (CHIN(cs, i))
			n++;
	return(n);
}

/*
 - mcadd - add a collating element to a cset
 */
static void
mcadd( struct parse *p, cset *cs, char *cp)
{
	size_t oldend = cs->smultis;
	void *np;

	cs->smultis += strlen(cp) + 1;
	np = realloc(cs->multis, cs->smultis);
	if (np == NULL) {
		free(cs->multis);
		cs->multis = NULL;
		SETERROR(REG_ESPACE);
		return;
	}
	cs->multis = np;

	strlcpy(cs->multis + oldend - 1, cp, cs->smultis - oldend + 1);
}

/*
 - mcinvert - invert the list of collating elements in a cset
 *
 * This would have to know the set of possibilities.  Implementation
 * is deferred.
 */
static void
mcinvert(struct parse *p, cset *cs)
{
	assert(cs->multis == NULL);	/* xxx */
}

/*
 - mccase - add case counterparts of the list of collating elements in a cset
 *
 * This would have to know the set of possibilities.  Implementation
 * is deferred.
 */
static void
mccase(struct parse *p, cset *cs)
{
	assert(cs->multis == NULL);	/* xxx */
}

/*
 - isinsets - is this character in any sets?
 */
static int			/* predicate */
isinsets(struct re_guts *g, int c)
{
	uch *col;
	int i;
	int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
	unsigned uc = (uch)c;

	for (i = 0, col = g->setbits; i < ncols; i++, col += g->csetsize)
		if (col[uc] != 0)
			return(1);
	return(0);
}

/*
 - samesets - are these two characters in exactly the same sets?
 */
static int			/* predicate */
samesets(struct re_guts *g, int c1, int c2)
{
	uch *col;
	int i;
	int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
	unsigned uc1 = (uch)c1;
	unsigned uc2 = (uch)c2;

	for (i = 0, col = g->setbits; i < ncols; i++, col += g->csetsize)
		if (col[uc1] != col[uc2])
			return(0);
	return(1);
}

/*
 - categorize - sort out character categories
 */
static void
categorize(struct parse *p, struct re_guts *g)
{
	cat_t *cats = g->categories;
	int c;
	int c2;
	cat_t cat;

	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	for (c = CHAR_MIN; c <= CHAR_MAX; c++)
		if (cats[c] == 0 && isinsets(g, c)) {
			cat = g->ncategories++;
			cats[c] = cat;
			for (c2 = c+1; c2 <= CHAR_MAX; c2++)
				if (cats[c2] == 0 && samesets(g, c, c2))
					cats[c2] = cat;
		}
}

/*
 - dupl - emit a duplicate of a bunch of sops
 */
static sopno			/* start of duplicate */
dupl(struct parse *p,
    sopno start,		/* from here */
    sopno finish)		/* to this less one */
{
	sopno ret = HERE();
	sopno len = finish - start;

	assert(finish >= start);
	if (len == 0)
		return(ret);
	if (!enlarge(p, p->ssize + len)) /* this many unexpected additions */
		return(ret);
	(void) memcpy(p->strip + p->slen, p->strip + start, len * sizeof(sop));
	p->slen += len;
	return(ret);
}

/*
 - doemit - emit a strip operator
 *
 * It might seem better to implement this as a macro with a function as
 * hard-case backup, but it's just too big and messy unless there are
 * some changes to the data structures.  Maybe later.
 */
static void
doemit(struct parse *p, sop op, size_t opnd)
{
	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	/* deal with oversize operands ("can't happen", more or less) */
	assert(opnd < 1<<OPSHIFT);

	/* deal with undersized strip */
	if (p->slen >= p->ssize)
		if (!enlarge(p, (p->ssize+1) / 2 * 3))	/* +50% */
			return;

	/* finally, it's all reduced to the easy case */
	p->strip[p->slen++] = SOP(op, opnd);
}

/*
 - doinsert - insert a sop into the strip
 */
static void
doinsert(struct parse *p, sop op, size_t opnd, sopno pos)
{
	sopno sn;
	sop s;
	int i;

	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	sn = HERE();
	EMIT(op, opnd);		/* do checks, ensure space */
	assert(HERE() == sn+1);
	s = p->strip[sn];

	/* adjust paren pointers */
	assert(pos > 0);
	for (i = 1; i < NPAREN; i++) {
		if (p->pbegin[i] >= pos) {
			p->pbegin[i]++;
		}
		if (p->pend[i] >= pos) {
			p->pend[i]++;
		}
	}

	memmove((char *)&p->strip[pos+1], (char *)&p->strip[pos],
						(HERE()-pos-1)*sizeof(sop));
	p->strip[pos] = s;
}

/*
 - dofwd - complete a forward reference
 */
static void
dofwd(struct parse *p, sopno pos, sop value)
{
	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	assert(value < 1<<OPSHIFT);
	p->strip[pos] = OP(p->strip[pos]) | value;
}

/*
 - enlarge - enlarge the strip
 */
static int
enlarge(struct parse *p, sopno size)
{
	sop *sp;

	if (p->ssize >= size)
		return 1;

	sp = reallocarray(p->strip, size, sizeof(sop));
	if (sp == NULL) {
		SETERROR(REG_ESPACE);
		return 0;
	}
	p->strip = sp;
	p->ssize = size;
	return 1;
}

/*
 - stripsnug - compact the strip
 */
static void
stripsnug(struct parse *p, struct re_guts *g)
{
	g->nstates = p->slen;
	g->strip = reallocarray(p->strip, p->slen, sizeof(sop));
	if (g->strip == NULL) {
		SETERROR(REG_ESPACE);
		g->strip = p->strip;
	}
}

/*
 - findmust - fill in must and mlen with longest mandatory literal string
 *
 * This algorithm could do fancy things like analyzing the operands of |
 * for common subsequences.  Someday.  This code is simple and finds most
 * of the interesting cases.
 *
 * Note that must and mlen got initialized during setup.
 */
static void
findmust(struct parse *p, struct re_guts *g)
{
	sop *scan;
	sop *start;    /* start initialized in the default case, after that */
	sop *newstart; /* newstart was initialized in the OCHAR case */
	sopno newlen;
	sop s;
	char *cp;
	sopno i;

	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	/* find the longest OCHAR sequence in strip */
	newlen = 0;
	scan = g->strip + 1;
	do {
		s = *scan++;
		switch (OP(s)) {
		case OCHAR:		/* sequence member */
			if (newlen == 0)		/* new sequence */
				newstart = scan - 1;
			newlen++;
			break;
		case OPLUS_:		/* things that don't break one */
		case OLPAREN:
		case ORPAREN:
			break;
		case OQUEST_:		/* things that must be skipped */
		case OCH_:
			scan--;
			do {
				scan += OPND(s);
				s = *scan;
				/* assert() interferes w debug printouts */
				if (OP(s) != O_QUEST && OP(s) != O_CH &&
							OP(s) != OOR2) {
					g->iflags |= BAD;
					return;
				}
			} while (OP(s) != O_QUEST && OP(s) != O_CH);
			/* fallthrough */
		default:		/* things that break a sequence */
			if (newlen > g->mlen) {		/* ends one */
				start = newstart;
				g->mlen = newlen;
			}
			newlen = 0;
			break;
		}
	} while (OP(s) != OEND);

	if (g->mlen == 0)		/* there isn't one */
		return;

	/* turn it into a character string */
	g->must = malloc((size_t)g->mlen + 1);
	if (g->must == NULL) {		/* argh; just forget it */
		g->mlen = 0;
		return;
	}
	cp = g->must;
	scan = start;
	for (i = g->mlen; i > 0; i--) {
		while (OP(s = *scan++) != OCHAR)
			continue;
		assert(cp < g->must + g->mlen);
		*cp++ = (char)OPND(s);
	}
	assert(cp == g->must + g->mlen);
	*cp++ = '\0';		/* just on general principles */
}

/*
 - pluscount - count + nesting
 */
static sopno			/* nesting depth */
pluscount(struct parse *p, struct re_guts *g)
{
	sop *scan;
	sop s;
	sopno plusnest = 0;
	sopno maxnest = 0;

	if (p->error != 0)
		return(0);	/* there may not be an OEND */

	scan = g->strip + 1;
	do {
		s = *scan++;
		switch (OP(s)) {
		case OPLUS_:
			plusnest++;
			break;
		case O_PLUS:
			if (plusnest > maxnest)
				maxnest = plusnest;
			plusnest--;
			break;
		}
	} while (OP(s) != OEND);
	if (plusnest != 0)
		g->iflags |= BAD;
	return(maxnest);
}
@


1.30
log
@Adopt relevant part of NetBSD's r1.7 commit to discard unused results of the
expressions generated by the REQUIRE() macro. Thus eliminating from build
output 100 lines or so of gcc complaints about "computed but not used".

cluebat & ok tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.29 2016/09/21 04:38:56 guenther Exp $ */
a127 3
#define	MUSTSEE(c, e)	(REQUIRE(MORE() && PEEK() == (c), e))
#define	MUSTEAT(c, e)	(REQUIRE(MORE() && GETNEXT() == (c), e))
#define	MUSTNOTSEE(c, e)	(REQUIRE(!MORE() || PEEK() != (c), e))
d317 1
a317 1
		MUSTEAT(')', REG_EPAREN);
d648 1
a648 1
	MUSTEAT(']', REG_EBRACK);
@


1.29
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.28 2015/12/28 22:08:18 mmcc Exp $ */
d127 1
a127 1
#define	REQUIRE(co, e)	((co) || SETERROR(e))
@


1.28
log
@Remove NULL-checks before free() and a few related dead assignments.

ok and valuable input from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.27 2015/11/01 03:45:29 guenther Exp $ */
d1297 1
a1297 2
	(void) memcpy((char *)(p->strip + p->slen),
		(char *)(p->strip + start), (size_t)len*sizeof(sop));
@


1.27
log
@delete old lint ARGSUSED comments
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.26 2014/10/18 04:12:28 deraadt Exp $ */
d1187 1
a1187 2
		if (cs->multis)
			free(cs->multis);
@


1.26
log
@reallocarray() -- a little tricky to review
ok doug millert
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.25 2014/09/08 15:45:20 tedu Exp $ */
a1203 1
/* ARGSUSED */
a1215 1
/* ARGSUSED */
@


1.25
log
@add \<word\> support to regcomp. prompted by renewed interest from jsg
because such support is reportedly common and in somewhat wide use.
undocumented for now because we don't endorse this.
ok jsg millert
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.24 2014/05/06 15:48:38 tedu Exp $ */
a1049 1
		nbytes = nc / CHAR_BIT * css;
d1056 1
a1056 1
		ptr = realloc(p->g->setbits, nbytes);
d1059 1
@


1.24
log
@reallocarray for things which are arrays. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.23 2013/11/26 13:16:18 deraadt Exp $ */
d84 1
d353 1
a353 1
		ordinary(p, c);
d505 6
d902 19
@


1.23
log
@unsigned char cast for ctype; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.22 2013/04/17 17:39:29 tedu Exp $ */
d174 1
a174 1
	g = (struct re_guts *)malloc(sizeof(struct re_guts));
d178 1
a178 1
	p->strip = (sop *)calloc(p->ssize, sizeof(sop));
d181 1
a181 1
		free((char *)g);
d1026 1
a1026 1
		ptr = (cset *)realloc((char *)p->g->sets, nc * sizeof(cset));
d1031 1
a1031 1
		ptr = (uch *)realloc((char *)p->g->setbits, nbytes);
d1366 1
a1366 1
	sp = (sop *)realloc(p->strip, size*sizeof(sop));
d1383 1
a1383 1
	g->strip = (sop *)realloc((char *)p->strip, p->slen * sizeof(sop));
@


1.22
log
@silence some warnings by adding prototypes, casts, and headers as
appropriate. in regex, stop using the struct hack for a fixed size array
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.21 2011/11/07 09:58:27 otto Exp $ */
d762 1
a762 1
	while (MORE() && isalpha(PEEK()))
@


1.21
log
@don't handle out-of-mem conditions using compiled out asserts (ugh). From
netbsd; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.20 2010/11/21 00:02:30 tedu Exp $ */
d174 1
a174 2
	g = (struct re_guts *)malloc(sizeof(struct re_guts) +
							(NC-1)*sizeof(cat_t));
d208 1
a208 1
	(void) memset((char *)g->catspace, 0, NC*sizeof(cat_t));
@


1.20
log
@the posix regex mistake is here to stay. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.19 2008/02/23 08:13:07 otto Exp $ */
d102 1
a102 1
static void enlarge(struct parse *, sopno);
d1273 2
a1274 2
	enlarge(p, p->ssize + len);	/* this many unexpected additions */
	assert(p->ssize >= p->slen + len);
d1300 2
a1301 2
		enlarge(p, (p->ssize+1) / 2 * 3);	/* +50% */
	assert(p->slen < p->ssize);
d1359 1
a1359 1
static void
d1365 1
a1365 1
		return;
d1370 1
a1370 1
		return;
d1374 1
@


1.19
log
@if the first call to allocset() fails, the second might deref a NULL
pointer, so add a safety-net. From Gianluigi Tiesi via Torok Edwin.
ok chl@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.18 2007/10/10 21:23:44 chl Exp $ */
a321 12
#ifndef POSIX_MISTAKE
	case ')':		/* happens only if no current unmatched ( */
		/*
		 * You may ask, why the ifndef?  Because I didn't notice
		 * this until slightly too late for 1003.2, and none of the
		 * other 1003.2 regular-expression reviewers noticed it at
		 * all.  So an unmatched ) is legal POSIX, at least until
		 * we can get it fixed.
		 */
		SETERROR(REG_EPAREN);
		break;
#endif
@


1.18
log
@add a proper test around allocset
use a simpler way to allocated memory in allocset, mostly done by
replacing malloc/realloc dance, by only one realloc
add comments about variables that are not used uninitialized, even
if gcc told the contrary
another malloc/realloc -> realloc change

Work initially started by otto@@, and then I joined him
ok otto@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.17 2007/09/02 15:19:17 deraadt Exp $ */
d1054 3
@


1.17
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.16 2006/03/31 05:36:36 deraadt Exp $ */
d642 4
a645 1
	cs = allocset(p);
d1032 2
d1038 8
a1045 13
		if (p->g->sets == NULL)
			p->g->sets = (cset *)calloc(nc, sizeof(cset));
		else {
			cset *ptr;
			ptr = (cset *)realloc((char *)p->g->sets,
			    nc * sizeof(cset));
			if (ptr == NULL) {
				free(p->g->sets);
				p->g->sets = NULL;
			} else
				p->g->sets = ptr;
		}
		if (p->g->sets == NULL)
d1047 1
d1049 2
a1050 17
		if (p->g->setbits == NULL)
			p->g->setbits = (uch *)malloc(nbytes);
		else {
			uch *ptr;

			ptr = (uch *)realloc((char *)p->g->setbits, nbytes);
			if (ptr == NULL) {
				free(p->g->setbits);
				p->g->setbits = NULL;
			} else {
				p->g->setbits = ptr;

				for (i = 0; i < no; i++)
					p->g->sets[i].ptr = p->g->setbits +
					    css*(i/CHAR_BIT);
			}
		}
d1052 1
a1052 8
		if (p->g->sets == NULL || p->g->setbits == NULL) {
nomem:
			no = 0;
			SETERROR(REG_ESPACE);
			/* caller's responsibility not to do set ops */
		} else
			(void) memset((char *)p->g->setbits + (nbytes - css),
			    0, css);
d1055 2
a1056 5
	assert(p->g->sets != NULL);	/* xxx */
	if (p->g->sets != NULL && p->g->setbits != NULL) {
		cs = &p->g->sets[no];
		cs->ptr = p->g->setbits + css*((no)/CHAR_BIT);
	}
d1063 9
d1169 1
a1169 4
	if (cs->multis == NULL)
		np = malloc(cs->smultis);
	else
		np = realloc(cs->multis, cs->smultis);
d1412 2
a1413 2
	sop *start;
	sop *newstart;
@


1.16
log
@(char)to{upper,lower}()
@
text
@d1 1
a1 1
/*	$OpenBSD: regcomp.c,v 1.15 2005/08/05 13:03:00 espie Exp $ */
d179 1
a179 1
	p->strip = (sop *)malloc(p->ssize * sizeof(sop));
d1034 1
a1034 1
			p->g->sets = (cset *)malloc(nc * sizeof(cset));
@


1.15
log
@zap rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d859 1
a859 1
		return(tolower(ch));
d861 1
a861 1
		return(toupper(ch));
@


1.14
log
@remove useless comments, once used for header file generation and delete
parameter names from prototypes. ok millert@@
@
text
@d1 1
a35 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)regcomp.c	8.5 (Berkeley) 3/20/94";
#else
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.13 2004/10/17 17:58:54 otto Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.13
log
@ansify and deregister; no change in obj code. ok millert@@
@
text
@d40 1
a40 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.12 2004/05/08 06:33:41 otto Exp $";
d76 37
a112 48
/* ========= begin header generated by ./mkh ========= */
#ifdef __cplusplus
extern "C" {
#endif

/* === regcomp.c === */
static void p_ere(struct parse *p, int stop);
static void p_ere_exp(struct parse *p);
static void p_str(struct parse *p);
static void p_bre(struct parse *p, int end1, int end2);
static int p_simp_re(struct parse *p, int starordinary);
static int p_count(struct parse *p);
static void p_bracket(struct parse *p);
static void p_b_term(struct parse *p, cset *cs);
static void p_b_cclass(struct parse *p, cset *cs);
static void p_b_eclass(struct parse *p, cset *cs);
static char p_b_symbol(struct parse *p);
static char p_b_coll_elem(struct parse *p, int endc);
static char othercase(int ch);
static void bothcases(struct parse *p, int ch);
static void ordinary(struct parse *p, int ch);
static void nonnewline(struct parse *p);
static void repeat(struct parse *p, sopno start, int from, int to);
static int seterr(struct parse *p, int e);
static cset *allocset(struct parse *p);
static void freeset(struct parse *p, cset *cs);
static int freezeset(struct parse *p, cset *cs);
static int firstch(struct parse *p, cset *cs);
static int nch(struct parse *p, cset *cs);
static void mcadd(struct parse *p, cset *cs, char *cp);
static void mcinvert(struct parse *p, cset *cs);
static void mccase(struct parse *p, cset *cs);
static int isinsets(struct re_guts *g, int c);
static int samesets(struct re_guts *g, int c1, int c2);
static void categorize(struct parse *p, struct re_guts *g);
static sopno dupl(struct parse *p, sopno start, sopno finish);
static void doemit(struct parse *p, sop op, size_t opnd);
static void doinsert(struct parse *p, sop op, size_t opnd, sopno pos);
static void dofwd(struct parse *p, sopno pos, sop value);
static void enlarge(struct parse *p, sopno size);
static void stripsnug(struct parse *p, struct re_guts *g);
static void findmust(struct parse *p, struct re_guts *g);
static sopno pluscount(struct parse *p, struct re_guts *g);

#ifdef __cplusplus
}
#endif
/* ========= end header generated by ./mkh ========= */
a153 9
 = extern int regcomp(regex_t *, const char *, int);
 = #define	REG_BASIC	0000
 = #define	REG_EXTENDED	0001
 = #define	REG_ICASE	0002
 = #define	REG_NOSUB	0004
 = #define	REG_NEWLINE	0010
 = #define	REG_NOSPEC	0020
 = #define	REG_PEND	0040
 = #define	REG_DUMP	0200
a253 1
 == static void p_ere(struct parse *p, int stop);
a296 1
 == static void p_ere_exp(struct parse *p);
a443 1
 == static void p_str(struct parse *p);
a454 2
 == static void p_bre(struct parse *p, int end1, \
 ==	int end2);
a492 1
 == static int p_simp_re(struct parse *p, int starordinary);
a608 1
 == static int p_count(struct parse *p);
a626 1
 == static void p_bracket(struct parse *p);
a705 1
 == static void p_b_term(struct parse *p, cset *cs);
a768 1
 == static void p_b_cclass(struct parse *p, cset *cs);
a799 1
 == static void p_b_eclass(struct parse *p, cset *cs);
a813 1
 == static char p_b_symbol(struct parse *p);
a831 1
 == static char p_b_coll_elem(struct parse *p, int endc);
a858 1
 == static char othercase(int ch);
a874 1
 == static void bothcases(struct parse *p, int ch);
a899 1
 == static void ordinary(struct parse *p, int ch);
a916 1
 == static void nonnewline(struct parse *p);
a940 1
 == static void repeat(struct parse *p, sopno start, int from, int to);
a1010 1
 == static int seterr(struct parse *p, int e);
a1023 1
 == static cset *allocset(struct parse *p);
a1097 1
 == static void freeset(struct parse *p, cset *cs);
a1113 1
 == static int freezeset(struct parse *p, cset *cs);
a1150 1
 == static int firstch(struct parse *p, cset *cs);
a1166 1
 == static int nch(struct parse *p, cset *cs);
a1182 2
 == static void mcadd(struct parse *p, cset *cs, \
 ==	char *cp);
a1208 1
 == static void mcinvert(struct parse *p, cset *cs);
a1221 1
 == static void mccase(struct parse *p, cset *cs);
a1234 1
 == static int isinsets(struct re_guts *g, int c);
a1251 1
 == static int samesets(struct re_guts *g, int c1, int c2);
a1269 1
 == static void categorize(struct parse *p, struct re_guts *g);
a1294 1
 == static sopno dupl(struct parse *p, sopno start, sopno finish);
a1316 1
 == static void doemit(struct parse *p, sop op, size_t opnd);
a1342 1
 == static void doinsert(struct parse *p, sop op, size_t opnd, sopno pos);
a1377 1
 == static void dofwd(struct parse *p, sopno pos, sop value);
a1391 1
 == static void enlarge(struct parse *p, sopno size);
a1411 1
 == static void stripsnug(struct parse *p, struct re_guts *g);
a1425 1
 == static void findmust(struct parse *p, struct re_guts *g);
a1509 1
 == static sopno pluscount(struct parse *p, struct re_guts *g);
@


1.12
log
@When parsing what follows [, do not allocate memory that is not used,
also fix a memory leak in error path.

ok millert@@
@
text
@d40 1
a40 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.11 2003/12/07 06:17:17 otto Exp $";
d176 1
a176 4
regcomp(preg, pattern, cflags)
regex_t *preg;
const char *pattern;
int cflags;
d179 4
a182 4
	register struct re_guts *g;
	register struct parse *p = &pa;
	register int i;
	register size_t len;
d274 1
a274 1
 == static void p_ere(register struct parse *p, int stop);
d277 7
a283 9
p_ere(p, stop)
register struct parse *p;
int stop;			/* character this ERE should end at */
{
	register char c;
	register sopno prevback;
	register sopno prevfwd;
	register sopno conc;
	register int first = 1;		/* is this the first alternative? */
d318 1
a318 1
 == static void p_ere_exp(register struct parse *p);
d321 1
a321 2
p_ere_exp(p)
register struct parse *p;
d323 5
a327 5
	register char c;
	register sopno pos;
	register int count;
	register int count2;
	register sopno subno;
d466 1
a466 1
 == static void p_str(register struct parse *p);
d469 1
a469 2
p_str(p)
register struct parse *p;
d478 2
a479 2
 == static void p_bre(register struct parse *p, register int end1, \
 ==	register int end2);
d489 7
a495 8
p_bre(p, end1, end2)
register struct parse *p;
register int end1;		/* first terminating character */
register int end2;		/* second terminating character */
{
	register sopno start = HERE();
	register int first = 1;			/* first subexpression? */
	register int wasdollar = 0;
d518 1
a518 1
 == static int p_simp_re(register struct parse *p, int starordinary);
d521 9
a529 10
p_simp_re(p, starordinary)
register struct parse *p;
int starordinary;		/* is a leading * an ordinary character? */
{
	register int c;
	register int count;
	register int count2;
	register sopno pos;
	register int i;
	register sopno subno;
d635 1
a635 1
 == static int p_count(register struct parse *p);
d638 1
a638 2
p_count(p)
register struct parse *p;
d640 2
a641 2
	register int count = 0;
	register int ndigits = 0;
d654 1
a654 1
 == static void p_bracket(register struct parse *p);
d660 1
a660 2
p_bracket(p)
register struct parse *p;
d662 2
a663 2
	register cset *cs;
	register int invert = 0;
d697 2
a698 2
		register int i;
		register int ci;
d710 1
a710 1
		register int i;
d734 1
a734 1
 == static void p_b_term(register struct parse *p, register cset *cs);
d737 1
a737 3
p_b_term(p, cs)
register struct parse *p;
register cset *cs;
d739 3
a741 3
	register char c;
	register char start, finish;
	register int i;
d798 1
a798 1
 == static void p_b_cclass(register struct parse *p, register cset *cs);
d801 7
a807 9
p_b_cclass(p, cs)
register struct parse *p;
register cset *cs;
{
	register char *sp = p->next;
	register struct cclass *cp;
	register size_t len;
	register char *u;
	register char c;
d830 1
a830 1
 == static void p_b_eclass(register struct parse *p, register cset *cs);
d835 1
a835 3
p_b_eclass(p, cs)
register struct parse *p;
register cset *cs;
d837 1
a837 1
	register char c;
d845 1
a845 1
 == static char p_b_symbol(register struct parse *p);
d848 1
a848 2
p_b_symbol(p)
register struct parse *p;
d850 1
a850 1
	register char value;
d864 1
a864 1
 == static char p_b_coll_elem(register struct parse *p, int endc);
d867 6
a872 7
p_b_coll_elem(p, endc)
register struct parse *p;
int endc;			/* name ended by endc,']' */
{
	register char *sp = p->next;
	register struct cname *cp;
	register int len;
d895 1
a895 2
othercase(ch)
int ch;
d909 1
a909 1
 == static void bothcases(register struct parse *p, int ch);
d914 1
a914 3
bothcases(p, ch)
register struct parse *p;
int ch;
d916 2
a917 2
	register char *oldnext = p->next;
	register char *oldend = p->end;
d935 1
a935 1
 == static void ordinary(register struct parse *p, register int ch);
d938 1
a938 3
ordinary(p, ch)
register struct parse *p;
register int ch;
d940 1
a940 1
	register cat_t *cap = p->g->categories;
d953 1
a953 1
 == static void nonnewline(register struct parse *p);
d958 1
a958 2
nonnewline(p)
register struct parse *p;
d960 2
a961 2
	register char *oldnext = p->next;
	register char *oldend = p->end;
d978 1
a978 1
 == static void repeat(register struct parse *p, sopno start, int from, int to);
d981 4
a984 5
repeat(p, start, from, to)
register struct parse *p;
sopno start;			/* operand from here to end of strip */
int from;			/* repeated from this number */
int to;				/* to this number of times (maybe INFINITY) */
d986 1
a986 1
	register sopno finish = HERE();
d991 1
a991 1
	register sopno copy;
d1049 1
a1049 1
 == static int seterr(register struct parse *p, int e);
d1052 1
a1052 3
seterr(p, e)
register struct parse *p;
int e;
d1063 1
a1063 1
 == static cset *allocset(register struct parse *p);
d1066 1
a1066 2
allocset(p)
register struct parse *p;
d1068 6
a1073 6
	register int no = p->g->ncsets++;
	register size_t nc;
	register size_t nbytes;
	register cset *cs;
	register size_t css = (size_t)p->g->csetsize;
	register int i;
d1138 1
a1138 1
 == static void freeset(register struct parse *p, register cset *cs);
d1141 1
a1141 3
freeset(p, cs)
register struct parse *p;
register cset *cs;
d1143 3
a1145 3
	register int i;
	register cset *top = &p->g->sets[p->g->ncsets];
	register size_t css = (size_t)p->g->csetsize;
d1155 1
a1155 1
 == static int freezeset(register struct parse *p, register cset *cs);
d1164 7
a1170 9
freezeset(p, cs)
register struct parse *p;
register cset *cs;
{
	register uch h = cs->hash;
	register int i;
	register cset *top = &p->g->sets[p->g->ncsets];
	register cset *cs2;
	register size_t css = (size_t)p->g->csetsize;
d1193 1
a1193 1
 == static int firstch(register struct parse *p, register cset *cs);
d1196 1
a1196 3
firstch(p, cs)
register struct parse *p;
register cset *cs;
d1198 2
a1199 2
	register int i;
	register size_t css = (size_t)p->g->csetsize;
d1210 1
a1210 1
 == static int nch(register struct parse *p, register cset *cs);
d1213 5
a1217 7
nch(p, cs)
register struct parse *p;
register cset *cs;
{
	register int i;
	register size_t css = (size_t)p->g->csetsize;
	register int n = 0;
d1227 2
a1228 2
 == static void mcadd(register struct parse *p, register cset *cs, \
 ==	register char *cp);
d1231 1
a1231 4
mcadd(p, cs, cp)
register struct parse *p;
register cset *cs;
register char *cp;
d1233 1
a1233 1
	register size_t oldend = cs->smultis;
d1255 1
a1255 1
 == static void mcinvert(register struct parse *p, register cset *cs);
d1262 1
a1262 3
mcinvert(p, cs)
register struct parse *p;
register cset *cs;
d1269 1
a1269 1
 == static void mccase(register struct parse *p, register cset *cs);
d1276 1
a1276 3
mccase(p, cs)
register struct parse *p;
register cset *cs;
d1283 1
a1283 1
 == static int isinsets(register struct re_guts *g, int c);
d1286 6
a1291 8
isinsets(g, c)
register struct re_guts *g;
int c;
{
	register uch *col;
	register int i;
	register int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
	register unsigned uc = (uch)c;
d1301 1
a1301 1
 == static int samesets(register struct re_guts *g, int c1, int c2);
d1304 7
a1310 10
samesets(g, c1, c2)
register struct re_guts *g;
int c1;
int c2;
{
	register uch *col;
	register int i;
	register int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
	register unsigned uc1 = (uch)c1;
	register unsigned uc2 = (uch)c2;
d1320 1
a1320 1
 == static void categorize(struct parse *p, register struct re_guts *g);
d1323 1
a1323 3
categorize(p, g)
struct parse *p;
register struct re_guts *g;
d1325 4
a1328 4
	register cat_t *cats = g->categories;
	register int c;
	register int c2;
	register cat_t cat;
d1346 1
a1346 1
 == static sopno dupl(register struct parse *p, sopno start, sopno finish);
d1349 3
a1351 4
dupl(p, start, finish)
register struct parse *p;
sopno start;			/* from here */
sopno finish;			/* to this less one */
d1353 2
a1354 2
	register sopno ret = HERE();
	register sopno len = finish - start;
d1369 1
a1369 1
 == static void doemit(register struct parse *p, sop op, size_t opnd);
d1376 1
a1376 4
doemit(p, op, opnd)
register struct parse *p;
sop op;
size_t opnd;
d1396 1
a1396 1
 == static void doinsert(register struct parse *p, sop op, size_t opnd, sopno pos);
d1399 5
a1403 9
doinsert(p, op, opnd, pos)
register struct parse *p;
sop op;
size_t opnd;
sopno pos;
{
	register sopno sn;
	register sop s;
	register int i;
d1432 1
a1432 1
 == static void dofwd(register struct parse *p, sopno pos, sop value);
d1435 1
a1435 4
dofwd(p, pos, value)
register struct parse *p;
register sopno pos;
sop value;
d1447 1
a1447 1
 == static void enlarge(register struct parse *p, sopno size);
d1450 1
a1450 3
enlarge(p, size)
register struct parse *p;
register sopno size;
d1452 1
a1452 1
	register sop *sp;
d1468 1
a1468 1
 == static void stripsnug(register struct parse *p, register struct re_guts *g);
d1471 1
a1471 3
stripsnug(p, g)
register struct parse *p;
register struct re_guts *g;
d1483 1
a1483 1
 == static void findmust(register struct parse *p, register struct re_guts *g);
d1492 1
a1492 3
findmust(p, g)
struct parse *p;
register struct re_guts *g;
d1494 1
a1494 1
	register sop *scan;
d1496 5
a1500 5
	register sop *newstart;
	register sopno newlen;
	register sop s;
	register char *cp;
	register sopno i;
d1568 1
a1568 1
 == static sopno pluscount(register struct parse *p, register struct re_guts *g);
d1571 6
a1576 8
pluscount(p, g)
struct parse *p;
register struct re_guts *g;
{
	register sop *scan;
	register sop s;
	register sopno plusnest = 0;
	register sopno maxnest = 0;
@


1.11
log
@Unbreak handling of non-ASCII chars. Fixes PR 3594. From FreeBSD
regcmp.c rev 1.13.

ok deraadt@@
@
text
@d40 1
a40 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.10 2003/06/02 20:18:36 millert Exp $";
d673 1
a673 1
	register cset *cs = allocset(p);
d688 2
d702 2
a703 1
	if (p->error != 0)	/* don't mess things up further */
d705 1
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d40 1
a40 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.9 2003/04/05 00:43:20 tdeval Exp $";
d403 1
a403 1
		REQUIRE(!MORE() || !isdigit(PEEK()), REG_BADRPT);
d415 1
a415 1
				(c == '{' && MORE2() && isdigit(PEEK2())) ))
d444 1
a444 1
			if (isdigit(PEEK())) {
d465 1
a465 1
				(c == '{' && MORE2() && isdigit(PEEK2())) ) )
d547 1
a547 1
		c = BACKSL | (unsigned char)GETNEXT();
d609 1
a609 1
		ordinary(p, c &~ BACKSL);
d622 1
a622 1
			if (MORE() && isdigit(PEEK())) {
d636 1
a636 1
	} else if (c == (unsigned char)'$')	/* $ (but not \$) ends it */
d653 1
a653 1
	while (MORE() && isdigit(PEEK()) && count <= DUPMAX) {
d913 1
d938 1
d962 1
a962 1
	if ((p->g->cflags&REG_ICASE) && isalpha(ch) && othercase(ch) != ch)
d965 1
a965 1
		EMIT(OCHAR, (unsigned char)ch);
d1333 1
a1333 1
	register unsigned uc = (unsigned char)c;
d1354 2
a1355 2
	register unsigned uc1 = (unsigned char)c1;
	register unsigned uc2 = (unsigned char)c2;
@


1.9
log
@strcpy/strcat -> strlcpy/strlcat
ok tedu@@, hints by deraadt@@ and millert@@
@
text
@d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.8 2002/02/16 21:27:24 millert Exp $";
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d44 1
a44 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.7 2001/11/01 23:27:28 deraadt Exp $";
d1288 1
a1288 2
	(void) strcpy(cs->multis + oldend - 1, cp);
	cs->multis[cs->smultis - 1] = '\0';
@


1.7
log
@much greater care for malloc & realloc failures; millert ok
@
text
@d44 1
a44 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.6 1998/08/14 21:39:35 deraadt Exp $";
d86 37
a122 37
static void p_ere __P((struct parse *p, int stop));
static void p_ere_exp __P((struct parse *p));
static void p_str __P((struct parse *p));
static void p_bre __P((struct parse *p, int end1, int end2));
static int p_simp_re __P((struct parse *p, int starordinary));
static int p_count __P((struct parse *p));
static void p_bracket __P((struct parse *p));
static void p_b_term __P((struct parse *p, cset *cs));
static void p_b_cclass __P((struct parse *p, cset *cs));
static void p_b_eclass __P((struct parse *p, cset *cs));
static char p_b_symbol __P((struct parse *p));
static char p_b_coll_elem __P((struct parse *p, int endc));
static char othercase __P((int ch));
static void bothcases __P((struct parse *p, int ch));
static void ordinary __P((struct parse *p, int ch));
static void nonnewline __P((struct parse *p));
static void repeat __P((struct parse *p, sopno start, int from, int to));
static int seterr __P((struct parse *p, int e));
static cset *allocset __P((struct parse *p));
static void freeset __P((struct parse *p, cset *cs));
static int freezeset __P((struct parse *p, cset *cs));
static int firstch __P((struct parse *p, cset *cs));
static int nch __P((struct parse *p, cset *cs));
static void mcadd __P((struct parse *p, cset *cs, char *cp));
static void mcinvert __P((struct parse *p, cset *cs));
static void mccase __P((struct parse *p, cset *cs));
static int isinsets __P((struct re_guts *g, int c));
static int samesets __P((struct re_guts *g, int c1, int c2));
static void categorize __P((struct parse *p, struct re_guts *g));
static sopno dupl __P((struct parse *p, sopno start, sopno finish));
static void doemit __P((struct parse *p, sop op, size_t opnd));
static void doinsert __P((struct parse *p, sop op, size_t opnd, sopno pos));
static void dofwd __P((struct parse *p, sopno pos, sop value));
static void enlarge __P((struct parse *p, sopno size));
static void stripsnug __P((struct parse *p, struct re_guts *g));
static void findmust __P((struct parse *p, struct re_guts *g));
static sopno pluscount __P((struct parse *p, struct re_guts *g));
@


1.6
log
@realloc repair
@
text
@d44 1
a44 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.5 1997/04/30 05:51:09 tholo Exp $";
d1109 13
a1121 3
		else
			p->g->sets = (cset *)realloc((char *)p->g->sets,
							nc * sizeof(cset));
d1125 13
a1137 5
			p->g->setbits = (uch *)realloc((char *)p->g->setbits,
								nbytes);
			/* xxx this isn't right if setbits is now NULL */
			for (i = 0; i < no; i++)
				p->g->sets[i].ptr = p->g->setbits + css*(i/CHAR_BIT);
d1139 3
a1141 4
		if (p->g->sets != NULL && p->g->setbits != NULL)
			(void) memset((char *)p->g->setbits + (nbytes - css),
								0, css);
		else {
d1145 3
a1147 1
		}
d1151 4
a1154 2
	cs = &p->g->sets[no];
	cs->ptr = p->g->setbits + css*((no)/CHAR_BIT);
@


1.5
log
@Remove dead code and variables
@
text
@d44 1
a44 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.4 1997/04/28 20:44:59 millert Exp $";
d1251 1
d1255 1
a1255 1
		cs->multis = malloc(cs->smultis);
d1257 5
a1261 2
		cs->multis = realloc(cs->multis, cs->smultis);
	if (cs->multis == NULL) {
d1265 1
@


1.4
log
@- cast usages of *printf() to void since we don't check return val
- move an assert to be *before* a strcpy() where it can do some good.
- integrate NetBSD fixes for 64-bit machines (NetBSD PR #3450, Ross Harvey)
- add lite2 tags
@
text
@d44 1
a44 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.3 1996/09/15 09:31:25 tholo Exp $";
a109 1
static char *mcfind __P((cset *cs, char *cp));
a1263 19
}

/*
 - mcfind - find a collating element in a cset
 == static char *mcfind(register cset *cs, register char *cp);
 */
static char *
mcfind(cs, cp)
register cset *cs;
register char *cp;
{
	register char *p;

	if (cs->multis == NULL)
		return(NULL);
	for (p = cs->multis; *p != '\0'; p += strlen(p) + 1)
		if (strcmp(cp, p) == 0)
			return(p);
	return(NULL);
@


1.3
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d36 2
d41 5
a45 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.2 1996/08/19 08:31:10 tholo Exp $";
d110 1
d1265 19
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d39 1
a39 1
static char rcsid[] = "$OpenBSD: regcomp.c,v 1.6 1995/02/27 13:29:01 cgd Exp $";
a103 3
static void mcsub __P((cset *cs, char *cp));
static int mcin __P((cset *cs, char *cp));
static char *mcfind __P((cset *cs, char *cp));
a670 1
	register char c;
a885 1
	register char c;
a1260 58
 - mcsub - subtract a collating element from a cset
 == static void mcsub(register cset *cs, register char *cp);
 */
static void
mcsub(cs, cp)
register cset *cs;
register char *cp;
{
	register char *fp = mcfind(cs, cp);
	register size_t len = strlen(fp);

	assert(fp != NULL);
	(void) memmove(fp, fp + len + 1,
				cs->smultis - (fp + len + 1 - cs->multis));
	cs->smultis -= len;

	if (cs->smultis == 0) {
		free(cs->multis);
		cs->multis = NULL;
		return;
	}

	cs->multis = realloc(cs->multis, cs->smultis);
	assert(cs->multis != NULL);
}

/*
 - mcin - is a collating element in a cset?
 == static int mcin(register cset *cs, register char *cp);
 */
static int
mcin(cs, cp)
register cset *cs;
register char *cp;
{
	return(mcfind(cs, cp) != NULL);
}

/*
 - mcfind - find a collating element in a cset
 == static char *mcfind(register cset *cs, register char *cp);
 */
static char *
mcfind(cs, cp)
register cset *cs;
register char *cp;
{
	register char *p;

	if (cs->multis == NULL)
		return(NULL);
	for (p = cs->multis; *p != '\0'; p += strlen(p) + 1)
		if (strcmp(cp, p) == 0)
			return(p);
	return(NULL);
}

/*
d1267 1
d1283 1
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: regcomp.c,v 1.6 1995/02/27 13:29:01 cgd Exp $	*/

a35 2
 *
 *	@@(#)regcomp.c	8.5 (Berkeley) 3/20/94
d39 1
a39 5
#if 0
static char sccsid[] = "@@(#)regcomp.c	8.5 (Berkeley) 3/20/94";
#else
static char rcsid[] = "$NetBSD: regcomp.c,v 1.6 1995/02/27 13:29:01 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
