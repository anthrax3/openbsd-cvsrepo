head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.4
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.25.0.6
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.14
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.12
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.8
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.16
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2017.09.05.03.16.13;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	ngpX0SPDX30tzjDf;

1.26
date	2017.08.05.15.16.32;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	OlemQmHeQF93n0Vu;

1.25
date	2016.05.23.00.05.15;	author guenther;	state Exp;
branches;
next	1.24;
commitid	93KfkbbTTGrOENTw;

1.24
date	2015.09.14.12.21.03;	author guenther;	state Exp;
branches;
next	1.23;
commitid	r2G6Pc81mZSKzBEM;

1.23
date	2015.08.14.14.30.40;	author stsp;	state Exp;
branches;
next	1.22;
commitid	xavJJXo5vDYqtbjp;

1.22
date	2015.07.02.16.07.43;	author semarie;	state Exp;
branches;
next	1.21;
commitid	3STRbVmwbMHrmqaG;

1.21
date	2015.06.09.20.04.04;	author stsp;	state Exp;
branches;
next	1.20;
commitid	jT8rVFyNjR2M4ZuY;

1.20
date	2013.08.28.16.53.34;	author stsp;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.01.20.02.53;	author stsp;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.15.22.27.48;	author stsp;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.28.10.24.38;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.17.07.07.23;	author moritz;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.06.08.26.12;	author moritz;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.08.08.05.35;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.08.05.53.01;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.23.21.13.28;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.20.18.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.17.07.45.35;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.17.05.50.51;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.27.00.58.54;	author lebel;	state Exp;
branches;
next	1.6;

1.6
date	97.07.09.01.08.21;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.10.29.03.22.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.09.31.14;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.26.00.17.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.28.24;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@New POSIX xlocale implementation written from scratch.
Complete in the sense that all POSIX *locale(3) and *_l(3) functions
are included, but in OpenBSD, we of course only really care about
LC_CTYPE and we only support ASCII and UTF-8.

With important help from kettenis@@, guenther@@, and jca@@.
Repeated testing in ports bulk builds by naddy@@.
Additional testing by jca@@, sebastia@@, dcoppa@@, and others.
OK kettenis@@ dcoppa@@, and guenther@@ on an earlier version.
Riding guenther@@'s libc/librthread major bump.
@
text
@/*	$OpenBSD: setlocale.c,v 1.26 2017/08/05 15:16:32 schwarze Exp $	*/
/*
 * Copyright (c) 2017 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <locale.h>
#include <stdlib.h>
#include <string.h>

#include "rune.h"

static void
freegl(char **oldgl)
{
	int ic;

	if (oldgl == NULL)
		return;
	for (ic = LC_ALL; ic < _LC_LAST; ic++)
		free(oldgl[ic]);
	free(oldgl);
}

static char **
dupgl(char **oldgl)
{
	char **newgl;
	int ic;

	if ((newgl = calloc(_LC_LAST, sizeof(*newgl))) == NULL)	
		return NULL;
	for (ic = LC_ALL; ic < _LC_LAST; ic++) {
		if ((newgl[ic] = strdup(oldgl != NULL ?
		    oldgl[ic] : ic == LC_ALL ? "" : "C")) == NULL) {
			freegl(newgl);
			return NULL;
		}
	}
	return newgl;
}

static int
changegl(int category, const char *locname, char **gl)
{
	char *cp;

	if ((locname = _get_locname(category, locname)) == NULL ||
	    (cp = strdup(locname)) == NULL)
		return -1;

	free(gl[category]);
	gl[category] = cp;
	return 0;
}

char *
setlocale(int category, const char *locname)
{
	/*
	 * Even though only LC_CTYPE has any effect in the OpenBSD
	 * base system, store complete information about the global
	 * locale, such that third-party software can access it,
	 * both via setlocale(3) and via locale(1).
	 */
	static char	  global_locname[256];
	static char	**global_locale;

	char **newgl, *firstname, *nextname;
	int ic;

	if (category < LC_ALL || category >= _LC_LAST)
		return NULL;

	/*
	 * Change the global locale.
	 */
	if (locname != NULL) {
		if ((newgl = dupgl(global_locale)) == NULL)
			return NULL;
		if (category == LC_ALL && strchr(locname, '/') != NULL) {

			/* One value for each category. */
			if ((firstname = strdup(locname)) == NULL)
				return NULL;
			nextname = firstname;
			for (ic = 1; ic < _LC_LAST; ic++)
				if (nextname == NULL || changegl(ic,
				    strsep(&nextname, "/"), newgl) == -1)
					break;
			free(firstname);
			if (ic < _LC_LAST || nextname != NULL) {
				freegl(newgl);
				return NULL;
			}
		} else {

			/* One value only. */
			if (changegl(category, locname, newgl) == -1) {
				freegl(newgl);
				return NULL;
			}

			/* One common value for all categories. */
			if (category == LC_ALL) {
				for (ic = 1; ic < _LC_LAST; ic++) {
					if (changegl(ic, locname,
					    newgl) == -1) {
						freegl(newgl);
						return NULL;
					}
				}
			}
		}
	} else
		newgl = global_locale;

	/*
	 * Assemble a string representation of the globale locale.
	 */

	/* setlocale(3) was never called with a non-NULL argument. */
	if (newgl == NULL) {
		(void)strlcpy(global_locname, "C", sizeof(global_locname));
		goto done;
	}

	/* Individual category. */
	if (category > LC_ALL) {
		if (strlcpy(global_locname, newgl[category],
		    sizeof(global_locname)) >= sizeof(global_locname))
			global_locname[0] = '\0';
		goto done;
	}

	/* LC_ALL overrides everything else. */
	if (newgl[LC_ALL][0] != '\0') {
		if (strlcpy(global_locname, newgl[LC_ALL],
		    sizeof(global_locname)) >= sizeof(global_locname))
			global_locname[0] = '\0';
		goto done;
	}

	/*
	 * Check whether all categories agree and return either
	 * the single common name for all categories or a string
	 * listing the names for all categories.
	 */
	for (ic = 2; ic < _LC_LAST; ic++)
		if (strcmp(newgl[ic], newgl[1]) != 0)
			break;
	if (ic == _LC_LAST) {
		if (strlcpy(global_locname, newgl[1],
		    sizeof(global_locname)) >= sizeof(global_locname))
			global_locname[0] = '\0';
	} else {
		ic = snprintf(global_locname, sizeof(global_locname),
		    "%s/%s/%s/%s/%s/%s", newgl[1], newgl[2], newgl[3],
		    newgl[4], newgl[5], newgl[6]);
		if (ic == -1 || ic >= sizeof(global_locname))
			global_locname[0] = '\0';
	}

done:
	if (locname != NULL) {
		/*
		 * We can't replace the global locale earlier
		 * because we first have to make sure that we
		 * also have the memory required to report success.
		 */
		if (global_locname[0] != '\0') {
			freegl(global_locale);
			global_locale = newgl;
			if (category == LC_ALL || category == LC_CTYPE)
				_GlobalRuneLocale =
				    strchr(global_locname, '.') == NULL ?
				    &_DefaultRuneLocale : _Utf8RuneLocale;
		} else {
			freegl(newgl);
			return NULL;
		}
	}
	return global_locname;
}
DEF_STRONG(setlocale);
@


1.26
log
@We only support ASCII and UTF-8, so we never need to
change _ctype_, _tolower_tab_, and _toupper_tab_.
No functional change.
Suggested by and OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.25 2016/05/23 00:05:15 guenther Exp $	*/
d3 1
a3 2
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
d5 3
a7 2
 * This code is derived from software contributed to Berkeley by
 * Paul Borman at Krystal Technologies.
d9 7
a15 23
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a18 3
#include <limits.h>
#include <paths.h>
#include <stdio.h>
a20 1
#include <unistd.h>
a21 1
#include "localedef.h"
a22 13
#include "rune_local.h"
/*
 * Category names for getenv()
 */
static char *categories[_LC_LAST] = {
    "LC_ALL",
    "LC_COLLATE",
    "LC_CTYPE",
    "LC_MONETARY",
    "LC_NUMERIC",
    "LC_TIME",
    "LC_MESSAGES"
};
d24 2
a25 23
/*
 * Current locales for each category
 */
static char current_categories[_LC_LAST][32] = {
    "C",
    "C",
    "C",
    "C",
    "C",
    "C",
    "C"
};

static char current_locale_string[_LC_LAST * 33];

static char	*currentlocale(void);
static void revert_to_default(int);
static int load_locale_sub(int, const char *);
static char	*loadlocale(int, const char *);
static const char *__get_locale_env(int);

char *
setlocale(int category, const char *locale)
d27 1
a27 18
	int i, loadlocale_success;
	size_t len;
	const char *env, *r;
	char new_categories[_LC_LAST][32];

	if (category < 0 || category >= _LC_LAST)
		return (NULL);

	if (!locale)
		return (category ?
		    current_categories[category] : currentlocale());

	/*
	 * Default to the current locale for everything.
	 */
	for (i = 1; i < _LC_LAST; ++i)
		(void)strlcpy(new_categories[i], current_categories[i],
		    sizeof(new_categories[i]));
d29 5
a33 67
	/*
	 * Now go fill up new_categories from the locale argument
	 */
	if (!*locale) {
		if (category == LC_ALL) {
			for (i = 1; i < _LC_LAST; ++i) {
				env = __get_locale_env(i);
				(void)strlcpy(new_categories[i], env,
				    sizeof(new_categories[i]));
			}
		}
		else {
			env = __get_locale_env(category);
			(void)strlcpy(new_categories[category], env,
				sizeof(new_categories[category]));
		}
	} else if (category) {
		(void)strlcpy(new_categories[category], locale,
		    sizeof(new_categories[category]));
	} else {
		if ((r = strchr(locale, '/')) == 0) {
			for (i = 1; i < _LC_LAST; ++i) {
				(void)strlcpy(new_categories[i], locale,
				    sizeof(new_categories[i]));
			}
		} else {
			for (i = 1;;) {
				if (*locale == '/')
					return (NULL);	/* invalid format. */
				len = r - locale;
				if (len + 1 > sizeof(new_categories[i]))
					return (NULL);	/* too long */
				(void)memcpy(new_categories[i], locale, len);
				new_categories[i][len] = '\0';
				if (*r == 0)
					break;
				if (*(locale = ++r) == 0)
					/* slash followed by NUL */
					return (NULL);
				/* skip until NUL or '/' */
				while (*r && *r != '/')
					r++;
				if (++i == _LC_LAST)
					return (NULL);	/* too many slashes. */
			}
			if (i + 1 != _LC_LAST)
				return (NULL);	/* too few slashes. */
		}
	}

	if (category)
		return (loadlocale(category, new_categories[category]));

	loadlocale_success = 0;
	for (i = 1; i < _LC_LAST; ++i) {
		if (loadlocale(i, new_categories[i]) != NULL)
			loadlocale_success = 1;
	}

	/*
	 * If all categories failed, return NULL; we don't need to back
	 * changes off, since none happened.
	 */
	if (!loadlocale_success)
		return NULL;

	return (currentlocale());
a34 1
DEF_STRONG(setlocale);
d36 2
a37 2
static char *
currentlocale(void)
d39 2
a40 1
	int i;
d42 7
a48 11
	(void)strlcpy(current_locale_string, current_categories[1],
	    sizeof(current_locale_string));

	for (i = 2; i < _LC_LAST; ++i)
		if (strcmp(current_categories[1], current_categories[i])) {
			(void)snprintf(current_locale_string,
			    sizeof(current_locale_string), "%s/%s/%s/%s/%s/%s",
			    current_categories[1], current_categories[2],
			    current_categories[3], current_categories[4],
			    current_categories[5], current_categories[6]);
			break;
a49 16
	return (current_locale_string);
}

static void
revert_to_default(int category)
{
	switch (category) {
	case LC_CTYPE:
		(void)_xpg4_setrunelocale("C");
		break;
	case LC_MESSAGES:
	case LC_COLLATE:
	case LC_MONETARY:
	case LC_NUMERIC:
	case LC_TIME:
		break;
d51 1
d55 1
a55 1
set_lc_messages_locale(const char *locname)
d57 1
a57 1
	const char *dot, *loc_encoding;
d59 2
a60 3
	/* Assumes "language[_territory][.codeset]" locale name. */
	dot = strrchr(locname, '.');
	if (dot == NULL)
a61 1
	loc_encoding = dot + 1;
d63 3
a65 1
	return strcmp(loc_encoding, "UTF-8") == 0 ? 0 : -1;
d68 2
a69 2
static int
load_locale_sub(int category, const char *locname)
d71 8
a78 9
	/* check for the default locales */
	if (!strcmp(locname, "C") || !strcmp(locname, "POSIX")) {
		revert_to_default(category);
		return 0;
	}

	/* sanity check */
	if (strchr(locname, '/') != NULL)
		return -1;
d80 2
a81 15
	switch (category) {
	case LC_CTYPE:
		if (_xpg4_setrunelocale(locname))
			return -1;
		break;

	case LC_MESSAGES:
		return set_lc_messages_locale(locname);

	case LC_COLLATE:
	case LC_MONETARY:
	case LC_NUMERIC:
	case LC_TIME:
		return -1;
	}
d83 1
a83 14
	return 0;
}

static char *
loadlocale(int category, const char *locname)
{
	if (strcmp(locname, current_categories[category]) == 0)
		return (current_categories[category]);

	if (!load_locale_sub(category, locname)) {
		(void)strlcpy(current_categories[category],
		    locname, sizeof(current_categories[category]));
		return current_categories[category];
	} else {
a84 2
	}
}
d86 22
a107 4
static const char *
__get_locale_env(int category)
{
	const char *env;
d109 5
a113 2
	/* 1. check LC_ALL. */
	env = getenv(categories[0]);
d115 13
a127 3
	/* 2. check LC_* */
	if (!env || !*env)
		env = getenv(categories[category]);
d129 3
a131 3
	/* 3. check LANG */
	if (!env || !*env)
		env = getenv("LANG");
d133 21
a153 3
	/* 4. if none is set, fall to "C" */
	if (!env || !*env || strchr(env, '/'))
		env = "C";
d155 40
a194 1
	return env;
d196 1
@


1.25
log
@Stop exposing <sys/localedef.h> and various symbols internal to the libc
locale implementation: _{Current,Default}*Locale, __[mn]locale_changed,
__mb_len_max_runtime

ok millert@@ schwarze@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.24 2015/09/14 12:21:03 guenther Exp $	*/
a196 1
		__install_currentrunelocale_ctype();
a237 1
		__install_currentrunelocale_ctype();
@


1.24
log
@Wrap <locale.h> so internal calls go direct
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.23 2015/08/14 14:30:40 stsp Exp $	*/
a33 1
#include <sys/localedef.h>
d42 1
@


1.23
log
@Load LC_MESSAGES locale only if the character encoding is UTF-8.
ok mpi tedu phessler zhuk, and discussed with many at c2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.22 2015/07/02 16:07:43 semarie Exp $	*/
d169 1
@


1.22
log
@remove new_categories variable from global.

This variable is used as temporary buffer in order to do checking
before copying the content to current_categories variable.

Switch it as local variable in setlocale function. Adapts some functions.

the commit collapse 3 proposed diffs on tech@@, and all OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.21 2015/06/09 20:04:04 stsp Exp $	*/
a209 3
	const char *charset;
	char charsets[sizeof(LOCALE_CHARSETS)];
	char *s = charsets;
d218 1
a218 13
	/* Allow message catalogs in encodings supported by LC_CTYPE.
	 * We don't care about the language name since it is application
	 * specific. */
	memcpy(charsets, LOCALE_CHARSETS, sizeof(charsets));
	do {
		charset = strsep(&s, " \t");
		if (charset && charset[0]) {
			if (strcmp(loc_encoding, charset) == 0)
				return 0;
		}
	} while (charset);

	return -1;
@


1.21
log
@Remove unused parameter of load_locale_sub(). No assembly change on i386.
Diff from Sebastien Marie. objdump foo help from uwe
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.20 2013/08/28 16:53:34 stsp Exp $	*/
a70 5
/*
 * The locales we are going to try and load
 */
static char new_categories[_LC_LAST][32];

d76 1
a76 1
static char	*loadlocale(int);
d85 1
d152 1
a152 1
		return (loadlocale(category));
d156 1
a156 1
		if (loadlocale(i) != NULL)
d240 1
a240 2
	if (!strcmp(new_categories[category], "C") ||
	    !strcmp(new_categories[category], "POSIX")) {
d270 1
a270 1
loadlocale(int category)
d272 1
a272 2
	if (strcmp(new_categories[category],
	    current_categories[category]) == 0)
d275 1
a275 1
	if (!load_locale_sub(category, new_categories[category])) {
d277 1
a277 1
		    new_categories[category], sizeof(current_categories[category]));
@


1.20
log
@Allow setlocale(LC_MESSAGES, ...); to succeed. This always returned an
error, but that makes some ports (e.g. GNOME) freak out. We can allow
any message language to be used as long as the encoding specified as
part of the locale name is supported (i.e. listed in locale -m output).
The primary users of LC_MESSAGES are catopen(3) and gettext(3), which
already worked without this change.
ok ajacoutot, naddy, matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.19 2013/06/01 20:02:53 stsp Exp $	*/
d80 1
a80 1
static int load_locale_sub(int, const char *, int);
d241 1
a241 1
load_locale_sub(int category, const char *locname, int isspecial)
d281 1
a281 1
	if (!load_locale_sub(category, new_categories[category], 0)) {
@


1.19
log
@Change the naming scheme used for directories in /usr/share/locale to
eliminate redundant copies of LC_CTYPE files.

Instead of names using "language_territory.codeset" permutations, use just
the codeset component to name directories storing LC_CTYPE files. Suggested
by bluhm@@ while discussing the idea of using symlinks in /usr/share/locale
like FreeBSD does.

Future locale features which store language and/or territory specific data
can name directories after language or territory names.
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.18 2011/03/15 22:27:48 stsp Exp $	*/
d212 29
d262 2
@


1.18
log
@Remove evaluation of PATH_LOCALE environment variable because it can be
abused to cause an integer overflow and serves no real purpose.
Found by Alexander Schrijver.
ok millert deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.17 2007/11/28 10:24:38 chl Exp $	*/
a213 3
	char name[PATH_MAX];
	int len;

a222 5
		return -1;

	len = snprintf(name, sizeof(name), "%s/%s/%s",
		       _PATH_LOCALE, locname, categories[category]);
	if (len < 0 || len >= sizeof(name))
@


1.17
log
@remove unused function

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.16 2007/09/17 07:07:23 moritz Exp $	*/
a90 5
	if (issetugid() != 0 ||
	    ((!_PathLocale && !(_PathLocale = getenv("PATH_LOCALE"))) ||
	     !*_PathLocale))
		_PathLocale = _PATH_LOCALE;

d229 1
a229 1
		       _PathLocale, locname, categories[category]);
@


1.16
log
@Check snprintf(3) return value for error or truncation.
Mostly path construction, where truncation could be bad.

ok and input from deraadt@@ millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.15 2007/09/06 08:26:12 moritz Exp $	*/
a79 1
static int force_locale_enable(int);
a213 8
}

static int
force_locale_enable(int category)
{
	revert_to_default(category);

	return 0;
@


1.15
log
@_xpg4_setrunelocale() returns an errno(2) value in the failure
case and 0 if the locale was found. So checking against -1 makes
no sense.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.14 2005/08/08 08:05:35 espie Exp $	*/
d229 1
d242 1
a242 1
	(void)snprintf(name, sizeof(name), "%s/%s/%s",
d244 2
@


1.14
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.13 2005/08/08 05:53:01 espie Exp $	*/
d246 1
a246 1
		if (_xpg4_setrunelocale(locname) == -1)
@


1.13
log
@activate LC_CTYPE for 8 bits locale.
Make sure tolower/toupper use the whole 8 bits.

okay deraadt@@
thanks to everyone who tested
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.12 2005/03/23 21:13:28 otto Exp $	*/
a32 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.12 2005/03/23 21:13:28 otto Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.12
log
@ansify. ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.11 2003/06/02 20:18:35 millert Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.11 2003/06/02 20:18:35 millert Exp $";
d47 2
a80 1
static char *PathLocale;
d83 3
d87 1
a87 1
static const char *__get_locale_env __P((int));
d97 3
a99 3
	    ((!PathLocale && !(PathLocale = getenv("PATH_LOCALE"))) ||
	     !*PathLocale))
		PathLocale = _PATH_LOCALE;
d204 27
a230 2
static char *
loadlocale(int category)
d234 1
a234 4
	if (strcmp(new_categories[category],
	    current_categories[category]) == 0)
		return (current_categories[category]);

d237 3
d241 3
a243 10
		/*
		 * Some day this will need to reset the locale to the default
		 * C locale.  Since we have no way to change them as of yet,
		 * there is no need to reset them.
		 */
		(void)strlcpy(current_categories[category],
		    new_categories[category],
		    sizeof(current_categories[category]));
		return (current_categories[category]);
	}
a244 3
	/*
	 * Some day we will actually look at this file.
	 */
d246 1
a246 1
	    PathLocale, new_categories[category], categories[category]);
d250 6
a256 1
	case LC_MESSAGES:
d260 1
a260 1
		return (NULL);
d263 17
a279 3
	(void)strlcpy(current_categories[category],
	    new_categories[category], sizeof(current_categories[category]));
	return current_categories[category];
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.10 2002/09/17 07:45:35 itojun Exp $	*/
d35 1
a35 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.10 2002/09/17 07:45:35 itojun Exp $";
d86 1
a86 3
setlocale(category, locale)
	int category;
	const char *locale;
d181 1
a181 1
currentlocale()
d201 1
a201 2
loadlocale(category)
	int category;
d245 1
a245 2
__get_locale_env(category)
	int category;
@


1.10
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.9 2002/09/17 05:50:51 itojun Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d35 1
a35 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.9 2002/09/17 05:50:51 itojun Exp $";
@


1.9
log
@correct possible buffer overrun in setlocale(x, y) where y is supplied from
outside.  see NetBSD SA2002-012.
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.8 2002/02/16 21:27:23 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.8 2002/02/16 21:27:23 millert Exp $";
d224 1
a224 1
		(void)stlrcpy(current_categories[category],
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.7 2001/06/27 00:58:54 lebel Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.7 2001/06/27 00:58:54 lebel Exp $";
d87 1
d94 3
a96 2
	int found, i, len;
	char *env, *r;
d114 2
a115 1
		(void)strcpy(new_categories[i], current_categories[i]);
d121 1
a121 13
		env = getenv(categories[category]);

		if (!env || !*env)
			env = getenv(categories[0]);

		if (!env || !*env)
			env = getenv("LANG");

		if (!env || !*env)
			env = "C";

		strlcpy(new_categories[category], env, 32);
		if (!category) {
d123 3
a125 3
				if (!(env = getenv(categories[i])) || !*env)
					env = new_categories[0];
				strlcpy(new_categories[i], env, 32);
d128 8
a135 2
	} else if (category)  {
		strlcpy(new_categories[category], locale, 32);
d139 2
a140 1
				strlcpy(new_categories[i], locale, 32);
d143 21
a163 14
			for (i = 1; r[1] == '/'; ++r);
			if (!r[1])
				return (NULL);	/* Hmm, just slashes... */
			do {
				len = r - locale > 31 ? 31 : r - locale;
				strlcpy(new_categories[i++], locale, len + 1);
				locale = r;
				while (*locale == '/')
				    ++locale;
				while (*++r && *r != '/');
			} while (*locale);
			while (i < _LC_LAST)
				(void)strcpy(new_categories[i],
				    new_categories[i-1]);
d170 2
a171 1
	for (found = 0, i = 1; i < _LC_LAST; ++i) {
d173 1
a173 5
			found = 1;
		else if (!category) {
			found = 0;
			break;
		}
d176 8
a183 1
	return (found ? currentlocale() : NULL);
d191 2
a192 1
	(void)strcpy(current_locale_string, current_categories[1]);
d197 1
a197 1
			    sizeof(current_locale_string), "%s/%s/%s/%s/%s",
d200 1
a200 1
			    current_categories[5]);
d217 1
a217 1
		!strcmp(new_categories[category], "POSIX")) {
d224 3
a226 2
		(void)strcpy(current_categories[category],
		    new_categories[category]);
d237 7
a243 7
		case LC_CTYPE:
		case LC_COLLATE:
		case LC_MESSAGES:
		case LC_MONETARY:
		case LC_NUMERIC:
		case LC_TIME:
			return (NULL);
d245 28
a272 1
	return (NULL);
@


1.7
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: setlocale.c,v 1.6 1997/07/09 01:08:21 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.6 1997/07/09 01:08:21 millert Exp $";
d85 2
a86 2
static char	*currentlocale __P((void));
static char	*loadlocale __P((int));
@


1.6
log
@Clean up some -Wall flowers.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.5 1996/10/29 03:22:27 millert Exp $";
d129 1
a129 2
		(void) strncpy(new_categories[category], env, 31);
		new_categories[category][31] = 0;
d134 1
a134 2
				(void)strncpy(new_categories[i], env, 31);
				new_categories[i][31] = 0;
d138 1
a138 2
		(void)strncpy(new_categories[category], locale, 31);
		new_categories[category][31] = 0;
d142 1
a142 2
				(void)strncpy(new_categories[i], locale, 31);
				new_categories[i][31] = 0;
d150 1
a150 2
				(void)strncpy(new_categories[i++], locale, len);
				new_categories[i++][len] = 0;
@


1.5
log
@POSIX compliance.
@
text
@d1 1
d39 1
a39 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.4 1996/09/15 09:31:14 tholo Exp $";
d45 1
d49 1
a49 1
#include <paths.h>
@


1.4
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.3 1996/08/26 00:17:18 deraadt Exp $";
d95 2
a96 1
	    (!PathLocale && !(PathLocale = getenv("PATH_LOCALE"))))
d118 1
a118 1
		if (!env)
d121 1
a121 1
		if (!env)
d124 1
a124 1
		if (!env)
d131 1
a131 1
				if (!(env = getenv(categories[i])))
d168 1
a168 2
	found = 0;
	for (i = 1; i < _LC_LAST; ++i)
d171 7
a177 3
	if (found)
	    return (currentlocale());
	return (NULL);
@


1.3
log
@use issetugid() to protect against bad getenv
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: setlocale.c,v 1.2 1996/08/19 08:28:24 tholo Exp $";
d233 1
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD$";
d94 2
a95 1
	if (!PathLocale && !(PathLocale = getenv("PATH_LOCALE")))
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
static char sccsid[] = "@@(#)setlocale.c	8.1 (Berkeley) 7/4/93";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
