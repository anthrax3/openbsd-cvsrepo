head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.6.0.8
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.20
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.12
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.16
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.14
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.10
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.8
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.7
date	2017.07.27.16.47.43;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	tDtNuCn2QrX574Ba;

1.6
date	2015.09.13.08.31.47;	author guenther;	state Exp;
branches;
next	1.5;
commitid	QZ177IcjQzeRxHAC;

1.5
date	2011.07.02.18.03.43;	author martynas;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.16.12.15.03;	author martynas;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.12.11.40.59;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.09.19.44.10;	author martynas;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.07.20.36.08;	author martynas;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Use stdrup, to avoid clang whining about the length parameters being
based upon input being used unsafely (they are safe)
ok millert kettenis
@
text
@/****************************************************************

The author of this software is David M. Gay.

Copyright (C) 1998-2001 by Lucent Technologies
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name of Lucent or any of its entities
not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.

****************************************************************/

/* Please send bug reports to David M. Gay (dmg at acm dot org,
 * with " at " changed at "@@" and " dot " changed to ".").	*/

#include "gdtoaimp.h"
#ifndef NO_FENV_H
#include <fenv.h>
#endif

#ifdef USE_LOCALE
#include "locale.h"
#endif

#ifdef IEEE_Arith
#ifndef NO_IEEE_Scale
#define Avoid_Underflow
#undef tinytens
/* The factor of 2^106 in tinytens[4] helps us avoid setting the underflow */
/* flag unnecessarily.  It leads to a song and dance at the end of strtod. */
static CONST double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128,
		9007199254740992.*9007199254740992.e-256
		};
#endif
#endif

#ifdef Honor_FLT_ROUNDS
#undef Check_FLT_ROUNDS
#define Check_FLT_ROUNDS
#else
#define Rounding Flt_Rounds
#endif

#ifdef Avoid_Underflow /*{*/
 static double
sulp
#ifdef KR_headers
	(x, scale) U *x; int scale;
#else
	(U *x, int scale)
#endif
{
	U u;
	double rv;
	int i;

	rv = ulp(x);
	if (!scale || (i = 2*P + 1 - ((word0(x) & Exp_mask) >> Exp_shift)) <= 0)
		return rv; /* Is there an example where i <= 0 ? */
	word0(&u) = Exp_1 + (i << Exp_shift);
	word1(&u) = 0;
	return rv * u.d;
	}
#endif /*}*/

 double
strtod
#ifdef KR_headers
	(s00, se) CONST char *s00; char **se;
#else
	(CONST char *s00, char **se)
#endif
{
#ifdef Avoid_Underflow
	int scale;
#endif
	int bb2, bb5, bbe, bd2, bd5, bbbits, bs2, c, decpt, dsign,
		 e, e1, esign, i, j, k, nd, nd0, nf, nz, nz0, sign;
	CONST char *s, *s0, *s1;
	double aadj;
	Long L;
	U adj, aadj1, rv, rv0;
	ULong y, z;
	Bigint *bb = NULL, *bb1, *bd = NULL, *bd0 = NULL, *bs = NULL, *delta = NULL;
#ifdef Avoid_Underflow
	ULong Lsb, Lsb1;
#endif
#ifdef SET_INEXACT
	int inexact, oldinexact;
#endif
#ifdef USE_LOCALE /*{{*/
#ifdef NO_LOCALE_CACHE
	char *decimalpoint = localeconv()->decimal_point;
	int dplen = strlen(decimalpoint);
#else
	char *decimalpoint;
	static char *decimalpoint_cache;
	static int dplen;
	if (!(s0 = decimalpoint_cache)) {
		s0 = localeconv()->decimal_point;
		decimalpoint_cache = strdup(s0);
		dplen = strlen(s0);
		}
	decimalpoint = (char*)s0;
#endif /*NO_LOCALE_CACHE*/
#else  /*USE_LOCALE}{*/
#define dplen 1
#endif /*USE_LOCALE}}*/

#ifdef Honor_FLT_ROUNDS /*{*/
	int Rounding;
#ifdef Trust_FLT_ROUNDS /*{{ only define this if FLT_ROUNDS really works! */
	Rounding = Flt_Rounds;
#else /*}{*/
	Rounding = 1;
	switch(fegetround()) {
	  case FE_TOWARDZERO:	Rounding = 0; break;
	  case FE_UPWARD:	Rounding = 2; break;
	  case FE_DOWNWARD:	Rounding = 3;
	  }
#endif /*}}*/
#endif /*}*/

	sign = nz0 = nz = decpt = 0;
	dval(&rv) = 0.;
	for(s = s00;;s++) switch(*s) {
		case '-':
			sign = 1;
			/* no break */
		case '+':
			if (*++s)
				goto break2;
			/* no break */
		case 0:
			goto ret0;
		case '\t':
		case '\n':
		case '\v':
		case '\f':
		case '\r':
		case ' ':
			continue;
		default:
			goto break2;
		}
 break2:
	if (*s == '0') {
#ifndef NO_HEX_FP /*{*/
		{
		static FPI fpi = { 53, 1-1023-53+1, 2046-1023-53+1, 1, SI };
		Long exp;
		ULong bits[2];
		switch(s[1]) {
		  case 'x':
		  case 'X':
			{
#ifdef Honor_FLT_ROUNDS
			FPI fpi1 = fpi;
			fpi1.rounding = Rounding;
#else
#define fpi1 fpi
#endif
			switch((i = gethex(&s, &fpi1, &exp, &bb, sign)) & STRTOG_Retmask) {
			  case STRTOG_NoMemory:
				goto ovfl;
			  case STRTOG_NoNumber:
				s = s00;
				sign = 0;
			  case STRTOG_Zero:
				break;
			  default:
				if (bb) {
					copybits(bits, fpi.nbits, bb);
					Bfree(bb);
					}
				ULtod(((U*)&rv)->L, bits, exp, i);
			  }}
			goto ret;
		  }
		}
#endif /*}*/
		nz0 = 1;
		while(*++s == '0') ;
		if (!*s)
			goto ret;
		}
	s0 = s;
	y = z = 0;
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
		if (nd < 9)
			y = 10*y + c - '0';
		else if (nd < 16)
			z = 10*z + c - '0';
	nd0 = nd;
#ifdef USE_LOCALE
	if (c == *decimalpoint) {
		for(i = 1; decimalpoint[i]; ++i)
			if (s[i] != decimalpoint[i])
				goto dig_done;
		s += i;
		c = *s;
#else
	if (c == '.') {
		c = *++s;
#endif
		decpt = 1;
		if (!nd) {
			for(; c == '0'; c = *++s)
				nz++;
			if (c > '0' && c <= '9') {
				s0 = s;
				nf += nz;
				nz = 0;
				goto have_dig;
				}
			goto dig_done;
			}
		for(; c >= '0' && c <= '9'; c = *++s) {
 have_dig:
			nz++;
			if (c -= '0') {
				nf += nz;
				for(i = 1; i < nz; i++)
					if (nd++ < 9)
						y *= 10;
					else if (nd <= DBL_DIG + 1)
						z *= 10;
				if (nd++ < 9)
					y = 10*y + c;
				else if (nd <= DBL_DIG + 1)
					z = 10*z + c;
				nz = 0;
				}
			}
		}/*}*/
 dig_done:
	e = 0;
	if (c == 'e' || c == 'E') {
		if (!nd && !nz && !nz0) {
			goto ret0;
			}
		s00 = s;
		esign = 0;
		switch(c = *++s) {
			case '-':
				esign = 1;
			case '+':
				c = *++s;
			}
		if (c >= '0' && c <= '9') {
			while(c == '0')
				c = *++s;
			if (c > '0' && c <= '9') {
				L = c - '0';
				s1 = s;
				while((c = *++s) >= '0' && c <= '9')
					L = 10*L + c - '0';
				if (s - s1 > 8 || L > 19999)
					/* Avoid confusion from exponents
					 * so large that e might overflow.
					 */
					e = 19999; /* safe for 16 bit ints */
				else
					e = (int)L;
				if (esign)
					e = -e;
				}
			else
				e = 0;
			}
		else
			s = s00;
		}
	if (!nd) {
		if (!nz && !nz0) {
#ifdef INFNAN_CHECK
			/* Check for Nan and Infinity */
			ULong bits[2];
			static FPI fpinan =	/* only 52 explicit bits */
				{ 52, 1-1023-53+1, 2046-1023-53+1, 1, SI };
			if (!decpt)
			 switch(c) {
			  case 'i':
			  case 'I':
				if (match(&s,"nf")) {
					--s;
					if (!match(&s,"inity"))
						++s;
					word0(&rv) = 0x7ff00000;
					word1(&rv) = 0;
					goto ret;
					}
				break;
			  case 'n':
			  case 'N':
				if (match(&s, "an")) {
#ifndef No_Hex_NaN
					if (*s == '(' /*)*/
					 && hexnan(&s, &fpinan, bits)
							== STRTOG_NaNbits) {
						word0(&rv) = 0x7ff00000 | bits[1];
						word1(&rv) = bits[0];
						}
					else {
#endif
						word0(&rv) = NAN_WORD0;
						word1(&rv) = NAN_WORD1;
#ifndef No_Hex_NaN
						}
#endif
					goto ret;
					}
			  }
#endif /* INFNAN_CHECK */
 ret0:
			s = s00;
			sign = 0;
			}
		goto ret;
		}
	e1 = e -= nf;

	/* Now we have nd0 digits, starting at s0, followed by a
	 * decimal point, followed by nd-nd0 digits.  The number we're
	 * after is the integer represented by those digits times
	 * 10**e */

	if (!nd0)
		nd0 = nd;
	k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;
	dval(&rv) = y;
	if (k > 9) {
#ifdef SET_INEXACT
		if (k > DBL_DIG)
			oldinexact = get_inexact();
#endif
		dval(&rv) = tens[k - 9] * dval(&rv) + z;
		}
	if (nd <= DBL_DIG
#ifndef RND_PRODQUOT
#ifndef Honor_FLT_ROUNDS
		&& Flt_Rounds == 1
#endif
#endif
			) {
		if (!e)
			goto ret;
#ifndef ROUND_BIASED_without_Round_Up
		if (e > 0) {
			if (e <= Ten_pmax) {
#ifdef VAX
				goto vax_ovfl_check;
#else
#ifdef Honor_FLT_ROUNDS
				/* round correctly FLT_ROUNDS = 2 or 3 */
				if (sign) {
					rv.d = -rv.d;
					sign = 0;
					}
#endif
				/* rv = */ rounded_product(dval(&rv), tens[e]);
				goto ret;
#endif
				}
			i = DBL_DIG - nd;
			if (e <= Ten_pmax + i) {
				/* A fancier test would sometimes let us do
				 * this for larger i values.
				 */
#ifdef Honor_FLT_ROUNDS
				/* round correctly FLT_ROUNDS = 2 or 3 */
				if (sign) {
					rv.d = -rv.d;
					sign = 0;
					}
#endif
				e -= i;
				dval(&rv) *= tens[i];
#ifdef VAX
				/* VAX exponent range is so narrow we must
				 * worry about overflow here...
				 */
 vax_ovfl_check:
				word0(&rv) -= P*Exp_msk1;
				/* rv = */ rounded_product(dval(&rv), tens[e]);
				if ((word0(&rv) & Exp_mask)
				 > Exp_msk1*(DBL_MAX_EXP+Bias-1-P))
					goto ovfl;
				word0(&rv) += P*Exp_msk1;
#else
				/* rv = */ rounded_product(dval(&rv), tens[e]);
#endif
				goto ret;
				}
			}
#ifndef Inaccurate_Divide
		else if (e >= -Ten_pmax) {
#ifdef Honor_FLT_ROUNDS
			/* round correctly FLT_ROUNDS = 2 or 3 */
			if (sign) {
				rv.d = -rv.d;
				sign = 0;
				}
#endif
			/* rv = */ rounded_quotient(dval(&rv), tens[-e]);
			goto ret;
			}
#endif
#endif /* ROUND_BIASED_without_Round_Up */
		}
	e1 += nd - k;

#ifdef IEEE_Arith
#ifdef SET_INEXACT
	inexact = 1;
	if (k <= DBL_DIG)
		oldinexact = get_inexact();
#endif
#ifdef Avoid_Underflow
	scale = 0;
#endif
#ifdef Honor_FLT_ROUNDS
	if (Rounding >= 2) {
		if (sign)
			Rounding = Rounding == 2 ? 0 : 2;
		else
			if (Rounding != 2)
				Rounding = 0;
		}
#endif
#endif /*IEEE_Arith*/

	/* Get starting approximation = rv * 10**e1 */

	if (e1 > 0) {
		if ( (i = e1 & 15) !=0)
			dval(&rv) *= tens[i];
		if (e1 &= ~15) {
			if (e1 > DBL_MAX_10_EXP) {
 ovfl:
				/* Can't trust HUGE_VAL */
#ifdef IEEE_Arith
#ifdef Honor_FLT_ROUNDS
				switch(Rounding) {
				  case 0: /* toward 0 */
				  case 3: /* toward -infinity */
					word0(&rv) = Big0;
					word1(&rv) = Big1;
					break;
				  default:
					word0(&rv) = Exp_mask;
					word1(&rv) = 0;
				  }
#else /*Honor_FLT_ROUNDS*/
				word0(&rv) = Exp_mask;
				word1(&rv) = 0;
#endif /*Honor_FLT_ROUNDS*/
#ifdef SET_INEXACT
				/* set overflow bit */
				dval(&rv0) = 1e300;
				dval(&rv0) *= dval(&rv0);
#endif
#else /*IEEE_Arith*/
				word0(&rv) = Big0;
				word1(&rv) = Big1;
#endif /*IEEE_Arith*/
 range_err:
				if (bd0) {
					Bfree(bb);
					Bfree(bd);
					Bfree(bs);
					Bfree(bd0);
					Bfree(delta);
					}
#ifndef NO_ERRNO
				errno = ERANGE;
#endif
				goto ret;
				}
			e1 >>= 4;
			for(j = 0; e1 > 1; j++, e1 >>= 1)
				if (e1 & 1)
					dval(&rv) *= bigtens[j];
		/* The last multiplication could overflow. */
			word0(&rv) -= P*Exp_msk1;
			dval(&rv) *= bigtens[j];
			if ((z = word0(&rv) & Exp_mask)
			 > Exp_msk1*(DBL_MAX_EXP+Bias-P))
				goto ovfl;
			if (z > Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {
				/* set to largest number */
				/* (Can't trust DBL_MAX) */
				word0(&rv) = Big0;
				word1(&rv) = Big1;
				}
			else
				word0(&rv) += P*Exp_msk1;
			}
		}
	else if (e1 < 0) {
		e1 = -e1;
		if ( (i = e1 & 15) !=0)
			dval(&rv) /= tens[i];
		if (e1 >>= 4) {
			if (e1 >= 1 << n_bigtens)
				goto undfl;
#ifdef Avoid_Underflow
			if (e1 & Scale_Bit)
				scale = 2*P;
			for(j = 0; e1 > 0; j++, e1 >>= 1)
				if (e1 & 1)
					dval(&rv) *= tinytens[j];
			if (scale && (j = 2*P + 1 - ((word0(&rv) & Exp_mask)
						>> Exp_shift)) > 0) {
				/* scaled rv is denormal; zap j low bits */
				if (j >= 32) {
					word1(&rv) = 0;
					if (j >= 53)
					 word0(&rv) = (P+2)*Exp_msk1;
					else
					 word0(&rv) &= 0xffffffff << (j-32);
					}
				else
					word1(&rv) &= 0xffffffff << j;
				}
#else
			for(j = 0; e1 > 1; j++, e1 >>= 1)
				if (e1 & 1)
					dval(&rv) *= tinytens[j];
			/* The last multiplication could underflow. */
			dval(&rv0) = dval(&rv);
			dval(&rv) *= tinytens[j];
			if (!dval(&rv)) {
				dval(&rv) = 2.*dval(&rv0);
				dval(&rv) *= tinytens[j];
#endif
				if (!dval(&rv)) {
 undfl:
					dval(&rv) = 0.;
					goto range_err;
					}
#ifndef Avoid_Underflow
				word0(&rv) = Tiny0;
				word1(&rv) = Tiny1;
				/* The refinement below will clean
				 * this approximation up.
				 */
				}
#endif
			}
		}

	/* Now the hard part -- adjusting rv to the correct value.*/

	/* Put digits into bd: true value = bd * 10^e */

	bd0 = s2b(s0, nd0, nd, y, dplen);
	if (bd0 == NULL)
		goto ovfl;

	for(;;) {
		bd = Balloc(bd0->k);
		if (bd == NULL)
			goto ovfl;
		Bcopy(bd, bd0);
		bb = d2b(dval(&rv), &bbe, &bbbits);	/* rv = bb * 2^bbe */
		if (bb == NULL)
			goto ovfl;
		bs = i2b(1);
		if (bs == NULL)
			goto ovfl;

		if (e >= 0) {
			bb2 = bb5 = 0;
			bd2 = bd5 = e;
			}
		else {
			bb2 = bb5 = -e;
			bd2 = bd5 = 0;
			}
		if (bbe >= 0)
			bb2 += bbe;
		else
			bd2 -= bbe;
		bs2 = bb2;
#ifdef Honor_FLT_ROUNDS
		if (Rounding != 1)
			bs2++;
#endif
#ifdef Avoid_Underflow
		Lsb = LSB;
		Lsb1 = 0;
		j = bbe - scale;
		i = j + bbbits - 1;	/* logb(rv) */
		j = P + 1 - bbbits;
		if (i < Emin) {	/* denormal */
			i = Emin - i;
			j -= i;
			if (i < 32)
				Lsb <<= i;
			else
				Lsb1 = Lsb << (i-32);
			}
#else /*Avoid_Underflow*/
#ifdef Sudden_Underflow
#ifdef IBM
		j = 1 + 4*P - 3 - bbbits + ((bbe + bbbits - 1) & 3);
#else
		j = P + 1 - bbbits;
#endif
#else /*Sudden_Underflow*/
		j = bbe;
		i = j + bbbits - 1;	/* logb(&rv) */
		if (i < Emin)	/* denormal */
			j += P - Emin;
		else
			j = P + 1 - bbbits;
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
		bb2 += j;
		bd2 += j;
#ifdef Avoid_Underflow
		bd2 += scale;
#endif
		i = bb2 < bd2 ? bb2 : bd2;
		if (i > bs2)
			i = bs2;
		if (i > 0) {
			bb2 -= i;
			bd2 -= i;
			bs2 -= i;
			}
		if (bb5 > 0) {
			bs = pow5mult(bs, bb5);
			if (bs == NULL)
				goto ovfl;
			bb1 = mult(bs, bb);
			if (bb1 == NULL)
				goto ovfl;
			Bfree(bb);
			bb = bb1;
			}
		if (bb2 > 0) {
			bb = lshift(bb, bb2);
			if (bb == NULL)
				goto ovfl;
			}
		if (bd5 > 0) {
			bd = pow5mult(bd, bd5);
			if (bd == NULL)
				goto ovfl;
			}
		if (bd2 > 0) {
			bd = lshift(bd, bd2);
			if (bd == NULL)
				goto ovfl;
			}
		if (bs2 > 0) {
			bs = lshift(bs, bs2);
			if (bs == NULL)
				goto ovfl;
			}
		delta = diff(bb, bd);
		if (delta == NULL)
			goto ovfl;
		dsign = delta->sign;
		delta->sign = 0;
		i = cmp(delta, bs);
#ifdef Honor_FLT_ROUNDS
		if (Rounding != 1) {
			if (i < 0) {
				/* Error is less than an ulp */
				if (!delta->x[0] && delta->wds <= 1) {
					/* exact */
#ifdef SET_INEXACT
					inexact = 0;
#endif
					break;
					}
				if (Rounding) {
					if (dsign) {
						dval(&adj) = 1.;
						goto apply_adj;
						}
					}
				else if (!dsign) {
					dval(&adj) = -1.;
					if (!word1(&rv)
					 && !(word0(&rv) & Frac_mask)) {
						y = word0(&rv) & Exp_mask;
#ifdef Avoid_Underflow
						if (!scale || y > 2*P*Exp_msk1)
#else
						if (y)
#endif
						  {
						  delta = lshift(delta,Log2P);
						  if (delta == NULL)
							goto ovfl;
						  if (cmp(delta, bs) <= 0)
							dval(&adj) = -0.5;
						  }
						}
 apply_adj:
#ifdef Avoid_Underflow
					if (scale && (y = word0(&rv) & Exp_mask)
						<= 2*P*Exp_msk1)
					  word0(&adj) += (2*P+1)*Exp_msk1 - y;
#else
#ifdef Sudden_Underflow
					if ((word0(&rv) & Exp_mask) <=
							P*Exp_msk1) {
						word0(&rv) += P*Exp_msk1;
						dval(&rv) += adj*ulp(&rv);
						word0(&rv) -= P*Exp_msk1;
						}
					else
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
					dval(&rv) += adj.d*ulp(&rv);
					}
				break;
				}
			dval(&adj) = ratio(delta, bs);
			if (adj.d < 1.)
				dval(&adj) = 1.;
			if (adj.d <= 0x7ffffffe) {
				/* dval(&adj) = Rounding ? ceil(&adj) : floor(&adj); */
				y = adj.d;
				if (y != adj.d) {
					if (!((Rounding>>1) ^ dsign))
						y++;
					dval(&adj) = y;
					}
				}
#ifdef Avoid_Underflow
			if (scale && (y = word0(&rv) & Exp_mask) <= 2*P*Exp_msk1)
				word0(&adj) += (2*P+1)*Exp_msk1 - y;
#else
#ifdef Sudden_Underflow
			if ((word0(&rv) & Exp_mask) <= P*Exp_msk1) {
				word0(&rv) += P*Exp_msk1;
				dval(&adj) *= ulp(&rv);
				if (dsign)
					dval(&rv) += adj;
				else
					dval(&rv) -= adj;
				word0(&rv) -= P*Exp_msk1;
				goto cont;
				}
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
			dval(&adj) *= ulp(&rv);
			if (dsign) {
				if (word0(&rv) == Big0 && word1(&rv) == Big1)
					goto ovfl;
				dval(&rv) += adj.d;
				}
			else
				dval(&rv) -= adj.d;
			goto cont;
			}
#endif /*Honor_FLT_ROUNDS*/

		if (i < 0) {
			/* Error is less than half an ulp -- check for
			 * special case of mantissa a power of two.
			 */
			if (dsign || word1(&rv) || word0(&rv) & Bndry_mask
#ifdef IEEE_Arith
#ifdef Avoid_Underflow
			 || (word0(&rv) & Exp_mask) <= (2*P+1)*Exp_msk1
#else
			 || (word0(&rv) & Exp_mask) <= Exp_msk1
#endif
#endif
				) {
#ifdef SET_INEXACT
				if (!delta->x[0] && delta->wds <= 1)
					inexact = 0;
#endif
				break;
				}
			if (!delta->x[0] && delta->wds <= 1) {
				/* exact result */
#ifdef SET_INEXACT
				inexact = 0;
#endif
				break;
				}
			delta = lshift(delta,Log2P);
			if (delta == NULL)
				goto ovfl;
			if (cmp(delta, bs) > 0)
				goto drop_down;
			break;
			}
		if (i == 0) {
			/* exactly half-way between */
			if (dsign) {
				if ((word0(&rv) & Bndry_mask1) == Bndry_mask1
				 &&  word1(&rv) == (
#ifdef Avoid_Underflow
			(scale && (y = word0(&rv) & Exp_mask) <= 2*P*Exp_msk1)
		? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
#endif
						   0xffffffff)) {
					/*boundary case -- increment exponent*/
					if (word0(&rv) == Big0 && word1(&rv) == Big1)
						goto ovfl;
					word0(&rv) = (word0(&rv) & Exp_mask)
						+ Exp_msk1
#ifdef IBM
						| Exp_msk1 >> 4
#endif
						;
					word1(&rv) = 0;
#ifdef Avoid_Underflow
					dsign = 0;
#endif
					break;
					}
				}
			else if (!(word0(&rv) & Bndry_mask) && !word1(&rv)) {
 drop_down:
				/* boundary case -- decrement exponent */
#ifdef Sudden_Underflow /*{{*/
				L = word0(&rv) & Exp_mask;
#ifdef IBM
				if (L <  Exp_msk1)
#else
#ifdef Avoid_Underflow
				if (L <= (scale ? (2*P+1)*Exp_msk1 : Exp_msk1))
#else
				if (L <= Exp_msk1)
#endif /*Avoid_Underflow*/
#endif /*IBM*/
					goto undfl;
				L -= Exp_msk1;
#else /*Sudden_Underflow}{*/
#ifdef Avoid_Underflow
				if (scale) {
					L = word0(&rv) & Exp_mask;
					if (L <= (2*P+1)*Exp_msk1) {
						if (L > (P+2)*Exp_msk1)
							/* round even ==> */
							/* accept rv */
							break;
						/* rv = smallest denormal */
						goto undfl;
						}
					}
#endif /*Avoid_Underflow*/
				L = (word0(&rv) & Exp_mask) - Exp_msk1;
#endif /*Sudden_Underflow}}*/
				word0(&rv) = L | Bndry_mask1;
				word1(&rv) = 0xffffffff;
#ifdef IBM
				goto cont;
#else
				break;
#endif
				}
#ifndef ROUND_BIASED
#ifdef Avoid_Underflow
			if (Lsb1) {
				if (!(word0(&rv) & Lsb1))
					break;
				}
			else if (!(word1(&rv) & Lsb))
				break;
#else
			if (!(word1(&rv) & LSB))
				break;
#endif
#endif
			if (dsign)
#ifdef Avoid_Underflow
				dval(&rv) += sulp(&rv, scale);
#else
				dval(&rv) += ulp(&rv);
#endif
#ifndef ROUND_BIASED
			else {
#ifdef Avoid_Underflow
				dval(&rv) -= sulp(&rv, scale);
#else
				dval(&rv) -= ulp(&rv);
#endif
#ifndef Sudden_Underflow
				if (!dval(&rv))
					goto undfl;
#endif
				}
#ifdef Avoid_Underflow
			dsign = 1 - dsign;
#endif
#endif
			break;
			}
		if ((aadj = ratio(delta, bs)) <= 2.) {
			if (dsign)
				aadj = dval(&aadj1) = 1.;
			else if (word1(&rv) || word0(&rv) & Bndry_mask) {
#ifndef Sudden_Underflow
				if (word1(&rv) == Tiny1 && !word0(&rv))
					goto undfl;
#endif
				aadj = 1.;
				dval(&aadj1) = -1.;
				}
			else {
				/* special case -- power of FLT_RADIX to be */
				/* rounded down... */

				if (aadj < 2./FLT_RADIX)
					aadj = 1./FLT_RADIX;
				else
					aadj *= 0.5;
				dval(&aadj1) = -aadj;
				}
			}
		else {
			aadj *= 0.5;
			dval(&aadj1) = dsign ? aadj : -aadj;
#ifdef Check_FLT_ROUNDS
			switch(Rounding) {
				case 2: /* towards +infinity */
					dval(&aadj1) -= 0.5;
					break;
				case 0: /* towards 0 */
				case 3: /* towards -infinity */
					dval(&aadj1) += 0.5;
				}
#else
			if (Flt_Rounds == 0)
				dval(&aadj1) += 0.5;
#endif /*Check_FLT_ROUNDS*/
			}
		y = word0(&rv) & Exp_mask;

		/* Check for overflow */

		if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {
			dval(&rv0) = dval(&rv);
			word0(&rv) -= P*Exp_msk1;
			dval(&adj) = dval(&aadj1) * ulp(&rv);
			dval(&rv) += dval(&adj);
			if ((word0(&rv) & Exp_mask) >=
					Exp_msk1*(DBL_MAX_EXP+Bias-P)) {
				if (word0(&rv0) == Big0 && word1(&rv0) == Big1)
					goto ovfl;
				word0(&rv) = Big0;
				word1(&rv) = Big1;
				goto cont;
				}
			else
				word0(&rv) += P*Exp_msk1;
			}
		else {
#ifdef Avoid_Underflow
			if (scale && y <= 2*P*Exp_msk1) {
				if (aadj <= 0x7fffffff) {
					if ((z = aadj) <= 0)
						z = 1;
					aadj = z;
					dval(&aadj1) = dsign ? aadj : -aadj;
					}
				word0(&aadj1) += (2*P+1)*Exp_msk1 - y;
				}
			dval(&adj) = dval(&aadj1) * ulp(&rv);
			dval(&rv) += dval(&adj);
#else
#ifdef Sudden_Underflow
			if ((word0(&rv) & Exp_mask) <= P*Exp_msk1) {
				dval(&rv0) = dval(&rv);
				word0(&rv) += P*Exp_msk1;
				dval(&adj) = dval(&aadj1) * ulp(&rv);
				dval(&rv) += dval(&adj);
#ifdef IBM
				if ((word0(&rv) & Exp_mask) <  P*Exp_msk1)
#else
				if ((word0(&rv) & Exp_mask) <= P*Exp_msk1)
#endif
					{
					if (word0(&rv0) == Tiny0
					 && word1(&rv0) == Tiny1)
						goto undfl;
					word0(&rv) = Tiny0;
					word1(&rv) = Tiny1;
					goto cont;
					}
				else
					word0(&rv) -= P*Exp_msk1;
				}
			else {
				dval(&adj) = dval(&aadj1) * ulp(&rv);
				dval(&rv) += dval(&adj);
				}
#else /*Sudden_Underflow*/
			/* Compute dval(&adj) so that the IEEE rounding rules will
			 * correctly round rv + dval(&adj) in some half-way cases.
			 * If rv * ulp(&rv) is denormalized (i.e.,
			 * y <= (P-1)*Exp_msk1), we must adjust aadj to avoid
			 * trouble from bits lost to denormalization;
			 * example: 1.2e-307 .
			 */
			if (y <= (P-1)*Exp_msk1 && aadj > 1.) {
				dval(&aadj1) = (double)(int)(aadj + 0.5);
				if (!dsign)
					dval(&aadj1) = -dval(&aadj1);
				}
			dval(&adj) = dval(&aadj1) * ulp(&rv);
			dval(&rv) += adj;
#endif /*Sudden_Underflow*/
#endif /*Avoid_Underflow*/
			}
		z = word0(&rv) & Exp_mask;
#ifndef SET_INEXACT
#ifdef Avoid_Underflow
		if (!scale)
#endif
		if (y == z) {
			/* Can we stop now? */
			L = (Long)aadj;
			aadj -= L;
			/* The tolerances below are conservative. */
			if (dsign || word1(&rv) || word0(&rv) & Bndry_mask) {
				if (aadj < .4999999 || aadj > .5000001)
					break;
				}
			else if (aadj < .4999999/FLT_RADIX)
				break;
			}
#endif
 cont:
		Bfree(bb);
		Bfree(bd);
		Bfree(bs);
		Bfree(delta);
		}
	Bfree(bb);
	Bfree(bd);
	Bfree(bs);
	Bfree(bd0);
	Bfree(delta);
#ifdef SET_INEXACT
	if (inexact) {
		if (!oldinexact) {
			word0(&rv0) = Exp_1 + (70 << Exp_shift);
			word1(&rv0) = 0;
			dval(&rv0) += 1.;
			}
		}
	else if (!oldinexact)
		clear_inexact();
#endif
#ifdef Avoid_Underflow
	if (scale) {
		word0(&rv0) = Exp_1 - 2*P*Exp_msk1;
		word1(&rv0) = 0;
		dval(&rv) *= dval(&rv0);
#ifndef NO_ERRNO
		/* try to avoid the bug of testing an 8087 register value */
#ifdef IEEE_Arith
		if (!(word0(&rv) & Exp_mask))
#else
		if (word0(&rv) == 0 && word1(&rv) == 0)
#endif
			errno = ERANGE;
#endif
		}
#endif /* Avoid_Underflow */
#ifdef SET_INEXACT
	if (inexact && !(word0(&rv) & Exp_mask)) {
		/* set underflow bit */
		dval(&rv0) = 1e-300;
		dval(&rv0) *= dval(&rv0);
		}
#endif
 ret:
	if (se)
		*se = (char *)s;
	return sign ? -dval(&rv) : dval(&rv);
	}
DEF_STRONG(strtod);
@


1.6
log
@Wrap <stdlib.h> so that calls go direct and the symbols not in the
C standard are all weak.
Apply __{BEGIN,END}_HIDDEN_DECLS to gdtoa{,imp}.h, hiding the
arch-specific __strtorx, __ULtox_D2A, __strtorQ, __ULtoQ_D2A symbols.
@
text
@d117 1
a117 4
		if ((decimalpoint_cache = (char*)MALLOC(strlen(s0) + 1))) {
			strlcpy(decimalpoint_cache, s0, strlen(s0) + 1);
			s0 = decimalpoint_cache;
			}
@


1.5
log
@Rebase on gdtoa-20110428;  contains fixes for absurdly long inputs
(among other things).  Fixes mozilla crasher for the link i was
provided with.

With the massive local changes to teach that malloc can fail, fixes
for the vax, strlcpy, moving things to library namespaces.  Tested
on all architectures.
@
text
@d1105 1
a1105 1

@


1.4
log
@teach gdtoa & its subroutines that malloc can fail;  in which case
ecvt, fcvt, gcvt, *printf, strtof, strtod, strtold act per ieee
1003.1.  after these massive changes, remove unused files which
would not work now.  reported by Maksymilian Arciemowicz;  ok theo
@
text
@d60 22
d96 1
a96 1
	double aadj, aadj1, adj, rv, rv0;
d98 1
d100 4
a103 1
	Bigint *bb, *bb1, *bd, *bd0 = NULL, *bs, *delta;
d107 1
a107 1
#ifdef USE_LOCALE
d110 1
d114 1
a115 1
		size_t len;
d117 2
a118 3
		len = strlen(s0) + 1;
		if ((decimalpoint_cache = (char*)malloc(len))) {
			strlcpy(decimalpoint_cache, s0, len);
d121 1
d124 5
a128 2
#endif
#endif
d144 1
a144 1
	dval(rv) = 0.;
d167 1
a167 1
#ifndef NO_HEX_FP /*{{*/
d176 1
a176 1
#if defined(FE_DOWNWARD) && defined(FE_TONEAREST) && defined(FE_TOWARDZERO) && defined(FE_UPWARD) /*{{*/
a177 1
#ifdef Honor_FLT_ROUNDS /*{{*/
d179 1
a179 8
#else /*}{*/
			switch(fegetround()) {
			  case FE_TOWARDZERO:	fpi1.rounding = 0; break;
			  case FE_UPWARD:	fpi1.rounding = 2; break;
			  case FE_DOWNWARD:	fpi1.rounding = 3;
			  }
#endif /*}}*/
#else /*}{*/
d181 1
a181 1
#endif /*}}*/
d183 2
a189 2
			  case STRTOG_NoMemory:
				goto ovfl;
d200 1
a200 1
#endif
d308 2
a309 2
					word0(rv) = 0x7ff00000;
					word1(rv) = 0;
d320 2
a321 2
						word0(rv) = 0x7ff00000 | bits[1];
						word1(rv) = bits[0];
d325 2
a326 2
						word0(rv) = NAN_WORD0;
						word1(rv) = NAN_WORD1;
d350 1
a350 1
	dval(rv) = y;
d356 1
a356 1
		dval(rv) = tens[k - 9] * dval(rv) + z;
d367 1
d376 1
a376 1
					rv = -rv;
d380 1
a380 1
				/* rv = */ rounded_product(dval(rv), tens[e]);
d392 1
a392 1
					rv = -rv;
d397 1
a397 1
				dval(rv) *= tens[i];
d403 3
a405 3
				word0(rv) -= P*Exp_msk1;
				/* rv = */ rounded_product(dval(rv), tens[e]);
				if ((word0(rv) & Exp_mask)
d408 1
a408 1
				word0(rv) += P*Exp_msk1;
d410 1
a410 1
				/* rv = */ rounded_product(dval(rv), tens[e]);
d420 1
a420 1
				rv = -rv;
d424 1
a424 1
			/* rv = */ rounded_quotient(dval(rv), tens[-e]);
d428 1
d456 1
a456 1
			dval(rv) *= tens[i];
a459 3
#ifndef NO_ERRNO
				errno = ERANGE;
#endif
d466 2
a467 2
					word0(rv) = Big0;
					word1(rv) = Big1;
d470 2
a471 2
					word0(rv) = Exp_mask;
					word1(rv) = 0;
d474 2
a475 2
				word0(rv) = Exp_mask;
				word1(rv) = 0;
d479 2
a480 2
				dval(rv0) = 1e300;
				dval(rv0) *= dval(rv0);
d483 2
a484 2
				word0(rv) = Big0;
				word1(rv) = Big1;
d486 11
a496 2
				if (bd0)
					goto retfree;
d502 1
a502 1
					dval(rv) *= bigtens[j];
d504 3
a506 3
			word0(rv) -= P*Exp_msk1;
			dval(rv) *= bigtens[j];
			if ((z = word0(rv) & Exp_mask)
d512 2
a513 2
				word0(rv) = Big0;
				word1(rv) = Big1;
d516 1
a516 1
				word0(rv) += P*Exp_msk1;
d522 1
a522 1
			dval(rv) /= tens[i];
d531 2
a532 2
					dval(rv) *= tinytens[j];
			if (scale && (j = 2*P + 1 - ((word0(rv) & Exp_mask)
d536 1
a536 1
					word1(rv) = 0;
d538 1
a538 1
					 word0(rv) = (P+2)*Exp_msk1;
d540 1
a540 1
					 word0(rv) &= 0xffffffff << j-32;
d543 1
a543 1
					word1(rv) &= 0xffffffff << j;
d548 1
a548 1
					dval(rv) *= tinytens[j];
d550 5
a554 5
			dval(rv0) = dval(rv);
			dval(rv) *= tinytens[j];
			if (!dval(rv)) {
				dval(rv) = 2.*dval(rv0);
				dval(rv) *= tinytens[j];
d556 1
a556 1
				if (!dval(rv)) {
d558 2
a559 7
					dval(rv) = 0.;
#ifndef NO_ERRNO
					errno = ERANGE;
#endif
					if (bd0)
						goto retfree;
					goto ret;
d562 2
a563 2
				word0(rv) = Tiny0;
				word1(rv) = Tiny1;
d576 1
a576 1
	bd0 = s2b(s0, nd0, nd, y);
d585 1
a585 1
		bb = d2b(dval(rv), &bbe, &bbbits);	/* rv = bb * 2^bbe */
d610 2
d614 9
a622 4
		if (i < Emin)	/* denormal */
			j += P - Emin;
		else
			j = P + 1 - bbbits;
d632 1
a632 1
		i = j + bbbits - 1;	/* logb(rv) */
d666 1
a666 1
		}
d671 1
a671 1
		}
d676 1
a676 1
		}
d681 1
a681 1
		}
d701 1
a701 1
						adj = 1.;
d706 4
a709 4
					adj = -1.;
					if (!word1(rv)
					 && !(word0(rv) & Frac_mask)) {
						y = word0(rv) & Exp_mask;
d720 1
a720 1
							adj = -0.5;
d725 1
a725 1
					if (scale && (y = word0(rv) & Exp_mask)
d727 1
a727 1
					  word0(adj) += (2*P+1)*Exp_msk1 - y;
d730 1
a730 1
					if ((word0(rv) & Exp_mask) <=
d732 3
a734 3
						word0(rv) += P*Exp_msk1;
						dval(rv) += adj*ulp(dval(rv));
						word0(rv) -= P*Exp_msk1;
d739 1
a739 1
					dval(rv) += adj*ulp(dval(rv));
d743 7
a749 7
			adj = ratio(delta, bs);
			if (adj < 1.)
				adj = 1.;
			if (adj <= 0x7ffffffe) {
				/* adj = Rounding ? ceil(adj) : floor(adj); */
				y = adj;
				if (y != adj) {
d752 1
a752 1
					adj = y;
d756 2
a757 2
			if (scale && (y = word0(rv) & Exp_mask) <= 2*P*Exp_msk1)
				word0(adj) += (2*P+1)*Exp_msk1 - y;
d760 3
a762 3
			if ((word0(rv) & Exp_mask) <= P*Exp_msk1) {
				word0(rv) += P*Exp_msk1;
				adj *= ulp(dval(rv));
d764 1
a764 1
					dval(rv) += adj;
d766 2
a767 2
					dval(rv) -= adj;
				word0(rv) -= P*Exp_msk1;
d772 1
a772 1
			adj *= ulp(dval(rv));
d774 1
a774 1
				if (word0(rv) == Big0 && word1(rv) == Big1)
d776 1
a776 1
				dval(rv) += adj;
d779 1
a779 1
				dval(rv) -= adj;
d788 1
a788 1
			if (dsign || word1(rv) || word0(rv) & Bndry_mask
d791 1
a791 1
			 || (word0(rv) & Exp_mask) <= (2*P+1)*Exp_msk1
d793 1
a793 1
			 || (word0(rv) & Exp_mask) <= Exp_msk1
d820 2
a821 2
				if ((word0(rv) & Bndry_mask1) == Bndry_mask1
				 &&  word1(rv) == (
d823 1
a823 1
			(scale && (y = word0(rv) & Exp_mask) <= 2*P*Exp_msk1)
d828 3
a830 1
					word0(rv) = (word0(rv) & Exp_mask)
d836 1
a836 1
					word1(rv) = 0;
d843 1
a843 1
			else if (!(word0(rv) & Bndry_mask) && !word1(rv)) {
d847 1
a847 1
				L = word0(rv) & Exp_mask;
d862 1
a862 1
					L = word0(rv) & Exp_mask;
d873 1
a873 1
				L = (word0(rv) & Exp_mask) - Exp_msk1;
d875 2
a876 2
				word0(rv) = L | Bndry_mask1;
				word1(rv) = 0xffffffff;
d884 6
a889 1
			if (!(word1(rv) & LSB))
d891 4
d897 5
a901 1
				dval(rv) += ulp(dval(rv));
d904 5
a908 1
				dval(rv) -= ulp(dval(rv));
d910 1
a910 1
				if (!dval(rv))
d922 2
a923 2
				aadj = aadj1 = 1.;
			else if (word1(rv) || word0(rv) & Bndry_mask) {
d925 1
a925 1
				if (word1(rv) == Tiny1 && !word0(rv))
d929 1
a929 1
				aadj1 = -1.;
d939 1
a939 1
				aadj1 = -aadj;
d944 1
a944 1
			aadj1 = dsign ? aadj : -aadj;
d948 1
a948 1
					aadj1 -= 0.5;
d952 1
a952 1
					aadj1 += 0.5;
d956 1
a956 1
				aadj1 += 0.5;
d959 1
a959 1
		y = word0(rv) & Exp_mask;
d964 5
a968 5
			dval(rv0) = dval(rv);
			word0(rv) -= P*Exp_msk1;
			adj = aadj1 * ulp(dval(rv));
			dval(rv) += adj;
			if ((word0(rv) & Exp_mask) >=
d970 1
a970 1
				if (word0(rv0) == Big0 && word1(rv0) == Big1)
d972 2
a973 2
				word0(rv) = Big0;
				word1(rv) = Big1;
d977 1
a977 1
				word0(rv) += P*Exp_msk1;
d986 1
a986 1
					aadj1 = dsign ? aadj : -aadj;
d988 1
a988 1
				word0(aadj1) += (2*P+1)*Exp_msk1 - y;
d990 2
a991 2
			adj = aadj1 * ulp(dval(rv));
			dval(rv) += adj;
d994 5
a998 5
			if ((word0(rv) & Exp_mask) <= P*Exp_msk1) {
				dval(rv0) = dval(rv);
				word0(rv) += P*Exp_msk1;
				adj = aadj1 * ulp(dval(rv));
				dval(rv) += adj;
d1000 1
a1000 1
				if ((word0(rv) & Exp_mask) <  P*Exp_msk1)
d1002 1
a1002 1
				if ((word0(rv) & Exp_mask) <= P*Exp_msk1)
d1005 2
a1006 2
					if (word0(rv0) == Tiny0
					 && word1(rv0) == Tiny1)
d1008 2
a1009 2
					word0(rv) = Tiny0;
					word1(rv) = Tiny1;
d1013 1
a1013 1
					word0(rv) -= P*Exp_msk1;
d1016 2
a1017 2
				adj = aadj1 * ulp(dval(rv));
				dval(rv) += adj;
d1020 3
a1022 3
			/* Compute adj so that the IEEE rounding rules will
			 * correctly round rv + adj in some half-way cases.
			 * If rv * ulp(rv) is denormalized (i.e.,
d1028 1
a1028 1
				aadj1 = (double)(int)(aadj + 0.5);
d1030 1
a1030 1
					aadj1 = -aadj1;
d1032 2
a1033 2
			adj = aadj1 * ulp(dval(rv));
			dval(rv) += adj;
d1037 1
a1037 1
		z = word0(rv) & Exp_mask;
d1047 1
a1047 1
			if (dsign || word1(rv) || word0(rv) & Bndry_mask) {
d1061 5
d1069 3
a1071 3
			word0(rv0) = Exp_1 + (70 << Exp_shift);
			word1(rv0) = 0;
			dval(rv0) += 1.;
d1079 3
a1081 3
		word0(rv0) = Exp_1 - 2*P*Exp_msk1;
		word1(rv0) = 0;
		dval(rv) *= dval(rv0);
d1085 1
a1085 1
		if (!(word0(rv) & Exp_mask))
d1087 1
a1087 1
		if (word0(rv) == 0 && word1(rv) == 0)
d1094 1
a1094 1
	if (inexact && !(word0(rv) & Exp_mask)) {
d1096 2
a1097 2
		dval(rv0) = 1e-300;
		dval(rv0) *= dval(rv0);
a1099 6
 retfree:
	Bfree(bb);
	Bfree(bd);
	Bfree(bs);
	Bfree(bd0);
	Bfree(delta);
d1103 1
a1103 1
	return sign ? -dval(rv) : dval(rv);
@


1.3
log
@strcpy -> strlcpy; ok mbalmer@@ martynas@@
@
text
@d77 1
a77 1
	Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
d166 2
a335 1
	bd0 = 0;
d552 2
d557 2
d561 2
d564 2
d622 2
d625 2
d630 1
a630 1
		if (bb2 > 0)
d632 4
a635 1
		if (bd5 > 0)
d637 4
a640 1
		if (bd2 > 0)
d642 4
a645 1
		if (bs2 > 0)
d647 3
d651 2
d685 2
d779 2
@


1.2
log
@bugfix update to gdtoa 2008-10-10.   ok millert@@, tested by many
@
text
@d88 1
d90 3
a92 2
		if ((decimalpoint_cache = (char*)malloc(strlen(s0) + 1))) {
			strcpy(decimalpoint_cache, s0);
@


1.1
log
@- replace dtoa w/ David's gdtoa, version 2008-03-15
- provide proper dtoa locks
- use the real strtof implementation
- add strtold, __hdtoa, __hldtoa
- add %a/%A support
- don't lose precision in printf, don't round to double anymore
- implement extended-precision versions of libc functions: fpclassify,
isnan, isinf, signbit, isnormal, isfinite, now that the ieee.h is
fixed
- separate vax versions of strtof, and __hdtoa
- add complex math support.  added functions: cacos, casin, catan,
ccos, csin, ctan, cacosh, casinh, catanh, ccosh, csinh, ctanh, cexp,
clog, cabs, cpow, csqrt, carg, cimag, conj, cproj, creal, cacosf,
casinf, catanf, ccosf, csinf, ctanf, cacoshf, casinhf, catanhf,
ccoshf, csinhf, ctanhf, cexpf, clogf, cabsf, cpowf, csqrtf, cargf,
cimagf, conjf, cprojf, crealf
- add fdim, fmax, fmin
- add log2. (adapted implementation e_log.c.  could be more acruate
& faster, but it's good enough for now)
- remove wrappers & cruft in libm, supposed to work-around mistakes
in SVID, etc.;  use ieee versions.  fixes issues in python 2.6 for
djm@@
- make _digittoint static
- proper definitions for i386, and amd64 in ieee.h
- sh, powerpc don't really have extended-precision
- add missing definitions for mips64 (quad), m{6,8}k (96-bit) float.h
for LDBL_*
- merge lead to frac for m{6,8}k, for gdtoa to work properly
- add FRAC*BITS & EXT_TO_ARRAY32 definitions in ieee.h, for hdtoa&ldtoa
to use
- add EXT_IMPLICIT_NBIT definition, which indicates implicit
normalization bit
- add regression tests for libc: fpclassify and printf
- arith.h & gd_qnan.h definitions
- update ieee.h: hppa doesn't have quad-precision, hppa64 does
- add missing prototypes to gdtoaimp
- on 64-bit platforms make sure gdtoa doesn't use a long when it
really wants an int
- etc., what i may have forgotten...
- bump libm major, due to removed&changed symbols
- no libc bump, since this is riding on djm's libc major crank from
a day ago

discussed with / requested by / testing theo, sthen@@, djm@@, jsg@@,
merdely@@, jsing@@, tedu@@, brad@@, jakemsr@@, and others.
looks good to millert@@
parts of the diff ok kettenis@@

this commit does not include:
- man page changes
@
text
@d45 1
a45 1
/* The factor of 2^53 in tinytens[4] helps us avoid setting the underflow */
d48 1
a48 1
		9007199254740992.e-256
a53 1
#define Rounding rounding
d81 29
a109 3
#ifdef Honor_FLT_ROUNDS
	int rounding;
#endif
d135 1
a135 1
#ifndef NO_HEX_FP
d144 1
a144 1
#if defined(FE_DOWNWARD) && defined(FE_TONEAREST) && defined(FE_TOWARDZERO) && defined(FE_UPWARD)
d146 3
d154 2
a155 1
#else
d157 1
a157 1
#endif
d189 6
a194 1
	if (c == *localeconv()->decimal_point)
d196 2
a197 1
	if (c == '.')
a198 1
		{
a199 1
		c = *++s;
d228 1
a228 1
		}
d415 1
a415 1
	if ((rounding = Flt_Rounds) >= 2) {
d417 1
a417 1
			rounding = rounding == 2 ? 0 : 2;
d419 2
a420 2
			if (rounding != 2)
				rounding = 0;
d439 1
a439 1
				switch(rounding) {
d570 1
a570 1
		if (rounding != 1)
d628 1
a628 1
		if (rounding != 1) {
d638 1
a638 1
				if (rounding) {
d684 1
a684 1
				/* adj = rounding ? ceil(adj) : floor(adj); */
d687 1
a687 1
					if (!((rounding>>1) ^ dsign))
d710 3
a712 1
			if (dsign)
d714 1
d807 1
a807 1
#endif /*Sudden_Underflow}*/
d995 3
d999 1
@

