head	1.28;
access;
symbols
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.16
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.14
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.12
	OPENBSD_5_0:1.17.0.10
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.8
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.6
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.8
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.10
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.8
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.28
date	2016.05.30.02.53.29;	author guenther;	state Exp;
branches;
next	1.27;
commitid	ZyVH79ruiyfArP3e;

1.27
date	2016.05.29.22.42.24;	author guenther;	state Exp;
branches;
next	1.26;
commitid	rJC8CpRkooAcbLSQ;

1.26
date	2015.11.26.07.26.50;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	aq6Uyo2xFhXwf5TA;

1.25
date	2015.09.14.12.09.35;	author guenther;	state Exp;
branches;
next	1.24;
commitid	yWXDlGtjhlCn6h5R;

1.24
date	2015.09.13.20.57.28;	author guenther;	state Exp;
branches;
next	1.23;
commitid	xpGEzBDorlPKpzSI;

1.23
date	2015.09.05.14.04.33;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	vZDbutvhymWp9pwT;

1.22
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	0DYulI8hhujBHMcR;

1.21
date	2015.01.14.23.36.16;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	tiEBIWumVnjfOhkT;

1.20
date	2014.05.25.17.47.04;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2013.09.30.12.02.36;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.05.17.19.00;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.17.07.07.23;	author moritz;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.05.13.02.16;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.03.48.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.20.01.35.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.02.20.18.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.27.00.58.57;	author lebel;	state Exp;
branches;
next	1.10;

1.10
date	99.08.17.09.13.13;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.04.29.21.25.20;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.05.19.19.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.28.02.22.35;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.19.08.35.08;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.08.05.13.38.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.01.07.09.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.01.06.47.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.02.08.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.24.12.56.18;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Stop publicly declaring _yp_dobind() and struct dom_binding, closing out
a rant Theo wrote 24 years ago.  Mark __ypexclude_{add,is,free}() as hidden

"get off my lawn!" deraadt@@
@
text
@/*	$OpenBSD: yp_bind.c,v 1.27 2016/05/29 22:42:24 guenther Exp $ */
/*
 * Copyright (c) 1992, 1993, 1996 Theo de Raadt <deraadt@@theos.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <paths.h>

#include <rpc/rpc.h>
#include <rpc/xdr.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "ypinternal.h"

struct dom_binding *_ypbindlist;
char _yp_domain[HOST_NAME_MAX+1];
int _yplib_timeout = 10;

int
_yp_dobind(const char *dom, struct dom_binding **ypdb)
{
	static pid_t	pid = -1;
	char            path[PATH_MAX];
	struct dom_binding *ysd, *ysd2;
	struct ypbind_resp ypbr;
	struct timeval  tv;
	struct sockaddr_in clnt_sin;
	struct ypbind_binding *bn;
	int             clnt_sock, fd;
	pid_t		gpid;
	CLIENT         *client;
	int             new = 0, r;
	u_short		port;

	/*
	 * test if YP is running or not
	 */
	if ((fd = open(YPBINDLOCK, O_RDONLY)) == -1)
		return YPERR_YPBIND;
	if (!(flock(fd, LOCK_EX | LOCK_NB) == -1 && errno == EWOULDBLOCK)) {
		(void)close(fd);
		return YPERR_YPBIND;
	}
	(void)close(fd);

	gpid = getpid();
	if (!(pid == -1 || pid == gpid)) {
		ysd = _ypbindlist;
		while (ysd) {
			if (ysd->dom_client)
				clnt_destroy(ysd->dom_client);
			ysd2 = ysd->dom_pnext;
			free(ysd);
			ysd = ysd2;
		}
		_ypbindlist = NULL;
	}
	pid = gpid;

	if (ypdb != NULL)
		*ypdb = NULL;

	if (dom == NULL || strlen(dom) == 0)
		return YPERR_BADARGS;

	for (ysd = _ypbindlist; ysd; ysd = ysd->dom_pnext)
		if (strcmp(dom, ysd->dom_domain) == 0)
			break;
	if (ysd == NULL) {
		if ((ysd = calloc(1, sizeof *ysd)) == NULL)
			return YPERR_RESRC;
		ysd->dom_socket = -1;
		ysd->dom_vers = 0;
		new = 1;
	}
again:
	if (ysd->dom_vers == 0) {
		r = snprintf(path, sizeof(path), "%s/%s.%d",
		    BINDINGDIR, dom, 2);
		if (r < 0 || r >= sizeof(path)) {
			if (new)
				free(ysd);
			return YPERR_BADARGS;
		}
		if ((fd = open(path, O_RDONLY)) == -1) {
			/*
			 * no binding file, YP is dead, or not yet fully
			 * alive.
			 */
			goto trynet;
		}
		if (flock(fd, LOCK_EX | LOCK_NB) == -1 &&
		    errno == EWOULDBLOCK) {
			struct iovec    iov[2];
			u_short         ypb_port;

			/*
			 * we fetch the ypbind port number, but do
			 * nothing with it.
			 */
			iov[0].iov_base = (caddr_t) &ypb_port;
			iov[0].iov_len = sizeof ypb_port;
			iov[1].iov_base = (caddr_t) &ypbr;
			iov[1].iov_len = sizeof ypbr;

			r = readv(fd, iov, 2);
			if (r != iov[0].iov_len + iov[1].iov_len) {
				(void)close(fd);
				ysd->dom_vers = -1;
				goto again;
			}
			(void)close(fd);
			goto gotdata;
		} else {
			/* no lock on binding file, YP is dead. */
			(void)close(fd);
			if (new)
				free(ysd);
			return YPERR_YPBIND;
		}
	}
trynet:
	if (ysd->dom_vers == -1 || ysd->dom_vers == 0) {
		(void)memset(&clnt_sin, 0, sizeof clnt_sin);
		clnt_sin.sin_len = sizeof(struct sockaddr_in);
		clnt_sin.sin_family = AF_INET;
		clnt_sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

		clnt_sock = RPC_ANYSOCK;
		client = clnttcp_create(&clnt_sin, YPBINDPROG, YPBINDVERS,
		    &clnt_sock, 0, 0);
		if (client == NULL) {
			clnt_pcreateerror("clnttcp_create");
			if (new)
				free(ysd);
			switch (rpc_createerr.cf_error.re_errno) {
			case ECONNREFUSED:
				return YPERR_YPBIND;
			case ENOMEM:
				return YPERR_RESRC;
			default:
				return YPERR_YPERR;
			}
		}
		if (ntohs(clnt_sin.sin_port) >= IPPORT_RESERVED ||
		    ntohs(clnt_sin.sin_port) == 20) {
			/*
			 * YP was not running, but someone has registered
			 * ypbind with portmap -- this simply means YP is
			 * not running.
			 */
			clnt_destroy(client);
			if (new)
				free(ysd);
			return YPERR_YPBIND;
		}
		tv.tv_sec = _yplib_timeout;
		tv.tv_usec = 0;
		r = clnt_call(client, YPBINDPROC_DOMAIN, xdr_domainname,
		    &dom, xdr_ypbind_resp, &ypbr, tv);
		if (r != RPC_SUCCESS) {
			clnt_destroy(client);
			ysd->dom_vers = -1;
			goto again;
		}
		clnt_destroy(client);
gotdata:
		bn = &ypbr.ypbind_resp_u.ypbind_bindinfo;
		memcpy(&port, &bn->ypbind_binding_port, sizeof port);
		if (ntohs(port) >= IPPORT_RESERVED ||
		    ntohs(port) == 20) {
			/*
			 * This is bullshit -- the ypbind wants me to
			 * communicate to an insecure ypserv.  We are
			 * within rights to syslog this as an attack,
			 * but for now we'll simply ignore it; real YP
			 * is obviously not running.
			 */
			if (new)
				free(ysd);
			return YPERR_YPBIND;
		}
		(void)memset(&ysd->dom_server_addr, 0,
		    sizeof ysd->dom_server_addr);
		ysd->dom_server_addr.sin_len = sizeof(struct sockaddr_in);
		ysd->dom_server_addr.sin_family = AF_INET;
		memcpy(&ysd->dom_server_addr.sin_port,
		    &bn->ypbind_binding_port,
		    sizeof(ysd->dom_server_addr.sin_port));
		memcpy(&ysd->dom_server_addr.sin_addr.s_addr,
		    &bn->ypbind_binding_addr,
		    sizeof(ysd->dom_server_addr.sin_addr.s_addr));
		ysd->dom_server_port = ysd->dom_server_addr.sin_port;
		ysd->dom_vers = YPVERS;
		strlcpy(ysd->dom_domain, dom, sizeof ysd->dom_domain);
	}
	tv.tv_sec = _yplib_timeout / 2;
	tv.tv_usec = 0;
	if (ysd->dom_client)
		clnt_destroy(ysd->dom_client);
	ysd->dom_socket = RPC_ANYSOCK;
	ysd->dom_client = clntudp_create(&ysd->dom_server_addr,
	    YPPROG, YPVERS, tv, &ysd->dom_socket);
	if (ysd->dom_client == NULL) {
		clnt_pcreateerror("clntudp_create");
		ysd->dom_vers = -1;
		goto again;
	}
	if (fcntl(ysd->dom_socket, F_SETFD, FD_CLOEXEC) == -1)
		perror("fcntl: F_SETFD");

	if (new) {
		ysd->dom_pnext = _ypbindlist;
		_ypbindlist = ysd;
	}
	if (ypdb != NULL)
		*ypdb = ysd;
	return 0;
}

void
_yp_unbind(struct dom_binding *ypb)
{
	clnt_destroy(ypb->dom_client);
	ypb->dom_client = NULL;
	ypb->dom_socket = -1;
}

int
yp_bind(const char *dom)
{
	return _yp_dobind(dom, NULL);
}
DEF_WEAK(yp_bind);

void
yp_unbind(const char *dom)
{
	struct dom_binding *ypb, *ypbp;

	ypbp = NULL;
	for (ypb = _ypbindlist; ypb; ypb = ypb->dom_pnext) {
		if (strcmp(dom, ypb->dom_domain) == 0) {
			clnt_destroy(ypb->dom_client);
			if (ypbp)
				ypbp->dom_pnext = ypb->dom_pnext;
			else
				_ypbindlist = ypb->dom_pnext;
			free(ypb);
			return;
		}
		ypbp = ypb;
	}
}
@


1.27
log
@_yp_bind(), _ypbindlist, _yp_domain, and _yplib_timeout are no longer
exported, so declare them as hidden to avoid pointless GOT relocations

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.26 2015/11/26 07:26:50 deraadt Exp $ */
a250 1
DEF_WEAK(_yp_dobind);
@


1.26
log
@remove the "YP server for domain %s not responding, still trying" code.
For years, it talked to stderr.  That was wrong.  Then it was converted
to opening /dev/tty, which is also wrong (pledge says so).  Upon
reconsideration people in these more modern times have adapted to all
sorts of services not being available, so axe the alert and retry
silently.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.25 2015/09/14 12:09:35 guenther Exp $ */
a259 1
DEF_WEAK(_yp_unbind);
@


1.25
log
@Wrap _yp_check() and _yp_unbind() so internal calls go direct and they're weak
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.24 2015/09/13 20:57:28 guenther Exp $ */
a63 1
	int             count = 0;
a192 13
			if (new == 0 || count) {
				int fd;

				fd = open(_PATH_TTY,
				    O_WRONLY | O_NONBLOCK | O_NOCTTY);
				if (fd != -1) {
					dprintf(fd,
			"YP server for domain %s not responding, still trying\n",
					    dom);
					close(fd);
				}
			}
			count++;
@


1.24
log
@Wrap <rpcsvc/ypclnt.h> so that calls go direct and the symbols are all weak
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.23 2015/09/05 14:04:33 deraadt Exp $ */
d274 1
@


1.23
log
@rather than assuming stderr is alive, open + dprintf to /dev/tty
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.22 2015/01/16 16:48:51 deraadt Exp $ */
d265 1
d280 1
@


1.22
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.21 2015/01/14 23:36:16 deraadt Exp $ */
d38 2
d194 12
a205 4
			if (new == 0 || count)
				fprintf(stderr,
		    "YP server for domain %s not responding, still trying\n",
				    dom);
@


1.21
log
@change _yp_domain[] to HOST_NAME_MAX+1, and re-arrange those who include
it to get limits.h early enough
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.20 2014/05/25 17:47:04 tedu Exp $ */
a27 1
#include <sys/param.h>
d37 1
@


1.20
log
@use calloc, from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.19 2013/09/30 12:02:36 millert Exp $ */
d45 1
a45 1
char _yp_domain[MAXHOSTNAMELEN];
@


1.19
log
@Use PATH_MAX, NAME_MAX and LOGIN_NAME_MAX not MAXPATHNAMELEN,
MAXNAMLEN or MAXLOGNAME where possible.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.18 2013/04/29 00:28:23 okan Exp $ */
d100 1
a100 1
		if ((ysd = malloc(sizeof *ysd)) == NULL)
a101 1
		(void)memset(ysd, 0, sizeof *ysd);
@


1.18
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.17 2009/06/05 17:19:00 schwarze Exp $ */
d52 1
a52 1
	char            path[MAXPATHLEN];
@


1.17
log
@improve yp_bind(3) error reporting after clnttcp_create(3) failure:
map ECONNREFUSED -> YPERR_YPBIND, ENOMEM -> YPERR_RESRC, else YPERR_YPERR
while here, malloc(3) failure should raise YPERR_RESRC, not YPERR_YPERR
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.16 2007/09/17 07:07:23 moritz Exp $ */
d245 1
a245 1
	if (fcntl(ysd->dom_socket, F_SETFD, 1) == -1)
@


1.16
log
@Check snprintf(3) return value for error or truncation.
Mostly path construction, where truncation could be bad.

ok and input from deraadt@@ millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.15 2005/08/05 13:02:16 espie Exp $ */
d101 1
a101 1
			return YPERR_YPERR;
d167 8
a174 1
			return YPERR_YPBIND;
@


1.15
log
@- remove rcsid
- put all the YPMATCHCACHE code into a #ifdef, proper
- remove all extra header files that are not needed

okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d109 1
a109 1
		(void) snprintf(path, sizeof(path), "%s/%s.%d",
d111 5
@


1.14
log
@remove terms 3 & 4 on my own software
@
text
@d1 1
a26 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.13 2002/07/20 01:35:34 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.13
log
@ansi
@
text
@d2 1
a2 2
 * Copyright (c) 1996 Theo de Raadt <deraadt@@theos.com>
 * Copyright (c) 1992, 1993 Theo de Raadt <deraadt@@theos.com>
a12 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d28 1
a28 1
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.12 2002/01/02 20:18:32 deraadt Exp $";
@


1.12
log
@more pid_t use
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.11 2001/06/27 00:58:57 lebel Exp $";
d58 1
a58 3
_yp_dobind(dom, ypdb)
	const char     *dom;
	struct dom_binding **ypdb;
d216 1
a216 1
		(void)memset(&ysd->dom_server_addr, 0, 
d255 1
a255 2
_yp_unbind(ypb)
	struct dom_binding *ypb;
d263 1
a263 2
yp_bind(dom)
	const char     *dom;
d269 1
a269 2
yp_unbind(dom)
	const char     *dom;
@


1.11
log
@use strlcpy vs strncpy+a[len-1]='\0'.  millert@@ ok.
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.10 1999/08/17 09:13:13 millert Exp $";
d62 1
a62 1
	static int      pid = -1;
d69 2
a70 1
	int             clnt_sock, fd, gpid;
@


1.10
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.9 1997/04/29 21:25:20 deraadt Exp $";
d229 1
a229 2
		(void)strncpy(ysd->dom_domain, dom, sizeof ysd->dom_domain-1);
		ysd->dom_domain[sizeof ysd->dom_domain-1] = '\0';
@


1.9
log
@possible buf oflow
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.8 1997/02/05 19:19:49 deraadt Exp $";
a39 1
#include <sys/file.h>
d42 1
@


1.8
log
@that cannot be right
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.7 1997/01/28 02:22:35 deraadt Exp $";
d229 2
a230 1
		(void)strcpy(ysd->dom_domain, dom);
@


1.7
log
@encourage a few more udp whacks at the server
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.6 1996/08/19 08:35:08 tholo Exp $";
d231 1
a231 1
	tv.tv_sec = _yplib_timeout / 4;
@


1.6
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.5 1996/08/05 13:38:54 deraadt Exp $";
d231 1
a231 1
	tv.tv_sec = _yplib_timeout / 2;
@


1.5
log
@check for port 20
@
text
@a0 2
/*	$OpenBSD: yp_bind.c,v 1.4 1996/07/01 07:09:10 deraadt Exp $	 */

d34 2
a35 2
static char *rcsid = "$OpenBSD: yp_bind.c,v 1.4 1996/07/01 07:09:10 deraadt Exp $";
#endif
@


1.4
log
@update rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: yp_bind.c,v 1.3 1996/07/01 06:47:35 deraadt Exp $	 */
d36 1
a36 1
static char *rcsid = "$OpenBSD$";
d176 2
a177 1
		if (ntohs(clnt_sin.sin_port) >= IPPORT_RESERVED) {
d206 2
a207 1
		if (ntohs(port) >= IPPORT_RESERVED) {
@


1.3
log
@streamline, check ports
@
text
@d1 1
a1 2
/*	$OpenBSD: yp_bind.c,v 1.2 1996/05/22 02:08:35 deraadt Exp $	 */
/*	$NetBSD: yplib.c,v 1.17 1996/02/04 23:26:26 jtc Exp $	 */
d5 1
a5 1
 * Copyright (c) 1992, 1993, 1996 Theo de Raadt <deraadt@@theos.com>
d36 1
a36 1
static char rcsid[] = "$NetBSD: yplib.c,v 1.17 1996/02/04 23:26:26 jtc Exp $";
@


1.2
log
@repair return values, more checking
@
text
@d1 1
a1 1
/*	$OpenBSD: yplib.c,v 1.4 1996/03/09 02:43:01 niklas Exp $	 */
d5 2
a6 1
 * Copyright (c) 1992, 1993 Theo de Raadt <deraadt@@theos.com>
d71 1
d76 1
a133 1
			struct ypbind_resp ybr;
a134 1
			struct ypbind_binding *bn;
d136 5
a140 1
			iov[0].iov_base = (caddr_t) & ypb_port;
d142 2
a143 2
			iov[1].iov_base = (caddr_t) & ybr;
			iov[1].iov_len = sizeof ybr;
a150 15
			(void)memset(&ysd->dom_server_addr, 0,
			    sizeof ysd->dom_server_addr);
			ysd->dom_server_addr.sin_len =
			    sizeof(struct sockaddr_in);
			ysd->dom_server_addr.sin_family = AF_INET;
			bn = &ybr.ypbind_resp_u.ypbind_bindinfo;
			memcpy(&ysd->dom_server_addr.sin_port,
			    &bn->ypbind_binding_port,
			    sizeof(ysd->dom_server_addr.sin_port));
				
			memcpy(&ysd->dom_server_addr.sin_addr,
			    &bn->ypbind_binding_addr,
			    sizeof(ysd->dom_server_addr.sin_addr));

			ysd->dom_server_port = ysd->dom_server_addr.sin_port;
d152 1
a152 1
			goto gotit;
a162 1
		struct ypbind_binding *bn;
d177 11
d196 1
a196 1
					dom);
d203 15
a217 1

a221 1
		bn = &ypbr.ypbind_resp_u.ypbind_bindinfo;
a228 1
gotit:
a290 1
	return;
@


1.1
log
@yp_prot.h lies -> use yp.h (from yp.x) instead, change lots of structure
accesses to match. change xdr_domainname() and some other functions to
take "char **" instead of "char *", as rpcgen intended -- helps programs
linking against rpcgen output of yp.x.  yp_all() should not free it's
return value. split xdryp.c and yplib.c into ~20 files so binaries like
"csh" need not link in functions like yp_maplist(). NIS+'s YP emulation
code lacks YPPROC_ORDER... attempt to deal nicely.
@
text
@d147 1
a147 1
				     sizeof ysd->dom_server_addr);
d149 1
a149 1
				sizeof(struct sockaddr_in);
a158 1
				
d181 1
a181 1
					&clnt_sock, 0, 0);
d191 1
a191 1
			      &dom, xdr_ypbind_resp, &ypbr, tv);
d205 1
a205 1
			     sizeof ysd->dom_server_addr);
d226 1
a226 1
				      YPPROG, YPVERS, tv, &ysd->dom_socket);
@
