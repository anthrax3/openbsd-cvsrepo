head	1.20;
access;
symbols
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.8
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.12
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.10
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.12
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.10
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.8
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.10.0.14
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.12
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.10
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.8
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.8.0.20
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.18
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.16
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.14
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.12
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.10
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.8
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.6
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.4
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.19;
commitid	pqjnYVtACzQ9ctai;

1.19
date	2015.11.05.23.38.07;	author bluhm;	state Exp;
branches;
next	1.18;
commitid	d1FKtMKL5iAL36vj;

1.18
date	2015.10.23.18.49.07;	author tobias;	state Exp;
branches;
next	1.17;
commitid	WIx4xKMvUoo5UYwe;

1.17
date	2015.09.05.11.25.30;	author guenther;	state Exp;
branches;
next	1.16;
commitid	1yIx001UxX92Imbe;

1.16
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	0DYulI8hhujBHMcR;

1.15
date	2013.06.01.21.26.17;	author stsp;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.12.21.31.20;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.05;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.05.13.03.00;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.23.21.13.28;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.11.15.30.14;	author art;	state Exp;
branches;
next	1.8;

1.8
date	96.09.15.09.31.23;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.09.05.12.32.33;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.26.00.17.20;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.19.08.30.09;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.06.23.10.09.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.10.06.21.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.38.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@/*	$OpenBSD: catopen.c,v 1.19 2015/11/05 23:38:07 bluhm Exp $ */
/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by J.T. Conklin.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define _NLS_PRIVATE

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <nl_types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

#define NLS_DEFAULT_LANG "C"

static nl_catd	load_msgcat(const char *);
static int	verify_msgcat(nl_catd);

nl_catd
catopen(const char *name, int oflag)
{
	char tmppath[PATH_MAX];
	char *nlspath;
	char *lang;
	char *s, *t, *sep, *dot;
	const char *u;
	nl_catd catd;
		
	if (name == NULL || *name == '\0')
		return (nl_catd) -1;

	/* absolute or relative path? */
	if (strchr(name, '/'))
		return load_msgcat(name);

	if (issetugid() != 0 || (nlspath = getenv("NLSPATH")) == NULL)
		return (nl_catd) -1;

	lang = NULL;
	if (oflag & NL_CAT_LOCALE) {
		lang = getenv("LC_ALL");
		if (lang == NULL)
			lang = getenv("LC_MESSAGES");
	}
	if (lang == NULL)
		lang = getenv("LANG");
	if (lang == NULL)
		lang = NLS_DEFAULT_LANG;
	if (strcmp(lang, "POSIX") == 0)
		lang = NLS_DEFAULT_LANG;

	s = nlspath;
	t = tmppath;

	/*
	 * Locale names are of the form language[_territory][.codeset].
	 * See POSIX-1-2008 "8.2 Internationalization Variables"
	 */
	sep = strchr(lang, '_');
	dot = strrchr(lang, '.');
	if (dot && sep && dot < sep)
		dot = NULL; /* ignore dots preceeding _ */
	if (dot == NULL)
		lang = NLS_DEFAULT_LANG; /* no codeset specified */
	do {
		while (*s && *s != ':') {
			if (*s == '%') {
				switch (*(++s)) {
				case 'L':	/* LANG or LC_MESSAGES */
					u = lang;
					while (*u && t < tmppath + PATH_MAX-1)
						*t++ = *u++;
					break;
				case 'N':	/* value of name parameter */
					u = name;
					while (*u && t < tmppath + PATH_MAX-1)
						*t++ = *u++;
					break;
				case 'l':	/* language part */
					u = lang;
					while (*u && t < tmppath + PATH_MAX-1) {
						*t++ = *u++;
						if (sep && u >= sep)
							break;
						if (dot && u >= dot)
							break;
					}
					break;
				case 't':	/* territory part */
					if (sep == NULL)
						break;
					u = sep + 1;
					while (*u && t < tmppath + PATH_MAX-1) {
						*t++ = *u++;
						if (dot && u >= dot)
							break;
					}
					break;
				case 'c':	/* codeset part */
					if (dot == NULL)
						break;
					u = dot + 1;
					while (*u && t < tmppath + PATH_MAX-1)
						*t++ = *u++;
					break;
				default:
					if (t < tmppath + PATH_MAX-1)
						*t++ = *s;
				}
			} else {
				if (t < tmppath + PATH_MAX-1)
					*t++ = *s;
			}
			s++;
		}

		*t = '\0';
		catd = load_msgcat(tmppath);
		if (catd != (nl_catd) -1)
			return catd;

		if (*s)
			s++;
		t = tmppath;
	} while (*s);

	return (nl_catd) -1;
}
DEF_WEAK(catopen);

static nl_catd
load_msgcat(const char *path)
{
	struct stat st;
	nl_catd catd;
	void *data;
	int fd;

	catd = NULL;

	if ((fd = open(path, O_RDONLY|O_CLOEXEC)) == -1)
		return (nl_catd) -1;

	if (fstat(fd, &st) != 0) {
		close (fd);
		return (nl_catd) -1;
	}

	if (st.st_size > INT_MAX || st.st_size < sizeof (struct _nls_cat_hdr)) {
		errno = EINVAL;
		close (fd);
		return (nl_catd) -1;
	}

	data = mmap(0, st.st_size, PROT_READ, MAP_SHARED, fd, 0);
	close (fd);

	if (data == MAP_FAILED)
		return (nl_catd) -1;

	if (ntohl(((struct _nls_cat_hdr *) data)->__magic) != _NLS_MAGIC)
		goto invalid;

	if ((catd = malloc(sizeof (*catd))) == 0)
		goto invalid;

	catd->__data = data;
	catd->__size = st.st_size;

	if (verify_msgcat(catd))
		goto invalid;

	return catd;

invalid:
	free(catd);
	munmap(data, st.st_size);
	errno = EINVAL;
	return (nl_catd) -1;
}

static int
verify_msgcat(nl_catd catd)
{
	struct _nls_cat_hdr *cat;
	struct _nls_set_hdr *set;
	struct _nls_msg_hdr *msg;
	size_t remain;
	int hdr_offset, i, index, j, msgs, nmsgs, nsets, off, txt_offset;

	remain = catd->__size;
	cat = (struct _nls_cat_hdr *) catd->__data;

	hdr_offset = ntohl(cat->__msg_hdr_offset);
	nsets = ntohl(cat->__nsets);
	txt_offset = ntohl(cat->__msg_txt_offset);

	/* catalog must contain at least one set and no negative offsets */
	if (nsets < 1 || hdr_offset < 0 || txt_offset < 0)
		return (1);

	remain -= sizeof (*cat);

	/* check if offsets or set size overflow */
	if (remain <= hdr_offset || remain <= ntohl(cat->__msg_txt_offset) ||
	    remain / sizeof (*set) < nsets)
		return (1);

	set = (struct _nls_set_hdr *) ((char *) catd->__data + sizeof (*cat));

	/* make sure that msg has space for at least one index */
	if (remain - hdr_offset < sizeof(*msg))
		return (1);

	msg = (struct _nls_msg_hdr *) ((char *) catd->__data + sizeof (*cat)
	    + hdr_offset);

	/* validate and retrieve largest string offset from sets */
	off = 0;
	for (i = 0; i < nsets; i++) {
		index = ntohl(set[i].__index);
		nmsgs = ntohl(set[i].__nmsgs);
		/* set must contain at least one message */
		if (index < 0 || nmsgs < 1)
			return (1);

		if (INT_MAX - nmsgs < index)
			return (1);
		msgs = index + nmsgs;

		/* avoid msg index overflow */
		if ((remain - hdr_offset) / sizeof(*msg) < msgs)
			return (1);

		/* retrieve largest string offset */
		for (j = index; j < nmsgs; j++) {
			if (ntohl(msg[j].__offset) < 0)
				return (1);
			off = MAXIMUM(off, ntohl(msg[j].__offset));
		}
	}

	/* check if largest string offset is nul-terminated */
	if (remain - txt_offset < off ||
	    memchr((char *) catd->__data + sizeof(*cat) + txt_offset + off,
	    '\0', remain - txt_offset - off) == NULL)
		return (1);

	return (0);
}

@


1.19
log
@After removing National Language Support (NLS) from base, stop
creating the directory /usr/share/nls.  Having a non-existing default
path in catopen(3) does not make sense, so remove it.  If the user
does not specify a NLS path, better fail early than fail because
of an empty directory.  Remove path form hier(7).
OK stsp@@ schwarze@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: catopen.c,v 1.18 2015/10/23 18:49:07 tobias Exp $ */
d187 1
a187 1
	data = mmap(0, (size_t)st.st_size, PROT_READ, MAP_SHARED, fd, (off_t)0);
d209 1
a209 1
	munmap(data, (size_t) st.st_size);
@


1.18
log
@Verify that opened message catalog is valid, i.e. avoid integer overflows
and out of boundary accesses.

with input by miod, ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: catopen.c,v 1.17 2015/09/05 11:25:30 guenther Exp $ */
a45 1
#define NLS_DEFAULT_PATH "/usr/share/nls/%L/%N.cat:/usr/share/nls/%l.%c/%N.cat:/usr/share/nls/%l/%N.cat"
d69 1
a69 1
		nlspath = NLS_DEFAULT_PATH;
@


1.17
log
@Use new framework for wrapping cat{open,gets,close}(), eliminating
_cat* in the process.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: catopen.c,v 1.16 2015/01/16 16:48:51 deraadt Exp $ */
a32 3
#include <limits.h>
#include <stdlib.h>
#include <string.h>
d36 1
a36 1
#include <unistd.h>
d38 1
d40 5
d49 2
a50 1
static nl_catd load_msgcat(const char *);
d172 2
d182 7
a188 1
	data = mmap(0, (size_t) st.st_size, PROT_READ, MAP_SHARED, fd, (off_t)0);
d191 1
a191 1
	if (data == MAP_FAILED) {
a192 1
	}
d194 2
a195 4
	if (ntohl(((struct _nls_cat_hdr *) data)->__magic) != _NLS_MAGIC) {
		munmap(data, (size_t) st.st_size);
		return (nl_catd) -1;
	}
d197 2
a198 4
	if ((catd = malloc(sizeof (*catd))) == 0) {
		munmap(data, (size_t) st.st_size);
		return (nl_catd) -1;
	}
d202 4
d207 6
d214 71
@


1.16
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: catopen.c,v 1.15 2013/06/01 21:26:17 stsp Exp $ */
a47 1
/* ARGSUSED */
d49 1
a49 1
_catopen(const char *name, int oflag)
d158 1
@


1.15
log
@Fix catopen(3) for UTF-8 locales and update the implementation to POSIX-2008.

Catalogs had an arbitrary character set which was used regardless of locale.
Add UTF-8-encoded catalogs for libc error messages, and rename existing ones
to indicate their character sets. catopen(3) now chooses a catalog which
matches the locale's encoding, if available.

help & ok matthew, man page bits ok jmc, input from naddy and bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: catopen.c,v 1.14 2011/07/12 21:31:20 matthew Exp $ */
a36 1
#include <sys/param.h>
@


1.14
log
@Don't call munmap(2) if mmap(2) failed.

ok deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: catopen.c,v 1.13 2008/06/26 05:42:05 ray Exp $ */
d44 1
a44 1
#define NLS_DEFAULT_PATH "/usr/share/nls/%L/%N.cat:/usr/share/nls/%N/%L"
d56 1
a56 1
	char *s, *t;
d69 12
a80 1
	if ((lang = getenv("LANG")) == NULL)
d84 12
a95 1
	t = tmppath;	
d100 1
a100 1
				case 'L':	/* locale */
d105 1
a105 1
				case 'N':	/* name */
d110 26
a135 3
				case 'l':	/* lang */
				case 't':	/* territory */
				case 'c':	/* codeset */
d169 1
a169 1
	if ((fd = open(path, O_RDONLY)) == -1)
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: catopen.c,v 1.12 2005/08/05 13:03:00 espie Exp $ */
a135 1
		munmap(data, (size_t) st.st_size);
@


1.12
log
@zap rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a16 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@ansify. ok deraadt@@ millert@@
@
text
@d1 1
a36 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: catopen.c,v 1.10 2002/02/16 21:27:23 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: catopen.c,v 1.9 2001/05/11 15:30:14 art Exp $";
d61 1
a61 3
_catopen(name, oflag)
	const char *name;
	int oflag;
d127 1
a127 2
load_msgcat(path)
	const char *path;
@


1.9
log
@-1 -> MAP_FAILED
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: catopen.c,v 1.8 1996/09/15 09:31:23 tholo Exp $";
d57 1
a57 1
static nl_catd load_msgcat __P((const char *));
@


1.8
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: catopen.c,v 1.7 1996/09/05 12:32:33 deraadt Exp $";
d148 1
a148 1
	if (data == (void *) -1) {
@


1.7
log
@1 char oflow; bitblt & deraadt
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: catopen.c,v 1.6 1996/08/26 00:17:20 deraadt Exp $";
d57 1
a57 1
static nl_catd load_msgcat();
d59 1
d145 1
a145 1
	data = mmap(0, (size_t) st.st_size, PROT_READ, MAP_SHARED, fd, 0);
@


1.6
log
@use issetugid() to protect against bad getenv
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: catopen.c,v 1.5 1996/08/19 08:30:09 tholo Exp $";
d91 1
a91 1
					while (*u && t < tmppath + PATH_MAX)
d96 1
a96 1
					while (*u && t < tmppath + PATH_MAX)
d104 1
a104 1
					if (t < tmppath + PATH_MAX)
d108 1
a108 1
				if (t < tmppath + PATH_MAX)
@


1.5
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD$";
d75 1
a75 1
	if (strchr (name, '/'))
d78 1
a78 1
	if ((nlspath = getenv ("NLSPATH")) == NULL) {
d80 1
a80 2
	}
	if ((lang = getenv ("LANG")) == NULL) {
a81 1
	}
d136 1
a136 1
	if ((fd = open (path, O_RDONLY)) == -1)
d157 1
a157 1
	if ((catd = malloc (sizeof (*catd))) == 0) {
@


1.4
log
@from jtc; Ensure user can't make us overrun fixed sized buffers.
Merged in changes from branch (make sure all memory, file descriptors,
mappings, etc. are freed and return (nl_catd) -1 on error). Also fix
one minor bug and clean up NLSPATH parsing a bit more.
@
text
@a0 2
/*	$NetBSD: catopen.c,v 1.6.4.3 1996/06/21 06:30:31 jtc Exp $	*/

d36 4
@


1.3
log
@exit nicely, error out nicely
@
text
@d1 1
a1 1
/*	$NetBSD: catopen.c,v 1.6.4.2 1996/05/28 22:46:56 jtc Exp $	*/
d55 2
d62 5
a66 2
	const char *path;
	struct stat st;
d68 1
a68 5
	int fd;
	void *data;

	struct _nls_cat_hdr *cat_hdr;

d73 9
a81 17
	if (strchr (name, '/')) {
		if (stat (name, &st)) {
			return (nl_catd) -1;
		}
		path = name;
	} else {
		char tmppath[PATH_MAX];
		char *nlspath;
		char *lang;
		char *s, *t;
		
		if ((nlspath = getenv ("NLSPATH")) == NULL) {
			nlspath = NLS_DEFAULT_PATH;
		}
		if ((lang = getenv ("LANG")) == NULL) {
			lang = NLS_DEFAULT_LANG;
		}
d83 4
a86 1
		for (s = nlspath, t = tmppath; *s; ) {
d88 18
a105 17
				if (*(s + 1) == 'L') {
					strcpy(t, lang);
					t += strlen(lang);
					s += 2;
				} else if (*(s + 1) == 'N') {
					strcpy(t, name);
					t += strlen(name);
					s += 2;
				} else {
					*t++ = *s++;
				}
			} else if (*s == ':') {
				*t = '\0';

				if (stat (tmppath, &st) == 0) {
					path = tmppath;
					goto load_msgcat;
a106 2

				t = tmppath;
d108 2
a109 1
				*t++ = *s++;
d111 1
d114 21
a134 2
		return (nl_catd) -1;
	}
a135 1
load_msgcat:
@


1.2
log
@svr4-style gencat
@
text
@d1 1
a1 1
/*	$NetBSD: catopen.c,v 1.6 1996/05/13 23:29:39 jtc Exp $	*/
d64 1
d74 1
a74 1
			return (nl_catd) 0;
d117 1
a117 1
		return (nl_catd) 0;
d122 1
a122 1
		return (nl_catd) 0;
d126 1
a126 1
		return (nl_catd) 0;
d129 6
a134 3
	if ((catd = malloc (sizeof (*catd))) == 0) {
		close (fd);
		return (nl_catd) 0;
d137 3
a139 6
	catd->__data = mmap(0, (size_t) st.st_size, PROT_READ, MAP_SHARED, fd, 0);
	close (fd);

	if (catd->__data == (void *) -1) {
		free (catd);
		return (nl_catd) 0;
a140 1
	catd->__size = st.st_size;
d142 3
a144 5
	cat_hdr = (struct _nls_cat_hdr *) catd->__data;
	if (ntohl(cat_hdr->__magic) != _NLS_MAGIC) {
		free (catd);
		close (fd);
		return (nl_catd) 0;
d147 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: catopen.c,v 1.5 1995/03/23 19:59:06 jtc Exp $	*/
d3 34
a36 3
/*
 * Written by J.T. Conklin, 10/05/94
 * Public domain.
d39 1
a39 5
#include <sys/cdefs.h>

#ifdef __indr_reference
__indr_reference(_catopen,catopen);
#else
d41 9
d52 2
a53 1
extern nl_catd _catopen __P((__const char *, int));
d56 2
a57 2
catopen(name, oflag)
	__const char *name;
d60 90
a149 1
	return _catopen(name, oflag);
a150 2

#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
