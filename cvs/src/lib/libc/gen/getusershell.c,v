head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.6
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.9.0.6
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.28
	OPENBSD_5_0:1.8.0.26
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.24
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.22
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.18
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.20
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.16
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.14
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.12
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.10
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.8
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.6
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.12.08.16.28.26;	author tedu;	state Exp;
branches;
next	1.16;
commitid	U37UjurkFBkpYArQ;

1.16
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.15;
commitid	iWfSX2BIn0sLw62l;

1.15
date	2015.02.06.23.21.58;	author millert;	state Exp;
branches;
next	1.14;
commitid	STdsVrA5MGLlnbLm;

1.14
date	2014.09.15.06.15.48;	author guenther;	state Exp;
branches;
next	1.13;
commitid	ztgYHm1nk3mtTyS3;

1.13
date	2014.01.19.21.01.06;	author tobias;	state Exp;
branches;
next	1.12;

1.12
date	2014.01.17.20.51.54;	author tobias;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.24.23.51.29;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2013.09.30.12.02.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2012.04.06.20.54.41;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.02.17.04.52;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.25.15.38.47;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.24.15;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@rewrite guts of getusershell() to avoid possibility of overflow.
instead of trying to allocate "just enough" memory based on the size of the
file (which is mostly comments, in fact), allocate memory on demand.
i.e., save memory by wasting it. also be a little stricter about parsing.
after discussion with tobias. (with a bug fix from patrick keshishian)
descended from bug glibc bug 18660 via tobias.
@
text
@/*	$OpenBSD: getusershell.c,v 1.16 2015/09/14 16:09:13 tedu Exp $ */
/*
 * Copyright (c) 1985, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <limits.h>
#include <paths.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/*
 * Local shells should NOT be added here.  They should be added in
 * /etc/shells.
 */

static char *okshells[] = { _PATH_BSHELL, _PATH_CSHELL, _PATH_KSHELL, NULL };
static char **curshell, **shells;
static char **initshells(void);

/*
 * Get a list of shells from _PATH_SHELLS, if it exists.
 */
char *
getusershell(void)
{
	char *ret;

	if (curshell == NULL)
		curshell = initshells();
	ret = *curshell;
	if (ret != NULL)
		curshell++;
	return (ret);
}

void
endusershell(void)
{
	char **s;

	if ((s = shells))
		while (*s)
			free(*s++);
	free(shells);
	shells = NULL;

	curshell = NULL;
}

void
setusershell(void)
{

	curshell = initshells();
}

static char **
initshells(void)
{
	size_t nshells, nalloc, linesize;
	char *line;
	FILE *fp;

	free(shells);
	shells = NULL;

	if ((fp = fopen(_PATH_SHELLS, "re")) == NULL)
		return (okshells);

	line = NULL;
	nalloc = 10; // just an initial guess
	nshells = 0;
	shells = reallocarray(NULL, nalloc, sizeof (char *));
	if (shells == NULL)
		goto fail;
	linesize = 0;
	while (getline(&line, &linesize, fp) != -1) {
		if (*line != '/')
			continue;
		line[strcspn(line, "#\n")] = '\0';
		if (!(shells[nshells] = strdup(line)))
			goto fail;

		if (nshells + 1 == nalloc) {
			char **new = reallocarray(shells, nalloc * 2, sizeof(char *));
			if (!new)
				goto fail;
			shells = new;
			nalloc *= 2;
		}
		nshells++;
	}
	free(line);
	shells[nshells] = NULL;
	(void)fclose(fp);
	return (shells);

fail:
	free(line);
	while (nshells)
		free(shells[nshells--]);
	free(shells);
	shells = NULL;
	(void)fclose(fp);
	return (okshells);
}
@


1.16
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: getusershell.c,v 1.15 2015/02/06 23:21:58 millert Exp $ */
a30 2
#include <sys/stat.h>

d37 1
d46 1
a46 1
static char **curshell, **shells, *strings;
d68 5
a72 1
	
d75 1
a75 2
	free(strings);
	strings = NULL;
d89 2
a90 1
	char **sp, *cp;
a91 1
	struct stat statb;
d95 1
a95 2
	free(strings);
	strings = NULL;
d98 10
a107 25
	if (fstat(fileno(fp), &statb) == -1) {
		(void)fclose(fp);
		return (okshells);
	}
	if (statb.st_size > SIZE_MAX) {
		(void)fclose(fp);
		return (okshells);
	}
	if ((strings = malloc((size_t)statb.st_size)) == NULL) {
		(void)fclose(fp);
		return (okshells);
	}
	shells = calloc((size_t)(statb.st_size / 3 + 2), sizeof (char *));
	if (shells == NULL) {
		(void)fclose(fp);
		free(strings);
		strings = NULL;
		return (okshells);
	}
	sp = shells;
	cp = strings;
	while (fgets(cp, PATH_MAX + 1, fp) != NULL) {
		while (*cp != '#' && *cp != '/' && *cp != '\0')
			cp++;
		if (*cp == '#' || *cp == '\0')
d109 12
a120 4
		*sp++ = cp;
		while (!isspace((unsigned char)*cp) && *cp != '#' && *cp != '\0')
			cp++;
		*cp++ = '\0';
d122 2
a123 1
	*sp = NULL;
d126 9
@


1.15
log
@SIZE_MAX is standard, we should be using it in preference to the
obsolete SIZE_T_MAX.  OK miod@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getusershell.c,v 1.14 2014/09/15 06:15:48 guenther Exp $ */
d70 1
a70 2
	if (shells != NULL)
		free(shells);
d72 1
a72 2
	if (strings != NULL)
		free(strings);
d91 1
a91 2
	if (shells != NULL)
		free(shells);
d93 1
a93 2
	if (strings != NULL)
		free(strings);
@


1.14
log
@When fopen()ing internal to libc (the API doesn't support the use
of the resulting FILE *), then pass fopen() the 'e' mode letter to
mark it close-on-exec.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getusershell.c,v 1.13 2014/01/19 21:01:06 tobias Exp $ */
d36 1
d105 1
a105 1
	if (statb.st_size > SIZE_T_MAX) {
@


1.13
log
@Fix one more off-by-one (making it an off-by-two):

1. integer division can give an off-by-one (like 2/3 = 0 for calloc)
2. ending the shells array with NULL takes space, too

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getusershell.c,v 1.12 2014/01/17 20:51:54 tobias Exp $ */
d98 1
a98 1
	if ((fp = fopen(_PATH_SHELLS, "r")) == NULL)
@


1.12
log
@Fix off-by-one on specially crafted /etc/shells file.

ok gilles@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getusershell.c,v 1.11 2013/11/24 23:51:29 deraadt Exp $ */
d112 1
a112 1
	shells = calloc((size_t)(statb.st_size / 3 + 1), sizeof (char *));
@


1.11
log
@most obvious unsigned char casts for ctype
ok jca krw ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: getusershell.c,v 1.10 2013/09/30 12:02:34 millert Exp $ */
d112 1
a112 1
	shells = calloc((size_t)(statb.st_size / 3), sizeof (char *));
@


1.10
log
@Use PATH_MAX, NAME_MAX and LOGIN_NAME_MAX not MAXPATHNAMELEN,
MAXNAMLEN or MAXLOGNAME where possible.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getusershell.c,v 1.9 2012/04/06 20:54:41 deraadt Exp $ */
d127 1
a127 1
		while (!isspace(*cp) && *cp != '#' && *cp != '\0')
@


1.9
log
@range check st_size before calling calloc()
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: getusershell.c,v 1.8 2005/08/08 08:05:34 espie Exp $ */
a30 2
#include <sys/param.h>
#include <sys/file.h>
d32 4
a36 1
#include <ctype.h>
a38 1
#include <paths.h>
d121 1
a121 1
	while (fgets(cp, MAXPATHLEN + 1, fp) != NULL) {
@


1.8
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d104 1
a104 1
	if ((strings = malloc((u_int)statb.st_size)) == NULL) {
d108 5
a112 1
	shells = calloc((unsigned)statb.st_size / 3, sizeof (char *));
@


1.7
log
@Add /bin/ksh to builtin list of OK shells.
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: getusershell.c,v 1.6 2005/03/25 15:38:47 otto Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.6
log
@deregister (and deauto!). ok millert@@ marco@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getusershell.c,v 1.5 2004/05/18 02:05:52 jfb Exp $";
d48 1
a48 1
static char *okshells[] = { _PATH_BSHELL, _PATH_CSHELL, NULL };
@


1.5
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getusershell.c,v 1.4 2003/06/02 20:18:34 millert Exp $";
d91 2
a92 2
	register char **sp, *cp;
	register FILE *fp;
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getusershell.c,v 1.3 2002/02/16 21:27:22 millert Exp $";
d56 1
a56 1
getusershell()
d69 1
a69 1
endusershell()
d82 1
a82 1
setusershell()
d89 1
a89 1
initshells()
@


1.3
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: getusershell.c,v 1.2 1996/08/19 08:24:15 tholo Exp $";
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getusershell.c,v 1.5 1995/02/27 04:13:27 cgd Exp $";
d54 1
a54 1
static char **initshells __P((void));
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: getusershell.c,v 1.5 1995/02/27 04:13:27 cgd Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)getusershell.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: getusershell.c,v 1.5 1995/02/27 04:13:27 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
