head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.6
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.8
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.14
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.12
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.10
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.8
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.8
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.6
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.10.25.16.35.40;	author krw;	state Exp;
branches;
next	1.23;
commitid	3oFGnk257DgqfXfj;

1.23
date	2015.08.13.00.03.27;	author krw;	state Exp;
branches;
next	1.22;
commitid	xtnumFeu4ACTyNau;

1.22
date	2015.01.20.18.22.20;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	F55lwc3gS4GN2mLs;

1.21
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	0DYulI8hhujBHMcR;

1.20
date	2013.11.16.12.58.12;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.04.21.13.02;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.01.06.13.15;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.29.17.17.49;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.29.06.28.14;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.26.23.33.04;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2006.09.24.20.29.52;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.02.18.31.55;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.08.08.05.33;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.25.15.38.47;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.11.21.03.10;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.24.21.22.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.19.15.25.13;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.21.04.04;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.09.30.58;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.22.24;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.53;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.53;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Nuke union of d_packname with un_d_boot0 & un_d_boot1, keeping
d_packname as a simple field. Also nuke the access #defines, and
support for b0 and b1 capabilities in disktab.

ok deraadt@@ miod@@
@
text
@/*
 * Copyright (c) 1983, 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* DEV_BSIZE */
#include <sys/types.h>
#define DKTYPENAMES
#include <sys/disklabel.h>
#include <ufs/ffs/fs.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <unistd.h>

static u_int	gettype(char *, char **);

struct disklabel *
getdiskbyname(const char *name)
{
	static struct	disklabel disk;
	struct	disklabel *dp = &disk;
	struct partition *pp;
	char	*buf;
	char	*db_array[2] = { _PATH_DISKTAB, 0 };
	char	*cp, *cq;
	char	p, max, psize[3], pbsize[3],
		pfsize[3], poffset[3], ptype[3];
	u_int32_t *dx;

	if (cgetent(&buf, db_array, (char *) name) < 0)
		return NULL;

	bzero((char *)&disk, sizeof(disk));
	/*
	 * typename
	 */
	cq = dp->d_typename;
	cp = buf;
	while (cq < dp->d_typename + sizeof(dp->d_typename) - 1 &&
	    (*cq = *cp) && *cq != '|' && *cq != ':')
		cq++, cp++;
	*cq = '\0';

	if (cgetcap(buf, "sf", ':') != NULL)
		dp->d_flags |= D_BADSECT;

#define getnumdflt(field, dname, dflt) \
	{ long f; (field) = (cgetnum(buf, dname, &f) == -1) ? (dflt) : f; }
#define	getnum(field, dname) \
	{ long f; cgetnum(buf, dname, &f); field = f; }

	getnumdflt(dp->d_secsize, "se", DEV_BSIZE);
	getnum(dp->d_ntracks, "nt");
	getnum(dp->d_nsectors, "ns");
	getnum(dp->d_ncylinders, "nc");

	if (cgetstr(buf, "dt", &cq) > 0)
		dp->d_type = (u_short)gettype(cq, dktypenames);
	else
		getnumdflt(dp->d_type, "dt", 0);
	getnumdflt(dp->d_secpercyl, "sc", dp->d_nsectors * dp->d_ntracks);
	/* XXX */
	dp->d_secperunith = 0;
	getnumdflt(dp->d_secperunit, "su", dp->d_secpercyl * dp->d_ncylinders);
	getnumdflt(dp->d_bbsize, "bs", BBSIZE);
	getnumdflt(dp->d_sbsize, "sb", SBSIZE);
	strlcpy(psize, "px", sizeof psize);
	strlcpy(pbsize, "bx", sizeof pbsize);
	strlcpy(pfsize, "fx", sizeof pfsize);
	strlcpy(poffset, "ox", sizeof poffset);
	strlcpy(ptype, "tx", sizeof ptype);
	max = 'a' - 1;
	pp = &dp->d_partitions[0];
	dp->d_version = 1;
	for (p = 'a'; p < 'a' + MAXPARTITIONS; p++, pp++) {
		long f;

		psize[1] = pbsize[1] = pfsize[1] = poffset[1] = ptype[1] = p;
		/* XXX */
		if (cgetnum(buf, psize, &f) == -1)
			DL_SETPSIZE(pp, 0);
		else {
			u_int32_t fsize, frag = 8;

			DL_SETPSIZE(pp, f);
			/* XXX */
			pp->p_offseth = 0;
			getnum(pp->p_offset, poffset);
			getnumdflt(fsize, pfsize, 0);
			if (fsize) {
				long bsize;

				if (cgetnum(buf, pbsize, &bsize) == 0)
					frag = bsize / fsize;
				pp->p_fragblock =
				    DISKLABELV1_FFS_FRAGBLOCK(fsize, frag);
			}
			getnumdflt(pp->p_fstype, ptype, 0);
			if (pp->p_fstype == 0 && cgetstr(buf, ptype, &cq) > 0)
				pp->p_fstype = (u_char)gettype(cq, fstypenames);
			max = p;
		}
	}
	dp->d_npartitions = max + 1 - 'a';
	(void)strlcpy(psize, "dx", sizeof psize);
	dx = dp->d_drivedata;
	for (p = '0'; p < '0' + NDDATA; p++, dx++) {
		psize[1] = p;
		getnumdflt(*dx, psize, 0);
	}
	dp->d_magic = DISKMAGIC;
	dp->d_magic2 = DISKMAGIC;
	free(buf);
	return (dp);
}

static u_int
gettype(char *t, char **names)
{
	char **nm;

	for (nm = names; *nm; nm++)
		if (strcasecmp(t, *nm) == 0)
			return (nm - names);
	if (isdigit((u_char)*t))
		return ((u_int)strtonum(t, 0, USHRT_MAX, NULL));
	return (0);
}
@


1.23
log
@Zap a few stray blanks.
@
text
@a72 5
	/*
	 * boot name (optional)  xxboot, bootxx
	 */
	cgetstr(buf, "b0", &dp->d_boot0);
	cgetstr(buf, "b1", &dp->d_boot1);
@


1.22
log
@Adjust <sys/param.h> comments regarding use of use of MAXFRAG, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d54 1
a54 1
	char  	*db_array[2] = { _PATH_DISKTAB, 0 };
d109 1
a109 1
	dp->d_version = 1; 
@


1.21
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d30 1
a30 1
#include <sys/param.h>	/* MAXFRAG DEV_BSIZE */
@


1.20
log
@In getdiskbyname() set partition size with DL_SETPSIZE(). Make sure
d_secperunith and p_offseth are set to 0 since they can't be read
from disktab and lower 32 bits (d_secperunit and p_offset) are read
directly from the input.
@
text
@d30 2
a31 1
#include <sys/param.h>
@


1.19
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d97 1
d115 1
a115 1
			pp->p_size = 0;
d119 1
a119 1
			pp->p_size = f;
d121 1
@


1.18
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@a97 2
	getnumdflt(dp->d_rpm, "rm", 3600);
	getnumdflt(dp->d_interleave, "il", 1);
@


1.17
log
@mark the non-handling of 48 bits units with XXX
@
text
@a99 4
	getnumdflt(dp->d_trackskew, "sk", 0);
	getnumdflt(dp->d_cylskew, "cs", 0);
	getnumdflt(dp->d_headswitch, "hs", 0);
	getnumdflt(dp->d_trkseek, "ts", 0);
@


1.16
log
@when producing a v1 label, set the version!!!!
@
text
@d96 1
d118 1
d125 1
@


1.15
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d112 1
@


1.14
log
@Zap D_REMOVABLE flag from disklabel. If you didn't already know that
floppies and cd's were removable, displaying that fact in disklabel
output was unlikely to help. And the display in disklabel was the only
use of D_REMOVABLE in the tree.

ok marco@@
@
text
@d119 2
d123 2
a124 2
			getnumdflt(pp->p_fsize, pfsize, 0);
			if (pp->p_fsize) {
d128 3
a130 3
					pp->p_frag = bsize / pp->p_fsize;
				else
					pp->p_frag = 8;
@


1.13
log
@Eliminate D_CHAIN, D_ECC and D_RAMDISK flags from disklabel. They were
not being used in the tree for anything obviously useful. Get it done
early so we can find if there are non-obvious uses out there.

ok deraadt@@ beck@@
@
text
@a77 2
	if (cgetstr(buf, "ty", &cq) > 0 && strcmp(cq, "removable") == 0)
		dp->d_flags |= D_REMOVABLE;
@


1.12
log
@kill atoi(), correct signedness of internal API gettype(); ok a few people
@
text
@a79 2
	else  if (cq && strcmp(cq, "simulated") == 0)
		dp->d_flags |= D_RAMDISK;
@


1.11
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d40 1
d44 1
a44 1
static int	gettype(char *, char **);
d96 1
a96 1
		dp->d_type = gettype(cq, dktypenames);
d136 1
a136 1
				pp->p_fstype = gettype(cq, fstypenames);
d153 1
a153 1
static int
d162 1
a162 1
		return (atoi(t));
@


1.10
log
@deregister (and deauto!). ok millert@@ marco@@
@
text
@a29 4
#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.9 2003/06/11 21:03:10 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */

@


1.9
log
@ansification; checked by pval
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.8 2003/06/02 20:18:34 millert Exp $";
d53 2
a54 2
	register struct	disklabel *dp = &disk;
	register struct partition *pp;
d57 1
a57 1
	char	*cp, *cq;	/* can't be register */
d159 1
a159 1
	register char **nm;
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.7 2002/05/24 21:22:37 deraadt Exp $";
d50 1
a50 2
getdiskbyname(name)
	const char *name;
d157 1
a157 3
gettype(t, names)
	char *t;
	char **names;
@


1.7
log
@try to use strlcpy and snprintf more; ok various
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.6 2002/02/16 21:27:22 millert Exp $";
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.5 2000/07/19 15:25:13 deraadt Exp $";
d117 5
a121 5
	strcpy(psize, "px");
	strcpy(pbsize, "bx");
	strcpy(pfsize, "fx");
	strcpy(poffset, "ox");
	strcpy(ptype, "tx");
d149 1
a149 1
	(void)strcpy(psize, "dx");
@


1.5
log
@off-by-one calculation error; getcwd() would return NULL if the buffer was
the needed length + terminating byte + 1; that 1 is not needed; assar
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.4 1997/07/23 21:04:04 kstailey Exp $";
d51 1
a51 1
static int	gettype __P((char *, char **));
@


1.4
log
@tabify
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.3 1996/09/15 09:30:58 tholo Exp $";
d171 1
a171 1
	if (isdigit(*t))
@


1.3
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.2 1996/08/19 08:22:24 tholo Exp $";
d94 1
a94 1
        { long f; (field) = (cgetnum(buf, dname, &f) == -1) ? (dflt) : f; }
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: disklabel.c,v 1.11 1995/06/07 13:14:09 cgd Exp $";
a50 1
static void	error __P((int));
a173 14
}

static void
error(err)
	int err;
{
	char *p;

	(void)write(STDERR_FILENO, "disktab: ", 9);
	(void)write(STDERR_FILENO, _PATH_DISKTAB, sizeof(_PATH_DISKTAB) - 1);
	(void)write(STDERR_FILENO, ": ", 2);
	p = strerror(err);
	(void)write(STDERR_FILENO, p, strlen(p));
	(void)write(STDERR_FILENO, "\n", 1);
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: disklabel.c,v 1.11 1995/06/07 13:14:09 cgd Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)disklabel.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: disklabel.c,v 1.11 1995/06/07 13:14:09 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
