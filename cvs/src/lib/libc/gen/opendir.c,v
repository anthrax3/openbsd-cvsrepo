head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.2
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.23.0.10
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.16
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.14
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.29;
commitid	pqjnYVtACzQ9ctai;

1.29
date	2015.09.12.13.34.22;	author guenther;	state Exp;
branches;
next	1.28;
commitid	TusJDQRjqkLPFiPJ;

1.28
date	2015.03.18.15.11.31;	author tedu;	state Exp;
branches;
next	1.27;
commitid	TKV3ocmluxKcTD9D;

1.27
date	2014.03.10.07.54.14;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2013.11.06.20.35.25;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.06.17.57.11;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2013.08.13.05.52.12;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.18.17.29.49;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.18.00.27.15;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.14.02.16.00;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.19.17.12.43;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.05.18.11.48;	author kurt;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.09.14.58.09;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.10.12.04.20;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.01.18.06.59;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.10.17.37.43;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.16.03.01.25;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.26.03.48.18;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.01.13.51.47;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.30.22.47.22;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.08.20.23.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.08.15.08.10.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.08.14.21.39.31;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.09.00.28.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.07.19.04.06;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.25.12;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.57;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@/*	$OpenBSD: opendir.c,v 1.29 2015/09/12 13:34:22 guenther Exp $ */
/*
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>

#include "telldir.h"

static DIR *__fdopendir(int fd);

/*
 * Open a directory specified by name.
 */
DIR *
opendir(const char *name)
{
	DIR *dirp;
	int fd;

	if ((fd = open(name, O_RDONLY | O_DIRECTORY | O_CLOEXEC)) == -1)
		return (NULL);
	dirp = __fdopendir(fd);
	if (dirp == NULL)
		close(fd);
	return (dirp);
}
DEF_WEAK(opendir);

/*
 * Open a directory specified by file descriptor.
 */
DIR *
fdopendir(int fd)
{
	DIR *dirp;
	int flags;

	if ((flags = fcntl(fd, F_GETFL)) == -1)
		return (NULL);
	if ((flags & O_ACCMODE) != O_RDONLY && (flags & O_ACCMODE) != O_RDWR) {
		errno = EBADF;
		return (NULL);
	}
	dirp = __fdopendir(fd);
	if (dirp != NULL) {
		/* Record current offset for immediate telldir() */
		dirp->dd_bufpos = dirp->dd_curpos = lseek(fd, 0, SEEK_CUR);

		/*
		 * POSIX doesn't require fdopendir() to set
		 * FD_CLOEXEC, so it's okay for this to fail.
		 */
		(void)fcntl(fd, F_SETFD, FD_CLOEXEC);
	}
	return (dirp);
}
DEF_WEAK(fdopendir);

static DIR *
__fdopendir(int fd)
{
	DIR *dirp;
	struct stat sb;
	int pageoffset;

	if (fstat(fd, &sb))
		return (NULL);
	if (!S_ISDIR(sb.st_mode)) {
		errno = ENOTDIR;
		return (NULL);
	}
	if ((dirp = malloc(sizeof(DIR))) == NULL)
		return (NULL);

	pageoffset = getpagesize() - 1;
	dirp->dd_len = ((int)sb.st_blksize * 4 + pageoffset) & ~pageoffset;
	dirp->dd_buf = malloc(dirp->dd_len);
	if (dirp->dd_buf == NULL) {
		free(dirp);
		return (NULL);
	}

	dirp->dd_size = 0;
	dirp->dd_loc = 0;
	dirp->dd_fd = fd;
	dirp->dd_lock = NULL;
	dirp->dd_curpos = 0;
	dirp->dd_bufpos = 0;

	return (dirp);
}
@


1.29
log
@Wrap <dirent.h> so that internal calls go direct and they're all weak symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.28 2015/03/18 15:11:31 tedu Exp $ */
d110 1
a110 1
	dirp->dd_buf = malloc((size_t)dirp->dd_len);
@


1.28
log
@use 4x buffer size for opendir. speeds up large directory reading, and
increased memory use is minimal.
ok deraadt logan
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.27 2014/03/10 07:54:14 schwarze Exp $ */
d60 1
d90 1
@


1.27
log
@Optimization, no functional change:
Save a cookie pointing to the very first entry in the DIR.dd_buf
cache buffer and use that to speed up seekdir(3) when rewinding
to that first entry.
No libc bump because DIR is an opaque struct.

When the optimization applies, which in particular it always does
for rewinddir(3) after reading less than about 500 entries,
seekdir(3) execution time drops from 100 to 0.05 milliseconds
on my i386 notebook.  Other cases are not slowed down.

Based on an idea from and ok by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.26 2013/11/06 20:35:25 schwarze Exp $ */
d107 1
a107 1
	dirp->dd_len = ((int)sb.st_blksize + pageoffset) & ~pageoffset;
@


1.26
log
@Search the userland buffer of dirent structures before falling back to
getdents(2).  No functional change, but considerable speedup in many
cases, see http://marc.info/?l=openbsd-tech&m=138369623117934 for some
approximate numbers.
ok guenther@@,  "good diagnosis" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.25 2013/10/06 17:57:11 guenther Exp $ */
d79 1
a79 1
		dirp->dd_curpos = lseek(fd, 0, SEEK_CUR);
d119 1
@


1.25
log
@fdopendir() needs to set dd_curpos so that an immediate telldir() works.

pointed out by and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.24 2013/08/13 05:52:12 guenther Exp $ */
d114 1
@


1.24
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.23 2011/07/18 17:29:49 matthew Exp $ */
d78 3
@


1.23
log
@Expose a bunch of new functionality from POSIX 2008: openat(2),
fchmodat(2), fstatat(2), mkdirat(2), mkfifoat(2), mknodat(2),
faccessat(2), fchownat(2), linkat(2), readlinkat(2), renameat(2),
symlinkat(2), unlinkat(2), utimensat(2), futimens(2), and
fdopendir(3).

"Minor" libc bump.

Tested in a bulk build by naddy@@
Much help from guenther@@, thib@@, tedu@@, oga@@, and others.
ok deraadt@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.22 2011/07/18 00:27:15 matthew Exp $ */
d42 1
a42 1
static DIR *__fdopendir(int fd, off_t offset);
d55 1
a55 1
	dirp = __fdopendir(fd, 0);
a68 1
	off_t offset;
d76 1
a76 3
	if ((offset = lseek(fd, 0, SEEK_CUR)) == -1)
		return (NULL);
	dirp = __fdopendir(fd, offset);
d88 1
a88 1
__fdopendir(int fd, off_t offset)
d100 1
a100 1
	if ((dirp = malloc(sizeof(DIR) + sizeof(struct _telldir))) == NULL)
a102 5
	/*
	 * Use a buffer that is page aligned.
	 * Hopefully this can be a big win someday by allowing page trades
	 * to user space to be done by getdirentries()
	 */
a110 7
	dirp->dd_td = (struct _telldir *)((char *)dirp + sizeof(DIR));
	dirp->dd_td->td_locs = NULL;
	dirp->dd_td->td_sz = 0;
	dirp->dd_td->td_loccnt = 0;
	dirp->dd_td->td_last = 0;

	dirp->dd_seek = 0;
a112 1
	dirp->dd_unused = 0;
d114 1
a114 11

	/*
	 * Set up seek point for rewinddir.
	 */
	dirp->dd_rewind = telldir(dirp);

	/*
	 * Store our actual seek offset.  Must do this *after* setting
	 * dd_rewind = telldir() so that rewinddir() works correctly.
	 */
	dirp->dd_seek = offset;
@


1.22
log
@Implement fdopendir(3) and refactor opendir(3) and fdopendir(3) to use
a common __fdopendir() function.  Also, take advantage of the new
O_DIRECTORY and O_CLOEXEC flags in opendir(3).

(Currently fdopendir(3) is commented out; it will be enabled shortly
alongside openat(2) et al.)

Tested by naddy@@ in a bulk build.
tweaks and ok guenther@@; stupid POSIX nit pointed out by oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.21 2011/07/14 02:16:00 deraadt Exp $ */
a60 1
#if 0
a88 1
#endif
@


1.21
log
@__opendir2, DTF_NODUP, and __DTF_READALL can die.  struct dirent
dd_flags is renamed to the placeholder position dd_unused so that
we can spot "broken software" which assumes we have Jan Simon Pendry's
union mounts (we don't have them, and won't have them ever again).
__opendir2 question spotted by matthew
verified to not break ports by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.20 2010/01/19 17:12:43 millert Exp $ */
d31 1
a31 2
#include <sys/param.h>
#include <sys/mount.h>
a36 1
#include <limits.h>
a37 1
#include <string.h>
d42 2
d45 1
a45 1
 * Open a directory.
a51 2
	struct stat sb;
	int pageoffset;
d53 1
a53 1
	if ((fd = open(name, O_RDONLY | O_NONBLOCK)) == -1)
d55 2
a56 1
	if (fstat(fd, &sb)) {
d58 15
d74 13
d88 13
a101 1
		close(fd);
d105 1
a105 3
	if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1 ||
	    (dirp = malloc(sizeof(DIR) + sizeof(struct _telldir))) == NULL) {
		close(fd);
a106 7
	}

	dirp->dd_td = (struct _telldir *)((char *)dirp + sizeof(DIR));
	dirp->dd_td->td_locs = NULL;
	dirp->dd_td->td_sz = 0;
	dirp->dd_td->td_loccnt = 0;
	dirp->dd_td->td_last = 0;
a117 1
		close(fd);
d121 6
d137 6
@


1.20
log
@Leave errno as-is if fstat(2) fails instead of masking the real
errno with ENOTDIR.  From Tim van der Molen.
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.19 2007/06/05 18:11:48 kurt Exp $ */
a50 7

	return (__opendir2(name, DTF_NODUP));
}

DIR *
__opendir2(const char *name, int flags)
{
d96 1
a96 1
	dirp->dd_flags = flags;
@


1.19
log
@_FD_LOCK/UNLOCK() is libpthread specific and not needed for librthread, so
isolate its usage to libpthread only and replace with generic non-static
mutex support in the one place it is needed:
 - remove _FD_LOCK/UNLOCK from lseek and ftruncate in libc and make the
   functions weak so that libpthread can override with its own new
   versions that do the locking.
 - remove _thread_fd_lock/unlock() weak functions from libc and adjust
   libpthread for the change.
 - add generic _thread_mutex_lock/unlock/destroy() weak functions in libc
   to support non-static mutexes in libc and add libpthread and librthread
   implementations for them. libc can utilize non-static mutexes via the
   new _MUTEX_LOCK/UNLOCK/DESTROY() macros. Actually these new macros can
   support both static and non-static mutexes but currently only using
   them for non-static.
 - make opendir/closedir/readdir/readdir_r/seekdir/telldir() thread-safe
   for both thread libraries by using a non-static mutex in the struct
   _dirdesc (typedef DIR), utilizing it in the *dir functions and remove
   remaining and incorrect _FD_LOCK/UNLOCK() use in libc.
 - add comments to both thread libraries to indicate libc depends on the
   current implementation of static mutex initialization. suggested by
   marc@@
 - major bump libc and libpthread due to function removal, structure
   change and weak symbol conversions.
okay marc@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.18 2007/02/09 14:58:09 millert Exp $ */
d65 5
a69 1
	if (fstat(fd, &sb) || !S_ISDIR(sb.st_mode)) {
d96 1
a96 1
		close (fd);
@


1.18
log
@The buffer passed to getdirentries() must be at least as large as
the filesystem block size.  Previously we used a constant (1024)
rounded to the page size.  Now we use the filesystem's block size,
rounded up to the nearest page.
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.17 2006/04/10 12:04:20 otto Exp $ */
d100 1
@


1.17
log
@telldir/seekdir optimization, avoid scanning the complete list,
while still returning the correct index for seekdir(); telldir()
Tested by Fred Crowson and others; "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.16 2006/04/01 18:06:59 otto Exp $ */
d61 1
a61 2
	int pagesz;
	int incr;
d83 1
a83 2
	 * If the machine's page size is an exact multiple of DIRBLKSIZ,
	 * use a buffer that is cluster boundary aligned.
d87 3
a89 7
	if (((pagesz = getpagesize()) % DIRBLKSIZ) == 0)
		incr = pagesz;
	else
		incr = DIRBLKSIZ;

	dirp->dd_len = incr;
	dirp->dd_buf = malloc(dirp->dd_len);
@


1.16
log
@- Plug huge mem leak; mostly samba was suffering.
- Fix semantics: seekdir(pos); telldir() shoud return pos. The code
that implements this will be made faster in a later commit.
- We loose documented behaviour (after closedir() the telldir()
positions are not valid anymore). This was never in Posix, and most
other systems have nothing like it.

Diff originally from Paul Thorn, rewritten by me using some FreeBSD
code.  "slap it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.15 2005/10/10 17:37:43 espie Exp $ */
d81 1
a81 1

@


1.15
log
@fix a few warnings, keep the crypt stuff for later.
okay otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendir.c,v 1.14 2005/08/08 08:05:34 espie Exp $ */
d43 2
d72 1
a72 1
	    (dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
d76 6
@


1.14
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a41 16

static int direntcmp(const void *, const void *);

/*
 * Comparison function for sorting dirent structures that never returns 0;
 * this causes qsort() to emulate a stable sort.
 */
static int
direntcmp(const void *d1, const void *d2)
{
	int i;

	i = strcmp((*(struct dirent **)d1)->d_name,
	    (*(struct dirent **)d2)->d_name);
	return (i != 0 ? i : (char *)d2 - (char *)d1);
}
@


1.13
log
@bye bye whiteouts
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: opendir.c,v 1.12 2005/05/26 03:48:18 pedro Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.12
log
@union is gone, ok millert@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.11 2005/03/01 13:51:47 miod Exp $";
d69 1
a69 1
	return (__opendir2(name, DTF_HIDEW|DTF_NODUP));
a113 2
	flags &= ~DTF_REWIND;

@


1.11
log
@Set errno right before return(), so that it does not risk being reset
by any other functions we will invoke in-between.

Fix from Andrey Matveev <andrushock@@korovino.net>
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.10 2004/05/18 02:05:52 jfb Exp $";
a79 1
	int unionstack;
d105 6
a110 15
	/*
	 * Determine whether this directory is the top of a union stack.
	 */
	if (flags & DTF_NODUP) {
		struct statfs sfb;

		if (fstatfs(fd, &sfb) < 0) {
			free(dirp);
			close(fd);
			return (NULL);
		}
		unionstack = strncmp(sfb.f_fstypename, MOUNT_UNION, MFSNAMELEN) == 0 ||
			     (sfb.f_flags & MNT_UNION);
	} else {
		unionstack = 0;
d113 2
a114 148
	if (unionstack) {
		int len = 0;
		int space = 0;
		char *buf = 0;
		char *ddptr = 0;
		char *ddeptr;
		int n;
		struct dirent **dpv;

		/*
		 * The strategy here is to read all the directory
		 * entries into a buffer, sort the buffer, and
		 * remove duplicate entries by setting the inode
		 * number to zero.
		 */

		do {
			/*
			 * Always make at least DIRBLKSIZ bytes
			 * available to getdirentries
			 */
			if (space < DIRBLKSIZ) {
				char *nbuf;

				space += incr;
				len += incr;
				nbuf = realloc(buf, len);
				if (nbuf == NULL) {
					if (buf)
						free(buf);
					free(dirp);
					close(fd);
					return (NULL);
				}
				buf = nbuf;
				ddptr = buf + (len - space);
			}

			n = getdirentries(fd, ddptr, space, &dirp->dd_seek);
			if (n > 0) {
				ddptr += n;
				space -= n;
			}
		} while (n > 0);

		ddeptr = ddptr;
		flags |= __DTF_READALL;

		/*
		 * Re-open the directory.
		 * This has the effect of rewinding back to the
		 * top of the union stack and is needed by
		 * programs which plan to fchdir to a descriptor
		 * which has also been read -- see fts.c.
		 */
		if (flags & DTF_REWIND) {
			(void) close(fd);
			if ((fd = open(name, O_RDONLY)) == -1) {
				free(buf);
				free(dirp);
				return (NULL);
			}
		}

		/*
		 * There is now a buffer full of (possibly) duplicate
		 * names.
		 */
		dirp->dd_buf = buf;

		/*
		 * Go round this loop twice...
		 *
		 * Scan through the buffer, counting entries.
		 * On the second pass, save pointers to each one.
		 * Then sort the pointers and remove duplicate names.
		 */
		for (dpv = 0;;) {
			for (n = 0, ddptr = buf; ddptr < ddeptr;) {
				struct dirent *dp;

				dp = (struct dirent *) ddptr;
				if ((long)dp & 03)
					break;
				if ((dp->d_reclen <= 0) ||
				    (dp->d_reclen > (ddeptr + 1 - ddptr)))
					break;
				ddptr += dp->d_reclen;
				if (dp->d_fileno) {
					if (dpv)
						dpv[n] = dp;
					n++;
				}
			}

			if (dpv) {
				struct dirent *xp;

				/*
				 * This sort must be stable.
				 */
				qsort(dpv, n, sizeof(*dpv), direntcmp);

				dpv[n] = NULL;
				xp = NULL;

				/*
				 * Scan through the buffer in sort order,
				 * zapping the inode number of any
				 * duplicate names.
				 */
				for (n = 0; dpv[n]; n++) {
					struct dirent *dp = dpv[n];

					if ((xp == NULL) ||
					    strcmp(dp->d_name, xp->d_name))
						xp = dp;
					else
						dp->d_fileno = 0;
					if (dp->d_type == DT_WHT &&
					    (flags & DTF_HIDEW))
						dp->d_fileno = 0;
				}

				free(dpv);
				break;
			} else {
				if (n+1 > SIZE_T_MAX / sizeof(struct dirent *))
					break;
				dpv = malloc((n+1) * sizeof(struct dirent *));
				if (dpv == NULL)
					break;
			}
		}

		dirp->dd_len = len;
		dirp->dd_size = ddptr - dirp->dd_buf;
	} else {
		dirp->dd_len = incr;
		dirp->dd_buf = malloc(dirp->dd_len);
		if (dirp->dd_buf == NULL) {
			free(dirp);
			close (fd);
			return (NULL);
		}
		dirp->dd_seek = 0;
		flags &= ~DTF_REWIND;
	}
@


1.10
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.9 2003/06/02 20:18:34 millert Exp $";
d85 1
a86 1
		close(fd);
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.8 2002/07/30 22:47:22 millert Exp $";
d66 1
a66 2
opendir(name)
	const char *name;
d73 1
a73 3
__opendir2(name, flags)
	const char *name;
	int flags;
@


1.8
log
@malloc paranoia; it is unlikely that any filesystem will support
enough directory entries to cause a problem but it is good form anyway.
deraadt@@ OK.
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.7 2002/07/08 20:23:14 millert Exp $";
@


1.7
log
@Use qsort() instead of mergesort() since the latter can fail due
to malloc().  opendir() requires a stable sort so we rig the compare
routine to never return 0.  From Lars J. Buitinck
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.6 1998/08/15 08:10:14 deraadt Exp $";
d45 1
d257 2
@


1.6
log
@fix realloc patch
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.5 1998/08/14 21:39:31 deraadt Exp $";
d49 16
d230 1
a230 1
				mergesort(dpv, n, sizeof(*dpv), alphasort);
@


1.5
log
@realloc repair
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.4 1997/07/09 00:28:23 millert Exp $";
d147 1
@


1.4
log
@Clean up some -Wall complaints.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.3 1996/09/07 19:04:06 tholo Exp $";
d135 2
d139 4
a142 2
				buf = realloc(buf, len);
				if (buf == NULL) {
@


1.3
log
@Understand about union mounts as well as union file system
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.2 1996/08/19 08:25:12 tholo Exp $";
d46 1
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: opendir.c,v 1.10 1995/06/18 10:58:32 cgd Exp $";
d106 2
a107 2
		unionstack = !strncmp(sfb.f_fstypename, MOUNT_UNION,
		    MFSNAMELEN);
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: opendir.c,v 1.10 1995/06/18 10:58:32 cgd Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)opendir.c	8.7 (Berkeley) 12/10/94";
#else
static char rcsid[] = "$NetBSD: opendir.c,v 1.10 1995/06/18 10:58:32 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
