head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.8
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.6
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2017.08.08.14.23.23;	author bluhm;	state Exp;
branches;
next	1.18;
commitid	mLHelEDyH1jZRa58;

1.18
date	2017.08.07.23.49.13;	author bluhm;	state Exp;
branches;
next	1.17;
commitid	q39VNwmubcTEa287;

1.17
date	2017.07.20.16.58.25;	author bluhm;	state Exp;
branches;
next	1.16;
commitid	kWQYWMxdCsreJKjF;

1.16
date	2016.10.19.16.09.24;	author millert;	state Exp;
branches;
next	1.15;
commitid	TerNQrUkEv9nJ3Qf;

1.15
date	2016.03.27.16.28.56;	author chl;	state Exp;
branches;
next	1.14;
commitid	2l6Oxximu4CoPitM;

1.14
date	2016.03.21.22.41.28;	author bluhm;	state Exp;
branches;
next	1.13;
commitid	hneUpr7ZOJCeNeHP;

1.13
date	2016.03.13.18.34.20;	author guenther;	state Exp;
branches;
next	1.12;
commitid	AStIlKdF20sYXV6x;

1.12
date	2016.02.19.23.49.38;	author millert;	state Exp;
branches;
next	1.11;
commitid	mRytK6Dskn38EmoT;

1.11
date	2015.11.25.00.01.21;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	C18rLGWf738HaMug;

1.10
date	2015.10.31.02.57.16;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	CLE0f1mZCJgLFjHQ;

1.9
date	2015.09.12.14.30.31;	author guenther;	state Exp;
branches;
next	1.8;
commitid	bIIajb0CCbQhTK6C;

1.8
date	2015.09.09.10.50.59;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	uqZ6rkD1cxwBHHkt;

1.7
date	2015.01.21.19.34.24;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	pHV6ylEWUGu7RJMO;

1.6
date	2014.10.03.15.41.18;	author bluhm;	state Exp;
branches;
next	1.5;
commitid	RsidCK7CSBJ8FrQr;

1.5
date	2014.07.14.03.52.04;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	c77xFkzm2wveXKxW;

1.4
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.30.18.48.33;	author martynas;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.21.10.23.31;	author chl;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.18.07.43.22;	author guenther;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Kernel sendsyslog(2), libc syslog(3), and syslogd(8) restrict and
truncate the length of a syslog message to 8192 bytes.  Use one
global define LOG_MAXLINE for all of them.
OK deraadt@@ millert@@
@
text
@/*	$OpenBSD: syslog_r.c,v 1.18 2017/08/07 23:49:13 bluhm Exp $ */
/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/uio.h>
#include <netdb.h>

#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <stdarg.h>

/* Reentrant version of syslog, i.e. syslog_r() */
void
syslog_r(int pri, struct syslog_data *data, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vsyslog_r(pri, data, fmt, ap);
	va_end(ap);
}
DEF_WEAK(syslog_r);

void
vsyslog_r(int pri, struct syslog_data *data, const char *fmt, va_list ap)
{
	__vsyslog_r(pri, data, 1, fmt, ap);
}
DEF_WEAK(vsyslog_r);

/*
 * This is used by both syslog_r and syslog.
 */
void
__vsyslog_r(int pri, struct syslog_data *data,
    int reentrant, const char *fmt, va_list ap)
{
	int cnt;
	char ch, *p, *t;
	int saved_errno;
#define	TBUF_SIZE	(LOG_MAXLINE+1)
#define	FMT_SIZE	(1024+1)
	char *stdp = NULL, tbuf[TBUF_SIZE], fmt_cpy[FMT_SIZE];
	int tbuf_left, fmt_left, prlen;

#define	INTERNALLOG	LOG_ERR|LOG_CONS|LOG_PERROR|LOG_PID
	/* Check for invalid bits. */
	if (pri & ~(LOG_PRIMASK|LOG_FACMASK)) {
		syslog_r(INTERNALLOG, data,
		    "syslog%s: unknown facility/priority: %x",
		    reentrant ? "_r" : "", pri);
		pri &= LOG_PRIMASK|LOG_FACMASK;
	}

	/* Check priority against setlogmask values. */
	if (!(LOG_MASK(LOG_PRI(pri)) & data->log_mask))
		return;

	saved_errno = errno;

	/* Set default facility if none specified. */
	if ((pri & LOG_FACMASK) == 0)
		pri |= data->log_fac;

	p = tbuf;
	tbuf_left = TBUF_SIZE;

#define	DEC()	\
	do {					\
		if (prlen < 0)			\
			prlen = 0;		\
		if (prlen >= tbuf_left)		\
			prlen = tbuf_left - 1;	\
		p += prlen;			\
		tbuf_left -= prlen;		\
	} while (0)

	prlen = snprintf(p, tbuf_left, "<%d>", pri);
	DEC();

	if (data->log_stat & LOG_PERROR)
		stdp = p;
	if (data->log_tag == NULL)
		data->log_tag = __progname;
	if (data->log_tag != NULL) {
		prlen = snprintf(p, tbuf_left, "%.*s", NAME_MAX, data->log_tag);
		DEC();
	}
	if (data->log_stat & LOG_PID) {
		prlen = snprintf(p, tbuf_left, "[%ld]", (long)getpid());
		DEC();
	}
	if (data->log_tag != NULL) {
		if (tbuf_left > 1) {
			*p++ = ':';
			tbuf_left--;
		}
		if (tbuf_left > 1) {
			*p++ = ' ';
			tbuf_left--;
		}
	}

	for (t = fmt_cpy, fmt_left = FMT_SIZE;
	    (ch = *fmt) != '\0' && fmt_left > 1;
	    ++fmt) {
		if (ch == '%' && fmt[1] == 'm') {
			char ebuf[NL_TEXTMAX];

			++fmt;
			(void)strerror_r(saved_errno, ebuf, sizeof(ebuf));
			prlen = snprintf(t, fmt_left, "%s", ebuf);
			if (prlen < 0)
				prlen = 0;
			if (prlen >= fmt_left)
				prlen = fmt_left - 1;
			t += prlen;
			fmt_left -= prlen;
		} else if (ch == '%' && fmt[1] == '%' && fmt_left > 2) {
			++fmt;
			*t++ = '%';
			*t++ = '%';
			fmt_left -= 2;
		} else {
			*t++ = ch;
			fmt_left--;
		}
	}
	*t = '\0';

	prlen = vsnprintf(p, tbuf_left, fmt_cpy, ap);
	DEC();
	cnt = p - tbuf;
	while (cnt > 0 && p[-1] == '\n') {
		*(--p) = '\0';
		--cnt;
	}

	/* Output to stderr if requested. */
	if (data->log_stat & LOG_PERROR) {
		struct iovec iov[2];

		iov[0].iov_base = stdp;
		iov[0].iov_len = cnt > stdp - tbuf ? cnt - (stdp - tbuf) : 0;
		iov[1].iov_base = "\n";
		iov[1].iov_len = 1;
		(void)writev(STDERR_FILENO, iov, 2);
	}

	/*
	 * If the sendsyslog() fails, it means that syslogd
	 * is not running or the kernel ran out of buffers.
	 */
	sendsyslog(tbuf, cnt, data->log_stat & LOG_CONS);
}

void
openlog_r(const char *ident, int logstat, int logfac, struct syslog_data *data)
{
	if (ident != NULL)
		data->log_tag = ident;
	data->log_stat = logstat;
	if (logfac != 0 && (logfac &~ LOG_FACMASK) == 0)
		data->log_fac = logfac;
}
DEF_WEAK(openlog_r);

void
closelog_r(struct syslog_data *data)
{
	data->log_tag = NULL;
}
DEF_WEAK(closelog_r);
@


1.18
log
@Since sendsyslog(2) handles the LOG_CONS parameter, the variable
conp in syslog(3) is unused.  Remove dead code.
OK jca@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.17 2017/07/20 16:58:25 bluhm Exp $ */
d76 1
a76 1
#define	TBUF_SIZE	(8192+1)
@


1.17
log
@Rename TBUF_LEN and FMT_LEN to _SIZE as they contain a NUL byte.
Change FMT_SIZE to 1024+1 for consistency.  Do not loop over the
format string if there is no output space left.
OK deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.16 2016/10/19 16:09:24 millert Exp $ */
d78 1
a78 1
	char *conp = NULL, *stdp = NULL, tbuf[TBUF_SIZE], fmt_cpy[FMT_SIZE];
a114 2
	if (data->log_stat & LOG_CONS)
		conp = p;
@


1.16
log
@Use the reentrant strerror_r() instead of strerror() to expand %m.
Previously, syslog_r() would avoid calling strerror() since the latter
is not reentrant.  OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.15 2016/03/27 16:28:56 chl Exp $ */
d76 3
a78 3
#define	TBUF_LEN	(8192+1)
#define	FMT_LEN		1024
	char *conp = NULL, *stdp = NULL, tbuf[TBUF_LEN], fmt_cpy[FMT_LEN];
d101 1
a101 1
	tbuf_left = TBUF_LEN;
d141 3
a143 1
	for (t = fmt_cpy, fmt_left = FMT_LEN; (ch = *fmt); ++fmt) {
d157 1
a159 1
			fmt++;
d162 2
a163 4
			if (fmt_left > 1) {
				*t++ = ch;
				fmt_left--;
			}
@


1.15
log
@remove unused variable

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.14 2016/03/21 22:41:28 bluhm Exp $ */
a140 2
	/* strerror() is not reentrant */

d143 2
d146 2
a147 7
			if (reentrant) {
				prlen = snprintf(t, fmt_left, "Error %d",
				    saved_errno); 
			} else {
				prlen = snprintf(t, fmt_left, "%s",
				    strerror(saved_errno)); 
			}
@


1.14
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.13 2016/03/13 18:34:20 guenther Exp $ */
d75 1
a75 1
	int fd, saved_errno;
@


1.13
log
@environ and __progname are not declared in a public header; declare them
in libc's hidden/stdlib.h instead of in each .c file that needs one

ok deraadt@@ gsoares@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.12 2016/02/19 23:49:38 millert Exp $ */
d193 1
a193 1
	 * If the sendsyslog2() fails, it means that syslogd
d196 1
a196 1
	sendsyslog2(tbuf, cnt, data->log_stat & LOG_CONS);
@


1.12
log
@Remove the "error" variable; we no longer fall back to writing to
/dev/console so the value of "error" is never read.  Also mention
that sendsyslog2 can fail due to ENOBUFS in the comment.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.11 2015/11/25 00:01:21 deraadt Exp $ */
d39 1
a45 3

extern char	*__progname;		/* Program name, from crt0. */

@


1.11
log
@Add a syscall stub for sendsyslog2(2), and use it in syslog_r(3), passing
LOG_CONS to the kernel.  As a result, the /dev/console opening code can
be removed.
ok kettenis millert beck
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.10 2015/10/31 02:57:16 deraadt Exp $ */
d77 1
a77 1
	int fd, saved_errno, error;
d195 2
a196 2
	 * If the sendsyslog() fails, it means that syslogd
	 * is not running.
d198 1
a198 1
	error = sendsyslog2(tbuf, cnt, data->log_stat & LOG_CONS);
@


1.10
log
@Do not include a timestamp in the syslog message.  There is no need --
syslogd will fill it in immediately upon reception on the other side of
sendsyslog(2).  Our libc only talks to our syslogd, which will fix the
timestamp before forwarding.  syslog_r has done this for a long time
already.
ok tedu bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.9 2015/09/12 14:30:31 guenther Exp $ */
d198 1
a198 18
	error = sendsyslog(tbuf, cnt);

	/*
	 * Output the message to the console; try not to block
	 * as a blocking console should not stop other processes.
	 * Make sure the error reported is the one from the syslogd failure.
	 */
	if (error == -1 && (data->log_stat & LOG_CONS) &&
	    (fd = open(_PATH_CONSOLE, O_WRONLY|O_NONBLOCK, 0)) >= 0) {
		struct iovec iov[2];
		
		iov[0].iov_base = conp;
		iov[0].iov_len = cnt > conp - tbuf ? cnt - (conp - tbuf) : 0;
		iov[1].iov_base = "\r\n";
		iov[1].iov_len = 2;
		(void)writev(fd, iov, 2);
		(void)close(fd);
	}
@


1.9
log
@Wrap <syslog.h> so that internal calls go direct and they're all weak symbols
Delete code that's a no-op now that we don't use sockets
Eliminate unnecessary #includes
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.8 2015/09/09 10:50:59 bluhm Exp $ */
d64 1
a64 1
	__vsyslog_r(pri, data, NULL, fmt, ap);
d69 1
a69 4
 * This is used by both syslog_r and syslog.  The latter supplies
 * a non-NULL gettime callback for filling in the date, but we also
 * use the presence of that callback to decide whether it's safe
 * to call strerror and what the name of the caller is
d73 1
a73 1
    size_t (*gettime)(char *, size_t), const char *fmt, va_list ap)
d88 1
a88 1
		    gettime != NULL ? "" : "_r", pri);
a119 9
	/* 
	 * syslogd will expand time automagically for reentrant case, and
	 * for normal case, invoke the callback to do it just do like before
	 */
	if (gettime != NULL) {
		prlen = gettime(p, tbuf_left);
		DEC();
	}

d148 4
a151 1
			if (gettime != NULL) {
a153 3
			} else {
				prlen = snprintf(t, fmt_left, "Error %d",
				    saved_errno); 
@


1.8
log
@Syslogd can handle 8192 bytes per message now.  Increase the libc
syslog(3) limit to the same size.  The buffer needs one byte more
as it conains a NUL that sendsyslog(2) does not process.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.7 2015/01/21 19:34:24 deraadt Exp $ */
a31 1
#include <sys/syslog.h>
d40 1
a47 4
int	sendsyslog(const char *, size_t);

void	__vsyslog_r(int pri, struct syslog_data *, size_t (*)(char *, size_t),
    const char *, va_list);
a49 2

/* PRINTFLIKE3 */
d59 1
a63 2
	const char *ident;

a64 5

	/* close the socket without losing log_tag */
	ident = data->log_tag;
	closelog_r(data);
	data->log_tag = ident;
d66 1
d239 1
d246 1
a246 1

@


1.7
log
@Truncate progname to NAME_MAX in the syslog message, to ensure other
information also makes it through.  This is a compromise to cope with
the absolutely ridiculous setprogname() API.
ok various discussions
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.6 2014/10/03 15:41:18 bluhm Exp $ */
d92 1
a92 1
#define	TBUF_LEN	2048
@


1.6
log
@Strip trailing new-lines from syslog messages.  This avoids empty
lines when printing to console or stderr.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.5 2014/07/14 03:52:04 deraadt Exp $ */
d43 1
d148 1
a148 1
		prlen = snprintf(p, tbuf_left, "%s", data->log_tag);
@


1.5
log
@Convert syslog_r(3) to using sendsyslog(2).  This ensures that syslog_r(3)
can be used anywhere (signal handler, stack protector fault handler) as
long as the format string does not contain floating point.
ok tedu miod beck
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.4 2013/04/29 00:28:23 okan Exp $ */
d93 1
a93 1
	char *stdp, tbuf[TBUF_LEN], fmt_cpy[FMT_LEN];
d130 2
d200 4
d210 1
a210 1
		iov[0].iov_len = cnt - (stdp - tbuf);
d231 2
a232 3
		p = strchr(tbuf, '>') + 1;
		iov[0].iov_base = p;
		iov[0].iov_len = cnt - (p - tbuf);
@


1.4
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.3 2011/05/30 18:48:33 martynas Exp $ */
a31 1
#include <sys/socket.h>
a33 1
#include <sys/un.h>
d47 1
a47 2
static void	disconnectlog_r(struct syslog_data *);	/* disconnect from syslogd */
static void	connectlog_r(struct syslog_data *);	/* (re)connect to syslogd */
a209 5
	/* Get connected, output the message to the local logger. */
	if (!data->opened)
		openlog_r(data->log_tag, data->log_stat, 0, data);
	connectlog_r(data);

d211 2
a212 6
	 * If the send() failed, there are two likely scenarios:
	 *  1) syslogd was restarted
	 *  2) /dev/log is out of socket buffer space
	 * We attempt to reconnect to /dev/log to take care of
	 * case #1 and keep send()ing data to cover case #2
	 * to give syslogd a chance to empty its socket buffer.
d214 1
a214 13
	if ((error = send(data->log_file, tbuf, cnt, 0)) < 0) {
		if (errno != ENOBUFS) {
			disconnectlog_r(data);
			connectlog_r(data);
		}
		do {
			struct timespec rqt = { 0, 1000 };

			nanosleep(&rqt, NULL);
			if ((error = send(data->log_file, tbuf, cnt, 0)) >= 0)
				break;
		} while (errno == ENOBUFS);
	}
a234 40
static void
disconnectlog_r(struct syslog_data *data)
{
	/*
	 * If the user closed the FD and opened another in the same slot,
	 * that's their problem.  They should close it before calling on
	 * system services.
	 */
	if (data->log_file != -1) {
		close(data->log_file);
		data->log_file = -1;
	}
	data->connected = 0;		/* retry connect */
}

static void
connectlog_r(struct syslog_data *data)
{
	struct sockaddr_un SyslogAddr;	/* AF_UNIX address of local logger */

	if (data->log_file == -1) {
		if ((data->log_file = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1)
			return;
		(void)fcntl(data->log_file, F_SETFD, FD_CLOEXEC);
	}
	if (data->log_file != -1 && !data->connected) {
		memset(&SyslogAddr, '\0', sizeof(SyslogAddr));
		SyslogAddr.sun_len = sizeof(SyslogAddr);
		SyslogAddr.sun_family = AF_UNIX;
		strlcpy(SyslogAddr.sun_path, _PATH_LOG,
		    sizeof(SyslogAddr.sun_path));
		if (connect(data->log_file, (struct sockaddr *)&SyslogAddr,
		    sizeof(SyslogAddr)) == -1) {
			(void)close(data->log_file);
			data->log_file = -1;
		} else
			data->connected = 1;
	}
}

a242 5

	if (data->log_stat & LOG_NDELAY)	/* open immediately */
		connectlog_r(data);

	data->opened = 1;	/* ident and facility has been set */
a247 3
	(void)close(data->log_file);
	data->log_file = -1;
	data->connected = 0;
@


1.3
log
@Make printf-like and scanf-like functions marked as such in llib-lc.ln
and llib-lwrap.ln databases;  so that the lint features doing format
strings checks are enabled by default.

Looks good to millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.2 2009/11/21 10:23:31 chl Exp $ */
d282 1
a282 1
		(void)fcntl(data->log_file, F_SETFD, 1);
@


1.2
log
@remove unused variable

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog_r.c,v 1.1 2009/11/18 07:43:22 guenther Exp $ */
d57 1
@


1.1
log
@More shrinkage, a bit for ramdisks but mostly for static binaries:
- wrap with #ifndef NO_LOG_BAD_DNS_RESPONSES libc code that uses
  p_class() and p_type() for diagnostics, then add that define to
  libstub to avoid pulling in res_debug_syms.o
- split rcmd() and ruserok() into separate files, as nothing uses both
- split readdir_r() to its own file
- split syslog_r() from syslog(), as the latter needs localtime(); many
  binaries no longer need to pull in all the time code after this; switch
  from usleep() to nanosleep() while we're at it

(The profit of analysis of -Wl,-M,--cref output)

Chops 888kB from /bin and /sbin on i386

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syslog.c,v 1.29 2007/11/09 18:40:19 millert Exp $ */
a91 1
	time_t now;
@

