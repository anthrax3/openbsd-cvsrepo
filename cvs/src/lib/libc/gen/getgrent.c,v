head	1.46;
access;
symbols
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.4
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.38.0.6
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.37.0.8
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.6
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.6
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.4
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.8
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.6
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2015.12.01.15.08.25;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	FnyjPuUxHGEcyAdw;

1.45
date	2015.11.24.22.03.33;	author millert;	state Exp;
branches;
next	1.44;
commitid	LVVvCb2EklWn8nFM;

1.44
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.43;
commitid	iWfSX2BIn0sLw62l;

1.43
date	2015.09.13.12.20.12;	author guenther;	state Exp;
branches;
next	1.42;
commitid	VZVQQLMIEaW0iTla;

1.42
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	0DYulI8hhujBHMcR;

1.41
date	2014.09.15.06.15.48;	author guenther;	state Exp;
branches;
next	1.40;
commitid	ztgYHm1nk3mtTyS3;

1.40
date	2014.03.12.10.54.36;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2014.03.05.23.44.47;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2013.04.17.17.40.35;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.25.20.10.10;	author sthen;	state Exp;
branches;
next	1.36;

1.36
date	2009.12.19.22.41.39;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.09.00.18.27;	author kurt;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.22.01.23.16;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.21.16.04.23;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.07.03.52.54;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.07.00.02.48;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2009.06.05.19.38.18;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.05.17.08.37;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.04.08.29.13;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.03.16.02.44;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.25.22.30.19;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.24.14.29.45;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.16.04.14.23;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.25.15.38.47;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.07.21.11.23;	author marc;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.01.20.22.00;	author avsm;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.06.03.08.13;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.24.21.22.37;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.11.04.52.50;	author pvalchev;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.24.14.35.10;	author d;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.08.08.07.24;	author d;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.01.06.08.19.48;	author d;	state Exp;
branches;
next	1.10;

1.10
date	99.09.03.16.23.18;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.11.20.11.18.37;	author d;	state Exp;
branches;
next	1.8;

1.8
date	97.12.19.09.42.22;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.09.00.28.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.25.04.59.42;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.09.15.10.09.10;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.08.19.08.23.29;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.04.24.12.55.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.21.39.18;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.54;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2000.10.21.04.52.44;	author jason;	state Exp;
branches;
next	;


desc
@@


1.46
log
@modify getpw*(), getgr*(), and getgrouplist() functions to access the
YP lock file unconditionally.  This hints to the kernel that a "getpw"
operation is happening, even in the non-YP case.  This looks like a
gruesome hack, but helps refine the ways these functions are called
and mandates the right pledge requests.  Once the tree is fully annotated
we will know better how to improve the backing store management.
ok semarie espie beck
@
text
@/*	$OpenBSD: getgrent.c,v 1.45 2015/11/24 22:03:33 millert Exp $ */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Portions Copyright (c) 1994, Jason Downs. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>
#include <grp.h>
#include <errno.h>
#ifdef YP
#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "ypinternal.h"
#include "ypexclude.h"
#endif
#include "thread_private.h"

/* This global storage is locked for the non-rentrant functions */
_THREAD_PRIVATE_KEY(gr_storage);
static struct group_storage {
#define	MAXGRP		200
	char *members[MAXGRP];
#define	MAXLINELENGTH	1024
	char line[MAXLINELENGTH];
} gr_storage;
#define GETGR_R_SIZE_MAX	_GR_BUF_LEN

/* File pointers are locked with the 'gr' mutex */
_THREAD_PRIVATE_KEY(gr);
static FILE *_gr_fp;
static struct group _gr_group;
static int _gr_stayopen;
static int grscan(int, gid_t, const char *, struct group *, struct group_storage *,
	int *);
static int start_gr(void);
static void endgrent_basic(void);

static struct group *getgrnam_gs(const char *, struct group *,
	struct group_storage *);
static struct group *getgrgid_gs(gid_t, struct group *,
	struct group_storage *);

#ifdef YP
static struct _ypexclude *__ypexhead = NULL;
static int	__ypmode = 0;
static char	*__ypcurrent, *__ypdomain;
static int	__ypcurrentlen;
#endif

struct group *
_getgrent_yp(int *foundyp)
{
	struct group *p_gr = (struct group*)_THREAD_PRIVATE(gr, _gr_group, NULL);
	struct group_storage *gs = (struct group_storage *)_THREAD_PRIVATE(gr_storage,
	    gr_storage, NULL);

	_THREAD_PRIVATE_MUTEX_LOCK(gr);
	if ((!_gr_fp && !start_gr()) || !grscan(0, 0, NULL, p_gr, gs, foundyp))
		p_gr = NULL;
	_THREAD_PRIVATE_MUTEX_UNLOCK(gr);
	return (p_gr);
}

struct group *
getgrent(void)
{
	return (_getgrent_yp(NULL));
}

static struct group *
getgrnam_gs(const char *name, struct group *p_gr, struct group_storage *gs)
{
	int rval;

	_THREAD_PRIVATE_MUTEX_LOCK(gr);
	if (!start_gr())
		rval = 0;
	else {
		rval = grscan(1, 0, name, p_gr, gs, NULL);
		if (!_gr_stayopen)
			endgrent_basic();
	}
	_THREAD_PRIVATE_MUTEX_UNLOCK(gr);
	return(rval ? p_gr : NULL);
}

struct group *
getgrnam(const char *name)
{
	struct group *p_gr = (struct group*)_THREAD_PRIVATE(gr,_gr_group,NULL);
	struct group_storage *gs = (struct group_storage *)_THREAD_PRIVATE(gr_storage,
	    gr_storage, NULL);

	return getgrnam_gs(name, p_gr, gs);
}

int
getgrnam_r(const char *name, struct group *grp, char *buffer,
	size_t bufsize, struct group **result)
{
	int errnosave;
	int ret;

	if (bufsize < GETGR_R_SIZE_MAX)
		return ERANGE;
	errnosave = errno;
	errno = 0;
	*result = getgrnam_gs(name, grp, (struct group_storage *)buffer);
	if (*result == NULL)
		ret = errno;
	else
		ret = 0;
	errno = errnosave;
	return ret;
}

static struct group *
getgrgid_gs(gid_t gid, struct group *p_gr, struct group_storage *gs)
{
	int rval;

	_THREAD_PRIVATE_MUTEX_LOCK(gr);
	if (!start_gr())
		rval = 0;
	else {
		rval = grscan(1, gid, NULL, p_gr, gs, NULL);
		if (!_gr_stayopen)
			endgrent_basic();
	}
	_THREAD_PRIVATE_MUTEX_UNLOCK(gr);
	return(rval ? p_gr : NULL);
}

struct group *
getgrgid(gid_t gid)
{
	struct group *p_gr = (struct group*)_THREAD_PRIVATE(gr, _gr_group, NULL);
	struct group_storage *gs = (struct group_storage *)_THREAD_PRIVATE(gr_storage,
	    gr_storage, NULL);

	return getgrgid_gs(gid, p_gr, gs);
}

int
getgrgid_r(gid_t gid, struct group *grp, char *buffer, size_t bufsize,
	struct group **result)
{
	int errnosave;
	int ret;

	if (bufsize < GETGR_R_SIZE_MAX)
		return ERANGE;
	errnosave = errno;
	errno = 0;
	*result = getgrgid_gs(gid, grp, (struct group_storage *)buffer);
	if (*result == NULL)
		ret = errno;
	else
		ret = 0;
	errno = errnosave;
	return ret;
}
DEF_WEAK(getgrgid_r);

static int
start_gr(void)
{
	if (_gr_fp) {
		rewind(_gr_fp);
#ifdef YP
		__ypmode = 0;
		free(__ypcurrent);
		__ypcurrent = NULL;
		if (__ypexhead)
			__ypexclude_free(&__ypexhead);
		__ypexhead = NULL;
#endif
		return(1);
	}

#ifdef YP
	/*
	 * Hint to the kernel that a passwd database operation is happening.
	 */
	(void)access("/var/run/ypbind.lock", R_OK);
#endif

	return((_gr_fp = fopen(_PATH_GROUP, "re")) ? 1 : 0);
}

void
setgrent(void)
{
	int saved_errno;

	saved_errno = errno;
	setgroupent(0);
	errno = saved_errno;
}
DEF_WEAK(setgrent);

int
setgroupent(int stayopen)
{
	int retval;

	_THREAD_PRIVATE_MUTEX_LOCK(gr);
	if (!start_gr())
		retval = 0;
	else {
		_gr_stayopen = stayopen;
		retval = 1;
	}
	_THREAD_PRIVATE_MUTEX_UNLOCK(gr);
	return (retval);
}
DEF_WEAK(setgroupent);

static
void
endgrent_basic(void)
{
	int saved_errno;

	if (_gr_fp) {
		saved_errno = errno;
		fclose(_gr_fp);
		_gr_fp = NULL;
#ifdef YP
		__ypmode = 0;
		free(__ypcurrent);
		__ypcurrent = NULL;
		if (__ypexhead)
			__ypexclude_free(&__ypexhead);
		__ypexhead = NULL;
#endif
		errno = saved_errno;
	}
}

void
endgrent(void)
{
	_THREAD_PRIVATE_MUTEX_LOCK(gr);
	endgrent_basic();
	_THREAD_PRIVATE_MUTEX_UNLOCK(gr);
}
DEF_WEAK(endgrent);

static int
grscan(int search, gid_t gid, const char *name, struct group *p_gr,
    struct group_storage *gs, int *foundyp)
{
	char *cp, **m;
	char *bp, *endp;
	u_long ul;
#ifdef YP
	char *key, *data;
	int keylen, datalen;
	int r;
#endif
	char **members;
	char *line;
	int saved_errno;

	if (gs == NULL)
		return 0;
	members = gs->members;
	line = gs->line;
	saved_errno = errno;

	for (;;) {
#ifdef YP
		if (__ypmode) {
			if (__ypcurrent) {
				r = yp_next(__ypdomain, "group.byname",
				    __ypcurrent, __ypcurrentlen,
				    &key, &keylen, &data, &datalen);
				free(__ypcurrent);
				__ypcurrent = key;
				__ypcurrentlen = keylen;
			} else {
				r = yp_first(__ypdomain, "group.byname",
				    &__ypcurrent, &__ypcurrentlen,
				    &data, &datalen);
			}
			if (r) {
				__ypmode = 0;
				__ypcurrent = NULL;
				if (r == YPERR_NOMORE)
					continue;
				else
					return 0;
			}
			bcopy(data, line, datalen);
			free(data);
			line[datalen] = '\0';
			bp = line;
			goto parse;
		}
#endif
		if (!fgets(line, sizeof(gs->line), _gr_fp)) {
			if (feof(_gr_fp) && !ferror(_gr_fp))
				errno = saved_errno;
			return 0;
		}
		bp = line;
		/* skip lines that are too big */
		if (!strchr(line, '\n')) {
			int ch;

			while ((ch = getc_unlocked(_gr_fp)) != '\n' &&
			    ch != EOF)
				;
			continue;
		}
#ifdef YP
		if (line[0] == '+' || line[0] == '-') {
			if (__ypdomain == NULL &&
			    yp_get_default_domain(&__ypdomain))
				goto parse;
			switch (yp_bind(__ypdomain)) {
			case 0:
				break;
			case YPERR_BADARGS:
			case YPERR_YPBIND:
				goto parse;
			default:
				return 0;
			}
		}
		if (line[0] == '+') {
			switch (line[1]) {
			case ':':
			case '\0':
			case '\n':
				if (foundyp) {
					*foundyp = 1;
					errno = saved_errno;
					return 0;
				}
				if (!search) {
					__ypmode = 1;
					continue;
				}
				if (name) {
					r = yp_match(__ypdomain,
					    "group.byname", name, strlen(name),
					    &data, &datalen);
				} else {
					char buf[20];
					snprintf(buf, sizeof buf, "%u", gid);
					r = yp_match(__ypdomain, "group.bygid",
					    buf, strlen(buf), &data, &datalen);
				}
				switch (r) {
				case 0:
					break;
				case YPERR_KEY:
					continue;
				default:
					return 0;
				}
				bcopy(data, line, datalen);
				free(data);
				line[datalen] = '\0';
				bp = line;
				p_gr->gr_name = strsep(&bp, ":\n");
				if (__ypexclude_is(&__ypexhead, p_gr->gr_name))
					continue;
				p_gr->gr_passwd = strsep(&bp, ":\n");
				if (!(cp = strsep(&bp, ":\n")))
					continue;
				if (name) {
					ul = strtoul(cp, &endp, 10);
					if (*endp != '\0' || endp == cp ||
					    ul >= GID_MAX)
						continue;
					p_gr->gr_gid = ul;
				} else
					p_gr->gr_gid = gid;
				goto found_it;
			default:
				bp = strsep(&bp, ":\n") + 1;
				if ((search && name && strcmp(bp, name)) ||
				    __ypexclude_is(&__ypexhead, bp))
					continue;
				r = yp_match(__ypdomain, "group.byname",
				    bp, strlen(bp), &data, &datalen);
				switch (r) {
				case 0:
					break;
				case YPERR_KEY:
					continue;
				default:
					return 0;
				}
				bcopy(data, line, datalen);
				free(data);
				line[datalen] = '\0';
				bp = line;
			}
		} else if (line[0] == '-') {
			if (__ypexclude_add(&__ypexhead,
			    strsep(&line, ":\n") + 1))
				return 0;
			if (foundyp) {
				*foundyp = -1;
				errno = saved_errno;
				return 0;
			}
			continue;
		}
parse:
#endif
		p_gr->gr_name = strsep(&bp, ":\n");
		if (search && name && strcmp(p_gr->gr_name, name))
			continue;
#ifdef YP
		if (__ypmode && __ypexclude_is(&__ypexhead, p_gr->gr_name))
			continue;
#endif
		p_gr->gr_passwd = strsep(&bp, ":\n");
		if (!(cp = strsep(&bp, ":\n")))
			continue;
		ul = strtoul(cp, &endp, 10);
		if (endp == cp || *endp != '\0' || ul >= GID_MAX)
			continue;
		p_gr->gr_gid = ul;
		if (search && name == NULL && p_gr->gr_gid != gid)
			continue;
#ifdef YP
	found_it:
#endif
		cp = NULL;
		if (bp == NULL)
			continue;
		for (m = p_gr->gr_mem = members;; bp++) {
			if (m == &members[MAXGRP - 1])
				break;
			if (*bp == ',') {
				if (cp) {
					*bp = '\0';
					*m++ = cp;
					cp = NULL;
				}
			} else if (*bp == '\0' || *bp == '\n' || *bp == ' ') {
				if (cp) {
					*bp = '\0';
					*m++ = cp;
				}
				break;
			} else if (cp == NULL)
				cp = bp;
		}
		*m = NULL;
		errno = saved_errno;
		return 1;
	}
	/* NOTREACHED */
}
@


1.45
log
@Use reentrant versions of getpw{nam,uid} and getgr{nam,gid} within
libc to avoid reusing the static buffers returned by the non-reentrant
versions.  Since this is inside libc we can use constants for the
buffer sizes instead of having to call sysconf().
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.44 2015/09/14 16:09:13 tedu Exp $ */
d37 1
d211 8
@


1.44
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.43 2015/09/13 12:20:12 guenther Exp $ */
a172 1
DEF_WEAK(getgrgid);
d193 1
@


1.43
log
@Wrap <grp.h> so that calls go direct and the symbols are all weak.
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.42 2015/01/16 16:48:51 deraadt Exp $ */
d202 1
a202 2
		if (__ypcurrent)
			free(__ypcurrent);
d253 1
a253 2
		if (__ypcurrent)
			free(__ypcurrent);
@


1.42
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.41 2014/09/15 06:15:48 guenther Exp $ */
d173 1
d223 1
d240 1
d272 1
@


1.41
log
@When fopen()ing internal to libc (the API doesn't support the use
of the resulting FILE *), then pass fopen() the 'e' mode letter to
mark it close-on-exec.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.40 2014/03/12 10:54:36 schwarze Exp $ */
a32 1
#include <sys/param.h>
d36 1
@


1.40
log
@Make sure that setgrent(), endgrent(), and endpwent() do not clobber
errno; they might do so on open() and close() failures, but by POSIX,
they are not supposed to fail.  Note that ignoring failures inside
setgrent() does not matter, the following getgrent() is bound to
fail the same way again, anyway.  If you insist on detecting open()
failure, use setgroupent(), even though that is less portable.
While here, remove two pointless (void) casts.
ok millert@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.39 2014/03/05 23:44:47 schwarze Exp $ */
d210 1
a210 1
	return((_gr_fp = fopen(_PATH_GROUP, "r")) ? 1 : 0);
@


1.39
log
@Fix the return values of getpwnam_r(), getpwuid_r(), getgrnam_r(),
and getgrgid_r() to agree with POSIX.  Not touching errno handling
yet, which will also need fixing.

Problem originally reported by william at 25thandClement dot com on bugs@@.
OK sthen@@, and kettenis@@ agrees it's "a step in the right direction".
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.38 2013/04/17 17:40:35 tedu Exp $ */
d216 5
a220 1
	(void) setgroupent(0);
d243 2
d246 2
a247 1
		(void)fclose(_gr_fp);
d258 1
@


1.38
log
@add some prototypes, casts, includes, parenthesis, and whatnot to
silence some warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.37 2011/04/25 20:10:10 sthen Exp $ */
d137 1
d184 1
@


1.37
log
@Teach sysconf(_SC_GETGR_R_SIZE_MAX) the correct size of a buffer for the
reentrant getgrent functions (getgrgid_r, getgrnam_r).

seems reasonable to millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.36 2009/12/19 22:41:39 schwarze Exp $ */
d395 1
a395 1
				if (search && name && strcmp(bp, name) ||
@


1.36
log
@Implement proper error handling for getgrent(3), getgrnam(3) and getgrgid(3).

1) Distinguish normal end of data (like eof, YPERR_NOMORE, YPERR_KEY)
   from error conditions.
2) Save errno(2) and restore it in case of success, as suggested by deraadt@@
   and beck@@.

While this code is touched,
 * move the common code for the yp_first and yp_next calls after the
   respective if/else-block; note that free(data) is not needed in case of
   failure and that __ypcurrent = NULL does no harm after failing yp_first.
 * return 0, not NULL: the return value of grscan is int, not a pointer.

This is the last part of the work done on getgrent.c during c2k9,
heavily relying on the other improvements done at that time.
This has been rotting in my tree far too long.

"get it in" deraadt@@; also lightly tested by simon@@ some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.35 2009/11/09 00:18:27 kurt Exp $ */
d56 1
a56 1
#define GETGR_R_SIZE_MAX	(1024+200*sizeof(char*))
@


1.35
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

committing on behalf of and okay guenther@@ now that we have install
media space available.
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.34 2009/10/22 01:23:16 guenther Exp $ */
d274 1
d280 1
a289 6
				if (r) {
					__ypcurrent = NULL;
					__ypmode = 0;
					free(data);
					continue;
				}
a291 2
				bcopy(data, line, datalen);
				free(data);
d296 5
a300 3
				if (r) {
					__ypmode = 0;
					free(data);
d302 2
a303 3
				}
				bcopy(data, line, datalen);
				free(data);
d305 2
d312 5
a316 2
		if (!fgets(line, sizeof(gs->line), _gr_fp))
			return(0);
d349 2
a350 1
					return (NULL);
d366 4
a369 1
				if (r != 0)
d371 3
d400 4
a403 1
				if (r)
d405 3
d414 8
a421 6
			if(!__ypexclude_add(&__ypexhead,
					    strsep(&line, ":\n") + 1))
				if (foundyp) {
					*foundyp = -1;
					return (NULL);
				}
d467 2
a468 1
		return(1);
@


1.34
log
@Back out previous commit, as it caused too much growth for the install
media to fit
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.33 2009/10/21 16:04:23 guenther Exp $ */
d322 2
a323 1
			while ((ch = getc(_gr_fp)) != '\n' && ch != EOF)
@


1.33
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

ok kurt@@, earlier version tested by sthen@@ and jj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.32 2009/06/07 03:52:54 schwarze Exp $ */
d322 1
a322 2
			while ((ch = getc_unlocked(_gr_fp)) != '\n' &&
			    ch != EOF)
@


1.32
log
@de-spaghetti:
If code is used from exactly one place, don't jump back dozens of lines to
reach it, only to "goto" back where you came from.
Instead, simply put the code where it belongs.
Also fixes a regression that crept in in rev. 1.30: After clearing the
variable __ypmode, don't try to make decisions based on its former value.
As a bonus, garbage collect the grname variable and the _ypmode enum type.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.31 2009/06/07 00:02:48 schwarze Exp $ */
d322 2
a323 1
			while ((ch = getc(_gr_fp)) != '\n' && ch != EOF)
@


1.31
log
@No need to malloc, copy, have a single read access, and free right away.
Thus, garbage collect one variable, one strdup, one free, two ifs,
one else and a couple of assignments.  No functional change.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.30 2009/06/05 19:38:18 schwarze Exp $ */
d75 1
a75 2
enum _ypmode { YPMODE_NONE, YPMODE_FULL, YPMODE_NAME };
static enum _ypmode __ypmode;
d198 1
a198 1
		__ypmode = YPMODE_NONE;
d241 1
a241 1
		__ypmode = YPMODE_NONE;
d282 1
a282 4
		char *grname;

		switch (__ypmode) {
		case YPMODE_FULL:
d290 1
a290 1
					__ypmode = YPMODE_NONE;
d303 1
a303 1
					__ypmode = YPMODE_NONE;
a309 17
			break;
		case YPMODE_NAME:
				r = yp_match(__ypdomain, "group.byname",
				    grname, strlen(grname),
				    &data, &datalen);
				__ypmode = YPMODE_NONE;
				if (r) {
					free(data);
					continue;
				}
				bcopy(data, line, datalen);
				free(data);
			break;
		case YPMODE_NONE:
			break;
		}
		if (__ypmode != YPMODE_NONE) {
d351 1
a351 1
					__ypmode = YPMODE_FULL;
d386 7
a392 3
				grname = strsep(&bp, ":\n") + 1;
				if (search && name && strcmp(grname, name) ||
				    __ypexclude_is(&__ypexhead, grname))
d394 4
a397 2
				__ypmode = YPMODE_NAME;
				continue;
d414 1
a414 2
		if (__ypmode == YPMODE_FULL &&
		    __ypexclude_is(&__ypexhead, p_gr->gr_name))
@


1.30
log
@The yp_bind(3) return code now distinguishes "YP not active" from "an error
occurred".  Based on this, decide to either bail or use the record as is.
Prevents getgrnam(3) and friends from silently skipping YP records
on system errors, for example when out of memory.
Also, calling yp_get_default_domain once is enough.
The first two switch cases are unchanged, just reindented.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.29 2009/06/05 17:08:37 schwarze Exp $ */
a271 1
	char *grname = (char *)NULL;
d283 2
a315 1
			if (grname) {
a319 2
				free(grname);
				grname = NULL;
a325 5
			} else {
				/* Cannot happen, handle it just to be safe. */
				__ypmode = YPMODE_NONE;
				continue;
			}
a362 2
			char *tptr;

d407 3
a409 4
				tptr = strsep(&bp, ":\n");
				tptr++;
				if (search && name && strcmp(tptr, name) ||
				    __ypexclude_is(&__ypexhead, tptr))
a411 2
				if ((grname = strdup(tptr)) == NULL)
					return 0;
@


1.29
log
@When parsing a line stating with "+" or "-" in group(5),
check whether YP is active up front, not half-way through the parsing.
This fixes the bug that group names starting with a dash (yuck!)
were skipped when YP was not active, introduced in rev. 1.27.
Besides, the code becomes easier to understand.
The code inside the two switch cases is unchanged, just reindented.
"looks good" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.28 2009/06/04 08:29:13 schwarze Exp $ */
d284 9
a292 4
		if (__ypmode != YPMODE_NONE) {

			if (!__ypdomain) {
				if (yp_get_default_domain(&__ypdomain)) {
d294 1
a294 4
					if (grname != (char *)NULL) {
						free(grname);
						grname = (char *)NULL;
					}
d297 10
a306 28
			}
			switch (__ypmode) {
			case YPMODE_FULL:
				if (__ypcurrent) {
					r = yp_next(__ypdomain, "group.byname",
					    __ypcurrent, __ypcurrentlen,
					    &key, &keylen, &data, &datalen);
					free(__ypcurrent);
					if (r != 0) {
						__ypcurrent = NULL;
						__ypmode = YPMODE_NONE;
						free(data);
						continue;
					}
					__ypcurrent = key;
					__ypcurrentlen = keylen;
					bcopy(data, line, datalen);
					free(data);
				} else {
					r = yp_first(__ypdomain, "group.byname",
					    &__ypcurrent, &__ypcurrentlen,
					    &data, &datalen);
					if (r != 0) {
						__ypmode = YPMODE_NONE;
						free(data);
						continue;
					}
					bcopy(data, line, datalen);
d308 1
d310 13
a322 14
				break;
			case YPMODE_NAME:
				if (grname != (char *)NULL) {
					r = yp_match(__ypdomain, "group.byname",
					    grname, strlen(grname),
					    &data, &datalen);
					__ypmode = YPMODE_NONE;
					free(grname);
					grname = (char *)NULL;
					if (r != 0) {
						free(data);
						continue;
					}
					bcopy(data, line, datalen);
a323 2
				} else {
					__ypmode = YPMODE_NONE;	/* ??? */
d326 6
a331 4
				break;
			case YPMODE_NONE:
				/* NOTREACHED */
				break;
d333 5
d355 14
a368 3
		if ((line[0] == '+' || line[0] == '-') && !_yp_check(NULL))
			goto parse;

a383 3
				if (!__ypdomain &&
				    yp_get_default_domain(&__ypdomain))
					continue;
@


1.28
log
@in case a handling a +groupname:*:: entry fails due to lack of memory,
do not just skip the entry, but report the error condition;
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.27 2009/06/03 16:02:44 schwarze Exp $ */
d366 3
d370 2
d380 33
a412 36
				if (_yp_check(NULL)) {
					if (!search) {
						__ypmode = YPMODE_FULL;
						continue;
					}
					if (!__ypdomain &&
					    yp_get_default_domain(&__ypdomain))
						continue;
					if (name) {
						r = yp_match(__ypdomain,
						    "group.byname",
						    name, strlen(name),
						    &data, &datalen);
					} else {
						char buf[20];

						snprintf(buf, sizeof buf,
						    "%u", gid);
						r = yp_match(__ypdomain,
						    "group.bygid",
						    buf, strlen(buf),
						    &data, &datalen);
					}
					if (r != 0)
						continue;
					bcopy(data, line, datalen);
					free(data);
					line[datalen] = '\0';
					bp = line;
					p_gr->gr_name = strsep(&bp, ":\n");
					if (__ypexclude_is(&__ypexhead,
							   p_gr->gr_name))
						continue;
					p_gr->gr_passwd =
						strsep(&bp, ":\n");
					if (!(cp = strsep(&bp, ":\n")))
d414 4
a417 11
					if (name) {
						ul = strtoul(cp, &endp, 10);
						if (*endp != '\0' ||
						    endp == cp || ul >= GID_MAX)
							continue;
						p_gr->gr_gid = ul;
					} else
						p_gr->gr_gid = gid;
					goto found_it;
				}
				break;
d419 4
a422 12
				if (_yp_check(NULL)) {
					char *tptr;

					tptr = strsep(&bp, ":\n");
					tptr++;
					if (search && name &&
						strcmp(tptr, name) ||
					    __ypexclude_is(&__ypexhead, tptr))
						continue;
					__ypmode = YPMODE_NAME;
					if ((grname = strdup(tptr)) == NULL)
						return (0);
d424 4
a427 2
				}
				break;
@


1.27
log
@Take advantage of the surprise libc bump to bring in
YP group(5) exclusion, i.e. support -groupname:*:: in /etc/group.
Such groups will be excluded from later +:*::,
in just the same was as it is already done for passwd(5).
I have been running this since the autumn of 2008.
Discussed with several (including deraadt@@, millert@@, jmc@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.26 2008/08/25 22:30:19 deraadt Exp $ */
d434 2
a435 1
					grname = strdup(tptr);
@


1.26
log
@correct +name handling; schwarze@@usta.de
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.25 2008/06/24 14:29:45 deraadt Exp $ */
d44 1
d74 1
d203 3
d246 3
d405 3
d429 3
a431 1
					if (search && name && strcmp(tptr, name))
d439 8
d453 5
@


1.25
log
@create a private getpwent()-like interface which does not walk the YP
groups map but instead tells us that it is there.  then use this interface
in getgrouplist(), and do a single lookup against netid.byname instead to
get all the groups associated with that user
ok kurt, testing by many others
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.24 2007/05/16 04:14:23 ray Exp $ */
a358 4
			if (foundyp) {
				*foundyp = 1;
				return (NULL);
			}
d363 4
d417 1
d421 1
a421 1
					grname = strdup(tptr + 1);
@


1.24
log
@Wrap some functions, labels, and variables in #ifdefs corresponding
to #ifdefs where they are used.  Found by lint by bret dot lambert
at gmail.

OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrent.c,v 1.23 2005/08/08 08:05:34 espie Exp $ */
d62 2
a63 1
static int grscan(int, gid_t, const char *, struct group *, struct group_storage *);
d80 1
a80 1
getgrent(void)
d87 1
a87 1
	if ((!_gr_fp && !start_gr()) || !grscan(0, 0, NULL, p_gr, gs))
d93 6
d108 1
a108 1
		rval = grscan(1, 0, name, p_gr, gs);
d154 1
a154 1
		rval = grscan(1, gid, NULL, p_gr, gs);
d255 1
a255 1
    struct group_storage *gs)
d359 4
@


1.23
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d429 1
d431 1
@


1.22
log
@deregister (and deauto!). ok millert@@ marco@@
@
text
@d1 1
a30 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.21 2004/06/07 21:11:23 marc Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.21
log
@
major bump to libc and libpthread to break the dependency of a
particular implementation of libpthread for libc.  libc no longer
needs pthread.h to compile.
OK millert@@, brad@@, tedu@@
@
text
@d32 1
a32 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.20 2004/05/18 02:05:52 jfb Exp $";
d253 1
a253 1
	register char *cp, **m;
d406 1
a406 1
					register char *tptr;
@


1.20
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d32 1
a32 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.19 2003/06/02 20:18:34 millert Exp $";
a61 1
_THREAD_PRIVATE_MUTEX(gr);
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d32 1
a32 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.18 2003/05/01 20:22:00 avsm Exp $";
d83 1
a83 1
getgrent()
d97 1
a97 4
getgrnam_gs(name, p_gr, gs)
	const char *name;
	struct group *p_gr;
	struct group_storage *gs;
d114 1
a114 2
getgrnam(name)
	const char *name;
d124 2
a125 6
getgrnam_r(name, grp, buffer, bufsize, result)
	const char *name;
	struct group *grp;
	char *buffer;
	size_t bufsize;
	struct group **result;
d143 1
a143 4
getgrgid_gs(gid, p_gr, gs)
	gid_t gid;
	struct group *p_gr;
	struct group_storage *gs;
d160 1
a160 2
getgrgid(gid)
	gid_t gid;
d170 2
a171 6
getgrgid_r(gid, grp, buffer, bufsize, result)
	gid_t gid;
	struct group *grp;
	char *buffer;
	size_t bufsize;
	struct group **result;
d189 1
a189 1
start_gr()
d205 1
a205 1
setgrent()
d211 1
a211 2
setgroupent(stayopen)
	int stayopen;
d228 1
a228 1
endgrent_basic()
d243 1
a243 1
endgrent()
d251 2
a252 6
grscan(search, gid, name, p_gr, gs)
	register int search;
	register gid_t gid;
	register const char *name;
	struct group *p_gr;
	struct group_storage *gs;
@


1.18
log
@add missing enumeration case to select to kill gcc warning
millert@@ ok
@
text
@d14 1
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d32 1
a32 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.17 2002/07/06 03:08:13 deraadt Exp $";
@


1.17
log
@KNF
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.16 2002/05/24 21:22:37 deraadt Exp $";
d358 3
@


1.16
log
@try to use strlcpy and snprintf more; ok various
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.15 2002/02/16 21:27:22 millert Exp $";
d89 3
a91 2
	struct group *p_gr = (struct group*)_THREAD_PRIVATE(gr,_gr_group,NULL);
	struct group_storage *gs = (struct group_storage *)_THREAD_PRIVATE(gr_storage,gr_storage,NULL);
d125 2
a126 1
	struct group_storage *gs = (struct group_storage *)_THREAD_PRIVATE(gr_storage,gr_storage,NULL);
d178 3
a180 2
	struct group *p_gr = (struct group*)_THREAD_PRIVATE(gr,_gr_group,NULL);
	struct group_storage *gs = (struct group_storage *)_THREAD_PRIVATE(gr_storage,gr_storage,NULL);
d215 1
a215 1
		if(__ypcurrent)
d256 1
a256 1
		if(__ypcurrent)
d298 1
a298 1
		if(__ypmode != YPMODE_NONE) {
d300 2
a301 2
			if(!__ypdomain) {
				if(yp_get_default_domain(&__ypdomain)) {
d303 1
a303 1
					if(grname != (char *)NULL) {
d310 1
a310 1
			switch(__ypmode) {
d312 1
a312 1
				if(__ypcurrent) {
d314 2
a315 2
						__ypcurrent, __ypcurrentlen,
						&key, &keylen, &data, &datalen);
d317 1
a317 1
					if(r != 0) {
d329 3
a331 3
						&__ypcurrent, &__ypcurrentlen,
						&data, &datalen);
					if(r != 0) {
d341 1
a341 1
				if(grname != (char *)NULL) {
d343 2
a344 2
						grname, strlen(grname),
						&data, &datalen);
d348 1
a348 1
					if(r != 0) {
d378 1
a378 1
			switch(line[1]) {
d382 1
a382 1
				if(_yp_check(NULL)) {
d387 2
a388 2
					if(!__ypdomain &&
					   yp_get_default_domain(&__ypdomain))
d428 1
a428 1
				if(_yp_check(NULL)) {
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.14 2001/09/11 04:52:50 pvalchev Exp $";
d389 3
a391 3
							     "group.byname",
							     name, strlen(name),
							     &data, &datalen);
d394 3
a396 1
						sprintf(buf, "%u", gid);
d398 3
a400 3
							     "group.bygid",
							     buf, strlen(buf),
							     &data, &datalen);
@


1.14
log
@repair getgrgid_r() and getgrnam_r() as the standart says; from d@@
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.13 2000/09/24 14:35:10 d Exp $";
d70 3
a72 3
static int grscan __P((int, gid_t, const char *, struct group *, struct group_storage *));
static int start_gr __P((void));
static void endgrent_basic __P((void));
@


1.13
log
@unlock, instead of re-lock. fixes PR#1408
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.12 2000/01/08 08:07:24 d Exp $";
d45 1
d54 11
d70 1
a70 1
static int grscan __P((int, gid_t, const char *, struct group *));
d74 4
a77 7
_THREAD_PRIVATE_KEY(gr_storage);
static struct group_storage {
#define	MAXGRP		200
	char *members[MAXGRP];
#define	MAXLINELENGTH	1024
	char line[MAXLINELENGTH];
} gr_storage;
d87 1
a87 2
getgrent_r(p_gr)
struct group *p_gr;
d89 3
d93 1
a93 1
	if ((!_gr_fp && !start_gr()) || !grscan(0, 0, NULL, p_gr))
d99 2
a100 10
struct group *
getgrent()
{
	struct group *p_gr = (struct group*)_THREAD_PRIVATE(gr,_gr_group,NULL);

	return getgrent_r(p_gr);
}

struct group *
getgrnam_r(name, p_gr)
d103 1
d111 1
a111 1
		rval = grscan(1, 0, name, p_gr);
d124 1
d126 1
a126 1
	return getgrnam_r(name, p_gr);
d129 25
a153 2
struct group *
getgrgid_r(gid, p_gr)
d156 1
d164 1
a164 1
		rval = grscan(1, gid, NULL, p_gr);
d177 1
d179 24
a202 1
	return getgrgid_r(gid, p_gr);
d269 1
a269 1
grscan(search, gid, name, p_gr)
d274 1
a286 1
	struct group_storage *gs;
a287 2
	/* Always use thread-specific storage for member data. */
	gs = (struct group_storage *)_THREAD_PRIVATE(gr_storage,gr_storage,NULL);
@


1.12
log
@fix sizeof's when aliasing reentrant structures.
 (this caused group name lookups to fail)
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.11 2000/01/06 08:19:48 d Exp $";
d187 1
a187 1
	_THREAD_PRIVATE_MUTEX_LOCK(gr);
@


1.12.2.1
log
@Pull in patch from current:
Fix (d):
unlock, instead of re-lock. fixes PR#1408
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.12 2000/01/08 08:07:24 d Exp $";
d187 1
a187 1
	_THREAD_PRIVATE_MUTEX_UNLOCK(gr);
@


1.11
log
@use thread-specific storage for the members list
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.10 1999/09/03 16:23:18 millert Exp $";
d311 1
a311 1
		if (!fgets(line, sizeof(line), _gr_fp))
@


1.10
log
@Use strtol() and strtoul() instead of atoi().  This allows us to catch
errors reasonably and deal correctly with unsigned quantities.
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.9 1998/11/20 11:18:37 d Exp $";
d53 2
a54 2
_THREAD_PRIVATE_KEY(gr)
_THREAD_PRIVATE_MUTEX(gr)
d62 2
d65 1
a65 1
static char *members[MAXGRP];
d67 2
a68 1
static char line[MAXLINELENGTH];
d231 10
@


1.9
log
@Add thread-safety to libc, so that libc_r will build (on i386 at least).
All POSIX libc api now there (to P1003.1c/D10)
  (more md stuff is needed for other libc/arch/*)
  (setlogin is no longer a special syscall)
Add -pthread option to gcc (that makes it use -lc_r and -D_POSIX_THREADS).
Doc some re-entrant routines
Add libc_r to intro(3)
dig() uses some libc srcs and an extra -I was needed there.
Add more md stuff to libc_r.
Update includes for the pthreads api
Update libc_r TODO
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.8 1997/12/19 09:42:22 deraadt Exp $";
d76 1
a76 1
struct group * p_gr;
d124 1
a124 1
	struct group * p_gr;
d217 1
a217 1
	struct group * p_gr;
d220 2
a221 1
	char *bp;
d347 8
a354 2
					p_gr->gr_gid =
						name ? atoi(cp) : gid;
d380 4
a383 1
		p_gr->gr_gid = atoi(cp);
@


1.8
log
@gid_t is unsigned
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.7 1997/07/09 00:28:20 millert Exp $";
d51 1
d53 2
d58 1
a58 1
static int grscan __P((int, gid_t, const char *));
d60 1
d75 11
d88 22
a109 3
	if ((!_gr_fp && !start_gr()) || !grscan(0, 0, NULL))
		return(NULL);
	return(&_gr_group);
d116 10
d128 1
d130 8
a137 5
		return(NULL);
	rval = grscan(1, 0, name);
	if (!_gr_stayopen)
		endgrent();
	return(rval ? &_gr_group : NULL);
a140 3
#ifdef __STDC__
getgrgid(gid_t gid)
#else
a142 1
#endif
d144 1
a144 1
	int rval;
d146 1
a146 6
	if (!start_gr())
		return(NULL);
	rval = grscan(1, gid, NULL);
	if (!_gr_stayopen)
		endgrent();
	return(rval ? &_gr_group : NULL);
d175 3
d179 7
a185 3
		return(0);
	_gr_stayopen = stayopen;
	return(1);
d188 1
d190 1
a190 1
endgrent()
d204 8
d213 1
a213 1
grscan(search, gid, name)
d217 1
d341 2
a342 2
					_gr_group.gr_name = strsep(&bp, ":\n");
					_gr_group.gr_passwd =
d346 1
a346 1
					_gr_group.gr_gid =
d367 2
a368 2
		_gr_group.gr_name = strsep(&bp, ":\n");
		if (search && name && strcmp(_gr_group.gr_name, name))
d370 1
a370 1
		_gr_group.gr_passwd = strsep(&bp, ":\n");
d373 2
a374 2
		_gr_group.gr_gid = atoi(cp);
		if (search && name == NULL && _gr_group.gr_gid != gid)
d380 1
a380 1
		for (m = _gr_group.gr_mem = members;; bp++) {
@


1.7
log
@Clean up some -Wall complaints.
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.6 1997/01/25 04:59:42 downsj Exp $";
d273 1
a273 1
						sprintf(buf, "%d", gid);
@


1.6
log
@sync with NetBSD, changes from PR#3114, Michael.Eriksson@@era-t.ericsson.se
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.5 1996/09/15 10:09:10 tholo Exp $";
d73 1
a73 1
	if (!_gr_fp && !start_gr() || !grscan(0, 0, NULL))
@


1.5
log
@Add a couple of syscalls; bring more prototypes into scope
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.4 1996/08/19 08:23:29 tholo Exp $";
d166 3
a174 3
			char *key, *data;
			int keylen, datalen;
			int r;
d259 34
a292 2
					__ypmode = YPMODE_FULL;
					continue;
d299 3
a302 1
					tptr = strsep(&bp, ":\n");
d320 1
@


1.4
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getgrent.c,v 1.13 1995/07/28 05:43:57 phil Exp $";
d40 1
d49 1
@


1.3
log
@yp_prot.h lies -> use yp.h (from yp.x) instead, change lots of structure
accesses to match. change xdr_domainname() and some other functions to
take "char **" instead of "char *", as rpcgen intended -- helps programs
linking against rpcgen output of yp.x.  yp_all() should not free it's
return value. split xdryp.c and yplib.c into ~20 files so binaries like
"csh" need not link in functions like yp_maplist(). NIS+'s YP emulation
code lacks YPPROC_ORDER... attempt to deal nicely.
@
text
@a0 2
/*	$NetBSD: getgrent.c,v 1.13 1995/07/28 05:43:57 phil Exp $	*/

d36 1
a36 5
#if 0
static char sccsid[] = "@@(#)getgrent.c	8.2 (Berkeley) 3/21/94";
#else
static char rcsid[] = "$NetBSD: getgrent.c,v 1.13 1995/07/28 05:43:57 phil Exp $";
#endif
@


1.2
log
@Prototype internal functions
Do the right thing in presense of __STDC__
@
text
@d52 1
a52 1
#include <rpcsvc/yp_prot.h>
@


1.1
log
@Initial revision
@
text
@d59 2
a60 1
static int grscan(), start_gr();
d163 3
a165 2
	register int search, gid;
	register char *name;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
