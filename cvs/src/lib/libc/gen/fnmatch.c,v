head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.8
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.6
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.4
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.8
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.03.01.20.29.03;	author millert;	state Exp;
branches;
next	1.20;
commitid	eBc25J0hr3UJIaRU;

1.20
date	2016.02.26.21.15.31;	author millert;	state Exp;
branches;
next	1.19;
commitid	B6lo7Ygbuu6PK2Ef;

1.19
date	2015.08.01.18.11.08;	author millert;	state Exp;
branches;
next	1.18;
commitid	myA3v7izrH6Wzmk4;

1.18
date	2014.12.11.16.25.34;	author millert;	state Exp;
branches;
next	1.17;
commitid	a6OqjlcWUl5lW6v9;

1.17
date	2013.11.24.23.51.29;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2011.12.06.11.47.46;	author stsp;	state Exp;
branches;
next	1.15;

1.15
date	2011.02.10.21.31.59;	author stsp;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.01.23.04.13;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.31.05.34.14;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.23.19.13.51;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.03.19.00.29.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.09.22.05.03.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.23.21.09.04;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.09.00.28.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.22.44;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.53;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.53;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@KNF this file; OK stsp@@
@
text
@/*	$OpenBSD: fnmatch.c,v 1.20 2016/02/26 21:15:31 millert Exp $	*/

/* Copyright (c) 2011, VMware, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the VMware, Inc. nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL VMWARE, INC. OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 2008, 2016 Todd C. Miller <millert@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Authored by William A. Rowe Jr. <wrowe; apache.org, vmware.com>, April 2011
 *
 * Derived from The Open Group Base Specifications Issue 7, IEEE Std 1003.1-2008
 * as described in;
 *   http://pubs.opengroup.org/onlinepubs/9699919799/functions/fnmatch.html
 *
 * Filename pattern matches defined in section 2.13, "Pattern Matching Notation"
 * from chapter 2. "Shell Command Language"
 *   http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13
 * where; 1. A bracket expression starting with an unquoted <circumflex> '^'
 * character CONTINUES to specify a non-matching list; 2. an explicit <period> '.'
 * in a bracket expression matching list, e.g. "[.abc]" does NOT match a leading
 * <period> in a filename; 3. a <left-square-bracket> '[' which does not introduce
 * a valid bracket expression is treated as an ordinary character; 4. a differing
 * number of consecutive slashes within pattern and string will NOT match;
 * 5. a trailing '\' in FNM_ESCAPE mode is treated as an ordinary '\' character.
 *
 * Bracket expansion defined in section 9.3.5, "RE Bracket Expression",
 * from chapter 9, "Regular Expressions"
 *   http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05
 * with no support for collating symbols, equivalence class expressions or
 * character class expressions.  A partial range expression with a leading
 * hyphen following a valid range expression will match only the ordinary
 * <hyphen> and the ending character (e.g. "[a-m-z]" will match characters
 * 'a' through 'm', a <hyphen> '-', or a 'z').
 *
 * Supports BSD extensions FNM_LEADING_DIR to match pattern to the end of one
 * path segment of string, and FNM_CASEFOLD to ignore alpha case.
 *
 * NOTE: Only POSIX/C single byte locales are correctly supported at this time.
 * Notably, non-POSIX locales with FNM_CASEFOLD produce undefined results,
 * particularly in ranges of mixed case (e.g. "[A-z]") or spanning alpha and
 * nonalpha characters within a range.
 *
 * XXX comments below indicate porting required for multi-byte character sets
 * and non-POSIX locale collation orders; requires mbr* APIs to track shift
 * state of pattern and string (rewinding pattern and string repeatedly).
 *
 * Certain parts of the code assume 0x00-0x3F are unique with any MBCS (e.g.
 * UTF-8, SHIFT-JIS, etc).  Any implementation allowing '\' as an alternate
 * path delimiter must be aware that 0x5C is NOT unique within SHIFT-JIS.
 */

#include <fnmatch.h>
#include <string.h>
#include <ctype.h>

#include "charclass.h"

#define	RANGE_MATCH	1
#define	RANGE_NOMATCH	0
#define	RANGE_ERROR	(-1)

static int
classmatch(const char *pattern, char test, int foldcase, const char **ep)
{
	const char * const mismatch = pattern;
	const char *colon;
	struct cclass *cc;
	int rval = RANGE_NOMATCH;
	size_t len;

	if (pattern[0] != '[' || pattern[1] != ':') {
		*ep = mismatch;
		return RANGE_ERROR;
	}
	pattern += 2;

	if ((colon = strchr(pattern, ':')) == NULL || colon[1] != ']') {
		*ep = mismatch;
		return RANGE_ERROR;
	}
	*ep = colon + 2;
	len = (size_t)(colon - pattern);

	if (foldcase && strncmp(pattern, "upper:]", 7) == 0)
		pattern = "lower:]";
	for (cc = cclasses; cc->name != NULL; cc++) {
		if (!strncmp(pattern, cc->name, len) && cc->name[len] == '\0') {
			if (cc->isctype((unsigned char)test))
				rval = RANGE_MATCH;
			break;
		}
	}
	if (cc->name == NULL) {
		/* invalid character class, treat as normal text */
		*ep = mismatch;
		rval = RANGE_ERROR;
	}
	return rval;
}

/* Most MBCS/collation/case issues handled here.  Wildcard '*' is not handled.
 * EOS '\0' and the FNM_PATHNAME '/' delimiters are not advanced over,
 * however the "\/" sequence is advanced to '/'.
 *
 * Both pattern and string are **char to support pointer increment of arbitrary
 * multibyte characters for the given locale, in a later iteration of this code
 */
static int fnmatch_ch(const char **pattern, const char **string, int flags)
{
	const char * const mismatch = *pattern;
	const int nocase = !!(flags & FNM_CASEFOLD);
	const int escape = !(flags & FNM_NOESCAPE);
	const int slash = !!(flags & FNM_PATHNAME);
	int result = FNM_NOMATCH;
	const char *startch;
	int negate;

	if (**pattern == '[') {
		++*pattern;

		/* Handle negation, either leading ! or ^ operators */
		negate = (**pattern == '!') || (**pattern == '^');
		if (negate)
			++*pattern;

		/* ']' is an ordinary char at the start of the range pattern */
		if (**pattern == ']')
			goto leadingclosebrace;

		while (**pattern) {
			if (**pattern == ']') {
				++*pattern;
				/* XXX: Fix for MBCS character width */
				++*string;
				return (result ^ negate);
			}

			if (escape && (**pattern == '\\')) {
				++*pattern;

				/* Patterns must terminate with ']', not EOS */
				if (!**pattern)
					break;
			}

			/* Patterns must terminate with ']' not '/' */
			if (slash && (**pattern == '/'))
				break;

			/* Match character classes. */
			switch (classmatch(*pattern, **string, nocase, pattern)) {
			case RANGE_MATCH:
				result = 0;
				continue;
			case RANGE_NOMATCH:
				/* Valid character class but no match. */
				continue;
			default:
				/* Not a valid character class. */
				break;
			}
			if (!**pattern)
				break;

leadingclosebrace:
			/* Look at only well-formed range patterns;
			 * "x-]" is not allowed unless escaped ("x-\]")
			 * XXX: Fix for locale/MBCS character width
			 */
			if (((*pattern)[1] == '-') && ((*pattern)[2] != ']')) {
				startch = *pattern;
				*pattern += (escape && ((*pattern)[2] == '\\')) ? 3 : 2;

				/*
				 * NOT a properly balanced [expr] pattern, EOS
				 * terminated or ranges containing a slash in
				 * FNM_PATHNAME mode pattern fall out to to the
				 * rewind and test '[' literal code path.
				 */
				if (!**pattern || (slash && (**pattern == '/')))
					break;

				/* XXX: handle locale/MBCS comparison, advance by MBCS char width */
				if ((**string >= *startch) && (**string <= **pattern))
					result = 0;
				else if (nocase &&
				    (isupper((unsigned char)**string) ||
				     isupper((unsigned char)*startch) ||
				     isupper((unsigned char)**pattern)) &&
				    (tolower((unsigned char)**string) >=
				     tolower((unsigned char)*startch)) &&
				    (tolower((unsigned char)**string) <=
				     tolower((unsigned char)**pattern)))
					result = 0;

				++*pattern;
				continue;
			}

			/* XXX: handle locale/MBCS comparison, advance by MBCS char width */
			if ((**string == **pattern))
				result = 0;
			else if (nocase && (isupper((unsigned char)**string) ||
			    isupper((unsigned char)**pattern)) &&
			    (tolower((unsigned char)**string) ==
			    tolower((unsigned char)**pattern)))
				result = 0;

			++*pattern;
		}
		/*
		 * NOT a properly balanced [expr] pattern;
		 * Rewind and reset result to test '[' literal
		 */
		*pattern = mismatch;
		result = FNM_NOMATCH;
	} else if (**pattern == '?') {
		/* Optimize '?' match before unescaping **pattern */
		if (!**string || (slash && (**string == '/')))
			return FNM_NOMATCH;
		result = 0;
		goto fnmatch_ch_success;
	} else if (escape && (**pattern == '\\') && (*pattern)[1]) {
		++*pattern;
	}

	/* XXX: handle locale/MBCS comparison, advance by the MBCS char width */
	if (**string == **pattern)
		result = 0;
	else if (nocase && (isupper((unsigned char)**string) ||
	    isupper((unsigned char)**pattern)) &&
	    (tolower((unsigned char)**string) ==
	    tolower((unsigned char)**pattern)))
		result = 0;

	/* Refuse to advance over trailing slash or NULs */
	if (**string == '\0' || **pattern == '\0' ||
	    (slash && ((**string == '/') || (**pattern == '/'))))
		return result;

fnmatch_ch_success:
	++*pattern;
	++*string;
	return result;
}


int fnmatch(const char *pattern, const char *string, int flags)
{
	static const char dummystring[2] = {' ', 0};
	const int escape = !(flags & FNM_NOESCAPE);
	const int slash = !!(flags & FNM_PATHNAME);
	const int leading_dir = !!(flags & FNM_LEADING_DIR);
	const char *dummyptr, *matchptr, *strendseg;
	int wild;
	/* For '*' wild processing only; surpress 'used before initialization'
	 * warnings with dummy initialization values;
	 */
	const char *strstartseg = NULL;
	const char *mismatch = NULL;
	int matchlen = 0;

	if (*pattern == '*')
		goto firstsegment;

	while (*pattern && *string) {
		/*
		 * Pre-decode "\/" which has no special significance, and
		 * match balanced slashes, starting a new segment pattern.
		 */
		if (slash && escape && (*pattern == '\\') && (pattern[1] == '/'))
			++pattern;
		if (slash && (*pattern == '/') && (*string == '/')) {
			++pattern;
			++string;
		}

firstsegment:
		/*
		 * At the beginning of each segment, validate leading period
		 * behavior.
		 */
		if ((flags & FNM_PERIOD) && (*string == '.')) {
		    if (*pattern == '.')
			    ++pattern;
		    else if (escape && (*pattern == '\\') && (pattern[1] == '.'))
			    pattern += 2;
		    else
			    return FNM_NOMATCH;
		    ++string;
		}

		/*
		 * Determine the end of string segment.  Presumes '/'
		 * character is unique, not composite in any MBCS encoding
		 */
		if (slash) {
			strendseg = strchr(string, '/');
			if (!strendseg)
				strendseg = strchr(string, '\0');
		} else {
			strendseg = strchr(string, '\0');
		}

		/*
		 * Allow pattern '*' to be consumed even with no remaining
		 * string to match.
		 */
		while (*pattern) {
			if ((string > strendseg) ||
			    ((string == strendseg) && (*pattern != '*')))
				break;

			if (slash && ((*pattern == '/') ||
			    (escape && (*pattern == '\\') && (pattern[1] == '/'))))
				break;

			/*
			 * Reduce groups of '*' and '?' to n '?' matches
			 * followed by one '*' test for simplicity.
			 */
			for (wild = 0; (*pattern == '*') || (*pattern == '?'); ++pattern) {
				if (*pattern == '*') {
					wild = 1;
				} else if (string < strendseg) {  /* && (*pattern == '?') */
					/* XXX: Advance 1 char for MBCS locale */
					++string;
				}
				else {  /* (string >= strendseg) && (*pattern == '?') */
					return FNM_NOMATCH;
				}
			}

			if (wild) {
				strstartseg = string;
				mismatch = pattern;

				/*
				 * Count fixed (non '*') char matches remaining
				 * in pattern * excluding '/' (or "\/") and '*'.
				 */
				for (matchptr = pattern, matchlen = 0; 1; ++matchlen) {
					if ((*matchptr == '\0') ||
					    (slash && ((*matchptr == '/') ||
					    (escape && (*matchptr == '\\') &&
					    (matchptr[1] == '/'))))) {
						/* Compare precisely this many
						 * trailing string chars, the
						 * resulting match needs no
						 * wildcard loop.
						 */
						/* XXX: Adjust for MBCS */
						if (string + matchlen > strendseg)
							return FNM_NOMATCH;

						string = strendseg - matchlen;
						wild = 0;
						break;
					}

					if (*matchptr == '*') {
						/*
						 * Ensure at least this many
						 * trailing string chars remain
						 * for the first comparison.
						 */
						/* XXX: Adjust for MBCS */
						if (string + matchlen > strendseg)
							return FNM_NOMATCH;

						/*
						 * Begin first wild comparison
						 * at the current position.
						 */
						break;
					}

					/*
					 * Skip forward in pattern by a single
					 * character match Use a dummy
					 * fnmatch_ch() test to count one
					 * "[range]" escape.
					 */
					/* XXX: Adjust for MBCS */
					if (escape && (*matchptr == '\\') &&
					    matchptr[1]) {
						matchptr += 2;
					} else if (*matchptr == '[') {
						dummyptr = dummystring;
						fnmatch_ch(&matchptr, &dummyptr,
						    flags);
					} else {
						++matchptr;
					}
				}
			}

			/* Incrementally match string against the pattern. */
			while (*pattern && (string < strendseg)) {
				/* Success; begin a new wild pattern search. */
				if (*pattern == '*')
					break;

				if (slash && ((*string == '/') ||
				    (*pattern == '/') || (escape &&
				    (*pattern == '\\') && (pattern[1] == '/'))))
					break;

				/*
				 * Compare ch's (the pattern is advanced over
				 * "\/" to the '/', but slashes will mismatch,
				 * and are not consumed).
				 */
				if (!fnmatch_ch(&pattern, &string, flags))
					continue;

				/*
				 * Failed to match, loop against next char
				 * offset of string segment until not enough
				 * string chars remain to match the fixed
				 * pattern.
				 */
				if (wild) {
					/* XXX: Advance 1 char for MBCS locale */
					string = ++strstartseg;
					if (string + matchlen > strendseg)
						return FNM_NOMATCH;

					pattern = mismatch;
					continue;
				} else
					return FNM_NOMATCH;
			}
		}

		if (*string && !((slash || leading_dir) && (*string == '/')))
			return FNM_NOMATCH;

		if (*pattern && !(slash && ((*pattern == '/') ||
		    (escape && (*pattern == '\\') && (pattern[1] == '/')))))
			return FNM_NOMATCH;

		if (leading_dir && !*pattern && *string == '/')
			return 0;
	}

	/* Where both pattern and string are at EOS, declare success.  */
	if (!*string && !*pattern)
		return 0;

	/* Pattern didn't match to the end of string. */
	return FNM_NOMATCH;
}
@


1.20
log
@Fix negation of POSIX character classes; passed new regress test.
OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.19 2015/08/01 18:11:08 millert Exp $	*/
d5 1
a5 1
 * 
d16 1
a16 1
 * 
d54 3
a56 3
 * where; 1. A bracket expression starting with an unquoted <circumflex> '^' 
 * character CONTINUES to specify a non-matching list; 2. an explicit <period> '.' 
 * in a bracket expression matching list, e.g. "[.abc]" does NOT match a leading 
d65 2
a66 2
 * with no support for collating symbols, equivalence class expressions or 
 * character class expressions.  A partial range expression with a leading 
d68 1
a68 1
 * <hyphen> and the ending character (e.g. "[a-m-z]" will match characters 
d101 2
d104 1
a104 1
	const char *colon;
a105 2
	int rval = RANGE_NOMATCH;
	const char * const mismatch = pattern;
d107 1
a107 1
	if (*pattern != '[' || pattern[1] != ':') {
d109 1
a109 1
		return(RANGE_ERROR);
a110 1

d115 1
a115 1
		return(RANGE_ERROR);
d134 1
a134 1
	return(rval);
d138 1
a138 1
 * EOS '\0' and the FNM_PATHNAME '/' delimiters are not advanced over, 
d146 54
a199 56
    const char * const mismatch = *pattern;
    const int nocase = !!(flags & FNM_CASEFOLD);
    const int escape = !(flags & FNM_NOESCAPE);
    const int slash = !!(flags & FNM_PATHNAME);
    int result = FNM_NOMATCH;
    const char *startch;
    int negate;

    if (**pattern == '[')
    {
        ++*pattern;

        /* Handle negation, either leading ! or ^ operators (never both) */
        negate = ((**pattern == '!') || (**pattern == '^'));
        if (negate)
            ++*pattern;

        /* ']' is an ordinary character at the start of the range pattern */
        if (**pattern == ']')
            goto leadingclosebrace;

        while (**pattern)
        {
            if (**pattern == ']') {
                ++*pattern;
                /* XXX: Fix for MBCS character width */
                ++*string;
                return (result ^ negate);
            }

            if (escape && (**pattern == '\\')) {
                ++*pattern;

                /* Patterns must be terminated with ']', not EOS */
                if (!**pattern)
                    break;
            }

            /* Patterns must be terminated with ']' not '/' */
            if (slash && (**pattern == '/'))
                break;

            /* Match character classes. */
            switch (classmatch(*pattern, **string, nocase, pattern)) {
            case RANGE_MATCH:
                result = 0;
                continue;
            case RANGE_NOMATCH:
                /* Valid character class but no match. */
                continue;
            default:
                /* Not a valid character class. */
                break;
            }
            if (!**pattern)
                break;
d202 74
a275 74
            /* Look at only well-formed range patterns; 
             * "x-]" is not allowed unless escaped ("x-\]")
             * XXX: Fix for locale/MBCS character width
             */
            if (((*pattern)[1] == '-') && ((*pattern)[2] != ']'))
            {
                startch = *pattern;
                *pattern += (escape && ((*pattern)[2] == '\\')) ? 3 : 2;

                /* NOT a properly balanced [expr] pattern, EOS terminated 
                 * or ranges containing a slash in FNM_PATHNAME mode pattern
                 * fall out to to the rewind and test '[' literal code path
                 */
                if (!**pattern || (slash && (**pattern == '/')))
                    break;

                /* XXX: handle locale/MBCS comparison, advance by MBCS char width */
                if ((**string >= *startch) && (**string <= **pattern))
                    result = 0;
                else if (nocase && (isupper((unsigned char)**string) ||
			    isupper((unsigned char)*startch) ||
                            isupper((unsigned char)**pattern))
                            && (tolower((unsigned char)**string) >=
			        tolower((unsigned char)*startch)) 
                            && (tolower((unsigned char)**string) <=
				tolower((unsigned char)**pattern)))
                    result = 0;

                ++*pattern;
                continue;
            }

            /* XXX: handle locale/MBCS comparison, advance by MBCS char width */
            if ((**string == **pattern))
                result = 0;
            else if (nocase && (isupper((unsigned char)**string) ||
			    isupper((unsigned char)**pattern))
                            && (tolower((unsigned char)**string) ==
				tolower((unsigned char)**pattern)))
                result = 0;

            ++*pattern;
        }

        /* NOT a properly balanced [expr] pattern; Rewind
         * and reset result to test '[' literal
         */
        *pattern = mismatch;
        result = FNM_NOMATCH;
    }
    else if (**pattern == '?') {
        /* Optimize '?' match before unescaping **pattern */
        if (!**string || (slash && (**string == '/')))
            return FNM_NOMATCH;
        result = 0;
        goto fnmatch_ch_success;
    }
    else if (escape && (**pattern == '\\') && (*pattern)[1]) {
        ++*pattern;
    }

    /* XXX: handle locale/MBCS comparison, advance by the MBCS char width */
    if (**string == **pattern)
        result = 0;
    else if (nocase && (isupper((unsigned char)**string) ||
		    isupper((unsigned char)**pattern))
                    && (tolower((unsigned char)**string) ==
			tolower((unsigned char)**pattern)))
        result = 0;

    /* Refuse to advance over trailing slash or nulls
     */
    if (!**string || !**pattern || (slash && ((**string == '/') || (**pattern == '/'))))
        return result;
d278 3
a280 3
    ++*pattern;
    ++*string;
    return result;
d286 27
a312 29
    static const char dummystring[2] = {' ', 0};
    const int escape = !(flags & FNM_NOESCAPE);
    const int slash = !!(flags & FNM_PATHNAME);
    const int leading_dir = !!(flags & FNM_LEADING_DIR);
    const char *strendseg;
    const char *dummyptr;
    const char *matchptr;
    int wild;
    /* For '*' wild processing only; surpress 'used before initialization'
     * warnings with dummy initialization values;
     */
    const char *strstartseg = NULL;
    const char *mismatch = NULL;
    int matchlen = 0;

    if (*pattern == '*')
        goto firstsegment;

    while (*pattern && *string)
    {
        /* Pre-decode "\/" which has no special significance, and
         * match balanced slashes, starting a new segment pattern
         */
        if (slash && escape && (*pattern == '\\') && (pattern[1] == '/'))
            ++pattern;
        if (slash && (*pattern == '/') && (*string == '/')) {
            ++pattern;
            ++string;
        }            
d315 171
a485 167
        /* At the beginning of each segment, validate leading period behavior.
         */
        if ((flags & FNM_PERIOD) && (*string == '.'))
        {
            if (*pattern == '.')
                ++pattern;
            else if (escape && (*pattern == '\\') && (pattern[1] == '.'))
                pattern += 2;
            else
                return FNM_NOMATCH;
            ++string;
        }

        /* Determine the end of string segment
         *
         * Presumes '/' character is unique, not composite in any MBCS encoding
         */
        if (slash) {
            strendseg = strchr(string, '/');
            if (!strendseg)
                strendseg = strchr(string, '\0');
        }
        else {
            strendseg = strchr(string, '\0');
        }

        /* Allow pattern '*' to be consumed even with no remaining string to match
         */
        while (*pattern)
        {
            if ((string > strendseg)
                || ((string == strendseg) && (*pattern != '*')))
                break;

            if (slash && ((*pattern == '/')
                           || (escape && (*pattern == '\\')
                                      && (pattern[1] == '/'))))
                break;

            /* Reduce groups of '*' and '?' to n '?' matches
             * followed by one '*' test for simplicity
             */
            for (wild = 0; ((*pattern == '*') || (*pattern == '?')); ++pattern)
            {
                if (*pattern == '*') {
                    wild = 1;
                }
                else if (string < strendseg) {  /* && (*pattern == '?') */
                    /* XXX: Advance 1 char for MBCS locale */
                    ++string;
                }
                else {  /* (string >= strendseg) && (*pattern == '?') */
                    return FNM_NOMATCH;
                }
            }

            if (wild)
            {
                strstartseg = string;
                mismatch = pattern;

                /* Count fixed (non '*') char matches remaining in pattern
                 * excluding '/' (or "\/") and '*'
                 */
                for (matchptr = pattern, matchlen = 0; 1; ++matchlen)
                {
                    if ((*matchptr == '\0') 
                        || (slash && ((*matchptr == '/')
                                      || (escape && (*matchptr == '\\')
                                                 && (matchptr[1] == '/')))))
                    {
                        /* Compare precisely this many trailing string chars,
                         * the resulting match needs no wildcard loop
                         */
                        /* XXX: Adjust for MBCS */
                        if (string + matchlen > strendseg)
                            return FNM_NOMATCH;

                        string = strendseg - matchlen;
                        wild = 0;
                        break;
                    }

                    if (*matchptr == '*')
                    {
                        /* Ensure at least this many trailing string chars remain
                         * for the first comparison
                         */
                        /* XXX: Adjust for MBCS */
                        if (string + matchlen > strendseg)
                            return FNM_NOMATCH;

                        /* Begin first wild comparison at the current position */
                        break;
                    }

                    /* Skip forward in pattern by a single character match
                     * Use a dummy fnmatch_ch() test to count one "[range]" escape
                     */ 
                    /* XXX: Adjust for MBCS */
                    if (escape && (*matchptr == '\\') && matchptr[1]) {
                        matchptr += 2;
                    }
                    else if (*matchptr == '[') {
                        dummyptr = dummystring;
                        fnmatch_ch(&matchptr, &dummyptr, flags);
                    }
                    else {
                        ++matchptr;
                    }
                }
            }

            /* Incrementally match string against the pattern
             */
            while (*pattern && (string < strendseg))
            {
                /* Success; begin a new wild pattern search
                 */
                if (*pattern == '*')
                    break;

                if (slash && ((*string == '/')
                              || (*pattern == '/')
                              || (escape && (*pattern == '\\')
                                         && (pattern[1] == '/'))))
                    break;

                /* Compare ch's (the pattern is advanced over "\/" to the '/',
                 * but slashes will mismatch, and are not consumed)
                 */
                if (!fnmatch_ch(&pattern, &string, flags))
                    continue;

                /* Failed to match, loop against next char offset of string segment 
                 * until not enough string chars remain to match the fixed pattern
                 */
                if (wild) {
                    /* XXX: Advance 1 char for MBCS locale */
                    string = ++strstartseg;
                    if (string + matchlen > strendseg)
                        return FNM_NOMATCH;

                    pattern = mismatch;
                    continue;
                }
                else
                    return FNM_NOMATCH;
            }
        }

        if (*string && !((slash || leading_dir) && (*string == '/')))
            return FNM_NOMATCH;

        if (*pattern && !(slash && ((*pattern == '/')
                                    || (escape && (*pattern == '\\')
                                               && (pattern[1] == '/')))))
            return FNM_NOMATCH;

        if (leading_dir && !*pattern && *string == '/')
            return 0;
    }

    /* Where both pattern and string are at EOS, declare success
     */
    if (!*string && !*pattern)
        return 0;
d487 2
a488 2
    /* pattern didn't match to the end of string */
    return FNM_NOMATCH;
@


1.19
log
@Fix a potential out-of-bounds read found via address-sanitizer while
fuzzing as reported by Elliott Hughes.  OK doug@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.18 2014/12/11 16:25:34 millert Exp $	*/
d30 1
a30 1
 * Copyright (c) 2008 Todd C. Miller <millert@@openbsd.org>
d190 2
a191 2
            if (classmatch(*pattern, **string, nocase, pattern)
                == RANGE_MATCH) {
d194 6
@


1.18
log
@Remove an undocumented limit on the length of the pattern and string
to match of PATH_MAX.  As fnmatch() is used for matching more than
just pathnames, this can prevent legitimate matches for long strings
or partterns.  OK miod@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.17 2013/11/24 23:51:29 deraadt Exp $	*/
d195 2
@


1.17
log
@most obvious unsigned char casts for ctype
ok jca krw ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.16 2011/12/06 11:47:46 stsp Exp $	*/
a90 1
#include <limits.h>
a294 4

    if (strnlen(pattern, PATH_MAX) == PATH_MAX ||
        strnlen(string, PATH_MAX) == PATH_MAX)
            return (FNM_NOMATCH);
@


1.16
log
@New fnmatch(3) implementation which is not recursive.
Written and provided under BSD licence by William A. Rowe Jr.
Originally released in Apache APR-1.4.5.
Merged class matching code from r1.14 and PATH_MAX check from r1.15.
ok miod millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.15 2011/02/10 21:31:59 stsp Exp $	*/
d217 7
a223 4
                else if (nocase && (isupper(**string) || isupper(*startch)
                                                      || isupper(**pattern))
                            && (tolower(**string) >= tolower(*startch)) 
                            && (tolower(**string) <= tolower(**pattern)))
d233 4
a236 2
            else if (nocase && (isupper(**string) || isupper(**pattern))
                            && (tolower(**string) == tolower(**pattern)))
d262 4
a265 2
    else if (nocase && (isupper(**string) || isupper(**pattern))
                    && (tolower(**string) == tolower(**pattern)))
@


1.15
log
@Put a limit on recursion during matching, and reject input of size greater
or equal PATH_MAX. Based on similar fix made in NetBSD.
ok miod@@ millert@@
@
text
@d1 27
a27 1
/*	$OpenBSD: fnmatch.c,v 1.14 2008/10/01 23:04:13 millert Exp $	*/
d30 1
a30 2
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
d32 3
a34 2
 * This code is derived from software contributed to Berkeley by
 * Guido van Rossum.
d36 7
a42 23
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d45 41
a85 3
/*
 * Function fnmatch() as specified in POSIX 1003.2-1992, section B.6.
 * Compares a filename or pathname to a pattern.
d88 2
a90 3
#include <stdio.h>
#include <string.h>
#include <fnmatch.h>
a94 2
#define	EOS	'\0'

a98 193
/* Limit of recursion during matching attempts. */
#define __FNM_MAX_RECUR	64

static int rangematch(const char *, char, int, char **);
static int classmatch(const char *, char, int, const char **);
static int __fnmatch(const char *, const char *, int, int);

int
fnmatch(const char *pattern, const char *string, int flags)
{
	int e;

	if (strnlen(pattern, PATH_MAX) == PATH_MAX ||
	    strnlen(string, PATH_MAX) == PATH_MAX)
		return (FNM_NOMATCH);
		
	e = __fnmatch(pattern, string, flags, __FNM_MAX_RECUR);
	if (e == -1)
		e = FNM_NOMATCH;
	return (e);
}

static int
__fnmatch(const char *pattern, const char *string, int flags, int recur)
{
	const char *stringstart;
	char *newp;
	char c, test;
	int e;

	if (recur-- == 0)
		return (-1);

	for (stringstart = string;;)
		switch (c = *pattern++) {
		case EOS:
			if ((flags & FNM_LEADING_DIR) && *string == '/')
				return (0);
			return (*string == EOS ? 0 : FNM_NOMATCH);
		case '?':
			if (*string == EOS)
				return (FNM_NOMATCH);
			if (*string == '/' && (flags & FNM_PATHNAME))
				return (FNM_NOMATCH);
			if (*string == '.' && (flags & FNM_PERIOD) &&
			    (string == stringstart ||
			    ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
				return (FNM_NOMATCH);
			++string;
			break;
		case '*':
			c = *pattern;
			/* Collapse multiple stars. */
			while (c == '*')
				c = *++pattern;

			if (*string == '.' && (flags & FNM_PERIOD) &&
			    (string == stringstart ||
			    ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
				return (FNM_NOMATCH);

			/* Optimize for pattern with * at end or before /. */
			if (c == EOS) {
				if (flags & FNM_PATHNAME)
					return ((flags & FNM_LEADING_DIR) ||
					    strchr(string, '/') == NULL ?
					    0 : FNM_NOMATCH);
				else
					return (0);
			} else if (c == '/' && (flags & FNM_PATHNAME)) {
				if ((string = strchr(string, '/')) == NULL)
					return (FNM_NOMATCH);
				break;
			}

			/* General case, use recursion. */
			while ((test = *string) != EOS) {
				e = __fnmatch(pattern, string,
				    flags & ~FNM_PERIOD, recur);
				if (e != FNM_NOMATCH)
					return (e);
				if (test == '/' && (flags & FNM_PATHNAME))
					break;
				++string;
			}
			return (FNM_NOMATCH);
		case '[':
			if (*string == EOS)
				return (FNM_NOMATCH);
			if (*string == '/' && (flags & FNM_PATHNAME))
				return (FNM_NOMATCH);
			if (*string == '.' && (flags & FNM_PERIOD) &&
			    (string == stringstart ||
			    ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
				return (FNM_NOMATCH);

			switch (rangematch(pattern, *string, flags, &newp)) {
			case RANGE_ERROR:
				/* not a good range, treat as normal text */
				goto normal;
			case RANGE_MATCH:
				pattern = newp;
				break;
			case RANGE_NOMATCH:
				return (FNM_NOMATCH);
			}
			++string;
			break;
		case '\\':
			if (!(flags & FNM_NOESCAPE)) {
				if ((c = *pattern++) == EOS) {
					c = '\\';
					--pattern;
				}
			}
			/* FALLTHROUGH */
		default:
		normal:
			if (c != *string && !((flags & FNM_CASEFOLD) &&
				 (tolower((unsigned char)c) ==
				 tolower((unsigned char)*string))))
				return (FNM_NOMATCH);
			++string;
			break;
		}
	/* NOTREACHED */
}

static int
rangematch(const char *pattern, char test, int flags, char **newp)
{
	int negate, ok, rv;
	char c, c2;

	/*
	 * A bracket expression starting with an unquoted circumflex
	 * character produces unspecified results (IEEE 1003.2-1992,
	 * 3.13.2).  This implementation treats it like '!', for
	 * consistency with the regular expression syntax.
	 * J.T. Conklin (conklin@@ngai.kaleida.com)
	 */
	if ((negate = (*pattern == '!' || *pattern == '^')))
		++pattern;

	if (flags & FNM_CASEFOLD)
		test = (char)tolower((unsigned char)test);

	/*
	 * A right bracket shall lose its special meaning and represent
	 * itself in a bracket expression if it occurs first in the list.
	 * -- POSIX.2 2.8.3.2
	 */
	ok = 0;
	c = *pattern++;
	do {
		if (c == '[' && *pattern == ':') {
			do {
				rv = classmatch(pattern + 1, test,
				    (flags & FNM_CASEFOLD), &pattern);
				if (rv == RANGE_MATCH)
					ok = 1;
				c = *pattern++;
			} while (rv != RANGE_ERROR && c == '[' && *pattern == ':');
			if (c == ']')
				break;
		}
		if (c == '\\' && !(flags & FNM_NOESCAPE))
			c = *pattern++;
		if (c == EOS)
			return (RANGE_ERROR);
		if (c == '/' && (flags & FNM_PATHNAME))
			return (RANGE_NOMATCH);
		if ((flags & FNM_CASEFOLD))
			c = (char)tolower((unsigned char)c);
		if (*pattern == '-'
		    && (c2 = *(pattern+1)) != EOS && c2 != ']') {
			pattern += 2;
			if (c2 == '\\' && !(flags & FNM_NOESCAPE))
				c2 = *pattern++;
			if (c2 == EOS)
				return (RANGE_ERROR);
			if (flags & FNM_CASEFOLD)
				c2 = (char)tolower((unsigned char)c2);
			if (c <= test && test <= c2)
				ok = 1;
		} else if (c == test)
			ok = 1;
	} while ((c = *pattern++) != ']');

	*newp = (char *)pattern;
	return (ok == negate ? RANGE_NOMATCH : RANGE_MATCH);
}

d106 8
d116 1
a116 1
		*ep = pattern - 2;
d132 2
a133 2
		/* invalid character class, return EOS */
		*ep = colon + strlen(colon);
d137 343
@


1.14
log
@POSIX character class support for fnmatch(3) and glob(3).  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.13 2006/03/31 05:34:14 deraadt Exp $	*/
d44 1
d54 3
d59 1
d64 15
d82 4
d131 4
a134 2
				if (!fnmatch(pattern, string, flags & ~FNM_PERIOD))
					return (0);
@


1.13
log
@(char)to{upper,lower}()
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.12 2005/08/08 08:05:34 espie Exp $	*/
d45 2
d54 1
d159 1
a159 1
	int negate, ok;
d183 11
d219 32
@


1.12
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.11 2004/05/18 02:05:52 jfb Exp $	*/
d170 1
a170 1
		test = tolower((unsigned char)test);
d187 1
a187 1
			c = tolower((unsigned char)c);
d196 1
a196 1
				c2 = tolower((unsigned char)c2);
@


1.11
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.10 2003/06/02 20:18:34 millert Exp $	*/
a33 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)fnmatch.c	8.2 (Berkeley) 4/16/94";
#else
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.10 2003/06/02 20:18:34 millert Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.9 2002/02/19 19:39:36 millert Exp $	*/
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.9 2002/02/19 19:39:36 millert Exp $";
d62 1
a62 3
fnmatch(pattern, string, flags)
	const char *pattern, *string;
	int flags;
@


1.9
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.8 2002/02/16 21:27:22 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d39 1
a39 1
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.8 2002/02/16 21:27:22 millert Exp $";
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.7 2000/03/23 19:13:51 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.7 2000/03/23 19:13:51 millert Exp $";
a167 1
#ifdef __STDC__
a168 7
#else
rangematch(pattern, test, flags, newp)
	char *pattern;
	char test;
	int flags;
	char **newp;
#endif
@


1.7
log
@Add #ifdef __STDC__ around the rangematch function header to avoid
promotion of test to int, thus violating the prototype.  Gcc handles
this gracefully but more std ANSI compilers will complain.
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.6 1998/03/19 00:29:59 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.6 1998/03/19 00:29:59 millert Exp $";
d63 1
a63 1
static int rangematch __P((const char *, char, int, char **));
@


1.6
log
@some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: fnmatch.c,v 1.5 1997/09/22 05:03:30 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.5 1997/09/22 05:03:30 millert Exp $";
d168 3
d172 1
a172 1
	const char *pattern;
d176 1
@


1.5
log
@From FreeBSD:
    1) Add support for FNM_LEADING_DIR, FNM_CASEFOLD, FNM_IGNORECASE
    2) POSIX.2 fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.4 1997/07/23 21:09:04 kstailey Exp $";
d103 1
a103 1
			if (c == EOS)
d110 1
a110 1
			else if (c == '/' && (flags & FNM_PATHNAME)) {
@


1.4
log
@trailing blanks
@
text
@d1 2
d40 5
a44 1
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.3 1997/07/09 00:28:18 millert Exp $";
d52 3
a55 1
#include <string.h>
d59 5
a63 1
static const char *rangematch __P((const char *, int, int));
d71 1
d77 2
d105 2
a106 1
					return (strchr(string, '/') == NULL ?
d110 1
a110 1
			else if (c == '/' && flags & FNM_PATHNAME) {
d120 1
a120 1
				if (test == '/' && flags & FNM_PATHNAME)
d128 5
a132 1
			if (*string == '/' && flags & FNM_PATHNAME)
d134 9
a142 2
			if ((pattern =
			    rangematch(pattern, *string, flags)) == NULL)
d144 1
d156 4
a159 1
			if (c != *string++)
d161 1
d167 2
a168 2
static const char *
rangematch(pattern, test, flags)
d170 3
a172 1
	int test, flags;
d187 11
a197 1
	for (ok = 0; (c = *pattern++) != ']';) {
d201 5
a205 1
			return (NULL);
d212 3
a214 1
				return (NULL);
d219 4
a222 2
	}
	return (ok == negate ? NULL : pattern);
@


1.3
log
@Clean up some -Wall complaints.
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.2 1996/08/19 08:22:44 tholo Exp $";
d152 1
a152 1
	
d158 1
a158 1
		if (*pattern == '-' 
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fnmatch.c,v 1.11 1995/02/27 03:43:06 cgd Exp $";
d150 1
a150 1
	if (negate = (*pattern == '!' || *pattern == '^'))
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: fnmatch.c,v 1.11 1995/02/27 03:43:06 cgd Exp $	*/

d38 1
a38 5
#if 0
static char sccsid[] = "@@(#)fnmatch.c	8.2 (Berkeley) 4/16/94";
#else
static char rcsid[] = "$NetBSD: fnmatch.c,v 1.11 1995/02/27 03:43:06 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

