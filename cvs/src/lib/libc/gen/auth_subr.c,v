head	1.50;
access;
symbols
	OPENBSD_6_2:1.50.0.10
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.50.0.8
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.37.0.4
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.36.0.16
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.14
	OPENBSD_5_0:1.36.0.12
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.10
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.8
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.4
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.6
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.30.0.12
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.10
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.8
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.6
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.30.0.4
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4;
locks; strict;
comment	@ * @;


1.50
date	2015.12.28.22.08.18;	author mmcc;	state Exp;
branches;
next	1.49;
commitid	0uXuF2O13NH9q2e1;

1.49
date	2015.11.24.22.03.33;	author millert;	state Exp;
branches;
next	1.48;
commitid	LVVvCb2EklWn8nFM;

1.48
date	2015.11.02.17.03.29;	author mmcc;	state Exp;
branches;
next	1.47;
commitid	G5BHed9WFwNV5mth;

1.47
date	2015.10.23.04.52.21;	author guenther;	state Exp;
branches;
next	1.46;
commitid	jgTeOcF3yVZrUbc5;

1.46
date	2015.10.22.23.55.51;	author mmcc;	state Exp;
branches;
next	1.45;
commitid	9Qg7XwgrvsnoFpQO;

1.45
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.44;
commitid	iWfSX2BIn0sLw62l;

1.44
date	2015.09.12.15.20.14;	author guenther;	state Exp;
branches;
next	1.43;
commitid	2Q8C6yMAg0ltaqhX;

1.43
date	2015.09.03.04.27.49;	author daniel;	state Exp;
branches;
next	1.42;
commitid	Yhl63OSFD8njomAq;

1.42
date	2015.08.31.02.53.57;	author guenther;	state Exp;
branches;
next	1.41;
commitid	lTMF8Y3C9fQGd6jQ;

1.41
date	2014.08.25.07.50.25;	author doug;	state Exp;
branches;
next	1.40;
commitid	vcwz0sp1JH7QzUmA;

1.40
date	2014.05.25.17.47.04;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2013.11.24.23.51.29;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.09.30.12.02.32;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.08.02.26.09;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.15.13.14.30;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.24.16.10.59;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.03.15.16.19.02;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2008.03.13.01.49.52;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.01.00.55.20;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.17.07.07.23;	author moritz;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.02.20.38.36;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.30.18.14.33;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.09.01.39.31;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.08.03.19.43.31;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.23.03.48.42;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.10.16.45.56;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.08.04.07.54;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.11.21.03.10;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.04.22.36.09;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.22.23.27.45;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.22.19.47.03;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.30.14.54.34;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.24.17.13.36;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.16.19.45.41;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.15.20.17.11;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.10.15.17.47.27;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.15.17.10.57;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.13.21.12.59;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.04.22.44.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.27.22.21.22;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.24.21.22.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.13.21.39.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.05.07.51.52;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.14.16.50.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.02.19.22.34;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.24.21.18.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.23.00.38.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.21.19.43.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.21.04.17.44;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.21.00.51.16;	author millert;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Remove NULL-checks before free() and a few related dead assignments.

ok and valuable input from millert@@
@
text
@/*	$OpenBSD: auth_subr.c,v 1.49 2015/11/24 22:03:33 millert Exp $	*/

/*
 * Copyright (c) 2000-2002,2004 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*-
 * Copyright (c) 1995,1996,1997 Berkeley Software Design, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Berkeley Software Design,
 *	Inc.
 * 4. The name of Berkeley Software Design, Inc.  may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI $From: auth_subr.c,v 2.4 1999/09/08 04:10:40 prb Exp $
 */

#include <sys/time.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <paths.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include <login_cap.h>

#define	MAXSPOOLSIZE	(8*1024)	/* Spool up to 8K of back info */

struct rmfiles {
	struct rmfiles	*next;
	char		*file;
};

struct authopts {
	struct authopts	*next;
	char		*opt;
};

struct authdata {
	struct	authdata *next;
	void	*ptr;
	size_t	len;
};

struct auth_session_t {
	char	*name;			/* name of use being authenticated */
	char	*style;			/* style of authentication used */
	char	*class;			/* class of user */
	char	*service;		/* type of service being performed */
	char	*challenge;		/* last challenge issued */
	int	flags;			/* see below */
	struct	passwd *pwd;		/* password entry for user */
	struct	timeval now;		/* time of authentication */

	int	state;			/* authenticated state */

	struct	rmfiles *rmlist;	/* list of files to remove on failure */
	struct	authopts *optlist;	/* list of options to scripts */ 
	struct	authdata *data;		/* additional data to send to scripts */

	char	spool[MAXSPOOLSIZE];	/* data returned from login script */
	int	index;			/* how much returned thus far */

	int	fd;			/* connection to authenticator */

	va_list	ap0;			/* argument list to auth_call */
	va_list	ap;			/* additional arguments to auth_call */
};

/*
 * Internal flags
 */
#define	AF_INTERACTIVE		0x0001	/* This is an interactive session */

/*
 * We cannot include bsd_auth.h until we define the above structures
 */
#include <bsd_auth.h>

/*
 * Internally used functions
 */
static void _add_rmlist(auth_session_t *, char *);
static void _auth_spool(auth_session_t *, int);
static void _recv_fd(auth_session_t *, int);
static char *_auth_next_arg(auth_session_t *);
/*
 * Set up a known environment for all authentication scripts.
 */
static char *auth_environ[] = {
	"PATH=" _PATH_DEFPATH,
	"SHELL=" _PATH_BSHELL,
	NULL,
};

static char defservice[] = LOGIN_DEFSERVICE;

static va_list nilap;

/*
 * Quick one liners that only exist to keep auth_session_t opaque
 */
void	auth_setstate(auth_session_t *as, int s){ as->state = s; }
void	auth_set_va_list(auth_session_t *as, va_list ap) { va_copy(as->ap, ap); }
int	auth_getstate(auth_session_t *as)	{ return (as->state); }
struct passwd *auth_getpwd(auth_session_t *as)	{ return (as->pwd); }
DEF_WEAK(auth_setstate);
DEF_WEAK(auth_set_va_list);
DEF_WEAK(auth_getstate);
DEF_WEAK(auth_getpwd);

/*
 * Open a new BSD Authentication session with the default service
 * (which can be changed later).
 */
auth_session_t *
auth_open(void)
{
	auth_session_t *as;

	if ((as = calloc(1, sizeof(auth_session_t))) != NULL) {
		as->service = defservice;
		as->fd = -1;
	}

	return (as);
}
DEF_WEAK(auth_open);

/*
 * Clean the specified BSD Authentication session.
 */
void
auth_clean(auth_session_t *as)
{
	struct rmfiles *rm;
	struct authdata *data;

	as->state = 0;

	auth_clrenv(as);

	/*
	 * Clean out the rmlist and remove specified files
	 */
	while ((rm = as->rmlist) != NULL) {
		as->rmlist = rm->next;
		unlink(rm->file);
		free(rm);
	}

	/*
	 * Clean out data
	 */
	while ((data = as->data) != NULL) {
		if (as->data->len)
			explicit_bzero(as->data->ptr, as->data->len);
		as->data = data->next;
		free(data);
	}

	auth_setitem(as, AUTHV_ALL, NULL);

	if (as->pwd != NULL) {
		explicit_bzero(as->pwd->pw_passwd, strlen(as->pwd->pw_passwd));
		free(as->pwd);
		as->pwd = NULL;
	}

	if (as->fd != -1) {
		close(as->fd);
		as->fd = -1;
	}
}
DEF_WEAK(auth_clean);

/*
 * Close the specified BSD Authentication session.
 * Return 0 if not authenticated.
 */
int
auth_close(auth_session_t *as)
{
	struct rmfiles *rm;
	struct authopts *opt;
	struct authdata *data;
	int s;

	/*
	 * Save our return value
	 */
	s = as->state & AUTH_ALLOW;

	if (s == 0)
		as->index = 0;

	auth_setenv(as);


	/*
	 * Clean out the rmlist and remove specified files if the
	 * authentication failed
	 */
	while ((rm = as->rmlist) != NULL) {
		as->rmlist = rm->next;
		if (s == 0)
			unlink(rm->file);
		free(rm);
	}

	/*
	 * Clean out the opt list
	 */
	while ((opt = as->optlist) != NULL) {
		as->optlist = opt->next;
		free(opt);
	}

	/*
	 * Clean out data
	 */
	while ((data = as->data) != NULL) {
		if (as->data->len)
			explicit_bzero(as->data->ptr, as->data->len);
		as->data = data->next;
		free(data);
	}

	if (as->pwd != NULL) {
		explicit_bzero(as->pwd->pw_passwd, strlen(as->pwd->pw_passwd));
		free(as->pwd);
		as->pwd = NULL;
	}

	/*
	 * Clean up random variables
	 */
	if (as->service && as->service != defservice)
		free(as->service);
	free(as->challenge);
	free(as->class);
	free(as->style);
	free(as->name);

	free(as);
	return (s);
}
DEF_WEAK(auth_close);

/*
 * Request a challenge for the session.
 * The name and style must have already been specified
 */
char *
auth_challenge(auth_session_t *as)
{
	char path[PATH_MAX];
	int len;

	if (as == NULL || as->style == NULL || as->name == NULL)
		return (NULL);

	len = snprintf(path, sizeof(path), _PATH_AUTHPROG "%s", as->style);
	if (len < 0 || len >= sizeof(path))
		return (NULL);

	as->state = 0;

	free(as->challenge);
	as->challenge = NULL;

	auth_call(as, path, as->style, "-s", "challenge", as->name,
	    as->class, (char *)NULL);
	if (as->state & AUTH_CHALLENGE)
		as->challenge = auth_getvalue(as, "challenge");
	as->state = 0;
	as->index = 0;	/* toss our data */
	return (as->challenge);
}
DEF_WEAK(auth_challenge);

/*
 * Set/unset the requested environment variables.
 * Mark the variables as set so they will not be set a second time.
 * XXX - should provide a way to detect setenv() failure.
 */
void
auth_setenv(auth_session_t *as)
{
	char *line, *name;

	/*
	 * Set any environment variables we were asked for
	 */
    	for (line = as->spool; line < as->spool + as->index;) {
		if (!strncasecmp(line, BI_SETENV, sizeof(BI_SETENV)-1)) {
			if (isblank((unsigned char)line[sizeof(BI_SETENV) - 1])) {
				/* only do it once! */
				line[0] = 'd'; line[1] = 'i'; line[2] = 'd';
				line += sizeof(BI_SETENV) - 1;
				for (name = line;
				    isblank((unsigned char)*name); ++name)
					;
				for (line = name;
				    *line && !isblank((unsigned char)*line);
				    ++line)
					;
				if (*line)
					*line++ = '\0';
				for (; isblank((unsigned char)*line); ++line)
					;
				if (*line != '\0' && setenv(name, line, 1))
					warn("setenv(%s, %s)", name, line);
			}
		} else
		if (!strncasecmp(line, BI_UNSETENV, sizeof(BI_UNSETENV)-1)) {
			if (isblank((unsigned char)line[sizeof(BI_UNSETENV) - 1])) {
				/* only do it once! */
				line[2] = 'd'; line[3] = 'i'; line[4] = 'd';
				line += sizeof(BI_UNSETENV) - 1;
				for (name = line;
				    isblank((unsigned char)*name); ++name)
					;
				for (line = name;
				    *line && !isblank((unsigned char)*line);
				    ++line)
					;
				if (*line)
					*line++ = '\0';
				unsetenv(name);
			}
		}
		while (*line++)
			;
	}
}
DEF_WEAK(auth_setenv);

/*
 * Clear out any requested environment variables.
 */
void
auth_clrenv(auth_session_t *as)
{
	char *line;

	for (line = as->spool; line < as->spool + as->index;) {
		if (!strncasecmp(line, BI_SETENV, sizeof(BI_SETENV)-1)) {
			if (isblank((unsigned char)line[sizeof(BI_SETENV) - 1])) {
				line[0] = 'i'; line[1] = 'g'; line[2] = 'n';
			}
		} else
		if (!strncasecmp(line, BI_UNSETENV, sizeof(BI_UNSETENV)-1)) {
			if (isblank((unsigned char)line[sizeof(BI_UNSETENV) - 1])) {
				line[2] = 'i'; line[3] = 'g'; line[4] = 'n';
			}
		}
		while (*line++)
			;
	}
}
DEF_WEAK(auth_clrenv);

char *
auth_getitem(auth_session_t *as, auth_item_t item)
{
	if (as != NULL) {
		switch (item) {
		case AUTHV_CHALLENGE:
			return (as->challenge);
		case AUTHV_CLASS:
			return (as->class);
		case AUTHV_NAME:
			return (as->name);
		case AUTHV_SERVICE:
			return (as->service ? as->service : defservice);
		case AUTHV_STYLE:
			return (as->style);
		case AUTHV_INTERACTIVE:
			return ((as->flags & AF_INTERACTIVE) ? "True" : NULL);
		default:
			break;
		}
	}
	return (NULL);
}
DEF_WEAK(auth_getitem);

int
auth_setitem(auth_session_t *as, auth_item_t item, char *value)
{
	if (as == NULL) {
		errno = EINVAL;
		return (-1);
	}

	switch (item) {
	case AUTHV_ALL:
		if (value != NULL) {
			errno = EINVAL;
			return (-1);
		}
		auth_setitem(as, AUTHV_CHALLENGE, NULL);
		auth_setitem(as, AUTHV_CLASS, NULL);
		auth_setitem(as, AUTHV_NAME, NULL);
		auth_setitem(as, AUTHV_SERVICE, NULL);
		auth_setitem(as, AUTHV_STYLE, NULL);
		auth_setitem(as, AUTHV_INTERACTIVE, NULL);
		return (0);

	case AUTHV_CHALLENGE:
		if (value == as->challenge)
			return (0);
		if (value != NULL && (value = strdup(value)) == NULL)
			return (-1);
		free(as->challenge);
		as->challenge = value;
		return (0);

	case AUTHV_CLASS:
		if (value == as->class)
			return (0);
		if (value != NULL && (value = strdup(value)) == NULL)
			return (-1);
		free(as->class);
		as->class = value;
		return (0);

	case AUTHV_NAME:
		if (value == as->name)
			return (0);
		if (value != NULL && (value = strdup(value)) == NULL)
			return (-1);
		free(as->name);
		as->name = value;
		return (0);

	case AUTHV_SERVICE:
		if (value == as->service)
			return (0);
		if (value == NULL || strcmp(value, defservice) == 0)
			value = defservice;
		else if ((value = strdup(value)) == NULL)
			return (-1);
		if (as->service && as->service != defservice)
			free(as->service);
		as->service = value;
		return (0);

	case AUTHV_STYLE:
		if (value == as->style)
			return (0);
		if (value == NULL || strchr(value, '/') != NULL ||
		    (value = strdup(value)) == NULL)
			return (-1);
		free(as->style);
		as->style = value;
		return (0);

	case AUTHV_INTERACTIVE:
		if (value == NULL)
			as->flags &= ~AF_INTERACTIVE;
		else
			as->flags |= ~AF_INTERACTIVE;
		return (0);

	default:
		errno = EINVAL;
		return (-1);
	}
}
DEF_WEAK(auth_setitem);

int
auth_setoption(auth_session_t *as, char *n, char *v)
{
	struct authopts *opt;
	size_t len = strlen(n) + strlen(v) + 2;
	int ret;

	if ((opt = malloc(sizeof(*opt) + len)) == NULL)
		return (-1);

	opt->opt = (char *)(opt + 1);

	ret = snprintf(opt->opt, len, "%s=%s", n, v);
	if (ret < 0 || ret >= len) {
		free(opt);
		errno = ENAMETOOLONG;
		return (-1);
	}
	opt->next = as->optlist;
	as->optlist = opt;
	return(0);
}
DEF_WEAK(auth_setoption);

void
auth_clroptions(auth_session_t *as)
{
	struct authopts *opt;

	while ((opt = as->optlist) != NULL) {
		as->optlist = opt->next;
		free(opt);
	}
}
DEF_WEAK(auth_clroptions);

void
auth_clroption(auth_session_t *as, char *option)
{
	struct authopts *opt, *oopt;
	size_t len;

	len = strlen(option);

	if ((opt = as->optlist) == NULL)
		return;

	if (strncmp(opt->opt, option, len) == 0 &&
	    (opt->opt[len] == '=' || opt->opt[len] == '\0')) {
		as->optlist = opt->next;
		free(opt);
		return;
	}

	while ((oopt = opt->next) != NULL) {
		if (strncmp(oopt->opt, option, len) == 0 &&
		    (oopt->opt[len] == '=' || oopt->opt[len] == '\0')) {
			opt->next = oopt->next;
			free(oopt);
			return;
		}
		opt = oopt;
	}
}
DEF_WEAK(auth_clroption);

int
auth_setdata(auth_session_t *as, void *ptr, size_t len)
{
	struct authdata *data, *dp;

	if (len <= 0)
		return (0);

	if ((data = malloc(sizeof(*data) + len)) == NULL)
		return (-1);

	data->next = NULL;
	data->len = len;
	data->ptr = data + 1;
	memcpy(data->ptr, ptr, len);

	if (as->data == NULL)
		as->data = data;
	else {
		for (dp = as->data; dp->next != NULL; dp = dp->next)
			;
		dp->next = data;
	}
	return (0);
}
DEF_WEAK(auth_setdata);

int
auth_setpwd(auth_session_t *as, struct passwd *pwd)
{
	struct passwd pwstore;
	char *instance, pwbuf[_PW_BUF_LEN];

	if (pwd == NULL && as->pwd == NULL && as->name == NULL)
		return (-1);		/* true failure */

	if (pwd == NULL) {
		/*
		 * If we were not passed in a pwd structure we need to
		 * go find one for ourself.  Always look up the username
		 * (if it is defined) in the passwd database to see if there
		 * is an entry for the user.  If not, either use the current
		 * entry or simply return a 1 which implies there is
		 * no user by that name here.  This is not a failure, just
		 * a point of information.
		 */
		if (as->name == NULL)
			return (0);
		getpwnam_r(as->name, &pwstore, pwbuf, sizeof(pwbuf), &pwd);
		if (pwd == NULL) {
			instance = strchr(as->name, '/');
			if (instance == NULL)
				return (as->pwd ? 0 : 1);
			if (strcmp(instance, "/root") == 0) {
				getpwnam_r(instance + 1, &pwstore, pwbuf,
				    sizeof(pwbuf), &pwd);
			}
			if (pwd == NULL)
				return (as->pwd ? 0 : 1);
		}
	}
	if ((pwd = pw_dup(pwd)) == NULL)
		return (-1);		/* true failure */
	if (as->pwd) {
		explicit_bzero(as->pwd->pw_passwd, strlen(as->pwd->pw_passwd));
		free(as->pwd);
	}
	as->pwd = pwd;
	return (0);
}
DEF_WEAK(auth_setpwd);

char *
auth_getvalue(auth_session_t *as, char *what)
{
	char *line, *v, *value;
	int n, len;

	len = strlen(what);

    	for (line = as->spool; line < as->spool + as->index;) {
		if (strncasecmp(line, BI_VALUE, sizeof(BI_VALUE)-1) != 0)
			goto next;
		line += sizeof(BI_VALUE) - 1;

		if (!isblank((unsigned char)*line))
			goto next;

		while (isblank((unsigned char)*++line))
			;

		if (strncmp(line, what, len) != 0 ||
		    !isblank((unsigned char)line[len]))
			goto next;
		line += len;
		while (isblank((unsigned char)*++line))
			;
		value = strdup(line);
		if (value == NULL)
			return (NULL);

		/*
		 * XXX - There should be a more standardized
		 * routine for doing this sort of thing.
		 */
		for (line = v = value; *line; ++line) {
			if (*line == '\\') {
				switch (*++line) {
				case 'r':
					*v++ = '\r';
					break;
				case 'n':
					*v++ = '\n';
					break;
				case 't':
					*v++ = '\t';
					break;
				case '0': case '1': case '2':
				case '3': case '4': case '5':
				case '6': case '7':
					n = *line - '0';
					if (isdigit((unsigned char)line[1])) {
						++line;
						n <<= 3;
						n |= *line-'0';
					}
					if (isdigit((unsigned char)line[1])) {
						++line;
						n <<= 3;
						n |= *line-'0';
					}
					break;
				default:
					*v++ = *line;
					break;
				}
			} else
				*v++ = *line;
		}
		*v = '\0';
		return (value);
next:
		while (*line++)
			;
	}
	return (NULL);
}
DEF_WEAK(auth_getvalue);

quad_t
auth_check_expire(auth_session_t *as)
{
	if (as->pwd == NULL && auth_setpwd(as, NULL) < 0) {
		as->state &= ~AUTH_ALLOW;
		as->state |= AUTH_EXPIRED;	/* XXX */
		return (-1);
	}

	if (as->pwd == NULL)
		return (0);

	if (as->pwd && (quad_t)as->pwd->pw_expire != 0) {
		if (as->now.tv_sec == 0)
			gettimeofday(&as->now, NULL);
		if ((quad_t)as->now.tv_sec >= (quad_t)as->pwd->pw_expire) {
			as->state &= ~AUTH_ALLOW;
			as->state |= AUTH_EXPIRED;
		}
		if ((quad_t)as->now.tv_sec == (quad_t)as->pwd->pw_expire)
			return (-1);
		return ((quad_t)as->pwd->pw_expire - (quad_t)as->now.tv_sec);
	}
	return (0);
}
DEF_WEAK(auth_check_expire);

quad_t
auth_check_change(auth_session_t *as)
{
	if (as->pwd == NULL && auth_setpwd(as, NULL) < 0) {
		as->state &= ~AUTH_ALLOW;
		as->state |= AUTH_PWEXPIRED;	/* XXX */
		return (-1);
	}

	if (as->pwd == NULL)
		return (0);

	if (as->pwd && (quad_t)as->pwd->pw_change) {
		if (as->now.tv_sec == 0)
			gettimeofday(&as->now, NULL);
		if (as->now.tv_sec >= (quad_t)as->pwd->pw_change) {
			as->state &= ~AUTH_ALLOW;
			as->state |= AUTH_PWEXPIRED;
		}
		if ((quad_t)as->now.tv_sec == (quad_t)as->pwd->pw_change)
			return (-1);
		return ((quad_t)as->pwd->pw_change - (quad_t)as->now.tv_sec);
	}
	return (0);
}
DEF_WEAK(auth_check_change);

/*
 * The down and dirty call to the login script
 * okay contains the default return value, typically 0 but
 * is AUTH_OKAY for approval like scripts.
 *
 * Internally additional trailing arguments can be read from as->ap
 * Options will be placed just after the first argument (not including path).
 *
 * Any data will be sent to (and freed by) the script
 */
int
auth_call(auth_session_t *as, char *path, ...)
{
	char *line;
	struct authdata *data;
	struct authopts *opt;
	pid_t pid;
	int status;
	int okay;
	int pfd[2];
	int argc;
	char *argv[64];		/* 64 args should be more than enough */
#define	Nargc	(sizeof(argv)/sizeof(argv[0]))

	va_start(as->ap0, path);

	argc = 0;
	if ((argv[argc] = _auth_next_arg(as)) != NULL)
		++argc;

	if (as->fd != -1) {
		argv[argc++] = "-v";
		argv[argc++] = "fd=4";		/* AUTH_FD, see below */
	}
	for (opt = as->optlist; opt != NULL; opt = opt->next) {
		if (argc < Nargc - 2) {
			argv[argc++] = "-v";
			argv[argc++] = opt->opt;
		} else {
			syslog(LOG_ERR, "too many authentication options");
			goto fail;
		}
	}
	while (argc < Nargc - 1 && (argv[argc] = _auth_next_arg(as)))
		++argc;

	if (argc >= Nargc - 1 && _auth_next_arg(as)) {
		if (memcmp(&nilap, &(as->ap0), sizeof(nilap)) != 0) {
			va_end(as->ap0);
			explicit_bzero(&(as->ap0), sizeof(as->ap0));
		}
		if (memcmp(&nilap, &(as->ap), sizeof(nilap)) != 0) {
			va_end(as->ap);
			explicit_bzero(&(as->ap), sizeof(as->ap));
		}
		syslog(LOG_ERR, "too many arguments");
		goto fail;
	}

	argv[argc] = NULL;

	if (secure_path(path) < 0) {
		syslog(LOG_ERR, "%s: path not secure", path);
		warnx("invalid script: %s", path);
		goto fail;
	}

	if (socketpair(PF_LOCAL, SOCK_STREAM, 0, pfd) < 0) {
		syslog(LOG_ERR, "unable to create backchannel %m");
		warnx("internal resource failure");
		goto fail;
	}

	switch (pid = fork()) {
	case -1:
		syslog(LOG_ERR, "%s: %m", path);
		warnx("internal resource failure");
		close(pfd[0]);
		close(pfd[1]);
		goto fail;
	case 0:
#define	COMM_FD	3
#define	AUTH_FD	4
		if (dup2(pfd[1], COMM_FD) < 0)
			err(1, "dup of backchannel");
		if (as->fd != -1) {
			if (dup2(as->fd, AUTH_FD) < 0)
				err(1, "dup of auth fd");
			closefrom(AUTH_FD + 1);
		} else
			closefrom(COMM_FD + 1);
		execve(path, argv, auth_environ);
		syslog(LOG_ERR, "%s: %m", path);
		err(1, "%s", path);
	default:
		close(pfd[1]);
		if (as->fd != -1) {
			close(as->fd);		/* so child has only ref */
			as->fd = -1;
		}
		while ((data = as->data) != NULL) {
			as->data = data->next;
			if (data->len > 0) {
				write(pfd[0], data->ptr, data->len);
				explicit_bzero(data->ptr, data->len);
			}
			free(data);
		}
		as->index = 0;
		_auth_spool(as, pfd[0]);
		close(pfd[0]);
		do {
			if (waitpid(pid, &status, 0) != -1) {
				if (!WIFEXITED(status))
					goto fail;
				break;
			}
			/*
			 * could get ECHILD if it was waited for by
			 * another thread or from a signal handler
			 */
		} while (errno == EINTR);
	}

	/*
	 * Now scan the spooled data
	 * It is easier to wait for all the data before starting
	 * to scan it.
	 */
    	for (line = as->spool; line < as->spool + as->index;) {
		if (!strncasecmp(line, BI_REJECT, sizeof(BI_REJECT)-1)) {
			line += sizeof(BI_REJECT) - 1;
			if (!*line || *line == ' ' || *line == '\t') {
				while (*line == ' ' || *line == '\t')
					++line;
				if (!strcasecmp(line, "silent")) {
					as->state = AUTH_SILENT;
					break;
				}
				if (!strcasecmp(line, "challenge")) {
					as->state  = AUTH_CHALLENGE;
					break;
				}
				if (!strcasecmp(line, "expired")) {
					as->state  = AUTH_EXPIRED;
					break;
				}
				if (!strcasecmp(line, "pwexpired")) {
					as->state  = AUTH_PWEXPIRED;
					break;
				}
			}
			break;
		} else if (!strncasecmp(line, BI_AUTH, sizeof(BI_AUTH)-1)) {
			line += sizeof(BI_AUTH) - 1;
			if (!*line || *line == ' ' || *line == '\t') {
				while (*line == ' ' || *line == '\t')
					++line;
				if (*line == '\0')
					as->state |= AUTH_OKAY;
				else if (!strcasecmp(line, "root"))
					as->state |= AUTH_ROOTOKAY;
				else if (!strcasecmp(line, "secure"))
					as->state |= AUTH_SECURE;
			}
		} else if (!strncasecmp(line, BI_REMOVE, sizeof(BI_REMOVE)-1)) {
			line += sizeof(BI_REMOVE) - 1;
			while (*line == ' ' || *line == '\t')
				++line;
			if (*line)
				_add_rmlist(as, line);
		}
		while (*line++)
			;
	}

	if (WEXITSTATUS(status))
		as->state &= ~AUTH_ALLOW;

	okay = as->state & AUTH_ALLOW;

	if (!okay)
		auth_clrenv(as);

	if (0) {
fail:
		auth_clrenv(as);
		as->state = 0;
		okay = -1;
	}

	while ((data = as->data) != NULL) {
		as->data = data->next;
		free(data);
	}

	if (memcmp(&nilap, &(as->ap0), sizeof(nilap)) != 0) {
		va_end(as->ap0);
		explicit_bzero(&(as->ap0), sizeof(as->ap0));
	}

	if (memcmp(&nilap, &(as->ap), sizeof(nilap)) != 0) {
		va_end(as->ap);
		explicit_bzero(&(as->ap), sizeof(as->ap));
	}
	return (okay);
}
DEF_WEAK(auth_call);

static void
_recv_fd(auth_session_t *as, int fd)
{
	struct msghdr msg;
	struct cmsghdr *cmp;
	union {
		struct cmsghdr hdr;
		char buf[CMSG_SPACE(sizeof(int))];
	} cmsgbuf;

	memset(&msg, 0, sizeof(msg));
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);
	if (recvmsg(fd, &msg, 0) < 0)
		syslog(LOG_ERR, "recvmsg: %m");
	else if (msg.msg_flags & MSG_TRUNC)
		syslog(LOG_ERR, "message truncated");
	else if (msg.msg_flags & MSG_CTRUNC)
		syslog(LOG_ERR, "control message truncated");
	else if ((cmp = CMSG_FIRSTHDR(&msg)) == NULL)
		syslog(LOG_ERR, "missing control message");
	else {
		if (cmp->cmsg_level != SOL_SOCKET)
			syslog(LOG_ERR, "unexpected cmsg_level %d",
			    cmp->cmsg_level);
		else if (cmp->cmsg_type != SCM_RIGHTS)
			syslog(LOG_ERR, "unexpected cmsg_type %d",
			    cmp->cmsg_type);
		else if (cmp->cmsg_len != CMSG_LEN(sizeof(int)))
			syslog(LOG_ERR, "bad cmsg_len %d",
			    cmp->cmsg_len);
		else {
			if (as->fd != -1)
				close(as->fd);
			as->fd = *(int *)CMSG_DATA(cmp);
		}
	}
}

static void
_auth_spool(auth_session_t *as, int fd)
{
	ssize_t r;
	char *b, *s;

	for (s = as->spool + as->index; as->index < sizeof(as->spool) - 1; ) {
		r = read(fd, as->spool + as->index,
		    sizeof(as->spool) - as->index);
		if (r <= 0) {
			as->spool[as->index] = '\0';
			return;
		}
		b = as->spool + as->index;
		as->index += r;
		/*
		 * Convert newlines into NULs to allow easy scanning of the
		 * file and receive an fd if there is a BI_FDPASS message.
		 * XXX - checking for BI_FDPASS here is annoying but
		 *       we need to avoid the read() slurping in control data.
		 */
		while (r-- > 0) {
			if (*b++ == '\n') {
				b[-1] = '\0';
				if (strcasecmp(s, BI_FDPASS) == 0)
					_recv_fd(as, fd);
				s = b;
			}
		}
	}

	syslog(LOG_ERR, "Overflowed backchannel spool buffer");
	errx(1, "System error in authentication program");
}

static void
_add_rmlist(auth_session_t *as, char *file)
{
	struct rmfiles *rm;
	size_t i = strlen(file) + 1;

	// XXX should rangecheck i since we are about to add?

	if ((rm = malloc(sizeof(struct rmfiles) + i)) == NULL) {
		syslog(LOG_ERR, "Failed to allocate rmfiles: %m");
		return;
	}
	rm->file = (char *)(rm + 1);
	rm->next = as->rmlist;
	strlcpy(rm->file, file, i);
	as->rmlist = rm;
}

static char *
_auth_next_arg(auth_session_t *as)
{
	char *arg;

	if (memcmp(&nilap, &(as->ap0), sizeof(nilap)) != 0) {
		if ((arg = va_arg(as->ap0, char *)) != NULL)
			return (arg);
		va_end(as->ap0);
		explicit_bzero(&(as->ap0), sizeof(as->ap0));
	}
	if (memcmp(&nilap, &(as->ap), sizeof(nilap)) != 0) {
		if ((arg = va_arg(as->ap, char *)) != NULL)
			return (arg);
		va_end(as->ap);
		explicit_bzero(&(as->ap), sizeof(as->ap));
	}
	return (NULL);
}
@


1.49
log
@Use reentrant versions of getpw{nam,uid} and getgr{nam,gid} within
libc to avoid reusing the static buffers returned by the non-reentrant
versions.  Since this is inside libc we can use constants for the
buffer sizes instead of having to call sysconf().
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.48 2015/11/02 17:03:29 mmcc Exp $	*/
d316 2
a317 4
	if (as->challenge) {
		free(as->challenge);
		as->challenge = NULL;
	}
@


1.48
log
@(struct timezone *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.47 2015/10/23 04:52:21 guenther Exp $	*/
d619 2
a620 1
	char *instance;
d637 2
a638 1
		if ((pwd = getpwnam(as->name)) == NULL) {
d642 4
a645 2
			if (strcmp(instance, "/root") == 0)
				pwd = getpwnam(instance + 1);
@


1.47
log
@Fix waitpid() loop again: do the errno check only if waitpid() returns -1
and check WIFEXITED() only if it returns != -1.  Delete the logging of
errors other than ECHILD: EFAULT and EINVAL are impossible here.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.46 2015/10/22 23:55:51 mmcc Exp $	*/
d748 1
a748 1
			gettimeofday(&as->now, (struct timezone *)NULL);
d775 1
a775 1
			gettimeofday(&as->now, (struct timezone *)NULL);
@


1.46
log
@Cast ctype function arguments to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.45 2015/09/14 16:09:13 tedu Exp $	*/
d899 5
a903 8
		status = 0;
		while (waitpid(pid, &status, 0) == -1 && errno == EINTR)
			;
		if (pid < 0) {
			if (errno != ECHILD) {
				syslog(LOG_ERR, "%s: waitpid: %m", path);
				warnx("internal failure");
				goto fail;
d905 5
a909 2
		} else if (!WIFEXITED(status))
			goto fail;
@


1.45
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.44 2015/09/12 15:20:14 guenther Exp $	*/
d366 1
a366 1
			if (isblank(line[sizeof(BI_UNSETENV) - 1])) {
@


1.44
log
@Wrap <bsd_auth.h> so that calls go direct and the symbols are all weak
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.43 2015/09/03 04:27:49 daniel Exp $	*/
d287 4
a290 8
	if (as->challenge)
		free(as->challenge);
	if (as->class)
		free(as->class);
	if (as->style)
		free(as->style);
	if (as->name)
		free(as->name);
d465 1
a465 2
		if (as->challenge)
			free(as->challenge);
d474 1
a474 2
		if (as->class)
			free(as->class);
d483 1
a483 2
		if (as->name)
			free(as->name);
d505 1
a505 2
		if (as->style)
			free(as->style);
@


1.43
log
@no more gcc2.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.42 2015/08/31 02:53:57 guenther Exp $	*/
d154 4
d175 1
d222 1
d299 1
d333 1
d390 1
d415 1
d440 1
d529 1
d553 1
d565 1
d595 1
d622 1
d663 1
d740 1
d767 1
d794 1
d1003 1
@


1.42
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.41 2014/08/25 07:50:25 doug Exp $	*/
d151 1
a151 7
void	auth_set_va_list(auth_session_t *as, va_list ap) {
#if defined(__GNUC__) && __GNUC__ >= 3
	va_copy(as->ap, ap);
#else
	as->ap = ap;
#endif
}
@


1.41
log
@Delete secret or secret-derived data with explicit_bzero.

concept ok deraadt@@
diff looks ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.40 2014/05/25 17:47:04 tedu Exp $	*/
d364 1
a364 1
					_warn("setenv(%s, %s)", name, line);
d845 1
a845 1
		_warnx("invalid script: %s", path);
d851 1
a851 1
		_warnx("internal resource failure");
d858 1
a858 1
		_warnx("internal resource failure");
d899 1
a899 1
				_warnx("internal failure");
@


1.40
log
@use calloc, from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.39 2013/11/24 23:51:29 deraadt Exp $	*/
d205 1
a205 1
			memset(as->data->ptr, 0, as->data->len);
d213 1
a213 1
		memset(as->pwd->pw_passwd, 0, strlen(as->pwd->pw_passwd));
d271 1
a271 1
			memset(as->data->ptr, 0, as->data->len);
d277 1
a277 1
		memset(as->pwd->pw_passwd, 0, strlen(as->pwd->pw_passwd));
d647 1
a647 1
		memset(as->pwd->pw_passwd, 0, strlen(as->pwd->pw_passwd));
d831 1
a831 1
			memset(&(as->ap0), 0, sizeof(as->ap0));
d835 1
a835 1
			memset(&(as->ap), 0, sizeof(as->ap));
d886 1
a886 1
				memset(data->ptr, 0, data->len);
d980 1
a980 1
		memset(&(as->ap0), 0, sizeof(as->ap0));
d985 1
a985 1
		memset(&(as->ap), 0, sizeof(as->ap));
d1091 1
a1091 1
		memset(&(as->ap0), 0, sizeof(as->ap0));
d1097 1
a1097 1
		memset(&(as->ap), 0, sizeof(as->ap));
@


1.39
log
@most obvious unsigned char casts for ctype
ok jca krw ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.38 2013/09/30 12:02:32 millert Exp $	*/
d170 1
a170 2
	if ((as = malloc(sizeof(auth_session_t))) != NULL) {
		memset(as, 0, sizeof(*as));
@


1.38
log
@Use PATH_MAX, NAME_MAX and LOGIN_NAME_MAX not MAXPATHNAMELEN,
MAXNAMLEN or MAXLOGNAME where possible.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.37 2013/01/08 02:26:09 deraadt Exp $	*/
d349 1
a349 1
			if (isblank(line[sizeof(BI_SETENV) - 1])) {
d353 2
a354 1
				for (name = line; isblank(*name); ++name)
d356 2
a357 1
				for (line = name; *line && !isblank(*line);
d362 1
a362 1
				for (; isblank(*line); ++line)
d373 2
a374 1
				for (name = line; isblank(*name); ++name)
d376 2
a377 1
				for (line = name; *line && !isblank(*line);
d398 1
a398 1
    	for (line = as->spool; line < as->spool + as->index;) {
d400 1
a400 1
			if (isblank(line[sizeof(BI_SETENV) - 1])) {
d405 1
a405 1
			if (isblank(line[sizeof(BI_UNSETENV) - 1])) {
d668 1
a668 1
		if (!isblank(*line))
d671 1
a671 1
		while (isblank(*++line))
d675 1
a675 1
		    !isblank(line[len]))
d678 1
a678 1
		while (isblank(*++line))
d704 1
a704 1
					if (isdigit(line[1])) {
d709 1
a709 1
					if (isdigit(line[1])) {
@


1.37
log
@More int's that should be size_t for strlen() use
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.36 2009/01/15 13:14:30 millert Exp $	*/
d52 1
a52 1
#include <sys/param.h>
d62 1
d308 1
a308 1
	char path[MAXPATHLEN];
@


1.36
log
@Remove support for kerb4 '.' instance separator, kerb4 is dead.  OK jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.35 2008/03/24 16:10:59 deraadt Exp $	*/
d559 1
a559 1
	int len;
d1064 3
a1066 1
	int i = strlen(file) + 1;
@


1.35
log
@msg_controllen has to be CMSG_SPACE so that the kernel can account for
each cmsg_len (ie. msg_controllen = sum of CMSG_ALIGN(cmsg_len).  This
works now that kernel fd passing has been fixed to accept a bit of
sloppiness because of this ABI repair.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.34 2008/03/15 16:19:02 deraadt Exp $	*/
d631 2
a632 2
			instance = strpbrk(as->name, "./");
			if (instance++ == NULL)
d634 2
a635 2
			if (strcmp(instance, "root") == 0)
				pwd = getpwnam(instance);
@


1.34
log
@Repair the simple cases for msg_controllen where it should just be
CMSG_SIZE(sizeof(int)), not sizeof(buffer) which may be larger because
of alignment; ok kettenis hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.33 2008/03/13 01:49:52 deraadt Exp $	*/
d998 1
a998 1
	msg.msg_controllen = CMSG_LEN(sizeof(int));
@


1.33
log
@Correct CMSG_SPACE and CMSG_LEN usage everywhere in the tree. Due to
an extensive discussion with otto, kettenis, millert, and hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.32 2007/11/01 00:55:20 millert Exp $	*/
d998 1
a998 1
	msg.msg_controllen = sizeof(cmsgbuf.buf);
@


1.32
log
@Fix waitpid() idiom.  Noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.31 2007/09/17 07:07:23 moritz Exp $	*/
d991 4
a994 1
	char cmsgbuf[CMSG_SPACE(sizeof(int))];
d997 2
a998 2
	msg.msg_control = cmsgbuf;
	msg.msg_controllen = sizeof(cmsgbuf);
@


1.31
log
@Check snprintf(3) return value for error or truncation.
Mostly path construction, where truncation could be bad.

ok and input from deraadt@@ millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.30 2004/12/02 20:38:36 millert Exp $	*/
d890 2
a891 3
		do {
			pid = waitpid(pid, &status, 0);
		} while (pid < 0 && errno == EINTR);
@


1.30
log
@Restart waitpid() if we are interupted by a signal.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.29 2004/08/30 18:14:33 millert Exp $	*/
d308 1
d313 4
a323 1
	snprintf(path, sizeof(path), _PATH_AUTHPROG "%s", as->style);
d525 2
a526 1
	int i = strlen(n) + strlen(v) + 2;
d528 1
a528 1
	if ((opt = malloc(sizeof(*opt) + i)) == NULL)
d533 6
a538 1
	snprintf(opt->opt, i, "%s=%s", n, v);
@


1.29
log
@Use CMSG_SPACE when allocating space for the control message.
Fixes fd passing problems on sparc and sparc64.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.28 2004/08/09 01:39:31 millert Exp $	*/
d880 4
a883 1
		if (waitpid(pid, &status, 0) < 0) {
@


1.28
log
@Add my copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.27 2004/08/03 19:43:31 millert Exp $	*/
d979 1
a979 1
	char cmsgbuf[CMSG_LEN(sizeof(int))];
d999 1
a999 1
		else if (cmp->cmsg_len != sizeof(cmsgbuf))
@


1.27
log
@Add support for passing a file descriptor back and forth between
the parent program and the login script.  This will be used by login
scripts that need to maintain state, for instance keeping a record
locked during authentication while using separate challenge and
response authentication with S/Key.  OK deraadt@@ marius@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.26 2004/01/23 03:48:42 deraadt Exp $	*/
d3 15
@


1.26
log
@Use closefrom(); ok millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.25 2004/01/10 16:45:56 millert Exp $	*/
d95 2
d116 1
d157 1
a169 1
	struct authopts *opt;
d202 5
d783 4
d835 9
a843 8
		close(pfd[0]);
		if (pfd[1] != COMM_FD) {
			if (dup2(pfd[1], COMM_FD) < 0)
				err(1, "dup of backchannel");
			close(pfd[1]);
		}

		closefrom(COMM_FD + 1);
d849 4
d960 36
d998 2
a999 2
	int r;
	char *b;
d1001 1
a1001 1
	while (as->index < sizeof(as->spool) - 1) {
d1011 4
a1014 2
		 * Go ahead and convert newlines into NULs to allow
		 * easy scanning of the file.
d1016 2
a1017 2
		while (r-- > 0)
			if (*b++ == '\n')
d1019 5
@


1.25
log
@Don't clean options in auth_clean() which was introduced in rev 1.8.
login(1) depends on auth_clean() leaving options alone so this was
API breakage.  Verified to not make ftpd leak memory by mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.24 2004/01/08 04:07:54 brad Exp $	*/
d830 1
a830 3
		for (status = getdtablesize() - 1; status > COMM_FD; status--)
			close(status);

@


1.24
log
@use va_copy() with gcc 3 and up.

ok millert@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.23 2003/06/11 21:03:10 deraadt Exp $	*/
a179 8
	}

	/*
	 * Clean out the opt list
	 */
	while ((opt = as->optlist) != NULL) {
		as->optlist = opt->next;
		free(opt);
@


1.23
log
@ansification; checked by pval
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.22 2003/01/04 22:36:09 deraadt Exp $	*/
d132 7
a138 1
void	auth_set_va_list(auth_session_t *as, va_list ap) { as->ap = ap; }
@


1.22
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.21 2002/11/22 23:27:45 millert Exp $	*/
d141 1
a141 1
auth_open()
@


1.21
log
@Initialize status to zero before calling waitpid().  That way, if
there is nothing to be waited for (for instance if SIGCHLD is being
ignored) we don't check WIFEXITED(garbage off the stack).
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.20 2002/11/22 19:47:03 deraadt Exp $	*/
d280 1
a280 1
 * Request a challange for the session.
@


1.20
log
@more snprintf; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.19 2002/10/30 14:54:34 drahn Exp $	*/
d851 1
@


1.19
log
@Revert this va_copy addition, it cannot work on macppc (which is the
only arch where va_copy is currently required), current version of
va_copy uses alloca, but since the results of the va_copy are not used
here, only after return, stack trashing will occur.
This will have to be revised again for gcc 3.2 support on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.18 2002/10/24 17:13:36 drahn Exp $	*/
d507 1
a507 1
	sprintf(opt->opt, "%s=%s", n, v);
@


1.18
log
@Use va_copy() for varargs assignemnt. va_copy() is standard with C99
and gcc3.2 requires this on powerpc.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.17 2002/10/16 19:45:41 millert Exp $	*/
d132 1
a132 3
void	auth_set_va_list(auth_session_t *as, va_list ap) {
	va_copy(as->ap, ap);
}
@


1.17
log
@Replace "if (value != NULL && value == as->FOO)" with just
"if (value == as->FOO)" -- NULL needs no special handling.
Pointed out by Paul Borman.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.16 2002/10/15 20:17:11 millert Exp $	*/
d132 3
a134 1
void	auth_set_va_list(auth_session_t *as, va_list ap) { as->ap = ap; }
@


1.16
log
@Fix typo introduce in last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.15 2002/10/15 17:47:27 millert Exp $	*/
d431 1
a431 1
		if (value != NULL && value == as->challenge)
d441 1
a441 1
		if (value != NULL && value == as->class)
d451 1
a451 1
		if (value != NULL && value == as->name)
d461 1
a461 1
		if (value != NULL && value == as->service)
d473 1
a473 1
		if (value != NULL && value == as->style)
@


1.15
log
@If auth_setitem() is called with the current value (ie: the pointer
is the same as the private value) then just return 0 as there is
nothing to do.

This fixes a potentially nasty problem where the caller could grab
the username or style from the auth session via auth_getitem() and
then call auth_verify() with those values.  auth_setitem() would
eventually get called which would make a private copy and free the
old values in the auth session.  After all this, the stashed username
and/or style pointers would point to freed memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.14 2002/10/15 17:10:57 millert Exp $	*/
d461 1
a461 1
		if (value != NULL && value == as->defservice)
@


1.14
log
@Cast NULL sentinel in auth_call() to a pointer
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.13 2002/10/13 21:12:59 millert Exp $	*/
d431 2
d441 2
a444 1

a446 1

d451 2
a454 1

a456 1

d461 2
a466 1

a468 1

d473 2
a477 1

a479 1

@


1.13
log
@Move the clearing of as->state in auth_challenge() to after the sanity
checks.  The check for "as != NULL" is useless if you have already
dereferenced "as".  Also fix some comment typos.  From Moritz Jodeit.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.12 2002/08/04 22:44:12 millert Exp $	*/
d300 1
a300 1
	    as->class, NULL);
@


1.12
log
@If fork() fails, log/report the error *before* we close our fd's just
in case close(2) were to set errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.11 2002/06/27 22:21:22 deraadt Exp $	*/
a287 2
	as->state = 0;

d291 2
d751 1
a751 2
 * Options will be placed be placed just after the first argument
 * (not including path).
d753 1
a753 1
 * Any data will sent (and freed) to the script
d766 1
a766 1
	char *argv[64];		/* 64 args should more than enough */
@


1.11
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.10 2002/05/24 21:22:37 deraadt Exp $	*/
d817 2
a820 2
		syslog(LOG_ERR, "%s: %m", path);
		_warnx("internal resource failure");
@


1.10
log
@try to use strlcpy and snprintf more; ok various
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.9 2002/03/13 21:39:41 millert Exp $	*/
d963 1
a963 1
		while(r-- > 0)
@


1.9
log
@Convert indentation whitespace -> tabs and kill $@@%^#! ^M's
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.8 2002/02/05 07:51:52 mpech Exp $	*/
d984 1
a984 1
	strcpy(rm->file, file);
@


1.8
log
@o) Fix memory leak in _auth_checklogin(), auth_approval(), auth_close() and
   auth_clean().

Spotted via ftpd. We could use ftpd as a simple debug tool for bsdauth and
login_cap routines. :)

millert@@ help&OK
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.7 2002/01/14 16:50:18 millert Exp $	*/
d84 1
a84 1
        struct	timeval now;		/* time of authentication */
d179 4
a182 4
        while ((opt = as->optlist) != NULL) {
                as->optlist = opt->next;
                free(opt);
        }
d211 2
a212 2
        struct authopts *opt;
        struct authdata *data;
d240 4
a243 4
        while ((opt = as->optlist) != NULL) {
                as->optlist = opt->next;
                free(opt);
        }
d299 1
a299 1
        auth_call(as, path, as->style, "-s", "challenge", as->name,
@


1.7
log
@If waitpid() return ECHILD that should not be a fatal error since
someone else could have waited for the process or zombies could be
disabled via SIG_IGN or SA_NOCLDWAIT.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.6 2001/07/02 19:22:34 millert Exp $	*/
d160 2
a161 1
        struct authdata *data;
d177 8
d253 6
@


1.6
log
@Convert warn/warnx -> _warn/_warnx
Should not really spew to stderr from libc but right now there
is no other way to get a sensible error message to the user.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.5 2001/06/24 21:18:14 millert Exp $	*/
d836 6
a841 6
			syslog(LOG_ERR, "%s: waitpid: %m", path);
			_warnx("internal failure");
			goto fail;
		}

		if (!WIFEXITED(status))
@


1.5
log
@When splitting instance from username, treat '/' as a separator as
well (for Kerb5).
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.4 2000/11/23 00:38:25 millert Exp $	*/
d322 1
a322 1
					warn("setenv(%s, %s)", name, line);
d790 1
a790 1
		warnx("invalid script: %s", path);
d796 1
a796 1
		warnx("internal resource failure");
d805 1
a805 1
		warnx("internal resource failure");
d837 1
a837 1
			warnx("internal failure");
@


1.4
log
@zero pw_passwd before freeing
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.3 2000/11/21 19:43:10 millert Exp $	*/
d84 1
a84 1
        struct timeval now;		/* time of authentication */
d583 2
a584 2
			instance = strchr(as->name, '.');
			if (instance == NULL)
d586 2
a587 2
			if (strcmp(instance, ".root") == 0)
				pwd = getpwnam(instance + 1);
@


1.3
log
@Remove needless memset() from last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.2 2000/11/21 04:17:44 millert Exp $	*/
d188 1
d594 2
a595 1
	if (as->pwd)
d597 1
@


1.2
log
@Deal with va_list not being a pointer; this should be re-evaluated.
Fixes a compile problem on alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: auth_subr.c,v 1.1 2000/11/21 00:51:16 millert Exp $	*/
a751 1
	memset(&(as->ap0), 0, sizeof(as->ap0));
@


1.1
log
@BSD authentication routines from BSDI.  Presently this is not used but
the login_* helper programs and other support will be committed in the
near future.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 2
d752 1
d772 1
a772 1
		if (as->ap0) {
d774 1
a774 1
			as->ap0 = NULL;
d776 1
a776 1
		if (as->ap) {
d778 1
a778 1
			as->ap = NULL;
d915 1
a915 1
	if (as->ap0) {
d917 1
a917 1
		as->ap0 = NULL;
d920 1
a920 1
	if (as->ap) {
d922 1
a922 1
		as->ap = NULL;
d976 1
a976 1
	if (as->ap0) {
d980 1
a980 1
		as->ap0 = NULL;
d982 1
a982 1
	if (as->ap) {
d986 1
a986 1
		as->ap = NULL;
@

