head	1.46;
access;
symbols
	OPENBSD_6_0:1.46.0.4
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.40.0.6
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.8
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.6
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.4
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.2
	OPENBSD_5_0:1.36.0.2
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.35.0.2
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.26.0.12
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.10
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.8
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.6
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.4
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.16.0.4
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2015.12.28.22.08.18;	author mmcc;	state Exp;
branches;
next	1.45;
commitid	0uXuF2O13NH9q2e1;

1.45
date	2015.11.24.22.03.33;	author millert;	state Exp;
branches;
next	1.44;
commitid	LVVvCb2EklWn8nFM;

1.44
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.43;
commitid	iWfSX2BIn0sLw62l;

1.43
date	2015.06.13.16.57.04;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	zOUKuqWBdOPOz1SZ;

1.42
date	2015.02.05.12.59.57;	author millert;	state Exp;
branches;
next	1.41;
commitid	DTQbfd4poqBW8iSJ;

1.41
date	2014.10.08.05.35.27;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	JwTGarRLHQKDgPh2;

1.40
date	2013.09.30.12.02.34;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2012.01.20.07.09.42;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2011.09.22.06.27.29;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2011.09.20.10.18.46;	author stsp;	state Exp;
branches;
next	1.36;

1.36
date	2011.05.12.07.15.10;	author pyr;	state Exp;
branches;
next	1.35;

1.35
date	2011.01.12.01.53.14;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2010.10.08.21.48.42;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.26.22.15.39;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.24.13.32.55;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.19.14.53.06;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2010.03.23.09.52.35;	author nicm;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.21.16.42.05;	author chl;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.18.15.50.27;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2008.10.01.23.04.13;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.28.17.50.12;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.07.16.34.04;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.25.21.16.47;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.14.21.34.58;	author todd;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.24.21.22.37;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.17.19.42.22;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.05.18.36.12;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.02.02.30.37;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.28.20.54.19;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.28.08.00.00;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.28.07.44.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.28.06.33.55;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.19.13.45.30;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.18.17.18.58;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.08.14.21.39.30;	author deraadt;	state Exp;
branches
	1.8.10.1;
next	1.7;

1.7
date	98.01.31.17.06.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.01.18.40.33;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.04.12.19.05.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.27.17.46.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.11.19.22.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.24.20;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.56;	author deraadt;	state Exp;
branches;
next	;

1.8.10.1
date	2001.04.10.19.06.24;	author jason;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Remove NULL-checks before free() and a few related dead assignments.

ok and valuable input from millert@@
@
text
@/*	$OpenBSD: glob.c,v 1.45 2015/11/24 22:03:33 millert Exp $ */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Guido van Rossum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * glob(3) -- a superset of the one defined in POSIX 1003.2.
 *
 * The [!...] convention to negate a range is supported (SysV, Posix, ksh).
 *
 * Optional extra services, controlled by flags not defined by POSIX:
 *
 * GLOB_QUOTE:
 *	Escaping convention: \ inhibits any special meaning the following
 *	character might have (except \ at end of string is retained).
 * GLOB_MAGCHAR:
 *	Set in gl_flags if pattern contained a globbing character.
 * GLOB_NOMAGIC:
 *	Same as GLOB_NOCHECK, but it will only append pattern if it did
 *	not contain any magic characters.  [Used in csh style globbing]
 * GLOB_ALTDIRFUNC:
 *	Use alternately specified directory access functions.
 * GLOB_TILDE:
 *	expand ~user/foo to the /home/dir/of/user/foo
 * GLOB_BRACE:
 *	expand {1,2}{a,b} to 1a 1b 2a 2b
 * gl_matchc:
 *	Number of matches in the current invocation of glob.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <glob.h>
#include <limits.h>
#include <pwd.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "charclass.h"

#define	DOLLAR		'$'
#define	DOT		'.'
#define	EOS		'\0'
#define	LBRACKET	'['
#define	NOT		'!'
#define	QUESTION	'?'
#define	QUOTE		'\\'
#define	RANGE		'-'
#define	RBRACKET	']'
#define	SEP		'/'
#define	STAR		'*'
#define	TILDE		'~'
#define	UNDERSCORE	'_'
#define	LBRACE		'{'
#define	RBRACE		'}'
#define	SLASH		'/'
#define	COMMA		','

#ifndef DEBUG

#define	M_QUOTE		0x8000
#define	M_PROTECT	0x4000
#define	M_MASK		0xffff
#define	M_ASCII		0x00ff

typedef u_short Char;

#else

#define	M_QUOTE		0x80
#define	M_PROTECT	0x40
#define	M_MASK		0xff
#define	M_ASCII		0x7f

typedef char Char;

#endif


#define	CHAR(c)		((Char)((c)&M_ASCII))
#define	META(c)		((Char)((c)|M_QUOTE))
#define	M_ALL		META('*')
#define	M_END		META(']')
#define	M_NOT		META('!')
#define	M_ONE		META('?')
#define	M_RNG		META('-')
#define	M_SET		META('[')
#define	M_CLASS		META(':')
#define	ismeta(c)	(((c)&M_QUOTE) != 0)

#define	GLOB_LIMIT_MALLOC	65536
#define	GLOB_LIMIT_STAT		2048
#define	GLOB_LIMIT_READDIR	16384

/* Limit of recursion during matching attempts. */
#define GLOB_LIMIT_RECUR	64

struct glob_lim {
	size_t	glim_malloc;
	size_t	glim_stat;
	size_t	glim_readdir;
};

struct glob_path_stat {
	char		*gps_path;
	struct stat	*gps_stat;
};

static int	 compare(const void *, const void *);
static int	 compare_gps(const void *, const void *);
static int	 g_Ctoc(const Char *, char *, u_int);
static int	 g_lstat(Char *, struct stat *, glob_t *);
static DIR	*g_opendir(Char *, glob_t *);
static Char	*g_strchr(const Char *, int);
static int	 g_strncmp(const Char *, const char *, size_t);
static int	 g_stat(Char *, struct stat *, glob_t *);
static int	 glob0(const Char *, glob_t *, struct glob_lim *);
static int	 glob1(Char *, Char *, glob_t *, struct glob_lim *);
static int	 glob2(Char *, Char *, Char *, Char *, Char *, Char *,
		    glob_t *, struct glob_lim *);
static int	 glob3(Char *, Char *, Char *, Char *, Char *,
		    Char *, Char *, glob_t *, struct glob_lim *);
static int	 globextend(const Char *, glob_t *, struct glob_lim *,
		    struct stat *);
static const Char *
		 globtilde(const Char *, Char *, size_t, glob_t *);
static int	 globexp1(const Char *, glob_t *, struct glob_lim *);
static int	 globexp2(const Char *, const Char *, glob_t *,
		    struct glob_lim *);
static int	 match(Char *, Char *, Char *, int);
#ifdef DEBUG
static void	 qprintf(const char *, Char *);
#endif

int
glob(const char *pattern, int flags, int (*errfunc)(const char *, int),
    glob_t *pglob)
{
	const u_char *patnext;
	int c;
	Char *bufnext, *bufend, patbuf[PATH_MAX];
	struct glob_lim limit = { 0, 0, 0 };

	patnext = (u_char *) pattern;
	if (!(flags & GLOB_APPEND)) {
		pglob->gl_pathc = 0;
		pglob->gl_pathv = NULL;
		pglob->gl_statv = NULL;
		if (!(flags & GLOB_DOOFFS))
			pglob->gl_offs = 0;
	}
	pglob->gl_flags = flags & ~GLOB_MAGCHAR;
	pglob->gl_errfunc = errfunc;
	pglob->gl_matchc = 0;

	if (strnlen(pattern, PATH_MAX) == PATH_MAX)
		return(GLOB_NOMATCH);

	if (pglob->gl_offs < 0 || pglob->gl_pathc < 0 ||
	    pglob->gl_offs >= INT_MAX || pglob->gl_pathc >= INT_MAX ||
	    pglob->gl_pathc >= INT_MAX - pglob->gl_offs - 1)
		return GLOB_NOSPACE;

	bufnext = patbuf;
	bufend = bufnext + PATH_MAX - 1;
	if (flags & GLOB_NOESCAPE)
		while (bufnext < bufend && (c = *patnext++) != EOS)
			*bufnext++ = c;
	else {
		/* Protect the quoted characters. */
		while (bufnext < bufend && (c = *patnext++) != EOS)
			if (c == QUOTE) {
				if ((c = *patnext++) == EOS) {
					c = QUOTE;
					--patnext;
				}
				*bufnext++ = c | M_PROTECT;
			} else
				*bufnext++ = c;
	}
	*bufnext = EOS;

	if (flags & GLOB_BRACE)
		return globexp1(patbuf, pglob, &limit);
	else
		return glob0(patbuf, pglob, &limit);
}

/*
 * Expand recursively a glob {} pattern. When there is no more expansion
 * invoke the standard globbing routine to glob the rest of the magic
 * characters
 */
static int
globexp1(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)
{
	const Char* ptr = pattern;

	/* Protect a single {}, for find(1), like csh */
	if (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS)
		return glob0(pattern, pglob, limitp);

	if ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL)
		return globexp2(ptr, pattern, pglob, limitp);

	return glob0(pattern, pglob, limitp);
}


/*
 * Recursive brace globbing helper. Tries to expand a single brace.
 * If it succeeds then it invokes globexp1 with the new pattern.
 * If it fails then it tries to glob the rest of the pattern and returns.
 */
static int
globexp2(const Char *ptr, const Char *pattern, glob_t *pglob,
    struct glob_lim *limitp)
{
	int     i, rv;
	Char   *lm, *ls;
	const Char *pe, *pm, *pl;
	Char    patbuf[PATH_MAX];

	/* copy part up to the brace */
	for (lm = patbuf, pm = pattern; pm != ptr; *lm++ = *pm++)
		;
	*lm = EOS;
	ls = lm;

	/* Find the balanced brace */
	for (i = 0, pe = ++ptr; *pe; pe++)
		if (*pe == LBRACKET) {
			/* Ignore everything between [] */
			for (pm = pe++; *pe != RBRACKET && *pe != EOS; pe++)
				;
			if (*pe == EOS) {
				/*
				 * We could not find a matching RBRACKET.
				 * Ignore and just look for RBRACE
				 */
				pe = pm;
			}
		} else if (*pe == LBRACE)
			i++;
		else if (*pe == RBRACE) {
			if (i == 0)
				break;
			i--;
		}

	/* Non matching braces; just glob the pattern */
	if (i != 0 || *pe == EOS)
		return glob0(patbuf, pglob, limitp);

	for (i = 0, pl = pm = ptr; pm <= pe; pm++) {
		switch (*pm) {
		case LBRACKET:
			/* Ignore everything between [] */
			for (pl = pm++; *pm != RBRACKET && *pm != EOS; pm++)
				;
			if (*pm == EOS) {
				/*
				 * We could not find a matching RBRACKET.
				 * Ignore and just look for RBRACE
				 */
				pm = pl;
			}
			break;

		case LBRACE:
			i++;
			break;

		case RBRACE:
			if (i) {
				i--;
				break;
			}
			/* FALLTHROUGH */
		case COMMA:
			if (i && *pm == COMMA)
				break;
			else {
				/* Append the current string */
				for (lm = ls; (pl < pm); *lm++ = *pl++)
					;

				/*
				 * Append the rest of the pattern after the
				 * closing brace
				 */
				for (pl = pe + 1; (*lm++ = *pl++) != EOS; )
					;

				/* Expand the current pattern */
#ifdef DEBUG
				qprintf("globexp2:", patbuf);
#endif
				rv = globexp1(patbuf, pglob, limitp);
				if (rv && rv != GLOB_NOMATCH)
					return rv;

				/* move after the comma, to the next string */
				pl = pm + 1;
			}
			break;

		default:
			break;
		}
	}
	return 0;
}



/*
 * expand tilde from the passwd file.
 */
static const Char *
globtilde(const Char *pattern, Char *patbuf, size_t patbuf_len, glob_t *pglob)
{
	struct passwd pwstore, *pwd = NULL;
	char *h, pwbuf[_PW_BUF_LEN];
	const Char *p;
	Char *b, *eb;

	if (*pattern != TILDE || !(pglob->gl_flags & GLOB_TILDE))
		return pattern;

	/* Copy up to the end of the string or / */
	eb = &patbuf[patbuf_len - 1];
	for (p = pattern + 1, h = (char *) patbuf;
	    h < (char *)eb && *p && *p != SLASH; *h++ = *p++)
		;

	*h = EOS;

#if 0
	if (h == (char *)eb)
		return what;
#endif

	if (((char *) patbuf)[0] == EOS) {
		/*
		 * handle a plain ~ or ~/ by expanding $HOME
		 * first and then trying the password file
		 */
		if (issetugid() != 0 || (h = getenv("HOME")) == NULL) {
			getpwuid_r(getuid(), &pwstore, pwbuf, sizeof(pwbuf),
			    &pwd);
			if (pwd == NULL)
				return pattern;
			else
				h = pwd->pw_dir;
		}
	} else {
		/*
		 * Expand a ~user
		 */
		getpwnam_r((char *)patbuf, &pwstore, pwbuf, sizeof(pwbuf),
		    &pwd);
		if (pwd == NULL)
			return pattern;
		else
			h = pwd->pw_dir;
	}

	/* Copy the home directory */
	for (b = patbuf; b < eb && *h; *b++ = *h++)
		;

	/* Append the rest of the pattern */
	while (b < eb && (*b++ = *p++) != EOS)
		;
	*b = EOS;

	return patbuf;
}

static int
g_strncmp(const Char *s1, const char *s2, size_t n)
{
	int rv = 0;

	while (n--) {
		rv = *(Char *)s1 - *(const unsigned char *)s2++;
		if (rv)
			break;
		if (*s1++ == '\0')
			break;
	}
	return rv;
}

static int
g_charclass(const Char **patternp, Char **bufnextp)
{
	const Char *pattern = *patternp + 1;
	Char *bufnext = *bufnextp;
	const Char *colon;
	struct cclass *cc;
	size_t len;

	if ((colon = g_strchr(pattern, ':')) == NULL || colon[1] != ']')
		return 1;	/* not a character class */

	len = (size_t)(colon - pattern);
	for (cc = cclasses; cc->name != NULL; cc++) {
		if (!g_strncmp(pattern, cc->name, len) && cc->name[len] == '\0')
			break;
	}
	if (cc->name == NULL)
		return -1;	/* invalid character class */
	*bufnext++ = M_CLASS;
	*bufnext++ = (Char)(cc - &cclasses[0]);
	*bufnextp = bufnext;
	*patternp += len + 3;

	return 0;
}

/*
 * The main glob() routine: compiles the pattern (optionally processing
 * quotes), calls glob1() to do the real pattern matching, and finally
 * sorts the list (unless unsorted operation is requested).  Returns 0
 * if things went well, nonzero if errors occurred.  It is not an error
 * to find no matches.
 */
static int
glob0(const Char *pattern, glob_t *pglob, struct glob_lim *limitp)
{
	const Char *qpatnext;
	int c, err, oldpathc;
	Char *bufnext, patbuf[PATH_MAX];

	qpatnext = globtilde(pattern, patbuf, PATH_MAX, pglob);
	oldpathc = pglob->gl_pathc;
	bufnext = patbuf;

	/* We don't need to check for buffer overflow any more. */
	while ((c = *qpatnext++) != EOS) {
		switch (c) {
		case LBRACKET:
			c = *qpatnext;
			if (c == NOT)
				++qpatnext;
			if (*qpatnext == EOS ||
			    g_strchr(qpatnext+1, RBRACKET) == NULL) {
				*bufnext++ = LBRACKET;
				if (c == NOT)
					--qpatnext;
				break;
			}
			*bufnext++ = M_SET;
			if (c == NOT)
				*bufnext++ = M_NOT;
			c = *qpatnext++;
			do {
				if (c == LBRACKET && *qpatnext == ':') {
					do {
						err = g_charclass(&qpatnext,
						    &bufnext);
						if (err)
							break;
						c = *qpatnext++;
					} while (c == LBRACKET && *qpatnext == ':');
					if (err == -1 &&
					    !(pglob->gl_flags & GLOB_NOCHECK))
						return GLOB_NOMATCH;
					if (c == RBRACKET)
						break;
				}
				*bufnext++ = CHAR(c);
				if (*qpatnext == RANGE &&
				    (c = qpatnext[1]) != RBRACKET) {
					*bufnext++ = M_RNG;
					*bufnext++ = CHAR(c);
					qpatnext += 2;
				}
			} while ((c = *qpatnext++) != RBRACKET);
			pglob->gl_flags |= GLOB_MAGCHAR;
			*bufnext++ = M_END;
			break;
		case QUESTION:
			pglob->gl_flags |= GLOB_MAGCHAR;
			*bufnext++ = M_ONE;
			break;
		case STAR:
			pglob->gl_flags |= GLOB_MAGCHAR;
			/* collapse adjacent stars to one,
			 * to avoid exponential behavior
			 */
			if (bufnext == patbuf || bufnext[-1] != M_ALL)
				*bufnext++ = M_ALL;
			break;
		default:
			*bufnext++ = CHAR(c);
			break;
		}
	}
	*bufnext = EOS;
#ifdef DEBUG
	qprintf("glob0:", patbuf);
#endif

	if ((err = glob1(patbuf, patbuf+PATH_MAX-1, pglob, limitp)) != 0)
		return(err);

	/*
	 * If there was no match we are going to append the pattern
	 * if GLOB_NOCHECK was specified or if GLOB_NOMAGIC was specified
	 * and the pattern did not contain any magic characters
	 * GLOB_NOMAGIC is there just for compatibility with csh.
	 */
	if (pglob->gl_pathc == oldpathc) {
		if ((pglob->gl_flags & GLOB_NOCHECK) ||
		    ((pglob->gl_flags & GLOB_NOMAGIC) &&
		    !(pglob->gl_flags & GLOB_MAGCHAR)))
			return(globextend(pattern, pglob, limitp, NULL));
		else
			return(GLOB_NOMATCH);
	}
	if (!(pglob->gl_flags & GLOB_NOSORT)) {
		if ((pglob->gl_flags & GLOB_KEEPSTAT)) {
			/* Keep the paths and stat info synced during sort */
			struct glob_path_stat *path_stat;
			int i;
			int n = pglob->gl_pathc - oldpathc;
			int o = pglob->gl_offs + oldpathc;

			if ((path_stat = calloc(n, sizeof(*path_stat))) == NULL)
				return GLOB_NOSPACE;
			for (i = 0; i < n; i++) {
				path_stat[i].gps_path = pglob->gl_pathv[o + i];
				path_stat[i].gps_stat = pglob->gl_statv[o + i];
			}
			qsort(path_stat, n, sizeof(*path_stat), compare_gps);
			for (i = 0; i < n; i++) {
				pglob->gl_pathv[o + i] = path_stat[i].gps_path;
				pglob->gl_statv[o + i] = path_stat[i].gps_stat;
			}
			free(path_stat);
		} else {
			qsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,
			    pglob->gl_pathc - oldpathc, sizeof(char *),
			    compare);
		}
	}
	return(0);
}

static int
compare(const void *p, const void *q)
{
	return(strcmp(*(char **)p, *(char **)q));
}

static int
compare_gps(const void *_p, const void *_q)
{
	const struct glob_path_stat *p = (const struct glob_path_stat *)_p;
	const struct glob_path_stat *q = (const struct glob_path_stat *)_q;

	return(strcmp(p->gps_path, q->gps_path));
}

static int
glob1(Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)
{
	Char pathbuf[PATH_MAX];

	/* A null pathname is invalid -- POSIX 1003.1 sect. 2.4. */
	if (*pattern == EOS)
		return(0);
	return(glob2(pathbuf, pathbuf+PATH_MAX-1,
	    pathbuf, pathbuf+PATH_MAX-1,
	    pattern, pattern_last, pglob, limitp));
}

/*
 * The functions glob2 and glob3 are mutually recursive; there is one level
 * of recursion for each segment in the pattern that contains one or more
 * meta characters.
 */
static int
glob2(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,
    Char *pattern, Char *pattern_last, glob_t *pglob, struct glob_lim *limitp)
{
	struct stat sb;
	Char *p, *q;
	int anymeta;

	/*
	 * Loop over pattern segments until end of pattern or until
	 * segment with meta character found.
	 */
	for (anymeta = 0;;) {
		if (*pattern == EOS) {		/* End of pattern? */
			*pathend = EOS;

			if ((pglob->gl_flags & GLOB_LIMIT) &&
			    limitp->glim_stat++ >= GLOB_LIMIT_STAT) {
				errno = 0;
				*pathend++ = SEP;
				*pathend = EOS;
				return(GLOB_NOSPACE);
			}
			if (g_lstat(pathbuf, &sb, pglob))
				return(0);

			if (((pglob->gl_flags & GLOB_MARK) &&
			    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode) ||
			    (S_ISLNK(sb.st_mode) &&
			    (g_stat(pathbuf, &sb, pglob) == 0) &&
			    S_ISDIR(sb.st_mode)))) {
				if (pathend+1 > pathend_last)
					return (1);
				*pathend++ = SEP;
				*pathend = EOS;
			}
			++pglob->gl_matchc;
			return(globextend(pathbuf, pglob, limitp, &sb));
		}

		/* Find end of next segment, copy tentatively to pathend. */
		q = pathend;
		p = pattern;
		while (*p != EOS && *p != SEP) {
			if (ismeta(*p))
				anymeta = 1;
			if (q+1 > pathend_last)
				return (1);
			*q++ = *p++;
		}

		if (!anymeta) {		/* No expansion, do next segment. */
			pathend = q;
			pattern = p;
			while (*pattern == SEP) {
				if (pathend+1 > pathend_last)
					return (1);
				*pathend++ = *pattern++;
			}
		} else
			/* Need expansion, recurse. */
			return(glob3(pathbuf, pathbuf_last, pathend,
			    pathend_last, pattern, p, pattern_last,
			    pglob, limitp));
	}
	/* NOTREACHED */
}

static int
glob3(Char *pathbuf, Char *pathbuf_last, Char *pathend, Char *pathend_last,
    Char *pattern, Char *restpattern, Char *restpattern_last, glob_t *pglob,
    struct glob_lim *limitp)
{
	struct dirent *dp;
	DIR *dirp;
	int err;
	char buf[PATH_MAX];

	/*
	 * The readdirfunc declaration can't be prototyped, because it is
	 * assigned, below, to two functions which are prototyped in glob.h
	 * and dirent.h as taking pointers to differently typed opaque
	 * structures.
	 */
	struct dirent *(*readdirfunc)(void *);

	if (pathend > pathend_last)
		return (1);
	*pathend = EOS;
	errno = 0;

	if ((dirp = g_opendir(pathbuf, pglob)) == NULL) {
		/* TODO: don't call for ENOENT or ENOTDIR? */
		if (pglob->gl_errfunc) {
			if (g_Ctoc(pathbuf, buf, sizeof(buf)))
				return(GLOB_ABORTED);
			if (pglob->gl_errfunc(buf, errno) ||
			    pglob->gl_flags & GLOB_ERR)
				return(GLOB_ABORTED);
		}
		return(0);
	}

	err = 0;

	/* Search directory for matching names. */
	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		readdirfunc = pglob->gl_readdir;
	else
		readdirfunc = (struct dirent *(*)(void *))readdir;
	while ((dp = (*readdirfunc)(dirp))) {
		u_char *sc;
		Char *dc;

		if ((pglob->gl_flags & GLOB_LIMIT) &&
		    limitp->glim_readdir++ >= GLOB_LIMIT_READDIR) {
			errno = 0;
			*pathend++ = SEP;
			*pathend = EOS;
			err = GLOB_NOSPACE;
			break;
		}

		/* Initial DOT must be matched literally. */
		if (dp->d_name[0] == DOT && *pattern != DOT)
			continue;
		dc = pathend;
		sc = (u_char *) dp->d_name;
		while (dc < pathend_last && (*dc++ = *sc++) != EOS)
			;
		if (dc >= pathend_last) {
			*dc = EOS;
			err = 1;
			break;
		}

		if (!match(pathend, pattern, restpattern, GLOB_LIMIT_RECUR)) {
			*pathend = EOS;
			continue;
		}
		err = glob2(pathbuf, pathbuf_last, --dc, pathend_last,
		    restpattern, restpattern_last, pglob, limitp);
		if (err)
			break;
	}

	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		(*pglob->gl_closedir)(dirp);
	else
		closedir(dirp);
	return(err);
}


/*
 * Extend the gl_pathv member of a glob_t structure to accommodate a new item,
 * add the new item, and update gl_pathc.
 *
 * This assumes the BSD realloc, which only copies the block when its size
 * crosses a power-of-two boundary; for v7 realloc, this would cause quadratic
 * behavior.
 *
 * Return 0 if new item added, error code if memory couldn't be allocated.
 *
 * Invariant of the glob_t structure:
 *	Either gl_pathc is zero and gl_pathv is NULL; or gl_pathc > 0 and
 *	gl_pathv points to (gl_offs + gl_pathc + 1) items.
 */
static int
globextend(const Char *path, glob_t *pglob, struct glob_lim *limitp,
    struct stat *sb)
{
	char **pathv;
	ssize_t i;
	size_t newn, len;
	char *copy = NULL;
	const Char *p;
	struct stat **statv;

	newn = 2 + pglob->gl_pathc + pglob->gl_offs;
	if (pglob->gl_offs >= INT_MAX ||
	    pglob->gl_pathc >= INT_MAX ||
	    newn >= INT_MAX ||
	    SIZE_MAX / sizeof(*pathv) <= newn ||
	    SIZE_MAX / sizeof(*statv) <= newn) {
 nospace:
		for (i = pglob->gl_offs; i < (ssize_t)(newn - 2); i++) {
			if (pglob->gl_pathv && pglob->gl_pathv[i])
				free(pglob->gl_pathv[i]);
			if ((pglob->gl_flags & GLOB_KEEPSTAT) != 0 &&
			    pglob->gl_pathv && pglob->gl_pathv[i])
				free(pglob->gl_statv[i]);
		}
		free(pglob->gl_pathv);
		pglob->gl_pathv = NULL;
		free(pglob->gl_statv);
		pglob->gl_statv = NULL;
		return(GLOB_NOSPACE);
	}

	pathv = reallocarray(pglob->gl_pathv, newn, sizeof(*pathv));
	if (pathv == NULL)
		goto nospace;
	if (pglob->gl_pathv == NULL && pglob->gl_offs > 0) {
		/* first time around -- clear initial gl_offs items */
		pathv += pglob->gl_offs;
		for (i = pglob->gl_offs; --i >= 0; )
			*--pathv = NULL;
	}
	pglob->gl_pathv = pathv;

	if ((pglob->gl_flags & GLOB_KEEPSTAT) != 0) {
		statv = reallocarray(pglob->gl_statv, newn, sizeof(*statv));
		if (statv == NULL)
			goto nospace;
		if (pglob->gl_statv == NULL && pglob->gl_offs > 0) {
			/* first time around -- clear initial gl_offs items */
			statv += pglob->gl_offs;
			for (i = pglob->gl_offs; --i >= 0; )
				*--statv = NULL;
		}
		pglob->gl_statv = statv;
		if (sb == NULL)
			statv[pglob->gl_offs + pglob->gl_pathc] = NULL;
		else {
			limitp->glim_malloc += sizeof(**statv);
			if ((pglob->gl_flags & GLOB_LIMIT) &&
			    limitp->glim_malloc >= GLOB_LIMIT_MALLOC) {
				errno = 0;
				return(GLOB_NOSPACE);
			}
			if ((statv[pglob->gl_offs + pglob->gl_pathc] =
			    malloc(sizeof(**statv))) == NULL)
				goto copy_error;
			memcpy(statv[pglob->gl_offs + pglob->gl_pathc], sb,
			    sizeof(*sb));
		}
		statv[pglob->gl_offs + pglob->gl_pathc + 1] = NULL;
	}

	for (p = path; *p++;)
		;
	len = (size_t)(p - path);
	limitp->glim_malloc += len;
	if ((copy = malloc(len)) != NULL) {
		if (g_Ctoc(path, copy, len)) {
			free(copy);
			return(GLOB_NOSPACE);
		}
		pathv[pglob->gl_offs + pglob->gl_pathc++] = copy;
	}
	pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;

	if ((pglob->gl_flags & GLOB_LIMIT) &&
	    (newn * sizeof(*pathv)) + limitp->glim_malloc >
	    GLOB_LIMIT_MALLOC) {
		errno = 0;
		return(GLOB_NOSPACE);
	}
 copy_error:
	return(copy == NULL ? GLOB_NOSPACE : 0);
}


/*
 * pattern matching function for filenames.  Each occurrence of the *
 * pattern causes a recursion level.
 */
static int
match(Char *name, Char *pat, Char *patend, int recur)
{
	int ok, negate_range;
	Char c, k;

	if (recur-- == 0)
		return(GLOB_NOSPACE);

	while (pat < patend) {
		c = *pat++;
		switch (c & M_MASK) {
		case M_ALL:
			while (pat < patend && (*pat & M_MASK) == M_ALL)
				pat++;	/* eat consecutive '*' */
			if (pat == patend)
				return(1);
			do {
			    if (match(name, pat, patend, recur))
				    return(1);
			} while (*name++ != EOS);
			return(0);
		case M_ONE:
			if (*name++ == EOS)
				return(0);
			break;
		case M_SET:
			ok = 0;
			if ((k = *name++) == EOS)
				return(0);
			if ((negate_range = ((*pat & M_MASK) == M_NOT)) != EOS)
				++pat;
			while (((c = *pat++) & M_MASK) != M_END) {
				if ((c & M_MASK) == M_CLASS) {
					Char idx = *pat & M_MASK;
					if (idx < NCCLASSES &&
					    cclasses[idx].isctype(k))
						ok = 1;
					++pat;
				}
				if ((*pat & M_MASK) == M_RNG) {
					if (c <= k && k <= pat[1])
						ok = 1;
					pat += 2;
				} else if (c == k)
					ok = 1;
			}
			if (ok == negate_range)
				return(0);
			break;
		default:
			if (*name++ != c)
				return(0);
			break;
		}
	}
	return(*name == EOS);
}

/* Free allocated data belonging to a glob_t structure. */
void
globfree(glob_t *pglob)
{
	int i;
	char **pp;

	if (pglob->gl_pathv != NULL) {
		pp = pglob->gl_pathv + pglob->gl_offs;
		for (i = pglob->gl_pathc; i--; ++pp)
			free(*pp);
		free(pglob->gl_pathv);
		pglob->gl_pathv = NULL;
	}
	if (pglob->gl_statv != NULL) {
		for (i = 0; i < pglob->gl_pathc; i++) {
			free(pglob->gl_statv[i]);
		}
		free(pglob->gl_statv);
		pglob->gl_statv = NULL;
	}
}

static DIR *
g_opendir(Char *str, glob_t *pglob)
{
	char buf[PATH_MAX];

	if (!*str)
		strlcpy(buf, ".", sizeof buf);
	else {
		if (g_Ctoc(str, buf, sizeof(buf)))
			return(NULL);
	}

	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		return((*pglob->gl_opendir)(buf));

	return(opendir(buf));
}

static int
g_lstat(Char *fn, struct stat *sb, glob_t *pglob)
{
	char buf[PATH_MAX];

	if (g_Ctoc(fn, buf, sizeof(buf)))
		return(-1);
	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		return((*pglob->gl_lstat)(buf, sb));
	return(lstat(buf, sb));
}

static int
g_stat(Char *fn, struct stat *sb, glob_t *pglob)
{
	char buf[PATH_MAX];

	if (g_Ctoc(fn, buf, sizeof(buf)))
		return(-1);
	if (pglob->gl_flags & GLOB_ALTDIRFUNC)
		return((*pglob->gl_stat)(buf, sb));
	return(stat(buf, sb));
}

static Char *
g_strchr(const Char *str, int ch)
{
	do {
		if (*str == ch)
			return ((Char *)str);
	} while (*str++);
	return (NULL);
}

static int
g_Ctoc(const Char *str, char *buf, u_int len)
{

	while (len--) {
		if ((*buf++ = *str++) == EOS)
			return (0);
	}
	return (1);
}

#ifdef DEBUG
static void
qprintf(const char *str, Char *s)
{
	Char *p;

	(void)printf("%s:\n", str);
	for (p = s; *p; p++)
		(void)printf("%c", CHAR(*p));
	(void)printf("\n");
	for (p = s; *p; p++)
		(void)printf("%c", *p & M_PROTECT ? '"' : ' ');
	(void)printf("\n");
	for (p = s; *p; p++)
		(void)printf("%c", ismeta(*p) ? '_' : ' ');
	(void)printf("\n");
}
#endif
@


1.45
log
@Use reentrant versions of getpw{nam,uid} and getgr{nam,gid} within
libc to avoid reusing the static buffers returned by the non-reentrant
versions.  Since this is inside libc we can use constants for the
buffer sizes instead of having to call sysconf().
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.44 2015/09/14 16:09:13 tedu Exp $ */
d813 4
a816 8
		if (pglob->gl_pathv) {
			free(pglob->gl_pathv);
			pglob->gl_pathv = NULL;
		}
		if (pglob->gl_statv) {
			free(pglob->gl_statv);
			pglob->gl_statv = NULL;
		}
@


1.44
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.43 2015/06/13 16:57:04 deraadt Exp $ */
d357 2
a358 2
	struct passwd *pwd;
	char *h;
d384 3
a386 1
			if ((pwd = getpwuid(getuid())) == NULL)
d395 3
a397 1
		if ((pwd = getpwnam((char*) patbuf)) == NULL)
@


1.43
log
@in glob() initialize the glob_t before the first failure check.
from j@@pureftpd.org
ok millert stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.42 2015/02/05 12:59:57 millert Exp $ */
d957 1
a957 2
			if (*pp)
				free(*pp);
d963 1
a963 2
			if (pglob->gl_statv[i] != NULL)
				free(pglob->gl_statv[i]);
@


1.42
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.41 2014/10/08 05:35:27 deraadt Exp $ */
a177 3
	if (strnlen(pattern, PATH_MAX) == PATH_MAX)
		return(GLOB_NOMATCH);

d189 3
@


1.41
log
@obvious realloc -> reallocarray conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.40 2013/09/30 12:02:34 millert Exp $ */
d67 1
@


1.40
log
@Use PATH_MAX, NAME_MAX and LOGIN_NAME_MAX not MAXPATHNAMELEN,
MAXNAMLEN or MAXLOGNAME where possible.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.39 2012/01/20 07:09:42 tedu Exp $ */
d819 1
a819 1
	pathv = realloc(pglob->gl_pathv, newn * sizeof(*pathv));
d831 1
a831 1
		statv = realloc(pglob->gl_statv, newn * sizeof(*statv));
@


1.39
log
@the glob stat limit is way too low.  bump to 2048.
while here, failed stats should count against the limit too.
ok deraadt sthen stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.38 2011/09/22 06:27:29 djm Exp $ */
a58 1
#include <sys/param.h>
d174 1
a174 1
	Char *bufnext, *bufend, patbuf[MAXPATHLEN];
d198 1
a198 1
	bufend = bufnext + MAXPATHLEN - 1;
d255 1
a255 1
	Char    patbuf[MAXPATHLEN];
d464 1
a464 1
	Char *bufnext, patbuf[MAXPATHLEN];
d466 1
a466 1
	qpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);
d536 1
a536 1
	if ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, limitp)) != 0)
d600 1
a600 1
	Char pathbuf[MAXPATHLEN];
d605 2
a606 2
	return(glob2(pathbuf, pathbuf+MAXPATHLEN-1,
	    pathbuf, pathbuf+MAXPATHLEN-1,
d691 1
a691 1
	char buf[MAXPATHLEN];
d974 1
a974 1
	char buf[MAXPATHLEN];
d992 1
a992 1
	char buf[MAXPATHLEN];
d1004 1
a1004 1
	char buf[MAXPATHLEN];
@


1.38
log
@fix GLOB_KEEPSTAT without GLOB_NOSORT; the implicit sort was being
applied only to the gl_pathv vector and not the corresponding gl_statv
array. reported in OpenSSH bz#1935; feedback and okay matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.37 2011/09/20 10:18:46 stsp Exp $ */
d126 1
a126 1
#define	GLOB_LIMIT_STAT		128
a630 2
			if (g_lstat(pathbuf, &sb, pglob))
				return(0);
d639 2
@


1.37
log
@In glob(3), limit recursion during matching attempts. Similar to fnmatch fix.
Also collapse consecutive '*' (from NetBSD).
ok miod deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.36 2011/05/12 07:15:10 pyr Exp $ */
d129 3
d138 4
a141 2
/* Limit of recursion during matching attempts. */
#define GLOB_LIMIT_RECUR	64
d144 1
d554 26
a579 3
	if (!(pglob->gl_flags & GLOB_NOSORT))
		qsort(pglob->gl_pathv + pglob->gl_offs + oldpathc,
		    pglob->gl_pathc - oldpathc, sizeof(char *), compare);
d587 9
@


1.36
log
@When the max number of items for a directory has reached GLOB_LIMIT_READDIR
an error is returned but closedir() is not called.

spotted and fix provided by Frank Denis obsd-tech@@pureftpd.org

ok otto@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.35 2011/01/12 01:53:14 djm Exp $ */
d66 1
d135 3
d158 1
a158 1
static int	 match(Char *, Char *, Char *);
d172 3
d714 1
a714 1
		if (!match(pathend, pattern, restpattern)) {
d851 1
a851 1
match(Char *name, Char *pat, Char *patend)
d856 3
d863 2
d868 1
a868 1
			    if (match(name, pat, patend))
@


1.35
log
@avoid some integer overflows mostly with GLOB_APPEND and GLOB_DOOFFS
and sanity check arguments (these will be unnecessary when we switch
struct glob members from being type into to size_t in the future);
"looks ok" tedu@@ feedback guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.34 2010/10/08 21:48:42 nicm Exp $ */
d690 2
a691 1
			return(GLOB_NOSPACE);
@


1.34
log
@Extend GLOB_LIMIT to cover readdir and stat and bump the malloc limit
from ARG_MAX to 64K.

Fixes glob-using programs (notably ftp) able to be triggered to hit
resource limits.

Idea from a similar NetBSD change, original problem reported by jasper@@.

ok millert tedu jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.33 2010/09/26 22:15:39 djm Exp $ */
d180 5
d750 4
a753 1
	if (SIZE_MAX / sizeof(*pathv) <= newn ||
d756 1
a756 1
		for (i = pglob->gl_offs; i < newn - 2; i++) {
d871 1
a871 1
					int idx = *pat & M_MASK;
@


1.33
log
@oops, don't free array before freeing members; spotted by dkrause@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.32 2010/09/24 13:32:55 djm Exp $ */
d124 9
d141 2
a142 2
static int	 glob0(const Char *, glob_t *);
static int	 glob1(Char *, Char *, glob_t *, size_t *);
d144 1
a144 1
		    glob_t *, size_t *);
d146 3
a148 2
		    Char *, Char *, glob_t *, size_t *);
static int	 globextend(const Char *, glob_t *, size_t *, struct stat *);
d151 3
a153 2
static int	 globexp1(const Char *, glob_t *);
static int	 globexp2(const Char *, const Char *, glob_t *);
d166 1
d200 1
a200 1
		return globexp1(patbuf, pglob);
d202 1
a202 1
		return glob0(patbuf, pglob);
d211 1
a211 1
globexp1(const Char *pattern, glob_t *pglob)
d217 1
a217 1
		return glob0(pattern, pglob);
d220 1
a220 1
		return globexp2(ptr, pattern, pglob);
d222 1
a222 1
	return glob0(pattern, pglob);
d232 2
a233 1
globexp2(const Char *ptr, const Char *pattern, glob_t *pglob)
d269 1
a269 1
		return glob0(patbuf, pglob);
d315 1
a315 1
				rv = globexp1(patbuf, pglob);
d443 1
a443 1
glob0(const Char *pattern, glob_t *pglob)
a447 1
	size_t limit = 0;
d519 1
a519 1
	if ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, &limit)) != 0)
d532 1
a532 1
			return(globextend(pattern, pglob, &limit, NULL));
d549 1
a549 1
glob1(Char *pattern, Char *pattern_last, glob_t *pglob, size_t *limitp)
d568 1
a568 1
    Char *pattern, Char *pattern_last, glob_t *pglob, size_t *limitp)
d584 8
d637 1
a637 1
    size_t *limitp)
d680 8
d734 2
a735 1
globextend(const Char *path, glob_t *pglob, size_t *limitp, struct stat *sb)
d791 6
d809 1
a809 1
	*limitp += len;
d820 2
a821 1
	    (newn * sizeof(*pathv)) + *limitp >= ARG_MAX) {
@


1.32
log
@add a GLOB_KEEPSTAT option that retains a copy of the struct stat
information that is looked up while matching glob(3)s

Keeping this information around can make a big difference when
fetching it is expensive, e.g. in sftp which uses GLOB_ALTDIRFUNC

feedback millert@@ jmc@@

"get it in before the libc crank" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.31 2010/05/19 14:53:06 chl Exp $ */
a867 1
		free(pglob->gl_statv);
d872 1
@


1.31
log
@remove unused variable

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.30 2010/03/23 09:52:35 nicm Exp $ */
d138 1
a138 1
static int	 globextend(const Char *, glob_t *, size_t *);
d160 1
d520 1
a520 1
			return(globextend(pattern, pglob, &limit));
d583 1
a583 1
			return(globextend(pathbuf, pglob, limitp));
d706 1
a706 1
globextend(const Char *path, glob_t *pglob, size_t *limitp)
d709 3
a711 3
	int i;
	u_int newsize, len;
	char *copy;
d713 1
d715 11
a725 3
	newsize = sizeof(*pathv) * (2 + pglob->gl_pathc + pglob->gl_offs);
	pathv = realloc((char *)pglob->gl_pathv, newsize);
	if (pathv == NULL) {
d730 4
d737 3
d748 23
d785 1
a785 1
	    newsize + *limitp >= ARG_MAX) {
d789 1
a789 1

d866 8
@


1.30
log
@Fix glob(3) to correctly return an error when its buffer space is
exhausted and GLOB_BRACE is given. globexp2() was ignoring errors
returned from lower levels.

While here, change globexp2() to return its return value normally rather
putting it in a int pointer then always returning 0.

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.29 2009/11/21 16:42:05 chl Exp $ */
a200 1
	int rv;
@


1.29
log
@replacing malloc/realloc dance, by only one realloc

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.28 2009/02/18 15:50:27 millert Exp $ */
d142 1
a142 1
static int	 globexp2(const Char *, const Char *, glob_t *, int *);
d207 2
a208 3
	while ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL)
		if (!globexp2(ptr, pattern, pglob, &rv))
			return rv;
d220 1
a220 1
globexp2(const Char *ptr, const Char *pattern, glob_t *pglob, int *rv)
d222 1
a222 1
	int     i;
d255 2
a256 4
	if (i != 0 || *pe == EOS) {
		*rv = glob0(patbuf, pglob);
		return 0;
	}
d302 3
a304 1
				*rv = globexp1(patbuf, pglob);
a314 1
	*rv = 0;
@


1.28
log
@Add missing braces.  This is why we use braces for indented block that
are more than a couple of lines...
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.27 2008/10/01 23:04:13 millert Exp $ */
d717 1
a717 2
	pathv = pglob->gl_pathv ? realloc((char *)pglob->gl_pathv, newsize) :
	    malloc(newsize);
@


1.27
log
@POSIX character class support for fnmatch(3) and glob(3).  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.26 2005/11/28 17:50:12 deraadt Exp $ */
d789 1
a789 1
			while (((c = *pat++) & M_MASK) != M_END)
d803 1
@


1.26
log
@unused arg in internal static API
@
text
@d1 1
a1 1
/*	$OpenBSD: glob.c,v 1.25 2005/08/08 08:05:34 espie Exp $ */
d72 2
d121 1
d129 2
a130 1
static Char	*g_strchr(Char *, int);
d207 1
a207 1
	while ((ptr = (const Char *) g_strchr((Char *) ptr, LBRACE)) != NULL)
d382 41
d451 1
a451 1
			    g_strchr((Char *) qpatnext+1, RBRACKET) == NULL) {
d462 14
d790 7
d875 1
a875 1
g_strchr(Char *str, int ch)
d879 1
a879 1
			return (str);
@


1.25
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d132 1
a132 1
static int	 glob3(Char *, Char *, Char *, Char *, Char *, Char *,
d551 2
a552 2
			    pathend_last, pattern, pattern_last,
			    p, pattern_last, pglob, limitp));
d559 2
a560 2
    Char *pattern, Char *pattern_last, Char *restpattern,
    Char *restpattern_last, glob_t *pglob, size_t *limitp)
@


1.24
log
@Kill register and fix some whilespace goofs in a do {} while loop.
@
text
@d1 1
a32 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)glob.c	8.3 (Berkeley) 10/13/93";
#else
static char rcsid[] = "$OpenBSD: glob.c,v 1.23 2004/05/18 02:05:52 jfb Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.23
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d37 1
a37 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.22 2003/06/25 21:16:47 deraadt Exp $";
d569 1
a569 1
	register struct dirent *dp;
d607 2
a608 2
		register u_char *sc;
		register Char *dc;
d658 2
a659 2
	register char **pathv;
	register int i;
d722 1
a722 1
			do
d725 1
a725 2
			while (*name++ != EOS)
				;
d760 2
a761 2
	register int i;
	register char **pp;
d840 1
a840 1
	register Char *p;
@


1.22
log
@protos
@
text
@d37 1
a37 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.21 2003/06/02 20:18:34 millert Exp $";
d152 2
a153 4
glob(pattern, flags, errfunc, pglob)
	const char *pattern;
	int flags, (*errfunc)(const char *, int);
	glob_t *pglob;
d201 1
a201 3
globexp1(pattern, pglob)
	const Char *pattern;
	glob_t *pglob;
d224 1
a224 4
globexp2(ptr, pattern, pglob, rv)
	const Char *ptr, *pattern;
	glob_t *pglob;
	int *rv;
d329 1
a329 5
globtilde(pattern, patbuf, patbuf_len, pglob)
	const Char *pattern;
	Char *patbuf;
	size_t patbuf_len;
	glob_t *pglob;
d394 1
a394 3
glob0(pattern, pglob)
	const Char *pattern;
	glob_t *pglob;
d481 1
a481 2
compare(p, q)
	const void *p, *q;
d487 1
a487 4
glob1(pattern, pattern_last, pglob, limitp)
	Char *pattern, *pattern_last;
	glob_t *pglob;
	size_t *limitp;
d505 2
a506 6
glob2(pathbuf, pathbuf_last, pathend, pathend_last, pattern,
    pattern_last, pglob, limitp)
	Char *pathbuf, *pathbuf_last, *pathend, *pathend_last;
	Char *pattern, *pattern_last;
	glob_t *pglob;
	size_t *limitp;
d565 3
a567 6
glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, pattern_last,
    restpattern, restpattern_last, pglob, limitp)
	Char *pathbuf, *pathbuf_last, *pathend, *pathend_last;
	Char *pattern, *pattern_last, *restpattern, *restpattern_last;
	glob_t *pglob;
	size_t *limitp;
d656 1
a656 4
globextend(path, pglob, limitp)
	const Char *path;
	glob_t *pglob;
	size_t *limitp;
d711 1
a711 2
match(name, pat, patend)
	register Char *name, *pat, *patend;
d759 1
a759 2
globfree(pglob)
	glob_t *pglob;
d775 1
a775 3
g_opendir(str, pglob)
	register Char *str;
	glob_t *pglob;
d793 1
a793 4
g_lstat(fn, sb, pglob)
	register Char *fn;
	struct stat *sb;
	glob_t *pglob;
d805 1
a805 4
g_stat(fn, sb, pglob)
	register Char *fn;
	struct stat *sb;
	glob_t *pglob;
d817 1
a817 3
g_strchr(str, ch)
	Char *str;
	int ch;
d827 1
a827 4
g_Ctoc(str, buf, len)
	register const Char *str;
	char *buf;
	u_int len;
d839 1
a839 3
qprintf(str, s)
	const char *str;
	register Char *s;
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d37 1
a37 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.20 2002/06/14 21:34:58 todd Exp $";
d604 1
a604 1
	struct dirent *(*readdirfunc)();
d629 1
a629 1
		readdirfunc = readdir;
@


1.20
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.19 2002/05/24 21:22:37 deraadt Exp $";
@


1.19
log
@try to use strlcpy and snprintf more; ok various
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.18 2002/02/17 19:42:22 millert Exp $";
d670 1
a670 1
 * Extend the gl_pathv member of a glob_t structure to accomodate a new item,
@


1.18
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.17 2002/02/16 21:27:22 millert Exp $";
d815 1
a815 1
		strcpy(buf, ".");
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.16 2001/04/05 18:36:12 deraadt Exp $";
d141 4
a144 4
static int	 glob2 __P((Char *, Char *, Char *, Char *, Char *, Char *,
		    glob_t *, size_t *));
static int	 glob3 __P((Char *, Char *, Char *, Char *, Char *, Char *,
		    Char *, Char *, glob_t *, size_t *));
@


1.16
log
@remove extra continue statements
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.15 2001/04/02 02:30:37 deraadt Exp $";
d133 8
a140 8
static int	 compare __P((const void *, const void *));
static int	 g_Ctoc __P((const Char *, char *, u_int));
static int	 g_lstat __P((Char *, struct stat *, glob_t *));
static DIR	*g_opendir __P((Char *, glob_t *));
static Char	*g_strchr __P((Char *, int));
static int	 g_stat __P((Char *, struct stat *, glob_t *));
static int	 glob0 __P((const Char *, glob_t *));
static int	 glob1 __P((Char *, Char *, glob_t *, size_t *));
d145 1
a145 1
static int	 globextend __P((const Char *, glob_t *, size_t *));
d147 4
a150 4
		 globtilde __P((const Char *, Char *, size_t, glob_t *));
static int	 globexp1 __P((const Char *, glob_t *));
static int	 globexp2 __P((const Char *, const Char *, glob_t *, int *));
static int	 match __P((Char *, Char *, Char *));
d152 1
a152 1
static void	 qprintf __P((const char *, Char *));
d158 1
a158 1
	int flags, (*errfunc) __P((const char *, int));
@


1.15
log
@use a len in g_Ctoc, easier code; freebsd
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.14 2001/03/28 20:54:19 millert Exp $";
d244 1
a244 1
		continue;
d253 1
a253 1
				continue;
d280 1
a280 1
				continue;
d306 2
a307 1
					continue;
d312 2
a313 2
				for (pl = pe + 1; (*lm++ = *pl++) != EOS;)
					continue;
d358 1
a358 1
		continue;
d362 5
d390 1
a390 1
		continue;
d394 1
a394 1
		continue;
d715 1
a715 1
		continue;
@


1.14
log
@Fix some glob defects:
o use MAXPATHLEN, not MAXPATHLEN + 1
o when manipulating static buffers, pass functions a pointer to
  the end of the buffer so we can avoid any overflows

Work by Theo and myself.
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.13 2001/03/28 08:00:00 deraadt Exp $";
d134 1
a134 1
static int	 g_Ctoc __P((const Char *, char *, char *));
d190 1
a190 2
			}
			else
d261 1
a261 2
		}
		else if (*pe == LBRACE)
d372 1
a372 2
	}
	else {
d612 1
a612 1
			if (g_Ctoc(pathbuf, buf, buf+sizeof(buf)))
d713 1
a713 1
		if (g_Ctoc(path, copy, copy+len+1)) {
d811 1
a811 1
		if (g_Ctoc(str, buf, buf+sizeof(buf)))
d829 1
a829 1
	if (g_Ctoc(fn, buf, buf+sizeof(buf)))
d844 1
a844 1
	if (g_Ctoc(fn, buf, buf+sizeof(buf)))
d864 1
a864 1
g_Ctoc(str, buf, ebuf)
d866 2
a867 1
	char *buf, *ebuf;
a868 1
	register char *dc;
d870 5
a874 5
	for (dc = buf; dc < ebuf && (*dc++ = *str++) != EOS;)
		continue;
	if (dc >= ebuf)
		return (1);
	return (0);
@


1.13
log
@must spec +1 in this one case...
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.12 2001/03/28 07:44:59 deraadt Exp $";
d140 5
a144 4
static int	 glob1 __P((Char *, glob_t *, size_t *));
static int	 glob2 __P((Char *, Char *, Char *, glob_t *, size_t *));
static int	 glob3 __P((Char *, Char *, Char *, Char *, glob_t *,
		    size_t *));
d163 1
a163 1
	Char *bufnext, *bufend, patbuf[MAXPATHLEN+1];
d177 1
a177 1
	bufend = bufnext + MAXPATHLEN;
d207 2
a208 1
static int globexp1(pattern, pglob)
d232 2
a233 1
static int globexp2(ptr, pattern, pglob, rv)
d241 1
a241 1
	Char    patbuf[MAXPATHLEN + 1];
d246 1
d412 1
a412 1
	Char *bufnext, patbuf[MAXPATHLEN+1];
d415 1
a415 2
	qpatnext = globtilde(pattern, patbuf, sizeof(patbuf) / sizeof(Char),
	    pglob);
d471 1
a471 1
	if ((err = glob1(patbuf, pglob, &limit)) != 0)
d502 2
a503 2
glob1(pattern, pglob, limitp)
	Char *pattern;
d507 1
a507 1
	Char pathbuf[MAXPATHLEN+1];
d512 3
a514 1
	return(glob2(pathbuf, pathbuf, pattern, pglob, limitp));
d523 4
a526 2
glob2(pathbuf, pathend, pattern, pglob, limitp)
	Char *pathbuf, *pathend, *pattern;
d549 2
d564 2
d572 3
a574 1
			while (*pattern == SEP)
d576 1
d579 3
a581 2
			return(glob3(pathbuf, pathend, pattern, p, pglob,
			    limitp));
d587 4
a590 2
glob3(pathbuf, pathend, pattern, restpattern, pglob, limitp)
	Char *pathbuf, *pathend, *pattern, *restpattern;
d607 2
d638 10
a647 3
		for (sc = (u_char *) dp->d_name, dc = pathend;
		     (*dc++ = *sc++) != EOS;)
			continue;
d652 2
a653 1
		err = glob2(pathbuf, --dc, restpattern, pglob, limitp);
@


1.12
log
@avoid g_Ctoc() overflows; art@@ ok
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.10 2001/03/19 13:45:30 millert Exp $";
d689 1
a689 1
		if (g_Ctoc(path, copy, copy+len)) {
@


1.11
log
@KNF
@
text
@d134 1
a134 1
static void	 g_Ctoc __P((const Char *, char *));
d596 2
a597 1
			g_Ctoc(pathbuf, buf);
d600 1
a600 1
				return (GLOB_ABORTED);
d689 4
a692 1
		g_Ctoc(path, copy);
d727 2
a728 1
			while (*name++ != EOS);
d786 4
a789 2
	else
		g_Ctoc(str, buf);
d805 2
a806 1
	g_Ctoc(fn, buf);
d820 2
a821 1
	g_Ctoc(fn, buf);
d839 2
a840 2
static void
g_Ctoc(str, buf)
d842 1
a842 1
	char *buf;
d846 1
a846 1
	for (dc = buf; (*dc++ = *str++) != EOS;)
d848 3
@


1.10
log
@set gl_pathv to NULL after we free it; christos@@netbsd.org
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.9 2001/03/18 17:18:58 deraadt Exp $";
a137 3
#ifdef notdef
static Char	*g_strcat __P((Char *, const Char *));
#endif
d178 2
a179 2
	    while (bufnext < bufend && (c = *patnext++) != EOS)
		    *bufnext++ = c;
d273 1
a273 1
	for (i = 0, pl = pm = ptr; pm <= pe; pm++)
d294 2
a295 2
			    i--;
			    break;
d326 1
d456 1
a456 1
			    *bufnext++ = M_ALL;
d538 2
a539 2
			    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode)
			    || (S_ISLNK(sb.st_mode) &&
d563 2
a564 1
		} else			/* Need expansion, recurse. */
a828 18

#ifdef notdef
static Char *
g_strcat(dst, src)
	Char *dst;
	const Char* src;
{
	Char *sdst = dst;

	while (*dst++)
		continue;
	--dst;
	while((*dst++ = *src++) != EOS)
		continue;

	return (sdst);
}
#endif
@


1.9
log
@GLOB_LIMIT changes from christos
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.8 1998/08/14 21:39:30 deraadt Exp $";
d669 1
a669 1
		if (pglob->gl_pathv)
d671 2
d769 1
@


1.8
log
@realloc repair
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.7 1998/01/31 17:06:27 millert Exp $";
d143 7
a149 5
static int	 glob1 __P((Char *, glob_t *));
static int	 glob2 __P((Char *, Char *, Char *, glob_t *));
static int	 glob3 __P((Char *, Char *, Char *, Char *, glob_t *));
static int	 globextend __P((const Char *, glob_t *));
static const Char *	globtilde __P((const Char *, Char *, size_t, glob_t *));
d411 1
d470 1
a470 1
	if ((err = glob1(patbuf, pglob)) != 0)
d483 1
a483 1
			return(globextend(pattern, pglob));
d501 1
a501 1
glob1(pattern, pglob)
d504 1
d511 1
a511 1
	return(glob2(pathbuf, pathbuf, pattern, pglob));
d520 1
a520 1
glob2(pathbuf, pathend, pattern, pglob)
d523 1
d548 1
a548 1
			return(globextend(pathbuf, pglob));
d566 2
a567 1
			return(glob3(pathbuf, pathend, pattern, p, pglob));
d573 1
a573 1
glob3(pathbuf, pathend, pattern, restpattern, pglob)
d576 1
d626 1
a626 1
		err = glob2(pathbuf, --dc, restpattern, pglob);
d654 1
a654 1
globextend(path, pglob)
d657 1
d661 1
a661 1
	u_int newsize;
d666 2
a667 3
	pathv = pglob->gl_pathv ?
		    realloc((char *)pglob->gl_pathv, newsize) :
		    malloc(newsize);
d684 3
a686 1
	if ((copy = malloc(p - path)) != NULL) {
d691 7
d840 1
a840 1
	    continue;
@


1.8.10.1
log
@Pull in patches from current:
Errata 025:
glob(3) contains multiple buffer overflows.
Fix (deraadt,millert)
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.16 2001/04/05 18:36:12 deraadt Exp $";
d134 1
a134 1
static int	 g_Ctoc __P((const Char *, char *, u_int));
d138 3
d143 5
a147 8
static int	 glob1 __P((Char *, Char *, glob_t *, size_t *));
static int	 glob2 __P((Char *, Char *, Char *, Char *, Char *, Char *,
		    glob_t *, size_t *));
static int	 glob3 __P((Char *, Char *, Char *, Char *, Char *, Char *,
		    Char *, Char *, glob_t *, size_t *));
static int	 globextend __P((const Char *, glob_t *, size_t *));
static const Char *
		 globtilde __P((const Char *, Char *, size_t, glob_t *));
d163 1
a163 1
	Char *bufnext, *bufend, patbuf[MAXPATHLEN];
d177 1
a177 1
	bufend = bufnext + MAXPATHLEN - 1;
d179 2
a180 2
		while (bufnext < bufend && (c = *patnext++) != EOS)
			*bufnext++ = c;
d190 2
a191 1
			} else
d207 1
a207 2
static int
globexp1(pattern, pglob)
d231 1
a231 2
static int
globexp2(ptr, pattern, pglob, rv)
d239 1
a239 1
	Char    patbuf[MAXPATHLEN];
d243 1
a243 2
		;
	*lm = EOS;
d251 1
a251 1
				;
d259 2
a260 1
		} else if (*pe == LBRACE)
d274 1
a274 1
	for (i = 0, pl = pm = ptr; pm <= pe; pm++) {
d279 1
a279 1
				;
d295 2
a296 2
				i--;
				break;
d305 1
a305 2
					;

d310 2
a311 2
				for (pl = pe + 1; (*lm++ = *pl++) != EOS; )
					;
a326 1
	}
d355 1
a355 1
		;
a358 5
#if 0
	if (h == (char *)eb)
		return what;
#endif

d370 2
a371 1
	} else {
d383 1
a383 1
		;
d387 1
a387 1
		;
d408 1
a408 2
	Char *bufnext, patbuf[MAXPATHLEN];
	size_t limit = 0;
d410 2
a411 1
	qpatnext = globtilde(pattern, patbuf, MAXPATHLEN, pglob);
d455 1
a455 1
				*bufnext++ = M_ALL;
d467 1
a467 1
	if ((err = glob1(patbuf, patbuf+MAXPATHLEN-1, pglob, &limit)) != 0)
d480 1
a480 1
			return(globextend(pattern, pglob, &limit));
d498 2
a499 2
glob1(pattern, pattern_last, pglob, limitp)
	Char *pattern, *pattern_last;
a500 1
	size_t *limitp;
d502 1
a502 1
	Char pathbuf[MAXPATHLEN];
d507 1
a507 3
	return(glob2(pathbuf, pathbuf+MAXPATHLEN-1,
	    pathbuf, pathbuf+MAXPATHLEN-1,
	    pattern, pattern_last, pglob, limitp));
d516 2
a517 4
glob2(pathbuf, pathbuf_last, pathend, pathend_last, pattern,
    pattern_last, pglob, limitp)
	Char *pathbuf, *pathbuf_last, *pathend, *pathend_last;
	Char *pattern, *pattern_last;
a518 1
	size_t *limitp;
d535 2
a536 2
			    pathend[-1] != SEP) && (S_ISDIR(sb.st_mode) ||
			    (S_ISLNK(sb.st_mode) &&
a538 2
				if (pathend+1 > pathend_last)
					return (1);
d543 1
a543 1
			return(globextend(pathbuf, pglob, limitp));
a551 2
			if (q+1 > pathend_last)
				return (1);
d558 1
a558 3
			while (*pattern == SEP) {
				if (pathend+1 > pathend_last)
					return (1);
d560 2
a561 6
			}
		} else
			/* Need expansion, recurse. */
			return(glob3(pathbuf, pathbuf_last, pathend,
			    pathend_last, pattern, pattern_last,
			    p, pattern_last, pglob, limitp));
d567 2
a568 4
glob3(pathbuf, pathbuf_last, pathend, pathend_last, pattern, pattern_last,
    restpattern, restpattern_last, pglob, limitp)
	Char *pathbuf, *pathbuf_last, *pathend, *pathend_last;
	Char *pattern, *pattern_last, *restpattern, *restpattern_last;
a569 1
	size_t *limitp;
a583 2
	if (pathend > pathend_last)
		return (1);
d590 1
a590 2
			if (g_Ctoc(pathbuf, buf, sizeof(buf)))
				return(GLOB_ABORTED);
d593 1
a593 1
				return(GLOB_ABORTED);
d612 3
a614 10
		dc = pathend;
		sc = (u_char *) dp->d_name;
		while (dc < pathend_last && (*dc++ = *sc++) != EOS)
			;
		if (dc >= pathend_last) {
			*dc = EOS;
			err = 1;
			break;
		}

d619 1
a619 2
		err = glob2(pathbuf, pathbuf_last, --dc, pathend_last,
		    restpattern, restpattern_last, pglob, limitp);
d647 1
a647 1
globextend(path, pglob, limitp)
a649 1
	size_t *limitp;
d653 1
a653 1
	u_int newsize, len;
d658 3
a660 2
	pathv = pglob->gl_pathv ? realloc((char *)pglob->gl_pathv, newsize) :
	    malloc(newsize);
d662 1
a662 1
		if (pglob->gl_pathv) {
a663 2
			pglob->gl_pathv = NULL;
		}
d676 3
a678 8
		;
	len = (size_t)(p - path);
	*limitp += len;
	if ((copy = malloc(len)) != NULL) {
		if (g_Ctoc(path, copy, len)) {
			free(copy);
			return(GLOB_NOSPACE);
		}
a681 7

	if ((pglob->gl_flags & GLOB_LIMIT) &&
	    newsize + *limitp >= ARG_MAX) {
		errno = 0;
		return(GLOB_NOSPACE);
	}

d706 1
a706 2
			while (*name++ != EOS)
				;
a750 1
		pglob->gl_pathv = NULL;
d763 2
a764 4
	else {
		if (g_Ctoc(str, buf, sizeof(buf)))
			return(NULL);
	}
d780 1
a780 2
	if (g_Ctoc(fn, buf, sizeof(buf)))
		return(-1);
d794 1
a794 2
	if (g_Ctoc(fn, buf, sizeof(buf)))
		return(-1);
d812 20
a831 2
static int
g_Ctoc(str, buf, len)
a833 1
	u_int len;
d835 1
d837 2
a838 5
	while (len--) {
		if ((*buf++ = *str++) == EOS)
			return (0);
	}
	return (1);
@


1.7
log
@Add GLOB_NOESCAPE to turn off backslash escaping and make backslash escaping
the default.  For xpg4.2.
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.6 1997/09/01 18:40:33 millert Exp $";
d661 3
a663 1
	if (pathv == NULL)
d665 1
@


1.6
log
@Make glob(3) XPG4.2 compliant.  This means changing GLOB_ABEND to
GLOB_ABORT and defining GLOB_NOMATCH and GLOB_NOSYS (the latter is
not used).
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.5 1997/04/12 19:05:48 millert Exp $";
d178 4
a181 1
	if (flags & GLOB_QUOTE) {
a193 3
	else
	    while (bufnext < bufend && (c = *patnext++) != EOS)
		    *bufnext++ = c;
@


1.5
log
@Different fix for buffer overflow.  From Keith Bostic <bostic@@bostic.com>
@
text
@d41 1
a41 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.4 1996/10/27 17:46:40 deraadt Exp $";
d197 1
a197 1
	    return globexp1(patbuf, pglob);
d199 1
a199 1
	    return glob0(patbuf, pglob);
d476 9
a484 6
	if (pglob->gl_pathc == oldpathc &&
	    ((pglob->gl_flags & GLOB_NOCHECK) ||
	      ((pglob->gl_flags & GLOB_NOMAGIC) &&
	       !(pglob->gl_flags & GLOB_MAGCHAR))))
		return(globextend(pattern, pglob));
	else if (!(pglob->gl_flags & GLOB_NOSORT))
d593 1
a593 1
				return (GLOB_ABEND);
d681 1
@


1.4
log
@be careful in the non-setuid case too, what the heck
@
text
@d38 5
a42 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.3 1996/09/11 19:22:46 deraadt Exp $";
d65 1
a65 1
 *	expand {1,2}{a,b} to 1a 1b 2a 2b 
d147 1
a147 1
static const Char *	 globtilde __P((const Char *, Char *, glob_t *));
d180 1
a180 1
		while (bufnext < bufend && (c = *patnext++) != EOS) 
d191 2
a192 2
	else 
	    while (bufnext < bufend && (c = *patnext++) != EOS) 
d253 1
a253 1
				/* 
d281 1
a281 1
				/* 
d306 1
a306 1
				/* 
d337 1
a337 1
globtilde(pattern, patbuf, pglob)
d340 1
d346 1
a346 1
	Char *b;
d352 3
a354 2
	for (p = pattern + 1, h = (char *) patbuf; *p && *p != SLASH; 
	     *h++ = *p++)
d360 2
a361 2
		/* 
		 * handle a plain ~ or ~/ by expanding $HOME 
a368 3
		} else {
			if (strlen(h) >= MAXPATHLEN-1)
				return pattern;
d382 1
a382 1
	for (b = patbuf; *h; *b++ = *h++)
d384 1
a384 1
	
d386 1
a386 1
	while ((*b++ = *p++) != EOS)
d388 1
d392 1
a392 1
	
d410 2
a411 1
	qpatnext = globtilde(pattern, patbuf, pglob);
d451 1
a451 1
			/* collapse adjacent stars to one, 
d471 1
a471 1
	 * If there was no match we are going to append the pattern 
d476 2
a477 2
	if (pglob->gl_pathc == oldpathc && 
	    ((pglob->gl_flags & GLOB_NOCHECK) || 
d481 1
a481 1
	else if (!(pglob->gl_flags & GLOB_NOSORT)) 
d530 1
a530 1
		
d583 1
a583 1
	    
d609 1
a609 1
		for (sc = (u_char *) dp->d_name, dc = pathend; 
d655 1
a655 1
	pathv = pglob->gl_pathv ? 
a678 1

d696 1
a696 1
			do 
d835 1
a835 1
static void 
@


1.3
log
@protect $HOME expansion; from das33@@cornell.edu
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.2 1996/08/19 08:24:20 tholo Exp $";
d363 3
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: glob.c,v 1.5 1995/02/27 04:13:35 cgd Exp $";
d358 1
a358 1
		if ((h = getenv("HOME")) == NULL) {
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: glob.c,v 1.5 1995/02/27 04:13:35 cgd Exp $	*/

d38 1
a38 5
#if 0
static char sccsid[] = "@@(#)glob.c	8.3 (Berkeley) 10/13/93";
#else
static char rcsid[] = "$NetBSD: glob.c,v 1.5 1995/02/27 04:13:35 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
