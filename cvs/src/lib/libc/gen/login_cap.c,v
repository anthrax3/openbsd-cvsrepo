head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.2
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.30.0.8
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.24
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.20
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.18
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.16
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.14
	OPENBSD_5_0:1.29.0.12
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.10
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.8
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.4
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.26.0.6
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.4
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.34
date	2016.03.10.18.30.53;	author mmcc;	state Exp;
branches;
next	1.33;
commitid	D5v3u5QFRsHc6xzf;

1.33
date	2015.12.28.22.08.18;	author mmcc;	state Exp;
branches;
next	1.32;
commitid	0uXuF2O13NH9q2e1;

1.32
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.31;
commitid	iWfSX2BIn0sLw62l;

1.31
date	2015.09.13.19.58.50;	author guenther;	state Exp;
branches;
next	1.30;
commitid	eDz8lDJvEPdUcxFf;

1.30
date	2014.04.01.02.16.37;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.02.16.01.58;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.17.07.07.23;	author moritz;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.02.15.19.16;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.09.04.40.35;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.04.20.36.40;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.16.06.24.41;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.10.15.53.31;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.09.21.15.09;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.07.17.33.58;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.07.01.09.40;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.24.20.31.00;	author avsm;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.25.21.16.47;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.31.15.47.03;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.15.13.27.06;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.22.19.47.03;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.09.20.36.19;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.27.10.21.35;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.23.03.03.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.29.08.08.57;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.28.07.05.03;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.23.19.04.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.30.16.56.00;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.04.15.31.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.10.15.33.03;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.16.18.06.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.24.17.03.47;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.20.18.37.20;	author millert;	state Exp;
branches;
next	;


desc
@@


1.34
log
@ANSIfy function declarations, move initializations to declaration block

ok millert@@
@
text
@/*	$OpenBSD: login_cap.c,v 1.33 2015/12/28 22:08:18 mmcc Exp $	*/

/*
 * Copyright (c) 2000-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*-
 * Copyright (c) 1995,1997 Berkeley Software Design, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Berkeley Software Design,
 *	Inc.
 * 4. The name of Berkeley Software Design, Inc.  may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI $From: login_cap.c,v 2.16 2000/03/22 17:10:55 donn Exp $
 */
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <login_cap.h>
#include <paths.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>


static	char *_authtypes[] = { LOGIN_DEFSTYLE, 0 };
static	char *expandstr(const char *, const struct passwd *, int);
static	int login_setenv(char *, char *, const struct passwd *, int);
static	int setuserenv(login_cap_t *, const struct passwd *);
static	int setuserpath(login_cap_t *, const struct passwd *);
static	u_quad_t multiply(u_quad_t, u_quad_t);
static	u_quad_t strtolimit(char *, char **, int);
static	u_quad_t strtosize(char *, char **, int);
static	int gsetrl(login_cap_t *, int, char *, int);

login_cap_t *
login_getclass(char *class)
{
	char *classfiles[2] = {NULL, NULL};
	login_cap_t *lc;
	int res;

	if (secure_path(_PATH_LOGIN_CONF) == 0)
		classfiles[0] = _PATH_LOGIN_CONF;

	if ((lc = malloc(sizeof(login_cap_t))) == NULL) {
		syslog(LOG_ERR, "%s:%d malloc: %m", __FILE__, __LINE__);
		return (0);
	}

	lc->lc_cap = 0;
	lc->lc_style = 0;

	if (class == NULL || class[0] == '\0')
		class = LOGIN_DEFCLASS;

    	if ((lc->lc_class = strdup(class)) == NULL) {
		syslog(LOG_ERR, "%s:%d strdup: %m", __FILE__, __LINE__);
		free(lc);
		return (0);
	}

	/*
	 * Not having a login.conf file is not an error condition.
	 * The individual routines deal reasonably with missing
	 * capabilities and use default values.
	 */
	if (classfiles[0] == NULL)
		return(lc);

	if ((res = cgetent(&lc->lc_cap, classfiles, lc->lc_class)) != 0) {
		lc->lc_cap = 0;
		switch (res) {
		case 1: 
			syslog(LOG_ERR, "%s: couldn't resolve 'tc'",
				lc->lc_class);
			break;
		case -1:
			if ((res = open(classfiles[0], 0)) >= 0)
				close(res);
			if (strcmp(lc->lc_class, LOGIN_DEFCLASS) == 0 &&
			    res < 0)
				return (lc);
			syslog(LOG_ERR, "%s: unknown class", lc->lc_class);
			break;
		case -2:
			syslog(LOG_ERR, "%s: getting class information: %m",
				lc->lc_class);
			break;
		case -3:
			syslog(LOG_ERR, "%s: 'tc' reference loop",
				lc->lc_class);
			break;
		default:
			syslog(LOG_ERR, "%s: unexpected cgetent error",
				lc->lc_class);
			break;
		}
		free(lc->lc_class);
		free(lc);
		return (0);
	}
	return (lc);
}
DEF_WEAK(login_getclass);

char *
login_getstyle(login_cap_t *lc, char *style, char *atype)
{
    	char **authtypes = _authtypes;
	char *auths, *ta;
    	char *f1 = NULL, **f2 = NULL;
	int i;

	/* Silently convert 's/key' -> 'skey' */
	if (style && strcmp(style, "s/key") == 0)
		style = "skey";

	free(lc->lc_style);
	lc->lc_style = NULL;

    	if (!atype || !(auths = login_getcapstr(lc, atype, NULL, NULL)))
		auths = login_getcapstr(lc, "auth", NULL, NULL);

	if (auths) {
		f1 = ta = auths;	/* auths malloced by login_getcapstr */
		i = 2;
		while (*ta)
			if (*ta++ == ',')
				++i;
		f2 = authtypes = calloc(sizeof(char *), i);
		if (!authtypes) {
			syslog(LOG_ERR, "malloc: %m");
			free(f1);
			return (0);
		}
		i = 0;
		while (*auths) {
			authtypes[i] = auths;
			while (*auths && *auths != ',')
				++auths;
			if (*auths)
				*auths++ = 0;
			if (!*authtypes[i])
				authtypes[i] = LOGIN_DEFSTYLE;
			++i;
		}
		authtypes[i] = 0;
	}

	if (!style)
		style = authtypes[0];
		
	while (*authtypes && strcmp(style, *authtypes))
		++authtypes;

	if (*authtypes) {
		lc->lc_style = strdup(*authtypes);
		if (lc->lc_style == NULL)
			syslog(LOG_ERR, "strdup: %m");
	}
	free(f1);
	free(f2);
	return (lc->lc_style);
}
DEF_WEAK(login_getstyle);

char *
login_getcapstr(login_cap_t *lc, char *cap, char *def, char *e)
{
	char *res = NULL, *str = e;
	int stat;

	errno = 0;

    	if (!lc->lc_cap)
		return (def);

	switch (stat = cgetstr(lc->lc_cap, cap, &res)) {
	case -1:
		str = def;
		break;
	case -2:
		syslog(LOG_ERR, "%s: getting capability %s: %m",
		    lc->lc_class, cap);
		break;
	default:
		if (stat >= 0)
			str = res;
		else
			syslog(LOG_ERR,
			    "%s: unexpected error with capability %s",
			    lc->lc_class, cap);
		break;
	}

	if (res != NULL && str != res)
		free(res);
	return(str);
}
DEF_WEAK(login_getcapstr);

quad_t
login_getcaptime(login_cap_t *lc, char *cap, quad_t def, quad_t e)
{
	char *ep;
	char *res = NULL, *sres;
	int stat;
	quad_t q, r;

	errno = 0;

    	if (!lc->lc_cap)
		return (def);

	switch (stat = cgetstr(lc->lc_cap, cap, &res)) {
	case -1:
		free(res);
		return (def);
	case -2:
		free(res);
		syslog(LOG_ERR, "%s: getting capability %s: %m",
		    lc->lc_class, cap);
		errno = ERANGE;
		return (e);
	default:
		if (stat >= 0) 
			break;
		free(res);
		syslog(LOG_ERR, "%s: unexpected error with capability %s",
		    lc->lc_class, cap);
		errno = ERANGE;
		return (e);
	}

	errno = 0;

	if (strcasecmp(res, "infinity") == 0) {
		free(res);
		return (RLIM_INFINITY);
	}

	q = 0;
	sres = res;
	while (*res) {
		r = strtoll(res, &ep, 0);
		if (!ep || ep == res ||
		    ((r == QUAD_MIN || r == QUAD_MAX) && errno == ERANGE)) {
invalid:
			syslog(LOG_ERR, "%s:%s=%s: invalid time",
			    lc->lc_class, cap, sres);
			free(sres);
			errno = ERANGE;
			return (e);
		}
		switch (*ep++) {
		case '\0':
			--ep;
			break;
		case 's': case 'S':
			break;
		case 'm': case 'M':
			r *= 60;
			break;
		case 'h': case 'H':
			r *= 60 * 60;
			break;
		case 'd': case 'D':
			r *= 60 * 60 * 24;
			break;
		case 'w': case 'W':
			r *= 60 * 60 * 24 * 7;
			break;
		case 'y': case 'Y':	/* Pretty absurd */
			r *= 60 * 60 * 24 * 365;
			break;
		default:
			goto invalid;
		}
		res = ep;
		q += r;
	}
	free(sres);
	return (q);
}
DEF_WEAK(login_getcaptime);

quad_t
login_getcapnum(login_cap_t *lc, char *cap, quad_t def, quad_t e)
{
	char *ep;
	char *res = NULL;
	int stat;
	quad_t q;

	errno = 0;

    	if (!lc->lc_cap)
		return (def);

	switch (stat = cgetstr(lc->lc_cap, cap, &res)) {
	case -1:
		free(res);
		return (def);
	case -2:
		free(res);
		syslog(LOG_ERR, "%s: getting capability %s: %m",
		    lc->lc_class, cap);
		errno = ERANGE;
		return (e);
	default:
		if (stat >= 0) 
			break;
		free(res);
		syslog(LOG_ERR, "%s: unexpected error with capability %s",
		    lc->lc_class, cap);
		errno = ERANGE;
		return (e);
	}

	errno = 0;

	if (strcasecmp(res, "infinity") == 0) {
		free(res);
		return (RLIM_INFINITY);
	}

    	q = strtoll(res, &ep, 0);
	if (!ep || ep == res || ep[0] ||
	    ((q == QUAD_MIN || q == QUAD_MAX) && errno == ERANGE)) {
		syslog(LOG_ERR, "%s:%s=%s: invalid number",
		    lc->lc_class, cap, res);
		free(res);
		errno = ERANGE;
		return (e);
	}
	free(res);
	return (q);
}
DEF_WEAK(login_getcapnum);

quad_t
login_getcapsize(login_cap_t *lc, char *cap, quad_t def, quad_t e)
{
	char *ep;
	char *res = NULL;
	int stat;
	quad_t q;

	errno = 0;

    	if (!lc->lc_cap)
		return (def);

	switch (stat = cgetstr(lc->lc_cap, cap, &res)) {
	case -1:
		free(res);
		return (def);
	case -2:
		free(res);
		syslog(LOG_ERR, "%s: getting capability %s: %m",
		    lc->lc_class, cap);
		errno = ERANGE;
		return (e);
	default:
		if (stat >= 0) 
			break;
		free(res);
		syslog(LOG_ERR, "%s: unexpected error with capability %s",
		    lc->lc_class, cap);
		errno = ERANGE;
		return (e);
	}

	errno = 0;
	q = strtolimit(res, &ep, 0);
	if (!ep || ep == res || (ep[0] && ep[1]) ||
	    ((q == QUAD_MIN || q == QUAD_MAX) && errno == ERANGE)) {
		syslog(LOG_ERR, "%s:%s=%s: invalid size",
		    lc->lc_class, cap, res);
		free(res);
		errno = ERANGE;
		return (e);
	}
	free(res);
	return (q);
}
DEF_WEAK(login_getcapsize);

int
login_getcapbool(login_cap_t *lc, char *cap, u_int def)
{
    	if (!lc->lc_cap)
		return (def);

	return (cgetcap(lc->lc_cap, cap, ':') != NULL);
}
DEF_WEAK(login_getcapbool);

void
login_close(login_cap_t *lc)
{
	if (lc) {
		free(lc->lc_class);
		free(lc->lc_cap);
		free(lc->lc_style);
		free(lc);
	}
}
DEF_WEAK(login_close);

#define	CTIME	1
#define	CSIZE	2
#define	CNUMB	3

static struct {
	int	what;
	int	type;
	char *	name;
} r_list[] = {
	{ RLIMIT_CPU,		CTIME, "cputime", },
	{ RLIMIT_FSIZE,		CSIZE, "filesize", },
	{ RLIMIT_DATA,		CSIZE, "datasize", },
	{ RLIMIT_STACK,		CSIZE, "stacksize", },
	{ RLIMIT_RSS,		CSIZE, "memoryuse", },
	{ RLIMIT_MEMLOCK,	CSIZE, "memorylocked", },
	{ RLIMIT_NPROC,		CNUMB, "maxproc", },
	{ RLIMIT_NOFILE,	CNUMB, "openfiles", },
	{ RLIMIT_CORE,		CSIZE, "coredumpsize", },
#ifdef RLIMIT_VMEM
	{ RLIMIT_VMEM,		CSIZE, "vmemoryuse", },
#endif
	{ -1, 0, 0 }
};

static int
gsetrl(login_cap_t *lc, int what, char *name, int type)
{
	struct rlimit rl;
	struct rlimit r;
	char name_cur[32];
	char name_max[32];
    	char *v;
	int len;

	/*
	 * If we have no capabilities then there is nothing to do and
	 * we can just return success.
	 */
	if (lc->lc_cap == NULL)
		return (0);

	len = snprintf(name_cur, sizeof name_cur, "%s-cur", name);
	if (len < 0 || len >= sizeof name_cur) {
		syslog(LOG_ERR, "current resource limit name too large");
		return (-1);
	}
	len = snprintf(name_max, sizeof name_max, "%s-max", name);
	if (len < 0 || len >= sizeof name_max) {
		syslog(LOG_ERR, "max resource limit name too large");
		return (-1);
	}

	if (getrlimit(what, &r)) {
		syslog(LOG_ERR, "getting resource limit: %m");
		return (-1);
	}

	/*
	 * We need to pre-fetch the 3 possible strings we will look
	 * up to see what order they come in.  If the one without
	 * the -cur or -max comes in first then we ignore any later
	 * -cur or -max entries.
	 * Note that the cgetent routines will always return failure
	 * on the entry "".  This will cause our login_get* routines
	 * to use the default entry.
	 */
	if ((v = cgetcap(lc->lc_cap, name, '=')) != NULL) {
		if (v < cgetcap(lc->lc_cap, name_cur, '='))
			name_cur[0] = '\0';
		if (v < cgetcap(lc->lc_cap, name_max, '='))
			name_max[0] = '\0';
	}

#define	RCUR	r.rlim_cur
#define	RMAX	r.rlim_max

	switch (type) {
	case CTIME:
		RCUR = (rlim_t)login_getcaptime(lc, name, RCUR, RCUR);
		RMAX = (rlim_t)login_getcaptime(lc, name, RMAX, RMAX);
		rl.rlim_cur = (rlim_t)login_getcaptime(lc, name_cur, RCUR, RCUR);
		rl.rlim_max = (rlim_t)login_getcaptime(lc, name_max, RMAX, RMAX);
		break;
	case CSIZE:
		RCUR = (rlim_t)login_getcapsize(lc, name, RCUR, RCUR);
		RMAX = (rlim_t)login_getcapsize(lc, name, RMAX, RMAX);
		rl.rlim_cur = (rlim_t)login_getcapsize(lc, name_cur, RCUR, RCUR);
		rl.rlim_max = (rlim_t)login_getcapsize(lc, name_max, RMAX, RMAX);
		break;
	case CNUMB:
		RCUR = (rlim_t)login_getcapnum(lc, name, RCUR, RCUR);
		RMAX = (rlim_t)login_getcapnum(lc, name, RMAX, RMAX);
		rl.rlim_cur = (rlim_t)login_getcapnum(lc, name_cur, RCUR, RCUR);
		rl.rlim_max = (rlim_t)login_getcapnum(lc, name_max, RMAX, RMAX);
		break;
	default:
		return (-1);
	}

	if (setrlimit(what, &rl)) {
		syslog(LOG_ERR, "%s: setting resource limit %s: %m",
		    lc->lc_class, name);
		return (-1);
	}
#undef	RCUR
#undef	RMAX
	return (0);
}

int
setclasscontext(char *class, u_int flags)
{
	int ret;
	login_cap_t *lc;

	flags &= LOGIN_SETRESOURCES | LOGIN_SETPRIORITY | LOGIN_SETUMASK |
	    LOGIN_SETPATH;

	lc = login_getclass(class);
	ret = lc ? setusercontext(lc, NULL, 0, flags) : -1;
	login_close(lc);
	return (ret);
}

int
setusercontext(login_cap_t *lc, struct passwd *pwd, uid_t uid, u_int flags)
{
	login_cap_t *flc;
	quad_t p;
	int i;

	flc = NULL;

	if (!lc && !(flc = lc = login_getclass(pwd ? pwd->pw_class : NULL)))
		return (-1);

	/*
	 * Without the pwd entry being passed we cannot set either
	 * the group or the login.  We could complain about it.
	 */
	if (pwd == NULL)
		flags &= ~(LOGIN_SETGROUP|LOGIN_SETLOGIN);

	if (flags & LOGIN_SETRESOURCES)
		for (i = 0; r_list[i].name; ++i) 
			if (gsetrl(lc, r_list[i].what, r_list[i].name,
			    r_list[i].type))
				/* XXX - call syslog()? */;

	if (flags & LOGIN_SETPRIORITY) {
		p = login_getcapnum(lc, "priority", 0, 0);

		if (setpriority(PRIO_PROCESS, 0, (int)p) < 0)
			syslog(LOG_ERR, "%s: setpriority: %m", lc->lc_class);
	}

	if (flags & LOGIN_SETUMASK) {
		p = login_getcapnum(lc, "umask", LOGIN_DEFUMASK,LOGIN_DEFUMASK);
		umask((mode_t)p);
	}

	if (flags & LOGIN_SETGROUP) {
		if (setresgid(pwd->pw_gid, pwd->pw_gid, pwd->pw_gid) < 0) {
			syslog(LOG_ERR, "setresgid(%u,%u,%u): %m",
			    pwd->pw_gid, pwd->pw_gid, pwd->pw_gid);
			login_close(flc);
			return (-1);
		}

		if (initgroups(pwd->pw_name, pwd->pw_gid) < 0) {
			syslog(LOG_ERR, "initgroups(%s,%u): %m",
			    pwd->pw_name, pwd->pw_gid);
			login_close(flc);
			return (-1);
		}
	}

	if (flags & LOGIN_SETLOGIN)
		if (setlogin(pwd->pw_name) < 0) {
			syslog(LOG_ERR, "setlogin(%s) failure: %m",
			    pwd->pw_name);
			login_close(flc);
			return (-1);
		}

	if (flags & LOGIN_SETUSER) {
		if (setresuid(uid, uid, uid) < 0) {
			syslog(LOG_ERR, "setresuid(%u,%u,%u): %m",
			    uid, uid, uid);
			login_close(flc);
			return (-1);
		}
	}

	if (flags & LOGIN_SETENV) {
		if (setuserenv(lc, pwd) == -1) {
			syslog(LOG_ERR, "could not set user environment: %m");
			login_close(flc);
			return (-1);
		}
	}

	if (flags & LOGIN_SETPATH) {
		if (setuserpath(lc, pwd) == -1) {
			syslog(LOG_ERR, "could not set PATH: %m");
			login_close(flc);
			return (-1);
		}
	}

	login_close(flc);
	return (0);
}
DEF_WEAK(setusercontext);

/*
 * Look up "path" for this user in login.conf and replace whitespace
 * with ':' while expanding '~' and '$'.  Sets the PATH environment
 * variable to the result or _PATH_DEFPATH on error.
 */
static int
setuserpath(login_cap_t *lc, const struct passwd *pwd)
{
	char *path = NULL, *opath = NULL, *op, *np;
	int len, error;

	if (lc->lc_cap == NULL)
		goto setit;		/* impossible */

	if ((len = cgetustr(lc->lc_cap, "path", &opath)) <= 0)
		goto setit;

	if ((path = malloc(len + 1)) == NULL)
		goto setit;

	/* Convert opath from space-separated to colon-separated path. */
	for (op = opath, np = path; *op != '\0'; ) {
		switch (*op) {
		case ' ':
		case '\t':
			/*
			 * Collapse consecutive spaces and trim any space
			 * at the very end.
			 */
			do {
				op++;
			} while (*op == ' ' || *op == '\t');
			if (*op != '\0')
				*np++ = ':';
			break;
		case '\\':
			/* check for escaped whitespace */
			if (*(op + 1) == ' ' || *(op + 1) == '\t')
				*np++ = *op++;
			/* FALLTHROUGH */
		default:
			*np++ = *op++;
			break;
		}
		
	}
	*np = '\0';
setit:
	error = login_setenv("PATH", path ? path : _PATH_DEFPATH, pwd, 1);
	free(opath);
	free(path);
	return (error);
}

/*
 * Look up "setenv" for this user in login.conf and set the comma-separated
 * list of environment variables, expanding '~' and '$'.
 */
static int
setuserenv(login_cap_t *lc, const struct passwd *pwd)
{
	char *beg, *end, *ep, *list, *value;
	int len, error;

	if (lc->lc_cap == NULL)
		return (-1);		/* impossible */

	if ((len = cgetustr(lc->lc_cap, "setenv", &list)) <= 0)
		return (0);

	for (beg = end = list, ep = list + len + 1; end < ep; end++) {
		switch (*end) {
		case '\\':
			if (*(end + 1) == ',')
				end++;	/* skip escaped comma */
			continue;
		case ',':
		case '\0':
			*end = '\0';
			if (beg == end) {
				beg++;
				continue;
			}
			break;
		default:
			continue;
		}

		if ((value = strchr(beg, '=')) != NULL)
			*value++ = '\0';
		else
			value = "";
		if ((error = login_setenv(beg, value, pwd, 0)) != 0) {
			free(list);
			return (error);
		}
		beg = end + 1;
	}
	free(list);
	return (0);
}

/*
 * Set an environment variable, substituting for ~ and $
 */
static int
login_setenv(char *name, char *ovalue, const struct passwd *pwd, int ispath)
{
	char *value = NULL;
	int error;

	if (*ovalue != '\0')
		value = expandstr(ovalue, pwd, ispath);
	error = setenv(name, value ? value : ovalue, 1);
	free(value);
	return (error);
}

/*
 * Convert an expression of the following forms
 * 	1) A number.
 *	2) A number followed by a b (mult by 512).
 *	3) A number followed by a k (mult by 1024).
 *	5) A number followed by a m (mult by 1024 * 1024).
 *	6) A number followed by a g (mult by 1024 * 1024 * 1024).
 *	7) A number followed by a t (mult by 1024 * 1024 * 1024 * 1024).
 *	8) Two or more numbers (with/without k,b,m,g, or t).
 *	   separated by x (also * for backwards compatibility), specifying
 *	   the product of the indicated values.
 */
static
u_quad_t
strtosize(char *str, char **endptr, int radix)
{
	u_quad_t num, num2;
	char *expr, *expr2;

	errno = 0;
	num = strtoull(str, &expr, radix);
	if (errno || expr == str) {
		if (endptr)
			*endptr = expr;
		return (num);
	}

	switch(*expr) {
	case 'b': case 'B':
		num = multiply(num, (u_quad_t)512);
		++expr;
		break;
	case 'k': case 'K':
		num = multiply(num, (u_quad_t)1024);
		++expr;
		break;
	case 'm': case 'M':
		num = multiply(num, (u_quad_t)1024 * 1024);
		++expr;
		break;
	case 'g': case 'G':
		num = multiply(num, (u_quad_t)1024 * 1024 * 1024);
		++expr;
		break;
	case 't': case 'T':
		num = multiply(num, (u_quad_t)1024 * 1024);
		num = multiply(num, (u_quad_t)1024 * 1024);
		++expr;
		break;
	}

	if (errno)
		goto erange;

	switch(*expr) {
	case '*':			/* Backward compatible. */
	case 'x':
		num2 = strtosize(expr+1, &expr2, radix);
		if (errno) {
			expr = expr2;
			goto erange;
		}

		if (expr2 == expr + 1) {
			if (endptr)
				*endptr = expr;
			return (num);
		}
		expr = expr2;
		num = multiply(num, num2);
		if (errno)
			goto erange;
		break;
	}
	if (endptr)
		*endptr = expr;
	return (num);
erange:
	if (endptr)
		*endptr = expr;
	errno = ERANGE;
	return (UQUAD_MAX);
}

static
u_quad_t
strtolimit(char *str, char **endptr, int radix)
{
	if (strcasecmp(str, "infinity") == 0 || strcasecmp(str, "inf") == 0) {
		if (endptr)
			*endptr = str + strlen(str);
		return ((u_quad_t)RLIM_INFINITY);
	}
	return (strtosize(str, endptr, radix));
}

static u_quad_t
multiply(u_quad_t n1, u_quad_t n2)
{
	static int bpw = 0;
	u_quad_t m;
	u_quad_t r;
	int b1, b2;

	/*
	 * Get rid of the simple cases
	 */
	if (n1 == 0 || n2 == 0)
		return (0);
	if (n1 == 1)
		return (n2);
	if (n2 == 1)
		return (n1);

	/*
	 * sizeof() returns number of bytes needed for storage.
	 * This may be different from the actual number of useful bits.
	 */
	if (!bpw) {
		bpw = sizeof(u_quad_t) * 8;
		while (((u_quad_t)1 << (bpw-1)) == 0)
			--bpw;
	}

	/*
	 * First check the magnitude of each number.  If the sum of the
	 * magnatude is way to high, reject the number.  (If this test
	 * is not done then the first multiply below may overflow.)
	 */
	for (b1 = bpw; (((u_quad_t)1 << (b1-1)) & n1) == 0; --b1)
		; 
	for (b2 = bpw; (((u_quad_t)1 << (b2-1)) & n2) == 0; --b2)
		; 
	if (b1 + b2 - 2 > bpw) {
		errno = ERANGE;
		return (UQUAD_MAX);
	}

	/*
	 * Decompose the multiplication to be:
	 * h1 = n1 & ~1
	 * h2 = n2 & ~1
	 * l1 = n1 & 1
	 * l2 = n2 & 1
	 * (h1 + l1) * (h2 + l2)
	 * (h1 * h2) + (h1 * l2) + (l1 * h2) + (l1 * l2)
	 *
	 * Since h1 && h2 do not have the low bit set, we can then say:
	 *
	 * (h1>>1 * h2>>1 * 4) + ...
	 *
	 * So if (h1>>1 * h2>>1) > (1<<(bpw - 2)) then the result will
	 * overflow.
	 *
	 * Finally, if MAX - ((h1 * l2) + (l1 * h2) + (l1 * l2)) < (h1*h2)
	 * then adding in residual amount will cause an overflow.
	 */

	m = (n1 >> 1) * (n2 >> 1);

	if (m >= ((u_quad_t)1 << (bpw-2))) {
		errno = ERANGE;
		return (UQUAD_MAX);
	}

	m *= 4;

	r = (n1 & n2 & 1)
	  + (n2 & 1) * (n1 & ~(u_quad_t)1)
	  + (n1 & 1) * (n2 & ~(u_quad_t)1);

	if ((u_quad_t)(m + r) < m) {
		errno = ERANGE;
		return (UQUAD_MAX);
	}
	m += r;

	return (m);
}

int
secure_path(char *path)
{
	struct stat sb;

	/*
	 * If not a regular file, or is owned/writeable by someone
	 * other than root, quit.
	 */
	if (lstat(path, &sb) < 0) {
		syslog(LOG_ERR, "cannot stat %s: %m", path);
		return (-1);
	} else if (!S_ISREG(sb.st_mode)) {
		syslog(LOG_ERR, "%s: not a regular file", path);
		return (-1);
	} else if (sb.st_uid != 0) {
		syslog(LOG_ERR, "%s: not owned by root", path);
		return (-1);
	} else if (sb.st_mode & (S_IWGRP | S_IWOTH)) {
		syslog(LOG_ERR, "%s: writable by non-root", path);
		return (-1);
	}
	return (0);
}
DEF_WEAK(secure_path);

/*
 * Check whether or not a tilde in a string should be expanded.
 * We only do expansion for things like "~", "~/...", ~me", "~me/...".
 * Additionally, for paths the tilde must be a the beginning.
 */
#define tilde_valid(s, b, u, l, ip) \
    ((!(ip) || (s) == (b) || (s)[-1] == ':') && \
    ((s)[1] == '/' || (s)[1] == '\0' || \
    (strncmp((s)+1, u, l) == 0 && ((s)[l+1] == '/' || (s)[l+1] == '\0'))))

/*
 * Make a copy of a string, expanding '~' to the user's homedir, '$' to the
 * login name and other escape sequences as per cgetstr(3).
 */
static char *
expandstr(const char *ostr, const struct passwd *pwd, int ispath)
{
	size_t n, olen, nlen, ulen, dlen;
	const char *ep, *eo, *op;
	char *nstr, *np;
	int ch;

	if (pwd != NULL) {
		ulen = strlen(pwd->pw_name);
		dlen = strlen(pwd->pw_dir);
	}

	/* calculate the size of the new string */
	olen = nlen = strlen(ostr);
	for (op = ostr, ep = ostr + olen; op < ep; op++) {
		switch (*op) {
		case '~':
			if (pwd == NULL ||
			    !tilde_valid(op, ostr, pwd->pw_name, ulen, ispath))
				break;
			if (op[1] != '/' && op[1] != '\0') {
				op += ulen;	/* ~username */
				nlen = nlen - ulen - 1 + dlen;
			} else
				nlen += dlen - 1;
			break;
		case '$':
			if (pwd != NULL)
				nlen += ulen - 1;
			break;
		case '^':
			/* control char */
			if (*++op != '\0')
				nlen--;
			break;
		case '\\':
			if (op[1] == '\0')
				break;
			/*
			 * Byte in octal notation (\123) or an escaped char (\t)
			 */
			eo = op + 4;
			do {
				op++;
				nlen--;
			} while (op < eo && *op >= '0' && *op <= '7');
			break;
		}
	}
	if ((np = nstr = malloc(++nlen)) == NULL)
		return (NULL);

	for (op = ostr, ep = ostr + olen; op < ep; op++) {
		switch ((ch = *op)) {
		case '~':
			if (pwd == NULL ||
			    !tilde_valid(op, ostr, pwd->pw_name, ulen, ispath))
				break;
			if (op[1] != '/' && op[1] != '\0')
				op += ulen;	/* ~username */
			strlcpy(np, pwd->pw_dir, nlen);
			nlen -= dlen;
			np += dlen;
			continue;
		case '$':
			if (pwd == NULL)
				break;
			strlcpy(np, pwd->pw_name, nlen);
			nlen -= ulen;
			np += ulen;
			continue;
		case '^':
			if (op[1] != '\0')
				ch = *++op & 037;
			break;
		case '\\':
			if (op[1] == '\0')
				break;
			switch(*++op) {
			case '0': case '1': case '2': case '3':
			case '4': case '5': case '6': case '7':
				/* byte in octal up to 3 digits long */
				ch = 0;
				n = 3;
				do {
					ch = ch * 8 + (*op++ - '0');
				} while (--n && *op >= '0' && *op <= '7');
				break;
			case 'b': case 'B':
				ch = '\b';
				break;
			case 't': case 'T':
				ch = '\t';
				break;
			case 'n': case 'N':
				ch = '\n';
				break;
			case 'f': case 'F':
				ch = '\f';
				break;
			case 'r': case 'R':
				ch = '\r';
				break;
			case 'e': case 'E':
				ch = '\033';
				break;
			case 'c': case 'C':
				ch = ':';
				break;
			default:
				ch = *op;
				break;
			}
			break;
		}
		*np++ = ch;
		nlen--;
	}
	*np = '\0';
	return (nstr);
}
@


1.33
log
@Remove NULL-checks before free() and a few related dead assignments.

ok and valuable input from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.32 2015/09/14 16:09:13 tedu Exp $	*/
d73 2
a74 2
static	int setuserenv(login_cap_t *lc, const struct passwd *pwd);
static	int setuserpath(login_cap_t *, const struct passwd *pwd);
d78 1
a78 1
static	int gsetrl(login_cap_t *lc, int what, char *name, int type);
d83 1
a83 1
	char *classfiles[2];
d87 1
a87 1
	if (secure_path(_PATH_LOGIN_CONF) == 0) {
a88 4
		classfiles[1] = NULL;
	} else {
		classfiles[0] = NULL;
	}
d215 1
a215 1
	char *res, *str;
a218 2
	str = e;			/* return error string by default */
	res = NULL;
d251 1
a251 1
	char *res, *sres;
a255 1
	res = NULL;
d336 1
a336 1
	char *res;
a340 1
	res = NULL;
d390 1
a390 1
	char *res;
a394 1
	res = NULL;
@


1.32
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.31 2015/09/13 19:58:50 guenther Exp $	*/
d167 2
a168 4
	if (lc->lc_style) {
		free(lc->lc_style);
		lc->lc_style = NULL;
	}
@


1.31
log
@Wrap <login_cap.h> so that calls go direct and the symbols are all weak
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.30 2014/04/01 02:16:37 millert Exp $	*/
d212 2
a213 4
	if (f1)
		free(f1);
	if (f2)
		free(f2);
d271 1
a271 2
		if (res)
			free(res);
d274 1
a274 2
		if (res)
			free(res);
d282 1
a282 2
		if (res)
			free(res);
d357 1
a357 2
		if (res)
			free(res);
d360 1
a360 2
		if (res)
			free(res);
d368 1
a368 2
		if (res)
			free(res);
d412 1
a412 2
		if (res)
			free(res);
d415 1
a415 2
		if (res)
			free(res);
d423 1
a423 2
		if (res)
			free(res);
d459 3
a461 6
		if (lc->lc_class)
			free(lc->lc_class);
		if (lc->lc_cap)
			free(lc->lc_cap);
		if (lc->lc_style)
			free(lc->lc_style);
@


1.30
log
@Use setresuid() and setresgid().  OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.29 2008/10/02 16:01:58 millert Exp $	*/
d153 1
d218 1
d255 1
d344 1
d402 1
d454 1
d464 1
d479 1
d694 1
d1018 1
@


1.29
log
@simplify and clarify login_getstyle; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.28 2007/09/17 07:07:23 moritz Exp $	*/
d635 3
a637 2
		if (setgid(pwd->pw_gid) < 0) {
			syslog(LOG_ERR, "setgid(%u): %m", (u_int)pwd->pw_gid);
d644 1
a644 1
			    pwd->pw_name, (u_int)pwd->pw_gid);
d659 3
a661 3
		(void) seteuid(uid);	/* just in case */
		if (setuid(uid) < 0) {
			syslog(LOG_ERR, "setuid(%u): %m", uid);
@


1.28
log
@Check snprintf(3) return value for error or truncation.
Mostly path construction, where truncation could be bad.

ok and input from deraadt@@ millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.27 2007/09/02 15:19:16 deraadt Exp $	*/
d159 1
a159 1
    	char *f1, **f2;
a161 3
	f1 = 0;
	f2 = 0;

d168 1
a168 1
		lc->lc_style = 0;
d206 3
a208 6
	if (*authtypes == NULL || (auths = strdup(*authtypes)) == NULL) {
		if (f1)
			free(f1);
		if (f2)
			free(f2);
		if (*authtypes)
a209 1
		return (0);
d215 1
a215 1
	return (lc->lc_style = auths);
@


1.27
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.26 2006/04/09 04:40:35 deraadt Exp $	*/
d512 1
d521 10
a530 2
	snprintf(name_cur, sizeof name_cur, "%s-cur", name);
	snprintf(name_max, sizeof name_max, "%s-max", name);
@


1.26
log
@a few rlim_t casts, kind of ok otto and millert
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.25 2005/10/04 20:36:40 otto Exp $	*/
d183 1
a183 1
		f2 = authtypes = malloc(sizeof(char *) * i);
@


1.25
log
@Fix use after free(). Bug found by mpech@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.24 2004/09/16 06:24:41 deraadt Exp $	*/
d549 4
a552 4
		RCUR = login_getcaptime(lc, name, RCUR, RCUR);
		RMAX = login_getcaptime(lc, name, RMAX, RMAX);
		rl.rlim_cur = login_getcaptime(lc, name_cur, RCUR, RCUR);
		rl.rlim_max = login_getcaptime(lc, name_max, RMAX, RMAX);
d555 4
a558 4
		RCUR = login_getcapsize(lc, name, RCUR, RCUR);
		RMAX = login_getcapsize(lc, name, RMAX, RMAX);
		rl.rlim_cur = login_getcapsize(lc, name_cur, RCUR, RCUR);
		rl.rlim_max = login_getcapsize(lc, name_max, RMAX, RMAX);
d561 4
a564 4
		RCUR = login_getcapnum(lc, name, RCUR, RCUR);
		RMAX = login_getcapnum(lc, name, RMAX, RMAX);
		rl.rlim_cur = login_getcapnum(lc, name_cur, RCUR, RCUR);
		rl.rlim_max = login_getcapnum(lc, name_max, RMAX, RMAX);
@


1.24
log
@unused variable killed
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.23 2004/08/10 15:53:31 millert Exp $	*/
a311 1
			free(sres);
d314 1
a395 1
		free(res);
d398 1
a446 1
		free(res);
d449 1
@


1.23
log
@Only expand a tilde for strings like "~", "~/..", "~user" and "~user/".
For the PATH, only expand a tilde that is at the beginning of the path name.
This is similar to the behavior prior to my commit here yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.22 2004/08/09 21:15:09 millert Exp $	*/
d818 1
a818 1
	u_quad_t num, num2, t;
a858 1
		t = num;
@


1.22
log
@Support the "setenv" capability in login.conf ala FreeBSD.  Following
FreeBSD's example, a '~' in an environment variable is replaced
with the user's homedir.  A '$' is replaced by the user's login
name.  Both can be escaped with a backslash to get the literal char.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.21 2004/08/07 17:33:58 millert Exp $	*/
d71 2
a72 2
static	char *expandstr(const char *, const struct passwd *);
static	int login_setenv(char *, char *, const struct passwd *);
d732 1
a732 1
	error = login_setenv("PATH", path ? path : _PATH_DEFPATH, pwd);
d776 1
a776 1
		if ((error = login_setenv(beg, value, pwd)) != 0) {
d790 1
a790 1
login_setenv(char *name, char *ovalue, const struct passwd *pwd)
d796 1
a796 1
		value = expandstr(ovalue, pwd);
d1009 10
d1023 1
a1023 1
expandstr(const char *ostr, const struct passwd *pwd)
d1025 1
a1025 1
	size_t n, olen, nlen;
d1030 5
d1040 8
a1047 2
			if (pwd != NULL)
				nlen += strlen(pwd->pw_dir) - 1;
d1051 1
a1051 1
				nlen += strlen(pwd->pw_name) - 1;
d1078 2
a1079 1
			if (pwd == NULL)
d1081 5
a1085 3
			n = strlcpy(np, pwd->pw_dir, nlen);
			nlen -= n;
			np += n;
d1090 3
a1092 3
			n = strlcpy(np, pwd->pw_name, nlen);
			nlen -= n;
			np += n;
@


1.21
log
@Honor vmemoryuse resouce limit if RLIMIT_VMEM is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.20 2004/05/18 02:05:52 jfb Exp $	*/
d3 15
d71 4
a74 1
static	int setuserpath(login_cap_t *, char *);
d664 8
d673 1
a673 1
		if (setuserpath(lc, pwd ? pwd->pw_dir : "") == -1) {
d686 2
a687 2
 * with ':' and "~/" with "$HOME/" at the beginning of entries.  Sets
 * the PATH environment variable to the result or _PATH_DEFPATH on error.
d690 1
a690 1
setuserpath(login_cap_t *lc, char *home)
d692 35
a726 21
	size_t psize, n;
	char *p, *path, *opath, *dst, *dend, *tmp, last;
	int cnt, error;

	dst = path = NULL;
	if ((opath = login_getcapstr(lc, "path", NULL, NULL)) == NULL)
		goto done;

	/* Count the number of entries that begin with "~/" or consist of "~" */
	for (p = opath, cnt = 0, last = ' '; *p != '\0'; last = *p++) {
		if (p[0] == '~' && (last == ' ' || last == '\t')) {
			switch (p[1]) {
			case '/':
				p++;
				/* FALLTHROUGH */
			case ' ':
			case '\t':
			case '\0':
				cnt++;
				break;
			}
d728 1
d730 17
d748 11
a758 9
	/* The '~' in opath counts against strlen(home), hence the decrement. */
	psize = (p - opath) + (cnt * (strlen(home) - 1)) + 1;
	if ((dst = path = malloc(psize)) == NULL)
		goto done;

	/* Copy path elements from opath into path, expanding ~ as we go. */
	dend = dst + psize;
	for (tmp = opath; (p = strsep(&tmp, " \t")) != NULL; ) {
		if (*p == '\0')
d760 6
a765 5
		if (p[0] == '~' && (p[1] == '/' || p[1] == '\0')) {
			n = strlcpy(dst, home, dend - dst);
			if (n >= dend - dst) {
				dst = path;
				goto done;
d767 3
a769 2
			dst += n;
			p++;
d771 8
a778 3
		if ((n = strlcpy(dst, p, dend - dst)) >= dend - dst) {
			dst = path;
			goto done;
d780 1
a780 2
		dst += n;
		*dst++ = ':';
d782 3
a784 2
	if (dst != path)
		*--dst = '\0';		/* replace trailing ':' w/ a NUL */
d786 13
a798 13
	/*
	 * Possible exit states:
	 *	error: path == NULL, opath == NULL, dst == NULL
	 *	error: path == NULL, opath != NULL, dst == NULL
	 *	error: path != NULL, opath != NULL, dst == path
	 *	good:  path != NULL, opath != NULL, dst != path
	 */
done:
	error = setenv("PATH", (path != dst) ? path : _PATH_DEFPATH, 1);
	if (opath != NULL)
		free(opath);
	if (path != opath)
		free(path);
d1006 113
@


1.20
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.19 2004/01/07 01:09:40 fgsch Exp $	*/
d480 3
@


1.19
log
@amout -> amount; from tom@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.18 2003/10/24 20:31:00 avsm Exp $	*/
d63 1
a63 2
login_getclass(class)
	char *class;
d137 1
a137 4
login_getstyle(lc, style, atype)
	login_cap_t *lc;
	char *style;
	char *atype;
d208 1
a208 5
login_getcapstr(lc, cap, def, e)
	login_cap_t *lc;
	char *cap;
	char *def;
	char *e;
d244 1
a244 5
login_getcaptime(lc, cap, def, e)
	login_cap_t *lc;
	char *cap;
	quad_t def;
	quad_t e;
d332 1
a332 5
login_getcapnum(lc, cap, def, e)
	login_cap_t *lc;
	char *cap;
	quad_t def;
	quad_t e;
d389 1
a389 5
login_getcapsize(lc, cap, def, e)
	login_cap_t *lc;
	char *cap;
	quad_t def;
	quad_t e;
d440 1
a440 4
login_getcapbool(lc, cap, def)
	login_cap_t *lc;
	char *cap;
	u_int def;
d449 1
a449 2
login_close(lc)
	login_cap_t *lc;
d484 1
a484 5
gsetrl(lc, what, name, type)
	login_cap_t *lc;
	int what;
	char *name;
	int type;
d560 1
a560 3
setclasscontext(class, flags)
	char *class;
	u_int flags;
d575 1
a575 5
setusercontext(lc, pwd, uid, flags)
	login_cap_t *lc;
	struct passwd *pwd;
	uid_t uid;
	u_int flags;
d661 1
a661 3
setuserpath(lc, home)
	login_cap_t *lc;
	char *home;
d746 1
a746 4
strtosize(str, endptr, radix)
	char *str;
	char **endptr;
	int radix;
d819 1
a819 4
strtolimit(str, endptr, radix)
	char *str;
	char **endptr;
	int radix;
d830 1
a830 3
multiply(n1, n2)
	u_quad_t n1;
	u_quad_t n2;
@


1.18
log
@dont compare int to NULL, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.17 2003/06/25 21:16:47 deraadt Exp $	*/
d932 1
a932 1
	 * then adding in residual amout will cause an overflow.
@


1.17
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.16 2003/03/31 15:47:03 millert Exp $	*/
d112 1
a112 1
			if (strcmp(lc->lc_class, LOGIN_DEFCLASS) == NULL &&
@


1.16
log
@Rewritten setuserpath() that is much clearer and uses strlcpy()
for added paranoia.  tdeval@@ and mpech@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.15 2002/12/15 13:27:06 henning Exp $	*/
d60 1
@


1.15
log
@more writeable -> writable by torh
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.14 2002/11/22 19:47:03 deraadt Exp $	*/
d688 5
d698 39
a736 35
	int hlen, plen, error;
	int cnt = 0;
	char *path;
	char *p, *savep;
	char *q, *saveq = NULL;

	hlen = strlen(home);

	if ((savep = p = path = login_getcapstr(lc, "path", NULL, NULL))) {
		while (*p)
			if (*p++ == '~')
				++cnt;
		plen = (p - path) + cnt * (hlen + 1) + 1;
		p = path;
		if ((saveq = q = path = malloc(plen))) {
			while (*p) {
				p += strspn(p, " \t");
				if (*p == '\0')
					break;
				plen = strcspn(p, " \t");
				if (hlen == 0 && *p == '~') {
					p += plen;
					continue;
				}
				if (q != path)
					*q++ = ':';
				if (*p == '~') {
					strcpy(q, home);
					q += hlen;
					++p;
					--plen;
				}
				memcpy(q, p, plen);
				p += plen;
				q += plen;
d738 6
a743 1
			*q = '\0';
d745 2
d748 2
a749 6
	error = setenv("PATH", path ? path : _PATH_DEFPATH, 1);
	
	if (savep)
		free(savep);
	if (saveq)
		free(saveq);
d751 13
@


1.14
log
@more snprintf; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.13 2002/10/09 20:36:19 millert Exp $	*/
d950 1
a950 1
		syslog(LOG_ERR, "%s: writeable by non-root", path);
@


1.13
log
@Use strtoll() and strtoull() instead of strtoq() and strtouq() now
that we have them as per the original BSDi code.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.12 2002/06/27 10:21:35 deraadt Exp $	*/
d526 2
a527 2
	sprintf(name_cur, "%s-cur", name);
	sprintf(name_max, "%s-max", name);
@


1.12
log
@%u and uid/gid
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.11 2002/06/23 03:03:37 deraadt Exp $	*/
d301 1
a301 1
		r = strtoq(res, &ep, 0);
d390 1
a390 1
    	q = strtoq(res, &ep, 0);
d765 1
a765 1
	num = strtouq(str, &expr, radix);
@


1.11
log
@uid_t is unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.10 2002/02/16 21:27:23 millert Exp $	*/
d646 1
a646 1
			syslog(LOG_ERR, "setgid(%d): %m", pwd->pw_gid);
d652 2
a653 2
			syslog(LOG_ERR, "initgroups(%s,%d): %m",
			    pwd->pw_name, pwd->pw_gid);
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.9 2002/01/29 08:08:57 mpech Exp $	*/
d670 1
a670 1
			syslog(LOG_ERR, "setuid(%d): %m", uid);
@


1.9
log
@Fix memory leak in setuserpath(). We prefer patch from millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.8 2002/01/28 07:05:03 mpech Exp $	*/
d56 4
a59 4
static	int setuserpath __P((login_cap_t *, char *));
static	u_quad_t multiply __P((u_quad_t, u_quad_t));
static	u_quad_t strtolimit __P((char *, char **, int));
static	u_quad_t strtosize __P((char *, char **, int));
@


1.8
log
@Fix memory leaks in login_getcapnum() and login_getcapsize().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.7 2002/01/23 19:04:09 millert Exp $	*/
d693 1
a693 1
	int hlen, plen;
d696 2
a697 1
	char *p, *q;
d701 1
a701 1
	if ((p = path = login_getcapstr(lc, "path", NULL, NULL))) {
d707 1
a707 1
		if ((q = path = malloc(plen))) {
d730 8
a737 6
		} else
			path = _PATH_DEFPATH;
	} else
		path = _PATH_DEFPATH;
	if (setenv("PATH", path, 1))
		return (-1);
d739 1
a739 1
	return (0);
@


1.7
log
@Fix memory leaks in login_getstyle(), login_getstr() and login_getcaptime()
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.6 2001/05/30 16:56:00 millert Exp $	*/
d355 2
d362 2
d366 2
d375 2
d383 4
a386 1
	if (strcasecmp(res, "infinity") == 0)
d388 1
a389 1
	errno = 0;
d393 1
d399 1
d416 1
d423 2
d427 2
d436 2
d448 1
d454 1
@


1.6
log
@Complain via syslog if login.conf does not exist.  With the BSD
authentication stuff in you really want to know if this file
doesn't exist.  The last two releases have shipped with /etc/login.conf
so there's no excuse not to have it, other than an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.5 2000/12/04 15:31:50 millert Exp $	*/
d154 5
d160 1
a160 1
		auths = login_getcapstr(lc, "auth", "", NULL);
d163 4
a166 25
		if (*auths) {
			f1 = ta = auths = strdup(auths);
			if (!auths) {
				syslog(LOG_ERR, "strdup: %m");
				return (0);
			}
			i = 2;
			while (*ta)
				if (*ta++ == ',')
					++i;
			f2 = authtypes = malloc(sizeof(char *) * i);
			if (!authtypes) {
				syslog(LOG_ERR, "malloc: %m");
				free(f1);
				return (0);
			}
			i = 0;
			while (*auths) {
				authtypes[i] = auths;
				while (*auths && *auths != ',')
					++auths;
				if (*auths)
					*auths++ = 0;
				if (!*authtypes[i])
					authtypes[i] = LOGIN_DEFSTYLE;
d168 16
a183 3
			}
			authtypes[i] = 0;
			
d185 1
a200 1
		lc->lc_style = 0;
d203 2
d217 1
a217 1
	char *res;
d221 2
d229 2
a230 1
		return (def);
d234 1
a234 1
		return (e);
d236 7
a242 5
		if (stat >= 0) 
			return (res);
		syslog(LOG_ERR, "%s: unexpected error with capability %s",
		    lc->lc_class, cap);
		return (e);
d244 4
d263 2
d270 2
d274 2
d283 2
d291 4
a294 1
	if (strcasecmp(res, "infinity") == 0)
d296 1
a296 2

	errno = 0;
d305 1
d338 1
@


1.5
log
@Silently convert s/key -> skey in login_getstyle().  A bit of a hack
but OpenBSD folks are more used to saying s/key.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.4 2000/11/10 15:33:03 provos Exp $	*/
d896 1
a896 4
#if 1 /* XXX - remove after 2.8 is out? */
		if (errno != ENOENT)
#endif
			syslog(LOG_ERR, "cannot stat %s: %m", path);
@


1.4
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.3 2000/09/16 18:06:01 millert Exp $	*/
d149 4
@


1.3
log
@Change setuserpath() from void to int so we can pass up a return
value if setenv() fails.  Porblem pointed out by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.2 2000/08/24 17:03:47 deraadt Exp $	*/
d702 1
a702 1
 *	   seperated by x (also * for backwards compatibility), specifying
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: login_cap.c,v 1.1 2000/08/20 18:37:20 millert Exp $	*/
d56 1
a56 1
static	void setuserpath __P((login_cap_t *, char *));
d630 7
a636 2
	if (flags & LOGIN_SETPATH)
		setuserpath(lc, pwd ? pwd->pw_dir : "");
d642 1
a642 1
static void
d688 3
a690 1
		warn("could not set PATH");
@


1.1
log
@login.conf code from BSDi.  This does not include the bsd auth code
which will come later.  At this stage it is primarily used for setting
resource limits.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
	int res, i;
d649 1
a649 1
	if (p = path = login_getcapstr(lc, "path", NULL, NULL)) {
d655 1
a655 1
		if (q = path = malloc(plen)) {
@

