head	1.26;
access;
symbols
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.20.0.10
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.18.0.20
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.18
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.16
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.14
	OPENBSD_5_0:1.18.0.12
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.10
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.8
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.8
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.6
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.10
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.8
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.6
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.4
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.1.0.2
	OPENBSD_2_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.05.26.15.51.37;	author millert;	state Exp;
branches;
next	1.25;
commitid	3fBtWnNad08Z4Rcj;

1.25
date	2015.11.24.22.03.33;	author millert;	state Exp;
branches;
next	1.24;
commitid	LVVvCb2EklWn8nFM;

1.24
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.23;
commitid	iWfSX2BIn0sLw62l;

1.23
date	2015.09.12.15.20.14;	author guenther;	state Exp;
branches;
next	1.22;
commitid	2Q8C6yMAg0ltaqhX;

1.22
date	2015.08.31.02.53.57;	author guenther;	state Exp;
branches;
next	1.21;
commitid	lTMF8Y3C9fQGd6jQ;

1.21
date	2015.08.27.13.33.24;	author dlg;	state Exp;
branches;
next	1.20;
commitid	u66KgrFF0rgcYmih;

1.20
date	2013.11.24.23.51.29;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.09.30.12.02.32;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.15.13.14.30;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.04.17.42.39;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.17.07.07.23;	author moritz;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.19.17.07.43;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.26.16.39.14;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.15.20.16.08;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.14.23.47.30;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.23.03.03.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.24.21.22.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.20.17.17.15;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.13.21.39.41;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.05.07.51.52;	author mpech;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.26.19.44.38;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.09.06.57.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.02.19.22.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.24.21.18.15;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.03.19.55.57;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.21.00.51.16;	author millert;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Use S_ISDIR instead of doing it by hand.  No binary change.
@
text
@/*	$OpenBSD: authenticate.c,v 1.25 2015/11/24 22:03:33 millert Exp $	*/

/*-
 * Copyright (c) 1997 Berkeley Software Design, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Berkeley Software Design,
 *	Inc.
 * 4. The name of Berkeley Software Design, Inc.  may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN, INC. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI $From: authenticate.c,v 2.21 1999/09/08 22:33:26 prb Exp $
 */

#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <limits.h>
#include <login_cap.h>
#include <paths.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#include <bsd_auth.h>

static int _auth_checknologin(login_cap_t *, int);

char *
auth_mkvalue(char *value)
{
	char *big, *p;

	big = malloc(strlen(value) * 4 + 1);
	if (big == NULL)
		return (NULL);
	/*
	 * XXX - There should be a more standardized
	 * routine for doing this sort of thing.
	 */
	for (p = big; *value; ++value) {
		switch (*value) {
		case '\r':
			*p++ = '\\';
			*p++ = 'r';
			break;
		case '\n':
			*p++ = '\\';
			*p++ = 'n';
			break;
		case '\\':
			*p++ = '\\';
			*p++ = *value;
			break;
		case '\t':
		case ' ':
			if (p == big)
				*p++ = '\\';
			*p++ = *value;
			break;
		default:
			if (!isprint((unsigned char)*value)) {
				*p++ = '\\';
				*p++ = ((*value >> 6) & 0x3) + '0';
				*p++ = ((*value >> 3) & 0x7) + '0';
				*p++ = ((*value     ) & 0x7) + '0';
			} else
				*p++ = *value;
			break;
		}
	}
	*p = '\0';
	return (big);
}
DEF_WEAK(auth_mkvalue);

void
auth_checknologin(login_cap_t *lc)
{
	if (_auth_checknologin(lc, 1))
		exit(1);
}
DEF_WEAK(auth_checknologin);

static int
_auth_checknologin(login_cap_t *lc, int print)
{
	struct stat sb;
	char *nologin;
	int mustfree;

	if (login_getcapbool(lc, "ignorenologin", 0))
		return (0);

	/*
	 * If we fail to get the nologin file due to a database error,
	 * assume there should have been one...
	 */
	nologin = login_getcapstr(lc, "nologin", "", NULL);
	mustfree = nologin && *nologin != '\0';
	if (nologin == NULL)
		goto print_nologin;

	/* First try the nologin file specified in login.conf. */
	if (*nologin != '\0' && stat(nologin, &sb) == 0)
		goto print_nologin;
	if (mustfree) {
		free(nologin);
		mustfree = 0;
	}

	/* If that doesn't exist try _PATH_NOLOGIN. */
	if (stat(_PATH_NOLOGIN, &sb) == 0) {
		nologin = _PATH_NOLOGIN;
		goto print_nologin;
	}

	/* Couldn't stat any nologin files, must be OK to login. */
	return (0);

print_nologin:
	if (print) {
		if (!nologin || *nologin == '\0' || auth_cat(nologin) == 0) {
			puts("Logins are not allowed at this time.");
			fflush(stdout);
		}
	}
	if (mustfree)
		free(nologin);
	return (-1);
}

int
auth_cat(char *file)
{
	int fd, nchars;
	char tbuf[8192];

	if ((fd = open(file, O_RDONLY, 0)) < 0)
		return (0);
	while ((nchars = read(fd, tbuf, sizeof(tbuf))) > 0)
		(void)write(fileno(stdout), tbuf, nchars);
	(void)close(fd);
	return (1);
}
DEF_WEAK(auth_cat);

int
auth_approval(auth_session_t *as, login_cap_t *lc, char *name, char *type)
{
	int close_on_exit, close_lc_on_exit, len;
	struct passwd pwstore, *pwd;
	char *approve, *s, path[PATH_MAX], pwbuf[_PW_BUF_LEN];

	pwd = NULL;
	close_on_exit = as == NULL;
	close_lc_on_exit = lc == NULL;

	if (as != NULL && name == NULL)
		name = auth_getitem(as, AUTHV_NAME);

	if (as != NULL)
		pwd = auth_getpwd(as);

	if (pwd == NULL) {
		if (name != NULL) {
			getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd);
		} else {
			getpwuid_r(getuid(), &pwstore, pwbuf, sizeof(pwbuf),
			    &pwd);
			if (pwd == NULL) {
				syslog(LOG_ERR, "no such user id %u", getuid());
				warnx("cannot approve who we don't recognize");
				return (0);
			}
			name = pwd->pw_name;
		}
	}

	if (name == NULL)
		name = pwd->pw_name;

	if (lc == NULL) {
		if (strlen(name) >= PATH_MAX) {
			syslog(LOG_ERR, "username to login %.*s...",
			    PATH_MAX, name);
			warnx("username too long");
			return (0);
		}
		if (pwd == NULL && (approve = strchr(name, '.')) != NULL) {
			strlcpy(path, name, sizeof path);
			path[approve-name] = '\0';
			getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd);
		}
		lc = login_getclass(pwd ? pwd->pw_class : NULL);
		if (lc == NULL) {
			warnx("unable to classify user");
			return (0);
		}
	}

	if (!type)
		type = LOGIN_DEFSERVICE;
	else {
		if (strncmp(type, "approve-", 8) == 0)
			type += 8;

		len = snprintf(path, sizeof(path), "approve-%s", type);
		if (len < 0 || len >= sizeof(path)) {
			if (close_lc_on_exit)
				login_close(lc);
			syslog(LOG_ERR, "approval path too long %.*s...",
			    PATH_MAX, type);
			warnx("approval script path too long");
			return (0);
		}
	}

	if ((approve = login_getcapstr(lc, s = path, NULL, NULL)) == NULL)
		approve = login_getcapstr(lc, s = "approve", NULL, NULL);

	if (approve && approve[0] != '/') {
		if (close_lc_on_exit)
			login_close(lc);
		syslog(LOG_ERR, "Invalid %s script: %s", s, approve);
		warnx("invalid path to approval script");
		free(approve);
		return (0);
	}

	if (as == NULL && (as = auth_open()) == NULL) {
		if (close_lc_on_exit)
			login_close(lc);
		syslog(LOG_ERR, "%m");
		warn(NULL);
		free(approve);
		return (0);
	}

	auth_setstate(as, AUTH_OKAY);
	if (auth_setitem(as, AUTHV_NAME, name) < 0) {
		syslog(LOG_ERR, "%m");
		warn(NULL);
		goto out;
	}
	if (auth_check_expire(as) < 0)	/* is this account expired */
		goto out;
	if (_auth_checknologin(lc,
	    auth_getitem(as, AUTHV_INTERACTIVE) != NULL)) {
		auth_setstate(as, (auth_getstate(as) & ~AUTH_ALLOW));
		goto out;
	}
	if (login_getcapbool(lc, "requirehome", 0) && pwd && pwd->pw_dir &&
	    pwd->pw_dir[0]) {
		struct stat sb;

		if (stat(pwd->pw_dir, &sb) < 0 || !S_ISDIR(sb.st_mode) ||
		    (pwd->pw_uid && sb.st_uid == pwd->pw_uid &&
		    (sb.st_mode & S_IXUSR) == 0)) {
			auth_setstate(as, (auth_getstate(as) & ~AUTH_ALLOW));
			goto out;
		}
	}
	if (approve)
		auth_call(as, approve, strrchr(approve, '/') + 1, name,
		    lc->lc_class, type, (char *)NULL);

out:
	free(approve);
	if (close_lc_on_exit)
		login_close(lc);

	if (close_on_exit)
		return (auth_close(as));
	return (auth_getstate(as) & AUTH_ALLOW);
}
DEF_WEAK(auth_approval);

auth_session_t *
auth_usercheck(char *name, char *style, char *type, char *password)
{
	char namebuf[LOGIN_NAME_MAX + 1 + NAME_MAX + 1];
	char pwbuf[_PW_BUF_LEN];
	auth_session_t *as;
	login_cap_t *lc;
	struct passwd pwstore, *pwd = NULL;
	char *slash;

	if (strlcpy(namebuf, name, sizeof(namebuf)) >= sizeof(namebuf))
		return (NULL);
	name = namebuf;

	/*
	 * Split up user:style names if we were not given a style
	 */
	if (style == NULL && (style = strchr(name, ':')) != NULL)
		*style++ = '\0';

	/*
	 * Cope with user/instance.  We are only using this to get
	 * the class so it is okay if we strip a /root instance
	 * The actual login script will pay attention to the instance.
	 */
	getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd);
	if (pwd == NULL) {
		if ((slash = strchr(name, '/')) != NULL) {
			*slash = '\0';
			getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd);
			*slash = '/';
		}
	}
	if ((lc = login_getclass(pwd ? pwd->pw_class : NULL)) == NULL)
		return (NULL);

	if ((style = login_getstyle(lc, style, type)) == NULL) {
		login_close(lc);
		return (NULL);
	}

	if (password) {
		if ((as = auth_open()) == NULL) {
			login_close(lc);
			return (NULL);
		}
		auth_setitem(as, AUTHV_SERVICE, "response");
		auth_setdata(as, "", 1);
		auth_setdata(as, password, strlen(password) + 1);
		explicit_bzero(password, strlen(password));
	} else
		as = NULL;
	as = auth_verify(as, style, name, lc->lc_class, (char *)NULL);
	login_close(lc);
	return (as);
}
DEF_WEAK(auth_usercheck);

int
auth_userokay(char *name, char *style, char *type, char *password)
{
	auth_session_t *as;

	as = auth_usercheck(name, style, type, password);

	return (as != NULL ? auth_close(as) : 0);
}
DEF_WEAK(auth_userokay);

auth_session_t *
auth_userchallenge(char *name, char *style, char *type, char **challengep)
{
	char namebuf[LOGIN_NAME_MAX + 1 + NAME_MAX + 1];
	auth_session_t *as;
	login_cap_t *lc;
	struct passwd pwstore, *pwd = NULL;
	char *slash, pwbuf[_PW_BUF_LEN];

	if (strlen(name) >= sizeof(namebuf))
		return (NULL);
	strlcpy(namebuf, name, sizeof namebuf);
	name = namebuf;

	/*
	 * Split up user:style names if we were not given a style
	 */
	if (style == NULL && (style = strchr(name, ':')) != NULL)
		*style++ = '\0';

	/*
	 * Cope with user/instance.  We are only using this to get
	 * the class so it is okay if we strip a /root instance
	 * The actual login script will pay attention to the instance.
	 */
	getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd);
	if (pwd == NULL) {
		if ((slash = strchr(name, '/')) != NULL) {
			*slash = '\0';
			getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd);
			*slash = '/';
		}
	}
	if ((lc = login_getclass(pwd ? pwd->pw_class : NULL)) == NULL)
		return (NULL);

	if ((style = login_getstyle(lc, style, type)) == NULL ||
	    (as = auth_open()) == NULL) {
		login_close(lc);
		return (NULL);
	}
	if (auth_setitem(as, AUTHV_STYLE, style) < 0 ||
	    auth_setitem(as, AUTHV_NAME, name) < 0 ||
	    auth_setitem(as, AUTHV_CLASS, lc->lc_class) < 0) {
		auth_close(as);
		login_close(lc);
		return (NULL);
	}
	login_close(lc);
	*challengep = auth_challenge(as);
	return (as);
}
DEF_WEAK(auth_userchallenge);

int
auth_userresponse(auth_session_t *as, char *response, int more)
{
	char path[PATH_MAX];
	char *style, *name, *challenge, *class;
	int len;

	if (as == NULL)
		return (0);

	auth_setstate(as, 0);

	if ((style = auth_getitem(as, AUTHV_STYLE)) == NULL ||
	    (name = auth_getitem(as, AUTHV_NAME)) == NULL) {
		if (more == 0)
			return (auth_close(as));
		return(0);
	}

	len = snprintf(path, sizeof(path), _PATH_AUTHPROG "%s", style);
	if (len < 0 || len >= sizeof(path)) {
		if (more == 0)
			return (auth_close(as));
		return (0);
	}

	challenge = auth_getitem(as, AUTHV_CHALLENGE);
	class = auth_getitem(as, AUTHV_CLASS);

	if (challenge)
		auth_setdata(as, challenge, strlen(challenge) + 1);
	else
		auth_setdata(as, "", 1);
	if (response) {
		auth_setdata(as, response, strlen(response) + 1);
		explicit_bzero(response, strlen(response));
	} else
		auth_setdata(as, "", 1);

	auth_call(as, path, style, "-s", "response", name, class, (char *)NULL);

	/*
	 * If they authenticated then make sure they did not expire
	 */
	if (auth_getstate(as) & AUTH_ALLOW)
		auth_check_expire(as);
	if (more == 0)
		return (auth_close(as));
	return (auth_getstate(as) & AUTH_ALLOW);
}
DEF_WEAK(auth_userresponse);

/*
 * Authenticate name with the specified style.
 * If ``as'' is NULL a new session is formed with the default service.
 * Returns NULL only if ``as'' is NULL and we were unable to allocate
 * a new session.
 *
 * Use auth_close() or auth_getstate() to determine if the authentication
 * worked.
 */
auth_session_t *
auth_verify(auth_session_t *as, char *style, char *name, ...)
{
	va_list ap;
	char path[PATH_MAX];

	if ((name == NULL || style == NULL) && as == NULL)
		return (as);

	if (as == NULL && (as = auth_open()) == NULL)
		return (NULL);
	auth_setstate(as, 0);

	if (style != NULL && auth_setitem(as, AUTHV_STYLE, style) < 0)
		return (as);

	if (name != NULL && auth_setitem(as, AUTHV_NAME, name) < 0)
		return (as);

	style = auth_getitem(as, AUTHV_STYLE);
	name = auth_getitem(as, AUTHV_NAME);

	snprintf(path, sizeof(path), _PATH_AUTHPROG "%s", style);
	va_start(ap, name);
	auth_set_va_list(as, ap);
	auth_call(as, path, auth_getitem(as, AUTHV_STYLE), "-s",
	    auth_getitem(as, AUTHV_SERVICE), name, (char *)NULL);
	va_end(ap);
	return (as);
}
DEF_WEAK(auth_verify);
@


1.25
log
@Use reentrant versions of getpw{nam,uid} and getgr{nam,gid} within
libc to avoid reusing the static buffers returned by the non-reentrant
versions.  Since this is inside libc we can use constants for the
buffer sizes instead of having to call sysconf().
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.24 2015/09/14 16:09:13 tedu Exp $	*/
d285 1
a285 2
		if (stat(pwd->pw_dir, &sb) < 0 ||
		    (sb.st_mode & 0170000) != S_IFDIR ||
@


1.24
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.23 2015/09/12 15:20:14 guenther Exp $	*/
d180 2
a181 2
	struct passwd *pwd;
	char *approve, *s, path[PATH_MAX];
d194 6
a199 4
		if (name != NULL)
			pwd = getpwnam(name);
		else {
			if ((pwd = getpwuid(getuid())) == NULL) {
d221 1
a221 1
			pwd = getpwnam(name);
d312 1
d315 1
a315 1
	struct passwd *pwd;
d333 2
a334 1
	if ((pwd = getpwnam(name)) == NULL) {
d337 1
a337 1
			pwd = getpwnam(name);
d383 2
a384 2
	struct passwd *pwd;
	char *slash;
d402 2
a403 1
	if ((pwd = getpwnam(name)) == NULL) {
d406 1
a406 1
			pwd = getpwnam(name);
@


1.23
log
@Wrap <bsd_auth.h> so that calls go direct and the symbols are all weak
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.22 2015/08/31 02:53:57 guenther Exp $	*/
d262 1
a262 2
		if (approve)
			free(approve);
d296 1
a296 2
	if (approve)
		free(approve);
@


1.22
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.21 2015/08/27 13:33:24 dlg Exp $	*/
d103 1
d111 1
d174 1
d306 1
d362 1
d373 1
d426 1
d478 1
d519 1
@


1.21
log
@use explicit_bzero to clear some memory that had creds in it instead of
memset.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.20 2013/11/24 23:51:29 deraadt Exp $	*/
d196 1
a196 1
				_warnx("cannot approve who we don't recognize");
d210 1
a210 1
			_warnx("username too long");
d220 1
a220 1
			_warnx("unable to classify user");
d237 1
a237 1
			_warnx("approval script path too long");
d249 1
a249 1
		_warnx("invalid path to approval script");
d258 1
a258 1
		_warn(NULL);
d267 1
a267 1
		_warn(NULL);
@


1.20
log
@most obvious unsigned char casts for ctype
ok jca krw ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.19 2013/09/30 12:02:32 millert Exp $	*/
d351 1
a351 1
		memset(password, 0, strlen(password));
d456 1
a456 1
		memset(response, 0, strlen(response));
@


1.19
log
@Use PATH_MAX, NAME_MAX and LOGIN_NAME_MAX not MAXPATHNAMELEN,
MAXNAMLEN or MAXLOGNAME where possible.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.18 2009/01/15 13:14:30 millert Exp $	*/
d90 1
a90 1
			if (!isprint(*value)) {
@


1.18
log
@Remove support for kerb4 '.' instance separator, kerb4 is dead.  OK jacekm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.17 2008/04/04 17:42:39 millert Exp $	*/
d36 1
a36 1
#include <sys/param.h>
d42 1
d178 1
a178 1
	char *approve, *s, path[MAXPATHLEN];
d207 1
a207 1
		if (strlen(name) >= MAXPATHLEN) {
d209 1
a209 1
			    MAXPATHLEN, name);
d236 1
a236 1
			    MAXPATHLEN, type);
d307 1
a307 1
	char namebuf[MAXLOGNAME + 1 + NAME_MAX + 1];
d372 1
a372 1
	char namebuf[MAXLOGNAME + 1 + NAME_MAX + 1];
d424 1
a424 1
	char path[MAXPATHLEN];
d485 1
a485 1
	char path[MAXPATHLEN];
@


1.17
log
@Zero out the password/response argument in the simplified BSD auth
interafces.  Otherwise, we end up with an extra copy in memory when
auth_call() forks that is not possible to clear.
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.16 2007/09/17 07:07:23 moritz Exp $	*/
d310 1
a310 1
	char *sep, save;
d323 2
a324 2
	 * Cope with user[./]instance.  We are only using this to get
	 * the class so it is okay if we strip a root instance
d328 2
a329 3
		if ((sep = strpbrk(name, "./")) != NULL) {
			save = *sep;
			*sep = '\0';
d331 1
a331 1
			*sep = save;
d375 1
a375 1
	char *sep, save;
d389 2
a390 2
	 * Cope with user[./]instance.  We are only using this to get
	 * the class so it is okay if we strip a root instance
d394 2
a395 3
		if ((sep = strpbrk(name, "./")) != NULL) {
			save = *sep;
			*sep = '\0';
d397 1
a397 1
			*sep = save;
@


1.16
log
@Check snprintf(3) return value for error or truncation.
Mostly path construction, where truncation could be bad.

ok and input from deraadt@@ millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.15 2005/12/19 17:07:43 millert Exp $	*/
d351 1
d455 1
a455 1
	if (response)
d457 2
a458 1
	else
@


1.15
log
@Use strlcpy() return value in bound check instead of using  an
extra strlen().  This has been in my tree for a long time.
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.14 2005/06/26 16:39:14 millert Exp $	*/
d175 1
a175 1
	int close_on_exit, close_lc_on_exit;
d230 9
a238 1
		snprintf(path, sizeof(path), "approve-%s", type);
d426 1
d439 8
a457 2

	snprintf(path, sizeof(path), _PATH_AUTHPROG "%s", style);
@


1.14
log
@add missing va_end(); Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.13 2002/10/15 20:16:08 millert Exp $	*/
d304 1
a304 1
	if (strlen(name) >= sizeof(namebuf))
a305 1
	strlcpy(namebuf, name, sizeof namebuf);
@


1.13
log
@cast NULL varargs sentinel to char * so it is 64 bit on alpha & sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.12 2002/07/14 23:47:30 deraadt Exp $	*/
d493 1
@


1.12
log
@indent, and double free fix; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.11 2002/06/23 03:03:37 deraadt Exp $	*/
d282 1
a282 1
		    lc->lc_class, type, 0);
d346 1
a346 1
	as = auth_verify(as, style, name, lc->lc_class, NULL);
d445 1
a445 1
	auth_call(as, path, style, "-s", "response", name, class, NULL);
d492 1
a492 1
	    auth_getitem(as, AUTHV_SERVICE), name, NULL);
@


1.11
log
@uid_t is unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.10 2002/05/24 21:22:37 deraadt Exp $	*/
d132 1
a132 1
	if (mustfree)
d134 2
d241 1
a241 1
               free(approve);
d250 2
a251 2
               if (approve)
                       free(approve);
d275 1
a275 1
		     (sb.st_mode & S_IXUSR) == 0)) {
d281 2
a282 2
	    auth_call(as, approve, strrchr(approve, '/') + 1, name,
		lc->lc_class, type, 0);
d285 2
a286 2
       if (approve)
               free(approve);
@


1.10
log
@try to use strlcpy and snprintf more; ok various
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.9 2002/03/20 17:17:15 mpech Exp $	*/
d192 1
a192 1
				syslog(LOG_ERR, "no such user id %d", getuid());
@


1.9
log
@fix memleak.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.8 2002/03/13 21:39:41 millert Exp $	*/
d211 1
a211 1
			strcpy(path, name);
d304 1
a304 1
	strcpy(namebuf, name);
d370 1
a370 1
	strcpy(namebuf, name);
@


1.8
log
@Convert indentation whitespace -> tabs and kill $@@%^#! ^M's
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.7 2002/02/05 07:51:52 mpech Exp $	*/
d239 1
d248 2
d283 2
@


1.7
log
@o) Fix memory leak in _auth_checklogin(), auth_approval(), auth_close() and
   auth_clean().

Spotted via ftpd. We could use ftpd as a simple debug tool for bsdauth and
login_cap routines. :)

millert@@ help&OK
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.6 2001/10/26 19:44:38 markus Exp $	*/
d115 4
a118 4
       int mustfree;

       if (login_getcapbool(lc, "ignorenologin", 0))
               return (0);
d124 15
a138 15
       nologin = login_getcapstr(lc, "nologin", "", NULL);
       mustfree = nologin && *nologin != '\0';
       if (nologin == NULL)
               goto print_nologin;

       /* First try the nologin file specified in login.conf. */
       if (*nologin != '\0' && stat(nologin, &sb) == 0)
               goto print_nologin;
       if (mustfree)
               free(nologin);

       /* If that doesn't exist try _PATH_NOLOGIN. */
       if (stat(_PATH_NOLOGIN, &sb) == 0) {
               nologin = _PATH_NOLOGIN;
               goto print_nologin;
d141 2
a142 2
       /* Couldn't stat any nologin files, must be OK to login. */
       return (0);
d144 4
a147 4
print_nologin:
       if (print) {
               if (!nologin || *nologin == '\0' || auth_cat(nologin) == 0) {
                       puts("Logins are not allowed at this time.");
d151 3
a153 3
       if (mustfree)
               free(nologin);
       return (-1);
@


1.6
log
@run the approve for accounts with expiration time, too. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.5 2001/07/09 06:57:42 deraadt Exp $	*/
d115 4
d124 15
a138 13
	if ((nologin = login_getcapstr(lc, "nologin", "", NULL)) == NULL) {
		if (print) {
			printf("Logins are not allowed at this time.\n");
			fflush(stdout);
		}
		return (-1);
	}
	if (*nologin && stat(nologin, &sb) >= 0) {
		if (print && auth_cat(nologin) == 0) {
			printf("Logins are not allowed at this time.\n");
			fflush(stdout);
		}
		return (-1);
d141 2
a142 2
	if (login_getcapbool(lc, "ignorenologin", 0))
		return(0);
d144 4
a147 3
	if (stat(_PATH_NOLOGIN, &sb) >= 0) {
		if (print && auth_cat(_PATH_NOLOGIN) == 0) {
			printf("Logins are not allowed at this time.\n");
a149 1
		return (-1);
d151 3
a153 1
	return(0);
@


1.5
log
@a first pass at -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.4 2001/07/02 19:22:34 millert Exp $	*/
d248 1
a248 1
	if (auth_check_expire(as))	/* is this account expired */
@


1.4
log
@Convert warn/warnx -> _warn/_warnx
Should not really spew to stderr from libc but right now there
is no other way to get a sensible error message to the user.
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.3 2001/06/24 21:18:15 millert Exp $	*/
a105 3
	struct stat sb;
	char *nologin;

d179 1
a179 1
	if (pwd == NULL)
d190 1
@


1.3
log
@When splitting instance from username, treat '/' as a separator as
well (for Kerb5).
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.2 2001/06/03 19:55:57 millert Exp $	*/
d188 1
a188 1
				warnx("cannot approve who we don't recognize");
d201 1
a201 1
			warnx("username too long");
d211 1
a211 1
			warnx("unable to classify user");
d232 1
a232 1
		warnx("invalid path to approval script");
d240 1
a240 1
		warnx(NULL);
d247 1
a247 1
		warnx(NULL);
@


1.2
log
@Don't bail out early for users w/o passwd file entries since we may
want to cons up a fake prompt for challenge/response auth methods.
markus@@ OK'd.
@
text
@d1 1
a1 1
/*	$OpenBSD: authenticate.c,v 1.1 2000/11/21 00:51:16 millert Exp $	*/
d289 1
a289 1
	char *dot;
d303 2
a304 2
	 * Cope with user.instance.  We are only using this to get
	 * the class so it is okay if we strip a .root instance
d308 3
a310 2
		if ((dot = strchr(name, '.')) != NULL) {
			dot = '\0';
d312 1
a312 1
			*dot = '.';
d342 1
d355 1
a355 1
	char *dot;
d369 2
a370 2
	 * Cope with user.instance.  We are only using this to get
	 * the class so it is okay if we strip a .root instance
d374 3
a376 2
		if ((dot = strchr(name, '.')) != NULL) {
			dot = '\0';
d378 1
a378 1
			*dot = '.';
@


1.1
log
@BSD authentication routines from BSDI.  Presently this is not used but
the login_* helper programs and other support will be committed in the
near future.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d314 1
a314 1
	if (pwd == NULL || (lc = login_getclass(pwd->pw_class)) == NULL)
d332 1
a332 1
	as = auth_verify(as, style, name, pwd->pw_class, NULL);
d378 1
a378 1
	if (pwd == NULL || (lc = login_getclass(pwd->pw_class)) == NULL)
d388 1
a388 1
	    auth_setitem(as, AUTHV_CLASS, pwd->pw_class) < 0) {
@

