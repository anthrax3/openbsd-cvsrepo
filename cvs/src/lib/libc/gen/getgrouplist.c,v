head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.6
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.14
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.12
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.12
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.10
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.8
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.24
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.22
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.20
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.18
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.16
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.12.01.15.08.25;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	FnyjPuUxHGEcyAdw;

1.26
date	2015.09.12.14.56.50;	author guenther;	state Exp;
branches;
next	1.25;
commitid	BXATo6E2rFBuIXKr;

1.25
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.24;
commitid	GouatFiJVxwlAVIQ;

1.24
date	2014.09.15.06.15.48;	author guenther;	state Exp;
branches;
next	1.23;
commitid	ztgYHm1nk3mtTyS3;

1.23
date	2014.01.22.09.58.28;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2013.04.17.17.40.35;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.09.00.18.27;	author kurt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.22.01.23.16;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.21.16.04.23;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.23.18.52.43;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.03.16.02.44;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.27.12.31.31;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.23.10.08.02;	author chl;	state Exp;
branches;
next	1.14;

1.14
date	2008.08.22.00.59.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.24.14.29.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.25.15.38.47;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.25.21.16.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.08.19.19.13.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.08.19.16.24.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.09.00.28.21;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.09.31.01;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.23.32;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.25.21.39.17;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.55;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@modify getpw*(), getgr*(), and getgrouplist() functions to access the
YP lock file unconditionally.  This hints to the kernel that a "getpw"
operation is happening, even in the non-YP case.  This looks like a
gruesome hack, but helps refine the ways these functions are called
and mandates the right pledge requests.  Once the tree is fully annotated
we will know better how to improve the backing store management.
ok semarie espie beck
@
text
@/*	$OpenBSD: getgrouplist.c,v 1.26 2015/09/12 14:56:50 guenther Exp $ */
/*
 * Copyright (c) 2008 Ingo Schwarze <schwarze@@usta.de>
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * get credential
 */
#include <sys/types.h>
#include <sys/limits.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <grp.h>
#include <pwd.h>

#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>

#ifdef YP
#define _PATH_NETID	"/etc/netid"
#define MAXLINELENGTH	1024

static int _parse_netid(char*, uid_t, gid_t*, int*, int);
static int _read_netid(const char *, uid_t, gid_t*, int*, int);

/*
 * Parse one string of the form "uid:gid[,gid[,...]]".
 * If the uid matches, add the groups to the group list.
 * If the groups fit, return 1, otherwise return -1. 
 * If the uid does not match, return 0.
 */
static int
_parse_netid(char *netid, uid_t uid, gid_t *groups, int *ngroups,
	     int maxgroups)
{
	const char *errstr = NULL;
	char *start, *p;
	uid_t tuid;
	gid_t gid;
	int i;

	/* Check the uid. */
	p = strchr(netid, ':');
	if (!p)
		return (0);
	*p++ = '\0';
	tuid = (uid_t)strtonum(netid, 0, UID_MAX, &errstr);
	if (errstr || tuid != uid)
		return (0);

        /* Loop over the gids. */
	while (p && *p) {
		start = p;
		p = strchr(start, ',');
		if (p)
			*p++ = '\0';
		gid = (gid_t)strtonum(start, 0, GID_MAX, &errstr);
		if (errstr)
			continue;

		/* Skip this group if it is already in the list. */
		for (i = 0; i < *ngroups; i++)
			if (groups[i] == gid)
				break;

		/* Try to add this new group to the list. */
		if (i == *ngroups) {
			if (*ngroups >= maxgroups)
				return (-1);
			groups[(*ngroups)++] = gid;
		}
	}
	return (1);
}

/*
 * Search /etc/netid for a particular uid and process that line.
 * See _parse_netid for details, including return values.
 */
static int
_read_netid(const char *key, uid_t uid, gid_t *groups, int *ngroups,
	    int maxgroups)
{
	FILE *fp;
	char line[MAXLINELENGTH], *p;
	int found = 0;

	fp = fopen(_PATH_NETID, "re");
	if (!fp) 
		return (0);
	while (!found && fgets(line, sizeof(line), fp)) {
		p = strchr(line, '\n');
		if (p)
			*p = '\0';
		else { /* Skip lines that are too long. */
			int ch;
			while ((ch = getc_unlocked(fp)) != '\n' && ch != EOF)
				;
			continue;
		}
		p = strchr(line, ' ');
		if (!p)
			continue;
		*p++ = '\0';
		if (strcmp(line, key))
			continue;
		found = _parse_netid(p, uid, groups, ngroups, maxgroups);
	}
	(void)fclose(fp);
	return (found);
}
#endif /* YP */

int
getgrouplist(const char *uname, gid_t agroup, gid_t *groups, int *grpcnt)
{
	int i, ngroups = 0, ret = 0, maxgroups = *grpcnt, bail;
	int needyp = 0, foundyp = 0;
	int *skipyp = &foundyp;
	extern struct group *_getgrent_yp(int *);
	struct group *grp;

	/*
	 * install primary group
	 */
	if (ngroups >= maxgroups) {
		*grpcnt = ngroups;
		return (-1);
	}
	groups[ngroups++] = agroup;

#ifdef YP
	/*
	 * Hint to the kernel that a passwd database operation is happening.
	 */
	(void)access("/var/run/ypbind.lock", R_OK);
#endif

	/*
	 * Scan the group file to find additional groups.
	 */
	setgrent();
	while ((grp = _getgrent_yp(skipyp)) || foundyp) {
		if (foundyp) {
			if (foundyp > 0)
				needyp = 1;
			else
				skipyp = NULL;
			foundyp = 0;
			continue;
		}
		if (grp->gr_gid == agroup)
			continue;
		for (bail = 0, i = 0; bail == 0 && i < ngroups; i++)
			if (groups[i] == grp->gr_gid)
				bail = 1;
		if (bail)
			continue;
		for (i = 0; grp->gr_mem[i]; i++) {
			if (!strcmp(grp->gr_mem[i], uname)) {
				if (ngroups >= maxgroups) {
					ret = -1;
					goto out;
				}
				groups[ngroups++] = grp->gr_gid;
				break;
			}
		}
	}

#ifdef YP
	/*
	 * If we were told that there is a YP marker, look at netid data.
	 */
	if (skipyp && needyp) {
		char buf[MAXLINELENGTH], *ypdata = NULL, *key;
		static char *__ypdomain;
		struct passwd pwstore;
		int ypdatalen;

		/* Construct the netid key to look up. */
		if (getpwnam_r(uname, &pwstore, buf, sizeof buf, NULL) ||
		    (!__ypdomain && yp_get_default_domain(&__ypdomain)))
			goto out;
		i = asprintf(&key, "unix.%u@@%s", pwstore.pw_uid, __ypdomain);
		if (i == -1)
			goto out;

		/* First scan the static netid file. */
		switch (_read_netid(key, pwstore.pw_uid,
		    groups, &ngroups, maxgroups)) {
		case -1:
			ret = -1;
			/* FALLTHROUGH */
		case 1:
			free(key);
			goto out;
		default:
			break;
		}

		/* Only access YP when there is no static entry. */
		if (!yp_bind(__ypdomain) &&
		    !yp_match(__ypdomain, "netid.byname", key,
			     (int)strlen(key), &ypdata, &ypdatalen))
			if (_parse_netid(ypdata, pwstore.pw_uid,
			    groups, &ngroups, maxgroups) == -1)
				ret = -1;

		free(key);
		free(ypdata);
	}
#endif /* YP */

out:
	endgrent();
	*grpcnt = ngroups;
	return (ret);
}
DEF_WEAK(getgrouplist);
@


1.26
log
@Wrap <unistd.h> so that internal calls go direct and they're all weak symbols
Delete unused 'fd' argument from internal function oldttyname()
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.25 2015/06/03 02:24:36 millert Exp $ */
d160 7
@


1.25
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.24 2014/09/15 06:15:48 guenther Exp $ */
d242 1
@


1.24
log
@When fopen()ing internal to libc (the API doesn't support the use
of the resulting FILE *), then pass fopen() the 'e' mode letter to
mark it close-on-exec.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.23 2014/01/22 09:58:28 jsg Exp $ */
d207 2
a208 2
		asprintf(&key, "unix.%u@@%s", pwstore.pw_uid, __ypdomain);
		if (key == NULL)
@


1.23
log
@fix a leak in getgrouplist()
problem reproduced and fix verified by schwarze who wrote the code
ok krw@@ deraadt@@ schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.22 2013/04/17 17:40:35 tedu Exp $ */
d117 1
a117 1
	fp = fopen(_PATH_NETID, "r");
@


1.22
log
@add some prototypes, casts, includes, parenthesis, and whatnot to
silence some warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.21 2009/11/09 00:18:27 kurt Exp $ */
d218 1
@


1.21
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

committing on behalf of and okay guenther@@ now that we have install
media space available.
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.20 2009/10/22 01:23:16 guenther Exp $ */
d205 1
a205 1
		    !__ypdomain && yp_get_default_domain(&__ypdomain))
@


1.20
log
@Back out previous commit, as it caused too much growth for the install
media to fit
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.19 2009/10/21 16:04:23 guenther Exp $ */
d126 1
a126 1
			while ((ch = getc(fp)) != '\n' && ch != EOF)
@


1.19
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

ok kurt@@, earlier version tested by sthen@@ and jj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.18 2009/06/23 18:52:43 schwarze Exp $ */
d126 1
a126 1
			while ((ch = getc_unlocked(fp)) != '\n' && ch != EOF)
@


1.18
log
@getgrouplist(3) used to and ought to return 0 on success;
fixing a regression introduced in rev. 1.16 spotted by otto@@;
ok millert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.17 2009/06/03 16:02:44 schwarze Exp $ */
d126 1
a126 1
			while ((ch = getc(fp)) != '\n' && ch != EOF)
@


1.17
log
@Take advantage of the surprise libc bump to bring in
YP group(5) exclusion, i.e. support -groupname:*:: in /etc/group.
Such groups will be excluded from later +:*::,
in just the same was as it is already done for passwd(5).
I have been running this since the autumn of 2008.
Discussed with several (including deraadt@@, millert@@, jmc@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.16 2009/03/27 12:31:31 schwarze Exp $ */
d212 6
a217 2
		if (ret = _read_netid(key, pwstore.pw_uid,
				      groups, &ngroups, maxgroups))
d219 3
d227 3
a229 2
			ret = _parse_netid(ypdata, pwstore.pw_uid,
			    		   groups, &ngroups, maxgroups);
@


1.16
log
@getgrouplist: If YP is #defined and enabled in /etc/group(5) and /etc/netid(5)
  contains a matching entry, use that and refrain from accessing YP.
getpwnam/getpwuid: If YP is #defined and /etc/master.passwd(5) contains
  a matching entry before the first YP entry, use that and stay away from YP.

Taken together, this allows a solution to the following problem pointed
out by deraadt@@: When YP was configured but temporarily unavailable, even
root login would block, hindering you when trying to do repairs.
To avoid this, you can now provide a static entry for root in /etc/netid.

Using suggestions from miod@@ otto@@ blambert@@ jmc@@.
"commit" deraadt@@, "cool" ajacoutot@@, "looks fine" jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.15 2008/08/23 10:08:02 chl Exp $ */
d148 1
d165 1
a165 1
	while ((grp = _getgrent_yp(&foundyp)) || foundyp) {
d167 4
a170 1
			needyp = 1;
d197 1
a197 1
	if (needyp) {
@


1.15
log
@add missing header needed by asprintf().

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.14 2008/08/22 00:59:34 deraadt Exp $ */
d3 1
d48 95
d191 1
a191 1
	 * If we were told that there is a YP marker, look there now.
d194 1
a194 2
		char buf[1024], *ypdata = NULL, *key, *p;
		const char *errstr = NULL;
d197 1
a197 12
		int r, ypdatalen;
		gid_t gid;
		uid_t uid;
	
		if (!__ypdomain) {
			if (_yp_check(&__ypdomain) == 0) {
				goto ypout;
			}
		}

		if (getpwnam_r(uname, &pwstore, buf, sizeof buf, NULL))
			goto ypout;
d199 4
d205 14
a218 3
			goto ypout;
		r = yp_match(__ypdomain, "netid.byname", key,
		    (int)strlen(key), &ypdata, &ypdatalen);
d220 1
a220 38
		if (r != 0)
			goto ypout;

		/* Parse the "uid:gid[,gid,gid[,...]]" string. */
		p = strchr(ypdata, ':');
		if (!p)
			goto ypout;
		*p++ = '\0';
		uid = (uid_t)strtonum(ypdata, 0, UID_MAX, &errstr);
		if (errstr || uid != pwstore.pw_uid)
			goto ypout;
		while (p && *p) {
			char *start = p;

			p = strchr(start, ',');
			if (p)
				*p++ = '\0';
			gid = (uid_t)strtonum(start, 0, GID_MAX, &errstr);
			if (errstr)
				goto ypout;

			/* Add new groups to the group list */
			for (i = 0; i < ngroups; i++) {
				if (groups[i] == gid)
					break;
			}
			if (i == ngroups) {
				if (ngroups >= maxgroups) {
					ret = -1;
					goto ypout;
				}
				groups[ngroups++] = gid;
			}
		}
ypout:
		if (ypdata)
			free(ypdata);
		goto out;
@


1.14
log
@After spotting a + record, continue scanning and pick up later groups
in the file.  Problem spotted by drahn.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.13 2008/06/24 14:29:45 deraadt Exp $ */
d38 1
@


1.13
log
@create a private getpwent()-like interface which does not walk the YP
groups map but instead tells us that it is there.  then use this interface
in getgrouplist(), and do a single lookup against netid.byname instead to
get all the groups associated with that user
ok kurt, testing by many others
@
text
@d1 1
a1 1
/*	$OpenBSD: getgrouplist.c,v 1.12 2005/08/08 08:05:34 espie Exp $ */
d49 2
a50 1
	int i, ngroups = 0, ret = 0, maxgroups = *grpcnt, bail, foundyp = 0;
d67 6
a72 1
	while ((grp = _getgrent_yp(&foundyp))) {
d96 1
a96 1
	if (foundyp) {
@


1.12
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d35 1
d38 1
d40 5
d49 2
a51 7
	int i, ngroups;
	int ret, maxgroups;
	int bail;

	ret = 0;
	ngroups = 0;
	maxgroups = *grpcnt;
d66 1
a66 1
	while ((grp = getgrent())) {
d85 70
@


1.11
log
@deregister (and deauto!). ok millert@@ marco@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: getgrouplist.c,v 1.10 2004/05/18 02:05:52 jfb Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.10
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getgrouplist.c,v 1.9 2003/06/25 21:16:47 deraadt Exp $";
d45 2
a46 2
	register struct group *grp;
	register int i, ngroups;
@


1.9
log
@protos
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getgrouplist.c,v 1.8 2003/06/02 20:18:34 millert Exp $";
d43 1
a43 5
getgrouplist(uname, agroup, groups, grpcnt)
	const char *uname;
	gid_t agroup;
	register gid_t *groups;
	int *grpcnt;
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getgrouplist.c,v 1.7 1997/08/19 19:13:27 deraadt Exp $";
d39 1
@


1.7
log
@repair duplication check
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: getgrouplist.c,v 1.6 1997/08/19 16:24:42 deraadt Exp $";
@


1.6
log
@do not reuse id's. also be more careful with maxgids.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getgrouplist.c,v 1.5 1997/07/09 00:28:21 millert Exp $";
d55 1
d77 1
a77 1
		for (i = 0; i < ngroups; i++)
d79 2
a80 2
				break;
		if (groups[i] == grp->gr_gid)
@


1.5
log
@Clean up some -Wall complaints.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getgrouplist.c,v 1.4 1996/09/15 09:31:01 tholo Exp $";
d63 4
d75 5
@


1.4
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getgrouplist.c,v 1.3 1996/08/19 08:23:32 tholo Exp $";
d69 1
a69 1
	while (grp = getgrent()) {
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getgrouplist.c,v 1.5 1995/06/01 22:51:17 jtc Exp $";
a52 1
	register struct passwd *pw;
@


1.2
log
@Prototype internal functions
Do the right thing in presense of __STDC__
@
text
@a0 2
/*	$NetBSD: getgrouplist.c,v 1.5 1995/06/01 22:51:17 jtc Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)getgrouplist.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: getgrouplist.c,v 1.5 1995/06/01 22:51:17 jtc Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d54 2
a55 2
	int agroup;
	register int *groups;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
