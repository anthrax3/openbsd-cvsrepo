head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.6
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.10
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.14
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.12
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.10
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.10
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_9_BASE:1.2;
locks; strict;
comment	@ * @;


1.26
date	2016.10.18.12.47.18;	author millert;	state Exp;
branches;
next	1.25;
commitid	aeQ9kyI0S7cY3KGG;

1.25
date	2015.09.14.10.45.27;	author guenther;	state Exp;
branches;
next	1.24;
commitid	KsWfRTbaoT9xznAC;

1.24
date	2013.11.24.23.51.29;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.05.14.13.30.34;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.13.10.20.54;	author dtucker;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.17.16.27.07;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.30.12.03.48;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.31.05.33.59;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.24.16.09.33;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.17.21.56.23;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.01.52.39;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.28.01.43.58;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.09.16.40.35;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.15.05.41.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.07.23.55.35;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.07.22.16.48;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.06.07.04.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.06.05.20.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.07.19.34.11;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.07.19.29.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.27.13.23.30;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.18.17.41.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.16.22.53.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.29.18.41.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.21.00.48.37;	author millert;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Avoid generate SIGTTOU when restoring the terminal mode.  If we get
SIGTTOU it means the process is not in the foreground process group
which, in most cases, means that the shell has taken control of the
tty.  Requiring the user the fg the process in this case doesn't
make sense and can result in both SIGTSTP and SIGTTOU being sent
which can lead to the process being suspended again immediately
after being brought into the foreground.
@
text
@/*	$OpenBSD: readpassphrase.c,v 1.25 2015/09/14 10:45:27 guenther Exp $	*/

/*
 * Copyright (c) 2000-2002, 2007, 2010
 *	Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <readpassphrase.h>

static volatile sig_atomic_t signo[_NSIG];

static void handler(int);

char *
readpassphrase(const char *prompt, char *buf, size_t bufsiz, int flags)
{
	ssize_t nr;
	int input, output, save_errno, i, need_restart;
	char ch, *p, *end;
	struct termios term, oterm;
	struct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;
	struct sigaction savetstp, savettin, savettou, savepipe;

	/* I suppose we could alloc on demand in this case (XXX). */
	if (bufsiz == 0) {
		errno = EINVAL;
		return(NULL);
	}

restart:
	for (i = 0; i < _NSIG; i++)
		signo[i] = 0;
	nr = -1;
	save_errno = 0;
	need_restart = 0;
	/*
	 * Read and write to /dev/tty if available.  If not, read from
	 * stdin and write to stderr unless a tty is required.
	 */
	if ((flags & RPP_STDIN) ||
	    (input = output = open(_PATH_TTY, O_RDWR)) == -1) {
		if (flags & RPP_REQUIRE_TTY) {
			errno = ENOTTY;
			return(NULL);
		}
		input = STDIN_FILENO;
		output = STDERR_FILENO;
	}

	/*
	 * Turn off echo if possible.
	 * If we are using a tty but are not the foreground pgrp this will
	 * generate SIGTTOU, so do it *before* installing the signal handlers.
	 */
	if (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {
		memcpy(&term, &oterm, sizeof(term));
		if (!(flags & RPP_ECHO_ON))
			term.c_lflag &= ~(ECHO | ECHONL);
		if (term.c_cc[VSTATUS] != _POSIX_VDISABLE)
			term.c_cc[VSTATUS] = _POSIX_VDISABLE;
		(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);
	} else {
		memset(&term, 0, sizeof(term));
		term.c_lflag |= ECHO;
		memset(&oterm, 0, sizeof(oterm));
		oterm.c_lflag |= ECHO;
	}

	/*
	 * Catch signals that would otherwise cause the user to end
	 * up with echo turned off in the shell.  Don't worry about
	 * things like SIGXCPU and SIGVTALRM for now.
	 */
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;		/* don't restart system calls */
	sa.sa_handler = handler;
	(void)sigaction(SIGALRM, &sa, &savealrm);
	(void)sigaction(SIGHUP, &sa, &savehup);
	(void)sigaction(SIGINT, &sa, &saveint);
	(void)sigaction(SIGPIPE, &sa, &savepipe);
	(void)sigaction(SIGQUIT, &sa, &savequit);
	(void)sigaction(SIGTERM, &sa, &saveterm);
	(void)sigaction(SIGTSTP, &sa, &savetstp);
	(void)sigaction(SIGTTIN, &sa, &savettin);
	(void)sigaction(SIGTTOU, &sa, &savettou);

	if (!(flags & RPP_STDIN))
		(void)write(output, prompt, strlen(prompt));
	end = buf + bufsiz - 1;
	p = buf;
	while ((nr = read(input, &ch, 1)) == 1 && ch != '\n' && ch != '\r') {
		if (p < end) {
			if ((flags & RPP_SEVENBIT))
				ch &= 0x7f;
			if (isalpha((unsigned char)ch)) {
				if ((flags & RPP_FORCELOWER))
					ch = (char)tolower((unsigned char)ch);
				if ((flags & RPP_FORCEUPPER))
					ch = (char)toupper((unsigned char)ch);
			}
			*p++ = ch;
		}
	}
	*p = '\0';
	save_errno = errno;
	if (!(term.c_lflag & ECHO))
		(void)write(output, "\n", 1);

	/* Restore old terminal settings and signals. */
	if (memcmp(&term, &oterm, sizeof(term)) != 0) {
		const int sigttou = signo[SIGTTOU];

		/* Ignore SIGTTOU generated when we are not the fg pgrp. */
		while (tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm) == -1 &&
		    errno == EINTR && !signo[SIGTTOU])
			continue;
		signo[SIGTTOU] = sigttou;
	}
	(void)sigaction(SIGALRM, &savealrm, NULL);
	(void)sigaction(SIGHUP, &savehup, NULL);
	(void)sigaction(SIGINT, &saveint, NULL);
	(void)sigaction(SIGQUIT, &savequit, NULL);
	(void)sigaction(SIGPIPE, &savepipe, NULL);
	(void)sigaction(SIGTERM, &saveterm, NULL);
	(void)sigaction(SIGTSTP, &savetstp, NULL);
	(void)sigaction(SIGTTIN, &savettin, NULL);
	(void)sigaction(SIGTTOU, &savettou, NULL);
	if (input != STDIN_FILENO)
		(void)close(input);

	/*
	 * If we were interrupted by a signal, resend it to ourselves
	 * now that we have restored the signal handlers.
	 */
	for (i = 0; i < _NSIG; i++) {
		if (signo[i]) {
			kill(getpid(), i);
			switch (i) {
			case SIGTSTP:
			case SIGTTIN:
			case SIGTTOU:
				need_restart = 1;
			}
		}
	}
	if (need_restart)
		goto restart;

	if (save_errno)
		errno = save_errno;
	return(nr == -1 ? NULL : buf);
}
DEF_WEAK(readpassphrase);

char *
getpass(const char *prompt)
{
	static char buf[_PASSWORD_LEN + 1];

	return(readpassphrase(prompt, buf, sizeof(buf), RPP_ECHO_OFF));
}

static void handler(int s)
{

	signo[s] = 1;
}
@


1.25
log
@Wrap <readpassphrase.h> so internal calls go direct and readpassphrase is weak
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.24 2013/11/24 23:51:29 deraadt Exp $	*/
d136 3
d142 1
@


1.24
log
@most obvious unsigned char casts for ctype
ok jca krw ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.23 2010/05/14 13:30:34 millert Exp $	*/
d174 1
@


1.23
log
@Defer installing signal handlers until echo is disabled so that we
get suspended normally when not the foreground process.  Fix potential
infinite loop when restoring terminal settings if process is in the
background when restore occurs.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.22 2010/01/13 10:20:54 dtucker Exp $	*/
d120 1
a120 1
			if (isalpha(ch)) {
d122 1
a122 1
					ch = (char)tolower(ch);
d124 1
a124 1
					ch = (char)toupper(ch);
@


1.22
log
@If a process receives two different signals while in readpassphrase, only
the most recent one will be stored for later re-delivery.  When the signal
handlers are restored, all except the most recent signal will be lost.
Replace the single variable with an array so signals are not lost.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.21 2008/01/17 16:27:07 millert Exp $	*/
d4 2
a5 1
 * Copyright (c) 2000-2002, 2007 Todd C. Miller <Todd.Miller@@courtesan.com>
d76 19
d112 13
a124 32
	/* Turn off echo if possible. */
	if (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {
		memcpy(&term, &oterm, sizeof(term));
		if (!(flags & RPP_ECHO_ON))
			term.c_lflag &= ~(ECHO | ECHONL);
		if (term.c_cc[VSTATUS] != _POSIX_VDISABLE)
			term.c_cc[VSTATUS] = _POSIX_VDISABLE;
		(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);
	} else {
		memset(&term, 0, sizeof(term));
		term.c_lflag |= ECHO;
		memset(&oterm, 0, sizeof(oterm));
		oterm.c_lflag |= ECHO;
	}

	/* No I/O if we are already backgrounded. */
	if (signo[SIGTTOU] != 1 && signo[SIGTTIN] != 1) {
		if (!(flags & RPP_STDIN))
			(void)write(output, prompt, strlen(prompt));
		end = buf + bufsiz - 1;
		p = buf;
		while ((nr = read(input, &ch, 1)) == 1 && ch != '\n' && ch != '\r') {
			if (p < end) {
				if ((flags & RPP_SEVENBIT))
					ch &= 0x7f;
				if (isalpha(ch)) {
					if ((flags & RPP_FORCELOWER))
						ch = (char)tolower(ch);
					if ((flags & RPP_FORCEUPPER))
						ch = (char)toupper(ch);
				}
				*p++ = ch;
d126 1
a127 4
		*p = '\0';
		save_errno = errno;
		if (!(term.c_lflag & ECHO))
			(void)write(output, "\n", 1);
d129 4
d137 1
a137 1
		    errno == EINTR)
@


1.21
log
@Use TCSAFLUSH instead of TCSANOW when turning echo back on so that
there is no chance of output that was written but still pending to
be displayed.  This is what the original getpass(3) did.
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.20 2007/10/30 12:03:48 millert Exp $	*/
d34 1
a34 1
static volatile sig_atomic_t signo;
d42 1
a42 1
	int input, output, save_errno;
d55 2
a56 1
	signo = 0;
d59 1
d108 1
a108 1
	if (signo != SIGTTOU && signo != SIGTTIN) {
d154 9
a162 7
	if (signo) {
		kill(getpid(), signo);
		switch (signo) {
		case SIGTSTP:
		case SIGTTIN:
		case SIGTTOU:
			goto restart;
d165 2
d184 1
a184 1
	signo = s;
@


1.20
log
@If we receive SIGTTOU when turning off echo, the process is already
backgrounded.  Do not print the password prompt in this case since
the first read will result in the process receiving SIGTTIN.
Fixes an issue where the password prompt would be displayed when
readpassphrase() would not be able to read anything.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.19 2006/03/31 05:33:59 deraadt Exp $	*/
d132 1
a132 1
		while (tcsetattr(input, TCSANOW|TCSASOFT, &oterm) == -1 &&
@


1.19
log
@(char)to{upper,lower}()
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.18 2005/08/08 08:05:34 espie Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2002 Todd C. Miller <Todd.Miller@@courtesan.com>
d56 2
d105 17
a121 12
	if (!(flags & RPP_STDIN))
		(void)write(output, prompt, strlen(prompt));
	end = buf + bufsiz - 1;
	for (p = buf; (nr = read(input, &ch, 1)) == 1 && ch != '\n' && ch != '\r';) {
		if (p < end) {
			if ((flags & RPP_SEVENBIT))
				ch &= 0x7f;
			if (isalpha(ch)) {
				if ((flags & RPP_FORCELOWER))
					ch = (char)tolower(ch);
				if ((flags & RPP_FORCEUPPER))
					ch = (char)toupper(ch);
a122 1
			*p++ = ch;
d124 4
a128 4
	*p = '\0';
	save_errno = errno;
	if (!(term.c_lflag & ECHO))
		(void)write(output, "\n", 1);
d162 2
a163 1
	errno = save_errno;
@


1.18
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.17 2005/05/24 16:09:33 millert Exp $	*/
d112 1
a112 1
					ch = tolower(ch);
d114 1
a114 1
					ch = toupper(ch);
@


1.17
log
@Restoration of terminal settings can be broken by a well-timed signal,
e.g. a terminating scp killing its ssh child so retry on EINTR.
From peak@@argo.troja.mff.cuni.cz via portable openssh bugzilla #905
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.16 2003/06/17 21:56:23 millert Exp $	*/
a21 4

#if defined(LIBC_SCCS) && !defined(lint)
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.16 2003/06/17 21:56:23 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.16
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.15 2003/06/03 01:52:39 millert Exp $	*/
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.15 2003/06/03 01:52:39 millert Exp $";
d129 5
a133 2
	if (memcmp(&term, &oterm, sizeof(term)) != 0)
		(void)tcsetattr(input, TCSANOW|TCSASOFT, &oterm);
@


1.15
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.14 2002/06/28 01:43:58 millert Exp $	*/
d10 11
a20 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d24 1
a24 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.14 2002/06/28 01:43:58 millert Exp $";
@


1.14
log
@Add RPP_STDIN flag which acts as the converse of RPP_REQUIRE_TTY.
Based on a patch from Brett Eldridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.13 2002/05/09 16:40:35 millert Exp $	*/
a4 1
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.13 2002/05/09 16:40:35 millert Exp $";
@


1.13
log
@Add SIGALRM and SIGPIPE to the list of signals we catch, turn echo back on,
and then re-deliver.  Note that for this to work with setugid processes,
the recent fix to cansignal() in kern_sig.c is required.
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.12 2001/12/15 05:41:00 millert Exp $	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.12 2001/12/15 05:41:00 millert Exp $";
d71 2
a72 1
	if ((input = output = open(_PATH_TTY, O_RDWR)) == -1) {
d100 1
a100 1
	if (tcgetattr(input, &oterm) == 0) {
d109 1
d111 1
d114 2
a115 1
	(void)write(output, prompt, strlen(prompt));
@


1.12
log
@Catch SIGTTIN and SIGTTOU too and treat them like SIGTSTP.
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.11 2001/12/07 23:55:35 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Todd C. Miller <Todd.Miller@@courtesan.com>
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.11 2001/12/07 23:55:35 millert Exp $";
d56 2
a57 2
	struct sigaction sa, saveint, savehup, savequit, saveterm;
	struct sigaction savetstp, savettin, savettou;
d66 1
d83 1
a83 1
	 * things like SIGALRM and SIGPIPE for now.
d88 2
d91 1
a91 1
	(void)sigaction(SIGHUP, &sa, &savehup);
d134 2
a136 1
	(void)sigaction(SIGHUP, &savehup, NULL);
d138 1
d151 1
a151 1
		kill(getpid(), signo); 
a155 1
			signo = 0;
@


1.11
log
@o Turn off ECHONL in addition to ECHO
o Return NULL of read(2) returns -1
o Add ERRORS and STANDARDS sections
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.10 2001/12/07 22:16:48 millert Exp $	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.10 2001/12/07 22:16:48 millert Exp $";
d56 2
a57 1
	struct sigaction sa, saveint, savehup, savequit, saveterm, savetstp;
d92 2
d136 2
d147 4
a150 1
		if (signo == SIGTSTP) {
@


1.10
log
@Instead of restoring the tty mode, restoring the signal handler,
unblocking the signal and redelivering it just make all our
signal handler interupt system calls and set a flag.  We can just
deliver the signal at the end right before we would normally return.
This solves the SIG_IGN problem nicely and causes readpassphrase() to
return when someone hits ^C even if the handler is SIG_IGN.
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.9 2001/12/06 07:04:17 millert Exp $	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.9 2001/12/06 07:04:17 millert Exp $";
d52 2
a53 1
	int input, output;
d95 2
a96 2
		if (!(flags & RPP_ECHO_ON) && (term.c_lflag & ECHO))
			term.c_lflag &= ~ECHO;
d107 1
a107 1
	for (p = buf; read(input, &ch, 1) == 1 && ch != '\n' && ch != '\r';) {
d121 1
a145 1

d148 2
a149 1
	return(buf);
@


1.9
log
@Use TCSAFLUSH not TCSANOW.  I was only using TCSANOW during debugging...
@
text
@d1 1
a1 1
/*	$OpenBSD: readpassphrase.c,v 1.8 2001/12/06 05:20:50 millert Exp $	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.8 2001/12/06 05:20:50 millert Exp $";
d45 1
a45 5
/* Shared with signal handler below to restore state. */
static struct termios term, oterm;
static struct sigaction sa, saveint, savehup, savequit, saveterm, savetstp;
static int input;
static volatile sig_atomic_t susp;
d52 1
d54 2
a55 1
	int output;
d63 1
d83 1
a83 1
	sa.sa_flags = SA_RESTART;
a88 1
	sa.sa_flags = 0;	/* don't restart for SIGTSTP */
a103 1
redo:
a118 5
	if (susp) {
		/* Back from suspend. */
		susp = 0;
		goto redo;
	}
d125 1
a125 1
		(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm);
d133 14
d158 1
a158 1
static void handler(int signo)
a159 43
	struct sigaction osa;
	sigset_t nset;
	int save_errno;

	save_errno = errno;

	/* Restore tty modes */
	if (memcmp(&term, &oterm, sizeof(term)) != 0)
		(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &oterm);

	/*
	 * Save old handler and set to original value.
	 * Unblock receipt of 'signo' and resend the signal so that
	 * it is caught by the pre-readpassphrase handler.
	 */
	switch (signo) {
	case SIGINT:
		(void)sigaction(signo, &saveint, &osa);
		break;
	case SIGHUP:
		(void)sigaction(signo, &savehup, &osa);
		break;
	case SIGQUIT:
		(void)sigaction(signo, &savequit, &osa);
		break;
	case SIGTERM:
		(void)sigaction(signo, &saveterm, &osa);
		break;
	case SIGTSTP:
		(void)sigaction(signo, &savetstp, &osa);
		susp = 1;
		break;
	}
	(void)sigemptyset(&nset);
	(void)sigaddset(&nset, signo);
	(void)sigprocmask(SIG_UNBLOCK, &nset, NULL);
	(void)kill(getpid(), signo);
	(void)sigprocmask(SIG_BLOCK, &nset, NULL);
	(void)sigaction(signo, &osa, NULL);

	/* Put tty modes back */
	if (memcmp(&term, &oterm, sizeof(term)) != 0)
		(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);
d161 1
a161 1
	errno = save_errno;
@


1.8
log
@Fix a long standing annoyance with getpass/readpassphrase.  Instead of
blocking SIGINT and SIGTSTP, catch them (along with SIGHUP, SIGQUIT, SIGTERM).
We restore the tty mode as needed and then restore the original signal
handler and resend the signal.  For SIGTSTP, upon return from suspend
the user is re-prompted for the passphrase.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.7 2001/08/07 19:34:11 millert Exp $";
d162 1
a162 1
		(void)tcsetattr(input, TCSANOW|TCSASOFT, &oterm);
d196 1
a196 1
		(void)tcsetattr(input, TCSANOW|TCSASOFT, &term);
@


1.7
log
@Do the memset only if tcgetattr() fails just in case the failed
tcgetattr() mucked with the passed in struct termios in some way.
@
text
@d1 2
d31 1
a31 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.6 2001/08/07 19:29:20 millert Exp $";
d45 8
d54 1
a54 5
readpassphrase(prompt, buf, bufsiz, flags)
	const char *prompt;
	char *buf;
	size_t bufsiz;
	int flags;
a55 1
	struct termios term, oterm;
d57 1
a57 2
	int input, output;
	sigset_t oset, nset;
d79 3
a81 3
	 * We block SIGINT and SIGTSTP so the terminal is not left
	 * in an inconsistent state (ie: no echo).  It would probably
	 * be better to simply catch these though.
d83 9
a91 4
	sigemptyset(&nset);
	sigaddset(&nset, SIGINT);
	sigaddset(&nset, SIGTSTP);
	(void)sigprocmask(SIG_BLOCK, &nset, &oset);
d106 1
d122 5
d131 1
a131 1
	/* Restore old terminal settings and signal mask. */
d134 5
a138 1
	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
d145 1
a145 2
getpass(prompt)
        const char *prompt;
d150 49
@


1.6
log
@Keep a verbatim copy of the old struct termios instead of using
flags to keep track of what we changed.  Print a newline if echo
is off, even if we didn't turn it off ourselves.  Fixes art's
problem with a newline not being printed when piping to less.
@
text
@d29 1
a29 1
static const char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.5 2001/06/27 13:23:30 djm Exp $";
a84 2
	memset(&term, 0, sizeof(term));
	memset(&oterm, 0, sizeof(oterm));
d92 3
@


1.5
log
@typo, spotted by Tom Holroyd <tomh@@po.crl.go.jp>; ok deraadt@@
@
text
@d29 1
a29 1
static char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.4 2001/06/18 17:41:39 millert Exp $";
d50 1
a50 1
	struct termios term;
d52 1
a52 2
	u_char status;
	int echo, input, output;
d85 5
a89 5
	echo = 0;
	status = _POSIX_VDISABLE;
	if (tcgetattr(input, &term) == 0) {
		if (!(flags & RPP_ECHO_ON) && (term.c_lflag & ECHO)) {
			echo = 1;
d91 1
a91 3
		}
		if (term.c_cc[VSTATUS] != _POSIX_VDISABLE) {
			status = term.c_cc[VSTATUS];
a92 1
		}
a94 7
	if (!(flags & RPP_ECHO_ON)) {
		if (tcgetattr(input, &term) == 0 && (term.c_lflag & ECHO)) {
			echo = 1;
			term.c_lflag &= ~ECHO;
			(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);
		}
	}
d112 6
a117 9
	if (echo || status != _POSIX_VDISABLE) {
		if (echo) {
			(void)write(output, "\n", 1);
			term.c_lflag |= ECHO;
		}
		if (status != _POSIX_VDISABLE)
			term.c_cc[VSTATUS] = status;
		(void)tcsetattr(input, TCSAFLUSH|TCSASOFT, &term);
	}
@


1.4
log
@Fix a char vs. u_char problem I introduced in the last commit.
@
text
@d29 1
a29 1
static char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.3 2001/06/16 22:53:10 millert Exp $";
d112 1
a112 1
				ch = ch &= 0x7f;
@


1.3
log
@Disable the STATUS character when reading passwords -- people seem to
expect to be able to use ^T in a password.
@
text
@d29 1
a29 1
static char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.2 2000/11/29 18:41:12 millert Exp $";
d51 2
a52 1
	char ch, status, *p, *end;
@


1.2
log
@Don't print an extra newline after reading passphrase if echo was not
turned off since we already printed one from the user.
@
text
@d29 1
a29 1
static char rcsid[] = "$OpenBSD: readpassphrase.c,v 1.1 2000/11/21 00:48:37 millert Exp $";
d51 1
a51 1
	char ch, *p, *end;
d86 12
d122 7
a128 3
	if (echo) {
		(void)write(output, "\n", 1);
		term.c_lflag |= ECHO;
@


1.1
log
@Add readpasasphrase(3), a more flexible getpass(3) replacement.
getpass(3) is now implemented in terms of readpasasphrase(3).
@
text
@d29 1
a29 1
static char rcsid[] = "$OpenBSD: getpass.c,v 1.7 2000/01/13 19:36:21 millert Exp $";
a109 1
	(void)write(output, "\n", 1);
d111 1
@

