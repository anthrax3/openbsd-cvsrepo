head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.1.0.8
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.6
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.10.27.05.54.49;	author guenther;	state Exp;
branches;
next	1.9;
commitid	GqevjOlUxm0Irj52;

1.9
date	2014.07.21.01.51.10;	author guenther;	state Exp;
branches;
next	1.8;
commitid	ro8JUTvBpvQMiFY9;

1.8
date	2013.07.03.04.46.36;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.28.18.09.38;	author martynas;	state Exp;
branches;
next	1.6;

1.6
date	2012.12.05.23.20.00;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.26.11.43.01;	author martynas;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.26.09.24.52;	author martynas;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.07.00.25.39;	author martynas;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.30.17.28.15;	author martynas;	state Exp;
branches;
next	1.1;

1.1
date	2009.04.19.16.42.06;	author martynas;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Wrap the remaining math functions in libc: __fpclassify*(), __flt_rounds(),
and ldexp().

ok millert@@
@
text
@/*	$OpenBSD: ldexp.c,v 1.9 2014/07/21 01:51:10 guenther Exp $	*/
/* @@(#)s_scalbn.c 5.1 93/09/24 */
/* @@(#)fdlibm.h 5.1 93/09/24 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#include <sys/types.h>
#include <endian.h>
#include <float.h>
#include <math.h>

/* Bit fiddling routines copied from msun/src/math_private.h,v 1.15 */

#if (BYTE_ORDER == BIG_ENDIAN) || (defined(__arm__) && !defined(__VFP_FP__))

typedef union
{
  double value;
  struct
  {
    u_int32_t msw;
    u_int32_t lsw;
  } parts;
} ieee_double_shape_type;

#endif

#if (BYTE_ORDER == LITTLE_ENDIAN) && !(defined(__arm__) && !defined(__VFP_FP__))

typedef union
{
  double value;
  struct
  {
    u_int32_t lsw;
    u_int32_t msw;
  } parts;
} ieee_double_shape_type;

#endif

/* Get two 32 bit ints from a double.  */

#define EXTRACT_WORDS(ix0,ix1,d)				\
do {								\
  ieee_double_shape_type ew_u;					\
  ew_u.value = (d);						\
  (ix0) = ew_u.parts.msw;					\
  (ix1) = ew_u.parts.lsw;					\
} while (0)

/* Get the more significant 32 bit int from a double.  */

#define GET_HIGH_WORD(i,d)					\
do {								\
  ieee_double_shape_type gh_u;					\
  gh_u.value = (d);						\
  (i) = gh_u.parts.msw;						\
} while (0)

/* Set the more significant 32 bits of a double from an int.  */

#define SET_HIGH_WORD(d,v)					\
do {								\
  ieee_double_shape_type sh_u;					\
  sh_u.value = (d);						\
  sh_u.parts.msw = (v);						\
  (d) = sh_u.value;						\
} while (0)


static const double
two54   =  1.80143985094819840000e+16, /* 0x43500000, 0x00000000 */
twom54  =  5.55111512312578270212e-17, /* 0x3C900000, 0x00000000 */
huge   = 1.0e+300,
tiny   = 1.0e-300;

static double
_copysign(double x, double y)
{
	u_int32_t hx,hy;
	GET_HIGH_WORD(hx,x);
	GET_HIGH_WORD(hy,y);
	SET_HIGH_WORD(x,(hx&0x7fffffff)|(hy&0x80000000));
	return x;
}

double
ldexp(double x, int n)
{
	int32_t k,hx,lx;
	EXTRACT_WORDS(hx,lx,x);
        k = (hx&0x7ff00000)>>20;		/* extract exponent */
        if (k==0) {				/* 0 or subnormal x */
            if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */
	    x *= two54;
	    GET_HIGH_WORD(hx,x);
	    k = ((hx&0x7ff00000)>>20) - 54;
            if (n< -50000) return tiny*x; 	/*underflow*/
	    }
        if (k==0x7ff) return x+x;		/* NaN or Inf */
        k = k+n;
        if (k >  0x7fe) return huge*_copysign(huge,x); /* overflow  */
        if (k > 0) 				/* normal result */
	    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); return x;}
        if (k <= -54) {
            if (n > 50000) 	/* in case integer overflow in n+k */
		return huge*_copysign(huge,x);	/*overflow*/
	    else return tiny*_copysign(tiny,x); 	/*underflow*/
	}
        k += 54;				/* subnormal result */
	SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
        return x*twom54;
}
DEF_STRONG(ldexp);

#if	LDBL_MANT_DIG == DBL_MANT_DIG
__strong_alias(ldexpl, ldexp);
#endif	/* LDBL_MANT_DIG == DBL_MANT_DIG */
@


1.9
log
@Switch from <sys/endian.h> or <machine/endian.h> to the new,
being-standardized <endian.h>

ok deraadt@@ millert@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldexp.c,v 1.8 2013/07/03 04:46:36 espie Exp $	*/
d123 1
@


1.8
log
@test LDBL_MANT_DIG == DBL_MANT_DIG instead of hardcoding 53.
-> test becomes meaningful on vax
No actual change, no bump
okay martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ldexp.c,v 1.7 2013/03/28 18:09:38 martynas Exp $	*/
d16 1
a16 1
#include <machine/endian.h>
@


1.7
log
@Switch libc and libm to use strong aliases rather than weak aliases
where appropriate.  Among other things makes the symbols consistent
across all architectures (notably where ldbl mantissa is 53 bits).

While at it, kill unused LINTLIBRARY/PROTOLIB1 cruft which was there
to trick lint into recording the right prototypes for aliased
functions.  Most of the work done at the awesome n2k13 hackathon.

Agreed by kettenis@@, guenther@@, matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldexp.c,v 1.6 2012/12/05 23:20:00 deraadt Exp $	*/
d124 1
a124 1
#if	LDBL_MANT_DIG == 53
d126 1
a126 1
#endif	/* LDBL_MANT_DIG == 53 */
@


1.6
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ldexp.c,v 1.5 2011/07/26 11:43:01 martynas Exp $	*/
a14 2
/* LINTLIBRARY */

d125 1
a125 6
#ifdef	lint
/* PROTOLIB1 */
long double ldexpl(long double, int);
#else	/* lint */
__weak_alias(ldexpl, ldexp);
#endif	/* lint */
@


1.5
log
@At some point we've switched to the VFP floating-point--unlike FPA
it actually stores floats in natural-endian--therefore the existing
checks became wrong.

Take into account __VFP_FP__, effectively bringing back the old
behavior.  This way it will work now, and in the future when some
of our platforms are switched to FPA, where it's much faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldexp.c,v 1.4 2011/07/26 09:24:52 martynas Exp $	*/
a17 1
#include <sys/cdefs.h>
@


1.4
log
@__arm32__ -> __arm__, since our new compiler isn't defining the
former anymore.  OK miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldexp.c,v 1.3 2011/07/07 00:25:39 martynas Exp $	*/
d25 1
a25 1
#if (BYTE_ORDER == BIG_ENDIAN) || defined(__arm__)
d39 1
a39 1
#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(__arm__)
@


1.3
log
@Fix bit twiddling routines on ARM;  where floating-point word order
is big endian.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldexp.c,v 1.2 2011/05/30 17:28:15 martynas Exp $	*/
d25 1
a25 1
#if (BYTE_ORDER == BIG_ENDIAN) || defined(arm32)
d39 1
a39 1
#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(arm32)
@


1.2
log
@Trick lint into recording the right prototypes in the llib-lc.ln
database on platforms without extended-precision floating-point
support.

Seems like a reasonable approach to millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ldexp.c,v 1.1 2009/04/19 16:42:06 martynas Exp $	*/
d25 1
a25 1
#if BYTE_ORDER == BIG_ENDIAN
d39 1
a39 1
#if BYTE_ORDER == LITTLE_ENDIAN
@


1.1
log
@- ldexp implementation has issues.  switch to the one from libm
- remove frexp in hppa64, cloned from hppa
- move generic ieee754 implementations of modf and ldexp to gen
ok kettenis@@, "looks good" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d15 1
a15 3
#if 0
__FBSDID("$FreeBSD: src/lib/libc/gen/ldexp.c,v 1.1 2005/01/22 06:03:40 das Exp $");
#endif
d127 5
a131 2
#if LDBL_MANT_DIG == 53
#ifdef __weak_alias
d133 2
a134 2
#endif /* __weak_alias */
#endif /* LDBL_MANT_DIG == 53 */
@

