head	1.68;
access;
symbols
	OPENBSD_6_2_BASE:1.68
	OPENBSD_6_1:1.68.0.4
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.66.0.4
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.59.0.6
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.57.0.6
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.57.0.4
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.55.0.10
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.55.0.8
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.55.0.6
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.4
	OPENBSD_5_0:1.55.0.2
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.53.0.12
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.10
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.6
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.53.0.8
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.4
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.53.0.2
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.52.0.10
	OPENBSD_4_3_BASE:1.52
	OPENBSD_4_2:1.52.0.8
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.52.0.6
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.52.0.4
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.52.0.2
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.51.0.2
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.49.0.2
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.48.0.2
	OPENBSD_3_6_BASE:1.48
	OPENBSD_3_5:1.47.0.2
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.46.0.2
	OPENBSD_3_4_BASE:1.46
	OPENBSD_3_3:1.43.0.2
	OPENBSD_3_3_BASE:1.43
	OPENBSD_3_2:1.42.0.2
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	OPENBSD_3_0:1.40.0.2
	OPENBSD_3_0_BASE:1.40
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.33.0.4
	OPENBSD_2_7_BASE:1.33
	OPENBSD_2_6:1.33.0.2
	OPENBSD_2_6_BASE:1.33
	OPENBSD_2_5:1.32.0.4
	OPENBSD_2_5_BASE:1.32
	OPENBSD_2_4:1.32.0.2
	OPENBSD_2_4_BASE:1.32
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.21.0.2
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.19.0.2
	OPENBSD_2_1_BASE:1.19
	OPENBSD_2_0:1.15.0.2
	OPENBSD_2_0_BASE:1.15
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.68
date	2016.12.25.20.30.41;	author krw;	state Exp;
branches;
next	1.67;
commitid	ALHQLQcKN7UxSqzC;

1.67
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.66;
commitid	pqjnYVtACzQ9ctai;

1.66
date	2015.12.29.22.31.21;	author mmcc;	state Exp;
branches;
next	1.65;
commitid	SsI297GDBX2Mi9pA;

1.65
date	2015.10.16.16.54.38;	author tobias;	state Exp;
branches;
next	1.64;
commitid	KtogRf4q2duZUiF1;

1.64
date	2015.10.16.13.54.45;	author tobias;	state Exp;
branches;
next	1.63;
commitid	cjUYlZnnnrQH8akg;

1.63
date	2015.10.16.07.40.12;	author tobias;	state Exp;
branches;
next	1.62;
commitid	OLVX9paEIyGYBfig;

1.62
date	2015.10.04.06.59.57;	author guenther;	state Exp;
branches;
next	1.61;
commitid	JcWnC1OUfJGfFqAr;

1.61
date	2015.08.27.04.37.58;	author guenther;	state Exp;
branches;
next	1.60;
commitid	JIyCoJVQ7Ljz0vfJ;

1.60
date	2015.08.26.01.54.09;	author guenther;	state Exp;
branches;
next	1.59;
commitid	ZWoe9OaBBikaM1w5;

1.59
date	2015.02.06.23.21.58;	author millert;	state Exp;
branches;
next	1.58;
commitid	STdsVrA5MGLlnbLm;

1.58
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	0DYulI8hhujBHMcR;

1.57
date	2014.01.19.20.48.57;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2013.10.17.08.02.20;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.03.19.55.28;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.08.15.18.18;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.04.21.12.50;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.28.17.50.32;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.25.15.38.47;	author otto;	state Exp;
branches;
next	1.49;

1.49
date	2004.09.15.19.00.43;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.30.23.14.32;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2003.08.27.17.16.00;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.25.21.16.47;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.10.04.02.49;	author david;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.11.06.39.47;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.16.21.27.23;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2001.07.09.06.57.43;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.11.12.51.23;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.11.12.33.09;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.01.18.49.35;	author aaron;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.03.02.37.27;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.25.05.33.04;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.12.12.47.58;	author art;	state Exp;
branches;
next	1.33;

1.33
date	99.08.17.09.13.12;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	98.10.04.17.24.17;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	98.09.24.06.17.47;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	98.09.08.15.13.31;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	98.09.07.03.23.55;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	98.09.05.16.30.07;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	98.08.23.17.48.02;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	98.08.21.20.33.12;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	98.08.21.19.25.36;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	98.01.20.22.10.48;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.01.02.05.32.47;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.12.15.10.19.17;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.07.23.21.04.06;	author kstailey;	state Exp;
branches;
next	1.20;

1.20
date	97.07.01.05.59.44;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.01.10.18.29.48;	author etheisen;	state Exp;
branches;
next	1.18;

1.18
date	97.01.09.03.49.38;	author rahnds;	state Exp;
branches;
next	1.17;

1.17
date	96.12.23.02.42.22;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.10.27.20.34.37;	author etheisen;	state Exp;
branches;
next	1.15;

1.15
date	96.09.15.09.31.04;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	96.08.19.08.25.09;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	96.07.30.09.22.43;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.06.17.06.40.53;	author etheisen;	state Exp;
branches;
next	1.11;

1.11
date	96.06.14.05.01.36;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.30.16.16.53;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	96.05.29.03.05.14;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.28.14.11.21;	author etheisen;	state Exp;
branches;
next	1.7;

1.7
date	96.05.24.10.59.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.17.20.03.59;	author pefo;	state Exp;
branches;
next	1.5;

1.5
date	95.12.04.14.23.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.10.31.16.58.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.10.30.14.13.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.30.13.50.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.57;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.57;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.68
log
@gcc says "if you define labels and don't use them, I will whine."

ok tom@@
@
text
@/*	$OpenBSD: nlist.c,v 1.67 2016/09/21 04:38:56 guenther Exp $ */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <a.out.h>		/* pulls in nlist.h */
#include <elf_abi.h>

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

int	__fdnlist(int, struct nlist *);
PROTO_NORMAL(__fdnlist);

#define	ISLAST(p)	(p->n_un.n_name == 0 || p->n_un.n_name[0] == 0)

/*
 * __elf_is_okay__ - Determine if ehdr really
 * is ELF and valid for the target platform.
 *
 * WARNING:  This is NOT a ELF ABI function and
 * as such its use should be restricted.
 */
static int
__elf_is_okay__(Elf_Ehdr *ehdr)
{
	int retval = 0;
	/*
	 * We need to check magic, class size, endianess,
	 * and version before we look at the rest of the
	 * Elf_Ehdr structure.  These few elements are
	 * represented in a machine independent fashion.
	 */
	if (IS_ELF(*ehdr) &&
	    ehdr->e_ident[EI_CLASS] == ELF_TARG_CLASS &&
	    ehdr->e_ident[EI_DATA] == ELF_TARG_DATA &&
	    ehdr->e_ident[EI_VERSION] == ELF_TARG_VER) {

		/* Now check the machine dependent header */
		if (ehdr->e_machine == ELF_TARG_MACH &&
		    ehdr->e_version == ELF_TARG_VER)
			retval = 1;
	}

	if (ehdr->e_shentsize != sizeof(Elf_Shdr))
		return 0;

	return retval;
}

int
__fdnlist(int fd, struct nlist *list)
{
	struct nlist *p;
	caddr_t strtab;
	Elf_Off symoff = 0, symstroff = 0;
	Elf_Word symsize = 0, symstrsize = 0;
	Elf_Sword nent, cc, i;
	Elf_Sym sbuf[1024];
	Elf_Sym *s;
	Elf_Ehdr ehdr;
	Elf_Shdr *shdr = NULL;
	Elf_Word shdr_size;
	struct stat st;
	int usemalloc = 0;
	size_t left, len;

	/* Make sure obj is OK */
	if (pread(fd, &ehdr, sizeof(Elf_Ehdr), 0) != sizeof(Elf_Ehdr) ||
	    !__elf_is_okay__(&ehdr) || fstat(fd, &st) < 0)
		return (-1);

	/* calculate section header table size */
	shdr_size = ehdr.e_shentsize * ehdr.e_shnum;

	/* Make sure it's not too big to mmap */
	if (SIZE_MAX - ehdr.e_shoff < shdr_size ||
	    (S_ISREG(st.st_mode) && ehdr.e_shoff + shdr_size > st.st_size)) {
		errno = EFBIG;
		return (-1);
	}

	/* mmap section header table */
	shdr = mmap(NULL, shdr_size, PROT_READ, MAP_SHARED|MAP_FILE, fd,
	    ehdr.e_shoff);
	if (shdr == MAP_FAILED) {
		usemalloc = 1;
		if ((shdr = malloc(shdr_size)) == NULL)
			return (-1);

		if (pread(fd, shdr, shdr_size, ehdr.e_shoff) != shdr_size) {
			free(shdr);
			return (-1);
		}
	}

	/*
	 * Find the symbol table entry and its corresponding
	 * string table entry.	Version 1.1 of the ABI states
	 * that there is only one symbol table but that this
	 * could change in the future.
	 */
	for (i = 0; i < ehdr.e_shnum; i++) {
		if (shdr[i].sh_type == SHT_SYMTAB) {
			if (shdr[i].sh_link >= ehdr.e_shnum)
				continue;
			symoff = shdr[i].sh_offset;
			symsize = shdr[i].sh_size;
			symstroff = shdr[shdr[i].sh_link].sh_offset;
			symstrsize = shdr[shdr[i].sh_link].sh_size;
			break;
		}
	}

	/* Flush the section header table */
	if (usemalloc)
		free(shdr);
	else
		munmap((caddr_t)shdr, shdr_size);

	/*
	 * clean out any left-over information for all valid entries.
	 * Type and value defined to be 0 if not found; historical
	 * versions cleared other and desc as well.  Also figure out
	 * the largest string length so don't read any more of the
	 * string table than we have to.
	 *
	 * XXX clearing anything other than n_type and n_value violates
	 * the semantics given in the man page.
	 */
	nent = 0;
	for (p = list; !ISLAST(p); ++p) {
		p->n_type = 0;
		p->n_other = 0;
		p->n_desc = 0;
		p->n_value = 0;
		++nent;
	}

	/* Don't process any further if object is stripped. */
	/* ELFism - dunno if stripped by looking at header */
	if (symoff == 0)
		return nent;

	/* Check for files too large to mmap. */
	if (SIZE_MAX - symstrsize < symstroff ||
	    (S_ISREG(st.st_mode) && symstrsize + symstroff > st.st_size)) {
		errno = EFBIG;
		return (-1);
	}

	/*
	 * Map string table into our address space.  This gives us
	 * an easy way to randomly access all the strings, without
	 * making the memory allocation permanent as with malloc/free
	 * (i.e., munmap will return it to the system).
	 */
	if (usemalloc) {
		if ((strtab = malloc(symstrsize)) == NULL)
			return (-1);
		if (pread(fd, strtab, symstrsize, symstroff) != symstrsize) {
			free(strtab);
			return (-1);
		}
	} else {
		strtab = mmap(NULL, symstrsize, PROT_READ, MAP_SHARED|MAP_FILE,
		    fd, symstroff);
		if (strtab == MAP_FAILED)
			return (-1);
	}

	while (symsize >= sizeof(Elf_Sym)) {
		cc = MINIMUM(symsize, sizeof(sbuf));
		if (pread(fd, sbuf, cc, symoff) != cc)
			break;
		symsize -= cc;
		symoff += cc;
		for (s = sbuf; cc > 0; ++s, cc -= sizeof(*s)) {
			Elf_Word soff = s->st_name;

			if (soff == 0 || soff >= symstrsize)
				continue;
			left = symstrsize - soff;

			for (p = list; !ISLAST(p); p++) {
				char *sym;

				/*
				 * First we check for the symbol as it was
				 * provided by the user. If that fails
				 * and the first char is an '_', skip over
				 * the '_' and try again.
				 * XXX - What do we do when the user really
				 *       wants '_foo' and there are symbols
				 *       for both 'foo' and '_foo' in the
				 *	 table and 'foo' is first?
				 */
				sym = p->n_un.n_name;
				len = strlen(sym);

				if ((len >= left ||
				    strcmp(&strtab[soff], sym) != 0) &&
				    (sym[0] != '_' || len - 1 >= left ||
				     strcmp(&strtab[soff], sym + 1) != 0))
					continue;

				p->n_value = s->st_value;

				/* XXX - type conversion */
				/*	 is pretty rude. */
				switch(ELF_ST_TYPE(s->st_info)) {
				case STT_NOTYPE:
					switch (s->st_shndx) {
					case SHN_UNDEF:
						p->n_type = N_UNDF;
						break;
					case SHN_ABS:
						p->n_type = N_ABS;
						break;
					case SHN_COMMON:
						p->n_type = N_COMM;
						break;
					default:
						p->n_type = N_COMM | N_EXT;
						break;
					}
					break;
				case STT_OBJECT:
					p->n_type = N_DATA;
					break;
				case STT_FUNC:
					p->n_type = N_TEXT;
					break;
				case STT_FILE:
					p->n_type = N_FN;
					break;
				}
				if (ELF_ST_BIND(s->st_info) == STB_LOCAL)
					p->n_type = N_EXT;
				p->n_desc = 0;
				p->n_other = 0;
				if (--nent <= 0)
					break;
			}
		}
	}
	if (usemalloc)
		free(strtab);
	else
		munmap(strtab, symstrsize);
	return (nent);
}
DEF_STRONG(__fdnlist);

int
nlist(const char *name, struct nlist *list)
{
	int fd, n;

	fd = open(name, O_RDONLY, 0);
	if (fd < 0)
		return (-1);
	n = __fdnlist(fd, list);
	(void)close(fd);
	return (n);
}
@


1.67
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.66 2015/12/29 22:31:21 mmcc Exp $ */
a281 1
elf_done:
@


1.66
log
@Verify that the section header size supplied in the ELF header is what
we expect it to be. This prevents out-of-bounds access or excessive
memory allocation on a malformed ELF header.

Found by Serguey Parkhomovsky with AFL. Improved by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.65 2015/10/16 16:54:38 tobias Exp $ */
d104 1
a104 1
	if (pread(fd, &ehdr, sizeof(Elf_Ehdr), (off_t)0) != sizeof(Elf_Ehdr) ||
d119 2
a120 2
	shdr = (Elf_Shdr *)mmap(NULL, (size_t)shdr_size, PROT_READ,
	    MAP_SHARED|MAP_FILE, fd, (off_t) ehdr.e_shoff);
d126 1
a126 2
		if (pread(fd, shdr, shdr_size, (off_t)ehdr.e_shoff) !=
		    shdr_size) {
d196 1
a196 2
		if (pread(fd, strtab, symstrsize, (off_t)symstroff) !=
		    symstrsize) {
d201 2
a202 2
		strtab = mmap(NULL, (size_t)symstrsize, PROT_READ,
		    MAP_SHARED|MAP_FILE, fd, (off_t) symstroff);
d209 1
a209 1
		if (pread(fd, sbuf, cc, (off_t)symoff) != cc)
@


1.65
log
@Check file sizes only for regular files. The current code breaks savecore
due to its kvm handling.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.64 2015/10/16 13:54:45 tobias Exp $ */
d79 3
@


1.64
log
@Merge nlist out of boundary access fix with other nlist implementations.
While at it, merge style and typo fixes back into nlist(3), too.

ok deraadt, jsing, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.63 2015/10/16 07:40:12 tobias Exp $ */
d110 1
a110 1
	    ehdr.e_shoff + shdr_size > st.st_size) {
d180 1
a180 1
	    symstrsize + symstroff > st.st_size) {
@


1.63
log
@Validate parsed ELF values to prevent out of boundary accesses.
While at it, return proper return value when encountering a stripped
binary. Instead of -1 (illegal file), it should be the amount of symbols
that were tried to be resolved.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.62 2015/10/04 06:59:57 guenther Exp $ */
d74 1
a74 1
		/* Now check the machine dependant header */
d123 2
a124 1
		if (pread(fd, shdr, shdr_size, (off_t)ehdr.e_shoff) != shdr_size) {
d194 2
a195 1
		if (pread(fd, strtab, symstrsize, (off_t)symstroff) != symstrsize) {
d272 1
a272 2
				if (ELF_ST_BIND(s->st_info) ==
				    STB_LOCAL)
@


1.62
log
@__fdnlist() is exported for libkvm, but the internal call can go direct
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.61 2015/08/27 04:37:58 guenther Exp $ */
d98 1
d109 2
a110 1
	if (shdr_size > SIZE_MAX) {
d137 2
d153 24
d178 2
a179 2
	/* XXX is this really possible? */
	if (symstrsize > SIZE_MAX) {
d183 1
a202 18
	/*
	 * clean out any left-over information for all valid entries.
	 * Type and value defined to be 0 if not found; historical
	 * versions cleared other and desc as well.  Also figure out
	 * the largest string length so don't read any more of the
	 * string table than we have to.
	 *
	 * XXX clearing anything other than n_type and n_value violates
	 * the semantics given in the man page.
	 */
	nent = 0;
	for (p = list; !ISLAST(p); ++p) {
		p->n_type = 0;
		p->n_other = 0;
		p->n_desc = 0;
		p->n_value = 0;
		++nent;
	}
d204 1
a204 6
	/* Don't process any further if object is stripped. */
	/* ELFism - dunno if stripped by looking at header */
	if (symoff == 0)
		goto elf_done;

	while (symsize > 0) {
d211 1
a211 1
			int soff = s->st_name;
d213 1
a213 1
			if (soff == 0)
d215 2
d226 1
a226 1
				 *       wants '_foo' and the are symbols
d231 5
a235 2
				if (strcmp(&strtab[soff], sym) != 0 &&
				    (sym[0] != '_' ||
@


1.61
log
@ELF uberalles: remove #ifdef _NLIST_DO_ELF tests
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.60 2015/08/26 01:54:09 guenther Exp $ */
d48 1
d276 1
@


1.60
log
@Hide many (194!) symbols that nothing should be using.
Delete exect(2); it wasn't portable across archs and nothing used it.

ports test build by naddy@@
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.59 2015/02/06 23:21:58 millert Exp $ */
a42 2

#ifdef _NLIST_DO_ELF
a43 1
#endif
a50 1
#ifdef _NLIST_DO_ELF
a274 1
#endif /* _NLIST_DO_ELF */
@


1.59
log
@SIZE_MAX is standard, we should be using it in preference to the
obsolete SIZE_T_MAX.  OK miod@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.58 2015/01/16 16:48:51 deraadt Exp $ */
a50 3
#ifdef _NLIST_DO_ELF
int	__elf_is_okay__(Elf_Ehdr *ehdr);
#endif
d62 1
a62 1
int
@


1.58
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.57 2014/01/19 20:48:57 deraadt Exp $ */
d37 1
a41 1
#include <limits.h>
d114 1
a114 1
	if (shdr_size > SIZE_T_MAX) {
d157 1
a157 1
	if (symstrsize > SIZE_T_MAX) {
@


1.57
log
@Rename the hidden symbol __elf_fdnlist to __fdnlist, and remove the
format handling wrapper.  __fdnlist is used by libkvm.  Avoid cranking
libc because the time is inconvenient, and __elf_fdnlist is not used
anywhere.
ok millert jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.56 2013/10/17 08:02:20 deraadt Exp $ */
a31 1
#include <sys/param.h>
d41 1
d48 2
d205 1
a205 1
		cc = MIN(symsize, sizeof(sbuf));
@


1.56
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.55 2011/07/03 19:55:28 krw Exp $ */
a48 1
int	__elf_fdnlist(int, struct nlist *);
d88 1
a88 1
__elf_fdnlist(int fd, struct nlist *list)
a280 23


static struct nlist_handlers {
	int	(*fn)(int fd, struct nlist *list);
} nlist_fn[] = {
#ifdef _NLIST_DO_ELF
	{ __elf_fdnlist },
#endif
};

int
__fdnlist(int fd, struct nlist *list)
{
	int n = -1, i;

	for (i = 0; i < sizeof(nlist_fn)/sizeof(nlist_fn[0]); i++) {
		n = (nlist_fn[i].fn)(fd, list);
		if (n != -1)
			break;
	}
	return (n);
}

@


1.55
log
@"it's" -> "its" in a couple of comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.54 2011/04/08 15:18:18 deraadt Exp $ */
a47 4
#ifdef _NLIST_DO_ECOFF
#include <sys/exec_ecoff.h>
#endif

a48 2
int	__aout_fdnlist(int, struct nlist *);
int	__ecoff_fdnlist(int, struct nlist *);
a55 204
#ifdef _NLIST_DO_AOUT
int
__aout_fdnlist(int fd, struct nlist *list)
{
	struct nlist *p, *s;
	char *strtab;
	off_t symoff, stroff;
	u_long symsize;
	int nent, cc;
	int strsize, usemalloc = 0;
	struct nlist nbuf[1024];
	struct exec exec;

	if (pread(fd, &exec, sizeof(exec), (off_t)0) != sizeof(exec) ||
	    N_BADMAG(exec) || exec.a_syms == 0)
		return (-1);

	stroff = N_STROFF(exec);
	symoff = N_SYMOFF(exec);
	symsize = exec.a_syms;

	/* Read in the size of the string table. */
	if (pread(fd, (void *)&strsize, sizeof(strsize), stroff) !=
	    sizeof(strsize))
		return (-1);
	else
		stroff += sizeof(strsize);

	/*
	 * Read in the string table.  We try mmap, but that will fail
	 * for /dev/ksyms so fall back on malloc.  Since OpenBSD's malloc(3)
	 * returns memory to the system on free this does not cause bloat.
	 */
	strsize -= sizeof(strsize);
	strtab = mmap(NULL, (size_t)strsize, PROT_READ, MAP_SHARED|MAP_FILE,
	    fd, stroff);
	if (strtab == MAP_FAILED) {
		usemalloc = 1;
		if ((strtab = (char *)malloc(strsize)) == NULL)
			return (-1);
		errno = EIO;
		if (pread(fd, strtab, strsize, stroff) != strsize) {
			nent = -1;
			goto aout_done;
		}
	}

	/*
	 * clean out any left-over information for all valid entries.
	 * Type and value defined to be 0 if not found; historical
	 * versions cleared other and desc as well.  Also figure out
	 * the largest string length so don't read any more of the
	 * string table than we have to.
	 *
	 * XXX clearing anything other than n_type and n_value violates
	 * the semantics given in the man page.
	 */
	nent = 0;
	for (p = list; !ISLAST(p); ++p) {
		p->n_type = 0;
		p->n_other = 0;
		p->n_desc = 0;
		p->n_value = 0;
		++nent;
	}

	while (symsize > 0) {
		cc = MIN(symsize, sizeof(nbuf));
		if (pread(fd, nbuf, cc, symoff) != cc)
			break;
		symsize -= cc;
		symoff += cc;
		for (s = nbuf; cc > 0; ++s, cc -= sizeof(*s)) {
			char *sname = strtab + s->n_un.n_strx - sizeof(int);

			if (s->n_un.n_strx == 0 || (s->n_type & N_STAB) != 0)
				continue;
			for (p = list; !ISLAST(p); p++) {
				char *pname = p->n_un.n_name;

				if (*sname != '_' && *pname == '_')
					pname++;
				if (!strcmp(sname, pname)) {
					p->n_value = s->n_value;
					p->n_type = s->n_type;
					p->n_desc = s->n_desc;
					p->n_other = s->n_other;
					if (--nent <= 0)
						break;
				}
			}
		}
	}
aout_done:
	if (usemalloc)
		free(strtab);
	else
		munmap(strtab, strsize);
	return (nent);
}
#endif /* _NLIST_DO_AOUT */

#ifdef _NLIST_DO_ECOFF
#define check(off, size)	((off < 0) || (off + size > mappedsize))
#define	BAD			do { rv = -1; goto out; } while (0)
#define	BADUNMAP		do { rv = -1; goto unmap; } while (0)

int
__ecoff_fdnlist(int fd, struct nlist *list)
{
	struct nlist *p;
	struct ecoff_exechdr *exechdrp;
	struct ecoff_symhdr *symhdrp;
	struct ecoff_extsym *esyms;
	struct stat st;
	char *mappedfile;
	size_t mappedsize;
	u_long symhdroff, extstroff;
	u_int symhdrsize;
	int rv, nent;
	long i, nesyms;

	rv = -3;

	if (fstat(fd, &st) < 0)
		BAD;
	if (st.st_size > SIZE_T_MAX) {
		errno = EFBIG;
		BAD;
	}
	mappedsize = st.st_size;
	mappedfile = mmap(NULL, mappedsize, PROT_READ, MAP_SHARED|MAP_FILE,
	    fd, 0);
	if (mappedfile == MAP_FAILED)
		BAD;

	if (check(0, sizeof *exechdrp))
		BADUNMAP;
	exechdrp = (struct ecoff_exechdr *)&mappedfile[0];

	if (ECOFF_BADMAG(exechdrp))
		BADUNMAP;

	symhdroff = exechdrp->f.f_symptr;
	symhdrsize = exechdrp->f.f_nsyms;

	if (check(symhdroff, sizeof *symhdrp) ||
	    sizeof *symhdrp != symhdrsize)
		BADUNMAP;
	symhdrp = (struct ecoff_symhdr *)&mappedfile[symhdroff];

	nesyms = symhdrp->esymMax;
	if (check(symhdrp->cbExtOffset, nesyms * sizeof *esyms))
		BADUNMAP;
	esyms = (struct ecoff_extsym *)&mappedfile[symhdrp->cbExtOffset];
	extstroff = symhdrp->cbSsExtOffset;

	/*
	 * clean out any left-over information for all valid entries.
	 * Type and value defined to be 0 if not found; historical
	 * versions cleared other and desc as well.
	 *
	 * XXX clearing anything other than n_type and n_value violates
	 * the semantics given in the man page.
	 */
	nent = 0;
	for (p = list; !ISLAST(p); ++p) {
		p->n_type = 0;
		p->n_other = 0;
		p->n_desc = 0;
		p->n_value = 0;
		++nent;
	}

	for (i = 0; i < nesyms; i++) {
		for (p = list; !ISLAST(p); p++) {
			char *nlistname;
			char *symtabname;

			nlistname = p->n_un.n_name;
			if (*nlistname == '_')
				nlistname++;
			symtabname =
			    &mappedfile[extstroff + esyms[i].es_strindex];

			if (!strcmp(symtabname, nlistname)) {
				p->n_value = esyms[i].es_value;
				p->n_type = N_EXT;		/* XXX */
				p->n_desc = 0;			/* XXX */
				p->n_other = 0;			/* XXX */
				if (--nent <= 0)
					break;
			}
		}
	}
	rv = nent;

unmap:
	munmap(mappedfile, mappedsize);
out:
	return (rv);
}
#endif /* _NLIST_DO_ECOFF */

a286 3
#ifdef _NLIST_DO_AOUT
	{ __aout_fdnlist },
#endif
a288 3
#endif
#ifdef _NLIST_DO_ECOFF
	{ __ecoff_fdnlist },
@


1.54
log
@a_syms is an int, not a pointer; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.53 2008/06/04 21:12:50 deraadt Exp $ */
d272 1
a272 1
 * as such it's use should be restricted.
d343 1
a343 1
	 * Find the symbol table entry and it's corresponding
@


1.53
log
@olf support starts to die (easy stuff first); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.52 2005/11/28 17:50:32 deraadt Exp $ */
d76 1
a76 1
	    N_BADMAG(exec) || exec.a_syms == NULL)
@


1.52
log
@some nice off_t casts to please lint
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.51 2005/08/08 08:05:34 espie Exp $ */
a45 1
#include <olf_abi.h>
d284 1
a284 1
	if ((IS_ELF(*ehdr) || IS_OLF(*ehdr)) &&
@


1.51
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d337 1
a337 1
		if (pread(fd, shdr, shdr_size, ehdr.e_shoff) != shdr_size) {
d380 1
a380 1
		if (pread(fd, strtab, symstrsize, symstroff) != symstrsize) {
d416 1
a416 1
		if (pread(fd, sbuf, cc, symoff) != cc)
@


1.50
log
@deregister (and deauto!). ok millert@@ marco@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: nlist.c,v 1.49 2004/09/15 19:00:43 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.49
log
@pretty
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.48 2004/05/18 02:05:52 jfb Exp $";
d61 1
a61 1
int	__elf_is_okay__(register Elf_Ehdr *ehdr);
d70 5
a74 5
	register struct nlist *p, *s;
	register char *strtab;
	register off_t symoff, stroff;
	register u_long symsize;
	register int nent, cc;
d281 1
a281 1
	register int retval = 0;
d305 5
a309 5
	register struct nlist *p;
	register caddr_t strtab;
	register Elf_Off symoff = 0, symstroff = 0;
	register Elf_Word symsize = 0, symstrsize = 0;
	register Elf_Sword nent, cc, i;
@


1.48
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.47 2004/01/30 23:14:32 millert Exp $";
d339 1
@


1.47
log
@Fix a logic thinko I made in rev. 1.27.  This fixes nlist when
the user passes in a symbol name with an underscore pre-pended
on ELF systems.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.46 2003/08/27 17:16:00 mickey Exp $";
d68 1
a68 3
__aout_fdnlist(fd, list)
	register int fd;
	register struct nlist *list;
d174 1
a174 3
__ecoff_fdnlist(fd, list)
	register int fd;
	register struct nlist *list;
d279 1
a279 2
__elf_is_okay__(ehdr)
	register Elf_Ehdr *ehdr;
d303 1
a303 3
__elf_fdnlist(fd, list)
	register int fd;
	register struct nlist *list;
d512 1
a512 3
__fdnlist(fd, list)
	register int fd;
	register struct nlist *list;
d526 1
a526 3
nlist(name, list)
	const char *name;
	struct nlist *list;
@


1.46
log
@sync STT_NOTYPE parsign w/ kvm_mkdb; pb@@ testing
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.45 2003/06/25 21:16:47 deraadt Exp $";
d439 3
a441 3
				 * provided by the user. If that fails,
				 * skip the first char if it's an '_' and
				 * try again.
d449 1
a449 1
				    ((sym[0] == '_') &&
@


1.45
log
@protos
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.44 2003/06/02 20:18:34 millert Exp $";
d459 14
a472 1
					p->n_type = N_UNDF;
@


1.44
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.43 2003/03/10 04:02:49 david Exp $";
d54 8
@


1.43
log
@duplicate words and spelling fixes in comments
ok miod@@
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.42 2002/06/11 06:39:47 art Exp $";
@


1.42
log
@random cleanup that's cheaper to commit than to remove from my tree.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.41 2002/02/16 21:27:23 millert Exp $";
d287 1
a287 1
	 * represented in a machine independant fashion.
@


1.41
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.40 2001/07/09 06:57:43 deraadt Exp $";
d426 1
a426 1
			register int soff = s->st_name;
@


1.40
log
@a first pass at -Wall
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.39 2001/05/11 12:51:23 art Exp $";
d488 1
a488 1
	int	(*fn) __P((int fd, struct nlist *list));
@


1.39
log
@MAP_SHARED is better. Maybe we're trying to map /dev/ksyms.
And we'll never write to those mappings anyway.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.38 2001/05/11 12:33:09 art Exp $";
a431 1
				int again = 0;
@


1.38
log
@MAP_COPY -> MAP_PRIVATE
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.37 2001/05/01 18:49:35 aaron Exp $";
d98 1
a98 1
	strtab = mmap(NULL, (size_t)strsize, PROT_READ, MAP_PRIVATE|MAP_FILE,
d197 1
a197 1
	mappedfile = mmap(NULL, mappedsize, PROT_READ, MAP_PRIVATE|MAP_FILE,
d337 1
a337 1
	    MAP_PRIVATE|MAP_FILE, fd, (off_t) ehdr.e_shoff);
d391 1
a391 1
		    MAP_PRIVATE|MAP_FILE, fd, (off_t) symstroff);
@


1.37
log
@Use pread() to avoid lseek() abuse, from art's todo list. Tested with
config(8) UKC; millert@@ ok
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.36 2001/02/03 02:37:27 art Exp $";
d98 1
a98 1
	strtab = mmap(NULL, (size_t)strsize, PROT_READ, MAP_COPY|MAP_FILE,
d197 1
a197 1
	mappedfile = mmap(NULL, mappedsize, PROT_READ, MAP_COPY|MAP_FILE,
d337 1
a337 1
	    MAP_COPY|MAP_FILE, fd, (off_t) ehdr.e_shoff);
d391 1
a391 1
		    MAP_COPY|MAP_FILE, fd, (off_t) symstroff);
@


1.36
log
@Fix the the elf nlist for cases where we can't mmap the headers.
This makes /dev/ksyms work (when that code is commited).
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.35 2001/01/25 05:33:04 art Exp $";
d70 1
a70 1
	register off_t symoff;
d77 1
a77 2
	if (lseek(fd, (off_t)0, SEEK_SET) == -1 ||
	    read(fd, &exec, sizeof(exec)) != sizeof(exec) ||
d81 1
d86 2
a87 3
	if (lseek(fd, N_STROFF(exec), SEEK_SET) == -1)
		return (-1);
	if (read(fd, (void *)&strsize, sizeof(strsize)) != sizeof(strsize))
d89 2
d99 1
a99 1
	    fd, lseek(fd, 0, SEEK_CUR));
d105 1
a105 1
		if (read(fd, strtab, strsize) != strsize) {
a128 4
	if (lseek(fd, symoff, SEEK_SET) == -1) {
		nent = -1;
		goto aout_done;
	}
d132 1
a132 1
		if (read(fd, nbuf, cc) != cc)
d135 1
d322 2
a323 4
	if (lseek(fd, (off_t)0, SEEK_SET) == -1 ||
	    read(fd, &ehdr, sizeof(Elf_Ehdr)) != sizeof(Elf_Ehdr) ||
	    !__elf_is_okay__(&ehdr) ||
	    fstat(fd, &st) < 0)
a418 5
	if (lseek(fd, (off_t) symoff, SEEK_SET) == -1) {
		nent = -1;
		goto elf_done;
	}

d421 1
a421 1
		if (read(fd, sbuf, cc) != cc)
@


1.35
log
@ELf-size independent nlist.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.34 2000/10/12 12:47:58 art Exp $";
d321 1
d342 9
a350 2
	if (shdr == MAP_FAILED)
		return (-1);
d369 4
a372 1
	munmap((caddr_t)shdr, shdr_size);
d386 13
a398 4
	strtab = mmap(NULL, (size_t)symstrsize, PROT_READ, MAP_COPY|MAP_FILE,
	    fd, (off_t) symstroff);
	if (strtab == MAP_FAILED)
		return (-1);
d488 4
a491 1
	munmap(strtab, symstrsize);
@


1.34
log
@MAP_FAILED, not -1.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.33 1999/08/17 09:13:12 millert Exp $";
d282 1
a282 1
	register Elf32_Ehdr *ehdr;
d288 1
a288 1
	 * Elf32_Ehdr structure.  These few elements are
d301 1
d312 8
a319 8
	register Elf32_Off symoff = 0, symstroff = 0;
	register Elf32_Word symsize = 0, symstrsize = 0;
	register Elf32_Sword nent, cc, i;
	Elf32_Sym sbuf[1024];
	Elf32_Sym *s;
	Elf32_Ehdr ehdr;
	Elf32_Shdr *shdr = NULL;
	Elf32_Word shdr_size;
d324 1
a324 1
	    read(fd, &ehdr, sizeof(Elf32_Ehdr)) != sizeof(Elf32_Ehdr) ||
d339 1
a339 1
	shdr = (Elf32_Shdr *)mmap(NULL, (size_t)shdr_size, PROT_READ,
d413 1
d420 3
d424 8
a431 3
				 * XXX - ABI crap, they
				 * really fucked this up
				 * for MIPS and PowerPC
d433 23
a455 30
				if (!strcmp(&strtab[soff],
				    ((ehdr.e_machine == EM_MIPS) ||
				     (ehdr.e_machine == EM_PPC)) ?
				    p->n_un.n_name+1 :
				    p->n_un.n_name)) {
					p->n_value = s->st_value;

					/* XXX - type conversion */
					/*	 is pretty rude. */
					switch(ELF32_ST_TYPE(s->st_info)) {
					case STT_NOTYPE:
						p->n_type = N_UNDF;
						break;
					case STT_OBJECT:
						p->n_type = N_DATA;
						break;
					case STT_FUNC:
						p->n_type = N_TEXT;
						break;
					case STT_FILE:
						p->n_type = N_FN;
						break;
					}
					if (ELF32_ST_BIND(s->st_info) ==
					    STB_LOCAL)
						p->n_type = N_EXT;
					p->n_desc = 0;
					p->n_other = 0;
					if (--nent <= 0)
						break;
d457 7
@


1.33
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.32 1998/10/04 17:24:17 millert Exp $";
d340 1
a340 1
	if (shdr == (Elf32_Shdr *)-1)
d376 1
a376 1
	if (strtab == (char *)-1)
@


1.32
log
@For a.out, try mmap first (like we used to do) and only malloc() if that fails (for ksyms).  Also clean up some mmap/malloc leaks.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.31 1998/09/24 06:17:47 millert Exp $";
a41 1
#include <sys/file.h>
d44 1
@


1.31
log
@back out gzip support, it will not make it for 2.4
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.27 1998/08/23 17:48:02 millert Exp $";
d70 1
a70 1
	register off_t stroff, symoff;
d73 1
a73 1
	int strsize;
a83 1
	stroff = symoff + symsize;
d88 1
a88 1
	if (read(fd, (char *)&strsize, sizeof(strsize)) != sizeof(strsize))
d92 3
a94 2
	 * Read in the string table.  Since OpenBSD's malloc(3) returns
	 * memory to the system on free this does not cause bloat.
d97 12
a108 4
	if ((strtab = (char *)malloc(strsize)) == NULL)
		return (-1);
	if (read(fd, strtab, strsize) != strsize)
		return (-1);
d128 4
a131 2
	if (lseek(fd, symoff, SEEK_SET) == -1)
		return (-1);
d159 5
a163 1
	free(strtab);
d400 1
a400 1
		goto done;
d404 1
a404 1
		goto done;
d457 1
a457 1
done:
@


1.30
log
@__alpha__, not alpha
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.29 1998/09/07 03:23:55 millert Exp $";
a59 11
#ifdef _NLIST_DO_GZIP
#include <zlib.h>
#define Read	gzread
#define Seek	gzseek
typedef gzFile	File;
#else
#define Read	read
#define Seek	lseek
typedef int	File;
#endif /* _NLIST_DO_GZIP */

d65 1
a65 1
	register File fd;
d77 2
a78 2
	if (Seek(fd, 0, SEEK_SET) == -1 ||
	    Read(fd, &exec, sizeof(exec)) != sizeof(exec) ||
d87 1
a87 1
	if (Seek(fd, N_STROFF(exec), SEEK_SET) == -1)
d89 1
a89 1
	if (Read(fd, (char *)&strsize, sizeof(strsize)) != sizeof(strsize))
d99 1
a99 1
	if (Read(fd, strtab, strsize) != strsize)
d120 1
a120 1
	if (Seek(fd, symoff, SEEK_SET) == -1)
d125 1
a125 1
		if (Read(fd, nbuf, cc) != cc)
d157 1
a157 1
#define	BADFREE			do { rv = -1; goto freestr; } while (0)
d161 1
a161 1
	register File fd;
d165 10
a174 5
	struct ecoff_exechdr exechdr;
	struct ecoff_symhdr symhdr;
	struct ecoff_extsym esym;
	char *strtab, *nlistname, *symtabname;
	int rv, nent, strsize, nesyms;
d178 1
a178 1
	if (Seek(fd, 0, SEEK_SET) == -1)
d180 2
a181 3

	/* Read in exec header and check magic nummber. */
	if (Read(fd, &exechdr, sizeof(exechdr)) != sizeof(exechdr))
d183 5
a187 1
	if (ECOFF_BADMAG(&exechdr))  
d190 20
a209 24
	/* Can't operate on stripped executables. *.
	if (exechdr.f.f_nsyms == 0)
		BAD;

	/* Read in symbol table header and check magic nummber. */
	if (Seek(fd, exechdr.f.f_symptr, SEEK_SET) == -1)
		BAD;
	if (Read(fd, &symhdr, sizeof(symhdr)) != sizeof(symhdr))
		BAD;
	if (ECOFF_BADMAG(&exechdr))
		BAD;

	/* Read in the string table. */
	if (Seek(fd, symhdr.cbSsExtOffset, SEEK_SET) == -1)
		BAD;
#ifdef __alpha__
	strsize = symhdr.estrMax;
#else
	strsize = symhdr.sh_estrmax;
#endif
	if (!(strtab = (char *)malloc(strsize)))
		BAD;
	if (Read(fd, strtab, strsize) != strsize)
		BADFREE;
d228 1
a228 10
	/* Seek to symbol table. */
	if (Seek(fd, symhdr.cbExtOffset, SEEK_SET) == -1)
		BADFREE;

	/* Check each symbol against the list */
	nesyms = symhdr.esymMax;
	while (nesyms--) {
		if (Read(fd, &esym, sizeof (esym)) != sizeof (esym))
			BADFREE;
		symtabname = strtab + esym.es_strindex;
d230 3
d236 2
d239 2
a240 2
			if (strcmp(symtabname, nlistname) == 0) {
				p->n_value = esym.es_value;
d242 2
d251 2
a252 2
freestr:
	free(strtab);
d292 1
a292 1
	register File fd;
d296 1
a296 1
	register char *strtab = NULL;
a304 1
	int serrno;
d308 4
a311 3
	if (Seek(fd, 0, SEEK_SET) == -1 ||
	    Read(fd, &ehdr, sizeof(Elf32_Ehdr)) != sizeof(Elf32_Ehdr) ||
	    !__elf_is_okay__(&ehdr))
d314 7
a320 17
	/*
	 * Clean out any left-over information for all valid entries.
	 * Type and value defined to be 0 if not found; historical
	 * versions cleared other and desc as well.  Also figure out
	 * the largest string length so don't read any more of the
	 * string table than we have to.
	 *
	 * XXX clearing anything other than n_type and n_value violates
	 * the semantics given in the man page.
	 */
	nent = 0;
	for (p = list; !ISLAST(p); ++p) {
		p->n_type = 0;
		p->n_other = 0;
		p->n_desc = 0;
		p->n_value = 0;
		++nent;
d323 5
a327 8
	/* Calculate section header table size */
	shdr_size = ehdr.e_shentsize * ehdr.e_shnum;

	/* Alloc and read section header table */
	shdr = (Elf32_Shdr *)malloc((size_t)shdr_size);
	if (shdr == NULL || Seek(fd, ehdr.e_shoff, SEEK_SET) == -1 ||
	    Read(fd, shdr, shdr_size) != shdr_size)
		goto done;
d345 2
a346 5
	/* Alloc and read in string table */
	strtab = (char *)malloc(symstrsize);
	if (strtab == NULL || Seek(fd, symstroff, SEEK_SET) == -1 ||
	    Read(fd, strtab, symstrsize) != symstrsize)
		goto done;
d348 6
d355 4
a358 2
	 * Don't process any further if object is stripped.
	 * ELFism -- dunno if stripped by looking at header
d360 30
a389 1
	if (symoff == 0 || Seek(fd, symoff, SEEK_SET) == -1)
d391 1
d395 1
a395 1
		if (Read(fd, sbuf, cc) != cc)
d435 2
d444 1
a444 6
	serrno = errno;
	if (shdr)
		free(shdr);
	if (strtab)
		free(strtab);
	errno = serrno;
d451 1
a451 1
	int	(*fn) __P((File fd, struct nlist *list));
d469 1
a469 13
	int n = -1, i, serrno;
	File f;
#ifdef _NLIST_DO_GZIP
	int nfd;

	if ((nfd = dup(fd)) == -1)
		return (-1);

	if ((f = gzdopen(nfd, "r")) == NULL)
		return (-1);
#else
	f = fd;
#endif /* _NLIST_DO_GZIP */
d472 1
a472 2
		n = (nlist_fn[i].fn)(f, list);
		serrno = errno;
a475 6

#ifdef _NLIST_DO_GZIP
	(void)gzclose(f);
#endif /* _NLIST_DO_GZIP */

	errno = serrno;
d479 1
d485 1
a485 1
	int n, fd;
d487 2
a488 2
	fd = open(name, O_RDONLY);
	if (fd == -1)
@


1.29
log
@make work on pmax
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.28 1998/09/05 16:30:07 millert Exp $";
d208 1
a208 1
#ifdef alpha
@


1.28
log
@Add support for nlisting against a gzipped kernel, #ifdef'd out since
it requires linking with -lz.  savecore will use this to operate on
gzipped kernels.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.27 1998/08/23 17:48:02 millert Exp $";
d208 1
d210 3
@


1.27
log
@Strip leading '_' from symbol to lookup if symbols in file lack leading '_'.
Needed to make nlist of /dev/ksyms work correctly on non-a.out kernels.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.26 1998/08/21 20:33:12 millert Exp $";
d60 11
d76 1
a76 1
	register int fd;
d88 2
a89 2
	if (lseek(fd, (off_t)0, SEEK_SET) == -1 ||
	    read(fd, &exec, sizeof(exec)) != sizeof(exec) ||
d98 1
a98 1
	if (lseek(fd, N_STROFF(exec), SEEK_SET) == -1)
d100 1
a100 1
	if (read(fd, (char *)&strsize, sizeof(strsize)) != sizeof(strsize))
d110 1
a110 1
	if (read(fd, strtab, strsize) != strsize)
d131 1
a131 1
	if (lseek(fd, symoff, SEEK_SET) == -1)
d136 1
a136 1
		if (read(fd, nbuf, cc) != cc)
d168 1
a168 1
#define	BADUNMAP		do { rv = -1; goto unmap; } while (0)
d172 1
a172 1
	register int fd;
d176 5
a180 10
	struct ecoff_exechdr *exechdrp;
	struct ecoff_symhdr *symhdrp;
	struct ecoff_extsym *esyms;
	struct stat st;
	char *mappedfile;
	size_t mappedsize;
	u_long symhdroff, extstroff;
	u_int symhdrsize;
	int rv, nent;
	long i, nesyms;
d184 7
a190 1
	if (fstat(fd, &st) < 0)
d192 7
a198 2
	if (st.st_size > SIZE_T_MAX) {
		errno = EFBIG;
d200 3
a202 5
	}
	mappedsize = st.st_size;
	mappedfile = mmap(NULL, mappedsize, PROT_READ, MAP_COPY|MAP_FILE,
	    fd, 0);
	if (mappedfile == MAP_FAILED)
d205 8
a212 20
	if (check(0, sizeof *exechdrp))
		BADUNMAP;
	exechdrp = (struct ecoff_exechdr *)&mappedfile[0];

	if (ECOFF_BADMAG(exechdrp))
		BADUNMAP;

	symhdroff = exechdrp->f.f_symptr;
	symhdrsize = exechdrp->f.f_nsyms;

	if (check(symhdroff, sizeof *symhdrp) ||
	    sizeof *symhdrp != symhdrsize)
		BADUNMAP;
	symhdrp = (struct ecoff_symhdr *)&mappedfile[symhdroff];

	nesyms = symhdrp->esymMax;
	if (check(symhdrp->cbExtOffset, nesyms * sizeof *esyms))
		BADUNMAP;
	esyms = (struct ecoff_extsym *)&mappedfile[symhdrp->cbExtOffset];
	extstroff = symhdrp->cbSsExtOffset;
d231 10
a240 1
	for (i = 0; i < nesyms; i++) {
a241 3
			char *nlistname;
			char *symtabname;

a244 2
			symtabname =
			    &mappedfile[extstroff + esyms[i].es_strindex];
d246 2
a247 2
			if (!strcmp(symtabname, nlistname)) {
				p->n_value = esyms[i].es_value;
a248 2
				p->n_desc = 0;			/* XXX */
				p->n_other = 0;			/* XXX */
d256 2
a257 2
unmap:
	munmap(mappedfile, mappedsize);
d297 1
a297 1
	register int fd;
d301 1
a301 1
	register caddr_t strtab;
d310 1
d314 3
a316 4
	if (lseek(fd, (off_t)0, SEEK_SET) == -1 ||
	    read(fd, &ehdr, sizeof(Elf32_Ehdr)) != sizeof(Elf32_Ehdr) ||
	    !__elf_is_okay__(&ehdr) ||
	    fstat(fd, &st) < 0)
d319 20
a338 1
	/* calculate section header table size */
d341 5
a345 11
	/* Make sure it's not too big to mmap */
	if (shdr_size > SIZE_T_MAX) {
		errno = EFBIG;
		return (-1);
	}

	/* mmap section header table */
	shdr = (Elf32_Shdr *)mmap(NULL, (size_t)shdr_size, PROT_READ,
	    MAP_COPY|MAP_FILE, fd, (off_t) ehdr.e_shoff);
	if (shdr == (Elf32_Shdr *)-1)
		return (-1);
d363 5
a367 2
	/* Flush the section header table */
	munmap((caddr_t)shdr, shdr_size);
a368 16
	/* Check for files too large to mmap. */
	/* XXX is this really possible? */
	if (symstrsize > SIZE_T_MAX) {
		errno = EFBIG;
		return (-1);
	}
	/*
	 * Map string table into our address space.  This gives us
	 * an easy way to randomly access all the strings, without
	 * making the memory allocation permanent as with malloc/free
	 * (i.e., munmap will return it to the system).
	 */
	strtab = mmap(NULL, (size_t)symstrsize, PROT_READ, MAP_COPY|MAP_FILE,
	    fd, (off_t) symstroff);
	if (strtab == (char *)-1)
		return (-1);
d370 2
a371 8
	 * clean out any left-over information for all valid entries.
	 * Type and value defined to be 0 if not found; historical
	 * versions cleared other and desc as well.  Also figure out
	 * the largest string length so don't read any more of the
	 * string table than we have to.
	 *
	 * XXX clearing anything other than n_type and n_value violates
	 * the semantics given in the man page.
d373 1
a373 16
	nent = 0;
	for (p = list; !ISLAST(p); ++p) {
		p->n_type = 0;
		p->n_other = 0;
		p->n_desc = 0;
		p->n_value = 0;
		++nent;
	}

	/* Don't process any further if object is stripped. */
	/* ELFism - dunno if stripped by looking at header */
	if (symoff == 0)
		goto done;

	if (lseek(fd, (off_t) symoff, SEEK_SET) == -1) {
		nent = -1;
a374 1
	}
d378 1
a378 1
		if (read(fd, sbuf, cc) != cc)
a417 2
					p->n_desc = 0;
					p->n_other = 0;
d425 6
a430 1
	munmap(strtab, symstrsize);
d437 1
a437 1
	int	(*fn) __P((int fd, struct nlist *list));
d455 13
a467 1
	int n = -1, i;
d470 2
a471 1
		n = (nlist_fn[i].fn)(fd, list);
d475 6
a483 1

d489 1
a489 1
	int fd, n;
d491 2
a492 2
	fd = open(name, O_RDONLY, 0);
	if (fd < 0)
@


1.26
log
@I committed the wrong version before, here is the correct one
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.25 1998/08/21 19:25:36 millert Exp $";
d133 6
a138 2
			for (p = list; !ISLAST(p); p++)
				if (!strcmp(sname, p->n_un.n_name)) {
d146 1
@


1.25
log
@For a.out use read, not mmap, to get the string table so this works on
/dev/ksyms.  mmap was only used because, at the time, free did not give
memory back to the system (our malloc/free uses mmap/munmap so we are ok).
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.24 1998/01/20 22:10:48 deraadt Exp $";
d46 1
d69 1
a69 1
	register void *strtab;
d87 2
d93 2
a94 6
	 * Map string table into our address space.  This gives us
	 * an easy way to randomly access all the strings, without
	 * making the memory allocation permanent as with malloc/free
	 * (i.e., munmap will return it to the system).  We try to
	 * get a clean snapshot via MAP_COPY but that does not work
	 * for cdevs (like /dev/ksyms) so we try without if that fails.
d96 4
a99 5
	if ((strtab = mmap(NULL, (size_t)strsize, PROT_READ, MAP_COPY|MAP_FILE,
	    fd, stroff)) == MAP_FAILED)
		strtab = mmap(NULL, (size_t)strsize, PROT_READ, 0, fd,
		    stroff);
	if (strtab == MAP_FAILED)
d101 1
d129 1
a129 1
			register int soff = s->n_un.n_strx;
d131 1
a131 1
			if (soff == 0 || (s->n_type & N_STAB) != 0)
d134 1
a134 1
				if (!strcmp(&((char *)strtab)[soff], p->n_un.n_name)) {
d144 1
a144 1
	munmap(strtab, strsize);
@


1.24
log
@type botch
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.23 1998/01/02 05:32:47 deraadt Exp $";
d72 1
a72 1
	size_t strsize;
a74 1
	struct stat st;
d78 1
a78 1
	    N_BADMAG(exec) || fstat(fd, &st) < 0)
d85 2
a86 3
	/* Check for files too large to mmap. */
	if (st.st_size - stroff > SIZE_T_MAX) {
		errno = EFBIG;
d88 1
a88 1
	}
d93 3
a95 1
	 * (i.e., munmap will return it to the system).
d97 4
a100 3
	strsize = st.st_size - stroff;
	strtab = mmap(NULL, (size_t)strsize, PROT_READ, MAP_COPY|MAP_FILE,
	    fd, stroff);
@


1.23
log
@make mmap() return void *, add MAP_FAILED
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.22 1997/12/15 10:19:17 deraadt Exp $";
d68 1
a68 1
	register void * strtab;
d134 1
a134 1
				if (!strcmp(&strtab[soff], p->n_un.n_name)) {
@


1.22
log
@MAP_COPY|MAP_FILE; mrg.  indent too
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.21 1997/07/23 21:04:06 kstailey Exp $";
d68 1
a68 1
	register caddr_t strtab;
d100 1
a100 1
	if (strtab == (char *)-1)
d182 1
a182 1
	if (mappedfile == (char *)-1)
@


1.21
log
@tabify
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.20 1997/07/01 05:59:44 millert Exp $";
d98 2
a99 1
	strtab = mmap(NULL, (size_t)strsize, PROT_READ, 0, fd, stroff);
d180 2
a181 1
	mappedfile = mmap(NULL, mappedsize, PROT_READ, 0, fd, 0);
d319 2
a320 2
	shdr = (Elf32_Shdr *)mmap(NULL, (size_t)shdr_size,
				  PROT_READ, 0, fd, (off_t) ehdr.e_shoff);
d355 2
a356 1
	strtab = mmap(NULL, (size_t)symstrsize, PROT_READ, 0, fd, (off_t) symstroff);
d382 1
a382 1
		
d414 12
a425 12
						case STT_NOTYPE:
							p->n_type = N_UNDF;
							break;
						case STT_OBJECT:
							p->n_type = N_DATA;
							break;
						case STT_FUNC:
							p->n_type = N_TEXT;
							break;
						case STT_FILE:
							p->n_type = N_FN;
							break;
d438 1
a438 1
  done:
a439 1

@


1.20
log
@Make -Wall happy.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.19 1997/01/10 18:29:48 etheisen Exp $";
d297 1
a297 1
        Elf32_Word shdr_size;
d300 1
a300 1
        /* Make sure obj is OK */
d307 2
a308 2
        /* calculate section header table size */
        shdr_size = ehdr.e_shentsize * ehdr.e_shnum;
d310 1
a310 1
        /* Make sure it's not too big to mmap */
d316 1
a316 1
        /* mmap section header table */
d318 1
a318 1
                                  PROT_READ, 0, fd, (off_t) ehdr.e_shoff);
d322 15
a336 15
        /*
         * Find the symbol table entry and it's corresponding
         * string table entry.  Version 1.1 of the ABI states
         * that there is only one symbol table but that this
         * could change in the future.
         */
        for (i = 0; i < ehdr.e_shnum; i++) {
                if (shdr[i].sh_type == SHT_SYMTAB) {
                        symoff = shdr[i].sh_offset;
                        symsize = shdr[i].sh_size;
                        symstroff = shdr[shdr[i].sh_link].sh_offset;
                        symstrsize = shdr[shdr[i].sh_link].sh_size;
                        break;
                }
        }
d338 2
a339 2
        /* Flush the section header table */
        munmap((caddr_t)shdr, shdr_size);
d375 5
a379 5
        /* Don't process any further if object is stripped. */
        /* ELFism - dunno if stripped by looking at header */
        if (symoff == 0)
                goto done;
                
d381 4
a384 4
                nent = -1;
                goto done;
        }
        
d396 5
a400 5
                                /*
                                 * XXX - ABI crap, they
                                 * really fucked this up
                                 * for MIPS and PowerPC
                                 */
d403 1
a403 1
				     (ehdr.e_machine == EM_PPC)) ? 
d408 2
a409 2
                                        /* XXX - type conversion */
                                        /*       is pretty rude. */
d411 12
a422 12
                                                case STT_NOTYPE:
                                                        p->n_type = N_UNDF;
                                                        break;
                                                case STT_OBJECT:
                                                        p->n_type = N_DATA;
                                                        break;
                                                case STT_FUNC:
                                                        p->n_type = N_TEXT;
                                                        break;
                                                case STT_FILE:
                                                        p->n_type = N_FN;
                                                        break;
d425 1
a425 1
                                            STB_LOCAL)
@


1.19
log
@Leading underscores... Actually, they really DID fuck this up on the MIPS
and PPC platforms... Everyone else has _leading!
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.18 1997/01/09 03:49:38 rahnds Exp $";
d290 2
a291 2
	register Elf32_Off symoff = 0, symstroff;
	register Elf32_Word symsize, symstrsize;
d457 1
@


1.18
log
@ELF does not use the leading '_' on any port, not just MIPS.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.17 1996/12/23 02:42:22 deraadt Exp $";
d396 10
a405 6
				/*
				 * ELF ports do not use the leading
				 * underscore that is given with "standard"
				 * nlist calls as a.out format does.
				 */
				if (!strcmp(&strtab[soff], p->n_un.n_name+1)) {
@


1.17
log
@use _{NLIST,KERN}_DO_{AOUT,ELF,ECOFF} to select binary types
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.15 1996/09/15 09:31:04 tholo Exp $";
d396 6
a401 9
                                /*
                                 * XXX - ABI crap, they
                                 * really fucked this up
                                 * for MIPS and PowerPC
                                 */
				if (!strcmp(&strtab[soff],
				    ehdr.e_machine == EM_MIPS ? 
				    p->n_un.n_name+1 :
				    p->n_un.n_name)) {
@


1.16
log
@Added OLF capability.
@
text
@d50 1
a50 1
#ifdef DO_ELF
d55 1
a55 1
#ifdef DO_ECOFF
d61 1
a61 1
#ifdef DO_AOUT
d146 1
a146 1
#endif /* DO_AOUT */
d148 1
a148 1
#ifdef DO_ECOFF
d249 1
a249 1
#endif /* DO_ECOFF */
d251 1
a251 1
#ifdef DO_ELF
d439 1
a439 1
#endif /* DO_ELF */
d445 1
a445 1
#ifdef DO_AOUT
d448 1
a448 1
#ifdef DO_ELF
d451 1
a451 1
#ifdef DO_ECOFF
@


1.15
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.14 1996/08/19 08:25:09 tholo Exp $";
d52 1
d270 1
a270 1
	if (IS_ELF(*ehdr) &&
@


1.14
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.13 1996/07/30 09:22:43 niklas Exp $";
d317 1
a317 1
                                  PROT_READ, 0, fd, ehdr.e_shoff);
d352 1
a352 1
	strtab = mmap(NULL, (size_t)symstrsize, PROT_READ, 0, fd, symstroff);
d379 1
a379 1
	if (lseek(fd, symoff, SEEK_SET) == -1) {
a475 1
	int i;
@


1.13
log
@Update ECOFF nlist from NetBSD
@
text
@a0 3
/*	$OpenBSD: nlist.c,v 1.12 1996/06/17 06:40:53 etheisen Exp $	*/
/*	$NetBSD: nlist.c,v 1.7 1996/05/16 20:49:20 cgd Exp $	*/

d35 1
a35 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.11 1996/06/14 05:01:36 deraadt Exp$";
@


1.12
log
@Added better ELF section header handling.  Correctly handle stripped objs.
Added STT_FILE translation.  General cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.11 1996/06/14 05:01:36 deraadt Exp $	*/
d38 1
a38 2
static char rcsid[] = "$OpenBSD: nlist.c,v 1.11 1996/06/14 05:01:36 deraadt Exp 
$";
d200 2
a201 2
	nesyms = symhdrp->sh_esymmax;
	if (check(symhdrp->sh_esymoff, nesyms * sizeof *esyms))
d203 2
a204 2
	esyms = (struct ecoff_extsym *)&mappedfile[symhdrp->sh_esymoff];
	extstroff = symhdrp->sh_estroff;
@


1.11
log
@if no executable formats are defined for the architecture, it should
nlist should return -1 (not garbage). Guess how I found this bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.10 1996/05/30 16:16:53 pefo Exp $ */
d38 2
a39 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.10 1996/05/30 16:16:53 pefo Exp $";
d293 3
a295 3
	register off_t symstroff, symoff;
	register u_long symsize;
	register int nent, cc, i;
d298 3
a300 4
	size_t symstrsize;
	char *shstr;
	Elf32_Ehdr eh;
	Elf32_Shdr *sh = NULL;
d303 1
d305 2
a306 2
	    read(fd, &eh, sizeof(eh)) != sizeof(eh) ||
	    !__elf_is_okay__(&eh) ||
d310 2
a311 1
	sh = (Elf32_Shdr *)malloc(sizeof(Elf32_Shdr) * eh.e_shnum);
d313 5
a317 2
	if (lseek (fd, eh.e_shoff, SEEK_SET) < 0)
		return(-1);
d319 4
a322 2
	if (read(fd, sh, sizeof(Elf32_Shdr) * eh.e_shnum) <
	    sizeof(Elf32_Shdr) * eh.e_shnum)
d325 19
a343 18
	shstr = (char *)malloc(sh[eh.e_shstrndx].sh_size);
	if (lseek (fd, sh[eh.e_shstrndx].sh_offset, SEEK_SET) < 0)
		return(-1);
	if (read(fd, shstr, sh[eh.e_shstrndx].sh_size) <
	    sh[eh.e_shstrndx].sh_size)
		return(-1);

	for (i = 0; i < eh.e_shnum; i++) {
		if (strcmp (shstr + sh[i].sh_name, ".strtab") == 0) {
			symstroff = sh[i].sh_offset;
			symstrsize = sh[i].sh_size;
		}
		else if (strcmp (shstr + sh[i].sh_name, ".symtab") == 0) {
			symoff = sh[i].sh_offset;
			symsize = sh[i].sh_size;
		}
	}
	
a376 2
	if (lseek(fd, symoff, SEEK_SET) == -1)
		return (-1);
d378 10
d399 5
d405 1
a405 1
				    eh.e_machine == EM_MIPS ?
d410 2
a411 1
		/*XXX type conversion is pretty rude... */
d413 12
a424 9
					case STT_NOTYPE:
						p->n_type = N_UNDF;
						break;
					case STT_FUNC:
						p->n_type = N_TEXT;
						break;
					case STT_OBJECT:
						p->n_type = N_DATA;
						break;
d426 2
a427 1
					if(ELF32_ST_BIND(s->st_info) == STB_LOCAL)
d437 1
@


1.10
log
@Fixes for ecoff updates
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.9 1996/05/29 03:05:14 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.9 1996/05/29 03:05:14 deraadt Exp $";
d436 1
a436 1
	int n, i;
@


1.9
log
@enable ELF/a.out/ECOFF in machine/exec.h
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.8 1996/05/28 14:11:21 etheisen Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.8 1996/05/28 14:11:21 etheisen Exp $";
d200 2
a201 2
	nesyms = symhdrp->esymMax;
	if (check(symhdrp->cbExtOffset, nesyms * sizeof *esyms))
d203 2
a204 2
	esyms = (struct ecoff_extsym *)&mappedfile[symhdrp->cbExtOffset];
	extstroff = symhdrp->cbSsExtOffset;
@


1.8
log
@All platforms get elf_nlist().  Hidden __elf_is_okay__() function is
now present for ELF platforms.  This function is not ABI compliant and
it's use should be restricted.  exec_sup.h now determines the target
OMF for various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: nlist.c,v 1.7 1996/05/24 10:59:00 deraadt Exp $ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD: nlist.c,v 1.7 1996/05/24 10:59:00 deraadt Exp $";
d41 1
a41 2
#include "exec_sup.h"           /* determine targ OMFs for a given machine */

d51 9
d254 31
@


1.7
log
@sync to ecoff changes
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d38 1
a38 1
static char rcsid[] = "$OpenBSD$";
d41 1
a41 5
#define DO_AOUT			/* always do a.out */
#if defined(__alpha__) || defined(pica)
#define DO_ECOFF
#endif
#define	DO_ELF
a48 7
#include <a.out.h>
#ifdef DO_ECOFF
#include <sys/exec_ecoff.h>
#endif
#ifdef DO_ELF
#include <elf_abi.h>
#endif
d266 1
a266 1
	    !IS_ELF(eh) ||
@


1.6
log
@Addition of elf support.
@
text
@d1 2
a2 1
/*	$NetBSD: nlist.c,v 1.6 1995/09/29 04:19:59 cgd Exp $	*/
d38 1
a38 5
#if 0
static char sccsid[] = "@@(#)nlist.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: nlist.c,v 1.6 1995/09/29 04:19:59 cgd Exp $";
#endif
d164 1
a164 1
	struct ecoff_filehdr *filehdrp;
d188 1
a188 1
	if (check(0, sizeof *filehdrp))
d190 1
a190 1
	filehdrp = (struct ecoff_filehdr *)&mappedfile[0];
d192 1
a192 1
	if (ECOFF_BADMAG(filehdrp))
d195 2
a196 2
	symhdroff = filehdrp->ef_symptr;
	symhdrsize = filehdrp->ef_syms;
d203 2
a204 2
	nesyms = symhdrp->sh_esymmax;
	if (check(symhdrp->sh_esymoff, nesyms * sizeof *esyms))
d206 2
a207 2
	esyms = (struct ecoff_extsym *)&mappedfile[symhdrp->sh_esymoff];
	extstroff = symhdrp->sh_estroff;
@


1.5
log
@a.out is more likely, so check for it first
@
text
@d61 1
a61 1
#include <sys/exec_elf.h>
d265 124
a388 1
	return (-1);
@


1.4
log
@__fdnlist() is used by libkvm
@
text
@d273 3
a280 3
#endif
#ifdef DO_AOUT
	{ __aout_fdnlist },
@


1.3
log
@nlist will now handle many formats (once the code is written)
@
text
@d284 15
d310 1
a310 5
	for (i = 0; i < sizeof(nlist_fn)/sizeof(nlist_fn[0]); i++) {
		n = (nlist_fn[i].fn)(fd, list);
		if (n != -1)
			break;
	}
@


1.2
log
@do ecoff on the pica as well (for now)
@
text
@d44 1
d46 1
a46 7
#define		DO_ECOFF
#else
#define		DO_AOUT
#endif

#if defined(DO_AOUT) + defined(DO_ECOFF) != 1
	ERROR: NOT PROPERLY CONFIGURED
d48 1
d60 3
a66 15
int
nlist(name, list)
	const char *name;
	struct nlist *list;
{
	int fd, n;

	fd = open(name, O_RDONLY, 0);
	if (fd < 0)
		return (-1);
	n = __fdnlist(fd, list);
	(void)close(fd);
	return (n);
}

d71 1
a71 1
__fdnlist(fd, list)
d162 1
a162 1
__fdnlist(fd, list)
d258 45
@


1.1
log
@Initial revision
@
text
@d44 1
a44 1
#ifdef __alpha__
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
