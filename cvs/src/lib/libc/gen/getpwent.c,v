head	1.61;
access;
symbols
	OPENBSD_6_1:1.61.0.4
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.61.0.2
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.60.0.2
	OPENBSD_5_9_BASE:1.60
	OPENBSD_5_8:1.54.0.4
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.43.0.4
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.2
	OPENBSD_5_0:1.42.0.8
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.6
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.4
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.38.0.4
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.34.0.12
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.10
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.8
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.6
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.4
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.34.0.2
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	OPENBSD_3_5:1.31.0.4
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_8:1.19.0.4
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2016.05.07.21.52.29;	author tedu;	state Exp;
branches;
next	1.60;
commitid	ubbtqq8abR4rInYW;

1.60
date	2015.12.28.22.08.18;	author mmcc;	state Exp;
branches;
next	1.59;
commitid	0uXuF2O13NH9q2e1;

1.59
date	2015.12.01.15.08.25;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	FnyjPuUxHGEcyAdw;

1.58
date	2015.11.24.22.03.33;	author millert;	state Exp;
branches;
next	1.57;
commitid	LVVvCb2EklWn8nFM;

1.57
date	2015.11.18.16.44.46;	author tedu;	state Exp;
branches;
next	1.56;
commitid	QVmzbQxv343IGoRu;

1.56
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.55;
commitid	iWfSX2BIn0sLw62l;

1.55
date	2015.09.13.15.33.48;	author guenther;	state Exp;
branches;
next	1.54;
commitid	zxB6o2cNPYznqLwP;

1.54
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.53;
commitid	GouatFiJVxwlAVIQ;

1.53
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	0DYulI8hhujBHMcR;

1.52
date	2014.03.12.10.54.36;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2014.03.12.09.58.23;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2014.03.08.16.47.43;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2014.03.05.23.44.47;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.15.22.32.55;	author benno;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.12.07.04.54;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2013.08.15.18.19.50;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.21.21.59.32;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.07.01.01.11;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.05.03.52.24;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2009.11.21.10.24.59;	author chl;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.12.18.00.18;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.03.16.02.44;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2009.03.27.12.31.31;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2008.07.23.19.36.47;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.06.22.19.39;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.25.14.51.27;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.24.14.27.24;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.25.15.38.47;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.25.21.16.47;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.01.20.22.00;	author avsm;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.21.21.25.19;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.06.03.10.23;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.06.00.10.36;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.24.21.22.37;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.10.16.46.25;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.13.14.51.08;	author pjanzen;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.31.17.42.25;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.25.19.11.48;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.25.12.21.05;	author d;	state Exp;
branches;
next	1.17;

1.17
date	99.09.15.08.57.25;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.09.14.21.03.15;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.09.03.16.23.18;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.08.14.21.39.29;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.07.14.18.19.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.12.18.10.12.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.23.21.04.06;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.04.18.18.55.16;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.04.13.05.11.07;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.10.16.09.24.21;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.10.15.18.27.58;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.09.16.19.01.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.15.10.09.11;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.09.15.09.31.02;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.24.02;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.04.24.12.55.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.55;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.61
log
@stop opening the shadow database by default. only programs that request it
via the _shadow functions will open now, preventing some programs running
as root from accidentally loading password hashes it into their memory.
ok deraadt
@
text
@/*	$OpenBSD: getpwent.c,v 1.60 2015/12/28 22:08:18 mmcc Exp $ */
/*
 * Copyright (c) 2008 Theo de Raadt
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 * Portions Copyright (c) 1994, 1995, 1996, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* ALIGN */
#include <fcntl.h>
#include <db.h>
#include <syslog.h>
#include <pwd.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <netgroup.h>
#ifdef YP
#include <stdio.h>
#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "ypinternal.h"
#include "ypexclude.h"
#endif
#include "thread_private.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

_THREAD_PRIVATE_KEY(pw);

static DB *_pw_db;			/* password database */

/* Following are used only by setpwent(), getpwent(), and endpwent() */
static struct passwd _pw_passwd;	/* password structure */
static char _pw_string[_PW_BUF_LEN];	/* string pointed to by _pw_passwd */
static int _pw_keynum;			/* key counter */
static int _pw_stayopen;		/* keep fd's open */
static int _pw_flags;			/* password flags */

static int __hashpw(DBT *, char *buf, size_t buflen, struct passwd *, int *);
static int __initdb(int);
static struct passwd *_pwhashbyname(const char *name, char *buf,
	size_t buflen, struct passwd *pw, int *);
static struct passwd *_pwhashbyuid(uid_t uid, char *buf,
	size_t buflen, struct passwd *pw, int *);

#ifdef YP
static char	*__ypdomain;

/* Following are used only by setpwent(), getpwent(), and endpwent() */
enum _ypmode { YPMODE_NONE, YPMODE_FULL, YPMODE_USER, YPMODE_NETGRP };
static enum	_ypmode __ypmode;
static char	*__ypcurrent;
static int	__ypcurrentlen;
static int	__yp_pw_flags;
static struct passwd *__ypproto;
static char	__ypline[_PW_BUF_LEN];
static int	__getpwent_has_yppw = -1;
static struct _ypexclude *__ypexhead;

static int __has_yppw(void);
static int __has_ypmaster(void);
static void __ypproto_set(struct passwd *, long long *, int, int *);
static int __ypparse(struct passwd *pw, char *s, int);

#define LOOKUP_BYNAME 0
#define LOOKUP_BYUID 1
static struct passwd *__yppwlookup(int, char *, uid_t, struct passwd *,
    char *, size_t, int *);

/* macro for deciding which YP maps to use. */
#define PASSWD_BYNAME \
	(__has_ypmaster() ? "master.passwd.byname" : "passwd.byname")
#define PASSWD_BYUID \
	(__has_ypmaster() ? "master.passwd.byuid" : "passwd.byuid")

static void
__ypproto_set(struct passwd *pw, long long *buf, int flags, int *yp_pw_flagsp)
{
	char *ptr;

	/* make this the new prototype */
	ptr = (char *)buf;

	/* first allocate the struct. */
	__ypproto = (struct passwd *)ptr;
	ptr += sizeof(struct passwd);

	/* name */
	if (pw->pw_name && (pw->pw_name)[0]) {
		ptr = (char *)ALIGN(ptr);
		bcopy(pw->pw_name, ptr, strlen(pw->pw_name) + 1);
		__ypproto->pw_name = ptr;
		ptr += (strlen(pw->pw_name) + 1);
	} else
		__ypproto->pw_name = NULL;

	/* password */
	if (pw->pw_passwd && (pw->pw_passwd)[0]) {
		ptr = (char *)ALIGN(ptr);
		bcopy(pw->pw_passwd, ptr, strlen(pw->pw_passwd) + 1);
		__ypproto->pw_passwd = ptr;
		ptr += (strlen(pw->pw_passwd) + 1);
	} else
		__ypproto->pw_passwd = NULL;

	/* uid */
	__ypproto->pw_uid = pw->pw_uid;

	/* gid */
	__ypproto->pw_gid = pw->pw_gid;

	/* change (ignored anyway) */
	__ypproto->pw_change = pw->pw_change;

	/* class (ignored anyway) */
	__ypproto->pw_class = "";

	/* gecos */
	if (pw->pw_gecos && (pw->pw_gecos)[0]) {
		ptr = (char *)ALIGN(ptr);
		bcopy(pw->pw_gecos, ptr, strlen(pw->pw_gecos) + 1);
		__ypproto->pw_gecos = ptr;
		ptr += (strlen(pw->pw_gecos) + 1);
	} else
		__ypproto->pw_gecos = NULL;

	/* dir */
	if (pw->pw_dir && (pw->pw_dir)[0]) {
		ptr = (char *)ALIGN(ptr);
		bcopy(pw->pw_dir, ptr, strlen(pw->pw_dir) + 1);
		__ypproto->pw_dir = ptr;
		ptr += (strlen(pw->pw_dir) + 1);
	} else
		__ypproto->pw_dir = NULL;

	/* shell */
	if (pw->pw_shell && (pw->pw_shell)[0]) {
		ptr = (char *)ALIGN(ptr);
		bcopy(pw->pw_shell, ptr, strlen(pw->pw_shell) + 1);
		__ypproto->pw_shell = ptr;
		ptr += (strlen(pw->pw_shell) + 1);
	} else
		__ypproto->pw_shell = NULL;

	/* expire (ignored anyway) */
	__ypproto->pw_expire = pw->pw_expire;

	/* flags */
	*yp_pw_flagsp = flags;
}

static int
__ypparse(struct passwd *pw, char *s, int yp_pw_flags)
{
	char *bp, *cp, *endp;
	u_long ul;
	int count = 0;

	/* count the colons. */
	bp = s;
	while (*bp != '\0') {
		if (*bp++ == ':')
			count++;
	}

	/* since this is currently using strsep(), parse it first */
	bp = s;
	pw->pw_name = strsep(&bp, ":\n");
	pw->pw_passwd = strsep(&bp, ":\n");
	if (!(cp = strsep(&bp, ":\n")))
		return (1);
	ul = strtoul(cp, &endp, 10);
	if (endp == cp || *endp != '\0' || ul >= UID_MAX)
		return (1);
	pw->pw_uid = (uid_t)ul;
	if (!(cp = strsep(&bp, ":\n")))
		return (1);
	ul = strtoul(cp, &endp, 10);
	if (endp == cp || *endp != '\0' || ul >= GID_MAX)
		return (1);
	pw->pw_gid = (gid_t)ul;
	if (count == 9) {
		long l;

		/* If the ypserv gave us all the fields, use them. */
		pw->pw_class = strsep(&bp, ":\n");
		if (!(cp = strsep(&bp, ":\n")))
			return (1);
		l = strtol(cp, &endp, 10);
		if (endp == cp || *endp != '\0' || l >= INT_MAX || l <= INT_MIN)
			return (1);
		pw->pw_change = (time_t)l;
		if (!(cp = strsep(&bp, ":\n")))
			return (1);
		l = strtol(cp, &endp, 10);
		if (endp == cp || *endp != '\0' || l >= INT_MAX || l <= INT_MIN)
			return (1);
		pw->pw_expire = (time_t)l;
	} else {
		/* ..else it is a normal ypserv. */
		pw->pw_class = "";
		pw->pw_change = 0;
		pw->pw_expire = 0;
	}
	pw->pw_gecos = strsep(&bp, ":\n");
	pw->pw_dir = strsep(&bp, ":\n");
	pw->pw_shell = strsep(&bp, ":\n");

	/* now let the prototype override, if set. */
	if (__ypproto) {
		if (!(yp_pw_flags & _PASSWORD_NOUID))
			pw->pw_uid = __ypproto->pw_uid;
		if (!(yp_pw_flags & _PASSWORD_NOGID))
			pw->pw_gid = __ypproto->pw_gid;
		if (__ypproto->pw_gecos)
			pw->pw_gecos = __ypproto->pw_gecos;
		if (__ypproto->pw_dir)
			pw->pw_dir = __ypproto->pw_dir;
		if (__ypproto->pw_shell)
			pw->pw_shell = __ypproto->pw_shell;
	}
	return (0);
}
#endif

struct passwd *
getpwent(void)
{
#ifdef YP
	static char *name = NULL;
	char *map;
#endif
	char bf[1 + sizeof(_pw_keynum)];
	struct passwd *pw = NULL;
	DBT key;

	_THREAD_PRIVATE_MUTEX_LOCK(pw);
	if (!_pw_db && !__initdb(0))
		goto done;

#ifdef YP
	map = PASSWD_BYNAME;

	if (__getpwent_has_yppw == -1)
		__getpwent_has_yppw = __has_yppw();

again:
	if (__getpwent_has_yppw && (__ypmode != YPMODE_NONE)) {
		const char *user, *host, *dom;
		int keylen, datalen, r, s;
		char *key, *data = NULL;

		if (!__ypdomain) {
			if (_yp_check(&__ypdomain) == 0) {
				__ypmode = YPMODE_NONE;
				goto again;
			}
		}
		switch (__ypmode) {
		case YPMODE_FULL:
			if (__ypcurrent) {
				r = yp_next(__ypdomain, map,
				    __ypcurrent, __ypcurrentlen,
				    &key, &keylen, &data, &datalen);
				free(__ypcurrent);
				__ypcurrent = NULL;
				if (r != 0) {
					__ypmode = YPMODE_NONE;
					free(data);
					goto again;
				}
				__ypcurrent = key;
				__ypcurrentlen = keylen;
			} else {
				r = yp_first(__ypdomain, map,
				    &__ypcurrent, &__ypcurrentlen,
				    &data, &datalen);
				if (r != 0 ||
				    __ypcurrentlen > sizeof(__ypline)) {
					__ypmode = YPMODE_NONE;
					free(data);
					goto again;
				}
			}
			bcopy(data, __ypline, datalen);
			free(data);
			break;
		case YPMODE_NETGRP:
			s = getnetgrent(&host, &user, &dom);
			if (s == 0) {	/* end of group */
				endnetgrent();
				__ypmode = YPMODE_NONE;
				goto again;
			}
			if (user && *user) {
				r = yp_match(__ypdomain, map,
				    user, strlen(user), &data, &datalen);
			} else
				goto again;
			if (r != 0 ||
			    __ypcurrentlen > sizeof(__ypline)) {
				/*
				 * if the netgroup is invalid, keep looking
				 * as there may be valid users later on.
				 */
				free(data);
				goto again;
			}
			bcopy(data, __ypline, datalen);
			free(data);
			break;
		case YPMODE_USER:
			if (name) {
				r = yp_match(__ypdomain, map,
				    name, strlen(name), &data, &datalen);
				__ypmode = YPMODE_NONE;
				free(name);
				name = NULL;
				if (r != 0 ||
				    __ypcurrentlen > sizeof(__ypline)) {
					free(data);
					goto again;
				}
				bcopy(data, __ypline, datalen);
				free(data);
			} else {		/* XXX */
				__ypmode = YPMODE_NONE;
				goto again;
			}
			break;
		case YPMODE_NONE:
			/* NOTREACHED */
			break;
		}

		__ypline[datalen] = '\0';
		if (__ypparse(&_pw_passwd, __ypline, __yp_pw_flags))
			goto again;
		pw = &_pw_passwd;
		goto done;
	}
#endif

	++_pw_keynum;
	bf[0] = _PW_KEYBYNUM;
	bcopy((char *)&_pw_keynum, &bf[1], sizeof(_pw_keynum));
	key.data = (u_char *)bf;
	key.size = 1 + sizeof(_pw_keynum);
	if (__hashpw(&key, _pw_string, sizeof _pw_string,
	    &_pw_passwd, &_pw_flags)) {
#ifdef YP
		static long long __yppbuf[_PW_BUF_LEN / sizeof(long long)];
		const char *user, *host, *dom;

		/* if we don't have YP at all, don't bother. */
		if (__getpwent_has_yppw) {
			if (_pw_passwd.pw_name[0] == '+') {
				/* set the mode */
				switch (_pw_passwd.pw_name[1]) {
				case '\0':
					__ypmode = YPMODE_FULL;
					break;
				case '@@':
					__ypmode = YPMODE_NETGRP;
					setnetgrent(_pw_passwd.pw_name + 2);
					break;
				default:
					__ypmode = YPMODE_USER;
					name = strdup(_pw_passwd.pw_name + 1);
					break;
				}

				__ypproto_set(&_pw_passwd, __yppbuf,
				    _pw_flags, &__yp_pw_flags);
				goto again;
			} else if (_pw_passwd.pw_name[0] == '-') {
				/* an attempted exclusion */
				switch (_pw_passwd.pw_name[1]) {
				case '\0':
					break;
				case '@@':
					setnetgrent(_pw_passwd.pw_name + 2);
					while (getnetgrent(&host, &user, &dom)) {
						if (user && *user)
							__ypexclude_add(&__ypexhead,
							    user);
					}
					endnetgrent();
					break;
				default:
					__ypexclude_add(&__ypexhead,
					    _pw_passwd.pw_name + 1);
					break;
				}
				goto again;
			}
		}
#endif
		pw = &_pw_passwd;
		goto done;
	}

done:
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
	return (pw);
}

#ifdef YP
/*
 * See if the YP token is in the database.  Only works if pwd_mkdb knows
 * about the token.
 */
static int
__has_yppw(void)
{
	DBT key, data, pkey, pdata;
	char bf[2];

	key.data = (u_char *)_PW_YPTOKEN;
	key.size = strlen(_PW_YPTOKEN);

	/* Pre-token database support. */
	bf[0] = _PW_KEYBYNAME;
	bf[1] = '+';
	pkey.data = (u_char *)bf;
	pkey.size = sizeof(bf);

	if ((_pw_db->get)(_pw_db, &key, &data, 0) &&
	    (_pw_db->get)(_pw_db, &pkey, &pdata, 0))
		return (0);	/* No YP. */
	return (1);
}

/*
 * See if there's a master.passwd map.
 */
static int
__has_ypmaster(void)
{
	int keylen, resultlen;
	char *key, *result;
	static int checked = -1;
	static uid_t saved_uid, saved_euid;
	uid_t uid = getuid(), euid = geteuid();

	/*
	 * Do not recheck IFF the saved UID and the saved
	 * EUID are the same. In all other cases, recheck.
	 */
	if (checked != -1 && saved_uid == uid && saved_euid == euid)
		return (checked);

	if (euid != 0) {
		saved_uid = uid;
		saved_euid = euid;
		checked = 0;
		return (checked);
	}

	if (!__ypdomain) {
		if (_yp_check(&__ypdomain) == 0) {
			saved_uid = uid;
			saved_euid = euid;
			checked = 0;
			return (checked);	/* No domain. */
		}
	}

	if (yp_first(__ypdomain, "master.passwd.byname",
	    &key, &keylen, &result, &resultlen)) {
		saved_uid = uid;
		saved_euid = euid;
		checked = 0;
		return (checked);
	}
	free(result);
	free(key);

	saved_uid = uid;
	saved_euid = euid;
	checked = 1;
	return (checked);
}

static struct passwd *
__yppwlookup(int lookup, char *name, uid_t uid, struct passwd *pw,
    char *buf, size_t buflen, int *flagsp)
{
	char bf[1 + _PW_NAME_LEN], *ypcurrent = NULL, *map = NULL;
	int yp_pw_flags = 0, ypcurrentlen, r, s = -1, pw_keynum;
	static long long yppbuf[_PW_BUF_LEN / sizeof(long long)];
	struct _ypexclude *ypexhead = NULL;
	const char *host, *user, *dom;
	DBT key;

	for (pw_keynum = 1; pw_keynum; pw_keynum++) {
		bf[0] = _PW_KEYBYNUM;
		bcopy((char *)&pw_keynum, &bf[1], sizeof(pw_keynum));
		key.data = (u_char *)bf;
		key.size = 1 + sizeof(pw_keynum);
		if (__hashpw(&key, buf, buflen, pw, flagsp) == 0)
			break;
		switch (pw->pw_name[0]) {
		case '+':
			if (!__ypdomain) {
				if (_yp_check(&__ypdomain) == 0)
					continue;
			}
			__ypproto_set(pw, yppbuf, *flagsp, &yp_pw_flags);
			if (!map) {
				if (lookup == LOOKUP_BYNAME) {
					if ((name = strdup(name)) == NULL) {
						pw = NULL;
						goto done;
					}
					map = PASSWD_BYNAME;
				} else {
					if (asprintf(&name, "%u", uid) == -1) {
						pw = NULL;
						goto done;
					}
					map = PASSWD_BYUID;
				}
			}

			switch (pw->pw_name[1]) {
			case '\0':
				free(ypcurrent);
				ypcurrent = NULL;
				r = yp_match(__ypdomain, map,
				    name, strlen(name),
				    &ypcurrent, &ypcurrentlen);
				if (r != 0 || ypcurrentlen > buflen) {
					free(ypcurrent);
					ypcurrent = NULL;
					continue;
				}
				break;
			case '@@':
pwnam_netgrp:
				free(ypcurrent);
				ypcurrent = NULL;
				if (s == -1)	/* first time */
					setnetgrent(pw->pw_name + 2);
				s = getnetgrent(&host, &user, &dom);
				if (s == 0) {	/* end of group */
					endnetgrent();
					s = -1;
					continue;
				} else {
					if (user && *user) {
						r = yp_match(__ypdomain, map,
						    user, strlen(user),
						    &ypcurrent, &ypcurrentlen);
					} else
						goto pwnam_netgrp;
					if (r != 0 || ypcurrentlen > buflen) {
						free(ypcurrent);
						ypcurrent = NULL;
						/*
						 * just because this
						 * user is bad, doesn't
						 * mean they all are.
						 */
						goto pwnam_netgrp;
					}
				}
				break;
			default:
				free(ypcurrent);
				ypcurrent = NULL;
				user = pw->pw_name + 1;
				r = yp_match(__ypdomain, map,
				    user, strlen(user),
				    &ypcurrent, &ypcurrentlen);
				if (r != 0 || ypcurrentlen > buflen) {
					free(ypcurrent);
					ypcurrent = NULL;
					continue;
				}
				break;
			}
			bcopy(ypcurrent, buf, ypcurrentlen);
			buf[ypcurrentlen] = '\0';
			if (__ypparse(pw, buf, yp_pw_flags) ||
			    __ypexclude_is(&ypexhead, pw->pw_name)) {
				if (s == 1)	/* inside netgrp */
					goto pwnam_netgrp;
				continue;
			}
			break;
		case '-':
			/* attempted exclusion */
			switch (pw->pw_name[1]) {
			case '\0':
				break;
			case '@@':
				setnetgrent(pw->pw_name + 2);
				while (getnetgrent(&host, &user, &dom)) {
					if (user && *user)
						__ypexclude_add(&ypexhead, user);
				}
				endnetgrent();
				break;
			default:
				__ypexclude_add(&ypexhead, pw->pw_name + 1);
				break;
			}
			break;
		}
		if ((lookup == LOOKUP_BYUID && pw->pw_uid == uid) ||
		    (lookup == LOOKUP_BYNAME && strcmp(pw->pw_name, name) == 0))
			goto done;
		if (s == 1)	/* inside netgrp */
			goto pwnam_netgrp;
		continue;
	}
	pw = NULL;
done:
	__ypexclude_free(&ypexhead);
	__ypproto = NULL;
	free(ypcurrent);
	ypcurrent = NULL;
	if (map)
		free(name);
	return (pw);
}
#endif /* YP */

static struct passwd *
_pwhashbyname(const char *name, char *buf, size_t buflen, struct passwd *pw,
    int *flagsp)
{
	char bf[1 + _PW_NAME_LEN];
	size_t len;
	DBT key;
	int r;

	len = strlen(name);
	if (len > _PW_NAME_LEN)
		return (NULL);
	bf[0] = _PW_KEYBYNAME;
	bcopy(name, &bf[1], MINIMUM(len, _PW_NAME_LEN));
	key.data = (u_char *)bf;
	key.size = 1 + MINIMUM(len, _PW_NAME_LEN);
	r = __hashpw(&key, buf, buflen, pw, flagsp);
	if (r)
		return (pw);
	return (NULL);
}

static struct passwd *
_pwhashbyuid(uid_t uid, char *buf, size_t buflen, struct passwd *pw,
    int *flagsp)
{
	char bf[1 + sizeof(int)];
	DBT key;
	int r;

	bf[0] = _PW_KEYBYUID;
	bcopy(&uid, &bf[1], sizeof(uid));
	key.data = (u_char *)bf;
	key.size = 1 + sizeof(uid);
	r = __hashpw(&key, buf, buflen, pw, flagsp);
	if (r)
		return (pw);
	return (NULL);
}

static int
getpwnam_internal(const char *name, struct passwd *pw, char *buf, size_t buflen,
    struct passwd **pwretp, int shadow)
{
	struct passwd *pwret = NULL;
	int flags = 0, *flagsp;
	int my_errno = 0;
	int saved_errno, tmp_errno;

	_THREAD_PRIVATE_MUTEX_LOCK(pw);
	saved_errno = errno;
	errno = 0;
	if (!_pw_db && !__initdb(shadow))
		goto fail;

	if (pw == &_pw_passwd)
		flagsp = &_pw_flags;
	else
		flagsp = &flags;

#ifdef YP
	if (__has_yppw())
		pwret = __yppwlookup(LOOKUP_BYNAME, (char *)name, 0, pw,
		    buf, buflen, flagsp);
#endif /* YP */
	if (!pwret)
		pwret = _pwhashbyname(name, buf, buflen, pw, flagsp);

	if (!_pw_stayopen) {
		tmp_errno = errno;
		(void)(_pw_db->close)(_pw_db);
		_pw_db = NULL;
		errno = tmp_errno;
	}
fail:
	if (pwretp)
		*pwretp = pwret;
	if (pwret == NULL)
		my_errno = errno;
	errno = saved_errno;
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
	return (my_errno);
}

int
getpwnam_r(const char *name, struct passwd *pw, char *buf, size_t buflen,
    struct passwd **pwretp)
{
	return getpwnam_internal(name, pw, buf, buflen, pwretp, 0);
}
DEF_WEAK(getpwnam_r);

struct passwd *
getpwnam(const char *name)
{
	struct passwd *pw = NULL;
	int my_errno;

	my_errno = getpwnam_r(name, &_pw_passwd, _pw_string,
	    sizeof _pw_string, &pw);
	if (my_errno) {
		pw = NULL;
		errno = my_errno;
	}
	return (pw);
}

struct passwd *
getpwnam_shadow(const char *name)
{
	struct passwd *pw = NULL;
	int my_errno;

	my_errno = getpwnam_internal(name, &_pw_passwd, _pw_string,
	    sizeof _pw_string, &pw, 1);
	if (my_errno) {
		pw = NULL;
		errno = my_errno;
	}
	return (pw);
}
DEF_WEAK(getpwnam_shadow);

static int
getpwuid_internal(uid_t uid, struct passwd *pw, char *buf, size_t buflen,
    struct passwd **pwretp, int shadow)
{
	struct passwd *pwret = NULL;
	int flags = 0, *flagsp;
	int my_errno = 0;
	int saved_errno, tmp_errno;

	_THREAD_PRIVATE_MUTEX_LOCK(pw);
	saved_errno = errno;
	errno = 0;
	if (!_pw_db && !__initdb(shadow))
		goto fail;

	if (pw == &_pw_passwd)
		flagsp = &_pw_flags;
	else
		flagsp = &flags;

#ifdef YP
	if (__has_yppw())
		pwret = __yppwlookup(LOOKUP_BYUID, NULL, uid, pw,
		    buf, buflen, flagsp);
#endif /* YP */
	if (!pwret)
		pwret = _pwhashbyuid(uid, buf, buflen, pw, flagsp);

	if (!_pw_stayopen) {
		tmp_errno = errno;
		(void)(_pw_db->close)(_pw_db);
		_pw_db = NULL;
		errno = tmp_errno;
	}
fail:
	if (pwretp)
		*pwretp = pwret;
	if (pwret == NULL)
		my_errno = errno;
	errno = saved_errno;
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
	return (my_errno);
}


int
getpwuid_r(uid_t uid, struct passwd *pw, char *buf, size_t buflen,
    struct passwd **pwretp)
{
	return getpwuid_internal(uid, pw, buf, buflen, pwretp, 0);
}
DEF_WEAK(getpwuid_r);

struct passwd *
getpwuid(uid_t uid)
{
	struct passwd *pw = NULL;
	int my_errno;

	my_errno = getpwuid_r(uid, &_pw_passwd, _pw_string,
	    sizeof _pw_string, &pw);
	if (my_errno) {
		pw = NULL;
		errno = my_errno;
	}
	return (pw);
}

struct passwd *
getpwuid_shadow(uid_t uid)
{
	struct passwd *pw = NULL;
	int my_errno;

	my_errno = getpwuid_internal(uid, &_pw_passwd, _pw_string,
	    sizeof _pw_string, &pw, 1);
	if (my_errno) {
		pw = NULL;
		errno = my_errno;
	}
	return (pw);
}
DEF_WEAK(getpwuid_shadow);

int
setpassent(int stayopen)
{
	_THREAD_PRIVATE_MUTEX_LOCK(pw);
	_pw_keynum = 0;
	_pw_stayopen = stayopen;
#ifdef YP
	__ypmode = YPMODE_NONE;
	free(__ypcurrent);
	__ypcurrent = NULL;
	__ypexclude_free(&__ypexhead);
	__ypproto = NULL;
#endif
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
	return (1);
}
DEF_WEAK(setpassent);

void
setpwent(void)
{
	(void) setpassent(0);
}

void
endpwent(void)
{
	int saved_errno;

	_THREAD_PRIVATE_MUTEX_LOCK(pw);
	saved_errno = errno;
	_pw_keynum = 0;
	if (_pw_db) {
		(void)(_pw_db->close)(_pw_db);
		_pw_db = NULL;
	}
#ifdef YP
	__ypmode = YPMODE_NONE;
	free(__ypcurrent);
	__ypcurrent = NULL;
	__ypexclude_free(&__ypexhead);
	__ypproto = NULL;
#endif
	errno = saved_errno;
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
}

static int
__initdb(int shadow)
{
	static int warned;
	int saved_errno = errno;

#ifdef YP
	/*
	 * Hint to the kernel that a passwd database operation is happening.
	 */
	(void)access("/var/run/ypbind.lock", R_OK);

	__ypmode = YPMODE_NONE;
	__getpwent_has_yppw = -1;
#endif
	if (shadow)
		_pw_db = dbopen(_PATH_SMP_DB, O_RDONLY, 0, DB_HASH, NULL);
	if (!_pw_db)
	    _pw_db = dbopen(_PATH_MP_DB, O_RDONLY, 0, DB_HASH, NULL);
	if (_pw_db) {
		errno = saved_errno;
		return (1);
	}
	if (!warned) {
		saved_errno = errno;
		errno = saved_errno;
		warned = 1;
	}
	return (0);
}

static int
__hashpw(DBT *key, char *buf, size_t buflen, struct passwd *pw,
    int *flagsp)
{
	char *p, *t;
	DBT data;

	if ((_pw_db->get)(_pw_db, key, &data, 0))
		return (0);
	p = (char *)data.data;
	if (data.size > buflen) {
		errno = ERANGE;
		return (0);
	}

	t = buf;
#define	EXPAND(e)	e = t; while ((*t++ = *p++));
	EXPAND(pw->pw_name);
	EXPAND(pw->pw_passwd);
	bcopy(p, (char *)&pw->pw_uid, sizeof(int));
	p += sizeof(int);
	bcopy(p, (char *)&pw->pw_gid, sizeof(int));
	p += sizeof(int);
	bcopy(p, (char *)&pw->pw_change, sizeof(time_t));
	p += sizeof(time_t);
	EXPAND(pw->pw_class);
	EXPAND(pw->pw_gecos);
	EXPAND(pw->pw_dir);
	EXPAND(pw->pw_shell);
	bcopy(p, (char *)&pw->pw_expire, sizeof(time_t));
	p += sizeof(time_t);

	/* See if there's any data left.  If so, read in flags. */
	if (data.size > (p - (char *)data.data)) {
		bcopy(p, (char *)flagsp, sizeof(int));
		p += sizeof(int);
	} else
		*flagsp = _PASSWORD_NOUID|_PASSWORD_NOGID;	/* default */
	return (1);
}
@


1.60
log
@Remove NULL-checks before free() and a few related dead assignments.

ok and valuable input from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.59 2015/12/01 15:08:25 deraadt Exp $ */
d746 1
a746 2
	/* XXX shadow should be 0 XXX */
	return getpwnam_internal(name, pw, buf, buflen, pwretp, 1);
d830 1
a830 2
	/* XXX shadow should be 0 XXX */
	return getpwuid_internal(uid, pw, buf, buflen, pwretp, 1);
@


1.59
log
@modify getpw*(), getgr*(), and getgrouplist() functions to access the
YP lock file unconditionally.  This hints to the kernel that a "getpw"
operation is happening, even in the non-YP case.  This looks like a
gruesome hack, but helps refine the ways these functions are called
and mandates the right pledge requests.  Once the tree is fully annotated
we will know better how to improve the backing store management.
ok semarie espie beck
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.58 2015/11/24 22:03:33 millert Exp $ */
d556 2
a557 4
				if (ypcurrent) {
					free(ypcurrent);
					ypcurrent = NULL;
				}
d569 2
a570 4
				if (ypcurrent) {
					free(ypcurrent);
					ypcurrent = NULL;
				}
d598 2
a599 4
				if (ypcurrent) {
					free(ypcurrent);
					ypcurrent = NULL;
				}
@


1.58
log
@Use reentrant versions of getpw{nam,uid} and getgr{nam,gid} within
libc to avoid reusing the static buffers returned by the non-reentrant
versions.  Since this is inside libc we can use constants for the
buffer sizes instead of having to call sysconf().
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.57 2015/11/18 16:44:46 tedu Exp $ */
d927 5
a944 1
		syslog(LOG_ERR, "%s: %m", _PATH_MP_DB);
@


1.57
log
@Add _shadow variants to the two popular getpw functions (uid and nam).
This version of the function will always open the secure/shadow/master
password files. Soon, the regular variants of these functions will not.
(Intermixing shadow and regular gets a little weird; don't do that.)
Not using struct spwd and getspwnam functions to reduce churn in callers.
Should just be a one line diff in most places.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.56 2015/09/14 16:09:13 tedu Exp $ */
a770 1
DEF_WEAK(getpwnam);
a855 1
DEF_WEAK(getpwuid);
@


1.56
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.55 2015/09/13 15:33:48 guenther Exp $ */
d68 1
a68 1
static int __initdb(void);
d266 1
a266 1
	if (!_pw_db && !__initdb())
d704 3
a706 3
int
getpwnam_r(const char *name, struct passwd *pw, char *buf, size_t buflen,
    struct passwd **pwretp)
d716 1
a716 1
	if (!_pw_db && !__initdb())
d747 8
d773 19
a791 3
int
getpwuid_r(uid_t uid, struct passwd *pw, char *buf, size_t buflen,
    struct passwd **pwretp)
d801 1
a801 1
	if (!_pw_db && !__initdb())
d832 9
d859 16
d923 1
a923 1
__initdb(void)
d932 5
a936 2
	if ((_pw_db = dbopen(_PATH_SMP_DB, O_RDONLY, 0, DB_HASH, NULL)) ||
	    (_pw_db = dbopen(_PATH_MP_DB, O_RDONLY, 0, DB_HASH, NULL))) {
@


1.55
log
@Wrap <pwd.h> so that calls go direct and the symbols are all weak.
Hide bcrypt_autorounds(), prefixing with an underbar for static builds.
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.54 2015/06/03 02:24:36 millert Exp $ */
d297 1
a297 2
					if (data)
						free(data);
d309 1
a309 2
					if (data)
						free(data);
d334 1
a334 2
				if (data)
					free(data);
d349 1
a349 2
					if (data)
						free(data);
d505 1
a505 2
	if (key)
		free(key);
d564 1
a564 2
					if (ypcurrent)
						free(ypcurrent);
d590 1
a590 2
						if (ypcurrent)
							free(ypcurrent);
d611 1
a611 2
					if (ypcurrent)
						free(ypcurrent);
d656 1
a656 2
	if (ypcurrent)
		free(ypcurrent);
d834 1
a834 2
	if (__ypcurrent)
		free(__ypcurrent);
d864 1
a864 2
	if (__ypcurrent)
		free(__ypcurrent);
@


1.54
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.53 2015/01/16 16:48:51 deraadt Exp $ */
d756 1
d772 1
d817 1
d833 1
d852 1
@


1.53
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.52 2014/03/12 10:54:36 schwarze Exp $ */
d545 4
a549 1
					name = strdup(name);
d551 4
a555 1
					asprintf(&name, "%u", uid);
@


1.52
log
@Make sure that setgrent(), endgrent(), and endpwent() do not clobber
errno; they might do so on open() and close() failures, but by POSIX,
they are not supposed to fail.  Note that ignoring failures inside
setgrent() does not matter, the following getgrent() is bound to
fail the same way again, anyway.  If you insist on detecting open()
failure, use setgroupent(), even though that is less portable.
While here, remove two pointless (void) casts.
ok millert@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.51 2014/03/12 09:58:23 schwarze Exp $ */
d33 1
a33 1
#include <sys/param.h>
d54 2
d680 1
a680 1
	bcopy(name, &bf[1], MIN(len, _PW_NAME_LEN));
d682 1
a682 1
	key.size = 1 + MIN(len, _PW_NAME_LEN);
@


1.51
log
@The functions getpw{nam,uid}_r() no longer set errno, not even if an
error occurs, but of course they do return the error.  This matches
what getgr{nam,gid}_r() have already been doing.  Original idea
by kettenis@@, and deraadt@@ called that idea "the only sane approach".
ok kettenis@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.50 2014/03/08 16:47:43 schwarze Exp $ */
d850 2
d853 1
d867 1
@


1.50
log
@Fix getpw{nam,uid}{,_r}() errno handling for the non-YP case.
Prevent close(2) and syslog(3) from stomping on errno; from guenther@@.
Set ERANGE if the buf is too small, required by POSIX; from jca@@.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.49 2014/03/05 23:44:47 schwarze Exp $ */
d744 1
a744 2
	if (!errno)
		errno = saved_errno;
d753 1
d755 3
a757 1
	if (getpwnam_r(name, &_pw_passwd, _pw_string, sizeof _pw_string, &pw))
d759 2
d803 1
a803 2
	if (!errno)
		errno = saved_errno;
d812 1
d814 3
a816 1
	if (getpwuid_r(uid, &_pw_passwd, _pw_string, sizeof _pw_string, &pw))
d818 2
@


1.49
log
@Fix the return values of getpwnam_r(), getpwuid_r(), getgrnam_r(),
and getgrgid_r() to agree with POSIX.  Not touching errno handling
yet, which will also need fixing.

Problem originally reported by william at 25thandClement dot com on bugs@@.
OK sthen@@, and kettenis@@ agrees it's "a step in the right direction".
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.48 2013/11/15 22:32:55 benno Exp $ */
d712 1
a712 1
	int saved_errno;
d734 1
d737 1
d767 1
a767 1
	int saved_errno;
d789 1
d792 1
d874 2
a875 1
	if (!warned)
d877 3
a879 1
	warned = 1;
d893 2
a894 1
	if (data.size > buflen)
d896 1
@


1.48
log
@getpwnam_r() and getpwuid_r() reopen the passwd even when called with
setpassent(stayopen).

Bug found and fixed by Erik Lax <erik-AT-halon-DOT-se>
ok millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.47 2013/11/12 07:04:54 deraadt Exp $ */
d711 2
d715 2
d740 4
d745 1
a745 1
	return (pwret ? 0 : 1);
d764 2
d768 2
d793 4
d798 1
a798 1
	return (pwret ? 0 : 1);
@


1.47
log
@ANSI prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.46 2013/08/15 18:19:50 miod Exp $ */
a710 1
	DB *savedb;
a712 1
	savedb = _pw_db;
d729 1
a729 1
	if (savedb != _pw_db || !_pw_stayopen) {
a755 1
	DB *savedb;
a757 1
	savedb = _pw_db;
d774 1
a774 1
	if (savedb != _pw_db || !_pw_stayopen) {
@


1.46
log
@Align stack yp buffers to 64-bit boundaries now, for they might contain
a struct passwd. ok deraadt@@ guenther@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.45 2013/03/21 21:59:32 deraadt Exp $ */
d66 1
a66 1
static int __initdb();
d86 1
a86 1
static int __has_yppw();
@


1.45
log
@Do not need machine/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.44 2013/01/07 01:01:11 deraadt Exp $ */
d88 1
a88 1
static void __ypproto_set(struct passwd *, long *, int, int *);
d103 1
a103 1
__ypproto_set(struct passwd *pw, long *buf, int flags, int *yp_pw_flagsp)
d382 1
a382 1
		static long __yppbuf[_PW_BUF_LEN / sizeof(long)];
d522 1
a522 1
	static long yppbuf[_PW_BUF_LEN / sizeof(long)];
@


1.44
log
@use a size_t instead of an int to avoid signed compare
spotted by Ilja Van Sprundel
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.43 2011/09/05 03:52:24 guenther Exp $ */
a44 1
#include <machine/param.h>
@


1.43
log
@Preserve errno across calls to open the password database(s), so
that errno isn't changed when a normal user (who can't open spwd.db)
does a lookup.

Problem pointed out by Tim van der Molen (tbvdm at xs4all.nl)
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.42 2009/11/21 10:24:59 chl Exp $ */
d671 1
a671 1
	int len, r;
d673 1
@


1.42
log
@remove unused variable

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.41 2009/11/12 18:00:18 deraadt Exp $ */
d847 1
d854 2
a855 1
	    (_pw_db = dbopen(_PATH_MP_DB, O_RDONLY, 0, DB_HASH, NULL)))
d857 1
@


1.41
log
@simplify the code looking for + in the password database, after analysis
of a false positive made by parfait; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.40 2009/06/03 16:02:44 schwarze Exp $ */
a448 1
	int len;
@


1.40
log
@Take advantage of the surprise libc bump to bring in
YP group(5) exclusion, i.e. support -groupname:*:: in /etc/group.
Such groups will be excluded from later +:*::,
in just the same was as it is already done for passwd(5).
I have been running this since the autumn of 2008.
Discussed with several (including deraadt@@, millert@@, jmc@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.39 2009/03/27 12:31:31 schwarze Exp $ */
d448 1
a448 1
	char bf[1 + _PW_NAME_LEN];
d456 1
a456 2
	len = strlen("+");
	bcopy("+", &bf[1], MIN(len, _PW_NAME_LEN));
d458 1
a458 1
	pkey.size = 1 + MIN(len, _PW_NAME_LEN);
@


1.39
log
@getgrouplist: If YP is #defined and enabled in /etc/group(5) and /etc/netid(5)
  contains a matching entry, use that and refrain from accessing YP.
getpwnam/getpwuid: If YP is #defined and /etc/master.passwd(5) contains
  a matching entry before the first YP entry, use that and stay away from YP.

Taken together, this allows a solution to the following problem pointed
out by deraadt@@: When YP was configured but temporarily unavailable, even
root login would block, hindering you when trying to do repairs.
To avoid this, you can now provide a static entry for root in /etc/netid.

Using suggestions from miod@@ otto@@ blambert@@ jmc@@.
"commit" deraadt@@, "cool" ajacoutot@@, "looks fine" jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.38 2008/07/23 19:36:47 deraadt Exp $ */
d51 1
a75 5
struct _ypexclude {
	const char *name;
	struct _ypexclude *next;
};

a88 3
static int __ypexclude_add(struct _ypexclude **, const char *);
static int __ypexclude_is(struct _ypexclude **, const char *);
static void __ypexclude_free(struct _ypexclude **);
a101 50

/*
 * Using DB for this just wastes too damn much memory.
 */
static int
__ypexclude_add(struct _ypexclude **headp, const char *name)
{
	struct _ypexclude *new;

	if (name[0] == '\0')	/* skip */
		return (0);

	new = (struct _ypexclude *)malloc(sizeof(struct _ypexclude));
	if (new == NULL)
		return (1);
	new->name = strdup(name);
	if (new->name == NULL) {
		free(new);
		return (1);
	}

	new->next = *headp;
	*headp = new;
	return (0);
}

static int
__ypexclude_is(struct _ypexclude **headp, const char *name)
{
	struct _ypexclude *curr;

	for (curr = *headp; curr; curr = curr->next) {
		if (strcmp(curr->name, name) == 0)
			return (1);	/* excluded */
	}
	return (0);
}

static void
__ypexclude_free(struct _ypexclude **headp)
{
	struct _ypexclude *curr, *next;

	for (curr = *headp; curr; curr = next) {
		next = curr->next;
		free((void *)curr->name);
		free(curr);
	}
	*headp = NULL;
}
@


1.38
log
@Avoid an occasional double free in getpwent() which corrupted memory.  It
happened only in the case of a + record indicating to use YP, but with ypbind
not actually running.  Problem found by pyr; solution found with millert
ok millert pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.37 2008/07/06 22:19:39 deraadt Exp $ */
d580 1
a580 1
	char bf[1 + _PW_NAME_LEN], *ypcurrent = NULL, *map;
a586 8
	if (lookup == LOOKUP_BYNAME) {
		map = PASSWD_BYNAME;
		name = strdup(name);
	} else {
		map = PASSWD_BYUID;
		asprintf(&name, "%u", uid);
	}

d601 9
d719 2
a720 1
	free(name);
@


1.37
log
@oops, fix getpwent() use of wrong buffers
found by alexander.schrijver
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.36 2008/06/25 14:51:27 millert Exp $ */
d335 1
a335 1
		char *key, *data;
a354 1
					data = NULL;
a372 1
			data = NULL;
a397 1
			data = NULL;
a413 1
				data = NULL;
@


1.36
log
@Add _PW_BUF_LEN define and use it instead of hard-coding 1024 for
the buffer size.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.35 2008/06/24 14:27:24 deraadt Exp $ */
d317 1
a317 1
	char bf[1 + sizeof(_pw_keynum)], pwbuf[_PW_BUF_LEN];
d441 2
a442 1
	if (__hashpw(&key, pwbuf, sizeof pwbuf, &_pw_passwd, &_pw_flags)) {
@


1.35
log
@implement getpwnam_r() and getpwuid_r() -- very nearly a rewrite of the
entire file.  much help from kurt, and tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: getpwent.c,v 1.34 2005/08/08 08:05:34 espie Exp $ */
d60 1
a60 1
static char _pw_string[1024];		/* string pointed to by _pw_passwd */
d87 1
a87 1
static char	__ypline[1024];
d317 1
a317 1
	char bf[1 + sizeof(_pw_keynum)], pwbuf[1024];
d443 1
a443 1
		static long __yppbuf[1024 / sizeof(long)];
d585 1
a585 1
	static long yppbuf[1024 / sizeof(long)];
@


1.34
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d3 1
d52 1
d54 5
d60 1
a60 1
static DB *_pw_db;			/* password database */
d64 7
a70 2
static int __hashpw(DBT *);
static int __initdb(void);
d73 8
d82 2
a83 3
static enum _ypmode __ypmode;

static char	*__ypcurrent, *__ypdomain;
d85 2
a86 2
static struct passwd *__ypproto = (struct passwd *)NULL;
static int	__ypflags;
d88 2
a89 2
static long	__yppbuf[1024 / sizeof(long)];
static int	__yp_override_passwd = 0;
d91 1
a91 1
static int __has_yppw(void);
d93 10
a102 6

static int __ypexclude_add(const char *);
static int __ypexclude_is(const char *);
static void __ypexclude_free(void);
static void __ypproto_set(void);
static int __ypparse(struct passwd *pw, char *s);
d106 1
a106 1
	__has_ypmaster() ? "master.passwd.byname" : "passwd.byname"
d108 1
a108 7
	__has_ypmaster() ? "master.passwd.byuid" : "passwd.byuid"

struct _ypexclude {
	const char *name;
	struct _ypexclude *next;
};
static struct _ypexclude *__ypexclude = (struct _ypexclude *)NULL;
d114 1
a114 1
__ypexclude_add(const char *name)
d125 1
a125 1
	if (new->name == (char *)NULL) {
d130 2
a131 3
	new->next = __ypexclude;
	__ypexclude = new;

d136 1
a136 1
__ypexclude_is(const char *name)
d140 1
a140 2
	for (curr = __ypexclude; curr != (struct _ypexclude *)NULL;
	    curr = curr->next) {
d148 1
a148 1
__ypexclude_free(void)
d152 1
a152 2
	for (curr = __ypexclude; curr != (struct _ypexclude *)NULL;
	    curr = next) {
a153 1

d157 1
a157 1
	__ypexclude = (struct _ypexclude *)NULL;
d161 1
a161 1
__ypproto_set(void)
a163 1
	struct passwd *pw = &_pw_passwd;
d166 1
a166 1
	ptr = (char *)__yppbuf;
d179 1
a179 1
		__ypproto->pw_name = (char *)NULL;
d188 1
a188 1
		__ypproto->pw_passwd = (char *)NULL;
d209 1
a209 1
		__ypproto->pw_gecos = (char *)NULL;
d218 1
a218 1
		__ypproto->pw_dir = (char *)NULL;
d227 1
a227 1
		__ypproto->pw_shell = (char *)NULL;
d233 1
a233 1
	__ypflags = _pw_flags;
d237 1
a237 1
__ypparse(struct passwd *pw, char *s)
d255 1
a255 1
		return 1;
d258 1
a258 1
		return 1;
d261 1
a261 1
		return 1;
d264 1
a264 1
		return 1;
d272 1
a272 1
			return 1;
d275 1
a275 1
			return 1;
d278 1
a278 1
			return 1;
d281 1
a281 1
			return 1;
d294 2
a295 4
	if (__ypproto != (struct passwd *)NULL) {
		if (__yp_override_passwd && __ypproto->pw_passwd != (char *)NULL)
			pw->pw_passwd = __ypproto->pw_passwd;
		if (!(__ypflags & _PASSWORD_NOUID))
d297 1
a297 1
		if (!(__ypflags & _PASSWORD_NOGID))
d299 1
a299 1
		if (__ypproto->pw_gecos != (char *)NULL)
d301 1
a301 1
		if (__ypproto->pw_dir != (char *)NULL)
d303 1
a303 1
		if (__ypproto->pw_shell != (char *)NULL)
d306 1
a306 1
	return 0;
a309 4
#ifdef YP
static int __getpwent_has_yppw = -1;
#endif

a312 2
	DBT key;
	char bf[sizeof(_pw_keynum) + 1];
d314 2
a315 2
	static char *name = (char *)NULL;
	const char *user, *host, *dom;
d317 3
d321 1
d323 1
a323 1
		return ((struct passwd *)NULL);
d326 2
d333 2
a335 2
		int keylen, datalen;
		int r, s;
d346 1
a346 1
				r = yp_next(__ypdomain, (PASSWD_BYNAME),
d350 1
a351 1
					__ypcurrent = NULL;
a359 3
				bcopy(data, __ypline, datalen);
				free(data);
				data = NULL;
d361 1
a361 1
				r = yp_first(__ypdomain, (PASSWD_BYNAME),
d364 2
a365 1
				if (r != 0) {
a370 3
				bcopy(data, __ypline, datalen);
				free(data);
				data = NULL;
d372 3
d384 2
a385 3
				r = yp_match(__ypdomain, (PASSWD_BYNAME),
				    user, strlen(user),
				    &data, &datalen);
d388 2
a389 1
			if (r != 0) {
d400 1
a400 1
			data = (char *)NULL;
d403 3
a405 4
			if (name != (char *)NULL) {
				r = yp_match(__ypdomain, (PASSWD_BYNAME),
				    name, strlen(name),
				    &data, &datalen);
d408 3
a410 2
				name = (char *)NULL;
				if (r != 0) {
d417 1
a417 1
				data = (char *)NULL;
d429 1
a429 1
		if (__ypparse(&_pw_passwd, __ypline))
d431 2
a432 1
		return &_pw_passwd;
d438 1
a438 1
	bcopy((char *)&_pw_keynum, bf + 1, sizeof(_pw_keynum));
d440 2
a441 2
	key.size = sizeof(_pw_keynum) + 1;
	if (__hashpw(&key)) {
d443 3
d464 2
a465 2
				/* save the prototype */
				__ypproto_set();
d476 2
a477 1
							__ypexclude_add(user);
d482 2
a483 1
					__ypexclude_add(_pw_passwd.pw_name + 1);
d490 2
a491 1
		return &_pw_passwd;
d493 4
a496 1
	return (struct passwd *)NULL;
a499 1

d507 2
a508 2
	DBT key, data;
	DBT pkey, pdata;
a509 1
	char bf[_PW_NAME_LEN + 1];
d517 1
a517 1
	bcopy("+", bf + 1, MIN(len, _PW_NAME_LEN));
d519 1
a519 1
	pkey.size = MIN(len, _PW_NAME_LEN) + 1;
d528 1
a528 2
 * See if there's a FreeBSD-style master.passwd map set.  From the FreeBSD
 * libc code.
d569 3
a571 1
	free (result);
a577 1
#endif
d579 9
a587 3
struct passwd *
getpwnam(const char *name)
{
a588 2
	int len, rval;
	char bf[_PW_NAME_LEN + 1];
d590 22
a611 2
	if (!_pw_db && !__initdb())
		return ((struct passwd *)NULL);
d613 15
a627 16
#ifdef YP
	/*
	 * If YP is active, we must sequence through the passwd file
	 * in sequence.
	 */
	if (__has_yppw()) {
		int r;
		int s = -1;
		const char *host, *user, *dom;

		for (_pw_keynum=1; _pw_keynum; _pw_keynum++) {
			bf[0] = _PW_KEYBYNUM;
			bcopy((char *)&_pw_keynum, bf + 1, sizeof(_pw_keynum));
			key.data = (u_char *)bf;
			key.size = sizeof(_pw_keynum) + 1;
			if (__hashpw(&key) == 0)
d629 30
a658 5
			switch (_pw_passwd.pw_name[0]) {
			case '+':
				if (!__ypdomain) {
					if (_yp_check(&__ypdomain) == 0) {
						continue;
d661 5
a665 73
				/* save the prototype */
				__ypproto_set();

				switch (_pw_passwd.pw_name[1]) {
				case '\0':
					if (__ypcurrent) {
						free(__ypcurrent);
						__ypcurrent = NULL;
					}
					r = yp_match(__ypdomain,
						(PASSWD_BYNAME),
						name, strlen(name),
						&__ypcurrent, &__ypcurrentlen);
					if (r != 0) {
						if (__ypcurrent)
							free(__ypcurrent);
						__ypcurrent = NULL;
						continue;
					}
					break;
				case '@@':
pwnam_netgrp:
					if (__ypcurrent) {
						free(__ypcurrent);
						__ypcurrent = NULL;
					}
					if (s == -1)	/* first time */
						setnetgrent(_pw_passwd.pw_name + 2);
					s = getnetgrent(&host, &user, &dom);
					if (s == 0) {	/* end of group */
						endnetgrent();
						s = -1;
						continue;
					} else {
						if (user && *user) {
							r = yp_match(__ypdomain,
							    (PASSWD_BYNAME),
							    user, strlen(user),
							    &__ypcurrent,
							    &__ypcurrentlen);
						} else
							goto pwnam_netgrp;
						if (r != 0) {
							if (__ypcurrent)
							    free(__ypcurrent);
							__ypcurrent = NULL;
							/*
							 * just because this
							 * user is bad, doesn't
							 * mean they all are.
							 */
							goto pwnam_netgrp;
						}
					}
					break;
				default:
					if (__ypcurrent) {
						free(__ypcurrent);
						__ypcurrent = NULL;
					}
					user = _pw_passwd.pw_name + 1;
					r = yp_match(__ypdomain,
						(PASSWD_BYNAME),
						user, strlen(user),
						&__ypcurrent,
						&__ypcurrentlen);
					if (r != 0) {
						if (__ypcurrent)
							free(__ypcurrent);
						__ypcurrent = NULL;
						continue;
					}
					break;
d667 8
a674 6
				bcopy(__ypcurrent, __ypline, __ypcurrentlen);
				__ypline[__ypcurrentlen] = '\0';
				if (__ypparse(&_pw_passwd, __ypline)
				   || __ypexclude_is(_pw_passwd.pw_name)) {
					if (s == 1)	/* inside netgrp */
						goto pwnam_netgrp;
d678 20
a697 16
			case '-':
				/* attempted exclusion */
				switch (_pw_passwd.pw_name[1]) {
				case '\0':
					break;
				case '@@':
					setnetgrent(_pw_passwd.pw_name + 2);
					while (getnetgrent(&host, &user, &dom)) {
						if (user && *user)
							__ypexclude_add(user);
					}
					endnetgrent();
					break;
				default:
					__ypexclude_add(_pw_passwd.pw_name + 1);
					break;
d699 4
d705 1
a705 12
			if (strcmp(_pw_passwd.pw_name, name) == 0) {
				if (!_pw_stayopen) {
					(void)(_pw_db->close)(_pw_db);
					_pw_db = (DB *)NULL;
				}
				__ypexclude_free();
				__ypproto = (struct passwd *)NULL;
				return &_pw_passwd;
			}
			if (s == 1)	/* inside netgrp */
				goto pwnam_netgrp;
			continue;
d707 17
a723 8
		if (!_pw_stayopen) {
			(void)(_pw_db->close)(_pw_db);
			_pw_db = (DB *)NULL;
		}
		__ypexclude_free();
		__ypproto = (struct passwd *)NULL;
		return (struct passwd *)NULL;
	}
d726 8
a733 1
	bf[0] = _PW_KEYBYNAME;
d736 54
a789 7
		rval = 0;
	else {
		bcopy(name, bf + 1, MIN(len, _PW_NAME_LEN));
		key.data = (u_char *)bf;
		key.size = MIN(len, _PW_NAME_LEN) + 1;
		rval = __hashpw(&key);
	}
d791 1
a791 1
	if (!_pw_stayopen) {
d793 1
a793 1
		_pw_db = (DB *)NULL;
d795 5
a799 1
	return (rval ? &_pw_passwd : (struct passwd *)NULL);
d803 12
a814 1
getpwuid(uid_t uid)
d816 3
a818 4
	DBT key;
	char bf[sizeof(_pw_keynum) + 1];
	uid_t keyuid;
	int rval;
d820 2
d823 6
a828 1
		return ((struct passwd *)NULL);
d831 6
a836 27
	/*
	 * If YP is active, we must sequence through the passwd file
	 * in sequence.
	 */
	if (__has_yppw()) {
		char uidbuf[20];
		int r;
		int s = -1;
		const char *host, *user, *dom;

		snprintf(uidbuf, sizeof uidbuf, "%u", uid);
		for (_pw_keynum=1; _pw_keynum; _pw_keynum++) {
			bf[0] = _PW_KEYBYNUM;
			bcopy((char *)&_pw_keynum, bf + 1, sizeof(_pw_keynum));
			key.data = (u_char *)bf;
			key.size = sizeof(_pw_keynum) + 1;
			if (__hashpw(&key) == 0)
				break;
			switch (_pw_passwd.pw_name[0]) {
			case '+':
				if (!__ypdomain) {
					if (_yp_check(&__ypdomain) == 0) {
						continue;
					}
				}
				/* save the prototype */
				__ypproto_set();
d838 3
a840 118
				switch (_pw_passwd.pw_name[1]) {
				case '\0':
					if (__ypcurrent) {
						free(__ypcurrent);
						__ypcurrent = NULL;
					}
					r = yp_match(__ypdomain, (PASSWD_BYUID),
						uidbuf, strlen(uidbuf),
						&__ypcurrent, &__ypcurrentlen);
					if (r != 0) {
						if (__ypcurrent)
							free(__ypcurrent);
						__ypcurrent = NULL;
						continue;
					}
					break;
				case '@@':
pwuid_netgrp:
					if (__ypcurrent) {
						free(__ypcurrent);
						__ypcurrent = NULL;
					}
					if (s == -1)	/* first time */
						setnetgrent(_pw_passwd.pw_name + 2);
					s = getnetgrent(&host, &user, &dom);
					if (s == 0) {	/* end of group */
						endnetgrent();
						s = -1;
						continue;
					} else {
						if (user && *user) {
							r = yp_match(__ypdomain,
							    (PASSWD_BYNAME),
							    user, strlen(user),
							    &__ypcurrent,
							    &__ypcurrentlen);
						} else
							goto pwuid_netgrp;
						if (r != 0) {
							if (__ypcurrent)
							    free(__ypcurrent);
							__ypcurrent = NULL;
							/*
							 * just because this
							 * user is bad, doesn't
							 * mean they all are.
							 */
							goto pwuid_netgrp;
						}
					}
					break;
				default:
					if (__ypcurrent) {
						free(__ypcurrent);
						__ypcurrent = NULL;
					}
					user = _pw_passwd.pw_name + 1;
					r = yp_match(__ypdomain,
						(PASSWD_BYNAME),
						user, strlen(user),
						&__ypcurrent,
						&__ypcurrentlen);
					if (r != 0) {
						if (__ypcurrent)
							free(__ypcurrent);
						__ypcurrent = NULL;
						continue;
					}
					break;
				}
				bcopy(__ypcurrent, __ypline, __ypcurrentlen);
				__ypline[__ypcurrentlen] = '\0';
				if (__ypparse(&_pw_passwd, __ypline)
				   || __ypexclude_is(_pw_passwd.pw_name)) {
					if (s == 1)	/* inside netgroup */
						goto pwuid_netgrp;
					continue;
				}
				break;
			case '-':
				/* attempted exclusion */
				switch (_pw_passwd.pw_name[1]) {
				case '\0':
					break;
				case '@@':
					setnetgrent(_pw_passwd.pw_name + 2);
					while (getnetgrent(&host, &user, &dom)) {
						if (user && *user)
							__ypexclude_add(user);
					}
					endnetgrent();
					break;
				default:
					__ypexclude_add(_pw_passwd.pw_name + 1);
					break;
				}
				break;
			}
			if (_pw_passwd.pw_uid == uid) {
				if (!_pw_stayopen) {
					(void)(_pw_db->close)(_pw_db);
					_pw_db = (DB *)NULL;
				}
				__ypexclude_free();
				__ypproto = NULL;
				return &_pw_passwd;
			}
			if (s == 1)	/* inside netgroup */
				goto pwuid_netgrp;
			continue;
		}
		if (!_pw_stayopen) {
			(void)(_pw_db->close)(_pw_db);
			_pw_db = (DB *)NULL;
		}
		__ypexclude_free();
		__ypproto = (struct passwd *)NULL;
		return (struct passwd *)NULL;
d842 6
a847 1
#endif /* YP */
d849 4
a852 6
	bf[0] = _PW_KEYBYUID;
	keyuid = uid;
	bcopy(&keyuid, bf + 1, sizeof(keyuid));
	key.data = (u_char *)bf;
	key.size = sizeof(keyuid) + 1;
	rval = __hashpw(&key);
d854 3
a856 5
	if (!_pw_stayopen) {
		(void)(_pw_db->close)(_pw_db);
		_pw_db = (DB *)NULL;
	}
	return (rval ? &_pw_passwd : (struct passwd *)NULL);
d862 1
d870 2
a871 2
	__ypexclude_free();
	__ypproto = (struct passwd *)NULL;
d873 1
d886 1
d890 1
a890 1
		_pw_db = (DB *)NULL;
d897 2
a898 2
	__ypexclude_free();
	__ypproto = (struct passwd *)NULL;
d900 1
d922 2
a923 1
__hashpw(DBT *key)
a925 2
	static u_int max;
	static char *line;
d931 2
a932 14
	if (data.size > max) {
		char *nline;

		max = data.size + 256;
		nline = realloc(line, max);
		if (nline == NULL) {
			if (line)
				free(line);
			line = NULL;
			max = 0;
			return 0;
		}
		line = nline;
	}
d934 1
a934 1
	t = line;
d936 3
a938 3
	EXPAND(_pw_passwd.pw_name);
	EXPAND(_pw_passwd.pw_passwd);
	bcopy(p, (char *)&_pw_passwd.pw_uid, sizeof(int));
d940 1
a940 1
	bcopy(p, (char *)&_pw_passwd.pw_gid, sizeof(int));
d942 1
a942 1
	bcopy(p, (char *)&_pw_passwd.pw_change, sizeof(time_t));
d944 5
a948 5
	EXPAND(_pw_passwd.pw_class);
	EXPAND(_pw_passwd.pw_gecos);
	EXPAND(_pw_passwd.pw_dir);
	EXPAND(_pw_passwd.pw_shell);
	bcopy(p, (char *)&_pw_passwd.pw_expire, sizeof(time_t));
d953 1
a953 1
		bcopy(p, (char *)&_pw_flags, sizeof(int));
d956 1
a956 2
		_pw_flags = _PASSWORD_NOUID|_PASSWORD_NOGID;	/* default */

@


1.33
log
@deregister (and deauto!). ok millert@@ marco@@
@
text
@d1 1
a30 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.32 2004/05/18 02:05:52 jfb Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.32
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d32 1
a32 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.31 2003/06/25 21:16:47 deraadt Exp $";
d153 2
a154 2
	register char *ptr;
	register struct passwd *pw = &_pw_passwd;
d979 1
a979 1
	register char *p, *t;
@


1.31
log
@protos
@
text
@d32 1
a32 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.30 2003/06/02 20:18:34 millert Exp $";
d100 1
a100 2
__ypexclude_add(name)
	const char *name;
d123 1
a123 2
__ypexclude_is(name)
	const char *name;
d136 1
a136 1
__ypexclude_free()
d151 1
a151 1
__ypproto_set()
d228 1
a228 3
__ypparse(pw, s)
struct passwd *pw;
char *s;
d308 1
a308 1
getpwent()
d491 1
a491 1
__has_yppw()
d519 1
a519 1
__has_ypmaster()
d567 1
a567 2
getpwnam(name)
	const char *name;
d919 1
a919 2
setpassent(stayopen)
	int stayopen;
d935 1
a935 1
setpwent()
d941 1
a941 1
endpwent()
d959 1
a959 1
__initdb()
d977 1
a977 2
__hashpw(key)
	DBT *key;
@


1.30
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d32 1
a32 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.29 2003/05/01 20:22:00 avsm Exp $";
d82 1
@


1.29
log
@add missing enumeration case to select to kill gcc warning
millert@@ ok
@
text
@d14 1
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d32 1
a32 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.28 2002/11/21 21:25:19 millert Exp $";
@


1.28
log
@Add a "shadow" group and make the shadow passwd db readable by that
group.  This changes getpw* to always try the shadow db first and
then fall back to the db w/o password hashes.  In the future,
/usr/libexec/auth/login_passwd (and others) will be setgid shadow
instead of setuid root.  OK deraadt@@

If you track -current you should do the following:
 o add group shadow to /etc/group
 o chgrp shadow /etc/spwd.db
 o chmod 640 /etc/spwd.db
 o rebuild and install src/usr.sbin/pwd_mkdb

You do not need to rebuild libc yet, but it would't hurt to do so.
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.27 2002/07/06 03:10:23 deraadt Exp $";
d424 3
@


1.27
log
@KNF
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.26 2002/07/06 00:10:36 deraadt Exp $";
a967 1
	char *p;
d973 2
a974 3
	p = (geteuid()) ? _PATH_MP_DB : _PATH_SMP_DB;
	_pw_db = dbopen(p, O_RDONLY, 0, DB_HASH, NULL);
	if (_pw_db)
d977 1
a977 1
		syslog(LOG_ERR, "%s: %m", p);
@


1.26
log
@cope better if realloc fails; better fix than cloder@@acm.org
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.25 2002/05/24 21:22:37 deraadt Exp $";
d71 2
a72 2
static char     *__ypcurrent, *__ypdomain;
static int      __ypcurrentlen;
d112 1
a112 1
	if (new == (struct _ypexclude *)NULL)
d133 1
a133 1
	     curr = curr->next) {
d146 1
a146 1
	     curr = next) {
d176 1
a176 1
	
d206 1
a206 1
	
d266 1
a266 1
			
d347 2
a348 2
					__ypcurrent, __ypcurrentlen,
					&key, &keylen, &data, &datalen);
d365 2
a366 2
					&__ypcurrent, &__ypcurrentlen,
					&data, &datalen);
d387 2
a388 2
					user, strlen(user),
					&data, &datalen);
d407 2
a408 2
					name, strlen(name),
					&data, &datalen);
d512 2
a513 2
	if ((_pw_db->get)(_pw_db, &key, &data, 0)
	    && (_pw_db->get)(_pw_db, &pkey, &pdata, 0))
d558 1
a558 1
	    	checked = 0;
@


1.25
log
@try to use strlcpy and snprintf more; ok various
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.24 2002/02/19 19:39:36 millert Exp $";
d1005 1
@


1.24
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.23 2002/02/16 21:27:22 millert Exp $";
d770 1
a770 1
		sprintf(uidbuf, "%u", uid);
@


1.23
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.22 2001/07/10 16:46:25 deraadt Exp $";
a748 1
#ifdef __STDC__
a749 4
#else
getpwuid(uid)
	uid_t uid;
#endif
@


1.22
log
@put another YP-only piece inside the ifdef
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.21 2001/02/13 14:51:08 pjanzen Exp $";
d64 2
a65 2
static int __hashpw __P((DBT *));
static int __initdb __P((void));
d79 2
a80 2
static int __has_yppw __P((void));
static int __has_ypmaster __P((void));
d82 4
a85 4
static int __ypexclude_add __P((const char *));
static int __ypexclude_is __P((const char *));
static void __ypexclude_free __P((void));
static void __ypproto_set __P((void));
@


1.21
log
@Avoid theoretical potential buffer overflow
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.20 2001/01/31 17:42:25 deraadt Exp $";
d310 1
d312 1
@


1.20
log
@move utmp to large format, usernames to 32 chars; downsj
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.19 2000/04/25 19:11:48 deraadt Exp $";
d498 1
a498 1
	char bf[_PW_NAME_LEN];
@


1.19
log
@well if you cannot do a libc commit properly a week before 2.7 tree lock, surely it can wait till after 2.7
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.17 1999/09/15 08:57:25 deraadt Exp $";
a43 1
#include <utmp.h>
d498 1
a498 1
	char bf[UT_NAMESIZE];
d506 1
a506 1
	bcopy("+", bf + 1, MIN(len, UT_NAMESIZE));
d508 1
a508 1
	pkey.size = MIN(len, UT_NAMESIZE) + 1;
d574 1
a574 1
	char bf[UT_NAMESIZE + 1];
d730 1
a730 1
	if (len > UT_NAMESIZE)
d733 1
a733 1
		bcopy(name, bf + 1, MIN(len, UT_NAMESIZE));
d735 1
a735 1
		key.size = MIN(len, UT_NAMESIZE) + 1;
@


1.18
log
@getpw*_r()
@
text
@a58 3
#include "thread_private.h"

_THREAD_PRIVATE_MUTEX(pw);
a99 3
static struct passwd *getpwnam_unlocked __P((const char *));
static struct passwd *getpwuid_unlocked __P((uid_t));

d323 1
a323 4
	_THREAD_PRIVATE_MUTEX_LOCK(pw);

	if (!_pw_db && !__initdb()) {
		_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
a324 2
	}

a428 1
		_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
a481 1
		_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
a483 1
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
d569 2
a570 2
static struct passwd *
getpwnam_unlocked(name)
d747 5
a751 2
static struct passwd *
getpwuid_unlocked (uid)
d753 1
a926 108
/* XXX copy static storage into user's buffer */
static int
fill_reent(src, pwd, buffer, bufsize, result)
	struct passwd *src;
	struct passwd *pwd;
	char *buffer;
	size_t bufsize;
	struct passwd **result;
{
	int len;

	*result = NULL;
	if (src == NULL) {
		if (errno == 0)
			return ENOENT;
		return errno;
	}

#define fill_alloc(field)				\
	if (src->field == NULL)				\
		pwd->field = NULL;			\
	else {						\
		len = strlen(src->field) + 1;		\
		if (len > bufsize)			\
			return ERANGE;			\
		memcpy(buffer, src->field, len);	\
		pwd->field = buffer;			\
		buffer += len;				\
		bufsize -= len;				\
	}

	fill_alloc(pw_name)
	fill_alloc(pw_passwd)
	pwd->pw_uid = src->pw_uid;
	pwd->pw_gid = src->pw_gid;
	pwd->pw_change = src->pw_change;
	fill_alloc(pw_class)
	fill_alloc(pw_gecos)
	fill_alloc(pw_dir)
	fill_alloc(pw_shell)
	pwd->pw_expire = src->pw_expire;

#undef fill_alloc

	*result = pwd;
	return 0;
}

struct passwd *
getpwnam(name)
	const char *name;
{
	struct passwd *ret;

	_THREAD_PRIVATE_MUTEX_LOCK(pw);
	ret = getpwnam_unlocked(name);
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
	return ret;
}

int
getpwnam_r(name, pwd, buffer, bufsize, result)
	const char *name;
	struct passwd *pwd;
	char *buffer;
	size_t bufsize;
	struct passwd **result;
{
	int error;
	struct passwd *pw;

	_THREAD_PRIVATE_MUTEX_LOCK(pw);
	pw = getpwnam_unlocked(name);
	error = fill_reent(pw, pwd, buffer, bufsize, result);
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
	return error;
}

struct passwd *
getpwuid(uid)
	uid_t uid;
{
	struct passwd *ret;

	_THREAD_PRIVATE_MUTEX_LOCK(pw);
	ret = getpwuid_unlocked(uid);
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
	return ret;
}

int
getpwuid_r(uid, pwd, buffer, bufsize, result)
	uid_t uid;
	struct passwd *pwd;
	char *buffer;
	size_t bufsize;
	struct passwd **result;
{
	int error;
	struct passwd *pw;

	_THREAD_PRIVATE_MUTEX_LOCK(pw);
	pw = getpwuid_unlocked(uid);
	error = fill_reent(pw, pwd, buffer, bufsize, result);
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
	return error;
}

a930 1
	_THREAD_PRIVATE_MUTEX_LOCK(pw);
a940 1
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
a952 1
	_THREAD_PRIVATE_MUTEX_LOCK(pw);
a965 1
	_THREAD_PRIVATE_MUTEX_UNLOCK(pw);
@


1.17
log
@redo master.passwd.byname check if either the uid or euid changes, this was
a case of bad caching; peter and I
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.15 1999/09/03 16:23:18 millert Exp $";
d59 3
d103 3
d329 4
a332 1
	if (!_pw_db && !__initdb())
d334 2
d440 1
d494 1
d497 1
d583 2
a584 2
struct passwd *
getpwnam(name)
d761 2
a762 5
struct passwd *
#ifdef __STDC__
getpwuid(uid_t uid)
#else
getpwuid(uid)
a763 1
#endif
d937 108
d1049 1
d1060 1
d1073 1
d1087 1
@


1.16
log
@indent
@
text
@d527 2
d530 5
a534 1
	if (checked != -1)
d537 3
a539 1
	if (geteuid() != 0) {
d546 2
d555 2
d560 1
a560 1
	free(result);
d562 2
@


1.15
log
@Use strtol() and strtoul() instead of atoi().  This allows us to catch
errors reasonably and deal correctly with unsigned quantities.
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.14 1998/08/14 21:39:29 deraadt Exp $";
d110 1
a110 1
		return(0);
d114 1
a114 1
		return(1);
d118 1
a118 1
		return(1);
d124 1
a124 1
	return(0);
d136 1
a136 1
			return(1);	/* excluded */
d138 1
a138 1
	return(0);
d170 1
a170 1
	if(pw->pw_name && (pw->pw_name)[0]) {
d179 1
a179 1
	if(pw->pw_passwd && (pw->pw_passwd)[0]) {
d200 1
a200 1
	if(pw->pw_gecos && (pw->pw_gecos)[0]) {
d209 1
a209 1
	if(pw->pw_dir && (pw->pw_dir)[0]) {
d218 1
a218 1
	if(pw->pw_shell && (pw->pw_shell)[0]) {
d293 2
a294 2
	if(__ypproto != (struct passwd *)NULL) {
		if(__yp_override_passwd && __ypproto->pw_passwd != (char *)NULL)
d296 1
a296 1
		if(!(__ypflags & _PASSWORD_NOUID))
d298 1
a298 1
		if(!(__ypflags & _PASSWORD_NOGID))
d300 1
a300 1
		if(__ypproto->pw_gecos != (char *)NULL)
d302 1
a302 1
		if(__ypproto->pw_dir != (char *)NULL)
d304 1
a304 1
		if(__ypproto->pw_shell != (char *)NULL)
d324 1
a324 1
		return((struct passwd *)NULL);
d331 1
a331 1
	if(__getpwent_has_yppw && (__ypmode != YPMODE_NONE)) {
d336 2
a337 2
		if(!__ypdomain) {
			if( _yp_check(&__ypdomain) == 0) {
d342 1
a342 1
		switch(__ypmode) {
d344 1
a344 1
			if(__ypcurrent) {
d349 1
a349 1
				if(r != 0) {
d352 1
a352 1
					if(data)
d366 1
a366 1
				if(r != 0) {
d368 1
a368 1
					if(data)
d379 1
a379 1
			if(s == 0) {	/* end of group */
d384 1
a384 1
			if(user && *user) {
d390 1
a390 1
			if(r != 0) {
d395 1
a395 1
				if(data)
d404 1
a404 1
			if(name != (char *)NULL) {
d411 2
a412 2
				if(r != 0) {
					if(data)
d438 1
a438 1
	if(__hashpw(&key)) {
d442 1
a442 1
			if(_pw_passwd.pw_name[0] == '+') {
d444 1
a444 1
				switch(_pw_passwd.pw_name[1]) {
d461 1
a461 1
			} else if(_pw_passwd.pw_name[0] == '-') {
d463 1
a463 1
				switch(_pw_passwd.pw_name[1]) {
d468 2
a469 2
					while(getnetgrent(&host, &user, &dom)) {
						if(user && *user)
d513 2
a514 2
		return(0);	/* No YP. */
	return(1);
d529 1
a529 1
		return(checked);
d531 1
a531 1
	if(geteuid() != 0) {
d533 1
a533 1
		return(checked);
d536 2
a537 2
	if(!__ypdomain) {
		if(_yp_check(&__ypdomain) == 0) {
d539 1
a539 1
			return(checked);	/* No domain. */
d546 1
a546 1
		return(checked);
d551 1
a551 1
	return(checked);
d564 1
a564 1
		return((struct passwd *)NULL);
d576 1
a576 1
		for(_pw_keynum=1; _pw_keynum; _pw_keynum++) {
d581 1
a581 1
			if(__hashpw(&key) == 0)
d583 1
a583 1
			switch(_pw_passwd.pw_name[0]) {
d585 2
a586 2
				if(!__ypdomain) {
					if(_yp_check(&__ypdomain) == 0) {
d593 1
a593 1
				switch(_pw_passwd.pw_name[1]) {
d595 1
a595 1
					if(__ypcurrent) {
d603 2
a604 2
					if(r != 0) {
						if(__ypcurrent)
d612 1
a612 1
					if(__ypcurrent) {
d616 1
a616 1
					if(s == -1)	/* first time */
d619 1
a619 1
					if(s == 0) {	/* end of group */
d624 1
a624 1
						if(user && *user) {
d632 2
a633 2
						if(r != 0) {
							if(__ypcurrent)
d646 1
a646 1
					if(__ypcurrent) {
d656 2
a657 2
					if(r != 0) {
						if(__ypcurrent)
d666 1
a666 1
				if(__ypparse(&_pw_passwd, __ypline)
d668 1
a668 1
					if(s == 1)	/* inside netgrp */
d675 1
a675 1
				switch(_pw_passwd.pw_name[1]) {
d680 2
a681 2
					while(getnetgrent(&host, &user, &dom)) {
						if(user && *user)
d692 1
a692 1
			if(strcmp(_pw_passwd.pw_name, name) == 0) {
d701 1
a701 1
			if(s == 1)	/* inside netgrp */
d730 1
a730 1
	return(rval ? &_pw_passwd : (struct passwd *)NULL);
d747 1
a747 1
		return((struct passwd *)NULL);
d761 1
a761 1
		for(_pw_keynum=1; _pw_keynum; _pw_keynum++) {
d766 1
a766 1
			if(__hashpw(&key) == 0)
d768 1
a768 1
			switch(_pw_passwd.pw_name[0]) {
d770 2
a771 2
				if(!__ypdomain) {
					if(_yp_check(&__ypdomain) == 0) {
d778 1
a778 1
				switch(_pw_passwd.pw_name[1]) {
d780 1
a780 1
					if(__ypcurrent) {
d787 2
a788 2
					if(r != 0) {
						if(__ypcurrent)
d796 1
a796 1
					if(__ypcurrent) {
d800 1
a800 1
					if(s == -1)	/* first time */
d803 1
a803 1
					if(s == 0) {	/* end of group */
d808 1
a808 1
						if(user && *user) {
d816 2
a817 2
						if(r != 0) {
							if(__ypcurrent)
d830 1
a830 1
					if(__ypcurrent) {
d840 2
a841 2
					if(r != 0) {
						if(__ypcurrent)
d850 1
a850 1
				if(__ypparse(&_pw_passwd, __ypline)
d852 1
a852 1
					if(s == 1)	/* inside netgroup */
d859 1
a859 1
				switch(_pw_passwd.pw_name[1]) {
d864 2
a865 2
					while(getnetgrent(&host, &user, &dom)) {
						if(user && *user)
d876 1
a876 1
			if( _pw_passwd.pw_uid == uid) {
d885 1
a885 1
			if(s == 1)	/* inside netgroup */
d910 1
a910 1
	return(rval ? &_pw_passwd : (struct passwd *)NULL);
d921 1
a921 1
	if(__ypcurrent)
d927 1
a927 1
	return(1);
d946 1
a946 1
	if(__ypcurrent)
d967 1
a967 1
		return(1);
d971 1
a971 1
	return(0);
d984 1
a984 1
		return(0);
d1024 1
a1024 1
	return(1);
@


1.14
log
@realloc repair
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.13 1998/07/14 18:19:16 deraadt Exp $";
d238 2
a239 1
	char *bp, *cp;
d255 4
a258 1
	pw->pw_uid = atoi(cp);
d261 4
a264 1
	pw->pw_gid = atoi(cp);
d266 2
d272 4
a275 1
		pw->pw_change = atoi(cp);
d278 4
a281 1
		pw->pw_expire = atoi(cp);
@


1.13
log
@avoid calling __has_yppw() everytime through getpwent(), by caching the YP status along with the open file status
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.12 1997/12/18 10:12:00 deraadt Exp $";
d972 2
d975 5
a979 2
		line = realloc(line, max);
		if (line == NULL)
d981 2
@


1.12
log
@handle long usernames more carefully
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.11 1997/07/23 21:04:06 kstailey Exp $";
d296 2
a305 1
	int has_yppw;
d312 2
a313 1
	has_yppw = __has_yppw();
d316 1
a316 1
	if(has_yppw && (__ypmode != YPMODE_NONE)) {
d426 1
a426 1
		if(has_yppw) {
d947 1
@


1.11
log
@tabify
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.10 1997/04/18 18:55:16 deraadt Exp $";
d700 8
a707 4
	bcopy(name, bf + 1, MIN(len, UT_NAMESIZE));
	key.data = (u_char *)bf;
	key.size = MIN(len, UT_NAMESIZE) + 1;
	rval = __hashpw(&key);
@


1.10
log
@constrain length of db lookups better; reported by adam@@math.tau.ac.il
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.9 1997/04/13 05:11:07 deraadt Exp $";
d800 1
a800 1
                                                         * just because this
@


1.9
log
@buf oflow; bitblt
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.8 1996/10/16 09:24:21 downsj Exp $";
d492 1
a492 1
	pkey.size = len + 1;
d702 1
a702 1
	key.size = len + 1;
@


1.8
log
@kill __yp_token, other clean ups.
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.7 1996/10/15 18:27:58 downsj Exp $";
d964 6
a969 2
	if (data.size > max && !(line = realloc(line, (max += 1024))))
		return(0);
@


1.7
log
@* optimal exclusions support -- don't waste memory with DB.  assumes
  exclusions lists are typically small.
* move YP_OVERRIDE_PASSWD to a static var.  needs some way for the system
  to set this.
* clean up variable names and some code.
* invisibly support FreeBSD ypserv running in "secure" mode.
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.6 1996/09/16 19:01:08 millert Exp $";
a67 2
const char __yp_token[] = "__YP!";	/* Let pwd_mkdb pull this in. */

d328 1
a328 1
				r = yp_next(__ypdomain, PASSWD_BYNAME,
d346 1
a346 1
				r = yp_first(__ypdomain, PASSWD_BYNAME,
d368 1
a368 1
				r = yp_match(__ypdomain, PASSWD_BYNAME,
d388 1
a388 1
				r = yp_match(__ypdomain, PASSWD_BYNAME,
d484 2
a485 2
	key.data = (u_char *)__yp_token;
	key.size = strlen(__yp_token);
d514 4
a517 2
	if(geteuid() != 0)
		return(0);
d520 4
a523 2
		if(_yp_check(&__ypdomain) == 0)
			return(0);	/* No domain. */
d583 1
a583 1
						PASSWD_BYNAME,
d609 1
a609 1
							    PASSWD_BYNAME,
d635 1
a635 1
						PASSWD_BYNAME,
d763 1
a763 1
					r = yp_match(__ypdomain, PASSWD_BYUID,
d789 1
a789 1
							    PASSWD_BYNAME,
d815 1
a815 1
						PASSWD_BYNAME,
@


1.6
log
@uid_t is now a u_int32_t, treat it as such.
@
text
@d4 1
a4 1
 * Portions Copyright (c) 1994, 1995, Jason Downs.  All rights reserved.
d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.5 1996/09/15 10:09:11 tholo Exp $";
d78 3
a80 3
static char	line[1024];
static long	prbuf[1024 / sizeof(long)];
static DB *__ypexclude = (DB *)NULL;
d83 2
d87 1
d90 15
d107 1
a107 1
const char *name;
d109 1
a109 1
	DBT key, data;
d111 2
a112 14
	/* initialize the exclusion table if needed. */
	if(__ypexclude == (DB *)NULL) {
		__ypexclude = dbopen(NULL, O_RDWR, 600, DB_HASH, NULL);
		if(__ypexclude == (DB *)NULL)
			return(1);
	}

	/* set up the key */
	key.data = (char *)name;
	key.size = strlen(name);

	/* data is nothing. */
	data.data = NULL;
	data.size = 0;
d114 6
a119 2
	/* store it */
	if((__ypexclude->put)(__ypexclude, &key, &data, 0) == -1)
d121 5
a125 1
	
d131 1
a131 1
const char *name;
d133 9
a141 1
	DBT key, data;
d143 4
a146 2
	if(__ypexclude == (DB *)NULL)
		return(0);	/* nothing excluded */
d148 3
a150 3
	/* set up the key */
	key.data = (char *)name;
	key.size = strlen(name);
d152 4
a155 4
	if((__ypexclude->get)(__ypexclude, &key, &data, 0) == 0)
		return(1);	/* excluded */
	
	return(0);
d165 1
a165 1
	ptr = (char *)prbuf;
d241 8
d260 15
a274 2
	pw->pw_change = 0;
	pw->pw_class = "";
a277 1
	pw->pw_expire = 0;
d281 1
a281 2
#ifdef YP_OVERRIDE_PASSWD
		if(__ypproto->pw_passwd != (char *)NULL)
a282 1
#endif
d330 1
a330 1
				r = yp_next(__ypdomain, "passwd.byname",
d344 1
a344 1
				bcopy(data, line, datalen);
d348 1
a348 1
				r = yp_first(__ypdomain, "passwd.byname",
d357 1
a357 1
				bcopy(data, line, datalen);
d370 1
a370 1
				r = yp_match(__ypdomain, "passwd.byname",
d384 1
a384 1
			bcopy(data, line, datalen);
d390 1
a390 1
				r = yp_match(__ypdomain, "passwd.byname",
d401 1
a401 1
				bcopy(data, line, datalen);
d411 2
a412 2
		line[datalen] = '\0';
		if (__ypparse(&_pw_passwd, line))
d501 33
d581 1
a581 1
						"passwd.byname",
d607 1
a607 1
							    "passwd.byname",
d633 1
a633 1
						"passwd.byname",
d645 3
a647 3
				bcopy(__ypcurrent, line, __ypcurrentlen);
				line[__ypcurrentlen] = '\0';
				if(__ypparse(&_pw_passwd, line)
d678 1
a678 4
				if(__ypexclude != (DB *)NULL) {
					(void)(__ypexclude->close)(__ypexclude);
					__ypexclude = (DB *)NULL;
				}
d690 1
a690 4
		if(__ypexclude != (DB *)NULL) {
			(void)(__ypexclude->close)(__ypexclude);
			__ypexclude = (DB *)NULL;
		}
d761 1
a761 1
					r = yp_match(__ypdomain, "passwd.byuid",
d787 1
a787 1
							    "passwd.byname",
d813 1
a813 1
						"passwd.byname",
d825 3
a827 3
				bcopy(__ypcurrent, line, __ypcurrentlen);
				line[__ypcurrentlen] = '\0';
				if(__ypparse(&_pw_passwd, line)
d858 1
a858 4
				if (__ypexclude != (DB *)NULL) {
					(void)(__ypexclude->close)(__ypexclude);
					__ypexclude = (DB *)NULL;
				}
d870 1
a870 4
		if(__ypexclude != (DB *)NULL) {
			(void)(__ypexclude->close)(__ypexclude);
			__ypexclude = (DB *)NULL;
		}
d901 1
a901 4
	if(__ypexclude != (DB *)NULL) {
		(void)(__ypexclude->close)(__ypexclude);
		__ypexclude = (DB *)NULL;
	}
d926 1
a926 4
	if(__ypexclude != (DB *)NULL) {
		(void)(__ypexclude->close)(__ypexclude);
		__ypexclude = (DB *)NULL;
	}
@


1.5
log
@Add a couple of syscalls; bring more prototypes into scope
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.4 1996/09/15 09:31:02 tholo Exp $";
d646 1
a646 1
	int uid;
d651 2
a652 1
	int keyuid, rval;
d668 1
a668 1
		sprintf(uidbuf, "%d", uid);
@


1.4
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.3 1996/08/19 08:24:02 tholo Exp $";
d57 1
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d36 1
a36 1
static char rcsid[] = "$OpenBSD: getpwent.c,v 1.14 1995/07/28 05:43:01 phil Exp $";
a260 1
	char *cp;
a595 2

				continue;
a780 2

				continue;
@


1.2
log
@yp_prot.h lies -> use yp.h (from yp.x) instead, change lots of structure
accesses to match. change xdr_domainname() and some other functions to
take "char **" instead of "char *", as rpcgen intended -- helps programs
linking against rpcgen output of yp.x.  yp_all() should not free it's
return value. split xdryp.c and yplib.c into ~20 files so binaries like
"csh" need not link in functions like yp_maplist(). NIS+'s YP emulation
code lacks YPPROC_ORDER... attempt to deal nicely.
@
text
@a0 2
/*	$NetBSD: getpwent.c,v 1.14 1995/07/28 05:43:01 phil Exp $	*/

d36 1
a36 5
#if 0
static char sccsid[] = "@@(#)getpwent.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: getpwent.c,v 1.14 1995/07/28 05:43:01 phil Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d61 1
a61 1
#include <rpcsvc/yp_prot.h>
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
