head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.2
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.14
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.12
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.8
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.6
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.27.0.20
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.18
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.14
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.16
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.12
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.10
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.8
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.6
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.4
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.20.0.6
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_8:1.16.0.8
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.6
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.16.0.4
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.33;
commitid	pqjnYVtACzQ9ctai;

1.33
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.32;
commitid	iWfSX2BIn0sLw62l;

1.32
date	2015.09.13.08.31.47;	author guenther;	state Exp;
branches;
next	1.31;
commitid	QZ177IcjQzeRxHAC;

1.31
date	2014.09.15.06.15.48;	author guenther;	state Exp;
branches;
next	1.30;
commitid	ztgYHm1nk3mtTyS3;

1.30
date	2011.10.14.16.33.53;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.10.13.31.02;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.06.18.51.09;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.15.04.18.19;	author hugh;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.22.02.42.11;	author ray;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.18.03.55.09;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.10.05.26.55;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.22.18.36.40;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.18.18.11.14;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.22.19.12.57;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.02.25.21.40.17;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.08.14.21.39.25;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.03.19.01.00.55;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.03.19.00.30.02;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.03.17.23.28.58;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.09.12.08.53.08;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.07.28.11.19.59;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.27.08.59.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.27.08.29.09;	author grr;	state Exp;
branches;
next	1.7;

1.7
date	97.07.23.21.09.06;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.07.23.21.04.04;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.06.10.21.44.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.01.04.35.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.09.31.00;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.23.10;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.54;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@/*	$OpenBSD: getcap.c,v 1.33 2015/09/14 16:09:13 tedu Exp $	*/
/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Casey Leedom of Lawrence Livermore National Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <db.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define	BFRAG		1024
#define	BSIZE		1024
#define	ESC		('[' & 037)	/* ASCII ESC */
#define	MAX_RECURSION	32		/* maximum getent recursion */
#define	SFRAG		100		/* cgetstr mallocs in SFRAG chunks */

#define RECOK	(char)0
#define TCERR	(char)1
#define	SHADOW	(char)2

static size_t	 topreclen;	/* toprec length */
static char	*toprec;	/* Additional record specified by cgetset() */
static int	 gottoprec;	/* Flag indicating retrieval of toprecord */

static int	cdbget(DB *, char **, const char *);
static int 	getent(char **, u_int *, char **, FILE *, const char *, int, char *);
static int	nfcmp(const char *, char *);

static int	usedb = 1;

/*
 * Cgetusedb() allows the user to specify whether or not to use a .db
 * version of the database file (if it exists) in preference to the
 * text version.  By default, the getcap(3) routines will use a .db file.
 */
int
cgetusedb(int new_usedb)
{
	int old_usedb = usedb;

	usedb = new_usedb;
	return(old_usedb);
}
DEF_WEAK(cgetusedb);

/*
 * Cgetset() allows the addition of a user specified buffer to be added
 * to the database array, in effect "pushing" the buffer on top of the
 * virtual database. 0 is returned on success, -1 on failure.
 */
int
cgetset(const char *ent)
{
	if (ent == NULL) {
		free(toprec);
		toprec = NULL;
		topreclen = 0;
		return (0);
	}
	topreclen = strlen(ent);
	if ((toprec = malloc(topreclen + 1)) == NULL)
		return (-1);
	gottoprec = 0;
	memcpy(toprec, ent, topreclen + 1);
	return (0);
}
DEF_WEAK(cgetset);

/*
 * Cgetcap searches the capability record buf for the capability cap with
 * type `type'.  A pointer to the value of cap is returned on success, NULL
 * if the requested capability couldn't be found.
 *
 * Specifying a type of ':' means that nothing should follow cap (:cap:).
 * In this case a pointer to the terminating ':' or NUL will be returned if
 * cap is found.
 *
 * If (cap, '@@') or (cap, terminator, '@@') is found before (cap, terminator)
 * return NULL.
 */
char *
cgetcap(char *buf, const char *cap, int type)
{
	char *bp;
	const char *cp;

	bp = buf;
	for (;;) {
		/*
		 * Skip past the current capability field - it's either the
		 * name field if this is the first time through the loop, or
		 * the remainder of a field whose name failed to match cap.
		 */
		for (;;)
			if (*bp == '\0')
				return (NULL);
			else
				if (*bp++ == ':')
					break;

		/*
		 * Try to match (cap, type) in buf.
		 */
		for (cp = cap; *cp == *bp && *bp != '\0'; cp++, bp++)
			continue;
		if (*cp != '\0')
			continue;
		if (*bp == '@@')
			return (NULL);
		if (type == ':') {
			if (*bp != '\0' && *bp != ':')
				continue;
			return(bp);
		}
		if (*bp != type)
			continue;
		bp++;
		return (*bp == '@@' ? NULL : bp);
	}
	/* NOTREACHED */
}
DEF_WEAK(cgetcap);

/*
 * Cgetent extracts the capability record name from the NULL terminated file
 * array db_array and returns a pointer to a malloc'd copy of it in buf.
 * Buf must be retained through all subsequent calls to cgetcap, cgetnum,
 * cgetflag, and cgetstr, but may then be free'd.  0 is returned on success,
 * -1 if the requested record couldn't be found, -2 if a system error was
 * encountered (couldn't open/read a file, etc.), and -3 if a potential
 * reference loop is detected.
 */
int
cgetent(char **buf, char **db_array, const char *name)
{
	u_int dummy;

	return (getent(buf, &dummy, db_array, NULL, name, 0, NULL));
}
DEF_WEAK(cgetent);

/*
 * Getent implements the functions of cgetent.  If fp is non-NULL,
 * *db_array has already been opened and fp is the open file descriptor.  We
 * do this to save time and avoid using up file descriptors for tc=
 * recursions.
 *
 * Getent returns the same success/failure codes as cgetent.  On success, a
 * pointer to a malloc'ed capability record with all tc= capabilities fully
 * expanded and its length (not including trailing ASCII NUL) are left in
 * *cap and *len.
 *
 * Basic algorithm:
 *	+ Allocate memory incrementally as needed in chunks of size BFRAG
 *	  for capability buffer.
 *	+ Recurse for each tc=name and interpolate result.  Stop when all
 *	  names interpolated, a name can't be found, or depth exceeds
 *	  MAX_RECURSION.
 */
static int
getent(char **cap, u_int *len, char **db_array, FILE *fp,
	const char *name, int depth, char *nfield)
{
	DB *capdbp;
	char *r_end, *rp, **db_p;
	int myfd, eof, foundit, opened, retval, clen;
	char *record, *cbuf;
	int tc_not_resolved;
	char pbuf[PATH_MAX];

	/*
	 * Return with ``loop detected'' error if we've recursed more than
	 * MAX_RECURSION times.
	 */
	if (depth > MAX_RECURSION)
		return (-3);

	opened = 0;

	/*
	 * Check if we have a top record from cgetset().
	 */
	if (depth == 0 && toprec != NULL && cgetmatch(toprec, name) == 0) {
		opened++;
		if ((record = malloc(topreclen + 1 + BFRAG)) == NULL)
			return (-2);
		memcpy(record, toprec, topreclen + 1);
		myfd = 0;
		db_p = db_array;
		rp = record + topreclen + 1;
		r_end = rp + BFRAG;
		goto tc_exp;
	}
	/*
	 * Allocate first chunk of memory.
	 */
	if ((record = malloc(BFRAG)) == NULL)
		return (-2);
	r_end = record + BFRAG;
	foundit = 0;
	/*
	 * Loop through database array until finding the record.
	 */

	for (db_p = db_array; *db_p != NULL; db_p++) {
		eof = 0;

		/*
		 * Open database if not already open.
		 */
		if (fp != NULL) {
			(void)fseek(fp, 0L, SEEK_SET);
			myfd = 0;
			opened++;
		} else {
			char *dbrecord;

			clen = snprintf(pbuf, sizeof(pbuf), "%s.db", *db_p);
			if (clen != -1 && clen < sizeof(pbuf) && usedb &&
			    (capdbp = dbopen(pbuf, O_RDONLY, 0, DB_HASH, 0))) {
				opened++;
				retval = cdbget(capdbp, &dbrecord, name);
				if (retval < 0) {
					/* no record available */
					(void)capdbp->close(capdbp);
					continue;
				}
				free(record);
				/* save the data; close frees it */
				clen = strlen(dbrecord);
				if ((cbuf = malloc(clen + 1)) == NULL)
					return (-2);
				memcpy(cbuf, dbrecord, clen + 1);
				if (capdbp->close(capdbp) < 0) {
					free(cbuf);
					return (-2);
				}
				/* assume tc='s have been expanded??? */
				*len = clen;
				*cap = cbuf;
				return (retval);
			} else {
				fp = fopen(*db_p, "re");
				if (fp == NULL) {
					/* No error on unfound file. */
					continue;
				}
				myfd = 1;
				opened++;
			}
		}
		/*
		 * Find the requested capability record ...
		 */
		{
		    char buf[BUFSIZ];
		    char *b_end, *bp;
		    int c;

		    /*
		     * Loop invariants:
		     *	There is always room for one more character in record.
		     *	R_end always points just past end of record.
		     *	Rp always points just past last character in record.
		     *	B_end always points just past last character in buf.
		     *	Bp always points at next character in buf.
		     */
		    b_end = buf;
		    bp = buf;
		    for (;;) {

			/*
			 * Read in a line implementing (\, newline)
			 * line continuation.
			 */
			rp = record;
			for (;;) {
				if (bp >= b_end) {
					size_t n;

					n = fread(buf, 1, sizeof(buf), fp);
					if (n == 0) {
						eof = feof(fp);
						if (myfd)
							(void)fclose(fp);
						if (eof) {
							fp = NULL;
							break;
						}
						free(record);
						return (-2);
					}
					b_end = buf+n;
					bp = buf;
				}

				c = *bp++;
				if (c == '\n') {
					if (rp > record && *(rp-1) == '\\') {
						rp--;
						continue;
					} else
						break;
				}
				*rp++ = c;

				/*
				 * Enforce loop invariant: if no room
				 * left in record buffer, try to get
				 * some more.
				 */
				if (rp >= r_end) {
					size_t pos;
					size_t newsize;
					char *nrecord;

					pos = rp - record;
					newsize = r_end - record + BFRAG;
					nrecord = realloc(record, newsize);
					if (nrecord == NULL) {
						free(record);
						if (myfd)
							(void)fclose(fp);
						errno = ENOMEM;
						return (-2);
					}
					record = nrecord;
					r_end = record + newsize;
					rp = record + pos;
				}
			}
				/* loop invariant lets us do this */
			*rp++ = '\0';

			/*
			 * If encountered EOF check next file.
			 */
			if (eof)
				break;

			/*
			 * Toss blank lines and comments.
			 */
			if (*record == '\0' || *record == '#')
				continue;

			/*
			 * See if this is the record we want ...
			 */
			if (cgetmatch(record, name) == 0) {
				if (nfield == NULL || !nfcmp(nfield, record)) {
					foundit = 1;
					break;	/* found it! */
				}
			}
		    }
		}
		if (foundit)
			break;
	}

	if (!foundit) {
		free(record);
		return (opened ? -1 : -2);
	}

	/*
	 * Got the capability record, but now we have to expand all tc=name
	 * references in it ...
	 */
tc_exp:	{
		char *s;
		u_int ilen;
		int diff, iret, tclen;
		char *ibuf, *icap, *scan, *tc, *tcstart, *tcend;

		/*
		 * Loop invariants:
		 *	There is room for one more character in record.
		 *	R_end points just past end of record.
		 *	Rp points just past last character in record.
		 *	Scan points at remainder of record that needs to be
		 *	scanned for tc=name constructs.
		 */
		scan = record;
		tc_not_resolved = 0;
		for (;;) {
			if ((tc = cgetcap(scan, "tc", '=')) == NULL)
				break;

			/*
			 * Find end of tc=name and stomp on the trailing `:'
			 * (if present) so we can use it to call ourselves.
			 */
			s = tc;
			for (;;) {
				if (*s == '\0')
					break;
				else
					if (*s++ == ':') {
						*(s - 1) = '\0';
						break;
					}
			}
			tcstart = tc - 3;
			tclen = s - tcstart;
			tcend = s;

			iret = getent(&icap, &ilen, db_p, fp, tc, depth+1,
				      NULL);
			if (iret != 0) {
				/* an error */
				if (iret < -1) {
					if (myfd)
						(void)fclose(fp);
					free(record);
					return (iret);
				}
				if (iret == 1)
					tc_not_resolved = 1;
				/* couldn't resolve tc */
				if (iret == -1) {
					*(s - 1) = ':';
					scan = s - 1;
					tc_not_resolved = 1;
					continue;

				}
			}
			/* not interested in name field of tc'ed record */
			s = ibuf = icap;
			for (;;)
				if (*s == '\0')
					break;
				else
					if (*s++ == ':')
						break;
			ilen -= s - icap;
			icap = s;

			/* make sure interpolated record is `:'-terminated */
			s += ilen;
			if (*(s-1) != ':') {
				*s = ':';	/* overwrite NUL with : */
				ilen++;
			}

			/*
			 * Make sure there's enough room to insert the
			 * new record.
			 */
			diff = ilen - tclen;
			if (diff >= r_end - rp) {
				u_int pos, tcpos, tcposend;
				size_t newsize;
				char *nrecord;

				pos = rp - record;
				newsize = r_end - record + diff + BFRAG;
				tcpos = tcstart - record;
				tcposend = tcend - record;
				nrecord = realloc(record, newsize);
				if (nrecord == NULL) {
					free(record);
					if (myfd)
						(void)fclose(fp);
					free(ibuf);
					errno = ENOMEM;
					return (-2);
				}
				record = nrecord;
				r_end = record + newsize;
				rp = record + pos;
				tcstart = record + tcpos;
				tcend = record + tcposend;
			}

			/*
			 * Insert tc'ed record into our record.
			 */
			s = tcstart + ilen;
			memmove(s, tcend, rp - tcend);
			memmove(tcstart, icap, ilen);
			rp += diff;
			free(ibuf);

			/*
			 * Start scan on `:' so next cgetcap works properly
			 * (cgetcap always skips first field).
			 */
			scan = s-1;
		}

	}
	/*
	 * Close file (if we opened it), give back any extra memory, and
	 * return capability, length and success.
	 */
	if (myfd)
		(void)fclose(fp);
	*len = rp - record - 1;	/* don't count NUL */
	if (r_end > rp) {
		char *nrecord;

		if ((nrecord = realloc(record, rp - record)) == NULL) {
			free(record);
			errno = ENOMEM;
			return (-2);
		}
		record = nrecord;
	}
	*cap = record;
	if (tc_not_resolved)
		return (1);
	return (0);
}

static int
cdbget(DB *capdbp, char **bp, const char *name)
{
	DBT key, data;

	key.data = (void *)name;
	key.size = strlen(name);

	for (;;) {
		/* Get the reference. */
		switch(capdbp->get(capdbp, &key, &data, 0)) {
		case -1:
			return (-2);
		case 1:
			return (-1);
		}

		/* If not an index to another record, leave. */
		if (((char *)data.data)[0] != SHADOW)
			break;

		key.data = (char *)data.data + 1;
		key.size = data.size - 1;
	}

	*bp = (char *)data.data + 1;
	return (((char *)(data.data))[0] == TCERR ? 1 : 0);
}

/*
 * Cgetmatch will return 0 if name is one of the names of the capability
 * record buf, -1 if not.
 */
int
cgetmatch(char *buf, const char *name)
{
	char *bp;
	const char *np;

	if (*name == '\0')
		return (-1);
	/*
	 * Start search at beginning of record.
	 */
	bp = buf;
	for (;;) {
		/*
		 * Try to match a record name.
		 */
		np = name;
		for (;;)
			if (*np == '\0') {
				if (*bp == '|' || *bp == ':' || *bp == '\0')
					return (0);
				else
					break;
			} else
				if (*bp++ != *np++)
					break;

		/*
		 * Match failed, skip to next name in record.
		 */
		bp--;	/* a '|' or ':' may have stopped the match */
		for (;;)
			if (*bp == '\0' || *bp == ':')
				return (-1);	/* match failed totally */
			else
				if (*bp++ == '|')
					break;	/* found next name */
	}
}
DEF_WEAK(cgetmatch);

int
cgetfirst(char **buf, char **db_array)
{

	(void)cgetclose();
	return (cgetnext(buf, db_array));
}
DEF_WEAK(cgetfirst);

static FILE *pfp;
static int slash;
static char **dbp;

int
cgetclose(void)
{

	if (pfp != NULL) {
		(void)fclose(pfp);
		pfp = NULL;
	}
	dbp = NULL;
	gottoprec = 0;
	slash = 0;
	return(0);
}
DEF_WEAK(cgetclose);

/*
 * Cgetnext() gets either the first or next entry in the logical database
 * specified by db_array.  It returns 0 upon completion of the database, 1
 * upon returning an entry with more remaining, and -1 if an error occurs.
 */
int
cgetnext(char **cap, char **db_array)
{
	size_t len, otopreclen = topreclen;
	int c, serrno, status = -1;
	char buf[BUFSIZ], nbuf[BSIZE];
	char *b_end, *bp, *r_end, *rp;
	char *record = NULL;
	char *otoprec = toprec;
	u_int dummy;
	off_t pos;

	if (dbp == NULL)
		dbp = db_array;

	if (pfp == NULL && (pfp = fopen(*dbp, "re")) == NULL)
		goto done;

	/*
	 * Check if we have an unused top record from cgetset().
	 */
	if (toprec && !gottoprec) {
		gottoprec = 1;
		record = toprec;
		goto lookup;
	}

	/*
	 * Allocate first chunk of memory.
	 */
	if ((record = malloc(BFRAG)) == NULL)
		goto done;
	r_end = record + BFRAG;

	/*
	 * Find the next capability record
	 */
	/*
	 * Loop invariants:
	 *	There is always room for one more character in record.
	 *	R_end always points just past end of record.
	 *	Rp always points just past last character in record.
	 *	B_end always points just past last character in buf.
	 *	Bp always points at next character in buf.
	 */
	b_end = buf;
	bp = buf;
	for (;;) {
		/*
		 * Read in a line implementing (\, newline)
		 * line continuation.
		 */
		rp = record;
		for (;;) {
			if (bp >= b_end) {
				size_t n;

				n = fread(buf, 1, sizeof(buf), pfp);
				if (n == 0) {
					if (ferror(pfp))
						goto done;
					(void)fclose(pfp);
					pfp = NULL;
					if (*++dbp == NULL) {
						status = 0;
						goto done;
					} else if ((pfp =
					    fopen(*dbp, "re")) == NULL) {
						goto done;
					} else
						continue;
				}
				b_end = buf + n;
				bp = buf;
			}

			c = *bp++;
			if (c == '\n') {
				if (rp > record && *(rp-1) == '\\') {
					rp--;
					continue;
				} else
					break;
			}
			*rp++ = c;

			/*
			 * Enforce loop invariant: if no room
			 * left in record buffer, try to get
			 * some more.
			 */
			if (rp >= r_end) {
				size_t newsize, off;
				char *nrecord;

				off = rp - record;
				newsize = r_end - record + BFRAG;
				nrecord = realloc(record, newsize);
				if (nrecord == NULL)
					goto done;
				record = nrecord;
				r_end = record + newsize;
				rp = record + off;
			}
		}
		/* loop invariant lets us do this */
		*rp++ = '\0';

		/*
		 * If not blank or comment, set toprec and topreclen so
		 * getent() doesn't have to re-parse the file to find it.
		 */
		if (*record != '\0' && *record != '#') {
			/* Rewind to end of record */
			fseeko(pfp, bp - b_end, SEEK_CUR);
			toprec = record;
			topreclen = rp - record;
			break;
		}
	}
lookup:
	/* extract name from record */
	len = strcspn(record, "|:");
	memcpy(nbuf, record, len);
	nbuf[len] = '\0';

	/* return value of getent() is one less than cgetnext() */
	pos = ftello(pfp);
	status = getent(cap, &dummy, dbp, pfp, nbuf, 0, NULL) + 1;
	if (status > 0)
		fseeko(pfp, pos, SEEK_SET);
done:
	serrno = errno;
	if (toprec != otoprec) {
		toprec = otoprec;
		topreclen = otopreclen;
		free(record);
	}
	if (status <= 0)
		(void)cgetclose();
	errno = serrno;

	return (status);
}
DEF_WEAK(cgetnext);

/*
 * Cgetstr retrieves the value of the string capability cap from the
 * capability record pointed to by buf.  A pointer to a decoded, NUL
 * terminated, malloc'd copy of the string is returned in the char *
 * pointed to by str.  The length of the string not including the trailing
 * NUL is returned on success, -1 if the requested string capability
 * couldn't be found, -2 if a system error was encountered (storage
 * allocation failure).
 */
int
cgetstr(char *buf, const char *cap, char **str)
{
	u_int m_room;
	char *bp, *mp;
	int len;
	char *mem;

	/*
	 * Find string capability cap
	 */
	bp = cgetcap(buf, cap, '=');
	if (bp == NULL)
		return (-1);

	/*
	 * Conversion / storage allocation loop ...  Allocate memory in
	 * chunks SFRAG in size.
	 */
	if ((mem = malloc(SFRAG)) == NULL)
		return (-2);	/* couldn't even allocate the first fragment */
	m_room = SFRAG;
	mp = mem;

	while (*bp != ':' && *bp != '\0') {
		/*
		 * Loop invariants:
		 *	There is always room for one more character in mem.
		 *	Mp always points just past last character in mem.
		 *	Bp always points at next character in buf.
		 */
		if (*bp == '^') {
			bp++;
			if (*bp == ':' || *bp == '\0')
				break;	/* drop unfinished escape */
			*mp++ = *bp++ & 037;
		} else if (*bp == '\\') {
			bp++;
			if (*bp == ':' || *bp == '\0')
				break;	/* drop unfinished escape */
			if ('0' <= *bp && *bp <= '7') {
				int n, i;

				n = 0;
				i = 3;	/* maximum of three octal digits */
				do {
					n = n * 8 + (*bp++ - '0');
				} while (--i && '0' <= *bp && *bp <= '7');
				*mp++ = n;
			}
			else switch (*bp++) {
				case 'b': case 'B':
					*mp++ = '\b';
					break;
				case 't': case 'T':
					*mp++ = '\t';
					break;
				case 'n': case 'N':
					*mp++ = '\n';
					break;
				case 'f': case 'F':
					*mp++ = '\f';
					break;
				case 'r': case 'R':
					*mp++ = '\r';
					break;
				case 'e': case 'E':
					*mp++ = ESC;
					break;
				case 'c': case 'C':
					*mp++ = ':';
					break;
				default:
					/*
					 * Catches '\', '^', and
					 *  everything else.
					 */
					*mp++ = *(bp-1);
					break;
			}
		} else
			*mp++ = *bp++;
		m_room--;

		/*
		 * Enforce loop invariant: if no room left in current
		 * buffer, try to get some more.
		 */
		if (m_room == 0) {
			size_t size = mp - mem;
			char *nmem;

			if ((nmem = realloc(mem, size + SFRAG)) == NULL) {
				free(mem);
				return (-2);
			}
			mem = nmem;
			m_room = SFRAG;
			mp = mem + size;
		}
	}
	*mp++ = '\0';	/* loop invariant let's us do this */
	m_room--;
	len = mp - mem - 1;

	/*
	 * Give back any extra memory and return value and success.
	 */
	if (m_room != 0) {
		char *nmem;

		if ((nmem = realloc(mem, mp - mem)) == NULL) {
			free(mem);
			return (-2);
		}
		mem = nmem;
	}
	*str = mem;
	return (len);
}
DEF_WEAK(cgetstr);

/*
 * Cgetustr retrieves the value of the string capability cap from the
 * capability record pointed to by buf.  The difference between cgetustr()
 * and cgetstr() is that cgetustr does not decode escapes but rather treats
 * all characters literally.  A pointer to a  NUL terminated malloc'd
 * copy of the string is returned in the char pointed to by str.  The
 * length of the string not including the trailing NUL is returned on success,
 * -1 if the requested string capability couldn't be found, -2 if a system
 * error was encountered (storage allocation failure).
 */
int
cgetustr(char *buf, const char *cap, char **str)
{
	u_int m_room;
	char *bp, *mp;
	int len;
	char *mem;

	/*
	 * Find string capability cap
	 */
	if ((bp = cgetcap(buf, cap, '=')) == NULL)
		return (-1);

	/*
	 * Conversion / storage allocation loop ...  Allocate memory in
	 * chunks SFRAG in size.
	 */
	if ((mem = malloc(SFRAG)) == NULL)
		return (-2);	/* couldn't even allocate the first fragment */
	m_room = SFRAG;
	mp = mem;

	while (*bp != ':' && *bp != '\0') {
		/*
		 * Loop invariants:
		 *	There is always room for one more character in mem.
		 *	Mp always points just past last character in mem.
		 *	Bp always points at next character in buf.
		 */
		*mp++ = *bp++;
		m_room--;

		/*
		 * Enforce loop invariant: if no room left in current
		 * buffer, try to get some more.
		 */
		if (m_room == 0) {
			size_t size = mp - mem;
			char *nmem;

			if ((nmem = realloc(mem, size + SFRAG)) == NULL) {
				free(mem);
				return (-2);
			}
			mem = nmem;
			m_room = SFRAG;
			mp = mem + size;
		}
	}
	*mp++ = '\0';	/* loop invariant let's us do this */
	m_room--;
	len = mp - mem - 1;

	/*
	 * Give back any extra memory and return value and success.
	 */
	if (m_room != 0) {
		char *nmem;

		if ((nmem = realloc(mem, mp - mem)) == NULL) {
			free(mem);
			return (-2);
		}
		mem = nmem;
	}
	*str = mem;
	return (len);
}
DEF_WEAK(cgetustr);

/*
 * Cgetnum retrieves the value of the numeric capability cap from the
 * capability record pointed to by buf.  The numeric value is returned in
 * the long pointed to by num.  0 is returned on success, -1 if the requested
 * numeric capability couldn't be found.
 */
int
cgetnum(char *buf, const char *cap, long *num)
{
	long n;
	int base, digit;
	char *bp;

	/*
	 * Find numeric capability cap
	 */
	bp = cgetcap(buf, cap, '#');
	if (bp == NULL)
		return (-1);

	/*
	 * Look at value and determine numeric base:
	 *	0x... or 0X...	hexadecimal,
	 * else	0...		octal,
	 * else			decimal.
	 */
	if (*bp == '0') {
		bp++;
		if (*bp == 'x' || *bp == 'X') {
			bp++;
			base = 16;
		} else
			base = 8;
	} else
		base = 10;

	/*
	 * Conversion loop ...
	 */
	n = 0;
	for (;;) {
		if ('0' <= *bp && *bp <= '9')
			digit = *bp - '0';
		else if ('a' <= *bp && *bp <= 'f')
			digit = 10 + *bp - 'a';
		else if ('A' <= *bp && *bp <= 'F')
			digit = 10 + *bp - 'A';
		else
			break;

		if (digit >= base)
			break;

		n = n * base + digit;
		bp++;
	}

	/*
	 * Return value and success.
	 */
	*num = n;
	return (0);
}
DEF_WEAK(cgetnum);

/*
 * Compare name field of record.
 */
static int
nfcmp(const char *nf, char *rec)
{
	char *cp, tmp;
	int ret;

	for (cp = rec; *cp != ':'; cp++)
		;

	tmp = *(cp + 1);
	*(cp + 1) = '\0';
	ret = strcmp(nf, rec);
	*(cp + 1) = tmp;

	return (ret);
}
@


1.33
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.32 2015/09/13 08:31:47 guenther Exp $	*/
d540 1
a540 2
		if ((nrecord =
		     realloc(record, (size_t)(rp - record))) == NULL) {
d774 1
a774 1
			fseeko(pfp, (off_t)(bp - b_end), SEEK_CUR);
d926 1
a926 1
		if ((nmem = realloc(mem, (size_t)(mp - mem))) == NULL) {
@


1.32
log
@Wrap <stdlib.h> so that calls go direct and the symbols not in the
C standard are all weak.
Apply __{BEGIN,END}_HIDDEN_DECLS to gdtoa{,imp}.h, hiding the
arch-specific __strtorx, __ULtox_D2A, __strtorQ, __ULtoQ_D2A symbols.
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.31 2014/09/15 06:15:48 guenther Exp $	*/
d90 1
a90 2
		if (toprec)
			free(toprec);
d356 1
a356 2
						if (record)
							free(record);
d499 1
a499 2
					if (record)
						free(record);
d542 1
a542 2
			if (record)
				free(record);
d909 1
a909 2
				if (mem)
					free(mem);
d928 1
a928 2
			if (mem)
				free(mem);
d990 1
a990 2
				if (mem)
					free(mem);
d1009 1
a1009 2
			if (mem)
				free(mem);
@


1.31
log
@When fopen()ing internal to libc (the API doesn't support the use
of the resulting FILE *), then pass fopen() the 'e' mode letter to
mark it close-on-exec.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.30 2011/10/14 16:33:53 millert Exp $	*/
d79 1
d103 1
d158 1
d176 1
d630 1
d639 1
d658 1
d809 1
d942 1
d1025 1
d1090 1
@


1.30
log
@Fix toprec handling in cgetnext().  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.29 2011/07/10 13:31:02 millert Exp $	*/
d275 1
a275 1
				fp = fopen(*db_p, "r");
d673 1
a673 1
	if (pfp == NULL && (pfp = fopen(*dbp, "r")) == NULL)
d725 1
a725 1
					    fopen(*dbp, "r")) == NULL) {
@


1.29
log
@Use stdio in getent() and reuse pfp from tcgetnext when calling getent().
Cuts cap_mkdb system time in half.  OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.28 2011/07/06 18:51:09 millert Exp $	*/
d661 1
a661 1
	size_t len;
d666 1
d681 1
a774 1
			gottoprec = 1;
d791 5
a795 1
	free(record);
@


1.28
log
@Speed up cgetnext() by passing the record we want to parse in to
getent() as toprec.  Make cap_mkdb faster when building termcap.db.
OK nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.27 2006/05/15 04:18:19 hugh Exp $ */
d61 1
a61 1
static int 	getent(char **, u_int *, char **, int, const char *, int, char *);
d171 1
a171 1
	return (getent(buf, &dummy, db_array, -1, name, 0, NULL));
d175 2
a176 2
 * Getent implements the functions of cgetent.  If fd is non-negative,
 * *db_array has already been opened and fd is the open file descriptor.  We
d193 1
a193 1
getent(char **cap, u_int *len, char **db_array, int fd,
d243 2
a244 2
		if (fd >= 0) {
			(void)lseek(fd, (off_t)0, SEEK_SET);
d275 2
a276 2
				fd = open(*db_p, O_RDONLY, 0);
				if (fd < 0) {
d311 1
a311 1
					int n;
d313 3
a315 2
					n = read(fd, buf, sizeof(buf));
					if (n <= 0) {
d317 3
a319 7
							(void)close(fd);
						if (n < 0) {
							free(record);
							return (-2);
						} else {
							fd = -1;
							eof = 1;
d322 2
d345 1
a345 1
					u_int pos;
d356 1
a356 1
							(void)close(fd);
d442 1
a442 1
			iret = getent(&icap, &ilen, db_p, fd, tc, depth+1,
d448 1
a448 1
						(void)close(fd);
d500 1
a500 1
						(void)close(fd);
d534 1
a534 1
		(void)close(fd);
d662 4
a665 6
	int serrno, status = -1;
	char nbuf[BSIZE];
	char *record = NULL, *r_end, *rp;
	char buf[BUFSIZ];
	char *b_end, *bp;
	int c;
d667 1
d748 1
a748 1
				size_t newsize, pos;
d751 1
a751 1
				pos = rp - record;
d758 1
a758 1
				rp = record + pos;
d784 4
a787 1
	status = getent(cap, &dummy, db_array, -1, nbuf, 0, NULL) + 1;
@


1.27
log
@Handle empty terminal names more gracefully.
Variously OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.26 2006/03/22 02:42:11 ray Exp $ */
d660 1
a660 1
cgetnext(char **bp, char **db_array)
d663 6
a668 2
	int status, done;
	char *line, *np, buf[BSIZE], nbuf[BSIZE];
d674 9
a682 3
	if (pfp == NULL && (pfp = fopen(*dbp, "r")) == NULL) {
		(void)cgetclose();
		return (-1);
d684 21
d706 13
a718 10
		if (toprec && !gottoprec) {
			gottoprec = 1;
			line = toprec;
		} else {
			line = fgetln(pfp, &len);
			if (line == NULL) {
				if (ferror(pfp)) {
					(void)cgetclose();
					return (-1);
				} else {
d722 2
a723 2
						(void)cgetclose();
						return (0);
d726 1
a726 2
						(void)cgetclose();
						return (-1);
d730 2
a731 5
			} else
				line[len - 1] = '\0';/* XXX - assumes newline */
			if (len == 1) {
				slash = 0;
				continue;
d733 8
a740 7
			if (isspace(*line) ||
			    *line == ':' || *line == '#' || slash) {
				if (line[len - 2] == '\\')
					slash = 1;
				else
					slash = 0;
				continue;
d742 1
a742 5
			if (line[len - 2] == '\\')
				slash = 1;
			else
				slash = 0;
		}
d744 8
d753 8
a760 10
		/*
		 * Line points to a name line.
		 */
		done = 0;
		np = nbuf;
		for (;;) {
			len = strcspn(line, ":\\");
			if (line[len] == ':') {
				done = 1;
				++len;
d762 3
a764 7
			/* copy substring */
			if (len >= sizeof(nbuf) - (np - nbuf)) {
				(void)cgetclose();
				return (-1);
			}
			memcpy(np, line, len);
			np += len;
a765 25
			if (done) {
				*np = '\0';
				break;
			} else { /* name field extends beyond the line */
				line = fgetln(pfp, &len);
				if (line == NULL) {
					if (ferror(pfp)) {
						(void)cgetclose();
						return (-1);
					}
					/* Move on to next file. */
					(void)fclose(pfp);
					pfp = NULL;
					++dbp;
					/* NUL terminate nbuf. */
					*np = '\0';
					break;
				} else
					/* XXX - assumes newline */
					line[len - 1] = '\0';
			}
		}
		len = strcspn(nbuf, "|:");
		memcpy(buf, nbuf, len);
		buf[len] = '\0';
d767 2
a768 6
		 * XXX
		 * Last argument of getent here should be nbuf if we want true
		 * sequential access in the case of duplicates.
		 * With NULL, getent will return the first entry found
		 * rather than the duplicate entry record.  This is a
		 * matter of semantics that should be resolved.
d770 23
a792 3
		status = getent(bp, &dummy, db_array, -1, buf, 0, NULL);
		if (status == -2 || status == -3)
			(void)cgetclose();
d794 1
a794 3
		return (status + 1);
	}
	/* NOTREACHED */
@


1.26
log
@Simplify cgetnext(3) by using strcspn(3).

OK jaredy@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.25 2006/03/18 03:55:09 ray Exp $ */
d594 2
@


1.25
log
@In all these cases pfp != NULL.  I also sneaked in some KNF.

Okay jaredy, millert@@, and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.24 2006/03/10 05:26:55 ray Exp $ */
d662 1
a662 1
	char *cp, *line, *np, buf[BSIZE], nbuf[BSIZE];
d722 4
a725 8
			for (cp = line; *cp != '\0'; cp++) {
				if (*cp == ':') {
					done = 1;
					cp++;
					break;
				}
				if (*cp == '\\')
					break;
a727 1
			len = cp - line;
@


1.24
log
@Don't dereference NULL pointer if file is truncated.
Sync with cap_mkdb(1).

ok otto and millert
@
text
@d1 1
a1 1
/*	$OpenBSD: getcap.c,v 1.23 2005/08/08 08:05:34 espie Exp $ */
d672 1
a672 1
	for(;;) {
d678 1
a678 1
			if (line == NULL && pfp) {
d745 1
a745 1
				if (line == NULL && pfp) {
@


1.23
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d750 1
d753 4
@


1.22
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d1 1
a32 4

#if defined(LIBC_SCCS) && !defined(lint)
static const char rcsid[] = "$OpenBSD: getcap.c,v 1.21 2003/06/02 20:18:34 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d34 1
a34 1
static const char rcsid[] = "$OpenBSD: getcap.c,v 1.20 2002/02/16 21:27:22 millert Exp $";
d75 1
a75 2
cgetusedb(new_usedb)
	int new_usedb;
d89 1
a89 2
cgetset(ent)
	const char *ent;
d119 1
a119 4
cgetcap(buf, cap, type)
	char *buf;
	const char *cap;
	int type;
d170 1
a170 3
cgetent(buf, db_array, name)
	char **buf, **db_array;
	const char *name;
d196 2
a197 5
getent(cap, len, db_array, fd, name, depth, nfield)
	char **cap, **db_array, *nfield;
	const char *name;
	u_int *len;
	int fd, depth;
d559 1
a559 4
cdbget(capdbp, bp, name)
	DB *capdbp;
	char **bp;
	const char *name;
d592 1
a592 3
cgetmatch(buf, name)
	char *buf;
	const char *name;
d630 1
a630 2
cgetfirst(buf, db_array)
	char **buf, **db_array;
d642 1
a642 1
cgetclose()
d661 1
a661 3
cgetnext(bp, db_array)
	char **bp;
	char **db_array;
d790 1
a790 4
cgetstr(buf, cap, str)
	char *buf;
	const char *cap;
	char **str;
d923 1
a923 3
cgetustr(buf, cap, str)
	char *buf, **str;
	const char *cap;
d1001 1
a1001 4
cgetnum(buf, cap, num)
	char *buf;
	const char *cap;
	long *num;
d1062 1
a1062 3
nfcmp(nf, rec)
	const char *nf;
	char *rec;
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static const char rcsid[] = "$OpenBSD: getcap.c,v 1.19 2001/09/22 18:36:40 millert Exp $";
@


1.19
log
@o kill some extra whitespace
o remove remaining strcpy()s to avoid false positives when auditing
o fix by one in a malloc() size param
o fix buffer overflow in cgetnext() reported by Jouko Pynnonen
o avoid needlessly setting errno to ENOMEM and when we *do* set it
  be sure to do so right before the return()
o check snprintf() return value when building up a .db pathname and
  fall back to the text version if it the .db path is too long.
o add a missing check for malloc() return value
o kill register
o memmove(), not bcopy()
@
text
@d38 1
a38 1
static const char rcsid[] = "$OpenBSD: getcap.c,v 1.18 2001/06/18 18:11:14 millert Exp $";
d67 3
a69 3
static int	cdbget __P((DB *, char **, const char *));
static int 	getent __P((char **, u_int *, char **, int, const char *, int, char *));
static int	nfcmp __P((const char *, char *));
@


1.18
log
@Add new cgetusedb() function to toggle reading of .db files in getcap(3).
Needed for cap_mkdb to really DRT when given several input files or
an output file with a different name from the input file.
cvs: ----------------------------------------------------------------------
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.17 2000/11/22 19:12:57 deraadt Exp $";
d45 1
a45 1
#include <errno.h>	
d105 1
a105 2
	if ((toprec = malloc (topreclen + 1)) == NULL) {
		errno = ENOMEM;
a106 1
	}
d108 1
a108 1
	(void)strcpy(toprec, ent);
d130 2
a131 2
	register char *bp;
	register const char *cp;
d214 1
a214 1
	register char *r_end, *rp, **db_p;
d218 2
a219 2
	char pbuf[_POSIX_PATH_MAX];
	
d234 1
a234 2
		if ((record = malloc (topreclen + BFRAG)) == NULL) {
			errno = ENOMEM;
d236 1
a236 2
		}
		(void)strcpy(record, toprec);
d246 1
a246 2
	if ((record = malloc(BFRAG)) == NULL) {
		errno = ENOMEM;
a247 1
	}
a259 1

d267 2
a268 2
			(void)snprintf(pbuf, sizeof(pbuf), "%s.db", *db_p);
			if (usedb &&
d280 2
a281 1
				cbuf = malloc(clen + 1);
d306 2
a307 2
		    register char *b_end, *bp;
		    register int c;
d329 1
a329 1
		
d346 1
a346 1
	
a372 1
						errno = ENOMEM;
d375 1
d383 1
a383 1
				/* loop invariant let's us do this */
d387 1
a387 1
			 * If encountered eof check next file.
d391 1
a391 1
				
d397 1
a397 1
	
d423 1
a423 2
		register char *newicap, *s;
		register int newilen;
d426 1
a426 1
		char *icap, *scan, *tc, *tcstart, *tcend;
d447 1
a447 1
			for (;;)
d455 1
a461 2
			newicap = icap;		/* Put into a register. */
			newilen = ilen;
d474 1
a474 1
					*(s - 1) = ':';			
d478 1
a478 1
					
d482 1
a482 1
			s = newicap;
d489 2
a490 2
			newilen -= s - newicap;
			newicap = s;
d493 1
a493 1
			s += newilen;
d496 1
a496 1
				newilen++;
d503 1
a503 1
			diff = newilen - tclen;
a516 1
					errno = ENOMEM;
d519 2
a520 1
					free(icap);
d533 3
a535 3
			s = tcstart + newilen;
			bcopy(tcend, s, rp - tcend);
			bcopy(newicap, tcstart, newilen);
d537 1
a537 1
			free(icap);
d545 1
a545 1
	
d570 1
a570 1
}	
d599 1
a599 1
	
d613 2
a614 2
	register char *bp;
	register const char *np;
a647 4




d652 1
d664 1
d682 1
a682 1
	register char **bp;
d687 1
a687 1
	char *cp, *line, *rp, *np, buf[BSIZE], nbuf[BSIZE];
d721 1
a721 1
				line[len - 1] = '\0';
d738 1
a738 1
		}			
a748 1
					*np++ = ':';
d750 1
a754 1
				*np++ = *cp;
d756 9
d778 1
d782 3
a784 8
		rp = buf;
		for(cp = nbuf; *cp != '\0'; cp++)
			if (*cp == '|' || *cp == ':')
				break;
			else
				*rp++ = *cp;

		*rp = '\0';
d817 2
a818 2
	register u_int m_room;
	register char *bp, *mp;
d833 1
a833 2
	if ((mem = malloc(SFRAG)) == NULL) {
		errno = ENOMEM;
a834 1
	}
d855 1
a855 1
				register int n, i;
d952 2
a953 2
	register u_int m_room;
	register char *bp, *mp;
d967 1
a967 2
	if ((mem = malloc(SFRAG)) == NULL) {
		errno = ENOMEM;
a968 1
	}
d1010 1
a1010 1
		if ((nmem = realloc(mem, (size_t)(mp - mem))) == NULL) {
d1033 3
a1035 3
	register long n;
	register int base, digit;
	register char *bp;
a1087 1

d1098 1
a1098 1
	
d1101 1
a1101 1
	
@


1.17
log
@avoid double fclose()
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.16 1999/02/25 21:40:17 millert Exp $";
d71 17
d273 1
d275 2
a276 2
			if ((capdbp = dbopen(pbuf, O_RDONLY, 0, DB_HASH, 0))
			     != NULL) {
@


1.16
log
@constify getcap(3).  This fixes a warning in libcurses and doesn't
really change the API since those parameters that was been constified
really are not modified by getcap(3) routines.
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.15 1998/08/14 21:39:25 deraadt Exp $";
a696 1
					(void)fclose(pfp);
d701 1
a755 1
						(void)fclose(pfp);
@


1.15
log
@realloc repair
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.14 1998/03/19 01:00:55 deraadt Exp $";
d67 3
a69 3
static int	cdbget __P((DB *, char **, char *));
static int 	getent __P((char **, u_int *, char **, int, char *, int, char *));
static int	nfcmp __P((char *, char *));
d78 1
a78 1
	char *ent;
d111 2
a112 1
	char *buf, *cap;
d115 2
a116 1
	register char *bp, *cp;
d165 2
a166 1
	char **buf, **db_array, *name;
d193 2
a194 1
	char **cap, **db_array, *name, *nfield;
d565 2
a566 1
	char **bp, *name;
d570 1
a570 1
	key.data = name;
d600 2
a601 1
	char *buf, *name;
d603 2
a604 1
	register char *np, *bp;
d802 2
a803 1
	char *buf, *cap;
d940 2
a941 1
	char *buf, *cap, **str;
d1022 2
a1023 1
	char *buf, *cap;
d1087 2
a1088 1
	char *nf, *rec;
@


1.14
log
@zap FILE * after closing it
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.13 1998/03/19 00:30:02 millert Exp $";
d349 1
d353 4
a356 2
					record = realloc(record, newsize);
					if (record == NULL) {
d362 1
d493 1
d499 4
a502 2
				record = realloc(record, newsize);
				if (record == NULL) {
d509 1
d540 4
a543 2
	if (r_end > rp)
		if ((record =
d545 2
d550 2
a551 1
		
d887 1
d889 3
a891 1
			if ((mem = realloc(mem, size + SFRAG)) == NULL)
d893 2
d906 6
a911 2
	if (m_room != 0)
		if ((mem = realloc(mem, (size_t)(mp - mem))) == NULL)
d913 3
d972 1
d974 3
a976 1
			if ((mem = realloc(mem, size + SFRAG)) == NULL)
d978 2
d991 6
a996 2
	if (m_room != 0)
		if ((mem = realloc(mem, (size_t)(mp - mem))) == NULL)
d998 3
@


1.13
log
@some -Wall
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.12 1998/03/17 23:28:58 deraadt Exp $";
d741 1
@


1.12
log
@do not ferror() after fclose(); dholland@@eecs.harvard.edu
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.11 1997/09/12 08:53:08 deraadt Exp $";
d596 1
a596 1
			if (*np == '\0')
d601 1
a601 1
			else
@


1.11
log
@wrong NULL
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.10 1997/07/28 11:19:59 deraadt Exp $";
a675 1
				(void)fclose(pfp);
d677 1
d681 1
a734 1
					(void)fclose(pfp);
d736 1
d740 1
@


1.10
log
@merge in getcap change by grr, in rev 1.8
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.8 1997/07/27 08:29:09 grr Exp $";
d744 1
a744 1
		for(cp = nbuf; *cp != NULL; cp++)
@


1.9
log
@revert until the change gets evaluated by more people
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.7 1997/07/23 21:09:06 kstailey Exp $";
d196 1
a196 1
	int myfd, eof, foundit, retval, clen;
d208 2
d214 1
d249 1
d251 1
d255 2
a256 2
				free(record);
				retval = cdbget(capdbp, &record, name);
d260 1
a260 1
					return (retval);
d262 1
d264 1
a264 1
				clen = strlen(record);
d266 1
a266 1
				memcpy(cbuf, record, clen + 1);
d271 1
d282 1
d289 15
a303 15
		char buf[BUFSIZ];
		register char *b_end, *bp;
		register int c;

		/*
		 * Loop invariants:
		 *	There is always room for one more character in record.
		 *	R_end always points just past end of record.
		 *	Rp always points just past last character in record.
		 *	B_end always points just past last character in buf.
		 *	Bp always points at next character in buf.
		 */
		b_end = buf;
		bp = buf;
		for (;;) {
d387 1
a388 1
	}
d395 1
a395 1
		return (-1 - (fd < 0));
@


1.8
log
@Make correct distinction between "entry not found" and "no capability files",
and allow looking through multiple databases, even if one is the *.db case.
@
text
@d196 1
a196 1
	int myfd, eof, foundit, opened, retval, clen;
a207 2
	opened = 0;

a211 1
		opened++;
a245 1
			opened++;
a246 1
			char *dbrecord;
d250 2
a251 2
				opened++;
				retval = cdbget(capdbp, &dbrecord, name);
d255 1
a255 1
					continue;
a256 1
				free(record);
d258 1
a258 1
				clen = strlen(dbrecord);
d260 1
a260 1
				memcpy(cbuf, dbrecord, clen + 1);
a264 1
				/* assume tc='s have been expanded??? */
a274 1
				opened++;
d281 15
a295 15
		    char buf[BUFSIZ];
		    register char *b_end, *bp;
		    register int c;

		    /*
		     * Loop invariants:
		     *	There is always room for one more character in record.
		     *	R_end always points just past end of record.
		     *	Rp always points just past last character in record.
		     *	B_end always points just past last character in buf.
		     *	Bp always points at next character in buf.
		     */
		    b_end = buf;
		    bp = buf;
		    for (;;) {
a378 1
		    }
d380 1
d387 1
a387 1
		return (opened ? -1 : -2);
@


1.7
log
@trailing blanks
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.6 1997/07/23 21:04:04 kstailey Exp $";
d196 1
a196 1
	int myfd, eof, foundit, retval, clen;
d208 2
d214 1
d249 1
d251 1
d255 2
a256 2
				free(record);
				retval = cdbget(capdbp, &record, name);
d260 1
a260 1
					return (retval);
d262 1
d264 1
a264 1
				clen = strlen(record);
d266 1
a266 1
				memcpy(cbuf, record, clen + 1);
d271 1
d282 1
d289 15
a303 15
		char buf[BUFSIZ];
		register char *b_end, *bp;
		register int c;

		/*
		 * Loop invariants:
		 *	There is always room for one more character in record.
		 *	R_end always points just past end of record.
		 *	Rp always points just past last character in record.
		 *	B_end always points just past last character in buf.
		 *	Bp always points at next character in buf.
		 */
		b_end = buf;
		bp = buf;
		for (;;) {
d387 1
a388 1
	}
d395 1
a395 1
		return (-1 - (fd < 0));
@


1.6
log
@tabify
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.5 1997/06/10 21:44:15 millert Exp $";
d334 1
a334 1
				 * Enforce loop invariant: if no room 
d432 1
a432 1
			iret = getent(&icap, &ilen, db_p, fd, tc, depth+1, 
d525 1
a525 1
		if ((record = 
d640 1
a640 1
 * Cgetnext() gets either the first or next entry in the logical database 
d704 1
a704 1
		/* 
d743 2
a744 2
		/* 
		 * XXX 
d746 1
a746 1
		 * sequential access in the case of duplicates.  
d748 1
a748 1
		 * rather than the duplicate entry record.  This is a 
d888 2
a889 2
 * all characters literally.  A pointer to a  NUL terminated malloc'd 
 * copy of the string is returned in the char pointed to by str.  The 
d891 1
a891 1
 * -1 if the requested string capability couldn't be found, -2 if a system 
@


1.5
log
@return -2 if can't open database like man page says.
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.4 1997/02/01 04:35:33 deraadt Exp $";
d83 6
a88 6
                toprec = NULL;
                topreclen = 0;
                return (0);
        }
        topreclen = strlen(ent);
        if ((toprec = malloc (topreclen + 1)) == NULL) {
d90 1
a90 1
                return (-1);
d93 2
a94 2
        (void)strcpy(toprec, ent);
        return (0);
d210 1
a210 1
         */
d646 1
a646 1
        register char **bp;
@


1.4
log
@mem leak, from lidl@@va.pubnix.com
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.3 1996/09/15 09:31:00 tholo Exp $";
d387 1
a387 1
		return (-1);
@


1.3
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.2 1996/08/19 08:23:10 tholo Exp $";
d244 1
a244 1
			(void)lseek(fd, (off_t)0, L_SET);
d385 2
a386 1
	if (!foundit)
d388 1
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: getcap.c,v 1.10 1995/08/24 05:26:35 mycroft Exp $";
a194 1
	DBT key, data;
a540 2
	char *buf;
	int st;
d648 1
a648 1
	int status, i, done;
a704 1
		i = 0;
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: getcap.c,v 1.10 1995/08/24 05:26:35 mycroft Exp $	*/

d38 1
a38 5
#if 0
static char sccsid[] = "@@(#)getcap.c	8.3 (Berkeley) 3/25/94";
#else
static char rcsid[] = "$NetBSD: getcap.c,v 1.10 1995/08/24 05:26:35 mycroft Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

