head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.6
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.16
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.14
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.10
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.8
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.19.0.22
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.18
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.20
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.16
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.14
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.12
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.10
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.8
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2015.09.13.11.32.51;	author guenther;	state Exp;
branches;
next	1.24;
commitid	iyy5LbsofWKe89dA;

1.24
date	2015.07.20.01.52.28;	author millert;	state Exp;
branches;
next	1.23;
commitid	1K7DsYjDc1gtQpBp;

1.23
date	2014.11.17.19.48.27;	author millert;	state Exp;
branches;
next	1.22;
commitid	zVcFLo6dtf42lfn1;

1.22
date	2011.03.13.22.21.32;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.24.23.49.06;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.21.18.59.15;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.01.17.15.49;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.29.18.38.41;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.28.23.05.13;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.09.19.38.31;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.25.15.38.47;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.18.35;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.14.05.16.43;	author pjanzen;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.01.11.28.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.01.07.48.50;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.13.15.30.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.21.00.47.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.19.15.25.13;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.20.30.05;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.07.09.00.28.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.27.36;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Wrap <vis.h> so that calls go direct and the symbols are all weak
@
text
@/*	$OpenBSD: vis.c,v 1.24 2015/07/20 01:52:28 millert Exp $ */
/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <errno.h>
#include <ctype.h>
#include <limits.h>
#include <string.h>
#include <stdlib.h>
#include <vis.h>

#define	isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
#define	isvisible(c,flag)						\
	(((c) == '\\' || (flag & VIS_ALL) == 0) &&			\
	(((u_int)(c) <= UCHAR_MAX && isascii((u_char)(c)) &&		\
	(((c) != '*' && (c) != '?' && (c) != '[' && (c) != '#') ||	\
		(flag & VIS_GLOB) == 0) && isgraph((u_char)(c))) ||	\
	((flag & VIS_SP) == 0 && (c) == ' ') ||				\
	((flag & VIS_TAB) == 0 && (c) == '\t') ||			\
	((flag & VIS_NL) == 0 && (c) == '\n') ||			\
	((flag & VIS_SAFE) && ((c) == '\b' ||				\
		(c) == '\007' || (c) == '\r' ||				\
		isgraph((u_char)(c))))))

/*
 * vis - visually encode characters
 */
char *
vis(char *dst, int c, int flag, int nextc)
{
	if (isvisible(c, flag)) {
		if ((c == '"' && (flag & VIS_DQ) != 0) ||
		    (c == '\\' && (flag & VIS_NOSLASH) == 0))
			*dst++ = '\\';
		*dst++ = c;
		*dst = '\0';
		return (dst);
	}

	if (flag & VIS_CSTYLE) {
		switch(c) {
		case '\n':
			*dst++ = '\\';
			*dst++ = 'n';
			goto done;
		case '\r':
			*dst++ = '\\';
			*dst++ = 'r';
			goto done;
		case '\b':
			*dst++ = '\\';
			*dst++ = 'b';
			goto done;
		case '\a':
			*dst++ = '\\';
			*dst++ = 'a';
			goto done;
		case '\v':
			*dst++ = '\\';
			*dst++ = 'v';
			goto done;
		case '\t':
			*dst++ = '\\';
			*dst++ = 't';
			goto done;
		case '\f':
			*dst++ = '\\';
			*dst++ = 'f';
			goto done;
		case ' ':
			*dst++ = '\\';
			*dst++ = 's';
			goto done;
		case '\0':
			*dst++ = '\\';
			*dst++ = '0';
			if (isoctal(nextc)) {
				*dst++ = '0';
				*dst++ = '0';
			}
			goto done;
		}
	}
	if (((c & 0177) == ' ') || (flag & VIS_OCTAL) ||
	    ((flag & VIS_GLOB) && (c == '*' || c == '?' || c == '[' || c == '#'))) {
		*dst++ = '\\';
		*dst++ = ((u_char)c >> 6 & 07) + '0';
		*dst++ = ((u_char)c >> 3 & 07) + '0';
		*dst++ = ((u_char)c & 07) + '0';
		goto done;
	}
	if ((flag & VIS_NOSLASH) == 0)
		*dst++ = '\\';
	if (c & 0200) {
		c &= 0177;
		*dst++ = 'M';
	}
	if (iscntrl((u_char)c)) {
		*dst++ = '^';
		if (c == 0177)
			*dst++ = '?';
		else
			*dst++ = c + '@@';
	} else {
		*dst++ = '-';
		*dst++ = c;
	}
done:
	*dst = '\0';
	return (dst);
}
DEF_WEAK(vis);

/*
 * strvis, strnvis, strvisx - visually encode characters from src into dst
 *	
 *	Dst must be 4 times the size of src to account for possible
 *	expansion.  The length of dst, not including the trailing NULL,
 *	is returned. 
 *
 *	Strnvis will write no more than siz-1 bytes (and will NULL terminate).
 *	The number of bytes needed to fully encode the string is returned.
 *
 *	Strvisx encodes exactly len bytes from src into dst.
 *	This is useful for encoding a block of data.
 */
int
strvis(char *dst, const char *src, int flag)
{
	char c;
	char *start;

	for (start = dst; (c = *src);)
		dst = vis(dst, c, flag, *++src);
	*dst = '\0';
	return (dst - start);
}
DEF_WEAK(strvis);

int
strnvis(char *dst, const char *src, size_t siz, int flag)
{
	char *start, *end;
	char tbuf[5];
	int c, i;

	i = 0;
	for (start = dst, end = start + siz - 1; (c = *src) && dst < end; ) {
		if (isvisible(c, flag)) {
			if ((c == '"' && (flag & VIS_DQ) != 0) ||
			    (c == '\\' && (flag & VIS_NOSLASH) == 0)) {
				/* need space for the extra '\\' */
				if (dst + 1 >= end) {
					i = 2;
					break;
				}
				*dst++ = '\\';
			}
			i = 1;
			*dst++ = c;
			src++;
		} else {
			i = vis(tbuf, c, flag, *++src) - tbuf;
			if (dst + i <= end) {
				memcpy(dst, tbuf, i);
				dst += i;
			} else {
				src--;
				break;
			}
		}
	}
	if (siz > 0)
		*dst = '\0';
	if (dst + i > end) {
		/* adjust return value for truncation */
		while ((c = *src))
			dst += vis(tbuf, c, flag, *++src) - tbuf;
	}
	return (dst - start);
}

int
stravis(char **outp, const char *src, int flag)
{
	char *buf;
	int len, serrno;

	buf = reallocarray(NULL, 4, strlen(src) + 1);
	if (buf == NULL)
		return -1;
	len = strvis(buf, src, flag);
	serrno = errno;
	*outp = realloc(buf, len + 1);
	if (*outp == NULL) {
		*outp = buf;
		errno = serrno;
	}
	return (len);
}

int
strvisx(char *dst, const char *src, size_t len, int flag)
{
	char c;
	char *start;

	for (start = dst; len > 1; len--) {
		c = *src;
		dst = vis(dst, c, flag, *++src);
	}
	if (len)
		dst = vis(dst, *src, flag, '\0');
	*dst = '\0';
	return (dst - start);
}
@


1.24
log
@Add VIS_DQ to escape double quotes.  OK deraadt@@ semarie@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vis.c,v 1.23 2014/11/17 19:48:27 millert Exp $ */
d139 1
d165 1
@


1.23
log
@Add stravis(), an allocating version of strvis().  OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vis.c,v 1.22 2011/03/13 22:21:32 guenther Exp $ */
d59 3
a62 2
		if (c == '\\' && (flag & VIS_NOSLASH) == 0)
			*dst++ = '\\';
d175 2
a176 3
			i = 1;
			*dst++ = c;
			if (c == '\\' && (flag & VIS_NOSLASH) == 0) {
d178 1
a178 4
				if (dst < end)
					*dst++ = '\\';
				else {
					dst--;
d182 1
d184 2
@


1.22
log
@Fix handling of VIS_ALL: in vis(), actually encode all characters
as requested and give a correct estimate when they don't all fit,
and in unvis() decode them instead of erroring

ok nicm@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vis.c,v 1.21 2010/08/24 23:49:06 djm Exp $ */
d32 2
a34 1
#include <ctype.h>
d36 1
d206 19
@


1.21
log
@backout VIS_HEX. guenther@@ points out that the C89 \xff encoding
idiotically accepts more then two hex digits following the \x, even
on platforms where a char has 8 bits. It is therefore dangerous to have
an almost-bit-not-quite compatible format in vis(3).

The VIS_ALL (encode all characters) option introduced in the same commit
remains.
@
text
@d1 1
a1 1
/*	$OpenBSD: vis.c,v 1.20 2010/08/21 18:59:15 djm Exp $ */
d38 2
a39 1
#define	isvisible(c)							\
d48 1
a48 1
		isgraph((u_char)(c)))))
d56 1
a56 1
	if (isvisible(c) && (flag & VIS_ALL) == 0) {
d171 1
a171 1
		if (isvisible(c)) {
@


1.20
log
@Two new flags: VIS_ALL - encode all characters, not just invisible ones
and VIS_HEX - use C89 \xff style hexadecimal encoding.

Teach unvis(3) how to deal with the hex encoding.

feedback and ok millert@@ chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vis.c,v 1.19 2005/09/01 17:15:49 millert Exp $ */
a48 2
static const char hexdigits[] = "0123456789abcdef";

d107 1
a107 1
	if (((c & 0177) == ' ') || (flag & (VIS_OCTAL|VIS_HEX)) ||
d109 4
a112 11
		if ((flag & VIS_HEX) != 0) {
			*dst++ = '\\';
			*dst++ = 'x';
			*dst++ = hexdigits[((u_char)c >> 4 & 0xf)];
			*dst++ = hexdigits[((u_char)c & 0xf)];
		} else {
			*dst++ = '\\';
			*dst++ = ((u_char)c >> 6 & 07) + '0';
			*dst++ = ((u_char)c >> 3 & 07) + '0';
			*dst++ = ((u_char)c & 07) + '0';
		}
@


1.19
log
@repair VIS_GLOB; deraadt@@ otto@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: vis.c,v 1.18 2005/08/29 18:38:41 otto Exp $ */
d49 2
d57 1
a57 1
	if (isvisible(c)) {
d109 1
a109 1
	if (((c & 0177) == ' ') || (flag & VIS_OCTAL) ||
d111 11
a121 4
		*dst++ = '\\';
		*dst++ = ((u_char)c >> 6 & 07) + '0';
		*dst++ = ((u_char)c >> 3 & 07) + '0';
		*dst++ = ((u_char)c & 07) + '0';
@


1.18
log
@Remove spurious call to isgraph() that sneaked in in rev 1.16.
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vis.c,v 1.17 2005/08/28 23:05:13 millert Exp $ */
d107 2
a108 1
	if (((c & 0177) == ' ') || (flag & VIS_OCTAL)) {	
@


1.17
log
@Fix the VIS_GLOB checks added in rev 1.16
Add missing casts to u_char so 0xff is treated the same on machines
with signed and unsigned chars.
OK deraadt@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vis.c,v 1.16 2005/08/09 19:38:31 millert Exp $ */
d107 1
a107 1
	if (((c & 0177) == ' ') || isgraph((u_char)c) || (flag & VIS_OCTAL)) {	
@


1.16
log
@Add VIS_GLOB to escape special characters used by shell-style globbing.
From Solar Designer based on changes in FreeBSD.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vis.c,v 1.15 2005/08/08 08:05:34 espie Exp $ */
d39 3
a41 4
	(((u_int)(c) <= UCHAR_MAX && isascii((u_char)(c))) &&   	\
	(((((c) != '*' && (c) != '?' && (c) != '[' && (c) != '#') ||	\
		(flag & VIS_GLOB) == 0) &&				\
		isgraph((u_char)(c))) ||				\
d47 1
a47 1
		isgraph((u_char)(c))))))
d107 1
a107 1
	if (((c & 0177) == ' ') || isgraph(c) || (flag & VIS_OCTAL)) {	
d120 1
a120 1
	if (iscntrl(c)) {
a162 1
	char c;
d165 1
a165 1
	int  i;
@


1.15
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d38 11
a48 8
#define isvisible(c)	(((u_int)(c) <= UCHAR_MAX && isascii((u_char)(c)) && \
				isgraph((u_char)(c))) ||		     \
				((flag & VIS_SP) == 0 && (c) == ' ') ||	     \
				((flag & VIS_TAB) == 0 && (c) == '\t') ||    \
				((flag & VIS_NL) == 0 && (c) == '\n') ||     \
				((flag & VIS_SAFE) && ((c) == '\b' ||	     \
				(c) == '\007' || (c) == '\r' ||		     \
				isgraph((u_char)(c)))))
d108 1
a108 1
	if (((c & 0177) == ' ') || (flag & VIS_OCTAL)) {	
@


1.14
log
@deregister (and deauto!). ok millert@@ marco@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: vis.c,v 1.13 2004/05/18 02:05:52 jfb Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.13
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.12 2003/06/02 20:18:35 millert Exp $";
d152 1
a152 1
	register char c;
d209 1
a209 1
	register char c;
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.11 2003/05/14 05:16:43 pjanzen Exp $";
d54 1
a54 4
vis(dst, c, flag, nextc)
	register char *dst;
	int c, nextc;
	register int flag;
d150 1
a150 4
strvis(dst, src, flag)
	register char *dst;
	register const char *src;
	int flag;
d162 1
a162 5
strnvis(dst, src, siz, flag)
	char *dst;
	const char *src;
	size_t siz;
	int flag;
d207 1
a207 5
strvisx(dst, src, len, flag)
	register char *dst;
	register const char *src;
	register size_t len;
	int flag;
@


1.11
log
@sync vis() behaviour when VIS_SAFE to man page:  don't do anything if isgraph()
is true, even if the character isn't 7-bit.
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.10 2002/07/01 11:28:06 deraadt Exp $";
@


1.10
log
@need string.h
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.9 2002/07/01 07:48:50 pjanzen Exp $";
d50 3
a52 2
				((flag & VIS_SAFE) &&			     \
				((c) == '\b' || (c) == '\007' || (c) == '\r')))
@


1.9
log
@Fix strnvis():  don't truncate unnecessarily, set the return value correctly
if we had to truncate, and don't NUL-terminate if size == 0.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.8 2002/02/19 19:39:36 millert Exp $";
d41 1
@


1.8
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.7 2001/08/13 15:30:23 millert Exp $";
d171 2
a172 2
	register char *dst;
	register const char *src;
d176 1
a176 1
	register char c;
d178 2
d181 1
d184 1
d192 1
d198 6
a203 4
			/* vis(3) requires up to 4 chars */
			if (dst + 3 < end)
				dst = vis(dst, c, flag, *++src);
			else
d205 1
d208 3
a210 4
	*dst = '\0';
	if (dst >= end) {
		char tbuf[5];

@


1.7
log
@Explicitly NUL terminate dst in strvis() and strvisx() in case
we are passes an empty string.  vis() and strnvis() were already OK.
Based on patch by wilfried@@openbsd.org
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.6 2000/11/21 00:47:28 millert Exp $";
a82 1
#ifdef __STDC__
a83 3
#else
		case '\007':
#endif
@


1.6
log
@Add strnvis(3) -- a length-bounded version of strvis(3) with a return
value similar to snprintf(3) and strlcpy(3).
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.5 2000/07/19 15:25:13 deraadt Exp $";
d169 1
d231 1
@


1.5
log
@off-by-one calculation error; getcwd() would return NULL if the buffer was
the needed length + terminating byte + 1; that 1 is not needed; assar
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.4 1997/07/25 20:30:05 mickey Exp $";
d44 7
d61 1
a61 6
	if (((u_int)c <= UCHAR_MAX && isascii((u_char)c) &&
	    isgraph((u_char)c)) ||
	   ((flag & VIS_SP) == 0 && c == ' ') ||
	   ((flag & VIS_TAB) == 0 && c == '\t') ||
	   ((flag & VIS_NL) == 0 && c == '\n') ||
	   ((flag & VIS_SAFE) && (c == '\b' || c == '\007' || c == '\r'))) {
d146 1
a146 1
 * strvis, strvisx - visually encode characters from src into dst
d152 3
d169 34
d204 7
a229 2
	*dst = '\0';

@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.3 1997/07/09 00:28:26 millert Exp $";
d54 2
a55 1
	if (((u_int)c <= UCHAR_MAX && isascii(c) && isgraph(c)) ||
@


1.3
log
@Clean up some -Wall complaints.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.2 1996/08/19 08:27:36 tholo Exp $";
d80 1
a80 1
#if __STDC__
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: vis.c,v 1.6 1995/02/25 15:40:09 cgd Exp $";
d54 1
a54 1
	if ((u_int)c <= UCHAR_MAX && isascii(c) && isgraph(c) ||
d161 1
a161 1
	for (start = dst; c = *src;)
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: vis.c,v 1.6 1995/02/25 15:40:09 cgd Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)vis.c	8.1 (Berkeley) 7/19/93";
#else
static char rcsid[] = "$NetBSD: vis.c,v 1.6 1995/02/25 15:40:09 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
