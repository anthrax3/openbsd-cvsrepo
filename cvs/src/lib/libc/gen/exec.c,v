head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.8
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.10
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.4
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.2
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.19.0.2
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.28
	OPENBSD_5_0:1.18.0.26
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.24
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.22
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.18
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.20
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.16
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.14
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.12
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.10
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.8
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.11.0.6
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.03.13.18.34.20;	author guenther;	state Exp;
branches;
next	1.22;
commitid	AStIlKdF20sYXV6x;

1.22
date	2015.09.12.14.56.50;	author guenther;	state Exp;
branches;
next	1.21;
commitid	BXATo6E2rFBuIXKr;

1.21
date	2013.09.30.12.02.33;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2013.01.08.02.26.09;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2012.03.21.23.20.35;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.25.15.38.47;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.11.21.03.10;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.31.01.06.15;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.30.00.15.13;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.22.18.46.04;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.29.19.52.26;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.09.16.19.05.58;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.08.14.21.39.23;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.09.20.09.46.10;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.25.20.30.01;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.05.05.37.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.10.27.23.02.23;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.22.40;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.15.43.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.53;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.53;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@environ and __progname are not declared in a public header; declare them
in libc's hidden/stdlib.h instead of in each .c file that needs one

ok deraadt@@ gsoares@@ mpi@@
@
text
@/*	$OpenBSD: exec.c,v 1.22 2015/09/12 14:56:50 guenther Exp $ */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/uio.h>

#include <errno.h>
#include <limits.h>
#include <paths.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int
execl(const char *name, const char *arg, ...)
{
	va_list ap;
	char **argv;
	int n;

	va_start(ap, arg);
	n = 1;
	while (va_arg(ap, char *) != NULL)
		n++;
	va_end(ap);
	argv = alloca((n + 1) * sizeof(*argv));
	if (argv == NULL) {
		errno = ENOMEM;
		return (-1);
	}
	va_start(ap, arg);
	n = 1;
	argv[0] = (char *)arg;
	while ((argv[n] = va_arg(ap, char *)) != NULL)
		n++;
	va_end(ap);
	return (execve(name, argv, environ));
}
DEF_WEAK(execl);

int
execle(const char *name, const char *arg, ...)
{
	va_list ap;
	char **argv, **envp;
	int n;

	va_start(ap, arg);
	n = 1;
	while (va_arg(ap, char *) != NULL)
		n++;
	va_end(ap);
	argv = alloca((n + 1) * sizeof(*argv));
	if (argv == NULL) {
		errno = ENOMEM;
		return (-1);
	}
	va_start(ap, arg);
	n = 1;
	argv[0] = (char *)arg;
	while ((argv[n] = va_arg(ap, char *)) != NULL)
		n++;
	envp = va_arg(ap, char **);
	va_end(ap);
	return (execve(name, argv, envp));
}

int
execlp(const char *name, const char *arg, ...)
{
	va_list ap;
	char **argv;
	int n;

	va_start(ap, arg);
	n = 1;
	while (va_arg(ap, char *) != NULL)
		n++;
	va_end(ap);
	argv = alloca((n + 1) * sizeof(*argv));
	if (argv == NULL) {
		errno = ENOMEM;
		return (-1);
	}
	va_start(ap, arg);
	n = 1;
	argv[0] = (char *)arg;
	while ((argv[n] = va_arg(ap, char *)) != NULL)
		n++;
	va_end(ap);
	return (execvp(name, argv));
}

int
execv(const char *name, char *const *argv)
{
	(void)execve(name, argv, environ);
	return (-1);
}

int
execvpe(const char *name, char *const *argv, char *const *envp)
{
	char **memp;
	int cnt;
	size_t lp, ln, len;
	char *p;
	int eacces = 0;
	char *bp, *cur, *path, buf[PATH_MAX];

	/*
	 * Do not allow null name
	 */
	if (name == NULL || *name == '\0') {
		errno = ENOENT;
		return (-1);
 	}

	/* If it's an absolute or relative path name, it's easy. */
	if (strchr(name, '/')) {
		bp = (char *)name;
		cur = path = NULL;
		goto retry;
	}
	bp = buf;

	/* Get the path we're searching. */
	if (!(path = getenv("PATH")))
		path = _PATH_DEFPATH;
	len = strlen(path) + 1;
	cur = alloca(len);
	if (cur == NULL) {
		errno = ENOMEM;
		return (-1);
	}
	strlcpy(cur, path, len);
	path = cur;
	while ((p = strsep(&cur, ":"))) {
		/*
		 * It's a SHELL path -- double, leading and trailing colons
		 * mean the current directory.
		 */
		if (!*p) {
			p = ".";
			lp = 1;
		} else
			lp = strlen(p);
		ln = strlen(name);

		/*
		 * If the path is too long complain.  This is a possible
		 * security issue; given a way to make the path too long
		 * the user may execute the wrong program.
		 */
		if (lp + ln + 2 > sizeof(buf)) {
			struct iovec iov[3];

			iov[0].iov_base = "execvp: ";
			iov[0].iov_len = 8;
			iov[1].iov_base = p;
			iov[1].iov_len = lp;
			iov[2].iov_base = ": path too long\n";
			iov[2].iov_len = 16;
			(void)writev(STDERR_FILENO, iov, 3);
			continue;
		}
		bcopy(p, buf, lp);
		buf[lp] = '/';
		bcopy(name, buf + lp + 1, ln);
		buf[lp + ln + 1] = '\0';

retry:		(void)execve(bp, argv, envp);
		switch(errno) {
		case E2BIG:
			goto done;
		case EISDIR:
		case ELOOP:
		case ENAMETOOLONG:
		case ENOENT:
			break;
		case ENOEXEC:
			for (cnt = 0; argv[cnt]; ++cnt)
				;
			memp = alloca((cnt + 2) * sizeof(char *));
			if (memp == NULL)
				goto done;
			memp[0] = "sh";
			memp[1] = bp;
			bcopy(argv + 1, memp + 2, cnt * sizeof(char *));
			(void)execve(_PATH_BSHELL, memp, envp);
			goto done;
		case ENOMEM:
			goto done;
		case ENOTDIR:
			break;
		case ETXTBSY:
			/*
			 * We used to retry here, but sh(1) doesn't.
			 */
			goto done;
		case EACCES:
			eacces = 1;
			break;
		default:
			goto done;
		}
	}
	if (eacces)
		errno = EACCES;
	else if (!errno)
		errno = ENOENT;
done:
	return (-1);
}
DEF_WEAK(execvpe);

int
execvp(const char *name, char *const *argv)
{
    return execvpe(name, argv, environ);
}
DEF_WEAK(execvp);

@


1.22
log
@Wrap <unistd.h> so that internal calls go direct and they're all weak symbols
Delete unused 'fd' argument from internal function oldttyname()
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.21 2013/09/30 12:02:33 millert Exp $ */
a41 2

extern char **environ;
@


1.21
log
@Use PATH_MAX, NAME_MAX and LOGIN_NAME_MAX not MAXPATHNAMELEN,
MAXNAMLEN or MAXLOGNAME where possible.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.20 2013/01/08 02:26:09 deraadt Exp $ */
d70 1
d246 1
d253 1
@


1.20
log
@More int's that should be size_t for strlen() use
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.19 2012/03/21 23:20:35 matthew Exp $ */
a30 1
#include <sys/param.h>
d33 1
d35 4
a38 1
#include <unistd.h>
d41 1
a41 3
#include <stdio.h>
#include <paths.h>
#include <stdarg.h>
d139 1
a139 1
	char *bp, *cur, *path, buf[MAXPATHLEN];
@


1.19
log
@Implement execvpe(3) and posix_spawn(3) and family.  Based on
FreeBSD's implementation via Frank Denis, with various cleanups and
tweaks by me.

ok deraadt@@, guenther@@; discussions and tweaks from many others
jmc@@ promises to help me further with the man pages in tree
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.c,v 1.18 2005/08/08 08:05:34 espie Exp $ */
d134 2
a135 1
	int cnt, lp, ln, len;
@


1.18
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d124 1
a124 1
execv(const char *name, char * const *argv)
d131 1
a131 1
execvp(const char *name, char * const *argv)
d200 1
a200 1
retry:		(void)execve(bp, argv, environ);
d218 1
a218 1
			(void)execve(_PATH_BSHELL, memp, environ);
d243 7
@


1.17
log
@deregister (and deauto!). ok millert@@ marco@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: exec.c,v 1.16 2003/06/11 21:03:10 deraadt Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.16
log
@ansification; checked by pval
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.15 2003/06/02 20:18:34 millert Exp $";
d137 2
a138 2
	register int cnt, lp, ln, len;
	register char *p;
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.14 2002/12/31 01:06:15 millert Exp $";
d127 1
a127 3
execv(name, argv)
	const char *name;
	char * const *argv;
d134 1
a134 3
execvp(name, argv)
	const char *name;
	char * const *argv;
@


1.14
log
@Catch EISDIR in execvp() and friends so that if a directory appears
in PATH that matches the name to be executed we skip it; Andy Isaacson
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.13 2002/07/30 00:15:13 deraadt Exp $";
@


1.13
log
@be even more careful with strlcpy()
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.12 2002/02/19 19:39:36 millert Exp $";
d215 1
@


1.12
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.11 2000/08/22 18:46:04 deraadt Exp $";
d145 1
a145 1
	register int cnt, lp, ln;
d169 2
a170 1
	cur = alloca(strlen(path) + 1);
d175 1
a175 1
	strcpy(cur, path);
@


1.11
log
@unused variable
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.10 2000/01/29 19:52:26 deraadt Exp $";
a46 2

#ifdef __STDC__
a47 3
#else
#include <varargs.h>
#endif
a51 1
#ifdef __STDC__
a52 6
#else
execl(name, arg, va_alist)
	const char *name;
	const char *arg;
	va_dcl
#endif
a57 1
#ifdef __STDC__
a58 3
#else
	va_start(ap);
#endif
a67 1
#ifdef __STDC__
a68 3
#else
	va_start(ap);
#endif
a77 1
#ifdef __STDC__
a78 6
#else
execle(name, arg, va_alist)
	const char *name;
	const char *arg;
	va_dcl
#endif
a83 1
#ifdef __STDC__
a84 3
#else
	va_start(ap);
#endif
a93 1
#ifdef __STDC__
a94 3
#else
	va_start(ap);
#endif
a104 1
#ifdef __STDC__
a105 6
#else
execlp(name, arg, va_alist)
	const char *name;
	const char *arg;
	va_dcl
#endif
a110 1
#ifdef __STDC__
a111 3
#else
	va_start(ap);
#endif
a120 1
#ifdef __STDC__
a121 3
#else
	va_start(ap);
#endif
@


1.10
log
@use alloca() instead of malloc, for vfork safety
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.9 1999/09/16 19:05:58 deraadt Exp $";
d197 1
a197 1
	int eacces = 0, etxtbsy = 0;
@


1.9
log
@use writev() where possible
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.8 1998/08/14 21:39:23 deraadt Exp $";
a55 35
static char **
buildargv(ap, arg, envpp)
	va_list ap;
	const char *arg;
	char ***envpp;
{
	register char **argv, **nargv;
	register int memsize, off;

	argv = NULL;
	for (off = memsize = 0;; ++off) {
		if (off >= memsize) {
			memsize += 50;	/* Starts out at 0. */
			memsize *= 2;	/* Ramp up fast. */
			nargv = realloc(argv, memsize * sizeof(char *));
			if (nargv == NULL) {
				if (argv)
					free(argv);
				return (NULL);
			}
			argv = nargv;
			if (off == 0) {
				argv[0] = (char *)arg;
				off = 1;
			}
		}
		if (!(argv[off] = va_arg(ap, char *)))
			break;
	}
	/* Get environment pointer if user supposed to provide one. */
	if (envpp)
		*envpp = va_arg(ap, char **);
	return (argv);
}

a66 1
	int sverrno;
d68 1
d75 3
a77 2
	if ((argv = buildargv(ap, arg, NULL)))
		(void)execve(name, argv, environ);
d79 16
a94 4
	sverrno = errno;
	free(argv);
	errno = sverrno;
	return (-1);
d109 1
a109 1
	int i;
d116 3
a118 2
	for (i = 1; va_arg(ap, char *) != NULL; i++)
		;
d120 6
a125 4

	argv = alloca (i * sizeof (char *));

#if __STDC__
d130 5
a134 4
	argv[0] = (char *) arg;
	for (i = 1; (argv[i] = (char *) va_arg(ap, char *)) != NULL; i++)
		;
	envp = (char **) va_arg(ap, char **);
d136 1
a136 2

	return execve(name, argv, envp);
a149 1
	int sverrno;
d151 1
d158 18
a175 2
	if ((argv = buildargv(ap, arg, NULL)))
		(void)execvp(name, argv);
d177 1
a177 4
	sverrno = errno;
	free(argv);
	errno = sverrno;
	return (-1);
d219 7
a225 2
	cur = path = strdup(path);

d262 4
a265 3
		case EACCES:
			eacces = 1;
			break;
d271 1
a271 1
			memp = malloc((cnt + 2) * sizeof(char *));
a277 1
			free(memp);
d279 4
d284 7
a290 3
			if (etxtbsy < 3)
				(void)sleep(++etxtbsy);
			goto retry;
d299 1
a299 2
done:	if (path)
		free(path);
@


1.8
log
@realloc repair
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.7 1997/09/20 09:46:10 deraadt Exp $";
d40 1
d245 9
a253 3
			(void)write(STDERR_FILENO, "execvp: ", 8);
			(void)write(STDERR_FILENO, p, lp);
			(void)write(STDERR_FILENO, ": path too long\n", 16);
@


1.7
log
@do execle() using alloca() for use inside signal handlers (malloc is bad)
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.6 1997/07/25 20:30:01 mickey Exp $";
d71 2
a72 1
				free(argv);
@


1.6
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.5 1996/12/05 05:37:10 deraadt Exp $";
a127 1
	int sverrno;
d129 1
d136 2
a137 2
	if ((argv = buildargv(ap, arg, &envp)))
		(void)execve(name, argv, envp);
d139 15
a153 4
	sverrno = errno;
	free(argv);
	errno = sverrno;
	return (-1);
@


1.5
log
@4.4lite2, safely uses malloc, with freebsd fixes too
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.4 1996/10/27 23:02:23 tholo Exp $";
d47 1
a47 1
#if __STDC__
d90 1
a90 1
#if __STDC__
d103 1
a103 1
#if __STDC__
d118 1
a118 1
#if __STDC__
d131 1
a131 1
#if __STDC__
d146 1
a146 1
#if __STDC__
d159 1
a159 1
#if __STDC__
@


1.4
log
@exec[lv]p() shall return ENOENT for empty path names
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.3 1996/08/19 08:22:40 tholo Exp $";
d55 34
d100 1
a101 10
	int i;

#if __STDC__
	va_start(ap, arg);
#else
	va_start(ap);
#endif
	for (i = 1; va_arg(ap, char *) != NULL; i++)
		;
	va_end(ap);
a102 2
	argv = alloca (i * sizeof (char *));
	
d108 2
a109 3
	argv[0] = (char *) arg;
	for (i = 1; (argv[i] = (char *) va_arg(ap, char *)) != NULL; i++) 
		;
d111 4
a114 2
	
	return execve(name, argv, environ);
d128 1
a129 1
	int i;
d136 2
a137 2
	for (i = 1; va_arg(ap, char *) != NULL; i++)
		;
d139 4
a142 15

	argv = alloca (i * sizeof (char *));
	
#if __STDC__
	va_start(ap, arg);
#else
	va_start(ap);
#endif
	argv[0] = (char *) arg;
	for (i = 1; (argv[i] = (char *) va_arg(ap, char *)) != NULL; i++) 
		;
	envp = (char **) va_arg(ap, char **);
	va_end(ap);

	return execve(name, argv, envp);
d156 1
a157 1
	int i;
d164 2
a165 2
	for (i = 1; va_arg(ap, char *) != NULL; i++)
		;
d167 4
a170 14

	argv = alloca (i * sizeof (char *));
	
#if __STDC__
	va_start(ap, arg);
#else
	va_start(ap);
#endif
	argv[0] = (char *) arg;
	for (i = 1; (argv[i] = va_arg(ap, char *)) != NULL; i++) 
		;
	va_end(ap);
	
	return execvp(name, argv);
d178 2
a179 1
	return execve(name, argv, environ);
d187 1
a187 2
	static int memsize;
	static char **memp;
d199 1
a199 1
	}
d214 1
a214 1
	while (p = strsep(&cur, ":")) {
d250 5
a254 8
			for (cnt = 0; argv[cnt]; ++cnt);
			if ((cnt + 2) * sizeof(char *) > memsize) {
				memsize = (cnt + 2) * sizeof(char *);
				if ((memp = realloc(memp, memsize)) == NULL) {
					memsize = 0;
					goto done;
				}
			}
d259 1
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: exec.c,v 1.7 1995/12/14 16:51:27 jtc Exp $";
d189 8
@


1.2
log
@use alloca() instead of malloc()
@
text
@a0 2
/*	$NetBSD: exec.c,v 1.7 1995/12/14 16:51:27 jtc Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)exec.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: exec.c,v 1.7 1995/12/14 16:51:27 jtc Exp $";
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: exec.c,v 1.6 1995/02/27 03:42:57 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: exec.c,v 1.6 1995/02/27 03:42:57 cgd Exp $";
a60 33
static char **
buildargv(ap, arg, envpp)
	va_list ap;
	const char *arg;
	char ***envpp;
{
	static size_t memsize;
	static char **argv;
	register size_t off;

	argv = NULL;
	for (off = 0;; ++off) {
		if (off >= memsize) {
			memsize += 50;	/* Starts out at 0. */
			memsize *= 2;	/* Ramp up fast. */
			if (!(argv = realloc(argv, memsize * sizeof(char *)))) {
				memsize = 0;
				return (NULL);
			}
			if (off == 0) {
				argv[0] = (char *)arg;
				off = 1;
			}
		}
		if (!(argv[off] = va_arg(ap, char *)))
			break;
	}
	/* Get environment pointer if user supposed to provide one. */
	if (envpp)
		*envpp = va_arg(ap, char **);
	return (argv);
}

a71 1
	int sverrno;
d73 10
d84 2
d91 3
a93 2
	if (argv = buildargv(ap, arg, NULL))
		(void)execve(name, argv, environ);
d95 2
a96 4
	sverrno = errno;
	free(argv);
	errno = sverrno;
	return (-1);
a109 1
	int sverrno;
d111 1
d118 2
a119 2
	if (argv = buildargv(ap, arg, &envp))
		(void)execve(name, argv, envp);
d121 15
a135 4
	sverrno = errno;
	free(argv);
	errno = sverrno;
	return (-1);
a148 1
	int sverrno;
d150 10
d161 2
d168 3
a170 2
	if (argv = buildargv(ap, arg, NULL))
		(void)execvp(name, argv);
d172 2
a173 4
	sverrno = errno;
	free(argv);
	errno = sverrno;
	return (-1);
d181 1
a181 2
	(void)execve(name, argv, environ);
	return (-1);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
