head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.19.0.8
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.10
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.28
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.26
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.24
	OPENBSD_5_0:1.17.0.22
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.20
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.18
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.14
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.16
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.10
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.8
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.05.07.19.48.00;	author guenther;	state Exp;
branches;
next	1.20;
commitid	dn5iPBRtfR9S1Pvl;

1.20
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	1.19;
commitid	d9R7VGw9CHTkwXE1;

1.19
date	2013.09.30.12.02.33;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.17.17.40.35;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.27.18.06.29;	author pedro;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.27.18.00.27;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.27.16.14.02;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.01.18.55.59;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.25.15.38.47;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.06.03.26.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.05.19.48.08;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.11.21.03.10;	author deraadt;	state Exp;
branches
	1.9.4.1
	1.9.6.1;
next	1.8;

1.8
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.24.01.52.27;	author cloder;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.19.15.25.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.08.14.21.39.26;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.09.00.28.20;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.11.27.22.00.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.23.15;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.54;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2005.01.06.03.06.30;	author brad;	state Exp;
branches;
next	;

1.9.6.1
date	2005.01.06.01.28.13;	author brad;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Avoid a transient PLT entry for the internal __getcwd syscall stub for
slightly better code on some archs
@
text
@/*	$OpenBSD: getcwd.c,v 1.20 2016/05/07 19:05:22 guenther Exp $	*/

/*
 * Copyright (c) 2005 Marius Eriksen <marius@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <errno.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>

int __getcwd(char *buf, size_t len);
PROTO_NORMAL(__getcwd);

char *
getcwd(char *buf, size_t size)
{
	char *allocated = NULL;

	if (buf != NULL && size == 0) {
		errno = EINVAL;
		return (NULL);
	}

	if (buf == NULL &&
	    (allocated = buf = malloc(size = PATH_MAX)) == NULL)
		return (NULL);

	if (__getcwd(buf, size) == -1) {
		free(allocated);
		return (NULL);
	}

	return (buf);
}
DEF_WEAK(getcwd);
@


1.20
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcwd.c,v 1.19 2013/09/30 12:02:33 millert Exp $	*/
d25 1
@


1.19
log
@Use PATH_MAX, NAME_MAX and LOGIN_NAME_MAX not MAXPATHNAMELEN,
MAXNAMLEN or MAXLOGNAME where possible.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcwd.c,v 1.18 2013/04/17 17:40:35 tedu Exp $	*/
d47 1
@


1.18
log
@add some prototypes, casts, includes, parenthesis, and whatnot to
silence some warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: getcwd.c,v 1.17 2006/05/27 18:06:29 pedro Exp $	*/
a18 1
#include <sys/param.h>
d20 1
d37 1
a37 1
	    (allocated = buf = malloc(size = MAXPATHLEN)) == NULL)
@


1.17
log
@System calls return -1 upon failure, so check for -1
Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcwd.c,v 1.16 2006/05/27 18:00:27 pedro Exp $	*/
d22 1
@


1.16
log
@Don't leak memory if getcwd() was passed NULL and __getcwd() fails
Okay miod@@ sturm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getcwd.c,v 1.15 2006/05/27 16:14:02 pedro Exp $	*/
d39 1
a39 1
	if (__getcwd(buf, size) < 0) {
@


1.15
log
@Make libc's getcwd() use the new __getcwd() system call
Hacked by marius@@ at c2k5, okay miod@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 2
d36 5
a40 1
	    (buf = malloc(size = MAXPATHLEN)) == NULL)
d42 1
d44 1
a44 1
	return (__getcwd(buf, size) < 0 ? NULL : buf);
@


1.14
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 2
a2 1
/*	$OpenBSD$ */
d4 1
a4 2
 * Copyright (c) 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
d6 3
a8 11
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d10 7
a16 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a19 2
#include <sys/stat.h>

a20 2
#include <dirent.h>
#include <stdio.h>
a21 2
#include <string.h>
#include <unistd.h>
d23 1
a23 3
#define	ISDOT(dp) \
	(dp->d_name[0] == '.' && (dp->d_name[1] == '\0' || \
	    (dp->d_name[1] == '.' && dp->d_name[2] == '\0')))
d26 1
a26 1
getcwd(char *pt, size_t size)
d28 3
a30 161
	struct dirent *dp;
	DIR *dir = NULL;
	dev_t dev;
	ino_t ino;
	int first;
	char *bpt, *bup;
	struct stat s;
	dev_t root_dev;
	ino_t root_ino;
	size_t ptsize, upsize;
	int save_errno;
	char *ept, *eup, *up;

	/*
	 * If no buffer specified by the user, allocate one as necessary.
	 * If a buffer is specified, the size has to be non-zero.  The path
	 * is built from the end of the buffer backwards.
	 */
	if (pt) {
		ptsize = 0;
		if (!size) {
			errno = EINVAL;
			return (NULL);
		}
		ept = pt + size;
	} else {
		if ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)
			return (NULL);
		ept = pt + ptsize;
	}
	bpt = ept - 1;
	*bpt = '\0';

	/*
	 * Allocate bytes for the string of "../"'s.
	 * Should always be enough (it's 340 levels).  If it's not, allocate
	 * as necessary.  Special * case the first stat, it's ".", not "..".
	 */
	if ((up = malloc(upsize = MAXPATHLEN)) == NULL)
		goto err;
	eup = up + upsize;
	bup = up;
	up[0] = '.';
	up[1] = '\0';

	/* Save root values, so know when to stop. */
	if (stat("/", &s))
		goto err;
	root_dev = s.st_dev;
	root_ino = s.st_ino;

	errno = 0;			/* XXX readdir has no error return. */

	for (first = 1;; first = 0) {
		/* Stat the current level. */
		if (lstat(up, &s))
			goto err;

		/* Save current node values. */
		ino = s.st_ino;
		dev = s.st_dev;

		/* Check for reaching root. */
		if (root_dev == dev && root_ino == ino) {
			*--bpt = '/';
			/*
			 * It's unclear that it's a requirement to copy the
			 * path to the beginning of the buffer, but it's always
			 * been that way and stuff would probably break.
			 */
			memmove(pt, bpt, ept - bpt);
			free(up);
			return (pt);
		}

		/*
		 * Build pointer to the parent directory, allocating memory
		 * as necessary.  Max length is 3 for "../", the largest
		 * possible component name, plus a trailing NUL.
		 */
		if (bup + 3  + MAXNAMLEN + 1 >= eup) {
			char *nup;

			if ((nup = realloc(up, upsize *= 2)) == NULL)
				goto err;
			bup = nup + (bup - up);
			up = nup;
			eup = up + upsize;
		}
		*bup++ = '.';
		*bup++ = '.';
		*bup = '\0';

		/* Open and stat parent directory. */
		if (!(dir = opendir(up)) || fstat(dirfd(dir), &s))
			goto err;

		/* Add trailing slash for next directory. */
		*bup++ = '/';

		/*
		 * If it's a mount point, have to stat each element because
		 * the inode number in the directory is for the entry in the
		 * parent directory, not the inode number of the mounted file.
		 */
		save_errno = 0;
		if (s.st_dev == dev) {
			for (;;) {
				if (!(dp = readdir(dir)))
					goto notfound;
				if (dp->d_fileno == ino)
					break;
			}
		} else
			for (;;) {
				if (!(dp = readdir(dir)))
					goto notfound;
				if (ISDOT(dp))
					continue;
				memcpy(bup, dp->d_name, dp->d_namlen + 1);

				/* Save the first error for later. */
				if (lstat(up, &s)) {
					if (!save_errno)
						save_errno = errno;
					errno = 0;
					continue;
				}
				if (s.st_dev == dev && s.st_ino == ino)
					break;
			}

		/*
		 * Check for length of the current name, preceding slash,
		 * leading slash.
		 */
		if (bpt - pt < dp->d_namlen + (first ? 1 : 2)) {
			size_t len;
			char *npt;

			if (!ptsize) {
				errno = ERANGE;
				goto err;
			}
			len = ept - bpt;
			if ((npt = realloc(pt, ptsize *= 2)) == NULL)
				goto err;
			bpt = npt + (bpt - pt);
			pt = npt;
			ept = pt + ptsize;
			memmove(ept - len, bpt, len);
			bpt = ept - len;
		}
		if (!first)
			*--bpt = '/';
		bpt -= dp->d_namlen;
		memcpy(bpt, dp->d_name, dp->d_namlen);
		(void)closedir(dir);

		/* Truncate any file name. */
		*bup = '\0';
d33 3
a35 19
notfound:
	/*
	 * If readdir set errno, use it, not any saved error; otherwise,
	 * didn't find the current directory in its parent directory, set
	 * errno to ENOENT.
	 */
	if (!errno)
		errno = save_errno ? save_errno : ENOENT;
	/* FALLTHROUGH */
err:
	save_errno = errno;

	if (ptsize)
		free(pt);
	free(up);
	if (dir)
		(void)closedir(dir);

	errno = save_errno;
d37 1
a37 1
	return (NULL);
@


1.13
log
@Save errno from clobbering by clsoedir() in the err case.
From Andrey Matveev; OK deraadt@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.12 2005/03/25 15:38:47 otto Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.12
log
@deregister (and deauto!). ok millert@@ marco@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.11 2005/01/06 03:26:02 millert Exp $";
d224 2
d231 3
@


1.11
log
@Replace bcopy() with memcpy() and memmove() so it is obvious what
is a move and what is a copy.  Also remove an unneeded variable.
No functional change.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.10 2005/01/05 19:48:08 otto Exp $";
d51 6
a56 6
	register struct dirent *dp;
	register DIR *dir = NULL;
	register dev_t dev;
	register ino_t ino;
	register int first;
	register char *bpt, *bup;
@


1.10
log
@Fix handling of memory allocation. Both the initial value of eup
and the new value of bup after realloc() were bogus.  This bug has
been here since the net.2 days.  Additionally, make the initial
size of the malloc'ed pieces of mem more sane and kill a redundant
test before free(). getcwd(3) is now able to return really long
paths.  Problem spotted by Peter Philipp <philipp at scan-plus dot de>

ok millert@@ deraadt@@
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.9 2003/06/11 21:03:10 deraadt Exp $";
d121 1
a121 1
			bcopy(bpt, pt, ept - bpt);
d170 1
a170 1
				bcopy(dp->d_name, bup, dp->d_namlen + 1);
d188 1
a188 1
			size_t len, off;
a194 1
			off = bpt - pt;
d198 1
a199 1
			bpt = pt + off;
d201 1
a201 1
			bcopy(bpt, ept - len, len);
d207 1
a207 1
		bcopy(dp->d_name, bpt, dp->d_namlen);
@


1.9
log
@ansification; checked by pval
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.8 2003/06/02 20:18:34 millert Exp $";
d77 1
a77 1
		if ((pt = malloc(ptsize = 1024 - 4)) == NULL)
d85 1
a85 1
	 * Allocate bytes (1024 - malloc space) for the string of "../"'s.
d89 1
a89 1
	if ((up = malloc(upsize = 1024 - 4)) == NULL)
d91 1
a91 1
	eup = up + MAXPATHLEN;
d136 1
a137 1
			bup = up;
d227 1
a227 2
	if (up)
		free(up);
@


1.9.4.1
log
@MFC:
Fix by otto@@

Fix handling of memory allocation. Both the initial value of eup
and the new value of bup after realloc() were bogus.  This bug has
been here since the net.2 days.  Additionally, make the initial
size of the malloc'ed pieces of mem more sane and kill a redundant
test before free(). getcwd(3) is now able to return really long
paths.  Problem spotted by Peter Philipp <philipp at scan-plus dot de>
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.9 2003/06/11 21:03:10 deraadt Exp $";
d77 1
a77 1
		if ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)
d85 1
a85 1
	 * Allocate bytes for the string of "../"'s.
d89 1
a89 1
	if ((up = malloc(upsize = MAXPATHLEN)) == NULL)
d91 1
a91 1
	eup = up + upsize;
a135 1
			bup = nup + (bup - up);
d137 1
d227 2
a228 1
	free(up);
@


1.9.6.1
log
@MFC:
Fix by otto@@

Fix handling of memory allocation. Both the initial value of eup
and the new value of bup after realloc() were bogus.  This bug has
been here since the net.2 days.  Additionally, make the initial
size of the malloc'ed pieces of mem more sane and kill a redundant
test before free(). getcwd(3) is now able to return really long
paths.  Problem spotted by Peter Philipp <philipp at scan-plus dot de>
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.9 2003/06/11 21:03:10 deraadt Exp $";
d77 1
a77 1
		if ((pt = malloc(ptsize = MAXPATHLEN)) == NULL)
d85 1
a85 1
	 * Allocate bytes for the string of "../"'s.
d89 1
a89 1
	if ((up = malloc(upsize = MAXPATHLEN)) == NULL)
d91 1
a91 1
	eup = up + upsize;
a135 1
			bup = nup + (bup - up);
d137 1
d227 2
a228 1
	free(up);
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.7 2002/11/24 01:52:27 cloder Exp $";
d49 1
a49 3
getcwd(pt, size)
	char *pt;
	size_t size;
@


1.7
log
@Fix comment: s/trailing NULL/trailing NUL/, no code changes.
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.6 2000/07/19 15:25:13 deraadt Exp $";
@


1.6
log
@off-by-one calculation error; getcwd() would return NULL if the buffer was
the needed length + terminating byte + 1; that 1 is not needed; assar
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.5 1998/08/14 21:39:26 deraadt Exp $";
d135 1
a135 1
		 * possible component name, plus a trailing NULL.
@


1.5
log
@realloc repair
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.4 1997/07/09 00:28:20 millert Exp $";
d193 1
a193 1
		if (bpt - pt <= dp->d_namlen + (first ? 1 : 2)) {
@


1.4
log
@Clean up some -Wall complaints.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.3 1996/11/27 22:00:45 millert Exp $";
d138 3
a140 1
			if ((up = realloc(up, upsize *= 2)) == NULL)
d142 1
d195 1
d203 1
a203 1
			if ((pt = realloc(pt, ptsize *= 2)) == NULL)
d205 1
d233 2
a234 1
	free(up);
@


1.3
log
@Fix file descriptor leak on error.  Noticed by bitblt.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.2 1996/08/19 08:23:15 tholo Exp $";
d50 1
a50 1
	    dp->d_name[1] == '.' && dp->d_name[2] == '\0'))
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: getcwd.c,v 1.5 1995/06/16 07:05:30 jtc Exp $";
d58 1
a58 1
	register DIR *dir;
d229 2
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: getcwd.c,v 1.5 1995/06/16 07:05:30 jtc Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)getcwd.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$NetBSD: getcwd.c,v 1.5 1995/06/16 07:05:30 jtc Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
