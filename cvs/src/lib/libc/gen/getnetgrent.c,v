head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.2
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.22
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.20
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.16
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.14
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.12
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.10
	OPENBSD_5_0:1.22.0.8
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.10
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.6
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2016.09.24.12.43.37;	author millert;	state Exp;
branches;
next	1.27;
commitid	Dti2i9QkyJYNiWzO;

1.27
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.26;
commitid	iWfSX2BIn0sLw62l;

1.26
date	2015.09.14.10.44.40;	author guenther;	state Exp;
branches;
next	1.25;
commitid	0GYQFU5Z6lrYnElQ;

1.25
date	2015.09.10.18.59.34;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	6O6HanUgBazjFluC;

1.24
date	2015.08.31.02.53.57;	author guenther;	state Exp;
branches;
next	1.23;
commitid	lTMF8Y3C9fQGd6jQ;

1.23
date	2014.10.08.04.37.02;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	mfNgKbS5szKX81MY;

1.22
date	2009.11.11.18.41.57;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.17.07.07.23;	author moritz;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.05.08.12.15;	author moritz;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.02.15.19.16;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.05.20.29.14;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.06.17.03.56;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.29.15.52.28;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.06.03.07.41;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.17.19.42.22;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.09.23.04.16;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.24.17.04.02;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.08.14.21.39.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.10.23.07.30;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.07.23.21.04.05;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.02.03.00.10.08;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.02.23.27.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.08.19.08.23.49;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.05.01.12.56.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.55;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Fix matching when all of user, host and domain are specified.
OK guenther@@
@
text
@/*	$OpenBSD: getnetgrent.c,v 1.27 2015/09/14 16:09:13 tedu Exp $	*/

/*
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christos Zoulas.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <stdio.h>
#include <netgroup.h>
#include <string.h>
#include <fcntl.h>
#include <err.h>
#include <ctype.h>
#include <stdlib.h>
#include <db.h>
#ifdef YP
#include <rpcsvc/ypclnt.h>
#endif

#define _NG_STAR(s)	(((s) == NULL || *(s) == '\0') ? _ngstar : s)
#define _NG_EMPTY(s)	((s) == NULL ? "" : s)
#define _NG_ISSPACE(p)	(isspace((unsigned char) (p)) || (p) == '\n')

static const char _ngstar[] = "*";
static struct netgroup *_nghead = (struct netgroup *)NULL;
static struct netgroup *_nglist = (struct netgroup *)NULL;
static DB *_ng_db;

/*
 * Simple string list
 */
struct stringlist {
	char		**sl_str;
	size_t		  sl_max;
	size_t		  sl_cur;
};

static struct stringlist *_ng_sl_init(void);
static int	_ng_sl_add(struct stringlist *, char *);
static void	_ng_sl_free(struct stringlist *, int);
static char    *_ng_sl_find(struct stringlist *, char *);
static char    *_ng_makekey(const char *, const char *, size_t);
static int	_ng_parse(char **, char **, struct netgroup **);
static void	_ng_print(char *, size_t, const struct netgroup *);

static int		getstring(char **, int, char **);
static struct netgroup	*getnetgroup(char **);
static int		 lookup(const char *, char *, char **, int);
static void		 addgroup(char *, struct stringlist *, char *);
static int		 in_check(const char *, const char *,
			    const char *, struct netgroup *);
static int		 in_find(char *, struct stringlist *,
			    char *, const char *, const char *, const char *);
static char		*in_lookup1(const char *, const char *,
			    const char *, int);
static int		 in_lookup(const char *, const char *,
			    const char *, const char *, int);

/*
 * _ng_sl_init(): Initialize a string list
 */
static struct stringlist *
_ng_sl_init(void)
{
	struct stringlist *sl = malloc(sizeof(struct stringlist));
	if (sl == NULL)
		return NULL;

	sl->sl_cur = 0;
	sl->sl_max = 20;
	sl->sl_str = calloc(sl->sl_max, sizeof(char *));
	if (sl->sl_str == NULL) {
		free(sl);
		return NULL;
	}
	return sl;
}


/*
 * _ng_sl_add(): Add an item to the string list
 */
static int
_ng_sl_add(struct stringlist *sl, char *name)
{
	if (sl->sl_cur == sl->sl_max - 1) {
		char **slstr;

		sl->sl_max += 20;
		slstr = reallocarray(sl->sl_str, sl->sl_max, sizeof(char *));
		if (slstr == NULL) {
			free(sl->sl_str);
			sl->sl_str = NULL;
			return -1;
		}
		sl->sl_str = slstr;
	}
	sl->sl_str[sl->sl_cur++] = name;
	return 0;
}


/*
 * _ng_sl_free(): Free a stringlist
 */
static void
_ng_sl_free(struct stringlist *sl, int all)
{
	size_t	i;

	if (all)
		for (i = 0; i < sl->sl_cur; i++)
			free(sl->sl_str[i]);
	free(sl->sl_str);
	free(sl);
}


/*
 * sl_find(): Find a name in the string list
 */
static char *
_ng_sl_find(struct stringlist *sl, char *name)
{
	size_t	i;

	for (i = 0; i < sl->sl_cur; i++)
		if (strcmp(sl->sl_str[i], name) == 0)
			return sl->sl_str[i];

	return NULL;
}


/*
 * getstring(): Get a string delimited by the character, skipping leading and
 * trailing blanks and advancing the pointer
 */
static int
getstring(char **pp, int del, char **str)
{
	char *sp, *ep, *dp;

	/* skip leading blanks */
	for (sp = *pp; *sp && _NG_ISSPACE(*sp); sp++)
		continue;

	/* accumulate till delimiter or space */
	for (ep = sp; *ep && *ep != del && !_NG_ISSPACE(*ep); ep++)
		continue;

	/* hunt for the delimiter */
	for (dp = ep; *dp && *dp != del && _NG_ISSPACE(*dp); dp++)
		continue;

	if (*dp != del) {
		*str = NULL;
		return 0;
	}

	*pp = ++dp;

	del = (ep - sp) + 1;
	if (del > 1) {
		dp = malloc(del);
		if (dp == NULL)
			return 0;
		memcpy(dp, sp, del);
		dp[del - 1] = '\0';
	} else
		dp = NULL;

	*str = dp;
	return 1;
}


/*
 * getnetgroup(): Parse a netgroup, and advance the pointer
 */
static struct netgroup *
getnetgroup(char **pp)
{
	struct netgroup *ng = malloc(sizeof(struct netgroup));

	if (ng == NULL)
		return NULL;

	(*pp)++;	/* skip '(' */
	if (!getstring(pp, ',', &ng->ng_host))
		goto badhost;

	if (!getstring(pp, ',', &ng->ng_user))
		goto baduser;

	if (!getstring(pp, ')', &ng->ng_domain))
		goto baddomain;

#ifdef DEBUG_NG
	{
		char buf[1024];
		_ng_print(buf, sizeof(buf), ng);
		fprintf(stderr, "netgroup %s\n", buf);
	}
#endif
	return ng;

baddomain:
	free(ng->ng_user);
baduser:
	free(ng->ng_host);
badhost:
	free(ng);
	return NULL;
}


/*
 * lookup(): Find the given key in the database or yp, and return its value
 * in *line; returns 1 if key was found, 0 otherwise
 */
static int
lookup(const char *ypdom, char *name, char **line, int bywhat)
{
	int	ret;
#ifdef YP
	int	i;
	char	*map = NULL;
#endif

	if (_ng_db) {
		DBT	 key, data;
		size_t	 len = strlen(name) + 2;
		char	*ks = malloc(len);

		if (ks == NULL)
			return 0;
		ks[0] = bywhat;
		memcpy(&ks[1], name, len - 1);

		key.data = (u_char *) ks;
		key.size = len;

		ret = (_ng_db->get)(_ng_db, &key, &data, 0);
		free(ks);
		switch (ret) {
		case 0:
			*line = strdup(data.data);
			if (*line == NULL)
				return 0;
			return 1;

		case 1:
			break;

		case -1:
			return 0;
		}
	}
#ifdef YP
	if (ypdom) {
		switch (bywhat) {
		case _NG_KEYBYNAME:
			map = "netgroup";
			break;

		case _NG_KEYBYUSER:
			map = "netgroup.byuser";
			break;

		case _NG_KEYBYHOST:
			map = "netgroup.byhost";
			break;
		}


		if (yp_match(ypdom, map, name, strlen(name), line, &i) == 0)
			return 1;
	}
#endif

	return 0;
}


/*
 * _ng_parse(): Parse a line and return: _NG_ERROR: Syntax Error _NG_NONE:
 * line was empty or a comment _NG_GROUP: line had a netgroup definition,
 * returned in ng _NG_NAME:  line had a netgroup name, returned in name
 *
 * Public since used by netgroup_mkdb
 */
static int
_ng_parse(char **p, char **name, struct netgroup **ng)
{
	while (**p) {
		if (**p == '#')
			/* comment */
			return _NG_NONE;

		while (**p && _NG_ISSPACE(**p))
			/* skipblank */
			(*p)++;

		if (**p == '(') {
			if ((*ng = getnetgroup(p)) == NULL)
				return _NG_ERROR;
			return _NG_GROUP;
		} else {
			char	*np;
			int	i;

			for (np = *p; **p && !_NG_ISSPACE(**p); (*p)++)
				continue;
			if (np != *p) {
				i = (*p - np) + 1;
				*name = malloc(i);
				if (*name == NULL)
					return _NG_ERROR;
				memcpy(*name, np, i);
				(*name)[i - 1] = '\0';
				return _NG_NAME;
			}
		}
	}
	return _NG_NONE;
}


/*
 * addgroup(): Recursively add all the members of the netgroup to this group
 */
static void
addgroup(char *ypdom, struct stringlist *sl, char *grp)
{
	char		*line, *p;
	struct netgroup	*ng;
	char		*name;

#ifdef DEBUG_NG
	(void) fprintf(stderr, "addgroup(%s)\n", grp);
#endif
	/* check for cycles */
	if (_ng_sl_find(sl, grp) != NULL) {
		warnx("netgroup: Cycle in group `%s'", grp);
		free(grp);
		return;
	}
	if (_ng_sl_add(sl, grp) == -1) {
		free(grp);
		return;
	}

	/* Lookup this netgroup */
	if (!lookup(ypdom, grp, &line, _NG_KEYBYNAME))
		return;

	p = line;

	for (;;) {
		switch (_ng_parse(&p, &name, &ng)) {
		case _NG_NONE:
			/* Done with the line */
			free(line);
			return;

		case _NG_GROUP:
			/* new netgroup */
			/* add to the list */
			ng->ng_next = _nglist;
			_nglist = ng;
			break;

		case _NG_NAME:
			/* netgroup name */
			addgroup(ypdom, sl, name);
			break;

		case _NG_ERROR:
			return;
		}
	}
}


/*
 * in_check(): Compare the spec with the netgroup
 */
static int
in_check(const char *host, const char *user, const char *domain,
    struct netgroup *ng)
{
	if ((host != NULL) && (ng->ng_host != NULL) &&
	    strcmp(ng->ng_host, host) != 0)
		return 0;

	if ((user != NULL) && (ng->ng_user != NULL) &&
	    strcmp(ng->ng_user, user) != 0)
		return 0;

	if ((domain != NULL) && (ng->ng_domain != NULL) &&
	    strcmp(ng->ng_domain, domain) != 0)
		return 0;

	return 1;
}


/*
 * in_find(): Find a match for the host, user, domain spec
 */
static int
in_find(char *ypdom, struct stringlist *sl, char *grp, const char *host,
    const char *user, const char *domain)
{
	char		*line, *p;
	int		 i;
	struct netgroup	*ng;
	char		*name;

#ifdef DEBUG_NG
	(void) fprintf(stderr, "in_find(%s)\n", grp);
#endif
	/* check for cycles */
	if (_ng_sl_find(sl, grp) != NULL) {
		warnx("netgroup: Cycle in group `%s'", grp);
		free(grp);
		return 0;
	}
	if (_ng_sl_add(sl, grp) == -1) {
		free(grp);
		return 0;
	}

	/* Lookup this netgroup */
	if (!lookup(ypdom, grp, &line, _NG_KEYBYNAME))
		return 0;

	p = line;

	for (;;) {
		switch (_ng_parse(&p, &name, &ng)) {
		case _NG_NONE:
			/* Done with the line */
			free(line);
			return 0;

		case _NG_GROUP:
			/* new netgroup */
			i = in_check(host, user, domain, ng);
			free(ng->ng_host);
			free(ng->ng_user);
			free(ng->ng_domain);
			free(ng);
			if (i) {
				free(line);
				return 1;
			}
			break;

		case _NG_NAME:
			/* netgroup name */
			if (in_find(ypdom, sl, name, host, user, domain)) {
				free(line);
				return 1;
			}
			break;

		case _NG_ERROR:
			free(line);
			return 0;
		}
	}
}


/*
 * _ng_makekey(): Make a key from the two names given. The key is of the form
 * <name1>.<name2> Names strings are replaced with * if they are empty;
 */
static char *
_ng_makekey(const char *s1, const char *s2, size_t len)
{
	char *buf = malloc(len);
	int ret;

	if (buf == NULL)
		return NULL;
	ret = snprintf(buf, len, "%s.%s", _NG_STAR(s1), _NG_STAR(s2));
	if (ret < 0 || ret >= len) {
		free(buf);
		return NULL;
	}

	return buf;
}

static void
_ng_print(char *buf, size_t len, const struct netgroup *ng)
{
	(void) snprintf(buf, len, "(%s,%s,%s)", _NG_EMPTY(ng->ng_host),
	    _NG_EMPTY(ng->ng_user), _NG_EMPTY(ng->ng_domain));
}


/*
 * in_lookup1(): Fast lookup for a key in the appropriate map
 */
static char *
in_lookup1(const char *ypdom, const char *key, const char *domain, int map)
{
	char	*line;
	size_t	 len;
	char	*ptr;
	int	 res;

	len = (key ? strlen(key) : 1) + (domain ? strlen(domain) : 1) + 2;
	ptr = _ng_makekey(key, domain, len);
	if (ptr == NULL)
		return NULL;
	res = lookup(ypdom, ptr, &line, map);
	free(ptr);
	return res ? line : NULL;
}


/*
 * in_lookup(): Fast lookup for a key in the appropriate map
 */
static int
in_lookup(const char *ypdom, const char *group, const char *key,
    const char *domain, int map)
{
	size_t	 len;
	char	*ptr, *line;

	if (domain != NULL) {
		/* Domain specified; look in "group.domain" and "*.domain" */
		if ((line = in_lookup1(ypdom, key, domain, map)) == NULL)
			line = in_lookup1(ypdom, NULL, domain, map);
	} else
		line = NULL;

	if (line == NULL) {
		/*
		 * domain not specified or domain lookup failed; look in
		 * "group.*" and "*.*"
		 */
	    if (((line = in_lookup1(ypdom, key, NULL, map)) == NULL) &&
		((line = in_lookup1(ypdom, NULL, NULL, map)) == NULL))
		return 0;
	}

	len = strlen(group);

	for (ptr = line; (ptr = strstr(ptr, group)) != NULL;)
		/* Make sure we did not find a substring */
		if ((ptr != line && ptr[-1] != ',') ||
		    (ptr[len] != '\0' && strchr("\n\t ,", ptr[len]) == NULL))
			ptr++;
		else {
			free(line);
			return 1;
		}

	free(line);
	return 0;
}


void
endnetgrent(void)
{
	for (_nglist = _nghead; _nglist != NULL; _nglist = _nghead) {
		_nghead = _nglist->ng_next;
		free(_nglist->ng_host);
		free(_nglist->ng_user);
		free(_nglist->ng_domain);
		free(_nglist);
	}

	if (_ng_db) {
		(void) (_ng_db->close) (_ng_db);
		_ng_db = NULL;
	}
}
DEF_WEAK(endnetgrent);


void
setnetgrent(const char *ng)
{
	struct stringlist	*sl;
#ifdef YP
	char			*line;
#endif
	char			*ng_copy, *ypdom = NULL;

	/* Cleanup any previous storage */
	if (_nghead != NULL)
		endnetgrent();

	sl = _ng_sl_init();
	if (sl == NULL)
		return;

	if (_ng_db == NULL)
		_ng_db = dbopen(_PATH_NETGROUP_DB, O_RDONLY, 0, DB_HASH, NULL);

#ifdef YP
	/*
	 * We use yp if there is a "+" in the netgroup file, or if there is
	 * no netgroup file at all
	 */
	if (_ng_db == NULL || lookup(NULL, "+", &line, _NG_KEYBYNAME) == 0)
		yp_get_default_domain(&ypdom);
	else
		free(line);
#endif
	ng_copy = strdup(ng);
	if (ng_copy != NULL)
		addgroup(ypdom, sl, ng_copy);
	_nghead = _nglist;
	_ng_sl_free(sl, 1);
}
DEF_WEAK(setnetgrent);


int
getnetgrent(const char **host, const char **user, const char **domain)
{
	if (_nglist == NULL)
		return 0;

	*host   = _nglist->ng_host;
	*user   = _nglist->ng_user;
	*domain = _nglist->ng_domain;

	_nglist = _nglist->ng_next;

	return 1;
}
DEF_WEAK(getnetgrent);


int
innetgr(const char *grp, const char *host, const char *user, const char *domain)
{
	char	*ypdom = NULL, *grpdup;
#ifdef YP
	char	*line = NULL;
#endif
	int	 found;
	struct stringlist *sl;

	if (_ng_db == NULL)
		_ng_db = dbopen(_PATH_NETGROUP_DB, O_RDONLY, 0, DB_HASH, NULL);

#ifdef YP
	/*
	 * We use yp if there is a "+" in the netgroup file, or if there is
	 * no netgroup file at all
	 */
	if (_ng_db == NULL)
		yp_get_default_domain(&ypdom);
	else if (lookup(NULL, "+", &line, _NG_KEYBYNAME) == 0)
		yp_get_default_domain(&ypdom);

	free(line);
#endif

	/* Try the fast lookup first */
	if (host != NULL && user == NULL) {
		if (in_lookup(ypdom, grp, host, domain, _NG_KEYBYHOST))
			return 1;
	} else if (host == NULL && user != NULL) {
		if (in_lookup(ypdom, grp, user, domain, _NG_KEYBYUSER))
			return 1;
	}

	/* Too bad need the slow recursive way */
	sl = _ng_sl_init();
	if (sl == NULL)
		return 0;

	grpdup = strdup(grp);
	if (grpdup == NULL) {
		_ng_sl_free(sl, 1);
		return 0;
	}

	found = in_find(ypdom, sl, grpdup, host, user, domain);
	_ng_sl_free(sl, 1);

	return found;
}
DEF_WEAK(innetgr);
@


1.27
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.26 2015/09/14 10:44:40 guenther Exp $	*/
d707 4
a710 2
	/* If a domainname is given, we would have found a match */
	if (domain != NULL)
d714 2
a715 1
	if (grpdup == NULL)
d717 1
a718 6
	/* Too bad need the slow recursive way */
	sl = _ng_sl_init();
	if (sl == NULL) {
		free(grpdup);
		return 0;
	}
@


1.26
log
@Wrap <netgroup.h> so internal calls go direct and the symbols are all weak
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.25 2015/09/10 18:59:34 deraadt Exp $	*/
d236 1
a236 2
	if (ng->ng_user)
		free(ng->ng_user);
d238 1
a238 2
	if (ng->ng_host)
		free(ng->ng_host);
d478 3
a480 6
			if (ng->ng_host != NULL)
				free(ng->ng_host);
			if (ng->ng_user != NULL)
				free(ng->ng_user);
			if (ng->ng_domain != NULL)
				free(ng->ng_domain);
d603 3
a605 6
		if (_nglist->ng_host != NULL)
			free(_nglist->ng_host);
		if (_nglist->ng_user != NULL)
			free(_nglist->ng_user);
		if (_nglist->ng_domain != NULL)
			free(_nglist->ng_domain);
d696 1
a696 2
	if (line)
		free(line);
@


1.25
log
@Hide netgroup internals inside libc.  The parts that netgroup_mkdb
wants to use, well.... copy them there.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.24 2015/08/31 02:53:57 guenther Exp $	*/
d622 1
d661 1
d678 1
d735 1
@


1.24
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.23 2014/10/08 04:37:02 deraadt Exp $	*/
a35 1
#define _NETGROUP_PRIVATE
d65 8
d89 1
a89 1
struct stringlist *
d110 1
a110 1
int
d133 1
a133 1
void
d149 1
a149 1
char *
d322 1
a322 1
int
d513 1
a513 1
char *
d530 1
a530 1
void
@


1.23
log
@reallocarray() to detect potential int overflow; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.22 2009/11/11 18:41:57 jsg Exp $	*/
d367 1
a367 1
		_warnx("netgroup: Cycle in group `%s'", grp);
d448 1
a448 1
		_warnx("netgroup: Cycle in group `%s'", grp);
@


1.22
log
@fix leaks in error cases found by parfait
ok blambert@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.21 2007/09/17 07:07:23 moritz Exp $	*/
d110 1
a110 1
		slstr = realloc(sl->sl_str, sl->sl_max * sizeof(char *));
@


1.21
log
@Check snprintf(3) return value for error or truncation.
Mostly path construction, where truncation could be bad.

ok and input from deraadt@@ millert@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.20 2007/09/05 08:12:15 moritz Exp $	*/
d92 2
a93 1
	if (sl->sl_str == NULL)
d95 1
d716 2
a717 1
	if (sl == NULL)
d719 1
@


1.20
log
@Fix debugging code, which tried to print the netgroup name
using the return value of _ng_print(), which returns void.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.19 2007/09/02 15:19:16 deraadt Exp $	*/
d508 10
a517 2
	if (buf != NULL)
		(void) snprintf(buf, len, "%s.%s", _NG_STAR(s1), _NG_STAR(s2));
@


1.19
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.18 2007/03/05 20:29:14 millert Exp $	*/
d220 2
a221 2
		(void) fprintf(stderr, "netgroup %s\n",
		    _ng_print(buf, sizeof(buf), ng));
@


1.18
log
@Remove _err() calls from getnetgrent.c.  This is a minor API change
as _ng_sl_add() now returns a value. The only consumer of that
interface is netgroup_mkdb(8).  Adapted from NetBSD.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.17 2005/08/08 08:05:34 espie Exp $	*/
d91 1
a91 1
	sl->sl_str = malloc(sl->sl_max * sizeof(char *));
@


1.17
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.16 2005/08/06 17:03:56 deraadt Exp $	*/
a52 1
static const char _ngoomem[] = "netgroup: %m";
d87 1
a87 1
		_err(1, _ngoomem);
d93 1
a93 1
		_err(1, _ngoomem);
d101 1
a101 1
void
d110 1
a110 2
			if (sl->sl_str)
				free(sl->sl_str);
d112 1
a112 1
			_err(1, _ngoomem);
d117 1
d185 1
a185 1
			_err(1, _ngoomem);
d205 1
a205 1
		_err(1, _ngoomem);
d245 1
d256 2
d264 3
a266 1
		switch ((_ng_db->get) (_ng_db, &key, &data, 0)) {
a267 1
			free(ks);
d270 1
a270 1
				_err(1, _ngoomem);
d277 1
a277 2
			_warn("netgroup: db get");
			break;
a278 1
		free(ks);
d326 1
a326 2
			if ((*ng = getnetgroup(p)) == NULL) {
				_warnx("netgroup: Syntax error `%s'", *p);
a327 1
			}
d339 1
a339 1
					_err(1, _ngoomem);
d369 4
a372 1
	_ng_sl_add(sl, grp);
d450 4
a453 1
	_ng_sl_add(sl, grp);
d508 2
a509 3
	if (buf == NULL)
		_err(1, _ngoomem);
	(void) snprintf(buf, len, "%s.%s", _NG_STAR(s1), _NG_STAR(s2));
d534 2
d610 1
a610 1
	struct stringlist	*sl = _ng_sl_init();
d620 4
d638 2
a639 3
	if (ng_copy == NULL)
		_err(1, _ngoomem);
	addgroup(ypdom, sl, ng_copy);
d702 1
a702 1
		return (0);
d706 2
@


1.16
log
@fix use after free, netbsd pr 30832, from phirerunner@@comcast.net
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.15 2004/05/18 02:05:52 jfb Exp $	*/
a32 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.15 2004/05/18 02:05:52 jfb Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.15
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.14 2003/09/29 15:52:28 deraadt Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.14 2003/09/29 15:52:28 deraadt Exp $";
d370 1
a371 1
		_warnx("netgroup: Cycle in group `%s'", grp);
d448 1
a449 1
		_warnx("netgroup: Cycle in group `%s'", grp);
@


1.14
log
@unchecked strdup; ok henning; spotted by jjy2+@@pitt.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.13 2002/07/06 03:07:41 deraadt Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.13 2002/07/06 03:07:41 deraadt Exp $";
d88 1
a88 1
_ng_sl_init()
d107 1
a107 3
_ng_sl_add(sl, name)
	struct stringlist	*sl;
	char			*name;
d130 1
a130 3
_ng_sl_free(sl, all)
	struct stringlist	*sl;
	int			 all;
d146 1
a146 3
_ng_sl_find(sl, name)
	struct stringlist	*sl;
	char			*name;
d163 1
a163 4
getstring(pp, del, str)
	char	**pp;
	int	  del;
	char	**str;
d205 1
a205 2
getnetgroup(pp)
	char	**pp;
d248 1
a248 5
lookup(ypdom, name, line, bywhat)
	const char	 *ypdom;
	char		 *name;
	char		**line;
	int		  bywhat;
d317 1
a317 4
_ng_parse(p, name, ng)
	char		**p;
	char		**name;
	struct netgroup	**ng;
d359 1
a359 4
addgroup(ypdom, sl, grp)
	char			*ypdom;
	struct stringlist	*sl;
	char			*grp;
d412 2
a413 5
in_check(host, user, domain, ng)
	const char	*host;
	const char	*user;
	const char	*domain;
	struct netgroup	*ng;
d435 2
a436 7
in_find(ypdom, sl, grp, host, user, domain)
	char			*ypdom;
	struct stringlist	*sl;
	char			*grp;
	const char		*host;
	const char		*user;
	const char		*domain;
d504 1
a504 3
_ng_makekey(s1, s2, len)
	const char	*s1, *s2;
	size_t		 len;
d514 1
a514 4
_ng_print(buf, len, ng)
	char *buf;
	size_t len;
	const struct netgroup *ng;
d525 1
a525 5
in_lookup1(ypdom, key, domain, map)
	const char	*ypdom;
	const char	*key;
	const char	*domain;
	int		 map;
d544 2
a545 6
in_lookup(ypdom, group, key, domain, map)
	const char	*ypdom;
	const char	*group;
	const char	*key;
	const char	*domain;
	int		 map;
d585 1
a585 1
endnetgrent()
d606 1
a606 2
setnetgrent(ng)
	const char	*ng;
d641 1
a641 4
getnetgrent(host, user, domain)
	const char	**host;
	const char	**user;
	const char	**domain;
d657 1
a657 2
innetgr(grp, host, user, domain)
	const char	*grp, *host, *user, *domain;
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.12 2002/02/17 19:42:22 millert Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.12 2002/02/17 19:42:22 millert Exp $";
d705 1
a705 1
	char	*ypdom = NULL;
d741 4
d747 1
a747 1
	found = in_find(ypdom, sl, strdup(grp), host, user, domain);
@


1.12
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.11 2002/02/16 21:27:22 millert Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.11 2002/02/16 21:27:22 millert Exp $";
d265 2
a266 2
	int		i;
	char	       *map = NULL;
d327 1
a327 1
 * 
d352 2
a353 2
			char	       *np;
			int		i;
d438 2
a439 2
	if ((host != NULL) && (ng->ng_host != NULL)
	    && strcmp(ng->ng_host, host) != 0)
d442 2
a443 2
	if ((user != NULL) && (ng->ng_user != NULL)
	    && strcmp(ng->ng_user, user) != 0)
d446 2
a447 2
	if ((domain != NULL) && (ng->ng_domain != NULL)
	    && strcmp(ng->ng_domain, domain) != 0)
d595 1
a595 1
	} else 
d599 1
a599 1
		/* 
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.10 2000/12/09 23:04:16 deraadt Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.10 2000/12/09 23:04:16 deraadt Exp $";
d75 8
a82 9
static int		 in_check __P((const char *, const char *,
				       const char *, struct netgroup *));
static int		 in_find __P((char *, struct stringlist *,
				      char *, const char *,
				      const char *, const char *));
static char		*in_lookup1 __P((const char *, const char *,
					 const char *, int));
static int		 in_lookup __P((const char *, const char *,
					const char *, const char *, int));
@


1.10
log
@avoid incorrect free; reported by danh@@nfol.com, my fix
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.9 2000/08/24 17:04:02 deraadt Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.9 2000/08/24 17:04:02 deraadt Exp $";
d71 4
a74 4
static int		getstring __P((char **, int, char **));
static struct netgroup	*getnetgroup __P((char **));
static int		 lookup __P((const char *, char *, char **, int));
static void		 addgroup __P((char *, struct stringlist *, char *));
@


1.9
log
@proper protos
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.8 1998/08/14 21:39:28 deraadt Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.8 1998/08/14 21:39:28 deraadt Exp $";
d596 1
a596 2
	}
	else 
d708 1
a708 1
	char	*line;
d723 1
a723 1
	else if (lookup(NULL, "+", &line, _NG_KEYBYNAME) == 0) {
d725 2
a727 1
	}
@


1.8
log
@realloc repair
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.7 1997/10/10 23:07:30 deraadt Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.7 1997/10/10 23:07:30 deraadt Exp $";
d48 3
@


1.7
log
@NO abort() CALLS IN LIBC
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.6 1997/07/23 21:04:05 kstailey Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.6 1997/07/23 21:04:05 kstailey Exp $";
d110 2
d113 5
a117 2
		sl->sl_str = realloc(sl->sl_str, sl->sl_max * sizeof(char *));
		if (sl->sl_str == NULL)
d119 2
@


1.6
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: getnetgrent.c,v 1.5 1997/02/03 00:10:08 millert Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.5 1997/02/03 00:10:08 millert Exp $";
a301 4

		default:
			abort();
			break;
a413 4

		default:
			abort();
			return;
a511 4
			return 0;

		default:
			abort();
@


1.5
log
@Back out stringlist
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.3 1996/08/19 08:23:49 tholo Exp $";
d80 1
a80 1
				        const char *, const char *, int));
d256 2
a257 2
	int             i;
	char           *map = NULL;
d347 2
a348 2
			char           *np;
			int             i;
@


1.4
log
@stringlist routines are now public (ftp uses them)
@
text
@d1 1
a1 2
/*	$OpenBSD: getnetgrent.c,v 1.11 1997/01/17 07:26:19 lukem Exp $	*/
/*	$NetBSD: getnetgrent.c,v 1.11 1997/01/17 07:26:19 lukem Exp $	*/
d35 1
a35 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.11 1997/01/17 07:26:19 lukem Exp $";
a46 1
#include <stringlist.h>
a47 3
#ifdef YP
#include <rpcsvc/ypclnt.h>
#endif
d59 9
d71 1
a71 1
static void		 addgroup __P((char *, StringList *, char *));
d74 1
a74 1
static int		 in_find __P((char *, StringList *,
d83 73
d372 3
a374 3
	char		*ypdom;
	StringList	*sl;
	char		*grp;
d384 1
a384 1
	if (sl_find(sl, grp) != NULL) {
d389 1
a389 1
	sl_add(sl, grp);
d458 6
a463 6
	char		*ypdom;
	StringList	*sl;
	char		*grp;
	const char	*host;
	const char	*user;
	const char	*domain;
d474 1
a474 1
	if (sl_find(sl, grp) != NULL) {
d479 1
a479 1
	sl_add(sl, grp);
d654 1
a654 1
	StringList	*sl = sl_init();
d656 1
a656 1
	char		*line;
d658 1
a658 1
	char		*ng_copy, *ypdom = NULL;
d682 1
a682 1
	sl_free(sl, 1);
d714 1
a714 1
	StringList *sl;
d745 1
a745 1
	sl = sl_init();
d747 1
a747 1
	sl_free(sl, 1);
@


1.3
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 3
d36 1
a36 1
static char *rcsid = "$OpenBSD: getnetgrent.c,v 1.9 1996/04/27 18:59:05 christos Exp $";
d48 1
d50 3
a63 9
/*
 * Simple string list
 */
struct stringlist {
	char		**sl_str;
	size_t		  sl_max;
	size_t		  sl_cur;
};

d67 1
a67 1
static void		 addgroup __P((char *, struct stringlist *, char *));
d70 1
a70 1
static int		 in_find __P((char *, struct stringlist *,
a78 73
 * _ng_sl_init(): Initialize a string list
 */
struct stringlist *
_ng_sl_init()
{
	struct stringlist *sl = malloc(sizeof(struct stringlist));
	if (sl == NULL)
		_err(1, _ngoomem);

	sl->sl_cur = 0;
	sl->sl_max = 20;
	sl->sl_str = malloc(sl->sl_max * sizeof(char *));
	if (sl->sl_str == NULL)
		_err(1, _ngoomem);
	return sl;
}


/*
 * _ng_sl_add(): Add an item to the string list
 */
void
_ng_sl_add(sl, name)
	struct stringlist	*sl;
	char			*name;
{
	if (sl->sl_cur == sl->sl_max - 1) {
		sl->sl_max += 20;
		sl->sl_str = realloc(sl->sl_str, sl->sl_max * sizeof(char *));
		if (sl->sl_str == NULL)
			_err(1, _ngoomem);
	}
	sl->sl_str[sl->sl_cur++] = name;
}


/*
 * _ng_sl_free(): Free a stringlist
 */
void
_ng_sl_free(sl, all)
	struct stringlist	*sl;
	int			 all;
{
	size_t	i;

	if (all)
		for (i = 0; i < sl->sl_cur; i++)
			free(sl->sl_str[i]);
	free(sl->sl_str);
	free(sl);
}


/*
 * sl_find(): Find a name in the string list
 */
char *
_ng_sl_find(sl, name)
	struct stringlist	*sl;
	char			*name;
{
	size_t	i;

	for (i = 0; i < sl->sl_cur; i++)
		if (strcmp(sl->sl_str[i], name) == 0)
			return sl->sl_str[i];

	return NULL;
}


/*
d295 3
a297 3
	char			*ypdom;
	struct stringlist	*sl;
	char			*grp;
d307 1
a307 1
	if (_ng_sl_find(sl, grp) != NULL) {
d312 1
a312 1
	_ng_sl_add(sl, grp);
d381 6
a386 6
	char			*ypdom;
	struct stringlist	*sl;
	char			*grp;
	const char		*host;
	const char		*user;
	const char		*domain;
d397 1
a397 1
	if (_ng_sl_find(sl, grp) != NULL) {
d402 1
a402 1
	_ng_sl_add(sl, grp);
d577 1
a577 1
	struct stringlist	*sl = _ng_sl_init();
d579 1
a579 1
	char			*line;
d581 1
a581 1
	char			*ng_copy, *ypdom = NULL;
d605 1
a605 1
	_ng_sl_free(sl, 1);
d637 1
a637 1
	struct stringlist *sl;
d668 1
a668 1
	sl = _ng_sl_init();
d670 1
a670 1
	_ng_sl_free(sl, 1);
@


1.2
log
@from netbsd:
- grab prototypes from netgroup.h
- added _ng_print, netgroup pretty printing function
@
text
@a0 2
/*	$NetBSD: getnetgrent.c,v 1.9 1996/04/27 18:59:05 christos Exp $	*/

d33 1
a33 1
static char *rcsid = "$NetBSD: getnetgrent.c,v 1.9 1996/04/27 18:59:05 christos Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: getnetgrent.c,v 1.8 1995/02/25 08:51:19 cgd Exp $	*/
d35 1
a35 1
static char *rcsid = "$NetBSD: getnetgrent.c,v 1.8 1995/02/25 08:51:19 cgd Exp $";
d38 1
d40 1
d50 1
d224 5
a228 3
	(void) fprintf(stderr, "netgroup(%s,%s,%s)\n", 
		       _NG_STAR(ng->ng_host), _NG_STAR(ng->ng_user),
		       _NG_STAR(ng->ng_domain));
d544 10
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
