head	1.58;
access;
symbols
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.55.0.2
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.50.0.6
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.44.0.12
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.10
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.8
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.6
	OPENBSD_5_0:1.44.0.4
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.2
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.43.0.4
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.42.0.6
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.40.0.4
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.38.0.4
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.37.0.6
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.4
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.34.0.8
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.34.0.6
	OPENBSD_3_6_BASE:1.34
	OPENBSD_3_5:1.34.0.4
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	OPENBSD_3_3:1.32.0.4
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9:1.24.0.4
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.23.0.4
	OPENBSD_2_7_BASE:1.23
	OPENBSD_2_6:1.23.0.2
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.18.0.4
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.58
date	2017.03.17.15.14.40;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	2tX7jqLhzgiPspU4;

1.57
date	2017.02.15.15.58.40;	author schwarze;	state Exp;
branches;
next	1.56;
commitid	SbhhDwSLme6aBaSZ;

1.56
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.55;
commitid	pqjnYVtACzQ9ctai;

1.55
date	2016.06.28.17.21.48;	author millert;	state Exp;
branches;
next	1.54;
commitid	C8bhIjOA1blQo5Xq;

1.54
date	2016.06.28.17.12.29;	author millert;	state Exp;
branches;
next	1.53;
commitid	HSm7xpY9N1bVO7cv;

1.53
date	2015.11.01.03.45.29;	author guenther;	state Exp;
branches;
next	1.52;
commitid	CfNWDWdDpm7mVO8i;

1.52
date	2015.09.14.16.09.13;	author tedu;	state Exp;
branches;
next	1.51;
commitid	iWfSX2BIn0sLw62l;

1.51
date	2015.09.12.13.32.24;	author guenther;	state Exp;
branches;
next	1.50;
commitid	wUu6kCeHna1yCsxH;

1.50
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	0DYulI8hhujBHMcR;

1.49
date	2014.11.23.00.14.22;	author guenther;	state Exp;
branches;
next	1.48;
commitid	4rl8ZBcj5RLFyyQj;

1.48
date	2014.11.20.04.14.15;	author guenther;	state Exp;
branches;
next	1.47;
commitid	NvSQRGlGPGMO43OH;

1.47
date	2014.10.08.04.36.23;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	qJvL9AeXX203opSv;

1.46
date	2014.05.25.17.47.04;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2013.09.30.12.02.33;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2010.09.24.13.56.32;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2009.08.27.16.19.27;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.11.13.24.05;	author otto;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.27.12.30.13;	author pedro;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.06.10.14.53;	author chl;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.02.20.32.57;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.08.09.13.38;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.17.20.36.55;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.16.03.01.25;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.11.21.03.10;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.20.18.34;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.12.01.47.41;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.27.22.21.28;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.16.21.27.22;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.27.21.42.06;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.03.22.23.48;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.31.23.30.48;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.30.20.40.30;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.15.21.14.39;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.24.17.04.12;	author deraadt;	state Exp;
branches
	1.24.2.1
	1.24.4.1;
next	1.23;

1.23
date	99.10.03.20.39.53;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	99.10.03.19.22.22;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	99.10.03.19.17.31;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.08.16.07.57.02;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	99.05.17.02.32.31;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.08.15.08.10.15;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.08.14.21.39.24;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.07.03.01.10.27;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.03.19.00.30.01;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.10.11.04.04.40;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.10.06.23.32.49;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.09.20.17.33.45;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.09.01.02.44.17;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.08.29.22.43.08;	author imp;	state Exp;
branches;
next	1.9;

1.9
date	97.08.02.00.13.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.21.09.05;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.03.24.02.54.15;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.06.12.53;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.14.01.02.42;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.12.23.06.08.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.12.23.04.58.34;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.22.59;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.54;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.54;	author deraadt;	state Exp;
branches;
next	;

1.24.2.1
date	2001.05.31.21.09.24;	author miod;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2001.05.31.23.47.47;	author miod;	state Exp;
branches;
next	;

1.24.4.1
date	2001.05.31.02.20.29;	author jason;	state Exp;
branches;
next	1.24.4.2;

1.24.4.2
date	2001.06.03.18.56.16;	author jason;	state Exp;
branches;
next	;


desc
@@


1.58
log
@recallocarray() the string buffer, to avoid leaving such contents
around in the address space.  Don't bother doing so for the buffer
which contains aslr'd pointers...
ok millert
@
text
@/*	$OpenBSD: fts.c,v 1.57 2017/02/15 15:58:40 schwarze Exp $	*/

/*-
 * Copyright (c) 1990, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* ALIGN */
#include <sys/stat.h>

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <fts.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

static FTSENT	*fts_alloc(FTS *, char *, size_t);
static FTSENT	*fts_build(FTS *, int);
static void	 fts_lfree(FTSENT *);
static void	 fts_load(FTS *, FTSENT *);
static size_t	 fts_maxarglen(char * const *);
static void	 fts_padjust(FTS *, FTSENT *);
static int	 fts_palloc(FTS *, size_t);
static FTSENT	*fts_sort(FTS *, FTSENT *, int);
static u_short	 fts_stat(FTS *, FTSENT *, int, int);
static int	 fts_safe_changedir(FTS *, FTSENT *, int, char *);

#define	ISDOT(a)	(a[0] == '.' && (!a[1] || (a[1] == '.' && !a[2])))

#define	CLR(opt)	(sp->fts_options &= ~(opt))
#define	ISSET(opt)	(sp->fts_options & (opt))
#define	SET(opt)	(sp->fts_options |= (opt))

#define	FCHDIR(sp, fd)	(!ISSET(FTS_NOCHDIR) && fchdir(fd))

/* fts_build flags */
#define	BCHILD		1		/* fts_children */
#define	BNAMES		2		/* fts_children, names only */
#define	BREAD		3		/* fts_read */

FTS *
fts_open(char * const *argv, int options,
    int (*compar)(const FTSENT **, const FTSENT **))
{
	FTS *sp;
	FTSENT *p, *root;
	int nitems;
	FTSENT *parent, *prev;

	/* Options check. */
	if (options & ~FTS_OPTIONMASK) {
		errno = EINVAL;
		return (NULL);
	}

	/* At least one path must be specified. */
	if (*argv == NULL) {
		errno = EINVAL;
		return (NULL);
	}

	/* Allocate/initialize the stream */
	if ((sp = calloc(1, sizeof(FTS))) == NULL)
		return (NULL);
	sp->fts_compar = compar;
	sp->fts_options = options;

	/* Logical walks turn on NOCHDIR; symbolic links are too hard. */
	if (ISSET(FTS_LOGICAL))
		SET(FTS_NOCHDIR);

	/*
	 * Start out with 1K of path space, and enough, in any case,
	 * to hold the user's paths.
	 */
	if (fts_palloc(sp, MAXIMUM(fts_maxarglen(argv), PATH_MAX)))
		goto mem1;

	/* Allocate/initialize root's parent. */
	if ((parent = fts_alloc(sp, "", 0)) == NULL)
		goto mem2;
	parent->fts_level = FTS_ROOTPARENTLEVEL;

	/* Allocate/initialize root(s). */
	for (root = prev = NULL, nitems = 0; *argv; ++argv, ++nitems) {
		if ((p = fts_alloc(sp, *argv, strlen(*argv))) == NULL)
			goto mem3;
		p->fts_level = FTS_ROOTLEVEL;
		p->fts_parent = parent;
		p->fts_accpath = p->fts_name;
		p->fts_info = fts_stat(sp, p, ISSET(FTS_COMFOLLOW), -1);

		/* Command-line "." and ".." are real directories. */
		if (p->fts_info == FTS_DOT)
			p->fts_info = FTS_D;

		/*
		 * If comparison routine supplied, traverse in sorted
		 * order; otherwise traverse in the order specified.
		 */
		if (compar) {
			p->fts_link = root;
			root = p;
		} else {
			p->fts_link = NULL;
			if (root == NULL)
				root = p;
			else
				prev->fts_link = p;
			prev = p;
		}
	}
	if (compar && nitems > 1)
		root = fts_sort(sp, root, nitems);

	/*
	 * Allocate a dummy pointer and make fts_read think that we've just
	 * finished the node before the root(s); set p->fts_info to FTS_INIT
	 * so that everything about the "current" node is ignored.
	 */
	if ((sp->fts_cur = fts_alloc(sp, "", 0)) == NULL)
		goto mem3;
	sp->fts_cur->fts_link = root;
	sp->fts_cur->fts_info = FTS_INIT;

	/*
	 * If using chdir(2), grab a file descriptor pointing to dot to ensure
	 * that we can get back here; this could be avoided for some paths,
	 * but almost certainly not worth the effort.  Slashes, symbolic links,
	 * and ".." are all fairly nasty problems.  Note, if we can't get the
	 * descriptor we run anyway, just more slowly.
	 */
	if (!ISSET(FTS_NOCHDIR) &&
	    (sp->fts_rfd = open(".", O_RDONLY | O_CLOEXEC)) < 0)
		SET(FTS_NOCHDIR);

	if (nitems == 0)
		free(parent);

	return (sp);

mem3:	fts_lfree(root);
	free(parent);
mem2:	free(sp->fts_path);
mem1:	free(sp);
	return (NULL);
}
DEF_WEAK(fts_open);

static void
fts_load(FTS *sp, FTSENT *p)
{
	size_t len;
	char *cp;

	/*
	 * Load the stream structure for the next traversal.  Since we don't
	 * actually enter the directory until after the preorder visit, set
	 * the fts_accpath field specially so the chdir gets done to the right
	 * place and the user can access the first node.  From fts_open it's
	 * known that the path will fit.
	 */
	len = p->fts_pathlen = p->fts_namelen;
	memmove(sp->fts_path, p->fts_name, len + 1);
	if ((cp = strrchr(p->fts_name, '/')) && (cp != p->fts_name || cp[1])) {
		len = strlen(++cp);
		memmove(p->fts_name, cp, len + 1);
		p->fts_namelen = len;
	}
	p->fts_accpath = p->fts_path = sp->fts_path;
	sp->fts_dev = p->fts_dev;
}

int
fts_close(FTS *sp)
{
	FTSENT *freep, *p;
	int rfd, error = 0;

	/*
	 * This still works if we haven't read anything -- the dummy structure
	 * points to the root list, so we step through to the end of the root
	 * list which has a valid parent pointer.
	 */
	if (sp->fts_cur) {
		for (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;) {
			freep = p;
			p = p->fts_link ? p->fts_link : p->fts_parent;
			free(freep);
		}
		free(p);
	}

	/* Stash the original directory fd if needed. */
	rfd = ISSET(FTS_NOCHDIR) ? -1 : sp->fts_rfd;

	/* Free up child linked list, sort array, path buffer, stream ptr.*/
	if (sp->fts_child)
		fts_lfree(sp->fts_child);
	free(sp->fts_array);
	free(sp->fts_path);
	free(sp);

	/* Return to original directory, checking for error. */
	if (rfd != -1) {
		int saved_errno;
		error = fchdir(rfd);
		saved_errno = errno;
		(void)close(rfd);
		errno = saved_errno;
	}

	return (error);
}
DEF_WEAK(fts_close);

/*
 * Special case of "/" at the end of the path so that slashes aren't
 * appended which would cause paths to be written as "....//foo".
 */
#define	NAPPEND(p)							\
	(p->fts_path[p->fts_pathlen - 1] == '/'				\
	    ? p->fts_pathlen - 1 : p->fts_pathlen)

FTSENT *
fts_read(FTS *sp)
{
	FTSENT *p, *tmp;
	int instr;
	char *t;
	int saved_errno;

	/* If finished or unrecoverable error, return NULL. */
	if (sp->fts_cur == NULL || ISSET(FTS_STOP))
		return (NULL);

	/* Set current node pointer. */
	p = sp->fts_cur;

	/* Save and zero out user instructions. */
	instr = p->fts_instr;
	p->fts_instr = FTS_NOINSTR;

	/* Any type of file may be re-visited; re-stat and re-turn. */
	if (instr == FTS_AGAIN) {
		p->fts_info = fts_stat(sp, p, 0, -1);
		return (p);
	}

	/*
	 * Following a symlink -- SLNONE test allows application to see
	 * SLNONE and recover.  If indirecting through a symlink, have
	 * keep a pointer to current location.  If unable to get that
	 * pointer, follow fails.
	 */
	if (instr == FTS_FOLLOW &&
	    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {
		p->fts_info = fts_stat(sp, p, 1, -1);
		if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {
			if ((p->fts_symfd =
			    open(".", O_RDONLY | O_CLOEXEC)) < 0) {
				p->fts_errno = errno;
				p->fts_info = FTS_ERR;
			} else
				p->fts_flags |= FTS_SYMFOLLOW;
		}
		return (p);
	}

	/* Directory in pre-order. */
	if (p->fts_info == FTS_D) {
		/* If skipped or crossed mount point, do post-order visit. */
		if (instr == FTS_SKIP ||
		    (ISSET(FTS_XDEV) && p->fts_dev != sp->fts_dev)) {
			if (p->fts_flags & FTS_SYMFOLLOW)
				(void)close(p->fts_symfd);
			if (sp->fts_child) {
				fts_lfree(sp->fts_child);
				sp->fts_child = NULL;
			}
			p->fts_info = FTS_DP;
			return (p);
		}

		/* Rebuild if only read the names and now traversing. */
		if (sp->fts_child && ISSET(FTS_NAMEONLY)) {
			CLR(FTS_NAMEONLY);
			fts_lfree(sp->fts_child);
			sp->fts_child = NULL;
		}

		/*
		 * Cd to the subdirectory.
		 *
		 * If have already read and now fail to chdir, whack the list
		 * to make the names come out right, and set the parent errno
		 * so the application will eventually get an error condition.
		 * Set the FTS_DONTCHDIR flag so that when we logically change
		 * directories back to the parent we don't do a chdir.
		 *
		 * If haven't read do so.  If the read fails, fts_build sets
		 * FTS_STOP or the fts_info field of the node.
		 */
		if (sp->fts_child) {
			if (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {
				p->fts_errno = errno;
				p->fts_flags |= FTS_DONTCHDIR;
				for (p = sp->fts_child; p; p = p->fts_link)
					p->fts_accpath =
					    p->fts_parent->fts_accpath;
			}
		} else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {
			if (ISSET(FTS_STOP))
				return (NULL);
			return (p);
		}
		p = sp->fts_child;
		sp->fts_child = NULL;
		goto name;
	}

	/* Move to the next node on this level. */
next:	tmp = p;
	if ((p = p->fts_link)) {
		free(tmp);

		/*
		 * If reached the top, return to the original directory (or
		 * the root of the tree), and load the paths for the next root.
		 */
		if (p->fts_level == FTS_ROOTLEVEL) {
			if (FCHDIR(sp, sp->fts_rfd)) {
				SET(FTS_STOP);
				return (NULL);
			}
			fts_load(sp, p);
			return (sp->fts_cur = p);
		}

		/*
		 * User may have called fts_set on the node.  If skipped,
		 * ignore.  If followed, get a file descriptor so we can
		 * get back if necessary.
		 */
		if (p->fts_instr == FTS_SKIP)
			goto next;
		if (p->fts_instr == FTS_FOLLOW) {
			p->fts_info = fts_stat(sp, p, 1, -1);
			if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {
				if ((p->fts_symfd =
				    open(".", O_RDONLY | O_CLOEXEC)) < 0) {
					p->fts_errno = errno;
					p->fts_info = FTS_ERR;
				} else
					p->fts_flags |= FTS_SYMFOLLOW;
			}
			p->fts_instr = FTS_NOINSTR;
		}

name:		t = sp->fts_path + NAPPEND(p->fts_parent);
		*t++ = '/';
		memmove(t, p->fts_name, p->fts_namelen + 1);
		return (sp->fts_cur = p);
	}

	/* Move up to the parent node. */
	p = tmp->fts_parent;
	free(tmp);

	if (p->fts_level == FTS_ROOTPARENTLEVEL) {
		/*
		 * Done; free everything up and set errno to 0 so the user
		 * can distinguish between error and EOF.
		 */
		free(p);
		errno = 0;
		return (sp->fts_cur = NULL);
	}

	/* NUL terminate the pathname. */
	sp->fts_path[p->fts_pathlen] = '\0';

	/*
	 * Return to the parent directory.  If at a root node or came through
	 * a symlink, go back through the file descriptor.  Otherwise, cd up
	 * one directory.
	 */
	if (p->fts_level == FTS_ROOTLEVEL) {
		if (FCHDIR(sp, sp->fts_rfd)) {
			SET(FTS_STOP);
			sp->fts_cur = p;
			return (NULL);
		}
	} else if (p->fts_flags & FTS_SYMFOLLOW) {
		if (FCHDIR(sp, p->fts_symfd)) {
			saved_errno = errno;
			(void)close(p->fts_symfd);
			errno = saved_errno;
			SET(FTS_STOP);
			sp->fts_cur = p;
			return (NULL);
		}
		(void)close(p->fts_symfd);
	} else if (!(p->fts_flags & FTS_DONTCHDIR) &&
	    fts_safe_changedir(sp, p->fts_parent, -1, "..")) {
		SET(FTS_STOP);
		sp->fts_cur = p;
		return (NULL);
	}
	p->fts_info = p->fts_errno ? FTS_ERR : FTS_DP;
	return (sp->fts_cur = p);
}
DEF_WEAK(fts_read);

/*
 * Fts_set takes the stream as an argument although it's not used in this
 * implementation; it would be necessary if anyone wanted to add global
 * semantics to fts using fts_set.  An error return is allowed for similar
 * reasons.
 */
int
fts_set(FTS *sp, FTSENT *p, int instr)
{
	if (instr && instr != FTS_AGAIN && instr != FTS_FOLLOW &&
	    instr != FTS_NOINSTR && instr != FTS_SKIP) {
		errno = EINVAL;
		return (1);
	}
	p->fts_instr = instr;
	return (0);
}
DEF_WEAK(fts_set);

FTSENT *
fts_children(FTS *sp, int instr)
{
	FTSENT *p;
	int fd;

	if (instr && instr != FTS_NAMEONLY) {
		errno = EINVAL;
		return (NULL);
	}

	/* Set current node pointer. */
	p = sp->fts_cur;

	/*
	 * Errno set to 0 so user can distinguish empty directory from
	 * an error.
	 */
	errno = 0;

	/* Fatal errors stop here. */
	if (ISSET(FTS_STOP))
		return (NULL);

	/* Return logical hierarchy of user's arguments. */
	if (p->fts_info == FTS_INIT)
		return (p->fts_link);

	/*
	 * If not a directory being visited in pre-order, stop here.  Could
	 * allow FTS_DNR, assuming the user has fixed the problem, but the
	 * same effect is available with FTS_AGAIN.
	 */
	if (p->fts_info != FTS_D /* && p->fts_info != FTS_DNR */)
		return (NULL);

	/* Free up any previous child list. */
	if (sp->fts_child)
		fts_lfree(sp->fts_child);

	if (instr == FTS_NAMEONLY) {
		SET(FTS_NAMEONLY);
		instr = BNAMES;
	} else
		instr = BCHILD;

	/*
	 * If using chdir on a relative path and called BEFORE fts_read does
	 * its chdir to the root of a traversal, we can lose -- we need to
	 * chdir into the subdirectory, and we don't know where the current
	 * directory is, so we can't get back so that the upcoming chdir by
	 * fts_read will work.
	 */
	if (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||
	    ISSET(FTS_NOCHDIR))
		return (sp->fts_child = fts_build(sp, instr));

	if ((fd = open(".", O_RDONLY | O_CLOEXEC)) < 0)
		return (NULL);
	sp->fts_child = fts_build(sp, instr);
	if (fchdir(fd)) {
		(void)close(fd);
		return (NULL);
	}
	(void)close(fd);
	return (sp->fts_child);
}
DEF_WEAK(fts_children);

/*
 * This is the tricky part -- do not casually change *anything* in here.  The
 * idea is to build the linked list of entries that are used by fts_children
 * and fts_read.  There are lots of special cases.
 *
 * The real slowdown in walking the tree is the stat calls.  If FTS_NOSTAT is
 * set and it's a physical walk (so that symbolic links can't be directories),
 * we can do things quickly.  First, if it's a 4.4BSD file system, the type
 * of the file is in the directory entry.  Otherwise, we assume that the number
 * of subdirectories in a node is equal to the number of links to the parent.
 * The former skips all stat calls.  The latter skips stat calls in any leaf
 * directories and for any files after the subdirectories in the directory have
 * been found, cutting the stat calls by about 2/3.
 */
static FTSENT *
fts_build(FTS *sp, int type)
{
	struct dirent *dp;
	FTSENT *p, *head;
	FTSENT *cur, *tail;
	DIR *dirp;
	void *oldaddr;
	size_t len, maxlen;
	int nitems, cderrno, descend, level, nlinks, nostat, doadjust;
	int saved_errno;
	char *cp;

	/* Set current node pointer. */
	cur = sp->fts_cur;

	/*
	 * Open the directory for reading.  If this fails, we're done.
	 * If being called from fts_read, set the fts_info field.
	 */
	if ((dirp = opendir(cur->fts_accpath)) == NULL) {
		if (type == BREAD) {
			cur->fts_info = FTS_DNR;
			cur->fts_errno = errno;
		}
		return (NULL);
	}

	/*
	 * Nlinks is the number of possible entries of type directory in the
	 * directory if we're cheating on stat calls, 0 if we're not doing
	 * any stat calls at all, -1 if we're doing stats on everything.
	 */
	if (type == BNAMES)
		nlinks = 0;
	else if (ISSET(FTS_NOSTAT) && ISSET(FTS_PHYSICAL)) {
		nlinks = cur->fts_nlink - (ISSET(FTS_SEEDOT) ? 0 : 2);
		nostat = 1;
	} else {
		nlinks = -1;
		nostat = 0;
	}

#ifdef notdef
	(void)printf("nlinks == %d (cur: %u)\n", nlinks, cur->fts_nlink);
	(void)printf("NOSTAT %d PHYSICAL %d SEEDOT %d\n",
	    ISSET(FTS_NOSTAT), ISSET(FTS_PHYSICAL), ISSET(FTS_SEEDOT));
#endif
	/*
	 * If we're going to need to stat anything or we want to descend
	 * and stay in the directory, chdir.  If this fails we keep going,
	 * but set a flag so we don't chdir after the post-order visit.
	 * We won't be able to stat anything, but we can still return the
	 * names themselves.  Note, that since fts_read won't be able to
	 * chdir into the directory, it will have to return different path
	 * names than before, i.e. "a/b" instead of "b".  Since the node
	 * has already been visited in pre-order, have to wait until the
	 * post-order visit to return the error.  There is a special case
	 * here, if there was nothing to stat then it's not an error to
	 * not be able to stat.  This is all fairly nasty.  If a program
	 * needed sorted entries or stat information, they had better be
	 * checking FTS_NS on the returned nodes.
	 */
	cderrno = 0;
	if (nlinks || type == BREAD) {
		if (fts_safe_changedir(sp, cur, dirfd(dirp), NULL)) {
			if (nlinks && type == BREAD)
				cur->fts_errno = errno;
			cur->fts_flags |= FTS_DONTCHDIR;
			descend = 0;
			cderrno = errno;
			(void)closedir(dirp);
			dirp = NULL;
		} else
			descend = 1;
	} else
		descend = 0;

	/*
	 * Figure out the max file name length that can be stored in the
	 * current path -- the inner loop allocates more path as necessary.
	 * We really wouldn't have to do the maxlen calculations here, we
	 * could do them in fts_read before returning the path, but it's a
	 * lot easier here since the length is part of the dirent structure.
	 *
	 * If not changing directories set a pointer so that can just append
	 * each new name into the path.
	 */
	len = NAPPEND(cur);
	if (ISSET(FTS_NOCHDIR)) {
		cp = sp->fts_path + len;
		*cp++ = '/';
	}
	len++;
	maxlen = sp->fts_pathlen - len;

	/*
	 * fts_level is signed so we must prevent it from wrapping
	 * around to FTS_ROOTLEVEL and FTS_ROOTPARENTLEVEL.
	 */
	level = cur->fts_level;
	if (level < FTS_MAXLEVEL)
	    level++;

	/* Read the directory, attaching each entry to the `link' pointer. */
	doadjust = 0;
	for (head = tail = NULL, nitems = 0; dirp && (dp = readdir(dirp));) {
		if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))
			continue;

		if (!(p = fts_alloc(sp, dp->d_name, dp->d_namlen)))
			goto mem1;
		if (dp->d_namlen >= maxlen) {	/* include space for NUL */
			oldaddr = sp->fts_path;
			if (fts_palloc(sp, dp->d_namlen +len + 1)) {
				/*
				 * No more memory for path or structures.  Save
				 * errno, free up the current structure and the
				 * structures already allocated.
				 */
mem1:				saved_errno = errno;
				free(p);
				fts_lfree(head);
				(void)closedir(dirp);
				cur->fts_info = FTS_ERR;
				SET(FTS_STOP);
				errno = saved_errno;
				return (NULL);
			}
			/* Did realloc() change the pointer? */
			if (oldaddr != sp->fts_path) {
				doadjust = 1;
				if (ISSET(FTS_NOCHDIR))
					cp = sp->fts_path + len;
			}
			maxlen = sp->fts_pathlen - len;
		}

		p->fts_level = level;
		p->fts_parent = sp->fts_cur;
		p->fts_pathlen = len + dp->d_namlen;
		if (p->fts_pathlen < len) {
			/*
			 * If we wrap, free up the current structure and
			 * the structures already allocated, then error
			 * out with ENAMETOOLONG.
			 */
			free(p);
			fts_lfree(head);
			(void)closedir(dirp);
			cur->fts_info = FTS_ERR;
			SET(FTS_STOP);
			errno = ENAMETOOLONG;
			return (NULL);
		}

		if (cderrno) {
			if (nlinks) {
				p->fts_info = FTS_NS;
				p->fts_errno = cderrno;
			} else
				p->fts_info = FTS_NSOK;
			p->fts_accpath = cur->fts_accpath;
		} else if (nlinks == 0
#ifdef DT_DIR
		    || (nostat &&
		    dp->d_type != DT_DIR && dp->d_type != DT_UNKNOWN)
#endif
		    ) {
			p->fts_accpath =
			    ISSET(FTS_NOCHDIR) ? p->fts_path : p->fts_name;
			p->fts_info = FTS_NSOK;
		} else {
			/* Build a file name for fts_stat to stat. */
			if (ISSET(FTS_NOCHDIR)) {
				p->fts_accpath = p->fts_path;
				memmove(cp, p->fts_name, p->fts_namelen + 1);
				p->fts_info = fts_stat(sp, p, 0, dirfd(dirp));
			} else {
				p->fts_accpath = p->fts_name;
				p->fts_info = fts_stat(sp, p, 0, -1);
			}

			/* Decrement link count if applicable. */
			if (nlinks > 0 && (p->fts_info == FTS_D ||
			    p->fts_info == FTS_DC || p->fts_info == FTS_DOT))
				--nlinks;
		}

		/* We walk in directory order so "ls -f" doesn't get upset. */
		p->fts_link = NULL;
		if (head == NULL)
			head = tail = p;
		else {
			tail->fts_link = p;
			tail = p;
		}
		++nitems;
	}
	if (dirp)
		(void)closedir(dirp);

	/*
	 * If realloc() changed the address of the path, adjust the
	 * addresses for the rest of the tree and the dir list.
	 */
	if (doadjust)
		fts_padjust(sp, head);

	/*
	 * If not changing directories, reset the path back to original
	 * state.
	 */
	if (ISSET(FTS_NOCHDIR)) {
		if (len == sp->fts_pathlen || nitems == 0)
			--cp;
		*cp = '\0';
	}

	/*
	 * If descended after called from fts_children or after called from
	 * fts_read and nothing found, get back.  At the root level we use
	 * the saved fd; if one of fts_open()'s arguments is a relative path
	 * to an empty directory, we wind up here with no other way back.  If
	 * can't get back, we're done.
	 */
	if (descend && (type == BCHILD || !nitems) &&
	    (cur->fts_level == FTS_ROOTLEVEL ? FCHDIR(sp, sp->fts_rfd) :
	    fts_safe_changedir(sp, cur->fts_parent, -1, ".."))) {
		cur->fts_info = FTS_ERR;
		SET(FTS_STOP);
		return (NULL);
	}

	/* If didn't find anything, return NULL. */
	if (!nitems) {
		if (type == BREAD)
			cur->fts_info = FTS_DP;
		return (NULL);
	}

	/* Sort the entries. */
	if (sp->fts_compar && nitems > 1)
		head = fts_sort(sp, head, nitems);
	return (head);
}

static u_short
fts_stat(FTS *sp, FTSENT *p, int follow, int dfd)
{
	FTSENT *t;
	dev_t dev;
	ino_t ino;
	struct stat *sbp, sb;
	int saved_errno;
	const char *path;

	if (dfd == -1) {
		path = p->fts_accpath;
		dfd = AT_FDCWD;
	} else
		path = p->fts_name;

	/* If user needs stat info, stat buffer already allocated. */
	sbp = ISSET(FTS_NOSTAT) ? &sb : p->fts_statp;

	/*
	 * If doing a logical walk, or application requested FTS_FOLLOW, do
	 * a stat(2).  If that fails, check for a non-existent symlink.  If
	 * fail, set the errno from the stat call.
	 */
	if (ISSET(FTS_LOGICAL) || follow) {
		if (fstatat(dfd, path, sbp, 0)) {
			saved_errno = errno;
			if (!fstatat(dfd, path, sbp, AT_SYMLINK_NOFOLLOW)) {
				errno = 0;
				return (FTS_SLNONE);
			}
			p->fts_errno = saved_errno;
			goto err;
		}
	} else if (fstatat(dfd, path, sbp, AT_SYMLINK_NOFOLLOW)) {
		p->fts_errno = errno;
err:		memset(sbp, 0, sizeof(struct stat));
		return (FTS_NS);
	}

	if (S_ISDIR(sbp->st_mode)) {
		/*
		 * Set the device/inode.  Used to find cycles and check for
		 * crossing mount points.  Also remember the link count, used
		 * in fts_build to limit the number of stat calls.  It is
		 * understood that these fields are only referenced if fts_info
		 * is set to FTS_D.
		 */
		dev = p->fts_dev = sbp->st_dev;
		ino = p->fts_ino = sbp->st_ino;
		p->fts_nlink = sbp->st_nlink;

		if (ISDOT(p->fts_name))
			return (FTS_DOT);

		/*
		 * Cycle detection is done by brute force when the directory
		 * is first encountered.  If the tree gets deep enough or the
		 * number of symbolic links to directories is high enough,
		 * something faster might be worthwhile.
		 */
		for (t = p->fts_parent;
		    t->fts_level >= FTS_ROOTLEVEL; t = t->fts_parent)
			if (ino == t->fts_ino && dev == t->fts_dev) {
				p->fts_cycle = t;
				return (FTS_DC);
			}
		return (FTS_D);
	}
	if (S_ISLNK(sbp->st_mode))
		return (FTS_SL);
	if (S_ISREG(sbp->st_mode))
		return (FTS_F);
	return (FTS_DEFAULT);
}

static FTSENT *
fts_sort(FTS *sp, FTSENT *head, int nitems)
{
	FTSENT **ap, *p;

	/*
	 * Construct an array of pointers to the structures and call qsort(3).
	 * Reassemble the array in the order returned by qsort.  If unable to
	 * sort for memory reasons, return the directory entries in their
	 * current order.  Allocate enough space for the current needs plus
	 * 40 so don't realloc one entry at a time.
	 */
	if (nitems > sp->fts_nitems) {
		struct _ftsent **a;

		if ((a = reallocarray(sp->fts_array,
		    nitems + 40, sizeof(FTSENT *))) == NULL) {
			free(sp->fts_array);
			sp->fts_array = NULL;
			sp->fts_nitems = 0;
			return (head);
		}
		sp->fts_nitems = nitems + 40;
		sp->fts_array = a;
	}
	for (ap = sp->fts_array, p = head; p; p = p->fts_link)
		*ap++ = p;
	qsort(sp->fts_array, nitems, sizeof(FTSENT *), sp->fts_compar);
	for (head = *(ap = sp->fts_array); --nitems; ++ap)
		ap[0]->fts_link = ap[1];
	ap[0]->fts_link = NULL;
	return (head);
}

static FTSENT *
fts_alloc(FTS *sp, char *name, size_t namelen)
{
	FTSENT *p;
	size_t len;

	/*
	 * The file name is a variable length array and no stat structure is
	 * necessary if the user has set the nostat bit.  Allocate the FTSENT
	 * structure, the file name and the stat structure in one chunk, but
	 * be careful that the stat structure is reasonably aligned.  Since the
	 * fts_name field is declared to be of size 1, the fts_name pointer is
	 * namelen + 2 before the first possible address of the stat structure.
	 */
	len = sizeof(FTSENT) + namelen;
	if (!ISSET(FTS_NOSTAT))
		len += sizeof(struct stat) + ALIGNBYTES;
	if ((p = calloc(1, len)) == NULL)
		return (NULL);

	p->fts_path = sp->fts_path;
	p->fts_namelen = namelen;
	p->fts_instr = FTS_NOINSTR;
	if (!ISSET(FTS_NOSTAT))
		p->fts_statp = (struct stat *)ALIGN(p->fts_name + namelen + 2);
	memcpy(p->fts_name, name, namelen);

	return (p);
}

static void
fts_lfree(FTSENT *head)
{
	FTSENT *p;

	/* Free a linked list of structures. */
	while ((p = head)) {
		head = head->fts_link;
		free(p);
	}
}

/*
 * Allow essentially unlimited paths; find, rm, ls should all work on any tree.
 * Most systems will allow creation of paths much longer than PATH_MAX, even
 * though the kernel won't resolve them.  Add the size (not just what's needed)
 * plus 256 bytes so don't realloc the path 2 bytes at a time.
 */
static int
fts_palloc(FTS *sp, size_t more)
{
	char *p;

	/*
	 * Check for possible wraparound.
	 */
	more += 256;
	if (sp->fts_pathlen + more < sp->fts_pathlen) {
		free(sp->fts_path);
		sp->fts_path = NULL;
		errno = ENAMETOOLONG;
		return (1);
	}
	p = recallocarray(sp->fts_path, sp->fts_pathlen,
	    sp->fts_pathlen + more, 1);
	if (p == NULL) {
		free(sp->fts_path);
		sp->fts_path = NULL;
		return (1);
	}
	sp->fts_pathlen += more;
	sp->fts_path = p;
	return (0);
}

/*
 * When the path is realloc'd, have to fix all of the pointers in structures
 * already returned.
 */
static void
fts_padjust(FTS *sp, FTSENT *head)
{
	FTSENT *p;
	char *addr = sp->fts_path;

#define	ADJUST(p) {							\
	if ((p)->fts_accpath != (p)->fts_name) {			\
		(p)->fts_accpath =					\
		    (char *)addr + ((p)->fts_accpath - (p)->fts_path);	\
	}								\
	(p)->fts_path = addr;						\
}
	/* Adjust the current set of children. */
	for (p = sp->fts_child; p; p = p->fts_link)
		ADJUST(p);

	/* Adjust the rest of the tree, including the current level. */
	for (p = head; p->fts_level >= FTS_ROOTLEVEL;) {
		ADJUST(p);
		p = p->fts_link ? p->fts_link : p->fts_parent;
	}
}

static size_t
fts_maxarglen(char * const *argv)
{
	size_t len, max;

	for (max = 0; *argv; ++argv)
		if ((len = strlen(*argv)) > max)
			max = len;
	return (max + 1);
}

/*
 * Change to dir specified by fd or p->fts_accpath without getting
 * tricked by someone changing the world out from underneath us.
 * Assumes p->fts_dev and p->fts_ino are filled in.
 */
static int
fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char *path)
{
	int ret, oerrno, newfd;
	struct stat sb;

	newfd = fd;
	if (ISSET(FTS_NOCHDIR))
		return (0);
	if (fd < 0 && (newfd = open(path, O_RDONLY|O_DIRECTORY|O_CLOEXEC)) < 0)
		return (-1);
	if (fstat(newfd, &sb)) {
		ret = -1;
		goto bail;
	}
	if (p->fts_dev != sb.st_dev || p->fts_ino != sb.st_ino) {
		errno = ENOENT;		/* disinformation */
		ret = -1;
		goto bail;
	}
	ret = fchdir(newfd);
bail:
	oerrno = errno;
	if (fd < 0)
		(void)close(newfd);
	errno = oerrno;
	return (ret);
}
@


1.57
log
@Style improvement, no functional change.

As reported by Yuri Pankov, some versions of GCC whine that "tmp"
might be used uninitialized in fts_open(3).  Clearly, that cannot
actually happen, but explicitly setting it to NULL is safer anyway.
While here, rename the badly named variable "tmp" and make the
inner "if" easier to understand.

Feedback and OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.56 2016/09/21 04:38:56 guenther Exp $	*/
a883 1
		sp->fts_nitems = nitems + 40;
d885 1
a885 1
		    sp->fts_nitems, sizeof(FTSENT *))) == NULL) {
d891 1
d966 2
a967 2
	sp->fts_pathlen += more;
	p = realloc(sp->fts_path, sp->fts_pathlen);
d973 1
@


1.56
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.55 2016/06/28 17:21:48 millert Exp $	*/
d77 1
a77 1
	FTSENT *parent, *tmp;
d114 1
a114 1
	for (root = NULL, nitems = 0; *argv; ++argv, ++nitems) {
d136 4
a139 5
				tmp = root = p;
			else {
				tmp->fts_link = p;
				tmp = p;
			}
@


1.55
log
@fts_open() requires that the list passed as argument to contain at least
one path.  When the list is empty (contain only a NULL pointer), return
EINVAL instead of pretending to succeed, which will cause a NULL pointer
deference in a later fts_read() call.  From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.54 2016/06/28 17:12:29 millert Exp $	*/
d657 1
a657 1
		if (!(p = fts_alloc(sp, dp->d_name, (size_t)dp->d_namlen)))
d897 1
a897 1
	qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), sp->fts_compar);
@


1.54
log
@Do not return an error in fts_open(3) if one of the paths in argv
is empty.  Otherwise, programs using fts(3) will report an error
if one of the paths is empty instead of just treating it as a
non-existent file.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.53 2015/11/01 03:45:29 guenther Exp $	*/
d81 6
@


1.53
log
@delete old lint ARGSUSED comments
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.52 2015/09/14 16:09:13 tedu Exp $	*/
a77 1
	size_t len;
d109 1
a109 7
		/* Don't allow zero-length paths. */
		if ((len = strlen(*argv)) == 0) {
			errno = ENOENT;
			goto mem3;
		}

		if ((p = fts_alloc(sp, *argv, len)) == NULL)
@


1.52
log
@remove null check before free. from Michael McConville
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.51 2015/09/12 13:32:24 guenther Exp $	*/
a451 1
/* ARGSUSED */
@


1.51
log
@Wrap <fts.h> and <ftw.h> so that internal calls to fts_*() go direct and
fts_*(), ftw(), and nftw() are weak symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.50 2015/01/16 16:48:51 deraadt Exp $	*/
d231 1
a231 2
	if (sp->fts_array)
		free(sp->fts_array);
d670 1
a670 2
				if (p)
					free(p);
d890 1
a890 2
			if (sp->fts_array)
				free(sp->fts_array);
d964 1
a964 2
		if (sp->fts_path)
			free(sp->fts_path);
d972 1
a972 2
		if (sp->fts_path)
			free(sp->fts_path);
@


1.50
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.49 2014/11/23 00:14:22 guenther Exp $	*/
d179 1
d247 1
d445 1
d465 1
d534 1
@


1.49
log
@Merge from FreeBSD:
------------------------------------------------------------------------
r246641 | jilles | 2013-02-10 15:09:15 -0800 (Sun, 10 Feb 2013) | 8 lines

fts: Use O_DIRECTORY when opening name that might be changed by attacker.

There are uncommon cases where fts_safe_changedir() may be called with a
non-NULL name that is not "..". Do not block or worse if an attacker put (a
(symlink to) a fifo or device where a directory used to be.

MFC after:      1 week

------------------------------------------------------------------------
r241010 | jilles | 2012-09-27 15:05:54 -0700 (Thu, 27 Sep 2012) | 9 lines

libc/fts: Use O_CLOEXEC for internal file descriptors.

Because fts keeps internal file descriptors open across calls, making such
descriptors close-on-exec helps not only multi-threaded applications but
also single-threaded applications.

In particular, this prevents passing a temporary file descriptor for saving
the current directory to processes created via find -exec.

------------------------------------------------------------------------

ports scan for possible O_CLOEXEC affected programs by sthen@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.48 2014/11/20 04:14:15 guenther Exp $	*/
d32 1
a32 1
#include <sys/param.h>
d44 2
d100 1
a100 1
	if (fts_palloc(sp, MAX(fts_maxarglen(argv), PATH_MAX)))
@


1.48
log
@Merge from FreeBSD:
--------
r260571 | jilles | 2014-01-12 12:30:55 -0800 (Sun, 12 Jan 2014) | 9 lines

fts: Stat things relative to the directory fd, if possible.

As a result, the kernel needs to process shorter pathnames if fts is not
changing directories (if fts follows symlinks (-L option to utilities), fts
cannot open "." or FTS_NOCHDIR was specified).

Side effect: If pathnames exceed PATH_MAX, [ENAMETOOLONG] is not hit at the
stat stage but later (opendir or application fts_accpath) or not at all.
--------

Prompted by a similar diff from (enh (at) google.com), who also reran a
performance test.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.47 2014/10/08 04:36:23 deraadt Exp $	*/
d162 2
a163 1
	if (!ISSET(FTS_NOCHDIR) && (sp->fts_rfd = open(".", O_RDONLY, 0)) < 0)
d288 2
a289 1
			if ((p->fts_symfd = open(".", O_RDONLY, 0)) < 0) {
d379 1
a379 1
				    open(".", O_RDONLY, 0)) < 0) {
d518 1
a518 1
	if ((fd = open(".", O_RDONLY, 0)) < 0)
d1031 1
a1031 1
	if (fd < 0 && (newfd = open(path, O_RDONLY, 0)) < 0)
@


1.47
log
@reallocarray() for mult int overflow detect; ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.46 2014/05/25 17:47:04 tedu Exp $	*/
d52 1
a52 1
static u_short	 fts_stat(FTS *, FTSENT *, int);
d119 1
a119 1
		p->fts_info = fts_stat(sp, p, ISSET(FTS_COMFOLLOW));
d273 1
a273 1
		p->fts_info = fts_stat(sp, p, 0);
d285 1
a285 1
		p->fts_info = fts_stat(sp, p, 1);
d374 1
a374 1
			p->fts_info = fts_stat(sp, p, 1);
d719 2
a720 1
			} else
d722 2
a723 2
			/* Stat it. */
			p->fts_info = fts_stat(sp, p, 0);
d790 1
a790 1
fts_stat(FTS *sp, FTSENT *p, int follow)
d797 7
d814 1
a814 1
		if (stat(p->fts_accpath, sbp)) {
d816 1
a816 1
			if (!lstat(p->fts_accpath, sbp)) {
d823 1
a823 1
	} else if (lstat(p->fts_accpath, sbp)) {
@


1.46
log
@use calloc, from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.45 2013/09/30 12:02:33 millert Exp $	*/
d873 2
a874 2
		if ((a = realloc(sp->fts_array,
		    sp->fts_nitems * sizeof(FTSENT *))) == NULL) {
@


1.45
log
@Use PATH_MAX, NAME_MAX and LOGIN_NAME_MAX not MAXPATHNAMELEN,
MAXNAMLEN or MAXLOGNAME where possible.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.44 2010/09/24 13:56:32 millert Exp $	*/
d909 1
a909 1
	if ((p = malloc(len)) == NULL)
a911 1
	memset(p, 0, len);
@


1.44
log
@Bump fts_level from short to int and add a spare short so things
line up nicely.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.43 2009/08/27 16:19:27 millert Exp $	*/
d39 1
d98 1
a98 1
	if (fts_palloc(sp, MAX(fts_maxarglen(argv), MAXPATHLEN)))
d937 1
a937 1
 * Most systems will allow creation of paths much longer than MAXPATHLEN, even
@


1.43
log
@Don't stop traversing a directory hierarchy if we reach SHRT_MAX,
just stop updating fts_level so we don't overflow it.  This allows
rm, find, etc to operate on very deep hierarchies.  Consumers of
fts(3) do need to be aware that the actual level may be larger
than fts_level.  During the next libc major bump we will make
fts_level an int instead of a short.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.42 2009/02/11 13:24:05 otto Exp $	*/
d637 1
a637 1
	 * fts_level is a short so we must prevent it from wrapping
@


1.42
log
@Avoid level going negative on deep (i mean really deep) dirs. Reported
by Maksymilian Arciemowicz. ok kettenis@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.41 2008/12/27 12:30:13 pedro Exp $	*/
d636 7
a642 9
	if (cur->fts_level == SHRT_MAX) {
		(void)closedir(dirp);
		cur->fts_info = FTS_ERR;
		SET(FTS_STOP);
		errno = ENAMETOOLONG;
		return (NULL);
	}

	level = cur->fts_level + 1;
@


1.41
log
@Fix file descriptor leak in fts_children(); okay dhill@@, millert@@,
tedu@@, thib@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.40 2007/11/06 10:14:53 chl Exp $	*/
d635 8
@


1.40
log
@malloc/memset -> calloc

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.39 2007/11/02 20:32:57 millert Exp $	*/
d518 2
a519 1
	if (fchdir(fd))
d521 1
@


1.39
log
@Simplify some of the logic in fts_close().  Initially based on a
diff from chl@@.  OK otto@@ and chl@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.38 2007/01/08 09:13:38 otto Exp $	*/
d84 1
a84 1
	if ((sp = malloc(sizeof(FTS))) == NULL)
a85 1
	memset(sp, 0, sizeof(FTS));
@


1.38
log
@fix mem leak, from NetBSD; ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.37 2005/08/08 08:05:34 espie Exp $	*/
d205 1
a205 1
	int saved_errno = 0;
d221 4
a224 1
	/* Free up child linked list, sort array, path buffer. */
d230 1
d232 6
a237 10
	/* Return to original directory, save errno if necessary. */
	if (!ISSET(FTS_NOCHDIR)) {
		saved_errno = fchdir(sp->fts_rfd) ? errno : 0;
		(void)close(sp->fts_rfd);
	}

	/* Set errno and return. */
	if (!ISSET(FTS_NOCHDIR) && saved_errno) {
		/* Free up the stream pointer. */
		free(sp);
a238 1
		return (-1);
d241 1
a241 3
	/* Free up the stream pointer. */
	free(sp);
	return (0);
@


1.37
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.36 2005/06/17 20:36:55 millert Exp $	*/
d164 3
@


1.36
log
@bye bye whiteouts
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.35 2005/06/16 03:01:25 millert Exp $	*/
a30 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)fts.c	8.6 (Berkeley) 8/14/94";
#else
static char rcsid[] = "$OpenBSD: fts.c,v 1.35 2005/06/16 03:01:25 millert Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.35
log
@bye bye whiteouts
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.34 2003/06/11 21:03:10 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.34 2003/06/11 21:03:10 deraadt Exp $";
a697 5
#ifdef FTS_WHITEOUT
		if (dp->d_type == DT_WHT)
			p->fts_flags |= FTS_ISW;
#endif

a798 11

#ifdef FTS_WHITEOUT
	/* check for whiteout */
	if (p->fts_flags & FTS_ISW) {
		if (sbp != &sb) {
			memset(sbp, '\0', sizeof (*sbp));
			sbp->st_mode = S_IFWHT;
		}
		return (FTS_W);
	}
#endif
@


1.34
log
@ansification; checked by pval
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.33 2003/06/02 20:18:34 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.33 2003/06/02 20:18:34 millert Exp $";
d556 1
a556 1
	int nitems, cderrno, descend, level, nlinks, oflag, nostat, doadjust;
d567 1
a567 9
#ifdef FTS_WHITEOUT
	if (ISSET(FTS_WHITEOUT))
		oflag = DTF_NODUP|DTF_REWIND;
	else
		oflag = DTF_HIDEW|DTF_NODUP|DTF_REWIND;
#else
#define __opendir2(path, flag) opendir(path)
#endif
	if ((dirp = __opendir2(cur->fts_accpath, oflag)) == NULL) {
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.32 2002/07/12 01:47:41 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.32 2002/07/12 01:47:41 millert Exp $";
d76 2
a77 4
fts_open(argv, options, compar)
	char * const *argv;
	int options;
	int (*compar)(const FTSENT **, const FTSENT **);
d183 1
a183 3
fts_load(sp, p)
	FTS *sp;
	FTSENT *p;
d207 1
a207 2
fts_close(sp)
	FTS *sp;
d261 1
a261 2
fts_read(sp)
	FTS *sp;
d456 1
a456 4
fts_set(sp, p, instr)
	FTS *sp;
	FTSENT *p;
	int instr;
d468 1
a468 3
fts_children(sp, instr)
	FTS *sp;
	int instr;
d548 1
a548 3
fts_build(sp, type)
	FTS *sp;
	int type;
d802 1
a802 4
fts_stat(sp, p, follow)
	FTS *sp;
	FTSENT *p;
	int follow;
d882 1
a882 4
fts_sort(sp, head, nitems)
	FTS *sp;
	FTSENT *head;
	int nitems;
d917 1
a917 4
fts_alloc(sp, name, namelen)
	FTS *sp;
	char *name;
	size_t namelen;
d948 1
a948 2
fts_lfree(head)
	FTSENT *head;
d966 1
a966 3
fts_palloc(sp, more)
	FTS *sp;
	size_t more;
d998 1
a998 3
fts_padjust(sp, head)
	FTS *sp;
	FTSENT *head;
d1022 1
a1022 2
fts_maxarglen(argv)
	char * const *argv;
d1038 1
a1038 5
fts_safe_changedir(sp, p, fd, path)
	FTS *sp;
	FTSENT *p;
	int fd;
	char *path;
@


1.32
log
@Add a missing check for fts_alloc() returning NULL; Chad Loder
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.31 2002/06/27 22:21:28 deraadt Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.31 2002/06/27 22:21:28 deraadt Exp $";
@


1.31
log
@%u
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.30 2002/02/16 21:27:22 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.30 2002/02/16 21:27:22 millert Exp $";
d128 2
a129 1
		p = fts_alloc(sp, *argv, len);
@


1.30
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.29 2001/08/27 21:42:06 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.29 2001/08/27 21:42:06 millert Exp $";
d615 1
a615 1
	(void)printf("nlinks == %d (cur: %d)\n", nlinks, cur->fts_nlink);
@


1.29
log
@Zero out entire FTS after allocating it instead of just zeroing out
a few fields by hand; Closes PR 2033
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.28 2001/08/03 22:23:48 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.28 2001/08/03 22:23:48 millert Exp $";
d55 10
a64 10
static FTSENT	*fts_alloc __P((FTS *, char *, size_t));
static FTSENT	*fts_build __P((FTS *, int));
static void	 fts_lfree __P((FTSENT *));
static void	 fts_load __P((FTS *, FTSENT *));
static size_t	 fts_maxarglen __P((char * const *));
static void	 fts_padjust __P((FTS *, FTSENT *));
static int	 fts_palloc __P((FTS *, size_t));
static FTSENT	*fts_sort __P((FTS *, FTSENT *, int));
static u_short	 fts_stat __P((FTS *, FTSENT *, int));
static int	 fts_safe_changedir __P((FTS *, FTSENT *, int, char *));
d83 1
a83 1
	int (*compar) __P((const FTSENT **, const FTSENT **));
@


1.28
log
@Update sp->fts_cur in fts_read() before returning NULL.  This
prevents a duplicate free() in fts_close().  From karls@@inet.no
with some other, similar cases added.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.27 2001/05/31 23:30:48 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.27 2001/05/31 23:30:48 millert Exp $";
d98 1
a98 1
	if ((sp = malloc((u_int)sizeof(FTS))) == NULL)
d961 4
a964 4
	/* Copy the name and guarantee NUL termination. */
	memmove(p->fts_name, name, namelen);
	p->fts_name[namelen] = '\0';

d967 2
a968 7
	p->fts_namelen = namelen;
	p->fts_path = sp->fts_path;
	p->fts_errno = 0;
	p->fts_flags = 0;
	p->fts_instr = FTS_NOINSTR;
	p->fts_number = 0;
	p->fts_pointer = NULL;
@


1.27
log
@Fix another case of CHDIR("..") pointed out by Bruce Evans
<bde@@zeta.org.au>.  Instead of fixing these inline I've modified
my fts_safe_changedir() function so it can be used in this case
too.  Thanks also to Kris Kennaway <kris@@obsecurity.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.26 2001/05/30 20:40:30 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.26 2001/05/30 20:40:30 millert Exp $";
d434 1
d443 1
d450 1
@


1.26
log
@When changing directory to '..', verify that we really are where
we should be.  This is similar to the old fts bug but happens when
popping out of directories, as opposed to descending into them.
Patch based on one by Kris Kennaway <kris@@obsecurity.org>.
Issue reported by Nick Cleaton <nick@@cleaton.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.25 2001/05/15 21:14:39 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.25 2001/05/15 21:14:39 millert Exp $";
d64 1
a64 1
static int	 fts_safe_changedir __P((FTS *, FTSENT *, int));
a71 1
#define	CHDIR(sp, path)	(!ISSET(FTS_NOCHDIR) && chdir(path))
a272 1
	struct stat sb;
d348 1
a348 1
			if (fts_safe_changedir(sp, p, -1)) {
d445 4
a448 11
	} else if (!(p->fts_flags & FTS_DONTCHDIR) && !ISSET(FTS_NOCHDIR)) {
		if (chdir("..") || stat(".", &sb)) {
			SET(FTS_STOP);
			return (NULL);
		}
		if (sb.st_ino != p->fts_parent->fts_ino ||
		    sb.st_dev != p->fts_parent->fts_dev) {
			errno = ENOENT;
			SET(FTS_STOP);
			return (NULL);
		}
d633 1
a633 1
		if (fts_safe_changedir(sp, cur, dirfd(dirp))) {
d794 2
a795 2
	    (cur->fts_level == FTS_ROOTLEVEL ?
	    FCHDIR(sp, sp->fts_rfd) : CHDIR(sp, ".."))) {
d1071 1
a1071 1
fts_safe_changedir(sp, p, fd)
d1075 1
d1083 1
a1083 1
	if (fd < 0 && (newfd = open(p->fts_accpath, O_RDONLY, 0)) < 0)
@


1.25
log
@Make path length variables size_t.  This fixes the problem where
things like rm can't remove files with ridiculously long path names
that were created by some script kiddie trying in vain to exploit
something.  Previously, the length was effectively constrained to
USHRT_MAX due to one of the internal structs.  Also, nuke FTS_CHDIRROOT
since it never worked correctly and hasn't been documented for a
long time.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.24 2000/08/24 17:04:12 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.24 2000/08/24 17:04:12 deraadt Exp $";
d274 1
d447 8
a454 2
	} else if (!(p->fts_flags & FTS_DONTCHDIR)) {
		if (CHDIR(sp, "..")) {
@


1.24
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.23 1999/10/03 20:39:53 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.23 1999/10/03 20:39:53 millert Exp $";
d55 1
a55 1
static FTSENT	*fts_alloc __P((FTS *, char *, int));
d83 1
a83 1
	register int options;
d86 3
a88 3
	register FTS *sp;
	register FTSENT *p, *root;
	register int nitems;
d90 1
a90 1
	int len;
d191 1
a191 1
	register FTSENT *p;
d193 2
a194 2
	register int len;
	register char *cp;
d218 1
a218 1
	register FTSENT *freep, *p;
d271 1
a271 1
	register FTS *sp;
d273 3
a275 3
	register FTSENT *p, *tmp;
	register int instr;
	register char *t;
d376 3
a378 10
			if ((sp->fts_options & FTS_CHDIRROOT)) {
				if (chdir(p->fts_accpath)) {
					SET(FTS_STOP);
					return (NULL);
				}
			} else {
				if (FCHDIR(sp, sp->fts_rfd)) {
					SET(FTS_STOP);
					return (NULL);
				}
d433 3
a435 10
		if ((sp->fts_options & FTS_CHDIRROOT)) {
			if (chdir(p->fts_accpath)) {
				SET(FTS_STOP);
				return (NULL);
			}
		} else {
			if (FCHDIR(sp, sp->fts_rfd)) {
				SET(FTS_STOP);
				return (NULL);
			}
d480 1
a480 1
	register FTS *sp;
d483 1
a483 1
	register FTSENT *p;
d562 1
a562 1
	register FTS *sp;
d565 2
a566 3
	register struct dirent *dp;
	register FTSENT *p, *head;
	register int nitems;
d570 3
a572 2
	int cderrno, descend, len, level, maxlen, nlinks, oflag, saved_errno,
	    nostat, doadjust;
d674 1
a674 1
		if ((p = fts_alloc(sp, dp->d_name, (int)dp->d_namlen)) == NULL)
d703 4
a706 1
		if (len + dp->d_namlen >= USHRT_MAX) {
d708 3
a710 4
			 * In an FTSENT, fts_pathlen is a u_short so it is
			 * possible to wraparound here.  If we do, free up
			 * the current structure and the structures already
			 * allocated, then error out with ENAMETOOLONG.
a719 3
		p->fts_level = level;
		p->fts_parent = sp->fts_cur;
		p->fts_pathlen = len + dp->d_namlen;
d819 1
a819 1
	register FTSENT *p;
d822 3
a824 3
	register FTSENT *t;
	register dev_t dev;
	register ino_t ino;
d903 1
a903 1
	register int nitems;
d905 1
a905 1
	register FTSENT **ap, *p;
d941 1
a941 1
	register int namelen;
d943 1
a943 1
	register FTSENT *p;
d978 1
a978 1
	register FTSENT *head;
d980 1
a980 1
	register FTSENT *p;
a1001 1
	sp->fts_pathlen += more + 256;
d1003 1
a1003 3
	 * Check for possible wraparound.  In an FTS, fts_pathlen is
	 * a signed int but in an FTSENT it is an unsigned short.
	 * We limit fts_pathlen to USHRT_MAX to be safe in both cases.
d1005 2
a1006 1
	if (sp->fts_pathlen < 0 || sp->fts_pathlen >= USHRT_MAX) {
d1013 1
@


1.24.2.1
log
@Pull in patch from current:
Errata(029):
Programs using the fts(3) routines (such as rm, find, and most programs
that take a -R flag) can be tricked into changing into the wrong
directory if the parent dir is changed out from underneath it.  This is
similar to the old fts bug but happens when popping out of directories,
as opposed to descending into them.
Fix(millert):
When changing directory to '..', verify that we really are where
we should be.  This is similar to the old fts bug but happens when
popping out of directories, as opposed to descending into them.
Patch based on one by Kris Kennaway <kris@@obsecurity.org>.
Issue reported by Nick Cleaton <nick@@cleaton.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.24 2000/08/24 17:04:12 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.24 2000/08/24 17:04:12 deraadt Exp $";
a273 1
	struct stat sb;
d460 2
a461 8
	} else if (!(p->fts_flags & FTS_DONTCHDIR) && !ISSET(FTS_NOCHDIR)) {
		if (chdir("..") || stat(".", &sb)) {
			SET(FTS_STOP);
			return (NULL);
		}
		if (sb.st_ino != p->fts_parent->fts_ino ||
		    sb.st_dev != p->fts_parent->fts_dev) {
			errno = ENOENT;
@


1.24.2.2
log
@Pull in patch from current:
Errata 029, improved fix(millert):
Fix another case of CHDIR("..") pointed out by Bruce Evans
<bde@@zeta.org.au>.  Instead of fixing these inline I've modified
my fts_safe_changedir() function so it can be used in this case
too.  Thanks also to Kris Kennaway <kris@@obsecurity.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.24.2.1 2001/05/31 21:09:24 miod Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.24.2.1 2001/05/31 21:09:24 miod Exp $";
d64 1
a64 1
static int	 fts_safe_changedir __P((FTS *, FTSENT *, int, char *));
d72 1
d274 1
d350 1
a350 1
			if (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {
d461 11
a471 4
	} else if (!(p->fts_flags & FTS_DONTCHDIR) &&
	    fts_safe_changedir(sp, p->fts_parent, -1, "..")) {
		SET(FTS_STOP);
		return (NULL);
d656 1
a656 1
		if (fts_safe_changedir(sp, cur, dirfd(dirp), NULL)) {
d818 2
a819 2
	    (cur->fts_level == FTS_ROOTLEVEL ? FCHDIR(sp, sp->fts_rfd) :
	    fts_safe_changedir(sp, cur->fts_parent, -1, ".."))) {
d1096 1
a1096 1
fts_safe_changedir(sp, p, fd, path)
a1099 1
	char *path;
d1107 1
a1107 1
	if (fd < 0 && (newfd = open(path, O_RDONLY, 0)) < 0)
@


1.24.4.1
log
@Pull in patch from current:
Errata 002:
Programs using the fts(3) routines (such as rm, find, and most programs that
take a -R flag) can be tricked into changing into the wrong directory if the
parent dir is changed out from underneath it. This is similar to the old fts
bug but happens when popping out of directories, as opposed to descending
into them.
Fix (millert):
When changing directory to '..', verify that we really are where
we should be.  This is similar to the old fts bug but happens when
popping out of directories, as opposed to descending into them.
Patch based on one by Kris Kennaway <kris@@obsecurity.org>.
Issue reported by Nick Cleaton <nick@@cleaton.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.24 2000/08/24 17:04:12 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.24 2000/08/24 17:04:12 deraadt Exp $";
a273 1
	struct stat sb;
d460 2
a461 8
	} else if (!(p->fts_flags & FTS_DONTCHDIR) && !ISSET(FTS_NOCHDIR)) {
		if (chdir("..") || stat(".", &sb)) {
			SET(FTS_STOP);
			return (NULL);
		}
		if (sb.st_ino != p->fts_parent->fts_ino ||
		    sb.st_dev != p->fts_parent->fts_dev) {
			errno = ENOENT;
@


1.24.4.2
log
@Pull in patch from current:
Fix (millert), Errata 002:
Fix another case of CHDIR("..") pointed out by Bruce Evans
<bde@@zeta.org.au>.  Instead of fixing these inline I've modified
my fts_safe_changedir() function so it can be used in this case
too.  Thanks also to Kris Kennaway <kris@@obsecurity.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.24.4.1 2001/05/31 02:20:29 jason Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.24.4.1 2001/05/31 02:20:29 jason Exp $";
d64 1
a64 1
static int	 fts_safe_changedir __P((FTS *, FTSENT *, int, char *));
d72 1
d274 1
d350 1
a350 1
			if (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {
d461 11
a471 4
	} else if (!(p->fts_flags & FTS_DONTCHDIR) &&
	    fts_safe_changedir(sp, p->fts_parent, -1, "..")) {
		SET(FTS_STOP);
		return (NULL);
d656 1
a656 1
		if (fts_safe_changedir(sp, cur, dirfd(dirp), NULL)) {
d818 2
a819 2
	    (cur->fts_level == FTS_ROOTLEVEL ? FCHDIR(sp, sp->fts_rfd) :
	    fts_safe_changedir(sp, cur->fts_parent, -1, ".."))) {
d1096 1
a1096 1
fts_safe_changedir(sp, p, fd, path)
a1099 1
	char *path;
d1107 1
a1107 1
	if (fd < 0 && (newfd = open(path, O_RDONLY, 0)) < 0)
@


1.23
log
@put back FTS_CHDIRROOT until next library major number crank
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.21 1999/10/03 19:17:31 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.21 1999/10/03 19:17:31 millert Exp $";
d219 1
a219 1
	int saved_errno;
@


1.22
log
@kill FTS_CHDIRROOT flag, it is broken beyond repair and no longer used
@
text
@d376 10
a385 3
			if (FCHDIR(sp, sp->fts_rfd)) {
				SET(FTS_STOP);
				return (NULL);
d440 10
a449 3
		if (FCHDIR(sp, sp->fts_rfd)) {
			SET(FTS_STOP);
			return (NULL);
@


1.21
log
@Fix multiple problems in the FTS_NOCHDIR case (mycroft@@netbsd.org):
* There was an off-by-one error that caused the addition of a NUL or slash
  in fts_build() to overwrite other memory.
* After fts_palloc(), we need to reset `cp' so that it points to the new
  path name buffer; otherwise the addition of the file name before calling
  fts_stat() could lose.  Also, fix stupidity in the fts_palloc() interface.
  We don't want N bytes more than the current buffer size; we want N bytes
  more than the current length.  Just pass in the new size, since we can't
  figure it out easily here.

fts_padjust() was doing more work than it needed to.  Based on changes
from mycroft@@netbsd.org.

Check for fts_pathlen oflow in two places.  Done before I saw the NetBSD
change (and last I checked they only did one of the checks).  In the
case of wrap, return ENAMETOOLONG.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.20 1999/08/16 07:57:02 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.20 1999/08/16 07:57:02 millert Exp $";
d376 3
a378 10
			if ((sp->fts_options & FTS_CHDIRROOT)) {
				if (chdir(p->fts_accpath)) {
					SET(FTS_STOP);
					return (NULL);
				}
			} else {
				if (FCHDIR(sp, sp->fts_rfd)) {
					SET(FTS_STOP);
					return (NULL);
				}
d433 3
a435 10
		if ((sp->fts_options & FTS_CHDIRROOT)) {
			if (chdir(p->fts_accpath)) {
				SET(FTS_STOP);
				return (NULL);
			}
		} else {
			if (FCHDIR(sp, sp->fts_rfd)) {
				SET(FTS_STOP);
				return (NULL);
			}
@


1.20
log
@If the FTS_NOCHDIR flag is set and the final directory is empty,
the trailing '/' would not be chopped; pho@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.19 1999/05/17 02:32:31 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.19 1999/05/17 02:32:31 millert Exp $";
a671 1
	maxlen = sp->fts_pathlen - cur->fts_pathlen - 1;
d677 2
d690 1
a690 1
		if (dp->d_namlen > maxlen) {
d692 1
a692 1
			if (fts_palloc(sp, (size_t)dp->d_namlen)) {
a702 1
				errno = saved_errno;
d705 1
d709 1
a709 1
			if (oldaddr != sp->fts_path)
d711 4
a714 1
			maxlen = sp->fts_pathlen - sp->fts_cur->fts_pathlen - 1;
d717 16
a732 1
		p->fts_pathlen = len + dp->d_namlen + 1;
d734 1
a734 1
		p->fts_level = level;
d934 1
a934 1
		    (size_t)(sp->fts_nitems * sizeof(FTSENT *)))) == NULL) {
d1018 13
a1030 1
	p = realloc(sp->fts_path, (size_t)sp->fts_pathlen);
d1051 1
a1051 1
	void *addr = sp->fts_path;
d1064 2
a1065 2
	/* Adjust the rest of the tree. */
	for (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;) {
a1068 6

	/* Adjust entries in the dir list as needed */
	for (p = head; p; p = p->fts_link) {
		if (p->fts_path != addr)
			ADJUST(p);
	}
d1080 1
a1080 1
	return (max);
@


1.19
log
@1) Only do pointer adjusting if realloc() changed our pointer
2) Only adjust pointers based on ftp_path, not fts_name.
3) Adjust the entries in the file list, as well as the trees, if
   needed.
Loosely based on a patch from Stas Kisel <stas@@SONET.CRIMEA.UA>
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.18 1998/08/15 08:10:15 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.18 1998/08/15 08:10:15 deraadt Exp $";
d779 1
a779 1
		if (len == sp->fts_pathlen)
@


1.18
log
@fix realloc patch
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.17 1998/08/14 21:39:24 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.17 1998/08/14 21:39:24 deraadt Exp $";
d60 1
a60 1
static void	 fts_padjust __P((FTS *, void *));
d431 1
a431 1
	/* Nul terminate the pathname. */
d584 1
a584 1
	void *adjaddr;
d586 1
a586 1
	    nostat;
d682 1
a682 1
	adjaddr = NULL;
d690 1
d707 3
a709 1
			adjaddr = sp->fts_path;
d768 2
a769 2
	 * If had to realloc the path, adjust the addresses for the rest
	 * of the tree.
d771 2
a772 2
	if (adjaddr)
		fts_padjust(sp, adjaddr);
d956 1
a956 1
	/* Copy the name and guarantee NULL termination. */
d1015 1
a1015 1
fts_padjust(sp, addr)
d1017 1
a1017 1
	void *addr;
d1020 1
d1023 4
a1026 2
	(p)->fts_accpath =						\
	    (char *)addr + ((p)->fts_accpath - (p)->fts_path);		\
d1037 6
@


1.17
log
@realloc repair
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.16 1998/07/03 01:10:27 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.16 1998/07/03 01:10:27 deraadt Exp $";
d1001 1
a1001 1
		return (0);
d1004 1
a1004 1
	return (1);
@


1.16
log
@do not free() before last ref; kmayer@@freegate.com
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.15 1998/03/19 00:30:01 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.15 1998/03/19 00:30:01 millert Exp $";
d908 2
d911 1
a911 1
		if ((sp->fts_array = realloc(sp->fts_array,
d913 3
d919 1
d993 2
d996 9
a1004 2
	sp->fts_path = realloc(sp->fts_path, (size_t)sp->fts_pathlen);
	return (sp->fts_path == NULL);
@


1.15
log
@some -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.14 1997/10/11 04:04:40 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.14 1997/10/11 04:04:40 millert Exp $";
a247 3
	/* Free up the stream pointer. */
	free(sp);

d250 2
d255 3
@


1.14
log
@Replace my trailing slash removal with the one from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.13 1997/10/06 23:32:49 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.13 1997/10/06 23:32:49 millert Exp $";
d302 1
a302 1
		if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR))
d308 1
d398 1
a398 1
			if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR))
d405 1
d646 1
a646 1
	if (nlinks || type == BREAD)
d657 1
a657 1
	else
@


1.13
log
@Fix bug caused by trailing '/' stripping.  Didn't always guarantee NULL
termination.  Now we do.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.12 1997/09/20 17:33:45 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.12 1997/09/20 17:33:45 millert Exp $";
a89 1
	char *a;
a128 7
		/* Strip trailing '/' from paths */
		a = *argv + len - 1;
		while (a > *argv && *a == '/') {
			a--;
			len--;
		}

d772 1
a772 1
		if (cp - 1 > sp->fts_path)
@


1.12
log
@Strip trailing '/' from paths.  Noted by hermit@@cs.tu-berlin.de in
the form of an ls(1) bug and dm@@reeducation-labor.lcs.mit.edu in
the form of a cp(1) bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.11 1997/09/01 02:44:17 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.11 1997/09/01 02:44:17 millert Exp $";
d951 3
a953 2
	/* Copy the name plus the trailing NULL. */
	memmove(p->fts_name, name, namelen + 1);
@


1.11
log
@Fix problem with ``find -execdir'' not having the correct initial cwd.
Adds a new flag to fts(3).
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.10 1997/08/29 22:43:08 imp Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.10 1997/08/29 22:43:08 imp Exp $";
d90 1
d128 7
@


1.10
log
@Minor KNF changes to fts_safe_chdir and recent NetBSD code integration
as pointed out by Bruce Evans.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.9 1997/08/02 00:13:49 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.9 1997/08/02 00:13:49 millert Exp $";
d170 1
a170 1
	 * If using chdir(2), grab a file descriptor pointing to dot to insure
d369 2
a370 2
		 * If reached the top, return to the original directory, and
		 * load the paths for the next root.
d373 10
a382 3
			if (FCHDIR(sp, sp->fts_rfd)) {
				SET(FTS_STOP);
				return (NULL);
d436 10
a445 3
		if (FCHDIR(sp, sp->fts_rfd)) {
			SET(FTS_STOP);
			return (NULL);
@


1.9
log
@From NetBSD (phil):
-  Add args for compar() function decl.
-  Fix it so fts_* never adds a / to a path name when there is
   already a trailing /.  Fixes NetBSD PR 1495.
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.8 1997/07/23 21:09:05 kstailey Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.8 1997/07/23 21:09:05 kstailey Exp $";
d264 2
a265 2
	(p->fts_path[p->fts_pathlen-1] == '/'				\
	    ? p->fts_pathlen-1 : p->fts_pathlen)
d1023 1
a1023 1
	int ret, oerrno, newfd = fd;
d1026 1
a1028 1

a1030 1

a1034 1

a1039 1

a1040 1

a1042 1

d1044 1
a1044 2
		(void) close(newfd);

d1046 1
a1046 1
	return(ret);
@


1.8
log
@trailing blanks
@
text
@d1 1
a1 1
/*	$OpenBSD: fts.c,v 1.7 1997/03/24 02:54:15 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.7 1997/03/24 02:54:15 millert Exp $";
d84 1
a84 1
	int (*compar)();
d260 2
a261 2
 * Special case a root of "/" so that slashes aren't appended which would
 * cause paths to be written as "//foo".
d264 2
a265 2
	(p->fts_level == FTS_ROOTLEVEL && p->fts_pathlen == 1 &&	\
	    p->fts_path[0] == '/' ? 0 : p->fts_pathlen)
@


1.7
log
@Make sure head, tail, and nitems get zero'd even if we
can't cd to the target dir.  Fixes rogue pointer problem
introduced with safe chdir changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.6 1997/01/17 06:12:53 millert Exp $";
d324 1
a324 1
		} 
d519 1
a519 1
	} else 
d710 1
a710 1
		    || (nostat && 
d828 1
a828 1
			} 
d961 1
a961 1
 * plus 256 bytes so don't realloc the path 2 bytes at a time. 
@


1.6
log
@Final fix to make fts(3) spoof-proof.
@
text
@d1 2
d37 5
a41 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.5 1997/01/14 01:02:42 millert Exp $";
d66 1
a66 1
#define	ISDOT(a)	(a[0] == '.' && (!a[1] || a[1] == '.' && !a[2]))
d315 1
a315 1
		    ISSET(FTS_XDEV) && p->fts_dev != sp->fts_dev) {
d365 1
a365 1
	if (p = p->fts_link) {
d665 22
a686 26
	if (dirp) {
		for (head = tail = NULL, nitems = 0; dp = readdir(dirp);) {
			if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))
				continue;

			if ((p = fts_alloc(sp, dp->d_name, (int)dp->d_namlen)) == NULL)
				goto mem1;
			if (dp->d_namlen > maxlen) {
				if (fts_palloc(sp, (size_t)dp->d_namlen)) {
					/*
					 * No more memory for path or structures.  Save
					 * errno, free up the current structure and the
					 * structures already allocated.
					 */
	mem1:				saved_errno = errno;
					if (p)
						free(p);
					fts_lfree(head);
					(void)closedir(dirp);
					errno = saved_errno;
					cur->fts_info = FTS_ERR;
					SET(FTS_STOP);
					return (NULL);
				}
				adjaddr = sp->fts_path;
				maxlen = sp->fts_pathlen - sp->fts_cur->fts_pathlen - 1;
d688 3
d692 14
a705 24
			p->fts_pathlen = len + dp->d_namlen + 1;
			p->fts_parent = sp->fts_cur;
			p->fts_level = level;

	#ifdef FTS_WHITEOUT
			if (dp->d_type == DT_WHT)
				p->fts_flags |= FTS_ISW;
	#endif

			if (cderrno) {
				if (nlinks) {
					p->fts_info = FTS_NS;
					p->fts_errno = cderrno;
				} else
					p->fts_info = FTS_NSOK;
				p->fts_accpath = cur->fts_accpath;
			} else if (nlinks == 0
	#ifdef DT_DIR
			    || nostat && 
			    dp->d_type != DT_DIR && dp->d_type != DT_UNKNOWN
	#endif
			    ) {
				p->fts_accpath =
				    ISSET(FTS_NOCHDIR) ? p->fts_path : p->fts_name;
d707 33
a739 25
			} else {
				/* Build a file name for fts_stat to stat. */
				if (ISSET(FTS_NOCHDIR)) {
					p->fts_accpath = p->fts_path;
					memmove(cp, p->fts_name, p->fts_namelen + 1);
				} else
					p->fts_accpath = p->fts_name;
				/* Stat it. */
				p->fts_info = fts_stat(sp, p, 0);

				/* Decrement link count if applicable. */
				if (nlinks > 0 && (p->fts_info == FTS_D ||
				    p->fts_info == FTS_DC || p->fts_info == FTS_DOT))
					--nlinks;
			}

			/* We walk in directory order so "ls -f" doesn't get upset. */
			p->fts_link = NULL;
			if (head == NULL)
				head = tail = p;
			else {
				tail->fts_link = p;
				tail = p;
			}
			++nitems;
d741 3
a744 1
	}
d951 1
a951 1
	while (p = head) {
@


1.5
log
@Be extra careful when chdir'ing to subdirs.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.4 1996/12/23 06:08:59 millert Exp $";
d631 2
d659 26
a684 22
	for (head = tail = NULL, nitems = 0; dp = readdir(dirp);) {
		if (!ISSET(FTS_SEEDOT) && ISDOT(dp->d_name))
			continue;

		if ((p = fts_alloc(sp, dp->d_name, (int)dp->d_namlen)) == NULL)
			goto mem1;
		if (dp->d_namlen > maxlen) {
			if (fts_palloc(sp, (size_t)dp->d_namlen)) {
				/*
				 * No more memory for path or structures.  Save
				 * errno, free up the current structure and the
				 * structures already allocated.
				 */
mem1:				saved_errno = errno;
				if (p)
					free(p);
				fts_lfree(head);
				(void)closedir(dirp);
				errno = saved_errno;
				cur->fts_info = FTS_ERR;
				SET(FTS_STOP);
				return (NULL);
a685 3
			adjaddr = sp->fts_path;
			maxlen = sp->fts_pathlen - sp->fts_cur->fts_pathlen - 1;
		}
d687 40
a726 3
		p->fts_pathlen = len + dp->d_namlen + 1;
		p->fts_parent = sp->fts_cur;
		p->fts_level = level;
d728 9
a736 44
#ifdef FTS_WHITEOUT
		if (dp->d_type == DT_WHT)
			p->fts_flags |= FTS_ISW;
#endif

		if (cderrno) {
			if (nlinks) {
				p->fts_info = FTS_NS;
				p->fts_errno = cderrno;
			} else
				p->fts_info = FTS_NSOK;
			p->fts_accpath = cur->fts_accpath;
		} else if (nlinks == 0
#ifdef DT_DIR
		    || nostat && 
		    dp->d_type != DT_DIR && dp->d_type != DT_UNKNOWN
#endif
		    ) {
			p->fts_accpath =
			    ISSET(FTS_NOCHDIR) ? p->fts_path : p->fts_name;
			p->fts_info = FTS_NSOK;
		} else {
			/* Build a file name for fts_stat to stat. */
			if (ISSET(FTS_NOCHDIR)) {
				p->fts_accpath = p->fts_path;
				memmove(cp, p->fts_name, p->fts_namelen + 1);
			} else
				p->fts_accpath = p->fts_name;
			/* Stat it. */
			p->fts_info = fts_stat(sp, p, 0);

			/* Decrement link count if applicable. */
			if (nlinks > 0 && (p->fts_info == FTS_D ||
			    p->fts_info == FTS_DC || p->fts_info == FTS_DOT))
				--nlinks;
		}

		/* We walk in directory order so "ls -f" doesn't get upset. */
		p->fts_link = NULL;
		if (head == NULL)
			head = tail = p;
		else {
			tail->fts_link = p;
			tail = p;
d738 1
a738 1
		++nitems;
a739 1
	(void)closedir(dirp);
@


1.4
log
@Back out last change, it is not sufficient.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.2 1996/08/19 08:22:59 tholo Exp $";
d58 1
d340 1
a340 1
			if (CHDIR(sp, p->fts_accpath)) {
d367 1
a367 1
			if (!ISSET(FTS_NOCHDIR) && FCHDIR(sp, sp->fts_rfd)) {
d423 1
a423 1
		if (!ISSET(FTS_NOCHDIR) && FCHDIR(sp, sp->fts_rfd)) {
d625 1
a625 1
		if (FCHDIR(sp, dirfd(dirp))) {
d1001 43
@


1.3
log
@Avoid spoofing when cd'ing to subdirs.  First cut.
@
text
@d339 6
a344 24
			if (!ISSET(FTS_NOCHDIR)) {
				struct stat *parent1, *fts_statp2, *parent2;
				int ret;

				/* XXX - make readable somehow */
				if (!ISSET(FTS_NOSTAT) && !ISSET(FTS_LOGICAL))
					ret = ((lstat(".", parent1) != 0) ||
					(chdir(p->fts_accpath) != 0) ||
					(lstat(".", fts_statp2) != 0) ||
					(lstat("..", parent2) != 0) ||
					(p->fts_dev != fts_statp2->st_dev) ||
					(p->fts_ino != fts_statp2->st_ino) ||
					(parent1->st_dev != parent2->st_dev) ||
					(parent1->st_ino != parent2->st_ino));
				else
					ret = chdir(p->fts_accpath);

				if (ret) {
					p->fts_errno = errno;
					p->fts_flags |= FTS_DONTCHDIR;
					for (p = sp->fts_child; p; p = p->fts_link)
						p->fts_accpath =
						    p->fts_parent->fts_accpath;
				}
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: fts.c,v 1.12 1995/02/27 03:43:30 cgd Exp $";
d339 24
a362 6
			if (CHDIR(sp, p->fts_accpath)) {
				p->fts_errno = errno;
				p->fts_flags |= FTS_DONTCHDIR;
				for (p = sp->fts_child; p; p = p->fts_link)
					p->fts_accpath =
					    p->fts_parent->fts_accpath;
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: fts.c,v 1.12 1995/02/27 03:43:30 cgd Exp $	*/

d35 1
a35 5
#if 0
static char sccsid[] = "@@(#)fts.c	8.4 (Berkeley) 4/16/94";
#else
static char rcsid[] = "$NetBSD: fts.c,v 1.12 1995/02/27 03:43:30 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

