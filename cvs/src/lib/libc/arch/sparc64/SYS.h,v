head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.8
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.4
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.9.0.38
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.36
	OPENBSD_5_0:1.9.0.34
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.32
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.30
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.16
date	2016.05.07.19.05.22;	author guenther;	state Exp;
branches;
next	1.15;
commitid	d9R7VGw9CHTkwXE1;

1.15
date	2015.10.23.04.39.25;	author guenther;	state Exp;
branches;
next	1.14;
commitid	OrVNAJkzchWBNbO0;

1.14
date	2015.09.05.06.22.47;	author guenther;	state Exp;
branches;
next	1.13;
commitid	YcHx4KWjuOzN6Vj2;

1.13
date	2015.08.31.02.53.57;	author guenther;	state Exp;
branches;
next	1.12;
commitid	lTMF8Y3C9fQGd6jQ;

1.12
date	2015.04.07.01.27.07;	author guenther;	state Exp;
branches;
next	1.11;
commitid	oQvh7XA3Kql35r0J;

1.11
date	2014.06.04.20.13.49;	author matthew;	state Exp;
branches;
next	1.10;
commitid	CQgbVinZLjc6cr0k;

1.10
date	2012.08.22.17.19.35;	author pascal;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.20.18.32;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.19.22.12.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.19.19.39.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.03.01.11.10;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.26.23.02.10;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.26.18.39.13;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.25.13.04.30;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.28.22.47.26;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.28.21.59.43;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Use a Thread Information Block in both single and multi-threaded programs.
This stores errno, the cancelation flags, and related bits for each thread
and is allocated by ld.so or libc.a.  This is an ABI break from 5.9-stable!

Make libpthread dlopen'able by moving the cancelation wrappers into libc
and doing locking and fork/errno handling via callbacks that libpthread
registers when it first initializes.  'errno' *must* be declared via
<errno.h> now!

Clean up libpthread's symbol exports like libc.

On powerpc, offset the TIB/TCB/TLS data from the register per the ELF spec.

Testing by various, particularly sthen@@ and patrick@@
ok kettenis@@
@
text
@/*	$OpenBSD: SYS.h,v 1.15 2015/10/23 04:39:25 guenther Exp $	*/
/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)SYS.h	8.1 (Berkeley) 6/4/93
 *
 *	from: Header: SYS.h,v 1.2 92/07/03 18:57:00 torek Exp
 *	$NetBSD: SYS.h,v 1.6 2001/07/23 07:26:50 thorpej Exp $
 */

#include <machine/asm.h>
#include <sys/syscall.h>
#include <machine/trap.h>

/* offsetof(struct tib, tib_errno) - offsetof(struct tib, __tib_tcb) */
#define	TCB_OFFSET_ERRNO	24

#define _CAT(x,y) x##y

#define	__ENTRY(p,x)		ENTRY(_CAT(p,x)) ; .weak x; x = _CAT(p,x)
#define	__ENTRY_HIDDEN(p,x)	ENTRY(_CAT(p,x))


/*
 * We define a hidden alias with the prefix "_libc_" for each global symbol
 * that may be used internally.  By referencing _libc_x instead of x, other
 * parts of libc prevent overriding by the application and avoid unnecessary
 * relocations.
 */
#define _HIDDEN(x)		_libc_##x
#define _HIDDEN_ALIAS(x,y)			\
	STRONG_ALIAS(_HIDDEN(x),y);		\
	.hidden _HIDDEN(x)
#define _HIDDEN_FALIAS(x,y)			\
	_HIDDEN_ALIAS(x,y);			\
	.type _HIDDEN(x),@@function

/*
 * For functions implemented in ASM that aren't syscalls.
 *   END_STRONG(x)	Like DEF_STRONG() in C; for standard/reserved C names
 *   END_WEAK(x)	Like DEF_WEAK() in C; for non-ISO C names
 */
#define	END_STRONG(x)	END(x); _HIDDEN_FALIAS(x,x); END(_HIDDEN(x))
#define	END_WEAK(x)	END_STRONG(x); .weak x


#define __END_HIDDEN(p,x)	END(_CAT(p,x));				\
				_HIDDEN_FALIAS(x, _CAT(p,x));		\
				END(_HIDDEN(x))
#define __END(p,x)		__END_HIDDEN(p,x); END(x)

/*
 * ERROR sets the thread's errno and returns
 */
#define	ERROR()							\
	st	%o0, [%g7 + TCB_OFFSET_ERRNO];			\
	retl;							\
	 mov	-1, %o0

/*
 * SYSCALL is used when further action must be taken before returning.
 * Note that it adds a `nop' over what we could do, if we only knew what
 * came at label 1....
 */
#define	_SYSCALL(p,x,y) \
	__ENTRY(p,x); mov _CAT(SYS_,y),%g1; t ST_SYSCALL; bcc 1f; nop; ERROR(); 1:
#define	_SYSCALL_HIDDEN(p,x,y) \
	__ENTRY_HIDDEN(p,x); mov _CAT(SYS_,y),%g1; t ST_SYSCALL; bcc 1f; nop; ERROR(); 1:

#define	__SYSCALL(p,x) \
	_SYSCALL(p,x,x)

#define	__SYSCALL_HIDDEN(p,x) \
	_SYSCALL_HIDDEN(p,x,x)

/*
 * RSYSCALL is used when the system call should just return.  Here
 * we use the SYSCALL_G2RFLAG to put the `success' return address in %g2
 * and avoid a branch.
 */
#define	__RSYSCALL(p,x) \
	__ENTRY(p,x); mov (_CAT(SYS_,x))|SYSCALL_G2RFLAG,%g1; \
	add %o7,8,%g2; t ST_SYSCALL; ERROR(); __END(p,x)
#define	__RSYSCALL_HIDDEN(p,x) \
	__ENTRY_HIDDEN(p,x); mov (_CAT(SYS_,x))|SYSCALL_G2RFLAG,%g1; \
	add %o7,8,%g2; t ST_SYSCALL; ERROR(); __END_HIDDEN(p,x)

/*
 * PSEUDO(x,y) is like RSYSCALL(y) except that the name is x.
 */
#define	__PSEUDO(p,x,y) \
	__ENTRY(p,x); mov (_CAT(SYS_,y))|SYSCALL_G2RFLAG,%g1; add %o7,8,%g2; \
	t ST_SYSCALL; ERROR(); __END(p,x)

/*
 * SYSCALL_NOERROR is like SYSCALL, except it's used for syscalls 
 * that never fail.
 *
 * XXX - This should be optimized.
 */
#define __SYSCALL_NOERROR(p,x) \
	__ENTRY(p,x); mov _CAT(SYS_,x),%g1; t ST_SYSCALL

/*
 * RSYSCALL_NOERROR is like RSYSCALL, except it's used for syscalls 
 * that never fail.
 *
 * XXX - This should be optimized.
 */
#define __RSYSCALL_NOERROR(p,x) \
	__ENTRY(p,x); mov (_CAT(SYS_,x))|SYSCALL_G2RFLAG,%g1; add %o7,8,%g2; \
	t ST_SYSCALL; __END(p,x)

/*
 * PSEUDO_NOERROR(x,y) is like RSYSCALL_NOERROR(y) except that the name is x.
 */
#define __PSEUDO_NOERROR(p,x,y) \
	__ENTRY(p,x); mov (_CAT(SYS_,y))|SYSCALL_G2RFLAG,%g1; add %o7,8,%g2; \
	t ST_SYSCALL; __END(p,x)

/*
 * SYSENTRY is for functions that pretend to be syscalls.
 */
#define	SYSCALL(x)		__SYSCALL(_thread_sys_,x)
#define	RSYSCALL(x)		__RSYSCALL(_thread_sys_,x)
#define	RSYSCALL_HIDDEN(x)	__RSYSCALL_HIDDEN(_thread_sys_,x)
#define	RSYSCALL_NOERROR(x,y)	__RSYSCALL_NOERROR(_thread_sys_,x,y)
#define	PSEUDO(x,y)		__PSEUDO(_thread_sys_,x,y)
#define	PSEUDO_NOERROR(x,y)	__PSEUDO_NOERROR(_thread_sys_,x,y)
#define	SYSENTRY(x)		__ENTRY(_thread_sys_,x)
#define	SYSENTRY_HIDDEN(x)	__ENTRY_HIDDEN(_thread_sys_,x)
#define	SYSCALL_END(x)		__END(_thread_sys_,x)
#define	SYSCALL_END_HIDDEN(x)	__END_HIDDEN(_thread_sys_,x)
@


1.15
log
@Merge the sigaction() and sigprocmask() overloads/wrappers from libpthread
into libc, and move pthread_sigmask() as well (just a trivial wrapper).
This provides consistent handling of SIGTHR between single- and multi-threaded
programs and is a step in the merge of all the libpthread overloads, providing
some ASM and Makefile bits that the other wrappers will need.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.14 2015/09/05 06:22:47 guenther Exp $	*/
d44 3
d82 1
a82 2
 * ERROR branches to cerror.  This is done with a macro so that I can
 * change it to be position independent later, if need be.
d84 4
a87 14
#ifdef __PIC__
#define	CALL(name) \
	PIC_PROLOGUE(%g1,%g2); \
	sethi %hi(name),%g2; \
	or %g2,%lo(name),%g2; \
	ldx [%g1+%g2],%g2; \
	jmp %g2; \
	nop
#else
#define	CALL(name) \
	sethi %hi(name),%g1; or %lo(name),%g1,%g1; \
	jmp %g1; nop
#endif
#define	ERROR()	CALL(_C_LABEL(__cerror))
a148 2

	.globl	_C_LABEL(__cerror)
@


1.14
log
@Adds hidden _libc_FOO aliases for the system call stubs.
Stop generating _brk and _sbrk symbols: they've already been hidden.
Set the ELF symbol size on the syscall stubs.
Give the __{min,cur}brk symbols a size and type, and hide more jump labels.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.13 2015/08/31 02:53:57 guenther Exp $	*/
a162 2
#define __SYSENTRY(p,x) __ENTRY(p,x)

d169 2
a170 1
#define	SYSENTRY(x)		__SYSENTRY(_thread_sys_,x)
d172 1
@


1.13
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.12 2015/04/07 01:27:07 guenther Exp $	*/
d73 5
d120 1
a120 1
	add %o7,8,%g2; t ST_SYSCALL; ERROR()
d123 1
a123 1
	add %o7,8,%g2; t ST_SYSCALL; ERROR()
d130 1
a130 1
	t ST_SYSCALL; ERROR()
d149 1
a149 1
	t ST_SYSCALL
d156 1
a156 1
	t ST_SYSCALL
d172 1
@


1.12
log
@Make pthread_atfork() track the DSO that called it like atexit() does,
unregistering callbacks if the DSO is unloaded.  Move the callback
handling from libpthread to libc, though libpthread still overrides the
inner call to handle locking and thread-library reinitialization.
Major version bump for both libc and libpthread.

verification that this fixes various ports ajacoutot@@
asm assistance miod@@; ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.11 2014/06/04 20:13:49 matthew Exp $	*/
d48 24
@


1.11
log
@Apply "unifdef -D__STDC__" to libc/arch/*/SYS.h

A while back, pascal@@ converted our system call stubs from using "cpp
| as" to "cc -x assembler-with-cpp", so there's no need to stay
compatible with ancient preprocessor semantics.

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.10 2012/08/22 17:19:35 pascal Exp $	*/
d46 2
a47 1
#define	__ENTRY(p,x)	ENTRY(_CAT(p,x)) ; .weak x; x = _CAT(p,x)
d75 2
d81 3
d90 5
a94 2
	__ENTRY(p,x); mov (_CAT(SYS_,x))|SYSCALL_G2RFLAG,%g1; add %o7,8,%g2; \
	t ST_SYSCALL; ERROR()
d138 1
@


1.10
log
@Convert cpp | as rules in bsd.lib.mk and lib/libc/sys/Makefile.inc to pure cc
invocations.  This allows us to use the compiler builtin define __PIC__ to check
for PIC/PIEness rather than passing -DPIC.  Simplifies PIE work a lot.

ok matthew@@, conceptually ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.9 2003/06/02 20:18:32 millert Exp $	*/
a43 1
#ifdef __STDC__
a44 3
#else
#define _CAT(x,y) x/**/y
#endif
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.8 2002/02/19 22:12:37 millert Exp $	*/
d56 1
a56 1
#ifdef PIC
@


1.8
log
@We need to keep K&R compat macros for some ports where the assemnbler is
still using -traditional-cpp.
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.7 2002/02/19 19:39:36 millert Exp $	*/
d18 1
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.6 2002/01/03 01:11:10 art Exp $	*/
d48 1
d50 3
@


1.6
log
@Always have the real entry point to the syscall called _thread_sys_
and provide the real name as a weak alias.
This is the last piece needed for libc_r on sparc64 (plus debugging).
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.5 2001/09/26 23:02:10 drahn Exp $	*/
a47 1
#ifdef __STDC__
a48 3
#else
#define _CAT(x,y) x/**/y
#endif
@


1.5
log
@Changes to SYS.h for sparc64 to make it work with libc_r
bulk of work done by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.4 2001/09/26 18:39:13 art Exp $	*/
a49 1
#define	__ENTRY(p,x)	ENTRY(p##x)
a51 1
#define	__ENTRY(p,x)	ENTRY(p/**/x)
d54 2
a134 5
#ifdef	_THREAD_SAFE
/*
 * For the thread_safe versions, we prepend _thread_sys_ to the function
 * name so that the 'C' wrapper can go around the real name.
 */
a140 12
#else	/* _THREAD_SAFE */
/*
 * The non-threaded library defaults to traditional syscalss where
 * the function name matches the syscall name.
 */
#define	SYSCALL(x)		__SYSCALL(,x)
#define	RSYSCALL(x)		__RSYSCALL(,x)
#define	RSYSCALL_NOERROR(x,y)	__RSYSCALL_NOERROR(,x,y)
#define	PSEUDO(x,y)		__PSEUDO(,x,y)
#define	PSEUDO_NOERROR(x,y)	__PSEUDO_NOERROR(,x,y)
#define	SYSENTRY(x)		__SYSENTRY(,x)
#endif	/* _THREAD_SAFE */
@


1.4
log
@Revert last. The ERROR() macro is called from leaf functions
and is _not_ supposed to do "call"s.
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.2 2001/08/28 22:47:26 art Exp $	*/
d50 1
d53 1
d80 2
a81 2
#define	_SYSCALL(x,y) \
	ENTRY(x); mov _CAT(SYS_,y),%g1; t ST_SYSCALL; bcc 1f; nop; ERROR(); 1:
d83 2
a84 2
#define	SYSCALL(x) \
	_SYSCALL(x,x)
d91 2
a92 2
#define	RSYSCALL(x) \
	ENTRY(x); mov (_CAT(SYS_,x))|SYSCALL_G2RFLAG,%g1; add %o7,8,%g2; \
d98 2
a99 2
#define	PSEUDO(x,y) \
	ENTRY(x); mov (_CAT(SYS_,y))|SYSCALL_G2RFLAG,%g1; add %o7,8,%g2; \
d108 2
a109 2
#define SYSCALL_NOERROR(x) \
	ENTRY(x); mov _CAT(SYS_,x),%g1; t ST_SYSCALL
d117 2
a118 2
#define RSYSCALL_NOERROR(x) \
	ENTRY(x); mov (_CAT(SYS_,x))|SYSCALL_G2RFLAG,%g1; add %o7,8,%g2; \
d124 2
a125 2
#define PSEUDO_NOERROR(x,y) \
	ENTRY(x); mov (_CAT(SYS_,y))|SYSCALL_G2RFLAG,%g1; add %o7,8,%g2; \
d133 1
a133 1
#define SYSENTRY(x) ENTRY(x)
d135 23
@


1.3
log
@Add an ASPICFLAG variable to bsd.own.mk which a platform use to pass flags
to 'as' to make it compile pic. add defaults for sparc64 which needs picflags
set to -fPIC and ASPICFLAGS to -KPIC.
Also simplifies the systemcall generation for sparc64 PIC mode.
ok epsie@@.
@
text
@d60 5
a64 1
	call name, 0; \
@


1.2
log
@Add SYSENTRY as on sparc. We'll need it later.
@
text
@d1 1
a1 1
/*	$OpenBSD: SYS.h,v 1.1 2001/08/28 21:59:43 art Exp $	*/
d60 1
a60 5
	PIC_PROLOGUE(%g1,%g2); \
	sethi %hi(name),%g2; \
	or %g2,%lo(name),%g2; \
	ldx [%g1+%g2],%g2; \
	jmp %g2; \
@


1.1
log
@SYS.h from NetBSD. Not fixed yet for libc_r.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d127 6
@

