head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.30
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.28
	OPENBSD_5_0:1.7.0.26
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.24
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.22
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.18
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.20
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.16
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.14
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.12
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.10
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.8
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.6
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.4.0.16
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.14
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.12
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.10
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.8
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.6
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@# @;


1.9
date	2014.03.18.22.36.29;	author miod;	state dead;
branches;
next	1.8;

1.8
date	2013.02.02.13.29.14;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.07.16.40.14;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.17.21.56.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.03.01.52.39;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.05.01.15.57.01;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.30.22.18.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.22.07.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.04.25.00.10.06;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: strlcpy.S,v 1.8 2013/02/02 13:29:14 miod Exp $ */
/*
 * Copyright (c) 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "DEFS.h"

/*
 * It is faster to implement strlcpy() as two distinct operations,
 * a strlen() and a memcpy().  Note that we *always* add a NUL, unless
 * the count is 0.
 *
 * TODO: try unrolling the two main loops a bit
 */

ENTRY(strlcpy)
	movl	%sp@@(8),%a0		| a0 = src
	movl	%a0,%a1			| working copy of src ptr
	movl	%a0,%d0			| return (d0) value is len(src)
	notl	%d0			| take the complement of d0
strlcpy_len:
	tstb	%a1@@+			| did we hit the terminating NUL?
	bne	strlcpy_len		| nope, keep going
	addl	%a1,%d0
					| now set things up to do the copy
	movl	%sp@@(4),%a1		| a1 = dst
	movl	%sp@@(12),%d1		| d1 = count
	beq	strlcpy_done		| zero count, just return

	subql	#1,%d1			| subtract one for the NUL
	cmpl	%d0, %d1		| must set d1 to MIN(d0, d1)
	ble	strlcpy_check		| count - 1 <= len(src), so d1 is ok
	movl	%d0, %d1		| d1 is too big, set it to len(src)
strlcpy_check:
	tstl	%d1			| is d1 zero?
	beq	strlcpy_clear		| if so, skip copy and set byte to NUL
strlcpy_copy:
	movb	%a0@@+,%a1@@+		| copy a byte
	subql	#1,%d1			| decrement count
	bne	strlcpy_copy		| space left?  continue copying...
strlcpy_clear:
	clrb	%a1@@			| clear last byte
strlcpy_done:
	moveal	%d0,%a0
	rts
@


1.8
log
@Userland bits for m68k/ELF. Mostly addition of register prefixes to the
assembler instructions, and cope with the few changes in return values
location.
@
text
@d1 1
a1 1
/*	$OpenBSD: strlcpy.S,v 1.7 2005/08/07 16:40:14 espie Exp $ */
@


1.7
log
@zap rcsid.
okay deraadt@@ (tested them all)
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d29 4
a32 4
	movl	sp@@(8),a0		| a0 = src
	movl	a0,a1			| working copy of src ptr
	movl	a0,d0			| return (d0) value is len(src)
	notl	d0			| take the complement of d0
d34 1
a34 1
	tstb	a1@@+			| did we hit the terminating NUL?
d36 1
a36 1
	addl	a1,d0
d38 2
a39 2
	movl	sp@@(4),a1		| a1 = dst
	movl	sp@@(12),d1		| d1 = count
d42 2
a43 2
	subql	#1,d1			| subtract one for the NUL
	cmpl	d0, d1			| must set d1 to MIN(d0, d1)
d45 1
a45 1
	movl	d0, d1			| d1 is too big, set it to len(src)
d47 1
a47 1
	tstl	d1			| is d1 zero?
d50 2
a51 2
	movb	a0@@+,a1@@+		| copy a byte
	subql	#1,d1			| decrement count
d54 1
a54 1
	clrb	a1@@			| clear last byte
d56 1
@


1.6
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a18 5

#if defined(LIBC_SCCS)
	.text
	.asciz "$OpenBSD: strlcpy.S,v 1.5 2003/06/03 01:52:39 millert Exp $"
#endif /* LIBC_SCCS */
@


1.5
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d8 7
a14 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d21 1
a21 1
	.asciz "$OpenBSD: strlcpy.S,v 1.4 1999/05/01 15:57:01 millert Exp $"
@


1.4
log
@It is faster to split this into separate length and copy operations
@
text
@a2 1
 * All rights reserved.
d4 3
a6 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d8 7
a14 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d21 1
a21 1
	.asciz "$OpenBSD: strlcpy.S,v 1.3 1999/04/30 22:18:22 millert Exp $"
@


1.3
log
@don't use a2
@
text
@d32 1
a32 1
	.asciz "$OpenBSD: strlcpy.S,v 1.2 1999/04/30 22:17:25 millert Exp $"
d35 8
d44 9
d54 15
a68 18
	movl	sp@@(8),a0		| a0 = src
	movl	sp@@(12),d1		| d1 = orig_count
	movl	d1,d0			| d0 = count
	beq	slcloop			| don't let count wrap...
	subql	#1,d0			| subtract one for the NUL
slcloop:
	tstb	a0@@			| got a NUL in src?
	beq	slcnul			| if so, add NUL to dst and we're done
	tstl	d0			| only copy bytes if count is non-zero
	beq	slcinc			| (else just increment src ptr)
	movb	a0@@,a1@@+		| copy a byte but only increment dst
	subql	#1,d0			| decrement count
slcinc:
	addql	#1,a0			| increment src ptr
	jra	slcloop			| keep going...
slcnul:
	tstl	d1			| make sure we had a non-zero orig_count
	beq	slcdone
d70 1
a70 3
slcdone:
	movl	a0,d0
	subl	sp@@(8),d0		| return value
@


1.2
log
@fix register usage (program logic is  unchanged)
@
text
@d32 1
a32 1
	.asciz "$OpenBSD: strlcpy.S,v 1.1 1999/04/25 00:10:06 millert Exp $"
a37 1
	movl	a0,a2			| a2 = orig_src
d58 1
a58 1
	subl	a2,d0			| return value
@


1.1
log
@m68k assembler version of strlcpy(3)
@
text
@d32 1
a32 1
	.asciz "$OpenBSD$"
d36 5
a40 5
	movl	sp@@(4),a0		| a0 = dst
	movl	sp@@(8),a1		| a1 = src
	movl	a1,a2			| a2 = orig_src
	movl	sp@@(12),a3		| a3 = orig_count
	movl	a3,d1			| d1 = count
d42 1
a42 1
	subql	#1,d1			| subtract one for the NUL
d44 1
a44 1
	tstb	a1@@			| got a NUL?
d46 1
a46 1
	tstl	d1			| only copy bytes if count is non-zero
d48 2
a49 2
	movb	a1@@,a0@@+		| copy a byte but only increment dst
	subql	#1,d1			| decrement count
d51 1
a51 1
	addql	#1,a1			| increment src ptr
d54 1
a54 1
	tstl	a3			| make sure we had a non-zero orig_count
d56 1
a56 1
	clrb	a0@@			| clear last byte
d58 1
a58 1
	movl	a1,d0
@

