head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.8
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.46
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.50
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.48
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.44
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.42
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.40
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.38
	OPENBSD_5_0:1.4.0.36
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.34
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.32
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.28
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.24
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.22
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.5
date	2015.06.01.19.02.11;	author miod;	state Exp;
branches;
next	1.4;
commitid	5xcG7tuSClVWQ32d;

1.4
date	2003.03.01.00.19.08;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	96.11.13.21.20.09;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.10.22;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.20;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Since the __{div,rem}{l,q}{,u} special libc entry points use a specific
calling convention which conflicts over t11 usage with the secureplt
calling convention, force these symbols to be `notype' rather `function', so
that the linker will not attempt to use plt relocations for them in the
absence of explicit relocation information.

Note that these symbols are still public and still callable with the old plt
convention, so existing binaries will still work with an updated libc, and
no libc version change is necessary.
@
text
@/*	$OpenBSD: divrem.m4,v 1.4 2003/03/01 00:19:08 miod Exp $	*/
/*	$NetBSD: divrem.m4,v 1.7 1996/10/17 03:08:04 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * Division and remainder.
 *
 * The use of m4 is modeled after the sparc code, but the algorithm is
 * simple binary long division.
 *
 * Note that the loops could probably benefit from unrolling.
 */

/*
 * M4 Parameters
 * NAME		name of function to generate
 * OP		OP=div: t10 / t11 -> t12; OP=rem: t10 % t11 -> t12
 * S		S=true: signed; S=false: unsigned
 * WORDSIZE	total number of bits
 */

define(A, `t10')
define(B, `t11')
define(RESULT, `t12')

define(BIT, `t0')
define(I, `t1')
define(CC, `t2')
define(T_0, `t3')
ifelse(S, `true', `define(NEG, `t4')')

#include <machine/asm.h>

/*
 * These functions use t11 as an input, which makes them incompatible with
 * the secureplt calling sequence. The compiler knows about this, and will
 * ask for a call through a got relocation. But this can only work if the
 * linker omits creating a plt entry for the symbol. In order to achieve
 * this, we need to declare it as `notype' instead of `function', which
 * means that LEAF(NAME, 0) can't be used as it uses .ent which forces the
 * `function' type.
 */
	.globl	NAME
	.type	NAME, @@notype
	.usepv	NAME, no

	.cfi_startproc
	.cfi_return_column ra
NAME:
	MCOUNT
	lda	sp, -64(sp)
	.cfi_def_cfa_offset 64
	stq	BIT, 0(sp)
	.cfi_rel_offset BIT, 0
	stq	I, 8(sp)
	.cfi_rel_offset I, 8
	stq	CC, 16(sp)
	.cfi_rel_offset CC, 16
	stq	T_0, 24(sp)
	.cfi_rel_offset T_0, 24
ifelse(S, `true',`dnl
	stq	NEG, 32(sp)
	.cfi_rel_offset NEG, 32
')dnl
	stq	A, 40(sp)
	.cfi_rel_offset A, 40
	stq	B, 48(sp)
	.cfi_rel_offset B, 48
	mov	zero, RESULT			/* Initialize result to zero */

ifelse(S, `true',
`
	/* Compute sign of result.  If either is negative, this is easy.  */
	or	A, B, NEG			/* not the sign, but... */
	srl	NEG, WORDSIZE - 1, NEG		/* rather, or of high bits */
	blbc	NEG, Ldoit			/* neither negative? do it! */

ifelse(OP, `div',
`	xor	A, B, NEG			/* THIS is the sign! */
', `	mov	A, NEG				/* sign follows A. */
')
	srl	NEG, WORDSIZE - 1, NEG		/* make negation the low bit. */

	srl	A, WORDSIZE - 1, I		/* is A negative? */
	blbc	I, LnegB			/* no. */
	/* A is negative; flip it. */
ifelse(WORDSIZE, `32', `
	/* top 32 bits may be random junk */
	zap	A, 0xf0, A
')
	subq	zero, A, A
	srl	B, WORDSIZE - 1, I		/* is B negative? */
	blbc	I, Ldoit			/* no. */
LnegB:
	/* B is definitely negative, no matter how we got here. */
ifelse(WORDSIZE, `32', `
	/* top 32 bits may be random junk */
	zap	B, 0xf0, B
')
	subq	zero, B, B
Ldoit:
')
ifelse(WORDSIZE, `32', `
	/*
	 * Clear the top 32 bits of each operand, as they may
	 * sign extension (if negated above), or random junk.
	 */
	zap	A, 0xf0, A
	zap	B, 0xf0, B
')

	/* kill the special cases. */
	beq	B, Ldotrap			/* division by zero! */

	cmpult	A, B, CC			/* A < B? */
	/* RESULT is already zero, from above.  A is untouched. */
	bne	CC, Lret_result

	cmpeq	A, B, CC			/* A == B? */
	cmovne	CC, 1, RESULT
	cmovne	CC, zero, A
	bne	CC, Lret_result

	/*
	 * Find out how many bits of zeros are at the beginning of the divisor.
	 */
LBbits:
	ldiq	T_0, 1				/* I = 0; BIT = 1<<WORDSIZE-1 */
	mov	zero, I
	sll	T_0, WORDSIZE-1, BIT
LBloop:
	and	B, BIT, CC			/* if bit in B is set, done. */
	bne	CC, LAbits
	addq	I, 1, I				/* increment I, shift bit */
	srl	BIT, 1, BIT
	cmplt	I, WORDSIZE-1, CC		/* if I leaves one bit, done. */
	bne	CC, LBloop

LAbits:
	beq	I, Ldodiv			/* If I = 0, divide now.  */
	ldiq	T_0, 1				/* BIT = 1<<WORDSIZE-1 */
	sll	T_0, WORDSIZE-1, BIT

LAloop:
	and	A, BIT, CC			/* if bit in A is set, done. */
	bne	CC, Ldodiv
	subq	I, 1, I				/* decrement I, shift bit */
	srl     BIT, 1, BIT 
	bne	I, LAloop			/* If I != 0, loop again */

Ldodiv:
	sll	B, I, B				/* B <<= i */
	ldiq	T_0, 1
	sll	T_0, I, BIT

Ldivloop:
	cmpult	A, B, CC
	or	RESULT, BIT, T_0
	cmoveq	CC, T_0, RESULT
	subq	A, B, T_0
	cmoveq	CC, T_0, A
	srl	BIT, 1, BIT	
	srl	B, 1, B
	beq	A, Lret_result
	bne	BIT, Ldivloop

Lret_result:
ifelse(OP, `div',
`', `	mov	A, RESULT
')
ifelse(S, `true',
`
	/* Check to see if we should negate it. */
	subq	zero, RESULT, T_0
	cmovlbs	NEG, T_0, RESULT
')

	ldq	BIT, 0(sp)
	.cfi_restore BIT
	ldq	I, 8(sp)
	.cfi_restore I
	ldq	CC, 16(sp)
	.cfi_restore CC
	ldq	T_0, 24(sp)
	.cfi_restore T_0
ifelse(S, `true',`dnl
	ldq	NEG, 32(sp)
	.cfi_restore NEG
')dnl
	ldq	A, 40(sp)
	.cfi_restore A
	ldq	B, 48(sp)
	.cfi_restore B
	lda	sp, 64(sp)
	.cfi_def_cfa_offset 0
	ret	zero, (t9), 1

Ldotrap:
	ldiq	a0, -2			/* This is the signal to SIGFPE! */
	call_pal PAL_gentrap
ifelse(OP, `div',
`', `	mov	zero, A			/* so that zero will be returned */
')
	br	zero, Lret_result

/*
 * For the reasons stated above, we can not use END(NAME) either, as it
 * expands to .end which requires a matching .ent.
 */
	.cfi_endproc
	.size	NAME, . - NAME
@


1.4
log
@Provide real ieee fp*() functions; from NetBSD.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: divrem.m4,v 1.3 1996/11/13 21:20:09 niklas Exp $	*/
d60 17
a76 1
LEAF(NAME, 0)					/* XXX */
d78 1
d80 1
d82 1
d84 1
d86 5
a90 2
ifelse(S, `true',
`	stq	NEG, 32(sp)')
d92 1
d94 1
d205 1
d207 1
d209 1
d211 5
a215 2
ifelse(S, `true',
`	ldq	NEG, 32(sp)')
d217 1
d219 1
d221 1
d232 6
a237 1
END(NAME)
@


1.3
log
@Sync to NetBSD + fixup RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: divrem.m4,v 1.2 1996/08/19 08:10:22 tholo Exp $	*/
d175 1
a175 1
	subqv	zero, RESULT, T_0
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 2
a2 1
/*	$OpenBSD: divrem.m4,v 1.5 1995/09/30 03:09:07 cgd Exp $	*/
d58 1
a58 1
#include "DEFS.h"
d116 1
a116 1
1:	cmpult	A, B, CC			/* A < B? */
d129 1
a129 1
	CONST(1, T_0)				/* I = 0; BIT = 1<<WORDSIZE-1 */
d142 1
a142 1
	CONST(1, T_0)				/* BIT = 1<<WORDSIZE-1 */
d154 1
a154 1
	CONST(1, T_0)
d191 1
a191 1
	CONST(-2, a0)			/* This is the signal to SIGFPE! */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: divrem.m4,v 1.5 1995/09/30 03:09:07 cgd Exp $	*/
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
