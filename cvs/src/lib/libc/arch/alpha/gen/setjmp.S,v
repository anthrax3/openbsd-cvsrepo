head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.4
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.6
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.44
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.36
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.40
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.38
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.34
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.32
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.30
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.28
	OPENBSD_5_0:1.7.0.26
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.24
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.22
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.18
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.20
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.16
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.14
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.12
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.10
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.8
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.6
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.9
date	2016.05.09.16.33.48;	author guenther;	state Exp;
branches;
next	1.8;
commitid	RAZYJFaigqhQRWSO;

1.8
date	2015.09.13.07.36.58;	author guenther;	state Exp;
branches;
next	1.7;
commitid	lKiiBbVqMp5OO6rf;

1.7
date	2005.08.07.16.40.13;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.29.18.56.14;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.15.13.39.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.04.13.51.20;	author art;	state Exp;
branches;
next	1.3;

1.3
date	96.11.13.21.20.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.10.45;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.21;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Stop using sigreturn for longjmp, just set the signal mask and return
registers ala _longjmp.  In setjmp, stop saving the onstack from sigaltstack
as it's been unused by longjmp for years.
In sig{set,long}jmp, use the internal, hidden names for setjmp/_setjmp/etc
to avoid creating PLT entries.

build testing deraadt@@
@
text
@/*	$OpenBSD: setjmp.S,v 1.8 2015/09/13 07:36:58 guenther Exp $	*/
/*	$NetBSD: setjmp.S,v 1.2 1996/10/17 03:08:06 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include "SYS.h"

/*
 * C library -- setjmp, longjmp
 *
 *	longjmp(a,v)
 * will generate a "return(v)" from
 * the last call to
 *	setjmp(a)
 * by restoring registers from the stack,
 * and the previous signal state.
 */

	.set	noreorder

LEAF(setjmp, 1)
	LDGP(pv)
	stq	ra, (2 * 8)(a0)			/* sc_pc = return address */
	stq	s0, (( 9 + 4) * 8)(a0)		/* saved bits of sc_regs */
	stq	s1, ((10 + 4) * 8)(a0)
	stq	s2, ((11 + 4) * 8)(a0)
	stq	s3, ((12 + 4) * 8)(a0)
	stq	s4, ((13 + 4) * 8)(a0)
	stq	s5, ((14 + 4) * 8)(a0)
	stq	s6, ((15 + 4) * 8)(a0)
	stq	ra, ((26 + 4) * 8)(a0)
	stq	sp, ((30 + 4) * 8)(a0)

	/*
	 * get signal mask
	 */
	mov	a0, s0				/* squirrel away ptr to sc */
	ldiq	a0, 1				/* how == SIG_BLOCK */
	mov	zero, a1			/* set == empty */
	CALLSYS_NOERROR(sigprocmask)
	bne	a3, botch			/* impossible */
	stq	v0, (1 * 8)(s0)			/* save oset in sc_mask */

	/*
	 * Restore old s0 and a0, and continue saving registers
	 */
	mov	s0, a0
	ldq	s0, (( 9 + 4) * 8)(a0)

	ldiq	t0, 0xacedbadf			/* *not* sigcontext magic */
	stq	t0, ((31 + 4) * 8)(a0)		/* magic in sc_regs[31] */
	/* Too bad we can't check if we actually used FP */
	ldiq	t0, 1
	stq	t0, (36 * 8)(a0)		/* say we've used FP.  */
	stt	fs0, ((2 + 37) * 8)(a0)		/* saved bits of sc_fpregs */
	stt	fs1, ((3 + 37) * 8)(a0)
	stt	fs2, ((4 + 37) * 8)(a0)
	stt	fs3, ((5 + 37) * 8)(a0)
	stt	fs4, ((6 + 37) * 8)(a0)
	stt	fs5, ((7 + 37) * 8)(a0)
	stt	fs6, ((8 + 37) * 8)(a0)
	stt	fs7, ((9 + 37) * 8)(a0)
	mf_fpcr	ft0				/* get FP control reg */
	stt	ft0, (69 * 8)(a0)		/* and store it in sc_fpcr */
	stq	zero, (70 * 8)(a0)		/* FP software control XXX */
	stq	zero, (71 * 8)(a0)		/* sc_reserved[0] */
	stq	zero, (72 * 8)(a0)		/* sc_reserved[1] */
	stq	zero, (73 * 8)(a0)		/* sc_xxx[0] */
	stq	zero, (74 * 8)(a0)		/* sc_xxx[1] */
	stq	zero, (75 * 8)(a0)		/* sc_xxx[2] */
	stq	zero, (76 * 8)(a0)		/* sc_xxx[3] */
	stq	zero, (77 * 8)(a0)		/* sc_xxx[4] */
	stq	zero, (78 * 8)(a0)		/* sc_xxx[5] */
	stq	zero, (79 * 8)(a0)		/* sc_xxx[6] */
	stq	zero, (80 * 8)(a0)		/* sc_xxx[7] */

	mov	zero, v0			/* return zero */
	RET
END_STRONG(setjmp)

LEAF(longjmp, 2)
	LDGP(pv)
	ldq	t0, ((31 + 4) * 8)(a0)		/* magic in sc_regs[31] */
	ldiq	t1, 0xacedbadf
	cmpeq	t0, t1, t0
	beq	t0, botch			/* If the magic was bad, punt */

	/*
	 * set signal mask
	 */
	mov	a0, s0				/* squirrel away ptr to sc */
	mov	a1, s1				/* and the return value */
	ldiq	a0, 3				/* how == SIG_SETMASK */
	ldq	a1, (1 * 8)(s0)			/* get set from sc_mask */
	CALLSYS_NOERROR(sigprocmask)
	bne	a3, botch			/* impossible */

	/*
	 * Restore a0 and a1, and continue restoring registers
	 */
	mov	s0, a0
	mov	s1, a1

	ldq	ra, (2 * 8)(a0)			/* sc_pc = return address */
	ldq	s0, (( 9 + 4) * 8)(a0)		/* saved bits of sc_regs */
	ldq	s1, ((10 + 4) * 8)(a0)
	ldq	s2, ((11 + 4) * 8)(a0)
	ldq	s3, ((12 + 4) * 8)(a0)
	ldq	s4, ((13 + 4) * 8)(a0)
	ldq	s5, ((14 + 4) * 8)(a0)
	ldq	s6, ((15 + 4) * 8)(a0)
	/* ldq	ra, ((26 + 4) * 8)(a0)		set above */
	ldq	sp, ((30 + 4) * 8)(a0)
	ldt	fs0, ((2 + 37) * 8)(a0)		/* saved bits of sc_fpregs */
	ldt	fs1, ((3 + 37) * 8)(a0)
	ldt	fs2, ((4 + 37) * 8)(a0)
	ldt	fs3, ((5 + 37) * 8)(a0)
	ldt	fs4, ((6 + 37) * 8)(a0)
	ldt	fs5, ((7 + 37) * 8)(a0)
	ldt	fs6, ((8 + 37) * 8)(a0)
	ldt	fs7, ((9 + 37) * 8)(a0)
	ldt	ft0, (69 * 8)(a0)		/* get sc_fpcr */
	mt_fpcr	ft0				/* and restore it. */

	bne	a1, 1f
	addq	a1, 1, a1
1:
	mov	a1, v0				/* return second arg */
	RET

botch:
	CALL(_HIDDEN(abort))
	RET					/* "can't" get here... */
END_STRONG(longjmp)
@


1.8
log
@Do provide hidden _libc_* aliases for sig{block,setmask} and use them in
the ASM *setjmp implementations.
Skip the PLT when calling them on amd64 (other archs to do this after testing)

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: setjmp.S,v 1.7 2005/08/07 16:40:13 espie Exp $	*/
d31 1
a31 1
#include <machine/asm.h>
d60 1
a60 1
	 * get signal information
d63 5
a68 15
	/* see what's blocked */
	mov	zero, a0
	CALL(_libc_sigblock)			/* see what's blocked */
	stq	v0, (1 * 8)(s0)			/* and remember it in sc_mask */

	lda	sp, -24(sp)			/* padded struct sigaltstack */
	mov	zero, a0
	mov	sp, a1
	CALL(sigaltstack)
	ldl	t0, 16(sp)
	lda	sp, 24(sp)
	ldq	ra, ((26 + 4) * 8)(s0)		/* restore return address */
	blt	v0, botch			/* check for error */
	and	t0, 0x1, t0			/* get SA_ONSTACK flag */
	stq	t0, (0 * 8)(s0)			/* and save it in sc_onstack */
d75 1
a75 1
	ldiq	t0, 0xacedbade			/* sigcontext magic number */
d104 1
a104 1
END(setjmp)
d108 42
d153 2
a154 2
	stq	a1, (( 0 + 4) * 8)(a0)		/* save return value */
	CALL(sigreturn)				/* use sigreturn to return */
d157 1
a157 2
	CALL(longjmperror)
	CALL(abort)
d159 1
a159 2
END(longjmp)

@


1.7
log
@zap rcsid.
okay deraadt@@ (tested them all)
@
text
@d1 1
a1 1
/*	$OpenBSD: setjmp.S,v 1.6 2004/01/29 18:56:14 tedu Exp $	*/
d66 1
a66 1
	CALL(sigblock)				/* see what's blocked */
@


1.6
log
@fix to use sigaltstack again.  help miod ok miod deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: setjmp.S,v 1.5 2004/01/15 13:39:38 deraadt Exp $	*/
a31 5

#if defined(LIBC_SCCS)
	.text
	.asciz "$OpenBSD: setjmp.S,v 1.5 2004/01/15 13:39:38 deraadt Exp $"
#endif
@


1.5
log
@ABI breakage happened with the sigaltstack replacement.  It is too late,
now we just have to cope.  Since setjmp uses it, the alpha and sparc64 are
unhappy with the structure change.  In a few days, we will make the second
hop here, for now, use the old system call until all binaries have the new
struct in them.
@
text
@d1 1
a1 1
/*	$OpenBSD: setjmp.S,v 1.4 2002/01/04 13:51:20 art Exp $	*/
d35 1
a35 1
	.asciz "$OpenBSD: setjmp.S,v 1.4 2002/01/04 13:51:20 art Exp $"
d74 1
a74 1
	lda	sp, -16(sp)			/* sizeof struct osigaltstack */
d77 3
a79 3
	CALL(osigaltstack)
	ldl	t0, 12(sp)
	lda	sp, 16(sp)
@


1.4
log
@longjmp(..., 0) is not really legal, but all other archs I've looked
at make sure that setjmp doesn't return 0 if longjmp is passed a 0.
Avoid surprises.
@
text
@d1 1
a1 1
/*	$OpenBSD: setjmp.S,v 1.3 1996/11/13 21:20:21 niklas Exp $	*/
d35 1
a35 1
	.asciz "$OpenBSD: setjmp.S,v 1.3 1996/11/13 21:20:21 niklas Exp $"
d74 1
a74 1
	lda	sp, -16(sp)			/* sizeof struct sigaltstack */
d77 1
a77 1
	CALL(sigaltstack)
@


1.3
log
@Sync to NetBSD + fixup RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: setjmp.S,v 1.2 1996/10/17 03:08:06 cgd Exp $	*/
d35 1
a35 1
	.asciz "$OpenBSD: setjmp.S,v 1.2 1996/08/19 08:10:45 tholo Exp $"
d123 3
d134 1
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 3
d31 1
a31 1
#include "DEFS.h"
d35 1
a35 1
	.asciz "$OpenBSD$"
d52 1
a52 1
	SETGP(pv)
d90 1
a90 1
	CONST(0xACEDBADE, t0)			/* sigcontext magic number */
d93 1
a93 1
	CONST(1, t0)
d103 1
a103 1
	MF_FPCR(ft0)				/* get FP control reg */
d122 1
a122 1
	SETGP(pv)
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: setjmp.S,v 1.1 1995/02/10 17:50:26 cgd Exp $	*/

d29 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
