head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.8
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.4
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@# @;


1.5
date	2015.08.31.04.53.36;	author guenther;	state Exp;
branches;
next	1.4;
commitid	UExCqAMIoN3NjYzV;

1.4
date	2015.08.31.02.53.56;	author guenther;	state Exp;
branches;
next	1.3;
commitid	lTMF8Y3C9fQGd6jQ;

1.3
date	2014.12.05.01.30.44;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	djmWSM6hLNve8mBa;

1.2
date	99.09.14.00.46.18;	author mickey;	state dead;
branches;
next	1.1;

1.1
date	98.12.17.16.56.47;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Add ALTEXIT_{STRONG,WEAK} to support wrapping of functions using ALTENTRY.
Fix memmove with that

ok deraadt@@
@
text
@/* This is a generated file. DO NOT EDIT. */
/*
 * Generated from:
 *
 *	OpenBSD: bcopy.m4
 */
/*
 * Copyright (c) 1999 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include "SYS.h"


LEAF_ENTRY(bcopy)
	copy	arg0, ret0
	copy	arg1, arg0
	copy	ret0, arg1
ALTENTRY(memmove)
	comb,>,n arg0, arg1, $bcopy.reverse
// ALTENTRY(memcpy)
	copy	arg0, ret0
	
	comib,>=,n 15, arg2, $bcopy_f.byte

	extru	arg1, 31, 2, t3
	extru	arg0, 31, 2, t4
	add	arg2, t4, arg2
	comb,<> t3, t4, $bcopy_f.unaligned
	dep	r0, 31, 2, arg1
	
	addi	-16, arg2, arg2
$bcopy_f.loop16a
	ldws,ma	4(sr0, arg1), t1
	ldws,ma	4(sr0, arg1), t2
	ldws,ma	4(sr0, arg1), t3
	ldws,ma	4(sr0, arg1), t4
	stbys,b,m t1, 4(sr0, arg0)
	stws,ma	t2, 4(sr0, arg0)
	stws,ma	t3, 4(sr0, arg0)
	addib,>= -16, arg2, $bcopy_f.loop16a
	stws,ma	t4, 4(sr0, arg0)

	addib,<,n 12, arg2, $bcopy_f.cleanup
$bcopy_f.word
	ldws,ma	4(sr0, arg1), t1
	addib,>= -4, arg2, $bcopy_f.word
	stws,ma	t1, 4(sr0, arg0)

$bcopy_f.cleanup
	addib,=,n 4, arg2, $bcopy_f.done
	ldws	0(sr0, arg1), t1
	add	arg0, arg2, arg0
	b	$bcopy_f.done
	stbys,e	t1, 0(sr0, arg0)

$bcopy_f.unaligned
	sub,>=	t4, t3, t2
	ldwm	4(sr0, arg1), ret1
	zdep	t2, 28, 29, t1
	mtsar	t1
	
	addi	-16, arg2, arg2
$bcopy_f.loop16u
	ldws,ma	4(sr0, arg1), t1
	ldws,ma	4(sr0, arg1), t2
	ldws,ma	4(sr0, arg1), t3
	ldws,ma	4(sr0, arg1), t4
	vshd	ret1, t1, r31
	stbys,b,m r31, 4(sr0, arg0)
	vshd	t1, t2, r31
	stws,ma	r31, 4(sr0, arg0)
	vshd	t2, t3, r31
	stws,ma	r31, 4(sr0, arg0)
	vshd	t3, t4, r31
	stws,ma	r31, 4(sr0, arg0)
	addib,>= -16, arg2, $bcopy_f.loop16u
	copy	t4, ret1

	addib,<,n 12, arg2, $bcopy_f.cleanup_un
$bcopy_f.word_un
	ldws,ma	4(sr0, arg1), t1
	vshd	ret1, t1, t2
	addib,<	-4, arg2, $bcopy_f.cleanup1_un
	stws,ma	t2, 4(sr0, arg0)
	ldws,ma	4(sr0, arg1), ret1
	vshd	t1, ret1, t2
	addib,>= -4, arg2, $bcopy_f.word_un
	stws,ma	t2, 4(sr0, arg0)

$bcopy_f.cleanup_un
	addib,<=,n 4, arg2, $bcopy_f.done
	mfctl	sar, t4
	add	arg0, arg2, arg0
	extru	t4, 28, 2, t4
	sub,<=	arg2, t4, r0
	ldws,ma	4(sr0, arg1), t1
	vshd	ret1, t1, t2
	b	$bcopy_f.done
	stbys,e	t2, 0(sr0, arg0)

$bcopy_f.cleanup1_un
	b	$bcopy_f.cleanup_un
	copy	t1, ret1

$bcopy_f.byte
	comb,>=,n r0, arg2, $bcopy_f.done
$bcopy_f.byte_loop
	ldbs,ma	1(sr0, arg1), t1
	addib,<> -1, arg2, $bcopy_f.byte_loop
	stbs,ma	t1, 1(sr0, arg0)
$bcopy_f.done

	bv	0(rp)
	nop
$bcopy.reverse
	copy	arg0, ret0
	add	arg1, arg2, arg1
	add	arg0, arg2, arg0


$bcopy_r.byte
	comb,>=,n r0, arg2, $bcopy_r.done
$bcopy_r.byte_loop
	ldbs,mb	-1(sr0, arg1), t1
	addib,<> -1, arg2, $bcopy_r.byte_loop
	stbs,mb	t1, -1(sr0, arg0)
$bcopy_r.done

	bv	0(rp)
	nop
EXIT_WEAK(bcopy)
ALTEXIT_STRONG(memmove)

	.end
@


1.4
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d155 1
@


1.3
log
@memmove/bcopy from libkern, almost certainly the unrolling here is
beneficial because the compiler tends to do small known-size blocks
inline.  Continue using the MI memcpy.c for now.
ok miod
@
text
@d34 1
a34 5

#undef _LOCORE
#define _LOCORE
#include <machine/asm.h>
#include <machine/frame.h>
d154 1
a154 1
EXIT(bcopy)
@


1.2
log
@this is the bcopy we use
@
text
@d1 1
a1 2
/*	$OpenBSD: memmove.S,v 1.1 1998/12/17 16:56:47 mickey Exp $	*/

d3 1
a3 1
 *  (c) Copyright 1988 HEWLETT-PACKARD COMPANY
d5 1
a5 10
 *  To anyone who acknowledges that this file is provided "AS IS"
 *  without any express or implied warranty:
 *      permission to use, copy, modify, and distribute this file
 *  for any purpose is hereby granted without fee, provided that
 *  the above copyright notice and this notice appears in all
 *  copies, and that the name of Hewlett-Packard Company not be
 *  used in advertising or publicity pertaining to distribution
 *  of the software without specific, written prior permission.
 *  Hewlett-Packard Company makes no representations about the
 *  suitability of this software for any purpose.
d8 2
a9 2
 * Copyright (c) 1990,1994 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
d11 8
a18 3
 * THE UNIVERSITY OF UTAH AND CSL PROVIDE THIS SOFTWARE IN ITS "AS IS"
 * CONDITION, AND DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
 * WHATSOEVER RESULTING FROM ITS USE.
d20 10
a29 2
 * CSL requests users of this software to return to csl-dist@@cs.utah.edu any
 * improvements that they make and grant CSL redistribution rights.
a30 2
 * 	Utah $Hdr: bcopy.s 1.10 94/12/14$
 *	Author: Bob Wheeler, University of Utah CSL
d33 4
d38 1
a39 9
/*
 * void
 * memmove(dst, src, count)
 *	vm_offset_t	dst;
 *	vm_offset_t	src;
 *	int		count;
 */
ENTRY(memmove)
	/* fall through */
d41 118
a158 206
/*
 * void
 * memcpy(dst, src, count)
 *	vm_offset_t	dst;
 *	vm_offset_t	src;
 *	int		count;
 */
ALTENTRY(memcpy)
	copy	arg0,arg3
	copy	arg1,arg0
	copy	arg3,arg1

        comb,>=,n r0,arg2,$bcopy_exit

	/*
	 * See if the source and destination are word aligned and if the count
	 * is an integer number of words. If so then we can use an optimized 
	 * routine. If not then branch to bcopy_checkalign and see what we can
	 * do there.
	 */

        or	arg0,arg1,t1
        or	t1,arg2,t2
        extru,= t2,31,2,r0
        b,n     $bcopy_checkalign

        addib,<,n -16,arg2,$bcopy_movewords

	/*
	 * We can move the data in 4 word moves. We'll use 4 registers to 
	 * avoid interlock and pipeline stalls.
	 */

$bcopy_loop16

        ldwm	16(arg0),t1
        ldw	-12(arg0),t2
        ldw     -8(arg0),t3
        ldw     -4(arg0),t4
        stwm    t1,16(arg1)
        stw     t2,-12(arg1)
        stw     t3,-8(arg1)
        addib,>= -16,arg2,$bcopy_loop16
        stw     t4,-4(arg1)


	/*
	 * We have already decremented the count by 16, add 12 to it and then 
	 * we can test if there is at least 1 word left to move.
	 */

$bcopy_movewords
        addib,<,n 12,arg2,$bcopy_exit

	/*
	 * Clean up any remaining words that were not moved in the 16 byte
	 * moves
	 */

$bcopy_loop4
        ldwm	4(arg0),t1
        addib,>= -4,arg2,$bcopy_loop4
        stwm    t1,4(arg1)

	b,n 	$bcopy_exit


$bcopy_checkalign

	/*
	 * The source or destination is not word aligned or the count is not 
	 * an integral number of words. If we are dealing with less than 16 
	 * bytes then just do it byte by byte. Otherwise, see if the data has 
	 * the same basic alignment. We will add in the byte offset to size to
	 * keep track of what we have to move even though the stbys instruction
	 * won't physically move it. 
	 */

        comib,>= 15,arg2,$bcopy_byte
        extru   arg0,31,2,t1
        extru   arg1,31,2,t2
        add     arg2,t2,arg2
        comb,<> t2,t1,$bcopy_unaligned
        dep     0,31,2,arg0

	/*
	 * the source and destination have the same basic alignment. We will 
	 * move the data in blocks of 16 bytes as long as we can and then 
	 * we'll go to the 4 byte moves.
	 */

        addib,<,n -16,arg2,$bcopy_aligned2

$bcopy_loop_aligned4
        ldwm	16(arg0),t1
        ldw     -12(arg0),t2
        ldw     -8(arg0),t3
        ldw     -4(arg0),t4
        stbys,b,m t1,4(arg1)
        stwm    t2,4(arg1)
        stwm    t3,4(arg1)
        addib,>= -16,arg2,$bcopy_loop_aligned4
        stwm    t4,4(arg1)

	/*
	 * see if there is anything left that needs to be moved in a word move.
	 * Since the count was decremented by 16, add 12 to test if there are 
	 * any full word moves left to do.
	 */

$bcopy_aligned2
        addib,<,n 12,arg2,$bcopy_cleanup

$bcopy_loop_aligned2
        ldws,ma	4(arg0),t1
        addib,>= -4,arg2,$bcopy_loop_aligned2
        stbys,b,m t1,4(arg1)

	/*
	 * move the last bytes that may be unaligned on a word boundary
	 */

$bcopy_cleanup
         addib,=,n 4,arg2,$bcopy_exit
         ldws	0(arg0),t1
         add    arg1,arg2,arg1
         b      $bcopy_exit
         stbys,e t1,0(arg1)

	/*
	 * The source and destination are not alligned on the same boundary 
	 * types. We will have to shift the data around. Figure out the shift 
	 * amount and load it into cr11.
	 */

$bcopy_unaligned
        sub,>=	t2,t1,t3
        ldwm    4(arg0),t1
        zdep    t3,28,29,t4
        mtctl   t4,11

	/*
	 * see if we can do some of this work in blocks of 16 bytes
	 */

        addib,<,n -16,arg2,$bcopy_unaligned_words

$bcopy_unaligned4
        ldwm	16(arg0),t2
	ldw	-12(arg0),t3
	ldw	-8(arg0),t4
	ldw	-4(arg0),r1
        vshd	t1,t2,r28
        stbys,b,m r28,4(arg1)
        vshd	t2,t3,r28
        stwm	r28,4(arg1)
        vshd	t3,t4,r28
        stwm	r28,4(arg1)
        vshd	t4,r1,r28
        stwm   	r28,4(arg1)
        addib,>= -16,arg2,$bcopy_unaligned4
	copy	r1,t1

	/*
	 * see if there is a full word that we can transfer
	 */

$bcopy_unaligned_words
        addib,<,n 12,arg2,$bcopy_unaligned_cleanup1

$bcopy_unaligned_loop
        ldwm	4(arg0),t2
        vshd    t1,t2,t3
        addib,< -4,arg2,$bcopy_unaligned_cleanup2
        stbys,b,m t3,4(arg1)

        ldwm	4(arg0),t1
        vshd    t2,t1,t3
        addib,>= -4,arg2,$bcopy_unaligned_loop
        stbys,b,m t3,4(arg1)

$bcopy_unaligned_cleanup1
	copy	t1,t2

$bcopy_unaligned_cleanup2
	addib,<=,n 4,arg2,$bcopy_exit
        add	arg1,arg2,arg1
	mfctl	sar,t3
	extru	t3,28,2,t3
	sub,<=	arg2,t3,r0
        ldwm    4(arg0),t1
        vshd    t2,t1,t3
        b       $bcopy_exit
        stbys,e t3,0(arg1)

	/*
	 * move data one byte at a time
	 */

$bcopy_byte
        comb,>=,n r0,arg2,$bcopy_exit

$bcopy_loop_byte
        ldbs,ma	1(arg0),t1
        addib,> -1,arg2,$bcopy_loop_byte
        stbs,ma t1,1(arg1) 
d160 1
a160 2
$bcopy_exit
EXIT(memmove)
@


1.1
log
@some missing parts; sys is not ready yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

