head	1.11;
access;
symbols
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	2017.02.27.11.38.08;	author jca;	state Exp;
branches;
next	1.10;
commitid	drUqtHQk8flZF7Hy;

1.10
date	2017.02.18.19.23.05;	author jca;	state Exp;
branches;
next	1.9;
commitid	6EwZbn7a3sVTI0GZ;

1.9
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	ZDWhDXAAMFWxMzBj;

1.8
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2014.03.14.11.07.33;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2013.07.12.14.36.22;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.01.20.22.27;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.29.22.51.35;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.11.24.13.59.53;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.09.08.11.08.21;	author eric;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Add support for RES_USE_DNSSEC

RES_USE_DNSSEC is implemented by setting the DNSSEC DO bit in outgoing
queries.  The resolver is then supposed to set the AD bit in the reply
if it managed to validate the answer through DNSSEC.  Useful when the
application doesn't implement validation internally.  This scheme
assumes that the validating resolver is trusted and that the
communication channel between the validating resolver and and the client
is secure.

ok eric@@ gilles@@
@
text
@/*	$OpenBSD: res_mkquery.c,v 1.10 2017/02/18 19:23:05 jca Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/nameser.h> /* for MAXDNAME */
#include <netdb.h>

#include <asr.h>
#include <errno.h>
#include <resolv.h>
#include <string.h>

#include "asr_private.h"

/* This function is apparently needed by some ports. */
int
res_mkquery(int op, const char *dname, int class, int type,
    const unsigned char *data, int datalen, const unsigned char *newrr,
    unsigned char *buf, int buflen)
{
	struct asr_ctx		*ac;
	struct asr_pack		 p;
	struct asr_dns_header	 h;
	char			 fqdn[MAXDNAME];
	char			 dn[MAXDNAME];

	/* we currently only support QUERY */
	if (op != QUERY || data)
		return (-1);

	if (dname[0] == '\0' || dname[strlen(dname) - 1] != '.') {
		if (strlcpy(fqdn, dname, sizeof(fqdn)) >= sizeof(fqdn) ||
		    strlcat(fqdn, ".", sizeof(fqdn)) >= sizeof(fqdn))
			return (-1);
		dname = fqdn;
	}

	if (_asr_dname_from_fqdn(dname, dn, sizeof(dn)) == -1)
		return (-1);

	ac = _asr_use_resolver(NULL);

	memset(&h, 0, sizeof h);
	h.id = res_randomid();
	if (ac->ac_options & RES_RECURSE)
		h.flags |= RD_MASK;
	h.qdcount = 1;
	if (ac->ac_options & (RES_USE_EDNS0 | RES_USE_DNSSEC))
		h.arcount = 1;

	_asr_pack_init(&p, buf, buflen);
	_asr_pack_header(&p, &h);
	_asr_pack_query(&p, type, class, dn);
	if (ac->ac_options & (RES_USE_EDNS0 | RES_USE_DNSSEC))
		_asr_pack_edns0(&p, MAXPACKETSZ,
		    ac->ac_options & RES_USE_DNSSEC);

	_asr_ctx_unref(ac);

	if (p.err)
		return (-1);

	return (p.offset);
}

/*
 * This function is not documented, but used by sendmail.
 * Put here because it uses asr_private.h too.
 */
int
res_querydomain(const char *name,
    const char *domain,
    int class,
    int type,
    u_char *answer,
    int anslen)
{
	char	fqdn[MAXDNAME], ndom[MAXDNAME];
	size_t	n;

	/* we really want domain to end with a dot for now */
	if (domain && ((n = strlen(domain)) == 0 || domain[n - 1 ] != '.')) {
		if (strlcpy(ndom, domain, sizeof(ndom)) >= sizeof(ndom) ||
		    strlcat(ndom, ".", sizeof(ndom)) >= sizeof(ndom)) {
			h_errno = NETDB_INTERNAL;
			errno = EINVAL;
			return (-1);
		}
		domain = ndom;
	}

	if (_asr_make_fqdn(name, domain, fqdn, sizeof fqdn) == 0) {
		h_errno = NETDB_INTERNAL;
		errno = EINVAL;
		return (-1);
	}

	return (res_query(fqdn, class, type, answer, anslen));
}
@


1.10
log
@Add EDNS0 support.

EDNS allows for various DNS extensions, among which UDP DNS packets size
bigger than 512 bytes.  The default is still to not advertize anything.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_mkquery.c,v 1.9 2015/09/09 15:49:34 deraadt Exp $	*/
d64 1
a64 1
	if (ac->ac_options & RES_USE_EDNS0)
d70 3
a72 2
	if (ac->ac_options & RES_USE_EDNS0)
		_asr_pack_edns0(&p, MAXPACKETSZ);
@


1.9
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: res_mkquery.c,v 1.8 2014/03/26 18:13:15 eric Exp $	*/
d64 2
d70 2
@


1.8
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_mkquery.c,v 1.7 2014/03/14 11:07:33 eric Exp $	*/
d54 1
a54 1
	if (asr_dname_from_fqdn(dname, dn, sizeof(dn)) == -1)
d57 1
a57 1
	ac = asr_use_resolver(NULL);
d65 3
a67 3
	asr_pack_init(&p, buf, buflen);
	asr_pack_header(&p, &h);
	asr_pack_query(&p, type, class, dn);
d69 1
a69 1
	asr_ctx_unref(ac);
d103 1
a103 1
	if (asr_make_fqdn(name, domain, fqdn, sizeof fqdn) == 0) {
@


1.7
log
@prefix structure names to avoid ambiguity and possible collisions when
the API gets public.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_mkquery.c,v 1.6 2013/07/12 14:36:22 eric Exp $	*/
d19 1
d22 1
d24 1
a28 1
#include "asr.h"
@


1.6
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_mkquery.c,v 1.5 2013/04/01 20:22:27 eric Exp $	*/
d35 5
a39 5
	struct asr_ctx	*ac;
	struct pack	 p;
	struct header	 h;
	char		 fqdn[MAXDNAME];
	char		 dn[MAXDNAME];
@


1.5
log
@properly check for domain name truncation at various places and fail
if that happens.

prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_mkquery.c,v 1.4 2013/03/29 22:51:35 guenther Exp $	*/
d52 1
a52 1
	if (dname_from_fqdn(dname, dn, sizeof(dn)) == -1)
d63 3
a65 3
	pack_init(&p, buf, buflen);
	pack_header(&p, &h);
	pack_query(&p, type, class, dn);
@


1.4
log
@res_querydomain()'s code to terminate the domain with '.' had the assignment
flipped so that it always used a domain of ".."

Heavy lifting by otto@@
ok eric@@ otto@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_mkquery.c,v 1.3 2012/11/24 15:12:48 eric Exp $	*/
d46 2
a47 2
		strlcpy(fqdn, dname, sizeof fqdn);
		if (strlcat(fqdn, ".", sizeof fqdn) >= sizeof fqdn)
d92 6
a97 2
		strlcpy(ndom, domain, sizeof ndom);
		strlcat(ndom, ".", sizeof ndom);
d102 1
a102 1
		h_errno = NO_RECOVERY;
@


1.3
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: res_mkquery.c,v 1.2 2012/11/24 13:59:53 eric Exp $	*/
a91 1
		domain = ndom;
d94 1
@


1.2
log
@make separate structures for pack and unpack
@
text
@d1 1
a1 1
/*	$OpenBSD: res_mkquery.c,v 1.1 2012/09/08 11:08:21 eric Exp $	*/
d20 1
a21 1
#include <arpa/nameser.h> /* for MAXDNAME */
@


1.1
log
@split asr_resolver.c into different files to overlay the libc/net
resolver implementation.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_resolver.c,v 1.10 2012/08/19 17:59:15 eric Exp $	*/
d36 1
a36 1
	struct packed	 p;
d63 1
a63 1
	packed_init(&p, buf, buflen);
@

