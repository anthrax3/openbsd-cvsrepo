head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.2
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.1.0.2
	OPENBSD_5_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2017.02.23.17.04.02;	author eric;	state Exp;
branches;
next	1.10;
commitid	A5SxxxFpG2Lk4uBi;

1.10
date	2015.09.20.14.19.21;	author eric;	state Exp;
branches;
next	1.9;
commitid	QoXCnUzVxYUpwKcZ;

1.9
date	2015.09.14.11.52.49;	author guenther;	state Exp;
branches;
next	1.8;
commitid	KzuByhRo5iAIKcqw;

1.8
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	ZDWhDXAAMFWxMzBj;

1.7
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.25.19.48.11;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2013.07.12.14.36.22;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2013.04.30.12.02.39;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.18.13.49.13;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Put a common subq pointer in the query struct, rather than one in each
element of the union.

ok gilles@@ millert@@ krw@@
@
text
@/*	$OpenBSD: getrrsetbyname_async.c,v 1.10 2015/09/20 14:19:21 eric Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <netdb.h>

#include <asr.h>
#include <errno.h>
#include <resolv.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "asr_private.h"

static int getrrsetbyname_async_run(struct asr_query *, struct asr_result *);
static void get_response(struct asr_result *, const char *, int);

struct asr_query *
getrrsetbyname_async(const char *hostname, unsigned int rdclass,
    unsigned int rdtype, unsigned int flags, void *asr)
{
	struct asr_ctx	 *ac;
	struct asr_query *as;

	ac = _asr_use_resolver(asr);
	if ((as = _asr_async_new(ac, ASR_GETRRSETBYNAME)) == NULL)
		goto abort; /* errno set */
	as->as_run = getrrsetbyname_async_run;

	as->as.rrset.flags = flags;
	as->as.rrset.class = rdclass;
	as->as.rrset.type = rdtype;
	as->as.rrset.name = strdup(hostname);
	if (as->as.rrset.name == NULL)
		goto abort; /* errno set */

	_asr_ctx_unref(ac);
	return (as);
    abort:
	if (as)
		_asr_async_free(as);

	_asr_ctx_unref(ac);
	return (NULL);
}
DEF_WEAK(getrrsetbyname_async);

static int
getrrsetbyname_async_run(struct asr_query *as, struct asr_result *ar)
{
    next:
	switch (as->as_state) {

	case ASR_STATE_INIT:

		/* Check for invalid class and type. */
		if (as->as.rrset.class > 0xffff || as->as.rrset.type > 0xffff) {
			ar->ar_rrset_errno = ERRSET_INVAL;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		/* Do not allow queries of class or type ANY. */
		if (as->as.rrset.class == 0xff || as->as.rrset.type == 0xff) {
			ar->ar_rrset_errno = ERRSET_INVAL;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		/* Do not allow flags yet, unimplemented. */
		if (as->as.rrset.flags) {
			ar->ar_rrset_errno = ERRSET_INVAL;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		/* Create a delegate the lookup to a subquery. */
		as->as_subq = _res_query_async_ctx(
		    as->as.rrset.name,
		    as->as.rrset.class,
		    as->as.rrset.type,
		    as->as_ctx);
		if (as->as_subq == NULL) {
			ar->ar_rrset_errno = ERRSET_FAIL;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		async_set_state(as, ASR_STATE_SUBQUERY);
		break;

	case ASR_STATE_SUBQUERY:

		if ((asr_run(as->as_subq, ar)) == ASYNC_COND)
			return (ASYNC_COND);

		as->as_subq = NULL;

		/* No packet received.*/
		if (ar->ar_datalen == -1) {
			switch (ar->ar_h_errno) {
			case HOST_NOT_FOUND:
				ar->ar_rrset_errno = ERRSET_NONAME;
				break;
			case NO_DATA:
				ar->ar_rrset_errno = ERRSET_NODATA;
				break;
			default:
				ar->ar_rrset_errno = ERRSET_FAIL;
				break;
			}
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		/* Got a packet but no answer. */
		if (ar->ar_count == 0) {
			free(ar->ar_data);
			switch (ar->ar_rcode) {
			case NXDOMAIN:
				ar->ar_rrset_errno = ERRSET_NONAME;
				break;
			case NOERROR:
				ar->ar_rrset_errno = ERRSET_NODATA;
				break;
			default:
				ar->ar_rrset_errno = ERRSET_FAIL;
				break;
			}
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		get_response(ar, ar->ar_data, ar->ar_datalen);
		free(ar->ar_data);
		async_set_state(as, ASR_STATE_HALT);
		break;

	case ASR_STATE_HALT:
		if (ar->ar_rrset_errno)
			ar->ar_rrsetinfo = NULL;
		return (ASYNC_DONE);

	default:
		ar->ar_rrset_errno = ERRSET_FAIL;
		async_set_state(as, ASR_STATE_HALT);
		break;
	}
	goto next;
}

/* The rest of this file is taken from the orignal implementation. */

/* $OpenBSD: getrrsetbyname_async.c,v 1.10 2015/09/20 14:19:21 eric Exp $ */

/*
 * Copyright (c) 2001 Jakob Schlyter. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Portions Copyright (c) 1999-2001 Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM
 * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * INTERNET SOFTWARE CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#define MAXPACKET 1024*64

struct dns_query {
	char			*name;
	u_int16_t		type;
	u_int16_t		class;
	struct dns_query	*next;
};

struct dns_rr {
	char			*name;
	u_int16_t		type;
	u_int16_t		class;
	u_int16_t		ttl;
	u_int16_t		size;
	void			*rdata;
	struct dns_rr		*next;
};

struct dns_response {
	HEADER			header;
	struct dns_query	*query;
	struct dns_rr		*answer;
	struct dns_rr		*authority;
	struct dns_rr		*additional;
};

static struct dns_response *parse_dns_response(const u_char *, int);
static struct dns_query *parse_dns_qsection(const u_char *, int,
    const u_char **, int);
static struct dns_rr *parse_dns_rrsection(const u_char *, int, const u_char **,
    int);

static void free_dns_query(struct dns_query *);
static void free_dns_rr(struct dns_rr *);
static void free_dns_response(struct dns_response *);

static int count_dns_rr(struct dns_rr *, u_int16_t, u_int16_t);

static void
get_response(struct asr_result *ar, const char *pkt, int pktlen)
{
	struct rrsetinfo *rrset = NULL;
	struct dns_response *response = NULL;
	struct dns_rr *rr;
	struct rdatainfo *rdata;
	unsigned int index_ans, index_sig;

	/* parse result */
	response = parse_dns_response(pkt, pktlen);
	if (response == NULL) {
		ar->ar_rrset_errno = ERRSET_FAIL;
		goto fail;
	}

	if (response->header.qdcount != 1) {
		ar->ar_rrset_errno = ERRSET_FAIL;
		goto fail;
	}

	/* initialize rrset */
	rrset = calloc(1, sizeof(struct rrsetinfo));
	if (rrset == NULL) {
		ar->ar_rrset_errno = ERRSET_NOMEMORY;
		goto fail;
	}
	rrset->rri_rdclass = response->query->class;
	rrset->rri_rdtype = response->query->type;
	rrset->rri_ttl = response->answer->ttl;
	rrset->rri_nrdatas = response->header.ancount;

	/* check for authenticated data */
	if (response->header.ad == 1)
		rrset->rri_flags |= RRSET_VALIDATED;

	/* copy name from answer section */
	rrset->rri_name = strdup(response->answer->name);
	if (rrset->rri_name == NULL) {
		ar->ar_rrset_errno = ERRSET_NOMEMORY;
		goto fail;
	}

	/* count answers */
	rrset->rri_nrdatas = count_dns_rr(response->answer, rrset->rri_rdclass,
	    rrset->rri_rdtype);
	rrset->rri_nsigs = count_dns_rr(response->answer, rrset->rri_rdclass,
	    T_RRSIG);

	/* allocate memory for answers */
	rrset->rri_rdatas = calloc(rrset->rri_nrdatas,
	    sizeof(struct rdatainfo));
	if (rrset->rri_rdatas == NULL) {
		ar->ar_rrset_errno = ERRSET_NOMEMORY;
		goto fail;
	}

	/* allocate memory for signatures */
	rrset->rri_sigs = calloc(rrset->rri_nsigs, sizeof(struct rdatainfo));
	if (rrset->rri_sigs == NULL) {
		ar->ar_rrset_errno = ERRSET_NOMEMORY;
		goto fail;
	}

	/* copy answers & signatures */
	for (rr = response->answer, index_ans = 0, index_sig = 0;
	    rr; rr = rr->next) {

		rdata = NULL;

		if (rr->class == rrset->rri_rdclass &&
		    rr->type  == rrset->rri_rdtype)
			rdata = &rrset->rri_rdatas[index_ans++];

		if (rr->class == rrset->rri_rdclass &&
		    rr->type  == T_RRSIG)
			rdata = &rrset->rri_sigs[index_sig++];

		if (rdata) {
			rdata->rdi_length = rr->size;
			rdata->rdi_data   = malloc(rr->size);

			if (rdata->rdi_data == NULL) {
				ar->ar_rrset_errno = ERRSET_NOMEMORY;
				goto fail;
			}
			memcpy(rdata->rdi_data, rr->rdata, rr->size);
		}
	}
	free_dns_response(response);

	ar->ar_rrsetinfo = rrset;
	ar->ar_rrset_errno = ERRSET_SUCCESS;
	return;

fail:
	if (rrset != NULL)
		freerrset(rrset);
	if (response != NULL)
		free_dns_response(response);
}

/*
 * DNS response parsing routines
 */
static struct dns_response *
parse_dns_response(const u_char *answer, int size)
{
	struct dns_response *resp;
	const u_char *cp;

	/* allocate memory for the response */
	resp = calloc(1, sizeof(*resp));
	if (resp == NULL)
		return (NULL);

	/* initialize current pointer */
	cp = answer;

	/* copy header */
	memcpy(&resp->header, cp, HFIXEDSZ);
	cp += HFIXEDSZ;

	/* fix header byte order */
	resp->header.qdcount = ntohs(resp->header.qdcount);
	resp->header.ancount = ntohs(resp->header.ancount);
	resp->header.nscount = ntohs(resp->header.nscount);
	resp->header.arcount = ntohs(resp->header.arcount);

	/* there must be at least one query */
	if (resp->header.qdcount < 1) {
		free_dns_response(resp);
		return (NULL);
	}

	/* parse query section */
	resp->query = parse_dns_qsection(answer, size, &cp,
	    resp->header.qdcount);
	if (resp->header.qdcount && resp->query == NULL) {
		free_dns_response(resp);
		return (NULL);
	}

	/* parse answer section */
	resp->answer = parse_dns_rrsection(answer, size, &cp,
	    resp->header.ancount);
	if (resp->header.ancount && resp->answer == NULL) {
		free_dns_response(resp);
		return (NULL);
	}

	/* parse authority section */
	resp->authority = parse_dns_rrsection(answer, size, &cp,
	    resp->header.nscount);
	if (resp->header.nscount && resp->authority == NULL) {
		free_dns_response(resp);
		return (NULL);
	}

	/* parse additional section */
	resp->additional = parse_dns_rrsection(answer, size, &cp,
	    resp->header.arcount);
	if (resp->header.arcount && resp->additional == NULL) {
		free_dns_response(resp);
		return (NULL);
	}

	return (resp);
}

static struct dns_query *
parse_dns_qsection(const u_char *answer, int size, const u_char **cp, int count)
{
	struct dns_query *head, *curr, *prev;
	int i, length;
	char name[MAXDNAME];

	for (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {

		/* allocate and initialize struct */
		curr = calloc(1, sizeof(struct dns_query));
		if (curr == NULL) {
			free_dns_query(head);
			return (NULL);
		}
		if (head == NULL)
			head = curr;
		if (prev != NULL)
			prev->next = curr;

		/* name */
		length = dn_expand(answer, answer + size, *cp, name,
		    sizeof(name));
		if (length < 0) {
			free_dns_query(head);
			return (NULL);
		}
		curr->name = strdup(name);
		if (curr->name == NULL) {
			free_dns_query(head);
			return (NULL);
		}
		*cp += length;

		/* type */
		curr->type = _getshort(*cp);
		*cp += INT16SZ;

		/* class */
		curr->class = _getshort(*cp);
		*cp += INT16SZ;
	}

	return (head);
}

static struct dns_rr *
parse_dns_rrsection(const u_char *answer, int size, const u_char **cp,
    int count)
{
	struct dns_rr *head, *curr, *prev;
	int i, length;
	char name[MAXDNAME];

	for (i = 1, head = NULL, prev = NULL; i <= count; i++, prev = curr) {

		/* allocate and initialize struct */
		curr = calloc(1, sizeof(struct dns_rr));
		if (curr == NULL) {
			free_dns_rr(head);
			return (NULL);
		}
		if (head == NULL)
			head = curr;
		if (prev != NULL)
			prev->next = curr;

		/* name */
		length = dn_expand(answer, answer + size, *cp, name,
		    sizeof(name));
		if (length < 0) {
			free_dns_rr(head);
			return (NULL);
		}
		curr->name = strdup(name);
		if (curr->name == NULL) {
			free_dns_rr(head);
			return (NULL);
		}
		*cp += length;

		/* type */
		curr->type = _getshort(*cp);
		*cp += INT16SZ;

		/* class */
		curr->class = _getshort(*cp);
		*cp += INT16SZ;

		/* ttl */
		curr->ttl = _getlong(*cp);
		*cp += INT32SZ;

		/* rdata size */
		curr->size = _getshort(*cp);
		*cp += INT16SZ;

		/* rdata itself */
		curr->rdata = malloc(curr->size);
		if (curr->rdata == NULL) {
			free_dns_rr(head);
			return (NULL);
		}
		memcpy(curr->rdata, *cp, curr->size);
		*cp += curr->size;
	}

	return (head);
}

static void
free_dns_query(struct dns_query *p)
{
	if (p == NULL)
		return;

	if (p->name)
		free(p->name);
	free_dns_query(p->next);
	free(p);
}

static void
free_dns_rr(struct dns_rr *p)
{
	if (p == NULL)
		return;

	if (p->name)
		free(p->name);
	if (p->rdata)
		free(p->rdata);
	free_dns_rr(p->next);
	free(p);
}

static void
free_dns_response(struct dns_response *p)
{
	if (p == NULL)
		return;

	free_dns_query(p->query);
	free_dns_rr(p->answer);
	free_dns_rr(p->authority);
	free_dns_rr(p->additional);
	free(p);
}

static int
count_dns_rr(struct dns_rr *p, u_int16_t class, u_int16_t type)
{
	int n = 0;

	while (p) {
		if (p->class == class && p->type == type)
			n++;
		p = p->next;
	}

	return (n);
}
@


1.10
log
@remove bogus includes of err.h
@
text
@d1 1
a1 1
/*	$OpenBSD: getrrsetbyname_async.c,v 1.9 2015/09/14 11:52:49 guenther Exp $	*/
d97 1
a97 1
		as->as.rrset.subq = _res_query_async_ctx(
d102 1
a102 1
		if (as->as.rrset.subq == NULL) {
d113 1
a113 1
		if ((asr_run(as->as.rrset.subq, ar)) == ASYNC_COND)
d116 1
a116 1
		as->as.rrset.subq = NULL;
d173 1
a173 1
/* $OpenBSD: getrrsetbyname_async.c,v 1.9 2015/09/14 11:52:49 guenther Exp $ */
@


1.9
log
@Wrap <asr.h> so internal calls go direct and all the symbols are weak
@
text
@d1 1
a1 1
/*	$OpenBSD: getrrsetbyname_async.c,v 1.8 2015/09/09 15:49:34 deraadt Exp $	*/
a25 1
#include <err.h>
d173 1
a173 1
/* $OpenBSD: getrrsetbyname_async.c,v 1.8 2015/09/09 15:49:34 deraadt Exp $ */
@


1.8
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: getrrsetbyname_async.c,v 1.7 2014/03/26 18:13:15 eric Exp $	*/
d66 1
d174 1
a174 1
/* $OpenBSD: getrrsetbyname_async.c,v 1.7 2014/03/26 18:13:15 eric Exp $ */
@


1.7
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getrrsetbyname_async.c,v 1.6 2014/03/25 19:48:11 eric Exp $	*/
d45 2
a46 2
	ac = asr_use_resolver(asr);
	if ((as = asr_async_new(ac, ASR_GETRRSETBYNAME)) == NULL)
d57 1
a57 1
	asr_ctx_unref(ac);
d61 1
a61 1
		asr_async_free(as);
d63 1
a63 1
	asr_ctx_unref(ac);
d97 1
a97 1
		as->as.rrset.subq = res_query_async_ctx(
d173 1
a173 1
/* $OpenBSD: getrrsetbyname_async.c,v 1.6 2014/03/25 19:48:11 eric Exp $ */
@


1.6
log
@Cleanup and simplify the API to be exposed.  Use better names for
structures, functions and defines.

discussed with and ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getrrsetbyname_async.c,v 1.5 2013/07/12 14:36:22 eric Exp $	*/
d19 1
d23 1
d25 1
a27 1
#include <netdb.h>
a32 1
#include "asr.h"
d173 1
a173 1
/* $OpenBSD: getrrsetbyname_async.c,v 1.5 2013/07/12 14:36:22 eric Exp $ */
@


1.5
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getrrsetbyname_async.c,v 1.4 2013/04/30 12:02:39 eric Exp $	*/
d34 2
a35 2
static int getrrsetbyname_async_run(struct async *, struct async_res *);
static void get_response(struct async_res *, const char *, int);
d37 1
a37 1
struct async *
d39 1
a39 1
    unsigned int rdtype, unsigned int flags, struct asr *asr)
d41 2
a42 2
	struct asr_ctx	*ac;
	struct async	*as;
d67 1
a67 1
getrrsetbyname_async_run(struct async *as, struct async_res *ar)
d112 1
a112 1
		if ((asr_async_run(as->as.rrset.subq, ar)) == ASYNC_COND)
d172 1
a172 1
/* $OpenBSD: getrrsetbyname_async.c,v 1.4 2013/04/30 12:02:39 eric Exp $ */
d257 1
a257 1
get_response(struct async_res *ar, const char *pkt, int pktlen)
@


1.4
log
@Do not take external buffers for storing DNS responses in the internal
async API.  That is actually useless and it makes the code more
complicated.  The required buffers are always allocated when needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: getrrsetbyname_async.c,v 1.3 2012/11/24 15:12:48 eric Exp $	*/
d45 1
a45 1
	if ((as = async_new(ac, ASR_GETRRSETBYNAME)) == NULL)
d60 1
a60 1
		async_free(as);
d112 1
a112 1
		if ((async_run(as->as.rrset.subq, ar)) == ASYNC_COND)
d172 1
a172 1
/* $OpenBSD: getrrsetbyname_async.c,v 1.3 2012/11/24 15:12:48 eric Exp $ */
@


1.3
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: getrrsetbyname_async.c,v 1.2 2012/08/18 13:49:13 eric Exp $	*/
d100 1
a100 1
		    NULL, 0, as->as_ctx);
d172 1
a172 1
/* $OpenBSD: getrrsetbyname_async.c,v 1.2 2012/08/18 13:49:13 eric Exp $ */
@


1.2
log
@getrrsetyname() only uses ERRSET_* and is not supposed to set errno.
make sure to save and restore errno properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: getrrsetbyname_async.c,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
d17 1
a19 1

d22 1
a22 1
        
d70 1
a70 1
	switch(as->as_state) {
d119 1
a119 1
			switch(ar->ar_h_errno) {
d137 1
a137 1
			switch(ar->ar_rcode) {
d165 1
a165 1
                break;
d172 1
a172 1
/* $OpenBSD: getrrsetbyname_async.c,v 1.1 2012/04/14 09:24:18 eric Exp $ */
d580 1
a580 1
	while(p) {
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.10 2011/07/13 16:14:43 eric Exp $	*/
a157 1

d163 1
a163 3
		ar->ar_errno = EOPNOTSUPP;
		ar->ar_h_errno = NETDB_INTERNAL;
		ar->ar_gai_errno = EAI_SYSTEM;
d172 1
a172 1
/* $OpenBSD: getrrsetbyname.c,v 1.12 2010/06/29 09:22:06 deraadt Exp $ */
@

