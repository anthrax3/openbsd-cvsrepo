head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.6
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.46
date	2017.02.27.11.38.08;	author jca;	state Exp;
branches;
next	1.45;
commitid	drUqtHQk8flZF7Hy;

1.45
date	2017.02.27.11.31.01;	author jca;	state Exp;
branches;
next	1.44;
commitid	nLx1XPQ9CsmYhcqA;

1.44
date	2017.02.27.10.44.46;	author jca;	state Exp;
branches;
next	1.43;
commitid	MlNq0zVlbx0f2ABQ;

1.43
date	2017.02.23.17.04.02;	author eric;	state Exp;
branches;
next	1.42;
commitid	A5SxxxFpG2Lk4uBi;

1.42
date	2017.02.18.19.23.05;	author jca;	state Exp;
branches;
next	1.41;
commitid	6EwZbn7a3sVTI0GZ;

1.41
date	2017.02.17.22.24.45;	author eric;	state Exp;
branches;
next	1.40;
commitid	k26K9OiIpUIb57jZ;

1.40
date	2016.12.18.01.34.51;	author krw;	state Exp;
branches;
next	1.39;
commitid	Uf3iC73TalqxSmjM;

1.39
date	2016.08.20.19.08.57;	author jca;	state Exp;
branches;
next	1.38;
commitid	DfBglAWBQqyZcnO5;

1.38
date	2015.12.16.16.32.30;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	oPoFLo6QaSW21nLc;

1.37
date	2015.11.23.18.04.54;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	OVI7ORhlpJiMawqs;

1.36
date	2015.10.28.21.38.45;	author eric;	state Exp;
branches;
next	1.35;
commitid	qIEvBVRrIDarZ0X2;

1.35
date	2015.10.07.13.59.34;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	y9bDEcHtAU9tyNfU;

1.34
date	2015.10.03.22.35.30;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	cWyRO8MVry4Yvtp1;

1.33
date	2015.10.03.09.57.30;	author eric;	state Exp;
branches;
next	1.32;
commitid	mlCldxHCB9oTJwsK;

1.32
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	ZDWhDXAAMFWxMzBj;

1.31
date	2015.06.20.01.16.25;	author jca;	state Exp;
branches;
next	1.30;
commitid	w9FRtEnp4OyBKluV;

1.30
date	2015.06.04.19.23.17;	author eric;	state Exp;
branches;
next	1.29;
commitid	bIU7HKMB8ExoKdOm;

1.29
date	2015.05.29.08.49.37;	author eric;	state Exp;
branches;
next	1.28;
commitid	Tf6Q1D724C96QEJe;

1.28
date	2015.05.26.19.28.57;	author eric;	state Exp;
branches;
next	1.27;
commitid	zZUSsmIZVurlTa45;

1.27
date	2015.02.14.20.15.05;	author jca;	state Exp;
branches;
next	1.26;
commitid	lhC5X7zNGiUNaWY1;

1.26
date	2014.04.17.15.28.26;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.25.19.48.11;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2014.03.14.11.07.33;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2013.07.12.14.36.21;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.01.15.02.01;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.01.14.34.34;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.01.12.38.29;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.01.09.21.10;	author eric;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.27.17.31.01;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.30.12.02.39;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.02.16.38.37;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2013.04.01.16.04.03;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2013.04.01.15.49.54;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.01.08.54.06;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.01.07.52.06;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.27.07.40.41;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.24.13.59.53;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.09.12.15.32;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.09.09.42.06;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.06.13.57.51;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.05.21.49.12;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.09.05.15.56.13;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.07.20.41.52;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.14.12.06.13;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Add support for RES_USE_DNSSEC

RES_USE_DNSSEC is implemented by setting the DNSSEC DO bit in outgoing
queries.  The resolver is then supposed to set the AD bit in the reply
if it managed to validate the answer through DNSSEC.  Useful when the
application doesn't implement validation internally.  This scheme
assumes that the validating resolver is trusted and that the
communication channel between the validating resolver and and the client
is secure.

ok eric@@ gilles@@
@
text
@/*	$OpenBSD: asr_private.h,v 1.44 2017/02/27 10:44:46 jca Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>

#define QR_MASK		(0x1 << 15)
#define OPCODE_MASK	(0xf << 11)
#define AA_MASK		(0x1 << 10)
#define TC_MASK		(0x1 <<  9)
#define RD_MASK		(0x1 <<  8)
#define RA_MASK		(0x1 <<  7)
#define Z_MASK		(0x1 <<  6)
#define AD_MASK		(0x1 <<  5)
#define CD_MASK		(0x1 <<  4)
#define RCODE_MASK	(0xf)

#define OPCODE(v)	((v) & OPCODE_MASK)
#define RCODE(v)	((v) & RCODE_MASK)


struct asr_pack {
	char		*buf;
	size_t		 len;
	size_t		 offset;
	int		 err;
};

struct asr_unpack {
	const char	*buf;
	size_t		 len;
	size_t		 offset;
	int		 err;
};

struct asr_dns_header {
	uint16_t	id;
	uint16_t	flags;
	uint16_t	qdcount;
	uint16_t	ancount;
	uint16_t	nscount;
	uint16_t	arcount;
};

struct asr_dns_query {
	char		q_dname[MAXDNAME];
	uint16_t	q_type;
	uint16_t	q_class;
};

struct asr_dns_rr {
	char		rr_dname[MAXDNAME];
	uint16_t	rr_type;
	uint16_t	rr_class;
	uint32_t	rr_ttl;
	union {
		struct {
			char	cname[MAXDNAME];
		} cname;
		struct {
			uint16_t	preference;
			char		exchange[MAXDNAME];
		} mx;
		struct {
			char	nsname[MAXDNAME];
		} ns;
		struct {
			char	ptrname[MAXDNAME];
		} ptr;
		struct {
			char		mname[MAXDNAME];
			char		rname[MAXDNAME];
			uint32_t	serial;
			uint32_t	refresh;
			uint32_t	retry;
			uint32_t	expire;
			uint32_t	minimum;
		} soa;
		struct {
			struct in_addr	addr;
		} in_a;
		struct {
			struct in6_addr	addr6;
		} in_aaaa;
		struct {
			uint16_t	 rdlen;
			const void	*rdata;
		} other;
	} rr;
};


#define ASR_MAXNS	5
#define ASR_MAXDB	3
#define ASR_MAXDOM	10

enum async_type {
	ASR_SEND,
	ASR_SEARCH,
	ASR_GETRRSETBYNAME,
	ASR_GETHOSTBYNAME,
	ASR_GETHOSTBYADDR,
	ASR_GETNETBYNAME,
	ASR_GETNETBYADDR,
	ASR_GETADDRINFO,
	ASR_GETNAMEINFO,
};

#define	ASR_DB_FILE	'f'
#define	ASR_DB_DNS	'b'

struct asr_ctx {
	int		 ac_refcount;
	int		 ac_options;
	int		 ac_ndots;
	char		*ac_domain;
	int		 ac_domcount;
	char		*ac_dom[ASR_MAXDOM];
	int		 ac_dbcount;
	char		 ac_db[ASR_MAXDB + 1];
	int		 ac_family[3];

	int		 ac_nscount;
	int		 ac_nstimeout;
	int		 ac_nsretries;
	struct sockaddr *ac_ns[ASR_MAXNS];

};

struct asr {
	pid_t		 a_pid;
	time_t		 a_mtime;
	time_t		 a_rtime;
	struct asr_ctx	*a_ctx;
};

#define ASYNC_COND		0
#define ASYNC_DONE		1

#define	ASYNC_DOM_FQDN		0x00000001
#define	ASYNC_DOM_NDOTS		0x00000002
#define	ASYNC_DOM_DOMAIN	0x00000004
#define ASYNC_DOM_ASIS		0x00000008

#define	ASYNC_NODATA		0x00000100
#define	ASYNC_AGAIN		0x00000200

#define	ASYNC_EXTOBUF		0x00002000

#define	ASYNC_NO_INET		0x00010000
#define	ASYNC_NO_INET6		0x00020000

struct asr_query {
	int		(*as_run)(struct asr_query *, struct asr_result *);
	struct asr_ctx	*as_ctx;
	int		 as_type;
	int		 as_flags;
	int		 as_state;

	/* cond */
	int		 as_timeout;
	int		 as_fd;
	struct asr_query *as_subq;

	/* loop indices in ctx */
	int		 as_dom_step;
	int		 as_dom_idx;
	int		 as_dom_flags;
	int		 as_family_idx;
	int		 as_db_idx;

	int		 as_count;

	union {
		struct {
			uint16_t	 reqid;
			int		 class;
			int		 type;
			char		*dname;		/* not fqdn! */
			int		 rcode;		/* response code */
			int		 ancount;	/* answer count */

			int		 nsidx;
			int		 nsloop;

			/* io buffers for query/response */
			unsigned char	*obuf;
			size_t		 obuflen;
			size_t		 obufsize;
			unsigned char	*ibuf;
			size_t		 ibuflen;
			size_t		 ibufsize;
			size_t		 datalen; /* for tcp io */
			uint16_t	 pktlen;
		} dns;

		struct {
			int		 class;
			int		 type;
			char		*name;
			int		 saved_h_errno;
		} search;

		struct {
			int		 flags;
			int		 class;
			int		 type;
			char		*name;
		} rrset;

		struct {
			char		*name;
			int		 family;
			char		 addr[16];
			int		 addrlen;
			int		 subq_h_errno;
		} hostnamadr;

		struct {
			char		*name;
			int		 family;
			in_addr_t	 addr;
		} netnamadr;

		struct {
			char		*hostname;
			char		*servname;
			int		 port_tcp;
			int		 port_udp;
			union {
				struct sockaddr		sa;
				struct sockaddr_in	sain;
				struct sockaddr_in6	sain6;
			}		 sa;

			struct addrinfo	 hints;
			char		*fqdn;
			struct addrinfo	*aifirst;
			struct addrinfo	*ailast;
		} ai;

		struct {
			char		*hostname;
			char		*servname;
			size_t		 hostnamelen;
			size_t		 servnamelen;
			union {
				struct sockaddr		sa;
				struct sockaddr_in	sain;
				struct sockaddr_in6	sain6;
			}		 sa;
			int		 flags;
		} ni;
#define MAXTOKEN 10
	} as;

};

#define AS_DB(p) ((p)->as_ctx->ac_db[(p)->as_db_idx - 1])
#define AS_FAMILY(p) ((p)->as_ctx->ac_family[(p)->as_family_idx])

enum asr_state {
	ASR_STATE_INIT,
	ASR_STATE_NEXT_DOMAIN,
	ASR_STATE_NEXT_DB,
	ASR_STATE_SAME_DB,
	ASR_STATE_NEXT_FAMILY,
	ASR_STATE_NEXT_NS,
	ASR_STATE_UDP_SEND,
	ASR_STATE_UDP_RECV,
	ASR_STATE_TCP_WRITE,
	ASR_STATE_TCP_READ,
	ASR_STATE_PACKET,
	ASR_STATE_SUBQUERY,
	ASR_STATE_NOT_FOUND,
	ASR_STATE_HALT,
};

#define MAXPACKETSZ	4096

__BEGIN_HIDDEN_DECLS

/* asr_utils.c */
void _asr_pack_init(struct asr_pack *, char *, size_t);
int _asr_pack_header(struct asr_pack *, const struct asr_dns_header *);
int _asr_pack_query(struct asr_pack *, uint16_t, uint16_t, const char *);
int _asr_pack_edns0(struct asr_pack *, uint16_t, int);
void _asr_unpack_init(struct asr_unpack *, const char *, size_t);
int _asr_unpack_header(struct asr_unpack *, struct asr_dns_header *);
int _asr_unpack_query(struct asr_unpack *, struct asr_dns_query *);
int _asr_unpack_rr(struct asr_unpack *, struct asr_dns_rr *);
int _asr_sockaddr_from_str(struct sockaddr *, int, const char *);
ssize_t _asr_dname_from_fqdn(const char *, char *, size_t);
ssize_t _asr_addr_as_fqdn(const char *, int, char *, size_t);

/* asr.c */
void _asr_resolver_done(void *);
struct asr_ctx *_asr_use_resolver(void *);
struct asr_ctx *_asr_no_resolver(void);
void _asr_ctx_unref(struct asr_ctx *);
struct asr_query *_asr_async_new(struct asr_ctx *, int);
void _asr_async_free(struct asr_query *);
size_t _asr_make_fqdn(const char *, const char *, char *, size_t);
char *_asr_strdname(const char *, char *, size_t);
int _asr_iter_db(struct asr_query *);
int _asr_parse_namedb_line(FILE *, char **, int, char *, size_t);

/* *_async.c */
struct asr_query *_res_query_async_ctx(const char *, int, int, struct asr_ctx *);
struct asr_query *_res_search_async_ctx(const char *, int, int, struct asr_ctx *);
struct asr_query *_gethostbyaddr_async_ctx(const void *, socklen_t, int,
    struct asr_ctx *);

int _asr_iter_domain(struct asr_query *, const char *, char *, size_t);

#ifdef DEBUG

#define DPRINT(...)		do { if(_asr_debug) {		\
		fprintf(_asr_debug, __VA_ARGS__);		\
	} } while (0)
#define DPRINT_PACKET(n, p, s)	do { if(_asr_debug) {		\
		fprintf(_asr_debug, "----- %s -----\n", n);	\
		_asr_dump_packet(_asr_debug, (p), (s));		\
		fprintf(_asr_debug, "--------------\n");		\
	} } while (0)

#else /* DEBUG */

#define DPRINT(...)
#define DPRINT_PACKET(...)

#endif /* DEBUG */

const char *_asr_querystr(int);
const char *_asr_statestr(int);
const char *_asr_transitionstr(int);
const char *_asr_print_sockaddr(const struct sockaddr *, char *, size_t);
void _asr_dump_config(FILE *, struct asr *);
void _asr_dump_packet(FILE *, const void *, size_t);

extern FILE *_asr_debug;

#define async_set_state(a, s) do {		\
	DPRINT("asr: [%s@@%p] %s -> %s\n",	\
		_asr_querystr((a)->as_type),	\
		as,				\
		_asr_statestr((a)->as_state),	\
		_asr_statestr((s)));		\
	(a)->as_state = (s); } while (0)

__END_HIDDEN_DECLS
@


1.45
log
@Recognize and allow bits AD and CD in DNS replies.

Needed for RES_USE_DNSSEC support.

ok eric@@ gilles@@
@
text
@d300 1
a300 1
int _asr_pack_edns0(struct asr_pack *, uint16_t);
@


1.44
log
@Put a common flags field in the query struct, rather than in some
elements of the union.

This field is for internal asr flags.  The flags in "struct rrset" and
"struct ni" are different kinds of flags.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.43 2017/02/23 17:04:02 eric Exp $	*/
d26 3
a28 1
#define Z_MASK		(0x7 <<  4)
@


1.43
log
@Put a common subq pointer in the query struct, rather than one in each
element of the union.

ok gilles@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.42 2017/02/18 19:23:05 jca Exp $	*/
d168 1
a186 1
			int		 flags;
a208 1
			int		 flags;
a250 1
			int		 flags;
@


1.42
log
@Add EDNS0 support.

EDNS allows for various DNS extensions, among which UDP DNS packets size
bigger than 512 bytes.  The default is still to not advertize anything.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.41 2017/02/17 22:24:45 eric Exp $	*/
d173 1
a212 1
			struct asr_query	*subq;
a220 1
			struct asr_query	*subq;
a225 1
			struct asr_query	*subq;
a233 1
			struct asr_query	*subq;
a251 1
			struct asr_query	*subq;
a265 1
			struct asr_query	*subq;
@


1.41
log
@use common errnos instead of random strings as error indicators in
pack/unpack contexts.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.40 2016/12/18 01:34:51 krw Exp $	*/
d297 1
d305 1
@


1.40
log
@Remove prototype for static function _asr_resolver. Eliminates gcc
whining about undefined static in all the .c files that include
asr_private.h. _asr_resolver() is defined and used in asr.c only.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.39 2016/08/20 19:08:57 jca Exp $	*/
d37 1
a37 1
	const char	*err;
d44 1
a44 1
	const char	*err;
@


1.39
log
@Declare all _asr_* debug functions as hidden.

Reported by & similar diff by guenther@@ some time ago, ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.38 2015/12/16 16:32:30 deraadt Exp $	*/
a312 1
static void *_asr_resolver(void);
@


1.38
log
@Remove support for HOSTALIASES from the resolver.  This "open and parse
any file indicated by an environment variable" feature inside the
resolver is incompatible with what pledge "dns" is trying to be.  It is
a misguided "feature" added way back in history which almost noone uses,
but everyone has to assume the risk from.
ok eric florian kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.37 2015/11/23 18:04:54 deraadt Exp $	*/
d344 7
a358 7

#else /* DEBUG */

#define DPRINT(...)
#define DPRINT_PACKET(...)

#endif /* DEBUG */
@


1.37
log
@Remove support for "lookup yp" in /etc/resolv.conf.  This historical
wart is incompatible with pledge, because suddenly a "dns" operation
needs "getpw" access to ypbind/ypserv, etc.  file + dns access is
enough for everyone, sorry if you were using that old SunOS 4.x style
mechanism, but it is now gone.
ok semarie millert florian
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.36 2015/10/28 21:38:45 eric Exp $	*/
a323 1
char *_asr_hostalias(struct asr_ctx *, const char *, char *, size_t);
@


1.36
log
@We are always using _PATH_RESCONF, so no need to remember the path on
the resolver.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.35 2015/10/07 13:59:34 deraadt Exp $	*/
a121 1
#define	ASR_DB_YP	'y'
@


1.35
log
@getaddrinfo_async() shouldn't unconditionally intialize the resolver
via _asr_use_resolver().  If the hint specifies for AI_NUMERICHOST,
create a transient lookup context which won't try to open /etc/reslov.conf
ok eric guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.34 2015/10/03 22:35:30 deraadt Exp $	*/
a142 1
	char		*a_path;
@


1.34
log
@Initially eric developers asr as a side-load style library for async DNS.
When it was integrated as the main resolver, a bunch of strange initialization
code remained.  Start whittling away at this, piece by piece, to make it
more clear.
ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.33 2015/10/03 09:57:30 eric Exp $	*/
d318 1
@


1.33
log
@missing asr* -> _asr* symbol rename for building with debug code

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.32 2015/09/09 15:49:34 deraadt Exp $	*/
d315 1
a315 1
void *_asr_resolver(const char *);
@


1.32
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.31 2015/06/20 01:16:25 jca Exp $	*/
d337 2
a338 2
#define DPRINT(...)		do { if(asr_debug) {		\
		fprintf(asr_debug, __VA_ARGS__);		\
d340 4
a343 4
#define DPRINT_PACKET(n, p, s)	do { if(asr_debug) {		\
		fprintf(asr_debug, "----- %s -----\n", n);	\
		asr_dump_packet(asr_debug, (p), (s));		\
		fprintf(asr_debug, "--------------\n");		\
d364 1
a364 1
		asr_querystr((a)->as_type),	\
d366 2
a367 2
		asr_statestr((a)->as_state),	\
		asr_statestr((s)));		\
@


1.31
log
@Rename print_sockaddr() to avoid symbol visibility problems

print_sockaddr is internal to asr, and conflicts with ports/net/samba4.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.30 2015/06/04 19:23:17 eric Exp $	*/
d300 2
d303 10
a312 10
void asr_pack_init(struct asr_pack *, char *, size_t);
int asr_pack_header(struct asr_pack *, const struct asr_dns_header *);
int asr_pack_query(struct asr_pack *, uint16_t, uint16_t, const char *);
void asr_unpack_init(struct asr_unpack *, const char *, size_t);
int asr_unpack_header(struct asr_unpack *, struct asr_dns_header *);
int asr_unpack_query(struct asr_unpack *, struct asr_dns_query *);
int asr_unpack_rr(struct asr_unpack *, struct asr_dns_rr *);
int asr_sockaddr_from_str(struct sockaddr *, int, const char *);
ssize_t asr_dname_from_fqdn(const char *, char *, size_t);
ssize_t asr_addr_as_fqdn(const char *, int, char *, size_t);
d315 11
a325 11
void *asr_resolver(const char *);
void asr_resolver_done(void *);
struct asr_ctx *asr_use_resolver(void *);
void asr_ctx_unref(struct asr_ctx *);
struct asr_query *asr_async_new(struct asr_ctx *, int);
void asr_async_free(struct asr_query *);
size_t asr_make_fqdn(const char *, const char *, char *, size_t);
char *asr_strdname(const char *, char *, size_t);
int asr_iter_db(struct asr_query *);
int asr_parse_namedb_line(FILE *, char **, int, char *, size_t);
char *asr_hostalias(struct asr_ctx *, const char *, char *, size_t);
d328 3
a330 3
struct asr_query *res_query_async_ctx(const char *, int, int, struct asr_ctx *);
struct asr_query *res_search_async_ctx(const char *, int, int, struct asr_ctx *);
struct asr_query *gethostbyaddr_async_ctx(const void *, socklen_t, int,
d333 2
d346 6
a351 6
const char *asr_querystr(int);
const char *asr_statestr(int);
const char *asr_transitionstr(int);
const char *asr_print_sockaddr(const struct sockaddr *, char *, size_t);
void asr_dump_config(FILE *, struct asr *);
void asr_dump_packet(FILE *, const void *, size_t);
d353 1
a353 1
extern FILE * asr_debug;
d369 2
@


1.30
log
@make sure to check for resolv.conf update the first time the resolver
is used after pid has changed.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.29 2015/05/29 08:49:37 eric Exp $	*/
d345 1
a345 1
const char *print_sockaddr(const struct sockaddr *, char *, size_t);
@


1.29
log
@fix a possible off-by-one when reading /etc/hosts if it doesn't end
with a newline.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.28 2015/05/26 19:28:57 eric Exp $	*/
d144 1
@


1.28
log
@simply use _PATH_HOSTS where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.27 2015/02/14 20:15:05 jca Exp $	*/
d321 1
a321 1
int asr_parse_namedb_line(FILE *, char **, int);
@


1.27
log
@Limit AI_ADDRCONFIG effects to DNS queries.

This is what RFC 2553 initially described, sadly RFC 3493 stopped
limiting scope to DNS.  This can result in nonsensical failures with
loopback addresses, link-local addresses, raw addresses and /etc/hosts
entries.

with and ok eric@@ sperreault@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.26 2014/04/17 15:28:26 guenther Exp $	*/
a133 2

	char		*ac_hostfile;
@


1.26
log
@Don't default enable the debug functionality with its unprotected getenv().

ok eric@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.25 2014/03/25 19:48:11 eric Exp $	*/
d164 2
@


1.25
log
@Cleanup and simplify the API to be exposed.  Use better names for
structures, functions and defines.

discussed with and ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.24 2014/03/14 11:07:33 eric Exp $	*/
a18 4

#ifndef ASRNODEBUG
#define DEBUG
#endif
@


1.24
log
@prefix structure names to avoid ambiguity and possible collisions when
the API gets public.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.23 2013/07/12 14:36:21 eric Exp $	*/
d155 2
d169 2
a170 2
struct async {
	int		(*as_run)(struct async *, struct async_res *);
d217 1
a217 1
			struct async	*subq;
d226 1
a226 1
			struct async	*subq;
d232 1
a232 1
			struct async	*subq;
d241 1
a241 1
			struct async	*subq;
d260 1
a260 1
			struct async	*subq;
d275 1
a275 1
			struct async	*subq;
d316 3
a318 1
struct asr_ctx *asr_use_resolver(struct asr *);
d320 2
a321 2
struct async *asr_async_new(struct asr_ctx *, int);
void asr_async_free(struct async *);
d324 1
a324 1
int asr_iter_db(struct async *);
d329 3
a331 3
struct async *res_query_async_ctx(const char *, int, int, struct asr_ctx *);
struct async *res_search_async_ctx(const char *, int, int, struct asr_ctx *);
struct async *gethostbyaddr_async_ctx(const void *, socklen_t, int,
@


1.23
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.22 2013/06/01 15:02:01 eric Exp $	*/
d37 1
a37 1
struct pack {
d44 1
a44 1
struct unpack {
d51 1
a51 1
struct header {
d60 1
a60 1
struct query {
d66 1
a66 1
struct rr {
d302 8
a309 8
void	asr_pack_init(struct pack *, char *, size_t);
int	asr_pack_header(struct pack *, const struct header *);
int	asr_pack_query(struct pack *, uint16_t, uint16_t, const char *);
void	asr_unpack_init(struct unpack *, const char *, size_t);
int	asr_unpack_header(struct unpack *, struct header *);
int	asr_unpack_query(struct unpack *, struct query *);
int	asr_unpack_rr(struct unpack *, struct rr *);
int	asr_sockaddr_from_str(struct sockaddr *, int, const char *);
d324 1
a324 1
/* <*>_async.h */
@


1.22
log
@Move search domain iteration code in res_search_async.c where it belongs.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.21 2013/06/01 14:34:34 eric Exp $	*/
d302 10
a311 10
void	pack_init(struct pack *, char *, size_t);
int	pack_header(struct pack *, const struct header *);
int	pack_query(struct pack *, uint16_t, uint16_t, const char *);

void	unpack_init(struct unpack *, const char *, size_t);
int	unpack_header(struct unpack *, struct header *);
int	unpack_query(struct unpack *, struct query *);
int	unpack_rr(struct unpack *, struct rr *);
int	sockaddr_from_str(struct sockaddr *, int, const char *);
ssize_t dname_from_fqdn(const char *, char *, size_t);
d316 2
a317 2
struct async *async_new(struct asr_ctx *, int);
void async_free(struct async *);
@


1.21
log
@Make hostaliases work for gethostbyname() and getaddrinfo() when
looking into /etc/hosts.  Remove the alias check from the search
domain iteration. Instead, take a shortcut to res_query_async_ctx() in
res_search_async_ctx().
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.20 2013/06/01 12:38:29 eric Exp $	*/
a318 1
size_t asr_domcat(const char *, const char *, char *, size_t);
a320 1
int asr_iter_domain(struct async *, const char *, char *, size_t);
@


1.20
log
@Update asr_hostaliases() to make all necessary checks in the function.
Explicitely check for issetguid() before calling getenv().  Also make
asr_hostalias() callable from other parts of asr too.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.19 2013/06/01 09:21:10 eric Exp $	*/
d158 2
a159 3
#define	ASYNC_DOM_HOSTALIAS	0x00000004
#define	ASYNC_DOM_DOMAIN	0x00000008
#define ASYNC_DOM_ASIS		0x00000010
@


1.19
log
@iterating over the ns list only matters for res_send_async.c, so move
things around.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.18 2013/05/27 17:31:01 eric Exp $	*/
d325 1
@


1.18
log
@Add minimal support for _res setup and update.

Change res_init() to initialize the _res structure on first call, and
udpate the global async context if changes were made by the user. All
resolver functions now call res_init() internally.

fixes issue spotted by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.17 2013/04/30 12:02:39 eric Exp $	*/
a183 2
	int		 as_ns_idx;
	int		 as_ns_cycles;
d197 3
a322 1
int asr_iter_ns(struct async *);
@


1.17
log
@Do not take external buffers for storing DNS responses in the internal
async API.  That is actually useless and it makes the code more
complicated.  The required buffers are always allocated when needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.16 2013/04/02 16:38:37 eric Exp $	*/
d124 3
a126 5
enum asr_db_type {
	ASR_DB_FILE,
	ASR_DB_DNS,
	ASR_DB_YP,
};
d136 1
a136 1
	int		 ac_db[ASR_MAXDB];
@


1.16
log
@better implementation for tcp_read() that can get the packet length in
multiple read.

prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.15 2013/04/01 16:04:03 deraadt Exp $	*/
a166 1
#define	ASYNC_EXTIBUF		0x00001000
a218 3
			unsigned char	*ibuf;
			size_t		 ibuflen;
			size_t		 ibufsize;
d329 2
a330 4
struct async *res_query_async_ctx(const char *, int, int, unsigned char *, int,
    struct asr_ctx *);
struct async *res_search_async_ctx(const char *, int, int, unsigned char *, int,
    struct asr_ctx *);
@


1.15
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.14 2013/04/01 15:49:54 deraadt Exp $	*/
d210 1
@


1.14
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.13 2013/04/01 08:54:06 eric Exp $	*/
d313 1
a313 1
int	unpack_query(struct unpack *, struct query*);
@


1.13
log
@rename field
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.12 2013/04/01 07:52:06 eric Exp $	*/
d308 2
a309 2
int	pack_header(struct pack*, const struct header*);
int	pack_query(struct pack*, uint16_t, uint16_t, const char*);
d312 3
a314 3
int	unpack_header(struct unpack*, struct header*);
int	unpack_query(struct unpack*, struct query*);
int	unpack_rr(struct unpack*, struct rr*);
d316 1
a316 1
ssize_t dname_from_fqdn(const char*, char*, size_t);
@


1.12
log
@simpler and saner implementation for tcp_write(). now fully handles
short writes.

prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.11 2013/03/27 07:40:41 eric Exp $	*/
d238 1
a238 1
			int		 h_errno;
@


1.11
log
@Only use the search domains for DNS lookups, as the current resolver does.
Better not diverge too much in behavior at this point.
Typo fix and doc update while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.10 2012/11/24 15:12:48 eric Exp $	*/
a208 1
			size_t		 bufpos;
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.9 2012/11/24 13:59:53 eric Exp $	*/
a235 1
			char		*dname;
d239 1
@


1.9
log
@make separate structures for pack and unpack
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.8 2012/09/09 12:15:32 eric Exp $	*/
d17 1
d288 1
a288 1
 
d343 1
a343 1
		fprintf(asr_debug, __VA_ARGS__); 		\
d367 1
a367 1
#define async_set_state(a, s) do { 		\
@


1.8
log
@cleanup asr_debug.c
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.7 2012/09/09 09:42:06 eric Exp $	*/
d36 9
a44 2
struct packed {
	char		*data;
d307 8
a314 6
void	packed_init(struct packed*, char*, size_t);
int	pack_header(struct packed*, const struct header*);
int	pack_query(struct packed*, uint16_t, uint16_t, const char*);
int	unpack_header(struct packed*, struct header*);
int	unpack_query(struct packed*, struct query*);
int	unpack_rr(struct packed*, struct rr*);
@


1.7
log
@use proper macros for debug traces.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.6 2012/09/06 13:57:51 eric Exp $	*/
a331 2
extern FILE * asr_debug;

d337 1
a337 1
		asr_dump_packet(asr_debug, (p), (s), 0);	\
a340 1
/* asr_debug.h */
d342 1
d344 5
a348 5
void asr_dump(struct asr *);
void asr_dump_async(struct async *);
void asr_dump_packet(FILE *, const void *, size_t, int);
void async_set_state(struct async *, int);
char *asr_print_addr(const struct sockaddr *, char *, size_t);
d355 1
a355 1
#define async_set_state(a, s) do { (a)->as_state = (s); } while (0)
d357 7
a363 1
#endif /* DEBUG */
@


1.6
log
@make it easy to build without debug code
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.5 2012/09/05 21:49:12 eric Exp $	*/
d332 10
a341 1
extern int asr_debug;
a348 1
void asr_printf(const char *fmt, ...);
d353 3
@


1.5
log
@Get rid of the hostaddr_async subquery and merge its behaviour
directly into getaddrinfo_async_run.  Simplifies everything by
a great deal.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.4 2012/09/05 15:56:13 eric Exp $	*/
d19 1
d21 1
@


1.4
log
@Make hostaddr_async() return a linked list of struct addrinfo.  First
round of a getaddrinfo_async() simplification. The goal is to make YP
support easier to add, and eventually remove the whole hostaddr_async
subquery.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.3 2012/07/07 20:41:52 eric Exp $	*/
a111 1
	ASR_HOSTADDR,
d251 1
a280 2
	ASR_STATE_SEARCH_DOMAIN,
	ASR_STATE_LOOKUP_DOMAIN,
a284 1
	ASR_STATE_LOOKUP_FAMILY,
a326 1
struct async *hostaddr_async_ctx(const char *, int, int, struct asr_ctx *);
@


1.3
log
@rename function to avoid symbol clash
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.2 2012/04/14 12:06:13 eric Exp $	*/
a270 19

		struct {
			char		*name;
			int		 family;
			int		 aiflags;
			union {
				struct sockaddr		sa;
				struct sockaddr_in	sain;
				struct sockaddr_in6	sain6;
			}		 sa;

			struct async	*subq;
			int		 class;
			int		 type;
			int		 ancount;
			unsigned char	*pkt;
			size_t		 pktlen;
			size_t		 pktpos;
			FILE		*file;
a271 4
			char		*tokens[MAXTOKEN];
			int		 token_count;
			int		 token_idx;
		} host;
a288 2
	ASR_STATE_READ_RR,
	ASR_STATE_READ_FILE,
@


1.2
log
@only define DEBUG internally
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_private.h,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
d369 1
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.5 2011/07/13 14:52:21 eric Exp $	*/
d18 2
@

