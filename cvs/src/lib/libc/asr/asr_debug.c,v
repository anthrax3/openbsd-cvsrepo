head	1.24;
access;
symbols
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.24
date	2017.02.27.11.31.01;	author jca;	state Exp;
branches;
next	1.23;
commitid	nLx1XPQ9CsmYhcqA;

1.23
date	2017.02.17.22.24.45;	author eric;	state Exp;
branches;
next	1.22;
commitid	k26K9OiIpUIb57jZ;

1.22
date	2015.10.28.21.38.45;	author eric;	state Exp;
branches;
next	1.21;
commitid	qIEvBVRrIDarZ0X2;

1.21
date	2015.10.03.09.57.30;	author eric;	state Exp;
branches;
next	1.20;
commitid	mlCldxHCB9oTJwsK;

1.20
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	ZDWhDXAAMFWxMzBj;

1.19
date	2015.06.20.01.16.25;	author jca;	state Exp;
branches;
next	1.18;
commitid	w9FRtEnp4OyBKluV;

1.18
date	2015.05.26.19.28.57;	author eric;	state Exp;
branches;
next	1.17;
commitid	zZUSsmIZVurlTa45;

1.17
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2014.03.25.19.48.11;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2014.03.14.11.07.33;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2013.07.12.14.36.21;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.27.17.31.01;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.09.06.42.17;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.01.15.49.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.24.13.59.53;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.09.12.15.32;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.09.09.42.06;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.05.21.49.12;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.05.15.56.13;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.07.20.41.52;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.25.20.28.25;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.15.21.42.58;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Recognize and allow bits AD and CD in DNS replies.

Needed for RES_USE_DNSSEC support.

ok eric@@ gilles@@
@
text
@/*	$OpenBSD: asr_debug.c,v 1.23 2017/02/17 22:24:45 eric Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <arpa/inet.h>
#include <netdb.h>

#include <asr.h>
#include <resolv.h>
#include <string.h>

#include "asr_private.h"

static const char *rcodetostr(uint16_t);
static const char *print_dname(const char *, char *, size_t);
static const char *print_header(const struct asr_dns_header *, char *, size_t);
static const char *print_query(const struct asr_dns_query *, char *, size_t);
static const char *print_rr(const struct asr_dns_rr *, char *, size_t);

FILE *_asr_debug = NULL;

#define OPCODE_SHIFT	11

static const char *
rcodetostr(uint16_t v)
{
	switch (v) {
	case NOERROR:	return "NOERROR";
	case FORMERR:	return "FORMERR";
	case SERVFAIL:	return "SERVFAIL";
	case NXDOMAIN:	return "NXDOMAIN";
	case NOTIMP:	return "NOTIMP";
	case REFUSED:	return "REFUSED";
	default:	return "?";
	}
}

static const char *
print_dname(const char *_dname, char *buf, size_t max)
{
	return (_asr_strdname(_dname, buf, max));
}

static const char *
print_rr(const struct asr_dns_rr *rr, char *buf, size_t max)
{
	char	*res;
	char	 tmp[256];
	char	 tmp2[256];
	int	 r;

	res = buf;

	r = snprintf(buf, max, "%s %u %s %s ",
	    print_dname(rr->rr_dname, tmp, sizeof tmp),
	    rr->rr_ttl,
	    __p_class(rr->rr_class),
	    __p_type(rr->rr_type));
	if (r == -1) {
		buf[0] = '\0';
		return (buf);
	}

	if ((size_t)r >= max)
		return (buf);

	max -= r;
	buf += r;

	switch (rr->rr_type) {
	case T_CNAME:
		print_dname(rr->rr.cname.cname, buf, max);
		break;
	case T_MX:
		snprintf(buf, max, "%lu %s",
		    (unsigned long)rr->rr.mx.preference,
		    print_dname(rr->rr.mx.exchange, tmp, sizeof tmp));
		break;
	case T_NS:
		print_dname(rr->rr.ns.nsname, buf, max);
		break;
	case T_PTR:
		print_dname(rr->rr.ptr.ptrname, buf, max);
		break;
	case T_SOA:
		snprintf(buf, max, "%s %s %lu %lu %lu %lu %lu",
		    print_dname(rr->rr.soa.rname, tmp, sizeof tmp),
		    print_dname(rr->rr.soa.mname, tmp2, sizeof tmp2),
		    (unsigned long)rr->rr.soa.serial,
		    (unsigned long)rr->rr.soa.refresh,
		    (unsigned long)rr->rr.soa.retry,
		    (unsigned long)rr->rr.soa.expire,
		    (unsigned long)rr->rr.soa.minimum);
		break;
	case T_A:
		if (rr->rr_class != C_IN)
			goto other;
		snprintf(buf, max, "%s", inet_ntop(AF_INET,
		    &rr->rr.in_a.addr, tmp, sizeof tmp));
		break;
	case T_AAAA:
		if (rr->rr_class != C_IN)
			goto other;
		snprintf(buf, max, "%s", inet_ntop(AF_INET6,
		    &rr->rr.in_aaaa.addr6, tmp, sizeof tmp));
		break;
	default:
	other:
		snprintf(buf, max, "(rdlen=%i)", (int)rr->rr.other.rdlen);
		break;
	}

	return (res);
}

static const char *
print_query(const struct asr_dns_query *q, char *buf, size_t max)
{
	char b[256];

	snprintf(buf, max, "%s	%s %s",
	    print_dname(q->q_dname, b, sizeof b),
	    __p_class(q->q_class), __p_type(q->q_type));

	return (buf);
}

static const char *
print_header(const struct asr_dns_header *h, char *buf, size_t max)
{
	snprintf(buf, max,
	"id:0x%04x %s op:%i %s %s %s %s z:%i %s %s r:%s qd:%i an:%i ns:%i ar:%i",
	    ((int)h->id),
	    (h->flags & QR_MASK) ? "QR":"  ",
	    (int)(OPCODE(h->flags) >> OPCODE_SHIFT),
	    (h->flags & AA_MASK) ? "AA":"  ",
	    (h->flags & TC_MASK) ? "TC":"  ",
	    (h->flags & RD_MASK) ? "RD":"  ",
	    (h->flags & RA_MASK) ? "RA":"  ",
	    (h->flags & Z_MASK),
	    (h->flags & AD_MASK) ? "AD":"  ",
	    (h->flags & CD_MASK) ? "CD":"  ",
	    rcodetostr(RCODE(h->flags)),
	    h->qdcount, h->ancount, h->nscount, h->arcount);

	return (buf);
}

void
_asr_dump_packet(FILE *f, const void *data, size_t len)
{
	char			buf[1024];
	struct asr_unpack	p;
	struct asr_dns_header	h;
	struct asr_dns_query	q;
	struct asr_dns_rr	rr;
	int			i, an, ns, ar, n;

	if (f == NULL)
		return;

	_asr_unpack_init(&p, data, len);

	if (_asr_unpack_header(&p, &h) == -1) {
		fprintf(f, ";; BAD PACKET: %s\n", strerror(p.err));
		return;
	}

	fprintf(f, ";; HEADER %s\n", print_header(&h, buf, sizeof buf));

	if (h.qdcount)
		fprintf(f, ";; QUERY SECTION:\n");
	for (i = 0; i < h.qdcount; i++) {
		if (_asr_unpack_query(&p, &q) == -1)
			goto error;
		fprintf(f, "%s\n", print_query(&q, buf, sizeof buf));
	}

	an = 0;
	ns = an + h.ancount;
	ar = ns + h.nscount;
	n = ar + h.arcount;

	for (i = 0; i < n; i++) {
		if (i == an)
			fprintf(f, "\n;; ANSWER SECTION:\n");
		if (i == ns)
			fprintf(f, "\n;; AUTHORITY SECTION:\n");
		if (i == ar)
			fprintf(f, "\n;; ADDITIONAL SECTION:\n");

		if (_asr_unpack_rr(&p, &rr) == -1)
			goto error;
		fprintf(f, "%s\n", print_rr(&rr, buf, sizeof buf));
	}

	if (p.offset != len)
		fprintf(f, ";; REMAINING GARBAGE %zu\n", len - p.offset);

    error:
	if (p.err)
		fprintf(f, ";; ERROR AT OFFSET %zu/%zu: %s\n", p.offset, p.len,
		    strerror(p.err));
}

const char *
_asr_print_sockaddr(const struct sockaddr *sa, char *buf, size_t len)
{
	char	h[256];
	int	portno;
	union {
		const struct sockaddr		*sa;
		const struct sockaddr_in	*sin;
		const struct sockaddr_in6	*sin6;
	}	s;

	s.sa = sa;

	switch (sa->sa_family) {
	case AF_INET:
		inet_ntop(AF_INET, &s.sin->sin_addr, h, sizeof h);
		portno = ntohs(s.sin->sin_port);
		break;
	case AF_INET6:
		inet_ntop(AF_INET6, &s.sin6->sin6_addr, h, sizeof h);
		portno = ntohs(s.sin6->sin6_port);
		break;
	default:
		snprintf(buf, len, "?");
		return (buf);
	}

	snprintf(buf, len, "%s:%i", h, portno);
	return (buf);
}

void
_asr_dump_config(FILE *f, struct asr *a)
{
	char		 buf[256];
	int		 i;
	struct asr_ctx	*ac;
	unsigned int	 o;

	if (f == NULL)
		return;

	ac = a->a_ctx;

	fprintf(f, "--------- ASR CONFIG ---------------\n");
	fprintf(f, "DOMAIN \"%s\"\n", ac->ac_domain);
	fprintf(f, "SEARCH\n");
	for (i = 0; i < ac->ac_domcount; i++)
		fprintf(f, "   \"%s\"\n", ac->ac_dom[i]);
	fprintf(f, "OPTIONS\n");
	fprintf(f, " options:");
	o = ac->ac_options;

#define PRINTOPT(flag, n) if (o & (flag)) { fprintf(f, " " n); o &= ~(flag); }
	PRINTOPT(RES_INIT, "INIT");
	PRINTOPT(RES_DEBUG, "DEBUG");
	PRINTOPT(RES_USEVC, "USEVC");
	PRINTOPT(RES_IGNTC, "IGNTC");
	PRINTOPT(RES_RECURSE, "RECURSE");
	PRINTOPT(RES_DEFNAMES, "DEFNAMES");
	PRINTOPT(RES_STAYOPEN, "STAYOPEN");
	PRINTOPT(RES_DNSRCH, "DNSRCH");
	PRINTOPT(RES_NOALIASES, "NOALIASES");
	PRINTOPT(RES_USE_EDNS0, "USE_EDNS0");
	PRINTOPT(RES_USE_DNSSEC, "USE_DNSSEC");
	if (o)
		fprintf(f, " 0x%08x", o);
	fprintf(f, "\n");

	fprintf(f, " ndots: %i\n", ac->ac_ndots);
	fprintf(f, " family:");
	for (i = 0; ac->ac_family[i] != -1; i++)
		fprintf(f, " %s", (ac->ac_family[i] == AF_INET)?"inet4":"inet6");
	fprintf(f, "\n");
	fprintf(f, "NAMESERVERS timeout=%i retry=%i\n",
		    ac->ac_nstimeout,
		    ac->ac_nsretries);
	for (i = 0; i < ac->ac_nscount; i++)
		fprintf(f, "	%s\n", _asr_print_sockaddr(ac->ac_ns[i], buf,
		    sizeof buf));
	fprintf(f, "LOOKUP %s", ac->ac_db);
	fprintf(f, "\n------------------------------------\n");
}

#define CASE(n) case n: return #n

const char *
_asr_statestr(int state)
{
	switch (state) {
	CASE(ASR_STATE_INIT);
	CASE(ASR_STATE_NEXT_DOMAIN);
	CASE(ASR_STATE_NEXT_DB);
	CASE(ASR_STATE_SAME_DB);
	CASE(ASR_STATE_NEXT_FAMILY);
	CASE(ASR_STATE_NEXT_NS);
	CASE(ASR_STATE_UDP_SEND);
	CASE(ASR_STATE_UDP_RECV);
	CASE(ASR_STATE_TCP_WRITE);
	CASE(ASR_STATE_TCP_READ);
	CASE(ASR_STATE_PACKET);
	CASE(ASR_STATE_SUBQUERY);
	CASE(ASR_STATE_NOT_FOUND);
	CASE(ASR_STATE_HALT);
	default:
		return "?";
	}
};

const char *
_asr_querystr(int type)
{
	switch (type) {
	CASE(ASR_SEND);
	CASE(ASR_SEARCH);
	CASE(ASR_GETRRSETBYNAME);
	CASE(ASR_GETHOSTBYNAME);
	CASE(ASR_GETHOSTBYADDR);
	CASE(ASR_GETNETBYNAME);
	CASE(ASR_GETNETBYADDR);
	CASE(ASR_GETADDRINFO);
	CASE(ASR_GETNAMEINFO);
	default:
		return "?";
	}
}

const char *
_asr_transitionstr(int type)
{
	switch (type) {
	CASE(ASYNC_COND);
	CASE(ASYNC_DONE);
	default:
		return "?";
	}
}
@


1.23
log
@use common errnos instead of random strings as error indicators in
pack/unpack contexts.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.22 2015/10/28 21:38:45 eric Exp $	*/
a39 1
#define Z_SHIFT		 4
d149 1
a149 1
	"id:0x%04x %s op:%i %s %s %s %s z:%i r:%s qd:%i an:%i ns:%i ar:%i",
d157 3
a159 1
	    ((h->flags & Z_MASK) >> Z_SHIFT),
@


1.22
log
@We are always using _PATH_RESCONF, so no need to remember the path on
the resolver.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.21 2015/10/03 09:57:30 eric Exp $	*/
d27 1
d181 1
a181 1
		fprintf(f, ";; BAD PACKET: %s\n", p.err);
d219 1
a219 1
		    p.err);
@


1.21
log
@missing asr* -> _asr* symbol rename for building with debug code

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.20 2015/09/09 15:49:34 deraadt Exp $	*/
a265 4
	if (a->a_path)
		fprintf(f, "CONF FILE \"%s\"\n", a->a_path);
	else
		fprintf(f, "STATIC CONF\n");
@


1.20
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.19 2015/06/20 01:16:25 jca Exp $	*/
d36 1
a36 1
FILE *asr_debug = NULL;
@


1.19
log
@Rename print_sockaddr() to avoid symbol visibility problems

print_sockaddr is internal to asr, and conflicts with ports/net/samba4.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.18 2015/05/26 19:28:57 eric Exp $	*/
d58 1
a58 1
	return (asr_strdname(_dname, buf, max));
d165 1
a165 1
asr_dump_packet(FILE *f, const void *data, size_t len)
d177 1
a177 1
	asr_unpack_init(&p, data, len);
d179 1
a179 1
	if (asr_unpack_header(&p, &h) == -1) {
d189 1
a189 1
		if (asr_unpack_query(&p, &q) == -1)
d207 1
a207 1
		if (asr_unpack_rr(&p, &rr) == -1)
d222 1
a222 1
asr_print_sockaddr(const struct sockaddr *sa, char *buf, size_t len)
d253 1
a253 1
asr_dump_config(FILE *f, struct asr *a)
d303 1
a303 1
		fprintf(f, "	%s\n", asr_print_sockaddr(ac->ac_ns[i], buf,
d312 1
a312 1
asr_statestr(int state)
d335 1
a335 1
asr_querystr(int type)
d353 1
a353 1
asr_transitionstr(int type)
@


1.18
log
@simply use _PATH_HOSTS where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.17 2014/03/26 18:13:15 eric Exp $	*/
d222 1
a222 1
print_sockaddr(const struct sockaddr *sa, char *buf, size_t len)
d303 1
a303 1
		fprintf(f, "	%s\n", print_sockaddr(ac->ac_ns[i], buf,
@


1.17
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.16 2014/03/25 19:48:11 eric Exp $	*/
a304 1
	fprintf(f, "HOSTFILE %s\n", ac->ac_hostfile);
@


1.16
log
@Cleanup and simplify the API to be exposed.  Use better names for
structures, functions and defines.

discussed with and ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.15 2014/03/14 11:07:33 eric Exp $	*/
d23 1
d25 1
a27 1
#include "asr.h"
@


1.15
log
@prefix structure names to avoid ambiguity and possible collisions when
the API gets public.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.14 2013/07/12 14:36:21 eric Exp $	*/
a356 1
	CASE(ASYNC_YIELD);
@


1.14
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.13 2013/05/27 17:31:01 eric Exp $	*/
d31 3
a33 3
static const char *print_header(const struct header *, char *, size_t);
static const char *print_query(const struct query *, char *, size_t);
static const char *print_rr(const struct rr *, char *, size_t);
d61 1
a61 1
print_rr(const struct rr *rr, char *buf, size_t max)
d133 1
a133 1
print_query(const struct query *q, char *buf, size_t max)
d145 1
a145 1
print_header(const struct header *h, char *buf, size_t max)
d166 6
a171 6
	char		buf[1024];
	struct unpack	p;
	struct header	h;
	struct query	q;
	struct rr	rr;
	int		i, an, ns, ar, n;
@


1.13
log
@Add minimal support for _res setup and update.

Change res_init() to initialize the _res structure on first call, and
udpate the global async context if changes were made by the user. All
resolver functions now call res_init() internally.

fixes issue spotted by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.12 2013/04/09 06:42:17 otto Exp $	*/
d176 1
a176 1
	unpack_init(&p, data, len);
d178 1
a178 1
	if (unpack_header(&p, &h) == -1) {
d188 1
a188 1
		if (unpack_query(&p, &q) == -1)
d206 1
a206 1
		if (unpack_rr(&p, &rr) == -1)
@


1.12
log
@show what we parsed in debug output; ok guether@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.11 2013/04/01 15:49:54 deraadt Exp $	*/
d305 1
a305 16
	fprintf(f, "LOOKUP");
	for (i = 0; i < ac->ac_dbcount; i++) {
		switch (ac->ac_db[i]) {
		case ASR_DB_FILE:
			fprintf(f, " file");
			break;
		case ASR_DB_DNS:
			fprintf(f, " dns");
			break;
		case ASR_DB_YP:
			fprintf(f, " yp");
			break;
		default:
			fprintf(f, " ?%i", ac->ac_db[i]);
		}
	}
@


1.11
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.10 2012/11/24 15:12:48 eric Exp $	*/
d296 1
a296 1
		fprintf(f, " %s", (ac->ac_family[i] == AF_INET)?"inet":"inet6");
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.9 2012/11/24 13:59:53 eric Exp $	*/
d29 5
a33 5
static const char* rcodetostr(uint16_t);
static const char* print_dname(const char *, char *, size_t);
static const char* print_header(const struct header *, char *, size_t);
static const char* print_query(const struct query *, char *, size_t);
static const char* print_rr(const struct rr*, char *, size_t);
d54 1
a54 1
static const char*
d60 1
a60 1
static const char*
d132 1
a132 1
static const char*
d144 1
a144 1
static const char*
@


1.9
log
@make separate structures for pack and unpack
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.8 2012/09/09 12:15:32 eric Exp $	*/
d17 1
a19 1

d43 1
a43 1
	switch(v) {
d86 1
a86 1
	switch(rr->rr_type) {
d155 1
a155 1
	    (h->flags & RA_MASK) ? "RA":"  ",  
d271 1
a271 1
	for(i = 0; i < ac->ac_domcount; i++)
d295 1
a295 1
	for(i = 0; ac->ac_family[i] != -1; i++)
d299 3
a301 3
		   ac->ac_nstimeout,
		   ac->ac_nsretries);
	for(i = 0; i < ac->ac_nscount; i++)
d306 1
a306 1
	for(i = 0; i < ac->ac_dbcount; i++) {
d370 1
a370 1
	switch(type) {
@


1.8
log
@cleanup asr_debug.c
@
text
@d1 1
a1 1
/*	$OpenBSD: res_debug.c,v 1.1 2012/09/08 11:08:21 eric Exp $	*/
d167 1
a167 1
	struct packed	p;
d176 1
a176 1
	packed_init(&p, (char *)data, len);
@


1.7
log
@use proper macros for debug traces.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.6 2012/09/05 21:49:12 eric Exp $	*/
d3 1
a3 1
 * Copyright (c) 2010-2012 Eric Faurot <eric@@openbsd.org>
d21 1
a22 1
#include <arpa/nameser.h>
a23 1
#include <inttypes.h>
a24 2
#include <string.h>
#include <stdarg.h>
d29 5
a33 10
static void asr_printf(const char *, ...);

static char *print_dname(const char *, char *, size_t);
static char *print_host(const struct sockaddr *, char *, size_t);

static const char *typetostr(uint16_t);
static const char *classtostr(uint16_t);
static const char *rcodetostr(uint16_t);

static const char *inet6_ntoa(struct in6_addr);
d35 1
a39 80
struct keyval {
	const char	*key;
	uint16_t	 value;
};

static struct keyval kv_class[] = {
	{ "IN",	C_IN },
	{ "CHAOS", C_CHAOS },
	{ "HS", C_HS },
	{ "ANY", C_ANY },
	{ NULL, 	0 },
};

static struct keyval kv_type[] = {
	{ "A",		T_A	},
	{ "NS",		T_NS	},
	{ "MD",		T_MD	},
	{ "MF",		T_MF	},
	{ "CNAME",	T_CNAME	},
	{ "SOA",	T_SOA	},
	{ "MB",		T_MB	},
	{ "MG",		T_MG	},
	{ "MR",		T_MR	},
	{ "NULL",	T_NULL	},
	{ "WKS",	T_WKS	},
	{ "PTR",	T_PTR	},
	{ "HINFO",	T_HINFO	},
	{ "MINFO",	T_MINFO	},
	{ "MX",		T_MX	},
	{ "TXT",	T_TXT	},

	{ "AAAA",	T_AAAA	},

	{ "AXFR",	T_AXFR	},
	{ "MAILB",	T_MAILB	},
	{ "MAILA",	T_MAILA	},
	{ "ANY",	T_ANY	},
	{ NULL, 	0 },
};

static struct keyval kv_rcode[] = {
	{ "NOERROR",	NOERROR	},
	{ "FORMERR",	FORMERR },
	{ "SERVFAIL",	SERVFAIL },
	{ "NXDOMAIN",	NXDOMAIN },
	{ "NOTIMP",	NOTIMP },
	{ "REFUSED",	REFUSED },
	{ NULL, 	0 },
};

static const char *
typetostr(uint16_t v)
{
	static char	 buf[16];
	size_t		 i;

	for(i = 0; kv_type[i].key; i++)
		if (kv_type[i].value == v)
			return (kv_type[i].key);

	snprintf(buf, sizeof buf, "%"PRIu16"?", v);

	return (buf);
}

static const char *
classtostr(uint16_t v)
{
	static char	 buf[16];
	size_t		 i;

	for(i = 0; kv_class[i].key; i++)
		if (kv_class[i].value == v)
			return (kv_class[i].key);

	snprintf(buf, sizeof buf, "%"PRIu16"?", v);

	return (buf);
}

d43 9
a51 10
	static char      buf[16];
	size_t           i;

	for(i = 0; kv_rcode[i].key; i++)
		if (kv_rcode[i].value == v)
			return (kv_rcode[i].key);

	snprintf(buf, sizeof buf, "%"PRIu16"?", v);

	return (buf);
d54 2
a55 2
static const char *
inet6_ntoa(struct in6_addr a)
d57 1
a57 8
	static char buf[256];
	struct sockaddr_in6	si;

	si.sin6_len = sizeof(si);
	si.sin6_family = PF_INET6;
	si.sin6_addr = a;

	return print_host((struct sockaddr*)&si, buf, sizeof buf);
d60 2
a61 2
static char*
print_rr(struct rr *rr, char *buf, size_t max)
d73 2
a74 2
	    classtostr(rr->rr_class),
	    typetostr(rr->rr_type));
d77 1
a77 1
		return buf;
d81 1
a81 1
		return buf;
d91 2
a92 2
		snprintf(buf, max, "%"PRIu32" %s",
		    rr->rr.mx.preference,
d102 1
a102 2
		snprintf(buf, max, "%s %s %" PRIu32 " %" PRIu32 " %" PRIu32
		    " %" PRIu32 " %" PRIu32,
d105 5
a109 5
		    rr->rr.soa.serial,
		    rr->rr.soa.refresh,
		    rr->rr.soa.retry,
		    rr->rr.soa.expire,
		    rr->rr.soa.minimum);
d114 2
a115 1
		snprintf(buf, max, "%s", inet_ntoa(rr->rr.in_a.addr));
d120 2
a121 1
		snprintf(buf, max, "%s", inet6_ntoa(rr->rr.in_aaaa.addr6));
d125 1
a125 1
		snprintf(buf, max, "(rdlen=%"PRIu16 ")", rr->rr.other.rdlen);
d132 2
a133 2
static char*
print_query(struct query *q, char *buf, size_t max)
d139 1
a139 1
	    classtostr(q->q_class), typetostr(q->q_type));
d144 2
a145 8
static char*
print_dname(const char *_dname, char *buf, size_t max)
{
	return asr_strdname(_dname, buf, max);
}

static char*
print_header(struct header *h, char *buf, size_t max, int noid)
d149 1
a149 1
	    noid ? 0 : ((int)h->id),
a159 42
	return buf;
}

static char *
print_host(const struct sockaddr *sa, char *buf, size_t len)
{
	switch (sa->sa_family) {
	case AF_INET:
		inet_ntop(AF_INET, &((const struct sockaddr_in*)sa)->sin_addr,
		    buf, len);
		break;
	case AF_INET6:
		inet_ntop(AF_INET6,
		    &((const struct sockaddr_in6*)sa)->sin6_addr, buf, len);
		break;
	default:
		buf[0] = '\0';
	}
	return (buf);
}

char *
asr_print_addr(const struct sockaddr *sa, char *buf, size_t len)
{
	char	h[256];

	print_host(sa, h, sizeof h);

	switch (sa->sa_family) {
	case AF_INET:
		snprintf(buf, len, "%s:%i", h,
		    ntohs(((const struct sockaddr_in*)(sa))->sin_port));
		break;
	case AF_INET6:
		snprintf(buf, len, "[%s]:%i", h,
		    ntohs(((const struct sockaddr_in6*)(sa))->sin6_port));
		break;
	default:
		snprintf(buf, len, "?");
		break;
	}

a162 6
struct kv { int code; const char *name; };

static const char*	kvlookup(struct kv *, int);

FILE	* asr_debug = NULL;

d164 1
a164 175
asr_dump(struct asr *a)
{
	char		 buf[256];
	int		 i;
	struct asr_ctx	*ac;
	unsigned int	 options;

	ac = a->a_ctx;

	asr_printf("--------- ASR CONFIG ---------------\n");
	if (a->a_path)
		asr_printf("CONF FILE \"%s\"\n", a->a_path);
	else
		asr_printf("STATIC CONF\n");
	asr_printf("DOMAIN \"%s\"\n", ac->ac_domain);
	asr_printf("SEARCH\n");
	for(i = 0; i < ac->ac_domcount; i++)
		asr_printf("   \"%s\"\n", ac->ac_dom[i]);
	asr_printf("OPTIONS\n");
	asr_printf(" options:");
	options = ac->ac_options;
	if (options & RES_INIT) {
		asr_printf(" INIT"); options &= ~RES_INIT;
	}
	if (options & RES_DEBUG) {
		asr_printf(" DEBUG"); options &= ~RES_DEBUG;
	}
	if (options & RES_USEVC) {
		asr_printf(" USEVC"); options &= ~RES_USEVC;
	}
	if (options & RES_IGNTC) {
		asr_printf(" IGNTC"); options &= ~RES_IGNTC;
	}
	if (options & RES_RECURSE) {
		asr_printf(" RECURSE"); options &= ~RES_RECURSE;
	}
	if (options & RES_DEFNAMES) {
		asr_printf(" DEFNAMES"); options &= ~RES_DEFNAMES;
	}
	if (options & RES_STAYOPEN) {
		asr_printf(" STAYOPEN"); options &= ~RES_STAYOPEN;
	}
	if (options & RES_DNSRCH) {
		asr_printf(" DNSRCH"); options &= ~RES_DNSRCH;
	}
	if (options & RES_NOALIASES) {
		asr_printf(" NOALIASES"); options &= ~RES_NOALIASES;
	}
	if (options & RES_USE_EDNS0) {
		asr_printf(" USE_EDNS0"); options &= ~RES_USE_EDNS0;
	}
	if (options & RES_USE_DNSSEC) {
		asr_printf(" USE_DNSSEC"); options &= ~RES_USE_DNSSEC;
	}
	if (options)
		asr_printf("0x%08x\n", options);
	asr_printf("\n", ac->ac_options);

	asr_printf(" ndots: %i\n", ac->ac_ndots);
	asr_printf(" family:");
	for(i = 0; ac->ac_family[i] != -1; i++)
		asr_printf(" %s", (ac->ac_family[i] == AF_INET) ?
		    "inet" : "inet6");
	asr_printf("\n");
	asr_printf("NAMESERVERS timeout=%i retry=%i\n",
		   ac->ac_nstimeout,
		   ac->ac_nsretries);
	for(i = 0; i < ac->ac_nscount; i++)
		asr_printf("	%s\n", asr_print_addr(ac->ac_ns[i], buf,
		    sizeof buf));
	asr_printf("HOSTFILE %s\n", ac->ac_hostfile);
	asr_printf("LOOKUP");
	for(i = 0; i < ac->ac_dbcount; i++) {
		switch (ac->ac_db[i]) {
		case ASR_DB_FILE:
			asr_printf(" file");
			break;
		case ASR_DB_DNS:
			asr_printf(" dns");
			break;
		case ASR_DB_YP:
			asr_printf(" yp");
			break;
		default:
			asr_printf(" ?%i", ac->ac_db[i]);
		}
	}
	asr_printf("\n------------------------------------\n");
}

static const char *
kvlookup(struct kv *kv, int code)
{
	while (kv->name) {
		if (kv->code == code)
			return (kv->name);
		kv++;
	}
	return "???";
}

struct kv kv_query_type[] = {
	{ ASR_SEND,		"ASR_SEND"		},
	{ ASR_SEARCH,		"ASR_SEARCH"		},
	{ ASR_GETRRSETBYNAME,	"ASR_GETRRSETBYNAME"	},
	{ ASR_GETHOSTBYNAME,	"ASR_GETHOSTBYNAME"	},
	{ ASR_GETHOSTBYADDR,	"ASR_GETHOSTBYADDR"	},
	{ ASR_GETNETBYNAME,	"ASR_GETNETBYNAME"	},
	{ ASR_GETNETBYADDR,	"ASR_GETNETBYADDR"	},
	{ ASR_GETADDRINFO,	"ASR_GETADDRINFO"	},
	{ ASR_GETNAMEINFO,	"ASR_GETNAMEINFO"	},
	{ 0, NULL }
};

struct kv kv_db_type[] = {
	{ ASR_DB_FILE,			"ASR_DB_FILE"			},
	{ ASR_DB_DNS,			"ASR_DB_DNS"			},
	{ ASR_DB_YP,			"ASR_DB_YP"			},
	{ 0, NULL }
};

struct kv kv_state[] = {
	{ ASR_STATE_INIT,		"ASR_STATE_INIT"		},
	{ ASR_STATE_NEXT_DOMAIN,	"ASR_STATE_NEXT_DOMAIN"		},
	{ ASR_STATE_NEXT_DB,		"ASR_STATE_NEXT_DB"		},
	{ ASR_STATE_SAME_DB,		"ASR_STATE_SAME_DB"		},
	{ ASR_STATE_NEXT_FAMILY,	"ASR_STATE_NEXT_FAMILY"		},
	{ ASR_STATE_NEXT_NS,		"ASR_STATE_NEXT_NS"		},
	{ ASR_STATE_UDP_SEND,		"ASR_STATE_UDP_SEND"		},
	{ ASR_STATE_UDP_RECV,		"ASR_STATE_UDP_RECV"		},
	{ ASR_STATE_TCP_WRITE,		"ASR_STATE_TCP_WRITE"		},
	{ ASR_STATE_TCP_READ,		"ASR_STATE_TCP_READ"		},
	{ ASR_STATE_PACKET,		"ASR_STATE_PACKET"		},
	{ ASR_STATE_SUBQUERY,		"ASR_STATE_SUBQUERY"		},
	{ ASR_STATE_NOT_FOUND,		"ASR_STATE_NOT_FOUND",		},
	{ ASR_STATE_HALT,		"ASR_STATE_HALT"		},
	{ 0, NULL }
};

struct kv kv_transition[] = {
	{ ASYNC_COND,			"ASYNC_COND"			},
	{ ASYNC_YIELD,			"ASYNC_YIELD"			},
	{ ASYNC_DONE,			"ASYNC_DONE"			},
        { 0, NULL }
};

const char *
asr_querystr(int type)
{
	return kvlookup(kv_query_type, type);
}

const char *
asr_transitionstr(int type)
{
	return kvlookup(kv_transition, type);
}

void
asr_dump_async(struct async *as)
{
	asr_printf("%s fd=%i timeout=%i"
		"   dom_idx=%i db_idx=%i ns_idx=%i ns_cycles=%i\n",
		kvlookup(kv_state, as->as_state),
		as->as_fd,
		as->as_timeout,

		as->as_dom_idx,
		as->as_db_idx,
		as->as_ns_idx,
		as->as_ns_cycles);
}

void
asr_dump_packet(FILE *f, const void *data, size_t len, int noid)
d183 1
a183 1
	fprintf(f, ";; HEADER %s\n", print_header(&h, buf, sizeof buf, noid));
d218 14
d233 16
a248 1
	return;
d251 2
a252 2
static void
asr_printf(const char *fmt, ...)
d254 4
a257 1
	va_list ap;
d259 1
a259 1
	if (asr_debug == NULL)
d262 103
a364 3
	va_start(ap, fmt);
	vfprintf(asr_debug, fmt, ap);
	va_end(ap);
d367 2
a368 2
void
async_set_state(struct async *as, int state)
d370 7
a376 6
	asr_printf("asr: [%s@@%p] %s -> %s\n",
		kvlookup(kv_query_type, as->as_type),
		as,
		kvlookup(kv_state, as->as_state),
		kvlookup(kv_state, state));
	as->as_state = state;
@


1.6
log
@Get rid of the hostaddr_async subquery and merge its behaviour
directly into getaddrinfo_async_run.  Simplifies everything by
a great deal.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.5 2012/09/05 15:56:13 eric Exp $	*/
d32 1
a32 1
static void asr_vdebug(const char *, va_list);
d309 1
a309 1
int	 asr_debug = 0;
a544 7
asr_vdebug(const char *fmt, va_list ap)
{
	if (asr_debug)
		vfprintf(stderr, fmt, ap);
}

void
d549 3
d553 1
a553 1
	asr_vdebug(fmt, ap);
@


1.5
log
@Make hostaddr_async() return a linked list of struct addrinfo.  First
round of a getaddrinfo_async() simplification. The goal is to make YP
support easier to add, and eventually remove the whole hostaddr_async
subquery.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.4 2012/07/07 20:41:52 eric Exp $	*/
a422 1
	{ ASR_HOSTADDR,		"ASR_HOSTADDR"		},
a434 2
	{ ASR_STATE_SEARCH_DOMAIN,	"ASR_STATE_SEARCH_DOMAIN"	},
	{ ASR_STATE_LOOKUP_DOMAIN,	"ASR_STATE_LOOKUP_DOMAIN"	},
a438 1
	{ ASR_STATE_LOOKUP_FAMILY,	"ASR_STATE_LOOKUP_FAMILY"	},
@


1.4
log
@rename function to avoid symbol clash
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.3 2012/04/25 20:28:25 eric Exp $	*/
a443 2
	{ ASR_STATE_READ_RR,		"ASR_STATE_READ_RR"		},
	{ ASR_STATE_READ_FILE,		"ASR_STATE_READ_FILE"		},
@


1.3
log
@fix a few warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.2 2012/04/15 21:42:58 eric Exp $	*/
a31 2
char *print_addr(const struct sockaddr *, char *, size_t);

d282 1
a282 1
print_addr(const struct sockaddr *sa, char *buf, size_t len)
d380 1
a380 1
		asr_printf("	%s\n", print_addr(ac->ac_ns[i], buf,
@


1.2
log
@calling getnameinfo here is a bad idea. use inet_ntop.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_debug.c,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
d32 2
d199 2
a200 2
		snprintf(buf, max,
		    "%s %s %" PRIu32 " %" PRIu32 " %" PRIu32 " %" PRIu32 " %" PRIu32,
d270 2
a271 1
		inet_ntop(AF_INET, &((struct sockaddr_in*)sa)->sin_addr, buf, len);
d274 2
a275 1
		inet_ntop(AF_INET6, &((struct sockaddr_in6*)sa)->sin6_addr, buf, len);
d293 1
a293 1
		    ntohs(((struct sockaddr_in*)(sa))->sin_port));
d297 1
a297 1
		    ntohs(((struct sockaddr_in6*)(sa))->sin6_port));
d375 2
a376 1
		asr_printf(" %s", (ac->ac_family[i] == AF_INET) ? "inet" : "inet6");
d382 2
a383 1
		asr_printf("	%s\n", print_addr(ac->ac_ns[i], buf, sizeof buf));
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.10 2011/07/13 16:14:43 eric Exp $	*/
d266 8
a273 4
	int	e;

	if ((e = getnameinfo(sa, sa->sa_len,
	    buf, len, NULL, 0, NI_NUMERICHOST)) != 0) {
a274 1
		return (NULL);
@

