head	1.36;
access;
symbols
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.36
date	2017.03.15.15.54.41;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	CbsRqwfygz5INFER;

1.35
date	2017.03.14.15.15.19;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	fdemfPehkoVQhcHP;

1.34
date	2017.02.27.11.38.08;	author jca;	state Exp;
branches;
next	1.33;
commitid	drUqtHQk8flZF7Hy;

1.33
date	2017.02.27.10.44.46;	author jca;	state Exp;
branches;
next	1.32;
commitid	MlNq0zVlbx0f2ABQ;

1.32
date	2017.02.18.22.25.13;	author eric;	state Exp;
branches;
next	1.31;
commitid	LQgo5ZJxU8Wa6bl0;

1.31
date	2017.02.18.19.23.05;	author jca;	state Exp;
branches;
next	1.30;
commitid	6EwZbn7a3sVTI0GZ;

1.30
date	2017.02.17.00.29.22;	author krw;	state Exp;
branches;
next	1.29;
commitid	l4ZvJH5RDcpCKvmM;

1.29
date	2015.10.23.00.52.09;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	NRR7zelWftDgrNLT;

1.28
date	2015.10.18.15.15.00;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	e0gF9Kz5C6KclYt5;

1.27
date	2015.09.20.14.19.21;	author eric;	state Exp;
branches;
next	1.26;
commitid	QoXCnUzVxYUpwKcZ;

1.26
date	2015.09.14.11.52.49;	author guenther;	state Exp;
branches;
next	1.25;
commitid	KzuByhRo5iAIKcqw;

1.25
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	ZDWhDXAAMFWxMzBj;

1.24
date	2015.09.09.15.40.04;	author guenther;	state Exp;
branches;
next	1.23;
commitid	ciFCSwO7wkqzZ7sN;

1.23
date	2015.06.20.01.16.25;	author jca;	state Exp;
branches;
next	1.22;
commitid	w9FRtEnp4OyBKluV;

1.22
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2014.03.25.19.48.11;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2014.03.14.11.07.33;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2013.07.12.14.36.22;	author eric;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.01.09.21.10;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.30.12.02.39;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.14.22.23.08;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.04.05.07.12.24;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2013.04.03.19.38.20;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.02.21.57.33;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.02.16.38.37;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.01.16.04.03;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.01.15.49.54;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2013.04.01.07.52.06;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.31.19.42.10;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.27.07.40.41;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.24.13.59.53;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.09.09.12.15.32;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.09.09.09.42.06;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.07.07.20.41.52;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.36
log
@use recallocarray to resize buffer - ensures that detritus from previous
lookups isn't left lying around the address space.
ok eric
@
text
@/*	$OpenBSD: res_send_async.c,v 1.35 2017/03/14 15:15:19 deraadt Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <netdb.h>

#include <asr.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <resolv.h> /* for res_random */
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "asr_private.h"

#define OP_QUERY    (0)

static int res_send_async_run(struct asr_query *, struct asr_result *);
static int sockaddr_connect(const struct sockaddr *, int);
static int udp_send(struct asr_query *);
static int udp_recv(struct asr_query *);
static int tcp_write(struct asr_query *);
static int tcp_read(struct asr_query *);
static int validate_packet(struct asr_query *);
static int setup_query(struct asr_query *, const char *, const char *, int, int);
static int ensure_ibuf(struct asr_query *, size_t);
static int iter_ns(struct asr_query *);

#define AS_NS_SA(p) ((p)->as_ctx->ac_ns[(p)->as.dns.nsidx - 1])


struct asr_query *
res_send_async(const unsigned char *buf, int buflen, void *asr)
{
	struct asr_ctx		*ac;
	struct asr_query	*as;
	struct asr_unpack	 p;
	struct asr_dns_header	 h;
	struct asr_dns_query	 q;

	DPRINT_PACKET("asr: res_send_async()", buf, buflen);

	ac = _asr_use_resolver(asr);
	if ((as = _asr_async_new(ac, ASR_SEND)) == NULL) {
		_asr_ctx_unref(ac);
		return (NULL); /* errno set */
	}
	as->as_run = res_send_async_run;

	as->as_flags |= ASYNC_EXTOBUF;
	as->as.dns.obuf = (unsigned char *)buf;
	as->as.dns.obuflen = buflen;
	as->as.dns.obufsize = buflen;

	_asr_unpack_init(&p, buf, buflen);
	_asr_unpack_header(&p, &h);
	_asr_unpack_query(&p, &q);
	if (p.err) {
		errno = EINVAL;
		goto err;
	}
	as->as.dns.reqid = h.id;
	as->as.dns.type = q.q_type;
	as->as.dns.class = q.q_class;
	as->as.dns.dname = strdup(q.q_dname);
	if (as->as.dns.dname == NULL)
		goto err; /* errno set */

	_asr_ctx_unref(ac);
	return (as);
    err:
	if (as)
		_asr_async_free(as);
	_asr_ctx_unref(ac);
	return (NULL);
}
DEF_WEAK(res_send_async);

/*
 * Unlike res_query(), this version will actually return the packet
 * if it has received a valid one (errno == 0) even if h_errno is
 * not NETDB_SUCCESS. So the packet *must* be freed if necessary.
 */
struct asr_query *
res_query_async(const char *name, int class, int type, void *asr)
{
	struct asr_ctx	 *ac;
	struct asr_query *as;

	DPRINT("asr: res_query_async(\"%s\", %i, %i)\n", name, class, type);

	ac = _asr_use_resolver(asr);
	as = _res_query_async_ctx(name, class, type, ac);
	_asr_ctx_unref(ac);

	return (as);
}
DEF_WEAK(res_query_async);

struct asr_query *
_res_query_async_ctx(const char *name, int class, int type, struct asr_ctx *a_ctx)
{
	struct asr_query	*as;

	DPRINT("asr: res_query_async_ctx(\"%s\", %i, %i)\n", name, class, type);

	if ((as = _asr_async_new(a_ctx, ASR_SEND)) == NULL)
		return (NULL); /* errno set */
	as->as_run = res_send_async_run;

	/* This adds a "." to name if it doesn't already has one.
	 * That's how res_query() behaves (through res_mkquery").
	 */
	if (setup_query(as, name, NULL, class, type) == -1)
		goto err; /* errno set */

	return (as);

    err:
	if (as)
		_asr_async_free(as);

	return (NULL);
}

static int
res_send_async_run(struct asr_query *as, struct asr_result *ar)
{
    next:
	switch (as->as_state) {

	case ASR_STATE_INIT:

		if (as->as_ctx->ac_nscount == 0) {
			ar->ar_errno = ECONNREFUSED;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		async_set_state(as, ASR_STATE_NEXT_NS);
		break;

	case ASR_STATE_NEXT_NS:

		if (iter_ns(as) == -1) {
			ar->ar_errno = ETIMEDOUT;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (as->as_ctx->ac_options & RES_USEVC ||
		    as->as.dns.obuflen > PACKETSZ)
			async_set_state(as, ASR_STATE_TCP_WRITE);
		else
			async_set_state(as, ASR_STATE_UDP_SEND);
		break;

	case ASR_STATE_UDP_SEND:

		if (udp_send(as) == -1) {
			async_set_state(as, ASR_STATE_NEXT_NS);
			break;
		}
		async_set_state(as, ASR_STATE_UDP_RECV);
		ar->ar_cond = ASR_WANT_READ;
		ar->ar_fd = as->as_fd;
		ar->ar_timeout = as->as_timeout;
		return (ASYNC_COND);
		break;

	case ASR_STATE_UDP_RECV:

		if (udp_recv(as) == -1) {
			if (errno == ENOMEM) {
				ar->ar_errno = errno;
				async_set_state(as, ASR_STATE_HALT);
				break;
			}
			if (errno != EOVERFLOW) {
				/* Fail or timeout */
				async_set_state(as, ASR_STATE_NEXT_NS);
				break;
			}
			if (as->as_ctx->ac_options & RES_IGNTC)
				async_set_state(as, ASR_STATE_PACKET);
			else
				async_set_state(as, ASR_STATE_TCP_WRITE);
		} else
			async_set_state(as, ASR_STATE_PACKET);
		break;

	case ASR_STATE_TCP_WRITE:

		switch (tcp_write(as)) {
		case -1: /* fail or timeout */
			async_set_state(as, ASR_STATE_NEXT_NS);
			break;
		case 0:
			async_set_state(as, ASR_STATE_TCP_READ);
			ar->ar_cond = ASR_WANT_READ;
			ar->ar_fd = as->as_fd;
			ar->ar_timeout = as->as_timeout;
			return (ASYNC_COND);
		case 1:
			ar->ar_cond = ASR_WANT_WRITE;
			ar->ar_fd = as->as_fd;
			ar->ar_timeout = as->as_timeout;
			return (ASYNC_COND);
		}
		break;

	case ASR_STATE_TCP_READ:

		switch (tcp_read(as)) {
		case -1: /* Fail or timeout */
			if (errno == ENOMEM) {
				ar->ar_errno = errno;
				async_set_state(as, ASR_STATE_HALT);
			} else
				async_set_state(as, ASR_STATE_NEXT_NS);
			break;
		case 0:
			async_set_state(as, ASR_STATE_PACKET);
			break;
		case 1:
			ar->ar_cond = ASR_WANT_READ;
			ar->ar_fd = as->as_fd;
			ar->ar_timeout = as->as_timeout;
			return (ASYNC_COND);
		}
		break;

	case ASR_STATE_PACKET:

		memmove(&ar->ar_ns, AS_NS_SA(as), AS_NS_SA(as)->sa_len);
		ar->ar_datalen = as->as.dns.ibuflen;
		ar->ar_data = as->as.dns.ibuf;
		as->as.dns.ibuf = NULL;
		ar->ar_errno = 0;
		ar->ar_rcode = as->as.dns.rcode;
		async_set_state(as, ASR_STATE_HALT);
		break;

	case ASR_STATE_HALT:

		if (ar->ar_errno) {
			ar->ar_h_errno = TRY_AGAIN;
			ar->ar_count = 0;
			ar->ar_datalen = -1;
			ar->ar_data = NULL;
		} else if (as->as.dns.ancount) {
			ar->ar_h_errno = NETDB_SUCCESS;
			ar->ar_count = as->as.dns.ancount;
		} else {
			ar->ar_count = 0;
			switch (as->as.dns.rcode) {
			case NXDOMAIN:
				ar->ar_h_errno = HOST_NOT_FOUND;
				break;
			case SERVFAIL:
				ar->ar_h_errno = TRY_AGAIN;
				break;
			case NOERROR:
				ar->ar_h_errno = NO_DATA;
				break;
			default:
				ar->ar_h_errno = NO_RECOVERY;
			}
		}
		return (ASYNC_DONE);

	default:

		ar->ar_errno = EOPNOTSUPP;
		ar->ar_h_errno = NETDB_INTERNAL;
		async_set_state(as, ASR_STATE_HALT);
		break;
	}
	goto next;
}

static int
sockaddr_connect(const struct sockaddr *sa, int socktype)
{
	int errno_save, sock;

	if ((sock = socket(sa->sa_family,
	    socktype | SOCK_NONBLOCK | SOCK_DNS, 0)) == -1)
		goto fail;

	if (connect(sock, sa, sa->sa_len) == -1) {
		/*
		 * In the TCP case, the caller will be asked to poll for
		 * POLLOUT so that we start writing the packet in tcp_write()
		 * when the connection is established, or fail there on error.
		 */
		if (errno == EINPROGRESS)
			return (sock);
		goto fail;
	}

	return (sock);

    fail:

	if (sock != -1) {
		errno_save = errno;
		close(sock);
		errno = errno_save;
	}

	return (-1);
}

/*
 * Prepare the DNS packet for the query type "type", class "class" and domain
 * name created by the concatenation on "name" and "dom".
 * Return 0 on success, set errno and return -1 on error.
 */
static int
setup_query(struct asr_query *as, const char *name, const char *dom,
	int class, int type)
{
	struct asr_pack		p;
	struct asr_dns_header	h;
	char			fqdn[MAXDNAME];
	char			dname[MAXDNAME];

	if (as->as_flags & ASYNC_EXTOBUF) {
		errno = EINVAL;
		DPRINT("attempting to write in user packet");
		return (-1);
	}

	if (_asr_make_fqdn(name, dom, fqdn, sizeof(fqdn)) > sizeof(fqdn)) {
		errno = EINVAL;
		DPRINT("asr_make_fqdn: name too long\n");
		return (-1);
	}

	if (_asr_dname_from_fqdn(fqdn, dname, sizeof(dname)) == -1) {
		errno = EINVAL;
		DPRINT("asr_dname_from_fqdn: invalid\n");
		return (-1);
	}

	if (as->as.dns.obuf == NULL) {
		as->as.dns.obufsize = PACKETSZ;
		as->as.dns.obuf = malloc(as->as.dns.obufsize);
		if (as->as.dns.obuf == NULL)
			return (-1); /* errno set */
	}
	as->as.dns.obuflen = 0;

	memset(&h, 0, sizeof h);
	h.id = res_randomid();
	if (as->as_ctx->ac_options & RES_RECURSE)
		h.flags |= RD_MASK;
	h.qdcount = 1;
	if (as->as_ctx->ac_options & (RES_USE_EDNS0 | RES_USE_DNSSEC))
		h.arcount = 1;

	_asr_pack_init(&p, as->as.dns.obuf, as->as.dns.obufsize);
	_asr_pack_header(&p, &h);
	_asr_pack_query(&p, type, class, dname);
	if (as->as_ctx->ac_options & (RES_USE_EDNS0 | RES_USE_DNSSEC))
		_asr_pack_edns0(&p, MAXPACKETSZ,
		    as->as_ctx->ac_options & RES_USE_DNSSEC);
	if (p.err) {
		DPRINT("error packing query");
		errno = EINVAL;
		return (-1);
	}

	/* Remember the parameters. */
	as->as.dns.reqid = h.id;
	as->as.dns.type = type;
	as->as.dns.class = class;
	if (as->as.dns.dname)
		free(as->as.dns.dname);
	as->as.dns.dname = strdup(dname);
	if (as->as.dns.dname == NULL) {
		DPRINT("strdup");
		return (-1); /* errno set */
	}
	as->as.dns.obuflen = p.offset;

	DPRINT_PACKET("asr_setup_query", as->as.dns.obuf, as->as.dns.obuflen);

	return (0);
}

/*
 * Create a connect UDP socket and send the output packet.
 *
 * Return 0 on success, or -1 on error (errno set).
 */
static int
udp_send(struct asr_query *as)
{
	ssize_t	n;
	int	save_errno;
#ifdef DEBUG
	char		buf[256];
#endif

	DPRINT("asr: [%p] connecting to %s UDP\n", as,
	    _asr_print_sockaddr(AS_NS_SA(as), buf, sizeof buf));

	as->as_fd = sockaddr_connect(AS_NS_SA(as), SOCK_DGRAM);
	if (as->as_fd == -1)
		return (-1); /* errno set */

	n = send(as->as_fd, as->as.dns.obuf, as->as.dns.obuflen, 0);
	if (n == -1) {
		save_errno = errno;
		close(as->as_fd);
		errno = save_errno;
		as->as_fd = -1;
		return (-1);
	}

	return (0);
}

/*
 * Try to receive a valid packet from the current UDP socket.
 *
 * Return 0 if a full packet could be read, or -1 on error (errno set).
 */
static int
udp_recv(struct asr_query *as)
{
	ssize_t		 n;
	int		 save_errno;

	if (ensure_ibuf(as, MAXPACKETSZ) == -1) {
		save_errno = errno;
		close(as->as_fd);
		errno = save_errno;
		as->as_fd = -1;
		return (-1);
	}

	n = recv(as->as_fd, as->as.dns.ibuf, as->as.dns.ibufsize, 0);
	save_errno = errno;
	close(as->as_fd);
	errno = save_errno;
	as->as_fd = -1;
	if (n == -1)
		return (-1);

	as->as.dns.ibuflen = n;

	DPRINT_PACKET("asr_udp_recv()", as->as.dns.ibuf, as->as.dns.ibuflen);

	if (validate_packet(as) == -1)
		return (-1); /* errno set */

	return (0);
}

/*
 * Write the output packet to the TCP socket.
 *
 * Return 0 when all bytes have been sent, 1 there is no buffer space on the
 * socket or it is not connected yet, or -1 on error (errno set).
 */
static int
tcp_write(struct asr_query *as)
{
	struct msghdr	msg;
	struct iovec	iov[2];
	uint16_t	len;
	ssize_t		n;
	size_t		offset;
	int		i;
#ifdef DEBUG
	char		buf[256];
#endif

	/* First try to connect if not already */
	if (as->as_fd == -1) {
		DPRINT("asr: [%p] connecting to %s TCP\n", as,
		    _asr_print_sockaddr(AS_NS_SA(as), buf, sizeof buf));
		as->as_fd = sockaddr_connect(AS_NS_SA(as), SOCK_STREAM);
		if (as->as_fd == -1)
			return (-1); /* errno set */
		as->as.dns.datalen = 0; /* bytes sent */
		return (1);
	}

	i = 0;

	/* Prepend de packet length if not sent already. */
	if (as->as.dns.datalen < sizeof(len)) {
		offset = 0;
		len = htons(as->as.dns.obuflen);
		iov[i].iov_base = (char *)(&len) + as->as.dns.datalen;
		iov[i].iov_len = sizeof(len) - as->as.dns.datalen;
		i++;
	} else
		offset = as->as.dns.datalen - sizeof(len);

	iov[i].iov_base = as->as.dns.obuf + offset;
	iov[i].iov_len = as->as.dns.obuflen - offset;
	i++;

	memset(&msg, 0, sizeof msg);
	msg.msg_iov = iov;
	msg.msg_iovlen = i;

    send_again:
	n = sendmsg(as->as_fd, &msg, MSG_NOSIGNAL);
	if (n == -1) {
		if (errno == EINTR)
			goto send_again;
		goto close; /* errno set */
	}

	as->as.dns.datalen += n;

	if (as->as.dns.datalen == as->as.dns.obuflen + sizeof(len)) {
		/* All sent. Prepare for TCP read */
		as->as.dns.datalen = 0;
		return (0);
	}

	/* More data to write */
	return (1);

close:
	close(as->as_fd);
	as->as_fd = -1;
	return (-1);
}

/*
 * Try to read a valid packet from the current TCP socket.
 *
 * Return 0 if a full packet could be read, 1 if more data is needed and the
 * socket must be read again, or -1 on error (errno set).
 */
static int
tcp_read(struct asr_query *as)
{
	ssize_t		 n;
	size_t		 offset, len;
	char		*pos;
	int		 save_errno, nfds;
	struct pollfd	 pfd;

	/* We must read the packet len first */
	if (as->as.dns.datalen < sizeof(as->as.dns.pktlen)) {

		pos = (char *)(&as->as.dns.pktlen) + as->as.dns.datalen;
		len = sizeof(as->as.dns.pktlen) - as->as.dns.datalen;

		n = read(as->as_fd, pos, len);
		if (n == -1)
			goto close; /* errno set */

		as->as.dns.datalen += n;
		if (as->as.dns.datalen < sizeof(as->as.dns.pktlen))
			return (1); /* need more data */

		as->as.dns.ibuflen = ntohs(as->as.dns.pktlen);
		if (ensure_ibuf(as, as->as.dns.ibuflen) == -1)
			goto close; /* errno set */

		pfd.fd = as->as_fd;
		pfd.events = POLLIN;
	    poll_again:
		nfds = poll(&pfd, 1, 0);
		if (nfds == -1) {
			if (errno == EINTR)
				goto poll_again;
			goto close; /* errno set */
		}
		if (nfds == 0)
			return (1); /* no more data available */
	}

	offset = as->as.dns.datalen - sizeof(as->as.dns.pktlen);
	pos = as->as.dns.ibuf + offset;
	len =  as->as.dns.ibuflen - offset;

    read_again:
	n = read(as->as_fd, pos, len);
	if (n == -1) {
		if (errno == EINTR)
			goto read_again;
		goto close; /* errno set */
	}
	if (n == 0) {
		errno = ECONNRESET;
		goto close;
	}
	as->as.dns.datalen += n;

	/* See if we got all the advertised bytes. */
	if (as->as.dns.datalen != as->as.dns.ibuflen + sizeof(as->as.dns.pktlen))
		return (1);

	DPRINT_PACKET("asr_tcp_read()", as->as.dns.ibuf, as->as.dns.ibuflen);

	if (validate_packet(as) == -1)
		goto close; /* errno set */

	errno = 0;
close:
	save_errno = errno;
	close(as->as_fd);
	errno = save_errno;
	as->as_fd = -1;
	return (errno ? -1 : 0);
}

/*
 * Make sure the input buffer is at least "n" bytes long, and allocate or
 * extend it if necessary. Return 0 on success, or set errno and return -1.
 */
static int
ensure_ibuf(struct asr_query *as, size_t n)
{
	char	*t;

	if (as->as.dns.ibufsize >= n)
		return (0);

	t = recallocarray(as->as.dns.ibuf, as->as.dns.ibufsize, n, 1);
	if (t == NULL)
		return (-1); /* errno set */
	as->as.dns.ibuf = t;
	as->as.dns.ibufsize = n;

	return (0);
}

/*
 * Check if the received packet is valid.
 * Return 0 on success, or set errno and return -1.
 */
static int
validate_packet(struct asr_query *as)
{
	struct asr_unpack	 p;
	struct asr_dns_header	 h;
	struct asr_dns_query	 q;
	struct asr_dns_rr	 rr;
	int			 r;

	_asr_unpack_init(&p, as->as.dns.ibuf, as->as.dns.ibuflen);

	_asr_unpack_header(&p, &h);
	if (p.err)
		goto inval;

	if (h.id != as->as.dns.reqid) {
		DPRINT("incorrect reqid\n");
		goto inval;
	}
	if (h.qdcount != 1)
		goto inval;
	/* Should be zero, we could allow this */
	if ((h.flags & Z_MASK) != 0)
		goto inval;
	/* Actually, it depends on the request but we only use OP_QUERY */
	if (OPCODE(h.flags) != OP_QUERY)
		goto inval;
	/* Must be a response */
	if ((h.flags & QR_MASK) == 0)
		goto inval;

	as->as.dns.rcode = RCODE(h.flags);
	as->as.dns.ancount = h.ancount;

	_asr_unpack_query(&p, &q);
	if (p.err)
		goto inval;

	if (q.q_type != as->as.dns.type ||
	    q.q_class != as->as.dns.class ||
	    strcasecmp(q.q_dname, as->as.dns.dname)) {
		DPRINT("incorrect type/class/dname '%s' != '%s'\n",
		    q.q_dname, as->as.dns.dname);
		goto inval;
	}

	/* Check for truncation */
	if (h.flags & TC_MASK && !(as->as_ctx->ac_options & RES_IGNTC)) {
		DPRINT("truncated\n");
		errno = EOVERFLOW;
		return (-1);
	}

	/* Validate the rest of the packet */
	for (r = h.ancount + h.nscount + h.arcount; r; r--)
		_asr_unpack_rr(&p, &rr);

	/* Report any error found when unpacking the RRs. */
	if (p.err) {
		DPRINT("unpack: %s\n", strerror(p.err));
		errno = p.err;
		return (-1);
	}

	if (p.offset != as->as.dns.ibuflen) {
		DPRINT("trailing garbage\n");
		errno = EMSGSIZE;
		return (-1);
	}

	return (0);

    inval:
	errno = EINVAL;
	return (-1);
}

/*
 * Set the async context nameserver index to the next nameserver, cycling
 * over the list until the maximum retry counter is reached.  Return 0 on
 * success, or -1 if all nameservers were used.
 */
static int
iter_ns(struct asr_query *as)
{
	for (;;) {
		if (as->as.dns.nsloop >= as->as_ctx->ac_nsretries)
			return (-1);

		as->as.dns.nsidx += 1;
		if (as->as.dns.nsidx <= as->as_ctx->ac_nscount)
			break;
		as->as.dns.nsidx = 0;
		as->as.dns.nsloop++;
		DPRINT("asr: iter_ns(): cycle %i\n", as->as.dns.nsloop);
	}

	as->as_timeout = 1000 * (as->as_ctx->ac_nstimeout << as->as.dns.nsloop);
	if (as->as.dns.nsloop > 0)
		as->as_timeout /= as->as_ctx->ac_nscount;
	if (as->as_timeout < 1000)
		as->as_timeout = 1000;

	return (0);
}
@


1.35
log
@don't need to handle the malloc case special, since realloc works
with NULL
ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.34 2017/02/27 11:38:08 jca Exp $	*/
d651 1
a651 1
	t = realloc(as->as.dns.ibuf, n);
@


1.34
log
@Add support for RES_USE_DNSSEC

RES_USE_DNSSEC is implemented by setting the DNSSEC DO bit in outgoing
queries.  The resolver is then supposed to set the AD bit in the reply
if it managed to validate the answer through DNSSEC.  Useful when the
application doesn't implement validation internally.  This scheme
assumes that the validating resolver is trusted and that the
communication channel between the validating resolver and and the client
is secure.

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.33 2017/02/27 10:44:46 jca Exp $	*/
a646 8

	if (as->as.dns.ibuf == NULL) {
		as->as.dns.ibuf = malloc(n);
		if (as->as.dns.ibuf == NULL)
			return (-1); /* errno set */
		as->as.dns.ibufsize = n;
		return (0);
	}
@


1.33
log
@Put a common flags field in the query struct, rather than in some
elements of the union.

This field is for internal asr flags.  The flags in "struct rrset" and
"struct ni" are different kinds of flags.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.32 2017/02/18 22:25:13 eric Exp $	*/
d380 1
a380 1
	if (as->as_ctx->ac_options & RES_USE_EDNS0)
d386 3
a388 2
	if (as->as_ctx->ac_options & RES_USE_EDNS0)
		_asr_pack_edns0(&p, MAXPACKETSZ);
@


1.32
log
@Use more specific error codes for invalid packets.
In particular, truncated packets without the TC flag set (non-compliant
server sending too large packets) now fail with EOVERFLOW instead of EINVAL,
so the TCP fallback mechanism can work.

feedback and ok krw@@ jca@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.31 2017/02/18 19:23:05 jca Exp $	*/
d70 1
a70 1
	as->as.dns.flags |= ASYNC_EXTOBUF;
d349 1
a349 1
	if (as->as.dns.flags & ASYNC_EXTOBUF) {
@


1.31
log
@Add EDNS0 support.

EDNS allows for various DNS extensions, among which UDP DNS packets size
bigger than 512 bytes.  The default is still to not advertize anything.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.30 2017/02/17 00:29:22 krw Exp $	*/
d718 2
a719 1
	if (h.flags & TC_MASK) {
d728 12
a739 2
	if (p.err || (p.offset != as->as.dns.ibuflen))
		goto inval;
@


1.30
log
@Increase UDP packet buffer to 4096 bytes from 512. There are some really
broken DNS servers out there that send packets >512 bytes w/o even the
courtesy of trying to use EDNS0.

A partial workaround as more complete packet parsing solutions are
worked on.

ok jca@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.29 2015/10/23 00:52:09 deraadt Exp $	*/
d380 2
d386 2
a454 2

#define MAXPACKETSZ	4096
@


1.29
log
@Switch to using SOCK_DNS flag, rather than the dnssocket() and
dnssonnect() calls.  Be a bit careful crossing over this, need a kernel
no older than Monday.
ok guenther tedu semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.28 2015/10/18 15:15:00 deraadt Exp $	*/
d452 3
a454 1
	if (ensure_ibuf(as, PACKETSZ) == -1) {
@


1.28
log
@libc DNS functions will now use the new dnssocket() / dnsconnect()
system calls.  These signal to the pledge kernel code that a DNS
transaction is happening.  These special sockets only work well with
port 53 (there are some cute plans...).
Programs calling pledge "inet" will not work! You need pledge "dns",

and of course, you need a fairly fresh kernel.

ok guenther kettenis tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.27 2015/09/20 14:19:21 eric Exp $	*/
d307 2
a308 1
	if ((sock = dnssocket(sa->sa_family, socktype | SOCK_NONBLOCK, 0)) == -1)
d311 1
a311 1
	if (dnsconnect(sock, sa, sa->sa_len) == -1) {
@


1.27
log
@remove bogus includes of err.h
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.26 2015/09/14 11:52:49 guenther Exp $	*/
d307 1
a307 1
	if ((sock = socket(sa->sa_family, socktype | SOCK_NONBLOCK, 0)) == -1)
d310 1
a310 1
	if (connect(sock, sa, sa->sa_len) == -1) {
@


1.26
log
@Wrap <asr.h> so internal calls go direct and all the symbols are weak
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.25 2015/09/09 15:49:34 deraadt Exp $	*/
a25 1
#include <err.h>
@


1.25
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.24 2015/09/09 15:40:04 guenther Exp $	*/
d98 1
d119 1
@


1.24
log
@Use SOCK_NONBLOCK in a couple more places

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.23 2015/06/20 01:16:25 jca Exp $	*/
d64 3
a66 3
	ac = asr_use_resolver(asr);
	if ((as = asr_async_new(ac, ASR_SEND)) == NULL) {
		asr_ctx_unref(ac);
d76 3
a78 3
	asr_unpack_init(&p, buf, buflen);
	asr_unpack_header(&p, &h);
	asr_unpack_query(&p, &q);
d90 1
a90 1
	asr_ctx_unref(ac);
d94 2
a95 2
		asr_async_free(as);
	asr_ctx_unref(ac);
d112 3
a114 3
	ac = asr_use_resolver(asr);
	as = res_query_async_ctx(name, class, type, ac);
	asr_ctx_unref(ac);
d120 1
a120 1
res_query_async_ctx(const char *name, int class, int type, struct asr_ctx *a_ctx)
d126 1
a126 1
	if ((as = asr_async_new(a_ctx, ASR_SEND)) == NULL)
d140 1
a140 1
		asr_async_free(as);
d353 1
a353 1
	if (asr_make_fqdn(name, dom, fqdn, sizeof(fqdn)) > sizeof(fqdn)) {
d359 1
a359 1
	if (asr_dname_from_fqdn(fqdn, dname, sizeof(dname)) == -1) {
d379 3
a381 3
	asr_pack_init(&p, as->as.dns.obuf, as->as.dns.obufsize);
	asr_pack_header(&p, &h);
	asr_pack_query(&p, type, class, dname);
d421 1
a421 1
	    asr_print_sockaddr(AS_NS_SA(as), buf, sizeof buf));
d498 1
a498 1
		    asr_print_sockaddr(AS_NS_SA(as), buf, sizeof buf));
d674 1
a674 1
	asr_unpack_init(&p, as->as.dns.ibuf, as->as.dns.ibuflen);
d676 1
a676 1
	asr_unpack_header(&p, &h);
d699 1
a699 1
	asr_unpack_query(&p, &q);
d719 1
a719 1
		asr_unpack_rr(&p, &rr);
@


1.23
log
@Rename print_sockaddr() to avoid symbol visibility problems

print_sockaddr is internal to asr, and conflicts with ports/net/samba4.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.22 2014/03/26 18:13:15 eric Exp $	*/
d304 1
a304 1
	int errno_save, flags, sock;
d306 1
a306 9
	if ((sock = socket(sa->sa_family, socktype, 0)) == -1)
		goto fail;

	if ((flags = fcntl(sock, F_GETFL, 0)) == -1)
		goto fail;

	flags |= O_NONBLOCK;

	if ((flags = fcntl(sock, F_SETFL, flags)) == -1)
@


1.22
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.21 2014/03/25 19:48:11 eric Exp $	*/
d429 1
a429 1
	    print_sockaddr(AS_NS_SA(as), buf, sizeof buf));
d506 1
a506 1
		    print_sockaddr(AS_NS_SA(as), buf, sizeof buf));
@


1.21
log
@Cleanup and simplify the API to be exposed.  Use better names for
structures, functions and defines.

discussed with and ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.20 2014/03/14 11:07:33 eric Exp $	*/
d19 1
d23 1
d25 1
a34 1
#include "asr.h"
@


1.20
log
@prefix structure names to avoid ambiguity and possible collisions when
the API gets public.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.19 2013/07/12 14:36:22 eric Exp $	*/
d37 1
a37 1
static int res_send_async_run(struct async *, struct async_res *);
d39 8
a46 8
static int udp_send(struct async *);
static int udp_recv(struct async *);
static int tcp_write(struct async *);
static int tcp_read(struct async *);
static int validate_packet(struct async *);
static int setup_query(struct async *, const char *, const char *, int, int);
static int ensure_ibuf(struct async *, size_t);
static int iter_ns(struct async *);
d51 2
a52 2
struct async *
res_send_async(const unsigned char *buf, int buflen, struct asr *asr)
d55 1
a55 1
	struct async		*as;
d100 1
a100 2
 * not NETDB_SUCCESS. So the packet *must* be freed if necessary
 * (ans == NULL).
d102 2
a103 2
struct async *
res_query_async(const char *name, int class, int type, struct asr *asr)
d105 2
a106 2
	struct asr_ctx	*ac;
	struct async	*as;
d117 1
a117 1
struct async *
d120 1
a120 1
	struct async	*as;
d144 1
a144 1
res_send_async_run(struct async *as, struct async_res *ar)
d182 1
a182 1
		ar->ar_cond = ASYNC_READ;
d217 1
a217 1
			ar->ar_cond = ASYNC_READ;
d222 1
a222 1
			ar->ar_cond = ASYNC_WRITE;
d243 1
a243 1
			ar->ar_cond = ASYNC_READ;
d252 1
a252 1
		memmove(&ar->ar_sa.sa, AS_NS_SA(as), AS_NS_SA(as)->sa_len);
d345 1
a345 1
setup_query(struct async *as, const char *name, const char *dom,
d418 1
a418 1
udp_send(struct async *as)
d451 1
a451 1
udp_recv(struct async *as)
d489 1
a489 1
tcp_write(struct async *as)
d564 1
a564 1
tcp_read(struct async *as)
d643 1
a643 1
ensure_ibuf(struct async *as, size_t n)
d672 1
a672 1
validate_packet(struct async *as)
d743 1
a743 1
iter_ns(struct async *as)
@


1.19
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.18 2013/06/01 09:21:10 eric Exp $	*/
d54 5
a58 5
	struct asr_ctx  *ac;
	struct async	*as;
	struct unpack	 p;
	struct header	 h;
	struct query	 q;
d349 4
a352 4
	struct pack	 p;
	struct header	 h;
	char		 fqdn[MAXDNAME];
	char		 dname[MAXDNAME];
d675 5
a679 5
	struct unpack	 p;
	struct header	 h;
	struct query	 q;
	struct rr	 rr;
	int		 r;
@


1.18
log
@iterating over the ns list only matters for res_send_async.c, so move
things around.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.17 2013/04/30 12:02:39 eric Exp $	*/
d46 1
a46 1
int asr_iter_ns(struct async *);
d63 1
a63 1
	if ((as = async_new(ac, ASR_SEND)) == NULL) {
d74 3
a76 3
	unpack_init(&p, buf, buflen);
	unpack_header(&p, &h);
	unpack_query(&p, &q);
d92 1
a92 1
		async_free(as);
d125 1
a125 1
	if ((as = async_new(a_ctx, ASR_SEND)) == NULL)
d139 1
a139 1
		async_free(as);
d163 1
a163 1
		if (asr_iter_ns(as) == -1) {
d366 1
a366 1
	if (dname_from_fqdn(fqdn, dname, sizeof(dname)) == -1) {
d368 1
a368 1
		DPRINT("dname_from_fqdn: invalid\n");
d386 3
a388 3
	pack_init(&p, as->as.dns.obuf, as->as.dns.obufsize);
	pack_header(&p, &h);
	pack_query(&p, type, class, dname);
d681 1
a681 1
	unpack_init(&p, as->as.dns.ibuf, as->as.dns.ibuflen);
d683 1
a683 1
	unpack_header(&p, &h);
d706 1
a706 1
	unpack_query(&p, &q);
d726 1
a726 1
		unpack_rr(&p, &rr);
d743 2
a744 2
int
asr_iter_ns(struct async *as)
d755 1
a755 1
		DPRINT("asr: asr_iter_ns(): cycle %i\n", as->as.dns.nsloop);
@


1.17
log
@Do not take external buffers for storing DNS responses in the internal
async API.  That is actually useless and it makes the code more
complicated.  The required buffers are always allocated when needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.16 2013/04/14 22:23:08 deraadt Exp $	*/
d46 1
d48 1
a48 2

#define AS_NS_SA(p) ((p)->as_ctx->ac_ns[(p)->as_ns_idx - 1])
d736 29
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.15 2013/04/05 07:12:24 eric Exp $	*/
d52 1
a52 2
res_send_async(const unsigned char *buf, int buflen, unsigned char *ans,
	int anslen, struct asr *asr)
a68 11
	if (ans) {
		as->as.dns.flags |= ASYNC_EXTIBUF;
		as->as.dns.ibuf = ans;
		as->as.dns.ibufsize = anslen;
		as->as.dns.ibuflen = 0;
	} else {
		as->as.dns.ibuf = NULL;
		as->as.dns.ibufsize = 0;
		as->as.dns.ibuflen = 0;
	}

d104 1
a104 2
res_query_async(const char *name, int class, int type, unsigned char *ans,
	int anslen, struct asr *asr)
d112 1
a112 1
	as = res_query_async_ctx(name, class, type, ans, anslen, ac);
d119 1
a119 2
res_query_async_ctx(const char *name, int class, int type, unsigned char *ans,
	int anslen, struct asr_ctx *a_ctx)
a128 10
	if (ans) {
		as->as.dns.flags |= ASYNC_EXTIBUF;
		as->as.dns.ibuf = ans;
		as->as.dns.ibufsize = anslen;
	} else {
		as->as.dns.ibuf = NULL;
		as->as.dns.ibufsize = 0;
	}
	as->as.dns.ibuflen = 0;

d457 6
a462 9
	/* Allocate input buf if needed */
	if (as->as.dns.ibuf == NULL) {
		if (ensure_ibuf(as, PACKETSZ) == -1) {
			save_errno = errno;
			close(as->as_fd);
			errno = save_errno;
			as->as_fd = -1;
			return (-1);
		}
d640 2
a641 3
 * Make sure the input buffer is at least "n" bytes long.
 * If not (or not allocated) allocated enough space, unless the
 * buffer is external (owned by the caller), in which case it fails.
a646 7

	if (as->as.dns.flags & ASYNC_EXTIBUF) {
		if (n <= as->as.dns.ibufsize)
			return (0);
		errno = EINVAL;
		return (-1);
	}
@


1.15
log
@do not fail on EINTR

suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.14 2013/04/03 19:38:20 matthew Exp $	*/
d603 1
a603 1
		pos = (char*)(&as->as.dns.pktlen) + as->as.dns.datalen;
@


1.14
log
@Use MSG_NOSIGNAL when writing DNS queries over TCP sockets to ensure
we don't trigger SIGPIPE.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.13 2013/04/02 21:57:33 eric Exp $	*/
d560 1
d562 3
a564 1
	if (n == -1)
d566 1
d620 1
d622 3
a624 1
		if (nfds == -1)
d626 1
d635 1
d637 3
a639 1
	if (n == -1)
d641 1
@


1.13
log
@add comment for how EINPROGRESS is handled there.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.12 2013/04/02 16:38:37 eric Exp $	*/
d519 1
d556 5
a560 1
	n = writev(as->as_fd, iov, i);
@


1.12
log
@better implementation for tcp_read() that can get the packet length in
multiple read.

prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.11 2013/04/01 16:04:03 deraadt Exp $	*/
d341 5
@


1.11
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.10 2013/04/01 15:49:54 deraadt Exp $	*/
d26 1
d580 5
a584 3
	uint16_t	len;
	ssize_t		n;
	int		save_errno;
d587 6
a592 2
	if (as->as.dns.datalen == 0) {
		n = read(as->as_fd, &len, sizeof(len));
a594 9
		/*
		 * If the server has sent us only the first byte, we fail.
		 * Technically, we could recover but it might not be worth
		 * supporting that.
		 */
		if (n < 2) {
			errno = EIO;
			goto close;
		}
d596 7
a602 2
		as->as.dns.datalen = ntohs(len);
		as->as.dns.ibuflen = 0;
d604 4
a607 1
		if (ensure_ibuf(as, as->as.dns.datalen) == -1)
d609 2
d613 5
a617 2
	n = read(as->as_fd, as->as.dns.ibuf + as->as.dns.ibuflen,
	    as->as.dns.datalen - as->as.dns.ibuflen);
d624 1
a624 1
	as->as.dns.ibuflen += n;
d627 1
a627 1
	if (as->as.dns.ibuflen != as->as.dns.datalen)
@


1.10
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.9 2013/04/01 07:52:06 eric Exp $	*/
d539 1
a539 1
		iov[i].iov_base = (char*)(&len) + as->as.dns.datalen;
@


1.9
log
@simpler and saner implementation for tcp_write(). now fully handles
short writes.

prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.8 2013/03/31 19:42:10 eric Exp $	*/
d81 1
a81 1
	as->as.dns.obuf = (unsigned char*)buf;
@


1.8
log
@Principle of least astonishment: implement nameserver retry/backoff as
in the former resolver.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.7 2013/03/27 07:40:41 eric Exp $	*/
d516 2
a517 2
	int		i, se;
	socklen_t	sl;
d529 1
d535 3
a537 13
	/* Check if the connection succeeded. */
	if (as->as.dns.datalen == 0) {
		sl = sizeof(se);
		if (getsockopt(as->as_fd, SOL_SOCKET, SO_ERROR, &se, &sl) == -1)
			goto close; /* errno set */
		if (se) {
			errno = se;
			goto close;
		}

		as->as.dns.bufpos = 0;

		/* Send the packet length first */
d539 2
a540 2
		iov[i].iov_base = &len;
		iov[i].iov_len = sizeof(len);
d542 2
a543 1
	}
d545 2
a546 2
	iov[i].iov_base = as->as.dns.obuf + as->as.dns.bufpos;
	iov[i].iov_len = as->as.dns.obuflen - as->as.dns.bufpos;
d553 1
a553 14
	/*
	 * We want at least the packet length to be written out the first time.
	 * Technically we could recover but that makes little sense to support
	 * that.
	 */
	if (as->as.dns.datalen == 0 && n < 2) {
		errno = EIO;
		goto close;
	}

	if (as->as.dns.datalen == 0) {
		as->as.dns.datalen = len;
		n -= 2;
	}
d555 1
a555 2
	as->as.dns.bufpos += n;
	if (as->as.dns.bufpos == as->as.dns.obuflen) {
a598 1
		as->as.dns.bufpos = 0;
@


1.7
log
@Only use the search domains for DNS lookups, as the current resolver does.
Better not diverge too much in behavior at this point.
Typo fix and doc update while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.6 2012/11/24 15:12:48 eric Exp $	*/
a451 2
	as->as_timeout = as->as_ctx->ac_nstimeout;

a528 1
		as->as_timeout = as->as_ctx->ac_nstimeout;
a583 1
	as->as_timeout = as->as_ctx->ac_nstimeout;
@


1.6
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.5 2012/11/24 13:59:53 eric Exp $	*/
d153 1
a153 1
	 * That's how res_query() behaves (trough res_mkquery").
@


1.5
log
@make separate structures for pack and unpack
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.4 2012/09/09 12:15:32 eric Exp $	*/
a19 1

d171 1
a171 1
	switch(as->as_state) {
d297 1
a297 1
			switch(as->as.dns.rcode) {
d318 1
a318 1
                break;
d730 1
a730 1
		goto inval;	
d754 1
a754 1
	for(r = h.ancount + h.nscount + h.arcount; r; r--)
@


1.4
log
@cleanup asr_debug.c
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.3 2012/09/09 09:42:06 eric Exp $	*/
d57 1
a57 1
	struct packed	 p;
d86 1
a86 1
	packed_init(&p, (char*)buf, buflen);
d368 1
a368 1
	struct packed	 p;
d405 1
a405 1
	packed_init(&p, as->as.dns.obuf, as->as.dns.obufsize);
d705 1
a705 1
	struct packed	 p;
d711 1
a711 1
	packed_init(&p, as->as.dns.ibuf, as->as.dns.ibuflen);
@


1.3
log
@use proper macros for debug traces.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.2 2012/07/07 20:41:52 eric Exp $	*/
d447 1
a447 1
	    asr_print_addr(AS_NS_SA(as), buf, sizeof buf));
d528 1
a528 1
		    asr_print_addr(AS_NS_SA(as), buf, sizeof buf));
@


1.2
log
@rename function to avoid symbol clash
@
text
@d1 1
a1 1
/*	$OpenBSD: res_send_async.c,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
d61 2
a62 6
#ifdef DEBUG
	if (asr_debug) {
		asr_printf("asr: res_send_async()\n");
		asr_dump_packet(stderr, buf, buflen, 0);
	}
#endif
d121 3
a123 3
#ifdef DEBUG
	asr_printf("asr: res_query_async(\"%s\", %i, %i)\n", name, class, type);
#endif
d137 2
a138 4
#ifdef DEBUG
	asr_printf("asr: res_query_async_ctx(\"%s\", %i, %i)\n", name, class,
	    type);
#endif
d375 1
a375 3
#ifdef DEBUG
		asr_printf("attempting to write in user packet");
#endif
d381 1
a381 3
#ifdef DEBUG
		asr_printf("asr_make_fqdn: name too long\n");
#endif
d387 1
a387 3
#ifdef DEBUG
		asr_printf("dname_from_fqdn: invalid\n");
#endif
d409 1
a409 3
#ifdef DEBUG
		asr_printf("error packing query");
#endif
d422 1
a422 3
#ifdef DEBUG
		asr_printf("strdup");
#endif
d427 1
a427 7
#ifdef DEBUG
	if (asr_debug) {
		asr_printf("------- asr_setup_query(): packet -------\n");
		asr_dump_packet(stderr, as->as.dns.obuf, as->as.dns.obuflen, 0);
		asr_printf("-----------------------------------------\n");
	}
#endif
d444 4
a448 4
	if (asr_debug)
		asr_printf("asr: [%p] connecting to %s UDP\n", as,
		    asr_print_addr(AS_NS_SA(as), buf, sizeof buf));
#endif
d499 1
a499 7
#ifdef DEBUG
	if (asr_debug) {
		asr_printf("------- asr_udp_recv() packet -------\n");
		asr_dump_packet(stderr, as->as.dns.ibuf, as->as.dns.ibuflen, 0);
		asr_printf("-------------------------------------\n");
	}
#endif
d527 2
a528 5
#ifdef DEBUG
		if (asr_debug)
			asr_printf("asr: [%p] connecting to %s TCP\n", as,
			    asr_print_addr(AS_NS_SA(as), buf, sizeof buf));
#endif
d647 2
a648 7
#ifdef DEBUG
	if (asr_debug) {
		asr_printf("------- asr_tcp_read() packet -------\n");
		asr_dump_packet(stderr, as->as.dns.ibuf, as->as.dns.ibuflen, 0);
		asr_printf("-------------------------------------\n");
	}
#endif
d718 1
a718 3
#ifdef DEBUG
		asr_printf("incorrect reqid\n");
#endif
d743 1
a743 2
#ifdef DEBUG
		asr_printf("incorrect type/class/dname '%s' != '%s'\n",
a744 1
#endif
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.10 2011/07/13 16:14:43 eric Exp $	*/
a46 3
#ifdef DEBUG
char *print_addr(const struct sockaddr *, char *, size_t);
#endif
d469 1
a469 1
		    print_addr(AS_NS_SA(as), buf, sizeof buf));
d558 1
a558 1
			    print_addr(AS_NS_SA(as), buf, sizeof buf));
@

