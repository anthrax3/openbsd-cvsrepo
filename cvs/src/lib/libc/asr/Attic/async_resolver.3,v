head	1.15;
access;
symbols
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.6.0.2
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2;
locks; strict;
comment	@.\" @;


1.15
date	2013.08.08.06.55.43;	author jmc;	state dead;
branches;
next	1.14;

1.14
date	2013.07.12.14.36.21;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.05.03.39.22;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.30.13.05.44;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.30.12.02.39;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.01.15.49.54;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.30.20.00.08;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.27.16.21.22;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.27.07.40.41;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.06.08.38.15;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.06.08.36.52;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.19.16.17.40;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.18.16.48.17;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.15.15.08.12;	author jmc;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.15
log
@sync with recent name changes;
@
text
@.\"	$OpenBSD: async_resolver.3,v 1.14 2013/07/12 14:36:21 eric Exp $
.\"
.\" Copyright (c) 2012, Eric Faurot <eric@@openbsd.org>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: July 12 2013 $
.Dt ASYN_RESOLVER 3
.Os
.Sh NAME
.Nm asr_resolver ,
.Nm asr_resolver_done ,
.Nm asr_async_run ,
.Nm asr_async_run_sync ,
.Nm asr_async_abort ,
.Nm res_send_async ,
.Nm res_query_async ,
.Nm res_search_async ,
.Nm getrrsetbyname_async ,
.Nm gethostbyname_async ,
.Nm gethostbyname2_async ,
.Nm gethostbyaddr_async ,
.Nm getnetbyname_async ,
.Nm getnetbyaddr_async ,
.Nm freenetent ,
.Nm getaddrinfo_async ,
.Nm getnameinfo_async
.Nd asynchronous resolver functions
.Sh SYNOPSIS
.In asr.h
.Ft struct asr *
.Fn asr_resolver "const char *conf"
.Ft void
.Fn asr_resolver_done "struct asr *asr"
.Ft int
.Fn asr_async_run "struct async *as" "struct async_res *ar"
.Ft int
.Fn asr_async_run_sync "struct async *as" "struct async_res *ar"
.Ft void
.Fn asr_async_abort "struct async *as"
.Ft struct async *
.Fn res_send_async "const unsigned char *pkt" "int pktlen" "struct asr *asr"
.Ft struct async *
.Fn res_query_async "const char *name" "int class" "int type" "struct asr *asr"
.Ft struct async *
.Fn res_search_async "const char *name" "int class" "int type" "struct asr *asr"
.Ft struct async *
.Fn getrrsetbyname_async "const char *hostname" "unsigned int rdclass" "unsigned int rdtype" "unsigned int flags" "struct asr *asr"
.Ft struct async *
.Fn gethostbyname_async "const char *name" "struct asr *asr"
.Ft struct async *
.Fn gethostbyname2_async "const char *name" "int af" "struct asr *asr"
.Ft struct async *
.Fn gethostbyaddr_async "const void *addr" "socklen_t len" "int af" "struct asr *asr"
.Ft struct async *
.Fn getnetbyname_async "const char *name" "struct asr *asr"
.Ft struct async *
.Fn getnetbyaddr_async "in_addr_t net" "int type" "struct asr *asr"
.Ft struct async *
.Fn getaddrinfo_async "const char *hostname" "const char *servname" "const struct addrinfo *hints" "struct asr *asr"
.Ft struct async *
.Fn getnameinfo_async "const struct sockaddr *sa" "socklen_t salen" "char *host" "size_t hostlen" "char *serv" "size_t servlen" "int flags" "struct asr *asr"
.Sh DESCRIPTION
The
.Nm asr
functions provide a simple interface for asynchronous address
resolution and nameserver querying.
They should be used in place of the classical resolver functions
of libc when blocking is not desirable.
.Pp
The principle of operation is as follows:
All async requests are made against an
.Nm asr
context which basically defines a list of sources to query and a
strategy to do so.
The user creates a query through one of the dedicated functions.
A query is a state-machine that can be run to try to fulfill a
particular request.
This is done by calling in a generic API that performs the state
transitions until it needs to give the control back to the user,
either because a result is available, or because the next transition
implies a blocking call (a file descriptor needs to be read from or
written to).
The user is responsible for dealing with the situation (fetch the result,
or wait until the fd conditions are met), and call back into the resolving
machinery when it is ready to proceed.
.Pp
.Fn asr_resolver
is the function used to create a new resolver context.
The
.Fa conf
argument is a path to the resolver configuration file
as described in
.Xr resolv.conf 5 .
If NULL, the default
.Pa /etc/resolv.conf
file is used.
The context tracks file changes to automatically update its configuration
if needed, replacing the current setup if a valid one can be reloaded from
the file.
If the configuration file cannot be loaded at context creation time, it falls
back to:
.Bd -literal -offset indent
lookup file
.Ed
.Pp
If the first character of the
.Fa conf
string is a '!', the configuration is read from the rest of the string rather
than loaded from a file.
No further update occurs in this case.
.Pp
.Fn asr_resolver_done
is used to discard the
.Fa asr
context when it is not used anymore.
Once called, that context is invalidated and cannot be used to create new
queries.
Internally, the context is refcounted, so that existing queries made against
it will be able to complete safely.
All relevant resources are effectively freed when all such queries are cleared.
.Pp
The
.Fn asr_async_run
function drives the resolving process.
It runs the
.Fa as
asynchronous query until an answer is available, or until it cannot continue
without blocking.
The results are returned to the user through the
.Fa ar
parameter, which must be a valid pointer to user allocated memory.
.Fa ar
is defined as:
.Bd -literal -offset indent
struct async_res {
	int	 ar_cond;
	int	 ar_fd;
	int	 ar_timeout;

	int	 ar_errno;
	int	 ar_h_errno;
	int	 ar_gai_errno;
	int	 ar_rrset_errno;

	int	 ar_count;

	int	 ar_rcode;
	void	*ar_data;
	int	 ar_datalen;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sain;
		struct sockaddr_in6	sain6;
	}	 ar_sa;

	struct addrinfo	 *ar_addrinfo;
	struct rrsetinfo *ar_rrsetinfo;
	struct hostent	 *ar_hostent;
	struct netent	 *ar_netent;
};
.Ed
.Pp
The function returns one of the following values:
.Bl -tag -width "ASYNC_YIELD " -offset indent
.It ASYNC_COND
The query cannot be processed further until a specific condition on a
file descriptor becomes true.
The following members of the
.Fa ar
structure are filled:
.Pp
.Bl -tag -width "ar_timeout " -compact
.It Fa ar_cond
One of ASYNC_READ or ASYNC_WRITE.
.It Fa ar_fd
The file descriptor waiting for an IO operation.
.It Fa ar_timeout
The timeout, expressed in milliseconds.
.El
.Pp
The caller is expected to call
.Fn asr_async_run
again once the condition holds or the timeout expires.
.It ASYNC_DONE
The query is completed.
The members relevant to the actual async query type are set accordingly,
including error conditions.
In any case, the query is cleared and its address is invalidated.
.It ASR_YIELD
A partial result is available.
This code is used for async queries that behave as iterators over the result
set.
The query-specific members of
.Fa ar
are set accordingly and the resolving process can be resumed by calling
.Fn asr_async_run .
.El
.Pp
Note that although the query itself may fail (the error being properly reported
in the
.Fa ar
structure), the
.Fn asr_async_run
function itself cannot fail and it always preserves errno.
.Pp
The
.Fn asr_async_run_sync
function is a wrapper around
.Fn asr_async_run
that handles the read/write conditions, thus falling back to a blocking
interface.
It only returns partial and complete results through ASYNC_YIELD and ASYNC_DONE
respectively.
It also preserves errno.
.Pp
The
.Fn asr_async_abort
function clears a running query.
It can be called after a partial result has been retrieved or when the query
is waiting on a file descriptor.
Note that a completed query is already cleared when
.Fn asr_async_run
returns, so
.Fn asr_async_abort
must not be called in this case.
.Pp
The remaining functions are used to initiate different kinds of query
on the
.Fa asr
resolver context.
The specific operational details for each of them are described below.
All functions return NULL if they could not allocate the necessary resources
to initiate the query.
All other errors (especially invalid parameters)
are reported when calling
.Fn asr_async_run .
They usually have the same interface as an existing resolver function, with
an additional
.Ar asr
contex argument, which specifies the context to use for this request.
If NULL, the default thread-local context is used.
.Pp
The
.Fn res_send_async ,
.Fn res_query_async
and
.Fn res_search_async
functions are asynchronous versions of the standard libc resolver routines.
Their interface is very similar, except that the response buffer is always
allocated internally.
The return value is found upon completion in the
.Fa ar_datalen
member of the response structure.
In addition, the
.Fa ar_sa
union contains the address of the DNS server that sent the response,
.Fa ar_rcode
contains the code returned by the server in the DNS response packet, and
.Fa ar_count
contains the number of answers in the packet.
If a response is received it is placed in a newly allocated buffer
and returned as
.Fa ar_data
member.
This buffer must be freed by the caller.
On error, the
.Fa ar_errno
and
.Fa ar_h_errno
members are set accordingly.
.Pp
The
.Fn getrrsetbyname_async
function is an asynchronous version of
.Xr getrrsetbyname 3 .
Upon completion, the return code is found in
.Fa ar_rrset_errno
and the address to the newly allocated result set is set in
.Fa ar_rrsetinfo .
As for the blocking function, it must be freed by calling
.Xr freerrset 3 .
.Pp
The
.Fn gethostbyname_async ,
.Fn gethostbyname2_async
and
.Fn gethostbyaddr_async
functions provide an asynchronous version of the network host entry functions.
Upon completion,
.Ar ar_h_errno
is set and the resulting hostent address, if found, is set
in the
.Ar ar_hostent
field.
Note that unlike their blocking counterparts, these functions always return a
pointer to newly allocated memory, which must be released by the caller using
.Xr free 3 .
.Pp
Similarly, the
.Fn getnetbyname_async
and
.Fn getnetbyaddr_async
functions provide an asynchronous version of the network entry functions.
Upon completion,
.Ar ar_h_errno
is set and the resulting netent address, if found, is set
in the
.Ar ar_netent
field.
The memory there is also allocated for the request, and it must be freed by
.Xr free 3 .
.Pp
The
.Fn getaddrinfo_async
function is an asynchronous version of the
.Xr getaddrinfo 3
call.
It provides a chain of addrinfo structures with all valid combinations of
socket address for the given
.Fa hostname ,
.Fa servname
and
.Fa hints .
Those three parameters have the same meaning as for the blocking counterpart.
Upon completion the return code is set in
.Fa ar_gai_errno .
The
.Fa ar_errno
member may also be set.
On success, the
.Fa ar_addrinfo
member points to a newly allocated list of addrinfo.
This list must be freed with
.Xr freeaddrinfo 3 .
The
.Fa ar_count
contains the number of elements in the list.
.Sh WORKING WITH THREADS
This implementation of the asynchronous resolver interface is thread-safe
and lock-free internally, but the following restriction applies:
Two different threads must not create queries on the same context or
run queries originating from the same context at the same time.
If they want to do that, all calls must be protected by a mutex around
that context.
.Pp
It is generally not a problem since the main point of the asynchronous
resolver is to multiplex queries within a single thread of control,
so sharing a resolver among threads is not useful.
.Pp
Note that this restriction only applies to resolver contexts explicitly
created by the caller, as a thread-local context is used by default.
.Sh SEE ALSO
.Xr getaddrinfo 3 ,
.Xr gethostbyname 3 ,
.Xr getnameinfo 3 ,
.Xr getnetbyname 3 ,
.Xr getrrsetbyname 3 ,
.Xr res_send 3 ,
.Xr resolv.conf 5
.Sh CAVEATS
This DNS resolver implementation doesn't support
the EDNS0 protocol extension yet.
@


1.14
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.13 2013/06/05 03:39:22 tedu Exp $
d17 1
a17 1
.Dd $Mdocdate: June 5 2013 $
@


1.13
log
@Use the fancy .In macro for includes. From Jan Klemkow. ok jmc schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.12 2013/04/30 13:05:44 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: April 30 2013 $
d21 5
a25 5
.Nm async_resolver ,
.Nm async_resolver_done ,
.Nm async_run ,
.Nm async_run_sync ,
.Nm async_abort ,
d42 1
a42 1
.Fn async_resolver "const char *conf"
d44 1
a44 1
.Fn async_resolver_done "struct asr *asr"
d46 1
a46 1
.Fn async_run "struct async *as" "struct async_res *ar"
d48 1
a48 1
.Fn async_run_sync "struct async *as" "struct async_res *ar"
d50 1
a50 1
.Fn async_abort "struct async *as"
d98 1
a98 1
.Fn async_resolver
d123 1
a123 1
.Fn async_resolver_done
d134 1
a134 1
.Fn async_run
d193 1
a193 1
.Fn async_run
d207 1
a207 1
.Fn async_run .
d214 1
a214 1
.Fn async_run
d218 1
a218 1
.Fn async_run_sync
d220 1
a220 1
.Fn async_run
d228 1
a228 1
.Fn async_abort
d233 1
a233 1
.Fn async_run
d235 1
a235 1
.Fn async_abort
d247 1
a247 1
.Fn async_run .
@


1.12
log
@various small fixes;
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.11 2013/04/30 12:02:39 eric Exp $
d40 1
a40 1
.Fd #include <asr.h>
@


1.11
log
@Do not take external buffers for storing DNS responses in the internal
async API.  That is actually useless and it makes the code more
complicated.  The required buffers are always allocated when needed.
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.10 2013/04/01 15:49:54 deraadt Exp $
d17 1
a17 1
.Dd $Mdocdate: April 1 2013 $
d248 1
a248 1
They usually have the same interface as an exisiting resolver function, with
d261 2
a262 1
allocated internally.  The return value is found upon completion in the
d272 1
a272 1
If a response is received it placed in a newly allocated buffer
@


1.10
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.9 2013/03/30 20:00:08 eric Exp $
d17 1
a17 1
.Dd $Mdocdate: March 30 2013 $
d52 1
a52 1
.Fn res_send_async "const unsigned char *pkt" "int pktlen" "unsigned char *ans" "int anslen" "struct asr *asr"
d54 3
a56 1
.Fn res_query_async "const char *name" "int class" "int type" "unsigned char *ans" "int anslen" "struct asr *asr"
d260 2
a261 2
Their interface is very similar, except that they take a resolver context as
last argument, and the return value is found upon completion in the
d271 2
a272 2
If no answer buffer is provided, a new one is allocated to fit the response
and returned as the
@


1.9
log
@Do not assume local nameserver if resolv.conf doesn't exist, just use
/etc/hosts.

discussed with deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.8 2013/03/27 16:21:22 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: March 27 2013 $
d41 1
a41 1
.Ft struct asr*
d51 1
a51 1
.Ft struct async*
d53 1
a53 1
.Ft struct async*
d55 1
a55 1
.Ft struct async*
d57 1
a57 1
.Ft struct async*
d59 1
a59 1
.Ft struct async*
d61 1
a61 1
.Ft struct async*
d63 1
a63 1
.Ft struct async*
d65 1
a65 1
.Ft struct async*
d67 1
a67 1
.Ft struct async*
d69 1
a69 1
.Ft struct async*
@


1.8
log
@explicitely -> explicitly;
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.7 2013/03/27 07:40:41 eric Exp $
d109 2
a110 2
If a configuration file cannot be loaded at context creation time, it falls
back to the equivalent of:
d112 1
a112 2
lookup bind file
nameserver 127.0.0.1
@


1.7
log
@Only use the search domains for DNS lookups, as the current resolver does.
Better not diverge too much in behavior at this point.
Typo fix and doc update while there.
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.6 2012/09/06 08:38:15 eric Exp $
d17 1
a17 1
.Dd $Mdocdate: September 6 2012 $
d359 1
a359 1
Note that this restriction only applies to resolver contexts explicitely
@


1.6
log
@YP is now supported.
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.5 2012/09/06 08:36:52 eric Exp $
d130 1
a130 2
All relevant resources are effectively
freed when all such queries are cleared.
d347 14
@


1.5
log
@remove unused member, reorganize a bit and sync manpage.
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.4 2012/08/19 16:17:40 eric Exp $
d17 1
a17 1
.Dd $Mdocdate: August 19 2012 $
a358 2
.Pp
The current implementation does not handle YP databases.
@


1.4
log
@When building dynamic hostent and netent, allocate a single linear buffer to
hold both the structure and the data. The freehostent() and freenetent() API
functions are not needed anymore.  While there, ensure that the constructed
addr and alias lists are really NULL terminated.
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.3 2012/08/18 16:48:17 eric Exp $
d17 1
a17 1
.Dd $Mdocdate: August 18 2012 $
d147 3
a149 3
	int			 ar_cond;
	int			 ar_fd;
	int			 ar_timeout;
d151 4
a154 4
	int			 ar_errno;
	int			 ar_h_errno;
	int			 ar_gai_errno;
	int			 ar_rrset_errno;
d156 5
a160 3
	int			 ar_rcode;
	void			*ar_data;
	int			 ar_datalen;
d165 1
a165 4
	}			 ar_sa;

	char			*ar_cname;
	int			 ar_count;
d167 4
a170 4
	struct addrinfo		*ar_addrinfo;
	struct rrsetinfo	*ar_rrsetinfo;
	struct hostent		*ar_hostent;
	struct netent		*ar_netent;
@


1.3
log
@ensure that async_run() and async_run_sync() always preserve errno.
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.2 2012/04/15 15:08:12 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: April 15 2012 $
a32 1
.Nm freehostent ,
d63 1
a63 2
.Ft void
.Fn freehostent "struct hostent *h"
a66 2
.Ft void
.Fn freenetent "struct netent *n"
d307 2
a308 4
pointer to newly allocated memory.
Therefore, the pointer must be freed through the new
.Fn freehostent
call.
d322 1
a322 1
.Fn freenetent .
@


1.2
log
@tweak previous;
@
text
@d1 1
a1 1
.\"	$OpenBSD: async_resolver.3,v 1.1 2012/04/14 09:24:18 eric Exp $
d17 1
a17 1
.Dd $Mdocdate: April 14 2012 $
d215 7
d230 1
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: smtpd.8,v 1.11 2009/10/22 15:02:12 sobrado Exp $
d17 1
a17 1
.Dd $Mdocdate: April 13 2012 $
d113 1
a113 1
If configuration file cannot be loaded at context creation time, it falls
d246 1
a246 1
an additionnal
d252 2
a253 1
.Fn res_send_async , res_query_async
d265 1
a265 1
contains the code returned by the server in the DNS responce packet, and
d267 1
a267 1
contains the number of answer in the packet.
d271 2
a272 1
member. This buffer must be freed by the caller.
d288 1
a288 1
.Fn freerrset 3 .
d292 1
a292 1
.Fn gethostbyname2_async 
a346 1
.Pp
d348 1
a348 2
.Xr res_send 3 ,
.Xr getrrsetbyname 3 ,
d350 1
d352 2
a353 2
.Xr getaddrinfo 3 ,
.Xr getnameinfo 3 ,
d355 1
a355 1
.Sh LIMITATIONS
@

