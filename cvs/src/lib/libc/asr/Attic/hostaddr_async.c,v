head	1.5;
access;
symbols
	OPENBSD_5_2:1.1.0.2
	OPENBSD_5_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.09.05.21.49.12;	author eric;	state dead;
branches;
next	1.4;

1.4
date	2012.09.05.16.52.05;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.09.05.15.56.13;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.18.13.31.03;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Get rid of the hostaddr_async subquery and merge its behaviour
directly into getaddrinfo_async_run.  Simplifies everything by
a great deal.
@
text
@/*	$OpenBSD: hostaddr_async.c,v 1.4 2012/09/05 16:52:05 eric Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/uio.h>

#include <arpa/nameser.h>
        
#include <err.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "asr.h"
#include "asr_private.h"

static int hostaddr_async_run(struct async *, struct async_res *);
static int addrinfo_add(struct async *, int, const void *, size_t, const char *);
static int addrinfo_from_file(struct async *, int,  FILE *);
static int addrinfo_from_pkt(struct async *, char *, size_t);
#ifdef YP
static int addrinfo_from_yp(struct async *, int, char *);
#endif

/*
 * This API function allows to iterate over host addresses, for the given
 * family which, must be AF_INET, AF_INET6, or AF_UNSPEC (in which case
 * the family lookup list from the resolver is used). The strategy is to
 * return all addresses found for the first DB that returned at least one
 * address.
 *
 * Flags can be 0, or one of AI_CANONNAME or AI_FQDN. If set, the
 * canonical name will be returned along with the address.
 */
struct async *
hostaddr_async_ctx(const char *name, int family, int flags, struct asr_ctx *ac)
{
	struct async	*as;
	char		 buf[MAXDNAME];

#ifdef DEBUG
	asr_printf("asr: hostaddr_async_ctx(\"%s\", %i)\n", name, family);
#endif
	if (asr_domcat(name, NULL, buf, sizeof buf) == 0) {
		errno = EINVAL;
		return (NULL);
	}

	if ((as = async_new(ac, ASR_HOSTADDR)) == NULL)
		goto err; /* errno set */
	as->as_run = hostaddr_async_run;

	as->as.ai.hints.ai_flags = flags;
	as->as.ai.hints.ai_family = family;
	as->as.ai.hostname = strdup(buf);
	if (as->as.ai.hostname == NULL)
		goto err; /* errno set */

	return (as);
    err:
	if (as)
		async_free(as);
	return (NULL);
}

static int
hostaddr_async_run(struct async *as, struct async_res *ar)
{
#ifdef YP
	static char	*domain = NULL;
	char		*res;
	int		 len;
#endif
	char		*name;
	int		 family, type, r;
	FILE		*file;

    next:
	switch(as->as_state) {

	case ASR_STATE_INIT:

		if (as->as.ai.hints.ai_family != AF_INET &&
		    as->as.ai.hints.ai_family != AF_INET6 &&
		    as->as.ai.hints.ai_family != AF_UNSPEC) {
			ar->ar_gai_errno = EAI_FAMILY;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		as->as_count = 0;
		as->as_db_idx = 0;
		async_set_state(as, ASR_STATE_NEXT_DB);
		break;

	case ASR_STATE_NEXT_FAMILY:

		as->as_family_idx += 1;
		if (as->as.ai.hints.ai_family != AF_UNSPEC ||
		    AS_FAMILY(as) == -1) {
			/* The family was specified, or we have tried all
			 * families with this DB.
			 */
			if (as->as_count) {
				ar->ar_gai_errno = 0;
				async_set_state(as, ASR_STATE_HALT);
			} else
				async_set_state(as, ASR_STATE_NEXT_DB);
			break;
		}

		async_set_state(as, ASR_STATE_LOOKUP_FAMILY);
		break;

	case ASR_STATE_LOOKUP_FAMILY:
		async_set_state(as, ASR_STATE_SAME_DB);
		break;

	case ASR_STATE_NEXT_DB:
		if (asr_iter_db(as) == -1) {
			async_set_state(as, ASR_STATE_NOT_FOUND);
			break;
		}
		as->as_family_idx = 0;
		/* FALLTHROUGH */

	case ASR_STATE_SAME_DB:
		/* query the current DB again. */
		switch(AS_DB(as)) {
		case ASR_DB_DNS:
			family = (as->as.ai.hints.ai_family == AF_UNSPEC) ?
			    AS_FAMILY(as) : as->as.ai.hints.ai_family;
			type = (family == AF_INET6) ? T_AAAA : T_A;
			name = as->as.ai.hostname;
			as->as.ai.subq = res_query_async_ctx(name, C_IN,
			    type, NULL, 0, as->as_ctx);
			if (as->as.ai.subq == NULL) {
				if (errno == ENOMEM)
					ar->ar_gai_errno = EAI_MEMORY;
				else
					ar->ar_gai_errno = EAI_FAIL;
				async_set_state(as, ASR_STATE_HALT);
				break;
			}
			async_set_state(as, ASR_STATE_SUBQUERY);
			break;

		case ASR_DB_FILE:
			file = fopen(as->as_ctx->ac_hostfile, "r");
			if (file == NULL) {
				async_set_state(as, ASR_STATE_NEXT_DB);
				break;
			}
			family = (as->as.ai.hints.ai_family == AF_UNSPEC) ?
			    AS_FAMILY(as) : as->as.ai.hints.ai_family;

			r = addrinfo_from_file(as, family, file);
			if (r == -1) {
				if (errno == ENOMEM)
					ar->ar_gai_errno = EAI_MEMORY;
				else
					ar->ar_gai_errno = EAI_FAIL;
				async_set_state(as, ASR_STATE_HALT);
			} else
				async_set_state(as, ASR_STATE_NEXT_FAMILY);
			fclose(file);
			break;

#ifdef YP
		case ASR_DB_YP:
			if (!domain && _yp_check(&domain) == 0) {
				async_set_state(as, ASR_STATE_NEXT_DB);
				break;
			}
			family = (as->as.ai.hints.ai_family == AF_UNSPEC) ?
			    AS_FAMILY(as) : as->as.ai.hints.ai_family;
			/* XXX
			 * ipnodes.byname could also contain IPv4 address
			 */
			name = (family == AF_INET6) ?
			    "ipnodes.byname" : "hosts.byname";
			r = yp_match(domain, name, as->as.ai.hostname,
				strlen(as->as.ai.hostname), &res, &len);
			if (r == 0) {
				r = addrinfo_from_yp(as, family, res);
				free(res);
				if (r == -1) {
					if (errno == ENOMEM)
						ar->ar_gai_errno = EAI_MEMORY;
					else
						ar->ar_gai_errno = EAI_FAIL;
					async_set_state(as, ASR_STATE_HALT);
					break;
				}
			}
			async_set_state(as, ASR_STATE_NEXT_FAMILY);
			break;
#endif

		default:
			async_set_state(as, ASR_STATE_NEXT_DB);
		}
		break;

	case ASR_STATE_SUBQUERY:
		if ((r = async_run(as->as.ai.subq, ar)) == ASYNC_COND)
			return (ASYNC_COND);
		as->as.ai.subq = NULL;

		if (ar->ar_datalen == -1) {
			async_set_state(as, ASR_STATE_NEXT_DB);
			break;
		}

		r = addrinfo_from_pkt(as, ar->ar_data, ar->ar_datalen);
		if (r == -1) {
			if (errno == ENOMEM)
				ar->ar_gai_errno = EAI_MEMORY;
			else
				ar->ar_gai_errno = EAI_FAIL;
			async_set_state(as, ASR_STATE_HALT);
		} else
			async_set_state(as, ASR_STATE_NEXT_FAMILY);
		free(ar->ar_data);
		break;

	case ASR_STATE_NOT_FOUND:
		/* XXX the exact error depends on what query/send returned */
		ar->ar_gai_errno = EAI_NODATA;
		async_set_state(as, ASR_STATE_HALT);
		break;

	case ASR_STATE_HALT:
		if (ar->ar_gai_errno == 0) {
			ar->ar_count = as->as_count;
			ar->ar_addrinfo = as->as.ai.aifirst;
			as->as.ai.aifirst = NULL;
		} else {
			ar->ar_count = 0;
			ar->ar_addrinfo = NULL;
		}
		return (ASYNC_DONE);

	default:
		ar->ar_errno = EOPNOTSUPP;
		ar->ar_gai_errno = EAI_SYSTEM;
		async_set_state(as, ASR_STATE_HALT);
		break;
	}
	goto next;
}

static int
addrinfo_add(struct async *as, int family, const void *addr, size_t addrlen,
    const char *name)
{
	struct addrinfo	*ai;

	if ((ai = calloc(1, sizeof (*ai) + addrlen)) == NULL)
		return (-1);

	ai->ai_family = family;
	ai->ai_addrlen = addrlen;
	ai->ai_addr = (void*)(ai + 1);
	if (name && (ai->ai_canonname = strdup(name)) == NULL) {
		free(ai);
		return (-1);
	}
	memmove(ai->ai_addr, addr, addrlen);

	if (!as->as.ai.aifirst)
		as->as.ai.aifirst = ai;
	if (as->as.ai.ailast)
		as->as.ai.ailast->ai_next = ai;
	as->as.ai.ailast = ai;
	as->as_count += 1;

	return (0);
}

static int
addrinfo_from_file(struct async *as, int family, FILE *f)
{
	char		*tokens[MAXTOKEN], *c;
	int		 n, i;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sain;
		struct sockaddr_in6	sain6;
	} u;

	for(;;) {
		n = asr_parse_namedb_line(f, tokens, MAXTOKEN);
		if (n == -1)
			break; /* ignore errors reading the file */

		for (i = 1; i < n; i++) {
			if (strcasecmp(as->as.ai.hostname, tokens[i]))
				continue;
			if (sockaddr_from_str(&u.sa, family, tokens[0]) == -1)
				continue;
			break;
		}
		if (i == n)
			continue;

		if (as->as.ai.hints.ai_flags & AI_CANONNAME)
			c = tokens[1];
		else if (as->as.ai.hints.ai_flags & AI_FQDN)
			c = as->as.ai.hostname;
		else
			c = NULL;

		if (addrinfo_add(as, u.sa.sa_family, &u.sa, u.sa.sa_len, c))
			return (-1); /* errno set */
	}
	return (0);
}

static int
addrinfo_from_pkt(struct async *as, char *pkt, size_t pktlen)
{
	struct packed	 p;
	struct header	 h;
	struct query	 q;
	struct rr	 rr;
	int		 i;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sain;
		struct sockaddr_in6	sain6;
	} u;
	char		 buf[MAXDNAME], *c;

	packed_init(&p, pkt, pktlen);
	unpack_header(&p, &h);
	for(; h.qdcount; h.qdcount--)
		unpack_query(&p, &q);

	for (i = 0; i < h.ancount; i++) {
		unpack_rr(&p, &rr);
		if (rr.rr_type != q.q_type ||
		    rr.rr_class != q.q_class)
			continue;

		memset(&u, 0, sizeof u);
		if (rr.rr_type == T_A) {
			u.sain.sin_len = sizeof u.sain;
			u.sain.sin_family = AF_INET;
			u.sain.sin_addr = rr.rr.in_a.addr;
			u.sain.sin_port = 0;
		} else if (rr.rr_type == T_AAAA) {
			u.sain6.sin6_len = sizeof u.sain6;
			u.sain6.sin6_family = AF_INET6;
 			u.sain6.sin6_addr = rr.rr.in_aaaa.addr6;
			u.sain6.sin6_port = 0;
		} else
			continue;

		if (as->as.ai.hints.ai_flags & AI_CANONNAME) {
			asr_strdname(rr.rr_dname, buf, sizeof buf);
			buf[strlen(buf) - 1] = '\0';
			c = buf;
		} else if (as->as.ai.hints.ai_flags & AI_FQDN)
			c = as->as.ai.hostname;
		else
			c = NULL;

		if (addrinfo_add(as, u.sa.sa_family, &u.sa, u.sa.sa_len, c))
			return (-1); /* errno set */
	}
	return (0);
}

#ifdef YP
static int
strsplit(char *line, char **tokens, int ntokens)
{
	int	ntok;
	char	*cp, **tp;

	for(cp = line, tp = tokens, ntok = 0;
	    ntok < ntokens && (*tp = strsep(&cp, " \t")) != NULL; )
		if (**tp != '\0') {
			tp++;
			ntok++;
		}

	return (ntok);
}

static int
addrinfo_from_yp(struct async *as, int family, char *line)
{
	char		*next, *tokens[MAXTOKEN], *c;
	int		 i, ntok;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sain;
		struct sockaddr_in6	sain6;
	} u;

	for(next = line; line; line = next) {
		if ((next = strchr(line, '\n'))) {
			*next = '\0';
			next += 1;
		}
		ntok = strsplit(line, tokens, MAXTOKEN);
		if (ntok < 2)
			continue;

		if (sockaddr_from_str(&u.sa, family, tokens[0]) == -1)
			continue;

		if (as->as.ai.hints.ai_flags & AI_CANONNAME)
			c = tokens[1];
		else if (as->as.ai.hints.ai_flags & AI_FQDN)
			c = as->as.ai.hostname;
		else
			c = NULL;

		if (addrinfo_add(as, u.sa.sa_family, &u.sa, u.sa.sa_len, c))
			return (-1); /* errno set */
	}
	return (0);
}
#endif
@


1.4
log
@Implement basic (blocking) YP support for getaddrinfo_async().
YP is now supported on all relevant resolver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostaddr_async.c,v 1.3 2012/09/05 15:56:13 eric Exp $	*/
@


1.3
log
@Make hostaddr_async() return a linked list of struct addrinfo.  First
round of a getaddrinfo_async() simplification. The goal is to make YP
support easier to add, and eventually remove the whole hostaddr_async
subquery.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostaddr_async.c,v 1.2 2012/08/18 13:31:03 eric Exp $	*/
d36 3
d84 7
a90 2
	char		 *name;
	int		 n, family, type, r;
d172 2
a173 2
			n = addrinfo_from_file(as, family, file);
			if (n == -1) {
d184 31
d389 54
@


1.2
log
@Simplify error reporting in hostaddr_async(). Only use EAI_* error codes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hostaddr_async.c,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
d33 3
a35 1
static int sockaddr_from_rr(struct sockaddr *, struct rr *);
d65 4
a68 4
	as->as.host.aiflags = flags;
	as->as.host.family = family;
	as->as.host.name = strdup(buf);
	if (as->as.host.name == NULL)
d81 3
a83 6
	struct packed	 p;
	struct header	 h;
	struct query	 q;
	struct rr	 rr;
	char		 buf[MAXDNAME], *c, *name;
	int		 i, n, family, type, r;
d90 3
a92 3
		if (as->as.host.family != AF_INET &&
		    as->as.host.family != AF_INET6 &&
		    as->as.host.family != AF_UNSPEC) {
d106 2
a107 1
		if (as->as.host.family != AF_UNSPEC || AS_FAMILY(as) == -1) {
a122 1

a126 1

d135 1
a135 3

		/* Query the current DB again. */

d138 2
a139 3

			family = (as->as.host.family == AF_UNSPEC) ?
			    AS_FAMILY(as) : as->as.host.family;
d141 2
a142 2
			name = as->as.host.name;
			as->as.host.subq = res_query_async_ctx(name, C_IN,
d144 1
a144 1
			if (as->as.host.subq == NULL) {
d156 7
d164 10
a173 5
			as->as.host.file = fopen(as->as_ctx->ac_hostfile, "r");
			if (as->as.host.file == NULL)
				async_set_state(as, ASR_STATE_NEXT_DB);
			else
				async_set_state(as, ASR_STATE_READ_FILE);
d182 1
a182 1
		if ((r = async_run(as->as.host.subq, ar)) == ASYNC_COND)
d184 1
a184 1
		as->as.host.subq = NULL;
d191 8
a198 19
		as->as.host.pkt = ar->ar_data;
		as->as.host.pktlen = ar->ar_datalen;
		packed_init(&p, as->as.host.pkt, as->as.host.pktlen);
		unpack_header(&p, &h);
		for(; h.qdcount; h.qdcount--)
			unpack_query(&p, &q);
		as->as.host.pktpos = p.offset;
		as->as.host.ancount = h.ancount;
		as->as.host.class = q.q_class;
		as->as.host.type = q.q_type;
		async_set_state(as, ASR_STATE_READ_RR);
		break;

	case ASR_STATE_READ_RR:

		/* When done with this NS, try with next family */
		if (as->as.host.ancount == 0) {
			free(as->as.host.pkt);
			as->as.host.pkt = NULL;
d200 1
a200 76
			break;
		}

		/* Continue reading the packet where we left it. */
		packed_init(&p, as->as.host.pkt, as->as.host.pktlen);
		p.offset = as->as.host.pktpos;
		unpack_rr(&p, &rr);
		as->as.host.pktpos = p.offset;
		as->as.host.ancount -= 1;
		if (rr.rr_type == as->as.host.type &&
		    rr.rr_class == as->as.host.class) {
			as->as_count += 1;
			ar->ar_count = as->as_count;
			sockaddr_from_rr(&ar->ar_sa.sa, &rr);
			if (as->as.host.aiflags & AI_CANONNAME)
				c = asr_strdname(rr.rr_dname, buf,
				    sizeof buf);
			else if (as->as.host.aiflags & AI_FQDN) {
				strlcpy(buf, as->as.host.name, sizeof buf);
				c = buf;
			} else
				c = NULL;
			if (c) {
				if (c[strlen(c) - 1] == '.')
					c[strlen(c) - 1] = '\0';
				ar->ar_cname = strdup(c);
			} else
				ar->ar_cname = NULL;
			return (ASYNC_YIELD);
		}
		break;

	case ASR_STATE_READ_FILE:

		/* When done with the file, try next family. */
		n = asr_parse_namedb_line(as->as.host.file, as->as.host.tokens,
		    MAXTOKEN);
		if (n == -1) {
			fclose(as->as.host.file);
			as->as.host.file = NULL;
			async_set_state(as, ASR_STATE_NEXT_FAMILY);
			break;
		}

		for (i = 1; i < n; i++) {
			if (strcasecmp(as->as.host.name,
			    as->as.host.tokens[i]))
				continue;

			family = as->as.host.family;
			if (family == AF_UNSPEC)
				family = AS_FAMILY(as);

			if (sockaddr_from_str(&ar->ar_sa.sa, family,
			    as->as.host.tokens[0]) == -1)
				continue;

			if (as->as.host.aiflags & AI_CANONNAME) {
				strlcpy(buf, as->as.host.tokens[1],
				    sizeof buf);
				c = buf;
			} else if (as->as.host.aiflags & AI_FQDN) {
				strlcpy(buf, as->as.host.name, sizeof buf);
				c = buf;
			} else
				c = NULL;
			if (c) {
				if (c[strlen(c) - 1] == '.')
					c[strlen(c) - 1] = '\0';
				ar->ar_cname = strdup(c);
			} else
				ar->ar_cname = NULL;
			as->as_count += 1;
			ar->ar_count = as->as_count;
			return (ASYNC_YIELD);
		}
d208 1
a208 1
	
d210 8
a217 1
		ar->ar_count = ar->ar_gai_errno ? 0 : as->as_count;
d230 2
a231 1
sockaddr_from_rr(struct sockaddr *sa, struct rr *rr)
d233 1
a233 2
	struct sockaddr_in	*sin;
	struct sockaddr_in6	*sin6;
d235 1
a235 1
	if (rr->rr_class != C_IN)
d238 51
a288 17
	switch (rr->rr_type) {
	case T_A:
		sin = (struct sockaddr_in*)sa;
		memset(sin, 0, sizeof *sin);
		sin->sin_len = sizeof *sin;
		sin->sin_family = PF_INET;
		sin->sin_addr = rr->rr.in_a.addr;
		sin->sin_port = 0;
		return (0);
	case T_AAAA:
		sin6 = (struct sockaddr_in6*)sa;
		memset(sin6, 0, sizeof *sin6);
		sin6->sin6_len = sizeof *sin6;
		sin6->sin6_family = PF_INET6;
		sin6->sin6_addr = rr->rr.in_aaaa.addr6;
		sin6->sin6_port = 0;
		return (0);
d290 2
a291 2
	default:
		break;
d293 2
d296 53
a348 1
	return (-1);
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.10 2011/07/13 16:14:43 eric Exp $	*/
a111 1
				ar->ar_errno = 0;
a149 2
				ar->ar_errno = errno;
				ar->ar_h_errno = NETDB_INTERNAL;
a283 1
		ar->ar_errno = 0;
d289 1
a289 6

		ar->ar_count = as->as_count;
		if (ar->ar_count) {
			ar->ar_errno = 0;
			ar->ar_gai_errno = 0;
		}
@

