head	1.9;
access;
symbols
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.1.0.2
	OPENBSD_5_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.03.26.18.13.15;	author eric;	state dead;
branches;
next	1.8;

1.8
date	2014.03.25.19.48.11;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2013.07.12.14.36.21;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2013.04.30.12.02.39;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.01.15.49.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.09.06.08.36.52;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.19.16.17.40;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@/*	$OpenBSD: asr.h,v 1.8 2014/03/25 19:48:11 eric Exp $	*/
/*
 * Copyright (c) 2012-2014 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

/*
 * Expected fd conditions
 */
#define ASR_WANT_READ	1
#define ASR_WANT_WRITE	2

/*
 * Structure through which asynchronous query results are returned when
 * calling asr_run().
 */
struct asr_result {
	/* Fields set if the query is not done yet (asr_run returns 0) */
	int	 ar_cond;	/* ASR_WANT_READ or ASR_WANT_WRITE */
	int	 ar_fd;		/* the fd waiting for io condition */
	int	 ar_timeout;	/* time to wait for in milliseconds */

	/* Error fields.  Depends on the query type. */
	int	 ar_errno;
	int	 ar_h_errno;
	int	 ar_gai_errno;
	int	 ar_rrset_errno;

	/* Result for res_*_async() calls */
	int	 ar_count;	/* number of answers in the dns reply */
	int	 ar_rcode;	/* response code in the dns reply */
	void	*ar_data;	/* raw reply packet (must be freed) */
	int	 ar_datalen;	/* reply packet length */
	struct sockaddr_storage ar_ns; /* nameserver that responded */

	/* Result for other calls. Must be freed properly. */
	struct addrinfo	 *ar_addrinfo;
	struct rrsetinfo *ar_rrsetinfo;
	struct hostent	 *ar_hostent;
	struct netent	 *ar_netent;
};

/*
 * Asynchronous query management.
 */

/* Forward declaration. The API uses opaque pointers as query handles. */
struct asr_query;

int asr_run(struct asr_query *, struct asr_result *);
int asr_run_sync(struct asr_query *, struct asr_result *);
void asr_abort(struct asr_query *);

/*
 * Asynchronous version of the resolver functions. Similar prototypes, with
 * an extra context parameter at the end which must currently be set to NULL.
 * All functions return a handle suitable for use with the management functions
 * above.
 */
struct asr_query *res_send_async(const unsigned char *, int, void *);
struct asr_query *res_query_async(const char *, int, int, void *);
struct asr_query *res_search_async(const char *, int, int, void *);

struct asr_query *getrrsetbyname_async(const char *, unsigned int, unsigned int,
    unsigned int, void *);

struct asr_query *gethostbyname_async(const char *, void *);
struct asr_query *gethostbyname2_async(const char *, int, void *);
struct asr_query *gethostbyaddr_async(const void *, socklen_t, int, void *);

struct asr_query *getnetbyname_async(const char *, void *);
struct asr_query *getnetbyaddr_async(in_addr_t, int, void *);

struct asr_query *getaddrinfo_async(const char *, const char *,
    const struct addrinfo *, void *);
struct asr_query *getnameinfo_async(const struct sockaddr *, socklen_t, char *,
    size_t, char *, size_t, int, void *);
@


1.8
log
@Cleanup and simplify the API to be exposed.  Use better names for
structures, functions and defines.

discussed with and ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.7 2013/07/12 14:36:21 eric Exp $	*/
@


1.7
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.6 2013/04/30 12:02:39 eric Exp $	*/
d3 1
a3 1
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
a20 1
#include <netinet/in.h>
d23 1
a23 2
 * This part is the generic API for the async mechanism.  It could be useful
 * beyond the resolver.
d25 2
a26 12

/* Return values for async_run() */
#define ASYNC_COND	0 /* wait for fd condition */
#define ASYNC_YIELD	1 /* partial result */
#define ASYNC_DONE	2 /* done */

/* Expected fd conditions  */
#define ASYNC_READ	1
#define ASYNC_WRITE	2

/* This opaque structure holds an async query state. */
struct async;
d29 2
a30 2
 * This is the structure through which async_run() returns async
 * results to the caller.
d32 5
a36 4
struct async_res {
	int	 ar_cond;
	int	 ar_fd;
	int	 ar_timeout;
d38 1
d44 6
a49 10
	int	 ar_count;

	int	 ar_rcode;
	void	*ar_data;
	int	 ar_datalen;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sain;
		struct sockaddr_in6	sain6;
	}	 ar_sa;
d51 1
d58 3
a60 3
int  asr_async_run(struct async *, struct async_res *);
int  asr_async_run_sync(struct async *, struct async_res *);
void asr_async_abort(struct async *);
d62 2
a63 2
/* This opaque structure holds an async resolver context. */
struct asr;
d65 3
a67 2
struct asr *asr_resolver(const char *);
void	    asr_resolver_done(struct asr *);
d69 24
a92 20
/* Async version of the resolver API */

struct async *res_send_async(const unsigned char *, int, struct asr *);
struct async *res_query_async(const char *, int, int, struct asr *);
struct async *res_search_async(const char *, int, int, struct asr *);

struct async *getrrsetbyname_async(const char *, unsigned int, unsigned int,
    unsigned int, struct asr *);

struct async *gethostbyname_async(const char *, struct asr *);
struct async *gethostbyname2_async(const char *, int, struct asr *);
struct async *gethostbyaddr_async(const void *, socklen_t, int, struct asr *);

struct async *getnetbyname_async(const char *, struct asr *);
struct async *getnetbyaddr_async(in_addr_t, int, struct asr *);

struct async *getaddrinfo_async(const char *, const char *,
    const struct addrinfo *, struct asr *);
struct async *getnameinfo_async(const struct sockaddr *, socklen_t, char *,
    size_t, char *, size_t, int, struct asr *);
@


1.6
log
@Do not take external buffers for storing DNS responses in the internal
async API.  That is actually useless and it makes the code more
complicated.  The required buffers are always allocated when needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.5 2013/04/01 15:49:54 deraadt Exp $	*/
d71 3
a73 3
int  async_run(struct async *, struct async_res *);
int  async_run_sync(struct async *, struct async_res *);
void async_abort(struct async *);
d78 2
a79 2
struct asr *async_resolver(const char *);
void	    async_resolver_done(struct asr *);
@


1.5
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.4 2012/11/24 15:12:48 eric Exp $	*/
d83 3
a85 6
struct async *res_send_async(const unsigned char *, int, unsigned char *, int,
    struct asr *);
struct async *res_query_async(const char *, int, int, unsigned char *, int,
    struct asr *);
struct async *res_search_async(const char *, int, int, unsigned char *, int,
    struct asr *);
@


1.4
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.3 2012/09/06 08:36:52 eric Exp $	*/
d78 2
a79 2
struct asr *async_resolver(const char*);
void	    async_resolver_done(struct asr*);
@


1.3
log
@remove unused member, reorganize a bit and sync manpage.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.2 2012/08/19 16:17:40 eric Exp $	*/
a19 1

@


1.2
log
@When building dynamic hostent and netent, allocate a single linear buffer to
hold both the structure and the data. The freehostent() and freenetent() API
functions are not needed anymore.  While there, ensure that the constructed
addr and alias lists are really NULL terminated.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
d55 2
a64 2
	char	*ar_cname;
	int	 ar_count;
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.h,v 1.5 2011/07/13 14:52:21 eric Exp $	*/
a96 1
void freehostent(struct hostent *);
a99 1
void freenetent(struct netent *);
@

