head	1.54;
access;
symbols
	OPENBSD_6_1:1.54.0.4
	OPENBSD_6_1_BASE:1.54
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.23.0.2
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.10.0.2
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4;
locks; strict;
comment	@ * @;


1.54
date	2017.02.27.10.44.46;	author jca;	state Exp;
branches;
next	1.53;
commitid	MlNq0zVlbx0f2ABQ;

1.53
date	2017.02.23.17.04.02;	author eric;	state Exp;
branches;
next	1.52;
commitid	A5SxxxFpG2Lk4uBi;

1.52
date	2017.02.21.22.32.28;	author eric;	state Exp;
branches;
next	1.51;
commitid	abM8yTeGRIos5TNQ;

1.51
date	2017.02.21.07.28.28;	author eric;	state Exp;
branches;
next	1.50;
commitid	uzsXYvahIDGpJamT;

1.50
date	2015.12.16.16.32.30;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	oPoFLo6QaSW21nLc;

1.49
date	2015.11.23.18.04.54;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	OVI7ORhlpJiMawqs;

1.48
date	2015.10.08.14.08.44;	author eric;	state Exp;
branches;
next	1.47;
commitid	9NELMbB2ZcRpx6EZ;

1.47
date	2015.10.08.13.55.56;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	63NwcbISHUTlp1PS;

1.46
date	2015.10.07.13.59.34;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	y9bDEcHtAU9tyNfU;

1.45
date	2015.09.20.14.19.21;	author eric;	state Exp;
branches;
next	1.44;
commitid	QoXCnUzVxYUpwKcZ;

1.44
date	2015.09.20.12.18.47;	author eric;	state Exp;
branches;
next	1.43;
commitid	8l1LJ1QQIsJq5P8q;

1.43
date	2015.09.14.11.52.49;	author guenther;	state Exp;
branches;
next	1.42;
commitid	KzuByhRo5iAIKcqw;

1.42
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	ZDWhDXAAMFWxMzBj;

1.41
date	2015.08.16.20.37.25;	author jca;	state Exp;
branches;
next	1.40;
commitid	TmVjrZT3wvueyXmy;

1.40
date	2015.05.29.08.49.37;	author eric;	state Exp;
branches;
next	1.39;
commitid	Tf6Q1D724C96QEJe;

1.39
date	2015.05.26.19.28.57;	author eric;	state Exp;
branches;
next	1.38;
commitid	zZUSsmIZVurlTa45;

1.38
date	2015.05.25.21.59.37;	author jca;	state Exp;
branches;
next	1.37;
commitid	MxuLnwEjORcrHpgO;

1.37
date	2015.05.25.19.30.25;	author eric;	state Exp;
branches;
next	1.36;
commitid	mgohVjAkJ8FHohVc;

1.36
date	2015.05.05.17.08.44;	author jca;	state Exp;
branches;
next	1.35;
commitid	J1OjfSgLjrQYC0PB;

1.35
date	2015.05.05.16.59.08;	author jca;	state Exp;
branches;
next	1.34;
commitid	Ej3pv5a1fDwUOOGc;

1.34
date	2015.02.14.20.15.05;	author jca;	state Exp;
branches;
next	1.33;
commitid	lhC5X7zNGiUNaWY1;

1.33
date	2015.01.30.16.41.43;	author gilles;	state Exp;
branches;
next	1.32;
commitid	uZ7MdPMefoZywQnM;

1.32
date	2015.01.14.23.36.15;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	tiEBIWumVnjfOhkT;

1.31
date	2014.11.18.20.51.00;	author krw;	state Exp;
branches;
next	1.30;
commitid	G35ycnLxaVis5TX9;

1.30
date	2014.09.15.06.15.48;	author guenther;	state Exp;
branches;
next	1.29;
commitid	ztgYHm1nk3mtTyS3;

1.29
date	2014.07.23.21.26.25;	author eric;	state Exp;
branches;
next	1.28;
commitid	WIq5DvzhMZ99bkXf;

1.28
date	2014.05.10.21.21.09;	author chl;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.28.21.38.59;	author sperreault;	state Exp;
branches;
next	1.26;

1.26
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.25.19.48.11;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2014.03.14.11.07.33;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2014.03.03.08.37.37;	author eric;	state Exp;
branches;
next	1.22;

1.22
date	2014.02.26.20.50.24;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2014.02.26.20.00.08;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2014.02.17.11.04.23;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2013.07.12.14.36.21;	author eric;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.01.14.34.34;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.30.12.02.39;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.30.06.53.07;	author eric;	state Exp;
branches;
next	1.15;

1.15
date	2013.04.08.08.24.56;	author chrisz;	state Exp;
branches;
next	1.14;

1.14
date	2013.04.01.15.49.54;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.30.20.11.19;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.28.11.47.23;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.27.07.40.41;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.24.13.59.53;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.06.15.05.16;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.05.21.49.12;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.05.15.56.13;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.18.11.19.51;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.13.14.05.12;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.10.09.20.51;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.25.20.28.25;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Put a common flags field in the query struct, rather than in some
elements of the union.

This field is for internal asr flags.  The flags in "struct rrset" and
"struct ni" are different kinds of flags.

ok eric@@
@
text
@/*	$OpenBSD: getaddrinfo_async.c,v 1.53 2017/02/23 17:04:02 eric Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <net/if.h>
#include <netdb.h>

#include <asr.h>
#include <errno.h>
#include <ifaddrs.h>
#include <resolv.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "asr_private.h"

struct match {
	int family;
	int socktype;
	int protocol;
};

static int getaddrinfo_async_run(struct asr_query *, struct asr_result *);
static int get_port(const char *, const char *, int);
static int iter_family(struct asr_query *, int);
static int addrinfo_add(struct asr_query *, const struct sockaddr *, const char *);
static int addrinfo_from_file(struct asr_query *, int,  FILE *);
static int addrinfo_from_pkt(struct asr_query *, char *, size_t);
static int addrconfig_setup(struct asr_query *);

static const struct match matches[] = {
	{ PF_INET,	SOCK_DGRAM,	IPPROTO_UDP	},
	{ PF_INET,	SOCK_STREAM,	IPPROTO_TCP	},
	{ PF_INET,	SOCK_RAW,	0		},
	{ PF_INET6,	SOCK_DGRAM,	IPPROTO_UDP	},
	{ PF_INET6,	SOCK_STREAM,	IPPROTO_TCP	},
	{ PF_INET6,	SOCK_RAW,	0		},
	{ -1,		0,		0,		},
};

#define MATCH_FAMILY(a, b) ((a) == matches[(b)].family || (a) == PF_UNSPEC)
#define MATCH_PROTO(a, b) ((a) == matches[(b)].protocol || (a) == 0 || matches[(b)].protocol == 0)
/* Do not match SOCK_RAW unless explicitely specified */
#define MATCH_SOCKTYPE(a, b) ((a) == matches[(b)].socktype || ((a) == 0 && \
				matches[(b)].socktype != SOCK_RAW))

enum {
	DOM_INIT,
	DOM_DOMAIN,
	DOM_DONE
};

struct asr_query *
getaddrinfo_async(const char *hostname, const char *servname,
	const struct addrinfo *hints, void *asr)
{
	struct asr_ctx		*ac;
	struct asr_query	*as;

	if (hints == NULL || (hints->ai_flags & AI_NUMERICHOST) == 0)
		ac = _asr_use_resolver(asr);
	else
		ac = _asr_no_resolver();
	if ((as = _asr_async_new(ac, ASR_GETADDRINFO)) == NULL)
		goto abort; /* errno set */
	as->as_run = getaddrinfo_async_run;

	if (hostname) {
		if ((as->as.ai.hostname = strdup(hostname)) == NULL)
			goto abort; /* errno set */
	}
	if (servname && (as->as.ai.servname = strdup(servname)) == NULL)
		goto abort; /* errno set */
	if (hints)
		memmove(&as->as.ai.hints, hints, sizeof *hints);
	else {
		memset(&as->as.ai.hints, 0, sizeof as->as.ai.hints);
		as->as.ai.hints.ai_family = PF_UNSPEC;
		as->as.ai.hints.ai_flags = AI_ADDRCONFIG;
	}

	_asr_ctx_unref(ac);
	return (as);
    abort:
	if (as)
		_asr_async_free(as);
	_asr_ctx_unref(ac);
	return (NULL);
}
DEF_WEAK(getaddrinfo_async);

static int
getaddrinfo_async_run(struct asr_query *as, struct asr_result *ar)
{
	char		 fqdn[MAXDNAME];
	const char	*str;
	struct addrinfo	*ai;
	int		 i, family, r;
	FILE		*f;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sain;
		struct sockaddr_in6	sain6;
	} sa;

    next:
	switch (as->as_state) {

	case ASR_STATE_INIT:

		/*
		 * First, make sure the parameters are valid.
		 */

		as->as_count = 0;

		if (as->as.ai.hostname == NULL &&
		    as->as.ai.servname == NULL) {
			ar->ar_gai_errno = EAI_NONAME;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (as->as.ai.hostname && as->as.ai.hostname[0] == '\0') {
			ar->ar_gai_errno = EAI_NODATA;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}
		
		ai = &as->as.ai.hints;

		if (ai->ai_addrlen ||
		    ai->ai_canonname ||
		    ai->ai_addr ||
		    ai->ai_next) {
			ar->ar_gai_errno = EAI_BADHINTS;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (ai->ai_flags & ~AI_MASK ||
		    (ai->ai_flags & AI_CANONNAME && ai->ai_flags & AI_FQDN)) {
			ar->ar_gai_errno = EAI_BADFLAGS;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (ai->ai_family != PF_UNSPEC &&
		    ai->ai_family != PF_INET &&
		    ai->ai_family != PF_INET6) {
			ar->ar_gai_errno = EAI_FAMILY;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (ai->ai_socktype &&
		    ai->ai_socktype != SOCK_DGRAM  &&
		    ai->ai_socktype != SOCK_STREAM &&
		    ai->ai_socktype != SOCK_RAW) {
			ar->ar_gai_errno = EAI_SOCKTYPE;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (ai->ai_socktype == SOCK_RAW &&
		    get_port(as->as.ai.servname, NULL, 1) != 0) {
			ar->ar_gai_errno = EAI_SERVICE;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		/* Restrict result set to configured address families */
		if (ai->ai_flags & AI_ADDRCONFIG) {
			if (addrconfig_setup(as) == -1) {
				ar->ar_errno = errno;
				ar->ar_gai_errno = EAI_SYSTEM;
				async_set_state(as, ASR_STATE_HALT);
				break;
			}
		}

		/* Make sure there is at least a valid combination */
		for (i = 0; matches[i].family != -1; i++)
			if (MATCH_FAMILY(ai->ai_family, i) &&
			    MATCH_SOCKTYPE(ai->ai_socktype, i) &&
			    MATCH_PROTO(ai->ai_protocol, i))
				break;
		if (matches[i].family == -1) {
			ar->ar_gai_errno = EAI_BADHINTS;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (ai->ai_protocol == 0 || ai->ai_protocol == IPPROTO_UDP)
			as->as.ai.port_udp = get_port(as->as.ai.servname, "udp",
			    as->as.ai.hints.ai_flags & AI_NUMERICSERV);
		if (ai->ai_protocol == 0 || ai->ai_protocol == IPPROTO_TCP)
			as->as.ai.port_tcp = get_port(as->as.ai.servname, "tcp",
			    as->as.ai.hints.ai_flags & AI_NUMERICSERV);
		if (as->as.ai.port_tcp == -2 || as->as.ai.port_udp == -2 ||
		    (as->as.ai.port_tcp == -1 && as->as.ai.port_udp == -1) ||
		    (ai->ai_protocol && (as->as.ai.port_udp == -1 ||
					 as->as.ai.port_tcp == -1))) {
			ar->ar_gai_errno = EAI_SERVICE;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		ar->ar_gai_errno = 0;

		/* If hostname is NULL, use local address */
		if (as->as.ai.hostname == NULL) {
			for (family = iter_family(as, 1);
			    family != -1;
			    family = iter_family(as, 0)) {
				/*
				 * We could use statically built sockaddrs for
				 * those, rather than parsing over and over.
				 */
				if (family == PF_INET)
					str = (ai->ai_flags & AI_PASSIVE) ? \
						"0.0.0.0" : "127.0.0.1";
				else /* PF_INET6 */
					str = (ai->ai_flags & AI_PASSIVE) ? \
						"::" : "::1";
				 /* This can't fail */
				_asr_sockaddr_from_str(&sa.sa, family, str);
				if ((r = addrinfo_add(as, &sa.sa, NULL))) {
					ar->ar_gai_errno = r;
					break;
				}
			}
			if (ar->ar_gai_errno == 0 && as->as_count == 0) {
				ar->ar_gai_errno = EAI_NODATA;
			}
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		/* Try numeric addresses first */
		for (family = iter_family(as, 1);
		    family != -1;
		    family = iter_family(as, 0)) {

			if (_asr_sockaddr_from_str(&sa.sa, family,
			    as->as.ai.hostname) == -1)
				continue;

			if ((r = addrinfo_add(as, &sa.sa, NULL)))
				ar->ar_gai_errno = r;
			break;
		}
		if (ar->ar_gai_errno || as->as_count) {
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (ai->ai_flags & AI_NUMERICHOST) {
			ar->ar_gai_errno = EAI_NONAME;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		async_set_state(as, ASR_STATE_NEXT_DB);
		break;

	case ASR_STATE_NEXT_DB:
		if (_asr_iter_db(as) == -1) {
			async_set_state(as, ASR_STATE_NOT_FOUND);
			break;
		}
		as->as_family_idx = 0;
		async_set_state(as, ASR_STATE_SAME_DB);
		break;

	case ASR_STATE_NEXT_FAMILY:
		as->as_family_idx += 1;
		if (as->as.ai.hints.ai_family != AF_UNSPEC ||
		    AS_FAMILY(as) == -1) {
			/* The family was specified, or we have tried all
			 * families with this DB.
			 */
			if (as->as_count) {
				ar->ar_gai_errno = 0;
				async_set_state(as, ASR_STATE_HALT);
			} else
				async_set_state(as, ASR_STATE_NEXT_DOMAIN);
			break;
		}
		async_set_state(as, ASR_STATE_SAME_DB);
		break;

	case ASR_STATE_NEXT_DOMAIN:
		/* domain search is only for dns */
		if (AS_DB(as) != ASR_DB_DNS) {
			async_set_state(as, ASR_STATE_NEXT_DB);
			break;
		}
		as->as_family_idx = 0;

		free(as->as.ai.fqdn);
		as->as.ai.fqdn = NULL;
		r = _asr_iter_domain(as, as->as.ai.hostname, fqdn, sizeof(fqdn));
		if (r == -1) {
			async_set_state(as, ASR_STATE_NEXT_DB);
			break;
		}
		if (r == 0) {
			ar->ar_gai_errno = EAI_FAIL;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}
		as->as.ai.fqdn = strdup(fqdn);
		if (as->as.ai.fqdn == NULL) {
			ar->ar_gai_errno = EAI_MEMORY;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		async_set_state(as, ASR_STATE_SAME_DB);
		break;

	case ASR_STATE_SAME_DB:
		/* query the current DB again */
		switch (AS_DB(as)) {
		case ASR_DB_DNS:
			if (as->as.ai.fqdn == NULL) {
				/* First try, initialize domain iteration */
				as->as_dom_flags = 0;
				as->as_dom_step = DOM_INIT;
				async_set_state(as, ASR_STATE_NEXT_DOMAIN);
				break;
			}

			family = (as->as.ai.hints.ai_family == AF_UNSPEC) ?
			    AS_FAMILY(as) : as->as.ai.hints.ai_family;

			if (family == AF_INET &&
			    as->as_flags & ASYNC_NO_INET) {
				async_set_state(as, ASR_STATE_NEXT_FAMILY);
				break;
			} else if (family == AF_INET6 &&
			    as->as_flags & ASYNC_NO_INET6) {
				async_set_state(as, ASR_STATE_NEXT_FAMILY);
				break;
			}

			as->as_subq = _res_query_async_ctx(as->as.ai.fqdn,
			    C_IN, (family == AF_INET6) ? T_AAAA : T_A,
			    as->as_ctx);

			if (as->as_subq == NULL) {
				if (errno == ENOMEM)
					ar->ar_gai_errno = EAI_MEMORY;
				else
					ar->ar_gai_errno = EAI_FAIL;
				async_set_state(as, ASR_STATE_HALT);
				break;
			}
			async_set_state(as, ASR_STATE_SUBQUERY);
			break;

		case ASR_DB_FILE:
			f = fopen(_PATH_HOSTS, "re");
			if (f == NULL) {
				async_set_state(as, ASR_STATE_NEXT_DB);
				break;
			}
			family = (as->as.ai.hints.ai_family == AF_UNSPEC) ?
			    AS_FAMILY(as) : as->as.ai.hints.ai_family;

			r = addrinfo_from_file(as, family, f);
			if (r == -1) {
				if (errno == ENOMEM)
					ar->ar_gai_errno = EAI_MEMORY;
				else
					ar->ar_gai_errno = EAI_FAIL;
				async_set_state(as, ASR_STATE_HALT);
			} else
				async_set_state(as, ASR_STATE_NEXT_FAMILY);
			fclose(f);
			break;

		default:
			async_set_state(as, ASR_STATE_NEXT_DB);
		}
		break;

	case ASR_STATE_SUBQUERY:
		if ((r = asr_run(as->as_subq, ar)) == ASYNC_COND)
			return (ASYNC_COND);

		as->as_subq = NULL;

		if (ar->ar_datalen == -1) {
			async_set_state(as, ASR_STATE_NEXT_FAMILY);
			break;
		}

		r = addrinfo_from_pkt(as, ar->ar_data, ar->ar_datalen);
		if (r == -1) {
			if (errno == ENOMEM)
				ar->ar_gai_errno = EAI_MEMORY;
			else
				ar->ar_gai_errno = EAI_FAIL;
			async_set_state(as, ASR_STATE_HALT);
		} else
			async_set_state(as, ASR_STATE_NEXT_FAMILY);
		free(ar->ar_data);
		break;

	case ASR_STATE_NOT_FOUND:
		/* No result found. Maybe we can try again. */
		if (as->as_flags & ASYNC_AGAIN)
			ar->ar_gai_errno = EAI_AGAIN;
		else
			ar->ar_gai_errno = EAI_NODATA;
		async_set_state(as, ASR_STATE_HALT);
		break;

	case ASR_STATE_HALT:
		if (ar->ar_gai_errno == 0) {
			ar->ar_count = as->as_count;
			ar->ar_addrinfo = as->as.ai.aifirst;
			as->as.ai.aifirst = NULL;
		} else {
			ar->ar_count = 0;
			ar->ar_addrinfo = NULL;
		}
		return (ASYNC_DONE);

	default:
		ar->ar_errno = EOPNOTSUPP;
		ar->ar_gai_errno = EAI_SYSTEM;
		async_set_state(as, ASR_STATE_HALT);
		break;
	}
	goto next;
}

/*
 * Retreive the port number for the service name "servname" and
 * the protocol "proto".
 */
static int
get_port(const char *servname, const char *proto, int numonly)
{
	struct servent		se;
	struct servent_data	sed;
	int			port, r;
	const char		*e;

	if (servname == NULL)
		return (0);

	e = NULL;
	port = strtonum(servname, 0, USHRT_MAX, &e);
	if (e == NULL)
		return (port);
	if (errno == ERANGE)
		return (-2); /* invalid */
	if (numonly)
		return (-2);

	memset(&sed, 0, sizeof(sed));
	r = getservbyname_r(servname, proto, &se, &sed);
	port = ntohs(se.s_port);
	endservent_r(&sed);

	if (r == -1)
		return (-1); /* not found */

	return (port);
}

/*
 * Iterate over the address families that are to be queried. Use the
 * list on the async context, unless a specific family was given in hints.
 */
static int
iter_family(struct asr_query *as, int first)
{
	if (first) {
		as->as_family_idx = 0;
		if (as->as.ai.hints.ai_family != PF_UNSPEC)
			return as->as.ai.hints.ai_family;
		return AS_FAMILY(as);
	}

	if (as->as.ai.hints.ai_family != PF_UNSPEC)
		return (-1);

	as->as_family_idx++;

	return AS_FAMILY(as);
}

/*
 * Use the sockaddr at "sa" to extend the result list on the "as" context,
 * with the specified canonical name "cname". This function adds one
 * entry per protocol/socktype match.
 */
static int
addrinfo_add(struct asr_query *as, const struct sockaddr *sa, const char *cname)
{
	struct addrinfo		*ai;
	int			 i, port, proto;

	for (i = 0; matches[i].family != -1; i++) {
		if (matches[i].family != sa->sa_family ||
		    !MATCH_SOCKTYPE(as->as.ai.hints.ai_socktype, i) ||
		    !MATCH_PROTO(as->as.ai.hints.ai_protocol, i))
			continue;

		proto = as->as.ai.hints.ai_protocol;
		if (!proto)
			proto = matches[i].protocol;

		if (proto == IPPROTO_TCP)
			port = as->as.ai.port_tcp;
		else if (proto == IPPROTO_UDP)
			port = as->as.ai.port_udp;
		else
			port = 0;

		/* servname specified, but not defined for this protocol */
		if (port == -1)
			continue;

		ai = calloc(1, sizeof(*ai) + sa->sa_len);
		if (ai == NULL)
			return (EAI_MEMORY);
		ai->ai_family = sa->sa_family;
		ai->ai_socktype = matches[i].socktype;
		ai->ai_protocol = proto;
		ai->ai_flags = as->as.ai.hints.ai_flags;
		ai->ai_addrlen = sa->sa_len;
		ai->ai_addr = (void *)(ai + 1);
		if (cname &&
		    as->as.ai.hints.ai_flags & (AI_CANONNAME | AI_FQDN)) {
			if ((ai->ai_canonname = strdup(cname)) == NULL) {
				free(ai);
				return (EAI_MEMORY);
			}
		}
		memmove(ai->ai_addr, sa, sa->sa_len);
		if (sa->sa_family == PF_INET)
			((struct sockaddr_in *)ai->ai_addr)->sin_port =
			    htons(port);
		else if (sa->sa_family == PF_INET6)
			((struct sockaddr_in6 *)ai->ai_addr)->sin6_port =
			    htons(port);

		if (as->as.ai.aifirst == NULL)
			as->as.ai.aifirst = ai;
		if (as->as.ai.ailast)
			as->as.ai.ailast->ai_next = ai;
		as->as.ai.ailast = ai;
		as->as_count += 1;
	}

	return (0);
}

static int
addrinfo_from_file(struct asr_query *as, int family, FILE *f)
{
	char		*tokens[MAXTOKEN], *c, buf[BUFSIZ + 1];
	int		 n, i;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sain;
		struct sockaddr_in6	sain6;
	} u;

	for (;;) {
		n = _asr_parse_namedb_line(f, tokens, MAXTOKEN, buf, sizeof(buf));
		if (n == -1)
			break; /* ignore errors reading the file */

		for (i = 1; i < n; i++) {
			if (strcasecmp(as->as.ai.hostname, tokens[i]))
				continue;
			if (_asr_sockaddr_from_str(&u.sa, family, tokens[0]) == -1)
				continue;
			break;
		}
		if (i == n)
			continue;

		if (as->as.ai.hints.ai_flags & (AI_CANONNAME | AI_FQDN))
			c = tokens[1];
		else
			c = NULL;

		if (addrinfo_add(as, &u.sa, c))
			return (-1); /* errno set */
	}
	return (0);
}

static int
addrinfo_from_pkt(struct asr_query *as, char *pkt, size_t pktlen)
{
	struct asr_unpack	 p;
	struct asr_dns_header	 h;
	struct asr_dns_query	 q;
	struct asr_dns_rr	 rr;
	int			 i;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sain;
		struct sockaddr_in6	sain6;
	} u;
	char		 buf[MAXDNAME], *c;

	_asr_unpack_init(&p, pkt, pktlen);
	_asr_unpack_header(&p, &h);
	for (; h.qdcount; h.qdcount--)
		_asr_unpack_query(&p, &q);

	for (i = 0; i < h.ancount; i++) {
		_asr_unpack_rr(&p, &rr);
		if (rr.rr_type != q.q_type ||
		    rr.rr_class != q.q_class)
			continue;

		memset(&u, 0, sizeof u);
		if (rr.rr_type == T_A) {
			u.sain.sin_len = sizeof u.sain;
			u.sain.sin_family = AF_INET;
			u.sain.sin_addr = rr.rr.in_a.addr;
			u.sain.sin_port = 0;
		} else if (rr.rr_type == T_AAAA) {
			u.sain6.sin6_len = sizeof u.sain6;
			u.sain6.sin6_family = AF_INET6;
			u.sain6.sin6_addr = rr.rr.in_aaaa.addr6;
			u.sain6.sin6_port = 0;
		} else
			continue;

		if (as->as.ai.hints.ai_flags & AI_CANONNAME) {
			_asr_strdname(rr.rr_dname, buf, sizeof buf);
			buf[strlen(buf) - 1] = '\0';
			c = res_hnok(buf) ? buf : NULL;
		} else if (as->as.ai.hints.ai_flags & AI_FQDN)
			c = as->as.ai.fqdn;
		else
			c = NULL;

		if (addrinfo_add(as, &u.sa, c))
			return (-1); /* errno set */
	}
	return (0);
}

static int
addrconfig_setup(struct asr_query *as)
{
	struct ifaddrs		*ifa, *ifa0;
	struct sockaddr_in	*sinp;
	struct sockaddr_in6	*sin6p;

	if (getifaddrs(&ifa0) == -1)
		return (-1);

	as->as_flags |= ASYNC_NO_INET | ASYNC_NO_INET6;

	for (ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr == NULL)
			continue;

		switch (ifa->ifa_addr->sa_family) {
		case PF_INET:
			sinp = (struct sockaddr_in *)ifa->ifa_addr;

			if (sinp->sin_addr.s_addr == htonl(INADDR_LOOPBACK))
				continue;

			as->as_flags &= ~ASYNC_NO_INET;
			break;
		case PF_INET6:
			sin6p = (struct sockaddr_in6 *)ifa->ifa_addr;

			if (IN6_IS_ADDR_LOOPBACK(&sin6p->sin6_addr))
				continue;

			if (IN6_IS_ADDR_LINKLOCAL(&sin6p->sin6_addr))
				continue;

			as->as_flags &= ~ASYNC_NO_INET6;
			break;
		}
	}

	freeifaddrs(ifa0);

	return (0);
}
@


1.53
log
@Put a common subq pointer in the query struct, rather than one in each
element of the union.

ok gilles@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.52 2017/02/21 22:32:28 eric Exp $	*/
d359 1
a359 1
			    as->as.ai.flags & ASYNC_NO_INET) {
d363 1
a363 1
			    as->as.ai.flags & ASYNC_NO_INET6) {
d434 1
a434 1
		if (as->as.ai.flags & ASYNC_AGAIN)
d687 1
a687 1
	as->as.ai.flags |= ASYNC_NO_INET | ASYNC_NO_INET6;
d700 1
a700 1
			as->as.ai.flags &= ~ASYNC_NO_INET;
d711 1
a711 1
			as->as.ai.flags &= ~ASYNC_NO_INET6;
@


1.52
log
@missing breaks

ok jca@@ krw@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.51 2017/02/21 07:28:28 eric Exp $	*/
d368 1
a368 1
			as->as.ai.subq = _res_query_async_ctx(as->as.ai.fqdn,
d372 1
a372 1
			if (as->as.ai.subq == NULL) {
d410 1
a410 1
		if ((r = asr_run(as->as.ai.subq, ar)) == ASYNC_COND)
d413 1
a413 1
		as->as.ai.subq = NULL;
@


1.51
log
@Report the errno set by getifaddrs(3) if the setup for AI_ADDRCONFIG fails,
rather than a non-informative EAI_FAIL.  Compare to -1 for error detection
while here.

ok jca@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.50 2015/12/16 16:32:30 deraadt Exp $	*/
d337 1
@


1.50
log
@Remove support for HOSTALIASES from the resolver.  This "open and parse
any file indicated by an environment variable" feature inside the
resolver is incompatible with what pledge "dns" is trying to be.  It is
a misguided "feature" added way back in history which almost noone uses,
but everyone has to assume the risk from.
ok eric florian kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.49 2015/11/23 18:04:54 deraadt Exp $	*/
d194 3
a196 2
			if (addrconfig_setup(as) != 0) {
				ar->ar_gai_errno = EAI_FAIL;
d683 1
a683 1
	if (getifaddrs(&ifa0) != 0)
@


1.49
log
@Remove support for "lookup yp" in /etc/resolv.conf.  This historical
wart is incompatible with pledge, because suddenly a "dns" operation
needs "getpw" access to ypbind/ypserv, etc.  file + dns access is
enough for everyone, sorry if you were using that old SunOS 4.x style
mechanism, but it is now gone.
ok semarie millert florian
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.48 2015/10/08 14:08:44 eric Exp $	*/
a78 1
	char			 alias[MAXDNAME];
a88 2
		if (_asr_hostalias(ac, hostname, alias, sizeof(alias)))
			hostname = alias;
@


1.48
log
@fix conditionals

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.47 2015/10/08 13:55:56 deraadt Exp $	*/
a34 7
#ifdef YP
#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "ypinternal.h"
#endif

a49 3
#ifdef YP
static int addrinfo_from_yp(struct asr_query *, int, char *);
#endif
a117 6
#ifdef YP
	static char	*domain = NULL;
	char		*res;
	int		 len;
	char		 *name;
#endif
a404 32
#ifdef YP
		case ASR_DB_YP:
			if (!domain && _yp_check(&domain) == 0) {
				async_set_state(as, ASR_STATE_NEXT_DB);
				break;
			}
			family = (as->as.ai.hints.ai_family == AF_UNSPEC) ?
			    AS_FAMILY(as) : as->as.ai.hints.ai_family;

			name = as->as.ai.hostname;

			/* XXX
			 * ipnodes.byname could also contain IPv4 address
			 */
			r = yp_match(domain, (family == AF_INET6) ?
			    "ipnodes.byname" : "hosts.byname",
			    name, strlen(name), &res, &len);
			if (r == 0) {
				r = addrinfo_from_yp(as, family, res);
				free(res);
				if (r == -1) {
					if (errno == ENOMEM)
						ar->ar_gai_errno = EAI_MEMORY;
					else
						ar->ar_gai_errno = EAI_FAIL;
					async_set_state(as, ASR_STATE_HALT);
					break;
				}
			}
			async_set_state(as, ASR_STATE_NEXT_FAMILY);
			break;
#endif
a720 52

#ifdef YP
static int
strsplit(char *line, char **tokens, int ntokens)
{
	int	ntok;
	char	*cp, **tp;

	for (cp = line, tp = tokens, ntok = 0;
	    ntok < ntokens && (*tp = strsep(&cp, " \t")) != NULL; )
		if (**tp != '\0') {
			tp++;
			ntok++;
		}

	return (ntok);
}

static int
addrinfo_from_yp(struct asr_query *as, int family, char *line)
{
	char		*next, *tokens[MAXTOKEN], *c;
	int		 ntok;
	union {
		struct sockaddr		sa;
		struct sockaddr_in	sain;
		struct sockaddr_in6	sain6;
	} u;

	for (next = line; line; line = next) {
		if ((next = strchr(line, '\n'))) {
			*next = '\0';
			next += 1;
		}
		ntok = strsplit(line, tokens, MAXTOKEN);
		if (ntok < 2)
			continue;

		if (_asr_sockaddr_from_str(&u.sa, family, tokens[0]) == -1)
			continue;

		if (as->as.ai.hints.ai_flags & (AI_CANONNAME | AI_FQDN))
			c = tokens[1];
		else
			c = NULL;

		if (addrinfo_add(as, &u.sa, c))
			return (-1); /* errno set */
	}
	return (0);
}
#endif
@


1.47
log
@Handle case where no hint is passed in.  Found as a crash of fdm by jturner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.46 2015/10/07 13:59:34 deraadt Exp $	*/
d91 1
a91 1
	if (hints && (hints->ai_flags & AI_NUMERICHOST) == 0)
@


1.46
log
@getaddrinfo_async() shouldn't unconditionally intialize the resolver
via _asr_use_resolver().  If the hint specifies for AI_NUMERICHOST,
create a transient lookup context which won't try to open /etc/reslov.conf
ok eric guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.45 2015/09/20 14:19:21 eric Exp $	*/
d91 1
a91 1
	if ((hints->ai_flags & AI_NUMERICHOST) == 0)
@


1.45
log
@remove bogus includes of err.h
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.44 2015/09/20 12:18:47 eric Exp $	*/
d91 4
a94 1
	ac = _asr_use_resolver(asr);
@


1.44
log
@remove unused static function
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.43 2015/09/14 11:52:49 guenther Exp $	*/
a26 1
#include <err.h>
@


1.43
log
@Wrap <asr.h> so internal calls go direct and all the symbols are weak
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.42 2015/09/09 15:49:34 deraadt Exp $	*/
a562 17
}

/*
 * Concatenate a name and a domain name. The result has no trailing dot.
 * Return the resulting string length, or 0 in case of error.
 */
static size_t
domcat(const char *name, const char *domain, char *buf, size_t buflen)
{
	size_t	r;

	r = _asr_make_fqdn(name, domain, buf, buflen);
	if (r == 0)
		return (0);
	buf[r - 1] = '\0';

	return (r - 1);
@


1.42
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.41 2015/08/16 20:37:25 jca Exp $	*/
d121 1
@


1.41
log
@Fix test against INADDR_LOOPBACK

ok gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.40 2015/05/29 08:49:37 eric Exp $	*/
a53 1
static int iter_domain(struct asr_query *, const char *, char *, size_t);
d92 2
a93 2
	ac = asr_use_resolver(asr);
	if ((as = asr_async_new(ac, ASR_GETADDRINFO)) == NULL)
d98 1
a98 1
		if (asr_hostalias(ac, hostname, alias, sizeof(alias)))
d113 1
a113 1
	asr_ctx_unref(ac);
d117 2
a118 2
		asr_async_free(as);
	asr_ctx_unref(ac);
d262 1
a262 1
				asr_sockaddr_from_str(&sa.sa, family, str);
d280 1
a280 1
			if (asr_sockaddr_from_str(&sa.sa, family,
d303 1
a303 1
		if (asr_iter_db(as) == -1) {
d338 1
a338 1
		r = iter_domain(as, as->as.ai.hostname, fqdn, sizeof(fqdn));
d382 1
a382 1
			as->as.ai.subq = res_query_async_ctx(as->as.ai.fqdn,
d573 1
a573 1
	r = asr_make_fqdn(name, domain, buf, buflen);
a581 96
 * Implement the search domain strategy.
 *
 * XXX duplicate from res_search_async
 *
 * This function works as a generator that constructs complete domains in
 * buffer "buf" of size "len" for the given host name "name", according to the
 * search rules defined by the resolving context.  It is supposed to be called
 * multiple times (with the same name) to generate the next possible domain
 * name, if any.
 *
 * It returns -1 if all possibilities have been exhausted, 0 if there was an
 * error generating the next name, or the resulting name length.
 */
static int
iter_domain(struct asr_query *as, const char *name, char * buf, size_t len)
{
	const char	*c;
	int		 dots;

	switch (as->as_dom_step) {

	case DOM_INIT:
		/* First call */

		/*
		 * If "name" is an FQDN, that's the only result and we
		 * don't try anything else.
		 */
		if (strlen(name) && name[strlen(name) - 1] ==  '.') {
			DPRINT("asr: iter_domain(\"%s\") fqdn\n", name);
			as->as_dom_flags |= ASYNC_DOM_FQDN;
			as->as_dom_step = DOM_DONE;
			return (domcat(name, NULL, buf, len));
		}

		/*
		 * Otherwise, we iterate through the specified search domains.
		 */
		as->as_dom_step = DOM_DOMAIN;
		as->as_dom_idx = 0;

		/*
		 * If "name" as enough dots, use it as-is first, as indicated
		 * in resolv.conf(5).
		 */
		dots = 0;
		for (c = name; *c; c++)
			dots += (*c == '.');
		if (dots >= as->as_ctx->ac_ndots) {
			DPRINT("asr: iter_domain(\"%s\") ndots\n", name);
			as->as_dom_flags |= ASYNC_DOM_NDOTS;
			if (strlcpy(buf, name, len) >= len)
				return (0);
			return (strlen(buf));
		}
		/* Otherwise, starts using the search domains */
		/* FALLTHROUGH */

	case DOM_DOMAIN:
		if (as->as_dom_idx < as->as_ctx->ac_domcount &&
		    (as->as_ctx->ac_options & RES_DNSRCH || (
			as->as_ctx->ac_options & RES_DEFNAMES &&
			as->as_dom_idx == 0 &&
			strchr(name, '.') == NULL))) {
			DPRINT("asr: iter_domain(\"%s\") domain \"%s\"\n",
			    name, as->as_ctx->ac_dom[as->as_dom_idx]);
			as->as_dom_flags |= ASYNC_DOM_DOMAIN;
			return (domcat(name,
			    as->as_ctx->ac_dom[as->as_dom_idx++], buf, len));
		}

		/* No more domain to try. */

		as->as_dom_step = DOM_DONE;

		/*
		 * If the name was not tried as an absolute name before,
		 * do it now.
		 */
		if (!(as->as_dom_flags & ASYNC_DOM_NDOTS)) {
			DPRINT("asr: iter_domain(\"%s\") as is\n", name);
			as->as_dom_flags |= ASYNC_DOM_ASIS;
			if (strlcpy(buf, name, len) >= len)
				return (0);
			return (strlen(buf));
		}
		/* Otherwise, we are done. */

	case DOM_DONE:
	default:
		DPRINT("asr: iter_domain(\"%s\") done\n", name);
		return (-1);
	}
}

/*
d660 1
a660 1
		n = asr_parse_namedb_line(f, tokens, MAXTOKEN, buf, sizeof(buf));
d667 1
a667 1
			if (asr_sockaddr_from_str(&u.sa, family, tokens[0]) == -1)
d700 2
a701 2
	asr_unpack_init(&p, pkt, pktlen);
	asr_unpack_header(&p, &h);
d703 1
a703 1
		asr_unpack_query(&p, &q);
d706 1
a706 1
		asr_unpack_rr(&p, &rr);
d726 1
a726 1
			asr_strdname(rr.rr_dname, buf, sizeof buf);
d821 1
a821 1
		if (asr_sockaddr_from_str(&u.sa, family, tokens[0]) == -1)
@


1.40
log
@fix a possible off-by-one when reading /etc/hosts if it doesn't end
with a newline.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.39 2015/05/26 19:28:57 eric Exp $	*/
d857 1
a857 1
			if (sinp->sin_addr.s_addr == INADDR_LOOPBACK)
@


1.39
log
@simply use _PATH_HOSTS where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.38 2015/05/25 21:59:37 jca Exp $	*/
d748 1
a748 1
	char		*tokens[MAXTOKEN], *c;
d757 1
a757 1
		n = asr_parse_namedb_line(f, tokens, MAXTOKEN);
@


1.38
log
@Kill outdated comment.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.37 2015/05/25 19:30:25 eric Exp $	*/
d399 1
a399 1
			f = fopen(as->as_ctx->ac_hostfile, "re");
@


1.37
log
@Skip search domains iteration if RES_DNSRCH and/or RES_DEFNAMES is unset.

prodded by Brad
ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.36 2015/05/05 17:08:44 jca Exp $	*/
d30 1
a30 1
#include <resolv.h> /* for res_hnok */
@


1.36
log
@AI_ADDRCONFIG: skip loopback addresses, not loopback interfaces.

This is what RFC3493 suggests.  Fixes AI_ADDRCONFIG on setups where
global addresses are configured only on loopback interfaces.

Discussed with and ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.34 2015/02/14 20:15:05 jca Exp $	*/
d642 5
a646 1
		if (as->as_dom_idx < as->as_ctx->ac_domcount) {
@


1.35
log
@Move the AI_ADDRCONFIG setup to its own function.

Input from and ok gilles@@ eric@@
@
text
@d837 1
a845 3
		if (ifa->ifa_flags & IFF_LOOPBACK)
			continue;

d851 5
d860 3
@


1.34
log
@Limit AI_ADDRCONFIG effects to DNS queries.

This is what RFC 2553 initially described, sadly RFC 3493 stopped
limiting scope to DNS.  This can result in nonsensical failures with
loopback addresses, link-local addresses, raw addresses and /etc/hosts
entries.

with and ok eric@@ sperreault@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.33 2015/01/30 16:41:43 gilles Exp $	*/
d58 1
a136 1
	struct ifaddrs	*ifa, *ifa0;
d211 1
a211 1
			if (getifaddrs(&ifa0) != 0) {
a215 15

			as->as.ai.flags |= ASYNC_NO_INET | ASYNC_NO_INET6;
			for (ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next) {
				if (ifa->ifa_flags & IFF_LOOPBACK)
					continue;
				if (ifa->ifa_addr == NULL)
					continue;
				if (ifa->ifa_addr->sa_family == PF_INET)
					as->as.ai.flags &= ~ASYNC_NO_INET;
				else if (ifa->ifa_addr->sa_family == PF_INET6 &&
				    !IN6_IS_ADDR_LINKLOCAL(&((struct
				    sockaddr_in6 *)ifa->ifa_addr)->sin6_addr))
					as->as.ai.flags &= ~ASYNC_NO_INET6;
			}
			freeifaddrs(ifa0);
d830 38
@


1.33
log
@fix a possible NULL-deref when trying to deref ifa->ifa_addr

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.32 2015/01/14 23:36:15 deraadt Exp $	*/
d134 1
a134 1
	int		 i, family, r, v4, v6;
d216 2
a217 2
			v4 = 0;
			v6 = 0;
d224 1
a224 1
					v4 = 1;
d228 1
a228 1
					v6 = 1;
a230 11
			if ((ai->ai_family == PF_UNSPEC && !v4 && !v6) ||
			    (ai->ai_family == PF_INET && !v4) ||
			    (ai->ai_family == PF_INET6 && !v6)) {
				ar->ar_gai_errno = EAI_NONAME;
				async_set_state(as, ASR_STATE_HALT);
				break;
			}
			if (ai->ai_family == PF_UNSPEC && v4 && !v6)
				ai->ai_family = PF_INET;
			if (ai->ai_family == PF_UNSPEC && !v4 && v6)
				ai->ai_family = PF_INET6;
d387 10
@


1.32
log
@change _yp_domain[] to HOST_NAME_MAX+1, and re-arrange those who include
it to get limits.h early enough
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.31 2014/11/18 20:51:00 krw Exp $	*/
d220 2
@


1.31
log
@Nuke some obvious #include duplications.

ok espie@@ deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.30 2014/09/15 06:15:48 guenther Exp $	*/
a23 6
#ifdef YP
#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "ypinternal.h"
#endif
d34 8
@


1.30
log
@When fopen()ing internal to libc (the API doesn't support the use
of the resulting FILE *), then pass fopen() the 'e' mode letter to
mark it close-on-exec.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.29 2014/07/23 21:26:25 eric Exp $	*/
a20 1
#include <sys/socket.h>
@


1.29
log
@Make queries using the search list for hostname lookups fail with
NO_DATA/EAI_NODATA when the hostname param is an empty string.
So far, they were using the entries in the search list with no
additional component, which is not really expected.

reported by jsing@@ and a few others

ok deraadt@@, "makes sense" jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.28 2014/05/10 21:21:09 chl Exp $	*/
d412 1
a412 1
			f = fopen(as->as_ctx->ac_hostfile, "r");
@


1.28
log
@remove warning by adding explicit parentheses around && within ||

ok sperreault@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.27 2014/04/28 21:38:59 sperreault Exp $	*/
d160 6
@


1.27
log
@Implement AI_ADDRCONFIG

This is a getaddrinfo() flag that is defined thusly in RFC 3493:

   If the AI_ADDRCONFIG flag is specified, IPv4 addresses shall be
   returned only if an IPv4 address is configured on the local system,
   and IPv6 addresses shall be returned only if an IPv6 address is
   configured on the local system.  The loopback address is not
   considered for this case as valid as a configured address.

      For example, when using the DNS, a query for AAAA records should
      occur only if the node has at least one IPv6 address configured
      (other than IPv6 loopback) and a query for A records should occur
      only if the node has at least one IPv4 address configured (other
      than the IPv4 loopback).

The flag is set by default when hints is NULL.

ok Eric Faurot, Jason McIntyre
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.26 2014/03/26 18:13:15 eric Exp $	*/
d222 3
a224 3
			if (ai->ai_family == PF_UNSPEC && !v4 && !v6 ||
			    ai->ai_family == PF_INET && !v4 ||
			    ai->ai_family == PF_INET6 && !v6) {
@


1.26
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.25 2014/03/25 19:48:11 eric Exp $	*/
d24 1
d36 1
d109 1
d133 1
a133 1
	int		 i, family, r;
d135 1
d200 33
@


1.25
log
@Cleanup and simplify the API to be exposed.  Use better names for
structures, functions and defines.

discussed with and ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.24 2014/03/14 11:07:33 eric Exp $	*/
d19 1
d30 1
d32 1
a39 1
#include "asr.h"
@


1.24
log
@prefix structure names to avoid ambiguity and possible collisions when
the API gets public.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.23 2014/03/03 08:37:37 eric Exp $	*/
d46 1
a46 1
static int getaddrinfo_async_run(struct async *, struct async_res *);
d48 5
a52 5
static int iter_family(struct async *, int);
static int iter_domain(struct async *, const char *, char *, size_t);
static int addrinfo_add(struct async *, const struct sockaddr *, const char *);
static int addrinfo_from_file(struct async *, int,  FILE *);
static int addrinfo_from_pkt(struct async *, char *, size_t);
d54 1
a54 1
static int addrinfo_from_yp(struct async *, int, char *);
d79 1
a79 1
struct async *
d81 1
a81 1
	const struct addrinfo *hints, struct asr *asr)
d83 3
a85 3
	struct asr_ctx	*ac;
	struct async	*as;
	char		 alias[MAXDNAME];
d117 1
a117 1
getaddrinfo_async_run(struct async *as, struct async_res *ar)
d425 1
a425 1
		if ((r = asr_async_run(as->as.ai.subq, ar)) == ASYNC_COND)
d427 1
d516 1
a516 1
iter_family(struct async *as, int first)
d565 1
a565 1
iter_domain(struct async *as, const char *name, char * buf, size_t len)
d648 1
a648 1
addrinfo_add(struct async *as, const struct sockaddr *sa, const char *cname)
d710 1
a710 1
addrinfo_from_file(struct async *as, int family, FILE *f)
d747 1
a747 1
addrinfo_from_pkt(struct async *as, char *pkt, size_t pktlen)
d819 1
a819 1
addrinfo_from_yp(struct async *as, int family, char *line)
@


1.23
log
@fix support for HOSTALIASES.

reported by tedu@@
ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.22 2014/02/26 20:50:24 deraadt Exp $	*/
d748 5
a752 5
	struct unpack	 p;
	struct header	 h;
	struct query	 q;
	struct rr	 rr;
	int		 i;
@


1.22
log
@need more #include files for resolv.h, for the non-YP case, which happens
on the install media...
ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.21 2014/02/26 20:00:08 eric Exp $	*/
d85 1
d92 6
a97 2
	if (hostname && (as->as.ai.hostname = strdup(hostname)) == NULL)
		goto abort; /* errno set */
d123 1
a123 1
	char		 alias[MAXDNAME], *name;
d396 1
a396 4
			name = asr_hostalias(as->as_ctx, as->as.ai.hostname,
			    alias, sizeof(alias));
			if (name == NULL)
				name = as->as.ai.hostname;
d711 1
a711 1
	char		*tokens[MAXTOKEN], buf[MAXDNAME], *name, *c;
a718 4
	name = asr_hostalias(as->as_ctx, as->as.ai.hostname, buf, sizeof(buf));
	if (name == NULL)
		name = as->as.ai.hostname;

d725 1
a725 1
			if (strcasecmp(name, tokens[i]))
@


1.21
log
@Do not restrict chars in dname during label expansion, but validate resulting
hostnames before returning them to the caller.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.20 2014/02/17 11:04:23 eric Exp $	*/
d20 2
@


1.20
log
@Better search strategy for getaddrinfo.  The address family loop must
be done "inside" the search domain loop, not the other way round.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.19 2013/07/12 14:36:21 eric Exp $	*/
d30 1
a770 8
		if (as->as.ai.fqdn == NULL) {
			asr_strdname(q.q_dname, buf, sizeof buf);
			buf[strlen(buf) - 1] = '\0';
			as->as.ai.fqdn = strdup(buf);
			if (as->as.ai.fqdn == NULL)
				return (-1); /* errno set */
		}

d788 1
a788 1
			c = buf;
@


1.19
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.18 2013/06/01 14:34:34 eric Exp $	*/
d46 1
d70 6
d117 1
d293 24
a316 1
				async_set_state(as, ASR_STATE_NEXT_DB);
d319 6
d332 8
d342 5
a346 12
			if (as->as.ai.fqdn) {
				as->as.ai.subq = res_query_async_ctx(
				    as->as.ai.fqdn, C_IN,
				    (family == AF_INET6) ? T_AAAA : T_A,
				    as->as_ctx);
			}
			else {
				as->as.ai.subq = res_search_async_ctx(
				    as->as.ai.hostname, C_IN,
				    (family == AF_INET6) ? T_AAAA : T_A,
				    as->as_ctx);
			}
d525 109
@


1.18
log
@Make hostaliases work for gethostbyname() and getaddrinfo() when
looking into /etc/hosts.  Remove the alias check from the search
domain iteration. Instead, take a shortcut to res_query_async_ctx() in
res_search_async_ctx().
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.17 2013/04/30 12:02:39 eric Exp $	*/
d77 1
a77 1
	if ((as = async_new(ac, ASR_GETADDRINFO)) == NULL)
d96 1
a96 1
		async_free(as);
d225 1
a225 1
				sockaddr_from_str(&sa.sa, family, str);
d243 1
a243 1
			if (sockaddr_from_str(&sa.sa, family,
d382 1
a382 1
		if ((r = async_run(as->as.ai.subq, ar)) == ASYNC_COND)
d579 1
a579 1
			if (sockaddr_from_str(&u.sa, family, tokens[0]) == -1)
d612 2
a613 2
	unpack_init(&p, pkt, pktlen);
	unpack_header(&p, &h);
d615 1
a615 1
		unpack_query(&p, &q);
d618 1
a618 1
		unpack_rr(&p, &rr);
d697 1
a697 1
		if (sockaddr_from_str(&u.sa, family, tokens[0]) == -1)
@


1.17
log
@Do not take external buffers for storing DNS responses in the internal
async API.  That is actually useless and it makes the code more
complicated.  The required buffers are always allocated when needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.16 2013/04/30 06:53:07 eric Exp $	*/
d108 1
d349 6
d360 1
a360 2
			    as->as.ai.hostname, strlen(as->as.ai.hostname),
			    &res, &len);
d559 1
a559 1
	char		*tokens[MAXTOKEN], *c;
d567 4
d577 1
a577 1
			if (strcasecmp(as->as.ai.hostname, tokens[i]))
@


1.16
log
@copy input flags in result addrinfo structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.15 2013/04/08 08:24:56 chrisz Exp $	*/
d299 1
a299 1
				    (family == AF_INET6) ? T_AAAA : T_A, NULL, 0,
d305 1
a305 1
				    (family == AF_INET6) ? T_AAAA : T_A, NULL, 0,
@


1.15
log
@Comply with rfc2553. lib/libc/net/getaddrinfo.c already has this right.
This fixes hostname resolution for OpenVPN 2.3.1.

ok eric@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.14 2013/04/01 15:49:54 deraadt Exp $	*/
d521 1
@


1.14
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.13 2013/03/30 20:11:19 eric Exp $	*/
d256 1
a256 1
			ar->ar_gai_errno = EAI_FAIL;
@


1.13
log
@allow "0" as service name for raw sockets.

ok sthen@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.12 2013/03/28 11:47:23 eric Exp $	*/
d436 1
a436 1
	const char*		e;
d522 1
a522 1
		ai->ai_addr = (void*)(ai + 1);
@


1.12
log
@accept and use any protocol specified by the caller.

issue spotted by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.11 2013/03/27 07:40:41 eric Exp $	*/
d173 1
a173 1
		    as->as.ai.servname != NULL) {
@


1.11
log
@Only use the search domains for DNS lookups, as the current resolver does.
Better not diverge too much in behavior at this point.
Typo fix and doc update while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.10 2012/11/24 15:12:48 eric Exp $	*/
d64 1
a64 1
#define MATCH_PROTO(a, b) ((a) == matches[(b)].protocol || (a) == 0)
a171 8
		if (ai->ai_protocol &&
		    ai->ai_protocol != IPPROTO_UDP  &&
		    ai->ai_protocol != IPPROTO_TCP) {
			ar->ar_gai_errno = EAI_PROTOCOL;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

d492 1
a492 1
	int			 i, port;
d500 5
a504 1
		if (matches[i].protocol == IPPROTO_TCP)
d506 1
a506 1
		else if (matches[i].protocol == IPPROTO_UDP)
d520 1
a520 1
		ai->ai_protocol = matches[i].protocol;
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.9 2012/11/24 13:59:53 eric Exp $	*/
a111 1
	char		 fqdn[MAXDNAME];
a268 23
		/* start domain lookup */
		async_set_state(as, ASR_STATE_NEXT_DOMAIN);
		break;

	case ASR_STATE_NEXT_DOMAIN:
		r = asr_iter_domain(as, as->as.ai.hostname, fqdn, sizeof(fqdn));
		if (r == -1) {
			async_set_state(as, ASR_STATE_NOT_FOUND);
			break;
		}
		if (r > (int)sizeof(fqdn)) {
			ar->ar_gai_errno = EAI_OVERFLOW;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}
		if (as->as.ai.fqdn)
			free(as->as.ai.fqdn);
		if ((as->as.ai.fqdn = strdup(fqdn)) == NULL) {
			ar->ar_gai_errno = EAI_MEMORY;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}
		as->as_db_idx = 0;
d274 1
a274 1
			async_set_state(as, ASR_STATE_NEXT_DOMAIN);
d299 1
a299 1
		/* query the current DB again. */
d304 12
a315 3
			as->as.ai.subq = res_query_async_ctx(as->as.ai.fqdn,
			    C_IN, (family == AF_INET6) ? T_AAAA : T_A, NULL, 0,
			    as->as_ctx);
d389 1
a389 1
			async_set_state(as, ASR_STATE_NEXT_DB);
d570 1
a570 1
			if (strcasecmp(as->as.ai.fqdn, tokens[i]))
d579 1
a579 1
		if (as->as.ai.hints.ai_flags & AI_CANONNAME)
a580 2
		else if (as->as.ai.hints.ai_flags & AI_FQDN)
			c = as->as.ai.fqdn;
d616 8
d693 1
a693 1
		if (as->as.ai.hints.ai_flags & AI_CANONNAME)
a694 2
		else if (as->as.ai.hints.ai_flags & AI_FQDN)
			c = as->as.ai.fqdn;
@


1.9
log
@make separate structures for pack and unpack
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.8 2012/09/06 15:05:16 eric Exp $	*/
d17 1
a19 1

a20 6
        
#include <err.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
d28 6
d60 1
a60 1
	{ -1, 		0, 		0, 		},
d121 1
a121 1
	switch(as->as_state) {
d219 1
a219 1
			for(family = iter_family(as, 1);
d247 1
a247 1
		for(family = iter_family(as, 1);
d252 1
a252 1
					      as->as.ai.hostname) == -1)
d255 1
a255 1
			if ((r = addrinfo_add(as, &sa.sa, NULL))) {
a256 1
			}
d324 1
a324 1
		switch(AS_DB(as)) {
d444 1
a444 1
                break;
d517 1
a517 1
	for(i = 0; matches[i].family != -1; i++) {
d579 1
a579 1
	for(;;) {
d624 1
a624 1
	for(; h.qdcount; h.qdcount--)
d642 1
a642 1
 			u.sain6.sin6_addr = rr.rr.in_aaaa.addr6;
d669 1
a669 1
	for(cp = line, tp = tokens, ntok = 0;
d690 1
a690 1
	for(next = line; line; line = next) {
@


1.8
log
@include yp headers if necessary.
remove unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.7 2012/09/05 21:49:12 eric Exp $	*/
d611 1
a611 1
	struct packed	 p;
d623 1
a623 1
	packed_init(&p, pkt, pktlen);
@


1.7
log
@Get rid of the hostaddr_async subquery and merge its behaviour
directly into getaddrinfo_async_run.  Simplifies everything by
a great deal.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.6 2012/09/05 15:56:13 eric Exp $	*/
d27 6
d684 1
a684 1
	int		 i, ntok;
@


1.6
log
@Make hostaddr_async() return a linked list of struct addrinfo.  First
round of a getaddrinfo_async() simplification. The goal is to make YP
support easier to add, and eventually remove the whole hostaddr_async
subquery.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.5 2012/08/18 11:19:51 eric Exp $	*/
d40 6
a45 1
static int add_sockaddr(struct async *, struct sockaddr *, const char *);
d98 5
d107 1
d228 1
a228 1
				if ((r = add_sockaddr(as, &sa.sa, NULL))) {
d249 1
a249 1
			if ((r = add_sockaddr(as, &sa.sa, NULL))) {
d265 2
a266 2
		/* Starting domain lookup */
		async_set_state(as, ASR_STATE_SEARCH_DOMAIN);
d269 1
a269 2
	case ASR_STATE_SEARCH_DOMAIN:

d280 10
d291 21
a311 19
		/*
		 * Create a subquery to lookup the host addresses.
		 * We use the special hostaddr_async() API, which has the
		 * nice property of honoring the "lookup" and "family" keyword
		 * in the configuration, thus returning the right address
		 * families in the right order, and thus fixing the current
		 * getaddrinfo() feature documented in the BUGS section of
		 * resolver.conf(5).
		 */
		as->as.ai.subq = hostaddr_async_ctx(fqdn,
		    as->as.ai.hints.ai_family, as->as.ai.hints.ai_flags,
		    as->as_ctx);
		if (as->as.ai.subq == NULL) {
			if (errno == EINVAL) {
				ar->ar_gai_errno = EAI_FAIL;
			} else {
				ar->ar_gai_errno = EAI_MEMORY;
			}
			async_set_state(as, ASR_STATE_HALT);
d314 1
a314 1
		async_set_state(as, ASR_STATE_LOOKUP_DOMAIN);
d317 19
a335 1
	case ASR_STATE_LOOKUP_DOMAIN:
d337 8
a344 3
		/* Run the subquery */
		if ((r = async_run(as->as.ai.subq, ar)) == ASYNC_COND)
			return (ASYNC_COND);
d346 22
a367 10
		/*
		 * The subquery is done. Stop there if we have at least one
		 * answer.
		 */
		as->as.ai.subq = NULL;
		if (ar->ar_count == 0) {
			/*
			 * No anwser for this domain, but we might be suggested
			 * to try again later, so remember this.  Then search
			 * the next domain.
d369 17
a385 3
			if (ar->ar_gai_errno == EAI_AGAIN)
				as->as.ai.flags |= ASYNC_AGAIN;
			async_set_state(as, ASR_STATE_SEARCH_DOMAIN);
d387 3
d391 1
d393 4
a396 1
		/* iterate over and expand results */
d398 3
a400 4
		for(ai = ar->ar_addrinfo; ai; ai = ai->ai_next) {
			r = add_sockaddr(as, ai->ai_addr, ai->ai_canonname);
			if (r)
				break;
d402 11
a412 3
		freeaddrinfo(ar->ar_addrinfo);
		ar->ar_gai_errno = r;
		async_set_state(as, ASR_STATE_HALT);
d416 2
a417 5

		/*
		 * No result found. Maybe we can try again.
		 */
		if (as->as.ai.flags & ASYNC_AGAIN) {
d419 1
a419 1
		} else {
a420 1
		}
a424 3

		/* Set the results. */

d507 1
a507 1
add_sockaddr(struct async *as, struct sockaddr *sa, const char *cname)
d562 148
@


1.5
log
@Improve error reporting in getnameinfo_async() and getaddrinfo_async().
They do not have to deal with h_errno at all.  Also, errno is only kept
for EAI_SYSTEM.  Small code cleanup while there.

Adapt getnameinfo() and getaddrinfo() wrappers to correctly save errno
and overwrite it in the EAI_SYSTEM case.

General errno handling issue reported by mikeb@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.4 2012/07/13 14:05:12 eric Exp $	*/
a300 12
		/* Got one more address, use it to extend the result list. */
		if (r == ASYNC_YIELD) {
			if ((r = add_sockaddr(as, &ar->ar_sa.sa,
			    ar->ar_cname))) {
				ar->ar_gai_errno = r;
				async_set_state(as, ASR_STATE_HALT);
			}
			if (ar->ar_cname)
				free(ar->ar_cname);
			break;
		}

d306 9
a314 2
		if (ar->ar_count) {
			async_set_state(as, ASR_STATE_HALT);
d318 10
a327 8
		/*
		 * No anwser for this domain, but we might be suggested to
		 * try again later, so remember this. Then search the next
		 * domain.
		 */
		if (ar->ar_gai_errno == EAI_AGAIN)
			as->as.ai.flags |= ASYNC_AGAIN;
		async_set_state(as, ASR_STATE_SEARCH_DOMAIN);
@


1.4
log
@properly report EAI_SERVICE when the given servname is not defined for
the given protocol.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.3 2012/07/10 09:20:51 eric Exp $	*/
a112 4
		async_set_state(as, ASR_STATE_HALT);
		ar->ar_errno = 0;
		ar->ar_h_errno = NETDB_SUCCESS;
		ar->ar_gai_errno = 0;
a115 1
			ar->ar_h_errno = NO_RECOVERY;
d117 1
a126 1
			ar->ar_h_errno = NO_RECOVERY;
d128 1
a133 1
			ar->ar_h_errno = NO_RECOVERY;
d135 1
a141 1
			ar->ar_h_errno = NO_RECOVERY;
d143 1
a150 1
			ar->ar_h_errno = NO_RECOVERY;
d152 1
a158 1
			ar->ar_h_errno = NO_RECOVERY;
d160 1
a165 1
			ar->ar_h_errno = NO_RECOVERY;
d167 1
a177 1
			ar->ar_h_errno = NO_RECOVERY;
d179 1
a192 1
			ar->ar_h_errno = NO_RECOVERY;
d194 1
d198 2
a217 2
					ar->ar_errno = errno;
					ar->ar_h_errno = NETDB_INTERNAL;
a218 1
					async_set_state(as, ASR_STATE_HALT);
a222 1
				ar->ar_h_errno = NO_DATA;
d225 1
a238 2
				ar->ar_errno = errno;
				ar->ar_h_errno = NETDB_INTERNAL;
a239 2
				async_set_state(as, ASR_STATE_HALT);
				break;
d241 3
a243 1

a246 2
		if (ar->ar_gai_errno || as->as_count)
			break;
a248 1
			ar->ar_h_errno = NO_RECOVERY;
a265 2
			ar->ar_errno = EINVAL;
			ar->ar_h_errno = NO_RECOVERY;
a283 1
			ar->ar_errno = errno;
a284 1
				ar->ar_h_errno = NO_RECOVERY;
a286 1
				ar->ar_h_errno = NETDB_INTERNAL;
a304 2
				ar->ar_errno = errno;
				ar->ar_h_errno = NETDB_INTERNAL;
a337 1
		ar->ar_errno = 0;
a338 1
			ar->ar_h_errno = TRY_AGAIN;
a340 1
			ar->ar_h_errno = NO_DATA;
a361 1
		ar->ar_h_errno = NETDB_INTERNAL;
@


1.3
log
@Better handling of servname in getaddrinfo_async. Do not necessarily
fail if there is no entry for a given protocol. Fix issue reported by
early testers.
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.2 2012/04/25 20:28:25 eric Exp $	*/
d194 3
a196 1
		    (as->as.ai.port_tcp == -1 && as->as.ai.port_udp == -1)) {
@


1.2
log
@fix a few warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: getaddrinfo_async.c,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
d187 11
a197 10
		if (as->as.ai.servname) {
			as->as.ai.port_udp = get_port(as->as.ai.servname,
			    "udp", as->as.ai.hints.ai_flags & AI_NUMERICSERV);
			as->as.ai.port_tcp = get_port(as->as.ai.servname,
			    "tcp", as->as.ai.hints.ai_flags & AI_NUMERICSERV);
			if (as->as.ai.port_tcp < 0 || as->as.ai.port_udp < 0) {
				ar->ar_h_errno = NO_RECOVERY;
				ar->ar_gai_errno = EAI_SERVICE;
				break;
			}
d468 4
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.10 2011/07/13 16:14:43 eric Exp $	*/
d272 1
a272 1
		if (r > sizeof(fqdn)) {
@

