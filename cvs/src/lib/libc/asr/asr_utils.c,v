head	1.18;
access;
symbols
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.3.0.2
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.1.0.2
	OPENBSD_5_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2017.09.23.20.55.06;	author jca;	state Exp;
branches;
next	1.17;
commitid	RrlcSgvK3WRelv6V;

1.17
date	2017.02.27.11.38.08;	author jca;	state Exp;
branches;
next	1.16;
commitid	drUqtHQk8flZF7Hy;

1.16
date	2017.02.19.12.02.30;	author jca;	state Exp;
branches;
next	1.15;
commitid	0wKaOIDZpWcMdE61;

1.15
date	2017.02.18.19.23.05;	author jca;	state Exp;
branches;
next	1.14;
commitid	6EwZbn7a3sVTI0GZ;

1.14
date	2017.02.17.22.24.45;	author eric;	state Exp;
branches;
next	1.13;
commitid	k26K9OiIpUIb57jZ;

1.13
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	ZDWhDXAAMFWxMzBj;

1.12
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2014.03.14.11.07.33;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2014.02.26.20.00.08;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.24.23.51.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.12.14.36.21;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2013.04.14.22.23.08;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2013.04.02.21.23.17;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.01.15.49.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.29.23.01.24;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.11.24.13.59.53;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Kill unused function

Spotted by krw@@
@
text
@/*	$OpenBSD: asr_utils.c,v 1.17 2017/02/27 11:38:08 jca Exp $	*/
/*
 * Copyright (c) 2009-2012	Eric Faurot	<eric@@faurot.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>

#include <asr.h>
#include <ctype.h>
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "asr_private.h"

static int dname_check_label(const char *, size_t);
static ssize_t dname_expand(const unsigned char *, size_t, size_t, size_t *,
    char *, size_t);

static int unpack_data(struct asr_unpack *, void *, size_t);
static int unpack_u16(struct asr_unpack *, uint16_t *);
static int unpack_u32(struct asr_unpack *, uint32_t *);
static int unpack_inaddr(struct asr_unpack *, struct in_addr *);
static int unpack_in6addr(struct asr_unpack *, struct in6_addr *);
static int unpack_dname(struct asr_unpack *, char *, size_t);

static int pack_data(struct asr_pack *, const void *, size_t);
static int pack_u16(struct asr_pack *, uint16_t);
static int pack_dname(struct asr_pack *, const char *);

static int
dname_check_label(const char *s, size_t l)
{
	if (l == 0 || l > 63)
		return (-1);

	return (0);
}

ssize_t
_asr_dname_from_fqdn(const char *str, char *dst, size_t max)
{
	ssize_t	 res;
	size_t	 l, n;
	char	*d;

	res = 0;

	/* special case: the root domain */
	if (str[0] == '.') {
		if (str[1] != '\0')
			return (-1);
		if (dst && max >= 1)
			*dst = '\0';
		return (1);
	}

	for (; *str; str = d + 1) {

		d = strchr(str, '.');
		if (d == NULL || d == str)
			return (-1);

		l = (d - str);

		if (dname_check_label(str, l) == -1)
			return (-1);

		res += l + 1;

		if (dst) {
			*dst++ = l;
			max -= 1;
			n = (l > max) ? max : l;
			memmove(dst, str, n);
			max -= n;
			if (max == 0)
				dst = NULL;
			else
				dst += n;
		}
	}

	if (dst)
		*dst++ = '\0';

	return (res + 1);
}

static ssize_t
dname_expand(const unsigned char *data, size_t len, size_t offset,
    size_t *newoffset, char *dst, size_t max)
{
	size_t		 n, count, end, ptr, start;
	ssize_t		 res;

	if (offset >= len)
		return (-1);

	res = 0;
	end = start = offset;

	for (; (n = data[offset]); ) {
		if ((n & 0xc0) == 0xc0) {
			if (offset + 2 > len)
				return (-1);
			ptr = 256 * (n & ~0xc0) + data[offset + 1];
			if (ptr >= start)
				return (-1);
			if (end < offset + 2)
				end = offset + 2;
			offset = start = ptr;
			continue;
		}
		if (offset + n + 1 > len)
			return (-1);

		if (dname_check_label(data + offset + 1, n) == -1)
			return (-1);

		/* copy n + at offset+1 */
		if (dst != NULL && max != 0) {
			count = (max < n + 1) ? (max) : (n + 1);
			memmove(dst, data + offset, count);
			dst += count;
			max -= count;
		}
		res += n + 1;
		offset += n + 1;
		if (end < offset)
			end = offset;
	}
	if (end < offset + 1)
		end = offset + 1;

	if (dst != NULL && max != 0)
		dst[0] = 0;
	if (newoffset)
		*newoffset = end;
	return (res + 1);
}

void
_asr_pack_init(struct asr_pack *pack, char *buf, size_t len)
{
	pack->buf = buf;
	pack->len = len;
	pack->offset = 0;
	pack->err = 0;
}

void
_asr_unpack_init(struct asr_unpack *unpack, const char *buf, size_t len)
{
	unpack->buf = buf;
	unpack->len = len;
	unpack->offset = 0;
	unpack->err = 0;
}

static int
unpack_data(struct asr_unpack *p, void *data, size_t len)
{
	if (p->err)
		return (-1);

	if (p->len - p->offset < len) {
		p->err = EOVERFLOW;
		return (-1);
	}

	memmove(data, p->buf + p->offset, len);
	p->offset += len;

	return (0);
}

static int
unpack_u16(struct asr_unpack *p, uint16_t *u16)
{
	if (unpack_data(p, u16, 2) == -1)
		return (-1);

	*u16 = ntohs(*u16);

	return (0);
}

static int
unpack_u32(struct asr_unpack *p, uint32_t *u32)
{
	if (unpack_data(p, u32, 4) == -1)
		return (-1);

	*u32 = ntohl(*u32);

	return (0);
}

static int
unpack_inaddr(struct asr_unpack *p, struct in_addr *a)
{
	return (unpack_data(p, a, 4));
}

static int
unpack_in6addr(struct asr_unpack *p, struct in6_addr *a6)
{
	return (unpack_data(p, a6, 16));
}

static int
unpack_dname(struct asr_unpack *p, char *dst, size_t max)
{
	ssize_t e;

	if (p->err)
		return (-1);

	e = dname_expand(p->buf, p->len, p->offset, &p->offset, dst, max);
	if (e == -1) {
		p->err = EINVAL;
		return (-1);
	}
	if (e < 0 || e > MAXDNAME) {
		p->err = ERANGE;
		return (-1);
	}

	return (0);
}

int
_asr_unpack_header(struct asr_unpack *p, struct asr_dns_header *h)
{
	if (unpack_data(p, h, HFIXEDSZ) == -1)
		return (-1);

	h->flags = ntohs(h->flags);
	h->qdcount = ntohs(h->qdcount);
	h->ancount = ntohs(h->ancount);
	h->nscount = ntohs(h->nscount);
	h->arcount = ntohs(h->arcount);

	return (0);
}

int
_asr_unpack_query(struct asr_unpack *p, struct asr_dns_query *q)
{
	unpack_dname(p, q->q_dname, sizeof(q->q_dname));
	unpack_u16(p, &q->q_type);
	unpack_u16(p, &q->q_class);

	return (p->err) ? (-1) : (0);
}

int
_asr_unpack_rr(struct asr_unpack *p, struct asr_dns_rr *rr)
{
	uint16_t	rdlen;
	size_t		save_offset;

	unpack_dname(p, rr->rr_dname, sizeof(rr->rr_dname));
	unpack_u16(p, &rr->rr_type);
	unpack_u16(p, &rr->rr_class);
	unpack_u32(p, &rr->rr_ttl);
	unpack_u16(p, &rdlen);

	if (p->err)
		return (-1);

	if (p->len - p->offset < rdlen) {
		p->err = EOVERFLOW;
		return (-1);
	}

	save_offset = p->offset;

	switch (rr->rr_type) {

	case T_CNAME:
		unpack_dname(p, rr->rr.cname.cname, sizeof(rr->rr.cname.cname));
		break;

	case T_MX:
		unpack_u16(p, &rr->rr.mx.preference);
		unpack_dname(p, rr->rr.mx.exchange, sizeof(rr->rr.mx.exchange));
		break;

	case T_NS:
		unpack_dname(p, rr->rr.ns.nsname, sizeof(rr->rr.ns.nsname));
		break;

	case T_PTR:
		unpack_dname(p, rr->rr.ptr.ptrname, sizeof(rr->rr.ptr.ptrname));
		break;

	case T_SOA:
		unpack_dname(p, rr->rr.soa.mname, sizeof(rr->rr.soa.mname));
		unpack_dname(p, rr->rr.soa.rname, sizeof(rr->rr.soa.rname));
		unpack_u32(p, &rr->rr.soa.serial);
		unpack_u32(p, &rr->rr.soa.refresh);
		unpack_u32(p, &rr->rr.soa.retry);
		unpack_u32(p, &rr->rr.soa.expire);
		unpack_u32(p, &rr->rr.soa.minimum);
		break;

	case T_A:
		if (rr->rr_class != C_IN)
			goto other;
		unpack_inaddr(p, &rr->rr.in_a.addr);
		break;

	case T_AAAA:
		if (rr->rr_class != C_IN)
			goto other;
		unpack_in6addr(p, &rr->rr.in_aaaa.addr6);
		break;
	default:
	other:
		rr->rr.other.rdata = p->buf + p->offset;
		rr->rr.other.rdlen = rdlen;
		p->offset += rdlen;
	}

	if (p->err)
		return (-1);

	/* make sure that the advertised rdlen is really ok */
	if (p->offset - save_offset != rdlen)
		p->err = EINVAL;

	return (p->err) ? (-1) : (0);
}

static int
pack_data(struct asr_pack *p, const void *data, size_t len)
{
	if (p->err)
		return (-1);

	if (p->len < p->offset + len) {
		p->err = EOVERFLOW;
		return (-1);
	}

	memmove(p->buf + p->offset, data, len);
	p->offset += len;

	return (0);
}

static int
pack_u16(struct asr_pack *p, uint16_t v)
{
	v = htons(v);

	return (pack_data(p, &v, 2));
}

static int
pack_dname(struct asr_pack *p, const char *dname)
{
	/* dname compression would be nice to have here.
	 * need additionnal context.
	 */
	return (pack_data(p, dname, strlen(dname) + 1));
}

int
_asr_pack_header(struct asr_pack *p, const struct asr_dns_header *h)
{
	struct asr_dns_header c;

	c.id = h->id;
	c.flags = htons(h->flags);
	c.qdcount = htons(h->qdcount);
	c.ancount = htons(h->ancount);
	c.nscount = htons(h->nscount);
	c.arcount = htons(h->arcount);

	return (pack_data(p, &c, HFIXEDSZ));
}

int
_asr_pack_query(struct asr_pack *p, uint16_t type, uint16_t class, const char *dname)
{
	pack_dname(p, dname);
	pack_u16(p, type);
	pack_u16(p, class);

	return (p->err) ? (-1) : (0);
}

int
_asr_pack_edns0(struct asr_pack *p, uint16_t pktsz, int dnssec_do)
{
	DPRINT("asr EDNS0 pktsz:%hu dnssec:%s\n", pktsz,
	    dnssec_do ? "yes" : "no");

	pack_dname(p, "");	/* root */
	pack_u16(p, T_OPT);	/* OPT */
	pack_u16(p, pktsz);	/* UDP payload size */

	/* extended RCODE and flags */
	pack_u16(p, 0);
	pack_u16(p, dnssec_do ? DNS_MESSAGEEXTFLAG_DO : 0);

	pack_u16(p, 0);		/* RDATA len */

	return (p->err) ? (-1) : (0);
}

int
_asr_sockaddr_from_str(struct sockaddr *sa, int family, const char *str)
{
	struct in_addr		 ina;
	struct in6_addr		 in6a;
	struct sockaddr_in	*sin;
	struct sockaddr_in6	*sin6;
	char			*cp, *str2;
	const char		*errstr;

	switch (family) {
	case PF_UNSPEC:
		if (_asr_sockaddr_from_str(sa, PF_INET, str) == 0)
			return (0);
		return _asr_sockaddr_from_str(sa, PF_INET6, str);

	case PF_INET:
		if (inet_pton(PF_INET, str, &ina) != 1)
			return (-1);

		sin = (struct sockaddr_in *)sa;
		memset(sin, 0, sizeof *sin);
		sin->sin_len = sizeof(struct sockaddr_in);
		sin->sin_family = PF_INET;
		sin->sin_addr.s_addr = ina.s_addr;
		return (0);

	case PF_INET6:
		cp = strchr(str, SCOPE_DELIMITER);
		if (cp) {
			str2 = strdup(str);
			if (str2 == NULL)
				return (-1);
			str2[cp - str] = '\0';
			if (inet_pton(PF_INET6, str2, &in6a) != 1) {
				free(str2);
				return (-1);
			}
			cp++;
			free(str2);
		} else if (inet_pton(PF_INET6, str, &in6a) != 1)
			return (-1);

		sin6 = (struct sockaddr_in6 *)sa;
		memset(sin6, 0, sizeof *sin6);
		sin6->sin6_len = sizeof(struct sockaddr_in6);
		sin6->sin6_family = PF_INET6;
		sin6->sin6_addr = in6a;

		if (cp == NULL)
			return (0);

		if (IN6_IS_ADDR_LINKLOCAL(&in6a) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&in6a) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(&in6a))
			if ((sin6->sin6_scope_id = if_nametoindex(cp)))
				return (0);

		sin6->sin6_scope_id = strtonum(cp, 0, UINT32_MAX, &errstr);
		if (errstr)
			return (-1);
		return (0);

	default:
		break;
	}

	return (-1);
}

ssize_t
_asr_addr_as_fqdn(const char *addr, int family, char *dst, size_t max)
{
	const struct in6_addr	*in6_addr;
	in_addr_t		 in_addr;

	switch (family) {
	case AF_INET:
		in_addr = ntohl(*((const in_addr_t *)addr));
		snprintf(dst, max,
		    "%d.%d.%d.%d.in-addr.arpa.",
		    in_addr & 0xff,
		    (in_addr >> 8) & 0xff,
		    (in_addr >> 16) & 0xff,
		    (in_addr >> 24) & 0xff);
		break;
	case AF_INET6:
		in6_addr = (const struct in6_addr *)addr;
		snprintf(dst, max,
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "ip6.arpa.",
		    in6_addr->s6_addr[15] & 0xf,
		    (in6_addr->s6_addr[15] >> 4) & 0xf,
		    in6_addr->s6_addr[14] & 0xf,
		    (in6_addr->s6_addr[14] >> 4) & 0xf,
		    in6_addr->s6_addr[13] & 0xf,
		    (in6_addr->s6_addr[13] >> 4) & 0xf,
		    in6_addr->s6_addr[12] & 0xf,
		    (in6_addr->s6_addr[12] >> 4) & 0xf,
		    in6_addr->s6_addr[11] & 0xf,
		    (in6_addr->s6_addr[11] >> 4) & 0xf,
		    in6_addr->s6_addr[10] & 0xf,
		    (in6_addr->s6_addr[10] >> 4) & 0xf,
		    in6_addr->s6_addr[9] & 0xf,
		    (in6_addr->s6_addr[9] >> 4) & 0xf,
		    in6_addr->s6_addr[8] & 0xf,
		    (in6_addr->s6_addr[8] >> 4) & 0xf,
		    in6_addr->s6_addr[7] & 0xf,
		    (in6_addr->s6_addr[7] >> 4) & 0xf,
		    in6_addr->s6_addr[6] & 0xf,
		    (in6_addr->s6_addr[6] >> 4) & 0xf,
		    in6_addr->s6_addr[5] & 0xf,
		    (in6_addr->s6_addr[5] >> 4) & 0xf,
		    in6_addr->s6_addr[4] & 0xf,
		    (in6_addr->s6_addr[4] >> 4) & 0xf,
		    in6_addr->s6_addr[3] & 0xf,
		    (in6_addr->s6_addr[3] >> 4) & 0xf,
		    in6_addr->s6_addr[2] & 0xf,
		    (in6_addr->s6_addr[2] >> 4) & 0xf,
		    in6_addr->s6_addr[1] & 0xf,
		    (in6_addr->s6_addr[1] >> 4) & 0xf,
		    in6_addr->s6_addr[0] & 0xf,
		    (in6_addr->s6_addr[0] >> 4) & 0xf);
		break;
	default:
		return (-1);
	}
	return (0);
}
@


1.17
log
@Add support for RES_USE_DNSSEC

RES_USE_DNSSEC is implemented by setting the DNSSEC DO bit in outgoing
queries.  The resolver is then supposed to set the AD bit in the reply
if it managed to validate the answer through DNSSEC.  Useful when the
application doesn't implement validation internally.  This scheme
assumes that the validating resolver is trusted and that the
communication channel between the validating resolver and and the client
is secure.

ok eric@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.16 2017/02/19 12:02:30 jca Exp $	*/
a380 8
}

static int
pack_u32(struct asr_pack *p, uint32_t v)
{
	v = htonl(v);

	return (pack_data(p, &v, 4));
@


1.16
log
@Use T_OPT instead of literal "41".

Requested earlier by eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.15 2017/02/18 19:23:05 jca Exp $	*/
d426 1
a426 1
_asr_pack_edns0(struct asr_pack *p, uint16_t pktsz)
d428 3
d434 5
a438 1
	pack_u32(p, 0);		/* extended RCODE and flags */
@


1.15
log
@Add EDNS0 support.

EDNS allows for various DNS extensions, among which UDP DNS packets size
bigger than 512 bytes.  The default is still to not advertize anything.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.14 2017/02/17 22:24:45 eric Exp $	*/
d429 1
a429 1
	pack_u16(p, 41);	/* OPT */
@


1.14
log
@use common errnos instead of random strings as error indicators in
pack/unpack contexts.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.13 2015/09/09 15:49:34 deraadt Exp $	*/
d384 8
d421 12
@


1.13
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.12 2014/03/26 18:13:15 eric Exp $	*/
d170 1
a170 1
	pack->err = NULL;
d179 1
a179 1
	unpack->err = NULL;
d189 1
a189 1
		p->err = "too short";
d243 1
a243 1
		p->err = "bad domain name";
d247 1
a247 1
		p->err = "domain name too long";
d295 1
a295 1
		p->err = "too short";
d353 1
a353 1
		p->err = "bad dlen";
d365 1
a365 1
		p->err = "no space";
@


1.12
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.11 2014/03/14 11:07:33 eric Exp $	*/
d62 1
a62 1
asr_dname_from_fqdn(const char *str, char *dst, size_t max)
d165 1
a165 1
asr_pack_init(struct asr_pack *pack, char *buf, size_t len)
d174 1
a174 1
asr_unpack_init(struct asr_unpack *unpack, const char *buf, size_t len)
d255 1
a255 1
asr_unpack_header(struct asr_unpack *p, struct asr_dns_header *h)
d270 1
a270 1
asr_unpack_query(struct asr_unpack *p, struct asr_dns_query *q)
d280 1
a280 1
asr_unpack_rr(struct asr_unpack *p, struct asr_dns_rr *rr)
d393 1
a393 1
asr_pack_header(struct asr_pack *p, const struct asr_dns_header *h)
d408 1
a408 1
asr_pack_query(struct asr_pack *p, uint16_t type, uint16_t class, const char *dname)
d418 1
a418 1
asr_sockaddr_from_str(struct sockaddr *sa, int family, const char *str)
d429 1
a429 1
		if (asr_sockaddr_from_str(sa, PF_INET, str) == 0)
d431 1
a431 1
		return asr_sockaddr_from_str(sa, PF_INET6, str);
d488 1
a488 1
asr_addr_as_fqdn(const char *addr, int family, char *dst, size_t max)
@


1.11
log
@prefix structure names to avoid ambiguity and possible collisions when
the API gets public.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.10 2014/02/26 20:00:08 eric Exp $	*/
d24 1
d26 1
a34 1
#include "asr.h"
@


1.10
log
@Do not restrict chars in dname during label expansion, but validate resulting
hostnames before returning them to the caller.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.9 2013/11/24 23:51:29 deraadt Exp $	*/
d40 10
a49 10
static int unpack_data(struct unpack *, void *, size_t);
static int unpack_u16(struct unpack *, uint16_t *);
static int unpack_u32(struct unpack *, uint32_t *);
static int unpack_inaddr(struct unpack *, struct in_addr *);
static int unpack_in6addr(struct unpack *, struct in6_addr *);
static int unpack_dname(struct unpack *, char *, size_t);

static int pack_data(struct pack *, const void *, size_t);
static int pack_u16(struct pack *, uint16_t);
static int pack_dname(struct pack *, const char *);
d164 1
a164 1
asr_pack_init(struct pack *pack, char *buf, size_t len)
d173 1
a173 1
asr_unpack_init(struct unpack *unpack, const char *buf, size_t len)
d182 1
a182 1
unpack_data(struct unpack *p, void *data, size_t len)
d199 1
a199 1
unpack_u16(struct unpack *p, uint16_t *u16)
d210 1
a210 1
unpack_u32(struct unpack *p, uint32_t *u32)
d221 1
a221 1
unpack_inaddr(struct unpack *p, struct in_addr *a)
d227 1
a227 1
unpack_in6addr(struct unpack *p, struct in6_addr *a6)
d233 1
a233 1
unpack_dname(struct unpack *p, char *dst, size_t max)
d254 1
a254 1
asr_unpack_header(struct unpack *p, struct header *h)
d269 1
a269 1
asr_unpack_query(struct unpack *p, struct query *q)
d279 1
a279 1
asr_unpack_rr(struct unpack *p, struct rr *rr)
d358 1
a358 1
pack_data(struct pack *p, const void *data, size_t len)
d375 1
a375 1
pack_u16(struct pack *p, uint16_t v)
d383 1
a383 1
pack_dname(struct pack *p, const char *dname)
d392 1
a392 1
asr_pack_header(struct pack *p, const struct header *h)
d394 1
a394 1
	struct header c;
d407 1
a407 1
asr_pack_query(struct pack *p, uint16_t type, uint16_t class, const char *dname)
@


1.9
log
@most obvious unsigned char casts for ctype
ok jca krw ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.8 2013/07/12 14:36:21 eric Exp $	*/
a55 4

	for (l--; l; l--, s++)
		if (!(isalnum((unsigned char)*s) || *s == '_' || *s == '-'))
			return (-1);
@


1.8
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.7 2013/04/14 22:23:08 deraadt Exp $	*/
d58 1
a58 1
		if (!(isalnum(*s) || *s == '_' || *s == '-'))
@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.6 2013/04/02 21:23:17 eric Exp $	*/
d65 1
a65 1
dname_from_fqdn(const char *str, char *dst, size_t max)
d168 1
a168 1
pack_init(struct pack *pack, char *buf, size_t len)
d177 1
a177 1
unpack_init(struct unpack *unpack, const char *buf, size_t len)
d258 1
a258 1
unpack_header(struct unpack *p, struct header *h)
d273 1
a273 1
unpack_query(struct unpack *p, struct query *q)
d283 1
a283 1
unpack_rr(struct unpack *p, struct rr *rr)
d396 1
a396 1
pack_header(struct pack *p, const struct header *h)
d411 1
a411 1
pack_query(struct pack *p, uint16_t type, uint16_t class, const char *dname)
d421 1
a421 1
sockaddr_from_str(struct sockaddr *sa, int family, const char *str)
d432 1
a432 1
		if (sockaddr_from_str(sa, PF_INET, str) == 0)
d434 1
a434 1
		return sockaddr_from_str(sa, PF_INET6, str);
d488 61
@


1.6
log
@make sure we always point before the current offset.

spotted by matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.5 2013/04/01 15:49:54 deraadt Exp $	*/
d427 1
a427 1
	char 			*cp, *str2;
@


1.5
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.4 2013/03/29 23:01:24 eric Exp $	*/
d136 1
a136 1
			offset = ptr;
@


1.4
log
@properly handle scope when parsing IPv6 addresses.

ok bluhm@@ naddy@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.3 2012/11/24 15:12:48 eric Exp $	*/
d36 2
a37 2
static int dname_check_label(const char*, size_t);
static ssize_t dname_expand(const unsigned char*, size_t, size_t, size_t*,
d40 10
a49 10
static int unpack_data(struct unpack*, void*, size_t);
static int unpack_u16(struct unpack*, uint16_t*);
static int unpack_u32(struct unpack*, uint32_t*);
static int unpack_inaddr(struct unpack*, struct in_addr*);
static int unpack_in6addr(struct unpack*, struct in6_addr*);
static int unpack_dname(struct unpack*, char*, size_t);

static int pack_data(struct pack*, const void*, size_t);
static int pack_u16(struct pack*, uint16_t);
static int pack_dname(struct pack*, const char*);
@


1.3
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.2 2012/11/24 13:59:53 eric Exp $	*/
d20 1
d27 1
d29 1
d427 2
d448 13
a460 1
		if (inet_pton(PF_INET6, str, &in6a) != 1)
d468 13
@


1.2
log
@make separate structures for pack and unpack
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_utils.c,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
a19 1

d54 1
a54 1
	for(l--; l; l--, s++)
d79 1
a79 1
	for(; *str; str = d + 1) {
d124 1
a124 1
	for(; (n = data[offset]); ) {
d301 1
a301 1
	switch(rr->rr_type) {
d402 1
a402 1
	c.arcount = htons(h->arcount);	
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dname.c,v 1.4 2011/04/02 15:59:17 eric Exp $	*/
d38 10
a47 10
static int unpack_data(struct packed*, void*, size_t);
static int unpack_u16(struct packed*, uint16_t*);
static int unpack_u32(struct packed*, uint32_t*);
static int unpack_inaddr(struct packed*, struct in_addr*);
static int unpack_in6addr(struct packed*, struct in6_addr*);
static int unpack_dname(struct packed*, char*, size_t);

static int pack_data(struct packed*, const void*, size_t);
static int pack_u16(struct packed*, uint16_t);
static int pack_dname(struct packed*, const char*);
d166 1
a166 1
packed_init(struct packed *pack, char *data, size_t len)
d168 1
a168 1
	pack->data = data;
d174 9
d184 1
a184 1
unpack_data(struct packed *p, void *data, size_t len)
d194 1
a194 1
	memmove(data, p->data + p->offset, len);
d201 1
a201 1
unpack_u16(struct packed *p, uint16_t *u16)
d212 1
a212 1
unpack_u32(struct packed *p, uint32_t *u32)
d223 1
a223 1
unpack_inaddr(struct packed *p, struct in_addr *a)
d229 1
a229 1
unpack_in6addr(struct packed *p, struct in6_addr *a6)
d235 1
a235 1
unpack_dname(struct packed *p, char *dst, size_t max)
d242 1
a242 1
	e = dname_expand(p->data, p->len, p->offset, &p->offset, dst, max);
d256 1
a256 1
unpack_header(struct packed *p, struct header *h)
d271 1
a271 1
unpack_query(struct packed *p, struct query *q)
d281 1
a281 1
unpack_rr(struct packed *p, struct rr *rr)
d344 1
a344 1
		rr->rr.other.rdata = p->data + p->offset;
d360 1
a360 1
pack_data(struct packed *p, const void *data, size_t len)
d370 1
a370 1
	memmove(p->data + p->offset, data, len);
d377 1
a377 1
pack_u16(struct packed *p, uint16_t v)
d385 1
a385 1
pack_dname(struct packed *p, const char *dname)
d394 1
a394 1
pack_header(struct packed *p, const struct header *h)
d409 1
a409 1
pack_query(struct packed *p, uint16_t type, uint16_t class, const char *dname)
@

