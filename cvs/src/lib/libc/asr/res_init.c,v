head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.4.0.8
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.2
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.04.05.04.29.21;	author guenther;	state Exp;
branches;
next	1.9;
commitid	INw7kjfUlnrMbBig;

1.9
date	2016.03.23.18.45.03;	author chrisz;	state Exp;
branches;
next	1.8;
commitid	1FotHM64kWuiD8kV;

1.8
date	2015.11.05.23.59.47;	author bluhm;	state Exp;
branches;
next	1.7;
commitid	eBNZnMpufPgEYduK;

1.7
date	2015.11.05.22.44.37;	author bluhm;	state Exp;
branches;
next	1.6;
commitid	hC7RFCT8AyHXLo9i;

1.6
date	2015.10.05.02.57.16;	author guenther;	state Exp;
branches;
next	1.5;
commitid	hN3BtB3F33HLhHuv;

1.5
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	ZDWhDXAAMFWxMzBj;

1.4
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2014.01.15.02.25.34;	author sthen;	state Exp;
branches;
next	1.2;

1.2
date	2013.05.27.17.31.01;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.09.08.11.08.21;	author eric;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Prefer _MUTEX_*LOCK over _THREAD_PRIVATE_MUTEX_*LOCK() when thread-specific
data isn't necessary.

ok mpi@@, ok&tweak natano@@
@
text
@/*	$OpenBSD: res_init.c,v 1.9 2016/03/23 18:45:03 chrisz Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/nameser.h>
#include <netinet/in.h>
#include <netdb.h>

#include <asr.h>
#include <resolv.h>
#include <string.h>

#include "asr_private.h"
#include "thread_private.h"


struct __res_state _res;
struct __res_state_ext _res_ext;

int h_errno;

int
res_init(void)
{
	static void *resinit_mutex;
	struct asr_ctx	*ac;
	int i;

	ac = _asr_use_resolver(NULL);

	/*
	 * The first thread to call res_init() will setup the global _res
	 * structure from the async context, not overriding fields set early
	 * by the user.
	 */
	_MUTEX_LOCK(&resinit_mutex);
	if (!(_res.options & RES_INIT)) {
		if (_res.retry == 0)
			_res.retry = ac->ac_nsretries;
		if (_res.options == 0)
			_res.options = ac->ac_options;
		if (_res.lookups[0] == '\0')
			strlcpy(_res.lookups, ac->ac_db, sizeof(_res.lookups));

		for (i = 0; i < ac->ac_nscount && i < MAXNS; i++) {
			/*
			 * No need to check for length since we copy to a
			 * struct sockaddr_storage with a size of 256 bytes
			 * and sa_len has only 8 bits.
			 */
			memcpy(&_res_ext.nsaddr_list[i], ac->ac_ns[i],
			    ac->ac_ns[i]->sa_len);
			if (ac->ac_ns[i]->sa_len <= sizeof(_res.nsaddr_list[i]))
				memcpy(&_res.nsaddr_list[i], ac->ac_ns[i],
				    ac->ac_ns[i]->sa_len);
			else
				memset(&_res.nsaddr_list[i], 0,
				    sizeof(_res.nsaddr_list[i]));
		}
		_res.nscount = i;
		_res.options |= RES_INIT;
	}
	_MUTEX_UNLOCK(&resinit_mutex);

	/*
	 * If the program is not threaded, we want to reflect (some) changes
	 * made by the user to the global _res structure.
	 * This is a bit of a hack: if there is already an async query on
	 * this context, it might change things in its back.  It is ok
	 * as long as the user only uses the blocking resolver API.
	 * If needed we could consider cloning the context if there is
	 * a running query.
	 */
	if (!__isthreaded) {
		ac->ac_nsretries = _res.retry;
		ac->ac_options = _res.options;
		strlcpy(ac->ac_db, _res.lookups, sizeof(ac->ac_db));
		ac->ac_dbcount = strlen(ac->ac_db);
	}

	_asr_ctx_unref(ac);

	return (0);
}
DEF_WEAK(res_init);
@


1.9
log
@Initialize _res_ext.nsaddr_list alongside _res.nsaddr_list.
Fallback to initialization with 0 when _res.nsaddr_list is to small to hold an
IPv6 address.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.8 2015/11/05 23:59:47 bluhm Exp $	*/
d40 1
a40 1
	_THREAD_PRIVATE_MUTEX(init);
d51 1
a51 1
	_THREAD_PRIVATE_MUTEX_LOCK(init);
d78 1
a78 1
	_THREAD_PRIVATE_MUTEX_UNLOCK(init);
@


1.8
log
@Set the name server counter in __res_state correctly if a nameserver
from asr_ctx was skiped.  Missed in previous commit.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.7 2015/11/05 22:44:37 bluhm Exp $	*/
d42 1
a42 1
	int i, j;
d60 7
a66 5
		for (i = 0, j = 0; i < ac->ac_nscount && j < MAXNS; i++) {
			if (ac->ac_ns[i]->sa_family != AF_INET ||
			    ac->ac_ns[i]->sa_len > sizeof(_res.nsaddr_list[j]))
				continue;
			memcpy(&_res.nsaddr_list[j], ac->ac_ns[i],
d68 6
a73 1
			j++;
d75 1
a75 1
		_res.nscount = j;
@


1.7
log
@When filling the __res_state compatibiliy struct, a long list of
nameservers could overflow the dns search pointers.  Restrict the
number, size and address family of nameservers in res_init(3).  This
fixes a crash in sendmail.  Only programs that use the bind resolver
internals directly are affected.
OK deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.6 2015/10/05 02:57:16 guenther Exp $	*/
a59 1
		_res.nscount = ac->ac_nscount;
d68 1
@


1.6
log
@Wrap <resolv.h> so that internal calls go direct

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.5 2015/09/09 15:49:34 deraadt Exp $	*/
d42 1
a42 1
	int i;
d61 5
a65 2
		for (i = 0; i < ac->ac_nscount; i++) {
			memcpy(&_res.nsaddr_list[i], ac->ac_ns[i],
d67 1
@


1.5
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.4 2014/03/26 18:13:15 eric Exp $	*/
d89 1
@


1.4
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.3 2014/01/15 02:25:34 sthen Exp $	*/
d44 1
a44 1
	ac = asr_use_resolver(NULL);
d85 1
a85 1
	asr_ctx_unref(ac);
@


1.3
log
@Initialise _res.nsaddr_list in res_init(), fixing some programs which depend
on bind resolver internals. Note, the list will not be updated if resolv.conf
is changed while the program runs unless the caller resets the RES_INIT flag.
Approach suggested by otto@@, original diff from Kapetanakis Giannis, fix
suggested by tedu@@ and dug up again by Riccardo Mottola.  Looks ok to eric@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.2 2013/05/27 17:31:01 eric Exp $	*/
d19 1
d22 1
d24 1
a27 1
#include "asr.h"
@


1.2
log
@Add minimal support for _res setup and update.

Change res_init() to initialize the _res structure on first call, and
udpate the global async context if changes were made by the user. All
resolver functions now call res_init() internally.

fixes issue spotted by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: res_init.c,v 1.1 2012/09/08 11:08:21 eric Exp $	*/
d40 1
d59 4
@


1.1
log
@split asr_resolver.c into different files to overlay the libc/net
resolver implementation.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_resolver.c,v 1.10 2012/08/19 17:59:15 eric Exp $	*/
d19 1
d23 1
d26 2
a28 6
/*
 * XXX these function is actually internal to asr, but we use it here to force
 * the creation a default resolver context in res_init().
 */
struct asr_ctx *asr_use_resolver(struct asr *);
void asr_ctx_unref(struct asr_ctx *);
d38 41
a78 2
	async_resolver_done(NULL);
	asr_ctx_unref(asr_use_resolver(NULL));
@

