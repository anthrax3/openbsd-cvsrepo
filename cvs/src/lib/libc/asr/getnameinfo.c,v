head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.1.0.2
	OPENBSD_5_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.10.02.20.56.14;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	UJaxUpaG8U3CpWke;

1.7
date	2015.09.14.07.38.37;	author guenther;	state Exp;
branches;
next	1.6;
commitid	sc13azJRI5HI5bbC;

1.6
date	2015.05.25.19.16.08;	author eric;	state Exp;
branches;
next	1.5;
commitid	IKpppy5sd1KKKbVq;

1.5
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2014.03.25.19.48.11;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2013.07.12.14.36.21;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2013.05.27.17.31.01;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.09.08.11.08.21;	author eric;	state Exp;
branches;
next	;


desc
@@


1.8
log
@make a && && & block more readable.  no binary change.
discussed with otto
@
text
@/*	$OpenBSD: getnameinfo.c,v 1.7 2015/09/14 07:38:37 guenther Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>

#include <asr.h>
#include <errno.h>
#include <resolv.h>
#include <string.h>

static size_t asr_print_addr(const struct sockaddr *, char *, size_t);
static size_t asr_print_port(const struct sockaddr *, const char *, char *, size_t);

#define SA_IN(sa) ((struct sockaddr_in*)(sa))
#define SA_IN6(sa) ((struct sockaddr_in6*)(sa))

/*
 * Print the textual representation (as given by inet_ntop(3)) of the address
 * set in "sa".
 *
 * Return the total length of the string it tried to create or 0 if an error
 * occured, in which case errno is set.  On success, the constructed string
 * is guaranteed to be NUL-terminated.  Overflow must be detected by checking
 * the returned size against buflen.
 *
 */
static size_t
asr_print_addr(const struct sockaddr *sa, char *buf, size_t buflen)
{
	unsigned int ifidx;
	char tmp[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
	char scope[IF_NAMESIZE + 1], *ifname;
	const void *addr;
	size_t s;

	switch(sa->sa_family) {
	case AF_INET:
		addr = &SA_IN(sa)->sin_addr;
		break;
	case AF_INET6:
		addr = &SA_IN6(sa)->sin6_addr;
		break;
	default:
		errno = EINVAL;
		return (0);
	}

	if (inet_ntop(sa->sa_family, addr, tmp, sizeof(tmp)) == NULL)
		return (0); /* errno set */

	s = strlcpy(buf, tmp, buflen);

	if (sa->sa_family == AF_INET6 && SA_IN6(sa)->sin6_scope_id) {

		scope[0] = SCOPE_DELIMITER;
		scope[1] = '\0';

		ifidx = SA_IN6(sa)->sin6_scope_id;
		ifname = NULL;

		if (IN6_IS_ADDR_LINKLOCAL(&(SA_IN6(sa)->sin6_addr)) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&(SA_IN6(sa)->sin6_addr)) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(&(SA_IN6(sa)->sin6_addr)))
			ifname = if_indextoname(ifidx, scope + 1);

		if (ifname == NULL)
			(void)snprintf(scope + 1, sizeof(scope) - 1, "%u", ifidx);

		if (s < buflen)
			(void)strlcat(buf, scope, buflen);

		s += strlen(scope);
	}

	return (s);
}

/* 
 * Print the textual representation of the port set on "sa".
 *
 * If proto is not NULL, it is used as parameter to "getservbyport_r(3)" to
 * return a service name. If it's not set, or if no matching service is found,
 * it prints the portno.
 *
 * Return the total length of the string it tried to create or 0 if an error
 * occured, in which case errno is set.  On success, the constructed string
 * is guaranteed to be NUL-terminated.  Overflow must be detected by checking
 * the returned size against buflen.
 */
static size_t
asr_print_port(const struct sockaddr *sa, const char *proto, char *buf, size_t buflen)
{
	struct servent s;
	struct servent_data sd;
	int port, r, saved_errno;
	size_t n;

	switch(sa->sa_family) {
	case AF_INET:
		port = SA_IN(sa)->sin_port;
		break;
	case AF_INET6:
		port = SA_IN6(sa)->sin6_port;
		break;
	default:
		errno = EINVAL;
		return (0);
	}

	if (proto) {
		memset(&sd, 0, sizeof (sd));
		saved_errno = errno;
		if (getservbyport_r(port, proto, &s, &sd) != -1) {
			n = strlcpy(buf, s.s_name, buflen);
			endservent_r(&sd);
			return (n);
		}
		errno = saved_errno;
	}

	r = snprintf(buf, buflen, "%u", ntohs(port));
	if (r == -1) 	/* Actually, this can not happen */
		return (0);

	return (r);
}

int
getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host,
    size_t hostlen, char *serv, size_t servlen, int flags)
{
	struct asr_query *as;
	struct asr_result ar;
	int saved_errno = errno;
	const char *proto;
	size_t r;

	/*
	 * Take a shortcut if we don't care about hostname,
	 * or if NI_NUMERICHOST is set.
	 */
	if (host == NULL || hostlen == 0 ||
	    (host && hostlen && (flags & NI_NUMERICHOST))) {
		if (host) {
			r = asr_print_addr(sa, host, hostlen);
			if (r == 0)
				return (EAI_SYSTEM); /* errno set */
			if (r >= hostlen)
				return (EAI_OVERFLOW);
		}

		if (serv && servlen) {
			if (flags & NI_NUMERICSERV)
				proto = NULL;
			else
				proto = (flags & NI_DGRAM) ? "udp" : "tcp";
			r = asr_print_port(sa, proto, serv, servlen);
			if (r == 0)
				return (EAI_SYSTEM); /* errno set */
			if (r >= servlen)
				return (EAI_OVERFLOW);
		}

		errno = saved_errno;
		return (0);
	}

	res_init();

	as = getnameinfo_async(sa, salen, host, hostlen, serv, servlen, flags,
	    NULL);
	if (as == NULL) {
		if (errno == ENOMEM) {
			errno = saved_errno;
			return (EAI_MEMORY);
		}
		return (EAI_SYSTEM);
	}

	asr_run_sync(as, &ar);
	if (ar.ar_gai_errno == EAI_SYSTEM)
		errno = ar.ar_errno;

	return (ar.ar_gai_errno);
}
DEF_WEAK(getnameinfo);
@


1.7
log
@Finish wrapping <netdb.h> so that calls go direct and the symbols are all weak
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.6 2015/05/25 19:16:08 eric Exp $	*/
d157 6
a162 3
	/* Take a shortcut if we don't care about hostname, or if NI_NUMERICHOST is set. */
	if (host == NULL || hostlen == 0 || (host && hostlen && flags & NI_NUMERICHOST)) {

@


1.6
log
@getnameinfo(3) doesn't need to initialize the resolver when it's only used
for address/port formatting (e.g. NI_NUMERICHOST).

ok deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.5 2014/03/26 18:13:15 eric Exp $	*/
d202 1
@


1.5
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.4 2014/03/25 19:48:11 eric Exp $	*/
d20 2
d28 118
d154 29
@


1.4
log
@Cleanup and simplify the API to be exposed.  Use better names for
structures, functions and defines.

discussed with and ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.3 2013/07/12 14:36:21 eric Exp $	*/
d19 1
d21 1
d23 1
a25 2

#include "asr.h"
@


1.3
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.2 2013/05/27 17:31:01 eric Exp $	*/
d30 3
a32 3
	struct async	*as;
	struct async_res ar;
	int		 saved_errno = errno;
d46 1
a46 1
	asr_async_run_sync(as, &ar);
@


1.2
log
@Add minimal support for _res setup and update.

Change res_init() to initialize the _res structure on first call, and
udpate the global async context if changes were made by the user. All
resolver functions now call res_init() internally.

fixes issue spotted by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getnameinfo.c,v 1.1 2012/09/08 11:08:21 eric Exp $	*/
d46 1
a46 1
	async_run_sync(as, &ar);
@


1.1
log
@split asr_resolver.c into different files to overlay the libc/net
resolver implementation.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr_resolver.c,v 1.10 2012/08/19 17:59:15 eric Exp $	*/
d33 2
@

