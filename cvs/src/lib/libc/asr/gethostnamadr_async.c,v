head	1.43;
access;
symbols
	OPENBSD_6_2:1.43.0.2
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.25.0.2
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5;
locks; strict;
comment	@ * @;


1.43
date	2017.02.23.17.04.02;	author eric;	state Exp;
branches;
next	1.42;
commitid	A5SxxxFpG2Lk4uBi;

1.42
date	2015.12.16.16.32.30;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	oPoFLo6QaSW21nLc;

1.41
date	2015.11.23.18.04.54;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	OVI7ORhlpJiMawqs;

1.40
date	2015.09.20.14.19.21;	author eric;	state Exp;
branches;
next	1.39;
commitid	QoXCnUzVxYUpwKcZ;

1.39
date	2015.09.14.11.52.49;	author guenther;	state Exp;
branches;
next	1.38;
commitid	KzuByhRo5iAIKcqw;

1.38
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	ZDWhDXAAMFWxMzBj;

1.37
date	2015.05.29.08.49.37;	author eric;	state Exp;
branches;
next	1.36;
commitid	Tf6Q1D724C96QEJe;

1.36
date	2015.05.26.19.28.57;	author eric;	state Exp;
branches;
next	1.35;
commitid	zZUSsmIZVurlTa45;

1.35
date	2015.03.02.14.22.48;	author brynet;	state Exp;
branches;
next	1.34;
commitid	SoNiYKkNjVClLcic;

1.34
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	0DYulI8hhujBHMcR;

1.33
date	2015.01.14.23.36.15;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	tiEBIWumVnjfOhkT;

1.32
date	2014.11.02.13.59.16;	author eric;	state Exp;
branches;
next	1.31;
commitid	F8FfJ1XxPFjXnH17;

1.31
date	2014.09.15.06.15.48;	author guenther;	state Exp;
branches;
next	1.30;
commitid	ztgYHm1nk3mtTyS3;

1.30
date	2014.07.23.21.26.25;	author eric;	state Exp;
branches
	1.30.4.1;
next	1.29;
commitid	WIq5DvzhMZ99bkXf;

1.29
date	2014.05.13.11.57.35;	author eric;	state Exp;
branches;
next	1.28;

1.28
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2014.03.25.19.48.11;	author eric;	state Exp;
branches;
next	1.26;

1.26
date	2014.03.14.11.07.33;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2014.02.26.20.00.08;	author eric;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2014.02.17.10.49.53;	author eric;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.24.23.51.29;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.07.17.07.43.23;	author eric;	state Exp;
branches;
next	1.21;

1.21
date	2013.07.12.14.36.21;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.01.14.34.34;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.30.12.02.39;	author eric;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.14.22.23.08;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2013.04.03.21.13.50;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.01.15.49.54;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.04.01.08.54.07;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.29.20.04.17;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.27.07.40.41;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.17.21.13.16;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2012.11.24.18.58.49;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.24.13.59.53;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.06.15.05.16;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.04.16.03.21;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.19.16.17.40;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.12.13.03.34;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.10.15.58.00;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.10.12.41.54;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.25.20.28.25;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;

1.25.2.1
date	2014.11.17.16.56.36;	author tedu;	state Exp;
branches;
next	;
commitid	fzNMQ4OWu9Jh6KoD;

1.30.4.1
date	2014.11.17.16.56.01;	author tedu;	state Exp;
branches;
next	1.30.4.2;
commitid	3OamWCftt9o7tziz;

1.30.4.2
date	2015.05.23.19.04.08;	author brynet;	state Exp;
branches;
next	;
commitid	P8pE5oDD0KCaD53w;


desc
@@


1.43
log
@Put a common subq pointer in the query struct, rather than one in each
element of the union.

ok gilles@@ millert@@ krw@@
@
text
@/*	$OpenBSD: gethostnamadr_async.c,v 1.42 2015/12/16 16:32:30 deraadt Exp $	*/
/*
 * Copyright (c) 2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>

#include <asr.h>
#include <ctype.h>
#include <errno.h>
#include <resolv.h> /* for res_hnok */
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "asr_private.h"

#define MAXALIASES	35
#define MAXADDRS	35

struct hostent_ext {
	struct hostent	 h;
	char		*aliases[MAXALIASES + 1];
	char		*addrs[MAXADDRS + 1];
	char		*end;
	char		*pos;
};

static int gethostnamadr_async_run(struct asr_query *, struct asr_result *);
static struct hostent_ext *hostent_alloc(int);
static int hostent_set_cname(struct hostent_ext *, const char *, int);
static int hostent_add_alias(struct hostent_ext *, const char *, int);
static int hostent_add_addr(struct hostent_ext *, const void *, size_t);
static struct hostent_ext *hostent_from_addr(int, const char *, const char *);
static struct hostent_ext *hostent_file_match(FILE *, int, int, const char *,
    int);
static struct hostent_ext *hostent_from_packet(int, int, char *, size_t);

struct asr_query *
gethostbyname_async(const char *name, void *asr)
{
	return gethostbyname2_async(name, AF_INET, asr);
}
DEF_WEAK(gethostbyname_async);

struct asr_query *
gethostbyname2_async(const char *name, int af, void *asr)
{
	struct asr_ctx	 *ac;
	struct asr_query *as;

	/* the original segfaults */
	if (name == NULL) {
		errno = EINVAL;
		return (NULL);
	}

	ac = _asr_use_resolver(asr);
	if ((as = _asr_async_new(ac, ASR_GETHOSTBYNAME)) == NULL)
		goto abort; /* errno set */
	as->as_run = gethostnamadr_async_run;

	as->as.hostnamadr.family = af;
	if (af == AF_INET)
		as->as.hostnamadr.addrlen = INADDRSZ;
	else if (af == AF_INET6)
		as->as.hostnamadr.addrlen = IN6ADDRSZ;
	as->as.hostnamadr.name = strdup(name);
	if (as->as.hostnamadr.name == NULL)
		goto abort; /* errno set */

	_asr_ctx_unref(ac);
	return (as);

    abort:
	if (as)
		_asr_async_free(as);
	_asr_ctx_unref(ac);
	return (NULL);
}
DEF_WEAK(gethostbyname2_async);

struct asr_query *
gethostbyaddr_async(const void *addr, socklen_t len, int af, void *asr)
{
	struct asr_ctx	 *ac;
	struct asr_query *as;

	ac = _asr_use_resolver(asr);
	as = _gethostbyaddr_async_ctx(addr, len, af, ac);
	_asr_ctx_unref(ac);

	return (as);
}
DEF_WEAK(gethostbyaddr_async);

struct asr_query *
_gethostbyaddr_async_ctx(const void *addr, socklen_t len, int af,
    struct asr_ctx *ac)
{
	struct asr_query *as;

	if ((as = _asr_async_new(ac, ASR_GETHOSTBYADDR)) == NULL)
		goto abort; /* errno set */
	as->as_run = gethostnamadr_async_run;

	as->as.hostnamadr.family = af;
	as->as.hostnamadr.addrlen = len;
	if (len > 0)
		memmove(as->as.hostnamadr.addr, addr, (len > 16) ? 16 : len);

	return (as);

    abort:
	if (as)
		_asr_async_free(as);
	return (NULL);
}

static int
gethostnamadr_async_run(struct asr_query *as, struct asr_result *ar)
{
	struct hostent_ext	*h;
	int			 r, type, saved_errno;
	FILE			*f;
	char			 name[MAXDNAME], *data, addr[16], *c;

    next:
	switch (as->as_state) {

	case ASR_STATE_INIT:

		if (as->as.hostnamadr.family != AF_INET &&
		    as->as.hostnamadr.family != AF_INET6) {
			ar->ar_h_errno = NETDB_INTERNAL;
			ar->ar_errno = EAFNOSUPPORT;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if ((as->as.hostnamadr.family == AF_INET &&
		     as->as.hostnamadr.addrlen != INADDRSZ) ||
		    (as->as.hostnamadr.family == AF_INET6 &&
		     as->as.hostnamadr.addrlen != IN6ADDRSZ)) {
			ar->ar_h_errno = NETDB_INTERNAL;
			ar->ar_errno = EINVAL;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (as->as_type == ASR_GETHOSTBYNAME) {

			if (as->as.hostnamadr.name[0] == '\0') {
				ar->ar_h_errno = NO_DATA;
				async_set_state(as, ASR_STATE_HALT);
				break;
			}

			/* Name might be an IP address string */
			for (c = as->as.hostnamadr.name; *c; c++)
				if (!isdigit((unsigned char)*c) &&
				     *c != '.' && *c != ':')
					break;
			if (*c == 0 &&
			    inet_pton(as->as.hostnamadr.family,
			    as->as.hostnamadr.name, addr) == 1) {
				h = hostent_from_addr(as->as.hostnamadr.family,
				    as->as.hostnamadr.name, addr);
				if (h == NULL) {
					ar->ar_errno = errno;
					ar->ar_h_errno = NETDB_INTERNAL;
				}
				else {
					ar->ar_hostent = &h->h;
					ar->ar_h_errno = NETDB_SUCCESS;
				}
				async_set_state(as, ASR_STATE_HALT);
				break;
			}
		}
		async_set_state(as, ASR_STATE_NEXT_DB);
		break;

	case ASR_STATE_NEXT_DB:

		if (_asr_iter_db(as) == -1) {
			async_set_state(as, ASR_STATE_NOT_FOUND);
			break;
		}

		switch (AS_DB(as)) {

		case ASR_DB_DNS:

			/* Create a subquery to do the DNS lookup */

			if (as->as_type == ASR_GETHOSTBYNAME) {
				type = (as->as.hostnamadr.family == AF_INET) ?
				    T_A : T_AAAA;
				as->as_subq = _res_search_async_ctx(
				    as->as.hostnamadr.name,
				    C_IN, type, as->as_ctx);
			} else {
				_asr_addr_as_fqdn(as->as.hostnamadr.addr,
				    as->as.hostnamadr.family,
				    name, sizeof(name));
				as->as_subq = _res_query_async_ctx(
				    name, C_IN, T_PTR, as->as_ctx);
			}

			if (as->as_subq == NULL) {
				ar->ar_errno = errno;
				ar->ar_h_errno = NETDB_INTERNAL;
				async_set_state(as, ASR_STATE_HALT);
				break;
			}

			async_set_state(as, ASR_STATE_SUBQUERY);
			break;

		case ASR_DB_FILE:

			/* Try to find a match in the host file */

			if ((f = fopen(_PATH_HOSTS, "re")) == NULL)
				break;

			if (as->as_type == ASR_GETHOSTBYNAME)
				data = as->as.hostnamadr.name;
			else
				data = as->as.hostnamadr.addr;

			h = hostent_file_match(f, as->as_type,
			    as->as.hostnamadr.family, data,
			    as->as.hostnamadr.addrlen);
			saved_errno = errno;
			fclose(f);
			errno = saved_errno;

			if (h == NULL) {
				if (errno) {
					ar->ar_errno = errno;
					ar->ar_h_errno = NETDB_INTERNAL;
					async_set_state(as, ASR_STATE_HALT);
				}
				/* otherwise not found */
				break;
			}
			ar->ar_hostent = &h->h;
			ar->ar_h_errno = NETDB_SUCCESS;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}
		break;

	case ASR_STATE_SUBQUERY:

		/* Run the DNS subquery. */

		if ((r = asr_run(as->as_subq, ar)) == ASYNC_COND)
			return (ASYNC_COND);

		/* Done. */
		as->as_subq = NULL;

		if (ar->ar_datalen == -1) {
			async_set_state(as, ASR_STATE_NEXT_DB);
			break;
		}

		/* If we got a packet but no anwser, use the next DB. */
		if (ar->ar_count == 0) {
			free(ar->ar_data);
			as->as.hostnamadr.subq_h_errno = ar->ar_h_errno;
			async_set_state(as, ASR_STATE_NEXT_DB);
			break;
		}

		/* Read the hostent from the packet. */

		h = hostent_from_packet(as->as_type,
		    as->as.hostnamadr.family, ar->ar_data, ar->ar_datalen);
		free(ar->ar_data);
		if (h == NULL) {
			ar->ar_errno = errno;
			ar->ar_h_errno = NETDB_INTERNAL;
			async_set_state(as, ASR_STATE_HALT);
			break;
		}

		if (as->as_type == ASR_GETHOSTBYADDR) {
			if (hostent_add_addr(h, as->as.hostnamadr.addr,
			    as->as.hostnamadr.addrlen) == -1) {
				free(h);
				ar->ar_errno = errno;
				ar->ar_h_errno = NETDB_INTERNAL;
				async_set_state(as, ASR_STATE_HALT);
				break;
			}
		}

		/*
		 * No valid hostname or address found in the dns packet.
		 * Ignore it.
		 */
		if ((as->as_type == ASR_GETHOSTBYNAME &&
		     h->h.h_addr_list[0] == NULL) ||
		    h->h.h_name == NULL) {
			free(h);
			async_set_state(as, ASR_STATE_NEXT_DB);
			break;
		}

		ar->ar_hostent = &h->h;
		ar->ar_h_errno = NETDB_SUCCESS;
		async_set_state(as, ASR_STATE_HALT);
		break;

	case ASR_STATE_NOT_FOUND:
		ar->ar_errno = 0;
		if (as->as.hostnamadr.subq_h_errno)
			ar->ar_h_errno = as->as.hostnamadr.subq_h_errno;
		else
			ar->ar_h_errno = HOST_NOT_FOUND;
		async_set_state(as, ASR_STATE_HALT);
		break;

	case ASR_STATE_HALT:
		if (ar->ar_h_errno)
			ar->ar_hostent = NULL;
		else
			ar->ar_errno = 0;
		return (ASYNC_DONE);

	default:
		ar->ar_errno = EOPNOTSUPP;
		ar->ar_h_errno = NETDB_INTERNAL;
		ar->ar_gai_errno = EAI_SYSTEM;
		async_set_state(as, ASR_STATE_HALT);
		break;
	}
	goto next;
}

/*
 * Create a hostent from a numeric address string.
 */
static struct hostent_ext *
hostent_from_addr(int family, const char *name, const char *addr)
{
	struct	 hostent_ext *h;

	if ((h = hostent_alloc(family)) == NULL)
		return (NULL);
	if (hostent_set_cname(h, name, 0) == -1)
		goto fail;
	if (hostent_add_addr(h, addr, h->h.h_length) == -1)
		goto fail;
	return (h);
fail:
	free(h);
	return (NULL);
}

/*
 * Lookup the first matching entry in the hostfile, either by address or by
 * name depending on reqtype, and build a hostent from the line.
 */
static struct hostent_ext *
hostent_file_match(FILE *f, int reqtype, int family, const char *data,
    int datalen)
{
	char	*tokens[MAXTOKEN], addr[16], buf[BUFSIZ + 1];
	struct	 hostent_ext *h;
	int	 n, i;

	for (;;) {
		n = _asr_parse_namedb_line(f, tokens, MAXTOKEN, buf, sizeof(buf));
		if (n == -1) {
			errno = 0; /* ignore errors reading the file */
			return (NULL);
		}

		/* there must be an address and at least one name */
		if (n < 2)
			continue;

		if (reqtype == ASR_GETHOSTBYNAME) {
			for (i = 1; i < n; i++) {
				if (strcasecmp(data, tokens[i]))
					continue;
				if (inet_pton(family, tokens[0], addr) == 1)
					goto found;
			}
		} else {
			if (inet_pton(family, tokens[0], addr) == 1 &&
			    memcmp(addr, data, datalen) == 0)
				goto found;
		}
	}

found:
	if ((h = hostent_alloc(family)) == NULL)
		return (NULL);
	if (hostent_set_cname(h, tokens[1], 0) == -1)
		goto fail;
	for (i = 2; i < n; i ++)
		if (hostent_add_alias(h, tokens[i], 0) == -1)
			goto fail;
	if (hostent_add_addr(h, addr, h->h.h_length) == -1)
		goto fail;
	return (h);
fail:
	free(h);
	return (NULL);
}

/*
 * Fill the hostent from the given DNS packet.
 */
static struct hostent_ext *
hostent_from_packet(int reqtype, int family, char *pkt, size_t pktlen)
{
	struct hostent_ext	*h;
	struct asr_unpack	 p;
	struct asr_dns_header	 hdr;
	struct asr_dns_query	 q;
	struct asr_dns_rr	 rr;
	char			 dname[MAXDNAME];

	if ((h = hostent_alloc(family)) == NULL)
		return (NULL);

	_asr_unpack_init(&p, pkt, pktlen);
	_asr_unpack_header(&p, &hdr);
	for (; hdr.qdcount; hdr.qdcount--)
		_asr_unpack_query(&p, &q);
	strlcpy(dname, q.q_dname, sizeof(dname));

	for (; hdr.ancount; hdr.ancount--) {
		_asr_unpack_rr(&p, &rr);
		if (rr.rr_class != C_IN)
			continue;
		switch (rr.rr_type) {

		case T_CNAME:
			if (reqtype == ASR_GETHOSTBYNAME) {
				if (hostent_add_alias(h, rr.rr_dname, 1) == -1)
					goto fail;
			} else {
				if (strcasecmp(rr.rr_dname, dname) == 0)
					strlcpy(dname, rr.rr.cname.cname,
					    sizeof(dname));
			}
			break;

		case T_PTR:
			if (reqtype != ASR_GETHOSTBYADDR)
				break;
			if (strcasecmp(rr.rr_dname, dname) != 0)
				continue;
			if (hostent_set_cname(h, rr.rr.ptr.ptrname, 1) == -1)
				hostent_add_alias(h, rr.rr.ptr.ptrname, 1);
			break;

		case T_A:
			if (reqtype != ASR_GETHOSTBYNAME)
				break;
			if (family != AF_INET)
				break;
			if (hostent_set_cname(h, rr.rr_dname, 1) == -1)
				;
			if (hostent_add_addr(h, &rr.rr.in_a.addr, 4) == -1)
				goto fail;
			break;

		case T_AAAA:
			if (reqtype != ASR_GETHOSTBYNAME)
				break;
			if (family != AF_INET6)
				break;
			if (hostent_set_cname(h, rr.rr_dname, 1) == -1)
				;
			if (hostent_add_addr(h, &rr.rr.in_aaaa.addr6, 16) == -1)
				goto fail;
			break;
		}
	}

	return (h);
fail:
	free(h);
	return (NULL);
}

static struct hostent_ext *
hostent_alloc(int family)
{
	struct hostent_ext	*h;
	size_t			alloc;

	alloc = sizeof(*h) + 1024;
	if ((h = calloc(1, alloc)) == NULL)
		return (NULL);

	h->h.h_addrtype = family;
	h->h.h_length = (family == AF_INET) ? 4 : 16;
	h->h.h_aliases = h->aliases;
	h->h.h_addr_list = h->addrs;
	h->pos = (char *)(h) + sizeof(*h);
	h->end = h->pos + 1024;

	return (h);
}

static int
hostent_set_cname(struct hostent_ext *h, const char *name, int isdname)
{
	char	buf[MAXDNAME];
	size_t	n;

	if (h->h.h_name)
		return (-1);

	if (isdname) {
		_asr_strdname(name, buf, sizeof buf);
		buf[strlen(buf) - 1] = '\0';
		if (!res_hnok(buf))
			return (-1);
		name = buf;
	}

	n = strlen(name) + 1;
	if (h->pos + n >= h->end)
		return (-1);

	h->h.h_name = h->pos;
	memmove(h->pos, name, n);
	h->pos += n;
	return (0);
}

static int
hostent_add_alias(struct hostent_ext *h, const char *name, int isdname)
{
	char	buf[MAXDNAME];
	size_t	i, n;

	for (i = 0; i < MAXALIASES; i++)
		if (h->aliases[i] == NULL)
			break;
	if (i == MAXALIASES)
		return (0);

	if (isdname) {
		_asr_strdname(name, buf, sizeof buf);
		buf[strlen(buf)-1] = '\0';
		if (!res_hnok(buf))
			return (-1);
		name = buf;
	}

	n = strlen(name) + 1;
	if (h->pos + n >= h->end)
		return (0);

	h->aliases[i] = h->pos;
	memmove(h->pos, name, n);
	h->pos += n;
	return (0);
}

static int
hostent_add_addr(struct hostent_ext *h, const void *addr, size_t size)
{
	int	i;

	for (i = 0; i < MAXADDRS; i++)
		if (h->addrs[i] == NULL)
			break;
	if (i == MAXADDRS)
		return (0);

	if (h->pos + size >= h->end)
		return (0);

	h->addrs[i] = h->pos;
	memmove(h->pos, addr, size);
	h->pos += size;
	return (0);
}
@


1.42
log
@Remove support for HOSTALIASES from the resolver.  This "open and parse
any file indicated by an environment variable" feature inside the
resolver is incompatible with what pledge "dns" is trying to be.  It is
a misguided "feature" added way back in history which almost noone uses,
but everyone has to assume the risk from.
ok eric florian kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.41 2015/11/23 18:04:54 deraadt Exp $	*/
d218 1
a218 1
				as->as.hostnamadr.subq = _res_search_async_ctx(
d225 1
a225 1
				as->as.hostnamadr.subq = _res_query_async_ctx(
d229 1
a229 1
			if (as->as.hostnamadr.subq == NULL) {
d278 1
a278 1
		if ((r = asr_run(as->as.hostnamadr.subq, ar)) == ASYNC_COND)
d282 1
a282 1
		as->as.hostnamadr.subq = NULL;
@


1.41
log
@Remove support for "lookup yp" in /etc/resolv.conf.  This historical
wart is incompatible with pledge, because suddenly a "dns" operation
needs "getpw" access to ypbind/ypserv, etc.  file + dns access is
enough for everyone, sorry if you were using that old SunOS 4.x style
mechanism, but it is now gone.
ok semarie millert florian
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.40 2015/09/20 14:19:21 eric Exp $	*/
d246 2
a247 6
			if (as->as_type == ASR_GETHOSTBYNAME) {
				data = _asr_hostalias(as->as_ctx,
				    as->as.hostnamadr.name, name, sizeof(name));
				if (data == NULL)
					data = as->as.hostnamadr.name;
			}
@


1.40
log
@remove bogus includes of err.h
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.39 2015/09/14 11:52:49 guenther Exp $	*/
a33 7
#ifdef YP
#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "ypinternal.h"
#endif

a55 4
#ifdef YP
static struct hostent_ext *_yp_gethostnamadr(int, const void *);
static struct hostent_ext *hostent_from_yp(int, char *);
#endif
a274 28
#ifdef YP
		case ASR_DB_YP:
			/* IPv4 only */
			if (as->as.hostnamadr.family != AF_INET)
				break;
			if (as->as_type == ASR_GETHOSTBYNAME) {
				data = _asr_hostalias(as->as_ctx,
				    as->as.hostnamadr.name, name, sizeof(name));
				if (data == NULL)
					data = as->as.hostnamadr.name;
			}
			else
				data = as->as.hostnamadr.addr;
			h = _yp_gethostnamadr(as->as_type, data);
			if (h == NULL) {
				if (errno) {
					ar->ar_errno = errno;
					ar->ar_h_errno = NETDB_INTERNAL;
					async_set_state(as, ASR_STATE_HALT);
				}
				/* otherwise not found */
				break;
			}
			ar->ar_hostent = &h->h;
			ar->ar_h_errno = NETDB_SUCCESS;
			async_set_state(as, ASR_STATE_HALT);
			break;
#endif
a613 92

#ifdef YP
static struct hostent_ext *
_yp_gethostnamadr(int type, const void *data)
{
	static char		*domain = NULL;
	struct hostent_ext	*h = NULL;
	const char		*name;
	char			 buf[HOST_NAME_MAX+1];
	char			*res = NULL;
	int			 r, len;

	if (!domain && _yp_check(&domain) == 0) {
		errno = 0; /* ignore yp_bind errors */
		return (NULL);
	}

	if (type == ASR_GETHOSTBYNAME) {
		name = data;
		len = strlen(name);
		r = yp_match(domain, "hosts.byname", name, len, &res, &len);
	}
	else {
		if (inet_ntop(AF_INET, data, buf, sizeof buf) == NULL)
			return (NULL);
		len = strlen(buf);
		r = yp_match(domain, "hosts.byaddr", buf, len, &res, &len);
	}
	if (r == 0) {
		h = hostent_from_yp(AF_INET, res);
	} else {
		errno = 0; /* ignore error if not found */
	}
	if (res)
		free(res);
	return (h);
}

static int
strsplit(char *line, char **tokens, int ntokens)
{
	int	ntok;
	char	*cp, **tp;

	for (cp = line, tp = tokens, ntok = 0;
	    ntok < ntokens && (*tp = strsep(&cp, " \t")) != NULL; )
		if (**tp != '\0') {
			tp++;
			ntok++;
		}

	return (ntok);
}

static struct hostent_ext *
hostent_from_yp(int family, char *line)
{
	struct hostent_ext	*h;
	char			*next, *tokens[10], addr[IN6ADDRSZ];
	int			 i, ntok;

	if ((h = hostent_alloc(family)) == NULL)
		return (NULL);

	for (next = line; line; line = next) {
		if ((next = strchr(line, '\n'))) {
			*next = '\0';
			next += 1;
		}
		ntok = strsplit(line, tokens, 10);
		if (ntok < 2)
			continue;
		if (inet_pton(family, tokens[0], addr) == 1)
			hostent_add_addr(h, addr, family == AF_INET ?
			    INADDRSZ : IN6ADDRSZ);
		i = 2;
		if (h->h.h_name == NULL)
			hostent_set_cname(h, tokens[1], 0);
		else if (strcmp(h->h.h_name, tokens[1]))
			i = 1;
		for (; i < ntok; i++)
			hostent_add_alias(h, tokens[i], 0);
	}

	if (h->h.h_name == NULL) {
		free(h);
		return (NULL);
	}

	return (h);
}
#endif
@


1.39
log
@Wrap <asr.h> so internal calls go direct and all the symbols are weak
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.38 2015/09/09 15:49:34 deraadt Exp $	*/
a26 1
#include <err.h>
@


1.38
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.37 2015/05/29 08:49:37 eric Exp $	*/
d74 1
d111 1
d125 1
@


1.37
log
@fix a possible off-by-one when reading /etc/hosts if it doesn't end
with a newline.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.36 2015/05/26 19:28:57 eric Exp $	*/
d87 2
a88 2
	ac = asr_use_resolver(asr);
	if ((as = asr_async_new(ac, ASR_GETHOSTBYNAME)) == NULL)
d101 1
a101 1
	asr_ctx_unref(ac);
d106 2
a107 2
		asr_async_free(as);
	asr_ctx_unref(ac);
d117 3
a119 3
	ac = asr_use_resolver(asr);
	as = gethostbyaddr_async_ctx(addr, len, af, ac);
	asr_ctx_unref(ac);
d125 1
a125 1
gethostbyaddr_async_ctx(const void *addr, socklen_t len, int af,
d130 1
a130 1
	if ((as = asr_async_new(ac, ASR_GETHOSTBYADDR)) == NULL)
d143 1
a143 1
		asr_async_free(as);
d213 1
a213 1
		if (asr_iter_db(as) == -1) {
d227 1
a227 1
				as->as.hostnamadr.subq = res_search_async_ctx(
d231 1
a231 1
				asr_addr_as_fqdn(as->as.hostnamadr.addr,
d234 1
a234 1
				as->as.hostnamadr.subq = res_query_async_ctx(
d256 1
a256 1
				data = asr_hostalias(as->as_ctx,
d290 1
a290 1
				data = asr_hostalias(as->as_ctx,
d437 1
a437 1
		n = asr_parse_namedb_line(f, tokens, MAXTOKEN, buf, sizeof(buf));
d493 2
a494 2
	asr_unpack_init(&p, pkt, pktlen);
	asr_unpack_header(&p, &hdr);
d496 1
a496 1
		asr_unpack_query(&p, &q);
d500 1
a500 1
		asr_unpack_rr(&p, &rr);
d585 1
a585 1
		asr_strdname(name, buf, sizeof buf);
d615 1
a615 1
		asr_strdname(name, buf, sizeof buf);
@


1.36
log
@simply use _PATH_HOSTS where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.35 2015/03/02 14:22:48 brynet Exp $	*/
d432 1
a432 1
	char	*tokens[MAXTOKEN], addr[16];
d437 1
a437 1
		n = asr_parse_namedb_line(f, tokens, MAXTOKEN);
@


1.35
log
@gethostbyname(3) would fail when more than 16 addrs/aliases were returned.

Bump MAXADDRS/ALIASES to the original of 35, and silently ignore extras
instead of failing.

Noticed by markson on freenode.

OK eric@@ "with revised diff", phessler@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.34 2015/01/16 16:48:51 deraadt Exp $	*/
d252 1
a252 1
			if ((f = fopen(as->as_ctx->ac_hostfile, "re")) == NULL)
@


1.34
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.33 2015/01/14 23:36:15 deraadt Exp $	*/
d44 2
a45 2
#define MAXALIASES	16
#define MAXADDRS	16
d612 1
a612 1
		return (-1);
d624 1
a624 1
		return (-1);
d641 1
a641 1
		return (-1);
d644 1
a644 1
		return (-1);
@


1.33
log
@change _yp_domain[] to HOST_NAME_MAX+1, and re-arrange those who include
it to get limits.h early enough
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.32 2014/11/02 13:59:16 eric Exp $	*/
d659 1
a659 1
	char			 buf[MAXHOSTNAMELEN];
@


1.32
log
@Fix a NULL deref when getting an actual result for an invalid hostname
in gethostbyname().  Similar fix for getnetbyname().

ok deraadt@@ daniel@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.31 2014/09/15 06:15:48 guenther Exp $	*/
a22 6
#ifdef YP
#include <rpc/rpc.h>
#include <rpcsvc/yp.h>
#include <rpcsvc/ypclnt.h>
#include "ypinternal.h"
#endif
d33 8
@


1.31
log
@When fopen()ing internal to libc (the API doesn't support the use
of the resulting FILE *), then pass fopen() the 'e' mode letter to
mark it close-on-exec.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.30 2014/07/23 21:26:25 eric Exp $	*/
d360 2
a361 2
		 * No address found in the dns packet. The blocking version
		 * reports this as an error.
d365 1
a365 2
		    (as->as_type == ASR_GETHOSTBYADDR &&
		     h->h.h_name == NULL)) {
@


1.30
log
@Make queries using the search list for hostname lookups fail with
NO_DATA/EAI_NODATA when the hostname param is an empty string.
So far, they were using the entries in the search list with no
additional component, which is not really expected.

reported by jsing@@ and a few others

ok deraadt@@, "makes sense" jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.29 2014/05/13 11:57:35 eric Exp $	*/
d250 1
a250 1
			if ((f = fopen(as->as_ctx->ac_hostfile, "r")) == NULL)
@


1.30.4.1
log
@backport fix to avoid null deref with invalid hostnames
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.30 2014/07/23 21:26:25 eric Exp $	*/
d360 2
a361 2
		 * No valid hostname or address found in the dns packet.
		 * Ignore it.
d365 2
a366 1
		    h->h.h_name == NULL) {
@


1.30.4.2
log
@Merge fix from 5.7/-current:

gethostbyname(3) would fail when more than 16 addrs/aliases were returned.

Bump MAXADDRS/ALIASES to the original of 35, and silently ignore extras
instead of failing.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.30.4.1 2014/11/17 16:56:01 tedu Exp $	*/
d42 2
a43 2
#define MAXALIASES	35
#define MAXADDRS	35
d610 1
a610 1
		return (0);
d622 1
a622 1
		return (0);
d639 1
a639 1
		return (0);
d642 1
a642 1
		return (0);
@


1.29
log
@skip incomplete entries in /etc/hosts and /etc/networks
fix null deref spotted by Seth Hanford, pinpointed by dtucker@@

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.28 2014/03/26 18:13:15 eric Exp $	*/
a175 1
		/* Name might be an IP address string */
d177 8
@


1.28
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.27 2014/03/25 19:48:11 eric Exp $	*/
d434 4
@


1.27
log
@Cleanup and simplify the API to be exposed.  Use better names for
structures, functions and defines.

discussed with and ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.26 2014/03/14 11:07:33 eric Exp $	*/
d29 1
d31 1
a39 1
#include "asr.h"
@


1.26
log
@prefix structure names to avoid ambiguity and possible collisions when
the API gets public.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.25 2014/02/26 20:00:08 eric Exp $	*/
d52 1
a52 1
static int gethostnamadr_async_run(struct async *, struct async_res *);
d66 2
a67 2
struct async *
gethostbyname_async(const char *name, struct asr *asr)
d72 2
a73 2
struct async *
gethostbyname2_async(const char *name, int af, struct asr *asr)
d75 2
a76 2
	struct asr_ctx	*ac;
	struct async	*as;
d108 2
a109 2
struct async *
gethostbyaddr_async(const void *addr, socklen_t len, int af, struct asr *asr)
d111 2
a112 2
	struct asr_ctx	*ac;
	struct async	*as;
d121 1
a121 1
struct async *
d125 1
a125 1
	struct async	*as;
d145 1
a145 1
gethostnamadr_async_run(struct async *as, struct async_res *ar)
d309 1
a309 1
		if ((r = asr_async_run(as->as.hostnamadr.subq, ar)) == ASYNC_COND)
@


1.25
log
@Do not restrict chars in dname during label expansion, but validate resulting
hostnames before returning them to the caller.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.24 2014/02/17 10:49:53 eric Exp $	*/
d470 6
a475 6
	struct hostent_ext *h;
	struct unpack	 p;
	struct header	 hdr;
	struct query	 q;
	struct rr	 rr;
	char		 dname[MAXDNAME];
@


1.25.2.1
log
@backport fix to avoid null deref with invalid hostnames
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.25 2014/02/26 20:00:08 eric Exp $	*/
d352 2
a353 2
		 * No valid hostname or address found in the dns packet.
		 * Ignore it.
d357 2
a358 1
		    h->h.h_name == NULL) {
@


1.24
log
@report extra PTR records as aliases
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.23 2013/11/24 23:51:29 deraadt Exp $	*/
d33 1
d574 2
d604 2
@


1.23
log
@most obvious unsigned char casts for ctype
ok jca krw ingo
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.22 2013/07/17 07:43:23 eric Exp $	*/
d508 1
a508 2
				goto fail;
			/* XXX See if we need MULTI_PTRS_ARE_ALIASES */
@


1.22
log
@missing symbol rename.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.21 2013/07/12 14:36:21 eric Exp $	*/
d177 2
a178 1
				if (!isdigit(*c) && *c != '.' && *c != ':')
@


1.21
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.20 2013/06/01 14:34:34 eric Exp $	*/
d139 1
a139 1
		async_free(as);
@


1.20
log
@Make hostaliases work for gethostbyname() and getaddrinfo() when
looking into /etc/hosts.  Remove the alias check from the search
domain iteration. Instead, take a shortcut to res_query_async_ctx() in
res_search_async_ctx().
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.19 2013/04/30 12:02:39 eric Exp $	*/
a50 2
ssize_t addr_as_fqdn(const char *, int, char *, size_t);

d84 1
a84 1
	if ((as = async_new(ac, ASR_GETHOSTBYNAME)) == NULL)
d102 1
a102 1
		async_free(as);
d126 1
a126 1
	if ((as = async_new(ac, ASR_GETHOSTBYADDR)) == NULL)
d219 1
a219 1
				addr_as_fqdn(as->as.hostnamadr.addr,
d307 1
a307 1
		if ((r = async_run(as->as.hostnamadr.subq, ar)) == ASYNC_COND)
d478 2
a479 2
	unpack_init(&p, pkt, pktlen);
	unpack_header(&p, &hdr);
d481 1
a481 1
		unpack_query(&p, &q);
d485 1
a485 1
		unpack_rr(&p, &rr);
a630 61
	return (0);
}

ssize_t
addr_as_fqdn(const char *addr, int family, char *dst, size_t max)
{
	const struct in6_addr	*in6_addr;
	in_addr_t		 in_addr;

	switch (family) {
	case AF_INET:
		in_addr = ntohl(*((const in_addr_t *)addr));
		snprintf(dst, max,
		    "%d.%d.%d.%d.in-addr.arpa.",
		    in_addr & 0xff,
		    (in_addr >> 8) & 0xff,
		    (in_addr >> 16) & 0xff,
		    (in_addr >> 24) & 0xff);
		break;
	case AF_INET6:
		in6_addr = (const struct in6_addr *)addr;
		snprintf(dst, max,
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x."
		    "ip6.arpa.",
		    in6_addr->s6_addr[15] & 0xf,
		    (in6_addr->s6_addr[15] >> 4) & 0xf,
		    in6_addr->s6_addr[14] & 0xf,
		    (in6_addr->s6_addr[14] >> 4) & 0xf,
		    in6_addr->s6_addr[13] & 0xf,
		    (in6_addr->s6_addr[13] >> 4) & 0xf,
		    in6_addr->s6_addr[12] & 0xf,
		    (in6_addr->s6_addr[12] >> 4) & 0xf,
		    in6_addr->s6_addr[11] & 0xf,
		    (in6_addr->s6_addr[11] >> 4) & 0xf,
		    in6_addr->s6_addr[10] & 0xf,
		    (in6_addr->s6_addr[10] >> 4) & 0xf,
		    in6_addr->s6_addr[9] & 0xf,
		    (in6_addr->s6_addr[9] >> 4) & 0xf,
		    in6_addr->s6_addr[8] & 0xf,
		    (in6_addr->s6_addr[8] >> 4) & 0xf,
		    in6_addr->s6_addr[7] & 0xf,
		    (in6_addr->s6_addr[7] >> 4) & 0xf,
		    in6_addr->s6_addr[6] & 0xf,
		    (in6_addr->s6_addr[6] >> 4) & 0xf,
		    in6_addr->s6_addr[5] & 0xf,
		    (in6_addr->s6_addr[5] >> 4) & 0xf,
		    in6_addr->s6_addr[4] & 0xf,
		    (in6_addr->s6_addr[4] >> 4) & 0xf,
		    in6_addr->s6_addr[3] & 0xf,
		    (in6_addr->s6_addr[3] >> 4) & 0xf,
		    in6_addr->s6_addr[2] & 0xf,
		    (in6_addr->s6_addr[2] >> 4) & 0xf,
		    in6_addr->s6_addr[1] & 0xf,
		    (in6_addr->s6_addr[1] >> 4) & 0xf,
		    in6_addr->s6_addr[0] & 0xf,
		    (in6_addr->s6_addr[0] >> 4) & 0xf);
		break;
	default:
		return (-1);
	}
@


1.19
log
@Do not take external buffers for storing DNS responses in the internal
async API.  That is actually useless and it makes the code more
complicated.  The required buffers are always allocated when needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.18 2013/04/14 22:23:08 deraadt Exp $	*/
d151 1
a151 1
	char			 dname[MAXDNAME], *data, addr[16], *c;
d223 1
a223 1
				    dname, sizeof(dname));
d225 1
a225 1
				    dname, C_IN, T_PTR, as->as_ctx);
d245 6
a250 2
			if (as->as_type == ASR_GETHOSTBYNAME)
				data = as->as.hostnamadr.name;
d279 6
a284 2
			if (as->as_type == ASR_GETHOSTBYNAME)
				data = as->as.hostnamadr.name;
@


1.18
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.17 2013/04/03 21:13:50 eric Exp $	*/
d219 1
a219 1
				    C_IN, type, NULL, 0, as->as_ctx);
d225 1
a225 1
				    dname, C_IN, T_PTR, NULL, 0, as->as_ctx);
@


1.17
log
@properly follow the CNAME chain in reverse lookups

spotted by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.16 2013/04/01 15:49:54 deraadt Exp $	*/
d538 1
a538 1
	struct hostent_ext     *h;
@


1.16
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.15 2013/04/01 08:54:07 eric Exp $	*/
d347 4
a350 2
		if (as->as_type == ASR_GETHOSTBYNAME &&
		    h->h.h_addr_list[0] == NULL) {
d467 1
d476 2
d489 3
a491 2
				if (hostent_set_cname(h, rr.rr_dname, 1) == -1)
					goto fail;
d498 2
@


1.15
log
@rename field
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.14 2013/03/29 20:04:17 eric Exp $	*/
d541 1
a541 1
	h->pos = (char*)(h) + sizeof(*h);
@


1.14
log
@Do not fail in gethostbyname_async() if there are multiple addresses in
a DNS packet...
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.13 2013/03/27 07:40:41 eric Exp $	*/
d315 1
a315 1
			as->as.hostnamadr.h_errno = ar->ar_h_errno;
d361 2
a362 2
		if (as->as.hostnamadr.h_errno)
			ar->ar_h_errno = as->as.hostnamadr.h_errno;
@


1.13
log
@Only use the search domains for DNS lookups, as the current resolver does.
Better not diverge too much in behavior at this point.
Typo fix and doc update while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.12 2012/12/17 21:13:16 eric Exp $	*/
d503 1
a503 1
				goto fail;
d514 1
a514 1
				goto fail;
@


1.12
log
@Allow gethostbyname() to accept a numeric IP string.
No lookup is done in this case.

regression reported by espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.11 2012/11/24 18:58:49 eric Exp $	*/
d195 1
a196 2
			else
				async_set_state(as, ASR_STATE_NEXT_DOMAIN);
a197 22
		else
			async_set_state(as, ASR_STATE_NEXT_DB);
		break;

	case ASR_STATE_NEXT_DOMAIN:

		r = asr_iter_domain(as, as->as.hostnamadr.name, dname,
		    sizeof(dname));
		if (r == -1) {
			async_set_state(as, ASR_STATE_NOT_FOUND);
			break;
		}

		if (as->as.hostnamadr.dname)
			free(as->as.hostnamadr.dname);
		if ((as->as.hostnamadr.dname = strdup(dname)) == NULL) {
			ar->ar_h_errno = NETDB_INTERNAL;
			ar->ar_errno = errno;
			async_set_state(as, ASR_STATE_HALT);
		}

		as->as_db_idx = 0;
d204 1
a204 4
			if (as->as_type == ASR_GETHOSTBYNAME)
				async_set_state(as, ASR_STATE_NEXT_DOMAIN);
			else
				async_set_state(as, ASR_STATE_NOT_FOUND);
d217 2
a218 2
				as->as.hostnamadr.subq = res_query_async_ctx(
				    as->as.hostnamadr.dname,
d246 1
a246 1
				data = as->as.hostnamadr.dname;
d276 1
a276 1
				data = as->as.hostnamadr.dname;
d315 1
d361 4
a364 1
		ar->ar_h_errno = HOST_NOT_FOUND;
@


1.11
log
@Saner implementation for self-contained hostent and netent, and also
a couple of fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.10 2012/11/24 15:12:48 eric Exp $	*/
d30 1
d58 1
d151 1
a151 1
	char			 dname[MAXDNAME], *data;
d176 23
a198 2
		if (as->as_type == ASR_GETHOSTBYNAME)
			async_set_state(as, ASR_STATE_NEXT_DOMAIN);
d405 20
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.9 2012/11/24 13:59:53 eric Exp $	*/
a38 1

d42 7
a48 4
#define HOSTENT_PTR(h) ((char**)(((char*)h) + sizeof (*h)))
#define HOSTENT_POS(h)  HOSTENT_PTR(h)[0]
#define HOSTENT_STOP(h)	HOSTENT_PTR(h)[1]
#define HOSTENT_LEFT(h) (HOSTENT_STOP(h) - HOSTENT_POS(h))
d53 7
a59 6
static struct hostent *hostent_alloc(int);
static int hostent_set_cname(struct hostent *, const char *, int);
static int hostent_add_alias(struct hostent *, const char *, int);
static int hostent_add_addr(struct hostent *, const void *, int);
static struct hostent *hostent_file_match(FILE *, int, int, const char *, int);
static struct hostent *hostent_from_packet(int, int, char *, size_t);
d61 2
a62 2
static struct hostent *_yp_gethostnamadr(int, const void *);
static struct hostent *hostent_from_yp(int, char *);
d146 4
a149 3
	int	r, type;
	FILE	*f;
	char	dname[MAXDNAME], *data;
d253 1
a253 1
			ar->ar_hostent = hostent_file_match(f, as->as_type,
d256 1
a256 1

d258 1
d260 1
a260 1
			if (ar->ar_hostent == NULL) {
d269 1
a269 1

d282 2
a283 2
			ar->ar_hostent = _yp_gethostnamadr(as->as_type, data);
			if (ar->ar_hostent == NULL) {
d292 1
a292 1

d324 1
a324 1
		ar->ar_hostent = hostent_from_packet(as->as_type,
d327 1
a327 2

		if (ar->ar_hostent == NULL) {
d335 1
a335 2
			if (hostent_add_addr(ar->ar_hostent,
			    as->as.hostnamadr.addr,
d337 1
a337 1
				free(ar->ar_hostent);
d350 2
a351 2
		    ar->ar_hostent->h_addr_list[0] == NULL) {
			free(ar->ar_hostent);
d356 1
d388 1
a388 1
static struct hostent *
d393 1
a393 1
	struct	 hostent *h;
d411 3
a413 3
			if (inet_pton(family, tokens[0], addr) == 1)
				if (memcmp(addr, data, datalen) == 0)
					goto found;
d425 1
a425 1
	if (hostent_add_addr(h, addr, h->h_length) == -1)
d436 1
a436 1
static struct hostent *
d439 1
a439 1
	struct hostent	*h;
d506 1
a506 1
static struct hostent *
d509 2
a510 2
	struct hostent	*h;
	size_t		 alloc;
d512 1
a512 1
	alloc = sizeof(*h) + (2 + MAXALIASES + MAXADDRS) * sizeof(char*) + 1024;
d516 6
a521 7
	h->h_addrtype = family;
	h->h_length = (family == AF_INET) ? 4 : 16;
	h->h_aliases = HOSTENT_PTR(h) + 2;
	h->h_addr_list = h->h_aliases + MAXALIASES;

	HOSTENT_STOP(h) = (char*)(h) + alloc;
	HOSTENT_POS(h) = (char*)(h->h_addr_list + MAXADDRS);
d527 1
a527 1
hostent_set_cname(struct hostent *h, const char *name, int isdname)
d530 1
d532 2
a533 2
	if (h->h_name)
		return (0);
a539 2
	if (strlen(name) + 1 >= HOSTENT_LEFT(h))
		return (1);
d541 3
a543 3
	strlcpy(HOSTENT_POS(h), name, HOSTENT_LEFT(h));
	h->h_name = HOSTENT_POS(h);
	HOSTENT_POS(h) += strlen(name) + 1;
d545 3
d552 1
a552 1
hostent_add_alias(struct hostent *h, const char *name, int isdname)
d555 1
a555 1
	size_t	i;
d557 2
a558 2
	for (i = 0; i < MAXALIASES - 1; i++)
		if (h->h_aliases[i] == NULL)
d560 2
a561 2
	if (i == MAXALIASES - 1)
		return (0);
a567 2
	if (strlen(name) + 1 >= HOSTENT_LEFT(h))
		return (1);
d569 3
a571 3
	strlcpy(HOSTENT_POS(h), name, HOSTENT_LEFT(h));
	h->h_aliases[i] = HOSTENT_POS(h);
	HOSTENT_POS(h) += strlen(name) + 1;
d573 3
d580 1
a580 1
hostent_add_addr(struct hostent *h, const void *addr, int size)
d584 2
a585 2
	for (i = 0; i < MAXADDRS - 1; i++)
		if (h->h_addr_list[i] == NULL)
d587 2
a588 2
	if (i == MAXADDRS - 1)
		return (0);
d590 2
a591 6
	if (size >= HOSTENT_LEFT(h))
		return (1);

	memmove(HOSTENT_POS(h), addr, size);
	h->h_addr_list[i] = HOSTENT_POS(h);
	HOSTENT_POS(h) += size;
d593 3
d661 1
a661 1
static struct hostent *
d664 6
a669 6
	static char	*domain = NULL;
	struct hostent	*h = NULL;
	const char	*name;
	char		 buf[MAXHOSTNAMELEN];
	char		*res = NULL;
	int		 r, len;
d713 1
a713 1
static struct hostent *
d716 3
a718 3
	struct hostent	*h;
	char		*next, *tokens[10], addr[IN6ADDRSZ];
	int		 i, ntok;
d735 1
a735 1
		if (!h->h_name)
d737 1
a737 1
		else if (strcmp(h->h_name, tokens[1]))
d743 1
a743 1
	if (h->h_name == NULL) {
@


1.9
log
@make separate structures for pack and unpack
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.8 2012/09/06 15:05:16 eric Exp $	*/
d17 1
a19 1

a22 6
        
#include <err.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
d30 6
d148 1
a148 1
	switch(as->as_state) {
d178 2
a179 1
		r = asr_iter_domain(as, as->as.hostnamadr.name, dname, sizeof(dname));
d207 1
a207 1
		switch(AS_DB(as)) {
d318 1
a318 1
		
d375 1
a375 1
                break;
d385 2
a386 1
hostent_file_match(FILE *f, int reqtype, int family, const char *data, int datalen)
d392 1
a392 1
	for(;;) {
d446 1
a446 1
	for(; hdr.qdcount; hdr.qdcount--)
d448 1
a448 1
	for(; hdr.ancount; hdr.ancount--) {
d599 1
a599 1
	
d698 1
a698 1
	for(cp = line, tp = tokens, ntok = 0;
d718 1
a718 1
	for(next = line; line; line = next) {
@


1.8
log
@include yp headers if necessary.
remove unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.7 2012/09/04 16:03:21 eric Exp $	*/
d434 1
a434 1
	struct packed	 p;
d442 1
a442 1
	packed_init(&p, pkt, pktlen);
@


1.7
log
@implement basic YP support for gethostbyname_async()/gethostbyaddr_async()
by using the blocking YP API internally.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.6 2012/08/19 16:17:40 eric Exp $	*/
d29 6
@


1.6
log
@When building dynamic hostent and netent, allocate a single linear buffer to
hold both the structure and the data. The freehostent() and freenetent() API
functions are not needed anymore.  While there, ensure that the constructed
addr and alias lists are really NULL terminated.
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.5 2012/07/12 13:03:34 eric Exp $	*/
d51 4
d261 24
d646 92
@


1.5
log
@unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.4 2012/07/10 15:58:00 eric Exp $	*/
d37 5
d299 1
a299 1
				freehostent(ar->ar_hostent);
d313 1
a313 1
			freehostent(ar->ar_hostent);
d389 1
a389 1
	freehostent(h);
d462 1
a462 1
	freehostent(h);
d470 1
d472 2
a473 2
	h = calloc(1, sizeof *h);
	if (h == NULL)
a475 6
	h->h_aliases = calloc(MAXALIASES, sizeof *h->h_aliases);
	h->h_addr_list = calloc(MAXADDRS, sizeof *h->h_addr_list);
	if (h->h_aliases == NULL || h->h_addr_list == NULL) {
		freehostent(h);
		return (NULL);
	}
d478 5
d498 1
a498 3
		h->h_name = strdup(buf);
	} else {
		h->h_name = strdup(name);
d500 6
a505 2
	if (h->h_name == NULL)
		return (-1);
d516 1
a516 1
	for (i = 0; i < MAXALIASES; i++)
d519 1
a519 1
	if (i == MAXALIASES)
d525 1
a525 3
		h->h_aliases[i] = strdup(buf);
	} else {
		h->h_aliases[i] = strdup(name);
d527 6
a532 2
	if (h->h_aliases[i] == NULL)
		return (-1);
d542 1
a542 1
	for (i = 0; i < MAXADDRS; i++)
d545 1
a545 1
	if (i == MAXADDRS)
d548 6
a553 4
	h->h_addr_list[i] = malloc(size);
	if (h->h_addr_list[i] == NULL)
		return (-1);
	memmove(h->h_addr_list[i], addr, size);
a556 16

void
freehostent(struct hostent *h)
{
	char **c;

	free(h->h_name);
	for (c = h->h_aliases; *c; c++)
		free(*c);
	free(h->h_aliases);
	for (c = h->h_addr_list; *c; c++)
		free(*c);
	free(h->h_addr_list);
	free(h);
}

@


1.4
log
@simplify the code, improve error handling and plug a potential fd leak on error
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.3 2012/07/10 12:41:54 eric Exp $	*/
d128 1
a128 1
	int	i, n, r, type;
@


1.3
log
@use the value actually passed to the function
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.2 2012/04/25 20:28:25 eric Exp $	*/
d44 2
a45 3
static int hostent_file_match(FILE *, int, int, int, const char *,
    char *, char **, int);
static int hostent_from_packet(struct hostent *, int, char *, size_t);
a127 1
	struct hostent	*e;
d130 1
a130 1
	char	*toks[MAXTOKEN], addr[16], dname[MAXDNAME], *data;
d233 13
a245 5
			if (( n = hostent_file_match(f, as->as_type,
			    as->as.hostnamadr.family,
			    as->as.hostnamadr.addrlen, data, addr,
			    toks, MAXTOKEN)) == -1) {
				fclose(f);
a247 12
			e = hostent_alloc(as->as.hostnamadr.family);
			if (e == NULL) {
				ar->ar_errno = errno;
				ar->ar_h_errno = NETDB_INTERNAL;
				async_set_state(as, ASR_STATE_HALT);
				break;
			}
			hostent_set_cname(e, toks[1], 0);
			for (i = 2; i < n; i ++)
				hostent_add_alias(e, toks[i], 0);
			hostent_add_addr(e, addr, e->h_length);
			fclose(f);
a249 1
			ar->ar_hostent = e;
d278 6
a283 1
		if ((e = hostent_alloc(as->as.hostnamadr.family)) == NULL) {
a285 1
			free(ar->ar_data);
d291 9
a299 5
			e->h_addr_list[0] = malloc(as->as.hostnamadr.addrlen);
			if (e->h_addr_list[0])
				memmove(e->h_addr_list[0],
				    as->as.hostnamadr.addr,
				    as->as.hostnamadr.addrlen);
a301 4
		hostent_from_packet(e, as->as_type, ar->ar_data,
		    ar->ar_datalen);
		free(ar->ar_data);

d307 2
a308 2
		    e->h_addr_list[0] == NULL) {
			freehostent(e);
a313 1
		ar->ar_hostent = e;
d342 1
a342 2
 * name. Split the matching line into tokens in the "token" array and return
 * the number of tokens.
d344 2
a345 3
static int
hostent_file_match(FILE *f, int type, int family, int len, const char *data,
    char *addr, char **tokens, int ntokens)
d347 3
a349 1
	int	n, i;
d352 5
a356 3
		n = asr_parse_namedb_line(f, tokens, ntokens);
		if (n == -1)
			return (-1);
d358 1
a358 1
		if (type == ASR_GETHOSTBYNAME) {
d363 1
a363 1
					return (n);
d365 4
a368 1
			continue;
d370 1
d372 14
a385 4
		if (inet_pton(family, tokens[0], addr) == 1)
			if (memcmp(addr, data, len) == 0)
				return (n);
	}
d391 2
a392 2
static int
hostent_from_packet(struct hostent *h, int action, char *pkt, size_t pktlen)
d394 1
d399 3
a401 1
	int		 r;
d414 7
a420 4
			if (action == ASR_GETHOSTBYNAME)
				r = hostent_add_alias(h, rr.rr_dname, 1);
			else
				r = hostent_set_cname(h, rr.rr_dname, 1);
d424 4
a427 3
			if (action != ASR_GETHOSTBYADDR)
				continue;
			r = hostent_set_cname(h, rr.rr.ptr.ptrname, 1);
d432 3
a434 1
			if (h->h_addrtype != AF_INET)
d436 4
a439 2
			r = hostent_set_cname(h, rr.rr_dname, 1);
			r = hostent_add_addr(h, &rr.rr.in_a.addr, 4);
d443 1
a443 1
			if (h->h_addrtype != AF_INET6)
d445 6
a450 2
			r = hostent_set_cname(h, rr.rr_dname, 1);
			r = hostent_add_addr(h, &rr.rr.in_aaaa.addr6, 16);
d455 4
a458 1
	return (0);
@


1.2
log
@fix a few warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: gethostnamadr_async.c,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
d356 1
a356 1
		n = asr_parse_namedb_line(f, tokens, MAXTOKEN);
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.10 2011/07/13 16:14:43 eric Exp $	*/
d541 1
a541 1
		in_addr = ntohl(*((in_addr_t *)addr));
d550 1
a550 1
		in6_addr = (struct in6_addr *)addr;
@

