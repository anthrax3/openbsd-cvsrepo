head	1.57;
access;
symbols
	OPENBSD_6_2:1.57.0.2
	OPENBSD_6_2_BASE:1.57
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.54.0.2
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.57
date	2017.02.27.10.44.46;	author jca;	state Exp;
branches;
next	1.56;
commitid	MlNq0zVlbx0f2ABQ;

1.56
date	2017.02.23.17.04.02;	author eric;	state Exp;
branches;
next	1.55;
commitid	A5SxxxFpG2Lk4uBi;

1.55
date	2017.02.18.19.23.05;	author jca;	state Exp;
branches;
next	1.54;
commitid	6EwZbn7a3sVTI0GZ;

1.54
date	2016.06.18.15.25.28;	author reyk;	state Exp;
branches;
next	1.53;
commitid	P237EKoLYHFfRrkP;

1.53
date	2016.05.27.11.25.57;	author sthen;	state Exp;
branches;
next	1.52;
commitid	o082Pb71tGiNuUk4;

1.52
date	2016.05.26.06.59.42;	author jmatthew;	state Exp;
branches;
next	1.51;
commitid	eb8nJ45WvpNQo3lq;

1.51
date	2016.02.24.20.52.53;	author eric;	state Exp;
branches;
next	1.50;
commitid	KA8M1uQYM2DFmWNm;

1.50
date	2015.12.16.16.32.30;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	oPoFLo6QaSW21nLc;

1.49
date	2015.11.23.18.04.53;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	OVI7ORhlpJiMawqs;

1.48
date	2015.10.28.21.38.45;	author eric;	state Exp;
branches;
next	1.47;
commitid	qIEvBVRrIDarZ0X2;

1.47
date	2015.10.28.11.52.26;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	wDPrOtVoYILefAYQ;

1.46
date	2015.10.07.13.59.34;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	y9bDEcHtAU9tyNfU;

1.45
date	2015.10.03.22.35.30;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	cWyRO8MVry4Yvtp1;

1.44
date	2015.10.03.09.57.30;	author eric;	state Exp;
branches;
next	1.43;
commitid	mlCldxHCB9oTJwsK;

1.43
date	2015.09.20.14.19.21;	author eric;	state Exp;
branches;
next	1.42;
commitid	QoXCnUzVxYUpwKcZ;

1.42
date	2015.09.20.12.50.58;	author eric;	state Exp;
branches;
next	1.41;
commitid	Fl5WWrlIdxnBU74c;

1.41
date	2015.09.14.11.52.49;	author guenther;	state Exp;
branches;
next	1.40;
commitid	KzuByhRo5iAIKcqw;

1.40
date	2015.09.09.15.49.34;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	ZDWhDXAAMFWxMzBj;

1.39
date	2015.09.02.13.47.47;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	kwVdmfg28TU83M0A;

1.38
date	2015.06.04.19.23.17;	author eric;	state Exp;
branches;
next	1.37;
commitid	bIU7HKMB8ExoKdOm;

1.37
date	2015.05.29.08.49.37;	author eric;	state Exp;
branches;
next	1.36;
commitid	Tf6Q1D724C96QEJe;

1.36
date	2015.05.26.19.28.57;	author eric;	state Exp;
branches;
next	1.35;
commitid	zZUSsmIZVurlTa45;

1.35
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	0DYulI8hhujBHMcR;

1.34
date	2014.09.15.06.15.48;	author guenther;	state Exp;
branches;
next	1.33;
commitid	ztgYHm1nk3mtTyS3;

1.33
date	2014.03.26.18.13.15;	author eric;	state Exp;
branches;
next	1.32;

1.32
date	2014.03.25.19.48.11;	author eric;	state Exp;
branches;
next	1.31;

1.31
date	2013.07.12.14.36.21;	author eric;	state Exp;
branches;
next	1.30;

1.30
date	2013.06.01.15.02.01;	author eric;	state Exp;
branches;
next	1.29;

1.29
date	2013.06.01.14.34.34;	author eric;	state Exp;
branches;
next	1.28;

1.28
date	2013.06.01.12.38.29;	author eric;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.01.09.21.09;	author eric;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.27.17.31.01;	author eric;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.30.12.02.39;	author eric;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.17.19.13.23;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2013.04.17.02.09.18;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.04.11.20.19.16;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2013.04.01.20.41.12;	author eric;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.01.20.22.27;	author eric;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.01.15.49.54;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.31.19.42.10;	author eric;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.30.20.00.08;	author eric;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.30.08.06.42;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.27.07.40.41;	author eric;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.24.15.12.48;	author eric;	state Exp;
branches;
next	1.13;

1.13
date	2012.09.09.16.45.14;	author eric;	state Exp;
branches;
next	1.12;

1.12
date	2012.09.09.12.46.36;	author eric;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.09.12.15.32;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2012.09.09.09.42.06;	author eric;	state Exp;
branches;
next	1.9;

1.9
date	2012.09.07.13.49.43;	author eric;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.06.19.59.09;	author eric;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.06.11.26.34;	author eric;	state Exp;
branches;
next	1.6;

1.6
date	2012.09.05.21.49.12;	author eric;	state Exp;
branches;
next	1.5;

1.5
date	2012.09.05.15.56.13;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2012.08.18.16.48.17;	author eric;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.15.22.25.14;	author eric;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.14.12.06.13;	author eric;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.14.09.24.18;	author eric;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Put a common flags field in the query struct, rather than in some
elements of the union.

This field is for internal asr flags.  The flags in "struct rrset" and
"struct ni" are different kinds of flags.

ok eric@@
@
text
@/*	$OpenBSD: asr.c,v 1.56 2017/02/23 17:04:02 eric Exp $	*/
/*
 * Copyright (c) 2010-2012 Eric Faurot <eric@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>

#include <asr.h>
#include <errno.h>
#include <fcntl.h>
#include <resolv.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "asr_private.h"

#include "thread_private.h"

#define DEFAULT_CONF		"lookup file\n"
#define DEFAULT_LOOKUP		"lookup bind file"

#define RELOAD_DELAY		15 /* seconds */

static void asr_check_reload(struct asr *);
static struct asr_ctx *asr_ctx_create(void);
static void asr_ctx_ref(struct asr_ctx *);
static void asr_ctx_free(struct asr_ctx *);
static int asr_ctx_add_searchdomain(struct asr_ctx *, const char *);
static int asr_ctx_from_file(struct asr_ctx *, const char *);
static int asr_ctx_from_string(struct asr_ctx *, const char *);
static int asr_ctx_parse(struct asr_ctx *, const char *);
static int asr_parse_nameserver(struct sockaddr *, const char *);
static int asr_ndots(const char *);
static void pass0(char **, int, struct asr_ctx *);
static int strsplit(char *, char **, int);
static void asr_ctx_envopts(struct asr_ctx *);
static void *__THREAD_NAME(_asr);

static struct asr *_asr = NULL;

/* Allocate and configure an async "resolver". */
static void *
_asr_resolver(void)
{
	static int	 init = 0;
	struct asr	*asr;

	if (init == 0) {
#ifdef DEBUG
		if (getenv("ASR_DEBUG"))
			_asr_debug = stderr;
#endif
		init = 1;
	}

	if ((asr = calloc(1, sizeof(*asr))) == NULL)
		goto fail;

	asr_check_reload(asr);
	if (asr->a_ctx == NULL) {
		if ((asr->a_ctx = asr_ctx_create()) == NULL)
			goto fail;
		if (asr_ctx_from_string(asr->a_ctx, DEFAULT_CONF) == -1)
			goto fail;
		asr_ctx_envopts(asr->a_ctx);
	}

#ifdef DEBUG
	_asr_dump_config(_asr_debug, asr);
#endif
	return (asr);

    fail:
	if (asr) {
		if (asr->a_ctx)
			asr_ctx_free(asr->a_ctx);
		free(asr);
	}

	return (NULL);
}

/*
 * Free the "asr" async resolver (or the thread-local resolver if NULL).
 * Drop the reference to the current context.
 */
void
_asr_resolver_done(void *arg)
{
	struct asr *asr = arg;
	struct asr **priv;

	if (asr == NULL) {
		priv = _THREAD_PRIVATE(_asr, _asr, &_asr);
		if (*priv == NULL)
			return;
		asr = *priv;
		*priv = NULL;
	}

	_asr_ctx_unref(asr->a_ctx);
	free(asr);
}

/*
 * Cancel an async query.
 */
void
asr_abort(struct asr_query *as)
{
	_asr_async_free(as);
}

/*
 * Resume the "as" async query resolution.  Return one of ASYNC_COND,
 * or ASYNC_DONE and put query-specific return values in the user-allocated
 * memory at "ar".
 */
int
asr_run(struct asr_query *as, struct asr_result *ar)
{
	int	r, saved_errno = errno;

	DPRINT("asr: asr_run(%p, %p) %s ctx=[%p]\n", as, ar,
	    _asr_querystr(as->as_type), as->as_ctx);
	r = as->as_run(as, ar);

	DPRINT("asr: asr_run(%p, %p) -> %s", as, ar, _asr_transitionstr(r));
#ifdef DEBUG
	if (r == ASYNC_COND)
#endif
		DPRINT(" fd=%i timeout=%i", ar->ar_fd, ar->ar_timeout);
	DPRINT("\n");
	if (r == ASYNC_DONE)
		_asr_async_free(as);

	errno = saved_errno;

	return (r);
}
DEF_WEAK(asr_run);

/*
 * Same as above, but run in a loop that handles the fd conditions result.
 */
int
asr_run_sync(struct asr_query *as, struct asr_result *ar)
{
	struct pollfd	 fds[1];
	struct timespec	 pollstart, pollend, elapsed;
	int		 timeout, r, p, saved_errno = errno;

	while ((r = asr_run(as, ar)) == ASYNC_COND) {
		fds[0].fd = ar->ar_fd;
		fds[0].events = (ar->ar_cond == ASR_WANT_READ) ? POLLIN:POLLOUT;

		timeout = ar->ar_timeout;
	again:
		if (clock_gettime(CLOCK_MONOTONIC, &pollstart))
			break;
		p = poll(fds, 1, timeout);
		if (p == -1 && errno == EINTR) {
			if (clock_gettime(CLOCK_MONOTONIC, &pollend))
				break;

			timespecsub(&pollend, &pollstart, &elapsed);
			timeout -= (elapsed.tv_sec * 1000) +
			    (elapsed.tv_nsec / 1000000);
			if (timeout < 1)
				break;
			goto again;
		}

		/*
		 * Otherwise, just ignore the error and let asr_run()
		 * catch the failure.
		 */
	}

	errno = saved_errno;

	return (r);
}
DEF_WEAK(asr_run_sync);

/*
 * Create a new async request of the given "type" on the async context "ac".
 * Take a reference on it so it does not gets deleted while the async query
 * is running.
 */
struct asr_query *
_asr_async_new(struct asr_ctx *ac, int type)
{
	struct asr_query	*as;

	DPRINT("asr: asr_async_new(ctx=%p) type=%i refcount=%i\n", ac, type,
	    ac ? ac->ac_refcount : 0);
	if (ac == NULL || (as = calloc(1, sizeof(*as))) == NULL)
		return (NULL);

	ac->ac_refcount += 1;
	as->as_ctx = ac;
	as->as_fd = -1;
	as->as_type = type;
	as->as_state = ASR_STATE_INIT;

	return (as);
}

/*
 * Free an async query and unref the associated context.
 */
void
_asr_async_free(struct asr_query *as)
{
	DPRINT("asr: asr_async_free(%p)\n", as);

	if (as->as_subq)
		_asr_async_free(as->as_subq);

	switch (as->as_type) {
	case ASR_SEND:
		if (as->as_fd != -1)
			close(as->as_fd);
		if (as->as.dns.obuf && !(as->as_flags & ASYNC_EXTOBUF))
			free(as->as.dns.obuf);
		if (as->as.dns.ibuf)
			free(as->as.dns.ibuf);
		if (as->as.dns.dname)
			free(as->as.dns.dname);
		break;

	case ASR_SEARCH:
		if (as->as.search.name)
			free(as->as.search.name);
		break;

	case ASR_GETRRSETBYNAME:
		if (as->as.rrset.name)
			free(as->as.rrset.name);
		break;

	case ASR_GETHOSTBYNAME:
	case ASR_GETHOSTBYADDR:
		if (as->as.hostnamadr.name)
			free(as->as.hostnamadr.name);
		break;

	case ASR_GETNETBYNAME:
	case ASR_GETNETBYADDR:
		if (as->as.netnamadr.name)
			free(as->as.netnamadr.name);
		break;

	case ASR_GETADDRINFO:
		if (as->as.ai.aifirst)
			freeaddrinfo(as->as.ai.aifirst);
		if (as->as.ai.hostname)
			free(as->as.ai.hostname);
		if (as->as.ai.servname)
			free(as->as.ai.servname);
		if (as->as.ai.fqdn)
			free(as->as.ai.fqdn);
		break;

	case ASR_GETNAMEINFO:
		break;
	}

	_asr_ctx_unref(as->as_ctx);
	free(as);
}

/*
 * Get a context from the given resolver. This takes a new reference to
 * the returned context, which *must* be explicitely dropped when done
 * using this context.
 */
struct asr_ctx *
_asr_use_resolver(void *arg)
{
	struct asr *asr = arg;
	struct asr **priv;

	if (asr == NULL) {
		DPRINT("using thread-local resolver\n");
		priv = _THREAD_PRIVATE(_asr, _asr, &_asr);
		if (*priv == NULL) {
			DPRINT("setting up thread-local resolver\n");
			*priv = _asr_resolver();
		}
		asr = *priv;
	}
	if (asr != NULL) {
		asr_check_reload(asr);
		asr_ctx_ref(asr->a_ctx);
		return (asr->a_ctx);
	}
	return (NULL);
}

static void
asr_ctx_ref(struct asr_ctx *ac)
{
	DPRINT("asr: asr_ctx_ref(ctx=%p) refcount=%i\n", ac, ac->ac_refcount);
	ac->ac_refcount += 1;
}

/*
 * Drop a reference to an async context, freeing it if the reference
 * count drops to 0.
 */
void
_asr_ctx_unref(struct asr_ctx *ac)
{
	DPRINT("asr: asr_ctx_unref(ctx=%p) refcount=%i\n", ac,
	    ac ? ac->ac_refcount : 0);
	if (ac == NULL)
		return;
	if (--ac->ac_refcount)
		return;

	asr_ctx_free(ac);
}

static void
asr_ctx_free(struct asr_ctx *ac)
{
	int i;

	if (ac->ac_domain)
		free(ac->ac_domain);
	for (i = 0; i < ASR_MAXNS; i++)
		free(ac->ac_ns[i]);
	for (i = 0; i < ASR_MAXDOM; i++)
		free(ac->ac_dom[i]);

	free(ac);
}

/*
 * Reload the configuration file if it has changed on disk.
 */
static void
asr_check_reload(struct asr *asr)
{
	struct asr_ctx	*ac;
	struct stat	 st;
	struct timespec	 ts;
	pid_t		 pid;

	pid = getpid();
	if (pid != asr->a_pid) {
		asr->a_pid = pid;
		asr->a_rtime = 0;
	}

	if (clock_gettime(CLOCK_MONOTONIC, &ts) == -1)
		return;

	if ((ts.tv_sec - asr->a_rtime) < RELOAD_DELAY && asr->a_rtime != 0)
		return;
	asr->a_rtime = ts.tv_sec;

	DPRINT("asr: checking for update of \"%s\"\n", _PATH_RESCONF);
	if (stat(_PATH_RESCONF, &st) == -1 ||
	    asr->a_mtime == st.st_mtime ||
	    (ac = asr_ctx_create()) == NULL)
		return;
	asr->a_mtime = st.st_mtime;

	DPRINT("asr: reloading config file\n");
	if (asr_ctx_from_file(ac, _PATH_RESCONF) == -1) {
		asr_ctx_free(ac);
		return;
	}

	asr_ctx_envopts(ac);
	if (asr->a_ctx)
		_asr_ctx_unref(asr->a_ctx);
	asr->a_ctx = ac;
}

/*
 * Construct a fully-qualified domain name for the given name and domain.
 * If "name" ends with a '.' it is considered as a FQDN by itself.
 * Otherwise, the domain, which must be a FQDN, is appended to "name" (it
 * may have a leading dot which would be ignored). If the domain is null,
 * then "." is used. Return the length of the constructed FQDN or (0) on
 * error.
 */
size_t
_asr_make_fqdn(const char *name, const char *domain, char *buf, size_t buflen)
{
	size_t	len;

	if (domain == NULL)
		domain = ".";
	else if ((len = strlen(domain)) == 0)
		return (0);
	else if (domain[len -1] != '.')
		return (0);

	len = strlen(name);
	if (len == 0) {
		if (strlcpy(buf, domain, buflen) >= buflen)
			return (0);
	} else if (name[len - 1] !=  '.') {
		if (domain[0] == '.')
			domain += 1;
		if (strlcpy(buf, name, buflen) >= buflen ||
		    strlcat(buf, ".", buflen) >= buflen ||
		    strlcat(buf, domain, buflen) >= buflen)
			return (0);
	} else {
		if (strlcpy(buf, name, buflen) >= buflen)
			return (0);
	}

	return (strlen(buf));
}

/*
 * Count the dots in a string.
 */
static int
asr_ndots(const char *s)
{
	int n;

	for (n = 0; *s; s++)
		if (*s == '.')
			n += 1;

	return (n);
}

/*
 * Allocate a new empty context.
 */
static struct asr_ctx *
asr_ctx_create(void)
{
	struct asr_ctx	*ac;

	if ((ac = calloc(1, sizeof(*ac))) == NULL)
		return (NULL);

	ac->ac_options = RES_RECURSE | RES_DEFNAMES | RES_DNSRCH;
	ac->ac_refcount = 1;
	ac->ac_ndots = 1;
	ac->ac_family[0] = AF_INET;
	ac->ac_family[1] = AF_INET6;
	ac->ac_family[2] = -1;

	ac->ac_nscount = 0;
	ac->ac_nstimeout = 5;
	ac->ac_nsretries = 4;

	return (ac);
}

struct asr_ctx *
_asr_no_resolver(void)
{
	return asr_ctx_create();
}

/*
 * Add a search domain to the async context.
 */
static int
asr_ctx_add_searchdomain(struct asr_ctx *ac, const char *domain)
{
	char buf[MAXDNAME];

	if (ac->ac_domcount == ASR_MAXDOM)
		return (-1);

	if (_asr_make_fqdn(domain, NULL, buf, sizeof(buf)) == 0)
		return (-1);

	if ((ac->ac_dom[ac->ac_domcount] = strdup(buf)) == NULL)
		return (0);

	ac->ac_domcount += 1;

	return (1);
}

static int
strsplit(char *line, char **tokens, int ntokens)
{
	int	ntok;
	char	*cp, **tp;

	for (cp = line, tp = tokens, ntok = 0;
	    ntok < ntokens && (*tp = strsep(&cp, " \t")) != NULL; )
		if (**tp != '\0') {
			tp++;
			ntok++;
		}

	return (ntok);
}

/*
 * Pass on a split config line.
 */
static void
pass0(char **tok, int n, struct asr_ctx *ac)
{
	int		 i, j, d;
	const char	*e;
	struct sockaddr_storage	ss;

	if (!strcmp(tok[0], "nameserver")) {
		if (ac->ac_nscount == ASR_MAXNS)
			return;
		if (n != 2)
			return;
		if (asr_parse_nameserver((struct sockaddr *)&ss, tok[1]))
			return;
		if ((ac->ac_ns[ac->ac_nscount] = calloc(1, ss.ss_len)) == NULL)
			return;
		memmove(ac->ac_ns[ac->ac_nscount], &ss, ss.ss_len);
		ac->ac_nscount += 1;

	} else if (!strcmp(tok[0], "domain")) {
		if (n != 2)
			return;
		if (ac->ac_domain)
			return;
		ac->ac_domain = strdup(tok[1]);

	} else if (!strcmp(tok[0], "lookup")) {
		/* ensure that each lookup is only given once */
		for (i = 1; i < n; i++)
			for (j = i + 1; j < n; j++)
				if (!strcmp(tok[i], tok[j]))
					return;
		ac->ac_dbcount = 0;
		for (i = 1; i < n && ac->ac_dbcount < ASR_MAXDB; i++) {
			if (!strcmp(tok[i], "yp")) {
				/* silently deprecated */
			} else if (!strcmp(tok[i], "bind"))
				ac->ac_db[ac->ac_dbcount++] = ASR_DB_DNS;
			else if (!strcmp(tok[i], "file"))
				ac->ac_db[ac->ac_dbcount++] = ASR_DB_FILE;
		}
	} else if (!strcmp(tok[0], "search")) {
		/* resolv.conf says the last line wins */
		for (i = 0; i < ASR_MAXDOM; i++) {
			free(ac->ac_dom[i]);
			ac->ac_dom[i] = NULL;
		}
		ac->ac_domcount = 0;
		for (i = 1; i < n; i++)
			asr_ctx_add_searchdomain(ac, tok[i]);

	} else if (!strcmp(tok[0], "family")) {
		if (n == 1 || n > 3)
			return;
		for (i = 1; i < n; i++)
			if (strcmp(tok[i], "inet4") && strcmp(tok[i], "inet6"))
				return;
		for (i = 1; i < n; i++)
			ac->ac_family[i - 1] = strcmp(tok[i], "inet4") ? \
			    AF_INET6 : AF_INET;
		ac->ac_family[i - 1] = -1;

	} else if (!strcmp(tok[0], "options")) {
		for (i = 1; i < n; i++) {
			if (!strcmp(tok[i], "tcp"))
				ac->ac_options |= RES_USEVC;
			else if (!strcmp(tok[i], "edns0"))
				ac->ac_options |= RES_USE_EDNS0;
			else if ((!strncmp(tok[i], "ndots:", 6))) {
				e = NULL;
				d = strtonum(tok[i] + 6, 1, 16, &e);
				if (e == NULL)
					ac->ac_ndots = d;
			}
		}
	}
}

/*
 * Setup an async context with the config specified in the string "str".
 */
static int
asr_ctx_from_string(struct asr_ctx *ac, const char *str)
{
	char		 buf[512], *ch;

	asr_ctx_parse(ac, str);

	if (ac->ac_dbcount == 0) {
		/* No lookup directive */
		asr_ctx_parse(ac, DEFAULT_LOOKUP);
	}

	if (ac->ac_nscount == 0)
		asr_ctx_parse(ac, "nameserver 127.0.0.1");

	if (ac->ac_domain == NULL)
		if (gethostname(buf, sizeof buf) == 0) {
			ch = strchr(buf, '.');
			if (ch)
				ac->ac_domain = strdup(ch + 1);
			else /* Assume root. see resolv.conf(5) */
				ac->ac_domain = strdup("");
		}

	/* If no search domain was specified, use the local subdomains */
	if (ac->ac_domcount == 0)
		for (ch = ac->ac_domain; ch; ) {
			asr_ctx_add_searchdomain(ac, ch);
			ch = strchr(ch, '.');
			if (ch && asr_ndots(++ch) == 0)
				break;
		}

	return (0);
}

/*
 * Setup the "ac" async context from the file at location "path".
 */
static int
asr_ctx_from_file(struct asr_ctx *ac, const char *path)
{
	FILE	*cf;
	char	 buf[4096];
	ssize_t	 r;

	cf = fopen(path, "re");
	if (cf == NULL)
		return (-1);

	r = fread(buf, 1, sizeof buf - 1, cf);
	if (feof(cf) == 0) {
		DPRINT("asr: config file too long: \"%s\"\n", path);
		r = -1;
	}
	fclose(cf);
	if (r == -1)
		return (-1);
	buf[r] = '\0';

	return asr_ctx_from_string(ac, buf);
}

/*
 * Parse lines in the configuration string. For each one, split it into
 * tokens and pass them to "pass0" for processing.
 */
static int
asr_ctx_parse(struct asr_ctx *ac, const char *str)
{
	size_t		 len;
	const char	*line;
	char		 buf[1024];
	char		*tok[10];
	int		 ntok;

	line = str;
	while (*line) {
		len = strcspn(line, "\n\0");
		if (len < sizeof buf) {
			memmove(buf, line, len);
			buf[len] = '\0';
		} else
			buf[0] = '\0';
		line += len;
		if (*line == '\n')
			line++;
		buf[strcspn(buf, ";#")] = '\0';
		if ((ntok = strsplit(buf, tok, 10)) == 0)
			continue;

		pass0(tok, ntok, ac);
	}

	return (0);
}

/*
 * Check for environment variables altering the configuration as described
 * in resolv.conf(5).  Although not documented there, this feature is disabled
 * for setuid/setgid programs.
 */
static void
asr_ctx_envopts(struct asr_ctx *ac)
{
	char	buf[4096], *e;
	size_t	s;

	if (issetugid()) {
		ac->ac_options |= RES_NOALIASES;
		return;
	}

	if ((e = getenv("RES_OPTIONS")) != NULL) {
		strlcpy(buf, "options ", sizeof buf);
		strlcat(buf, e, sizeof buf);
		s = strlcat(buf, "\n", sizeof buf);
		if (s < sizeof buf)
			asr_ctx_parse(ac, buf);
	}

	if ((e = getenv("LOCALDOMAIN")) != NULL) {
		strlcpy(buf, "search ", sizeof buf);
		strlcat(buf, e, sizeof buf);
		s = strlcat(buf, "\n", sizeof buf);
		if (s < sizeof buf)
			asr_ctx_parse(ac, buf);
	}
}

/*
 * Parse a resolv.conf(5) nameserver string into a sockaddr.
 */
static int
asr_parse_nameserver(struct sockaddr *sa, const char *s)
{
	in_port_t	 portno = 53;

	if (_asr_sockaddr_from_str(sa, PF_UNSPEC, s) == -1)
		return (-1);

	if (sa->sa_family == PF_INET)
		((struct sockaddr_in *)sa)->sin_port = htons(portno);
	else if (sa->sa_family == PF_INET6)
		((struct sockaddr_in6 *)sa)->sin6_port = htons(portno);

	return (0);
}

/*
 * Turn a (uncompressed) DNS domain name into a regular nul-terminated string
 * where labels are separated by dots. The result is put into the "buf" buffer,
 * truncated if it exceeds "max" chars. The function returns "buf".
 */
char *
_asr_strdname(const char *_dname, char *buf, size_t max)
{
	const unsigned char *dname = _dname;
	char	*res;
	size_t	 left, n, count;

	if (_dname[0] == 0) {
		strlcpy(buf, ".", max);
		return buf;
	}

	res = buf;
	left = max - 1;
	for (n = 0; dname[0] && left; n += dname[0]) {
		count = (dname[0] < (left - 1)) ? dname[0] : (left - 1);
		memmove(buf, dname + 1, count);
		dname += dname[0] + 1;
		left -= count;
		buf += count;
		if (left) {
			left -= 1;
			*buf++ = '.';
		}
	}
	buf[0] = 0;

	return (res);
}

/*
 * Read and split the next line from the given namedb file.
 * Return -1 on error, or put the result in the "tokens" array of
 * size "ntoken" and returns the number of token on the line.
 */
int
_asr_parse_namedb_line(FILE *file, char **tokens, int ntoken, char *lbuf, size_t sz)
{
	size_t	  len;
	char	 *buf;
	int	  ntok;

    again:
	if ((buf = fgetln(file, &len)) == NULL)
		return (-1);

	if (len >= sz)
		goto again;

	if (buf[len - 1] == '\n')
		len--;
	else {
		memcpy(lbuf, buf, len);
		buf = lbuf;
	}

	buf[len] = '\0';
	buf[strcspn(buf, "#")] = '\0';
	if ((ntok = strsplit(buf, tokens, ntoken)) == 0)
		goto again;

	return (ntok);
}

/*
 * Update the async context so that it uses the next configured DB.
 * Return 0 on success, or -1 if no more DBs is available.
 */
int
_asr_iter_db(struct asr_query *as)
{
	if (as->as_db_idx >= as->as_ctx->ac_dbcount) {
		DPRINT("asr_iter_db: done\n");
		return (-1);
	}

	as->as_db_idx += 1;
	DPRINT("asr_iter_db: %i\n", as->as_db_idx);

	return (0);
}
@


1.56
log
@Put a common subq pointer in the query struct, rather than one in each
element of the union.

ok gilles@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.55 2017/02/18 19:23:05 jca Exp $	*/
d247 1
a247 1
		if (as->as.dns.obuf && !(as->as.dns.flags & ASYNC_EXTOBUF))
@


1.55
log
@Add EDNS0 support.

EDNS allows for various DNS extensions, among which UDP DNS packets size
bigger than 512 bytes.  The default is still to not advertize anything.

ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.54 2016/06/18 15:25:28 reyk Exp $	*/
d239 4
a255 2
		if (as->as.search.subq)
			_asr_async_free(as->as.search.subq);
a260 2
		if (as->as.rrset.subq)
			_asr_async_free(as->as.rrset.subq);
a266 2
		if (as->as.hostnamadr.subq)
			_asr_async_free(as->as.hostnamadr.subq);
a272 2
		if (as->as.netnamadr.subq)
			_asr_async_free(as->as.netnamadr.subq);
a277 2
		if (as->as.ai.subq)
			_asr_async_free(as->as.ai.subq);
a288 2
		if (as->as.ni.subq)
			_asr_async_free(as->as.ni.subq);
@


1.54
log
@Remove duplicated line.

OK eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.53 2016/05/27 11:25:57 sthen Exp $	*/
d606 2
@


1.53
log
@typo fixes; Anthony Coulter
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.52 2016/05/26 06:59:42 jmatthew Exp $	*/
a734 1
		s = strlcat(buf, "\n", sizeof buf);
@


1.52
log
@Calculate elapsed time in poll() and subtract that from the remaining time
when restarting poll() after receiving a signal.

The ruby runtime send signals to threads periodically, so without accounting
for elapsed time, the timeout would never expire if we didn't get a response
from a nameserver.

ok deraadt@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.51 2016/02/24 20:52:53 eric Exp $	*/
d718 1
a718 1
 * in resolv.conf(5).  Altough not documented there, this feature is disabled
@


1.51
log
@Avoid a possible double-free if the "search" keyword is used multiple times.

ok jca@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.50 2015/12/16 16:32:30 deraadt Exp $	*/
d172 2
a173 1
	int		 r, saved_errno = errno;
d178 2
d181 12
a192 2
		r = poll(fds, 1, ar->ar_timeout);
		if (r == -1 && errno == EINTR)
d194 2
@


1.50
log
@Remove support for HOSTALIASES from the resolver.  This "open and parse
any file indicated by an environment variable" feature inside the
resolver is incompatible with what pledge "dns" is trying to be.  It is
a misguided "feature" added way back in history which almost noone uses,
but everyone has to assume the risk from.
ok eric florian kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.49 2015/11/23 18:04:53 deraadt Exp $	*/
d568 1
a568 1
		for (i = 0; i < ASR_MAXDOM; i++)
d570 2
@


1.49
log
@Remove support for "lookup yp" in /etc/resolv.conf.  This historical
wart is incompatible with pledge, because suddenly a "dns" operation
needs "getpw" access to ypbind/ypserv, etc.  file + dns access is
enough for everyone, sorry if you were using that old SunOS 4.x style
mechanism, but it is now gone.
ok semarie millert florian
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.48 2015/10/28 21:38:45 eric Exp $	*/
a38 4
#ifndef ASR_OPT_HOSTALIASES
#define ASR_OPT_HOSTALIASES 1
#endif

a836 43
}

/*
 * Check if the hostname "name" is a user-defined alias as per hostname(7).
 * If so, copies the result in the buffer "abuf" of size "abufsz" and
 * return "abuf". Otherwise return NULL.
 */
char *
_asr_hostalias(struct asr_ctx *ac, const char *name, char *abuf, size_t abufsz)
{
#if ASR_OPT_HOSTALIASES
	FILE	 *fp;
	size_t	  len;
	char	 *file, *buf, *tokens[2];
	int	  ntok;

	if (ac->ac_options & RES_NOALIASES ||
	    asr_ndots(name) != 0 ||
	    issetugid() ||
	    (file = getenv("HOSTALIASES")) == NULL ||
	    (fp = fopen(file, "re")) == NULL)
		return (NULL);

	DPRINT("asr: looking up aliases in \"%s\"\n", file);

	while ((buf = fgetln(fp, &len)) != NULL) {
		if (buf[len - 1] == '\n')
			len--;
		buf[len] = '\0';
		if ((ntok = strsplit(buf, tokens, 2)) != 2)
			continue;
		if (!strcasecmp(tokens[0], name)) {
			if (strlcpy(abuf, tokens[1], abufsz) > abufsz)
				continue;
			DPRINT("asr: found alias \"%s\"\n", abuf);
			fclose(fp);
			return (abuf);
		}
	}

	fclose(fp);
#endif
	return (NULL);
@


1.48
log
@We are always using _PATH_RESCONF, so no need to remember the path on
the resolver.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.47 2015/10/28 11:52:26 deraadt Exp $	*/
d563 3
a565 3
			if (!strcmp(tok[i], "yp"))
				ac->ac_db[ac->ac_dbcount++] = ASR_DB_YP;
			else if (!strcmp(tok[i], "bind"))
@


1.47
log
@Remove support for [addr]:port syntax from the "nameserver" line.
This extension never made it to other systems.  (pledge is also happy
with this.  The idea of DNS @@ any port collides with pledge encouraring
differentiation between DNS and non-DNS sockets)
ok phessler jung sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.46 2015/10/07 13:59:34 deraadt Exp $	*/
a70 1
	const char *conf = _PATH_RESCONF;
a84 4
	/* Use the given config file */
	asr->a_path = strdup(conf);
	if (asr->a_path == NULL)
		goto fail;
a102 1
		free(asr->a_path);
a127 1
	free(asr->a_path);
a370 3
	if (asr->a_path == NULL)
		return;

d384 2
a385 2
	DPRINT("asr: checking for update of \"%s\"\n", asr->a_path);
	if (stat(asr->a_path, &st) == -1 ||
d392 1
a392 1
	if (asr_ctx_from_file(ac, asr->a_path) == -1) {
@


1.46
log
@getaddrinfo_async() shouldn't unconditionally intialize the resolver
via _asr_use_resolver().  If the hint specifies for AI_NUMERICHOST,
create a transient lookup context which won't try to open /etc/reslov.conf
ok eric guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.45 2015/10/03 22:35:30 deraadt Exp $	*/
a752 3
	const char	*estr;
	char		 buf[256];
	char		*port = NULL;
a753 18

	if (*s == '[') {
		strlcpy(buf, s + 1, sizeof buf);
		s = buf;
		port = strchr(buf, ']');
		if (port == NULL)
			return (-1);
		*port++ = '\0';
		if (*port != ':')
			return (-1);
		port++;
	}

	if (port) {
		portno = strtonum(port, 1, USHRT_MAX, &estr);
		if (estr)
			return (-1);
	}
@


1.45
log
@Initially eric developers asr as a side-load style library for async DNS.
When it was integrated as the main resolver, a bunch of strange initialization
code remained.  Start whittling away at this, piece by piece, to make it
more clear.
ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.44 2015/10/03 09:57:30 eric Exp $	*/
d490 6
@


1.44
log
@missing asr* -> _asr* symbol rename for building with debug code

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.43 2015/09/20 14:19:21 eric Exp $	*/
a38 3
#ifndef ASR_OPT_THREADSAFE
#define ASR_OPT_THREADSAFE 1
#endif
a41 9
#ifndef ASR_OPT_ENVOPTS
#define ASR_OPT_ENVOPTS 1
#endif
#ifndef ASR_OPT_RELOADCONF
#define ASR_OPT_RELOADCONF 1
#endif
#ifndef ASR_OPT_ALTCONF
#define ASR_OPT_ALTCONF 1
#endif
a42 1
#if ASR_OPT_THREADSAFE
a43 1
#endif
a61 1
#if ASR_OPT_ENVOPTS
a62 2
#endif
#if ASR_OPT_THREADSAFE
a63 3
#else
#	define _THREAD_PRIVATE(a, b, c)  (c)
#endif
d68 2
a69 2
void *
_asr_resolver(const char *conf)
d71 1
d86 6
a91 11
#if ASR_OPT_ALTCONF
	/* If not setuid/setgid, allow to use an alternate config. */
	if (conf == NULL && !issetugid())
		conf = getenv("ASR_CONFIG");
#endif

	if (conf == NULL)
		conf = _PATH_RESCONF;

	if (conf[0] == '!') {
		/* Use the rest of the string as config file */
d94 1
a94 1
		if (asr_ctx_from_string(asr->a_ctx, conf + 1) == -1)
d96 1
a96 15
	} else {
		/* Use the given config file */
		asr->a_path = strdup(conf);
		if (asr->a_path == NULL)
			goto fail;
		asr_check_reload(asr);
		if (asr->a_ctx == NULL) {
			if ((asr->a_ctx = asr_ctx_create()) == NULL)
				goto fail;
			if (asr_ctx_from_string(asr->a_ctx, DEFAULT_CONF) == -1)
				goto fail;
#if ASR_OPT_ENVOPTS
			asr_ctx_envopts(asr->a_ctx);
#endif
		}
d316 1
a316 1
			*priv = _asr_resolver(NULL);
a373 1
#if ASR_OPT_RELOADCONF
a376 1
#endif
a380 2
#if ASR_OPT_RELOADCONF

a399 4
#else
	if ((ac = asr_ctx_create()) == NULL)
		return;
#endif
a406 1
#if ASR_OPT_ENVOPTS
a407 1
#endif
a706 1
#if ASR_OPT_ENVOPTS
a739 1
#endif
@


1.43
log
@remove bogus includes of err.h
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.42 2015/09/20 12:50:58 eric Exp $	*/
d97 1
a97 1
			asr_debug = stderr;
d138 1
a138 1
	asr_dump_config(asr_debug, asr);
d196 1
a196 1
	    asr_querystr(as->as_type), as->as_ctx);
d199 1
a199 1
	DPRINT("asr: asr_run(%p, %p) -> %s", as, ar, asr_transitionstr(r));
@


1.42
log
@use _PATH_RESCONF directly
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.41 2015/09/14 11:52:49 guenther Exp $	*/
a26 1
#include <err.h>
@


1.41
log
@Wrap <asr.h> so internal calls go direct and all the symbols are weak
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.40 2015/09/09 15:49:34 deraadt Exp $	*/
a59 1
#define DEFAULT_CONFFILE	_PATH_RESCONF
d113 1
a113 1
		conf = DEFAULT_CONFFILE;
@


1.40
log
@Hide all unnecessary asr / resolver related API with _ prefixes.
direction & ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.39 2015/09/02 13:47:47 deraadt Exp $	*/
d214 1
d242 1
@


1.39
log
@use _PATH_RESCONF
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.38 2015/06/04 19:23:17 eric Exp $	*/
d91 1
a91 1
asr_resolver(const char *conf)
d160 1
a160 1
asr_resolver_done(void *arg)
d173 1
a173 1
	asr_ctx_unref(asr->a_ctx);
d184 1
a184 1
	asr_async_free(as);
d208 1
a208 1
		asr_async_free(as);
d248 1
a248 1
asr_async_new(struct asr_ctx *ac, int type)
d270 1
a270 1
asr_async_free(struct asr_query *as)
d287 1
a287 1
			asr_async_free(as->as.search.subq);
d294 1
a294 1
			asr_async_free(as->as.rrset.subq);
d302 1
a302 1
			asr_async_free(as->as.hostnamadr.subq);
d310 1
a310 1
			asr_async_free(as->as.netnamadr.subq);
d317 1
a317 1
			asr_async_free(as->as.ai.subq);
d330 1
a330 1
			asr_async_free(as->as.ni.subq);
d334 1
a334 1
	asr_ctx_unref(as->as_ctx);
d344 1
a344 1
asr_use_resolver(void *arg)
d354 1
a354 1
			*priv = asr_resolver(NULL);
d378 1
a378 1
asr_ctx_unref(struct asr_ctx *ac)
d457 1
a457 1
		asr_ctx_unref(asr->a_ctx);
d470 1
a470 1
asr_make_fqdn(const char *name, const char *domain, char *buf, size_t buflen)
d551 1
a551 1
	if (asr_make_fqdn(domain, NULL, buf, sizeof(buf)) == 0)
d820 1
a820 1
	if (asr_sockaddr_from_str(sa, PF_UNSPEC, s) == -1)
d837 1
a837 1
asr_strdname(const char *_dname, char *buf, size_t max)
d872 1
a872 1
asr_parse_namedb_line(FILE *file, char **tokens, int ntoken, char *lbuf, size_t sz)
d905 1
a905 1
asr_iter_db(struct asr_query *as)
d924 1
a924 1
asr_hostalias(struct asr_ctx *ac, const char *name, char *abuf, size_t abufsz)
@


1.38
log
@make sure to check for resolv.conf update the first time the resolver
is used after pid has changed.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.37 2015/05/29 08:49:37 eric Exp $	*/
d60 1
a60 1
#define DEFAULT_CONFFILE	"/etc/resolv.conf"
@


1.37
log
@fix a possible off-by-one when reading /etc/hosts if it doesn't end
with a newline.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.36 2015/05/26 19:28:57 eric Exp $	*/
d415 1
d422 7
@


1.36
log
@simply use _PATH_HOSTS where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.35 2015/01/16 16:48:51 deraadt Exp $	*/
d864 1
a864 1
asr_parse_namedb_line(FILE *file, char **tokens, int ntoken)
d874 3
d879 4
@


1.35
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.34 2014/09/15 06:15:48 guenther Exp $	*/
a60 1
#define DEFAULT_HOSTFILE	"/etc/hosts"
a523 2

	ac->ac_hostfile = DEFAULT_HOSTFILE;
@


1.34
log
@When fopen()ing internal to libc (the API doesn't support the use
of the resulting FILE *), then pass fopen() the 'e' mode letter to
mark it close-on-exec.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.33 2014/03/26 18:13:15 eric Exp $	*/
d36 1
@


1.33
log
@Make the asr API public.  Install asr.h to /usr/include.h and manpages.
Include tweaks suggested by mpi@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.32 2014/03/25 19:48:11 eric Exp $	*/
d698 1
a698 1
	cf = fopen(path, "r");
d923 1
a923 1
	    (fp = fopen(file, "r")) == NULL)
@


1.32
log
@Cleanup and simplify the API to be exposed.  Use better names for
structures, functions and defines.

discussed with and ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.31 2013/07/12 14:36:21 eric Exp $	*/
d19 1
d24 1
d26 1
a29 1
#include <netdb.h>
a36 1
#include "asr.h"
@


1.31
log
@Make some symbols static and prefix all visible symbols with asr_
to prevent collisions with third-party programs.

suggested by sthen@@, ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.30 2013/06/01 15:02:01 eric Exp $	*/
d89 1
a89 1
struct asr *
d159 1
a159 1
asr_resolver_done(struct asr *asr)
d161 1
d181 1
a181 1
asr_async_abort(struct async *as)
d188 2
a189 2
 * ASYNC_YIELD or ASYNC_DONE and put query-specific return values in
 * the user-allocated memory at "ar".
d192 1
a192 1
asr_async_run(struct async *as, struct async_res *ar)
d196 1
a196 1
	DPRINT("asr: async_run(%p, %p) %s ctx=[%p]\n", as, ar,
d200 1
a200 1
	DPRINT("asr: async_run(%p, %p) -> %s", as, ar, asr_transitionstr(r));
d218 1
a218 1
asr_async_run_sync(struct async *as, struct async_res *ar)
d223 1
a223 1
	while ((r = asr_async_run(as, ar)) == ASYNC_COND) {
d225 1
a225 1
		fds[0].events = (ar->ar_cond == ASYNC_READ) ? POLLIN : POLLOUT;
d231 1
a231 1
		 * Otherwise, just ignore the error and let asr_async_run()
d246 1
a246 1
struct async *
d249 1
a249 1
	struct async	*as;
d269 1
a269 1
asr_async_free(struct async *as)
d343 1
a343 1
asr_use_resolver(struct asr *asr)
d345 1
d891 1
a891 1
asr_iter_db(struct async *as)
@


1.30
log
@Move search domain iteration code in res_search_async.c where it belongs.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.29 2013/06/01 14:34:34 eric Exp $	*/
d90 1
a90 1
async_resolver(const char *conf)
d159 1
a159 1
async_resolver_done(struct asr *asr)
d180 1
a180 1
async_abort(struct async *as)
d182 1
a182 1
	async_free(as);
d191 1
a191 1
async_run(struct async *as, struct async_res *ar)
d206 1
a206 1
		async_free(as);
d217 1
a217 1
async_run_sync(struct async *as, struct async_res *ar)
d222 1
a222 1
	while ((r = async_run(as, ar)) == ASYNC_COND) {
d230 1
a230 1
		 * Otherwise, just ignore the error and let async_run()
d246 1
a246 1
async_new(struct asr_ctx *ac, int type)
d250 1
a250 1
	DPRINT("asr: async_new(ctx=%p) type=%i refcount=%i\n", ac, type,
d268 1
a268 1
async_free(struct async *as)
d270 1
a270 1
	DPRINT("asr: async_free(%p)\n", as);
d285 1
a285 1
			async_free(as->as.search.subq);
d292 1
a292 1
			async_free(as->as.rrset.subq);
d300 1
a300 1
			async_free(as->as.hostnamadr.subq);
d308 1
a308 1
			async_free(as->as.netnamadr.subq);
d315 1
a315 1
			async_free(as->as.ai.subq);
d328 1
a328 1
			async_free(as->as.ni.subq);
d351 1
a351 1
			*priv = async_resolver(NULL);
d811 1
a811 1
	if (sockaddr_from_str(sa, PF_UNSPEC, s) == -1)
@


1.29
log
@Make hostaliases work for gethostbyname() and getaddrinfo() when
looking into /etc/hosts.  Remove the alias check from the search
domain iteration. Instead, take a shortcut to res_query_async_ctx() in
res_search_async_ctx().
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.28 2013/06/01 12:38:29 eric Exp $	*/
a489 17
 * Concatenate a name and a domain name. The result has no trailing dot.
 * Return the resulting string length, or 0 in case of error.
 */
size_t
asr_domcat(const char *name, const char *domain, char *buf, size_t buflen)
{
	size_t	r;

	r = asr_make_fqdn(name, domain, buf, buflen);
	if (r == 0)
		return (0);
	buf[r - 1] = '\0';

	return (r - 1);
}

/*
a899 90
}

enum {
	DOM_INIT,
	DOM_DOMAIN,
	DOM_DONE
};

/*
 * Implement the search domain strategy.
 *
 * This function works as a generator that constructs complete domains in
 * buffer "buf" of size "len" for the given host name "name", according to the
 * search rules defined by the resolving context.  It is supposed to be called
 * multiple times (with the same name) to generate the next possible domain
 * name, if any.
 *
 * It returns -1 if all possibilities have been exhausted, 0 if there was an
 * error generating the next name, or the resulting name length.
 */
int
asr_iter_domain(struct async *as, const char *name, char * buf, size_t len)
{
	switch (as->as_dom_step) {

	case DOM_INIT:
		/* First call */

		/*
		 * If "name" is an FQDN, that's the only result and we
		 * don't try anything else.
		 */
		if (strlen(name) && name[strlen(name) - 1] ==  '.') {
			DPRINT("asr: asr_iter_domain(\"%s\") fqdn\n", name);
			as->as_dom_flags |= ASYNC_DOM_FQDN;
			as->as_dom_step = DOM_DONE;
			return (asr_domcat(name, NULL, buf, len));
		}

		/*
		 * Otherwise, we iterate through the specified search domains.
		 */
		as->as_dom_step = DOM_DOMAIN;
		as->as_dom_idx = 0;

		/*
		 * If "name" as enough dots, use it as-is first, as indicated
		 * in resolv.conf(5).
		 */
		if ((asr_ndots(name)) >= as->as_ctx->ac_ndots) {
			DPRINT("asr: asr_iter_domain(\"%s\") ndots\n", name);
			as->as_dom_flags |= ASYNC_DOM_NDOTS;
			if (strlcpy(buf, name, len) >= len)
				return (0);
			return (strlen(buf));
		}
		/* Otherwise, starts using the search domains */
		/* FALLTHROUGH */

	case DOM_DOMAIN:
		if (as->as_dom_idx < as->as_ctx->ac_domcount) {
			DPRINT("asr: asr_iter_domain(\"%s\") domain \"%s\"\n",
			    name, as->as_ctx->ac_dom[as->as_dom_idx]);
			as->as_dom_flags |= ASYNC_DOM_DOMAIN;
			return (asr_domcat(name,
			    as->as_ctx->ac_dom[as->as_dom_idx++], buf, len));
		}

		/* No more domain to try. */

		as->as_dom_step = DOM_DONE;

		/*
		 * If the name was not tried as an absolute name before,
		 * do it now.
		 */
		if (!(as->as_dom_flags & ASYNC_DOM_NDOTS)) {
			DPRINT("asr: asr_iter_domain(\"%s\") as is\n", name);
			as->as_dom_flags |= ASYNC_DOM_ASIS;
			if (strlcpy(buf, name, len) >= len)
				return (0);
			return (strlen(buf));
		}
		/* Otherwise, we are done. */

	case DOM_DONE:
	default:
		DPRINT("asr: asr_iter_domain(\"%s\") done\n", name);
		return (-1);
	}
@


1.28
log
@Update asr_hostaliases() to make all necessary checks in the function.
Explicitely check for issetguid() before calling getenv().  Also make
asr_hostalias() callable from other parts of asr too.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.27 2013/06/01 09:21:09 eric Exp $	*/
a939 4
#if ASR_OPT_HOSTALIASES
	char	*alias;
#endif

a954 15

#if ASR_OPT_HOSTALIASES
		/*
		 * If "name" has no dots, it might be an alias. If so,
		 * That's also the only result.
		 */
		alias = asr_hostalias(as->as_ctx, name, buf, len);
		if (alias) {
			DPRINT("asr: asr_iter_domain(\"%s\") is alias \"%s\"\n",
			    name, alias);
			as->as_dom_flags |= ASYNC_DOM_HOSTALIAS;
			as->as_dom_step = DOM_DONE;
			return (asr_domcat(alias, NULL, buf, len));
		}
#endif
@


1.27
log
@iterating over the ns list only matters for res_send_async.c, so move
things around.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.26 2013/05/27 17:31:01 eric Exp $	*/
a76 3
#if ASR_OPT_HOSTALIASES
static char *asr_hostalias(const char *, char *, size_t);
#endif
d965 2
a966 3
		if ((as->as_ctx->ac_options & RES_NOALIASES) == 0 &&
		    asr_ndots(name) == 0 &&
		    (alias = asr_hostalias(name, buf, len)) != NULL) {
a1027 1
#if ASR_OPT_HOSTALIASES
d1033 2
a1034 2
static char *
asr_hostalias(const char *name, char *abuf, size_t abufsz)
d1036 1
d1042 5
a1046 2
	file = getenv("HOSTALIASES");
	if (file == NULL || issetugid() != 0 || (fp = fopen(file, "r")) == NULL)
d1067 1
a1069 1
#endif
@


1.26
log
@Add minimal support for _res setup and update.

Change res_init() to initialize the _res structure on first call, and
udpate the global async context if changes were made by the user. All
resolver functions now call res_init() internally.

fixes issue spotted by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.25 2013/04/30 12:02:39 eric Exp $	*/
a916 1
	as->as_ns_idx = 0;
a917 30

	return (0);
}

/*
 * Set the async context nameserver index to the next nameserver of the
 * currently used DB (assuming it is DNS), cycling over the list until the
 * maximum retry counter is reached.  Return 0 on success, or -1 if all
 * nameservers were used.
 */
int
asr_iter_ns(struct async *as)
{
	for (;;) {
		if (as->as_ns_cycles >= as->as_ctx->ac_nsretries)
			return (-1);

		as->as_ns_idx += 1;
		if (as->as_ns_idx <= as->as_ctx->ac_nscount)
			break;
		as->as_ns_idx = 0;
		as->as_ns_cycles++;
		DPRINT("asr: asr_iter_ns(): cycle %i\n", as->as_ns_cycles);
	}

	as->as_timeout = 1000 * (as->as_ctx->ac_nstimeout << as->as_ns_cycles);
	if (as->as_ns_cycles > 0)
		as->as_timeout /= as->as_ctx->ac_nscount;
	if (as->as_timeout < 1000)
		as->as_timeout = 1000;
@


1.25
log
@Do not take external buffers for storing DNS responses in the internal
async API.  That is actually useless and it makes the code more
complicated.  The required buffers are always allocated when needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.24 2013/04/17 19:13:23 otto Exp $	*/
d397 1
a397 1
	for (i = 0; i < ac->ac_nscount; i++)
d399 1
a399 1
	for (i = 0; i < ac->ac_domcount; i++)
d635 1
a635 1
		for (i = 0; i < ac->ac_domcount; i++)
@


1.24
log
@check return value of strdup(), fix mem leak in error path and take
into account that asr_use_resolver() can return NULL; ok tedu@@ eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.23 2013/04/17 02:09:18 deraadt Exp $	*/
d280 1
a280 1
		if (as->as.dns.ibuf && !(as->as.dns.flags & ASYNC_EXTIBUF))
@


1.23
log
@give a timespec a name that is easier to verify
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.22 2013/04/11 20:19:16 otto Exp $	*/
d127 2
d150 1
d175 1
a175 2
	if (asr->a_path)
		free(asr->a_path);
d254 2
a255 2
	    ac->ac_refcount);
	if ((as = calloc(1, sizeof(*as))) == NULL)
d358 6
a363 4

	asr_check_reload(asr);
	asr_ctx_ref(asr->a_ctx);
	return (asr->a_ctx);
d380 4
a383 1
	DPRINT("asr: asr_ctx_unref(ctx=%p) refcount=%i\n", ac, ac->ac_refcount);
@


1.22
log
@Proper access of _THREAD_PRIVATE storage. Avoids a mem leak and reinit
of resolver context for each resolver call for single threaded
programs. With and ok tedu@@ ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.21 2013/04/01 20:41:12 eric Exp $	*/
d407 1
a407 1
	struct timespec	 tp;
d414 1
a414 1
	if (clock_gettime(CLOCK_MONOTONIC, &tp) == -1)
d417 1
a417 1
	if ((tp.tv_sec - asr->a_rtime) < RELOAD_DELAY && asr->a_rtime != 0)
d419 1
a419 1
	asr->a_rtime = tp.tv_sec;
@


1.21
log
@If more than one lookup line is found in resolv.conf, the latest one
takes precedence.  Simplify code while there.

suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.20 2013/04/01 20:22:27 eric Exp $	*/
d164 1
a164 1
		priv = _THREAD_PRIVATE(_asr, asr, &_asr);
d349 1
a349 1
		priv = _THREAD_PRIVATE(_asr, asr, &_asr);
@


1.20
log
@properly check for domain name truncation at various places and fail
if that happens.

prodded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.19 2013/04/01 15:49:54 deraadt Exp $	*/
a611 5
		/* ignore the line if we already set lookup */
		if (ac->ac_dbcount != 0)
			return;
		if (n - 1 > ASR_MAXDB)
			return;
d617 8
a624 12
		for (i = 1; i < n; i++, ac->ac_dbcount++) {
			if (!strcmp(tok[i], "yp")) {
				ac->ac_db[i-1] = ASR_DB_YP;
			} else if (!strcmp(tok[i], "bind")) {
				ac->ac_db[i-1] = ASR_DB_DNS;
			} else if (!strcmp(tok[i], "file")) {
				ac->ac_db[i-1] = ASR_DB_FILE;
			} else {
				/* ignore the line */
				ac->ac_dbcount = 0;
				return;
			}
@


1.19
log
@space cleanup; ok eric
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.18 2013/03/31 19:42:10 eric Exp $	*/
d468 2
a469 1
		strlcpy(buf, domain, buflen);
d473 4
a476 3
		strlcpy(buf, name, buflen);
		strlcat(buf, ".", buflen);
		strlcat(buf, domain, buflen);
d478 2
a479 1
		strlcpy(buf, name, buflen);
d487 1
d970 2
a971 2
 * It returns 0 if it could generate a new domain name, or -1 when all
 * possibilites have been exhausted.
d1025 3
a1027 2
			strlcpy(buf, name, len);
			return (0);
d1052 3
a1054 2
			strlcpy(buf, name, len);
			return (0);
@


1.18
log
@Principle of least astonishment: implement nameserver retry/backoff as
in the former resolver.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.17 2013/03/30 20:00:08 eric Exp $	*/
d446 1
a446 1
/* 
d513 1
a513 1
/* 
d593 1
a593 1
		if (asr_parse_nameserver((struct sockaddr*)&ss, tok[1]))
d802 1
a802 1
 */ 
d845 1
a845 1
char*
@


1.17
log
@Do not assume local nameserver if resolv.conf doesn't exist, just use
/etc/hosts.

discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.16 2013/03/30 08:06:42 otto Exp $	*/
d534 2
a535 2
	ac->ac_nstimeout = 1000;
	ac->ac_nsretries = 3;
d941 6
@


1.16
log
@don't ever skip reload the very first time; detective work by rpe@@; ok eric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.15 2013/03/27 07:40:41 eric Exp $	*/
d60 1
a60 1
#define DEFAULT_CONF		"lookup bind file\nnameserver 127.0.0.1\n"
@


1.15
log
@Only use the search domains for DNS lookups, as the current resolver does.
Better not diverge too much in behavior at this point.
Typo fix and doc update while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.14 2012/11/24 15:12:48 eric Exp $	*/
d417 1
a417 1
	if ((tp.tv_sec - asr->a_rtime) < RELOAD_DELAY)
@


1.14
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.13 2012/09/09 16:45:14 eric Exp $	*/
a303 2
		if (as->as.hostnamadr.dname)
			free(as->as.hostnamadr.dname);
@


1.13
log
@tweak options
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.12 2012/09/09 12:46:36 eric Exp $	*/
d17 1
a19 1

d223 1
a223 1
	while((r = async_run(as, ar)) == ASYNC_COND) {
d272 1
a272 1
	switch(as->as_type) {
d277 1
a277 1
			free (as->as.dns.obuf);
d279 1
a279 1
			free (as->as.dns.ibuf);
d381 1
a381 1
	
d392 1
a392 1
	for(i = 0; i < ac->ac_nscount; i++)
d394 1
a394 1
	for(i = 0; i < ac->ac_domcount; i++)
d408 1
a408 1
        struct stat	 st;
d508 1
a508 1
	for(n = 0; *s; s++)
d570 1
a570 1
	for(cp = line, tp = tokens, ntok = 0;
d616 2
a617 2
		for(i = 1; i < n; i++)
			for(j = i + 1; j < n; j++)
d620 1
a620 1
		for(i = 1; i < n; i++, ac->ac_dbcount++) {
d635 1
a635 1
		for(i = 0; i < ac->ac_domcount; i++)
d638 1
a638 1
		for(i = 1; i < n; i++)
d653 1
a653 1
		for(i = 1; i < n; i++) {
d695 1
a695 1
		for(ch = ac->ac_domain; ch; ) {
d728 1
a728 1
 
d824 1
a824 1
	
d889 1
a889 1
  again:
d972 1
a972 1
	switch(as->as_dom_step) {
d1052 1
a1052 1
	}	
@


1.12
log
@allow to disable some features at build time
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.11 2012/09/09 12:15:32 eric Exp $	*/
d39 1
a39 1
#	define ASR_OPT_THREADSAFE 1
d42 1
a42 1
#	define ASR_OPT_HOSTALIASES 1
d45 1
a45 1
#	define ASR_OPT_ENVOPTS 1
d48 4
a51 1
#	define ASR_OPT_RELOADCONF 1
d109 1
d113 1
@


1.11
log
@cleanup asr_debug.c
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.10 2012/09/09 09:42:06 eric Exp $	*/
d37 15
d53 1
a70 1
static char *asr_hostalias(const char *, char *, size_t);
a71 1
static void asr_ctx_envopts(struct asr_ctx *);
d74 11
a85 1
static void *__THREAD_NAME(_asr);
d128 1
d130 1
d401 2
a403 1
	struct asr_ctx	*ac;
d405 1
d410 1
d424 4
d435 1
d437 1
d761 1
d795 1
d963 1
d965 1
d983 1
d997 1
d1050 1
d1088 1
@


1.10
log
@use proper macros for debug traces.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.9 2012/09/07 13:49:43 eric Exp $	*/
d109 1
a109 1
	asr_dump(asr);
d170 1
d172 3
a174 4
		DPRINT(" fd=%i timeout=%i\n", ar->ar_fd, ar->ar_timeout);
	else
		DPRINT("\n");

@


1.9
log
@return value has no use; make it void.
fix comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.8 2012/09/06 19:59:09 eric Exp $	*/
d71 1
a72 1
	if (init == 0) {
d74 2
a75 1
			asr_debug = 1;
d78 1
a78 1
#endif
d165 2
a166 4
#ifdef DEBUG
	asr_printf("asr: async_run(%p, %p) %s ctx=[%p]\n",
		as, ar, asr_querystr(as->as_type), as->as_ctx);
#endif
d169 6
a174 12
#ifdef DEBUG
	if (asr_debug) {
		asr_printf("asr: async_run(%p, %p) -> %s", as, ar,
		    asr_transitionstr(r));
		if (r == ASYNC_COND)
			asr_printf(" fd=%i timeout=%i\n",
			    ar->ar_fd, ar->ar_timeout);
		else
			asr_printf("\n");
		fflush(stderr);
	}
#endif
d219 3
a221 4
#ifdef DEBUG
	asr_printf("asr: async_new(ctx=%p) type=%i refcount=%i\n",
	    ac, type, ac->ac_refcount);
#endif
d240 1
a240 3
#ifdef DEBUG
	asr_printf("asr: async_free(%p)\n", as);
#endif
d319 1
a319 4
		/* Use the thread-local resolver. */
#ifdef DEBUG
		asr_printf("using thread-local resolver\n");
#endif
d322 1
a322 3
#ifdef DEBUG
			asr_printf("setting up thread-local resolver\n");
#endif
d336 1
a336 4
#ifdef DEBUG
	asr_printf("asr: asr_ctx_ref(ctx=%p) refcount=%i\n",
	    ac, ac->ac_refcount);
#endif
d347 1
a347 4
#ifdef DEBUG
	asr_printf("asr: asr_ctx_unref(ctx=%p) refcount=%i\n",
	    ac, ac->ac_refcount);
#endif
d389 1
a389 4
#ifdef DEBUG
	asr_printf("asr: checking for update of \"%s\"\n", asr->a_path);
#endif

d396 1
a396 4
#ifdef DEBUG
	asr_printf("asr: reloading config file\n");
#endif

d681 1
a681 3
#ifdef DEBUG
		asr_printf("asr: config file too long: \"%s\"\n", path);
#endif
d870 1
a870 3
#ifdef DEBUG
		asr_printf("asr_iter_db: done\n");
#endif
d876 2
a877 3
#ifdef DEBUG
	asr_printf("asr_iter_db: %i\n", as->as_db_idx);
#endif
d899 1
a899 3
#ifdef DEBUG
		asr_printf("asr: asr_iter_ns(): cycle %i\n", as->as_ns_cycles);
#endif
d938 1
a938 3
#ifdef DEBUG
			asr_printf("asr: asr_iter_domain(\"%s\") fqdn\n", name);
#endif
d951 2
a952 4
#ifdef DEBUG
			asr_printf("asr: asr_iter_domain(\"%s\") is alias "
			    "\"%s\"\n", name, alias);
#endif
d969 1
a969 4
#ifdef DEBUG
			asr_printf("asr: asr_iter_domain(\"%s\") ndots\n",
			    name);
#endif
d979 2
a980 5
#ifdef DEBUG
			asr_printf("asr: asr_iter_domain(\"%s\") "
			    "domain \"%s\"\n", name,
			    as->as_ctx->ac_dom[as->as_dom_idx]);
#endif
d995 1
a995 4
#ifdef DEBUG
			asr_printf("asr: asr_iter_domain(\"%s\") as is\n",
			    name);
#endif
d1004 1
a1004 3
#ifdef DEBUG
		asr_printf("asr: asr_iter_domain(\"%s\") done\n", name);
#endif
d1026 1
a1026 3
#ifdef DEBUG
	asr_printf("asr: looking up aliases in \"%s\"\n", file);
#endif
d1037 1
a1037 3
#ifdef DEBUG
			asr_printf("asr: found alias \"%s\"\n", abuf);
#endif
@


1.8
log
@config parsing is done in one pass now. no need to use callback anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.7 2012/09/06 11:26:34 eric Exp $	*/
d58 1
a58 1
static int pass0(char **, int, struct asr_ctx *);
d570 1
a570 1
static int
d579 1
a579 1
			return (0);
d581 1
a581 1
			return (0);
d583 1
a583 1
			return (0);
d585 1
a585 1
			return (0);
d591 1
a591 1
			return (0);
d593 1
a593 1
			return (0);
d599 1
a599 1
			return (0);
d601 1
a601 1
			return (0);
d606 1
a606 1
					return (0);
d617 1
a617 1
				return (0);
d630 1
a630 1
			return (0);
d633 1
a633 1
				return (0);
a650 2

	return (0);
d722 2
a723 4
 * Parse a configuration string.  Lines are read one by one, comments are
 * stripped and the remaining line is split into tokens which are passed
 * to the "cb" callback function.  Parsing stops if the callback returns
 * non-zero.
d749 1
a749 2
		if (pass0(tok, ntok, ac))
			break;
@


1.7
log
@add a strsplit() helper to factorize code a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.6 2012/09/05 21:49:12 eric Exp $	*/
d53 1
a53 2
static int asr_ctx_parse(const char*, int(*)(char**, int, struct asr_ctx*),
    struct asr_ctx *);
d663 1
a663 1
	asr_ctx_parse(str, pass0, ac);
d667 1
a667 1
		asr_ctx_parse(DEFAULT_LOOKUP, pass0, ac);
d671 1
a671 1
		asr_ctx_parse("nameserver 127.0.0.1", pass0, ac);
d730 1
a730 2
asr_ctx_parse(const char *str, int (*cb)(char**, int, struct asr_ctx*),
    struct asr_ctx *ac)
d753 1
a753 1
		if (cb(tok, ntok, ac))
d782 1
a782 1
			asr_ctx_parse(buf, pass0, ac);
d790 1
a790 1
			asr_ctx_parse(buf, pass0, ac);
@


1.6
log
@Get rid of the hostaddr_async subquery and merge its behaviour
directly into getaddrinfo_async_run.  Simplifies everything by
a great deal.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.5 2012/09/05 15:56:13 eric Exp $	*/
d60 1
d552 16
d737 1
a737 1
	char		*tok[10], **tp, *cp;
d752 1
a752 9
		for(cp = buf, tp = tok, ntok = 0;
		    tp < &tok[10] && (*tp = strsep(&cp, " \t")) != NULL; )
			if (**tp != '\0') {
				tp++;
				ntok++;
			}
		*tp = NULL;

		if (tok[0] == NULL)
d880 1
a880 1
	char	 *buf, *cp, **tp;
d892 1
a892 8
	for(cp = buf, tp = tokens, ntok = 0;
	    ntok < ntoken && (*tp = strsep(&cp, " \t")) != NULL;)
		if (**tp != '\0') {
			tp++;
			ntok++;
		}
	*tp = NULL;
	if (tokens[0] == NULL)
d1075 1
a1075 1
	char	 *file, *buf, *cp, **tp, *tokens[2];
d1090 1
a1090 7
		for(cp = buf, tp = tokens, ntok = 0;
		    ntok < 2 && (*tp = strsep(&cp, " \t")) != NULL; )
			if (**tp != '\0') {
				tp++;
				ntok++;
			}
		if (ntok != 2)
@


1.5
log
@Make hostaddr_async() return a linked list of struct addrinfo.  First
round of a getaddrinfo_async() simplification. The goal is to make YP
support easier to add, and eventually remove the whole hostaddr_async
subquery.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.4 2012/08/18 16:48:17 eric Exp $	*/
d304 2
a310 9
		break;

	case ASR_HOSTADDR:
		if (as->as.ai.hostname)
			free(as->as.ai.hostname);
		if (as->as.ai.subq)
			async_free(as->as.ai.subq);
		if (as->as.ai.aifirst)
			freeaddrinfo(as->as.ai.aifirst);
@


1.4
log
@ensure that async_run() and async_run_sync() always preserve errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.3 2012/04/15 22:25:14 eric Exp $	*/
d312 6
a317 8
		if (as->as.host.name)
			free(as->as.host.name);
		if (as->as.host.subq)
			async_free(as->as.host.subq);
		if (as->as.host.pkt)
			free(as->as.host.pkt);
		if (as->as.host.file)
			fclose(as->as.host.file);
@


1.3
log
@Create a new resolver for each thread.  It will be done differently
eventually, but it's enough for now to make the blocking API fully
thread-safe without locking.
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.2 2012/04/14 12:06:13 eric Exp $	*/
d162 1
a162 1
	int	r;
d185 2
d196 2
a197 2
	struct pollfd		 fds[1];
	int			 r;
d206 4
a209 2
		if (r == -1) /* XXX Is it possible? and what to do if so? */
			err(1, "poll");
d211 2
@


1.2
log
@only define DEBUG internally
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.1 2012/04/14 09:24:18 eric Exp $	*/
d37 1
d61 2
a62 1
static struct asr * _default_resolver = NULL;
d129 2
d132 2
a133 1
		if (_default_resolver == NULL)
d135 2
a136 2
		asr = _default_resolver;
		_default_resolver = NULL;
d329 2
d332 12
a343 9
		/* We want the use the global resolver. */

		/* _THREAD_PRIVATE_MUTEX_LOCK(_asr_mutex); */
		if (_default_resolver != NULL)
			asr_check_reload(asr);
		else
			_default_resolver = async_resolver(NULL);
		asr = _default_resolver;
		/* _THREAD_PRIVATE_MUTEX_UNLOCK(_asr_mutex); */
@


1.1
log
@Import asr, an experimental async resolver implementation.
The idea is to eventually replace the existing resolver with
something better. Time to start working on it in tree.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asr.c,v 1.10 2011/07/13 16:14:43 eric Exp $	*/
d897 1
a897 1
#if DEBUG
d905 1
a905 1
#if DEBUG
d929 1
a929 1
#if DEBUG
d970 1
a970 1
#if DEBUG
d985 1
a985 1
#if DEBUG
@

