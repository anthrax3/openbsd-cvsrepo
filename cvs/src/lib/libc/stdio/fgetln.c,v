head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.6
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.7.0.20
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.16
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.14
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.12
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.10
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.8
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.6
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.4
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.24
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.22
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2017.03.17.14.53.08;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	bQ84PWVgZi7suGTT;

1.16
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.15;
commitid	pqjnYVtACzQ9ctai;

1.15
date	2016.08.25.19.21.33;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	mJDoEis3tkoHOxWZ;

1.14
date	2015.08.31.02.53.57;	author guenther;	state Exp;
branches;
next	1.13;
commitid	lTMF8Y3C9fQGd6jQ;

1.13
date	2015.01.05.21.58.52;	author millert;	state Exp;
branches;
next	1.12;
commitid	G5HcVFR7wCDEV6UJ;

1.12
date	2013.11.12.07.04.06;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.21.09.53.44;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.09.00.18.27;	author kurt;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.22.01.23.16;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.21.16.04.23;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.08.08.05.36;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.28.04.34.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.28.18.12.44;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.20.18.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.14.21.34.58;	author todd;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.32.29;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Use recallocarray() to avoid leaving detritus in memory when resizing
buffers.  We don't bother doing this for objects containing pointers,
but focus on controllable data.
ok millert
@
text
@/*	$OpenBSD: fgetln.c,v 1.16 2016/09/21 04:38:56 guenther Exp $ */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "local.h"

/*
 * Expand the line buffer.  Return -1 on error.
 */
static int
__slbexpand(FILE *fp, size_t newsize)
{
	void *p;

	if (fp->_lb._size >= newsize)
		return (0);
	if ((p = recallocarray(fp->_lb._base, fp->_lb._size, newsize, 1)) == NULL)
		return (-1);
	fp->_lb._base = p;
	fp->_lb._size = newsize;
	return (0);
}

/*
 * Get an input line.  The returned pointer often (but not always)
 * points into a stdio buffer.  Fgetline does not alter the text of
 * the returned line (which is thus not a C string because it will
 * not necessarily end with '\0'), but does allow callers to modify
 * it if they wish.  Thus, we set __SMOD in case the caller does.
 */
char *
fgetln(FILE *fp, size_t *lenp)
{
	unsigned char *p;
	char *ret;
	size_t len;
	size_t off;

	FLOCKFILE(fp);
	_SET_ORIENTATION(fp, -1);

	/* make sure there is input */
	if (fp->_r <= 0 && __srefill(fp))
		goto error;

	/* look for a newline in the input */
	if ((p = memchr(fp->_p, '\n', fp->_r)) != NULL) {
		/*
		 * Found one.  Flag buffer as modified to keep fseek from
		 * `optimising' a backward seek, in case the user stomps on
		 * the text.
		 */
		p++;		/* advance over it */
		ret = (char *)fp->_p;
		*lenp = len = p - fp->_p;
		fp->_flags |= __SMOD;
		fp->_r -= len;
		fp->_p = p;
		FUNLOCKFILE(fp);
		return (ret);
	}

	/*
	 * We have to copy the current buffered data to the line buffer.
	 * As a bonus, though, we can leave off the __SMOD.
	 *
	 * OPTIMISTIC is length that we (optimistically) expect will
	 * accommodate the `rest' of the string, on each trip through the
	 * loop below.
	 */
#define OPTIMISTIC 80

	for (len = fp->_r, off = 0;; len += fp->_r) {
		size_t diff;

		/*
		 * Make sure there is room for more bytes.  Copy data from
		 * file buffer to line buffer, refill file and look for
		 * newline.  The loop stops only when we find a newline.
		 */
		if (__slbexpand(fp, len + OPTIMISTIC))
			goto error;
		(void)memcpy(fp->_lb._base + off, fp->_p, len - off);
		off = len;
		if (__srefill(fp)) {
			if (fp->_flags & __SEOF)
				break;
			goto error;
		}
		if ((p = memchr(fp->_p, '\n', fp->_r)) == NULL)
			continue;

		/* got it: finish up the line (like code above) */
		p++;
		diff = p - fp->_p;
		len += diff;
		if (__slbexpand(fp, len))
			goto error;
		(void)memcpy(fp->_lb._base + off, fp->_p, diff);
		fp->_r -= diff;
		fp->_p = p;
		break;
	}
	*lenp = len;
	ret = (char *)fp->_lb._base;
	FUNLOCKFILE(fp);
	return (ret);

error:
	FUNLOCKFILE(fp);
	*lenp = 0;
	return (NULL);
}
DEF_WEAK(fgetln);
@


1.16
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fgetln.c,v 1.15 2016/08/25 19:21:33 schwarze Exp $ */
d49 1
a49 1
	if ((p = realloc(fp->_lb._base, newsize)) == NULL)
@


1.15
log
@After read errors, fgetln(3) sometimes succeeded (returning non-NULL)
and failed (setting errno and ferror(3)) both at the same time.
That's a bad idea in general, and here in particular since
returning partial lines was neither reliable (sometimes, you
got NULL anyway) nor predictable (almost always, the line would
be truncated long before the actual read error).
Instead, on read failure, fail properly and always return NULL.
Issue found in a discussion with Andrey Chernov <ache at freebsd dot org>
who finally agreed to move FreeBSD into the same direction.
The fix is joint work with and OK by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fgetln.c,v 1.14 2015/08/31 02:53:57 guenther Exp $ */
d79 1
a79 1
	if ((p = memchr((void *)fp->_p, '\n', fp->_r)) != NULL) {
d115 1
a115 2
		(void)memcpy((void *)(fp->_lb._base + off), (void *)fp->_p,
		    len - off);
d122 1
a122 1
		if ((p = memchr((void *)fp->_p, '\n', fp->_r)) == NULL)
d131 1
a131 2
		(void)memcpy((void *)(fp->_lb._base + off), (void *)fp->_p,
		    diff);
@


1.14
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fgetln.c,v 1.13 2015/01/05 21:58:52 millert Exp $ */
d118 5
a122 2
		if (__srefill(fp))
			break;	/* EOF or error: return partial line */
@


1.13
log
@Remove #ifdef notdef bits--we are not going to change the fgetln()
API to NUL-terminate the buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: fgetln.c,v 1.12 2013/11/12 07:04:06 deraadt Exp $ */
d145 1
@


1.12
log
@both files contain a function which should only be static.
not cranking libc over this (unless an issue is found in ports)
@
text
@d1 1
a1 1
/*	$OpenBSD: fgetln.c,v 1.11 2009/11/21 09:53:44 guenther Exp $ */
a40 4
#ifdef notdef
 * The `new size' does not account for a terminating '\0',
 * so we add 1 here.
#endif
a46 3
#ifdef notdef
	++newsize;
#endif
a136 3
#ifdef notdef
	ret[len] = '\0';
#endif
a140 1
	*lenp = 0;		/* ??? */
d142 2
a143 1
	return (NULL);		/* ??? */
@


1.11
log
@Several stdio functions were failing to set the stream orientation
to 'narrow' as they should.

"looks correct" millert@@  "makes sense" blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fgetln.c,v 1.10 2009/11/09 00:18:27 kurt Exp $ */
d46 1
a46 1
int
@


1.10
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

committing on behalf of and okay guenther@@ now that we have install
media space available.
@
text
@d1 1
a1 1
/*	$OpenBSD: fgetln.c,v 1.9 2009/10/22 01:23:16 guenther Exp $ */
d79 1
@


1.9
log
@Back out previous commit, as it caused too much growth for the install
media to fit
@
text
@d1 1
a1 1
/*	$OpenBSD: fgetln.c,v 1.8 2009/10/21 16:04:23 guenther Exp $ */
d74 1
d78 2
d81 2
a82 4
	if (fp->_r <= 0 && __srefill(fp)) {
		*lenp = 0;
		return (NULL);
	}
a85 2
		char *ret;

d97 1
d142 1
d144 1
a144 1
	fp->_lb._base[len] = '\0';
d146 2
a147 1
	return ((char *)fp->_lb._base);
d151 1
@


1.8
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

ok kurt@@, earlier version tested by sthen@@ and jj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fgetln.c,v 1.7 2005/08/08 08:05:36 espie Exp $ */
a73 1
	char *ret;
a76 2
	FLOCKFILE(fp);

d78 4
a81 2
	if (fp->_r <= 0 && __srefill(fp))
		goto error;
d85 2
a97 1
		FUNLOCKFILE(fp);
a141 1
	ret = (char *)fp->_lb._base;
d143 1
a143 1
	ret[len] = '\0';
d145 1
a145 2
	FUNLOCKFILE(fp);
	return (ret);
a148 1
	FUNLOCKFILE(fp);
@


1.7
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d74 1
d78 2
d81 2
a82 4
	if (fp->_r <= 0 && __srefill(fp)) {
		*lenp = 0;
		return (NULL);
	}
a85 2
		char *ret;

d97 1
d142 1
d144 1
a144 1
	fp->_lb._base[len] = '\0';
d146 2
a147 1
	return ((char *)fp->_lb._base);
d151 1
@


1.6
log
@Use '\0' not 0 when storing as a char, part from Andrey Matveev.
@
text
@d1 1
a32 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: fgetln.c,v 1.5 2004/09/28 18:12:44 otto Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.5
log
@deregister + ansify, no change in object code. ok deraadt@@ millert@@
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: fgetln.c,v 1.4 2003/06/02 20:18:37 millert Exp $";
d146 1
a146 1
	fp->_lb._base[len] = 0;
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: fgetln.c,v 1.3 2002/06/14 21:34:58 todd Exp $";
d50 1
a50 3
__slbexpand(fp, newsize)
	FILE *fp;
	size_t newsize;
d74 1
a74 3
fgetln(fp, lenp)
	register FILE *fp;
	size_t *lenp;
d76 2
a77 2
	register unsigned char *p;
	register size_t len;
d88 1
a88 1
		register char *ret;
d115 1
a115 1
		register size_t diff;
@


1.3
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char *rcsid = "$OpenBSD: fgetln.c,v 1.2 1996/08/19 08:32:29 tholo Exp $";
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: fgetln.c,v 1.1.1.1 1995/10/18 08:42:11 deraadt Exp $";
d117 1
a117 1
	 * accomodate the `rest' of the string, on each trip through the
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: fgetln.c,v 1.2 1995/02/02 02:09:10 jtc Exp $	*/

d38 1
a38 2
/* from: static char sccsid[] = "@@(#)fgetline.c	8.1 (Berkeley) 6/4/93"; */
static char *rcsid = "$Id: fgetln.c,v 1.2 1995/02/02 02:09:10 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
