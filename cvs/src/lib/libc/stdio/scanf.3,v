head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.14
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.10
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.12
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.4
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.8
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.6
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.20.0.6
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.4
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.8
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.6
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.6
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.10
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.8
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@.\" @;


1.22
date	2013.07.17.05.42.11;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.05.17.19.06;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.18.14.01.38;	author stsp;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.02.22.29.07;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.03.17.57.47;	author martynas;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.05.19.29.28;	author martynas;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.31.19.19.31;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.13.17.56.18;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.26.03.30.25;	author jaredy;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.26.03.27.04;	author jaredy;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.26.16.24.56;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.20.18.37;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.24.00.30.59;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.31.22.20.56;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.27.04.16.51;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.20.01.39.32;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.18.03.01.35;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.04.22.19.31;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	99.07.02.20.58.00;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	99.05.16.19.55.09;	author alex;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.33.03;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.14;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@more library history
facts checked by sobrado@@
style tweaks and ok jmc@@
@
text
@.\"	$OpenBSD: scanf.3,v 1.21 2013/03/05 17:19:06 otto Exp $
.\"
.\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek and the American National Standards Committee X3,
.\" on Information Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.Dd $Mdocdate: March 5 2013 $
.Dt SCANF 3
.Os
.Sh NAME
.Nm scanf ,
.Nm fscanf ,
.Nm sscanf ,
.Nm vscanf ,
.Nm vsscanf ,
.Nm vfscanf
.Nd input format conversion
.Sh SYNOPSIS
.In stdio.h
.Ft int
.Fn scanf "const char *format" ...
.Ft int
.Fn fscanf "FILE *stream" "const char *format" ...
.Ft int
.Fn sscanf "const char *str" "const char *format" ...
.In stdarg.h
.Ft int
.Fn vscanf "const char *format" "va_list ap"
.Ft int
.Fn vsscanf "const char *str" "const char *format" "va_list ap"
.Ft int
.Fn vfscanf "FILE *stream" "const char *format" "va_list ap"
.Sh DESCRIPTION
The
.Fn scanf
family of functions read input according to the given
.Fa format
as described below.
This format may contain
.Dq conversion specifiers ;
the results of such conversions, if any, are stored through a set of pointer
arguments.
.Pp
The
.Fn scanf
function reads input from the standard input stream
.Em stdin ,
.Fn fscanf
reads input from the supplied stream pointer
.Fa stream ,
and
.Fn sscanf
reads its input from the character string pointed to by
.Fa str .
.Pp
The
.Fn vfscanf
function is analogous to
.Xr vfprintf 3
and reads input from the stream pointer
.Fa stream
using a variable argument list of pointers (see
.Xr stdarg 3 ) .
The
.Fn vscanf
function scans a variable argument list from the standard input and the
.Fn vsscanf
function scans it from a string; these are analogous to the
.Fn vprintf
and
.Fn vsprintf
functions, respectively.
.Pp
Each successive
.Em pointer
argument must correspond properly with each successive conversion specifier
(but see the
.Cm *
conversion below).
All conversions are introduced by the
.Cm %
(percent sign) character.
The
.Fa format
string may also contain other characters.
Whitespace (such as blanks, tabs, or newlines) in the
.Fa format
string match any amount of whitespace, including none, in the input.
Everything else matches only itself.
Scanning stops when an input character does not match such a format character.
Scanning also stops when an input conversion cannot be made (see below).
.Sh CONVERSIONS
Following the
.Cm %
character, introducing a conversion, there may be a number of
.Em flag
characters, as follows:
.Bl -tag -width "ll (ell ell)"
.It Cm *
Suppresses assignment.
The conversion that follows occurs as usual, but no pointer is used;
the result of the conversion is simply discarded.
.It Cm hh
Indicates that the conversion will be one of
.Cm dioux
or
.Cm n
and the next pointer is a pointer to a
.Vt char
(rather than
.Vt int ) .
.It Cm h
Indicates that the conversion will be one of
.Cm dioux
or
.Cm n
and the next pointer is a pointer to a
.Vt "short int"
(rather than
.Vt int ) .
.It Cm l No (ell)
Indicates either that the conversion will be one of
.Cm dioux
or
.Cm n
and the next pointer is a pointer to a
.Vt "long int"
(rather than
.Vt int ) ,
or that the conversion will be one of
.Cm efg
and the next pointer is a pointer to
.Vt double
(rather than
.Vt float ) ,
or that the conversion will be one of
.Cm sc[ .
.Pp
If the conversion is one of
.Cm sc[
the expected conversion input is a multibyte character sequence.
Each multibyte character in the sequence is converted with a call to the
.Fn mbrtowc
function.
The field width specifies the maximum amount of bytes read from the
multibyte character sequence and passed to
.Fn mbrtowc
for conversion.
The next pointer is a pointer to a
.Vt wchar_t
wide-character buffer large enough to accept the converted input sequence
including the terminating NUL wide character which will be added automatically.
.It Cm ll No (ell ell)
Indicates that the conversion will be one of
.Cm dioux
or
.Cm n
and the next pointer is a pointer to a
.Vt "long long int"
(rather than
.Vt int ) .
.It Cm L
Indicates that the conversion will be one of
.Cm efg
and the next pointer is a pointer to
.Vt "long double" .
.It Cm j
Indicates that the conversion will be one of
.Cm dioux
or
.Cm n
and the next pointer is a pointer to an
.Vt intmax_t
(rather than
.Vt int ) .
.It Cm t
Indicates that the conversion will be one of
.Cm dioux
or
.Cm n
and the next pointer is a pointer to a
.Vt ptrdiff_t
(rather than
.Vt int ) .
.It Cm z
Indicates that the conversion will be one of
.Cm dioux
or
.Cm n
and the next pointer is a pointer to a
.Vt size_t
(rather than
.Vt int ) .
.It Cm q
(deprecated)
Indicates that the conversion will be one of
.Cm dioux
or
.Cm n
and the next pointer is a pointer to a
.Vt "long long int"
(rather than
.Vt int ) .
.El
.Pp
In addition to these flags, there may be an optional maximum field width,
expressed as a decimal integer, between the
.Cm %
and the conversion.
If no width is given,
a default of
.Dq infinity
is used (with one exception, below);
otherwise at most this many characters are scanned in processing the
conversion.
Before conversion begins, most conversions skip whitespace;
this whitespace is not counted against the field width.
.Pp
The following conversions are available:
.Bl -tag -width XXXX
.It Cm %
Matches a literal
.Ql % .
That is,
.Dq Li %%
in the format string matches a single input
.Ql %
character.
No conversion is done, and assignment does not occur.
.It Cm d
Matches an optionally signed decimal integer;
the next pointer must be a pointer to
.Vt int .
.It Cm D
Equivalent to
.Cm ld ;
this exists only for backwards compatibility.
.It Cm i
Matches an optionally signed integer;
the next pointer must be a pointer to
.Vt int .
The integer is read in base 16 if it begins
with
.Ql 0x
or
.Ql 0X ,
in base 8 if it begins with
.Ql 0 ,
and in base 10 otherwise.
Only characters that correspond to the base are used.
.It Cm o
Matches an octal integer;
the next pointer must be a pointer to
.Vt "unsigned int" .
.It Cm O
Equivalent to
.Cm lo ;
this exists for backwards compatibility.
.It Cm u
Matches an optionally signed decimal integer;
the next pointer must be a pointer to
.Vt "unsigned int" .
.It Cm xX
Matches an optionally signed hexadecimal integer;
the next pointer must be a pointer to
.Vt "unsigned int" .
.It Cm eE
Equivalent to
.Cm f .
.It Cm fF
Matches an optionally signed floating-point number;
the next pointer must be a pointer to
.Vt float .
.It Cm gG
Equivalent to
.Cm f .
.It Cm aA
Equivalent to
.Cm f .
.It Cm s
Matches a sequence of non-whitespace characters;
the next pointer must be a pointer to
.Vt char ,
or to
.Vt wchar_t
if the
.Vt l
length modifier is present.
The provided array must be large enough to accept and store
the whole sequence and the terminating NUL character.
The input string stops at whitespace
or at the maximum field width, whichever occurs first.
If specified, the maximum field length refers to the sequence
being scanned rather than the storage space, hence the provided
array must be 1 larger for the terminating NUL character.
.It Cm c
Matches a sequence of characters consuming the number of bytes
specified by the field width (defaults to 1 if unspecified);
the next pointer must be a pointer to
.Vt char ,
or to
.Vt wchar_t
if the
.Vt l
length modifier is present.
There must be enough room for all the characters
(no terminating NUL is added).
The usual skip of leading whitespace is suppressed.
To skip whitespace first, use an explicit space in the format.
.It Cm \&[
Matches a nonempty sequence of characters from the specified set
of accepted characters;
the next pointer must be a pointer to
.Vt char ,
or to
.Vt wchar_t
if the
.Vt l
length modifier is present.
There must be enough room for all the characters in the string,
plus a terminating NUL character.
The usual skip of leading whitespace is suppressed.
.Pp
The string is to be made up of characters in
(or not in)
a particular set;
the set is defined by the characters between the open bracket
.Cm \&[
character
and a close bracket
.Cm \&]
character.
The set
.Em excludes
those characters
if the first character after the open bracket is a circumflex
.Cm ^ .
To include a close bracket in the set,
make it the first character after the open bracket
or the circumflex;
any other position will end the set.
The hyphen character
.Cm \-
is also special;
when placed between two other characters,
it adds all intervening characters to the set.
To include a hyphen,
make it the last character before the final close bracket.
.Pp
For instance,
.Ql [^]0-9-]
means the set
.Do
everything except close bracket, zero through nine, and hyphen
.Dc .
The string ends with the appearance of a character not in
(or, with a circumflex, in) the set
or when the field width runs out.
.It Cm p
Matches a pointer value (as printed by
.Ql %p
in
.Xr printf 3 ) ;
the next pointer must be a pointer to
.Vt void .
.It Cm n
Nothing is expected;
instead, the number of characters consumed thus far from the input
is stored through the next pointer,
which must be a pointer to
.Vt int .
This is
.Em not
a conversion, although it can be suppressed with the
.Cm *
flag.
.El
.Pp
For backwards compatibility, other conversion characters (except
.Ql \e0 )
are taken as if they were
.Ql %d
or, if uppercase,
.Ql %ld ,
and a `conversion' of
.Ql %\e0
causes an immediate return of
.Dv EOF .
.Sh RETURN VALUES
These functions return the number of input items assigned, which can be fewer
than provided for, or even zero, in the event of a matching failure.
Zero indicates that, while there was input available, no conversions were
assigned; typically this is due to an invalid input character,
such as an alphabetic character for a
.Ql %d
conversion.
The value
.Dv EOF
is returned if an input failure,
such as an end-of-file,
occurs before any conversion.
If an error or end-of-file occurs after conversion has begun,
the number of conversions which were successfully completed is returned.
.Sh SEE ALSO
.Xr getc 3 ,
.Xr mbrtowc 3 ,
.Xr printf 3 ,
.Xr strtod 3 ,
.Xr strtol 3 ,
.Xr strtoul 3
.Sh STANDARDS
The functions
.Fn fscanf ,
.Fn scanf ,
and
.Fn sscanf
conform to
.St -ansiC .
.Sh HISTORY
The functions
.Fn scanf ,
.Fn fscanf ,
and
.Fn sscanf
first appeared in
.At v7 ,
and
.Fn vscanf ,
.Fn vsscanf ,
and
.Fn vfscanf
in
.Bx 4.3 Reno .
.Sh BUGS
Numerical strings are truncated to 512 characters; for example,
.Cm %f
and
.Cm %d
are implicitly
.Cm %512f
and
.Cm %512d .
@


1.21
log
@tweak wording of scanf return value; prompted by Jan Stary; ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.20 2012/01/18 14:01:38 stsp Exp $
d34 1
a34 1
.Dd $Mdocdate: January 18 2012 $
d448 7
d459 1
a459 1
first appeared in
@


1.20
log
@Add support for C99 %ls, %lc, and %l[ format directives to scanf(3).
Based on code from FreeBSD.
Tested by myself (full release/install cycle on i386 and sparc64) and ajacoutot.
Man page help from jmc.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.19 2011/11/02 22:29:07 schwarze Exp $
d34 1
a34 1
.Dd $Mdocdate: November 2 2011 $
d426 3
a428 2
is returned if an input failure occurs before any conversion such as an
end-of-file occurs.
@


1.19
log
@Sync scanf(3) to wscanf(3), and a few bits the opposite way:
.Fd -> .In, .Li -> .Vt, and remove various other gratuitous differences.
feedback and ok stsp@@, ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.18 2011/07/03 17:57:47 martynas Exp $
d34 1
a34 1
.Dd $Mdocdate: July 3 2011 $
d162 18
a179 1
.Vt float ) .
d311 6
a316 1
and the provided array must be large enough to accept and store
d328 6
a333 1
and there must be enough room for all the characters
d342 6
a347 1
and there must be enough room for all the characters in the string,
d432 1
@


1.18
log
@Recognize %a, %A format specifiers, per C99.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.17 2009/04/05 19:29:28 martynas Exp $
d34 1
a34 1
.Dd $Mdocdate: April 5 2009 $
d46 1
a46 1
.Fd #include <stdio.h>
d53 1
a53 1
.Fd #include <stdarg.h>
d136 1
a136 1
.Li char
d138 1
a138 1
.Li int ) .
d145 1
a145 1
.Li short int
d147 1
a147 1
.Li int ) .
d154 1
a154 1
.Li long int
d156 1
a156 1
.Li int ) ,
d160 1
a160 1
.Li double
d162 2
a163 2
.Li float ) .
.It Cm \&ll No (ell ell)
d169 1
a169 1
.Li long long int
d171 1
a171 1
.Li int ) .
d173 1
a173 1
Indicates that the conversion will be
d176 1
a176 1
.Li long double .
d183 1
a183 1
.Li intmax_t
d185 1
a185 1
.Li int ) .
d192 1
a192 1
.Li ptrdiff_t
d194 1
a194 1
.Li int ) .
d201 1
a201 1
.Li size_t
d203 1
a203 1
.Li int ) .
d211 1
a211 1
.Li "long long int"
d232 2
a233 1
Matches a literal `%'.
d235 1
a235 1
.Ql %\&%
d243 1
a243 1
.Li int .
d251 1
a251 1
.Li int .
d264 1
a264 1
.Li unsigned int .
d272 2
a273 2
.Li unsigned int .
.It Cm x
d276 1
a276 4
.Li unsigned int .
.It Cm X
Equivalent to
.Cm x .
d283 1
a283 1
.Li float .
d293 1
a293 1
.Li char ,
d295 1
a295 3
all the sequence and the terminating
.Tn NUL
character.
d300 1
a300 3
array must be 1 larger for the terminating
.Tn NUL
character.
d305 1
a305 1
.Li char ,
d307 1
a307 3
(no terminating
.Tn NUL
is added).
d314 1
a314 1
.Li char ,
d316 1
a316 3
plus a terminating
.Tn NUL
character.
d338 1
a338 1
.Cm -
d360 1
a360 1
.Li void .
d366 1
a366 1
.Li int .
a420 2
All of the backwards compatibility formats will be removed in the future.
.Pp
@


1.17
log
@accept %F, which actually behaves the same as %f.  per C99
ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.16 2007/05/31 19:19:31 jmc Exp $
d34 1
a34 1
.Dd $Mdocdate: May 31 2007 $
d279 3
d286 1
a286 7
.It Cm e
Equivalent to
.Cm f .
.It Cm g
Equivalent to
.Cm f .
.It Cm E
d289 1
a289 1
.It Cm G
@


1.16
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.15 2006/01/13 17:56:18 millert Exp $
d34 1
a34 1
.Dd $Mdocdate$
d279 1
a279 1
.It Cm f
@


1.15
log
@Use long long and intmax_t instead of quad_t throughout.  Adapted in
part from FreeBSD.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.14 2005/07/26 03:30:25 jaredy Exp $
d34 1
a34 1
.Dd December 27, 2005
@


1.14
log
@- typos, punctuation, spacing, macro, layout, etc. fixes
- avoid first person

ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.13 2005/07/26 03:27:04 jaredy Exp $
d34 1
a34 1
.Dd January 31, 1995
d104 3
a106 3
(but see
.Dq suppression
below).
d125 1
a125 1
.Bl -tag -width indent
d130 9
d148 1
a148 1
.It Cm l
d163 1
a163 1
.It Cm q
d169 1
a169 1
.Li quad_t
d177 37
d341 3
a343 1
The set excludes those characters
@


1.13
log
@clarify description of 'c' conversion; ok millert, jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.12 2003/09/26 16:24:56 deraadt Exp $
d122 1
a122 1
character introducing a conversion there may be a number of
d285 1
d290 1
a290 1
.Cm [
d293 1
a293 1
.Cm ]
d309 1
d312 6
a317 4
means the set `everything except close bracket, zero through nine,
and hyphen'.
The string ends with the appearance of a character not in the
(or, with a circumflex, in) set
@


1.12
log
@for %#s, # is the amount of input string, not the amount of output string.
hence # must be 1 less than the size of the storage buffer.  yes, we've known
this for a long time, but it is not clearly documented and half the code out
there does not use n-1! whoever designed this needs to be tortured.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.11 2003/06/02 20:18:37 millert Exp $
d265 2
a266 3
Matches a sequence of
.Li width
count characters (default 1);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.10 2000/12/24 00:30:59 aaron Exp $
d253 2
a254 2
and the array must be large enough to accept all the sequence and the
terminating
d259 5
@


1.10
log
@Various repairs, mostly to get rid of short lines.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.9 2000/07/31 22:20:56 pjanzen Exp $
d18 1
a18 5
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@reinsert corrected history section, based on jdolecek@@netbsd
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.8 2000/04/27 04:16:51 aaron Exp $
d116 1
a116 2
string
may also contain other characters.
d335 1
a335 2
For backwards compatibility,
other conversion characters (except
d346 4
a349 9
These
functions
return
the number of input items assigned, which can be fewer than provided
for, or even zero, in the event of a matching failure.
Zero
indicates that, while there was input available,
no conversions were assigned;
typically this is due to an invalid input character,
@


1.8
log
@Remove redundant HISTORY section.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.7 2000/04/20 01:39:32 aaron Exp $
d380 8
@


1.7
log
@Flesh out all of the stdio man pages.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.6 2000/04/18 03:01:35 aaron Exp $
a379 7
.Sh HISTORY
The functions
.Fn vscanf ,
.Fn vsscanf
and
.Fn vfscanf
are new to this release.
@


1.6
log
@Repairs, mostly removing hard sentence breaks.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.5 2000/03/04 22:19:31 aaron Exp $
d67 1
a67 1
family of functions scans input according to a
d71 2
a72 4
.Em conversion specifiers ;
the results from such conversions, if any,
are stored through the
.Em pointer
d74 1
d77 1
a77 2
function
reads input from the standard input stream
d80 1
a80 1
reads input from the stream pointer
d86 1
d89 1
a89 2
function
is analogous to
d97 1
a97 2
function scans a variable argument list from the standard input and
the
d99 1
a99 3
function scans it from a string;
these are analogous to
the
d103 2
a104 1
functions respectively.
d107 4
a110 3
argument must correspond properly with
each successive conversion specifier
(but see `suppression' below).
d118 1
a118 1
White space (such as blanks, tabs, or newlines) in the
d121 3
a123 6
Everything else
matches only itself.
Scanning stops
when an input character does not match such a format character.
Scanning also stops
when an input conversion cannot be made (see below).
d127 1
a127 2
character introducing a conversion
there may be a number of
d141 1
a141 1
.Em short int
d143 1
a143 1
.Em int ) .
d150 1
a150 1
.Em long int
d152 1
a152 1
.Em int ) ,
d156 1
a156 1
.Em double
d158 1
a158 1
.Em float ) .
d165 1
a165 1
.Em quad_t
d167 1
a167 1
.Em int ) .
d172 1
a172 1
.Em long double .
d175 2
a176 4
In addition to these flags,
there may be an optional maximum field width,
expressed as a decimal integer,
between the
d180 6
a185 5
a default of `infinity' is used (with one exception, below);
otherwise at most this many characters are scanned
in processing the conversion.
Before conversion begins,
most conversions skip whitespace;
d192 5
a196 2
That is, `%\&%' in the format string
matches a single input `%' character.
d201 1
a201 1
.Em int .
d209 1
a209 1
.Em int .
d222 1
a222 1
.Em unsigned int .
d230 1
a230 1
.Em unsigned int .
d234 1
a234 1
.Em unsigned int .
d241 1
a241 1
.Em float .
d257 1
a257 1
.Em char ,
d260 1
a260 1
.Dv NUL
d266 2
a267 3
.Em width
count
characters (default 1);
d269 1
a269 1
.Em char ,
d272 1
a272 1
.Dv NUL
d280 1
a280 1
.Em char ,
d283 1
a283 1
.Dv NUL
d295 1
a295 3
The set
.Em excludes
those characters
d322 1
a322 1
.Em void .
d328 1
a328 1
.Em int .
@


1.5
log
@In Unix land we prefer "whitespace" to "white space" or "white-space". At
least, this is the impression I get from looking at a lot of Perl docs.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.4 1999/07/02 20:58:00 aaron Exp $
d148 1
a148 1
.Em short  int
d157 1
a157 1
.Em long  int
d371 2
a372 2
end-of-file occurs. If an error or end-of-file occurs after conversion
has begun,
@


1.4
log
@remove redundant .Pp macros
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.3 1999/05/16 19:55:09 alex Exp $
d123 1
a123 1
string match any amount of white space, including none, in the input.
d193 2
a194 2
most conversions skip white space;
this white space is not counted against the field width.
d260 1
a260 1
Matches a sequence of non-white-space characters;
d267 1
a267 1
The input string stops at white space
d280 2
a281 2
The usual skip of leading white space is suppressed.
To skip white space first, use an explicit space in the format.
d291 1
a291 1
The usual skip of leading white space is suppressed.
@


1.3
log
@Cleanup xrefs under SEE ALSO.  Specifically:

  - Sort xrefs by section, and then alphabetically.
  - Add missing commas between xref items.
  - Remove commas from the last xref entry.
  - Remove duplicate entries.
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.2 1996/08/19 08:33:03 tholo Exp $
a354 1
.Pp
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d1 1
a1 1
.\"	$OpenBSD: scanf.3,v 1.7 1995/02/02 01:15:52 jtc Exp $
d376 3
d380 1
a380 4
.Xr strtoul 3 ,
.Xr strtod 3 ,
.Xr getc 3 ,
.Xr printf 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
.\"	$NetBSD: scanf.3,v 1.7 1995/02/02 01:15:52 jtc Exp $
a36 2
.\"
.\"     @@(#)scanf.3	8.2 (Berkeley) 12/11/93
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
