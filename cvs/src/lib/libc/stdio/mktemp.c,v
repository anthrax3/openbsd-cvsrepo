head	1.38;
access;
symbols
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.8
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.35.0.6
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.6
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.31.0.6
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.4
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.10
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.8
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.13.0.14
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.13.0.12
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.13.0.10
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.8
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.13.0.6
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2015.09.13.08.31.47;	author guenther;	state Exp;
branches;
next	1.37;
commitid	QZ177IcjQzeRxHAC;

1.37
date	2015.09.12.14.56.50;	author guenther;	state Exp;
branches;
next	1.36;
commitid	BXATo6E2rFBuIXKr;

1.36
date	2015.08.31.02.53.57;	author guenther;	state Exp;
branches;
next	1.35;
commitid	lTMF8Y3C9fQGd6jQ;

1.35
date	2014.10.31.15.54.14;	author millert;	state Exp;
branches;
next	1.34;
commitid	RCJERlsx8x5z53WY;

1.34
date	2014.08.31.02.21.18;	author guenther;	state Exp;
branches;
next	1.33;
commitid	ByaPhxsk4NZYxbFu;

1.33
date	2014.05.06.22.55.27;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2013.03.12.16.47.11;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2011.10.02.07.41.56;	author dtucker;	state Exp;
branches;
next	1.30;

1.30
date	2010.03.21.23.09.30;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2010.02.11.16.48.36;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2010.02.08.17.58.24;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.20.16.05.11;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.01.13.35.46;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.17.22.53.43;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.09.15.20.28.44;	author chl;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.22.00.56.13;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2008.08.21.16.54.44;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.22.21.47.45;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.21.11.09.30;	author tobias;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.08.08.05.36;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.28.18.12.44;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.20.18.37;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.27.18.20.45;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.24;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.02.20.18.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.06.30.23.03.13;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.04.14.19.25.11;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.03.04.02.34.49;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.07.22.21.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.06.20.04.10.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.04.07.22.48.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.02.10.00.52.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.02.07.13.01.24;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.20.07.46.56;	author graichen;	state Exp;
branches;
next	1.4;

1.4
date	97.01.19.22.32.22;	author graichen;	state Exp;
branches;
next	1.3;

1.3
date	96.12.28.02.33.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.32.55;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.14;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Wrap <stdlib.h> so that calls go direct and the symbols not in the
C standard are all weak.
Apply __{BEGIN,END}_HIDDEN_DECLS to gdtoa{,imp}.h, hiding the
arch-specific __strtorx, __ULtox_D2A, __strtorQ, __ULtoQ_D2A symbols.
@
text
@/*	$OpenBSD: mktemp.c,v 1.37 2015/09/12 14:56:50 guenther Exp $ */
/*
 * Copyright (c) 1996-1998, 2008 Theo de Raadt
 * Copyright (c) 1997, 2008-2009 Todd C. Miller
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>

#define MKTEMP_NAME	0
#define MKTEMP_FILE	1
#define MKTEMP_DIR	2

#define TEMPCHARS	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
#define NUM_CHARS	(sizeof(TEMPCHARS) - 1)
#define MIN_X		6

#define MKOTEMP_FLAGS	(O_APPEND | O_CLOEXEC | O_DSYNC | O_RSYNC | O_SYNC)

#ifndef nitems
#define nitems(_a)	(sizeof((_a)) / sizeof((_a)[0]))
#endif

static int
mktemp_internal(char *path, int slen, int mode, int flags)
{
	char *start, *cp, *ep;
	const char tempchars[] = TEMPCHARS;
	unsigned int tries;
	struct stat sb;
	size_t len;
	int fd;

	len = strlen(path);
	if (len < MIN_X || slen < 0 || (size_t)slen > len - MIN_X) {
		errno = EINVAL;
		return(-1);
	}
	ep = path + len - slen;

	for (start = ep; start > path && start[-1] == 'X'; start--)
		;
	if (ep - start < MIN_X) {
		errno = EINVAL;
		return(-1);
	}

	if (flags & ~MKOTEMP_FLAGS) {
		errno = EINVAL;
		return(-1);
	}
	flags |= O_CREAT | O_EXCL | O_RDWR;

	tries = INT_MAX;
	do {
		cp = start;
		do {
			unsigned short rbuf[16];
			unsigned int i;

			/*
			 * Avoid lots of arc4random() calls by using
			 * a buffer sized for up to 16 Xs at a time.
			 */
			arc4random_buf(rbuf, sizeof(rbuf));
			for (i = 0; i < nitems(rbuf) && cp != ep; i++)
				*cp++ = tempchars[rbuf[i] % NUM_CHARS];
		} while (cp != ep);

		switch (mode) {
		case MKTEMP_NAME:
			if (lstat(path, &sb) != 0)
				return(errno == ENOENT ? 0 : -1);
			break;
		case MKTEMP_FILE:
			fd = open(path, flags, S_IRUSR|S_IWUSR);
			if (fd != -1 || errno != EEXIST)
				return(fd);
			break;
		case MKTEMP_DIR:
			if (mkdir(path, S_IRUSR|S_IWUSR|S_IXUSR) == 0)
				return(0);
			if (errno != EEXIST)
				return(-1);
			break;
		}
	} while (--tries);

	errno = EEXIST;
	return(-1);
}

char *
_mktemp(char *path)
{
	if (mktemp_internal(path, 0, MKTEMP_NAME, 0) == -1)
		return(NULL);
	return(path);
}

__warn_references(mktemp,
    "warning: mktemp() possibly used unsafely; consider using mkstemp()");

char *
mktemp(char *path)
{
	return(_mktemp(path));
}

int
mkostemps(char *path, int slen, int flags)
{
	return(mktemp_internal(path, slen, MKTEMP_FILE, flags));
}

int
mkstemp(char *path)
{
	return(mktemp_internal(path, 0, MKTEMP_FILE, 0));
}
DEF_WEAK(mkstemp);

int
mkostemp(char *path, int flags)
{
	return(mktemp_internal(path, 0, MKTEMP_FILE, flags));
}
DEF_WEAK(mkostemp);

int
mkstemps(char *path, int slen)
{
	return(mktemp_internal(path, slen, MKTEMP_FILE, 0));
}

char *
mkdtemp(char *path)
{
	int error;

	error = mktemp_internal(path, 0, MKTEMP_DIR, 0);
	return(error ? NULL : path);
}
@


1.37
log
@Wrap <unistd.h> so that internal calls go direct and they're all weak symbols
Delete unused 'fd' argument from internal function oldttyname()
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.36 2015/08/31 02:53:57 guenther Exp $ */
d148 1
a163 1
DEF_WEAK(mkdtemp);
@


1.36
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.35 2014/10/31 15:54:14 millert Exp $ */
d141 1
d163 1
@


1.35
log
@Use "const char tempchars[]" instead of "const char *tempchars".
Since tempchars is never reassigned there's no need to indirect
through a pointer.  Still getting used to this newfangled C89.
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.34 2014/08/31 02:21:18 guenther Exp $ */
a111 2

char *_mktemp(char *);
@


1.34
log
@Add additional userland interfaces for setting close-on-exec on fds
when creating them: mkostemp(), mkostemps(), the 'e' mode letter for
fopen(), freopen(), fdopen(), and popen().  The close-on-exec flag will
be cleared by the action created by posix_spawn_file_actions_adddup2().

Also, add support for the C11 'x' mode letter for fopen() and freopen(),
setting O_EXCL when possibly creating files.

Note: this requires kernel support for pipe2() and dup3()!

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.33 2014/05/06 22:55:27 millert Exp $ */
d48 1
a48 1
	const char *tempchars = TEMPCHARS;
@


1.33
log
@We don't really need uniform distribution for mktemp(3) so use
arc4random_buf() to avoid lots of arc4random() calls with a getpid()
syscall for each one.  We fetch 32 bytes of random data at a time
which can handle up to 16 Xs.  16 Xs should be enough for anyone.
Requested and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.32 2013/03/12 16:47:11 guenther Exp $ */
d38 2
d45 1
a45 1
mktemp_internal(char *path, int slen, int mode)
d68 6
d96 1
a96 1
			fd = open(path, O_CREAT|O_EXCL|O_RDWR, S_IRUSR|S_IWUSR);
d118 1
a118 1
	if (mktemp_internal(path, 0, MKTEMP_NAME) == -1)
d133 6
d141 7
a147 1
	return(mktemp_internal(path, 0, MKTEMP_FILE));
d153 1
a153 1
	return(mktemp_internal(path, slen, MKTEMP_FILE));
d161 1
a161 1
	error = mktemp_internal(path, 0, MKTEMP_DIR);
@


1.32
log
@Return EINVAL if there are fewer than six template Xs in the path.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.31 2011/10/02 07:41:56 dtucker Exp $ */
d38 4
d47 1
a47 1
	unsigned int r, tries;
d68 13
a80 4
		for (cp = start; cp != ep; cp++) {
			r = arc4random_uniform(NUM_CHARS);
			*cp = tempchars[r];
		}
@


1.31
log
@signedness fix; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.30 2010/03/21 23:09:30 schwarze Exp $ */
d36 1
d49 1
a49 1
	if (len == 0 || slen < 0 || (size_t)slen >= len) {
d55 5
a59 4
	tries = 1;
	for (start = ep; start > path && start[-1] == 'X'; start--) {
		if (tries < INT_MAX / NUM_CHARS)
			tries *= NUM_CHARS;
a60 1
	tries *= 2;
d62 1
@


1.30
log
@When all tried file names already existed, mktemp(3) returned without
setting errno(2).  Behaviour unchanged for mkstemp[s] and mkdtemp.

ok guenther deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.29 2010/02/11 16:48:36 guenther Exp $ */
d48 1
a48 1
	if (len == 0 || slen >= len) {
@


1.29
log
@The previous commit didn't use the first X in the template if the
entire template was Xs.  Test suite written now to keep this from
happening again.  Problem caught by Vadim Zhukov again.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.28 2010/02/08 17:58:24 guenther Exp $ */
d85 2
@


1.28
log
@Don't underrun the buffer when the template is all X's.
Also, remove a duplicate preconditions check.
Based on a suggestion by Vadim Zhukov (persgray <at> gmail.com)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.27 2009/03/20 16:05:11 millert Exp $ */
d55 1
a55 1
	for (start = ep; start > path && *--start == 'X';) {
a59 1
	start++;
@


1.27
log
@Return -1 from mktemp_internal() on EINVAL like we used to.
OK oga@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.26 2009/03/01 13:35:46 millert Exp $ */
a46 5
	if (*path == '\0') {
		errno = EINVAL;
		return(-1);
	}

d55 1
a55 1
	for (start = ep; start >= path && *--start == 'X';) {
@


1.26
log
@New mktemp(3) based on the one from portable mktemp(1).  Now includes
digits (in addition to letters) in the random file name.  Instead
of looping forever, mktemp(3) will terminate when it has tried 2 *
N^62 times where N is the number of X's.  This is effectively forever
for lots of X's.
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.25 2009/02/17 22:53:43 deraadt Exp $ */
d49 1
a49 1
		return(0);
d55 1
a55 1
		return(0);
@


1.25
log
@when the template is entirely XXX characters, would crash
from Vadim Zhukov <persgray@@gmail
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.24 2008/09/15 20:28:44 chl Exp $ */
d3 2
a4 2
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
d6 3
a8 11
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d10 7
a16 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d21 1
d23 1
a23 1
#include <errno.h>
d30 6
a35 1
static int _gettemp(char *, int *, int, int);
d37 2
a38 2
int
mkstemps(char *path, int slen)
d40 5
d47 11
a57 2
	return (_gettemp(path, &fd, 0, slen) ? fd : -1);
}
d59 7
a65 4
int
mkstemp(char *path)
{
	int fd;
d67 5
a71 2
	return (_gettemp(path, &fd, 0, 0) ? fd : -1);
}
d73 19
a91 4
char *
mkdtemp(char *path)
{
	return(_gettemp(path, (int *)NULL, 1, 0) ? path : (char *)NULL);
d99 3
a101 1
	return(_gettemp(path, (int *)NULL, 0, 0) ? path : (char *)NULL);
d113 5
d119 2
a120 2
static int
_gettemp(char *path, int *doopen, int domkdir, int slen)
d122 2
a123 4
	char *start, *cp, *ep;
	struct stat sbuf;
	size_t len;
	int r;
d125 4
a128 4
	if (doopen && domkdir) {
		errno = EINVAL;
		return(0);
	}
d130 2
a131 37
	len = strlen(path);
	if (len == 0 || slen >= len) {
		errno = EINVAL;
		return(0);
	}
	ep = path + len - slen;

	for (start = ep - 1; start != path; start--)
		if (*start != 'X') {
			start++;
			break;
		}

	for (;;) {
		for (cp = start; cp != ep; cp++) {
			r = arc4random_uniform(26 + 26);
			if (r < 26)
				*cp = r + 'A';
			else
				*cp = (r - 26) + 'a';
		}

		if (doopen) {
			if ((*doopen =
			    open(path, O_CREAT|O_EXCL|O_RDWR, 0600)) >= 0)
				return(1);
			if (errno != EEXIST)
				return(0);
		} else if (domkdir) {
			if (mkdir(path, 0700) == 0)
				return(1);
			if (errno != EEXIST)
				return(0);
		} else if (lstat(path, &sbuf))
			return(errno == ENOENT ? 1 : 0);
	}
	/*NOTREACHED*/
@


1.24
log
@add missing header needed by strlen().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.23 2008/08/22 00:56:13 millert Exp $ */
d103 5
a107 3
	for (start = ep; *--start == 'X';)
		;
	start++;
@


1.23
log
@Replace the old algorithm that included the process id as part of the
temporary file name with one that only uses random data.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.22 2008/08/21 16:54:44 millert Exp $ */
d37 1
@


1.22
log
@Remove useless code, the kernel will set errno appropriately if an
element in the path does not exist.  OK deraadt@@ pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.21 2008/07/22 21:47:45 deraadt Exp $ */
d85 1
a85 1
	char *start, *trv, *suffp;
d87 2
a88 2
	int rval;
	pid_t pid;
d95 2
a96 6
	for (trv = path; *trv; ++trv)
		;
	trv -= slen;
	suffp = trv;
	--trv;
	if (trv < path) {
d98 1
a98 6
		return (0);
	}
	pid = getpid();
	while (trv >= path && *trv == 'X' && pid != 0) {
		*trv-- = (pid % 10) + '0';
		pid /= 10;
d100 1
a100 2
	while (trv >= path && *trv == 'X') {
		char c;
d102 3
a104 8
		pid = arc4random_uniform(26+26);
		if (pid < 26)
			c = pid + 'A';
		else
			c = (pid - 26) + 'a';
		*trv-- = c;
	}
	start = trv + 1;
d107 8
a127 22

		/* tricky little algorithm for backward compatibility */
		for (trv = start;;) {
			if (!*trv)
				return (0);
			if (*trv == 'Z') {
				if (trv == suffp)
					return (0);
				*trv++ = 'a';
			} else {
				if (isdigit(*trv))
					*trv = 'a';
				else if (*trv == 'z')	/* inc from z to A */
					*trv = 'A';
				else {
					if (trv == suffp)
						return (0);
					++*trv;
				}
				break;
			}
		}
@


1.21
log
@use arc4random_uniform(); ok djm millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.20 2007/10/21 11:09:30 tobias Exp $ */
a119 20

	/* Check the target directory. */
	if (doopen || domkdir) {
		for (;; --trv) {
			if (trv <= path)
				break;
			if (*trv == '/') {
				*trv = '\0';
				rval = stat(path, &sbuf);
				*trv = '/';
				if (rval != 0)
					return(0);
				if (!S_ISDIR(sbuf.st_mode)) {
					errno = ENOTDIR;
					return(0);
				}
				break;
			}
		}
	}
@


1.20
log
@Comment fix about time consumption of _gettemp.
FreeBSD did this in revision 1.20.

OK deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mktemp.c,v 1.19 2005/08/08 08:05:36 espie Exp $ */
d112 1
a112 1
		pid = (arc4random() & 0xffff) % (26+26);
@


1.19
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d121 1
a121 4
	/*
	 * check the target directory; if you have six X's and it
	 * doesn't exist this runs for a *very* long time.
	 */
@


1.18
log
@deregister + ansify, no change in object code. ok deraadt@@ millert@@
@
text
@d1 1
a29 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.17 2003/06/02 20:18:37 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d31 1
a31 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.16 2002/05/27 18:20:45 millert Exp $";
d46 1
a46 3
mkstemps(path, slen)
	char *path;
	int slen;
d54 1
a54 2
mkstemp(path)
	char *path;
d62 1
a62 2
mkdtemp(path)
	char *path;
d70 1
a70 2
_mktemp(path)
	char *path;
d79 1
a79 2
mktemp(path)
	char *path;
d86 1
a86 5
_gettemp(path, doopen, domkdir, slen)
	char *path;
	register int *doopen;
	int domkdir;
	int slen;
d88 1
a88 1
	register char *start, *trv, *suffp;
@


1.16
log
@Don't decrement the current character pointer past the beginning of the
buffer passed in.  Based on a patch from Mark Andrews.  deraadt@@ OK
@
text
@d13 1
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d31 1
a31 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.15 2002/02/16 21:27:24 millert Exp $";
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.14 2002/01/02 20:18:32 deraadt Exp $";
d122 1
a122 1
	while (*trv == 'X' && pid != 0) {
d126 1
a126 1
	while (*trv == 'X') {
@


1.14
log
@more pid_t use
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.13 1998/06/30 23:03:13 deraadt Exp $";
d47 1
a47 1
static int _gettemp __P((char *, int *, int, int));
d75 1
a75 1
char *_mktemp __P((char *));
@


1.13
log
@add mkstemp(char *template, int suffixlen) interface
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.12 1998/04/14 19:25:11 deraadt Exp $";
d104 2
a105 1
	int pid, rval;
@


1.12
log
@wrap Z->a and z->A; peter@@netplex.com.au
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.11 1998/03/04 02:34:49 deraadt Exp $";
d47 11
a57 1
static int _gettemp __P((char *, int *, int));
d65 1
a65 1
	return (_gettemp(path, &fd, 0) ? fd : -1);
d72 1
a72 1
	return(_gettemp(path, (int *)NULL, 1) ? path : (char *)NULL);
d81 1
a81 1
	return(_gettemp(path, (int *)NULL, 0) ? path : (char *)NULL);
d96 1
a96 1
_gettemp(path, doopen, domkdir)
d100 1
d102 1
a102 1
	register char *start, *trv;
a110 1
	pid = getpid();
d113 2
d116 5
d178 4
a181 2
				return(0);
			if (*trv == 'Z')
d183 1
a183 1
			else {
d188 3
a190 1
				else
d192 1
@


1.11
log
@uninitialized case; bde
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.10 1997/10/07 22:21:34 millert Exp $";
d162 1
a162 1
			if (*trv == 'z')
d167 2
@


1.10
log
@1) Don't truncate the input string when a directory cannot be stat'd
2) Use traditional mktemp(3) semantics.  Don't return an error if
   directories in the path don't exist yet for mktemp(3) only.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.9 1997/06/20 04:10:19 millert Exp $";
d118 1
d125 1
a125 1
		for (start = trv + 1;; --trv) {
@


1.9
log
@Add mkdtemp(3)
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.8 1997/04/07 22:48:50 millert Exp $";
a90 1
	extern int errno;
d93 1
a93 1
	int pid;
d123 15
a137 10
	for (start = trv + 1;; --trv) {
		if (trv <= path)
			break;
		if (*trv == '/') {
			*trv = '\0';
			if (stat(path, &sbuf))
				return(0);
			if (!S_ISDIR(sbuf.st_mode)) {
				errno = ENOTDIR;
				return(0);
a138 2
			*trv = '/';
			break;
@


1.8
log
@Change a stat(2) -> lstat(2) to avoid symlink games.  From Keith
Bostic <bostic@@bostic.com>.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.7 1997/02/10 00:52:28 millert Exp $";
d47 1
a47 1
static int _gettemp();
d55 8
a62 1
	return (_gettemp(path, &fd) ? fd : -1);
d71 1
a71 1
	return(_gettemp(path, (int *)NULL) ? path : (char *)NULL);
d86 1
a86 1
_gettemp(path, doopen)
d89 1
d96 5
d147 6
a152 2
		}
		else if (lstat(path, &sbuf))
@


1.7
log
@Pull in stdlib.h for arc4random prototype.
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.6 1997/02/07 13:01:24 deraadt Exp $";
d135 1
a135 1
		else if (stat(path, &sbuf))
@


1.6
log
@pre-pad with random alphabetic letters instead of digit 0
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.5 1997/01/20 07:46:56 graichen Exp $";
d43 1
@


1.5
log
@back out my last change to avoid the __warn_references on the mips - it's
now done for the pmax like for the arc in machine/cdefs.h
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.4 1997/01/19 22:32:22 graichen Exp $";
d85 1
a85 1
	u_int pid;
d88 5
a92 3
	for (trv = path; *trv; ++trv);		/* extra X's get set to 0's */
	while (*--trv == 'X') {
		*trv = (pid % 10) + '0';
d94 10
@


1.4
log
@put all the __warn_references behind a #ifndef NO_WARN_REFERENCES which
is then set in the libc Makefile for the mips (the mips linker can't
handle them)
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.3 1996/12/28 02:33:10 deraadt Exp $";
a65 1
#ifndef NO_WARN_REFERENCES
a67 1
#endif
@


1.3
log
@95% of common uses of these are incorrect and insecure. correct use is
incredibly rare. Time for some education!
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.2 1996/08/19 08:32:55 tholo Exp $";
d66 1
d69 1
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d35 1
a35 1
static char rcsid[] = "$OpenBSD: mktemp.c,v 1.5 1995/02/02 02:10:09 jtc Exp $";
d57 12
d73 1
a73 1
	return(_gettemp(path, (int *)NULL) ? path : (char *)NULL);
d75 1
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: mktemp.c,v 1.5 1995/02/02 02:10:09 jtc Exp $	*/

d35 1
a35 4
#if 0
static char sccsid[] = "@@(#)mktemp.c	8.1 (Berkeley) 6/4/93";
#endif
static char rcsid[] = "$NetBSD: mktemp.c,v 1.5 1995/02/02 02:10:09 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

