head	1.77;
access;
symbols
	OPENBSD_6_0:1.73.0.2
	OPENBSD_6_0_BASE:1.73
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.67.0.6
	OPENBSD_5_8_BASE:1.67
	OPENBSD_5_7:1.67.0.2
	OPENBSD_5_7_BASE:1.67
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.63.0.2
	OPENBSD_5_4_BASE:1.63
	OPENBSD_5_3:1.62.0.4
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.62.0.2
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.61
	OPENBSD_5_1:1.61.0.4
	OPENBSD_5_0:1.61.0.2
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.58.0.4
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.53.0.6
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.48.0.2
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.42.0.4
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.38.0.2
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.77
date	2016.08.29.12.20.57;	author millert;	state Exp;
branches;
next	1.76;
commitid	2jJcsHC7fzR2qTFL;

1.76
date	2016.08.27.16.10.40;	author millert;	state Exp;
branches;
next	1.75;
commitid	IlLcqilYYtyvTXbD;

1.75
date	2016.08.17.22.15.08;	author tedu;	state Exp;
branches;
next	1.74;
commitid	lSGOQPiJ4nZ3YNDj;

1.74
date	2016.08.17.18.07.07;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	DioLcoNJM3JPs257;

1.73
date	2016.06.06.17.22.59;	author millert;	state Exp;
branches;
next	1.72;
commitid	u01Bsk0pU72IxDck;

1.72
date	2016.01.19.18.22.53;	author mmcc;	state Exp;
branches;
next	1.71;
commitid	s3riHJUsMx4Rb6UB;

1.71
date	2016.01.04.15.47.47;	author schwarze;	state Exp;
branches;
next	1.70;
commitid	fTX7qATKrBWtwLVw;

1.70
date	2015.12.28.22.08.18;	author mmcc;	state Exp;
branches;
next	1.69;
commitid	0uXuF2O13NH9q2e1;

1.69
date	2015.09.29.03.19.24;	author guenther;	state Exp;
branches;
next	1.68;
commitid	yKdJafwKaYfM4gkS;

1.68
date	2015.08.31.02.53.57;	author guenther;	state Exp;
branches;
next	1.67;
commitid	lTMF8Y3C9fQGd6jQ;

1.67
date	2014.12.21.00.23.30;	author daniel;	state Exp;
branches;
next	1.66;
commitid	KQ5Vj1nc8aoPuER8;

1.66
date	2014.05.03.12.36.45;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2014.03.19.05.17.01;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2013.11.01.19.05.10;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2013.03.02.19.40.08;	author guenther;	state Exp;
branches;
next	1.62;

1.62
date	2012.06.26.14.53.23;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.06.19.53.52;	author stsp;	state Exp;
branches;
next	1.60;

1.60
date	2010.12.22.14.54.44;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2010.10.17.20.26.51;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2009.11.09.00.18.27;	author kurt;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.28.21.15.02;	author naddy;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.22.01.23.16;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.21.16.04.23;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.16.12.15.03;	author martynas;	state Exp;
branches;
next	1.53;

1.53
date	2008.10.21.17.51.17;	author martynas;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.07.20.36.08;	author martynas;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.27.00.40.38;	author martynas;	state Exp;
branches;
next	1.50;

1.50
date	2008.08.26.18.29.12;	author martynas;	state Exp;
branches;
next	1.49;

1.49
date	2008.08.26.17.56.30;	author martynas;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.10.18.18.55;	author martynas;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.16.20.42.52;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2008.05.16.14.28.53;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2008.05.13.18.52.25;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2008.05.05.21.50.45;	author chl;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.28.19.06.19;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.30.03.57.29;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2007.01.16.19.20.53;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.26.06.20.16;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2006.10.29.18.45.55;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.29.23.00.23;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2006.01.13.17.56.18;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2006.01.06.18.53.04;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.19.19.43.01;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.19.19.39.25;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2005.09.23.02.33.34;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.08.08.05.36;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.17.20.40.32;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.08.22.08.30;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.30.09.25.17;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2004.09.28.18.12.44;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2004.09.25.06.35.50;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.25.02.33.41;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.09.24.23.25.49;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.24.21.41.14;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.18.19.28.06;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.16.20.21.03;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2004.09.14.22.20.21;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.20.18.37;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.16.21.13.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.24.17.13.36;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.19.19.39.37;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.17.19.42.24;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.24;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.05.10.20.06;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.13.19.16.34;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.09.06.57.45;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.31.18.11.38;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.20.00.10.11;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.08.22.17.06.35;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.08.14.21.39.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.25.20.30.12;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.12.14.06.49.43;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.11.13.18.46.29;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.10.27.00.33.06;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.09.24.20.02.14;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.33.11;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.77
log
@Store the return value of mbrtowc() in a size_t, not int.
OK schwarze@@
@
text
@/*	$OpenBSD: vfprintf.c,v 1.75 2016/08/17 22:15:08 tedu Exp $	*/
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Actual printf innards.
 *
 * This code is large and complicated...
 */

#include <sys/types.h>
#include <sys/mman.h>

#include <errno.h>
#include <langinfo.h>
#include <limits.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <syslog.h>
#include <wchar.h>

#include "local.h"
#include "fvwrite.h"

union arg {
	int			intarg;
	unsigned int		uintarg;
	long			longarg;
	unsigned long		ulongarg;
	long long		longlongarg;
	unsigned long long	ulonglongarg;
	ptrdiff_t		ptrdiffarg;
	size_t			sizearg;
	ssize_t			ssizearg;
	intmax_t		intmaxarg;
	uintmax_t		uintmaxarg;
	void			*pvoidarg;
	char			*pchararg;
	signed char		*pschararg;
	short			*pshortarg;
	int			*pintarg;
	long			*plongarg;
	long long		*plonglongarg;
	ptrdiff_t		*pptrdiffarg;
	ssize_t			*pssizearg;
	intmax_t		*pintmaxarg;
#ifdef FLOATING_POINT
	double			doublearg;
	long double		longdoublearg;
#endif
#ifdef PRINTF_WIDE_CHAR
	wint_t			wintarg;
	wchar_t			*pwchararg;
#endif
};

static int __find_arguments(const char *fmt0, va_list ap, union arg **argtable,
    size_t *argtablesiz);
static int __grow_type_table(unsigned char **typetable, int *tablesize);

/*
 * Flush out all the vectors defined by the given uio,
 * then reset it so that it can be reused.
 */
static int
__sprint(FILE *fp, struct __suio *uio)
{
	int err;

	if (uio->uio_resid == 0) {
		uio->uio_iovcnt = 0;
		return (0);
	}
	err = __sfvwrite(fp, uio);
	uio->uio_resid = 0;
	uio->uio_iovcnt = 0;
	return (err);
}

/*
 * Helper function for `fprintf to unbuffered unix file': creates a
 * temporary buffer.  We only work on write-only files; this avoids
 * worries about ungetc buffers and so forth.
 */
static int
__sbprintf(FILE *fp, const char *fmt, va_list ap)
{
	int ret;
	FILE fake;
	struct __sfileext fakeext;
	unsigned char buf[BUFSIZ];

	_FILEEXT_SETUP(&fake, &fakeext);
	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
	fake._file = fp->_file;
	fake._cookie = fp->_cookie;
	fake._write = fp->_write;

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
	fake._bf._size = fake._w = sizeof(buf);
	fake._lbfsize = 0;	/* not actually used, but Just In Case */

	/* do the work, then copy any error status */
	ret = __vfprintf(&fake, fmt, ap);
	if (ret >= 0 && __sflush(&fake))
		ret = EOF;
	if (fake._flags & __SERR)
		fp->_flags |= __SERR;
	return (ret);
}

#ifdef PRINTF_WIDE_CHAR
/*
 * Convert a wide character string argument for the %ls format to a multibyte
 * string representation. If not -1, prec specifies the maximum number of
 * bytes to output, and also means that we can't assume that the wide char
 * string is null-terminated.
 */
static char *
__wcsconv(wchar_t *wcsarg, int prec)
{
	mbstate_t mbs;
	char buf[MB_LEN_MAX];
	wchar_t *p;
	char *convbuf;
	size_t clen, nbytes;

	/* Allocate space for the maximum number of bytes we could output. */
	if (prec < 0) {
		memset(&mbs, 0, sizeof(mbs));
		p = wcsarg;
		nbytes = wcsrtombs(NULL, (const wchar_t **)&p, 0, &mbs);
		if (nbytes == (size_t)-1)
			return (NULL);
	} else {
		/*
		 * Optimisation: if the output precision is small enough,
		 * just allocate enough memory for the maximum instead of
		 * scanning the string.
		 */
		if (prec < 128)
			nbytes = prec;
		else {
			nbytes = 0;
			p = wcsarg;
			memset(&mbs, 0, sizeof(mbs));
			for (;;) {
				clen = wcrtomb(buf, *p++, &mbs);
				if (clen == 0 || clen == (size_t)-1 ||
				    nbytes + clen > (size_t)prec)
					break;
				nbytes += clen;
			}
			if (clen == (size_t)-1)
				return (NULL);
		}
	}
	if ((convbuf = malloc(nbytes + 1)) == NULL)
		return (NULL);

	/* Fill the output buffer. */
	p = wcsarg;
	memset(&mbs, 0, sizeof(mbs));
	if ((nbytes = wcsrtombs(convbuf, (const wchar_t **)&p,
	    nbytes, &mbs)) == (size_t)-1) {
		free(convbuf);
		return (NULL);
	}
	convbuf[nbytes] = '\0';
	return (convbuf);
}
#endif

#ifdef FLOATING_POINT
#include <float.h>
#include <locale.h>
#include <math.h>
#include "floatio.h"
#include "gdtoa.h"

#define	DEFPREC		6

static int exponent(char *, int, int);
#endif /* FLOATING_POINT */

/*
 * The size of the buffer we use as scratch space for integer
 * conversions, among other things.  Technically, we would need the
 * most space for base 10 conversions with thousands' grouping
 * characters between each pair of digits.  100 bytes is a
 * conservative overestimate even for a 128-bit uintmax_t.
 */
#define BUF	100

#define STATIC_ARG_TBL_SIZE 8	/* Size of static argument table. */


/*
 * Macros for converting digits to letters and vice versa
 */
#define	to_digit(c)	((c) - '0')
#define is_digit(c)	((unsigned)to_digit(c) <= 9)
#define	to_char(n)	((n) + '0')

/*
 * Flags used during conversion.
 */
#define	ALT		0x0001		/* alternate form */
#define	LADJUST		0x0004		/* left adjustment */
#define	LONGDBL		0x0008		/* long double */
#define	LONGINT		0x0010		/* long integer */
#define	LLONGINT	0x0020		/* long long integer */
#define	SHORTINT	0x0040		/* short integer */
#define	ZEROPAD		0x0080		/* zero (as opposed to blank) pad */
#define FPT		0x0100		/* Floating point number */
#define PTRINT		0x0200		/* (unsigned) ptrdiff_t */
#define SIZEINT		0x0400		/* (signed) size_t */
#define CHARINT		0x0800		/* 8 bit integer */
#define MAXINT		0x1000		/* largest integer size (intmax_t) */

int
vfprintf(FILE *fp, const char *fmt0, __va_list ap)
{
	int ret;

	FLOCKFILE(fp);
	ret = __vfprintf(fp, fmt0, ap);
	FUNLOCKFILE(fp);
	return (ret);
}
DEF_STRONG(vfprintf);

int
__vfprintf(FILE *fp, const char *fmt0, __va_list ap)
{
	char *fmt;		/* format string */
	int ch;			/* character from fmt */
	int n, n2;		/* handy integers (short term usage) */
	char *cp;		/* handy char pointer (short term usage) */
	struct __siov *iovp;	/* for PRINT macro */
	int flags;		/* flags as above */
	int ret;		/* return value accumulator */
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format; <0 for N/A */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
	wchar_t wc;
	mbstate_t ps;
#ifdef FLOATING_POINT
	/*
	 * We can decompose the printed representation of floating
	 * point numbers into several parts, some of which may be empty:
	 *
	 * [+|-| ] [0x|0X] MMM . NNN [e|E|p|P] [+|-] ZZ
	 *    A       B     ---C---      D       E   F
	 *
	 * A:	'sign' holds this value if present; '\0' otherwise
	 * B:	ox[1] holds the 'x' or 'X'; '\0' if not hexadecimal
	 * C:	cp points to the string MMMNNN.  Leading and trailing
	 *	zeros are not in the string and must be added.
	 * D:	expchar holds this character; '\0' if no exponent, e.g. %f
	 * F:	at least two digits for decimal, at least one digit for hex
	 */
	char *decimal_point = NULL;
	int signflag;		/* true if float is negative */
	union {			/* floating point arguments %[aAeEfFgG] */
		double dbl;
		long double ldbl;
	} fparg;
	int expt;		/* integer value of exponent */
	char expchar;		/* exponent character: [eEpP\0] */
	char *dtoaend;		/* pointer to end of converted digits */
	int expsize;		/* character count for expstr */
	int lead;		/* sig figs before decimal or group sep */
	int ndig;		/* actual number of digits returned by dtoa */
	char expstr[MAXEXPDIG+2];	/* buffer for exponent string: e+ZZZ */
	char *dtoaresult = NULL;
#endif

	uintmax_t _umax;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;	/* base for %[diouxX] conversion */
	int dprec;		/* a copy of prec if %[diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	const char *xdigs;	/* digits for %[xX] conversion */
#define NIOV 8
	struct __suio uio;	/* output information: summary */
	struct __siov iov[NIOV];/* ... and individual io vectors */
	char buf[BUF];		/* buffer with space for digits of uintmax_t */
	char ox[2];		/* space for 0x; ox[1] is either x, X, or \0 */
	union arg *argtable;	/* args, built due to positional arg */
	union arg statargtable[STATIC_ARG_TBL_SIZE];
	size_t argtablesiz;
	int nextarg;		/* 1-based argument index */
	va_list orgap;		/* original argument pointer */
#ifdef PRINTF_WIDE_CHAR
	char *convbuf;		/* buffer for wide to multi-byte conversion */
#endif

	/*
	 * Choose PADSIZE to trade efficiency vs. size.  If larger printf
	 * fields occur frequently, increase PADSIZE and make the initialisers
	 * below longer.
	 */
#define	PADSIZE	16		/* pad chunk size */
	static char blanks[PADSIZE] =
	 {' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' ',' '};
	static char zeroes[PADSIZE] =
	 {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'};

	static const char xdigs_lower[16] = "0123456789abcdef";
	static const char xdigs_upper[16] = "0123456789ABCDEF";

	/*
	 * BEWARE, these `goto error' on error, and PAD uses `n'.
	 */
#define	PRINT(ptr, len) do { \
	iovp->iov_base = (ptr); \
	iovp->iov_len = (len); \
	uio.uio_resid += (len); \
	iovp++; \
	if (++uio.uio_iovcnt >= NIOV) { \
		if (__sprint(fp, &uio)) \
			goto error; \
		iovp = iov; \
	} \
} while (0)
#define	PAD(howmany, with) do { \
	if ((n = (howmany)) > 0) { \
		while (n > PADSIZE) { \
			PRINT(with, PADSIZE); \
			n -= PADSIZE; \
		} \
		PRINT(with, n); \
	} \
} while (0)
#define	PRINTANDPAD(p, ep, len, with) do {	\
	n2 = (ep) - (p);       			\
	if (n2 > (len))				\
		n2 = (len);			\
	if (n2 > 0)				\
		PRINT((p), n2);			\
	PAD((len) - (n2 > 0 ? n2 : 0), (with));	\
} while(0)
#define	FLUSH() do { \
	if (uio.uio_resid && __sprint(fp, &uio)) \
		goto error; \
	uio.uio_iovcnt = 0; \
	iovp = iov; \
} while (0)

	/*
	 * To extend shorts properly, we need both signed and unsigned
	 * argument extraction methods.
	 */
#define	SARG() \
	((intmax_t)(flags&MAXINT ? GETARG(intmax_t) : \
	    flags&LLONGINT ? GETARG(long long) : \
	    flags&LONGINT ? GETARG(long) : \
	    flags&PTRINT ? GETARG(ptrdiff_t) : \
	    flags&SIZEINT ? GETARG(ssize_t) : \
	    flags&SHORTINT ? (short)GETARG(int) : \
	    flags&CHARINT ? (signed char)GETARG(int) : \
	    GETARG(int)))
#define	UARG() \
	((uintmax_t)(flags&MAXINT ? GETARG(uintmax_t) : \
	    flags&LLONGINT ? GETARG(unsigned long long) : \
	    flags&LONGINT ? GETARG(unsigned long) : \
	    flags&PTRINT ? (uintptr_t)GETARG(ptrdiff_t) : /* XXX */ \
	    flags&SIZEINT ? GETARG(size_t) : \
	    flags&SHORTINT ? (unsigned short)GETARG(int) : \
	    flags&CHARINT ? (unsigned char)GETARG(int) : \
	    GETARG(unsigned int)))

	/*
	 * Append a digit to a value and check for overflow.
	 */
#define APPEND_DIGIT(val, dig) do { \
	if ((val) > INT_MAX / 10) \
		goto overflow; \
	(val) *= 10; \
	if ((val) > INT_MAX - to_digit((dig))) \
		goto overflow; \
	(val) += to_digit((dig)); \
} while (0)

	 /*
	  * Get * arguments, including the form *nn$.  Preserve the nextarg
	  * that the argument can be gotten once the type is determined.
	  */
#define GETASTER(val) \
	n2 = 0; \
	cp = fmt; \
	while (is_digit(*cp)) { \
		APPEND_DIGIT(n2, *cp); \
		cp++; \
	} \
	if (*cp == '$') { \
		int hold = nextarg; \
		if (argtable == NULL) { \
			argtable = statargtable; \
			if (__find_arguments(fmt0, orgap, &argtable, \
			    &argtablesiz) == -1) { \
				ret = -1; \
				goto error; \
			} \
		} \
		nextarg = n2; \
		val = GETARG(int); \
		nextarg = hold; \
		fmt = ++cp; \
	} else { \
		val = GETARG(int); \
	}

/*
* Get the argument indexed by nextarg.   If the argument table is
* built, use it to get the argument.  If its not, get the next
* argument (and arguments must be gotten sequentially).
*/
#define GETARG(type) \
	((argtable != NULL) ? *((type*)(&argtable[nextarg++])) : \
		(nextarg++, va_arg(ap, type)))

	_SET_ORIENTATION(fp, -1);
	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite(fp)) {
		errno = EBADF;
		return (EOF);
	}

	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
	    fp->_file >= 0)
		return (__sbprintf(fp, fmt0, ap));

	fmt = (char *)fmt0;
	argtable = NULL;
	nextarg = 1;
	va_copy(orgap, ap);
	uio.uio_iov = iovp = iov;
	uio.uio_resid = 0;
	uio.uio_iovcnt = 0;
	ret = 0;
#ifdef PRINTF_WIDE_CHAR
	convbuf = NULL;
#endif

	memset(&ps, 0, sizeof(ps));
	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
		size_t len;

		cp = fmt;
		while ((len = mbrtowc(&wc, fmt, MB_CUR_MAX, &ps)) != 0) {
			if (len == (size_t)-1 || len == (size_t)-2) {
				ret = -1;
				goto error;
			}
			fmt += len;
			if (wc == '%') {
				fmt--;
				break;
			}
		}
		if (fmt != cp) {
			ptrdiff_t m = fmt - cp;
			if (m < 0 || m > INT_MAX - ret)
				goto overflow;
			PRINT(cp, m);
			ret += m;
		}
		if (len == 0)
			goto done;
		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
		ox[1] = '\0';

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
		case ' ':
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '#':
			flags |= ALT;
			goto rflag;
		case '\'':
			/* grouping not implemented */
			goto rflag;
		case '*':
			/*
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			GETASTER(width);
			if (width >= 0)
				goto rflag;
			if (width == INT_MIN)
				goto overflow;
			width = -width;
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
				GETASTER(n);
				prec = n < 0 ? -1 : n;
				goto rflag;
			}
			n = 0;
			while (is_digit(ch)) {
				APPEND_DIGIT(n, ch);
				ch = *fmt++;
			}
			if (ch == '$') {
				nextarg = n;
				if (argtable == NULL) {
					argtable = statargtable;
					if (__find_arguments(fmt0, orgap,
					    &argtable, &argtablesiz) == -1) {
						ret = -1;
						goto error;
					}
				}
				goto rflag;
			}
			prec = n;
			goto reswitch;
		case '0':
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				APPEND_DIGIT(n, ch);
				ch = *fmt++;
			} while (is_digit(ch));
			if (ch == '$') {
				nextarg = n;
				if (argtable == NULL) {
					argtable = statargtable;
					if (__find_arguments(fmt0, orgap,
					    &argtable, &argtablesiz) == -1) {
						ret = -1;
						goto error;
					}
				}
				goto rflag;
			}
			width = n;
			goto reswitch;
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
			goto rflag;
#endif
		case 'h':
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else {
				flags |= SHORTINT;
			}
			goto rflag;
		case 'j':
			flags |= MAXINT;
			goto rflag;
		case 'l':
			if (*fmt == 'l') {
				fmt++;
				flags |= LLONGINT;
			} else {
				flags |= LONGINT;
			}
			goto rflag;
		case 'q':
			flags |= LLONGINT;
			goto rflag;
		case 't':
			flags |= PTRINT;
			goto rflag;
		case 'z':
			flags |= SIZEINT;
			goto rflag;
		case 'c':
#ifdef PRINTF_WIDE_CHAR
			if (flags & LONGINT) {
				mbstate_t mbs;
				size_t mbseqlen;

				memset(&mbs, 0, sizeof(mbs));
				mbseqlen = wcrtomb(buf,
				    (wchar_t)GETARG(wint_t), &mbs);
				if (mbseqlen == (size_t)-1) {
					ret = -1;
					goto error;
				}
				cp = buf;
				size = (int)mbseqlen;
			} else {
#endif
				*(cp = buf) = GETARG(int);
				size = 1;
#ifdef PRINTF_WIDE_CHAR
			}
#endif
			sign = '\0';
			break;
		case 'D':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_umax = SARG();
			if ((intmax_t)_umax < 0) {
				_umax = -_umax;
				sign = '-';
			}
			base = DEC;
			goto number;
#ifdef FLOATING_POINT
		case 'a':
		case 'A':
			if (ch == 'a') {
				ox[1] = 'x';
				xdigs = xdigs_lower;
				expchar = 'p';
			} else {
				ox[1] = 'X';
				xdigs = xdigs_upper;
				expchar = 'P';
			}
			if (prec >= 0)
				prec++;
			if (dtoaresult)
				__freedtoa(dtoaresult);
			if (flags & LONGDBL) {
				fparg.ldbl = GETARG(long double);
				dtoaresult = cp =
				    __hldtoa(fparg.ldbl, xdigs, prec,
				    &expt, &signflag, &dtoaend);
				if (dtoaresult == NULL) {
					errno = ENOMEM;
					goto error;
				}
			} else {
				fparg.dbl = GETARG(double);
				dtoaresult = cp =
				    __hdtoa(fparg.dbl, xdigs, prec,
				    &expt, &signflag, &dtoaend);
				if (dtoaresult == NULL) {
					errno = ENOMEM;
					goto error;
				}
			}
			if (prec < 0)
				prec = dtoaend - cp;
			if (expt == INT_MAX)
				ox[1] = '\0';
			goto fp_common;
		case 'e':
		case 'E':
			expchar = ch;
			if (prec < 0)	/* account for digit before decpt */
				prec = DEFPREC + 1;
			else
				prec++;
			goto fp_begin;
		case 'f':
		case 'F':
			expchar = '\0';
			goto fp_begin;
		case 'g':
		case 'G':
			expchar = ch - ('g' - 'e');
 			if (prec == 0)
 				prec = 1;
fp_begin:
			if (prec < 0)
				prec = DEFPREC;
			if (dtoaresult)
				__freedtoa(dtoaresult);
			if (flags & LONGDBL) {
				fparg.ldbl = GETARG(long double);
				dtoaresult = cp =
				    __ldtoa(&fparg.ldbl, expchar ? 2 : 3, prec,
				    &expt, &signflag, &dtoaend);
				if (dtoaresult == NULL) {
					errno = ENOMEM;
					goto error;
				}
			} else {
				fparg.dbl = GETARG(double);
				dtoaresult = cp =
				    __dtoa(fparg.dbl, expchar ? 2 : 3, prec,
				    &expt, &signflag, &dtoaend);
				if (dtoaresult == NULL) {
					errno = ENOMEM;
					goto error;
				}
				if (expt == 9999)
					expt = INT_MAX;
 			}
fp_common:
			if (signflag)
				sign = '-';
			if (expt == INT_MAX) {	/* inf or nan */
				if (*cp == 'N')
					cp = (ch >= 'a') ? "nan" : "NAN";
				else
					cp = (ch >= 'a') ? "inf" : "INF";
 				size = 3;
				flags &= ~ZEROPAD;
 				break;
 			}
			flags |= FPT;
			ndig = dtoaend - cp;
 			if (ch == 'g' || ch == 'G') {
				if (expt > -4 && expt <= prec) {
					/* Make %[gG] smell like %[fF] */
					expchar = '\0';
					if (flags & ALT)
						prec -= expt;
					else
						prec = ndig - expt;
					if (prec < 0)
						prec = 0;
				} else {
					/*
					 * Make %[gG] smell like %[eE], but
					 * trim trailing zeroes if no # flag.
					 */
					if (!(flags & ALT))
						prec = ndig;
				}
 			}
			if (expchar) {
				expsize = exponent(expstr, expt - 1, expchar);
				size = expsize + prec;
				if (prec > 1 || flags & ALT)
 					++size;
			} else {
				/* space for digits before decimal point */
				if (expt > 0)
					size = expt;
				else	/* "0" */
					size = 1;
				/* space for decimal pt and following digits */
				if (prec || flags & ALT)
					size += prec + 1;
				lead = expt;
			}
			break;
#endif /* FLOATING_POINT */
#ifndef NO_PRINTF_PERCENT_N
		case 'n':
			if (flags & LLONGINT)
				*GETARG(long long *) = ret;
			else if (flags & LONGINT)
				*GETARG(long *) = ret;
			else if (flags & SHORTINT)
				*GETARG(short *) = ret;
			else if (flags & CHARINT)
				*GETARG(signed char *) = ret;
			else if (flags & PTRINT)
				*GETARG(ptrdiff_t *) = ret;
			else if (flags & SIZEINT)
				*GETARG(ssize_t *) = ret;
			else if (flags & MAXINT)
				*GETARG(intmax_t *) = ret;
			else
				*GETARG(int *) = ret;
			continue;	/* no output */
#endif /* NO_PRINTF_PERCENT_N */
		case 'O':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_umax = UARG();
			base = OCT;
			goto nosign;
		case 'p':
			/*
			 * ``The argument shall be a pointer to void.  The
			 * value of the pointer is converted to a sequence
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			_umax = (u_long)GETARG(void *);
			base = HEX;
			xdigs = xdigs_lower;
			ox[1] = 'x';
			goto nosign;
		case 's':
#ifdef PRINTF_WIDE_CHAR
			if (flags & LONGINT) {
				wchar_t *wcp;

				free(convbuf);
				convbuf = NULL;
				if ((wcp = GETARG(wchar_t *)) == NULL) {
					struct syslog_data sdata = SYSLOG_DATA_INIT;
					int save_errno = errno;

					syslog_r(LOG_CRIT | LOG_CONS, &sdata,
					    "vfprintf %%ls NULL in \"%s\"", fmt0);
					errno = save_errno;

					cp = "(null)";
				} else {
					convbuf = __wcsconv(wcp, prec);
					if (convbuf == NULL) {
						ret = -1;
						goto error;
					}
					cp = convbuf;
				}
			} else
#endif /* PRINTF_WIDE_CHAR */
			if ((cp = GETARG(char *)) == NULL) {
				struct syslog_data sdata = SYSLOG_DATA_INIT;
				int save_errno = errno;

				syslog_r(LOG_CRIT | LOG_CONS, &sdata,
				    "vfprintf %%s NULL in \"%s\"", fmt0);
				errno = save_errno;

				cp = "(null)";
			}
			len = prec >= 0 ? strnlen(cp, prec) : strlen(cp);
			if (len > INT_MAX)
				goto overflow;
			size = (int)len;
			sign = '\0';
			break;
		case 'U':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_umax = UARG();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = xdigs_upper;
			goto hex;
		case 'x':
			xdigs = xdigs_lower;
hex:			_umax = UARG();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _umax != 0)
				ox[1] = ch;

			/* unsigned conversions */
nosign:			sign = '\0';
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
				flags &= ~ZEROPAD;

			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
			if (_umax != 0 || prec != 0) {
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char(_umax & 7);
						_umax >>= 3;
					} while (_umax);
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					while (_umax >= 10) {
						*--cp = to_char(_umax % 10);
						_umax /= 10;
					}
					*--cp = to_char(_umax);
					break;

				case HEX:
					do {
						*--cp = xdigs[_umax & 15];
						_umax >>= 4;
					} while (_umax);
					break;

				default:
					cp = "bug in vfprintf: bad base";
					size = strlen(cp);
					goto skipsize;
				}
			}
			size = buf + BUF - cp;
			if (size > BUF)	/* should never happen */
				abort();
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
		}

		/*
		 * All reasonable formats wind up here.  At this point, `cp'
		 * points to a string which (if not flags&LADJUST) should be
		 * padded out to `width' places.  If flags&ZEROPAD, it should
		 * first be prefixed by any sign or other prefix; otherwise,
		 * it should be blank padded before the prefix is emitted.
		 * After any left-hand padding and prefixing, emit zeroes
		 * required by a decimal %[diouxX] precision, then print the
		 * string proper, then emit zeroes required by any leftover
		 * floating precision; finally, if LADJUST, pad with blanks.
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
			realsz++;
		if (ox[1])
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD(width - realsz, blanks);

		/* prefix */
		if (sign)
			PRINT(&sign, 1);
		if (ox[1]) {	/* ox[1] is either x, X, or \0 */
			ox[0] = '0';
			PRINT(ox, 2);
		}

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD(width - realsz, zeroes);

		/* leading zeroes from decimal precision */
		PAD(dprec - size, zeroes);

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
			PRINT(cp, size);
		} else {	/* glue together f_p fragments */
			if (decimal_point == NULL)
				decimal_point = nl_langinfo(RADIXCHAR);
			if (!expchar) {	/* %[fF] or sufficiently short %[gG] */
				if (expt <= 0) {
					PRINT(zeroes, 1);
					if (prec || flags & ALT)
						PRINT(decimal_point, 1);
					PAD(-expt, zeroes);
					/* already handled initial 0's */
					prec += expt;
 				} else {
					PRINTANDPAD(cp, dtoaend, lead, zeroes);
					cp += lead;
					if (prec || flags & ALT)
						PRINT(decimal_point, 1);
				}
				PRINTANDPAD(cp, dtoaend, prec, zeroes);
			} else {	/* %[eE] or sufficiently long %[gG] */
				if (prec > 1 || flags & ALT) {
					buf[0] = *cp++;
					buf[1] = *decimal_point;
					PRINT(buf, 2);
					PRINT(cp, ndig-1);
					PAD(prec - ndig, zeroes);
				} else { /* XeYYY */
					PRINT(cp, 1);
				}
				PRINT(expstr, expsize);
			}
		}
#else
		PRINT(cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD(width - realsz, blanks);

		/* finally, adjust ret */
		if (width < realsz)
			width = realsz;
		if (width > INT_MAX - ret)
			goto overflow;
		ret += width;

		FLUSH();	/* copy out the I/O vectors */
	}
done:
	FLUSH();
error:
	va_end(orgap);
	if (__sferror(fp))
		ret = -1;
	goto finish;

overflow:
	errno = EOVERFLOW;
	ret = -1;

finish:
#ifdef PRINTF_WIDE_CHAR
	free(convbuf);
#endif
#ifdef FLOATING_POINT
	if (dtoaresult)
		__freedtoa(dtoaresult);
#endif
	if (argtable != NULL && argtable != statargtable) {
		munmap(argtable, argtablesiz);
		argtable = NULL;
	}
	return (ret);
}

/*
 * Type ids for argument type table.
 */
#define T_UNUSED	0
#define T_SHORT		1
#define T_U_SHORT	2
#define TP_SHORT	3
#define T_INT		4
#define T_U_INT		5
#define TP_INT		6
#define T_LONG		7
#define T_U_LONG	8
#define TP_LONG		9
#define T_LLONG		10
#define T_U_LLONG	11
#define TP_LLONG	12
#define T_DOUBLE	13
#define T_LONG_DOUBLE	14
#define TP_CHAR		15
#define TP_VOID		16
#define T_PTRINT	17
#define TP_PTRINT	18
#define T_SIZEINT	19
#define T_SSIZEINT	20
#define TP_SSIZEINT	21
#define T_MAXINT	22
#define T_MAXUINT	23
#define TP_MAXINT	24
#define T_CHAR		25
#define T_U_CHAR	26
#define T_WINT		27
#define TP_WCHAR	28

/*
 * Find all arguments when a positional parameter is encountered.  Returns a
 * table, indexed by argument number, of pointers to each arguments.  The
 * initial argument table should be an array of STATIC_ARG_TBL_SIZE entries.
 * It will be replaced with a mmap-ed one if it overflows (malloc cannot be
 * used since we are attempting to make snprintf thread safe, and alloca is
 * problematic since we have nested functions..)
 */
static int
__find_arguments(const char *fmt0, va_list ap, union arg **argtable,
    size_t *argtablesiz)
{
	char *fmt;		/* format string */
	int ch;			/* character from fmt */
	int n, n2;		/* handy integer (short term usage) */
	char *cp;		/* handy char pointer (short term usage) */
	int flags;		/* flags as above */
	unsigned char *typetable; /* table of types */
	unsigned char stattypetable[STATIC_ARG_TBL_SIZE];
	int tablesize;		/* current size of type table */
	int tablemax;		/* largest used index in table */
	int nextarg;		/* 1-based argument index */
	int ret = 0;		/* return value */
	wchar_t wc;
	mbstate_t ps;

	/*
	 * Add an argument type to the table, expanding if necessary.
	 */
#define ADDTYPE(type) \
	((nextarg >= tablesize) ? \
		__grow_type_table(&typetable, &tablesize) : 0, \
	(nextarg > tablemax) ? tablemax = nextarg : 0, \
	typetable[nextarg++] = type)

#define	ADDSARG() \
        ((flags&MAXINT) ? ADDTYPE(T_MAXINT) : \
	    ((flags&PTRINT) ? ADDTYPE(T_PTRINT) : \
	    ((flags&SIZEINT) ? ADDTYPE(T_SSIZEINT) : \
	    ((flags&LLONGINT) ? ADDTYPE(T_LLONG) : \
	    ((flags&LONGINT) ? ADDTYPE(T_LONG) : \
	    ((flags&SHORTINT) ? ADDTYPE(T_SHORT) : \
	    ((flags&CHARINT) ? ADDTYPE(T_CHAR) : ADDTYPE(T_INT))))))))

#define	ADDUARG() \
        ((flags&MAXINT) ? ADDTYPE(T_MAXUINT) : \
	    ((flags&PTRINT) ? ADDTYPE(T_PTRINT) : \
	    ((flags&SIZEINT) ? ADDTYPE(T_SIZEINT) : \
	    ((flags&LLONGINT) ? ADDTYPE(T_U_LLONG) : \
	    ((flags&LONGINT) ? ADDTYPE(T_U_LONG) : \
	    ((flags&SHORTINT) ? ADDTYPE(T_U_SHORT) : \
	    ((flags&CHARINT) ? ADDTYPE(T_U_CHAR) : ADDTYPE(T_U_INT))))))))

	/*
	 * Add * arguments to the type array.
	 */
#define ADDASTER() \
	n2 = 0; \
	cp = fmt; \
	while (is_digit(*cp)) { \
		APPEND_DIGIT(n2, *cp); \
		cp++; \
	} \
	if (*cp == '$') { \
		int hold = nextarg; \
		nextarg = n2; \
		ADDTYPE(T_INT); \
		nextarg = hold; \
		fmt = ++cp; \
	} else { \
		ADDTYPE(T_INT); \
	}
	fmt = (char *)fmt0;
	typetable = stattypetable;
	tablesize = STATIC_ARG_TBL_SIZE;
	tablemax = 0;
	nextarg = 1;
	memset(typetable, T_UNUSED, STATIC_ARG_TBL_SIZE);
	memset(&ps, 0, sizeof(ps));

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
		size_t len;

		cp = fmt;
		while ((len = mbrtowc(&wc, fmt, MB_CUR_MAX, &ps)) != 0) {
			if (len == (size_t)-1 || len == (size_t)-2)
				return (-1);
			fmt += len;
			if (wc == '%') {
				fmt--;
				break;
			}
		}
		if (len == 0)
			goto done;
		fmt++;		/* skip over '%' */

		flags = 0;

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
		case ' ':
		case '#':
		case '\'':
			goto rflag;
		case '*':
			ADDASTER();
			goto rflag;
		case '-':
		case '+':
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
				ADDASTER();
				goto rflag;
			}
			while (is_digit(ch)) {
				ch = *fmt++;
			}
			goto reswitch;
		case '0':
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				APPEND_DIGIT(n ,ch);
				ch = *fmt++;
			} while (is_digit(ch));
			if (ch == '$') {
				nextarg = n;
				goto rflag;
			}
			goto reswitch;
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
			goto rflag;
#endif
		case 'h':
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else {
				flags |= SHORTINT;
			}
			goto rflag;
		case 'j':
			flags |= MAXINT;
			goto rflag;
		case 'l':
			if (*fmt == 'l') {
				fmt++;
				flags |= LLONGINT;
			} else {
				flags |= LONGINT;
			}
			goto rflag;
		case 'q':
			flags |= LLONGINT;
			goto rflag;
		case 't':
			flags |= PTRINT;
			goto rflag;
		case 'z':
			flags |= SIZEINT;
			goto rflag;
		case 'c':
#ifdef PRINTF_WIDE_CHAR
			if (flags & LONGINT)
				ADDTYPE(T_WINT);
			else
#endif
				ADDTYPE(T_INT);
			break;
		case 'D':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			ADDSARG();
			break;
#ifdef FLOATING_POINT
		case 'a':
		case 'A':
		case 'e':
		case 'E':
		case 'f':
		case 'F':
		case 'g':
		case 'G':
			if (flags & LONGDBL)
				ADDTYPE(T_LONG_DOUBLE);
			else
				ADDTYPE(T_DOUBLE);
			break;
#endif /* FLOATING_POINT */
#ifndef NO_PRINTF_PERCENT_N
		case 'n':
			if (flags & LLONGINT)
				ADDTYPE(TP_LLONG);
			else if (flags & LONGINT)
				ADDTYPE(TP_LONG);
			else if (flags & SHORTINT)
				ADDTYPE(TP_SHORT);
			else if (flags & PTRINT)
				ADDTYPE(TP_PTRINT);
			else if (flags & SIZEINT)
				ADDTYPE(TP_SSIZEINT);
			else if (flags & MAXINT)
				ADDTYPE(TP_MAXINT);
			else
				ADDTYPE(TP_INT);
			continue;	/* no output */
#endif /* NO_PRINTF_PERCENT_N */
		case 'O':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			ADDUARG();
			break;
		case 'p':
			ADDTYPE(TP_VOID);
			break;
		case 's':
#ifdef PRINTF_WIDE_CHAR
			if (flags & LONGINT)
				ADDTYPE(TP_WCHAR);
			else
#endif
				ADDTYPE(TP_CHAR);
			break;
		case 'U':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
		case 'X':
		case 'x':
			ADDUARG();
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			break;
		}
	}
done:
	/*
	 * Build the argument table.
	 */
	if (tablemax >= STATIC_ARG_TBL_SIZE) {
		*argtablesiz = sizeof(union arg) * (tablemax + 1);
		*argtable = mmap(NULL, *argtablesiz,
		    PROT_WRITE|PROT_READ, MAP_ANON|MAP_PRIVATE, -1, 0);
		if (*argtable == MAP_FAILED)
			return (-1);
	}

	for (n = 1; n <= tablemax; n++) {
		switch (typetable[n]) {
		case T_UNUSED:
		case T_CHAR:
		case T_U_CHAR:
		case T_SHORT:
		case T_U_SHORT:
		case T_INT:
			(*argtable)[n].intarg = va_arg(ap, int);
			break;
		case TP_SHORT:
			(*argtable)[n].pshortarg = va_arg(ap, short *);
			break;
		case T_U_INT:
			(*argtable)[n].uintarg = va_arg(ap, unsigned int);
			break;
		case TP_INT:
			(*argtable)[n].pintarg = va_arg(ap, int *);
			break;
		case T_LONG:
			(*argtable)[n].longarg = va_arg(ap, long);
			break;
		case T_U_LONG:
			(*argtable)[n].ulongarg = va_arg(ap, unsigned long);
			break;
		case TP_LONG:
			(*argtable)[n].plongarg = va_arg(ap, long *);
			break;
		case T_LLONG:
			(*argtable)[n].longlongarg = va_arg(ap, long long);
			break;
		case T_U_LLONG:
			(*argtable)[n].ulonglongarg = va_arg(ap, unsigned long long);
			break;
		case TP_LLONG:
			(*argtable)[n].plonglongarg = va_arg(ap, long long *);
			break;
#ifdef FLOATING_POINT
		case T_DOUBLE:
			(*argtable)[n].doublearg = va_arg(ap, double);
			break;
		case T_LONG_DOUBLE:
			(*argtable)[n].longdoublearg = va_arg(ap, long double);
			break;
#endif
		case TP_CHAR:
			(*argtable)[n].pchararg = va_arg(ap, char *);
			break;
		case TP_VOID:
			(*argtable)[n].pvoidarg = va_arg(ap, void *);
			break;
		case T_PTRINT:
			(*argtable)[n].ptrdiffarg = va_arg(ap, ptrdiff_t);
			break;
		case TP_PTRINT:
			(*argtable)[n].pptrdiffarg = va_arg(ap, ptrdiff_t *);
			break;
		case T_SIZEINT:
			(*argtable)[n].sizearg = va_arg(ap, size_t);
			break;
		case T_SSIZEINT:
			(*argtable)[n].ssizearg = va_arg(ap, ssize_t);
			break;
		case TP_SSIZEINT:
			(*argtable)[n].pssizearg = va_arg(ap, ssize_t *);
			break;
		case T_MAXINT:
			(*argtable)[n].intmaxarg = va_arg(ap, intmax_t);
			break;
		case T_MAXUINT:
			(*argtable)[n].uintmaxarg = va_arg(ap, uintmax_t);
			break;
		case TP_MAXINT:
			(*argtable)[n].pintmaxarg = va_arg(ap, intmax_t *);
			break;
#ifdef PRINTF_WIDE_CHAR
		case T_WINT:
			(*argtable)[n].wintarg = va_arg(ap, wint_t);
			break;
		case TP_WCHAR:
			(*argtable)[n].pwchararg = va_arg(ap, wchar_t *);
			break;
#endif
		}
	}
	goto finish;

overflow:
	errno = EOVERFLOW;
	ret = -1;

finish:
	if (typetable != NULL && typetable != stattypetable) {
		munmap(typetable, *argtablesiz);
		typetable = NULL;
	}
	return (ret);
}

/*
 * Increase the size of the type table.
 */
static int
__grow_type_table(unsigned char **typetable, int *tablesize)
{
	unsigned char *oldtable = *typetable;
	int newsize = *tablesize * 2;

	if (newsize < getpagesize())
		newsize = getpagesize();

	if (*tablesize == STATIC_ARG_TBL_SIZE) {
		*typetable = mmap(NULL, newsize, PROT_WRITE|PROT_READ,
		    MAP_ANON|MAP_PRIVATE, -1, 0);
		if (*typetable == MAP_FAILED)
			return (-1);
		bcopy(oldtable, *typetable, *tablesize);
	} else {
		unsigned char *new = mmap(NULL, newsize, PROT_WRITE|PROT_READ,
		    MAP_ANON|MAP_PRIVATE, -1, 0);
		if (new == MAP_FAILED)
			return (-1);
		memmove(new, *typetable, *tablesize);
		munmap(*typetable, *tablesize);
		*typetable = new;
	}
	memset(*typetable + *tablesize, T_UNUSED, (newsize - *tablesize));

	*tablesize = newsize;
	return (0);
}

 
#ifdef FLOATING_POINT
static int
exponent(char *p0, int exp, int fmtch)
{
	char *p, *t;
	char expbuf[MAXEXPDIG];

	p = p0;
	*p++ = fmtch;
	if (exp < 0) {
		exp = -exp;
		*p++ = '-';
	} else
		*p++ = '+';
	t = expbuf + MAXEXPDIG;
	if (exp > 9) {
		do {
			*--t = to_char(exp % 10);
		} while ((exp /= 10) > 9);
		*--t = to_char(exp);
		for (; t < expbuf + MAXEXPDIG; *p++ = *t++)
			/* nothing */;
	} else {
		/*
		 * Exponents for decimal floating point conversions
		 * (%[eEgG]) must be at least two characters long,
		 * whereas exponents for hexadecimal conversions can
		 * be only one character long.
		 */
		if (fmtch == 'e' || fmtch == 'E')
			*p++ = '0';
		*p++ = to_char(exp);
	}
	return (p - p0);
}
#endif /* FLOATING_POINT */
@


1.76
log
@When a precision is specified for a string format use strnlen()
to determine the length instead of doing it manually.  OK schwarze@@
@
text
@d492 6
a497 2
		while ((n = mbrtowc(&wc, fmt, MB_CUR_MAX, &ps)) > 0) {
			fmt += n;
a502 4
		if (n < 0) {
			ret = -1;
			goto error;
		}
d510 1
a510 1
		if (n == 0)
d1220 2
d1223 4
a1226 2
		while ((n = mbrtowc(&wc, fmt, MB_CUR_MAX, &ps)) > 0) {
			fmt += n;
d1232 1
a1232 3
		if (n < 0)
			return (-1);
		if (n == 0)
@


1.75
log
@% is escaped with more %, not backslash.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.74 2016/08/17 18:07:07 deraadt Exp $	*/
d489 2
d891 4
a894 16
			if (prec >= 0) {
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen() will go further.
				 */
				char *p = memchr(cp, 0, prec);

				size = p ? (p - cp) : prec;
			} else {
				size_t len;

				if ((len = strlen(cp)) > INT_MAX)
					goto overflow;
				size = (int)len;
			}
@


1.74
log
@Generate syslog warnings for %s fmt strings NULL to "(null)" conversions.
Over time we can repair software which performs this non-standard behaviour,
and fix bugs along the way.  Let's first find out how bad the situation is
by deploying this in snapshots.

This type of logging is possible because OpenBSD syslog_r(3) -> sendsyslog(2)
is side-effect free enough to be used in the bowels of libc.

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.73 2016/06/06 17:22:59 millert Exp $	*/
d865 1
a865 1
					    "vfprintf \%ls NULL in \"%s\"", fmt0);
d884 1
a884 1
				    "vfprintf \%s NULL in \"%s\"", fmt0);
@


1.73
log
@Return EOVERFLOW, not ENOMEM for overflow conditions to match POSIX.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.72 2016/01/19 18:22:53 mmcc Exp $	*/
d53 1
d861 7
d879 8
a886 1
			if ((cp = GETARG(char *)) == NULL)
d888 1
@


1.72
log
@remove a nop assignment that has been #if 0'd since 1996

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.71 2016/01/04 15:47:47 schwarze Exp $	*/
d1079 1
a1079 1
	errno = ENOMEM;
d1477 1
a1477 1
	errno = ENOMEM;
@


1.71
log
@Fix lots of bugs.
1. When fprintf(fp, "...%ls...", ...) encounters an encoding error,
do not destroy all the fp->_flags, which made the file permanently
unreadable and unwriteable.
2. Do not change fp->_flags at all in case of encoding errors.
Neither the manual nor POSIX ask for it, no other conversions set the
error indicator, and it isn't needed because the return value reports
failure and must be checked anyway.
3. Detect failure in mbrtowc(3), do not silently treat invalid bytes
in the format string as the end of the format string.
4. Detect failure of __find_arguments(), no matter whether due to
out of memory conditions or encoding errors, and gracefully fail
rather than accessing an invalid pointer.
5. Remove the pointless and slightly dangerous errno = EILSEQ overrides
after functions that already do that and are required by the standard
to do so.
OK jca@@ on items 1, 2, and 5.
OK millert@@ on the complete diff.
"Completely brutal mix of bugs."  deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.70 2015/12/28 22:08:18 mmcc Exp $	*/
a1388 4
#if 0
	/* XXX is this required? */
	(*argtable)[0].intarg = 0;
#endif
@


1.70
log
@Remove NULL-checks before free() and a few related dead assignments.

ok and valuable input from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.69 2015/09/29 03:19:24 guenther Exp $	*/
d168 1
a168 2
		if (nbytes == (size_t)-1) {
			errno = EILSEQ;
a169 1
		}
d189 1
a189 2
			if (clen == (size_t)-1) {
				errno = EILSEQ;
a190 1
			}
a201 1
		errno = EILSEQ;
d436 5
a440 1
			__find_arguments(fmt0, orgap, &argtable, &argtablesiz); \
d496 4
d507 1
a507 1
		if (n <= 0)
d570 5
a574 2
					__find_arguments(fmt0, orgap,
					    &argtable, &argtablesiz);
d599 5
a603 2
					__find_arguments(fmt0, orgap,
					    &argtable, &argtablesiz);
d652 1
a652 2
					fp->_flags |= __SERR;
					errno = EILSEQ;
d864 1
a864 1
						fp->_flags = __SERR;
d1222 3
a1224 1
		if (n <= 0)
@


1.69
log
@Delete the final, inscrutable NOSTRICT and VARARGS lint comments

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.68 2015/08/31 02:53:57 guenther Exp $	*/
d849 2
a850 4
				if (convbuf != NULL) {
					free(convbuf);
					convbuf = NULL;
				}
d1076 1
a1076 2
	if (convbuf)
		free(convbuf);
@


1.68
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.67 2014/12/21 00:23:30 daniel Exp $	*/
a838 1
			/* NOSTRICT */
@


1.67
log
@Show the sign for NaN as per POSIX; from Elliott Hughes.

ok martynas@@, millert@@, doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.66 2014/05/03 12:36:45 deraadt Exp $	*/
d271 1
@


1.66
log
@Add #ifndef NO_PRINTF_PERCENT_N.  Since we are fully standardized, we
don't use disable %n ourselves.  But Google's Android libc is based
on our libc....  Giving them an easy knob to disable this dangerous
feature easily make their job easier without making our job any harder.
Request from Elliott @@ google
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.65 2014/03/19 05:17:01 guenther Exp $	*/
d756 1
a756 1
				if (*cp == 'N') {
d758 1
a758 2
					sign = '\0';
				} else
@


1.65
log
@It's still safe to assumed 'signed' exists
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.64 2013/11/01 19:05:10 guenther Exp $	*/
d804 1
d823 1
d1322 1
d1339 1
@


1.64
log
@Pull in gdtoa.h instead of declaring __dtoa() and __freedtoa() directly

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.63 2013/03/02 19:40:08 guenther Exp $	*/
d401 1
a401 1
	    flags&CHARINT ? (__signed char)GETARG(int) : \
d812 1
a812 1
				*GETARG(__signed char *) = ret;
@


1.63
log
@Fix the combination of 'j' format flag and the XPG "<num>$" modifier.

ok deraadt@@ kettenis@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.62 2012/06/26 14:53:23 matthew Exp $	*/
d219 1
a222 2
extern char *__dtoa(double, int, int, int *, int *, char **);
extern void  __freedtoa(char *);
@


1.62
log
@Use nl_langinfo(RADIXCHAR) instead of localeconv()->decimal_point in
printf() and avoid calling it unless needed (i.e., when we have a
floating point value to print).  This isn't a big concern currently
due to our limited locale support and current localeconv()
implementation, but it's still technically a data race and
implementing POSIX 2008 per-thread locales is likely to make it worse.

nl_langinfo() isn't guaranteed by POSIX to be thread-safe either, but
at least our current implementation is thread-safe and it's a simpler
interface to keep that way.  Printing floating point values isn't
async-signal-safe anyway due to gdtoa()'s use of malloc(), so that's
not an issue.

ok deraadt, stsp, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.61 2011/07/06 19:53:52 stsp Exp $	*/
d1271 3
d1450 6
d1457 1
a1457 1
			(*argtable)[n].intmaxarg = va_arg(ap, intmax_t);
@


1.61
log
@Add support for C99 %ls and %lc format directives, as been documented in
the vfprintf(3) man page for ages. Based on code from NetBSD/FreeBSD.
Prevent ramdisk growth with a maze of #ifdefs.
ok robert, no objections deraadt, espie, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.60 2010/12/22 14:54:44 millert Exp $	*/
d44 1
d303 1
a303 1
	char *decimal_point = localeconv()->decimal_point;
d1018 2
@


1.60
log
@Fix out of date comment; no code change
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.59 2010/10/17 20:26:51 guenther Exp $	*/
d52 1
d83 4
d146 66
d334 3
d479 3
d633 22
a654 2
			*(cp = buf) = GETARG(int);
			size = 1;
d844 20
d1074 4
d1119 2
d1286 6
a1291 1
			ADDTYPE(T_INT);
d1341 6
a1346 1
			ADDTYPE(TP_CHAR);
d1447 8
@


1.59
log
@The ssizearg member of union arg is pointless if it isn't of type ssize_t

Noted by Claus Assmann
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.58 2009/11/09 00:18:27 kurt Exp $	*/
d179 1
a179 1
#define	LONGDBL		0x0008		/* long double; unimplemented */
@


1.58
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

committing on behalf of and okay guenther@@ now that we have install
media space available.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.57 2009/10/28 21:15:02 naddy Exp $	*/
d65 1
a65 1
	size_t			ssizearg;
@


1.57
log
@skip the \' formatting flag, grouping is not implemented; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.56 2009/10/22 01:23:16 guenther Exp $	*/
d133 2
a134 2
	ret = vfprintf(&fake, fmt, ap);
	if (ret >= 0 && fflush(&fake))
d192 11
@


1.56
log
@Back out previous commit, as it caused too much growth for the install
media to fit
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.55 2009/10/21 16:04:23 guenther Exp $	*/
d440 3
d1090 1
@


1.55
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

ok kurt@@, earlier version tested by sthen@@ and jj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.54 2009/10/16 12:15:03 martynas Exp $	*/
d133 2
a134 2
	ret = __vfprintf(&fake, fmt, ap);
	if (ret >= 0 && __sflush(&fake))
a191 11
{
	int ret;

	FLOCKFILE(fp);
	ret = __vfprintf(fp, fmt0, ap);
	FUNLOCKFILE(fp);
	return (ret);
}

int
__vfprintf(FILE *fp, const char *fmt0, __va_list ap)
@


1.54
log
@teach gdtoa & its subroutines that malloc can fail;  in which case
ecvt, fcvt, gcvt, *printf, strtof, strtod, strtold act per ieee
1003.1.  after these massive changes, remove unused files which
would not work now.  reported by Maksymilian Arciemowicz;  ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.53 2008/10/21 17:51:17 martynas Exp $	*/
d133 2
a134 2
	ret = vfprintf(&fake, fmt, ap);
	if (ret >= 0 && fflush(&fake))
d192 11
@


1.53
log
@use decimal point from locale.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.52 2008/09/07 20:36:08 martynas Exp $	*/
d579 4
d588 4
d625 4
d634 4
@


1.52
log
@- replace dtoa w/ David's gdtoa, version 2008-03-15
- provide proper dtoa locks
- use the real strtof implementation
- add strtold, __hdtoa, __hldtoa
- add %a/%A support
- don't lose precision in printf, don't round to double anymore
- implement extended-precision versions of libc functions: fpclassify,
isnan, isinf, signbit, isnormal, isfinite, now that the ieee.h is
fixed
- separate vax versions of strtof, and __hdtoa
- add complex math support.  added functions: cacos, casin, catan,
ccos, csin, ctan, cacosh, casinh, catanh, ccosh, csinh, ctanh, cexp,
clog, cabs, cpow, csqrt, carg, cimag, conj, cproj, creal, cacosf,
casinf, catanf, ccosf, csinf, ctanf, cacoshf, casinhf, catanhf,
ccoshf, csinhf, ctanhf, cexpf, clogf, cabsf, cpowf, csqrtf, cargf,
cimagf, conjf, cprojf, crealf
- add fdim, fmax, fmin
- add log2. (adapted implementation e_log.c.  could be more acruate
& faster, but it's good enough for now)
- remove wrappers & cruft in libm, supposed to work-around mistakes
in SVID, etc.;  use ieee versions.  fixes issues in python 2.6 for
djm@@
- make _digittoint static
- proper definitions for i386, and amd64 in ieee.h
- sh, powerpc don't really have extended-precision
- add missing definitions for mips64 (quad), m{6,8}k (96-bit) float.h
for LDBL_*
- merge lead to frac for m{6,8}k, for gdtoa to work properly
- add FRAC*BITS & EXT_TO_ARRAY32 definitions in ieee.h, for hdtoa&ldtoa
to use
- add EXT_IMPLICIT_NBIT definition, which indicates implicit
normalization bit
- add regression tests for libc: fpclassify and printf
- arith.h & gd_qnan.h definitions
- update ieee.h: hppa doesn't have quad-precision, hppa64 does
- add missing prototypes to gdtoaimp
- on 64-bit platforms make sure gdtoa doesn't use a long when it
really wants an int
- etc., what i may have forgotten...
- bump libm major, due to removed&changed symbols
- no libc bump, since this is riding on djm's libc major crank from
a day ago

discussed with / requested by / testing theo, sthen@@, djm@@, jsg@@,
merdely@@, jsing@@, tedu@@, brad@@, jakemsr@@, and others.
looks good to millert@@
parts of the diff ok kettenis@@

this commit does not include:
- man page changes
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.51 2008/08/27 00:40:38 martynas Exp $	*/
d882 1
a882 1
						PRINT(".", 1);
d888 1
a888 1
					buf[1] = '.';
@


1.51
log
@comment fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.50 2008/08/26 18:29:12 martynas Exp $	*/
d143 1
a147 1
#define	BUF		(MAXEXP+MAXFRACT+1)	/* + decimal point */
a151 1
static char *cvt(double, int, int, int *, int *, int, int *);
d153 1
d155 8
a162 3
#else /* no FLOATING_POINT */
#define	BUF		40
#endif /* FLOATING_POINT */
a177 1
#define	HEXPREFIX	0x0002		/* add 0x or 0X prefix */
d201 1
a201 1
	int prec;		/* precision from format (%.3d), or -1 */
d206 14
d221 5
a225 2
	int softsign;		/* temporary negative sign for floats */
	double _double;		/* double precision arguments %[eEfFgG] */
d227 2
d230 3
a232 2
	int ndig;		/* actual number of digits returned by cvt */
	char expstr[7];		/* buffer for exponent string */
d237 1
a237 1
	enum { OCT, DEC, HEX } base;/* base for %[diouxX] conversion */
d241 1
a241 1
	char *xdigs;		/* digits for %[xX] conversion */
d245 2
a246 2
	char buf[BUF];		/* space for %c, %[diouxX], %[eEfFgG] */
	char ox[2];		/* space for 0x hex-prefix */
d264 3
d290 8
d424 1
d559 31
d592 6
d600 2
d604 5
a608 1
			if (prec == -1) {
d610 2
a611 4
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
				prec = 1;
			}

d613 4
a616 1
				_double = (double) GETARG(long double);
d618 17
a634 21
				_double = GETARG(double);
			}

			/* do this before tricky precision changes */
			if (isinf(_double)) {
				if (_double < 0)
					sign = '-';
				if (ch == 'E' || ch == 'F' || ch == 'G')
					cp = "INF";
				else
					cp = "inf";
				size = 3;
				flags &= ~ZEROPAD;
				break;
			}
			if (isnan(_double)) {
				if (ch == 'E' || ch == 'F' || ch == 'G')
					cp = "NAN";
				else
					cp = "nan";
				size = 3;
d636 2
a637 3
				break;
			}

d639 18
a656 24
			if (dtoaresult)
				__freedtoa(dtoaresult);
			dtoaresult = cp = cvt(_double, prec, flags, &softsign,
				&expt, ch, &ndig);
			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
					ch = (ch == 'g') ? 'e' : 'E';
				else
					ch = 'g';
			}
			if (ch == 'e' || ch == 'E') {	/* 'e' or 'E' fmt */
				--expt;
				expsize = exponent(expstr, expt, ch);
				size = expsize + ndig;
				if (ndig > 1 || flags & ALT)
					++size;
			} else if (ch == 'f' || ch == 'F') {
							/* 'f' or 'F' fmt */
				if (expt > 0) {
					size = expt;
					if (prec || flags & ALT)
						size += prec + 1;
				} else { /* "0.X" */
					size = prec + 2;
d658 6
a663 4
			} else if (expt >= ndig) {	/* fixed g fmt */
				size = expt;
				if (flags & ALT)
					++size;
d665 9
a673 1
				size = ndig + (expt > 0 ?  1 : 2 - expt);
a674 3

			if (softsign)
				sign = '-';
d713 2
a714 3
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ch = 'x';
d745 1
a745 1
			xdigs = "0123456789ABCDEF";
d748 1
a748 1
			xdigs = "0123456789abcdef";
d753 1
a753 1
				flags |= HEXPREFIX;
d811 2
d843 1
a843 1
		else if (flags & HEXPREFIX)
d851 1
a851 1
		if (sign) {
d853 1
a853 1
		} else if (flags & HEXPREFIX) {
a854 1
			ox[1] = ch;
d870 4
a873 5
			if (ch >= 'f' || ch == 'F') {	/* 'f', 'g' or 'F' */
				if (_double == 0) {
					/* kludge for __dtoa irregularity */
					PRINT("0", 1);
					if (expt < ndig || (flags & ALT) != 0) {
a874 5
						PAD(ndig - 1, zeroes);
					}
				} else if (expt <= 0) {
					PRINT("0", 1);
					PRINT(decimal_point, 1);
d876 6
a881 5
					PRINT(cp, ndig);
				} else if (expt >= ndig) {
					PRINT(cp, ndig);
					PAD(expt - ndig, zeroes);
					if (flags & ALT)
a882 5
				} else {
					PRINT(cp, expt);
					cp += expt;
					PRINT(".", 1);
					PRINT(cp, ndig-expt);
d884 8
a891 11
			} else {	/* 'e' or 'E' */
				if (ndig > 1 || flags & ALT) {
					ox[0] = *cp++;
					ox[1] = '.';
					PRINT(ox, 2);
					if (_double) {
						PRINT(cp, ndig-1);
					} else {/* 0.[0..] */
						/* __dtoa irregularity */
						PAD(ndig - 1, zeroes);
					}
d1142 2
a1333 38

static char *
cvt(double value, int ndigits, int flags, int *sign, int *decpt, int ch, 
    int *length)
{
	int mode;
	char *digits, *bp, *rve;

	if (ch == 'f' || ch == 'F') {
		mode = 3;		/* ndigits after the decimal point */
	} else {
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
			ndigits++;
		}
		mode = 2;		/* ndigits significant digits */
	}

	digits = __dtoa(value, mode, ndigits, decpt, sign, &rve);
	if ((ch != 'g' && ch != 'G') || flags & ALT) {/* Print trailing zeros */
		bp = digits + ndigits;
		if (ch == 'f' || ch == 'F') {
			if (*digits == '0' && value)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
			*rve++ = '0';
	}
	*length = rve - digits;
	return (digits);
}

d1338 1
a1338 1
	char expbuf[MAXEXP];
d1347 1
a1347 1
	t = expbuf + MAXEXP;
d1353 1
a1353 1
		for (; t < expbuf + MAXEXP; *p++ = *t++)
d1356 8
a1363 1
		*p++ = '0';
@


1.50
log
@- add F
- make inf INF nan NAN comply to standards (eEfFgG)
- extend man page bits
ok millert@@.  w/ a man page tweak and ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.48 2008/07/10 18:18:55 martynas Exp $	*/
d204 1
a204 1
	double _double;		/* double precision arguments %[eEfgG] */
d213 2
a214 2
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
d217 1
a217 1
	char *xdigs;		/* digits for [xX] conversion */
d221 1
a221 1
	char buf[BUF];		/* space for %c, %[diouxX], %[eEfgG] */
d756 1
a756 1
		 * required by a decimal [diouxX] precision, then print the
@


1.49
log
@don't zero-pad special values.  ok millert@@
@
text
@d526 1
d545 4
a548 1
				cp = "Inf";
d554 4
a557 1
				cp = "NaN";
d574 1
a574 1
			if (ch <= 'e') {	/* 'e' or 'E' fmt */
d580 2
a581 1
			} else if (ch == 'f') {		/* f fmt */
d794 1
a794 1
			if (ch >= 'f') {	/* 'f' or 'g' */
d1082 1
d1277 1
a1277 1
	if (ch == 'f') {
d1293 1
a1293 1
		if (ch == 'f') {
@


1.48
log
@- handle sign of negative zero.  use sign dtoa sets
- remove 'value < 0' cruft, dtoa already clears sign bit for us
discussed with, and tested by phessler@@
ok millert@@, who noticed to remove now-unused variable, and phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.47 2008/05/16 20:42:52 millert Exp $	*/
d546 1
d552 1
@


1.47
log
@Fix ssize_t vs. size_t mismatch
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.46 2008/05/16 14:28:53 millert Exp $	*/
d152 1
a152 1
static char *cvt(double, int, int, char *, int *, int, int *);
d203 1
a203 1
	char softsign;		/* temporary negative sign for floats */
d1260 1
a1260 1
cvt(double value, int ndigits, int flags, char *sign, int *decpt, int ch, 
d1263 1
a1263 1
	int mode, dsgn;
d1279 1
a1279 6
	if (value < 0) {
		value = -value;
		*sign = '-';
	} else
		*sign = '\000';
	digits = __dtoa(value, mode, ndigits, decpt, &dsgn, &rve);
@


1.46
log
@C99 says that for each va_copy() there must be a matching va_end().
Replace the non-portable hackery in __find_arguments() with a union.
From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.45 2008/05/13 18:52:25 millert Exp $	*/
d76 1
a76 1
	size_t			*pssizearg;
@


1.45
log
@Don't forget to va_end() the va_list we get from va_copy().  From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.44 2008/05/05 21:50:45 chl Exp $	*/
d56 29
a84 1
static int __find_arguments(const char *fmt0, va_list ap, va_list **argtable,
d223 2
a224 2
	va_list *argtable;	/* args, built due to positional arg */
	va_list statargtable[STATIC_ARG_TBL_SIZE];
d336 2
a337 2
	(((argtable != NULL) ? (void)(ap = argtable[nextarg]) : (void)0), \
	 nextarg++, va_arg(ap, type))
d905 1
a905 1
__find_arguments(const char *fmt0, va_list ap, va_list **argtable,
d1127 1
a1127 1
		*argtablesiz = sizeof (va_list) * (tablemax + 1);
d1136 1
a1136 1
	(*argtable) [0] = NULL;
a1138 1
		va_copy((*argtable)[n], ap);
d1146 1
a1146 1
			(void) va_arg(ap, int);
d1149 1
a1149 1
			(void) va_arg(ap, short *);
d1152 1
a1152 1
			(void) va_arg(ap, unsigned int);
d1155 1
a1155 1
			(void) va_arg(ap, int *);
d1158 1
a1158 1
			(void) va_arg(ap, long);
d1161 1
a1161 1
			(void) va_arg(ap, unsigned long);
d1164 1
a1164 1
			(void) va_arg(ap, long *);
d1167 1
a1167 1
			(void) va_arg(ap, long long);
d1170 1
a1170 1
			(void) va_arg(ap, unsigned long long);
d1173 1
a1173 1
			(void) va_arg(ap, long long *);
d1175 1
d1177 1
a1177 1
			(void) va_arg(ap, double);
d1180 1
a1180 1
			(void) va_arg(ap, long double);
d1182 1
d1184 1
a1184 1
			(void) va_arg(ap, char *);
d1187 1
a1187 1
			(void) va_arg(ap, void *);
d1190 1
a1190 1
			(void) va_arg(ap, ptrdiff_t);
d1193 1
a1193 1
			(void) va_arg(ap, ptrdiff_t *);
d1196 1
a1196 1
			(void) va_arg(ap, size_t);
d1199 1
a1199 1
			(void) va_arg(ap, ssize_t);
d1202 1
a1202 1
			(void) va_arg(ap, ssize_t *);
d1205 1
a1205 1
			(void) va_arg(ap, intmax_t *);
@


1.44
log
@add missing header for getpagesize

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.43 2007/11/28 19:06:19 deraadt Exp $	*/
d816 1
@


1.43
log
@%hhd was being printed as if %hd was specified
ok millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.42 2007/01/30 03:57:29 ray Exp $	*/
d51 1
@


1.42
log
@Remove and simplify an impossible case (if *p = memchr(cp, 0, prec),
p - cp cannot be greater than prec).

Prevent an integer overflow when printing a string with length
greater than INT_MAX.

Initial diff from millert@@.

OK millert@@, beck@@, and otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.41 2007/01/16 19:20:53 millert Exp $	*/
d449 6
a454 1
			flags |= SHORTINT;
d863 2
d907 2
a908 1
	    ((flags&SHORTINT) ? ADDTYPE(T_SHORT) : ADDTYPE(T_INT)))))))
d916 2
a917 1
	    ((flags&SHORTINT) ? ADDTYPE(T_U_SHORT) : ADDTYPE(T_U_INT)))))))
d1112 2
a1113 2
			(void) va_arg(ap, int);
			break;
a1114 2
			(void) va_arg(ap, int);
			break;
d1116 1
a1120 3
			break;
		case T_INT:
			(void) va_arg(ap, int);
@


1.41
log
@Fix potential int overflow for printf(3) when passing in very large
values for the field width.  Adapted from a diff by Christian Biere.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.40 2006/11/26 06:20:16 deraadt Exp $	*/
d608 1
a608 7
				if (p != NULL) {
					size = p - cp;
					if (size > prec)
						size = prec;
				} else {
					size = prec;
				}
d610 5
a614 1
				size = strlen(cp);
@


1.40
log
@try first mmap() allocation at pagesize, no need to re-mmap at every power
of 2 from 16 to pagesize(); ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.39 2006/10/29 18:45:55 deraadt Exp $	*/
d44 1
d162 1
a162 1
	int n, m, n2;		/* handy integers (short term usage) */
d264 12
d284 1
a284 1
		n2 = 10 * n2 + to_digit(*cp); \
d344 4
a347 1
		if ((m = fmt - cp) != 0) {
d385 2
d403 1
a403 1
				n = 10 * n + to_digit(ch);
d415 1
a415 1
			prec = n < 0 ? -1 : n;
d429 1
a429 1
				n = 10 * n + to_digit(ch);
d801 5
a805 1
		ret += width > realsz ? width : realsz;
d812 9
d829 1
a829 2
	return (__sferror(fp) ? EOF : ret);
	/* NOTREACHED */
d883 1
d919 1
a919 1
		n2 = 10 * n2 + to_digit(*cp); \
d983 1
a983 1
				n = 10 * n + to_digit(ch);
d1175 1
d1177 5
d1186 1
a1186 1
	return (0);
@


1.39
log
@make __dtoa & strtod() thread-safe useing the same method as newer gdtoa
codebase.  tested mostly by ckuethe and myself.  __dtoa() use now requires
a call to __freedtoa()
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.38 2006/04/29 23:00:23 tedu Exp $	*/
d1160 3
@


1.38
log
@check mmap for failure.  the helper functions using it return -1, but
callers do not yet check since printf() for example is not documented
to return an error.
some formatting cleanups.
mostly ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.37 2006/01/13 17:56:18 millert Exp $	*/
d120 2
d179 1
d503 3
a505 1
			cp = cvt(_double, prec, flags, &softsign,
d790 4
a1183 2

extern char *__dtoa(double, int, int, int *, int *, char **);
@


1.37
log
@Use long long and intmax_t instead of quad_t throughout.  Adapted in
part from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.36 2006/01/06 18:53:04 millert Exp $	*/
d54 1
a54 1
static void __find_arguments(const char *fmt0, va_list ap, va_list **argtable,
d157 6
a162 6
	char *fmt;	/* format string */
	int ch;	/* character from fmt */
	int n, m, n2;	/* handy integers (short term usage) */
	char *cp;	/* handy char pointer (short term usage) */
	struct __siov *iovp;/* for PRINT macro */
	int flags;	/* flags as above */
d519 1
a519 1
				} else	/* "0.X" */
d521 1
d526 3
a528 3
			} else
				size = ndig + (expt > 0 ?
					1 : 2 - expt);
d589 1
a589 1
				} else
d591 2
a592 1
			} else
d594 1
d760 1
a760 1
					} else	/* 0.[0..] */
d763 2
a764 1
				} else	/* XeYYY */
d766 1
d830 1
a830 1
static void
d834 5
a838 5
	char *fmt;	/* format string */
	int ch;	/* character from fmt */
	int n, n2;	/* handy integer (short term usage) */
	char *cp;	/* handy char pointer (short term usage) */
	int flags;	/* flags as above */
d1051 1
a1051 1
		*argtable = (va_list *)mmap(NULL, *argtablesiz,
d1053 2
d1140 1
d1153 1
a1153 2
		*typetable = (unsigned char *)mmap(NULL,
		    sizeof (unsigned char) * newsize, PROT_WRITE|PROT_READ,
d1155 2
a1156 1
		/* XXX unchecked */
d1159 1
a1159 2
		unsigned char *new = (unsigned char *)mmap(NULL,
		    sizeof (unsigned char) * newsize, PROT_WRITE|PROT_READ,
d1161 2
a1165 1
		/* XXX unchecked */
d1170 1
a1170 1
	return(0);
d1204 1
a1204 1
	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
d1231 1
a1231 2
	}
	else
d1239 3
a1241 3
		for (; t < expbuf + MAXEXP; *p++ = *t++);
	}
	else {
@


1.36
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.35 2005/12/19 19:43:01 millert Exp $ */
d43 2
d47 1
a49 2
#include <errno.h>
#include <stdarg.h>
d140 13
a152 12
#define	ALT		0x001		/* alternate form */
#define	HEXPREFIX	0x002		/* add 0x or 0X prefix */
#define	LADJUST		0x004		/* left adjustment */
#define	LONGDBL		0x008		/* long double; unimplemented */
#define	LONGINT		0x010		/* long integer */
#define	QUADINT		0x020		/* quad integer */
#define	SHORTINT	0x040		/* short integer */
#define	ZEROPAD		0x080		/* zero (as opposed to blank) pad */
#define FPT		0x100		/* Floating point number */
#define PTRINT		0x200		/* (unsigned) ptrdiff_t */
#define SIZEINT		0x400		/* (signed) size_t */
#define CHARINT		0x800		/* 8 bit integer */
d179 1
a179 6
#ifdef __GNUC__			/* gcc has builtin quad type (long long) SOS */
#define	quad_t	  long long
#define	u_quad_t  unsigned long long
#endif

	u_quad_t _uquad;	/* integer arguments %[diouxX] */
d242 2
a243 1
	(flags&QUADINT ? GETARG(quad_t) : \
d247 3
a249 3
	    flags&SHORTINT ? (long)(short)GETARG(int) : \
	    flags&CHARINT ? (long)(__signed char)GETARG(int) : \
	    (long)GETARG(int))
d251 4
a254 3
	(flags&QUADINT ? GETARG(u_quad_t) : \
	    flags&LONGINT ? GETARG(u_long) : \
	    flags&PTRINT ? GETARG(ptrdiff_t) : /* XXX */ \
d256 3
a258 3
	    flags&SHORTINT ? (u_long)(u_short)GETARG(int) : \
	    flags&CHARINT ? (u_long)(u_char)GETARG(int) : \
	    (u_long)GETARG(u_int))
d431 1
a431 1
			flags |= QUADINT;
d436 1
a436 1
				flags |= QUADINT;
d442 1
a442 1
			flags |= QUADINT;
d460 3
a462 3
			_uquad = SARG();
			if ((quad_t)_uquad < 0) {
				_uquad = -_uquad;
d534 2
a535 2
			if (flags & QUADINT)
				*GETARG(quad_t *) = ret;
d540 2
d546 2
d555 1
a555 1
			_uquad = UARG();
d567 1
a567 1
			_uquad = (u_long)GETARG(void *);
d598 1
a598 1
			_uquad = UARG();
d606 1
a606 1
hex:			_uquad = UARG();
d609 1
a609 1
			if (flags & ALT && _uquad != 0)
d628 1
a628 1
			if (_uquad != 0 || prec != 0) {
d637 3
a639 3
						*--cp = to_char(_uquad & 7);
						_uquad >>= 3;
					} while (_uquad);
d647 3
a649 3
					while (_uquad >= 10) {
						*--cp = to_char(_uquad % 10);
						_uquad /= 10;
d651 1
a651 1
					*--cp = to_char(_uquad);
d656 3
a658 3
						*--cp = xdigs[_uquad & 15];
						_uquad >>= 4;
					} while (_uquad);
d801 3
a803 3
#define T_QUAD		10
#define T_U_QUAD	11
#define TP_QUAD		12
d813 3
d852 4
a855 1
	((flags&QUADINT) ? ADDTYPE(T_QUAD) : \
d857 1
a857 1
		((flags&SHORTINT) ? ADDTYPE(T_SHORT) : ADDTYPE(T_INT))))
d860 4
a863 1
	((flags&QUADINT) ? ADDTYPE(T_U_QUAD) : \
d865 1
a865 1
		((flags&SHORTINT) ? ADDTYPE(T_U_SHORT) : ADDTYPE(T_U_INT))))
d962 1
a962 1
				flags |= QUADINT;
d968 1
a968 1
			flags |= QUADINT;
d984 1
a984 8
			if (flags & QUADINT)
				ADDTYPE(T_QUAD);
			else if (flags & PTRINT)
				ADDTYPE(T_PTRINT);
			else if (flags & SIZEINT)
				ADDTYPE(T_SSIZEINT);
			else
				ADDSARG();
d999 2
a1000 2
			if (flags & QUADINT)
				ADDTYPE(TP_QUAD);
d1009 2
d1018 1
a1018 4
			if (flags & QUADINT)
				ADDTYPE(T_U_QUAD);
			else
				ADDUARG();
a1029 5
			if (flags & QUADINT)
				ADDTYPE(T_U_QUAD);
			else
				ADDUARG();
			break;
d1032 1
a1032 8
			if (flags & QUADINT)
				ADDTYPE(T_U_QUAD);
			else if (flags & PTRINT)
				ADDTYPE(T_PTRINT);
			else if (flags & SIZEINT)
				ADDTYPE(T_SIZEINT);
			else
				ADDUARG();
d1087 2
a1088 2
		case T_QUAD:
			(void) va_arg(ap, quad_t);
d1090 2
a1091 2
		case T_U_QUAD:
			(void) va_arg(ap, u_quad_t);
d1093 2
a1094 2
		case TP_QUAD:
			(void) va_arg(ap, quad_t *);
d1122 3
@


1.35
log
@Missing piece from previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.34 2005/12/19 19:39:25 millert Exp $ */
d153 1
a153 1
vfprintf(FILE *fp, const char *fmt0, _BSD_VA_LIST_ ap)
@


1.34
log
@Add %hhd to *printf and *scanf as well as %z to *scanf.  This was
sent out and approved about 6 months ago and has been rotting in
my tree ever since.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.33 2005/09/23 02:33:34 tedu Exp $ */
d150 1
@


1.33
log
@support %jd from c99, although intmax_t may not be available.
ok deraadt espie kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vfprintf.c,v 1.32 2005/08/08 08:05:36 espie Exp $ */
d249 1
d257 1
d939 6
a944 1
			flags |= SHORTINT;
@


1.32
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d427 3
@


1.31
log
@
next citrus step.

reviewed by millert, otto, kevlo, naddy, kettenis...
libc+libstdc++ bump
@
text
@d1 1
a32 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.29 2005/04/30 09:25:17 espie Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.30
log
@Fix rearranging of parameters for quad types.
Use stateful functions for mbtowc.
Use the same loop for scanning and for rescanning the format.

okay millert@@
@
text
@d295 1
@


1.29
log
@Change internals of FILE: reuse the unget buffer field to access an
extended attribute data structure (pimpl idiom). Idea taken from citrus.
Much discussion with deraadt@@, otto@@, millert@@...

This is the least disruptive way to extend FILE, since its size can't really
change without this being a flag day. So the size doesn't change.

Actual additions to the structure will come in separate steps, since this
change is nasty enough on its own.

Tests by otto@@ and others, careful reading of code by otto@@ and millert@@.

This is definitely a major bump, and has been checked to not impact a
full ports build.
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.28 2004/09/28 18:12:44 otto Exp $";
d168 1
d247 1
a247 1
	(flags&QUADINT ? va_arg(ap, quad_t) : \
d254 1
a254 1
	(flags&QUADINT ? va_arg(ap, u_quad_t) : \
d315 1
d321 1
a321 1
		while ((n = mbtowc(&wc, fmt, MB_CUR_MAX)) > 0) {
d829 2
d842 3
a844 2
	((flags&LONGINT) ? ADDTYPE(T_LONG) : \
		((flags&SHORTINT) ? ADDTYPE(T_SHORT) : ADDTYPE(T_INT)))
d847 3
a849 2
	((flags&LONGINT) ? ADDTYPE(T_U_LONG) : \
		((flags&SHORTINT) ? ADDTYPE(T_U_SHORT) : ADDTYPE(T_U_INT)))
d876 1
d882 9
a890 3
		for (cp = fmt; (ch = *fmt) != '\0' && ch != '%'; fmt++)
			/* void */;
		if (ch == '\0')
@


1.28
log
@deregister + ansify, no change in object code. ok deraadt@@ millert@@
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.27 2004/09/25 06:35:50 brad Exp $";
d89 1
d92 1
@


1.27
log
@typo fix, from the original diff in PR 3932
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.26 2004/09/25 02:33:41 deraadt Exp $";
d65 1
a65 3
__sprint(fp, uio)
	FILE *fp;
	register struct __suio *uio;
d67 1
a67 1
	register int err;
d85 1
a85 4
__sbprintf(fp, fmt, ap)
	register FILE *fp;
	const char *fmt;
	va_list ap;
d153 1
a153 4
vfprintf(fp, fmt0, ap)
	FILE *fp;
	const char *fmt0;
	_BSD_VA_LIST_ ap;
d155 6
a160 6
	register char *fmt;	/* format string */
	register int ch;	/* character from fmt */
	register int n, m, n2;	/* handy integers (short term usage) */
	register char *cp;	/* handy char pointer (short term usage) */
	register struct __siov *iovp;/* for PRINT macro */
	register int flags;	/* flags as above */
d812 2
a813 5
__find_arguments(fmt0, ap, argtable, argtablesiz)
	const char *fmt0;
	va_list ap;
	va_list **argtable;
	size_t *argtablesiz;
d815 5
a819 5
	register char *fmt;	/* format string */
	register int ch;	/* character from fmt */
	register int n, n2;	/* handy integer (short term usage) */
	register char *cp;	/* handy char pointer (short term usage) */
	register int flags;	/* flags as above */
d1120 1
a1120 3
__grow_type_table(typetable, tablesize)
	unsigned char **typetable;
	int *tablesize;
d1152 2
a1153 4
cvt(value, ndigits, flags, sign, decpt, ch, length)
	double value;
	int ndigits, flags, *decpt, ch, *length;
	char *sign;
d1194 1
a1194 3
exponent(p0, exp, fmtch)
	char *p0;
	int exp, fmtch;
d1196 1
a1196 1
	register char *p, *t;
@


1.26
log
@oops
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.25 2004/09/24 23:25:49 deraadt Exp $";
d815 1
a815 1
 * It will be replaces with a mmap-ed one if it overflows (malloc cannot be
@


1.25
log
@access one too far away; from claus; ok millert
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.24 2004/09/24 21:41:14 deraadt Exp $";
d843 1
a843 1
	(nextarg > tablemax) ? tablemax = nextarg : 0,
@


1.24
log
@explain why mmap; pointed out by claus, pr 3932
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.23 2004/09/18 19:28:06 otto Exp $";
d843 2
a844 2
	typetable[nextarg++] = type, \
	(nextarg > tablemax) ? tablemax = nextarg : 0)
@


1.23
log
@Add 'z' and 't' modifiers for printing size_t and ptrdiff_t.
ok millert@@ deraadt@@
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.22 2004/09/16 20:21:03 otto Exp $";
d815 3
a817 1
 * It will be replaces with a malloc-ed on if it overflows.
@


1.22
log
@Handle ll's correctly for positional args. Problem spotted by hin@@,
ok henning@@ millert@@ deraadt@@
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.21 2004/09/14 22:20:21 deraadt Exp $";
d46 1
d154 3
d254 2
d261 2
d445 6
d541 4
d805 5
d943 6
d957 1
a957 1
			if (flags & QUADINT) {
d959 5
a963 1
			} else {
a964 1
			}
d985 4
d1020 4
d1100 15
@


1.21
log
@signed vs unsigned
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.20 2003/06/02 20:18:37 millert Exp $";
d910 6
a915 1
			flags |= LONGINT;
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.19 2003/05/16 21:13:21 deraadt Exp $";
d1083 1
a1083 1
		char *new = (unsigned char *)mmap(NULL,
@


1.19
log
@When positional arguments need more memory for storage (more than 8 args),
use mmap() instead of malloc().  this makes all the functionality in
snprintf() and friends signal race safe.  it also makes syslog_r() and the
entire family of *warn*() and *err*() signal race safe, which was the
real goal. ok pjazen millert
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.18 2002/10/24 17:13:36 drahn Exp $";
@


1.18
log
@Use va_copy() for varargs assignemnt. va_copy() is standard with C99
and gcc3.2 requires this on powerpc.
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.17 2002/02/19 19:39:37 millert Exp $";
d48 1
d59 2
a60 1
static void __find_arguments(const char *fmt0, va_list ap, va_list **argtable);
d202 1
d277 1
a277 1
			__find_arguments(fmt0, orgap, &argtable); \
d390 1
a390 1
					    &argtable);
d416 1
a416 1
					    &argtable);
d763 4
a766 2
	if (argtable != NULL && argtable != statargtable)
		free(argtable);
d799 1
a799 1
__find_arguments(fmt0, ap, argtable)
d803 1
d997 3
a999 2
		*argtable = (va_list *)
		    malloc(sizeof (va_list) * (tablemax + 1));
d1063 4
a1066 2
	if (typetable != NULL && typetable != stattypetable)
		free(typetable);
d1081 3
a1083 2
		*typetable = (unsigned char *)
		    malloc(sizeof (unsigned char) * newsize);
d1087 6
a1092 2
		*typetable = (unsigned char *)
		    realloc(*typetable, sizeof (unsigned char) * newsize);
@


1.17
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.16 2002/02/17 19:42:24 millert Exp $";
d307 1
a307 1
	orgap = ap;
d1000 1
a1000 1
		(*argtable)[n] = ap;
@


1.16
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.15 2002/02/16 21:27:24 millert Exp $";
a52 2

#ifdef __STDC__
a53 3
#else
#include <varargs.h>
#endif
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.14 2001/12/05 10:20:06 deraadt Exp $";
d63 2
a64 4
static void __find_arguments __P((const char *fmt0, va_list ap,
	va_list **argtable));
static int __grow_type_table __P((unsigned char **typetable,
	int *tablesize));
@


1.14
log
@KNF, i need this for what comes next..
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.13 2001/08/13 19:16:34 millert Exp $";
d133 2
a134 2
static char *cvt __P((double, int, int, char *, int *, int, int *));
static int exponent __P((char *, int, int));
d1097 1
a1097 1
extern char *__dtoa __P((double, int, int, int *, int *, char **));
@


1.13
log
@Fix a bug with the %e flag introduced in a -Wall pass.  The original
code was in error but due to C precedence rules it didn't cause a
problem.
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.12 2001/07/09 06:57:45 deraadt Exp $";
d60 2
a61 2
#include "local.h"  
#include "fvwrite.h"  
d205 1
a205 1
	va_list *argtable;        /* args, built due to positional arg */
d207 2
a208 2
	int nextarg;            /* 1-based argument index */
	va_list orgap;          /* original argument pointer */
d265 5
a269 5
 
         /*
          * Get * arguments, including the form *nn$.  Preserve the nextarg
          * that the argument can be gotten once the type is determined.
          */
d271 5
a275 16
	 n2 = 0; \
	 cp = fmt; \
	 while (is_digit(*cp)) { \
		 n2 = 10 * n2 + to_digit(*cp); \
		 cp++; \
	 } \
	 if (*cp == '$') { \
	       int hold = nextarg; \
		 if (argtable == NULL) { \
			 argtable = statargtable; \
			 __find_arguments(fmt0, orgap, &argtable); \
		 } \
		 nextarg = n2; \
		 val = GETARG(int); \
		 nextarg = hold; \
		 fmt = ++cp; \
d277 13
a289 3
	else { \
	       val = GETARG(int); \
	 }
d299 1
a299 1
 
d415 1
a415 1
                       	if (ch == '$') {
d417 3
a419 3
			   	if (argtable == NULL) {
			   		argtable = statargtable;
			   		__find_arguments(fmt0, orgap,
d421 2
a422 2
			  	}
				goto rflag; 
d502 1
a502 1
			} 
d787 4
a790 4
#define T_U_QUAD      	11
#define TP_QUAD         12
#define T_DOUBLE      	13
#define T_LONG_DOUBLE 	14
d799 1
a799 1
 */ 
d856 1
a856 1
	tablemax = 0; 
d1094 1
a1094 1
  
d1111 2
a1112 2
		/* To obtain ndigits after the decimal point for the 'e' 
		 * and 'E' formats, round to ndigits + 1 significant 
@


1.12
log
@a first pass at -Wall
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.11 2001/05/31 18:11:38 deraadt Exp $";
d743 1
a743 1
					if (_double || (flags & ALT) == 0) {
@


1.11
log
@knf
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.10 2001/04/20 00:10:11 millert Exp $";
d743 1
a743 1
					if (_double || flags & ALT == 0) {
@


1.10
log
@Fix an incorrect memset() in __grow_type_table(); dk@@homepage.ru
While I was there I noticed and fixed a bogus realloc().
We should really check malloc/realloc return values and deal sanely
but that will have to be done later.  Theo OK'd
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.9 1999/08/22 17:06:35 millert Exp $";
d281 1
a281 1
			 __find_arguments (fmt0, orgap, &argtable); \
d420 1
a420 1
			   		__find_arguments (fmt0, orgap,
d768 2
a769 2
	if ((argtable != NULL) && (argtable != statargtable))
		free (argtable);
d802 1
a802 1
__find_arguments (fmt0, ap, argtable)
d848 1
a848 1
		ADDTYPE (T_INT); \
d852 1
a852 1
		ADDTYPE (T_INT); \
d859 1
a859 1
	memset (typetable, T_UNUSED, STATIC_ARG_TBL_SIZE);
d879 1
a879 1
			ADDASTER ();
d886 1
a886 1
				ADDASTER ();
d1000 1
a1000 1
		    malloc (sizeof (va_list) * (tablemax + 1));
d1008 4
a1011 4
		(*argtable) [n] = ap;
		switch (typetable [n]) {
		    case T_UNUSED:
			(void) va_arg (ap, int);
d1013 2
a1014 2
		    case T_SHORT:
			(void) va_arg (ap, int);
d1016 2
a1017 2
		    case T_U_SHORT:
			(void) va_arg (ap, int);
d1019 2
a1020 2
		    case TP_SHORT:
			(void) va_arg (ap, short *);
d1022 2
a1023 2
		    case T_INT:
			(void) va_arg (ap, int);
d1025 2
a1026 2
		    case T_U_INT:
			(void) va_arg (ap, unsigned int);
d1028 2
a1029 2
		    case TP_INT:
			(void) va_arg (ap, int *);
d1031 2
a1032 2
		    case T_LONG:
			(void) va_arg (ap, long);
d1034 2
a1035 2
		    case T_U_LONG:
			(void) va_arg (ap, unsigned long);
d1037 2
a1038 2
		    case TP_LONG:
			(void) va_arg (ap, long *);
d1040 2
a1041 2
		    case T_QUAD:
			(void) va_arg (ap, quad_t);
d1043 2
a1044 2
		    case T_U_QUAD:
			(void) va_arg (ap, u_quad_t);
d1046 2
a1047 2
		    case TP_QUAD:
			(void) va_arg (ap, quad_t *);
d1049 2
a1050 2
		    case T_DOUBLE:
			(void) va_arg (ap, double);
d1052 2
a1053 2
		    case T_LONG_DOUBLE:
			(void) va_arg (ap, long double);
d1055 2
a1056 2
		    case TP_CHAR:
			(void) va_arg (ap, char *);
d1058 2
a1059 2
		    case TP_VOID:
			(void) va_arg (ap, void *);
d1064 2
a1065 2
	if ((typetable != NULL) && (typetable != stattypetable))
		free (typetable);
d1081 1
a1081 1
		    malloc (sizeof (unsigned char) * newsize);
d1083 1
a1083 1
		bcopy (oldtable, *typetable, *tablesize);
d1086 1
a1086 1
		    realloc (*typetable, sizeof (unsigned char) * newsize);
d1089 1
a1089 1
	memset (*typetable + *tablesize, T_UNUSED, (newsize - *tablesize));
@


1.9
log
@do { ... } while (0) instead of just { ... } in macros
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.8 1998/08/14 21:39:42 deraadt Exp $";
d1082 1
d1086 1
a1086 1
		    realloc (typetable, sizeof (unsigned char) * newsize);
d1089 1
a1089 1
	memset (&typetable [*tablesize], T_UNUSED, (newsize - *tablesize));
@


1.8
log
@realloc repair
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.7 1997/07/25 20:30:12 mickey Exp $";
d224 1
a224 1
#define	PRINT(ptr, len) { \
d234 2
a235 2
}
#define	PAD(howmany, with) { \
d243 2
a244 2
}
#define	FLUSH() { \
d249 1
a249 1
}
@


1.7
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.6 1996/12/14 06:49:43 tholo Exp $";
d63 4
a66 3
static void __find_arguments(const char *fmt0, va_list ap, va_list **argtable);
static int __grow_type_table(unsigned char **typetable,
			      int *tablesize);
d1072 1
a1072 1
__grow_type_table (typetable, tablesize)
d1086 1
a1086 1

@


1.6
log
@Clean up lint and compile warnings
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.5 1996/11/13 18:46:29 niklas Exp $";
d54 1
a54 1
#if __STDC__
@


1.5
log
@va_list is *not* void* all over...
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.4 1996/10/27 00:33:06 tholo Exp $";
d64 1
a64 1
static void __grow_type_table(int nextarg, unsigned char **typetable,
a810 1
	int width;		/* width from format (%8d), or 0 */
d822 1
a822 1
		__grow_type_table(nextarg, &typetable, &tablesize) : 0, \
a870 1
		width = 0;
a904 1
			width = n;
d1070 2
a1071 3
static void
__grow_type_table (nextarg, typetable, tablesize)
	int nextarg;
d1090 1
@


1.4
log
@Set errno to EBADF when attempting to write to a file pointer opened read-only
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.3 1996/09/24 20:02:14 michaels Exp $";
d63 3
a65 3
static void __find_arguments(const char *fmt0, va_list ap, void ***argtable);
static void __grow_type_table(int nextarg, unsigned char **typetable
			     ,int *tablesize);
d204 2
a205 2
	void **argtable;        /* args, built due to positional arg */
	void *statargtable [STATIC_ARG_TBL_SIZE];
d297 2
a298 2
	((argtable != NULL) ? \
	*((type*)(argtable[nextarg++])) : (nextarg++, va_arg(ap, type)))
d393 2
a394 1
					__find_arguments(fmt0, orgap, &argtable);
d418 3
a420 3
			   	argtable = statargtable;
			   	__find_arguments (fmt0, orgap,
			   	&argtable);
d768 1
a768 1
	free (argtable);
d772 1
d775 1
a775 1
*/
d804 1
a804 1
	void ***argtable;
d813 1
a813 1
	unsigned char stattypetable [STATIC_ARG_TBL_SIZE];
d1001 2
a1002 2
		*argtable = (void **)
		    malloc (sizeof (void *) * (tablemax + 1));
d1005 2
d1008 1
@


1.3
log
@Support XPG/3-style positional arguments in printf family.
From Mark Diekhans (markd@@grizzly.com).
@
text
@d38 1
a38 1
static char *rcsid = "$OpenBSD: vfprintf.c,v 1.1.1.1 1995/10/18 08:42:15 deraadt Exp $";
d52 1
d301 2
a302 1
	if (cantwrite(fp))
d304 1
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d59 6
a64 2
#include "local.h"
#include "fvwrite.h"
a134 1

d136 1
d138 1
a138 1
#endif /* FLOATING_POINT */
d168 1
a168 1
	register int n, m;	/* handy integers (short term usage) */
d203 4
d255 3
a257 3
	    flags&LONGINT ? va_arg(ap, long) : \
	    flags&SHORTINT ? (long)(short)va_arg(ap, int) : \
	    (long)va_arg(ap, int))
d260 29
a288 3
	    flags&LONGINT ? va_arg(ap, u_long) : \
	    flags&SHORTINT ? (u_long)(u_short)va_arg(ap, int) : \
	    (u_long)va_arg(ap, u_int))
d290 9
d309 3
d364 2
a365 1
			if ((width = va_arg(ap, int)) >= 0)
d377 1
a377 1
				n = va_arg(ap, int);
d386 8
d411 9
d442 1
a442 1
			*(cp = buf) = va_arg(ap, int);
d471 1
a471 1
				_double = (double) va_arg(ap, long double);
d473 1
a473 1
				_double = va_arg(ap, double);
d526 1
a526 1
				*va_arg(ap, quad_t *) = ret;
d528 1
a528 1
				*va_arg(ap, long *) = ret;
d530 1
a530 1
				*va_arg(ap, short *) = ret;
d532 1
a532 1
				*va_arg(ap, int *) = ret;
d550 1
a550 1
			_uquad = (u_long)va_arg(ap, void *);
d557 1
a557 1
			if ((cp = va_arg(ap, char *)) == NULL)
d763 2
d768 319
d1088 1
@


1.1
log
@Initial revision
@
text
@d38 1
a38 2
/*static char *sccsid = "from: @@(#)vfprintf.c	5.50 (Berkeley) 12/16/92";*/
static char *rcsid = "$Id: vfprintf.c,v 1.17 1995/05/02 19:52:41 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
