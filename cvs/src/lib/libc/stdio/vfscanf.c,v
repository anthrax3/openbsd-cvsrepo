head	1.34;
access;
symbols
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.8
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.6
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.6
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.4
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.14
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.12
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.10
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.8
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.6
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.14
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.12
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.10
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2016.10.30.05.07.06;	author jsg;	state Exp;
branches;
next	1.33;
commitid	aoBkNCjFAcH18XWa;

1.33
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.32;
commitid	pqjnYVtACzQ9ctai;

1.32
date	2015.08.31.02.53.57;	author guenther;	state Exp;
branches;
next	1.31;
commitid	lTMF8Y3C9fQGd6jQ;

1.31
date	2014.03.19.05.17.01;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.17.17.40.35;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2012.01.18.14.01.38;	author stsp;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.08.18.30.42;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.03.17.57.47;	author martynas;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.03.05.16.59;	author martynas;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.09.00.18.27;	author kurt;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.22.01.23.16;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.21.16.04.23;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.05.19.29.28;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.13.21.33.28;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.13.17.56.18;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.08.02.13.28;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.06.18.53.04;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.03.00.57.45;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.19.19.39.25;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.08.08.05.36;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.17.20.40.32;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.28.04.34.05;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.11.18.39.19;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.31.18.36.29;	author pat;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.28.18.12.44;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.20.18.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.19.19.39.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.09.06.57.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.01.20.21.25.39;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.01.19.19.40.12;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.20.30.13;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.09.31.46;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.33.12;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@include float.h for the LDBL_MAX_EXP cpp test in floatio.h
@
text
@/*	$OpenBSD: vfscanf.c,v 1.33 2016/09/21 04:38:56 guenther Exp $ */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <ctype.h>
#include <wctype.h>
#include <inttypes.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "local.h"

#ifdef FLOATING_POINT
#include <float.h>
#include "floatio.h"
#endif

#define	BUF		513	/* Maximum length of numeric string. */

/*
 * Flags used during conversion.
 */
#define	LONG		0x00001	/* l: long or double */
#define	LONGDBL		0x00002	/* L: long double */
#define	SHORT		0x00004	/* h: short */
#define	SHORTSHORT	0x00008	/* hh: 8 bit integer */
#define LLONG		0x00010	/* ll: long long (+ deprecated q: quad) */
#define	POINTER		0x00020	/* p: void * (as hex) */
#define	SIZEINT		0x00040	/* z: (signed) size_t */
#define	MAXINT		0x00080	/* j: intmax_t */
#define	PTRINT		0x00100	/* t: ptrdiff_t */
#define	NOSKIP		0x00200	/* [ or c: do not skip blanks */
#define	SUPPRESS	0x00400	/* *: suppress assignment */
#define	UNSIGNED	0x00800	/* %[oupxX] conversions */

/*
 * The following are used in numeric conversions only:
 * SIGNOK, HAVESIGN, NDIGITS, DPTOK, and EXPOK are for floating point;
 * SIGNOK, HAVESIGN, NDIGITS, PFXOK, and NZDIGITS are for integral.
 */
#define	SIGNOK		0x01000	/* +/- is (still) legal */
#define	HAVESIGN	0x02000	/* sign detected */
#define	NDIGITS		0x04000	/* no digits detected */

#define	DPTOK		0x08000	/* (float) decimal point is still legal */
#define	EXPOK		0x10000	/* (float) exponent (e+3, etc) still legal */

#define	PFXOK		0x08000	/* 0x prefix is (still) legal */
#define	NZDIGITS	0x10000	/* no zero digits detected */

/*
 * Conversion types.
 */
#define	CT_CHAR		0	/* %c conversion */
#define	CT_CCL		1	/* %[...] conversion */
#define	CT_STRING	2	/* %s conversion */
#define	CT_INT		3	/* integer, i.e., strtoimax or strtoumax */
#define	CT_FLOAT	4	/* floating, i.e., strtod */

#define u_char unsigned char
#define u_long unsigned long

static u_char *__sccl(char *, u_char *);

/*
 * Internal, unlocked version of vfscanf
 */
int
__svfscanf(FILE *fp, const char *fmt0, __va_list ap)
{
	u_char *fmt = (u_char *)fmt0;
	int c;		/* character from format, or conversion */
	size_t width;	/* field width, or 0 */
	char *p;	/* points into all kinds of strings */
	int n;		/* handy integer */
	int flags;	/* flags as defined above */
	char *p0;	/* saves original value of p when necessary */
	int nassigned;		/* number of fields assigned */
	int nread;		/* number of characters consumed from fp */
	int base;		/* base argument to strtoimax/strtouimax */
	char ccltab[256];	/* character class table for %[...] */
	char buf[BUF];		/* buffer for numeric conversions */
#ifdef SCANF_WIDE_CHAR
	wchar_t *wcp;		/* handy wide character pointer */
	size_t nconv;		/* length of multibyte sequence converted */
	mbstate_t mbs;
#endif

	/* `basefix' is used to avoid `if' tests in the integer scanner */
	static short basefix[17] =
		{ 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };

	_SET_ORIENTATION(fp, -1);

	nassigned = 0;
	nread = 0;
	base = 0;		/* XXX just to keep gcc happy */
	for (;;) {
		c = *fmt++;
		if (c == 0)
			return (nassigned);
		if (isspace(c)) {
			while ((fp->_r > 0 || __srefill(fp) == 0) &&
			    isspace(*fp->_p))
				nread++, fp->_r--, fp->_p++;
			continue;
		}
		if (c != '%')
			goto literal;
		width = 0;
		flags = 0;
		/*
		 * switch on the format.  continue if done;
		 * break once format type is derived.
		 */
again:		c = *fmt++;
		switch (c) {
		case '%':
literal:
			if (fp->_r <= 0 && __srefill(fp))
				goto input_failure;
			if (*fp->_p != c)
				goto match_failure;
			fp->_r--, fp->_p++;
			nread++;
			continue;

		case '*':
			flags |= SUPPRESS;
			goto again;
		case 'j':
			flags |= MAXINT;
			goto again;
		case 'L':
			flags |= LONGDBL;
			goto again;
		case 'h':
			if (*fmt == 'h') {
				fmt++;
				flags |= SHORTSHORT;
			} else {
				flags |= SHORT;
			}
			goto again;
		case 'l':
			if (*fmt == 'l') {
				fmt++;
				flags |= LLONG;
			} else {
				flags |= LONG;
			}
			goto again;
		case 'q':
			flags |= LLONG;		/* deprecated */
			goto again;
		case 't':
			flags |= PTRINT;
			goto again;
		case 'z':
			flags |= SIZEINT;
			goto again;

		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			width = width * 10 + c - '0';
			goto again;

		/*
		 * Conversions.
		 * Those marked `compat' are for 4.[123]BSD compatibility.
		 *
		 * (According to ANSI, E and X formats are supposed
		 * to the same as e and x.  Sorry about that.)
		 */
		case 'D':	/* compat */
			flags |= LONG;
			/* FALLTHROUGH */
		case 'd':
			c = CT_INT;
			base = 10;
			break;

		case 'i':
			c = CT_INT;
			base = 0;
			break;

		case 'O':	/* compat */
			flags |= LONG;
			/* FALLTHROUGH */
		case 'o':
			c = CT_INT;
			flags |= UNSIGNED;
			base = 8;
			break;

		case 'u':
			c = CT_INT;
			flags |= UNSIGNED;
			base = 10;
			break;

		case 'X':
		case 'x':
			flags |= PFXOK;	/* enable 0x prefixing */
			c = CT_INT;
			flags |= UNSIGNED;
			base = 16;
			break;

#ifdef FLOATING_POINT
		case 'e': case 'E':
		case 'f': case 'F':
		case 'g': case 'G':
		case 'a': case 'A':
			c = CT_FLOAT;
			break;
#endif

		case 's':
			c = CT_STRING;
			break;

		case '[':
			fmt = __sccl(ccltab, fmt);
			flags |= NOSKIP;
			c = CT_CCL;
			break;

		case 'c':
			flags |= NOSKIP;
			c = CT_CHAR;
			break;

		case 'p':	/* pointer format is like hex */
			flags |= POINTER | PFXOK;
			c = CT_INT;
			flags |= UNSIGNED;
			base = 16;
			break;

		case 'n':
			if (flags & SUPPRESS)
				continue;
			if (flags & SHORTSHORT)
				*va_arg(ap, signed char *) = nread;
			else if (flags & SHORT)
				*va_arg(ap, short *) = nread;
			else if (flags & LONG)
				*va_arg(ap, long *) = nread;
			else if (flags & SIZEINT)
				*va_arg(ap, ssize_t *) = nread;
			else if (flags & PTRINT)
				*va_arg(ap, ptrdiff_t *) = nread;
			else if (flags & LLONG)
				*va_arg(ap, long long *) = nread;
			else if (flags & MAXINT)
				*va_arg(ap, intmax_t *) = nread;
			else
				*va_arg(ap, int *) = nread;
			continue;

		/*
		 * Disgusting backwards compatibility hacks.	XXX
		 */
		case '\0':	/* compat */
			return (EOF);

		default:	/* compat */
			if (isupper(c))
				flags |= LONG;
			c = CT_INT;
			base = 10;
			break;
		}

		/*
		 * We have a conversion that requires input.
		 */
		if (fp->_r <= 0 && __srefill(fp))
			goto input_failure;

		/*
		 * Consume leading white space, except for formats
		 * that suppress this.
		 */
		if ((flags & NOSKIP) == 0) {
			while (isspace(*fp->_p)) {
				nread++;
				if (--fp->_r > 0)
					fp->_p++;
				else if (__srefill(fp))
					goto input_failure;
			}
			/*
			 * Note that there is at least one character in
			 * the buffer, so conversions that do not set NOSKIP
			 * ca no longer result in an input failure.
			 */
		}

		/*
		 * Do the conversion.
		 */
		switch (c) {

		case CT_CHAR:
			/* scan arbitrary characters (sets NOSKIP) */
			if (width == 0)
				width = 1;
#ifdef SCANF_WIDE_CHAR
			if (flags & LONG) {
				if ((flags & SUPPRESS) == 0)
					wcp = va_arg(ap, wchar_t *);
				else
					wcp = NULL;
				n = 0;
				while (width != 0) {
					if (n == MB_CUR_MAX) {
						fp->_flags |= __SERR;
						goto input_failure;
					}
					buf[n++] = *fp->_p;
					fp->_p++;
					fp->_r--;
					bzero(&mbs, sizeof(mbs));
					nconv = mbrtowc(wcp, buf, n, &mbs);
					if (nconv == (size_t)-1) {
						fp->_flags |= __SERR;
						goto input_failure;
					}
					if (nconv == 0 && !(flags & SUPPRESS))
						*wcp = L'\0';
					if (nconv != (size_t)-2) {
						nread += n;
						width--;
						if (!(flags & SUPPRESS))
							wcp++;
						n = 0;
					}
					if (fp->_r <= 0 && __srefill(fp)) {
						if (n != 0) {
							fp->_flags |= __SERR;
							goto input_failure;
						}
						break;
					}
				}
				if (!(flags & SUPPRESS))
					nassigned++;
			} else
#endif /* SCANF_WIDE_CHAR */
			if (flags & SUPPRESS) {
				size_t sum = 0;
				for (;;) {
					if ((n = fp->_r) < width) {
						sum += n;
						width -= n;
						fp->_p += n;
						if (__srefill(fp)) {
							if (sum == 0)
							    goto input_failure;
							break;
						}
					} else {
						sum += width;
						fp->_r -= width;
						fp->_p += width;
						break;
					}
				}
				nread += sum;
			} else {
				size_t r = fread(va_arg(ap, char *), 1,
				    width, fp);

				if (r == 0)
					goto input_failure;
				nread += r;
				nassigned++;
			}
			break;

		case CT_CCL:
			/* scan a (nonempty) character class (sets NOSKIP) */
			if (width == 0)
				width = (size_t)~0;	/* `infinity' */
#ifdef SCANF_WIDE_CHAR
			/* take only those things in the class */
			if (flags & LONG) {
				wchar_t twc;
				int nchars;

				if ((flags & SUPPRESS) == 0)
					wcp = va_arg(ap, wchar_t *);
				else
					wcp = &twc;
				n = 0;
				nchars = 0;
				while (width != 0) {
					if (n == MB_CUR_MAX) {
						fp->_flags |= __SERR;
						goto input_failure;
					}
					buf[n++] = *fp->_p;
					fp->_p++;
					fp->_r--;
					bzero(&mbs, sizeof(mbs));
					nconv = mbrtowc(wcp, buf, n, &mbs);
					if (nconv == (size_t)-1) {
						fp->_flags |= __SERR;
						goto input_failure;
					}
					if (nconv == 0)
						*wcp = L'\0';
					if (nconv != (size_t)-2) {
						if (wctob(*wcp) != EOF &&
						    !ccltab[wctob(*wcp)]) {
							while (n != 0) {
								n--;
								ungetc(buf[n],
								    fp);
							}
							break;
						}
						nread += n;
						width--;
						if (!(flags & SUPPRESS))
							wcp++;
						nchars++;
						n = 0;
					}
					if (fp->_r <= 0 && __srefill(fp)) {
						if (n != 0) {
							fp->_flags |= __SERR;
							goto input_failure;
						}
						break;
					}
				}
				if (n != 0) {
					fp->_flags |= __SERR;
					goto input_failure;
				}
				n = nchars;
				if (n == 0)
					goto match_failure;
				if (!(flags & SUPPRESS)) {
					*wcp = L'\0';
					nassigned++;
				}
			} else
#endif /* SCANF_WIDE_CHAR */
			/* take only those things in the class */
			if (flags & SUPPRESS) {
				n = 0;
				while (ccltab[*fp->_p]) {
					n++, fp->_r--, fp->_p++;
					if (--width == 0)
						break;
					if (fp->_r <= 0 && __srefill(fp)) {
						if (n == 0)
							goto input_failure;
						break;
					}
				}
				if (n == 0)
					goto match_failure;
			} else {
				p0 = p = va_arg(ap, char *);
				while (ccltab[*fp->_p]) {
					fp->_r--;
					*p++ = *fp->_p++;
					if (--width == 0)
						break;
					if (fp->_r <= 0 && __srefill(fp)) {
						if (p == p0)
							goto input_failure;
						break;
					}
				}
				n = p - p0;
				if (n == 0)
					goto match_failure;
				*p = '\0';
				nassigned++;
			}
			nread += n;
			break;

		case CT_STRING:
			/* like CCL, but zero-length string OK, & no NOSKIP */
			if (width == 0)
				width = (size_t)~0;
#ifdef SCANF_WIDE_CHAR
			if (flags & LONG) {
				wchar_t twc;

				if ((flags & SUPPRESS) == 0)
					wcp = va_arg(ap, wchar_t *);
				else
					wcp = &twc;
				n = 0;
				while (!isspace(*fp->_p) && width != 0) {
					if (n == MB_CUR_MAX) {
						fp->_flags |= __SERR;
						goto input_failure;
					}
					buf[n++] = *fp->_p;
					fp->_p++;
					fp->_r--;
					bzero(&mbs, sizeof(mbs));
					nconv = mbrtowc(wcp, buf, n, &mbs);
					if (nconv == (size_t)-1) {
						fp->_flags |= __SERR;
						goto input_failure;
					}
					if (nconv == 0)
						*wcp = L'\0';
					if (nconv != (size_t)-2) {
						if (iswspace(*wcp)) {
							while (n != 0) {
								n--;
								ungetc(buf[n],
								    fp);
							}
							break;
						}
						nread += n;
						width--;
						if (!(flags & SUPPRESS))
							wcp++;
						n = 0;
					}
					if (fp->_r <= 0 && __srefill(fp)) {
						if (n != 0) {
							fp->_flags |= __SERR;
							goto input_failure;
						}
						break;
					}
				}
				if (!(flags & SUPPRESS)) {
					*wcp = L'\0';
					nassigned++;
				}
			} else
#endif /* SCANF_WIDE_CHAR */
			if (flags & SUPPRESS) {
				n = 0;
				while (!isspace(*fp->_p)) {
					n++, fp->_r--, fp->_p++;
					if (--width == 0)
						break;
					if (fp->_r <= 0 && __srefill(fp))
						break;
				}
				nread += n;
			} else {
				p0 = p = va_arg(ap, char *);
				while (!isspace(*fp->_p)) {
					fp->_r--;
					*p++ = *fp->_p++;
					if (--width == 0)
						break;
					if (fp->_r <= 0 && __srefill(fp))
						break;
				}
				*p = '\0';
				nread += p - p0;
				nassigned++;
			}
			continue;

		case CT_INT:
			/* scan an integer as if by strtoimax/strtoumax */
#ifdef hardway
			if (width == 0 || width > sizeof(buf) - 1)
				width = sizeof(buf) - 1;
#else
			/* size_t is unsigned, hence this optimisation */
			if (--width > sizeof(buf) - 2)
				width = sizeof(buf) - 2;
			width++;
#endif
			flags |= SIGNOK | NDIGITS | NZDIGITS;
			for (p = buf; width; width--) {
				c = *fp->_p;
				/*
				 * Switch on the character; `goto ok'
				 * if we accept it as a part of number.
				 */
				switch (c) {

				/*
				 * The digit 0 is always legal, but is
				 * special.  For %i conversions, if no
				 * digits (zero or nonzero) have been
				 * scanned (only signs), we will have
				 * base==0.  In that case, we should set
				 * it to 8 and enable 0x prefixing.
				 * Also, if we have not scanned zero digits
				 * before this, do not turn off prefixing
				 * (someone else will turn it off if we
				 * have scanned any nonzero digits).
				 */
				case '0':
					if (base == 0) {
						base = 8;
						flags |= PFXOK;
					}
					if (flags & NZDIGITS)
					    flags &= ~(SIGNOK|NZDIGITS|NDIGITS);
					else
					    flags &= ~(SIGNOK|PFXOK|NDIGITS);
					goto ok;

				/* 1 through 7 always legal */
				case '1': case '2': case '3':
				case '4': case '5': case '6': case '7':
					base = basefix[base];
					flags &= ~(SIGNOK | PFXOK | NDIGITS);
					goto ok;

				/* digits 8 and 9 ok iff decimal or hex */
				case '8': case '9':
					base = basefix[base];
					if (base <= 8)
						break;	/* not legal here */
					flags &= ~(SIGNOK | PFXOK | NDIGITS);
					goto ok;

				/* letters ok iff hex */
				case 'A': case 'B': case 'C':
				case 'D': case 'E': case 'F':
				case 'a': case 'b': case 'c':
				case 'd': case 'e': case 'f':
					/* no need to fix base here */
					if (base <= 10)
						break;	/* not legal here */
					flags &= ~(SIGNOK | PFXOK | NDIGITS);
					goto ok;

				/* sign ok only as first character */
				case '+': case '-':
					if (flags & SIGNOK) {
						flags &= ~SIGNOK;
						flags |= HAVESIGN;
						goto ok;
					}
					break;

				/*
				 * x ok iff flag still set and 2nd char (or
				 * 3rd char if we have a sign).
				 */
				case 'x': case 'X':
					if ((flags & PFXOK) && p ==
					    buf + 1 + !!(flags & HAVESIGN)) {
						base = 16;	/* if %i */
						flags &= ~PFXOK;
						goto ok;
					}
					break;
				}

				/*
				 * If we got here, c is not a legal character
				 * for a number.  Stop accumulating digits.
				 */
				break;
		ok:
				/*
				 * c is legal: store it and look at the next.
				 */
				*p++ = c;
				if (--fp->_r > 0)
					fp->_p++;
				else if (__srefill(fp))
					break;		/* EOF */
			}
			/*
			 * If we had only a sign, it is no good; push
			 * back the sign.  If the number ends in `x',
			 * it was [sign] '0' 'x', so push back the x
			 * and treat it as [sign] '0'.
			 */
			if (flags & NDIGITS) {
				if (p > buf)
					(void) ungetc(*(u_char *)--p, fp);
				goto match_failure;
			}
			c = ((u_char *)p)[-1];
			if (c == 'x' || c == 'X') {
				--p;
				(void) ungetc(c, fp);
			}
			if ((flags & SUPPRESS) == 0) {
				uintmax_t res;

				*p = '\0';
				if (flags & UNSIGNED)
					res = strtoumax(buf, NULL, base);
				else
					res = strtoimax(buf, NULL, base);
				if (flags & POINTER)
					*va_arg(ap, void **) =
					    (void *)(uintptr_t)res;
				else if (flags & MAXINT)
					*va_arg(ap, intmax_t *) = res;
				else if (flags & LLONG)
					*va_arg(ap, long long *) = res;
				else if (flags & SIZEINT)
					*va_arg(ap, ssize_t *) = res;
				else if (flags & PTRINT)
					*va_arg(ap, ptrdiff_t *) = res;
				else if (flags & LONG)
					*va_arg(ap, long *) = res;
				else if (flags & SHORT)
					*va_arg(ap, short *) = res;
				else if (flags & SHORTSHORT)
					*va_arg(ap, signed char *) = res;
				else
					*va_arg(ap, int *) = res;
				nassigned++;
			}
			nread += p - buf;
			break;

#ifdef FLOATING_POINT
		case CT_FLOAT:
			/* scan a floating point number as if by strtod */
#ifdef hardway
			if (width == 0 || width > sizeof(buf) - 1)
				width = sizeof(buf) - 1;
#else
			/* size_t is unsigned, hence this optimisation */
			if (--width > sizeof(buf) - 2)
				width = sizeof(buf) - 2;
			width++;
#endif
			flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
			for (p = buf; width; width--) {
				c = *fp->_p;
				/*
				 * This code mimicks the integer conversion
				 * code, but is much simpler.
				 */
				switch (c) {

				case '0': case '1': case '2': case '3':
				case '4': case '5': case '6': case '7':
				case '8': case '9':
					flags &= ~(SIGNOK | NDIGITS);
					goto fok;

				case '+': case '-':
					if (flags & SIGNOK) {
						flags &= ~SIGNOK;
						goto fok;
					}
					break;
				case '.':
					if (flags & DPTOK) {
						flags &= ~(SIGNOK | DPTOK);
						goto fok;
					}
					break;
				case 'e': case 'E':
					/* no exponent without some digits */
					if ((flags&(NDIGITS|EXPOK)) == EXPOK) {
						flags =
						    (flags & ~(EXPOK|DPTOK)) |
						    SIGNOK | NDIGITS;
						goto fok;
					}
					break;
				}
				break;
		fok:
				*p++ = c;
				if (--fp->_r > 0)
					fp->_p++;
				else if (__srefill(fp))
					break;	/* EOF */
			}
			/*
			 * If no digits, might be missing exponent digits
			 * (just give back the exponent) or might be missing
			 * regular digits, but had sign and/or decimal point.
			 */
			if (flags & NDIGITS) {
				if (flags & EXPOK) {
					/* no digits at all */
					while (p > buf)
						ungetc(*(u_char *)--p, fp);
					goto match_failure;
				}
				/* just a bad exponent (e and maybe sign) */
				c = *(u_char *)--p;
				if (c != 'e' && c != 'E') {
					(void) ungetc(c, fp);/* sign */
					c = *(u_char *)--p;
				}
				(void) ungetc(c, fp);
			}
			if ((flags & SUPPRESS) == 0) {
				*p = '\0';
				if (flags & LONGDBL) {
					long double res = strtold(buf,
					    (char **)NULL);
					*va_arg(ap, long double *) = res;
				} else if (flags & LONG) {
					double res = strtod(buf, (char **)NULL);
					*va_arg(ap, double *) = res;
				} else {
					float res = strtof(buf, (char **)NULL);
					*va_arg(ap, float *) = res;
				}
				nassigned++;
			}
			nread += p - buf;
			break;
#endif /* FLOATING_POINT */
		}
	}
input_failure:
	if (nassigned == 0)
		nassigned = -1;
match_failure:
	return (nassigned);
}

/*
 * Fill in the given table from the scanset at the given format
 * (just after `[').  Return a pointer to the character past the
 * closing `]'.  The table has a 1 wherever characters should be
 * considered part of the scanset.
 */
static u_char *
__sccl(char *tab, u_char *fmt)
{
	int c, n, v;

	/* first `clear' the whole table */
	c = *fmt++;		/* first char hat => negated scanset */
	if (c == '^') {
		v = 1;		/* default => accept */
		c = *fmt++;	/* get new first char */
	} else
		v = 0;		/* default => reject */
	/* should probably use memset here */
	for (n = 0; n < 256; n++)
		tab[n] = v;
	if (c == 0)
		return (fmt - 1);/* format ended before closing ] */

	/*
	 * Now set the entries corresponding to the actual scanset
	 * to the opposite of the above.
	 *
	 * The first character may be ']' (or '-') without being special;
	 * the last character may be '-'.
	 */
	v = 1 - v;
	for (;;) {
		tab[c] = v;		/* take character c */
doswitch:
		n = *fmt++;		/* and examine the next */
		switch (n) {

		case 0:			/* format ended too soon */
			return (fmt - 1);

		case '-':
			/*
			 * A scanset of the form
			 *	[01+-]
			 * is defined as `the digit 0, the digit 1,
			 * the character +, the character -', but
			 * the effect of a scanset such as
			 *	[a-zA-Z0-9]
			 * is implementation defined.  The V7 Unix
			 * scanf treats `a-z' as `the letters a through
			 * z', but treats `a-a' as `the letter a, the
			 * character -, and the letter a'.
			 *
			 * For compatibility, the `-' is not considerd
			 * to define a range if the character following
			 * it is either a close bracket (required by ANSI)
			 * or is not numerically greater than the character
			 * we just stored in the table (c).
			 */
			n = *fmt;
			if (n == ']' || n < c) {
				c = '-';
				break;	/* resume the for(;;) */
			}
			fmt++;
			do {		/* fill in the range */
				tab[++c] = v;
			} while (c < n);
#if 1	/* XXX another disgusting compatibility hack */
			/*
			 * Alas, the V7 Unix scanf also treats formats
			 * such as [a-c-e] as `the letters a through e'.
			 * This too is permitted by the standard....
			 */
			goto doswitch;
#else
			c = *fmt++;
			if (c == 0)
				return (fmt - 1);
			if (c == ']')
				return (fmt);
#endif
			break;

		case ']':		/* end of scanset */
			return (fmt);

		default:		/* just another character */
			c = n;
			break;
		}
	}
	/* NOTREACHED */
}

int
vfscanf(FILE *fp, const char *fmt0, __va_list ap)
{
	int r;

	FLOCKFILE(fp);
	r = __svfscanf(fp, fmt0, ap);
	FUNLOCKFILE(fp);
	return (r);
}
DEF_STRONG(vfscanf);
@


1.33
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.32 2015/08/31 02:53:57 guenther Exp $ */
d45 1
@


1.32
log
@Add framework for resolving (pun intended) libc namespace issues, using
wrapper .h files and asm labels to let internal calls resolve directly and
not be overridable or use the PLT.  Then, apply that framework to most of
the functions in stdio.h, string.h, err.h, and wchar.h.  Delete the
should-have-been-hidden-all-along _v?(err|warn)[cx]? symbols while here.

tests clean on i386, amd64, sparc64, powerpc, and mips64

naming feedback from kettenis@@ and millert@@
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.31 2014/03/19 05:17:01 guenther Exp $ */
d404 1
a404 1
				size_t r = fread((void *)va_arg(ap, char *), 1,
@


1.31
log
@It's still safe to assumed 'signed' exists
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.30 2013/04/17 17:40:35 tedu Exp $ */
d970 1
@


1.30
log
@add some prototypes, casts, includes, parenthesis, and whatnot to
silence some warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.29 2012/01/18 14:01:38 stsp Exp $ */
d276 1
a276 1
				*va_arg(ap, __signed char *) = nread;
d752 1
a752 1
					*va_arg(ap, __signed char *) = res;
@


1.29
log
@Add support for C99 %ls, %lc, and %l[ format directives to scanf(3).
Based on code from FreeBSD.
Tested by myself (full release/install cycle on i386 and sparc64) and ajacoutot.
Man page help from jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.28 2011/11/08 18:30:42 guenther Exp $ */
d35 1
@


1.28
log
@Make __svfscanf() the unlocked, core of vfscanf() and use it in
sscanf()/vsscanf() where locking is unnecessary.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.27 2011/07/03 17:57:47 martynas Exp $ */
d40 1
d112 5
d340 42
d417 66
d524 54
@


1.27
log
@Recognize %a, %A format specifiers, per C99.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.26 2011/07/03 05:16:59 martynas Exp $ */
a92 4
#if !defined(VFSCANF)
#define VFSCANF	vfscanf
#endif

d94 1
a94 1
 * vfscanf
d97 1
a97 1
VFSCANF(FILE *fp, const char *fmt0, __va_list ap)
a115 1
	FLOCKFILE(fp);
d123 1
a123 2
		if (c == 0) {
			FUNLOCKFILE(fp);
a124 1
		}
a289 1
			FUNLOCKFILE(fp);
a691 1
	FUNLOCKFILE(fp);
d789 11
@


1.26
log
@Properly implement the long double (%Lf) scanf without the precision
loss.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.25 2009/11/09 00:18:27 kurt Exp $ */
d242 4
a245 6
		case 'E':
		case 'G':
		case 'e': 
		case 'f': 
		case 'F': 
		case 'g':
@


1.25
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

committing on behalf of and okay guenther@@ now that we have install
media space available.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.24 2009/10/22 01:23:16 guenther Exp $ */
d52 1
a52 1
#define	LONGDBL		0x00002	/* L: long double; unimplemented */
a678 2
				double res;

d680 3
a682 2
				res = strtod(buf, (char **) NULL);
				if (flags & LONGDBL)
d684 2
a685 1
				else if (flags & LONG)
d687 2
a688 1
				else
d690 1
@


1.24
log
@Back out previous commit, as it caused too much growth for the install
media to fit
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.23 2009/10/21 16:04:23 guenther Exp $ */
d120 1
d128 2
a129 1
		if (c == 0)
d131 1
d299 1
d697 2
a698 1
	return (nassigned ? nassigned : -1);
d700 1
@


1.23
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

ok kurt@@, earlier version tested by sthen@@ and jj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.22 2009/04/05 19:29:28 martynas Exp $ */
a119 1
	FLOCKFILE(fp);
d127 1
a127 2
		if (c == 0) {
			FUNLOCKFILE(fp);
a128 1
		}
a295 1
			FUNLOCKFILE(fp);
d693 1
a693 2
	if (nassigned == 0)
		nassigned = -1;
a694 1
	FUNLOCKFILE(fp);
@


1.22
log
@accept %F, which actually behaves the same as %f.  per C99
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.21 2006/01/13 21:33:28 millert Exp $ */
d120 1
d128 2
a129 1
		if (c == 0)
d131 1
d299 1
d697 2
a698 1
	return (nassigned ? nassigned : -1);
d700 1
@


1.21
log
@Pull in inttypes.h, not stdint.h so we get the prototypes for
strtoimax/strtoumax.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.20 2006/01/13 17:56:18 millert Exp $ */
d243 1
@


1.20
log
@Use long long and intmax_t instead of quad_t throughout.  Adapted in
part from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.19 2006/01/08 02:13:28 millert Exp $ */
d34 3
a37 1
#include <stdint.h>
a39 2
#include <ctype.h>
#include <stdarg.h>
@


1.19
log
@Fix the handling of negative hexadecimal numbers in integer formats.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.18 2006/01/06 18:53:04 millert Exp $ */
d34 2
d51 12
a62 9
#define	LONG		0x0001	/* l: long or double */
#define	LONGDBL		0x0002	/* L: long double; unimplemented */
#define	SHORT		0x0004	/* h: short */
#define QUAD		0x0008	/* q: quad */
#define	SUPPRESS	0x0010	/* suppress assignment */
#define	POINTER		0x0020	/* weird %p pointer (`fake hex') */
#define	NOSKIP		0x0040	/* do not skip blanks */
#define	SHORTSHORT	0x0080	/* hh: 8 bit integer */
#define	SIZEINT		0x0100	/* z: (signed) size_t */
d69 3
a71 3
#define	SIGNOK		0x0200	/* +/- is (still) legal */
#define	HAVESIGN	0x0400	/* sign detected */
#define	NDIGITS		0x0800	/* no digits detected */
d73 2
a74 2
#define	DPTOK		0x1000	/* (float) decimal point is still legal */
#define	EXPOK		0x2000	/* (float) exponent (e+3, etc) still legal */
d76 2
a77 2
#define	PFXOK		0x1000	/* 0x prefix is (still) legal */
#define	NZDIGITS	0x2000	/* no zero digits detected */
d85 1
a85 1
#define	CT_INT		3	/* integer, i.e., strtoq or strtouq */
d112 1
a112 2
	int base;		/* base argument to strtoq/strtouq */
	u_quad_t (*ccfn)();	/* conversion function (strtoq/strtouq) */
a124 1
	ccfn = NULL;		/* XXX just to keep gcc happy */
d158 3
d175 1
a175 1
				flags |= QUAD;
d181 4
a184 1
			flags |= QUAD;
a206 1
			ccfn = (u_quad_t (*)())strtoq;
a211 1
			ccfn = (u_quad_t (*)())strtoq;
d220 1
a220 1
			ccfn = strtouq;
d226 1
a226 1
			ccfn = strtouq;
d234 1
a234 1
			ccfn = strtouq;
d266 1
a266 1
			ccfn = strtouq;
d271 1
a271 1
			if (flags & SUPPRESS)	/* ??? */
a278 2
			else if (flags & QUAD)
				*va_arg(ap, quad_t *) = nread;
d281 6
a300 1
			ccfn = (u_quad_t (*)())strtoq;
d442 1
a442 1
			/* scan an integer as if by strtoq/strtouq */
d524 1
a524 1
					if (flags & PFXOK && p ==
d565 1
a565 1
				u_quad_t res;
d568 4
a571 1
				res = (*ccfn)(buf, (char **)NULL, base);
d574 5
a578 1
					    (void *)(long)res;
d581 2
a582 2
				else if (flags & QUAD)
					*va_arg(ap, quad_t *) = res;
@


1.18
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.17 2006/01/03 00:57:45 millert Exp $ */
d61 2
a62 2
 * SIGNOK, NDIGITS, DPTOK, and EXPOK are for floating point;
 * SIGNOK, NDIGITS, PFXOK, and NZDIGITS are for integral.
d65 2
a66 1
#define	NDIGITS		0x0400	/* no digits detected */
d68 2
a69 2
#define	DPTOK		0x0800	/* (float) decimal point is still legal */
#define	EXPOK		0x1000	/* (float) exponent (e+3, etc) still legal */
d71 2
a72 2
#define	PFXOK		0x0800	/* 0x prefix is (still) legal */
#define	NZDIGITS	0x1000	/* no zero digits detected */
d504 1
d509 4
a512 1
				/* x ok iff flag still set & 2nd char */
d514 2
a515 1
					if (flags & PFXOK && p == buf + 1) {
@


1.17
log
@Do not overlap flags; problem introduced when new escapes were added.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.16 2005/12/19 19:39:25 millert Exp $ */
d95 1
a95 1
VFSCANF(FILE *fp, const char *fmt0, _BSD_VA_LIST_ ap)
@


1.16
log
@Add %hhd to *printf and *scanf as well as %z to *scanf.  This was
sent out and approved about 6 months ago and has been rotting in
my tree ever since.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfscanf.c,v 1.15 2005/08/08 08:05:36 espie Exp $ */
d64 2
a65 2
#define	SIGNOK		0x080	/* +/- is (still) legal */
#define	NDIGITS		0x100	/* no digits detected */
d67 2
a68 2
#define	DPTOK		0x200	/* (float) decimal point is still legal */
#define	EXPOK		0x400	/* (float) exponent (e+3, etc) still legal */
d70 2
a71 2
#define	PFXOK		0x200	/* 0x prefix is (still) legal */
#define	NZDIGITS	0x400	/* no zero digits detected */
@


1.15
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d49 9
a57 7
#define	LONG		0x01	/* l: long or double */
#define	LONGDBL		0x02	/* L: long double; unimplemented */
#define	SHORT		0x04	/* h: short */
#define QUAD		0x08	/* q: quad */
#define	SUPPRESS	0x10	/* suppress assignment */
#define	POINTER		0x20	/* weird %p pointer (`fake hex') */
#define	NOSKIP		0x40	/* do not skip blanks */
d158 6
a163 1
			flags |= SHORT;
d176 3
d265 3
a267 1
			if (flags & SHORT)
d271 4
d556 2
d564 2
@


1.14
log
@
next citrus step.

reviewed by millert, otto, kevlo, naddy, kettenis...
libc+libstdc++ bump
@
text
@d1 1
a32 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.13 2005/05/28 04:34:05 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.13
log
@Use '\0' not 0 when storing as a char, part from Andrey Matveev.
@
text
@d34 1
a34 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.12 2005/05/11 18:39:19 espie Exp $";
d115 2
@


1.12
log
@let vfscanf be a real function. Use a weak_alias on systems where this
is feasible.

Okay millert@@

There's a major libc bump coming that is going to cover this as well...
@
text
@d34 1
a34 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.11 2005/03/31 18:36:29 pat Exp $";
d379 1
a379 1
				*p = 0;
d409 1
a409 1
				*p = 0;
d536 1
a536 1
				*p = 0;
d634 1
a634 1
				*p = 0;
@


1.11
log
@make sure the implementation matches the prototype..
char const * -> const char *

ok otto@@ deraadt@@
@
text
@d34 1
a34 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.10 2004/09/28 18:12:44 otto Exp $";
d88 4
d96 1
a96 1
__svfscanf(FILE *fp, const char *fmt0, _BSD_VA_LIST_ ap)
@


1.10
log
@deregister + ansify, no change in object code. ok deraadt@@ millert@@
@
text
@d34 1
a34 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.9 2003/06/02 20:18:37 millert Exp $";
d92 1
a92 1
__svfscanf(FILE *fp, char const *fmt0, _BSD_VA_LIST_ ap)
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d34 1
a34 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.8 2002/02/19 19:39:37 millert Exp $";
d86 1
a86 1
static u_char *__sccl();
d92 1
a92 4
__svfscanf(fp, fmt0, ap)
	register FILE *fp;
	char const *fmt0;
	_BSD_VA_LIST_ ap;
d94 7
a100 7
	register u_char *fmt = (u_char *)fmt0;
	register int c;		/* character from format, or conversion */
	register size_t width;	/* field width, or 0 */
	register char *p;	/* points into all kinds of strings */
	register int n;		/* handy integer */
	register int flags;	/* flags as defined above */
	register char *p0;	/* saves original value of p when necessary */
d658 1
a658 3
__sccl(tab, fmt)
	register char *tab;
	register u_char *fmt;
d660 1
a660 1
	register int c, n, v;
@


1.8
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.7 2001/07/09 06:57:45 deraadt Exp $";
@


1.7
log
@a first pass at -Wall
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.6 1998/01/20 21:25:39 millert Exp $";
a43 1
#ifdef __STDC__
a44 3
#else
#include <varargs.h>
#endif
@


1.6
log
@Better fix for %n and whitespace.  Chris Torek <torek@@bsdi.com>
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.4 1997/07/25 20:30:13 mickey Exp $";
d99 1
@


1.5
log
@Ignore whitespace separating a conversion and %n.  There may be
a cleaner way to do this.
@
text
@d131 2
a132 10
			for (;;) {
				if (fp->_r <= 0 && __srefill(fp)) {
					while (isspace(*fmt))
						fmt++;
					if (*fmt == '%' && *(fmt + 1) == 'n')
						break;
					return (nassigned);
				}
				if (!isspace(*fp->_p))
					break;
a133 1
			}
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.3 1996/09/15 09:31:46 tholo Exp $";
d132 5
a136 1
				if (fp->_r <= 0 && __srefill(fp))
d138 1
@


1.3
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.2 1996/08/19 08:33:12 tholo Exp $";
d44 1
a44 1
#if __STDC__
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: vfscanf.c,v 1.14 1995/03/22 00:57:02 jtc Exp $";
d357 1
a357 1
				width = ~0;	/* `infinity' */
d398 1
a398 1
				width = ~0;
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: vfscanf.c,v 1.14 1995/03/22 00:57:02 jtc Exp $	*/

d38 1
a38 4
#if 0
static char sccsid[] = "@@(#)vfscanf.c	8.1 (Berkeley) 6/4/93";
#endif
static char rcsid[] = "$NetBSD: vfscanf.c,v 1.14 1995/03/22 00:57:02 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
