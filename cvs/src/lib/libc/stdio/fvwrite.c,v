head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.17.0.28
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.24
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.26
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.18
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.22
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.20
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.16
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.14.0.20
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.16
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.14
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.12
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.8
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.6
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9:1.10.0.8
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2017.03.17.16.06.33;	author millert;	state Exp;
branches;
next	1.19;
commitid	ng2t0zbpK6CZFuvH;

1.19
date	2017.03.16.14.26.18;	author millert;	state Exp;
branches;
next	1.18;
commitid	c5BRdMsPYCVyObT5;

1.18
date	2016.09.21.04.38.56;	author guenther;	state Exp;
branches;
next	1.17;
commitid	pqjnYVtACzQ9ctai;

1.17
date	2009.11.09.00.18.27;	author kurt;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.22.01.23.16;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.21.16.04.23;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.08.08.05.36;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.28.18.12.44;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.18.37;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.09.06.57.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.08.07.17.42.48;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.08.07.17.35.58;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.11.20.06.13.26;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.08.14.21.39.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.11.30.01.13.24;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.11.29.19.54.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.10.26.08.16.07;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.10.26.06.58.58;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.32.49;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.13;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Use recallocarray() to avoid leaving detritus in memory when resizing
the string buffer used by asprintf() and vasprintf().  OK deraadt@@
@
text
@/*	$OpenBSD: fvwrite.c,v 1.19 2017/03/16 14:26:18 millert Exp $ */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include "local.h"
#include "fvwrite.h"

/*
 * Write some memory regions.  Return zero on success, EOF on error.
 *
 * This routine is large and unsightly, but most of the ugliness due
 * to the three different kinds of output buffering is handled here.
 */
int
__sfvwrite(FILE *fp, struct __suio *uio)
{
	size_t len;
	char *p;
	struct __siov *iov;
	int w, s;
	char *nl;
	int nlknown, nldist;

	if ((len = uio->uio_resid) == 0)
		return (0);
	/* make sure we can write */
	if (cantwrite(fp)) {
		errno = EBADF;
		return (EOF);
	}

#define	MIN(a, b) ((a) < (b) ? (a) : (b))
#define	COPY(n)	  (void)memcpy(fp->_p, p, n)

	iov = uio->uio_iov;
	p = iov->iov_base;
	len = iov->iov_len;
	iov++;
#define GETIOV(extra_work) \
	while (len == 0) { \
		extra_work; \
		p = iov->iov_base; \
		len = iov->iov_len; \
		iov++; \
	}
	if (fp->_flags & __SNBF) {
		/*
		 * Unbuffered: write up to BUFSIZ bytes at a time.
		 */
		do {
			GETIOV(;);
			w = (*fp->_write)(fp->_cookie, p, MIN(len, BUFSIZ));
			if (w <= 0)
				goto err;
			p += w;
			len -= w;
		} while ((uio->uio_resid -= w) != 0);
	} else if ((fp->_flags & __SLBF) == 0) {
		/*
		 * Fully buffered: fill partially full buffer, if any,
		 * and then flush.  If there is no partial buffer, write
		 * one _bf._size byte chunk directly (without copying).
		 *
		 * String output is a special case: write as many bytes
		 * as fit, but pretend we wrote everything.  This makes
		 * snprintf() return the number of bytes needed, rather
		 * than the number used, and avoids its write function
		 * (so that the write function can be invalid).
		 */
		do {
			GETIOV(;);
			if ((fp->_flags & (__SALC | __SSTR)) ==
			    (__SALC | __SSTR) && fp->_w < len) {
				size_t blen = fp->_p - fp->_bf._base;
				int pgmsk = getpagesize() - 1;
				unsigned char *_base;
				int _size;

				/* Round up to nearest page. */
				_size = ((blen + len + 1 + pgmsk) & ~pgmsk) - 1;
				_base = recallocarray(fp->_bf._base,
				    fp->_bf._size + 1, _size + 1, 1);
				if (_base == NULL)
					goto err;
				fp->_w += _size - fp->_bf._size;
				fp->_bf._base = _base;
				fp->_bf._size = _size;
				fp->_p = _base + blen;
			}
			w = fp->_w;
			if (fp->_flags & __SSTR) {
				if (len < w)
					w = len;
				COPY(w);	/* copy MIN(fp->_w,len), */
				fp->_w -= w;
				fp->_p += w;
				w = len;	/* but pretend copied all */
			} else if (fp->_p > fp->_bf._base && len > w) {
				/* fill and flush */
				COPY(w);
				/* fp->_w -= w; */ /* unneeded */
				fp->_p += w;
				if (__sflush(fp))
					goto err;
			} else if (len >= (w = fp->_bf._size)) {
				/* write directly */
				w = (*fp->_write)(fp->_cookie, p, w);
				if (w <= 0)
					goto err;
			} else {
				/* fill and done */
				w = len;
				COPY(w);
				fp->_w -= w;
				fp->_p += w;
			}
			p += w;
			len -= w;
		} while ((uio->uio_resid -= w) != 0);
	} else {
		/*
		 * Line buffered: like fully buffered, but we
		 * must check for newlines.  Compute the distance
		 * to the first newline (including the newline),
		 * or `infinity' if there is none, then pretend
		 * that the amount to write is MIN(len,nldist).
		 */
		nlknown = 0;
		nldist = 0;	/* XXX just to keep gcc happy */
		do {
			GETIOV(nlknown = 0);
			if (!nlknown) {
				nl = memchr(p, '\n', len);
				nldist = nl ? nl + 1 - p : len + 1;
				nlknown = 1;
			}
			s = MIN(len, nldist);
			w = fp->_w + fp->_bf._size;
			if (fp->_p > fp->_bf._base && s > w) {
				COPY(w);
				/* fp->_w -= w; */
				fp->_p += w;
				if (__sflush(fp))
					goto err;
			} else if (s >= (w = fp->_bf._size)) {
				w = (*fp->_write)(fp->_cookie, p, w);
				if (w <= 0)
				 	goto err;
			} else {
				w = s;
				COPY(w);
				fp->_w -= w;
				fp->_p += w;
			}
			if ((nldist -= w) == 0) {
				/* copied the newline: flush and forget */
				if (__sflush(fp))
					goto err;
				nlknown = 0;
			}
			p += w;
			len -= w;
		} while ((uio->uio_resid -= w) != 0);
	}
	return (0);

err:
	fp->_flags |= __SERR;
	return (EOF);
}
@


1.19
log
@When reallocating the buffer for asprintf(), just round up to the
nearest page instead of doubling the old size until it is large
enough.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fvwrite.c,v 1.18 2016/09/21 04:38:56 guenther Exp $ */
d115 2
a116 1
				_base = realloc(fp->_bf._base, _size + 1);
@


1.18
log
@Delete casts to off_t and size_t that are implied by assignments
or prototypes.  Ditto for some of the char* and void* casts too.

verified no change to instructions on ILP32 (i386) and LP64 (amd64)
ok natano@@ abluhm@@ deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fvwrite.c,v 1.17 2009/11/09 00:18:27 kurt Exp $ */
d38 1
d109 1
d113 2
a114 5
				/* Allocate space exponentially. */
				_size = fp->_bf._size;
				do {
					_size = (_size << 1) + 1;
				} while (_size < blen + len);
@


1.17
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

committing on behalf of and okay guenther@@ now that we have install
media space available.
@
text
@d1 1
a1 1
/*	$OpenBSD: fvwrite.c,v 1.16 2009/10/22 01:23:16 guenther Exp $ */
d66 1
a66 1
#define	COPY(n)	  (void)memcpy((void *)fp->_p, (void *)p, (size_t)(n))
d167 1
a167 1
				nl = memchr((void *)p, '\n', len);
@


1.16
log
@Back out previous commit, as it caused too much growth for the install
media to fit
@
text
@d1 1
a1 1
/*	$OpenBSD: fvwrite.c,v 1.15 2009/10/21 16:04:23 guenther Exp $ */
d137 1
a137 1
				if (fflush(fp))
d177 1
a177 1
				if (fflush(fp))
d191 1
a191 1
				if (fflush(fp))
@


1.15
log
@Fix the handle locking in stdio to use flockfile/funlockfile
internally when and where required.  Macros in <stdio.h> are updated
to automatically call the underlying functions when the process is
threaded to obtain the necessary locking.  A private mutex is added
to protect __sglue, the internal list of FILE handles, and another
to protect the one-time initialization.  Some routines in libc that
use getc() change to use getc_unlocked() as they're either protected
by their own lock or aren't thread-safe routines anyway.

ok kurt@@, earlier version tested by sthen@@ and jj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fvwrite.c,v 1.14 2005/08/08 08:05:36 espie Exp $ */
d137 1
a137 1
				if (__sflush(fp))
d177 1
a177 1
				if (__sflush(fp))
d191 1
a191 1
				if (__sflush(fp))
@


1.14
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d137 1
a137 1
				if (fflush(fp))
d177 1
a177 1
				if (fflush(fp))
d191 1
a191 1
				if (fflush(fp))
@


1.13
log
@deregister + ansify, no change in object code. ok deraadt@@ millert@@
@
text
@d1 1
a32 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.12 2003/06/02 20:18:37 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d34 1
a34 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.11 2001/07/09 06:57:44 deraadt Exp $";
d51 1
a51 3
__sfvwrite(fp, uio)
	register FILE *fp;
	register struct __suio *uio;
d53 4
a56 4
	register size_t len;
	register char *p;
	register struct __siov *iov;
	register int w, s;
@


1.11
log
@a first pass at -Wall
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.10 1999/08/07 17:42:48 millert Exp $";
@


1.10
log
@Local changes that should not have gone in
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.8 1998/11/20 06:13:26 millert Exp $";
d54 1
@


1.9
log
@If fread() returns EBADF, also set the error flag; tobez@@plab.ku.dk
@
text
@d114 1
a114 3
			    (__SALC | __SSTR) && fp->_w < len &&
			    ((fp->_flags & __SAMX) == 0 || fp->_bf._size
			    <= fp->_blksize)) {
a123 3
				/* Apply maximum if v?asnprintf */
				if ((fp->_flags & __SAMX))
					_size = MIN(_size, fp->_blksize);
@


1.8
log
@Allocate space exponentially, not linearly for v?asprintf; mycroft@@netbsd.org
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.7 1998/08/14 21:39:40 deraadt Exp $";
d114 3
a116 1
			    (__SALC | __SSTR) && fp->_w < len) {
d126 3
@


1.7
log
@realloc repair
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.6 1997/11/30 01:13:24 millert Exp $";
d117 1
d119 6
a124 7
				/*
				 * Alloc an extra 128 bytes (+ 1 for NULL)
				 * so we don't call realloc(3) so often.
				 */
				fp->_w = len + 128;
				fp->_bf._size = blen + len + 128;
				_base = realloc(fp->_bf._base, fp->_bf._size + 1);
d127 1
d129 2
a130 1
				fp->_p = fp->_bf._base + blen;
@


1.6
log
@Deal with realloc() failure in v?asprintf()
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.5 1997/11/29 19:54:48 millert Exp $";
d116 1
d124 2
a125 3
				fp->_bf._base =
				    realloc(fp->_bf._base, fp->_bf._size + 1);
				if (fp->_bf._base == NULL)
d127 1
@


1.5
log
@Implement asprintf(3) and vasprintf(3) functions similar to the
ones in the glibc.  Some man pages changes from FreeBSD
(asprintf.c/vasprintf.c are not based on GNU or FreeBSD code).
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.4 1996/10/26 08:16:07 tholo Exp $";
a122 1
				/* XXX - check return val */
d125 2
@


1.4
log
@Need <errno.h>
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.3 1996/10/26 06:58:58 tholo Exp $";
d42 1
d113 15
@


1.3
log
@Set errno when trying to write to a read-only stream
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.2 1996/08/19 08:32:49 tholo Exp $";
d43 1
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: fvwrite.c,v 1.4 1995/02/02 02:09:45 jtc Exp $";
d66 2
a67 1
	if (cantwrite(fp))
d69 1
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: fvwrite.c,v 1.4 1995/02/02 02:09:45 jtc Exp $	*/

d38 1
a38 4
#if 0
static char sccsid[] = "@@(#)fvwrite.c	8.1 (Berkeley) 6/4/93";
#endif
static char rcsid[] = "$NetBSD: fvwrite.c,v 1.4 1995/02/02 02:09:45 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
