head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.24
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.20
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.22
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.14
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.18
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.16
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.12
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.26
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.22
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.20
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.18
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.16
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.14
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.12
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.8.0.22
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.20
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.18
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.16
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.8.0.14
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_8:1.8.0.12
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.10
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.8
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.14
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.30;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.01.17.12.32.11;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.10.07.51.03;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.26.23.19.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.19.10.10.10;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	98.02.11.04.40.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.02.11.04.32.28;	author gene;	state Exp;
branches;
next	1.6;

1.6
date	97.08.19.07.54.49;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.08.01.19.29.44;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.22.08.39.59;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.09.22.08.13.43;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.09.22.07.59.07;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@/*	$OpenBSD: rnusers.x,v 1.13 2009/10/27 23:59:30 deraadt Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Find out about remote users
 */

#ifndef RPC_HDR
#endif


#ifdef RPC_HDR
%/*
% * The following structures are used by version 2 of the rusersd protocol.
% * They were not developed with rpcgen, so they do not appear as RPCL.
% */
%
%#define	RUSERSVERS_ORIG 1	/* original version */
%#define	RUSERSVERS_IDLE 2
%#define	MAXUSERS 100
%
%/*
% * This is the structure used in version 2 of the rusersd RPC service.
% * It corresponds to the utmp structure for BSD sytems.
% */
%
%#define RNUSERS_MAXUSERLEN 8
%#define RNUSERS_MAXLINELEN 8
%#define RNUSERS_MAXHOSTLEN 16
%
%struct ru_utmp {
%	char	*ut_line;		/* tty name */
%	char	*ut_name;		/* user id */
%	char	*ut_host;		/* host name, if remote */
%	int	ut_time;		/* time on */
%};
%typedef struct ru_utmp rutmp;
%
%struct utmparr {
%	struct ru_utmp **uta_arr;
%	int uta_cnt;
%};
%typedef struct utmparr utmparr;
%int	xdr_utmparr(XDR *, struct utmparr *);
%
%struct utmpidle {
%	struct ru_utmp ui_utmp;
%	unsigned ui_idle;
%};
%
%struct utmpidlearr {
%	struct utmpidle **uia_arr;
%	int uia_cnt;
%};
%typedef struct utmpidlearr utmpidlearr;
%int xdr_utmpidlearr(XDR *, struct utmpidlearr *);
%
%#define RUSERSVERS_1 ((u_long)1)
%#define RUSERSVERS_2 ((u_long)2)
%#ifndef RUSERSPROG
%#define RUSERSPROG ((u_long)100002)
%#endif
%#ifndef RUSERSPROC_NUM
%#define RUSERSPROC_NUM ((u_long)1)
%#endif
%#ifndef RUSERSPROC_NAMES
%#define RUSERSPROC_NAMES ((u_long)2)
%#endif
%#ifndef RUSERSPROC_ALLNAMES
%#define RUSERSPROC_ALLNAMES ((u_long)3)
%#endif
%
#endif	/* RPC_HDR */

#ifdef	RPC_XDR
%bool_t	xdr_utmp(XDR *, struct ru_utmp *);
%bool_t	xdr_utmpptr(XDR *, struct ru_utmp **);
%bool_t	xdr_utmparr(XDR *, struct utmparr *);
%bool_t	xdr_utmpidle(XDR *, struct utmpidle *);
%bool_t	xdr_utmpidleptr(XDR *, struct utmpidle **);
%
%bool_t
%xdr_utmp(XDR *xdrs, struct ru_utmp *objp)
%{
%	int size;
%
%	size = RNUSERS_MAXLINELEN;
%	if (!xdr_bytes(xdrs, &objp->ut_line, &size, RNUSERS_MAXLINELEN))
%		return (FALSE);
%	size = RNUSERS_MAXUSERLEN;
%	if (!xdr_bytes(xdrs, &objp->ut_name, &size, RNUSERS_MAXUSERLEN))
%		return (FALSE);
%	size = RNUSERS_MAXHOSTLEN;
%	if (!xdr_bytes(xdrs, &objp->ut_host, &size, RNUSERS_MAXHOSTLEN))
%		return (FALSE);
%	if (!xdr_int(xdrs, &objp->ut_time))
%		return (FALSE);
%	return (TRUE);
%}
%
%bool_t
%xdr_utmpptr(XDR *xdrs, struct ru_utmp **objpp)
%{
%	if (!xdr_reference(xdrs, (char **) objpp, sizeof (struct ru_utmp),
%	    xdr_utmp))
%		return (FALSE);
%	return (TRUE);
%}
%
%bool_t
%xdr_utmparr(XDR *xdrs, struct utmparr *objp)
%{
%	if (!xdr_array(xdrs, (char **)&objp->uta_arr, (u_int *)&objp->uta_cnt,
%	    MAXUSERS, sizeof(struct ru_utmp *), xdr_utmpptr))
%		return (FALSE);
%	return (TRUE);
%}
%
%bool_t
%xdr_utmpidle(XDR *xdrs, struct utmpidle *objp)
%{
%	if (!xdr_utmp(xdrs, &objp->ui_utmp))
%		return (FALSE);
%	if (!xdr_u_int(xdrs, &objp->ui_idle))
%		return (FALSE);
%	return (TRUE);
%}
%
%bool_t
%xdr_utmpidleptr(XDR *xdrs, struct utmpidle **objpp)
%{
%	if (!xdr_reference(xdrs, (char **) objpp, sizeof (struct utmpidle),
%	    xdr_utmpidle))
%		return (FALSE);
%	return (TRUE);
%}
%
%bool_t
%xdr_utmpidlearr(XDR *xdrs, struct utmpidlearr *objp)
%{
%	if (!xdr_array(xdrs, (char **)&objp->uia_arr, (u_int *)&objp->uia_cnt,
%	    MAXUSERS, sizeof(struct utmpidle *), xdr_utmpidleptr))
%		return (FALSE);
%	return (TRUE);
%}
#endif
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rnusers.x,v 1.12 2004/01/17 12:32:11 deraadt Exp $	*/
d4 1
a4 6
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
d6 3
a8 3
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
d10 9
a18 3
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d20 12
a31 11
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
@


1.12
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: rnusers.x,v 1.11 2003/07/10 07:51:03 deraadt Exp $	*/
a36 5
%#ifndef lint
%/*static char sccsid[] = "from: @@(#)rnusers.x 1.2 87/09/20 Copyr 1987 Sun Micro";*/
%/*static char sccsid[] = "from: @@(#)rnusers.x	2.1 88/08/01 4.0 RPCSRC";*/
%static char rcsid[] = "$OpenBSD: rnusers.x,v 1.11 2003/07/10 07:51:03 deraadt Exp $";
%#endif /* not lint */
@


1.11
log
@5 missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rnusers.x,v 1.10 2003/06/26 23:19:53 deraadt Exp $	*/
d10 1
a10 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
 * 
d22 1
a22 1
 * 
d26 1
a26 1
 * 
d40 1
a40 1
%static char rcsid[] = "$OpenBSD: rnusers.x,v 1.10 2003/06/26 23:19:53 deraadt Exp $";
d51 1
a51 1
%#define 	RUSERSVERS_ORIG 1	/* original version */
@


1.10
log
@simple protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rnusers.x,v 1.9 2003/06/19 10:10:10 deraadt Exp $	*/
d40 1
a40 1
%static char rcsid[] = "$OpenBSD: rnusers.x,v 1.9 2003/06/19 10:10:10 deraadt Exp $";
d77 1
a77 1
%int xdr_utmparr(XDR *, struct utmparr *);
d109 6
@


1.9
log
@ansi and knf inside
@
text
@d1 1
a1 1
/*	$OpenBSD: rnusers.x,v 1.8 1998/02/11 04:40:40 deraadt Exp $	*/
d40 1
a40 1
%static char rcsid[] = "$OpenBSD: rnusers.x,v 1.8 1998/02/11 04:40:40 deraadt Exp $";
d77 1
a77 1
%int xdr_utmparr();
d89 1
a89 1
%int xdr_utmpidlearr();
@


1.8
log
@revert. Changes completely break on the alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: rnusers.x,v 1.6 1997/08/19 07:54:49 niklas Exp $	*/
d40 1
a40 1
%static char rcsid[] = "$OpenBSD: rnusers.x,v 1.6 1997/08/19 07:54:49 niklas Exp $";
d110 1
a110 3
%xdr_utmp(xdrs, objp)
%	XDR *xdrs;
%	struct ru_utmp *objp;
d115 1
a115 1
%	if (!xdr_bytes(xdrs, &objp->ut_line, &size, RNUSERS_MAXLINELEN)) {
a116 1
%	}
d118 1
a118 1
%	if (!xdr_bytes(xdrs, &objp->ut_name, &size, RNUSERS_MAXUSERLEN)) {
a119 1
%	}
d121 1
a121 1
%	if (!xdr_bytes(xdrs, &objp->ut_host, &size, RNUSERS_MAXHOSTLEN)) {
d123 1
a123 2
%	}
%	if (!xdr_int(xdrs, &objp->ut_time)) {
a124 1
%	}
d129 1
a129 3
%xdr_utmpptr(xdrs, objpp)
%	XDR *xdrs;
%	struct ru_utmp **objpp;
d131 2
a132 2
%	if (!xdr_reference(xdrs, (char **) objpp, sizeof (struct ru_utmp), 
%			   xdr_utmp)) {
a133 1
%	}
d138 1
a138 3
%xdr_utmparr(xdrs, objp)
%	XDR *xdrs;
%	struct utmparr *objp;
d141 1
a141 1
%		       MAXUSERS, sizeof(struct ru_utmp *), xdr_utmpptr)) {
a142 1
%	}
d147 1
a147 3
%xdr_utmpidle(xdrs, objp)
%	XDR *xdrs;
%	struct utmpidle *objp;
d149 1
a149 1
%	if (!xdr_utmp(xdrs, &objp->ui_utmp)) {
d151 1
a151 2
%	}
%	if (!xdr_u_int(xdrs, &objp->ui_idle)) {
a152 1
%	}
d157 1
a157 3
%xdr_utmpidleptr(xdrs, objpp)
%	XDR *xdrs;
%	struct utmpidle **objpp;
d159 2
a160 2
%	if (!xdr_reference(xdrs, (char **) objpp, sizeof (struct utmpidle), 
%			   xdr_utmpidle)) {
a161 1
%	}
d166 1
a166 3
%xdr_utmpidlearr(xdrs, objp)
%	XDR *xdrs;
%	struct utmpidlearr *objp;
d169 1
a169 1
%		       MAXUSERS, sizeof(struct utmpidle *), xdr_utmpidleptr)) {
a170 1
%	}
@


1.7
log
@Based on a combination of work from FreeBSD and NetBSD with some tweaks from
me: this fixes lots of casting issues and does a good cleanup.  It kills the
bugs found in our 'rusers' binary which didn't grok some servers correctly
due to problems in our xdr.
Thanks to an extensive debug session with A. Emory Lundberg (emory@@hellyeah.com)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 1
%#include <sys/cdefs.h>
d40 1
a40 1
% static char rcsid[] = "$OpenBSD$";
d59 5
d65 4
a68 4
%	char	ut_line[8];		/* tty name */
%	char	ut_name[8];		/* user id */
%	char	ut_host[16];		/* host name, if remote */
%	time_t	ut_time;		/* time on */
d73 1
a73 1
%	struct utmp **uta_arr;
d77 1
d89 1
d91 2
a92 12
%#include <sys/cdefs.h>
%__BEGIN_DECLS
%bool_t xdr_utmp __P((XDR *, struct ru_utmp *));
%bool_t xdr_utmpptr __P((XDR *, struct ru_utmp **));
%bool_t xdr_utmparr __P((XDR *, struct utmparr *));
%bool_t xdr_utmpidle __P((XDR *, struct utmpidle *));
%bool_t xdr_utmpidleptr __P((XDR *, struct utmpidle **));
%bool_t xdr_utmpidlearr __P((XDR *, struct utmpidlearr *));
%__END_DECLS
%
%#define RUSERSVERS_1 ((u_int32_t)1)
%#define RUSERSVERS_2 ((u_int32_t)2)
d94 1
a94 1
%#define RUSERSPROG ((u_int32_t)100002)
d97 1
a97 1
%#define RUSERSPROC_NUM ((u_int32_t)1)
d100 1
a100 1
%#define RUSERSPROC_NAMES ((u_int32_t)2)
d103 1
a103 1
%#define RUSERSPROC_ALLNAMES ((u_int32_t)3)
a113 1
%	char *ptr;
d116 10
a125 17
%	/*
%	 * We are using a non-malloc allocated array,
%	 * so we are not supposed to call xdr_free with it.
%	 */
%	if (xdrs->x_op == XDR_FREE)
%		return (TRUE);
%	ptr  = objp->ut_line;
%	size = sizeof(objp->ut_line);
%	if (!xdr_bytes(xdrs, &ptr, &size, size))
%		return (FALSE);
%	ptr  = objp->ut_name;
%	size = sizeof(objp->ut_name);
%	if (!xdr_bytes(xdrs, &ptr, &size, size))
%		return (FALSE);
%	ptr  = objp->ut_host;
%	size = sizeof(objp->ut_host);
%	if (!xdr_bytes(xdrs, &ptr, &size, size))
d127 2
a128 1
%	if (!xdr_long(xdrs, &objp->ut_time))
d130 1
a138 1
%
d140 1
a140 1
%			   xdr_utmp))
d142 1
a150 1
%
d152 1
a152 1
%		       MAXUSERS, sizeof(struct utmp *), xdr_utmpptr))
d154 1
d163 1
a163 2
%
%	if (!xdr_utmp(xdrs, &objp->ui_utmp))
d165 2
a166 1
%	if (!xdr_u_int(xdrs, &objp->ui_idle))
d168 1
a176 1
%
d178 1
a178 1
%			   xdr_utmpidle))
d180 1
a188 1
%
d190 1
a190 1
%		       MAXUSERS, sizeof(struct utmpidle *), xdr_utmpidleptr))
d192 1
@


1.6
log
@$OpenBSD$
@
text
@d37 1
d41 1
a41 1
%static char rcsid[] = "$OpenBSD: rnusers.x,v 1.5 1997/08/01 19:29:44 millert Exp $";
a59 5
%
%#define RNUSERS_MAXUSERLEN 8
%#define RNUSERS_MAXLINELEN 8
%#define RNUSERS_MAXHOSTLEN 16
%
d61 4
a64 4
%	char	*ut_line;		/* tty name */
%	char	*ut_name;		/* user id */
%	char	*ut_host;		/* host name, if remote */
%	int	ut_time;		/* time on */
d69 1
a69 1
%	struct ru_utmp **uta_arr;
a72 1
%int xdr_utmparr();
a83 1
%int xdr_utmpidlearr();
d85 12
a96 2
%#define RUSERSVERS_1 ((u_long)1)
%#define RUSERSVERS_2 ((u_long)2)
d98 1
a98 1
%#define RUSERSPROG ((u_long)100002)
d101 1
a101 1
%#define RUSERSPROC_NUM ((u_long)1)
d104 1
a104 1
%#define RUSERSPROC_NAMES ((u_long)2)
d107 1
a107 1
%#define RUSERSPROC_ALLNAMES ((u_long)3)
d118 1
d121 17
a137 10
%	size = RNUSERS_MAXLINELEN;
%	if (!xdr_bytes(xdrs, &objp->ut_line, &size, RNUSERS_MAXLINELEN)) {
%		return (FALSE);
%	}
%	size = RNUSERS_MAXUSERLEN;
%	if (!xdr_bytes(xdrs, &objp->ut_name, &size, RNUSERS_MAXUSERLEN)) {
%		return (FALSE);
%	}
%	size = RNUSERS_MAXHOSTLEN;
%	if (!xdr_bytes(xdrs, &objp->ut_host, &size, RNUSERS_MAXHOSTLEN)) {
d139 1
a139 2
%	}
%	if (!xdr_int(xdrs, &objp->ut_time)) {
a140 1
%	}
d149 1
d151 1
a151 1
%			   xdr_utmp)) {
a152 1
%	}
d161 1
d163 1
a163 1
%		       MAXUSERS, sizeof(struct ru_utmp *), xdr_utmpptr)) {
a164 1
%	}
d173 2
a174 1
%	if (!xdr_utmp(xdrs, &objp->ui_utmp)) {
d176 1
a176 2
%	}
%	if (!xdr_u_int(xdrs, &objp->ui_idle)) {
a177 1
%	}
d186 1
d188 1
a188 1
%			   xdr_utmpidle)) {
a189 1
%	}
d198 1
d200 1
a200 1
%		       MAXUSERS, sizeof(struct utmpidle *), xdr_utmpidleptr)) {
a201 1
%	}
@


1.5
log
@ut_time is an int
@
text
@d1 2
d40 1
a40 1
%static char rcsid[] = "$Id: rnusers.x,v 1.4 1996/09/22 08:39:59 tholo Exp $";
@


1.4
log
@Always use private utmp structure definition; don't depend on host system
not to change
@
text
@d38 1
a38 1
%static char rcsid[] = "$Id: rnusers.x,v 1.3 1996/09/22 08:13:43 tholo Exp $";
d66 1
a66 1
%	long	ut_time;		/* time on */
d126 1
a126 1
%	if (!xdr_long(xdrs, &objp->ut_time)) {
@


1.3
log
@Avoid name clashes with rusers.x
@
text
@d38 1
a38 1
%static char rcsid[] = "$Id: rnusers.x,v 1.2 1996/09/22 07:59:07 tholo Exp $";
d71 1
a71 1
%	struct utmp **uta_arr;
d135 1
a135 1
%	struct utmp **objpp;
d150 1
a150 1
%		       MAXUSERS, sizeof(struct utmp *), xdr_utmpptr)) {
@


1.2
log
@Make this work properly; we have to let the XDR routines allocate and free
memory for us.
@
text
@d38 1
a38 1
%static char rcsid[] = "$Id: rnusers.x,v 1.1.1.1 1995/10/18 08:43:10 deraadt Exp $";
d58 3
a60 3
%#define RUSERS_MAXUSERLEN 8
%#define RUSERS_MAXLINELEN 8
%#define RUSERS_MAXHOSTLEN 16
d114 2
a115 2
%	size = RUSERS_MAXLINELEN;
%	if (!xdr_bytes(xdrs, &objp->ut_line, &size, RUSERS_MAXLINELEN)) {
d118 2
a119 2
%	size = RUSERS_MAXUSERLEN;
%	if (!xdr_bytes(xdrs, &objp->ut_name, &size, RUSERS_MAXUSERLEN)) {
d122 2
a123 2
%	size = RUSERS_MAXHOSTLEN;
%	if (!xdr_bytes(xdrs, &objp->ut_host, &size, RUSERS_MAXHOSTLEN)) {
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
%static char rcsid[] = "$Id: rnusers.x,v 1.1 1995/01/12 19:39:53 jtc Exp $";
d57 5
d63 3
a65 3
%	char	ut_line[8];		/* tty name */
%	char	ut_name[8];		/* user id */
%	char	ut_host[16];		/* host name, if remote */
a111 1
%	char *ptr;
d114 2
a115 3
%	ptr  = objp->ut_line;
%	size = sizeof(objp->ut_line);
%	if (!xdr_bytes(xdrs, &ptr, &size, size)) {
d118 2
a119 3
%	ptr  = objp->ut_name;
%	size = sizeof(objp->ut_line);
%	if (!xdr_bytes(xdrs, &ptr, &size, size)) {
d122 2
a123 3
%	ptr  = objp->ut_host;
%	size = sizeof(objp->ut_host);
%	if (!xdr_bytes(xdrs, &ptr, &size, size)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
