head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.1.0.4
	OPENBSD_6_0_BASE:1.1
	OPENBSD_5_9:1.1.0.2
	OPENBSD_5_9_BASE:1.1;
locks; strict;
comment	@.\" @;


1.8
date	2017.01.06.20.35.23;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	zQjBCi56P5qtBYhd;

1.7
date	2016.12.11.14.22.43;	author schwarze;	state Exp;
branches;
next	1.6;
commitid	vNo9ojV3GFqPchdI;

1.6
date	2016.12.11.12.21.48;	author schwarze;	state Exp;
branches;
next	1.5;
commitid	gtHWkzls8TKG85kf;

1.5
date	2016.12.10.22.47.49;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	Jnyf2h2zidKORaea;

1.4
date	2016.11.21.14.27.38;	author schwarze;	state Exp;
branches;
next	1.3;
commitid	fUcNpRsJybgEy7Nl;

1.3
date	2016.11.14.18.23.30;	author jmc;	state Exp;
branches;
next	1.2;
commitid	n3ExXv5sDEoI3U5n;

1.2
date	2016.11.06.15.52.50;	author jmc;	state Exp;
branches;
next	1.1;
commitid	UKoyflsJLv0vYdpL;

1.1
date	2015.11.12.00.55.49;	author schwarze;	state Exp;
branches;
next	;
commitid	RO3YWQP7BDJs4F8k;


desc
@@


1.8
log
@resolve duplication of names and prototypes in manuals related to ex_data
and sprinkle cross references instead; more work is obviously needed here
@
text
@.\"	$OpenBSD: ECDSA_SIG_new.3,v 1.7 2016/12/11 14:22:43 schwarze Exp $
.\"	OpenSSL e6390aca Jul 21 10:06:03 2015 -0400
.\"
.\" This file was written by Nils Larsch <nils@@openssl.org>.
.\" Copyright (c) 2004, 2005, 2012, 2013 The OpenSSL Project.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\"
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in
.\"    the documentation and/or other materials provided with the
.\"    distribution.
.\"
.\" 3. All advertising materials mentioning features or use of this
.\"    software must display the following acknowledgment:
.\"    "This product includes software developed by the OpenSSL Project
.\"    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
.\"
.\" 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
.\"    endorse or promote products derived from this software without
.\"    prior written permission. For written permission, please contact
.\"    openssl-core@@openssl.org.
.\"
.\" 5. Products derived from this software may not be called "OpenSSL"
.\"    nor may "OpenSSL" appear in their names without prior written
.\"    permission of the OpenSSL Project.
.\"
.\" 6. Redistributions of any form whatsoever must retain the following
.\"    acknowledgment:
.\"    "This product includes software developed by the OpenSSL Project
.\"    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
.\" EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
.\" ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
.\" SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
.\" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
.\" OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: December 11 2016 $
.Dt ECDSA_SIG_NEW 3
.Os
.Sh NAME
.Nm ECDSA_SIG_new ,
.Nm ECDSA_SIG_free ,
.Nm i2d_ECDSA_SIG ,
.Nm d2i_ECDSA_SIG ,
.Nm ECDSA_size ,
.Nm ECDSA_sign_setup ,
.Nm ECDSA_sign ,
.Nm ECDSA_sign_ex ,
.Nm ECDSA_verify ,
.Nm ECDSA_do_sign ,
.Nm ECDSA_do_sign_ex ,
.Nm ECDSA_do_verify ,
.Nm ECDSA_OpenSSL ,
.Nm ECDSA_get_default_method ,
.Nm ECDSA_set_default_method ,
.Nm ECDSA_set_method
.Nd Elliptic Curve Digital Signature Algorithm
.Sh SYNOPSIS
.In openssl/ecdsa.h
.Ft ECDSA_SIG*
.Fo ECDSA_SIG_new
.Fa void
.Fc
.Ft void
.Fo ECDSA_SIG_free
.Fa "ECDSA_SIG *sig"
.Fc
.Ft int
.Fo i2d_ECDSA_SIG
.Fa "const ECDSA_SIG *sig"
.Fa "unsigned char **pp"
.Fc
.Ft ECDSA_SIG*
.Fo d2i_ECDSA_SIG
.Fa "ECDSA_SIG **sig"
.Fa "const unsigned char **pp"
.Fa "long len"
.Fc
.Ft int
.Fo ECDSA_size
.Fa "const EC_KEY *eckey"
.Fc
.Ft int
.Fo ECDSA_sign_setup
.Fa "EC_KEY *eckey"
.Fa "BN_CTX *ctx"
.Fa "BIGNUM **kinv"
.Fa "BIGNUM **rp"
.Fc
.Ft int
.Fo ECDSA_sign
.Fa "int type"
.Fa "const unsigned char *dgst"
.Fa "int dgstlen"
.Fa "unsigned char *sig"
.Fa "unsigned int *siglen"
.Fa "EC_KEY *eckey"
.Fc
.Ft int
.Fo ECDSA_sign_ex
.Fa "int type"
.Fa "const unsigned char *dgst"
.Fa "int dgstlen"
.Fa "unsigned char *sig"
.Fa "unsigned int *siglen"
.Fa "const BIGNUM *kinv"
.Fa "const BIGNUM *rp"
.Fa "EC_KEY *eckey"
.Fc
.Ft int
.Fo ECDSA_verify
.Fa "int type"
.Fa "const unsigned char *dgst"
.Fa "int dgstlen"
.Fa "const unsigned char *sig"
.Fa "int siglen"
.Fa "EC_KEY *eckey"
.Fc
.Ft ECDSA_SIG*
.Fo ECDSA_do_sign
.Fa "const unsigned char *dgst"
.Fa "int dgst_len"
.Fa "EC_KEY *eckey"
.Fc
.Ft ECDSA_SIG*
.Fo ECDSA_do_sign_ex
.Fa "const unsigned char *dgst"
.Fa "int dgstlen"
.Fa "const BIGNUM *kinv"
.Fa "const BIGNUM *rp"
.Fa "EC_KEY *eckey"
.Fc
.Ft int
.Fo ECDSA_do_verify
.Fa "const unsigned char *dgst"
.Fa "int dgst_len"
.Fa "const ECDSA_SIG *sig"
.Fa "EC_KEY* eckey"
.Fc
.Ft const ECDSA_METHOD*
.Fo ECDSA_OpenSSL
.Fa void
.Fc
.Ft const ECDSA_METHOD*
.Fo ECDSA_get_default_method
.Fa void
.Fc
.Ft void
.Fo ECDSA_set_default_method
.Fa "const ECDSA_METHOD *meth"
.Fc
.Ft int
.Fo ECDSA_set_method
.Fa "EC_KEY *eckey"
.Fa "const ECDSA_METHOD *meth"
.Fc
.Sh DESCRIPTION
These functions provide a low level interface to ECDSA.
Most applications should use the higher level EVP interface such as
.Xr EVP_DigestSignInit 3
or
.Xr EVP_DigestVerifyInit 3
instead.
Creation of the required
.Vt EC_KEY
objects is described in
.Xr EC_KEY_new 3 .
.Pp
The
.Vt ECDSA_SIG
structure consists of two
.Vt BIGNUM Ns s
for the
.Fa r
and
.Fa s
value of an ECDSA signature (see X9.62 or FIPS 186-2).
.Bd -literal -offset indent
struct {
	BIGNUM *r;
	BIGNUM *s;
} ECDSA_SIG;
.Ed
.Pp
.Fn ECDSA_SIG_new
allocates a new
.Vt ECDSA_SIG
structure (note: this function also allocates the
.Vt BIGNUM Ns s )
and initializes it.
.Pp
.Fn ECDSA_SIG_free
frees the
.Vt ECDSA_SIG
structure
.Fa sig .
.Pp
.Fn i2d_ECDSA_SIG
creates the DER encoding of the ECDSA signature
.Fa sig
and writes the encoded signature to
.Fa *pp
(note: if
.Fa pp
is
.Dv NULL ,
.Fn i2d_ECDSA_SIG
returns the expected length in bytes of the DER-encoded signature).
.Fn i2d_ECDSA_SIG
returns the length of the DER-encoded signature (or 0 on error).
.Pp
.Fn d2i_ECDSA_SIG
decodes a DER-encoded ECDSA signature and returns the decoded signature
in a newly allocated
.Vt ECDSA_SIG
structure.
.Fa *sig
points to the buffer containing the DER-encoded signature of size
.Fa len .
.Pp
.Fn ECDSA_size
returns the maximum length of a DER-encoded ECDSA signature created with
the private EC key
.Fa eckey .
.Pp
.Fn ECDSA_sign_setup
may be used to precompute parts of the signing operation.
.Fa eckey
is the private EC key and
.Fa ctx
is a pointer to a
.Vt BN_CTX
structure (or
.Dv NULL ) .
The precomputed values are returned in
.Fa kinv
and
.Fa rp
and can be used in a later call to
.Fa ECDSA_sign_ex
or
.Fa ECDSA_do_sign_ex .
.Pp
.Fn ECDSA_sign
is a wrapper function for
.Fa ECDSA_sign_ex
with
.Fa kinv
and
.Fa rp
set to
.Dv NULL .
.Pp
.Fn ECDSA_sign_ex
computes a digital signature of the
.Fa dgstlen
bytes hash value
.Fa dgst
using the private EC key
.Fa eckey
and the optional pre-computed values
.Fa kinv
and
.Fa rp .
The DER-encoded signature is stored in
.Fa sig
and its length is returned in
.Fa siglen .
Note:
.Fa sig
must point to
.Fn ECDSA_size
bytes of memory.
The parameter
.Fa type
is ignored.
.Pp
.Fn ECDSA_verify
verifies that the signature in
.Fa sig
of size
.Fa siglen
is a valid ECDSA signature of the hash value
.Fa dgst
of size
.Fa dgstlen
using the public key
.Fa eckey .
The parameter
.Fa type
is ignored.
.Pp
.Fn ECDSA_do_sign
is a wrapper function for
.Fn ECDSA_do_sign_ex
with
.Fa kinv
and
.Fa rp
set to
.Dv NULL .
.Pp
.Fn ECDSA_do_sign_ex
computes a digital signature of the
.Fa dgst_len
bytes hash value
.Fa dgst
using the private key
.Fa eckey
and the optional pre-computed values
.Fa kinv
and
.Fa rp .
The signature is returned in a newly allocated
.Vt ECDSA_SIG
structure (or
.Dv NULL
on error).
.Pp
.Fn ECDSA_do_verify
verifies that the signature
.Fa sig
is a valid ECDSA signature of the hash value
.Fa dgst
of size
.Fa dgst_len
using the public key
.Fa eckey .
.Sh RETURN VALUES
.Fn ECDSA_size
returns the maximum length signature or 0 on error.
.Pp
.Fn ECDSA_sign ,
.Fn ECDSA_sign_ex ,
and
.Fn ECDSA_sign_setup
return 1 if successful or 0 on error.
.Pp
.Fn ECDSA_do_sign
and
.Fn ECDSA_do_sign_ex
return a pointer to an allocated
.Vt ECDSA_SIG
structure or
.Dv NULL
on error.
.Pp
.Fn ECDSA_verify
and
.Fn ECDSA_do_verify
return 1 for a valid signature, 0 for an invalid signature and -1 on
error.
The error codes can be obtained by
.Xr ERR_get_error 3 .
.Sh EXAMPLES
Creating an ECDSA signature of given SHA-1 hash value using the named
curve secp192k1.
.Pp
First step: create an
.Vt EC_KEY
object.
This part is
.Em not
ECDSA specific.
.Bd -literal -offset indent
int ret;
ECDSA_SIG *sig;
EC_KEY *eckey;

eckey = EC_KEY_new_by_curve_name(NID_secp192k1);
if (eckey == NULL) {
	/* error */
}
if (!EC_KEY_generate_key(eckey)) {
	/* error */
}
.Ed
.Pp
Second step: compute the ECDSA signature of a SHA-1 hash value using
.Fn ECDSA_do_sign
.Bd -literal -offset indent
sig = ECDSA_do_sign(digest, 20, eckey);
if (sig == NULL) {
	/* error */
}
.Ed
.Pp
or using
.Fn ECDSA_sign
.Bd -literal -offset indent
unsigned char *buffer, *pp;
int buf_len;

buf_len = ECDSA_size(eckey);
buffer  = malloc(buf_len);
pp = buffer;
if (!ECDSA_sign(0, dgst, dgstlen, pp, &buf_len, eckey) {
	/* error */
}
.Ed
.Pp
Third step: verify the created ECDSA signature using
.Fn ECDSA_do_verify
.Pp
.Dl ret = ECDSA_do_verify(digest, 20, sig, eckey);
.Pp
or using
.Fn ECDSA_verify
.Pp
.Dl ret = ECDSA_verify(0, digest, 20, buffer, buf_len, eckey);
.Pp
and finally evaluate the return value:
.Bd -literal -offset indent
if (ret == -1) {
	/* error */
} else if (ret == 0) {
	/* incorrect signature */
} else {
	/* ret == 1 */
	/* signature ok */
}
.Ed
.Sh SEE ALSO
.Xr d2i_ECPKParameters 3 ,
.Xr DSA_new 3 ,
.Xr EC_GROUP_new 3 ,
.Xr EC_KEY_new 3 ,
.Xr ECDSA_set_ex_data 3 ,
.Xr EVP_DigestSignInit 3 ,
.Xr EVP_DigestVerifyInit 3 ,
.Xr RSA_new 3
.Sh STANDARDS
ANSI X9.62, US Federal Information Processing Standard FIPS 186-2
(Digital Signature Standard, DSS)
.Sh HISTORY
The ECDSA implementation was first introduced in OpenSSL 0.9.8.
.Sh AUTHORS
.An Nils Larsch
for the OpenSSL project.
@


1.7
log
@Distribute the text of ec(3) to the individual EC manuals where it belongs.
Make sure EC_GROUP_new(3) points to all EC manuals and all EC manuals
point back to EC_GROUP_new(3), and add some other useful links as well.
Change all links to ec(3) to point to EC_GROUP_new(3) instead.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ECDSA_SIG_new.3,v 1.6 2016/12/11 12:21:48 schwarze Exp $
a69 2
.Nm ECDSA_get_ex_data ,
.Nm ECDSA_get_ex_new_index ,
a70 1
.Nm ECDSA_set_ex_data ,
a162 13
.Ft void*
.Fo ECDSA_get_ex_data
.Fa "EC_KEY *d"
.Fa "int idx"
.Fc
.Ft int
.Fo ECDSA_get_ex_new_index
.Fa "long argl"
.Fa "void *argp"
.Fa "CRYPTO_EX_new *new_func"
.Fa "CRYPTO_EX_dup *dup_func"
.Fa "CRYPTO_EX_free *free_func"
.Fc
a167 6
.Fo ECDSA_set_ex_data
.Fa "EC_KEY *d"
.Fa "int idx"
.Fa "void *arg"
.Fc
.Ft int
d443 1
@


1.6
log
@Change all references to rsa(3) to point to RSA_new(3) instead.
Make sure all RSA pages point back to RSA_new(3).
@
text
@d1 1
a1 1
.\"	$OpenBSD: ECDSA_SIG_new.3,v 1.5 2016/12/10 22:47:49 schwarze Exp $
d52 1
a52 1
.Dd $Mdocdate: December 10 2016 $
d201 4
d461 1
d463 2
@


1.5
log
@Change all references to dsa(3) to point to DSA_new(3).
Make sure all DSA pages point back to DSA_new(3).
@
text
@d1 1
a1 1
.\"	$OpenBSD: ECDSA_SIG_new.3,v 1.4 2016/11/21 14:27:38 schwarze Exp $
d52 1
a52 1
.Dd $Mdocdate: November 21 2016 $
d460 1
a460 1
.Xr rsa 3
@


1.4
log
@Add Copyright and license.
Merge some additional information from OpenSSL.
@
text
@d1 1
a1 1
.\"	$OpenBSD: ECDSA_SIG_new.3,v 1.3 2016/11/14 18:23:30 jmc Exp $
d52 1
a52 1
.Dd $Mdocdate: November 14 2016 $
d457 1
a457 1
.Xr dsa 3 ,
@


1.3
log
@various cleanup;
@
text
@d1 2
a2 1
.\"	$OpenBSD: ECDSA_SIG_new.3,v 1.2 2016/11/06 15:52:50 jmc Exp $
d4 49
a52 1
.Dd $Mdocdate: November 6 2016 $
d195 7
d223 1
a223 1
and initialize it.
d366 3
d370 3
d374 6
a379 2
.Fn ECDSA_sign
return 1 if successful or 0 on error.
d458 2
@


1.2
log
@first pass; ok schwarze
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d3 1
a3 1
.Dd $Mdocdate: November 12 2015 $
a47 14
.Ft ECDSA_SIG*
.Fo ECDSA_do_sign
.Fa "const unsigned char *dgst"
.Fa "int dgst_len"
.Fa "EC_KEY *eckey"
.Fc
.Ft ECDSA_SIG*
.Fo ECDSA_do_sign_ex
.Fa "const unsigned char *dgst"
.Fa "int dgstlen"
.Fa "const BIGNUM *kinv"
.Fa "const BIGNUM *rp"
.Fa "EC_KEY *eckey"
.Fc
d49 2
a50 5
.Fo ECDSA_do_verify
.Fa "const unsigned char *dgst"
.Fa "int dgst_len"
.Fa "const ECDSA_SIG *sig"
.Fa "EC_KEY* eckey"
d88 14
d103 5
a107 2
.Fo ECDSA_size
.Fa "const EC_KEY *eckey"
a112 4
.Ft void
.Fo ECDSA_set_default_method
.Fa "const ECDSA_METHOD *meth"
.Fc
d117 4
a120 4
.Ft int
.Fo ECDSA_set_method
.Fa "EC_KEY *eckey"
.Fa "const ECDSA_METHOD *meth"
d130 4
d140 4
a143 4
.Ft void*
.Fo ECDSA_get_ex_data
.Fa "EC_KEY *d"
.Fa "int idx"
d185 1
a185 1
returns the expected length in bytes of the DER encoded signature).
d187 1
a187 1
returns the length of the DER encoded signature (or 0 on error).
d190 1
a190 1
decodes a DER encoded ECDSA signature and returns the decoded signature
d195 1
a195 1
points to the buffer containing the DER encoded signature of size
d199 1
a199 1
returns the maximum length of a DER encoded ECDSA signature created with
d212 1
a212 1
The precomputed values or returned in
d222 1
a222 1
is wrapper function for
d242 1
a242 1
The DER encoded signatures is stored in
d271 3
a273 1
is wrapper function for ECDSA_do_sign_ex with
d323 1
a323 1
Creating a ECDSA signature of given SHA-1 hash value using the named
d326 1
a326 1
First step: Create an
d369 1
a369 1
Third step: Verify the created ECDSA signature using
d397 1
a397 1
The ecdsa implementation was first introduced in OpenSSL 0.9.8.
@


1.1
log
@Convert the handful of manuals that had imaginary names,
give them names that really exist.
This also helps jmc@@'s ongoing work on improving NAME sections.
@
text
@d1 3
a3 1
.Dd $Mdocdate: July 17 2014 $
@

