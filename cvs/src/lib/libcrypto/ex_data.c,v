head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19;
locks; strict;
comment	@ * @;


1.19
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.18;
commitid	kT0fLt3r4lroFJra;

1.18
date	2015.02.10.11.22.21;	author jsing;	state Exp;
branches;
next	1.17;
commitid	LaAI4ax0sm4T2bQg;

1.17
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.16;
commitid	yQEL1wOWIearrW15;

1.16
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	mJUVYpkFBZ0Zv2bG;

1.15
date	2014.06.07.14.41.56;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	2nvnQBrv22dLtvTt;

1.14
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2014.05.22.21.12.15;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.20.14.32.19;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.17.50.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.15.13.41.53;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.10;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.02.54;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.02;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.29;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.24;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.34;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.34;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.41;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.02;	author djm;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: ex_data.c,v 1.18 2015/02/10 11:22:21 jsing Exp $ */

/*
 * Overhaul notes;
 *
 * This code is now *mostly* thread-safe. It is now easier to understand in what
 * ways it is safe and in what ways it is not, which is an improvement. Firstly,
 * all per-class stacks and index-counters for ex_data are stored in the same
 * global LHASH table (keyed by class). This hash table uses locking for all
 * access with the exception of CRYPTO_cleanup_all_ex_data(), which must only be
 * called when no other threads can possibly race against it (even if it was
 * locked, the race would mean it's possible the hash table might have been
 * recreated after the cleanup). As classes can only be added to the hash table,
 * and within each class, the stack of methods can only be incremented, the
 * locking mechanics are simpler than they would otherwise be. For example, the
 * new/dup/free ex_data functions will lock the hash table, copy the method
 * pointers it needs from the relevant class, then unlock the hash table before
 * actually applying those method pointers to the task of the new/dup/free
 * operations. As they can't be removed from the method-stack, only
 * supplemented, there's no race conditions associated with using them outside
 * the lock. The get/set_ex_data functions are not locked because they do not
 * involve this global state at all - they operate directly with a previously
 * obtained per-class method index and a particular "ex_data" variable. These
 * variables are usually instantiated per-context (eg. each RSA structure has
 * one) so locking on read/write access to that variable can be locked locally
 * if required (eg. using the "RSA" lock to synchronise access to a
 * per-RSA-structure ex_data variable if required).
 * [Geoff]
 */

/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <openssl/err.h>
#include <openssl/lhash.h>

/* What an "implementation of ex_data functionality" looks like */
struct st_CRYPTO_EX_DATA_IMPL {
	/*********************/
	/* GLOBAL OPERATIONS */
	/* Return a new class index */
	int (*cb_new_class)(void);
	/* Cleanup all state used by the implementation */
	void (*cb_cleanup)(void);
	/************************/
	/* PER-CLASS OPERATIONS */
	/* Get a new method index within a class */
	int (*cb_get_new_index)(int class_index, long argl, void *argp,
	    CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
	    CRYPTO_EX_free *free_func);
	/* Initialise a new CRYPTO_EX_DATA of a given class */
	int (*cb_new_ex_data)(int class_index, void *obj,
	    CRYPTO_EX_DATA *ad);
	/* Duplicate a CRYPTO_EX_DATA of a given class onto a copy */
	int (*cb_dup_ex_data)(int class_index, CRYPTO_EX_DATA *to,
	    CRYPTO_EX_DATA *from);
	/* Cleanup a CRYPTO_EX_DATA of a given class */
	void (*cb_free_ex_data)(int class_index, void *obj,
	    CRYPTO_EX_DATA *ad);
};

/* The implementation we use at run-time */
static const CRYPTO_EX_DATA_IMPL *impl = NULL;

/* To call "impl" functions, use this macro rather than referring to 'impl' directly, eg.
 * EX_IMPL(get_new_index)(...);
*/
#define EX_IMPL(a) impl->cb_##a

/* Predeclare the "default" ex_data implementation */
static int int_new_class(void);
static void int_cleanup(void);
static int int_get_new_index(int class_index, long argl, void *argp,
    CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
    CRYPTO_EX_free *free_func);
static int int_new_ex_data(int class_index, void *obj,
    CRYPTO_EX_DATA *ad);
static int int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
    CRYPTO_EX_DATA *from);
static void int_free_ex_data(int class_index, void *obj,
    CRYPTO_EX_DATA *ad);

static CRYPTO_EX_DATA_IMPL impl_default = {
	int_new_class,
	int_cleanup,
	int_get_new_index,
	int_new_ex_data,
	int_dup_ex_data,
	int_free_ex_data
};

/* Internal function that checks whether "impl" is set and if not, sets it to
 * the default. */
static void
impl_check(void)
{
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	if (!impl)
		impl = &impl_default;
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
}
/* A macro wrapper for impl_check that first uses a non-locked test before
 * invoking the function (which checks again inside a lock). */
#define IMPL_CHECK if(!impl) impl_check();

/* API functions to get/set the "ex_data" implementation */
const CRYPTO_EX_DATA_IMPL *
CRYPTO_get_ex_data_implementation(void)
{
	IMPL_CHECK
	return impl;
}

int
CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i)
{
	int toret = 0;
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	if (!impl) {
		impl = i;
		toret = 1;
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	return toret;
}

/****************************************************************************/
/* Interal (default) implementation of "ex_data" support. API functions are
 * further down. */

/* The type that represents what each "class" used to implement locally. A STACK
 * of CRYPTO_EX_DATA_FUNCS plus a index-counter. The 'class_index' is the global
 * value representing the class that is used to distinguish these items. */
typedef struct st_ex_class_item {
	int class_index;
	STACK_OF(CRYPTO_EX_DATA_FUNCS) *meth;
	int meth_num;
} EX_CLASS_ITEM;

/* When assigning new class indexes, this is our counter */
static int ex_class = CRYPTO_EX_INDEX_USER;

/* The global hash table of EX_CLASS_ITEM items */
DECLARE_LHASH_OF(EX_CLASS_ITEM);
static LHASH_OF(EX_CLASS_ITEM) *ex_data = NULL;

/* The callbacks required in the "ex_data" hash table */
static unsigned long
ex_class_item_hash(const EX_CLASS_ITEM *a)
{
	return a->class_index;
}

static IMPLEMENT_LHASH_HASH_FN(ex_class_item, EX_CLASS_ITEM)

static int
ex_class_item_cmp(const EX_CLASS_ITEM *a, const EX_CLASS_ITEM *b)
{
	return a->class_index - b->class_index;
}

static IMPLEMENT_LHASH_COMP_FN(ex_class_item, EX_CLASS_ITEM)

/* Internal functions used by the "impl_default" implementation to access the
 * state */

static int
ex_data_check(void)
{
	int toret = 1;
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	if (!ex_data &&
	    (ex_data = lh_EX_CLASS_ITEM_new()) == NULL)
		toret = 0;
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	return toret;
}
/* This macros helps reduce the locking from repeated checks because the
 * ex_data_check() function checks ex_data again inside a lock. */
#define EX_DATA_CHECK(iffail) if(!ex_data && !ex_data_check()) {iffail}

/* This "inner" callback is used by the callback function that follows it */
static void
def_cleanup_util_cb(CRYPTO_EX_DATA_FUNCS *funcs)
{
	free(funcs);
}

/* This callback is used in lh_doall to destroy all EX_CLASS_ITEM values from
 * "ex_data" prior to the ex_data hash table being itself destroyed. Doesn't do
 * any locking. */
static void
def_cleanup_cb(void *a_void)
{
	EX_CLASS_ITEM *item = (EX_CLASS_ITEM *)a_void;
	sk_CRYPTO_EX_DATA_FUNCS_pop_free(item->meth, def_cleanup_util_cb);
	free(item);
}

/* Return the EX_CLASS_ITEM from the "ex_data" hash table that corresponds to a
 * given class. Handles locking. */
static EX_CLASS_ITEM *
def_get_class(int class_index)
{
	EX_CLASS_ITEM d, *p, *gen;
	EX_DATA_CHECK(return NULL;)
	d.class_index = class_index;
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	p = lh_EX_CLASS_ITEM_retrieve(ex_data, &d);
	if (!p) {
		gen = malloc(sizeof(EX_CLASS_ITEM));
		if (gen) {
			gen->class_index = class_index;
			gen->meth_num = 0;
			gen->meth = sk_CRYPTO_EX_DATA_FUNCS_new_null();
			if (!gen->meth)
				free(gen);
			else {
				/* Because we're inside the ex_data lock, the
				 * return value from the insert will be NULL */
				(void)lh_EX_CLASS_ITEM_insert(ex_data, gen);
				p = gen;
			}
		}
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	if (!p)
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
	return p;
}

/* Add a new method to the given EX_CLASS_ITEM and return the corresponding
 * index (or -1 for error). Handles locking. */
static int
def_add_index(EX_CLASS_ITEM *item, long argl, void *argp,
    CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
	int toret = -1;
	CRYPTO_EX_DATA_FUNCS *a = malloc(sizeof(CRYPTO_EX_DATA_FUNCS));

	if (!a) {
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
		return -1;
	}
	a->argl = argl;
	a->argp = argp;
	a->new_func = new_func;
	a->dup_func = dup_func;
	a->free_func = free_func;
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	while (sk_CRYPTO_EX_DATA_FUNCS_num(item->meth) <= item->meth_num) {
		if (!sk_CRYPTO_EX_DATA_FUNCS_push(item->meth, NULL)) {
			CRYPTOerror(ERR_R_MALLOC_FAILURE);
			free(a);
			goto err;
		}
	}
	toret = item->meth_num++;
	(void)sk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);
err:
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	return toret;
}

/**************************************************************/
/* The functions in the default CRYPTO_EX_DATA_IMPL structure */

static int
int_new_class(void)
{
	int toret;

	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	toret = ex_class++;
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	return toret;
}

static void
int_cleanup(void)
{
	EX_DATA_CHECK(return;)
	lh_EX_CLASS_ITEM_doall(ex_data, def_cleanup_cb);
	lh_EX_CLASS_ITEM_free(ex_data);
	ex_data = NULL;
	impl = NULL;
}

static int
int_get_new_index(int class_index, long argl, void *argp,
    CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
    CRYPTO_EX_free *free_func)
{
	EX_CLASS_ITEM *item = def_get_class(class_index);

	if (!item)
		return -1;
	return def_add_index(item, argl, argp, new_func, dup_func, free_func);
}

/* Thread-safe by copying a class's array of "CRYPTO_EX_DATA_FUNCS" entries in
 * the lock, then using them outside the lock. NB: Thread-safety only applies to
 * the global "ex_data" state (ie. class definitions), not thread-safe on 'ad'
 * itself. */
static int
int_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
	int mx, i;
	void *ptr;
	CRYPTO_EX_DATA_FUNCS **storage = NULL;
	EX_CLASS_ITEM *item = def_get_class(class_index);

	if (!item)
		/* error is already set */
		return 0;
	ad->sk = NULL;
	CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
	mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);
	if (mx > 0) {
		storage = reallocarray(NULL, mx, sizeof(CRYPTO_EX_DATA_FUNCS*));
		if (!storage)
			goto skip;
		for (i = 0; i < mx; i++)
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(
			    item->meth, i);
	}
skip:
	CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
	if ((mx > 0) && !storage) {
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	for (i = 0; i < mx; i++) {
		if (storage[i] && storage[i]->new_func) {
			ptr = CRYPTO_get_ex_data(ad, i);
			storage[i]->new_func(obj, ptr, ad, i,
			    storage[i]->argl, storage[i]->argp);
		}
	}
	free(storage);
	return 1;
}

/* Same thread-safety notes as for "int_new_ex_data" */
static int
int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from)
{
	int mx, j, i;
	char *ptr;
	CRYPTO_EX_DATA_FUNCS **storage = NULL;
	EX_CLASS_ITEM *item;

	if (!from->sk)
		/* 'to' should be "blank" which *is* just like 'from' */
		return 1;
	if ((item = def_get_class(class_index)) == NULL)
		return 0;
	CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
	mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);
	j = sk_void_num(from->sk);
	if (j < mx)
		mx = j;
	if (mx > 0) {
		storage = reallocarray(NULL, mx, sizeof(CRYPTO_EX_DATA_FUNCS*));
		if (!storage)
			goto skip;
		for (i = 0; i < mx; i++)
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(
			    item->meth, i);
	}
skip:
	CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
	if ((mx > 0) && !storage) {
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	for (i = 0; i < mx; i++) {
		ptr = CRYPTO_get_ex_data(from, i);
		if (storage[i] && storage[i]->dup_func)
			storage[i]->dup_func(to, from, &ptr, i,
			    storage[i]->argl, storage[i]->argp);
		CRYPTO_set_ex_data(to, i, ptr);
	}
	free(storage);
	return 1;
}

/* Same thread-safety notes as for "int_new_ex_data" */
static void
int_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
	int mx, i;
	EX_CLASS_ITEM *item;
	void *ptr;
	CRYPTO_EX_DATA_FUNCS **storage = NULL;
	if ((item = def_get_class(class_index)) == NULL)
		return;
	CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
	mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);
	if (mx > 0) {
		storage = reallocarray(NULL, mx, sizeof(CRYPTO_EX_DATA_FUNCS*));
		if (!storage)
			goto skip;
		for (i = 0; i < mx; i++)
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(
			    item->meth, i);
	}
skip:
	CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
	if ((mx > 0) && !storage) {
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
		return;
	}
	for (i = 0; i < mx; i++) {
		if (storage[i] && storage[i]->free_func) {
			ptr = CRYPTO_get_ex_data(ad, i);
			storage[i]->free_func(obj, ptr, ad, i,
			    storage[i]->argl, storage[i]->argp);
		}
	}
	free(storage);
	if (ad->sk) {
		sk_void_free(ad->sk);
		ad->sk = NULL;
	}
}

/********************************************************************/
/* API functions that defer all "state" operations to the "ex_data"
 * implementation we have set. */

/* Obtain an index for a new class (not the same as getting a new index within
 * an existing class - this is actually getting a new *class*) */
int
CRYPTO_ex_data_new_class(void)
{
	IMPL_CHECK
	return EX_IMPL(new_class)();
}

/* Release all "ex_data" state to prevent memory leaks. This can't be made
 * thread-safe without overhauling a lot of stuff, and shouldn't really be
 * called under potential race-conditions anyway (it's for program shutdown
 * after all). */
void
CRYPTO_cleanup_all_ex_data(void)
{
	IMPL_CHECK
	EX_IMPL(cleanup)();
}

/* Inside an existing class, get/register a new index. */
int
CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,
    CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
	int ret = -1;

	IMPL_CHECK
	ret = EX_IMPL(get_new_index)(class_index,
	    argl, argp, new_func, dup_func, free_func);
	return ret;
}

/* Initialise a new CRYPTO_EX_DATA for use in a particular class - including
 * calling new() callbacks for each index in the class used by this variable */
int
CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
	IMPL_CHECK
	return EX_IMPL(new_ex_data)(class_index, obj, ad);
}

/* Duplicate a CRYPTO_EX_DATA variable - including calling dup() callbacks for
 * each index in the class used by this variable */
int
CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from)
{
	IMPL_CHECK
	return EX_IMPL(dup_ex_data)(class_index, to, from);
}

/* Cleanup a CRYPTO_EX_DATA variable - including calling free() callbacks for
 * each index in the class used by this variable */
void
CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
	IMPL_CHECK
	EX_IMPL(free_ex_data)(class_index, obj, ad);
}

/* For a given CRYPTO_EX_DATA variable, set the value corresponding to a
 * particular index in the class used by this variable */
int
CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)
{
	int i;

	if (ad->sk == NULL) {
		if ((ad->sk = sk_void_new_null()) == NULL) {
			CRYPTOerror(ERR_R_MALLOC_FAILURE);
			return (0);
		}
	}
	i = sk_void_num(ad->sk);

	while (i <= idx) {
		if (!sk_void_push(ad->sk, NULL)) {
			CRYPTOerror(ERR_R_MALLOC_FAILURE);
			return (0);
		}
		i++;
	}
	sk_void_set(ad->sk, idx, val);
	return (1);
}

/* For a given CRYPTO_EX_DATA_ variable, get the value corresponding to a
 * particular index in the class used by this variable */
void *
CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)
{
	if (ad->sk == NULL)
		return (0);
	else if (idx >= sk_void_num(ad->sk))
		return (0);
	else
		return (sk_void_value(ad->sk, idx));
}
@


1.18
log
@Remove more IMPLEMENT_STACK_OF noops that have been hiding for the last
15 years.
@
text
@d1 1
a1 1
/* $OpenBSD: ex_data.c,v 1.17 2014/07/11 08:44:47 jsing Exp $ */
d335 1
a335 1
		CRYPTOerr(CRYPTO_F_DEF_GET_CLASS, ERR_R_MALLOC_FAILURE);
d349 1
a349 1
		CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);
d360 1
a360 1
			CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);
d437 1
a437 1
		CRYPTOerr(CRYPTO_F_INT_NEW_EX_DATA, ERR_R_MALLOC_FAILURE);
d481 1
a481 1
		CRYPTOerr(CRYPTO_F_INT_DUP_EX_DATA, ERR_R_MALLOC_FAILURE);
d518 1
a518 1
		CRYPTOerr(CRYPTO_F_INT_FREE_EX_DATA, ERR_R_MALLOC_FAILURE);
d608 1
a608 2
			CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,
			    ERR_R_MALLOC_FAILURE);
d616 1
a616 2
			CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,
			    ERR_R_MALLOC_FAILURE);
@


1.17
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ex_data.c,v 1.16 2014/06/12 15:49:27 deraadt Exp $ */
a638 2

IMPLEMENT_STACK_OF(CRYPTO_EX_DATA_FUNCS)
@


1.16
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d141 1
a141 1
#include "cryptlib.h"
@


1.15
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/ex_data.c */
@


1.14
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d346 2
a347 2
	CRYPTO_EX_DATA_FUNCS *a = (CRYPTO_EX_DATA_FUNCS *)malloc(
	    sizeof(CRYPTO_EX_DATA_FUNCS));
@


1.13
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d427 1
a427 1
		storage = malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));
d471 1
a471 1
		storage = malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));
d508 1
a508 1
		storage = malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));
@


1.12
log
@More KNF.
@
text
@d447 1
a447 2
	if (storage)
		free(storage);
d491 1
a491 2
	if (storage)
		free(storage);
d528 1
a528 2
	if (storage)
		free(storage);
@


1.11
log
@some KNF cleanup following the script
@
text
@d37 1
a37 1
 * 
d44 1
a44 1
 * 
d51 1
a51 1
 * 
d66 1
a66 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d69 1
a69 1
 * 
d81 1
a81 1
 * 
d95 1
a95 1
 *    notice, this list of conditions and the following disclaimer. 
d279 3
a281 3
	if (!ex_data
		&& (ex_data = lh_EX_CLASS_ITEM_new()) == NULL)
	toret = 0;
d347 1
a347 1
	sizeof(CRYPTO_EX_DATA_FUNCS));
d379 1
d399 1
a399 1
CRYPTO_EX_free *free_func)
d402 1
d413 1
a413 2
int_new_ex_data(int class_index, void *obj,
    CRYPTO_EX_DATA *ad)
d419 1
d431 2
a432 1
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);
d444 1
a444 1
			storage[i]->argl, storage[i]->argp);
d454 1
a454 2
int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
    CRYPTO_EX_DATA *from)
d460 1
d476 2
a477 1
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);
d514 2
a515 1
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);
d527 1
a527 1
			storage[i]->argl, storage[i]->argp);
d571 1
a571 1
	argl, argp, new_func, dup_func, free_func);
d611 2
a612 1
			CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);
d620 2
a621 1
			CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);
@


1.10
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d214 2
a215 2
const CRYPTO_EX_DATA_IMPL
*CRYPTO_get_ex_data_implementation(void)
d309 2
a310 2
static EX_CLASS_ITEM
*def_get_class(int class_index)
d625 2
a626 2
void
*CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)
@


1.9
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d293 1
a293 1
	OPENSSL_free(funcs);
d304 1
a304 1
	OPENSSL_free(item);
d318 1
a318 1
		gen = OPENSSL_malloc(sizeof(EX_CLASS_ITEM));
d324 1
a324 1
				OPENSSL_free(gen);
d346 1
a346 1
	CRYPTO_EX_DATA_FUNCS *a = (CRYPTO_EX_DATA_FUNCS *)OPENSSL_malloc(
d361 1
a361 1
			OPENSSL_free(a);
d425 1
a425 1
		storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));
d445 1
a445 1
		OPENSSL_free(storage);
d469 1
a469 1
		storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));
d489 1
a489 1
		OPENSSL_free(storage);
d506 1
a506 1
		storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));
d526 1
a526 1
		OPENSSL_free(storage);
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d145 1
a145 2
struct st_CRYPTO_EX_DATA_IMPL
	{
d156 2
a157 2
			CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
			CRYPTO_EX_free *free_func);
d160 1
a160 1
			CRYPTO_EX_DATA *ad);
d163 1
a163 1
			CRYPTO_EX_DATA *from);
d166 2
a167 2
			CRYPTO_EX_DATA *ad);
	};
d173 2
a174 1
 * EX_IMPL(get_new_index)(...); */
d181 2
a182 2
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func);
d184 1
a184 1
		CRYPTO_EX_DATA *ad);
d186 1
a186 1
		CRYPTO_EX_DATA *from);
d188 3
a190 3
		CRYPTO_EX_DATA *ad);
static CRYPTO_EX_DATA_IMPL impl_default =
	{
d197 1
a197 1
	};
d201 3
a203 2
static void impl_check(void)
	{
d205 1
a205 1
	if(!impl)
d208 1
a208 1
	}
d214 3
a216 2
const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void)
	{
d219 5
a223 3
	}
int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i)
	{
d226 1
a226 2
	if(!impl)
		{
d229 1
a229 1
		}
d232 1
a232 1
	}
d255 3
a257 2
static unsigned long ex_class_item_hash(const EX_CLASS_ITEM *a)
	{
d259 2
a260 1
	}
d263 3
a265 2
static int ex_class_item_cmp(const EX_CLASS_ITEM *a, const EX_CLASS_ITEM *b)
	{
d267 2
a268 1
	}
d274 3
a276 2
static int ex_data_check(void)
	{
d279 3
a281 3
	if(!ex_data
	   && (ex_data = lh_EX_CLASS_ITEM_new()) == NULL)
		toret = 0;
d284 1
a284 1
	}
d290 3
a292 2
static void def_cleanup_util_cb(CRYPTO_EX_DATA_FUNCS *funcs)
	{
d294 1
a294 1
	}
d299 3
a301 2
static void def_cleanup_cb(void *a_void)
	{
d305 1
a305 1
	}
d309 3
a311 2
static EX_CLASS_ITEM *def_get_class(int class_index)
	{
d317 1
a317 2
	if(!p)
		{
d319 1
a319 2
		if(gen)
			{
d323 1
a323 1
			if(!gen->meth)
d325 1
a325 2
			else
				{
a329 1
				}
d332 1
d334 2
a335 2
	if(!p)
		CRYPTOerr(CRYPTO_F_DEF_GET_CLASS,ERR_R_MALLOC_FAILURE);
d337 1
a337 1
	}
d341 4
a344 4
static int def_add_index(EX_CLASS_ITEM *item, long argl, void *argp,
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func)
	{
d347 3
a349 4
					sizeof(CRYPTO_EX_DATA_FUNCS));
	if(!a)
		{
		CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX,ERR_R_MALLOC_FAILURE);
d351 6
a356 6
		}
	a->argl=argl;
	a->argp=argp;
	a->new_func=new_func;
	a->dup_func=dup_func;
	a->free_func=free_func;
d358 3
a360 5
	while (sk_CRYPTO_EX_DATA_FUNCS_num(item->meth) <= item->meth_num)
		{
		if (!sk_CRYPTO_EX_DATA_FUNCS_push(item->meth, NULL))
			{
			CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX,ERR_R_MALLOC_FAILURE);
a362 1
			}
d364 1
d370 1
a370 1
	}
d375 3
a377 2
static int int_new_class(void)
	{
d383 1
a383 1
	}
d385 3
a387 2
static void int_cleanup(void)
	{
d393 1
a393 1
	}
d395 5
a399 4
static int int_get_new_index(int class_index, long argl, void *argp,
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func)
	{
d401 1
a401 1
	if(!item)
d404 1
a404 1
	}
d410 5
a414 4
static int int_new_ex_data(int class_index, void *obj,
		CRYPTO_EX_DATA *ad)
	{
	int mx,i;
d418 1
a418 1
	if(!item)
d424 1
a424 2
	if(mx > 0)
		{
d426 1
a426 1
		if(!storage)
d428 3
a430 3
		for(i = 0; i < mx; i++)
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);
		}
d433 2
a434 3
	if((mx > 0) && !storage)
		{
		CRYPTOerr(CRYPTO_F_INT_NEW_EX_DATA,ERR_R_MALLOC_FAILURE);
d436 3
a438 5
		}
	for(i = 0; i < mx; i++)
		{
		if(storage[i] && storage[i]->new_func)
			{
d440 2
a441 3
			storage[i]->new_func(obj,ptr,ad,i,
				storage[i]->argl,storage[i]->argp);
			}
d443 2
a444 1
	if(storage)
d447 1
a447 1
	}
d450 4
a453 3
static int int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
		CRYPTO_EX_DATA *from)
	{
d458 1
a458 1
	if(!from->sk)
d461 1
a461 1
	if((item = def_get_class(class_index)) == NULL)
d466 1
a466 1
	if(j < mx)
d468 1
a468 2
	if(mx > 0)
		{
d470 1
a470 1
		if(!storage)
d472 3
a474 3
		for(i = 0; i < mx; i++)
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);
		}
d477 2
a478 3
	if((mx > 0) && !storage)
		{
		CRYPTOerr(CRYPTO_F_INT_DUP_EX_DATA,ERR_R_MALLOC_FAILURE);
d480 2
a481 3
		}
	for(i = 0; i < mx; i++)
		{
d483 6
a488 6
		if(storage[i] && storage[i]->dup_func)
			storage[i]->dup_func(to,from,&ptr,i,
				storage[i]->argl,storage[i]->argp);
		CRYPTO_set_ex_data(to,i,ptr);
		}
	if(storage)
d491 1
a491 1
	}
d494 4
a497 4
static void int_free_ex_data(int class_index, void *obj,
		CRYPTO_EX_DATA *ad)
	{
	int mx,i;
d501 1
a501 1
	if((item = def_get_class(class_index)) == NULL)
d505 1
a505 2
	if(mx > 0)
		{
d507 1
a507 1
		if(!storage)
d509 3
a511 3
		for(i = 0; i < mx; i++)
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);
		}
d514 2
a515 3
	if((mx > 0) && !storage)
		{
		CRYPTOerr(CRYPTO_F_INT_FREE_EX_DATA,ERR_R_MALLOC_FAILURE);
d517 6
d524 2
a525 10
	for(i = 0; i < mx; i++)
		{
		if(storage[i] && storage[i]->free_func)
			{
			ptr = CRYPTO_get_ex_data(ad,i);
			storage[i]->free_func(obj,ptr,ad,i,
				storage[i]->argl,storage[i]->argp);
			}
		}
	if(storage)
d527 1
a527 2
	if(ad->sk)
		{
d529 1
a529 2
		ad->sk=NULL;
		}
d531 1
d539 3
a541 2
int CRYPTO_ex_data_new_class(void)
	{
d544 1
a544 1
	}
d550 3
a552 2
void CRYPTO_cleanup_all_ex_data(void)
	{
d555 1
a555 1
	}
d558 4
a561 4
int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func)
	{
d566 1
a566 1
			argl, argp, new_func, dup_func, free_func);
d568 1
a568 1
	}
d572 3
a574 2
int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
	{
d577 1
a577 1
	}
d581 3
a583 3
int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
	     CRYPTO_EX_DATA *from)
	{
d586 1
a586 1
	}
d590 3
a592 2
void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
	{
d595 1
a595 1
	}
d599 3
a601 2
int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)
	{
d604 12
a615 7
	if (ad->sk == NULL)
		{
		if ((ad->sk=sk_void_new_null()) == NULL)
			{
			CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);
			return(0);
			}
a616 9
	i=sk_void_num(ad->sk);

	while (i <= idx)
		{
		if (!sk_void_push(ad->sk,NULL))
			{
			CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);
			return(0);
			}
a617 3
		}
	sk_void_set(ad->sk,idx,val);
	return(1);
d619 3
d625 3
a627 2
void *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)
	{
d629 1
a629 1
		return(0);
d631 1
a631 1
		return(0);
d633 2
a634 2
		return(sk_void_value(ad->sk,idx));
	}
@


1.7
log
@resolve conflicts
@
text
@d248 2
a249 1
static LHASH *ex_data = NULL;
d252 1
a252 1
static unsigned long ex_hash_cb(const void *a_void)
d254 1
a254 1
	return ((const EX_CLASS_ITEM *)a_void)->class_index;
d256 3
a258 1
static int ex_cmp_cb(const void *a_void, const void *b_void)
d260 1
a260 2
	return (((const EX_CLASS_ITEM *)a_void)->class_index -
		((const EX_CLASS_ITEM *)b_void)->class_index);
d262 1
d271 2
a272 1
	if(!ex_data && ((ex_data = lh_new(ex_hash_cb, ex_cmp_cb)) == NULL))
d305 1
a305 1
	p = lh_retrieve(ex_data, &d);
d320 1
a320 1
				lh_insert(ex_data, gen);
d382 2
a383 2
	lh_doall(ex_data, def_cleanup_cb);
	lh_free(ex_data);
d459 1
a459 1
	j = sk_num(from->sk);
d530 1
a530 1
		sk_free(ad->sk);
d603 1
a603 1
		if ((ad->sk=sk_new_null()) == NULL)
d609 1
a609 1
	i=sk_num(ad->sk);
d613 1
a613 1
		if (!sk_push(ad->sk,NULL))
d620 1
a620 1
	sk_set(ad->sk,idx,val);
d630 1
a630 1
	else if (idx >= sk_num(ad->sk))
d633 1
a633 1
		return(sk_value(ad->sk,idx));
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d141 1
a141 4
#include <stdio.h>
#include <stdlib.h>
#include <openssl/buffer.h>
#include <openssl/bio.h>
a142 1
#include "cryptlib.h"
d286 1
a286 1
static void def_cleanup_cb(const void *a_void)
d357 1
a357 1
	sk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d2 29
d87 53
d148 143
a290 2
int CRYPTO_get_ex_new_index(int idx, STACK_OF(CRYPTO_EX_DATA_FUNCS) **skp, long argl, void *argp,
	     CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
d292 4
a295 2
	int ret= -1;
	CRYPTO_EX_DATA_FUNCS *a;
d297 10
a306 4
	MemCheck_off();
	if (*skp == NULL)
		*skp=sk_CRYPTO_EX_DATA_FUNCS_new_null();
	if (*skp == NULL)
d308 16
a323 2
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX,ERR_R_MALLOC_FAILURE);
		goto err;
d325 16
a340 2
	a=(CRYPTO_EX_DATA_FUNCS *)OPENSSL_malloc(sizeof(CRYPTO_EX_DATA_FUNCS));
	if (a == NULL)
d342 2
a343 2
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX,ERR_R_MALLOC_FAILURE);
		goto err;
d350 2
a351 1
	while (sk_CRYPTO_EX_DATA_FUNCS_num(*skp) <= idx)
d353 1
a353 1
		if (!sk_CRYPTO_EX_DATA_FUNCS_push(*skp,NULL))
d355 1
a355 1
			CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX,ERR_R_MALLOC_FAILURE);
d360 2
a361 2
	sk_CRYPTO_EX_DATA_FUNCS_set(*skp,idx, a);
	ret=idx;
d363 230
a592 2
	MemCheck_on();
	return(ret);
d595 2
d624 3
a626 1
void *CRYPTO_get_ex_data(CRYPTO_EX_DATA *ad, int idx)
a633 79
	}

/* The callback is called with the 'object', which is the original data object
 * being duplicated, a pointer to the
 * 'new' object to be inserted, the index, and the argi/argp
 */
int CRYPTO_dup_ex_data(STACK_OF(CRYPTO_EX_DATA_FUNCS) *meth, CRYPTO_EX_DATA *to,
	     CRYPTO_EX_DATA *from)
	{
	int i,j,m,r;
	CRYPTO_EX_DATA_FUNCS *mm;
	char *from_d;

	if (meth == NULL) return(1);
	if (from->sk == NULL) return(1);
	m=sk_CRYPTO_EX_DATA_FUNCS_num(meth);
	j=sk_num(from->sk);
	for (i=0; i<j; i++)
		{
		from_d=CRYPTO_get_ex_data(from,i);
		if (i < m)
			{
			mm=sk_CRYPTO_EX_DATA_FUNCS_value(meth,i);
			if (mm->dup_func != NULL)
				r=mm->dup_func(to,from,(char **)&from_d,i,
					mm->argl,mm->argp);
			}
		CRYPTO_set_ex_data(to,i,from_d);
		}
	return(1);
	}

/* Call each free callback */
void CRYPTO_free_ex_data(STACK_OF(CRYPTO_EX_DATA_FUNCS) *meth, void *obj, CRYPTO_EX_DATA *ad)
	{
	CRYPTO_EX_DATA_FUNCS *m;
	void *ptr;
	int i,max;

	if (meth != NULL)
		{
		max=sk_CRYPTO_EX_DATA_FUNCS_num(meth);
		for (i=0; i<max; i++)
			{
			m=sk_CRYPTO_EX_DATA_FUNCS_value(meth,i);
			if ((m != NULL) && (m->free_func != NULL))
				{
				ptr=CRYPTO_get_ex_data(ad,i);
				m->free_func(obj,ptr,ad,i,m->argl,m->argp);
				}
			}
		}
	if (ad->sk != NULL)
		{
		sk_free(ad->sk);
		ad->sk=NULL;
		}
	}

void CRYPTO_new_ex_data(STACK_OF(CRYPTO_EX_DATA_FUNCS) *meth, void *obj, CRYPTO_EX_DATA *ad)
	{
	CRYPTO_EX_DATA_FUNCS *m;
	void *ptr;
	int i,max;

	ad->sk=NULL;
	if (meth != NULL)
		{
		max=sk_CRYPTO_EX_DATA_FUNCS_num(meth);
		for (i=0; i<max; i++)
			{
			m=sk_CRYPTO_EX_DATA_FUNCS_value(meth,i);
			if ((m != NULL) && (m->new_func != NULL))
				{
				ptr=CRYPTO_get_ex_data(ad,i);
				m->new_func(obj,ptr,ad,i,m->argl,m->argp);
				}
			}
		}
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d104 1
a104 1
	return(idx);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d80 1
a80 1
	a=(CRYPTO_EX_DATA_FUNCS *)Malloc(sizeof(CRYPTO_EX_DATA_FUNCS));
d96 1
a96 1
			Free(a);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d66 2
a67 2
int CRYPTO_get_ex_new_index(int idx, STACK **skp, long argl, char *argp,
	     int (*new_func)(), int (*dup_func)(), void (*free_func)())
d74 1
a74 1
		*skp=sk_new_null();
d91 1
a91 1
	while (sk_num(*skp) <= idx)
d93 1
a93 1
		if (!sk_push(*skp,NULL))
d100 1
a100 1
	sk_set(*skp,idx, (char *)a);
d107 1
a107 1
int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, char *val)
d134 1
a134 1
char *CRYPTO_get_ex_data(CRYPTO_EX_DATA *ad, int idx)
d148 1
a148 1
int CRYPTO_dup_ex_data(STACK *meth, CRYPTO_EX_DATA *to,
d157 1
a157 1
	m=sk_num(meth);
d164 1
a164 1
			mm=(CRYPTO_EX_DATA_FUNCS *)sk_value(meth,i);
d175 1
a175 1
void CRYPTO_free_ex_data(STACK *meth, char *obj, CRYPTO_EX_DATA *ad)
d178 1
a178 1
	char *ptr;
d183 1
a183 1
		max=sk_num(meth);
d186 1
a186 1
			m=(CRYPTO_EX_DATA_FUNCS *)sk_value(meth,i);
d201 1
a201 1
void CRYPTO_new_ex_data(STACK *meth, char *obj, CRYPTO_EX_DATA *ad)
d204 1
a204 1
	char *ptr;
d210 1
a210 1
		max=sk_num(meth);
d213 1
a213 1
			m=(CRYPTO_EX_DATA_FUNCS *)sk_value(meth,i);
d223 1
a223 1

@


1.1
log
@Initial revision
@
text
@d61 3
a63 3
#include "buffer.h"
#include "bio.h"
#include "lhash.h"
d66 2
a67 8
int CRYPTO_get_ex_new_index(idx,skp,argl,argp,new_func,dup_func,free_func)
int idx;
STACK **skp;
long argl;
char *argp;
int (*new_func)();
int (*dup_func)();
void (*free_func)();
d69 1
d72 1
d78 1
a78 1
		return(-1);
d84 1
a84 1
		return(-1);
d97 1
a97 1
			return(-1);
d100 4
a103 1
	sk_value(*skp,idx)=(char *)a;
d107 1
a107 4
int CRYPTO_set_ex_data(ad,idx,val)
CRYPTO_EX_DATA *ad;
int idx;
char *val;
d130 1
a130 1
	sk_value(ad->sk,idx)=val;
d134 1
a134 3
char *CRYPTO_get_ex_data(ad,idx)
CRYPTO_EX_DATA *ad;
int idx;
d144 1
a144 1
/* The callback is called with the 'object', which is the origional data object
d148 2
a149 3
int CRYPTO_dup_ex_data(meth,to,from)
STACK *meth;
CRYPTO_EX_DATA *to,*from;
d175 1
a175 4
void CRYPTO_free_ex_data(meth,obj,ad)
STACK *meth;
char *obj;
CRYPTO_EX_DATA *ad;
d201 1
a201 4
void CRYPTO_new_ex_data(meth,obj,ad)
STACK *meth;
char *obj;
CRYPTO_EX_DATA *ad;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a1 29

/*
 * Overhaul notes;
 *
 * This code is now *mostly* thread-safe. It is now easier to understand in what
 * ways it is safe and in what ways it is not, which is an improvement. Firstly,
 * all per-class stacks and index-counters for ex_data are stored in the same
 * global LHASH table (keyed by class). This hash table uses locking for all
 * access with the exception of CRYPTO_cleanup_all_ex_data(), which must only be
 * called when no other threads can possibly race against it (even if it was
 * locked, the race would mean it's possible the hash table might have been
 * recreated after the cleanup). As classes can only be added to the hash table,
 * and within each class, the stack of methods can only be incremented, the
 * locking mechanics are simpler than they would otherwise be. For example, the
 * new/dup/free ex_data functions will lock the hash table, copy the method
 * pointers it needs from the relevant class, then unlock the hash table before
 * actually applying those method pointers to the task of the new/dup/free
 * operations. As they can't be removed from the method-stack, only
 * supplemented, there's no race conditions associated with using them outside
 * the lock. The get/set_ex_data functions are not locked because they do not
 * involve this global state at all - they operate directly with a previously
 * obtained per-class method index and a particular "ex_data" variable. These
 * variables are usually instantiated per-context (eg. each RSA structure has
 * one) so locking on read/write access to that variable can be locked locally
 * if required (eg. using the "RSA" lock to synchronise access to a
 * per-RSA-structure ex_data variable if required).
 * [Geoff]
 */

a57 53
/* ====================================================================
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d61 3
a63 3
#include <openssl/buffer.h>
#include <openssl/bio.h>
#include <openssl/lhash.h>
d66 14
a79 159
/* What an "implementation of ex_data functionality" looks like */
struct st_CRYPTO_EX_DATA_IMPL
	{
	/*********************/
	/* GLOBAL OPERATIONS */
	/* Return a new class index */
	int (*cb_new_class)(void);
	/* Cleanup all state used by the implementation */
	void (*cb_cleanup)(void);
	/************************/
	/* PER-CLASS OPERATIONS */
	/* Get a new method index within a class */
	int (*cb_get_new_index)(int class_index, long argl, void *argp,
			CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
			CRYPTO_EX_free *free_func);
	/* Initialise a new CRYPTO_EX_DATA of a given class */
	int (*cb_new_ex_data)(int class_index, void *obj,
			CRYPTO_EX_DATA *ad);
	/* Duplicate a CRYPTO_EX_DATA of a given class onto a copy */
	int (*cb_dup_ex_data)(int class_index, CRYPTO_EX_DATA *to,
			CRYPTO_EX_DATA *from);
	/* Cleanup a CRYPTO_EX_DATA of a given class */
	void (*cb_free_ex_data)(int class_index, void *obj,
			CRYPTO_EX_DATA *ad);
	};

/* The implementation we use at run-time */
static const CRYPTO_EX_DATA_IMPL *impl = NULL;

/* To call "impl" functions, use this macro rather than referring to 'impl' directly, eg.
 * EX_IMPL(get_new_index)(...); */
#define EX_IMPL(a) impl->cb_##a

/* Predeclare the "default" ex_data implementation */
static int int_new_class(void);
static void int_cleanup(void);
static int int_get_new_index(int class_index, long argl, void *argp,
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func);
static int int_new_ex_data(int class_index, void *obj,
		CRYPTO_EX_DATA *ad);
static int int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
		CRYPTO_EX_DATA *from);
static void int_free_ex_data(int class_index, void *obj,
		CRYPTO_EX_DATA *ad);
static CRYPTO_EX_DATA_IMPL impl_default =
	{
	int_new_class,
	int_cleanup,
	int_get_new_index,
	int_new_ex_data,
	int_dup_ex_data,
	int_free_ex_data
	};

/* Internal function that checks whether "impl" is set and if not, sets it to
 * the default. */
static void impl_check(void)
	{
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	if(!impl)
		impl = &impl_default;
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	}
/* A macro wrapper for impl_check that first uses a non-locked test before
 * invoking the function (which checks again inside a lock). */
#define IMPL_CHECK if(!impl) impl_check();

/* API functions to get/set the "ex_data" implementation */
const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void)
	{
	IMPL_CHECK
	return impl;
	}
int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i)
	{
	int toret = 0;
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	if(!impl)
		{
		impl = i;
		toret = 1;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	return toret;
	}

/****************************************************************************/
/* Interal (default) implementation of "ex_data" support. API functions are
 * further down. */

/* The type that represents what each "class" used to implement locally. A STACK
 * of CRYPTO_EX_DATA_FUNCS plus a index-counter. The 'class_index' is the global
 * value representing the class that is used to distinguish these items. */
typedef struct st_ex_class_item {
	int class_index;
	STACK_OF(CRYPTO_EX_DATA_FUNCS) *meth;
	int meth_num;
} EX_CLASS_ITEM;

/* When assigning new class indexes, this is our counter */
static int ex_class = CRYPTO_EX_INDEX_USER;

/* The global hash table of EX_CLASS_ITEM items */
static LHASH *ex_data = NULL;

/* The callbacks required in the "ex_data" hash table */
static unsigned long ex_hash_cb(const void *a_void)
	{
	return ((const EX_CLASS_ITEM *)a_void)->class_index;
	}
static int ex_cmp_cb(const void *a_void, const void *b_void)
	{
	return (((const EX_CLASS_ITEM *)a_void)->class_index -
		((const EX_CLASS_ITEM *)b_void)->class_index);
	}

/* Internal functions used by the "impl_default" implementation to access the
 * state */

static int ex_data_check(void)
	{
	int toret = 1;
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	if(!ex_data && ((ex_data = lh_new(ex_hash_cb, ex_cmp_cb)) == NULL))
		toret = 0;
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	return toret;
	}
/* This macros helps reduce the locking from repeated checks because the
 * ex_data_check() function checks ex_data again inside a lock. */
#define EX_DATA_CHECK(iffail) if(!ex_data && !ex_data_check()) {iffail}

/* This "inner" callback is used by the callback function that follows it */
static void def_cleanup_util_cb(CRYPTO_EX_DATA_FUNCS *funcs)
	{
	OPENSSL_free(funcs);
	}

/* This callback is used in lh_doall to destroy all EX_CLASS_ITEM values from
 * "ex_data" prior to the ex_data hash table being itself destroyed. Doesn't do
 * any locking. */
static void def_cleanup_cb(const void *a_void)
	{
	EX_CLASS_ITEM *item = (EX_CLASS_ITEM *)a_void;
	sk_CRYPTO_EX_DATA_FUNCS_pop_free(item->meth, def_cleanup_util_cb);
	OPENSSL_free(item);
	}

/* Return the EX_CLASS_ITEM from the "ex_data" hash table that corresponds to a
 * given class. Handles locking. */
static EX_CLASS_ITEM *def_get_class(int class_index)
	{
	EX_CLASS_ITEM d, *p, *gen;
	EX_DATA_CHECK(return NULL;)
	d.class_index = class_index;
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	p = lh_retrieve(ex_data, &d);
	if(!p)
d81 2
a82 16
		gen = OPENSSL_malloc(sizeof(EX_CLASS_ITEM));
		if(gen)
			{
			gen->class_index = class_index;
			gen->meth_num = 0;
			gen->meth = sk_CRYPTO_EX_DATA_FUNCS_new_null();
			if(!gen->meth)
				OPENSSL_free(gen);
			else
				{
				/* Because we're inside the ex_data lock, the
				 * return value from the insert will be NULL */
				lh_insert(ex_data, gen);
				p = gen;
				}
			}
d84 2
a85 16
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	if(!p)
		CRYPTOerr(CRYPTO_F_DEF_GET_CLASS,ERR_R_MALLOC_FAILURE);
	return p;
	}

/* Add a new method to the given EX_CLASS_ITEM and return the corresponding
 * index (or -1 for error). Handles locking. */
static int def_add_index(EX_CLASS_ITEM *item, long argl, void *argp,
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func)
	{
	int toret = -1;
	CRYPTO_EX_DATA_FUNCS *a = (CRYPTO_EX_DATA_FUNCS *)OPENSSL_malloc(
					sizeof(CRYPTO_EX_DATA_FUNCS));
	if(!a)
d87 2
a88 2
		CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX,ERR_R_MALLOC_FAILURE);
		return -1;
d95 1
a95 2
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	while (sk_CRYPTO_EX_DATA_FUNCS_num(item->meth) <= item->meth_num)
d97 1
a97 1
		if (!sk_CRYPTO_EX_DATA_FUNCS_push(item->meth, NULL))
d99 3
a101 3
			CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX,ERR_R_MALLOC_FAILURE);
			OPENSSL_free(a);
			goto err;
d104 2
a105 5
	toret = item->meth_num++;
	sk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);
err:
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	return toret;
d108 4
a111 4
/**************************************************************/
/* The functions in the default CRYPTO_EX_DATA_IMPL structure */

static int int_new_class(void)
d113 1
a113 6
	int toret;
	CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
	toret = ex_class++;
	CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
	return toret;
	}
d115 1
a115 37
static void int_cleanup(void)
	{
	EX_DATA_CHECK(return;)
	lh_doall(ex_data, def_cleanup_cb);
	lh_free(ex_data);
	ex_data = NULL;
	impl = NULL;
	}

static int int_get_new_index(int class_index, long argl, void *argp,
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func)
	{
	EX_CLASS_ITEM *item = def_get_class(class_index);
	if(!item)
		return -1;
	return def_add_index(item, argl, argp, new_func, dup_func, free_func);
	}

/* Thread-safe by copying a class's array of "CRYPTO_EX_DATA_FUNCS" entries in
 * the lock, then using them outside the lock. NB: Thread-safety only applies to
 * the global "ex_data" state (ie. class definitions), not thread-safe on 'ad'
 * itself. */
static int int_new_ex_data(int class_index, void *obj,
		CRYPTO_EX_DATA *ad)
	{
	int mx,i;
	void *ptr;
	CRYPTO_EX_DATA_FUNCS **storage = NULL;
	EX_CLASS_ITEM *item = def_get_class(class_index);
	if(!item)
		/* error is already set */
		return 0;
	ad->sk = NULL;
	CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
	mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);
	if(mx > 0)
d117 5
a121 5
		storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));
		if(!storage)
			goto skip;
		for(i = 0; i < mx; i++)
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);
d123 3
a125 3
skip:
	CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
	if((mx > 0) && !storage)
d127 1
a127 6
		CRYPTOerr(CRYPTO_F_INT_NEW_EX_DATA,ERR_R_MALLOC_FAILURE);
		return 0;
		}
	for(i = 0; i < mx; i++)
		{
		if(storage[i] && storage[i]->new_func)
d129 2
a130 3
			ptr = CRYPTO_get_ex_data(ad, i);
			storage[i]->new_func(obj,ptr,ad,i,
				storage[i]->argl,storage[i]->argp);
d132 1
d134 2
a135 3
	if(storage)
		OPENSSL_free(storage);
	return 1;
d138 3
a140 3
/* Same thread-safety notes as for "int_new_ex_data" */
static int int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
		CRYPTO_EX_DATA *from)
d142 35
a176 21
	int mx, j, i;
	char *ptr;
	CRYPTO_EX_DATA_FUNCS **storage = NULL;
	EX_CLASS_ITEM *item;
	if(!from->sk)
		/* 'to' should be "blank" which *is* just like 'from' */
		return 1;
	if((item = def_get_class(class_index)) == NULL)
		return 0;
	CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
	mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);
	j = sk_num(from->sk);
	if(j < mx)
		mx = j;
	if(mx > 0)
		{
		storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));
		if(!storage)
			goto skip;
		for(i = 0; i < mx; i++)
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);
d178 1
a178 18
skip:
	CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
	if((mx > 0) && !storage)
		{
		CRYPTOerr(CRYPTO_F_INT_DUP_EX_DATA,ERR_R_MALLOC_FAILURE);
		return 0;
		}
	for(i = 0; i < mx; i++)
		{
		ptr = CRYPTO_get_ex_data(from, i);
		if(storage[i] && storage[i]->dup_func)
			storage[i]->dup_func(to,from,&ptr,i,
				storage[i]->argl,storage[i]->argp);
		CRYPTO_set_ex_data(to,i,ptr);
		}
	if(storage)
		OPENSSL_free(storage);
	return 1;
d181 5
a185 3
/* Same thread-safety notes as for "int_new_ex_data" */
static void int_free_ex_data(int class_index, void *obj,
		CRYPTO_EX_DATA *ad)
d187 5
a191 24
	int mx,i;
	EX_CLASS_ITEM *item;
	void *ptr;
	CRYPTO_EX_DATA_FUNCS **storage = NULL;
	if((item = def_get_class(class_index)) == NULL)
		return;
	CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
	mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);
	if(mx > 0)
		{
		storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));
		if(!storage)
			goto skip;
		for(i = 0; i < mx; i++)
			storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);
		}
skip:
	CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
	if((mx > 0) && !storage)
		{
		CRYPTOerr(CRYPTO_F_INT_FREE_EX_DATA,ERR_R_MALLOC_FAILURE);
		return;
		}
	for(i = 0; i < mx; i++)
d193 2
a194 1
		if(storage[i] && storage[i]->free_func)
d196 6
a201 3
			ptr = CRYPTO_get_ex_data(ad,i);
			storage[i]->free_func(obj,ptr,ad,i,
				storage[i]->argl,storage[i]->argp);
d204 1
a204 3
	if(storage)
		OPENSSL_free(storage);
	if(ad->sk)
d211 4
a214 7
/********************************************************************/
/* API functions that defer all "state" operations to the "ex_data"
 * implementation we have set. */

/* Obtain an index for a new class (not the same as getting a new index within
 * an existing class - this is actually getting a new *class*) */
int CRYPTO_ex_data_new_class(void)
d216 3
a218 26
	IMPL_CHECK
	return EX_IMPL(new_class)();
	}

/* Release all "ex_data" state to prevent memory leaks. This can't be made
 * thread-safe without overhauling a lot of stuff, and shouldn't really be
 * called under potential race-conditions anyway (it's for program shutdown
 * after all). */
void CRYPTO_cleanup_all_ex_data(void)
	{
	IMPL_CHECK
	EX_IMPL(cleanup)();
	}

/* Inside an existing class, get/register a new index. */
int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func)
	{
	int ret = -1;

	IMPL_CHECK
	ret = EX_IMPL(get_new_index)(class_index,
			argl, argp, new_func, dup_func, free_func);
	return ret;
	}
d220 2
a221 32
/* Initialise a new CRYPTO_EX_DATA for use in a particular class - including
 * calling new() callbacks for each index in the class used by this variable */
int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
	{
	IMPL_CHECK
	return EX_IMPL(new_ex_data)(class_index, obj, ad);
	}

/* Duplicate a CRYPTO_EX_DATA variable - including calling dup() callbacks for
 * each index in the class used by this variable */
int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
	     CRYPTO_EX_DATA *from)
	{
	IMPL_CHECK
	return EX_IMPL(dup_ex_data)(class_index, to, from);
	}

/* Cleanup a CRYPTO_EX_DATA variable - including calling free() callbacks for
 * each index in the class used by this variable */
void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
	{
	IMPL_CHECK
	EX_IMPL(free_ex_data)(class_index, obj, ad);
	}

/* For a given CRYPTO_EX_DATA variable, set the value corresponding to a
 * particular index in the class used by this variable */
int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)
	{
	int i;

	if (ad->sk == NULL)
d223 2
a224 1
		if ((ad->sk=sk_new_null()) == NULL)
d226 6
a231 12
			CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);
			return(0);
			}
		}
	i=sk_num(ad->sk);

	while (i <= idx)
		{
		if (!sk_push(ad->sk,NULL))
			{
			CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);
			return(0);
a232 1
		i++;
a233 2
	sk_set(ad->sk,idx,val);
	return(1);
a235 11
/* For a given CRYPTO_EX_DATA_ variable, get the value corresponding to a
 * particular index in the class used by this variable */
void *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)
	{
	if (ad->sk == NULL)
		return(0);
	else if (idx >= sk_num(ad->sk))
		return(0);
	else
		return(sk_value(ad->sk,idx));
	}
a236 1
IMPLEMENT_STACK_OF(CRYPTO_EX_DATA_FUNCS)
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d141 5
a146 1
#include <openssl/lhash.h>
d290 1
a290 1
static void def_cleanup_cb(void *a_void)
d361 1
a361 1
	(void)sk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d248 1
a248 2
DECLARE_LHASH_OF(EX_CLASS_ITEM);
static LHASH_OF(EX_CLASS_ITEM) *ex_data = NULL;
d251 1
a251 1
static unsigned long ex_class_item_hash(const EX_CLASS_ITEM *a)
d253 1
a253 1
	return a->class_index;
d255 1
a255 3
static IMPLEMENT_LHASH_HASH_FN(ex_class_item, EX_CLASS_ITEM)

static int ex_class_item_cmp(const EX_CLASS_ITEM *a, const EX_CLASS_ITEM *b)
d257 2
a258 1
	return a->class_index - b->class_index;
a259 1
static IMPLEMENT_LHASH_COMP_FN(ex_class_item, EX_CLASS_ITEM)
d268 1
a268 2
	if(!ex_data
	   && (ex_data = lh_EX_CLASS_ITEM_new()) == NULL)
d301 1
a301 1
	p = lh_EX_CLASS_ITEM_retrieve(ex_data, &d);
d316 1
a316 1
				(void)lh_EX_CLASS_ITEM_insert(ex_data, gen);
d378 2
a379 2
	lh_EX_CLASS_ITEM_doall(ex_data, def_cleanup_cb);
	lh_EX_CLASS_ITEM_free(ex_data);
d455 1
a455 1
	j = sk_void_num(from->sk);
d526 1
a526 1
		sk_void_free(ad->sk);
d599 1
a599 1
		if ((ad->sk=sk_void_new_null()) == NULL)
d605 1
a605 1
	i=sk_void_num(ad->sk);
d609 1
a609 1
		if (!sk_void_push(ad->sk,NULL))
d616 1
a616 1
	sk_void_set(ad->sk,idx,val);
d626 1
a626 1
	else if (idx >= sk_void_num(ad->sk))
d629 1
a629 1
		return(sk_void_value(ad->sk,idx));
@


