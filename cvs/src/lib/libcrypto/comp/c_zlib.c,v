head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.2
	OPENBSD_6_1_BASE:1.19;
locks; strict;
comment	@ * @;


1.19
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.18;
commitid	kT0fLt3r4lroFJra;

1.18
date	2015.12.23.20.37.23;	author mmcc;	state Exp;
branches;
next	1.17;
commitid	5o0uX3Cl1ddb0aBa;

1.17
date	2014.11.03.16.58.28;	author tedu;	state Exp;
branches;
next	1.16;
commitid	n942paV9fz6n8jsn;

1.16
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	mJUVYpkFBZ0Zv2bG;

1.15
date	2014.06.07.14.41.56;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	2nvnQBrv22dLtvTt;

1.14
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.26.13.04.24;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.20.57.05;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.31.21.10.57;	author jasper;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.37;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.29.05.39.20;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.15.02.29.12;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.05.53.34;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.08;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.34.54;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.06;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.06.27.05.05.32;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.42;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.01.09.12.13.53;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.05;	author djm;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: c_zlib.c,v 1.18 2015/12/23 20:37:23 mmcc Exp $ */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/objects.h>
#include <openssl/comp.h>
#include <openssl/err.h>

COMP_METHOD *COMP_zlib(void );

static COMP_METHOD zlib_method_nozlib = {
	.type = NID_undef,
	.name = "(undef)"
};

#ifdef ZLIB

#include <zlib.h>

static int zlib_stateful_init(COMP_CTX *ctx);
static void zlib_stateful_finish(COMP_CTX *ctx);
static int zlib_stateful_compress_block(COMP_CTX *ctx, unsigned char *out,
    unsigned int olen, unsigned char *in, unsigned int ilen);
static int zlib_stateful_expand_block(COMP_CTX *ctx, unsigned char *out,
    unsigned int olen, unsigned char *in, unsigned int ilen);


/* memory allocations functions for zlib intialization */
static void*
zlib_zalloc(void* opaque, unsigned int no, unsigned int size)
{
	return calloc(no, size);
}

static void
zlib_zfree(void* opaque, void* address)
{
	free(address);
}

static COMP_METHOD zlib_stateful_method = {
	.type = NID_zlib_compression,
	.name = LN_zlib_compression,
	.init = zlib_stateful_init,
	.finish = zlib_stateful_finish,
	.compress = zlib_stateful_compress_block,
	.expand = zlib_stateful_expand_block
};

struct zlib_state {
	z_stream istream;
	z_stream ostream;
};

static int zlib_stateful_ex_idx = -1;

static int
zlib_stateful_init(COMP_CTX *ctx)
{
	int err;
	struct zlib_state *state = malloc(sizeof(struct zlib_state));

	if (state == NULL)
		goto err;

	state->istream.zalloc = zlib_zalloc;
	state->istream.zfree = zlib_zfree;
	state->istream.opaque = Z_NULL;
	state->istream.next_in = Z_NULL;
	state->istream.next_out = Z_NULL;
	state->istream.avail_in = 0;
	state->istream.avail_out = 0;
	err = inflateInit_(&state->istream, ZLIB_VERSION, sizeof(z_stream));
	if (err != Z_OK)
		goto err;

	state->ostream.zalloc = zlib_zalloc;
	state->ostream.zfree = zlib_zfree;
	state->ostream.opaque = Z_NULL;
	state->ostream.next_in = Z_NULL;
	state->ostream.next_out = Z_NULL;
	state->ostream.avail_in = 0;
	state->ostream.avail_out = 0;
	err = deflateInit_(&state->ostream, Z_DEFAULT_COMPRESSION,
	    ZLIB_VERSION, sizeof(z_stream));
	if (err != Z_OK)
		goto err;

	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_COMP, ctx, &ctx->ex_data);
	CRYPTO_set_ex_data(&ctx->ex_data, zlib_stateful_ex_idx, state);
	return 1;

err:
	free(state);
	return 0;
}

static void
zlib_stateful_finish(COMP_CTX *ctx)
{
	struct zlib_state *state =
	    (struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,
	    zlib_stateful_ex_idx);

	inflateEnd(&state->istream);
	deflateEnd(&state->ostream);
	free(state);
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP, ctx, &ctx->ex_data);
}

static int
zlib_stateful_compress_block(COMP_CTX *ctx, unsigned char *out,
    unsigned int olen, unsigned char *in, unsigned int ilen)
{
	int err = Z_OK;
	struct zlib_state *state =
	    (struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,
	    zlib_stateful_ex_idx);

	if (state == NULL)
		return -1;

	state->ostream.next_in = in;
	state->ostream.avail_in = ilen;
	state->ostream.next_out = out;
	state->ostream.avail_out = olen;
	if (ilen > 0)
		err = deflate(&state->ostream, Z_SYNC_FLUSH);
	if (err != Z_OK)
		return -1;

#ifdef DEBUG_ZLIB
	fprintf(stderr, "compress(%4d)->%4d %s\n",
	    ilen, olen - state->ostream.avail_out,
	    (ilen != olen - state->ostream.avail_out)?"zlib":"clear");
#endif

	return olen - state->ostream.avail_out;
}

static int
zlib_stateful_expand_block(COMP_CTX *ctx, unsigned char *out,
    unsigned int olen, unsigned char *in, unsigned int ilen)
{
	int err = Z_OK;

	struct zlib_state *state =
	    (struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,
	    zlib_stateful_ex_idx);

	if (state == NULL)
		return 0;

	state->istream.next_in = in;
	state->istream.avail_in = ilen;
	state->istream.next_out = out;
	state->istream.avail_out = olen;
	if (ilen > 0)
		err = inflate(&state->istream, Z_SYNC_FLUSH);
	if (err != Z_OK)
		return -1;

#ifdef DEBUG_ZLIB
	fprintf(stderr, "expand(%4d)->%4d %s\n",
	    ilen, olen - state->istream.avail_out,
	    (ilen != olen - state->istream.avail_out)?"zlib":"clear");
#endif

	return olen - state->istream.avail_out;
}

#endif

COMP_METHOD *
COMP_zlib(void)
{
	COMP_METHOD *meth = &zlib_method_nozlib;

#ifdef ZLIB
	{
		/* init zlib_stateful_ex_idx here so that in a multi-process
		 * application it's enough to intialize openssl before forking
		 * (idx will be inherited in all the children) */
		if (zlib_stateful_ex_idx == -1) {
			CRYPTO_w_lock(CRYPTO_LOCK_COMP);
			if (zlib_stateful_ex_idx == -1)
				zlib_stateful_ex_idx =
			    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_COMP,
			    0, NULL, NULL, NULL, NULL);
			CRYPTO_w_unlock(CRYPTO_LOCK_COMP);
			if (zlib_stateful_ex_idx == -1)
				goto err;
		}

		meth = &zlib_stateful_method;
	}

err:
#endif

	return (meth);
}

void
COMP_zlib_cleanup(void)
{
}

#ifdef ZLIB

/* Zlib based compression/decompression filter BIO */

typedef struct {
	unsigned char *ibuf;	/* Input buffer */
	int ibufsize;		/* Buffer size */
	z_stream zin;		/* Input decompress context */
	unsigned char *obuf;	/* Output buffer */
	int obufsize;		/* Output buffer size */
	unsigned char *optr;	/* Position in output buffer */
	int ocount;		/* Amount of data in output buffer */
	int odone;		/* deflate EOF */
	int comp_level;		/* Compression level to use */
	z_stream zout;		/* Output compression context */
} BIO_ZLIB_CTX;

#define ZLIB_DEFAULT_BUFSIZE 1024

static int bio_zlib_new(BIO *bi);
static int bio_zlib_free(BIO *bi);
static int bio_zlib_read(BIO *b, char *out, int outl);
static int bio_zlib_write(BIO *b, const char *in, int inl);
static long bio_zlib_ctrl(BIO *b, int cmd, long num, void *ptr);
static long bio_zlib_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp);

static BIO_METHOD bio_meth_zlib = {
	.type = BIO_TYPE_COMP,
	.name = "zlib",
	.bwrite = bio_zlib_write,
	.bread = bio_zlib_read,
	.ctrl = bio_zlib_ctrl,
	.create = bio_zlib_new,
	.destroy = bio_zlib_free,
	.callback_ctrl = bio_zlib_callback_ctrl
};

BIO_METHOD *
BIO_f_zlib(void)
{
	return &bio_meth_zlib;
}


static int
bio_zlib_new(BIO *bi)
{
	BIO_ZLIB_CTX *ctx;

	ctx = malloc(sizeof(BIO_ZLIB_CTX));
	if (!ctx) {
		COMPerror(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	ctx->ibuf = NULL;
	ctx->obuf = NULL;
	ctx->ibufsize = ZLIB_DEFAULT_BUFSIZE;
	ctx->obufsize = ZLIB_DEFAULT_BUFSIZE;
	ctx->zin.zalloc = Z_NULL;
	ctx->zin.zfree = Z_NULL;
	ctx->zin.next_in = NULL;
	ctx->zin.avail_in = 0;
	ctx->zin.next_out = NULL;
	ctx->zin.avail_out = 0;
	ctx->zout.zalloc = Z_NULL;
	ctx->zout.zfree = Z_NULL;
	ctx->zout.next_in = NULL;
	ctx->zout.avail_in = 0;
	ctx->zout.next_out = NULL;
	ctx->zout.avail_out = 0;
	ctx->odone = 0;
	ctx->comp_level = Z_DEFAULT_COMPRESSION;
	bi->init = 1;
	bi->ptr = (char *)ctx;
	bi->flags = 0;
	return 1;
}

static int
bio_zlib_free(BIO *bi)
{
	BIO_ZLIB_CTX *ctx;

	if (!bi)
		return 0;
	ctx = (BIO_ZLIB_CTX *)bi->ptr;
	if (ctx->ibuf) {
		/* Destroy decompress context */
		inflateEnd(&ctx->zin);
		free(ctx->ibuf);
	}
	if (ctx->obuf) {
		/* Destroy compress context */
		deflateEnd(&ctx->zout);
		free(ctx->obuf);
	}
	free(ctx);
	bi->ptr = NULL;
	bi->init = 0;
	bi->flags = 0;
	return 1;
}

static int
bio_zlib_read(BIO *b, char *out, int outl)
{
	BIO_ZLIB_CTX *ctx;
	int ret;
	z_stream *zin;

	if (!out || !outl)
		return 0;
	ctx = (BIO_ZLIB_CTX *)b->ptr;
	zin = &ctx->zin;
	BIO_clear_retry_flags(b);
	if (!ctx->ibuf) {
		ctx->ibuf = malloc(ctx->ibufsize);
		if (!ctx->ibuf) {
			COMPerror(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		inflateInit(zin);
		zin->next_in = ctx->ibuf;
		zin->avail_in = 0;
	}

	/* Copy output data directly to supplied buffer */
	zin->next_out = (unsigned char *)out;
	zin->avail_out = (unsigned int)outl;
	for (;;) {
		/* Decompress while data available */
		while (zin->avail_in) {
			ret = inflate(zin, 0);
			if ((ret != Z_OK) && (ret != Z_STREAM_END)) {
				COMPerror(COMP_R_ZLIB_INFLATE_ERROR);
				ERR_asprintf_error_data("zlib error:%s",
				    zError(ret));
				return 0;
			}
			/* If EOF or we've read everything then return */
			if ((ret == Z_STREAM_END) || !zin->avail_out)
				return outl - zin->avail_out;
		}

		/* No data in input buffer try to read some in,
		 * if an error then return the total data read.
		 */
		ret = BIO_read(b->next_bio, ctx->ibuf, ctx->ibufsize);
		if (ret <= 0) {
			/* Total data read */
			int tot = outl - zin->avail_out;
			BIO_copy_next_retry(b);
			if (ret < 0)
				return (tot > 0) ? tot : ret;
			return tot;
		}
		zin->avail_in = ret;
		zin->next_in = ctx->ibuf;
	}
}

static int
bio_zlib_write(BIO *b, const char *in, int inl)
{
	BIO_ZLIB_CTX *ctx;
	int ret;
	z_stream *zout;

	if (!in || !inl)
		return 0;
	ctx = (BIO_ZLIB_CTX *)b->ptr;
	if (ctx->odone)
		return 0;
	zout = &ctx->zout;
	BIO_clear_retry_flags(b);
	if (!ctx->obuf) {
		ctx->obuf = malloc(ctx->obufsize);
		/* Need error here */
		if (!ctx->obuf) {
			COMPerror(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		ctx->optr = ctx->obuf;
		ctx->ocount = 0;
		deflateInit(zout, ctx->comp_level);
		zout->next_out = ctx->obuf;
		zout->avail_out = ctx->obufsize;
	}
	/* Obtain input data directly from supplied buffer */
	zout->next_in = (void *)in;
	zout->avail_in = inl;
	for (;;) {
		/* If data in output buffer write it first */
		while (ctx->ocount) {
			ret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);
			if (ret <= 0) {
				/* Total data written */
				int tot = inl - zout->avail_in;
				BIO_copy_next_retry(b);
				if (ret < 0)
					return (tot > 0) ? tot : ret;
				return tot;
			}
			ctx->optr += ret;
			ctx->ocount -= ret;
		}

		/* Have we consumed all supplied data? */
		if (!zout->avail_in)
			return inl;

		/* Compress some more */

		/* Reset buffer */
		ctx->optr = ctx->obuf;
		zout->next_out = ctx->obuf;
		zout->avail_out = ctx->obufsize;
		/* Compress some more */
		ret = deflate(zout, 0);
		if (ret != Z_OK) {
			COMPerror(COMP_R_ZLIB_DEFLATE_ERROR);
			ERR_asprintf_error_data("zlib error:%s", zError(ret));
			return 0;
		}
		ctx->ocount = ctx->obufsize - zout->avail_out;
	}
}

static int
bio_zlib_flush(BIO *b)
{
	BIO_ZLIB_CTX *ctx;
	int ret;
	z_stream *zout;

	ctx = (BIO_ZLIB_CTX *)b->ptr;
	/* If no data written or already flush show success */
	if (!ctx->obuf || (ctx->odone && !ctx->ocount))
		return 1;
	zout = &ctx->zout;
	BIO_clear_retry_flags(b);
	/* No more input data */
	zout->next_in = NULL;
	zout->avail_in = 0;
	for (;;) {
		/* If data in output buffer write it first */
		while (ctx->ocount) {
			ret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);
			if (ret <= 0) {
				BIO_copy_next_retry(b);
				return ret;
			}
			ctx->optr += ret;
			ctx->ocount -= ret;
		}
		if (ctx->odone)
			return 1;

		/* Compress some more */

		/* Reset buffer */
		ctx->optr = ctx->obuf;
		zout->next_out = ctx->obuf;
		zout->avail_out = ctx->obufsize;
		/* Compress some more */
		ret = deflate(zout, Z_FINISH);
		if (ret == Z_STREAM_END)
			ctx->odone = 1;
		else if (ret != Z_OK) {
			COMPerror(COMP_R_ZLIB_DEFLATE_ERROR);
			ERR_asprintf_error_data("zlib error:%s", zError(ret));
			return 0;
		}
		ctx->ocount = ctx->obufsize - zout->avail_out;
	}
}

static long
bio_zlib_ctrl(BIO *b, int cmd, long num, void *ptr)
{
	BIO_ZLIB_CTX *ctx;
	int ret, *ip;
	int ibs, obs;
	if (!b->next_bio)
		return 0;
	ctx = (BIO_ZLIB_CTX *)b->ptr;
	switch (cmd) {

	case BIO_CTRL_RESET:
		ctx->ocount = 0;
		ctx->odone = 0;
		ret = 1;
		break;

	case BIO_CTRL_FLUSH:
		ret = bio_zlib_flush(b);
		if (ret > 0)
			ret = BIO_flush(b->next_bio);
		break;

	case BIO_C_SET_BUFF_SIZE:
		ibs = -1;
		obs = -1;
		if (ptr != NULL) {
			ip = ptr;
			if (*ip == 0)
				ibs = (int) num;
			else
				obs = (int) num;
		} else {
			ibs = (int)num;
			obs = ibs;
		}

		if (ibs != -1) {
			free(ctx->ibuf);
			ctx->ibuf = NULL;
			ctx->ibufsize = ibs;
		}

		if (obs != -1) {
			free(ctx->obuf);
			ctx->obuf = NULL;
			ctx->obufsize = obs;
		}
		ret = 1;
		break;

	case BIO_C_DO_STATE_MACHINE:
		BIO_clear_retry_flags(b);
		ret = BIO_ctrl(b->next_bio, cmd, num, ptr);
		BIO_copy_next_retry(b);
		break;

	default:
		ret = BIO_ctrl(b->next_bio, cmd, num, ptr);
		break;

	}

	return ret;
}


static long
bio_zlib_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)
{
	if (!b->next_bio)
		return 0;
	return BIO_callback_ctrl(b->next_bio, cmd, fp);
}

#endif
@


1.18
log
@remove NULL-checks before free()
@
text
@d1 1
a1 1
/* $OpenBSD: c_zlib.c,v 1.17 2014/11/03 16:58:28 tedu Exp $ */
d260 1
a260 1
		COMPerr(COMP_F_BIO_ZLIB_NEW, ERR_R_MALLOC_FAILURE);
d327 1
a327 1
			COMPerr(COMP_F_BIO_ZLIB_READ, ERR_R_MALLOC_FAILURE);
d343 1
a343 2
				COMPerr(COMP_F_BIO_ZLIB_READ,
				    COMP_R_ZLIB_INFLATE_ERROR);
d388 1
a388 1
			COMPerr(COMP_F_BIO_ZLIB_WRITE, ERR_R_MALLOC_FAILURE);
d429 1
a429 2
			COMPerr(COMP_F_BIO_ZLIB_WRITE,
			    COMP_R_ZLIB_DEFLATE_ERROR);
d478 1
a478 2
			COMPerr(COMP_F_BIO_ZLIB_FLUSH,
			    COMP_R_ZLIB_DEFLATE_ERROR);
@


1.17
log
@minor cleanup of zlib code. DSO is gone. ok jsing.
@
text
@d1 1
a1 1
/* $OpenBSD: c_zlib.c,v 1.16 2014/06/12 15:49:28 deraadt Exp $ */
d527 2
a528 4
			if (ctx->ibuf) {
				free(ctx->ibuf);
				ctx->ibuf = NULL;
			}
d533 2
a534 4
			if (ctx->obuf) {
				free(ctx->obuf);
				ctx->obuf = NULL;
			}
@


1.16
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d16 1
a16 3
#ifndef ZLIB
#undef ZLIB_SHARED
#else
a40 17
#if 0
static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out,
    unsigned int olen, unsigned char *in, unsigned int ilen);
static int zlib_expand_block(COMP_CTX *ctx, unsigned char *out,
    unsigned int olen, unsigned char *in, unsigned int ilen);

static int zz_uncompress(Bytef *dest, uLongf *destLen, const Bytef *source,
    uLong sourceLen);

static COMP_METHOD zlib_stateless_method = {
	.type = NID_zlib_compression,
	.name = LN_zlib_compression,
	.compress = zlib_compress_block,
	.expand = zlib_expand_block
};
#endif

a49 37
#ifdef ZLIB_SHARED
#include <openssl/dso.h>

/* Function pointers */
typedef int (*compress_ft)(Bytef *dest, uLongf *destLen, const Bytef *source,
    uLong sourceLen);
typedef int (*inflateEnd_ft)(z_streamp strm);
typedef int (*inflate_ft)(z_streamp strm, int flush);
typedef int (*inflateInit__ft)(z_streamp strm, const char * version,
    int stream_size);
typedef int (*deflateEnd_ft)(z_streamp strm);
typedef int (*deflate_ft)(z_streamp strm, int flush);
typedef int (*deflateInit__ft)(z_streamp strm, int level, const char * version,
    int stream_size);
typedef const char * (*zError__ft)(int err);
static compress_ft	p_compress = NULL;
static inflateEnd_ft	p_inflateEnd = NULL;
static inflate_ft	p_inflate = NULL;
static inflateInit__ft	p_inflateInit_ = NULL;
static deflateEnd_ft	p_deflateEnd = NULL;
static deflate_ft	p_deflate = NULL;
static deflateInit__ft	p_deflateInit_ = NULL;
static zError__ft	p_zError = NULL;

static int zlib_loaded = 0;     /* only attempt to init func pts once */
static DSO *zlib_dso = NULL;

#define compress                p_compress
#define inflateEnd              p_inflateEnd
#define inflate                 p_inflate
#define inflateInit_            p_inflateInit_
#define deflateEnd              p_deflateEnd
#define deflate                 p_deflate
#define deflateInit_            p_deflateInit_
#define zError			p_zError
#endif /* ZLIB_SHARED */

a171 96
#if 0
static int
zlib_compress_block(COMP_CTX *ctx, unsigned char *out,
    unsigned int olen, unsigned char *in, unsigned int ilen)
{
	unsigned long l;
	int i;
	int clear = 1;

	if (ilen > 128) {
		out[0] = 1;
		l = olen - 1;
		i = compress(&(out[1]), &l, in, (unsigned long)ilen);
		if (i != Z_OK)
			return (-1);
		if (ilen > l) {
			clear = 0;
			l++;
		}
	}
	if (clear) {
		out[0] = 0;
		memcpy(&(out[1]), in, ilen);
		l = ilen + 1;
	}

#ifdef DEBUG_ZLIB
	fprintf(stderr, "compress(%4d)->%4d %s\n",
	    ilen,(int)l, (clear)?"clear":"zlib");
#endif

	return ((int)l);
}

static int
zlib_expand_block(COMP_CTX *ctx, unsigned char *out, unsigned int olen,
    unsigned char *in, unsigned int ilen)
{
	unsigned long l;
	int i;

	if (in[0]) {
		l = olen;
		i = zz_uncompress(out, &l, &(in[1]), (unsigned long)ilen - 1);
		if (i != Z_OK)
			return (-1);
	} else {
		memcpy(out, &(in[1]), ilen - 1);
		l = ilen - 1;
	}

#ifdef DEBUG_ZLIB
	fprintf(stderr, "expand  (%4d)->%4d %s\n",
	    ilen,(int)l, in[0]?"zlib":"clear");
#endif

	return ((int)l);
}

static int
zz_uncompress(Bytef *dest, uLongf *destLen, const Bytef *source,
    uLong sourceLen)
{
	z_stream stream;
	int err;

	stream.next_in = (Bytef*)source;
	stream.avail_in = (uInt)sourceLen;
	/* Check for source > 64K on 16-bit machine: */
	if ((uLong)stream.avail_in != sourceLen)
		return Z_BUF_ERROR;

	stream.next_out = dest;
	stream.avail_out = (uInt)*destLen;
	if ((uLong)stream.avail_out != *destLen)
		return Z_BUF_ERROR;

	stream.zalloc = (alloc_func)0;
	stream.zfree = (free_func)0;

	err = inflateInit_(&stream, ZLIB_VERSION, sizeof(z_stream));
	if (err != Z_OK)
		return err;

	err = inflate(&stream, Z_FINISH);
	if (err != Z_STREAM_END) {
		inflateEnd(&stream);
		return err;
	}
	*destLen = stream.total_out;

	err = inflateEnd(&stream);
	return err;
}
#endif

d179 1
a179 33
#ifdef ZLIB_SHARED
	if (!zlib_loaded) {
		zlib_dso = DSO_load(NULL, "z", NULL, 0);
		if (zlib_dso != NULL) {
			p_compress = (compress_ft)DSO_bind_func(
			    zlib_dso, "compress");
			p_inflateEnd = (inflateEnd_ft)DSO_bind_func(
			    zlib_dso, "inflateEnd");
			p_inflate = (inflate_ft)DSO_bind_func(
			    zlib_dso, "inflate");
			p_inflateInit_ = (inflateInit__ft)DSO_bind_func(
			    zlib_dso, "inflateInit_");
			p_deflateEnd = (deflateEnd_ft)DSO_bind_func(
			    zlib_dso, "deflateEnd");
			p_deflate = (deflate_ft)DSO_bind_func(
			    zlib_dso, "deflate");
			p_deflateInit_ = (deflateInit__ft)DSO_bind_func(
			    zlib_dso, "deflateInit_");
			p_zError = (zError__ft)DSO_bind_func(
			    zlib_dso, "zError");

			if (p_compress && p_inflateEnd && p_inflate &&
			    p_inflateInit_ && p_deflateEnd && p_deflate &&
			    p_deflateInit_ && p_zError)
				zlib_loaded++;
		}
	}

#endif
#ifdef ZLIB_SHARED
	if (zlib_loaded)
#endif
#if defined(ZLIB) || defined(ZLIB_SHARED)
a206 4
#ifdef ZLIB_SHARED
	if (zlib_dso)
		DSO_free(zlib_dso);
#endif
a257 7
#ifdef ZLIB_SHARED
	(void)COMP_zlib();
	if (!zlib_loaded) {
		COMPerr(COMP_F_BIO_ZLIB_NEW, COMP_R_ZLIB_NOT_SUPPORTED);
		return 0;
	}
#endif
@


1.15
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
@


1.14
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d116 1
a116 2
	struct zlib_state *state =
	    (struct zlib_state *)malloc(sizeof(struct zlib_state));
@


1.13
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d11 2
a12 8
	NID_undef,
	"(undef)",
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
d52 4
a55 8
	NID_zlib_compression,
	LN_zlib_compression,
	NULL,
	NULL,
	zlib_compress_block,
	zlib_expand_block,
	NULL,
	NULL,
d60 6
a65 8
	NID_zlib_compression,
	LN_zlib_compression,
	zlib_stateful_init,
	zlib_stateful_finish,
	zlib_stateful_compress_block,
	zlib_stateful_expand_block,
	NULL,
	NULL,
d424 8
a431 10
	BIO_TYPE_COMP,
	"zlib",
	bio_zlib_write,
	bio_zlib_read,
	NULL,
	NULL,
	bio_zlib_ctrl,
	bio_zlib_new,
	bio_zlib_free,
	bio_zlib_callback_ctrl
@


1.12
log
@KNF.
@
text
@d554 1
a554 1
				ERR_add_error_data(2, "zlib error:",
d641 1
a641 1
			ERR_add_error_data(2, "zlib error:", zError(ret));
d691 1
a691 1
			ERR_add_error_data(2, "zlib error:", zError(ret));
@


1.11
log
@malloc + memset 0 -> calloc
(not that it matters much as this is in disabled code, for we don't build with
zlib support)
@
text
@d10 1
a10 1
static COMP_METHOD zlib_method_nozlib={
d19 1
a19 1
	};
d30 1
a30 1
	unsigned int olen, unsigned char *in, unsigned int ilen);
d32 1
a32 1
	unsigned int olen, unsigned char *in, unsigned int ilen);
d36 2
a37 1
static void* zlib_zalloc(void* opaque, unsigned int no, unsigned int size)
d42 2
a43 1
static void zlib_zfree(void* opaque, void* address)
d50 1
a50 1
	unsigned int olen, unsigned char *in, unsigned int ilen);
d52 1
a52 1
	unsigned int olen, unsigned char *in, unsigned int ilen);
d55 1
a55 1
	uLong sourceLen);
d57 1
a57 1
static COMP_METHOD zlib_stateless_method={
d66 1
a66 1
	};
d69 1
a69 1
static COMP_METHOD zlib_stateful_method={
d78 1
a78 1
	};
d84 2
a85 2
typedef int (*compress_ft)(Bytef *dest,uLongf *destLen,
	const Bytef *source, uLong sourceLen);
d88 2
a89 2
typedef int (*inflateInit__ft)(z_streamp strm,
	const char * version, int stream_size);
d92 2
a93 2
typedef int (*deflateInit__ft)(z_streamp strm, int level,
	const char * version, int stream_size);
d95 8
a102 8
static compress_ft	p_compress=NULL;
static inflateEnd_ft	p_inflateEnd=NULL;
static inflate_ft	p_inflate=NULL;
static inflateInit__ft	p_inflateInit_=NULL;
static deflateEnd_ft	p_deflateEnd=NULL;
static deflate_ft	p_deflate=NULL;
static deflateInit__ft	p_deflateInit_=NULL;
static zError__ft	p_zError=NULL;
d117 1
a117 2
struct zlib_state
	{
d120 1
a120 1
	};
d124 3
a126 2
static int zlib_stateful_init(COMP_CTX *ctx)
	{
d129 1
a129 1
		(struct zlib_state *)malloc(sizeof(struct zlib_state));
d141 1
a141 2
	err = inflateInit_(&state->istream,
		ZLIB_VERSION, sizeof(z_stream));
d152 2
a153 2
	err = deflateInit_(&state->ostream,Z_DEFAULT_COMPRESSION,
		ZLIB_VERSION, sizeof(z_stream));
d157 2
a158 2
	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);
	CRYPTO_set_ex_data(&ctx->ex_data,zlib_stateful_ex_idx,state);
d160 2
a161 1
 err:
d164 1
a164 1
	}
d166 3
a168 2
static void zlib_stateful_finish(COMP_CTX *ctx)
	{
d170 3
a172 2
		(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,
			zlib_stateful_ex_idx);
d176 2
a177 2
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);
	}
d179 4
a182 3
static int zlib_stateful_compress_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen)
	{
d185 2
a186 2
		(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,
			zlib_stateful_ex_idx);
d199 1
d201 3
a203 3
	fprintf(stderr,"compress(%4d)->%4d %s\n",
		ilen,olen - state->ostream.avail_out,
		(ilen != olen - state->ostream.avail_out)?"zlib":"clear");
d205 1
d207 1
a207 1
	}
d209 4
a212 3
static int zlib_stateful_expand_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen)
	{
d216 2
a217 2
		(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,
			zlib_stateful_ex_idx);
d230 1
d232 3
a234 3
	fprintf(stderr,"expand(%4d)->%4d %s\n",
		ilen,olen - state->istream.avail_out,
		(ilen != olen - state->istream.avail_out)?"zlib":"clear");
d236 1
d238 1
a238 1
	}
d241 4
a244 3
static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen)
	{
d247 1
a247 1
	int clear=1;
d249 4
a252 5
	if (ilen > 128)
		{
		out[0]=1;
		l=olen-1;
		i=compress(&(out[1]),&l,in,(unsigned long)ilen);
d254 3
a256 4
			return(-1);
		if (ilen > l)
			{
			clear=0;
a257 7
			}
		}
	if (clear)
		{
		out[0]=0;
		memcpy(&(out[1]),in,ilen);
		l=ilen+1;
d259 7
d267 2
a268 2
	fprintf(stderr,"compress(%4d)->%4d %s\n",
		ilen,(int)l,(clear)?"clear":"zlib");
a269 2
	return((int)l);
	}
d271 7
a277 3
static int zlib_expand_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen)
	{
d281 3
a283 4
	if (in[0])
		{
		l=olen;
		i=zz_uncompress(out,&l,&(in[1]),(unsigned long)ilen-1);
d285 6
a290 7
			return(-1);
		}
	else
		{
		memcpy(out,&(in[1]),ilen-1);
		l=ilen-1;
		}
d292 2
a293 2
        fprintf(stderr,"expand  (%4d)->%4d %s\n",
		ilen,(int)l,in[0]?"zlib":"clear");
a294 2
	return((int)l);
	}
d296 6
a301 2
static int zz_uncompress (Bytef *dest, uLongf *destLen, const Bytef *source,
	     uLong sourceLen)
d303 2
a304 2
    z_stream stream;
    int err;
d306 10
a315 4
    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
d317 2
a318 3
    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
d320 3
a322 2
    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
d324 6
a329 10
    err = inflateInit_(&stream,
	    ZLIB_VERSION, sizeof(z_stream));
    if (err != Z_OK) return err;

    err = inflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        inflateEnd(&stream);
        return err;
    }
    *destLen = stream.total_out;
d331 2
a332 2
    err = inflateEnd(&stream);
    return err;
d338 3
a340 2
COMP_METHOD *COMP_zlib(void)
	{
d344 1
a344 2
	if (!zlib_loaded)
		{
d346 21
a366 30
		if (zlib_dso != NULL)
			{
			p_compress
				= (compress_ft) DSO_bind_func(zlib_dso,
					"compress");
			p_inflateEnd
				= (inflateEnd_ft) DSO_bind_func(zlib_dso,
					"inflateEnd");
			p_inflate
				= (inflate_ft) DSO_bind_func(zlib_dso,
					"inflate");
			p_inflateInit_
				= (inflateInit__ft) DSO_bind_func(zlib_dso,
					"inflateInit_");
			p_deflateEnd
				= (deflateEnd_ft) DSO_bind_func(zlib_dso,
					"deflateEnd");
			p_deflate
				= (deflate_ft) DSO_bind_func(zlib_dso,
					"deflate");
			p_deflateInit_
				= (deflateInit__ft) DSO_bind_func(zlib_dso,
					"deflateInit_");
			p_zError
				= (zError__ft) DSO_bind_func(zlib_dso,
					"zError");

			if (p_compress && p_inflateEnd && p_inflate
				&& p_inflateInit_ && p_deflateEnd
				&& p_deflate && p_deflateInit_ && p_zError)
a367 1
			}
d369 1
d376 1
a376 1
		{
d380 1
a380 2
		if (zlib_stateful_ex_idx == -1)
			{
d384 2
a385 2
					CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_COMP,
						0,NULL,NULL,NULL,NULL);
d389 2
a390 2
			}
		
d392 3
a394 2
		}
err:	
d397 2
a398 2
	return(meth);
	}
d400 3
a402 2
void COMP_zlib_cleanup(void)
	{
d407 1
a407 1
	}
d413 1
a413 2
typedef struct
	{
d424 1
a424 1
	} BIO_ZLIB_CTX;
d435 1
a435 2
static BIO_METHOD bio_meth_zlib = 
	{
d446 1
a446 1
	};
d448 3
a450 2
BIO_METHOD *BIO_f_zlib(void)
	{
d452 1
a452 1
	}
d455 3
a457 2
static int bio_zlib_new(BIO *bi)
	{
d459 1
d462 1
a462 2
	if (!zlib_loaded)
		{
d465 1
a465 1
		}
d468 1
a468 2
	if(!ctx)
		{
d471 1
a471 1
		}
d494 1
a494 1
	}
d496 3
a498 2
static int bio_zlib_free(BIO *bi)
	{
d500 3
a502 1
	if(!bi) return 0;
d504 1
a504 2
	if(ctx->ibuf)
		{
d508 2
a509 3
		}
	if(ctx->obuf)
		{
d513 1
a513 1
		}
d519 1
a519 1
	}
d521 3
a523 2
static int bio_zlib_read(BIO *b, char *out, int outl)
	{
d527 3
a529 1
	if(!out || !outl) return 0;
d533 1
a533 2
	if(!ctx->ibuf)
		{
d535 1
a535 2
		if(!ctx->ibuf)
			{
d538 1
a538 1
			}
d542 1
a542 1
		}
d547 1
a547 2
	for(;;)
		{
d549 1
a549 2
		while(zin->avail_in)
			{
d551 1
a551 2
			if((ret != Z_OK) && (ret != Z_STREAM_END))
				{
d553 1
a553 1
						COMP_R_ZLIB_INFLATE_ERROR);
d555 1
a555 1
							zError(ret));
d557 1
a557 1
				}
d559 1
a559 1
			if((ret == Z_STREAM_END) || !zin->avail_out)
d561 1
a561 1
			}
d567 1
a567 2
		if(ret <= 0)
			{
d571 2
a572 1
			if(ret < 0) return (tot > 0) ? tot : ret;
d574 1
a574 1
			}
a576 1
		}
d578 1
d580 3
a582 2
static int bio_zlib_write(BIO *b, const char *in, int inl)
	{
d586 3
a588 1
	if(!in || !inl) return 0;
d590 2
a591 1
	if(ctx->odone) return 0;
d594 1
a594 2
	if(!ctx->obuf)
		{
d597 1
a597 2
		if(!ctx->obuf)
			{
d600 1
a600 1
			}
d606 1
a606 1
		}
d610 1
a610 2
	for(;;)
		{
d612 1
a612 1
		while(ctx->ocount) {
d614 1
a614 2
			if(ret <= 0)
				{
d618 2
a619 1
				if(ret < 0) return (tot > 0) ? tot : ret;
d621 1
a621 1
				}
d627 1
a627 1
		if(!zout->avail_in)
d638 1
a638 2
		if(ret != Z_OK)
			{
d640 1
a640 1
						COMP_R_ZLIB_DEFLATE_ERROR);
d643 1
a643 1
			}
a644 1
		}
d646 1
d648 3
a650 2
static int bio_zlib_flush(BIO *b)
	{
d654 1
d657 2
a658 1
	if(!ctx->obuf || (ctx->odone && !ctx->ocount)) return 1;
d664 1
a664 2
	for(;;)
		{
d666 1
a666 2
		while(ctx->ocount)
			{
d668 1
a668 2
			if(ret <= 0)
				{
d671 1
a671 1
				}
d674 3
a676 2
			}
		if(ctx->odone) return 1;
d686 3
a688 3
		if(ret == Z_STREAM_END) ctx->odone = 1;
		else if(ret != Z_OK)
			{
d690 1
a690 1
						COMP_R_ZLIB_DEFLATE_ERROR);
d693 1
a693 1
			}
a694 1
		}
d696 1
d698 3
a700 2
static long bio_zlib_ctrl(BIO *b, int cmd, long num, void *ptr)
	{
d704 2
a705 1
	if(!b->next_bio) return 0;
d707 1
a707 2
	switch (cmd)
		{
d724 1
a724 2
		if (ptr != NULL)
			{
d728 1
a728 1
			else 
d730 1
a730 3
			}
		else
			{
d733 1
a733 1
			}
d735 2
a736 4
		if (ibs != -1)
			{
			if (ctx->ibuf)
				{
d739 1
a739 1
				}
d741 1
a741 1
			}
d743 2
a744 4
		if (obs != -1)
			{
			if (ctx->obuf)
				{
d747 1
a747 1
				}
d749 1
a749 1
			}
d763 1
a763 1
		}
d766 1
a766 1
	}
d769 4
a772 3
static long bio_zlib_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)
	{
	if(!b->next_bio)
d774 2
a775 3
	return
		BIO_callback_ctrl(b->next_bio, cmd, fp);
	}
@


1.10
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d38 1
a38 6
	void *p;
	
	p=malloc(no*size);
	if (p)
		memset(p, 0, no*size);
	return p;
a40 1

a77 10
/* 
 * When OpenSSL is built on Windows, we do not want to require that
 * the ZLIB.DLL be available in order for the OpenSSL DLLs to
 * work.  Therefore, all ZLIB routines are loaded at run time
 * and we do not link to a .LIB file when ZLIB_SHARED is set.
 */
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
# include <windows.h>
#endif /* !(OPENSSL_SYS_WINDOWS || OPENSSL_SYS_WIN32) */

d160 1
a160 1
	if (state) free(state);
a331 3
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
		zlib_dso = DSO_load(NULL, "ZLIB1", NULL, 0);
#else
a332 1
#endif
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d40 1
a40 1
	p=OPENSSL_malloc(no*size);
d49 1
a49 1
	OPENSSL_free(address);
d143 1
a143 1
		(struct zlib_state *)OPENSSL_malloc(sizeof(struct zlib_state));
d176 1
a176 1
	if (state) OPENSSL_free(state);
d187 1
a187 1
	OPENSSL_free(state);
d482 1
a482 1
	ctx = OPENSSL_malloc(sizeof(BIO_ZLIB_CTX));
d521 1
a521 1
		OPENSSL_free(ctx->ibuf);
d527 1
a527 1
		OPENSSL_free(ctx->obuf);
d529 1
a529 1
	OPENSSL_free(ctx);
d547 1
a547 1
		ctx->ibuf = OPENSSL_malloc(ctx->ibufsize);
d609 1
a609 1
		ctx->obuf = OPENSSL_malloc(ctx->obufsize);
d757 1
a757 1
				OPENSSL_free(ctx->ibuf);
d767 1
a767 1
				OPENSSL_free(ctx->obuf);
@


1.8
log
@add a fix from OpenSSL CVS for SA38200.

"Modify compression code so it avoids using ex_data free functions.
This stops applications that call CRYPTO_free_all_ex_data()
prematurely leaking memory."

looks ok to markus@@
@
text
@d784 1
@


1.7
log
@resolve conflicts
@
text
@a138 9
static void zlib_stateful_free_ex_data(void *obj, void *item,
	CRYPTO_EX_DATA *ad, int ind,long argl, void *argp)
	{
	struct zlib_state *state = (struct zlib_state *)item;
	inflateEnd(&state->istream);
	deflateEnd(&state->ostream);
	OPENSSL_free(state);
	}

d182 6
d402 1
a402 1
						0,NULL,NULL,NULL,zlib_stateful_free_ex_data);
@


1.6
log
@resolve conflicts
@
text
@d730 1
d775 1
a775 1

a786 1

@


1.5
log
@resolve conflicts
@
text
@d27 26
d61 1
a61 1
static COMP_METHOD zlib_method={
d71 12
d88 1
a88 1
 * and we do not link to a .LIB file.
d104 5
d113 4
d125 4
d131 119
d251 1
a251 1
	     unsigned int olen, unsigned char *in, unsigned int ilen)
d284 1
a284 1
	     unsigned int olen, unsigned char *in, unsigned int ilen)
d326 2
a327 1
    err = inflateInit(&stream);
d340 1
d370 12
d384 2
a385 1
				&& p_inflateInit_)
d395 19
a413 1
		meth = &zlib_method;
d419 383
@


1.4
log
@resolve conflicts
@
text
@a53 5

# define Z_CALLCONV _stdcall
# define ZLIB_SHARED
#else
# define Z_CALLCONV
a58 8
/* Prototypes for built in stubs */
static int stub_compress(Bytef *dest,uLongf *destLen,
	const Bytef *source, uLong sourceLen);
static int stub_inflateEnd(z_streamp strm);
static int stub_inflate(z_streamp strm, int flush);
static int stub_inflateInit_(z_streamp strm, const char * version,
	int stream_size);

d60 1
a60 1
typedef int (Z_CALLCONV *compress_ft)(Bytef *dest,uLongf *destLen,
d62 3
a64 3
typedef int (Z_CALLCONV *inflateEnd_ft)(z_streamp strm);
typedef int (Z_CALLCONV *inflate_ft)(z_streamp strm, int flush);
typedef int (Z_CALLCONV *inflateInit__ft)(z_streamp strm,
d74 4
a77 4
#define compress                stub_compress
#define inflateEnd              stub_inflateEnd
#define inflate                 stub_inflate
#define inflateInit_            stub_inflateInit_
a180 10
		if (!zlib_dso)
			{
			zlib_dso = DSO_load(NULL, "ZLIB", NULL, 0);
			if (zlib_dso)
				{
				/* Clear the errors from the first failed
				   DSO_load() */
				ERR_clear_error();
				}
			}
d198 4
a201 1
			zlib_loaded++;
d206 3
d210 1
a210 1
	meth = &zlib_method;
a215 39
#ifdef ZLIB_SHARED
/* Stubs for each function to be dynamicly loaded */
static int 
stub_compress(Bytef *dest,uLongf *destLen,const Bytef *source, uLong sourceLen)
	{
	if (p_compress)
		return(p_compress(dest,destLen,source,sourceLen));
	else
		return(Z_MEM_ERROR);
	}

static int
stub_inflateEnd(z_streamp strm)
	{
	if ( p_inflateEnd )
		return(p_inflateEnd(strm));
	else
		return(Z_MEM_ERROR);
	}

static int
stub_inflate(z_streamp strm, int flush)
	{
	if ( p_inflate )
		return(p_inflate(strm,flush));
	else
		return(Z_MEM_ERROR);
	}

static int
stub_inflateInit_(z_streamp strm, const char * version, int stream_size)
	{
	if ( p_inflateInit_ )
		return(p_inflateInit_(strm,version,stream_size));
	else
		return(Z_MEM_ERROR);
	}

#endif /* ZLIB_SHARED */
@


1.3
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d6 1
d193 11
a203 1
		zlib_dso = DSO_load(NULL, "ZLIB", NULL, 0);
@


1.2
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a210 1
			meth = &zlib_method;
d214 2
a215 1
#elif defined(ZLIB)
@


1.1
log
@new files for OpenSSL 0.9.4
@
text
@d9 1
a9 3
#ifndef ZLIB

static COMP_METHOD zlib_method={
d11 2
a12 1
	"(null)",
d20 2
d42 1
d45 47
d118 4
a121 1
fprintf(stderr,"compress(%4d)->%4d %s\n",ilen,(int)l,(clear)?"clear":"zlib");
d143 4
a146 1
        fprintf(stderr,"expand  (%4d)->%4d %s\n",ilen,(int)l,in[0]?"zlib":"clear");
d186 72
a257 1
	return(&zlib_method);
d260 1
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d9 3
a11 1
static COMP_METHOD zlib_method_nozlib={
d13 1
a13 2
	"(undef)",
	NULL,
a20 2
#ifndef ZLIB
#undef ZLIB_SHARED
a40 1
	NULL,
a42 47
/* 
 * When OpenSSL is built on Windows, we do not want to require that
 * the ZLIB.DLL be available in order for the OpenSSL DLLs to
 * work.  Therefore, all ZLIB routines are loaded at run time
 * and we do not link to a .LIB file.
 */
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
# include <windows.h>

# define Z_CALLCONV _stdcall
# define ZLIB_SHARED
#else
# define Z_CALLCONV
#endif /* !(OPENSSL_SYS_WINDOWS || OPENSSL_SYS_WIN32) */

#ifdef ZLIB_SHARED
#include <openssl/dso.h>

/* Prototypes for built in stubs */
static int stub_compress(Bytef *dest,uLongf *destLen,
	const Bytef *source, uLong sourceLen);
static int stub_inflateEnd(z_streamp strm);
static int stub_inflate(z_streamp strm, int flush);
static int stub_inflateInit_(z_streamp strm, const char * version,
	int stream_size);

/* Function pointers */
typedef int (Z_CALLCONV *compress_ft)(Bytef *dest,uLongf *destLen,
	const Bytef *source, uLong sourceLen);
typedef int (Z_CALLCONV *inflateEnd_ft)(z_streamp strm);
typedef int (Z_CALLCONV *inflate_ft)(z_streamp strm, int flush);
typedef int (Z_CALLCONV *inflateInit__ft)(z_streamp strm,
	const char * version, int stream_size);
static compress_ft	p_compress=NULL;
static inflateEnd_ft	p_inflateEnd=NULL;
static inflate_ft	p_inflate=NULL;
static inflateInit__ft	p_inflateInit_=NULL;

static int zlib_loaded = 0;     /* only attempt to init func pts once */
static DSO *zlib_dso = NULL;

#define compress                stub_compress
#define inflateEnd              stub_inflateEnd
#define inflate                 stub_inflate
#define inflateInit_            stub_inflateInit_
#endif /* ZLIB_SHARED */

d69 1
a69 4
#ifdef DEBUG_ZLIB
	fprintf(stderr,"compress(%4d)->%4d %s\n",
		ilen,(int)l,(clear)?"clear":"zlib");
#endif
d91 1
a91 4
#ifdef DEBUG_ZLIB
        fprintf(stderr,"expand  (%4d)->%4d %s\n",
		ilen,(int)l,in[0]?"zlib":"clear");
#endif
d131 1
a131 72
	COMP_METHOD *meth = &zlib_method_nozlib;

#ifdef ZLIB_SHARED
	if (!zlib_loaded)
		{
#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
		zlib_dso = DSO_load(NULL, "ZLIB", NULL, 0);
#else
		zlib_dso = DSO_load(NULL, "z", NULL, 0);
#endif
		if (zlib_dso != NULL)
			{
			p_compress
				= (compress_ft) DSO_bind_func(zlib_dso,
					"compress");
			p_inflateEnd
				= (inflateEnd_ft) DSO_bind_func(zlib_dso,
					"inflateEnd");
			p_inflate
				= (inflate_ft) DSO_bind_func(zlib_dso,
					"inflate");
			p_inflateInit_
				= (inflateInit__ft) DSO_bind_func(zlib_dso,
					"inflateInit_");
			zlib_loaded++;
			meth = &zlib_method;
			}
		}

#elif defined(ZLIB)
	meth = &zlib_method;
#endif

	return(meth);
	}

#ifdef ZLIB_SHARED
/* Stubs for each function to be dynamicly loaded */
static int 
stub_compress(Bytef *dest,uLongf *destLen,const Bytef *source, uLong sourceLen)
	{
	if (p_compress)
		return(p_compress(dest,destLen,source,sourceLen));
	else
		return(Z_MEM_ERROR);
	}

static int
stub_inflateEnd(z_streamp strm)
	{
	if ( p_inflateEnd )
		return(p_inflateEnd(strm));
	else
		return(Z_MEM_ERROR);
	}

static int
stub_inflate(z_streamp strm, int flush)
	{
	if ( p_inflate )
		return(p_inflate(strm,flush));
	else
		return(Z_MEM_ERROR);
	}

static int
stub_inflateInit_(z_streamp strm, const char * version, int stream_size)
	{
	if ( p_inflateInit_ )
		return(p_inflateInit_(strm,version,stream_size));
	else
		return(Z_MEM_ERROR);
a133 1
#endif /* ZLIB_SHARED */
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d211 1
d215 1
a215 2
#endif
#if defined(ZLIB) || defined(ZLIB_SHARED)
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a5 1
#include <openssl/err.h>
d192 1
a192 11
		zlib_dso = DSO_load(NULL, "ZLIB1", NULL, 0);
		if (!zlib_dso)
			{
			zlib_dso = DSO_load(NULL, "ZLIB", NULL, 0);
			if (zlib_dso)
				{
				/* Clear the errors from the first failed
				   DSO_load() */
				ERR_clear_error();
				}
			}
@


1.1.1.4
log
@import of openssl-0.9.7j
@
text
@d54 5
d64 8
d73 1
a73 1
typedef int (*compress_ft)(Bytef *dest,uLongf *destLen,
d75 3
a77 3
typedef int (*inflateEnd_ft)(z_streamp strm);
typedef int (*inflate_ft)(z_streamp strm, int flush);
typedef int (*inflateInit__ft)(z_streamp strm,
d87 4
a90 4
#define compress                p_compress
#define inflateEnd              p_inflateEnd
#define inflate                 p_inflate
#define inflateInit_            p_inflateInit_
d194 10
d221 1
a221 4

			if (p_compress && p_inflateEnd && p_inflate
				&& p_inflateInit_)
				zlib_loaded++;
a225 3
#ifdef ZLIB_SHARED
	if (zlib_loaded)
#endif
d227 1
a227 1
		meth = &zlib_method;
d233 39
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@a26 26
static int zlib_stateful_init(COMP_CTX *ctx);
static void zlib_stateful_finish(COMP_CTX *ctx);
static int zlib_stateful_compress_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen);
static int zlib_stateful_expand_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen);


/* memory allocations functions for zlib intialization */
static void* zlib_zalloc(void* opaque, unsigned int no, unsigned int size)
{
	void *p;
	
	p=OPENSSL_malloc(no*size);
	if (p)
		memset(p, 0, no*size);
	return p;
}


static void zlib_zfree(void* opaque, void* address)
{
	OPENSSL_free(address);
}

#if 0
d35 1
a35 1
static COMP_METHOD zlib_stateless_method={
a44 12
#endif

static COMP_METHOD zlib_stateful_method={
	NID_zlib_compression,
	LN_zlib_compression,
	zlib_stateful_init,
	zlib_stateful_finish,
	zlib_stateful_compress_block,
	zlib_stateful_expand_block,
	NULL,
	NULL,
	};
d50 1
a50 1
 * and we do not link to a .LIB file when ZLIB_SHARED is set.
a65 5
typedef int (*deflateEnd_ft)(z_streamp strm);
typedef int (*deflate_ft)(z_streamp strm, int flush);
typedef int (*deflateInit__ft)(z_streamp strm, int level,
	const char * version, int stream_size);
typedef const char * (*zError__ft)(int err);
a69 4
static deflateEnd_ft	p_deflateEnd=NULL;
static deflate_ft	p_deflate=NULL;
static deflateInit__ft	p_deflateInit_=NULL;
static zError__ft	p_zError=NULL;
a77 4
#define deflateEnd              p_deflateEnd
#define deflate                 p_deflate
#define deflateInit_            p_deflateInit_
#define zError			p_zError
a79 119
struct zlib_state
	{
	z_stream istream;
	z_stream ostream;
	};

static int zlib_stateful_ex_idx = -1;

static void zlib_stateful_free_ex_data(void *obj, void *item,
	CRYPTO_EX_DATA *ad, int ind,long argl, void *argp)
	{
	struct zlib_state *state = (struct zlib_state *)item;
	inflateEnd(&state->istream);
	deflateEnd(&state->ostream);
	OPENSSL_free(state);
	}

static int zlib_stateful_init(COMP_CTX *ctx)
	{
	int err;
	struct zlib_state *state =
		(struct zlib_state *)OPENSSL_malloc(sizeof(struct zlib_state));

	if (state == NULL)
		goto err;

	state->istream.zalloc = zlib_zalloc;
	state->istream.zfree = zlib_zfree;
	state->istream.opaque = Z_NULL;
	state->istream.next_in = Z_NULL;
	state->istream.next_out = Z_NULL;
	state->istream.avail_in = 0;
	state->istream.avail_out = 0;
	err = inflateInit_(&state->istream,
		ZLIB_VERSION, sizeof(z_stream));
	if (err != Z_OK)
		goto err;

	state->ostream.zalloc = zlib_zalloc;
	state->ostream.zfree = zlib_zfree;
	state->ostream.opaque = Z_NULL;
	state->ostream.next_in = Z_NULL;
	state->ostream.next_out = Z_NULL;
	state->ostream.avail_in = 0;
	state->ostream.avail_out = 0;
	err = deflateInit_(&state->ostream,Z_DEFAULT_COMPRESSION,
		ZLIB_VERSION, sizeof(z_stream));
	if (err != Z_OK)
		goto err;

	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);
	CRYPTO_set_ex_data(&ctx->ex_data,zlib_stateful_ex_idx,state);
	return 1;
 err:
	if (state) OPENSSL_free(state);
	return 0;
	}

static void zlib_stateful_finish(COMP_CTX *ctx)
	{
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);
	}

static int zlib_stateful_compress_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen)
	{
	int err = Z_OK;
	struct zlib_state *state =
		(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,
			zlib_stateful_ex_idx);

	if (state == NULL)
		return -1;

	state->ostream.next_in = in;
	state->ostream.avail_in = ilen;
	state->ostream.next_out = out;
	state->ostream.avail_out = olen;
	if (ilen > 0)
		err = deflate(&state->ostream, Z_SYNC_FLUSH);
	if (err != Z_OK)
		return -1;
#ifdef DEBUG_ZLIB
	fprintf(stderr,"compress(%4d)->%4d %s\n",
		ilen,olen - state->ostream.avail_out,
		(ilen != olen - state->ostream.avail_out)?"zlib":"clear");
#endif
	return olen - state->ostream.avail_out;
	}

static int zlib_stateful_expand_block(COMP_CTX *ctx, unsigned char *out,
	unsigned int olen, unsigned char *in, unsigned int ilen)
	{
	int err = Z_OK;

	struct zlib_state *state =
		(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,
			zlib_stateful_ex_idx);

	if (state == NULL)
		return 0;

	state->istream.next_in = in;
	state->istream.avail_in = ilen;
	state->istream.next_out = out;
	state->istream.avail_out = olen;
	if (ilen > 0)
		err = inflate(&state->istream, Z_SYNC_FLUSH);
	if (err != Z_OK)
		return -1;
#ifdef DEBUG_ZLIB
	fprintf(stderr,"expand(%4d)->%4d %s\n",
		ilen,olen - state->istream.avail_out,
		(ilen != olen - state->istream.avail_out)?"zlib":"clear");
#endif
	return olen - state->istream.avail_out;
	}

#if 0
d81 1
a81 1
	unsigned int olen, unsigned char *in, unsigned int ilen)
d114 1
a114 1
	unsigned int olen, unsigned char *in, unsigned int ilen)
d156 1
a156 2
    err = inflateInit_(&stream,
	    ZLIB_VERSION, sizeof(z_stream));
a168 1
#endif
a197 12
			p_deflateEnd
				= (deflateEnd_ft) DSO_bind_func(zlib_dso,
					"deflateEnd");
			p_deflate
				= (deflate_ft) DSO_bind_func(zlib_dso,
					"deflate");
			p_deflateInit_
				= (deflateInit__ft) DSO_bind_func(zlib_dso,
					"deflateInit_");
			p_zError
				= (zError__ft) DSO_bind_func(zlib_dso,
					"zError");
d200 1
a200 2
				&& p_inflateInit_ && p_deflateEnd
				&& p_deflate && p_deflateInit_ && p_zError)
d210 1
a210 19
		{
		/* init zlib_stateful_ex_idx here so that in a multi-process
		 * application it's enough to intialize openssl before forking
		 * (idx will be inherited in all the children) */
		if (zlib_stateful_ex_idx == -1)
			{
			CRYPTO_w_lock(CRYPTO_LOCK_COMP);
			if (zlib_stateful_ex_idx == -1)
				zlib_stateful_ex_idx =
					CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_COMP,
						0,NULL,NULL,NULL,zlib_stateful_free_ex_data);
			CRYPTO_w_unlock(CRYPTO_LOCK_COMP);
			if (zlib_stateful_ex_idx == -1)
				goto err;
			}
		
		meth = &zlib_stateful_method;
		}
err:	
a215 383
void COMP_zlib_cleanup(void)
	{
#ifdef ZLIB_SHARED
	if (zlib_dso)
		DSO_free(zlib_dso);
#endif
	}

#ifdef ZLIB

/* Zlib based compression/decompression filter BIO */

typedef struct
	{
	unsigned char *ibuf;	/* Input buffer */
	int ibufsize;		/* Buffer size */
	z_stream zin;		/* Input decompress context */
	unsigned char *obuf;	/* Output buffer */
	int obufsize;		/* Output buffer size */
	unsigned char *optr;	/* Position in output buffer */
	int ocount;		/* Amount of data in output buffer */
	int odone;		/* deflate EOF */
	int comp_level;		/* Compression level to use */
	z_stream zout;		/* Output compression context */
	} BIO_ZLIB_CTX;

#define ZLIB_DEFAULT_BUFSIZE 1024

static int bio_zlib_new(BIO *bi);
static int bio_zlib_free(BIO *bi);
static int bio_zlib_read(BIO *b, char *out, int outl);
static int bio_zlib_write(BIO *b, const char *in, int inl);
static long bio_zlib_ctrl(BIO *b, int cmd, long num, void *ptr);
static long bio_zlib_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp);

static BIO_METHOD bio_meth_zlib = 
	{
	BIO_TYPE_COMP,
	"zlib",
	bio_zlib_write,
	bio_zlib_read,
	NULL,
	NULL,
	bio_zlib_ctrl,
	bio_zlib_new,
	bio_zlib_free,
	bio_zlib_callback_ctrl
	};

BIO_METHOD *BIO_f_zlib(void)
	{
	return &bio_meth_zlib;
	}


static int bio_zlib_new(BIO *bi)
	{
	BIO_ZLIB_CTX *ctx;
#ifdef ZLIB_SHARED
	(void)COMP_zlib();
	if (!zlib_loaded)
		{
		COMPerr(COMP_F_BIO_ZLIB_NEW, COMP_R_ZLIB_NOT_SUPPORTED);
		return 0;
		}
#endif
	ctx = OPENSSL_malloc(sizeof(BIO_ZLIB_CTX));
	if(!ctx)
		{
		COMPerr(COMP_F_BIO_ZLIB_NEW, ERR_R_MALLOC_FAILURE);
		return 0;
		}
	ctx->ibuf = NULL;
	ctx->obuf = NULL;
	ctx->ibufsize = ZLIB_DEFAULT_BUFSIZE;
	ctx->obufsize = ZLIB_DEFAULT_BUFSIZE;
	ctx->zin.zalloc = Z_NULL;
	ctx->zin.zfree = Z_NULL;
	ctx->zin.next_in = NULL;
	ctx->zin.avail_in = 0;
	ctx->zin.next_out = NULL;
	ctx->zin.avail_out = 0;
	ctx->zout.zalloc = Z_NULL;
	ctx->zout.zfree = Z_NULL;
	ctx->zout.next_in = NULL;
	ctx->zout.avail_in = 0;
	ctx->zout.next_out = NULL;
	ctx->zout.avail_out = 0;
	ctx->odone = 0;
	ctx->comp_level = Z_DEFAULT_COMPRESSION;
	bi->init = 1;
	bi->ptr = (char *)ctx;
	bi->flags = 0;
	return 1;
	}

static int bio_zlib_free(BIO *bi)
	{
	BIO_ZLIB_CTX *ctx;
	if(!bi) return 0;
	ctx = (BIO_ZLIB_CTX *)bi->ptr;
	if(ctx->ibuf)
		{
		/* Destroy decompress context */
		inflateEnd(&ctx->zin);
		OPENSSL_free(ctx->ibuf);
		}
	if(ctx->obuf)
		{
		/* Destroy compress context */
		deflateEnd(&ctx->zout);
		OPENSSL_free(ctx->obuf);
		}
	OPENSSL_free(ctx);
	bi->ptr = NULL;
	bi->init = 0;
	bi->flags = 0;
	return 1;
	}

static int bio_zlib_read(BIO *b, char *out, int outl)
	{
	BIO_ZLIB_CTX *ctx;
	int ret;
	z_stream *zin;
	if(!out || !outl) return 0;
	ctx = (BIO_ZLIB_CTX *)b->ptr;
	zin = &ctx->zin;
	BIO_clear_retry_flags(b);
	if(!ctx->ibuf)
		{
		ctx->ibuf = OPENSSL_malloc(ctx->ibufsize);
		if(!ctx->ibuf)
			{
			COMPerr(COMP_F_BIO_ZLIB_READ, ERR_R_MALLOC_FAILURE);
			return 0;
			}
		inflateInit(zin);
		zin->next_in = ctx->ibuf;
		zin->avail_in = 0;
		}

	/* Copy output data directly to supplied buffer */
	zin->next_out = (unsigned char *)out;
	zin->avail_out = (unsigned int)outl;
	for(;;)
		{
		/* Decompress while data available */
		while(zin->avail_in)
			{
			ret = inflate(zin, 0);
			if((ret != Z_OK) && (ret != Z_STREAM_END))
				{
				COMPerr(COMP_F_BIO_ZLIB_READ,
						COMP_R_ZLIB_INFLATE_ERROR);
				ERR_add_error_data(2, "zlib error:",
							zError(ret));
				return 0;
				}
			/* If EOF or we've read everything then return */
			if((ret == Z_STREAM_END) || !zin->avail_out)
				return outl - zin->avail_out;
			}

		/* No data in input buffer try to read some in,
		 * if an error then return the total data read.
		 */
		ret = BIO_read(b->next_bio, ctx->ibuf, ctx->ibufsize);
		if(ret <= 0)
			{
			/* Total data read */
			int tot = outl - zin->avail_out;
			BIO_copy_next_retry(b);
			if(ret < 0) return (tot > 0) ? tot : ret;
			return tot;
			}
		zin->avail_in = ret;
		zin->next_in = ctx->ibuf;
		}
	}

static int bio_zlib_write(BIO *b, const char *in, int inl)
	{
	BIO_ZLIB_CTX *ctx;
	int ret;
	z_stream *zout;
	if(!in || !inl) return 0;
	ctx = (BIO_ZLIB_CTX *)b->ptr;
	if(ctx->odone) return 0;
	zout = &ctx->zout;
	BIO_clear_retry_flags(b);
	if(!ctx->obuf)
		{
		ctx->obuf = OPENSSL_malloc(ctx->obufsize);
		/* Need error here */
		if(!ctx->obuf)
			{
			COMPerr(COMP_F_BIO_ZLIB_WRITE, ERR_R_MALLOC_FAILURE);
			return 0;
			}
		ctx->optr = ctx->obuf;
		ctx->ocount = 0;
		deflateInit(zout, ctx->comp_level);
		zout->next_out = ctx->obuf;
		zout->avail_out = ctx->obufsize;
		}
	/* Obtain input data directly from supplied buffer */
	zout->next_in = (void *)in;
	zout->avail_in = inl;
	for(;;)
		{
		/* If data in output buffer write it first */
		while(ctx->ocount) {
			ret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);
			if(ret <= 0)
				{
				/* Total data written */
				int tot = inl - zout->avail_in;
				BIO_copy_next_retry(b);
				if(ret < 0) return (tot > 0) ? tot : ret;
				return tot;
				}
			ctx->optr += ret;
			ctx->ocount -= ret;
		}

		/* Have we consumed all supplied data? */
		if(!zout->avail_in)
			return inl;

		/* Compress some more */

		/* Reset buffer */
		ctx->optr = ctx->obuf;
		zout->next_out = ctx->obuf;
		zout->avail_out = ctx->obufsize;
		/* Compress some more */
		ret = deflate(zout, 0);
		if(ret != Z_OK)
			{
			COMPerr(COMP_F_BIO_ZLIB_WRITE,
						COMP_R_ZLIB_DEFLATE_ERROR);
			ERR_add_error_data(2, "zlib error:", zError(ret));
			return 0;
			}
		ctx->ocount = ctx->obufsize - zout->avail_out;
		}
	}

static int bio_zlib_flush(BIO *b)
	{
	BIO_ZLIB_CTX *ctx;
	int ret;
	z_stream *zout;
	ctx = (BIO_ZLIB_CTX *)b->ptr;
	/* If no data written or already flush show success */
	if(!ctx->obuf || (ctx->odone && !ctx->ocount)) return 1;
	zout = &ctx->zout;
	BIO_clear_retry_flags(b);
	/* No more input data */
	zout->next_in = NULL;
	zout->avail_in = 0;
	for(;;)
		{
		/* If data in output buffer write it first */
		while(ctx->ocount)
			{
			ret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);
			if(ret <= 0)
				{
				BIO_copy_next_retry(b);
				return ret;
				}
			ctx->optr += ret;
			ctx->ocount -= ret;
			}
		if(ctx->odone) return 1;

		/* Compress some more */

		/* Reset buffer */
		ctx->optr = ctx->obuf;
		zout->next_out = ctx->obuf;
		zout->avail_out = ctx->obufsize;
		/* Compress some more */
		ret = deflate(zout, Z_FINISH);
		if(ret == Z_STREAM_END) ctx->odone = 1;
		else if(ret != Z_OK)
			{
			COMPerr(COMP_F_BIO_ZLIB_FLUSH,
						COMP_R_ZLIB_DEFLATE_ERROR);
			ERR_add_error_data(2, "zlib error:", zError(ret));
			return 0;
			}
		ctx->ocount = ctx->obufsize - zout->avail_out;
		}
	}

static long bio_zlib_ctrl(BIO *b, int cmd, long num, void *ptr)
	{
	BIO_ZLIB_CTX *ctx;
	int ret, *ip;
	int ibs, obs;
	if(!b->next_bio) return 0;
	ctx = (BIO_ZLIB_CTX *)b->ptr;
	switch (cmd)
		{

	case BIO_CTRL_RESET:
		ctx->ocount = 0;
		ctx->odone = 0;
		break;

	case BIO_CTRL_FLUSH:
		ret = bio_zlib_flush(b);
		if (ret > 0)
			ret = BIO_flush(b->next_bio);
		break;

	case BIO_C_SET_BUFF_SIZE:
		ibs = -1;
		obs = -1;
		if (ptr != NULL)
			{
			ip = ptr;
			if (*ip == 0)
				ibs = (int) num;
			else 
				obs = (int) num;
			}
		else
			{
			ibs = (int)num;
			obs = ibs;
			}

		if (ibs != -1)
			{
			if (ctx->ibuf)
				{
				OPENSSL_free(ctx->ibuf);
				ctx->ibuf = NULL;
				}
			ctx->ibufsize = ibs;
			}

		if (obs != -1)
			{
			if (ctx->obuf)
				{
				OPENSSL_free(ctx->obuf);
				ctx->obuf = NULL;
				}
			ctx->obufsize = obs;
			}

		break;

	case BIO_C_DO_STATE_MACHINE:
		BIO_clear_retry_flags(b);
		ret = BIO_ctrl(b->next_bio, cmd, num, ptr);
		BIO_copy_next_retry(b);
		break;

	default:
		ret = BIO_ctrl(b->next_bio, cmd, num, ptr);
		break;

		}

	return ret;
	}


static long bio_zlib_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)
	{
	if(!b->next_bio)
		return 0;
	return
		BIO_callback_ctrl(b->next_bio, cmd, fp);
	}

#endif
@


1.1.1.6
log
@import openssl-0.9.8j
@
text
@a729 1
		ret = 1;
d774 1
a774 1
		ret = 1;
d786 1
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d139 9
a190 6
	struct zlib_state *state =
		(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,
			zlib_stateful_ex_idx);
	inflateEnd(&state->istream);
	deflateEnd(&state->ostream);
	OPENSSL_free(state);
d405 1
a405 1
						0,NULL,NULL,NULL,NULL);
a786 1

@


