head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.2
	OPENBSD_6_1_BASE:1.31;
locks; strict;
comment	@ * @;


1.31
date	2015.07.19.22.34.27;	author doug;	state Exp;
branches;
next	1.30;
commitid	ayrDDFJT2T84Q0hD;

1.30
date	2014.10.18.17.20.40;	author jsing;	state Exp;
branches;
next	1.29;
commitid	8tb4v3IC8S2vzfHj;

1.29
date	2014.06.22.12.16.28;	author jsing;	state Exp;
branches;
next	1.28;
commitid	cDNLjNGuVSosCFRr;

1.28
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	mJUVYpkFBZ0Zv2bG;

1.27
date	2014.06.10.16.15.19;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	i7ofdog6OmjCcKaT;

1.26
date	2014.06.02.15.08.38;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	tWDKJg0nrCJLQhsu;

1.25
date	2014.05.22.17.53.00;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.15.18.02.05;	author reyk;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.14.16.49.10;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.14.14.56.01;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.14.10.03.00;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.14.09.36.26;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.13.23.50.02;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.13.19.04.55;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.13.18.50.36;	author reyk;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.13.18.31.41;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.13.18.12.23;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.13.17.48.39;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.13.17.29.41;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.01.17.44.20;	author thib;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.15.02.29.13;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.15.02.57.35;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.19;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.09;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.11.21.14.40;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.41;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.01.09.12.13.55;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.07;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2011.11.03.02.32.11;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.40;	author djm;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Remove OpenSSL engine RSAX.

OpenSSL stopped building it last year and removed it this year.
Based on OpenSSL commit c436e05bdc7f49985a750df64122c960240b3ae1.

Also cranked major version in libcrypto, libssl and libtls.

"fine with me" bcook@@ miod@@
@
text
@/* $OpenBSD: engine.h,v 1.30 2014/10/18 17:20:40 jsing Exp $ */
/* Written by Geoff Thorpe (geoff@@geoffthorpe.net) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECDH support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */

#ifndef HEADER_ENGINE_H
#define HEADER_ENGINE_H

#include <openssl/opensslconf.h>

#ifdef OPENSSL_NO_ENGINE
#error ENGINE is disabled.
#endif

#ifndef OPENSSL_NO_DEPRECATED
#include <openssl/bn.h>
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
#ifndef OPENSSL_NO_ECDH
#include <openssl/ecdh.h>
#endif
#ifndef OPENSSL_NO_ECDSA
#include <openssl/ecdsa.h>
#endif
#include <openssl/ui.h>
#include <openssl/err.h>
#endif

#include <openssl/ossl_typ.h>

#include <openssl/x509.h>

#ifdef  __cplusplus
extern "C" {
#endif

/* These flags are used to control combinations of algorithm (methods)
 * by bitwise "OR"ing. */
#define ENGINE_METHOD_RSA		(unsigned int)0x0001
#define ENGINE_METHOD_DSA		(unsigned int)0x0002
#define ENGINE_METHOD_DH		(unsigned int)0x0004
#define ENGINE_METHOD_RAND		(unsigned int)0x0008
#define ENGINE_METHOD_ECDH		(unsigned int)0x0010
#define ENGINE_METHOD_ECDSA		(unsigned int)0x0020
#define ENGINE_METHOD_CIPHERS		(unsigned int)0x0040
#define ENGINE_METHOD_DIGESTS		(unsigned int)0x0080
#define ENGINE_METHOD_STORE		(unsigned int)0x0100
#define ENGINE_METHOD_PKEY_METHS	(unsigned int)0x0200
#define ENGINE_METHOD_PKEY_ASN1_METHS	(unsigned int)0x0400
/* Obvious all-or-nothing cases. */
#define ENGINE_METHOD_ALL		(unsigned int)0xFFFF
#define ENGINE_METHOD_NONE		(unsigned int)0x0000

/* This(ese) flag(s) controls behaviour of the ENGINE_TABLE mechanism used
 * internally to control registration of ENGINE implementations, and can be set
 * by ENGINE_set_table_flags(). The "NOINIT" flag prevents attempts to
 * initialise registered ENGINEs if they are not already initialised. */
#define ENGINE_TABLE_FLAG_NOINIT	(unsigned int)0x0001

/* ENGINE flags that can be set by ENGINE_set_flags(). */
/* #define ENGINE_FLAGS_MALLOCED	0x0001 */ /* Not used */

/* This flag is for ENGINEs that wish to handle the various 'CMD'-related
 * control commands on their own. Without this flag, ENGINE_ctrl() handles these
 * control commands on behalf of the ENGINE using their "cmd_defns" data. */
#define ENGINE_FLAGS_MANUAL_CMD_CTRL	(int)0x0002

/* This flag is for ENGINEs who return new duplicate structures when found via
 * "ENGINE_by_id()". When an ENGINE must store state (eg. if ENGINE_ctrl()
 * commands are called in sequence as part of some stateful process like
 * key-generation setup and execution), it can set this flag - then each attempt
 * to obtain the ENGINE will result in it being copied into a new structure.
 * Normally, ENGINEs don't declare this flag so ENGINE_by_id() just increments
 * the existing ENGINE's structural reference count. */
#define ENGINE_FLAGS_BY_ID_COPY		(int)0x0004

/* This flag if for an ENGINE that does not want its methods registered as
 * part of ENGINE_register_all_complete() for example if the methods are
 * not usable as default methods.
 */

#define ENGINE_FLAGS_NO_REGISTER_ALL	(int)0x0008

/* ENGINEs can support their own command types, and these flags are used in
 * ENGINE_CTRL_GET_CMD_FLAGS to indicate to the caller what kind of input each
 * command expects. Currently only numeric and string input is supported. If a
 * control command supports none of the _NUMERIC, _STRING, or _NO_INPUT options,
 * then it is regarded as an "internal" control command - and not for use in
 * config setting situations. As such, they're not available to the
 * ENGINE_ctrl_cmd_string() function, only raw ENGINE_ctrl() access. Changes to
 * this list of 'command types' should be reflected carefully in
 * ENGINE_cmd_is_executable() and ENGINE_ctrl_cmd_string(). */

/* accepts a 'long' input value (3rd parameter to ENGINE_ctrl) */
#define ENGINE_CMD_FLAG_NUMERIC		(unsigned int)0x0001
/* accepts string input (cast from 'void*' to 'const char *', 4th parameter to
 * ENGINE_ctrl) */
#define ENGINE_CMD_FLAG_STRING		(unsigned int)0x0002
/* Indicates that the control command takes *no* input. Ie. the control command
 * is unparameterised. */
#define ENGINE_CMD_FLAG_NO_INPUT	(unsigned int)0x0004
/* Indicates that the control command is internal. This control command won't
 * be shown in any output, and is only usable through the ENGINE_ctrl_cmd()
 * function. */
#define ENGINE_CMD_FLAG_INTERNAL	(unsigned int)0x0008

/* NB: These 3 control commands are deprecated and should not be used. ENGINEs
 * relying on these commands should compile conditional support for
 * compatibility (eg. if these symbols are defined) but should also migrate the
 * same functionality to their own ENGINE-specific control functions that can be
 * "discovered" by calling applications. The fact these control commands
 * wouldn't be "executable" (ie. usable by text-based config) doesn't change the
 * fact that application code can find and use them without requiring per-ENGINE
 * hacking. */

/* These flags are used to tell the ctrl function what should be done.
 * All command numbers are shared between all engines, even if some don't
 * make sense to some engines.  In such a case, they do nothing but return
 * the error ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED. */
#define ENGINE_CTRL_SET_LOGSTREAM		1
#define ENGINE_CTRL_SET_PASSWORD_CALLBACK	2
#define ENGINE_CTRL_HUP				3 /* Close and reinitialise any
						     handles/connections etc. */
#define ENGINE_CTRL_SET_USER_INTERFACE          4 /* Alternative to callback */
#define ENGINE_CTRL_SET_CALLBACK_DATA           5 /* User-specific data, used
						     when calling the password
						     callback and the user
						     interface */
#define ENGINE_CTRL_LOAD_CONFIGURATION		6 /* Load a configuration, given
						     a string that represents a
						     file name or so */
#define ENGINE_CTRL_LOAD_SECTION		7 /* Load data from a given
						     section in the already loaded
						     configuration */

/* These control commands allow an application to deal with an arbitrary engine
 * in a dynamic way. Warn: Negative return values indicate errors FOR THESE
 * COMMANDS because zero is used to indicate 'end-of-list'. Other commands,
 * including ENGINE-specific command types, return zero for an error.
 *
 * An ENGINE can choose to implement these ctrl functions, and can internally
 * manage things however it chooses - it does so by setting the
 * ENGINE_FLAGS_MANUAL_CMD_CTRL flag (using ENGINE_set_flags()). Otherwise the
 * ENGINE_ctrl() code handles this on the ENGINE's behalf using the cmd_defns
 * data (set using ENGINE_set_cmd_defns()). This means an ENGINE's ctrl()
 * handler need only implement its own commands - the above "meta" commands will
 * be taken care of. */

/* Returns non-zero if the supplied ENGINE has a ctrl() handler. If "not", then
 * all the remaining control commands will return failure, so it is worth
 * checking this first if the caller is trying to "discover" the engine's
 * capabilities and doesn't want errors generated unnecessarily. */
#define ENGINE_CTRL_HAS_CTRL_FUNCTION		10
/* Returns a positive command number for the first command supported by the
 * engine. Returns zero if no ctrl commands are supported. */
#define ENGINE_CTRL_GET_FIRST_CMD_TYPE		11
/* The 'long' argument specifies a command implemented by the engine, and the
 * return value is the next command supported, or zero if there are no more. */
#define ENGINE_CTRL_GET_NEXT_CMD_TYPE		12
/* The 'void*' argument is a command name (cast from 'const char *'), and the
 * return value is the command that corresponds to it. */
#define ENGINE_CTRL_GET_CMD_FROM_NAME		13
/* The next two allow a command to be converted into its corresponding string
 * form. In each case, the 'long' argument supplies the command. In the NAME_LEN
 * case, the return value is the length of the command name (not counting a
 * trailing EOL). In the NAME case, the 'void*' argument must be a string buffer
 * large enough, and it will be populated with the name of the command (WITH a
 * trailing EOL). */
#define ENGINE_CTRL_GET_NAME_LEN_FROM_CMD	14
#define ENGINE_CTRL_GET_NAME_FROM_CMD		15
/* The next two are similar but give a "short description" of a command. */
#define ENGINE_CTRL_GET_DESC_LEN_FROM_CMD	16
#define ENGINE_CTRL_GET_DESC_FROM_CMD		17
/* With this command, the return value is the OR'd combination of
 * ENGINE_CMD_FLAG_*** values that indicate what kind of input a given
 * engine-specific ctrl command expects. */
#define ENGINE_CTRL_GET_CMD_FLAGS		18

/* ENGINE implementations should start the numbering of their own control
 * commands from this value. (ie. ENGINE_CMD_BASE, ENGINE_CMD_BASE + 1, etc). */
#define ENGINE_CMD_BASE				200

/* If an ENGINE supports its own specific control commands and wishes the
 * framework to handle the above 'ENGINE_CMD_***'-manipulation commands on its
 * behalf, it should supply a null-terminated array of ENGINE_CMD_DEFN entries
 * to ENGINE_set_cmd_defns(). It should also implement a ctrl() handler that
 * supports the stated commands (ie. the "cmd_num" entries as described by the
 * array). NB: The array must be ordered in increasing order of cmd_num.
 * "null-terminated" means that the last ENGINE_CMD_DEFN element has cmd_num set
 * to zero and/or cmd_name set to NULL. */
typedef struct ENGINE_CMD_DEFN_st {
	unsigned int cmd_num; /* The command number */
	const char *cmd_name; /* The command name itself */
	const char *cmd_desc; /* A short description of the command */
	unsigned int cmd_flags; /* The input the command expects */
} ENGINE_CMD_DEFN;

/* Generic function pointer */
typedef int (*ENGINE_GEN_FUNC_PTR)(void);
/* Generic function pointer taking no arguments */
typedef int (*ENGINE_GEN_INT_FUNC_PTR)(ENGINE *);
/* Specific control function pointer */
typedef int (*ENGINE_CTRL_FUNC_PTR)(ENGINE *, int, long, void *,
    void (*f)(void));
/* Generic load_key function pointer */
typedef EVP_PKEY * (*ENGINE_LOAD_KEY_PTR)(ENGINE *, const char *,
    UI_METHOD *ui_method, void *callback_data);
typedef int (*ENGINE_SSL_CLIENT_CERT_PTR)(ENGINE *, SSL *ssl,
    STACK_OF(X509_NAME) *ca_dn, X509 **pcert, EVP_PKEY **pkey,
    STACK_OF(X509) **pother, UI_METHOD *ui_method, void *callback_data);

/* These callback types are for an ENGINE's handler for cipher and digest logic.
 * These handlers have these prototypes;
 *   int foo(ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid);
 *   int foo(ENGINE *e, const EVP_MD **digest, const int **nids, int nid);
 * Looking at how to implement these handlers in the case of cipher support, if
 * the framework wants the EVP_CIPHER for 'nid', it will call;
 *   foo(e, &p_evp_cipher, NULL, nid);    (return zero for failure)
 * If the framework wants a list of supported 'nid's, it will call;
 *   foo(e, NULL, &p_nids, 0); (returns number of 'nids' or -1 for error)
 */
/* Returns to a pointer to the array of supported cipher 'nid's. If the second
 * parameter is non-NULL it is set to the size of the returned array. */
typedef int (*ENGINE_CIPHERS_PTR)(ENGINE *, const EVP_CIPHER **,
    const int **, int);
typedef int (*ENGINE_DIGESTS_PTR)(ENGINE *, const EVP_MD **, const int **, int);
typedef int (*ENGINE_PKEY_METHS_PTR)(ENGINE *, EVP_PKEY_METHOD **,
    const int **, int);
typedef int (*ENGINE_PKEY_ASN1_METHS_PTR)(ENGINE *, EVP_PKEY_ASN1_METHOD **,
    const int **, int);

/* STRUCTURE functions ... all of these functions deal with pointers to ENGINE
 * structures where the pointers have a "structural reference". This means that
 * their reference is to allowed access to the structure but it does not imply
 * that the structure is functional. To simply increment or decrement the
 * structural reference count, use ENGINE_by_id and ENGINE_free. NB: This is not
 * required when iterating using ENGINE_get_next as it will automatically
 * decrement the structural reference count of the "current" ENGINE and
 * increment the structural reference count of the ENGINE it returns (unless it
 * is NULL). */

/* Get the first/last "ENGINE" type available. */
ENGINE *ENGINE_get_first(void);
ENGINE *ENGINE_get_last(void);
/* Iterate to the next/previous "ENGINE" type (NULL = end of the list). */
ENGINE *ENGINE_get_next(ENGINE *e);
ENGINE *ENGINE_get_prev(ENGINE *e);
/* Add another "ENGINE" type into the array. */
int ENGINE_add(ENGINE *e);
/* Remove an existing "ENGINE" type from the array. */
int ENGINE_remove(ENGINE *e);
/* Retrieve an engine from the list by its unique "id" value. */
ENGINE *ENGINE_by_id(const char *id);
/* Add all the built-in engines. */
void ENGINE_load_openssl(void);
void ENGINE_load_dynamic(void);
#ifndef OPENSSL_NO_STATIC_ENGINE
void ENGINE_load_padlock(void);
#endif
void ENGINE_load_builtin_engines(void);

/* Get and set global flags (ENGINE_TABLE_FLAG_***) for the implementation
 * "registry" handling. */
unsigned int ENGINE_get_table_flags(void);
void ENGINE_set_table_flags(unsigned int flags);

/* Manage registration of ENGINEs per "table". For each type, there are 3
 * functions;
 *   ENGINE_register_***(e) - registers the implementation from 'e' (if it has one)
 *   ENGINE_unregister_***(e) - unregister the implementation from 'e'
 *   ENGINE_register_all_***() - call ENGINE_register_***() for each 'e' in the list
 * Cleanup is automatically registered from each table when required, so
 * ENGINE_cleanup() will reverse any "register" operations. */

int ENGINE_register_RSA(ENGINE *e);
void ENGINE_unregister_RSA(ENGINE *e);
void ENGINE_register_all_RSA(void);

int ENGINE_register_DSA(ENGINE *e);
void ENGINE_unregister_DSA(ENGINE *e);
void ENGINE_register_all_DSA(void);

int ENGINE_register_ECDH(ENGINE *e);
void ENGINE_unregister_ECDH(ENGINE *e);
void ENGINE_register_all_ECDH(void);

int ENGINE_register_ECDSA(ENGINE *e);
void ENGINE_unregister_ECDSA(ENGINE *e);
void ENGINE_register_all_ECDSA(void);

int ENGINE_register_DH(ENGINE *e);
void ENGINE_unregister_DH(ENGINE *e);
void ENGINE_register_all_DH(void);

int ENGINE_register_RAND(ENGINE *e);
void ENGINE_unregister_RAND(ENGINE *e);
void ENGINE_register_all_RAND(void);

int ENGINE_register_STORE(ENGINE *e);
void ENGINE_unregister_STORE(ENGINE *e);
void ENGINE_register_all_STORE(void);

int ENGINE_register_ciphers(ENGINE *e);
void ENGINE_unregister_ciphers(ENGINE *e);
void ENGINE_register_all_ciphers(void);

int ENGINE_register_digests(ENGINE *e);
void ENGINE_unregister_digests(ENGINE *e);
void ENGINE_register_all_digests(void);

int ENGINE_register_pkey_meths(ENGINE *e);
void ENGINE_unregister_pkey_meths(ENGINE *e);
void ENGINE_register_all_pkey_meths(void);

int ENGINE_register_pkey_asn1_meths(ENGINE *e);
void ENGINE_unregister_pkey_asn1_meths(ENGINE *e);
void ENGINE_register_all_pkey_asn1_meths(void);

/* These functions register all support from the above categories. Note, use of
 * these functions can result in static linkage of code your application may not
 * need. If you only need a subset of functionality, consider using more
 * selective initialisation. */
int ENGINE_register_complete(ENGINE *e);
int ENGINE_register_all_complete(void);

/* Send parametrised control commands to the engine. The possibilities to send
 * down an integer, a pointer to data or a function pointer are provided. Any of
 * the parameters may or may not be NULL, depending on the command number. In
 * actuality, this function only requires a structural (rather than functional)
 * reference to an engine, but many control commands may require the engine be
 * functional. The caller should be aware of trying commands that require an
 * operational ENGINE, and only use functional references in such situations. */
int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void));

/* This function tests if an ENGINE-specific command is usable as a "setting".
 * Eg. in an application's config file that gets processed through
 * ENGINE_ctrl_cmd_string(). If this returns zero, it is not available to
 * ENGINE_ctrl_cmd_string(), only ENGINE_ctrl(). */
int ENGINE_cmd_is_executable(ENGINE *e, int cmd);

/* This function works like ENGINE_ctrl() with the exception of taking a
 * command name instead of a command number, and can handle optional commands.
 * See the comment on ENGINE_ctrl_cmd_string() for an explanation on how to
 * use the cmd_name and cmd_optional. */
int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,
    long i, void *p, void (*f)(void), int cmd_optional);

/* This function passes a command-name and argument to an ENGINE. The cmd_name
 * is converted to a command number and the control command is called using
 * 'arg' as an argument (unless the ENGINE doesn't support such a command, in
 * which case no control command is called). The command is checked for input
 * flags, and if necessary the argument will be converted to a numeric value. If
 * cmd_optional is non-zero, then if the ENGINE doesn't support the given
 * cmd_name the return value will be success anyway. This function is intended
 * for applications to use so that users (or config files) can supply
 * engine-specific config data to the ENGINE at run-time to control behaviour of
 * specific engines. As such, it shouldn't be used for calling ENGINE_ctrl()
 * functions that return data, deal with binary data, or that are otherwise
 * supposed to be used directly through ENGINE_ctrl() in application code. Any
 * "return" data from an ENGINE_ctrl() operation in this function will be lost -
 * the return value is interpreted as failure if the return value is zero,
 * success otherwise, and this function returns a boolean value as a result. In
 * other words, vendors of 'ENGINE'-enabled devices should write ENGINE
 * implementations with parameterisations that work in this scheme, so that
 * compliant ENGINE-based applications can work consistently with the same
 * configuration for the same ENGINE-enabled devices, across applications. */
int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
    int cmd_optional);

/* These functions are useful for manufacturing new ENGINE structures. They
 * don't address reference counting at all - one uses them to populate an ENGINE
 * structure with personalised implementations of things prior to using it
 * directly or adding it to the builtin ENGINE list in OpenSSL. These are also
 * here so that the ENGINE structure doesn't have to be exposed and break binary
 * compatibility! */
ENGINE *ENGINE_new(void);
int ENGINE_free(ENGINE *e);
int ENGINE_up_ref(ENGINE *e);
int ENGINE_set_id(ENGINE *e, const char *id);
int ENGINE_set_name(ENGINE *e, const char *name);
int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);
int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);
int ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *ecdh_meth);
int ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *ecdsa_meth);
int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);
int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);
int ENGINE_set_STORE(ENGINE *e, const STORE_METHOD *store_meth);
int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f);
int ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f);
int ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f);
int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f);
int ENGINE_set_load_privkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpriv_f);
int ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f);
int ENGINE_set_load_ssl_client_cert_function(ENGINE *e,
    ENGINE_SSL_CLIENT_CERT_PTR loadssl_f);
int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);
int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);
int ENGINE_set_pkey_meths(ENGINE *e, ENGINE_PKEY_METHS_PTR f);
int ENGINE_set_pkey_asn1_meths(ENGINE *e, ENGINE_PKEY_ASN1_METHS_PTR f);
int ENGINE_set_flags(ENGINE *e, int flags);
int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns);
/* These functions allow control over any per-structure ENGINE data. */
int ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg);
void *ENGINE_get_ex_data(const ENGINE *e, int idx);

/* This function cleans up anything that needs it. Eg. the ENGINE_add() function
 * automatically ensures the list cleanup function is registered to be called
 * from ENGINE_cleanup(). Similarly, all ENGINE_register_*** functions ensure
 * ENGINE_cleanup() will clean up after them. */
void ENGINE_cleanup(void);

/* These return values from within the ENGINE structure. These can be useful
 * with functional references as well as structural references - it depends
 * which you obtained. Using the result for functional purposes if you only
 * obtained a structural reference may be problematic! */
const char *ENGINE_get_id(const ENGINE *e);
const char *ENGINE_get_name(const ENGINE *e);
const RSA_METHOD *ENGINE_get_RSA(const ENGINE *e);
const DSA_METHOD *ENGINE_get_DSA(const ENGINE *e);
const ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *e);
const ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *e);
const DH_METHOD *ENGINE_get_DH(const ENGINE *e);
const RAND_METHOD *ENGINE_get_RAND(const ENGINE *e);
const STORE_METHOD *ENGINE_get_STORE(const ENGINE *e);
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e);
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e);
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e);
ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e);
ENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e);
ENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e);
ENGINE_SSL_CLIENT_CERT_PTR ENGINE_get_ssl_client_cert_function(const ENGINE *e);
ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e);
ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e);
ENGINE_PKEY_METHS_PTR ENGINE_get_pkey_meths(const ENGINE *e);
ENGINE_PKEY_ASN1_METHS_PTR ENGINE_get_pkey_asn1_meths(const ENGINE *e);
const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);
const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid);
const EVP_PKEY_METHOD *ENGINE_get_pkey_meth(ENGINE *e, int nid);
const EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth(ENGINE *e, int nid);
const EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth_str(ENGINE *e,
    const char *str, int len);
const EVP_PKEY_ASN1_METHOD *ENGINE_pkey_asn1_find_str(ENGINE **pe,
    const char *str, int len);
const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e);
int ENGINE_get_flags(const ENGINE *e);

/* FUNCTIONAL functions. These functions deal with ENGINE structures
 * that have (or will) be initialised for use. Broadly speaking, the
 * structural functions are useful for iterating the list of available
 * engine types, creating new engine types, and other "list" operations.
 * These functions actually deal with ENGINEs that are to be used. As
 * such these functions can fail (if applicable) when particular
 * engines are unavailable - eg. if a hardware accelerator is not
 * attached or not functioning correctly. Each ENGINE has 2 reference
 * counts; structural and functional. Every time a functional reference
 * is obtained or released, a corresponding structural reference is
 * automatically obtained or released too. */

/* Initialise a engine type for use (or up its reference count if it's
 * already in use). This will fail if the engine is not currently
 * operational and cannot initialise. */
int ENGINE_init(ENGINE *e);
/* Free a functional reference to a engine type. This does not require
 * a corresponding call to ENGINE_free as it also releases a structural
 * reference. */
int ENGINE_finish(ENGINE *e);

/* The following functions handle keys that are stored in some secondary
 * location, handled by the engine.  The storage may be on a card or
 * whatever. */
EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,
    UI_METHOD *ui_method, void *callback_data);
EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,
    UI_METHOD *ui_method, void *callback_data);
int ENGINE_load_ssl_client_cert(ENGINE *e, SSL *s,
    STACK_OF(X509_NAME) *ca_dn, X509 **pcert, EVP_PKEY **ppkey,
    STACK_OF(X509) **pother,
    UI_METHOD *ui_method, void *callback_data);

/* This returns a pointer for the current ENGINE structure that
 * is (by default) performing any RSA operations. The value returned
 * is an incremented reference, so it should be free'd (ENGINE_finish)
 * before it is discarded. */
ENGINE *ENGINE_get_default_RSA(void);
/* Same for the other "methods" */
ENGINE *ENGINE_get_default_DSA(void);
ENGINE *ENGINE_get_default_ECDH(void);
ENGINE *ENGINE_get_default_ECDSA(void);
ENGINE *ENGINE_get_default_DH(void);
ENGINE *ENGINE_get_default_RAND(void);
/* These functions can be used to get a functional reference to perform
 * ciphering or digesting corresponding to "nid". */
ENGINE *ENGINE_get_cipher_engine(int nid);
ENGINE *ENGINE_get_digest_engine(int nid);
ENGINE *ENGINE_get_pkey_meth_engine(int nid);
ENGINE *ENGINE_get_pkey_asn1_meth_engine(int nid);

/* This sets a new default ENGINE structure for performing RSA
 * operations. If the result is non-zero (success) then the ENGINE
 * structure will have had its reference count up'd so the caller
 * should still free their own reference 'e'. */
int ENGINE_set_default_RSA(ENGINE *e);
int ENGINE_set_default_string(ENGINE *e, const char *def_list);
/* Same for the other "methods" */
int ENGINE_set_default_DSA(ENGINE *e);
int ENGINE_set_default_ECDH(ENGINE *e);
int ENGINE_set_default_ECDSA(ENGINE *e);
int ENGINE_set_default_DH(ENGINE *e);
int ENGINE_set_default_RAND(ENGINE *e);
int ENGINE_set_default_ciphers(ENGINE *e);
int ENGINE_set_default_digests(ENGINE *e);
int ENGINE_set_default_pkey_meths(ENGINE *e);
int ENGINE_set_default_pkey_asn1_meths(ENGINE *e);

/* The combination "set" - the flags are bitwise "OR"d from the
 * ENGINE_METHOD_*** defines above. As with the "ENGINE_register_complete()"
 * function, this function can result in unnecessary static linkage. If your
 * application requires only specific functionality, consider using more
 * selective functions. */
int ENGINE_set_default(ENGINE *e, unsigned int flags);

void ENGINE_add_conf_module(void);

/* Deprecated functions ... */
/* int ENGINE_clear_defaults(void); */

/**************************/
/* DYNAMIC ENGINE SUPPORT */
/**************************/

/* Binary/behaviour compatibility levels */
#define OSSL_DYNAMIC_VERSION		(unsigned long)0x00020000
/* Binary versions older than this are too old for us (whether we're a loader or
 * a loadee) */
#define OSSL_DYNAMIC_OLDEST		(unsigned long)0x00020000

/* When compiling an ENGINE entirely as an external shared library, loadable by
 * the "dynamic" ENGINE, these types are needed. The 'dynamic_fns' structure
 * type provides the calling application's (or library's) error functionality
 * and memory management function pointers to the loaded library. These should
 * be used/set in the loaded library code so that the loading application's
 * 'state' will be used/changed in all operations. The 'static_state' pointer
 * allows the loaded library to know if it shares the same static data as the
 * calling application (or library), and thus whether these callbacks need to be
 * set or not. */
typedef void *(*dyn_MEM_malloc_cb)(size_t);
typedef void *(*dyn_MEM_realloc_cb)(void *, size_t);
typedef void (*dyn_MEM_free_cb)(void *);
typedef struct st_dynamic_MEM_fns {
	dyn_MEM_malloc_cb			malloc_cb;
	dyn_MEM_realloc_cb			realloc_cb;
	dyn_MEM_free_cb				free_cb;
} dynamic_MEM_fns;
/* FIXME: Perhaps the memory and locking code (crypto.h) should declare and use
 * these types so we (and any other dependant code) can simplify a bit?? */
typedef void (*dyn_lock_locking_cb)(int, int, const char *, int);
typedef int (*dyn_lock_add_lock_cb)(int*, int, int, const char *, int);
typedef struct CRYPTO_dynlock_value *(*dyn_dynlock_create_cb)(
    const char *, int);
typedef void (*dyn_dynlock_lock_cb)(int, struct CRYPTO_dynlock_value *,
    const char *, int);
typedef void (*dyn_dynlock_destroy_cb)(struct CRYPTO_dynlock_value *,
    const char *, int);
typedef struct st_dynamic_LOCK_fns {
	dyn_lock_locking_cb			lock_locking_cb;
	dyn_lock_add_lock_cb			lock_add_lock_cb;
	dyn_dynlock_create_cb			dynlock_create_cb;
	dyn_dynlock_lock_cb			dynlock_lock_cb;
	dyn_dynlock_destroy_cb			dynlock_destroy_cb;
} dynamic_LOCK_fns;
/* The top-level structure */
typedef struct st_dynamic_fns {
	void 					*static_state;
	const ERR_FNS				*err_fns;
	const CRYPTO_EX_DATA_IMPL		*ex_data_fns;
	dynamic_MEM_fns				mem_fns;
	dynamic_LOCK_fns			lock_fns;
} dynamic_fns;

/* The version checking function should be of this prototype. NB: The
 * ossl_version value passed in is the OSSL_DYNAMIC_VERSION of the loading code.
 * If this function returns zero, it indicates a (potential) version
 * incompatibility and the loaded library doesn't believe it can proceed.
 * Otherwise, the returned value is the (latest) version supported by the
 * loading library. The loader may still decide that the loaded code's version
 * is unsatisfactory and could veto the load. The function is expected to
 * be implemented with the symbol name "v_check", and a default implementation
 * can be fully instantiated with IMPLEMENT_DYNAMIC_CHECK_FN(). */
typedef unsigned long (*dynamic_v_check_fn)(unsigned long ossl_version);
#define IMPLEMENT_DYNAMIC_CHECK_FN() \
	extern unsigned long v_check(unsigned long v); \
	extern unsigned long v_check(unsigned long v) { \
		if(v >= OSSL_DYNAMIC_OLDEST) return OSSL_DYNAMIC_VERSION; \
		return 0; }

/* This function is passed the ENGINE structure to initialise with its own
 * function and command settings. It should not adjust the structural or
 * functional reference counts. If this function returns zero, (a) the load will
 * be aborted, (b) the previous ENGINE state will be memcpy'd back onto the
 * structure, and (c) the shared library will be unloaded. So implementations
 * should do their own internal cleanup in failure circumstances otherwise they
 * could leak. The 'id' parameter, if non-NULL, represents the ENGINE id that
 * the loader is looking for. If this is NULL, the shared library can choose to
 * return failure or to initialise a 'default' ENGINE. If non-NULL, the shared
 * library must initialise only an ENGINE matching the passed 'id'. The function
 * is expected to be implemented with the symbol name "bind_engine". A standard
 * implementation can be instantiated with IMPLEMENT_DYNAMIC_BIND_FN(fn) where
 * the parameter 'fn' is a callback function that populates the ENGINE structure
 * and returns an int value (zero for failure). 'fn' should have prototype;
 *    [static] int fn(ENGINE *e, const char *id); */
typedef int (*dynamic_bind_engine)(ENGINE *e, const char *id,
    const dynamic_fns *fns);
#define IMPLEMENT_DYNAMIC_BIND_FN(fn) \
	extern \
	int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns); \
	extern \
	int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \
		if(ENGINE_get_static_state() == fns->static_state) goto skip_cbs; \
		if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, \
			fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) \
			return 0; \
		CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); \
		CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); \
		CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \
		CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \
		CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \
		if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \
			return 0; \
		if(!ERR_set_implementation(fns->err_fns)) return 0; \
	skip_cbs: \
		if(!fn(e,id)) return 0; \
		return 1; }

/* If the loading application (or library) and the loaded ENGINE library share
 * the same static data (eg. they're both dynamically linked to the same
 * libcrypto.so) we need a way to avoid trying to set system callbacks - this
 * would fail, and for the same reason that it's unnecessary to try. If the
 * loaded ENGINE has (or gets from through the loader) its own copy of the
 * libcrypto static data, we will need to set the callbacks. The easiest way to
 * detect this is to have a function that returns a pointer to some static data
 * and let the loading application and loaded ENGINE compare their respective
 * values. */
					void *ENGINE_get_static_state(void);

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_ENGINE_strings(void);

/* Error codes for the ENGINE functions. */

/* Function codes. */
#define ENGINE_F_DYNAMIC_CTRL				 180
#define ENGINE_F_DYNAMIC_GET_DATA_CTX			 181
#define ENGINE_F_DYNAMIC_LOAD				 182
#define ENGINE_F_DYNAMIC_SET_DATA_CTX			 183
#define ENGINE_F_ENGINE_ADD				 105
#define ENGINE_F_ENGINE_BY_ID				 106
#define ENGINE_F_ENGINE_CMD_IS_EXECUTABLE		 170
#define ENGINE_F_ENGINE_CTRL				 142
#define ENGINE_F_ENGINE_CTRL_CMD			 178
#define ENGINE_F_ENGINE_CTRL_CMD_STRING			 171
#define ENGINE_F_ENGINE_FINISH				 107
#define ENGINE_F_ENGINE_FREE_UTIL			 108
#define ENGINE_F_ENGINE_GET_CIPHER			 185
#define ENGINE_F_ENGINE_GET_DEFAULT_TYPE		 177
#define ENGINE_F_ENGINE_GET_DIGEST			 186
#define ENGINE_F_ENGINE_GET_NEXT			 115
#define ENGINE_F_ENGINE_GET_PKEY_ASN1_METH		 193
#define ENGINE_F_ENGINE_GET_PKEY_METH			 192
#define ENGINE_F_ENGINE_GET_PREV			 116
#define ENGINE_F_ENGINE_INIT				 119
#define ENGINE_F_ENGINE_LIST_ADD			 120
#define ENGINE_F_ENGINE_LIST_REMOVE			 121
#define ENGINE_F_ENGINE_LOAD_PRIVATE_KEY		 150
#define ENGINE_F_ENGINE_LOAD_PUBLIC_KEY			 151
#define ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT		 194
#define ENGINE_F_ENGINE_NEW				 122
#define ENGINE_F_ENGINE_REMOVE				 123
#define ENGINE_F_ENGINE_SET_DEFAULT_STRING		 189
#define ENGINE_F_ENGINE_SET_DEFAULT_TYPE		 126
#define ENGINE_F_ENGINE_SET_ID				 129
#define ENGINE_F_ENGINE_SET_NAME			 130
#define ENGINE_F_ENGINE_TABLE_REGISTER			 184
#define ENGINE_F_ENGINE_UNLOAD_KEY			 152
#define ENGINE_F_ENGINE_UNLOCKED_FINISH			 191
#define ENGINE_F_ENGINE_UP_REF				 190
#define ENGINE_F_INT_CTRL_HELPER			 172
#define ENGINE_F_INT_ENGINE_CONFIGURE			 188
#define ENGINE_F_INT_ENGINE_MODULE_INIT			 187
#define ENGINE_F_LOG_MESSAGE				 141

/* Reason codes. */
#define ENGINE_R_ALREADY_LOADED				 100
#define ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER		 133
#define ENGINE_R_CMD_NOT_EXECUTABLE			 134
#define ENGINE_R_COMMAND_TAKES_INPUT			 135
#define ENGINE_R_COMMAND_TAKES_NO_INPUT			 136
#define ENGINE_R_CONFLICTING_ENGINE_ID			 103
#define ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED		 119
#define ENGINE_R_DH_NOT_IMPLEMENTED			 139
#define ENGINE_R_DSA_NOT_IMPLEMENTED			 140
#define ENGINE_R_DSO_FAILURE				 104
#define ENGINE_R_DSO_NOT_FOUND				 132
#define ENGINE_R_ENGINES_SECTION_ERROR			 148
#define ENGINE_R_ENGINE_CONFIGURATION_ERROR		 102
#define ENGINE_R_ENGINE_IS_NOT_IN_LIST			 105
#define ENGINE_R_ENGINE_SECTION_ERROR			 149
#define ENGINE_R_FAILED_LOADING_PRIVATE_KEY		 128
#define ENGINE_R_FAILED_LOADING_PUBLIC_KEY		 129
#define ENGINE_R_FINISH_FAILED				 106
#define ENGINE_R_GET_HANDLE_FAILED			 107
#define ENGINE_R_ID_OR_NAME_MISSING			 108
#define ENGINE_R_INIT_FAILED				 109
#define ENGINE_R_INTERNAL_LIST_ERROR			 110
#define ENGINE_R_INVALID_ARGUMENT			 143
#define ENGINE_R_INVALID_CMD_NAME			 137
#define ENGINE_R_INVALID_CMD_NUMBER			 138
#define ENGINE_R_INVALID_INIT_VALUE			 151
#define ENGINE_R_INVALID_STRING				 150
#define ENGINE_R_NOT_INITIALISED			 117
#define ENGINE_R_NOT_LOADED				 112
#define ENGINE_R_NO_CONTROL_FUNCTION			 120
#define ENGINE_R_NO_INDEX				 144
#define ENGINE_R_NO_LOAD_FUNCTION			 125
#define ENGINE_R_NO_REFERENCE				 130
#define ENGINE_R_NO_SUCH_ENGINE				 116
#define ENGINE_R_NO_UNLOAD_FUNCTION			 126
#define ENGINE_R_PROVIDE_PARAMETERS			 113
#define ENGINE_R_RSA_NOT_IMPLEMENTED			 141
#define ENGINE_R_UNIMPLEMENTED_CIPHER			 146
#define ENGINE_R_UNIMPLEMENTED_DIGEST			 147
#define ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD	 101
#define ENGINE_R_VERSION_INCOMPATIBILITY		 145

#ifdef  __cplusplus
}
#endif
#endif
@


1.30
log
@None of these need to include <openssl/rand.h>
@
text
@d1 1
a1 1
/* $OpenBSD: engine.h,v 1.29 2014/06/22 12:16:28 jsing Exp $ */
a324 1
void ENGINE_load_rsax(void);
@


1.29
log
@KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: engine.h,v 1.28 2014/06/12 15:49:29 deraadt Exp $ */
a89 1
#include <openssl/rand.h>
@


1.28
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d60 1
a60 1
 * ECDH support in OpenSSL originally developed by 
d143 1
a143 1
/* This flag if for an ENGINE that does not want its methods registered as 
d257 1
a257 2
typedef struct ENGINE_CMD_DEFN_st
	{
d262 1
a262 1
	} ENGINE_CMD_DEFN;
d269 2
a270 1
typedef int (*ENGINE_CTRL_FUNC_PTR)(ENGINE *, int, long, void *, void (*f)(void));
d273 1
a273 1
	UI_METHOD *ui_method, void *callback_data);
d275 3
a277 2
	STACK_OF(X509_NAME) *ca_dn, X509 **pcert, EVP_PKEY **pkey,
	STACK_OF(X509) **pother, UI_METHOD *ui_method, void *callback_data);
d290 2
a291 1
typedef int (*ENGINE_CIPHERS_PTR)(ENGINE *, const EVP_CIPHER **, const int **, int);
d293 5
a297 2
typedef int (*ENGINE_PKEY_METHS_PTR)(ENGINE *, EVP_PKEY_METHOD **, const int **, int);
typedef int (*ENGINE_PKEY_ASN1_METHS_PTR)(ENGINE *, EVP_PKEY_ASN1_METHOD **, const int **, int);
d413 1
a413 1
        long i, void *p, void (*f)(void), int cmd_optional);
d435 1
a435 1
				int cmd_optional);
d462 1
a462 1
				ENGINE_SSL_CLIENT_CERT_PTR loadssl_f);
d471 1
a471 1
		CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
d510 1
a510 1
					const char *str, int len);
d512 1
a512 1
					const char *str, int len);
d541 1
a541 1
	UI_METHOD *ui_method, void *callback_data);
d543 1
a543 1
	UI_METHOD *ui_method, void *callback_data);
d545 3
a547 3
	STACK_OF(X509_NAME) *ca_dn, X509 **pcert, EVP_PKEY **ppkey,
	STACK_OF(X509) **pother,
	UI_METHOD *ui_method, void *callback_data);
d622 1
a622 1
	} dynamic_MEM_fns;
d625 2
a626 2
typedef void (*dyn_lock_locking_cb)(int,int,const char *,int);
typedef int (*dyn_lock_add_lock_cb)(int*,int,int,const char *,int);
d628 3
a630 3
						const char *,int);
typedef void (*dyn_dynlock_lock_cb)(int,struct CRYPTO_dynlock_value *,
						const char *,int);
d632 1
a632 1
						const char *,int);
d639 1
a639 1
	} dynamic_LOCK_fns;
d647 1
a647 1
	} dynamic_fns;
d681 1
a681 1
				const dynamic_fns *fns);
d712 1
a712 1
void *ENGINE_get_static_state(void);
@


1.27
log
@Abandon the auto-ENGINE /dev/crypto interface.  VIA 3des cbc receives
collateral damage.

The syncronous nature of this mechanism has hampered performance for
symmetric crypto relative to brute-force cpu. The assymetric crypto
support never really materialized in drivers.

So abandon the complexity.
ok tedu beck mikeb
some disagrement from djm but if he wants to test /dev/crypto ciphers
he should do it without this this gigantic API in the way
@
text
@d1 1
a1 1
/* openssl/engine.h */
@


1.26
log
@A few months back there was a big community fuss regarding direct-use
of the intel RDRAND instruction.  Consensus was RDRAND should probably
only be used as an additional source of entropy in a mixer.

Guess which library bends over backwards to provide easy access to
RDRAND?  Yep.  Guess which applications are using this support?  Not
even one... but still, this is being placed as a trap for someone.

Send this support straight to the abyss.
ok kettenis
@
text
@a320 1
void ENGINE_load_cryptodev(void);
a707 4

#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(HAVE_CRYPTODEV)
void ENGINE_setup_bsd_cryptodev(void);
#endif
@


1.25
log
@Expand the OPENSSL_{GLOBAL,EXPORT,IMPORT,EXTERN} macros - this rids the
libssl tree from all uses of these defines.

ok miod@@
@
text
@a322 1
void ENGINE_load_rdrand(void);
@


1.24
log
@Remove the GOST engine: It is not compiled or used and depends on the
"dynamic engine" feature that is not enabled in our build.  People who
need it can still pull it out of the Attic; if it is to have a Russian
engine just because it's a Russian engine.

OK deraadt@@ beck@@
@
text
@d657 2
a658 2
	OPENSSL_EXPORT unsigned long v_check(unsigned long v); \
	OPENSSL_EXPORT unsigned long v_check(unsigned long v) { \
d680 1
a680 1
	OPENSSL_EXPORT \
d682 1
a682 1
	OPENSSL_EXPORT \
@


1.23
log
@Remove the GMP engine: It was an experimental engine using libgmp as
an alternative backend for BIGNUM calculations.  It is PoC code that
is not enabled in OpenSSL and probably not used by anymore.

ok deraadt@@
@
text
@a319 3
#ifndef OPENSSL_NO_GOST
void ENGINE_load_gost(void);
#endif
@


1.22
log
@Remove the CAPI engine: It is a backend for the Windows CryptoAPI and
could be maintained in an external package.

"it should probably go" beck@@
@
text
@a319 3
#ifndef OPENSSL_NO_GMP
void ENGINE_load_gmp(void);
#endif
@


1.21
log
@Remove the nuron engine.  The static engine is not standalone and the
FPGA-based device is long obsolete.
@
text
@a319 1
void ENGINE_load_capi(void);
@


1.20
log
@Remove the nCipher CHIL engine.  It is not standalone and depends on
external libraries that aren't covered by the same license.
@
text
@a318 1
void ENGINE_load_nuron(void);
@


1.19
log
@Cope with the removal of openssl/symhacks.h
@
text
@a248 16
/* NB: These 2 nCipher "chil" control commands are deprecated, and their
 * functionality is now available through ENGINE-specific control commands
 * (exposed through the above-mentioned 'CMD'-handling). Code using these 2
 * commands should be migrated to the more general command handling before these
 * are removed. */

/* Flags specific to the nCipher "chil" engine */
#define ENGINE_CTRL_CHIL_SET_FORKCHECK		100
	/* Depending on the value of the (long)i argument, this sets or
	 * unsets the SimpleForkCheck flag in the CHIL API to enable or
	 * disable checking and workarounds for applications that fork().
	 */
#define ENGINE_CTRL_CHIL_NO_LOCKING		101
	/* This prevents the initialisation function from providing mutex
	 * callbacks to the nCipher library. */

a318 1
void ENGINE_load_chil(void);
@


1.18
log
@Remove the AEP engine: it is not standalone and doesn't seem to be
relevant anymore.  OpenSSL should have a better way to include 3rd
party engines: either completely and free or external.  But including
a wrapper for a non-free wrapper in the code base does not make much
sense and could also be provided by the vendor.

ok deraadt@@
@
text
@a95 1
#include <openssl/symhacks.h>
@


1.17
log
@Remove the Atalla engine: It is not standalone and depends on external
non-free libraries.  OpenSSL should have a better way to include 3rd
party engines: either completely free or external.  But including a
wrapper for a non-free wrapper in the code base does not make much
sense and could also be provided by the vendor.

ok deraadt@@
@
text
@a335 1
void ENGINE_load_aep(void);
@


1.16
log
@Remove the cswift engine: it is not standalone and we don't have the
hardware.

The vendor_defns/cswift.h does not specify a copyright and
theoretically defaults to the OpenSSL license, but it also mentions
that it includes parts that have been "clipped" from CryptoSwift's
proprietary headers.  This file should better include an explicit
copyright statement or mention OpenSSL's library instead of the
ambiguous "Attribution notice".

ok deraadt@@
@
text
@a336 1
void ENGINE_load_atalla(void);
@


1.15
log
@Remove the "sureware" engine:
The vendor_defns/sureware.h file by Baltimore Technologies Ltd. has a
copyright that does not grant rights!

Vendor files should either include a compatible license in the
copyright statement or use OpenSSL's defaults, but adding a copyright
statement without any terms is not acceptable.  It should not have
been included in the first place.

ok deraadt@@
@
text
@a338 1
void ENGINE_load_cswift(void);
@


1.14
log
@Remove the Broadcom ubsec engine:
The vendor_defns/hw_ubsec.h file has a copyright that does not grant rights!

Vendor files should either include a compatible license in the
copyright statement or use OpenSSL's defaults, but adding a copyright
statement without any terms is not acceptable.  It should not have
been included in the first place.

(The ubsec(4) kernel driver is not affected by this change)

ok deraadt@@
@
text
@a340 1
void ENGINE_load_sureware(void);
@


1.13
log
@Remove the IBM 4758 engine: we don't have this hardware and it is an
old PCI accelerator that was EOL'ed in 2005.

ok deraadt@@
@
text
@a341 1
void ENGINE_load_ubsec(void);
@


1.12
log
@resolve conflicts
@
text
@a335 1
void ENGINE_load_4758cca(void);
@


1.11
log
@openssl-1.0.0e: resolve conflicts
@
text
@d144 7
d354 2
a355 1
void ENGINE_load_aesni(void);
@


1.10
log
@resolve conflicts, fix local changes
@
text
@d681 1
d704 2
@


1.9
log
@AES-NI engine support for OpenSSL.
This is code mostly picked up from upstream OpenSSL, or to be more exact
a diff from David Woodhouse <dwmw2 at infradead dot org>.

Remember to make includes before doing a build!

no objections from djm@@
OK deraadt@@, reyk@@ (AES is about 4.25x faster on his x201 now)
@
text
@a90 1
#include <openssl/store.h>
a94 2
#include <openssl/x509.h>

d98 2
d115 2
d301 2
a302 1

d334 5
d342 3
a344 3
void ENGINE_load_nuron(void);
void ENGINE_load_sureware(void);
void ENGINE_load_ubsec(void);
a347 1
void ENGINE_load_padlock(void);
a348 3
#ifndef OPENSSL_NO_CAPIENG
void ENGINE_load_capi(void);
#endif
d399 8
d486 2
d524 2
d528 6
d585 2
d602 2
d732 1
a732 1
#if defined(__OpenBSD__) || defined(__FreeBSD__)
d761 2
d769 1
a769 1
#define ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT		 192
d798 1
d825 1
@


1.8
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d340 1
@


1.7
log
@resolve conflicts
@
text
@d96 2
d283 3
d342 3
d470 2
d507 1
d543 4
d741 1
@


1.6
log
@merge 0.9.7d
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.
d58 5
d73 1
a73 1
#include <openssl/ossl_typ.h>
d84 6
d91 1
d93 4
a97 1
#include <openssl/err.h>
a102 11
/* Fixups for missing algorithms */
#ifdef OPENSSL_NO_RSA
typedef void RSA_METHOD;
#endif
#ifdef OPENSSL_NO_DSA
typedef void DSA_METHOD;
#endif
#ifdef OPENSSL_NO_DH
typedef void DH_METHOD;
#endif

d109 2
d113 1
d183 9
a191 3
                                                     when calling the password
                                                     callback and the user
                                                     interface */
d238 1
a238 1
#define ENGINE_CMD_BASE		200
d273 1
a273 1
typedef int (*ENGINE_GEN_FUNC_PTR)();
d277 1
a277 1
typedef int (*ENGINE_CTRL_FUNC_PTR)(ENGINE *, int, long, void *, void (*f)());
d321 5
d327 3
a329 2
void ENGINE_load_chil(void);
void ENGINE_load_atalla(void);
d331 1
d333 1
a333 3
void ENGINE_load_aep(void);
void ENGINE_load_sureware(void);
void ENGINE_load_4758cca(void);
d335 1
d359 8
d375 4
d401 1
a401 1
int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)());
d414 1
a414 1
        long i, void *p, void (*f)(), int cmd_optional);
d451 2
d455 1
d466 1
a466 2
/* These functions (and the "get" function lower down) allow control over any
 * per-structure ENGINE data. */
d470 1
d486 2
d490 1
a502 1
void *ENGINE_get_ex_data(const ENGINE *e, int idx);
d540 2
d557 2
d581 1
a581 1
#define OSSL_DYNAMIC_VERSION		(unsigned long)0x00010200
d584 1
a584 1
#define OSSL_DYNAMIC_OLDEST		(unsigned long)0x00010200
d591 4
a594 1
 * 'state' will be used/changed in all operations. */
d622 1
d640 1
a640 1
	unsigned long v_check(unsigned long v) { \
d662 1
d664 13
a676 14
		if (ERR_get_implementation() != fns->err_fns) \
			{ \
			if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, \
				fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) \
				return 0; \
			CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); \
			CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); \
			CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \
			CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \
			CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \
			if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \
				return 0; \
			if(!ERR_set_implementation(fns->err_fns)) return 0; \
			} \
d680 11
d707 1
d715 1
a715 1
#define ENGINE_F_ENGINE_FREE				 108
a725 1
#define ENGINE_F_ENGINE_MODULE_INIT			 187
d734 1
d738 1
a739 1
#define ENGINE_F_SET_DATA_CTX				 183
@


1.5
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d516 1
a516 1
int ENGINE_set_default_string(ENGINE *e, const char *list);
d619 14
a632 11
		if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, \
			fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) \
			return 0; \
		CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); \
		CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); \
		CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \
		CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \
		CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \
		if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \
			return 0; \
		if(!ERR_set_implementation(fns->err_fns)) return 0; \
@


1.4
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d541 1
a541 1
#define OSSL_DYNAMIC_VERSION		(unsigned long)0x00010100
d544 1
a544 1
#define OSSL_DYNAMIC_OLDEST		(unsigned long)0x00010100
d632 4
@


1.3
log
@merge with 0.9.7-beta1
@
text
@d62 6
d316 1
a316 1
void ENGINE_load_openbsd_dev_crypto(void);
a317 3
#ifdef __OpenBSD__
void ENGINE_load_cryptodev(void);
#endif	
d415 1
d672 1
@


1.2
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d315 1
a315 1
	
@


1.1
log
@openssl-engine-0.9.6 merge
@
text
@d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d62 1
d64 1
d66 2
d69 2
d72 1
d74 1
a74 1
#include <openssl/evp.h>
d76 1
d82 11
d99 2
a100 2
#define ENGINE_METHOD_BN_MOD_EXP	(unsigned int)0x0010
#define ENGINE_METHOD_BN_MOD_EXP_CRT	(unsigned int)0x0020
d105 55
d166 61
d237 15
a251 15
/* As we're missing a BIGNUM_METHOD, we need a couple of locally
 * defined function types that engines can implement. */

#ifndef HEADER_ENGINE_INT_H
/* mod_exp operation, calculates; r = a ^ p mod m
 * NB: ctx can be NULL, but if supplied, the implementation may use
 * it if it wishes. */
typedef int (*BN_MOD_EXP)(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
		const BIGNUM *m, BN_CTX *ctx);

/* private key operation for RSA, provided seperately in case other
 * RSA implementations wish to use it. */
typedef int (*BN_MOD_EXP_CRT)(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
		const BIGNUM *q, const BIGNUM *dmp1, const BIGNUM *dmq1,
		const BIGNUM *iqmp, BN_CTX *ctx);
d254 1
a254 1
typedef void (*ENGINE_GEN_FUNC_PTR)();
d256 1
a256 1
typedef void (*ENGINE_GEN_INT_FUNC_PTR)(void);
d258 28
a285 18
typedef int (*ENGINE_CTRL_FUNC_PTR)(int cmd, long i, void *p, void (*f)());

/* The list of "engine" types is a static array of (const ENGINE*)
 * pointers (not dynamic because static is fine for now and we otherwise
 * have to hook an appropriate load/unload function in to initialise and
 * cleanup). */
typedef struct engine_st ENGINE;
#endif

/* STRUCTURE functions ... all of these functions deal with pointers to
 * ENGINE structures where the pointers have a "structural reference".
 * This means that their reference is to allow access to the structure
 * but it does not imply that the structure is functional. To simply
 * increment or decrement the structural reference count, use ENGINE_new
 * and ENGINE_free. NB: This is not required when iterating using
 * ENGINE_get_next as it will automatically decrement the structural
 * reference count of the "current" ENGINE and increment the structural
 * reference count of the ENGINE it returns (unless it is NULL). */
d299 69
d369 41
a409 15
/* These functions are useful for manufacturing new ENGINE
 * structures. They don't address reference counting at all -
 * one uses them to populate an ENGINE structure with personalised
 * implementations of things prior to using it directly or adding
 * it to the builtin ENGINE list in OpenSSL. These are also here
 * so that the ENGINE structure doesn't have to be exposed and
 * break binary compatibility!
 *
 * NB: I'm changing ENGINE_new to force the ENGINE structure to
 * be allocated from within OpenSSL. See the comment for
 * ENGINE_get_struct_size().
 */
#if 0
ENGINE *ENGINE_new(ENGINE *e);
#else
a410 1
#endif
d414 5
a418 6
int ENGINE_set_RSA(ENGINE *e, RSA_METHOD *rsa_meth);
int ENGINE_set_DSA(ENGINE *e, DSA_METHOD *dsa_meth);
int ENGINE_set_DH(ENGINE *e, DH_METHOD *dh_meth);
int ENGINE_set_RAND(ENGINE *e, RAND_METHOD *rand_meth);
int ENGINE_set_BN_mod_exp(ENGINE *e, BN_MOD_EXP bn_mod_exp);
int ENGINE_set_BN_mod_exp_crt(ENGINE *e, BN_MOD_EXP_CRT bn_mod_exp_crt);
d422 41
a462 31

/* These return values from within the ENGINE structure. These can
 * be useful with functional references as well as structural
 * references - it depends which you obtained. Using the result
 * for functional purposes if you only obtained a structural
 * reference may be problematic! */
const char *ENGINE_get_id(ENGINE *e);
const char *ENGINE_get_name(ENGINE *e);
RSA_METHOD *ENGINE_get_RSA(ENGINE *e);
DSA_METHOD *ENGINE_get_DSA(ENGINE *e);
DH_METHOD *ENGINE_get_DH(ENGINE *e);
RAND_METHOD *ENGINE_get_RAND(ENGINE *e);
BN_MOD_EXP ENGINE_get_BN_mod_exp(ENGINE *e);
BN_MOD_EXP_CRT ENGINE_get_BN_mod_exp_crt(ENGINE *e);
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(ENGINE *e);
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(ENGINE *e);
ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(ENGINE *e);

/* ENGINE_new is normally passed a NULL in the first parameter because
 * the calling code doesn't have access to the definition of the ENGINE
 * structure (for good reason). However, if the caller wishes to use
 * its own memory allocation or use a static array, the following call
 * should be used to check the amount of memory the ENGINE structure
 * will occupy. This will make the code more future-proof.
 *
 * NB: I'm "#if 0"-ing this out because it's better to force the use of
 * internally allocated memory. See similar change in ENGINE_new().
 */
#if 0
int ENGINE_get_struct_size(void);
#endif
a483 6
/* Send control parametrised commands to the engine.  The possibilities
 * to send down an integer, a pointer to data or a function pointer are
 * provided.  Any of the parameters may or may not be NULL, depending
 * on the command number */
/* WARNING: This is currently experimental and may change radically! */
int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)());
d489 1
a489 1
	const char *passphrase);
d491 1
a491 1
	const char *passphrase);
d502 4
a505 2
ENGINE *ENGINE_get_default_BN_mod_exp(void);
ENGINE *ENGINE_get_default_BN_mod_exp_crt(void);
d512 1
d517 2
a518 2
int ENGINE_set_default_BN_mod_exp(ENGINE *e);
int ENGINE_set_default_BN_mod_exp_crt(ENGINE *e);
d521 4
a524 1
 * ENGINE_METHOD_*** defines above. */
d527 4
a530 2
/* Obligatory error function. */
void ERR_load_ENGINE_strings(void);
d532 96
a627 9
/*
 * Error codes for all engine functions. NB: We use "generic"
 * function names instead of per-implementation ones because this
 * levels the playing field for externally implemented bootstrapped
 * support code. As the filename and line number is included, it's
 * more important to indicate the type of function, so that
 * bootstrapped code (that can't easily add its own errors in) can
 * use the same error codes too.
 */
d633 1
d638 3
a640 11
#define ENGINE_F_ATALLA_FINISH				 135
#define ENGINE_F_ATALLA_INIT				 136
#define ENGINE_F_ATALLA_MOD_EXP				 137
#define ENGINE_F_ATALLA_RSA_MOD_EXP			 138
#define ENGINE_F_CSWIFT_DSA_SIGN			 133
#define ENGINE_F_CSWIFT_DSA_VERIFY			 134
#define ENGINE_F_CSWIFT_FINISH				 100
#define ENGINE_F_CSWIFT_INIT				 101
#define ENGINE_F_CSWIFT_MOD_EXP				 102
#define ENGINE_F_CSWIFT_MOD_EXP_CRT			 103
#define ENGINE_F_CSWIFT_RSA_MOD_EXP			 104
d643 1
d645 2
d649 3
a651 9
#define ENGINE_F_ENGINE_GET_BN_MOD_EXP			 109
#define ENGINE_F_ENGINE_GET_BN_MOD_EXP_CRT		 110
#define ENGINE_F_ENGINE_GET_CTRL_FUNCTION		 144
#define ENGINE_F_ENGINE_GET_DH				 111
#define ENGINE_F_ENGINE_GET_DSA				 112
#define ENGINE_F_ENGINE_GET_FINISH_FUNCTION		 145
#define ENGINE_F_ENGINE_GET_ID				 113
#define ENGINE_F_ENGINE_GET_INIT_FUNCTION		 146
#define ENGINE_F_ENGINE_GET_NAME			 114
a653 2
#define ENGINE_F_ENGINE_GET_RAND			 117
#define ENGINE_F_ENGINE_GET_RSA				 118
d659 1
d662 1
a662 3
#define ENGINE_F_ENGINE_SET_BN_MOD_EXP			 124
#define ENGINE_F_ENGINE_SET_BN_MOD_EXP_CRT		 125
#define ENGINE_F_ENGINE_SET_CTRL_FUNCTION		 147
a663 3
#define ENGINE_F_ENGINE_SET_DH				 127
#define ENGINE_F_ENGINE_SET_DSA				 128
#define ENGINE_F_ENGINE_SET_FINISH_FUNCTION		 148
a664 1
#define ENGINE_F_ENGINE_SET_INIT_FUNCTION		 149
d666 1
a666 2
#define ENGINE_F_ENGINE_SET_RAND			 131
#define ENGINE_F_ENGINE_SET_RSA				 132
d668 2
a669 10
#define ENGINE_F_HWCRHK_CTRL				 143
#define ENGINE_F_HWCRHK_FINISH				 135
#define ENGINE_F_HWCRHK_GET_PASS			 155
#define ENGINE_F_HWCRHK_INIT				 136
#define ENGINE_F_HWCRHK_LOAD_PRIVKEY			 153
#define ENGINE_F_HWCRHK_LOAD_PUBKEY			 154
#define ENGINE_F_HWCRHK_MOD_EXP				 137
#define ENGINE_F_HWCRHK_MOD_EXP_CRT			 138
#define ENGINE_F_HWCRHK_RAND_BYTES			 139
#define ENGINE_F_HWCRHK_RSA_MOD_EXP			 140
d671 1
d675 4
a678 4
#define ENGINE_R_BIO_WAS_FREED				 121
#define ENGINE_R_BN_CTX_FULL				 101
#define ENGINE_R_BN_EXPAND_FAIL				 102
#define ENGINE_R_CHIL_ERROR				 123
d681 2
d684 2
d687 1
d695 5
a699 1
#define ENGINE_R_MISSING_KEY_COMPONENTS			 111
a701 1
#define ENGINE_R_NO_CALLBACK				 127
d703 1
a703 1
#define ENGINE_R_NO_KEY					 124
d709 4
a712 4
#define ENGINE_R_REQUEST_FAILED				 114
#define ENGINE_R_REQUEST_FALLBACK			 118
#define ENGINE_R_SIZE_TOO_LARGE_OR_TOO_SMALL		 122
#define ENGINE_R_UNIT_FAILURE				 115
a717 1

@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.
a61 1
#include <openssl/ossl_typ.h>
a62 1
#ifndef OPENSSL_NO_RSA
a63 2
#endif
#ifndef OPENSSL_NO_DSA
a64 2
#endif
#ifndef OPENSSL_NO_DH
a65 1
#endif
d67 1
a67 1
#include <openssl/ui.h>
a68 1
#include <openssl/err.h>
a73 11
/* Fixups for missing algorithms */
#ifdef OPENSSL_NO_RSA
typedef void RSA_METHOD;
#endif
#ifdef OPENSSL_NO_DSA
typedef void DSA_METHOD;
#endif
#ifdef OPENSSL_NO_DH
typedef void DH_METHOD;
#endif

d80 2
a81 2
#define ENGINE_METHOD_CIPHERS		(unsigned int)0x0040
#define ENGINE_METHOD_DIGESTS		(unsigned int)0x0080
a85 55
/* This(ese) flag(s) controls behaviour of the ENGINE_TABLE mechanism used
 * internally to control registration of ENGINE implementations, and can be set
 * by ENGINE_set_table_flags(). The "NOINIT" flag prevents attempts to
 * initialise registered ENGINEs if they are not already initialised. */
#define ENGINE_TABLE_FLAG_NOINIT	(unsigned int)0x0001

/* ENGINE flags that can be set by ENGINE_set_flags(). */
/* #define ENGINE_FLAGS_MALLOCED	0x0001 */ /* Not used */

/* This flag is for ENGINEs that wish to handle the various 'CMD'-related
 * control commands on their own. Without this flag, ENGINE_ctrl() handles these
 * control commands on behalf of the ENGINE using their "cmd_defns" data. */
#define ENGINE_FLAGS_MANUAL_CMD_CTRL	(int)0x0002

/* This flag is for ENGINEs who return new duplicate structures when found via
 * "ENGINE_by_id()". When an ENGINE must store state (eg. if ENGINE_ctrl()
 * commands are called in sequence as part of some stateful process like
 * key-generation setup and execution), it can set this flag - then each attempt
 * to obtain the ENGINE will result in it being copied into a new structure.
 * Normally, ENGINEs don't declare this flag so ENGINE_by_id() just increments
 * the existing ENGINE's structural reference count. */
#define ENGINE_FLAGS_BY_ID_COPY		(int)0x0004

/* ENGINEs can support their own command types, and these flags are used in
 * ENGINE_CTRL_GET_CMD_FLAGS to indicate to the caller what kind of input each
 * command expects. Currently only numeric and string input is supported. If a
 * control command supports none of the _NUMERIC, _STRING, or _NO_INPUT options,
 * then it is regarded as an "internal" control command - and not for use in
 * config setting situations. As such, they're not available to the
 * ENGINE_ctrl_cmd_string() function, only raw ENGINE_ctrl() access. Changes to
 * this list of 'command types' should be reflected carefully in
 * ENGINE_cmd_is_executable() and ENGINE_ctrl_cmd_string(). */

/* accepts a 'long' input value (3rd parameter to ENGINE_ctrl) */
#define ENGINE_CMD_FLAG_NUMERIC		(unsigned int)0x0001
/* accepts string input (cast from 'void*' to 'const char *', 4th parameter to
 * ENGINE_ctrl) */
#define ENGINE_CMD_FLAG_STRING		(unsigned int)0x0002
/* Indicates that the control command takes *no* input. Ie. the control command
 * is unparameterised. */
#define ENGINE_CMD_FLAG_NO_INPUT	(unsigned int)0x0004
/* Indicates that the control command is internal. This control command won't
 * be shown in any output, and is only usable through the ENGINE_ctrl_cmd()
 * function. */
#define ENGINE_CMD_FLAG_INTERNAL	(unsigned int)0x0008

/* NB: These 3 control commands are deprecated and should not be used. ENGINEs
 * relying on these commands should compile conditional support for
 * compatibility (eg. if these symbols are defined) but should also migrate the
 * same functionality to their own ENGINE-specific control functions that can be
 * "discovered" by calling applications. The fact these control commands
 * wouldn't be "executable" (ie. usable by text-based config) doesn't change the
 * fact that application code can find and use them without requiring per-ENGINE
 * hacking. */

a91 61
#define ENGINE_CTRL_HUP				3 /* Close and reinitialise any
						     handles/connections etc. */
#define ENGINE_CTRL_SET_USER_INTERFACE          4 /* Alternative to callback */
#define ENGINE_CTRL_SET_CALLBACK_DATA           5 /* User-specific data, used
                                                     when calling the password
                                                     callback and the user
                                                     interface */

/* These control commands allow an application to deal with an arbitrary engine
 * in a dynamic way. Warn: Negative return values indicate errors FOR THESE
 * COMMANDS because zero is used to indicate 'end-of-list'. Other commands,
 * including ENGINE-specific command types, return zero for an error.
 *
 * An ENGINE can choose to implement these ctrl functions, and can internally
 * manage things however it chooses - it does so by setting the
 * ENGINE_FLAGS_MANUAL_CMD_CTRL flag (using ENGINE_set_flags()). Otherwise the
 * ENGINE_ctrl() code handles this on the ENGINE's behalf using the cmd_defns
 * data (set using ENGINE_set_cmd_defns()). This means an ENGINE's ctrl()
 * handler need only implement its own commands - the above "meta" commands will
 * be taken care of. */

/* Returns non-zero if the supplied ENGINE has a ctrl() handler. If "not", then
 * all the remaining control commands will return failure, so it is worth
 * checking this first if the caller is trying to "discover" the engine's
 * capabilities and doesn't want errors generated unnecessarily. */
#define ENGINE_CTRL_HAS_CTRL_FUNCTION		10
/* Returns a positive command number for the first command supported by the
 * engine. Returns zero if no ctrl commands are supported. */
#define ENGINE_CTRL_GET_FIRST_CMD_TYPE		11
/* The 'long' argument specifies a command implemented by the engine, and the
 * return value is the next command supported, or zero if there are no more. */
#define ENGINE_CTRL_GET_NEXT_CMD_TYPE		12
/* The 'void*' argument is a command name (cast from 'const char *'), and the
 * return value is the command that corresponds to it. */
#define ENGINE_CTRL_GET_CMD_FROM_NAME		13
/* The next two allow a command to be converted into its corresponding string
 * form. In each case, the 'long' argument supplies the command. In the NAME_LEN
 * case, the return value is the length of the command name (not counting a
 * trailing EOL). In the NAME case, the 'void*' argument must be a string buffer
 * large enough, and it will be populated with the name of the command (WITH a
 * trailing EOL). */
#define ENGINE_CTRL_GET_NAME_LEN_FROM_CMD	14
#define ENGINE_CTRL_GET_NAME_FROM_CMD		15
/* The next two are similar but give a "short description" of a command. */
#define ENGINE_CTRL_GET_DESC_LEN_FROM_CMD	16
#define ENGINE_CTRL_GET_DESC_FROM_CMD		17
/* With this command, the return value is the OR'd combination of
 * ENGINE_CMD_FLAG_*** values that indicate what kind of input a given
 * engine-specific ctrl command expects. */
#define ENGINE_CTRL_GET_CMD_FLAGS		18

/* ENGINE implementations should start the numbering of their own control
 * commands from this value. (ie. ENGINE_CMD_BASE, ENGINE_CMD_BASE + 1, etc). */
#define ENGINE_CMD_BASE		200

/* NB: These 2 nCipher "chil" control commands are deprecated, and their
 * functionality is now available through ENGINE-specific control commands
 * (exposed through the above-mentioned 'CMD'-handling). Code using these 2
 * commands should be migrated to the more general command handling before these
 * are removed. */

d102 15
a116 15
/* If an ENGINE supports its own specific control commands and wishes the
 * framework to handle the above 'ENGINE_CMD_***'-manipulation commands on its
 * behalf, it should supply a null-terminated array of ENGINE_CMD_DEFN entries
 * to ENGINE_set_cmd_defns(). It should also implement a ctrl() handler that
 * supports the stated commands (ie. the "cmd_num" entries as described by the
 * array). NB: The array must be ordered in increasing order of cmd_num.
 * "null-terminated" means that the last ENGINE_CMD_DEFN element has cmd_num set
 * to zero and/or cmd_name set to NULL. */
typedef struct ENGINE_CMD_DEFN_st
	{
	unsigned int cmd_num; /* The command number */
	const char *cmd_name; /* The command name itself */
	const char *cmd_desc; /* A short description of the command */
	unsigned int cmd_flags; /* The input the command expects */
	} ENGINE_CMD_DEFN;
d119 1
a119 1
typedef int (*ENGINE_GEN_FUNC_PTR)();
d121 1
a121 1
typedef int (*ENGINE_GEN_INT_FUNC_PTR)(ENGINE *);
d123 18
a140 28
typedef int (*ENGINE_CTRL_FUNC_PTR)(ENGINE *, int, long, void *, void (*f)());
/* Generic load_key function pointer */
typedef EVP_PKEY * (*ENGINE_LOAD_KEY_PTR)(ENGINE *, const char *,
	UI_METHOD *ui_method, void *callback_data);
/* These callback types are for an ENGINE's handler for cipher and digest logic.
 * These handlers have these prototypes;
 *   int foo(ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid);
 *   int foo(ENGINE *e, const EVP_MD **digest, const int **nids, int nid);
 * Looking at how to implement these handlers in the case of cipher support, if
 * the framework wants the EVP_CIPHER for 'nid', it will call;
 *   foo(e, &p_evp_cipher, NULL, nid);    (return zero for failure)
 * If the framework wants a list of supported 'nid's, it will call;
 *   foo(e, NULL, &p_nids, 0); (returns number of 'nids' or -1 for error)
 */
/* Returns to a pointer to the array of supported cipher 'nid's. If the second
 * parameter is non-NULL it is set to the size of the returned array. */
typedef int (*ENGINE_CIPHERS_PTR)(ENGINE *, const EVP_CIPHER **, const int **, int);
typedef int (*ENGINE_DIGESTS_PTR)(ENGINE *, const EVP_MD **, const int **, int);

/* STRUCTURE functions ... all of these functions deal with pointers to ENGINE
 * structures where the pointers have a "structural reference". This means that
 * their reference is to allowed access to the structure but it does not imply
 * that the structure is functional. To simply increment or decrement the
 * structural reference count, use ENGINE_by_id and ENGINE_free. NB: This is not
 * required when iterating using ENGINE_get_next as it will automatically
 * decrement the structural reference count of the "current" ENGINE and
 * increment the structural reference count of the ENGINE it returns (unless it
 * is NULL). */
a153 66
/* Add all the built-in engines. */
void ENGINE_load_openssl(void);
void ENGINE_load_dynamic(void);
void ENGINE_load_cswift(void);
void ENGINE_load_chil(void);
void ENGINE_load_atalla(void);
void ENGINE_load_nuron(void);
void ENGINE_load_ubsec(void);
void ENGINE_load_aep(void);
void ENGINE_load_sureware(void);
void ENGINE_load_4758cca(void);
void ENGINE_load_openbsd_dev_crypto(void);
void ENGINE_load_builtin_engines(void);

/* Get and set global flags (ENGINE_TABLE_FLAG_***) for the implementation
 * "registry" handling. */
unsigned int ENGINE_get_table_flags(void);
void ENGINE_set_table_flags(unsigned int flags);

/* Manage registration of ENGINEs per "table". For each type, there are 3
 * functions;
 *   ENGINE_register_***(e) - registers the implementation from 'e' (if it has one)
 *   ENGINE_unregister_***(e) - unregister the implementation from 'e'
 *   ENGINE_register_all_***() - call ENGINE_register_***() for each 'e' in the list
 * Cleanup is automatically registered from each table when required, so
 * ENGINE_cleanup() will reverse any "register" operations. */

int ENGINE_register_RSA(ENGINE *e);
void ENGINE_unregister_RSA(ENGINE *e);
void ENGINE_register_all_RSA(void);

int ENGINE_register_DSA(ENGINE *e);
void ENGINE_unregister_DSA(ENGINE *e);
void ENGINE_register_all_DSA(void);

int ENGINE_register_DH(ENGINE *e);
void ENGINE_unregister_DH(ENGINE *e);
void ENGINE_register_all_DH(void);

int ENGINE_register_RAND(ENGINE *e);
void ENGINE_unregister_RAND(ENGINE *e);
void ENGINE_register_all_RAND(void);

int ENGINE_register_ciphers(ENGINE *e);
void ENGINE_unregister_ciphers(ENGINE *e);
void ENGINE_register_all_ciphers(void);

int ENGINE_register_digests(ENGINE *e);
void ENGINE_unregister_digests(ENGINE *e);
void ENGINE_register_all_digests(void);

/* These functions register all support from the above categories. Note, use of
 * these functions can result in static linkage of code your application may not
 * need. If you only need a subset of functionality, consider using more
 * selective initialisation. */
int ENGINE_register_complete(ENGINE *e);
int ENGINE_register_all_complete(void);

/* Send parametrised control commands to the engine. The possibilities to send
 * down an integer, a pointer to data or a function pointer are provided. Any of
 * the parameters may or may not be NULL, depending on the command number. In
 * actuality, this function only requires a structural (rather than functional)
 * reference to an engine, but many control commands may require the engine be
 * functional. The caller should be aware of trying commands that require an
 * operational ENGINE, and only use functional references in such situations. */
int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)());
d155 15
a169 41
/* This function tests if an ENGINE-specific command is usable as a "setting".
 * Eg. in an application's config file that gets processed through
 * ENGINE_ctrl_cmd_string(). If this returns zero, it is not available to
 * ENGINE_ctrl_cmd_string(), only ENGINE_ctrl(). */
int ENGINE_cmd_is_executable(ENGINE *e, int cmd);

/* This function works like ENGINE_ctrl() with the exception of taking a
 * command name instead of a command number, and can handle optional commands.
 * See the comment on ENGINE_ctrl_cmd_string() for an explanation on how to
 * use the cmd_name and cmd_optional. */
int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,
        long i, void *p, void (*f)(), int cmd_optional);

/* This function passes a command-name and argument to an ENGINE. The cmd_name
 * is converted to a command number and the control command is called using
 * 'arg' as an argument (unless the ENGINE doesn't support such a command, in
 * which case no control command is called). The command is checked for input
 * flags, and if necessary the argument will be converted to a numeric value. If
 * cmd_optional is non-zero, then if the ENGINE doesn't support the given
 * cmd_name the return value will be success anyway. This function is intended
 * for applications to use so that users (or config files) can supply
 * engine-specific config data to the ENGINE at run-time to control behaviour of
 * specific engines. As such, it shouldn't be used for calling ENGINE_ctrl()
 * functions that return data, deal with binary data, or that are otherwise
 * supposed to be used directly through ENGINE_ctrl() in application code. Any
 * "return" data from an ENGINE_ctrl() operation in this function will be lost -
 * the return value is interpreted as failure if the return value is zero,
 * success otherwise, and this function returns a boolean value as a result. In
 * other words, vendors of 'ENGINE'-enabled devices should write ENGINE
 * implementations with parameterisations that work in this scheme, so that
 * compliant ENGINE-based applications can work consistently with the same
 * configuration for the same ENGINE-enabled devices, across applications. */
int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
				int cmd_optional);

/* These functions are useful for manufacturing new ENGINE structures. They
 * don't address reference counting at all - one uses them to populate an ENGINE
 * structure with personalised implementations of things prior to using it
 * directly or adding it to the builtin ENGINE list in OpenSSL. These are also
 * here so that the ENGINE structure doesn't have to be exposed and break binary
 * compatibility! */
d171 1
d175 6
a180 5
int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);
int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);
int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);
int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);
int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f);
d184 31
a214 41
int ENGINE_set_load_privkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpriv_f);
int ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f);
int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);
int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);
int ENGINE_set_flags(ENGINE *e, int flags);
int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns);
/* These functions (and the "get" function lower down) allow control over any
 * per-structure ENGINE data. */
int ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
		CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg);

/* This function cleans up anything that needs it. Eg. the ENGINE_add() function
 * automatically ensures the list cleanup function is registered to be called
 * from ENGINE_cleanup(). Similarly, all ENGINE_register_*** functions ensure
 * ENGINE_cleanup() will clean up after them. */
void ENGINE_cleanup(void);

/* These return values from within the ENGINE structure. These can be useful
 * with functional references as well as structural references - it depends
 * which you obtained. Using the result for functional purposes if you only
 * obtained a structural reference may be problematic! */
const char *ENGINE_get_id(const ENGINE *e);
const char *ENGINE_get_name(const ENGINE *e);
const RSA_METHOD *ENGINE_get_RSA(const ENGINE *e);
const DSA_METHOD *ENGINE_get_DSA(const ENGINE *e);
const DH_METHOD *ENGINE_get_DH(const ENGINE *e);
const RAND_METHOD *ENGINE_get_RAND(const ENGINE *e);
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e);
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e);
ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e);
ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e);
ENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e);
ENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e);
ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e);
ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e);
const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid);
const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid);
const ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e);
int ENGINE_get_flags(const ENGINE *e);
void *ENGINE_get_ex_data(const ENGINE *e, int idx);
d236 6
d247 1
a247 1
	UI_METHOD *ui_method, void *callback_data);
d249 1
a249 1
	UI_METHOD *ui_method, void *callback_data);
d260 2
a261 4
/* These functions can be used to get a functional reference to perform
 * ciphering or digesting corresponding to "nid". */
ENGINE *ENGINE_get_cipher_engine(int nid);
ENGINE *ENGINE_get_digest_engine(int nid);
a267 1
int ENGINE_set_default_string(ENGINE *e, const char *list);
d272 2
a273 2
int ENGINE_set_default_ciphers(ENGINE *e);
int ENGINE_set_default_digests(ENGINE *e);
d276 1
a276 4
 * ENGINE_METHOD_*** defines above. As with the "ENGINE_register_complete()"
 * function, this function can result in unnecessary static linkage. If your
 * application requires only specific functionality, consider using more
 * selective functions. */
d279 2
a280 1
void ENGINE_add_conf_module(void);
d282 9
a290 99
/* Deprecated functions ... */
/* int ENGINE_clear_defaults(void); */

/**************************/
/* DYNAMIC ENGINE SUPPORT */
/**************************/

/* Binary/behaviour compatibility levels */
#define OSSL_DYNAMIC_VERSION		(unsigned long)0x00010100
/* Binary versions older than this are too old for us (whether we're a loader or
 * a loadee) */
#define OSSL_DYNAMIC_OLDEST		(unsigned long)0x00010100

/* When compiling an ENGINE entirely as an external shared library, loadable by
 * the "dynamic" ENGINE, these types are needed. The 'dynamic_fns' structure
 * type provides the calling application's (or library's) error functionality
 * and memory management function pointers to the loaded library. These should
 * be used/set in the loaded library code so that the loading application's
 * 'state' will be used/changed in all operations. */
typedef void *(*dyn_MEM_malloc_cb)(size_t);
typedef void *(*dyn_MEM_realloc_cb)(void *, size_t);
typedef void (*dyn_MEM_free_cb)(void *);
typedef struct st_dynamic_MEM_fns {
	dyn_MEM_malloc_cb			malloc_cb;
	dyn_MEM_realloc_cb			realloc_cb;
	dyn_MEM_free_cb				free_cb;
	} dynamic_MEM_fns;
/* FIXME: Perhaps the memory and locking code (crypto.h) should declare and use
 * these types so we (and any other dependant code) can simplify a bit?? */
typedef void (*dyn_lock_locking_cb)(int,int,const char *,int);
typedef int (*dyn_lock_add_lock_cb)(int*,int,int,const char *,int);
typedef struct CRYPTO_dynlock_value *(*dyn_dynlock_create_cb)(
						const char *,int);
typedef void (*dyn_dynlock_lock_cb)(int,struct CRYPTO_dynlock_value *,
						const char *,int);
typedef void (*dyn_dynlock_destroy_cb)(struct CRYPTO_dynlock_value *,
						const char *,int);
typedef struct st_dynamic_LOCK_fns {
	dyn_lock_locking_cb			lock_locking_cb;
	dyn_lock_add_lock_cb			lock_add_lock_cb;
	dyn_dynlock_create_cb			dynlock_create_cb;
	dyn_dynlock_lock_cb			dynlock_lock_cb;
	dyn_dynlock_destroy_cb			dynlock_destroy_cb;
	} dynamic_LOCK_fns;
/* The top-level structure */
typedef struct st_dynamic_fns {
	const ERR_FNS				*err_fns;
	const CRYPTO_EX_DATA_IMPL		*ex_data_fns;
	dynamic_MEM_fns				mem_fns;
	dynamic_LOCK_fns			lock_fns;
	} dynamic_fns;

/* The version checking function should be of this prototype. NB: The
 * ossl_version value passed in is the OSSL_DYNAMIC_VERSION of the loading code.
 * If this function returns zero, it indicates a (potential) version
 * incompatibility and the loaded library doesn't believe it can proceed.
 * Otherwise, the returned value is the (latest) version supported by the
 * loading library. The loader may still decide that the loaded code's version
 * is unsatisfactory and could veto the load. The function is expected to
 * be implemented with the symbol name "v_check", and a default implementation
 * can be fully instantiated with IMPLEMENT_DYNAMIC_CHECK_FN(). */
typedef unsigned long (*dynamic_v_check_fn)(unsigned long ossl_version);
#define IMPLEMENT_DYNAMIC_CHECK_FN() \
	unsigned long v_check(unsigned long v) { \
		if(v >= OSSL_DYNAMIC_OLDEST) return OSSL_DYNAMIC_VERSION; \
		return 0; }

/* This function is passed the ENGINE structure to initialise with its own
 * function and command settings. It should not adjust the structural or
 * functional reference counts. If this function returns zero, (a) the load will
 * be aborted, (b) the previous ENGINE state will be memcpy'd back onto the
 * structure, and (c) the shared library will be unloaded. So implementations
 * should do their own internal cleanup in failure circumstances otherwise they
 * could leak. The 'id' parameter, if non-NULL, represents the ENGINE id that
 * the loader is looking for. If this is NULL, the shared library can choose to
 * return failure or to initialise a 'default' ENGINE. If non-NULL, the shared
 * library must initialise only an ENGINE matching the passed 'id'. The function
 * is expected to be implemented with the symbol name "bind_engine". A standard
 * implementation can be instantiated with IMPLEMENT_DYNAMIC_BIND_FN(fn) where
 * the parameter 'fn' is a callback function that populates the ENGINE structure
 * and returns an int value (zero for failure). 'fn' should have prototype;
 *    [static] int fn(ENGINE *e, const char *id); */
typedef int (*dynamic_bind_engine)(ENGINE *e, const char *id,
				const dynamic_fns *fns);
#define IMPLEMENT_DYNAMIC_BIND_FN(fn) \
	int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \
		if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, \
			fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) \
			return 0; \
		CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); \
		CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); \
		CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \
		CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \
		CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \
		if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \
			return 0; \
		if(!ERR_set_implementation(fns->err_fns)) return 0; \
		if(!fn(e,id)) return 0; \
		return 1; }
a295 1
void ERR_load_ENGINE_strings(void);
d300 11
a310 3
#define ENGINE_F_DYNAMIC_CTRL				 180
#define ENGINE_F_DYNAMIC_GET_DATA_CTX			 181
#define ENGINE_F_DYNAMIC_LOAD				 182
a312 1
#define ENGINE_F_ENGINE_CMD_IS_EXECUTABLE		 170
a313 2
#define ENGINE_F_ENGINE_CTRL_CMD			 178
#define ENGINE_F_ENGINE_CTRL_CMD_STRING			 171
d316 9
a324 3
#define ENGINE_F_ENGINE_GET_CIPHER			 185
#define ENGINE_F_ENGINE_GET_DEFAULT_TYPE		 177
#define ENGINE_F_ENGINE_GET_DIGEST			 186
d327 2
a333 1
#define ENGINE_F_ENGINE_MODULE_INIT			 187
d336 3
a338 1
#define ENGINE_F_ENGINE_SET_DEFAULT_STRING		 189
d340 3
d344 1
d346 2
a347 1
#define ENGINE_F_ENGINE_TABLE_REGISTER			 184
d349 10
a358 2
#define ENGINE_F_INT_CTRL_HELPER			 172
#define ENGINE_F_INT_ENGINE_CONFIGURE			 188
a359 1
#define ENGINE_F_SET_DATA_CTX				 183
d363 4
a366 4
#define ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER		 133
#define ENGINE_R_CMD_NOT_EXECUTABLE			 134
#define ENGINE_R_COMMAND_TAKES_INPUT			 135
#define ENGINE_R_COMMAND_TAKES_NO_INPUT			 136
a368 2
#define ENGINE_R_DH_NOT_IMPLEMENTED			 139
#define ENGINE_R_DSA_NOT_IMPLEMENTED			 140
a369 2
#define ENGINE_R_DSO_NOT_FOUND				 132
#define ENGINE_R_ENGINES_SECTION_ERROR			 148
a370 1
#define ENGINE_R_ENGINE_SECTION_ERROR			 149
d378 1
a378 5
#define ENGINE_R_INVALID_ARGUMENT			 143
#define ENGINE_R_INVALID_CMD_NAME			 137
#define ENGINE_R_INVALID_CMD_NUMBER			 138
#define ENGINE_R_INVALID_INIT_VALUE			 151
#define ENGINE_R_INVALID_STRING				 150
d381 1
d383 1
a383 1
#define ENGINE_R_NO_INDEX				 144
d389 4
a392 4
#define ENGINE_R_RSA_NOT_IMPLEMENTED			 141
#define ENGINE_R_UNIMPLEMENTED_CIPHER			 146
#define ENGINE_R_UNIMPLEMENTED_DIGEST			 147
#define ENGINE_R_VERSION_INCOMPATIBILITY		 145
d398 1
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@a61 6
#include <openssl/opensslconf.h>

#ifdef OPENSSL_NO_ENGINE
#error ENGINE is disabled.
#endif

d310 1
a310 1
void ENGINE_load_cryptodev(void);
a408 1
int ENGINE_up_ref(ENGINE *e);
a664 1
#define ENGINE_F_ENGINE_UP_REF				 190
@


1.1.1.3
log
@import 0.9.7c
@
text
@d541 1
a541 1
#define OSSL_DYNAMIC_VERSION		(unsigned long)0x00010200
d544 1
a544 1
#define OSSL_DYNAMIC_OLDEST		(unsigned long)0x00010200
a631 4

#if defined(__OpenBSD__) || defined(__FreeBSD__)
void ENGINE_setup_bsd_cryptodev(void);
#endif
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@d516 1
a516 1
int ENGINE_set_default_string(ENGINE *e, const char *def_list);
d619 11
a629 14
		if (ERR_get_implementation() != fns->err_fns) \
			{ \
			if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, \
				fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) \
				return 0; \
			CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); \
			CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); \
			CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \
			CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \
			CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \
			if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \
				return 0; \
			if(!ERR_set_implementation(fns->err_fns)) return 0; \
			} \
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.
a57 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECDH support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
d68 1
a68 1
#ifndef OPENSSL_NO_DEPRECATED
a78 6
#ifndef OPENSSL_NO_ECDH
#include <openssl/ecdh.h>
#endif
#ifndef OPENSSL_NO_ECDSA
#include <openssl/ecdsa.h>
#endif
a79 1
#include <openssl/store.h>
d81 1
a82 4
#endif

#include <openssl/ossl_typ.h>
#include <openssl/symhacks.h>
d88 11
a104 2
#define ENGINE_METHOD_ECDH		(unsigned int)0x0010
#define ENGINE_METHOD_ECDSA		(unsigned int)0x0020
a106 1
#define ENGINE_METHOD_STORE		(unsigned int)0x0100
d176 3
a178 9
						     when calling the password
						     callback and the user
						     interface */
#define ENGINE_CTRL_LOAD_CONFIGURATION		6 /* Load a configuration, given
						     a string that represents a
						     file name or so */
#define ENGINE_CTRL_LOAD_SECTION		7 /* Load data from a given
						     section in the already loaded
						     configuration */
d225 1
a225 1
#define ENGINE_CMD_BASE				200
d260 1
a260 1
typedef int (*ENGINE_GEN_FUNC_PTR)(void);
d264 1
a264 1
typedef int (*ENGINE_CTRL_FUNC_PTR)(ENGINE *, int, long, void *, void (*f)(void));
d308 2
a309 3
#ifndef OPENSSL_NO_STATIC_ENGINE
void ENGINE_load_4758cca(void);
void ENGINE_load_aep(void);
a310 5
void ENGINE_load_chil(void);
void ENGINE_load_cswift(void);
#ifndef OPENSSL_NO_GMP
void ENGINE_load_gmp(void);
#endif
d312 2
d315 1
a315 2
void ENGINE_load_ubsec(void);
#endif
a316 1
void ENGINE_load_padlock(void);
a339 8
int ENGINE_register_ECDH(ENGINE *e);
void ENGINE_unregister_ECDH(ENGINE *e);
void ENGINE_register_all_ECDH(void);

int ENGINE_register_ECDSA(ENGINE *e);
void ENGINE_unregister_ECDSA(ENGINE *e);
void ENGINE_register_all_ECDSA(void);

a347 4
int ENGINE_register_STORE(ENGINE *e);
void ENGINE_unregister_STORE(ENGINE *e);
void ENGINE_register_all_STORE(void);

d370 1
a370 1
int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void));
d383 1
a383 1
        long i, void *p, void (*f)(void), int cmd_optional);
a419 2
int ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *ecdh_meth);
int ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *ecdsa_meth);
a421 1
int ENGINE_set_STORE(ENGINE *e, const STORE_METHOD *store_meth);
d432 2
a433 1
/* These functions allow control over any per-structure ENGINE data. */
a436 1
void *ENGINE_get_ex_data(const ENGINE *e, int idx);
a451 2
const ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *e);
const ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *e);
a453 1
const STORE_METHOD *ENGINE_get_STORE(const ENGINE *e);
d466 1
a503 2
ENGINE *ENGINE_get_default_ECDH(void);
ENGINE *ENGINE_get_default_ECDSA(void);
a518 2
int ENGINE_set_default_ECDH(ENGINE *e);
int ENGINE_set_default_ECDSA(ENGINE *e);
d541 1
a541 1
#define OSSL_DYNAMIC_VERSION		(unsigned long)0x00020000
d544 1
a544 1
#define OSSL_DYNAMIC_OLDEST		(unsigned long)0x00020000
d551 1
a551 4
 * 'state' will be used/changed in all operations. The 'static_state' pointer
 * allows the loaded library to know if it shares the same static data as the
 * calling application (or library), and thus whether these callbacks need to be
 * set or not. */
a578 1
	void 					*static_state;
d596 1
a596 1
	OPENSSL_EXPORT unsigned long v_check(unsigned long v) { \
a617 1
	OPENSSL_EXPORT \
d619 14
a632 13
		if(ENGINE_get_static_state() == fns->static_state) goto skip_cbs; \
		if(!CRYPTO_set_mem_functions(fns->mem_fns.malloc_cb, \
			fns->mem_fns.realloc_cb, fns->mem_fns.free_cb)) \
			return 0; \
		CRYPTO_set_locking_callback(fns->lock_fns.lock_locking_cb); \
		CRYPTO_set_add_lock_callback(fns->lock_fns.lock_add_lock_cb); \
		CRYPTO_set_dynlock_create_callback(fns->lock_fns.dynlock_create_cb); \
		CRYPTO_set_dynlock_lock_callback(fns->lock_fns.dynlock_lock_cb); \
		CRYPTO_set_dynlock_destroy_callback(fns->lock_fns.dynlock_destroy_cb); \
		if(!CRYPTO_set_ex_data_implementation(fns->ex_data_fns)) \
			return 0; \
		if(!ERR_set_implementation(fns->err_fns)) return 0; \
	skip_cbs: \
a635 11
/* If the loading application (or library) and the loaded ENGINE library share
 * the same static data (eg. they're both dynamically linked to the same
 * libcrypto.so) we need a way to avoid trying to set system callbacks - this
 * would fail, and for the same reason that it's unnecessary to try. If the
 * loaded ENGINE has (or gets from through the loader) its own copy of the
 * libcrypto static data, we will need to set the callbacks. The easiest way to
 * detect this is to have a function that returns a pointer to some static data
 * and let the loading application and loaded ENGINE compare their respective
 * values. */
void *ENGINE_get_static_state(void);

a651 1
#define ENGINE_F_DYNAMIC_SET_DATA_CTX			 183
d659 1
a659 1
#define ENGINE_F_ENGINE_FREE_UTIL			 108
d670 1
a678 1
#define ENGINE_F_ENGINE_UNLOCKED_FINISH			 191
a681 1
#define ENGINE_F_INT_ENGINE_MODULE_INIT			 187
d683 1
@


1.1.1.6
log
@import openssl-0.9.8j
@
text
@a95 2
#include <openssl/x509.h>

a280 3
typedef int (*ENGINE_SSL_CLIENT_CERT_PTR)(ENGINE *, SSL *ssl,
	STACK_OF(X509_NAME) *ca_dn, X509 **pcert, EVP_PKEY **pkey,
	STACK_OF(X509) **pother, UI_METHOD *ui_method, void *callback_data);
a336 3
#ifndef OPENSSL_NO_CAPIENG
void ENGINE_load_capi(void);
#endif
a461 2
int ENGINE_set_load_ssl_client_cert_function(ENGINE *e,
				ENGINE_SSL_CLIENT_CERT_PTR loadssl_f);
a496 1
ENGINE_SSL_CLIENT_CERT_PTR ENGINE_get_ssl_client_cert_function(const ENGINE *e);
a531 4
int ENGINE_load_ssl_client_cert(ENGINE *e, SSL *s,
	STACK_OF(X509_NAME) *ca_dn, X509 **pcert, EVP_PKEY **ppkey,
	STACK_OF(X509) **pother,
	UI_METHOD *ui_method, void *callback_data);
a725 1
#define ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT		 192
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d91 1
d96 2
a100 2
#include <openssl/x509.h>

a115 2
#define ENGINE_METHOD_PKEY_METHS	(unsigned int)0x0200
#define ENGINE_METHOD_PKEY_ASN1_METHS	(unsigned int)0x0400
d300 1
a300 2
typedef int (*ENGINE_PKEY_METHS_PTR)(ENGINE *, EVP_PKEY_METHOD **, const int **, int);
typedef int (*ENGINE_PKEY_ASN1_METHS_PTR)(ENGINE *, EVP_PKEY_ASN1_METHOD **, const int **, int);
d332 3
d338 2
d341 2
a343 5
#ifndef OPENSSL_NO_GMP
void ENGINE_load_gmp(void);
#endif
#ifndef OPENSSL_NO_GOST
void ENGINE_load_gost(void);
a344 3
#endif
void ENGINE_load_cryptodev(void);
void ENGINE_load_builtin_engines(void);
a394 8
int ENGINE_register_pkey_meths(ENGINE *e);
void ENGINE_unregister_pkey_meths(ENGINE *e);
void ENGINE_register_all_pkey_meths(void);

int ENGINE_register_pkey_asn1_meths(ENGINE *e);
void ENGINE_unregister_pkey_asn1_meths(ENGINE *e);
void ENGINE_register_all_pkey_asn1_meths(void);

a473 2
int ENGINE_set_pkey_meths(ENGINE *e, ENGINE_PKEY_METHS_PTR f);
int ENGINE_set_pkey_asn1_meths(ENGINE *e, ENGINE_PKEY_ASN1_METHS_PTR f);
a509 2
ENGINE_PKEY_METHS_PTR ENGINE_get_pkey_meths(const ENGINE *e);
ENGINE_PKEY_ASN1_METHS_PTR ENGINE_get_pkey_asn1_meths(const ENGINE *e);
a511 6
const EVP_PKEY_METHOD *ENGINE_get_pkey_meth(ENGINE *e, int nid);
const EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth(ENGINE *e, int nid);
const EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth_str(ENGINE *e,
					const char *str, int len);
const EVP_PKEY_ASN1_METHOD *ENGINE_pkey_asn1_find_str(ENGINE **pe,
					const char *str, int len);
a562 2
ENGINE *ENGINE_get_pkey_meth_engine(int nid);
ENGINE *ENGINE_get_pkey_asn1_meth_engine(int nid);
a577 2
int ENGINE_set_default_pkey_meths(ENGINE *e);
int ENGINE_set_default_pkey_asn1_meths(ENGINE *e);
d706 1
a706 1
#if defined(__OpenBSD__) || defined(__FreeBSD__) || defined(HAVE_CRYPTODEV)
a734 2
#define ENGINE_F_ENGINE_GET_PKEY_ASN1_METH		 193
#define ENGINE_F_ENGINE_GET_PKEY_METH			 192
d741 1
a741 1
#define ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT		 194
a769 1
#define ENGINE_R_ENGINE_CONFIGURATION_ERROR		 102
a795 1
#define ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD	 101
@


1.1.1.8
log
@import OpenSSL 1.0.0e
@
text
@a679 1
	OPENSSL_EXPORT unsigned long v_check(unsigned long v); \
a701 2
	OPENSSL_EXPORT \
	int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns); \
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@a143 7
/* This flag if for an ENGINE that does not want its methods registered as 
 * part of ENGINE_register_all_complete() for example if the methods are
 * not usable as default methods.
 */

#define ENGINE_FLAGS_NO_REGISTER_ALL	(int)0x0008

a346 2
void ENGINE_load_rsax(void);
void ENGINE_load_rdrand(void);
@


