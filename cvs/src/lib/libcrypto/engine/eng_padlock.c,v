head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	2016.11.04.13.56.05;	author miod;	state Exp;
branches;
next	1.14;
commitid	TilmOttV27QFPTgF;

1.14
date	2015.02.07.13.19.15;	author doug;	state Exp;
branches;
next	1.13;
commitid	gtwLkRyWx0K1HbzX;

1.13
date	2014.10.18.17.20.40;	author jsing;	state Exp;
branches;
next	1.12;
commitid	8tb4v3IC8S2vzfHj;

1.12
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.11;
commitid	nzndm3zqPmFurSaK;

1.11
date	2014.06.22.12.05.09;	author jsing;	state Exp;
branches;
next	1.10;
commitid	6PKo4InI2wtFRRxh;

1.10
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	mJUVYpkFBZ0Zv2bG;

1.9
date	2014.05.22.17.53.00;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.28.21.14.50;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.20.16.18.06;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.17.21.17.12;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.14.18.40.47;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.13.55;	author djm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove I386_ONLY define. It was only used to prefer a
faster-on-genuine-80386-but-slower-on-80486-onwards innstruction sequence in
the SHA512 code, and had not been enabled in years, if at all.

ok tom@@ bcook@@
@
text
@/* $OpenBSD: eng_padlock.c,v 1.14 2015/02/07 13:19:15 doug Exp $ */
/*
 * Support for VIA PadLock Advanced Cryptography Engine (ACE)
 * Written by Michal Ludvig <michal@@logix.cz>
 *            http://www.logix.cz/michal
 *
 * Big thanks to Andy Polyakov for a help with optimization,
 * assembler fixes, port to MS Windows and a lot of other
 * valuable work on this engine!
 */

/* ====================================================================
 * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/crypto.h>
#include <openssl/dso.h>
#include <openssl/engine.h>
#include <openssl/evp.h>
#ifndef OPENSSL_NO_AES
#include <openssl/aes.h>
#endif
#include <openssl/err.h>

#ifndef OPENSSL_NO_HW
#ifndef OPENSSL_NO_HW_PADLOCK

/* Attempt to have a single source for both 0.9.7 and 0.9.8 :-) */
#if (OPENSSL_VERSION_NUMBER >= 0x00908000L)
#  ifndef OPENSSL_NO_DYNAMIC_ENGINE
#    define DYNAMIC_ENGINE
#  endif
#elif (OPENSSL_VERSION_NUMBER >= 0x00907000L)
#  ifdef ENGINE_DYNAMIC_SUPPORT
#    define DYNAMIC_ENGINE
#  endif
#else
#  error "Only OpenSSL >= 0.9.7 is supported"
#endif

/* VIA PadLock AES is available *ONLY* on some x86 CPUs.
   Not only that it doesn't exist elsewhere, but it
   even can't be compiled on other platforms!

   In addition, because of the heavy use of inline assembler,
   compiler choice is limited to GCC and Microsoft C. */
#undef COMPILE_HW_PADLOCK
#if !defined(OPENSSL_NO_INLINE_ASM)
# if (defined(__GNUC__) && (defined(__i386__) || defined(__i386)))
#  define COMPILE_HW_PADLOCK
# endif
#endif

#ifdef OPENSSL_NO_DYNAMIC_ENGINE
#ifdef COMPILE_HW_PADLOCK
static ENGINE *ENGINE_padlock (void);
#endif

void ENGINE_load_padlock (void)
{
/* On non-x86 CPUs it just returns. */
#ifdef COMPILE_HW_PADLOCK
	ENGINE *toadd = ENGINE_padlock ();
	if (!toadd)
		return;
	ENGINE_add (toadd);
	ENGINE_free (toadd);
	ERR_clear_error ();
#endif
}

#endif

#ifdef COMPILE_HW_PADLOCK
/* We do these includes here to avoid header problems on platforms that
   do not have the VIA padlock anyway... */
#include <stdlib.h>
#if defined(__GNUC__)
# ifndef alloca
#  define alloca(s) __builtin_alloca(s)
# endif
#endif

/* Function for ENGINE detection and control */
static int padlock_available(void);
static int padlock_init(ENGINE *e);

/* RNG Stuff */
static RAND_METHOD padlock_rand;

/* Cipher Stuff */
#ifndef OPENSSL_NO_AES
static int padlock_ciphers(ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid);
#endif

/* Engine names */
static const char *padlock_id = "padlock";
static char padlock_name[100];

/* Available features */
static int padlock_use_ace = 0;	/* Advanced Cryptography Engine */
static int padlock_use_rng = 0;	/* Random Number Generator */
#ifndef OPENSSL_NO_AES
static int padlock_aes_align_required = 1;
#endif

/* ===== Engine "management" functions ===== */

/* Prepare the ENGINE structure for registration */
static int
padlock_bind_helper(ENGINE *e)
{
	/* Check available features */
	padlock_available();

	/*
	 * RNG is currently disabled for reasons discussed in commentary just
	 * before padlock_rand_bytes function.
	 */
	padlock_use_rng = 0;

	/* Generate a nice engine name with available features */
	(void) snprintf(padlock_name, sizeof(padlock_name),
	    "VIA PadLock (%s, %s)",
	    padlock_use_rng ? "RNG" : "no-RNG",
	    padlock_use_ace ? "ACE" : "no-ACE");

	/* Register everything or return with an error */
	if (!ENGINE_set_id(e, padlock_id) ||
	    !ENGINE_set_name(e, padlock_name) ||
	    !ENGINE_set_init_function(e, padlock_init) ||
#ifndef OPENSSL_NO_AES
	    (padlock_use_ace && !ENGINE_set_ciphers (e, padlock_ciphers)) ||
#endif
	    (padlock_use_rng && !ENGINE_set_RAND (e, &padlock_rand))) {
		return 0;
	}

	/* Everything looks good */
	return 1;
}

#ifdef OPENSSL_NO_DYNAMIC_ENGINE

/* Constructor */
static ENGINE *
ENGINE_padlock(void)
{
	ENGINE *eng = ENGINE_new();

	if (!eng) {
		return NULL;
	}

	if (!padlock_bind_helper(eng)) {
		ENGINE_free(eng);
		return NULL;
	}

	return eng;
}

#endif

/* Check availability of the engine */
static int
padlock_init(ENGINE *e)
{
	return (padlock_use_rng || padlock_use_ace);
}

/* This stuff is needed if this ENGINE is being compiled into a self-contained
 * shared-library.
 */
#ifdef DYNAMIC_ENGINE
static int
padlock_bind_fn(ENGINE *e, const char *id)
{
	if (id && (strcmp(id, padlock_id) != 0)) {
		return 0;
	}

	if (!padlock_bind_helper(e))  {
		return 0;
	}

	return 1;
}

IMPLEMENT_DYNAMIC_CHECK_FN()
IMPLEMENT_DYNAMIC_BIND_FN (padlock_bind_fn)
#endif /* DYNAMIC_ENGINE */

/* ===== Here comes the "real" engine ===== */

#ifndef OPENSSL_NO_AES
/* Some AES-related constants */
#define AES_BLOCK_SIZE		16
#define AES_KEY_SIZE_128	16
#define AES_KEY_SIZE_192	24
#define AES_KEY_SIZE_256	32

/* Here we store the status information relevant to the
   current context. */
/* BIG FAT WARNING:
 * 	Inline assembler in PADLOCK_XCRYPT_ASM()
 * 	depends on the order of items in this structure.
 * 	Don't blindly modify, reorder, etc!
 */
struct padlock_cipher_data {
	unsigned char iv[AES_BLOCK_SIZE];	/* Initialization vector */
	union {
		unsigned int pad[4];
		struct {
			int rounds : 4;
			int dgst : 1;	/* n/a in C3 */
			int align : 1;	/* n/a in C3 */
			int ciphr : 1;	/* n/a in C3 */
			unsigned int keygen : 1;
			int interm : 1;
			unsigned int encdec : 1;
			int ksize : 2;
		} b;
	} cword;		/* Control word */
	AES_KEY ks;		/* Encryption key */
};

/*
 * Essentially this variable belongs in thread local storage.
 * Having this variable global on the other hand can only cause
 * few bogus key reloads [if any at all on single-CPU system],
 * so we accept the penatly...
 */
static volatile struct padlock_cipher_data *padlock_saved_context;
#endif

/*
 * =======================================================
 * Inline assembler section(s).
 * =======================================================
 * Order of arguments is chosen to facilitate Windows port
 * using __fastcall calling convention. If you wish to add
 * more routines, keep in mind that first __fastcall
 * argument is passed in %ecx and second - in %edx.
 * =======================================================
 */
#if defined(__GNUC__) && __GNUC__>=2
/*
 * As for excessive "push %ebx"/"pop %ebx" found all over.
 * When generating position-independent code GCC won't let
 * us use "b" in assembler templates nor even respect "ebx"
 * in "clobber description." Therefore the trouble...
 */

/* Helper function - check if a CPUID instruction
   is available on this CPU */
static int
padlock_insn_cpuid_available(void)
{
	int result = -1;

	/* We're checking if the bit #21 of EFLAGS
	   can be toggled. If yes = CPUID is available. */
	asm volatile (
	    "pushf\n"
	    "popl %%eax\n"
	    "xorl $0x200000, %%eax\n"
	    "movl %%eax, %%ecx\n"
	    "andl $0x200000, %%ecx\n"
	    "pushl %%eax\n"
	    "popf\n"
	    "pushf\n"
	    "popl %%eax\n"
	    "andl $0x200000, %%eax\n"
	    "xorl %%eax, %%ecx\n"
	    "movl %%ecx, %0\n"
	    : "=r" (result) : : "eax", "ecx");

	return (result == 0);
}

/* Load supported features of the CPU to see if
   the PadLock is available. */
static int
padlock_available(void)
{
	char vendor_string[16];
	unsigned int eax, edx;

	/* First check if the CPUID instruction is available at all... */
	if (! padlock_insn_cpuid_available())
		return 0;

	/* Are we running on the Centaur (VIA) CPU? */
	eax = 0x00000000;
	vendor_string[12] = 0;
	asm volatile (
	    "pushl	%%ebx\n"
	    "cpuid\n"
	    "movl	%%ebx,(%%edi)\n"
	    "movl	%%edx,4(%%edi)\n"
	    "movl	%%ecx,8(%%edi)\n"
	    "popl	%%ebx"
	    : "+a"(eax) : "D"(vendor_string) : "ecx", "edx");
	if (strcmp(vendor_string, "CentaurHauls") != 0)
		return 0;

	/* Check for Centaur Extended Feature Flags presence */
	eax = 0xC0000000;
	asm volatile ("pushl %%ebx; cpuid; popl	%%ebx"
	    : "+a"(eax) : : "ecx", "edx");
	if (eax < 0xC0000001)
		return 0;

	/* Read the Centaur Extended Feature Flags */
	eax = 0xC0000001;
	asm volatile ("pushl %%ebx; cpuid; popl %%ebx"
	    : "+a"(eax), "=d"(edx) : : "ecx");

	/* Fill up some flags */
	padlock_use_ace = ((edx & (0x3 << 6)) == (0x3 << 6));
	padlock_use_rng = ((edx & (0x3 << 2)) == (0x3 << 2));

	return padlock_use_ace + padlock_use_rng;
}

#ifndef OPENSSL_NO_AES
/* Our own htonl()/ntohl() */
static inline void
padlock_bswapl(AES_KEY *ks)
{
	size_t i = sizeof(ks->rd_key)/sizeof(ks->rd_key[0]);
	unsigned int *key = ks->rd_key;

	while (i--) {
		asm volatile ("bswapl %0" : "+r"(*key));
		key++;
	}
}
#endif

/* Force key reload from memory to the CPU microcode.
   Loading EFLAGS from the stack clears EFLAGS[30]
   which does the trick. */
static inline void
padlock_reload_key(void)
{
	asm volatile ("pushfl; popfl");
}

#ifndef OPENSSL_NO_AES
/*
 * This is heuristic key context tracing. At first one
 * believes that one should use atomic swap instructions,
 * but it's not actually necessary. Point is that if
 * padlock_saved_context was changed by another thread
 * after we've read it and before we compare it with cdata,
 * our key *shall* be reloaded upon thread context switch
 * and we are therefore set in either case...
 */
static inline void
padlock_verify_context(struct padlock_cipher_data *cdata)
{
	asm volatile (
	    "pushfl\n"
	    "	btl	$30,(%%esp)\n"
	    "	jnc	1f\n"
	    "	cmpl	%2,%1\n"
	    "	je	1f\n"
	    "	popfl\n"
	    "	subl	$4,%%esp\n"
	    "1:	addl	$4,%%esp\n"
	    "	movl	%2,%0"
	    :"+m"(padlock_saved_context)
	: "r"(padlock_saved_context), "r"(cdata) : "cc");
}

/* Template for padlock_xcrypt_* modes */
/* BIG FAT WARNING:
 * 	The offsets used with 'leal' instructions
 * 	describe items of the 'padlock_cipher_data'
 * 	structure.
 */
#define PADLOCK_XCRYPT_ASM(name,rep_xcrypt)	\
static inline void *name(size_t cnt,		\
	struct padlock_cipher_data *cdata,	\
	void *out, const void *inp) 		\
{	void *iv; 				\
	asm volatile ( "pushl	%%ebx\n"	\
		"	leal	16(%0),%%edx\n"	\
		"	leal	32(%0),%%ebx\n"	\
			rep_xcrypt "\n"		\
		"	popl	%%ebx"		\
		: "=a"(iv), "=c"(cnt), "=D"(out), "=S"(inp) \
		: "0"(cdata), "1"(cnt), "2"(out), "3"(inp)  \
		: "edx", "cc", "memory");	\
	return iv;				\
}

/* Generate all functions with appropriate opcodes */
PADLOCK_XCRYPT_ASM(padlock_xcrypt_ecb, ".byte 0xf3,0x0f,0xa7,0xc8")	/* rep xcryptecb */
PADLOCK_XCRYPT_ASM(padlock_xcrypt_cbc, ".byte 0xf3,0x0f,0xa7,0xd0")	/* rep xcryptcbc */
PADLOCK_XCRYPT_ASM(padlock_xcrypt_cfb, ".byte 0xf3,0x0f,0xa7,0xe0")	/* rep xcryptcfb */
PADLOCK_XCRYPT_ASM(padlock_xcrypt_ofb, ".byte 0xf3,0x0f,0xa7,0xe8")	/* rep xcryptofb */
#endif

/* The RNG call itself */
static inline unsigned int
padlock_xstore(void *addr, unsigned int edx_in)
{
	unsigned int eax_out;

	asm volatile (".byte 0x0f,0xa7,0xc0"	/* xstore */
	: "=a"(eax_out),"=m"(*(unsigned *)addr)
	: "D"(addr), "d" (edx_in)
	);

	return eax_out;
}

/* Why not inline 'rep movsd'? I failed to find information on what
 * value in Direction Flag one can expect and consequently have to
 * apply "better-safe-than-sorry" approach and assume "undefined."
 * I could explicitly clear it and restore the original value upon
 * return from padlock_aes_cipher, but it's presumably too much
 * trouble for too little gain...
 *
 * In case you wonder 'rep xcrypt*' instructions above are *not*
 * affected by the Direction Flag and pointers advance toward
 * larger addresses unconditionally.
 */
static inline unsigned char *
padlock_memcpy(void *dst, const void *src, size_t n)
{
	long       *d = dst;
	const long *s = src;

	n /= sizeof(*d);
		do { *d++ = *s++;
	} while (--n);

	return dst;
}
#endif

/* ===== AES encryption/decryption ===== */
#ifndef OPENSSL_NO_AES

#if defined(NID_aes_128_cfb128) && ! defined (NID_aes_128_cfb)
#define NID_aes_128_cfb	NID_aes_128_cfb128
#endif

#if defined(NID_aes_128_ofb128) && ! defined (NID_aes_128_ofb)
#define NID_aes_128_ofb	NID_aes_128_ofb128
#endif

#if defined(NID_aes_192_cfb128) && ! defined (NID_aes_192_cfb)
#define NID_aes_192_cfb	NID_aes_192_cfb128
#endif

#if defined(NID_aes_192_ofb128) && ! defined (NID_aes_192_ofb)
#define NID_aes_192_ofb	NID_aes_192_ofb128
#endif

#if defined(NID_aes_256_cfb128) && ! defined (NID_aes_256_cfb)
#define NID_aes_256_cfb	NID_aes_256_cfb128
#endif

#if defined(NID_aes_256_ofb128) && ! defined (NID_aes_256_ofb)
#define NID_aes_256_ofb	NID_aes_256_ofb128
#endif

/* List of supported ciphers. */
static int padlock_cipher_nids[] = {
	NID_aes_128_ecb,
	NID_aes_128_cbc,
	NID_aes_128_cfb,
	NID_aes_128_ofb,

	NID_aes_192_ecb,
	NID_aes_192_cbc,
	NID_aes_192_cfb,
	NID_aes_192_ofb,

	NID_aes_256_ecb,
	NID_aes_256_cbc,
	NID_aes_256_cfb,
	NID_aes_256_ofb,
};
static int padlock_cipher_nids_num = (sizeof(padlock_cipher_nids)/
sizeof(padlock_cipher_nids[0]));

/* Function prototypes ... */
static int padlock_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc);
static int padlock_aes_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t nbytes);

#define NEAREST_ALIGNED(ptr) ( (unsigned char *)(ptr) +		\
	( (0x10 - ((size_t)(ptr) & 0x0F)) & 0x0F )	)
#define ALIGNED_CIPHER_DATA(ctx) ((struct padlock_cipher_data *)\
	NEAREST_ALIGNED(ctx->cipher_data))

#define EVP_CIPHER_block_size_ECB	AES_BLOCK_SIZE
#define EVP_CIPHER_block_size_CBC	AES_BLOCK_SIZE
#define EVP_CIPHER_block_size_OFB	1
#define EVP_CIPHER_block_size_CFB	1

/* Declaring so many ciphers by hand would be a pain.
   Instead introduce a bit of preprocessor magic :-) */
#define	DECLARE_AES_EVP(ksize,lmode,umode)	\
static const EVP_CIPHER padlock_aes_##ksize##_##lmode = {	\
	NID_aes_##ksize##_##lmode,		\
	EVP_CIPHER_block_size_##umode,	\
	AES_KEY_SIZE_##ksize,		\
	AES_BLOCK_SIZE,			\
	0 | EVP_CIPH_##umode##_MODE,	\
	padlock_aes_init_key,		\
	padlock_aes_cipher,		\
	NULL,				\
	sizeof(struct padlock_cipher_data) + 16,	\
	EVP_CIPHER_set_asn1_iv,		\
	EVP_CIPHER_get_asn1_iv,		\
	NULL,				\
	NULL				\
}

DECLARE_AES_EVP(128, ecb, ECB);
DECLARE_AES_EVP(128, cbc, CBC);
DECLARE_AES_EVP(128, cfb, CFB);
DECLARE_AES_EVP(128, ofb, OFB);

DECLARE_AES_EVP(192, ecb, ECB);
DECLARE_AES_EVP(192, cbc, CBC);
DECLARE_AES_EVP(192, cfb, CFB);
DECLARE_AES_EVP(192, ofb, OFB);

DECLARE_AES_EVP(256, ecb, ECB);
DECLARE_AES_EVP(256, cbc, CBC);
DECLARE_AES_EVP(256, cfb, CFB);
DECLARE_AES_EVP(256, ofb, OFB);

static int
padlock_ciphers(ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid)
{
	/* No specific cipher => return a list of supported nids ... */
	if (!cipher) {
		*nids = padlock_cipher_nids;
		return padlock_cipher_nids_num;
	}

	/* ... or the requested "cipher" otherwise */
	switch (nid) {
	case NID_aes_128_ecb:
		*cipher = &padlock_aes_128_ecb;
		break;
	case NID_aes_128_cbc:
		*cipher = &padlock_aes_128_cbc;
		break;
	case NID_aes_128_cfb:
		*cipher = &padlock_aes_128_cfb;
		break;
	case NID_aes_128_ofb:
		*cipher = &padlock_aes_128_ofb;
		break;
	case NID_aes_192_ecb:
		*cipher = &padlock_aes_192_ecb;
		break;
	case NID_aes_192_cbc:
		*cipher = &padlock_aes_192_cbc;
		break;
	case NID_aes_192_cfb:
		*cipher = &padlock_aes_192_cfb;
		break;
	case NID_aes_192_ofb:
		*cipher = &padlock_aes_192_ofb;
		break;
	case NID_aes_256_ecb:
		*cipher = &padlock_aes_256_ecb;
		break;
	case NID_aes_256_cbc:
		*cipher = &padlock_aes_256_cbc;
		break;
	case NID_aes_256_cfb:
		*cipher = &padlock_aes_256_cfb;
		break;
	case NID_aes_256_ofb:
		*cipher = &padlock_aes_256_ofb;
		break;
	default:
		/* Sorry, we don't support this NID */
		*cipher = NULL;
		return 0;
	}

	return 1;
}

/* Prepare the encryption key for PadLock usage */
static int
padlock_aes_init_key (EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	struct padlock_cipher_data *cdata;
	int key_len = EVP_CIPHER_CTX_key_length(ctx) * 8;

	if (key == NULL)
		return 0;	/* ERROR */

	cdata = ALIGNED_CIPHER_DATA(ctx);
	memset(cdata, 0, sizeof(struct padlock_cipher_data));

	/* Prepare Control word. */
	if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_OFB_MODE)
		cdata->cword.b.encdec = 0;
	else
		cdata->cword.b.encdec = (ctx->encrypt == 0);
	cdata->cword.b.rounds = 10 + (key_len - 128) / 32;
	cdata->cword.b.ksize = (key_len - 128) / 64;

	switch (key_len) {
	case 128:
		/* PadLock can generate an extended key for
		   AES128 in hardware */
		memcpy(cdata->ks.rd_key, key, AES_KEY_SIZE_128);
		cdata->cword.b.keygen = 0;
		break;

	case 192:
	case 256:
		/* Generate an extended AES key in software.
		   Needed for AES192/AES256 */
		/* Well, the above applies to Stepping 8 CPUs
		   and is listed as hardware errata. They most
		   likely will fix it at some point and then
		   a check for stepping would be due here. */
		if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CFB_MODE ||
		    EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_OFB_MODE ||
		    enc)
			AES_set_encrypt_key(key, key_len, &cdata->ks);
		else
			AES_set_decrypt_key(key, key_len, &cdata->ks);
#ifndef AES_ASM
		/* OpenSSL C functions use byte-swapped extended key. */
		padlock_bswapl(&cdata->ks);
#endif
		cdata->cword.b.keygen = 1;
		break;

	default:
		/* ERROR */
		return 0;
	}

	/*
	 * This is done to cover for cases when user reuses the
	 * context for new key. The catch is that if we don't do
	 * this, padlock_eas_cipher might proceed with old key...
	 */
	padlock_reload_key ();

	return 1;
}

/*
 * Simplified version of padlock_aes_cipher() used when
 * 1) both input and output buffers are at aligned addresses.
 * or when
 * 2) running on a newer CPU that doesn't require aligned buffers.
 */
static int
padlock_aes_cipher_omnivorous(EVP_CIPHER_CTX *ctx, unsigned char *out_arg,
    const unsigned char *in_arg, size_t nbytes)
{
	struct padlock_cipher_data *cdata;
	void  *iv;

	cdata = ALIGNED_CIPHER_DATA(ctx);
	padlock_verify_context(cdata);

	switch (EVP_CIPHER_CTX_mode(ctx)) {
	case EVP_CIPH_ECB_MODE:
		padlock_xcrypt_ecb(nbytes / AES_BLOCK_SIZE, cdata,
		    out_arg, in_arg);
		break;

	case EVP_CIPH_CBC_MODE:
		memcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);
		iv = padlock_xcrypt_cbc(nbytes / AES_BLOCK_SIZE, cdata,
		    out_arg, in_arg);
		memcpy(ctx->iv, iv, AES_BLOCK_SIZE);
		break;

	case EVP_CIPH_CFB_MODE:
		memcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);
		iv = padlock_xcrypt_cfb(nbytes / AES_BLOCK_SIZE, cdata,
		    out_arg, in_arg);
		memcpy(ctx->iv, iv, AES_BLOCK_SIZE);
		break;

	case EVP_CIPH_OFB_MODE:
		memcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);
		padlock_xcrypt_ofb(nbytes / AES_BLOCK_SIZE, cdata,
		    out_arg, in_arg);
		memcpy(ctx->iv, cdata->iv, AES_BLOCK_SIZE);
		break;

	default:
		return 0;
	}

	memset(cdata->iv, 0, AES_BLOCK_SIZE);

	return 1;
}

#ifndef  PADLOCK_CHUNK
# define PADLOCK_CHUNK	512	/* Must be a power of 2 larger than 16 */
#endif
#if PADLOCK_CHUNK<16 || PADLOCK_CHUNK&(PADLOCK_CHUNK-1)
# error "insane PADLOCK_CHUNK..."
#endif

/* Re-align the arguments to 16-Bytes boundaries and run the
   encryption function itself. This function is not AES-specific. */
static int
padlock_aes_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out_arg,
    const unsigned char *in_arg, size_t nbytes)
{
	struct padlock_cipher_data *cdata;
	const  void *inp;
	unsigned char  *out;
	void  *iv;
	int    inp_misaligned, out_misaligned, realign_in_loop;
	size_t chunk, allocated = 0;

	/* ctx->num is maintained in byte-oriented modes,
	   such as CFB and OFB... */
	if ((chunk = ctx->num)) {
		/* borrow chunk variable */
		unsigned char *ivp = ctx->iv;

		switch (EVP_CIPHER_CTX_mode(ctx)) {
		case EVP_CIPH_CFB_MODE:
			if (chunk >= AES_BLOCK_SIZE)
				return 0; /* bogus value */

			if (ctx->encrypt)
				while (chunk < AES_BLOCK_SIZE && nbytes != 0) {
					ivp[chunk] = *(out_arg++) = *(in_arg++) ^ ivp[chunk];
					chunk++, nbytes--;
				}
			else
				while (chunk < AES_BLOCK_SIZE && nbytes != 0) {
					unsigned char c = *(in_arg++);
					*(out_arg++) = c ^ ivp[chunk];
					ivp[chunk++] = c, nbytes--;
				}

			ctx->num = chunk % AES_BLOCK_SIZE;
			break;
		case EVP_CIPH_OFB_MODE:
			if (chunk >= AES_BLOCK_SIZE)
				return 0; /* bogus value */

			while (chunk < AES_BLOCK_SIZE && nbytes != 0) {
				*(out_arg++) = *(in_arg++) ^ ivp[chunk];
				chunk++, nbytes--;
			}

			ctx->num = chunk % AES_BLOCK_SIZE;
			break;
		}
	}

	if (nbytes == 0)
		return 1;
#if 0
	if (nbytes % AES_BLOCK_SIZE)
		return 0; /* are we expected to do tail processing? */
#else
	/* nbytes is always multiple of AES_BLOCK_SIZE in ECB and CBC
	   modes and arbitrary value in byte-oriented modes, such as
	   CFB and OFB... */
#endif

	/* VIA promises CPUs that won't require alignment in the future.
	   For now padlock_aes_align_required is initialized to 1 and
	   the condition is never met... */
	/* C7 core is capable to manage unaligned input in non-ECB[!]
	   mode, but performance penalties appear to be approximately
	   same as for software alignment below or ~3x. They promise to
	   improve it in the future, but for now we can just as well
	   pretend that it can only handle aligned input... */
	if (!padlock_aes_align_required && (nbytes % AES_BLOCK_SIZE) == 0)
		return padlock_aes_cipher_omnivorous(ctx, out_arg, in_arg,
		    nbytes);

	inp_misaligned = (((size_t)in_arg) & 0x0F);
	out_misaligned = (((size_t)out_arg) & 0x0F);

	/* Note that even if output is aligned and input not,
	 * I still prefer to loop instead of copy the whole
	 * input and then encrypt in one stroke. This is done
	 * in order to improve L1 cache utilization... */
	realign_in_loop = out_misaligned|inp_misaligned;

	if (!realign_in_loop && (nbytes % AES_BLOCK_SIZE) == 0)
		return padlock_aes_cipher_omnivorous(ctx, out_arg, in_arg,
		    nbytes);

	/* this takes one "if" out of the loops */
	chunk = nbytes;
	chunk %= PADLOCK_CHUNK;
	if (chunk == 0)
		chunk = PADLOCK_CHUNK;

	if (out_misaligned) {
		/* optmize for small input */
		allocated = (chunk < nbytes ? PADLOCK_CHUNK : nbytes);
		out = alloca(0x10 + allocated);
		out = NEAREST_ALIGNED(out);
	} else
		out = out_arg;

	cdata = ALIGNED_CIPHER_DATA(ctx);
	padlock_verify_context(cdata);

	switch (EVP_CIPHER_CTX_mode(ctx)) {
	case EVP_CIPH_ECB_MODE:
		do {
			if (inp_misaligned)
				inp = padlock_memcpy(out, in_arg, chunk);
			else
				inp = in_arg;
			in_arg += chunk;

			padlock_xcrypt_ecb(chunk / AES_BLOCK_SIZE, cdata,
			    out, inp);

			if (out_misaligned)
				out_arg = padlock_memcpy(out_arg, out, chunk) +
				    chunk;
			else
				out = out_arg += chunk;

			nbytes -= chunk;
			chunk = PADLOCK_CHUNK;
		} while (nbytes);
		break;

	case EVP_CIPH_CBC_MODE:
		memcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);
		goto cbc_shortcut;
		do {
			if (iv != cdata->iv)
				memcpy(cdata->iv, iv, AES_BLOCK_SIZE);
			chunk = PADLOCK_CHUNK;
			cbc_shortcut: /* optimize for small input */
			if (inp_misaligned)
				inp = padlock_memcpy(out, in_arg, chunk);
			else
				inp = in_arg;
			in_arg += chunk;

			iv = padlock_xcrypt_cbc(chunk / AES_BLOCK_SIZE, cdata,
			    out, inp);

			if (out_misaligned)
				out_arg = padlock_memcpy(out_arg, out, chunk) +
				    chunk;
			else
				out = out_arg += chunk;
		} while (nbytes -= chunk);
		memcpy(ctx->iv, iv, AES_BLOCK_SIZE);
		break;

	case EVP_CIPH_CFB_MODE:
		memcpy (iv = cdata->iv, ctx->iv, AES_BLOCK_SIZE);
		chunk &= ~(AES_BLOCK_SIZE - 1);
		if (chunk)
			goto cfb_shortcut;
		else
			goto cfb_skiploop;
		do {
			if (iv != cdata->iv)
				memcpy(cdata->iv, iv, AES_BLOCK_SIZE);
			chunk = PADLOCK_CHUNK;
			cfb_shortcut: /* optimize for small input */
			if (inp_misaligned)
				inp = padlock_memcpy(out, in_arg, chunk);
			else
				inp = in_arg;
			in_arg += chunk;

			iv = padlock_xcrypt_cfb(chunk / AES_BLOCK_SIZE, cdata,
			    out, inp);

			if (out_misaligned)
				out_arg = padlock_memcpy(out_arg, out, chunk) +
				    chunk;
			else
				out = out_arg += chunk;

			nbytes -= chunk;
		} while (nbytes >= AES_BLOCK_SIZE);

cfb_skiploop:
		if (nbytes) {
			unsigned char *ivp = cdata->iv;

			if (iv != ivp) {
				memcpy(ivp, iv, AES_BLOCK_SIZE);
				iv = ivp;
			}
			ctx->num = nbytes;
			if (cdata->cword.b.encdec) {
				cdata->cword.b.encdec = 0;
				padlock_reload_key();
				padlock_xcrypt_ecb(1, cdata, ivp, ivp);
				cdata->cword.b.encdec = 1;
				padlock_reload_key();
				while (nbytes) {
					unsigned char c = *(in_arg++);
					*(out_arg++) = c ^ *ivp;
					*(ivp++) = c, nbytes--;
				}
			} else {
				padlock_reload_key();
				padlock_xcrypt_ecb(1, cdata, ivp, ivp);
				padlock_reload_key();
				while (nbytes) {
					*ivp = *(out_arg++) = *(in_arg++) ^ *ivp;
					ivp++, nbytes--;
				}
			}
		}

		memcpy(ctx->iv, iv, AES_BLOCK_SIZE);
		break;

	case EVP_CIPH_OFB_MODE:
		memcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);
		chunk &= ~(AES_BLOCK_SIZE - 1);
		if (chunk) do	{
			if (inp_misaligned)
				inp = padlock_memcpy(out, in_arg, chunk);
			else
				inp = in_arg;
			in_arg += chunk;

			padlock_xcrypt_ofb(chunk / AES_BLOCK_SIZE, cdata,
			    out, inp);

			if (out_misaligned)
				out_arg = padlock_memcpy(out_arg, out, chunk) +
				    chunk;
			else
				out = out_arg += chunk;

			nbytes -= chunk;
			chunk = PADLOCK_CHUNK;
		} while (nbytes >= AES_BLOCK_SIZE);

		if (nbytes) {
			unsigned char *ivp = cdata->iv;

			ctx->num = nbytes;
			padlock_reload_key();	/* empirically found */
			padlock_xcrypt_ecb(1, cdata, ivp, ivp);
			padlock_reload_key();	/* empirically found */
			while (nbytes) {
				*(out_arg++) = *(in_arg++) ^ *ivp;
				ivp++, nbytes--;
			}
		}

		memcpy(ctx->iv, cdata->iv, AES_BLOCK_SIZE);
		break;

	default:
		return 0;
	}

	/* Clean the realign buffer if it was used */
	if (out_misaligned) {
		volatile unsigned long *p = (void *)out;
		size_t n = allocated/sizeof(*p);
		while (n--)
			*p++ = 0;
	}

	memset(cdata->iv, 0, AES_BLOCK_SIZE);

	return 1;
}

#endif /* OPENSSL_NO_AES */

/* ===== Random Number Generator ===== */
/*
 * This code is not engaged. The reason is that it does not comply
 * with recommendations for VIA RNG usage for secure applications
 * (posted at http://www.via.com.tw/en/viac3/c3.jsp) nor does it
 * provide meaningful error control...
 */
/* Wrapper that provides an interface between the API and
   the raw PadLock RNG */
static int
padlock_rand_bytes(unsigned char *output, int count)
{
	unsigned int eax, buf;

	while (count >= 8) {
		eax = padlock_xstore(output, 0);
		if (!(eax & (1 << 6)))
			return 0; /* RNG disabled */
		/* this ---vv--- covers DC bias, Raw Bits and String Filter */
		if (eax & (0x1F << 10))
			return 0;
		if ((eax & 0x1F) == 0)
			continue; /* no data, retry... */
		if ((eax & 0x1F) != 8)
			return 0; /* fatal failure...  */
		output += 8;
		count -= 8;
	}
	while (count > 0) {
		eax = padlock_xstore(&buf, 3);
		if (!(eax & (1 << 6)))
			return 0; /* RNG disabled */
		/* this ---vv--- covers DC bias, Raw Bits and String Filter */
		if (eax & (0x1F << 10))
			return 0;
		if ((eax & 0x1F) == 0)
			continue; /* no data, retry... */
		if ((eax & 0x1F) != 1)
			return 0; /* fatal failure...  */
		*output++ = (unsigned char)buf;
		count--;
	}
	*(volatile unsigned int *)&buf = 0;

	return 1;
}

/* Dummy but necessary function */
static int
padlock_rand_status(void)
{
	return 1;
}

/* Prepare structure for registration */
static RAND_METHOD padlock_rand = {
	.bytes = padlock_rand_bytes,
	.pseudorand = padlock_rand_bytes,
	.status = padlock_rand_status
};

#else  /* !COMPILE_HW_PADLOCK */
#ifndef OPENSSL_NO_DYNAMIC_ENGINE
extern int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns);
extern int
bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) {
	return 0;
}
IMPLEMENT_DYNAMIC_CHECK_FN()
#endif
#endif /* COMPILE_HW_PADLOCK */

#endif /* !OPENSSL_NO_HW_PADLOCK */
#endif /* !OPENSSL_NO_HW */
@


1.14
log
@Delete a lot of #if 0 code in libressl.

There are a few instances where #if 1 is removed but the code remains.

Based on the following OpenSSL commits.  Some of the commits weren't
strictly deletions so they are going to be split up into separate commits.

6f91b017bbb7140f816721141ac156d1b828a6b3
3d47c1d331fdc7574d2275cda1a630ccdb624b08
dfb56425b68314b2b57e17c82c1df42e7a015132
c8fa2356a00cbaada8963f739e5570298311a060
f16a64d11f55c01f56baa62ebf1dec7f8fe718cb
9ccc00ef6ea65567622e40c49aca43f2c6d79cdb
02a938c953b3e1ced71d9a832de1618f907eb96d
75d0ebef2aef7a2c77b27575b8da898e22f3ccd5
d6fbb194095312f4722c81c9362dbd0de66cb656
6f1a93ad111c7dfe36a09a976c4c009079b19ea1
1a5adcfb5edfe23908b350f8757df405b0f5f71f
8de24b792743d11e1d5a0dcd336a49368750c577
a2b18e657ea1a932d125154f4e13ab2258796d90
8e964419603d2478dfb391c66e7ccb2dcc9776b4
32dfde107636ac9bc62a5b3233fe2a54dbc27008

input + ok jsing@@, miod@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: eng_padlock.c,v 1.13 2014/10/18 17:20:40 jsing Exp $ */
d103 1
a103 1
#if !defined(I386_ONLY) && !defined(OPENSSL_NO_INLINE_ASM)
@


1.13
log
@None of these need to include <openssl/rand.h>
@
text
@d1 1
a1 1
/* $OpenBSD: eng_padlock.c,v 1.12 2014/07/10 22:45:57 jsing Exp $ */
d171 4
a174 1
#if 1	/* disable RNG for now, see commentary in vicinity of RNG code */
a175 1
#endif
@


1.12
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: eng_padlock.c,v 1.11 2014/06/22 12:05:09 jsing Exp $ */
a77 1
#include <openssl/rand.h>
@


1.11
log
@KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: eng_padlock.c,v 1.10 2014/06/12 15:49:29 deraadt Exp $ */
a65 1

d70 1
@


1.10
log
@tags as requested by miod and tedu
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* 
d7 2
a8 2
 * Big thanks to Andy Polyakov for a help with optimization, 
 * assembler fixes, port to MS Windows and a lot of other 
d100 1
a100 1
 
d120 2
a121 1
	if (!toadd) return;
d173 1
a173 1
	padlock_use_rng=0;
d178 3
a180 3
		"VIA PadLock (%s, %s)", 
		 padlock_use_rng ? "RNG" : "no-RNG",
		 padlock_use_ace ? "ACE" : "no-ACE");
d182 1
a182 1
	/* Register everything or return with an error */ 
a184 1

d257 1
a257 1
/* Here we store the status information relevant to the 
d264 1
a264 2
struct padlock_cipher_data
{
d266 2
a267 1
	union {	unsigned int pad[4];
d269 8
a276 8
			int rounds:4;
			int dgst:1;	/* n/a in C3 */
			int align:1;	/* n/a in C3 */
			int ciphr:1;	/* n/a in C3 */
			unsigned int keygen:1;
			int interm:1;
			unsigned int encdec:1;
			int ksize:2;
d316 1
a316 1
	/* We're checking if the bit #21 of EFLAGS 
d319 14
a332 14
		"pushf\n"
		"popl %%eax\n"
		"xorl $0x200000, %%eax\n"
		"movl %%eax, %%ecx\n"
		"andl $0x200000, %%ecx\n"
		"pushl %%eax\n"
		"popf\n"
		"pushf\n"
		"popl %%eax\n"
		"andl $0x200000, %%eax\n"
		"xorl %%eax, %%ecx\n"
		"movl %%ecx, %0\n"
		: "=r" (result) : : "eax", "ecx");
	
d352 7
a358 7
		"pushl	%%ebx\n"
		"cpuid\n"
		"movl	%%ebx,(%%edi)\n"
		"movl	%%edx,4(%%edi)\n"
		"movl	%%ecx,8(%%edi)\n"
		"popl	%%ebx"
		: "+a"(eax) : "D"(vendor_string) : "ecx", "edx");
d365 1
a365 1
		: "+a"(eax) : : "ecx", "edx");
d372 1
a372 1
		: "+a"(eax), "=d"(edx) : : "ecx");
d375 2
a376 2
	padlock_use_ace = ((edx & (0x3<<6)) == (0x3<<6));
	padlock_use_rng = ((edx & (0x3<<2)) == (0x3<<2));
d397 1
a397 1
   Loading EFLAGS from the stack clears EFLAGS[30] 
d419 10
a428 10
	"pushfl\n"
"	btl	$30,(%%esp)\n"
"	jnc	1f\n"
"	cmpl	%2,%1\n"
"	je	1f\n"
"	popfl\n"
"	subl	$4,%%esp\n"
"1:	addl	$4,%%esp\n"
"	movl	%2,%0"
	:"+m"(padlock_saved_context)
d433 1
a433 1
/* BIG FAT WARNING: 
d468 3
a470 3
	    : "=a"(eax_out),"=m"(*(unsigned *)addr)
	    : "D"(addr), "d" (edx_in)
	    );
d485 1
a485 1
 */ 
d487 1
a487 1
padlock_memcpy(void *dst,const void *src,size_t n)
d489 2
a490 2
	long       *d=dst;
	const long *s=src;
d493 2
a494 1
	do { *d++ = *s++; } while (--n);
d545 1
a545 1
				      sizeof(padlock_cipher_nids[0]));
d549 1
a549 1
				const unsigned char *iv, int enc);
d551 1
a551 1
			      const unsigned char *in, size_t nbytes);
d582 14
a595 14
DECLARE_AES_EVP(128,ecb,ECB);
DECLARE_AES_EVP(128,cbc,CBC);
DECLARE_AES_EVP(128,cfb,CFB);
DECLARE_AES_EVP(128,ofb,OFB);

DECLARE_AES_EVP(192,ecb,ECB);
DECLARE_AES_EVP(192,cbc,CBC);
DECLARE_AES_EVP(192,cfb,CFB);
DECLARE_AES_EVP(192,ofb,OFB);

DECLARE_AES_EVP(256,ecb,ECB);
DECLARE_AES_EVP(256,cbc,CBC);
DECLARE_AES_EVP(256,cfb,CFB);
DECLARE_AES_EVP(256,ofb,OFB);
d598 1
a598 1
padlock_ciphers (ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid)
d608 40
a647 43
	  case NID_aes_128_ecb:
	    *cipher = &padlock_aes_128_ecb;
	    break;
	  case NID_aes_128_cbc:
	    *cipher = &padlock_aes_128_cbc;
	    break;
	  case NID_aes_128_cfb:
	    *cipher = &padlock_aes_128_cfb;
	    break;
	  case NID_aes_128_ofb:
	    *cipher = &padlock_aes_128_ofb;
	    break;

	  case NID_aes_192_ecb:
	    *cipher = &padlock_aes_192_ecb;
	    break;
	  case NID_aes_192_cbc:
	    *cipher = &padlock_aes_192_cbc;
	    break;
	  case NID_aes_192_cfb:
	    *cipher = &padlock_aes_192_cfb;
	    break;
	  case NID_aes_192_ofb:
	    *cipher = &padlock_aes_192_ofb;
	    break;

	  case NID_aes_256_ecb:
	    *cipher = &padlock_aes_256_ecb;
	    break;
	  case NID_aes_256_cbc:
	    *cipher = &padlock_aes_256_cbc;
	    break;
	  case NID_aes_256_cfb:
	    *cipher = &padlock_aes_256_cfb;
	    break;
	  case NID_aes_256_ofb:
	    *cipher = &padlock_aes_256_ofb;
	    break;

	  default:
	    /* Sorry, we don't support this NID */
	    *cipher = NULL;
	    return 0;
d656 1
a656 1
		      const unsigned char *iv, int enc)
d661 2
a662 1
	if (key==NULL) return 0;	/* ERROR */
d675 7
a681 7
	switch(key_len) {
		case 128:
			/* PadLock can generate an extended key for
			   AES128 in hardware */
			memcpy(cdata->ks.rd_key, key, AES_KEY_SIZE_128);
			cdata->cword.b.keygen = 0;
			break;
d683 14
a696 14
		case 192:
		case 256:
			/* Generate an extended AES key in software.
			   Needed for AES192/AES256 */
			/* Well, the above applies to Stepping 8 CPUs
			   and is listed as hardware errata. They most
			   likely will fix it at some point and then
			   a check for stepping would be due here. */
			if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CFB_MODE ||
			    EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_OFB_MODE ||
			    enc)
				AES_set_encrypt_key(key, key_len, &cdata->ks);
			else
				AES_set_decrypt_key(key, key_len, &cdata->ks);
d698 2
a699 2
			/* OpenSSL C functions use byte-swapped extended key. */
			padlock_bswapl(&cdata->ks);
d701 2
a702 2
			cdata->cword.b.keygen = 1;
			break;
d704 3
a706 3
		default:
			/* ERROR */
			return 0;
d719 1
a719 1
/* 
d727 1
a727 1
		const unsigned char *in_arg, size_t nbytes)
d737 2
a738 1
		padlock_xcrypt_ecb(nbytes/AES_BLOCK_SIZE, cdata, out_arg, in_arg);
d743 2
a744 1
		iv = padlock_xcrypt_cbc(nbytes/AES_BLOCK_SIZE, cdata, out_arg, in_arg);
d750 2
a751 1
		iv = padlock_xcrypt_cfb(nbytes/AES_BLOCK_SIZE, cdata, out_arg, in_arg);
d757 2
a758 1
		padlock_xcrypt_ofb(nbytes/AES_BLOCK_SIZE, cdata, out_arg, in_arg);
d778 1
a778 1
/* Re-align the arguments to 16-Bytes boundaries and run the 
d782 1
a782 1
		   const unsigned char *in_arg, size_t nbytes)
d789 1
a789 1
	size_t chunk, allocated=0;
d793 3
a795 2
	if ((chunk = ctx->num)) { /* borrow chunk variable */
		unsigned char *ivp=ctx->iv;
d803 1
a803 1
				while (chunk<AES_BLOCK_SIZE && nbytes!=0) {
d807 2
a808 1
			else	while (chunk<AES_BLOCK_SIZE && nbytes!=0) {
d814 1
a814 1
			ctx->num = chunk%AES_BLOCK_SIZE;
d820 1
a820 1
			while (chunk<AES_BLOCK_SIZE && nbytes!=0) {
d825 1
a825 1
			ctx->num = chunk%AES_BLOCK_SIZE;
d849 3
a851 2
	if (!padlock_aes_align_required && (nbytes%AES_BLOCK_SIZE)==0)
		return padlock_aes_cipher_omnivorous(ctx, out_arg, in_arg, nbytes);
d862 3
a864 2
	if (!realign_in_loop && (nbytes%AES_BLOCK_SIZE)==0)
		return padlock_aes_cipher_omnivorous(ctx, out_arg, in_arg, nbytes);
d867 1
a867 1
	chunk  = nbytes;
d869 2
a870 1
	if (chunk==0) chunk = PADLOCK_CHUNK;
d874 1
a874 1
		allocated = (chunk<nbytes?PADLOCK_CHUNK:nbytes);
d877 1
a877 2
	}
	else
d885 1
a885 1
		do	{
d892 2
a893 1
			padlock_xcrypt_ecb(chunk/AES_BLOCK_SIZE, cdata, out, inp);
d896 2
a897 1
				out_arg = padlock_memcpy(out_arg, out, chunk) + chunk;
d899 1
a899 1
				out     = out_arg+=chunk;
d902 1
a902 1
			chunk   = PADLOCK_CHUNK;
d909 1
a909 1
		do	{
d913 1
a913 1
		cbc_shortcut: /* optimize for small input */
d920 2
a921 1
			iv = padlock_xcrypt_cbc(chunk/AES_BLOCK_SIZE, cdata, out, inp);
d924 2
a925 1
				out_arg = padlock_memcpy(out_arg, out, chunk) + chunk;
d927 1
a927 2
				out     = out_arg+=chunk;

d934 6
a939 4
		chunk &= ~(AES_BLOCK_SIZE-1);
		if (chunk)	goto cfb_shortcut;
		else		goto cfb_skiploop;
		do	{
d943 1
a943 1
		cfb_shortcut: /* optimize for small input */
d950 2
a951 1
			iv = padlock_xcrypt_cfb(chunk/AES_BLOCK_SIZE, cdata, out, inp);
d954 2
a955 1
				out_arg = padlock_memcpy(out_arg, out, chunk) + chunk;
d957 1
a957 1
				out     = out_arg+=chunk;
d962 1
a962 1
		cfb_skiploop:
d972 1
a972 1
				cdata->cword.b.encdec=0;
d974 2
a975 2
				padlock_xcrypt_ecb(1,cdata,ivp,ivp);
				cdata->cword.b.encdec=1;
d977 1
a977 1
				while(nbytes) {
d982 3
a984 3
			}
			else {	padlock_reload_key();
				padlock_xcrypt_ecb(1,cdata,ivp,ivp);
d998 1
a998 1
		chunk &= ~(AES_BLOCK_SIZE-1);
d1006 2
a1007 1
			padlock_xcrypt_ofb(chunk/AES_BLOCK_SIZE, cdata, out, inp);
d1010 2
a1011 1
				out_arg = padlock_memcpy(out_arg, out, chunk) + chunk;
d1013 1
a1013 1
				out     = out_arg+=chunk;
d1016 1
a1016 1
			chunk   = PADLOCK_CHUNK;
d1024 1
a1024 1
			padlock_xcrypt_ecb(1,cdata,ivp,ivp);
d1041 4
a1044 3
		volatile unsigned long *p=(void *)out;
		size_t   n = allocated/sizeof(*p);
		while (n--) *p++=0;
d1061 1
a1061 1
/* Wrapper that provides an interface between the API and 
d1070 2
a1071 1
		if (!(eax&(1<<6)))	return 0; /* RNG disabled */
d1073 6
a1078 3
		if (eax&(0x1F<<10))	return 0;
		if ((eax&0x1F)==0)	continue; /* no data, retry... */
		if ((eax&0x1F)!=8)	return 0; /* fatal failure...  */
d1080 1
a1080 1
		count  -= 8;
d1084 2
a1085 1
		if (!(eax&(1<<6)))	return 0; /* RNG disabled */
d1087 6
a1092 3
		if (eax&(0x1F<<10))	return 0;
		if ((eax&0x1F)==0)	continue; /* no data, retry... */
		if ((eax&0x1F)!=1)	return 0; /* fatal failure...  */
d1096 1
a1096 1
	*(volatile unsigned int *)&buf=0;
d1117 5
a1121 4
extern
int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns);
extern
int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { return 0; }
@


1.9
log
@Expand the OPENSSL_{GLOBAL,EXPORT,IMPORT,EXTERN} macros - this rids the
libssl tree from all uses of these defines.

ok miod@@
@
text
@d1 1
@


1.8
log
@Remove WIN32, WIN64 and MINGW32 tentacles.
Also check for _LP64 rather than __arch64__ (the former being more reliable
than __LP64__ or __arch64__) to tell 64-bit int platforms apart from 32-bit
int platforms.

Loosely based upon a diff from Martijn van Duren on tech@@
@
text
@d1091 1
a1091 1
OPENSSL_EXPORT
d1093 1
a1093 1
OPENSSL_EXPORT
@


1.7
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d132 1
a132 6
#ifdef _WIN32
# include <malloc.h>
# ifndef alloca
#  define alloca _alloca
# endif
#elif defined(__GNUC__)
@


1.6
log
@Restore beck's rev 1.3: snprintf() was reviewed
@
text
@d1089 3
a1091 6
	NULL,			/* seed */
	padlock_rand_bytes,	/* bytes */
	NULL,			/* cleanup */
	NULL,			/* add */
	padlock_rand_bytes,	/* pseudorand */
	padlock_rand_status,	/* rand status */
@


1.5
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d180 1
a180 1
	snprintf(padlock_name, sizeof(padlock_name),
@


1.4
log
@Get rid of MS Visual C compiler and Intel C compiler specific defines.
@
text
@d180 1
a180 1
	(void) snprintf(padlock_name, sizeof(padlock_name),
@


1.3
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@d104 1
a104 2
# if (defined(__GNUC__) && (defined(__i386__) || defined(__i386))) || \
     (defined(_MSC_VER) && defined(_M_IX86))
a500 130

#elif defined(_MSC_VER)
/*
 * Unlike GCC these are real functions. In order to minimize impact
 * on performance we adhere to __fastcall calling convention in
 * order to get two first arguments passed through %ecx and %edx.
 * Which kind of suits very well, as instructions in question use
 * both %ecx and %edx as input:-)
 */
#define REP_XCRYPT(code)		\
	_asm _emit 0xf3			\
	_asm _emit 0x0f _asm _emit 0xa7	\
	_asm _emit code

/* BIG FAT WARNING: 
 * 	The offsets used with 'lea' instructions
 * 	describe items of the 'padlock_cipher_data'
 * 	structure.
 */
#define PADLOCK_XCRYPT_ASM(name,code)	\
static void * __fastcall 		\
	name (size_t cnt, void *cdata,	\
	void *outp, const void *inp)	\
{	_asm	mov	eax,edx		\
	_asm	lea	edx,[eax+16]	\
	_asm	lea	ebx,[eax+32]	\
	_asm	mov	edi,outp	\
	_asm	mov	esi,inp		\
	REP_XCRYPT(code)		\
}

PADLOCK_XCRYPT_ASM(padlock_xcrypt_ecb,0xc8)
PADLOCK_XCRYPT_ASM(padlock_xcrypt_cbc,0xd0)
PADLOCK_XCRYPT_ASM(padlock_xcrypt_cfb,0xe0)
PADLOCK_XCRYPT_ASM(padlock_xcrypt_ofb,0xe8)

static int __fastcall
padlock_xstore(void *outp,unsigned int code)
{	_asm	mov	edi,ecx
	_asm _emit 0x0f _asm _emit 0xa7 _asm _emit 0xc0
}

static void __fastcall
padlock_reload_key(void)
{	_asm pushfd _asm popfd		}

static void __fastcall
padlock_verify_context(void *cdata)
{	_asm	{
		pushfd
		bt	DWORD PTR[esp],30
		jnc	skip
		cmp	ecx,padlock_saved_context
		je	skip
		popfd
		sub	esp,4
	skip:	add	esp,4
		mov	padlock_saved_context,ecx
		}
}

static int
padlock_available(void)
{	_asm	{
		pushfd
		pop	eax
		mov	ecx,eax
		xor	eax,1<<21
		push	eax
		popfd
		pushfd
		pop	eax
		xor	eax,ecx
		bt	eax,21
		jnc	noluck
		mov	eax,0
		cpuid
		xor	eax,eax
		cmp	ebx,'tneC'
		jne	noluck
		cmp	edx,'Hrua'
		jne	noluck
		cmp	ecx,'slua'
		jne	noluck
		mov	eax,0xC0000000
		cpuid
		mov	edx,eax
		xor	eax,eax
		cmp	edx,0xC0000001
		jb	noluck
		mov	eax,0xC0000001
		cpuid
		xor	eax,eax
		bt	edx,6
		jnc	skip_a
		bt	edx,7
		jnc	skip_a
		mov	padlock_use_ace,1
		inc	eax
	skip_a:	bt	edx,2
		jnc	skip_r
		bt	edx,3
		jnc	skip_r
		mov	padlock_use_rng,1
		inc	eax
	skip_r:
	noluck:
		}
}

static void __fastcall
padlock_bswapl(void *key)
{	_asm	{
		pushfd
		cld
		mov	esi,ecx
		mov	edi,ecx
		mov	ecx,60
	up:	lodsd
		bswap	eax
		stosd
		loop	up
		popfd
		}
}

/* MS actually specifies status of Direction Flag and compiler even
 * manages to compile following as 'rep movsd' all by itself...
 */
#define padlock_memcpy(o,i,n) ((unsigned char *)memcpy((o),(i),(n)&~3U))
@


1.2
log
@Remove eng_cryptodev.c (merged into old-name hw_cryptodev.c); move
undo the move of crypto/engines/eng_padlock to engines/e_padlock.
Requested by reyk@@.

Note that eng_padlock is not compiled in currently.
@
text
@d181 1
a181 1
	BIO_snprintf(padlock_name, sizeof(padlock_name),
@


1.1
log
@Initial revision
@
text
@d107 5
a112 1
# endif
d127 2
d132 2
a133 1
#ifdef _MSC_VER
d135 7
a141 6
# define alloca _alloca
#elif defined(NETWARE_CLIB) && defined(__GNUC__)
  void *alloca(size_t);
# define alloca(s) __builtin_alloca(s)
#else
# include <stdlib.h>
d202 2
d222 2
d249 2
a250 2
IMPLEMENT_DYNAMIC_CHECK_FN ();
IMPLEMENT_DYNAMIC_BIND_FN (padlock_bind_fn);
d1228 8
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@d237 2
a238 2
IMPLEMENT_DYNAMIC_CHECK_FN ()
IMPLEMENT_DYNAMIC_BIND_FN (padlock_bind_fn)
@

