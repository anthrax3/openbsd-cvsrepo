head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.2
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14;
locks; strict;
comment	@ * @;


1.14
date	2015.06.19.06.05.11;	author bcook;	state Exp;
branches;
next	1.13;
commitid	UoMmqRBqGwWCJkBW;

1.13
date	2015.02.11.03.19.37;	author doug;	state Exp;
branches;
next	1.12;
commitid	5KSZBoxiLebzObKt;

1.12
date	2014.07.13.16.03.09;	author beck;	state Exp;
branches;
next	1.11;
commitid	6xdvCwSqBadTW6X3;

1.11
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.10;
commitid	id8dTrTMtnTn4fqt;

1.10
date	2014.07.09.08.52.00;	author bcook;	state Exp;
branches;
next	1.9;
commitid	CfQ3JtbpylNlXgdT;

1.9
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	mJUVYpkFBZ0Zv2bG;

1.8
date	2014.06.10.15.20.40;	author jsing;	state Exp;
branches;
next	1.7;
commitid	bVia1atxAsS9lVc4;

1.7
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2014.05.22.21.12.16;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.13;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.19;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.38.27;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.07;	author djm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Disable ENGINE_load_dynamic (dynamic engine support).

We do not build, test or ship any dynamic engines, so we can remove the dynamic
engine loader as well. This leaves a stub initialization function in its place.

ok beck@@, reyk@@, miod@@
@
text
@/* $OpenBSD: eng_dyn.c,v 1.13 2015/02/11 03:19:37 doug Exp $ */
/* Written by Geoff Thorpe (geoff@@geoffthorpe.net) for the OpenSSL
 * project 2001.
 */
/* ====================================================================
 * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <openssl/engine.h>

void
ENGINE_load_dynamic(void)
{
}
@


1.13
log
@Enable building with -DOPENSSL_NO_DEPRECATED.

If you didn't enable deprecated code, there were missing err.h and
bn.h includes.  This commit allows building with or without deprecated
code.

This was not derived from an OpenSSL commit.  However, they recently
enabled OPENSSL_NO_DEPRECATED in git and fixed these header problems
in a different way.

Verified with clang that this only changes line numbers in the generated
asm.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: eng_dyn.c,v 1.12 2014/07/13 16:03:09 beck Exp $ */
d59 1
a59 236
#include <string.h>

#include <openssl/err.h>

#include "eng_int.h"
#include <openssl/dso.h>

/* Shared libraries implementing ENGINEs for use by the "dynamic" ENGINE loader
 * should implement the hook-up functions with the following prototypes. */

/* Our ENGINE handlers */
static int dynamic_init(ENGINE *e);
static int dynamic_finish(ENGINE *e);
static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void));
/* Predeclare our context type */
typedef struct st_dynamic_data_ctx dynamic_data_ctx;
/* The implementation for the important control command */
static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx);

#define DYNAMIC_CMD_SO_PATH		ENGINE_CMD_BASE
#define DYNAMIC_CMD_NO_VCHECK		(ENGINE_CMD_BASE + 1)
#define DYNAMIC_CMD_ID			(ENGINE_CMD_BASE + 2)
#define DYNAMIC_CMD_LIST_ADD		(ENGINE_CMD_BASE + 3)
#define DYNAMIC_CMD_DIR_LOAD		(ENGINE_CMD_BASE + 4)
#define DYNAMIC_CMD_DIR_ADD		(ENGINE_CMD_BASE + 5)
#define DYNAMIC_CMD_LOAD		(ENGINE_CMD_BASE + 6)

/* The constants used when creating the ENGINE */
static const char *engine_dynamic_id = "dynamic";
static const char *engine_dynamic_name = "Dynamic engine loading support";
static const ENGINE_CMD_DEFN dynamic_cmd_defns[] = {
	{
		DYNAMIC_CMD_SO_PATH,
		"SO_PATH",
		"Specifies the path to the new ENGINE shared library",
		ENGINE_CMD_FLAG_STRING},
	{
		DYNAMIC_CMD_NO_VCHECK,
		"NO_VCHECK",
		"Specifies to continue even if version checking fails (boolean)",
		ENGINE_CMD_FLAG_NUMERIC},
	{
		DYNAMIC_CMD_ID,
		"ID",
		"Specifies an ENGINE id name for loading",
		ENGINE_CMD_FLAG_STRING},
	{
		DYNAMIC_CMD_LIST_ADD,
		"LIST_ADD",
		"Whether to add a loaded ENGINE to the internal list (0=no,1=yes,2=mandatory)",
		ENGINE_CMD_FLAG_NUMERIC},
	{
		DYNAMIC_CMD_DIR_LOAD,
		"DIR_LOAD",
		"Specifies whether to load from 'DIR_ADD' directories (0=no,1=yes,2=mandatory)",
		ENGINE_CMD_FLAG_NUMERIC},
	{
		DYNAMIC_CMD_DIR_ADD,
		"DIR_ADD",
		"Adds a directory from which ENGINEs can be loaded",
		ENGINE_CMD_FLAG_STRING},
	{
		DYNAMIC_CMD_LOAD,
		"LOAD",
		"Load up the ENGINE specified by other settings",
		ENGINE_CMD_FLAG_NO_INPUT},

	{0, NULL, NULL, 0}
};

/* Loading code stores state inside the ENGINE structure via the "ex_data"
 * element. We load all our state into a single structure and use that as a
 * single context in the "ex_data" stack. */
struct st_dynamic_data_ctx {
	/* The DSO object we load that supplies the ENGINE code */
	DSO *dynamic_dso;
	/* The function pointer to the version checking shared library function */
	dynamic_v_check_fn v_check;
	/* The function pointer to the engine-binding shared library function */
	dynamic_bind_engine bind_engine;
	/* The default name/path for loading the shared library */
	const char *DYNAMIC_LIBNAME;
	/* Whether to continue loading on a version check failure */
	int no_vcheck;
	/* If non-NULL, stipulates the 'id' of the ENGINE to be loaded */
	const char *engine_id;
	/* If non-zero, a successfully loaded ENGINE should be added to the internal
	 * ENGINE list. If 2, the add must succeed or the entire load should fail. */
	int list_add_value;
	/* The symbol name for the version checking function */
	const char *DYNAMIC_F1;
	/* The symbol name for the "initialise ENGINE structure" function */
	const char *DYNAMIC_F2;
	/* Whether to never use 'dirs', use 'dirs' as a fallback, or only use
	 * 'dirs' for loading. Default is to use 'dirs' as a fallback. */
	int dir_load;
	/* A stack of directories from which ENGINEs could be loaded */
	STACK_OF(OPENSSL_STRING) *dirs;
};

/* This is the "ex_data" index we obtain and reserve for use with our context
 * structure. */
static int dynamic_ex_data_idx = -1;

static void
int_free_str(char *s)
{
	free(s);
}

/* Because our ex_data element may or may not get allocated depending on whether
 * a "first-use" occurs before the ENGINE is freed, we have a memory leak
 * problem to solve. We can't declare a "new" handler for the ex_data as we
 * don't want a dynamic_data_ctx in *all* ENGINE structures of all types (this
 * is a bug in the design of CRYPTO_EX_DATA). As such, we just declare a "free"
 * handler and that will get called if an ENGINE is being destroyed and there
 * was an ex_data element corresponding to our context type. */
static void
dynamic_data_ctx_free_func(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
    int idx, long argl, void *argp)
{
	if (ptr) {
		dynamic_data_ctx *ctx = (dynamic_data_ctx *)ptr;
		if (ctx->dynamic_dso)
			DSO_free(ctx->dynamic_dso);
		free((void *)ctx->DYNAMIC_LIBNAME);
		free((void *)ctx->engine_id);
		if (ctx->dirs)
			sk_OPENSSL_STRING_pop_free(ctx->dirs, int_free_str);
		free(ctx);
	}
}

/* Construct the per-ENGINE context. We create it blindly and then use a lock to
 * check for a race - if so, all but one of the threads "racing" will have
 * wasted their time. The alternative involves creating everything inside the
 * lock which is far worse. */
static int
dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx)
{
	dynamic_data_ctx *c;

	c = malloc(sizeof(dynamic_data_ctx));
	if (!c) {
		ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	memset(c, 0, sizeof(dynamic_data_ctx));
	c->dynamic_dso = NULL;
	c->v_check = NULL;
	c->bind_engine = NULL;
	c->DYNAMIC_LIBNAME = NULL;
	c->no_vcheck = 0;
	c->engine_id = NULL;
	c->list_add_value = 0;
	c->DYNAMIC_F1 = "v_check";
	c->DYNAMIC_F2 = "bind_engine";
	c->dir_load = 1;
	c->dirs = sk_OPENSSL_STRING_new_null();
	if (!c->dirs) {
		ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE);
		free(c);
		return 0;
	}
	CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
	if ((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e,
	    dynamic_ex_data_idx)) == NULL) {
		/* Good, we're the first */
		ENGINE_set_ex_data(e, dynamic_ex_data_idx, c);
		*ctx = c;
		c = NULL;
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
	/* If we lost the race to set the context, c is non-NULL and *ctx is the
	 * context of the thread that won. */
	free(c);
	return 1;
}

/* This function retrieves the context structure from an ENGINE's "ex_data", or
 * if it doesn't exist yet, sets it up. */
static dynamic_data_ctx *
dynamic_get_data_ctx(ENGINE *e)
{
	dynamic_data_ctx *ctx;
	if (dynamic_ex_data_idx < 0) {
		/* Create and register the ENGINE ex_data, and associate our
		 * "free" function with it to ensure any allocated contexts get
		 * freed when an ENGINE goes underground. */
		int new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL,
		    dynamic_data_ctx_free_func);
		if (new_idx == -1) {
			ENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX,
			    ENGINE_R_NO_INDEX);
			return NULL;
		}
		CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
		/* Avoid a race by checking again inside this lock */
		if (dynamic_ex_data_idx < 0) {
			/* Good, someone didn't beat us to it */
			dynamic_ex_data_idx = new_idx;
			new_idx = -1;
		}
		CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
		/* In theory we could "give back" the index here if
		 * (new_idx>-1), but it's not possible and wouldn't gain us much
		 * if it were. */
	}
	ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx);
	/* Check if the context needs to be created */
	if ((ctx == NULL) && !dynamic_set_data_ctx(e, &ctx))
		/* "set_data" will set errors if necessary */
		return NULL;
	return ctx;
}

static ENGINE *
engine_dynamic(void)
{
	ENGINE *ret = ENGINE_new();

	if (!ret)
		return NULL;

	if (!ENGINE_set_id(ret, engine_dynamic_id) ||
	    !ENGINE_set_name(ret, engine_dynamic_name) ||
	    !ENGINE_set_init_function(ret, dynamic_init) ||
	    !ENGINE_set_finish_function(ret, dynamic_finish) ||
	    !ENGINE_set_ctrl_function(ret, dynamic_ctrl) ||
	    !ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) ||
	    !ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) {
		ENGINE_free(ret);
		return NULL;
	}
	return ret;
}
a63 248
	ENGINE *toadd = engine_dynamic();

	if (!toadd)
		return;

	ENGINE_add(toadd);
	/* If the "add" worked, it gets a structural reference. So either way,
	 * we release our just-created reference. */
	ENGINE_free(toadd);
	/* If the "add" didn't work, it was probably a conflict because it was
	 * already added (eg. someone calling ENGINE_load_blah then calling
	 * ENGINE_load_builtin_engines() perhaps). */
	ERR_clear_error();
}

static int
dynamic_init(ENGINE *e)
{
	/* We always return failure - the "dyanamic" engine itself can't be used
	 * for anything. */
	return 0;
}

static int
dynamic_finish(ENGINE *e)
{
	/* This should never be called on account of "dynamic_init" always
	 * failing. */
	return 0;
}

static int
dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))
{
	dynamic_data_ctx *ctx = dynamic_get_data_ctx(e);
	int initialised;

	if (!ctx) {
		ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_NOT_LOADED);
		return 0;
	}
	initialised = ((ctx->dynamic_dso == NULL) ? 0 : 1);
	/* All our control commands require the ENGINE to be uninitialised */
	if (initialised) {
		ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_ALREADY_LOADED);
		return 0;
	}
	switch (cmd) {
	case DYNAMIC_CMD_SO_PATH:
		/* a NULL 'p' or a string of zero-length is the same thing */
		if (p && (strlen((const char *)p) < 1))
			p = NULL;
		free((void *)ctx->DYNAMIC_LIBNAME);
		if (p)
			ctx->DYNAMIC_LIBNAME = strdup(p);
		else
			ctx->DYNAMIC_LIBNAME = NULL;
		return (ctx->DYNAMIC_LIBNAME ? 1 : 0);
	case DYNAMIC_CMD_NO_VCHECK:
		ctx->no_vcheck = ((i == 0) ? 0 : 1);
		return 1;
	case DYNAMIC_CMD_ID:
		/* a NULL 'p' or a string of zero-length is the same thing */
		if (p && (strlen((const char *)p) < 1))
			p = NULL;
		free((void *)ctx->engine_id);
		if (p)
			ctx->engine_id = strdup(p);
		else
			ctx->engine_id = NULL;
		return (ctx->engine_id ? 1 : 0);
	case DYNAMIC_CMD_LIST_ADD:
		if ((i < 0) || (i > 2)) {
			ENGINEerr(ENGINE_F_DYNAMIC_CTRL,
			    ENGINE_R_INVALID_ARGUMENT);
			return 0;
		}
		ctx->list_add_value = (int)i;
		return 1;
	case DYNAMIC_CMD_LOAD:
		return dynamic_load(e, ctx);
	case DYNAMIC_CMD_DIR_LOAD:
		if ((i < 0) || (i > 2)) {
			ENGINEerr(ENGINE_F_DYNAMIC_CTRL,
			    ENGINE_R_INVALID_ARGUMENT);
			return 0;
		}
		ctx->dir_load = (int)i;
		return 1;
	case DYNAMIC_CMD_DIR_ADD:
		/* a NULL 'p' or a string of zero-length is the same thing */
		if (!p || (strlen((const char *)p) < 1)) {
			ENGINEerr(ENGINE_F_DYNAMIC_CTRL,
			    ENGINE_R_INVALID_ARGUMENT);
			return 0;
		}
		{
			char *tmp_str = strdup(p);
			if (!tmp_str) {
				ENGINEerr(ENGINE_F_DYNAMIC_CTRL,
				    ERR_R_MALLOC_FAILURE);
				return 0;
			}
			sk_OPENSSL_STRING_insert(ctx->dirs, tmp_str, -1);
		}
		return 1;
	default:
		break;
	}
	ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);
	return 0;
}

static int
int_load(dynamic_data_ctx *ctx)
{
	int num, loop;

	/* Unless told not to, try a direct load */
	if ((ctx->dir_load != 2) && (DSO_load(ctx->dynamic_dso,
	    ctx->DYNAMIC_LIBNAME, NULL, 0)) != NULL)
		return 1;
	/* If we're not allowed to use 'dirs' or we have none, fail */
	if (!ctx->dir_load || (num = sk_OPENSSL_STRING_num(ctx->dirs)) < 1)
		return 0;
	for (loop = 0; loop < num; loop++) {
		const char *s = sk_OPENSSL_STRING_value(ctx->dirs, loop);
		char *merge = DSO_merge(ctx->dynamic_dso,
		    ctx->DYNAMIC_LIBNAME, s);
		if (!merge)
			return 0;
		if (DSO_load(ctx->dynamic_dso, merge, NULL, 0)) {
			/* Found what we're looking for */
			free(merge);
			return 1;
		}
		free(merge);
	}
	return 0;
}

static int
dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)
{
	ENGINE cpy;
	dynamic_fns fns;

	if (!ctx->dynamic_dso)
		ctx->dynamic_dso = DSO_new();
	if (!ctx->DYNAMIC_LIBNAME) {
		if (!ctx->engine_id)
			return 0;
		ctx->DYNAMIC_LIBNAME = DSO_convert_filename(ctx->dynamic_dso,
		    ctx->engine_id);
	}
	if (!int_load(ctx)) {
		ENGINEerr(ENGINE_F_DYNAMIC_LOAD,
		    ENGINE_R_DSO_NOT_FOUND);
		DSO_free(ctx->dynamic_dso);
		ctx->dynamic_dso = NULL;
		return 0;
	}
	/* We have to find a bind function otherwise it'll always end badly */
	if (!(ctx->bind_engine = (dynamic_bind_engine)DSO_bind_func(
	    ctx->dynamic_dso, ctx->DYNAMIC_F2))) {
		ctx->bind_engine = NULL;
		DSO_free(ctx->dynamic_dso);
		ctx->dynamic_dso = NULL;
		ENGINEerr(ENGINE_F_DYNAMIC_LOAD,
		    ENGINE_R_DSO_FAILURE);
		return 0;
	}
	/* Do we perform version checking? */
	if (!ctx->no_vcheck) {
		unsigned long vcheck_res = 0;
		/* Now we try to find a version checking function and decide how
		 * to cope with failure if/when it fails. */
		ctx->v_check = (dynamic_v_check_fn)DSO_bind_func(
		    ctx->dynamic_dso, ctx->DYNAMIC_F1);
		if (ctx->v_check)
			vcheck_res = ctx->v_check(OSSL_DYNAMIC_VERSION);
		/* We fail if the version checker veto'd the load *or* if it is
		 * deferring to us (by returning its version) and we think it is
		 * too old. */
		if (vcheck_res < OSSL_DYNAMIC_OLDEST) {
			/* Fail */
			ctx->bind_engine = NULL;
			ctx->v_check = NULL;
			DSO_free(ctx->dynamic_dso);
			ctx->dynamic_dso = NULL;
			ENGINEerr(ENGINE_F_DYNAMIC_LOAD,
			    ENGINE_R_VERSION_INCOMPATIBILITY);
			return 0;
		}
	}
	/* First binary copy the ENGINE structure so that we can roll back if
	 * the hand-over fails */
	memcpy(&cpy, e, sizeof(ENGINE));
	/* Provide the ERR, "ex_data", memory, and locking callbacks so the
	 * loaded library uses our state rather than its own. FIXME: As noted in
	 * engine.h, much of this would be simplified if each area of code
	 * provided its own "summary" structure of all related callbacks. It
	 * would also increase opaqueness. */
	fns.static_state = ENGINE_get_static_state();
	fns.err_fns = ERR_get_implementation();
	fns.ex_data_fns = CRYPTO_get_ex_data_implementation();
	CRYPTO_get_mem_functions(&fns.mem_fns.malloc_cb,
	    &fns.mem_fns.realloc_cb,
	    &fns.mem_fns.free_cb);
	fns.lock_fns.lock_locking_cb = CRYPTO_get_locking_callback();
	fns.lock_fns.lock_add_lock_cb = CRYPTO_get_add_lock_callback();
	fns.lock_fns.dynlock_create_cb = CRYPTO_get_dynlock_create_callback();
	fns.lock_fns.dynlock_lock_cb = CRYPTO_get_dynlock_lock_callback();
	fns.lock_fns.dynlock_destroy_cb = CRYPTO_get_dynlock_destroy_callback();
	/* Now that we've loaded the dynamic engine, make sure no "dynamic"
	 * ENGINE elements will show through. */
	engine_set_all_null(e);

	/* Try to bind the ENGINE onto our own ENGINE structure */
	if (!ctx->bind_engine(e, ctx->engine_id, &fns)) {
		ctx->bind_engine = NULL;
		ctx->v_check = NULL;
		DSO_free(ctx->dynamic_dso);
		ctx->dynamic_dso = NULL;
		ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_INIT_FAILED);
		/* Copy the original ENGINE structure back */
		memcpy(e, &cpy, sizeof(ENGINE));
		return 0;
	}
	/* Do we try to add this ENGINE to the internal list too? */
	if (ctx->list_add_value > 0) {
		if (!ENGINE_add(e)) {
			/* Do we tolerate this or fail? */
			if (ctx->list_add_value > 1) {
				/* Fail - NB: By this time, it's too late to
				 * rollback, and trying to do so allows the
				 * bind_engine() code to have created leaks. We
				 * just have to fail where we are, after the
				 * ENGINE has changed. */
				ENGINEerr(ENGINE_F_DYNAMIC_LOAD,
				    ENGINE_R_CONFLICTING_ENGINE_ID);
				return 0;
			}
			/* Tolerate */
			ERR_clear_error();
		}
	}
	return 1;
@


1.12
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: eng_dyn.c,v 1.11 2014/07/10 13:58:22 jsing Exp $ */
d60 2
@


1.11
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: eng_dyn.c,v 1.10 2014/07/09 08:52:00 bcook Exp $ */
d351 1
a351 1
			ctx->DYNAMIC_LIBNAME = BUF_strdup(p);
d364 1
a364 1
			ctx->engine_id = BUF_strdup(p);
d394 1
a394 1
			char *tmp_str = BUF_strdup(p);
@


1.10
log
@remove unused dynamic_cmd_defns_empty structure.

ok miod@@ deraadt@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: eng_dyn.c,v 1.9 2014/06/12 15:49:29 deraadt Exp $ */
d59 1
@


1.9
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a122 3
	{0, NULL, NULL, 0}
};
static const ENGINE_CMD_DEFN dynamic_cmd_defns_empty[] = {
@


1.8
log
@KNF.
@
text
@d1 1
a1 1
/* crypto/engine/eng_dyn.c */
@


1.7
log
@more: no need for null check before free
ok tedu guenther
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d87 2
a88 1
	{DYNAMIC_CMD_SO_PATH,
d92 2
a93 1
	{DYNAMIC_CMD_NO_VCHECK,
d97 2
a98 1
	{DYNAMIC_CMD_ID,
d102 2
a103 1
	{DYNAMIC_CMD_LIST_ADD,
d107 2
a108 1
	{DYNAMIC_CMD_DIR_LOAD,
d112 2
a113 1
	{DYNAMIC_CMD_DIR_ADD,
d117 2
a118 1
	{DYNAMIC_CMD_LOAD,
d122 1
d124 1
a124 1
	};
d127 1
a127 1
	};
d132 1
a132 2
struct st_dynamic_data_ctx
	{
d157 1
a157 1
	};
d163 6
a168 1
static void int_free_str(char *s) { free(s); }
d176 5
a180 5
static void dynamic_data_ctx_free_func(void *parent, void *ptr,
			CRYPTO_EX_DATA *ad, int idx, long argl, void *argp)
	{
	if(ptr)
		{
d182 1
a182 1
		if(ctx->dynamic_dso)
d186 1
a186 1
		if(ctx->dirs)
a188 1
		}
d190 1
d196 3
a198 2
static int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx)
	{
d200 1
d202 2
a203 3
	if(!c)
		{
		ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX,ERR_R_MALLOC_FAILURE);
d205 1
a205 1
		}
d218 2
a219 3
	if(!c->dirs)
		{
		ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX,ERR_R_MALLOC_FAILURE);
d222 1
a222 1
		}
d224 2
a225 3
	if((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e,
				dynamic_ex_data_idx)) == NULL)
		{
d230 1
a230 1
		}
d236 1
a236 1
	}
d240 3
a242 2
static dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e)
	{
d244 1
a244 2
	if(dynamic_ex_data_idx < 0)
		{
d249 4
a252 4
					dynamic_data_ctx_free_func);
		if(new_idx == -1)
			{
			ENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX,ENGINE_R_NO_INDEX);
d254 1
a254 1
			}
d257 1
a257 2
		if(dynamic_ex_data_idx < 0)
			{
d261 1
a261 1
			}
d266 1
a266 1
		}
d269 1
a269 1
	if((ctx == NULL) && !dynamic_set_data_ctx(e, &ctx))
d273 1
a273 1
	}
d275 3
a277 2
static ENGINE *engine_dynamic(void)
	{
d279 2
a280 1
	if(!ret)
d282 8
a289 8
	if(!ENGINE_set_id(ret, engine_dynamic_id) ||
			!ENGINE_set_name(ret, engine_dynamic_name) ||
			!ENGINE_set_init_function(ret, dynamic_init) ||
			!ENGINE_set_finish_function(ret, dynamic_finish) ||
			!ENGINE_set_ctrl_function(ret, dynamic_ctrl) ||
			!ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) ||
			!ENGINE_set_cmd_defns(ret, dynamic_cmd_defns))
		{
d292 1
a292 1
		}
d294 1
a294 1
	}
d296 3
a298 2
void ENGINE_load_dynamic(void)
	{
d300 4
a303 1
	if(!toadd) return;
d312 1
a312 1
	}
d314 3
a316 2
static int dynamic_init(ENGINE *e)
	{
d320 1
a320 1
	}
d322 3
a324 2
static int dynamic_finish(ENGINE *e)
	{
d328 1
a328 1
	}
d330 3
a332 2
static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))
	{
d335 3
a337 4
	
	if(!ctx)
		{
		ENGINEerr(ENGINE_F_DYNAMIC_CTRL,ENGINE_R_NOT_LOADED);
d339 1
a339 1
		}
d342 2
a343 4
	if(initialised)
		{
		ENGINEerr(ENGINE_F_DYNAMIC_CTRL,
			ENGINE_R_ALREADY_LOADED);
d345 2
a346 3
		}
	switch(cmd)
		{
d349 1
a349 1
		if(p && (strlen((const char *)p) < 1))
d352 1
a352 1
		if(p)
d362 1
a362 1
		if(p && (strlen((const char *)p) < 1))
d365 1
a365 1
		if(p)
d371 1
a371 2
		if((i < 0) || (i > 2))
			{
d373 1
a373 1
				ENGINE_R_INVALID_ARGUMENT);
d375 1
a375 1
			}
d381 1
a381 2
		if((i < 0) || (i > 2))
			{
d383 1
a383 1
				ENGINE_R_INVALID_ARGUMENT);
d385 1
a385 1
			}
d390 1
a390 2
		if(!p || (strlen((const char *)p) < 1))
			{
d392 1
a392 1
				ENGINE_R_INVALID_ARGUMENT);
d394 1
a394 1
			}
d396 5
a400 6
		char *tmp_str = BUF_strdup(p);
		if(!tmp_str)
			{
			ENGINEerr(ENGINE_F_DYNAMIC_CTRL,
				ERR_R_MALLOC_FAILURE);
			return 0;
d402 1
a402 1
		sk_OPENSSL_STRING_insert(ctx->dirs, tmp_str, -1);
d407 2
a408 2
		}
	ENGINEerr(ENGINE_F_DYNAMIC_CTRL,ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);
d410 1
a410 1
	}
d412 3
a414 2
static int int_load(dynamic_data_ctx *ctx)
	{
d416 1
d418 2
a419 2
	if((ctx->dir_load != 2) && (DSO_load(ctx->dynamic_dso,
				ctx->DYNAMIC_LIBNAME, NULL, 0)) != NULL)
d422 1
a422 1
	if(!ctx->dir_load || (num = sk_OPENSSL_STRING_num(ctx->dirs)) < 1)
d424 1
a424 2
	for(loop = 0; loop < num; loop++)
		{
d426 3
a428 2
		char *merge = DSO_merge(ctx->dynamic_dso, ctx->DYNAMIC_LIBNAME, s);
		if(!merge)
d430 1
a430 2
		if(DSO_load(ctx->dynamic_dso, merge, NULL, 0))
			{
d434 1
a434 1
			}
d436 1
a436 1
		}
d438 1
a438 1
	}
d440 3
a442 2
static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)
	{
d446 1
a446 1
	if(!ctx->dynamic_dso)
d448 2
a449 3
	if(!ctx->DYNAMIC_LIBNAME)
		{
		if(!ctx->engine_id)
d451 4
a454 5
		ctx->DYNAMIC_LIBNAME =
			DSO_convert_filename(ctx->dynamic_dso, ctx->engine_id);
		}
	if(!int_load(ctx))
		{
d456 1
a456 1
			ENGINE_R_DSO_NOT_FOUND);
d460 1
a460 1
		}
d462 2
a463 3
	if(!(ctx->bind_engine = (dynamic_bind_engine)DSO_bind_func(
					ctx->dynamic_dso, ctx->DYNAMIC_F2)))
		{
d468 1
a468 1
			ENGINE_R_DSO_FAILURE);
d470 1
a470 1
		}
d472 1
a472 2
	if(!ctx->no_vcheck)
		{
d477 2
a478 2
				ctx->dynamic_dso, ctx->DYNAMIC_F1);
		if(ctx->v_check)
d483 1
a483 2
		if(vcheck_res < OSSL_DYNAMIC_OLDEST)
			{
d490 1
a490 1
				ENGINE_R_VERSION_INCOMPATIBILITY);
a491 1
			}
d493 1
d506 2
a507 2
				&fns.mem_fns.realloc_cb,
				&fns.mem_fns.free_cb);
d518 1
a518 2
	if(!ctx->bind_engine(e, ctx->engine_id, &fns))
		{
d523 1
a523 1
		ENGINEerr(ENGINE_F_DYNAMIC_LOAD,ENGINE_R_INIT_FAILED);
d527 1
a527 1
		}
d529 2
a530 4
	if(ctx->list_add_value > 0)
		{
		if(!ENGINE_add(e))
			{
d532 1
a532 2
			if(ctx->list_add_value > 1)
				{
d539 1
a539 1
					ENGINE_R_CONFLICTING_ENGINE_ID);
d541 1
a541 1
				}
a543 1
			}
d545 1
d547 1
a547 1
	}
@


1.6
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d172 2
a173 4
		if(ctx->DYNAMIC_LIBNAME)
			free((void*)ctx->DYNAMIC_LIBNAME);
		if(ctx->engine_id)
			free((void*)ctx->engine_id);
d336 1
a336 2
		if(ctx->DYNAMIC_LIBNAME)
			free((void*)ctx->DYNAMIC_LIBNAME);
d349 1
a349 2
		if(ctx->engine_id)
			free((void*)ctx->engine_id);
@


1.5
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d225 1
a225 2
	if(c)
		free(c);
@


1.4
log
@resolve conflicts, fix local changes
@
text
@d156 1
a156 1
static void int_free_str(char *s) { OPENSSL_free(s); }
d173 1
a173 1
			OPENSSL_free((void*)ctx->DYNAMIC_LIBNAME);
d175 1
a175 1
			OPENSSL_free((void*)ctx->engine_id);
d178 1
a178 1
		OPENSSL_free(ctx);
d189 1
a189 1
	c = OPENSSL_malloc(sizeof(dynamic_data_ctx));
d210 1
a210 1
		OPENSSL_free(c);
d226 1
a226 1
		OPENSSL_free(c);
d340 1
a340 1
			OPENSSL_free((void*)ctx->DYNAMIC_LIBNAME);
d354 1
a354 1
			OPENSSL_free((void*)ctx->engine_id);
d425 1
a425 1
			OPENSSL_free(merge);
d428 1
a428 1
		OPENSSL_free(merge);
@


1.3
log
@resolve conflicts
@
text
@d149 1
a149 1
	STACK *dirs;
d156 1
a156 1
static void int_free_str(void *s) { OPENSSL_free(s); }
d177 1
a177 1
			sk_pop_free(ctx->dirs, int_free_str);
d206 1
a206 1
	c->dirs = sk_new_null();
d396 1
a396 1
		sk_insert(ctx->dirs, tmp_str, -1);
d414 1
a414 1
	if(!ctx->dir_load || ((num = sk_num(ctx->dirs)) < 1))
d418 1
a418 1
		const char *s = sk_value(ctx->dirs, loop);
@


1.2
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@a59 3
#include <stdio.h>
#include <openssl/crypto.h>
#include "cryptlib.h"
a60 1
#include <openssl/engine.h>
d69 1
a69 1
static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)());
d79 3
a81 1
#define DYNAMIC_CMD_LOAD		(ENGINE_CMD_BASE + 4)
d103 8
d145 5
d156 1
d176 2
d192 1
a192 1
		ENGINEerr(ENGINE_F_SET_DATA_CTX,ERR_R_MALLOC_FAILURE);
d205 8
d315 1
a315 1
static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)())
d371 28
d406 27
d438 10
a447 2
	if(!ctx->DYNAMIC_LIBNAME || ((ctx->dynamic_dso = DSO_load(NULL,
				ctx->DYNAMIC_LIBNAME, NULL, 0)) == NULL))
d451 2
d499 1
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d160 4
d176 1
a176 1
	if(!ctx)
d317 7
a323 2
		ctx->DYNAMIC_LIBNAME = (const char *)p;
		return 1;
d331 7
a337 2
		ctx->engine_id = (const char *)p;
		return 1;
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@a159 4
		if(ctx->DYNAMIC_LIBNAME)
			OPENSSL_free((void*)ctx->DYNAMIC_LIBNAME);
		if(ctx->engine_id)
			OPENSSL_free((void*)ctx->engine_id);
d172 1
a172 1
	if(!c)
d313 2
a314 7
		if(ctx->DYNAMIC_LIBNAME)
			OPENSSL_free((void*)ctx->DYNAMIC_LIBNAME);
		if(p)
			ctx->DYNAMIC_LIBNAME = BUF_strdup(p);
		else
			ctx->DYNAMIC_LIBNAME = NULL;
		return (ctx->DYNAMIC_LIBNAME ? 1 : 0);
d322 2
a323 7
		if(ctx->engine_id)
			OPENSSL_free((void*)ctx->engine_id);
		if(p)
			ctx->engine_id = BUF_strdup(p);
		else
			ctx->engine_id = NULL;
		return (ctx->engine_id ? 1 : 0);
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d60 3
d64 1
d73 1
a73 1
static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void));
d83 1
a83 3
#define DYNAMIC_CMD_DIR_LOAD		(ENGINE_CMD_BASE + 4)
#define DYNAMIC_CMD_DIR_ADD		(ENGINE_CMD_BASE + 5)
#define DYNAMIC_CMD_LOAD		(ENGINE_CMD_BASE + 6)
a104 8
	{DYNAMIC_CMD_DIR_LOAD,
		"DIR_LOAD",
		"Specifies whether to load from 'DIR_ADD' directories (0=no,1=yes,2=mandatory)",
		ENGINE_CMD_FLAG_NUMERIC},
	{DYNAMIC_CMD_DIR_ADD,
		"DIR_ADD",
		"Adds a directory from which ENGINEs can be loaded",
		ENGINE_CMD_FLAG_STRING},
a138 5
	/* Whether to never use 'dirs', use 'dirs' as a fallback, or only use
	 * 'dirs' for loading. Default is to use 'dirs' as a fallback. */
	int dir_load;
	/* A stack of directories from which ENGINEs could be loaded */
	STACK *dirs;
a144 1
static void int_free_str(void *s) { OPENSSL_free(s); }
a163 2
		if(ctx->dirs)
			sk_pop_free(ctx->dirs, int_free_str);
d178 1
a178 1
		ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX,ERR_R_MALLOC_FAILURE);
a190 8
	c->dir_load = 1;
	c->dirs = sk_new_null();
	if(!c->dirs)
		{
		ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX,ERR_R_MALLOC_FAILURE);
		OPENSSL_free(c);
		return 0;
		}
d293 1
a293 1
static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))
a348 28
	case DYNAMIC_CMD_DIR_LOAD:
		if((i < 0) || (i > 2))
			{
			ENGINEerr(ENGINE_F_DYNAMIC_CTRL,
				ENGINE_R_INVALID_ARGUMENT);
			return 0;
			}
		ctx->dir_load = (int)i;
		return 1;
	case DYNAMIC_CMD_DIR_ADD:
		/* a NULL 'p' or a string of zero-length is the same thing */
		if(!p || (strlen((const char *)p) < 1))
			{
			ENGINEerr(ENGINE_F_DYNAMIC_CTRL,
				ENGINE_R_INVALID_ARGUMENT);
			return 0;
			}
		{
		char *tmp_str = BUF_strdup(p);
		if(!tmp_str)
			{
			ENGINEerr(ENGINE_F_DYNAMIC_CTRL,
				ERR_R_MALLOC_FAILURE);
			return 0;
			}
		sk_insert(ctx->dirs, tmp_str, -1);
		}
		return 1;
a355 27
static int int_load(dynamic_data_ctx *ctx)
	{
	int num, loop;
	/* Unless told not to, try a direct load */
	if((ctx->dir_load != 2) && (DSO_load(ctx->dynamic_dso,
				ctx->DYNAMIC_LIBNAME, NULL, 0)) != NULL)
		return 1;
	/* If we're not allowed to use 'dirs' or we have none, fail */
	if(!ctx->dir_load || ((num = sk_num(ctx->dirs)) < 1))
		return 0;
	for(loop = 0; loop < num; loop++)
		{
		const char *s = sk_value(ctx->dirs, loop);
		char *merge = DSO_merge(ctx->dynamic_dso, ctx->DYNAMIC_LIBNAME, s);
		if(!merge)
			return 0;
		if(DSO_load(ctx->dynamic_dso, merge, NULL, 0))
			{
			/* Found what we're looking for */
			OPENSSL_free(merge);
			return 1;
			}
		OPENSSL_free(merge);
		}
	return 0;
	}

d361 2
a362 10
	if(!ctx->dynamic_dso)
		ctx->dynamic_dso = DSO_new();
	if(!ctx->DYNAMIC_LIBNAME)
		{
		if(!ctx->engine_id)
			return 0;
		ctx->DYNAMIC_LIBNAME =
			DSO_convert_filename(ctx->dynamic_dso, ctx->engine_id);
		}
	if(!int_load(ctx))
a365 2
		DSO_free(ctx->dynamic_dso);
		ctx->dynamic_dso = NULL;
a411 1
	fns.static_state = ENGINE_get_static_state();
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d149 1
a149 1
	STACK_OF(OPENSSL_STRING) *dirs;
d156 1
a156 1
static void int_free_str(char *s) { OPENSSL_free(s); }
d177 1
a177 1
			sk_OPENSSL_STRING_pop_free(ctx->dirs, int_free_str);
d206 1
a206 1
	c->dirs = sk_OPENSSL_STRING_new_null();
d396 1
a396 1
		sk_OPENSSL_STRING_insert(ctx->dirs, tmp_str, -1);
d414 1
a414 1
	if(!ctx->dir_load || (num = sk_OPENSSL_STRING_num(ctx->dirs)) < 1)
d418 1
a418 1
		const char *s = sk_OPENSSL_STRING_value(ctx->dirs, loop);
@


