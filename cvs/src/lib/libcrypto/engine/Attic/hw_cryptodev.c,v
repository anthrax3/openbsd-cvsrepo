head	1.46;
access;
symbols
	butholakala:1.39
	openssl_1_0_1_g:1.1.1.4
	OPENBSD_5_5:1.39.0.6
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.38.0.10
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.6
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.8
	OPENBSD_5_0:1.38.0.4
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.32.0.4
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	pre_openssl_0_9_8h:1.31
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.6
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	openssl_0_9_7j:1.1.1.3
	openssl:1.1.1
	OPENBSD_3_9:1.29.0.4
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENSSL_0_9_7C:1.1.1.1
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENSSL_0_9_7B:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14;
locks; strict;
comment	@ * @;


1.46
date	2014.06.10.16.15.19;	author deraadt;	state dead;
branches;
next	1.45;
commitid	i7ofdog6OmjCcKaT;

1.45
date	2014.06.09.22.22.20;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	xu8I79lutfEoCDOk;

1.44
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	2nvnQBrv22dLtvTt;

1.43
date	2014.05.30.02.52.11;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2014.05.07.08.31.30;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2014.04.23.05.13.57;	author beck;	state Exp;
branches;
next	1.39;

1.39
date	2013.05.30.15.37.51;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	2010.12.16.16.56.08;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.16.00.07.25;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2010.10.06.22.57.46;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.29.01.46.19;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.03.07.22.07;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2008.09.06.12.20.16;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.26.10.48.16;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.08.00.16.44;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.23.23.08.24;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.29.05.39.21;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.29.16.55.23;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.26.14.34.44;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.15.23.41.49;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.04.21.31.10;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.03.23.44.47;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.03.20.26.30;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.03.20.18.45;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.03.08.48.26;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.07.16.27.47;	author markus;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.15.57.44;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.08.18.45.24;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.20.11.01.15;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.19.18.20.40;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.19.02.37.16;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.19.02.19.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.18.14.36.53;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.18.10.54.34;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.13.18.37.32;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.11.16.21.26;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.11.16.07.14;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.11.12.26.02;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.11.11.18.44;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.09.00.43.30;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.16.22.24.53;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.13;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.05.11.21.35.11;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.20.41.41;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.09;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Abandon the auto-ENGINE /dev/crypto interface.  VIA 3des cbc receives
collateral damage.

The syncronous nature of this mechanism has hampered performance for
symmetric crypto relative to brute-force cpu. The assymetric crypto
support never really materialized in drivers.

So abandon the complexity.
ok tedu beck mikeb
some disagrement from djm but if he wants to test /dev/crypto ciphers
he should do it without this this gigantic API in the way
@
text
@/*
 * Copyright (c) 2002-2004 Theo de Raadt
 * Copyright (c) 2002 Bob Beck <beck@@openbsd.org>
 * Copyright (c) 2002 Markus Friedl
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <openssl/objects.h>
#include <openssl/engine.h>
#include <openssl/evp.h>
#include <openssl/bn.h>

#if (defined(__unix__) || defined(unix)) && !defined(USG)
#include <sys/param.h>
# if (OpenBSD >= 200112) || ((__FreeBSD_version >= 470101 && __FreeBSD_version < 500000) || __FreeBSD_version >= 500041)
# define HAVE_CRYPTODEV
# endif
# if (OpenBSD >= 200110)
# define HAVE_SYSLOG_R
# endif
#endif

#ifndef HAVE_CRYPTODEV

void
ENGINE_load_cryptodev(void)
{
	/* This is a NOP on platforms without /dev/crypto */
	return;
}

#else

#include <sys/types.h>
#include <crypto/cryptodev.h>
#include <openssl/dh.h>
#include <openssl/dsa.h>
#include <openssl/err.h>
#include <openssl/rsa.h>
#include <sys/ioctl.h>

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <syslog.h>
#include <unistd.h>

#if defined(__i386__) || defined(__amd64__)
#include <sys/sysctl.h>
#include <machine/cpu.h>
#include <machine/specialreg.h>

#include <ssl/aes.h>

static int check_viac3aes(void);
#endif

#define CRYPTO_VIAC3_MAX	3

struct dev_crypto_state {
	struct session_op d_sess;
	int d_fd;
};

struct dev_crypto_cipher {
	int	c_id;
	int	c_nid;
	int	c_ivmax;
	int	c_keylen;
};

static u_int32_t cryptodev_asymfeat = 0;

static int get_asym_dev_crypto(void);
static int open_dev_crypto(void);
static int get_dev_crypto(void);
static struct dev_crypto_cipher *cipher_nid_to_cryptodev(int nid);
static int get_cryptodev_ciphers(const int **cnids);
/*static int get_cryptodev_digests(const int **cnids);*/
static int cryptodev_usable_ciphers(const int **nids);
static int cryptodev_usable_digests(const int **nids);
static int cryptodev_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t inl);
static int cryptodev_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc);
static int cryptodev_cleanup(EVP_CIPHER_CTX *ctx);
static int cryptodev_engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
    const int **nids, int nid);
static int cryptodev_engine_digests(ENGINE *e, const EVP_MD **digest,
    const int **nids, int nid);
static int bn2crparam(const BIGNUM *a, struct crparam *crp);
static int crparam2bn(struct crparam *crp, BIGNUM *a);
static void zapparams(struct crypt_kop *kop);
static int cryptodev_asym(struct crypt_kop *kop, int rlen, BIGNUM *r,
    int slen, BIGNUM *s);

static int cryptodev_bn_mod_exp(BIGNUM *r, const BIGNUM *a,
    const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
static int cryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I,
    RSA *rsa, BN_CTX *ctx);
static int cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa,
    BN_CTX *ctx);
static int cryptodev_dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a,
    const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
static int cryptodev_dsa_dsa_mod_exp(DSA *dsa, BIGNUM *t1, BIGNUM *g,
    BIGNUM *u1, BIGNUM *pub_key, BIGNUM *u2, BIGNUM *p,
    BN_CTX *ctx, BN_MONT_CTX *mont);
static DSA_SIG *cryptodev_dsa_do_sign(const unsigned char *dgst,
    int dlen, DSA *dsa);
static int cryptodev_dsa_verify(const unsigned char *dgst, int dgst_len,
    DSA_SIG *sig, DSA *dsa);
static int cryptodev_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,
    const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
    BN_MONT_CTX *m_ctx);
static int cryptodev_dh_compute_key(unsigned char *key,
    const BIGNUM *pub_key, DH *dh);
static int cryptodev_ctrl(ENGINE *e, int cmd, long i, void *p,
    void (*f)());
void ENGINE_load_cryptodev(void);

static const ENGINE_CMD_DEFN cryptodev_defns[] = {
	{ 0, NULL, NULL, 0 }
};

static struct dev_crypto_cipher ciphers[] = {
	{ CRYPTO_DES_CBC,		NID_des_cbc,		8,	 8, },
	{ CRYPTO_3DES_CBC,		NID_des_ede3_cbc,	8,	24, },
	{ CRYPTO_AES_CBC,		NID_aes_128_cbc,	16,	16, },
	{ CRYPTO_AES_CBC,		NID_aes_192_cbc,	16,	24, },
	{ CRYPTO_AES_CBC,		NID_aes_256_cbc,	16,	32, },
	{ CRYPTO_BLF_CBC,		NID_bf_cbc,		8,	16, },
	{ CRYPTO_CAST_CBC,		NID_cast5_cbc,		8,	16, },
	{ 0,				NID_undef,		0,	 0, },
};

#if 0 /* UNUSED */
static struct {
	int	id;
	int	nid;
} digests[] = {
	{ CRYPTO_SHA1_HMAC,		NID_hmacWithSHA1,	},
	{ CRYPTO_RIPEMD160_HMAC,	NID_ripemd160,		},
	{ CRYPTO_MD5_KPDK,		NID_undef,		},
	{ CRYPTO_SHA1_KPDK,		NID_undef,		},
	{ CRYPTO_MD5,			NID_md5,		},
	{ CRYPTO_SHA1,			NID_undef,		},
	{ 0,				NID_undef,		},
};
#endif

/*
 * Return a fd if /dev/crypto seems usable, -1 otherwise.
 */
static int
open_dev_crypto(void)
{
	static int fd = -1;

	if (fd == -1) {
		if ((fd = open("/dev/crypto", O_RDWR, 0)) == -1)
			return (-1);
		/* close on exec */
		if (fcntl(fd, F_SETFD, 1) == -1) {
			close(fd);
			fd = -1;
			return (-1);
		}
	}
	return (fd);
}

static int
get_dev_crypto(void)
{
	int fd, retfd;

	if ((fd = open_dev_crypto()) == -1)
		return (-1);
	if (ioctl(fd, CRIOGET, &retfd) == -1) {
		close(fd);
		return (-1);
	}

	/* close on exec */
	if (fcntl(retfd, F_SETFD, 1) == -1) {
		close(retfd);
		return (-1);
	}
	return (retfd);
}

/* Caching version for asym operations */
static int
get_asym_dev_crypto(void)
{
	static int fd = -1;

	if (fd == -1)
		fd = get_dev_crypto();
	return fd;
}

/* convert libcrypto nids to cryptodev */
static struct dev_crypto_cipher *
cipher_nid_to_cryptodev(int nid)
{
	int i;

	for (i = 0; ciphers[i].c_id; i++)
		if (ciphers[i].c_nid == nid)
			return (&ciphers[i]);
	return (NULL);
}

/*
 * Find out what ciphers /dev/crypto will let us have a session for.
 * XXX note, that some of these openssl doesn't deal with yet!
 * returning them here is harmless, as long as we return NULL
 * when asked for a handler in the cryptodev_engine_ciphers routine
 */
static int
get_cryptodev_ciphers(const int **cnids)
{
	static int nids[CRYPTO_ALGORITHM_MAX + CRYPTO_VIAC3_MAX + 1];
	struct session_op sess;
	int fd, i, count = 0;

	if ((fd = get_dev_crypto()) < 0) {
		*cnids = NULL;
		return (0);
	}
	memset(&sess, 0, sizeof(sess));
	sess.key = (caddr_t)"123456781234567812345678";

	for (i = 0; ciphers[i].c_id && count <= CRYPTO_ALGORITHM_MAX; i++) {
		if (ciphers[i].c_nid == NID_undef)
			continue;
		sess.cipher = ciphers[i].c_id;
		sess.keylen = ciphers[i].c_keylen;
		sess.mac = 0;
		if (ioctl(fd, CIOCGSESSION, &sess) != -1 &&
		    ioctl(fd, CIOCFSESSION, &sess.ses) != -1)
			nids[count++] = ciphers[i].c_nid;
	}
	close(fd);

#if defined(__i386__) || defined(__amd64__)
	/*
	 * Always check for the VIA C3 AES instructions;
	 * even if /dev/crypto is disabled.
	 */
	if (check_viac3aes() >= 1) {
		int have_NID_aes_128_cbc = 0;
		int have_NID_aes_192_cbc = 0;
		int have_NID_aes_256_cbc = 0;

		for (i = 0; i < count; i++) {
			if (nids[i] == NID_aes_128_cbc)
				have_NID_aes_128_cbc = 1;
			if (nids[i] == NID_aes_192_cbc)
				have_NID_aes_192_cbc = 1;
			if (nids[i] == NID_aes_256_cbc)
				have_NID_aes_256_cbc = 1;
		}
		if (!have_NID_aes_128_cbc)
			nids[count++] = NID_aes_128_cbc;
		if (!have_NID_aes_192_cbc)
			nids[count++] = NID_aes_192_cbc;
		if (!have_NID_aes_256_cbc)
			nids[count++] = NID_aes_256_cbc;
	}
#endif

	if (count > 0)
		*cnids = nids;
	else
		*cnids = NULL;
	return (count);
}

/*
 * Find out what digests /dev/crypto will let us have a session for.
 * XXX note, that some of these openssl doesn't deal with yet!
 * returning them here is harmless, as long as we return NULL
 * when asked for a handler in the cryptodev_engine_digests routine
 */
#if 0 /* UNUSED */
static int
get_cryptodev_digests(const int **cnids)
{
	static int nids[CRYPTO_ALGORITHM_MAX];
	struct session_op sess;
	int fd, i, count = 0;

	if ((fd = get_dev_crypto()) < 0) {
		*cnids = NULL;
		return (0);
	}
	memset(&sess, 0, sizeof(sess));
	for (i = 0; digests[i].id && count < CRYPTO_ALGORITHM_MAX; i++) {
		if (digests[i].nid == NID_undef)
			continue;
		sess.mac = digests[i].id;
		sess.cipher = 0;
		if (ioctl(fd, CIOCGSESSION, &sess) != -1 &&
		    ioctl(fd, CIOCFSESSION, &sess.ses) != -1)
			nids[count++] = digests[i].nid;
	}
	close(fd);

	if (count > 0)
		*cnids = nids;
	else
		*cnids = NULL;
	return (count);
}
#endif

/*
 * Find the useable ciphers|digests from dev/crypto - this is the first
 * thing called by the engine init crud which determines what it
 * can use for ciphers from this engine. We want to return
 * only what we can do, anythine else is handled by software.
 *
 * If we can't initialize the device to do anything useful for
 * any reason, we want to return a NULL array, and 0 length,
 * which forces everything to be done is software. By putting
 * the initalization of the device in here, we ensure we can
 * use this engine as the default, and if for whatever reason
 * /dev/crypto won't do what we want it will just be done in
 * software
 *
 * This can (should) be greatly expanded to perhaps take into
 * account speed of the device, and what we want to do.
 * (although the disabling of particular alg's could be controlled
 * by the device driver with sysctl's.) - this is where we
 * want most of the decisions made about what we actually want
 * to use from /dev/crypto.
 */
static int
cryptodev_usable_ciphers(const int **nids)
{
	return (get_cryptodev_ciphers(nids));
}

static int
cryptodev_usable_digests(const int **nids)
{
	/*
	 * XXXX just disable all digests for now, because it sucks.
	 * we need a better way to decide this - i.e. I may not
	 * want digests on slow cards like hifn on fast machines,
	 * but might want them on slow or loaded machines, etc.
	 * will also want them when using crypto cards that don't
	 * suck moose gonads - would be nice to be able to decide something
	 * as reasonable default without having hackery that's card dependent.
	 * of course, the default should probably be just do everything,
	 * with perhaps a sysctl to turn algoritms off (or have them off
	 * by default) on cards that generally suck like the hifn.
	 */
	*nids = NULL;
	return (0);
}

static int
cryptodev_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t inl)
{
	struct crypt_op cryp;
	struct dev_crypto_state *state = ctx->cipher_data;
	struct session_op *sess = &state->d_sess;
	void *iiv;
	unsigned char save_iv[EVP_MAX_IV_LENGTH];

	if (state->d_fd < 0)
		return (0);
	if (!inl)
		return (1);
	if ((inl % ctx->cipher->block_size) != 0)
		return (0);

	memset(&cryp, 0, sizeof(cryp));

	cryp.ses = sess->ses;
	cryp.flags = 0;
	cryp.len = inl;
	cryp.src = (caddr_t) in;
	cryp.dst = (caddr_t) out;
	cryp.mac = 0;

	cryp.op = ctx->encrypt ? COP_ENCRYPT : COP_DECRYPT;

	if (ctx->cipher->iv_len) {
		cryp.iv = (caddr_t) ctx->iv;
		if (!ctx->encrypt) {
			iiv = (void *) in + inl - ctx->cipher->iv_len;
			memcpy(save_iv, iiv, ctx->cipher->iv_len);
		}
	} else
		cryp.iv = NULL;

	if (ioctl(state->d_fd, CIOCCRYPT, &cryp) == -1) {
		/* XXX need better errror handling
		 * this can fail for a number of different reasons.
		 */
		return (0);
	}

	if (ctx->cipher->iv_len) {
		if (ctx->encrypt)
			iiv = (void *) out + inl - ctx->cipher->iv_len;
		else
			iiv = save_iv;
		memcpy(ctx->iv, iiv, ctx->cipher->iv_len);
	}
	return (1);
}

static int
cryptodev_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	struct dev_crypto_state *state = ctx->cipher_data;
	struct session_op *sess = &state->d_sess;
	struct dev_crypto_cipher *cipher;

	if ((cipher = cipher_nid_to_cryptodev(ctx->cipher->nid)) == NULL)
		return (0);

	if (ctx->cipher->iv_len > cipher->c_ivmax)
		return (0);

	if (ctx->key_len != cipher->c_keylen)
		return (0);

	memset(sess, 0, sizeof(struct session_op));

	if ((state->d_fd = get_dev_crypto()) < 0)
		return (0);

	sess->key = (unsigned char *)key;
	sess->keylen = ctx->key_len;
	sess->cipher = cipher->c_id;

	if (ioctl(state->d_fd, CIOCGSESSION, sess) == -1) {
		close(state->d_fd);
		state->d_fd = -1;
		return (0);
	}
	return (1);
}

/*
 * free anything we allocated earlier when initting a
 * session, and close the session.
 */
static int
cryptodev_cleanup(EVP_CIPHER_CTX *ctx)
{
	int ret = 0;
	struct dev_crypto_state *state = ctx->cipher_data;
	struct session_op *sess = &state->d_sess;

	if (state->d_fd < 0)
		return (0);

	/* XXX if this ioctl fails, someting's wrong. the invoker
	 * may have called us with a bogus ctx, or we could
	 * have a device that for whatever reason just doesn't
	 * want to play ball - it's not clear what's right
	 * here - should this be an error? should it just
	 * increase a counter, hmm. For right now, we return
	 * 0 - I don't believe that to be "right". we could
	 * call the gorpy openssl lib error handlers that
	 * print messages to users of the library. hmm..
	 */

	if (ioctl(state->d_fd, CIOCFSESSION, &sess->ses) == -1) {
		ret = 0;
	} else {
		ret = 1;
	}
	close(state->d_fd);
	state->d_fd = -1;

	return (ret);
}

/*
 * libcrypto EVP stuff - this is how we get wired to EVP so the engine
 * gets called when libcrypto requests a cipher NID.
 */

/* DES CBC EVP */
const EVP_CIPHER cryptodev_des_cbc = {
	NID_des_cbc,
	8, 8, 8,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

/* 3DES CBC EVP */
const EVP_CIPHER cryptodev_3des_cbc = {
	NID_des_ede3_cbc,
	8, 24, 8,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

const EVP_CIPHER cryptodev_bf_cbc = {
	NID_bf_cbc,
	8, 16, 8,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

const EVP_CIPHER cryptodev_cast_cbc = {
	NID_cast5_cbc,
	8, 16, 8,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

EVP_CIPHER cryptodev_aes_128_cbc = {
	NID_aes_128_cbc,
	16, 16, 16,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

EVP_CIPHER cryptodev_aes_192_cbc = {
	NID_aes_192_cbc,
	16, 24, 16,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

EVP_CIPHER cryptodev_aes_256_cbc = {
	NID_aes_256_cbc,
	16, 32, 16,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

#if defined(__i386__) || defined(__amd64__)

static inline void
viac3_xcrypt_cbc(int *cw, const void *src, void *dst, void *key, int rep,
    void *iv)
{
#ifdef notdef
	printf("cw %p[%x %x %x %x] src %p dst %p key %p rep %x iv %p\n",
	    cw, cw[0], cw[1], cw[2], cw[3],
	    src, dst, key, rep, iv);
#endif
#if defined(__i386__)

	/*
	 * Clear bit 30 of EFLAGS.
	 */
	__asm __volatile("pushfl; popfl");

	/*
	 * Cannot simply place key into "b" register, since the compiler
	 * -pic mode uses that register; so instead we must dance a little.
	 */
	__asm __volatile("pushl %%ebx; movl %0, %%ebx; rep xcryptcbc; popl %%ebx" :
	    : "m" (key), "a" (iv), "c" (rep), "d" (cw), "S" (src), "D" (dst)
	    : "memory", "cc");
#else

	/*
	 * Clear bit 30 of EFLAGS.
	 */
	__asm __volatile("pushfq; popfq");
	__asm __volatile("rep xcryptcbc" :
	    : "b" (key), "a" (iv), "c" (rep), "d" (cw), "S" (src), "D" (dst)
	    : "memory", "cc");
#endif

}

#define ISUNALIGNED(x)	((long)(x)) & 15
#define DOALIGN(v)	((void *)(((long)(v) + 15) & ~15))

static int
xcrypt_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t inl)
{
	unsigned char *save_iv_store[EVP_MAX_IV_LENGTH + 15];
	unsigned char *save_iv = DOALIGN(save_iv_store);
	unsigned char *ivs_store[EVP_MAX_IV_LENGTH + 15];
	unsigned char *ivs = DOALIGN(ivs_store);
	void *iiv, *iv = NULL, *ivp = NULL;
	const void *usein = in;
	void *useout = out, *spare = NULL;
	int cws[4 + 3], *cw = DOALIGN(cws);

	if (!inl)
		return (1);
	if ((inl % ctx->cipher->block_size) != 0)
		return (0);
	if (inl > UINT_MAX)
		return (0);

	if (ISUNALIGNED(in) || ISUNALIGNED(out)) {
		spare = malloc(inl);
		if (spare == NULL)
			return (0);

		if (ISUNALIGNED(in)) {
			bcopy(in, spare, inl);
			usein = spare;
		}
		if (ISUNALIGNED(out))
			useout = spare;
	}

	cw[0] = C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_SW |
	    C3_CRYPT_CWLO_NORMAL;
	cw[0] |= ctx->encrypt ? C3_CRYPT_CWLO_ENCRYPT : C3_CRYPT_CWLO_DECRYPT;
	cw[1] = cw[2] = cw[3] = 0;

	switch (ctx->key_len * 8) {
	case 128:
		cw[0] |= C3_CRYPT_CWLO_KEY128;
		break;
	case 192:
		cw[0] |= C3_CRYPT_CWLO_KEY192;
		break;
	case 256:
		cw[0] |= C3_CRYPT_CWLO_KEY256;
		break;
	}

	if (ctx->cipher->iv_len) {
		iv = (caddr_t) ctx->iv;
		if (!ctx->encrypt) {
			iiv = (void *) in + inl - ctx->cipher->iv_len;
			memcpy(save_iv, iiv, ctx->cipher->iv_len);
		}
	}

	ivp = iv;
	if (ISUNALIGNED(iv)) {
		bcopy(iv, ivs, ctx->cipher->iv_len);
		ivp = ivs;
	}

	viac3_xcrypt_cbc(cw, usein, useout, ctx->cipher_data,  inl / 16, ivp);

	if (ISUNALIGNED(in) || ISUNALIGNED(out)) {
		if (ISUNALIGNED(out))
			bcopy(spare, out, inl);
		free(spare);
	}

	if (ivp == ivs)
		bcopy(ivp, iv, ctx->cipher->iv_len);

	if (ctx->cipher->iv_len) {
		if (ctx->encrypt)
			iiv = (void *) out + inl - ctx->cipher->iv_len;
		else
			iiv = save_iv;
		memcpy(ctx->iv, iiv, ctx->cipher->iv_len);
	}
	return (1);
}

static int
xcrypt_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	AES_KEY *k = ctx->cipher_data;
#ifndef AES_ASM
	int i;
#endif

	memset(k, 0, sizeof *k);
	if (enc)
		AES_set_encrypt_key(key, ctx->key_len * 8, k);
	else
		AES_set_decrypt_key(key, ctx->key_len * 8, k);

#ifndef AES_ASM
	/*
	 * XXX Damn OpenSSL byte swaps the expanded key!!
	 *
	 * XXX But only if we're using the C implementation of AES
	 */
	for (i = 0; i < 4 * (AES_MAXNR + 1); i++)
		k->rd_key[i] = htonl(k->rd_key[i]);
#endif

	return (1);
}

static int
xcrypt_cleanup(EVP_CIPHER_CTX *ctx)
{
	memset(ctx->cipher_data, 0, ctx->cipher->ctx_size);
	return (1);
}

static int
check_viac3aes(void)
{
	int mib[2] = { CTL_MACHDEP, CPU_XCRYPT }, value;
	size_t size = sizeof(value);

	if (sysctl(mib, sizeof(mib)/sizeof(mib[0]), &value, &size,
	    NULL, 0) < 0)
		return (0);
	if (value == 0)
		return (0);

	if (value & C3_HAS_AES) {
		cryptodev_aes_128_cbc.init = xcrypt_init_key;
		cryptodev_aes_128_cbc.do_cipher = xcrypt_cipher;
		cryptodev_aes_128_cbc.cleanup = xcrypt_cleanup;
		cryptodev_aes_128_cbc.ctx_size = sizeof(AES_KEY);

		cryptodev_aes_192_cbc.init = xcrypt_init_key;
		cryptodev_aes_192_cbc.do_cipher = xcrypt_cipher;
		cryptodev_aes_192_cbc.cleanup = xcrypt_cleanup;
		cryptodev_aes_192_cbc.ctx_size = sizeof(AES_KEY);

		cryptodev_aes_256_cbc.init = xcrypt_init_key;
		cryptodev_aes_256_cbc.do_cipher = xcrypt_cipher;
		cryptodev_aes_256_cbc.cleanup = xcrypt_cleanup;
		cryptodev_aes_256_cbc.ctx_size = sizeof(AES_KEY);
	}
	return (value);
}
#endif /* __i386__ || __amd64__ */

/*
 * Registered by the ENGINE when used to find out how to deal with
 * a particular NID in the ENGINE. this says what we'll do at the
 * top level - note, that list is restricted by what we answer with
 */
static int
cryptodev_engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
    const int **nids, int nid)
{
	if (!cipher)
		return (cryptodev_usable_ciphers(nids));

	switch (nid) {
	case NID_des_ede3_cbc:
		*cipher = &cryptodev_3des_cbc;
		break;
	case NID_des_cbc:
		*cipher = &cryptodev_des_cbc;
		break;
	case NID_bf_cbc:
		*cipher = &cryptodev_bf_cbc;
		break;
	case NID_cast5_cbc:
		*cipher = &cryptodev_cast_cbc;
		break;
	case NID_aes_128_cbc:
		*cipher = &cryptodev_aes_128_cbc;
		break;
	case NID_aes_192_cbc:
		*cipher = &cryptodev_aes_192_cbc;
		break;
	case NID_aes_256_cbc:
		*cipher = &cryptodev_aes_256_cbc;
		break;
	default:
		*cipher = NULL;
		break;
	}
	return (*cipher != NULL);
}

static int
cryptodev_engine_digests(ENGINE *e, const EVP_MD **digest,
    const int **nids, int nid)
{
	if (!digest)
		return (cryptodev_usable_digests(nids));

	switch (nid) {
	case NID_md5:
		*digest = NULL; /* need to make a clean md5 critter */
		break;
	default:
		*digest = NULL;
		break;
	}
	return (*digest != NULL);
}

/*
 * Convert a BIGNUM to the representation that /dev/crypto needs.
 * Upon completion of use, the caller is responsible for freeing
 * crp->crp_p.
 */
static int
bn2crparam(const BIGNUM *a, struct crparam *crp)
{
	int i, j, k;
	ssize_t bytes, bits;
	u_char *b;

	crp->crp_p = NULL;
	crp->crp_nbits = 0;

	bits = BN_num_bits(a);
	bytes = (bits + 7) / 8;

	b = malloc(bytes);
	if (b == NULL)
		return (1);

	crp->crp_p = b;
	crp->crp_nbits = bits;

	for (i = 0, j = 0; i < a->top; i++) {
		for (k = 0; k < BN_BITS2 / 8; k++) {
			if ((j + k) >= bytes)
				return (0);
			b[j + k] = a->d[i] >> (k * 8);
		}
		j += BN_BITS2 / 8;
	}
	return (0);
}

/* Convert a /dev/crypto parameter to a BIGNUM */
static int
crparam2bn(struct crparam *crp, BIGNUM *a)
{
	u_int8_t *pd;
	int i, bytes;

	bytes = (crp->crp_nbits + 7) / 8;

	if (bytes == 0)
		return (-1);

	if ((pd = malloc(bytes)) == NULL)
		return (-1);

	for (i = 0; i < bytes; i++)
		pd[i] = crp->crp_p[bytes - i - 1];

	BN_bin2bn(pd, bytes, a);
	free(pd);

	return (0);
}

static void
zapparams(struct crypt_kop *kop)
{
	int i;

	for (i = 0; i <= kop->crk_iparams + kop->crk_oparams; i++) {
		free(kop->crk_param[i].crp_p);
		kop->crk_param[i].crp_p = NULL;
		kop->crk_param[i].crp_nbits = 0;
	}
}

static int
cryptodev_asym(struct crypt_kop *kop, int rlen, BIGNUM *r, int slen, BIGNUM *s)
{
	int fd, ret = -1;

	if ((fd = get_asym_dev_crypto()) < 0)
		return (ret);

	if (r) {
		kop->crk_param[kop->crk_iparams].crp_p = calloc(rlen, sizeof(char));
		kop->crk_param[kop->crk_iparams].crp_nbits = rlen * 8;
		kop->crk_oparams++;
	}
	if (s) {
		kop->crk_param[kop->crk_iparams+1].crp_p = calloc(slen, sizeof(char));
		kop->crk_param[kop->crk_iparams+1].crp_nbits = slen * 8;
		kop->crk_oparams++;
	}

	if (ioctl(fd, CIOCKEY, kop) == 0) {
		if (r)
			crparam2bn(&kop->crk_param[kop->crk_iparams], r);
		if (s)
			crparam2bn(&kop->crk_param[kop->crk_iparams+1], s);
		ret = 0;
	}

	return (ret);
}

static int
cryptodev_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
	struct crypt_kop kop;
	int ret = 1;

	/* Currently, we know we can do mod exp iff we can do any
	 * asymmetric operations at all.
	 */
	if (cryptodev_asymfeat == 0) {
		ret = BN_mod_exp(r, a, p, m, ctx);
		return (ret);
	}

	memset(&kop, 0, sizeof kop);
	kop.crk_op = CRK_MOD_EXP;

	/* inputs: a^p % m */
	if (bn2crparam(a, &kop.crk_param[0]))
		goto err;
	if (bn2crparam(p, &kop.crk_param[1]))
		goto err;
	if (bn2crparam(m, &kop.crk_param[2]))
		goto err;
	kop.crk_iparams = 3;

	if (cryptodev_asym(&kop, BN_num_bytes(m), r, 0, NULL) == -1) {
		const RSA_METHOD *meth = RSA_PKCS1_SSLeay();
		ret = meth->bn_mod_exp(r, a, p, m, ctx, in_mont);
	}
err:
	zapparams(&kop);
	return (ret);
}

static int
cryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa,
    BN_CTX *ctx)
{
	return (RSA_PKCS1_SSLeay()->rsa_mod_exp)(r0, I, rsa, ctx);
}

static int
cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
{
	struct crypt_kop kop;
	int ret = 1;

	if (!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp) {
		/* XXX 0 means failure?? */
		return (0);
	}

	memset(&kop, 0, sizeof kop);
	kop.crk_op = CRK_MOD_EXP_CRT;
	/* inputs: rsa->p rsa->q I rsa->dmp1 rsa->dmq1 rsa->iqmp */
	if (bn2crparam(rsa->p, &kop.crk_param[0]))
		goto err;
	if (bn2crparam(rsa->q, &kop.crk_param[1]))
		goto err;
	if (bn2crparam(I, &kop.crk_param[2]))
		goto err;
	if (bn2crparam(rsa->dmp1, &kop.crk_param[3]))
		goto err;
	if (bn2crparam(rsa->dmq1, &kop.crk_param[4]))
		goto err;
	if (bn2crparam(rsa->iqmp, &kop.crk_param[5]))
		goto err;
	kop.crk_iparams = 6;

	if (cryptodev_asym(&kop, BN_num_bytes(rsa->n), r0, 0, NULL) == -1) {
		const RSA_METHOD *meth = RSA_PKCS1_SSLeay();
		ret = (*meth->rsa_mod_exp)(r0, I, rsa, ctx);
	}
err:
	zapparams(&kop);
	return (ret);
}

static RSA_METHOD cryptodev_rsa = {
	.name = "cryptodev RSA method"
};

static int
cryptodev_dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,
    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
	return (cryptodev_bn_mod_exp(r, a, p, m, ctx, m_ctx));
}

static int
cryptodev_dsa_dsa_mod_exp(DSA *dsa, BIGNUM *t1, BIGNUM *g,
    BIGNUM *u1, BIGNUM *pub_key, BIGNUM *u2, BIGNUM *p,
    BN_CTX *ctx, BN_MONT_CTX *mont)
{
	BIGNUM t2;
	int ret = 0;

	BN_init(&t2);

	/* v = ( g^u1 * y^u2 mod p ) mod q */
	/* let t1 = g ^ u1 mod p */
	ret = 0;

	if (!dsa->meth->bn_mod_exp(dsa,t1,dsa->g,u1,dsa->p,ctx,mont))
		goto err;

	/* let t2 = y ^ u2 mod p */
	if (!dsa->meth->bn_mod_exp(dsa,&t2,dsa->pub_key,u2,dsa->p,ctx,mont))
		goto err;
	/* let u1 = t1 * t2 mod p */
	if (!BN_mod_mul(u1,t1,&t2,dsa->p,ctx))
		goto err;

	BN_copy(t1,u1);

	ret = 1;
err:
	BN_free(&t2);
	return(ret);
}

static DSA_SIG *
cryptodev_dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)
{
	struct crypt_kop kop;
	BIGNUM *r = NULL, *s = NULL;
	DSA_SIG *dsaret = NULL;

	if ((r = BN_new()) == NULL)
		goto err;
	if ((s = BN_new()) == NULL) {
		BN_free(r);
		goto err;
	}

	memset(&kop, 0, sizeof kop);
	kop.crk_op = CRK_DSA_SIGN;

	/* inputs: dgst dsa->p dsa->q dsa->g dsa->priv_key */
	kop.crk_param[0].crp_p = (caddr_t)dgst;
	kop.crk_param[0].crp_nbits = dlen * 8;
	if (bn2crparam(dsa->p, &kop.crk_param[1]))
		goto err;
	if (bn2crparam(dsa->q, &kop.crk_param[2]))
		goto err;
	if (bn2crparam(dsa->g, &kop.crk_param[3]))
		goto err;
	if (bn2crparam(dsa->priv_key, &kop.crk_param[4]))
		goto err;
	kop.crk_iparams = 5;

	if (cryptodev_asym(&kop, BN_num_bytes(dsa->q), r,
	    BN_num_bytes(dsa->q), s) == 0) {
		dsaret = DSA_SIG_new();
		dsaret->r = r;
		dsaret->s = s;
	} else {
		const DSA_METHOD *meth = DSA_OpenSSL();
		BN_free(r);
		BN_free(s);
		dsaret = (meth->dsa_do_sign)(dgst, dlen, dsa);
	}
err:
	kop.crk_param[0].crp_p = NULL;
	zapparams(&kop);
	return (dsaret);
}

static int
cryptodev_dsa_verify(const unsigned char *dgst, int dlen,
    DSA_SIG *sig, DSA *dsa)
{
	struct crypt_kop kop;
	int dsaret = 1;

	memset(&kop, 0, sizeof kop);
	kop.crk_op = CRK_DSA_VERIFY;

	/* inputs: dgst dsa->p dsa->q dsa->g dsa->pub_key sig->r sig->s */
	kop.crk_param[0].crp_p = (caddr_t)dgst;
	kop.crk_param[0].crp_nbits = dlen * 8;
	if (bn2crparam(dsa->p, &kop.crk_param[1]))
		goto err;
	if (bn2crparam(dsa->q, &kop.crk_param[2]))
		goto err;
	if (bn2crparam(dsa->g, &kop.crk_param[3]))
		goto err;
	if (bn2crparam(dsa->pub_key, &kop.crk_param[4]))
		goto err;
	if (bn2crparam(sig->r, &kop.crk_param[5]))
		goto err;
	if (bn2crparam(sig->s, &kop.crk_param[6]))
		goto err;
	kop.crk_iparams = 7;

	if (cryptodev_asym(&kop, 0, NULL, 0, NULL) == 0) {
		dsaret = kop.crk_status;
	} else {
		const DSA_METHOD *meth = DSA_OpenSSL();

		dsaret = (meth->dsa_do_verify)(dgst, dlen, sig, dsa);
	}
err:
	kop.crk_param[0].crp_p = NULL;
	zapparams(&kop);
	return (dsaret);
}

static DSA_METHOD cryptodev_dsa = {
	.name = "cryptodev DSA method"
};

static int
cryptodev_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,
    const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
    BN_MONT_CTX *m_ctx)
{
	return (cryptodev_bn_mod_exp(r, a, p, m, ctx, m_ctx));
}

static int
cryptodev_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
{
	struct crypt_kop kop;
	int dhret = 1;
	int fd, keylen;

	if ((fd = get_asym_dev_crypto()) < 0) {
		const DH_METHOD *meth = DH_OpenSSL();

		return ((meth->compute_key)(key, pub_key, dh));
	}

	keylen = BN_num_bits(dh->p);

	memset(&kop, 0, sizeof kop);
	kop.crk_op = CRK_DH_COMPUTE_KEY;

	/* inputs: dh->priv_key pub_key dh->p key */
	if (bn2crparam(dh->priv_key, &kop.crk_param[0]))
		goto err;
	if (bn2crparam(pub_key, &kop.crk_param[1]))
		goto err;
	if (bn2crparam(dh->p, &kop.crk_param[2]))
		goto err;
	kop.crk_iparams = 3;

	kop.crk_param[3].crp_p = key;
	kop.crk_param[3].crp_nbits = keylen * 8;
	kop.crk_oparams = 1;

	if (ioctl(fd, CIOCKEY, &kop) == -1) {
		const DH_METHOD *meth = DH_OpenSSL();

		dhret = (meth->compute_key)(key, pub_key, dh);
	}
err:
	kop.crk_param[3].crp_p = NULL;
	zapparams(&kop);
	return (dhret);
}

static DH_METHOD cryptodev_dh = {
	.name = "cryptodev DH method"
};

/*
 * ctrl right now is just a wrapper that doesn't do much
 * but I expect we'll want some options soon.
 */
static int
cryptodev_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)())
{
#ifdef HAVE_SYSLOG_R
	struct syslog_data sd = SYSLOG_DATA_INIT;
#endif

	switch (cmd) {
	default:
#ifdef HAVE_SYSLOG_R
		syslog_r(LOG_ERR, &sd,
		    "cryptodev_ctrl: unknown command %d", cmd);
#else
		syslog(LOG_ERR, "cryptodev_ctrl: unknown command %d", cmd);
#endif
		break;
	}
	return (1);
}

void
ENGINE_load_cryptodev(void)
{
	ENGINE *engine = ENGINE_new();
	int fd;

	if (engine == NULL)
		return;
	if ((fd = get_dev_crypto()) < 0) {
		ENGINE_free(engine);
		return;
	}

	/*
	 * find out what asymmetric crypto algorithms we support
	 */
	if (ioctl(fd, CIOCASYMFEAT, &cryptodev_asymfeat) == -1) {
		close(fd);
		ENGINE_free(engine);
		return;
	}
	close(fd);

	if (!ENGINE_set_id(engine, "cryptodev") ||
	    !ENGINE_set_name(engine, "BSD cryptodev engine") ||
	    !ENGINE_set_ciphers(engine, cryptodev_engine_ciphers) ||
	    !ENGINE_set_digests(engine, cryptodev_engine_digests) ||
	    !ENGINE_set_ctrl_function(engine, cryptodev_ctrl) ||
	    !ENGINE_set_cmd_defns(engine, cryptodev_defns)) {
		ENGINE_free(engine);
		return;
	}

	if (ENGINE_set_RSA(engine, &cryptodev_rsa)) {
		const RSA_METHOD *rsa_meth = RSA_PKCS1_SSLeay();

		cryptodev_rsa.bn_mod_exp = rsa_meth->bn_mod_exp;
		cryptodev_rsa.rsa_mod_exp = rsa_meth->rsa_mod_exp;
		cryptodev_rsa.rsa_pub_enc = rsa_meth->rsa_pub_enc;
		cryptodev_rsa.rsa_pub_dec = rsa_meth->rsa_pub_dec;
		cryptodev_rsa.rsa_priv_enc = rsa_meth->rsa_priv_enc;
		cryptodev_rsa.rsa_priv_dec = rsa_meth->rsa_priv_dec;
		if (cryptodev_asymfeat & CRF_MOD_EXP) {
			cryptodev_rsa.bn_mod_exp = cryptodev_bn_mod_exp;
			if (cryptodev_asymfeat & CRF_MOD_EXP_CRT)
				cryptodev_rsa.rsa_mod_exp =
				    cryptodev_rsa_mod_exp;
			else
				cryptodev_rsa.rsa_mod_exp =
				    cryptodev_rsa_nocrt_mod_exp;
		}
	}

	if (ENGINE_set_DSA(engine, &cryptodev_dsa)) {
		const DSA_METHOD *meth = DSA_OpenSSL();

		memcpy(&cryptodev_dsa, meth, sizeof(DSA_METHOD));
		if (cryptodev_asymfeat & CRF_DSA_SIGN)
			cryptodev_dsa.dsa_do_sign = cryptodev_dsa_do_sign;
		if (cryptodev_asymfeat & CRF_MOD_EXP) {
			cryptodev_dsa.bn_mod_exp = cryptodev_dsa_bn_mod_exp;
			cryptodev_dsa.dsa_mod_exp = cryptodev_dsa_dsa_mod_exp;
		}
		if (cryptodev_asymfeat & CRF_DSA_VERIFY)
			cryptodev_dsa.dsa_do_verify = cryptodev_dsa_verify;
	}

	if (ENGINE_set_DH(engine, &cryptodev_dh)){
		const DH_METHOD *dh_meth = DH_OpenSSL();

		cryptodev_dh.generate_key = dh_meth->generate_key;
		cryptodev_dh.compute_key = dh_meth->compute_key;
		cryptodev_dh.bn_mod_exp = dh_meth->bn_mod_exp;
		if (cryptodev_asymfeat & CRF_MOD_EXP) {
			cryptodev_dh.bn_mod_exp = cryptodev_mod_exp_dh;
			if (cryptodev_asymfeat & CRF_DH_COMPUTE_KEY)
				cryptodev_dh.compute_key =
				    cryptodev_dh_compute_key;
		}
	}

	ENGINE_add(engine);
	ENGINE_free(engine);
	ERR_clear_error();
}

#endif /* HAVE_CRYPTODEV */
@


1.45
log
@use memset instead of bzero
@
text
@@


1.44
log
@malloc() result does not need a cast.
ok miod
@
text
@d746 1
a746 1
	bzero(k, sizeof *k);
d768 1
a768 1
	bzero(ctx->cipher_data, ctx->cipher->ctx_size);
@


1.43
log
@no need for null check before free. from Brendan MacDonell
@
text
@d911 1
a911 1
	if ((pd = (u_int8_t *) malloc(bytes)) == NULL)
@


1.42
log
@add additional includes from eng_cryptodev.c
makes this compile with OPENSSL_NO_DEPRECATED defined.
ok deraadt@@
@
text
@d929 1
a929 2
		if (kop->crk_param[i].crp_p)
			free(kop->crk_param[i].crp_p);
@


1.41
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d32 1
d57 4
@


1.40
log
@Make libssl and libcrypto compile with -Werror
ok miod@@
@
text
@d1042 1
a1042 13
	"cryptodev RSA method",
	NULL,				/* rsa_pub_enc */
	NULL,				/* rsa_pub_dec */
	NULL,				/* rsa_priv_enc */
	NULL,				/* rsa_priv_dec */
	NULL,
	NULL,
	NULL,				/* init */
	NULL,				/* finish */
	0,				/* flags */
	NULL,				/* app_data */
	NULL,				/* rsa_sign */
	NULL				/* rsa_verify */
d1172 1
a1172 10
	"cryptodev DSA method",
	NULL,
	NULL,				/* dsa_sign_setup */
	NULL,
	NULL,				/* dsa_mod_exp */
	NULL,
	NULL,				/* init */
	NULL,				/* finish */
	0,	/* flags */
	NULL	/* app_data */
d1226 1
a1226 8
	"cryptodev DH method",
	NULL,				/* cryptodev_dh_generate_key */
	NULL,
	NULL,
	NULL,
	NULL,
	0,	/* flags */
	NULL	/* app_data */
@


1.39
log
@Switch to using unhyphenated VIA padlock mnemonics.  VIA abandoned the
hyphen in their official programming guide sometime between 2003 and
2005, and Clang's integrated assembler does not support hyphenated
mnemonics.

ok jsg, deraadt
@
text
@d657 1
a657 1
	void *useout = out, *spare;
@


1.38
log
@move CRYPTO_VIAC3_MAX out of cryptodev.h and into the only
file it will be used from.

requested by/ok mikeb@@
@
text
@d628 1
a628 1
	__asm __volatile("pushl %%ebx; movl %0, %%ebx; rep xcrypt-cbc; popl %%ebx" :
d637 1
a637 1
	__asm __volatile("rep xcrypt-cbc" :
@


1.37
log
@The VIA ciphers are added to an array of CRYPTO_ALGORITHM_MAX length
which should have been declared as CRYPTO_ALGORITHM_MAX + 1,
fix this and reserve enough space for the VIA additions as well.

ok/comments from mikeb & deraadt
@
text
@d77 2
@


1.36
log
@More OpenSSL fixes:

- Update local engines for the EVP API change (len u_int => size_t)
- Use hw_cryptodev.c instead of eng_cryptodev.c
- Make x86_64-xlate.pl always write to the output file and not stdout,
  fixing "make -j" builds (spotted by naddy@@)

ok naddy@@
@
text
@d241 1
a241 1
	static int nids[CRYPTO_ALGORITHM_MAX];
d252 1
a252 1
	for (i = 0; ciphers[i].c_id && count < CRYPTO_ALGORITHM_MAX; i++) {
@


1.35
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@a58 2
#include <stdio.h>
#include <unistd.h>
d60 1
d62 2
d65 1
a65 2
#include <errno.h>
#include <string.h>
d100 1
a100 1
    const unsigned char *in, unsigned int inl);
d384 1
a384 1
    const unsigned char *in, unsigned int inl)
d647 1
a647 1
    const unsigned char *in, unsigned int inl)
d661 2
@


1.34
log
@VIA xcrypt for amd64, simpler version of a diff from deraadt
with suggestions from miod.

The codepath doesn't seem to be called yet, this will be
investigated later.

looks good miod@@, ok deraadt@@
@
text
@a149 1
	{ CRYPTO_SKIPJACK_CBC,		NID_undef,		0,	 0, },
@


1.33
log
@When running in pic mode we don't have enough general registers for all
the xcrypt inputs, hence the dance which is done to make this work.

The constraint for the key however was "mr" which is both from
memory and from a general register, it seems gcc3 went with the former
and gcc4 went with the later in the pic case, so change the
constraint for the key to just "m" which gives us more efficient
code that both gcc3 and gcc4 are happy with.

ok kettenis@@
@
text
@d67 1
a67 1
#ifdef __i386__
d265 1
a265 1
#if defined(__i386__)
d267 1
a267 1
	 * On i386, always check for the VIA C3 AES instructions;
d605 1
a605 1
#if defined(__i386__)
d612 1
a612 1
	printf("cw %x[%x %x %x %x] src %x dst %x key %x rep %x iv %x\n",
d616 2
d630 11
d794 1
a794 1
#endif /* __i386__ */
@


1.32
log
@remerge local tweaks, update per-arch configuration headers, update
Makefiles, crank shlib_version
@
text
@d626 1
a626 1
	    : "mr" (key), "a" (iv), "c" (rep), "d" (cw), "S" (src), "D" (dst)
@


1.31
log
@fix memory leak (in one case of unaligned buffers); from Markus Kvetter
ok markus
@
text
@d117 3
a119 2
    RSA *rsa);
static int cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa);
d982 2
a983 1
cryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)
d985 1
a985 7
	int r;
	BN_CTX *ctx;

	ctx = BN_CTX_new();
	r = cryptodev_bn_mod_exp(r0, I, rsa->d, rsa->n, ctx, NULL);
	BN_CTX_free(ctx);
	return (r);
d989 1
a989 1
cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)
d1018 1
a1018 1
		ret = (*meth->rsa_mod_exp)(r0, I, rsa);
@


1.30
log
@potential fd leak (we will fix this before we move to cloning)
@
text
@d696 3
a698 2
	if (ISUNALIGNED(out)) {
		bcopy(spare, out, inl);
@


1.29
log
@no need to byteswap for AES_ASM, from tom@@
@
text
@d196 2
a197 1
	if (ioctl(fd, CRIOGET, &retfd) == -1)
d199 1
@


1.28
log
@resolve conflicts
@
text
@d717 1
d719 1
d727 6
a732 1
	/* Damn OpenSSL byte swaps the expanded key!! */
d735 1
@


1.27
log
@adjust comment, open_dev_crypto() returns -1 on error.

ok markus@@
@
text
@d96 1
a96 1
static int get_cryptodev_digests(const int **cnids);
d153 1
d166 1
d302 1
d332 1
d839 1
a839 1
	ssize_t words, bytes, bits;
@


1.26
log
@on error set correct pointer to NULL.
From phk@@freebsd.org

ok markus@@
@
text
@d167 1
a167 1
 * Return a fd if /dev/crypto seems usable, 0 otherwise.
@


1.25
log
@machdep.xcrypt now has a different meaning: Instead of > 0 indicating
that AES is there, we now have 3 flag bits: C3_HAS_AES, C3_HAS_SHA
(SHA1 & SHA256), and C3_HAS_MM (RSA).  Change this code to only look
at C3_HAS_AES for now.
@
text
@d242 1
a242 1
		*nids = NULL;
d308 1
a308 1
		*nids = NULL;
@


1.24
log
@merge 0.9.7d
@
text
@d747 5
a751 4
	cryptodev_aes_128_cbc.init = xcrypt_init_key;
	cryptodev_aes_128_cbc.do_cipher = xcrypt_cipher;
	cryptodev_aes_128_cbc.cleanup = xcrypt_cleanup;
	cryptodev_aes_128_cbc.ctx_size = sizeof(AES_KEY);
d753 4
a756 4
	cryptodev_aes_192_cbc.init = xcrypt_init_key;
	cryptodev_aes_192_cbc.do_cipher = xcrypt_cipher;
	cryptodev_aes_192_cbc.cleanup = xcrypt_cleanup;
	cryptodev_aes_192_cbc.ctx_size = sizeof(AES_KEY);
d758 5
a762 4
	cryptodev_aes_256_cbc.init = xcrypt_init_key;
	cryptodev_aes_256_cbc.do_cipher = xcrypt_cipher;
	cryptodev_aes_256_cbc.cleanup = xcrypt_cleanup;
	cryptodev_aes_256_cbc.ctx_size = sizeof(AES_KEY);
@


1.23
log
@remove some debug code and cleanup..
@
text
@d1260 2
a1261 1
	if ((fd = get_dev_crypto()) < 0)
d1263 1
d1270 1
@


1.22
log
@OK, this time the AES soft keys work with ssh and such.  I spent over 3
hours learning that OpenSSL's internal functions for AES extended keys
generate screwy byte order swapped data..
@
text
@d2 1
a3 1
 * Copyright (c) 2002 Theo de Raadt
a57 2
#include <ssl/aes.h>

d71 3
d265 1
a265 1
	if (check_viac3aes() == 1) {
a712 1
	u_long *kk = (u_long *)key;
a715 6
#ifdef notdef
	for (i = 0; i < ctx->key_len / 4; i++)
		printf("%08x ", kk[i]);
	printf("\n");
#endif

a724 6
#ifdef notdef
	for (i = 0; i < 4 * (AES_MAXNR + 1); i++)
		printf("%08x ", k->rd_key[i]);
	printf("\n");
#endif

d761 1
a761 1
	return (1);
@


1.21
log
@oops, software key gen bug
@
text
@d58 2
d73 1
a73 1
static void check_viac3aes(void);
d264 20
a283 1
	check_viac3aes();
d599 2
a600 2
volatile static void
viac3_crypto(int *cw, const void *src, void *dst, void *key, int rep,
d656 3
a658 3
	cw[0] = C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_HW |
	    C3_CRYPT_CWLO_NORMAL |
	    ctx->encrypt ? C3_CRYPT_CWLO_ENCRYPT : C3_CRYPT_CWLO_DECRYPT;
d687 1
a687 1
	viac3_crypto(cw, usein, useout, ctx->cipher_data,  inl / 16, ivp);
d711 26
a736 1
	bcopy(key, ctx->cipher_data, ctx->key_len);
d743 1
a743 1
	bzero(ctx->cipher_data, ctx->key_len);
d747 1
a747 1
static void
d755 1
a755 1
		return;
d757 1
a757 1
		return;
d762 1
a762 1
	cryptodev_aes_128_cbc.ctx_size = 128;
d767 1
a767 1
	cryptodev_aes_192_cbc.ctx_size = 128;
d772 2
a773 1
	cryptodev_aes_256_cbc.ctx_size = 128;
@


1.20
log
@Switch to using software generated extended keys (because the cpu cannot
yet generate 192 & 256 bit keys).  Ensure that 192 and 256 are in the
nids table.  This also accelerates performance for 128 a tiny bit:

type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes
aes-128-cbc      34921.48k   129617.82k   362059.93k   623649.81k   790397.77k
aes-192-cbc      26227.43k    99215.33k   283242.84k   509881.15k   665323.22k
aes-256-cbc      26133.22k    97458.06k   265990.84k   457824.69k   579835.09k
@
text
@a57 2
#include <ssl/aes.h>

d71 1
a71 1
static int check_viac3aes(void);
d262 1
a262 20
	if (check_viac3aes() == 1) {
		int have_NID_aes_128_cbc = 0;
		int have_NID_aes_192_cbc = 0;
		int have_NID_aes_256_cbc = 0;

		for (i = 0; i < count; i++) {
			if (nids[i] == NID_aes_128_cbc)
				have_NID_aes_128_cbc = 1;
			if (nids[i] == NID_aes_192_cbc)
				have_NID_aes_192_cbc = 1;
			if (nids[i] == NID_aes_256_cbc)
				have_NID_aes_256_cbc = 1;
		}
		if (!have_NID_aes_128_cbc)
			nids[count++] = NID_aes_128_cbc;
		if (!have_NID_aes_192_cbc)
			nids[count++] = NID_aes_192_cbc;
		if (!have_NID_aes_256_cbc)
			nids[count++] = NID_aes_256_cbc;
	}
d635 1
a635 1
	cw[0] = C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_SW |
d690 1
a690 4
	if (enc)
		AES_set_encrypt_key(key, 128, ctx->cipher_data);
	else
		AES_set_decrypt_key(key, 128, ctx->cipher_data);
d701 1
a701 1
static int
d709 1
a709 1
		return (0);
d711 1
a711 1
		return (0);
d716 1
a716 1
	cryptodev_aes_128_cbc.ctx_size = sizeof(AES_KEY);
d721 1
a721 1
	cryptodev_aes_192_cbc.ctx_size = sizeof(AES_KEY);
d726 1
a726 2
	cryptodev_aes_256_cbc.ctx_size = sizeof(AES_KEY);
	return (1);
@


1.19
log
@If on an i386, detect existance of the VIA C3 xcrypt-* using sysctl of
the machdep.xcrypt node.  If they exist, use the xcrypt-cbc instruction
to accelerate aes-{128,192,256}-cbc, for more than 100x performance
increase. This code has no effect on any cpu...  Tested thus far using
openssl speed command, and of course, ssh.  778MB/sec AES-128-CBC
performance at 8192 byte block size.
@
text
@d58 2
d73 1
a73 1
static void check_viac3aes(void);
d264 20
a283 1
	check_viac3aes();
d656 1
a656 1
	cw[0] = C3_CRYPT_CWLO_ALG_AES | C3_CRYPT_CWLO_KEYGEN_HW |
d711 4
a714 1
	bcopy(key, ctx->cipher_data, ctx->key_len);
d725 1
a725 1
static void
d733 1
a733 1
		return;
d735 1
a735 1
		return;
d740 1
a740 1
	cryptodev_aes_128_cbc.ctx_size = 128;
d745 1
a745 1
	cryptodev_aes_192_cbc.ctx_size = 128;
d750 2
a751 1
	cryptodev_aes_256_cbc.ctx_size = 128;
@


1.18
log
@support AES with 192 and 256 bit keys, too.
tested with kern.cryptodevallowsoft=1; ok deraadt@@
@
text
@d52 1
a52 1
#else 
d57 1
d67 7
d257 8
d537 1
a537 1
const EVP_CIPHER cryptodev_aes_128_cbc = {
d550 1
a550 1
const EVP_CIPHER cryptodev_aes_192_cbc = {
d563 1
a563 1
const EVP_CIPHER cryptodev_aes_256_cbc = {
d575 154
@


1.17
log
@nuke term 3, since we're all in ~deraadt/terms and I clued in now.
@
text
@d71 7
d83 1
a83 3
static int cryptodev_max_iv(int cipher);
static int cryptodev_key_length_valid(int cipher, int len);
static int cipher_nid_to_cryptodev(int nid);
d130 1
a130 6
static struct {
	int	id;
	int	nid;
	int	ivmax;
	int	keylen;
} ciphers[] = {
d134 2
a204 32
/*
 * XXXX this needs to be set for each alg - and determined from
 * a running card.
 */
static int
cryptodev_max_iv(int cipher)
{
	int i;

	for (i = 0; ciphers[i].id; i++)
		if (ciphers[i].id == cipher)
			return (ciphers[i].ivmax);
	return (0);
}

/*
 * XXXX this needs to be set for each alg - and determined from
 * a running card. For now, fake it out - but most of these
 * for real devices should return 1 for the supported key
 * sizes the device can handle.
 */
static int
cryptodev_key_length_valid(int cipher, int len)
{
	int i;

	for (i = 0; ciphers[i].id; i++)
		if (ciphers[i].id == cipher)
			return (ciphers[i].keylen == len);
	return (0);
}

d206 1
a206 1
static int
d211 4
a214 4
	for (i = 0; ciphers[i].id; i++)
		if (ciphers[i].nid == nid)
			return (ciphers[i].id);
	return (0);
d237 2
a238 2
	for (i = 0; ciphers[i].id && count < CRYPTO_ALGORITHM_MAX; i++) {
		if (ciphers[i].nid == NID_undef)
d240 2
a241 2
		sess.cipher = ciphers[i].id;
		sess.keylen = ciphers[i].keylen;
d245 1
a245 1
			nids[count++] = ciphers[i].nid;
d398 1
a398 1
	int cipher;
d400 1
a400 1
	if ((cipher = cipher_nid_to_cryptodev(ctx->cipher->nid)) == NID_undef)
d403 1
a403 1
	if (ctx->cipher->iv_len > cryptodev_max_iv(cipher))
d406 1
a406 1
	if (!cryptodev_key_length_valid(cipher, ctx->key_len))
d416 1
a416 1
	sess->cipher = cipher;
d521 1
a521 1
const EVP_CIPHER cryptodev_aes_cbc = {
d534 26
d586 7
a592 1
		*cipher = &cryptodev_aes_cbc;
@


1.16
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@a14 3
 * 3. Neither the name of the author nor the names of contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.15
log
@remove printf("bar\n");
@
text
@d32 25
a57 1
#include <sys/param.h>
a65 3
#include <ssl/objects.h>
#include <ssl/engine.h>
#include <ssl/evp.h>
a124 4
	{ENGINE_CMD_BASE,
		"SO_PATH",
		"Specifies the path to the some stupid shared library",
		ENGINE_CMD_FLAG_STRING},
d1031 1
d1033 1
d1037 1
d1040 3
d1069 1
a1069 1
	    !ENGINE_set_name(engine, "OpenBSD cryptodev engine") ||
d1130 2
@


1.14
log
@remove support for RC4 via /dev/crypto, suggested by Niels; ok provos@@
@
text
@a859 1
	printf("bar\n");
@


1.13
log
@do not syslog from libraries!
@
text
@a122 1
	{ CRYPTO_ARC4,			NID_rc4,		8,	16, },
a482 14
/* ARC4 (16 byte key) */
const EVP_CIPHER cryptodev_arc4_cipher = {
	NID_rc4,
	1, 16, 0,
	EVP_CIPH_VARIABLE_LENGTH,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	NULL,
	NULL,
	NULL
};

a562 3
	case NID_rc4:
		*cipher = &cryptodev_arc4_cipher;
		break;
@


1.12
log
@KNF, -Wall, and other cleanups.  still does not failover 100% correctly
for operations when /dev/crypto is missing, for instance in chroot
@
text
@d40 1
a41 1
#include <stdarg.h>
a363 1
	struct syslog_data sd = SYSLOG_DATA_INIT;
a395 1
		syslog_r(LOG_ERR, &sd, "CIOCCRYPT failed (%m)");
a414 1
	struct syslog_data sd = SYSLOG_DATA_INIT;
a435 2
		syslog_r(LOG_ERR, &sd, "CIOCGSESSION failed (%m)");

a452 1
	struct syslog_data sd = SYSLOG_DATA_INIT;
a468 1
		syslog_r(LOG_ERR, &sd, "CIOCFSESSION failed (%m)");
a1047 1
	struct syslog_data sd = SYSLOG_DATA_INIT;
a1058 1
		syslog_r(LOG_ERR, &sd, "CIOCASYMFEAT failed (%m)");
@


1.11
log
@stupid stupid bug ja ja ja ja
@
text
@d55 19
d77 2
a79 1
static int cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa);
d82 3
d87 3
d99 3
d144 1
a144 1
open_dev_crypto()
d162 1
a162 1
get_dev_crypto()
d181 1
a181 1
get_asym_dev_crypto()
d330 1
a330 1
int
d336 1
a336 1
int
d355 1
a355 1
int
d411 1
a411 1
int
d452 1
a452 1
int
d577 1
a577 1
int
d610 1
a610 1
int
a627 1

d702 1
a702 1
cryptodev_sym(struct crypt_kop *kop, int rlen, BIGNUM *r, int slen, BIGNUM *s)
d758 1
a758 1
	if (cryptodev_sym(&kop, BN_num_bytes(m), r, 0, NULL) == -1) {
d807 1
a807 1
	if (cryptodev_sym(&kop, BN_num_bytes(rsa->n), r0, 0, NULL) == -1) {
d902 1
a902 1
	if (cryptodev_sym(&kop, BN_num_bytes(dsa->q), r,
d946 1
a946 1
	if (cryptodev_sym(&kop, 0, NULL, 0, NULL) == 0) {
a958 1

d987 5
a991 2
	if ((fd = get_asym_dev_crypto()) < 0)
		return (-1);
d1109 1
a1109 1
	        if (cryptodev_asymfeat & CRF_MOD_EXP) {
d1113 1
a1113 1
	        if (cryptodev_asymfeat & CRF_DSA_VERIFY)
@


1.10
log
@unbreak sshd with privsep: open /dev/crypto, keep fd, and call
CRIOGET per EVP_Init(); ok niklas@@, miod@@
@
text
@d120 1
a120 1
		if (fd = open("/dev/crypto", O_RDWR, 0) == -1)
@


1.9
log
@per-evp state is now sizeof(struct dev_crypto_state) instead sizeof(struct session_op)
@
text
@d115 18
d137 1
a137 1
	if ((fd = open("/dev/crypto", O_RDWR, 0)) == -1)
d139 1
a139 2
	if (ioctl(fd, CRIOGET, &retfd) == -1) {
		close(fd);
a140 2
	}
	close(fd);
@


1.8
log
@keep a FD per EVP_init, use a global FD for all asym operations;
ok beck@@
@
text
@d455 1
a455 1
	sizeof(struct session_op),
d469 1
a469 1
	sizeof(struct session_op),
d483 1
a483 1
	sizeof(struct session_op),
d496 1
a496 1
	sizeof(struct session_op),
d509 1
a509 1
	sizeof(struct session_op),
d522 1
a522 1
	sizeof(struct session_op),
@


1.7
log
@KNF
@
text
@d48 5
a52 2
static int cryptodev_fd = -1;
static int cryptodev_sessions = 0;
d112 1
a112 3
 * Return 1 if /dev/crypto seems usable, 0 otherwise , also
 * does most of the work of initting the device, if not already
 * done.. This should leave is with global fd initialized with CRIOGET.
d115 1
a115 1
check_dev_crypto()
d117 1
a117 1
	int fd;
d119 3
a121 7
	if (cryptodev_fd == -1) {
		if ((fd = open("/dev/crypto", O_RDWR, 0)) == -1)
			return (0);
		if (ioctl(fd, CRIOGET, &cryptodev_fd) == -1) {
			close(fd);
			return (0);
		}
d123 8
a130 6
		/* close on exec */
		if (fcntl(cryptodev_fd, F_SETFD, 1) == -1) {
			close(cryptodev_fd);
			cryptodev_fd = -1;
			return (0);
		}
d132 12
a143 1
	return (1);
d201 1
a201 1
	int i, count = 0;
d203 4
d216 2
a217 2
		if (ioctl(cryptodev_fd, CIOCGSESSION, &sess) != -1 &&
		    ioctl(cryptodev_fd, CIOCFSESSION, &sess.ses) != -1)
d220 2
d240 1
a240 1
	int i, count = 0;
d242 4
d252 2
a253 2
		if (ioctl(cryptodev_fd, CIOCGSESSION, &sess) != -1 &&
		    ioctl(cryptodev_fd, CIOCFSESSION, &sess.ses) != -1)
d256 2
a288 11
	struct syslog_data sd = SYSLOG_DATA_INIT;

	if (!check_dev_crypto()) {
		*nids = NULL;
		return (0);
	}

	/* find what the device can do. Unfortunately, we don't
	 * necessarily want all of these yet, because we aren't
	 * yet set up to do them
	 */
a289 7

	/*
	 * find out what asymmetric crypto algorithms we support
	 */
	if (ioctl(cryptodev_fd, CIOCASYMFEAT, &cryptodev_asymfeat) == -1) {
		syslog_r(LOG_ERR, &sd, "CIOCASYMFEAT failed (%m)");
	}
a294 1
#if 1
a308 7
#endif

	if (!check_dev_crypto()) {
		*nids = NULL;
		return (0);
	}
	return (get_cryptodev_digests(nids));
a310 1

d316 2
a317 1
	struct session_op *sess = ctx->cipher_data;
d322 1
a322 3
	if (cryptodev_fd == -1)
		return (0);
	if (sess == NULL)
d349 1
a349 1
	if (ioctl(cryptodev_fd, CIOCCRYPT, &cryp) == -1) {
d371 2
a372 1
	struct session_op *sess = ctx->cipher_data;
a378 3
	if (!check_dev_crypto())
		return (0);

d387 3
d394 1
a394 1
	if (ioctl(cryptodev_fd, CIOCGSESSION, sess) == -1) {
d396 3
a400 1
	cryptodev_sessions++;
d412 2
a413 1
	struct session_op *sess = ctx->cipher_data;
d416 1
a416 1
	if (sess == NULL)
d430 1
a430 1
	if (ioctl(cryptodev_fd, CIOCFSESSION, &sess->ses) == -1) {
a433 1
		cryptodev_sessions--;
d436 3
a438 4
	if (cryptodev_sessions == 0 && cryptodev_fd != -1 ) {
		close(cryptodev_fd); /* XXX should this be closed? */
		cryptodev_fd = -1;
	}
d661 4
a664 1
	int ret = -1;
d677 1
a677 1
	if (ioctl(cryptodev_fd, CIOCKEY, kop) == 0) {
d684 1
d943 4
a946 1
	int keylen;
d966 1
a966 1
	if (ioctl(cryptodev_fd, CIOCKEY, &kop) == -1) {
d1011 1
d1015 1
a1015 3


	if (!check_dev_crypto()) {
a1016 1
	}
d1021 1
a1021 1
	if (ioctl(cryptodev_fd, CIOCASYMFEAT, &cryptodev_asymfeat) == -1) {
d1023 1
d1026 1
a1089 1

@


1.6
log
@add "dsa_dsa_mod_exp" - This mimics the software dsa_mod_exp funtion
using two mod_exp operations - otherwise we use BN_mod_exp2 entirely
in software, which makes dsa verifications glacially slow while
signatures, (which use mod_exp) are fast. This lets cards that can
only do bn_mod_exp decently offload most of dsa.
@
text
@d89 1
a89 1
	{ CRYPTO_CAST_CBC, 		NID_cast5_cbc,		8, 	16, },
d268 1
a268 1
	
a285 1
	
d684 1
a684 1
	} 
a702 1
	
d803 1
a803 1
	
d805 1
a805 1
 
d808 1
a808 1
	ret = 0; 
d1016 1
a1016 1
	
d1047 1
a1047 1
				cryptodev_rsa.rsa_mod_exp = 
d1057 5
a1061 5
		
		memcpy(&cryptodev_dsa, meth, sizeof(DSA_METHOD)); 
		if (cryptodev_asymfeat & CRF_DSA_SIGN) 
			cryptodev_dsa.dsa_do_sign = cryptodev_dsa_do_sign;   
  	        if (cryptodev_asymfeat & CRF_MOD_EXP) {
d1065 2
a1066 2
  	        if (cryptodev_asymfeat & CRF_DSA_VERIFY)
			cryptodev_dsa.dsa_do_verify = cryptodev_dsa_verify;   
a1067 1
		
d1082 1
a1082 1
	
@


1.5
log
@Make DSA work now... at least for things that can do bn_mod_exp.
@
text
@d798 32
a884 1
	printf("foo\n");
d1063 4
a1068 2
  	        if (cryptodev_asymfeat & CRF_MOD_EXP)
			cryptodev_dsa.bn_mod_exp = cryptodev_dsa_bn_mod_exp;
d1090 1
@


1.4
log
@Make asymmetric crypto work in userland

this will only be used if you both have a card that supports it
with a working driver and you set sysctl kern.userasymcrypto=1
@
text
@d812 1
d853 1
a1025 2
#if 0 
	/* dsa is currently busted. */
d1028 2
a1029 4

		cryptodev_dsa.dsa_do_sign = meth->dsa_do_sign;
		cryptodev_dsa.dsa_do_verify = meth->dsa_do_verify;   
		cryptodev_dsa.bn_mod_exp = meth->bn_mod_exp;
a1036 1
#endif
@


1.3
log
@Pass the right arguments for RSA, DSA, and modexp operations. Fix the
translation between the crypto framework's format and the BN structure.
@
text
@d45 2
d50 1
a50 1
static u_int32_t cryptodev_symfeat = 0;
d72 4
a132 2
	ioctl(cryptodev_fd, CIOCSYMFEAT, &cryptodev_symfeat);

d267 2
d279 8
d669 1
a669 1
		kop->crk_param[kop->crk_iparams].crp_p = malloc(rlen);
d674 1
a674 1
		kop->crk_param[kop->crk_iparams+1].crp_p = malloc(slen);
d679 1
a679 1
	if (ioctl(cryptodev_fd, CIOCKEY, &kop) == 0) {
d681 1
a681 1
			crparam2bn(&kop->crk_param[3], r);
d683 1
a683 1
			crparam2bn(&kop->crk_param[4], s);
d685 1
a685 1
	}
d694 9
a702 1
	int ret = 0;
d704 1
d718 2
a719 1
		ret = BN_mod_exp(r, a, p, m, ctx);
d726 11
d742 1
a742 1
	int ret = 0;
d746 1
a746 1
		goto err;
a767 1

d781 2
a782 2
	cryptodev_rsa_mod_exp,		/* rsa_mod_exp */
	cryptodev_bn_mod_exp,		/* bn_mod_exp */
a834 1

d850 1
a850 1
	int dsaret = 0;
d885 1
d888 1
a888 1
	cryptodev_dsa_do_sign,
d890 1
a890 1
	cryptodev_dsa_verify,
d892 1
a892 1
	cryptodev_dsa_bn_mod_exp,	/* bn_mod_exp */
d911 1
a911 1
	int dhret = 0;
d946 2
a947 2
	cryptodev_dh_compute_key,
	cryptodev_mod_exp_dh,
d976 1
a976 2
	const RSA_METHOD *rsa_meth;
	const DH_METHOD *dh_meth;
d981 13
d1004 5
a1008 3
	if ((cryptodev_symfeat & CRSFEAT_RSA) &&
	    ENGINE_set_RSA(engine, &cryptodev_rsa)) {
		rsa_meth = RSA_PKCS1_SSLeay();
d1011 1
a1011 1
		cryptodev_rsa.rsa_priv_enc = rsa_meth->rsa_priv_dec;
d1013 9
d1024 14
a1037 2
	if ((cryptodev_symfeat & CRSFEAT_DSA) &&
	    ENGINE_set_DSA(engine, &cryptodev_dsa)) {
d1039 5
a1044 3
	if ((cryptodev_symfeat & CRSFEAT_DH) &&
	    ENGINE_set_DH(engine, &cryptodev_dh)) {
		dh_meth = DH_OpenSSL();
d1047 7
d1055 1
a1055 1

@


1.2
log
@add aes/bf/cast; ok deraadt@@
@
text
@d584 1
a584 1
	int i, j, n;
d601 5
a605 10
	words = (bits + BN_BITS2 - 1) / BN_BITS2;

	n = 0;
	for (i = 0; i < words && n < bytes; i++) {
		BN_ULONG word;

		word = a->d[i];
		for (j = 0 ; j < BN_BYTES && n < bytes; j++, n++) {
			*b++ = (word & 0xff);
			word >>= 8;
d607 1
d616 1
d619 7
a625 1
	bytes = (crp->crp_nbits + 7)/8;
d627 5
a631 5
	BN_zero(a);
	for (i = bytes - 1; i >= 0; i--) {
		BN_lshift(a, a, 8);
		BN_add_word(a, (u_char)crp->crp_p[i]);
	}
d650 1
a650 1
cryptodev_sym(struct crypt_kop *kop, BIGNUM *r, BIGNUM *s)
d655 2
a656 2
		kop->crk_param[kop->crk_iparams].crp_p = malloc(256);
		kop->crk_param[kop->crk_iparams].crp_nbits = 256 * 8;
d660 2
a661 2
		kop->crk_param[kop->crk_iparams+1].crp_p = malloc(256);
		kop->crk_param[kop->crk_iparams+1].crp_nbits = 256 * 8;
d666 4
a669 1
		crparam2bn(&kop->crk_param[3], r);
d685 1
a685 1
	/* inputs: a m p */
d688 1
a688 1
	if (bn2crparam(m, &kop.crk_param[1]))
d690 1
a690 1
	if (bn2crparam(p, &kop.crk_param[2]))
d694 1
a694 1
	if (cryptodev_sym(&kop, r, NULL) == -1) {
d731 1
a731 1
	if (cryptodev_sym(&kop, r0, NULL) == -1) {
d794 2
a795 1
	if (cryptodev_sym(&kop, r, s) == 0) {
d839 1
a839 1
	if (cryptodev_sym(&kop, NULL, NULL) == 0) {
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d4 1
d81 1
a81 1
	{ CRYPTO_AES_CBC,		NID_undef,		8,	24, },
d83 1
a83 1
	{ CRYPTO_CAST_CBC,		NID_cast5_cbc,		8,	 8, },
d480 38
d540 9
@


1.1.1.1
log
@import 0.9.7b (without idea and rc5)
@
text
@a3 1
 * Copyright (c) 2002 Markus Friedl
d31 1
a31 5
#include <openssl/objects.h>
#include <openssl/engine.h>
#include <openssl/evp.h>

#if (defined(__unix__) || defined(unix)) && !defined(USG)
a32 20
# if (OpenBSD >= 200112) || ((__FreeBSD_version >= 470101 && __FreeBSD_version < 500000) || __FreeBSD_version >= 500041)
# define HAVE_CRYPTODEV
# endif
# if (OpenBSD >= 200110)
# define HAVE_SYSLOG_R
# endif
#endif

#ifndef HAVE_CRYPTODEV

void
ENGINE_load_cryptodev(void)
{
	/* This is a NOP on platforms without /dev/crypto */
	return;
}

#else 

#include <sys/types.h>
d39 1
d41 7
a47 10
#include <syslog.h>
#include <errno.h>
#include <string.h>

struct dev_crypto_state {
	struct session_op d_sess;
	int d_fd;
};

static u_int32_t cryptodev_asymfeat = 0;
a48 19
static int get_asym_dev_crypto(void);
static int open_dev_crypto(void);
static int get_dev_crypto(void);
static int cryptodev_max_iv(int cipher);
static int cryptodev_key_length_valid(int cipher, int len);
static int cipher_nid_to_cryptodev(int nid);
static int get_cryptodev_ciphers(const int **cnids);
static int get_cryptodev_digests(const int **cnids);
static int cryptodev_usable_ciphers(const int **nids);
static int cryptodev_usable_digests(const int **nids);
static int cryptodev_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, unsigned int inl);
static int cryptodev_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc);
static int cryptodev_cleanup(EVP_CIPHER_CTX *ctx);
static int cryptodev_engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
    const int **nids, int nid);
static int cryptodev_engine_digests(ENGINE *e, const EVP_MD **digest,
    const int **nids, int nid);
a51 2
static int cryptodev_asym(struct crypt_kop *kop, int rlen, BIGNUM *r,
    int slen, BIGNUM *s);
d53 1
a55 3
static int cryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I,
    RSA *rsa);
static int cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa);
a57 3
static int cryptodev_dsa_dsa_mod_exp(DSA *dsa, BIGNUM *t1, BIGNUM *g,
    BIGNUM *u1, BIGNUM *pub_key, BIGNUM *u2, BIGNUM *p,
    BN_CTX *ctx, BN_MONT_CTX *mont);
a66 3
static int cryptodev_ctrl(ENGINE *e, int cmd, long i, void *p,
    void (*f)());
void ENGINE_load_cryptodev(void);
d80 1
a80 1
	{ CRYPTO_AES_CBC,		NID_aes_128_cbc,	16,	16, },
d82 1
a82 1
	{ CRYPTO_CAST_CBC,		NID_cast5_cbc,		8,	16, },
d84 1
d102 3
a104 1
 * Return a fd if /dev/crypto seems usable, 0 otherwise.
d107 1
a107 1
open_dev_crypto(void)
d109 1
a109 1
	static int fd = -1;
d111 1
a111 1
	if (fd == -1) {
d113 6
a118 1
			return (-1);
d120 4
a123 4
		if (fcntl(fd, F_SETFD, 1) == -1) {
			close(fd);
			fd = -1;
			return (-1);
d126 1
a126 2
	return (fd);
}
d128 1
a128 27
static int
get_dev_crypto(void)
{
	int fd, retfd;

	if ((fd = open_dev_crypto()) == -1)
		return (-1);
	if (ioctl(fd, CRIOGET, &retfd) == -1)
		return (-1);

	/* close on exec */
	if (fcntl(retfd, F_SETFD, 1) == -1) {
		close(retfd);
		return (-1);
	}
	return (retfd);
}

/* Caching version for asym operations */
static int
get_asym_dev_crypto(void)
{
	static int fd = -1;

	if (fd == -1)
		fd = get_dev_crypto();
	return fd;
d186 1
a186 1
	int fd, i, count = 0;
a187 4
	if ((fd = get_dev_crypto()) < 0) {
		*nids = NULL;
		return (0);
	}
d197 2
a198 2
		if (ioctl(fd, CIOCGSESSION, &sess) != -1 &&
		    ioctl(fd, CIOCFSESSION, &sess.ses) != -1)
a200 2
	close(fd);

d219 1
a219 1
	int fd, i, count = 0;
a220 4
	if ((fd = get_dev_crypto()) < 0) {
		*nids = NULL;
		return (0);
	}
d227 2
a228 2
		if (ioctl(fd, CIOCGSESSION, &sess) != -1 &&
		    ioctl(fd, CIOCFSESSION, &sess.ses) != -1)
a230 2
	close(fd);

d259 1
a259 1
static int
d262 9
d274 1
a274 1
static int
d277 1
d292 7
d301 2
a302 1
static int
d307 1
a307 2
	struct dev_crypto_state *state = ctx->cipher_data;
	struct session_op *sess = &state->d_sess;
d310 1
d312 3
a314 1
	if (state->d_fd < 0)
d341 1
a341 1
	if (ioctl(state->d_fd, CIOCCRYPT, &cryp) == -1) {
d345 1
d359 1
a359 1
static int
d363 2
a364 2
	struct dev_crypto_state *state = ctx->cipher_data;
	struct session_op *sess = &state->d_sess;
d370 3
a380 3
	if ((state->d_fd = get_dev_crypto()) < 0)
		return (0);

d385 2
a386 3
	if (ioctl(state->d_fd, CIOCGSESSION, sess) == -1) {
		close(state->d_fd);
		state->d_fd = -1;
d389 1
d397 1
a397 1
static int
d401 2
a402 2
	struct dev_crypto_state *state = ctx->cipher_data;
	struct session_op *sess = &state->d_sess;
d404 1
a404 1
	if (state->d_fd < 0)
d418 2
a419 1
	if (ioctl(state->d_fd, CIOCFSESSION, &sess->ses) == -1) {
d422 1
d425 4
a428 3
	close(state->d_fd);
	state->d_fd = -1;

d437 14
d459 1
a459 1
	sizeof(struct dev_crypto_state),
d473 1
a473 1
	sizeof(struct dev_crypto_state),
a478 38
const EVP_CIPHER cryptodev_bf_cbc = {
	NID_bf_cbc,
	8, 16, 8,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

const EVP_CIPHER cryptodev_cast_cbc = {
	NID_cast5_cbc,
	8, 16, 8,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

const EVP_CIPHER cryptodev_aes_cbc = {
	NID_aes_128_cbc,
	16, 16, 16,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};
d485 1
a485 1
static int
d493 3
a501 9
	case NID_bf_cbc:
		*cipher = &cryptodev_bf_cbc;
		break;
	case NID_cast5_cbc:
		*cipher = &cryptodev_cast_cbc;
		break;
	case NID_aes_128_cbc:
		*cipher = &cryptodev_aes_cbc;
		break;
d509 1
a509 1
static int
d527 1
d536 1
a536 1
	int i, j, k;
d553 10
a562 5
	for (i = 0, j = 0; i < a->top; i++) {
		for (k = 0; k < BN_BITS2 / 8; k++) {
			if ((j + k) >= bytes)
				return (0);
			b[j + k] = a->d[i] >> (k * 8);
a563 1
		j += BN_BITS2 / 8;
a571 1
	u_int8_t *pd;
d574 1
a574 1
	bytes = (crp->crp_nbits + 7) / 8;
d576 5
a580 11
	if (bytes == 0)
		return (-1);

	if ((pd = (u_int8_t *) malloc(bytes)) == NULL)
		return (-1);

	for (i = 0; i < bytes; i++)
		pd[i] = crp->crp_p[bytes - i - 1];

	BN_bin2bn(pd, bytes, a);
	free(pd);
d599 1
a599 1
cryptodev_asym(struct crypt_kop *kop, int rlen, BIGNUM *r, int slen, BIGNUM *s)
d601 1
a601 4
	int fd, ret = -1;

	if ((fd = get_asym_dev_crypto()) < 0)
		return (ret);
d604 2
a605 2
		kop->crk_param[kop->crk_iparams].crp_p = calloc(rlen, sizeof(char));
		kop->crk_param[kop->crk_iparams].crp_nbits = rlen * 8;
d609 2
a610 2
		kop->crk_param[kop->crk_iparams+1].crp_p = calloc(slen, sizeof(char));
		kop->crk_param[kop->crk_iparams+1].crp_nbits = slen * 8;
d614 2
a615 5
	if (ioctl(fd, CIOCKEY, kop) == 0) {
		if (r)
			crparam2bn(&kop->crk_param[kop->crk_iparams], r);
		if (s)
			crparam2bn(&kop->crk_param[kop->crk_iparams+1], s);
a617 1

d626 1
a626 9
	int ret = 1;

	/* Currently, we know we can do mod exp iff we can do any
	 * asymmetric operations at all.
	 */
	if (cryptodev_asymfeat == 0) {
		ret = BN_mod_exp(r, a, p, m, ctx);
		return (ret);
	}
d631 1
a631 1
	/* inputs: a^p % m */
d634 1
a634 1
	if (bn2crparam(p, &kop.crk_param[1]))
d636 1
a636 1
	if (bn2crparam(m, &kop.crk_param[2]))
d640 2
a641 3
	if (cryptodev_asym(&kop, BN_num_bytes(m), r, 0, NULL) == -1) {
		const RSA_METHOD *meth = RSA_PKCS1_SSLeay();
		ret = meth->bn_mod_exp(r, a, p, m, ctx, in_mont);
a647 11
static int
cryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)
{
	int r;
	BN_CTX *ctx;

	ctx = BN_CTX_new();
	r = cryptodev_bn_mod_exp(r0, I, rsa->d, rsa->n, ctx, NULL);
	BN_CTX_free(ctx);
	return (r);
}
d653 1
a653 1
	int ret = 1;
d657 1
a657 1
		return (0);
d677 1
a677 1
	if (cryptodev_asym(&kop, BN_num_bytes(rsa->n), r0, 0, NULL) == -1) {
d679 1
d693 2
a694 2
	NULL,
	NULL,
a709 32
static int
cryptodev_dsa_dsa_mod_exp(DSA *dsa, BIGNUM *t1, BIGNUM *g,
    BIGNUM *u1, BIGNUM *pub_key, BIGNUM *u2, BIGNUM *p,
    BN_CTX *ctx, BN_MONT_CTX *mont)
{
	BIGNUM t2;
	int ret = 0;

	BN_init(&t2);

	/* v = ( g^u1 * y^u2 mod p ) mod q */
	/* let t1 = g ^ u1 mod p */
	ret = 0;

	if (!dsa->meth->bn_mod_exp(dsa,t1,dsa->g,u1,dsa->p,ctx,mont))
		goto err;

	/* let t2 = y ^ u2 mod p */
	if (!dsa->meth->bn_mod_exp(dsa,&t2,dsa->pub_key,u2,dsa->p,ctx,mont))
		goto err;
	/* let u1 = t1 * t2 mod p */
	if (!BN_mod_mul(u1,t1,&t2,dsa->p,ctx))
		goto err;

	BN_copy(t1,u1);

	ret = 1;
err:
	BN_free(&t2);
	return(ret);
}

a723 1
	printf("bar\n");
d740 1
a740 2
	if (cryptodev_asym(&kop, BN_num_bytes(dsa->q), r,
	    BN_num_bytes(dsa->q), s) == 0) {
d746 1
d762 1
a762 1
	int dsaret = 1;
d784 1
a784 1
	if (cryptodev_asym(&kop, 0, NULL, 0, NULL) == 0) {
d799 1
a799 1
	NULL,
d801 1
a801 1
	NULL,
d803 1
a803 1
	NULL,
d822 2
a823 8
	int dhret = 1;
	int fd, keylen;

	if ((fd = get_asym_dev_crypto()) < 0) {
		const DH_METHOD *meth = DH_OpenSSL();

		return ((meth->compute_key)(key, pub_key, dh));
	}
d843 1
a843 1
	if (ioctl(fd, CIOCKEY, &kop) == -1) {
d857 2
a858 2
	NULL,
	NULL,
a871 1
#ifdef HAVE_SYSLOG_R
a872 1
#endif
a875 1
#ifdef HAVE_SYSLOG_R
a877 3
#else
		syslog(LOG_ERR, "cryptodev_ctrl: unknown command %d", cmd);
#endif
d887 2
a888 1
	int fd;
a891 11
	if ((fd = get_dev_crypto()) < 0)
		return;

	/*
	 * find out what asymmetric crypto algorithms we support
	 */
	if (ioctl(fd, CIOCASYMFEAT, &cryptodev_asymfeat) == -1) {
		close(fd);
		return;
	}
	close(fd);
d894 1
a894 1
	    !ENGINE_set_name(engine, "BSD cryptodev engine") ||
d903 3
a905 5
	if (ENGINE_set_RSA(engine, &cryptodev_rsa)) {
		const RSA_METHOD *rsa_meth = RSA_PKCS1_SSLeay();

		cryptodev_rsa.bn_mod_exp = rsa_meth->bn_mod_exp;
		cryptodev_rsa.rsa_mod_exp = rsa_meth->rsa_mod_exp;
d908 1
a908 1
		cryptodev_rsa.rsa_priv_enc = rsa_meth->rsa_priv_enc;
a909 9
		if (cryptodev_asymfeat & CRF_MOD_EXP) {
			cryptodev_rsa.bn_mod_exp = cryptodev_bn_mod_exp;
			if (cryptodev_asymfeat & CRF_MOD_EXP_CRT)
				cryptodev_rsa.rsa_mod_exp =
				    cryptodev_rsa_mod_exp;
			else
				cryptodev_rsa.rsa_mod_exp =
				    cryptodev_rsa_nocrt_mod_exp;
		}
d912 2
a913 12
	if (ENGINE_set_DSA(engine, &cryptodev_dsa)) {
		const DSA_METHOD *meth = DSA_OpenSSL();

		memcpy(&cryptodev_dsa, meth, sizeof(DSA_METHOD));
		if (cryptodev_asymfeat & CRF_DSA_SIGN)
			cryptodev_dsa.dsa_do_sign = cryptodev_dsa_do_sign;
		if (cryptodev_asymfeat & CRF_MOD_EXP) {
			cryptodev_dsa.bn_mod_exp = cryptodev_dsa_bn_mod_exp;
			cryptodev_dsa.dsa_mod_exp = cryptodev_dsa_dsa_mod_exp;
		}
		if (cryptodev_asymfeat & CRF_DSA_VERIFY)
			cryptodev_dsa.dsa_do_verify = cryptodev_dsa_verify;
d916 3
a918 3
	if (ENGINE_set_DH(engine, &cryptodev_dh)){
		const DH_METHOD *dh_meth = DH_OpenSSL();

a920 7
		cryptodev_dh.bn_mod_exp = dh_meth->bn_mod_exp;
		if (cryptodev_asymfeat & CRF_MOD_EXP) {
			cryptodev_dh.bn_mod_exp = cryptodev_mod_exp_dh;
			if (cryptodev_asymfeat & CRF_DH_COMPUTE_KEY)
				cryptodev_dh.compute_key =
				    cryptodev_dh_compute_key;
		}
a926 2

#endif /* HAVE_CRYPTODEV */
@


1.1.1.2
log
@import openssl-0.9.7d
@
text
@d15 3
d877 1
d1057 1
a1057 2
	if ((fd = get_dev_crypto()) < 0) {
		ENGINE_free(engine);
a1058 1
	}
a1064 1
		ENGINE_free(engine);
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d80 1
a80 1
/*static int get_cryptodev_digests(const int **cnids);*/
a139 1
#if 0 /* UNUSED */
a151 1
#endif
d261 1
a261 1
		*cnids = NULL;
a291 1
#if 0 /* UNUSED */
d300 1
a300 1
		*cnids = NULL;
a320 1
#endif
d626 1
a626 1
	ssize_t bytes, bits;
@


1.1.1.4
log
@Import OpenSSL 1.0.1g
@
text
@a31 1
#include <openssl/bn.h>
d33 1
a33 2
#if (defined(__unix__) || defined(unix)) && !defined(USG) && \
	(defined(OpenBSD) || defined(__FreeBSD__))
d36 1
a36 1
#  define HAVE_CRYPTODEV
d39 1
a39 1
#  define HAVE_SYSLOG_R
d53 1
a53 1
 
a55 4
#include <crypto/dh/dh.h>
#include <crypto/dsa/dsa.h>
#include <crypto/err/err.h>
#include <crypto/rsa/rsa.h>
a68 8

#ifdef USE_CRYPTODEV_DIGESTS
	char dummy_mac_key[HASH_MAX_LEN];

	unsigned char digest_res[HASH_MAX_LEN];
	char *mac_data;
	int mac_len;
#endif
d76 3
d80 1
a80 3
#ifdef USE_CRYPTODEV_DIGESTS
static int get_cryptodev_digests(const int **cnids);
#endif
d84 1
a84 1
    const unsigned char *in, size_t inl);
d101 2
a102 2
    RSA *rsa, BN_CTX *ctx);
static int cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx);
d118 1
a118 1
    void (*f)(void));
a130 1
	{ CRYPTO_ARC4,			NID_rc4,		0,	16, },
a133 2
	{ CRYPTO_AES_CBC,		NID_aes_192_cbc,	16,	24, },
	{ CRYPTO_AES_CBC,		NID_aes_256_cbc,	16,	32, },
d140 1
a140 1
#ifdef USE_CRYPTODEV_DIGESTS
a143 1
	int 	keylen;
d145 7
a151 8
	{ CRYPTO_MD5_HMAC,		NID_hmacWithMD5,	16},
	{ CRYPTO_SHA1_HMAC,		NID_hmacWithSHA1,	20},
	{ CRYPTO_RIPEMD160_HMAC,	NID_ripemd160,		16/*?*/},
	{ CRYPTO_MD5_KPDK,		NID_undef,		0},
	{ CRYPTO_SHA1_KPDK,		NID_undef,		0},
	{ CRYPTO_MD5,			NID_md5,		16},
	{ CRYPTO_SHA1,			NID_sha1,		20},
	{ 0,				NID_undef,		0},
a182 1
#ifndef CRIOGET_NOT_NEEDED
a190 3
#else
        retfd = fd;
#endif
a193 7
static void put_dev_crypto(int fd)
{
#ifndef CRIOGET_NOT_NEEDED
	close(fd);
#endif
}

d206 44
d267 1
a267 1
	sess.key = (caddr_t)"123456789abcdefghijklmno";
d279 1
a279 1
	put_dev_crypto(fd);
a287 1
#ifdef USE_CRYPTODEV_DIGESTS
d294 1
a306 1
	sess.mackey = (caddr_t)"123456789abcdefghijklmno";
a310 1
		sess.mackeylen = digests[i].keylen;
d316 1
a316 1
	put_dev_crypto(fd);
d324 1
a324 1
#endif  /* 0 */
a355 3
#ifdef USE_CRYPTODEV_DIGESTS
	return (get_cryptodev_digests(nids));
#else
a369 1
#endif
d374 1
a374 1
    const unsigned char *in, size_t inl)
d379 1
a379 1
	const void *iiv;
d403 1
a403 1
			iiv = in + inl - ctx->cipher->iv_len;
d418 1
a418 1
			iiv = out + inl - ctx->cipher->iv_len;
d432 4
a435 1
	int cipher = -1, i;
d437 2
a438 7
	for (i = 0; ciphers[i].id; i++)
		if (ctx->cipher->nid == ciphers[i].nid &&
		    ctx->cipher->iv_len <= ciphers[i].ivmax &&
		    ctx->key_len == ciphers[i].keylen) {
			cipher = ciphers[i].id;
			break;
		}
d440 1
a440 2
	if (!ciphers[i].id) {
		state->d_fd = -1;
a441 1
	}
d448 1
a448 1
	sess->key = (caddr_t)key;
d453 1
a453 1
		put_dev_crypto(state->d_fd);
d490 1
a490 1
	put_dev_crypto(state->d_fd);
a500 14
/* RC4 */
const EVP_CIPHER cryptodev_rc4 = {
	NID_rc4,
	1, 16, 0,
	EVP_CIPH_VARIABLE_LENGTH,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	NULL,
	NULL,
	NULL
};

a567 26
const EVP_CIPHER cryptodev_aes_192_cbc = {
	NID_aes_192_cbc,
	16, 24, 16,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

const EVP_CIPHER cryptodev_aes_256_cbc = {
	NID_aes_256_cbc,
	16, 32, 16,
	EVP_CIPH_CBC_MODE,
	cryptodev_init_key,
	cryptodev_cipher,
	cryptodev_cleanup,
	sizeof(struct dev_crypto_state),
	EVP_CIPHER_set_asn1_iv,
	EVP_CIPHER_get_asn1_iv,
	NULL
};

a580 3
	case NID_rc4:
		*cipher = &cryptodev_rc4;
		break;
a595 6
	case NID_aes_192_cbc:
		*cipher = &cryptodev_aes_192_cbc;
		break;
	case NID_aes_256_cbc:
		*cipher = &cryptodev_aes_256_cbc;
		break;
a602 250

#ifdef USE_CRYPTODEV_DIGESTS

/* convert digest type to cryptodev */
static int
digest_nid_to_cryptodev(int nid)
{
	int i;

	for (i = 0; digests[i].id; i++)
		if (digests[i].nid == nid)
			return (digests[i].id);
	return (0);
}


static int
digest_key_length(int nid)
{
	int i;

	for (i = 0; digests[i].id; i++)
		if (digests[i].nid == nid)
			return digests[i].keylen;
	return (0);
}


static int cryptodev_digest_init(EVP_MD_CTX *ctx)
{
	struct dev_crypto_state *state = ctx->md_data;
	struct session_op *sess = &state->d_sess;
	int digest;

	if ((digest = digest_nid_to_cryptodev(ctx->digest->type)) == NID_undef){
		printf("cryptodev_digest_init: Can't get digest \n");
		return (0);
	}

	memset(state, 0, sizeof(struct dev_crypto_state));

	if ((state->d_fd = get_dev_crypto()) < 0) {
		printf("cryptodev_digest_init: Can't get Dev \n");
		return (0);
	}

	sess->mackey = state->dummy_mac_key;
	sess->mackeylen = digest_key_length(ctx->digest->type);
	sess->mac = digest;

	if (ioctl(state->d_fd, CIOCGSESSION, sess) < 0) {
		put_dev_crypto(state->d_fd);
		state->d_fd = -1;
		printf("cryptodev_digest_init: Open session failed\n");
		return (0);
	}

	return (1);
}

static int cryptodev_digest_update(EVP_MD_CTX *ctx, const void *data,
		size_t count)
{
	struct crypt_op cryp;
	struct dev_crypto_state *state = ctx->md_data;
	struct session_op *sess = &state->d_sess;

	if (!data || state->d_fd < 0) {
		printf("cryptodev_digest_update: illegal inputs \n");
		return (0);
	}

	if (!count) {
		return (0);
	}

	if (!(ctx->flags & EVP_MD_CTX_FLAG_ONESHOT)) {
		/* if application doesn't support one buffer */
		state->mac_data = OPENSSL_realloc(state->mac_data, state->mac_len + count);

		if (!state->mac_data) {
			printf("cryptodev_digest_update: realloc failed\n");
			return (0);
		}

		memcpy(state->mac_data + state->mac_len, data, count);
   		state->mac_len += count;
	
		return (1);
	}

	memset(&cryp, 0, sizeof(cryp));

	cryp.ses = sess->ses;
	cryp.flags = 0;
	cryp.len = count;
	cryp.src = (caddr_t) data;
	cryp.dst = NULL;
	cryp.mac = (caddr_t) state->digest_res;
	if (ioctl(state->d_fd, CIOCCRYPT, &cryp) < 0) {
		printf("cryptodev_digest_update: digest failed\n");
		return (0);
	}
	return (1);
}


static int cryptodev_digest_final(EVP_MD_CTX *ctx, unsigned char *md)
{
	struct crypt_op cryp;
	struct dev_crypto_state *state = ctx->md_data;
	struct session_op *sess = &state->d_sess;

	int ret = 1;

	if (!md || state->d_fd < 0) {
		printf("cryptodev_digest_final: illegal input\n");
		return(0);
	}

	if (! (ctx->flags & EVP_MD_CTX_FLAG_ONESHOT) ) {
		/* if application doesn't support one buffer */
		memset(&cryp, 0, sizeof(cryp));
		cryp.ses = sess->ses;
		cryp.flags = 0;
		cryp.len = state->mac_len;
		cryp.src = state->mac_data;
		cryp.dst = NULL;
		cryp.mac = (caddr_t)md;
		if (ioctl(state->d_fd, CIOCCRYPT, &cryp) < 0) {
			printf("cryptodev_digest_final: digest failed\n");
			return (0);
		}

		return 1;
	}

	memcpy(md, state->digest_res, ctx->digest->md_size);

	return (ret);
}


static int cryptodev_digest_cleanup(EVP_MD_CTX *ctx)
{
	int ret = 1;
	struct dev_crypto_state *state = ctx->md_data;
	struct session_op *sess = &state->d_sess;

	if (state == NULL)
	  return 0;

	if (state->d_fd < 0) {
		printf("cryptodev_digest_cleanup: illegal input\n");
		return (0);
	}

	if (state->mac_data) {
		OPENSSL_free(state->mac_data);
		state->mac_data = NULL;
		state->mac_len = 0;
	}

	if (ioctl(state->d_fd, CIOCFSESSION, &sess->ses) < 0) {
		printf("cryptodev_digest_cleanup: failed to close session\n");
		ret = 0;
	} else {
		ret = 1;
	}
	put_dev_crypto(state->d_fd);	
	state->d_fd = -1;

	return (ret);
}

static int cryptodev_digest_copy(EVP_MD_CTX *to,const EVP_MD_CTX *from)
{
	struct dev_crypto_state *fstate = from->md_data;
	struct dev_crypto_state *dstate = to->md_data;
	struct session_op *sess;
	int digest;

	if (dstate == NULL || fstate == NULL)
	  return 1;

       	memcpy(dstate, fstate, sizeof(struct dev_crypto_state));

	sess = &dstate->d_sess;

	digest = digest_nid_to_cryptodev(to->digest->type);

	sess->mackey = dstate->dummy_mac_key;
	sess->mackeylen = digest_key_length(to->digest->type);
	sess->mac = digest;

	dstate->d_fd = get_dev_crypto();

	if (ioctl(dstate->d_fd, CIOCGSESSION, sess) < 0) {
		put_dev_crypto(dstate->d_fd);
		dstate->d_fd = -1;
		printf("cryptodev_digest_init: Open session failed\n");
		return (0);
	}

	if (fstate->mac_len != 0) {
	        if (fstate->mac_data != NULL)
	                {
        		dstate->mac_data = OPENSSL_malloc(fstate->mac_len);
	        	memcpy(dstate->mac_data, fstate->mac_data, fstate->mac_len);
           		dstate->mac_len = fstate->mac_len;
	        	}
	}

	return 1;
}


const EVP_MD cryptodev_sha1 = {
	NID_sha1,
	NID_undef, 
	SHA_DIGEST_LENGTH, 
	EVP_MD_FLAG_ONESHOT,
	cryptodev_digest_init,
	cryptodev_digest_update,
	cryptodev_digest_final,
	cryptodev_digest_copy,
	cryptodev_digest_cleanup,
	EVP_PKEY_NULL_method,
	SHA_CBLOCK,
	sizeof(struct dev_crypto_state),
};

const EVP_MD cryptodev_md5 = {
	NID_md5,
	NID_undef, 
	16 /* MD5_DIGEST_LENGTH */, 
	EVP_MD_FLAG_ONESHOT,
	cryptodev_digest_init,
	cryptodev_digest_update,
	cryptodev_digest_final,
	cryptodev_digest_copy,
	cryptodev_digest_cleanup,
	EVP_PKEY_NULL_method,
	64 /* MD5_CBLOCK */,
	sizeof(struct dev_crypto_state),
};

#endif /* USE_CRYPTODEV_DIGESTS */


a610 1
#ifdef USE_CRYPTODEV_DIGESTS
d612 1
a612 1
		*digest = &cryptodev_md5; 
a613 3
	case NID_sha1:
		*digest = &cryptodev_sha1;
 		break;
a614 1
#endif /* USE_CRYPTODEV_DIGESTS */
a641 1
	memset(b, 0, bytes);
d643 1
a643 1
	crp->crp_p = (caddr_t) b;
d686 1
a686 1
	for (i = 0; i < kop->crk_iparams + kop->crk_oparams; i++) {
d751 1
a751 6
	if (cryptodev_asym(&kop, BN_num_bytes(m), r, 0, NULL)) {
		const RSA_METHOD *meth = RSA_PKCS1_SSLeay();
		printf("OCF asym process failed, Running in software\n");
		ret = meth->bn_mod_exp(r, a, p, m, ctx, in_mont);

	} else if (ECANCELED == kop.crk_status) {
a752 1
		printf("OCF hardware operation cancelled. Running in Software\n");
a754 2
	/* else cryptodev operation worked ok ==> ret = 1*/

d761 1
a761 1
cryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
d764 2
d773 1
a773 1
cryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
d800 1
a800 6
	if (cryptodev_asym(&kop, BN_num_bytes(rsa->n), r0, 0, NULL)) {
		const RSA_METHOD *meth = RSA_PKCS1_SSLeay();
		printf("OCF asym process failed, running in Software\n");
		ret = (*meth->rsa_mod_exp)(r0, I, rsa, ctx);

	} else if (ECANCELED == kop.crk_status) {
d802 1
a802 2
		printf("OCF hardware operation cancelled. Running in Software\n");
		ret = (*meth->rsa_mod_exp)(r0, I, rsa, ctx);
a803 2
	/* else cryptodev operation worked ok ==> ret = 1*/

d939 1
a939 2
/*OCF success value is 0, if not zero, change dsaret to fail*/
		if(0 != kop.crk_status) dsaret  = 0;
d999 1
a999 1
	kop.crk_param[3].crp_p = (caddr_t) key;
d1030 1
a1030 1
cryptodev_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))
d1066 1
a1066 1
		put_dev_crypto(fd);
d1070 1
a1070 1
	put_dev_crypto(fd);
@


