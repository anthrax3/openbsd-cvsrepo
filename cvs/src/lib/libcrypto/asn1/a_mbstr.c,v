head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23;
locks; strict;
comment	@ * @;


1.23
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.22;
commitid	kT0fLt3r4lroFJra;

1.22
date	2015.07.16.02.18.58;	author miod;	state Exp;
branches;
next	1.21;
commitid	0OeWiocRJ0TVCsE0;

1.21
date	2014.10.12.20.47.12;	author miod;	state Exp;
branches;
next	1.20;
commitid	0qOR7tWs6FBCp7Yq;

1.20
date	2014.09.21.12.14.34;	author miod;	state Exp;
branches;
next	1.19;
commitid	Rkuor0kYDpl70xCs;

1.19
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.18;
commitid	yQEL1wOWIearrW15;

1.18
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.17;
commitid	id8dTrTMtnTn4fqt;

1.17
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	mJUVYpkFBZ0Zv2bG;

1.16
date	2014.05.20.01.21.52;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.26.18.56.37;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.19.12.51.01;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.18.07.09.23;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.15.17.46.16;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.26;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.11.22.15.18;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.05.11.05.07;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.57.05;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.08.37;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.45;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.11.21.11.43;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.20.41.32;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.13.51;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.03;	author djm;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: a_mbstr.c,v 1.22 2015/07/16 02:18:58 miod Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999.
 */
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include <openssl/asn1.h>
#include <openssl/err.h>

#include "asn1_locl.h"

static int traverse_string(const unsigned char *p, int len, int inform,
    int (*rfunc)(unsigned long value, void *in), void *arg);
static int in_utf8(unsigned long value, void *arg);
static int out_utf8(unsigned long value, void *arg);
static int type_str(unsigned long value, void *arg);
static int cpy_asc(unsigned long value, void *arg);
static int cpy_bmp(unsigned long value, void *arg);
static int cpy_univ(unsigned long value, void *arg);
static int cpy_utf8(unsigned long value, void *arg);
static int is_printable(unsigned long value);

/* These functions take a string in UTF8, ASCII or multibyte form and
 * a mask of permissible ASN1 string types. It then works out the minimal
 * type (using the order Printable < IA5 < T61 < BMP < Universal < UTF8)
 * and creates a string of the correct type with the supplied data.
 * Yes this is horrible: it has to be :-(
 * The 'ncopy' form checks minimum and maximum size limits too.
 */

int
ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in, int len,
    int inform, unsigned long mask)
{
	return ASN1_mbstring_ncopy(out, in, len, inform, mask, 0, 0);
}

int
ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
    int inform, unsigned long mask, long minsize, long maxsize)
{
	int str_type;
	int ret;
	char free_out;
	int outform, outlen = 0;
	ASN1_STRING *dest;
	unsigned char *p;
	int nchar;
	int (*cpyfunc)(unsigned long, void *) = NULL;

	if (len < 0)
		len = strlen((const char *)in);
	if (!mask)
		mask = DIRSTRING_TYPE;

	/* First do a string check and work out the number of characters */
	switch (inform) {
	case MBSTRING_BMP:
		if (len & 1) {
			ASN1error(ASN1_R_INVALID_BMPSTRING_LENGTH);
			return -1;
		}
		nchar = len >> 1;
		break;

	case MBSTRING_UNIV:
		if (len & 3) {
			ASN1error(ASN1_R_INVALID_UNIVERSALSTRING_LENGTH);
			return -1;
		}
		nchar = len >> 2;
		break;

	case MBSTRING_UTF8:
		nchar = 0;
		/* This counts the characters and does utf8 syntax checking */
		ret = traverse_string(in, len, MBSTRING_UTF8, in_utf8, &nchar);
		if (ret < 0) {
			ASN1error(ASN1_R_INVALID_UTF8STRING);
			return -1;
		}
		break;

	case MBSTRING_ASC:
		nchar = len;
		break;

	default:
		ASN1error(ASN1_R_UNKNOWN_FORMAT);
		return -1;
	}

	if ((minsize > 0) && (nchar < minsize)) {
		ASN1error(ASN1_R_STRING_TOO_SHORT);
		ERR_asprintf_error_data("minsize=%ld", minsize);
		return -1;
	}

	if ((maxsize > 0) && (nchar > maxsize)) {
		ASN1error(ASN1_R_STRING_TOO_LONG);
		ERR_asprintf_error_data("maxsize=%ld", maxsize);
		return -1;
	}

	/* Now work out minimal type (if any) */
	if (traverse_string(in, len, inform, type_str, &mask) < 0) {
		ASN1error(ASN1_R_ILLEGAL_CHARACTERS);
		return -1;
	}


	/* Now work out output format and string type */
	outform = MBSTRING_ASC;
	if (mask & B_ASN1_PRINTABLESTRING)
		str_type = V_ASN1_PRINTABLESTRING;
	else if (mask & B_ASN1_IA5STRING)
		str_type = V_ASN1_IA5STRING;
	else if (mask & B_ASN1_T61STRING)
		str_type = V_ASN1_T61STRING;
	else if (mask & B_ASN1_BMPSTRING) {
		str_type = V_ASN1_BMPSTRING;
		outform = MBSTRING_BMP;
	} else if (mask & B_ASN1_UNIVERSALSTRING) {
		str_type = V_ASN1_UNIVERSALSTRING;
		outform = MBSTRING_UNIV;
	} else {
		str_type = V_ASN1_UTF8STRING;
		outform = MBSTRING_UTF8;
	}
	if (!out)
		return str_type;
	if (*out) {
		free_out = 0;
		dest = *out;
		if (dest->data) {
			dest->length = 0;
			free(dest->data);
			dest->data = NULL;
		}
		dest->type = str_type;
	} else {
		free_out = 1;
		dest = ASN1_STRING_type_new(str_type);
		if (!dest) {
			ASN1error(ERR_R_MALLOC_FAILURE);
			return -1;
		}
		*out = dest;
	}
	/* If both the same type just copy across */
	if (inform == outform) {
		if (!ASN1_STRING_set(dest, in, len)) {
			ASN1error(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		return str_type;
	}

	/* Work out how much space the destination will need */
	switch (outform) {
	case MBSTRING_ASC:
		outlen = nchar;
		cpyfunc = cpy_asc;
		break;

	case MBSTRING_BMP:
		outlen = nchar << 1;
		cpyfunc = cpy_bmp;
		break;

	case MBSTRING_UNIV:
		outlen = nchar << 2;
		cpyfunc = cpy_univ;
		break;

	case MBSTRING_UTF8:
		outlen = 0;
		if (traverse_string(in, len, inform, out_utf8, &outlen) < 0) {
			ASN1error(ASN1_R_ILLEGAL_CHARACTERS);
			goto err;
		}
		cpyfunc = cpy_utf8;
		break;
	}
	if (!(p = malloc(outlen + 1))) {
		ASN1error(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	dest->length = outlen;
	dest->data = p;
	p[outlen] = 0;
	traverse_string(in, len, inform, cpyfunc, &p);
	return str_type;

err:
	if (free_out) {
		ASN1_STRING_free(dest);
		*out = NULL;
	}
	return -1;
}

/* This function traverses a string and passes the value of each character
 * to an optional function along with a void * argument.
 */

static int
traverse_string(const unsigned char *p, int len, int inform,
    int (*rfunc)(unsigned long value, void *in), void *arg)
{
	unsigned long value;
	int ret;

	while (len) {
		switch (inform) {
		case MBSTRING_ASC:
			value = *p++;
			len--;
			break;
		case MBSTRING_BMP:
			value = *p++ << 8;
			value |= *p++;
			/* BMP is explictly defined to not support surrogates */
			if (UNICODE_IS_SURROGATE(value))
				return -1;
			len -= 2;
			break;
		case MBSTRING_UNIV:
			value = (unsigned long)*p++ << 24;
			value |= *p++ << 16;
			value |= *p++ << 8;
			value |= *p++;
			if (value > UNICODE_MAX || UNICODE_IS_SURROGATE(value))
				return -1;
			len -= 4;
			break;
		default:
			ret = UTF8_getc(p, len, &value);
			if (ret < 0)
				return -1;
			len -= ret;
			p += ret;
			break;
		}
		if (rfunc) {
			ret = rfunc(value, arg);
			if (ret <= 0)
				return ret;
		}
	}
	return 1;
}

/* Various utility functions for traverse_string */

/* Just count number of characters */

static int
in_utf8(unsigned long value, void *arg)
{
	int *nchar;

	nchar = arg;
	(*nchar)++;
	return 1;
}

/* Determine size of output as a UTF8 String */

static int
out_utf8(unsigned long value, void *arg)
{
	int *outlen;
	int ret;

	outlen = arg;
	ret = UTF8_putc(NULL, -1, value);
	if (ret < 0)
		return ret;
	*outlen += ret;
	return 1;
}

/* Determine the "type" of a string: check each character against a
 * supplied "mask".
 */

static int
type_str(unsigned long value, void *arg)
{
	unsigned long types;

	types = *((unsigned long *)arg);
	if ((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))
		types &= ~B_ASN1_PRINTABLESTRING;
	if ((types & B_ASN1_IA5STRING) && (value > 127))
		types &= ~B_ASN1_IA5STRING;
	if ((types & B_ASN1_T61STRING) && (value > 0xff))
		types &= ~B_ASN1_T61STRING;
	if ((types & B_ASN1_BMPSTRING) && (value > 0xffff))
		types &= ~B_ASN1_BMPSTRING;
	if (!types)
		return -1;
	*((unsigned long *)arg) = types;
	return 1;
}

/* Copy one byte per character ASCII like strings */

static int
cpy_asc(unsigned long value, void *arg)
{
	unsigned char **p, *q;

	p = arg;
	q = *p;
	*q = value;
	(*p)++;
	return 1;
}

/* Copy two byte per character BMPStrings */

static int
cpy_bmp(unsigned long value, void *arg)
{
	unsigned char **p, *q;

	p = arg;
	q = *p;
	*q++ = (value >> 8) & 0xff;
	*q = value & 0xff;
	*p += 2;
	return 1;
}

/* Copy four byte per character UniversalStrings */

static int
cpy_univ(unsigned long value, void *arg)
{
	unsigned char **p, *q;

	p = arg;
	q = *p;
	*q++ = (value >> 24) & 0xff;
	*q++ = (value >> 16) & 0xff;
	*q++ = (value >> 8) & 0xff;
	*q = value & 0xff;
	*p += 4;
	return 1;
}

/* Copy to a UTF8String */

static int
cpy_utf8(unsigned long value, void *arg)
{
	unsigned char **p;

	int ret;
	p = arg;
	/* We already know there is enough room so pass 0xff as the length */
	ret = UTF8_putc(*p, 0xff, value);
	*p += ret;
	return 1;
}

/* Return 1 if the character is permitted in a PrintableString */
static int
is_printable(unsigned long value)
{
	int ch;

	if (value > 0x7f)
		return 0;
	ch = (int)value;

	/* Note: we can't use 'isalnum' because certain accented
	 * characters may count as alphanumeric in some environments.
	 */
	if ((ch >= 'a') && (ch <= 'z'))
		return 1;
	if ((ch >= 'A') && (ch <= 'Z'))
		return 1;
	if ((ch >= '0') && (ch <= '9'))
		return 1;
	if ((ch == ' ') || strchr("'()+,-./:=?", ch))
		return 1;
	return 0;
}
@


1.22
log
@Explicitely cast a char into unsigned long before shifting it left by 24, for
this would promote it to int for the shift, and then cast to unsigned long,
sign-extending it if sizeof(long) > sizeof(int).

This was not a problem because the computed value was explicitely range
checked afterwards, with an upper bound way smaller than 1U<<31, but it's
better practice to cast correctly.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: a_mbstr.c,v 1.21 2014/10/12 20:47:12 miod Exp $ */
d116 1
a116 2
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
			    ASN1_R_INVALID_BMPSTRING_LENGTH);
d124 1
a124 2
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
			    ASN1_R_INVALID_UNIVERSALSTRING_LENGTH);
d135 1
a135 2
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
			    ASN1_R_INVALID_UTF8STRING);
d145 1
a145 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_UNKNOWN_FORMAT);
d150 1
a150 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_SHORT);
d156 1
a156 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_LONG);
d163 1
a163 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_ILLEGAL_CHARACTERS);
d201 1
a201 2
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
			    ERR_R_MALLOC_FAILURE);
d209 1
a209 2
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
			    ERR_R_MALLOC_FAILURE);
d235 1
a235 2
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
			    ASN1_R_ILLEGAL_CHARACTERS);
d242 1
a242 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);
@


1.21
log
@Paranoia: in ASN1_mbstring_ncopy(), check for len < 0 instead of len == -1,
in order to catch all negative sizes.
@
text
@d1 1
a1 1
/* $OpenBSD: a_mbstr.c,v 1.20 2014/09/21 12:14:34 miod Exp $ */
d291 1
a291 1
			value = *p++ << 24;
@


1.20
log
@Fix a memory leak in the error path in ASN1_mbstring_ncopy().
Replace an if() posse with a switch() statement in traverse_string().
Remove unnecessary casts in cpy_*(),

with tweaks from guenther@@; ok bcook@@ jsing@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: a_mbstr.c,v 1.19 2014/07/11 08:44:47 jsing Exp $ */
d107 1
a107 1
	if (len == -1)
@


1.19
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: a_mbstr.c,v 1.18 2014/07/10 13:58:22 jsing Exp $ */
d215 1
a215 1
			return -1;
d242 1
a242 1
			return -1;
a247 2
		if (free_out)
			ASN1_STRING_free(dest);
d249 1
a249 1
		return -1;
d256 7
d277 2
a278 1
		if (inform == MBSTRING_ASC) {
d281 2
a282 1
		} else if (inform == MBSTRING_BMP) {
d289 4
a292 3
		} else if (inform == MBSTRING_UNIV) {
			value = ((unsigned long)*p++) << 24;
			value |= ((unsigned long)*p++) << 16;
d298 2
a299 1
		} else {
d305 1
d379 1
a379 1
	*q = (unsigned char) value;
d393 2
a394 2
	*q++ = (unsigned char) ((value >> 8) & 0xff);
	*q = (unsigned char) (value & 0xff);
d408 4
a411 4
	*q++ = (unsigned char) ((value >> 24) & 0xff);
	*q++ = (unsigned char) ((value >> 16) & 0xff);
	*q++ = (unsigned char) ((value >> 8) & 0xff);
	*q = (unsigned char) (value & 0xff);
@


1.18
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: a_mbstr.c,v 1.17 2014/06/12 15:49:27 deraadt Exp $ */
a62 1
#include "cryptlib.h"
d64 2
@


1.17
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d59 1
d61 2
a62 1
#include <ctype.h>
@


1.16
log
@Bring UTF8_{getc,putc} up-to-date: it's been a decade since 5- and 6-byte
encodings and encoding of surrogate pair code points were banned.  Add
checks for those, both to those functions and to the code decoding the
BMP and UNIV encodings.

ok miod@@
@
text
@d1 1
a1 1
/* a_mbstr.c */
@


1.15
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d63 1
d236 5
a240 1
		traverse_string(in, len, inform, out_utf8, &outlen);
d275 3
d284 2
d323 1
d326 4
a329 1
	*outlen += UTF8_putc(NULL, -1, value);
@


1.14
log
@More KNF.
@
text
@a100 1
	char strbuf[32];
d150 1
a150 2
		snprintf(strbuf, sizeof strbuf, "%ld", minsize);
		ERR_add_error_data(2, "minsize=", strbuf);
d156 1
a156 2
		snprintf(strbuf, sizeof strbuf, "%ld", maxsize);
		ERR_add_error_data(2, "maxsize=", strbuf);
@


1.13
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d92 1
a92 2
    int inform, unsigned long mask,
    long minsize, long maxsize)
a110 1

d265 1
d282 3
a284 2
			if (ret < 0) return -1;
				len -= ret;
d304 1
d316 1
d413 4
a416 2
	if (value > 0x7f) return 0;
		ch = (int)value;
@


1.12
log
@More KNF.
@
text
@d153 1
a153 1
		(void) snprintf(strbuf, sizeof strbuf, "%ld", minsize);
d160 1
a160 1
		(void) snprintf(strbuf, sizeof strbuf, "%ld", maxsize);
@


1.11
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d65 1
a65 1
		 int (*rfunc)(unsigned long value, void *in), void *arg);
d83 3
a85 2
int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in, int len,
					int inform, unsigned long mask)
d90 4
a93 3
int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
					int inform, unsigned long mask, 
					long minsize, long maxsize)
d103 6
a108 3
	int (*cpyfunc)(unsigned long,void *) = NULL;
	if(len == -1) len = strlen((const char *)in);
	if(!mask) mask = DIRSTRING_TYPE;
d111 1
a111 1
	switch(inform) {
d113 2
a114 2
		case MBSTRING_BMP:
		if(len & 1) {
d116 1
a116 1
					 ASN1_R_INVALID_BMPSTRING_LENGTH);
d122 2
a123 2
		case MBSTRING_UNIV:
		if(len & 3) {
d125 1
a125 1
					 ASN1_R_INVALID_UNIVERSALSTRING_LENGTH);
d131 1
a131 1
		case MBSTRING_UTF8:
d135 1
a135 1
		if(ret < 0) {
d137 1
a137 1
						 ASN1_R_INVALID_UTF8STRING);
d142 1
a142 1
		case MBSTRING_ASC:
d146 1
a146 1
		default:
d151 1
a151 1
	if((minsize > 0) && (nchar < minsize)) {
d158 1
a158 1
	if((maxsize > 0) && (nchar > maxsize)) {
d166 1
a166 1
	if(traverse_string(in, len, inform, type_str, &mask) < 0) {
d174 7
a180 4
	if(mask & B_ASN1_PRINTABLESTRING) str_type = V_ASN1_PRINTABLESTRING;
	else if(mask & B_ASN1_IA5STRING) str_type = V_ASN1_IA5STRING;
	else if(mask & B_ASN1_T61STRING) str_type = V_ASN1_T61STRING;
	else if(mask & B_ASN1_BMPSTRING) {
d183 1
a183 1
	} else if(mask & B_ASN1_UNIVERSALSTRING) {
d190 3
a192 2
	if(!out) return str_type;
	if(*out) {
d195 1
a195 1
		if(dest->data) {
d204 1
a204 1
		if(!dest) {
d206 1
a206 1
							ERR_R_MALLOC_FAILURE);
d212 4
a215 3
	if(inform == outform) {
		if(!ASN1_STRING_set(dest, in, len)) {
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,ERR_R_MALLOC_FAILURE);
d219 1
a219 1
	} 
d222 2
a223 2
	switch(outform) {
		case MBSTRING_ASC:
d228 1
a228 1
		case MBSTRING_BMP:
d233 1
a233 1
		case MBSTRING_UNIV:
d238 1
a238 1
		case MBSTRING_UTF8:
d244 4
a247 3
	if(!(p = malloc(outlen + 1))) {
		if(free_out) ASN1_STRING_free(dest);
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,ERR_R_MALLOC_FAILURE);
d254 1
a254 1
	return str_type;	
d261 3
a263 2
static int traverse_string(const unsigned char *p, int len, int inform,
		 int (*rfunc)(unsigned long value, void *in), void *arg)
d267 2
a268 2
	while(len) {
		if(inform == MBSTRING_ASC) {
d271 1
a271 1
		} else if(inform == MBSTRING_BMP) {
d275 1
a275 1
		} else if(inform == MBSTRING_UNIV) {
d283 2
a284 2
			if(ret < 0) return -1;
			len -= ret;
d287 1
a287 1
		if(rfunc) {
d289 2
a290 1
			if(ret <= 0) return ret;
d300 2
a301 1
static int in_utf8(unsigned long value, void *arg)
d311 2
a312 1
static int out_utf8(unsigned long value, void *arg)
d324 2
a325 1
static int type_str(unsigned long value, void *arg)
d328 1
d330 10
a339 9
	if((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))
					types &= ~B_ASN1_PRINTABLESTRING;
	if((types & B_ASN1_IA5STRING) && (value > 127))
					types &= ~B_ASN1_IA5STRING;
	if((types & B_ASN1_T61STRING) && (value > 0xff))
					types &= ~B_ASN1_T61STRING;
	if((types & B_ASN1_BMPSTRING) && (value > 0xffff))
					types &= ~B_ASN1_BMPSTRING;
	if(!types) return -1;
d346 2
a347 1
static int cpy_asc(unsigned long value, void *arg)
d350 1
d360 2
a361 1
static int cpy_bmp(unsigned long value, void *arg)
d364 1
d375 2
a376 1
static int cpy_univ(unsigned long value, void *arg)
d379 1
d392 2
a393 1
static int cpy_utf8(unsigned long value, void *arg)
d396 1
d406 2
a407 1
static int is_printable(unsigned long value)
d410 4
a413 3
	if(value > 0x7f) return 0;
	ch = (int) value;
	/* Note: we can't use 'isalnum' because certain accented 
d416 8
a423 4
	if((ch >= 'a') && (ch <= 'z')) return 1;
	if((ch >= 'A') && (ch <= 'Z')) return 1;
	if((ch >= '0') && (ch <= '9')) return 1;
	if ((ch == ' ') || strchr("'()+,-./:=?", ch)) return 1;
@


1.10
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@d188 1
a188 1
			OPENSSL_free(dest->data);
d234 1
a234 1
	if(!(p = OPENSSL_malloc(outlen + 1))) {
@


1.9
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@a387 1
#ifndef CHARSET_EBCDIC
a391 6
#else /*CHARSET_EBCDIC*/
	if((ch >= os_toascii['a']) && (ch <= os_toascii['z'])) return 1;
	if((ch >= os_toascii['A']) && (ch <= os_toascii['Z'])) return 1;
	if((ch >= os_toascii['0']) && (ch <= os_toascii['9'])) return 1;
	if ((ch == os_toascii[' ']) || strchr("'()+,-./:=?", os_toebcdic[ch])) return 1;
#endif /*CHARSET_EBCDIC*/
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d148 1
a148 1
		BIO_snprintf(strbuf, sizeof strbuf, "%ld", minsize);
d155 1
a155 1
		BIO_snprintf(strbuf, sizeof strbuf, "%ld", maxsize);
@


1.7
log
@resolve conflicts
@
text
@d96 1
a96 1
	int outform, outlen;
@


1.6
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.5
log
@merge 0.9.7d
@
text
@d110 1
a110 1
			ASN1err(ASN1_F_ASN1_MBSTRING_COPY,
d119 1
a119 1
			ASN1err(ASN1_F_ASN1_MBSTRING_COPY,
d131 1
a131 1
			ASN1err(ASN1_F_ASN1_MBSTRING_COPY,
d142 1
a142 1
		ASN1err(ASN1_F_ASN1_MBSTRING_COPY, ASN1_R_UNKNOWN_FORMAT);
d147 1
a147 1
		ASN1err(ASN1_F_ASN1_MBSTRING_COPY, ASN1_R_STRING_TOO_SHORT);
d154 1
a154 1
		ASN1err(ASN1_F_ASN1_MBSTRING_COPY, ASN1_R_STRING_TOO_LONG);
d162 1
a162 1
		ASN1err(ASN1_F_ASN1_MBSTRING_COPY, ASN1_R_ILLEGAL_CHARACTERS);
d196 1
a196 1
			ASN1err(ASN1_F_ASN1_MBSTRING_COPY,
d205 1
a205 1
			ASN1err(ASN1_F_ASN1_MBSTRING_COPY,ERR_R_MALLOC_FAILURE);
d236 1
a236 1
		ASN1err(ASN1_F_ASN1_MBSTRING_COPY,ERR_R_MALLOC_FAILURE);
@


1.4
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d148 1
a148 1
		snprintf(strbuf, sizeof strbuf, "%ld", minsize);
d155 1
a155 1
		snprintf(strbuf, sizeof strbuf, "%ld", maxsize);
@


1.3
log
@Trivial sprintf() -> snprintf() changes. ok deraadt@@
@
text
@d299 1
a299 1
	long *outlen;
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d148 1
a148 1
		sprintf(strbuf, "%ld", minsize);
d155 1
a155 1
		sprintf(strbuf, "%ld", maxsize);
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d95 1
d184 1
d188 1
a188 1
			Free(dest->data);
d193 1
d234 2
a235 2
	if(!(p = Malloc(outlen + 1))) {
		ASN1_STRING_free(dest);
d264 2
a265 2
			value = *p++ << 24;
			value |= *p++ << 16;
d388 1
d393 6
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a94 1
	char free_out;
a182 1
		free_out = 0;
d186 1
a186 1
			OPENSSL_free(dest->data);
a190 1
		free_out = 1;
d231 2
a232 2
	if(!(p = OPENSSL_malloc(outlen + 1))) {
		if(free_out) ASN1_STRING_free(dest);
d261 2
a262 2
			value = ((unsigned long)*p++) << 24;
			value |= ((unsigned long)*p++) << 16;
a384 1
#ifndef CHARSET_EBCDIC
a388 6
#else /*CHARSET_EBCDIC*/
	if((ch >= os_toascii['a']) && (ch <= os_toascii['z'])) return 1;
	if((ch >= os_toascii['A']) && (ch <= os_toascii['Z'])) return 1;
	if((ch >= os_toascii['0']) && (ch <= os_toascii['9'])) return 1;
	if ((ch == os_toascii[' ']) || strchr("'()+,-./:=?", os_toebcdic[ch])) return 1;
#endif /*CHARSET_EBCDIC*/
@


1.1.1.2
log
@import 0.9.7c
@
text
@d299 1
a299 1
	int *outlen;
@


1.1.1.3
log
@import openssl-0.9.7d
@
text
@d148 1
a148 1
		BIO_snprintf(strbuf, sizeof strbuf, "%ld", minsize);
d155 1
a155 1
		BIO_snprintf(strbuf, sizeof strbuf, "%ld", maxsize);
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d110 1
a110 1
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
d119 1
a119 1
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
d131 1
a131 1
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
d142 1
a142 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_UNKNOWN_FORMAT);
d147 1
a147 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_SHORT);
d154 1
a154 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_LONG);
d162 1
a162 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_ILLEGAL_CHARACTERS);
d196 1
a196 1
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
d205 1
a205 1
			ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,ERR_R_MALLOC_FAILURE);
d236 1
a236 1
		ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,ERR_R_MALLOC_FAILURE);
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d96 1
a96 1
	int outform, outlen = 0;
@


