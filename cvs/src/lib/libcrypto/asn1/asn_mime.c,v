head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.2
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27;
locks; strict;
comment	@ * @;


1.27
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.26;
commitid	kT0fLt3r4lroFJra;

1.26
date	2015.02.22.15.19.56;	author jsing;	state Exp;
branches;
next	1.25;
commitid	GMcTlSgvcpkYdpb1;

1.25
date	2015.02.10.11.22.21;	author jsing;	state Exp;
branches;
next	1.24;
commitid	LaAI4ax0sm4T2bQg;

1.24
date	2015.02.08.22.17.49;	author miod;	state Exp;
branches;
next	1.23;
commitid	eyN0U148qk9U7yka;

1.23
date	2014.10.22.13.02.03;	author jsing;	state Exp;
branches;
next	1.22;
commitid	PjnBgKe6Buhbf937;

1.22
date	2014.07.13.16.03.09;	author beck;	state Exp;
branches;
next	1.21;
commitid	6xdvCwSqBadTW6X3;

1.21
date	2014.07.11.13.41.59;	author miod;	state Exp;
branches;
next	1.20;
commitid	m0t9LXKcoE1LTsTy;

1.20
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.19;
commitid	yQEL1wOWIearrW15;

1.19
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.18;
commitid	id8dTrTMtnTn4fqt;

1.18
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	mJUVYpkFBZ0Zv2bG;

1.17
date	2014.06.01.15.39.50;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	k01TWVGFNtltfh7t;

1.16
date	2014.05.30.02.52.11;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.25.17.32.20;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.15.21.07.10;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.26.18.56.37;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.21.11.37.41;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.19.07.20.59;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.18.00.58.49;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.18.00.10.08;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.17.18.38.53;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.17.17.30.22;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.40;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.40;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.13.51;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2009.04.06.06.30.01;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.03;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.34;	author djm;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: asn_mime.c,v 1.26 2015/02/22 15:19:56 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 1999-2008 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/asn1.h>
#include <openssl/asn1t.h>
#include <openssl/err.h>
#include <openssl/x509.h>

#include "asn1_locl.h"

/* Generalised MIME like utilities for streaming ASN1. Although many
 * have a PKCS7/CMS like flavour others are more general purpose.
 */

/* MIME format structures
 * Note that all are translated to lower case apart from
 * parameter values. Quotes are stripped off
 */

typedef struct {
	char *param_name;		/* Param name e.g. "micalg" */
	char *param_value;		/* Param value e.g. "sha1" */
} MIME_PARAM;

DECLARE_STACK_OF(MIME_PARAM)

typedef struct {
	char *name;			/* Name of line e.g. "content-type" */
	char *value;			/* Value of line e.g. "text/plain" */
	STACK_OF(MIME_PARAM) *params;	/* Zero or more parameters */
} MIME_HEADER;

DECLARE_STACK_OF(MIME_HEADER)

static int asn1_output_data(BIO *out, BIO *data, ASN1_VALUE *val, int flags,
    const ASN1_ITEM *it);
static char * strip_ends(char *name);
static char * strip_start(char *name);
static char * strip_end(char *name);
static MIME_HEADER *mime_hdr_new(char *name, char *value);
static int mime_hdr_addparam(MIME_HEADER *mhdr, char *name, char *value);
static STACK_OF(MIME_HEADER) *mime_parse_hdr(BIO *bio);
static int mime_hdr_cmp(const MIME_HEADER * const *a,
    const MIME_HEADER * const *b);
static int mime_param_cmp(const MIME_PARAM * const *a,
    const MIME_PARAM * const *b);
static void mime_param_free(MIME_PARAM *param);
static int mime_bound_check(char *line, int linelen, char *bound, int blen);
static int multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret);
static int strip_eol(char *linebuf, int *plen);
static MIME_HEADER *mime_hdr_find(STACK_OF(MIME_HEADER) *hdrs, char *name);
static MIME_PARAM *mime_param_find(MIME_HEADER *hdr, char *name);
static void mime_hdr_free(MIME_HEADER *hdr);

#define MAX_SMLEN 1024
#define mime_debug(x) /* x */

/* Output an ASN1 structure in BER format streaming if necessary */

int
i2d_ASN1_bio_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
    const ASN1_ITEM *it)
{
	/* If streaming create stream BIO and copy all content through it */
	if (flags & SMIME_STREAM) {
		BIO *bio, *tbio;
		bio = BIO_new_NDEF(out, val, it);
		if (!bio) {
			ASN1error(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		SMIME_crlf_copy(in, bio, flags);
		(void)BIO_flush(bio);
		/* Free up successive BIOs until we hit the old output BIO */
		do {
			tbio = BIO_pop(bio);
			BIO_free(bio);
			bio = tbio;
		} while (bio != out);
	}
	/* else just write out ASN1 structure which will have all content
	 * stored internally
	 */
	else
		ASN1_item_i2d_bio(it, out, val);
	return 1;
}

/* Base 64 read and write of ASN1 structure */

static int
B64_write_ASN1(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
    const ASN1_ITEM *it)
{
	BIO *b64;
	int r;

	b64 = BIO_new(BIO_f_base64());
	if (!b64) {
		ASN1error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	/* prepend the b64 BIO so all data is base64 encoded.
	 */
	out = BIO_push(b64, out);
	r = i2d_ASN1_bio_stream(out, val, in, flags, it);
	(void)BIO_flush(out);
	BIO_pop(out);
	BIO_free(b64);
	return r;
}

/* Streaming ASN1 PEM write */

int
PEM_write_bio_ASN1_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
    const char *hdr, const ASN1_ITEM *it)
{
	int r;

	BIO_printf(out, "-----BEGIN %s-----\n", hdr);
	r = B64_write_ASN1(out, val, in, flags, it);
	BIO_printf(out, "-----END %s-----\n", hdr);
	return r;
}

static ASN1_VALUE *
b64_read_asn1(BIO *bio, const ASN1_ITEM *it)
{
	BIO *b64;
	ASN1_VALUE *val;
	if (!(b64 = BIO_new(BIO_f_base64()))) {
		ASN1error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	bio = BIO_push(b64, bio);
	val = ASN1_item_d2i_bio(it, bio, NULL);
	if (!val)
		ASN1error(ASN1_R_DECODE_ERROR);
	(void)BIO_flush(bio);
	bio = BIO_pop(bio);
	BIO_free(b64);
	return val;
}

/* Generate the MIME "micalg" parameter from RFC3851, RFC4490 */

static int
asn1_write_micalg(BIO *out, STACK_OF(X509_ALGOR) *mdalgs)
{
	const EVP_MD *md;
	int i, have_unknown = 0, write_comma, ret = 0, md_nid;

	have_unknown = 0;
	write_comma = 0;
	for (i = 0; i < sk_X509_ALGOR_num(mdalgs); i++) {
		if (write_comma)
			BIO_write(out, ",", 1);
		write_comma = 1;
		md_nid = OBJ_obj2nid(sk_X509_ALGOR_value(mdalgs, i)->algorithm);
		md = EVP_get_digestbynid(md_nid);
		if (md && md->md_ctrl) {
			int rv;
			char *micstr;
			rv = md->md_ctrl(NULL, EVP_MD_CTRL_MICALG, 0, &micstr);
			if (rv > 0) {
				BIO_puts(out, micstr);
				free(micstr);
				continue;
			}
			if (rv != -2)
				goto err;
		}
		switch (md_nid) {
		case NID_sha1:
			BIO_puts(out, "sha1");
			break;

		case NID_md5:
			BIO_puts(out, "md5");
			break;

		case NID_sha256:
			BIO_puts(out, "sha-256");
			break;

		case NID_sha384:
			BIO_puts(out, "sha-384");
			break;

		case NID_sha512:
			BIO_puts(out, "sha-512");
			break;

		case NID_id_GostR3411_94:
			BIO_puts(out, "gostr3411-94");
			goto err;
			break;

		default:
			if (have_unknown)
				write_comma = 0;
			else {
				BIO_puts(out, "unknown");
				have_unknown = 1;
			}
			break;

		}
	}

	ret = 1;

err:
	return ret;
}

/* SMIME sender */

int
SMIME_write_ASN1(BIO *bio, ASN1_VALUE *val, BIO *data, int flags,
    int ctype_nid, int econt_nid, STACK_OF(X509_ALGOR) *mdalgs,
    const ASN1_ITEM *it)
{
	char bound[33], c;
	int i;
	const char *mime_prefix, *mime_eol, *cname = "smime.p7m";
	const char *msg_type = NULL;

	if (flags & SMIME_OLDMIME)
		mime_prefix = "application/x-pkcs7-";
	else
		mime_prefix = "application/pkcs7-";

	if (flags & SMIME_CRLFEOL)
		mime_eol = "\r\n";
	else
		mime_eol = "\n";
	if ((flags & SMIME_DETACHED) && data) {
		/* We want multipart/signed */
		/* Generate a random boundary */
		arc4random_buf(bound, 32);
		for (i = 0; i < 32; i++) {
			c = bound[i] & 0xf;
			if (c < 10)
				c += '0';
			else
				c += 'A' - 10;
			bound[i] = c;
		}
		bound[32] = 0;
		BIO_printf(bio, "MIME-Version: 1.0%s", mime_eol);
		BIO_printf(bio, "Content-Type: multipart/signed;");
		BIO_printf(bio, " protocol=\"%ssignature\";", mime_prefix);
		BIO_puts(bio, " micalg=\"");
		asn1_write_micalg(bio, mdalgs);
		BIO_printf(bio, "\"; boundary=\"----%s\"%s%s",
		    bound, mime_eol, mime_eol);
		BIO_printf(bio, "This is an S/MIME signed message%s%s",
		    mime_eol, mime_eol);
		/* Now write out the first part */
		BIO_printf(bio, "------%s%s", bound, mime_eol);
		if (!asn1_output_data(bio, data, val, flags, it))
			return 0;
		BIO_printf(bio, "%s------%s%s", mime_eol, bound, mime_eol);

		/* Headers for signature */

		BIO_printf(bio, "Content-Type: %ssignature;", mime_prefix);
		BIO_printf(bio, " name=\"smime.p7s\"%s", mime_eol);
		BIO_printf(bio, "Content-Transfer-Encoding: base64%s",
		    mime_eol);
		BIO_printf(bio, "Content-Disposition: attachment;");
		BIO_printf(bio, " filename=\"smime.p7s\"%s%s",
		    mime_eol, mime_eol);
		B64_write_ASN1(bio, val, NULL, 0, it);
		BIO_printf(bio, "%s------%s--%s%s", mime_eol, bound,
		    mime_eol, mime_eol);
		return 1;
	}

	/* Determine smime-type header */

	if (ctype_nid == NID_pkcs7_enveloped)
		msg_type = "enveloped-data";
	else if (ctype_nid == NID_pkcs7_signed) {
		if (econt_nid == NID_id_smime_ct_receipt)
			msg_type = "signed-receipt";
		else if (sk_X509_ALGOR_num(mdalgs) >= 0)
			msg_type = "signed-data";
		else
			msg_type = "certs-only";
	} else if (ctype_nid == NID_id_smime_ct_compressedData) {
		msg_type = "compressed-data";
		cname = "smime.p7z";
	}
	/* MIME headers */
	BIO_printf(bio, "MIME-Version: 1.0%s", mime_eol);
	BIO_printf(bio, "Content-Disposition: attachment;");
	BIO_printf(bio, " filename=\"%s\"%s", cname, mime_eol);
	BIO_printf(bio, "Content-Type: %smime;", mime_prefix);
	if (msg_type)
		BIO_printf(bio, " smime-type=%s;", msg_type);
	BIO_printf(bio, " name=\"%s\"%s", cname, mime_eol);
	BIO_printf(bio, "Content-Transfer-Encoding: base64%s%s",
	    mime_eol, mime_eol);
	if (!B64_write_ASN1(bio, val, data, flags, it))
		return 0;
	BIO_printf(bio, "%s", mime_eol);
	return 1;
}

/* Handle output of ASN1 data */


static int
asn1_output_data(BIO *out, BIO *data, ASN1_VALUE *val, int flags,
    const ASN1_ITEM *it)
{
	BIO *tmpbio;
	const ASN1_AUX *aux = it->funcs;
	ASN1_STREAM_ARG sarg;
	int rv = 1;

	/* If data is not deteched or resigning then the output BIO is
	 * already set up to finalise when it is written through.
	 */
	if (!(flags & SMIME_DETACHED) || (flags & PKCS7_REUSE_DIGEST)) {
		SMIME_crlf_copy(data, out, flags);
		return 1;
	}

	if (!aux || !aux->asn1_cb) {
		ASN1error(ASN1_R_STREAMING_NOT_SUPPORTED);
		return 0;
	}

	sarg.out = out;
	sarg.ndef_bio = NULL;
	sarg.boundary = NULL;

	/* Let ASN1 code prepend any needed BIOs */

	if (aux->asn1_cb(ASN1_OP_DETACHED_PRE, &val, it, &sarg) <= 0)
		return 0;

	/* Copy data across, passing through filter BIOs for processing */
	SMIME_crlf_copy(data, sarg.ndef_bio, flags);

	/* Finalize structure */
	if (aux->asn1_cb(ASN1_OP_DETACHED_POST, &val, it, &sarg) <= 0)
		rv = 0;

	/* Now remove any digests prepended to the BIO */

	while (sarg.ndef_bio != out) {
		tmpbio = BIO_pop(sarg.ndef_bio);
		BIO_free(sarg.ndef_bio);
		sarg.ndef_bio = tmpbio;
	}

	return rv;
}

/* SMIME reader: handle multipart/signed and opaque signing.
 * in multipart case the content is placed in a memory BIO
 * pointed to by "bcont". In opaque this is set to NULL
 */

ASN1_VALUE *
SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)
{
	BIO *asnin;
	STACK_OF(MIME_HEADER) *headers = NULL;
	STACK_OF(BIO) *parts = NULL;
	MIME_HEADER *hdr;
	MIME_PARAM *prm;
	ASN1_VALUE *val;
	int ret;

	if (bcont)
		*bcont = NULL;

	if (!(headers = mime_parse_hdr(bio))) {
		ASN1error(ASN1_R_MIME_PARSE_ERROR);
		return NULL;
	}

	if (!(hdr = mime_hdr_find(headers, "content-type")) || !hdr->value) {
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		ASN1error(ASN1_R_NO_CONTENT_TYPE);
		return NULL;
	}

	/* Handle multipart/signed */

	if (!strcmp(hdr->value, "multipart/signed")) {
		/* Split into two parts */
		prm = mime_param_find(hdr, "boundary");
		if (!prm || !prm->param_value) {
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
			ASN1error(ASN1_R_NO_MULTIPART_BOUNDARY);
			return NULL;
		}
		ret = multi_split(bio, prm->param_value, &parts);
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		if (!ret || (sk_BIO_num(parts) != 2) ) {
			ASN1error(ASN1_R_NO_MULTIPART_BODY_FAILURE);
			sk_BIO_pop_free(parts, BIO_vfree);
			return NULL;
		}

		/* Parse the signature piece */
		asnin = sk_BIO_value(parts, 1);

		if (!(headers = mime_parse_hdr(asnin))) {
			ASN1error(ASN1_R_MIME_SIG_PARSE_ERROR);
			sk_BIO_pop_free(parts, BIO_vfree);
			return NULL;
		}

		/* Get content type */

		if (!(hdr = mime_hdr_find(headers, "content-type")) ||
		    !hdr->value) {
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
			sk_BIO_pop_free(parts, BIO_vfree);
			ASN1error(ASN1_R_NO_SIG_CONTENT_TYPE);
			return NULL;
		}

		if (strcmp(hdr->value, "application/x-pkcs7-signature") &&
		    strcmp(hdr->value, "application/pkcs7-signature")) {
			ASN1error(ASN1_R_SIG_INVALID_MIME_TYPE);
			ERR_asprintf_error_data("type: %s", hdr->value);
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
			sk_BIO_pop_free(parts, BIO_vfree);
			return NULL;
		}
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		/* Read in ASN1 */
		if (!(val = b64_read_asn1(asnin, it))) {
			ASN1error(ASN1_R_ASN1_SIG_PARSE_ERROR);
			sk_BIO_pop_free(parts, BIO_vfree);
			return NULL;
		}

		if (bcont) {
			*bcont = sk_BIO_value(parts, 0);
			BIO_free(asnin);
			sk_BIO_free(parts);
		} else sk_BIO_pop_free(parts, BIO_vfree);
			return val;
	}

	/* OK, if not multipart/signed try opaque signature */

	if (strcmp (hdr->value, "application/x-pkcs7-mime") &&
	    strcmp (hdr->value, "application/pkcs7-mime")) {
		ASN1error(ASN1_R_INVALID_MIME_TYPE);
		ERR_asprintf_error_data("type: %s", hdr->value);
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		return NULL;
	}

	sk_MIME_HEADER_pop_free(headers, mime_hdr_free);

	if (!(val = b64_read_asn1(bio, it))) {
		ASN1error(ASN1_R_ASN1_PARSE_ERROR);
		return NULL;
	}
	return val;
}

/* Copy text from one BIO to another making the output CRLF at EOL */
int
SMIME_crlf_copy(BIO *in, BIO *out, int flags)
{
	BIO *bf;
	char eol;
	int len;
	char linebuf[MAX_SMLEN];

	/* Buffer output so we don't write one line at a time. This is
	 * useful when streaming as we don't end up with one OCTET STRING
	 * per line.
	 */
	bf = BIO_new(BIO_f_buffer());
	if (!bf)
		return 0;
	out = BIO_push(bf, out);
	if (flags & SMIME_BINARY) {
		while ((len = BIO_read(in, linebuf, MAX_SMLEN)) > 0)
			BIO_write(out, linebuf, len);
	} else {
		if (flags & SMIME_TEXT)
			BIO_printf(out, "Content-Type: text/plain\r\n\r\n");
		while ((len = BIO_gets(in, linebuf, MAX_SMLEN)) > 0) {
			eol = strip_eol(linebuf, &len);
			if (len)
				BIO_write(out, linebuf, len);
			if (eol)
				BIO_write(out, "\r\n", 2);
		}
	}
	(void)BIO_flush(out);
	BIO_pop(out);
	BIO_free(bf);
	return 1;
}

/* Strip off headers if they are text/plain */
int
SMIME_text(BIO *in, BIO *out)
{
	char iobuf[4096];
	int len;
	STACK_OF(MIME_HEADER) *headers;
	MIME_HEADER *hdr;

	if (!(headers = mime_parse_hdr(in))) {
		ASN1error(ASN1_R_MIME_PARSE_ERROR);
		return 0;
	}
	if (!(hdr = mime_hdr_find(headers, "content-type")) || !hdr->value) {
		ASN1error(ASN1_R_MIME_NO_CONTENT_TYPE);
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		return 0;
	}
	if (strcmp (hdr->value, "text/plain")) {
		ASN1error(ASN1_R_INVALID_MIME_TYPE);
		ERR_asprintf_error_data("type: %s", hdr->value);
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		return 0;
	}
	sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
	while ((len = BIO_read(in, iobuf, sizeof(iobuf))) > 0)
		BIO_write(out, iobuf, len);
	if (len < 0)
		return 0;
	return 1;
}

/*
 * Split a multipart/XXX message body into component parts: result is
 * canonical parts in a STACK of bios
 */
static int
multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret)
{
	char linebuf[MAX_SMLEN];
	int len, blen;
	int eol = 0, next_eol = 0;
	BIO *bpart = NULL;
	STACK_OF(BIO) *parts;
	char state, part, first;

	blen = strlen(bound);
	part = 0;
	state = 0;
	first = 1;
	parts = sk_BIO_new_null();
	*ret = parts;
	if (parts == NULL)
		return 0;
	while ((len = BIO_gets(bio, linebuf, MAX_SMLEN)) > 0) {
		state = mime_bound_check(linebuf, len, bound, blen);
		if (state == 1) {
			first = 1;
			part++;
		} else if (state == 2) {
			if (sk_BIO_push(parts, bpart) == 0)
				return 0;
			return 1;
		} else if (part) {
			/* Strip CR+LF from linebuf */
			next_eol = strip_eol(linebuf, &len);
			if (first) {
				first = 0;
				if (bpart != NULL) {
					if (sk_BIO_push(parts, bpart) == 0)
						return 0;
				}
				bpart = BIO_new(BIO_s_mem());
				if (bpart == NULL)
					return 0;
				BIO_set_mem_eof_return(bpart, 0);
			} else if (eol)
				BIO_write(bpart, "\r\n", 2);
			eol = next_eol;
			if (len)
				BIO_write(bpart, linebuf, len);
		}
	}
	BIO_free(bpart);
	return 0;
}

/* This is the big one: parse MIME header lines up to message body */

#define MIME_INVALID	0
#define MIME_START	1
#define MIME_TYPE	2
#define MIME_NAME	3
#define MIME_VALUE	4
#define MIME_QUOTE	5
#define MIME_COMMENT	6


static
STACK_OF(MIME_HEADER) *mime_parse_hdr(BIO *bio)
{
	char *p, *q, c;
	char *ntmp;
	char linebuf[MAX_SMLEN];
	MIME_HEADER *mhdr = NULL;
	STACK_OF(MIME_HEADER) *headers;
	int len, state, save_state = 0;

	headers = sk_MIME_HEADER_new(mime_hdr_cmp);
	if (!headers)
		return NULL;
	while ((len = BIO_gets(bio, linebuf, MAX_SMLEN)) > 0) {
		/* If whitespace at line start then continuation line */
		if (mhdr && isspace((unsigned char)linebuf[0]))
			state = MIME_NAME;
		else
			state = MIME_START;
		ntmp = NULL;

		/* Go through all characters */
		for (p = linebuf, q = linebuf;
		    (c = *p) && (c != '\r') && (c != '\n'); p++) {

			/* State machine to handle MIME headers
			 * if this looks horrible that's because it *is*
			 */

			switch (state) {
			case MIME_START:
				if (c == ':') {
					state = MIME_TYPE;
					*p = 0;
					ntmp = strip_ends(q);
					q = p + 1;
				}
				break;

			case MIME_TYPE:
				if (c == ';') {
					mime_debug("Found End Value\n");
					*p = 0;
					mhdr = mime_hdr_new(ntmp,
					    strip_ends(q));
					if (mhdr == NULL)
						goto merr;
					if (sk_MIME_HEADER_push(headers,
					    mhdr) == 0)
						goto merr;
					ntmp = NULL;
					q = p + 1;
					state = MIME_NAME;
				} else if (c == '(') {
					save_state = state;
					state = MIME_COMMENT;
				}
				break;

			case MIME_COMMENT:
				if (c == ')') {
					state = save_state;
				}
				break;

			case MIME_NAME:
				if (c == '=') {
					state = MIME_VALUE;
					*p = 0;
					ntmp = strip_ends(q);
					q = p + 1;
				}
				break;

			case MIME_VALUE:
				if (c == ';') {
					state = MIME_NAME;
					*p = 0;
					mime_hdr_addparam(mhdr, ntmp,
					    strip_ends(q));
					ntmp = NULL;
					q = p + 1;
				} else if (c == '"') {
					mime_debug("Found Quote\n");
					state = MIME_QUOTE;
				} else if (c == '(') {
					save_state = state;
					state = MIME_COMMENT;
				}
				break;

			case MIME_QUOTE:
				if (c == '"') {
					mime_debug("Found Match Quote\n");
					state = MIME_VALUE;
				}
				break;
			}
		}

		if (state == MIME_TYPE) {
			mhdr = mime_hdr_new(ntmp, strip_ends(q));
			if (mhdr == NULL)
				goto merr;
			if (sk_MIME_HEADER_push(headers, mhdr) == 0)
				goto merr;
		} else if (state == MIME_VALUE)
			mime_hdr_addparam(mhdr, ntmp, strip_ends(q));

		if (p == linebuf)
			break;	/* Blank line means end of headers */
	}

	return headers;

merr:
	if (mhdr != NULL)
		mime_hdr_free(mhdr);
	sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
	return NULL;
}

static char *
strip_ends(char *name)
{
	return strip_end(strip_start(name));
}

/* Strip a parameter of whitespace from start of param */
static char *
strip_start(char *name)
{
	char *p, c;

	/* Look for first non white space or quote */
	for (p = name; (c = *p); p++) {
		if (c == '"') {
			/* Next char is start of string if non null */
			if (p[1])
				return p + 1;
			/* Else null string */
			return NULL;
		}
		if (!isspace((unsigned char)c))
			return p;
	}
	return NULL;
}

/* As above but strip from end of string : maybe should handle brackets? */
static char *
strip_end(char *name)
{
	char *p, c;

	if (!name)
		return NULL;

	/* Look for first non white space or quote */
	for (p = name + strlen(name) - 1; p >= name; p--) {
		c = *p;
		if (c == '"') {
			if (p - 1 == name)
				return NULL;
			*p = 0;
			return name;
		}
		if (isspace((unsigned char)c))
			*p = 0;
		else
			return name;
	}
	return NULL;
}

static MIME_HEADER *
mime_hdr_new(char *name, char *value)
{
	MIME_HEADER *mhdr;
	char *tmpname = NULL, *tmpval = NULL, *p;

	if (name) {
		if (!(tmpname = strdup(name)))
			goto err;
		for (p = tmpname; *p; p++)
			*p = tolower((unsigned char)*p);
	}
	if (value) {
		if (!(tmpval = strdup(value)))
			goto err;
		for (p = tmpval; *p; p++)
			*p = tolower((unsigned char)*p);
	}
	mhdr = malloc(sizeof(MIME_HEADER));
	if (!mhdr)
		goto err;
	mhdr->name = tmpname;
	mhdr->value = tmpval;
	if (!(mhdr->params = sk_MIME_PARAM_new(mime_param_cmp))) {
		free(mhdr);
		goto err;
	}
	return mhdr;
err:
	free(tmpname);
	free(tmpval);
	return NULL;
}

static int
mime_hdr_addparam(MIME_HEADER *mhdr, char *name, char *value)
{
	char *tmpname = NULL, *tmpval = NULL, *p;
	MIME_PARAM *mparam;

	if (name) {
		tmpname = strdup(name);
		if (!tmpname)
			goto err;
		for (p = tmpname; *p; p++)
			*p = tolower((unsigned char)*p);
	}
	if (value) {
		tmpval = strdup(value);
		if (!tmpval)
			goto err;
	}
	/* Parameter values are case sensitive so leave as is */
	mparam = malloc(sizeof(MIME_PARAM));
	if (!mparam)
		goto err;
	mparam->param_name = tmpname;
	mparam->param_value = tmpval;
	if (sk_MIME_PARAM_push(mhdr->params, mparam) == 0) {
		free(mparam);
		goto err;
	}
	return 1;
err:
	free(tmpname);
	free(tmpval);
	return 0;
}

static int
mime_hdr_cmp(const MIME_HEADER * const *a, const MIME_HEADER * const *b)
{
	if (!(*a)->name || !(*b)->name)
		return !!(*a)->name - !!(*b)->name;
	return (strcmp((*a)->name, (*b)->name));
}

static int
mime_param_cmp(const MIME_PARAM * const *a, const MIME_PARAM * const *b)
{
	if (!(*a)->param_name || !(*b)->param_name)
		return !!(*a)->param_name - !!(*b)->param_name;
	return (strcmp((*a)->param_name, (*b)->param_name));
}

/* Find a header with a given name (if possible) */

static MIME_HEADER *
mime_hdr_find(STACK_OF(MIME_HEADER) *hdrs, char *name)
{
	MIME_HEADER htmp;
	int idx;
	htmp.name = name;
	idx = sk_MIME_HEADER_find(hdrs, &htmp);
	if (idx < 0)
		return NULL;
	return sk_MIME_HEADER_value(hdrs, idx);
}

static MIME_PARAM *
mime_param_find(MIME_HEADER *hdr, char *name)
{
	MIME_PARAM param;
	int idx;
	param.param_name = name;
	idx = sk_MIME_PARAM_find(hdr->params, &param);
	if (idx < 0)
		return NULL;
	return sk_MIME_PARAM_value(hdr->params, idx);
}

static void
mime_hdr_free(MIME_HEADER *hdr)
{
	free(hdr->name);
	free(hdr->value);
	if (hdr->params)
		sk_MIME_PARAM_pop_free(hdr->params, mime_param_free);
	free(hdr);
}

static void
mime_param_free(MIME_PARAM *param)
{
	free(param->param_name);
	free(param->param_value);
	free(param);
}

/* Check for a multipart boundary. Returns:
 * 0 : no boundary
 * 1 : part boundary
 * 2 : final boundary
 */
static int
mime_bound_check(char *line, int linelen, char *bound, int blen)
{
	if (linelen == -1)
		linelen = strlen(line);
	if (blen == -1)
		blen = strlen(bound);
	/* Quickly eliminate if line length too short */
	if (blen + 2 > linelen)
		return 0;
	/* Check for part boundary */
	if (!strncmp(line, "--", 2) && !strncmp(line + 2, bound, blen)) {
		if (!strncmp(line + blen + 2, "--", 2))
			return 2;
		else
			return 1;
	}
	return 0;
}

static int
strip_eol(char *linebuf, int *plen)
{
	int len = *plen;
	char *p, c;
	int is_eol = 0;

	for (p = linebuf + len - 1; len > 0; len--, p--) {
		c = *p;
		if (c == '\n')
			is_eol = 1;
		else if (c != '\r')
			break;
	}
	*plen = len;
	return is_eol;
}
@


1.26
log
@Remove IMPLEMENT_STACK_OF noops.
@
text
@d1 1
a1 1
/* $OpenBSD: asn_mime.c,v 1.25 2015/02/10 11:22:21 jsing Exp $ */
d125 1
a125 2
			ASN1err(ASN1_F_I2D_ASN1_BIO_STREAM,
			    ERR_R_MALLOC_FAILURE);
d156 1
a156 1
		ASN1err(ASN1_F_B64_WRITE_ASN1, ERR_R_MALLOC_FAILURE);
d189 1
a189 1
		ASN1err(ASN1_F_B64_READ_ASN1, ERR_R_MALLOC_FAILURE);
d195 1
a195 1
		ASN1err(ASN1_F_B64_READ_ASN1, ASN1_R_DECODE_ERROR);
d390 1
a390 2
		ASN1err(ASN1_F_ASN1_OUTPUT_DATA,
		    ASN1_R_STREAMING_NOT_SUPPORTED);
d441 1
a441 1
		ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_MIME_PARSE_ERROR);
d447 1
a447 1
		ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_CONTENT_TYPE);
d458 1
a458 2
			ASN1err(ASN1_F_SMIME_READ_ASN1,
			    ASN1_R_NO_MULTIPART_BOUNDARY);
d464 1
a464 2
			ASN1err(ASN1_F_SMIME_READ_ASN1,
			    ASN1_R_NO_MULTIPART_BODY_FAILURE);
d473 1
a473 2
			ASN1err(ASN1_F_SMIME_READ_ASN1,
			    ASN1_R_MIME_SIG_PARSE_ERROR);
d484 1
a484 2
			ASN1err(ASN1_F_SMIME_READ_ASN1,
			    ASN1_R_NO_SIG_CONTENT_TYPE);
d490 1
a490 2
			ASN1err(ASN1_F_SMIME_READ_ASN1,
			    ASN1_R_SIG_INVALID_MIME_TYPE);
d499 1
a499 2
			ASN1err(ASN1_F_SMIME_READ_ASN1,
			    ASN1_R_ASN1_SIG_PARSE_ERROR);
d516 1
a516 1
		ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_INVALID_MIME_TYPE);
d525 1
a525 1
		ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_ASN1_PARSE_ERROR);
d578 1
a578 1
		ASN1err(ASN1_F_SMIME_TEXT, ASN1_R_MIME_PARSE_ERROR);
d582 1
a582 1
		ASN1err(ASN1_F_SMIME_TEXT, ASN1_R_MIME_NO_CONTENT_TYPE);
d587 1
a587 1
		ASN1err(ASN1_F_SMIME_TEXT, ASN1_R_INVALID_MIME_TYPE);
@


1.25
log
@Remove more IMPLEMENT_STACK_OF noops that have been hiding for the last
15 years.
@
text
@d1 1
a1 1
/* $OpenBSD: asn_mime.c,v 1.24 2015/02/08 22:17:49 miod Exp $ */
a89 1
IMPLEMENT_STACK_OF(MIME_HEADER)
@


1.24
log
@Check memory allocation results, as well as stack pushes.
Also fix a memory leak in one of the error paths of SMIME_read_ASN1(), spotted
by doug@@
tweaks&ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn_mime.c,v 1.23 2014/10/22 13:02:03 jsing Exp $ */
a81 1
IMPLEMENT_STACK_OF(MIME_PARAM)
@


1.23
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn_mime.c,v 1.22 2014/07/13 16:03:09 beck Exp $ */
d490 1
d610 2
a611 1
/* Split a multipart/XXX message body into component parts: result is
a613 1

d630 2
d638 2
a639 1
			sk_BIO_push(parts, bpart);
d646 4
a649 2
				if (bpart)
					sk_BIO_push(parts, bpart);
d651 2
d661 1
d721 5
a725 1
					sk_MIME_HEADER_push(headers, mhdr);
d778 4
a781 1
			sk_MIME_HEADER_push(headers, mhdr);
d790 6
d909 4
a912 1
	sk_MIME_PARAM_push(mhdr->params, mparam);
@


1.22
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn_mime.c,v 1.21 2014/07/11 13:41:59 miod Exp $ */
d57 1
a62 1
#include <openssl/rand.h>
d301 1
a301 1
		RAND_pseudo_bytes((unsigned char *)bound, 32);
@


1.21
log
@More memory leaks and unchecked allocations; OpenSSL PR #3403 via OpenSSL
trunk. (note we had already fixed some of the issues in that PR independently)
@
text
@d1 1
a1 1
/* $OpenBSD: asn_mime.c,v 1.20 2014/07/11 08:44:47 jsing Exp $ */
d836 1
a836 1
		if (!(tmpname = BUF_strdup(name)))
d842 1
a842 1
		if (!(tmpval = BUF_strdup(value)))
d870 1
a870 1
		tmpname = BUF_strdup(name);
d877 1
a877 1
		tmpval = BUF_strdup(value);
@


1.20
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn_mime.c,v 1.19 2014/07/10 13:58:22 jsing Exp $ */
d678 2
@


1.19
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: asn_mime.c,v 1.18 2014/06/12 15:49:27 deraadt Exp $ */
d59 3
a61 1
#include "cryptlib.h"
d64 1
a64 2
#include <openssl/asn1.h>
#include <openssl/asn1t.h>
@


1.18
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d55 1
d57 2
a58 1
#include <ctype.h>
@


1.17
log
@There is no need for is{upper,lower}() tests before to{lower,uppper}(),
since all other characters are mapped through transparently.
ok jsing
@
text
@d1 1
a1 1
/* asn_mime.c */
@


1.16
log
@no need for null check before free. from Brendan MacDonell
@
text
@a828 1
	int c;
d833 2
a834 7
		for (p = tmpname; *p; p++) {
			c = (unsigned char)*p;
			if (isupper(c)) {
				c = tolower(c);
				*p = c;
			}
		}
d839 2
a840 7
		for (p = tmpval; *p; p++) {
			c = (unsigned char)*p;
			if (isupper(c)) {
				c = tolower(c);
				*p = c;
			}
		}
a861 1
	int c;
d868 2
a869 7
		for (p = tmpname; *p; p++) {
			c = (unsigned char)*p;
			if (isupper(c)) {
				c = tolower(c);
				*p = c;
			}
		}
@


1.15
log
@remove unused shit. from Alexander Schrijver
@
text
@d952 2
a953 4
	if (hdr->name)
		free(hdr->name);
	if (hdr->value)
		free(hdr->value);
d962 2
a963 4
	if (param->param_name)
		free(param->param_name);
	if (param->param_value)
		free(param->param_value);
@


1.14
log
@Fix memory leaks upon failure.
ok beck@@
@
text
@d1002 1
a1002 1
	p = linebuf + len - 1;
@


1.13
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d828 1
a828 1
	char *tmpname, *tmpval, *p;
d830 1
d833 1
a833 1
			return NULL;
d841 1
a841 2
	} else
		tmpname = NULL;
d844 1
a844 1
			return NULL;
a851 5
	} else tmpval = NULL;
		mhdr = malloc(sizeof(MIME_HEADER));
	if (!mhdr) {
		OPENSSL_free(tmpname);
		return NULL;
d853 3
d860 1
a860 1
		return NULL;
d863 4
d872 1
a872 1
	char *tmpname, *tmpval, *p;
d879 1
a879 1
			return 0;
d887 1
a887 2
	} else
		tmpname = NULL;
d891 2
a892 3
			return 0;
	} else
		tmpval = NULL;
d896 1
a896 1
		return 0;
d901 4
@


1.12
log
@improve realloc/calloc/malloc patterns; ok guenther
@
text
@d496 1
a496 1
			ERR_add_error_data(2, "type: ", hdr->value);
d523 1
a523 1
		ERR_add_error_data(2, "type: ", hdr->value);
d594 1
a594 1
		ERR_add_error_data(2, "type: ", hdr->value);
@


1.11
log
@More KNF.
@
text
@d853 1
a853 1
		mhdr = (MIME_HEADER *)malloc(sizeof(MIME_HEADER));
d894 1
a894 1
	mparam = (MIME_PARAM *) malloc(sizeof(MIME_PARAM));
@


1.10
log
@lob a few more knf grenades in here to soften things up.
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d74 2
a75 2
char *param_name;			/* Param name e.g. "micalg" */
char *param_value;			/* Param value e.g. "sha1" */
d82 3
a84 3
char *name;				/* Name of line e.g. "content-type" */
char *value;				/* Value of line e.g. "text/plain" */
STACK_OF(MIME_PARAM) *params;		/* Zero or more parameters */
d91 1
a91 1
					const ASN1_ITEM *it);
d99 1
a99 1
			const MIME_HEADER * const *b);
d101 1
a101 1
			const MIME_PARAM * const *b);
d115 3
a117 2
int i2d_ASN1_bio_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
				const ASN1_ITEM *it)
d124 2
a125 1
			ASN1err(ASN1_F_I2D_ASN1_BIO_STREAM,ERR_R_MALLOC_FAILURE);
d147 3
a149 2
static int B64_write_ASN1(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
				const ASN1_ITEM *it)
d153 1
d155 2
a156 2
	if(!b64) {
		ASN1err(ASN1_F_B64_WRITE_ASN1,ERR_R_MALLOC_FAILURE);
d171 3
a173 3
int PEM_write_bio_ASN1_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
				const char *hdr,
				const ASN1_ITEM *it)
d176 1
d183 2
a184 1
static ASN1_VALUE *b64_read_asn1(BIO *bio, const ASN1_ITEM *it)
d188 2
a189 2
	if(!(b64 = BIO_new(BIO_f_base64()))) {
		ASN1err(ASN1_F_B64_READ_ASN1,ERR_R_MALLOC_FAILURE);
d191 1
a191 1
}
d194 2
a195 2
	if(!val)
		ASN1err(ASN1_F_B64_READ_ASN1,ASN1_R_DECODE_ERROR);
d204 2
a205 1
static int asn1_write_micalg(BIO *out, STACK_OF(X509_ALGOR) *mdalgs)
d209 1
d230 2
a231 2
		switch(md_nid) {
			case NID_sha1:
d235 1
a235 1
			case NID_md5:
d239 1
a239 1
			case NID_sha256:
d243 1
a243 1
			case NID_sha384:
d247 1
a247 1
			case NID_sha512:
d251 1
a251 1
			case NID_id_GostR3411_94:
d253 1
a253 1
				goto err;
d256 1
a256 1
			default:
a268 1
	err:
d270 1
a271 1

d276 4
a279 4
int SMIME_write_ASN1(BIO *bio, ASN1_VALUE *val, BIO *data, int flags,
				int ctype_nid, int econt_nid,
				STACK_OF(X509_ALGOR) *mdalgs,
				const ASN1_ITEM *it)
d284 2
a285 1
	const char *msg_type=NULL;
d295 2
a296 2
	if((flags & SMIME_DETACHED) && data) {
	/* We want multipart/signed */
d299 1
a299 1
		for(i = 0; i < 32; i++) {
d301 4
a304 2
			if(c < 10) c += '0';
			else c += 'A' - 10;
d306 1
a306 1
	}
d314 1
a314 1
						bound, mime_eol, mime_eol);
d316 1
a316 1
						mime_eol, mime_eol);
d325 1
a325 1
		BIO_printf(bio, "Content-Type: %ssignature;", mime_prefix); 
d328 1
a328 1
								mime_eol);
d331 1
a331 1
							mime_eol, mime_eol);
d333 2
a334 2
		BIO_printf(bio,"%s------%s--%s%s", mime_eol, bound,
							mime_eol, mime_eol);
d336 1
a336 1
}
d362 1
a362 1
						mime_eol, mime_eol);
d372 3
a374 2
static int asn1_output_data(BIO *out, BIO *data, ASN1_VALUE *val, int flags,
					const ASN1_ITEM *it)
d391 1
a391 1
					ASN1_R_STREAMING_NOT_SUPPORTED);
a419 1

d427 2
a428 1
ASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)
d438 2
a439 1
	if(bcont) *bcont = NULL;
d442 1
a442 1
		ASN1err(ASN1_F_SMIME_READ_ASN1,ASN1_R_MIME_PARSE_ERROR);
d444 1
a444 1
}
d446 1
a446 1
	if(!(hdr = mime_hdr_find(headers, "content-type")) || !hdr->value) {
d450 1
a450 1
}
d454 1
a454 1
	if(!strcmp(hdr->value, "multipart/signed")) {
d457 1
a457 1
		if(!prm || !prm->param_value) {
d459 2
a460 1
			ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_MULTIPART_BOUNDARY);
d462 1
a462 1
	}
d465 3
a467 2
		if(!ret || (sk_BIO_num(parts) != 2) ) {
			ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_MULTIPART_BODY_FAILURE);
d470 1
a470 1
	}
d476 2
a477 1
			ASN1err(ASN1_F_SMIME_READ_ASN1,ASN1_R_MIME_SIG_PARSE_ERROR);
d480 1
a480 1
	}
d484 2
a485 2
		if(!(hdr = mime_hdr_find(headers, "content-type")) ||
								 !hdr->value) {
d487 2
a488 1
			ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_SIG_CONTENT_TYPE);
d490 1
a490 1
	}
d492 4
a495 3
		if(strcmp(hdr->value, "application/x-pkcs7-signature") &&
			strcmp(hdr->value, "application/pkcs7-signature")) {
			ASN1err(ASN1_F_SMIME_READ_ASN1,ASN1_R_SIG_INVALID_MIME_TYPE);
d500 1
a500 1
	}
d503 3
a505 2
		if(!(val = b64_read_asn1(asnin, it))) {
			ASN1err(ASN1_F_SMIME_READ_ASN1,ASN1_R_ASN1_SIG_PARSE_ERROR);
d508 1
a508 1
	}
d510 1
a510 1
		if(bcont) {
d514 4
a517 4
	} else sk_BIO_pop_free(parts, BIO_vfree);
		return val;
}
		
d522 1
a522 1
		ASN1err(ASN1_F_SMIME_READ_ASN1,ASN1_R_INVALID_MIME_TYPE);
d526 1
a526 1
}
d529 2
a530 2
	
	if(!(val = b64_read_asn1(bio, it))) {
d533 1
a533 1
}
a534 1

d538 2
a539 1
int SMIME_crlf_copy(BIO *in, BIO *out, int flags)
d545 1
d554 3
a556 3
	if(flags & SMIME_BINARY) {
		while((len = BIO_read(in, linebuf, MAX_SMLEN)) > 0)
						BIO_write(out, linebuf, len);
d558 1
a558 1
		if(flags & SMIME_TEXT)
d564 2
a565 1
			if(eol) BIO_write(out, "\r\n", 2);
d575 2
a576 1
int SMIME_text(BIO *in, BIO *out)
d584 1
a584 1
		ASN1err(ASN1_F_SMIME_TEXT,ASN1_R_MIME_PARSE_ERROR);
d586 3
a588 3
}
	if(!(hdr = mime_hdr_find(headers, "content-type")) || !hdr->value) {
		ASN1err(ASN1_F_SMIME_TEXT,ASN1_R_MIME_NO_CONTENT_TYPE);
d591 1
a591 1
}
d593 1
a593 1
		ASN1err(ASN1_F_SMIME_TEXT,ASN1_R_INVALID_MIME_TYPE);
d597 1
a597 1
}
d600 1
a600 1
						BIO_write(out, iobuf, len);
d610 2
a611 1
static int multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret)
d628 1
a628 1
		if(state == 1) {
d631 1
a631 1
	} else if(state == 2) {
d634 1
a634 1
	} else if(part) {
d637 1
a637 1
			if(first) {
d639 2
a640 1
				if(bpart) sk_BIO_push(parts, bpart);
d643 1
a643 1
		} else if (eol)
d648 1
a649 1
}
d664 2
a665 1
static STACK_OF(MIME_HEADER) *mime_parse_hdr(BIO *bio)
d676 6
a681 10
	/* If whitespace at line start then continuation line */
	if(mhdr && isspace((unsigned char)linebuf[0])) state = MIME_NAME;
	else state = MIME_START;
	ntmp = NULL;
	/* Go through all characters */
	for(p = linebuf, q = linebuf; (c = *p) && (c!='\r') && (c!='\n'); p++) {

	/* State machine to handle MIME headers
	 * if this looks horrible that's because it *is*
         */
d683 9
a691 1
		switch(state) {
d693 7
a699 7
			if(c == ':') {
				state = MIME_TYPE;
				*p = 0;
				ntmp = strip_ends(q);
				q = p + 1;
		}
			break;
d702 14
a715 13
			if(c == ';') {
				mime_debug("Found End Value\n");
				*p = 0;
				mhdr = mime_hdr_new(ntmp, strip_ends(q));
				sk_MIME_HEADER_push(headers, mhdr);
				ntmp = NULL;
				q = p + 1;
				state = MIME_NAME;
		} else if(c == '(') {
				save_state = state;
				state = MIME_COMMENT;
		}
			break;
d718 4
a721 4
			if(c == ')') {
				state = save_state;
		}
			break;
d724 7
a730 7
			if(c == '=') {
				state = MIME_VALUE;
				*p = 0;
				ntmp = strip_ends(q);
				q = p + 1;
		}
			break ;
d733 15
a747 14
			if(c == ';') {
				state = MIME_NAME;
				*p = 0;
				mime_hdr_addparam(mhdr, ntmp, strip_ends(q));
				ntmp = NULL;
				q = p + 1;
		} else if (c == '"') {
				mime_debug("Found Quote\n");
				state = MIME_QUOTE;
		} else if(c == '(') {
				save_state = state;
				state = MIME_COMMENT;
		}
			break;
d750 6
a755 3
			if(c == '"') {
				mime_debug("Found Match Quote\n");
				state = MIME_VALUE;
a756 3
			break;
	}
}
d758 5
a762 7
	if(state == MIME_TYPE) {
		mhdr = mime_hdr_new(ntmp, strip_ends(q));
		sk_MIME_HEADER_push(headers, mhdr);
} else if(state == MIME_VALUE)
			 mime_hdr_addparam(mhdr, ntmp, strip_ends(q));
	if(p == linebuf) break;	/* Blank line means end of headers */
}
d764 3
a766 1
return headers;
d768 1
d771 2
a772 1
static char *strip_ends(char *name)
d778 2
a779 1
static char *strip_start(char *name)
d782 1
d784 2
a785 2
	for(p = name; (c = *p) ;p++) {
		if(c == '"') {
d787 2
a788 1
			if(p[1]) return p + 1;
d791 3
a794 2
		if(!isspace((unsigned char)c)) return p;
}
d799 2
a800 1
static char *strip_end(char *name)
d803 4
a806 1
	if(!name) return NULL;
d808 1
a808 1
	for(p = name + strlen(name) - 1; p >= name ;p--) {
d810 3
a812 2
		if(c == '"') {
			if(p - 1 == name) return NULL;
d815 5
a820 3
		if(isspace((unsigned char)c)) *p = 0;	
		else return name;
}
d824 2
a825 1
static MIME_HEADER *mime_hdr_new(char *name, char *value)
d830 4
a833 3
	if(name) {
		if(!(tmpname = BUF_strdup(name))) return NULL;
		for(p = tmpname ; *p; p++) {
d835 1
a835 1
			if(isupper(c)) {
d838 1
d840 6
a845 5
	}
} else tmpname = NULL;
	if(value) {
		if(!(tmpval = BUF_strdup(value))) return NULL;
		for(p = tmpval ; *p; p++) {
d847 1
a847 1
			if(isupper(c)) {
d850 1
d852 2
a853 3
	}
} else tmpval = NULL;
	mhdr = (MIME_HEADER *) malloc(sizeof(MIME_HEADER));
d857 1
a857 1
}
d863 1
a863 1
}
d866 3
a868 2
		
static int mime_hdr_addparam(MIME_HEADER *mhdr, char *name, char *value)
d873 2
a874 1
	if(name) {
d876 3
a878 2
		if(!tmpname) return 0;
		for(p = tmpname ; *p; p++) {
d880 1
a880 1
			if(isupper(c)) {
d883 1
d885 3
a887 3
	}
} else tmpname = NULL;
	if(value) {
d889 4
a892 2
		if(!tmpval) return 0;
} else tmpval = NULL;
d895 2
a896 1
	if(!mparam) return 0;
d903 2
a904 2
static int mime_hdr_cmp(const MIME_HEADER * const *a,
			const MIME_HEADER * const *b)
d908 1
a908 2

	return(strcmp((*a)->name, (*b)->name));
d911 2
a912 2
static int mime_param_cmp(const MIME_PARAM * const *a,
			const MIME_PARAM * const *b)
d916 1
a916 1
	return(strcmp((*a)->param_name, (*b)->param_name));
d921 2
a922 1
static MIME_HEADER *mime_hdr_find(STACK_OF(MIME_HEADER) *hdrs, char *name)
d928 2
a929 1
	if(idx < 0) return NULL;
d933 2
a934 1
static MIME_PARAM *mime_param_find(MIME_HEADER *hdr, char *name)
d940 2
a941 1
	if(idx < 0) return NULL;
d945 2
a946 1
static void mime_hdr_free(MIME_HEADER *hdr)
d948 6
a953 3
	if(hdr->name) free(hdr->name);
	if(hdr->value) free(hdr->value);
	if(hdr->params) sk_MIME_PARAM_pop_free(hdr->params, mime_param_free);
d957 2
a958 1
static void mime_param_free(MIME_PARAM *param)
d960 4
a963 2
	if(param->param_name) free(param->param_name);
	if(param->param_value) free(param->param_value);
d972 2
a973 1
static int mime_bound_check(char *line, int linelen, char *bound, int blen)
d975 4
a978 2
	if(linelen == -1) linelen = strlen(line);
	if(blen == -1) blen = strlen(bound);
d980 2
a981 1
	if(blen + 2 > linelen) return 0;
d983 6
a988 4
	if(!strncmp(line, "--", 2) && !strncmp(line + 2, bound, blen)) {
		if(!strncmp(line + blen + 2, "--", 2)) return 2;
		else return 1;
}
d992 2
a993 1
static int strip_eol(char *linebuf, int *plen)
@


1.9
log
@putting most of the braces in the right column is the very least we can do.
@
text
@d119 1
a119 2
	if (flags & SMIME_STREAM)
	{
d122 1
a122 2
		if (!bio)
		{
d129 1
a129 2
		do
		{
d151 1
a151 2
	if(!b64)
	{
d204 1
a204 2
	for (i = 0; i < sk_X509_ALGOR_num(mdalgs); i++)
	{
d210 1
a210 2
		if (md && md->md_ctrl)
		{
d214 1
a214 2
			if (rv > 0)
			{
d222 1
a222 2
		switch(md_nid)
		{
d251 1
a251 2
			else
			{
d332 1
a332 2
	else if (ctype_nid == NID_pkcs7_signed)
	{
d339 1
a339 3
	}
	else if (ctype_nid == NID_id_smime_ct_compressedData)
	{
d373 1
a373 2
	if (!(flags & SMIME_DETACHED) || (flags & PKCS7_REUSE_DIGEST))
	{
d378 1
a378 2
	if (!aux || !aux->asn1_cb)
	{
d402 1
a402 2
	while (sarg.ndef_bio != out)
	{
d535 1
a535 2
	if(flags & SMIME_BINARY)
	{
d538 1
a538 3
	}
	else
	{
d541 1
a541 2
		while ((len = BIO_gets(in, linebuf, MAX_SMLEN)) > 0)
		{
d928 1
a928 2
	for (p = linebuf + len - 1; len > 0; len--, p--)
	{
@


1.8
log
@fix some more leaks, mostly suggestions from miod
ok miod@@
@
text
@d117 1
a117 1
	{
d120 1
a120 1
		{
d124 1
a124 1
			{
d127 1
a127 1
			}
d132 1
a132 1
			{
d136 2
a137 2
			} while (bio != out);
		}
d144 1
a144 1
	}
d150 1
a150 1
	{
d155 1
a155 1
		{
d158 1
a158 1
		}
d167 1
a167 1
	}
d174 1
a174 1
	{
d180 1
a180 1
	}
d189 1
a189 1
	}
d203 1
a203 1
	{
d209 1
a209 1
		{
d216 1
a216 1
			{
d221 1
a221 1
				{
d225 1
a225 1
				}
d228 1
a228 1
			}
d230 1
a230 1
			{
d260 1
a260 1
				{
d263 1
a263 1
				}
a265 1
			}
d267 1
d274 1
a274 1
	}
d305 1
a305 1
		}
d335 1
a335 1
	}
d342 1
a342 1
		{
d349 1
a349 1
		}
d351 1
a351 1
		{
d354 1
a354 1
		}
d376 1
a376 1
	{
d386 1
a386 1
		{
d389 1
a389 1
		}
d392 1
a392 1
		{
d396 1
a396 1
		}
d417 1
a417 1
		{
d421 1
a421 1
		}
d425 1
a425 1
	}
d447 1
a447 1
	}
d453 1
a453 1
	}
d464 1
a464 1
		}
d471 1
a471 1
		}
d480 1
a480 1
		}
d489 1
a489 1
		}
d498 1
a498 1
		}
d505 1
a505 1
		}
d511 1
a511 1
		} else sk_BIO_pop_free(parts, BIO_vfree);
d513 1
a513 1
	}
d523 1
a523 1
	}
d530 1
a530 1
	}
d551 1
a551 1
		{
d554 1
a554 1
		}
d556 1
a556 1
		{
d560 1
a560 1
			{
a564 1
			}
d566 1
d584 1
a584 1
	}
d589 1
a589 1
	}
d595 1
a595 1
	}
d628 1
a628 1
		} else if(state == 2) {
d631 1
a631 1
		} else if(part) {
d639 1
a639 1
			} else if (eol)
a643 1
		}
d645 1
d689 1
a689 1
			}
d701 1
a701 1
			} else if(c == '(') {
d704 1
a704 1
			}
d710 1
a710 1
			}
d719 1
a719 1
			}
d729 1
a729 1
			} else if (c == '"') {
d732 1
a732 1
			} else if(c == '(') {
d735 1
a735 1
			}
d742 1
a742 1
			}
a743 1
		}
d745 1
d750 1
a750 1
	} else if(state == MIME_VALUE)
d775 1
a775 1
		}
d777 1
a777 1
	}
d793 1
a793 1
		}
d796 1
a796 1
	}
a811 1
			}
d813 2
a814 1
	} else tmpname = NULL;
a821 1
			}
d823 2
a824 1
	} else tmpval = NULL;
d829 1
a829 1
	}
d835 1
a835 1
	}
a851 1
			}
d853 2
a854 1
	} else tmpname = NULL;
d858 1
a858 1
	} else tmpval = NULL;
d937 1
a937 1
	}
d942 1
a942 1
	{
d948 1
a948 1
		{
d954 1
a954 1
		}
d957 1
a957 1
	}
@


1.7
log
@fix some of the leaks
ok miod@@ looks good deraadt@@
@
text
@d826 2
a827 1
	if (!mhdr)
d829 1
@


1.6
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d826 2
a827 1
	if(!mhdr) return NULL;
d830 4
a833 1
	if(!(mhdr->params = sk_MIME_PARAM_new(mime_param_cmp))) return NULL;
@


1.5
log
@resolve conflicts
@
text
@d223 1
a223 1
				OPENSSL_free(micstr);
d825 1
a825 1
	mhdr = (MIME_HEADER *) OPENSSL_malloc(sizeof(MIME_HEADER));
d854 1
a854 1
	mparam = (MIME_PARAM *) OPENSSL_malloc(sizeof(MIME_PARAM));
d903 2
a904 2
	if(hdr->name) OPENSSL_free(hdr->name);
	if(hdr->value) OPENSSL_free(hdr->value);
d906 1
a906 1
	OPENSSL_free(hdr);
d911 3
a913 3
	if(param->param_name) OPENSSL_free(param->param_name);
	if(param->param_value) OPENSSL_free(param->param_value);
	OPENSSL_free(param);
@


1.4
log
@resolve conflicts, fix local changes
@
text
@d380 1
d382 4
a385 1
	if (!(flags & SMIME_DETACHED))
d412 1
a412 1
		return 0;
d423 1
a423 1
	return 1;
a492 1
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d495 1
d808 1
a808 1
			c = *p;
d818 1
a818 1
			c = *p;
d842 1
a842 1
			c = *p;
d865 3
d874 2
@


1.3
log
@resolve conflicts
@
text
@d62 1
d90 2
d113 33
d162 1
a162 1
	r = ASN1_item_i2d_bio(it, out, val);
d169 13
d204 2
a205 1
	int i, have_unknown = 0, write_comma, md_nid;
d214 15
d251 5
d269 4
a272 1
	return 1;
d278 1
a278 1
int int_smime_write_ASN1(BIO *bio, ASN1_VALUE *val, BIO *data, int flags,
a280 1
				asn1_output_data_fn *data_fn,
d318 1
a318 1
		if (!data_fn(bio, data, val, flags, it))
a370 2
#if 0

a421 2

#endif
@


1.2
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@a154 1
	const EVP_MD *md;
a163 1
		md = EVP_get_digestbynid(md_nid);
@


1.1
log
@Initial revision
@
text
@d529 2
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@a528 2
	if (len < 0)
		return 0;
@


1.1.1.3
log
@import of OpenSSL 0.9.8k
@
text
@d155 1
d165 1
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@a61 1
#include "asn1_locl.h"
a88 2
static int asn1_output_data(BIO *out, BIO *data, ASN1_VALUE *val, int flags,
					const ASN1_ITEM *it);
a109 33
/* Output an ASN1 structure in BER format streaming if necessary */

int i2d_ASN1_bio_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
				const ASN1_ITEM *it)
	{
	/* If streaming create stream BIO and copy all content through it */
	if (flags & SMIME_STREAM)
		{
		BIO *bio, *tbio;
		bio = BIO_new_NDEF(out, val, it);
		if (!bio)
			{
			ASN1err(ASN1_F_I2D_ASN1_BIO_STREAM,ERR_R_MALLOC_FAILURE);
			return 0;
			}
		SMIME_crlf_copy(in, bio, flags);
		(void)BIO_flush(bio);
		/* Free up successive BIOs until we hit the old output BIO */
		do
			{
			tbio = BIO_pop(bio);
			BIO_free(bio);
			bio = tbio;
			} while (bio != out);
		}
	/* else just write out ASN1 structure which will have all content
	 * stored internally
	 */
	else
		ASN1_item_i2d_bio(it, out, val);
	return 1;
	}

d126 1
a126 1
	r = i2d_ASN1_bio_stream(out, val, in, flags, it);
a132 13
/* Streaming ASN1 PEM write */

int PEM_write_bio_ASN1_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
				const char *hdr,
				const ASN1_ITEM *it)
	{
	int r;
	BIO_printf(out, "-----BEGIN %s-----\n", hdr);
	r = B64_write_ASN1(out, val, in, flags, it);
	BIO_printf(out, "-----END %s-----\n", hdr);
	return r;
	}

d155 1
a155 2
	const EVP_MD *md;
	int i, have_unknown = 0, write_comma, ret = 0, md_nid;
a163 15
		md = EVP_get_digestbynid(md_nid);
		if (md && md->md_ctrl)
			{
			int rv;
			char *micstr;
			rv = md->md_ctrl(NULL, EVP_MD_CTRL_MICALG, 0, &micstr);
			if (rv > 0)
				{
				BIO_puts(out, micstr);
				OPENSSL_free(micstr);
				continue;
				}
			if (rv != -2)
				goto err;
			}
a185 5
			case NID_id_GostR3411_94:
			BIO_puts(out, "gostr3411-94");
				goto err;
			break;

d199 1
a199 4
	ret = 1;
	err:

	return ret;
d205 1
a205 1
int SMIME_write_ASN1(BIO *bio, ASN1_VALUE *val, BIO *data, int flags,
d208 1
d246 1
a246 1
		if (!asn1_output_data(bio, data, val, flags, it))
d299 2
d352 2
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@a379 1
	int rv = 1;
d381 1
a381 4
	/* If data is not deteched or resigning then the output BIO is
	 * already set up to finalise when it is written through.
	 */
	if (!(flags & SMIME_DETACHED) || (flags & PKCS7_REUSE_DIGEST))
d408 1
a408 1
		rv = 0;
d419 1
a419 1
	return rv;
d489 1
a491 1
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d804 1
a804 1
			c = (unsigned char)*p;
d814 1
a814 1
			c = (unsigned char)*p;
d838 1
a838 1
			c = (unsigned char)*p;
a860 3
	if (!(*a)->name || !(*b)->name)
		return !!(*a)->name - !!(*b)->name;

a866 2
	if (!(*a)->param_name || !(*b)->param_name)
		return !!(*a)->param_name - !!(*b)->param_name;
@


