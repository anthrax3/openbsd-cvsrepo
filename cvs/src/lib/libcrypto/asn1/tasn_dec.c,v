head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.2
	OPENBSD_6_1_BASE:1.34;
locks; strict;
comment	@ * @;


1.34
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.33;
commitid	kT0fLt3r4lroFJra;

1.33
date	2016.12.30.16.04.34;	author jsing;	state Exp;
branches;
next	1.32;
commitid	Gs5oxnpdEYq1UpKL;

1.32
date	2016.05.04.15.00.24;	author tedu;	state Exp;
branches;
next	1.31;
commitid	s4NE9FX4wus4Piaj;

1.31
date	2016.05.04.14.53.29;	author tedu;	state Exp;
branches;
next	1.30;
commitid	dp2wUlmUxyODyIfQ;

1.30
date	2016.05.03.12.38.53;	author tedu;	state Exp;
branches;
next	1.29;
commitid	0ClIPo2LiLW7bSvG;

1.29
date	2015.12.12.21.05.11;	author beck;	state Exp;
branches
	1.29.2.1;
next	1.28;
commitid	Y2HbFH1bfMa51S45;

1.28
date	2015.12.04.04.19.25;	author beck;	state Exp;
branches;
next	1.27;
commitid	Px5RE05vAlEZcwrp;

1.27
date	2015.07.20.15.41.48;	author miod;	state Exp;
branches
	1.27.4.1;
next	1.26;
commitid	eQlIJuW9w6GrHYVc;

1.26
date	2015.03.19.14.00.22;	author tedu;	state Exp;
branches;
next	1.25;
commitid	Ix1rLPv61p1TR5LF;

1.25
date	2015.02.14.15.23.57;	author miod;	state Exp;
branches
	1.25.4.1;
next	1.24;
commitid	peVibfevZfgr8DNB;

1.24
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches
	1.24.4.1;
next	1.23;
commitid	mJUVYpkFBZ0Zv2bG;

1.23
date	2014.05.30.02.52.11;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.05.04.19.06.40;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.26.18.56.37;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.19.17.40.49;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.19.16.12.39;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.18.16.11.22;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.18.15.03.20;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.18.14.34.07;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.18.12.15.48;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.18.00.58.49;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.18.00.10.08;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.09.12.15.27;	author djm;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.04.07.10.32;	author pvalchev;	state Exp;
branches
	1.6.6.1
	1.6.8.1;
next	1.5;

1.5
date	2006.06.27.05.07.00;	author djm;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.09.30.15.19.38;	author markus;	state Exp;
branches
	1.4.8.1
	1.4.10.1;
next	1.3;

1.3
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.49;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.12.20.44.17;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.35;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.11.21.12.07;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.06.27.05.05.30;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.40;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.01.09.12.13.51;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.04.06.06.30.01;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.03;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.08;	author djm;	state Exp;
branches;
next	;

1.2.2.1
date	2003.10.01.22.46.19;	author brad;	state Exp;
branches;
next	;

1.2.4.1
date	2003.10.01.15.58.03;	author margarida;	state Exp;
branches;
next	;

1.3.2.1
date	2003.10.31.00.13.15;	author brad;	state Exp;
branches;
next	;

1.4.8.1
date	2006.10.05.18.42.22;	author brad;	state Exp;
branches;
next	;

1.4.10.1
date	2006.10.05.17.36.24;	author brad;	state Exp;
branches;
next	;

1.5.2.1
date	2006.11.02.19.56.23;	author brad;	state Exp;
branches;
next	;

1.6.6.1
date	2009.04.08.02.30.01;	author djm;	state Exp;
branches;
next	;

1.6.8.1
date	2009.04.08.02.30.16;	author djm;	state Exp;
branches;
next	;

1.8.2.1
date	2009.04.08.02.30.30;	author djm;	state Exp;
branches;
next	;

1.24.4.1
date	2015.03.19.14.02.22;	author tedu;	state Exp;
branches;
next	;
commitid	bYTbbXa7PWk8y7To;

1.25.4.1
date	2015.03.19.14.01.15;	author tedu;	state Exp;
branches;
next	1.25.4.2;
commitid	dQgHc1qjfDF6g1rY;

1.25.4.2
date	2015.12.04.04.22.24;	author beck;	state Exp;
branches;
next	;
commitid	ZVglRJakFne9YJ2W;

1.27.4.1
date	2015.12.04.04.21.36;	author beck;	state Exp;
branches;
next	1.27.4.2;
commitid	u7syVc7fULpN4VfA;

1.27.4.2
date	2016.05.03.12.39.23;	author tedu;	state Exp;
branches;
next	;
commitid	5iHrqqr5iZFurKzX;

1.29.2.1
date	2016.05.03.12.39.48;	author tedu;	state Exp;
branches;
next	;
commitid	Ekna9eOpYJ6UbVcF;


desc
@@


1.34
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: tasn_dec.c,v 1.33 2016/12/30 16:04:34 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */


#include <stddef.h>
#include <string.h>
#include <openssl/asn1.h>
#include <openssl/asn1t.h>
#include <openssl/objects.h>
#include <openssl/buffer.h>
#include <openssl/err.h>

static int asn1_check_eoc(const unsigned char **in, long len);
static int asn1_find_end(const unsigned char **in, long len, char inf);

static int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,
    char inf, int tag, int aclass, int depth);

static int collect_data(BUF_MEM *buf, const unsigned char **p, long plen);

static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
    char *inf, char *cst, const unsigned char **in, long len, int exptag,
    int expclass, char opt, ASN1_TLC *ctx);

static int asn1_template_ex_d2i(ASN1_VALUE **pval, const unsigned char **in,
    long len, const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx);
static int asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in,
    long len, const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx);
static int asn1_d2i_ex_primitive(ASN1_VALUE **pval, const unsigned char **in,
    long len, const ASN1_ITEM *it, int tag, int aclass, char opt,
    ASN1_TLC *ctx);

/* Table to convert tags to bit values, used for MSTRING type */
static const unsigned long tag2bit[32] = {
	0,	0,	0,	B_ASN1_BIT_STRING,	/* tags  0 -  3 */
	B_ASN1_OCTET_STRING,	0,	0,		B_ASN1_UNKNOWN,/* tags  4- 7 */
	B_ASN1_UNKNOWN,	B_ASN1_UNKNOWN,	B_ASN1_UNKNOWN,	B_ASN1_UNKNOWN,/* tags  8-11 */
	B_ASN1_UTF8STRING,B_ASN1_UNKNOWN,B_ASN1_UNKNOWN,B_ASN1_UNKNOWN,/* tags 12-15 */
	B_ASN1_SEQUENCE,0,B_ASN1_NUMERICSTRING,B_ASN1_PRINTABLESTRING, /* tags 16-19 */
	B_ASN1_T61STRING,B_ASN1_VIDEOTEXSTRING,B_ASN1_IA5STRING,       /* tags 20-22 */
	B_ASN1_UTCTIME, B_ASN1_GENERALIZEDTIME,			       /* tags 23-24 */
	B_ASN1_GRAPHICSTRING,B_ASN1_ISO64STRING,B_ASN1_GENERALSTRING,  /* tags 25-27 */
	B_ASN1_UNIVERSALSTRING,B_ASN1_UNKNOWN,B_ASN1_BMPSTRING,B_ASN1_UNKNOWN, /* tags 28-31 */
};

unsigned long
ASN1_tag2bit(int tag)
{
	if ((tag < 0) || (tag > 30))
		return 0;
	return tag2bit[tag];
}

/* Macro to initialize and invalidate the cache */

#define asn1_tlc_clear(c)	if (c) (c)->valid = 0
/* Version to avoid compiler warning about 'c' always non-NULL */
#define asn1_tlc_clear_nc(c)	(c)->valid = 0

/* Decode an ASN1 item, this currently behaves just
 * like a standard 'd2i' function. 'in' points to
 * a buffer to read the data from, in future we will
 * have more advanced versions that can input data
 * a piece at a time and this will simply be a special
 * case.
 */

ASN1_VALUE *
ASN1_item_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
    const ASN1_ITEM *it)
{
	ASN1_TLC c;
	ASN1_VALUE *ptmpval = NULL;

	if (!pval)
		pval = &ptmpval;
	asn1_tlc_clear_nc(&c);
	if (ASN1_item_ex_d2i(pval, in, len, it, -1, 0, 0, &c) > 0)
		return *pval;
	return NULL;
}

int
ASN1_template_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
    const ASN1_TEMPLATE *tt)
{
	ASN1_TLC c;

	asn1_tlc_clear_nc(&c);
	return asn1_template_ex_d2i(pval, in, len, tt, 0, &c);
}


/* Decode an item, taking care of IMPLICIT tagging, if any.
 * If 'opt' set and tag mismatch return -1 to handle OPTIONAL
 */

int
ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
    const ASN1_ITEM *it, int tag, int aclass, char opt, ASN1_TLC *ctx)
{
	const ASN1_TEMPLATE *tt, *errtt = NULL;
	const ASN1_EXTERN_FUNCS *ef;
	const ASN1_AUX *aux = it->funcs;
	ASN1_aux_cb *asn1_cb;
	const unsigned char *p = NULL, *q;
	unsigned char oclass;
	char seq_eoc, seq_nolen, cst, isopt;
	long tmplen;
	int i;
	int otag;
	int ret = 0;
	ASN1_VALUE **pchptr;
	int combine;

	combine = aclass & ASN1_TFLG_COMBINE;
	aclass &= ~ASN1_TFLG_COMBINE;

	if (!pval)
		return 0;

	if (aux && aux->asn1_cb)
		asn1_cb = aux->asn1_cb;
	else
		asn1_cb = 0;

	switch (it->itype) {
	case ASN1_ITYPE_PRIMITIVE:
		if (it->templates) {
			/* tagging or OPTIONAL is currently illegal on an item
			 * template because the flags can't get passed down.
			 * In practice this isn't a problem: we include the
			 * relevant flags from the item template in the
			 * template itself.
			 */
			if ((tag != -1) || opt) {
				ASN1error(ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
				goto err;
			}
			return asn1_template_ex_d2i(pval, in, len,
			    it->templates, opt, ctx);
		}
		return asn1_d2i_ex_primitive(pval, in, len, it,
		    tag, aclass, opt, ctx);
		break;

	case ASN1_ITYPE_MSTRING:
		p = *in;
		/* Just read in tag and class */
		ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
		    &p, len, -1, 0, 1, ctx);
		if (!ret) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}

		/* Must be UNIVERSAL class */
		if (oclass != V_ASN1_UNIVERSAL) {
			/* If OPTIONAL, assume this is OK */
			if (opt)
				return -1;
			ASN1error(ASN1_R_MSTRING_NOT_UNIVERSAL);
			goto err;
		}
		/* Check tag matches bit map */
		if (!(ASN1_tag2bit(otag) & it->utype)) {
			/* If OPTIONAL, assume this is OK */
			if (opt)
				return -1;
			ASN1error(ASN1_R_MSTRING_WRONG_TAG);
			goto err;
		}
		return asn1_d2i_ex_primitive(pval, in, len,
		    it, otag, 0, 0, ctx);

	case ASN1_ITYPE_EXTERN:
		/* Use new style d2i */
		ef = it->funcs;
		return ef->asn1_ex_d2i(pval, in, len,
		    it, tag, aclass, opt, ctx);

	case ASN1_ITYPE_CHOICE:
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
			goto auxerr;

		if (*pval) {
			/* Free up and zero CHOICE value if initialised */
			i = asn1_get_choice_selector(pval, it);
			if ((i >= 0) && (i < it->tcount)) {
				tt = it->templates + i;
				pchptr = asn1_get_field_ptr(pval, tt);
				ASN1_template_free(pchptr, tt);
				asn1_set_choice_selector(pval, -1, it);
			}
		} else if (!ASN1_item_ex_new(pval, it)) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}
		/* CHOICE type, try each possibility in turn */
		p = *in;
		for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
			pchptr = asn1_get_field_ptr(pval, tt);
			/* We mark field as OPTIONAL so its absence
			 * can be recognised.
			 */
			ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
			/* If field not present, try the next one */
			if (ret == -1)
				continue;
			/* If positive return, read OK, break loop */
			if (ret > 0)
				break;
			/* Otherwise must be an ASN1 parsing error */
			errtt = tt;
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}

		/* Did we fall off the end without reading anything? */
		if (i == it->tcount) {
			/* If OPTIONAL, this is OK */
			if (opt) {
				/* Free and zero it */
				ASN1_item_ex_free(pval, it);
				return -1;
			}
			ASN1error(ASN1_R_NO_MATCHING_CHOICE_TYPE);
			goto err;
		}

		asn1_set_choice_selector(pval, i, it);
		*in = p;
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
			goto auxerr;
		return 1;

	case ASN1_ITYPE_NDEF_SEQUENCE:
	case ASN1_ITYPE_SEQUENCE:
		p = *in;
		tmplen = len;

		/* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
		if (tag == -1) {
			tag = V_ASN1_SEQUENCE;
			aclass = V_ASN1_UNIVERSAL;
		}
		/* Get SEQUENCE length and update len, p */
		ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
		    &p, len, tag, aclass, opt, ctx);
		if (!ret) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			goto err;
		} else if (ret == -1)
			return -1;
		if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
			len = tmplen - (p - *in);
			seq_nolen = 1;
		}
		/* If indefinite we don't do a length check */
		else
			seq_nolen = seq_eoc;
		if (!cst) {
			ASN1error(ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
			goto err;
		}

		if (!*pval && !ASN1_item_ex_new(pval, it)) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			goto err;
		}

		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
			goto auxerr;

		/* Free up and zero any ADB found */
		for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
			if (tt->flags & ASN1_TFLG_ADB_MASK) {
				const ASN1_TEMPLATE *seqtt;
				ASN1_VALUE **pseqval;
				seqtt = asn1_do_adb(pval, tt, 1);
				if (!seqtt)
					goto err;
				pseqval = asn1_get_field_ptr(pval, seqtt);
				ASN1_template_free(pseqval, seqtt);
			}
		}

		/* Get each field entry */
		for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
			const ASN1_TEMPLATE *seqtt;
			ASN1_VALUE **pseqval;
			seqtt = asn1_do_adb(pval, tt, 1);
			if (!seqtt)
				goto err;
			pseqval = asn1_get_field_ptr(pval, seqtt);
			/* Have we ran out of data? */
			if (!len)
				break;
			q = p;
			if (asn1_check_eoc(&p, len)) {
				if (!seq_eoc) {
					ASN1error(ASN1_R_UNEXPECTED_EOC);
					goto err;
				}
				len -= p - q;
				seq_eoc = 0;
				q = p;
				break;
			}
			/* This determines the OPTIONAL flag value. The field
			 * cannot be omitted if it is the last of a SEQUENCE
			 * and there is still data to be read. This isn't
			 * strictly necessary but it increases efficiency in
			 * some cases.
			 */
			if (i == (it->tcount - 1))
				isopt = 0;
			else
				isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
			/* attempt to read in field, allowing each to be
			 * OPTIONAL */

			ret = asn1_template_ex_d2i(pseqval, &p, len,
			    seqtt, isopt, ctx);
			if (!ret) {
				errtt = seqtt;
				goto err;
			} else if (ret == -1) {
				/* OPTIONAL component absent.
				 * Free and zero the field.
				 */
				ASN1_template_free(pseqval, seqtt);
				continue;
			}
			/* Update length */
			len -= p - q;
		}

		/* Check for EOC if expecting one */
		if (seq_eoc && !asn1_check_eoc(&p, len)) {
			ASN1error(ASN1_R_MISSING_EOC);
			goto err;
		}
		/* Check all data read */
		if (!seq_nolen && len) {
			ASN1error(ASN1_R_SEQUENCE_LENGTH_MISMATCH);
			goto err;
		}

		/* If we get here we've got no more data in the SEQUENCE,
		 * however we may not have read all fields so check all
		 * remaining are OPTIONAL and clear any that are.
		 */
		for (; i < it->tcount; tt++, i++) {
			const ASN1_TEMPLATE *seqtt;
			seqtt = asn1_do_adb(pval, tt, 1);
			if (!seqtt)
				goto err;
			if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
				ASN1_VALUE **pseqval;
				pseqval = asn1_get_field_ptr(pval, seqtt);
				ASN1_template_free(pseqval, seqtt);
			} else {
				errtt = seqtt;
				ASN1error(ASN1_R_FIELD_MISSING);
				goto err;
			}
		}
		/* Save encoding */
		if (!asn1_enc_save(pval, *in, p - *in, it)) {
			ASN1error(ERR_R_MALLOC_FAILURE);
			goto auxerr;
		}
		*in = p;
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
			goto auxerr;
		return 1;

	default:
		return 0;
	}

auxerr:
	ASN1error(ASN1_R_AUX_ERROR);
err:
	if (combine == 0)
		ASN1_item_ex_free(pval, it);
	if (errtt)
		ERR_asprintf_error_data("Field=%s, Type=%s", errtt->field_name,
		    it->sname);
	else
		ERR_asprintf_error_data("Type=%s", it->sname);
	return 0;
}

/* Templates are handled with two separate functions.
 * One handles any EXPLICIT tag and the other handles the rest.
 */

static int
asn1_template_ex_d2i(ASN1_VALUE **val, const unsigned char **in, long inlen,
    const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx)
{
	int flags, aclass;
	int ret;
	long len;
	const unsigned char *p, *q;
	char exp_eoc;

	if (!val)
		return 0;
	flags = tt->flags;
	aclass = flags & ASN1_TFLG_TAG_CLASS;

	p = *in;

	/* Check if EXPLICIT tag expected */
	if (flags & ASN1_TFLG_EXPTAG) {
		char cst;
		/* Need to work out amount of data available to the inner
		 * content and where it starts: so read in EXPLICIT header to
		 * get the info.
		 */
		ret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst,
		    &p, inlen, tt->tag, aclass, opt, ctx);
		q = p;
		if (!ret) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			return 0;
		} else if (ret == -1)
			return -1;
		if (!cst) {
			ASN1error(ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
			return 0;
		}
		/* We've found the field so it can't be OPTIONAL now */
		ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx);
		if (!ret) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			return 0;
		}
		/* We read the field in OK so update length */
		len -= p - q;
		if (exp_eoc) {
			/* If NDEF we must have an EOC here */
			if (!asn1_check_eoc(&p, len)) {
				ASN1error(ASN1_R_MISSING_EOC);
				goto err;
			}
		} else {
			/* Otherwise we must hit the EXPLICIT tag end or its
			 * an error */
			if (len) {
				ASN1error(ASN1_R_EXPLICIT_LENGTH_MISMATCH);
				goto err;
			}
		}
	} else
		return asn1_template_noexp_d2i(val, in, inlen, tt, opt, ctx);

	*in = p;
	return 1;

err:
	ASN1_template_free(val, tt);
	return 0;
}

static int
asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in, long len,
    const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx)
{
	int flags, aclass;
	int ret;
	const unsigned char *p, *q;

	if (!val)
		return 0;
	flags = tt->flags;
	aclass = flags & ASN1_TFLG_TAG_CLASS;

	p = *in;
	q = p;

	if (flags & ASN1_TFLG_SK_MASK) {
		/* SET OF, SEQUENCE OF */
		int sktag, skaclass;
		char sk_eoc;
		/* First work out expected inner tag value */
		if (flags & ASN1_TFLG_IMPTAG) {
			sktag = tt->tag;
			skaclass = aclass;
		} else {
			skaclass = V_ASN1_UNIVERSAL;
			if (flags & ASN1_TFLG_SET_OF)
				sktag = V_ASN1_SET;
			else
				sktag = V_ASN1_SEQUENCE;
		}
		/* Get the tag */
		ret = asn1_check_tlen(&len, NULL, NULL, &sk_eoc, NULL,
		    &p, len, sktag, skaclass, opt, ctx);
		if (!ret) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			return 0;
		} else if (ret == -1)
			return -1;
		if (!*val)
			*val = (ASN1_VALUE *)sk_new_null();
		else {
			/* We've got a valid STACK: free up any items present */
			STACK_OF(ASN1_VALUE) *sktmp =
			    (STACK_OF(ASN1_VALUE) *)*val;
			ASN1_VALUE *vtmp;
			while (sk_ASN1_VALUE_num(sktmp) > 0) {
				vtmp = sk_ASN1_VALUE_pop(sktmp);
				ASN1_item_ex_free(&vtmp,
				    tt->item);
			}
		}

		if (!*val) {
			ASN1error(ERR_R_MALLOC_FAILURE);
			goto err;
		}

		/* Read as many items as we can */
		while (len > 0) {
			ASN1_VALUE *skfield;
			q = p;
			/* See if EOC found */
			if (asn1_check_eoc(&p, len)) {
				if (!sk_eoc) {
					ASN1error(ASN1_R_UNEXPECTED_EOC);
					goto err;
				}
				len -= p - q;
				sk_eoc = 0;
				break;
			}
			skfield = NULL;
			if (!ASN1_item_ex_d2i(&skfield, &p, len,
			    tt->item, -1, 0, 0, ctx)) {
				ASN1error(ERR_R_NESTED_ASN1_ERROR);
				goto err;
			}
			len -= p - q;
			if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val,
			    skfield)) {
				ASN1error(ERR_R_MALLOC_FAILURE);
				goto err;
			}
		}
		if (sk_eoc) {
			ASN1error(ASN1_R_MISSING_EOC);
			goto err;
		}
	} else if (flags & ASN1_TFLG_IMPTAG) {
		/* IMPLICIT tagging */
		ret = ASN1_item_ex_d2i(val, &p, len,
		    tt->item, tt->tag, aclass, opt, ctx);
		if (!ret) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			goto err;
		} else if (ret == -1)
			return -1;
	} else {
		/* Nothing special */
		ret = ASN1_item_ex_d2i(val, &p, len, tt->item,
		    -1, tt->flags & ASN1_TFLG_COMBINE, opt, ctx);
		if (!ret) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			goto err;
		} else if (ret == -1)
			return -1;
	}

	*in = p;
	return 1;

err:
	ASN1_template_free(val, tt);
	return 0;
}

static int
asn1_d2i_ex_primitive(ASN1_VALUE **pval, const unsigned char **in, long inlen,
    const ASN1_ITEM *it, int tag, int aclass, char opt, ASN1_TLC *ctx)
{
	int ret = 0, utype;
	long plen;
	char cst, inf, free_cont = 0;
	const unsigned char *p;
	BUF_MEM buf;
	const unsigned char *cont = NULL;
	long len;

	buf.length = 0;
	buf.max = 0;
	buf.data = NULL;

	if (!pval) {
		ASN1error(ASN1_R_ILLEGAL_NULL);
		return 0; /* Should never happen */
	}

	if (it->itype == ASN1_ITYPE_MSTRING) {
		utype = tag;
		tag = -1;
	} else
		utype = it->utype;

	if (utype == V_ASN1_ANY) {
		/* If type is ANY need to figure out type from tag */
		unsigned char oclass;
		if (tag >= 0) {
			ASN1error(ASN1_R_ILLEGAL_TAGGED_ANY);
			return 0;
		}
		if (opt) {
			ASN1error(ASN1_R_ILLEGAL_OPTIONAL_ANY);
			return 0;
		}
		p = *in;
		ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, NULL,
		    &p, inlen, -1, 0, 0, ctx);
		if (!ret) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			return 0;
		}
		if (oclass != V_ASN1_UNIVERSAL)
			utype = V_ASN1_OTHER;
	}
	if (tag == -1) {
		tag = utype;
		aclass = V_ASN1_UNIVERSAL;
	}
	p = *in;
	/* Check header */
	ret = asn1_check_tlen(&plen, NULL, NULL, &inf, &cst,
	    &p, inlen, tag, aclass, opt, ctx);
	if (!ret) {
		ASN1error(ERR_R_NESTED_ASN1_ERROR);
		return 0;
	} else if (ret == -1)
		return -1;
	ret = 0;
	/* SEQUENCE, SET and "OTHER" are left in encoded form */
	if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
	    (utype == V_ASN1_OTHER)) {
		/* Clear context cache for type OTHER because the auto clear
		 * when we have a exact match wont work
		 */
		if (utype == V_ASN1_OTHER) {
			asn1_tlc_clear(ctx);
		}
		/* SEQUENCE and SET must be constructed */
		else if (!cst) {
			ASN1error(ASN1_R_TYPE_NOT_CONSTRUCTED);
			return 0;
		}

		cont = *in;
		/* If indefinite length constructed find the real end */
		if (inf) {
			if (!asn1_find_end(&p, plen, inf))
				goto err;
			len = p - cont;
		} else {
			len = p - cont + plen;
			p += plen;
			buf.data = NULL;
		}
	} else if (cst) {
		/* Should really check the internal tags are correct but
		 * some things may get this wrong. The relevant specs
		 * say that constructed string types should be OCTET STRINGs
		 * internally irrespective of the type. So instead just check
		 * for UNIVERSAL class and ignore the tag.
		 */
		if (!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL, 0)) {
			free_cont = 1;
			goto err;
		}
		len = buf.length;
		/* Append a final null to string */
		if (!BUF_MEM_grow_clean(&buf, len + 1)) {
			ASN1error(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		buf.data[len] = 0;
		cont = (const unsigned char *)buf.data;
		free_cont = 1;
	} else {
		cont = p;
		len = plen;
		p += plen;
	}

	/* We now have content length and type: translate into a structure */
	if (!asn1_ex_c2i(pval, cont, len, utype, &free_cont, it))
		goto err;

	*in = p;
	ret = 1;

err:
	if (free_cont && buf.data)
		free(buf.data);
	return ret;
}

/* Translate ASN1 content octets into a structure */

int
asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len, int utype,
    char *free_cont, const ASN1_ITEM *it)
{
	ASN1_VALUE **opval = NULL;
	ASN1_STRING *stmp;
	ASN1_TYPE *typ = NULL;
	int ret = 0;
	const ASN1_PRIMITIVE_FUNCS *pf;
	ASN1_INTEGER **tint;

	pf = it->funcs;

	if (pf && pf->prim_c2i)
		return pf->prim_c2i(pval, cont, len, utype, free_cont, it);
	/* If ANY type clear type and set pointer to internal value */
	if (it->utype == V_ASN1_ANY) {
		if (!*pval) {
			typ = ASN1_TYPE_new();
			if (typ == NULL)
				goto err;
			*pval = (ASN1_VALUE *)typ;
		} else
			typ = (ASN1_TYPE *)*pval;

		if (utype != typ->type)
			ASN1_TYPE_set(typ, utype, NULL);
		opval = pval;
		pval = &typ->value.asn1_value;
	}
	switch (utype) {
	case V_ASN1_OBJECT:
		if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len))
			goto err;
		break;

	case V_ASN1_NULL:
		if (len) {
			ASN1error(ASN1_R_NULL_IS_WRONG_LENGTH);
			goto err;
		}
		*pval = (ASN1_VALUE *)1;
		break;

	case V_ASN1_BOOLEAN:
		if (len != 1) {
			ASN1error(ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
			goto err;
		} else {
			ASN1_BOOLEAN *tbool;
			tbool = (ASN1_BOOLEAN *)pval;
			*tbool = *cont;
		}
		break;

	case V_ASN1_BIT_STRING:
		if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len))
			goto err;
		break;

	case V_ASN1_INTEGER:
	case V_ASN1_ENUMERATED:
		tint = (ASN1_INTEGER **)pval;
		if (!c2i_ASN1_INTEGER(tint, &cont, len))
			goto err;
		/* Fixup type to match the expected form */
		(*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);
		break;

	case V_ASN1_OCTET_STRING:
	case V_ASN1_NUMERICSTRING:
	case V_ASN1_PRINTABLESTRING:
	case V_ASN1_T61STRING:
	case V_ASN1_VIDEOTEXSTRING:
	case V_ASN1_IA5STRING:
	case V_ASN1_UTCTIME:
	case V_ASN1_GENERALIZEDTIME:
	case V_ASN1_GRAPHICSTRING:
	case V_ASN1_VISIBLESTRING:
	case V_ASN1_GENERALSTRING:
	case V_ASN1_UNIVERSALSTRING:
	case V_ASN1_BMPSTRING:
	case V_ASN1_UTF8STRING:
	case V_ASN1_OTHER:
	case V_ASN1_SET:
	case V_ASN1_SEQUENCE:
	default:
		if (utype == V_ASN1_BMPSTRING && (len & 1)) {
			ASN1error(ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
			goto err;
		}
		if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {
			ASN1error(ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
			goto err;
		}
		/* All based on ASN1_STRING and handled the same */
		if (!*pval) {
			stmp = ASN1_STRING_type_new(utype);
			if (!stmp) {
				ASN1error(ERR_R_MALLOC_FAILURE);
				goto err;
			}
			*pval = (ASN1_VALUE *)stmp;
		} else {
			stmp = (ASN1_STRING *)*pval;
			stmp->type = utype;
		}
		/* If we've already allocated a buffer use it */
		if (*free_cont) {
			free(stmp->data);
			stmp->data = (unsigned char *)cont; /* UGLY CAST! RL */
			stmp->length = len;
			*free_cont = 0;
		} else {
			if (!ASN1_STRING_set(stmp, cont, len)) {
				ASN1error(ERR_R_MALLOC_FAILURE);
				ASN1_STRING_free(stmp);
				*pval = NULL;
				goto err;
			}
		}
		break;
	}
	/* If ASN1_ANY and NULL type fix up value */
	if (typ && (utype == V_ASN1_NULL))
		typ->value.ptr = NULL;

	ret = 1;

err:
	if (!ret) {
		ASN1_TYPE_free(typ);
		if (opval)
			*opval = NULL;
	}
	return ret;
}


/* This function finds the end of an ASN1 structure when passed its maximum
 * length, whether it is indefinite length and a pointer to the content.
 * This is more efficient than calling asn1_collect because it does not
 * recurse on each indefinite length header.
 */

static int
asn1_find_end(const unsigned char **in, long len, char inf)
{
	int expected_eoc;
	long plen;
	const unsigned char *p = *in, *q;

	/* If not indefinite length constructed just add length */
	if (inf == 0) {
		*in += len;
		return 1;
	}
	expected_eoc = 1;
	/* Indefinite length constructed form. Find the end when enough EOCs
	 * are found. If more indefinite length constructed headers
	 * are encountered increment the expected eoc count otherwise just
	 * skip to the end of the data.
	 */
	while (len > 0) {
		if (asn1_check_eoc(&p, len)) {
			expected_eoc--;
			if (expected_eoc == 0)
				break;
			len -= 2;
			continue;
		}
		q = p;
		/* Just read in a header: only care about the length */
		if (!asn1_check_tlen(&plen, NULL, NULL, &inf, NULL, &p, len,
		    -1, 0, 0, NULL)) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			return 0;
		}
		if (inf)
			expected_eoc++;
		else
			p += plen;
		len -= p - q;
	}
	if (expected_eoc) {
		ASN1error(ASN1_R_MISSING_EOC);
		return 0;
	}
	*in = p;
	return 1;
}
/* This function collects the asn1 data from a constructred string
 * type into a buffer. The values of 'in' and 'len' should refer
 * to the contents of the constructed type and 'inf' should be set
 * if it is indefinite length.
 */

#ifndef ASN1_MAX_STRING_NEST
/* This determines how many levels of recursion are permitted in ASN1
 * string types. If it is not limited stack overflows can occur. If set
 * to zero no recursion is allowed at all. Although zero should be adequate
 * examples exist that require a value of 1. So 5 should be more than enough.
 */
#define ASN1_MAX_STRING_NEST 5
#endif

static int
asn1_collect(BUF_MEM *buf, const unsigned char **in, long len, char inf,
    int tag, int aclass, int depth)
{
	const unsigned char *p, *q;
	long plen;
	char cst, ininf;

	p = *in;
	inf &= 1;
	/* If no buffer and not indefinite length constructed just pass over
	 * the encoded data */
	if (!buf && !inf) {
		*in += len;
		return 1;
	}
	while (len > 0) {
		q = p;
		/* Check for EOC */
		if (asn1_check_eoc(&p, len)) {
			/* EOC is illegal outside indefinite length
			 * constructed form */
			if (!inf) {
				ASN1error(ASN1_R_UNEXPECTED_EOC);
				return 0;
			}
			inf = 0;
			break;
		}

		if (!asn1_check_tlen(&plen, NULL, NULL, &ininf, &cst, &p,
		    len, tag, aclass, 0, NULL)) {
			ASN1error(ERR_R_NESTED_ASN1_ERROR);
			return 0;
		}

		/* If indefinite length constructed update max length */
		if (cst) {
			if (depth >= ASN1_MAX_STRING_NEST) {
				ASN1error(ASN1_R_NESTED_ASN1_STRING);
				return 0;
			}
			if (!asn1_collect(buf, &p, plen, ininf, tag, aclass,
			    depth + 1))
				return 0;
		} else if (plen && !collect_data(buf, &p, plen))
			return 0;
		len -= p - q;
	}
	if (inf) {
		ASN1error(ASN1_R_MISSING_EOC);
		return 0;
	}
	*in = p;
	return 1;
}

static int
collect_data(BUF_MEM *buf, const unsigned char **p, long plen)
{
	int len;
	if (buf) {
		len = buf->length;
		if (!BUF_MEM_grow_clean(buf, len + plen)) {
			ASN1error(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		memcpy(buf->data + len, *p, plen);
	}
	*p += plen;
	return 1;
}

/* Check for ASN1 EOC and swallow it if found */

static int
asn1_check_eoc(const unsigned char **in, long len)
{
	const unsigned char *p;

	if (len < 2)
		return 0;
	p = *in;
	if (!p[0] && !p[1]) {
		*in += 2;
		return 1;
	}
	return 0;
}

/* Check an ASN1 tag and length: a bit like ASN1_get_object
 * but it sets the length for indefinite length constructed
 * form, we don't know the exact length but we can set an
 * upper bound to the amount of data available minus the
 * header length just read.
 */

static int
asn1_check_tlen(long *olen, int *otag, unsigned char *oclass, char *inf,
    char *cst, const unsigned char **in, long len, int exptag, int expclass,
    char opt, ASN1_TLC *ctx)
{
	int i;
	int ptag, pclass;
	long plen;
	const unsigned char *p, *q;

	p = *in;
	q = p;

	if (ctx && ctx->valid) {
		i = ctx->ret;
		plen = ctx->plen;
		pclass = ctx->pclass;
		ptag = ctx->ptag;
		p += ctx->hdrlen;
	} else {
		i = ASN1_get_object(&p, &plen, &ptag, &pclass, len);
		if (ctx) {
			ctx->ret = i;
			ctx->plen = plen;
			ctx->pclass = pclass;
			ctx->ptag = ptag;
			ctx->hdrlen = p - q;
			ctx->valid = 1;
			/* If definite length, and no error, length +
			 * header can't exceed total amount of data available.
			 */
			if (!(i & 0x81) && ((plen + ctx->hdrlen) > len)) {
				ASN1error(ASN1_R_TOO_LONG);
				asn1_tlc_clear(ctx);
				return 0;
			}
		}
	}

	if (i & 0x80) {
		ASN1error(ASN1_R_BAD_OBJECT_HEADER);
		asn1_tlc_clear(ctx);
		return 0;
	}
	if (exptag >= 0) {
		if ((exptag != ptag) || (expclass != pclass)) {
			/* If type is OPTIONAL, not an error:
			 * indicate missing type.
			 */
			if (opt)
				return -1;
			asn1_tlc_clear(ctx);
			ASN1error(ASN1_R_WRONG_TAG);
			return 0;
		}
		/* We have a tag and class match:
		 * assume we are going to do something with it */
		asn1_tlc_clear(ctx);
	}

	if (i & 1)
		plen = len - (p - q);
	if (inf)
		*inf = i & 1;
	if (cst)
		*cst = i & V_ASN1_CONSTRUCTED;
	if (olen)
		*olen = plen;
	if (oclass)
		*oclass = pclass;
	if (otag)
		*otag = ptag;

	*in = p;
	return 1;
}
@


1.33
log
@Expand ASN1_ITEM_rptr and ASN1_ITEM_ptr macros - no change in generated
assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.32 2016/05/04 15:00:24 tedu Exp $ */
d192 1
a192 2
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
				    ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
d208 1
a208 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d217 1
a217 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ASN1_R_MSTRING_NOT_UNIVERSAL);
d225 1
a225 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ASN1_R_MSTRING_WRONG_TAG);
d251 1
a251 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d270 1
a270 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d282 1
a282 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ASN1_R_NO_MATCHING_CHOICE_TYPE);
d306 1
a306 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d318 1
a318 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
d323 1
a323 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d357 1
a357 2
					ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
					    ASN1_R_UNEXPECTED_EOC);
d396 1
a396 1
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
d401 1
a401 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ASN1_R_SEQUENCE_LENGTH_MISMATCH);
d420 1
a420 2
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
				    ASN1_R_FIELD_MISSING);
d426 1
a426 1
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_MALLOC_FAILURE);
d439 1
a439 1
	ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
d483 1
a483 2
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d488 1
a488 2
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
			    ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
d494 1
a494 2
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d502 1
a502 2
				ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
				    ASN1_R_MISSING_EOC);
d509 1
a509 2
				ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
				    ASN1_R_EXPLICIT_LENGTH_MISMATCH);
d559 1
a559 2
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d578 1
a578 2
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
			    ERR_R_MALLOC_FAILURE);
d589 1
a589 2
					ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
					    ASN1_R_UNEXPECTED_EOC);
d599 1
a599 2
				ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
				    ERR_R_NESTED_ASN1_ERROR);
d605 1
a605 2
				ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
				    ERR_R_MALLOC_FAILURE);
d610 1
a610 2
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
			    ASN1_R_MISSING_EOC);
d618 1
a618 2
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d627 1
a627 2
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
d658 1
a658 1
		ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_NULL);
d672 1
a672 2
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
			    ASN1_R_ILLEGAL_TAGGED_ANY);
d676 1
a676 2
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
			    ASN1_R_ILLEGAL_OPTIONAL_ANY);
d683 1
a683 2
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
			    ERR_R_NESTED_ASN1_ERROR);
d698 1
a698 1
		ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_NESTED_ASN1_ERROR);
d714 1
a714 2
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
			    ASN1_R_TYPE_NOT_CONSTRUCTED);
d743 1
a743 2
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
			    ERR_R_MALLOC_FAILURE);
d808 1
a808 2
			ASN1err(ASN1_F_ASN1_EX_C2I,
			    ASN1_R_NULL_IS_WRONG_LENGTH);
d816 1
a816 2
			ASN1err(ASN1_F_ASN1_EX_C2I,
			    ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
d858 1
a858 2
			ASN1err(ASN1_F_ASN1_EX_C2I,
			    ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
d862 1
a862 2
			ASN1err(ASN1_F_ASN1_EX_C2I,
			    ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
d869 1
a869 2
				ASN1err(ASN1_F_ASN1_EX_C2I,
				    ERR_R_MALLOC_FAILURE);
d885 1
a885 2
				ASN1err(ASN1_F_ASN1_EX_C2I,
				    ERR_R_MALLOC_FAILURE);
d945 1
a945 1
			ASN1err(ASN1_F_ASN1_FIND_END, ERR_R_NESTED_ASN1_ERROR);
d955 1
a955 1
		ASN1err(ASN1_F_ASN1_FIND_END, ASN1_R_MISSING_EOC);
d999 1
a999 2
				ASN1err(ASN1_F_ASN1_COLLECT,
				    ASN1_R_UNEXPECTED_EOC);
d1008 1
a1008 1
			ASN1err(ASN1_F_ASN1_COLLECT, ERR_R_NESTED_ASN1_ERROR);
d1015 1
a1015 2
				ASN1err(ASN1_F_ASN1_COLLECT,
				    ASN1_R_NESTED_ASN1_STRING);
d1026 1
a1026 1
		ASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_MISSING_EOC);
d1040 1
a1040 1
			ASN1err(ASN1_F_COLLECT_DATA, ERR_R_MALLOC_FAILURE);
d1105 1
a1105 2
				ASN1err(ASN1_F_ASN1_CHECK_TLEN,
				    ASN1_R_TOO_LONG);
d1113 1
a1113 1
		ASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_BAD_OBJECT_HEADER);
d1125 1
a1125 1
			ASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_WRONG_TAG);
@


1.32
log
@internal only negative types should not be handled here.
CVE-2016-2108 from openssl.
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.31 2016/05/04 14:53:29 tedu Exp $ */
d592 1
a592 1
				    ASN1_ITEM_ptr(tt->item));
d619 1
a619 1
			    ASN1_ITEM_ptr(tt->item), -1, 0, 0, ctx)) {
d640 1
a640 1
		    ASN1_ITEM_ptr(tt->item), tt->tag, aclass, opt, ctx);
d649 1
a649 1
		ret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item),
@


1.31
log
@revert the big change from yesterday to prepare for smaller commits.
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.30 2016/05/03 12:38:53 tedu Exp $ */
a863 1
	case V_ASN1_NEG_INTEGER:
a864 1
	case V_ASN1_NEG_ENUMERATED:
@


1.30
log
@patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.29 2015/12/12 21:05:11 beck Exp $ */
d864 1
d866 1
@


1.29
log
@move initialization of buf up to quell warnings and make it obvious the err case is ok.
ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.28 2015/12/04 04:19:25 beck Exp $ */
a863 1
	case V_ASN1_NEG_INTEGER:
a864 1
	case V_ASN1_NEG_ENUMERATED:
@


1.29.2.1
log
@backport patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.29 2015/12/12 21:05:11 beck Exp $ */
d864 1
d866 1
@


1.28
log
@Fix for OpenSSL CVE-2015-3195
ok djm@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.27 2015/07/20 15:41:48 miod Exp $ */
d679 4
a759 3
		buf.length = 0;
		buf.max = 0;
		buf.data = NULL;
@


1.27
log
@Check the return value of asn1_enc_save(). ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.26 2015/03/19 14:00:22 tedu Exp $ */
d169 4
d454 2
a455 1
	ASN1_item_ex_free(pval, it);
d650 1
a650 1
		    -1, 0, opt, ctx);
@


1.27.4.1
log
@Fix for OpenSSL CVE-2015-3195
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.28 2015/12/04 04:19:25 beck Exp $ */
a168 4
	int combine;

	combine = aclass & ASN1_TFLG_COMBINE;
	aclass &= ~ASN1_TFLG_COMBINE;
d450 1
a450 2
	if (combine == 0)
		ASN1_item_ex_free(pval, it);
d645 1
a645 1
		    -1, tt->flags & ASN1_TFLG_COMBINE, opt, ctx);
@


1.27.4.2
log
@backport patch from openssl for multiple issues:
missing padding check in aesni functions
overflow in evp encode functions
use of invalid negative asn.1 types
ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.27.4.1 2015/12/04 04:21:36 beck Exp $ */
d863 1
d865 1
@


1.26
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.25 2015/02/14 15:23:57 miod Exp $ */
d434 2
a435 1
		if (!asn1_enc_save(pval, *in, p - *in, it))
d437 1
@


1.25
log
@Remove IMPLEMENT_COMPAT_ASN1() and related support code. Nothing uses it in
libcrypto/libssl, and nothing seems to use it in the wild, apart from embedded
copies of OpenSSL.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.24 2014/06/12 15:49:27 deraadt Exp $ */
d241 10
a250 2
		/* Allocate structure */
		if (!*pval && !ASN1_item_ex_new(pval, it)) {
d335 13
@


1.25.4.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.25 2015/02/14 15:23:57 miod Exp $ */
d241 2
a242 10
		if (*pval) {
			/* Free up and zero CHOICE value if initialised */
			i = asn1_get_choice_selector(pval, it);
			if ((i >= 0) && (i < it->tcount)) {
				tt = it->templates + i;
				pchptr = asn1_get_field_ptr(pval, tt);
				ASN1_template_free(pchptr, tt);
				asn1_set_choice_selector(pval, -1, it);
			}
		} else if (!ASN1_item_ex_new(pval, it)) {
a326 13

		/* Free up and zero any ADB found */
		for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
			if (tt->flags & ASN1_TFLG_ADB_MASK) {
				const ASN1_TEMPLATE *seqtt;
				ASN1_VALUE **pseqval;
				seqtt = asn1_do_adb(pval, tt, 1);
				if (!seqtt)
					goto err;
				pseqval = asn1_get_field_ptr(pval, seqtt);
				ASN1_template_free(pseqval, seqtt);
			}
		}
@


1.25.4.2
log
@Fix for OpenSSL CVE-2015-3195
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.28 2015/12/04 04:19:25 beck Exp $ */
a168 4
	int combine;

	combine = aclass & ASN1_TFLG_COMBINE;
	aclass &= ~ASN1_TFLG_COMBINE;
d448 1
a448 2
	if (combine == 0)
		ASN1_item_ex_free(pval, it);
d643 1
a643 1
		    -1, tt->flags & ASN1_TFLG_COMBINE, opt, ctx);
@


1.24
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a157 1
	const ASN1_COMPAT_FUNCS *cf;
d162 1
a162 2
	unsigned char *wp = NULL;	/* BIG FAT WARNING!  BREAKS CONST WHERE USED */
	unsigned char imphack = 0, oclass;
d168 1
a168 1
	ASN1_VALUE **pchptr, *ptmpval;
a235 64

	case ASN1_ITYPE_COMPAT:
		/* we must resort to old style evil hackery */
		cf = it->funcs;

		/* If OPTIONAL see if it is there */
		if (opt) {
			int exptag;
			p = *in;
			if (tag == -1)
				exptag = it->utype;
			else
				exptag = tag;
			/* Don't care about anything other than presence
			 * of expected tag */

			ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
			    &p, len, exptag, aclass, 1, ctx);
			if (!ret) {
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
				    ERR_R_NESTED_ASN1_ERROR);
				goto err;
			}
			if (ret == -1)
				return -1;
		}

		/* This is the old style evil hack IMPLICIT handling:
		 * since the underlying code is expecting a tag and
		 * class other than the one present we change the
		 * buffer temporarily then change it back afterwards.
		 * This doesn't and never did work for tags > 30.
		 *
		 * Yes this is *horrible* but it is only needed for
		 * old style d2i which will hopefully not be around
		 * for much longer.
		 * FIXME: should copy the buffer then modify it so
		 * the input buffer can be const: we should *always*
		 * copy because the old style d2i might modify the
		 * buffer.
		 */

		if (tag != -1) {
			wp = *(unsigned char **)in;
			imphack = *wp;
			if (p == NULL) {
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
				    ERR_R_NESTED_ASN1_ERROR);
				goto err;
			}
			*wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED) |
			    it->utype);
		}

		ptmpval = cf->asn1_d2i(pval, in, len);

		if (tag != -1)
			*wp = imphack;

		if (ptmpval)
			return 1;

		ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
		goto err;
@


1.24.4.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: tasn_dec.c,v 1.24 2014/06/12 15:49:27 deraadt Exp $ */
d307 2
a308 10
		if (*pval) {
			/* Free up and zero CHOICE value if initialised */
			i = asn1_get_choice_selector(pval, it);
			if ((i >= 0) && (i < it->tcount)) {
				tt = it->templates + i;
				pchptr = asn1_get_field_ptr(pval, tt);
				ASN1_template_free(pchptr, tt);
				asn1_set_choice_selector(pval, -1, it);
			}
		} else if (!ASN1_item_ex_new(pval, it)) {
a392 13

		/* Free up and zero any ADB found */
		for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
			if (tt->flags & ASN1_TFLG_ADB_MASK) {
				const ASN1_TEMPLATE *seqtt;
				ASN1_VALUE **pseqval;
				seqtt = asn1_do_adb(pval, tt, 1);
				if (!seqtt)
					goto err;
				pseqval = asn1_get_field_ptr(pval, seqtt);
				ASN1_template_free(pseqval, seqtt);
			}
		}
@


1.23
log
@no need for null check before free. from Brendan MacDonell
@
text
@d1 1
a1 1
/* tasn_dec.c */
@


1.22
log
@i give up. reuse problem is unfixable. dlg says puppet crashes.
@
text
@d954 1
a954 2
			if (stmp->data)
				free(stmp->data);
@


1.21
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d385 4
a388 8
		if (!*pval) {
			if (!ASN1_item_ex_new(pval, it)) {
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
				    ERR_R_NESTED_ASN1_ERROR);
				goto err;
			}
		} else {
			memset(*pval, 0, it->size);
@


1.20
log
@another attempt at fixing stale x509 data. since we don't know where the
initial storage came from, we can't free it. just memset in the sequence
case. probably ok beck
@
text
@d499 2
a500 2
		ERR_add_error_data(4, "Field=", errtt->field_name,
		    ", Type=", it->sname);
d502 1
a502 1
		ERR_add_error_data(2, "Type=", it->sname);
@


1.19
log
@can't actually do this. cause unknown.
@
text
@a174 6
	/* always start fresh */
	if (0 && *pval) {
		ASN1_item_ex_free(pval, it);
		*pval = NULL;
	}

d385 8
a392 4
		if (!*pval && !ASN1_item_ex_new(pval, it)) {
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
			    ERR_R_NESTED_ASN1_ERROR);
			goto err;
@


1.18
log
@guenther would prefer more separation
@
text
@d176 1
a176 1
	if (*pval) {
@


1.17
log
@Some dude named Tavis Ormandy reported a bug which has gone unfixed.
http://marc.info/?l=openssl-users&m=138014120223264&w=2
Arguably a doc bug, but we argue not. If you parse a new cert into memory
occupied by a previously verified cert, the new cert will inherit that
state, bypassing future verification checks. To avoid this, we will always
start fresh with a new object.

grudging ok from guenther, after i threatened to make him read the code yet
again. "that ok was way more painful and tiring then it should have been"
@
text
@d174 1
d180 1
@


1.16
log
@blank lines between decls and code
@
text
@d174 5
@


1.15
log
@More KNF.
@
text
@d129 1
d143 1
d171 1
d847 1
d1160 1
@


1.14
log
@lob a few more knf grenades in here to soften things up.
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d72 1
a72 1
			char inf, int tag, int aclass, int depth);
d77 10
a86 17
				char *inf, char *cst,
				const unsigned char **in, long len,
				int exptag, int expclass, char opt,
				ASN1_TLC *ctx);

static int asn1_template_ex_d2i(ASN1_VALUE **pval,
				const unsigned char **in, long len,
				const ASN1_TEMPLATE *tt, char opt,
				ASN1_TLC *ctx);
static int asn1_template_noexp_d2i(ASN1_VALUE **val,
				const unsigned char **in, long len,
				const ASN1_TEMPLATE *tt, char opt,
				ASN1_TLC *ctx);
static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
				const unsigned char **in, long len,
				const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx);
d90 9
a98 9
0,	0,	0,	B_ASN1_BIT_STRING,	/* tags  0 -  3 */
B_ASN1_OCTET_STRING,	0,	0,		B_ASN1_UNKNOWN,/* tags  4- 7 */
B_ASN1_UNKNOWN,	B_ASN1_UNKNOWN,	B_ASN1_UNKNOWN,	B_ASN1_UNKNOWN,/* tags  8-11 */
B_ASN1_UTF8STRING,B_ASN1_UNKNOWN,B_ASN1_UNKNOWN,B_ASN1_UNKNOWN,/* tags 12-15 */
B_ASN1_SEQUENCE,0,B_ASN1_NUMERICSTRING,B_ASN1_PRINTABLESTRING, /* tags 16-19 */
B_ASN1_T61STRING,B_ASN1_VIDEOTEXSTRING,B_ASN1_IA5STRING,       /* tags 20-22 */
B_ASN1_UTCTIME, B_ASN1_GENERALIZEDTIME,			       /* tags 23-24 */	
B_ASN1_GRAPHICSTRING,B_ASN1_ISO64STRING,B_ASN1_GENERALSTRING,  /* tags 25-27 */
B_ASN1_UNIVERSALSTRING,B_ASN1_UNKNOWN,B_ASN1_BMPSTRING,B_ASN1_UNKNOWN, /* tags 28-31 */
d101 2
a102 1
unsigned long ASN1_tag2bit(int tag)
d104 2
a105 1
	if ((tag < 0) || (tag > 30)) return 0;
d115 2
a116 2
/* Decode an ASN1 item, this currently behaves just 
 * like a standard 'd2i' function. 'in' points to 
d123 3
a125 2
ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval,
		const unsigned char **in, long len, const ASN1_ITEM *it)
d132 1
a132 1
	if (ASN1_item_ex_d2i(pval, in, len, it, -1, 0, 0, &c) > 0) 
d137 3
a139 2
int ASN1_template_d2i(ASN1_VALUE **pval,
		const unsigned char **in, long len, const ASN1_TEMPLATE *tt)
d151 3
a153 3
int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
			const ASN1_ITEM *it,
			int tag, int aclass, char opt, ASN1_TLC *ctx)
d161 1
a161 1
	unsigned char *wp=NULL;	/* BIG FAT WARNING!  BREAKS CONST WHERE USED */
d173 2
a174 1
	else asn1_cb = 0;
d176 1
a176 1
	switch(it->itype) {
d187 1
a187 1
				ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
d191 2
a192 2
					it->templates, opt, ctx);
	}
d194 1
a194 1
						tag, aclass, opt, ctx);
d201 1
a201 1
						&p, len, -1, 0, 1, ctx);
d204 1
a204 1
					ERR_R_NESTED_ASN1_ERROR);
d211 2
a212 1
			if (opt) return -1;
d214 1
a214 1
					ASN1_R_MSTRING_NOT_UNIVERSAL);
d223 1
a223 1
					ASN1_R_MSTRING_WRONG_TAG);
d227 1
a227 1
						it, otag, 0, 0, ctx);
d233 1
a233 1
						it, tag, aclass, opt, ctx);
d245 2
a246 1
			else exptag = tag;
d251 1
a251 1
					&p, len, exptag, aclass, 1, ctx);
d254 1
a254 1
					ERR_R_NESTED_ASN1_ERROR);
d281 1
a281 1
					ERR_R_NESTED_ASN1_ERROR);
d284 2
a285 2
			*wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
								| it->utype);
a298 1

d301 1
a301 1
				goto auxerr;
d306 1
a306 1
						ERR_R_NESTED_ASN1_ERROR);
d311 1
a311 1
		for (i = 0, tt=it->templates; i < it->tcount; i++, tt++) {
d326 1
a326 1
						ERR_R_NESTED_ASN1_ERROR);
d339 1
a339 1
					ASN1_R_NO_MATCHING_CHOICE_TYPE);
d346 1
a346 1
				goto auxerr;
d361 1
a361 1
					&p, len, tag, aclass, opt, ctx);
d364 1
a364 1
					ERR_R_NESTED_ASN1_ERROR);
d366 1
a366 2
		}
		else if (ret == -1)
d373 2
a374 1
		else seq_nolen = seq_eoc;
d377 1
a377 1
				ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
d383 1
a383 1
				ERR_R_NESTED_ASN1_ERROR);
d388 1
a388 1
				goto auxerr;
d405 1
a405 1
							ASN1_R_UNEXPECTED_EOC);
d421 2
a422 1
			else isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
d427 1
a427 1
							seqtt, isopt, ctx);
d450 1
a450 1
					ASN1_R_SEQUENCE_LENGTH_MISMATCH);
d470 1
a470 1
							ASN1_R_FIELD_MISSING);
d479 1
a479 1
				goto auxerr;
d482 1
a482 1
		default:
d485 2
a486 1
	auxerr:
d488 1
a488 1
	err:
d492 1
a492 1
					", Type=", it->sname);
d502 3
a504 4
static int asn1_template_ex_d2i(ASN1_VALUE **val,
				const unsigned char **in, long inlen,
				const ASN1_TEMPLATE *tt, char opt,
							ASN1_TLC *ctx)
d511 1
d527 1
a527 1
					&p, inlen, tt->tag, aclass, opt, ctx);
d531 1
a531 1
					ERR_R_NESTED_ASN1_ERROR);
d537 1
a537 1
					ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
d544 1
a544 1
					ERR_R_NESTED_ASN1_ERROR);
d553 1
a553 1
						ASN1_R_MISSING_EOC);
d561 1
a561 1
					ASN1_R_EXPLICIT_LENGTH_MISMATCH);
d565 2
a566 4
	}
		else 
			return asn1_template_noexp_d2i(val, in, inlen,
								tt, opt, ctx);
d571 1
a571 1
	err:
d576 3
a578 4
static int asn1_template_noexp_d2i(ASN1_VALUE **val,
				const unsigned char **in, long len,
				const ASN1_TEMPLATE *tt, char opt,
				ASN1_TLC *ctx)
d583 1
d609 1
a609 1
					&p, len, sktag, skaclass, opt, ctx);
d612 1
a612 1
						ERR_R_NESTED_ASN1_ERROR);
d614 1
a614 2
		}
		else if (ret == -1)
d620 2
a621 2
			STACK_OF(ASN1_VALUE) *sktmp
			    = (STACK_OF(ASN1_VALUE) *)*val;
d623 1
a623 1
			while(sk_ASN1_VALUE_num(sktmp) > 0) {
d626 1
a626 1
						ASN1_ITEM_ptr(tt->item));
d629 1
a629 1
				
d632 1
a632 1
						ERR_R_MALLOC_FAILURE);
d637 1
a637 1
		while(len > 0) {
d644 1
a644 1
							ASN1_R_UNEXPECTED_EOC);
d653 1
a653 2
						ASN1_ITEM_ptr(tt->item),
						-1, 0, 0, ctx)) {
d655 1
a655 1
					ERR_R_NESTED_ASN1_ERROR);
d660 1
a660 1
						skfield)) {
d662 1
a662 1
						ERR_R_MALLOC_FAILURE);
d667 2
a668 1
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ASN1_R_MISSING_EOC);
d674 1
a674 1
			ASN1_ITEM_ptr(tt->item), tt->tag, aclass, opt, ctx);
d677 1
a677 1
						ERR_R_NESTED_ASN1_ERROR);
d679 1
a679 2
		}
		else if (ret == -1)
d684 1
a684 1
							-1, 0, opt, ctx);
d687 1
a687 1
					ERR_R_NESTED_ASN1_ERROR);
d689 1
a689 2
		}
		else if (ret == -1)
d696 1
a696 1
	err:
d701 3
a703 4
static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
				const unsigned char **in, long inlen, 
				const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx)
d711 2
a712 1
	long len; 
d721 1
a721 2
	}
	else
d729 1
a729 1
					ASN1_R_ILLEGAL_TAGGED_ANY);
d734 1
a734 1
					ASN1_R_ILLEGAL_OPTIONAL_ANY);
d739 1
a739 1
					&p, inlen, -1, 0, 0, ctx);
d742 1
a742 1
					ERR_R_NESTED_ASN1_ERROR);
d755 1
a755 1
				&p, inlen, tag, aclass, opt, ctx);
d759 1
a759 2
	}
	else if (ret == -1)
d761 1
a761 1
        ret = 0;
d763 2
a764 2
	if ((utype == V_ASN1_SEQUENCE)
		|| (utype == V_ASN1_SET) || (utype == V_ASN1_OTHER)) {
d774 1
a774 1
				ASN1_R_TYPE_NOT_CONSTRUCTED);
d782 1
a782 1
				 goto err;
d807 1
a807 1
						ERR_R_MALLOC_FAILURE);
d825 4
a828 2
	err:
	if (free_cont && buf.data) free(buf.data);
d834 3
a836 2
int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
			int utype, char *free_cont, const ASN1_ITEM *it)
d855 1
a855 2
		}
		else
d863 1
a863 1
	switch(utype) {
d872 1
a872 1
						ASN1_R_NULL_IS_WRONG_LENGTH);
d881 1
a881 1
						ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
d926 1
a926 1
					ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
d931 1
a931 1
					ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
d939 1
a939 1
							ERR_R_MALLOC_FAILURE);
d957 2
a958 2
							ERR_R_MALLOC_FAILURE);
				ASN1_STRING_free(stmp);	
d967 1
a967 1
		 typ->value.ptr = NULL;
d970 2
a971 1
	err:
d987 2
a988 1
static int asn1_find_end(const unsigned char **in, long len, char inf)
d993 1
d1006 1
a1006 1
		if(asn1_check_eoc(&p, len)) {
d1015 2
a1016 2
		if(!asn1_check_tlen(&plen, NULL, NULL, &inf, NULL, &p, len,
				-1, 0, 0, NULL)) {
d1048 3
a1050 3

static int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,
			char inf, int tag, int aclass, int depth)
d1055 1
d1064 1
a1064 1
	while(len > 0) {
d1072 1
a1072 1
					ASN1_R_UNEXPECTED_EOC);
d1080 1
a1080 1
					len, tag, aclass, 0, NULL)) {
d1089 1
a1089 1
					ASN1_R_NESTED_ASN1_STRING);
d1093 1
a1093 1
						depth + 1))
d1095 1
a1095 2
		}
		else if (plen && !collect_data(buf, &p, plen))
d1107 2
a1108 1
static int collect_data(BUF_MEM *buf, const unsigned char **p, long plen)
d1125 2
a1126 1
static int asn1_check_eoc(const unsigned char **in, long len)
d1129 3
a1131 1
	if (len < 2) return 0;
d1147 4
a1150 5
static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
				char *inf, char *cst,
				const unsigned char **in, long len,
				int exptag, int expclass, char opt,
				ASN1_TLC *ctx)
d1175 1
a1175 1
			 * header can't exceed total amount of data available. 
d1179 1
a1179 1
							ASN1_R_TOO_LONG);
d1196 2
a1197 1
			if (opt) return -1;
a1208 1

a1210 1

a1212 1

a1214 1

a1216 1

@


1.13
log
@putting most of the braces in the right column is the very least we can do.
@
text
@d178 3
a180 5
	switch(it->itype)
	{
		case ASN1_ITYPE_PRIMITIVE:
		if (it->templates)
		{
d187 1
a187 2
			if ((tag != -1) || opt)
			{
d199 1
a199 1
		case ASN1_ITYPE_MSTRING:
d204 1
a204 2
		if (!ret)
		{
d211 1
a211 2
		if (oclass != V_ASN1_UNIVERSAL)
		{
d219 1
a219 2
		if (!(ASN1_tag2bit(otag) & it->utype))
		{
d230 1
a230 1
		case ASN1_ITYPE_EXTERN:
d236 1
a236 1
		case ASN1_ITYPE_COMPAT:
d241 1
a241 2
		if (opt)
		{
d252 1
a252 2
			if (!ret)
			{
d276 1
a276 2
		if (tag != -1)
		{
d279 1
a279 2
			if (p == NULL)
			{
d300 1
a300 1
		case ASN1_ITYPE_CHOICE:
d305 1
a305 2
		if (!*pval && !ASN1_item_ex_new(pval, it))
		{
d312 1
a312 2
		for (i = 0, tt=it->templates; i < it->tcount; i++, tt++)
		{
d332 1
a332 2
		if (i == it->tcount)
		{
d334 1
a334 2
			if (opt)
			{
d350 2
a351 2
		case ASN1_ITYPE_NDEF_SEQUENCE:
		case ASN1_ITYPE_SEQUENCE:
d356 1
a356 2
		if (tag == -1)
		{
d363 1
a363 2
		if (!ret)
		{
d370 1
a370 2
		if (aux && (aux->flags & ASN1_AFLG_BROKEN))
		{
d376 1
a376 2
		if (!cst)
		{
d382 1
a382 2
		if (!*pval && !ASN1_item_ex_new(pval, it))
		{
d392 1
a392 2
		for (i = 0, tt = it->templates; i < it->tcount; i++, tt++)
		{
d403 2
a404 4
			if (asn1_check_eoc(&p, len))
			{
				if (!seq_eoc)
				{
d428 1
a428 2
			if (!ret)
			{
d431 1
a431 3
			}
			else if (ret == -1)
			{
d443 1
a443 2
		if (seq_eoc && !asn1_check_eoc(&p, len))
		{
d448 1
a448 2
		if (!seq_nolen && len)
		{
d458 1
a458 2
		for (; i < it->tcount; tt++, i++)
		{
d463 1
a463 2
			if (seqtt->flags & ASN1_TFLG_OPTIONAL)
			{
d467 1
a467 3
			}
			else
			{
d519 1
a519 2
	if (flags & ASN1_TFLG_EXPTAG)
	{
d528 1
a528 2
		if (!ret)
		{
d532 1
a532 2
		}
		else if (ret == -1)
d534 1
a534 2
		if (!cst)
		{
d541 1
a541 2
		if (!ret)
		{
d548 1
a548 2
		if (exp_eoc)
		{
d550 1
a550 2
			if (!asn1_check_eoc(&p, len))
			{
d555 1
a555 3
		}
		else
		{
d558 1
a558 2
			if (len)
			{
d593 1
a593 2
	if (flags & ASN1_TFLG_SK_MASK)
	{
d598 1
a598 2
		if (flags & ASN1_TFLG_IMPTAG)
		{
d601 1
a601 3
		}
		else
		{
d611 1
a611 2
		if (!ret)
		{
d620 1
a620 2
		else
		{
d625 1
a625 2
			while(sk_ASN1_VALUE_num(sktmp) > 0)
			{
d632 1
a632 2
		if (!*val)
		{
d639 1
a639 2
		while(len > 0)
		{
d643 2
a644 4
			if (asn1_check_eoc(&p, len))
			{
				if (!sk_eoc)
				{
d656 1
a656 2
						-1, 0, 0, ctx))
			{
d663 1
a663 2
						skfield))
			{
d669 1
a669 2
		if (sk_eoc)
		{
d673 1
a673 3
	}
	else if (flags & ASN1_TFLG_IMPTAG)
	{
d677 1
a677 2
		if (!ret)
		{
d684 1
a684 3
	}
	else
	{
d688 1
a688 2
		if (!ret)
		{
d717 1
a717 2
	if (!pval)
	{
d722 1
a722 2
	if (it->itype == ASN1_ITYPE_MSTRING)
	{
d729 1
a729 2
	if (utype == V_ASN1_ANY)
	{
d732 1
a732 2
		if (tag >= 0)
		{
d737 1
a737 2
		if (opt)
		{
d745 1
a745 2
		if (!ret)
		{
d753 1
a753 2
	if (tag == -1)
	{
d761 1
a761 2
	if (!ret)
	{
d770 1
a770 2
		|| (utype == V_ASN1_SET) || (utype == V_ASN1_OTHER))
	{
d774 1
a774 2
		if (utype == V_ASN1_OTHER)
		{
d778 1
a778 2
		else if (!cst)
		{
d786 1
a786 2
		if (inf)
		{
d790 1
a790 3
		}
		else
		{
d795 1
a795 3
	}
	else if (cst)
	{
d805 1
a805 2
		if (!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL, 0))
		{
d811 1
a811 2
		if (!BUF_MEM_grow_clean(&buf, len + 1))
		{
d819 1
a819 3
	}
	else
	{
d852 2
a853 4
	if (it->utype == V_ASN1_ANY)
	{
		if (!*pval)
		{
d867 2
a868 3
	switch(utype)
	{
		case V_ASN1_OBJECT:
d873 2
a874 3
		case V_ASN1_NULL:
		if (len)
		{
d882 2
a883 3
		case V_ASN1_BOOLEAN:
		if (len != 1)
		{
d887 1
a887 3
		}
		else
		{
d894 1
a894 1
		case V_ASN1_BIT_STRING:
d899 4
a902 4
		case V_ASN1_INTEGER:
		case V_ASN1_NEG_INTEGER:
		case V_ASN1_ENUMERATED:
		case V_ASN1_NEG_ENUMERATED:
d910 19
a928 20
		case V_ASN1_OCTET_STRING:
		case V_ASN1_NUMERICSTRING:
		case V_ASN1_PRINTABLESTRING:
		case V_ASN1_T61STRING:
		case V_ASN1_VIDEOTEXSTRING:
		case V_ASN1_IA5STRING:
		case V_ASN1_UTCTIME:
		case V_ASN1_GENERALIZEDTIME:
		case V_ASN1_GRAPHICSTRING:
		case V_ASN1_VISIBLESTRING:
		case V_ASN1_GENERALSTRING:
		case V_ASN1_UNIVERSALSTRING:
		case V_ASN1_BMPSTRING:
		case V_ASN1_UTF8STRING:
		case V_ASN1_OTHER:
		case V_ASN1_SET:
		case V_ASN1_SEQUENCE:
		default:
		if (utype == V_ASN1_BMPSTRING && (len & 1))
		{
d933 1
a933 2
		if (utype == V_ASN1_UNIVERSALSTRING && (len & 3))
		{
d939 1
a939 2
		if (!*pval)
		{
d941 1
a941 2
			if (!stmp)
			{
d947 1
a947 3
		}
		else
		{
d952 1
a952 2
		if (*free_cont)
		{
d958 2
a959 5
		}
		else
		{
			if (!ASN1_STRING_set(stmp, cont, len))
			{
d975 1
a975 2
	if (!ret)
	{
d996 1
a996 2
	if (inf == 0)
	{
d1006 2
a1007 4
	while (len > 0)
	{
		if(asn1_check_eoc(&p, len))
		{
d1017 1
a1017 2
				-1, 0, 0, NULL))
		{
d1027 1
a1027 2
	if (expected_eoc)
	{
d1060 1
a1060 2
	if (!buf && !inf)
	{
d1064 1
a1064 2
	while(len > 0)
	{
d1067 1
a1067 2
		if (asn1_check_eoc(&p, len))
		{
d1070 1
a1070 2
			if (!inf)
			{
d1080 1
a1080 2
					len, tag, aclass, 0, NULL))
		{
d1086 2
a1087 4
		if (cst)
		{
			if (depth >= ASN1_MAX_STRING_NEST)
			{
d1100 1
a1100 2
	if (inf)
	{
d1111 1
a1111 2
	if (buf)
	{
d1113 1
a1113 2
		if (!BUF_MEM_grow_clean(buf, len + plen))
		{
d1130 1
a1130 2
	if (!p[0] && !p[1])
	{
d1157 1
a1157 2
	if (ctx && ctx->valid)
	{
d1163 1
a1163 3
	}
	else
	{
d1165 1
a1165 2
		if (ctx)
		{
d1175 1
a1175 2
			if (!(i & 0x81) && ((plen + ctx->hdrlen) > len))
			{
d1184 1
a1184 2
	if (i & 0x80)
	{
d1189 2
a1190 4
	if (exptag >= 0)
	{
		if ((exptag != ptag) || (expclass != pclass))
		{
@


1.12
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d106 1
a106 1
	};
d109 1
a109 1
	{
d112 1
a112 1
	}
d130 1
a130 1
	{
d139 1
a139 1
	}
d143 1
a143 1
	{
d147 1
a147 1
	}
d157 1
a157 1
	{
d179 1
a179 1
		{
d182 1
a182 1
			{
d190 1
a190 1
				{
d194 1
a194 1
				}
d197 1
a197 1
		}
d208 1
a208 1
			{
d212 1
a212 1
			}
d216 1
a216 1
			{
d222 1
a222 1
			}
d225 1
a225 1
			{
d232 1
a232 1
			}
d248 1
a248 1
			{
d260 1
a260 1
				{
d264 1
a264 1
				}
d267 1
a267 1
			}
d285 1
a285 1
			{
d289 1
a289 1
				{
d293 1
a293 1
				}
d296 1
a296 1
			}
d316 1
a316 1
			{
d320 1
a320 1
			}
d324 1
a324 1
			{
d341 1
a341 1
			}
d345 1
a345 1
			{
d348 1
a348 1
				{
d352 1
a352 1
				}
d356 1
a356 1
			}
d371 1
a371 1
			{
d374 1
a374 1
			}
d379 1
a379 1
			{
d383 1
a383 1
			}
d387 1
a387 1
			{
d390 1
a390 1
			}
d394 1
a394 1
			{
d398 1
a398 1
			}
d401 1
a401 1
			{
d405 1
a405 1
			}
d412 1
a412 1
			{
d424 2
a426 2
				if (!seq_eoc)
					{
d430 1
a430 1
					}
d435 1
a435 1
				}
d451 1
a451 1
				{
d454 1
a454 1
				}
d456 1
a456 1
				{
d462 1
a462 1
				}
d465 1
a465 1
			}
d469 1
a469 1
			{
d472 1
a472 1
			}
d475 1
a475 1
			{
d479 1
a479 1
			}
d486 1
a486 1
			{
d492 1
a492 1
				{
d496 1
a496 1
				}
d498 1
a498 1
				{
a502 1
				}
d504 1
d515 1
a515 1
		}
d526 1
a526 1
	}
d536 1
a536 1
	{
d551 1
a551 1
		{
d561 1
a561 1
			{
d565 1
a565 1
			}
d569 1
a569 1
			{
d573 1
a573 1
			}
d577 1
a577 1
			{
d581 1
a581 1
			}
d585 1
a585 1
			{
d588 1
a588 1
				{
a591 1
				}
d593 1
d595 1
a595 1
			{
d599 1
a599 1
				{
a602 1
				}
d605 1
d616 1
a616 1
	}
d622 1
a622 1
	{
d635 1
a635 1
		{
d641 1
a641 1
			{
d644 1
a644 1
			}
d646 1
a646 1
			{
d652 1
a652 1
			}
d657 1
a657 1
			{
d661 1
a661 1
			}
d667 1
a667 1
			{
d673 1
a673 1
				{
a676 1
				}
d678 1
d681 1
a681 1
			{
d685 1
a685 1
			}
d689 1
a689 1
			{
d694 2
a696 2
				if (!sk_eoc)
					{
d700 1
a700 1
					}
d704 1
a704 1
				}
d709 1
a709 1
				{
d713 1
a713 1
				}
d717 1
a717 1
				{
a720 1
				}
d722 1
d724 1
a724 1
			{
a726 1
			}
d728 1
d730 1
a730 1
		{
d735 1
a735 1
			{
d739 1
a739 1
			}
d742 1
a742 1
		}
d744 1
a744 1
		{
d749 1
a749 1
			{
d753 1
a753 1
			}
d756 1
a756 1
		}
d764 1
a764 1
	}
d770 1
a770 1
	{
d779 1
a779 1
		{
d782 1
a782 1
		}
d785 1
a785 1
		{
d788 1
a788 1
		}
d793 1
a793 1
		{
d797 1
a797 1
			{
d801 1
a801 1
			}
d803 1
a803 1
			{
d807 1
a807 1
			}
d812 1
a812 1
			{
d816 1
a816 1
			}
d819 1
a819 1
		}
d821 1
a821 1
		{
d824 1
a824 1
		}
d830 1
a830 1
		{
d833 1
a833 1
		}
d840 1
a840 1
		{
d845 1
a845 1
			{
d847 1
a847 1
			}
d850 1
a850 1
			{
d854 1
a854 1
			}
d859 1
a859 1
			{
d863 1
a863 1
			}
d865 1
a865 1
			{
a868 1
			}
d870 1
d872 1
a872 1
		{
d883 1
a883 1
			{
d886 1
a886 1
			}
d890 1
a890 1
			{
d894 1
a894 1
			}
d898 1
a898 1
		}
d900 1
a900 1
		{
d904 1
a904 1
		}
d915 1
a915 1
	}
d921 1
a921 1
	{
d934 2
a936 2
		if (!*pval)
			{
d941 1
a941 1
			}
d949 1
a949 1
		}
d951 1
a951 1
		{
d959 1
a959 1
			{
d963 1
a963 1
			}
d969 1
a969 1
			{
d973 1
a973 1
			}
d975 1
a975 1
			{
d979 1
a979 1
			}
d1017 1
a1017 1
			{
d1021 1
a1021 1
			}
d1023 1
a1023 1
			{
d1027 1
a1027 1
			}
d1030 1
a1030 1
			{
d1033 1
a1033 1
				{
d1037 1
a1037 1
				}
d1039 1
a1039 1
			}
d1041 1
a1041 1
			{
d1044 1
a1044 1
			}
d1047 1
a1047 1
			{
d1053 1
a1053 1
			}
d1055 2
a1057 2
			if (!ASN1_STRING_set(stmp, cont, len))
				{
a1062 1
				}
d1064 1
d1066 1
a1066 1
		}
d1074 1
a1074 1
		{
d1078 1
a1078 1
		}
d1080 1
a1080 1
	}
d1090 1
a1090 1
	{
d1096 1
a1096 1
		{
d1099 1
a1099 1
		}
d1107 2
a1109 2
		if(asn1_check_eoc(&p, len))
			{
d1115 1
a1115 1
			}
d1120 1
a1120 1
			{
d1123 1
a1123 1
			}
d1129 1
a1129 1
		}
d1131 1
a1131 1
		{
d1134 1
a1134 1
		}
d1137 1
a1137 1
	}
d1156 1
a1156 1
	{
d1165 1
a1165 1
		{
d1168 1
a1168 1
		}
d1170 1
a1170 1
		{
d1174 1
a1174 1
			{
d1178 1
a1178 1
				{
d1182 1
a1182 1
				}
d1185 1
a1185 1
			}
d1189 1
a1189 1
			{
d1192 1
a1192 1
			}
d1196 2
a1198 2
			if (depth >= ASN1_MAX_STRING_NEST)
				{
d1202 1
a1202 1
				}
d1206 1
a1206 1
			}
d1210 1
a1210 1
		}
d1212 1
a1212 1
		{
d1215 1
a1215 1
		}
d1218 1
a1218 1
	}
d1221 1
a1221 1
	{
d1224 1
a1224 1
		{
d1227 1
a1227 1
			{
d1230 1
a1230 1
			}
d1232 1
a1232 1
		}
d1235 1
a1235 1
	}
d1240 1
a1240 1
	{
d1245 1
a1245 1
		{
d1248 1
a1248 1
		}
d1250 1
a1250 1
	}
d1264 1
a1264 1
	{
d1273 1
a1273 1
		{
d1279 1
a1279 1
		}
d1281 1
a1281 1
		{
d1284 1
a1284 1
			{
d1295 1
a1295 1
				{
a1299 1
				}
d1302 1
d1305 1
a1305 1
		{
d1309 1
a1309 1
		}
d1311 2
a1313 2
		if ((exptag != ptag) || (expclass != pclass))
			{
d1321 1
a1321 1
			}
d1325 1
a1325 1
		}
d1347 1
a1347 1
	}
@


1.11
log
@openssl-1.0.0e: resolve conflicts
@
text
@d913 1
a913 1
	if (free_cont && buf.data) OPENSSL_free(buf.data);
d1049 1
a1049 1
				OPENSSL_free(stmp->data);
@


1.10
log
@resolve conflicts, fix local changes
@
text
@d171 1
a171 1
	ASN1_VALUE *pchval, **pchptr, *ptmpval;
a321 1
		pchval = NULL;
@


1.9
log
@resolve conflicts
@
text
@d117 2
d135 1
a135 1
	c.valid = 0;
d145 1
a145 1
	c.valid = 0;
d311 1
a311 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it))
d361 1
a361 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it))
d408 1
a408 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it))
d510 1
a510 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it))
d670 2
a671 1
			STACK *sktmp = (STACK *)*val;
d673 1
a673 1
			while(sk_num(sktmp) > 0)
d675 1
a675 1
				vtmp = (ASN1_VALUE *)sk_pop(sktmp);
d716 2
a717 1
			if (!sk_push((STACK *)*val, (char *)skfield))
@


1.8
log
@resolve conflicts
@
text
@d72 1
a72 1
				char inf, int tag, int aclass);
a613 1
	*val = NULL;
a759 1
	*val = NULL;
d879 1
a879 1
		if (!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL))
d1013 12
d1141 10
d1152 1
a1152 1
				char inf, int tag, int aclass)
d1194 8
a1201 2
#ifdef OPENSSL_ALLOW_NESTED_ASN1_STRINGS
			if (!asn1_collect(buf, &p, plen, ininf, tag, aclass))
a1202 4
#else
			ASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_NESTED_ASN1_STRING);
			return 0;
#endif
@


1.8.2.1
log
@MFC: fixes for OpenSSL ASN.1 invalid memory accesses (CVE-2009-0590 and
CVE-2009-0789).
@
text
@d614 1
d761 1
a1014 12
		if (utype == V_ASN1_BMPSTRING && (len & 1))
			{
			ASN1err(ASN1_F_ASN1_EX_C2I,
					ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
			goto err;
			}
		if (utype == V_ASN1_UNIVERSALSTRING && (len & 3))
			{
			ASN1err(ASN1_F_ASN1_EX_C2I,
					ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
			goto err;
			}
@


1.7
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.6
log
@openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@d6 1
a6 1
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
d68 26
a93 10
static int asn1_check_eoc(unsigned char **in, long len);
static int asn1_find_end(unsigned char **in, long len, char inf);
static int asn1_collect(BUF_MEM *buf, unsigned char **in, long len, char inf, int tag, int aclass);
static int collect_data(BUF_MEM *buf, unsigned char **p, long plen);
static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass, char *inf, char *cst,
			unsigned char **in, long len, int exptag, int expclass, char opt, ASN1_TLC *ctx);
static int asn1_template_ex_d2i(ASN1_VALUE **pval, unsigned char **in, long len, const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx);
static int asn1_template_noexp_d2i(ASN1_VALUE **val, unsigned char **in, long len, const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx);
static int asn1_d2i_ex_primitive(ASN1_VALUE **pval, unsigned char **in, long len,
					const ASN1_ITEM *it, int tag, int aclass, char opt, ASN1_TLC *ctx);
d96 1
a96 1
static unsigned long tag2bit[32]={
d101 1
a101 1
0,	0,	B_ASN1_NUMERICSTRING,B_ASN1_PRINTABLESTRING,   /* tags 16-19 */
d109 2
a110 2
{
	if((tag < 0) || (tag > 30)) return 0;
d112 1
a112 1
}
d116 1
a116 1
#define asn1_tlc_clear(c)	if(c) (c)->valid = 0
d126 3
a128 2
ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval, unsigned char **in, long len, const ASN1_ITEM *it)
{
d131 4
a134 3
	if(!pval) pval = &ptmpval;
	asn1_tlc_clear(&c);
	if(ASN1_item_ex_d2i(pval, in, len, it, -1, 0, 0, &c) > 0) 
d137 1
a137 1
}
d139 3
a141 2
int ASN1_template_d2i(ASN1_VALUE **pval, unsigned char **in, long len, const ASN1_TEMPLATE *tt)
{
d143 1
a143 1
	asn1_tlc_clear(&c);
d145 1
a145 1
}
d152 4
a155 3
int ASN1_item_ex_d2i(ASN1_VALUE **pval, unsigned char **in, long len, const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx)
{
d161 3
a163 1
	unsigned char *p, *q, imphack = 0, oclass;
d170 4
a173 2
	if(!pval) return 0;
	if(aux && aux->asn1_cb) asn1_cb = aux->asn1_cb;
d176 2
a177 2
	switch(it->itype) {

d179 7
a185 5
		if(it->templates) {
			/* tagging or OPTIONAL is currently illegal on an item template
			 * because the flags can't get passed down. In practice this isn't
			 * a problem: we include the relevant flags from the item template
			 * in the template itself.
d187 4
a190 2
			if ((tag != -1) || opt) {
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
d192 3
a194 2
			}
			return asn1_template_ex_d2i(pval, in, len, it->templates, opt, ctx);
d196 2
a197 1
		return asn1_d2i_ex_primitive(pval, in, len, it, tag, aclass, opt, ctx);
d203 6
a208 3
		ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL, &p, len, -1, 0, 1, ctx);
		if(!ret) {
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
d210 2
a211 1
		} 
d213 2
a214 1
		if(oclass != V_ASN1_UNIVERSAL) {
d216 3
a218 2
			if(opt) return -1;
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
d220 1
a220 1
		} 
d222 2
a223 1
		if(!(ASN1_tag2bit(otag) & it->utype)) {
d225 4
a228 2
			if(opt) return -1;
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
d230 3
a232 2
		} 
		return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);
d237 2
a238 1
		return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);
d245 2
a246 1
		if(opt) {
d249 2
a250 1
			if(tag == -1) exptag = it->utype;
d252 9
a260 4
			/* Don't care about anything other than presence of expected tag */
			ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL, &p, len, exptag, aclass, 1, ctx);
			if(!ret) {
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
d262 3
d266 1
a266 2
			if(ret == -1) return -1;
		}
d282 13
a294 5
		if(tag != -1) {
			p = *in;
			imphack = *p;
			*p = (unsigned char)((*p & V_ASN1_CONSTRUCTED) | it->utype);
		}
d298 5
a302 1
		if(tag != -1) *p = imphack;
a303 1
		if(ptmpval) return 1;
d309 1
a309 1
		if(asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it))
d313 5
a317 4
		if(!*pval) {
			if(!ASN1_item_ex_new(pval, it)) {
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
				goto err;
a318 1
		}
d322 2
a323 1
		for(i = 0, tt=it->templates; i < it->tcount; i++, tt++) {
d330 2
a331 1
			if(ret == -1) continue;
d333 2
a334 1
			if(ret > 0) break;
d337 2
a338 1
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
d340 2
a341 1
		}
d343 2
a344 1
		if(i == it->tcount) {
d346 2
a347 1
			if(opt) {
d351 4
d356 1
a356 3
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
			goto err;
		}
d359 1
a359 1
		if(asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it))
d363 1
d369 2
a370 1
		if(tag == -1) {
d373 1
a373 1
		}
d375 6
a380 3
		ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst, &p, len, tag, aclass, opt, ctx);
		if(!ret) {
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
d382 5
a386 2
		} else if(ret == -1) return -1;
		if(aux && (aux->flags & ASN1_AFLG_BROKEN)) {
d389 7
a395 3
		} else seq_nolen = seq_eoc;	/* If indefinite we don't do a length check */
		if(!cst) {
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
d397 1
a397 1
		}
d399 5
a403 4
		if(!*pval) {
			if(!ASN1_item_ex_new(pval, it)) {
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
				goto err;
d405 2
a406 2
		}
		if(asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it))
d410 2
a411 1
		for(i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
d415 2
a416 1
			if(!seqtt) goto err;
d419 2
a420 1
			if(!len) break;
d422 6
a427 3
			if(asn1_check_eoc(&p, len)) {
				if(!seq_eoc) {
					ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);
d429 1
a429 1
				}
d434 6
a439 5
			}
			/* This determines the OPTIONAL flag value. The field cannot
			 * be omitted if it is the last of a SEQUENCE and there is
			 * still data to be read. This isn't strictly necessary but
			 * it increases efficiency in some cases.
d441 2
a442 1
			if(i == (it->tcount - 1)) isopt = 0;
d444 7
a450 3
			/* attempt to read in field, allowing each to be OPTIONAL */
			ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
			if(!ret) {
d453 5
a457 2
			} else if(ret == -1) {
				/* OPTIONAL component absent. Free and zero the field
d461 1
a461 1
			}
d464 2
a465 1
		}
d467 2
a468 1
		if(seq_eoc && !asn1_check_eoc(&p, len)) {
d471 1
a471 1
		}
d473 4
a476 2
		if(!seq_nolen && len) {
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
d478 1
a478 1
		}
d484 2
a485 1
		for(; i < it->tcount; tt++, i++) {
d488 4
a491 2
			if(!seqtt) goto err;
			if(seqtt->flags & ASN1_TFLG_OPTIONAL) {
d495 3
a497 1
			} else {
d499 2
a500 1
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
d502 1
a503 1
		}
d505 2
a506 1
		if(!asn1_enc_save(pval, *in, p - *in, it)) goto auxerr;
d508 1
a508 1
		if(asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it))
d514 1
a514 1
	}
d519 5
a523 2
	if(errtt) ERR_add_error_data(4, "Field=", errtt->field_name, ", Type=", it->sname);
	else ERR_add_error_data(2, "Type=", it->sname);
d525 1
a525 1
}
d527 2
a528 2
/* Templates are handled with two separate functions. One handles any EXPLICIT tag and the other handles the
 * rest.
d531 5
a535 2
static int asn1_template_ex_d2i(ASN1_VALUE **val, unsigned char **in, long inlen, const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx)
{
d539 1
a539 1
	unsigned char *p, *q;
d541 2
a542 1
	if(!val) return 0;
d549 2
a550 1
	if(flags & ASN1_TFLG_EXPTAG) {
d552 3
a554 2
		/* Need to work out amount of data available to the inner content and where it
		 * starts: so read in EXPLICIT header to get the info.
d556 2
a557 1
		ret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst, &p, inlen, tt->tag, aclass, opt, ctx);
d559 4
a562 2
		if(!ret) {
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
d564 7
a570 3
		} else if(ret == -1) return -1;
		if(!cst) {
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
d572 1
a572 1
		}
d575 4
a578 2
		if(!ret) {
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
d580 1
a580 1
		}
d583 2
a584 1
		if(exp_eoc) {
d586 4
a589 2
			if(!asn1_check_eoc(&p, len)) {
				ASN1err(ASN1_F_ASN1_TEMPLATE_D2I, ASN1_R_MISSING_EOC);
d591 1
d593 8
a600 4
		} else {
			/* Otherwise we must hit the EXPLICIT tag end or its an error */
			if(len) {
				ASN1err(ASN1_F_ASN1_TEMPLATE_D2I, ASN1_R_EXPLICIT_LENGTH_MISMATCH);
d602 1
d605 3
a607 2
	} else 
		return asn1_template_noexp_d2i(val, in, inlen, tt, opt, ctx);
d616 1
a616 1
}
d618 5
a622 2
static int asn1_template_noexp_d2i(ASN1_VALUE **val, unsigned char **in, long len, const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx)
{
d625 3
a627 2
	unsigned char *p, *q;
	if(!val) return 0;
d634 2
a635 1
	if(flags & ASN1_TFLG_SK_MASK) {
d640 2
a641 1
		if(flags & ASN1_TFLG_IMPTAG) {
d644 3
a646 1
		} else {
d648 5
a652 3
			if(flags & ASN1_TFLG_SET_OF) sktag = V_ASN1_SET;
			else sktag = V_ASN1_SEQUENCE;
		}
d654 14
a667 7
		ret = asn1_check_tlen(&len, NULL, NULL, &sk_eoc, NULL, &p, len, sktag, skaclass, opt, ctx);
		if(!ret) {
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
			return 0;
		} else if(ret == -1) return -1;
		if(!*val) *val = (ASN1_VALUE *)sk_new_null();
		else {
d671 2
a672 1
			while(sk_num(sktmp) > 0) {
d674 3
a676 1
				ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
a677 1
		}
d679 4
a682 2
		if(!*val) {
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_MALLOC_FAILURE);
d684 2
a685 1
		}
d687 2
a688 1
		while(len > 0) {
d692 6
a697 3
			if(asn1_check_eoc(&p, len)) {
				if(!sk_eoc) {
					ASN1err(ASN1_F_ASN1_TEMPLATE_D2I, ASN1_R_UNEXPECTED_EOC);
d699 1
a699 1
				}
d703 1
a703 1
			}
d705 6
a710 2
			if(!ASN1_item_ex_d2i(&skfield, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0, 0, ctx)) {
				ASN1err(ASN1_F_ASN1_TEMPLATE_D2I, ERR_R_NESTED_ASN1_ERROR);
d712 1
a712 1
			}
d714 4
a717 2
			if(!sk_push((STACK *)*val, (char *)skfield)) {
				ASN1err(ASN1_F_ASN1_TEMPLATE_D2I, ERR_R_MALLOC_FAILURE);
d719 1
d721 3
a723 3
		}
		if(sk_eoc) {
			ASN1err(ASN1_F_ASN1_TEMPLATE_D2I, ASN1_R_MISSING_EOC);
d725 1
d727 2
a728 1
	} else if(flags & ASN1_TFLG_IMPTAG) {
d730 6
a735 3
		ret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), tt->tag, aclass, opt, ctx);
		if(!ret) {
			ASN1err(ASN1_F_ASN1_TEMPLATE_D2I, ERR_R_NESTED_ASN1_ERROR);
d737 6
a742 2
		} else if(ret == -1) return -1;
	} else {
d744 6
a749 3
		ret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0, opt, ctx);
		if(!ret) {
			ASN1err(ASN1_F_ASN1_TEMPLATE_D2I, ERR_R_NESTED_ASN1_ERROR);
d751 4
a754 2
		} else if(ret == -1) return -1;
	}
d763 1
a763 1
}
d765 5
a769 4
static int asn1_d2i_ex_primitive(ASN1_VALUE **pval, unsigned char **in, long inlen, 
						const ASN1_ITEM *it,
						int tag, int aclass, char opt, ASN1_TLC *ctx)
{
d773 1
a773 1
	unsigned char *p;
d775 1
a775 1
	unsigned char *cont = NULL;
d777 2
a778 1
	if(!pval) {
d781 1
a781 1
	}
d783 2
a784 1
	if(it->itype == ASN1_ITYPE_MSTRING) {
d787 3
a789 1
	} else utype = it->utype;
d791 2
a792 1
	if(utype == V_ASN1_ANY) {
d795 4
a798 2
		if(tag >= 0) {
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_TAGGED_ANY);
d800 5
a804 3
		}
		if(opt) {
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_OPTIONAL_ANY);
d806 1
a806 1
		}
d808 6
a813 3
		ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, NULL, &p, inlen, -1, 0, 0, ctx);
		if(!ret) {
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_NESTED_ASN1_ERROR);
d815 3
d819 2
a820 3
		if(oclass != V_ASN1_UNIVERSAL) utype = V_ASN1_OTHER;
	}
	if(tag == -1) {
d823 1
a823 1
	}
d826 4
a829 2
	ret = asn1_check_tlen(&plen, NULL, NULL, &inf, &cst, &p, inlen, tag, aclass, opt, ctx);
	if(!ret) {
d832 4
a835 3
	} else if(ret == -1) return -1;

	ret = 0;
d837 5
a841 3
	if((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) || (utype == V_ASN1_OTHER)) {
		/* Clear context cache for type OTHER because the auto clear when
		 * we have a exact match wont work
d843 2
a844 1
		if(utype == V_ASN1_OTHER) {
d846 1
d848 4
a851 2
		} else if(!cst) {
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_TYPE_NOT_CONSTRUCTED);
d853 1
a853 1
		}
d857 4
a860 2
		if(inf) {
			if(!asn1_find_end(&p, plen, inf)) goto err;
d862 3
a864 1
		} else {
d868 1
d870 2
a871 1
	} else if(cst) {
d881 5
a885 1
		if(!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL)) goto err;
d888 4
a891 2
		if(!BUF_MEM_grow_clean(&buf, len + 1)) {
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_MALLOC_FAILURE);
d893 1
a893 1
		}
d895 1
a895 1
		cont = (unsigned char *)buf.data;
d897 3
a899 1
	} else {
d903 1
a903 1
	}
d906 2
a907 1
	if(!asn1_ex_c2i(pval, cont, len, utype, &free_cont, it)) goto err;
d912 1
a912 1
	if(free_cont && buf.data) OPENSSL_free(buf.data);
d914 1
a914 1
}
d918 3
a920 2
int asn1_ex_c2i(ASN1_VALUE **pval, unsigned char *cont, int len, int utype, char *free_cont, const ASN1_ITEM *it)
{
d928 3
a930 1
	if(pf && pf->prim_c2i) return pf->prim_c2i(pval, cont, len, utype, free_cont, it);
d932 4
a935 2
	if(it->utype == V_ASN1_ANY) {
		if(!*pval) {
d937 2
d940 6
a945 2
		} else typ = (ASN1_TYPE *)*pval;
		if(utype != typ->type) ASN1_TYPE_set(typ, utype, NULL);
d947 4
a950 3
		pval = (ASN1_VALUE **)&typ->value.ptr;
	}
	switch(utype) {
d952 2
a953 1
		if(!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len)) goto err;
d957 4
a960 2
		if(len) {
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_NULL_IS_WRONG_LENGTH);
d962 1
a962 1
		}
d967 4
a970 2
		if(len != 1) {
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
d972 3
a974 1
		} else {
d978 1
a978 1
		}
d982 2
a983 1
		if(!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len)) goto err;
d991 2
a992 1
		if(!c2i_ASN1_INTEGER(tint, &cont, len)) goto err;
d1016 2
a1017 1
		if(!*pval) {
d1019 4
a1022 2
			if(!stmp) {
				ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_MALLOC_FAILURE);
d1024 2
d1027 2
a1028 2
			*pval = (ASN1_VALUE *)stmp;
		} else {
d1031 1
a1031 1
		}
d1033 5
a1037 3
		if(*free_cont) {
			if(stmp->data) OPENSSL_free(stmp->data);
			stmp->data = cont;
d1040 7
a1046 3
		} else {
			if(!ASN1_STRING_set(stmp, cont, len)) {
				ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_MALLOC_FAILURE);
d1050 1
d1052 1
a1053 2
		break;
	}
d1055 2
a1056 1
	if(typ && utype==V_ASN1_NULL) typ->value.ptr = NULL;
d1060 1
a1060 1
	if(!ret)
d1067 2
a1068 1
}
d1076 1
a1076 1
static int asn1_find_end(unsigned char **in, long len, char inf)
d1080 1
a1080 1
	unsigned char *p = *in, *q;
d1090 1
a1090 1
	 * are encountered increment the expected eoc count otherwise justi
a1124 1

d1131 4
a1134 3
static int asn1_collect(BUF_MEM *buf, unsigned char **in, long len, char inf, int tag, int aclass)
{
	unsigned char *p, *q;
d1139 9
a1147 1
	while(len > 0) {
d1150 8
a1157 4
		if(asn1_check_eoc(&p, len)) {
			/* EOC is illegal outside indefinite length constructed form */
			if(!inf) {
				ASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_UNEXPECTED_EOC);
d1159 1
a1159 1
			}
d1162 5
a1166 2
		}
		if(!asn1_check_tlen(&plen, NULL, NULL, &ininf, &cst, &p, len, tag, aclass, 0, NULL)) {
d1169 2
a1170 1
		}
d1172 2
a1173 1
		if(cst) {
d1181 4
a1184 2
		} else {
			if(plen && !collect_data(buf, &p, plen)) return 0;
d1186 2
a1187 3
		len -= p - q;
	}
	if(inf) {
d1190 1
a1190 1
	}
d1193 1
a1193 1
}
d1195 10
a1204 8
static int collect_data(BUF_MEM *buf, unsigned char **p, long plen)
{
		int len;
		if(buf) {
			len = buf->length;
			if(!BUF_MEM_grow_clean(buf, len + plen)) {
				ASN1err(ASN1_F_COLLECT_DATA, ERR_R_MALLOC_FAILURE);
				return 0;
d1206 1
a1206 1
			memcpy(buf->data + len, *p, plen);
d1208 3
a1210 3
		*p += plen;
		return 1;
}
d1214 4
a1217 4
static int asn1_check_eoc(unsigned char **in, long len)
{
	unsigned char *p;
	if(len < 2) return 0;
d1219 2
a1220 1
	if(!p[0] && !p[1]) {
d1223 2
a1225 2
	return 0;
}
d1234 6
a1239 3
static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass, char *inf, char *cst,
		unsigned char **in, long len, int exptag, int expclass, char opt, ASN1_TLC *ctx)
{
d1243 1
a1243 1
	unsigned char *p, *q;
d1247 2
a1248 1
	if(ctx && ctx->valid) {
d1254 3
a1256 1
	} else {
d1258 2
a1259 1
		if(ctx) {
d1269 4
a1272 2
			if(!(i & 0x81) && ((plen + ctx->hdrlen) > len)) {
				ASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_TOO_LONG);
d1275 1
a1277 1
	}
d1279 2
a1280 1
	if(i & 0x80) {
d1284 7
a1290 5
	}
	if(exptag >= 0) {
		if((exptag != ptag) || (expclass != pclass)) {
			/* If type is OPTIONAL, not an error, but indicate missing
			 * type.
d1292 1
a1292 1
			if(opt) return -1;
d1296 4
a1300 3
		/* We have a tag and class match, so assume we are going to do something with it */
		asn1_tlc_clear(ctx);
	}
d1302 8
a1309 1
	if(i & 1) plen = len - (p - q);
d1311 2
a1312 1
	if(inf) *inf = i & 1;
d1314 2
a1315 1
	if(cst) *cst = i & V_ASN1_CONSTRUCTED;
d1317 2
a1318 3
	if(olen) *olen = plen;
	if(oclass) *oclass = pclass;
	if(otag) *otag = ptag;
d1322 1
a1322 1
}
@


1.6.8.1
log
@MFC: fixes for OpenSSL ASN.1 invalid memory accesses (CVE-2009-0590 and
CVE-2009-0789).
@
text
@d477 1
d577 1
a770 12
		if (utype == V_ASN1_BMPSTRING && (len & 1))
			{
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
					ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
			goto err;
			}
		if (utype == V_ASN1_UNIVERSALSTRING && (len & 3))
			{
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
					ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
			goto err;
			}
@


1.6.6.1
log
@MFC: fixes for OpenSSL ASN.1 invalid memory accesses (CVE-2009-0590 and
CVE-2009-0789).
@
text
@d477 1
d577 1
a770 12
		if (utype == V_ASN1_BMPSTRING && (len & 1))
			{
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
					ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
			goto err;
			}
		if (utype == V_ASN1_UNIVERSALSTRING && (len & 3))
			{
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
					ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
			goto err;
			}
@


1.5
log
@resolve conflicts
@
text
@d632 2
@


1.5.2.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a631 2

	ret = 0;
@


1.4
log
@security fix from http://www.openssl.org/news/secadv_20030930.txt
see also http://cvs.openssl.org/chngview?cn=11471
@
text
@d69 1
d648 1
a648 1
			if(!asn1_collect(NULL, &p, plen, inf, -1, -1)) goto err;
d811 56
d870 1
a870 3
 * if it is indefinite length. If 'buf' is NULL then we just want
 * to find the end of the current structure: useful for indefinite
 * length constructed stuff.
a879 5
	/* If no buffer and not indefinite length constructed just pass over the encoded data */
	if(!buf && !inf) {
		*in += len;
		return 1;
	}
d898 7
a904 1
			if(!asn1_collect(buf, &p, plen, ininf, tag, aclass)) return 0;
d906 1
a906 1
			if(!collect_data(buf, &p, plen)) return 0;
@


1.4.8.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a630 2

	ret = 0;
@


1.4.10.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a630 2

	ret = 0;
@


1.3
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d694 1
d709 1
d801 6
a806 1
	if(!ret) ASN1_TYPE_free(typ);
@


1.3.2.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@a693 1
	ASN1_VALUE **opval = NULL;
a707 1
		opval = pval;
d799 1
a799 6
	if(!ret)
		{
		ASN1_TYPE_free(typ);
		if (opval)
			*opval = NULL;
		}
@


1.2
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d667 1
a667 1
		if(!BUF_MEM_grow(&buf, len + 1)) {
d860 1
a860 1
			if(!BUF_MEM_grow(buf, len + plen)) {
@


1.2.2.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@a693 1
	ASN1_VALUE **opval = NULL;
a707 1
		opval = pval;
d799 1
a799 6
	if(!ret)
		{
		ASN1_TYPE_free(typ);
		if (opval)
			*opval = NULL;
		}
@


1.2.4.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@a693 1
	ASN1_VALUE **opval = NULL;
a707 1
		opval = pval;
d799 1
a799 6
	if(!ret)
		{
		ASN1_TYPE_free(typ);
		if (opval)
			*opval = NULL;
		}
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d916 2
a917 2
			/* If definite length, length + header can't exceed total
			 * amount of data available.
d919 1
a919 1
			if(!(i & 1) && ((plen + ctx->hdrlen) > len)) {
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d916 2
a917 2
			/* If definite length, and no error, length +
			 * header can't exceed total amount of data available. 
d919 1
a919 1
			if(!(i & 0x81) && ((plen + ctx->hdrlen) > len)) {
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d667 1
a667 1
		if(!BUF_MEM_grow_clean(&buf, len + 1)) {
d860 1
a860 1
			if(!BUF_MEM_grow_clean(buf, len + plen)) {
@


1.1.1.4
log
@import 0.9.7c
@
text
@a693 1
	ASN1_VALUE **opval = NULL;
a707 1
		opval = pval;
d799 1
a799 6
	if(!ret)
		{
		ASN1_TYPE_free(typ);
		if (opval)
			*opval = NULL;
		}
@


1.1.1.5
log
@import of openssl-0.9.7j
@
text
@a68 1
static int asn1_find_end(unsigned char **in, long len, char inf);
d647 1
a647 1
			if(!asn1_find_end(&p, plen, inf)) goto err;
a809 56
/* This function finds the end of an ASN1 structure when passed its maximum
 * length, whether it is indefinite length and a pointer to the content.
 * This is more efficient than calling asn1_collect because it does not
 * recurse on each indefinite length header.
 */

static int asn1_find_end(unsigned char **in, long len, char inf)
	{
	int expected_eoc;
	long plen;
	unsigned char *p = *in, *q;
	/* If not indefinite length constructed just add length */
	if (inf == 0)
		{
		*in += len;
		return 1;
		}
	expected_eoc = 1;
	/* Indefinite length constructed form. Find the end when enough EOCs
	 * are found. If more indefinite length constructed headers
	 * are encountered increment the expected eoc count otherwise justi
	 * skip to the end of the data.
	 */
	while (len > 0)
		{
		if(asn1_check_eoc(&p, len))
			{
			expected_eoc--;
			if (expected_eoc == 0)
				break;
			len -= 2;
			continue;
			}
		q = p;
		/* Just read in a header: only care about the length */
		if(!asn1_check_tlen(&plen, NULL, NULL, &inf, NULL, &p, len,
				-1, 0, 0, NULL))
			{
			ASN1err(ASN1_F_ASN1_FIND_END, ERR_R_NESTED_ASN1_ERROR);
			return 0;
			}
		if (inf)
			expected_eoc++;
		else
			p += plen;
		len -= p - q;
		}
	if (expected_eoc)
		{
		ASN1err(ASN1_F_ASN1_FIND_END, ASN1_R_MISSING_EOC);
		return 0;
		}
	*in = p;
	return 1;
	}

d813 3
a815 1
 * if it is indefinite length.
d825 5
d848 1
a848 7
#ifdef OPENSSL_ALLOW_NESTED_ASN1_STRINGS
			if (!asn1_collect(buf, &p, plen, ininf, tag, aclass))
				return 0;
#else
			ASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_NESTED_ASN1_STRING);
			return 0;
#endif
d850 1
a850 1
			if(plen && !collect_data(buf, &p, plen)) return 0;
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d6 1
a6 1
 * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
d68 10
a77 26
static int asn1_check_eoc(const unsigned char **in, long len);
static int asn1_find_end(const unsigned char **in, long len, char inf);

static int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,
				char inf, int tag, int aclass);

static int collect_data(BUF_MEM *buf, const unsigned char **p, long plen);

static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
				char *inf, char *cst,
				const unsigned char **in, long len,
				int exptag, int expclass, char opt,
				ASN1_TLC *ctx);

static int asn1_template_ex_d2i(ASN1_VALUE **pval,
				const unsigned char **in, long len,
				const ASN1_TEMPLATE *tt, char opt,
				ASN1_TLC *ctx);
static int asn1_template_noexp_d2i(ASN1_VALUE **val,
				const unsigned char **in, long len,
				const ASN1_TEMPLATE *tt, char opt,
				ASN1_TLC *ctx);
static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
				const unsigned char **in, long len,
				const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx);
d80 1
a80 1
static const unsigned long tag2bit[32] = {
d85 1
a85 1
B_ASN1_SEQUENCE,0,B_ASN1_NUMERICSTRING,B_ASN1_PRINTABLESTRING, /* tags 16-19 */
d93 2
a94 2
	{
	if ((tag < 0) || (tag > 30)) return 0;
d96 1
a96 1
	}
d100 1
a100 1
#define asn1_tlc_clear(c)	if (c) (c)->valid = 0
d110 2
a111 3
ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval,
		const unsigned char **in, long len, const ASN1_ITEM *it)
	{
d114 3
a116 4
	if (!pval)
		pval = &ptmpval;
	c.valid = 0;
	if (ASN1_item_ex_d2i(pval, in, len, it, -1, 0, 0, &c) > 0) 
d119 1
a119 1
	}
d121 2
a122 3
int ASN1_template_d2i(ASN1_VALUE **pval,
		const unsigned char **in, long len, const ASN1_TEMPLATE *tt)
	{
d124 1
a124 1
	c.valid = 0;
d126 1
a126 1
	}
d133 3
a135 4
int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
			const ASN1_ITEM *it,
			int tag, int aclass, char opt, ASN1_TLC *ctx)
	{
d141 1
a141 3
	const unsigned char *p = NULL, *q;
	unsigned char *wp=NULL;	/* BIG FAT WARNING!  BREAKS CONST WHERE USED */
	unsigned char imphack = 0, oclass;
d148 2
a149 4
	if (!pval)
		return 0;
	if (aux && aux->asn1_cb)
		asn1_cb = aux->asn1_cb;
d152 2
a153 2
	switch(it->itype)
		{
d155 5
a159 7
		if (it->templates)
			{
			/* tagging or OPTIONAL is currently illegal on an item
			 * template because the flags can't get passed down.
			 * In practice this isn't a problem: we include the
			 * relevant flags from the item template in the
			 * template itself.
d161 2
a162 4
			if ((tag != -1) || opt)
				{
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
				ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
d164 2
a165 3
				}
			return asn1_template_ex_d2i(pval, in, len,
					it->templates, opt, ctx);
d167 1
a167 2
		return asn1_d2i_ex_primitive(pval, in, len, it,
						tag, aclass, opt, ctx);
d173 3
a175 6
		ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
						&p, len, -1, 0, 1, ctx);
		if (!ret)
			{
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
					ERR_R_NESTED_ASN1_ERROR);
d177 1
a177 2
			}

d179 1
a179 2
		if (oclass != V_ASN1_UNIVERSAL)
			{
d181 2
a182 3
			if (opt) return -1;
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
					ASN1_R_MSTRING_NOT_UNIVERSAL);
d184 1
a184 1
			}
d186 1
a186 2
		if (!(ASN1_tag2bit(otag) & it->utype))
			{
d188 2
a189 4
			if (opt)
				return -1;
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
					ASN1_R_MSTRING_WRONG_TAG);
d191 2
a192 3
			}
		return asn1_d2i_ex_primitive(pval, in, len,
						it, otag, 0, 0, ctx);
d197 1
a197 2
		return ef->asn1_ex_d2i(pval, in, len,
						it, tag, aclass, opt, ctx);
d204 1
a204 2
		if (opt)
			{
d207 1
a207 2
			if (tag == -1)
				exptag = it->utype;
d209 4
a212 9
			/* Don't care about anything other than presence
			 * of expected tag */

			ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
					&p, len, exptag, aclass, 1, ctx);
			if (!ret)
				{
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
					ERR_R_NESTED_ASN1_ERROR);
a213 3
				}
			if (ret == -1)
				return -1;
d215 2
a216 1

d232 5
a236 13
		if (tag != -1)
			{
			wp = *(unsigned char **)in;
			imphack = *wp;
			if (p == NULL)
				{
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
					ERR_R_NESTED_ASN1_ERROR);
				goto err;
				}
			*wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
								| it->utype);
			}
d240 1
a240 5
		if (tag != -1)
			*wp = imphack;

		if (ptmpval)
			return 1;
d242 1
d248 1
a248 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it))
d252 4
a255 5
		if (!*pval && !ASN1_item_ex_new(pval, it))
			{
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
						ERR_R_NESTED_ASN1_ERROR);
			goto err;
d257 1
d261 1
a261 2
		for (i = 0, tt=it->templates; i < it->tcount; i++, tt++)
			{
d268 1
a268 2
			if (ret == -1)
				continue;
d270 1
a270 2
			if (ret > 0)
				break;
d273 1
a273 2
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
						ERR_R_NESTED_ASN1_ERROR);
d275 1
a275 2
			}

d277 1
a277 2
		if (i == it->tcount)
			{
d279 1
a279 2
			if (opt)
				{
d283 2
a284 3
				}
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
					ASN1_R_NO_MATCHING_CHOICE_TYPE);
d286 1
a286 2
			}

d289 1
a289 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it))
a292 1
		case ASN1_ITYPE_NDEF_SEQUENCE:
d298 1
a298 2
		if (tag == -1)
			{
d301 1
a301 1
			}
d303 3
a305 6
		ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
					&p, len, tag, aclass, opt, ctx);
		if (!ret)
			{
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
					ERR_R_NESTED_ASN1_ERROR);
d307 2
a308 5
			}
		else if (ret == -1)
			return -1;
		if (aux && (aux->flags & ASN1_AFLG_BROKEN))
			{
d311 3
a313 7
			}
		/* If indefinite we don't do a length check */
		else seq_nolen = seq_eoc;
		if (!cst)
			{
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
				ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
d315 1
a315 1
			}
d317 4
a320 5
		if (!*pval && !ASN1_item_ex_new(pval, it))
			{
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
				ERR_R_NESTED_ASN1_ERROR);
			goto err;
d322 2
a323 2

		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it))
d327 1
a327 2
		for (i = 0, tt = it->templates; i < it->tcount; i++, tt++)
			{
d331 1
a331 2
			if (!seqtt)
				goto err;
d334 1
a334 2
			if (!len)
				break;
d336 3
a338 6
			if (asn1_check_eoc(&p, len))
				{
				if (!seq_eoc)
					{
					ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
							ASN1_R_UNEXPECTED_EOC);
d340 1
a340 1
					}
d345 5
a349 6
				}
			/* This determines the OPTIONAL flag value. The field
			 * cannot be omitted if it is the last of a SEQUENCE
			 * and there is still data to be read. This isn't
			 * strictly necessary but it increases efficiency in
			 * some cases.
d351 1
a351 2
			if (i == (it->tcount - 1))
				isopt = 0;
d353 3
a355 7
			/* attempt to read in field, allowing each to be
			 * OPTIONAL */

			ret = asn1_template_ex_d2i(pseqval, &p, len,
							seqtt, isopt, ctx);
			if (!ret)
				{
d358 2
a359 5
				}
			else if (ret == -1)
				{
				/* OPTIONAL component absent.
				 * Free and zero the field.
d363 1
a363 1
				}
d366 1
a366 2
			}

d368 1
a368 2
		if (seq_eoc && !asn1_check_eoc(&p, len))
			{
d371 1
a371 1
			}
d373 2
a374 4
		if (!seq_nolen && len)
			{
			ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
					ASN1_R_SEQUENCE_LENGTH_MISMATCH);
d376 1
a376 1
			}
d382 1
a382 2
		for (; i < it->tcount; tt++, i++)
			{
d385 2
a386 4
			if (!seqtt)
				goto err;
			if (seqtt->flags & ASN1_TFLG_OPTIONAL)
				{
d390 1
a390 3
				}
			else
				{
d392 1
a392 2
				ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
							ASN1_R_FIELD_MISSING);
a393 1
				}
d395 1
d397 1
a397 2
		if (!asn1_enc_save(pval, *in, p - *in, it))
			goto auxerr;
d399 1
a399 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it))
d405 1
a405 1
		}
d410 2
a411 5
	if (errtt)
		ERR_add_error_data(4, "Field=", errtt->field_name,
					", Type=", it->sname);
	else
		ERR_add_error_data(2, "Type=", it->sname);
d413 1
a413 1
	}
d415 2
a416 2
/* Templates are handled with two separate functions.
 * One handles any EXPLICIT tag and the other handles the rest.
d419 2
a420 5
static int asn1_template_ex_d2i(ASN1_VALUE **val,
				const unsigned char **in, long inlen,
				const ASN1_TEMPLATE *tt, char opt,
							ASN1_TLC *ctx)
	{
d424 1
a424 1
	const unsigned char *p, *q;
d426 1
a426 2
	if (!val)
		return 0;
d433 1
a433 2
	if (flags & ASN1_TFLG_EXPTAG)
		{
d435 2
a436 3
		/* Need to work out amount of data available to the inner
		 * content and where it starts: so read in EXPLICIT header to
		 * get the info.
d438 1
a438 2
		ret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst,
					&p, inlen, tt->tag, aclass, opt, ctx);
d440 2
a441 4
		if (!ret)
			{
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
					ERR_R_NESTED_ASN1_ERROR);
d443 3
a445 7
			}
		else if (ret == -1)
			return -1;
		if (!cst)
			{
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
					ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
d447 1
a447 1
			}
d450 2
a451 4
		if (!ret)
			{
			ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
					ERR_R_NESTED_ASN1_ERROR);
d453 1
a453 1
			}
d456 1
a456 2
		if (exp_eoc)
			{
d458 2
a459 4
			if (!asn1_check_eoc(&p, len))
				{
				ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
						ASN1_R_MISSING_EOC);
a460 1
				}
d462 4
a465 8
		else
			{
			/* Otherwise we must hit the EXPLICIT tag end or its
			 * an error */
			if (len)
				{
				ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
					ASN1_R_EXPLICIT_LENGTH_MISMATCH);
a466 1
				}
d469 2
a470 3
		else 
			return asn1_template_noexp_d2i(val, in, inlen,
								tt, opt, ctx);
d479 1
a479 1
	}
d481 2
a482 5
static int asn1_template_noexp_d2i(ASN1_VALUE **val,
				const unsigned char **in, long len,
				const ASN1_TEMPLATE *tt, char opt,
				ASN1_TLC *ctx)
	{
d485 2
a486 3
	const unsigned char *p, *q;
	if (!val)
		return 0;
d493 1
a493 2
	if (flags & ASN1_TFLG_SK_MASK)
		{
d498 1
a498 2
		if (flags & ASN1_TFLG_IMPTAG)
			{
d501 1
a501 3
			}
		else
			{
d503 3
a505 5
			if (flags & ASN1_TFLG_SET_OF)
				sktag = V_ASN1_SET;
			else
				sktag = V_ASN1_SEQUENCE;
			}
d507 7
a513 14
		ret = asn1_check_tlen(&len, NULL, NULL, &sk_eoc, NULL,
					&p, len, sktag, skaclass, opt, ctx);
		if (!ret)
			{
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
						ERR_R_NESTED_ASN1_ERROR);
			return 0;
			}
		else if (ret == -1)
			return -1;
		if (!*val)
			*val = (ASN1_VALUE *)sk_new_null();
		else
			{
d517 1
a517 2
			while(sk_num(sktmp) > 0)
				{
d519 1
a519 3
				ASN1_item_ex_free(&vtmp,
						ASN1_ITEM_ptr(tt->item));
				}
d521 1
d523 2
a524 4
		if (!*val)
			{
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
						ERR_R_MALLOC_FAILURE);
d526 1
a526 2
			}

d528 1
a528 2
		while(len > 0)
			{
d532 3
a534 6
			if (asn1_check_eoc(&p, len))
				{
				if (!sk_eoc)
					{
					ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
							ASN1_R_UNEXPECTED_EOC);
d536 1
a536 1
					}
d540 1
a540 1
				}
d542 2
a543 6
			if (!ASN1_item_ex_d2i(&skfield, &p, len,
						ASN1_ITEM_ptr(tt->item),
						-1, 0, 0, ctx))
				{
				ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
					ERR_R_NESTED_ASN1_ERROR);
d545 1
a545 1
				}
d547 2
a548 4
			if (!sk_push((STACK *)*val, (char *)skfield))
				{
				ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
						ERR_R_MALLOC_FAILURE);
a549 1
				}
d551 3
a553 3
		if (sk_eoc)
			{
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ASN1_R_MISSING_EOC);
a554 1
			}
d556 1
a556 2
	else if (flags & ASN1_TFLG_IMPTAG)
		{
d558 3
a560 6
		ret = ASN1_item_ex_d2i(val, &p, len,
			ASN1_ITEM_ptr(tt->item), tt->tag, aclass, opt, ctx);
		if (!ret)
			{
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
						ERR_R_NESTED_ASN1_ERROR);
d562 2
a563 6
			}
		else if (ret == -1)
			return -1;
		}
	else
		{
d565 3
a567 6
		ret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item),
							-1, 0, opt, ctx);
		if (!ret)
			{
			ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
					ERR_R_NESTED_ASN1_ERROR);
d569 2
a570 4
			}
		else if (ret == -1)
			return -1;
		}
d579 1
a579 1
	}
d581 4
a584 5
static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
				const unsigned char **in, long inlen, 
				const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx)
	{
d588 1
a588 1
	const unsigned char *p;
d590 1
a590 1
	const unsigned char *cont = NULL;
d592 1
a592 2
	if (!pval)
		{
d595 1
a595 1
		}
d597 1
a597 2
	if (it->itype == ASN1_ITYPE_MSTRING)
		{
d600 1
a600 3
		}
	else
		utype = it->utype;
d602 1
a602 2
	if (utype == V_ASN1_ANY)
		{
d605 2
a606 4
		if (tag >= 0)
			{
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
					ASN1_R_ILLEGAL_TAGGED_ANY);
d608 3
a610 5
			}
		if (opt)
			{
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
					ASN1_R_ILLEGAL_OPTIONAL_ANY);
d612 1
a612 1
			}
d614 3
a616 6
		ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, NULL,
					&p, inlen, -1, 0, 0, ctx);
		if (!ret)
			{
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
					ERR_R_NESTED_ASN1_ERROR);
a617 3
			}
		if (oclass != V_ASN1_UNIVERSAL)
			utype = V_ASN1_OTHER;
d619 3
a621 2
	if (tag == -1)
		{
d624 1
a624 1
		}
d627 2
a628 4
	ret = asn1_check_tlen(&plen, NULL, NULL, &inf, &cst,
				&p, inlen, tag, aclass, opt, ctx);
	if (!ret)
		{
d631 1
a631 4
		}
	else if (ret == -1)
		return -1;
        ret = 0;
d633 3
a635 5
	if ((utype == V_ASN1_SEQUENCE)
		|| (utype == V_ASN1_SET) || (utype == V_ASN1_OTHER))
		{
		/* Clear context cache for type OTHER because the auto clear
		 * when we have a exact match wont work
d637 1
a637 2
		if (utype == V_ASN1_OTHER)
			{
a638 1
			}
d640 2
a641 4
		else if (!cst)
			{
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
				ASN1_R_TYPE_NOT_CONSTRUCTED);
d643 1
a643 1
			}
d647 2
a648 4
		if (inf)
			{
			if (!asn1_find_end(&p, plen, inf))
				 goto err;
d650 1
a650 3
			}
		else
			{
a653 1
			}
d655 1
a655 2
	else if (cst)
		{
d665 1
a665 5
		if (!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL))
			{
			free_cont = 1;
			goto err;
			}
d668 2
a669 4
		if (!BUF_MEM_grow_clean(&buf, len + 1))
			{
			ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
						ERR_R_MALLOC_FAILURE);
d671 1
a671 1
			}
d673 1
a673 1
		cont = (const unsigned char *)buf.data;
d675 1
a675 3
		}
	else
		{
d679 1
a679 1
		}
d682 1
a682 2
	if (!asn1_ex_c2i(pval, cont, len, utype, &free_cont, it))
		goto err;
d687 1
a687 1
	if (free_cont && buf.data) OPENSSL_free(buf.data);
d689 1
a689 1
	}
d693 2
a694 3
int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
			int utype, char *free_cont, const ASN1_ITEM *it)
	{
d702 1
a702 3

	if (pf && pf->prim_c2i)
		return pf->prim_c2i(pval, cont, len, utype, free_cont, it);
d704 2
a705 4
	if (it->utype == V_ASN1_ANY)
		{
		if (!*pval)
			{
a706 2
			if (typ == NULL)
				goto err;
d708 2
a709 6
			}
		else
			typ = (ASN1_TYPE *)*pval;

		if (utype != typ->type)
			ASN1_TYPE_set(typ, utype, NULL);
d711 3
a713 4
		pval = &typ->value.asn1_value;
		}
	switch(utype)
		{
d715 1
a715 2
		if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len))
			goto err;
d719 2
a720 4
		if (len)
			{
			ASN1err(ASN1_F_ASN1_EX_C2I,
						ASN1_R_NULL_IS_WRONG_LENGTH);
d722 1
a722 1
			}
d727 2
a728 4
		if (len != 1)
			{
			ASN1err(ASN1_F_ASN1_EX_C2I,
						ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
d730 1
a730 3
			}
		else
			{
d734 1
a734 1
			}
d738 1
a738 2
		if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len))
			goto err;
d746 1
a746 2
		if (!c2i_ASN1_INTEGER(tint, &cont, len))
			goto err;
d770 1
a770 2
		if (!*pval)
			{
d772 2
a773 4
			if (!stmp)
				{
				ASN1err(ASN1_F_ASN1_EX_C2I,
							ERR_R_MALLOC_FAILURE);
d775 1
a775 1
				}
d777 1
a777 3
			}
		else
			{
d780 1
a780 1
			}
d782 3
a784 5
		if (*free_cont)
			{
			if (stmp->data)
				OPENSSL_free(stmp->data);
			stmp->data = (unsigned char *)cont; /* UGLY CAST! RL */
d787 3
a789 7
			}
		else
			{
			if (!ASN1_STRING_set(stmp, cont, len))
				{
				ASN1err(ASN1_F_ASN1_EX_C2I,
							ERR_R_MALLOC_FAILURE);
a792 1
				}
d794 1
d796 1
a796 1
		}
d798 1
a798 2
	if (typ && (utype == V_ASN1_NULL))
		 typ->value.ptr = NULL;
d802 1
a802 1
	if (!ret)
d809 1
a809 2
	}

d817 1
a817 1
static int asn1_find_end(const unsigned char **in, long len, char inf)
d821 1
a821 1
	const unsigned char *p = *in, *q;
d831 1
a831 1
	 * are encountered increment the expected eoc count otherwise just
d866 1
d873 3
a875 4
static int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,
				char inf, int tag, int aclass)
	{
	const unsigned char *p, *q;
d880 1
a880 9
	/* If no buffer and not indefinite length constructed just pass over
	 * the encoded data */
	if (!buf && !inf)
		{
		*in += len;
		return 1;
		}
	while(len > 0)
		{
d883 4
a886 8
		if (asn1_check_eoc(&p, len))
			{
			/* EOC is illegal outside indefinite length
			 * constructed form */
			if (!inf)
				{
				ASN1err(ASN1_F_ASN1_COLLECT,
					ASN1_R_UNEXPECTED_EOC);
d888 1
a888 1
				}
d891 2
a892 5
			}

		if (!asn1_check_tlen(&plen, NULL, NULL, &ininf, &cst, &p,
					len, tag, aclass, 0, NULL))
			{
d895 1
a895 2
			}

d897 1
a897 2
		if (cst)
			{
d905 3
a907 3
			}
		else if (plen && !collect_data(buf, &p, plen))
			return 0;
d909 2
a910 3
		}
	if (inf)
		{
d913 1
a913 1
		}
d916 1
a916 1
	}
d918 8
a925 10
static int collect_data(BUF_MEM *buf, const unsigned char **p, long plen)
	{
	int len;
	if (buf)
		{
		len = buf->length;
		if (!BUF_MEM_grow_clean(buf, len + plen))
			{
			ASN1err(ASN1_F_COLLECT_DATA, ERR_R_MALLOC_FAILURE);
			return 0;
d927 1
a927 1
		memcpy(buf->data + len, *p, plen);
d929 3
a931 3
	*p += plen;
	return 1;
	}
d935 4
a938 4
static int asn1_check_eoc(const unsigned char **in, long len)
	{
	const unsigned char *p;
	if (len < 2) return 0;
d940 1
a940 2
	if (!p[0] && !p[1])
		{
d943 1
a943 1
		}
d945 1
a945 1
	}
d954 3
a956 6
static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
				char *inf, char *cst,
				const unsigned char **in, long len,
				int exptag, int expclass, char opt,
				ASN1_TLC *ctx)
	{
d960 1
a960 1
	const unsigned char *p, *q;
d964 1
a964 2
	if (ctx && ctx->valid)
		{
d970 1
a970 3
		}
	else
		{
d972 1
a972 2
		if (ctx)
			{
d982 2
a983 4
			if (!(i & 0x81) && ((plen + ctx->hdrlen) > len))
				{
				ASN1err(ASN1_F_ASN1_CHECK_TLEN,
							ASN1_R_TOO_LONG);
a985 1
				}
d988 1
d990 1
a990 2
	if (i & 0x80)
		{
d994 5
a998 7
		}
	if (exptag >= 0)
		{
		if ((exptag != ptag) || (expclass != pclass))
			{
			/* If type is OPTIONAL, not an error:
			 * indicate missing type.
d1000 1
a1000 1
			if (opt) return -1;
d1004 2
a1005 3
			}
		/* We have a tag and class match:
		 * assume we are going to do something with it */
d1007 1
a1007 4
		}

	if (i & 1)
		plen = len - (p - q);
d1009 1
a1009 2
	if (inf)
		*inf = i & 1;
d1011 1
a1011 2
	if (cst)
		*cst = i & V_ASN1_CONSTRUCTED;
d1013 1
a1013 2
	if (olen)
		*olen = plen;
d1015 3
a1017 5
	if (oclass)
		*oclass = pclass;

	if (otag)
		*otag = ptag;
d1021 1
a1021 1
	}
@


1.1.1.7
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.8
log
@import of OpenSSL 0.9.8k
@
text
@d72 1
a72 1
			char inf, int tag, int aclass, int depth);
d614 1
d761 1
d881 1
a881 1
		if (!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL, 0))
a1014 12
		if (utype == V_ASN1_BMPSTRING && (len & 1))
			{
			ASN1err(ASN1_F_ASN1_EX_C2I,
					ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
			goto err;
			}
		if (utype == V_ASN1_UNIVERSALSTRING && (len & 3))
			{
			ASN1err(ASN1_F_ASN1_EX_C2I,
					ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
			goto err;
			}
a1130 10
#ifndef ASN1_MAX_STRING_NEST
/* This determines how many levels of recursion are permitted in ASN1
 * string types. If it is not limited stack overflows can occur. If set
 * to zero no recursion is allowed at all. Although zero should be adequate
 * examples exist that require a value of 1. So 5 should be more than enough.
 */
#define ASN1_MAX_STRING_NEST 5
#endif


d1132 1
a1132 1
			char inf, int tag, int aclass, int depth)
d1174 2
a1175 8
			if (depth >= ASN1_MAX_STRING_NEST)
				{
				ASN1err(ASN1_F_ASN1_COLLECT,
					ASN1_R_NESTED_ASN1_STRING);
				return 0;
				}
			if (!asn1_collect(buf, &p, plen, ininf, tag, aclass,
						depth + 1))
d1177 4
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@a116 2
/* Version to avoid compiler warning about 'c' always non-NULL */
#define asn1_tlc_clear_nc(c)	(c)->valid = 0
d133 1
a133 1
	asn1_tlc_clear_nc(&c);
d143 1
a143 1
	asn1_tlc_clear_nc(&c);
d309 1
a309 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
d359 1
a359 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
d406 1
a406 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
d508 1
a508 1
		if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
d668 1
a668 2
			STACK_OF(ASN1_VALUE) *sktmp
			    = (STACK_OF(ASN1_VALUE) *)*val;
d670 1
a670 1
			while(sk_ASN1_VALUE_num(sktmp) > 0)
d672 1
a672 1
				vtmp = sk_ASN1_VALUE_pop(sktmp);
d713 1
a713 2
			if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val,
						skfield))
@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@d171 1
a171 1
	ASN1_VALUE **pchptr, *ptmpval;
d322 1
@


