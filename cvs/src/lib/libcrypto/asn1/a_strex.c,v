head	1.25;
access;
symbols
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25;
locks; strict;
comment	@ * @;


1.25
date	2015.02.07.13.19.15;	author doug;	state Exp;
branches;
next	1.24;
commitid	gtwLkRyWx0K1HbzX;

1.24
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.23;
commitid	yQEL1wOWIearrW15;

1.23
date	2014.07.10.20.42.45;	author jsing;	state Exp;
branches;
next	1.22;
commitid	20VSMAFx2CbvQ9nw;

1.22
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	mJUVYpkFBZ0Zv2bG;

1.21
date	2014.05.29.20.21.22;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.20.01.21.52;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.18.19.30.36;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.19.13.11.41;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.18.00.58.49;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.17.19.33.42;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.09.12.15.26;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.17;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.14.11.18.02;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.15.02.29.10;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.15.02.57.06;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.47;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.35.37;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.12.20.43.58;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.31;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.11.54;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.41.33;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.37.02;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.40;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.13.51;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.08;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Delete a lot of #if 0 code in libressl.

There are a few instances where #if 1 is removed but the code remains.

Based on the following OpenSSL commits.  Some of the commits weren't
strictly deletions so they are going to be split up into separate commits.

6f91b017bbb7140f816721141ac156d1b828a6b3
3d47c1d331fdc7574d2275cda1a630ccdb624b08
dfb56425b68314b2b57e17c82c1df42e7a015132
c8fa2356a00cbaada8963f739e5570298311a060
f16a64d11f55c01f56baa62ebf1dec7f8fe718cb
9ccc00ef6ea65567622e40c49aca43f2c6d79cdb
02a938c953b3e1ced71d9a832de1618f907eb96d
75d0ebef2aef7a2c77b27575b8da898e22f3ccd5
d6fbb194095312f4722c81c9362dbd0de66cb656
6f1a93ad111c7dfe36a09a976c4c009079b19ea1
1a5adcfb5edfe23908b350f8757df405b0f5f71f
8de24b792743d11e1d5a0dcd336a49368750c577
a2b18e657ea1a932d125154f4e13ab2258796d90
8e964419603d2478dfb391c66e7ccb2dcc9776b4
32dfde107636ac9bc62a5b3233fe2a54dbc27008

input + ok jsing@@, miod@@, tedu@@
@
text
@/* $OpenBSD: a_strex.c,v 1.24 2014/07/11 08:44:47 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/asn1.h>
#include <openssl/crypto.h>
#include <openssl/x509.h>

#include "asn1_locl.h"

#include "charmap.h"

/* ASN1_STRING_print_ex() and X509_NAME_print_ex().
 * Enhanced string and name printing routines handling
 * multibyte characters, RFC2253 and a host of other
 * options.
 */

#define CHARTYPE_BS_ESC		(ASN1_STRFLGS_ESC_2253 | CHARTYPE_FIRST_ESC_2253 | CHARTYPE_LAST_ESC_2253)

#define ESC_FLAGS (ASN1_STRFLGS_ESC_2253 | \
		  ASN1_STRFLGS_ESC_QUOTE | \
		  ASN1_STRFLGS_ESC_CTRL | \
		  ASN1_STRFLGS_ESC_MSB)


/* Three IO functions for sending data to memory, a BIO and
 * and a FILE pointer.
 */
static int
send_bio_chars(void *arg, const void *buf, int len)
{
	if (!arg)
		return 1;
	if (BIO_write(arg, buf, len) != len)
		return 0;
	return 1;
}

static int
send_fp_chars(void *arg, const void *buf, int len)
{
	if (!arg)
		return 1;
	if (fwrite(buf, 1, (size_t)len, arg) != (size_t)len)
		return 0;
	return 1;
}

typedef int char_io(void *arg, const void *buf, int len);

/* This function handles display of
 * strings, one character at a time.
 * It is passed an unsigned long for each
 * character because it could come from 2 or even
 * 4 byte forms.
 */

static int
do_esc_char(unsigned long c, unsigned char flags, char *do_quotes,
    char_io *io_ch, void *arg)
{
	unsigned char chflgs, chtmp;
	char tmphex[sizeof(long) * 2 + 3];

	if (c > 0xffffffffL)
		return -1;
	if (c > 0xffff) {
		snprintf(tmphex, sizeof tmphex, "\\W%08lX", c);
		if (!io_ch(arg, tmphex, 10))
			return -1;
		return 10;
	}
	if (c > 0xff) {
		snprintf(tmphex, sizeof tmphex, "\\U%04lX", c);
		if (!io_ch(arg, tmphex, 6))
			return -1;
		return 6;
	}
	chtmp = (unsigned char)c;
	if (chtmp > 0x7f)
		chflgs = flags & ASN1_STRFLGS_ESC_MSB;
	else
		chflgs = char_type[chtmp] & flags;
	if (chflgs & CHARTYPE_BS_ESC) {
		/* If we don't escape with quotes, signal we need quotes */
		if (chflgs & ASN1_STRFLGS_ESC_QUOTE) {
			if (do_quotes)
				*do_quotes = 1;
			if (!io_ch(arg, &chtmp, 1))
				return -1;
			return 1;
		}
		if (!io_ch(arg, "\\", 1))
			return -1;
		if (!io_ch(arg, &chtmp, 1))
			return -1;
		return 2;
	}
	if (chflgs & (ASN1_STRFLGS_ESC_CTRL|ASN1_STRFLGS_ESC_MSB)) {
		snprintf(tmphex, sizeof tmphex, "\\%02X", chtmp);
		if (!io_ch(arg, tmphex, 3))
			return -1;
		return 3;
	}
	/* If we get this far and do any escaping at all must escape
	 * the escape character itself: backslash.
	 */
	if (chtmp == '\\' && flags & ESC_FLAGS) {
		if (!io_ch(arg, "\\\\", 2))
			return -1;
		return 2;
	}
	if (!io_ch(arg, &chtmp, 1))
		return -1;
	return 1;
}

#define BUF_TYPE_WIDTH_MASK	0x7
#define BUF_TYPE_CONVUTF8	0x8

/* This function sends each character in a buffer to
 * do_esc_char(). It interprets the content formats
 * and converts to or from UTF8 as appropriate.
 */

static int
do_buf(unsigned char *buf, int buflen, int type, unsigned char flags,
    char *quotes, char_io *io_ch, void *arg)
{
	int i, outlen, len;
	unsigned char orflags, *p, *q;
	unsigned long c;

	p = buf;
	q = buf + buflen;
	outlen = 0;
	while (p != q) {
		if (p == buf && flags & ASN1_STRFLGS_ESC_2253)
			orflags = CHARTYPE_FIRST_ESC_2253;
		else
			orflags = 0;
		switch (type & BUF_TYPE_WIDTH_MASK) {
		case 4:
			c = ((unsigned long)*p++) << 24;
			c |= ((unsigned long)*p++) << 16;
			c |= ((unsigned long)*p++) << 8;
			c |= *p++;
			if (c > UNICODE_MAX || UNICODE_IS_SURROGATE(c))
				return -1;
			break;

		case 2:
			c = ((unsigned long)*p++) << 8;
			c |= *p++;
			if (UNICODE_IS_SURROGATE(c))
				return -1;
			break;

		case 1:
			c = *p++;
			break;

		case 0:
			i = UTF8_getc(p, q - p, &c);
			if (i < 0)
				return -1;	/* Invalid UTF8String */
			p += i;
			break;
		default:
			return -1;		/* invalid width */
		}
		if (p == q && flags & ASN1_STRFLGS_ESC_2253)
			orflags = CHARTYPE_LAST_ESC_2253;
		if (type & BUF_TYPE_CONVUTF8) {
			unsigned char utfbuf[6];
			int utflen;

			utflen = UTF8_putc(utfbuf, sizeof utfbuf, c);
			if (utflen < 0)
				return -1;
			for (i = 0; i < utflen; i++) {
				/* We don't need to worry about setting orflags correctly
				 * because if utflen==1 its value will be correct anyway
				 * otherwise each character will be > 0x7f and so the
				 * character will never be escaped on first and last.
				 */
				len = do_esc_char(utfbuf[i],
				    (unsigned char)(flags | orflags), quotes,
				    io_ch, arg);
				if (len < 0)
					return -1;
				outlen += len;
			}
		} else {
			len = do_esc_char(c, (unsigned char)(flags | orflags),
			    quotes, io_ch, arg);
			if (len < 0)
				return -1;
			outlen += len;
		}
	}
	return outlen;
}

/* This function hex dumps a buffer of characters */

static int
do_hex_dump(char_io *io_ch, void *arg, unsigned char *buf, int buflen)
{
	static const char hexdig[] = "0123456789ABCDEF";
	unsigned char *p, *q;
	char hextmp[2];
	if (arg) {
		p = buf;
		q = buf + buflen;
		while (p != q) {
			hextmp[0] = hexdig[*p >> 4];
			hextmp[1] = hexdig[*p & 0xf];
			if (!io_ch(arg, hextmp, 2))
				return -1;
			p++;
		}
	}
	return buflen << 1;
}

/* "dump" a string. This is done when the type is unknown,
 * or the flags request it. We can either dump the content
 * octets or the entire DER encoding. This uses the RFC2253
 * #01234 format.
 */

static int
do_dump(unsigned long lflags, char_io *io_ch, void *arg, ASN1_STRING *str)
{
	/* Placing the ASN1_STRING in a temp ASN1_TYPE allows
	 * the DER encoding to readily obtained
	 */
	ASN1_TYPE t;
	unsigned char *der_buf, *p;
	int outlen, der_len;

	if (!io_ch(arg, "#", 1))
		return -1;
	/* If we don't dump DER encoding just dump content octets */
	if (!(lflags & ASN1_STRFLGS_DUMP_DER)) {
		outlen = do_hex_dump(io_ch, arg, str->data, str->length);
		if (outlen < 0)
			return -1;
		return outlen + 1;
	}
	t.type = str->type;
	t.value.ptr = (char *)str;
	der_len = i2d_ASN1_TYPE(&t, NULL);
	der_buf = malloc(der_len);
	if (!der_buf)
		return -1;
	p = der_buf;
	i2d_ASN1_TYPE(&t, &p);
	outlen = do_hex_dump(io_ch, arg, der_buf, der_len);
	free(der_buf);
	if (outlen < 0)
		return -1;
	return outlen + 1;
}

/* Lookup table to convert tags to character widths,
 * 0 = UTF8 encoded, -1 is used for non string types
 * otherwise it is the number of bytes per character
 */

static const signed char tag2nbyte[] = {
	-1, -1, -1, -1, -1,	/* 0-4 */
	-1, -1, -1, -1, -1,	/* 5-9 */
	-1, -1, 0, -1,		/* 10-13 */
	-1, -1, -1, -1,		/* 15-17 */
	-1, 1, 1,		/* 18-20 */
	-1, 1, 1, 1,		/* 21-24 */
	-1, 1, -1,		/* 25-27 */
	4, -1, 2		/* 28-30 */
};

/* This is the main function, print out an
 * ASN1_STRING taking note of various escape
 * and display options. Returns number of
 * characters written or -1 if an error
 * occurred.
 */

static int
do_print_ex(char_io *io_ch, void *arg, unsigned long lflags, ASN1_STRING *str)
{
	int outlen, len;
	int type;
	char quotes;
	unsigned char flags;

	quotes = 0;
	/* Keep a copy of escape flags */
	flags = (unsigned char)(lflags & ESC_FLAGS);
	type = str->type;
	outlen = 0;

	if (lflags & ASN1_STRFLGS_SHOW_TYPE) {
		const char *tagname;
		tagname = ASN1_tag2str(type);
		outlen += strlen(tagname);
		if (!io_ch(arg, tagname, outlen) || !io_ch(arg, ":", 1))
			return -1;
		outlen++;
	}

	/* Decide what to do with type, either dump content or display it */

	/* Dump everything */
	if (lflags & ASN1_STRFLGS_DUMP_ALL)
		type = -1;
	/* Ignore the string type */
	else if (lflags & ASN1_STRFLGS_IGNORE_TYPE)
		type = 1;
	else {
		/* Else determine width based on type */
		if ((type > 0) && (type < 31))
			type = tag2nbyte[type];
		else
			type = -1;
		if ((type == -1) && !(lflags & ASN1_STRFLGS_DUMP_UNKNOWN))
			type = 1;
	}

	if (type == -1) {
		len = do_dump(lflags, io_ch, arg, str);
		if (len < 0)
			return -1;
		outlen += len;
		return outlen;
	}

	if (lflags & ASN1_STRFLGS_UTF8_CONVERT) {
		/* Note: if string is UTF8 and we want
		 * to convert to UTF8 then we just interpret
		 * it as 1 byte per character to avoid converting
		 * twice.
		 */
		if (!type)
			type = 1;
		else
			type |= BUF_TYPE_CONVUTF8;
	}

	len = do_buf(str->data, str->length, type, flags, &quotes, io_ch, NULL);
	if (len < 0)
		return -1;
	outlen += len;
	if (quotes)
		outlen += 2;
	if (!arg)
		return outlen;
	if (quotes && !io_ch(arg, "\"", 1))
		return -1;
	if (do_buf(str->data, str->length, type, flags, NULL, io_ch, arg) < 0)
		return -1;
	if (quotes && !io_ch(arg, "\"", 1))
		return -1;
	return outlen;
}

/* Used for line indenting: print 'indent' spaces */

static int
do_indent(char_io *io_ch, void *arg, int indent)
{
	int i;
	for (i = 0; i < indent; i++)
		if (!io_ch(arg, " ", 1))
			return 0;
	return 1;
}

#define FN_WIDTH_LN	25
#define FN_WIDTH_SN	10

static int
do_name_ex(char_io *io_ch, void *arg, X509_NAME *n, int indent,
    unsigned long flags)
{
	int i, prev = -1, orflags, cnt;
	int fn_opt, fn_nid;
	ASN1_OBJECT *fn;
	ASN1_STRING *val;
	X509_NAME_ENTRY *ent;
	char objtmp[80];
	const char *objbuf;
	int outlen, len;
	char *sep_dn, *sep_mv, *sep_eq;
	int sep_dn_len, sep_mv_len, sep_eq_len;

	if (indent < 0)
		indent = 0;
	outlen = indent;
	if (!do_indent(io_ch, arg, indent))
		return -1;

	switch (flags & XN_FLAG_SEP_MASK) {
	case XN_FLAG_SEP_MULTILINE:
		sep_dn = "\n";
		sep_dn_len = 1;
		sep_mv = " + ";
		sep_mv_len = 3;
		break;

	case XN_FLAG_SEP_COMMA_PLUS:
		sep_dn = ",";
		sep_dn_len = 1;
		sep_mv = "+";
		sep_mv_len = 1;
		indent = 0;
		break;

	case XN_FLAG_SEP_CPLUS_SPC:
		sep_dn = ", ";
		sep_dn_len = 2;
		sep_mv = " + ";
		sep_mv_len = 3;
		indent = 0;
		break;

	case XN_FLAG_SEP_SPLUS_SPC:
		sep_dn = "; ";
		sep_dn_len = 2;
		sep_mv = " + ";
		sep_mv_len = 3;
		indent = 0;
		break;

	default:
		return -1;
	}

	if (flags & XN_FLAG_SPC_EQ) {
		sep_eq = " = ";
		sep_eq_len = 3;
	} else {
		sep_eq = "=";
		sep_eq_len = 1;
	}

	fn_opt = flags & XN_FLAG_FN_MASK;

	cnt = X509_NAME_entry_count(n);
	for (i = 0; i < cnt; i++) {
		if (flags & XN_FLAG_DN_REV)
			ent = X509_NAME_get_entry(n, cnt - i - 1);
		else
			ent = X509_NAME_get_entry(n, i);
		if (prev != -1) {
			if (prev == ent->set) {
				if (!io_ch(arg, sep_mv, sep_mv_len))
					return -1;
				outlen += sep_mv_len;
			} else {
				if (!io_ch(arg, sep_dn, sep_dn_len))
					return -1;
				outlen += sep_dn_len;
				if (!do_indent(io_ch, arg, indent))
					return -1;
				outlen += indent;
			}
		}
		prev = ent->set;
		fn = X509_NAME_ENTRY_get_object(ent);
		val = X509_NAME_ENTRY_get_data(ent);
		fn_nid = OBJ_obj2nid(fn);
		if (fn_opt != XN_FLAG_FN_NONE) {
			int objlen, fld_len;
			if ((fn_opt == XN_FLAG_FN_OID) ||
			    (fn_nid == NID_undef)) {
				OBJ_obj2txt(objtmp, sizeof objtmp, fn, 1);
				fld_len = 0; /* XXX: what should this be? */
				objbuf = objtmp;
			} else {
				if (fn_opt == XN_FLAG_FN_SN) {
					fld_len = FN_WIDTH_SN;
					objbuf = OBJ_nid2sn(fn_nid);
				} else if (fn_opt == XN_FLAG_FN_LN) {
					fld_len = FN_WIDTH_LN;
					objbuf = OBJ_nid2ln(fn_nid);
				} else {
					fld_len = 0; /* XXX: what should this be? */
					objbuf = "";
				}
			}
			objlen = strlen(objbuf);
			if (!io_ch(arg, objbuf, objlen))
				return -1;
			if ((objlen < fld_len) && (flags & XN_FLAG_FN_ALIGN)) {
				if (!do_indent(io_ch, arg, fld_len - objlen))
					return -1;
				outlen += fld_len - objlen;
			}
			if (!io_ch(arg, sep_eq, sep_eq_len))
				return -1;
			outlen += objlen + sep_eq_len;
		}
		/* If the field name is unknown then fix up the DER dump
		 * flag. We might want to limit this further so it will
 		 * DER dump on anything other than a few 'standard' fields.
		 */
		if ((fn_nid == NID_undef) &&
		    (flags & XN_FLAG_DUMP_UNKNOWN_FIELDS))
			orflags = ASN1_STRFLGS_DUMP_ALL;
		else
			orflags = 0;

		len = do_print_ex(io_ch, arg, flags | orflags, val);
		if (len < 0)
			return -1;
		outlen += len;
	}
	return outlen;
}

/* Wrappers round the main functions */

int
X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent, unsigned long flags)
{
	if (flags == XN_FLAG_COMPAT)
		return X509_NAME_print(out, nm, indent);
	return do_name_ex(send_bio_chars, out, nm, indent, flags);
}

int
X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent, unsigned long flags)
{
	if (flags == XN_FLAG_COMPAT) {
		BIO *btmp;
		int ret;
		btmp = BIO_new_fp(fp, BIO_NOCLOSE);
		if (!btmp)
			return -1;
		ret = X509_NAME_print(btmp, nm, indent);
		BIO_free(btmp);
		return ret;
	}
	return do_name_ex(send_fp_chars, fp, nm, indent, flags);
}

int
ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unsigned long flags)
{
	return do_print_ex(send_bio_chars, out, flags, str);
}

int
ASN1_STRING_print_ex_fp(FILE *fp, ASN1_STRING *str, unsigned long flags)
{
	return do_print_ex(send_fp_chars, fp, flags, str);
}

/* Utility function: convert any string type to UTF8, returns number of bytes
 * in output string or a negative error code
 */

int
ASN1_STRING_to_UTF8(unsigned char **out, ASN1_STRING *in)
{
	ASN1_STRING stmp, *str = &stmp;
	int mbflag, type, ret;

	if (!in)
		return -1;
	type = in->type;
	if ((type < 0) || (type > 30))
		return -1;
	mbflag = tag2nbyte[type];
	if (mbflag == -1)
		return -1;
	mbflag |= MBSTRING_FLAG;
	stmp.data = NULL;
	stmp.length = 0;
	ret = ASN1_mbstring_copy(&str, in->data, in->length, mbflag,
	    B_ASN1_UTF8STRING);
	if (ret < 0)
		return ret;
	*out = stmp.data;
	return stmp.length;
}
@


1.24
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: a_strex.c,v 1.23 2014/07/10 20:42:45 jsing Exp $ */
a86 14
#if 0				/* never used */
static int
send_mem_chars(void *arg, const void *buf, int len)
{
	unsigned char **out = arg;

	if (!out)
		return 1;
	memcpy(*out, buf, len);
	*out += len;
	return 1;
}
#endif

@


1.23
log
@Inline the only use of the HEX_SIZE macro and nuke both DECIMAL_SIZE and
HEX_SIZE.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: a_strex.c,v 1.22 2014/06/12 15:49:27 deraadt Exp $ */
d61 2
a62 1
#include "cryptlib.h"
d65 1
a65 1
#include <openssl/asn1.h>
@


1.22
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d134 1
a134 1
	char tmphex[HEX_SIZE(long) + 3];
@


1.21
log
@Everything sane has stdio, and FILE *. we don't need ifdefs for this.
ok to firebomb from tedu@@
@
text
@d1 1
a1 1
/* a_strex.c */
@


1.20
log
@Bring UTF8_{getc,putc} up-to-date: it's been a decade since 5- and 6-byte
encodings and encoding of surrogate pair code points were banned.  Add
checks for those, both to those functions and to the code decoding the
BMP and UNIV encodings.

ok miod@@
@
text
@a603 1
#ifndef OPENSSL_NO_FP_API
a618 1
#endif
a625 1
#ifndef OPENSSL_NO_FP_API
a630 1
#endif
@


1.19
log
@Make sure UTF8_getc() is invoked with the proper buffer size.

ok beck@@ guenther@@
@
text
@d65 1
d219 2
d226 2
d248 1
d250 2
@


1.18
log
@More KNF.
@
text
@d114 1
a114 1
	if (fwrite(buf, 1, len, arg) != (unsigned int)len)
d230 1
a230 1
			i = UTF8_getc(p, buflen, &c);
@


1.17
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
a73 1

d86 2
a87 1
static int send_mem_chars(void *arg, const void *buf, int len)
d90 3
a92 1
	if(!out) return 1;
d99 2
a100 1
static int send_bio_chars(void *arg, const void *buf, int len)
d102 4
a105 2
	if(!arg) return 1;
	if(BIO_write(arg, buf, len) != len) return 0;
d109 2
a110 1
static int send_fp_chars(void *arg, const void *buf, int len)
d112 4
a115 2
	if(!arg) return 1;
	if(fwrite(buf, 1, len, arg) != (unsigned int)len) return 0;
d128 3
a130 1
static int do_esc_char(unsigned long c, unsigned char flags, char *do_quotes, char_io *io_ch, void *arg)
d133 1
a133 1
	char tmphex[HEX_SIZE(long)+3];
d135 1
a135 1
	if(c > 0xffffffffL)
d137 1
a137 1
	if(c > 0xffff) {
d139 2
a140 1
		if(!io_ch(arg, tmphex, 10)) return -1;
d143 1
a143 1
	if(c > 0xff) {
d145 2
a146 1
		if(!io_ch(arg, tmphex, 6)) return -1;
d150 5
a154 3
	if(chtmp > 0x7f) chflgs = flags & ASN1_STRFLGS_ESC_MSB;
	else chflgs = char_type[chtmp] & flags;
	if(chflgs & CHARTYPE_BS_ESC) {
d156 5
a160 3
		if(chflgs & ASN1_STRFLGS_ESC_QUOTE) {
			if(do_quotes) *do_quotes = 1;
			if(!io_ch(arg, &chtmp, 1)) return -1;
d163 4
a166 2
		if(!io_ch(arg, "\\", 1)) return -1;
		if(!io_ch(arg, &chtmp, 1)) return -1;
d169 1
a169 1
	if(chflgs & (ASN1_STRFLGS_ESC_CTRL|ASN1_STRFLGS_ESC_MSB)) {
d171 2
a172 1
		if(!io_ch(arg, tmphex, 3)) return -1;
d175 1
a175 1
	/* If we get this far and do any escaping at all must escape 
d179 2
a180 1
		if(!io_ch(arg, "\\\\", 2)) return -1;
d183 2
a184 1
	if(!io_ch(arg, &chtmp, 1)) return -1;
d196 3
a198 2
static int do_buf(unsigned char *buf, int buflen,
			int type, unsigned char flags, char *quotes, char_io *io_ch, void *arg)
d203 1
d207 7
a213 5
	while(p != q) {
		if(p == buf && flags & ASN1_STRFLGS_ESC_2253) orflags = CHARTYPE_FIRST_ESC_2253;
		else orflags = 0;
		switch(type & BUF_TYPE_WIDTH_MASK) {
			case 4:
d220 1
a220 1
			case 2:
d225 1
a225 1
			case 1:
d228 2
a229 2
			
			case 0:
d231 2
a232 1
			if(i < 0) return -1;	/* Invalid UTF8String */
d235 2
a236 2
			default:
			return -1;	/* invalid width */
d238 3
a240 2
		if (p == q && flags & ASN1_STRFLGS_ESC_2253) orflags = CHARTYPE_LAST_ESC_2253;
		if(type & BUF_TYPE_CONVUTF8) {
d244 1
a244 1
			for(i = 0; i < utflen; i++) {
d246 2
a247 2
				 * because if utflen==1 its value will be correct anyway 
				 * otherwise each character will be > 0x7f and so the 
d250 5
a254 2
				len = do_esc_char(utfbuf[i], (unsigned char)(flags | orflags), quotes, io_ch, arg);
				if(len < 0) return -1;
d258 4
a261 2
			len = do_esc_char(c, (unsigned char)(flags | orflags), quotes, io_ch, arg);
			if(len < 0) return -1;
d270 2
a271 1
static int do_hex_dump(char_io *io_ch, void *arg, unsigned char *buf, int buflen)
d276 1
a276 1
	if(arg) {
d279 1
a279 1
		while(p != q) {
d282 2
a283 1
			if(!io_ch(arg, hextmp, 2)) return -1;
d296 2
a297 1
static int do_dump(unsigned long lflags, char_io *io_ch, void *arg, ASN1_STRING *str)
d306 2
a307 1
	if(!io_ch(arg, "#", 1)) return -1;
d309 1
a309 1
	if(!(lflags & ASN1_STRFLGS_DUMP_DER)) {
d311 2
a312 1
		if(outlen < 0) return -1;
d319 2
a320 1
	if(!der_buf) return -1;
d325 2
a326 1
	if(outlen < 0) return -1;
d353 2
a354 1
static int do_print_ex(char_io *io_ch, void *arg, unsigned long lflags, ASN1_STRING *str)
d360 1
a363 1

a364 1

d367 1
a367 2

	if(lflags & ASN1_STRFLGS_SHOW_TYPE) {
d371 2
a372 1
		if(!io_ch(arg, tagname, outlen) || !io_ch(arg, ":", 1)) return -1; 
d379 2
a380 1
	if(lflags & ASN1_STRFLGS_DUMP_ALL) type = -1;
d382 2
a383 1
	else if(lflags & ASN1_STRFLGS_IGNORE_TYPE) type = 1;
d386 6
a391 3
		if((type > 0) && (type < 31)) type = tag2nbyte[type];
		else type = -1;
		if((type == -1) && !(lflags & ASN1_STRFLGS_DUMP_UNKNOWN)) type = 1;
d394 1
a394 1
	if(type == -1) {
d396 2
a397 1
		if(len < 0) return -1;
d402 1
a402 1
	if(lflags & ASN1_STRFLGS_UTF8_CONVERT) {
d408 4
a411 2
		if(!type) type = 1;
		else type |= BUF_TYPE_CONVUTF8;
d415 2
a416 1
	if(len < 0) return -1;
d418 9
a426 4
	if(quotes) outlen += 2;
	if(!arg) return outlen;
	if(quotes && !io_ch(arg, "\"", 1)) return -1;
	if(do_buf(str->data, str->length, type, flags, NULL, io_ch, arg) < 0)
a427 1
	if(quotes && !io_ch(arg, "\"", 1)) return -1;
d433 2
a434 1
static int do_indent(char_io *io_ch, void *arg, int indent)
d437 3
a439 2
	for(i = 0; i < indent; i++)
			if(!io_ch(arg, " ", 1)) return 0;
d446 3
a448 2
static int do_name_ex(char_io *io_ch, void *arg, X509_NAME *n,
				int indent, unsigned long flags)
d460 3
a462 1
	if(indent < 0) indent = 0;
d464 3
a466 1
	if(!do_indent(io_ch, arg, indent)) return -1;
d468 1
a468 1
		case XN_FLAG_SEP_MULTILINE:
d475 1
a475 1
		case XN_FLAG_SEP_COMMA_PLUS:
d483 1
a483 1
		case XN_FLAG_SEP_CPLUS_SPC:
d491 1
a491 1
		case XN_FLAG_SEP_SPLUS_SPC:
d499 1
a499 1
		default:
d503 1
a503 1
	if(flags & XN_FLAG_SPC_EQ) {
d513 10
a522 8
	cnt = X509_NAME_entry_count(n);	
	for(i = 0; i < cnt; i++) {
		if(flags & XN_FLAG_DN_REV)
				ent = X509_NAME_get_entry(n, cnt - i - 1);
		else ent = X509_NAME_get_entry(n, i);
		if(prev != -1) {
			if(prev == ent->set) {
				if(!io_ch(arg, sep_mv, sep_mv_len)) return -1;
d525 2
a526 1
				if(!io_ch(arg, sep_dn, sep_dn_len)) return -1;
d528 2
a529 1
				if(!do_indent(io_ch, arg, indent)) return -1;
d537 1
a537 1
		if(fn_opt != XN_FLAG_FN_NONE) {
d539 2
a540 1
			if((fn_opt == XN_FLAG_FN_OID) || (fn_nid==NID_undef) ) {
d545 1
a545 1
				if(fn_opt == XN_FLAG_FN_SN) {
d548 1
a548 1
				} else if(fn_opt == XN_FLAG_FN_LN) {
d557 2
a558 1
			if(!io_ch(arg, objbuf, objlen)) return -1;
d560 2
a561 1
				if (!do_indent(io_ch, arg, fld_len - objlen)) return -1;
d564 2
a565 1
			if(!io_ch(arg, sep_eq, sep_eq_len)) return -1;
d572 6
a577 4
		if((fn_nid == NID_undef) && (flags & XN_FLAG_DUMP_UNKNOWN_FIELDS)) 
					orflags = ASN1_STRFLGS_DUMP_ALL;
		else orflags = 0;
     
d579 2
a580 1
		if(len < 0) return -1;
d588 2
a589 1
int X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent, unsigned long flags)
d591 1
a591 1
	if(flags == XN_FLAG_COMPAT)
d597 2
a598 1
int X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent, unsigned long flags)
d600 1
a600 1
	if(flags == XN_FLAG_COMPAT) {
d604 2
a605 1
		if(!btmp) return -1;
d609 1
a609 1
		}
d614 2
a615 1
int ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unsigned long flags)
d621 2
a622 1
int ASN1_STRING_print_ex_fp(FILE *fp, ASN1_STRING *str, unsigned long flags)
d632 2
a633 1
int ASN1_STRING_to_UTF8(unsigned char **out, ASN1_STRING *in)
d637 3
a639 1
	if(!in) return -1;
d641 2
a642 1
	if((type < 0) || (type > 30)) return -1;
d644 2
a645 1
	if(mbflag == -1) return -1;
d649 4
a652 2
	ret = ASN1_mbstring_copy(&str, in->data, in->length, mbflag, B_ASN1_UTF8STRING);
	if(ret < 0) return ret;
@


1.16
log
@lob a few more knf grenades in here to soften things up.
@
text
@d128 1
a128 1
		(void) snprintf(tmphex, sizeof tmphex, "\\W%08lX", c);
d133 1
a133 1
		(void) snprintf(tmphex, sizeof tmphex, "\\U%04lX", c);
d152 1
a152 1
		(void) snprintf(tmphex, sizeof tmphex, "\\%02X", chtmp);
@


1.15
log
@sprintf: bad.
snprintf: good.
snprintf with a correct size: better!
(harmless in this case)
@
text
@d408 1
a408 2
	switch (flags & XN_FLAG_SEP_MASK)
	{
d528 1
a528 2
	if(flags == XN_FLAG_COMPAT)
		{
@


1.14
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d152 1
a152 1
		(void) snprintf(tmphex, 11, "\\%02X", chtmp);
@


1.13
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@d281 1
a281 1
	der_buf = OPENSSL_malloc(der_len);
d286 1
a286 1
	OPENSSL_free(der_buf);
@


1.12
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d128 1
a128 1
		BIO_snprintf(tmphex, sizeof tmphex, "\\W%08lX", c);
d133 1
a133 1
		BIO_snprintf(tmphex, sizeof tmphex, "\\U%04lX", c);
d152 1
a152 1
		BIO_snprintf(tmphex, 11, "\\%02X", chtmp);
@


1.11
log
@openssl-1.0.0e: resolve conflicts
@
text
@d570 1
@


1.10
log
@resolve conflicts
@
text
@d77 5
d156 7
a305 5

#define ESC_FLAGS (ASN1_STRFLGS_ESC_2253 | \
		  ASN1_STRFLGS_ESC_QUOTE | \
		  ASN1_STRFLGS_ESC_CTRL | \
		  ASN1_STRFLGS_ESC_MSB)
@


1.9
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.8
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 2000-2004 The OpenSSL Project.  All rights reserved.
d61 1
a66 1
#include "cryptlib.h"
d173 1
a173 1
		if(p == buf) orflags = CHARTYPE_FIRST_ESC_2253;
d197 2
d200 1
a200 1
		if (p == q) orflags = CHARTYPE_LAST_ESC_2253;
d228 1
a228 1
	const static char hexdig[] = "0123456789ABCDEF";
d284 1
a284 1
const static signed char tag2nbyte[] = {
d361 1
a361 1
	if(outlen < 0) return -1;
d366 2
a367 1
	do_buf(str->data, str->length, type, flags, NULL, io_ch, arg);
d519 1
a519 1

d534 1
d541 1
a541 1

d546 1
d561 1
a561 6
	if (mbflag == 0)
		mbflag = MBSTRING_UTF8;
	else if (mbflag == 4)
		mbflag = MBSTRING_UNIV;
	else		
		mbflag |= MBSTRING_FLAG;
@


1.7
log
@merge 0.9.7d
@
text
@d6 1
a6 1
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
d556 6
a561 1
	mbflag |= MBSTRING_FLAG;
@


1.6
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d288 1
a288 1
	-1, 1, -1,-1,		/* 21-24 */
@


1.5
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d282 1
a282 1
const static char tag2nbyte[] = {
@


1.4
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d66 1
d118 4
a121 1
	char tmphex[11];
d123 1
a123 1
		BIO_snprintf(tmphex, 11, "\\W%08lX", c);
d128 1
a128 1
		BIO_snprintf(tmphex, 11, "\\U%04lX", c);
d202 1
a202 1
			utflen = UTF8_putc(utfbuf, 6, c);
d468 1
a468 1
				OBJ_obj2txt(objtmp, 80, fn, 1);
@


1.3
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d547 1
a547 1
	if(!*out || !in) return -1;
d556 1
a556 1
	if(out) *out = stmp.data;
@


1.2
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d80 2
a81 2

int send_mem_chars(void *arg, const void *buf, int len)
d89 1
d91 1
a91 1
int send_bio_chars(void *arg, const void *buf, int len)
d98 1
a98 1
int send_fp_chars(void *arg, const void *buf, int len)
d244 1
a244 1
int do_dump(unsigned long lflags, char_io *io_ch, void *arg, ASN1_STRING *str)
@


1.1
log
@openssl-engine-0.9.6 merge
@
text
@d374 2
d461 1
a461 1
			int objlen;
d464 1
d467 2
a468 1
				if(fn_opt == XN_FLAG_FN_SN) 
d470 2
a471 1
				else if(fn_opt == XN_FLAG_FN_LN)
d473 4
a476 1
				else objbuf = "";
d480 4
d506 2
d514 10
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a373 2
#define FN_WIDTH_LN	25
#define FN_WIDTH_SN	10
d459 1
a459 1
			int objlen, fld_len;
a461 1
				fld_len = 0; /* XXX: what should this be? */
d464 1
a464 2
				if(fn_opt == XN_FLAG_FN_SN) {
					fld_len = FN_WIDTH_SN;
d466 1
a466 2
				} else if(fn_opt == XN_FLAG_FN_LN) {
					fld_len = FN_WIDTH_LN;
d468 1
a468 4
				} else {
					fld_len = 0; /* XXX: what should this be? */
					objbuf = "";
				}
a471 4
			if ((objlen < fld_len) && (flags & XN_FLAG_FN_ALIGN)) {
				if (!do_indent(io_ch, arg, fld_len - objlen)) return -1;
				outlen += fld_len - objlen;
			}
a493 2
	if(flags == XN_FLAG_COMPAT)
		return X509_NAME_print(out, nm, indent);
a499 10
	if(flags == XN_FLAG_COMPAT)
		{
		BIO *btmp;
		int ret;
		btmp = BIO_new_fp(fp, BIO_NOCLOSE);
		if(!btmp) return -1;
		ret = X509_NAME_print(btmp, nm, indent);
		BIO_free(btmp);
		return ret;
		}
@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@d80 2
a81 2
#if 0				/* never used */
static int send_mem_chars(void *arg, const void *buf, int len)
a88 1
#endif
d90 1
a90 1
static int send_bio_chars(void *arg, const void *buf, int len)
d97 1
a97 1
static int send_fp_chars(void *arg, const void *buf, int len)
d243 1
a243 1
static int do_dump(unsigned long lflags, char_io *io_ch, void *arg, ASN1_STRING *str)
@


1.1.1.3
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d547 1
a547 1
	if(!in) return -1;
d556 1
a556 1
	*out = stmp.data;
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a65 1
#include "cryptlib.h"
d117 1
a117 4
	char tmphex[HEX_SIZE(long)+3];

	if(c > 0xffffffffL)
		return -1;
d119 1
a119 1
		BIO_snprintf(tmphex, sizeof tmphex, "\\W%08lX", c);
d124 1
a124 1
		BIO_snprintf(tmphex, sizeof tmphex, "\\U%04lX", c);
d198 1
a198 1
			utflen = UTF8_putc(utfbuf, sizeof utfbuf, c);
d464 1
a464 1
				OBJ_obj2txt(objtmp, sizeof objtmp, fn, 1);
@


1.1.1.5
log
@import 0.9.7c
@
text
@d282 1
a282 1
const static signed char tag2nbyte[] = {
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d288 1
a288 1
	-1, 1, 1, 1,		/* 21-24 */
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d6 1
a6 1
 * Copyright (c) 2000-2004 The OpenSSL Project.  All rights reserved.
d556 1
a556 6
	if (mbflag == 0)
		mbflag = MBSTRING_UTF8;
	else if (mbflag == 4)
		mbflag = MBSTRING_UNIV;
	else		
		mbflag |= MBSTRING_FLAG;
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@d6 1
a6 1
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
a60 1
#include "cryptlib.h"
d66 1
d173 1
a173 1
		if(p == buf && flags & ASN1_STRFLGS_ESC_2253) orflags = CHARTYPE_FIRST_ESC_2253;
a196 2
			default:
			return -1;	/* invalid width */
d198 1
a198 1
		if (p == q && flags & ASN1_STRFLGS_ESC_2253) orflags = CHARTYPE_LAST_ESC_2253;
d226 1
a226 1
	static const char hexdig[] = "0123456789ABCDEF";
d282 1
a282 1
static const signed char tag2nbyte[] = {
d359 1
a359 1
	if(len < 0) return -1;
d364 1
a364 2
	if(do_buf(str->data, str->length, type, flags, NULL, io_ch, arg) < 0)
		return -1;
d516 1
a516 1
#ifndef OPENSSL_NO_FP_API
a530 1
#endif
d537 1
a537 1
#ifndef OPENSSL_NO_FP_API
a541 1
#endif
d556 6
a561 1
	mbflag |= MBSTRING_FLAG;
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@a76 5
#define ESC_FLAGS (ASN1_STRFLGS_ESC_2253 | \
		  ASN1_STRFLGS_ESC_QUOTE | \
		  ASN1_STRFLGS_ESC_CTRL | \
		  ASN1_STRFLGS_ESC_MSB)

a150 7
	/* If we get this far and do any escaping at all must escape 
	 * the escape character itself: backslash.
	 */
	if (chtmp == '\\' && flags & ESC_FLAGS) {
		if(!io_ch(arg, "\\\\", 2)) return -1;
		return 2;
	}
d294 5
@


1.1.1.11
log
@Import OpenSSL 1.0.1g
@
text
@a569 1
	stmp.length = 0;
@


