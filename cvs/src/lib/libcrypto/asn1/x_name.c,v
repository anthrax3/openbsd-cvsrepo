head	1.33;
access;
symbols;
locks; strict;
comment	@ * @;


1.33
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.32;
commitid	kT0fLt3r4lroFJra;

1.32
date	2016.12.30.16.04.34;	author jsing;	state Exp;
branches;
next	1.31;
commitid	Gs5oxnpdEYq1UpKL;

1.31
date	2015.07.24.15.09.52;	author jsing;	state Exp;
branches;
next	1.30;
commitid	tii1oXfX8c5bF54I;

1.30
date	2015.07.15.17.41.56;	author miod;	state Exp;
branches;
next	1.29;
commitid	DcNcvLrFcR3LeOUP;

1.29
date	2015.02.14.15.29.29;	author miod;	state Exp;
branches;
next	1.28;
commitid	cF5vnS14x6Fhk3c2;

1.28
date	2015.02.14.15.25.08;	author jsing;	state Exp;
branches;
next	1.27;
commitid	wDJ7aAdpBnIQhhRZ;

1.27
date	2015.02.14.15.16.59;	author miod;	state Exp;
branches;
next	1.26;
commitid	AWnZp1u1Xadn6Czq;

1.26
date	2015.02.11.04.00.39;	author jsing;	state Exp;
branches;
next	1.25;
commitid	QCjRtjn2xv9owjIW;

1.25
date	2015.02.11.03.39.51;	author jsing;	state Exp;
branches;
next	1.24;
commitid	PWeA1V6nbEryguKH;

1.24
date	2015.02.10.08.33.10;	author jsing;	state Exp;
branches;
next	1.23;
commitid	v5VD2cgZRaYX8ah1;

1.23
date	2015.02.10.05.25.45;	author jsing;	state Exp;
branches;
next	1.22;
commitid	HQSAPkY0rIzvWYsC;

1.22
date	2015.02.10.04.21.50;	author jsing;	state Exp;
branches;
next	1.21;
commitid	lmzaeFtqKbLCKhxJ;

1.21
date	2015.02.09.15.05.59;	author jsing;	state Exp;
branches;
next	1.20;
commitid	X3hE8E9VwC2nOKbW;

1.20
date	2014.07.12.11.25.25;	author miod;	state Exp;
branches;
next	1.19;
commitid	5oZSAHeMCKXwCOOM;

1.19
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.18;
commitid	yQEL1wOWIearrW15;

1.18
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.17;
commitid	id8dTrTMtnTn4fqt;

1.17
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	mJUVYpkFBZ0Zv2bG;

1.16
date	2014.05.30.02.52.11;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.18.11.20.32;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.18.00.58.49;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.18.00.10.08;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.29.05.39.18;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.02.56;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.13;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.51;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.35;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.51;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.51;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.51;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.03;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.40;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.03;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2011.11.03.02.32.08;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.10.13.21.23.34;	author djm;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: x_name.c,v 1.32 2016/12/30 16:04:34 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include <openssl/asn1t.h>
#include <openssl/err.h>
#include <openssl/x509.h>

#include "asn1_locl.h"

typedef STACK_OF(X509_NAME_ENTRY) STACK_OF_X509_NAME_ENTRY;
DECLARE_STACK_OF(STACK_OF_X509_NAME_ENTRY)

static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
    long len, const ASN1_ITEM *it, int tag, int aclass, char opt,
    ASN1_TLC *ctx);

static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out,
    const ASN1_ITEM *it, int tag, int aclass);
static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it);
static void x509_name_ex_free(ASN1_VALUE **val, const ASN1_ITEM *it);

static int x509_name_encode(X509_NAME *a);
static int x509_name_canon(X509_NAME *a);
static int asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in);
static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname,
    unsigned char **in);

static int x509_name_ex_print(BIO *out, ASN1_VALUE **pval, int indent,
    const char *fname, const ASN1_PCTX *pctx);

static const ASN1_TEMPLATE X509_NAME_ENTRY_seq_tt[] = {
	{
		.offset = offsetof(X509_NAME_ENTRY, object),
		.field_name = "object",
		.item = &ASN1_OBJECT_it,
	},
	{
		.offset = offsetof(X509_NAME_ENTRY, value),
		.field_name = "value",
		.item = &ASN1_PRINTABLE_it,
	},
};

const ASN1_ITEM X509_NAME_ENTRY_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = X509_NAME_ENTRY_seq_tt,
	.tcount = sizeof(X509_NAME_ENTRY_seq_tt) / sizeof(ASN1_TEMPLATE),
	.size = sizeof(X509_NAME_ENTRY),
	.sname = "X509_NAME_ENTRY",
};


X509_NAME_ENTRY *
d2i_X509_NAME_ENTRY(X509_NAME_ENTRY **a, const unsigned char **in, long len)
{
	return (X509_NAME_ENTRY *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &X509_NAME_ENTRY_it);
}

int
i2d_X509_NAME_ENTRY(X509_NAME_ENTRY *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_NAME_ENTRY_it);
}

X509_NAME_ENTRY *
X509_NAME_ENTRY_new(void)
{
	return (X509_NAME_ENTRY *)ASN1_item_new(&X509_NAME_ENTRY_it);
}

void
X509_NAME_ENTRY_free(X509_NAME_ENTRY *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &X509_NAME_ENTRY_it);
}

X509_NAME_ENTRY *
X509_NAME_ENTRY_dup(X509_NAME_ENTRY *x)
{
	return ASN1_item_dup(&X509_NAME_ENTRY_it, x);
}

/* For the "Name" type we need a SEQUENCE OF { SET OF X509_NAME_ENTRY }
 * so declare two template wrappers for this
 */

static const ASN1_TEMPLATE X509_NAME_ENTRIES_item_tt = {
	.flags = ASN1_TFLG_SET_OF,
	.tag = 0,
	.offset = 0,
	.field_name = "RDNS",
	.item = &X509_NAME_ENTRY_it,
};

const ASN1_ITEM X509_NAME_ENTRIES_it = {
	.itype = ASN1_ITYPE_PRIMITIVE,
	.utype = -1,
	.templates = &X509_NAME_ENTRIES_item_tt,
	.tcount = 0,
	.funcs = NULL,
	.size = 0,
	.sname = "X509_NAME_ENTRIES",
};

static const ASN1_TEMPLATE X509_NAME_INTERNAL_item_tt = {
	.flags = ASN1_TFLG_SEQUENCE_OF,
	.tag = 0,
	.offset = 0,
	.field_name = "Name",
	.item = &X509_NAME_ENTRIES_it,
};

const ASN1_ITEM X509_NAME_INTERNAL_it = {
	.itype = ASN1_ITYPE_PRIMITIVE,
	.utype = -1,
	.templates = &X509_NAME_INTERNAL_item_tt,
	.tcount = 0,
	.funcs = NULL,
	.size = 0,
	.sname = "X509_NAME_INTERNAL",
};

/* Normally that's where it would end: we'd have two nested STACK structures
 * representing the ASN1. Unfortunately X509_NAME uses a completely different
 * form and caches encodings so we have to process the internal form and convert
 * to the external form.
 */

const ASN1_EXTERN_FUNCS x509_name_ff = {
	NULL,
	x509_name_ex_new,
	x509_name_ex_free,
	0,	/* Default clear behaviour is OK */
	x509_name_ex_d2i,
	x509_name_ex_i2d,
	x509_name_ex_print
};

const ASN1_ITEM X509_NAME_it = {
	.itype = ASN1_ITYPE_EXTERN,
	.utype = V_ASN1_SEQUENCE,
	.templates = NULL,
	.tcount = 0,
	.funcs = &x509_name_ff,
	.size = 0,
	.sname = "X509_NAME",
};

X509_NAME *
d2i_X509_NAME(X509_NAME **a, const unsigned char **in, long len)
{
	return (X509_NAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &X509_NAME_it);
}

int
i2d_X509_NAME(X509_NAME *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_NAME_it);
}

X509_NAME *
X509_NAME_new(void)
{
	return (X509_NAME *)ASN1_item_new(&X509_NAME_it);
}

void
X509_NAME_free(X509_NAME *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &X509_NAME_it);
}

X509_NAME *
X509_NAME_dup(X509_NAME *x)
{
	return ASN1_item_dup(&X509_NAME_it, x);
}

static int
x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it)
{
	X509_NAME *ret = NULL;

	ret = malloc(sizeof(X509_NAME));
	if (!ret)
		goto memerr;
	if ((ret->entries = sk_X509_NAME_ENTRY_new_null()) == NULL)
		goto memerr;
	if ((ret->bytes = BUF_MEM_new()) == NULL)
		goto memerr;
	ret->canon_enc = NULL;
	ret->canon_enclen = 0;
	ret->modified = 1;
	*val = (ASN1_VALUE *)ret;
	return 1;

memerr:
	ASN1error(ERR_R_MALLOC_FAILURE);
	if (ret) {
		if (ret->entries)
			sk_X509_NAME_ENTRY_free(ret->entries);
		free(ret);
	}
	return 0;
}

static void
x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
	X509_NAME *a;

	if (!pval || !*pval)
		return;
	a = (X509_NAME *)*pval;

	BUF_MEM_free(a->bytes);
	sk_X509_NAME_ENTRY_pop_free(a->entries, X509_NAME_ENTRY_free);
	free(a->canon_enc);
	free(a);
	*pval = NULL;
}

static int
x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in, long len,
    const ASN1_ITEM *it, int tag, int aclass, char opt, ASN1_TLC *ctx)
{
	const unsigned char *p = *in, *q;
	union {
		STACK_OF(STACK_OF_X509_NAME_ENTRY) *s;
		ASN1_VALUE *a;
	} intname = {NULL};
	union {
		X509_NAME *x;
		ASN1_VALUE *a;
	} nm = {NULL};
	int i, j, ret;
	STACK_OF(X509_NAME_ENTRY) *entries;
	X509_NAME_ENTRY *entry;
	q = p;

	/* Get internal representation of Name */
	ret = ASN1_item_ex_d2i(&intname.a, &p, len,
	    &X509_NAME_INTERNAL_it, tag, aclass, opt, ctx);

	if (ret <= 0)
		return ret;

	if (*val)
		x509_name_ex_free(val, NULL);
	if (!x509_name_ex_new(&nm.a, NULL))
		goto err;
	/* We've decoded it: now cache encoding */
	if (!BUF_MEM_grow(nm.x->bytes, p - q))
		goto err;
	memcpy(nm.x->bytes->data, q, p - q);

	/* Convert internal representation to X509_NAME structure */
	for (i = 0; i < sk_STACK_OF_X509_NAME_ENTRY_num(intname.s); i++) {
		entries = sk_STACK_OF_X509_NAME_ENTRY_value(intname.s, i);
		for (j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {
			entry = sk_X509_NAME_ENTRY_value(entries, j);
			entry->set = i;
			if (!sk_X509_NAME_ENTRY_push(nm.x->entries, entry))
				goto err;
		}
		sk_X509_NAME_ENTRY_free(entries);
	}
	sk_STACK_OF_X509_NAME_ENTRY_free(intname.s);
	ret = x509_name_canon(nm.x);
	if (!ret)
		goto err;
	nm.x->modified = 0;
	*val = nm.a;
	*in = p;
	return ret;

err:
	if (nm.x != NULL)
		X509_NAME_free(nm.x);
	ASN1error(ERR_R_NESTED_ASN1_ERROR);
	return 0;
}

static int
x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out, const ASN1_ITEM *it,
    int tag, int aclass)
{
	int ret;
	X509_NAME *a = (X509_NAME *)*val;

	if (a->modified) {
		ret = x509_name_encode(a);
		if (ret < 0)
			return ret;
		ret = x509_name_canon(a);
		if (ret < 0)
			return ret;
	}
	ret = a->bytes->length;
	if (out != NULL) {
		memcpy(*out, a->bytes->data, ret);
		*out += ret;
	}
	return ret;
}

static void
local_sk_X509_NAME_ENTRY_free(STACK_OF(X509_NAME_ENTRY) *ne)
{
	sk_X509_NAME_ENTRY_free(ne);
}

static void
local_sk_X509_NAME_ENTRY_pop_free(STACK_OF(X509_NAME_ENTRY) *ne)
{
	sk_X509_NAME_ENTRY_pop_free(ne, X509_NAME_ENTRY_free);
}

static int
x509_name_encode(X509_NAME *a)
{
	union {
		STACK_OF(STACK_OF_X509_NAME_ENTRY) *s;
		ASN1_VALUE *a;
	} intname = {NULL};
	int len;
	unsigned char *p;
	STACK_OF(X509_NAME_ENTRY) *entries = NULL;
	X509_NAME_ENTRY *entry;
	int i, set = -1;

	intname.s = sk_STACK_OF_X509_NAME_ENTRY_new_null();
	if (!intname.s)
		goto memerr;
	for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
		entry = sk_X509_NAME_ENTRY_value(a->entries, i);
		if (entry->set != set) {
			entries = sk_X509_NAME_ENTRY_new_null();
			if (!entries)
				goto memerr;
			if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname.s,
			    entries))
				goto memerr;
			set = entry->set;
		}
		if (entries == NULL /* if entry->set is bogusly -1 */ ||
		    !sk_X509_NAME_ENTRY_push(entries, entry))
			goto memerr;
	}
	len = ASN1_item_ex_i2d(&intname.a, NULL,
	    &X509_NAME_INTERNAL_it, -1, -1);
	if (!BUF_MEM_grow(a->bytes, len))
		goto memerr;
	p = (unsigned char *)a->bytes->data;
	ASN1_item_ex_i2d(&intname.a, &p, &X509_NAME_INTERNAL_it,
	    -1, -1);
	sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,
	    local_sk_X509_NAME_ENTRY_free);
	a->modified = 0;
	return len;

memerr:
	sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,
	    local_sk_X509_NAME_ENTRY_free);
	ASN1error(ERR_R_MALLOC_FAILURE);
	return -1;
}

static int
x509_name_ex_print(BIO *out, ASN1_VALUE **pval, int indent, const char *fname,
    const ASN1_PCTX *pctx)
{
	if (X509_NAME_print_ex(out, (X509_NAME *)*pval, indent,
	    pctx->nm_flags) <= 0)
		return 0;
	return 2;
}

/* This function generates the canonical encoding of the Name structure.
 * In it all strings are converted to UTF8, leading, trailing and
 * multiple spaces collapsed, converted to lower case and the leading
 * SEQUENCE header removed.
 *
 * In future we could also normalize the UTF8 too.
 *
 * By doing this comparison of Name structures can be rapidly
 * performed by just using memcmp() of the canonical encoding.
 * By omitting the leading SEQUENCE name constraints of type
 * dirName can also be checked with a simple memcmp().
 */

static int
x509_name_canon(X509_NAME *a)
{
	unsigned char *p;
	STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
	STACK_OF(X509_NAME_ENTRY) *entries = NULL;
	X509_NAME_ENTRY *entry, *tmpentry = NULL;
	int i, len, set = -1, ret = 0;

	if (a->canon_enc) {
		free(a->canon_enc);
		a->canon_enc = NULL;
	}
	/* Special case: empty X509_NAME => null encoding */
	if (sk_X509_NAME_ENTRY_num(a->entries) == 0) {
		a->canon_enclen = 0;
		return 1;
	}
	intname = sk_STACK_OF_X509_NAME_ENTRY_new_null();
	if (!intname)
		goto err;
	for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
		entry = sk_X509_NAME_ENTRY_value(a->entries, i);
		if (entry->set != set) {
			entries = sk_X509_NAME_ENTRY_new_null();
			if (!entries)
				goto err;
			if (sk_STACK_OF_X509_NAME_ENTRY_push(intname,
			    entries) == 0) {
				sk_X509_NAME_ENTRY_free(entries);
				goto err;
			}
			set = entry->set;
		}
		tmpentry = X509_NAME_ENTRY_new();
		if (tmpentry == NULL)
			goto err;
		tmpentry->object = OBJ_dup(entry->object);
		if (tmpentry->object == NULL)
			goto err;
		if (!asn1_string_canon(tmpentry->value, entry->value))
			goto err;
		if (entries == NULL /* if entry->set is bogusly -1 */ ||
		    !sk_X509_NAME_ENTRY_push(entries, tmpentry))
			goto err;
		tmpentry = NULL;
	}

	/* Finally generate encoding */
	len = i2d_name_canon(intname, NULL);
	if (len < 0)
		goto err;
	p = malloc(len);
	if (p == NULL)
		goto err;
	a->canon_enc = p;
	a->canon_enclen = len;
	i2d_name_canon(intname, &p);
	ret = 1;

err:
	if (tmpentry)
		X509_NAME_ENTRY_free(tmpentry);
	if (intname)
		sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
		    local_sk_X509_NAME_ENTRY_pop_free);
	return ret;
}

/* Bitmap of all the types of string that will be canonicalized. */

#define ASN1_MASK_CANON	\
	(B_ASN1_UTF8STRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING \
	| B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING \
	| B_ASN1_VISIBLESTRING)


static int
asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in)
{
	unsigned char *to, *from;
	int len, i;

	/* If type not in bitmask just copy string across */
	if (!(ASN1_tag2bit(in->type) & ASN1_MASK_CANON)) {
		if (!ASN1_STRING_copy(out, in))
			return 0;
		return 1;
	}

	out->type = V_ASN1_UTF8STRING;
	out->length = ASN1_STRING_to_UTF8(&out->data, in);
	if (out->length == -1)
		return 0;

	to = out->data;
	from = to;

	len = out->length;

	/* Convert string in place to canonical form.
	 * Ultimately we may need to handle a wider range of characters
	 * but for now ignore anything with MSB set and rely on the
	 * isspace() and tolower() functions.
	 */

	/* Ignore leading spaces */
	while ((len > 0) && !(*from & 0x80) && isspace(*from)) {
		from++;
		len--;
	}

	to = from + len - 1;

	/* Ignore trailing spaces */
	while ((len > 0) && !(*to & 0x80) && isspace(*to)) {
		to--;
		len--;
	}

	to = out->data;

	i = 0;
	while (i < len) {
		/* If MSB set just copy across */
		if (*from & 0x80) {
			*to++ = *from++;
			i++;
		}
		/* Collapse multiple spaces */
		else if (isspace(*from)) {
			/* Copy one space across */
			*to++ = ' ';
			/* Ignore subsequent spaces. Note: don't need to
			 * check len here because we know the last
			 * character is a non-space so we can't overflow.
			 */
			do {
				from++;
				i++;
			} while (!(*from & 0x80) && isspace(*from));
		} else {
			*to++ = tolower(*from);
			from++;
			i++;
		}
	}

	out->length = to - out->data;

	return 1;
}

static int
i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *_intname, unsigned char **in)
{
	int i, len, ltmp;
	ASN1_VALUE *v;
	STACK_OF(ASN1_VALUE) *intname = (STACK_OF(ASN1_VALUE) *)_intname;

	len = 0;
	for (i = 0; i < sk_ASN1_VALUE_num(intname); i++) {
		v = sk_ASN1_VALUE_value(intname, i);
		ltmp = ASN1_item_ex_i2d(&v, in,
		    &X509_NAME_ENTRIES_it, -1, -1);
		if (ltmp < 0)
			return ltmp;
		len += ltmp;
	}
	return len;
}

int
X509_NAME_set(X509_NAME **xn, X509_NAME *name)
{
	X509_NAME *in;

	if (!xn || !name)
		return (0);

	if (*xn != name) {
		in = X509_NAME_dup(name);
		if (in != NULL) {
			X509_NAME_free(*xn);
			*xn = in;
		}
	}
	return (*xn != NULL);
}
@


1.32
log
@Expand ASN1_ITEM_rptr and ASN1_ITEM_ptr macros - no change in generated
assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.31 2015/07/24 15:09:52 jsing Exp $ */
d260 1
a260 1
	ASN1err(ASN1_F_X509_NAME_EX_NEW, ERR_R_MALLOC_FAILURE);
d342 1
a342 1
	ASN1err(ASN1_F_X509_NAME_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
d427 1
a427 1
	ASN1err(ASN1_F_X509_NAME_ENCODE, ERR_R_MALLOC_FAILURE);
@


1.31
log
@Expand ASN1_ITEM_TEMPLATE/ASN1_EX_TEMPLATE_TYPE/ASN1_ITEM_TEMPLATE_END
macros - the generated assembly only differs by changes to line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.30 2015/07/15 17:41:56 miod Exp $ */
d305 1
a305 1
	    ASN1_ITEM_rptr(X509_NAME_INTERNAL), tag, aclass, opt, ctx);
d413 1
a413 1
	    ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);
d417 1
a417 1
	ASN1_item_ex_i2d(&intname.a, &p, ASN1_ITEM_rptr(X509_NAME_INTERNAL),
d618 1
a618 1
		    ASN1_ITEM_rptr(X509_NAME_ENTRIES), -1, -1);
@


1.30
log
@Fix two theoretical NULL pointer dereferences which can only happen if you
have seriously corrupted your memory; Coverity CID 21708 and 21721.

While there, plug a memory leak upon error in x509_name_canon().

ok bcook@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.29 2015/02/14 15:29:29 miod Exp $ */
d148 35
a182 7
ASN1_ITEM_TEMPLATE(X509_NAME_ENTRIES) =
    ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SET_OF, 0, RDNS, X509_NAME_ENTRY)
ASN1_ITEM_TEMPLATE_END(X509_NAME_ENTRIES)

ASN1_ITEM_TEMPLATE(X509_NAME_INTERNAL) =
    ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, Name, X509_NAME_ENTRIES)
ASN1_ITEM_TEMPLATE_END(X509_NAME_INTERNAL)
@


1.29
log
@Unchecked allocations in x509_name_canon().
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.28 2015/02/14 15:25:08 jsing Exp $ */
d380 2
a381 1
		if (!sk_X509_NAME_ENTRY_push(entries, entry))
d453 3
a455 1
			if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries))
d457 1
d468 2
a469 1
		if (!sk_X509_NAME_ENTRY_push(entries, tmpentry))
@


1.28
log
@Manually expand IMPLEMENT_EXTERN_ASN1 macro (the only occurence in crypto).

Only change to generated assembly is due to line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.27 2015/02/14 15:16:59 miod Exp $ */
d457 2
d460 2
@


1.27
log
@Check i2d_name_canon() for failure (negative return). Coverity CID 78888.
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.26 2015/02/11 04:00:39 jsing Exp $ */
d172 9
a180 2
IMPLEMENT_EXTERN_ASN1(X509_NAME, V_ASN1_SEQUENCE, x509_name_ff)

@


1.26
log
@Remove initialisers with default values from the ASN1 data structures.

Minor changes in generated assembly due to the compiler swapping from
.quad 0/.long 0 to .zero, along with changes due to line numbering.
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.25 2015/02/11 03:39:51 jsing Exp $ */
d425 1
a425 1
	int i, set = -1, ret = 0;
d459 5
a463 3
	a->canon_enclen = i2d_name_canon(intname, NULL);
	p = malloc(a->canon_enclen);
	if (!p)
d466 1
a470 1

@


1.25
log
@Expand most of the ASN1_SEQUENCE* and associated macros, making the data
structures visible and easier to review, without having to wade through
layers and layers of asn1t.h macros.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.24 2015/02/10 08:33:10 jsing Exp $ */
a91 2
		.flags = 0,
		.tag = 0,
a96 2
		.flags = 0,
		.tag = 0,
a107 1
	.funcs = NULL,
@


1.24
log
@The IMPLEMENT_STACK_OF and IMPLEMENT_ASN1_SET_OF macros were turned into
noops around 15 years ago. Remove multiple occurances of both that still
exist in the code today.
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.23 2015/02/10 05:25:45 jsing Exp $ */
d90 26
a115 4
ASN1_SEQUENCE(X509_NAME_ENTRY) = {
	ASN1_SIMPLE(X509_NAME_ENTRY, object, ASN1_OBJECT),
	ASN1_SIMPLE(X509_NAME_ENTRY, value, ASN1_PRINTABLE)
} ASN1_SEQUENCE_END(X509_NAME_ENTRY)
@


1.23
log
@Manually expand ASN1_ITEM_rptr macros that should have been expanded with
the IMPLEMENT_ASN1_DUP_FUNCTION macro.
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.22 2015/02/10 04:21:50 jsing Exp $ */
a579 3

IMPLEMENT_STACK_OF(X509_NAME_ENTRY)
IMPLEMENT_ASN1_SET_OF(X509_NAME_ENTRY)
@


1.22
log
@Expand the IMPLEMENT_ASN1_DUP_FUNCTION macro so that the code is visible
and functions can be readily located.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.21 2015/02/09 15:05:59 jsing Exp $ */
d124 1
a124 1
	return ASN1_item_dup(ASN1_ITEM_rptr(X509_NAME_ENTRY), x);
d186 1
a186 1
	return ASN1_item_dup(ASN1_ITEM_rptr(X509_NAME), x);
@


1.21
log
@Expand the IMPLEMENT_ASN1_FUNCTIONS macro so that the code is visible and
functions can be readily located.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.20 2014/07/12 11:25:25 miod Exp $ */
d120 6
a125 1
IMPLEMENT_ASN1_DUP_FUNCTION(X509_NAME_ENTRY)
d182 6
a187 1
IMPLEMENT_ASN1_DUP_FUNCTION(X509_NAME)
@


1.20
log
@typos
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.19 2014/07/11 08:44:47 jsing Exp $ */
d95 25
a119 1
IMPLEMENT_ASN1_FUNCTIONS(X509_NAME_ENTRY)
d152 25
a176 1
IMPLEMENT_ASN1_FUNCTIONS(X509_NAME)
@


1.19
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.18 2014/07/10 13:58:22 jsing Exp $ */
d338 1
a338 1
 * perfomed by just using memcmp() of the canonical encoding.
@


1.18
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x_name.c,v 1.17 2014/06/12 15:49:27 deraadt Exp $ */
a62 1
#include "cryptlib.h"
d64 1
d66 1
@


1.17
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d59 1
d61 2
a62 1
#include <ctype.h>
@


1.16
log
@no need for null check before free. from Brendan MacDonell
@
text
@d1 1
a1 1
/* crypto/asn1/x_name.c */
@


1.15
log
@More KNF.
@
text
@d167 1
a167 2
	if (a->canon_enc)
		free(a->canon_enc);
@


1.14
log
@lob a few more knf grenades in here to soften things up.
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d69 3
a71 4
static int x509_name_ex_d2i(ASN1_VALUE **val,
				const unsigned char **in, long len,
				const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx);
d74 1
a74 1
				const ASN1_ITEM *it, int tag, int aclass);
d82 1
a82 1
			  unsigned char **in);
d84 2
a85 5

static int x509_name_ex_print(BIO *out, ASN1_VALUE **pval,
						int indent,
						const char *fname, 
						const ASN1_PCTX *pctx);
d100 1
a100 1
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SET_OF, 0, RDNS, X509_NAME_ENTRY)
d104 1
a104 1
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, Name, X509_NAME_ENTRIES)
d123 1
a123 1
IMPLEMENT_EXTERN_ASN1(X509_NAME, V_ASN1_SEQUENCE, x509_name_ff) 
d128 2
a129 1
static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it)
d132 1
d134 5
a138 2
	if(!ret) goto memerr;
	if ((ret->entries=sk_X509_NAME_ENTRY_new_null()) == NULL)
a139 1
	if((ret->bytes = BUF_MEM_new()) == NULL) goto memerr;
d142 1
a142 1
	ret->modified=1;
d146 1
a146 1
 memerr:
d156 2
a157 1
static void x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)
d160 3
a162 2
	if(!pval || !*pval)
	    return;
d166 1
a166 1
	sk_X509_NAME_ENTRY_pop_free(a->entries,X509_NAME_ENTRY_free);
d173 3
a175 3
static int x509_name_ex_d2i(ASN1_VALUE **val,
			const unsigned char **in, long len, const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx)
d178 8
a185 3
	union { STACK_OF(STACK_OF_X509_NAME_ENTRY) *s;
		ASN1_VALUE *a; } intname = {NULL};
	union { X509_NAME *x; ASN1_VALUE *a; } nm = {NULL};
d192 2
a193 5
	ret = ASN1_item_ex_d2i(&intname.a,
			       &p, len, ASN1_ITEM_rptr(X509_NAME_INTERNAL),
			       tag, aclass, opt, ctx);
	
	if(ret <= 0) return ret;
d195 7
a201 2
	if(*val) x509_name_ex_free(val, NULL);
	if(!x509_name_ex_new(&nm.a, NULL)) goto err;
d203 2
a204 1
	if(!BUF_MEM_grow(nm.x->bytes, p - q)) goto err;
d208 1
a208 1
	for(i = 0; i < sk_STACK_OF_X509_NAME_ENTRY_num(intname.s); i++) {
d210 1
a210 1
		for(j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {
d213 1
a213 1
			if(!sk_X509_NAME_ENTRY_push(nm.x->entries, entry))
d226 1
d228 1
a228 1
        if (nm.x != NULL)
d234 3
a236 1
static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass)
d240 2
a241 1
	if(a->modified) {
d243 1
a243 1
		if(ret < 0)
d246 1
a246 1
		if(ret < 0)
d250 3
a252 3
	if(out != NULL) {
		memcpy(*out,a->bytes->data,ret);
		*out+=ret;
d257 2
a258 1
static void local_sk_X509_NAME_ENTRY_free(STACK_OF(X509_NAME_ENTRY) *ne)
d263 2
a264 1
static void local_sk_X509_NAME_ENTRY_pop_free(STACK_OF(X509_NAME_ENTRY) *ne)
d269 2
a270 1
static int x509_name_encode(X509_NAME *a)
d272 4
a275 2
	union { STACK_OF(STACK_OF_X509_NAME_ENTRY) *s;
		ASN1_VALUE *a; } intname = {NULL};
d281 1
d283 3
a285 2
	if(!intname.s) goto memerr;
	for(i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
d287 1
a287 1
		if(entry->set != set) {
d289 4
a292 3
			if(!entries) goto memerr;
			if(!sk_STACK_OF_X509_NAME_ENTRY_push(intname.s,
							     entries))
d296 2
a297 1
		if(!sk_X509_NAME_ENTRY_push(entries, entry)) goto memerr;
d300 6
a305 5
			       ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);
	if (!BUF_MEM_grow(a->bytes,len)) goto memerr;
	p=(unsigned char *)a->bytes->data;
	ASN1_item_ex_i2d(&intname.a,
			 &p, ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);
d307 1
a307 1
					     local_sk_X509_NAME_ENTRY_free);
d310 1
d313 1
a313 1
					     local_sk_X509_NAME_ENTRY_free);
d318 3
a320 4
static int x509_name_ex_print(BIO *out, ASN1_VALUE **pval,
						int indent,
						const char *fname, 
						const ASN1_PCTX *pctx)
d322 2
a323 2
	if (X509_NAME_print_ex(out, (X509_NAME *)*pval,
					indent, pctx->nm_flags) <= 0)
d341 2
a342 1
static int x509_name_canon(X509_NAME *a)
d353 1
a353 1
		}
d360 1
a360 1
	if(!intname)
d362 1
a362 1
	for(i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
d364 1
a364 1
		if(entry->set != set) {
d366 1
a366 1
			if(!entries)
d368 1
a368 1
			if(!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries))
d376 1
a376 1
		if(!sk_X509_NAME_ENTRY_push(entries, tmpentry))
a381 1

a382 1

a383 1

a385 1

a386 1

a387 1

d390 1
a390 1
	err:
d396 1
a396 1
					local_sk_X509_NAME_ENTRY_pop_free);
a405 1
	
d407 3
a409 1
static int asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in)
d438 1
a438 1
	while((len > 0) && !(*from & 0x80) && isspace(*from)) {
d454 1
a454 1
	while(i < len) {
d459 1
a459 1
			}
d465 1
a465 1
			 * check len here because we know the last 
d471 1
a471 1
			} while(!(*from & 0x80) && isspace(*from));
a481 1

d484 2
a485 2
static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *_intname,
			  unsigned char **in)
d495 1
a495 1
			ASN1_ITEM_rptr(X509_NAME_ENTRIES), -1, -1);
d503 2
a504 1
int X509_NAME_set(X509_NAME **xn, X509_NAME *name)
d508 2
a509 1
	if (!xn || !name) return(0);
d512 1
a512 1
		in=X509_NAME_dup(name);
d515 1
a515 1
			*xn=in;
d518 1
a518 1
	return(*xn != NULL);
d520 1
a520 1
	
@


1.13
log
@putting most of the braces in the right column is the very least we can do.
@
text
@d148 1
a148 2
	if (ret)
	{
d244 1
a244 1
	{
d246 1
a246 1
	}
d249 1
a249 1
	{
d251 1
a251 1
	}
d297 1
a297 1
	{
d302 1
a302 1
	}
d318 1
a318 1
	{
d325 1
a325 2
	if (a->canon_enc)
		{
d330 1
a330 2
	if (sk_X509_NAME_ENTRY_num(a->entries) == 0)
		{
d333 1
a333 1
		}
d337 1
a337 2
	for(i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++)
		{
d339 1
a339 2
		if(entry->set != set)
			{
d346 1
a346 1
			}
d354 1
a354 1
		}
d379 1
a379 1
	}
d390 1
a390 1
	{
d395 1
a395 2
	if (!(ASN1_tag2bit(in->type) & ASN1_MASK_CANON))
		{
d399 1
a399 1
		}
d418 1
a418 2
	while((len > 0) && !(*from & 0x80) && isspace(*from))
		{
d421 1
a421 1
		}
d426 1
a426 2
	while ((len > 0) && !(*to & 0x80) && isspace(*to))
		{
d429 1
a429 1
		}
d434 1
a434 2
	while(i < len)
		{
d436 1
a436 2
		if (*from & 0x80)
			{
d441 1
a441 2
		else if (isspace(*from))
			{
d448 1
a448 2
			do
				{
d451 2
a452 5
				}
			while(!(*from & 0x80) && isspace(*from));
			}
		else
			{
a455 1
			}
d457 1
d463 1
a463 1
	}
d467 1
a467 1
	{
d473 1
a473 2
	for (i = 0; i < sk_ASN1_VALUE_num(intname); i++)
		{
d480 1
a480 1
		}
d482 1
a482 1
	}
d485 1
a485 1
	{
d490 1
a490 2
	if (*xn != name)
		{
d492 1
a492 2
		if (in != NULL)
			{
a494 1
			}
d496 1
d498 1
a498 1
	}
@


1.12
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d149 1
a149 1
		{
d153 1
a153 1
		}
@


1.11
log
@resolve conflicts
@
text
@d135 1
a135 1
	ret = OPENSSL_malloc(sizeof(X509_NAME));
d152 1
a152 1
		OPENSSL_free(ret);
d167 2
a168 2
		OPENSSL_free(a->canon_enc);
	OPENSSL_free(a);
d328 1
a328 1
		OPENSSL_free(a->canon_enc);
d365 1
a365 1
	p = OPENSSL_malloc(a->canon_enclen);
@


1.10
log
@openssl-1.0.0e: resolve conflicts
@
text
@d402 1
a402 2
		out->type = in->type;
		if (!ASN1_STRING_set(out, in->data, in->length))
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d217 3
a219 1
	err:
d469 2
a470 1
			*to++ = tolower(*from++);
@


1.8
log
@resolve conflicts
@
text
@d60 1
d64 1
d66 2
a67 2
static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in, long len, const ASN1_ITEM *it,
					int tag, int aclass, char opt, ASN1_TLC *ctx);
d69 7
a75 1
static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass);
d80 10
d123 2
a124 1
	x509_name_ex_i2d
d140 2
d166 2
d172 3
a174 12
/* Used with sk_pop_free() to free up the internal representation.
 * NB: we only free the STACK and not its contents because it is
 * already present in the X509_NAME structure.
 */

static void sk_internal_free(void *a)
{
	sk_free(a);
}

static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in, long len, const ASN1_ITEM *it,
					int tag, int aclass, char opt, ASN1_TLC *ctx)
d177 2
a178 1
	union { STACK *s; ASN1_VALUE *a; } intname = {NULL};
d199 2
a200 2
	for(i = 0; i < sk_num(intname.s); i++) {
		entries = (STACK_OF(X509_NAME_ENTRY) *)sk_value(intname.s, i);
d209 4
a212 1
	sk_free(intname.s);
d227 6
a232 2
		ret = x509_name_encode((X509_NAME *)a);
		if(ret < 0) return ret;
d242 10
d254 2
a255 1
	union { STACK *s; ASN1_VALUE *a; } intname = {NULL};
d261 1
a261 1
	intname.s = sk_new_null();
d268 3
a270 1
			if(!sk_push(intname.s, (char *)entries)) goto memerr;
d281 2
a282 1
	sk_pop_free(intname.s, sk_internal_free);
d285 3
a287 2
	memerr:
	sk_pop_free(intname.s, sk_internal_free);
d292 205
@


1.7
log
@resolve conflicts
@
text
@d64 1
a64 1
static int x509_name_ex_d2i(ASN1_VALUE **val, unsigned char **in, long len, const ASN1_ITEM *it,
d126 1
a126 1
	ASN1err(ASN1_F_X509_NAME_NEW, ERR_R_MALLOC_FAILURE);
d159 1
a159 1
static int x509_name_ex_d2i(ASN1_VALUE **val, unsigned char **in, long len, const ASN1_ITEM *it,
d162 3
a164 2
	unsigned char *p = *in, *q;
	STACK *intname = NULL, **intname_pp = &intname;
a165 1
	X509_NAME *nm = NULL, **nm_pp = &nm;
d171 1
a171 1
	ret = ASN1_item_ex_d2i((ASN1_VALUE **)intname_pp,
d178 1
a178 1
	if(!x509_name_ex_new((ASN1_VALUE **)nm_pp, NULL)) goto err;
d180 2
a181 2
	if(!BUF_MEM_grow(nm->bytes, p - q)) goto err;
	memcpy(nm->bytes->data, q, p - q);
d184 2
a185 2
	for(i = 0; i < sk_num(intname); i++) {
		entries = (STACK_OF(X509_NAME_ENTRY) *)sk_value(intname, i);
d189 1
a189 1
			if(!sk_X509_NAME_ENTRY_push(nm->entries, entry))
d194 3
a196 3
	sk_free(intname);
	nm->modified = 0;
	*val = (ASN1_VALUE *)nm;
d200 1
a200 1
	ASN1err(ASN1_F_D2I_X509_NAME, ERR_R_NESTED_ASN1_ERROR);
d222 1
a222 1
	STACK *intname = NULL, **intname_pp = &intname;
d228 2
a229 2
	intname = sk_new_null();
	if(!intname) goto memerr;
d235 1
a235 1
			if(!sk_push(intname, (char *)entries)) goto memerr;
d240 1
a240 1
	len = ASN1_item_ex_i2d((ASN1_VALUE **)intname_pp, NULL,
d244 1
a244 1
	ASN1_item_ex_i2d((ASN1_VALUE **)intname_pp,
d246 1
a246 1
	sk_pop_free(intname, sk_internal_free);
d250 2
a251 2
	sk_pop_free(intname, sk_internal_free);
	ASN1err(ASN1_F_D2I_X509_NAME, ERR_R_MALLOC_FAILURE);
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d163 1
a163 1
	STACK *intname = NULL;
d165 1
a165 1
	X509_NAME *nm = NULL;
d171 3
a173 2
	ret = ASN1_item_ex_d2i((ASN1_VALUE **)&intname, &p, len, ASN1_ITEM_rptr(X509_NAME_INTERNAL),
								tag, aclass, opt, ctx);
d178 1
a178 1
	if(!x509_name_ex_new((ASN1_VALUE **)&nm, NULL)) goto err;
d222 1
a222 1
	STACK *intname = NULL;
d240 2
a241 1
	len = ASN1_item_ex_i2d((ASN1_VALUE **)&intname, NULL, ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);
d244 2
a245 1
	ASN1_item_ex_i2d((ASN1_VALUE **)&intname, &p, ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d61 1
a61 2
#include <openssl/objects.h>
#include <openssl/asn1_mac.h>
d64 2
a65 93
static int i2d_X509_NAME_entries(X509_NAME *a);
int i2d_X509_NAME_ENTRY(X509_NAME_ENTRY *a, unsigned char **pp)
	{
	M_ASN1_I2D_vars(a);

	M_ASN1_I2D_len(a->object,i2d_ASN1_OBJECT);
	M_ASN1_I2D_len(a->value,i2d_ASN1_PRINTABLE);

	M_ASN1_I2D_seq_total();

	M_ASN1_I2D_put(a->object,i2d_ASN1_OBJECT);
	M_ASN1_I2D_put(a->value,i2d_ASN1_PRINTABLE);

	M_ASN1_I2D_finish();
	}

X509_NAME_ENTRY *d2i_X509_NAME_ENTRY(X509_NAME_ENTRY **a, unsigned char **pp,
	     long length)
	{
	M_ASN1_D2I_vars(a,X509_NAME_ENTRY *,X509_NAME_ENTRY_new);

	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	M_ASN1_D2I_get(ret->object,d2i_ASN1_OBJECT);
	M_ASN1_D2I_get(ret->value,d2i_ASN1_PRINTABLE);
	ret->set=0;
	M_ASN1_D2I_Finish(a,X509_NAME_ENTRY_free,ASN1_F_D2I_X509_NAME_ENTRY);
	}

int i2d_X509_NAME(X509_NAME *a, unsigned char **pp)
	{
	int ret;

	if (a == NULL) return(0);
	if (a->modified)
		{
		ret=i2d_X509_NAME_entries(a);
		if (ret < 0) return(ret);
		}

	ret=a->bytes->length;
	if (pp != NULL)
		{
		memcpy(*pp,a->bytes->data,ret);
		*pp+=ret;
		}
	return(ret);
	}

static int i2d_X509_NAME_entries(X509_NAME *a)
	{
	X509_NAME_ENTRY *ne,*fe=NULL;
	STACK_OF(X509_NAME_ENTRY) *sk;
	BUF_MEM *buf=NULL;
	int set=0,r,ret=0;
	int i;
	unsigned char *p;
	int size=0;

	sk=a->entries;
	for (i=0; i<sk_X509_NAME_ENTRY_num(sk); i++)
		{
		ne=sk_X509_NAME_ENTRY_value(sk,i);
		if (fe == NULL)
			{
			fe=ne;
			size=0;
			}

		if (ne->set != set)
			{
			ret+=ASN1_object_size(1,size,V_ASN1_SET);
			fe->size=size;
			fe=ne;
			size=0;
			set=ne->set;
			}
		size+=i2d_X509_NAME_ENTRY(ne,NULL);
		}
	if (fe != NULL)
		{
		/* SET OF needed only if entries is non empty */
		ret+=ASN1_object_size(1,size,V_ASN1_SET);
		fe->size=size;
		}

	r=ASN1_object_size(1,ret,V_ASN1_SEQUENCE);

	buf=a->bytes;
	if (!BUF_MEM_grow(buf,r)) goto err;
	p=(unsigned char *)buf->data;

	ASN1_put_object(&p,1,ret,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);
d67 51
a117 63
	set= -1;
	for (i=0; i<sk_X509_NAME_ENTRY_num(sk); i++)
		{
		ne=sk_X509_NAME_ENTRY_value(sk,i);
		if (set != ne->set)
			{
			set=ne->set;
			ASN1_put_object(&p,1,ne->size,
				V_ASN1_SET,V_ASN1_UNIVERSAL);
			}
		i2d_X509_NAME_ENTRY(ne,&p);
		}
	a->modified=0;
	return(r);
err:
	return(-1);
	}

X509_NAME *d2i_X509_NAME(X509_NAME **a, unsigned char **pp, long length)
	{
	int set=0,i;
	int idx=0;
	unsigned char *orig;
	M_ASN1_D2I_vars(a,X509_NAME *,X509_NAME_new);

	orig= *pp;
	if (sk_X509_NAME_ENTRY_num(ret->entries) > 0)
		{
		while (sk_X509_NAME_ENTRY_num(ret->entries) > 0)
			X509_NAME_ENTRY_free(
				       sk_X509_NAME_ENTRY_pop(ret->entries));
		}

	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	for (;;)
		{
		if (M_ASN1_D2I_end_sequence()) break;
		M_ASN1_D2I_get_set_type(X509_NAME_ENTRY,ret->entries,
					d2i_X509_NAME_ENTRY,
					X509_NAME_ENTRY_free);
		for (; idx < sk_X509_NAME_ENTRY_num(ret->entries); idx++)
			{
			sk_X509_NAME_ENTRY_value(ret->entries,idx)->set=set;
			}
		set++;
		}

	i=(int)(c.p-orig);
	if (!BUF_MEM_grow(ret->bytes,i)) goto err;
	memcpy(ret->bytes->data,orig,i);
	ret->bytes->length=i;
	ret->modified=0;

	M_ASN1_D2I_Finish(a,X509_NAME_free,ASN1_F_D2I_X509_NAME);
	}

X509_NAME *X509_NAME_new(void)
	{
	X509_NAME *ret=NULL;
	ASN1_CTX c;

	M_ASN1_New_Malloc(ret,X509_NAME);
d119 2
a120 2
		{ c.line=__LINE__; goto err2; }
	M_ASN1_New(ret->bytes,BUF_MEM_new);
d122 2
a123 8
	return(ret);
	M_ASN1_New_Error(ASN1_F_X509_NAME_NEW);
	}

X509_NAME_ENTRY *X509_NAME_ENTRY_new(void)
	{
	X509_NAME_ENTRY *ret=NULL;
	ASN1_CTX c;
d125 15
a139 12
	M_ASN1_New_Malloc(ret,X509_NAME_ENTRY);
/*	M_ASN1_New(ret->object,ASN1_OBJECT_new);*/
	ret->object=NULL;
	ret->set=0;
	M_ASN1_New(ret->value,ASN1_STRING_new);
	return(ret);
	M_ASN1_New_Error(ASN1_F_X509_NAME_ENTRY_NEW);
	}

void X509_NAME_free(X509_NAME *a)
	{
	if(a == NULL)
d141 1
d146 105
a250 1
	}
a251 7
void X509_NAME_ENTRY_free(X509_NAME_ENTRY *a)
	{
	if (a == NULL) return;
	ASN1_OBJECT_free(a->object);
	M_ASN1_BIT_STRING_free(a->value);
	OPENSSL_free(a);
	}
d257 1
a257 1
	if (*xn == NULL) return(0);
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@a143 2

	ret+=ASN1_object_size(1,size,V_ASN1_SET);
d145 3
d149 1
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d220 1
a220 1
	if ((ret->entries=sk_X509_NAME_ENTRY_new(NULL)) == NULL)
d249 1
a249 1
	Free(a);
d257 1
a257 1
	Free(a);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d256 1
a256 1
	ASN1_BIT_STRING_free(a->value);
@


1.1
log
@Initial revision
@
text
@d61 3
a63 2
#include "objects.h"
#include "asn1_mac.h"
a64 8
/*
 * ASN1err(ASN1_F_D2I_X509_NAME,ASN1_R_LENGTH_MISMATCH);
 * ASN1err(ASN1_F_X509_NAME_NEW,ASN1_R_UNKNOWN_ATTRIBUTE_TYPE);
 * ASN1err(ASN1_F_D2I_X509_NAME_ENTRY,ASN1_R_LENGTH_MISMATCH);
 * ASN1err(ASN1_F_X509_NAME_ENTRY_NEW,ASN1_R_UNKNOWN_ATTRIBUTE_TYPE);
 */

#ifndef NOPROTO
d66 1
a66 7
#else
static int i2d_X509_NAME_entries();
#endif

int i2d_X509_NAME_ENTRY(a,pp)
X509_NAME_ENTRY *a;
unsigned char **pp;
d81 2
a82 4
X509_NAME_ENTRY *d2i_X509_NAME_ENTRY(a,pp,length)
X509_NAME_ENTRY **a;
unsigned char **pp;
long length;
d94 1
a94 3
int i2d_X509_NAME(a,pp)
X509_NAME *a;
unsigned char **pp;
d114 1
a114 2
static int i2d_X509_NAME_entries(a)
X509_NAME *a;
d117 1
a117 1
	STACK *sk;
d125 1
a125 1
	for (i=0; i<sk_num(sk); i++)
d127 1
a127 1
		ne=(X509_NAME_ENTRY *)sk_value(sk,i);
d158 1
a158 1
	for (i=0; i<sk_num(sk); i++)
d160 1
a160 1
		ne=(X509_NAME_ENTRY *)sk_value(sk,i);
d175 1
a175 4
X509_NAME *d2i_X509_NAME(a,pp,length)
X509_NAME **a;
unsigned char **pp;
long length;
d183 1
a183 1
	if (sk_num(ret->entries) > 0)
d185 3
a187 3
		while (sk_num(ret->entries) > 0)
			X509_NAME_ENTRY_free((X509_NAME_ENTRY *)
				sk_pop(ret->entries));
d195 4
a198 2
		M_ASN1_D2I_get_set(ret->entries,d2i_X509_NAME_ENTRY);
		for (; idx < sk_num(ret->entries); idx++)
d200 1
a200 2
			((X509_NAME_ENTRY *)sk_value(ret->entries,idx))->set=
				set;
d214 1
a214 1
X509_NAME *X509_NAME_new()
d217 1
d220 2
a221 1
	if ((ret->entries=sk_new(NULL)) == NULL) goto err2;
d228 1
a228 1
X509_NAME_ENTRY *X509_NAME_ENTRY_new()
d231 1
d242 1
a242 2
void X509_NAME_free(a)
X509_NAME *a;
d244 3
d248 2
a249 2
	sk_pop_free(a->entries,X509_NAME_ENTRY_free);
	Free((char *)a);
d252 1
a252 2
void X509_NAME_ENTRY_free(a)
X509_NAME_ENTRY *a;
d257 1
a257 1
	Free((char *)a);
d260 1
a260 3
int X509_NAME_set(xn,name)
X509_NAME **xn;
X509_NAME *name;
d278 2
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 2
a62 2
#include <openssl/asn1t.h>
#include <openssl/x509.h>
d64 57
a120 2
static int x509_name_ex_d2i(ASN1_VALUE **val, unsigned char **in, long len, const ASN1_ITEM *it,
					int tag, int aclass, char opt, ASN1_TLC *ctx);
d122 8
a129 3
static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass);
static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it);
static void x509_name_ex_free(ASN1_VALUE **val, const ASN1_ITEM *it);
d131 10
a140 1
static int x509_name_encode(X509_NAME *a);
d142 9
a150 4
ASN1_SEQUENCE(X509_NAME_ENTRY) = {
	ASN1_SIMPLE(X509_NAME_ENTRY, object, ASN1_OBJECT),
	ASN1_SIMPLE(X509_NAME_ENTRY, value, ASN1_PRINTABLE)
} ASN1_SEQUENCE_END(X509_NAME_ENTRY)
d152 14
a165 2
IMPLEMENT_ASN1_FUNCTIONS(X509_NAME_ENTRY)
IMPLEMENT_ASN1_DUP_FUNCTION(X509_NAME_ENTRY)
d167 57
a223 3
/* For the "Name" type we need a SEQUENCE OF { SET OF X509_NAME_ENTRY }
 * so declare two template wrappers for this
 */
d225 5
a229 13
ASN1_ITEM_TEMPLATE(X509_NAME_ENTRIES) =
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SET_OF, 0, RDNS, X509_NAME_ENTRY)
ASN1_ITEM_TEMPLATE_END(X509_NAME_ENTRIES)

ASN1_ITEM_TEMPLATE(X509_NAME_INTERNAL) =
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, Name, X509_NAME_ENTRIES)
ASN1_ITEM_TEMPLATE_END(X509_NAME_INTERNAL)

/* Normally that's where it would end: we'd have two nested STACK structures
 * representing the ASN1. Unfortunately X509_NAME uses a completely different
 * form and caches encodings so we have to process the internal form and convert
 * to the external form.
 */
d231 2
a232 25
const ASN1_EXTERN_FUNCS x509_name_ff = {
	NULL,
	x509_name_ex_new,
	x509_name_ex_free,
	0,	/* Default clear behaviour is OK */
	x509_name_ex_d2i,
	x509_name_ex_i2d
};

IMPLEMENT_EXTERN_ASN1(X509_NAME, V_ASN1_SEQUENCE, x509_name_ff) 

IMPLEMENT_ASN1_FUNCTIONS(X509_NAME)
IMPLEMENT_ASN1_DUP_FUNCTION(X509_NAME)

static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it)
{
	X509_NAME *ret = NULL;
	ret = OPENSSL_malloc(sizeof(X509_NAME));
	if(!ret) goto memerr;
	if ((ret->entries=sk_X509_NAME_ENTRY_new_null()) == NULL)
		goto memerr;
	if((ret->bytes = BUF_MEM_new()) == NULL) goto memerr;
	ret->modified=1;
	*val = (ASN1_VALUE *)ret;
	return 1;
d234 3
a236 17
 memerr:
	ASN1err(ASN1_F_X509_NAME_NEW, ERR_R_MALLOC_FAILURE);
	if (ret)
		{
		if (ret->entries)
			sk_X509_NAME_ENTRY_free(ret->entries);
		OPENSSL_free(ret);
		}
	return 0;
}

static void x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
	X509_NAME *a;
	if(!pval || !*pval)
	    return;
	a = (X509_NAME *)*pval;
d238 7
a244 10
	BUF_MEM_free(a->bytes);
	sk_X509_NAME_ENTRY_pop_free(a->entries,X509_NAME_ENTRY_free);
	OPENSSL_free(a);
	*pval = NULL;
}

/* Used with sk_pop_free() to free up the internal representation.
 * NB: we only free the STACK and not its contents because it is
 * already present in the X509_NAME structure.
 */
d246 3
a248 21
static void sk_internal_free(void *a)
{
	sk_free(a);
}

static int x509_name_ex_d2i(ASN1_VALUE **val, unsigned char **in, long len, const ASN1_ITEM *it,
					int tag, int aclass, char opt, ASN1_TLC *ctx)
{
	unsigned char *p = *in, *q;
	STACK *intname = NULL;
	int i, j, ret;
	X509_NAME *nm = NULL;
	STACK_OF(X509_NAME_ENTRY) *entries;
	X509_NAME_ENTRY *entry;
	q = p;

	/* Get internal representation of Name */
	ret = ASN1_item_ex_d2i((ASN1_VALUE **)&intname, &p, len, ASN1_ITEM_rptr(X509_NAME_INTERNAL),
								tag, aclass, opt, ctx);
	
	if(ret <= 0) return ret;
d250 8
a257 26
	if(*val) x509_name_ex_free(val, NULL);
	if(!x509_name_ex_new((ASN1_VALUE **)&nm, NULL)) goto err;
	/* We've decoded it: now cache encoding */
	if(!BUF_MEM_grow(nm->bytes, p - q)) goto err;
	memcpy(nm->bytes->data, q, p - q);

	/* Convert internal representation to X509_NAME structure */
	for(i = 0; i < sk_num(intname); i++) {
		entries = (STACK_OF(X509_NAME_ENTRY) *)sk_value(intname, i);
		for(j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {
			entry = sk_X509_NAME_ENTRY_value(entries, j);
			entry->set = i;
			if(!sk_X509_NAME_ENTRY_push(nm->entries, entry))
				goto err;
		}
		sk_X509_NAME_ENTRY_free(entries);
	}
	sk_free(intname);
	nm->modified = 0;
	*val = (ASN1_VALUE *)nm;
	*in = p;
	return ret;
	err:
	ASN1err(ASN1_F_D2I_X509_NAME, ERR_R_NESTED_ASN1_ERROR);
	return 0;
}
d259 7
a265 48
static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass)
{
	int ret;
	X509_NAME *a = (X509_NAME *)*val;
	if(a->modified) {
		ret = x509_name_encode((X509_NAME *)a);
		if(ret < 0) return ret;
	}
	ret = a->bytes->length;
	if(out != NULL) {
		memcpy(*out,a->bytes->data,ret);
		*out+=ret;
	}
	return ret;
}

static int x509_name_encode(X509_NAME *a)
{
	STACK *intname = NULL;
	int len;
	unsigned char *p;
	STACK_OF(X509_NAME_ENTRY) *entries = NULL;
	X509_NAME_ENTRY *entry;
	int i, set = -1;
	intname = sk_new_null();
	if(!intname) goto memerr;
	for(i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
		entry = sk_X509_NAME_ENTRY_value(a->entries, i);
		if(entry->set != set) {
			entries = sk_X509_NAME_ENTRY_new_null();
			if(!entries) goto memerr;
			if(!sk_push(intname, (char *)entries)) goto memerr;
			set = entry->set;
		}
		if(!sk_X509_NAME_ENTRY_push(entries, entry)) goto memerr;
	}
	len = ASN1_item_ex_i2d((ASN1_VALUE **)&intname, NULL, ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);
	if (!BUF_MEM_grow(a->bytes,len)) goto memerr;
	p=(unsigned char *)a->bytes->data;
	ASN1_item_ex_i2d((ASN1_VALUE **)&intname, &p, ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);
	sk_pop_free(intname, sk_internal_free);
	a->modified = 0;
	return len;
	memerr:
	sk_pop_free(intname, sk_internal_free);
	ASN1err(ASN1_F_D2I_X509_NAME, ERR_R_MALLOC_FAILURE);
	return -1;
}
d267 8
d276 3
a278 1
int X509_NAME_set(X509_NAME **xn, X509_NAME *name)
d282 1
a282 1
	if (!xn || !name) return(0);
a295 2
IMPLEMENT_STACK_OF(X509_NAME_ENTRY)
IMPLEMENT_ASN1_SET_OF(X509_NAME_ENTRY)
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d163 1
a163 1
	STACK *intname = NULL, **intname_pp = &intname;
d165 1
a165 1
	X509_NAME *nm = NULL, **nm_pp = &nm;
d171 2
a172 3
	ret = ASN1_item_ex_d2i((ASN1_VALUE **)intname_pp,
			       &p, len, ASN1_ITEM_rptr(X509_NAME_INTERNAL),
			       tag, aclass, opt, ctx);
d177 1
a177 1
	if(!x509_name_ex_new((ASN1_VALUE **)nm_pp, NULL)) goto err;
d221 1
a221 1
	STACK *intname = NULL, **intname_pp = &intname;
d239 1
a239 2
	len = ASN1_item_ex_i2d((ASN1_VALUE **)intname_pp, NULL,
			       ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);
d242 1
a242 2
	ASN1_item_ex_i2d((ASN1_VALUE **)intname_pp,
			 &p, ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d64 1
a64 1
static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in, long len, const ASN1_ITEM *it,
d126 1
a126 1
	ASN1err(ASN1_F_X509_NAME_EX_NEW, ERR_R_MALLOC_FAILURE);
d159 1
a159 1
static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in, long len, const ASN1_ITEM *it,
d162 2
a163 3
	const unsigned char *p = *in, *q;
	union { STACK *s; ASN1_VALUE *a; } intname = {NULL};
	union { X509_NAME *x; ASN1_VALUE *a; } nm = {NULL};
d165 1
d171 1
a171 1
	ret = ASN1_item_ex_d2i(&intname.a,
d178 1
a178 1
	if(!x509_name_ex_new(&nm.a, NULL)) goto err;
d180 2
a181 2
	if(!BUF_MEM_grow(nm.x->bytes, p - q)) goto err;
	memcpy(nm.x->bytes->data, q, p - q);
d184 2
a185 2
	for(i = 0; i < sk_num(intname.s); i++) {
		entries = (STACK_OF(X509_NAME_ENTRY) *)sk_value(intname.s, i);
d189 1
a189 1
			if(!sk_X509_NAME_ENTRY_push(nm.x->entries, entry))
d194 3
a196 3
	sk_free(intname.s);
	nm.x->modified = 0;
	*val = nm.a;
d200 1
a200 1
	ASN1err(ASN1_F_X509_NAME_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
d222 1
a222 1
	union { STACK *s; ASN1_VALUE *a; } intname = {NULL};
d228 2
a229 2
	intname.s = sk_new_null();
	if(!intname.s) goto memerr;
d235 1
a235 1
			if(!sk_push(intname.s, (char *)entries)) goto memerr;
d240 1
a240 1
	len = ASN1_item_ex_i2d(&intname.a, NULL,
d244 1
a244 1
	ASN1_item_ex_i2d(&intname.a,
d246 1
a246 1
	sk_pop_free(intname.s, sk_internal_free);
d250 2
a251 2
	sk_pop_free(intname.s, sk_internal_free);
	ASN1err(ASN1_F_X509_NAME_ENCODE, ERR_R_MALLOC_FAILURE);
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@a59 1
#include <ctype.h>
a62 1
#include "asn1_locl.h"
d64 2
a65 2
typedef STACK_OF(X509_NAME_ENTRY) STACK_OF_X509_NAME_ENTRY;
DECLARE_STACK_OF(STACK_OF_X509_NAME_ENTRY)
d67 1
a67 7
static int x509_name_ex_d2i(ASN1_VALUE **val,
				const unsigned char **in, long len,
				const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx);

static int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out,
				const ASN1_ITEM *it, int tag, int aclass);
a71 10
static int x509_name_canon(X509_NAME *a);
static int asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in);
static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname,
			  unsigned char **in);


static int x509_name_ex_print(BIO *out, ASN1_VALUE **pval,
						int indent,
						const char *fname, 
						const ASN1_PCTX *pctx);
d105 1
a105 2
	x509_name_ex_i2d,
	x509_name_ex_print
a120 2
	ret->canon_enc = NULL;
	ret->canon_enclen = 0;
a144 2
	if (a->canon_enc)
		OPENSSL_free(a->canon_enc);
d149 12
a160 3
static int x509_name_ex_d2i(ASN1_VALUE **val,
			const unsigned char **in, long len, const ASN1_ITEM *it,
				int tag, int aclass, char opt, ASN1_TLC *ctx)
d163 1
a163 2
	union { STACK_OF(STACK_OF_X509_NAME_ENTRY) *s;
		ASN1_VALUE *a; } intname = {NULL};
d184 2
a185 2
	for(i = 0; i < sk_STACK_OF_X509_NAME_ENTRY_num(intname.s); i++) {
		entries = sk_STACK_OF_X509_NAME_ENTRY_value(intname.s, i);
d194 1
a194 4
	sk_STACK_OF_X509_NAME_ENTRY_free(intname.s);
	ret = x509_name_canon(nm.x);
	if (!ret)
		goto err;
d209 2
a210 6
		ret = x509_name_encode(a);
		if(ret < 0)
			return ret;
		ret = x509_name_canon(a);
		if(ret < 0)
			return ret;
a219 10
static void local_sk_X509_NAME_ENTRY_free(STACK_OF(X509_NAME_ENTRY) *ne)
	{
	sk_X509_NAME_ENTRY_free(ne);
	}

static void local_sk_X509_NAME_ENTRY_pop_free(STACK_OF(X509_NAME_ENTRY) *ne)
	{
	sk_X509_NAME_ENTRY_pop_free(ne, X509_NAME_ENTRY_free);
	}

d222 1
a222 2
	union { STACK_OF(STACK_OF_X509_NAME_ENTRY) *s;
		ASN1_VALUE *a; } intname = {NULL};
d228 1
a228 1
	intname.s = sk_STACK_OF_X509_NAME_ENTRY_new_null();
d235 1
a235 3
			if(!sk_STACK_OF_X509_NAME_ENTRY_push(intname.s,
							     entries))
				goto memerr;
d246 1
a246 2
	sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,
					     local_sk_X509_NAME_ENTRY_free);
d249 2
a250 3
memerr:
	sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,
					     local_sk_X509_NAME_ENTRY_free);
a254 205
static int x509_name_ex_print(BIO *out, ASN1_VALUE **pval,
						int indent,
						const char *fname, 
						const ASN1_PCTX *pctx)
	{
	if (X509_NAME_print_ex(out, (X509_NAME *)*pval,
					indent, pctx->nm_flags) <= 0)
		return 0;
	return 2;
	}

/* This function generates the canonical encoding of the Name structure.
 * In it all strings are converted to UTF8, leading, trailing and
 * multiple spaces collapsed, converted to lower case and the leading
 * SEQUENCE header removed.
 *
 * In future we could also normalize the UTF8 too.
 *
 * By doing this comparison of Name structures can be rapidly
 * perfomed by just using memcmp() of the canonical encoding.
 * By omitting the leading SEQUENCE name constraints of type
 * dirName can also be checked with a simple memcmp().
 */

static int x509_name_canon(X509_NAME *a)
	{
	unsigned char *p;
	STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
	STACK_OF(X509_NAME_ENTRY) *entries = NULL;
	X509_NAME_ENTRY *entry, *tmpentry = NULL;
	int i, set = -1, ret = 0;

	if (a->canon_enc)
		{
		OPENSSL_free(a->canon_enc);
		a->canon_enc = NULL;
		}
	/* Special case: empty X509_NAME => null encoding */
	if (sk_X509_NAME_ENTRY_num(a->entries) == 0)
		{
		a->canon_enclen = 0;
		return 1;
		}
	intname = sk_STACK_OF_X509_NAME_ENTRY_new_null();
	if(!intname)
		goto err;
	for(i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++)
		{
		entry = sk_X509_NAME_ENTRY_value(a->entries, i);
		if(entry->set != set)
			{
			entries = sk_X509_NAME_ENTRY_new_null();
			if(!entries)
				goto err;
			if(!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries))
				goto err;
			set = entry->set;
			}
		tmpentry = X509_NAME_ENTRY_new();
		tmpentry->object = OBJ_dup(entry->object);
		if (!asn1_string_canon(tmpentry->value, entry->value))
			goto err;
		if(!sk_X509_NAME_ENTRY_push(entries, tmpentry))
			goto err;
		tmpentry = NULL;
		}

	/* Finally generate encoding */

	a->canon_enclen = i2d_name_canon(intname, NULL);

	p = OPENSSL_malloc(a->canon_enclen);

	if (!p)
		goto err;

	a->canon_enc = p;

	i2d_name_canon(intname, &p);

	ret = 1;

	err:

	if (tmpentry)
		X509_NAME_ENTRY_free(tmpentry);
	if (intname)
		sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
					local_sk_X509_NAME_ENTRY_pop_free);
	return ret;
	}

/* Bitmap of all the types of string that will be canonicalized. */

#define ASN1_MASK_CANON	\
	(B_ASN1_UTF8STRING | B_ASN1_BMPSTRING | B_ASN1_UNIVERSALSTRING \
	| B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_IA5STRING \
	| B_ASN1_VISIBLESTRING)
	

static int asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in)
	{
	unsigned char *to, *from;
	int len, i;

	/* If type not in bitmask just copy string across */
	if (!(ASN1_tag2bit(in->type) & ASN1_MASK_CANON))
		{
		out->type = in->type;
		if (!ASN1_STRING_set(out, in->data, in->length))
			return 0;
		return 1;
		}

	out->type = V_ASN1_UTF8STRING;
	out->length = ASN1_STRING_to_UTF8(&out->data, in);
	if (out->length == -1)
		return 0;

	to = out->data;
	from = to;

	len = out->length;

	/* Convert string in place to canonical form.
	 * Ultimately we may need to handle a wider range of characters
	 * but for now ignore anything with MSB set and rely on the
	 * isspace() and tolower() functions.
	 */

	/* Ignore leading spaces */
	while((len > 0) && !(*from & 0x80) && isspace(*from))
		{
		from++;
		len--;
		}

	to = from + len - 1;

	/* Ignore trailing spaces */
	while ((len > 0) && !(*to & 0x80) && isspace(*to))
		{
		to--;
		len--;
		}

	to = out->data;

	i = 0;
	while(i < len)
		{
		/* If MSB set just copy across */
		if (*from & 0x80)
			{
			*to++ = *from++;
			i++;
			}
		/* Collapse multiple spaces */
		else if (isspace(*from))
			{
			/* Copy one space across */
			*to++ = ' ';
			/* Ignore subsequent spaces. Note: don't need to
			 * check len here because we know the last 
			 * character is a non-space so we can't overflow.
			 */
			do
				{
				from++;
				i++;
				}
			while(!(*from & 0x80) && isspace(*from));
			}
		else
			{
			*to++ = tolower(*from++);
			i++;
			}
		}

	out->length = to - out->data;

	return 1;

	}

static int i2d_name_canon(STACK_OF(STACK_OF_X509_NAME_ENTRY) *_intname,
			  unsigned char **in)
	{
	int i, len, ltmp;
	ASN1_VALUE *v;
	STACK_OF(ASN1_VALUE) *intname = (STACK_OF(ASN1_VALUE) *)_intname;

	len = 0;
	for (i = 0; i < sk_ASN1_VALUE_num(intname); i++)
		{
		v = sk_ASN1_VALUE_value(intname, i);
		ltmp = ASN1_item_ex_i2d(&v, in,
			ASN1_ITEM_rptr(X509_NAME_ENTRIES), -1, -1);
		if (ltmp < 0)
			return ltmp;
		len += ltmp;
		}
	return len;
	}
@


1.1.1.6
log
@import OpenSSL 1.0.0e
@
text
@d217 1
a217 3
err:
        if (nm.x != NULL)
		X509_NAME_free(nm.x);
d467 1
a467 2
			*to++ = tolower(*from);
			from++;
@


1.1.1.7
log
@import OpenSSL-1.0.1c
@
text
@d402 2
a403 1
		if (!ASN1_STRING_copy(out, in))
@


