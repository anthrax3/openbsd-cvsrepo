head	1.44;
access;
symbols
	OPENBSD_6_2_BASE:1.44
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43;
locks; strict;
comment	@ * @;


1.44
date	2017.04.29.18.43.31;	author beck;	state Exp;
branches;
next	1.43;
commitid	8aY6ysZR2nh3niOc;

1.43
date	2016.08.07.03.27.21;	author tb;	state Exp;
branches
	1.43.4.1;
next	1.42;
commitid	grLSpvTr68XyHvmT;

1.42
date	2016.04.19.20.20.24;	author tj;	state Exp;
branches;
next	1.41;
commitid	iZJhAVPER3wiBek6;

1.41
date	2015.09.11.11.52.55;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	iXKQtu2B8x2yh0yk;

1.40
date	2015.08.25.17.26.43;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	21xiEZwxxunesfVs;

1.39
date	2015.06.13.02.33.58;	author bcook;	state Exp;
branches;
next	1.38;
commitid	1j0tuJL3zCx8gQY3;

1.38
date	2015.04.27.03.37.06;	author bcook;	state Exp;
branches;
next	1.37;
commitid	13gZSSDxU9GbfmDr;

1.37
date	2015.03.22.13.28.03;	author bcook;	state Exp;
branches;
next	1.36;
commitid	cmzOp8tijOBrF7Kc;

1.36
date	2014.10.11.16.44.05;	author bcook;	state Exp;
branches;
next	1.35;
commitid	OL2bSBfmy5C8QLXW;

1.35
date	2014.08.28.01.00.57;	author bcook;	state Exp;
branches;
next	1.34;
commitid	E5NcGUlyj8nrr9VG;

1.34
date	2014.08.16.18.42.41;	author bcook;	state Exp;
branches;
next	1.33;
commitid	AJZ6yblbimliEUX2;

1.33
date	2014.08.16.17.21.56;	author bcook;	state Exp;
branches;
next	1.32;
commitid	v8kIONl2paT6PFFK;

1.32
date	2014.07.22.01.15.58;	author bcook;	state Exp;
branches;
next	1.31;
commitid	mypIuWbBrM781Odg;

1.31
date	2014.07.21.23.34.54;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	gk0odKv3a7FxrMGZ;

1.30
date	2014.07.21.20.19.47;	author guenther;	state Exp;
branches;
next	1.29;
commitid	YSEc9bNwZ5UrloBr;

1.29
date	2014.07.21.19.15.56;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	FbnABDHuEowN12Dq;

1.28
date	2014.07.20.03.24.10;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	8xr1sUA2k7J8HBOw;

1.27
date	2014.07.19.16.12.00;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	oWjeTrZBQ00DYH7n;

1.26
date	2014.07.19.16.10.50;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	YCArPkBRyF2lC3Ss;

1.25
date	2014.07.16.14.26.47;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	a4Mpg9AHJHHaquhi;

1.24
date	2014.07.13.13.37.38;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Zy4DLvWKKFRZnvS5;

1.23
date	2014.07.13.13.03.09;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	eGUXBFLD6xH0xZHF;

1.22
date	2014.07.13.08.24.20;	author beck;	state Exp;
branches;
next	1.21;
commitid	OPKo292RVtf5Fu9c;

1.21
date	2014.07.12.20.41.47;	author wouter;	state Exp;
branches;
next	1.20;
commitid	831J69NQ2L1nOM1f;

1.20
date	2014.07.12.15.43.49;	author beck;	state Exp;
branches;
next	1.19;
commitid	DRpy15dDmRbYEvSl;

1.19
date	2014.07.12.14.46.31;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	aGhdpaTmiVmuu1bG;

1.18
date	2014.07.08.09.38.55;	author beck;	state Exp;
branches;
next	1.17;
commitid	k7egjevz61knTcxk;

1.17
date	2014.07.08.09.30.33;	author beck;	state Exp;
branches;
next	1.16;
commitid	mmgFMyh8xzVfWDZc;

1.16
date	2014.07.08.09.24.27;	author beck;	state Exp;
branches;
next	1.15;
commitid	XPaZdSMkBqpCYo2r;

1.15
date	2014.07.08.08.33.43;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	UP2SjClCrQEgdPkz;

1.14
date	2014.06.26.13.48.11;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	Jj9u9b2Ga0P4dsxc;

1.13
date	2014.06.25.17.04.18;	author beck;	state Exp;
branches;
next	1.12;
commitid	o7nNRtC7T4I0D3dw;

1.12
date	2014.06.25.16.45.49;	author beck;	state Exp;
branches;
next	1.11;
commitid	EPpJ21gTmGhhOMv0;

1.11
date	2014.06.25.16.31.03;	author beck;	state Exp;
branches;
next	1.10;
commitid	qlVHBNXZd14Y7UFK;

1.10
date	2014.06.25.16.29.30;	author beck;	state Exp;
branches;
next	1.9;
commitid	ADSmq8zPWgTzfgm2;

1.9
date	2014.06.25.15.53.56;	author beck;	state Exp;
branches;
next	1.8;
commitid	66X676PJ7rhgEm2K;

1.8
date	2014.06.23.03.47.46;	author beck;	state Exp;
branches;
next	1.7;
commitid	Zl44eeIb8lcnS4iR;

1.7
date	2014.06.23.03.32.57;	author beck;	state Exp;
branches;
next	1.6;
commitid	sQYnbedQUtYCUsW1;

1.6
date	2014.06.21.21.44.36;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	T9oRI3RPmvVbj278;

1.5
date	2014.06.21.02.08.34;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	DfuyRb7v7tAxILFl;

1.4
date	2014.06.20.20.27.22;	author beck;	state Exp;
branches;
next	1.3;
commitid	V7pxtfCXxW9H5aUS;

1.3
date	2014.06.20.20.18.19;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	m2IshFsE3mP0SPHi;

1.2
date	2014.06.20.19.53.36;	author otto;	state Exp;
branches;
next	1.1;
commitid	w4PH39b6Uk4XXqAd;

1.1
date	2014.06.20.19.08.11;	author beck;	state Exp;
branches;
next	;
commitid	fOlqoqnHY6kRyNDn;

1.43.4.1
date	2017.04.29.18.57.00;	author beck;	state Exp;
branches;
next	;
commitid	2LleVhVdLHIyE8Dm;


desc
@@


1.44
log
@Switch Linux getrandom() usage to non-blocking mode, continuing to
use fallback mechanims if unsuccessful.

The design of Linux getrandom is broken.  It has an
uninitialized phase coupled with blocking behaviour, which
is unacceptable from within a library at boot time without
possible recovery.
ok deraadt@@ jsing@@
@
text
@/*	$OpenBSD: getentropy_linux.c,v 1.43 2016/08/07 03:27:21 tb Exp $	*/

/*
 * Copyright (c) 2014 Theo de Raadt <deraadt@@openbsd.org>
 * Copyright (c) 2014 Bob Beck <beck@@obtuse.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Emulation of getentropy(2) as documented at:
 * http://man.openbsd.org/getentropy.2
 */

#define	_POSIX_C_SOURCE	199309L
#define	_GNU_SOURCE	1
#include <sys/types.h>
#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/resource.h>
#include <sys/syscall.h>
#ifdef SYS__sysctl
#include <linux/sysctl.h>
#endif
#include <sys/statvfs.h>
#include <sys/socket.h>
#include <sys/mount.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <link.h>
#include <termios.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <time.h>
#include <openssl/sha.h>

#include <linux/types.h>
#include <linux/random.h>
#ifdef HAVE_GETAUXVAL
#include <sys/auxv.h>
#endif
#include <sys/vfs.h>

#define REPEAT 5
#define min(a, b) (((a) < (b)) ? (a) : (b))

#define HX(a, b) \
	do { \
		if ((a)) \
			HD(errno); \
		else \
			HD(b); \
	} while (0)

#define HR(x, l) (SHA512_Update(&ctx, (char *)(x), (l)))
#define HD(x)	 (SHA512_Update(&ctx, (char *)&(x), sizeof (x)))
#define HF(x)    (SHA512_Update(&ctx, (char *)&(x), sizeof (void*)))

int	getentropy(void *buf, size_t len);

static int gotdata(char *buf, size_t len);
#ifdef SYS_getrandom
static int getentropy_getrandom(void *buf, size_t len);
#endif
static int getentropy_urandom(void *buf, size_t len);
#ifdef SYS__sysctl
static int getentropy_sysctl(void *buf, size_t len);
#endif
static int getentropy_fallback(void *buf, size_t len);
static int getentropy_phdr(struct dl_phdr_info *info, size_t size, void *data);

int
getentropy(void *buf, size_t len)
{
	int ret = -1;

	if (len > 256) {
		errno = EIO;
		return (-1);
	}

#ifdef SYS_getrandom
	/*
	 * Try descriptor-less getrandom(), in non-blocking mode.
	 *
	 * The design of Linux getrandom is broken.  It has an
	 * uninitialized phase coupled with blocking behaviour, which
	 * is unacceptable from within a library at boot time without
	 * possible recovery. See http://bugs.python.org/issue26839#msg267745
	 */
	ret = getentropy_getrandom(buf, len);
	if (ret != -1)
		return (ret);
#endif

	/*
	 * Try to get entropy with /dev/urandom
	 *
	 * This can fail if the process is inside a chroot or if file
	 * descriptors are exhausted.
	 */
	ret = getentropy_urandom(buf, len);
	if (ret != -1)
		return (ret);

#ifdef SYS__sysctl
	/*
	 * Try to use sysctl CTL_KERN, KERN_RANDOM, RANDOM_UUID.
	 * sysctl is a failsafe API, so it guarantees a result.  This
	 * should work inside a chroot, or when file descriptors are
	 * exhausted.
	 *
	 * However this can fail if the Linux kernel removes support
	 * for sysctl.  Starting in 2007, there have been efforts to
	 * deprecate the sysctl API/ABI, and push callers towards use
	 * of the chroot-unavailable fd-using /proc mechanism --
	 * essentially the same problems as /dev/urandom.
	 *
	 * Numerous setbacks have been encountered in their deprecation
	 * schedule, so as of June 2014 the kernel ABI still exists on
	 * most Linux architectures. The sysctl() stub in libc is missing
	 * on some systems.  There are also reports that some kernels
	 * spew messages to the console.
	 */
	ret = getentropy_sysctl(buf, len);
	if (ret != -1)
		return (ret);
#endif /* SYS__sysctl */

	/*
	 * Entropy collection via /dev/urandom and sysctl have failed.
	 *
	 * No other API exists for collecting entropy.  See the large
	 * comment block above.
	 *
	 * We have very few options:
	 *     - Even syslog_r is unsafe to call at this low level, so
	 *	 there is no way to alert the user or program.
	 *     - Cannot call abort() because some systems have unsafe
	 *	 corefiles.
	 *     - Could raise(SIGKILL) resulting in silent program termination.
	 *     - Return EIO, to hint that arc4random's stir function
	 *       should raise(SIGKILL)
	 *     - Do the best under the circumstances....
	 *
	 * This code path exists to bring light to the issue that Linux
	 * still does not provide a failsafe API for entropy collection.
	 *
	 * We hope this demonstrates that Linux should either retain their
	 * sysctl ABI, or consider providing a new failsafe API which
	 * works in a chroot or when file descriptors are exhausted.
	 */
#undef FAIL_INSTEAD_OF_TRYING_FALLBACK
#ifdef FAIL_INSTEAD_OF_TRYING_FALLBACK
	raise(SIGKILL);
#endif
	ret = getentropy_fallback(buf, len);
	if (ret != -1)
		return (ret);

	errno = EIO;
	return (ret);
}

/*
 * Basic sanity checking; wish we could do better.
 */
static int
gotdata(char *buf, size_t len)
{
	char	any_set = 0;
	size_t	i;

	for (i = 0; i < len; ++i)
		any_set |= buf[i];
	if (any_set == 0)
		return (-1);
	return (0);
}

#ifdef SYS_getrandom
static int
getentropy_getrandom(void *buf, size_t len)
{
	int pre_errno = errno;
	int ret;
	if (len > 256)
		return (-1);
	do {
		ret = syscall(SYS_getrandom, buf, len, GRND_NONBLOCK);
	} while (ret == -1 && errno == EINTR);

	if (ret != len)
		return (-1);
	errno = pre_errno;
	return (0);
}
#endif

static int
getentropy_urandom(void *buf, size_t len)
{
	struct stat st;
	size_t i;
	int fd, cnt, flags;
	int save_errno = errno;

start:

	flags = O_RDONLY;
#ifdef O_NOFOLLOW
	flags |= O_NOFOLLOW;
#endif
#ifdef O_CLOEXEC
	flags |= O_CLOEXEC;
#endif
	fd = open("/dev/urandom", flags, 0);
	if (fd == -1) {
		if (errno == EINTR)
			goto start;
		goto nodevrandom;
	}
#ifndef O_CLOEXEC
	fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);
#endif

	/* Lightly verify that the device node looks sane */
	if (fstat(fd, &st) == -1 || !S_ISCHR(st.st_mode)) {
		close(fd);
		goto nodevrandom;
	}
	if (ioctl(fd, RNDGETENTCNT, &cnt) == -1) {
		close(fd);
		goto nodevrandom;
	}
	for (i = 0; i < len; ) {
		size_t wanted = len - i;
		ssize_t ret = read(fd, (char *)buf + i, wanted);

		if (ret == -1) {
			if (errno == EAGAIN || errno == EINTR)
				continue;
			close(fd);
			goto nodevrandom;
		}
		i += ret;
	}
	close(fd);
	if (gotdata(buf, len) == 0) {
		errno = save_errno;
		return (0);		/* satisfied */
	}
nodevrandom:
	errno = EIO;
	return (-1);
}

#ifdef SYS__sysctl
static int
getentropy_sysctl(void *buf, size_t len)
{
	static int mib[] = { CTL_KERN, KERN_RANDOM, RANDOM_UUID };
	size_t i;
	int save_errno = errno;

	for (i = 0; i < len; ) {
		size_t chunk = min(len - i, 16);

		/* SYS__sysctl because some systems already removed sysctl() */
		struct __sysctl_args args = {
			.name = mib,
			.nlen = 3,
			.oldval = (char *)buf + i,
			.oldlenp = &chunk,
		};
		if (syscall(SYS__sysctl, &args) != 0)
			goto sysctlfailed;
		i += chunk;
	}
	if (gotdata(buf, len) == 0) {
		errno = save_errno;
		return (0);			/* satisfied */
	}
sysctlfailed:
	errno = EIO;
	return (-1);
}
#endif /* SYS__sysctl */

static const int cl[] = {
	CLOCK_REALTIME,
#ifdef CLOCK_MONOTONIC
	CLOCK_MONOTONIC,
#endif
#ifdef CLOCK_MONOTONIC_RAW
	CLOCK_MONOTONIC_RAW,
#endif
#ifdef CLOCK_TAI
	CLOCK_TAI,
#endif
#ifdef CLOCK_VIRTUAL
	CLOCK_VIRTUAL,
#endif
#ifdef CLOCK_UPTIME
	CLOCK_UPTIME,
#endif
#ifdef CLOCK_PROCESS_CPUTIME_ID
	CLOCK_PROCESS_CPUTIME_ID,
#endif
#ifdef CLOCK_THREAD_CPUTIME_ID
	CLOCK_THREAD_CPUTIME_ID,
#endif
};

static int
getentropy_phdr(struct dl_phdr_info *info, size_t size, void *data)
{
	SHA512_CTX *ctx = data;

	SHA512_Update(ctx, &info->dlpi_addr, sizeof (info->dlpi_addr));
	return (0);
}

static int
getentropy_fallback(void *buf, size_t len)
{
	uint8_t results[SHA512_DIGEST_LENGTH];
	int save_errno = errno, e, pgs = getpagesize(), faster = 0, repeat;
	static int cnt;
	struct timespec ts;
	struct timeval tv;
	struct rusage ru;
	sigset_t sigset;
	struct stat st;
	SHA512_CTX ctx;
	static pid_t lastpid;
	pid_t pid;
	size_t i, ii, m;
	char *p;

	pid = getpid();
	if (lastpid == pid) {
		faster = 1;
		repeat = 2;
	} else {
		faster = 0;
		lastpid = pid;
		repeat = REPEAT;
	}
	for (i = 0; i < len; ) {
		int j;
		SHA512_Init(&ctx);
		for (j = 0; j < repeat; j++) {
			HX((e = gettimeofday(&tv, NULL)) == -1, tv);
			if (e != -1) {
				cnt += (int)tv.tv_sec;
				cnt += (int)tv.tv_usec;
			}

			dl_iterate_phdr(getentropy_phdr, &ctx);

			for (ii = 0; ii < sizeof(cl)/sizeof(cl[0]); ii++)
				HX(clock_gettime(cl[ii], &ts) == -1, ts);

			HX((pid = getpid()) == -1, pid);
			HX((pid = getsid(pid)) == -1, pid);
			HX((pid = getppid()) == -1, pid);
			HX((pid = getpgid(0)) == -1, pid);
			HX((e = getpriority(0, 0)) == -1, e);

			if (!faster) {
				ts.tv_sec = 0;
				ts.tv_nsec = 1;
				(void) nanosleep(&ts, NULL);
			}

			HX(sigpending(&sigset) == -1, sigset);
			HX(sigprocmask(SIG_BLOCK, NULL, &sigset) == -1,
			    sigset);

			HF(getentropy);	/* an addr in this library */
			HF(printf);		/* an addr in libc */
			p = (char *)&p;
			HD(p);		/* an addr on stack */
			p = (char *)&errno;
			HD(p);		/* the addr of errno */

			if (i == 0) {
				struct sockaddr_storage ss;
				struct statvfs stvfs;
				struct termios tios;
				struct statfs stfs;
				socklen_t ssl;
				off_t off;

				/*
				 * Prime-sized mappings encourage fragmentation;
				 * thus exposing some address entropy.
				 */
				struct mm {
					size_t	npg;
					void	*p;
				} mm[] =	 {
					{ 17, MAP_FAILED }, { 3, MAP_FAILED },
					{ 11, MAP_FAILED }, { 2, MAP_FAILED },
					{ 5, MAP_FAILED }, { 3, MAP_FAILED },
					{ 7, MAP_FAILED }, { 1, MAP_FAILED },
					{ 57, MAP_FAILED }, { 3, MAP_FAILED },
					{ 131, MAP_FAILED }, { 1, MAP_FAILED },
				};

				for (m = 0; m < sizeof mm/sizeof(mm[0]); m++) {
					HX(mm[m].p = mmap(NULL,
					    mm[m].npg * pgs,
					    PROT_READ|PROT_WRITE,
					    MAP_PRIVATE|MAP_ANON, -1,
					    (off_t)0), mm[m].p);
					if (mm[m].p != MAP_FAILED) {
						size_t mo;

						/* Touch some memory... */
						p = mm[m].p;
						mo = cnt %
						    (mm[m].npg * pgs - 1);
						p[mo] = 1;
						cnt += (int)((long)(mm[m].p)
						    / pgs);
					}

					/* Check cnts and times... */
					for (ii = 0; ii < sizeof(cl)/sizeof(cl[0]);
					    ii++) {
						HX((e = clock_gettime(cl[ii],
						    &ts)) == -1, ts);
						if (e != -1)
							cnt += (int)ts.tv_nsec;
					}

					HX((e = getrusage(RUSAGE_SELF,
					    &ru)) == -1, ru);
					if (e != -1) {
						cnt += (int)ru.ru_utime.tv_sec;
						cnt += (int)ru.ru_utime.tv_usec;
					}
				}

				for (m = 0; m < sizeof mm/sizeof(mm[0]); m++) {
					if (mm[m].p != MAP_FAILED)
						munmap(mm[m].p, mm[m].npg * pgs);
					mm[m].p = MAP_FAILED;
				}

				HX(stat(".", &st) == -1, st);
				HX(statvfs(".", &stvfs) == -1, stvfs);
				HX(statfs(".", &stfs) == -1, stfs);

				HX(stat("/", &st) == -1, st);
				HX(statvfs("/", &stvfs) == -1, stvfs);
				HX(statfs("/", &stfs) == -1, stfs);

				HX((e = fstat(0, &st)) == -1, st);
				if (e == -1) {
					if (S_ISREG(st.st_mode) ||
					    S_ISFIFO(st.st_mode) ||
					    S_ISSOCK(st.st_mode)) {
						HX(fstatvfs(0, &stvfs) == -1,
						    stvfs);
						HX(fstatfs(0, &stfs) == -1,
						    stfs);
						HX((off = lseek(0, (off_t)0,
						    SEEK_CUR)) < 0, off);
					}
					if (S_ISCHR(st.st_mode)) {
						HX(tcgetattr(0, &tios) == -1,
						    tios);
					} else if (S_ISSOCK(st.st_mode)) {
						memset(&ss, 0, sizeof ss);
						ssl = sizeof(ss);
						HX(getpeername(0,
						    (void *)&ss, &ssl) == -1,
						    ss);
					}
				}

				HX((e = getrusage(RUSAGE_CHILDREN,
				    &ru)) == -1, ru);
				if (e != -1) {
					cnt += (int)ru.ru_utime.tv_sec;
					cnt += (int)ru.ru_utime.tv_usec;
				}
			} else {
				/* Subsequent hashes absorb previous result */
				HD(results);
			}

			HX((e = gettimeofday(&tv, NULL)) == -1, tv);
			if (e != -1) {
				cnt += (int)tv.tv_sec;
				cnt += (int)tv.tv_usec;
			}

			HD(cnt);
		}
#ifdef HAVE_GETAUXVAL
#ifdef AT_RANDOM
		/* Not as random as you think but we take what we are given */
		p = (char *) getauxval(AT_RANDOM);
		if (p)
			HR(p, 16);
#endif
#ifdef AT_SYSINFO_EHDR
		p = (char *) getauxval(AT_SYSINFO_EHDR);
		if (p)
			HR(p, pgs);
#endif
#ifdef AT_BASE
		p = (char *) getauxval(AT_BASE);
		if (p)
			HD(p);
#endif
#endif

		SHA512_Final(results, &ctx);
		memcpy((char *)buf + i, results, min(sizeof(results), len - i));
		i += min(sizeof(results), len - i);
	}
	explicit_bzero(&ctx, sizeof ctx);
	explicit_bzero(results, sizeof results);
	if (gotdata(buf, len) == 0) {
		errno = save_errno;
		return (0);		/* satisfied */
	}
	errno = EIO;
	return (-1);
}
@


1.43
log
@Update the link for the getentropy(2) manual to man.openbsd.org/

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.42 2016/04/19 20:20:24 tj Exp $	*/
d99 6
a104 1
	 * Try descriptor-less getrandom()
a108 2
	if (errno != ENOSYS)
		return (-1);
d162 1
a162 1
	 * does not provide a failsafe API for entropy collection.
d205 1
a205 1
		ret = syscall(SYS_getrandom, buf, len, 0);
@


1.43.4.1
log
@MFC: Switch Linux getrandom() usage to non-blocking mode, continuing to
use fallback mechanims if unsuccessful.

The design of Linux getrandom is broken.  It has an
uninitialized phase coupled with blocking behaviour, which
is unacceptable from within a library at boot time without
possible recovery.
ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.44 2017/04/29 18:43:31 beck Exp $	*/
d99 1
a99 6
	 * Try descriptor-less getrandom(), in non-blocking mode.
	 *
	 * The design of Linux getrandom is broken.  It has an
	 * uninitialized phase coupled with blocking behaviour, which
	 * is unacceptable from within a library at boot time without
	 * possible recovery. See http://bugs.python.org/issue26839#msg267745
d104 2
d159 1
a159 1
	 * still does not provide a failsafe API for entropy collection.
d202 1
a202 1
		ret = syscall(SYS_getrandom, buf, len, GRND_NONBLOCK);
@


1.42
log
@fix typo in comment; ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.41 2015/09/11 11:52:55 deraadt Exp $	*/
d20 1
a20 1
 * http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/getentropy.2
@


1.41
log
@unify files further
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.40 2015/08/25 17:26:43 deraadt Exp $	*/
d123 1
a123 1
	 * exhuasted.
@


1.40
log
@unify versions, so they are easier to diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.39 2015/06/13 02:33:58 bcook Exp $	*/
d94 1
a94 1
		return -1;
d189 2
a190 2
		return -1;
	return 0;
d263 1
a263 1
		return 0;		/* satisfied */
d267 1
a267 1
	return -1;
d298 1
a298 1
	return -1;
d333 1
a333 1
	return 0;
d543 1
a543 1
		return 0;		/* satisfied */
d546 1
a546 1
	return -1;
@


1.39
log
@Remove unneeded sys/sysctl.h on linux.

This only provides the sysctl wrapper in glibc, which we do not use and is not available in other libc implementations for Linux. Thanks to ncopa from github.
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.38 2015/04/27 03:37:06 bcook Exp $	*/
d302 1
a302 1
static int cl[] = {
@


1.38
log
@Not all Linux libc's include linux/sysctl.h in sys/sysctl.h.

Include it if we have the sysctl syscall.
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.36 2014/10/11 16:44:05 bcook Exp $	*/
a30 1
#include <sys/sysctl.h>
@


1.37
log
@sys/sysctl.h includes linux/sysctl.h, remove the extra unchecked include
@
text
@d30 1
a30 1
#ifdef HAVE_SYS_SYSCTL_H
d32 1
@


1.36
log
@include header needed by older linux kernels

not all versions of <linux/random.h> include <linux/types.h> by default
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.35 2014/08/28 01:00:57 bcook Exp $	*/
a53 1
#include <linux/sysctl.h>
@


1.35
log
@preserve errno value on success.

If getrandom returns a temporary failure, make sure errno is not polluted when
it succeeds. Thanks to deraadt@@ for pointing it out.
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.34 2014/08/16 18:42:41 bcook Exp $	*/
d52 1
@


1.34
log
@only build the getrandom path if SYS_getrandom is defined.

like the sysctl path
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.31 2014/07/21 23:34:54 deraadt Exp $	*/
d197 1
d205 4
a208 3
	if (ret == len)
		return (0);
	return (-1);
@


1.33
log
@getrandom(2) support for getentropy_linux

This enables support for the new getrandom(2) syscall in Linux 3.17.

If the call exists and fails, return a failure in getentropy(2) emulation as
well. This adds a EINTR check in case the urandom pool is not initialized.

Tested on Fedora Rawhide with 3.17rc0 and Ubuntu 14.04

ok deraadt@@
@
text
@d77 1
d79 1
d97 1
d106 1
d193 1
a196 1
#ifdef SYS_getrandom
a205 1
#endif
d208 1
@


1.32
log
@better match proposed syscall api
@
text
@d101 2
d192 2
a193 10
#if 0

/* Hand-definitions until the API becomes commonplace */
#ifndef SYS__getrandom
#ifdef __LP64__
#define SYS__getrandom 317
#else
#define SYS__getrandom 354
#endif
#endif
d196 4
a199 1
	ret = syscall(SYS__getrandom, buf, len, 0);
d203 1
a203 1
	return -1;
@


1.31
log
@protect sysctl path with SYS__sysctl instead; from enh@@google, ok bcook
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.30 2014/07/21 20:19:47 guenther Exp $	*/
a199 6
	struct __getrandom_args args = {
		.buf = buf;
		.len = len;
		.flags = 0;
	};

d202 1
a202 1
	ret = syscall(SYS__getrandom, &args);
@


1.30
log
@Use explicit_bzero() instead of memset() on buffers going out of scope.
Also, zero the SHA256 context.

suggested by "eric" in a comment on an opensslrampage.org post
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.29 2014/07/21 19:15:56 deraadt Exp $	*/
d79 1
a79 1
#ifdef CTL_MAXNAME
d112 1
a112 1
#ifdef CTL_MAXNAME
d134 1
a134 1
#endif /* CTL_MAXNAME */
d273 1
a273 1
#ifdef CTL_MAXNAME
d303 1
a303 1
#endif /* CTL_MAXNAME */
@


1.29
log
@cast from void * before math; enh@@google
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.28 2014/07/20 03:24:10 deraadt Exp $	*/
d542 2
a543 1
	memset(results, 0, sizeof results);
@


1.28
log
@Demonstrate how new linux getrandom() will be called, at least until
it shows up in libraries.  Even the system call is probably not finalized.
Bit dissapointed it has turned out to be a descriptor-less read() with
EINVAL and EINTR error conditions, but we can work with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.27 2014/07/19 16:12:00 deraadt Exp $	*/
d288 1
a288 1
			.oldval = buf + i,
@


1.27
log
@remove disabled main hook; we use phdr now; ok bcook
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.26 2014/07/19 16:10:50 deraadt Exp $	*/
d77 1
d96 7
d185 28
@


1.26
log
@tab love
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.25 2014/07/16 14:26:47 kettenis Exp $	*/
a75 3
#if 0
extern int main(int, char *argv[]);
#endif
a359 3
#if 0
			HF(main);		/* an addr in program */
#endif
@


1.25
log
@Only call getauxval(3) if HAVE_GETAUXVAL is defined.  Fixes build on older
Linux (such as Ubuntu 12.04LTS) that don't have it yet.  Seems the AT_XXX
defines are pulled in by <link.h> now.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.24 2014/07/13 13:37:38 deraadt Exp $	*/
d23 2
a24 2
#define	_POSIX_C_SOURCE 199309L
#define	_GNU_SOURCE     1
@


1.24
log
@Use dl_iterate_phdr() to iterate over the segments and throw the addresses
into the hash; hoping the system has some ASLR or PIE.  This replaces and
substantially improves upon &main which proved problematic with some picky
linkers.
Work with kettenis, testing by beck
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.23 2014/07/13 13:03:09 deraadt Exp $	*/
d489 1
d505 1
@


1.23
log
@Provide a link to the canonical API specification.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.22 2014/07/13 08:24:20 beck Exp $	*/
d42 1
d85 1
d298 9
d341 2
@


1.22
log
@Take away the use of the address of main as a source of entropy. Causes
distractions to people testing and seeing link errors in some setups.
This will come back in another form
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.21 2014/07/12 20:41:47 wouter Exp $	*/
d18 3
@


1.21
log
@Remove signed/unsigned warning, statement before declaration and
add a function to use function pointers that does not take sizeof(fptr).

OK beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.20 2014/07/12 15:43:49 beck Exp $	*/
d72 1
d74 1
d347 1
d349 1
@


1.20
log
@guard inclusion of sys/sysctl.h so we can detect at compile time and
keep linux distros happy that don't have it.
ok bcook@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.19 2014/07/12 14:46:31 deraadt Exp $	*/
d68 1
d213 1
a213 1
		ssize_t ret = read(fd, buf + i, wanted);
d238 1
a238 1
	size_t i, chunk;
d242 1
a242 1
		chunk = min(len - i, 16);
d294 1
a294 1
	int save_errno = errno, e, m, pgs = getpagesize(), faster = 0, repeat;
d304 1
a304 1
	size_t i, ii;
d333 1
a333 1
			HX((m = getpriority(0, 0)) == -1, m);
d345 3
a347 3
			HD(main);		/* an addr in program */
			HD(getentropy);	/* an addr in this library */
			HD(printf);		/* an addr in libc */
d487 1
a487 1
		memcpy(buf + i, results, min(sizeof(results), len - i));
@


1.19
log
@remove gratuitous differences, ok beck bcook
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.18 2014/07/08 09:38:55 beck Exp $	*/
d27 1
d29 1
@


1.18
log
@fix oops, accidental delete.. darn copying of files between machines
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.17 2014/07/08 09:30:33 beck Exp $	*/
d144 2
a145 2
#undef FAIL_HARD_WHEN_LINUX_DEPRECATES_SYSCTL
#ifdef FAIL_HARD_WHEN_LINUX_DEPRECATES_SYSCTL
d182 1
a182 1
        flags = O_RDONLY;
d184 1
a184 1
        flags |= O_NOFOLLOW;
d187 1
a187 1
        flags |= O_CLOEXEC;
@


1.17
log
@j should be an int, like repeat
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.16 2014/07/08 09:24:27 beck Exp $	*/
d320 1
a320 1
			nt += (int)tv.tv_usec;
@


1.16
log
@unbreak last commit - but same intent, make re-seed less expensive
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.15 2014/07/08 08:33:43 deraadt Exp $	*/
d301 1
a301 1
	size_t i, j, ii;
d314 1
d320 1
a320 1
				cnt += (int)tv.tv_usec;
@


1.15
log
@repeat calls to getentrypy() with the same pid likely indicate reseeds.
Since we assume the PRNG above is doing "something old, something new"
folding, shortcut and do fewer repeats through the timing loop.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.14 2014/06/26 13:48:11 deraadt Exp $	*/
d291 1
a291 1
	int save_errno = errno, e, m, pgs = getpagesize(), repeat = 0;
d301 1
a301 1
	size_t i, ii;
d305 5
a309 3
	if (lastpid == getpid())
		repeat = REPEAT - 1;
	else
d311 2
a312 1

d315 1
a315 2
		for (; repeat < REPEAT; repeat++) {

d331 5
a335 3
			ts.tv_sec = 0;
			ts.tv_nsec = 1;
			(void) nanosleep(&ts, NULL);
@


1.14
log
@fix HD() misuse; from brent cook
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.13 2014/06/25 17:04:18 beck Exp $	*/
d291 1
a291 1
	int save_errno = errno, e, m, pgs = getpagesize(), repeat;
d299 1
d304 6
d312 1
a312 1
		for (repeat = 0; repeat < REPEAT; repeat++) {
@


1.13
log
@AT_BASE returns us the *address* of the start of ld.so, so
use the address, not what it points to (which is always the same)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.12 2014/06/25 16:45:49 beck Exp $	*/
d468 1
a468 1
			HD(p, sizeof(p));
@


1.12
log
@get the page of data at AT_SYSINFO_EHDR
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.9 2014/06/25 15:53:56 beck Exp $	*/
d468 1
a468 1
			HR(p, sizeof(p));
@


1.11
log
@comment fixes from theo
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.10 2014/06/25 16:29:30 beck Exp $	*/
d463 1
a463 1
			HR(p, sizeof(p));
@


1.10
log
@Possibly obtain a little bit of entropy from addresses returned
by getauxval if we have it.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.9 2014/06/25 15:53:56 beck Exp $	*/
d111 4
a114 3
	 * schedule, so as of June 2014 the kernel ABI still exists. The
	 * sysctl() stub in libc is missing on some systems.  There are
	 * also reports that some kernels spew messages to the console.
d157 1
a157 1
 * XXX Should be replaced with a proper entropy measure.
@


1.9
log
@O_NOFOLLOW would be very nice to have here if the version of linux
we are running supports it.
from enh@@google.com
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.8 2014/06/23 03:47:46 beck Exp $	*/
d48 3
d64 2
a65 1
#define HD(xxx)	(SHA512_Update(&ctx, (char *)&(xxx), sizeof (xxx)))
d453 17
@


1.8
log
@unbreak build of getentropy_sysctl - we need linux/sysctl.h, and
RANDOM_UUID is an enum member.
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.6 2014/06/21 21:44:36 deraadt Exp $	*/
d172 1
a172 1
	int fd, cnt;
d176 5
d182 3
a184 8
	fd = open("/dev/urandom", O_RDONLY|O_CLOEXEC, 0);
	if (fd == -1) {
		if (errno == EINTR)
			goto start;
		goto nodevrandom;
	}
#else
	fd = open("/dev/urandom", O_RDONLY, 0);
d190 1
@


1.7
log
@unbreak - main needs to be extern in here somewhere.
@
text
@d47 1
d68 1
d70 1
d93 1
a93 1
#ifdef RANDOM_UUID
d114 1
a114 1
#endif /* RANDOM_UUID */
d224 1
a224 1
#ifdef RANDOM_UUID
d228 1
a228 1
	static const int mib[] = { CTL_KERN, KERN_RANDOM, RANDOM_UUID };
d239 1
a239 1
			.oldval = &buf[i],
d254 1
a254 1
#endif /* RANDOM_UUID */
d339 1
a339 1
	
d355 1
a355 1
	
d373 1
a373 1
	
d382 1
a382 1
	
d390 1
a390 1
	
d396 1
a396 1
	
d400 1
a400 1
	
d404 1
a404 1
	
d428 1
a428 1
	
d439 1
a439 1
	
d445 1
a445 1
	
@


1.6
log
@repair indentation for an inner loop; shorten some macros and variable
names to shorten line lengths
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.5 2014/06/21 02:08:34 deraadt Exp $	*/
d64 1
@


1.5
log
@hash in correct pointer
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.4 2014/06/20 20:27:22 beck Exp $	*/
d52 1
a52 1
#define HASHX(a, b) \
d55 1
a55 1
			HASHD(errno); \
d57 1
a57 1
			HASHD(b); \
d60 1
a60 1
#define HASHD(xxx)	(SHA512_Update(&ctx, (char *)&(xxx), sizeof (xxx)))
d281 2
a282 2
	int save_errno = errno, e, m, pgsiz = getpagesize(), repeat;
	static int counter;
d291 1
a291 1
	void *p;
d297 1
a297 1
			HASHX((e = gettimeofday(&tv, NULL)) == -1, tv);
d299 2
a300 2
				counter += (int)tv.tv_sec;
				counter += (int)tv.tv_usec;
d304 1
a304 1
				HASHX(clock_gettime(cl[ii], &ts) == -1, ts);
d306 5
a310 5
			HASHX((pid = getpid()) == -1, pid);
			HASHX((pid = getsid(pid)) == -1, pid);
			HASHX((pid = getppid()) == -1, pid);
			HASHX((pid = getpgid(0)) == -1, pid);
			HASHX((m = getpriority(0, 0)) == -1, m);
d316 2
a317 2
			HASHX(sigpending(&sigset) == -1, sigset);
			HASHX(sigprocmask(SIG_BLOCK, NULL, &sigset) == -1,
d320 65
a384 45
			HASHD(main);	   /* an address in the main program */
			HASHD(getentropy); /* man address in this library */
			HASHD(printf);	   /* an address in libc */
			p = (void *)&p;
			HASHD(p); 	  /* an address on stack */
			p = (void *)&errno;
			HASHD(p); 	 /* the address of errno */

		if (i == 0) {
			struct sockaddr_storage ss;
			struct statvfs stvfs;
			struct termios tios;
			struct statfs stfs;
			socklen_t ssl;
			off_t off;

			/*
			 * Prime-sized mappings encourage fragmentation;
			 * thus exposing some address entropy.
			 */
			struct mm {
				size_t	npg;
				void	*p;
			} mm[] =	 {
				{ 17, MAP_FAILED }, { 3, MAP_FAILED },
				{ 11, MAP_FAILED }, { 2, MAP_FAILED },
				{ 5, MAP_FAILED }, { 3, MAP_FAILED },
				{ 7, MAP_FAILED }, { 1, MAP_FAILED },
				{ 57, MAP_FAILED }, { 3, MAP_FAILED },
				{ 131, MAP_FAILED }, { 1, MAP_FAILED },
			};

			for (m = 0; m < sizeof mm/sizeof(mm[0]); m++) {
				HASHX(mm[m].p = mmap(NULL, mm[m].npg * pgsiz,
				    PROT_READ|PROT_WRITE,
				    MAP_PRIVATE|MAP_ANON, -1, (off_t)0), mm[m].p);
				if (mm[m].p != MAP_FAILED) {
					char *mp;

					/* Touch some memory... */
					mp = mm[m].p;
					mp[counter % (mm[m].npg *
					    pgsiz - 1)] = 1;
					counter += (int)((long)(mm[m].p)
					    / pgsiz);
d386 37
a422 8

				/* Check counters and times... */
				for (ii = 0; ii < sizeof(cl)/sizeof(cl[0]);
				    ii++) {
					HASHX((e = clock_gettime(cl[ii],
					    &ts)) == -1, ts);
					if (e != -1)
						counter += (int)ts.tv_nsec;
d424 3
a426 3

				HASHX((e = getrusage(RUSAGE_SELF, &ru)) == -1,
				    ru);
d428 2
a429 37
					counter += (int)ru.ru_utime.tv_sec;
					counter += (int)ru.ru_utime.tv_usec;
				}
			}

			for (m = 0; m < sizeof mm/sizeof(mm[0]); m++) {
				if (mm[m].p != MAP_FAILED)
					munmap(mm[m].p, mm[m].npg * pgsiz);
				mm[m].p = MAP_FAILED;
			}

			HASHX(stat(".", &st) == -1, st);
			HASHX(statvfs(".", &stvfs) == -1, stvfs);
			HASHX(statfs(".", &stfs) == -1, stfs);

			HASHX(stat("/", &st) == -1, st);
			HASHX(statvfs("/", &stvfs) == -1, stvfs);
			HASHX(statfs("/", &stfs) == -1, stfs);

			HASHX((e = fstat(0, &st)) == -1, st);
			if (e == -1) {
				if (S_ISREG(st.st_mode) ||
				    S_ISFIFO(st.st_mode) ||
				    S_ISSOCK(st.st_mode)) {
					HASHX(fstatvfs(0, &stvfs) == -1,
					    stvfs);
					HASHX(fstatfs(0, &stfs) == -1, stfs);
					HASHX((off = lseek(0, (off_t)0,
					    SEEK_CUR)) < 0, off);
				}
				if (S_ISCHR(st.st_mode)) {
					HASHX(tcgetattr(0, &tios) == -1, tios);
				} else if (S_ISSOCK(st.st_mode)) {
					memset(&ss, 0, sizeof ss);
					ssl = sizeof(ss);
					HASHX(getpeername(0, (void *)&ss,
					    &ssl) == -1, ss);
d431 3
d435 2
a436 2

			HASHX((e = getrusage(RUSAGE_CHILDREN, &ru)) == -1, ru);
d438 2
a439 2
				counter += (int)ru.ru_utime.tv_sec;
				counter += (int)ru.ru_utime.tv_usec;
d441 2
a442 3
		} else {
			/* Subsequent hashes absorb previous result */
			HASHD(results);
a443 10

		HASHX((e = gettimeofday(&tv, NULL)) == -1, tv);
		if (e != -1) {
			counter += (int)tv.tv_sec;
			counter += (int)tv.tv_usec;
		}

		HASHD(counter);

		} /* repeat */
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.3 2014/06/20 20:18:19 deraadt Exp $	*/
d355 1
a355 1
				    MAP_PRIVATE|MAP_ANON, -1, (off_t)0), p);
@


1.3
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.2 2014/06/20 19:53:36 otto Exp $	*/
d91 4
a94 3
	 * Try to use sysctl CTL_KERN, KERN_RANDOM, RANDOM_UUID.  sysctl is
	 * a failsafe API, so it guarantees a result.  This should work
	 * inside a chroot, or when file descriptors are exhuasted.
d96 5
a100 5
	 * However this can fail if the Linux kernel removes support for sysctl.
	 * Starting in 2007, there have been efforts to deprecate the sysctl
	 * API/ABI, and push callers towards use of the chroot-unavailable
	 * fd-using /proc mechanism -- essentially the same problems as
	 * /dev/urandom.
d121 2
a122 1
	 *     - Cannot call abort() because some systems have unsafe corefiles.
d297 5
a301 5
		HASHX((e = gettimeofday(&tv, NULL)) == -1, tv);
		if (e != -1) {
			counter += (int)tv.tv_sec;
			counter += (int)tv.tv_usec;
		}
d303 2
a304 2
		for (ii = 0; ii < sizeof(cl)/sizeof(cl[0]); ii++)
			HASHX(clock_gettime(cl[ii], &ts) == -1, ts);
d306 21
a326 20
		HASHX((pid = getpid()) == -1, pid);
		HASHX((pid = getsid(pid)) == -1, pid);
		HASHX((pid = getppid()) == -1, pid);
		HASHX((pid = getpgid(0)) == -1, pid);
		HASHX((m = getpriority(0, 0)) == -1, m);

		ts.tv_sec = 0;
		ts.tv_nsec = 1;
		(void) nanosleep(&ts, NULL);

		HASHX(sigpending(&sigset) == -1, sigset);
		HASHX(sigprocmask(SIG_BLOCK, NULL, &sigset) == -1, sigset);

		HASHD(main);		/* an address in the main program */
		HASHD(getentropy);		/* an address in this library */
		HASHD(printf);		/* an address in libc */
		p = (void *)&p;
		HASHD(p);			/* an address on stack */
		p = (void *)&errno;
		HASHD(p);			/* the address of errno */
d343 7
a349 7
			} mm[] = {
			    { 17, MAP_FAILED }, { 3, MAP_FAILED },
			    { 11, MAP_FAILED }, { 2, MAP_FAILED },
			    { 5, MAP_FAILED }, { 3, MAP_FAILED },
			    { 7, MAP_FAILED }, { 1, MAP_FAILED },
			    { 57, MAP_FAILED }, { 3, MAP_FAILED },
			    { 131, MAP_FAILED }, { 1, MAP_FAILED },
d361 4
a364 2
					mp[counter % (mm[m].npg * pgsiz - 1)] = 1;
					counter += (int)((long)(mm[m].p) / pgsiz);
d370 2
a371 2
					HASHX((e = clock_gettime(cl[ii], &ts)) == -1,
					    ts);
d376 2
a377 1
				HASHX((e = getrusage(RUSAGE_SELF, &ru)) == -1, ru);
d400 2
a401 1
				if (S_ISREG(st.st_mode) || S_ISFIFO(st.st_mode) ||
d403 2
a404 1
					HASHX(fstatvfs(0, &stvfs) == -1, stvfs);
@


1.2
log
@rearrange so that the main function with the important comments is at the top
ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: getentropy_linux.c,v 1.1 2014/06/20 19:08:11 beck Exp $	*/
d182 1
a182 1
			goto nodevrandom;
@


1.1
log
@Work in progress on how to deal with the inherit unreliability of
/dev/urandom. Does well in the fallback case. Get it in tree so
it can be worked on.
ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a63 1
extern int main(int, char *argv[]);
d65 79
a440 76
}

int
getentropy(void *buf, size_t len)
{
	int ret = -1;

	if (len > 256) {
		errno = EIO;
		return -1;
	}

	/*
	 * Try to get entropy with /dev/urandom
	 *
	 * This can fail if the process is inside a chroot or if file
	 * descriptors are exhausted.
	 */
	ret = getentropy_urandom(buf, len);
	if (ret != -1)
		return (ret);

#ifdef RANDOM_UUID
	/*
	 * Try to use sysctl CTL_KERN, KERN_RANDOM, RANDOM_UUID.  sysctl is
	 * a failsafe API, so it guarantees a result.  This should work
	 * inside a chroot, or when file descriptors are exhuasted.
	 *
	 * However this can fail if the Linux kernel removes support for sysctl.
	 * Starting in 2007, there have been efforts to deprecate the sysctl
	 * API/ABI, and push callers towards use of the chroot-unavailable
	 * fd-using /proc mechanism -- essentially the same problems as
	 * /dev/urandom.
	 *
	 * Numerous setbacks have been encountered in their deprecation
	 * schedule, so as of June 2014 the kernel ABI still exists. The
	 * sysctl() stub in libc is missing on some systems.  There are
	 * also reports that some kernels spew messages to the console.
	 */
	ret = getentropy_sysctl(buf, len);
	if (ret != -1)
		return (ret);
#endif /* RANDOM_UUID */

	/*
	 * Entropy collection via /dev/urandom and sysctl have failed.
	 *
	 * No other API exists for collecting entropy.  See the large
	 * comment block above.
	 *
	 * We have very few options:
	 *     - Even syslog_r is unsafe to call at this low level, so
	 *	 there is no way to alert the user or program.
	 *     - Cannot call abort() because some systems have unsafe corefiles.
	 *     - Could raise(SIGKILL) resulting in silent program termination.
	 *     - Return EIO, to hint that arc4random's stir function
	 *       should raise(SIGKILL)
	 *     - Do the best under the circumstances....
	 *
	 * This code path exists to bring light to the issue that Linux
	 * does not provide a failsafe API for entropy collection.
	 *
	 * We hope this demonstrates that Linux should either retain their
	 * sysctl ABI, or consider providing a new failsafe API which
	 * works in a chroot or when file descriptors are exhausted.
	 */
#undef FAIL_HARD_WHEN_LINUX_DEPRECATES_SYSCTL
#ifdef FAIL_HARD_WHEN_LINUX_DEPRECATES_SYSCTL
	raise(SIGKILL);
#endif
	ret = getentropy_fallback(buf, len);
	if (ret != -1)
		return (ret);

	errno = EIO;
	return (ret);
@

