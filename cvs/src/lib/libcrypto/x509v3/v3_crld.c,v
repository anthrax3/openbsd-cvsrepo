head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.2
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21;
locks; strict;
comment	@ * @;


1.22
date	2017.05.02.04.11.08;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	nMFcck4ZnMnM0Ie2;

1.21
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.20;
commitid	kT0fLt3r4lroFJra;

1.20
date	2016.12.30.15.54.49;	author jsing;	state Exp;
branches;
next	1.19;
commitid	kn1H5Mumrqi1t2NN;

1.19
date	2015.07.29.16.13.48;	author jsing;	state Exp;
branches;
next	1.18;
commitid	p0YErzIitgRtixdM;

1.18
date	2015.07.25.16.14.29;	author jsing;	state Exp;
branches;
next	1.17;
commitid	zsQhEc8DIa1ZAAEL;

1.17
date	2015.07.25.16.00.14;	author jsing;	state Exp;
branches;
next	1.16;
commitid	IQmUl7Av61G6tr84;

1.16
date	2015.02.14.15.19.04;	author miod;	state Exp;
branches;
next	1.15;
commitid	Vpu7eteZ8LtAv8VW;

1.15
date	2015.02.10.08.33.10;	author jsing;	state Exp;
branches;
next	1.14;
commitid	v5VD2cgZRaYX8ah1;

1.14
date	2015.02.09.16.03.11;	author jsing;	state Exp;
branches;
next	1.13;
commitid	xIhBiKP17QbaVYG2;

1.13
date	2014.10.05.18.27.58;	author miod;	state Exp;
branches;
next	1.12;
commitid	zjwP8qQhJG7MS2F0;

1.12
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.11;
commitid	yQEL1wOWIearrW15;

1.11
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.10;
commitid	id8dTrTMtnTn4fqt;

1.10
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	mJUVYpkFBZ0Zv2bG;

1.9
date	2014.04.21.14.27.06;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.16;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.12.18;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.54;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.02;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.20.41.53;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.14.01;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.22
log
@the XXXfree functions being called accept NULL, so don't check first.
ok beck
@
text
@/* $OpenBSD: v3_crld.c,v 1.21 2017/01/29 17:49:23 beck Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999.
 */
/* ====================================================================
 * Copyright (c) 1999-2008 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/asn1.h>
#include <openssl/asn1t.h>
#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/x509v3.h>

static void *v2i_crld(const X509V3_EXT_METHOD *method,
    X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
static int i2r_crldp(const X509V3_EXT_METHOD *method, void *pcrldp, BIO *out,
    int indent);

const X509V3_EXT_METHOD v3_crld = {
	.ext_nid = NID_crl_distribution_points,
	.ext_flags = 0,
	.it = &CRL_DIST_POINTS_it,
	.ext_new = NULL,
	.ext_free = NULL,
	.d2i = NULL,
	.i2d = NULL,
	.i2s = NULL,
	.s2i = NULL,
	.i2v = NULL,
	.v2i = v2i_crld,
	.i2r = i2r_crldp,
	.r2i = NULL,
	.usr_data = NULL,
};

const X509V3_EXT_METHOD v3_freshest_crl = {
	.ext_nid = NID_freshest_crl,
	.ext_flags = 0,
	.it = &CRL_DIST_POINTS_it,
	.ext_new = NULL,
	.ext_free = NULL,
	.d2i = NULL,
	.i2d = NULL,
	.i2s = NULL,
	.s2i = NULL,
	.i2v = NULL,
	.v2i = v2i_crld,
	.i2r = i2r_crldp,
	.r2i = NULL,
	.usr_data = NULL,
};

static
STACK_OF(GENERAL_NAME) *gnames_from_sectname(X509V3_CTX *ctx, char *sect)
{
	STACK_OF(CONF_VALUE) *gnsect;
	STACK_OF(GENERAL_NAME) *gens;

	if (*sect == '@@')
		gnsect = X509V3_get_section(ctx, sect + 1);
	else
		gnsect = X509V3_parse_list(sect);
	if (!gnsect) {
		X509V3error(X509V3_R_SECTION_NOT_FOUND);
		return NULL;
	}
	gens = v2i_GENERAL_NAMES(NULL, ctx, gnsect);
	if (*sect == '@@')
		X509V3_section_free(ctx, gnsect);
	else
		sk_CONF_VALUE_pop_free(gnsect, X509V3_conf_free);
	return gens;
}

static int
set_dist_point_name(DIST_POINT_NAME **pdp, X509V3_CTX *ctx, CONF_VALUE *cnf)
{
	STACK_OF(GENERAL_NAME) *fnm = NULL;
	STACK_OF(X509_NAME_ENTRY) *rnm = NULL;

	if (!strncmp(cnf->name, "fullname", 9)) {
		fnm = gnames_from_sectname(ctx, cnf->value);
		if (!fnm)
			goto err;
	} else if (!strcmp(cnf->name, "relativename")) {
		int ret;
		STACK_OF(CONF_VALUE) *dnsect;
		X509_NAME *nm;
		nm = X509_NAME_new();
		if (!nm)
			return -1;
		dnsect = X509V3_get_section(ctx, cnf->value);
		if (!dnsect) {
			X509V3error(X509V3_R_SECTION_NOT_FOUND);
			X509_NAME_free(nm);
			return -1;
		}
		ret = X509V3_NAME_from_section(nm, dnsect, MBSTRING_ASC);
		X509V3_section_free(ctx, dnsect);
		rnm = nm->entries;
		nm->entries = NULL;
		X509_NAME_free(nm);
		if (!ret || sk_X509_NAME_ENTRY_num(rnm) <= 0)
			goto err;
		/* Since its a name fragment can't have more than one
		 * RDNSequence
		 */
		if (sk_X509_NAME_ENTRY_value(rnm,
		    sk_X509_NAME_ENTRY_num(rnm) - 1)->set) {
			X509V3error(X509V3_R_INVALID_MULTIPLE_RDNS);
			goto err;
		}
	} else
		return 0;

	if (*pdp) {
		X509V3error(X509V3_R_DISTPOINT_ALREADY_SET);
		goto err;
	}

	*pdp = DIST_POINT_NAME_new();
	if (!*pdp)
		goto err;
	if (fnm) {
		(*pdp)->type = 0;
		(*pdp)->name.fullname = fnm;
	} else {
		(*pdp)->type = 1;
		(*pdp)->name.relativename = rnm;
	}

	return 1;

err:
	sk_GENERAL_NAME_pop_free(fnm, GENERAL_NAME_free);
	sk_X509_NAME_ENTRY_pop_free(rnm, X509_NAME_ENTRY_free);
	return -1;
}

static const BIT_STRING_BITNAME reason_flags[] = {
	{0, "Unused", "unused"},
	{1, "Key Compromise", "keyCompromise"},
	{2, "CA Compromise", "CACompromise"},
	{3, "Affiliation Changed", "affiliationChanged"},
	{4, "Superseded", "superseded"},
	{5, "Cessation Of Operation", "cessationOfOperation"},
	{6, "Certificate Hold", "certificateHold"},
	{7, "Privilege Withdrawn", "privilegeWithdrawn"},
	{8, "AA Compromise", "AACompromise"},
	{-1, NULL, NULL}
};

static int
set_reasons(ASN1_BIT_STRING **preas, char *value)
{
	STACK_OF(CONF_VALUE) *rsk = NULL;
	const BIT_STRING_BITNAME *pbn;
	const char *bnam;
	int i, ret = 0;

	if (*preas != NULL)
		return 0;
	rsk = X509V3_parse_list(value);
	if (rsk == NULL)
		return 0;
	for (i = 0; i < sk_CONF_VALUE_num(rsk); i++) {
		bnam = sk_CONF_VALUE_value(rsk, i)->name;
		if (!*preas) {
			*preas = ASN1_BIT_STRING_new();
			if (!*preas)
				goto err;
		}
		for (pbn = reason_flags; pbn->lname; pbn++) {
			if (!strcmp(pbn->sname, bnam)) {
				if (!ASN1_BIT_STRING_set_bit(*preas,
				    pbn->bitnum, 1))
					goto err;
				break;
			}
		}
		if (!pbn->lname)
			goto err;
	}
	ret = 1;

err:
	sk_CONF_VALUE_pop_free(rsk, X509V3_conf_free);
	return ret;
}

static int
print_reasons(BIO *out, const char *rname, ASN1_BIT_STRING *rflags, int indent)
{
	int first = 1;
	const BIT_STRING_BITNAME *pbn;

	BIO_printf(out, "%*s%s:\n%*s", indent, "", rname, indent + 2, "");
	for (pbn = reason_flags; pbn->lname; pbn++) {
		if (ASN1_BIT_STRING_get_bit(rflags, pbn->bitnum)) {
			if (first)
				first = 0;
			else
				BIO_puts(out, ", ");
			BIO_puts(out, pbn->lname);
		}
	}
	if (first)
		BIO_puts(out, "<EMPTY>\n");
	else
		BIO_puts(out, "\n");
	return 1;
}

static DIST_POINT *
crldp_from_section(X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)
{
	int i;
	CONF_VALUE *cnf;
	DIST_POINT *point = NULL;

	point = DIST_POINT_new();
	if (!point)
		goto err;
	for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
		int ret;
		cnf = sk_CONF_VALUE_value(nval, i);
		ret = set_dist_point_name(&point->distpoint, ctx, cnf);
		if (ret > 0)
			continue;
		if (ret < 0)
			goto err;
		if (!strcmp(cnf->name, "reasons")) {
			if (!set_reasons(&point->reasons, cnf->value))
				goto err;
		}
		else if (!strcmp(cnf->name, "CRLissuer")) {
			point->CRLissuer =
			    gnames_from_sectname(ctx, cnf->value);
			if (!point->CRLissuer)
				goto err;
		}
	}

	return point;

err:
	DIST_POINT_free(point);
	return NULL;
}

static void *
v2i_crld(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
    STACK_OF(CONF_VALUE) *nval)
{
	STACK_OF(DIST_POINT) *crld = NULL;
	GENERAL_NAMES *gens = NULL;
	GENERAL_NAME *gen = NULL;
	CONF_VALUE *cnf;
	int i;

	if (!(crld = sk_DIST_POINT_new_null()))
		goto merr;
	for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
		DIST_POINT *point;
		cnf = sk_CONF_VALUE_value(nval, i);
		if (!cnf->value) {
			STACK_OF(CONF_VALUE) *dpsect;
			dpsect = X509V3_get_section(ctx, cnf->name);
			if (!dpsect)
				goto err;
			point = crldp_from_section(ctx, dpsect);
			X509V3_section_free(ctx, dpsect);
			if (!point)
				goto err;
			if (!sk_DIST_POINT_push(crld, point)) {
				DIST_POINT_free(point);
				goto merr;
			}
		} else {
			if (!(gen = v2i_GENERAL_NAME(method, ctx, cnf)))
				goto err;
			if (!(gens = GENERAL_NAMES_new()))
				goto merr;
			if (!sk_GENERAL_NAME_push(gens, gen))
				goto merr;
			gen = NULL;
			if (!(point = DIST_POINT_new()))
				goto merr;
			if (!sk_DIST_POINT_push(crld, point)) {
				DIST_POINT_free(point);
				goto merr;
			}
			if (!(point->distpoint = DIST_POINT_NAME_new()))
				goto merr;
			point->distpoint->name.fullname = gens;
			point->distpoint->type = 0;
			gens = NULL;
		}
	}
	return crld;

merr:
	X509V3error(ERR_R_MALLOC_FAILURE);
err:
	GENERAL_NAME_free(gen);
	GENERAL_NAMES_free(gens);
	sk_DIST_POINT_pop_free(crld, DIST_POINT_free);
	return NULL;
}

static int
dpn_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
{
	DIST_POINT_NAME *dpn = (DIST_POINT_NAME *)*pval;

	switch (operation) {
	case ASN1_OP_NEW_POST:
		dpn->dpname = NULL;
		break;

	case ASN1_OP_FREE_POST:
		if (dpn->dpname)
			X509_NAME_free(dpn->dpname);
		break;
	}
	return 1;
}


static const ASN1_AUX DIST_POINT_NAME_aux = {
	.app_data = NULL,
	.flags = 0,
	.ref_offset = 0,
	.ref_lock = 0,
	.asn1_cb = dpn_cb,
	.enc_offset = 0,
};
static const ASN1_TEMPLATE DIST_POINT_NAME_ch_tt[] = {
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SEQUENCE_OF,
		.tag = 0,
		.offset = offsetof(DIST_POINT_NAME, name.fullname),
		.field_name = "name.fullname",
		.item = &GENERAL_NAME_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SET_OF,
		.tag = 1,
		.offset = offsetof(DIST_POINT_NAME, name.relativename),
		.field_name = "name.relativename",
		.item = &X509_NAME_ENTRY_it,
	},
};

const ASN1_ITEM DIST_POINT_NAME_it = {
	.itype = ASN1_ITYPE_CHOICE,
	.utype = offsetof(DIST_POINT_NAME, type),
	.templates = DIST_POINT_NAME_ch_tt,
	.tcount = sizeof(DIST_POINT_NAME_ch_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &DIST_POINT_NAME_aux,
	.size = sizeof(DIST_POINT_NAME),
	.sname = "DIST_POINT_NAME",
};



DIST_POINT_NAME *
d2i_DIST_POINT_NAME(DIST_POINT_NAME **a, const unsigned char **in, long len)
{
	return (DIST_POINT_NAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &DIST_POINT_NAME_it);
}

int
i2d_DIST_POINT_NAME(DIST_POINT_NAME *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &DIST_POINT_NAME_it);
}

DIST_POINT_NAME *
DIST_POINT_NAME_new(void)
{
	return (DIST_POINT_NAME *)ASN1_item_new(&DIST_POINT_NAME_it);
}

void
DIST_POINT_NAME_free(DIST_POINT_NAME *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &DIST_POINT_NAME_it);
}

static const ASN1_TEMPLATE DIST_POINT_seq_tt[] = {
	{
		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(DIST_POINT, distpoint),
		.field_name = "distpoint",
		.item = &DIST_POINT_NAME_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 1,
		.offset = offsetof(DIST_POINT, reasons),
		.field_name = "reasons",
		.item = &ASN1_BIT_STRING_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
		.tag = 2,
		.offset = offsetof(DIST_POINT, CRLissuer),
		.field_name = "CRLissuer",
		.item = &GENERAL_NAME_it,
	},
};

const ASN1_ITEM DIST_POINT_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = DIST_POINT_seq_tt,
	.tcount = sizeof(DIST_POINT_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(DIST_POINT),
	.sname = "DIST_POINT",
};


DIST_POINT *
d2i_DIST_POINT(DIST_POINT **a, const unsigned char **in, long len)
{
	return (DIST_POINT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &DIST_POINT_it);
}

int
i2d_DIST_POINT(DIST_POINT *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &DIST_POINT_it);
}

DIST_POINT *
DIST_POINT_new(void)
{
	return (DIST_POINT *)ASN1_item_new(&DIST_POINT_it);
}

void
DIST_POINT_free(DIST_POINT *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &DIST_POINT_it);
}

static const ASN1_TEMPLATE CRL_DIST_POINTS_item_tt = {
	.flags = ASN1_TFLG_SEQUENCE_OF,
	.tag = 0,
	.offset = 0,
	.field_name = "CRLDistributionPoints",
	.item = &DIST_POINT_it,
};

const ASN1_ITEM CRL_DIST_POINTS_it = {
	.itype = ASN1_ITYPE_PRIMITIVE,
	.utype = -1,
	.templates = &CRL_DIST_POINTS_item_tt,
	.tcount = 0,
	.funcs = NULL,
	.size = 0,
	.sname = "CRL_DIST_POINTS",
};


CRL_DIST_POINTS *
d2i_CRL_DIST_POINTS(CRL_DIST_POINTS **a, const unsigned char **in, long len)
{
	return (CRL_DIST_POINTS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &CRL_DIST_POINTS_it);
}

int
i2d_CRL_DIST_POINTS(CRL_DIST_POINTS *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRL_DIST_POINTS_it);
}

CRL_DIST_POINTS *
CRL_DIST_POINTS_new(void)
{
	return (CRL_DIST_POINTS *)ASN1_item_new(&CRL_DIST_POINTS_it);
}

void
CRL_DIST_POINTS_free(CRL_DIST_POINTS *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &CRL_DIST_POINTS_it);
}

static const ASN1_TEMPLATE ISSUING_DIST_POINT_seq_tt[] = {
	{
		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(ISSUING_DIST_POINT, distpoint),
		.field_name = "distpoint",
		.item = &DIST_POINT_NAME_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 1,
		.offset = offsetof(ISSUING_DIST_POINT, onlyuser),
		.field_name = "onlyuser",
		.item = &ASN1_FBOOLEAN_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 2,
		.offset = offsetof(ISSUING_DIST_POINT, onlyCA),
		.field_name = "onlyCA",
		.item = &ASN1_FBOOLEAN_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 3,
		.offset = offsetof(ISSUING_DIST_POINT, onlysomereasons),
		.field_name = "onlysomereasons",
		.item = &ASN1_BIT_STRING_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 4,
		.offset = offsetof(ISSUING_DIST_POINT, indirectCRL),
		.field_name = "indirectCRL",
		.item = &ASN1_FBOOLEAN_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 5,
		.offset = offsetof(ISSUING_DIST_POINT, onlyattr),
		.field_name = "onlyattr",
		.item = &ASN1_FBOOLEAN_it,
	},
};

const ASN1_ITEM ISSUING_DIST_POINT_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = ISSUING_DIST_POINT_seq_tt,
	.tcount = sizeof(ISSUING_DIST_POINT_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(ISSUING_DIST_POINT),
	.sname = "ISSUING_DIST_POINT",
};


ISSUING_DIST_POINT *
d2i_ISSUING_DIST_POINT(ISSUING_DIST_POINT **a, const unsigned char **in, long len)
{
	return (ISSUING_DIST_POINT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &ISSUING_DIST_POINT_it);
}

int
i2d_ISSUING_DIST_POINT(ISSUING_DIST_POINT *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &ISSUING_DIST_POINT_it);
}

ISSUING_DIST_POINT *
ISSUING_DIST_POINT_new(void)
{
	return (ISSUING_DIST_POINT *)ASN1_item_new(&ISSUING_DIST_POINT_it);
}

void
ISSUING_DIST_POINT_free(ISSUING_DIST_POINT *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &ISSUING_DIST_POINT_it);
}

static int i2r_idp(const X509V3_EXT_METHOD *method, void *pidp, BIO *out,
    int indent);
static void *v2i_idp(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
    STACK_OF(CONF_VALUE) *nval);

const X509V3_EXT_METHOD v3_idp = {
	NID_issuing_distribution_point, X509V3_EXT_MULTILINE,
	&ISSUING_DIST_POINT_it,
	0, 0, 0, 0,
	0, 0,
	0,
	v2i_idp,
	i2r_idp, 0,
	NULL
};

static void *
v2i_idp(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
    STACK_OF(CONF_VALUE) *nval)
{
	ISSUING_DIST_POINT *idp = NULL;
	CONF_VALUE *cnf;
	char *name, *val;
	int i, ret;

	idp = ISSUING_DIST_POINT_new();
	if (!idp)
		goto merr;
	for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
		cnf = sk_CONF_VALUE_value(nval, i);
		name = cnf->name;
		val = cnf->value;
		ret = set_dist_point_name(&idp->distpoint, ctx, cnf);
		if (ret > 0)
			continue;
		if (ret < 0)
			goto err;
		if (!strcmp(name, "onlyuser")) {
			if (!X509V3_get_value_bool(cnf, &idp->onlyuser))
				goto err;
		}
		else if (!strcmp(name, "onlyCA")) {
			if (!X509V3_get_value_bool(cnf, &idp->onlyCA))
				goto err;
		}
		else if (!strcmp(name, "onlyAA")) {
			if (!X509V3_get_value_bool(cnf, &idp->onlyattr))
				goto err;
		}
		else if (!strcmp(name, "indirectCRL")) {
			if (!X509V3_get_value_bool(cnf, &idp->indirectCRL))
				goto err;
		}
		else if (!strcmp(name, "onlysomereasons")) {
			if (!set_reasons(&idp->onlysomereasons, val))
				goto err;
		} else {
			X509V3error(X509V3_R_INVALID_NAME);
			X509V3_conf_err(cnf);
			goto err;
		}
	}
	return idp;

merr:
	X509V3error(ERR_R_MALLOC_FAILURE);
err:
	ISSUING_DIST_POINT_free(idp);
	return NULL;
}

static int
print_gens(BIO *out, STACK_OF(GENERAL_NAME) *gens, int indent)
{
	int i;

	for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
		BIO_printf(out, "%*s", indent + 2, "");
		GENERAL_NAME_print(out, sk_GENERAL_NAME_value(gens, i));
		BIO_puts(out, "\n");
	}
	return 1;
}

static int
print_distpoint(BIO *out, DIST_POINT_NAME *dpn, int indent)
{
	if (dpn->type == 0) {
		BIO_printf(out, "%*sFull Name:\n", indent, "");
		print_gens(out, dpn->name.fullname, indent);
	} else {
		X509_NAME ntmp;
		ntmp.entries = dpn->name.relativename;
		BIO_printf(out, "%*sRelative Name:\n%*s",
		    indent, "", indent + 2, "");
		X509_NAME_print_ex(out, &ntmp, 0, XN_FLAG_ONELINE);
		BIO_puts(out, "\n");
	}
	return 1;
}

static int
i2r_idp(const X509V3_EXT_METHOD *method, void *pidp, BIO *out, int indent)
{
	ISSUING_DIST_POINT *idp = pidp;

	if (idp->distpoint)
		print_distpoint(out, idp->distpoint, indent);
	if (idp->onlyuser > 0)
		BIO_printf(out, "%*sOnly User Certificates\n", indent, "");
	if (idp->onlyCA > 0)
		BIO_printf(out, "%*sOnly CA Certificates\n", indent, "");
	if (idp->indirectCRL > 0)
		BIO_printf(out, "%*sIndirect CRL\n", indent, "");
	if (idp->onlysomereasons)
		print_reasons(out, "Only Some Reasons",
	    idp->onlysomereasons, indent);
	if (idp->onlyattr > 0)
		BIO_printf(out, "%*sOnly Attribute Certificates\n", indent, "");
	if (!idp->distpoint && (idp->onlyuser <= 0) && (idp->onlyCA <= 0) &&
	    (idp->indirectCRL <= 0) && !idp->onlysomereasons &&
	    (idp->onlyattr <= 0))
		BIO_printf(out, "%*s<EMPTY>\n", indent, "");

	return 1;
}

static int
i2r_crldp(const X509V3_EXT_METHOD *method, void *pcrldp, BIO *out, int indent)
{
	STACK_OF(DIST_POINT) *crld = pcrldp;
	DIST_POINT *point;
	int i;

	for (i = 0; i < sk_DIST_POINT_num(crld); i++) {
		BIO_puts(out, "\n");
		point = sk_DIST_POINT_value(crld, i);
		if (point->distpoint)
			print_distpoint(out, point->distpoint, indent);
		if (point->reasons)
			print_reasons(out, "Reasons", point->reasons,
		    indent);
		if (point->CRLissuer) {
			BIO_printf(out, "%*sCRL Issuer:\n", indent, "");
			print_gens(out, point->CRLissuer, indent);
		}
	}
	return 1;
}

int
DIST_POINT_set_dpname(DIST_POINT_NAME *dpn, X509_NAME *iname)
{
	int i;
	STACK_OF(X509_NAME_ENTRY) *frag;
	X509_NAME_ENTRY *ne;

	if (!dpn || (dpn->type != 1))
		return 1;
	frag = dpn->name.relativename;
	dpn->dpname = X509_NAME_dup(iname);
	if (!dpn->dpname)
		return 0;
	for (i = 0; i < sk_X509_NAME_ENTRY_num(frag); i++) {
		ne = sk_X509_NAME_ENTRY_value(frag, i);
		if (!X509_NAME_add_entry(dpn->dpname, ne, -1, i ? 0 : 1)) {
			X509_NAME_free(dpn->dpname);
			dpn->dpname = NULL;
			return 0;
		}
	}
	/* generate cached encoding of name */
	if (i2d_X509_NAME(dpn->dpname, NULL) < 0) {
		X509_NAME_free(dpn->dpname);
		dpn->dpname = NULL;
		return 0;
	}
	return 1;
}
@


1.21
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.20 2016/12/30 15:54:49 jsing Exp $ */
d189 2
a190 4
	if (fnm)
		sk_GENERAL_NAME_pop_free(fnm, GENERAL_NAME_free);
	if (rnm)
		sk_X509_NAME_ENTRY_pop_free(rnm, X509_NAME_ENTRY_free);
d301 1
a301 2
	if (point)
		DIST_POINT_free(point);
@


1.20
log
@Expand ASN1_ITEM_ref and ASN1_ITEM_ptr macros - no change in generated
assembly. Of particular interest is ASN1_ITEM_ptr which does nothing
and resulted in code like:

  if (method->it)
    ASN1_ITEM_free(..., ASN1_ITEM_ptr(method->it));
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.19 2015/07/29 16:13:48 jsing Exp $ */
d118 1
a118 2
		X509V3err(X509V3_F_GNAMES_FROM_SECTNAME,
		    X509V3_R_SECTION_NOT_FOUND);
d148 1
a148 2
			X509V3err(X509V3_F_SET_DIST_POINT_NAME,
			    X509V3_R_SECTION_NOT_FOUND);
d164 1
a164 2
			X509V3err(X509V3_F_SET_DIST_POINT_NAME,
			    X509V3_R_INVALID_MULTIPLE_RDNS);
d171 1
a171 2
		X509V3err(X509V3_F_SET_DIST_POINT_NAME,
		    X509V3_R_DISTPOINT_ALREADY_SET);
d360 1
a360 1
	X509V3err(X509V3_F_V2I_CRLD, ERR_R_MALLOC_FAILURE);
d691 1
a691 1
			X509V3err(X509V3_F_V2I_IDP, X509V3_R_INVALID_NAME);
d699 1
a699 1
	X509V3err(X509V3_F_V2I_IDP, ERR_R_MALLOC_FAILURE);
@


1.19
log
@Use named initialisers for X509V3_EXT_METHOD structs (for the usual
reasons) - only change in generated assembly is due to line numbering.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.18 2015/07/25 16:14:29 jsing Exp $ */
d76 1
a76 1
	.it = ASN1_ITEM_ref(CRL_DIST_POINTS),
d93 1
a93 1
	.it = ASN1_ITEM_ref(CRL_DIST_POINTS),
d645 1
a645 1
	ASN1_ITEM_ref(ISSUING_DIST_POINT),
@


1.18
log
@Expand ASN.1 template macros that got missed in the last pass - only change
to generated assembly is due to line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.17 2015/07/25 16:00:14 jsing Exp $ */
d74 14
a87 7
	NID_crl_distribution_points, 0, ASN1_ITEM_ref(CRL_DIST_POINTS),
	0, 0, 0, 0,
	0, 0,
	0,
	v2i_crld,
	i2r_crldp, 0,
	NULL
d91 14
a104 7
	NID_freshest_crl, 0, ASN1_ITEM_ref(CRL_DIST_POINTS),
	0, 0, 0, 0,
	0, 0,
	0,
	v2i_crld,
	i2r_crldp, 0,
	NULL
@


1.17
log
@Expand ASN.1 template macros - the generated assembly only differs by
changes to line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.16 2015/02/14 15:19:04 miod Exp $ */
d393 7
a399 1
	ASN1_IMP_SET_OF(DIST_POINT_NAME, name.relativename, X509_NAME_ENTRY, 1)
@


1.16
log
@Memory leak in `should not happen' condition; Coverity CID 78889.
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.15 2015/02/10 08:33:10 jsing Exp $ */
d377 16
a392 2
ASN1_CHOICE_cb(DIST_POINT_NAME, dpn_cb) = {
	ASN1_IMP_SEQUENCE_OF(DIST_POINT_NAME, name.fullname, GENERAL_NAME, 0),
d394 11
a404 1
} ASN1_CHOICE_END_cb(DIST_POINT_NAME, DIST_POINT_NAME, type)
d433 33
a465 5
ASN1_SEQUENCE(DIST_POINT) = {
	ASN1_EXP_OPT(DIST_POINT, distpoint, DIST_POINT_NAME, 0),
	ASN1_IMP_OPT(DIST_POINT, reasons, ASN1_BIT_STRING, 1),
	ASN1_IMP_SEQUENCE_OF_OPT(DIST_POINT, CRLissuer, GENERAL_NAME, 2)
} ASN1_SEQUENCE_END(DIST_POINT)
d493 17
a509 4
ASN1_ITEM_TEMPLATE(CRL_DIST_POINTS) =
    ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, CRLDistributionPoints,
	DIST_POINT)
ASN1_ITEM_TEMPLATE_END(CRL_DIST_POINTS)
d537 54
a590 8
ASN1_SEQUENCE(ISSUING_DIST_POINT) = {
	ASN1_EXP_OPT(ISSUING_DIST_POINT, distpoint, DIST_POINT_NAME, 0),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, onlyuser, ASN1_FBOOLEAN, 1),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, onlyCA, ASN1_FBOOLEAN, 2),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, onlysomereasons, ASN1_BIT_STRING, 3),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, indirectCRL, ASN1_FBOOLEAN, 4),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, onlyattr, ASN1_FBOOLEAN, 5)
} ASN1_SEQUENCE_END(ISSUING_DIST_POINT)
@


1.15
log
@The IMPLEMENT_STACK_OF and IMPLEMENT_ASN1_SET_OF macros were turned into
noops around 15 years ago. Remove multiple occurances of both that still
exist in the code today.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.14 2015/02/09 16:03:11 jsing Exp $ */
d207 2
d210 1
a210 3
	if (!rsk)
		return 0;
	if (*preas)
@


1.14
log
@Expand the IMPLEMENT_ASN1_FUNCTIONS macro so that the code is visible and
functions can be readily located.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.13 2014/10/05 18:27:58 miod Exp $ */
a356 3

IMPLEMENT_STACK_OF(DIST_POINT)
IMPLEMENT_ASN1_SET_OF(DIST_POINT)
@


1.13
log
@Memory leak upon error in set_dist_point_name().
ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.12 2014/07/11 08:44:49 jsing Exp $ */
d386 25
a410 1
IMPLEMENT_ASN1_FUNCTIONS(DIST_POINT_NAME)
d418 25
a442 1
IMPLEMENT_ASN1_FUNCTIONS(DIST_POINT)
d449 25
a473 1
IMPLEMENT_ASN1_FUNCTIONS(CRL_DIST_POINTS)
d484 25
a508 1
IMPLEMENT_ASN1_FUNCTIONS(ISSUING_DIST_POINT)
@


1.12
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.11 2014/07/10 13:58:23 jsing Exp $ */
d137 1
@


1.11
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_crld.c,v 1.10 2014/06/12 15:49:31 deraadt Exp $ */
a61 2
#include "cryptlib.h"
#include <openssl/conf.h>
d64 2
@


1.10
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 2
@


1.9
log
@KNF.
@
text
@d1 1
a1 1
/* v3_crld.c */
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d67 1
a67 1
		      X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
d69 1
a69 1
		     int indent);
d71 1
a71 2
const X509V3_EXT_METHOD v3_crld =
	{
d73 2
a74 2
	0,0,0,0,
	0,0,
d77 1
a77 1
	i2r_crldp,0,
d79 1
a79 1
	};
d81 1
a81 2
const X509V3_EXT_METHOD v3_freshest_crl =
	{
d83 2
a84 2
	0,0,0,0,
	0,0,
d87 1
a87 1
	i2r_crldp,0,
d89 1
a89 1
	};
d91 3
a93 2
static STACK_OF(GENERAL_NAME) *gnames_from_sectname(X509V3_CTX *ctx, char *sect)
	{
d96 1
d101 1
a101 2
	if (!gnsect)
		{
d103 1
a103 1
						X509V3_R_SECTION_NOT_FOUND);
d105 1
a105 1
		}
d112 1
a112 1
	}
d114 3
a116 3
static int set_dist_point_name(DIST_POINT_NAME **pdp, X509V3_CTX *ctx,
							CONF_VALUE *cnf)
	{
d119 2
a120 2
	if (!strncmp(cnf->name, "fullname", 9))
		{
d124 1
a124 3
		}
	else if (!strcmp(cnf->name, "relativename"))
		{
d132 1
a132 2
		if (!dnsect)
			{
d134 1
a134 1
						X509V3_R_SECTION_NOT_FOUND);
d136 1
a136 1
			}
d148 1
a148 2
				sk_X509_NAME_ENTRY_num(rnm) - 1)->set)
			{
d150 1
a150 1
						X509V3_R_INVALID_MULTIPLE_RDNS);
a151 1
			}
d153 1
a153 1
	else
d156 1
a156 2
	if (*pdp)
		{
d158 1
a158 1
						X509V3_R_DISTPOINT_ALREADY_SET);
d160 1
a160 1
		}
d165 1
a165 2
	if (fnm)
		{
d168 1
a168 3
		}
	else
		{
d171 1
a171 1
		}
d174 2
a175 2
		
	err:
d181 1
a181 1
	}
d184 10
a193 10
{0, "Unused", "unused"},
{1, "Key Compromise", "keyCompromise"},
{2, "CA Compromise", "CACompromise"},
{3, "Affiliation Changed", "affiliationChanged"},
{4, "Superseded", "superseded"},
{5, "Cessation Of Operation", "cessationOfOperation"},
{6, "Certificate Hold", "certificateHold"},
{7, "Privilege Withdrawn", "privilegeWithdrawn"},
{8, "AA Compromise", "AACompromise"},
{-1, NULL, NULL}
d196 3
a198 2
static int set_reasons(ASN1_BIT_STRING **preas, char *value)
	{
d203 1
d209 1
a209 2
	for (i = 0; i < sk_CONF_VALUE_num(rsk); i++)
		{
d211 1
a211 2
		if (!*preas)
			{
d215 3
a217 5
			}
		for (pbn = reason_flags; pbn->lname; pbn++)
			{
			if (!strcmp(pbn->sname, bnam))
				{
d219 1
a219 1
							pbn->bitnum, 1))
a221 1
				}
d223 1
d226 1
a226 1
		}
d229 1
a229 1
	err:
d232 1
a232 1
	}
d234 3
a236 3
static int print_reasons(BIO *out, const char *rname,
			ASN1_BIT_STRING *rflags, int indent)
	{
d239 1
d241 2
a242 4
	for (pbn = reason_flags; pbn->lname; pbn++)
		{
		if (ASN1_BIT_STRING_get_bit(rflags, pbn->bitnum))
			{
a247 1
			}
d249 1
d255 1
a255 1
	}
d257 3
a259 3
static DIST_POINT *crldp_from_section(X509V3_CTX *ctx,
						STACK_OF(CONF_VALUE) *nval)
	{
d263 1
d267 1
a267 2
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++)
		{
d275 1
a275 2
		if (!strcmp(cnf->name, "reasons"))
			{
d278 2
a279 3
			}
		else if (!strcmp(cnf->name, "CRLissuer"))
			{
d281 1
a281 1
				gnames_from_sectname(ctx, cnf->value);
a283 1
			}
d285 1
a287 1
			
d289 1
a289 1
	err:
d293 1
a293 1
	}
d295 4
a298 3
static void *v2i_crld(const X509V3_EXT_METHOD *method,
		      X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)
	{
d304 4
a307 2
	if(!(crld = sk_DIST_POINT_new_null())) goto merr;
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++) {
d310 1
a310 2
		if (!cnf->value)
			{
d319 1
a319 2
			if(!sk_DIST_POINT_push(crld, point))
				{
a321 1
				}
d323 4
a326 5
		else
			{
			if(!(gen = v2i_GENERAL_NAME(method, ctx, cnf)))
				goto err; 
			if(!(gens = GENERAL_NAMES_new()))
d328 1
a328 1
			if(!sk_GENERAL_NAME_push(gens, gen))
d331 1
a331 1
			if(!(point = DIST_POINT_new()))
d333 1
a333 2
			if(!sk_DIST_POINT_push(crld, point))
				{
d336 2
a337 2
				}
			if(!(point->distpoint = DIST_POINT_NAME_new()))
d342 1
a342 1
			}
d346 3
a348 3
	merr:
	X509V3err(X509V3_F_V2I_CRLD,ERR_R_MALLOC_FAILURE);
	err:
d358 3
a360 3
static int dpn_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
	{
d363 2
a364 3
	switch(operation)
		{
		case ASN1_OP_NEW_POST:
d368 1
a368 1
		case ASN1_OP_FREE_POST:
d372 1
a372 1
		}
d374 1
a374 1
	}
d393 3
a395 2
ASN1_ITEM_TEMPLATE(CRL_DIST_POINTS) = 
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, CRLDistributionPoints, DIST_POINT)
d412 1
a412 1
		   int indent);
d414 1
a414 1
		     STACK_OF(CONF_VALUE) *nval);
d416 1
a416 2
const X509V3_EXT_METHOD v3_idp =
	{
d419 2
a420 2
	0,0,0,0,
	0,0,
d423 1
a423 1
	i2r_idp,0,
d425 1
a425 1
	};
d427 4
a430 3
static void *v2i_idp(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
		     STACK_OF(CONF_VALUE) *nval)
	{
d435 1
d439 1
a439 2
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++)
		{
d448 1
a448 2
		if (!strcmp(name, "onlyuser"))
			{
d451 2
a452 3
			}
		else if (!strcmp(name, "onlyCA"))
			{
d455 2
a456 3
			}
		else if (!strcmp(name, "onlyAA"))
			{
d459 2
a460 3
			}
		else if (!strcmp(name, "indirectCRL"))
			{
d463 2
a464 3
			}
		else if (!strcmp(name, "onlysomereasons"))
			{
d467 4
a470 7
			}
		else
			{
                        X509V3err(X509V3_F_V2I_IDP, X509V3_R_INVALID_NAME);
                        X509V3_conf_err(cnf);
                        goto err;
			}
d472 1
d475 3
a477 3
	merr:
	X509V3err(X509V3_F_V2I_IDP,ERR_R_MALLOC_FAILURE);
	err:
d480 1
a480 1
	}
d482 3
a484 2
static int print_gens(BIO *out, STACK_OF(GENERAL_NAME) *gens, int indent)
	{
d486 2
a487 2
	for (i = 0; i < sk_GENERAL_NAME_num(gens); i++)
		{
d491 1
a491 1
		}
d493 1
a493 1
	}
d495 4
a498 4
static int print_distpoint(BIO *out, DIST_POINT_NAME *dpn, int indent)
	{
	if (dpn->type == 0)
		{
d501 1
a501 3
		}
	else
		{
d505 1
a505 1
						indent, "", indent + 2, "");
d508 1
a508 1
		}
d510 1
a510 1
	}
d512 3
a514 3
static int i2r_idp(const X509V3_EXT_METHOD *method, void *pidp, BIO *out,
		   int indent)
	{
d516 1
d526 2
a527 2
		print_reasons(out, "Only Some Reasons", 
				idp->onlysomereasons, indent);
d530 3
a532 3
	if (!idp->distpoint && (idp->onlyuser <= 0) && (idp->onlyCA <= 0)
		&& (idp->indirectCRL <= 0) && !idp->onlysomereasons
		&& (idp->onlyattr <= 0))
d534 1
a534 1
		
d536 1
a536 1
	}
d538 3
a540 3
static int i2r_crldp(const X509V3_EXT_METHOD *method, void *pcrldp, BIO *out,
		     int indent)
	{
d544 2
a545 2
	for(i = 0; i < sk_DIST_POINT_num(crld); i++)
		{
d548 1
a548 1
		if(point->distpoint)
d550 1
a550 1
		if(point->reasons) 
d552 2
a553 3
								indent);
		if(point->CRLissuer)
			{
a555 1
			}
d557 1
d559 1
a559 1
	}
d561 3
a563 2
int DIST_POINT_set_dpname(DIST_POINT_NAME *dpn, X509_NAME *iname)
	{
d567 1
d574 1
a574 2
	for (i = 0; i < sk_X509_NAME_ENTRY_num(frag); i++)
		{
d576 1
a576 2
		if (!X509_NAME_add_entry(dpn->dpname, ne, -1, i ? 0 : 1))
			{
a579 1
			}
d581 1
d583 1
a583 2
	if (i2d_X509_NAME(dpn->dpname, NULL) < 0)
		{
d587 1
a587 1
		}
d589 1
a589 1
	}
@


1.7
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d66 138
a203 13
static STACK_OF(CONF_VALUE) *i2v_crld(X509V3_EXT_METHOD *method,
		STACK_OF(DIST_POINT) *crld, STACK_OF(CONF_VALUE) *extlist);
static STACK_OF(DIST_POINT) *v2i_crld(X509V3_EXT_METHOD *method,
				X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);

const X509V3_EXT_METHOD v3_crld = {
NID_crl_distribution_points, X509V3_EXT_MULTILINE, ASN1_ITEM_ref(CRL_DIST_POINTS),
0,0,0,0,
0,0,
(X509V3_EXT_I2V)i2v_crld,
(X509V3_EXT_V2I)v2i_crld,
0,0,
NULL
d206 67
a272 4
static STACK_OF(CONF_VALUE) *i2v_crld(X509V3_EXT_METHOD *method,
			STACK_OF(DIST_POINT) *crld, STACK_OF(CONF_VALUE) *exts)
{
	DIST_POINT *point;
d274 26
a299 7
	for(i = 0; i < sk_DIST_POINT_num(crld); i++) {
		point = sk_DIST_POINT_value(crld, i);
		if(point->distpoint) {
			if(point->distpoint->type == 0)
				exts = i2v_GENERAL_NAMES(NULL,
					 point->distpoint->name.fullname, exts);
		        else X509V3_add_value("RelativeName","<UNSUPPORTED>", &exts);
d301 8
a308 4
		if(point->reasons) 
			X509V3_add_value("reasons","<UNSUPPORTED>", &exts);
		if(point->CRLissuer)
			X509V3_add_value("CRLissuer","<UNSUPPORTED>", &exts);
a309 2
	return exts;
}
d311 3
a313 3
static STACK_OF(DIST_POINT) *v2i_crld(X509V3_EXT_METHOD *method,
				X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)
{
d323 38
a360 13
		if(!(gen = v2i_GENERAL_NAME(method, ctx, cnf))) goto err; 
		if(!(gens = GENERAL_NAMES_new())) goto merr;
		if(!sk_GENERAL_NAME_push(gens, gen)) goto merr;
		gen = NULL;
		if(!(point = DIST_POINT_new())) goto merr;
		if(!sk_DIST_POINT_push(crld, point)) {
			DIST_POINT_free(point);
			goto merr;
		}
		if(!(point->distpoint = DIST_POINT_NAME_new())) goto merr;
		point->distpoint->name.fullname = gens;
		point->distpoint->type = 0;
		gens = NULL;
d376 18
d395 2
a396 1
ASN1_CHOICE(DIST_POINT_NAME) = {
d399 2
a400 1
} ASN1_CHOICE_END(DIST_POINT_NAME)
d417 200
@


1.6
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.5
log
@merge 0.9.7d
@
text
@d71 1
a71 1
X509V3_EXT_METHOD v3_crld = {
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d159 1
a159 1
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, DIST_POINT, DIST_POINT)
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d63 1
a63 1
#include <openssl/asn1_mac.h>
d72 3
a74 6
NID_crl_distribution_points, X509V3_EXT_MULTILINE,
(X509V3_EXT_NEW)CRL_DIST_POINTS_new,
(X509V3_EXT_FREE)CRL_DIST_POINTS_free,
(X509V3_EXT_D2I)d2i_CRL_DIST_POINTS,
(X509V3_EXT_I2D)i2d_CRL_DIST_POINTS,
NULL, NULL,
d77 2
a78 1
NULL, NULL, NULL
d88 5
a92 3
		if(point->distpoint && point->distpoint->fullname) {
			exts = i2v_GENERAL_NAMES(NULL,
					 point->distpoint->fullname, exts);
a97 2
		if(point->distpoint && point->distpoint->relativename)
		        X509V3_add_value("RelativeName","<UNSUPPORTED>", &exts);
d106 1
a106 1
	STACK_OF(GENERAL_NAME) *gens = NULL;
d124 2
a125 1
		point->distpoint->fullname = gens;
a138 24
int i2d_CRL_DIST_POINTS(STACK_OF(DIST_POINT) *a, unsigned char **pp)
{

return i2d_ASN1_SET_OF_DIST_POINT(a, pp, i2d_DIST_POINT, V_ASN1_SEQUENCE,
                                                 V_ASN1_UNIVERSAL, IS_SEQUENCE);}

STACK_OF(DIST_POINT) *CRL_DIST_POINTS_new(void)
{
	return sk_DIST_POINT_new_null();
}

void CRL_DIST_POINTS_free(STACK_OF(DIST_POINT) *a)
{
	sk_DIST_POINT_pop_free(a, DIST_POINT_free);
}

STACK_OF(DIST_POINT) *d2i_CRL_DIST_POINTS(STACK_OF(DIST_POINT) **a,
		unsigned char **pp,long length)
{
return d2i_ASN1_SET_OF_DIST_POINT(a, pp, length, d2i_DIST_POINT,
                         DIST_POINT_free, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);

}

a141 29
int i2d_DIST_POINT(DIST_POINT *a, unsigned char **pp)
{
	int v = 0;
	M_ASN1_I2D_vars(a);
	/* NB: underlying type is a CHOICE so need EXPLICIT tagging */
	M_ASN1_I2D_len_EXP_opt (a->distpoint, i2d_DIST_POINT_NAME, 0, v);
	M_ASN1_I2D_len_IMP_opt (a->reasons, i2d_ASN1_BIT_STRING);
	M_ASN1_I2D_len_IMP_opt (a->CRLissuer, i2d_GENERAL_NAMES);

	M_ASN1_I2D_seq_total();

	M_ASN1_I2D_put_EXP_opt (a->distpoint, i2d_DIST_POINT_NAME, 0, v);
	M_ASN1_I2D_put_IMP_opt (a->reasons, i2d_ASN1_BIT_STRING, 1);
	M_ASN1_I2D_put_IMP_opt (a->CRLissuer, i2d_GENERAL_NAMES, 2);

	M_ASN1_I2D_finish();
}

DIST_POINT *DIST_POINT_new(void)
{
	DIST_POINT *ret=NULL;
	ASN1_CTX c;
	M_ASN1_New_Malloc(ret, DIST_POINT);
	ret->distpoint = NULL;
	ret->reasons = NULL;
	ret->CRLissuer = NULL;
	return (ret);
	M_ASN1_New_Error(ASN1_F_DIST_POINT_NEW);
}
d143 18
a160 12
DIST_POINT *d2i_DIST_POINT(DIST_POINT **a, unsigned char **pp, long length)
{
	M_ASN1_D2I_vars(a,DIST_POINT *,DIST_POINT_new);
	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	M_ASN1_D2I_get_EXP_opt (ret->distpoint, d2i_DIST_POINT_NAME, 0);
	M_ASN1_D2I_get_IMP_opt (ret->reasons, d2i_ASN1_BIT_STRING, 1,
							V_ASN1_BIT_STRING);
	M_ASN1_D2I_get_IMP_opt (ret->CRLissuer, d2i_GENERAL_NAMES, 2,
							V_ASN1_SEQUENCE);
	M_ASN1_D2I_Finish(a, DIST_POINT_free, ASN1_F_D2I_DIST_POINT);
}
d162 1
a162 76
void DIST_POINT_free(DIST_POINT *a)
{
	if (a == NULL) return;
	DIST_POINT_NAME_free(a->distpoint);
	M_ASN1_BIT_STRING_free(a->reasons);
	sk_GENERAL_NAME_pop_free(a->CRLissuer, GENERAL_NAME_free);
	OPENSSL_free (a);
}

int i2d_DIST_POINT_NAME(DIST_POINT_NAME *a, unsigned char **pp)
{
	M_ASN1_I2D_vars(a);

	if(a->fullname) {
		M_ASN1_I2D_len_IMP_opt (a->fullname, i2d_GENERAL_NAMES);
	} else {
		M_ASN1_I2D_len_IMP_SET_opt_type(X509_NAME_ENTRY,
				a->relativename, i2d_X509_NAME_ENTRY, 1);
	}

	/* Don't want a SEQUENCE so... */
	if(pp == NULL) return ret;
	p = *pp;

	if(a->fullname) {
		M_ASN1_I2D_put_IMP_opt (a->fullname, i2d_GENERAL_NAMES, 0);
	} else {
		M_ASN1_I2D_put_IMP_SET_opt_type(X509_NAME_ENTRY,
				a->relativename, i2d_X509_NAME_ENTRY, 1);
	}
	M_ASN1_I2D_finish();
}

DIST_POINT_NAME *DIST_POINT_NAME_new(void)
{
	DIST_POINT_NAME *ret=NULL;
	ASN1_CTX c;
	M_ASN1_New_Malloc(ret, DIST_POINT_NAME);
	ret->fullname = NULL;
	ret->relativename = NULL;
	return (ret);
	M_ASN1_New_Error(ASN1_F_DIST_POINT_NAME_NEW);
}

void DIST_POINT_NAME_free(DIST_POINT_NAME *a)
{
	if (a == NULL) return;
	sk_X509_NAME_ENTRY_pop_free(a->relativename, X509_NAME_ENTRY_free);
	sk_GENERAL_NAME_pop_free(a->fullname, GENERAL_NAME_free);
	OPENSSL_free (a);
}

DIST_POINT_NAME *d2i_DIST_POINT_NAME(DIST_POINT_NAME **a, unsigned char **pp,
	     long length)
{
        unsigned char _tmp, tag;
        M_ASN1_D2I_vars(a,DIST_POINT_NAME *,DIST_POINT_NAME_new);
        M_ASN1_D2I_Init();
        c.slen = length;

        _tmp = M_ASN1_next;
        tag = _tmp & ~V_ASN1_CONSTRUCTED;
	
	if(tag == (0|V_ASN1_CONTEXT_SPECIFIC)) {
		M_ASN1_D2I_get_imp(ret->fullname, d2i_GENERAL_NAMES,
							V_ASN1_SEQUENCE);
	} else if (tag == (1|V_ASN1_CONTEXT_SPECIFIC)) {
		M_ASN1_D2I_get_IMP_set_opt_type (X509_NAME_ENTRY,
			ret->relativename, d2i_X509_NAME_ENTRY, X509_NAME_ENTRY_free, 1);
	} else {
		c.error = ASN1_R_BAD_TAG;
		goto err;
	}

	M_ASN1_D2I_Finish(a, DIST_POINT_NAME_free, ASN1_F_D2I_DIST_POINT_NAME);
}
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d90 1
a90 1
		if(point->distpoint->fullname) {
d98 1
a98 1
		if(point->distpoint->relativename)
d112 1
a112 1
	if(!(crld = sk_DIST_POINT_new(NULL))) goto merr;
d216 1
a216 1
	Free (a);
d259 1
a259 1
	Free (a);
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d214 1
a214 1
	ASN1_BIT_STRING_free(a->reasons);
d216 1
a216 1
	Free ((char *)a);
a220 1
	int v = 0;
d226 2
a227 1
		M_ASN1_I2D_len_EXP_opt (a->relativename, i2d_X509_NAME, 1, v);
d237 2
a238 1
		M_ASN1_I2D_put_EXP_opt (a->relativename, i2d_X509_NAME, 1, v);
d257 1
a257 1
	X509_NAME_free(a->relativename);
d259 1
a259 1
	Free ((char *)a);
d277 2
a278 1
		M_ASN1_D2I_get_EXP_opt (ret->relativename, d2i_X509_NAME, 1);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d63 1
a63 1
#include <openssl/asn1t.h>
d72 6
a77 3
NID_crl_distribution_points, X509V3_EXT_MULTILINE, ASN1_ITEM_ref(CRL_DIST_POINTS),
0,0,0,0,
0,0,
d80 1
a80 2
0,0,
NULL
d90 3
a92 5
		if(point->distpoint) {
			if(point->distpoint->type == 0)
				exts = i2v_GENERAL_NAMES(NULL,
					 point->distpoint->name.fullname, exts);
		        else X509V3_add_value("RelativeName","<UNSUPPORTED>", &exts);
d98 2
d108 1
a108 1
	GENERAL_NAMES *gens = NULL;
d112 1
a112 1
	if(!(crld = sk_DIST_POINT_new_null())) goto merr;
d126 1
a126 2
		point->distpoint->name.fullname = gens;
		point->distpoint->type = 0;
d140 24
d167 29
d197 12
a208 18
ASN1_CHOICE(DIST_POINT_NAME) = {
	ASN1_IMP_SEQUENCE_OF(DIST_POINT_NAME, name.fullname, GENERAL_NAME, 0),
	ASN1_IMP_SET_OF(DIST_POINT_NAME, name.relativename, X509_NAME_ENTRY, 1)
} ASN1_CHOICE_END(DIST_POINT_NAME)

IMPLEMENT_ASN1_FUNCTIONS(DIST_POINT_NAME)

ASN1_SEQUENCE(DIST_POINT) = {
	ASN1_EXP_OPT(DIST_POINT, distpoint, DIST_POINT_NAME, 0),
	ASN1_IMP_OPT(DIST_POINT, reasons, ASN1_BIT_STRING, 1),
	ASN1_IMP_SEQUENCE_OF_OPT(DIST_POINT, CRLissuer, GENERAL_NAME, 2)
} ASN1_SEQUENCE_END(DIST_POINT)

IMPLEMENT_ASN1_FUNCTIONS(DIST_POINT)

ASN1_ITEM_TEMPLATE(CRL_DIST_POINTS) = 
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, DIST_POINT, DIST_POINT)
ASN1_ITEM_TEMPLATE_END(CRL_DIST_POINTS)
d210 74
a283 1
IMPLEMENT_ASN1_FUNCTIONS(CRL_DIST_POINTS)
@


1.1.1.2
log
@import openssl-0.9.7d
@
text
@d159 1
a159 1
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, CRLDistributionPoints, DIST_POINT)
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d71 1
a71 1
const X509V3_EXT_METHOD v3_crld = {
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2008 The OpenSSL Project.  All rights reserved.
d66 13
a78 138
static void *v2i_crld(const X509V3_EXT_METHOD *method,
		      X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval);
static int i2r_crldp(const X509V3_EXT_METHOD *method, void *pcrldp, BIO *out,
		     int indent);

const X509V3_EXT_METHOD v3_crld =
	{
	NID_crl_distribution_points, 0, ASN1_ITEM_ref(CRL_DIST_POINTS),
	0,0,0,0,
	0,0,
	0,
	v2i_crld,
	i2r_crldp,0,
	NULL
	};

const X509V3_EXT_METHOD v3_freshest_crl =
	{
	NID_freshest_crl, 0, ASN1_ITEM_ref(CRL_DIST_POINTS),
	0,0,0,0,
	0,0,
	0,
	v2i_crld,
	i2r_crldp,0,
	NULL
	};

static STACK_OF(GENERAL_NAME) *gnames_from_sectname(X509V3_CTX *ctx, char *sect)
	{
	STACK_OF(CONF_VALUE) *gnsect;
	STACK_OF(GENERAL_NAME) *gens;
	if (*sect == '@@')
		gnsect = X509V3_get_section(ctx, sect + 1);
	else
		gnsect = X509V3_parse_list(sect);
	if (!gnsect)
		{
		X509V3err(X509V3_F_GNAMES_FROM_SECTNAME,
						X509V3_R_SECTION_NOT_FOUND);
		return NULL;
		}
	gens = v2i_GENERAL_NAMES(NULL, ctx, gnsect);
	if (*sect == '@@')
		X509V3_section_free(ctx, gnsect);
	else
		sk_CONF_VALUE_pop_free(gnsect, X509V3_conf_free);
	return gens;
	}

static int set_dist_point_name(DIST_POINT_NAME **pdp, X509V3_CTX *ctx,
							CONF_VALUE *cnf)
	{
	STACK_OF(GENERAL_NAME) *fnm = NULL;
	STACK_OF(X509_NAME_ENTRY) *rnm = NULL;
	if (!strncmp(cnf->name, "fullname", 9))
		{
		fnm = gnames_from_sectname(ctx, cnf->value);
		if (!fnm)
			goto err;
		}
	else if (!strcmp(cnf->name, "relativename"))
		{
		int ret;
		STACK_OF(CONF_VALUE) *dnsect;
		X509_NAME *nm;
		nm = X509_NAME_new();
		if (!nm)
			return -1;
		dnsect = X509V3_get_section(ctx, cnf->value);
		if (!dnsect)
			{
			X509V3err(X509V3_F_SET_DIST_POINT_NAME,
						X509V3_R_SECTION_NOT_FOUND);
			return -1;
			}
		ret = X509V3_NAME_from_section(nm, dnsect, MBSTRING_ASC);
		X509V3_section_free(ctx, dnsect);
		rnm = nm->entries;
		nm->entries = NULL;
		X509_NAME_free(nm);
		if (!ret || sk_X509_NAME_ENTRY_num(rnm) <= 0)
			goto err;
		/* Since its a name fragment can't have more than one
		 * RDNSequence
		 */
		if (sk_X509_NAME_ENTRY_value(rnm,
				sk_X509_NAME_ENTRY_num(rnm) - 1)->set)
			{
			X509V3err(X509V3_F_SET_DIST_POINT_NAME,
						X509V3_R_INVALID_MULTIPLE_RDNS);
			goto err;
			}
		}
	else
		return 0;

	if (*pdp)
		{
		X509V3err(X509V3_F_SET_DIST_POINT_NAME,
						X509V3_R_DISTPOINT_ALREADY_SET);
		goto err;
		}

	*pdp = DIST_POINT_NAME_new();
	if (!*pdp)
		goto err;
	if (fnm)
		{
		(*pdp)->type = 0;
		(*pdp)->name.fullname = fnm;
		}
	else
		{
		(*pdp)->type = 1;
		(*pdp)->name.relativename = rnm;
		}

	return 1;
		
	err:
	if (fnm)
		sk_GENERAL_NAME_pop_free(fnm, GENERAL_NAME_free);
	if (rnm)
		sk_X509_NAME_ENTRY_pop_free(rnm, X509_NAME_ENTRY_free);
	return -1;
	}

static const BIT_STRING_BITNAME reason_flags[] = {
{0, "Unused", "unused"},
{1, "Key Compromise", "keyCompromise"},
{2, "CA Compromise", "CACompromise"},
{3, "Affiliation Changed", "affiliationChanged"},
{4, "Superseded", "superseded"},
{5, "Cessation Of Operation", "cessationOfOperation"},
{6, "Certificate Hold", "certificateHold"},
{7, "Privilege Withdrawn", "privilegeWithdrawn"},
{8, "AA Compromise", "AACompromise"},
{-1, NULL, NULL}
d81 4
a84 67
static int set_reasons(ASN1_BIT_STRING **preas, char *value)
	{
	STACK_OF(CONF_VALUE) *rsk = NULL;
	const BIT_STRING_BITNAME *pbn;
	const char *bnam;
	int i, ret = 0;
	rsk = X509V3_parse_list(value);
	if (!rsk)
		return 0;
	if (*preas)
		return 0;
	for (i = 0; i < sk_CONF_VALUE_num(rsk); i++)
		{
		bnam = sk_CONF_VALUE_value(rsk, i)->name;
		if (!*preas)
			{
			*preas = ASN1_BIT_STRING_new();
			if (!*preas)
				goto err;
			}
		for (pbn = reason_flags; pbn->lname; pbn++)
			{
			if (!strcmp(pbn->sname, bnam))
				{
				if (!ASN1_BIT_STRING_set_bit(*preas,
							pbn->bitnum, 1))
					goto err;
				break;
				}
			}
		if (!pbn->lname)
			goto err;
		}
	ret = 1;

	err:
	sk_CONF_VALUE_pop_free(rsk, X509V3_conf_free);
	return ret;
	}

static int print_reasons(BIO *out, const char *rname,
			ASN1_BIT_STRING *rflags, int indent)
	{
	int first = 1;
	const BIT_STRING_BITNAME *pbn;
	BIO_printf(out, "%*s%s:\n%*s", indent, "", rname, indent + 2, "");
	for (pbn = reason_flags; pbn->lname; pbn++)
		{
		if (ASN1_BIT_STRING_get_bit(rflags, pbn->bitnum))
			{
			if (first)
				first = 0;
			else
				BIO_puts(out, ", ");
			BIO_puts(out, pbn->lname);
			}
		}
	if (first)
		BIO_puts(out, "<EMPTY>\n");
	else
		BIO_puts(out, "\n");
	return 1;
	}

static DIST_POINT *crldp_from_section(X509V3_CTX *ctx,
						STACK_OF(CONF_VALUE) *nval)
	{
d86 7
a92 26
	CONF_VALUE *cnf;
	DIST_POINT *point = NULL;
	point = DIST_POINT_new();
	if (!point)
		goto err;
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++)
		{
		int ret;
		cnf = sk_CONF_VALUE_value(nval, i);
		ret = set_dist_point_name(&point->distpoint, ctx, cnf);
		if (ret > 0)
			continue;
		if (ret < 0)
			goto err;
		if (!strcmp(cnf->name, "reasons"))
			{
			if (!set_reasons(&point->reasons, cnf->value))
				goto err;
			}
		else if (!strcmp(cnf->name, "CRLissuer"))
			{
			point->CRLissuer =
				gnames_from_sectname(ctx, cnf->value);
			if (!point->CRLissuer)
				goto err;
			}
d94 4
a97 8

	return point;
			

	err:
	if (point)
		DIST_POINT_free(point);
	return NULL;
d99 2
d102 3
a104 3
static void *v2i_crld(const X509V3_EXT_METHOD *method,
		      X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *nval)
	{
d114 13
a126 38
		if (!cnf->value)
			{
			STACK_OF(CONF_VALUE) *dpsect;
			dpsect = X509V3_get_section(ctx, cnf->name);
			if (!dpsect)
				goto err;
			point = crldp_from_section(ctx, dpsect);
			X509V3_section_free(ctx, dpsect);
			if (!point)
				goto err;
			if(!sk_DIST_POINT_push(crld, point))
				{
				DIST_POINT_free(point);
				goto merr;
				}
			}
		else
			{
			if(!(gen = v2i_GENERAL_NAME(method, ctx, cnf)))
				goto err; 
			if(!(gens = GENERAL_NAMES_new()))
				goto merr;
			if(!sk_GENERAL_NAME_push(gens, gen))
				goto merr;
			gen = NULL;
			if(!(point = DIST_POINT_new()))
				goto merr;
			if(!sk_DIST_POINT_push(crld, point))
				{
				DIST_POINT_free(point);
				goto merr;
				}
			if(!(point->distpoint = DIST_POINT_NAME_new()))
				goto merr;
			point->distpoint->name.fullname = gens;
			point->distpoint->type = 0;
			gens = NULL;
			}
a141 18
static int dpn_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
	{
	DIST_POINT_NAME *dpn = (DIST_POINT_NAME *)*pval;

	switch(operation)
		{
		case ASN1_OP_NEW_POST:
		dpn->dpname = NULL;
		break;

		case ASN1_OP_FREE_POST:
		if (dpn->dpname)
			X509_NAME_free(dpn->dpname);
		break;
		}
	return 1;
	}
d143 1
a143 2

ASN1_CHOICE_cb(DIST_POINT_NAME, dpn_cb) = {
d146 1
a146 2
} ASN1_CHOICE_END_cb(DIST_POINT_NAME, DIST_POINT_NAME, type)

a162 200

ASN1_SEQUENCE(ISSUING_DIST_POINT) = {
	ASN1_EXP_OPT(ISSUING_DIST_POINT, distpoint, DIST_POINT_NAME, 0),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, onlyuser, ASN1_FBOOLEAN, 1),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, onlyCA, ASN1_FBOOLEAN, 2),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, onlysomereasons, ASN1_BIT_STRING, 3),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, indirectCRL, ASN1_FBOOLEAN, 4),
	ASN1_IMP_OPT(ISSUING_DIST_POINT, onlyattr, ASN1_FBOOLEAN, 5)
} ASN1_SEQUENCE_END(ISSUING_DIST_POINT)

IMPLEMENT_ASN1_FUNCTIONS(ISSUING_DIST_POINT)

static int i2r_idp(const X509V3_EXT_METHOD *method, void *pidp, BIO *out,
		   int indent);
static void *v2i_idp(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
		     STACK_OF(CONF_VALUE) *nval);

const X509V3_EXT_METHOD v3_idp =
	{
	NID_issuing_distribution_point, X509V3_EXT_MULTILINE,
	ASN1_ITEM_ref(ISSUING_DIST_POINT),
	0,0,0,0,
	0,0,
	0,
	v2i_idp,
	i2r_idp,0,
	NULL
	};

static void *v2i_idp(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
		     STACK_OF(CONF_VALUE) *nval)
	{
	ISSUING_DIST_POINT *idp = NULL;
	CONF_VALUE *cnf;
	char *name, *val;
	int i, ret;
	idp = ISSUING_DIST_POINT_new();
	if (!idp)
		goto merr;
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++)
		{
		cnf = sk_CONF_VALUE_value(nval, i);
		name = cnf->name;
		val = cnf->value;
		ret = set_dist_point_name(&idp->distpoint, ctx, cnf);
		if (ret > 0)
			continue;
		if (ret < 0)
			goto err;
		if (!strcmp(name, "onlyuser"))
			{
			if (!X509V3_get_value_bool(cnf, &idp->onlyuser))
				goto err;
			}
		else if (!strcmp(name, "onlyCA"))
			{
			if (!X509V3_get_value_bool(cnf, &idp->onlyCA))
				goto err;
			}
		else if (!strcmp(name, "onlyAA"))
			{
			if (!X509V3_get_value_bool(cnf, &idp->onlyattr))
				goto err;
			}
		else if (!strcmp(name, "indirectCRL"))
			{
			if (!X509V3_get_value_bool(cnf, &idp->indirectCRL))
				goto err;
			}
		else if (!strcmp(name, "onlysomereasons"))
			{
			if (!set_reasons(&idp->onlysomereasons, val))
				goto err;
			}
		else
			{
                        X509V3err(X509V3_F_V2I_IDP, X509V3_R_INVALID_NAME);
                        X509V3_conf_err(cnf);
                        goto err;
			}
		}
	return idp;

	merr:
	X509V3err(X509V3_F_V2I_IDP,ERR_R_MALLOC_FAILURE);
	err:
	ISSUING_DIST_POINT_free(idp);
	return NULL;
	}

static int print_gens(BIO *out, STACK_OF(GENERAL_NAME) *gens, int indent)
	{
	int i;
	for (i = 0; i < sk_GENERAL_NAME_num(gens); i++)
		{
		BIO_printf(out, "%*s", indent + 2, "");
		GENERAL_NAME_print(out, sk_GENERAL_NAME_value(gens, i));
		BIO_puts(out, "\n");
		}
	return 1;
	}

static int print_distpoint(BIO *out, DIST_POINT_NAME *dpn, int indent)
	{
	if (dpn->type == 0)
		{
		BIO_printf(out, "%*sFull Name:\n", indent, "");
		print_gens(out, dpn->name.fullname, indent);
		}
	else
		{
		X509_NAME ntmp;
		ntmp.entries = dpn->name.relativename;
		BIO_printf(out, "%*sRelative Name:\n%*s",
						indent, "", indent + 2, "");
		X509_NAME_print_ex(out, &ntmp, 0, XN_FLAG_ONELINE);
		BIO_puts(out, "\n");
		}
	return 1;
	}

static int i2r_idp(const X509V3_EXT_METHOD *method, void *pidp, BIO *out,
		   int indent)
	{
	ISSUING_DIST_POINT *idp = pidp;
	if (idp->distpoint)
		print_distpoint(out, idp->distpoint, indent);
	if (idp->onlyuser > 0)
		BIO_printf(out, "%*sOnly User Certificates\n", indent, "");
	if (idp->onlyCA > 0)
		BIO_printf(out, "%*sOnly CA Certificates\n", indent, "");
	if (idp->indirectCRL > 0)
		BIO_printf(out, "%*sIndirect CRL\n", indent, "");
	if (idp->onlysomereasons)
		print_reasons(out, "Only Some Reasons", 
				idp->onlysomereasons, indent);
	if (idp->onlyattr > 0)
		BIO_printf(out, "%*sOnly Attribute Certificates\n", indent, "");
	if (!idp->distpoint && (idp->onlyuser <= 0) && (idp->onlyCA <= 0)
		&& (idp->indirectCRL <= 0) && !idp->onlysomereasons
		&& (idp->onlyattr <= 0))
		BIO_printf(out, "%*s<EMPTY>\n", indent, "");
		
	return 1;
	}

static int i2r_crldp(const X509V3_EXT_METHOD *method, void *pcrldp, BIO *out,
		     int indent)
	{
	STACK_OF(DIST_POINT) *crld = pcrldp;
	DIST_POINT *point;
	int i;
	for(i = 0; i < sk_DIST_POINT_num(crld); i++)
		{
		BIO_puts(out, "\n");
		point = sk_DIST_POINT_value(crld, i);
		if(point->distpoint)
			print_distpoint(out, point->distpoint, indent);
		if(point->reasons) 
			print_reasons(out, "Reasons", point->reasons,
								indent);
		if(point->CRLissuer)
			{
			BIO_printf(out, "%*sCRL Issuer:\n", indent, "");
			print_gens(out, point->CRLissuer, indent);
			}
		}
	return 1;
	}

int DIST_POINT_set_dpname(DIST_POINT_NAME *dpn, X509_NAME *iname)
	{
	int i;
	STACK_OF(X509_NAME_ENTRY) *frag;
	X509_NAME_ENTRY *ne;
	if (!dpn || (dpn->type != 1))
		return 1;
	frag = dpn->name.relativename;
	dpn->dpname = X509_NAME_dup(iname);
	if (!dpn->dpname)
		return 0;
	for (i = 0; i < sk_X509_NAME_ENTRY_num(frag); i++)
		{
		ne = sk_X509_NAME_ENTRY_value(frag, i);
		if (!X509_NAME_add_entry(dpn->dpname, ne, -1, i ? 0 : 1))
			{
			X509_NAME_free(dpn->dpname);
			dpn->dpname = NULL;
			return 0;
			}
		}
	/* generate cached encoding of name */
	if (i2d_X509_NAME(dpn->dpname, NULL) < 0)
		{
		X509_NAME_free(dpn->dpname);
		dpn->dpname = NULL;
		return 0;
		}
	return 1;
	}
@


