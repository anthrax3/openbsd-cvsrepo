head	1.26;
access;
symbols;
locks; strict;
comment	@ * @;


1.26
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.25;
commitid	kT0fLt3r4lroFJra;

1.25
date	2016.09.03.11.56.33;	author beck;	state Exp;
branches;
next	1.24;
commitid	oPw4bcoV45qZngAy;

1.24
date	2015.02.07.13.19.15;	author doug;	state Exp;
branches;
next	1.23;
commitid	gtwLkRyWx0K1HbzX;

1.23
date	2014.07.13.16.03.10;	author beck;	state Exp;
branches;
next	1.22;
commitid	6xdvCwSqBadTW6X3;

1.22
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.21;
commitid	yQEL1wOWIearrW15;

1.21
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.20;
commitid	id8dTrTMtnTn4fqt;

1.20
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	mJUVYpkFBZ0Zv2bG;

1.19
date	2014.06.01.15.39.52;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	k01TWVGFNtltfh7t;

1.18
date	2014.06.01.04.15.25;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	BexTm37tPQZKSq75;

1.17
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2014.05.26.12.37.32;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.22.21.12.16;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.27.20.20.59;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.21.16.08.08;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.15.17.46.17;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.20.03.40.06;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.02.18.39;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.12.20;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.55;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.04;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.56;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.14.01;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.04.06.06.30.05;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.12;	author djm;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: v3_utl.c,v 1.25 2016/09/03 11:56:33 beck Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 1999-2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* X509 v3 extension utilities */

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include <openssl/bn.h>
#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/x509v3.h>

static char *strip_spaces(char *name);
static int sk_strcmp(const char * const *a, const char * const *b);
static STACK_OF(OPENSSL_STRING) *get_email(X509_NAME *name,
    GENERAL_NAMES *gens);
static void str_free(OPENSSL_STRING str);
static int append_ia5(STACK_OF(OPENSSL_STRING) **sk, ASN1_IA5STRING *email);

static int ipv4_from_asc(unsigned char *v4, const char *in);
static int ipv6_from_asc(unsigned char *v6, const char *in);
static int ipv6_cb(const char *elem, int len, void *usr);
static int ipv6_hex(unsigned char *out, const char *in, int inlen);

/* Add a CONF_VALUE name value pair to stack */

int
X509V3_add_value(const char *name, const char *value,
    STACK_OF(CONF_VALUE) **extlist)
{
	CONF_VALUE *vtmp = NULL;
	char *tname = NULL, *tvalue = NULL;

	if (name && !(tname = strdup(name)))
		goto err;
	if (value && !(tvalue = strdup(value)))
		goto err;
	if (!(vtmp = malloc(sizeof(CONF_VALUE))))
		goto err;
	if (!*extlist && !(*extlist = sk_CONF_VALUE_new_null()))
		goto err;
	vtmp->section = NULL;
	vtmp->name = tname;
	vtmp->value = tvalue;
	if (!sk_CONF_VALUE_push(*extlist, vtmp))
		goto err;
	return 1;

err:
	X509V3error(ERR_R_MALLOC_FAILURE);
	free(vtmp);
	free(tname);
	free(tvalue);
	return 0;
}

int
X509V3_add_value_uchar(const char *name, const unsigned char *value,
    STACK_OF(CONF_VALUE) **extlist)
{
	return X509V3_add_value(name, (const char *)value, extlist);
}

/* Free function for STACK_OF(CONF_VALUE) */

void
X509V3_conf_free(CONF_VALUE *conf)
{
	if (!conf)
		return;
	free(conf->name);
	free(conf->value);
	free(conf->section);
	free(conf);
}

int
X509V3_add_value_bool(const char *name, int asn1_bool,
    STACK_OF(CONF_VALUE) **extlist)
{
	if (asn1_bool)
		return X509V3_add_value(name, "TRUE", extlist);
	return X509V3_add_value(name, "FALSE", extlist);
}

int
X509V3_add_value_bool_nf(char *name, int asn1_bool,
    STACK_OF(CONF_VALUE) **extlist)
{
	if (asn1_bool)
		return X509V3_add_value(name, "TRUE", extlist);
	return 1;
}


char *
i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *method, ASN1_ENUMERATED *a)
{
	BIGNUM *bntmp = NULL;
	char *strtmp = NULL;

	if (!a)
		return NULL;
	if (!(bntmp = ASN1_ENUMERATED_to_BN(a, NULL)) ||
	    !(strtmp = BN_bn2dec(bntmp)))
		X509V3error(ERR_R_MALLOC_FAILURE);
	BN_free(bntmp);
	return strtmp;
}

char *
i2s_ASN1_INTEGER(X509V3_EXT_METHOD *method, ASN1_INTEGER *a)
{
	BIGNUM *bntmp = NULL;
	char *strtmp = NULL;

	if (!a)
		return NULL;
	if (!(bntmp = ASN1_INTEGER_to_BN(a, NULL)) ||
	    !(strtmp = BN_bn2dec(bntmp)))
		X509V3error(ERR_R_MALLOC_FAILURE);
	BN_free(bntmp);
	return strtmp;
}

ASN1_INTEGER *
s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, char *value)
{
	BIGNUM *bn = NULL;
	ASN1_INTEGER *aint;
	int isneg, ishex;
	int ret;

	if (!value) {
		X509V3error(X509V3_R_INVALID_NULL_VALUE);
		return 0;
	}
	bn = BN_new();
	if (value[0] == '-') {
		value++;
		isneg = 1;
	} else
		isneg = 0;

	if (value[0] == '0' && ((value[1] == 'x') || (value[1] == 'X'))) {
		value += 2;
		ishex = 1;
	} else
		ishex = 0;

	if (ishex)
		ret = BN_hex2bn(&bn, value);
	else
		ret = BN_dec2bn(&bn, value);

	if (!ret || value[ret]) {
		BN_free(bn);
		X509V3error(X509V3_R_BN_DEC2BN_ERROR);
		return 0;
	}

	if (isneg && BN_is_zero(bn))
		isneg = 0;

	aint = BN_to_ASN1_INTEGER(bn, NULL);
	BN_free(bn);
	if (!aint) {
		X509V3error(X509V3_R_BN_TO_ASN1_INTEGER_ERROR);
		return 0;
	}
	if (isneg)
		aint->type |= V_ASN1_NEG;
	return aint;
}

int
X509V3_add_value_int(const char *name, ASN1_INTEGER *aint,
    STACK_OF(CONF_VALUE) **extlist)
{
	char *strtmp;
	int ret;

	if (!aint)
		return 1;
	if (!(strtmp = i2s_ASN1_INTEGER(NULL, aint)))
		return 0;
	ret = X509V3_add_value(name, strtmp, extlist);
	free(strtmp);
	return ret;
}

int
X509V3_get_value_bool(CONF_VALUE *value, int *asn1_bool)
{
	char *btmp;

	if (!(btmp = value->value))
		goto err;
	if (!strcmp(btmp, "TRUE") || !strcmp(btmp, "true") ||
	    !strcmp(btmp, "Y") || !strcmp(btmp, "y") ||
	    !strcmp(btmp, "YES") || !strcmp(btmp, "yes")) {
		*asn1_bool = 0xff;
		return 1;
	} else if (!strcmp(btmp, "FALSE") || !strcmp(btmp, "false") ||
	    !strcmp(btmp, "N") || !strcmp(btmp, "n") ||
	    !strcmp(btmp, "NO") || !strcmp(btmp, "no")) {
		*asn1_bool = 0;
		return 1;
	}

err:
	X509V3error(X509V3_R_INVALID_BOOLEAN_STRING);
	X509V3_conf_err(value);
	return 0;
}

int
X509V3_get_value_int(CONF_VALUE *value, ASN1_INTEGER **aint)
{
	ASN1_INTEGER *itmp;

	if (!(itmp = s2i_ASN1_INTEGER(NULL, value->value))) {
		X509V3_conf_err(value);
		return 0;
	}
	*aint = itmp;
	return 1;
}

#define HDR_NAME	1
#define HDR_VALUE	2

/*#define DEBUG*/

STACK_OF(CONF_VALUE) *
X509V3_parse_list(const char *line)
{
	char *p, *q, c;
	char *ntmp, *vtmp;
	STACK_OF(CONF_VALUE) *values = NULL;
	char *linebuf;
	int state;

	/* We are going to modify the line so copy it first */
	if ((linebuf = strdup(line)) == NULL) {
		X509V3error(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	state = HDR_NAME;
	ntmp = NULL;

	/* Go through all characters */
	for (p = linebuf, q = linebuf; (c = *p) && (c != '\r') &&
	    (c != '\n'); p++) {

		switch (state) {
		case HDR_NAME:
			if (c == ':') {
				state = HDR_VALUE;
				*p = 0;
				ntmp = strip_spaces(q);
				if (!ntmp) {
					X509V3error(X509V3_R_INVALID_NULL_NAME);
					goto err;
				}
				q = p + 1;
			} else if (c == ',') {
				*p = 0;
				ntmp = strip_spaces(q);
				q = p + 1;
				if (!ntmp) {
					X509V3error(X509V3_R_INVALID_NULL_NAME);
					goto err;
				}
				X509V3_add_value(ntmp, NULL, &values);
			}
			break;

		case HDR_VALUE:
			if (c == ',') {
				state = HDR_NAME;
				*p = 0;
				vtmp = strip_spaces(q);
				if (!vtmp) {
					X509V3error(X509V3_R_INVALID_NULL_VALUE);
					goto err;
				}
				X509V3_add_value(ntmp, vtmp, &values);
				ntmp = NULL;
				q = p + 1;
			}

		}
	}

	if (state == HDR_VALUE) {
		vtmp = strip_spaces(q);
		if (!vtmp) {
			X509V3error(X509V3_R_INVALID_NULL_VALUE);
			goto err;
		}
		X509V3_add_value(ntmp, vtmp, &values);
	} else {
		ntmp = strip_spaces(q);
		if (!ntmp) {
			X509V3error(X509V3_R_INVALID_NULL_NAME);
			goto err;
		}
		X509V3_add_value(ntmp, NULL, &values);
	}
	free(linebuf);
	return values;

err:
	free(linebuf);
	sk_CONF_VALUE_pop_free(values, X509V3_conf_free);
	return NULL;

}

/* Delete leading and trailing spaces from a string */
static char *
strip_spaces(char *name)
{
	char *p, *q;

	/* Skip over leading spaces */
	p = name;
	while (*p && isspace((unsigned char)*p))
		p++;
	if (!*p)
		return NULL;
	q = p + strlen(p) - 1;
	while ((q != p) && isspace((unsigned char)*q))
		q--;
	if (p != q)
		q[1] = 0;
	if (!*p)
		return NULL;
	return p;
}

/* hex string utilities */

/* Given a buffer of length 'len' return a malloc'ed string with its
 * hex representation
 */
char *
hex_to_string(const unsigned char *buffer, long len)
{
	char *tmp, *q;
	const unsigned char *p;
	int i;
	static const char hexdig[] = "0123456789ABCDEF";

	if (!buffer || !len)
		return NULL;
	if (!(tmp = malloc(len * 3 + 1))) {
		X509V3error(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	q = tmp;
	for (i = 0, p = buffer; i < len; i++, p++) {
		*q++ = hexdig[(*p >> 4) & 0xf];
		*q++ = hexdig[*p & 0xf];
		*q++ = ':';
	}
	q[-1] = 0;
	return tmp;
}

/* Give a string of hex digits convert to
 * a buffer
 */

unsigned char *
string_to_hex(const char *str, long *len)
{
	unsigned char *hexbuf, *q;
	unsigned char ch, cl, *p;
	if (!str) {
		X509V3error(X509V3_R_INVALID_NULL_ARGUMENT);
		return NULL;
	}
	if (!(hexbuf = malloc(strlen(str) >> 1)))
		goto err;
	for (p = (unsigned char *)str, q = hexbuf; *p; ) {
		ch = *p++;
		if (ch == ':')
			continue;
		cl = *p++;
		if (!cl) {
			X509V3error(X509V3_R_ODD_NUMBER_OF_DIGITS);
			free(hexbuf);
			return NULL;
		}
		ch = tolower(ch);
		cl = tolower(cl);

		if ((ch >= '0') && (ch <= '9'))
			ch -= '0';
		else if ((ch >= 'a') && (ch <= 'f'))
			ch -= 'a' - 10;
		else
			goto badhex;

		if ((cl >= '0') && (cl <= '9'))
			cl -= '0';
		else if ((cl >= 'a') && (cl <= 'f'))
			cl -= 'a' - 10;
		else
			goto badhex;

		*q++ = (ch << 4) | cl;
	}

	if (len)
		*len = q - hexbuf;

	return hexbuf;

err:
	free(hexbuf);
	X509V3error(ERR_R_MALLOC_FAILURE);
	return NULL;

badhex:
	free(hexbuf);
	X509V3error(X509V3_R_ILLEGAL_HEX_DIGIT);
	return NULL;
}

/* V2I name comparison function: returns zero if 'name' matches
 * cmp or cmp.*
 */

int
name_cmp(const char *name, const char *cmp)
{
	int len, ret;
	char c;

	len = strlen(cmp);
	if ((ret = strncmp(name, cmp, len)))
		return ret;
	c = name[len];
	if (!c || (c=='.'))
		return 0;
	return 1;
}

static int
sk_strcmp(const char * const *a, const char * const *b)
{
	return strcmp(*a, *b);
}

STACK_OF(OPENSSL_STRING) *X509_get1_email(X509 *x)
{
	GENERAL_NAMES *gens;
	STACK_OF(OPENSSL_STRING) *ret;

	gens = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);
	ret = get_email(X509_get_subject_name(x), gens);
	sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
	return ret;
}

STACK_OF(OPENSSL_STRING) *X509_get1_ocsp(X509 *x)
{
	AUTHORITY_INFO_ACCESS *info;
	STACK_OF(OPENSSL_STRING) *ret = NULL;
	int i;

	info = X509_get_ext_d2i(x, NID_info_access, NULL, NULL);
	if (!info)
		return NULL;
	for (i = 0; i < sk_ACCESS_DESCRIPTION_num(info); i++) {
		ACCESS_DESCRIPTION *ad = sk_ACCESS_DESCRIPTION_value(info, i);
		if (OBJ_obj2nid(ad->method) == NID_ad_OCSP) {
			if (ad->location->type == GEN_URI) {
				if (!append_ia5(&ret,
				    ad->location->d.uniformResourceIdentifier))
					break;
			}
		}
	}
	AUTHORITY_INFO_ACCESS_free(info);
	return ret;
}

STACK_OF(OPENSSL_STRING) *X509_REQ_get1_email(X509_REQ *x)
{
	GENERAL_NAMES *gens;
	STACK_OF(X509_EXTENSION) *exts;
	STACK_OF(OPENSSL_STRING) *ret;

	exts = X509_REQ_get_extensions(x);
	gens = X509V3_get_d2i(exts, NID_subject_alt_name, NULL, NULL);
	ret = get_email(X509_REQ_get_subject_name(x), gens);
	sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
	sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);
	return ret;
}


static
STACK_OF(OPENSSL_STRING) *get_email(X509_NAME *name, GENERAL_NAMES *gens)
{
	STACK_OF(OPENSSL_STRING) *ret = NULL;
	X509_NAME_ENTRY *ne;
	ASN1_IA5STRING *email;
	GENERAL_NAME *gen;
	int i;

	/* Now add any email address(es) to STACK */
	i = -1;

	/* First supplied X509_NAME */
	while ((i = X509_NAME_get_index_by_NID(name,
	    NID_pkcs9_emailAddress, i)) >= 0) {
		ne = X509_NAME_get_entry(name, i);
		email = X509_NAME_ENTRY_get_data(ne);
		if (!append_ia5(&ret, email))
			return NULL;
	}
	for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
		gen = sk_GENERAL_NAME_value(gens, i);
		if (gen->type != GEN_EMAIL)
			continue;
		if (!append_ia5(&ret, gen->d.ia5))
			return NULL;
	}
	return ret;
}

static void
str_free(OPENSSL_STRING str)
{
	free(str);
}

static int
append_ia5(STACK_OF(OPENSSL_STRING) **sk, ASN1_IA5STRING *email)
{
	char *emtmp;

	/* First some sanity checks */
	if (email->type != V_ASN1_IA5STRING)
		return 1;
	if (!email->data || !email->length)
		return 1;
	if (!*sk)
		*sk = sk_OPENSSL_STRING_new(sk_strcmp);
	if (!*sk)
		return 0;
	/* Don't add duplicates */
	if (sk_OPENSSL_STRING_find(*sk, (char *)email->data) != -1)
		return 1;
	emtmp = strdup((char *)email->data);
	if (!emtmp || !sk_OPENSSL_STRING_push(*sk, emtmp)) {
		X509_email_free(*sk);
		*sk = NULL;
		return 0;
	}
	return 1;
}

void
X509_email_free(STACK_OF(OPENSSL_STRING) *sk)
{
	sk_OPENSSL_STRING_pop_free(sk, str_free);
}

typedef int (*equal_fn) (const unsigned char *pattern, size_t pattern_len,
    const unsigned char *subject, size_t subject_len, unsigned int flags);

/* Skip pattern prefix to match "wildcard" subject */
static void skip_prefix(const unsigned char **p, size_t *plen,
    const unsigned char *subject, size_t subject_len, unsigned int flags)
{
	const unsigned char *pattern = *p;
	size_t pattern_len = *plen;

	/*
	 * If subject starts with a leading '.' followed by more octets, and
	 * pattern is longer, compare just an equal-length suffix with the
	 * full subject (starting at the '.'), provided the prefix contains
	 * no NULs.
	 */
	if ((flags & _X509_CHECK_FLAG_DOT_SUBDOMAINS) == 0)
		return;

	while (pattern_len > subject_len && *pattern) {
		if ((flags & X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS) &&
		    *pattern == '.')
			break;
		++pattern;
		--pattern_len;
	}

	/* Skip if entire prefix acceptable */
	if (pattern_len == subject_len) {
		*p = pattern;
		*plen = pattern_len;
	}
}

/*
 * Open/BoringSSL uses memcmp for "equal_case" while their
 * "equal_nocase" function is a hand-rolled strncasecmp that does not
 * allow \0 in the pattern. Since an embedded \0 is likely a sign of
 * problems, we simply don't allow it in either case, and then we use
 * standard libc funcitons.
 */

/* Compare using strncasecmp */
static int equal_nocase(const unsigned char *pattern, size_t pattern_len,
    const unsigned char *subject, size_t subject_len,
    unsigned int flags)
{
	if (memchr(pattern, '\0', pattern_len) != NULL)
		return 0;
	if (memchr(subject, '\0', subject_len) != NULL)
		return 0;
	skip_prefix(&pattern, &pattern_len, subject, subject_len, flags);
	if (pattern_len != subject_len)
		return 0;
	return (strncasecmp(pattern, subject, pattern_len) == 0);
}

/* Compare using strncmp. */
static int equal_case(const unsigned char *pattern, size_t pattern_len,
    const unsigned char *subject, size_t subject_len,
    unsigned int flags)
{
	if (memchr(pattern, 0, pattern_len) != NULL)
		return 0;
	if (memchr(subject, 0, subject_len) != NULL)
		return 0;
	skip_prefix(&pattern, &pattern_len, subject, subject_len, flags);
	if (pattern_len != subject_len)
		return 0;
	return (strncmp(pattern, subject, pattern_len) == 0);
}

/*
 * RFC 5280, section 7.5, requires that only the domain is compared in a
 * case-insensitive manner.
 */
static int equal_email(const unsigned char *a, size_t a_len,
    const unsigned char *b, size_t b_len,
    unsigned int unused_flags)
{
	size_t pos = a_len;
	if (a_len != b_len)
		return 0;
	/*
	 * We search backwards for the '@@' character, so that we do not have to
	 * deal with quoted local-parts.  The domain part is compared in a
	 * case-insensitive manner.
	 */
	while (pos > 0) {
		pos--;
		if (a[pos] == '@@' || b[pos] == '@@') {
			if (!equal_nocase(a + pos, a_len - pos, b + pos, a_len - pos, 0))
				return 0;
			break;
		}
	}
	if (pos == 0)
		pos = a_len;
	return equal_case(a, pos, b, pos, 0);
}

/*
 * Compare the prefix and suffix with the subject, and check that the
 * characters in-between are valid.
 */
static int wildcard_match(const unsigned char *prefix, size_t prefix_len,
    const unsigned char *suffix, size_t suffix_len,
    const unsigned char *subject, size_t subject_len, unsigned int flags)
{
	const unsigned char *wildcard_start;
	const unsigned char *wildcard_end;
	const unsigned char *p;
	int allow_multi = 0;
	int allow_idna = 0;

	if (subject_len < prefix_len + suffix_len)
		return 0;
	if (!equal_nocase(prefix, prefix_len, subject, prefix_len, flags))
		return 0;
	wildcard_start = subject + prefix_len;
	wildcard_end = subject + (subject_len - suffix_len);
	if (!equal_nocase(wildcard_end, suffix_len, suffix, suffix_len, flags))
		return 0;
	/*
	 * If the wildcard makes up the entire first label, it must match at
	 * least one character.
	 */
	if (prefix_len == 0 && *suffix == '.') {
		if (wildcard_start == wildcard_end)
			return 0;
		allow_idna = 1;
		if (flags & X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS)
			allow_multi = 1;
	}
	/* IDNA labels cannot match partial wildcards */
	if (!allow_idna &&
	    subject_len >= 4
	    && strncasecmp((char *)subject, "xn--", 4) == 0)
		return 0;
	/* The wildcard may match a literal '*' */
	if (wildcard_end == wildcard_start + 1 && *wildcard_start == '*')
		return 1;
	/*
	 * Check that the part matched by the wildcard contains only
	 * permitted characters and only matches a single label unless
	 * allow_multi is set.
	 */
	for (p = wildcard_start; p != wildcard_end; ++p)
		if (!(('0' <= *p && *p <= '9') || ('A' <= *p && *p <= 'Z') ||
		    ('a' <= *p && *p <= 'z') || *p == '-' ||
		    (allow_multi && *p == '.')))
			return 0;
	return 1;
}

#define LABEL_START     (1 << 0)
#define LABEL_END       (1 << 1)
#define LABEL_HYPHEN    (1 << 2)
#define LABEL_IDNA      (1 << 3)

static const unsigned char *valid_star(const unsigned char *p, size_t len,
    unsigned int flags)
{
	const unsigned char *star = 0;
	size_t i;
	int state = LABEL_START;
	int dots = 0;
	for (i = 0; i < len; ++i) {
		/*
		 * Locate first and only legal wildcard, either at the start
		 * or end of a non-IDNA first and not final label.
		 */
		if (p[i] == '*') {
			int atstart = (state & LABEL_START);
			int atend = (i == len - 1 || p[i + 1] == '.');
			/*
			 * At most one wildcard per pattern.
			 * No wildcards in IDNA labels.
			 * No wildcards after the first label.
			 */
			if (star != NULL || (state & LABEL_IDNA) != 0 || dots)
				return NULL;
			/* Only full-label '*.example.com' wildcards? */
			if ((flags & X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS)
			    && (!atstart || !atend))
				return NULL;
			/* No 'foo*bar' wildcards */
			if (!atstart && !atend)
				return NULL;
			star = &p[i];
			state &= ~LABEL_START;
		} else if ((state & LABEL_START) != 0) {
			/*
			 * At the start of a label, skip any "xn--" and
			 * remain in the LABEL_START state, but set the
			 * IDNA label state
			 */
			if ((state & LABEL_IDNA) == 0 && len - i >= 4
			    && strncasecmp((char *)&p[i], "xn--", 4) == 0) {
				i += 3;
				state |= LABEL_IDNA;
				continue;
			}
			/* Labels must start with a letter or digit */
			state &= ~LABEL_START;
			if (('a' <= p[i] && p[i] <= 'z')
			    || ('A' <= p[i] && p[i] <= 'Z')
			    || ('0' <= p[i] && p[i] <= '9'))
				continue;
			return NULL;
		} else if (('a' <= p[i] && p[i] <= 'z')
		    || ('A' <= p[i] && p[i] <= 'Z')
		    || ('0' <= p[i] && p[i] <= '9')) {
			state &= LABEL_IDNA;
			continue;
		} else if (p[i] == '.') {
			if (state & (LABEL_HYPHEN | LABEL_START))
				return NULL;
			state = LABEL_START;
			++dots;
		} else if (p[i] == '-') {
			/* no domain/subdomain starts with '-' */
			if ((state & LABEL_START) != 0)
				return NULL;
			state |= LABEL_HYPHEN;
		} else
			return NULL;
	}

	/*
	 * The final label must not end in a hyphen or ".", and
	 * there must be at least two dots after the star.
	 */
	if ((state & (LABEL_START | LABEL_HYPHEN)) != 0 || dots < 2)
		return NULL;
	return star;
}

/* Compare using wildcards. */
static int equal_wildcard(const unsigned char *pattern, size_t pattern_len,
    const unsigned char *subject, size_t subject_len, unsigned int flags)
{
	const unsigned char *star = NULL;

	/*
	 * Subject names starting with '.' can only match a wildcard pattern
	 * via a subject sub-domain pattern suffix match.
	 */
	if (!(subject_len > 1 && subject[0] == '.'))
		star = valid_star(pattern, pattern_len, flags);
	if (star == NULL)
		return equal_nocase(pattern, pattern_len,
		    subject, subject_len, flags);
	return wildcard_match(pattern, star - pattern,
	    star + 1, (pattern + pattern_len) - star - 1,
	    subject, subject_len, flags);
}

/*
 * Compare an ASN1_STRING to a supplied string. If they match return 1. If
 * cmp_type > 0 only compare if string matches the type, otherwise convert it
 * to UTF8.
 */

static int
do_check_string(ASN1_STRING *a, int cmp_type, equal_fn equal,
    unsigned int flags, const char *b, size_t blen, char **peername)
{
	int rv = 0;

	if (!a->data || !a->length)
		return 0;
	if (cmp_type > 0) {
		if (cmp_type != a->type)
			return 0;
		if (cmp_type == V_ASN1_IA5STRING)
			rv = equal(a->data, a->length, (unsigned char *)b,
			    blen, flags);
		else if (a->length == (int)blen && !memcmp(a->data, b, blen))
			rv = 1;
		if (rv > 0 && peername &&
		    (*peername = strndup((char *)a->data, a->length)) == NULL)
			rv = -1;
	} else {
		int astrlen;
		unsigned char *astr;
		astrlen = ASN1_STRING_to_UTF8(&astr, a);
		if (astrlen < 0)
			return -1;
		rv = equal(astr, astrlen, (unsigned char *)b, blen, flags);
		if (rv > 0 && peername &&
		    (*peername = strndup((char *)astr, astrlen)) == NULL)
			rv = -1;
		free(astr);
	}
	return rv;
}

static int do_x509_check(X509 *x, const char *chk, size_t chklen,
    unsigned int flags, int check_type, char **peername)
{
	GENERAL_NAMES *gens = NULL;
	X509_NAME *name = NULL;
	size_t i;
	int j;
	int cnid = NID_undef;
	int alt_type;
	int san_present = 0;
	int rv = 0;
	equal_fn equal;

	/* See below, this flag is internal-only */
	flags &= ~_X509_CHECK_FLAG_DOT_SUBDOMAINS;
	if (check_type == GEN_EMAIL) {
		cnid = NID_pkcs9_emailAddress;
		alt_type = V_ASN1_IA5STRING;
		equal = equal_email;
	} else if (check_type == GEN_DNS) {
		cnid = NID_commonName;
		/* Implicit client-side DNS sub-domain pattern */
		if (chklen > 1 && chk[0] == '.')
			flags |= _X509_CHECK_FLAG_DOT_SUBDOMAINS;
		alt_type = V_ASN1_IA5STRING;
		if (flags & X509_CHECK_FLAG_NO_WILDCARDS)
			equal = equal_nocase;
		else
			equal = equal_wildcard;
	} else {
		alt_type = V_ASN1_OCTET_STRING;
		equal = equal_case;
	}

	gens = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);
	if (gens != NULL) {
		for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
			GENERAL_NAME *gen;
			ASN1_STRING *cstr;
			gen = sk_GENERAL_NAME_value(gens, i);
			if (gen->type != check_type)
				continue;
			san_present = 1;
			if (check_type == GEN_EMAIL)
				cstr = gen->d.rfc822Name;
			else if (check_type == GEN_DNS)
				cstr = gen->d.dNSName;
			else
				cstr = gen->d.iPAddress;
			/* Positive on success, negative on error! */
			if ((rv = do_check_string(cstr, alt_type, equal, flags,
			    chk, chklen, peername)) != 0)
				break;
		}
		GENERAL_NAMES_free(gens);
		if (rv != 0)
			return rv;
		if (cnid == NID_undef ||
		    (san_present &&
		    !(flags & X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT)))
			return 0;
	}

	/* We're done if CN-ID is not pertinent */
	if (cnid == NID_undef)
		return 0;

	j = -1;
	name = X509_get_subject_name(x);
	while ((j = X509_NAME_get_index_by_NID(name, cnid, j)) >= 0) {
		X509_NAME_ENTRY *ne;
		ASN1_STRING *str;
		if ((ne = X509_NAME_get_entry(name, j)) == NULL)
			return -1;
		if ((str = X509_NAME_ENTRY_get_data(ne)) == NULL)
			return -1;
		/* Positive on success, negative on error! */
		if ((rv = do_check_string(str, -1, equal, flags,
			 chk, chklen, peername)) != 0)
			return rv;
	}
	return 0;
}

int X509_check_host(X509 *x, const char *chk, size_t chklen,
    unsigned int flags, char **peername)
{
	if (chk == NULL)
		return -2;
	if (memchr(chk, '\0', chklen))
		return -2;
	return do_x509_check(x, chk, chklen, flags, GEN_DNS, peername);
}

int X509_check_email(X509 *x, const char *chk, size_t chklen,
    unsigned int flags)
{
	if (chk == NULL)
		return -2;
	if (memchr(chk, '\0', chklen))
		return -2;
	return do_x509_check(x, chk, chklen, flags, GEN_EMAIL, NULL);
}

int X509_check_ip(X509 *x, const unsigned char *chk, size_t chklen,
    unsigned int flags)
{
	if (chk == NULL)
		return -2;
	return do_x509_check(x, (char *)chk, chklen, flags, GEN_IPADD, NULL);
}

int X509_check_ip_asc(X509 *x, const char *ipasc, unsigned int flags)
{
	unsigned char ipout[16];
	size_t iplen;

	if (ipasc == NULL)
		return -2;
	iplen = (size_t)a2i_ipadd(ipout, ipasc);
	if (iplen == 0)
		return -2;
	return do_x509_check(x, (char *)ipout, iplen, flags, GEN_IPADD, NULL);
}

/* Convert IP addresses both IPv4 and IPv6 into an
 * OCTET STRING compatible with RFC3280.
 */

ASN1_OCTET_STRING *
a2i_IPADDRESS(const char *ipasc)
{
	unsigned char ipout[16];
	ASN1_OCTET_STRING *ret;
	int iplen;

	/* If string contains a ':' assume IPv6 */

	iplen = a2i_ipadd(ipout, ipasc);

	if (!iplen)
		return NULL;

	ret = ASN1_OCTET_STRING_new();
	if (!ret)
		return NULL;
	if (!ASN1_OCTET_STRING_set(ret, ipout, iplen)) {
		ASN1_OCTET_STRING_free(ret);
		return NULL;
	}
	return ret;
}

ASN1_OCTET_STRING *
a2i_IPADDRESS_NC(const char *ipasc)
{
	ASN1_OCTET_STRING *ret = NULL;
	unsigned char ipout[32];
	char *iptmp = NULL, *p;
	int iplen1, iplen2;

	p = strchr(ipasc, '/');
	if (!p)
		return NULL;
	iptmp = strdup(ipasc);
	if (!iptmp)
		return NULL;
	p = iptmp + (p - ipasc);
	*p++ = 0;

	iplen1 = a2i_ipadd(ipout, iptmp);

	if (!iplen1)
		goto err;

	iplen2 = a2i_ipadd(ipout + iplen1, p);

	free(iptmp);
	iptmp = NULL;

	if (!iplen2 || (iplen1 != iplen2))
		goto err;

	ret = ASN1_OCTET_STRING_new();
	if (!ret)
		goto err;
	if (!ASN1_OCTET_STRING_set(ret, ipout, iplen1 + iplen2))
		goto err;

	return ret;

err:
	free(iptmp);
	if (ret)
		ASN1_OCTET_STRING_free(ret);
	return NULL;
}


int
a2i_ipadd(unsigned char *ipout, const char *ipasc)
{
	/* If string contains a ':' assume IPv6 */

	if (strchr(ipasc, ':')) {
		if (!ipv6_from_asc(ipout, ipasc))
			return 0;
		return 16;
	} else {
		if (!ipv4_from_asc(ipout, ipasc))
			return 0;
		return 4;
	}
}

static int
ipv4_from_asc(unsigned char *v4, const char *in)
{
	int a0, a1, a2, a3;
	if (sscanf(in, "%d.%d.%d.%d", &a0, &a1, &a2, &a3) != 4)
		return 0;
	if ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255) ||
	    (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))
		return 0;
	v4[0] = a0;
	v4[1] = a1;
	v4[2] = a2;
	v4[3] = a3;
	return 1;
}

typedef struct {
	/* Temporary store for IPV6 output */
	unsigned char tmp[16];
	/* Total number of bytes in tmp */
	int total;
	/* The position of a zero (corresponding to '::') */
	int zero_pos;
	/* Number of zeroes */
	int zero_cnt;
} IPV6_STAT;


static int
ipv6_from_asc(unsigned char *v6, const char *in)
{
	IPV6_STAT v6stat;

	v6stat.total = 0;
	v6stat.zero_pos = -1;
	v6stat.zero_cnt = 0;

	/* Treat the IPv6 representation as a list of values
	 * separated by ':'. The presence of a '::' will parse
 	 * as one, two or three zero length elements.
	 */
	if (!CONF_parse_list(in, ':', 0, ipv6_cb, &v6stat))
		return 0;

	/* Now for some sanity checks */

	if (v6stat.zero_pos == -1) {
		/* If no '::' must have exactly 16 bytes */
		if (v6stat.total != 16)
			return 0;
	} else {
		/* If '::' must have less than 16 bytes */
		if (v6stat.total == 16)
			return 0;
		/* More than three zeroes is an error */
		if (v6stat.zero_cnt > 3)
			return 0;
		/* Can only have three zeroes if nothing else present */
		else if (v6stat.zero_cnt == 3) {
			if (v6stat.total > 0)
				return 0;
		}
		/* Can only have two zeroes if at start or end */
		else if (v6stat.zero_cnt == 2) {
			if ((v6stat.zero_pos != 0) &&
			    (v6stat.zero_pos != v6stat.total))
				return 0;
		} else
			/* Can only have one zero if *not* start or end */
		{
			if ((v6stat.zero_pos == 0) ||
			    (v6stat.zero_pos == v6stat.total))
				return 0;
		}
	}

	/* Format result */

	if (v6stat.zero_pos >= 0) {
		/* Copy initial part */
		memcpy(v6, v6stat.tmp, v6stat.zero_pos);
		/* Zero middle */
		memset(v6 + v6stat.zero_pos, 0, 16 - v6stat.total);
		/* Copy final part */
		if (v6stat.total != v6stat.zero_pos)
			memcpy(v6 + v6stat.zero_pos + 16 - v6stat.total,
			    v6stat.tmp + v6stat.zero_pos,
			    v6stat.total - v6stat.zero_pos);
	} else
		memcpy(v6, v6stat.tmp, 16);

	return 1;
}

static int
ipv6_cb(const char *elem, int len, void *usr)
{
	IPV6_STAT *s = usr;

	/* Error if 16 bytes written */
	if (s->total == 16)
		return 0;
	if (len == 0) {
		/* Zero length element, corresponds to '::' */
		if (s->zero_pos == -1)
			s->zero_pos = s->total;
		/* If we've already got a :: its an error */
		else if (s->zero_pos != s->total)
			return 0;
		s->zero_cnt++;
	} else {
		/* If more than 4 characters could be final a.b.c.d form */
		if (len > 4) {
			/* Need at least 4 bytes left */
			if (s->total > 12)
				return 0;
			/* Must be end of string */
			if (elem[len])
				return 0;
			if (!ipv4_from_asc(s->tmp + s->total, elem))
				return 0;
			s->total += 4;
		} else {
			if (!ipv6_hex(s->tmp + s->total, elem, len))
				return 0;
			s->total += 2;
		}
	}
	return 1;
}

/* Convert a string of up to 4 hex digits into the corresponding
 * IPv6 form.
 */

static int
ipv6_hex(unsigned char *out, const char *in, int inlen)
{
	unsigned char c;
	unsigned int num = 0;

	if (inlen > 4)
		return 0;
	while (inlen--) {
		c = *in++;
		num <<= 4;
		if ((c >= '0') && (c <= '9'))
			num |= c - '0';
		else if ((c >= 'A') && (c <= 'F'))
			num |= c - 'A' + 10;
		else if ((c >= 'a') && (c <= 'f'))
			num |=  c - 'a' + 10;
		else
			return 0;
	}
	out[0] = num >> 8;
	out[1] = num & 0xff;
	return 1;
}

int
X509V3_NAME_from_section(X509_NAME *nm, STACK_OF(CONF_VALUE)*dn_sk,
    unsigned long chtype)
{
	CONF_VALUE *v;
	int i, mval;
	char *p, *type;

	if (!nm)
		return 0;

	for (i = 0; i < sk_CONF_VALUE_num(dn_sk); i++) {
		v = sk_CONF_VALUE_value(dn_sk, i);
		type = v->name;
		/* Skip past any leading X. X: X, etc to allow for
		 * multiple instances
		 */
		for (p = type; *p; p++)
			if ((*p == ':') || (*p == ',') || (*p == '.')) {
				p++;
				if (*p)
					type = p;
				break;
			}
		if (*type == '+') {
			mval = -1;
			type++;
		} else
			mval = 0;
		if (!X509_NAME_add_entry_by_txt(nm, type, chtype,
		    (unsigned char *) v->value, -1, -1, mval))
			return 0;
	}
	return 1;
}
@


1.25
log
@Bring in functions used by stunnel and exim from BoringSSL - this brings
in X509_check_host, X509_check_email, X509_check_ip, and X509_check_ip_asc,
with some cleanup on the way in by myself and jsing@@
ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_utl.c,v 1.24 2015/02/07 13:19:15 doug Exp $ */
d106 1
a106 1
	X509V3err(X509V3_F_X509V3_ADD_VALUE, ERR_R_MALLOC_FAILURE);
d162 1
a162 1
		X509V3err(X509V3_F_I2S_ASN1_ENUMERATED, ERR_R_MALLOC_FAILURE);
d177 1
a177 1
		X509V3err(X509V3_F_I2S_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);
d191 1
a191 2
		X509V3err(X509V3_F_S2I_ASN1_INTEGER,
		    X509V3_R_INVALID_NULL_VALUE);
d214 1
a214 1
		X509V3err(X509V3_F_S2I_ASN1_INTEGER, X509V3_R_BN_DEC2BN_ERROR);
d224 1
a224 2
		X509V3err(X509V3_F_S2I_ASN1_INTEGER,
		    X509V3_R_BN_TO_ASN1_INTEGER_ERROR);
d268 1
a268 2
	X509V3err(X509V3_F_X509V3_GET_VALUE_BOOL,
	    X509V3_R_INVALID_BOOLEAN_STRING);
d302 1
a302 1
		X509V3err(X509V3_F_X509V3_PARSE_LIST, ERR_R_MALLOC_FAILURE);
d319 1
a319 2
					X509V3err(X509V3_F_X509V3_PARSE_LIST,
					    X509V3_R_INVALID_NULL_NAME);
d328 1
a328 2
					X509V3err(X509V3_F_X509V3_PARSE_LIST,
					    X509V3_R_INVALID_NULL_NAME);
d341 1
a341 2
					X509V3err(X509V3_F_X509V3_PARSE_LIST,
					    X509V3_R_INVALID_NULL_VALUE);
d355 1
a355 2
			X509V3err(X509V3_F_X509V3_PARSE_LIST,
			    X509V3_R_INVALID_NULL_VALUE);
d362 1
a362 2
			X509V3err(X509V3_F_X509V3_PARSE_LIST,
			    X509V3_R_INVALID_NULL_NAME);
d415 1
a415 1
		X509V3err(X509V3_F_HEX_TO_STRING, ERR_R_MALLOC_FAILURE);
d438 1
a438 2
		X509V3err(X509V3_F_STRING_TO_HEX,
		    X509V3_R_INVALID_NULL_ARGUMENT);
d449 1
a449 2
			X509V3err(X509V3_F_STRING_TO_HEX,
			    X509V3_R_ODD_NUMBER_OF_DIGITS);
d480 1
a480 1
	X509V3err(X509V3_F_STRING_TO_HEX, ERR_R_MALLOC_FAILURE);
d485 1
a485 1
	X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_ILLEGAL_HEX_DIGIT);
@


1.24
log
@Delete a lot of #if 0 code in libressl.

There are a few instances where #if 1 is removed but the code remains.

Based on the following OpenSSL commits.  Some of the commits weren't
strictly deletions so they are going to be split up into separate commits.

6f91b017bbb7140f816721141ac156d1b828a6b3
3d47c1d331fdc7574d2275cda1a630ccdb624b08
dfb56425b68314b2b57e17c82c1df42e7a015132
c8fa2356a00cbaada8963f739e5570298311a060
f16a64d11f55c01f56baa62ebf1dec7f8fe718cb
9ccc00ef6ea65567622e40c49aca43f2c6d79cdb
02a938c953b3e1ced71d9a832de1618f907eb96d
75d0ebef2aef7a2c77b27575b8da898e22f3ccd5
d6fbb194095312f4722c81c9362dbd0de66cb656
6f1a93ad111c7dfe36a09a976c4c009079b19ea1
1a5adcfb5edfe23908b350f8757df405b0f5f71f
8de24b792743d11e1d5a0dcd336a49368750c577
a2b18e657ea1a932d125154f4e13ab2258796d90
8e964419603d2478dfb391c66e7ccb2dcc9776b4
32dfde107636ac9bc62a5b3233fe2a54dbc27008

input + ok jsing@@, miod@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_utl.c,v 1.23 2014/07/13 16:03:10 beck Exp $ */
d639 423
@


1.23
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_utl.c,v 1.22 2014/07/11 08:44:49 jsing Exp $ */
a330 3
#if 0
				printf("%s\n", ntmp);
#endif
a344 3
#if 0
				printf("%s\n", ntmp);
#endif
a359 3
#if 0
		printf("%s=%s\n", ntmp, vtmp);
#endif
a367 3
#if 0
		printf("%s\n", ntmp);
#endif
@


1.22
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_utl.c,v 1.21 2014/07/10 13:58:23 jsing Exp $ */
d90 1
a90 1
	if (name && !(tname = BUF_strdup(name)))
d92 1
a92 1
	if (value && !(tvalue = BUF_strdup(value)))
d304 4
a307 1
	linebuf = BUF_strdup(line);
d638 1
a638 1
	emtmp = BUF_strdup((char *)email->data);
d692 1
a692 1
	iptmp = BUF_strdup(ipasc);
@


1.21
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_utl.c,v 1.20 2014/06/12 15:49:31 deraadt Exp $ */
d64 1
a64 1
#include "cryptlib.h"
d66 1
a67 1
#include <openssl/bn.h>
@


1.20
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 3
a63 2
#include <stdio.h>
#include <ctype.h>
@


1.19
log
@There is no need for is{upper,lower}() tests before to{lower,uppper}(),
since all other characters are mapped through transparently.
ok jsing
@
text
@d1 1
a1 1
/* v3_utl.c */
@


1.18
log
@EBCDIC support died a while ago, except in a comment.
@
text
@d471 2
a472 4
		if (isupper(ch))
			ch = tolower(ch);
		if (isupper(cl))
			cl = tolower(cl);
@


1.17
log
@more: no need for null check before free
ok tedu guenther
@
text
@a418 1
 * @@@@@@ (Contents of buffer are always kept in ASCII, also on EBCDIC machines)
a419 1

@


1.16
log
@KNF.
@
text
@d106 3
a108 6
	if (vtmp)
		free(vtmp);
	if (tname)
		free(tname);
	if (tvalue)
		free(tvalue);
d126 3
a128 6
	if (conf->name)
		free(conf->name);
	if (conf->value)
		free(conf->value);
	if (conf->section)
		free(conf->section);
@


1.15
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d70 2
a71 1
static STACK_OF(OPENSSL_STRING) *get_email(X509_NAME *name, GENERAL_NAMES *gens);
d82 3
a84 2
int X509V3_add_value(const char *name, const char *value,
						STACK_OF(CONF_VALUE) **extlist)
d88 9
a96 4
	if(name && !(tname = BUF_strdup(name))) goto err;
	if(value && !(tvalue = BUF_strdup(value))) goto err;
	if(!(vtmp = malloc(sizeof(CONF_VALUE)))) goto err;
	if(!*extlist && !(*extlist = sk_CONF_VALUE_new_null())) goto err;
d100 2
a101 1
	if(!sk_CONF_VALUE_push(*extlist, vtmp)) goto err;
d103 9
a111 5
	err:
	X509V3err(X509V3_F_X509V3_ADD_VALUE,ERR_R_MALLOC_FAILURE);
	if(vtmp) free(vtmp);
	if(tname) free(tname);
	if(tvalue) free(tvalue);
d115 6
a120 5
int X509V3_add_value_uchar(const char *name, const unsigned char *value,
			   STACK_OF(CONF_VALUE) **extlist)
    {
    return X509V3_add_value(name,(const char *)value,extlist);
    }
d124 2
a125 1
void X509V3_conf_free(CONF_VALUE *conf)
d127 8
a134 4
	if(!conf) return;
	if(conf->name) free(conf->name);
	if(conf->value) free(conf->value);
	if(conf->section) free(conf->section);
d138 3
a140 2
int X509V3_add_value_bool(const char *name, int asn1_bool,
						STACK_OF(CONF_VALUE) **extlist)
d142 2
a143 1
	if(asn1_bool) return X509V3_add_value(name, "TRUE", extlist);
d147 3
a149 2
int X509V3_add_value_bool_nf(char *name, int asn1_bool,
						STACK_OF(CONF_VALUE) **extlist)
d151 2
a152 1
	if(asn1_bool) return X509V3_add_value(name, "TRUE", extlist);
d157 2
a158 1
char *i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *method, ASN1_ENUMERATED *a)
d162 6
a167 4
	if(!a) return NULL;
	if(!(bntmp = ASN1_ENUMERATED_to_BN(a, NULL)) ||
	    !(strtmp = BN_bn2dec(bntmp)) )
		X509V3err(X509V3_F_I2S_ASN1_ENUMERATED,ERR_R_MALLOC_FAILURE);
d172 2
a173 1
char *i2s_ASN1_INTEGER(X509V3_EXT_METHOD *method, ASN1_INTEGER *a)
d177 6
a182 4
	if(!a) return NULL;
	if(!(bntmp = ASN1_INTEGER_to_BN(a, NULL)) ||
	    !(strtmp = BN_bn2dec(bntmp)) )
		X509V3err(X509V3_F_I2S_ASN1_INTEGER,ERR_R_MALLOC_FAILURE);
d187 2
a188 1
ASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, char *value)
d194 1
d196 2
a197 1
		X509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_INVALID_NULL_VALUE);
d204 2
a205 1
	} else isneg = 0;
d210 2
a211 1
	} else ishex = 0;
d213 4
a216 2
	if (ishex) ret = BN_hex2bn(&bn, value);
	else ret = BN_dec2bn(&bn, value);
d220 1
a220 1
		X509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_BN_DEC2BN_ERROR);
d224 2
a225 1
	if (isneg && BN_is_zero(bn)) isneg = 0;
d230 2
a231 1
		X509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_BN_TO_ASN1_INTEGER_ERROR);
d234 2
a235 1
	if (isneg) aint->type |= V_ASN1_NEG;
d239 3
a241 2
int X509V3_add_value_int(const char *name, ASN1_INTEGER *aint,
	     STACK_OF(CONF_VALUE) **extlist)
d245 5
a249 2
	if(!aint) return 1;
	if(!(strtmp = i2s_ASN1_INTEGER(NULL, aint))) return 0;
d255 2
a256 1
int X509V3_get_value_bool(CONF_VALUE *value, int *asn1_bool)
d259 6
a264 4
	if(!(btmp = value->value)) goto err;
	if(!strcmp(btmp, "TRUE") || !strcmp(btmp, "true")
		 || !strcmp(btmp, "Y") || !strcmp(btmp, "y")
		|| !strcmp(btmp, "YES") || !strcmp(btmp, "yes")) {
d267 3
a269 3
	} else if(!strcmp(btmp, "FALSE") || !strcmp(btmp, "false")
		 || !strcmp(btmp, "N") || !strcmp(btmp, "n")
		|| !strcmp(btmp, "NO") || !strcmp(btmp, "no")) {
d273 4
a276 2
	err:
	X509V3err(X509V3_F_X509V3_GET_VALUE_BOOL,X509V3_R_INVALID_BOOLEAN_STRING);
d281 2
a282 1
int X509V3_get_value_int(CONF_VALUE *value, ASN1_INTEGER **aint)
d285 2
a286 1
	if(!(itmp = s2i_ASN1_INTEGER(NULL, value->value))) {
d299 2
a300 1
STACK_OF(CONF_VALUE) *X509V3_parse_list(const char *line)
d307 1
d312 1
d314 2
a315 1
	for(p = linebuf, q = linebuf; (c = *p) && (c!='\r') && (c!='\n'); p++) {
d317 3
a319 3
		switch(state) {
			case HDR_NAME:
			if(c == ':') {
d323 3
a325 2
				if(!ntmp) {
					X509V3err(X509V3_F_X509V3_PARSE_LIST, X509V3_R_INVALID_NULL_NAME);
d329 1
a329 1
			} else if(c == ',') {
d336 3
a338 2
				if(!ntmp) {
					X509V3err(X509V3_F_X509V3_PARSE_LIST, X509V3_R_INVALID_NULL_NAME);
d343 1
a343 1
			break ;
d345 2
a346 2
			case HDR_VALUE:
			if(c == ',') {
d353 3
a355 2
				if(!vtmp) {
					X509V3err(X509V3_F_X509V3_PARSE_LIST, X509V3_R_INVALID_NULL_VALUE);
d366 1
a366 1
	if(state == HDR_VALUE) {
d371 3
a373 2
		if(!vtmp) {
			X509V3err(X509V3_F_X509V3_PARSE_LIST, X509V3_R_INVALID_NULL_VALUE);
d382 3
a384 2
		if(!ntmp) {
			X509V3err(X509V3_F_X509V3_PARSE_LIST, X509V3_R_INVALID_NULL_NAME);
d389 2
a390 2
free(linebuf);
return values;
d393 3
a395 3
free(linebuf);
sk_CONF_VALUE_pop_free(values, X509V3_conf_free);
return NULL;
d400 2
a401 1
static char *strip_spaces(char *name)
d404 1
d407 4
a410 2
	while(*p && isspace((unsigned char)*p)) p++;
	if(!*p) return NULL;
d412 6
a417 3
	while((q != p) && isspace((unsigned char)*q)) q--;
	if(p != q) q[1] = 0;
	if(!*p) return NULL;
d428 2
a429 1
char *hex_to_string(const unsigned char *buffer, long len)
d435 5
a439 3
	if(!buffer || !len) return NULL;
	if(!(tmp = malloc(len * 3 + 1))) {
		X509V3err(X509V3_F_HEX_TO_STRING,ERR_R_MALLOC_FAILURE);
d443 1
a443 1
	for(i = 0, p = buffer; i < len; i++,p++) {
d456 2
a457 1
unsigned char *string_to_hex(const char *str, long *len)
d461 3
a463 2
	if(!str) {
		X509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_INVALID_NULL_ARGUMENT);
d466 3
a468 2
	if(!(hexbuf = malloc(strlen(str) >> 1))) goto err;
	for(p = (unsigned char *)str, q = hexbuf; *p;) {
d470 2
a471 1
		if(ch == ':') continue;
d473 3
a475 2
		if(!cl) {
			X509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_ODD_NUMBER_OF_DIGITS);
d479 11
a489 2
		if(isupper(ch)) ch = tolower(ch);
		if(isupper(cl)) cl = tolower(cl);
d491 6
a496 7
		if((ch >= '0') && (ch <= '9')) ch -= '0';
		else if ((ch >= 'a') && (ch <= 'f')) ch -= 'a' - 10;
		else goto badhex;

		if((cl >= '0') && (cl <= '9')) cl -= '0';
		else if ((cl >= 'a') && (cl <= 'f')) cl -= 'a' - 10;
		else goto badhex;
d501 2
a502 1
	if(len) *len = q - hexbuf;
d506 1
a506 1
	err:
d508 1
a508 1
	X509V3err(X509V3_F_STRING_TO_HEX,ERR_R_MALLOC_FAILURE);
d511 1
a511 1
	badhex:
d513 1
a513 1
	X509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_ILLEGAL_HEX_DIGIT);
a514 1

d521 2
a522 1
int name_cmp(const char *name, const char *cmp)
d526 1
d528 2
a529 1
	if((ret = strncmp(name, cmp, len))) return ret;
d531 2
a532 1
	if(!c || (c=='.')) return 0;
d536 2
a537 1
static int sk_strcmp(const char * const *a, const char * const *b)
d562 1
a562 2
	for (i = 0; i < sk_ACCESS_DESCRIPTION_num(info); i++)
		{
d564 4
a567 5
		if (OBJ_obj2nid(ad->method) == NID_ad_OCSP)
			{
			if (ad->location->type == GEN_URI)
				{
				if (!append_ia5(&ret, ad->location->d.uniformResourceIdentifier))
a568 1
				}
d571 1
d591 2
a592 1
static STACK_OF(OPENSSL_STRING) *get_email(X509_NAME *name, GENERAL_NAMES *gens)
d599 1
d602 1
d604 2
a605 2
	while((i = X509_NAME_get_index_by_NID(name,
					 NID_pkcs9_emailAddress, i)) >= 0) {
d608 2
a609 1
		if(!append_ia5(&ret, email)) return NULL;
d611 1
a611 2
	for(i = 0; i < sk_GENERAL_NAME_num(gens); i++)
	{
d613 4
a616 2
		if(gen->type != GEN_EMAIL) continue;
		if(!append_ia5(&ret, gen->d.ia5)) return NULL;
d621 2
a622 1
static void str_free(OPENSSL_STRING str)
d627 2
a628 1
static int append_ia5(STACK_OF(OPENSSL_STRING) **sk, ASN1_IA5STRING *email)
d631 1
d633 8
a640 4
	if(email->type != V_ASN1_IA5STRING) return 1;
	if(!email->data || !email->length) return 1;
	if(!*sk) *sk = sk_OPENSSL_STRING_new(sk_strcmp);
	if(!*sk) return 0;
d642 2
a643 1
	if(sk_OPENSSL_STRING_find(*sk, (char *)email->data) != -1) return 1;
d645 1
a645 1
	if(!emtmp || !sk_OPENSSL_STRING_push(*sk, emtmp)) {
d653 2
a654 1
void X509_email_free(STACK_OF(OPENSSL_STRING) *sk)
d659 1
a659 1
/* Convert IP addresses both IPv4 and IPv6 into an 
d663 3
a665 2
ASN1_OCTET_STRING *a2i_IPADDRESS(const char *ipasc)
	{
d680 1
a680 2
	if (!ASN1_OCTET_STRING_set(ret, ipout, iplen))
		{
d683 1
a683 1
		}
d685 1
a685 1
	}
d687 3
a689 2
ASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc)
	{
d694 2
a695 1
	p = strchr(ipasc,'/');
d725 1
a725 1
	err:
d730 2
a731 2
	}
	
d733 3
a735 2
int a2i_ipadd(unsigned char *ipout, const char *ipasc)
	{
d738 1
a738 2
	if (strchr(ipasc, ':'))
		{
d742 1
a742 3
		}
	else
		{
a745 1
		}
d747 1
d749 3
a751 2
static int ipv4_from_asc(unsigned char *v4, const char *in)
	{
d755 2
a756 2
	if ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255)
		|| (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))
d763 1
a763 1
	}
d766 9
a774 9
		/* Temporary store for IPV6 output */
		unsigned char tmp[16];
		/* Total number of bytes in tmp */
		int total;
		/* The position of a zero (corresponding to '::') */
		int zero_pos;
		/* Number of zeroes */
		int zero_cnt;
	} IPV6_STAT;
d777 3
a779 2
static int ipv6_from_asc(unsigned char *v6, const char *in)
	{
d781 1
d785 1
d795 1
a795 2
	if (v6stat.zero_pos == -1)
		{
d799 1
a799 3
		}
	else 
		{
d807 1
a807 2
		else if (v6stat.zero_cnt == 3)
			{
d810 1
a810 1
			}
d812 3
a814 4
		else if (v6stat.zero_cnt == 2)
			{
			if ((v6stat.zero_pos != 0)
				&& (v6stat.zero_pos != v6stat.total))
d816 5
a820 6
			}
		else 
		/* Can only have one zero if *not* start or end */
			{
			if ((v6stat.zero_pos == 0)
				|| (v6stat.zero_pos == v6stat.total))
a821 1
			}
d823 1
d827 1
a827 2
	if (v6stat.zero_pos >= 0)
		{
d835 3
a837 4
				v6stat.tmp + v6stat.zero_pos,
				v6stat.total - v6stat.zero_pos);
		}
	else
d841 1
a841 1
	}
d843 3
a845 2
static int ipv6_cb(const char *elem, int len, void *usr)
	{
d847 1
d851 1
a851 2
	if (len == 0)
		{
d859 1
a859 3
		}
	else 
		{
d861 1
a861 2
		if (len > 4)
			{
d871 1
a871 3
			}
		else
			{
a874 1
			}
d876 1
d878 1
a878 1
	}
d884 3
a886 2
static int ipv6_hex(unsigned char *out, const char *in, int inlen)
	{
d889 1
d892 1
a892 2
	while(inlen--)
		{
d903 1
a903 1
		}
d907 1
a907 1
	}
d909 4
a912 4

int X509V3_NAME_from_section(X509_NAME *nm, STACK_OF(CONF_VALUE)*dn_sk,
						unsigned long chtype)
	{
d916 1
d920 3
a922 4
	for (i = 0; i < sk_CONF_VALUE_num(dn_sk); i++)
		{
		v=sk_CONF_VALUE_value(dn_sk,i);
		type=v->name;
d924 1
a924 1
		 * multiple instances 
d926 2
a927 3
		for(p = type; *p ; p++) 
			if ((*p == ':') || (*p == ',') || (*p == '.'))
				{
d929 2
a930 1
				if(*p) type = p;
d932 2
a933 3
				}
		if (*type == '+')
			{
d936 1
a936 2
			}
		else
d938 4
a941 5
		if (!X509_NAME_add_entry_by_txt(nm,type, chtype,
				(unsigned char *) v->value,-1,-1,mval))
					return 0;

		}
d943 1
a943 1
	}
@


1.14
log
@Put explicit (void) in function declarations and shuffle keywords in some
declaration to pass -Wextra, should we want to add it to CFLAGS.
No binary change.
@
text
@d425 1
a425 1
	if(hexbuf) free(hexbuf);
d626 1
a626 2
	if (iptmp)
		free(iptmp);
@


1.13
log
@no need for malloc casts
@
text
@d368 1
a368 1
	const static char hexdig[] = "0123456789ABCDEF";
@


1.12
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d88 1
a88 1
	if(!(vtmp = (CONF_VALUE *)malloc(sizeof(CONF_VALUE)))) goto err;
@


1.11
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@d88 1
a88 1
	if(!(vtmp = (CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE)))) goto err;
d97 3
a99 3
	if(vtmp) OPENSSL_free(vtmp);
	if(tname) OPENSSL_free(tname);
	if(tvalue) OPENSSL_free(tvalue);
d114 4
a117 4
	if(conf->name) OPENSSL_free(conf->name);
	if(conf->value) OPENSSL_free(conf->value);
	if(conf->section) OPENSSL_free(conf->section);
	OPENSSL_free(conf);
d209 1
a209 1
	OPENSSL_free(strtmp);
d331 1
a331 1
OPENSSL_free(linebuf);
d335 1
a335 1
OPENSSL_free(linebuf);
d358 1
a358 1
/* Given a buffer of length 'len' return a OPENSSL_malloc'ed string with its
d370 1
a370 1
	if(!(tmp = OPENSSL_malloc(len * 3 + 1))) {
d396 1
a396 1
	if(!(hexbuf = OPENSSL_malloc(strlen(str) >> 1))) goto err;
d403 1
a403 1
			OPENSSL_free(hexbuf);
d425 1
a425 1
	if(hexbuf) OPENSSL_free(hexbuf);
d430 1
a430 1
	OPENSSL_free(hexbuf);
d534 1
a534 1
	OPENSSL_free(str);
d611 1
a611 1
	OPENSSL_free(iptmp);
d627 1
a627 1
		OPENSSL_free(iptmp);
@


1.10
log
@resolve conflicts, fix local changes
@
text
@a380 4
#ifdef CHARSET_EBCDIC
	ebcdic2ascii(tmp, tmp, q - tmp - 1);
#endif

a398 3
#ifdef CHARSET_EBCDIC
		ch = os_toebcdic[ch];
#endif
a400 3
#ifdef CHARSET_EBCDIC
		cl = os_toebcdic[cl];
#endif
a836 1
#ifndef CHARSET_EBCDIC
a837 3
#else
			if ((*p == os_toascii[':']) || (*p == os_toascii[',']) || (*p == os_toascii['.']))
#endif
a842 1
#ifndef CHARSET_EBCDIC
a843 3
#else
		if (*type == os_toascii['+'])
#endif
@


1.9
log
@resolve conflicts
@
text
@d70 3
a72 3
static STACK *get_email(X509_NAME *name, GENERAL_NAMES *gens);
static void str_free(void *str);
static int append_ia5(STACK **sk, ASN1_IA5STRING *email);
d347 1
a347 1
	while(isspace((unsigned char)*p)) p++;
d363 1
a363 1
char *hex_to_string(unsigned char *buffer, long len)
d366 1
a366 1
	unsigned char *p;
d392 1
a392 1
unsigned char *string_to_hex(char *str, long *len)
d466 1
a466 1
STACK *X509_get1_email(X509 *x)
d469 2
a470 1
	STACK *ret;
d477 1
a477 1
STACK *X509_get1_ocsp(X509 *x)
d480 1
a480 1
	STACK *ret = NULL;
d482 1
d502 1
a502 1
STACK *X509_REQ_get1_email(X509_REQ *x)
d506 2
a507 1
	STACK *ret;
d517 1
a517 1
static STACK *get_email(X509_NAME *name, GENERAL_NAMES *gens)
d519 1
a519 1
	STACK *ret = NULL;
d542 1
a542 1
static void str_free(void *str)
d547 1
a547 1
static int append_ia5(STACK **sk, ASN1_IA5STRING *email)
d553 1
a553 1
	if(!*sk) *sk = sk_new(sk_strcmp);
d556 1
a556 1
	if(sk_find(*sk, (char *)email->data) != -1) return 1;
d558 1
a558 1
	if(!emtmp || !sk_push(*sk, emtmp)) {
d566 1
a566 1
void X509_email_free(STACK *sk)
d568 1
a568 1
	sk_pop_free(sk, str_free);
@


1.8
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
d739 3
a741 2
	/* Copy initial part */
	if (v6stat.zero_pos > 0)
d743 1
a743 2
	/* Zero middle */
	if (v6stat.total != 16)
d745 8
a752 5
	/* Copy final part */
	if (v6stat.total != v6stat.zero_pos)
		memcpy(v6 + v6stat.zero_pos + 16 - v6stat.total,
			v6stat.tmp + v6stat.zero_pos,
			v6stat.total - v6stat.zero_pos);
@


1.7
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d3 1
a3 1
 * project 1999.
d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d66 1
d74 5
a164 1
	bn = BN_new();
d169 1
d183 2
a184 1
	if (!ret) {
d368 1
a368 1
	static char hexdig[] = "0123456789ABCDEF";
d476 24
d567 302
@


1.6
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d340 1
a340 1
	while(*p && isspace((unsigned char)*p)) p++;
@


1.5
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d81 1
a81 1
	if(value && !(tvalue = BUF_strdup(value))) goto err;;
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d494 1
a494 1
					 NID_pkcs9_emailAddress, i)) > 0) {
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d69 1
a69 1
static STACK *get_email(X509_NAME *name, STACK_OF(GENERAL_NAME) *gens);
d157 2
d160 1
a160 1
	if(!value) {
d164 14
a177 1
	if(!BN_dec2bn(&bn, value)) {
d182 5
a186 1
	if(!(aint = BN_to_ASN1_INTEGER(bn, NULL))) {
d190 1
a190 1
	BN_free(bn);
d243 1
a243 1
STACK_OF(CONF_VALUE) *X509V3_parse_list(char *line)
d272 1
a272 1
#ifdef DEBUG
d288 1
a288 1
#ifdef DEBUG
d305 1
a305 1
#ifdef DEBUG
d315 1
a315 1
#ifdef DEBUG
d461 1
a461 1
	STACK_OF(GENERAL_NAME) *gens;
d471 1
a471 1
	STACK_OF(GENERAL_NAME) *gens;
d483 1
a483 1
static STACK *get_email(X509_NAME *name, STACK_OF(GENERAL_NAME) *gens)
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d68 4
d82 2
a83 2
	if(!(vtmp = (CONF_VALUE *)Malloc(sizeof(CONF_VALUE)))) goto err;
	if(!*extlist && !(*extlist = sk_CONF_VALUE_new(NULL))) goto err;
d91 3
a93 3
	if(vtmp) Free(vtmp);
	if(tname) Free(tname);
	if(tvalue) Free(tvalue);
d108 4
a111 4
	if(conf->name) Free(conf->name);
	if(conf->value) Free(conf->value);
	if(conf->section) Free(conf->section);
	Free(conf);
d183 1
a183 1
	Free(strtmp);
d305 1
a305 1
Free(linebuf);
d309 1
a309 1
Free(linebuf);
d332 1
a332 1
/* Given a buffer of length 'len' return a Malloc'ed string with its
d334 1
d344 1
a344 1
	if(!(tmp = Malloc(len * 3 + 1))) {
d355 4
d374 1
a374 1
	if(!(hexbuf = Malloc(strlen(str) >> 1))) goto err;
d377 3
d382 3
d387 1
a387 1
			Free(hexbuf);
d409 1
a409 1
	if(hexbuf) Free(hexbuf);
d414 1
a414 1
	Free(hexbuf);
d433 83
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d107 1
a107 1
	Free((char *)conf);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a67 4
static int sk_strcmp(const char * const *a, const char * const *b);
static STACK *get_email(X509_NAME *name, GENERAL_NAMES *gens);
static void str_free(void *str);
static int append_ia5(STACK **sk, ASN1_IA5STRING *email);
d78 2
a79 2
	if(!(vtmp = (CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE)))) goto err;
	if(!*extlist && !(*extlist = sk_CONF_VALUE_new_null())) goto err;
d87 3
a89 3
	if(vtmp) OPENSSL_free(vtmp);
	if(tname) OPENSSL_free(tname);
	if(tvalue) OPENSSL_free(tvalue);
d104 4
a107 4
	if(conf->name) OPENSSL_free(conf->name);
	if(conf->value) OPENSSL_free(conf->value);
	if(conf->section) OPENSSL_free(conf->section);
	OPENSSL_free(conf);
a152 2
	int isneg, ishex;
	int ret;
d154 1
a154 1
	if (!value) {
d158 1
a158 14
	if (value[0] == '-') {
		value++;
		isneg = 1;
	} else isneg = 0;

	if (value[0] == '0' && ((value[1] == 'x') || (value[1] == 'X'))) {
		value += 2;
		ishex = 1;
	} else ishex = 0;

	if (ishex) ret = BN_hex2bn(&bn, value);
	else ret = BN_dec2bn(&bn, value);

	if (!ret) {
d163 1
a163 5
	if (isneg && BN_is_zero(bn)) isneg = 0;

	aint = BN_to_ASN1_INTEGER(bn, NULL);
	BN_free(bn);
	if (!aint) {
d167 1
a167 1
	if (isneg) aint->type |= V_ASN1_NEG;
d179 1
a179 1
	OPENSSL_free(strtmp);
d220 1
a220 1
STACK_OF(CONF_VALUE) *X509V3_parse_list(const char *line)
d249 1
a249 1
#if 0
d265 1
a265 1
#if 0
d282 1
a282 1
#if 0
d292 1
a292 1
#if 0
d301 1
a301 1
OPENSSL_free(linebuf);
d305 1
a305 1
OPENSSL_free(linebuf);
d328 1
a328 1
/* Given a buffer of length 'len' return a OPENSSL_malloc'ed string with its
a329 1
 * @@@@@@ (Contents of buffer are always kept in ASCII, also on EBCDIC machines)
d339 1
a339 1
	if(!(tmp = OPENSSL_malloc(len * 3 + 1))) {
a349 4
#ifdef CHARSET_EBCDIC
	ebcdic2ascii(tmp, tmp, q - tmp - 1);
#endif

d365 1
a365 1
	if(!(hexbuf = OPENSSL_malloc(strlen(str) >> 1))) goto err;
a367 3
#ifdef CHARSET_EBCDIC
		ch = os_toebcdic[ch];
#endif
a369 3
#ifdef CHARSET_EBCDIC
		cl = os_toebcdic[cl];
#endif
d372 1
a372 1
			OPENSSL_free(hexbuf);
d394 1
a394 1
	if(hexbuf) OPENSSL_free(hexbuf);
d399 1
a399 1
	OPENSSL_free(hexbuf);
a417 83
}

static int sk_strcmp(const char * const *a, const char * const *b)
{
	return strcmp(*a, *b);
}

STACK *X509_get1_email(X509 *x)
{
	GENERAL_NAMES *gens;
	STACK *ret;
	gens = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);
	ret = get_email(X509_get_subject_name(x), gens);
	sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
	return ret;
}

STACK *X509_REQ_get1_email(X509_REQ *x)
{
	GENERAL_NAMES *gens;
	STACK_OF(X509_EXTENSION) *exts;
	STACK *ret;
	exts = X509_REQ_get_extensions(x);
	gens = X509V3_get_d2i(exts, NID_subject_alt_name, NULL, NULL);
	ret = get_email(X509_REQ_get_subject_name(x), gens);
	sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);
	sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);
	return ret;
}


static STACK *get_email(X509_NAME *name, GENERAL_NAMES *gens)
{
	STACK *ret = NULL;
	X509_NAME_ENTRY *ne;
	ASN1_IA5STRING *email;
	GENERAL_NAME *gen;
	int i;
	/* Now add any email address(es) to STACK */
	i = -1;
	/* First supplied X509_NAME */
	while((i = X509_NAME_get_index_by_NID(name,
					 NID_pkcs9_emailAddress, i)) > 0) {
		ne = X509_NAME_get_entry(name, i);
		email = X509_NAME_ENTRY_get_data(ne);
		if(!append_ia5(&ret, email)) return NULL;
	}
	for(i = 0; i < sk_GENERAL_NAME_num(gens); i++)
	{
		gen = sk_GENERAL_NAME_value(gens, i);
		if(gen->type != GEN_EMAIL) continue;
		if(!append_ia5(&ret, gen->d.ia5)) return NULL;
	}
	return ret;
}

static void str_free(void *str)
{
	OPENSSL_free(str);
}

static int append_ia5(STACK **sk, ASN1_IA5STRING *email)
{
	char *emtmp;
	/* First some sanity checks */
	if(email->type != V_ASN1_IA5STRING) return 1;
	if(!email->data || !email->length) return 1;
	if(!*sk) *sk = sk_new(sk_strcmp);
	if(!*sk) return 0;
	/* Don't add duplicates */
	if(sk_find(*sk, (char *)email->data) != -1) return 1;
	emtmp = BUF_strdup((char *)email->data);
	if(!emtmp || !sk_push(*sk, emtmp)) {
		X509_email_free(*sk);
		*sk = NULL;
		return 0;
	}
	return 1;
}

void X509_email_free(STACK *sk)
{
	sk_pop_free(sk, str_free);
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d494 1
a494 1
					 NID_pkcs9_emailAddress, i)) >= 0) {
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d3 1
a3 1
 * project.
d6 1
a6 1
 * Copyright (c) 1999-2003 The OpenSSL Project.  All rights reserved.
a65 1
#include <openssl/bn.h>
a72 5
static int ipv4_from_asc(unsigned char *v4, const char *in);
static int ipv6_from_asc(unsigned char *v6, const char *in);
static int ipv6_cb(const char *elem, int len, void *usr);
static int ipv6_hex(unsigned char *out, const char *in, int inlen);

d159 1
a163 1
	bn = BN_new();
d177 1
a177 2
	if (!ret || value[ret]) {
		BN_free(bn);
d361 1
a361 1
	const static char hexdig[] = "0123456789ABCDEF";
a468 24
STACK *X509_get1_ocsp(X509 *x)
{
	AUTHORITY_INFO_ACCESS *info;
	STACK *ret = NULL;
	int i;
	info = X509_get_ext_d2i(x, NID_info_access, NULL, NULL);
	if (!info)
		return NULL;
	for (i = 0; i < sk_ACCESS_DESCRIPTION_num(info); i++)
		{
		ACCESS_DESCRIPTION *ad = sk_ACCESS_DESCRIPTION_value(info, i);
		if (OBJ_obj2nid(ad->method) == NID_ad_OCSP)
			{
			if (ad->location->type == GEN_URI)
				{
				if (!append_ia5(&ret, ad->location->d.uniformResourceIdentifier))
					break;
				}
			}
		}
	AUTHORITY_INFO_ACCESS_free(info);
	return ret;
}

a535 302

/* Convert IP addresses both IPv4 and IPv6 into an 
 * OCTET STRING compatible with RFC3280.
 */

ASN1_OCTET_STRING *a2i_IPADDRESS(const char *ipasc)
	{
	unsigned char ipout[16];
	ASN1_OCTET_STRING *ret;
	int iplen;

	/* If string contains a ':' assume IPv6 */

	iplen = a2i_ipadd(ipout, ipasc);

	if (!iplen)
		return NULL;

	ret = ASN1_OCTET_STRING_new();
	if (!ret)
		return NULL;
	if (!ASN1_OCTET_STRING_set(ret, ipout, iplen))
		{
		ASN1_OCTET_STRING_free(ret);
		return NULL;
		}
	return ret;
	}

ASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc)
	{
	ASN1_OCTET_STRING *ret = NULL;
	unsigned char ipout[32];
	char *iptmp = NULL, *p;
	int iplen1, iplen2;
	p = strchr(ipasc,'/');
	if (!p)
		return NULL;
	iptmp = BUF_strdup(ipasc);
	if (!iptmp)
		return NULL;
	p = iptmp + (p - ipasc);
	*p++ = 0;

	iplen1 = a2i_ipadd(ipout, iptmp);

	if (!iplen1)
		goto err;

	iplen2 = a2i_ipadd(ipout + iplen1, p);

	OPENSSL_free(iptmp);
	iptmp = NULL;

	if (!iplen2 || (iplen1 != iplen2))
		goto err;

	ret = ASN1_OCTET_STRING_new();
	if (!ret)
		goto err;
	if (!ASN1_OCTET_STRING_set(ret, ipout, iplen1 + iplen2))
		goto err;

	return ret;

	err:
	if (iptmp)
		OPENSSL_free(iptmp);
	if (ret)
		ASN1_OCTET_STRING_free(ret);
	return NULL;
	}
	

int a2i_ipadd(unsigned char *ipout, const char *ipasc)
	{
	/* If string contains a ':' assume IPv6 */

	if (strchr(ipasc, ':'))
		{
		if (!ipv6_from_asc(ipout, ipasc))
			return 0;
		return 16;
		}
	else
		{
		if (!ipv4_from_asc(ipout, ipasc))
			return 0;
		return 4;
		}
	}

static int ipv4_from_asc(unsigned char *v4, const char *in)
	{
	int a0, a1, a2, a3;
	if (sscanf(in, "%d.%d.%d.%d", &a0, &a1, &a2, &a3) != 4)
		return 0;
	if ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255)
		|| (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))
		return 0;
	v4[0] = a0;
	v4[1] = a1;
	v4[2] = a2;
	v4[3] = a3;
	return 1;
	}

typedef struct {
		/* Temporary store for IPV6 output */
		unsigned char tmp[16];
		/* Total number of bytes in tmp */
		int total;
		/* The position of a zero (corresponding to '::') */
		int zero_pos;
		/* Number of zeroes */
		int zero_cnt;
	} IPV6_STAT;


static int ipv6_from_asc(unsigned char *v6, const char *in)
	{
	IPV6_STAT v6stat;
	v6stat.total = 0;
	v6stat.zero_pos = -1;
	v6stat.zero_cnt = 0;
	/* Treat the IPv6 representation as a list of values
	 * separated by ':'. The presence of a '::' will parse
 	 * as one, two or three zero length elements.
	 */
	if (!CONF_parse_list(in, ':', 0, ipv6_cb, &v6stat))
		return 0;

	/* Now for some sanity checks */

	if (v6stat.zero_pos == -1)
		{
		/* If no '::' must have exactly 16 bytes */
		if (v6stat.total != 16)
			return 0;
		}
	else 
		{
		/* If '::' must have less than 16 bytes */
		if (v6stat.total == 16)
			return 0;
		/* More than three zeroes is an error */
		if (v6stat.zero_cnt > 3)
			return 0;
		/* Can only have three zeroes if nothing else present */
		else if (v6stat.zero_cnt == 3)
			{
			if (v6stat.total > 0)
				return 0;
			}
		/* Can only have two zeroes if at start or end */
		else if (v6stat.zero_cnt == 2)
			{
			if ((v6stat.zero_pos != 0)
				&& (v6stat.zero_pos != v6stat.total))
				return 0;
			}
		else 
		/* Can only have one zero if *not* start or end */
			{
			if ((v6stat.zero_pos == 0)
				|| (v6stat.zero_pos == v6stat.total))
				return 0;
			}
		}

	/* Format result */

	/* Copy initial part */
	if (v6stat.zero_pos > 0)
		memcpy(v6, v6stat.tmp, v6stat.zero_pos);
	/* Zero middle */
	if (v6stat.total != 16)
		memset(v6 + v6stat.zero_pos, 0, 16 - v6stat.total);
	/* Copy final part */
	if (v6stat.total != v6stat.zero_pos)
		memcpy(v6 + v6stat.zero_pos + 16 - v6stat.total,
			v6stat.tmp + v6stat.zero_pos,
			v6stat.total - v6stat.zero_pos);

	return 1;
	}

static int ipv6_cb(const char *elem, int len, void *usr)
	{
	IPV6_STAT *s = usr;
	/* Error if 16 bytes written */
	if (s->total == 16)
		return 0;
	if (len == 0)
		{
		/* Zero length element, corresponds to '::' */
		if (s->zero_pos == -1)
			s->zero_pos = s->total;
		/* If we've already got a :: its an error */
		else if (s->zero_pos != s->total)
			return 0;
		s->zero_cnt++;
		}
	else 
		{
		/* If more than 4 characters could be final a.b.c.d form */
		if (len > 4)
			{
			/* Need at least 4 bytes left */
			if (s->total > 12)
				return 0;
			/* Must be end of string */
			if (elem[len])
				return 0;
			if (!ipv4_from_asc(s->tmp + s->total, elem))
				return 0;
			s->total += 4;
			}
		else
			{
			if (!ipv6_hex(s->tmp + s->total, elem, len))
				return 0;
			s->total += 2;
			}
		}
	return 1;
	}

/* Convert a string of up to 4 hex digits into the corresponding
 * IPv6 form.
 */

static int ipv6_hex(unsigned char *out, const char *in, int inlen)
	{
	unsigned char c;
	unsigned int num = 0;
	if (inlen > 4)
		return 0;
	while(inlen--)
		{
		c = *in++;
		num <<= 4;
		if ((c >= '0') && (c <= '9'))
			num |= c - '0';
		else if ((c >= 'A') && (c <= 'F'))
			num |= c - 'A' + 10;
		else if ((c >= 'a') && (c <= 'f'))
			num |=  c - 'a' + 10;
		else
			return 0;
		}
	out[0] = num >> 8;
	out[1] = num & 0xff;
	return 1;
	}


int X509V3_NAME_from_section(X509_NAME *nm, STACK_OF(CONF_VALUE)*dn_sk,
						unsigned long chtype)
	{
	CONF_VALUE *v;
	int i, mval;
	char *p, *type;
	if (!nm)
		return 0;

	for (i = 0; i < sk_CONF_VALUE_num(dn_sk); i++)
		{
		v=sk_CONF_VALUE_value(dn_sk,i);
		type=v->name;
		/* Skip past any leading X. X: X, etc to allow for
		 * multiple instances 
		 */
		for(p = type; *p ; p++) 
#ifndef CHARSET_EBCDIC
			if ((*p == ':') || (*p == ',') || (*p == '.'))
#else
			if ((*p == os_toascii[':']) || (*p == os_toascii[',']) || (*p == os_toascii['.']))
#endif
				{
				p++;
				if(*p) type = p;
				break;
				}
#ifndef CHARSET_EBCDIC
		if (*type == '+')
#else
		if (*type == os_toascii['+'])
#endif
			{
			mval = -1;
			type++;
			}
		else
			mval = 0;
		if (!X509_NAME_add_entry_by_txt(nm,type, chtype,
				(unsigned char *) v->value,-1,-1,mval))
					return 0;

		}
	return 1;
	}
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
d739 2
a740 3
	if (v6stat.zero_pos >= 0)
		{
		/* Copy initial part */
d742 2
a743 1
		/* Zero middle */
d745 5
a749 8
		/* Copy final part */
		if (v6stat.total != v6stat.zero_pos)
			memcpy(v6 + v6stat.zero_pos + 16 - v6stat.total,
				v6stat.tmp + v6stat.zero_pos,
				v6stat.total - v6stat.zero_pos);
		}
	else
		memcpy(v6, v6stat.tmp, 16);
@


1.1.1.5
log
@import of OpenSSL 0.9.8k
@
text
@d87 1
a87 1
	if(value && !(tvalue = BUF_strdup(value))) goto err;
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d70 3
a72 3
static STACK_OF(OPENSSL_STRING) *get_email(X509_NAME *name, GENERAL_NAMES *gens);
static void str_free(OPENSSL_STRING str);
static int append_ia5(STACK_OF(OPENSSL_STRING) **sk, ASN1_IA5STRING *email);
d363 1
a363 1
char *hex_to_string(const unsigned char *buffer, long len)
d366 1
a366 1
	const unsigned char *p;
d392 1
a392 1
unsigned char *string_to_hex(const char *str, long *len)
d466 1
a466 1
STACK_OF(OPENSSL_STRING) *X509_get1_email(X509 *x)
d469 1
a469 2
	STACK_OF(OPENSSL_STRING) *ret;

d476 1
a476 1
STACK_OF(OPENSSL_STRING) *X509_get1_ocsp(X509 *x)
d479 1
a479 1
	STACK_OF(OPENSSL_STRING) *ret = NULL;
a480 1

d500 1
a500 1
STACK_OF(OPENSSL_STRING) *X509_REQ_get1_email(X509_REQ *x)
d504 1
a504 2
	STACK_OF(OPENSSL_STRING) *ret;

d514 1
a514 1
static STACK_OF(OPENSSL_STRING) *get_email(X509_NAME *name, GENERAL_NAMES *gens)
d516 1
a516 1
	STACK_OF(OPENSSL_STRING) *ret = NULL;
d539 1
a539 1
static void str_free(OPENSSL_STRING str)
d544 1
a544 1
static int append_ia5(STACK_OF(OPENSSL_STRING) **sk, ASN1_IA5STRING *email)
d550 1
a550 1
	if(!*sk) *sk = sk_OPENSSL_STRING_new(sk_strcmp);
d553 1
a553 1
	if(sk_OPENSSL_STRING_find(*sk, (char *)email->data) != -1) return 1;
d555 1
a555 1
	if(!emtmp || !sk_OPENSSL_STRING_push(*sk, emtmp)) {
d563 1
a563 1
void X509_email_free(STACK_OF(OPENSSL_STRING) *sk)
d565 1
a565 1
	sk_OPENSSL_STRING_pop_free(sk, str_free);
@


