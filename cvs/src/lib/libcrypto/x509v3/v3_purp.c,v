head	1.29;
access;
symbols
	OPENBSD_6_1_BASE:1.29;
locks; strict;
comment	@ * @;


1.29
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.28;
commitid	kT0fLt3r4lroFJra;

1.28
date	2017.01.21.04.42.16;	author jsing;	state Exp;
branches;
next	1.27;
commitid	cj6ZwEZdOgoZ48c9;

1.27
date	2016.11.08.20.01.06;	author miod;	state Exp;
branches;
next	1.26;
commitid	XlGKrVG93X98CAkl;

1.26
date	2015.02.10.13.28.17;	author jsing;	state Exp;
branches;
next	1.25;
commitid	b6QwIkxyvUWeF5XG;

1.25
date	2015.02.10.11.22.22;	author jsing;	state Exp;
branches;
next	1.24;
commitid	LaAI4ax0sm4T2bQg;

1.24
date	2014.12.06.19.26.37;	author doug;	state Exp;
branches;
next	1.23;
commitid	9GO7rmvzRwFf0a5J;

1.23
date	2014.10.05.18.33.57;	author miod;	state Exp;
branches;
next	1.22;
commitid	bup3dhsJSsJKGnQG;

1.22
date	2014.07.13.16.03.10;	author beck;	state Exp;
branches;
next	1.21;
commitid	6xdvCwSqBadTW6X3;

1.21
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.20;
commitid	yQEL1wOWIearrW15;

1.20
date	2014.07.10.22.45.58;	author jsing;	state Exp;
branches;
next	1.19;
commitid	nzndm3zqPmFurSaK;

1.19
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.18;
commitid	id8dTrTMtnTn4fqt;

1.18
date	2014.06.28.18.14.57;	author logan;	state Exp;
branches;
next	1.17;
commitid	EDDMGJA9QOLgVFRr;

1.17
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	mJUVYpkFBZ0Zv2bG;

1.16
date	2014.05.26.12.10.11;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.09.18.20;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.27;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.12.02.18.39;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.22.00.03.22;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.18;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.15.06.18.46;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.12.20;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.03;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.55;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.20.41.54;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.04.29.05.37.18;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.01.09.12.14.01;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.12;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.04.13.15.16.35;	author miod;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: v3_purp.c,v 1.28 2017/01/21 04:42:16 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2001.
 */
/* ====================================================================
 * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/err.h>
#include <openssl/x509v3.h>
#include <openssl/x509_vfy.h>

static void x509v3_cache_extensions(X509 *x);

static int check_ssl_ca(const X509 *x);
static int check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x,
    int ca);
static int check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x,
    int ca);
static int check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x,
    int ca);
static int purpose_smime(const X509 *x, int ca);
static int check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x,
    int ca);
static int check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x,
    int ca);
static int check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x,
    int ca);
static int check_purpose_timestamp_sign(const X509_PURPOSE *xp, const X509 *x,
    int ca);
static int no_check(const X509_PURPOSE *xp, const X509 *x, int ca);
static int ocsp_helper(const X509_PURPOSE *xp, const X509 *x, int ca);

static int xp_cmp(const X509_PURPOSE * const *a, const X509_PURPOSE * const *b);
static void xptable_free(X509_PURPOSE *p);

static X509_PURPOSE xstandard[] = {
	{X509_PURPOSE_SSL_CLIENT, X509_TRUST_SSL_CLIENT, 0, check_purpose_ssl_client, "SSL client", "sslclient", NULL},
	{X509_PURPOSE_SSL_SERVER, X509_TRUST_SSL_SERVER, 0, check_purpose_ssl_server, "SSL server", "sslserver", NULL},
	{X509_PURPOSE_NS_SSL_SERVER, X509_TRUST_SSL_SERVER, 0, check_purpose_ns_ssl_server, "Netscape SSL server", "nssslserver", NULL},
	{X509_PURPOSE_SMIME_SIGN, X509_TRUST_EMAIL, 0, check_purpose_smime_sign, "S/MIME signing", "smimesign", NULL},
	{X509_PURPOSE_SMIME_ENCRYPT, X509_TRUST_EMAIL, 0, check_purpose_smime_encrypt, "S/MIME encryption", "smimeencrypt", NULL},
	{X509_PURPOSE_CRL_SIGN, X509_TRUST_COMPAT, 0, check_purpose_crl_sign, "CRL signing", "crlsign", NULL},
	{X509_PURPOSE_ANY, X509_TRUST_DEFAULT, 0, no_check, "Any Purpose", "any", NULL},
	{X509_PURPOSE_OCSP_HELPER, X509_TRUST_COMPAT, 0, ocsp_helper, "OCSP helper", "ocsphelper", NULL},
	{X509_PURPOSE_TIMESTAMP_SIGN, X509_TRUST_TSA, 0, check_purpose_timestamp_sign, "Time Stamp signing", "timestampsign", NULL},
};

#define X509_PURPOSE_COUNT (sizeof(xstandard)/sizeof(X509_PURPOSE))

static STACK_OF(X509_PURPOSE) *xptable = NULL;

static int
xp_cmp(const X509_PURPOSE * const *a, const X509_PURPOSE * const *b)
{
	return (*a)->purpose - (*b)->purpose;
}

/* As much as I'd like to make X509_check_purpose use a "const" X509*
 * I really can't because it does recalculate hashes and do other non-const
 * things. */
int
X509_check_purpose(X509 *x, int id, int ca)
{
	int idx;
	const X509_PURPOSE *pt;

	if (!(x->ex_flags & EXFLAG_SET)) {
		CRYPTO_w_lock(CRYPTO_LOCK_X509);
		x509v3_cache_extensions(x);
		CRYPTO_w_unlock(CRYPTO_LOCK_X509);
	}
	if (id == -1)
		return 1;
	idx = X509_PURPOSE_get_by_id(id);
	if (idx == -1)
		return -1;
	pt = X509_PURPOSE_get0(idx);
	return pt->check_purpose(pt, x, ca);
}

int
X509_PURPOSE_set(int *p, int purpose)
{
	if (X509_PURPOSE_get_by_id(purpose) == -1) {
		X509V3error(X509V3_R_INVALID_PURPOSE);
		return 0;
	}
	*p = purpose;
	return 1;
}

int
X509_PURPOSE_get_count(void)
{
	if (!xptable)
		return X509_PURPOSE_COUNT;
	return sk_X509_PURPOSE_num(xptable) + X509_PURPOSE_COUNT;
}

X509_PURPOSE *
X509_PURPOSE_get0(int idx)
{
	if (idx < 0)
		return NULL;
	if (idx < (int)X509_PURPOSE_COUNT)
		return xstandard + idx;
	return sk_X509_PURPOSE_value(xptable, idx - X509_PURPOSE_COUNT);
}

int
X509_PURPOSE_get_by_sname(char *sname)
{
	int i;
	X509_PURPOSE *xptmp;

	for (i = 0; i < X509_PURPOSE_get_count(); i++) {
		xptmp = X509_PURPOSE_get0(i);
		if (!strcmp(xptmp->sname, sname))
			return i;
	}
	return -1;
}

int
X509_PURPOSE_get_by_id(int purpose)
{
	X509_PURPOSE tmp;
	int idx;

	if ((purpose >= X509_PURPOSE_MIN) && (purpose <= X509_PURPOSE_MAX))
		return purpose - X509_PURPOSE_MIN;
	tmp.purpose = purpose;
	if (!xptable)
		return -1;
	idx = sk_X509_PURPOSE_find(xptable, &tmp);
	if (idx == -1)
		return -1;
	return idx + X509_PURPOSE_COUNT;
}

int
X509_PURPOSE_add(int id, int trust, int flags,
    int (*ck)(const X509_PURPOSE *, const X509 *, int), char *name,
    char *sname, void *arg)
{
	int idx;
	X509_PURPOSE *ptmp;
	char *name_dup, *sname_dup;

	name_dup = sname_dup = NULL;

	if (name == NULL || sname == NULL) {
		X509V3error(X509V3_R_INVALID_NULL_ARGUMENT);
		return 0;
	}

	/* This is set according to what we change: application can't set it */
	flags &= ~X509_PURPOSE_DYNAMIC;
	/* This will always be set for application modified trust entries */
	flags |= X509_PURPOSE_DYNAMIC_NAME;
	/* Get existing entry if any */
	idx = X509_PURPOSE_get_by_id(id);
	/* Need a new entry */
	if (idx == -1) {
		if ((ptmp = malloc(sizeof(X509_PURPOSE))) == NULL) {
			X509V3error(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		ptmp->flags = X509_PURPOSE_DYNAMIC;
	} else
		ptmp = X509_PURPOSE_get0(idx);

	if ((name_dup = strdup(name)) == NULL)
		goto err;
	if ((sname_dup = strdup(sname)) == NULL)
		goto err;

	/* free existing name if dynamic */
	if (ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) {
		free(ptmp->name);
		free(ptmp->sname);
	}
	/* dup supplied name */
	ptmp->name = name_dup;
	ptmp->sname = sname_dup;
	/* Keep the dynamic flag of existing entry */
	ptmp->flags &= X509_PURPOSE_DYNAMIC;
	/* Set all other flags */
	ptmp->flags |= flags;

	ptmp->purpose = id;
	ptmp->trust = trust;
	ptmp->check_purpose = ck;
	ptmp->usr_data = arg;

	/* If its a new entry manage the dynamic table */
	if (idx == -1) {
		if (xptable == NULL &&
		    (xptable = sk_X509_PURPOSE_new(xp_cmp)) == NULL)
			goto err;
		if (sk_X509_PURPOSE_push(xptable, ptmp) == 0)
			goto err;
	}
	return 1;

err:
	free(name_dup);
	free(sname_dup);
	if (idx == -1)
		free(ptmp);
	X509V3error(ERR_R_MALLOC_FAILURE);
	return 0;
}

static void
xptable_free(X509_PURPOSE *p)
{
	if (!p)
		return;
	if (p->flags & X509_PURPOSE_DYNAMIC) {
		if (p->flags & X509_PURPOSE_DYNAMIC_NAME) {
			free(p->name);
			free(p->sname);
		}
		free(p);
	}
}

void
X509_PURPOSE_cleanup(void)
{
	unsigned int i;

	sk_X509_PURPOSE_pop_free(xptable, xptable_free);
	for(i = 0; i < X509_PURPOSE_COUNT; i++)
		xptable_free(xstandard + i);
	xptable = NULL;
}

int
X509_PURPOSE_get_id(X509_PURPOSE *xp)
{
	return xp->purpose;
}

char *
X509_PURPOSE_get0_name(X509_PURPOSE *xp)
{
	return xp->name;
}

char *
X509_PURPOSE_get0_sname(X509_PURPOSE *xp)
{
	return xp->sname;
}

int
X509_PURPOSE_get_trust(X509_PURPOSE *xp)
{
	return xp->trust;
}

static int
nid_cmp(const int *a, const int *b)
{
	return *a - *b;
}

static int nid_cmp_BSEARCH_CMP_FN(const void *, const void *);
static int nid_cmp(int const *, int const *);
static int *OBJ_bsearch_nid(int *key, int const *base, int num);

static int
nid_cmp_BSEARCH_CMP_FN(const void *a_, const void *b_)
{
	int const *a = a_;
	int const *b = b_;
	return nid_cmp(a, b);
}

static int *
OBJ_bsearch_nid(int *key, int const *base, int num)
{
	return (int *)OBJ_bsearch_(key, base, num, sizeof(int),
	    nid_cmp_BSEARCH_CMP_FN);
}

int
X509_supported_extension(X509_EXTENSION *ex)
{
	/* This table is a list of the NIDs of supported extensions:
	 * that is those which are used by the verify process. If
	 * an extension is critical and doesn't appear in this list
	 * then the verify process will normally reject the certificate.
	 * The list must be kept in numerical order because it will be
	 * searched using bsearch.
	 */

	static const int supported_nids[] = {
		NID_netscape_cert_type, /* 71 */
		NID_key_usage,		/* 83 */
		NID_subject_alt_name,	/* 85 */
		NID_basic_constraints,	/* 87 */
		NID_certificate_policies, /* 89 */
		NID_ext_key_usage,	/* 126 */
		NID_policy_constraints,	/* 401 */
		NID_proxyCertInfo,	/* 663 */
		NID_name_constraints,	/* 666 */
		NID_policy_mappings,	/* 747 */
		NID_inhibit_any_policy	/* 748 */
	};

	int ex_nid = OBJ_obj2nid(X509_EXTENSION_get_object(ex));

	if (ex_nid == NID_undef)
		return 0;

	if (OBJ_bsearch_nid(&ex_nid, supported_nids,
	    sizeof(supported_nids) / sizeof(int)))
		return 1;
	return 0;
}

static void
setup_dp(X509 *x, DIST_POINT *dp)
{
	X509_NAME *iname = NULL;
	int i;

	if (dp->reasons) {
		if (dp->reasons->length > 0)
			dp->dp_reasons = dp->reasons->data[0];
		if (dp->reasons->length > 1)
			dp->dp_reasons |= (dp->reasons->data[1] << 8);
		dp->dp_reasons &= CRLDP_ALL_REASONS;
	} else
		dp->dp_reasons = CRLDP_ALL_REASONS;
	if (!dp->distpoint || (dp->distpoint->type != 1))
		return;
	for (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++) {
		GENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);
		if (gen->type == GEN_DIRNAME) {
			iname = gen->d.directoryName;
			break;
		}
	}
	if (!iname)
		iname = X509_get_issuer_name(x);

	DIST_POINT_set_dpname(dp->distpoint, iname);

}

static void
setup_crldp(X509 *x)
{
	int i;

	x->crldp = X509_get_ext_d2i(x, NID_crl_distribution_points, NULL, NULL);
	for (i = 0; i < sk_DIST_POINT_num(x->crldp); i++)
		setup_dp(x, sk_DIST_POINT_value(x->crldp, i));
}

static void
x509v3_cache_extensions(X509 *x)
{
	BASIC_CONSTRAINTS *bs;
	PROXY_CERT_INFO_EXTENSION *pci;
	ASN1_BIT_STRING *usage;
	ASN1_BIT_STRING *ns;
	EXTENDED_KEY_USAGE *extusage;
	X509_EXTENSION *ex;

	int i;
	if (x->ex_flags & EXFLAG_SET)
		return;
#ifndef OPENSSL_NO_SHA
	X509_digest(x, EVP_sha1(), x->sha1_hash, NULL);
#endif
	/* Does subject name match issuer ? */
	if (!X509_NAME_cmp(X509_get_subject_name(x), X509_get_issuer_name(x)))
		x->ex_flags |= EXFLAG_SI;
	/* V1 should mean no extensions ... */
	if (!X509_get_version(x))
		x->ex_flags |= EXFLAG_V1;
	/* Handle basic constraints */
	if ((bs = X509_get_ext_d2i(x, NID_basic_constraints, NULL, NULL))) {
		if (bs->ca)
			x->ex_flags |= EXFLAG_CA;
		if (bs->pathlen) {
			if ((bs->pathlen->type == V_ASN1_NEG_INTEGER) ||
			    !bs->ca) {
				x->ex_flags |= EXFLAG_INVALID;
				x->ex_pathlen = 0;
			} else
				x->ex_pathlen = ASN1_INTEGER_get(bs->pathlen);
		} else
			x->ex_pathlen = -1;
		BASIC_CONSTRAINTS_free(bs);
		x->ex_flags |= EXFLAG_BCONS;
	}
	/* Handle proxy certificates */
	if ((pci = X509_get_ext_d2i(x, NID_proxyCertInfo, NULL, NULL))) {
		if (x->ex_flags & EXFLAG_CA ||
		    X509_get_ext_by_NID(x, NID_subject_alt_name, -1) >= 0 ||
		    X509_get_ext_by_NID(x, NID_issuer_alt_name, -1) >= 0) {
			x->ex_flags |= EXFLAG_INVALID;
		}
		if (pci->pcPathLengthConstraint) {
			if (pci->pcPathLengthConstraint->type ==
			    V_ASN1_NEG_INTEGER) {
				x->ex_flags |= EXFLAG_INVALID;
				x->ex_pcpathlen = 0;
			} else
				x->ex_pcpathlen =
				    ASN1_INTEGER_get(pci->
				      pcPathLengthConstraint);
		} else
			x->ex_pcpathlen = -1;
		PROXY_CERT_INFO_EXTENSION_free(pci);
		x->ex_flags |= EXFLAG_PROXY;
	}
	/* Handle key usage */
	if ((usage = X509_get_ext_d2i(x, NID_key_usage, NULL, NULL))) {
		if (usage->length > 0) {
			x->ex_kusage = usage->data[0];
			if (usage->length > 1)
				x->ex_kusage |= usage->data[1] << 8;
		} else
			x->ex_kusage = 0;
		x->ex_flags |= EXFLAG_KUSAGE;
		ASN1_BIT_STRING_free(usage);
	}
	x->ex_xkusage = 0;
	if ((extusage = X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL))) {
		x->ex_flags |= EXFLAG_XKUSAGE;
		for (i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {
			switch (OBJ_obj2nid(sk_ASN1_OBJECT_value(extusage, i))) {
			case NID_server_auth:
				x->ex_xkusage |= XKU_SSL_SERVER;
				break;

			case NID_client_auth:
				x->ex_xkusage |= XKU_SSL_CLIENT;
				break;

			case NID_email_protect:
				x->ex_xkusage |= XKU_SMIME;
				break;

			case NID_code_sign:
				x->ex_xkusage |= XKU_CODE_SIGN;
				break;

			case NID_ms_sgc:
			case NID_ns_sgc:
				x->ex_xkusage |= XKU_SGC;
				break;

			case NID_OCSP_sign:
				x->ex_xkusage |= XKU_OCSP_SIGN;
				break;

			case NID_time_stamp:
				x->ex_xkusage |= XKU_TIMESTAMP;
				break;

			case NID_dvcs:
				x->ex_xkusage |= XKU_DVCS;
				break;
			}
		}
		sk_ASN1_OBJECT_pop_free(extusage, ASN1_OBJECT_free);
	}

	if ((ns = X509_get_ext_d2i(x, NID_netscape_cert_type, NULL, NULL))) {
		if (ns->length > 0)
			x->ex_nscert = ns->data[0];
		else
			x->ex_nscert = 0;
		x->ex_flags |= EXFLAG_NSCERT;
		ASN1_BIT_STRING_free(ns);
	}

	x->skid = X509_get_ext_d2i(x, NID_subject_key_identifier, NULL, NULL);
	x->akid = X509_get_ext_d2i(x, NID_authority_key_identifier, NULL, NULL);
	x->altname = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);
	x->nc = X509_get_ext_d2i(x, NID_name_constraints, &i, NULL);
	if (!x->nc && (i != -1))
		x->ex_flags |= EXFLAG_INVALID;
	setup_crldp(x);

	for (i = 0; i < X509_get_ext_count(x); i++) {
		ex = X509_get_ext(x, i);
		if (OBJ_obj2nid(X509_EXTENSION_get_object(ex)) ==
		    NID_freshest_crl)
			x->ex_flags |= EXFLAG_FRESHEST;
		if (!X509_EXTENSION_get_critical(ex))
			continue;
		if (!X509_supported_extension(ex)) {
			x->ex_flags |= EXFLAG_CRITICAL;
			break;
		}
	}
	x->ex_flags |= EXFLAG_SET;
}

/* CA checks common to all purposes
 * return codes:
 * 0 not a CA
 * 1 is a CA
 * 2 basicConstraints absent so "maybe" a CA
 * 3 basicConstraints absent but self signed V1.
 * 4 basicConstraints absent but keyUsage present and keyCertSign asserted.
 */

#define V1_ROOT (EXFLAG_V1|EXFLAG_SS)
#define ku_reject(x, usage) \
	(((x)->ex_flags & EXFLAG_KUSAGE) && !((x)->ex_kusage & (usage)))
#define xku_reject(x, usage) \
	(((x)->ex_flags & EXFLAG_XKUSAGE) && !((x)->ex_xkusage & (usage)))
#define ns_reject(x, usage) \
	(((x)->ex_flags & EXFLAG_NSCERT) && !((x)->ex_nscert & (usage)))

static int
check_ca(const X509 *x)
{
	/* keyUsage if present should allow cert signing */
	if (ku_reject(x, KU_KEY_CERT_SIGN))
		return 0;
	if (x->ex_flags & EXFLAG_BCONS) {
		if (x->ex_flags & EXFLAG_CA)
			return 1;
		/* If basicConstraints says not a CA then say so */
		else
			return 0;
	} else {
		/* we support V1 roots for...  uh, I don't really know why. */
		if ((x->ex_flags & V1_ROOT) == V1_ROOT)
			return 3;
		/* If key usage present it must have certSign so tolerate it */
		else if (x->ex_flags & EXFLAG_KUSAGE)
			return 4;
		/* Older certificates could have Netscape-specific CA types */
		else if (x->ex_flags & EXFLAG_NSCERT &&
		    x->ex_nscert & NS_ANY_CA)
			return 5;
		/* can this still be regarded a CA certificate?  I doubt it */
		return 0;
	}
}

int
X509_check_ca(X509 *x)
{
	if (!(x->ex_flags & EXFLAG_SET)) {
		CRYPTO_w_lock(CRYPTO_LOCK_X509);
		x509v3_cache_extensions(x);
		CRYPTO_w_unlock(CRYPTO_LOCK_X509);
	}

	return check_ca(x);
}

/* Check SSL CA: common checks for SSL client and server */
static int
check_ssl_ca(const X509 *x)
{
	int ca_ret;

	ca_ret = check_ca(x);
	if (!ca_ret)
		return 0;
	/* check nsCertType if present */
	if (ca_ret != 5 || x->ex_nscert & NS_SSL_CA)
		return ca_ret;
	else
		return 0;
}

static int
check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	if (xku_reject(x, XKU_SSL_CLIENT))
		return 0;
	if (ca)
		return check_ssl_ca(x);
	/* We need to do digital signatures with it */
	if (ku_reject(x, KU_DIGITAL_SIGNATURE))
		return 0;
	/* nsCertType if present should allow SSL client use */
	if (ns_reject(x, NS_SSL_CLIENT))
		return 0;
	return 1;
}

static int
check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	if (xku_reject(x, XKU_SSL_SERVER|XKU_SGC))
		return 0;
	if (ca)
		return check_ssl_ca(x);

	if (ns_reject(x, NS_SSL_SERVER))
		return 0;
	/* Now as for keyUsage: we'll at least need to sign OR encipher */
	if (ku_reject(x, KU_DIGITAL_SIGNATURE|KU_KEY_ENCIPHERMENT))
		return 0;

	return 1;
}

static int
check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	int ret;

	ret = check_purpose_ssl_server(xp, x, ca);
	if (!ret || ca)
		return ret;
	/* We need to encipher or Netscape complains */
	if (ku_reject(x, KU_KEY_ENCIPHERMENT))
		return 0;
	return ret;
}

/* common S/MIME checks */
static int
purpose_smime(const X509 *x, int ca)
{
	if (xku_reject(x, XKU_SMIME))
		return 0;
	if (ca) {
		int ca_ret;
		ca_ret = check_ca(x);
		if (!ca_ret)
			return 0;
		/* check nsCertType if present */
		if (ca_ret != 5 || x->ex_nscert & NS_SMIME_CA)
			return ca_ret;
		else
			return 0;
	}
	if (x->ex_flags & EXFLAG_NSCERT) {
		if (x->ex_nscert & NS_SMIME)
			return 1;
		/* Workaround for some buggy certificates */
		if (x->ex_nscert & NS_SSL_CLIENT)
			return 2;
		return 0;
	}
	return 1;
}

static int
check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	int ret;

	ret = purpose_smime(x, ca);
	if (!ret || ca)
		return ret;
	if (ku_reject(x, KU_DIGITAL_SIGNATURE|KU_NON_REPUDIATION))
		return 0;
	return ret;
}

static int
check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	int ret;

	ret = purpose_smime(x, ca);
	if (!ret || ca)
		return ret;
	if (ku_reject(x, KU_KEY_ENCIPHERMENT))
		return 0;
	return ret;
}

static int
check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	if (ca) {
		int ca_ret;
		if ((ca_ret = check_ca(x)) != 2)
			return ca_ret;
		else
			return 0;
	}
	if (ku_reject(x, KU_CRL_SIGN))
		return 0;
	return 1;
}

/* OCSP helper: this is *not* a full OCSP check. It just checks that
 * each CA is valid. Additional checks must be made on the chain.
 */
static int
ocsp_helper(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	/* Must be a valid CA.  Should we really support the "I don't know"
	   value (2)? */
	if (ca)
		return check_ca(x);
	/* leaf certificate is checked in OCSP_verify() */
	return 1;
}

static int
check_purpose_timestamp_sign(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	int i_ext;

	/* If ca is true we must return if this is a valid CA certificate. */
	if (ca)
		return check_ca(x);

	/*
	 * Check the optional key usage field:
	 * if Key Usage is present, it must be one of digitalSignature
	 * and/or nonRepudiation (other values are not consistent and shall
	 * be rejected).
	 */
	if ((x->ex_flags & EXFLAG_KUSAGE) &&
	    ((x->ex_kusage & ~(KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE)) ||
	    !(x->ex_kusage & (KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE))))
		return 0;

	/* Only time stamp key usage is permitted and it's required. */
	if (!(x->ex_flags & EXFLAG_XKUSAGE) || x->ex_xkusage != XKU_TIMESTAMP)
		return 0;

	/* Extended Key Usage MUST be critical */
	i_ext = X509_get_ext_by_NID((X509 *) x, NID_ext_key_usage, -1);
	if (i_ext >= 0) {
		X509_EXTENSION *ext = X509_get_ext((X509 *) x, i_ext);
		if (!X509_EXTENSION_get_critical(ext))
			return 0;
	}

	return 1;
}

static int
no_check(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	return 1;
}

/* Various checks to see if one certificate issued the second.
 * This can be used to prune a set of possible issuer certificates
 * which have been looked up using some simple method such as by
 * subject name.
 * These are:
 * 1. Check issuer_name(subject) == subject_name(issuer)
 * 2. If akid(subject) exists check it matches issuer
 * 3. If key_usage(issuer) exists check it supports certificate signing
 * returns 0 for OK, positive for reason for mismatch, reasons match
 * codes for X509_verify_cert()
 */

int
X509_check_issued(X509 *issuer, X509 *subject)
{
	if (X509_NAME_cmp(X509_get_subject_name(issuer),
	    X509_get_issuer_name(subject)))
		return X509_V_ERR_SUBJECT_ISSUER_MISMATCH;
	x509v3_cache_extensions(issuer);
	x509v3_cache_extensions(subject);

	if (subject->akid) {
		int ret = X509_check_akid(issuer, subject->akid);
		if (ret != X509_V_OK)
			return ret;
	}

	if (subject->ex_flags & EXFLAG_PROXY) {
		if (ku_reject(issuer, KU_DIGITAL_SIGNATURE))
			return X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE;
	} else if (ku_reject(issuer, KU_KEY_CERT_SIGN))
		return X509_V_ERR_KEYUSAGE_NO_CERTSIGN;
	return X509_V_OK;
}

int
X509_check_akid(X509 *issuer, AUTHORITY_KEYID *akid)
{
	if (!akid)
		return X509_V_OK;

	/* Check key ids (if present) */
	if (akid->keyid && issuer->skid &&
	    ASN1_OCTET_STRING_cmp(akid->keyid, issuer->skid) )
		return X509_V_ERR_AKID_SKID_MISMATCH;
	/* Check serial number */
	if (akid->serial &&
	    ASN1_INTEGER_cmp(X509_get_serialNumber(issuer), akid->serial))
		return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
	/* Check issuer name */
	if (akid->issuer) {
		/* Ugh, for some peculiar reason AKID includes
		 * SEQUENCE OF GeneralName. So look for a DirName.
		 * There may be more than one but we only take any
		 * notice of the first.
		 */
		GENERAL_NAMES *gens;
		GENERAL_NAME *gen;
		X509_NAME *nm = NULL;
		int i;
		gens = akid->issuer;
		for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
			gen = sk_GENERAL_NAME_value(gens, i);
			if (gen->type == GEN_DIRNAME) {
				nm = gen->d.dirn;
				break;
			}
		}
		if (nm && X509_NAME_cmp(nm, X509_get_issuer_name(issuer)))
			return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
	}
	return X509_V_OK;
}
@


1.28
log
@Expand DECLARE_OBJ_BSEARCH_CMP_FN and IMPLEMENT_OBJ_BSEARCH_CMP_FN macros.

No change to generated assembly excluding line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.27 2016/11/08 20:01:06 miod Exp $ */
d141 1
a141 1
		X509V3err(X509V3_F_X509_PURPOSE_SET, X509V3_R_INVALID_PURPOSE);
d209 1
a209 2
		X509V3err(X509V3_F_X509_PURPOSE_ADD,
		    X509V3_R_INVALID_NULL_ARGUMENT);
d222 1
a222 2
			X509V3err(X509V3_F_X509_PURPOSE_ADD,
			    ERR_R_MALLOC_FAILURE);
d267 1
a267 1
	X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);
@


1.27
log
@Stricter checks of ASN1_INTEGER to reject ASN1_NEG_INTEGER in places when
they don't make sense.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.26 2015/02/10 13:28:17 jsing Exp $ */
d328 18
a345 2
DECLARE_OBJ_BSEARCH_CMP_FN(int, int, nid);
IMPLEMENT_OBJ_BSEARCH_CMP_FN(int, int, nid);
@


1.26
log
@unifdef OPENSSL_NO_RFC3779 - this is currently disabled and unlikely to
be enabled, mostly since people use SANs instead.

ok beck@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.25 2015/02/10 11:22:22 jsing Exp $ */
d453 8
a460 2
			x->ex_pcpathlen =
			    ASN1_INTEGER_get(pci->pcPathLengthConstraint);
@


1.25
log
@Remove more IMPLEMENT_STACK_OF noops that have been hiding for the last
15 years.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.24 2014/12/06 19:26:37 doug Exp $ */
a348 4
#ifndef OPENSSL_NO_RFC3779
		NID_sbgp_ipAddrBlock,	/* 290 */
		NID_sbgp_autonomousSysNum, /* 291 */
#endif
a529 5
#ifndef OPENSSL_NO_RFC3779
	x->rfc3779_addr = X509_get_ext_d2i(x, NID_sbgp_ipAddrBlock, NULL, NULL);
	x->rfc3779_asid = X509_get_ext_d2i(x, NID_sbgp_autonomousSysNum,
	    NULL, NULL);
#endif
@


1.24
log
@Avoid modifying input on failure in X509_(TRUST|PURPOSE)_add.

If X509_TRUST_add() or X509_PURPOSE_add() fail, they will leave the
object in an inconsistent state since the name is already freed.
This commit avoids changing the original name unless the *_add() call
will succeed.

Based on BoringSSL's commit: ab2815eaff6219ef57aedca2f7b1b72333c27fd0

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.23 2014/10/05 18:33:57 miod Exp $ */
a104 2

IMPLEMENT_STACK_OF(X509_PURPOSE)
@


1.23
log
@The fixes to X509_PURPOSE_add() in r1.18 actually could cause a global
X509_PURPOSE object (obtained with X509_PURPOSE_get0() instead of being
allocated in the function) to be freed if modifying that object would fail
due to a low memory condition, while this object would still be referenced
elsewhere.
Fix this by only cleaning the object if we did not allocate it here.

While there, fail early if either `name' or `sname' are NULL, rather than
allocating an object and realizing we have nothing to strdup() into it.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.22 2014/07/13 16:03:10 beck Exp $ */
d206 3
d233 5
d244 2
a245 4
	ptmp->name = strdup(name);
	ptmp->sname = strdup(sname);
	if (ptmp->name == NULL || ptmp->sname == NULL)
		goto err;
d267 2
a268 2
	free(ptmp->name);
	free(ptmp->sname);
a270 4
	else {
		ptmp->name = NULL;
		ptmp->sname = NULL;
	}
@


1.22
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.21 2014/07/11 08:44:49 jsing Exp $ */
d207 6
d221 1
a221 1
		if (!(ptmp = malloc(sizeof(X509_PURPOSE)))) {
d236 4
a239 9
	ptmp->name = name ? strdup(name) : NULL;
	ptmp->sname = sname ? strdup(sname) : NULL;
	if (!ptmp->name || !ptmp->sname) {
		free(ptmp->name);
		free(ptmp->sname);
		free(ptmp);
		X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);
		return 0;
	}
d252 5
a256 16
		if (!xptable && !(xptable = sk_X509_PURPOSE_new(xp_cmp))) {
			free(ptmp->name);
			free(ptmp->sname);
			free(ptmp);
			X509V3err(X509V3_F_X509_PURPOSE_ADD,
			    ERR_R_MALLOC_FAILURE);
			return 0;
		}
		if (!sk_X509_PURPOSE_push(xptable, ptmp)) {
			free(ptmp->name);
			free(ptmp->sname);
			free(ptmp);
			X509V3err(X509V3_F_X509_PURPOSE_ADD,
			    ERR_R_MALLOC_FAILURE);
			return 0;
		}
d259 12
@


1.21
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.20 2014/07/10 22:45:58 jsing Exp $ */
d230 2
a231 2
	ptmp->name = BUF_strdup(name);
	ptmp->sname = BUF_strdup(sname);
@


1.20
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.19 2014/07/10 13:58:23 jsing Exp $ */
d64 1
a64 1
#include "cryptlib.h"
@


1.19
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.18 2014/06/28 18:14:57 logan Exp $ */
d61 2
@


1.18
log
@Fix 9 memory leaks.

(Thanks to Brent Cook)

With help from tedu@@

OK from tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_purp.c,v 1.17 2014/06/12 15:49:31 deraadt Exp $ */
d60 2
@


1.17
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d229 3
d248 3
d256 3
@


1.16
log
@KNF.
@
text
@d1 1
a1 1
/* v3_purp.c */
@


1.15
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d67 6
a72 3
static int check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x, int ca);
static int check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca);
static int check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca);
d74 8
a81 4
static int check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x, int ca);
static int check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x, int ca);
static int check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x, int ca);
static int check_purpose_timestamp_sign(const X509_PURPOSE *xp, const X509 *x, int ca);
d85 1
a85 2
static int xp_cmp(const X509_PURPOSE * const *a,
		const X509_PURPOSE * const *b);
d106 2
a107 2
static int xp_cmp(const X509_PURPOSE * const *a,
		const X509_PURPOSE * const *b)
d115 2
a116 1
int X509_check_purpose(X509 *x, int id, int ca)
d120 2
a121 1
	if(!(x->ex_flags & EXFLAG_SET)) {
d126 2
a127 1
	if(id == -1) return 1;
d129 2
a130 1
	if(idx == -1) return -1;
d135 2
a136 1
int X509_PURPOSE_set(int *p, int purpose)
d138 1
a138 1
	if(X509_PURPOSE_get_by_id(purpose) == -1) {
d146 2
a147 1
int X509_PURPOSE_get_count(void)
d149 2
a150 1
	if(!xptable) return X509_PURPOSE_COUNT;
d154 2
a155 1
X509_PURPOSE * X509_PURPOSE_get0(int idx)
d157 4
a160 2
	if(idx < 0) return NULL;
	if(idx < (int)X509_PURPOSE_COUNT) return xstandard + idx;
d164 2
a165 1
int X509_PURPOSE_get_by_sname(char *sname)
d169 2
a170 1
	for(i = 0; i < X509_PURPOSE_get_count(); i++) {
d172 2
a173 1
		if(!strcmp(xptmp->sname, sname)) return i;
d178 2
a179 1
int X509_PURPOSE_get_by_id(int purpose)
d183 2
a184 1
	if((purpose >= X509_PURPOSE_MIN) && (purpose <= X509_PURPOSE_MAX))
d187 2
a188 1
	if(!xptable) return -1;
d190 2
a191 1
	if(idx == -1) return -1;
d195 4
a198 3
int X509_PURPOSE_add(int id, int trust, int flags,
			int (*ck)(const X509_PURPOSE *, const X509 *, int),
					char *name, char *sname, void *arg)
d202 1
d210 4
a213 3
	if(idx == -1) {
		if(!(ptmp = malloc(sizeof(X509_PURPOSE)))) {
			X509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);
d217 2
a218 1
	} else ptmp = X509_PURPOSE_get0(idx);
d221 1
a221 1
	if(ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) {
d228 2
a229 2
	if(!ptmp->name || !ptmp->sname) {
		X509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);
d243 4
a246 3
	if(idx == -1) {
		if(!xptable && !(xptable = sk_X509_PURPOSE_new(xp_cmp))) {
			X509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);
d250 2
a251 1
			X509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);
d258 6
a263 5
static void xptable_free(X509_PURPOSE *p)
	{
	if(!p) return;
	if (p->flags & X509_PURPOSE_DYNAMIC) 
		{
a268 1
		}
d270 1
d272 2
a273 1
void X509_PURPOSE_cleanup(void)
d276 1
d278 2
a279 1
	for(i = 0; i < X509_PURPOSE_COUNT; i++) xptable_free(xstandard + i);
d283 2
a284 1
int X509_PURPOSE_get_id(X509_PURPOSE *xp)
d289 2
a290 1
char *X509_PURPOSE_get0_name(X509_PURPOSE *xp)
d295 2
a296 1
char *X509_PURPOSE_get0_sname(X509_PURPOSE *xp)
d301 2
a302 1
int X509_PURPOSE_get_trust(X509_PURPOSE *xp)
d307 3
a309 2
static int nid_cmp(const int *a, const int *b)
	{
d311 1
a311 1
	}
d316 3
a318 2
int X509_supported_extension(X509_EXTENSION *ex)
	{
d329 1
a329 1
        	NID_key_usage,		/* 83 */
d333 1
a333 1
        	NID_ext_key_usage,	/* 126 */
d347 1
a347 1
	if (ex_nid == NID_undef) 
d351 1
a351 1
			sizeof(supported_nids)/sizeof(int)))
d354 1
a354 1
	}
d356 3
a358 2
static void setup_dp(X509 *x, DIST_POINT *dp)
	{
d361 2
a362 2
	if (dp->reasons)
		{
d368 1
a368 2
		}
	else
d372 1
a372 2
	for (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++)
		{
d374 1
a374 2
		if (gen->type == GEN_DIRNAME)
			{
a376 1
			}
d378 1
d384 1
a384 1
	}
d386 3
a388 2
static void setup_crldp(X509 *x)
	{
d390 1
d394 1
a394 1
	}
d396 2
a397 1
static void x509v3_cache_extensions(X509 *x)
d405 1
a405 1
	
d407 2
a408 1
	if(x->ex_flags & EXFLAG_SET) return;
d413 2
a414 2
	if(!X509_NAME_cmp(X509_get_subject_name(x), X509_get_issuer_name(x)))
			 x->ex_flags |= EXFLAG_SI;
d416 2
a417 1
	if(!X509_get_version(x)) x->ex_flags |= EXFLAG_V1;
d419 6
a424 5
	if((bs=X509_get_ext_d2i(x, NID_basic_constraints, NULL, NULL))) {
		if(bs->ca) x->ex_flags |= EXFLAG_CA;
		if(bs->pathlen) {
			if((bs->pathlen->type == V_ASN1_NEG_INTEGER)
						|| !bs->ca) {
d427 4
a430 2
			} else x->ex_pathlen = ASN1_INTEGER_get(bs->pathlen);
		} else x->ex_pathlen = -1;
d435 4
a438 4
	if((pci=X509_get_ext_d2i(x, NID_proxyCertInfo, NULL, NULL))) {
		if (x->ex_flags & EXFLAG_CA
		    || X509_get_ext_by_NID(x, NID_subject_alt_name, -1) >= 0
		    || X509_get_ext_by_NID(x, NID_issuer_alt_name, -1) >= 0) {
d443 3
a445 2
				ASN1_INTEGER_get(pci->pcPathLengthConstraint);
		} else x->ex_pcpathlen = -1;
d450 2
a451 2
	if((usage=X509_get_ext_d2i(x, NID_key_usage, NULL, NULL))) {
		if(usage->length > 0) {
d453 1
a453 1
			if(usage->length > 1) 
d455 2
a456 1
		} else x->ex_kusage = 0;
d461 1
a461 1
	if((extusage=X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL))) {
d463 3
a465 3
		for(i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {
			switch(OBJ_obj2nid(sk_ASN1_OBJECT_value(extusage,i))) {
				case NID_server_auth:
d469 1
a469 1
				case NID_client_auth:
d473 1
a473 1
				case NID_email_protect:
d477 1
a477 1
				case NID_code_sign:
d481 2
a482 2
				case NID_ms_sgc:
				case NID_ns_sgc:
d486 1
a486 1
				case NID_OCSP_sign:
d490 1
a490 1
				case NID_time_stamp:
d494 1
a494 1
				case NID_dvcs:
d502 5
a506 3
	if((ns=X509_get_ext_d2i(x, NID_netscape_cert_type, NULL, NULL))) {
		if(ns->length > 0) x->ex_nscert = ns->data[0];
		else x->ex_nscert = 0;
d510 3
a512 2
	x->skid =X509_get_ext_d2i(x, NID_subject_key_identifier, NULL, NULL);
	x->akid =X509_get_ext_d2i(x, NID_authority_key_identifier, NULL, NULL);
d520 3
a522 3
 	x->rfc3779_addr =X509_get_ext_d2i(x, NID_sbgp_ipAddrBlock, NULL, NULL);
 	x->rfc3779_asid =X509_get_ext_d2i(x, NID_sbgp_autonomousSysNum,
 					  NULL, NULL);
d524 1
a524 2
	for (i = 0; i < X509_get_ext_count(x); i++)
		{
d526 2
a527 2
		if (OBJ_obj2nid(X509_EXTENSION_get_object(ex))
					== NID_freshest_crl)
d531 1
a531 2
		if (!X509_supported_extension(ex))
			{
a533 1
			}
d535 1
d556 2
a557 1
static int check_ca(const X509 *x)
d560 5
a564 3
	if(ku_reject(x, KU_KEY_CERT_SIGN)) return 0;
	if(x->ex_flags & EXFLAG_BCONS) {
		if(x->ex_flags & EXFLAG_CA) return 1;
d566 2
a567 1
		else return 0;
d570 2
a571 1
		if((x->ex_flags & V1_ROOT) == V1_ROOT) return 3;
d573 2
a574 1
		else if (x->ex_flags & EXFLAG_KUSAGE) return 4;
d576 3
a578 2
		else if (x->ex_flags & EXFLAG_NSCERT
			 && x->ex_nscert & NS_ANY_CA) return 5;
d584 2
a585 1
int X509_check_ca(X509 *x)
d587 1
a587 1
	if(!(x->ex_flags & EXFLAG_SET)) {
d597 2
a598 1
static int check_ssl_ca(const X509 *x)
d601 1
d603 2
a604 1
	if(!ca_ret) return 0;
d606 4
a609 2
	if(ca_ret != 5 || x->ex_nscert & NS_SSL_CA) return ca_ret;
	else return 0;
d612 2
a613 2

static int check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x, int ca)
d615 4
a618 2
	if(xku_reject(x,XKU_SSL_CLIENT)) return 0;
	if(ca) return check_ssl_ca(x);
d620 5
a624 3
	if(ku_reject(x,KU_DIGITAL_SIGNATURE)) return 0;
	/* nsCertType if present should allow SSL client use */	
	if(ns_reject(x, NS_SSL_CLIENT)) return 0;
d628 2
a629 1
static int check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)
d631 4
a634 2
	if(xku_reject(x,XKU_SSL_SERVER|XKU_SGC)) return 0;
	if(ca) return check_ssl_ca(x);
d636 2
a637 1
	if(ns_reject(x, NS_SSL_SERVER)) return 0;
d639 3
a641 2
	if(ku_reject(x, KU_DIGITAL_SIGNATURE|KU_KEY_ENCIPHERMENT)) return 0;
	
a642 1

d645 2
a646 1
static int check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)
d649 1
d651 2
a652 1
	if(!ret || ca) return ret;
d654 2
a655 1
	if(ku_reject(x, KU_KEY_ENCIPHERMENT)) return 0;
d660 2
a661 1
static int purpose_smime(const X509 *x, int ca)
d663 3
a665 2
	if(xku_reject(x,XKU_SMIME)) return 0;
	if(ca) {
d668 2
a669 1
		if(!ca_ret) return 0;
d671 4
a674 2
		if(ca_ret != 5 || x->ex_nscert & NS_SMIME_CA) return ca_ret;
		else return 0;
d676 3
a678 2
	if(x->ex_flags & EXFLAG_NSCERT) {
		if(x->ex_nscert & NS_SMIME) return 1;
d680 2
a681 1
		if(x->ex_nscert & NS_SSL_CLIENT) return 2;
d687 2
a688 1
static int check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x, int ca)
d691 1
d693 4
a696 2
	if(!ret || ca) return ret;
	if(ku_reject(x, KU_DIGITAL_SIGNATURE|KU_NON_REPUDIATION)) return 0;
d700 2
a701 1
static int check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x, int ca)
d704 1
d706 4
a709 2
	if(!ret || ca) return ret;
	if(ku_reject(x, KU_KEY_ENCIPHERMENT)) return 0;
d713 2
a714 1
static int check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x, int ca)
d716 1
a716 1
	if(ca) {
d718 4
a721 2
		if((ca_ret = check_ca(x)) != 2) return ca_ret;
		else return 0;
d723 2
a724 1
	if(ku_reject(x, KU_CRL_SIGN)) return 0;
d731 2
a732 2

static int ocsp_helper(const X509_PURPOSE *xp, const X509 *x, int ca)
d736 2
a737 1
	if(ca) return check_ca(x);
d742 2
a743 2
static int check_purpose_timestamp_sign(const X509_PURPOSE *xp, const X509 *x,
					int ca)
d748 2
a749 1
	if (ca) return check_ca(x);
d751 1
a751 1
	/* 
d753 1
a753 1
	 * if Key Usage is present, it must be one of digitalSignature 
d757 3
a759 3
	if ((x->ex_flags & EXFLAG_KUSAGE)
	    && ((x->ex_kusage & ~(KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE)) ||
		!(x->ex_kusage & (KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE))))
d768 1
a768 2
	if (i_ext >= 0)
		{
d772 1
a772 1
		}
d777 2
a778 1
static int no_check(const X509_PURPOSE *xp, const X509 *x, int ca)
d795 2
a796 1
int X509_check_issued(X509 *issuer, X509 *subject)
d798 3
a800 3
	if(X509_NAME_cmp(X509_get_subject_name(issuer),
			X509_get_issuer_name(subject)))
				return X509_V_ERR_SUBJECT_ISSUER_MISMATCH;
d804 1
a804 2
	if(subject->akid)
		{
d808 1
a808 1
		}
d810 2
a811 3
	if(subject->ex_flags & EXFLAG_PROXY)
		{
		if(ku_reject(issuer, KU_DIGITAL_SIGNATURE))
d813 1
a813 2
		}
	else if(ku_reject(issuer, KU_KEY_CERT_SIGN))
d818 4
a821 4
int X509_check_akid(X509 *issuer, AUTHORITY_KEYID *akid)
	{

	if(!akid)
d825 3
a827 3
	if(akid->keyid && issuer->skid &&
		 ASN1_OCTET_STRING_cmp(akid->keyid, issuer->skid) )
				return X509_V_ERR_AKID_SKID_MISMATCH;
d829 3
a831 3
	if(akid->serial &&
		ASN1_INTEGER_cmp(X509_get_serialNumber(issuer), akid->serial))
				return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
d833 1
a833 2
	if(akid->issuer)
		{
d844 1
a844 2
		for(i = 0; i < sk_GENERAL_NAME_num(gens); i++)
			{
d846 1
a846 2
			if(gen->type == GEN_DIRNAME)
				{
a848 1
				}
d850 2
a851 1
		if(nm && X509_NAME_cmp(nm, X509_get_issuer_name(issuer)))
d853 1
a853 1
		}
d855 1
a855 2
	}

@


1.14
log
@OpenSSL PR#3309: when looking for an extension, set the last found position
to -1 to properly search all extensions.  ok tedu@@

From http://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=300b9f0b70
@
text
@d186 1
a186 1
		if(!(ptmp = OPENSSL_malloc(sizeof(X509_PURPOSE)))) {
d193 1
a193 1
	/* OPENSSL_free existing name if dynamic */
d195 2
a196 2
		OPENSSL_free(ptmp->name);
		OPENSSL_free(ptmp->sname);
d235 2
a236 2
			OPENSSL_free(p->name);
			OPENSSL_free(p->sname);
d238 1
a238 1
		OPENSSL_free(p);
@


1.13
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d392 2
a393 2
		    || X509_get_ext_by_NID(x, NID_subject_alt_name, 0) >= 0
		    || X509_get_ext_by_NID(x, NID_issuer_alt_name, 0) >= 0) {
d673 1
a673 1
	i_ext = X509_get_ext_by_NID((X509 *) x, NID_ext_key_usage, 0);
@


1.12
log
@resolve conflicts, fix local changes
@
text
@a476 2
		if (!X509_EXTENSION_get_critical(ex))
			continue;
d480 2
@


1.11
log
@resolve conflicts
@
text
@d74 1
d91 1
d270 1
a270 1
static int nid_cmp(int *a, int *b)
d275 3
d288 1
a288 1
	static int supported_nids[] = {
d300 3
a302 1
		NID_proxyCertInfo,	/* 661 */
d306 1
a306 3
	int ex_nid;

	ex_nid = OBJ_obj2nid(X509_EXTENSION_get_object(ex));
d311 2
a312 3
	if (OBJ_bsearch((char *)&ex_nid, (char *)supported_nids,
		sizeof(supported_nids)/sizeof(int), sizeof(int),
		(int (*)(const void *, const void *))nid_cmp))
d316 40
a355 1
 
d463 6
d470 3
a472 3
	x->rfc3779_addr =X509_get_ext_d2i(x, NID_sbgp_ipAddrBlock, NULL, NULL);
	x->rfc3779_asid =X509_get_ext_d2i(x, NID_sbgp_autonomousSysNum,
					  NULL, NULL);
d479 3
d649 35
d708 6
a713 31
	if(subject->akid) {
		/* Check key ids (if present) */
		if(subject->akid->keyid && issuer->skid &&
		 ASN1_OCTET_STRING_cmp(subject->akid->keyid, issuer->skid) )
				return X509_V_ERR_AKID_SKID_MISMATCH;
		/* Check serial number */
		if(subject->akid->serial &&
			ASN1_INTEGER_cmp(X509_get_serialNumber(issuer),
						subject->akid->serial))
				return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
		/* Check issuer name */
		if(subject->akid->issuer) {
			/* Ugh, for some peculiar reason AKID includes
			 * SEQUENCE OF GeneralName. So look for a DirName.
			 * There may be more than one but we only take any
			 * notice of the first.
			 */
			GENERAL_NAMES *gens;
			GENERAL_NAME *gen;
			X509_NAME *nm = NULL;
			int i;
			gens = subject->akid->issuer;
			for(i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
				gen = sk_GENERAL_NAME_value(gens, i);
				if(gen->type == GEN_DIRNAME) {
					nm = gen->d.dirn;
					break;
				}
			}
			if(nm && X509_NAME_cmp(nm, X509_get_issuer_name(issuer)))
				return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
d715 1
a715 1
	}
d725 42
@


1.10
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.9
log
@resolve conflicts
@
text
@d294 3
a296 1
		NID_proxyCertInfo	/* 661 */
d330 1
a330 1
			 x->ex_flags |= EXFLAG_SS;
@


1.8
log
@resolve conflicts
@
text
@d142 1
a142 1
	if(idx < X509_PURPOSE_COUNT) return xstandard + idx;
d242 1
a242 1
	int i;
d288 1
d290 4
d351 4
d418 5
@


1.7
log
@merge 0.9.7d
@
text
@a65 1
static int ca_check(const X509 *x);
d288 2
a289 1
        	NID_ext_key_usage	/* 126 */
d310 1
d339 10
d440 1
a440 1
static int ca_check(const X509 *x)
d449 1
d453 5
a457 1
		else return 2;
d461 11
d476 1
a476 1
	ca_ret = ca_check(x);
d479 1
a479 5
	if(x->ex_flags & EXFLAG_NSCERT) {
		if(x->ex_nscert & NS_SSL_CA) return ca_ret;
		return 0;
	}
	if(ca_ret != 2) return ca_ret;
d524 1
a524 1
		ca_ret = ca_check(x);
d527 1
a527 5
		if(x->ex_flags & EXFLAG_NSCERT) {
			if(x->ex_nscert & NS_SMIME_CA) return ca_ret;
			return 0;
		}
		if(ca_ret != 2) return ca_ret;
d561 1
a561 1
		if((ca_ret = ca_check(x)) != 2) return ca_ret;
d574 3
a576 11
	/* Must be a valid CA */
	if(ca) {
		int ca_ret;
		ca_ret = ca_check(x);
		if(ca_ret != 2) return ca_ret;
		if(x->ex_flags & EXFLAG_NSCERT) {
			if(x->ex_nscert & NS_ANY_CA) return ca_ret;
			return 0;
		}
		return 0;
	}
d638 7
a644 1
	if(ku_reject(issuer, KU_KEY_CERT_SIGN)) return X509_V_ERR_KEYUSAGE_NO_CERTSIGN;
@


1.6
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.
d418 1
d440 1
a440 1
		else if (x->ex_flags & EXFLAG_KUSAGE) return 3;
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d381 4
@


1.4
log
@openssl-engine-0.9.6a merge
@
text
@d3 1
a3 1
 * project 1999.
d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
a63 1

d76 1
d90 1
d124 10
a157 1

d269 38
d312 2
a313 1
	STACK_OF(ASN1_OBJECT) *extusage;
d317 1
a317 1
#ifndef NO_SHA
d372 9
d394 11
d544 21
d606 1
a606 1
			STACK_OF(GENERAL_NAME) *gens;
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d365 2
d385 1
a385 1
	
d451 1
a451 1
	if(ku_reject(x, KU_DIGITAL_SIGNATURE)) return 0;
@


1.2
log
@OpenSSL 0.9.5a merge
@
text
@d62 1
d67 10
a76 9
static int ca_check(X509 *x);
static int check_purpose_ssl_client(X509_PURPOSE *xp, X509 *x, int ca);
static int check_purpose_ssl_server(X509_PURPOSE *xp, X509 *x, int ca);
static int check_purpose_ns_ssl_server(X509_PURPOSE *xp, X509 *x, int ca);
static int purpose_smime(X509 *x, int ca);
static int check_purpose_smime_sign(X509_PURPOSE *xp, X509 *x, int ca);
static int check_purpose_smime_encrypt(X509_PURPOSE *xp, X509 *x, int ca);
static int check_purpose_crl_sign(X509_PURPOSE *xp, X509 *x, int ca);
static int no_check(X509_PURPOSE *xp, X509 *x, int ca);
d78 2
a79 1
static int xp_cmp(X509_PURPOSE **a, X509_PURPOSE **b);
d98 2
a99 1
static int xp_cmp(X509_PURPOSE **a, X509_PURPOSE **b)
d104 3
d110 1
a110 1
	X509_PURPOSE *pt;
d162 1
a162 1
			int (*ck)(X509_PURPOSE *, X509 *, int),
d175 1
a175 1
		if(!(ptmp = Malloc(sizeof(X509_PURPOSE)))) {
d182 1
a182 1
	/* Free existing name if dynamic */
d184 2
a185 2
		Free(ptmp->name);
		Free(ptmp->sname);
d224 2
a225 2
			Free(p->name);
			Free(p->sname);
d227 1
a227 1
		Free(p);
a258 1
#ifndef NO_SHA
d265 1
d268 1
d270 1
d334 2
a337 1
#endif
d355 1
a355 1
static int ca_check(X509 *x)
d369 15
d385 1
a385 1
static int check_purpose_ssl_client(X509_PURPOSE *xp, X509 *x, int ca)
d388 1
a388 12
	if(ca) {
		int ca_ret;
		ca_ret = ca_check(x);
		if(!ca_ret) return 0;
		/* check nsCertType if present */
		if(x->ex_flags & EXFLAG_NSCERT) {
			if(x->ex_nscert & NS_SSL_CA) return ca_ret;
			return 0;
		}
		if(ca_ret != 2) return ca_ret;
		else return 0;
	}
d396 1
a396 1
static int check_purpose_ssl_server(X509_PURPOSE *xp, X509 *x, int ca)
d399 1
a399 2
	/* Otherwise same as SSL client for a CA */
	if(ca) return check_purpose_ssl_client(xp, x, 1);
d409 1
a409 1
static int check_purpose_ns_ssl_server(X509_PURPOSE *xp, X509 *x, int ca)
d420 1
a420 1
static int purpose_smime(X509 *x, int ca)
d444 1
a444 1
static int check_purpose_smime_sign(X509_PURPOSE *xp, X509 *x, int ca)
d453 1
a453 1
static int check_purpose_smime_encrypt(X509_PURPOSE *xp, X509 *x, int ca)
d462 1
a462 1
static int check_purpose_crl_sign(X509_PURPOSE *xp, X509 *x, int ca)
d473 1
a473 1
static int no_check(X509_PURPOSE *xp, X509 *x, int ca)
d477 57
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d74 1
d85 2
a86 1
	{X509_PURPOSE_CRL_SIGN, X509_TRUST_ANY, 0, check_purpose_crl_sign, "CRL signing", "crlsign", NULL},
d457 5
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d3 1
a3 1
 * project 2001.
d6 1
a6 1
 * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.
d62 1
a62 1
#include <openssl/x509_vfy.h>
d66 8
a73 11
static int ca_check(const X509 *x);
static int check_ssl_ca(const X509 *x);
static int check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x, int ca);
static int check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca);
static int check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca);
static int purpose_smime(const X509 *x, int ca);
static int check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x, int ca);
static int check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x, int ca);
static int check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x, int ca);
static int no_check(const X509_PURPOSE *xp, const X509 *x, int ca);
static int ocsp_helper(const X509_PURPOSE *xp, const X509 *x, int ca);
d75 1
a75 2
static int xp_cmp(const X509_PURPOSE * const *a,
		const X509_PURPOSE * const *b);
d84 1
a84 3
	{X509_PURPOSE_CRL_SIGN, X509_TRUST_COMPAT, 0, check_purpose_crl_sign, "CRL signing", "crlsign", NULL},
	{X509_PURPOSE_ANY, X509_TRUST_DEFAULT, 0, no_check, "Any Purpose", "any", NULL},
	{X509_PURPOSE_OCSP_HELPER, X509_TRUST_COMPAT, 0, ocsp_helper, "OCSP helper", "ocsphelper", NULL},
d93 1
a93 2
static int xp_cmp(const X509_PURPOSE * const *a,
		const X509_PURPOSE * const *b)
a97 3
/* As much as I'd like to make X509_check_purpose use a "const" X509*
 * I really can't because it does recalculate hashes and do other non-const
 * things. */
d101 1
a101 1
	const X509_PURPOSE *pt;
a113 10
int X509_PURPOSE_set(int *p, int purpose)
{
	if(X509_PURPOSE_get_by_id(purpose) == -1) {
		X509V3err(X509V3_F_X509_PURPOSE_SET, X509V3_R_INVALID_PURPOSE);
		return 0;
	}
	*p = purpose;
	return 1;
}

d138 1
d153 1
a153 1
			int (*ck)(const X509_PURPOSE *, const X509 *, int),
d166 1
a166 1
		if(!(ptmp = OPENSSL_malloc(sizeof(X509_PURPOSE)))) {
d173 1
a173 1
	/* OPENSSL_free existing name if dynamic */
d175 2
a176 2
		OPENSSL_free(ptmp->name);
		OPENSSL_free(ptmp->sname);
d215 2
a216 2
			OPENSSL_free(p->name);
			OPENSSL_free(p->sname);
d218 1
a218 1
		OPENSSL_free(p);
d250 1
a250 38
static int nid_cmp(int *a, int *b)
	{
	return *a - *b;
	}

int X509_supported_extension(X509_EXTENSION *ex)
	{
	/* This table is a list of the NIDs of supported extensions:
	 * that is those which are used by the verify process. If
	 * an extension is critical and doesn't appear in this list
	 * then the verify process will normally reject the certificate.
	 * The list must be kept in numerical order because it will be
	 * searched using bsearch.
	 */

	static int supported_nids[] = {
		NID_netscape_cert_type, /* 71 */
        	NID_key_usage,		/* 83 */
		NID_subject_alt_name,	/* 85 */
		NID_basic_constraints,	/* 87 */
        	NID_ext_key_usage	/* 126 */
	};

	int ex_nid;

	ex_nid = OBJ_obj2nid(X509_EXTENSION_get_object(ex));

	if (ex_nid == NID_undef) 
		return 0;

	if (OBJ_bsearch((char *)&ex_nid, (char *)supported_nids,
		sizeof(supported_nids)/sizeof(int), sizeof(int),
		(int (*)(const void *, const void *))nid_cmp))
		return 1;
	return 0;
	}
 

d256 1
a256 3
	EXTENDED_KEY_USAGE *extusage;
	X509_EXTENSION *ex;
	
a258 1
#ifndef OPENSSL_NO_SHA
a259 1
#endif
a311 9
				break;

				case NID_OCSP_sign:
				x->ex_xkusage |= XKU_OCSP_SIGN;
				break;

				case NID_time_stamp:
				x->ex_xkusage |= XKU_TIMESTAMP;
				break;
a322 13
	x->skid =X509_get_ext_d2i(x, NID_subject_key_identifier, NULL, NULL);
	x->akid =X509_get_ext_d2i(x, NID_authority_key_identifier, NULL, NULL);
	for (i = 0; i < X509_get_ext_count(x); i++)
		{
		ex = X509_get_ext(x, i);
		if (!X509_EXTENSION_get_critical(ex))
			continue;
		if (!X509_supported_extension(ex))
			{
			x->ex_flags |= EXFLAG_CRITICAL;
			break;
			}
		}
d325 1
d343 1
a343 1
static int ca_check(const X509 *x)
a352 2
		/* If key usage present it must have certSign so tolerate it */
		else if (x->ex_flags & EXFLAG_KUSAGE) return 3;
a356 15
/* Check SSL CA: common checks for SSL client and server */
static int check_ssl_ca(const X509 *x)
{
	int ca_ret;
	ca_ret = ca_check(x);
	if(!ca_ret) return 0;
	/* check nsCertType if present */
	if(x->ex_flags & EXFLAG_NSCERT) {
		if(x->ex_nscert & NS_SSL_CA) return ca_ret;
		return 0;
	}
	if(ca_ret != 2) return ca_ret;
	else return 0;
}

d358 1
a358 1
static int check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x, int ca)
d361 12
a372 1
	if(ca) return check_ssl_ca(x);
d380 1
a380 1
static int check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)
d383 2
a384 1
	if(ca) return check_ssl_ca(x);
d394 1
a394 1
static int check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)
d405 1
a405 1
static int purpose_smime(const X509 *x, int ca)
d429 1
a429 1
static int check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x, int ca)
d434 1
a434 1
	if(ku_reject(x, KU_DIGITAL_SIGNATURE|KU_NON_REPUDIATION)) return 0;
d438 1
a438 1
static int check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x, int ca)
d447 1
a447 1
static int check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x, int ca)
a456 83

/* OCSP helper: this is *not* a full OCSP check. It just checks that
 * each CA is valid. Additional checks must be made on the chain.
 */

static int ocsp_helper(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	/* Must be a valid CA */
	if(ca) {
		int ca_ret;
		ca_ret = ca_check(x);
		if(ca_ret != 2) return ca_ret;
		if(x->ex_flags & EXFLAG_NSCERT) {
			if(x->ex_nscert & NS_ANY_CA) return ca_ret;
			return 0;
		}
		return 0;
	}
	/* leaf certificate is checked in OCSP_verify() */
	return 1;
}

static int no_check(const X509_PURPOSE *xp, const X509 *x, int ca)
{
	return 1;
}

/* Various checks to see if one certificate issued the second.
 * This can be used to prune a set of possible issuer certificates
 * which have been looked up using some simple method such as by
 * subject name.
 * These are:
 * 1. Check issuer_name(subject) == subject_name(issuer)
 * 2. If akid(subject) exists check it matches issuer
 * 3. If key_usage(issuer) exists check it supports certificate signing
 * returns 0 for OK, positive for reason for mismatch, reasons match
 * codes for X509_verify_cert()
 */

int X509_check_issued(X509 *issuer, X509 *subject)
{
	if(X509_NAME_cmp(X509_get_subject_name(issuer),
			X509_get_issuer_name(subject)))
				return X509_V_ERR_SUBJECT_ISSUER_MISMATCH;
	x509v3_cache_extensions(issuer);
	x509v3_cache_extensions(subject);
	if(subject->akid) {
		/* Check key ids (if present) */
		if(subject->akid->keyid && issuer->skid &&
		 ASN1_OCTET_STRING_cmp(subject->akid->keyid, issuer->skid) )
				return X509_V_ERR_AKID_SKID_MISMATCH;
		/* Check serial number */
		if(subject->akid->serial &&
			ASN1_INTEGER_cmp(X509_get_serialNumber(issuer),
						subject->akid->serial))
				return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
		/* Check issuer name */
		if(subject->akid->issuer) {
			/* Ugh, for some peculiar reason AKID includes
			 * SEQUENCE OF GeneralName. So look for a DirName.
			 * There may be more than one but we only take any
			 * notice of the first.
			 */
			GENERAL_NAMES *gens;
			GENERAL_NAME *gen;
			X509_NAME *nm = NULL;
			int i;
			gens = subject->akid->issuer;
			for(i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
				gen = sk_GENERAL_NAME_value(gens, i);
				if(gen->type == GEN_DIRNAME) {
					nm = gen->d.dirn;
					break;
				}
			}
			if(nm && X509_NAME_cmp(nm, X509_get_issuer_name(issuer)))
				return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
		}
	}
	if(ku_reject(issuer, KU_KEY_CERT_SIGN)) return X509_V_ERR_KEYUSAGE_NO_CERTSIGN;
	return X509_V_OK;
}

@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@a380 4

				case NID_dvcs:
				x->ex_xkusage |= XKU_DVCS;
				break;
@


1.1.1.3
log
@import openssl-0.9.7d
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.
a417 1
 * 4 basicConstraints absent but keyUsage present and keyCertSign asserted.
d439 1
a439 1
		else if (x->ex_flags & EXFLAG_KUSAGE) return 4;
@


1.1.1.4
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d66 1
d289 1
a289 2
        	NID_ext_key_usage,	/* 126 */
		NID_proxyCertInfo	/* 661 */
a309 1
	PROXY_CERT_INFO_EXTENSION *pci;
a337 10
	/* Handle proxy certificates */
	if((pci=X509_get_ext_d2i(x, NID_proxyCertInfo, NULL, NULL))) {
		if (x->ex_flags & EXFLAG_CA
		    || X509_get_ext_by_NID(x, NID_subject_alt_name, 0) >= 0
		    || X509_get_ext_by_NID(x, NID_issuer_alt_name, 0) >= 0) {
			x->ex_flags |= EXFLAG_INVALID;
		}
		PROXY_CERT_INFO_EXTENSION_free(pci);
		x->ex_flags |= EXFLAG_PROXY;
	}
d429 1
a429 1
static int check_ca(const X509 *x)
a437 1
		/* we support V1 roots for...  uh, I don't really know why. */
d441 1
a441 5
		/* Older certificates could have Netscape-specific CA types */
		else if (x->ex_flags & EXFLAG_NSCERT
			 && x->ex_nscert & NS_ANY_CA) return 5;
		/* can this still be regarded a CA certificate?  I doubt it */
		return 0;
a444 11
int X509_check_ca(X509 *x)
{
	if(!(x->ex_flags & EXFLAG_SET)) {
		CRYPTO_w_lock(CRYPTO_LOCK_X509);
		x509v3_cache_extensions(x);
		CRYPTO_w_unlock(CRYPTO_LOCK_X509);
	}

	return check_ca(x);
}

d449 1
a449 1
	ca_ret = check_ca(x);
d452 5
a456 1
	if(ca_ret != 5 || x->ex_nscert & NS_SSL_CA) return ca_ret;
d501 1
a501 1
		ca_ret = check_ca(x);
d504 5
a508 1
		if(ca_ret != 5 || x->ex_nscert & NS_SMIME_CA) return ca_ret;
d542 1
a542 1
		if((ca_ret = check_ca(x)) != 2) return ca_ret;
d555 11
a565 3
	/* Must be a valid CA.  Should we really support the "I don't know"
	   value (2)? */
	if(ca) return check_ca(x);
d627 1
a627 7
	if(subject->ex_flags & EXFLAG_PROXY)
		{
		if(ku_reject(issuer, KU_DIGITAL_SIGNATURE))
			return X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE;
		}
	else if(ku_reject(issuer, KU_KEY_CERT_SIGN))
		return X509_V_ERR_KEYUSAGE_NO_CERTSIGN;
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d142 1
a142 1
	if(idx < (int)X509_PURPOSE_COUNT) return xstandard + idx;
d242 1
a242 1
	unsigned int i;
a287 1
		NID_certificate_policies, /* 89 */
a288 4
#ifndef OPENSSL_NO_RFC3779
		NID_sbgp_ipAddrBlock,	/* 290 */
		NID_sbgp_autonomousSysNum, /* 291 */
#endif
a345 4
		if (pci->pcPathLengthConstraint) {
			x->ex_pcpathlen =
				ASN1_INTEGER_get(pci->pcPathLengthConstraint);
		} else x->ex_pcpathlen = -1;
a408 5
#ifndef OPENSSL_NO_RFC3779
	x->rfc3779_addr =X509_get_ext_d2i(x, NID_sbgp_ipAddrBlock, NULL, NULL);
	x->rfc3779_asid =X509_get_ext_d2i(x, NID_sbgp_autonomousSysNum,
					  NULL, NULL);
#endif
@


1.1.1.6
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
d294 1
a294 3
		NID_policy_constraints,	/* 401 */
		NID_proxyCertInfo,	/* 661 */
		NID_inhibit_any_policy	/* 748 */
d328 1
a328 1
			 x->ex_flags |= EXFLAG_SI;
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@a73 1
static int check_purpose_timestamp_sign(const X509_PURPOSE *xp, const X509 *x, int ca);
a89 1
	{X509_PURPOSE_TIMESTAMP_SIGN, X509_TRUST_TSA, 0, check_purpose_timestamp_sign, "Time Stamp signing", "timestampsign", NULL},
d268 1
a268 1
static int nid_cmp(const int *a, const int *b)
a272 3
DECLARE_OBJ_BSEARCH_CMP_FN(int, int, nid);
IMPLEMENT_OBJ_BSEARCH_CMP_FN(int, int, nid);

d283 1
a283 1
	static const int supported_nids[] = {
d295 1
a295 3
		NID_proxyCertInfo,	/* 663 */
		NID_name_constraints,	/* 666 */
		NID_policy_mappings,	/* 747 */
d299 3
a301 1
	int ex_nid = OBJ_obj2nid(X509_EXTENSION_get_object(ex));
d306 3
a308 2
	if (OBJ_bsearch_nid(&ex_nid, supported_nids,
			sizeof(supported_nids)/sizeof(int)))
d312 1
a312 40

static void setup_dp(X509 *x, DIST_POINT *dp)
	{
	X509_NAME *iname = NULL;
	int i;
	if (dp->reasons)
		{
		if (dp->reasons->length > 0)
			dp->dp_reasons = dp->reasons->data[0];
		if (dp->reasons->length > 1)
			dp->dp_reasons |= (dp->reasons->data[1] << 8);
		dp->dp_reasons &= CRLDP_ALL_REASONS;
		}
	else
		dp->dp_reasons = CRLDP_ALL_REASONS;
	if (!dp->distpoint || (dp->distpoint->type != 1))
		return;
	for (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++)
		{
		GENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);
		if (gen->type == GEN_DIRNAME)
			{
			iname = gen->d.directoryName;
			break;
			}
		}
	if (!iname)
		iname = X509_get_issuer_name(x);

	DIST_POINT_set_dpname(dp->distpoint, iname);

	}

static void setup_crldp(X509 *x)
	{
	int i;
	x->crldp = X509_get_ext_d2i(x, NID_crl_distribution_points, NULL, NULL);
	for (i = 0; i < sk_DIST_POINT_num(x->crldp); i++)
		setup_dp(x, sk_DIST_POINT_value(x->crldp, i));
	}
a419 6
	x->altname = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);
	x->nc = X509_get_ext_d2i(x, NID_name_constraints, &i, NULL);
	if (!x->nc && (i != -1))
		x->ex_flags |= EXFLAG_INVALID;
	setup_crldp(x);

d421 3
a423 3
 	x->rfc3779_addr =X509_get_ext_d2i(x, NID_sbgp_ipAddrBlock, NULL, NULL);
 	x->rfc3779_asid =X509_get_ext_d2i(x, NID_sbgp_autonomousSysNum,
 					  NULL, NULL);
a429 3
		if (OBJ_obj2nid(X509_EXTENSION_get_object(ex))
					== NID_freshest_crl)
			x->ex_flags |= EXFLAG_FRESHEST;
a596 35
static int check_purpose_timestamp_sign(const X509_PURPOSE *xp, const X509 *x,
					int ca)
{
	int i_ext;

	/* If ca is true we must return if this is a valid CA certificate. */
	if (ca) return check_ca(x);

	/* 
	 * Check the optional key usage field:
	 * if Key Usage is present, it must be one of digitalSignature 
	 * and/or nonRepudiation (other values are not consistent and shall
	 * be rejected).
	 */
	if ((x->ex_flags & EXFLAG_KUSAGE)
	    && ((x->ex_kusage & ~(KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE)) ||
		!(x->ex_kusage & (KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE))))
		return 0;

	/* Only time stamp key usage is permitted and it's required. */
	if (!(x->ex_flags & EXFLAG_XKUSAGE) || x->ex_xkusage != XKU_TIMESTAMP)
		return 0;

	/* Extended Key Usage MUST be critical */
	i_ext = X509_get_ext_by_NID((X509 *) x, NID_ext_key_usage, 0);
	if (i_ext >= 0)
		{
		X509_EXTENSION *ext = X509_get_ext((X509 *) x, i_ext);
		if (!X509_EXTENSION_get_critical(ext))
			return 0;
		}

	return 1;
}

d621 31
a651 6

	if(subject->akid)
		{
		int ret = X509_check_akid(issuer, subject->akid);
		if (ret != X509_V_OK)
			return ret;
d653 1
a653 1

a662 42

int X509_check_akid(X509 *issuer, AUTHORITY_KEYID *akid)
	{

	if(!akid)
		return X509_V_OK;

	/* Check key ids (if present) */
	if(akid->keyid && issuer->skid &&
		 ASN1_OCTET_STRING_cmp(akid->keyid, issuer->skid) )
				return X509_V_ERR_AKID_SKID_MISMATCH;
	/* Check serial number */
	if(akid->serial &&
		ASN1_INTEGER_cmp(X509_get_serialNumber(issuer), akid->serial))
				return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
	/* Check issuer name */
	if(akid->issuer)
		{
		/* Ugh, for some peculiar reason AKID includes
		 * SEQUENCE OF GeneralName. So look for a DirName.
		 * There may be more than one but we only take any
		 * notice of the first.
		 */
		GENERAL_NAMES *gens;
		GENERAL_NAME *gen;
		X509_NAME *nm = NULL;
		int i;
		gens = akid->issuer;
		for(i = 0; i < sk_GENERAL_NAME_num(gens); i++)
			{
			gen = sk_GENERAL_NAME_value(gens, i);
			if(gen->type == GEN_DIRNAME)
				{
				nm = gen->d.dirn;
				break;
				}
			}
		if(nm && X509_NAME_cmp(nm, X509_get_issuer_name(issuer)))
			return X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;
		}
	return X509_V_OK;
	}
@


1.1.1.8
log
@Import OpenSSL 1.0.1g
@
text
@d477 2
a481 2
		if (!X509_EXTENSION_get_critical(ex))
			continue;
@


