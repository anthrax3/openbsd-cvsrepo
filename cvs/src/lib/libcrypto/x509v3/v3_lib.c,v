head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.2
	OPENBSD_6_1_BASE:1.17;
locks; strict;
comment	@ * @;


1.17
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.16;
commitid	kT0fLt3r4lroFJra;

1.16
date	2017.01.21.04.42.16;	author jsing;	state Exp;
branches;
next	1.15;
commitid	cj6ZwEZdOgoZ48c9;

1.15
date	2016.12.30.15.54.49;	author jsing;	state Exp;
branches;
next	1.14;
commitid	kn1H5Mumrqi1t2NN;

1.14
date	2015.02.10.11.22.22;	author jsing;	state Exp;
branches;
next	1.13;
commitid	LaAI4ax0sm4T2bQg;

1.13
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.12;
commitid	yQEL1wOWIearrW15;

1.12
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	mJUVYpkFBZ0Zv2bG;

1.11
date	2014.04.21.16.59.26;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.21.16.08.08;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.18;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.12.19;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.54;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.03;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.11.21.18.12;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.14.01;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: v3_lib.c,v 1.16 2017/01/21 04:42:16 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999.
 */
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* X509 v3 extension utilities */

#include <stdio.h>

#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/x509v3.h>

#include "ext_dat.h"

static STACK_OF(X509V3_EXT_METHOD) *ext_list = NULL;

static int ext_cmp(const X509V3_EXT_METHOD * const *a,
    const X509V3_EXT_METHOD * const *b);
static void ext_list_free(X509V3_EXT_METHOD *ext);

int
X509V3_EXT_add(X509V3_EXT_METHOD *ext)
{
	if (!ext_list && !(ext_list = sk_X509V3_EXT_METHOD_new(ext_cmp))) {
		X509V3error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	if (!sk_X509V3_EXT_METHOD_push(ext_list, ext)) {
		X509V3error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	return 1;
}

static int
ext_cmp(const X509V3_EXT_METHOD * const *a, const X509V3_EXT_METHOD * const *b)
{
	return ((*a)->ext_nid - (*b)->ext_nid);
}

static int ext_cmp_BSEARCH_CMP_FN(const void *, const void *);
static int ext_cmp(const X509V3_EXT_METHOD * const *, const X509V3_EXT_METHOD * const *);
static const X509V3_EXT_METHOD * *OBJ_bsearch_ext(const X509V3_EXT_METHOD * *key, const X509V3_EXT_METHOD * const *base, int num);

static int
ext_cmp_BSEARCH_CMP_FN(const void *a_, const void *b_)
{
	const X509V3_EXT_METHOD * const *a = a_;
	const X509V3_EXT_METHOD * const *b = b_;
	return ext_cmp(a, b);
}

static const X509V3_EXT_METHOD * *
OBJ_bsearch_ext(const X509V3_EXT_METHOD * *key, const X509V3_EXT_METHOD * const *base, int num)
{
	return (const X509V3_EXT_METHOD * *)OBJ_bsearch_(key, base, num, sizeof(const X509V3_EXT_METHOD *),
	    ext_cmp_BSEARCH_CMP_FN);
}

const X509V3_EXT_METHOD *
X509V3_EXT_get_nid(int nid)
{
	X509V3_EXT_METHOD tmp;
	const X509V3_EXT_METHOD *t = &tmp, * const *ret;
	int idx;

	if (nid < 0)
		return NULL;
	tmp.ext_nid = nid;
	ret = OBJ_bsearch_ext(&t, standard_exts, STANDARD_EXTENSION_COUNT);
	if (ret)
		return *ret;
	if (!ext_list)
		return NULL;
	idx = sk_X509V3_EXT_METHOD_find(ext_list, &tmp);
	if (idx == -1)
		return NULL;
	return sk_X509V3_EXT_METHOD_value(ext_list, idx);
}

const X509V3_EXT_METHOD *
X509V3_EXT_get(X509_EXTENSION *ext)
{
	int nid;

	if ((nid = OBJ_obj2nid(ext->object)) == NID_undef)
		return NULL;
	return X509V3_EXT_get_nid(nid);
}

int
X509V3_EXT_add_list(X509V3_EXT_METHOD *extlist)
{
	for (; extlist->ext_nid!=-1; extlist++)
		if (!X509V3_EXT_add(extlist))
			return 0;
	return 1;
}

int
X509V3_EXT_add_alias(int nid_to, int nid_from)
{
	const X509V3_EXT_METHOD *ext;
	X509V3_EXT_METHOD *tmpext;

	if (!(ext = X509V3_EXT_get_nid(nid_from))) {
		X509V3error(X509V3_R_EXTENSION_NOT_FOUND);
		return 0;
	}
	if (!(tmpext = malloc(sizeof(X509V3_EXT_METHOD)))) {
		X509V3error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	*tmpext = *ext;
	tmpext->ext_nid = nid_to;
	tmpext->ext_flags |= X509V3_EXT_DYNAMIC;
	return X509V3_EXT_add(tmpext);
}

void
X509V3_EXT_cleanup(void)
{
	sk_X509V3_EXT_METHOD_pop_free(ext_list, ext_list_free);
	ext_list = NULL;
}

static void
ext_list_free(X509V3_EXT_METHOD *ext)
{
	if (ext->ext_flags & X509V3_EXT_DYNAMIC)
		free(ext);
}

/* Legacy function: we don't need to add standard extensions
 * any more because they are now kept in ext_dat.h.
 */

int
X509V3_add_standard_extensions(void)
{
	return 1;
}

/* Return an extension internal structure */

void *
X509V3_EXT_d2i(X509_EXTENSION *ext)
{
	const X509V3_EXT_METHOD *method;
	const unsigned char *p;

	if (!(method = X509V3_EXT_get(ext)))
		return NULL;
	p = ext->value->data;
	if (method->it)
		return ASN1_item_d2i(NULL, &p, ext->value->length,
		    method->it);
	return method->d2i(NULL, &p, ext->value->length);
}

/* Get critical flag and decoded version of extension from a NID.
 * The "idx" variable returns the last found extension and can
 * be used to retrieve multiple extensions of the same NID.
 * However multiple extensions with the same NID is usually
 * due to a badly encoded certificate so if idx is NULL we
 * choke if multiple extensions exist.
 * The "crit" variable is set to the critical value.
 * The return value is the decoded extension or NULL on
 * error. The actual error can have several different causes,
 * the value of *crit reflects the cause:
 * >= 0, extension found but not decoded (reflects critical value).
 * -1 extension not found.
 * -2 extension occurs more than once.
 */

void *
X509V3_get_d2i(STACK_OF(X509_EXTENSION) *x, int nid, int *crit, int *idx)
{
	int lastpos, i;
	X509_EXTENSION *ex, *found_ex = NULL;

	if (!x) {
		if (idx)
			*idx = -1;
		if (crit)
			*crit = -1;
		return NULL;
	}
	if (idx)
		lastpos = *idx + 1;
	else
		lastpos = 0;
	if (lastpos < 0)
		lastpos = 0;
	for (i = lastpos; i < sk_X509_EXTENSION_num(x); i++) {
		ex = sk_X509_EXTENSION_value(x, i);
		if (OBJ_obj2nid(ex->object) == nid) {
			if (idx) {
				*idx = i;
				found_ex = ex;
				break;
			} else if (found_ex) {
				/* Found more than one */
				if (crit)
					*crit = -2;
				return NULL;
			}
			found_ex = ex;
		}
	}
	if (found_ex) {
		/* Found it */
		if (crit)
			*crit = X509_EXTENSION_get_critical(found_ex);
		return X509V3_EXT_d2i(found_ex);
	}

	/* Extension not found */
	if (idx)
		*idx = -1;
	if (crit)
		*crit = -1;
	return NULL;
}

/* This function is a general extension append, replace and delete utility.
 * The precise operation is governed by the 'flags' value. The 'crit' and
 * 'value' arguments (if relevant) are the extensions internal structure.
 */

int
X509V3_add1_i2d(STACK_OF(X509_EXTENSION) **x, int nid, void *value,
    int crit, unsigned long flags)
{
	int extidx = -1;
	int errcode;
	X509_EXTENSION *ext, *extmp;
	unsigned long ext_op = flags & X509V3_ADD_OP_MASK;

	/* If appending we don't care if it exists, otherwise
	 * look for existing extension.
	 */
	if (ext_op != X509V3_ADD_APPEND)
		extidx = X509v3_get_ext_by_NID(*x, nid, -1);

	/* See if extension exists */
	if (extidx >= 0) {
		/* If keep existing, nothing to do */
		if (ext_op == X509V3_ADD_KEEP_EXISTING)
			return 1;
		/* If default then its an error */
		if (ext_op == X509V3_ADD_DEFAULT) {
			errcode = X509V3_R_EXTENSION_EXISTS;
			goto err;
		}
		/* If delete, just delete it */
		if (ext_op == X509V3_ADD_DELETE) {
			if (!sk_X509_EXTENSION_delete(*x, extidx))
				return -1;
			return 1;
		}
	} else {
		/* If replace existing or delete, error since
		 * extension must exist
		 */
		if ((ext_op == X509V3_ADD_REPLACE_EXISTING) ||
		    (ext_op == X509V3_ADD_DELETE)) {
			errcode = X509V3_R_EXTENSION_NOT_FOUND;
			goto err;
		}
	}

	/* If we get this far then we have to create an extension:
	 * could have some flags for alternative encoding schemes...
	 */

	ext = X509V3_EXT_i2d(nid, crit, value);

	if (!ext) {
		X509V3error(X509V3_R_ERROR_CREATING_EXTENSION);
		return 0;
	}

	/* If extension exists replace it.. */
	if (extidx >= 0) {
		extmp = sk_X509_EXTENSION_value(*x, extidx);
		X509_EXTENSION_free(extmp);
		if (!sk_X509_EXTENSION_set(*x, extidx, ext))
			return -1;
		return 1;
	}

	if (!*x && !(*x = sk_X509_EXTENSION_new_null()))
		return -1;
	if (!sk_X509_EXTENSION_push(*x, ext))
		return -1;

	return 1;

err:
	if (!(flags & X509V3_ADD_SILENT))
		X509V3error(errcode);
	return 0;
}
@


1.16
log
@Expand DECLARE_OBJ_BSEARCH_CMP_FN and IMPLEMENT_OBJ_BSEARCH_CMP_FN macros.

No change to generated assembly excluding line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_lib.c,v 1.15 2016/12/30 15:54:49 jsing Exp $ */
d78 1
a78 1
		X509V3err(X509V3_F_X509V3_EXT_ADD, ERR_R_MALLOC_FAILURE);
d82 1
a82 1
		X509V3err(X509V3_F_X509V3_EXT_ADD, ERR_R_MALLOC_FAILURE);
d160 1
a160 2
		X509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS,
		    X509V3_R_EXTENSION_NOT_FOUND);
d164 1
a164 1
		X509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS, ERR_R_MALLOC_FAILURE);
d333 1
a333 2
		X509V3err(X509V3_F_X509V3_ADD1_I2D,
		    X509V3_R_ERROR_CREATING_EXTENSION);
d355 1
a355 1
		X509V3err(X509V3_F_X509V3_ADD1_I2D, errcode);
@


1.15
log
@Expand ASN1_ITEM_ref and ASN1_ITEM_ptr macros - no change in generated
assembly. Of particular interest is ASN1_ITEM_ptr which does nothing
and resulted in code like:

  if (method->it)
    ASN1_ITEM_free(..., ASN1_ITEM_ptr(method->it));
@
text
@d1 1
a1 1
/* $OpenBSD: v3_lib.c,v 1.14 2015/02/10 11:22:22 jsing Exp $ */
d94 18
a111 4
DECLARE_OBJ_BSEARCH_CMP_FN(const X509V3_EXT_METHOD *,
    const X509V3_EXT_METHOD *, ext);
IMPLEMENT_OBJ_BSEARCH_CMP_FN(const X509V3_EXT_METHOD *,
    const X509V3_EXT_METHOD *, ext);
@


1.14
log
@Remove more IMPLEMENT_STACK_OF noops that have been hiding for the last
15 years.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_lib.c,v 1.13 2014/07/11 08:44:49 jsing Exp $ */
d197 1
a197 1
		    ASN1_ITEM_ptr(method->it));
@


1.13
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_lib.c,v 1.12 2014/06/12 15:49:31 deraadt Exp $ */
a345 2

IMPLEMENT_STACK_OF(X509V3_EXT_METHOD)
@


1.12
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d61 1
a61 1
#include "cryptlib.h"
d63 1
@


1.11
log
@KNF.
@
text
@d1 1
a1 1
/* v3_lib.c */
@


1.10
log
@no need for malloc casts
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d70 1
a70 1
		const X509V3_EXT_METHOD * const *b);
d73 2
a74 1
int X509V3_EXT_add(X509V3_EXT_METHOD *ext)
d76 2
a77 2
	if(!ext_list && !(ext_list = sk_X509V3_EXT_METHOD_new(ext_cmp))) {
		X509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);
d80 2
a81 2
	if(!sk_X509V3_EXT_METHOD_push(ext_list, ext)) {
		X509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);
d87 2
a88 2
static int ext_cmp(const X509V3_EXT_METHOD * const *a,
		   const X509V3_EXT_METHOD * const *b)
d93 2
a94 2
DECLARE_OBJ_BSEARCH_CMP_FN(const X509V3_EXT_METHOD *, const X509V3_EXT_METHOD *,
			   ext);
d96 1
a96 1
			     const X509V3_EXT_METHOD *, ext);
d98 2
a99 1
const X509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid)
d104 3
a106 1
	if(nid < 0) return NULL;
d109 4
a112 2
	if(ret) return *ret;
	if(!ext_list) return NULL;
d114 2
a115 1
	if(idx == -1) return NULL;
d119 2
a120 1
const X509V3_EXT_METHOD *X509V3_EXT_get(X509_EXTENSION *ext)
d123 3
a125 1
	if((nid = OBJ_obj2nid(ext->object)) == NID_undef) return NULL;
d129 2
a130 2

int X509V3_EXT_add_list(X509V3_EXT_METHOD *extlist)
d132 3
a134 2
	for(;extlist->ext_nid!=-1;extlist++) 
			if(!X509V3_EXT_add(extlist)) return 0;
d138 2
a139 1
int X509V3_EXT_add_alias(int nid_to, int nid_from)
d144 3
a146 2
	if(!(ext = X509V3_EXT_get_nid(nid_from))) {
		X509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS,X509V3_R_EXTENSION_NOT_FOUND);
d149 2
a150 2
	if(!(tmpext = malloc(sizeof(X509V3_EXT_METHOD)))) {
		X509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS,ERR_R_MALLOC_FAILURE);
d159 2
a160 1
void X509V3_EXT_cleanup(void)
d166 2
a167 1
static void ext_list_free(X509V3_EXT_METHOD *ext)
d169 2
a170 1
	if(ext->ext_flags & X509V3_EXT_DYNAMIC) free(ext);
d177 2
a178 1
int X509V3_add_standard_extensions(void)
d185 2
a186 1
void *X509V3_EXT_d2i(X509_EXTENSION *ext)
d191 2
a192 1
	if(!(method = X509V3_EXT_get(ext))) return NULL;
d194 3
a196 1
	if(method->it) return ASN1_item_d2i(NULL, &p, ext->value->length, ASN1_ITEM_ptr(method->it));
d215 2
a216 1
void *X509V3_get_d2i(STACK_OF(X509_EXTENSION) *x, int nid, int *crit, int *idx)
d220 6
a225 3
	if(!x) {
		if(idx) *idx = -1;
		if(crit) *crit = -1;
d228 7
a234 5
	if(idx) lastpos = *idx + 1;
	else lastpos = 0;
	if(lastpos < 0) lastpos = 0;
	for(i = lastpos; i < sk_X509_EXTENSION_num(x); i++)
	{
d236 2
a237 2
		if(OBJ_obj2nid(ex->object) == nid) {
			if(idx) {
d241 1
a241 1
			} else if(found_ex) {
d243 2
a244 1
				if(crit) *crit = -2;
d250 1
a250 1
	if(found_ex) {
d252 2
a253 1
		if(crit) *crit = X509_EXTENSION_get_critical(found_ex);
d258 4
a261 2
	if(idx) *idx = -1;
	if(crit) *crit = -1;
d270 3
a272 2
int X509V3_add1_i2d(STACK_OF(X509_EXTENSION) **x, int nid, void *value,
					int crit, unsigned long flags)
d282 1
a282 1
	if(ext_op != X509V3_ADD_APPEND)
d286 1
a286 1
	if(extidx >= 0) {
d288 1
a288 1
		if(ext_op == X509V3_ADD_KEEP_EXISTING)
d291 1
a291 1
		if(ext_op == X509V3_ADD_DEFAULT) {
d296 3
a298 2
		if(ext_op == X509V3_ADD_DELETE) {
			if(!sk_X509_EXTENSION_delete(*x, extidx)) return -1;
d302 1
a302 1
		/* If replace existing or delete, error since 
d305 2
a306 2
		if((ext_op == X509V3_ADD_REPLACE_EXISTING) ||
		   (ext_op == X509V3_ADD_DELETE)) {
d318 3
a320 2
	if(!ext) {
		X509V3err(X509V3_F_X509V3_ADD1_I2D, X509V3_R_ERROR_CREATING_EXTENSION);
d325 1
a325 1
	if(extidx >= 0) {
d328 2
a329 1
		if(!sk_X509_EXTENSION_set(*x, extidx, ext)) return -1;
d333 4
a336 2
	if(!*x && !(*x = sk_X509_EXTENSION_new_null())) return -1;
	if(!sk_X509_EXTENSION_push(*x, ext)) return -1;
d340 2
a341 2
	err:
	if(!(flags & X509V3_ADD_SILENT))
@


1.9
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d136 1
a136 1
	if(!(tmpext = (X509V3_EXT_METHOD *)malloc(sizeof(X509V3_EXT_METHOD)))) {
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d136 1
a136 1
	if(!(tmpext = (X509V3_EXT_METHOD *)OPENSSL_malloc(sizeof(X509V3_EXT_METHOD)))) {
d154 1
a154 1
	if(ext->ext_flags & X509V3_EXT_DYNAMIC) OPENSSL_free(ext);
@


1.7
log
@resolve conflicts
@
text
@d87 1
a87 1
		const X509V3_EXT_METHOD * const *b)
d92 6
a97 1
X509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid)
d99 2
a100 1
	X509V3_EXT_METHOD tmp, *t = &tmp, **ret;
d104 1
a104 3
	ret = (X509V3_EXT_METHOD **) OBJ_bsearch((char *)&t,
			(char *)standard_exts, STANDARD_EXTENSION_COUNT,
			sizeof(X509V3_EXT_METHOD *), (int (*)(const void *, const void *))ext_cmp);
d112 1
a112 1
X509V3_EXT_METHOD *X509V3_EXT_get(X509_EXTENSION *ext)
d129 3
a131 1
	X509V3_EXT_METHOD *ext, *tmpext;
d170 1
a170 1
	X509V3_EXT_METHOD *method;
@


1.6
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.5
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d165 2
a166 1
	unsigned char *p;
d280 1
a280 1
		X509V3err(X509V3_F_X509V3_ADD_I2D, X509V3_R_ERROR_CREATING_EXTENSION);
d299 1
a299 1
		X509V3err(X509V3_F_X509V3_ADD_I2D, errcode);
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d205 1
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d166 1
a166 1
	if(!(method = X509V3_EXT_get(ext)) || !method->d2i) return NULL;
d168 1
d216 1
a216 1
		if(crit) *crit = found_ex->critical;
d224 75
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d67 1
a67 1
static STACK *ext_list = NULL;
d69 2
a70 1
static int ext_cmp(X509V3_EXT_METHOD **a, X509V3_EXT_METHOD **b);
d75 1
a75 1
	if(!ext_list && !(ext_list = sk_new(ext_cmp))) {
d79 1
a79 1
	if(!sk_push(ext_list, (char *)ext)) {
d86 2
a87 1
static int ext_cmp(X509V3_EXT_METHOD **a, X509V3_EXT_METHOD **b)
d100 1
a100 1
			sizeof(X509V3_EXT_METHOD *), (int (*)())ext_cmp);
d103 1
a103 1
	idx = sk_find(ext_list, (char *)&tmp);
d105 1
a105 1
	return (X509V3_EXT_METHOD *)sk_value(ext_list, idx);
d130 1
a130 1
	if(!(tmpext = (X509V3_EXT_METHOD *)Malloc(sizeof(X509V3_EXT_METHOD)))) {
d142 1
a142 1
	sk_pop_free(ext_list, ext_list_free);
d148 1
a148 1
	if(ext->ext_flags & X509V3_EXT_DYNAMIC) Free(ext);
d218 1
a218 1
	
d224 2
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d65 2
d92 1
a92 1
	X509V3_EXT_METHOD tmp;
d94 1
d96 5
a100 1
	if(!ext_list || (tmp.ext_nid < 0) ) return NULL;
d135 1
a135 1
	return 1;
d149 3
a151 5
extern X509V3_EXT_METHOD v3_bcons, v3_nscert, v3_key_usage, v3_ext_ku;
extern X509V3_EXT_METHOD v3_pkey_usage_period, v3_sxnet;
extern X509V3_EXT_METHOD v3_ns_ia5_list[], v3_alt[], v3_skey_id, v3_akey_id;

extern X509V3_EXT_METHOD v3_crl_num, v3_crl_reason, v3_cpols, v3_crld;
a154 14
	X509V3_EXT_add_list(v3_ns_ia5_list);
	X509V3_EXT_add_list(v3_alt);
	X509V3_EXT_add(&v3_bcons);
	X509V3_EXT_add(&v3_nscert);
	X509V3_EXT_add(&v3_key_usage);
	X509V3_EXT_add(&v3_ext_ku);
	X509V3_EXT_add(&v3_skey_id);
	X509V3_EXT_add(&v3_akey_id);
	X509V3_EXT_add(&v3_pkey_usage_period);
	X509V3_EXT_add(&v3_crl_num);
	X509V3_EXT_add(&v3_sxnet);
	X509V3_EXT_add(&v3_crl_reason);
	X509V3_EXT_add(&v3_cpols);
	X509V3_EXT_add(&v3_crld);
d169 53
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d65 1
a65 1
#include "ext_dat.h"
d67 1
a67 4
static STACK_OF(X509V3_EXT_METHOD) *ext_list = NULL;

static int ext_cmp(const X509V3_EXT_METHOD * const *a,
		const X509V3_EXT_METHOD * const *b);
d72 1
a72 1
	if(!ext_list && !(ext_list = sk_X509V3_EXT_METHOD_new(ext_cmp))) {
d76 1
a76 1
	if(!sk_X509V3_EXT_METHOD_push(ext_list, ext)) {
d83 1
a83 2
static int ext_cmp(const X509V3_EXT_METHOD * const *a,
		const X509V3_EXT_METHOD * const *b)
d90 1
a90 1
	X509V3_EXT_METHOD tmp, *t = &tmp, **ret;
a91 1
	if(nid < 0) return NULL;
d93 2
a94 6
	ret = (X509V3_EXT_METHOD **) OBJ_bsearch((char *)&t,
			(char *)standard_exts, STANDARD_EXTENSION_COUNT,
			sizeof(X509V3_EXT_METHOD *), (int (*)(const void *, const void *))ext_cmp);
	if(ret) return *ret;
	if(!ext_list) return NULL;
	idx = sk_X509V3_EXT_METHOD_find(ext_list, &tmp);
d96 1
a96 1
	return sk_X509V3_EXT_METHOD_value(ext_list, idx);
d121 1
a121 1
	if(!(tmpext = (X509V3_EXT_METHOD *)OPENSSL_malloc(sizeof(X509V3_EXT_METHOD)))) {
d128 1
a128 1
	return X509V3_EXT_add(tmpext);
d133 1
a133 1
	sk_X509V3_EXT_METHOD_pop_free(ext_list, ext_list_free);
d139 1
a139 1
	if(ext->ext_flags & X509V3_EXT_DYNAMIC) OPENSSL_free(ext);
d142 5
a146 3
/* Legacy function: we don't need to add standard extensions
 * any more because they are now kept in ext_dat.h.
 */
d150 14
d173 1
a173 1
	if(!(method = X509V3_EXT_get(ext))) return NULL;
a174 1
	if(method->it) return ASN1_item_d2i(NULL, &p, ext->value->length, ASN1_ITEM_ptr(method->it));
a177 130
/* Get critical flag and decoded version of extension from a NID.
 * The "idx" variable returns the last found extension and can
 * be used to retrieve multiple extensions of the same NID.
 * However multiple extensions with the same NID is usually
 * due to a badly encoded certificate so if idx is NULL we
 * choke if multiple extensions exist.
 * The "crit" variable is set to the critical value.
 * The return value is the decoded extension or NULL on
 * error. The actual error can have several different causes,
 * the value of *crit reflects the cause:
 * >= 0, extension found but not decoded (reflects critical value).
 * -1 extension not found.
 * -2 extension occurs more than once.
 */

void *X509V3_get_d2i(STACK_OF(X509_EXTENSION) *x, int nid, int *crit, int *idx)
{
	int lastpos, i;
	X509_EXTENSION *ex, *found_ex = NULL;
	if(!x) {
		if(idx) *idx = -1;
		if(crit) *crit = -1;
		return NULL;
	}
	if(idx) lastpos = *idx + 1;
	else lastpos = 0;
	if(lastpos < 0) lastpos = 0;
	for(i = lastpos; i < sk_X509_EXTENSION_num(x); i++)
	{
		ex = sk_X509_EXTENSION_value(x, i);
		if(OBJ_obj2nid(ex->object) == nid) {
			if(idx) {
				*idx = i;
				break;
			} else if(found_ex) {
				/* Found more than one */
				if(crit) *crit = -2;
				return NULL;
			}
			found_ex = ex;
		}
	}
	if(found_ex) {
		/* Found it */
		if(crit) *crit = X509_EXTENSION_get_critical(found_ex);
		return X509V3_EXT_d2i(found_ex);
	}

	/* Extension not found */
	if(idx) *idx = -1;
	if(crit) *crit = -1;
	return NULL;
}

/* This function is a general extension append, replace and delete utility.
 * The precise operation is governed by the 'flags' value. The 'crit' and
 * 'value' arguments (if relevant) are the extensions internal structure.
 */

int X509V3_add1_i2d(STACK_OF(X509_EXTENSION) **x, int nid, void *value,
					int crit, unsigned long flags)
{
	int extidx = -1;
	int errcode;
	X509_EXTENSION *ext, *extmp;
	unsigned long ext_op = flags & X509V3_ADD_OP_MASK;

	/* If appending we don't care if it exists, otherwise
	 * look for existing extension.
	 */
	if(ext_op != X509V3_ADD_APPEND)
		extidx = X509v3_get_ext_by_NID(*x, nid, -1);

	/* See if extension exists */
	if(extidx >= 0) {
		/* If keep existing, nothing to do */
		if(ext_op == X509V3_ADD_KEEP_EXISTING)
			return 1;
		/* If default then its an error */
		if(ext_op == X509V3_ADD_DEFAULT) {
			errcode = X509V3_R_EXTENSION_EXISTS;
			goto err;
		}
		/* If delete, just delete it */
		if(ext_op == X509V3_ADD_DELETE) {
			if(!sk_X509_EXTENSION_delete(*x, extidx)) return -1;
			return 1;
		}
	} else {
		/* If replace existing or delete, error since 
		 * extension must exist
		 */
		if((ext_op == X509V3_ADD_REPLACE_EXISTING) ||
		   (ext_op == X509V3_ADD_DELETE)) {
			errcode = X509V3_R_EXTENSION_NOT_FOUND;
			goto err;
		}
	}

	/* If we get this far then we have to create an extension:
	 * could have some flags for alternative encoding schemes...
	 */

	ext = X509V3_EXT_i2d(nid, crit, value);

	if(!ext) {
		X509V3err(X509V3_F_X509V3_ADD_I2D, X509V3_R_ERROR_CREATING_EXTENSION);
		return 0;
	}

	/* If extension exists replace it.. */
	if(extidx >= 0) {
		extmp = sk_X509_EXTENSION_value(*x, extidx);
		X509_EXTENSION_free(extmp);
		if(!sk_X509_EXTENSION_set(*x, extidx, ext)) return -1;
		return 1;
	}

	if(!*x && !(*x = sk_X509_EXTENSION_new_null())) return -1;
	if(!sk_X509_EXTENSION_push(*x, ext)) return -1;

	return 1;

	err:
	if(!(flags & X509V3_ADD_SILENT))
		X509V3err(X509V3_F_X509V3_ADD_I2D, errcode);
	return 0;
}

IMPLEMENT_STACK_OF(X509V3_EXT_METHOD)
@


1.1.1.2
log
@import 0.9.7c
@
text
@a204 1
				found_ex = ex;
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d165 1
a165 2
	const unsigned char *p;

d279 1
a279 1
		X509V3err(X509V3_F_X509V3_ADD1_I2D, X509V3_R_ERROR_CREATING_EXTENSION);
d298 1
a298 1
		X509V3err(X509V3_F_X509V3_ADD1_I2D, errcode);
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d87 1
a87 1
		   const X509V3_EXT_METHOD * const *b)
d92 1
a92 6
DECLARE_OBJ_BSEARCH_CMP_FN(const X509V3_EXT_METHOD *, const X509V3_EXT_METHOD *,
			   ext);
IMPLEMENT_OBJ_BSEARCH_CMP_FN(const X509V3_EXT_METHOD *,
			     const X509V3_EXT_METHOD *, ext);

const X509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid)
d94 1
a94 2
	X509V3_EXT_METHOD tmp;
	const X509V3_EXT_METHOD *t = &tmp, * const *ret;
d98 3
a100 1
	ret = OBJ_bsearch_ext(&t, standard_exts, STANDARD_EXTENSION_COUNT);
d108 1
a108 1
const X509V3_EXT_METHOD *X509V3_EXT_get(X509_EXTENSION *ext)
d125 1
a125 3
	const X509V3_EXT_METHOD *ext;
	X509V3_EXT_METHOD *tmpext;

d164 1
a164 1
	const X509V3_EXT_METHOD *method;
@


