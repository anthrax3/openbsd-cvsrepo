head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.2
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25;
locks; strict;
comment	@ * @;


1.25
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.24;
commitid	kT0fLt3r4lroFJra;

1.24
date	2016.12.30.15.54.49;	author jsing;	state Exp;
branches;
next	1.23;
commitid	kn1H5Mumrqi1t2NN;

1.23
date	2015.09.30.18.21.50;	author jsing;	state Exp;
branches;
next	1.22;
commitid	W41jP34sV2UzYLCa;

1.22
date	2015.07.29.16.13.48;	author jsing;	state Exp;
branches;
next	1.21;
commitid	p0YErzIitgRtixdM;

1.21
date	2015.07.25.16.00.14;	author jsing;	state Exp;
branches;
next	1.20;
commitid	IQmUl7Av61G6tr84;

1.20
date	2015.07.15.17.00.35;	author miod;	state Exp;
branches;
next	1.19;
commitid	56CQQhqlmQ8UzQqn;

1.19
date	2015.02.14.15.17.52;	author miod;	state Exp;
branches;
next	1.18;
commitid	4aZvBtran2stBrnQ;

1.18
date	2015.02.10.11.22.22;	author jsing;	state Exp;
branches;
next	1.17;
commitid	LaAI4ax0sm4T2bQg;

1.17
date	2015.02.09.16.03.11;	author jsing;	state Exp;
branches;
next	1.16;
commitid	xIhBiKP17QbaVYG2;

1.16
date	2014.10.05.18.27.33;	author miod;	state Exp;
branches;
next	1.15;
commitid	IgX6FbzqYSI29Vk1;

1.15
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.14;
commitid	yQEL1wOWIearrW15;

1.14
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.13;
commitid	id8dTrTMtnTn4fqt;

1.13
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	mJUVYpkFBZ0Zv2bG;

1.12
date	2014.04.21.14.27.06;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.16;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.12.18;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.53;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.02;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.11.21.18.09;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.06.27.05.05.36;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.14.01;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.04.06.06.30.05;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: v3_cpols.c,v 1.24 2016/12/30 15:54:49 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999.
 */
/* ====================================================================
 * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/asn1.h>
#include <openssl/asn1t.h>
#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/x509v3.h>

#include "pcy_int.h"

/* Certificate policies extension support: this one is a bit complex... */

static int i2r_certpol(X509V3_EXT_METHOD *method, STACK_OF(POLICYINFO) *pol,
    BIO *out, int indent);
static STACK_OF(POLICYINFO) *r2i_certpol(X509V3_EXT_METHOD *method,
    X509V3_CTX *ctx, char *value);
static void print_qualifiers(BIO *out, STACK_OF(POLICYQUALINFO) *quals,
    int indent);
static void print_notice(BIO *out, USERNOTICE *notice, int indent);
static POLICYINFO *policy_section(X509V3_CTX *ctx,
    STACK_OF(CONF_VALUE) *polstrs, int ia5org);
static POLICYQUALINFO *notice_section(X509V3_CTX *ctx,
    STACK_OF(CONF_VALUE) *unot, int ia5org);
static int nref_nos(STACK_OF(ASN1_INTEGER) *nnums, STACK_OF(CONF_VALUE) *nos);

const X509V3_EXT_METHOD v3_cpols = {
	.ext_nid = NID_certificate_policies,
	.ext_flags = 0,
	.it = &CERTIFICATEPOLICIES_it,
	.ext_new = NULL,
	.ext_free = NULL,
	.d2i = NULL,
	.i2d = NULL,
	.i2s = NULL,
	.s2i = NULL,
	.i2v = NULL,
	.v2i = NULL,
	.i2r = (X509V3_EXT_I2R)i2r_certpol,
	.r2i = (X509V3_EXT_R2I)r2i_certpol,
	.usr_data = NULL,
};

static const ASN1_TEMPLATE CERTIFICATEPOLICIES_item_tt = {
	.flags = ASN1_TFLG_SEQUENCE_OF,
	.tag = 0,
	.offset = 0,
	.field_name = "CERTIFICATEPOLICIES",
	.item = &POLICYINFO_it,
};

const ASN1_ITEM CERTIFICATEPOLICIES_it = {
	.itype = ASN1_ITYPE_PRIMITIVE,
	.utype = -1,
	.templates = &CERTIFICATEPOLICIES_item_tt,
	.tcount = 0,
	.funcs = NULL,
	.size = 0,
	.sname = "CERTIFICATEPOLICIES",
};


CERTIFICATEPOLICIES *
d2i_CERTIFICATEPOLICIES(CERTIFICATEPOLICIES **a, const unsigned char **in, long len)
{
	return (CERTIFICATEPOLICIES *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &CERTIFICATEPOLICIES_it);
}

int
i2d_CERTIFICATEPOLICIES(CERTIFICATEPOLICIES *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &CERTIFICATEPOLICIES_it);
}

CERTIFICATEPOLICIES *
CERTIFICATEPOLICIES_new(void)
{
	return (CERTIFICATEPOLICIES *)ASN1_item_new(&CERTIFICATEPOLICIES_it);
}

void
CERTIFICATEPOLICIES_free(CERTIFICATEPOLICIES *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &CERTIFICATEPOLICIES_it);
}

static const ASN1_TEMPLATE POLICYINFO_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(POLICYINFO, policyid),
		.field_name = "policyid",
		.item = &ASN1_OBJECT_it,
	},
	{
		.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(POLICYINFO, qualifiers),
		.field_name = "qualifiers",
		.item = &POLICYQUALINFO_it,
	},
};

const ASN1_ITEM POLICYINFO_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = POLICYINFO_seq_tt,
	.tcount = sizeof(POLICYINFO_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(POLICYINFO),
	.sname = "POLICYINFO",
};


POLICYINFO *
d2i_POLICYINFO(POLICYINFO **a, const unsigned char **in, long len)
{
	return (POLICYINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &POLICYINFO_it);
}

int
i2d_POLICYINFO(POLICYINFO *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &POLICYINFO_it);
}

POLICYINFO *
POLICYINFO_new(void)
{
	return (POLICYINFO *)ASN1_item_new(&POLICYINFO_it);
}

void
POLICYINFO_free(POLICYINFO *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &POLICYINFO_it);
}

static const ASN1_TEMPLATE policydefault_tt = {
	.flags = 0,
	.tag = 0,
	.offset = offsetof(POLICYQUALINFO, d.other),
	.field_name = "d.other",
	.item = &ASN1_ANY_it,
};

static const ASN1_ADB_TABLE POLICYQUALINFO_adbtbl[] = {
	{
		.value = NID_id_qt_cps,
		.tt = {
			.flags = 0,
			.tag = 0,
			.offset = offsetof(POLICYQUALINFO, d.cpsuri),
			.field_name = "d.cpsuri",
			.item = &ASN1_IA5STRING_it,
		},
	
	},
	{
		.value = NID_id_qt_unotice,
		.tt = {
			.flags = 0,
			.tag = 0,
			.offset = offsetof(POLICYQUALINFO, d.usernotice),
			.field_name = "d.usernotice",
			.item = &USERNOTICE_it,
		},
	
	},
};

static const ASN1_ADB POLICYQUALINFO_adb = {
	.flags = 0,
	.offset = offsetof(POLICYQUALINFO, pqualid),
	.app_items = 0,
	.tbl = POLICYQUALINFO_adbtbl,
	.tblcount = sizeof(POLICYQUALINFO_adbtbl) / sizeof(ASN1_ADB_TABLE),
	.default_tt = &policydefault_tt,
	.null_tt = NULL,
};

static const ASN1_TEMPLATE POLICYQUALINFO_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(POLICYQUALINFO, pqualid),
		.field_name = "pqualid",
		.item = &ASN1_OBJECT_it,
	},
	{
		.flags = ASN1_TFLG_ADB_OID,
		.tag = -1,
		.offset = 0,
		.field_name = "POLICYQUALINFO",
		.item = (const ASN1_ITEM *)&POLICYQUALINFO_adb,
	},
};

const ASN1_ITEM POLICYQUALINFO_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = POLICYQUALINFO_seq_tt,
	.tcount = sizeof(POLICYQUALINFO_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(POLICYQUALINFO),
	.sname = "POLICYQUALINFO",
};


POLICYQUALINFO *
d2i_POLICYQUALINFO(POLICYQUALINFO **a, const unsigned char **in, long len)
{
	return (POLICYQUALINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &POLICYQUALINFO_it);
}

int
i2d_POLICYQUALINFO(POLICYQUALINFO *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &POLICYQUALINFO_it);
}

POLICYQUALINFO *
POLICYQUALINFO_new(void)
{
	return (POLICYQUALINFO *)ASN1_item_new(&POLICYQUALINFO_it);
}

void
POLICYQUALINFO_free(POLICYQUALINFO *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &POLICYQUALINFO_it);
}

static const ASN1_TEMPLATE USERNOTICE_seq_tt[] = {
	{
		.flags = ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(USERNOTICE, noticeref),
		.field_name = "noticeref",
		.item = &NOTICEREF_it,
	},
	{
		.flags = ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(USERNOTICE, exptext),
		.field_name = "exptext",
		.item = &DISPLAYTEXT_it,
	},
};

const ASN1_ITEM USERNOTICE_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = USERNOTICE_seq_tt,
	.tcount = sizeof(USERNOTICE_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(USERNOTICE),
	.sname = "USERNOTICE",
};


USERNOTICE *
d2i_USERNOTICE(USERNOTICE **a, const unsigned char **in, long len)
{
	return (USERNOTICE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &USERNOTICE_it);
}

int
i2d_USERNOTICE(USERNOTICE *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &USERNOTICE_it);
}

USERNOTICE *
USERNOTICE_new(void)
{
	return (USERNOTICE *)ASN1_item_new(&USERNOTICE_it);
}

void
USERNOTICE_free(USERNOTICE *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &USERNOTICE_it);
}

static const ASN1_TEMPLATE NOTICEREF_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(NOTICEREF, organization),
		.field_name = "organization",
		.item = &DISPLAYTEXT_it,
	},
	{
		.flags = ASN1_TFLG_SEQUENCE_OF,
		.tag = 0,
		.offset = offsetof(NOTICEREF, noticenos),
		.field_name = "noticenos",
		.item = &ASN1_INTEGER_it,
	},
};

const ASN1_ITEM NOTICEREF_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = NOTICEREF_seq_tt,
	.tcount = sizeof(NOTICEREF_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(NOTICEREF),
	.sname = "NOTICEREF",
};


NOTICEREF *
d2i_NOTICEREF(NOTICEREF **a, const unsigned char **in, long len)
{
	return (NOTICEREF *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &NOTICEREF_it);
}

int
i2d_NOTICEREF(NOTICEREF *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &NOTICEREF_it);
}

NOTICEREF *
NOTICEREF_new(void)
{
	return (NOTICEREF *)ASN1_item_new(&NOTICEREF_it);
}

void
NOTICEREF_free(NOTICEREF *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &NOTICEREF_it);
}

static
STACK_OF(POLICYINFO) *r2i_certpol(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
    char *value)
{
	STACK_OF(POLICYINFO) *pols = NULL;
	char *pstr;
	POLICYINFO *pol;
	ASN1_OBJECT *pobj;
	STACK_OF(CONF_VALUE) *vals;
	CONF_VALUE *cnf;
	int i, ia5org;

	pols = sk_POLICYINFO_new_null();
	if (pols == NULL) {
		X509V3error(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	vals = X509V3_parse_list(value);
	if (vals == NULL) {
		X509V3error(ERR_R_X509V3_LIB);
		goto err;
	}
	ia5org = 0;
	for (i = 0; i < sk_CONF_VALUE_num(vals); i++) {
		cnf = sk_CONF_VALUE_value(vals, i);
		if (cnf->value || !cnf->name) {
			X509V3error(X509V3_R_INVALID_POLICY_IDENTIFIER);
			X509V3_conf_err(cnf);
			goto err;
		}
		pstr = cnf->name;
		if (!strcmp(pstr, "ia5org")) {
			ia5org = 1;
			continue;
		} else if (*pstr == '@@') {
			STACK_OF(CONF_VALUE) *polsect;
			polsect = X509V3_get_section(ctx, pstr + 1);
			if (!polsect) {
				X509V3error(X509V3_R_INVALID_SECTION);
				X509V3_conf_err(cnf);
				goto err;
			}
			pol = policy_section(ctx, polsect, ia5org);
			X509V3_section_free(ctx, polsect);
			if (!pol)
				goto err;
		} else {
			if (!(pobj = OBJ_txt2obj(cnf->name, 0))) {
				X509V3error(X509V3_R_INVALID_OBJECT_IDENTIFIER);
				X509V3_conf_err(cnf);
				goto err;
			}
			pol = POLICYINFO_new();
			pol->policyid = pobj;
		}
		if (!sk_POLICYINFO_push(pols, pol)){
			POLICYINFO_free(pol);
			X509V3error(ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}
	sk_CONF_VALUE_pop_free(vals, X509V3_conf_free);
	return pols;

err:
	sk_CONF_VALUE_pop_free(vals, X509V3_conf_free);
	sk_POLICYINFO_pop_free(pols, POLICYINFO_free);
	return NULL;
}

static POLICYINFO *
policy_section(X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *polstrs, int ia5org)
{
	int i;
	CONF_VALUE *cnf;
	POLICYINFO *pol;
	POLICYQUALINFO *nqual = NULL;

	if ((pol = POLICYINFO_new()) == NULL)
		goto merr;
	for (i = 0; i < sk_CONF_VALUE_num(polstrs); i++) {
		cnf = sk_CONF_VALUE_value(polstrs, i);
		if (strcmp(cnf->name, "policyIdentifier") == 0) {
			ASN1_OBJECT *pobj;

			if ((pobj = OBJ_txt2obj(cnf->value, 0)) == NULL) {
				X509V3error(X509V3_R_INVALID_OBJECT_IDENTIFIER);
				X509V3_conf_err(cnf);
				goto err;
			}
			pol->policyid = pobj;
		} else if (name_cmp(cnf->name, "CPS") == 0) {
			if ((nqual = POLICYQUALINFO_new()) == NULL)
				goto merr;
			nqual->pqualid = OBJ_nid2obj(NID_id_qt_cps);
			nqual->d.cpsuri = ASN1_IA5STRING_new();
			if (nqual->d.cpsuri == NULL)
				goto merr;
			if (ASN1_STRING_set(nqual->d.cpsuri, cnf->value,
			    strlen(cnf->value)) == 0)
				goto merr;

			if (pol->qualifiers == NULL) {
				pol->qualifiers = sk_POLICYQUALINFO_new_null();
				if (pol->qualifiers == NULL)
					goto merr;
			}
			if (sk_POLICYQUALINFO_push(pol->qualifiers, nqual) == 0)
				goto merr;
			nqual = NULL;
		} else if (name_cmp(cnf->name, "userNotice") == 0) {
			STACK_OF(CONF_VALUE) *unot;
			POLICYQUALINFO *qual;

			if (*cnf->value != '@@') {
				X509V3error(X509V3_R_EXPECTED_A_SECTION_NAME);
				X509V3_conf_err(cnf);
				goto err;
			}
			unot = X509V3_get_section(ctx, cnf->value + 1);
			if (unot == NULL) {
				X509V3error(X509V3_R_INVALID_SECTION);
				X509V3_conf_err(cnf);
				goto err;
			}
			qual = notice_section(ctx, unot, ia5org);
			X509V3_section_free(ctx, unot);
			if (qual == NULL)
				goto err;

			if (pol->qualifiers == NULL) {
				pol->qualifiers = sk_POLICYQUALINFO_new_null();
				if (pol->qualifiers == NULL)
					goto merr;
			}
			if (sk_POLICYQUALINFO_push(pol->qualifiers, qual) == 0)
				goto merr;
		} else {
			X509V3error(X509V3_R_INVALID_OPTION);
			X509V3_conf_err(cnf);
			goto err;
		}
	}
	if (pol->policyid == NULL) {
		X509V3error(X509V3_R_NO_POLICY_IDENTIFIER);
		goto err;
	}

	return pol;

merr:
	X509V3error(ERR_R_MALLOC_FAILURE);

err:
	POLICYQUALINFO_free(nqual);
	POLICYINFO_free(pol);
	return NULL;
}

static POLICYQUALINFO *
notice_section(X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *unot, int ia5org)
{
	int i, ret;
	CONF_VALUE *cnf;
	USERNOTICE *not;
	POLICYQUALINFO *qual;

	if (!(qual = POLICYQUALINFO_new()))
		goto merr;
	qual->pqualid = OBJ_nid2obj(NID_id_qt_unotice);
	if (!(not = USERNOTICE_new()))
		goto merr;
	qual->d.usernotice = not;
	for (i = 0; i < sk_CONF_VALUE_num(unot); i++) {
		cnf = sk_CONF_VALUE_value(unot, i);
		if (!strcmp(cnf->name, "explicitText")) {
			if (not->exptext == NULL) {
				not->exptext = ASN1_VISIBLESTRING_new();
				if (not->exptext == NULL)
					goto merr;
			}
			if (!ASN1_STRING_set(not->exptext, cnf->value,
			    strlen(cnf->value)))
				goto merr;
		} else if (!strcmp(cnf->name, "organization")) {
			NOTICEREF *nref;
			if (!not->noticeref) {
				if (!(nref = NOTICEREF_new()))
					goto merr;
				not->noticeref = nref;
			} else
				nref = not->noticeref;
			if (ia5org)
				nref->organization->type = V_ASN1_IA5STRING;
			else
				nref->organization->type = V_ASN1_VISIBLESTRING;
			if (!ASN1_STRING_set(nref->organization, cnf->value,
			    strlen(cnf->value)))
				goto merr;
		} else if (!strcmp(cnf->name, "noticeNumbers")) {
			NOTICEREF *nref;
			STACK_OF(CONF_VALUE) *nos;
			if (!not->noticeref) {
				if (!(nref = NOTICEREF_new()))
					goto merr;
				not->noticeref = nref;
			} else
				nref = not->noticeref;
			nos = X509V3_parse_list(cnf->value);
			if (!nos || !sk_CONF_VALUE_num(nos)) {
				X509V3error(X509V3_R_INVALID_NUMBERS);
				X509V3_conf_err(cnf);
				if (nos != NULL)
					sk_CONF_VALUE_pop_free(nos,
					    X509V3_conf_free);
				goto err;
			}
			ret = nref_nos(nref->noticenos, nos);
			sk_CONF_VALUE_pop_free(nos, X509V3_conf_free);
			if (!ret)
				goto err;
		} else {
			X509V3error(X509V3_R_INVALID_OPTION);
			X509V3_conf_err(cnf);
			goto err;
		}
	}

	if (not->noticeref &&
	    (!not->noticeref->noticenos || !not->noticeref->organization)) {
		X509V3error(X509V3_R_NEED_ORGANIZATION_AND_NUMBERS);
		goto err;
	}

	return qual;

merr:
	X509V3error(ERR_R_MALLOC_FAILURE);

err:
	POLICYQUALINFO_free(qual);
	return NULL;
}

static int
nref_nos(STACK_OF(ASN1_INTEGER) *nnums, STACK_OF(CONF_VALUE) *nos)
{
	CONF_VALUE *cnf;
	ASN1_INTEGER *aint;
	int i;

	for (i = 0; i < sk_CONF_VALUE_num(nos); i++) {
		cnf = sk_CONF_VALUE_value(nos, i);
		if (!(aint = s2i_ASN1_INTEGER(NULL, cnf->name))) {
			X509V3error(X509V3_R_INVALID_NUMBER);
			goto err;
		}
		if (!sk_ASN1_INTEGER_push(nnums, aint))
			goto merr;
	}
	return 1;

merr:
	X509V3error(ERR_R_MALLOC_FAILURE);

err:
	sk_ASN1_INTEGER_pop_free(nnums, ASN1_STRING_free);
	return 0;
}

static int
i2r_certpol(X509V3_EXT_METHOD *method, STACK_OF(POLICYINFO) *pol, BIO *out,
    int indent)
{
	int i;
	POLICYINFO *pinfo;

	/* First print out the policy OIDs */
	for (i = 0; i < sk_POLICYINFO_num(pol); i++) {
		pinfo = sk_POLICYINFO_value(pol, i);
		BIO_printf(out, "%*sPolicy: ", indent, "");
		i2a_ASN1_OBJECT(out, pinfo->policyid);
		BIO_puts(out, "\n");
		if (pinfo->qualifiers)
			print_qualifiers(out, pinfo->qualifiers, indent + 2);
	}
	return 1;
}

static void
print_qualifiers(BIO *out, STACK_OF(POLICYQUALINFO) *quals, int indent)
{
	POLICYQUALINFO *qualinfo;
	int i;

	for (i = 0; i < sk_POLICYQUALINFO_num(quals); i++) {
		qualinfo = sk_POLICYQUALINFO_value(quals, i);
		switch (OBJ_obj2nid(qualinfo->pqualid)) {
		case NID_id_qt_cps:
			BIO_printf(out, "%*sCPS: %s\n", indent, "",
			    qualinfo->d.cpsuri->data);
			break;

		case NID_id_qt_unotice:
			BIO_printf(out, "%*sUser Notice:\n", indent, "");
			print_notice(out, qualinfo->d.usernotice, indent + 2);
			break;

		default:
			BIO_printf(out, "%*sUnknown Qualifier: ",
			    indent + 2, "");

			i2a_ASN1_OBJECT(out, qualinfo->pqualid);
			BIO_puts(out, "\n");
			break;
		}
	}
}

static void
print_notice(BIO *out, USERNOTICE *notice, int indent)
{
	int i;

	if (notice->noticeref) {
		NOTICEREF *ref;
		ref = notice->noticeref;
		BIO_printf(out, "%*sOrganization: %s\n", indent, "",
		    ref->organization->data);
		BIO_printf(out, "%*sNumber%s: ", indent, "",
		    sk_ASN1_INTEGER_num(ref->noticenos) > 1 ? "s" : "");
		for (i = 0; i < sk_ASN1_INTEGER_num(ref->noticenos); i++) {
			ASN1_INTEGER *num;
			char *tmp;
			num = sk_ASN1_INTEGER_value(ref->noticenos, i);
			if (i)
				BIO_puts(out, ", ");
			tmp = i2s_ASN1_INTEGER(NULL, num);
			BIO_puts(out, tmp);
			free(tmp);
		}
		BIO_puts(out, "\n");
	}
	if (notice->exptext)
		BIO_printf(out, "%*sExplicit Text: %s\n", indent, "",
		    notice->exptext->data);
}

void
X509_POLICY_NODE_print(BIO *out, X509_POLICY_NODE *node, int indent)
{
	const X509_POLICY_DATA *dat = node->data;

	BIO_printf(out, "%*sPolicy: ", indent, "");

	i2a_ASN1_OBJECT(out, dat->valid_policy);
	BIO_puts(out, "\n");
	BIO_printf(out, "%*s%s\n", indent + 2, "",
	    node_data_critical(dat) ? "Critical" : "Non Critical");
	if (dat->qualifier_set)
		print_qualifiers(out, dat->qualifier_set, indent + 2);
	else
		BIO_printf(out, "%*sNo Qualifiers\n", indent + 2, "");
}
@


1.24
log
@Expand ASN1_ITEM_ref and ASN1_ITEM_ptr macros - no change in generated
assembly. Of particular interest is ASN1_ITEM_ptr which does nothing
and resulted in code like:

  if (method->it)
    ASN1_ITEM_free(..., ASN1_ITEM_ptr(method->it));
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.23 2015/09/30 18:21:50 jsing Exp $ */
d415 1
a415 1
		X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_MALLOC_FAILURE);
d420 1
a420 1
		X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_X509V3_LIB);
d427 1
a427 2
			X509V3err(X509V3_F_R2I_CERTPOL,
			    X509V3_R_INVALID_POLICY_IDENTIFIER);
d439 1
a439 2
				X509V3err(X509V3_F_R2I_CERTPOL,
				    X509V3_R_INVALID_SECTION);
d449 1
a449 2
				X509V3err(X509V3_F_R2I_CERTPOL,
				    X509V3_R_INVALID_OBJECT_IDENTIFIER);
d458 1
a458 1
			X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_MALLOC_FAILURE);
d487 1
a487 2
				X509V3err(X509V3_F_POLICY_SECTION,
				    X509V3_R_INVALID_OBJECT_IDENTIFIER);
d516 1
a516 2
				X509V3err(X509V3_F_POLICY_SECTION,
				    X509V3_R_EXPECTED_A_SECTION_NAME);
d522 1
a522 2
				X509V3err(X509V3_F_POLICY_SECTION,
				    X509V3_R_INVALID_SECTION);
d539 1
a539 2
			X509V3err(X509V3_F_POLICY_SECTION,
			    X509V3_R_INVALID_OPTION);
d545 1
a545 2
		X509V3err(X509V3_F_POLICY_SECTION,
		    X509V3_R_NO_POLICY_IDENTIFIER);
d552 1
a552 1
	X509V3err(X509V3_F_POLICY_SECTION, ERR_R_MALLOC_FAILURE);
d611 1
a611 2
				X509V3err(X509V3_F_NOTICE_SECTION,
				    X509V3_R_INVALID_NUMBERS);
d623 1
a623 2
			X509V3err(X509V3_F_NOTICE_SECTION,
			    X509V3_R_INVALID_OPTION);
d631 1
a631 2
		X509V3err(X509V3_F_NOTICE_SECTION,
		    X509V3_R_NEED_ORGANIZATION_AND_NUMBERS);
d638 1
a638 1
	X509V3err(X509V3_F_NOTICE_SECTION, ERR_R_MALLOC_FAILURE);
d655 1
a655 1
			X509V3err(X509V3_F_NREF_NOS, X509V3_R_INVALID_NUMBER);
d664 1
a664 1
	X509V3err(X509V3_F_NREF_NOS, ERR_R_MALLOC_FAILURE);
@


1.23
log
@Replace M_ASN1_IA5STRING_(new|free) with ASN1_IA5STRING_(new|free). Same
with one s/M_ASN1_VISIBLESTRING_new/ASN1_VISIBLESTRING_new/.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.22 2015/07/29 16:13:48 jsing Exp $ */
d88 1
a88 1
	.it = ASN1_ITEM_ref(CERTIFICATEPOLICIES),
@


1.22
log
@Use named initialisers for X509V3_EXT_METHOD structs (for the usual
reasons) - only change in generated assembly is due to line numbering.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.21 2015/07/25 16:00:14 jsing Exp $ */
d500 1
a500 1
			nqual->d.cpsuri = M_ASN1_IA5STRING_new();
d586 1
a586 1
				not->exptext = M_ASN1_VISIBLESTRING_new();
@


1.21
log
@Expand ASN.1 template macros - the generated assembly only differs by
changes to line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.20 2015/07/15 17:00:35 miod Exp $ */
d86 14
a99 7
	NID_certificate_policies, 0, ASN1_ITEM_ref(CERTIFICATEPOLICIES),
	0, 0, 0, 0,
	0, 0,
	0, 0,
	(X509V3_EXT_I2R)i2r_certpol,
	(X509V3_EXT_R2I)r2i_certpol,
	NULL
@


1.20
log
@Unchecked allocations, and make sure we do not leak upon error. Fixes
Coverity CID 21739 and more.
ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.19 2015/02/14 15:17:52 miod Exp $ */
d95 17
a111 4
ASN1_ITEM_TEMPLATE(CERTIFICATEPOLICIES) =
    ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, CERTIFICATEPOLICIES,
	POLICYINFO)
ASN1_ITEM_TEMPLATE_END(CERTIFICATEPOLICIES)
d139 26
a164 4
ASN1_SEQUENCE(POLICYINFO) = {
	ASN1_SIMPLE(POLICYINFO, policyid, ASN1_OBJECT),
	ASN1_SEQUENCE_OF_OPT(POLICYINFO, qualifiers, POLICYQUALINFO)
} ASN1_SEQUENCE_END(POLICYINFO)
d192 42
a233 2
ASN1_ADB_TEMPLATE(policydefault) =
    ASN1_SIMPLE(POLICYQUALINFO, d.other, ASN1_ANY);
d235 26
a260 9
ASN1_ADB(POLICYQUALINFO) = {
	ADB_ENTRY(NID_id_qt_cps, ASN1_SIMPLE(POLICYQUALINFO, d.cpsuri, ASN1_IA5STRING)),
	ADB_ENTRY(NID_id_qt_unotice, ASN1_SIMPLE(POLICYQUALINFO, d.usernotice, USERNOTICE))
} ASN1_ADB_END(POLICYQUALINFO, 0, pqualid, 0, &policydefault_tt, NULL);

ASN1_SEQUENCE(POLICYQUALINFO) = {
	ASN1_SIMPLE(POLICYQUALINFO, pqualid, ASN1_OBJECT),
	ASN1_ADB_OBJECT(POLICYQUALINFO)
} ASN1_SEQUENCE_END(POLICYQUALINFO)
d288 26
a313 4
ASN1_SEQUENCE(USERNOTICE) = {
	ASN1_OPT(USERNOTICE, noticeref, NOTICEREF),
	ASN1_OPT(USERNOTICE, exptext, DISPLAYTEXT)
} ASN1_SEQUENCE_END(USERNOTICE)
d341 26
a366 4
ASN1_SEQUENCE(NOTICEREF) = {
	ASN1_SIMPLE(NOTICEREF, organization, DISPLAYTEXT),
	ASN1_SEQUENCE_OF(NOTICEREF, noticenos, ASN1_INTEGER)
} ASN1_SEQUENCE_END(NOTICEREF)
@


1.19
log
@Memory leak upon error; Coverity CID 78857
ok doug@@ jsing@@
CVy: Committing in .
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.18 2015/02/10 11:22:22 jsing Exp $ */
d337 1
a337 1
	POLICYQUALINFO *qual;
d339 1
a339 1
	if (!(pol = POLICYINFO_new()))
d343 1
a343 1
		if (!strcmp(cnf->name, "policyIdentifier")) {
d345 2
a346 1
			if (!(pobj = OBJ_txt2obj(cnf->value, 0))) {
d353 6
a358 4
		} else if (!name_cmp(cnf->name, "CPS")) {
			if (!pol->qualifiers)
				pol->qualifiers = sk_POLICYQUALINFO_new_null();
			if (!(qual = POLICYQUALINFO_new()))
d360 2
a361 1
			if (!sk_POLICYQUALINFO_push(pol->qualifiers, qual))
d363 7
a369 4
			qual->pqualid = OBJ_nid2obj(NID_id_qt_cps);
			qual->d.cpsuri = M_ASN1_IA5STRING_new();
			if (!ASN1_STRING_set(qual->d.cpsuri, cnf->value,
			    strlen(cnf->value)))
d371 2
a372 1
		} else if (!name_cmp(cnf->name, "userNotice")) {
d374 2
d383 1
a383 1
			if (!unot) {
d391 1
a391 1
			if (!qual)
d393 7
a399 3
			if (!pol->qualifiers) pol->qualifiers =
			    sk_POLICYQUALINFO_new_null();
			if (!sk_POLICYQUALINFO_push(pol->qualifiers, qual))
d408 1
a408 1
	if (!pol->policyid) {
d420 1
@


1.18
log
@Remove more IMPLEMENT_STACK_OF noops that have been hiding for the last
15 years.
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.17 2015/02/09 16:03:11 jsing Exp $ */
d464 3
@


1.17
log
@Expand the IMPLEMENT_ASN1_FUNCTIONS macro so that the code is visible and
functions can be readily located.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.16 2014/10/05 18:27:33 miod Exp $ */
a614 3

IMPLEMENT_STACK_OF(X509_POLICY_NODE)
IMPLEMENT_STACK_OF(X509_POLICY_DATA)
@


1.16
log
@Be sure to check object allocation for success before using them.
Tweaks and ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.15 2014/07/11 08:44:49 jsing Exp $ */
d100 25
a124 1
IMPLEMENT_ASN1_FUNCTIONS(CERTIFICATEPOLICIES)
d131 25
a155 1
IMPLEMENT_ASN1_FUNCTIONS(POLICYINFO)
d170 25
a194 1
IMPLEMENT_ASN1_FUNCTIONS(POLICYQUALINFO)
d201 25
a225 1
IMPLEMENT_ASN1_FUNCTIONS(USERNOTICE)
d232 25
a256 1
IMPLEMENT_ASN1_FUNCTIONS(NOTICEREF)
@


1.15
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.14 2014/07/10 13:58:23 jsing Exp $ */
d163 1
a163 1
		if (cnf->value || !cnf->name ) {
d307 5
a311 1
			not->exptext = M_ASN1_VISIBLESTRING_new();
d337 3
a339 2
			} else nref = not->noticeref;
				nos = X509V3_parse_list(cnf->value);
@


1.14
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_cpols.c,v 1.13 2014/06/12 15:49:31 deraadt Exp $ */
a61 2
#include "cryptlib.h"
#include <openssl/conf.h>
d64 2
@


1.13
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 2
@


1.12
log
@KNF.
@
text
@d1 1
a1 1
/* v3_cpols.c */
@


1.11
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d70 6
a75 3
static int i2r_certpol(X509V3_EXT_METHOD *method, STACK_OF(POLICYINFO) *pol, BIO *out, int indent);
static STACK_OF(POLICYINFO) *r2i_certpol(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, char *value);
static void print_qualifiers(BIO *out, STACK_OF(POLICYQUALINFO) *quals, int indent);
d78 1
a78 1
				 STACK_OF(CONF_VALUE) *polstrs, int ia5org);
d80 1
a80 1
					STACK_OF(CONF_VALUE) *unot, int ia5org);
d84 7
a90 7
NID_certificate_policies, 0,ASN1_ITEM_ref(CERTIFICATEPOLICIES),
0,0,0,0,
0,0,
0,0,
(X509V3_EXT_I2R)i2r_certpol,
(X509V3_EXT_R2I)r2i_certpol,
NULL
d93 3
a95 2
ASN1_ITEM_TEMPLATE(CERTIFICATEPOLICIES) = 
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, CERTIFICATEPOLICIES, POLICYINFO)
d107 2
a108 1
ASN1_ADB_TEMPLATE(policydefault) = ASN1_SIMPLE(POLICYQUALINFO, d.other, ASN1_ANY);
d136 3
a138 2
static STACK_OF(POLICYINFO) *r2i_certpol(X509V3_EXT_METHOD *method,
		X509V3_CTX *ctx, char *value)
d147 1
d153 1
a153 1
	vals =  X509V3_parse_list(value);
d159 1
a159 1
	for(i = 0; i < sk_CONF_VALUE_num(vals); i++) {
d161 3
a163 2
		if(cnf->value || !cnf->name ) {
			X509V3err(X509V3_F_R2I_CERTPOL,X509V3_R_INVALID_POLICY_IDENTIFIER);
d168 1
a168 1
		if(!strcmp(pstr,"ia5org")) {
d171 1
a171 1
		} else if(*pstr == '@@') {
d174 3
a176 3
			if(!polsect) {
				X509V3err(X509V3_F_R2I_CERTPOL,X509V3_R_INVALID_SECTION);

d182 2
a183 1
			if(!pol) goto err;
d185 3
a187 2
			if(!(pobj = OBJ_txt2obj(cnf->name, 0))) {
				X509V3err(X509V3_F_R2I_CERTPOL,X509V3_R_INVALID_OBJECT_IDENTIFIER);
d202 2
a203 1
	err:
d209 2
a210 2
static POLICYINFO *policy_section(X509V3_CTX *ctx,
				STACK_OF(CONF_VALUE) *polstrs, int ia5org)
d216 4
a219 2
	if(!(pol = POLICYINFO_new())) goto merr;
	for(i = 0; i < sk_CONF_VALUE_num(polstrs); i++) {
d221 1
a221 1
		if(!strcmp(cnf->name, "policyIdentifier")) {
d223 3
a225 2
			if(!(pobj = OBJ_txt2obj(cnf->value, 0))) {
				X509V3err(X509V3_F_POLICY_SECTION,X509V3_R_INVALID_OBJECT_IDENTIFIER);
d230 7
a236 7

		} else if(!name_cmp(cnf->name, "CPS")) {
			if(!pol->qualifiers) pol->qualifiers =
						 sk_POLICYQUALINFO_new_null();
			if(!(qual = POLICYQUALINFO_new())) goto merr;
			if(!sk_POLICYQUALINFO_push(pol->qualifiers, qual))
								 goto merr;
d239 4
a242 3
			if(!ASN1_STRING_set(qual->d.cpsuri, cnf->value,
						 strlen(cnf->value))) goto merr;
		} else if(!name_cmp(cnf->name, "userNotice")) {
d244 3
a246 2
			if(*cnf->value != '@@') {
				X509V3err(X509V3_F_POLICY_SECTION,X509V3_R_EXPECTED_A_SECTION_NAME);
d251 3
a253 3
			if(!unot) {
				X509V3err(X509V3_F_POLICY_SECTION,X509V3_R_INVALID_SECTION);

d259 6
a264 5
			if(!qual) goto err;
			if(!pol->qualifiers) pol->qualifiers =
						 sk_POLICYQUALINFO_new_null();
			if(!sk_POLICYQUALINFO_push(pol->qualifiers, qual))
								 goto merr;
d266 2
a267 2
			X509V3err(X509V3_F_POLICY_SECTION,X509V3_R_INVALID_OPTION);

d272 3
a274 2
	if(!pol->policyid) {
		X509V3err(X509V3_F_POLICY_SECTION,X509V3_R_NO_POLICY_IDENTIFIER);
d280 2
a281 2
	merr:
	X509V3err(X509V3_F_POLICY_SECTION,ERR_R_MALLOC_FAILURE);
d283 1
a283 1
	err:
a285 2
	
	
d288 2
a289 2
static POLICYQUALINFO *notice_section(X509V3_CTX *ctx,
					STACK_OF(CONF_VALUE) *unot, int ia5org)
d295 3
a297 1
	if(!(qual = POLICYQUALINFO_new())) goto merr;
d299 2
a300 1
	if(!(not = USERNOTICE_new())) goto merr;
d302 1
a302 1
	for(i = 0; i < sk_CONF_VALUE_num(unot); i++) {
d304 1
a304 1
		if(!strcmp(cnf->name, "explicitText")) {
d306 4
a309 3
			if(!ASN1_STRING_set(not->exptext, cnf->value,
						 strlen(cnf->value))) goto merr;
		} else if(!strcmp(cnf->name, "organization")) {
d311 3
a313 2
			if(!not->noticeref) {
				if(!(nref = NOTICEREF_new())) goto merr;
d315 10
a324 6
			} else nref = not->noticeref;
			if(ia5org) nref->organization->type = V_ASN1_IA5STRING;
			else nref->organization->type = V_ASN1_VISIBLESTRING;
			if(!ASN1_STRING_set(nref->organization, cnf->value,
						 strlen(cnf->value))) goto merr;
		} else if(!strcmp(cnf->name, "noticeNumbers")) {
d327 3
a329 2
			if(!not->noticeref) {
				if(!(nref = NOTICEREF_new())) goto merr;
d332 4
a335 3
			nos = X509V3_parse_list(cnf->value);
			if(!nos || !sk_CONF_VALUE_num(nos)) {
				X509V3err(X509V3_F_NOTICE_SECTION,X509V3_R_INVALID_NUMBERS);
d344 2
a345 1
			X509V3err(X509V3_F_NOTICE_SECTION,X509V3_R_INVALID_OPTION);
d351 5
a355 4
	if(not->noticeref && 
	      (!not->noticeref->noticenos || !not->noticeref->organization)) {
			X509V3err(X509V3_F_NOTICE_SECTION,X509V3_R_NEED_ORGANIZATION_AND_NUMBERS);
			goto err;
d360 2
a361 2
	merr:
	X509V3err(X509V3_F_NOTICE_SECTION,ERR_R_MALLOC_FAILURE);
d363 1
a363 1
	err:
d368 2
a369 1
static int nref_nos(STACK_OF(ASN1_INTEGER) *nnums, STACK_OF(CONF_VALUE) *nos)
a372 1

d375 1
a375 1
	for(i = 0; i < sk_CONF_VALUE_num(nos); i++) {
d377 2
a378 2
		if(!(aint = s2i_ASN1_INTEGER(NULL, cnf->name))) {
			X509V3err(X509V3_F_NREF_NOS,X509V3_R_INVALID_NUMBER);
d381 2
a382 1
		if(!sk_ASN1_INTEGER_push(nnums, aint)) goto merr;
d386 2
a387 2
	merr:
	X509V3err(X509V3_F_NREF_NOS,ERR_R_MALLOC_FAILURE);
d389 1
a389 1
	err:
d394 3
a396 3

static int i2r_certpol(X509V3_EXT_METHOD *method, STACK_OF(POLICYINFO) *pol,
		BIO *out, int indent)
d400 1
d402 1
a402 1
	for(i = 0; i < sk_POLICYINFO_num(pol); i++) {
d407 2
a408 2
		if(pinfo->qualifiers)
			 print_qualifiers(out, pinfo->qualifiers, indent + 2);
d413 2
a414 2
static void print_qualifiers(BIO *out, STACK_OF(POLICYQUALINFO) *quals,
		int indent)
d418 2
a419 1
	for(i = 0; i < sk_POLICYQUALINFO_num(quals); i++) {
d421 2
a422 3
		switch(OBJ_obj2nid(qualinfo->pqualid))
		{
			case NID_id_qt_cps:
d424 1
a424 1
						qualinfo->d.cpsuri->data);
d426 2
a427 2
		
			case NID_id_qt_unotice:
d432 1
a432 1
			default:
d434 2
a435 2
							 indent + 2, "");
			
d443 2
a444 1
static void print_notice(BIO *out, USERNOTICE *notice, int indent)
d447 2
a448 1
	if(notice->noticeref) {
d452 1
a452 1
						 ref->organization->data);
d454 2
a455 2
			   sk_ASN1_INTEGER_num(ref->noticenos) > 1 ? "s" : "");
		for(i = 0; i < sk_ASN1_INTEGER_num(ref->noticenos); i++) {
d459 2
a460 1
			if(i) BIO_puts(out, ", ");
d467 1
a467 1
	if(notice->exptext)
d469 1
a469 1
							 notice->exptext->data);
d472 3
a474 2
void X509_POLICY_NODE_print(BIO *out, X509_POLICY_NODE *node, int indent)
	{
d478 1
a478 1
			
d482 1
a482 1
		node_data_critical(dat) ? "Critical" : "Non Critical");
d487 1
a487 2
	}

a490 1

@


1.10
log
@resolve conflicts, fix local changes
@
text
@d429 1
a429 1
			OPENSSL_free(tmp);
@


1.9
log
@resolve conflicts
@
text
@d453 2
a454 1
	
d456 2
@


1.8
log
@resolve conflicts
@
text
@d184 5
a188 1
		sk_POLICYINFO_push(pols, pol);
d454 1
@


1.7
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.6
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d66 2
d80 1
a80 1
X509V3_EXT_METHOD v3_cpols = {
d353 1
a353 1
	X509V3err(X509V3_F_NOTICE_SECTION,ERR_R_MALLOC_FAILURE);
d434 16
@


1.5
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d140 4
d145 4
d187 1
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d76 1
a76 1
static STACK_OF(ASN1_INTEGER) *nref_nos(STACK_OF(CONF_VALUE) *nos);
d229 2
d260 1
a260 1
	int i;
d280 2
a281 2
			if(ia5org) nref->organization = M_ASN1_IA5STRING_new();
			else nref->organization = M_ASN1_VISIBLESTRING_new();
d297 1
a297 1
			nref->noticenos = nref_nos(nos);
d299 2
a300 1
			if(!nref->noticenos) goto err;
a302 1

d324 1
a324 1
static STACK_OF(ASN1_INTEGER) *nref_nos(STACK_OF(CONF_VALUE) *nos)
a325 1
	STACK_OF(ASN1_INTEGER) *nnums;
a330 1
	if(!(nnums = sk_ASN1_INTEGER_new_null())) goto merr;
d339 1
a339 1
	return nnums;
d346 1
a346 1
	return NULL;
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d63 1
a63 1
#include <openssl/asn1_mac.h>
d79 4
a82 7
NID_certificate_policies, 0,
(X509V3_EXT_NEW)CERTIFICATEPOLICIES_new,
(X509V3_EXT_FREE)CERTIFICATEPOLICIES_free,
(X509V3_EXT_D2I)d2i_CERTIFICATEPOLICIES,
(X509V3_EXT_I2D)i2d_CERTIFICATEPOLICIES,
NULL, NULL,
NULL, NULL,
d88 40
a366 77

int i2d_CERTIFICATEPOLICIES(STACK_OF(POLICYINFO) *a, unsigned char **pp)
{

return i2d_ASN1_SET_OF_POLICYINFO(a, pp, i2d_POLICYINFO, V_ASN1_SEQUENCE,
                                                 V_ASN1_UNIVERSAL, IS_SEQUENCE);}

STACK_OF(POLICYINFO) *CERTIFICATEPOLICIES_new(void)
{
	return sk_POLICYINFO_new_null();
}

void CERTIFICATEPOLICIES_free(STACK_OF(POLICYINFO) *a)
{
	sk_POLICYINFO_pop_free(a, POLICYINFO_free);
}

STACK_OF(POLICYINFO) *d2i_CERTIFICATEPOLICIES(STACK_OF(POLICYINFO) **a,
		unsigned char **pp,long length)
{
return d2i_ASN1_SET_OF_POLICYINFO(a, pp, length, d2i_POLICYINFO,
                         POLICYINFO_free, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);

}

IMPLEMENT_STACK_OF(POLICYINFO)
IMPLEMENT_ASN1_SET_OF(POLICYINFO)

int i2d_POLICYINFO(POLICYINFO *a, unsigned char **pp)
{
	M_ASN1_I2D_vars(a);

	M_ASN1_I2D_len (a->policyid, i2d_ASN1_OBJECT);
	M_ASN1_I2D_len_SEQUENCE_type(POLICYQUALINFO, a->qualifiers,
							 i2d_POLICYQUALINFO);

	M_ASN1_I2D_seq_total();

	M_ASN1_I2D_put (a->policyid, i2d_ASN1_OBJECT);
	M_ASN1_I2D_put_SEQUENCE_type(POLICYQUALINFO, a->qualifiers,
							 i2d_POLICYQUALINFO);

	M_ASN1_I2D_finish();
}

POLICYINFO *POLICYINFO_new(void)
{
	POLICYINFO *ret=NULL;
	ASN1_CTX c;
	M_ASN1_New_Malloc(ret, POLICYINFO);
	ret->policyid = NULL;
	ret->qualifiers = NULL;
	return (ret);
	M_ASN1_New_Error(ASN1_F_POLICYINFO_NEW);
}

POLICYINFO *d2i_POLICYINFO(POLICYINFO **a, unsigned char **pp,long length)
{
	M_ASN1_D2I_vars(a,POLICYINFO *,POLICYINFO_new);
	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	M_ASN1_D2I_get(ret->policyid, d2i_ASN1_OBJECT);
	if(!M_ASN1_D2I_end_sequence()) {
		M_ASN1_D2I_get_seq_type (POLICYQUALINFO, ret->qualifiers,
				 d2i_POLICYQUALINFO, POLICYQUALINFO_free);
	}
	M_ASN1_D2I_Finish(a, POLICYINFO_free, ASN1_F_D2I_POLICYINFO);
}

void POLICYINFO_free(POLICYINFO *a)
{
	if (a == NULL) return;
	ASN1_OBJECT_free(a->policyid);
	sk_POLICYQUALINFO_pop_free(a->qualifiers, POLICYQUALINFO_free);
	OPENSSL_free (a);
}

a421 196
		
	

int i2d_POLICYQUALINFO(POLICYQUALINFO *a, unsigned char **pp)
{
	M_ASN1_I2D_vars(a);

	M_ASN1_I2D_len (a->pqualid, i2d_ASN1_OBJECT);
	switch(OBJ_obj2nid(a->pqualid)) {
		case NID_id_qt_cps:
		M_ASN1_I2D_len(a->d.cpsuri, i2d_ASN1_IA5STRING);
		break;

		case NID_id_qt_unotice:
		M_ASN1_I2D_len(a->d.usernotice, i2d_USERNOTICE);
		break;

		default:
		M_ASN1_I2D_len(a->d.other, i2d_ASN1_TYPE);
		break;
	}

	M_ASN1_I2D_seq_total();

	M_ASN1_I2D_put (a->pqualid, i2d_ASN1_OBJECT);
	switch(OBJ_obj2nid(a->pqualid)) {
		case NID_id_qt_cps:
		M_ASN1_I2D_put(a->d.cpsuri, i2d_ASN1_IA5STRING);
		break;

		case NID_id_qt_unotice:
		M_ASN1_I2D_put(a->d.usernotice, i2d_USERNOTICE);
		break;

		default:
		M_ASN1_I2D_put(a->d.other, i2d_ASN1_TYPE);
		break;
	}

	M_ASN1_I2D_finish();
}

POLICYQUALINFO *POLICYQUALINFO_new(void)
{
	POLICYQUALINFO *ret=NULL;
	ASN1_CTX c;
	M_ASN1_New_Malloc(ret, POLICYQUALINFO);
	ret->pqualid = NULL;
	ret->d.other = NULL;
	return (ret);
	M_ASN1_New_Error(ASN1_F_POLICYQUALINFO_NEW);
}

POLICYQUALINFO *d2i_POLICYQUALINFO(POLICYQUALINFO **a, unsigned char **pp,
		long length)
{
	M_ASN1_D2I_vars(a,POLICYQUALINFO *,POLICYQUALINFO_new);
	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	M_ASN1_D2I_get (ret->pqualid, d2i_ASN1_OBJECT);
	switch(OBJ_obj2nid(ret->pqualid)) {
		case NID_id_qt_cps:
		M_ASN1_D2I_get(ret->d.cpsuri, d2i_ASN1_IA5STRING);
		break;

		case NID_id_qt_unotice:
		M_ASN1_D2I_get(ret->d.usernotice, d2i_USERNOTICE);
		break;

		default:
		M_ASN1_D2I_get(ret->d.other, d2i_ASN1_TYPE);
		break;
	}
	M_ASN1_D2I_Finish(a, POLICYQUALINFO_free, ASN1_F_D2I_POLICYQUALINFO);
}

void POLICYQUALINFO_free(POLICYQUALINFO *a)
{
	if (a == NULL) return;
	switch(OBJ_obj2nid(a->pqualid)) {
		case NID_id_qt_cps:
		M_ASN1_IA5STRING_free(a->d.cpsuri);
		break;

		case NID_id_qt_unotice:
		USERNOTICE_free(a->d.usernotice);
		break;

		default:
		ASN1_TYPE_free(a->d.other);
		break;
	}
	
	ASN1_OBJECT_free(a->pqualid);
	OPENSSL_free (a);
}

int i2d_USERNOTICE(USERNOTICE *a, unsigned char **pp)
{
	M_ASN1_I2D_vars(a);

	M_ASN1_I2D_len (a->noticeref, i2d_NOTICEREF);
	M_ASN1_I2D_len (a->exptext, i2d_DISPLAYTEXT);

	M_ASN1_I2D_seq_total();

	M_ASN1_I2D_put (a->noticeref, i2d_NOTICEREF);
	M_ASN1_I2D_put (a->exptext, i2d_DISPLAYTEXT);

	M_ASN1_I2D_finish();
}

USERNOTICE *USERNOTICE_new(void)
{
	USERNOTICE *ret=NULL;
	ASN1_CTX c;
	M_ASN1_New_Malloc(ret, USERNOTICE);
	ret->noticeref = NULL;
	ret->exptext = NULL;
	return (ret);
	M_ASN1_New_Error(ASN1_F_USERNOTICE_NEW);
}

USERNOTICE *d2i_USERNOTICE(USERNOTICE **a, unsigned char **pp,long length)
{
	M_ASN1_D2I_vars(a,USERNOTICE *,USERNOTICE_new);
	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	M_ASN1_D2I_get_opt(ret->noticeref, d2i_NOTICEREF, V_ASN1_SEQUENCE);
	if (!M_ASN1_D2I_end_sequence()) {
		M_ASN1_D2I_get(ret->exptext, d2i_DISPLAYTEXT);
	}
	M_ASN1_D2I_Finish(a, USERNOTICE_free, ASN1_F_D2I_USERNOTICE);
}

void USERNOTICE_free(USERNOTICE *a)
{
	if (a == NULL) return;
	NOTICEREF_free(a->noticeref);
	M_DISPLAYTEXT_free(a->exptext);
	OPENSSL_free (a);
}

int i2d_NOTICEREF(NOTICEREF *a, unsigned char **pp)
{
	M_ASN1_I2D_vars(a);

	M_ASN1_I2D_len (a->organization, i2d_DISPLAYTEXT);
	M_ASN1_I2D_len_SEQUENCE_type(ASN1_INTEGER, a->noticenos,
				     i2d_ASN1_INTEGER);

	M_ASN1_I2D_seq_total();

	M_ASN1_I2D_put (a->organization, i2d_DISPLAYTEXT);
	M_ASN1_I2D_put_SEQUENCE_type(ASN1_INTEGER, a->noticenos,
				     i2d_ASN1_INTEGER);

	M_ASN1_I2D_finish();
}

NOTICEREF *NOTICEREF_new(void)
{
	NOTICEREF *ret=NULL;
	ASN1_CTX c;
	M_ASN1_New_Malloc(ret, NOTICEREF);
	ret->organization = NULL;
	ret->noticenos = NULL;
	return (ret);
	M_ASN1_New_Error(ASN1_F_NOTICEREF_NEW);
}

NOTICEREF *d2i_NOTICEREF(NOTICEREF **a, unsigned char **pp,long length)
{
	M_ASN1_D2I_vars(a,NOTICEREF *,NOTICEREF_new);
	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	/* This is to cope with some broken encodings that use IA5STRING for
         * the organization field
	 */
	M_ASN1_D2I_get_opt(ret->organization, d2i_ASN1_IA5STRING,
							 V_ASN1_IA5STRING);
	if(!ret->organization) {
		 M_ASN1_D2I_get(ret->organization, d2i_DISPLAYTEXT);
	}
	M_ASN1_D2I_get_seq_type(ASN1_INTEGER, ret->noticenos, d2i_ASN1_INTEGER,
				ASN1_STRING_free);
	M_ASN1_D2I_Finish(a, NOTICEREF_free, ASN1_F_D2I_NOTICEREF);
}

void NOTICEREF_free(NOTICEREF *a)
{
	if (a == NULL) return;
	M_DISPLAYTEXT_free(a->organization);
	sk_ASN1_INTEGER_pop_free(a->noticenos, ASN1_STRING_free);
	OPENSSL_free (a);
}
a422 2
IMPLEMENT_STACK_OF(POLICYQUALINFO)
IMPLEMENT_ASN1_SET_OF(POLICYQUALINFO)
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d76 1
a76 1
static STACK *nref_nos(STACK_OF(CONF_VALUE) *nos);
d285 1
a285 1
static STACK *nref_nos(STACK_OF(CONF_VALUE) *nos)
d287 1
a287 1
	STACK *nnums;
d290 1
d292 2
a293 1
	if(!(nnums = sk_new_null())) goto merr;
d300 1
a300 1
		if(!sk_push(nnums, (char *)aint)) goto merr;
d308 1
a308 1
	sk_pop_free(nnums, ASN1_STRING_free);
d404 1
a404 1
	Free (a);
d446 2
a447 2
				 (sk_num(ref->noticenos) > 1) ? "s" : "");
		for(i = 0; i < sk_num(ref->noticenos); i++) {
d450 1
a450 1
			num = (ASN1_INTEGER *)sk_value(ref->noticenos, i);
d454 1
a454 1
			Free(tmp);
d556 1
a556 1
	Free (a);
d602 1
a602 1
	Free (a);
d610 2
a611 1
	M_ASN1_I2D_len_SEQUENCE(a->noticenos, i2d_ASN1_INTEGER);
d616 2
a617 1
	M_ASN1_I2D_put_SEQUENCE(a->noticenos, i2d_ASN1_INTEGER);
d646 2
a647 1
	M_ASN1_D2I_get_seq(ret->noticenos, d2i_ASN1_INTEGER, ASN1_STRING_free);
d655 2
a656 2
	sk_pop_free(a->noticenos, ASN1_STRING_free);
	Free (a);
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d172 1
a172 1
			qual->d.cpsuri = ASN1_IA5STRING_new();
d232 1
a232 1
			not->exptext = ASN1_VISIBLESTRING_new();
d241 2
a242 2
			if(ia5org) nref->organization = ASN1_IA5STRING_new();
			else nref->organization = ASN1_VISIBLESTRING_new();
d541 1
a541 1
		ASN1_IA5STRING_free(a->d.cpsuri);
d599 1
a599 1
	DISPLAYTEXT_free(a->exptext);
d649 1
a649 1
	DISPLAYTEXT_free(a->organization);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d63 1
a63 1
#include <openssl/asn1t.h>
d76 1
a76 1
static STACK_OF(ASN1_INTEGER) *nref_nos(STACK_OF(CONF_VALUE) *nos);
d79 7
a85 4
NID_certificate_policies, 0,ASN1_ITEM_ref(CERTIFICATEPOLICIES),
0,0,0,0,
0,0,
0,0,
a90 40
ASN1_ITEM_TEMPLATE(CERTIFICATEPOLICIES) = 
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0, CERTIFICATEPOLICIES, POLICYINFO)
ASN1_ITEM_TEMPLATE_END(CERTIFICATEPOLICIES)

IMPLEMENT_ASN1_FUNCTIONS(CERTIFICATEPOLICIES)

ASN1_SEQUENCE(POLICYINFO) = {
	ASN1_SIMPLE(POLICYINFO, policyid, ASN1_OBJECT),
	ASN1_SEQUENCE_OF_OPT(POLICYINFO, qualifiers, POLICYQUALINFO)
} ASN1_SEQUENCE_END(POLICYINFO)

IMPLEMENT_ASN1_FUNCTIONS(POLICYINFO)

ASN1_ADB_TEMPLATE(policydefault) = ASN1_SIMPLE(POLICYQUALINFO, d.other, ASN1_ANY);

ASN1_ADB(POLICYQUALINFO) = {
	ADB_ENTRY(NID_id_qt_cps, ASN1_SIMPLE(POLICYQUALINFO, d.cpsuri, ASN1_IA5STRING)),
	ADB_ENTRY(NID_id_qt_unotice, ASN1_SIMPLE(POLICYQUALINFO, d.usernotice, USERNOTICE))
} ASN1_ADB_END(POLICYQUALINFO, 0, pqualid, 0, &policydefault_tt, NULL);

ASN1_SEQUENCE(POLICYQUALINFO) = {
	ASN1_SIMPLE(POLICYQUALINFO, pqualid, ASN1_OBJECT),
	ASN1_ADB_OBJECT(POLICYQUALINFO)
} ASN1_SEQUENCE_END(POLICYQUALINFO)

IMPLEMENT_ASN1_FUNCTIONS(POLICYQUALINFO)

ASN1_SEQUENCE(USERNOTICE) = {
	ASN1_OPT(USERNOTICE, noticeref, NOTICEREF),
	ASN1_OPT(USERNOTICE, exptext, DISPLAYTEXT)
} ASN1_SEQUENCE_END(USERNOTICE)

IMPLEMENT_ASN1_FUNCTIONS(USERNOTICE)

ASN1_SEQUENCE(NOTICEREF) = {
	ASN1_SIMPLE(NOTICEREF, organization, DISPLAYTEXT),
	ASN1_SEQUENCE_OF(NOTICEREF, noticenos, ASN1_INTEGER)
} ASN1_SEQUENCE_END(NOTICEREF)

IMPLEMENT_ASN1_FUNCTIONS(NOTICEREF)
d172 1
a172 1
			qual->d.cpsuri = M_ASN1_IA5STRING_new();
d232 1
a232 1
			not->exptext = M_ASN1_VISIBLESTRING_new();
d241 2
a242 2
			if(ia5org) nref->organization = M_ASN1_IA5STRING_new();
			else nref->organization = M_ASN1_VISIBLESTRING_new();
d285 1
a285 1
static STACK_OF(ASN1_INTEGER) *nref_nos(STACK_OF(CONF_VALUE) *nos)
d287 1
a287 1
	STACK_OF(ASN1_INTEGER) *nnums;
a289 1

d291 1
a291 2

	if(!(nnums = sk_ASN1_INTEGER_new_null())) goto merr;
d298 1
a298 1
		if(!sk_ASN1_INTEGER_push(nnums, aint)) goto merr;
d306 1
a306 1
	sk_ASN1_INTEGER_pop_free(nnums, ASN1_STRING_free);
d328 77
d444 2
a445 2
			   sk_ASN1_INTEGER_num(ref->noticenos) > 1 ? "s" : "");
		for(i = 0; i < sk_ASN1_INTEGER_num(ref->noticenos); i++) {
d448 1
a448 1
			num = sk_ASN1_INTEGER_value(ref->noticenos, i);
d452 1
a452 1
			OPENSSL_free(tmp);
d460 193
d654 2
@


1.1.1.2
log
@import 0.9.7c
@
text
@d76 1
a76 1
static int nref_nos(STACK_OF(ASN1_INTEGER) *nnums, STACK_OF(CONF_VALUE) *nos);
a228 2
			if(!pol->qualifiers) pol->qualifiers =
						 sk_POLICYQUALINFO_new_null();
d258 1
a258 1
	int i, ret;
d278 2
a279 2
			if(ia5org) nref->organization->type = V_ASN1_IA5STRING;
			else nref->organization->type = V_ASN1_VISIBLESTRING;
d295 1
a295 1
			ret = nref_nos(nref->noticenos, nos);
d297 1
a297 2
			if (!ret)
				goto err;
d300 1
d322 1
a322 1
static int nref_nos(STACK_OF(ASN1_INTEGER) *nnums, STACK_OF(CONF_VALUE) *nos)
d324 1
d330 1
d339 1
a339 1
	return 1;
d346 1
a346 1
	return 0;
@


1.1.1.3
log
@import of openssl-0.9.7j
@
text
@a139 4
	if (pols == NULL) {
		X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_MALLOC_FAILURE);
		return NULL;
	}
a140 4
	if (vals == NULL) {
		X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_X509V3_LIB);
		goto err;
	}
a178 1
	sk_CONF_VALUE_pop_free(vals, X509V3_conf_free);
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2004 The OpenSSL Project.  All rights reserved.
a65 2
#include "pcy_int.h"

d78 1
a78 1
const X509V3_EXT_METHOD v3_cpols = {
d351 1
a351 1
	X509V3err(X509V3_F_NREF_NOS,ERR_R_MALLOC_FAILURE);
a431 16
void X509_POLICY_NODE_print(BIO *out, X509_POLICY_NODE *node, int indent)
	{
	const X509_POLICY_DATA *dat = node->data;

	BIO_printf(out, "%*sPolicy: ", indent, "");
			
	i2a_ASN1_OBJECT(out, dat->valid_policy);
	BIO_puts(out, "\n");
	BIO_printf(out, "%*s%s\n", indent + 2, "",
		node_data_critical(dat) ? "Critical" : "Non Critical");
	if (dat->qualifier_set)
		print_qualifiers(out, dat->qualifier_set, indent + 2);
	else
		BIO_printf(out, "%*sNo Qualifiers\n", indent + 2, "");
	}
	
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.6
log
@import of OpenSSL 0.9.8k
@
text
@d184 1
a184 5
		if (!sk_POLICYINFO_push(pols, pol)){
			POLICYINFO_free(pol);
			X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_MALLOC_FAILURE);
			goto err;
		}
a449 1
IMPLEMENT_STACK_OF(X509_POLICY_NODE)
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d453 1
a453 2


a454 2
IMPLEMENT_STACK_OF(X509_POLICY_DATA)

@


