head	1.21;
access;
symbols;
locks; strict;
comment	@ * @;


1.21
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.20;
commitid	kT0fLt3r4lroFJra;

1.20
date	2016.12.30.15.54.49;	author jsing;	state Exp;
branches;
next	1.19;
commitid	kn1H5Mumrqi1t2NN;

1.19
date	2015.12.14.03.39.14;	author beck;	state Exp;
branches;
next	1.18;
commitid	vLkSVzR5O32zzlrV;

1.18
date	2015.09.30.18.41.06;	author jsing;	state Exp;
branches;
next	1.17;
commitid	8UbnRNonXjerilzx;

1.17
date	2015.02.17.05.14.38;	author miod;	state Exp;
branches;
next	1.16;
commitid	RNypsvAGREE2yoTr;

1.16
date	2014.10.05.18.26.43;	author miod;	state Exp;
branches;
next	1.15;
commitid	zostE7jHtbPN1yX7;

1.15
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.14;
commitid	yQEL1wOWIearrW15;

1.14
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.13;
commitid	id8dTrTMtnTn4fqt;

1.13
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	mJUVYpkFBZ0Zv2bG;

1.12
date	2014.05.22.21.12.16;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.21.14.27.06;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.15;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.12.17;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.53;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.02;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.11.21.18.08;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.14.01;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: v3_conf.c,v 1.20 2016/12/30 15:54:49 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999.
 */
/* ====================================================================
 * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* extension creation utilities */

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#include <openssl/conf.h>
#include <openssl/err.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>

static int v3_check_critical(char **value);
static int v3_check_generic(char **value);
static X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid,
    int crit, char *value);
static X509_EXTENSION *v3_generic_extension(const char *ext, char *value,
    int crit, int type, X509V3_CTX *ctx);
static char *conf_lhash_get_string(void *db, char *section, char *value);
static STACK_OF(CONF_VALUE) *conf_lhash_get_section(void *db, char *section);
static X509_EXTENSION *do_ext_i2d(const X509V3_EXT_METHOD *method, int ext_nid,
    int crit, void *ext_struc);
static unsigned char *generic_asn1(char *value, X509V3_CTX *ctx, long *ext_len);

/* CONF *conf:  Config file    */
/* char *name:  Name    */
/* char *value:  Value    */
X509_EXTENSION *
X509V3_EXT_nconf(CONF *conf, X509V3_CTX *ctx, char *name, char *value)
{
	int crit;
	int ext_type;
	X509_EXTENSION *ret;

	crit = v3_check_critical(&value);
	if ((ext_type = v3_check_generic(&value)))
		return v3_generic_extension(name, value, crit, ext_type, ctx);
	ret = do_ext_nconf(conf, ctx, OBJ_sn2nid(name), crit, value);
	if (!ret) {
		X509V3error(X509V3_R_ERROR_IN_EXTENSION);
		ERR_asprintf_error_data("name=%s, value=%s", name, value);
	}
	return ret;
}

/* CONF *conf:  Config file    */
/* char *value:  Value    */
X509_EXTENSION *
X509V3_EXT_nconf_nid(CONF *conf, X509V3_CTX *ctx, int ext_nid, char *value)
{
	int crit;
	int ext_type;

	crit = v3_check_critical(&value);
	if ((ext_type = v3_check_generic(&value)))
		return v3_generic_extension(OBJ_nid2sn(ext_nid),
		    value, crit, ext_type, ctx);
	return do_ext_nconf(conf, ctx, ext_nid, crit, value);
}

/* CONF *conf:  Config file    */
/* char *value:  Value    */
static X509_EXTENSION *
do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid, int crit, char *value)
{
	const X509V3_EXT_METHOD *method;
	X509_EXTENSION *ext;
	void *ext_struc;

	if (ext_nid == NID_undef) {
		X509V3error(X509V3_R_UNKNOWN_EXTENSION_NAME);
		return NULL;
	}
	if (!(method = X509V3_EXT_get_nid(ext_nid))) {
		X509V3error(X509V3_R_UNKNOWN_EXTENSION);
		return NULL;
	}
	/* Now get internal extension representation based on type */
	if (method->v2i) {
		STACK_OF(CONF_VALUE) *nval;

		if (*value == '@@')
			nval = NCONF_get_section(conf, value + 1);
		else
			nval = X509V3_parse_list(value);
		if (sk_CONF_VALUE_num(nval) <= 0) {
			X509V3error(X509V3_R_INVALID_EXTENSION_STRING);
			ERR_asprintf_error_data("name=%s,section=%s",
			    OBJ_nid2sn(ext_nid), value);
			if (*value != '@@')
				sk_CONF_VALUE_pop_free(nval, X509V3_conf_free);
			return NULL;
		}
		ext_struc = method->v2i(method, ctx, nval);
		if (*value != '@@')
			sk_CONF_VALUE_pop_free(nval, X509V3_conf_free);
	} else if (method->s2i) {
		ext_struc = method->s2i(method, ctx, value);
	} else if (method->r2i) {
		if (!ctx->db || !ctx->db_meth) {
			X509V3error(X509V3_R_NO_CONFIG_DATABASE);
			return NULL;
		}
		ext_struc = method->r2i(method, ctx, value);
	} else {
		X509V3error(X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED);
		ERR_asprintf_error_data("name=%s", OBJ_nid2sn(ext_nid));
		return NULL;
	}
	if (ext_struc == NULL)
		return NULL;

	ext = do_ext_i2d(method, ext_nid, crit, ext_struc);
	if (method->it)
		ASN1_item_free(ext_struc, method->it);
	else
		method->ext_free(ext_struc);
	return ext;
}

static X509_EXTENSION *
do_ext_i2d(const X509V3_EXT_METHOD *method, int ext_nid, int crit,
    void *ext_struc)
{
	unsigned char *ext_der;
	int ext_len;
	ASN1_OCTET_STRING *ext_oct = NULL;
	X509_EXTENSION *ext;

	/* Convert internal representation to DER */
	if (method->it) {
		ext_der = NULL;
		ext_len = ASN1_item_i2d(ext_struc, &ext_der,
		    method->it);
		if (ext_len < 0)
			goto merr;
	} else {
		unsigned char *p;
		ext_len = method->i2d(ext_struc, NULL);
		if (!(ext_der = malloc(ext_len)))
			goto merr;
		p = ext_der;
		method->i2d(ext_struc, &p);
	}
	if (!(ext_oct = ASN1_OCTET_STRING_new()))
		goto merr;
	ext_oct->data = ext_der;
	ext_oct->length = ext_len;

	ext = X509_EXTENSION_create_by_NID(NULL, ext_nid, crit, ext_oct);
	if (!ext)
		goto merr;
	ASN1_OCTET_STRING_free(ext_oct);

	return ext;

merr:
	ASN1_OCTET_STRING_free(ext_oct);
	X509V3error(ERR_R_MALLOC_FAILURE);
	return NULL;

}

/* Given an internal structure, nid and critical flag create an extension */

X509_EXTENSION *
X509V3_EXT_i2d(int ext_nid, int crit, void *ext_struc)
{
	const X509V3_EXT_METHOD *method;

	if (!(method = X509V3_EXT_get_nid(ext_nid))) {
		X509V3error(X509V3_R_UNKNOWN_EXTENSION);
		return NULL;
	}
	return do_ext_i2d(method, ext_nid, crit, ext_struc);
}

/* Check the extension string for critical flag */
static int
v3_check_critical(char **value)
{
	char *p = *value;

	if ((strlen(p) < 9) || strncmp(p, "critical,", 9))
		return 0;
	p += 9;
	while (isspace((unsigned char)*p)) p++;
		*value = p;
	return 1;
}

/* Check extension string for generic extension and return the type */
static int
v3_check_generic(char **value)
{
	int gen_type = 0;
	char *p = *value;

	if ((strlen(p) >= 4) && !strncmp(p, "DER:", 4)) {
		p += 4;
		gen_type = 1;
	} else if ((strlen(p) >= 5) && !strncmp(p, "ASN1:", 5)) {
		p += 5;
		gen_type = 2;
	} else
		return 0;

	while (isspace((unsigned char)*p))
		p++;
	*value = p;
	return gen_type;
}

/* Create a generic extension: for now just handle DER type */
static X509_EXTENSION *
v3_generic_extension(const char *ext, char *value, int crit, int gen_type,
    X509V3_CTX *ctx)
{
	unsigned char *ext_der = NULL;
	long ext_len = 0;
	ASN1_OBJECT *obj = NULL;
	ASN1_OCTET_STRING *oct = NULL;
	X509_EXTENSION *extension = NULL;

	if (!(obj = OBJ_txt2obj(ext, 0))) {
		X509V3error(X509V3_R_EXTENSION_NAME_ERROR);
		ERR_asprintf_error_data("name=%s", ext);
		goto err;
	}

	if (gen_type == 1)
		ext_der = string_to_hex(value, &ext_len);
	else if (gen_type == 2)
		ext_der = generic_asn1(value, ctx, &ext_len);
	else {
		ERR_asprintf_error_data("Unexpected generic extension type %d", gen_type);
		goto err;
	}

	if (ext_der == NULL) {
		X509V3error(X509V3_R_EXTENSION_VALUE_ERROR);
		ERR_asprintf_error_data("value=%s", value);
		goto err;
	}

	if (!(oct = ASN1_OCTET_STRING_new())) {
		X509V3error(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	oct->data = ext_der;
	oct->length = ext_len;
	ext_der = NULL;

	extension = X509_EXTENSION_create_by_OBJ(NULL, obj, crit, oct);

err:
	ASN1_OBJECT_free(obj);
	ASN1_OCTET_STRING_free(oct);
	free(ext_der);
	return extension;
}

static unsigned char *
generic_asn1(char *value, X509V3_CTX *ctx, long *ext_len)
{
	ASN1_TYPE *typ;
	unsigned char *ext_der = NULL;

	typ = ASN1_generate_v3(value, ctx);
	if (typ == NULL)
		return NULL;
	*ext_len = i2d_ASN1_TYPE(typ, &ext_der);
	ASN1_TYPE_free(typ);
	return ext_der;
}

/* This is the main function: add a bunch of extensions based on a config file
 * section to an extension STACK.
 */

int
X509V3_EXT_add_nconf_sk(CONF *conf, X509V3_CTX *ctx, char *section,
    STACK_OF(X509_EXTENSION) **sk)
{
	X509_EXTENSION *ext;
	STACK_OF(CONF_VALUE) *nval;
	CONF_VALUE *val;
	int i;

	if (!(nval = NCONF_get_section(conf, section)))
		return 0;
	for (i = 0; i < sk_CONF_VALUE_num(nval); i++) {
		val = sk_CONF_VALUE_value(nval, i);
		if (!(ext = X509V3_EXT_nconf(conf, ctx, val->name, val->value)))
			return 0;
		if (sk)
			X509v3_add_ext(sk, ext, -1);
		X509_EXTENSION_free(ext);
	}
	return 1;
}

/* Convenience functions to add extensions to a certificate, CRL and request */

int
X509V3_EXT_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section, X509 *cert)
{
	STACK_OF(X509_EXTENSION) **sk = NULL;

	if (cert)
		sk = &cert->cert_info->extensions;
	return X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);
}

/* Same as above but for a CRL */

int
X509V3_EXT_CRL_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,
    X509_CRL *crl)
{
	STACK_OF(X509_EXTENSION) **sk = NULL;

	if (crl)
		sk = &crl->crl->extensions;
	return X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);
}

/* Add extensions to certificate request */

int
X509V3_EXT_REQ_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,
    X509_REQ *req)
{
	STACK_OF(X509_EXTENSION) *extlist = NULL, **sk = NULL;
	int i;

	if (req)
		sk = &extlist;
	i = X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);
	if (!i || !sk)
		return i;
	i = X509_REQ_add_extensions(req, extlist);
	sk_X509_EXTENSION_pop_free(extlist, X509_EXTENSION_free);
	return i;
}

/* Config database functions */

char *
X509V3_get_string(X509V3_CTX *ctx, char *name, char *section)
{
	if (!ctx->db || !ctx->db_meth || !ctx->db_meth->get_string) {
		X509V3error(X509V3_R_OPERATION_NOT_DEFINED);
		return NULL;
	}
	if (ctx->db_meth->get_string)
		return ctx->db_meth->get_string(ctx->db, name, section);
	return NULL;
}

STACK_OF(CONF_VALUE) *
X509V3_get_section(X509V3_CTX *ctx, char *section)
{
	if (!ctx->db || !ctx->db_meth || !ctx->db_meth->get_section) {
		X509V3error(X509V3_R_OPERATION_NOT_DEFINED);
		return NULL;
	}
	if (ctx->db_meth->get_section)
		return ctx->db_meth->get_section(ctx->db, section);
	return NULL;
}

void
X509V3_string_free(X509V3_CTX *ctx, char *str)
{
	if (!str)
		return;
	if (ctx->db_meth->free_string)
		ctx->db_meth->free_string(ctx->db, str);
}

void
X509V3_section_free(X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *section)
{
	if (!section)
		return;
	if (ctx->db_meth->free_section)
		ctx->db_meth->free_section(ctx->db, section);
}

static char *
nconf_get_string(void *db, char *section, char *value)
{
	return NCONF_get_string(db, section, value);
}

static
STACK_OF(CONF_VALUE) *nconf_get_section(void *db, char *section)
{
	return NCONF_get_section(db, section);
}

static X509V3_CONF_METHOD nconf_method = {
	nconf_get_string,
	nconf_get_section,
	NULL,
	NULL
};

void
X509V3_set_nconf(X509V3_CTX *ctx, CONF *conf)
{
	ctx->db_meth = &nconf_method;
	ctx->db = conf;
}

void
X509V3_set_ctx(X509V3_CTX *ctx, X509 *issuer, X509 *subj, X509_REQ *req,
    X509_CRL *crl, int flags)
{
	ctx->issuer_cert = issuer;
	ctx->subject_cert = subj;
	ctx->crl = crl;
	ctx->subject_req = req;
	ctx->flags = flags;
}

/* Old conf compatibility functions */

X509_EXTENSION *
X509V3_EXT_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx, char *name,
    char *value)
{
	CONF ctmp;

	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_nconf(&ctmp, ctx, name, value);
}

/* LHASH *conf:  Config file    */
/* char *value:  Value    */
X509_EXTENSION *
X509V3_EXT_conf_nid(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx, int ext_nid,
    char *value)
{
	CONF ctmp;

	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_nconf_nid(&ctmp, ctx, ext_nid, value);
}

static char *
conf_lhash_get_string(void *db, char *section, char *value)
{
	return CONF_get_string(db, section, value);
}

static STACK_OF(CONF_VALUE) *
conf_lhash_get_section(void *db, char *section)
{
	return CONF_get_section(db, section);
}

static X509V3_CONF_METHOD conf_lhash_method = {
	conf_lhash_get_string,
	conf_lhash_get_section,
	NULL,
	NULL
};

void
X509V3_set_conf_lhash(X509V3_CTX *ctx, LHASH_OF(CONF_VALUE) *lhash)
{
	ctx->db_meth = &conf_lhash_method;
	ctx->db = lhash;
}

int
X509V3_EXT_add_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx, char *section,
    X509 *cert)
{
	CONF ctmp;

	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_add_nconf(&ctmp, ctx, section, cert);
}

/* Same as above but for a CRL */

int
X509V3_EXT_CRL_add_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
    char *section, X509_CRL *crl)
{
	CONF ctmp;

	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_CRL_add_nconf(&ctmp, ctx, section, crl);
}

/* Add extensions to certificate request */

int
X509V3_EXT_REQ_add_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
    char *section, X509_REQ *req)
{
	CONF ctmp;

	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_REQ_add_nconf(&ctmp, ctx, section, req);
}
@


1.20
log
@Expand ASN1_ITEM_ref and ASN1_ITEM_ptr macros - no change in generated
assembly. Of particular interest is ASN1_ITEM_ptr which does nothing
and resulted in code like:

  if (method->it)
    ASN1_ITEM_free(..., ASN1_ITEM_ptr(method->it));
@
text
@d1 1
a1 1
/* $OpenBSD: v3_conf.c,v 1.19 2015/12/14 03:39:14 beck Exp $ */
d96 1
a96 2
		X509V3err(X509V3_F_X509V3_EXT_NCONF,
		    X509V3_R_ERROR_IN_EXTENSION);
d127 1
a127 2
		X509V3err(X509V3_F_DO_EXT_NCONF,
		    X509V3_R_UNKNOWN_EXTENSION_NAME);
d131 1
a131 1
		X509V3err(X509V3_F_DO_EXT_NCONF, X509V3_R_UNKNOWN_EXTENSION);
d143 1
a143 2
			X509V3err(X509V3_F_DO_EXT_NCONF,
			    X509V3_R_INVALID_EXTENSION_STRING);
d157 1
a157 2
			X509V3err(X509V3_F_DO_EXT_NCONF,
			    X509V3_R_NO_CONFIG_DATABASE);
d162 1
a162 2
		X509V3err(X509V3_F_DO_EXT_NCONF,
		    X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED);
d215 1
a215 1
	X509V3err(X509V3_F_DO_EXT_I2D, ERR_R_MALLOC_FAILURE);
d228 1
a228 1
		X509V3err(X509V3_F_X509V3_EXT_I2D, X509V3_R_UNKNOWN_EXTENSION);
d282 1
a282 2
		X509V3err(X509V3_F_V3_GENERIC_EXTENSION,
		    X509V3_R_EXTENSION_NAME_ERROR);
d297 1
a297 2
		X509V3err(X509V3_F_V3_GENERIC_EXTENSION,
		    X509V3_R_EXTENSION_VALUE_ERROR);
d303 1
a303 1
		X509V3err(X509V3_F_V3_GENERIC_EXTENSION, ERR_R_MALLOC_FAILURE);
d410 1
a410 2
		X509V3err(X509V3_F_X509V3_GET_STRING,
		    X509V3_R_OPERATION_NOT_DEFINED);
d422 1
a422 2
		X509V3err(X509V3_F_X509V3_GET_SECTION,
		    X509V3_R_OPERATION_NOT_DEFINED);
@


1.19
log
@initialize ext_len to 0.
ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_conf.c,v 1.18 2015/09/30 18:41:06 jsing Exp $ */
d176 1
a176 1
		ASN1_item_free(ext_struc, ASN1_ITEM_ptr(method->it));
d195 1
a195 1
		    ASN1_ITEM_ptr(method->it));
@


1.18
log
@Replace M_ASN1_OCTET_STRING_(free|new) with ASN1_OCTET_STRING_(free|new).
@
text
@d1 1
a1 1
/* $OpenBSD: v3_conf.c,v 1.17 2015/02/17 05:14:38 miod Exp $ */
d281 1
a281 1
	long ext_len;
d297 4
@


1.17
log
@Memory leak in error path. Coverity CID 78822.
ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_conf.c,v 1.16 2014/10/05 18:26:43 miod Exp $ */
d206 1
a206 1
	if (!(ext_oct = M_ASN1_OCTET_STRING_new()))
d214 1
a214 1
	M_ASN1_OCTET_STRING_free(ext_oct);
d219 1
a219 1
	M_ASN1_OCTET_STRING_free(ext_oct);
d305 1
a305 1
	if (!(oct = M_ASN1_OCTET_STRING_new())) {
d318 1
a318 1
	M_ASN1_OCTET_STRING_free(oct);
@


1.16
log
@Missing deallocation upon error.
ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_conf.c,v 1.15 2014/07/11 08:44:49 jsing Exp $ */
a124 1
	STACK_OF(CONF_VALUE) *nval;
d138 2
d149 2
a155 2
		if (!ext_struc)
			return NULL;
d157 1
a157 2
		if (!(ext_struc = method->s2i(method, ctx, value)))
			return NULL;
d164 1
a164 2
		if (!(ext_struc = method->r2i(method, ctx, value)))
			return NULL;
d171 2
@


1.15
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_conf.c,v 1.14 2014/07/10 13:58:23 jsing Exp $ */
d187 1
a187 1
	ASN1_OCTET_STRING *ext_oct;
d218 1
@


1.14
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: v3_conf.c,v 1.13 2014/06/12 15:49:31 deraadt Exp $ */
a63 1
#include "cryptlib.h"
d65 1
@


1.13
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 3
a63 2
#include <stdio.h>
#include <ctype.h>
@


1.12
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d1 1
a1 1
/* v3_conf.c */
@


1.11
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d316 1
a316 2
	if (ext_der)
		free(ext_der);
@


1.10
log
@KNF.
@
text
@d97 1
a97 1
		ERR_add_error_data(4, "name=", name, ", value=", value);
d145 2
a146 2
			ERR_add_error_data(4, "name=", OBJ_nid2sn(ext_nid),
			    ",section=", value);
d168 1
a168 1
		ERR_add_error_data(2, "name=", OBJ_nid2sn(ext_nid));
d286 1
a286 1
		ERR_add_error_data(2, "name=", ext);
d298 1
a298 1
		ERR_add_error_data(2, "value=", value);
@


1.9
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
a60 1

d70 4
a73 2
static X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid, int crit, char *value);
static X509_EXTENSION *v3_generic_extension(const char *ext, char *value, int crit, int type, X509V3_CTX *ctx);
d77 1
a77 1
				  int crit, void *ext_struc);
d79 1
d83 3
a85 3
X509_EXTENSION *X509V3_EXT_nconf(CONF *conf, X509V3_CTX *ctx, char *name,
				 char *value)
	{
d89 1
d91 1
a91 1
	if ((ext_type = v3_check_generic(&value))) 
d94 5
a98 5
	if (!ret)
		{
		X509V3err(X509V3_F_X509V3_EXT_NCONF,X509V3_R_ERROR_IN_EXTENSION);
		ERR_add_error_data(4,"name=", name, ", value=", value);
		}
d100 1
a100 1
	}
d104 3
a106 3
X509_EXTENSION *X509V3_EXT_nconf_nid(CONF *conf, X509V3_CTX *ctx, int ext_nid,
				     char *value)
	{
d109 1
d111 1
a111 1
	if ((ext_type = v3_check_generic(&value))) 
d113 1
a113 1
						 value, crit, ext_type, ctx);
d115 1
a115 1
	}
d119 3
a121 3
static X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid,
				    int crit, char *value)
	{
d126 4
a129 3
	if (ext_nid == NID_undef)
		{
		X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_UNKNOWN_EXTENSION_NAME);
d131 3
a133 4
		}
	if (!(method = X509V3_EXT_get_nid(ext_nid)))
		{
		X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_UNKNOWN_EXTENSION);
d135 1
a135 1
		}
d137 10
a146 8
	if (method->v2i)
		{
		if(*value == '@@') nval = NCONF_get_section(conf, value + 1);
		else nval = X509V3_parse_list(value);
		if(sk_CONF_VALUE_num(nval) <= 0)
			{
			X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_INVALID_EXTENSION_STRING);
			ERR_add_error_data(4, "name=", OBJ_nid2sn(ext_nid), ",section=", value);
d148 1
a148 1
			}
d150 12
a161 7
		if(*value != '@@') sk_CONF_VALUE_pop_free(nval,
							 X509V3_conf_free);
		if(!ext_struc) return NULL;
		}
	else if(method->s2i)
		{
		if(!(ext_struc = method->s2i(method, ctx, value))) return NULL;
d163 1
a163 5
	else if(method->r2i)
		{
		if(!ctx->db || !ctx->db_meth)
			{
			X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_NO_CONFIG_DATABASE);
d165 3
a167 6
			}
		if(!(ext_struc = method->r2i(method, ctx, value))) return NULL;
		}
	else
		{
		X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED);
d170 1
a170 1
		}
d172 5
a176 3
	ext  = do_ext_i2d(method, ext_nid, crit, ext_struc);
	if(method->it) ASN1_item_free(ext_struc, ASN1_ITEM_ptr(method->it));
	else method->ext_free(ext_struc);
d178 1
d180 4
a183 5
	}

static X509_EXTENSION *do_ext_i2d(const X509V3_EXT_METHOD *method, int ext_nid,
				  int crit, void *ext_struc)
	{
d188 1
d190 1
a190 2
	if (method->it)
		{
d192 5
a196 5
		ext_len = ASN1_item_i2d(ext_struc, &ext_der, ASN1_ITEM_ptr(method->it));
		if (ext_len < 0) goto merr;
		}
	 else
		{
d199 2
a200 1
		if(!(ext_der = malloc(ext_len))) goto merr;
d203 3
a205 2
		}
	if (!(ext_oct = M_ASN1_OCTET_STRING_new())) goto merr;
d210 2
a211 1
	if (!ext) goto merr;
d216 2
a217 2
	merr:
	X509V3err(X509V3_F_DO_EXT_I2D,ERR_R_MALLOC_FAILURE);
d220 1
a220 1
	}
d224 3
a226 2
X509_EXTENSION *X509V3_EXT_i2d(int ext_nid, int crit, void *ext_struc)
	{
d228 1
d230 1
a230 1
		X509V3err(X509V3_F_X509V3_EXT_I2D,X509V3_R_UNKNOWN_EXTENSION);
d237 2
a238 1
static int v3_check_critical(char **value)
d241 6
a246 4
	if ((strlen(p) < 9) || strncmp(p, "critical,", 9)) return 0;
	p+=9;
	while(isspace((unsigned char)*p)) p++;
	*value = p;
d251 2
a252 1
static int v3_check_generic(char **value)
d256 3
a258 3
	if ((strlen(p) >= 4) && !strncmp(p, "DER:", 4))
		{
		p+=4;
d260 2
a261 4
		}
	else if ((strlen(p) >= 5) && !strncmp(p, "ASN1:", 5))
		{
		p+=5;
d263 1
a263 2
		}
	else
d266 2
a267 1
	while (isspace((unsigned char)*p)) p++;
d273 5
a277 5
static X509_EXTENSION *v3_generic_extension(const char *ext, char *value,
					    int crit, int gen_type,
					    X509V3_CTX *ctx)
	{
	unsigned char *ext_der=NULL;
d279 7
a285 6
	ASN1_OBJECT *obj=NULL;
	ASN1_OCTET_STRING *oct=NULL;
	X509_EXTENSION *extension=NULL;
	if (!(obj = OBJ_txt2obj(ext, 0)))
		{
		X509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_NAME_ERROR);
d288 1
a288 1
		}
d295 3
a297 3
	if (ext_der == NULL)
		{
		X509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_VALUE_ERROR);
d300 1
a300 1
		}
d302 2
a303 3
	if (!(oct = M_ASN1_OCTET_STRING_new()))
		{
		X509V3err(X509V3_F_V3_GENERIC_EXTENSION,ERR_R_MALLOC_FAILURE);
d305 1
a305 1
		}
d313 1
a313 1
	err:
d316 2
a317 1
	if(ext_der) free(ext_der);
d319 1
d321 3
a323 4
	}

static unsigned char *generic_asn1(char *value, X509V3_CTX *ctx, long *ext_len)
	{
d326 1
d333 1
a333 1
	}
d339 4
a342 4

int X509V3_EXT_add_nconf_sk(CONF *conf, X509V3_CTX *ctx, char *section,
			    STACK_OF(X509_EXTENSION) **sk)
	{
d345 1
a345 1
	CONF_VALUE *val;	
d347 4
a350 3
	if (!(nval = NCONF_get_section(conf, section))) return 0;
	for (i = 0; i < sk_CONF_VALUE_num(nval); i++)
		{
d353 3
a355 2
								return 0;
		if (sk) X509v3_add_ext(sk, ext, -1);
d357 1
a357 1
		}
d359 1
a359 1
	}
d363 3
a365 3
int X509V3_EXT_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,
			 X509 *cert)
	{
d367 1
d371 1
a371 1
	}
d375 4
a378 3
int X509V3_EXT_CRL_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,
			     X509_CRL *crl)
	{
d380 1
d384 1
a384 1
	}
d388 4
a391 3
int X509V3_EXT_REQ_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,
	     X509_REQ *req)
	{
d394 1
d403 1
a403 1
	}
d407 6
a412 5
char * X509V3_get_string(X509V3_CTX *ctx, char *name, char *section)
	{
	if(!ctx->db || !ctx->db_meth || !ctx->db_meth->get_string)
		{
		X509V3err(X509V3_F_X509V3_GET_STRING,X509V3_R_OPERATION_NOT_DEFINED);
d414 1
a414 1
		}
d416 1
a416 1
			return ctx->db_meth->get_string(ctx->db, name, section);
d418 1
a418 1
	}
d420 6
a425 5
STACK_OF(CONF_VALUE) * X509V3_get_section(X509V3_CTX *ctx, char *section)
	{
	if(!ctx->db || !ctx->db_meth || !ctx->db_meth->get_section)
		{
		X509V3err(X509V3_F_X509V3_GET_SECTION,X509V3_R_OPERATION_NOT_DEFINED);
d427 1
a427 1
		}
d429 1
a429 1
			return ctx->db_meth->get_section(ctx->db, section);
d431 1
a431 1
	}
d433 5
a437 3
void X509V3_string_free(X509V3_CTX *ctx, char *str)
	{
	if (!str) return;
d439 2
a440 2
			ctx->db_meth->free_string(ctx->db, str);
	}
d442 5
a446 3
void X509V3_section_free(X509V3_CTX *ctx, STACK_OF(CONF_VALUE) *section)
	{
	if (!section) return;
d448 2
a449 2
			ctx->db_meth->free_section(ctx->db, section);
	}
d451 3
a453 2
static char *nconf_get_string(void *db, char *section, char *value)
	{
d455 1
a455 1
	}
d457 3
a459 2
static STACK_OF(CONF_VALUE) *nconf_get_section(void *db, char *section)
	{
d461 1
a461 1
	}
d464 4
a467 4
nconf_get_string,
nconf_get_section,
NULL,
NULL
d470 3
a472 2
void X509V3_set_nconf(X509V3_CTX *ctx, CONF *conf)
	{
d475 1
a475 1
	}
d477 4
a480 3
void X509V3_set_ctx(X509V3_CTX *ctx, X509 *issuer, X509 *subj, X509_REQ *req,
		    X509_CRL *crl, int flags)
	{
d486 1
a486 1
	}
d490 4
a493 3
X509_EXTENSION *X509V3_EXT_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
				char *name, char *value)
	{
d495 1
d498 1
a498 1
	}
d502 4
a505 3
X509_EXTENSION *X509V3_EXT_conf_nid(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
				    int ext_nid, char *value)
	{
d507 1
d510 1
a510 1
	}
d512 3
a514 2
static char *conf_lhash_get_string(void *db, char *section, char *value)
	{
d516 1
a516 1
	}
d518 3
a520 2
static STACK_OF(CONF_VALUE) *conf_lhash_get_section(void *db, char *section)
	{
d522 1
a522 1
	}
d525 4
a528 4
conf_lhash_get_string,
conf_lhash_get_section,
NULL,
NULL
d531 3
a533 2
void X509V3_set_conf_lhash(X509V3_CTX *ctx, LHASH_OF(CONF_VALUE) *lhash)
	{
d536 1
a536 1
	}
d538 4
a541 3
int X509V3_EXT_add_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
			char *section, X509 *cert)
	{
d543 1
d546 1
a546 1
	}
d550 4
a553 3
int X509V3_EXT_CRL_add_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
			    char *section, X509_CRL *crl)
	{
d555 1
d558 1
a558 1
	}
d562 4
a565 3
int X509V3_EXT_REQ_add_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
			    char *section, X509_REQ *req)
	{
d567 1
d570 1
a570 1
	}
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d193 1
a193 1
		if(!(ext_der = OPENSSL_malloc(ext_len))) goto merr;
d303 1
a303 1
	if(ext_der) OPENSSL_free(ext_der);
@


1.7
log
@resolve conflicts
@
text
@d75 2
a76 2
static X509_EXTENSION *do_ext_i2d(X509V3_EXT_METHOD *method, int ext_nid,
						 int crit, void *ext_struc);
d82 1
a82 1
	     char *value)
d102 1
a102 1
	     char *value)
d116 1
a116 1
	     int crit, char *value)
d118 1
a118 1
	X509V3_EXT_METHOD *method;
d175 2
a176 2
static X509_EXTENSION *do_ext_i2d(X509V3_EXT_METHOD *method, int ext_nid,
						 int crit, void *ext_struc)
d217 1
a217 1
	X509V3_EXT_METHOD *method;
d261 2
a262 1
	     int crit, int gen_type, X509V3_CTX *ctx)
d326 1
a326 1
	     STACK_OF(X509_EXTENSION) **sk)
d347 1
a347 1
	     X509 *cert)
d358 1
a358 1
	     X509_CRL *crl)
d447 1
a447 1
	     X509_CRL *crl, int flags)
d458 2
a459 2
X509_EXTENSION *X509V3_EXT_conf(LHASH *conf, X509V3_CTX *ctx, char *name,
	     char *value)
d468 2
a469 2
X509_EXTENSION *X509V3_EXT_conf_nid(LHASH *conf, X509V3_CTX *ctx, int ext_nid,
	     char *value)
d493 1
a493 1
void X509V3_set_conf_lhash(X509V3_CTX *ctx, LHASH *lhash)
d499 2
a500 2
int X509V3_EXT_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,
	     X509 *cert)
d509 2
a510 2
int X509V3_EXT_CRL_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,
	     X509_CRL *crl)
d519 2
a520 2
int X509V3_EXT_REQ_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,
	     X509_REQ *req)
@


1.6
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.5
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d72 1
a72 1
static X509_EXTENSION *v3_generic_extension(const char *ext, char *value, int crit, int type);
d77 1
d89 1
a89 1
		return v3_generic_extension(name, value, crit, ext_type);
d93 1
a93 1
		X509V3err(X509V3_F_X509V3_EXT_CONF,X509V3_R_ERROR_IN_EXTENSION);
d109 1
a109 1
							 value, crit, ext_type);
d124 1
a124 1
		X509V3err(X509V3_F_DO_EXT_CONF,X509V3_R_UNKNOWN_EXTENSION_NAME);
d129 1
a129 1
		X509V3err(X509V3_F_DO_EXT_CONF,X509V3_R_UNKNOWN_EXTENSION);
d137 1
a137 1
		if(!nval)
d139 1
a139 1
			X509V3err(X509V3_F_X509V3_EXT_CONF,X509V3_R_INVALID_EXTENSION_STRING);
d154 1
a154 1
		if(!ctx->db)
d156 1
a156 1
			X509V3err(X509V3_F_X509V3_EXT_CONF,X509V3_R_NO_CONFIG_DATABASE);
d163 1
a163 1
		X509V3err(X509V3_F_X509V3_EXT_CONF,X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED);
d239 1
d241 13
a253 2
	if ((strlen(p) < 4) || strncmp(p, "DER:", 4)) return 0;
	p+=4;
d256 1
a256 1
	return 1;
d261 1
a261 1
	     int crit, int type)
d275 6
a280 1
	if (!(ext_der = string_to_hex(value, &ext_len)))
d307 11
d386 5
d398 5
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d239 1
a239 1
	if ((strlen(p) < 4) || strncmp(p, "DER:,", 4)) return 0;
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d71 1
a71 1
static X509_EXTENSION *do_ext_conf(LHASH *conf, X509V3_CTX *ctx, int ext_nid, int crit, char *value);
d77 1
a77 1
/* LHASH *conf:  Config file    */
d80 1
a80 1
X509_EXTENSION *X509V3_EXT_conf(LHASH *conf, X509V3_CTX *ctx, char *name,
d82 1
a82 1
{
d87 1
a87 1
	if((ext_type = v3_check_generic(&value))) 
d89 3
a91 2
	ret = do_ext_conf(conf, ctx, OBJ_sn2nid(name), crit, value);
	if(!ret) {
d94 2
a96 2
	return ret;
}
d98 1
a98 1
/* LHASH *conf:  Config file    */
d100 1
a100 1
X509_EXTENSION *X509V3_EXT_conf_nid(LHASH *conf, X509V3_CTX *ctx, int ext_nid,
d102 1
a102 1
{
d106 1
a106 1
	if((ext_type = v3_check_generic(&value))) 
d109 2
a110 2
	return do_ext_conf(conf, ctx, ext_nid, crit, value);
}
d112 1
a112 1
/* LHASH *conf:  Config file    */
d114 1
a114 1
static X509_EXTENSION *do_ext_conf(LHASH *conf, X509V3_CTX *ctx, int ext_nid,
d116 1
a116 1
{
d121 2
a122 1
	if(ext_nid == NID_undef) {
d125 3
a127 2
	}
	if(!(method = X509V3_EXT_get_nid(ext_nid))) {
d130 1
a130 1
	}
d132 3
a134 2
	if(method->v2i) {
		if(*value == '@@') nval = CONF_get_section(conf, value + 1);
d136 2
a137 1
		if(!nval) {
d141 1
a141 1
		}
d146 3
a148 1
	} else if(method->s2i) {
d150 5
a154 2
	} else if(method->r2i) {
		if(!ctx->db) {
d157 2
d160 2
a161 2
		if(!(ext_struc = method->r2i(method, ctx, value))) return NULL;
	} else {
d165 1
a165 1
	}
d168 2
a169 1
	method->ext_free(ext_struc);
d172 1
a172 1
}
d176 2
a177 2
{
	unsigned char *ext_der, *p;
d182 15
a196 5
	ext_len = method->i2d(ext_struc, NULL);
	if(!(ext_der = OPENSSL_malloc(ext_len))) goto merr;
	p = ext_der;
	method->i2d(ext_struc, &p);
	if(!(ext_oct = M_ASN1_OCTET_STRING_new())) goto merr;
d199 1
a199 1
	
d201 1
a201 1
	if(!ext) goto merr;
d210 1
a210 1
}
d215 1
a215 1
{
d217 1
a217 1
	if(!(method = X509V3_EXT_get_nid(ext_nid))) {
d228 1
a228 1
	if((strlen(p) < 9) || strncmp(p, "critical,", 9)) return 0;
d239 1
a239 1
	if((strlen(p) < 4) || strncmp(p, "DER:,", 4)) return 0;
d241 1
a241 1
	while(isspace((unsigned char)*p)) p++;
d249 19
a267 11
{
unsigned char *ext_der=NULL;
long ext_len;
ASN1_OBJECT *obj=NULL;
ASN1_OCTET_STRING *oct=NULL;
X509_EXTENSION *extension=NULL;
if(!(obj = OBJ_txt2obj(ext, 0))) {
	X509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_NAME_ERROR);
	ERR_add_error_data(2, "name=", ext);
	goto err;
}
d269 5
a273 5
if(!(ext_der = string_to_hex(value, &ext_len))) {
	X509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_VALUE_ERROR);
	ERR_add_error_data(2, "value=", value);
	goto err;
}
d275 11
a285 4
if(!(oct = M_ASN1_OCTET_STRING_new())) {
	X509V3err(X509V3_F_V3_GENERIC_EXTENSION,ERR_R_MALLOC_FAILURE);
	goto err;
}
d287 1
a287 12
oct->data = ext_der;
oct->length = ext_len;
ext_der = NULL;

extension = X509_EXTENSION_create_by_OBJ(NULL, obj, crit, oct);

err:
ASN1_OBJECT_free(obj);
M_ASN1_OCTET_STRING_free(oct);
if(ext_der) OPENSSL_free(ext_der);
return extension;
}
d291 1
a291 1
 * section
d294 4
a297 3
int X509V3_EXT_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,
	     X509 *cert)
{
d302 3
a304 2
	if(!(nval = CONF_get_section(conf, section))) return 0;
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++) {
d306 1
a306 1
		if(!(ext = X509V3_EXT_conf(conf, ctx, val->name, val->value)))
d308 1
a308 1
		if(cert) X509_add_ext(cert, ext, -1);
d310 13
a323 2
	return 1;
}
d327 1
a327 1
int X509V3_EXT_CRL_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,
d329 5
a333 12
{
	X509_EXTENSION *ext;
	STACK_OF(CONF_VALUE) *nval;
	CONF_VALUE *val;	
	int i;
	if(!(nval = CONF_get_section(conf, section))) return 0;
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++) {
		val = sk_CONF_VALUE_value(nval, i);
		if(!(ext = X509V3_EXT_conf(conf, ctx, val->name, val->value)))
								return 0;
		if(crl) X509_CRL_add_ext(crl, ext, -1);
		X509_EXTENSION_free(ext);
a334 2
	return 1;
}
d338 1
a338 1
int X509V3_EXT_REQ_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,
d340 2
a341 5
{
	X509_EXTENSION *ext;
	STACK_OF(X509_EXTENSION) *extlist = NULL;
	STACK_OF(CONF_VALUE) *nval;
	CONF_VALUE *val;	
d343 6
a348 10
	if(!(nval = CONF_get_section(conf, section))) return 0;
	for(i = 0; i < sk_CONF_VALUE_num(nval); i++) {
		val = sk_CONF_VALUE_value(nval, i);
		if(!(ext = X509V3_EXT_conf(conf, ctx, val->name, val->value)))
								return 0;
		if(!extlist) extlist = sk_X509_EXTENSION_new_null();
		sk_X509_EXTENSION_push(extlist, ext);
	}
	if(req) i = X509_REQ_add_extensions(req, extlist);
	else i = 1;
d351 1
a351 1
}
d356 2
a357 2
{
	if(ctx->db_meth->get_string)
d360 1
a360 1
}
d363 2
a364 2
{
	if(ctx->db_meth->get_section)
d367 1
a367 1
}
d370 3
a372 3
{
	if(!str) return;
	if(ctx->db_meth->free_string)
d374 1
a374 1
}
d377 3
a379 3
{
	if(!section) return;
	if(ctx->db_meth->free_section)
d381 54
a434 1
}
d437 1
a437 1
{
d439 1
a439 1
}
d442 1
a442 1
{
d444 1
a444 1
}
d454 1
a454 1
{
d457 21
a477 1
}
d479 7
a485 9
void X509V3_set_ctx(X509V3_CTX *ctx, X509 *issuer, X509 *subj, X509_REQ *req,
	     X509_CRL *crl, int flags)
{
	ctx->issuer_cert = issuer;
	ctx->subject_cert = subj;
	ctx->crl = crl;
	ctx->subject_req = req;
	ctx->flags = flags;
}
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d170 1
a170 1
	if(!(ext_der = Malloc(ext_len))) goto merr;
d258 1
a258 1
if(ext_der) Free(ext_der);
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d173 1
a173 1
	if(!(ext_oct = ASN1_OCTET_STRING_new())) goto merr;
d179 1
a179 1
	ASN1_OCTET_STRING_free(ext_oct);
d223 1
a223 1
/* Create a generic extension: for now just handle RAW type */
d244 1
a244 1
if(!(oct = ASN1_OCTET_STRING_new())) {
d257 1
a257 1
ASN1_OCTET_STRING_free(oct);
d303 24
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d71 1
a71 1
static X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid, int crit, char *value);
d77 1
a77 1
/* CONF *conf:  Config file    */
d80 1
a80 1
X509_EXTENSION *X509V3_EXT_nconf(CONF *conf, X509V3_CTX *ctx, char *name,
d82 1
a82 1
	{
d87 1
a87 1
	if ((ext_type = v3_check_generic(&value))) 
d89 2
a90 3
	ret = do_ext_nconf(conf, ctx, OBJ_sn2nid(name), crit, value);
	if (!ret)
		{
d93 1
a93 1
		}
d95 1
a95 1
	}
d97 1
a97 1
/* CONF *conf:  Config file    */
d99 1
a99 1
X509_EXTENSION *X509V3_EXT_nconf_nid(CONF *conf, X509V3_CTX *ctx, int ext_nid,
d101 1
a101 1
	{
d105 1
a105 1
	if ((ext_type = v3_check_generic(&value))) 
d108 2
a109 2
	return do_ext_nconf(conf, ctx, ext_nid, crit, value);
	}
d111 1
a111 1
/* CONF *conf:  Config file    */
d113 1
a113 1
static X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid,
d115 1
a115 1
	{
d120 1
a120 2
	if (ext_nid == NID_undef)
		{
d123 2
a124 3
		}
	if (!(method = X509V3_EXT_get_nid(ext_nid)))
		{
d127 1
a127 1
		}
d129 2
a130 3
	if (method->v2i)
		{
		if(*value == '@@') nval = NCONF_get_section(conf, value + 1);
d132 1
a132 2
		if(!nval)
			{
d136 1
a136 1
			}
d141 1
a141 3
		}
	else if(method->s2i)
		{
d143 2
a144 5
		}
	else if(method->r2i)
		{
		if(!ctx->db)
			{
d147 1
a147 1
			}
d149 1
a149 3
		}
	else
		{
d153 1
a153 1
		}
d156 1
a156 2
	if(method->it) ASN1_item_free(ext_struc, ASN1_ITEM_ptr(method->it));
	else method->ext_free(ext_struc);
d159 1
a159 1
	}
d163 2
a164 2
	{
	unsigned char *ext_der;
d169 5
a173 15
	if (method->it)
		{
		ext_der = NULL;
		ext_len = ASN1_item_i2d(ext_struc, &ext_der, ASN1_ITEM_ptr(method->it));
		if (ext_len < 0) goto merr;
		}
	 else
		{
		unsigned char *p;
		ext_len = method->i2d(ext_struc, NULL);
		if(!(ext_der = OPENSSL_malloc(ext_len))) goto merr;
		p = ext_der;
		method->i2d(ext_struc, &p);
		}
	if (!(ext_oct = M_ASN1_OCTET_STRING_new())) goto merr;
d176 1
a176 1

d178 2
a179 2
	if (!ext) goto merr;
	M_ASN1_OCTET_STRING_free(ext_oct);
d187 1
a187 1
	}
d192 1
a192 1
	{
d194 1
a194 1
	if (!(method = X509V3_EXT_get_nid(ext_nid))) {
d205 1
a205 1
	if ((strlen(p) < 9) || strncmp(p, "critical,", 9)) return 0;
d216 1
a216 1
	if ((strlen(p) < 4) || strncmp(p, "DER:,", 4)) return 0;
d218 1
a218 1
	while (isspace((unsigned char)*p)) p++;
d223 1
a223 1
/* Create a generic extension: for now just handle DER type */
d226 11
a236 12
	{
	unsigned char *ext_der=NULL;
	long ext_len;
	ASN1_OBJECT *obj=NULL;
	ASN1_OCTET_STRING *oct=NULL;
	X509_EXTENSION *extension=NULL;
	if (!(obj = OBJ_txt2obj(ext, 0)))
		{
		X509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_NAME_ERROR);
		ERR_add_error_data(2, "name=", ext);
		goto err;
		}
d238 5
a242 6
	if (!(ext_der = string_to_hex(value, &ext_len)))
		{
		X509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_VALUE_ERROR);
		ERR_add_error_data(2, "value=", value);
		goto err;
		}
d244 4
a247 5
	if (!(oct = M_ASN1_OCTET_STRING_new()))
		{
		X509V3err(X509V3_F_V3_GENERIC_EXTENSION,ERR_R_MALLOC_FAILURE);
		goto err;
		}
d249 12
a260 13
	oct->data = ext_der;
	oct->length = ext_len;
	ext_der = NULL;

	extension = X509_EXTENSION_create_by_OBJ(NULL, obj, crit, oct);

	err:
	ASN1_OBJECT_free(obj);
	M_ASN1_OCTET_STRING_free(oct);
	if(ext_der) OPENSSL_free(ext_der);
	return extension;

	}
d264 1
a264 1
 * section to an extension STACK.
d267 3
a269 4

int X509V3_EXT_add_nconf_sk(CONF *conf, X509V3_CTX *ctx, char *section,
	     STACK_OF(X509_EXTENSION) **sk)
	{
d274 2
a275 3
	if (!(nval = NCONF_get_section(conf, section))) return 0;
	for (i = 0; i < sk_CONF_VALUE_num(nval); i++)
		{
d277 1
a277 1
		if (!(ext = X509V3_EXT_nconf(conf, ctx, val->name, val->value)))
d279 1
a279 1
		if (sk) X509v3_add_ext(sk, ext, -1);
d281 1
a281 1
		}
d283 1
a283 12
	}

/* Convenience functions to add extensions to a certificate, CRL and request */

int X509V3_EXT_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,
	     X509 *cert)
	{
	STACK_OF(X509_EXTENSION) **sk = NULL;
	if (cert)
		sk = &cert->cert_info->extensions;
	return X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);
	}
d287 1
a287 1
int X509V3_EXT_CRL_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,
d289 4
a292 13
	{
	STACK_OF(X509_EXTENSION) **sk = NULL;
	if (crl)
		sk = &crl->crl->extensions;
	return X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);
	}

/* Add extensions to certificate request */

int X509V3_EXT_REQ_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,
	     X509_REQ *req)
	{
	STACK_OF(X509_EXTENSION) *extlist = NULL, **sk = NULL;
d294 7
a300 8
	if (req)
		sk = &extlist;
	i = X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);
	if (!i || !sk)
		return i;
	i = X509_REQ_add_extensions(req, extlist);
	sk_X509_EXTENSION_pop_free(extlist, X509_EXTENSION_free);
	return i;
d302 2
d308 2
a309 2
	{
	if (ctx->db_meth->get_string)
d312 1
a312 1
	}
d315 2
a316 2
	{
	if (ctx->db_meth->get_section)
d319 1
a319 1
	}
d322 3
a324 3
	{
	if (!str) return;
	if (ctx->db_meth->free_string)
d326 1
a326 1
	}
d329 3
a331 3
	{
	if (!section) return;
	if (ctx->db_meth->free_section)
d333 1
a333 54
	}

static char *nconf_get_string(void *db, char *section, char *value)
	{
	return NCONF_get_string(db, section, value);
	}

static STACK_OF(CONF_VALUE) *nconf_get_section(void *db, char *section)
	{
	return NCONF_get_section(db, section);
	}

static X509V3_CONF_METHOD nconf_method = {
nconf_get_string,
nconf_get_section,
NULL,
NULL
};

void X509V3_set_nconf(X509V3_CTX *ctx, CONF *conf)
	{
	ctx->db_meth = &nconf_method;
	ctx->db = conf;
	}

void X509V3_set_ctx(X509V3_CTX *ctx, X509 *issuer, X509 *subj, X509_REQ *req,
	     X509_CRL *crl, int flags)
	{
	ctx->issuer_cert = issuer;
	ctx->subject_cert = subj;
	ctx->crl = crl;
	ctx->subject_req = req;
	ctx->flags = flags;
	}

/* Old conf compatibility functions */

X509_EXTENSION *X509V3_EXT_conf(LHASH *conf, X509V3_CTX *ctx, char *name,
	     char *value)
	{
	CONF ctmp;
	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_nconf(&ctmp, ctx, name, value);
	}

/* LHASH *conf:  Config file    */
/* char *value:  Value    */
X509_EXTENSION *X509V3_EXT_conf_nid(LHASH *conf, X509V3_CTX *ctx, int ext_nid,
	     char *value)
	{
	CONF ctmp;
	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_nconf_nid(&ctmp, ctx, ext_nid, value);
	}
d336 1
a336 1
	{
d338 1
a338 1
	}
d341 1
a341 1
	{
d343 1
a343 1
	}
d353 1
a353 1
	{
d356 1
a356 1
	}
d358 9
a366 27
int X509V3_EXT_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,
	     X509 *cert)
	{
	CONF ctmp;
	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_add_nconf(&ctmp, ctx, section, cert);
	}

/* Same as above but for a CRL */

int X509V3_EXT_CRL_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,
	     X509_CRL *crl)
	{
	CONF ctmp;
	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_CRL_add_nconf(&ctmp, ctx, section, crl);
	}

/* Add extensions to certificate request */

int X509V3_EXT_REQ_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,
	     X509_REQ *req)
	{
	CONF ctmp;
	CONF_set_nconf(&ctmp, conf);
	return X509V3_EXT_REQ_add_nconf(&ctmp, ctx, section, req);
	}
@


1.1.1.2
log
@import 0.9.7c
@
text
@d239 1
a239 1
	if ((strlen(p) < 4) || strncmp(p, "DER:", 4)) return 0;
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
d72 1
a72 1
static X509_EXTENSION *v3_generic_extension(const char *ext, char *value, int crit, int type, X509V3_CTX *ctx);
a76 1
static unsigned char *generic_asn1(char *value, X509V3_CTX *ctx, long *ext_len);
d88 1
a88 1
		return v3_generic_extension(name, value, crit, ext_type, ctx);
d92 1
a92 1
		X509V3err(X509V3_F_X509V3_EXT_NCONF,X509V3_R_ERROR_IN_EXTENSION);
d108 1
a108 1
						 value, crit, ext_type, ctx);
d123 1
a123 1
		X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_UNKNOWN_EXTENSION_NAME);
d128 1
a128 1
		X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_UNKNOWN_EXTENSION);
d136 1
a136 1
		if(sk_CONF_VALUE_num(nval) <= 0)
d138 1
a138 1
			X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_INVALID_EXTENSION_STRING);
d153 1
a153 1
		if(!ctx->db || !ctx->db_meth)
d155 1
a155 1
			X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_NO_CONFIG_DATABASE);
d162 1
a162 1
		X509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED);
a237 1
	int gen_type = 0;
d239 2
a240 13
	if ((strlen(p) >= 4) && !strncmp(p, "DER:", 4))
		{
		p+=4;
		gen_type = 1;
		}
	else if ((strlen(p) >= 5) && !strncmp(p, "ASN1:", 5))
		{
		p+=5;
		gen_type = 2;
		}
	else
		return 0;

d243 1
a243 1
	return gen_type;
d248 1
a248 1
	     int crit, int gen_type, X509V3_CTX *ctx)
d262 1
a262 6
	if (gen_type == 1)
		ext_der = string_to_hex(value, &ext_len);
	else if (gen_type == 2)
		ext_der = generic_asn1(value, ctx, &ext_len);

	if (ext_der == NULL)
a288 11
static unsigned char *generic_asn1(char *value, X509V3_CTX *ctx, long *ext_len)
	{
	ASN1_TYPE *typ;
	unsigned char *ext_der = NULL;
	typ = ASN1_generate_v3(value, ctx);
	if (typ == NULL)
		return NULL;
	*ext_len = i2d_ASN1_TYPE(typ, &ext_der);
	ASN1_TYPE_free(typ);
	return ext_der;
	}
a356 5
	if(!ctx->db || !ctx->db_meth || !ctx->db_meth->get_string)
		{
		X509V3err(X509V3_F_X509V3_GET_STRING,X509V3_R_OPERATION_NOT_DEFINED);
		return NULL;
		}
a363 5
	if(!ctx->db || !ctx->db_meth || !ctx->db_meth->get_section)
		{
		X509V3err(X509V3_F_X509V3_GET_SECTION,X509V3_R_OPERATION_NOT_DEFINED);
		return NULL;
		}
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d75 2
a76 2
static X509_EXTENSION *do_ext_i2d(const X509V3_EXT_METHOD *method, int ext_nid,
				  int crit, void *ext_struc);
d82 1
a82 1
				 char *value)
d102 1
a102 1
				     char *value)
d116 1
a116 1
				    int crit, char *value)
d118 1
a118 1
	const X509V3_EXT_METHOD *method;
d175 2
a176 2
static X509_EXTENSION *do_ext_i2d(const X509V3_EXT_METHOD *method, int ext_nid,
				  int crit, void *ext_struc)
d217 1
a217 1
	const X509V3_EXT_METHOD *method;
d261 1
a261 2
					    int crit, int gen_type,
					    X509V3_CTX *ctx)
d325 1
a325 1
			    STACK_OF(X509_EXTENSION) **sk)
d346 1
a346 1
			 X509 *cert)
d357 1
a357 1
			     X509_CRL *crl)
d446 1
a446 1
		    X509_CRL *crl, int flags)
d457 2
a458 2
X509_EXTENSION *X509V3_EXT_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
				char *name, char *value)
d467 2
a468 2
X509_EXTENSION *X509V3_EXT_conf_nid(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
				    int ext_nid, char *value)
d492 1
a492 1
void X509V3_set_conf_lhash(X509V3_CTX *ctx, LHASH_OF(CONF_VALUE) *lhash)
d498 2
a499 2
int X509V3_EXT_add_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
			char *section, X509 *cert)
d508 2
a509 2
int X509V3_EXT_CRL_add_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
			    char *section, X509_CRL *crl)
d518 2
a519 2
int X509V3_EXT_REQ_add_conf(LHASH_OF(CONF_VALUE) *conf, X509V3_CTX *ctx,
			    char *section, X509_REQ *req)
@


