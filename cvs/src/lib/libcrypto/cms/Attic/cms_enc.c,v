head	1.8;
access;
symbols;
locks; strict;
comment	@ * @;


1.8
date	2016.09.04.17.55.28;	author jsing;	state dead;
branches;
next	1.7;
commitid	6cKjjSNzZGsdvU20;

1.7
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.6;
commitid	vHznCDK3idwNEFz4;

1.6
date	2014.10.22.13.02.04;	author jsing;	state Exp;
branches;
next	1.5;
commitid	PjnBgKe6Buhbf937;

1.5
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.4;
commitid	yQEL1wOWIearrW15;

1.4
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	mJUVYpkFBZ0Zv2bG;

1.3
date	2014.05.24.15.55.21;	author jsing;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.42;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.42;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.10.13.21.23.38;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.04.13.15.16.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Remove cms.

ok beck@@, guenther@@, tedu@@
@
text
@/* $OpenBSD: cms_enc.c,v 1.7 2015/09/10 15:56:25 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */

#include <stdlib.h>

#include <openssl/asn1t.h>
#include <openssl/cms.h>
#include <openssl/err.h>
#include <openssl/pem.h>
#include <openssl/x509v3.h>

#include "cms_lcl.h"

/* CMS EncryptedData Utilities */

DECLARE_ASN1_ITEM(CMS_EncryptedData)

/* Return BIO based on EncryptedContentInfo and key */

BIO *
cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec)
{
	BIO *b;
	EVP_CIPHER_CTX *ctx;
	const EVP_CIPHER *ciph;
	X509_ALGOR *calg = ec->contentEncryptionAlgorithm;
	unsigned char iv[EVP_MAX_IV_LENGTH], *piv = NULL;
	unsigned char *tkey = NULL;
	size_t tkeylen = 0;
	int ok = 0;
	int enc, keep_key = 0;

	enc = ec->cipher ? 1 : 0;

	b = BIO_new(BIO_f_cipher());
	if (!b) {
		CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
		    ERR_R_MALLOC_FAILURE);
		return NULL;
	}

	BIO_get_cipher_ctx(b, &ctx);

	if (enc) {
		ciph = ec->cipher;
		/* If not keeping key set cipher to NULL so subsequent calls
		 * decrypt.
		 */
		if (ec->key)
			ec->cipher = NULL;
	} else {
		ciph = EVP_get_cipherbyobj(calg->algorithm);

		if (!ciph) {
			CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
			    CMS_R_UNKNOWN_CIPHER);
			goto err;
		}
	}

	if (EVP_CipherInit_ex(ctx, ciph, NULL, NULL, NULL, enc) <= 0) {
		CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
		    CMS_R_CIPHER_INITIALISATION_ERROR);
		goto err;
	}

	if (enc) {
		int ivlen;
		calg->algorithm = OBJ_nid2obj(EVP_CIPHER_CTX_type(ctx));
		/* Generate a random IV if we need one */
		ivlen = EVP_CIPHER_CTX_iv_length(ctx);
		if (ivlen > 0) {
			arc4random_buf(iv, ivlen);
			piv = iv;
		}
	} else if (EVP_CIPHER_asn1_to_param(ctx, calg->parameter) <= 0) {
		CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
		    CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
		goto err;
	}
	tkeylen = EVP_CIPHER_CTX_key_length(ctx);
	/* Generate random session key */
	if (!enc || !ec->key) {
		tkey = malloc(tkeylen);
		if (!tkey) {
			CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (EVP_CIPHER_CTX_rand_key(ctx, tkey) <= 0)
			goto err;
	}

	if (!ec->key) {
		ec->key = tkey;
		ec->keylen = tkeylen;
		tkey = NULL;
		if (enc)
			keep_key = 1;
		else
			ERR_clear_error();

	}

	if (ec->keylen != tkeylen) {
		/* If necessary set key length */
		if (EVP_CIPHER_CTX_set_key_length(ctx, ec->keylen) <= 0) {
			/* Only reveal failure if debugging so we don't
			 * leak information which may be useful in MMA.
			 */
			if (enc || ec->debug) {
				CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
				    CMS_R_INVALID_KEY_LENGTH);
				goto err;
			} else {
				/* Use random key */
				explicit_bzero(ec->key, ec->keylen);
				free(ec->key);
				ec->key = tkey;
				ec->keylen = tkeylen;
				tkey = NULL;
				ERR_clear_error();
			}
		}
	}

	if (EVP_CipherInit_ex(ctx, NULL, NULL, ec->key, piv, enc) <= 0) {
		CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
		    CMS_R_CIPHER_INITIALISATION_ERROR);
		goto err;
	}

	if (piv) {
		calg->parameter = ASN1_TYPE_new();
		if (!calg->parameter) {
			CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
			    ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (EVP_CIPHER_param_to_asn1(ctx, calg->parameter) <= 0) {
			CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
			    CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
			goto err;
		}
	}
	ok = 1;

err:
	if (ec->key && !keep_key) {
		explicit_bzero(ec->key, ec->keylen);
		free(ec->key);
		ec->key = NULL;
	}
	if (tkey) {
		explicit_bzero(tkey, tkeylen);
		free(tkey);
	}
	if (ok)
		return b;
	BIO_free(b);
	return NULL;
}

int
cms_EncryptedContent_init(CMS_EncryptedContentInfo *ec,
    const EVP_CIPHER *cipher, const unsigned char *key, size_t keylen)
{
	ec->cipher = cipher;
	if (key) {
		ec->key = malloc(keylen);
		if (!ec->key)
			return 0;
		memcpy(ec->key, key, keylen);
	}
	ec->keylen = keylen;
	if (cipher)
		ec->contentType = OBJ_nid2obj(NID_pkcs7_data);
	return 1;
}

int
CMS_EncryptedData_set1_key(CMS_ContentInfo *cms, const EVP_CIPHER *ciph,
    const unsigned char *key, size_t keylen)
{
	CMS_EncryptedContentInfo *ec;

	if (!key || !keylen) {
		CMSerr(CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY, CMS_R_NO_KEY);
		return 0;
	}
	if (ciph) {
		cms->d.encryptedData = M_ASN1_new_of(CMS_EncryptedData);
		if (!cms->d.encryptedData) {
			CMSerr(CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY,
			    ERR_R_MALLOC_FAILURE);
			return 0;
		}
		cms->contentType = OBJ_nid2obj(NID_pkcs7_encrypted);
		cms->d.encryptedData->version = 0;
	} else if (OBJ_obj2nid(cms->contentType) != NID_pkcs7_encrypted) {
		CMSerr(CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY,
		    CMS_R_NOT_ENCRYPTED_DATA);
		return 0;
	}
	ec = cms->d.encryptedData->encryptedContentInfo;
	return cms_EncryptedContent_init(ec, ciph, key, keylen);
}

BIO *
cms_EncryptedData_init_bio(CMS_ContentInfo *cms)
{
	CMS_EncryptedData *enc = cms->d.encryptedData;

	if (enc->encryptedContentInfo->cipher && enc->unprotectedAttrs)
		enc->version = 2;
	return cms_EncryptedContent_init_bio(enc->encryptedContentInfo);
}
@


1.7
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cms_enc.c,v 1.6 2014/10/22 13:02:04 jsing Exp $ */
@


1.6
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: cms_enc.c,v 1.5 2014/07/11 08:44:48 jsing Exp $ */
d167 1
a167 1
				OPENSSL_cleanse(ec->key, ec->keylen);
d200 1
a200 1
		OPENSSL_cleanse(ec->key, ec->keylen);
d205 1
a205 1
		OPENSSL_cleanse(tkey, tkeylen);
@


1.5
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cms_enc.c,v 1.4 2014/06/12 15:49:28 deraadt Exp $ */
d54 2
a59 1
#include <openssl/rand.h>
d123 1
a123 2
			if (RAND_pseudo_bytes(iv, ivlen) <= 0)
				goto err;
@


1.4
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a53 1
#include "cryptlib.h"
d55 2
d58 1
d60 1
a60 3
#include <openssl/err.h>
#include <openssl/cms.h>
#include <openssl/rand.h>
@


1.3
log
@KNF.
@
text
@d1 1
a1 1
/* crypto/cms/cms_enc.c */
@


1.2
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d69 3
a71 2
BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec)
	{
a78 1

a79 1

d85 1
a85 2
	if (!b)
		{
d87 1
a87 1
							ERR_R_MALLOC_FAILURE);
d89 1
a89 1
		}
d93 1
a93 2
	if (enc)
		{
d100 1
a100 3
		}
	else
		{
d103 1
a103 2
		if (!ciph)
			{
d105 1
a105 1
							CMS_R_UNKNOWN_CIPHER);
a106 1
			}
d108 1
d110 1
a110 2
	if (EVP_CipherInit_ex(ctx, ciph, NULL, NULL, NULL, enc) <= 0)
		{
d112 1
a112 1
				CMS_R_CIPHER_INITIALISATION_ERROR);
d114 1
a114 1
		}
d116 1
a116 2
	if (enc)
		{
d121 1
a121 2
		if (ivlen > 0)
			{
a124 1
			}
d126 1
a126 2
	else if (EVP_CIPHER_asn1_to_param(ctx, calg->parameter) <= 0)
		{
d128 1
a128 1
				CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
d130 1
a130 1
		}
d133 1
a133 2
	if (!enc || !ec->key)
		{
d135 1
a135 2
		if (!tkey)
			{
d137 1
a137 1
							ERR_R_MALLOC_FAILURE);
d139 1
a139 1
			}
d142 1
a142 1
		}
d144 1
a144 2
	if (!ec->key)
		{
a151 2
		
		}
d153 3
a155 2
	if (ec->keylen != tkeylen)
		{
d157 1
a157 2
		if (EVP_CIPHER_CTX_set_key_length(ctx, ec->keylen) <= 0)
			{
d161 1
a161 2
			if (enc || ec->debug)
				{
d163 1
a163 1
						CMS_R_INVALID_KEY_LENGTH);
d165 1
a165 3
				}
			else
				{
a172 1
				}
d175 1
d177 1
a177 2
	if (EVP_CipherInit_ex(ctx, NULL, NULL, ec->key, piv, enc) <= 0)
		{
d179 1
a179 1
				CMS_R_CIPHER_INITIALISATION_ERROR);
d181 1
a181 1
		}
d183 1
a183 2
	if (piv)
		{
d185 1
a185 2
		if (!calg->parameter)
			{
d187 1
a187 1
							ERR_R_MALLOC_FAILURE);
d189 2
a190 3
			}
		if (EVP_CIPHER_param_to_asn1(ctx, calg->parameter) <= 0)
			{
d192 1
a192 1
				CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
a193 1
			}
d195 1
d198 2
a199 3
	err:
	if (ec->key && !keep_key)
		{
d203 2
a204 3
		}
	if (tkey)
		{
d207 1
a207 1
		}
d212 1
a212 1
	}
d214 4
a217 4
int cms_EncryptedContent_init(CMS_EncryptedContentInfo *ec, 
				const EVP_CIPHER *cipher,
				const unsigned char *key, size_t keylen)
	{
d219 1
a219 2
	if (key)
		{
d224 1
a224 1
		}
d229 1
a229 1
	}
d231 4
a234 3
int CMS_EncryptedData_set1_key(CMS_ContentInfo *cms, const EVP_CIPHER *ciph,
				const unsigned char *key, size_t keylen)
	{
d236 2
a237 2
	if (!key || !keylen)
		{
d240 2
a241 3
		}
	if (ciph)
		{
d243 1
a243 2
		if (!cms->d.encryptedData)
			{
d245 1
a245 1
				ERR_R_MALLOC_FAILURE);
d247 1
a247 1
			}
d250 1
a250 3
		}
	else if (OBJ_obj2nid(cms->contentType) != NID_pkcs7_encrypted)
		{
d252 1
a252 1
						CMS_R_NOT_ENCRYPTED_DATA);
d254 1
a254 1
		}
d257 1
a257 1
	}
d259 3
a261 2
BIO *cms_EncryptedData_init_bio(CMS_ContentInfo *cms)
	{
d263 1
d267 1
a267 1
	}
@


1.1
log
@Initial revision
@
text
@d76 2
d142 3
a144 3


	if (enc && !ec->key)
d146 2
a147 5
		/* Generate random key */
		if (!ec->keylen)
			ec->keylen = EVP_CIPHER_CTX_key_length(ctx);
		ec->key = OPENSSL_malloc(ec->keylen);
		if (!ec->key)
d153 1
a153 1
		if (EVP_CIPHER_CTX_rand_key(ctx, ec->key) <= 0)
a154 1
		keep_key = 1;
d156 14
a169 1
	else if (ec->keylen != (unsigned int)EVP_CIPHER_CTX_key_length(ctx))
d174 19
a192 3
			CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
				CMS_R_INVALID_KEY_LENGTH);
			goto err;
d225 1
a225 1
		OPENSSL_free(ec->key);
d228 5
d246 1
a246 1
		ec->key = OPENSSL_malloc(keylen);
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.1c
@
text
@a75 2
	unsigned char *tkey = NULL;
	size_t tkeylen;
d140 3
a142 3
	tkeylen = EVP_CIPHER_CTX_key_length(ctx);
	/* Generate random session key */
	if (!enc || !ec->key)
d144 5
a148 2
		tkey = OPENSSL_malloc(tkeylen);
		if (!tkey)
d154 1
a154 1
		if (EVP_CIPHER_CTX_rand_key(ctx, tkey) <= 0)
d156 1
d158 1
a158 14

	if (!ec->key)
		{
		ec->key = tkey;
		ec->keylen = tkeylen;
		tkey = NULL;
		if (enc)
			keep_key = 1;
		else
			ERR_clear_error();
		
		}

	if (ec->keylen != tkeylen)
d163 3
a165 19
			/* Only reveal failure if debugging so we don't
			 * leak information which may be useful in MMA.
			 */
			if (enc || ec->debug)
				{
				CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
						CMS_R_INVALID_KEY_LENGTH);
				goto err;
				}
			else
				{
				/* Use random key */
				OPENSSL_cleanse(ec->key, ec->keylen);
				OPENSSL_free(ec->key);
				ec->key = tkey;
				ec->keylen = tkeylen;
				tkey = NULL;
				ERR_clear_error();
				}
a199 5
		}
	if (tkey)
		{
		OPENSSL_cleanse(tkey, tkeylen);
		OPENSSL_free(tkey);
@


1.1.1.3
log
@Import OpenSSL 1.0.1g
@
text
@d77 1
a77 1
	size_t tkeylen = 0;
@


