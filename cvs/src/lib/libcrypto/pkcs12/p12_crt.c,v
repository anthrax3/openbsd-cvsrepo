head	1.17;
access;
symbols
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17;
locks; strict;
comment	@ * @;


1.17
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.16;
commitid	kT0fLt3r4lroFJra;

1.16
date	2015.02.14.12.43.07;	author miod;	state Exp;
branches;
next	1.15;
commitid	UdJZJZYRCFvHGcy3;

1.15
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.14;
commitid	yQEL1wOWIearrW15;

1.14
date	2014.07.08.09.24.53;	author jsing;	state Exp;
branches;
next	1.13;
commitid	XxMwLiDq7L4rxrmk;

1.13
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	mJUVYpkFBZ0Zv2bG;

1.12
date	2014.04.15.20.06.10;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.15;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.57.58;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.15.06.18.41;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.05.53.36;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.44;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.27.05.05.34;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.13.58;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.04.06.06.30.04;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: p12_crt.c,v 1.16 2015/02/14 12:43:07 miod Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>

#include <openssl/err.h>
#include <openssl/pkcs12.h>

static int pkcs12_add_bag(STACK_OF(PKCS12_SAFEBAG) **pbags,
    PKCS12_SAFEBAG *bag);

static int
copy_bag_attr(PKCS12_SAFEBAG *bag, EVP_PKEY *pkey, int nid)
{
	int idx;
	X509_ATTRIBUTE *attr;

	idx = EVP_PKEY_get_attr_by_NID(pkey, nid, -1);
	if (idx < 0)
		return 1;
	attr = EVP_PKEY_get_attr(pkey, idx);
	if (!X509at_add1_attr(&bag->attrib, attr))
		return 0;
	return 1;
}

PKCS12 *
PKCS12_create(char *pass, char *name, EVP_PKEY *pkey, X509 *cert,
    STACK_OF(X509) *ca, int nid_key, int nid_cert, int iter, int mac_iter,
    int keytype)
{
	PKCS12 *p12 = NULL;
	STACK_OF(PKCS7) *safes = NULL;
	STACK_OF(PKCS12_SAFEBAG) *bags = NULL;
	PKCS12_SAFEBAG *bag = NULL;
	int i;
	unsigned char keyid[EVP_MAX_MD_SIZE];
	unsigned int keyidlen = 0;

	/* Set defaults */
	if (!nid_cert) {
		nid_cert = NID_pbe_WithSHA1And40BitRC2_CBC;
	}
	if (!nid_key)
		nid_key = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
	if (!iter)
		iter = PKCS12_DEFAULT_ITER;
	if (!mac_iter)
		mac_iter = 1;

	if (!pkey && !cert && !ca) {
		PKCS12error(PKCS12_R_INVALID_NULL_ARGUMENT);
		return NULL;
	}

	if (pkey && cert) {
		if (!X509_check_private_key(cert, pkey))
			return NULL;
		X509_digest(cert, EVP_sha1(), keyid, &keyidlen);
	}

	if (cert) {
		bag = PKCS12_add_cert(&bags, cert);
		if (name && !PKCS12_add_friendlyname(bag, name, -1))
			goto err;
		if (keyidlen && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
			goto err;
	}

	/* Add all other certificates */
	for (i = 0; i < sk_X509_num(ca); i++) {
		if (!PKCS12_add_cert(&bags, sk_X509_value(ca, i)))
			goto err;
	}

	if (bags && !PKCS12_add_safe(&safes, bags, nid_cert, iter, pass))
		goto err;

	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	bags = NULL;

	if (pkey) {
		bag = PKCS12_add_key(&bags, pkey, keytype, iter, nid_key, pass);

		if (!bag)
			goto err;

		if (!copy_bag_attr(bag, pkey, NID_ms_csp_name))
			goto err;
		if (!copy_bag_attr(bag, pkey, NID_LocalKeySet))
			goto err;

		if (name && !PKCS12_add_friendlyname(bag, name, -1))
			goto err;
		if (keyidlen && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
			goto err;
	}

	if (bags && !PKCS12_add_safe(&safes, bags, -1, 0, NULL))
		goto err;

	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	bags = NULL;

	p12 = PKCS12_add_safes(safes, 0);

	if (!p12)
		goto err;

	sk_PKCS7_pop_free(safes, PKCS7_free);

	safes = NULL;

	if ((mac_iter != -1) &&
	    !PKCS12_set_mac(p12, pass, -1, NULL, 0, mac_iter, NULL))
		goto err;

	return p12;

err:
	if (p12)
		PKCS12_free(p12);
	if (safes)
		sk_PKCS7_pop_free(safes, PKCS7_free);
	if (bags)
		sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	return NULL;
}

PKCS12_SAFEBAG *
PKCS12_add_cert(STACK_OF(PKCS12_SAFEBAG) **pbags, X509 *cert)
{
	PKCS12_SAFEBAG *bag = NULL;
	char *name;
	int namelen = -1;
	unsigned char *keyid;
	int keyidlen = -1;

	/* Add user certificate */
	if (!(bag = PKCS12_x5092certbag(cert)))
		goto err;

	/* Use friendlyName and localKeyID in certificate.
	 * (if present)
	 */
	name = (char *)X509_alias_get0(cert, &namelen);
	if (name && !PKCS12_add_friendlyname(bag, name, namelen))
		goto err;

	keyid = X509_keyid_get0(cert, &keyidlen);

	if (keyid && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
		goto err;

	if (!pkcs12_add_bag(pbags, bag))
		goto err;

	return bag;

err:
	if (bag)
		PKCS12_SAFEBAG_free(bag);

	return NULL;
}

PKCS12_SAFEBAG *
PKCS12_add_key(STACK_OF(PKCS12_SAFEBAG) **pbags, EVP_PKEY *key, int key_usage,
    int iter, int nid_key, char *pass)
{
	PKCS12_SAFEBAG *bag = NULL;
	PKCS8_PRIV_KEY_INFO *p8 = NULL;

	/* Make a PKCS#8 structure */
	if (!(p8 = EVP_PKEY2PKCS8(key)))
		goto err;
	if (key_usage && !PKCS8_add_keyusage(p8, key_usage))
		goto err;
	if (nid_key != -1) {
		bag = PKCS12_MAKE_SHKEYBAG(nid_key, pass, -1, NULL, 0,
		    iter, p8);
		PKCS8_PRIV_KEY_INFO_free(p8);
		p8 = NULL;
	} else {
		bag = PKCS12_MAKE_KEYBAG(p8);
		if (bag != NULL)
			p8 = NULL;
	}

	if (!bag)
		goto err;

	if (!pkcs12_add_bag(pbags, bag))
		goto err;

	return bag;

err:
	if (bag)
		PKCS12_SAFEBAG_free(bag);
	if (p8)
		PKCS8_PRIV_KEY_INFO_free(p8);

	return NULL;
}

int
PKCS12_add_safe(STACK_OF(PKCS7) **psafes, STACK_OF(PKCS12_SAFEBAG) *bags,
    int nid_safe, int iter, char *pass)
{
	PKCS7 *p7 = NULL;
	int free_safes = 0;

	if (!*psafes) {
		*psafes = sk_PKCS7_new_null();
		if (!*psafes)
			return 0;
		free_safes = 1;
	} else
		free_safes = 0;

	if (nid_safe == 0)
		nid_safe = NID_pbe_WithSHA1And40BitRC2_CBC;

	if (nid_safe == -1)
		p7 = PKCS12_pack_p7data(bags);
	else
		p7 = PKCS12_pack_p7encdata(nid_safe, pass, -1, NULL, 0,
		    iter, bags);
	if (!p7)
		goto err;

	if (!sk_PKCS7_push(*psafes, p7))
		goto err;

	return 1;

err:
	if (free_safes) {
		sk_PKCS7_free(*psafes);
		*psafes = NULL;
	}

	if (p7)
		PKCS7_free(p7);

	return 0;
}

static int
pkcs12_add_bag(STACK_OF(PKCS12_SAFEBAG) **pbags, PKCS12_SAFEBAG *bag)
{
	int free_bags;

	if (!pbags)
		return 1;
	if (!*pbags) {
		*pbags = sk_PKCS12_SAFEBAG_new_null();
		if (!*pbags)
			return 0;
		free_bags = 1;
	} else
		free_bags = 0;

	if (!sk_PKCS12_SAFEBAG_push(*pbags, bag)) {
		if (free_bags) {
			sk_PKCS12_SAFEBAG_free(*pbags);
			*pbags = NULL;
		}
		return 0;
	}

	return 1;
}

PKCS12 *
PKCS12_add_safes(STACK_OF(PKCS7) *safes, int nid_p7)
{
	PKCS12 *p12;

	if (nid_p7 <= 0)
		nid_p7 = NID_pkcs7_data;
	p12 = PKCS12_init(nid_p7);

	if (!p12)
		return NULL;

	if (!PKCS12_pack_authsafes(p12, safes)) {
		PKCS12_free(p12);
		return NULL;
	}

	return p12;
}
@


1.16
log
@Try and fix a bunch of memory leaks upon error;
ok tedu@@ about 7 months ago and I was sitting upon this diff for no reason
@
text
@d1 1
a1 1
/* $OpenBSD: p12_crt.c,v 1.15 2014/07/11 08:44:49 jsing Exp $ */
d107 1
a107 2
		PKCS12err(PKCS12_F_PKCS12_CREATE,
		    PKCS12_R_INVALID_NULL_ARGUMENT);
@


1.15
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: p12_crt.c,v 1.14 2014/07/08 09:24:53 jsing Exp $ */
d239 2
a240 1
	} else
d242 3
d257 2
@


1.14
log
@KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: p12_crt.c,v 1.13 2014/06/12 15:49:30 deraadt Exp $ */
d60 2
a61 1
#include "cryptlib.h"
a62 1

@


1.13
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d64 2
a65 1
static int pkcs12_add_bag(STACK_OF(PKCS12_SAFEBAG) **pbags, PKCS12_SAFEBAG *bag);
d67 3
a69 2
static int copy_bag_attr(PKCS12_SAFEBAG *bag, EVP_PKEY *pkey, int nid)
	{
d72 1
d80 1
a80 1
	}
d82 4
a85 3
PKCS12 *PKCS12_create(char *pass, char *name, EVP_PKEY *pkey, X509 *cert,
	     STACK_OF(X509) *ca, int nid_key, int nid_cert, int iter, int mac_iter,
	     int keytype)
d96 1
a96 2
	if (!nid_cert)
		{
d98 1
a98 1
		}
d106 3
a108 3
	if(!pkey && !cert && !ca)
		{
		PKCS12err(PKCS12_F_PKCS12_CREATE,PKCS12_R_INVALID_NULL_ARGUMENT);
d110 1
a110 1
		}
d112 2
a113 3
	if (pkey && cert)
		{
		if(!X509_check_private_key(cert, pkey))
d116 1
a116 1
		}
d118 1
a118 2
	if (cert)
		{
d120 1
a120 1
		if(name && !PKCS12_add_friendlyname(bag, name, -1))
d122 1
a122 1
		if(keyidlen && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
d124 1
a124 1
		}
d127 1
a127 2
	for(i = 0; i < sk_X509_num(ca); i++)
		{
d130 1
a130 1
		}
d133 1
a133 1
			goto err;
d138 1
a138 2
	if (pkey)
		{
d149 1
a149 1
		if(name && !PKCS12_add_friendlyname(bag, name, -1))
d151 1
a151 1
		if(keyidlen && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
d153 1
a153 1
		}
d156 1
a156 1
			goto err;
d171 2
a172 2
		!PKCS12_set_mac(p12, pass, -1, NULL, 0, mac_iter, NULL))
	    goto err;
d176 1
a176 2
	err:

a183 1

d186 3
a188 2
PKCS12_SAFEBAG *PKCS12_add_cert(STACK_OF(PKCS12_SAFEBAG) **pbags, X509 *cert)
	{
d196 1
a196 1
	if(!(bag = PKCS12_x5092certbag(cert)))
a201 1

d203 1
a203 2

	if(name && !PKCS12_add_friendlyname(bag, name, namelen))
d208 1
a208 1
	if(keyid && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
d216 1
a216 2
	err:

d221 1
d223 4
a226 7
	}

PKCS12_SAFEBAG *PKCS12_add_key(STACK_OF(PKCS12_SAFEBAG) **pbags, EVP_PKEY *key,
						int key_usage, int iter,
						int nid_key, char *pass)
	{

d231 1
a231 1
	if(!(p8 = EVP_PKEY2PKCS8(key)))
d233 1
a233 1
	if(key_usage && !PKCS8_add_keyusage(p8, key_usage))
d235 3
a237 3
	if (nid_key != -1)
		{
		bag = PKCS12_MAKE_SHKEYBAG(nid_key, pass, -1, NULL, 0, iter, p8);
d239 1
a239 2
		}
	else
d242 1
a242 1
	if(!bag)
d250 1
a250 2
	err:

d255 1
d257 4
a260 5
	}

int PKCS12_add_safe(STACK_OF(PKCS7) **psafes, STACK_OF(PKCS12_SAFEBAG) *bags,
						int nid_safe, int iter, char *pass)
	{
d264 1
a264 2
	if (!*psafes)
		{
d269 1
a269 2
		}
	else
d279 1
a279 1
					  iter, bags);
d288 2
a289 3
	err:
	if (free_safes)
		{
d292 1
a292 1
		}
d298 1
d300 4
a303 1
	}
a304 3
static int pkcs12_add_bag(STACK_OF(PKCS12_SAFEBAG) **pbags, PKCS12_SAFEBAG *bag)
	{
	int free_bags;
d307 1
a307 2
	if (!*pbags)
		{
d312 1
a312 2
		}
	else 
d315 2
a316 4
	if (!sk_PKCS12_SAFEBAG_push(*pbags, bag))
		{
		if (free_bags)
			{
d319 1
a319 1
			}
d321 1
a321 1
		}
d324 1
d326 4
a329 2
	}
		
a330 3
PKCS12 *PKCS12_add_safes(STACK_OF(PKCS7) *safes, int nid_p7)
	{
	PKCS12 *p12;
d338 1
a338 2
	if(!PKCS12_pack_authsafes(p12, safes))
		{
d341 1
a341 1
		}
d344 1
a344 2

	}
@


1.12
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok beck deraadt
@
text
@d1 1
a1 1
/* p12_crt.c */
@


1.11
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a93 5
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			nid_cert = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
		else
#endif
@


1.10
log
@resolve conflicts, fix local changes
@
text
@d93 6
d100 1
@


1.9
log
@resolve conflicts
@
text
@a61 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a92 6
		{
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			nid_cert = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
		else
#endif
a93 1
		}
@


1.8
log
@resolve conflicts
@
text
@d173 3
@


1.7
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
d62 4
d97 6
d104 1
@


1.6
log
@resolve conflicts
@
text
@d66 13
a137 1
		int cspidx;
d143 4
a146 8
		cspidx = EVP_PKEY_get_attr_by_NID(pkey, NID_ms_csp_name, -1);
		if (cspidx >= 0)
			{
			X509_ATTRIBUTE *cspattr;
			cspattr = EVP_PKEY_get_attr(pkey, cspidx);
			if (!X509at_add1_attr(&bag->attrib, cspattr))
				goto err;
			}
@


1.5
log
@resolve conflicts
@
text
@d3 1
a3 1
 * project 1999.
d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d63 3
d70 4
a73 7
	PKCS12 *p12;
	STACK_OF(PKCS12_SAFEBAG) *bags;
	STACK_OF(PKCS7) *safes;
	PKCS12_SAFEBAG *bag;
	PKCS8_PRIV_KEY_INFO *p8;
	PKCS7 *authsafe;
	X509 *tcert;
d76 1
a76 1
	unsigned int keyidlen;
d79 10
a88 1
	if(!nid_cert)
a89 12
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			nid_cert = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
		else
#endif
			nid_cert = NID_pbe_WithSHA1And40BitRC2_CBC;
		}
	if(!nid_key) nid_key = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
	if(!iter) iter = PKCS12_DEFAULT_ITER;
	if(!mac_iter) mac_iter = 1;

	if(!pkey || !cert) {
d92 81
a172 1
	}
d174 1
a174 1
	if(!X509_check_private_key(cert, pkey)) return NULL;
d176 7
a182 4
	if(!(bags = sk_PKCS12_SAFEBAG_new_null ())) {
		PKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);
		return NULL;
	}
d185 28
a212 4
	if(!(bag = PKCS12_x5092certbag(cert))) return NULL;
	if(name && !PKCS12_add_friendlyname(bag, name, -1)) return NULL;
	X509_digest(cert, EVP_sha1(), keyid, &keyidlen);
	if(!PKCS12_add_localkeyid(bag, keyid, keyidlen)) return NULL;
a213 3
	if(!sk_PKCS12_SAFEBAG_push(bags, bag)) {
		PKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);
		return NULL;
d215 18
a232 10
	
	/* Add all other certificates */
	if(ca) {
		for(i = 0; i < sk_X509_num(ca); i++) {
			tcert = sk_X509_value(ca, i);
			if(!(bag = PKCS12_x5092certbag(tcert))) return NULL;
			if(!sk_PKCS12_SAFEBAG_push(bags, bag)) {
				PKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);
				return NULL;
			}
d234 18
d254 23
a276 2
	/* Turn certbags into encrypted authsafe */
	authsafe = PKCS12_pack_p7encdata (nid_cert, pass, -1, NULL, 0,
d278 17
a294 1
	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
d296 1
a296 1
	if (!authsafe) return NULL;
a297 4
	if(!(safes = sk_PKCS7_new_null ())
	   || !sk_PKCS7_push(safes, authsafe)) {
		PKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);
		return NULL;
d300 27
a326 19
	/* Make a shrouded key bag */
	if(!(p8 = EVP_PKEY2PKCS8 (pkey))) return NULL;
	if(keytype && !PKCS8_add_keyusage(p8, keytype)) return NULL;
	bag = PKCS12_MAKE_SHKEYBAG (nid_key, pass, -1, NULL, 0, iter, p8);
	if(!bag) return NULL;
	PKCS8_PRIV_KEY_INFO_free(p8);
        if (name && !PKCS12_add_friendlyname (bag, name, -1)) return NULL;
	if(!PKCS12_add_localkeyid (bag, keyid, keyidlen)) return NULL;
	if(!(bags = sk_PKCS12_SAFEBAG_new_null())
	   || !sk_PKCS12_SAFEBAG_push (bags, bag)) {
		PKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	/* Turn it into unencrypted safe bag */
	if(!(authsafe = PKCS12_pack_p7data (bags))) return NULL;
	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	if(!sk_PKCS7_push(safes, authsafe)) {
		PKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);
		return NULL;
d328 1
d330 6
a335 1
	if(!(p12 = PKCS12_init (NID_pkcs7_data))) return NULL;
d337 2
a338 1
	if(!PKCS12_pack_authsafes (p12, safes)) return NULL;
d340 5
a344 4
	sk_PKCS7_pop_free(safes, PKCS7_free);

	if(!PKCS12_set_mac (p12, pass, -1, NULL, 0, mac_iter, NULL))
	    return NULL;
d348 1
a348 1
}
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d79 9
a87 1
	if(!nid_cert) nid_cert = NID_pbe_WithSHA1And40BitRC2_CBC;
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d97 1
a97 1
	if(!(bag = M_PKCS12_x5092certbag(cert))) return NULL;
d111 1
a111 1
			if(!(bag = M_PKCS12_x5092certbag(tcert))) return NULL;
d155 1
a155 1
	if(!M_PKCS12_pack_authsafes (p12, safes)) return NULL;
@


1.2
log
@OpenSSL 0.9.5a merge
@
text
@d68 2
a69 1
	STACK *bags, *safes;
d89 3
a91 1
	if(!(bags = sk_new (NULL))) {
d102 1
a102 1
	if(!sk_push(bags, (char *)bag)) {
d112 1
a112 1
			if(!sk_push(bags, (char *)bag)) {
d122 1
a122 1
	sk_pop_free(bags, PKCS12_SAFEBAG_free);
d126 2
a127 1
	if(!(safes = sk_new (NULL)) || !sk_push(safes, (char *)authsafe)) {
d140 2
a141 1
	if(!(bags = sk_new(NULL)) || !sk_push (bags, (char *)bag)) {
d147 2
a148 2
	sk_pop_free(bags, PKCS12_SAFEBAG_free);
	if(!sk_push(safes, (char *)authsafe)) {
d157 1
a157 1
	sk_pop_free(safes, PKCS7_free);
@


1.1
log
@new files for OpenSSL 0.9.4
@
text
@d64 1
a64 1
	     STACK *ca, int nid_key, int nid_cert, int iter, int mac_iter,
d106 2
a107 2
		for(i = 0; i < sk_num(ca); i++) {
			tcert = (X509 *)sk_value(ca, i);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d64 1
a64 1
	     STACK_OF(X509) *ca, int nid_key, int nid_cert, int iter, int mac_iter,
d68 1
a68 2
	STACK_OF(PKCS12_SAFEBAG) *bags;
	STACK_OF(PKCS7) *safes;
d88 1
a88 3
	if(!X509_check_private_key(cert, pkey)) return NULL;

	if(!(bags = sk_PKCS12_SAFEBAG_new_null ())) {
d94 1
a94 1
	if(!(bag = PKCS12_x5092certbag(cert))) return NULL;
d99 1
a99 1
	if(!sk_PKCS12_SAFEBAG_push(bags, bag)) {
d106 4
a109 4
		for(i = 0; i < sk_X509_num(ca); i++) {
			tcert = sk_X509_value(ca, i);
			if(!(bag = PKCS12_x5092certbag(tcert))) return NULL;
			if(!sk_PKCS12_SAFEBAG_push(bags, bag)) {
d119 1
a119 1
	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
d123 1
a123 2
	if(!(safes = sk_PKCS7_new_null ())
	   || !sk_PKCS7_push(safes, authsafe)) {
d136 1
a136 2
	if(!(bags = sk_PKCS12_SAFEBAG_new_null())
	   || !sk_PKCS12_SAFEBAG_push (bags, bag)) {
d142 2
a143 2
	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	if(!sk_PKCS7_push(safes, authsafe)) {
d150 1
a150 1
	if(!PKCS12_pack_authsafes (p12, safes)) return NULL;
d152 1
a152 1
	sk_PKCS7_pop_free(safes, PKCS7_free);
@


1.1.1.2
log
@import of openssl-0.9.7j
@
text
@d79 1
a79 9
	if(!nid_cert)
		{
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			nid_cert = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
		else
#endif
			nid_cert = NID_pbe_WithSHA1And40BitRC2_CBC;
		}
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d3 1
a3 1
 * project.
d6 1
a6 1
 * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
a62 3

static int pkcs12_add_bag(STACK_OF(PKCS12_SAFEBAG) **pbags, PKCS12_SAFEBAG *bag);

d67 7
a73 4
	PKCS12 *p12 = NULL;
	STACK_OF(PKCS7) *safes = NULL;
	STACK_OF(PKCS12_SAFEBAG) *bags = NULL;
	PKCS12_SAFEBAG *bag = NULL;
d76 1
a76 1
	unsigned int keyidlen = 0;
d79 12
a90 8
	if (!nid_cert)
		nid_cert = NID_pbe_WithSHA1And40BitRC2_CBC;
	if (!nid_key)
		nid_key = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
	if (!iter)
		iter = PKCS12_DEFAULT_ITER;
	if (!mac_iter)
		mac_iter = 1;
d92 1
a92 2
	if(!pkey && !cert && !ca)
		{
d95 3
a97 1
		}
d99 4
a102 6
	if (pkey && cert)
		{
		if(!X509_check_private_key(cert, pkey))
			return NULL;
		X509_digest(cert, EVP_sha1(), keyid, &keyidlen);
		}
d104 5
a108 8
	if (cert)
		{
		bag = PKCS12_add_cert(&bags, cert);
		if(name && !PKCS12_add_friendlyname(bag, name, -1))
			goto err;
		if(keyidlen && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
			goto err;
		}
d110 5
d116 7
a122 27
	for(i = 0; i < sk_X509_num(ca); i++)
		{
		if (!PKCS12_add_cert(&bags, sk_X509_value(ca, i)))
			goto err;
		}

	if (bags && !PKCS12_add_safe(&safes, bags, nid_cert, iter, pass))
			goto err;

	sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	bags = NULL;

	if (pkey)
		{
		int cspidx;
		bag = PKCS12_add_key(&bags, pkey, keytype, iter, nid_key, pass);

		if (!bag)
			goto err;

		cspidx = EVP_PKEY_get_attr_by_NID(pkey, NID_ms_csp_name, -1);
		if (cspidx >= 0)
			{
			X509_ATTRIBUTE *cspattr;
			cspattr = EVP_PKEY_get_attr(pkey, cspidx);
			if (!X509at_add1_attr(&bag->attrib, cspattr))
				goto err;
a123 5

		if(name && !PKCS12_add_friendlyname(bag, name, -1))
			goto err;
		if(keyidlen && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
			goto err;
d125 1
d127 3
a129 3
	if (bags && !PKCS12_add_safe(&safes, bags, -1, 0, NULL))
			goto err;

a130 1
	bags = NULL;
d132 1
a132 61
	p12 = PKCS12_add_safes(safes, 0);

	sk_PKCS7_pop_free(safes, PKCS7_free);

	safes = NULL;

	if ((mac_iter != -1) &&
		!PKCS12_set_mac(p12, pass, -1, NULL, 0, mac_iter, NULL))
	    goto err;

	return p12;

	err:

	if (p12)
		PKCS12_free(p12);
	if (safes)
		sk_PKCS7_pop_free(safes, PKCS7_free);
	if (bags)
		sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
	return NULL;

}

PKCS12_SAFEBAG *PKCS12_add_cert(STACK_OF(PKCS12_SAFEBAG) **pbags, X509 *cert)
	{
	PKCS12_SAFEBAG *bag = NULL;
	char *name;
	int namelen = -1;
	unsigned char *keyid;
	int keyidlen = -1;

	/* Add user certificate */
	if(!(bag = PKCS12_x5092certbag(cert)))
		goto err;

	/* Use friendlyName and localKeyID in certificate.
	 * (if present)
	 */

	name = (char *)X509_alias_get0(cert, &namelen);

	if(name && !PKCS12_add_friendlyname(bag, name, namelen))
		goto err;

	keyid = X509_keyid_get0(cert, &keyidlen);

	if(keyid && !PKCS12_add_localkeyid(bag, keyid, keyidlen))
		goto err;

	if (!pkcs12_add_bag(pbags, bag))
		goto err;

	return bag;

	err:

	if (bag)
		PKCS12_SAFEBAG_free(bag);

	return NULL;
d134 4
d140 12
a151 36
PKCS12_SAFEBAG *PKCS12_add_key(STACK_OF(PKCS12_SAFEBAG) **pbags, EVP_PKEY *key,
						int key_usage, int iter,
						int nid_key, char *pass)
	{

	PKCS12_SAFEBAG *bag = NULL;
	PKCS8_PRIV_KEY_INFO *p8 = NULL;

	/* Make a PKCS#8 structure */
	if(!(p8 = EVP_PKEY2PKCS8(key)))
		goto err;
	if(key_usage && !PKCS8_add_keyusage(p8, key_usage))
		goto err;
	if (nid_key != -1)
		{
		bag = PKCS12_MAKE_SHKEYBAG(nid_key, pass, -1, NULL, 0, iter, p8);
		PKCS8_PRIV_KEY_INFO_free(p8);
		}
	else
		bag = PKCS12_MAKE_KEYBAG(p8);

	if(!bag)
		goto err;

	if (!pkcs12_add_bag(pbags, bag))
		goto err;

	return bag;

	err:

	if (bag)
		PKCS12_SAFEBAG_free(bag);

	return NULL;

d153 6
a158 45

int PKCS12_add_safe(STACK_OF(PKCS7) **psafes, STACK_OF(PKCS12_SAFEBAG) *bags,
						int nid_safe, int iter, char *pass)
	{
	PKCS7 *p7 = NULL;
	int free_safes = 0;

	if (!*psafes)
		{
		*psafes = sk_PKCS7_new_null();
		if (!*psafes)
			return 0;
		free_safes = 1;
		}
	else
		free_safes = 0;

	if (nid_safe == 0)
		nid_safe = NID_pbe_WithSHA1And40BitRC2_CBC;

	if (nid_safe == -1)
		p7 = PKCS12_pack_p7data(bags);
	else
		p7 = PKCS12_pack_p7encdata(nid_safe, pass, -1, NULL, 0,
					  iter, bags);
	if (!p7)
		goto err;

	if (!sk_PKCS7_push(*psafes, p7))
		goto err;

	return 1;

	err:
	if (free_safes)
		{
		sk_PKCS7_free(*psafes);
		*psafes = NULL;
		}

	if (p7)
		PKCS7_free(p7);

	return 0;

d161 1
a161 29
static int pkcs12_add_bag(STACK_OF(PKCS12_SAFEBAG) **pbags, PKCS12_SAFEBAG *bag)
	{
	int free_bags;
	if (!pbags)
		return 1;
	if (!*pbags)
		{
		*pbags = sk_PKCS12_SAFEBAG_new_null();
		if (!*pbags)
			return 0;
		free_bags = 1;
		}
	else 
		free_bags = 0;

	if (!sk_PKCS12_SAFEBAG_push(*pbags, bag))
		{
		if (free_bags)
			{
			sk_PKCS12_SAFEBAG_free(*pbags);
			*pbags = NULL;
			}
		return 0;
		}

	return 1;

	}
		
d163 1
a163 6
PKCS12 *PKCS12_add_safes(STACK_OF(PKCS7) *safes, int nid_p7)
	{
	PKCS12 *p12;
	if (nid_p7 <= 0)
		nid_p7 = NID_pkcs7_data;
	p12 = PKCS12_init(nid_p7);
d165 1
a165 2
	if (!p12)
		return NULL;
d167 2
a168 5
	if(!PKCS12_pack_authsafes(p12, safes))
		{
		PKCS12_free(p12);
		return NULL;
		}
d172 1
a172 1
	}
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
a61 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a65 13
static int copy_bag_attr(PKCS12_SAFEBAG *bag, EVP_PKEY *pkey, int nid)
	{
	int idx;
	X509_ATTRIBUTE *attr;
	idx = EVP_PKEY_get_attr_by_NID(pkey, nid, -1);
	if (idx < 0)
		return 1;
	attr = EVP_PKEY_get_attr(pkey, idx);
	if (!X509at_add1_attr(&bag->attrib, attr))
		return 0;
	return 1;
	}

a79 6
		{
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			nid_cert = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
		else
#endif
a80 1
		}
d125 1
d131 8
a138 4
		if (!copy_bag_attr(bag, pkey, NID_ms_csp_name))
			goto err;
		if (!copy_bag_attr(bag, pkey, NID_LocalKeySet))
			goto err;
@


1.1.1.5
log
@import of OpenSSL 0.9.8k
@
text
@a172 3
	if (!p12)
		goto err;

@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d62 4
d97 6
d104 1
@


1.1.1.7
log
@Import OpenSSL 1.0.1g
@
text
@a92 6
		{
#ifdef OPENSSL_FIPS
		if (FIPS_mode())
			nid_cert = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;
		else
#endif
a93 1
		}
@


