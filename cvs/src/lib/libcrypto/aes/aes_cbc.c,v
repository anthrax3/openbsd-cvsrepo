head	1.12;
access;
symbols
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.12
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	mJUVYpkFBZ0Zv2bG;

1.11
date	2014.06.11.01.53.02;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	4evB2EbwDYaBfe0g;

1.10
date	2014.04.15.14.38.10;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.09.12.15.23;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.27.05.06.57;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.29.05.39.17;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.11.22.15.18;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.10;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.43;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.34.28;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.11.21.11.32;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.32;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.01;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.30;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.50;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.02;	author djm;	state Exp;
branches;
next	;


desc
@@


1.12
log
@tags as requested by miod and tedu
@
text
@/* $OpenBSD$ */
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 */

#include <openssl/aes.h>
#include <openssl/modes.h>

void
AES_cbc_encrypt(const unsigned char *in, unsigned char *out,
    size_t len, const AES_KEY *key, unsigned char *ivec, const int enc)
{
	if (enc)
		CRYPTO_cbc128_encrypt(in, out, len, key, ivec,
		    (block128_f)AES_encrypt);
	else
		CRYPTO_cbc128_decrypt(in, out, len, key, ivec,
		    (block128_f)AES_decrypt);
}
@


1.11
log
@c-file-style hints, begone; ok beck
@
text
@d1 1
a1 1
/* crypto/aes/aes_cbc.c */
@


1.10
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d1 1
a1 1
/* crypto/aes/aes_cbc.c -*- mode:C; c-file-style: "eay" -*- */
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d55 4
a58 4
void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,
		     size_t len, const AES_KEY *key,
		     unsigned char *ivec, const int enc) {

d60 2
a61 1
		CRYPTO_cbc128_encrypt(in,out,len,key,ivec,(block128_f)AES_encrypt);
d63 2
a64 1
		CRYPTO_cbc128_decrypt(in,out,len,key,ivec,(block128_f)AES_decrypt);
@


1.8
log
@resolve conflicts
@
text
@a51 7
#ifndef AES_DEBUG
# ifndef NDEBUG
#  define NDEBUG
# endif
#endif
#include <assert.h>

d53 1
a53 1
#include "aes_locl.h"
a54 1
#if !defined(OPENSSL_FIPS_AES_ASM)
d56 1
a56 1
		     const unsigned long length, const AES_KEY *key,
d59 4
a62 65
	unsigned long n;
	unsigned long len = length;
	unsigned char tmp[AES_BLOCK_SIZE];
	const unsigned char *iv = ivec;

	assert(in && out && key && ivec);
	assert((AES_ENCRYPT == enc)||(AES_DECRYPT == enc));

	if (AES_ENCRYPT == enc) {
		while (len >= AES_BLOCK_SIZE) {
			for(n=0; n < AES_BLOCK_SIZE; ++n)
				out[n] = in[n] ^ iv[n];
			AES_encrypt(out, out, key);
			iv = out;
			len -= AES_BLOCK_SIZE;
			in += AES_BLOCK_SIZE;
			out += AES_BLOCK_SIZE;
		}
		if (len) {
			for(n=0; n < len; ++n)
				out[n] = in[n] ^ iv[n];
			for(n=len; n < AES_BLOCK_SIZE; ++n)
				out[n] = iv[n];
			AES_encrypt(out, out, key);
			iv = out;
		}
		memcpy(ivec,iv,AES_BLOCK_SIZE);
	} else if (in != out) {
		while (len >= AES_BLOCK_SIZE) {
			AES_decrypt(in, out, key);
			for(n=0; n < AES_BLOCK_SIZE; ++n)
				out[n] ^= iv[n];
			iv = in;
			len -= AES_BLOCK_SIZE;
			in  += AES_BLOCK_SIZE;
			out += AES_BLOCK_SIZE;
		}
		if (len) {
			AES_decrypt(in,tmp,key);
			for(n=0; n < len; ++n)
				out[n] = tmp[n] ^ iv[n];
			iv = in;
		}
		memcpy(ivec,iv,AES_BLOCK_SIZE);
	} else {
		while (len >= AES_BLOCK_SIZE) {
			memcpy(tmp, in, AES_BLOCK_SIZE);
			AES_decrypt(in, out, key);
			for(n=0; n < AES_BLOCK_SIZE; ++n)
				out[n] ^= ivec[n];
			memcpy(ivec, tmp, AES_BLOCK_SIZE);
			len -= AES_BLOCK_SIZE;
			in += AES_BLOCK_SIZE;
			out += AES_BLOCK_SIZE;
		}
		if (len) {
			memcpy(tmp, in, AES_BLOCK_SIZE);
			AES_decrypt(tmp, out, key);
			for(n=0; n < len; ++n)
				out[n] ^= ivec[n];
			for(n=len; n < AES_BLOCK_SIZE; ++n)
				out[n] = tmp[n];
			memcpy(ivec, tmp, AES_BLOCK_SIZE);
		}
	}
a63 1
#endif
@


1.7
log
@resolve conflicts
@
text
@d62 1
d133 1
@


1.6
log
@resolve conflicts
@
text
@a61 1
#if !defined(OPENSSL_FIPS_AES_ASM)
a131 1
#endif
@


1.5
log
@resolve conflicts
@
text
@d62 1
d133 1
@


1.4
log
@merge 0.9.7d
@
text
@d69 1
d77 3
a79 3
				tmp[n] = in[n] ^ ivec[n];
			AES_encrypt(tmp, out, key);
			memcpy(ivec, out, AES_BLOCK_SIZE);
d86 1
a86 1
				tmp[n] = in[n] ^ ivec[n];
d88 22
a109 5
				tmp[n] = ivec[n];
			AES_encrypt(tmp, tmp, key);
			memcpy(out, tmp, AES_BLOCK_SIZE);
			memcpy(ivec, tmp, AES_BLOCK_SIZE);
		}			
d123 1
a123 1
			AES_decrypt(tmp, tmp, key);
d125 3
a127 1
				out[n] = tmp[n] ^ ivec[n];
d129 1
a129 1
		}			
@


1.3
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d107 1
a107 1
				out[n] ^= ivec[n];
@


1.2
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d75 1
a75 1
			for(n=0; n < sizeof tmp; ++n)
d89 2
a90 2
			memcpy(out, tmp, len);
			memcpy(ivec, tmp, sizeof tmp);
d94 1
a94 1
			memcpy(tmp, in, sizeof tmp);
d104 1
a104 1
			memcpy(tmp, in, sizeof tmp);
d108 1
a108 1
			memcpy(ivec, tmp, sizeof tmp);
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d52 5
d58 1
d66 1
a66 1
	int n;
d68 1
a68 1
	unsigned char tmp[16];
a70 1
	assert(length % AES_BLOCK_SIZE == 0);
d73 3
a75 3
	if (AES_ENCRYPT == enc)
		while (len > 0) {
			for(n=0; n < 16; ++n)
d78 4
a81 4
			memcpy(ivec, out, 16);
			len -= 16;
			in += 16;
			out += 16;
d83 12
a94 3
	else
		while (len > 0) {
			memcpy(tmp, in, 16);
d96 1
a96 1
			for(n=0; n < 16; ++n)
d98 4
a101 4
			memcpy(ivec, tmp, 16);
			len -= 16;
			in += 16;
			out += 16;
d103 8
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@a51 5
#ifndef AES_DEBUG
# ifndef NDEBUG
#  define NDEBUG
# endif
#endif
a52 1

d60 1
a60 1
	unsigned long n;
d62 1
a62 1
	unsigned char tmp[AES_BLOCK_SIZE];
d65 1
d68 3
a70 3
	if (AES_ENCRYPT == enc) {
		while (len >= AES_BLOCK_SIZE) {
			for(n=0; n < sizeof tmp; ++n)
d73 4
a76 4
			memcpy(ivec, out, AES_BLOCK_SIZE);
			len -= AES_BLOCK_SIZE;
			in += AES_BLOCK_SIZE;
			out += AES_BLOCK_SIZE;
d78 3
a80 12
		if (len) {
			for(n=0; n < len; ++n)
				tmp[n] = in[n] ^ ivec[n];
			for(n=len; n < AES_BLOCK_SIZE; ++n)
				tmp[n] = ivec[n];
			AES_encrypt(tmp, tmp, key);
			memcpy(out, tmp, len);
			memcpy(ivec, tmp, sizeof tmp);
		}			
	} else {
		while (len >= AES_BLOCK_SIZE) {
			memcpy(tmp, in, sizeof tmp);
d82 1
a82 1
			for(n=0; n < AES_BLOCK_SIZE; ++n)
d84 4
a87 4
			memcpy(ivec, tmp, AES_BLOCK_SIZE);
			len -= AES_BLOCK_SIZE;
			in += AES_BLOCK_SIZE;
			out += AES_BLOCK_SIZE;
a88 8
		if (len) {
			memcpy(tmp, in, sizeof tmp);
			AES_decrypt(tmp, tmp, key);
			for(n=0; n < len; ++n)
				out[n] ^= ivec[n];
			memcpy(ivec, tmp, sizeof tmp);
		}			
	}
@


1.1.1.3
log
@import 0.9.7c
@
text
@d75 1
a75 1
			for(n=0; n < AES_BLOCK_SIZE; ++n)
d89 2
a90 2
			memcpy(out, tmp, AES_BLOCK_SIZE);
			memcpy(ivec, tmp, AES_BLOCK_SIZE);
d94 1
a94 1
			memcpy(tmp, in, AES_BLOCK_SIZE);
d104 1
a104 1
			memcpy(tmp, in, AES_BLOCK_SIZE);
d108 1
a108 1
			memcpy(ivec, tmp, AES_BLOCK_SIZE);
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@d107 1
a107 1
				out[n] = tmp[n] ^ ivec[n];
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a68 1
	const unsigned char *iv = ivec;
d76 3
a78 3
				out[n] = in[n] ^ iv[n];
			AES_encrypt(out, out, key);
			iv = out;
d85 1
a85 1
				out[n] = in[n] ^ iv[n];
d87 5
a91 22
				out[n] = iv[n];
			AES_encrypt(out, out, key);
			iv = out;
		}
		memcpy(ivec,iv,AES_BLOCK_SIZE);
	} else if (in != out) {
		while (len >= AES_BLOCK_SIZE) {
			AES_decrypt(in, out, key);
			for(n=0; n < AES_BLOCK_SIZE; ++n)
				out[n] ^= iv[n];
			iv = in;
			len -= AES_BLOCK_SIZE;
			in  += AES_BLOCK_SIZE;
			out += AES_BLOCK_SIZE;
		}
		if (len) {
			AES_decrypt(in,tmp,key);
			for(n=0; n < len; ++n)
				out[n] = tmp[n] ^ iv[n];
			iv = in;
		}
		memcpy(ivec,iv,AES_BLOCK_SIZE);
d105 1
a105 1
			AES_decrypt(tmp, out, key);
d107 1
a107 3
				out[n] ^= ivec[n];
			for(n=len; n < AES_BLOCK_SIZE; ++n)
				out[n] = tmp[n];
d109 1
a109 1
		}
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@a61 1
#if !defined(OPENSSL_FIPS_AES_ASM)
a131 1
#endif
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d62 1
d133 1
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a61 1
#if !defined(OPENSSL_FIPS_AES_ASM)
a131 1
#endif
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d52 7
d60 1
a60 1
#include <openssl/modes.h>
d62 1
d64 1
a64 1
		     size_t len, const AES_KEY *key,
d67 65
a131 4
	if (enc)
		CRYPTO_cbc128_encrypt(in,out,len,key,ivec,(block128_f)AES_encrypt);
	else
		CRYPTO_cbc128_decrypt(in,out,len,key,ivec,(block128_f)AES_decrypt);
d133 1
@


