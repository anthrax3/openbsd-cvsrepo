head	1.15;
access;
symbols;
locks; strict;
comment	@ * @;


1.15
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.14;
commitid	kT0fLt3r4lroFJra;

1.14
date	2015.02.10.09.50.12;	author miod;	state Exp;
branches;
next	1.13;
commitid	vXPcwCc8wnLZxSX4;

1.13
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.12;
commitid	yQEL1wOWIearrW15;

1.12
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.11;
commitid	nzndm3zqPmFurSaK;

1.11
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.10;
commitid	id8dTrTMtnTn4fqt;

1.10
date	2014.06.27.06.07.35;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	d2qNpuBRGDFtF1vS;

1.9
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	mJUVYpkFBZ0Zv2bG;

1.8
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2014.05.08.13.20.49;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.57.20;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.09.16;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.57;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: bn_ctx.c,v 1.14 2015/02/10 09:50:12 miod Exp $ */
/* Written by Ulf Moeller for the OpenSSL project. */
/* ====================================================================
 * Copyright (c) 1998-2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#if !defined(BN_CTX_DEBUG) && !defined(BN_DEBUG)
#ifndef NDEBUG
#define NDEBUG
#endif
#endif

#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/err.h>

#include "bn_lcl.h"

/* TODO list
 *
 * 1. Check a bunch of "(words+1)" type hacks in various bignum functions and
 * check they can be safely removed.
 *  - Check +1 and other ugliness in BN_from_montgomery()
 *
 * 2. Consider allowing a BN_new_ex() that, at least, lets you specify an
 * appropriate 'block' size that will be honoured by bn_expand_internal() to
 * prevent piddly little reallocations. OTOH, profiling bignum expansions in
 * BN_CTX doesn't show this to be a big issue.
 */

/* How many bignums are in each "pool item"; */
#define BN_CTX_POOL_SIZE	16
/* The stack frame info is resizing, set a first-time expansion size; */
#define BN_CTX_START_FRAMES	32

/***********/
/* BN_POOL */
/***********/

/* A bundle of bignums that can be linked with other bundles */
typedef struct bignum_pool_item {
	/* The bignum values */
	BIGNUM vals[BN_CTX_POOL_SIZE];
	/* Linked-list admin */
	struct bignum_pool_item *prev, *next;
} BN_POOL_ITEM;

/* A linked-list of bignums grouped in bundles */
typedef struct bignum_pool {
	/* Linked-list admin */
	BN_POOL_ITEM *head, *current, *tail;
	/* Stack depth and allocation size */
	unsigned used, size;
} BN_POOL;

static void		BN_POOL_init(BN_POOL *);
static void		BN_POOL_finish(BN_POOL *);
#ifndef OPENSSL_NO_DEPRECATED
static void		BN_POOL_reset(BN_POOL *);
#endif
static BIGNUM *		BN_POOL_get(BN_POOL *);
static void		BN_POOL_release(BN_POOL *, unsigned int);

/************/
/* BN_STACK */
/************/

/* A wrapper to manage the "stack frames" */
typedef struct bignum_ctx_stack {
	/* Array of indexes into the bignum stack */
	unsigned int *indexes;
	/* Number of stack frames, and the size of the allocated array */
	unsigned int depth, size;
} BN_STACK;

static void		BN_STACK_init(BN_STACK *);
static void		BN_STACK_finish(BN_STACK *);
#ifndef OPENSSL_NO_DEPRECATED
static void		BN_STACK_reset(BN_STACK *);
#endif
static int		BN_STACK_push(BN_STACK *, unsigned int);
static unsigned int	BN_STACK_pop(BN_STACK *);

/**********/
/* BN_CTX */
/**********/

/* The opaque BN_CTX type */
struct bignum_ctx {
	/* The bignum bundles */
	BN_POOL pool;
	/* The "stack frames", if you will */
	BN_STACK stack;
	/* The number of bignums currently assigned */
	unsigned int used;
	/* Depth of stack overflow */
	int err_stack;
	/* Block "gets" until an "end" (compatibility behaviour) */
	int too_many;
};

/* Enable this to find BN_CTX bugs */
#ifdef BN_CTX_DEBUG
static const char *ctxdbg_cur = NULL;

static void
ctxdbg(BN_CTX *ctx)
{
	unsigned int bnidx = 0, fpidx = 0;
	BN_POOL_ITEM *item = ctx->pool.head;
	BN_STACK *stack = &ctx->stack;

	fprintf(stderr, "(%08x): ", (unsigned int)ctx);
	while (bnidx < ctx->used) {
		fprintf(stderr, "%03x ",
		    item->vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);
		if (!(bnidx % BN_CTX_POOL_SIZE))
			item = item->next;
	}
	fprintf(stderr, "\n");
	bnidx = 0;
	fprintf(stderr, "          : ");
	while (fpidx < stack->depth) {
		while (bnidx++ < stack->indexes[fpidx])
			fprintf(stderr, "    ");
		fprintf(stderr, "^^^ ");
		bnidx++;
		fpidx++;
	}
	fprintf(stderr, "\n");
}
#define CTXDBG_ENTRY(str, ctx) \
	do { \
		ctxdbg_cur = (str); \
		fprintf(stderr, "Starting %s\n", ctxdbg_cur); \
		ctxdbg(ctx); \
	} while(0)

#define CTXDBG_EXIT(ctx) \
	do { \
		fprintf(stderr, "Ending %s\n", ctxdbg_cur); \
		ctxdbg(ctx); \
	} while(0)

#define CTXDBG_RET(ctx,ret)
#else
#define CTXDBG_ENTRY(str, ctx)
#define CTXDBG_EXIT(ctx)
#define CTXDBG_RET(ctx,ret)
#endif

/* This function is an evil legacy and should not be used. This implementation
 * is WYSIWYG, though I've done my best. */
#ifndef OPENSSL_NO_DEPRECATED
void
BN_CTX_init(BN_CTX *ctx)
{
	/* Assume the caller obtained the context via BN_CTX_new() and so is
	 * trying to reset it for use. Nothing else makes sense, least of all
	 * binary compatibility from a time when they could declare a static
	 * variable. */
	BN_POOL_reset(&ctx->pool);
	BN_STACK_reset(&ctx->stack);
	ctx->used = 0;
	ctx->err_stack = 0;
	ctx->too_many = 0;
}
#endif

BN_CTX *
BN_CTX_new(void)
{
	BN_CTX *ret = malloc(sizeof(BN_CTX));
	if (!ret) {
		BNerror(ERR_R_MALLOC_FAILURE);
		return NULL;
	}

	/* Initialise the structure */
	BN_POOL_init(&ret->pool);
	BN_STACK_init(&ret->stack);
	ret->used = 0;
	ret->err_stack = 0;
	ret->too_many = 0;
	return ret;
}

void
BN_CTX_free(BN_CTX *ctx)
{
	if (ctx == NULL)
		return;
#ifdef BN_CTX_DEBUG
	{
		BN_POOL_ITEM *pool = ctx->pool.head;
		fprintf(stderr, "BN_CTX_free, stack-size=%d, pool-bignums=%d\n",
		    ctx->stack.size, ctx->pool.size);
		fprintf(stderr, "dmaxs: ");
		while (pool) {
			unsigned loop = 0;
			while (loop < BN_CTX_POOL_SIZE)
				fprintf(stderr, "%02x ",
				    pool->vals[loop++].dmax);
			pool = pool->next;
		}
		fprintf(stderr, "\n");
	}
#endif
	BN_STACK_finish(&ctx->stack);
	BN_POOL_finish(&ctx->pool);
	free(ctx);
}

void
BN_CTX_start(BN_CTX *ctx)
{
	CTXDBG_ENTRY("BN_CTX_start", ctx);

	/* If we're already overflowing ... */
	if (ctx->err_stack || ctx->too_many)
		ctx->err_stack++;
	/* (Try to) get a new frame pointer */
	else if (!BN_STACK_push(&ctx->stack, ctx->used)) {
		BNerror(BN_R_TOO_MANY_TEMPORARY_VARIABLES);
		ctx->err_stack++;
	}
	CTXDBG_EXIT(ctx);
}

void
BN_CTX_end(BN_CTX *ctx)
{
	CTXDBG_ENTRY("BN_CTX_end", ctx);

	if (ctx->err_stack)
		ctx->err_stack--;
	else {
		unsigned int fp = BN_STACK_pop(&ctx->stack);
		/* Does this stack frame have anything to release? */
		if (fp < ctx->used)
			BN_POOL_release(&ctx->pool, ctx->used - fp);
		ctx->used = fp;
		/* Unjam "too_many" in case "get" had failed */
		ctx->too_many = 0;
	}
	CTXDBG_EXIT(ctx);
}

BIGNUM *
BN_CTX_get(BN_CTX *ctx)
{
	BIGNUM *ret;

	CTXDBG_ENTRY("BN_CTX_get", ctx);

	if (ctx->err_stack || ctx->too_many)
		return NULL;
	if ((ret = BN_POOL_get(&ctx->pool)) == NULL) {
		/* Setting too_many prevents repeated "get" attempts from
		 * cluttering the error stack. */
		ctx->too_many = 1;
		BNerror(BN_R_TOO_MANY_TEMPORARY_VARIABLES);
		return NULL;
	}
	/* OK, make sure the returned bignum is "zero" */
	BN_zero(ret);
	ctx->used++;
	CTXDBG_RET(ctx, ret);
	return ret;
}

/************/
/* BN_STACK */
/************/

static void
BN_STACK_init(BN_STACK *st)
{
	st->indexes = NULL;
	st->depth = st->size = 0;
}

static void
BN_STACK_finish(BN_STACK *st)
{
	if (st->size)
		free(st->indexes);
}

#ifndef OPENSSL_NO_DEPRECATED
static void
BN_STACK_reset(BN_STACK *st)
{
	st->depth = 0;
}
#endif

static int
BN_STACK_push(BN_STACK *st, unsigned int idx)
{
	if (st->depth == st->size)
		/* Need to expand */
	{
		unsigned int newsize = (st->size ?
		    (st->size * 3 / 2) : BN_CTX_START_FRAMES);
		unsigned int *newitems = reallocarray(NULL,
		    newsize, sizeof(unsigned int));
		if (!newitems)
			return 0;
		if (st->depth)
			memcpy(newitems, st->indexes, st->depth *
			    sizeof(unsigned int));
		if (st->size)
			free(st->indexes);
		st->indexes = newitems;
		st->size = newsize;
	}
	st->indexes[(st->depth)++] = idx;
	return 1;
}

static unsigned int
BN_STACK_pop(BN_STACK *st)
{
	return st->indexes[--(st->depth)];
}

/***********/
/* BN_POOL */
/***********/

static void
BN_POOL_init(BN_POOL *p)
{
	p->head = p->current = p->tail = NULL;
	p->used = p->size = 0;
}

static void
BN_POOL_finish(BN_POOL *p)
{
	while (p->head) {
		unsigned int loop = 0;
		BIGNUM *bn = p->head->vals;
		while (loop++ < BN_CTX_POOL_SIZE) {
			if (bn->d)
				BN_clear_free(bn);
			bn++;
		}
		p->current = p->head->next;
		free(p->head);
		p->head = p->current;
	}
}

#ifndef OPENSSL_NO_DEPRECATED
static void
BN_POOL_reset(BN_POOL *p)
{
	BN_POOL_ITEM *item = p->head;
	while (item) {
		unsigned int loop = 0;
		BIGNUM *bn = item->vals;
		while (loop++ < BN_CTX_POOL_SIZE) {
			if (bn->d)
				BN_clear(bn);
			bn++;
		}
		item = item->next;
	}
	p->current = p->head;
	p->used = 0;
}
#endif

static BIGNUM *
BN_POOL_get(BN_POOL *p)
{
	if (p->used == p->size) {
		BIGNUM *bn;
		unsigned int loop = 0;
		BN_POOL_ITEM *item = malloc(sizeof(BN_POOL_ITEM));
		if (!item)
			return NULL;
		/* Initialise the structure */
		bn = item->vals;
		while (loop++ < BN_CTX_POOL_SIZE)
			BN_init(bn++);
		item->prev = p->tail;
		item->next = NULL;
		/* Link it in */
		if (!p->head)
			p->head = p->current = p->tail = item;
		else {
			p->tail->next = item;
			p->tail = item;
			p->current = item;
		}
		p->size += BN_CTX_POOL_SIZE;
		p->used++;
		/* Return the first bignum from the new pool */
		return item->vals;
	}
	if (!p->used)
		p->current = p->head;
	else if ((p->used % BN_CTX_POOL_SIZE) == 0)
		p->current = p->current->next;
	return p->current->vals + ((p->used++) % BN_CTX_POOL_SIZE);
}

static void
BN_POOL_release(BN_POOL *p, unsigned int num)
{
	unsigned int offset = (p->used - 1) % BN_CTX_POOL_SIZE;

	p->used -= num;
	while (num--) {
		bn_check_top(p->current->vals + offset);
		if (!offset) {
			offset = BN_CTX_POOL_SIZE - 1;
			p->current = p->current->prev;
		} else
			offset--;
	}
}
@


1.14
log
@Remove unnecessary include of assert.h
@
text
@d1 1
a1 1
/* $OpenBSD: bn_ctx.c,v 1.13 2014/07/11 08:44:47 jsing Exp $ */
d228 1
a228 1
		BNerr(BN_F_BN_CTX_NEW, ERR_R_MALLOC_FAILURE);
d277 1
a277 1
		BNerr(BN_F_BN_CTX_START, BN_R_TOO_MANY_TEMPORARY_VARIABLES);
d315 1
a315 1
		BNerr(BN_F_BN_CTX_GET, BN_R_TOO_MANY_TEMPORARY_VARIABLES);
@


1.13
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_ctx.c,v 1.12 2014/07/10 22:45:56 jsing Exp $ */
a62 1
#include <assert.h>
@


1.12
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: bn_ctx.c,v 1.11 2014/07/10 13:58:22 jsing Exp $ */
d69 2
a70 1
#include "cryptlib.h"
@


1.11
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_ctx.c,v 1.10 2014/06/27 06:07:35 deraadt Exp $ */
d66 2
@


1.10
log
@hand-KNF macro the do { } while loops
@
text
@d1 1
a1 1
/* $OpenBSD: bn_ctx.c,v 1.9 2014/06/12 15:49:28 deraadt Exp $ */
d63 1
d65 1
a65 1
#include <assert.h>
@


1.9
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d182 13
a194 9
#define CTXDBG_ENTRY(str, ctx)	do { \
				ctxdbg_cur = (str); \
				fprintf(stderr,"Starting %s\n", ctxdbg_cur); \
				ctxdbg(ctx); \
				} while(0)
#define CTXDBG_EXIT(ctx)	do { \
				fprintf(stderr,"Ending %s\n", ctxdbg_cur); \
				ctxdbg(ctx); \
				} while(0)
@


1.8
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d1 1
a1 1
/* crypto/bn/bn_ctx.c */
@


1.7
log
@Emergency knfectomie requested by tedu@@.
@
text
@d352 2
a353 2
		unsigned int *newitems = malloc(newsize *
		    sizeof(unsigned int));
@


1.6
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d11 1
a11 1
 *    notice, this list of conditions and the following disclaimer. 
d91 1
a91 2
typedef struct bignum_pool_item
	{
d96 2
a97 1
	} BN_POOL_ITEM;
d99 1
a99 2
typedef struct bignum_pool
	{
d104 2
a105 1
	} BN_POOL;
d119 1
a119 2
typedef struct bignum_ctx_stack
	{
d124 2
a125 1
	} BN_STACK;
d139 1
a139 2
struct bignum_ctx
	{
d150 1
a150 1
	};
d155 4
a158 2
static void ctxdbg(BN_CTX *ctx)
	{
d162 6
a167 5
	fprintf(stderr,"(%08x): ", (unsigned int)ctx);
	while(bnidx < ctx->used)
		{
		fprintf(stderr,"%03x ", item->vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);
		if(!(bnidx % BN_CTX_POOL_SIZE))
d169 2
a170 2
		}
	fprintf(stderr,"\n");
d172 5
a176 6
	fprintf(stderr,"          : ");
	while(fpidx < stack->depth)
		{
		while(bnidx++ < stack->indexes[fpidx])
			fprintf(stderr,"    ");
		fprintf(stderr,"^^^ ");
a178 2
		}
	fprintf(stderr,"\n");
d180 2
d201 3
a203 2
void BN_CTX_init(BN_CTX *ctx)
	{
d213 1
a213 1
	}
d216 3
a218 2
BN_CTX *BN_CTX_new(void)
	{
d220 2
a221 3
	if(!ret)
		{
		BNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);
d223 2
a224 1
		}
d232 1
a232 1
	}
d234 3
a236 2
void BN_CTX_free(BN_CTX *ctx)
	{
d241 12
a252 11
	BN_POOL_ITEM *pool = ctx->pool.head;
	fprintf(stderr,"BN_CTX_free, stack-size=%d, pool-bignums=%d\n",
		ctx->stack.size, ctx->pool.size);
	fprintf(stderr,"dmaxs: ");
	while(pool) {
		unsigned loop = 0;
		while(loop < BN_CTX_POOL_SIZE)
			fprintf(stderr,"%02x ", pool->vals[loop++].dmax);
		pool = pool->next;
	}
	fprintf(stderr,"\n");
d258 1
a258 1
	}
d260 3
a262 2
void BN_CTX_start(BN_CTX *ctx)
	{
d264 1
d266 1
a266 1
	if(ctx->err_stack || ctx->too_many)
d269 2
a270 3
	else if(!BN_STACK_push(&ctx->stack, ctx->used))
		{
		BNerr(BN_F_BN_CTX_START,BN_R_TOO_MANY_TEMPORARY_VARIABLES);
d272 1
a272 1
		}
d274 1
a274 1
	}
d276 3
a278 2
void BN_CTX_end(BN_CTX *ctx)
	{
d280 2
a281 1
	if(ctx->err_stack)
d283 1
a283 2
	else
		{
d286 1
a286 1
		if(fp < ctx->used)
d291 1
a291 1
		}
d293 1
a293 1
	}
d295 3
a297 2
BIGNUM *BN_CTX_get(BN_CTX *ctx)
	{
d299 1
d301 4
a304 3
	if(ctx->err_stack || ctx->too_many) return NULL;
	if((ret = BN_POOL_get(&ctx->pool)) == NULL)
		{
d308 1
a308 1
		BNerr(BN_F_BN_CTX_GET,BN_R_TOO_MANY_TEMPORARY_VARIABLES);
d310 1
a310 1
		}
d316 1
a316 1
	}
d322 3
a324 2
static void BN_STACK_init(BN_STACK *st)
	{
d327 1
a327 1
	}
d329 6
a334 4
static void BN_STACK_finish(BN_STACK *st)
	{
	if(st->size) free(st->indexes);
	}
d337 3
a339 2
static void BN_STACK_reset(BN_STACK *st)
	{
d341 1
a341 1
	}
d344 5
a348 1
static int BN_STACK_push(BN_STACK *st, unsigned int idx)
a349 3
	if(st->depth == st->size)
		/* Need to expand */
		{
d351 1
a351 1
				(st->size * 3 / 2) : BN_CTX_START_FRAMES);
d353 4
a356 3
						sizeof(unsigned int));
		if(!newitems) return 0;
		if(st->depth)
d358 3
a360 2
						sizeof(unsigned int));
		if(st->size) free(st->indexes);
d363 1
a363 1
		}
d366 1
a366 1
	}
d368 3
a370 2
static unsigned int BN_STACK_pop(BN_STACK *st)
	{
d372 1
a372 1
	}
d378 3
a380 2
static void BN_POOL_init(BN_POOL *p)
	{
d383 1
a383 1
	}
d385 4
a388 4
static void BN_POOL_finish(BN_POOL *p)
	{
	while(p->head)
		{
d391 3
a393 3
		while(loop++ < BN_CTX_POOL_SIZE)
			{
			if(bn->d) BN_clear_free(bn);
d395 1
a395 1
			}
a398 1
		}
d400 1
d403 3
a405 2
static void BN_POOL_reset(BN_POOL *p)
	{
d407 1
a407 2
	while(item)
		{
d410 3
a412 3
		while(loop++ < BN_CTX_POOL_SIZE)
			{
			if(bn->d) BN_clear(bn);
d414 1
a414 1
			}
d416 1
a416 1
		}
d419 1
a419 1
	}
d422 4
a425 4
static BIGNUM *BN_POOL_get(BN_POOL *p)
	{
	if(p->used == p->size)
		{
d429 2
a430 1
		if(!item) return NULL;
d433 1
a433 1
		while(loop++ < BN_CTX_POOL_SIZE)
d438 1
a438 1
		if(!p->head)
d440 1
a440 2
		else
			{
d444 1
a444 1
			}
d449 2
a450 2
		}
	if(!p->used)
d452 1
a452 1
	else if((p->used % BN_CTX_POOL_SIZE) == 0)
d455 1
a455 1
	}
d457 3
a459 2
static void BN_POOL_release(BN_POOL *p, unsigned int num)
	{
d461 1
d463 1
a463 2
	while(num--)
		{
d465 1
a465 2
		if(!offset)
			{
d468 1
a468 2
			}
		else
a469 1
		}
d471 1
a471 1

@


1.5
log
@resolve conflicts, fix local changes
@
text
@d216 1
a216 1
	BN_CTX *ret = OPENSSL_malloc(sizeof(BN_CTX));
d252 1
a252 1
	OPENSSL_free(ctx);
d320 1
a320 1
	if(st->size) OPENSSL_free(st->indexes);
d337 1
a337 1
		unsigned int *newitems = OPENSSL_malloc(newsize *
d343 1
a343 1
		if(st->size) OPENSSL_free(st->indexes);
d378 1
a378 1
		OPENSSL_free(p->head);
d409 1
a409 1
		BN_POOL_ITEM *item = OPENSSL_malloc(sizeof(BN_POOL_ITEM));
@


1.4
log
@resolve conflicts
@
text
@d164 1
a164 1
		fprintf(stderr,"%02x ", item->vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);
d174 2
a175 2
			fprintf(stderr,"   ");
		fprintf(stderr,"^^ ");
@


1.3
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
d57 4
a60 3
#ifndef BN_CTX_DEBUG
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
d69 44
d114 6
a119 1
BN_CTX *BN_CTX_new(void)
d121 12
a132 1
	BN_CTX *ret;
d134 29
a162 2
	ret=(BN_CTX *)OPENSSL_malloc(sizeof(BN_CTX));
	if (ret == NULL)
d164 14
a177 2
		BNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);
		return(NULL);
d179 1
a179 4

	BN_CTX_init(ret);
	ret->flags=BN_FLG_MALLOCED;
	return(ret);
d181 15
d197 3
d202 8
a209 5
#if 0 /* explicit version */
	int i;
	ctx->tos = 0;
	ctx->flags = 0;
	ctx->depth = 0;
d211 1
a211 4
	for (i = 0; i < BN_CTX_NUM; i++)
		BN_init(&(ctx->bn[i]));
#else
	memset(ctx, 0, sizeof *ctx);
d213 16
d233 96
a328 1
	int i;
d330 20
a349 2
	if (ctx == NULL) return;
	assert(ctx->depth == 0);
d351 3
a353 4
	for (i=0; i < BN_CTX_NUM; i++)
		BN_clear_free(&(ctx->bn[i]));
	if (ctx->flags & BN_FLG_MALLOCED)
		OPENSSL_free(ctx);
d356 5
a360 1
void BN_CTX_start(BN_CTX *ctx)
d362 2
a363 3
	if (ctx->depth < BN_CTX_NUM_POS)
		ctx->pos[ctx->depth] = ctx->tos;
	ctx->depth++;
d366 16
d383 2
a384 1
BIGNUM *BN_CTX_get(BN_CTX *ctx)
d386 2
a387 6
	/* Note: If BN_CTX_get is ever changed to allocate BIGNUMs dynamically,
	 * make sure that if BN_CTX_get fails once it will return NULL again
	 * until BN_CTX_end is called.  (This is so that callers have to check
	 * only the last return value.)
	 */
	if (ctx->depth > BN_CTX_NUM_POS || ctx->tos >= BN_CTX_NUM)
d389 3
a391 1
		if (!ctx->too_many)
d393 2
a394 3
			BNerr(BN_F_BN_CTX_GET,BN_R_TOO_MANY_TEMPORARY_VARIABLES);
			/* disable error code until BN_CTX_end is called: */
			ctx->too_many = 1;
d396 1
a396 1
		return NULL;
d398 2
a399 1
	return (&(ctx->bn[ctx->tos++]));
d401 1
d403 1
a403 1
void BN_CTX_end(BN_CTX *ctx)
d405 32
a436 7
	if (ctx == NULL) return;
	assert(ctx->depth > 0);
	if (ctx->depth == 0)
		/* should never happen, but we can tolerate it if not in
		 * debug mode (could be a 'goto err' in the calling function
		 * before BN_CTX_start was reached) */
		BN_CTX_start(ctx);
d438 15
a452 4
	ctx->too_many = 0;
	ctx->depth--;
	if (ctx->depth < BN_CTX_NUM_POS)
		ctx->tos = ctx->pos[ctx->depth];
d454 1
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d64 1
d66 1
a66 1
#include <openssl/bn.h>
d87 1
d95 3
d120 1
d123 5
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d72 1
a72 1
	ret=(BN_CTX *)Malloc(sizeof(BN_CTX));
d105 1
a105 1
		Free(ctx);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a63 1

d65 1
a65 1
#include "bn_lcl.h"
d72 1
a72 1
	ret=(BN_CTX *)OPENSSL_malloc(sizeof(BN_CTX));
a85 1
#if 0 /* explicit version */
a92 3
#else
	memset(ctx, 0, sizeof *ctx);
#endif
d105 1
a105 1
		OPENSSL_free(ctx);
a114 1

a116 5
	/* Note: If BN_CTX_get is ever changed to allocate BIGNUMs dynamically,
	 * make sure that if BN_CTX_get fails once it will return NULL again
	 * until BN_CTX_end is called.  (This is so that callers have to check
	 * only the last return value.)
	 */
@


1.1.1.2
log
@import of OpenSSL 0.9.8h
@
text
@d4 1
a4 1
 * Copyright (c) 1998-2004 The OpenSSL Project.  All rights reserved.
d57 3
a59 4
#if !defined(BN_CTX_DEBUG) && !defined(BN_DEBUG)
#ifndef NDEBUG
#define NDEBUG
#endif
a67 20
/* TODO list
 *
 * 1. Check a bunch of "(words+1)" type hacks in various bignum functions and
 * check they can be safely removed.
 *  - Check +1 and other ugliness in BN_from_montgomery()
 *
 * 2. Consider allowing a BN_new_ex() that, at least, lets you specify an
 * appropriate 'block' size that will be honoured by bn_expand_internal() to
 * prevent piddly little reallocations. OTOH, profiling bignum expansions in
 * BN_CTX doesn't show this to be a big issue.
 */

/* How many bignums are in each "pool item"; */
#define BN_CTX_POOL_SIZE	16
/* The stack frame info is resizing, set a first-time expansion size; */
#define BN_CTX_START_FRAMES	32

/***********/
/* BN_POOL */
/***********/
d69 1
a69 2
/* A bundle of bignums that can be linked with other bundles */
typedef struct bignum_pool_item
d71 1
a71 40
	/* The bignum values */
	BIGNUM vals[BN_CTX_POOL_SIZE];
	/* Linked-list admin */
	struct bignum_pool_item *prev, *next;
	} BN_POOL_ITEM;
/* A linked-list of bignums grouped in bundles */
typedef struct bignum_pool
	{
	/* Linked-list admin */
	BN_POOL_ITEM *head, *current, *tail;
	/* Stack depth and allocation size */
	unsigned used, size;
	} BN_POOL;
static void		BN_POOL_init(BN_POOL *);
static void		BN_POOL_finish(BN_POOL *);
#ifndef OPENSSL_NO_DEPRECATED
static void		BN_POOL_reset(BN_POOL *);
#endif
static BIGNUM *		BN_POOL_get(BN_POOL *);
static void		BN_POOL_release(BN_POOL *, unsigned int);

/************/
/* BN_STACK */
/************/

/* A wrapper to manage the "stack frames" */
typedef struct bignum_ctx_stack
	{
	/* Array of indexes into the bignum stack */
	unsigned int *indexes;
	/* Number of stack frames, and the size of the allocated array */
	unsigned int depth, size;
	} BN_STACK;
static void		BN_STACK_init(BN_STACK *);
static void		BN_STACK_finish(BN_STACK *);
#ifndef OPENSSL_NO_DEPRECATED
static void		BN_STACK_reset(BN_STACK *);
#endif
static int		BN_STACK_push(BN_STACK *, unsigned int);
static unsigned int	BN_STACK_pop(BN_STACK *);
d73 2
a74 29
/**********/
/* BN_CTX */
/**********/

/* The opaque BN_CTX type */
struct bignum_ctx
	{
	/* The bignum bundles */
	BN_POOL pool;
	/* The "stack frames", if you will */
	BN_STACK stack;
	/* The number of bignums currently assigned */
	unsigned int used;
	/* Depth of stack overflow */
	int err_stack;
	/* Block "gets" until an "end" (compatibility behaviour) */
	int too_many;
	};

/* Enable this to find BN_CTX bugs */
#ifdef BN_CTX_DEBUG
static const char *ctxdbg_cur = NULL;
static void ctxdbg(BN_CTX *ctx)
	{
	unsigned int bnidx = 0, fpidx = 0;
	BN_POOL_ITEM *item = ctx->pool.head;
	BN_STACK *stack = &ctx->stack;
	fprintf(stderr,"(%08x): ", (unsigned int)ctx);
	while(bnidx < ctx->used)
d76 2
a77 3
		fprintf(stderr,"%02x ", item->vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);
		if(!(bnidx % BN_CTX_POOL_SIZE))
			item = item->next;
d79 4
a82 12
	fprintf(stderr,"\n");
	bnidx = 0;
	fprintf(stderr,"          : ");
	while(fpidx < stack->depth)
		{
		while(bnidx++ < stack->indexes[fpidx])
			fprintf(stderr,"   ");
		fprintf(stderr,"^^ ");
		bnidx++;
		fpidx++;
		}
	fprintf(stderr,"\n");
a83 15
#define CTXDBG_ENTRY(str, ctx)	do { \
				ctxdbg_cur = (str); \
				fprintf(stderr,"Starting %s\n", ctxdbg_cur); \
				ctxdbg(ctx); \
				} while(0)
#define CTXDBG_EXIT(ctx)	do { \
				fprintf(stderr,"Ending %s\n", ctxdbg_cur); \
				ctxdbg(ctx); \
				} while(0)
#define CTXDBG_RET(ctx,ret)
#else
#define CTXDBG_ENTRY(str, ctx)
#define CTXDBG_EXIT(ctx)
#define CTXDBG_RET(ctx,ret)
#endif
a84 3
/* This function is an evil legacy and should not be used. This implementation
 * is WYSIWYG, though I've done my best. */
#ifndef OPENSSL_NO_DEPRECATED
d87 5
a91 8
	/* Assume the caller obtained the context via BN_CTX_new() and so is
	 * trying to reset it for use. Nothing else makes sense, least of all
	 * binary compatibility from a time when they could declare a static
	 * variable. */
	BN_POOL_reset(&ctx->pool);
	BN_STACK_reset(&ctx->stack);
	ctx->used = 0;
	ctx->err_stack = 0;
d93 4
a96 1
	}
a97 16

BN_CTX *BN_CTX_new(void)
	{
	BN_CTX *ret = OPENSSL_malloc(sizeof(BN_CTX));
	if(!ret)
		{
		BNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);
		return NULL;
		}
	/* Initialise the structure */
	BN_POOL_init(&ret->pool);
	BN_STACK_init(&ret->stack);
	ret->used = 0;
	ret->err_stack = 0;
	ret->too_many = 0;
	return ret;
d102 9
a110 20
	if (ctx == NULL)
		return;
#ifdef BN_CTX_DEBUG
	{
	BN_POOL_ITEM *pool = ctx->pool.head;
	fprintf(stderr,"BN_CTX_free, stack-size=%d, pool-bignums=%d\n",
		ctx->stack.size, ctx->pool.size);
	fprintf(stderr,"dmaxs: ");
	while(pool) {
		unsigned loop = 0;
		while(loop < BN_CTX_POOL_SIZE)
			fprintf(stderr,"%02x ", pool->vals[loop++].dmax);
		pool = pool->next;
	}
	fprintf(stderr,"\n");
	}
#endif
	BN_STACK_finish(&ctx->stack);
	BN_POOL_finish(&ctx->pool);
	OPENSSL_free(ctx);
d115 3
a117 11
	CTXDBG_ENTRY("BN_CTX_start", ctx);
	/* If we're already overflowing ... */
	if(ctx->err_stack || ctx->too_many)
		ctx->err_stack++;
	/* (Try to) get a new frame pointer */
	else if(!BN_STACK_push(&ctx->stack, ctx->used))
		{
		BNerr(BN_F_BN_CTX_START,BN_R_TOO_MANY_TEMPORARY_VARIABLES);
		ctx->err_stack++;
		}
	CTXDBG_EXIT(ctx);
a119 17
void BN_CTX_end(BN_CTX *ctx)
	{
	CTXDBG_ENTRY("BN_CTX_end", ctx);
	if(ctx->err_stack)
		ctx->err_stack--;
	else
		{
		unsigned int fp = BN_STACK_pop(&ctx->stack);
		/* Does this stack frame have anything to release? */
		if(fp < ctx->used)
			BN_POOL_release(&ctx->pool, ctx->used - fp);
		ctx->used = fp;
		/* Unjam "too_many" in case "get" had failed */
		ctx->too_many = 0;
		}
	CTXDBG_EXIT(ctx);
	}
d123 6
a128 44
	BIGNUM *ret;
	CTXDBG_ENTRY("BN_CTX_get", ctx);
	if(ctx->err_stack || ctx->too_many) return NULL;
	if((ret = BN_POOL_get(&ctx->pool)) == NULL)
		{
		/* Setting too_many prevents repeated "get" attempts from
		 * cluttering the error stack. */
		ctx->too_many = 1;
		BNerr(BN_F_BN_CTX_GET,BN_R_TOO_MANY_TEMPORARY_VARIABLES);
		return NULL;
		}
	/* OK, make sure the returned bignum is "zero" */
	BN_zero(ret);
	ctx->used++;
	CTXDBG_RET(ctx, ret);
	return ret;
	}

/************/
/* BN_STACK */
/************/

static void BN_STACK_init(BN_STACK *st)
	{
	st->indexes = NULL;
	st->depth = st->size = 0;
	}

static void BN_STACK_finish(BN_STACK *st)
	{
	if(st->size) OPENSSL_free(st->indexes);
	}

#ifndef OPENSSL_NO_DEPRECATED
static void BN_STACK_reset(BN_STACK *st)
	{
	st->depth = 0;
	}
#endif

static int BN_STACK_push(BN_STACK *st, unsigned int idx)
	{
	if(st->depth == st->size)
		/* Need to expand */
d130 1
a130 38
		unsigned int newsize = (st->size ?
				(st->size * 3 / 2) : BN_CTX_START_FRAMES);
		unsigned int *newitems = OPENSSL_malloc(newsize *
						sizeof(unsigned int));
		if(!newitems) return 0;
		if(st->depth)
			memcpy(newitems, st->indexes, st->depth *
						sizeof(unsigned int));
		if(st->size) OPENSSL_free(st->indexes);
		st->indexes = newitems;
		st->size = newsize;
		}
	st->indexes[(st->depth)++] = idx;
	return 1;
	}

static unsigned int BN_STACK_pop(BN_STACK *st)
	{
	return st->indexes[--(st->depth)];
	}

/***********/
/* BN_POOL */
/***********/

static void BN_POOL_init(BN_POOL *p)
	{
	p->head = p->current = p->tail = NULL;
	p->used = p->size = 0;
	}

static void BN_POOL_finish(BN_POOL *p)
	{
	while(p->head)
		{
		unsigned int loop = 0;
		BIGNUM *bn = p->head->vals;
		while(loop++ < BN_CTX_POOL_SIZE)
d132 3
a134 2
			if(bn->d) BN_clear_free(bn);
			bn++;
d136 1
a136 3
		p->current = p->head->next;
		OPENSSL_free(p->head);
		p->head = p->current;
d138 1
d141 1
a141 2
#ifndef OPENSSL_NO_DEPRECATED
static void BN_POOL_reset(BN_POOL *p)
d143 7
a149 16
	BN_POOL_ITEM *item = p->head;
	while(item)
		{
		unsigned int loop = 0;
		BIGNUM *bn = item->vals;
		while(loop++ < BN_CTX_POOL_SIZE)
			{
			if(bn->d) BN_clear(bn);
			bn++;
			}
		item = item->next;
		}
	p->current = p->head;
	p->used = 0;
	}
#endif
d151 4
a154 33
static BIGNUM *BN_POOL_get(BN_POOL *p)
	{
	if(p->used == p->size)
		{
		BIGNUM *bn;
		unsigned int loop = 0;
		BN_POOL_ITEM *item = OPENSSL_malloc(sizeof(BN_POOL_ITEM));
		if(!item) return NULL;
		/* Initialise the structure */
		bn = item->vals;
		while(loop++ < BN_CTX_POOL_SIZE)
			BN_init(bn++);
		item->prev = p->tail;
		item->next = NULL;
		/* Link it in */
		if(!p->head)
			p->head = p->current = p->tail = item;
		else
			{
			p->tail->next = item;
			p->tail = item;
			p->current = item;
			}
		p->size += BN_CTX_POOL_SIZE;
		p->used++;
		/* Return the first bignum from the new pool */
		return item->vals;
		}
	if(!p->used)
		p->current = p->head;
	else if((p->used % BN_CTX_POOL_SIZE) == 0)
		p->current = p->current->next;
	return p->current->vals + ((p->used++) % BN_CTX_POOL_SIZE);
a155 18

static void BN_POOL_release(BN_POOL *p, unsigned int num)
	{
	unsigned int offset = (p->used - 1) % BN_CTX_POOL_SIZE;
	p->used -= num;
	while(num--)
		{
		bn_check_top(p->current->vals + offset);
		if(!offset)
			{
			offset = BN_CTX_POOL_SIZE - 1;
			p->current = p->current->prev;
			}
		else
			offset--;
		}
	}

@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d164 1
a164 1
		fprintf(stderr,"%03x ", item->vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);
d174 2
a175 2
			fprintf(stderr,"    ");
		fprintf(stderr,"^^^ ");
@


