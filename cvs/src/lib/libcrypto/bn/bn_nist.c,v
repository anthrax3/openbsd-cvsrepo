head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.6
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18;
locks; strict;
comment	@ * @;


1.18
date	2016.07.18.01.04.52;	author bcook;	state Exp;
branches;
next	1.17;
commitid	hKsRMLPOHpBA2Qxq;

1.17
date	2016.07.17.22.01.01;	author bcook;	state Exp;
branches;
next	1.16;
commitid	iKcrMPC9Y5Pp0Nw1;

1.16
date	2016.07.17.21.21.40;	author bcook;	state Exp;
branches;
next	1.15;
commitid	t4OR1ORmB0TiJOZ8;

1.15
date	2014.10.28.07.35.58;	author jsg;	state Exp;
branches;
next	1.14;
commitid	pi8qF4s0vNCGLEKv;

1.14
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.13;
commitid	yQEL1wOWIearrW15;

1.13
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.12;
commitid	id8dTrTMtnTn4fqt;

1.12
date	2014.07.09.16.06.13;	author miod;	state Exp;
branches;
next	1.11;
commitid	WBUBPtdvi23w6jGY;

1.11
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	mJUVYpkFBZ0Zv2bG;

1.10
date	2014.05.08.13.48.36;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.24.21.31.02;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.18.19.41.23;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.14.14.50.09;	author sthen;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.09.12.15.31;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.13.52;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2011.11.03.02.32.09;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.10.13.21.23.37;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.04.13.15.16.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.18
log
@don't mix code and decls, ok tedu@@
@
text
@/* $OpenBSD: bn_nist.c,v 1.17 2016/07/17 22:01:01 bcook Exp $ */
/*
 * Written by Nils Larsch for the OpenSSL project
 */
/* ====================================================================
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <machine/endian.h>

#include <stdint.h>
#include <string.h>

#include "bn_lcl.h"

#define BN_NIST_192_TOP	(192+BN_BITS2-1)/BN_BITS2
#define BN_NIST_224_TOP	(224+BN_BITS2-1)/BN_BITS2
#define BN_NIST_256_TOP	(256+BN_BITS2-1)/BN_BITS2
#define BN_NIST_384_TOP	(384+BN_BITS2-1)/BN_BITS2
#define BN_NIST_521_TOP	(521+BN_BITS2-1)/BN_BITS2

/* pre-computed tables are "carry-less" values of modulus*(i+1) */
#if BN_BITS2 == 64
static const BN_ULONG _nist_p_192[][BN_NIST_192_TOP] = {
	{0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFEULL, 0xFFFFFFFFFFFFFFFFULL},
	{0xFFFFFFFFFFFFFFFEULL, 0xFFFFFFFFFFFFFFFDULL, 0xFFFFFFFFFFFFFFFFULL},
	{0xFFFFFFFFFFFFFFFDULL, 0xFFFFFFFFFFFFFFFCULL, 0xFFFFFFFFFFFFFFFFULL}
};
static const BN_ULONG _nist_p_192_sqr[] = {
	0x0000000000000001ULL, 0x0000000000000002ULL, 0x0000000000000001ULL,
	0xFFFFFFFFFFFFFFFEULL, 0xFFFFFFFFFFFFFFFDULL, 0xFFFFFFFFFFFFFFFFULL
};
static const BN_ULONG _nist_p_224[][BN_NIST_224_TOP] = {
	{
		0x0000000000000001ULL, 0xFFFFFFFF00000000ULL,
		0xFFFFFFFFFFFFFFFFULL, 0x00000000FFFFFFFFULL
	},
	{
		0x0000000000000002ULL, 0xFFFFFFFE00000000ULL,
		0xFFFFFFFFFFFFFFFFULL, 0x00000001FFFFFFFFULL
	} /* this one is "carry-full" */
};
static const BN_ULONG _nist_p_224_sqr[] = {
	0x0000000000000001ULL, 0xFFFFFFFE00000000ULL,
	0xFFFFFFFFFFFFFFFFULL, 0x0000000200000000ULL,
	0x0000000000000000ULL, 0xFFFFFFFFFFFFFFFEULL,
	0xFFFFFFFFFFFFFFFFULL
};
static const BN_ULONG _nist_p_256[][BN_NIST_256_TOP] = {
	{
		0xFFFFFFFFFFFFFFFFULL, 0x00000000FFFFFFFFULL,
		0x0000000000000000ULL, 0xFFFFFFFF00000001ULL
	},
	{
		0xFFFFFFFFFFFFFFFEULL, 0x00000001FFFFFFFFULL,
		0x0000000000000000ULL, 0xFFFFFFFE00000002ULL
	},
	{
		0xFFFFFFFFFFFFFFFDULL, 0x00000002FFFFFFFFULL,
		0x0000000000000000ULL, 0xFFFFFFFD00000003ULL
	},
	{
		0xFFFFFFFFFFFFFFFCULL, 0x00000003FFFFFFFFULL,
		0x0000000000000000ULL, 0xFFFFFFFC00000004ULL
	},
	{
		0xFFFFFFFFFFFFFFFBULL, 0x00000004FFFFFFFFULL,
		0x0000000000000000ULL, 0xFFFFFFFB00000005ULL
	},
};
static const BN_ULONG _nist_p_256_sqr[] = {
	0x0000000000000001ULL, 0xFFFFFFFE00000000ULL,
	0xFFFFFFFFFFFFFFFFULL, 0x00000001FFFFFFFEULL,
	0x00000001FFFFFFFEULL, 0x00000001FFFFFFFEULL,
	0xFFFFFFFE00000001ULL, 0xFFFFFFFE00000002ULL
};
static const BN_ULONG _nist_p_384[][BN_NIST_384_TOP] = {
	{
		0x00000000FFFFFFFFULL, 0xFFFFFFFF00000000ULL,
		0xFFFFFFFFFFFFFFFEULL, 0xFFFFFFFFFFFFFFFFULL,
		0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL
	},
	{
		0x00000001FFFFFFFEULL, 0xFFFFFFFE00000000ULL,
		0xFFFFFFFFFFFFFFFDULL, 0xFFFFFFFFFFFFFFFFULL,
		0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL
	},
	{
		0x00000002FFFFFFFDULL, 0xFFFFFFFD00000000ULL,
		0xFFFFFFFFFFFFFFFCULL, 0xFFFFFFFFFFFFFFFFULL,
		0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL
	},
	{
		0x00000003FFFFFFFCULL, 0xFFFFFFFC00000000ULL,
		0xFFFFFFFFFFFFFFFBULL, 0xFFFFFFFFFFFFFFFFULL,
		0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL
	},
	{
		0x00000004FFFFFFFBULL, 0xFFFFFFFB00000000ULL,
		0xFFFFFFFFFFFFFFFAULL, 0xFFFFFFFFFFFFFFFFULL,
		0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL
	},
};
static const BN_ULONG _nist_p_384_sqr[] = {
	0xFFFFFFFE00000001ULL, 0x0000000200000000ULL, 0xFFFFFFFE00000000ULL,
	0x0000000200000000ULL, 0x0000000000000001ULL, 0x0000000000000000ULL,
	0x00000001FFFFFFFEULL, 0xFFFFFFFE00000000ULL, 0xFFFFFFFFFFFFFFFDULL,
	0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL
};
static const BN_ULONG _nist_p_521[] = {
	0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL, 0x00000000000001FFULL
};
static const BN_ULONG _nist_p_521_sqr[] = {
	0x0000000000000001ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0xFFFFFFFFFFFFFC00ULL,
	0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL, 0x000000000003FFFFULL
};
#elif BN_BITS2 == 32
static const BN_ULONG _nist_p_192[][BN_NIST_192_TOP] = {
	{
		0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFF,
		0xFFFFFFFF, 0xFFFFFFFF
	},
	{
		0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFD, 0xFFFFFFFF,
		0xFFFFFFFF, 0xFFFFFFFF
	},
	{
		0xFFFFFFFD, 0xFFFFFFFF, 0xFFFFFFFC, 0xFFFFFFFF,
		0xFFFFFFFF, 0xFFFFFFFF
	}
};
static const BN_ULONG _nist_p_192_sqr[] = {
	0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x00000000,
	0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
};
static const BN_ULONG _nist_p_224[][BN_NIST_224_TOP] = {
	{
		0x00000001, 0x00000000, 0x00000000, 0xFFFFFFFF,
		0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
	},
	{
		0x00000002, 0x00000000, 0x00000000, 0xFFFFFFFE,
		0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
	}
};
static const BN_ULONG _nist_p_224_sqr[] = {
	0x00000001, 0x00000000, 0x00000000, 0xFFFFFFFE,
	0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x00000002,
	0x00000000, 0x00000000, 0xFFFFFFFE, 0xFFFFFFFF,
	0xFFFFFFFF, 0xFFFFFFFF
};
static const BN_ULONG _nist_p_256[][BN_NIST_256_TOP] = {
	{
		0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000,
		0x00000000, 0x00000000, 0x00000001, 0xFFFFFFFF
	},
	{
		0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000001,
		0x00000000, 0x00000000, 0x00000002, 0xFFFFFFFE
	},
	{
		0xFFFFFFFD, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000002,
		0x00000000, 0x00000000, 0x00000003, 0xFFFFFFFD
	},
	{
		0xFFFFFFFC, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000003,
		0x00000000, 0x00000000, 0x00000004, 0xFFFFFFFC
	},
	{
		0xFFFFFFFB, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000004,
		0x00000000, 0x00000000, 0x00000005, 0xFFFFFFFB
	},
};
static const BN_ULONG _nist_p_256_sqr[] = {
	0x00000001, 0x00000000, 0x00000000, 0xFFFFFFFE,
	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0x00000001,
	0xFFFFFFFE, 0x00000001, 0xFFFFFFFE, 0x00000001,
	0x00000001, 0xFFFFFFFE, 0x00000002, 0xFFFFFFFE
};
static const BN_ULONG _nist_p_384[][BN_NIST_384_TOP] = {
	{
		0xFFFFFFFF, 0x00000000, 0x00000000, 0xFFFFFFFF,
		0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
		0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
	},
	{
		0xFFFFFFFE, 0x00000001, 0x00000000, 0xFFFFFFFE,
		0xFFFFFFFD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
		0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
	},
	{
		0xFFFFFFFD, 0x00000002, 0x00000000, 0xFFFFFFFD,
		0xFFFFFFFC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
		0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
	},
	{
		0xFFFFFFFC, 0x00000003, 0x00000000, 0xFFFFFFFC,
		0xFFFFFFFB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
		0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
	},
	{
		0xFFFFFFFB, 0x00000004, 0x00000000, 0xFFFFFFFB,
		0xFFFFFFFA, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
		0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
	},
};
static const BN_ULONG _nist_p_384_sqr[] = {
	0x00000001, 0xFFFFFFFE, 0x00000000, 0x00000002, 0x00000000, 0xFFFFFFFE,
	0x00000000, 0x00000002, 0x00000001, 0x00000000, 0x00000000, 0x00000000,
	0xFFFFFFFE, 0x00000001, 0x00000000, 0xFFFFFFFE, 0xFFFFFFFD, 0xFFFFFFFF,
	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
};
static const BN_ULONG _nist_p_521[] = {
	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
	0xFFFFFFFF, 0x000001FF
};
static const BN_ULONG _nist_p_521_sqr[] = {
	0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFFFFFC00, 0xFFFFFFFF,
	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
	0xFFFFFFFF, 0xFFFFFFFF, 0x0003FFFF
};
#else
#error "unsupported BN_BITS2"
#endif

static const BIGNUM _bignum_nist_p_192 = {
	(BN_ULONG *)_nist_p_192[0],
	BN_NIST_192_TOP,
	BN_NIST_192_TOP,
	0,
	BN_FLG_STATIC_DATA
};

static const BIGNUM _bignum_nist_p_224 = {
	(BN_ULONG *)_nist_p_224[0],
	BN_NIST_224_TOP,
	BN_NIST_224_TOP,
	0,
	BN_FLG_STATIC_DATA
};

static const BIGNUM _bignum_nist_p_256 = {
	(BN_ULONG *)_nist_p_256[0],
	BN_NIST_256_TOP,
	BN_NIST_256_TOP,
	0,
	BN_FLG_STATIC_DATA
};

static const BIGNUM _bignum_nist_p_384 = {
	(BN_ULONG *)_nist_p_384[0],
	BN_NIST_384_TOP,
	BN_NIST_384_TOP,
	0,
	BN_FLG_STATIC_DATA
};

static const BIGNUM _bignum_nist_p_521 = {
	(BN_ULONG *)_nist_p_521,
	BN_NIST_521_TOP,
	BN_NIST_521_TOP,
	0,
	BN_FLG_STATIC_DATA
};


const BIGNUM *
BN_get0_nist_prime_192(void)
{
	return &_bignum_nist_p_192;
}

const BIGNUM *
BN_get0_nist_prime_224(void)
{
	return &_bignum_nist_p_224;
}

const BIGNUM *
BN_get0_nist_prime_256(void)
{
	return &_bignum_nist_p_256;
}

const BIGNUM *
BN_get0_nist_prime_384(void)
{
	return &_bignum_nist_p_384;
}

const BIGNUM *
BN_get0_nist_prime_521(void)
{
	return &_bignum_nist_p_521;
}

static void
nist_cp_bn_0(BN_ULONG *dst, const BN_ULONG *src, int top, int max)
{
	int i;

#ifdef BN_DEBUG
	OPENSSL_assert(top <= max);
#endif
	for (i = 0; i < top; i++)
		dst[i] = src[i];
	for (; i < max; i++)
		dst[i] = 0;
}

static void nist_cp_bn(BN_ULONG *dst, const BN_ULONG *src, int top)
{
	int i;

	for (i = 0; i < top; i++)
		dst[i] = src[i];
}

#if BN_BITS2 == 64
#define bn_cp_64(to, n, from, m)	(to)[n] = (m>=0)?((from)[m]):0;
#define bn_64_set_0(to, n)		(to)[n] = (BN_ULONG)0;
/*
 * two following macros are implemented under assumption that they
 * are called in a sequence with *ascending* n, i.e. as they are...
 */
#define bn_cp_32_naked(to, n, from, m)	(((n)&1)?(to[(n)/2]|=((m)&1)?(from[(m)/2]&BN_MASK2h):(from[(m)/2]<<32))\
						:(to[(n)/2] =((m)&1)?(from[(m)/2]>>32):(from[(m)/2]&BN_MASK2l)))
#define bn_32_set_0(to, n)		(((n)&1)?(to[(n)/2]&=BN_MASK2l):(to[(n)/2]=0));
#define bn_cp_32(to,n,from,m)		((m)>=0)?bn_cp_32_naked(to,n,from,m):bn_32_set_0(to,n)
# if BYTE_ORDER == LITTLE_ENDIAN
#  if defined(_LP64)
#   define NIST_INT64 long
#  else
#   define NIST_INT64 long long
#  endif
# endif
#else
#define bn_cp_64(to, n, from, m) \
	{ \
	bn_cp_32(to, (n)*2, from, (m)*2); \
	bn_cp_32(to, (n)*2+1, from, (m)*2+1); \
	}
#define bn_64_set_0(to, n) \
	{ \
	bn_32_set_0(to, (n)*2); \
	bn_32_set_0(to, (n)*2+1); \
	}
#define bn_cp_32(to, n, from, m)	(to)[n] = (m>=0)?((from)[m]):0;
#define bn_32_set_0(to, n)		(to)[n] = (BN_ULONG)0;
# if defined(BN_LLONG)
#  define NIST_INT64 long long
# endif
#endif /* BN_BITS2 != 64 */

#define nist_set_192(to, from, a1, a2, a3) \
	{ \
	bn_cp_64(to, 0, from, (a3) - 3) \
	bn_cp_64(to, 1, from, (a2) - 3) \
	bn_cp_64(to, 2, from, (a1) - 3) \
	}

int
BN_nist_mod_192(BIGNUM *r, const BIGNUM *a, const BIGNUM *field, BN_CTX *ctx)
{
	int top = a->top, i;
	int carry;
	BN_ULONG *r_d, *a_d = a->d;
	union {
		BN_ULONG bn[BN_NIST_192_TOP];
		unsigned int ui[BN_NIST_192_TOP *
		    sizeof(BN_ULONG) / sizeof(unsigned int)];
	} buf;
	BN_ULONG c_d[BN_NIST_192_TOP], *res;
	uintptr_t mask;
	static const BIGNUM _bignum_nist_p_192_sqr = {
		(BN_ULONG *)_nist_p_192_sqr,
		sizeof(_nist_p_192_sqr) / sizeof(_nist_p_192_sqr[0]),
		sizeof(_nist_p_192_sqr) / sizeof(_nist_p_192_sqr[0]),
		0,
		BN_FLG_STATIC_DATA
	};

	field = &_bignum_nist_p_192; /* just to make sure */

	if (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_192_sqr) >= 0)
		return BN_nnmod(r, a, field, ctx);

	i = BN_ucmp(field, a);
	if (i == 0) {
		BN_zero(r);
		return 1;
	} else if (i > 0)
		return (r == a) ? 1 : (BN_copy(r , a) != NULL);

	if (r != a) {
		if (!bn_wexpand(r, BN_NIST_192_TOP))
			return 0;
		r_d = r->d;
		nist_cp_bn(r_d, a_d, BN_NIST_192_TOP);
	} else
		r_d = a_d;

	nist_cp_bn_0(buf.bn, a_d + BN_NIST_192_TOP, top - BN_NIST_192_TOP,
	    BN_NIST_192_TOP);

#if defined(NIST_INT64)
	{
		NIST_INT64 acc;	/* accumulator */
		unsigned int *rp = (unsigned int *)r_d;
		const unsigned int *bp = (const unsigned int *)buf.ui;

		acc = rp[0];
		acc += bp[3 * 2 - 6];
		acc += bp[5 * 2 - 6];
		rp[0] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[1];
		acc += bp[3 * 2 - 5];
		acc += bp[5 * 2 - 5];
		rp[1] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[2];
		acc += bp[3 * 2 - 6];
		acc += bp[4 * 2 - 6];
		acc += bp[5 * 2 - 6];
		rp[2] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[3];
		acc += bp[3 * 2 - 5];
		acc += bp[4 * 2 - 5];
		acc += bp[5 * 2 - 5];
		rp[3] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[4];
		acc += bp[4 * 2 - 6];
		acc += bp[5 * 2 - 6];
		rp[4] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[5];
		acc += bp[4 * 2 - 5];
		acc += bp[5 * 2 - 5];
		rp[5] = (unsigned int)acc;

		carry = (int)(acc >> 32);
	}
#else
	{
		BN_ULONG t_d[BN_NIST_192_TOP] = {0};

		nist_set_192(t_d, buf.bn, 0, 3, 3);
		carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);
		nist_set_192(t_d, buf.bn, 4, 4, 0);
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);
		nist_set_192(t_d, buf.bn, 5, 5, 5)
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);
	}
#endif
	if (carry > 0)
		carry = (int)bn_sub_words(r_d, r_d, _nist_p_192[carry - 1],
		    BN_NIST_192_TOP);
	else
		carry = 1;

	/*
	 * we need 'if (carry==0 || result>=modulus) result-=modulus;'
	 * as comparison implies subtraction, we can write
	 * 'tmp=result-modulus; if (!carry || !borrow) result=tmp;'
	 * this is what happens below, but without explicit if:-) a.
	 */
	mask = 0 - (uintptr_t)bn_sub_words(c_d, r_d, _nist_p_192[0],
	    BN_NIST_192_TOP);
	mask &= 0 - (uintptr_t)carry;
	res = c_d;
	res = (BN_ULONG *)(((uintptr_t)res & ~mask) | ((uintptr_t)r_d & mask));
	nist_cp_bn(r_d, res, BN_NIST_192_TOP);
	r->top = BN_NIST_192_TOP;
	bn_correct_top(r);

	return 1;
}

typedef BN_ULONG (*bn_addsub_f)(BN_ULONG *, const BN_ULONG *,
    const BN_ULONG *, int);

#define nist_set_224(to, from, a1, a2, a3, a4, a5, a6, a7) \
	{ \
	bn_cp_32(to, 0, from, (a7) - 7) \
	bn_cp_32(to, 1, from, (a6) - 7) \
	bn_cp_32(to, 2, from, (a5) - 7) \
	bn_cp_32(to, 3, from, (a4) - 7) \
	bn_cp_32(to, 4, from, (a3) - 7) \
	bn_cp_32(to, 5, from, (a2) - 7) \
	bn_cp_32(to, 6, from, (a1) - 7) \
	}

int
BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field, BN_CTX *ctx)
{
	int top = a->top, i;
	int carry;
	BN_ULONG *r_d, *a_d = a->d;
	union {
		BN_ULONG bn[BN_NIST_224_TOP];
		unsigned int ui[BN_NIST_224_TOP *
		    sizeof(BN_ULONG) / sizeof(unsigned int)];
	} buf;
	BN_ULONG c_d[BN_NIST_224_TOP], *res;
	uintptr_t mask;
	union {
		bn_addsub_f f;
		uintptr_t p;
	} u;
	static const BIGNUM _bignum_nist_p_224_sqr = {
		(BN_ULONG *)_nist_p_224_sqr,
		sizeof(_nist_p_224_sqr) / sizeof(_nist_p_224_sqr[0]),
		sizeof(_nist_p_224_sqr) / sizeof(_nist_p_224_sqr[0]),
		0,
		BN_FLG_STATIC_DATA
	};

	field = &_bignum_nist_p_224; /* just to make sure */

	if (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_224_sqr) >= 0)
		return BN_nnmod(r, a, field, ctx);

	i = BN_ucmp(field, a);
	if (i == 0) {
		BN_zero(r);
		return 1;
	} else if (i > 0)
		return (r == a) ? 1 : (BN_copy(r, a) != NULL);

	if (r != a) {
		if (!bn_wexpand(r, BN_NIST_224_TOP))
			return 0;
		r_d = r->d;
		nist_cp_bn(r_d, a_d, BN_NIST_224_TOP);
	} else
		r_d = a_d;

	memset(&buf, 0, sizeof(buf));

#if BN_BITS2==64
	/* copy upper 256 bits of 448 bit number ... */
	nist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP - 1),
	    top - (BN_NIST_224_TOP - 1), BN_NIST_224_TOP);
	/* ... and right shift by 32 to obtain upper 224 bits */
	nist_set_224(buf.bn, c_d, 14, 13, 12, 11, 10, 9, 8);
	/* truncate lower part to 224 bits too */
	r_d[BN_NIST_224_TOP - 1] &= BN_MASK2l;
#else
	nist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP,
	    top - BN_NIST_224_TOP, BN_NIST_224_TOP);
#endif

#if defined(NIST_INT64) && BN_BITS2!=64
	{
		NIST_INT64 acc;	/* accumulator */
		unsigned int *rp = (unsigned int *)r_d;
		const unsigned int *bp = (const unsigned int *)buf.ui;

		acc = rp[0];
		acc -= bp[7 - 7];
		acc -= bp[11 - 7];
		rp[0] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[1];
		acc -= bp[8 - 7];
		acc -= bp[12 - 7];
		rp[1] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[2];
		acc -= bp[9 - 7];
		acc -= bp[13 - 7];
		rp[2] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[3];
		acc += bp[7 - 7];
		acc += bp[11 - 7];
		acc -= bp[10 - 7];
		rp[3] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[4];
		acc += bp[8 - 7];
		acc += bp[12 - 7];
		acc -= bp[11 - 7];
		rp[4] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[5];
		acc += bp[9 - 7];
		acc += bp[13 - 7];
		acc -= bp[12 - 7];
		rp[5] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[6];
		acc += bp[10 - 7];
		acc -= bp[13 - 7];
		rp[6] = (unsigned int)acc;

		carry = (int)(acc >> 32);
# if BN_BITS2==64
		rp[7] = carry;
# endif
	}
#else
	{
		BN_ULONG t_d[BN_NIST_224_TOP] = {0};

		nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);
		carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);
		nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);
		nist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);
		carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);
		nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);
		carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);

#if BN_BITS2==64
		carry = (int)(r_d[BN_NIST_224_TOP - 1] >> 32);
#endif
	}
#endif
	u.f = bn_sub_words;
	if (carry > 0) {
		carry = (int)bn_sub_words(r_d, r_d, _nist_p_224[carry - 1],
		    BN_NIST_224_TOP);
#if BN_BITS2==64
		carry = (int)(~(r_d[BN_NIST_224_TOP - 1] >> 32)) & 1;
#endif
	} else if (carry < 0) {
		/* it's a bit more complicated logic in this case.
		 * if bn_add_words yields no carry, then result
		 * has to be adjusted by unconditionally *adding*
		 * the modulus. but if it does, then result has
		 * to be compared to the modulus and conditionally
		 * adjusted by *subtracting* the latter. */
		carry = (int)bn_add_words(r_d, r_d, _nist_p_224[-carry - 1],
		    BN_NIST_224_TOP);
		mask = 0 - (uintptr_t)carry;
		u.p = ((uintptr_t)bn_sub_words & mask) |
		    ((uintptr_t)bn_add_words & ~mask);
	} else
		carry = 1;

	/* otherwise it's effectively same as in BN_nist_mod_192... */
	mask = 0 - (uintptr_t)(*u.f)(c_d, r_d, _nist_p_224[0], BN_NIST_224_TOP);
	mask &= 0 - (uintptr_t)carry;
	res = c_d;
	res = (BN_ULONG *)(((uintptr_t)res & ~mask) | ((uintptr_t)r_d & mask));
	nist_cp_bn(r_d, res, BN_NIST_224_TOP);
	r->top = BN_NIST_224_TOP;
	bn_correct_top(r);

	return 1;
}

#define nist_set_256(to, from, a1, a2, a3, a4, a5, a6, a7, a8) \
	{ \
	bn_cp_32(to, 0, from, (a8) - 8) \
	bn_cp_32(to, 1, from, (a7) - 8) \
	bn_cp_32(to, 2, from, (a6) - 8) \
	bn_cp_32(to, 3, from, (a5) - 8) \
	bn_cp_32(to, 4, from, (a4) - 8) \
	bn_cp_32(to, 5, from, (a3) - 8) \
	bn_cp_32(to, 6, from, (a2) - 8) \
	bn_cp_32(to, 7, from, (a1) - 8) \
	}

int
BN_nist_mod_256(BIGNUM *r, const BIGNUM *a, const BIGNUM *field, BN_CTX *ctx)
{
	int i, top = a->top;
	int carry = 0;
	BN_ULONG *a_d = a->d, *r_d;
	union {
		BN_ULONG bn[BN_NIST_256_TOP];
		unsigned int ui[BN_NIST_256_TOP *
		    sizeof(BN_ULONG) / sizeof(unsigned int)];
	} buf;
	BN_ULONG c_d[BN_NIST_256_TOP] = {0}, *res;
	uintptr_t mask;
	union {
		bn_addsub_f f;
		uintptr_t p;
	} u;
	static const BIGNUM _bignum_nist_p_256_sqr = {
		(BN_ULONG *)_nist_p_256_sqr,
		sizeof(_nist_p_256_sqr) / sizeof(_nist_p_256_sqr[0]),
		sizeof(_nist_p_256_sqr) / sizeof(_nist_p_256_sqr[0]),
		0,
		BN_FLG_STATIC_DATA
	};

	field = &_bignum_nist_p_256; /* just to make sure */

	if (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_256_sqr) >= 0)
		return BN_nnmod(r, a, field, ctx);

	i = BN_ucmp(field, a);
	if (i == 0) {
		BN_zero(r);
		return 1;
	} else if (i > 0)
		return (r == a) ? 1 : (BN_copy(r, a) != NULL);

	if (r != a) {
		if (!bn_wexpand(r, BN_NIST_256_TOP))
			return 0;
		r_d = r->d;
		nist_cp_bn(r_d, a_d, BN_NIST_256_TOP);
	} else
		r_d = a_d;

	nist_cp_bn_0(buf.bn, a_d + BN_NIST_256_TOP,
	    top - BN_NIST_256_TOP, BN_NIST_256_TOP);

#if defined(NIST_INT64)
	{
		NIST_INT64 acc;	/* accumulator */
		unsigned int *rp = (unsigned int *)r_d;
		const unsigned int *bp = (const unsigned int *)buf.ui;

		acc = rp[0];
		acc += bp[8 - 8];
		acc += bp[9 - 8];
		acc -= bp[11 - 8];
		acc -= bp[12 - 8];
		acc -= bp[13 - 8];
		acc -= bp[14 - 8];
		rp[0] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[1];
		acc += bp[9 - 8];
		acc += bp[10 - 8];
		acc -= bp[12 - 8];
		acc -= bp[13 - 8];
		acc -= bp[14 - 8];
		acc -= bp[15 - 8];
		rp[1] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[2];
		acc += bp[10 - 8];
		acc += bp[11 - 8];
		acc -= bp[13 - 8];
		acc -= bp[14 - 8];
		acc -= bp[15 - 8];
		rp[2] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[3];
		acc += bp[11 - 8];
		acc += bp[11 - 8];
		acc += bp[12 - 8];
		acc += bp[12 - 8];
		acc += bp[13 - 8];
		acc -= bp[15 - 8];
		acc -= bp[8 - 8];
		acc -= bp[9 - 8];
		rp[3] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[4];
		acc += bp[12 - 8];
		acc += bp[12 - 8];
		acc += bp[13 - 8];
		acc += bp[13 - 8];
		acc += bp[14 - 8];
		acc -= bp[9 - 8];
		acc -= bp[10 - 8];
		rp[4] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[5];
		acc += bp[13 - 8];
		acc += bp[13 - 8];
		acc += bp[14 - 8];
		acc += bp[14 - 8];
		acc += bp[15 - 8];
		acc -= bp[10 - 8];
		acc -= bp[11 - 8];
		rp[5] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[6];
		acc += bp[14 - 8];
		acc += bp[14 - 8];
		acc += bp[15 - 8];
		acc += bp[15 - 8];
		acc += bp[14 - 8];
		acc += bp[13 - 8];
		acc -= bp[8 - 8];
		acc -= bp[9 - 8];
		rp[6] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[7];
		acc += bp[15 - 8];
		acc += bp[15 - 8];
		acc += bp[15 - 8];
		acc += bp[8 - 8];
		acc -= bp[10 - 8];
		acc -= bp[11 - 8];
		acc -= bp[12 - 8];
		acc -= bp[13 - 8];
		rp[7] = (unsigned int)acc;

		carry = (int)(acc >> 32);
	}
#else
	{
		BN_ULONG t_d[BN_NIST_256_TOP] = {0};

		/*S1*/
		nist_set_256(t_d, buf.bn, 15, 14, 13, 12, 11, 0, 0, 0);
		/*S2*/
		nist_set_256(c_d, buf.bn, 0, 15, 14, 13, 12, 0, 0, 0);
		carry = (int)bn_add_words(t_d, t_d, c_d, BN_NIST_256_TOP);
		/* left shift */
		{
			BN_ULONG *ap, t, c;
			ap = t_d;
			c = 0;
			for (i = BN_NIST_256_TOP; i != 0; --i) {
				t = *ap;
				*(ap++) = ((t << 1) | c) & BN_MASK2;
				c = (t & BN_TBIT) ? 1 : 0;
			}
			carry <<= 1;
			carry |= c;
		}
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);
		/*S3*/
		nist_set_256(t_d, buf.bn, 15, 14, 0, 0, 0, 10, 9, 8);
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);
		/*S4*/
		nist_set_256(t_d, buf.bn, 8, 13, 15, 14, 13, 11, 10, 9);
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);
		/*D1*/
		nist_set_256(t_d, buf.bn, 10, 8, 0, 0, 0, 13, 12, 11);
		carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
		/*D2*/
		nist_set_256(t_d, buf.bn, 11, 9, 0, 0, 15, 14, 13, 12);
		carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
		/*D3*/
		nist_set_256(t_d, buf.bn, 12, 0, 10, 9, 8, 15, 14, 13);
		carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
		/*D4*/
		nist_set_256(t_d, buf.bn, 13, 0, 11, 10, 9, 0, 15, 14);
		carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);

	}
#endif
	/* see BN_nist_mod_224 for explanation */
	u.f = bn_sub_words;
	if (carry > 0)
		carry = (int)bn_sub_words(r_d, r_d, _nist_p_256[carry - 1],
		    BN_NIST_256_TOP);
	else if (carry < 0) {
		carry = (int)bn_add_words(r_d, r_d, _nist_p_256[-carry - 1],
		    BN_NIST_256_TOP);
		mask = 0 - (uintptr_t)carry;
		u.p = ((uintptr_t)bn_sub_words & mask) |
		    ((uintptr_t)bn_add_words & ~mask);
	} else
		carry = 1;

	mask = 0 - (uintptr_t)(*u.f)(c_d, r_d, _nist_p_256[0], BN_NIST_256_TOP);
	mask &= 0 - (uintptr_t)carry;
	res = c_d;
	res = (BN_ULONG *)(((uintptr_t)res & ~mask) | ((uintptr_t)r_d & mask));
	nist_cp_bn(r_d, res, BN_NIST_256_TOP);
	r->top = BN_NIST_256_TOP;
	bn_correct_top(r);

	return 1;
}

#define nist_set_384(to,from,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
	{ \
	bn_cp_32(to, 0, from,  (a12) - 12) \
	bn_cp_32(to, 1, from,  (a11) - 12) \
	bn_cp_32(to, 2, from,  (a10) - 12) \
	bn_cp_32(to, 3, from,  (a9) - 12)  \
	bn_cp_32(to, 4, from,  (a8) - 12)  \
	bn_cp_32(to, 5, from,  (a7) - 12)  \
	bn_cp_32(to, 6, from,  (a6) - 12)  \
	bn_cp_32(to, 7, from,  (a5) - 12)  \
	bn_cp_32(to, 8, from,  (a4) - 12)  \
	bn_cp_32(to, 9, from,  (a3) - 12)  \
	bn_cp_32(to, 10, from, (a2) - 12)  \
	bn_cp_32(to, 11, from, (a1) - 12)  \
	}

int
BN_nist_mod_384(BIGNUM *r, const BIGNUM *a, const BIGNUM *field, BN_CTX *ctx)
{
	int i, top = a->top;
	int carry = 0;
	BN_ULONG *r_d, *a_d = a->d;
	union {
		BN_ULONG bn[BN_NIST_384_TOP];
		unsigned int ui[BN_NIST_384_TOP *
		    sizeof(BN_ULONG) / sizeof(unsigned int)];
	} buf;
	BN_ULONG c_d[BN_NIST_384_TOP], *res;
	uintptr_t mask;
	union {
		bn_addsub_f f;
		uintptr_t p;
	} u;
	static const BIGNUM _bignum_nist_p_384_sqr = {
		(BN_ULONG *)_nist_p_384_sqr,
		sizeof(_nist_p_384_sqr) / sizeof(_nist_p_384_sqr[0]),
		sizeof(_nist_p_384_sqr) / sizeof(_nist_p_384_sqr[0]),
		0,
		BN_FLG_STATIC_DATA
	};

	field = &_bignum_nist_p_384; /* just to make sure */

	if (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_384_sqr) >= 0)
		return BN_nnmod(r, a, field, ctx);

	i = BN_ucmp(field, a);
	if (i == 0) {
		BN_zero(r);
		return 1;
	} else if (i > 0)
		return (r == a) ? 1 : (BN_copy(r, a) != NULL);

	if (r != a) {
		if (!bn_wexpand(r, BN_NIST_384_TOP))
			return 0;
		r_d = r->d;
		nist_cp_bn(r_d, a_d, BN_NIST_384_TOP);
	} else
		r_d = a_d;

	nist_cp_bn_0(buf.bn, a_d + BN_NIST_384_TOP,
	    top - BN_NIST_384_TOP, BN_NIST_384_TOP);

#if defined(NIST_INT64)
	{
		NIST_INT64 acc;	/* accumulator */
		unsigned int *rp = (unsigned int *)r_d;
		const unsigned int *bp = (const unsigned int *)buf.ui;

		acc = rp[0];
		acc += bp[12 - 12];
		acc += bp[21 - 12];
		acc += bp[20 - 12];
		acc -= bp[23 - 12];
		rp[0] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[1];
		acc += bp[13 - 12];
		acc += bp[22 - 12];
		acc += bp[23 - 12];
		acc -= bp[12 - 12];
		acc -= bp[20 - 12];
		rp[1] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[2];
		acc += bp[14 - 12];
		acc += bp[23 - 12];
		acc -= bp[13 - 12];
		acc -= bp[21 - 12];
		rp[2] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[3];
		acc += bp[15 - 12];
		acc += bp[12 - 12];
		acc += bp[20 - 12];
		acc += bp[21 - 12];
		acc -= bp[14 - 12];
		acc -= bp[22 - 12];
		acc -= bp[23 - 12];
		rp[3] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[4];
		acc += bp[21 - 12];
		acc += bp[21 - 12];
		acc += bp[16 - 12];
		acc += bp[13 - 12];
		acc += bp[12 - 12];
		acc += bp[20 - 12];
		acc += bp[22 - 12];
		acc -= bp[15 - 12];
		acc -= bp[23 - 12];
		acc -= bp[23 - 12];
		rp[4] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[5];
		acc += bp[22 - 12];
		acc += bp[22 - 12];
		acc += bp[17 - 12];
		acc += bp[14 - 12];
		acc += bp[13 - 12];
		acc += bp[21 - 12];
		acc += bp[23 - 12];
		acc -= bp[16 - 12];
		rp[5] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[6];
		acc += bp[23 - 12];
		acc += bp[23 - 12];
		acc += bp[18 - 12];
		acc += bp[15 - 12];
		acc += bp[14 - 12];
		acc += bp[22 - 12];
		acc -= bp[17 - 12];
		rp[6] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[7];
		acc += bp[19 - 12];
		acc += bp[16 - 12];
		acc += bp[15 - 12];
		acc += bp[23 - 12];
		acc -= bp[18 - 12];
		rp[7] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[8];
		acc += bp[20 - 12];
		acc += bp[17 - 12];
		acc += bp[16 - 12];
		acc -= bp[19 - 12];
		rp[8] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[9];
		acc += bp[21 - 12];
		acc += bp[18 - 12];
		acc += bp[17 - 12];
		acc -= bp[20 - 12];
		rp[9] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[10];
		acc += bp[22 - 12];
		acc += bp[19 - 12];
		acc += bp[18 - 12];
		acc -= bp[21 - 12];
		rp[10] = (unsigned int)acc;
		acc >>= 32;

		acc += rp[11];
		acc += bp[23 - 12];
		acc += bp[20 - 12];
		acc += bp[19 - 12];
		acc -= bp[22 - 12];
		rp[11] = (unsigned int)acc;

		carry = (int)(acc >> 32);
	}
#else
	{
		BN_ULONG t_d[BN_NIST_384_TOP] = {0};

		/*S1*/
		nist_set_256(t_d, buf.bn, 0, 0, 0, 0, 0, 23 - 4, 22 - 4,
		    21 - 4);
		/* left shift */
		{
			BN_ULONG *ap, t, c;
			ap = t_d;
			c = 0;
			for (i = 3; i != 0; --i) {
				t= *ap;
				*(ap++) = ((t << 1)|c) & BN_MASK2;
				c = (t & BN_TBIT) ? 1 : 0;
			}
			*ap = c;
		}
		carry = (int)bn_add_words(r_d + (128 / BN_BITS2),
		    r_d + (128 / BN_BITS2), t_d, BN_NIST_256_TOP);
		/*S2 */
		carry += (int)bn_add_words(r_d, r_d, buf.bn, BN_NIST_384_TOP);
		/*S3*/
		nist_set_384(t_d, buf.bn, 20, 19, 18, 17, 16, 15, 14, 13, 12,
		    23, 22, 21);
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
		/*S4*/
		nist_set_384(t_d, buf.bn, 19, 18, 17, 16, 15, 14, 13, 12, 20,
		    0, 23, 0);
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
		/*S5*/
		nist_set_384(t_d, buf.bn, 0,0, 0,0, 23, 22, 21, 20, 0,0, 0, 0);
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
		/*S6*/
		nist_set_384(t_d, buf.bn, 0,0, 0,0, 0,0, 23, 22, 21, 0,0, 20);
		carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
		/*D1*/
		nist_set_384(t_d, buf.bn, 22, 21, 20, 19, 18, 17, 16, 15, 14,
		    13, 12, 23);
		carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);
		/*D2*/
		nist_set_384(t_d, buf.bn, 0,0, 0,0, 0,0, 0,23, 22, 21, 20, 0);
		carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);
		/*D3*/
		nist_set_384(t_d, buf.bn, 0,0, 0,0, 0,0, 0,23, 23, 0,0, 0);
		carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);

	}
#endif
	/* see BN_nist_mod_224 for explanation */
	u.f = bn_sub_words;
	if (carry > 0)
		carry = (int)bn_sub_words(r_d, r_d, _nist_p_384[carry - 1],
		    BN_NIST_384_TOP);
	else if (carry < 0) {
		carry = (int)bn_add_words(r_d, r_d, _nist_p_384[-carry - 1],
		    BN_NIST_384_TOP);
		mask = 0 - (uintptr_t)carry;
		u.p = ((uintptr_t)bn_sub_words & mask) |
		    ((uintptr_t)bn_add_words & ~mask);
	} else
		carry = 1;

	mask = 0 - (uintptr_t)(*u.f)(c_d, r_d, _nist_p_384[0], BN_NIST_384_TOP);
	mask &= 0 - (uintptr_t)carry;
	res = c_d;
	res = (BN_ULONG *)(((uintptr_t)res & ~mask) | ((uintptr_t)r_d & mask));
	nist_cp_bn(r_d, res, BN_NIST_384_TOP);
	r->top = BN_NIST_384_TOP;
	bn_correct_top(r);

	return 1;
}

#define BN_NIST_521_RSHIFT	(521%BN_BITS2)
#define BN_NIST_521_LSHIFT	(BN_BITS2-BN_NIST_521_RSHIFT)
#define BN_NIST_521_TOP_MASK	((BN_ULONG)BN_MASK2>>BN_NIST_521_LSHIFT)

int
BN_nist_mod_521(BIGNUM *r, const BIGNUM *a, const BIGNUM *field, BN_CTX *ctx)
{
	int top = a->top, i;
	BN_ULONG *r_d, *a_d = a->d, t_d[BN_NIST_521_TOP], val, tmp, *res;
	uintptr_t mask;
	static const BIGNUM _bignum_nist_p_521_sqr = {
		(BN_ULONG *)_nist_p_521_sqr,
		sizeof(_nist_p_521_sqr) / sizeof(_nist_p_521_sqr[0]),
		sizeof(_nist_p_521_sqr) / sizeof(_nist_p_521_sqr[0]),
		0,
		BN_FLG_STATIC_DATA
	};

	field = &_bignum_nist_p_521; /* just to make sure */

	if (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_521_sqr) >= 0)
		return BN_nnmod(r, a, field, ctx);

	i = BN_ucmp(field, a);
	if (i == 0) {
		BN_zero(r);
		return 1;
	} else if (i > 0)
		return (r == a) ? 1 : (BN_copy(r, a) != NULL);

	if (r != a) {
		if (!bn_wexpand(r, BN_NIST_521_TOP))
			return 0;
		r_d = r->d;
		nist_cp_bn(r_d, a_d, BN_NIST_521_TOP);
	} else
		r_d = a_d;

	/* upper 521 bits, copy ... */
	nist_cp_bn_0(t_d, a_d + (BN_NIST_521_TOP - 1),
	    top - (BN_NIST_521_TOP - 1), BN_NIST_521_TOP);
	/* ... and right shift */
	for (val = t_d[0], i = 0; i < BN_NIST_521_TOP - 1; i++) {
		tmp = val >> BN_NIST_521_RSHIFT;
		val = t_d[i + 1];
		t_d[i] = (tmp | val << BN_NIST_521_LSHIFT) & BN_MASK2;
	}
	t_d[i] = val >> BN_NIST_521_RSHIFT;
	/* lower 521 bits */
	r_d[i] &= BN_NIST_521_TOP_MASK;

	bn_add_words(r_d, r_d, t_d, BN_NIST_521_TOP);
	mask = 0 - (uintptr_t)bn_sub_words(t_d, r_d, _nist_p_521,
	    BN_NIST_521_TOP);
	res = t_d;
	res = (BN_ULONG *)(((uintptr_t)res & ~mask) | ((uintptr_t)r_d & mask));
	nist_cp_bn(r_d, res, BN_NIST_521_TOP);
	r->top = BN_NIST_521_TOP;
	bn_correct_top(r);

	return 1;
}
@


1.17
log
@use memset to initialize the union
@
text
@d1 1
a1 1
/* $OpenBSD: bn_nist.c,v 1.16 2016/07/17 21:21:40 bcook Exp $ */
a572 1
	memset(&buf, 0, sizeof(buf));
d606 2
@


1.16
log
@Initialize buffers before use, noted by Kinichiro Inoguchi.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_nist.c,v 1.15 2014/10/28 07:35:58 jsg Exp $ */
d62 1
d572 2
a573 1
	} buf = {0};
@


1.15
log
@deregister; no binary change
ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_nist.c,v 1.14 2014/07/11 08:44:48 jsing Exp $ */
d513 1
a513 1
		BN_ULONG t_d[BN_NIST_192_TOP];
d571 1
a571 1
	} buf;
d676 1
a676 1
		BN_ULONG t_d[BN_NIST_224_TOP];
d749 1
a749 1
	BN_ULONG c_d[BN_NIST_256_TOP], *res;
d882 1
a882 1
		BN_ULONG t_d[BN_NIST_256_TOP];
d1136 1
a1136 1
		BN_ULONG t_d[BN_NIST_384_TOP];
@


1.14
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_nist.c,v 1.13 2014/07/10 13:58:22 jsing Exp $ */
d427 1
a427 1
	register BN_ULONG *r_d, *a_d = a->d;
d743 1
a743 1
	register BN_ULONG *a_d = a->d, *r_d;
d891 1
a891 1
			register BN_ULONG *ap, t, c;
d970 1
a970 1
	register BN_ULONG *r_d, *a_d = a->d;
d1143 1
a1143 1
			register BN_ULONG *ap, t, c;
@


1.13
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_nist.c,v 1.12 2014/07/09 16:06:13 miod Exp $ */
d59 2
a63 3
#include "cryptlib.h"

#include <machine/endian.h>
@


1.12
log
@Remove leading underscore from _BYTE_ORDER and _{LITTLE,BIG}_ENDIAN, to be
more friendly to systems where the underscore flavours may be defined as empty.
Found the hard way be bcook@@; joint brainstrom with bcook beck and guenther
@
text
@d1 1
a1 1
/* $OpenBSD: bn_nist.c,v 1.11 2014/06/12 15:49:28 deraadt Exp $ */
d59 2
a64 1

@


1.11
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d390 1
a390 1
# if _BYTE_ORDER == _LITTLE_ENDIAN
@


1.10
log
@knfectomie.
@
text
@d1 1
a1 1
/* crypto/bn/bn_nist.c */
@


1.9
log
@Try to clean the maze of <openssl/bn.h> defines regarding the BN internals.

The intent of this change is to only keep support for two kind of architectures:
- those with 32-bit int and long, and 64-bit long long, where
  ``long * long -> long long'' multiplication routines are available.
- those with 64-bit int and long, and no 128-bit long long type.

This gets rid of the SIXTY_FOUR_BIT_LONG, SIXTY_FOUR_BIT (not the same!),
THIRTY_TWO_BIT, SIXTEEN_BIT and EIGHT_BIT defines.

After this change, the types and defines are as follows:

arch:           64bit           32bit           rationale
BN_LLONG        undefined       defined         defined if l * l -> ll
BN_ULLONG       undefined       u long long     result of BN_LONG * BN_LONG
BN_ULONG        u long          u int           native register size
BN_LONG         long            int             the same, signed
BN_BITS         128             64              size of 2*BN_ULONG in bits
BN_BYTES        8               4               size of 2*BN_ULONG in bytes
BN_BITS2        64              32              BN_BITS / 2

Tested on various 32-bit and 64-bit OpenBSD systems of various endianness.
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d74 4
a77 4
	{0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFEULL,0xFFFFFFFFFFFFFFFFULL},
	{0xFFFFFFFFFFFFFFFEULL,0xFFFFFFFFFFFFFFFDULL,0xFFFFFFFFFFFFFFFFULL},
	{0xFFFFFFFFFFFFFFFDULL,0xFFFFFFFFFFFFFFFCULL,0xFFFFFFFFFFFFFFFFULL}
	};
d79 3
a81 3
	0x0000000000000001ULL,0x0000000000000002ULL,0x0000000000000001ULL,
	0xFFFFFFFFFFFFFFFEULL,0xFFFFFFFFFFFFFFFDULL,0xFFFFFFFFFFFFFFFFULL
	};
d83 9
a91 5
	{0x0000000000000001ULL,0xFFFFFFFF00000000ULL,
	 0xFFFFFFFFFFFFFFFFULL,0x00000000FFFFFFFFULL},
	{0x0000000000000002ULL,0xFFFFFFFE00000000ULL,
	 0xFFFFFFFFFFFFFFFFULL,0x00000001FFFFFFFFULL} /* this one is "carry-full" */
	};
d93 3
a95 3
	0x0000000000000001ULL,0xFFFFFFFE00000000ULL,
	0xFFFFFFFFFFFFFFFFULL,0x0000000200000000ULL,
	0x0000000000000000ULL,0xFFFFFFFFFFFFFFFEULL,
d97 1
a97 1
	};
d99 21
a119 11
	{0xFFFFFFFFFFFFFFFFULL,0x00000000FFFFFFFFULL,
	 0x0000000000000000ULL,0xFFFFFFFF00000001ULL},
	{0xFFFFFFFFFFFFFFFEULL,0x00000001FFFFFFFFULL,
	 0x0000000000000000ULL,0xFFFFFFFE00000002ULL},
	{0xFFFFFFFFFFFFFFFDULL,0x00000002FFFFFFFFULL,
	 0x0000000000000000ULL,0xFFFFFFFD00000003ULL},
	{0xFFFFFFFFFFFFFFFCULL,0x00000003FFFFFFFFULL,
	 0x0000000000000000ULL,0xFFFFFFFC00000004ULL},
	{0xFFFFFFFFFFFFFFFBULL,0x00000004FFFFFFFFULL,
	 0x0000000000000000ULL,0xFFFFFFFB00000005ULL},
	};
d121 5
a125 5
	0x0000000000000001ULL,0xFFFFFFFE00000000ULL,
	0xFFFFFFFFFFFFFFFFULL,0x00000001FFFFFFFEULL,
	0x00000001FFFFFFFEULL,0x00000001FFFFFFFEULL,
	0xFFFFFFFE00000001ULL,0xFFFFFFFE00000002ULL
	};
d127 26
a152 11
	{0x00000000FFFFFFFFULL,0xFFFFFFFF00000000ULL,0xFFFFFFFFFFFFFFFEULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	{0x00000001FFFFFFFEULL,0xFFFFFFFE00000000ULL,0xFFFFFFFFFFFFFFFDULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	{0x00000002FFFFFFFDULL,0xFFFFFFFD00000000ULL,0xFFFFFFFFFFFFFFFCULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	{0x00000003FFFFFFFCULL,0xFFFFFFFC00000000ULL,0xFFFFFFFFFFFFFFFBULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	{0x00000004FFFFFFFBULL,0xFFFFFFFB00000000ULL,0xFFFFFFFFFFFFFFFAULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	};
d154 10
a163 11
	0xFFFFFFFE00000001ULL,0x0000000200000000ULL,0xFFFFFFFE00000000ULL,
	0x0000000200000000ULL,0x0000000000000001ULL,0x0000000000000000ULL,
	0x00000001FFFFFFFEULL,0xFFFFFFFE00000000ULL,0xFFFFFFFFFFFFFFFDULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL
	};
static const BN_ULONG _nist_p_521[] =
	{0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,
	0x00000000000001FFULL};
d165 7
a171 7
	0x0000000000000001ULL,0x0000000000000000ULL,0x0000000000000000ULL,
	0x0000000000000000ULL,0x0000000000000000ULL,0x0000000000000000ULL,
	0x0000000000000000ULL,0x0000000000000000ULL,0xFFFFFFFFFFFFFC00ULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL,0x000000000003FFFFULL
	};
d174 13
a186 4
	{0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFD,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFD,0xFFFFFFFF,0xFFFFFFFC,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF}
	};
d188 3
a190 3
	0x00000001,0x00000000,0x00000002,0x00000000,0x00000001,0x00000000,
	0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFD,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF
	};
d192 9
a200 5
	{0x00000001,0x00000000,0x00000000,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0x00000002,0x00000000,0x00000000,0xFFFFFFFE,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF}
	};
d202 5
a206 5
	0x00000001,0x00000000,0x00000000,0xFFFFFFFE,
	0xFFFFFFFF,0xFFFFFFFF,0x00000000,0x00000002,
	0x00000000,0x00000000,0xFFFFFFFE,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF
	};
d208 21
a228 11
	{0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0x00000000,
	 0x00000000,0x00000000,0x00000001,0xFFFFFFFF},
	{0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFF,0x00000001,
	 0x00000000,0x00000000,0x00000002,0xFFFFFFFE},
	{0xFFFFFFFD,0xFFFFFFFF,0xFFFFFFFF,0x00000002,
	 0x00000000,0x00000000,0x00000003,0xFFFFFFFD},
	{0xFFFFFFFC,0xFFFFFFFF,0xFFFFFFFF,0x00000003,
	 0x00000000,0x00000000,0x00000004,0xFFFFFFFC},
	{0xFFFFFFFB,0xFFFFFFFF,0xFFFFFFFF,0x00000004,
	 0x00000000,0x00000000,0x00000005,0xFFFFFFFB},
	};
d230 5
a234 5
	0x00000001,0x00000000,0x00000000,0xFFFFFFFE,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFE,0x00000001,
	0xFFFFFFFE,0x00000001,0xFFFFFFFE,0x00000001,
	0x00000001,0xFFFFFFFE,0x00000002,0xFFFFFFFE
	};
d236 26
a261 11
	{0xFFFFFFFF,0x00000000,0x00000000,0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFE,0x00000001,0x00000000,0xFFFFFFFE,0xFFFFFFFD,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFD,0x00000002,0x00000000,0xFFFFFFFD,0xFFFFFFFC,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFC,0x00000003,0x00000000,0xFFFFFFFC,0xFFFFFFFB,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFB,0x00000004,0x00000000,0xFFFFFFFB,0xFFFFFFFA,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	};
d263 11
a273 9
	0x00000001,0xFFFFFFFE,0x00000000,0x00000002,0x00000000,0xFFFFFFFE,
	0x00000000,0x00000002,0x00000001,0x00000000,0x00000000,0x00000000,
	0xFFFFFFFE,0x00000001,0x00000000,0xFFFFFFFE,0xFFFFFFFD,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF
	};
static const BN_ULONG _nist_p_521[] = {0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
	0xFFFFFFFF,0x000001FF};
d275 7
a281 7
	0x00000001,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
	0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
	0x00000000,0x00000000,0x00000000,0x00000000,0xFFFFFC00,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0x0003FFFF
	};
d286 1
a286 3

static const BIGNUM _bignum_nist_p_192 =
	{
d292 1
a292 1
	};
d294 1
a294 2
static const BIGNUM _bignum_nist_p_224 =
	{
d300 1
a300 1
	};
d302 1
a302 2
static const BIGNUM _bignum_nist_p_256 =
	{
d308 1
a308 1
	};
d310 1
a310 2
static const BIGNUM _bignum_nist_p_384 =
	{
d316 1
a316 1
	};
d318 1
a318 2
static const BIGNUM _bignum_nist_p_521 =
	{
d324 1
a324 1
	};
d327 3
a329 2
const BIGNUM *BN_get0_nist_prime_192(void)
	{
d331 1
a331 1
	}
d333 3
a335 2
const BIGNUM *BN_get0_nist_prime_224(void)
	{
d337 1
a337 1
	}
d339 3
a341 2
const BIGNUM *BN_get0_nist_prime_256(void)
	{
d343 1
a343 1
	}
d345 3
a347 2
const BIGNUM *BN_get0_nist_prime_384(void)
	{
d349 1
a349 1
	}
d351 3
a353 2
const BIGNUM *BN_get0_nist_prime_521(void)
	{
d355 1
a355 1
	}
d357 3
a359 3

static void nist_cp_bn_0(BN_ULONG *dst, const BN_ULONG *src, int top, int max)
	{
d369 1
a369 1
	}
d372 1
a372 1
	{ 
d377 1
a377 1
	}
d422 5
a426 5
int BN_nist_mod_192(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,
	BN_CTX *ctx)
	{
	int      top = a->top, i;
	int      carry;
d428 6
a433 6
	union	{
		BN_ULONG	bn[BN_NIST_192_TOP];
		unsigned int	ui[BN_NIST_192_TOP*sizeof(BN_ULONG)/sizeof(unsigned int)];
		} buf;
	BN_ULONG c_d[BN_NIST_192_TOP],
		*res;
d437 5
a441 3
		sizeof(_nist_p_192_sqr)/sizeof(_nist_p_192_sqr[0]),
		sizeof(_nist_p_192_sqr)/sizeof(_nist_p_192_sqr[0]),
		0,BN_FLG_STATIC_DATA };
d445 1
a445 1
 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_192_sqr)>=0)
d449 1
a449 2
	if (i == 0)
		{
d452 2
a453 3
		}
	else if (i > 0)
		return (r == a) ? 1 : (BN_copy(r ,a) != NULL);
d455 1
a455 2
	if (r != a)
		{
d460 1
a460 2
		}
	else
d463 2
a464 1
	nist_cp_bn_0(buf.bn, a_d + BN_NIST_192_TOP, top - BN_NIST_192_TOP, BN_NIST_192_TOP);
d468 40
a507 9
	NIST_INT64		acc;	/* accumulator */
	unsigned int		*rp=(unsigned int *)r_d;
	const unsigned int	*bp=(const unsigned int *)buf.ui;

	acc  = rp[0];	acc += bp[3*2-6];
			acc += bp[5*2-6]; rp[0] = (unsigned int)acc; acc >>= 32;

	acc += rp[1];	acc += bp[3*2-5];
			acc += bp[5*2-5]; rp[1] = (unsigned int)acc; acc >>= 32;
d509 1
a509 15
	acc += rp[2];	acc += bp[3*2-6];
			acc += bp[4*2-6];
			acc += bp[5*2-6]; rp[2] = (unsigned int)acc; acc >>= 32;

	acc += rp[3];	acc += bp[3*2-5];
			acc += bp[4*2-5];
			acc += bp[5*2-5]; rp[3] = (unsigned int)acc; acc >>= 32;

	acc += rp[4];	acc += bp[4*2-6];
			acc += bp[5*2-6]; rp[4] = (unsigned int)acc; acc >>= 32;

	acc += rp[5];	acc += bp[4*2-5];
			acc += bp[5*2-5]; rp[5] = (unsigned int)acc;

	carry = (int)(acc>>32);
d513 1
a513 1
	BN_ULONG t_d[BN_NIST_192_TOP];
d515 6
a520 6
	nist_set_192(t_d, buf.bn, 0, 3, 3);
	carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);
	nist_set_192(t_d, buf.bn, 4, 4, 0);
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);
	nist_set_192(t_d, buf.bn, 5, 5, 5)
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);
d524 2
a525 1
		carry = (int)bn_sub_words(r_d,r_d,_nist_p_192[carry-1],BN_NIST_192_TOP);
d535 5
a539 5
	mask  = 0-(uintptr_t)bn_sub_words(c_d,r_d,_nist_p_192[0],BN_NIST_192_TOP);
	mask &= 0-(uintptr_t)carry;
	res   = c_d;
	res   = (BN_ULONG *)
	 (((uintptr_t)res&~mask) | ((uintptr_t)r_d&mask));
d545 1
a545 1
	}
d547 2
a548 1
typedef BN_ULONG (*bn_addsub_f)(BN_ULONG *,const BN_ULONG *,const BN_ULONG *,int);
d561 5
a565 5
int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,
	BN_CTX *ctx)
	{
	int	top = a->top, i;
	int	carry;
d567 6
a572 6
	union	{
		BN_ULONG	bn[BN_NIST_224_TOP];
		unsigned int	ui[BN_NIST_224_TOP*sizeof(BN_ULONG)/sizeof(unsigned int)];
		} buf;
	BN_ULONG c_d[BN_NIST_224_TOP],
		*res;
d574 4
a577 1
	union { bn_addsub_f f; uintptr_t p; } u;
d580 5
a584 4
		sizeof(_nist_p_224_sqr)/sizeof(_nist_p_224_sqr[0]),
		sizeof(_nist_p_224_sqr)/sizeof(_nist_p_224_sqr[0]),
		0,BN_FLG_STATIC_DATA };

d588 1
a588 1
 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_224_sqr)>=0)
d592 1
a592 2
	if (i == 0)
		{
d595 2
a596 3
		}
	else if (i > 0)
		return (r == a)? 1 : (BN_copy(r ,a) != NULL);
d598 1
a598 2
	if (r != a)
		{
d603 1
a603 2
		}
	else
d608 2
a609 1
	nist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP-1), top - (BN_NIST_224_TOP-1), BN_NIST_224_TOP);
d613 1
a613 1
	r_d[BN_NIST_224_TOP-1] &= BN_MASK2l;
d615 2
a616 1
	nist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP, BN_NIST_224_TOP);
d621 47
a667 12
	NIST_INT64		acc;	/* accumulator */
	unsigned int		*rp=(unsigned int *)r_d;
	const unsigned int	*bp=(const unsigned int *)buf.ui;

	acc  = rp[0];	acc -= bp[7-7];
			acc -= bp[11-7]; rp[0] = (unsigned int)acc; acc >>= 32;

	acc += rp[1];	acc -= bp[8-7];
			acc -= bp[12-7]; rp[1] = (unsigned int)acc; acc >>= 32;

	acc += rp[2];	acc -= bp[9-7];
			acc -= bp[13-7]; rp[2] = (unsigned int)acc; acc >>= 32;
d669 1
a669 16
	acc += rp[3];	acc += bp[7-7];
			acc += bp[11-7];
			acc -= bp[10-7]; rp[3] = (unsigned int)acc; acc>>= 32;

	acc += rp[4];	acc += bp[8-7];
			acc += bp[12-7];
			acc -= bp[11-7]; rp[4] = (unsigned int)acc; acc >>= 32;

	acc += rp[5];	acc += bp[9-7];
			acc += bp[13-7];
			acc -= bp[12-7]; rp[5] = (unsigned int)acc; acc >>= 32;

	acc += rp[6];	acc += bp[10-7];
			acc -= bp[13-7]; rp[6] = (unsigned int)acc;

	carry = (int)(acc>>32);
d671 1
a671 1
	rp[7] = carry;
d673 1
a673 1
	}	
d676 1
a676 1
	BN_ULONG t_d[BN_NIST_224_TOP];
d678 8
a685 8
	nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);
	carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);
	nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);
	nist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);
	nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);
d688 1
a688 1
	carry = (int)(r_d[BN_NIST_224_TOP-1]>>32);
d693 3
a695 3
	if (carry > 0)
		{
		carry = (int)bn_sub_words(r_d,r_d,_nist_p_224[carry-1],BN_NIST_224_TOP);
d697 1
a697 1
		carry=(int)(~(r_d[BN_NIST_224_TOP-1]>>32))&1;
d699 1
a699 3
		}
	else if (carry < 0)
		{
d706 6
a711 6
		carry = (int)bn_add_words(r_d,r_d,_nist_p_224[-carry-1],BN_NIST_224_TOP);
		mask = 0-(uintptr_t)carry;
		u.p = ((uintptr_t)bn_sub_words&mask) |
		 ((uintptr_t)bn_add_words&~mask);
		}
	else
d715 4
a718 4
	mask  = 0-(uintptr_t)(*u.f)(c_d,r_d,_nist_p_224[0],BN_NIST_224_TOP);
	mask &= 0-(uintptr_t)carry;
	res   = c_d;
	res   = (BN_ULONG *)(((uintptr_t)res&~mask) | ((uintptr_t)r_d&mask));
d724 1
a724 1
	}
d738 5
a742 5
int BN_nist_mod_256(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,
	BN_CTX *ctx)
	{
	int	i, top = a->top;
	int	carry = 0;
d744 1
a744 1
	union	{
d746 4
a749 4
		unsigned int ui[BN_NIST_256_TOP*sizeof(BN_ULONG)/sizeof(unsigned int)];
		} buf;
	BN_ULONG c_d[BN_NIST_256_TOP],
		*res;
d751 4
a754 1
	union { bn_addsub_f f; uintptr_t p; } u;
d757 5
a761 3
		sizeof(_nist_p_256_sqr)/sizeof(_nist_p_256_sqr[0]),
		sizeof(_nist_p_256_sqr)/sizeof(_nist_p_256_sqr[0]),
		0,BN_FLG_STATIC_DATA };
d765 1
a765 1
 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_256_sqr)>=0)
d769 1
a769 2
	if (i == 0)
		{
d772 2
a773 3
		}
	else if (i > 0)
		return (r == a)? 1 : (BN_copy(r ,a) != NULL);
d775 1
a775 2
	if (r != a)
		{
d780 1
a780 2
		}
	else
d783 2
a784 1
	nist_cp_bn_0(buf.bn, a_d + BN_NIST_256_TOP, top - BN_NIST_256_TOP, BN_NIST_256_TOP);
d788 89
a876 66
	NIST_INT64		acc;	/* accumulator */
	unsigned int		*rp=(unsigned int *)r_d;
	const unsigned int	*bp=(const unsigned int *)buf.ui;

	acc = rp[0];	acc += bp[8-8];
			acc += bp[9-8];
			acc -= bp[11-8];
			acc -= bp[12-8];
			acc -= bp[13-8];
			acc -= bp[14-8]; rp[0] = (unsigned int)acc; acc >>= 32;

	acc += rp[1];	acc += bp[9-8];
			acc += bp[10-8];
			acc -= bp[12-8];
			acc -= bp[13-8];
			acc -= bp[14-8];
			acc -= bp[15-8]; rp[1] = (unsigned int)acc; acc >>= 32;

	acc += rp[2];	acc += bp[10-8];
			acc += bp[11-8];
			acc -= bp[13-8];
			acc -= bp[14-8];
			acc -= bp[15-8]; rp[2] = (unsigned int)acc; acc >>= 32;

	acc += rp[3];	acc += bp[11-8];
			acc += bp[11-8];
			acc += bp[12-8];
			acc += bp[12-8];
			acc += bp[13-8];
			acc -= bp[15-8];
			acc -= bp[8-8];
			acc -= bp[9-8];  rp[3] = (unsigned int)acc; acc >>= 32;

	acc += rp[4];	acc += bp[12-8];
			acc += bp[12-8];
			acc += bp[13-8];
			acc += bp[13-8];
			acc += bp[14-8];
			acc -= bp[9-8];
			acc -= bp[10-8]; rp[4] = (unsigned int)acc; acc >>= 32;

	acc += rp[5];	acc += bp[13-8];
			acc += bp[13-8];
			acc += bp[14-8];
			acc += bp[14-8];
			acc += bp[15-8];
			acc -= bp[10-8];
			acc -= bp[11-8]; rp[5] = (unsigned int)acc; acc >>= 32;

	acc += rp[6];	acc += bp[14-8];
			acc += bp[14-8];
			acc += bp[15-8];
			acc += bp[15-8];
			acc += bp[14-8];
			acc += bp[13-8];
			acc -= bp[8-8];
			acc -= bp[9-8];  rp[6] = (unsigned int)acc; acc >>= 32;

	acc += rp[7];	acc += bp[15-8];
			acc += bp[15-8];
			acc += bp[15-8];
			acc += bp[8 -8];
			acc -= bp[10-8];
			acc -= bp[11-8];
			acc -= bp[12-8];
			acc -= bp[13-8]; rp[7] = (unsigned int)acc;
d878 1
a878 1
	carry = (int)(acc>>32);
d882 1
a882 1
	BN_ULONG t_d[BN_NIST_256_TOP];
d884 6
a889 6
	/*S1*/
	nist_set_256(t_d, buf.bn, 15, 14, 13, 12, 11, 0, 0, 0);
	/*S2*/
	nist_set_256(c_d, buf.bn, 0, 15, 14, 13, 12, 0, 0, 0);
	carry = (int)bn_add_words(t_d, t_d, c_d, BN_NIST_256_TOP);
	/* left shift */
d891 7
a897 8
		register BN_ULONG *ap,t,c;
		ap = t_d;
		c=0;
		for (i = BN_NIST_256_TOP; i != 0; --i)
			{
			t= *ap;
			*(ap++)=((t<<1)|c)&BN_MASK2;
			c=(t & BN_TBIT)?1:0;
d899 2
a900 2
		carry <<= 1;
		carry  |= c;
d902 19
a920 19
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);
	/*S3*/
	nist_set_256(t_d, buf.bn, 15, 14, 0, 0, 0, 10, 9, 8);
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);
	/*S4*/
	nist_set_256(t_d, buf.bn, 8, 13, 15, 14, 13, 11, 10, 9);
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);
	/*D1*/
	nist_set_256(t_d, buf.bn, 10, 8, 0, 0, 0, 13, 12, 11);
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
	/*D2*/
	nist_set_256(t_d, buf.bn, 11, 9, 0, 0, 15, 14, 13, 12);
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
	/*D3*/
	nist_set_256(t_d, buf.bn, 12, 0, 10, 9, 8, 15, 14, 13);
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
	/*D4*/
	nist_set_256(t_d, buf.bn, 13, 0, 11, 10, 9, 0, 15, 14);
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
d927 9
a935 9
		carry = (int)bn_sub_words(r_d,r_d,_nist_p_256[carry-1],BN_NIST_256_TOP);
	else if (carry < 0)
		{
		carry = (int)bn_add_words(r_d,r_d,_nist_p_256[-carry-1],BN_NIST_256_TOP);
		mask = 0-(uintptr_t)carry;
		u.p = ((uintptr_t)bn_sub_words&mask) |
		 ((uintptr_t)bn_add_words&~mask);
		}
	else
d938 4
a941 4
	mask  = 0-(uintptr_t)(*u.f)(c_d,r_d,_nist_p_256[0],BN_NIST_256_TOP);
	mask &= 0-(uintptr_t)carry;
	res   = c_d;
	res   = (BN_ULONG *)(((uintptr_t)res&~mask) | ((uintptr_t)r_d&mask));
d947 1
a947 1
	}
d965 5
a969 5
int BN_nist_mod_384(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,
	BN_CTX *ctx)
	{
	int	i, top = a->top;
	int	carry = 0;
d971 1
a971 1
	union	{
d973 4
a976 4
		unsigned int ui[BN_NIST_384_TOP*sizeof(BN_ULONG)/sizeof(unsigned int)];
		} buf;
	BN_ULONG c_d[BN_NIST_384_TOP],
		*res;
d978 4
a981 1
	union { bn_addsub_f f; uintptr_t p; } u;
d984 5
a988 4
		sizeof(_nist_p_384_sqr)/sizeof(_nist_p_384_sqr[0]),
		sizeof(_nist_p_384_sqr)/sizeof(_nist_p_384_sqr[0]),
		0,BN_FLG_STATIC_DATA };

d992 1
a992 1
 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_384_sqr)>=0)
d996 1
a996 2
	if (i == 0)
		{
d999 2
a1000 3
		}
	else if (i > 0)
		return (r == a)? 1 : (BN_copy(r ,a) != NULL);
d1002 1
a1002 2
	if (r != a)
		{
d1007 1
a1007 2
		}
	else
d1010 2
a1011 1
	nist_cp_bn_0(buf.bn, a_d + BN_NIST_384_TOP, top - BN_NIST_384_TOP, BN_NIST_384_TOP);
d1015 116
a1130 81
	NIST_INT64		acc;	/* accumulator */
	unsigned int		*rp=(unsigned int *)r_d;
	const unsigned int	*bp=(const unsigned int *)buf.ui;

	acc = rp[0];	acc += bp[12-12];
			acc += bp[21-12];
			acc += bp[20-12];
			acc -= bp[23-12]; rp[0] = (unsigned int)acc; acc >>= 32;

	acc += rp[1];	acc += bp[13-12];
			acc += bp[22-12];
			acc += bp[23-12];
			acc -= bp[12-12];
			acc -= bp[20-12]; rp[1] = (unsigned int)acc; acc >>= 32;

	acc += rp[2];	acc += bp[14-12];
			acc += bp[23-12];
			acc -= bp[13-12];
			acc -= bp[21-12]; rp[2] = (unsigned int)acc; acc >>= 32;

	acc += rp[3];	acc += bp[15-12];
			acc += bp[12-12];
			acc += bp[20-12];
			acc += bp[21-12];
			acc -= bp[14-12];
			acc -= bp[22-12];
			acc -= bp[23-12]; rp[3] = (unsigned int)acc; acc >>= 32;

	acc += rp[4];	acc += bp[21-12];
			acc += bp[21-12];
			acc += bp[16-12];
			acc += bp[13-12];
			acc += bp[12-12];
			acc += bp[20-12];
			acc += bp[22-12];
			acc -= bp[15-12];
			acc -= bp[23-12];
			acc -= bp[23-12]; rp[4] = (unsigned int)acc; acc >>= 32;

	acc += rp[5];	acc += bp[22-12];
			acc += bp[22-12];
			acc += bp[17-12];
			acc += bp[14-12];
			acc += bp[13-12];
			acc += bp[21-12];
			acc += bp[23-12];
			acc -= bp[16-12]; rp[5] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[6];	acc += bp[23-12];
			acc += bp[23-12];
			acc += bp[18-12];
			acc += bp[15-12];
			acc += bp[14-12];
			acc += bp[22-12];
			acc -= bp[17-12]; rp[6] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[7];	acc += bp[19-12];
			acc += bp[16-12];
			acc += bp[15-12];
			acc += bp[23-12];
			acc -= bp[18-12]; rp[7] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[8];	acc += bp[20-12];
			acc += bp[17-12];
			acc += bp[16-12];
			acc -= bp[19-12]; rp[8] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[9];	acc += bp[21-12];
			acc += bp[18-12];
			acc += bp[17-12];
			acc -= bp[20-12]; rp[9] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[10];	acc += bp[22-12];
			acc += bp[19-12];
			acc += bp[18-12];
			acc -= bp[21-12]; rp[10] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[11];	acc += bp[23-12];
			acc += bp[20-12];
			acc += bp[19-12];
			acc -= bp[22-12]; rp[11] = (unsigned int)acc;
d1132 1
a1132 1
	carry = (int)(acc>>32);
d1136 1
a1136 1
	BN_ULONG t_d[BN_NIST_384_TOP];
d1138 3
a1140 2
	/*S1*/
	nist_set_256(t_d, buf.bn, 0, 0, 0, 0, 0, 23-4, 22-4, 21-4);
d1143 7
a1149 8
		register BN_ULONG *ap,t,c;
		ap = t_d;
		c=0;
		for (i = 3; i != 0; --i)
			{
			t= *ap;
			*(ap++)=((t<<1)|c)&BN_MASK2;
			c=(t & BN_TBIT)?1:0;
d1151 1
a1151 1
		*ap=c;
d1153 28
a1180 25
	carry = (int)bn_add_words(r_d+(128/BN_BITS2), r_d+(128/BN_BITS2), 
		t_d, BN_NIST_256_TOP);
	/*S2 */
	carry += (int)bn_add_words(r_d, r_d, buf.bn, BN_NIST_384_TOP);
	/*S3*/
	nist_set_384(t_d,buf.bn,20,19,18,17,16,15,14,13,12,23,22,21);
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
	/*S4*/
	nist_set_384(t_d,buf.bn,19,18,17,16,15,14,13,12,20,0,23,0);
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
	/*S5*/
	nist_set_384(t_d, buf.bn,0,0,0,0,23,22,21,20,0,0,0,0);
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
	/*S6*/
	nist_set_384(t_d,buf.bn,0,0,0,0,0,0,23,22,21,0,0,20);
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
	/*D1*/
	nist_set_384(t_d,buf.bn,22,21,20,19,18,17,16,15,14,13,12,23);
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);
	/*D2*/
	nist_set_384(t_d,buf.bn,0,0,0,0,0,0,0,23,22,21,20,0);
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);
	/*D3*/
	nist_set_384(t_d,buf.bn,0,0,0,0,0,0,0,23,23,0,0,0);
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);
d1187 9
a1195 9
		carry = (int)bn_sub_words(r_d,r_d,_nist_p_384[carry-1],BN_NIST_384_TOP);
	else if (carry < 0)
		{
		carry = (int)bn_add_words(r_d,r_d,_nist_p_384[-carry-1],BN_NIST_384_TOP);
		mask = 0-(uintptr_t)carry;
		u.p = ((uintptr_t)bn_sub_words&mask) |
		 ((uintptr_t)bn_add_words&~mask);
		}
	else
d1198 4
a1201 4
	mask  = 0-(uintptr_t)(*u.f)(c_d,r_d,_nist_p_384[0],BN_NIST_384_TOP);
	mask &= 0-(uintptr_t)carry;
	res   = c_d;
	res   = (BN_ULONG *)(((uintptr_t)res&~mask) | ((uintptr_t)r_d&mask));
d1207 1
a1207 1
	}
d1213 5
a1217 7
int BN_nist_mod_521(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,
	BN_CTX *ctx)
	{
	int	top = a->top, i;
	BN_ULONG *r_d, *a_d = a->d,
		 t_d[BN_NIST_521_TOP],
		 val,tmp,*res;
d1221 5
a1225 3
		sizeof(_nist_p_521_sqr)/sizeof(_nist_p_521_sqr[0]),
		sizeof(_nist_p_521_sqr)/sizeof(_nist_p_521_sqr[0]),
		0,BN_FLG_STATIC_DATA };
d1229 1
a1229 1
 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_521_sqr)>=0)
d1233 1
a1233 2
	if (i == 0)
		{
d1236 2
a1237 3
		}
	else if (i > 0)
		return (r == a)? 1 : (BN_copy(r ,a) != NULL);
d1239 2
a1240 3
	if (r != a)
		{
		if (!bn_wexpand(r,BN_NIST_521_TOP))
d1243 2
a1244 3
		nist_cp_bn(r_d,a_d, BN_NIST_521_TOP);
		}
	else
d1248 2
a1249 1
	nist_cp_bn_0(t_d,a_d + (BN_NIST_521_TOP-1), top - (BN_NIST_521_TOP-1),BN_NIST_521_TOP);
d1251 6
a1256 7
	for (val=t_d[0],i=0; i<BN_NIST_521_TOP-1; i++)
		{
		tmp = val>>BN_NIST_521_RSHIFT;
		val = t_d[i+1];
		t_d[i] = (tmp | val<<BN_NIST_521_LSHIFT) & BN_MASK2;
		}
	t_d[i] = val>>BN_NIST_521_RSHIFT;
d1260 6
a1265 5
	bn_add_words(r_d,r_d,t_d,BN_NIST_521_TOP);
	mask = 0-(uintptr_t)bn_sub_words(t_d,r_d,_nist_p_521,BN_NIST_521_TOP);
	res  = t_d;
	res  = (BN_ULONG *)(((uintptr_t)res&~mask) | ((uintptr_t)r_d&mask));
	nist_cp_bn(r_d,res,BN_NIST_521_TOP);
d1270 1
a1270 1
	}
@


1.8
log
@Do not ask the user to pass either -DB_ENDIAN or -DL_ENDIAN to the compiler,
but rather figure out the endianness from <machine/endian.h> automagically;
help from guenther@@

ok jca@@ guenther@@ beck@@ and the rest of the `Buena SSL rampage club'
@
text
@d324 1
a324 1
#  if defined(__arch64__)
d343 1
a343 3
# if defined(_WIN32) && !defined(__GNUC__)
#  define NIST_INT64 __int64
# elif defined(BN_LLONG)
d595 1
a595 1
		/* it's a bit more comlicated logic in this case.
@


1.7
log
@replace PTR_SIZE_INT (only used for VMS) with uintptr_t, tweaks from jca@@,
makes sense to beck@@
@
text
@d62 2
d323 1
a323 1
# if defined(L_ENDIAN)
@


1.6
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d367 1
a367 1
	PTR_SIZE_INT mask;
d451 2
a452 2
	mask  = 0-(PTR_SIZE_INT)bn_sub_words(c_d,r_d,_nist_p_192[0],BN_NIST_192_TOP);
	mask &= 0-(PTR_SIZE_INT)carry;
d455 1
a455 1
	 (((PTR_SIZE_INT)res&~mask) | ((PTR_SIZE_INT)r_d&mask));
d488 2
a489 2
	PTR_SIZE_INT mask;
	union { bn_addsub_f f; PTR_SIZE_INT p; } u;
d602 3
a604 3
		mask = 0-(PTR_SIZE_INT)carry;
		u.p = ((PTR_SIZE_INT)bn_sub_words&mask) |
		 ((PTR_SIZE_INT)bn_add_words&~mask);
d610 2
a611 2
	mask  = 0-(PTR_SIZE_INT)(*u.f)(c_d,r_d,_nist_p_224[0],BN_NIST_224_TOP);
	mask &= 0-(PTR_SIZE_INT)carry;
d613 1
a613 2
	res   = (BN_ULONG *)(((PTR_SIZE_INT)res&~mask) |
	 ((PTR_SIZE_INT)r_d&mask));
d645 2
a646 2
	PTR_SIZE_INT mask;
	union { bn_addsub_f f; PTR_SIZE_INT p; } u;
d802 3
a804 3
		mask = 0-(PTR_SIZE_INT)carry;
		u.p = ((PTR_SIZE_INT)bn_sub_words&mask) |
		 ((PTR_SIZE_INT)bn_add_words&~mask);
d809 2
a810 2
	mask  = 0-(PTR_SIZE_INT)(*u.f)(c_d,r_d,_nist_p_256[0],BN_NIST_256_TOP);
	mask &= 0-(PTR_SIZE_INT)carry;
d812 1
a812 2
	res   = (BN_ULONG *)(((PTR_SIZE_INT)res&~mask) |
	 ((PTR_SIZE_INT)r_d&mask));
d848 2
a849 2
	PTR_SIZE_INT mask;
	union { bn_addsub_f f; PTR_SIZE_INT p; } u;
d1023 3
a1025 3
		mask = 0-(PTR_SIZE_INT)carry;
		u.p = ((PTR_SIZE_INT)bn_sub_words&mask) |
		 ((PTR_SIZE_INT)bn_add_words&~mask);
d1030 2
a1031 2
	mask  = 0-(PTR_SIZE_INT)(*u.f)(c_d,r_d,_nist_p_384[0],BN_NIST_384_TOP);
	mask &= 0-(PTR_SIZE_INT)carry;
d1033 1
a1033 2
	res   = (BN_ULONG *)(((PTR_SIZE_INT)res&~mask) |
	 ((PTR_SIZE_INT)r_d&mask));
d1052 1
a1052 1
	PTR_SIZE_INT mask;
d1097 1
a1097 1
	mask = 0-(PTR_SIZE_INT)bn_sub_words(t_d,r_d,_nist_p_521,BN_NIST_521_TOP);
d1099 1
a1099 2
	res  = (BN_ULONG *)(((PTR_SIZE_INT)res&~mask) |
	 ((PTR_SIZE_INT)r_d&mask));
@


1.5
log
@resolve conflicts
@
text
@d289 1
a289 1
static void nist_cp_bn_0(BN_ULONG *buf, BN_ULONG *a, int top, int max)
a291 1
	BN_ULONG *_tmp1 = (buf), *_tmp2 = (a);
d296 4
a299 4
	for (i = (top); i != 0; i--)
		*_tmp1++ = *_tmp2++;
	for (i = (max) - (top); i != 0; i--)
		*_tmp1++ = (BN_ULONG) 0;
d302 1
a302 1
static void nist_cp_bn(BN_ULONG *buf, BN_ULONG *a, int top)
d305 3
a307 3
	BN_ULONG *_tmp1 = (buf), *_tmp2 = (a);
	for (i = (top); i != 0; i--)
		*_tmp1++ = *_tmp2++;
d453 1
d455 1
a455 1
	 (((PTR_SIZE_INT)c_d&~mask) | ((PTR_SIZE_INT)r_d&mask));
d482 5
a486 2
	BN_ULONG buf[BN_NIST_224_TOP],
		 c_d[BN_NIST_224_TOP],
d525 1
a525 1
	nist_set_224(buf, c_d, 14, 13, 12, 11, 10, 9, 8);
d529 1
a529 1
	nist_cp_bn_0(buf, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP, BN_NIST_224_TOP);
d536 1
a536 1
	const unsigned int	*bp=(const unsigned int *)buf;
d571 1
a571 1
	nist_set_224(t_d, buf, 10, 9, 8, 7, 0, 0, 0);
d573 1
a573 1
	nist_set_224(t_d, buf, 0, 13, 12, 11, 0, 0, 0);
d575 1
a575 1
	nist_set_224(t_d, buf, 13, 12, 11, 10, 9, 8, 7);
d577 1
a577 1
	nist_set_224(t_d, buf, 0, 0, 0, 0, 13, 12, 11);
d612 2
a613 1
	res   = (BN_ULONG *)(((PTR_SIZE_INT)c_d&~mask) |
d812 2
a813 1
	res   = (BN_ULONG *)(((PTR_SIZE_INT)c_d&~mask) |
d1034 2
a1035 1
	res   = (BN_ULONG *)(((PTR_SIZE_INT)c_d&~mask) |
d1101 2
a1102 1
	res  = (BN_ULONG *)(((PTR_SIZE_INT)t_d&~mask) |
@


1.4
log
@openssl-1.0.0e: resolve conflicts
@
text
@d322 7
a339 1
#if BN_BITS2 == 32
d342 5
a346 1
#endif
a348 1

d362 5
a366 3
	BN_ULONG t_d[BN_NIST_192_TOP],
	         buf[BN_NIST_192_TOP],
		 c_d[BN_NIST_192_TOP],
d399 27
a425 1
	nist_cp_bn_0(buf, a_d + BN_NIST_192_TOP, top - BN_NIST_192_TOP, BN_NIST_192_TOP);
d427 7
a433 1
	nist_set_192(t_d, buf, 0, 3, 3);
d435 1
a435 1
	nist_set_192(t_d, buf, 4, 4, 0);
d437 1
a437 1
	nist_set_192(t_d, buf, 5, 5, 5)
d439 2
a440 1

d482 1
a482 2
	BN_ULONG t_d[BN_NIST_224_TOP],
	         buf[BN_NIST_224_TOP],
d520 1
a520 1
	nist_cp_bn_0(t_d, a_d + (BN_NIST_224_TOP-1), top - (BN_NIST_224_TOP-1), BN_NIST_224_TOP);
d522 1
a522 1
	nist_set_224(buf, t_d, 14, 13, 12, 11, 10, 9, 8);
d528 40
d580 2
d636 5
a640 3
	BN_ULONG t_d[BN_NIST_256_TOP],
	         buf[BN_NIST_256_TOP],
		 c_d[BN_NIST_256_TOP],
d674 76
a749 1
	nist_cp_bn_0(buf, a_d + BN_NIST_256_TOP, top - BN_NIST_256_TOP, BN_NIST_256_TOP);
d752 1
a752 1
	nist_set_256(t_d, buf, 15, 14, 13, 12, 11, 0, 0, 0);
d754 1
a754 1
	nist_set_256(c_d, buf, 0, 15, 14, 13, 12, 0, 0, 0);
d772 1
a772 1
	nist_set_256(t_d, buf, 15, 14, 0, 0, 0, 10, 9, 8);
d775 1
a775 1
	nist_set_256(t_d, buf, 8, 13, 15, 14, 13, 11, 10, 9);
d778 1
a778 1
	nist_set_256(t_d, buf, 10, 8, 0, 0, 0, 13, 12, 11);
d781 1
a781 1
	nist_set_256(t_d, buf, 11, 9, 0, 0, 15, 14, 13, 12);
d784 1
a784 1
	nist_set_256(t_d, buf, 12, 0, 10, 9, 8, 15, 14, 13);
d787 1
a787 1
	nist_set_256(t_d, buf, 13, 0, 11, 10, 9, 0, 15, 14);
d790 2
d839 5
a843 3
	BN_ULONG t_d[BN_NIST_384_TOP],
	         buf[BN_NIST_384_TOP],
		 c_d[BN_NIST_384_TOP],
d878 91
a968 1
	nist_cp_bn_0(buf, a_d + BN_NIST_384_TOP, top - BN_NIST_384_TOP, BN_NIST_384_TOP);
d971 1
a971 1
	nist_set_256(t_d, buf, 0, 0, 0, 0, 0, 23-4, 22-4, 21-4);
d988 1
a988 1
	carry += (int)bn_add_words(r_d, r_d, buf, BN_NIST_384_TOP);
d990 1
a990 1
	nist_set_384(t_d,buf,20,19,18,17,16,15,14,13,12,23,22,21);
d993 1
a993 1
	nist_set_384(t_d,buf,19,18,17,16,15,14,13,12,20,0,23,0);
d996 1
a996 1
	nist_set_384(t_d, buf,0,0,0,0,23,22,21,20,0,0,0,0);
d999 1
a999 1
	nist_set_384(t_d,buf,0,0,0,0,0,0,23,22,21,0,0,20);
d1002 1
a1002 1
	nist_set_384(t_d,buf,22,21,20,19,18,17,16,15,14,13,12,23);
d1005 1
a1005 1
	nist_set_384(t_d,buf,0,0,0,0,0,0,0,23,22,21,20,0);
d1008 1
a1008 1
	nist_set_384(t_d,buf,0,0,0,0,0,0,0,23,23,0,0,0);
d1011 2
@


1.3
log
@resolve conflicts
@
text
@d357 1
a357 1
	size_t   mask;
d408 4
a411 3
	mask  = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_192[0],BN_NIST_192_TOP);
	mask &= 0-(size_t)carry;
	res   = (BN_ULONG *)(((size_t)c_d&~mask) | ((size_t)r_d&mask));
d442 2
a443 2
	size_t   mask;
	union { bn_addsub_f f; size_t p; } u;
d514 3
a516 2
		mask = 0-(size_t)carry;
		u.p = ((size_t)bn_sub_words&mask) | ((size_t)bn_add_words&~mask);
d522 4
a525 3
	mask  = 0-(size_t)(*u.f)(c_d,r_d,_nist_p_224[0],BN_NIST_224_TOP);
	mask &= 0-(size_t)carry;
	res   = (BN_ULONG *)(((size_t)c_d&~mask) | ((size_t)r_d&mask));
d555 2
a556 2
	size_t   mask;
	union { bn_addsub_f f; size_t p; } u;
d635 3
a637 2
		mask = 0-(size_t)carry;
		u.p = ((size_t)bn_sub_words&mask) | ((size_t)bn_add_words&~mask);
d642 4
a645 3
	mask  = 0-(size_t)(*u.f)(c_d,r_d,_nist_p_256[0],BN_NIST_256_TOP);
	mask &= 0-(size_t)carry;
	res   = (BN_ULONG *)(((size_t)c_d&~mask) | ((size_t)r_d&mask));
d679 2
a680 2
	size_t	 mask;
	union { bn_addsub_f f; size_t p; } u;
d762 3
a764 2
		mask = 0-(size_t)carry;
		u.p = ((size_t)bn_sub_words&mask) | ((size_t)bn_add_words&~mask);
d769 4
a772 3
	mask  = 0-(size_t)(*u.f)(c_d,r_d,_nist_p_384[0],BN_NIST_384_TOP);
	mask &= 0-(size_t)carry;
	res   = (BN_ULONG *)(((size_t)c_d&~mask) | ((size_t)r_d&mask));
d791 1
a791 1
	size_t	mask;
d836 3
a838 2
	mask = 0-(size_t)bn_sub_words(t_d,r_d,_nist_p_521,BN_NIST_521_TOP);
	res  = (BN_ULONG *)(((size_t)t_d&~mask) | ((size_t)r_d&mask));
@


1.2
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d69 1
d71 10
a80 4
static const BN_ULONG _nist_p_192[] =
	{0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFEULL,
	0xFFFFFFFFFFFFFFFFULL};
static const BN_ULONG _nist_p_224[] =
d82 11
a92 2
	0xFFFFFFFFFFFFFFFFULL,0x00000000FFFFFFFFULL};
static const BN_ULONG _nist_p_256[] =
d94 34
a127 5
	0x0000000000000000ULL,0xFFFFFFFF00000001ULL};
static const BN_ULONG _nist_p_384[] =
	{0x00000000FFFFFFFFULL,0xFFFFFFFF00000000ULL,
	0xFFFFFFFFFFFFFFFEULL,0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL};
d134 8
d143 57
a199 9
static const BN_ULONG _nist_p_192[] = {0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFE,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF};
static const BN_ULONG _nist_p_224[] = {0x00000001,0x00000000,0x00000000,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF};
static const BN_ULONG _nist_p_256[] = {0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
	0x00000000,0x00000000,0x00000000,0x00000001,0xFFFFFFFF};
static const BN_ULONG _nist_p_384[] = {0xFFFFFFFF,0x00000000,0x00000000,
	0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF};
d204 10
d219 1
a219 1
	(BN_ULONG *)_nist_p_192,
d228 1
a228 1
	(BN_ULONG *)_nist_p_224,
d237 1
a237 1
	(BN_ULONG *)_nist_p_256,
d246 1
a246 1
	(BN_ULONG *)_nist_p_384,
d294 1
d296 1
d314 8
a321 3
/* TBD */
#define bn_cp_32(to, n, from, m)	(to)[n] = (m>=0)?((from)[m]):0;
#define bn_32_set_0(to, n)		(to)[n] = (BN_ULONG)0;
d342 1
a342 1
	if (a3 != 0) bn_cp_64(to, 0, from, (a3) - 3) else bn_64_set_0(to, 0)\
d344 1
a344 1
	if (a1 != 0) bn_cp_64(to, 2, from, (a1) - 3) else bn_64_set_0(to, 2)\
d358 5
d366 2
a367 2
 	if (BN_is_negative(a) || a->top > 2*BN_NIST_192_TOP)
		return BN_nnmod(r, field, a, ctx);
d391 1
a391 5
	carry = bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_192,BN_NIST_192_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
	
d393 3
a395 4
	carry = bn_add_words(r_d, res, t_d, BN_NIST_192_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_192,BN_NIST_192_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
d397 4
a400 5
	nist_set_192(t_d, buf, 5, 5, 5)
	carry = bn_add_words(r_d, res, t_d, BN_NIST_192_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_192,BN_NIST_192_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
d402 9
a414 5
	if (BN_ucmp(field, r) <= 0)
		{
		if (!BN_usub(r, r, field)) return 0;
		}

d418 2
d422 7
a428 7
	if (a7 != 0) bn_cp_32(to, 0, from, (a7) - 7) else bn_32_set_0(to, 0)\
	if (a6 != 0) bn_cp_32(to, 1, from, (a6) - 7) else bn_32_set_0(to, 1)\
	if (a5 != 0) bn_cp_32(to, 2, from, (a5) - 7) else bn_32_set_0(to, 2)\
	if (a4 != 0) bn_cp_32(to, 3, from, (a4) - 7) else bn_32_set_0(to, 3)\
	if (a3 != 0) bn_cp_32(to, 4, from, (a3) - 7) else bn_32_set_0(to, 4)\
	if (a2 != 0) bn_cp_32(to, 5, from, (a2) - 7) else bn_32_set_0(to, 5)\
	if (a1 != 0) bn_cp_32(to, 6, from, (a1) - 7) else bn_32_set_0(to, 6)\
a433 1
#if BN_BITS2 == 32
d442 7
d452 2
a453 2
 	if (BN_is_negative(a) || a->top > 2*BN_NIST_224_TOP)
		return BN_nnmod(r, field, a, ctx);
d474 8
d483 1
a483 1

d485 1
a485 5
	carry = bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_224,BN_NIST_224_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
	
d487 5
a491 4
	carry = bn_add_words(r_d, res, t_d, BN_NIST_224_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_224,BN_NIST_224_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
d493 2
a494 9
	nist_set_224(t_d, buf, 13, 12, 11, 10, 9, 8, 7);
#if BRANCH_FREE
	carry = bn_sub_words(r_d, res, t_d, BN_NIST_224_TOP);
	bn_add_words(c_d,r_d,_nist_p_224,BN_NIST_224_TOP);
	mask = 0-(size_t)carry;
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
#else
	if (bn_sub_words(r_d, res, t_d, BN_NIST_224_TOP))
		bn_add_words(r_d,r_d,_nist_p_224,BN_NIST_224_TOP);
d496 22
a517 6
	nist_set_224(t_d, buf, 0, 0, 0, 0, 13, 12, 11);
#if BRANCH_FREE
	carry = bn_sub_words(r_d, res, t_d, BN_NIST_224_TOP);
	bn_add_words(c_d,r_d,_nist_p_224,BN_NIST_224_TOP);
	mask = 0-(size_t)carry;
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
d519 4
a523 4
#else
	if (bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP))
		bn_add_words(r_d,r_d,_nist_p_224,BN_NIST_224_TOP);
#endif
a526 5
	if (BN_ucmp(field, r) <= 0)
		{
		if (!BN_usub(r, r, field)) return 0;
		}

a527 3
#else	/* BN_BITS!=32 */
	return 0;
#endif
d532 8
a539 8
	if (a8 != 0) bn_cp_32(to, 0, from, (a8) - 8) else bn_32_set_0(to, 0)\
	if (a7 != 0) bn_cp_32(to, 1, from, (a7) - 8) else bn_32_set_0(to, 1)\
	if (a6 != 0) bn_cp_32(to, 2, from, (a6) - 8) else bn_32_set_0(to, 2)\
	if (a5 != 0) bn_cp_32(to, 3, from, (a5) - 8) else bn_32_set_0(to, 3)\
	if (a4 != 0) bn_cp_32(to, 4, from, (a4) - 8) else bn_32_set_0(to, 4)\
	if (a3 != 0) bn_cp_32(to, 5, from, (a3) - 8) else bn_32_set_0(to, 5)\
	if (a2 != 0) bn_cp_32(to, 6, from, (a2) - 8) else bn_32_set_0(to, 6)\
	if (a1 != 0) bn_cp_32(to, 7, from, (a1) - 8) else bn_32_set_0(to, 7)\
a544 1
#if BN_BITS2 == 32
d553 6
d562 2
a563 2
 	if (BN_is_negative(a) || a->top > 2*BN_NIST_256_TOP)
		return BN_nnmod(r, field, a, ctx);
d589 17
a605 16
	nist_set_256(c_d,buf, 0, 15, 14, 13, 12, 0, 0, 0);
	carry = bn_add_words(t_d, t_d, c_d, BN_NIST_256_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,t_d,_nist_p_256,BN_NIST_256_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)t_d&~mask));

	carry = bn_add_words(t_d, res, res, BN_NIST_256_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,t_d,_nist_p_256,BN_NIST_256_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)t_d&~mask));

	carry = bn_add_words(r_d, r_d, res, BN_NIST_256_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_256,BN_NIST_256_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));

d608 1
a608 5
	carry = bn_add_words(r_d, res, t_d, BN_NIST_256_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_256,BN_NIST_256_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));

d611 1
a611 5
	carry = bn_add_words(r_d, res, t_d, BN_NIST_256_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_256,BN_NIST_256_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));

d614 1
a614 9
#if BRANCH_FREE
	carry = bn_sub_words(r_d, res, t_d, BN_NIST_256_TOP);
	bn_add_words(c_d,r_d,_nist_p_256,BN_NIST_256_TOP);
	mask = 0-(size_t)carry;
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));	
#else
	if (bn_sub_words(r_d, res, t_d, BN_NIST_256_TOP))
		bn_add_words(r_d,r_d,_nist_p_256,BN_NIST_256_TOP);
#endif
d617 1
a617 9
#if BRANCH_FREE
	carry = bn_sub_words(r_d, res, t_d, BN_NIST_256_TOP);
	bn_add_words(c_d,r_d,_nist_p_256,BN_NIST_256_TOP);
	mask = 0-(size_t)carry;
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));	
#else
	if (bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP))
		bn_add_words(r_d,r_d,_nist_p_256,BN_NIST_256_TOP);
#endif
d620 1
a620 9
#if BRANCH_FREE
	carry = bn_sub_words(r_d, res, t_d, BN_NIST_256_TOP);
	bn_add_words(c_d,r_d,_nist_p_256,BN_NIST_256_TOP);
	mask = 0-(size_t)carry;
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));	
#else
	if (bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP))
		bn_add_words(r_d,r_d,_nist_p_256,BN_NIST_256_TOP);
#endif
d623 1
a623 5
#if BRANCH_FREE
	carry = bn_sub_words(r_d, res, t_d, BN_NIST_256_TOP);
	bn_add_words(c_d,r_d,_nist_p_256,BN_NIST_256_TOP);
	mask = 0-(size_t)carry;
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));	
d625 17
a641 5
	nist_cp_bn(r_d, res, BN_NIST_384_TOP);
#else
	if (bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP))
		bn_add_words(r_d,r_d,_nist_p_256,BN_NIST_256_TOP);
#endif
a644 5
	if (BN_ucmp(field, r) <= 0)
		{
		if (!BN_usub(r, r, field)) return 0;
		}

a645 3
#else	/* BN_BITS!=32 */
	return 0;
#endif
d650 12
a661 12
	if (a12 != 0) bn_cp_32(to, 0, from,  (a12) - 12) else bn_32_set_0(to, 0)\
	if (a11 != 0) bn_cp_32(to, 1, from,  (a11) - 12) else bn_32_set_0(to, 1)\
	if (a10 != 0) bn_cp_32(to, 2, from,  (a10) - 12) else bn_32_set_0(to, 2)\
	if (a9 != 0)  bn_cp_32(to, 3, from,  (a9) - 12)  else bn_32_set_0(to, 3)\
	if (a8 != 0)  bn_cp_32(to, 4, from,  (a8) - 12)  else bn_32_set_0(to, 4)\
	if (a7 != 0)  bn_cp_32(to, 5, from,  (a7) - 12)  else bn_32_set_0(to, 5)\
	if (a6 != 0)  bn_cp_32(to, 6, from,  (a6) - 12)  else bn_32_set_0(to, 6)\
	if (a5 != 0)  bn_cp_32(to, 7, from,  (a5) - 12)  else bn_32_set_0(to, 7)\
	if (a4 != 0)  bn_cp_32(to, 8, from,  (a4) - 12)  else bn_32_set_0(to, 8)\
	if (a3 != 0)  bn_cp_32(to, 9, from,  (a3) - 12)  else bn_32_set_0(to, 9)\
	if (a2 != 0)  bn_cp_32(to, 10, from, (a2) - 12)  else bn_32_set_0(to, 10)\
	if (a1 != 0)  bn_cp_32(to, 11, from, (a1) - 12)  else bn_32_set_0(to, 11)\
a666 1
#if BN_BITS2 == 32
d675 7
d685 2
a686 2
 	if (BN_is_negative(a) || a->top > 2*BN_NIST_384_TOP)
		return BN_nnmod(r, field, a, ctx);
d724 1
a724 1
	carry = bn_add_words(r_d+(128/BN_BITS2), r_d+(128/BN_BITS2), 
a725 13
	/*
	 * we need if (result>=modulus) subtract(result,modulus);
	 * in n-bit space this can be expressed as
	 * if (carry || result>=modulus) subtract(result,modulus);
	 * the catch is that comparison implies subtraction and
	 * therefore one can write tmp=subtract(result,modulus);
	 * and then if(carry || !borrow) result=tmp; this's what
	 * happens below, but without explicit if:-) a.
	 */
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_384,BN_NIST_384_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));

d727 1
a727 5
	carry = bn_add_words(r_d, res, buf, BN_NIST_384_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_384,BN_NIST_384_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));

d730 1
a730 5
	carry = bn_add_words(r_d, res, t_d, BN_NIST_384_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_384,BN_NIST_384_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));

d733 1
a733 5
	carry = bn_add_words(r_d, res, t_d, BN_NIST_384_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_384,BN_NIST_384_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));

d736 1
a736 5
	carry = bn_add_words(r_d, res, t_d, BN_NIST_384_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_384,BN_NIST_384_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));

d739 1
a739 5
	carry = bn_add_words(r_d, res, t_d, BN_NIST_384_TOP);
	mask = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_384,BN_NIST_384_TOP);
	mask = ~mask | (0-(size_t)carry);
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));

d742 1
a742 9
#if BRANCH_FREE
	carry = bn_sub_words(r_d, res, t_d, BN_NIST_384_TOP);
	bn_add_words(c_d,r_d,_nist_p_384,BN_NIST_384_TOP);
	mask = 0-(size_t)carry;
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
#else
	if (bn_sub_words(r_d, res, t_d, BN_NIST_384_TOP))
		bn_add_words(r_d,r_d,_nist_p_384,BN_NIST_384_TOP);
#endif
d745 1
a745 9
#if BRANCH_FREE
	carry = bn_sub_words(r_d, res, t_d, BN_NIST_384_TOP);
	bn_add_words(c_d,r_d,_nist_p_384,BN_NIST_384_TOP);
	mask = 0-(size_t)carry;
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
#else
	if (bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP))
		bn_add_words(r_d,r_d,_nist_p_384,BN_NIST_384_TOP);
#endif
d748 14
a761 5
#if BRANCH_FREE
	carry = bn_sub_words(r_d, res, t_d, BN_NIST_384_TOP);
	bn_add_words(c_d,r_d,_nist_p_384,BN_NIST_384_TOP);
	mask = 0-(size_t)carry;
	res = (BN_ULONG *)(((size_t)c_d&mask) | ((size_t)r_d&~mask));
d763 3
a766 4
#else
	if (bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP))
		bn_add_words(r_d,r_d,_nist_p_384,BN_NIST_384_TOP);
#endif
a769 5
	if (BN_ucmp(field, r) <= 0)
		{
		if (!BN_usub(r, r, field)) return 0;
		}

a770 3
#else	/* BN_BITS!=32 */
	return 0;
#endif
d773 4
d780 10
a789 7
#if BN_BITS2 == 64
#define BN_NIST_521_TOP_MASK	(BN_ULONG)0x1FF
#elif BN_BITS2 == 32
#define BN_NIST_521_TOP_MASK	(BN_ULONG)0x1FF
#endif
	int	top, ret = 0;
	BIGNUM	*tmp;
d793 2
a794 2
 	if (BN_is_negative(a))
		return BN_nnmod(r, field, a, ctx);
d796 2
a797 4
	/* check whether a reduction is necessary */
	top = a->top;
	if (top < BN_NIST_521_TOP  || ( top == BN_NIST_521_TOP &&
	    (!(a->d[BN_NIST_521_TOP-1] & ~(BN_NIST_521_TOP_MASK)))))
d799 2
a800 13
		int i = BN_ucmp(field, a);
		if (i == 0)
			{
			BN_zero(r);
			return 1;
			}
		else
			{
#ifdef BN_DEBUG
			OPENSSL_assert(i > 0); /* because 'field' is 1111...1111 */
#endif
			return (r == a)? 1 : (BN_copy(r ,a) != NULL);
			}
d802 2
d805 1
a805 23
 	if (BN_num_bits(a) > 2*521)
		return BN_nnmod(r, field, a, ctx);

	BN_CTX_start(ctx);
	tmp = BN_CTX_get(ctx);
	if (!tmp)
		goto err;

	if (!bn_wexpand(tmp, BN_NIST_521_TOP))
		goto err;
	nist_cp_bn(tmp->d, a->d, BN_NIST_521_TOP);

	tmp->top = BN_NIST_521_TOP;
        tmp->d[BN_NIST_521_TOP-1]  &= BN_NIST_521_TOP_MASK;
	bn_correct_top(tmp);

	if (!BN_rshift(r, a, 521))
		goto err;

	if (!BN_uadd(r, tmp, r))
		goto err;

	if (BN_ucmp(field, r) <= 0)
d807 4
a810 1
		if (!BN_usub(r, r, field)) goto err;
d812 2
d815 19
a833 3
	ret = 1;
err:
	BN_CTX_end(ctx);
d835 1
a835 2
	bn_check_top(r);
	return ret;
@


1.1
log
@Initial revision
@
text
@d62 1
d105 47
d154 1
a154 3
	static BIGNUM const_nist_192 = { (BN_ULONG *)_nist_p_192,
		BN_NIST_192_TOP, BN_NIST_192_TOP, 0, BN_FLG_STATIC_DATA };
	return &const_nist_192;
d159 1
a159 3
	static BIGNUM const_nist_224 = { (BN_ULONG *)_nist_p_224,
		BN_NIST_224_TOP, BN_NIST_224_TOP, 0, BN_FLG_STATIC_DATA };
	return &const_nist_224;
d164 1
a164 3
	static BIGNUM const_nist_256 = { (BN_ULONG *)_nist_p_256,
		BN_NIST_256_TOP, BN_NIST_256_TOP, 0, BN_FLG_STATIC_DATA };
	return &const_nist_256;
d169 1
a169 3
	static BIGNUM const_nist_384 = { (BN_ULONG *)_nist_p_384,
		BN_NIST_384_TOP, BN_NIST_384_TOP, 0, BN_FLG_STATIC_DATA };
	return &const_nist_384;
d174 1
a174 3
	static BIGNUM const_nist_521 = { (BN_ULONG *)_nist_p_521,
		BN_NIST_521_TOP, BN_NIST_521_TOP, 0, BN_FLG_STATIC_DATA };
	return &const_nist_521;
a176 1
#define BN_NIST_ADD_ONE(a)	while (!(*(a)=(*(a)+1)&BN_MASK2)) ++(a);
d179 1
a179 1
        {
d181 8
a188 6
        BN_ULONG *_tmp1 = (buf), *_tmp2 = (a);
        for (i = (top); i != 0; i--)
                *_tmp1++ = *_tmp2++;
        for (i = (max) - (top); i != 0; i--)
                *_tmp1++ = (BN_ULONG) 0;
        }
d191 1
a191 1
        { 
d193 4
a196 4
        BN_ULONG *_tmp1 = (buf), *_tmp2 = (a);
        for (i = (top); i != 0; i--)
                *_tmp1++ = *_tmp2++;
        }
d241 5
a254 3
	if (top == BN_NIST_192_TOP)
		return BN_usub(r, a, field);

d289 5
d321 5
a334 3
	if (top == BN_NIST_224_TOP)
		return BN_usub(r, a, field);

d384 5
d420 5
a433 3
	if (top == BN_NIST_256_TOP)
		return BN_usub(r, a, field);

d528 5
d568 5
a581 3
	if (top == BN_NIST_384_TOP)
		return BN_usub(r, a, field);

d696 5
a715 1
	BN_ULONG *r_d;
d718 5
d726 19
a744 2
           (!(a->d[BN_NIST_521_TOP-1] & ~(BN_NIST_521_TOP_MASK)))))
		return (r == a)? 1 : (BN_copy(r ,a) != NULL);
d764 2
a765 4
	top = r->top;
	r_d = r->d;
	if (top == BN_NIST_521_TOP  && 
           (r_d[BN_NIST_521_TOP-1] & ~(BN_NIST_521_TOP_MASK)))
d767 1
a767 2
		BN_NIST_ADD_ONE(r_d)
		r->d[BN_NIST_521_TOP-1] &= BN_NIST_521_TOP_MASK; 
a768 1
	bn_correct_top(r);
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@a61 1

a67 1
/* pre-computed tables are "carry-less" values of modulus*(i+1) */
d69 4
a72 10
static const BN_ULONG _nist_p_192[][BN_NIST_192_TOP] = {
	{0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFEULL,0xFFFFFFFFFFFFFFFFULL},
	{0xFFFFFFFFFFFFFFFEULL,0xFFFFFFFFFFFFFFFDULL,0xFFFFFFFFFFFFFFFFULL},
	{0xFFFFFFFFFFFFFFFDULL,0xFFFFFFFFFFFFFFFCULL,0xFFFFFFFFFFFFFFFFULL}
	};
static const BN_ULONG _nist_p_192_sqr[] = {
	0x0000000000000001ULL,0x0000000000000002ULL,0x0000000000000001ULL,
	0xFFFFFFFFFFFFFFFEULL,0xFFFFFFFFFFFFFFFDULL,0xFFFFFFFFFFFFFFFFULL
	};
static const BN_ULONG _nist_p_224[][BN_NIST_224_TOP] = {
d74 2
a75 11
	 0xFFFFFFFFFFFFFFFFULL,0x00000000FFFFFFFFULL},
	{0x0000000000000002ULL,0xFFFFFFFE00000000ULL,
	 0xFFFFFFFFFFFFFFFFULL,0x00000001FFFFFFFFULL} /* this one is "carry-full" */
	};
static const BN_ULONG _nist_p_224_sqr[] = {
	0x0000000000000001ULL,0xFFFFFFFE00000000ULL,
	0xFFFFFFFFFFFFFFFFULL,0x0000000200000000ULL,
	0x0000000000000000ULL,0xFFFFFFFFFFFFFFFEULL,
	0xFFFFFFFFFFFFFFFFULL
	};
static const BN_ULONG _nist_p_256[][BN_NIST_256_TOP] = {
d77 5
a81 34
	 0x0000000000000000ULL,0xFFFFFFFF00000001ULL},
	{0xFFFFFFFFFFFFFFFEULL,0x00000001FFFFFFFFULL,
	 0x0000000000000000ULL,0xFFFFFFFE00000002ULL},
	{0xFFFFFFFFFFFFFFFDULL,0x00000002FFFFFFFFULL,
	 0x0000000000000000ULL,0xFFFFFFFD00000003ULL},
	{0xFFFFFFFFFFFFFFFCULL,0x00000003FFFFFFFFULL,
	 0x0000000000000000ULL,0xFFFFFFFC00000004ULL},
	{0xFFFFFFFFFFFFFFFBULL,0x00000004FFFFFFFFULL,
	 0x0000000000000000ULL,0xFFFFFFFB00000005ULL},
	};
static const BN_ULONG _nist_p_256_sqr[] = {
	0x0000000000000001ULL,0xFFFFFFFE00000000ULL,
	0xFFFFFFFFFFFFFFFFULL,0x00000001FFFFFFFEULL,
	0x00000001FFFFFFFEULL,0x00000001FFFFFFFEULL,
	0xFFFFFFFE00000001ULL,0xFFFFFFFE00000002ULL
	};
static const BN_ULONG _nist_p_384[][BN_NIST_384_TOP] = {
	{0x00000000FFFFFFFFULL,0xFFFFFFFF00000000ULL,0xFFFFFFFFFFFFFFFEULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	{0x00000001FFFFFFFEULL,0xFFFFFFFE00000000ULL,0xFFFFFFFFFFFFFFFDULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	{0x00000002FFFFFFFDULL,0xFFFFFFFD00000000ULL,0xFFFFFFFFFFFFFFFCULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	{0x00000003FFFFFFFCULL,0xFFFFFFFC00000000ULL,0xFFFFFFFFFFFFFFFBULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	{0x00000004FFFFFFFBULL,0xFFFFFFFB00000000ULL,0xFFFFFFFFFFFFFFFAULL,
	 0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL},
	};
static const BN_ULONG _nist_p_384_sqr[] = {
	0xFFFFFFFE00000001ULL,0x0000000200000000ULL,0xFFFFFFFE00000000ULL,
	0x0000000200000000ULL,0x0000000000000001ULL,0x0000000000000000ULL,
	0x00000001FFFFFFFEULL,0xFFFFFFFE00000000ULL,0xFFFFFFFFFFFFFFFDULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL
	};
a87 8
static const BN_ULONG _nist_p_521_sqr[] = {
	0x0000000000000001ULL,0x0000000000000000ULL,0x0000000000000000ULL,
	0x0000000000000000ULL,0x0000000000000000ULL,0x0000000000000000ULL,
	0x0000000000000000ULL,0x0000000000000000ULL,0xFFFFFFFFFFFFFC00ULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,0xFFFFFFFFFFFFFFFFULL,
	0xFFFFFFFFFFFFFFFFULL,0x000000000003FFFFULL
	};
d89 9
a97 57
static const BN_ULONG _nist_p_192[][BN_NIST_192_TOP] = {
	{0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFD,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFD,0xFFFFFFFF,0xFFFFFFFC,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF}
	};
static const BN_ULONG _nist_p_192_sqr[] = {
	0x00000001,0x00000000,0x00000002,0x00000000,0x00000001,0x00000000,
	0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFD,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF
	};
static const BN_ULONG _nist_p_224[][BN_NIST_224_TOP] = {
	{0x00000001,0x00000000,0x00000000,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0x00000002,0x00000000,0x00000000,0xFFFFFFFE,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF}
	};
static const BN_ULONG _nist_p_224_sqr[] = {
	0x00000001,0x00000000,0x00000000,0xFFFFFFFE,
	0xFFFFFFFF,0xFFFFFFFF,0x00000000,0x00000002,
	0x00000000,0x00000000,0xFFFFFFFE,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF
	};
static const BN_ULONG _nist_p_256[][BN_NIST_256_TOP] = {
	{0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0x00000000,
	 0x00000000,0x00000000,0x00000001,0xFFFFFFFF},
	{0xFFFFFFFE,0xFFFFFFFF,0xFFFFFFFF,0x00000001,
	 0x00000000,0x00000000,0x00000002,0xFFFFFFFE},
	{0xFFFFFFFD,0xFFFFFFFF,0xFFFFFFFF,0x00000002,
	 0x00000000,0x00000000,0x00000003,0xFFFFFFFD},
	{0xFFFFFFFC,0xFFFFFFFF,0xFFFFFFFF,0x00000003,
	 0x00000000,0x00000000,0x00000004,0xFFFFFFFC},
	{0xFFFFFFFB,0xFFFFFFFF,0xFFFFFFFF,0x00000004,
	 0x00000000,0x00000000,0x00000005,0xFFFFFFFB},
	};
static const BN_ULONG _nist_p_256_sqr[] = {
	0x00000001,0x00000000,0x00000000,0xFFFFFFFE,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFE,0x00000001,
	0xFFFFFFFE,0x00000001,0xFFFFFFFE,0x00000001,
	0x00000001,0xFFFFFFFE,0x00000002,0xFFFFFFFE
	};
static const BN_ULONG _nist_p_384[][BN_NIST_384_TOP] = {
	{0xFFFFFFFF,0x00000000,0x00000000,0xFFFFFFFF,0xFFFFFFFE,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFE,0x00000001,0x00000000,0xFFFFFFFE,0xFFFFFFFD,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFD,0x00000002,0x00000000,0xFFFFFFFD,0xFFFFFFFC,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFC,0x00000003,0x00000000,0xFFFFFFFC,0xFFFFFFFB,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	{0xFFFFFFFB,0x00000004,0x00000000,0xFFFFFFFB,0xFFFFFFFA,0xFFFFFFFF,
	 0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF},
	};
static const BN_ULONG _nist_p_384_sqr[] = {
	0x00000001,0xFFFFFFFE,0x00000000,0x00000002,0x00000000,0xFFFFFFFE,
	0x00000000,0x00000002,0x00000001,0x00000000,0x00000000,0x00000000,
	0xFFFFFFFE,0x00000001,0x00000000,0xFFFFFFFE,0xFFFFFFFD,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF
	};
a101 10
static const BN_ULONG _nist_p_521_sqr[] = {
	0x00000001,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
	0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
	0x00000000,0x00000000,0x00000000,0x00000000,0xFFFFFC00,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,
	0xFFFFFFFF,0xFFFFFFFF,0x0003FFFF
	};
#else
#error "unsupported BN_BITS2"
a103 47

static const BIGNUM _bignum_nist_p_192 =
	{
	(BN_ULONG *)_nist_p_192[0],
	BN_NIST_192_TOP,
	BN_NIST_192_TOP,
	0,
	BN_FLG_STATIC_DATA
	};

static const BIGNUM _bignum_nist_p_224 =
	{
	(BN_ULONG *)_nist_p_224[0],
	BN_NIST_224_TOP,
	BN_NIST_224_TOP,
	0,
	BN_FLG_STATIC_DATA
	};

static const BIGNUM _bignum_nist_p_256 =
	{
	(BN_ULONG *)_nist_p_256[0],
	BN_NIST_256_TOP,
	BN_NIST_256_TOP,
	0,
	BN_FLG_STATIC_DATA
	};

static const BIGNUM _bignum_nist_p_384 =
	{
	(BN_ULONG *)_nist_p_384[0],
	BN_NIST_384_TOP,
	BN_NIST_384_TOP,
	0,
	BN_FLG_STATIC_DATA
	};

static const BIGNUM _bignum_nist_p_521 =
	{
	(BN_ULONG *)_nist_p_521,
	BN_NIST_521_TOP,
	BN_NIST_521_TOP,
	0,
	BN_FLG_STATIC_DATA
	};


d106 3
a108 1
	return &_bignum_nist_p_192;
d113 3
a115 1
	return &_bignum_nist_p_224;
d120 3
a122 1
	return &_bignum_nist_p_256;
d127 3
a129 1
	return &_bignum_nist_p_384;
d134 3
a136 1
	return &_bignum_nist_p_521;
d139 1
d142 1
a142 1
	{
d144 6
a149 10
	BN_ULONG *_tmp1 = (buf), *_tmp2 = (a);

#ifdef BN_DEBUG
	OPENSSL_assert(top <= max);
#endif
	for (i = (top); i != 0; i--)
		*_tmp1++ = *_tmp2++;
	for (i = (max) - (top); i != 0; i--)
		*_tmp1++ = (BN_ULONG) 0;
	}
d152 1
a152 1
	{ 
d154 4
a157 4
	BN_ULONG *_tmp1 = (buf), *_tmp2 = (a);
	for (i = (top); i != 0; i--)
		*_tmp1++ = *_tmp2++;
	}
d162 3
a164 8
/*
 * two following macros are implemented under assumption that they
 * are called in a sequence with *ascending* n, i.e. as they are...
 */
#define bn_cp_32_naked(to, n, from, m)	(((n)&1)?(to[(n)/2]|=((m)&1)?(from[(m)/2]&BN_MASK2h):(from[(m)/2]<<32))\
						:(to[(n)/2] =((m)&1)?(from[(m)/2]>>32):(from[(m)/2]&BN_MASK2l)))
#define bn_32_set_0(to, n)		(((n)&1)?(to[(n)/2]&=BN_MASK2l):(to[(n)/2]=0));
#define bn_cp_32(to,n,from,m)		((m)>=0)?bn_cp_32_naked(to,n,from,m):bn_32_set_0(to,n)
d185 1
a185 1
	bn_cp_64(to, 0, from, (a3) - 3) \
d187 1
a187 1
	bn_cp_64(to, 2, from, (a1) - 3) \
a200 10
	static const BIGNUM _bignum_nist_p_192_sqr = {
		(BN_ULONG *)_nist_p_192_sqr,
		sizeof(_nist_p_192_sqr)/sizeof(_nist_p_192_sqr[0]),
		sizeof(_nist_p_192_sqr)/sizeof(_nist_p_192_sqr[0]),
		0,BN_FLG_STATIC_DATA };

	field = &_bignum_nist_p_192; /* just to make sure */

 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_192_sqr)>=0)
		return BN_nnmod(r, a, field, ctx);
d211 3
d227 5
a231 1
	carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);
d233 5
a237 1
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);
d239 4
a242 6
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);

	if (carry > 0)
		carry = (int)bn_sub_words(r_d,r_d,_nist_p_192[carry-1],BN_NIST_192_TOP);
	else
		carry = 1;
a243 9
	/*
	 * we need 'if (carry==0 || result>=modulus) result-=modulus;'
	 * as comparison implies subtraction, we can write
	 * 'tmp=result-modulus; if (!carry || !borrow) result=tmp;'
	 * this is what happens below, but without explicit if:-) a.
	 */
	mask  = 0-(size_t)bn_sub_words(c_d,r_d,_nist_p_192[0],BN_NIST_192_TOP);
	mask &= 0-(size_t)carry;
	res   = (BN_ULONG *)(((size_t)c_d&~mask) | ((size_t)r_d&mask));
a250 2
typedef BN_ULONG (*bn_addsub_f)(BN_ULONG *,const BN_ULONG *,const BN_ULONG *,int);

d253 7
a259 7
	bn_cp_32(to, 0, from, (a7) - 7) \
	bn_cp_32(to, 1, from, (a6) - 7) \
	bn_cp_32(to, 2, from, (a5) - 7) \
	bn_cp_32(to, 3, from, (a4) - 7) \
	bn_cp_32(to, 4, from, (a3) - 7) \
	bn_cp_32(to, 5, from, (a2) - 7) \
	bn_cp_32(to, 6, from, (a1) - 7) \
d265 1
a273 12
	union { bn_addsub_f f; size_t p; } u;
	static const BIGNUM _bignum_nist_p_224_sqr = {
		(BN_ULONG *)_nist_p_224_sqr,
		sizeof(_nist_p_224_sqr)/sizeof(_nist_p_224_sqr[0]),
		sizeof(_nist_p_224_sqr)/sizeof(_nist_p_224_sqr[0]),
		0,BN_FLG_STATIC_DATA };


	field = &_bignum_nist_p_224; /* just to make sure */

 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_224_sqr)>=0)
		return BN_nnmod(r, a, field, ctx);
d284 3
a296 8
#if BN_BITS2==64
	/* copy upper 256 bits of 448 bit number ... */
	nist_cp_bn_0(t_d, a_d + (BN_NIST_224_TOP-1), top - (BN_NIST_224_TOP-1), BN_NIST_224_TOP);
	/* ... and right shift by 32 to obtain upper 224 bits */
	nist_set_224(buf, t_d, 14, 13, 12, 11, 10, 9, 8);
	/* truncate lower part to 224 bits too */
	r_d[BN_NIST_224_TOP-1] &= BN_MASK2l;
#else
d298 1
a298 1
#endif
d300 5
a304 1
	carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);
d306 5
a310 1
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);
d312 9
a320 1
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);
d322 5
a326 1
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);
d328 4
a331 9
#if BN_BITS2==64
	carry = (int)(r_d[BN_NIST_224_TOP-1]>>32);
#endif
	u.f = bn_sub_words;
	if (carry > 0)
		{
		carry = (int)bn_sub_words(r_d,r_d,_nist_p_224[carry-1],BN_NIST_224_TOP);
#if BN_BITS2==64
		carry=(int)(~(r_d[BN_NIST_224_TOP-1]>>32))&1;
a332 21
		}
	else if (carry < 0)
		{
		/* it's a bit more comlicated logic in this case.
		 * if bn_add_words yields no carry, then result
		 * has to be adjusted by unconditionally *adding*
		 * the modulus. but if it does, then result has
		 * to be compared to the modulus and conditionally
		 * adjusted by *subtracting* the latter. */
		carry = (int)bn_add_words(r_d,r_d,_nist_p_224[-carry-1],BN_NIST_224_TOP);
		mask = 0-(size_t)carry;
		u.p = ((size_t)bn_sub_words&mask) | ((size_t)bn_add_words&~mask);
		}
	else
		carry = 1;

	/* otherwise it's effectively same as in BN_nist_mod_192... */
	mask  = 0-(size_t)(*u.f)(c_d,r_d,_nist_p_224[0],BN_NIST_224_TOP);
	mask &= 0-(size_t)carry;
	res   = (BN_ULONG *)(((size_t)c_d&~mask) | ((size_t)r_d&mask));
	nist_cp_bn(r_d, res, BN_NIST_224_TOP);
d337 3
d344 8
a351 8
	bn_cp_32(to, 0, from, (a8) - 8) \
	bn_cp_32(to, 1, from, (a7) - 8) \
	bn_cp_32(to, 2, from, (a6) - 8) \
	bn_cp_32(to, 3, from, (a5) - 8) \
	bn_cp_32(to, 4, from, (a4) - 8) \
	bn_cp_32(to, 5, from, (a3) - 8) \
	bn_cp_32(to, 6, from, (a2) - 8) \
	bn_cp_32(to, 7, from, (a1) - 8) \
d357 1
a365 11
	union { bn_addsub_f f; size_t p; } u;
	static const BIGNUM _bignum_nist_p_256_sqr = {
		(BN_ULONG *)_nist_p_256_sqr,
		sizeof(_nist_p_256_sqr)/sizeof(_nist_p_256_sqr[0]),
		sizeof(_nist_p_256_sqr)/sizeof(_nist_p_256_sqr[0]),
		0,BN_FLG_STATIC_DATA };

	field = &_bignum_nist_p_256; /* just to make sure */

 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_256_sqr)>=0)
		return BN_nnmod(r, a, field, ctx);
d376 3
d394 16
a409 17
	nist_set_256(c_d, buf, 0, 15, 14, 13, 12, 0, 0, 0);
	carry = (int)bn_add_words(t_d, t_d, c_d, BN_NIST_256_TOP);
	/* left shift */
		{
		register BN_ULONG *ap,t,c;
		ap = t_d;
		c=0;
		for (i = BN_NIST_256_TOP; i != 0; --i)
			{
			t= *ap;
			*(ap++)=((t<<1)|c)&BN_MASK2;
			c=(t & BN_TBIT)?1:0;
			}
		carry <<= 1;
		carry  |= c;
		}
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);
d412 5
a416 1
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);
d419 5
a423 1
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);
d426 9
a434 1
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
d437 9
a445 1
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
d448 9
a456 1
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
d459 5
a463 1
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);
d465 5
a469 17
	/* see BN_nist_mod_224 for explanation */
	u.f = bn_sub_words;
	if (carry > 0)
		carry = (int)bn_sub_words(r_d,r_d,_nist_p_256[carry-1],BN_NIST_256_TOP);
	else if (carry < 0)
		{
		carry = (int)bn_add_words(r_d,r_d,_nist_p_256[-carry-1],BN_NIST_256_TOP);
		mask = 0-(size_t)carry;
		u.p = ((size_t)bn_sub_words&mask) | ((size_t)bn_add_words&~mask);
		}
	else
		carry = 1;

	mask  = 0-(size_t)(*u.f)(c_d,r_d,_nist_p_256[0],BN_NIST_256_TOP);
	mask &= 0-(size_t)carry;
	res   = (BN_ULONG *)(((size_t)c_d&~mask) | ((size_t)r_d&mask));
	nist_cp_bn(r_d, res, BN_NIST_256_TOP);
d474 3
d481 12
a492 12
	bn_cp_32(to, 0, from,  (a12) - 12) \
	bn_cp_32(to, 1, from,  (a11) - 12) \
	bn_cp_32(to, 2, from,  (a10) - 12) \
	bn_cp_32(to, 3, from,  (a9) - 12)  \
	bn_cp_32(to, 4, from,  (a8) - 12)  \
	bn_cp_32(to, 5, from,  (a7) - 12)  \
	bn_cp_32(to, 6, from,  (a6) - 12)  \
	bn_cp_32(to, 7, from,  (a5) - 12)  \
	bn_cp_32(to, 8, from,  (a4) - 12)  \
	bn_cp_32(to, 9, from,  (a3) - 12)  \
	bn_cp_32(to, 10, from, (a2) - 12)  \
	bn_cp_32(to, 11, from, (a1) - 12)  \
d498 1
a506 12
	union { bn_addsub_f f; size_t p; } u;
	static const BIGNUM _bignum_nist_p_384_sqr = {
		(BN_ULONG *)_nist_p_384_sqr,
		sizeof(_nist_p_384_sqr)/sizeof(_nist_p_384_sqr[0]),
		sizeof(_nist_p_384_sqr)/sizeof(_nist_p_384_sqr[0]),
		0,BN_FLG_STATIC_DATA };


	field = &_bignum_nist_p_384; /* just to make sure */

 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_384_sqr)>=0)
		return BN_nnmod(r, a, field, ctx);
d517 3
d547 1
a547 1
	carry = (int)bn_add_words(r_d+(128/BN_BITS2), r_d+(128/BN_BITS2), 
d549 13
d563 5
a567 1
	carry += (int)bn_add_words(r_d, r_d, buf, BN_NIST_384_TOP);
d570 5
a574 1
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
d577 5
a581 1
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
d584 5
a588 1
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
d591 5
a595 1
	carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);
d598 9
a606 1
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);
d609 9
a617 1
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);
d620 5
a624 14
	carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);

	/* see BN_nist_mod_224 for explanation */
	u.f = bn_sub_words;
	if (carry > 0)
		carry = (int)bn_sub_words(r_d,r_d,_nist_p_384[carry-1],BN_NIST_384_TOP);
	else if (carry < 0)
		{
		carry = (int)bn_add_words(r_d,r_d,_nist_p_384[-carry-1],BN_NIST_384_TOP);
		mask = 0-(size_t)carry;
		u.p = ((size_t)bn_sub_words&mask) | ((size_t)bn_add_words&~mask);
		}
	else
		carry = 1;
a625 3
	mask  = 0-(size_t)(*u.f)(c_d,r_d,_nist_p_384[0],BN_NIST_384_TOP);
	mask &= 0-(size_t)carry;
	res   = (BN_ULONG *)(((size_t)c_d&~mask) | ((size_t)r_d&mask));
d627 4
d635 3
a639 4
#define BN_NIST_521_RSHIFT	(521%BN_BITS2)
#define BN_NIST_521_LSHIFT	(BN_BITS2-BN_NIST_521_RSHIFT)
#define BN_NIST_521_TOP_MASK	((BN_ULONG)BN_MASK2>>BN_NIST_521_LSHIFT)

d643 13
a655 23
	int	top = a->top, i;
	BN_ULONG *r_d, *a_d = a->d,
		 t_d[BN_NIST_521_TOP],
		 val,tmp,*res;
	size_t	mask;
	static const BIGNUM _bignum_nist_p_521_sqr = {
		(BN_ULONG *)_nist_p_521_sqr,
		sizeof(_nist_p_521_sqr)/sizeof(_nist_p_521_sqr[0]),
		sizeof(_nist_p_521_sqr)/sizeof(_nist_p_521_sqr[0]),
		0,BN_FLG_STATIC_DATA };

	field = &_bignum_nist_p_521; /* just to make sure */

 	if (BN_is_negative(a) || BN_ucmp(a,&_bignum_nist_p_521_sqr)>=0)
		return BN_nnmod(r, a, field, ctx);

	i = BN_ucmp(field, a);
	if (i == 0)
		{
		BN_zero(r);
		return 1;
		}
	else if (i > 0)
d658 22
a679 14
	if (r != a)
		{
		if (!bn_wexpand(r,BN_NIST_521_TOP))
			return 0;
		r_d = r->d;
		nist_cp_bn(r_d,a_d, BN_NIST_521_TOP);
		}
	else
		r_d = a_d;

	/* upper 521 bits, copy ... */
	nist_cp_bn_0(t_d,a_d + (BN_NIST_521_TOP-1), top - (BN_NIST_521_TOP-1),BN_NIST_521_TOP);
	/* ... and right shift */
	for (val=t_d[0],i=0; i<BN_NIST_521_TOP-1; i++)
d681 2
a682 3
		tmp = val>>BN_NIST_521_RSHIFT;
		val = t_d[i+1];
		t_d[i] = (tmp | val<<BN_NIST_521_LSHIFT) & BN_MASK2;
a683 9
	t_d[i] = val>>BN_NIST_521_RSHIFT;
	/* lower 521 bits */
	r_d[i] &= BN_NIST_521_TOP_MASK;

	bn_add_words(r_d,r_d,t_d,BN_NIST_521_TOP);
	mask = 0-(size_t)bn_sub_words(t_d,r_d,_nist_p_521,BN_NIST_521_TOP);
	res  = (BN_ULONG *)(((size_t)t_d&~mask) | ((size_t)r_d&mask));
	nist_cp_bn(r_d,res,BN_NIST_521_TOP);
	r->top = BN_NIST_521_TOP;
d686 6
a691 1
	return 1;
@


1.1.1.3
log
@import OpenSSL 1.0.0e
@
text
@d357 1
a357 1
	PTR_SIZE_INT mask;
d408 3
a410 4
	mask  = 0-(PTR_SIZE_INT)bn_sub_words(c_d,r_d,_nist_p_192[0],BN_NIST_192_TOP);
	mask &= 0-(PTR_SIZE_INT)carry;
	res   = (BN_ULONG *)
	 (((PTR_SIZE_INT)c_d&~mask) | ((PTR_SIZE_INT)r_d&mask));
d441 2
a442 2
	PTR_SIZE_INT mask;
	union { bn_addsub_f f; PTR_SIZE_INT p; } u;
d513 2
a514 3
		mask = 0-(PTR_SIZE_INT)carry;
		u.p = ((PTR_SIZE_INT)bn_sub_words&mask) |
		 ((PTR_SIZE_INT)bn_add_words&~mask);
d520 3
a522 4
	mask  = 0-(PTR_SIZE_INT)(*u.f)(c_d,r_d,_nist_p_224[0],BN_NIST_224_TOP);
	mask &= 0-(PTR_SIZE_INT)carry;
	res   = (BN_ULONG *)(((PTR_SIZE_INT)c_d&~mask) |
	 ((PTR_SIZE_INT)r_d&mask));
d552 2
a553 2
	PTR_SIZE_INT mask;
	union { bn_addsub_f f; PTR_SIZE_INT p; } u;
d632 2
a633 3
		mask = 0-(PTR_SIZE_INT)carry;
		u.p = ((PTR_SIZE_INT)bn_sub_words&mask) |
		 ((PTR_SIZE_INT)bn_add_words&~mask);
d638 3
a640 4
	mask  = 0-(PTR_SIZE_INT)(*u.f)(c_d,r_d,_nist_p_256[0],BN_NIST_256_TOP);
	mask &= 0-(PTR_SIZE_INT)carry;
	res   = (BN_ULONG *)(((PTR_SIZE_INT)c_d&~mask) |
	 ((PTR_SIZE_INT)r_d&mask));
d674 2
a675 2
	PTR_SIZE_INT mask;
	union { bn_addsub_f f; PTR_SIZE_INT p; } u;
d757 2
a758 3
		mask = 0-(PTR_SIZE_INT)carry;
		u.p = ((PTR_SIZE_INT)bn_sub_words&mask) |
		 ((PTR_SIZE_INT)bn_add_words&~mask);
d763 3
a765 4
	mask  = 0-(PTR_SIZE_INT)(*u.f)(c_d,r_d,_nist_p_384[0],BN_NIST_384_TOP);
	mask &= 0-(PTR_SIZE_INT)carry;
	res   = (BN_ULONG *)(((PTR_SIZE_INT)c_d&~mask) |
	 ((PTR_SIZE_INT)r_d&mask));
d784 1
a784 1
	PTR_SIZE_INT mask;
d829 2
a830 3
	mask = 0-(PTR_SIZE_INT)bn_sub_words(t_d,r_d,_nist_p_521,BN_NIST_521_TOP);
	res  = (BN_ULONG *)(((PTR_SIZE_INT)t_d&~mask) |
	 ((PTR_SIZE_INT)r_d&mask));
@


1.1.1.4
log
@import OpenSSL-1.0.1c
@
text
@a321 7
# if defined(L_ENDIAN)
#  if defined(__arch64__)
#   define NIST_INT64 long
#  else
#   define NIST_INT64 long long
#  endif
# endif
d333 1
d336 1
a336 5
# if defined(_WIN32) && !defined(__GNUC__)
#  define NIST_INT64 __int64
# elif defined(BN_LLONG)
#  define NIST_INT64 long long
# endif
d339 1
d353 3
a355 5
	union	{
		BN_ULONG	bn[BN_NIST_192_TOP];
		unsigned int	ui[BN_NIST_192_TOP*sizeof(BN_ULONG)/sizeof(unsigned int)];
		} buf;
	BN_ULONG c_d[BN_NIST_192_TOP],
d388 1
a388 27
	nist_cp_bn_0(buf.bn, a_d + BN_NIST_192_TOP, top - BN_NIST_192_TOP, BN_NIST_192_TOP);

#if defined(NIST_INT64)
	{
	NIST_INT64		acc;	/* accumulator */
	unsigned int		*rp=(unsigned int *)r_d;
	const unsigned int	*bp=(const unsigned int *)buf.ui;

	acc  = rp[0];	acc += bp[3*2-6];
			acc += bp[5*2-6]; rp[0] = (unsigned int)acc; acc >>= 32;

	acc += rp[1];	acc += bp[3*2-5];
			acc += bp[5*2-5]; rp[1] = (unsigned int)acc; acc >>= 32;

	acc += rp[2];	acc += bp[3*2-6];
			acc += bp[4*2-6];
			acc += bp[5*2-6]; rp[2] = (unsigned int)acc; acc >>= 32;

	acc += rp[3];	acc += bp[3*2-5];
			acc += bp[4*2-5];
			acc += bp[5*2-5]; rp[3] = (unsigned int)acc; acc >>= 32;

	acc += rp[4];	acc += bp[4*2-6];
			acc += bp[5*2-6]; rp[4] = (unsigned int)acc; acc >>= 32;

	acc += rp[5];	acc += bp[4*2-5];
			acc += bp[5*2-5]; rp[5] = (unsigned int)acc;
d390 1
a390 7
	carry = (int)(acc>>32);
	}
#else
	{
	BN_ULONG t_d[BN_NIST_192_TOP];

	nist_set_192(t_d, buf.bn, 0, 3, 3);
d392 1
a392 1
	nist_set_192(t_d, buf.bn, 4, 4, 0);
d394 1
a394 1
	nist_set_192(t_d, buf.bn, 5, 5, 5)
d396 1
a396 2
	}
#endif
d438 2
a439 1
	BN_ULONG buf[BN_NIST_224_TOP],
d477 1
a477 1
	nist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP-1), top - (BN_NIST_224_TOP-1), BN_NIST_224_TOP);
d479 1
a479 1
	nist_set_224(buf, c_d, 14, 13, 12, 11, 10, 9, 8);
a484 40

#if defined(NIST_INT64) && BN_BITS2!=64
	{
	NIST_INT64		acc;	/* accumulator */
	unsigned int		*rp=(unsigned int *)r_d;
	const unsigned int	*bp=(const unsigned int *)buf;

	acc  = rp[0];	acc -= bp[7-7];
			acc -= bp[11-7]; rp[0] = (unsigned int)acc; acc >>= 32;

	acc += rp[1];	acc -= bp[8-7];
			acc -= bp[12-7]; rp[1] = (unsigned int)acc; acc >>= 32;

	acc += rp[2];	acc -= bp[9-7];
			acc -= bp[13-7]; rp[2] = (unsigned int)acc; acc >>= 32;

	acc += rp[3];	acc += bp[7-7];
			acc += bp[11-7];
			acc -= bp[10-7]; rp[3] = (unsigned int)acc; acc>>= 32;

	acc += rp[4];	acc += bp[8-7];
			acc += bp[12-7];
			acc -= bp[11-7]; rp[4] = (unsigned int)acc; acc >>= 32;

	acc += rp[5];	acc += bp[9-7];
			acc += bp[13-7];
			acc -= bp[12-7]; rp[5] = (unsigned int)acc; acc >>= 32;

	acc += rp[6];	acc += bp[10-7];
			acc -= bp[13-7]; rp[6] = (unsigned int)acc;

	carry = (int)(acc>>32);
# if BN_BITS2==64
	rp[7] = carry;
# endif
	}	
#else
	{
	BN_ULONG t_d[BN_NIST_224_TOP];

a496 2
	}
#endif
d551 3
a553 5
	union	{
		BN_ULONG bn[BN_NIST_256_TOP];
		unsigned int ui[BN_NIST_256_TOP*sizeof(BN_ULONG)/sizeof(unsigned int)];
		} buf;
	BN_ULONG c_d[BN_NIST_256_TOP],
d587 1
a587 76
	nist_cp_bn_0(buf.bn, a_d + BN_NIST_256_TOP, top - BN_NIST_256_TOP, BN_NIST_256_TOP);

#if defined(NIST_INT64)
	{
	NIST_INT64		acc;	/* accumulator */
	unsigned int		*rp=(unsigned int *)r_d;
	const unsigned int	*bp=(const unsigned int *)buf.ui;

	acc = rp[0];	acc += bp[8-8];
			acc += bp[9-8];
			acc -= bp[11-8];
			acc -= bp[12-8];
			acc -= bp[13-8];
			acc -= bp[14-8]; rp[0] = (unsigned int)acc; acc >>= 32;

	acc += rp[1];	acc += bp[9-8];
			acc += bp[10-8];
			acc -= bp[12-8];
			acc -= bp[13-8];
			acc -= bp[14-8];
			acc -= bp[15-8]; rp[1] = (unsigned int)acc; acc >>= 32;

	acc += rp[2];	acc += bp[10-8];
			acc += bp[11-8];
			acc -= bp[13-8];
			acc -= bp[14-8];
			acc -= bp[15-8]; rp[2] = (unsigned int)acc; acc >>= 32;

	acc += rp[3];	acc += bp[11-8];
			acc += bp[11-8];
			acc += bp[12-8];
			acc += bp[12-8];
			acc += bp[13-8];
			acc -= bp[15-8];
			acc -= bp[8-8];
			acc -= bp[9-8];  rp[3] = (unsigned int)acc; acc >>= 32;

	acc += rp[4];	acc += bp[12-8];
			acc += bp[12-8];
			acc += bp[13-8];
			acc += bp[13-8];
			acc += bp[14-8];
			acc -= bp[9-8];
			acc -= bp[10-8]; rp[4] = (unsigned int)acc; acc >>= 32;

	acc += rp[5];	acc += bp[13-8];
			acc += bp[13-8];
			acc += bp[14-8];
			acc += bp[14-8];
			acc += bp[15-8];
			acc -= bp[10-8];
			acc -= bp[11-8]; rp[5] = (unsigned int)acc; acc >>= 32;

	acc += rp[6];	acc += bp[14-8];
			acc += bp[14-8];
			acc += bp[15-8];
			acc += bp[15-8];
			acc += bp[14-8];
			acc += bp[13-8];
			acc -= bp[8-8];
			acc -= bp[9-8];  rp[6] = (unsigned int)acc; acc >>= 32;

	acc += rp[7];	acc += bp[15-8];
			acc += bp[15-8];
			acc += bp[15-8];
			acc += bp[8 -8];
			acc -= bp[10-8];
			acc -= bp[11-8];
			acc -= bp[12-8];
			acc -= bp[13-8]; rp[7] = (unsigned int)acc;

	carry = (int)(acc>>32);
	}
#else
	{
	BN_ULONG t_d[BN_NIST_256_TOP];
d590 1
a590 1
	nist_set_256(t_d, buf.bn, 15, 14, 13, 12, 11, 0, 0, 0);
d592 1
a592 1
	nist_set_256(c_d, buf.bn, 0, 15, 14, 13, 12, 0, 0, 0);
d610 1
a610 1
	nist_set_256(t_d, buf.bn, 15, 14, 0, 0, 0, 10, 9, 8);
d613 1
a613 1
	nist_set_256(t_d, buf.bn, 8, 13, 15, 14, 13, 11, 10, 9);
d616 1
a616 1
	nist_set_256(t_d, buf.bn, 10, 8, 0, 0, 0, 13, 12, 11);
d619 1
a619 1
	nist_set_256(t_d, buf.bn, 11, 9, 0, 0, 15, 14, 13, 12);
d622 1
a622 1
	nist_set_256(t_d, buf.bn, 12, 0, 10, 9, 8, 15, 14, 13);
d625 1
a625 1
	nist_set_256(t_d, buf.bn, 13, 0, 11, 10, 9, 0, 15, 14);
a627 2
	}
#endif
d675 3
a677 5
	union	{
		BN_ULONG bn[BN_NIST_384_TOP];
		unsigned int ui[BN_NIST_384_TOP*sizeof(BN_ULONG)/sizeof(unsigned int)];
		} buf;
	BN_ULONG c_d[BN_NIST_384_TOP],
d712 1
a712 91
	nist_cp_bn_0(buf.bn, a_d + BN_NIST_384_TOP, top - BN_NIST_384_TOP, BN_NIST_384_TOP);

#if defined(NIST_INT64)
	{
	NIST_INT64		acc;	/* accumulator */
	unsigned int		*rp=(unsigned int *)r_d;
	const unsigned int	*bp=(const unsigned int *)buf.ui;

	acc = rp[0];	acc += bp[12-12];
			acc += bp[21-12];
			acc += bp[20-12];
			acc -= bp[23-12]; rp[0] = (unsigned int)acc; acc >>= 32;

	acc += rp[1];	acc += bp[13-12];
			acc += bp[22-12];
			acc += bp[23-12];
			acc -= bp[12-12];
			acc -= bp[20-12]; rp[1] = (unsigned int)acc; acc >>= 32;

	acc += rp[2];	acc += bp[14-12];
			acc += bp[23-12];
			acc -= bp[13-12];
			acc -= bp[21-12]; rp[2] = (unsigned int)acc; acc >>= 32;

	acc += rp[3];	acc += bp[15-12];
			acc += bp[12-12];
			acc += bp[20-12];
			acc += bp[21-12];
			acc -= bp[14-12];
			acc -= bp[22-12];
			acc -= bp[23-12]; rp[3] = (unsigned int)acc; acc >>= 32;

	acc += rp[4];	acc += bp[21-12];
			acc += bp[21-12];
			acc += bp[16-12];
			acc += bp[13-12];
			acc += bp[12-12];
			acc += bp[20-12];
			acc += bp[22-12];
			acc -= bp[15-12];
			acc -= bp[23-12];
			acc -= bp[23-12]; rp[4] = (unsigned int)acc; acc >>= 32;

	acc += rp[5];	acc += bp[22-12];
			acc += bp[22-12];
			acc += bp[17-12];
			acc += bp[14-12];
			acc += bp[13-12];
			acc += bp[21-12];
			acc += bp[23-12];
			acc -= bp[16-12]; rp[5] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[6];	acc += bp[23-12];
			acc += bp[23-12];
			acc += bp[18-12];
			acc += bp[15-12];
			acc += bp[14-12];
			acc += bp[22-12];
			acc -= bp[17-12]; rp[6] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[7];	acc += bp[19-12];
			acc += bp[16-12];
			acc += bp[15-12];
			acc += bp[23-12];
			acc -= bp[18-12]; rp[7] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[8];	acc += bp[20-12];
			acc += bp[17-12];
			acc += bp[16-12];
			acc -= bp[19-12]; rp[8] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[9];	acc += bp[21-12];
			acc += bp[18-12];
			acc += bp[17-12];
			acc -= bp[20-12]; rp[9] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[10];	acc += bp[22-12];
			acc += bp[19-12];
			acc += bp[18-12];
			acc -= bp[21-12]; rp[10] = (unsigned int)acc; acc >>= 32;
			
	acc += rp[11];	acc += bp[23-12];
			acc += bp[20-12];
			acc += bp[19-12];
			acc -= bp[22-12]; rp[11] = (unsigned int)acc;

	carry = (int)(acc>>32);
	}
#else
	{
	BN_ULONG t_d[BN_NIST_384_TOP];
d715 1
a715 1
	nist_set_256(t_d, buf.bn, 0, 0, 0, 0, 0, 23-4, 22-4, 21-4);
d732 1
a732 1
	carry += (int)bn_add_words(r_d, r_d, buf.bn, BN_NIST_384_TOP);
d734 1
a734 1
	nist_set_384(t_d,buf.bn,20,19,18,17,16,15,14,13,12,23,22,21);
d737 1
a737 1
	nist_set_384(t_d,buf.bn,19,18,17,16,15,14,13,12,20,0,23,0);
d740 1
a740 1
	nist_set_384(t_d, buf.bn,0,0,0,0,23,22,21,20,0,0,0,0);
d743 1
a743 1
	nist_set_384(t_d,buf.bn,0,0,0,0,0,0,23,22,21,0,0,20);
d746 1
a746 1
	nist_set_384(t_d,buf.bn,22,21,20,19,18,17,16,15,14,13,12,23);
d749 1
a749 1
	nist_set_384(t_d,buf.bn,0,0,0,0,0,0,0,23,22,21,20,0);
d752 1
a752 1
	nist_set_384(t_d,buf.bn,0,0,0,0,0,0,0,23,23,0,0,0);
a754 2
	}
#endif
@


1.1.1.5
log
@Import OpenSSL 1.0.1g
@
text
@d289 1
a289 1
static void nist_cp_bn_0(BN_ULONG *dst, const BN_ULONG *src, int top, int max)
d292 1
d297 4
a300 4
	for (i = 0; i < top; i++)
		dst[i] = src[i];
	for (; i < max; i++)
		dst[i] = 0;
d303 1
a303 1
static void nist_cp_bn(BN_ULONG *dst, const BN_ULONG *src, int top)
d306 3
a308 3

	for (i = 0; i < top; i++)
		dst[i] = src[i];
a453 1
	res   = c_d;
d455 1
a455 1
	 (((PTR_SIZE_INT)res&~mask) | ((PTR_SIZE_INT)r_d&mask));
d482 2
a483 5
	union	{
		BN_ULONG	bn[BN_NIST_224_TOP];
		unsigned int	ui[BN_NIST_224_TOP*sizeof(BN_ULONG)/sizeof(unsigned int)];
		} buf;
	BN_ULONG c_d[BN_NIST_224_TOP],
d522 1
a522 1
	nist_set_224(buf.bn, c_d, 14, 13, 12, 11, 10, 9, 8);
d526 1
a526 1
	nist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP, BN_NIST_224_TOP);
d533 1
a533 1
	const unsigned int	*bp=(const unsigned int *)buf.ui;
d568 1
a568 1
	nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);
d570 1
a570 1
	nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);
d572 1
a572 1
	nist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);
d574 1
a574 1
	nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);
d609 1
a609 2
	res   = c_d;
	res   = (BN_ULONG *)(((PTR_SIZE_INT)res&~mask) |
d808 1
a808 2
	res   = c_d;
	res   = (BN_ULONG *)(((PTR_SIZE_INT)res&~mask) |
d1029 1
a1029 2
	res   = c_d;
	res   = (BN_ULONG *)(((PTR_SIZE_INT)res&~mask) |
d1095 1
a1095 2
	res  = t_d;
	res  = (BN_ULONG *)(((PTR_SIZE_INT)res&~mask) |
@


