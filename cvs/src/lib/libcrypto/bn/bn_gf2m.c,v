head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23;
locks; strict;
comment	@ * @;


1.23
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.22;
commitid	kT0fLt3r4lroFJra;

1.22
date	2016.09.03.14.37.00;	author bcook;	state Exp;
branches;
next	1.21;
commitid	NlDlaOi0lgowhhsG;

1.21
date	2016.03.12.21.44.11;	author bcook;	state Exp;
branches;
next	1.20;
commitid	xgEeS3Zk3RaZ7P7t;

1.20
date	2015.06.11.15.55.28;	author jsing;	state Exp;
branches;
next	1.19;
commitid	QMTebccnYTf6rqhg;

1.19
date	2015.04.29.00.11.12;	author doug;	state Exp;
branches;
next	1.18;
commitid	DUDpybhZMBt1ldZh;

1.18
date	2015.02.10.09.50.12;	author miod;	state Exp;
branches
	1.18.4.1;
next	1.17;
commitid	vXPcwCc8wnLZxSX4;

1.17
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.16;
commitid	69Tc75PIK8JcRRsC;

1.16
date	2014.10.28.07.35.58;	author jsg;	state Exp;
branches;
next	1.15;
commitid	pi8qF4s0vNCGLEKv;

1.15
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches
	1.15.4.1;
next	1.14;
commitid	yQEL1wOWIearrW15;

1.14
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.13;
commitid	nzndm3zqPmFurSaK;

1.13
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	mJUVYpkFBZ0Zv2bG;

1.12
date	2014.05.29.21.19.30;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2014.05.22.21.12.15;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2014.05.08.13.20.49;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.24.21.31.02;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.04.11.02.42;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches
	1.2.2.1
	1.2.6.1;
next	1.1;

1.1
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.13.52;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.11.03.02.32.09;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.36;	author djm;	state Exp;
branches;
next	;

1.2.2.1
date	2010.03.12.13.26.38;	author jasper;	state Exp;
branches;
next	;

1.2.6.1
date	2010.03.12.13.26.05;	author jasper;	state Exp;
branches;
next	;

1.15.4.1
date	2015.06.11.16.11.00;	author jsing;	state Exp;
branches;
next	;
commitid	jrR1mmYpHDQoSJAs;

1.18.4.1
date	2015.06.11.16.09.20;	author jsing;	state Exp;
branches;
next	;
commitid	B0KrBXUvDclRlbxZ;


desc
@@


1.23
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: bn_gf2m.c,v 1.22 2016/09/03 14:37:00 bcook Exp $ */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 *
 * The Elliptic Curve Public-Key Crypto Library (ECC Code) included
 * herein is developed by SUN MICROSYSTEMS, INC., and is contributed
 * to the OpenSSL project.
 *
 * The ECC Code is licensed pursuant to the OpenSSL open source
 * license provided below.
 *
 * In addition, Sun covenants to all licensees who provide a reciprocal
 * covenant with respect to their own patents if any, not to sue under
 * current and future patent claims necessarily infringed by the making,
 * using, practicing, selling, offering for sale and/or otherwise
 * disposing of the ECC Code as delivered hereunder (or portions thereof),
 * provided that such covenant shall not apply:
 *  1) for code that a licensee deletes from the ECC Code;
 *  2) separates from the ECC Code; or
 *  3) for infringements caused by:
 *       i) the modification of the ECC Code or
 *      ii) the combination of the ECC Code with other software or
 *          devices where such combination causes the infringement.
 *
 * The software is originally written by Sheueling Chang Shantz and
 * Douglas Stebila of Sun Microsystems Laboratories.
 *
 */

/* NOTE: This file is licensed pursuant to the OpenSSL license below
 * and may be modified; but after modifications, the above covenant
 * may no longer apply!  In such cases, the corresponding paragraph
 * ["In addition, Sun covenants ... causes the infringement."] and
 * this note can be edited out; but please keep the Sun copyright
 * notice and attribution. */

/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <limits.h>
#include <stdio.h>

#include <openssl/opensslconf.h>

#include <openssl/err.h>

#include "bn_lcl.h"

#ifndef OPENSSL_NO_EC2M

/* Maximum number of iterations before BN_GF2m_mod_solve_quad_arr should fail. */
#define MAX_ITERATIONS 50

static const BN_ULONG SQR_tb[16] =
	{     0,     1,     4,     5,    16,    17,    20,    21,
64,    65,    68,    69,    80,    81,    84,    85 };
/* Platform-specific macros to accelerate squaring. */
#ifdef _LP64
#define SQR1(w) \
    SQR_tb[(w) >> 60 & 0xF] << 56 | SQR_tb[(w) >> 56 & 0xF] << 48 | \
    SQR_tb[(w) >> 52 & 0xF] << 40 | SQR_tb[(w) >> 48 & 0xF] << 32 | \
    SQR_tb[(w) >> 44 & 0xF] << 24 | SQR_tb[(w) >> 40 & 0xF] << 16 | \
    SQR_tb[(w) >> 36 & 0xF] <<  8 | SQR_tb[(w) >> 32 & 0xF]
#define SQR0(w) \
    SQR_tb[(w) >> 28 & 0xF] << 56 | SQR_tb[(w) >> 24 & 0xF] << 48 | \
    SQR_tb[(w) >> 20 & 0xF] << 40 | SQR_tb[(w) >> 16 & 0xF] << 32 | \
    SQR_tb[(w) >> 12 & 0xF] << 24 | SQR_tb[(w) >>  8 & 0xF] << 16 | \
    SQR_tb[(w) >>  4 & 0xF] <<  8 | SQR_tb[(w)       & 0xF]
#else
#define SQR1(w) \
    SQR_tb[(w) >> 28 & 0xF] << 24 | SQR_tb[(w) >> 24 & 0xF] << 16 | \
    SQR_tb[(w) >> 20 & 0xF] <<  8 | SQR_tb[(w) >> 16 & 0xF]
#define SQR0(w) \
    SQR_tb[(w) >> 12 & 0xF] << 24 | SQR_tb[(w) >>  8 & 0xF] << 16 | \
    SQR_tb[(w) >>  4 & 0xF] <<  8 | SQR_tb[(w)       & 0xF]
#endif

#if !defined(OPENSSL_BN_ASM_GF2m)
/* Product of two polynomials a, b each with degree < BN_BITS2 - 1,
 * result is a polynomial r with degree < 2 * BN_BITS - 1
 * The caller MUST ensure that the variables have the right amount
 * of space allocated.
 */
static void
bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a, const BN_ULONG b)
{
#ifndef _LP64
	BN_ULONG h, l, s;
	BN_ULONG tab[8], top2b = a >> 30;
	BN_ULONG a1, a2, a4;

	a1 = a & (0x3FFFFFFF);
	a2 = a1 << 1;
	a4 = a2 << 1;

	tab[0] = 0;
	tab[1] = a1;
	tab[2] = a2;
	tab[3] = a1 ^ a2;
	tab[4] = a4;
	tab[5] = a1 ^ a4;
	tab[6] = a2 ^ a4;
	tab[7] = a1 ^ a2 ^ a4;

	s = tab[b & 0x7];
	l = s;
	s = tab[b >> 3 & 0x7];
	l ^= s << 3;
	h = s >> 29;
	s = tab[b >> 6 & 0x7];
	l ^= s <<  6;
	h ^= s >> 26;
	s = tab[b >> 9 & 0x7];
	l ^= s <<  9;
	h ^= s >> 23;
	s = tab[b >> 12 & 0x7];
	l ^= s << 12;
	h ^= s >> 20;
	s = tab[b >> 15 & 0x7];
	l ^= s << 15;
	h ^= s >> 17;
	s = tab[b >> 18 & 0x7];
	l ^= s << 18;
	h ^= s >> 14;
	s = tab[b >> 21 & 0x7];
	l ^= s << 21;
	h ^= s >> 11;
	s = tab[b >> 24 & 0x7];
	l ^= s << 24;
	h ^= s >>  8;
	s = tab[b >> 27 & 0x7];
	l ^= s << 27;
	h ^= s >>  5;
	s = tab[b >> 30];
	l ^= s << 30;
	h ^= s >> 2;

	/* compensate for the top two bits of a */
	if (top2b & 01) {
		l ^= b << 30;
		h ^= b >> 2;
	}
	if (top2b & 02) {
		l ^= b << 31;
		h ^= b >> 1;
	}

	*r1 = h;
	*r0 = l;
#else
	BN_ULONG h, l, s;
	BN_ULONG tab[16], top3b = a >> 61;
	BN_ULONG a1, a2, a4, a8;

	a1 = a & (0x1FFFFFFFFFFFFFFFULL);
	a2 = a1 << 1;
	a4 = a2 << 1;
	a8 = a4 << 1;

	tab[0] = 0;
	tab[1] = a1;
	tab[2] = a2;
	tab[3] = a1 ^ a2;
	tab[4] = a4;
	tab[5] = a1 ^ a4;
	tab[6] = a2 ^ a4;
	tab[7] = a1 ^ a2 ^ a4;
	tab[8] = a8;
	tab[9] = a1 ^ a8;
	tab[10] = a2 ^ a8;
	tab[11] = a1 ^ a2 ^ a8;
	tab[12] = a4 ^ a8;
	tab[13] = a1 ^ a4 ^ a8;
	tab[14] = a2 ^ a4 ^ a8;
	tab[15] = a1 ^ a2 ^ a4 ^ a8;

	s = tab[b & 0xF];
	l = s;
	s = tab[b >> 4 & 0xF];
	l ^= s << 4;
	h = s >> 60;
	s = tab[b >> 8 & 0xF];
	l ^= s << 8;
	h ^= s >> 56;
	s = tab[b >> 12 & 0xF];
	l ^= s << 12;
	h ^= s >> 52;
	s = tab[b >> 16 & 0xF];
	l ^= s << 16;
	h ^= s >> 48;
	s = tab[b >> 20 & 0xF];
	l ^= s << 20;
	h ^= s >> 44;
	s = tab[b >> 24 & 0xF];
	l ^= s << 24;
	h ^= s >> 40;
	s = tab[b >> 28 & 0xF];
	l ^= s << 28;
	h ^= s >> 36;
	s = tab[b >> 32 & 0xF];
	l ^= s << 32;
	h ^= s >> 32;
	s = tab[b >> 36 & 0xF];
	l ^= s << 36;
	h ^= s >> 28;
	s = tab[b >> 40 & 0xF];
	l ^= s << 40;
	h ^= s >> 24;
	s = tab[b >> 44 & 0xF];
	l ^= s << 44;
	h ^= s >> 20;
	s = tab[b >> 48 & 0xF];
	l ^= s << 48;
	h ^= s >> 16;
	s = tab[b >> 52 & 0xF];
	l ^= s << 52;
	h ^= s >> 12;
	s = tab[b >> 56 & 0xF];
	l ^= s << 56;
	h ^= s >>  8;
	s = tab[b >> 60];
	l ^= s << 60;
	h ^= s >>  4;

	/* compensate for the top three bits of a */
	if (top3b & 01) {
		l ^= b << 61;
		h ^= b >> 3;
	}
	if (top3b & 02) {
		l ^= b << 62;
		h ^= b >> 2;
	}
	if (top3b & 04) {
		l ^= b << 63;
		h ^= b >> 1;
	}

	*r1 = h;
	*r0 = l;
#endif
}

/* Product of two polynomials a, b each with degree < 2 * BN_BITS2 - 1,
 * result is a polynomial r with degree < 4 * BN_BITS2 - 1
 * The caller MUST ensure that the variables have the right amount
 * of space allocated.
 */
static void
bn_GF2m_mul_2x2(BN_ULONG *r, const BN_ULONG a1, const BN_ULONG a0,
    const BN_ULONG b1, const BN_ULONG b0)
{
	BN_ULONG m1, m0;

	/* r[3] = h1, r[2] = h0; r[1] = l1; r[0] = l0 */
	bn_GF2m_mul_1x1(r + 3, r + 2, a1, b1);
	bn_GF2m_mul_1x1(r + 1, r, a0, b0);
	bn_GF2m_mul_1x1(&m1, &m0, a0 ^ a1, b0 ^ b1);
	/* Correction on m1 ^= l1 ^ h1; m0 ^= l0 ^ h0; */
	r[2] ^= m1 ^ r[1] ^ r[3];  /* h0 ^= m1 ^ l1 ^ h1; */
	r[1] = r[3] ^ r[2] ^ r[0] ^ m1 ^ m0;  /* l1 ^= l0 ^ h0 ^ m0; */
}
#else
void bn_GF2m_mul_2x2(BN_ULONG *r, BN_ULONG a1, BN_ULONG a0, BN_ULONG b1,
    BN_ULONG b0);
#endif

/* Add polynomials a and b and store result in r; r could be a or b, a and b
 * could be equal; r is the bitwise XOR of a and b.
 */
int
BN_GF2m_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
	int i;
	const BIGNUM *at, *bt;

	bn_check_top(a);
	bn_check_top(b);

	if (a->top < b->top) {
		at = b;
		bt = a;
	} else {
		at = a;
		bt = b;
	}

	if (bn_wexpand(r, at->top) == NULL)
		return 0;

	for (i = 0; i < bt->top; i++) {
		r->d[i] = at->d[i] ^ bt->d[i];
	}
	for (; i < at->top; i++) {
		r->d[i] = at->d[i];
	}

	r->top = at->top;
	bn_correct_top(r);

	return 1;
}


/* Some functions allow for representation of the irreducible polynomials
 * as an int[], say p.  The irreducible f(t) is then of the form:
 *     t^p[0] + t^p[1] + ... + t^p[k]
 * where m = p[0] > p[1] > ... > p[k] = 0.
 */


/* Performs modular reduction of a and store result in r.  r could be a. */
int
BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[])
{
	int j, k;
	int n, dN, d0, d1;
	BN_ULONG zz, *z;

	bn_check_top(a);

	if (!p[0]) {
		/* reduction mod 1 => return 0 */
		BN_zero(r);
		return 1;
	}

	/* Since the algorithm does reduction in the r value, if a != r, copy
	 * the contents of a into r so we can do reduction in r.
	 */
	if (a != r) {
		if (!bn_wexpand(r, a->top))
			return 0;
		for (j = 0; j < a->top; j++) {
			r->d[j] = a->d[j];
		}
		r->top = a->top;
	}
	z = r->d;

	/* start reduction */
	dN = p[0] / BN_BITS2;
	for (j = r->top - 1; j > dN; ) {
		zz = z[j];
		if (z[j] == 0) {
			j--;
			continue;
		}
		z[j] = 0;

		for (k = 1; p[k] != 0; k++) {
			/* reducing component t^p[k] */
			n = p[0] - p[k];
			d0 = n % BN_BITS2;
			d1 = BN_BITS2 - d0;
			n /= BN_BITS2;
			z[j - n] ^= (zz >> d0);
			if (d0)
				z[j - n - 1] ^= (zz << d1);
		}

		/* reducing component t^0 */
		n = dN;
		d0 = p[0] % BN_BITS2;
		d1 = BN_BITS2 - d0;
		z[j - n] ^= (zz >> d0);
		if (d0)
			z[j - n - 1] ^= (zz << d1);
	}

	/* final round of reduction */
	while (j == dN) {

		d0 = p[0] % BN_BITS2;
		zz = z[dN] >> d0;
		if (zz == 0)
			break;
		d1 = BN_BITS2 - d0;

		/* clear up the top d1 bits */
		if (d0)
			z[dN] = (z[dN] << d1) >> d1;
		else
			z[dN] = 0;
		z[0] ^= zz; /* reduction t^0 component */

		for (k = 1; p[k] != 0; k++) {
			BN_ULONG tmp_ulong;

			/* reducing component t^p[k]*/
			n = p[k] / BN_BITS2;
			d0 = p[k] % BN_BITS2;
			d1 = BN_BITS2 - d0;
			z[n] ^= (zz << d0);
			if (d0 && (tmp_ulong = zz >> d1))
				z[n + 1] ^= tmp_ulong;
		}


	}

	bn_correct_top(r);
	return 1;
}

/* Performs modular reduction of a by p and store result in r.  r could be a.
 *
 * This function calls down to the BN_GF2m_mod_arr implementation; this wrapper
 * function is only provided for convenience; for best performance, use the
 * BN_GF2m_mod_arr function.
 */
int
BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p)
{
	int ret = 0;
	int arr[6];

	bn_check_top(a);
	bn_check_top(p);
	ret = BN_GF2m_poly2arr(p, arr, sizeof(arr) / sizeof(arr[0]));
	if (!ret || ret > (int)(sizeof(arr) / sizeof(arr[0]))) {
		BNerror(BN_R_INVALID_LENGTH);
		return 0;
	}
	ret = BN_GF2m_mod_arr(r, a, arr);
	bn_check_top(r);
	return ret;
}


/* Compute the product of two polynomials a and b, reduce modulo p, and store
 * the result in r.  r could be a or b; a could be b.
 */
int
BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const int p[],
    BN_CTX *ctx)
{
	int zlen, i, j, k, ret = 0;
	BIGNUM *s;
	BN_ULONG x1, x0, y1, y0, zz[4];

	bn_check_top(a);
	bn_check_top(b);

	if (a == b) {
		return BN_GF2m_mod_sqr_arr(r, a, p, ctx);
	}

	BN_CTX_start(ctx);
	if ((s = BN_CTX_get(ctx)) == NULL)
		goto err;

	zlen = a->top + b->top + 4;
	if (!bn_wexpand(s, zlen))
		goto err;
	s->top = zlen;

	for (i = 0; i < zlen; i++)
		s->d[i] = 0;

	for (j = 0; j < b->top; j += 2) {
		y0 = b->d[j];
		y1 = ((j + 1) == b->top) ? 0 : b->d[j + 1];
		for (i = 0; i < a->top; i += 2) {
			x0 = a->d[i];
			x1 = ((i + 1) == a->top) ? 0 : a->d[i + 1];
			bn_GF2m_mul_2x2(zz, x1, x0, y1, y0);
			for (k = 0; k < 4; k++)
				s->d[i + j + k] ^= zz[k];
		}
	}

	bn_correct_top(s);
	if (BN_GF2m_mod_arr(r, s, p))
		ret = 1;
	bn_check_top(r);

err:
	BN_CTX_end(ctx);
	return ret;
}

/* Compute the product of two polynomials a and b, reduce modulo p, and store
 * the result in r.  r could be a or b; a could equal b.
 *
 * This function calls down to the BN_GF2m_mod_mul_arr implementation; this wrapper
 * function is only provided for convenience; for best performance, use the
 * BN_GF2m_mod_mul_arr function.
 */
int
BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *p,
    BN_CTX *ctx)
{
	int ret = 0;
	const int max = BN_num_bits(p) + 1;
	int *arr = NULL;

	bn_check_top(a);
	bn_check_top(b);
	bn_check_top(p);
	if ((arr = reallocarray(NULL, max, sizeof(int))) == NULL)
		goto err;
	ret = BN_GF2m_poly2arr(p, arr, max);
	if (!ret || ret > max) {
		BNerror(BN_R_INVALID_LENGTH);
		goto err;
	}
	ret = BN_GF2m_mod_mul_arr(r, a, b, arr, ctx);
	bn_check_top(r);

err:
	free(arr);
	return ret;
}


/* Square a, reduce the result mod p, and store it in a.  r could be a. */
int
BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const int p[], BN_CTX *ctx)
{
	int i, ret = 0;
	BIGNUM *s;

	bn_check_top(a);
	BN_CTX_start(ctx);
	if ((s = BN_CTX_get(ctx)) == NULL)
		goto err;
	if (!bn_wexpand(s, 2 * a->top))
		goto err;

	for (i = a->top - 1; i >= 0; i--) {
		s->d[2 * i + 1] = SQR1(a->d[i]);
		s->d[2 * i] = SQR0(a->d[i]);
	}

	s->top = 2 * a->top;
	bn_correct_top(s);
	if (!BN_GF2m_mod_arr(r, s, p))
		goto err;
	bn_check_top(r);
	ret = 1;

err:
	BN_CTX_end(ctx);
	return ret;
}

/* Square a, reduce the result mod p, and store it in a.  r could be a.
 *
 * This function calls down to the BN_GF2m_mod_sqr_arr implementation; this wrapper
 * function is only provided for convenience; for best performance, use the
 * BN_GF2m_mod_sqr_arr function.
 */
int
BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
{
	int ret = 0;
	const int max = BN_num_bits(p) + 1;
	int *arr = NULL;

	bn_check_top(a);
	bn_check_top(p);
	if ((arr = reallocarray(NULL, max, sizeof(int))) == NULL)
		goto err;
	ret = BN_GF2m_poly2arr(p, arr, max);
	if (!ret || ret > max) {
		BNerror(BN_R_INVALID_LENGTH);
		goto err;
	}
	ret = BN_GF2m_mod_sqr_arr(r, a, arr, ctx);
	bn_check_top(r);

err:
	free(arr);
	return ret;
}


/* Invert a, reduce modulo p, and store the result in r. r could be a.
 * Uses Modified Almost Inverse Algorithm (Algorithm 10) from
 *     Hankerson, D., Hernandez, J.L., and Menezes, A.  "Software Implementation
 *     of Elliptic Curve Cryptography Over Binary Fields".
 */
int
BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
{
	BIGNUM *b, *c = NULL, *u = NULL, *v = NULL, *tmp;
	int ret = 0;

	bn_check_top(a);
	bn_check_top(p);

	BN_CTX_start(ctx);

	if ((b = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((c = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((u = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((v = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_GF2m_mod(u, a, p))
		goto err;
	if (BN_is_zero(u))
		goto err;

	if (!BN_copy(v, p))
		goto err;
#if 0
	if (!BN_one(b))
		goto err;

	while (1) {
		while (!BN_is_odd(u)) {
			if (BN_is_zero(u))
				goto err;
			if (!BN_rshift1(u, u))
				goto err;
			if (BN_is_odd(b)) {
				if (!BN_GF2m_add(b, b, p))
					goto err;
			}
			if (!BN_rshift1(b, b))
				goto err;
		}

		if (BN_abs_is_word(u, 1))
			break;

		if (BN_num_bits(u) < BN_num_bits(v)) {
			tmp = u;
			u = v;
			v = tmp;
			tmp = b;
			b = c;
			c = tmp;
		}

		if (!BN_GF2m_add(u, u, v))
			goto err;
		if (!BN_GF2m_add(b, b, c))
			goto err;
	}
#else
	{
		int i,	ubits = BN_num_bits(u),
		vbits = BN_num_bits(v),	/* v is copy of p */
		top = p->top;
		BN_ULONG *udp, *bdp, *vdp, *cdp;

		if (!bn_wexpand(u, top))
                        goto err;
		udp = u->d;
		for (i = u->top; i < top; i++)
			udp[i] = 0;
		u->top = top;
		if (!bn_wexpand(b, top))
                        goto err;
		bdp = b->d;
		bdp[0] = 1;
		for (i = 1; i < top; i++)
			bdp[i] = 0;
		b->top = top;
		if (!bn_wexpand(c, top))
                        goto err;
		cdp = c->d;
		for (i = 0; i < top; i++)
			cdp[i] = 0;
		c->top = top;
		vdp = v->d;	/* It pays off to "cache" *->d pointers, because
				 * it allows optimizer to be more aggressive.
				 * But we don't have to "cache" p->d, because *p
				 * is declared 'const'... */
		while (1) {
			while (ubits && !(udp[0]&1)) {
				BN_ULONG u0, u1, b0, b1, mask;

				u0 = udp[0];
				b0 = bdp[0];
				mask = (BN_ULONG)0 - (b0 & 1);
				b0  ^= p->d[0] & mask;
				for (i = 0; i < top - 1; i++) {
					u1 = udp[i + 1];
					udp[i] = ((u0 >> 1) |
					    (u1 << (BN_BITS2 - 1))) & BN_MASK2;
					u0 = u1;
					b1 = bdp[i + 1] ^ (p->d[i + 1] & mask);
					bdp[i] = ((b0 >> 1) |
					    (b1 << (BN_BITS2 - 1))) & BN_MASK2;
					b0 = b1;
				}
				udp[i] = u0 >> 1;
				bdp[i] = b0 >> 1;
				ubits--;
			}

			if (ubits <= BN_BITS2) {
				/* See if poly was reducible. */
				if (udp[0] == 0)
					goto err;
				if (udp[0] == 1)
					break;
			}

			if (ubits < vbits) {
				i = ubits;
				ubits = vbits;
				vbits = i;
				tmp = u;
				u = v;
				v = tmp;
				tmp = b;
				b = c;
				c = tmp;
				udp = vdp;
				vdp = v->d;
				bdp = cdp;
				cdp = c->d;
			}
			for (i = 0; i < top; i++) {
				udp[i] ^= vdp[i];
				bdp[i] ^= cdp[i];
			}
			if (ubits == vbits) {
				BN_ULONG ul;
				int utop = (ubits - 1) / BN_BITS2;

				while ((ul = udp[utop]) == 0 && utop)
					utop--;
				ubits = utop*BN_BITS2 + BN_num_bits_word(ul);
			}
		}
		bn_correct_top(b);
	}
#endif

	if (!BN_copy(r, b))
		goto err;
	bn_check_top(r);
	ret = 1;

err:
#ifdef BN_DEBUG /* BN_CTX_end would complain about the expanded form */
	bn_correct_top(c);
	bn_correct_top(u);
	bn_correct_top(v);
#endif
	BN_CTX_end(ctx);
	return ret;
}

/* Invert xx, reduce modulo p, and store the result in r. r could be xx.
 *
 * This function calls down to the BN_GF2m_mod_inv implementation; this wrapper
 * function is only provided for convenience; for best performance, use the
 * BN_GF2m_mod_inv function.
 */
int
BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *xx, const int p[], BN_CTX *ctx)
{
	BIGNUM *field;
	int ret = 0;

	bn_check_top(xx);
	BN_CTX_start(ctx);
	if ((field = BN_CTX_get(ctx)) == NULL)
		goto err;
	if (!BN_GF2m_arr2poly(p, field))
		goto err;

	ret = BN_GF2m_mod_inv(r, xx, field, ctx);
	bn_check_top(r);

err:
	BN_CTX_end(ctx);
	return ret;
}


#ifndef OPENSSL_SUN_GF2M_DIV
/* Divide y by x, reduce modulo p, and store the result in r. r could be x
 * or y, x could equal y.
 */
int
BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *y, const BIGNUM *x, const BIGNUM *p,
    BN_CTX *ctx)
{
	BIGNUM *xinv = NULL;
	int ret = 0;

	bn_check_top(y);
	bn_check_top(x);
	bn_check_top(p);

	BN_CTX_start(ctx);
	if ((xinv = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_GF2m_mod_inv(xinv, x, p, ctx))
		goto err;
	if (!BN_GF2m_mod_mul(r, y, xinv, p, ctx))
		goto err;
	bn_check_top(r);
	ret = 1;

err:
	BN_CTX_end(ctx);
	return ret;
}
#else
/* Divide y by x, reduce modulo p, and store the result in r. r could be x
 * or y, x could equal y.
 * Uses algorithm Modular_Division_GF(2^m) from
 *     Chang-Shantz, S.  "From Euclid's GCD to Montgomery Multiplication to
 *     the Great Divide".
 */
int
BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *y, const BIGNUM *x, const BIGNUM *p,
    BN_CTX *ctx)
{
	BIGNUM *a, *b, *u, *v;
	int ret = 0;

	bn_check_top(y);
	bn_check_top(x);
	bn_check_top(p);

	BN_CTX_start(ctx);

	if ((a = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((b = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((u = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((v = BN_CTX_get(ctx)) == NULL)
		goto err;

	/* reduce x and y mod p */
	if (!BN_GF2m_mod(u, y, p))
		goto err;
	if (!BN_GF2m_mod(a, x, p))
		goto err;
	if (!BN_copy(b, p))
		goto err;

	while (!BN_is_odd(a)) {
		if (!BN_rshift1(a, a))
			goto err;
		if (BN_is_odd(u))
			if (!BN_GF2m_add(u, u, p))
				goto err;
		if (!BN_rshift1(u, u))
			goto err;
	}

	do {
		if (BN_GF2m_cmp(b, a) > 0) {
			if (!BN_GF2m_add(b, b, a))
				goto err;
			if (!BN_GF2m_add(v, v, u))
				goto err;
			do {
				if (!BN_rshift1(b, b))
					goto err;
				if (BN_is_odd(v))
					if (!BN_GF2m_add(v, v, p))
						goto err;
				if (!BN_rshift1(v, v))
					goto err;
			} while (!BN_is_odd(b));
		} else if (BN_abs_is_word(a, 1))
			break;
		else {
			if (!BN_GF2m_add(a, a, b))
				goto err;
			if (!BN_GF2m_add(u, u, v))
				goto err;
			do {
				if (!BN_rshift1(a, a))
					goto err;
				if (BN_is_odd(u))
					if (!BN_GF2m_add(u, u, p))
						goto err;
				if (!BN_rshift1(u, u))
					goto err;
			} while (!BN_is_odd(a));
		}
	} while (1);

	if (!BN_copy(r, u))
		goto err;
	bn_check_top(r);
	ret = 1;

err:
	BN_CTX_end(ctx);
	return ret;
}
#endif

/* Divide yy by xx, reduce modulo p, and store the result in r. r could be xx
 * or yy, xx could equal yy.
 *
 * This function calls down to the BN_GF2m_mod_div implementation; this wrapper
 * function is only provided for convenience; for best performance, use the
 * BN_GF2m_mod_div function.
 */
int
BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *yy, const BIGNUM *xx,
    const int p[], BN_CTX *ctx)
{
	BIGNUM *field;
	int ret = 0;

	bn_check_top(yy);
	bn_check_top(xx);

	BN_CTX_start(ctx);
	if ((field = BN_CTX_get(ctx)) == NULL)
		goto err;
	if (!BN_GF2m_arr2poly(p, field))
		goto err;

	ret = BN_GF2m_mod_div(r, yy, xx, field, ctx);
	bn_check_top(r);

err:
	BN_CTX_end(ctx);
	return ret;
}


/* Compute the bth power of a, reduce modulo p, and store
 * the result in r.  r could be a.
 * Uses simple square-and-multiply algorithm A.5.1 from IEEE P1363.
 */
int
BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const int p[],
    BN_CTX *ctx)
{
	int ret = 0, i, n;
	BIGNUM *u;

	bn_check_top(a);
	bn_check_top(b);

	if (BN_is_zero(b))
		return (BN_one(r));

	if (BN_abs_is_word(b, 1))
		return (BN_copy(r, a) != NULL);

	BN_CTX_start(ctx);
	if ((u = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_GF2m_mod_arr(u, a, p))
		goto err;

	n = BN_num_bits(b) - 1;
	for (i = n - 1; i >= 0; i--) {
		if (!BN_GF2m_mod_sqr_arr(u, u, p, ctx))
			goto err;
		if (BN_is_bit_set(b, i)) {
			if (!BN_GF2m_mod_mul_arr(u, u, a, p, ctx))
				goto err;
		}
	}
	if (!BN_copy(r, u))
		goto err;
	bn_check_top(r);
	ret = 1;

err:
	BN_CTX_end(ctx);
	return ret;
}

/* Compute the bth power of a, reduce modulo p, and store
 * the result in r.  r could be a.
 *
 * This function calls down to the BN_GF2m_mod_exp_arr implementation; this wrapper
 * function is only provided for convenience; for best performance, use the
 * BN_GF2m_mod_exp_arr function.
 */
int
BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *p,
    BN_CTX *ctx)
{
	int ret = 0;
	const int max = BN_num_bits(p) + 1;
	int *arr = NULL;

	bn_check_top(a);
	bn_check_top(b);
	bn_check_top(p);
	if ((arr = reallocarray(NULL, max, sizeof(int))) == NULL)
		goto err;
	ret = BN_GF2m_poly2arr(p, arr, max);
	if (!ret || ret > max) {
		BNerror(BN_R_INVALID_LENGTH);
		goto err;
	}
	ret = BN_GF2m_mod_exp_arr(r, a, b, arr, ctx);
	bn_check_top(r);

err:
	free(arr);
	return ret;
}

/* Compute the square root of a, reduce modulo p, and store
 * the result in r.  r could be a.
 * Uses exponentiation as in algorithm A.4.1 from IEEE P1363.
 */
int
BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a, const int p[], BN_CTX *ctx)
{
	int ret = 0;
	BIGNUM *u;

	bn_check_top(a);

	if (!p[0]) {
		/* reduction mod 1 => return 0 */
		BN_zero(r);
		return 1;
	}

	BN_CTX_start(ctx);
	if ((u = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_set_bit(u, p[0] - 1))
		goto err;
	ret = BN_GF2m_mod_exp_arr(r, a, u, p, ctx);
	bn_check_top(r);

err:
	BN_CTX_end(ctx);
	return ret;
}

/* Compute the square root of a, reduce modulo p, and store
 * the result in r.  r could be a.
 *
 * This function calls down to the BN_GF2m_mod_sqrt_arr implementation; this wrapper
 * function is only provided for convenience; for best performance, use the
 * BN_GF2m_mod_sqrt_arr function.
 */
int
BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
{
	int ret = 0;
	const int max = BN_num_bits(p) + 1;
	int *arr = NULL;
	bn_check_top(a);
	bn_check_top(p);
	if ((arr = reallocarray(NULL, max, sizeof(int))) == NULL)
		goto err;
	ret = BN_GF2m_poly2arr(p, arr, max);
	if (!ret || ret > max) {
		BNerror(BN_R_INVALID_LENGTH);
		goto err;
	}
	ret = BN_GF2m_mod_sqrt_arr(r, a, arr, ctx);
	bn_check_top(r);

err:
	free(arr);
	return ret;
}

/* Find r such that r^2 + r = a mod p.  r could be a. If no r exists returns 0.
 * Uses algorithms A.4.7 and A.4.6 from IEEE P1363.
 */
int
BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const int p[],
    BN_CTX *ctx)
{
	int ret = 0, count = 0, j;
	BIGNUM *a, *z, *rho, *w, *w2, *tmp;

	bn_check_top(a_);

	if (!p[0]) {
		/* reduction mod 1 => return 0 */
		BN_zero(r);
		return 1;
	}

	BN_CTX_start(ctx);
	if ((a = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((z = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((w = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_GF2m_mod_arr(a, a_, p))
		goto err;

	if (BN_is_zero(a)) {
		BN_zero(r);
		ret = 1;
		goto err;
	}

	if (p[0] & 0x1) /* m is odd */
	{
		/* compute half-trace of a */
		if (!BN_copy(z, a))
			goto err;
		for (j = 1; j <= (p[0] - 1) / 2; j++) {
			if (!BN_GF2m_mod_sqr_arr(z, z, p, ctx))
				goto err;
			if (!BN_GF2m_mod_sqr_arr(z, z, p, ctx))
				goto err;
			if (!BN_GF2m_add(z, z, a))
				goto err;
		}

	}
	else /* m is even */
	{
		if ((rho = BN_CTX_get(ctx)) == NULL)
			goto err;
		if ((w2 = BN_CTX_get(ctx)) == NULL)
			goto err;
		if ((tmp = BN_CTX_get(ctx)) == NULL)
			goto err;
		do {
			if (!BN_rand(rho, p[0], 0, 0))
				goto err;
			if (!BN_GF2m_mod_arr(rho, rho, p))
				goto err;
			BN_zero(z);
			if (!BN_copy(w, rho))
				goto err;
			for (j = 1; j <= p[0] - 1; j++) {
				if (!BN_GF2m_mod_sqr_arr(z, z, p, ctx))
					goto err;
				if (!BN_GF2m_mod_sqr_arr(w2, w, p, ctx))
					goto err;
				if (!BN_GF2m_mod_mul_arr(tmp, w2, a, p, ctx))
					goto err;
				if (!BN_GF2m_add(z, z, tmp))
					goto err;
				if (!BN_GF2m_add(w, w2, rho))
					goto err;
			}
			count++;
		} while (BN_is_zero(w) && (count < MAX_ITERATIONS));
		if (BN_is_zero(w)) {
			BNerror(BN_R_TOO_MANY_ITERATIONS);
			goto err;
		}
	}

	if (!BN_GF2m_mod_sqr_arr(w, z, p, ctx))
		goto err;
	if (!BN_GF2m_add(w, z, w))
		goto err;
	if (BN_GF2m_cmp(w, a)) {
		BNerror(BN_R_NO_SOLUTION);
		goto err;
	}

	if (!BN_copy(r, z))
		goto err;
	bn_check_top(r);

	ret = 1;

err:
	BN_CTX_end(ctx);
	return ret;
}

/* Find r such that r^2 + r = a mod p.  r could be a. If no r exists returns 0.
 *
 * This function calls down to the BN_GF2m_mod_solve_quad_arr implementation; this wrapper
 * function is only provided for convenience; for best performance, use the
 * BN_GF2m_mod_solve_quad_arr function.
 */
int
BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
{
	int ret = 0;
	const int max = BN_num_bits(p) + 1;
	int *arr = NULL;

	bn_check_top(a);
	bn_check_top(p);
	if ((arr = reallocarray(NULL, max, sizeof(int))) == NULL)
		goto err;
	ret = BN_GF2m_poly2arr(p, arr, max);
	if (!ret || ret > max) {
		BNerror(BN_R_INVALID_LENGTH);
		goto err;
	}
	ret = BN_GF2m_mod_solve_quad_arr(r, a, arr, ctx);
	bn_check_top(r);

err:
	free(arr);
	return ret;
}

/* Convert the bit-string representation of a polynomial
 * ( \sum_{i=0}^n a_i * x^i) into an array of integers corresponding
 * to the bits with non-zero coefficient.  Array is terminated with -1.
 * Up to max elements of the array will be filled.  Return value is total
 * number of array elements that would be filled if array was large enough.
 */
int
BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)
{
	int i, j, k = 0;
	BN_ULONG mask;

	if (BN_is_zero(a))
		return 0;

	for (i = a->top - 1; i >= 0; i--) {
		if (!a->d[i])
			/* skip word if a->d[i] == 0 */
			continue;
		mask = BN_TBIT;
		for (j = BN_BITS2 - 1; j >= 0; j--) {
			if (a->d[i] & mask) {
				if (k < max)
					p[k] = BN_BITS2 * i + j;
				k++;
			}
			mask >>= 1;
		}
	}

	if (k < max) {
		p[k] = -1;
		k++;
	}

	return k;
}

/* Convert the coefficient array representation of a polynomial to a
 * bit-string.  The array must be terminated by -1.
 */
int
BN_GF2m_arr2poly(const int p[], BIGNUM *a)
{
	int i;

	bn_check_top(a);
	BN_zero(a);
	for (i = 0; p[i] != -1; i++) {
		if (BN_set_bit(a, p[i]) == 0)
			return 0;
	}
	bn_check_top(a);

	return 1;
}

#endif
@


1.22
log
@Avoid undefined-behavior right-shifting by a word-size # of bits.

Found with STACK, originally from OpenSSL, ok @@beck
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.21 2016/03/12 21:44:11 bcook Exp $ */
d473 1
a473 1
		BNerr(BN_F_BN_GF2M_MOD, BN_R_INVALID_LENGTH);
d556 1
a556 1
		BNerr(BN_F_BN_GF2M_MOD_MUL, BN_R_INVALID_LENGTH);
d618 1
a618 1
		BNerr(BN_F_BN_GF2M_MOD_SQR, BN_R_INVALID_LENGTH);
d1055 1
a1055 1
		BNerr(BN_F_BN_GF2M_MOD_EXP, BN_R_INVALID_LENGTH);
d1117 1
a1117 1
		BNerr(BN_F_BN_GF2M_MOD_SQRT, BN_R_INVALID_LENGTH);
d1209 1
a1209 2
			BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR,
			    BN_R_TOO_MANY_ITERATIONS);
d1219 1
a1219 1
		BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR, BN_R_NO_SOLUTION);
d1253 1
a1253 1
		BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD, BN_R_INVALID_LENGTH);
@


1.21
log
@Add error handling to the remaining calls to bn_wexpand().

Noticed by pascal-cuoq from Github:
https://github.com/libressl-portable/openbsd/issues/56

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.20 2015/06/11 15:55:28 jsing Exp $ */
d446 1
a446 2
			tmp_ulong = zz >> d1;
			if (d0 && tmp_ulong)
@


1.20
log
@Avoid an infinite loop that can be triggered by parsing an ASN.1
ECParameters structure that has a specially malformed binary polynomial
field.

Issue reported by Joseph Barr-Pixton and fix based on OpenSSL.

Fixes CVE-2015-1788.

ok doug@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.19 2015/04/29 00:11:12 doug Exp $ */
d705 2
a706 1
		bn_wexpand(u, top);
d711 2
a712 1
		bn_wexpand(b, top);
d718 2
a719 1
		bn_wexpand(c, top);
@


1.19
log
@Add missing BN_CTX_end() calls.

After calling BN_CTX_start(), there must be a BN_CTX_end() before
returning.  There were missing BN_CTX_end() calls in error paths.  One diff
chunk was simply removing redundant code related to this.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.18 2015/02/10 09:50:12 miod Exp $ */
d748 7
a754 2
			if (ubits <= BN_BITS2 && udp[0] == 1)
				break;
@


1.18
log
@Remove unnecessary include of assert.h
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.17 2015/02/09 15:49:22 jsing Exp $ */
d579 1
a579 1
		return 0;
@


1.18.4.1
log
@MFC: Fix several defects from OpenSSL.

These include:

CVE-2015-1788 - Malformed ECParameters causes infinite loop
CVE-2015-1789 - Exploitable out-of-bounds read in X509_cmp_time
CVE-2015-1792 - CMS verify infinite loop with unknown hash function
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.18 2015/02/10 09:50:12 miod Exp $ */
d748 2
a749 7
			if (ubits <= BN_BITS2) {
				/* See if poly was reducible. */
				if (udp[0] == 0)
					goto err;
				if (udp[0] == 1)
					break;
			}
@


1.17
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.16 2014/10/28 07:35:58 jsg Exp $ */
a90 1
#include <assert.h>
@


1.16
log
@deregister; no binary change
ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.15 2014/07/11 08:44:47 jsing Exp $ */
d843 1
a843 2
	xinv = BN_CTX_get(ctx);
	if (xinv == NULL)
d877 7
a883 5
	a = BN_CTX_get(ctx);
	b = BN_CTX_get(ctx);
	u = BN_CTX_get(ctx);
	v = BN_CTX_get(ctx);
	if (v == NULL)
d1141 5
a1145 4
	a = BN_CTX_get(ctx);
	z = BN_CTX_get(ctx);
	w = BN_CTX_get(ctx);
	if (w == NULL)
d1174 5
a1178 4
		rho = BN_CTX_get(ctx);
		w2 = BN_CTX_get(ctx);
		tmp = BN_CTX_get(ctx);
		if (tmp == NULL)
@


1.15
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.14 2014/07/10 22:45:56 jsing Exp $ */
d140 1
a140 1
	register BN_ULONG h, l, s;
d142 1
a142 1
	register BN_ULONG a1, a2, a4;
d203 1
a203 1
	register BN_ULONG h, l, s;
d205 1
a205 1
	register BN_ULONG a1, a2, a4, a8;
@


1.15.4.1
log
@MFC: Fix several defects from OpenSSL.

These include:

CVE-2015-1788 - Malformed ECParameters causes infinite loop
CVE-2015-1789 - Exploitable out-of-bounds read in X509_cmp_time
CVE-2015-1792 - CMS verify infinite loop with unknown hash function
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.15 2014/07/11 08:44:47 jsing Exp $ */
d749 2
a750 7
			if (ubits <= BN_BITS2) {
				/* See if poly was reducible. */
				if (udp[0] == 0)
					goto err;
				if (udp[0] == 1)
					break;
			}
@


1.14
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: bn_gf2m.c,v 1.13 2014/06/12 15:49:28 deraadt Exp $ */
d97 2
a98 1
#include "cryptlib.h"
@


1.13
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d94 3
@


1.12
log
@ok, next pass after review:  when possible, put the reallocarray arguments
in the "size_t nmemb, size_t size"
@
text
@d1 1
a1 1
/* crypto/bn/bn_gf2m.c */
@


1.11
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d550 1
a550 1
	if ((arr = reallocarray(NULL, sizeof(int), max)) == NULL)
d612 1
a612 1
	if ((arr = reallocarray(NULL, sizeof(int), max)) == NULL)
d1040 1
a1040 1
	if ((arr = reallocarray(NULL, sizeof(int), max)) == NULL)
d1102 1
a1102 1
	if ((arr = reallocarray(NULL, sizeof(int), max)) == NULL)
d1237 1
a1237 1
	if ((arr = reallocarray(NULL, sizeof(int), max)) == NULL)
@


1.10
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d550 1
a550 1
	if ((arr = (int *)malloc(sizeof(int) * max)) == NULL)
d612 1
a612 1
	if ((arr = (int *)malloc(sizeof(int) * max)) == NULL)
d1040 1
a1040 1
	if ((arr = (int *)malloc(sizeof(int) * max)) == NULL)
d1102 1
a1102 1
	if ((arr = (int *)malloc(sizeof(int) * max)) == NULL)
d1237 1
a1237 1
	if ((arr = (int *)malloc(sizeof(int) * max)) == NULL)
@


1.9
log
@Emergency knfectomie requested by tedu@@.
@
text
@d561 1
a561 2
	if (arr)
		free(arr);
d623 1
a623 2
	if (arr)
		free(arr);
d1051 1
a1051 2
	if (arr)
		free(arr);
d1113 1
a1113 2
	if (arr)
		free(arr);
d1248 1
a1248 2
	if (arr)
		free(arr);
@


1.8
log
@Try to clean the maze of <openssl/bn.h> defines regarding the BN internals.

The intent of this change is to only keep support for two kind of architectures:
- those with 32-bit int and long, and 64-bit long long, where
  ``long * long -> long long'' multiplication routines are available.
- those with 64-bit int and long, and no 128-bit long long type.

This gets rid of the SIXTY_FOUR_BIT_LONG, SIXTY_FOUR_BIT (not the same!),
THIRTY_TWO_BIT, SIXTEEN_BIT and EIGHT_BIT defines.

After this change, the types and defines are as follows:

arch:           64bit           32bit           rationale
BN_LLONG        undefined       defined         defined if l * l -> ll
BN_ULLONG       undefined       u long long     result of BN_LONG * BN_LONG
BN_ULONG        u long          u int           native register size
BN_LONG         long            int             the same, signed
BN_BITS         128             64              size of 2*BN_ULONG in bits
BN_BYTES        8               4               size of 2*BN_ULONG in bytes
BN_BITS2        64              32              BN_BITS / 2

Tested on various 32-bit and 64-bit OpenBSD systems of various endianness.
@
text
@d45 1
a45 1
 *    notice, this list of conditions and the following disclaimer. 
d103 2
a104 2
  {     0,     1,     4,     5,    16,    17,    20,    21,
       64,    65,    68,    69,    80,    81,    84,    85 };
d132 3
a134 2
static void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a, const BN_ULONG b)
	{
d137 1
a137 1
	BN_ULONG tab[8], top2b = a >> 30; 
d140 45
a184 16
	a1 = a & (0x3FFFFFFF); a2 = a1 << 1; a4 = a2 << 1;

	tab[0] =  0; tab[1] = a1;    tab[2] = a2;    tab[3] = a1^a2;
	tab[4] = a4; tab[5] = a1^a4; tab[6] = a2^a4; tab[7] = a1^a2^a4;

	s = tab[b       & 0x7]; l  = s;
	s = tab[b >>  3 & 0x7]; l ^= s <<  3; h  = s >> 29;
	s = tab[b >>  6 & 0x7]; l ^= s <<  6; h ^= s >> 26;
	s = tab[b >>  9 & 0x7]; l ^= s <<  9; h ^= s >> 23;
	s = tab[b >> 12 & 0x7]; l ^= s << 12; h ^= s >> 20;
	s = tab[b >> 15 & 0x7]; l ^= s << 15; h ^= s >> 17;
	s = tab[b >> 18 & 0x7]; l ^= s << 18; h ^= s >> 14;
	s = tab[b >> 21 & 0x7]; l ^= s << 21; h ^= s >> 11;
	s = tab[b >> 24 & 0x7]; l ^= s << 24; h ^= s >>  8;
	s = tab[b >> 27 & 0x7]; l ^= s << 27; h ^= s >>  5;
	s = tab[b >> 30      ]; l ^= s << 30; h ^= s >>  2;
d187 8
d196 2
a197 4
	if (top2b & 01) { l ^= b << 30; h ^= b >> 2; } 
	if (top2b & 02) { l ^= b << 31; h ^= b >> 1; } 

	*r1 = h; *r0 = l;
d203 69
a271 23
	a1 = a & (0x1FFFFFFFFFFFFFFFULL); a2 = a1 << 1; a4 = a2 << 1; a8 = a4 << 1;

	tab[ 0] = 0;     tab[ 1] = a1;       tab[ 2] = a2;       tab[ 3] = a1^a2;
	tab[ 4] = a4;    tab[ 5] = a1^a4;    tab[ 6] = a2^a4;    tab[ 7] = a1^a2^a4;
	tab[ 8] = a8;    tab[ 9] = a1^a8;    tab[10] = a2^a8;    tab[11] = a1^a2^a8;
	tab[12] = a4^a8; tab[13] = a1^a4^a8; tab[14] = a2^a4^a8; tab[15] = a1^a2^a4^a8;

	s = tab[b       & 0xF]; l  = s;
	s = tab[b >>  4 & 0xF]; l ^= s <<  4; h  = s >> 60;
	s = tab[b >>  8 & 0xF]; l ^= s <<  8; h ^= s >> 56;
	s = tab[b >> 12 & 0xF]; l ^= s << 12; h ^= s >> 52;
	s = tab[b >> 16 & 0xF]; l ^= s << 16; h ^= s >> 48;
	s = tab[b >> 20 & 0xF]; l ^= s << 20; h ^= s >> 44;
	s = tab[b >> 24 & 0xF]; l ^= s << 24; h ^= s >> 40;
	s = tab[b >> 28 & 0xF]; l ^= s << 28; h ^= s >> 36;
	s = tab[b >> 32 & 0xF]; l ^= s << 32; h ^= s >> 32;
	s = tab[b >> 36 & 0xF]; l ^= s << 36; h ^= s >> 28;
	s = tab[b >> 40 & 0xF]; l ^= s << 40; h ^= s >> 24;
	s = tab[b >> 44 & 0xF]; l ^= s << 44; h ^= s >> 20;
	s = tab[b >> 48 & 0xF]; l ^= s << 48; h ^= s >> 16;
	s = tab[b >> 52 & 0xF]; l ^= s << 52; h ^= s >> 12;
	s = tab[b >> 56 & 0xF]; l ^= s << 56; h ^= s >>  8;
	s = tab[b >> 60      ]; l ^= s << 60; h ^= s >>  4;
d274 12
d287 2
a288 5
	if (top3b & 01) { l ^= b << 61; h ^= b >> 3; } 
	if (top3b & 02) { l ^= b << 62; h ^= b >> 2; } 
	if (top3b & 04) { l ^= b << 63; h ^= b >> 1; } 

	*r1 = h; *r0 = l;
d290 1
a290 1
	} 
d297 4
a300 2
static void bn_GF2m_mul_2x2(BN_ULONG *r, const BN_ULONG a1, const BN_ULONG a0, const BN_ULONG b1, const BN_ULONG b0)
	{
d302 1
d304 2
a305 2
	bn_GF2m_mul_1x1(r+3, r+2, a1, b1);
	bn_GF2m_mul_1x1(r+1, r, a0, b0);
d310 1
a310 1
	}
d312 3
a314 2
void bn_GF2m_mul_2x2(BN_ULONG *r, BN_ULONG a1, BN_ULONG a0, BN_ULONG b1, BN_ULONG b0);
#endif 
d316 1
a316 1
/* Add polynomials a and b and store result in r; r could be a or b, a and b 
d319 3
a321 2
int	BN_GF2m_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
	{
d328 7
a334 2
	if (a->top < b->top) { at = b; bt = a; }
	else { at = a; bt = b; }
d336 1
a336 1
	if(bn_wexpand(r, at->top) == NULL)
d339 1
a339 2
	for (i = 0; i < bt->top; i++)
		{
d341 2
a342 3
		}
	for (; i < at->top; i++)
		{
d344 2
a345 2
		}
	
d348 1
a348 1
	
d350 1
a350 1
	}
d361 3
a363 2
int BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[])
	{
d370 1
a370 2
	if (!p[0])
		{
d374 1
a374 1
		}
d377 1
a377 1
	 * the contents of a into r so we can do reduction in r. 
d379 4
a382 5
	if (a != r)
		{
		if (!bn_wexpand(r, a->top)) return 0;
		for (j = 0; j < a->top; j++)
			{
d384 1
a384 1
			}
d386 1
a386 1
		}
d390 2
a391 3
	dN = p[0] / BN_BITS2;  
	for (j = r->top - 1; j > dN;)
		{
d393 4
a396 1
		if (z[j] == 0) { j--; continue; }
d399 1
a399 2
		for (k = 1; p[k] != 0; k++)
			{
d402 7
a408 5
			d0 = n % BN_BITS2;  d1 = BN_BITS2 - d0;
			n /= BN_BITS2; 
			z[j-n] ^= (zz>>d0);
			if (d0) z[j-n-1] ^= (zz<<d1);
			}
d411 1
a411 1
		n = dN;  
d414 4
a417 3
		z[j-n] ^= (zz >> d0);
		if (d0) z[j-n-1] ^= (zz << d1);
		}
d420 1
a420 2
	while (j == dN)
		{
d424 2
a425 1
		if (zz == 0) break;
d427 1
a427 1
		
d435 1
a435 2
		for (k = 1; p[k] != 0; k++)
			{
d439 1
a439 1
			n = p[k] / BN_BITS2;   
d444 4
a447 3
                        if (d0 && tmp_ulong)
                                z[n+1] ^= tmp_ulong;
			}
d449 1
a449 2
		
		}
d453 1
a453 1
	}
d458 1
a458 1
 * function is only provided for convenience; for best performance, use the 
d461 3
a463 2
int	BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p)
	{
d466 1
d469 3
a471 4
	ret = BN_GF2m_poly2arr(p, arr, sizeof(arr)/sizeof(arr[0]));
	if (!ret || ret > (int)(sizeof(arr)/sizeof(arr[0])))
		{
		BNerr(BN_F_BN_GF2M_MOD,BN_R_INVALID_LENGTH);
d473 1
a473 1
		}
d477 1
a477 1
	}
d483 4
a486 2
int	BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const int p[], BN_CTX *ctx)
	{
d494 1
a494 2
	if (a == b)
		{
d496 1
a496 1
		}
d499 3
a501 2
	if ((s = BN_CTX_get(ctx)) == NULL) goto err;
	
d503 2
a504 1
	if (!bn_wexpand(s, zlen)) goto err;
d507 2
a508 1
	for (i = 0; i < zlen; i++) s->d[i] = 0;
d510 1
a510 2
	for (j = 0; j < b->top; j += 2)
		{
d512 2
a513 3
		y1 = ((j+1) == b->top) ? 0 : b->d[j+1];
		for (i = 0; i < a->top; i += 2)
			{
d515 1
a515 1
			x1 = ((i+1) == a->top) ? 0 : a->d[i+1];
d517 2
a518 2
			for (k = 0; k < 4; k++) s->d[i+j+k] ^= zz[k];
			}
d520 1
d530 1
a530 1
	}
d536 1
a536 1
 * function is only provided for convenience; for best performance, use the 
d539 4
a542 2
int	BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *p, BN_CTX *ctx)
	{
d545 2
a546 1
	int *arr=NULL;
d550 2
a551 1
	if ((arr = (int *)malloc(sizeof(int) * max)) == NULL) goto err;
d553 2
a554 3
	if (!ret || ret > max)
		{
		BNerr(BN_F_BN_GF2M_MOD_MUL,BN_R_INVALID_LENGTH);
d556 1
a556 1
		}
d559 1
d561 2
a562 1
	if (arr) free(arr);
d564 1
a564 1
	}
d568 3
a570 2
int	BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const int p[], BN_CTX *ctx)
	{
d576 4
a579 2
	if ((s = BN_CTX_get(ctx)) == NULL) return 0;
	if (!bn_wexpand(s, 2 * a->top)) goto err;
d581 4
a584 5
	for (i = a->top - 1; i >= 0; i--)
		{
		s->d[2*i+1] = SQR1(a->d[i]);
		s->d[2*i  ] = SQR0(a->d[i]);
		}
d588 2
a589 1
	if (!BN_GF2m_mod_arr(r, s, p)) goto err;
d592 1
d596 1
a596 1
	}
d601 1
a601 1
 * function is only provided for convenience; for best performance, use the 
d604 3
a606 2
int	BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
	{
d609 1
a609 1
	int *arr=NULL;
d613 2
a614 1
	if ((arr = (int *)malloc(sizeof(int) * max)) == NULL) goto err;
d616 2
a617 3
	if (!ret || ret > max)
		{
		BNerr(BN_F_BN_GF2M_MOD_SQR,BN_R_INVALID_LENGTH);
d619 1
a619 1
		}
d622 1
d624 2
a625 1
	if (arr) free(arr);
d627 1
a627 1
	}
d630 1
a630 1
/* Invert a, reduce modulo p, and store the result in r. r could be a. 
d635 3
a637 2
int BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
	{
a644 5
	
	if ((b = BN_CTX_get(ctx))==NULL) goto err;
	if ((c = BN_CTX_get(ctx))==NULL) goto err;
	if ((u = BN_CTX_get(ctx))==NULL) goto err;
	if ((v = BN_CTX_get(ctx))==NULL) goto err;
d646 8
a653 2
	if (!BN_GF2m_mod(u, a, p)) goto err;
	if (BN_is_zero(u)) goto err;
d655 7
a661 1
	if (!BN_copy(v, p)) goto err;
d663 2
a664 1
	if (!BN_one(b)) goto err;
d666 9
a674 11
	while (1)
		{
		while (!BN_is_odd(u))
			{
			if (BN_is_zero(u)) goto err;
			if (!BN_rshift1(u, u)) goto err;
			if (BN_is_odd(b))
				{
				if (!BN_GF2m_add(b, b, p)) goto err;
				}
			if (!BN_rshift1(b, b)) goto err;
d676 3
d680 2
a681 1
		if (BN_abs_is_word(u, 1)) break;
d683 7
a689 8
		if (BN_num_bits(u) < BN_num_bits(v))
			{
			tmp = u; u = v; v = tmp;
			tmp = b; b = c; c = tmp;
			}
		
		if (!BN_GF2m_add(u, u, v)) goto err;
		if (!BN_GF2m_add(b, b, c)) goto err;
d691 6
d699 1
a699 1
	int i,	ubits = BN_num_bits(u),
d702 1
a702 1
	BN_ULONG *udp,*bdp,*vdp,*cdp;
d704 37
a740 32
	bn_wexpand(u,top);	udp = u->d;
				for (i=u->top;i<top;i++) udp[i] = 0;
				u->top = top;
	bn_wexpand(b,top);	bdp = b->d;
				bdp[0] = 1;
				for (i=1;i<top;i++) bdp[i] = 0;
				b->top = top;
	bn_wexpand(c,top);	cdp = c->d;
				for (i=0;i<top;i++) cdp[i] = 0;
				c->top = top;
	vdp = v->d;	/* It pays off to "cache" *->d pointers, because
			 * it allows optimizer to be more aggressive.
			 * But we don't have to "cache" p->d, because *p
			 * is declared 'const'... */
	while (1)
		{
		while (ubits && !(udp[0]&1))
			{
			BN_ULONG u0,u1,b0,b1,mask;

			u0   = udp[0];
			b0   = bdp[0];
			mask = (BN_ULONG)0-(b0&1);
			b0  ^= p->d[0]&mask;
			for (i=0;i<top-1;i++)
				{
				u1 = udp[i+1];
				udp[i] = ((u0>>1)|(u1<<(BN_BITS2-1)))&BN_MASK2;
				u0 = u1;
				b1 = bdp[i+1]^(p->d[i+1]&mask);
				bdp[i] = ((b0>>1)|(b1<<(BN_BITS2-1)))&BN_MASK2;
				b0 = b1;
d742 3
a744 3
			udp[i] = u0>>1;
			bdp[i] = b0>>1;
			ubits--;
d747 2
a748 1
		if (ubits<=BN_BITS2 && udp[0]==1) break;
d750 14
a763 7
		if (ubits<vbits)
			{
			i = ubits; ubits = vbits; vbits = i;
			tmp = u; u = v; v = tmp;
			tmp = b; b = c; c = tmp;
			udp = vdp; vdp = v->d;
			bdp = cdp; cdp = c->d;
d765 3
a767 4
		for(i=0;i<top;i++)
			{
			udp[i] ^= vdp[i];
			bdp[i] ^= cdp[i];
d769 7
a775 7
		if (ubits==vbits)
			{
			BN_ULONG ul;
			int utop = (ubits-1)/BN_BITS2;

			while ((ul=udp[utop])==0 && utop) utop--;
			ubits = utop*BN_BITS2 + BN_num_bits_word(ul);
d778 1
a778 1
	bn_correct_top(b);
d782 2
a783 1
	if (!BN_copy(r, b)) goto err;
d789 3
a791 3
        bn_correct_top(c);
        bn_correct_top(u);
        bn_correct_top(v);
d793 1
a793 1
  	BN_CTX_end(ctx);
d795 1
a795 1
	}
d797 1
a797 1
/* Invert xx, reduce modulo p, and store the result in r. r could be xx. 
d800 1
a800 1
 * function is only provided for convenience; for best performance, use the 
d803 3
a805 2
int BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *xx, const int p[], BN_CTX *ctx)
	{
d811 5
a815 3
	if ((field = BN_CTX_get(ctx)) == NULL) goto err;
	if (!BN_GF2m_arr2poly(p, field)) goto err;
	
d822 1
a822 1
	}
d826 1
a826 1
/* Divide y by x, reduce modulo p, and store the result in r. r could be x 
d829 4
a832 2
int BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *y, const BIGNUM *x, const BIGNUM *p, BN_CTX *ctx)
	{
d842 7
a848 4
	if (xinv == NULL) goto err;
	
	if (!BN_GF2m_mod_inv(xinv, x, p, ctx)) goto err;
	if (!BN_GF2m_mod_mul(r, y, xinv, p, ctx)) goto err;
d855 1
a855 1
	}
d857 1
a857 1
/* Divide y by x, reduce modulo p, and store the result in r. r could be x 
d859 2
a860 2
 * Uses algorithm Modular_Division_GF(2^m) from 
 *     Chang-Shantz, S.  "From Euclid's GCD to Montgomery Multiplication to 
d863 4
a866 2
int BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *y, const BIGNUM *x, const BIGNUM *p, BN_CTX *ctx)
	{
d875 1
a875 1
	
d880 2
a881 1
	if (v == NULL) goto err;
d884 16
a899 10
	if (!BN_GF2m_mod(u, y, p)) goto err;
	if (!BN_GF2m_mod(a, x, p)) goto err;
	if (!BN_copy(b, p)) goto err;
	
	while (!BN_is_odd(a))
		{
		if (!BN_rshift1(a, a)) goto err;
		if (BN_is_odd(u)) if (!BN_GF2m_add(u, u, p)) goto err;
		if (!BN_rshift1(u, u)) goto err;
		}
d901 16
a916 14
	do
		{
		if (BN_GF2m_cmp(b, a) > 0)
			{
			if (!BN_GF2m_add(b, b, a)) goto err;
			if (!BN_GF2m_add(v, v, u)) goto err;
			do
				{
				if (!BN_rshift1(b, b)) goto err;
				if (BN_is_odd(v)) if (!BN_GF2m_add(v, v, p)) goto err;
				if (!BN_rshift1(v, v)) goto err;
				} while (!BN_is_odd(b));
			}
		else if (BN_abs_is_word(a, 1))
d918 16
a933 12
		else
			{
			if (!BN_GF2m_add(a, a, b)) goto err;
			if (!BN_GF2m_add(u, u, v)) goto err;
			do
				{
				if (!BN_rshift1(a, a)) goto err;
				if (BN_is_odd(u)) if (!BN_GF2m_add(u, u, p)) goto err;
				if (!BN_rshift1(u, u)) goto err;
				} while (!BN_is_odd(a));
			}
		} while (1);
d935 2
a936 1
	if (!BN_copy(r, u)) goto err;
d941 1
a941 1
  	BN_CTX_end(ctx);
d943 1
a943 1
	}
d946 1
a946 1
/* Divide yy by xx, reduce modulo p, and store the result in r. r could be xx 
d950 1
a950 1
 * function is only provided for convenience; for best performance, use the 
d953 4
a956 2
int BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *yy, const BIGNUM *xx, const int p[], BN_CTX *ctx)
	{
d964 5
a968 3
	if ((field = BN_CTX_get(ctx)) == NULL) goto err;
	if (!BN_GF2m_arr2poly(p, field)) goto err;
	
d975 1
a975 1
	}
d982 4
a985 2
int	BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const int p[], BN_CTX *ctx)
	{
d993 1
a993 1
		return(BN_one(r));
d999 6
a1004 4
	if ((u = BN_CTX_get(ctx)) == NULL) goto err;
	
	if (!BN_GF2m_mod_arr(u, a, p)) goto err;
	
d1006 6
a1011 7
	for (i = n - 1; i >= 0; i--)
		{
		if (!BN_GF2m_mod_sqr_arr(u, u, p, ctx)) goto err;
		if (BN_is_bit_set(b, i))
			{
			if (!BN_GF2m_mod_mul_arr(u, u, a, p, ctx)) goto err;
			}
d1013 3
a1015 1
	if (!BN_copy(r, u)) goto err;
d1018 1
d1022 1
a1022 1
	}
d1028 1
a1028 1
 * function is only provided for convenience; for best performance, use the 
d1031 4
a1034 2
int BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *p, BN_CTX *ctx)
	{
d1037 2
a1038 1
	int *arr=NULL;
d1042 2
a1043 1
	if ((arr = (int *)malloc(sizeof(int) * max)) == NULL) goto err;
d1045 2
a1046 3
	if (!ret || ret > max)
		{
		BNerr(BN_F_BN_GF2M_MOD_EXP,BN_R_INVALID_LENGTH);
d1048 1
a1048 1
		}
d1051 1
d1053 2
a1054 1
	if (arr) free(arr);
d1056 1
a1056 1
	}
d1062 3
a1064 2
int	BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a, const int p[], BN_CTX *ctx)
	{
d1070 1
a1070 2
	if (!p[0])
		{
d1074 1
a1074 1
		}
d1077 5
a1081 3
	if ((u = BN_CTX_get(ctx)) == NULL) goto err;
	
	if (!BN_set_bit(u, p[0] - 1)) goto err;
d1088 1
a1088 1
	}
d1094 1
a1094 1
 * function is only provided for convenience; for best performance, use the 
d1097 3
a1099 2
int BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
	{
d1102 1
a1102 1
	int *arr=NULL;
d1105 2
a1106 1
	if ((arr = (int *)malloc(sizeof(int) * max)) == NULL) goto err;
d1108 2
a1109 3
	if (!ret || ret > max)
		{
		BNerr(BN_F_BN_GF2M_MOD_SQRT,BN_R_INVALID_LENGTH);
d1111 1
a1111 1
		}
d1114 1
d1116 2
a1117 1
	if (arr) free(arr);
d1119 1
a1119 1
	}
d1124 4
a1127 2
int BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const int p[], BN_CTX *ctx)
	{
d1133 1
a1133 2
	if (!p[0])
		{
d1137 1
a1137 1
		}
d1143 2
a1144 1
	if (w == NULL) goto err;
d1146 4
a1149 4
	if (!BN_GF2m_mod_arr(a, a_, p)) goto err;
	
	if (BN_is_zero(a))
		{
d1153 1
a1153 1
		}
d1156 1
a1156 1
		{
d1158 9
a1166 8
		if (!BN_copy(z, a)) goto err;
		for (j = 1; j <= (p[0] - 1) / 2; j++)
			{
			if (!BN_GF2m_mod_sqr_arr(z, z, p, ctx)) goto err;
			if (!BN_GF2m_mod_sqr_arr(z, z, p, ctx)) goto err;
			if (!BN_GF2m_add(z, z, a)) goto err;
			}
		
d1168 2
d1171 1
a1171 1
		{
d1175 7
a1181 5
		if (tmp == NULL) goto err;
		do
			{
			if (!BN_rand(rho, p[0], 0, 0)) goto err;
			if (!BN_GF2m_mod_arr(rho, rho, p)) goto err;
d1183 14
a1196 9
			if (!BN_copy(w, rho)) goto err;
			for (j = 1; j <= p[0] - 1; j++)
				{
				if (!BN_GF2m_mod_sqr_arr(z, z, p, ctx)) goto err;
				if (!BN_GF2m_mod_sqr_arr(w2, w, p, ctx)) goto err;
				if (!BN_GF2m_mod_mul_arr(tmp, w2, a, p, ctx)) goto err;
				if (!BN_GF2m_add(z, z, tmp)) goto err;
				if (!BN_GF2m_add(w, w2, rho)) goto err;
				}
d1198 4
a1201 4
			} while (BN_is_zero(w) && (count < MAX_ITERATIONS));
		if (BN_is_zero(w))
			{
			BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR,BN_R_TOO_MANY_ITERATIONS);
a1202 1
			}
d1204 7
a1210 5
	
	if (!BN_GF2m_mod_sqr_arr(w, z, p, ctx)) goto err;
	if (!BN_GF2m_add(w, z, w)) goto err;
	if (BN_GF2m_cmp(w, a))
		{
d1213 1
a1213 1
		}
d1215 2
a1216 1
	if (!BN_copy(r, z)) goto err;
d1224 1
a1224 1
	}
d1229 1
a1229 1
 * function is only provided for convenience; for best performance, use the 
d1232 3
a1234 2
int BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
	{
d1237 2
a1238 1
	int *arr=NULL;
d1241 2
a1242 2
	if ((arr = (int *)malloc(sizeof(int) *
						max)) == NULL) goto err;
d1244 2
a1245 3
	if (!ret || ret > max)
		{
		BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD,BN_R_INVALID_LENGTH);
d1247 1
a1247 1
		}
d1250 1
d1252 2
a1253 1
	if (arr) free(arr);
d1255 1
a1255 1
	}
d1258 1
a1258 1
 * ( \sum_{i=0}^n a_i * x^i) into an array of integers corresponding 
d1263 3
a1265 2
int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)
	{
d1272 1
a1272 2
	for (i = a->top - 1; i >= 0; i--)
		{
d1277 4
a1280 5
		for (j = BN_BITS2 - 1; j >= 0; j--)
			{
			if (a->d[i] & mask) 
				{
				if (k < max) p[k] = BN_BITS2 * i + j;
d1282 1
a1282 1
				}
a1283 1
			}
d1285 1
d1293 1
a1293 1
	}
d1295 1
a1295 1
/* Convert the coefficient array representation of a polynomial to a 
d1298 3
a1300 2
int BN_GF2m_arr2poly(const int p[], BIGNUM *a)
	{
d1305 1
a1305 2
	for (i = 0; p[i] != -1; i++)
		{
d1308 1
a1308 1
		}
d1312 1
a1312 1
	}
@


1.7
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d106 1
a106 1
#if defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)
d117 1
a117 2
#endif
#ifdef THIRTY_TWO_BIT
a131 1
#ifdef THIRTY_TWO_BIT
d134 1
d162 1
a162 5
	} 
#endif
#if defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)
static void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a, const BN_ULONG b)
	{
d198 1
a199 1
#endif
@


1.6
log
@resolve conflicts
@
text
@d447 1
a447 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
d457 1
a457 1
	if (arr) OPENSSL_free(arr);
d503 1
a503 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
d513 1
a513 1
	if (arr) OPENSSL_free(arr);
d864 1
a864 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
d874 1
a874 1
	if (arr) OPENSSL_free(arr);
d922 1
a922 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
d932 1
a932 1
	if (arr) OPENSSL_free(arr);
d1040 1
a1040 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) *
d1051 1
a1051 1
	if (arr) OPENSSL_free(arr);
@


1.5
log
@openssl-1.0.0e: resolve conflicts
@
text
@d97 2
d127 1
d222 3
a224 1

d368 1
a368 2
	const int max = BN_num_bits(p) + 1;
	int *arr=NULL;
d371 2
a372 3
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
	ret = BN_GF2m_poly2arr(p, arr, max);
	if (!ret || ret > max)
d375 1
a375 1
		goto err;
a378 2
err:
	if (arr) OPENSSL_free(arr);
d525 1
a525 1
	BIGNUM *b, *c, *u, *v, *tmp;
d533 4
a536 5
	b = BN_CTX_get(ctx);
	c = BN_CTX_get(ctx);
	u = BN_CTX_get(ctx);
	v = BN_CTX_get(ctx);
	if (v == NULL) goto err;
a537 1
	if (!BN_one(b)) goto err;
d539 2
d542 2
a543 2

	if (BN_is_zero(u)) goto err;
d569 44
d614 27
d647 5
d1113 1
@


1.4
log
@resolve conflicts, fix local changes
@
text
@d548 1
@


1.3
log
@cherrypick patch from OpenSSL 0.9.8m:

  *) Always check bn_wexpend() return values for failure.  (CVE-2009-3245)
     [Martin Olsson, Neel Mehta]
@
text
@a123 12
#ifdef SIXTEEN_BIT
#define SQR1(w) \
    SQR_tb[(w) >> 12 & 0xF] <<  8 | SQR_tb[(w) >>  8 & 0xF]
#define SQR0(w) \
    SQR_tb[(w) >>  4 & 0xF] <<  8 | SQR_tb[(w)       & 0xF]
#endif
#ifdef EIGHT_BIT
#define SQR1(w) \
    SQR_tb[(w) >>  4 & 0xF]
#define SQR0(w) \
    SQR_tb[(w)       & 15]
#endif
a129 50
#ifdef EIGHT_BIT
static void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a, const BN_ULONG b)
	{
	register BN_ULONG h, l, s;
	BN_ULONG tab[4], top1b = a >> 7;
	register BN_ULONG a1, a2;

	a1 = a & (0x7F); a2 = a1 << 1;

	tab[0] = 0; tab[1] = a1; tab[2] = a2; tab[3] = a1^a2;

	s = tab[b      & 0x3]; l  = s;
	s = tab[b >> 2 & 0x3]; l ^= s << 2; h  = s >> 6;
	s = tab[b >> 4 & 0x3]; l ^= s << 4; h ^= s >> 4;
	s = tab[b >> 6      ]; l ^= s << 6; h ^= s >> 2;
	
	/* compensate for the top bit of a */

	if (top1b & 01) { l ^= b << 7; h ^= b >> 1; } 

	*r1 = h; *r0 = l;
	} 
#endif
#ifdef SIXTEEN_BIT
static void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a, const BN_ULONG b)
	{
	register BN_ULONG h, l, s;
	BN_ULONG tab[4], top1b = a >> 15; 
	register BN_ULONG a1, a2;

	a1 = a & (0x7FFF); a2 = a1 << 1;

	tab[0] = 0; tab[1] = a1; tab[2] = a2; tab[3] = a1^a2;

	s = tab[b      & 0x3]; l  = s;
	s = tab[b >> 2 & 0x3]; l ^= s <<  2; h  = s >> 14;
	s = tab[b >> 4 & 0x3]; l ^= s <<  4; h ^= s >> 12;
	s = tab[b >> 6 & 0x3]; l ^= s <<  6; h ^= s >> 10;
	s = tab[b >> 8 & 0x3]; l ^= s <<  8; h ^= s >>  8;
	s = tab[b >>10 & 0x3]; l ^= s << 10; h ^= s >>  6;
	s = tab[b >>12 & 0x3]; l ^= s << 12; h ^= s >>  4;
	s = tab[b >>14      ]; l ^= s << 14; h ^= s >>  2;

	/* compensate for the top bit of a */

	if (top1b & 01) { l ^= b << 15; h ^= b >> 1; } 

	*r1 = h; *r0 = l;
	} 
#endif
d262 1
a262 1
int BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const unsigned int p[])
d363 2
a364 2
	const int max = BN_num_bits(p);
	unsigned int *arr=NULL;
d367 1
a367 1
	if ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;
d385 1
a385 1
int	BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const unsigned int p[], BN_CTX *ctx)
d441 2
a442 2
	const int max = BN_num_bits(p);
	unsigned int *arr=NULL;
d446 1
a446 1
	if ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;
d462 1
a462 1
int	BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const unsigned int p[], BN_CTX *ctx)
d497 2
a498 2
	const int max = BN_num_bits(p);
	unsigned int *arr=NULL;
d502 1
a502 1
	if ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;
d584 1
a584 1
int BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *xx, const unsigned int p[], BN_CTX *ctx)
d710 1
a710 1
int BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *yy, const BIGNUM *xx, const unsigned int p[], BN_CTX *ctx)
d735 1
a735 1
int	BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const unsigned int p[], BN_CTX *ctx)
d781 2
a782 2
	const int max = BN_num_bits(p);
	unsigned int *arr=NULL;
d786 1
a786 1
	if ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;
d804 1
a804 1
int	BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a, const unsigned int p[], BN_CTX *ctx)
d840 2
a841 2
	const int max = BN_num_bits(p);
	unsigned int *arr=NULL;
d844 1
a844 1
	if ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;
d861 1
a861 1
int BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const unsigned int p[], BN_CTX *ctx)
d863 1
a863 2
	int ret = 0, count = 0;
	unsigned int j;
d958 2
a959 2
	const int max = BN_num_bits(p);
	unsigned int *arr=NULL;
d962 1
a962 1
	if ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) *
d978 2
a979 2
 * ( \sum_{i=0}^n a_i * x^i , where a_0 is *not* zero) into an array
 * of integers corresponding to the bits with non-zero coefficient.
d981 1
a981 1
 * number of coefficients that would be extracted if array was large enough.
d983 1
a983 1
int BN_GF2m_poly2arr(const BIGNUM *a, unsigned int p[], int max)
d988 1
a988 4
	if (BN_is_zero(a) || !BN_is_bit_set(a, 0))
		/* a_0 == 0 => return error (the unsigned int array
		 * must be terminated by 0)
		 */
d1008 5
d1017 1
a1017 1
 * bit-string.  The array must be terminated by 0.
d1019 1
a1019 1
int BN_GF2m_arr2poly(const unsigned int p[], BIGNUM *a)
d1025 1
a1025 1
	for (i = 0; p[i] != 0; i++)
a1029 1
	BN_set_bit(a, 0);
@


1.2
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d297 2
a298 1
	bn_wexpand(r, at->top);
@


1.2.2.1
log
@MFC, original commit by djm@@:
---------------------------
cherrypick patch from OpenSSL 0.9.8m:

  *) Always check bn_wexpend() return values for failure.  (CVE-2009-3245)
     [Martin Olsson, Neel Mehta]

---------------------------

ok sthen@@
@
text
@d297 1
a297 2
	if(bn_wexpand(r, at->top) == NULL)
		return 0;
@


1.2.6.1
log
@MFC, original commit by djm@@:
---------------------------
cherrypick patch from OpenSSL 0.9.8m:

  *) Always check bn_wexpend() return values for failure.  (CVE-2009-3245)
     [Martin Olsson, Neel Mehta]

---------------------------

ok sthen@@
@
text
@d297 1
a297 2
	if(bn_wexpand(r, at->top) == NULL)
		return 0;
@


1.1
log
@Initial revision
@
text
@d387 5
a391 1
		if (d0) z[dN] = (z[dN] << d1) >> d1; /* clear up the top d1 bits */
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@d387 1
a387 5
		/* clear up the top d1 bits */
		if (d0)
			z[dN] = (z[dN] << d1) >> d1;
		else
			z[dN] = 0;
@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d124 12
d142 50
d297 1
a297 2
	if(bn_wexpand(r, at->top) == NULL)
		return 0;
d323 1
a323 1
int BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[])
d424 2
a425 2
	const int max = BN_num_bits(p) + 1;
	int *arr=NULL;
d428 1
a428 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
d446 1
a446 1
int	BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const int p[], BN_CTX *ctx)
d502 2
a503 2
	const int max = BN_num_bits(p) + 1;
	int *arr=NULL;
d507 1
a507 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
d523 1
a523 1
int	BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const int p[], BN_CTX *ctx)
d558 2
a559 2
	const int max = BN_num_bits(p) + 1;
	int *arr=NULL;
d563 1
a563 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
d645 1
a645 1
int BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *xx, const int p[], BN_CTX *ctx)
d771 1
a771 1
int BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *yy, const BIGNUM *xx, const int p[], BN_CTX *ctx)
d796 1
a796 1
int	BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const int p[], BN_CTX *ctx)
d842 2
a843 2
	const int max = BN_num_bits(p) + 1;
	int *arr=NULL;
d847 1
a847 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
d865 1
a865 1
int	BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a, const int p[], BN_CTX *ctx)
d901 2
a902 2
	const int max = BN_num_bits(p) + 1;
	int *arr=NULL;
d905 1
a905 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL) goto err;
d922 1
a922 1
int BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const int p[], BN_CTX *ctx)
d924 2
a925 1
	int ret = 0, count = 0, j;
d1020 2
a1021 2
	const int max = BN_num_bits(p) + 1;
	int *arr=NULL;
d1024 1
a1024 1
	if ((arr = (int *)OPENSSL_malloc(sizeof(int) *
d1040 2
a1041 2
 * ( \sum_{i=0}^n a_i * x^i) into an array of integers corresponding 
 * to the bits with non-zero coefficient.  Array is terminated with -1.
d1043 1
a1043 1
 * number of array elements that would be filled if array was large enough.
d1045 1
a1045 1
int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)
d1050 4
a1053 1
	if (BN_is_zero(a))
a1072 5
	if (k < max) {
		p[k] = -1;
		k++;
	}

d1077 1
a1077 1
 * bit-string.  The array must be terminated by -1.
d1079 1
a1079 1
int BN_GF2m_arr2poly(const int p[], BIGNUM *a)
d1085 1
a1085 1
	for (i = 0; p[i] != -1; i++)
d1090 1
@


1.1.1.4
log
@import OpenSSL 1.0.0e
@
text
@a547 1
			if (BN_is_zero(u)) goto err;
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@a96 2
#ifndef OPENSSL_NO_EC2M

a124 1
#if !defined(OPENSSL_BN_ASM_GF2m)
d219 1
a219 3
#else
void bn_GF2m_mul_2x2(BN_ULONG *r, BN_ULONG a1, BN_ULONG a0, BN_ULONG b1, BN_ULONG b0);
#endif 
d363 2
a364 1
	int arr[6];
d367 3
a369 2
	ret = BN_GF2m_poly2arr(p, arr, sizeof(arr)/sizeof(arr[0]));
	if (!ret || ret > (int)(sizeof(arr)/sizeof(arr[0])))
d372 1
a372 1
		return 0;
d376 2
d524 1
a524 1
	BIGNUM *b, *c = NULL, *u = NULL, *v = NULL, *tmp;
d532 5
a536 4
	if ((b = BN_CTX_get(ctx))==NULL) goto err;
	if ((c = BN_CTX_get(ctx))==NULL) goto err;
	if ((u = BN_CTX_get(ctx))==NULL) goto err;
	if ((v = BN_CTX_get(ctx))==NULL) goto err;
d538 1
d540 2
a543 4
	if (!BN_copy(v, p)) goto err;
#if 0
	if (!BN_one(b)) goto err;

a567 44
#else
	{
	int i,	ubits = BN_num_bits(u),
		vbits = BN_num_bits(v),	/* v is copy of p */
		top = p->top;
	BN_ULONG *udp,*bdp,*vdp,*cdp;

	bn_wexpand(u,top);	udp = u->d;
				for (i=u->top;i<top;i++) udp[i] = 0;
				u->top = top;
	bn_wexpand(b,top);	bdp = b->d;
				bdp[0] = 1;
				for (i=1;i<top;i++) bdp[i] = 0;
				b->top = top;
	bn_wexpand(c,top);	cdp = c->d;
				for (i=0;i<top;i++) cdp[i] = 0;
				c->top = top;
	vdp = v->d;	/* It pays off to "cache" *->d pointers, because
			 * it allows optimizer to be more aggressive.
			 * But we don't have to "cache" p->d, because *p
			 * is declared 'const'... */
	while (1)
		{
		while (ubits && !(udp[0]&1))
			{
			BN_ULONG u0,u1,b0,b1,mask;

			u0   = udp[0];
			b0   = bdp[0];
			mask = (BN_ULONG)0-(b0&1);
			b0  ^= p->d[0]&mask;
			for (i=0;i<top-1;i++)
				{
				u1 = udp[i+1];
				udp[i] = ((u0>>1)|(u1<<(BN_BITS2-1)))&BN_MASK2;
				u0 = u1;
				b1 = bdp[i+1]^(p->d[i+1]&mask);
				bdp[i] = ((b0>>1)|(b1<<(BN_BITS2-1)))&BN_MASK2;
				b0 = b1;
				}
			udp[i] = u0>>1;
			bdp[i] = b0>>1;
			ubits--;
			}
a568 27
		if (ubits<=BN_BITS2 && udp[0]==1) break;

		if (ubits<vbits)
			{
			i = ubits; ubits = vbits; vbits = i;
			tmp = u; u = v; v = tmp;
			tmp = b; b = c; c = tmp;
			udp = vdp; vdp = v->d;
			bdp = cdp; cdp = c->d;
			}
		for(i=0;i<top;i++)
			{
			udp[i] ^= vdp[i];
			bdp[i] ^= cdp[i];
			}
		if (ubits==vbits)
			{
			BN_ULONG ul;
			int utop = (ubits-1)/BN_BITS2;

			while ((ul=udp[utop])==0 && utop) utop--;
			ubits = utop*BN_BITS2 + BN_num_bits_word(ul);
			}
		}
	bn_correct_top(b);
	}
#endif
a574 5
#ifdef BN_DEBUG /* BN_CTX_end would complain about the expanded form */
        bn_correct_top(c);
        bn_correct_top(u);
        bn_correct_top(v);
#endif
a1035 1
#endif
@


