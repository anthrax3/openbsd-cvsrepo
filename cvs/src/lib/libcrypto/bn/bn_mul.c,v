head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.6
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20;
locks; strict;
comment	@ * @;


1.20
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.19;
commitid	69Tc75PIK8JcRRsC;

1.19
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.18;
commitid	yQEL1wOWIearrW15;

1.18
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.17;
commitid	nzndm3zqPmFurSaK;

1.17
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.16;
commitid	id8dTrTMtnTn4fqt;

1.16
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	mJUVYpkFBZ0Zv2bG;

1.15
date	2014.05.08.13.20.49;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.21.01.49.11;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.57.21;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.33;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.44;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.58;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.36.38;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.43;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.12.50;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2011.11.03.02.32.09;	author djm;	state Exp;
branches;
next	;


desc
@@


1.20
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@/* $OpenBSD: bn_mul.c,v 1.19 2014/07/11 08:44:48 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#ifndef BN_DEBUG
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
#endif

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include "bn_lcl.h"

#if defined(OPENSSL_NO_ASM) || !defined(OPENSSL_BN_ASM_PART_WORDS)
/* Here follows specialised variants of bn_add_words() and
   bn_sub_words().  They have the property performing operations on
   arrays of different sizes.  The sizes of those arrays is expressed through
   cl, which is the common length ( basicall, min(len(a),len(b)) ), and dl,
   which is the delta between the two lengths, calculated as len(a)-len(b).
   All lengths are the number of BN_ULONGs...  For the operations that require
   a result array as parameter, it must have the length cl+abs(dl).
   These functions should probably end up in bn_asm.c as soon as there are
   assembler counterparts for the systems that use assembler files.  */

BN_ULONG
bn_sub_part_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int cl,
    int dl)
{
	BN_ULONG c, t;

	assert(cl >= 0);
	c = bn_sub_words(r, a, b, cl);

	if (dl == 0)
		return c;

	r += cl;
	a += cl;
	b += cl;

	if (dl < 0) {
#ifdef BN_COUNT
		fprintf(stderr,
		    "  bn_sub_part_words %d + %d (dl < 0, c = %d)\n",
		    cl, dl, c);
#endif
		for (;;) {
			t = b[0];
			r[0] = (0 - t - c) & BN_MASK2;
			if (t != 0)
				c = 1;
			if (++dl >= 0)
				break;

			t = b[1];
			r[1] = (0 - t - c) & BN_MASK2;
			if (t != 0)
				c = 1;
			if (++dl >= 0)
				break;

			t = b[2];
			r[2] = (0 - t - c) & BN_MASK2;
			if (t != 0)
				c = 1;
			if (++dl >= 0)
				break;

			t = b[3];
			r[3] = (0 - t - c) & BN_MASK2;
			if (t != 0)
				c = 1;
			if (++dl >= 0)
				break;

			b += 4;
			r += 4;
		}
	} else {
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr,
		    "  bn_sub_part_words %d + %d (dl > 0, c = %d)\n",
		    cl, dl, c);
#endif
		while (c) {
			t = a[0];
			r[0] = (t - c) & BN_MASK2;
			if (t != 0)
				c = 0;
			if (--dl <= 0)
				break;

			t = a[1];
			r[1] = (t - c) & BN_MASK2;
			if (t != 0)
				c = 0;
			if (--dl <= 0)
				break;

			t = a[2];
			r[2] = (t - c) & BN_MASK2;
			if (t != 0)
				c = 0;
			if (--dl <= 0)
				break;

			t = a[3];
			r[3] = (t - c) & BN_MASK2;
			if (t != 0)
				c = 0;
			if (--dl <= 0)
				break;

			save_dl = dl;
			a += 4;
			r += 4;
		}
		if (dl > 0) {
#ifdef BN_COUNT
			fprintf(stderr,
			    "  bn_sub_part_words %d + %d (dl > 0, c == 0)\n",
			    cl, dl);
#endif
			if (save_dl > dl) {
				switch (save_dl - dl) {
				case 1:
					r[1] = a[1];
					if (--dl <= 0)
						break;
				case 2:
					r[2] = a[2];
					if (--dl <= 0)
						break;
				case 3:
					r[3] = a[3];
					if (--dl <= 0)
						break;
				}
				a += 4;
				r += 4;
			}
		}
		if (dl > 0) {
#ifdef BN_COUNT
			fprintf(stderr,
			    "  bn_sub_part_words %d + %d (dl > 0, copy)\n",
			    cl, dl);
#endif
			for (;;) {
				r[0] = a[0];
				if (--dl <= 0)
					break;
				r[1] = a[1];
				if (--dl <= 0)
					break;
				r[2] = a[2];
				if (--dl <= 0)
					break;
				r[3] = a[3];
				if (--dl <= 0)
					break;

				a += 4;
				r += 4;
			}
		}
	}
	return c;
}
#endif

BN_ULONG
bn_add_part_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int cl,
    int dl)
{
	BN_ULONG c, l, t;

	assert(cl >= 0);
	c = bn_add_words(r, a, b, cl);

	if (dl == 0)
		return c;

	r += cl;
	a += cl;
	b += cl;

	if (dl < 0) {
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr,
		    "  bn_add_part_words %d + %d (dl < 0, c = %d)\n",
		    cl, dl, c);
#endif
		while (c) {
			l = (c + b[0]) & BN_MASK2;
			c = (l < c);
			r[0] = l;
			if (++dl >= 0)
				break;

			l = (c + b[1]) & BN_MASK2;
			c = (l < c);
			r[1] = l;
			if (++dl >= 0)
				break;

			l = (c + b[2]) & BN_MASK2;
			c = (l < c);
			r[2] = l;
			if (++dl >= 0)
				break;

			l = (c + b[3]) & BN_MASK2;
			c = (l < c);
			r[3] = l;
			if (++dl >= 0)
				break;

			save_dl = dl;
			b += 4;
			r += 4;
		}
		if (dl < 0) {
#ifdef BN_COUNT
			fprintf(stderr,
			    "  bn_add_part_words %d + %d (dl < 0, c == 0)\n",
			    cl, dl);
#endif
			if (save_dl < dl) {
				switch (dl - save_dl) {
				case 1:
					r[1] = b[1];
					if (++dl >= 0)
						break;
				case 2:
					r[2] = b[2];
					if (++dl >= 0)
						break;
				case 3:
					r[3] = b[3];
					if (++dl >= 0)
						break;
				}
				b += 4;
				r += 4;
			}
		}
		if (dl < 0) {
#ifdef BN_COUNT
			fprintf(stderr,
			    "  bn_add_part_words %d + %d (dl < 0, copy)\n",
			    cl, dl);
#endif
			for (;;) {
				r[0] = b[0];
				if (++dl >= 0)
					break;
				r[1] = b[1];
				if (++dl >= 0)
					break;
				r[2] = b[2];
				if (++dl >= 0)
					break;
				r[3] = b[3];
				if (++dl >= 0)
					break;

				b += 4;
				r += 4;
			}
		}
	} else {
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr,
		    "  bn_add_part_words %d + %d (dl > 0)\n", cl, dl);
#endif
		while (c) {
			t = (a[0] + c) & BN_MASK2;
			c = (t < c);
			r[0] = t;
			if (--dl <= 0)
				break;

			t = (a[1] + c) & BN_MASK2;
			c = (t < c);
			r[1] = t;
			if (--dl <= 0)
				break;

			t = (a[2] + c) & BN_MASK2;
			c = (t < c);
			r[2] = t;
			if (--dl <= 0)
				break;

			t = (a[3] + c) & BN_MASK2;
			c = (t < c);
			r[3] = t;
			if (--dl <= 0)
				break;

			save_dl = dl;
			a += 4;
			r += 4;
		}
#ifdef BN_COUNT
		fprintf(stderr,
		    "  bn_add_part_words %d + %d (dl > 0, c == 0)\n", cl, dl);
#endif
		if (dl > 0) {
			if (save_dl > dl) {
				switch (save_dl - dl) {
				case 1:
					r[1] = a[1];
					if (--dl <= 0)
						break;
				case 2:
					r[2] = a[2];
					if (--dl <= 0)
						break;
				case 3:
					r[3] = a[3];
					if (--dl <= 0)
						break;
				}
				a += 4;
				r += 4;
			}
		}
		if (dl > 0) {
#ifdef BN_COUNT
			fprintf(stderr,
			    "  bn_add_part_words %d + %d (dl > 0, copy)\n",
			    cl, dl);
#endif
			for (;;) {
				r[0] = a[0];
				if (--dl <= 0)
					break;
				r[1] = a[1];
				if (--dl <= 0)
					break;
				r[2] = a[2];
				if (--dl <= 0)
					break;
				r[3] = a[3];
				if (--dl <= 0)
					break;

				a += 4;
				r += 4;
			}
		}
	}
	return c;
}

#ifdef BN_RECURSION
/* Karatsuba recursive multiplication algorithm
 * (cf. Knuth, The Art of Computer Programming, Vol. 2) */

/* r is 2*n2 words in size,
 * a and b are both n2 words in size.
 * n2 must be a power of 2.
 * We multiply and return the result.
 * t must be 2*n2 words in size
 * We calculate
 * a[0]*b[0]
 * a[0]*b[0]+a[1]*b[1]+(a[0]-a[1])*(b[1]-b[0])
 * a[1]*b[1]
 */
/* dnX may not be positive, but n2/2+dnX has to be */
void
bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2, int dna,
    int dnb, BN_ULONG *t)
{
	int n = n2 / 2, c1, c2;
	int tna = n + dna, tnb = n + dnb;
	unsigned int neg, zero;
	BN_ULONG ln, lo, *p;

# ifdef BN_COUNT
	fprintf(stderr, " bn_mul_recursive %d%+d * %d%+d\n",n2,dna,n2,dnb);
# endif
# ifdef BN_MUL_COMBA
#  if 0
	if (n2 == 4) {
		bn_mul_comba4(r, a, b);
		return;
	}
#  endif
	/* Only call bn_mul_comba 8 if n2 == 8 and the
	 * two arrays are complete [steve]
	 */
	if (n2 == 8 && dna == 0 && dnb == 0) {
		bn_mul_comba8(r, a, b);
		return;
	}
# endif /* BN_MUL_COMBA */
	/* Else do normal multiply */
	if (n2 < BN_MUL_RECURSIVE_SIZE_NORMAL) {
		bn_mul_normal(r, a, n2 + dna, b, n2 + dnb);
		if ((dna + dnb) < 0)
			memset(&r[2*n2 + dna + dnb], 0,
			    sizeof(BN_ULONG) * -(dna + dnb));
		return;
	}
	/* r=(a[0]-a[1])*(b[1]-b[0]) */
	c1 = bn_cmp_part_words(a, &(a[n]), tna, n - tna);
	c2 = bn_cmp_part_words(&(b[n]), b,tnb, tnb - n);
	zero = neg = 0;
	switch (c1 * 3 + c2) {
	case -4:
		bn_sub_part_words(t, &(a[n]), a, tna, tna - n); /* - */
		bn_sub_part_words(&(t[n]), b, &(b[n]), tnb, n - tnb); /* - */
		break;
	case -3:
		zero = 1;
		break;
	case -2:
		bn_sub_part_words(t, &(a[n]), a, tna, tna - n); /* - */
		bn_sub_part_words(&(t[n]), &(b[n]), b, tnb, tnb - n); /* + */
		neg = 1;
		break;
	case -1:
	case 0:
	case 1:
		zero = 1;
		break;
	case 2:
		bn_sub_part_words(t, a, &(a[n]), tna, n - tna); /* + */
		bn_sub_part_words(&(t[n]), b, &(b[n]), tnb, n - tnb); /* - */
		neg = 1;
		break;
	case 3:
		zero = 1;
		break;
	case 4:
		bn_sub_part_words(t, a, &(a[n]), tna, n - tna);
		bn_sub_part_words(&(t[n]), &(b[n]), b, tnb, tnb - n);
		break;
	}

# ifdef BN_MUL_COMBA
	if (n == 4 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba4 could take
					       extra args to do this well */
	{
		if (!zero)
			bn_mul_comba4(&(t[n2]), t, &(t[n]));
		else
			memset(&(t[n2]), 0, 8 * sizeof(BN_ULONG));

		bn_mul_comba4(r, a, b);
		bn_mul_comba4(&(r[n2]), &(a[n]), &(b[n]));
	} else if (n == 8 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba8 could
						    take extra args to do this
						    well */
	{
		if (!zero)
			bn_mul_comba8(&(t[n2]), t, &(t[n]));
		else
			memset(&(t[n2]), 0, 16 * sizeof(BN_ULONG));

		bn_mul_comba8(r, a, b);
		bn_mul_comba8(&(r[n2]), &(a[n]), &(b[n]));
	} else
# endif /* BN_MUL_COMBA */
	{
		p = &(t[n2 * 2]);
		if (!zero)
			bn_mul_recursive(&(t[n2]), t, &(t[n]), n, 0, 0, p);
		else
			memset(&(t[n2]), 0, n2 * sizeof(BN_ULONG));
		bn_mul_recursive(r, a, b, n, 0, 0, p);
		bn_mul_recursive(&(r[n2]), &(a[n]), &(b[n]), n, dna, dnb, p);
	}

	/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign
	 * r[10] holds (a[0]*b[0])
	 * r[32] holds (b[1]*b[1])
	 */

	c1 = (int)(bn_add_words(t, r, &(r[n2]), n2));

	if (neg) /* if t[32] is negative */
	{
		c1 -= (int)(bn_sub_words(&(t[n2]), t, &(t[n2]), n2));
	} else {
		/* Might have a carry */
		c1 += (int)(bn_add_words(&(t[n2]), &(t[n2]), t, n2));
	}

	/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])
	 * r[10] holds (a[0]*b[0])
	 * r[32] holds (b[1]*b[1])
	 * c1 holds the carry bits
	 */
	c1 += (int)(bn_add_words(&(r[n]), &(r[n]), &(t[n2]), n2));
	if (c1) {
		p = &(r[n + n2]);
		lo= *p;
		ln = (lo + c1) & BN_MASK2;
		*p = ln;

		/* The overflow will stop before we over write
		 * words we should not overwrite */
		if (ln < (BN_ULONG)c1) {
			do {
				p++;
				lo= *p;
				ln = (lo + 1) & BN_MASK2;
				*p = ln;
			} while (ln == 0);
		}
	}
}

/* n+tn is the word length
 * t needs to be n*4 is size, as does r */
/* tnX may not be negative but less than n */
void
bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n, int tna,
    int tnb, BN_ULONG *t)
{
	int i, j, n2 = n * 2;
	int c1, c2, neg;
	BN_ULONG ln, lo, *p;

# ifdef BN_COUNT
	fprintf(stderr, " bn_mul_part_recursive (%d%+d) * (%d%+d)\n",
	    n, tna, n, tnb);
# endif
	if (n < 8) {
		bn_mul_normal(r, a, n + tna, b, n + tnb);
		return;
	}

	/* r=(a[0]-a[1])*(b[1]-b[0]) */
	c1 = bn_cmp_part_words(a, &(a[n]), tna, n - tna);
	c2 = bn_cmp_part_words(&(b[n]), b, tnb, tnb - n);
	neg = 0;
	switch (c1 * 3 + c2) {
	case -4:
		bn_sub_part_words(t, &(a[n]), a, tna, tna - n); /* - */
		bn_sub_part_words(&(t[n]), b, &(b[n]), tnb, n - tnb); /* - */
		break;
	case -3:
		/* break; */
	case -2:
		bn_sub_part_words(t, &(a[n]), a, tna, tna - n); /* - */
		bn_sub_part_words(&(t[n]), &(b[n]), b, tnb, tnb - n); /* + */
		neg = 1;
		break;
	case -1:
	case 0:
	case 1:
		/* break; */
	case 2:
		bn_sub_part_words(t, a, &(a[n]), tna, n - tna); /* + */
		bn_sub_part_words(&(t[n]), b, &(b[n]), tnb, n - tnb); /* - */
		neg = 1;
		break;
	case 3:
		/* break; */
	case 4:
		bn_sub_part_words(t, a, &(a[n]), tna, n - tna);
		bn_sub_part_words(&(t[n]), &(b[n]), b, tnb, tnb - n);
		break;
	}
		/* The zero case isn't yet implemented here. The speedup
		   would probably be negligible. */
# if 0
	if (n == 4) {
		bn_mul_comba4(&(t[n2]), t, &(t[n]));
		bn_mul_comba4(r, a, b);
		bn_mul_normal(&(r[n2]), &(a[n]), tn, &(b[n]), tn);
		memset(&(r[n2 + tn * 2]), 0, sizeof(BN_ULONG) * (n2 - tn * 2));
	} else
# endif
		if (n == 8) {
		bn_mul_comba8(&(t[n2]), t, &(t[n]));
		bn_mul_comba8(r, a, b);
		bn_mul_normal(&(r[n2]), &(a[n]), tna, &(b[n]), tnb);
		memset(&(r[n2 + tna + tnb]), 0,
		    sizeof(BN_ULONG) * (n2 - tna - tnb));
	} else {
		p = &(t[n2*2]);
		bn_mul_recursive(&(t[n2]), t, &(t[n]), n, 0, 0, p);
		bn_mul_recursive(r, a, b, n, 0, 0, p);
		i = n / 2;
		/* If there is only a bottom half to the number,
		 * just do it */
		if (tna > tnb)
			j = tna - i;
		else
			j = tnb - i;
		if (j == 0) {
			bn_mul_recursive(&(r[n2]), &(a[n]), &(b[n]),
			    i, tna - i, tnb - i, p);
			memset(&(r[n2 + i * 2]), 0,
			    sizeof(BN_ULONG) * (n2 - i * 2));
		}
		else if (j > 0) /* eg, n == 16, i == 8 and tn == 11 */
		{
			bn_mul_part_recursive(&(r[n2]), &(a[n]), &(b[n]),
			    i, tna - i, tnb - i, p);
			memset(&(r[n2 + tna + tnb]), 0,
			    sizeof(BN_ULONG) * (n2 - tna - tnb));
		}
		else /* (j < 0) eg, n == 16, i == 8 and tn == 5 */
		{
			memset(&(r[n2]), 0, sizeof(BN_ULONG) * n2);
			if (tna < BN_MUL_RECURSIVE_SIZE_NORMAL &&
			    tnb < BN_MUL_RECURSIVE_SIZE_NORMAL) {
				bn_mul_normal(&(r[n2]), &(a[n]), tna,
				    &(b[n]), tnb);
			} else {
				for (;;) {
					i /= 2;
					/* these simplified conditions work
					 * exclusively because difference
					 * between tna and tnb is 1 or 0 */
					if (i < tna || i < tnb) {
						bn_mul_part_recursive(&(r[n2]),
						    &(a[n]), &(b[n]), i,
						    tna - i, tnb - i, p);
						break;
					} else if (i == tna || i == tnb) {
						bn_mul_recursive(&(r[n2]),
						    &(a[n]), &(b[n]), i,
						    tna - i, tnb - i, p);
						break;
					}
				}
			}
		}
	}

	/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign
	 * r[10] holds (a[0]*b[0])
	 * r[32] holds (b[1]*b[1])
	 */

	c1 = (int)(bn_add_words(t, r,&(r[n2]), n2));

	if (neg) /* if t[32] is negative */
	{
		c1 -= (int)(bn_sub_words(&(t[n2]), t,&(t[n2]), n2));
	} else {
		/* Might have a carry */
		c1 += (int)(bn_add_words(&(t[n2]), &(t[n2]), t, n2));
	}

	/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])
	 * r[10] holds (a[0]*b[0])
	 * r[32] holds (b[1]*b[1])
	 * c1 holds the carry bits
	 */
	c1 += (int)(bn_add_words(&(r[n]), &(r[n]), &(t[n2]), n2));
	if (c1) {
		p = &(r[n + n2]);
		lo= *p;
		ln = (lo + c1)&BN_MASK2;
		*p = ln;

		/* The overflow will stop before we over write
		 * words we should not overwrite */
		if (ln < (BN_ULONG)c1) {
			do {
				p++;
				lo= *p;
				ln = (lo + 1) & BN_MASK2;
				*p = ln;
			} while (ln == 0);
		}
	}
}

/* a and b must be the same size, which is n2.
 * r needs to be n2 words and t needs to be n2*2
 */
void
bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2, BN_ULONG *t)
{
	int n = n2 / 2;

# ifdef BN_COUNT
	fprintf(stderr, " bn_mul_low_recursive %d * %d\n",n2,n2);
# endif

	bn_mul_recursive(r, a, b, n, 0, 0, &(t[0]));
	if (n >= BN_MUL_LOW_RECURSIVE_SIZE_NORMAL) {
		bn_mul_low_recursive(&(t[0]), &(a[0]), &(b[n]), n, &(t[n2]));
		bn_add_words(&(r[n]), &(r[n]), &(t[0]), n);
		bn_mul_low_recursive(&(t[0]), &(a[n]), &(b[0]), n, &(t[n2]));
		bn_add_words(&(r[n]), &(r[n]), &(t[0]), n);
	} else {
		bn_mul_low_normal(&(t[0]), &(a[0]), &(b[n]), n);
		bn_mul_low_normal(&(t[n]), &(a[n]), &(b[0]), n);
		bn_add_words(&(r[n]), &(r[n]), &(t[0]), n);
		bn_add_words(&(r[n]), &(r[n]), &(t[n]), n);
	}
}

/* a and b must be the same size, which is n2.
 * r needs to be n2 words and t needs to be n2*2
 * l is the low words of the output.
 * t needs to be n2*3
 */
void
bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l, int n2,
    BN_ULONG *t)
{
	int i, n;
	int c1, c2;
	int neg, oneg, zero;
	BN_ULONG ll, lc, *lp, *mp;

# ifdef BN_COUNT
	fprintf(stderr, " bn_mul_high %d * %d\n",n2,n2);
# endif
	n = n2 / 2;

	/* Calculate (al-ah)*(bh-bl) */
	neg = zero = 0;
	c1 = bn_cmp_words(&(a[0]), &(a[n]), n);
	c2 = bn_cmp_words(&(b[n]), &(b[0]), n);
	switch (c1 * 3 + c2) {
	case -4:
		bn_sub_words(&(r[0]), &(a[n]), &(a[0]), n);
		bn_sub_words(&(r[n]), &(b[0]), &(b[n]), n);
		break;
	case -3:
		zero = 1;
		break;
	case -2:
		bn_sub_words(&(r[0]), &(a[n]), &(a[0]), n);
		bn_sub_words(&(r[n]), &(b[n]), &(b[0]), n);
		neg = 1;
		break;
	case -1:
	case 0:
	case 1:
		zero = 1;
		break;
	case 2:
		bn_sub_words(&(r[0]), &(a[0]), &(a[n]), n);
		bn_sub_words(&(r[n]), &(b[0]), &(b[n]), n);
		neg = 1;
		break;
	case 3:
		zero = 1;
		break;
	case 4:
		bn_sub_words(&(r[0]), &(a[0]), &(a[n]), n);
		bn_sub_words(&(r[n]), &(b[n]), &(b[0]), n);
		break;
	}

	oneg = neg;
	/* t[10] = (a[0]-a[1])*(b[1]-b[0]) */
	/* r[10] = (a[1]*b[1]) */
# ifdef BN_MUL_COMBA
	if (n == 8) {
		bn_mul_comba8(&(t[0]), &(r[0]), &(r[n]));
		bn_mul_comba8(r, &(a[n]), &(b[n]));
	} else
# endif
	{
		bn_mul_recursive(&(t[0]), &(r[0]), &(r[n]), n, 0, 0, &(t[n2]));
		bn_mul_recursive(r, &(a[n]), &(b[n]), n, 0, 0, &(t[n2]));
	}

	/* s0 == low(al*bl)
	 * s1 == low(ah*bh)+low((al-ah)*(bh-bl))+low(al*bl)+high(al*bl)
	 * We know s0 and s1 so the only unknown is high(al*bl)
	 * high(al*bl) == s1 - low(ah*bh+s0+(al-ah)*(bh-bl))
	 * high(al*bl) == s1 - (r[0]+l[0]+t[0])
	 */
	if (l != NULL) {
		lp = &(t[n2 + n]);
		c1 = (int)(bn_add_words(lp, &(r[0]), &(l[0]), n));
	} else {
		c1 = 0;
		lp = &(r[0]);
	}

	if (neg)
		neg = (int)(bn_sub_words(&(t[n2]), lp, &(t[0]), n));
	else {
		bn_add_words(&(t[n2]), lp, &(t[0]), n);
		neg = 0;
	}

	if (l != NULL) {
		bn_sub_words(&(t[n2 + n]), &(l[n]), &(t[n2]), n);
	} else {
		lp = &(t[n2 + n]);
		mp = &(t[n2]);
		for (i = 0; i < n; i++)
			lp[i] = ((~mp[i]) + 1) & BN_MASK2;
	}

	/* s[0] = low(al*bl)
	 * t[3] = high(al*bl)
	 * t[10] = (a[0]-a[1])*(b[1]-b[0]) neg is the sign
	 * r[10] = (a[1]*b[1])
	 */
	/* R[10] = al*bl
	 * R[21] = al*bl + ah*bh + (a[0]-a[1])*(b[1]-b[0])
	 * R[32] = ah*bh
	 */
	/* R[1]=t[3]+l[0]+r[0](+-)t[0] (have carry/borrow)
	 * R[2]=r[0]+t[3]+r[1](+-)t[1] (have carry/borrow)
	 * R[3]=r[1]+(carry/borrow)
	 */
	if (l != NULL) {
		lp = &(t[n2]);
		c1 = (int)(bn_add_words(lp, &(t[n2 + n]), &(l[0]), n));
	} else {
		lp = &(t[n2 + n]);
		c1 = 0;
	}
	c1 += (int)(bn_add_words(&(t[n2]), lp, &(r[0]), n));
	if (oneg)
		c1 -= (int)(bn_sub_words(&(t[n2]), &(t[n2]), &(t[0]), n));
	else
		c1 += (int)(bn_add_words(&(t[n2]), &(t[n2]), &(t[0]), n));

	c2 = (int)(bn_add_words(&(r[0]), &(r[0]), &(t[n2 + n]), n));
	c2 += (int)(bn_add_words(&(r[0]), &(r[0]), &(r[n]), n));
	if (oneg)
		c2 -= (int)(bn_sub_words(&(r[0]), &(r[0]), &(t[n]), n));
	else
		c2 += (int)(bn_add_words(&(r[0]), &(r[0]), &(t[n]), n));

	if (c1 != 0) /* Add starting at r[0], could be +ve or -ve */
	{
		i = 0;
		if (c1 > 0) {
			lc = c1;
			do {
				ll = (r[i] + lc) & BN_MASK2;
				r[i++] = ll;
				lc = (lc > ll);
			} while (lc);
		} else {
			lc = -c1;
			do {
				ll = r[i];
				r[i++] = (ll - lc) & BN_MASK2;
				lc = (lc > ll);
			} while (lc);
		}
	}
	if (c2 != 0) /* Add starting at r[1] */
	{
		i = n;
		if (c2 > 0) {
			lc = c2;
			do {
				ll = (r[i] + lc) & BN_MASK2;
				r[i++] = ll;
				lc = (lc > ll);
			} while (lc);
		} else {
			lc = -c2;
			do {
				ll = r[i];
				r[i++] = (ll - lc) & BN_MASK2;
				lc = (lc > ll);
			} while (lc);
		}
	}
}
#endif /* BN_RECURSION */

int
BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
	int ret = 0;
	int top, al, bl;
	BIGNUM *rr;
#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
	int i;
#endif
#ifdef BN_RECURSION
	BIGNUM *t = NULL;
	int j = 0, k;
#endif

#ifdef BN_COUNT
	fprintf(stderr, "BN_mul %d * %d\n",a->top,b->top);
#endif

	bn_check_top(a);
	bn_check_top(b);
	bn_check_top(r);

	al = a->top;
	bl = b->top;

	if ((al == 0) || (bl == 0)) {
		BN_zero(r);
		return (1);
	}
	top = al + bl;

	BN_CTX_start(ctx);
	if ((r == a) || (r == b)) {
		if ((rr = BN_CTX_get(ctx)) == NULL)
			goto err;
	} else
		rr = r;
	rr->neg = a->neg ^ b->neg;

#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
	i = al - bl;
#endif
#ifdef BN_MUL_COMBA
	if (i == 0) {
# if 0
		if (al == 4) {
			if (bn_wexpand(rr, 8) == NULL)
				goto err;
			rr->top = 8;
			bn_mul_comba4(rr->d, a->d, b->d);
			goto end;
		}
# endif
		if (al == 8) {
			if (bn_wexpand(rr, 16) == NULL)
				goto err;
			rr->top = 16;
			bn_mul_comba8(rr->d, a->d, b->d);
			goto end;
		}
	}
#endif /* BN_MUL_COMBA */
#ifdef BN_RECURSION
	if ((al >= BN_MULL_SIZE_NORMAL) && (bl >= BN_MULL_SIZE_NORMAL)) {
		if (i >= -1 && i <= 1) {
			/* Find out the power of two lower or equal
			   to the longest of the two numbers */
			if (i >= 0) {
				j = BN_num_bits_word((BN_ULONG)al);
			}
			if (i == -1) {
				j = BN_num_bits_word((BN_ULONG)bl);
			}
			j = 1 << (j - 1);
			assert(j <= al || j <= bl);
			k = j + j;
			if ((t = BN_CTX_get(ctx)) == NULL)
				goto err;
			if (al > j || bl > j) {
				if (bn_wexpand(t, k * 4) == NULL)
					goto err;
				if (bn_wexpand(rr, k * 4) == NULL)
					goto err;
				bn_mul_part_recursive(rr->d, a->d, b->d,
				    j, al - j, bl - j, t->d);
			}
			else	/* al <= j || bl <= j */
			{
				if (bn_wexpand(t, k * 2) == NULL)
					goto err;
				if (bn_wexpand(rr, k * 2) == NULL)
					goto err;
				bn_mul_recursive(rr->d, a->d, b->d,
				    j, al - j, bl - j, t->d);
			}
			rr->top = top;
			goto end;
		}
#if 0
		if (i == 1 && !BN_get_flags(b, BN_FLG_STATIC_DATA)) {
			BIGNUM *tmp_bn = (BIGNUM *)b;
			if (bn_wexpand(tmp_bn, al) == NULL)
				goto err;
			tmp_bn->d[bl] = 0;
			bl++;
			i--;
		} else if (i == -1 && !BN_get_flags(a, BN_FLG_STATIC_DATA)) {
			BIGNUM *tmp_bn = (BIGNUM *)a;
			if (bn_wexpand(tmp_bn, bl) == NULL)
				goto err;
			tmp_bn->d[al] = 0;
			al++;
			i++;
		}
		if (i == 0) {
			/* symmetric and > 4 */
			/* 16 or larger */
			j = BN_num_bits_word((BN_ULONG)al);
			j = 1 << (j - 1);
			k = j + j;
			if ((t = BN_CTX_get(ctx)) == NULL)
				goto err;
			if (al == j) /* exact multiple */
			{
				if (bn_wexpand(t, k * 2) == NULL)
					goto err;
				if (bn_wexpand(rr, k * 2) == NULL)
					goto err;
				bn_mul_recursive(rr->d, a->d, b->d, al, t->d);
			} else {
				if (bn_wexpand(t, k * 4) == NULL)
					goto err;
				if (bn_wexpand(rr, k * 4) == NULL)
					goto err;
				bn_mul_part_recursive(rr->d, a->d, b->d,
				    al - j, j, t->d);
			}
			rr->top = top;
			goto end;
		}
#endif
	}
#endif /* BN_RECURSION */
	if (bn_wexpand(rr, top) == NULL)
		goto err;
	rr->top = top;
	bn_mul_normal(rr->d, a->d, al, b->d, bl);

#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
end:
#endif
	bn_correct_top(rr);
	if (r != rr)
		BN_copy(r, rr);
	ret = 1;
err:
	bn_check_top(r);
	BN_CTX_end(ctx);
	return (ret);
}

void
bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)
{
	BN_ULONG *rr;

#ifdef BN_COUNT
	fprintf(stderr, " bn_mul_normal %d * %d\n", na, nb);
#endif

	if (na < nb) {
		int itmp;
		BN_ULONG *ltmp;

		itmp = na;
		na = nb;
		nb = itmp;
		ltmp = a;
		a = b;
		b = ltmp;

	}
	rr = &(r[na]);
	if (nb <= 0) {
		(void)bn_mul_words(r, a, na, 0);
		return;
	} else
		rr[0] = bn_mul_words(r, a, na, b[0]);

	for (;;) {
		if (--nb <= 0)
			return;
		rr[1] = bn_mul_add_words(&(r[1]), a, na, b[1]);
		if (--nb <= 0)
			return;
		rr[2] = bn_mul_add_words(&(r[2]), a, na, b[2]);
		if (--nb <= 0)
			return;
		rr[3] = bn_mul_add_words(&(r[3]), a, na, b[3]);
		if (--nb <= 0)
			return;
		rr[4] = bn_mul_add_words(&(r[4]), a, na, b[4]);
		rr += 4;
		r += 4;
		b += 4;
	}
}

void
bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
{
#ifdef BN_COUNT
	fprintf(stderr, " bn_mul_low_normal %d * %d\n", n, n);
#endif
	bn_mul_words(r, a, n, b[0]);

	for (;;) {
		if (--n <= 0)
			return;
		bn_mul_add_words(&(r[1]), a, n, b[1]);
		if (--n <= 0)
			return;
		bn_mul_add_words(&(r[2]), a, n, b[2]);
		if (--n <= 0)
			return;
		bn_mul_add_words(&(r[3]), a, n, b[3]);
		if (--n <= 0)
			return;
		bn_mul_add_words(&(r[4]), a, n, b[4]);
		r += 4;
		b += 4;
	}
}
@


1.19
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_mul.c,v 1.18 2014/07/10 22:45:56 jsing Exp $ */
d1015 1
a1015 2
			t = BN_CTX_get(ctx);
			if (t == NULL)
d1059 2
a1060 1
			t = BN_CTX_get(ctx);
@


1.18
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: bn_mul.c,v 1.17 2014/07/10 13:58:22 jsing Exp $ */
a69 1
#include "cryptlib.h"
@


1.17
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_mul.c,v 1.16 2014/06/12 15:49:28 deraadt Exp $ */
d67 2
@


1.16
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d64 1
d66 2
a67 1
#include <assert.h>
@


1.15
log
@Emergency knfectomie requested by tedu@@.
@
text
@d1 1
a1 1
/* crypto/bn/bn_mul.c */
@


1.14
log
@openssl-1.0.0e: resolve conflicts
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d80 4
a83 4
BN_ULONG bn_sub_part_words(BN_ULONG *r,
	const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
	{
d96 1
a96 2
	if (dl < 0)
		{
d98 3
a100 1
		fprintf(stderr, "  bn_sub_part_words %d + %d (dl < 0, c = %d)\n", cl, dl, c);
d102 1
a102 2
		for (;;)
			{
d104 5
a108 3
			r[0] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;
d111 5
a115 3
			r[1] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;
d118 5
a122 3
			r[2] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;
d125 5
a129 3
			r[3] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;
a132 1
			}
d134 1
a134 2
	else
		{
d137 3
a139 1
		fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, c = %d)\n", cl, dl, c);
d141 1
a141 2
		while(c)
			{
d143 5
a147 3
			r[0] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;
d150 5
a154 3
			r[1] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;
d157 5
a161 3
			r[2] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;
d164 5
a168 3
			r[3] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;
d173 2
a174 3
			}
		if (dl > 0)
			{
d176 3
a178 1
			fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, c == 0)\n", cl, dl);
d180 2
a181 4
			if (save_dl > dl)
				{
				switch (save_dl - dl)
					{
d184 2
a185 1
					if (--dl <= 0) break;
d188 2
a189 1
					if (--dl <= 0) break;
d192 3
a194 2
					if (--dl <= 0) break;
					}
a196 1
				}
d198 2
a199 2
		if (dl > 0)
			{
d201 3
a203 1
			fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, copy)\n", cl, dl);
d205 1
a205 2
			for(;;)
				{
d207 2
a208 1
				if (--dl <= 0) break;
d210 2
a211 1
				if (--dl <= 0) break;
d213 2
a214 1
				if (--dl <= 0) break;
d216 2
a217 1
				if (--dl <= 0) break;
a220 1
				}
d223 1
d225 1
a225 1
	}
d228 4
a231 4
BN_ULONG bn_add_part_words(BN_ULONG *r,
	const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
	{
d244 1
a244 2
	if (dl < 0)
		{
d247 3
a249 1
		fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, c = %d)\n", cl, dl, c);
d251 24
a274 21
		while (c)
			{
			l=(c+b[0])&BN_MASK2;
			c=(l < c);
			r[0]=l;
			if (++dl >= 0) break;

			l=(c+b[1])&BN_MASK2;
			c=(l < c);
			r[1]=l;
			if (++dl >= 0) break;

			l=(c+b[2])&BN_MASK2;
			c=(l < c);
			r[2]=l;
			if (++dl >= 0) break;

			l=(c+b[3])&BN_MASK2;
			c=(l < c);
			r[3]=l;
			if (++dl >= 0) break;
d277 4
a280 5
			b+=4;
			r+=4;
			}
		if (dl < 0)
			{
d282 3
a284 1
			fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, c == 0)\n", cl, dl);
d286 2
a287 4
			if (save_dl < dl)
				{
				switch (dl - save_dl)
					{
d290 2
a291 1
					if (++dl >= 0) break;
d294 2
a295 1
					if (++dl >= 0) break;
d298 3
a300 2
					if (++dl >= 0) break;
					}
a302 1
				}
d304 2
a305 2
		if (dl < 0)
			{
d307 3
a309 1
			fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, copy)\n", cl, dl);
d311 1
a311 2
			for(;;)
				{
d313 2
a314 1
				if (++dl >= 0) break;
d316 2
a317 1
				if (++dl >= 0) break;
d319 2
a320 1
				if (++dl >= 0) break;
d322 2
a323 1
				if (++dl >= 0) break;
a326 1
				}
d329 1
a329 2
	else
		{
d332 2
a333 1
		fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0)\n", cl, dl);
d335 24
a358 21
		while (c)
			{
			t=(a[0]+c)&BN_MASK2;
			c=(t < c);
			r[0]=t;
			if (--dl <= 0) break;

			t=(a[1]+c)&BN_MASK2;
			c=(t < c);
			r[1]=t;
			if (--dl <= 0) break;

			t=(a[2]+c)&BN_MASK2;
			c=(t < c);
			r[2]=t;
			if (--dl <= 0) break;

			t=(a[3]+c)&BN_MASK2;
			c=(t < c);
			r[3]=t;
			if (--dl <= 0) break;
d361 3
a363 3
			a+=4;
			r+=4;
			}
d365 2
a366 1
		fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0, c == 0)\n", cl, dl);
d368 3
a370 6
		if (dl > 0)
			{
			if (save_dl > dl)
				{
				switch (save_dl - dl)
					{
d373 2
a374 1
					if (--dl <= 0) break;
d377 2
a378 1
					if (--dl <= 0) break;
d381 3
a383 2
					if (--dl <= 0) break;
					}
a385 1
				}
d387 2
a388 2
		if (dl > 0)
			{
d390 3
a392 1
			fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0, copy)\n", cl, dl);
d394 1
a394 2
			for(;;)
				{
d396 2
a397 1
				if (--dl <= 0) break;
d399 2
a400 1
				if (--dl <= 0) break;
d402 2
a403 1
				if (--dl <= 0) break;
d405 2
a406 1
				if (--dl <= 0) break;
a409 1
				}
d412 1
d414 1
a414 1
	}
d431 8
a438 7
void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
	int dna, int dnb, BN_ULONG *t)
	{
	int n=n2/2,c1,c2;
	int tna=n+dna, tnb=n+dnb;
	unsigned int neg,zero;
	BN_ULONG ln,lo,*p;
d441 1
a441 1
	fprintf(stderr," bn_mul_recursive %d%+d * %d%+d\n",n2,dna,n2,dnb);
d445 2
a446 3
	if (n2 == 4)
		{
		bn_mul_comba4(r,a,b);
d448 1
a448 1
		}
d453 4
a456 5
	if (n2 == 8 && dna == 0 && dnb == 0)
		{
		bn_mul_comba8(r,a,b);
		return; 
		}
d459 2
a460 3
	if (n2 < BN_MUL_RECURSIVE_SIZE_NORMAL)
		{
		bn_mul_normal(r,a,n2+dna,b,n2+dnb);
d463 1
a463 1
				sizeof(BN_ULONG) * -(dna + dnb));
d465 1
a465 1
		}
d467 4
a470 5
	c1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);
	c2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);
	zero=neg=0;
	switch (c1*3+c2)
		{
d472 2
a473 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d476 1
a476 1
		zero=1;
d479 3
a481 3
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */
		neg=1;
d486 1
a486 1
		zero=1;
d489 3
a491 3
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
		neg=1;
d494 1
a494 1
		zero=1;
d497 2
a498 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);
d500 1
a500 1
		}
d505 1
a505 1
		{
d507 1
a507 1
			bn_mul_comba4(&(t[n2]),t,&(t[n]));
d509 5
a513 6
			memset(&(t[n2]),0,8*sizeof(BN_ULONG));
		
		bn_mul_comba4(r,a,b);
		bn_mul_comba4(&(r[n2]),&(a[n]),&(b[n]));
		}
	else if (n == 8 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba8 could
d516 1
a516 1
		{
d518 1
a518 1
			bn_mul_comba8(&(t[n2]),t,&(t[n]));
d520 5
a524 6
			memset(&(t[n2]),0,16*sizeof(BN_ULONG));
		
		bn_mul_comba8(r,a,b);
		bn_mul_comba8(&(r[n2]),&(a[n]),&(b[n]));
		}
	else
d526 2
a527 2
		{
		p= &(t[n2*2]);
d529 1
a529 1
			bn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);
d531 4
a534 4
			memset(&(t[n2]),0,n2*sizeof(BN_ULONG));
		bn_mul_recursive(r,a,b,n,0,0,p);
		bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,dna,dnb,p);
		}
d541 1
a541 1
	c1=(int)(bn_add_words(t,r,&(r[n2]),n2));
d544 3
a546 5
		{
		c1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));
		}
	else
		{
d548 2
a549 2
		c1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));
		}
d556 3
a558 4
	c1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));
	if (c1)
		{
		p= &(r[n+n2]);
d560 2
a561 2
		ln=(lo+c1)&BN_MASK2;
		*p=ln;
d565 2
a566 3
		if (ln < (BN_ULONG)c1)
			{
			do	{
d569 3
a571 4
				ln=(lo+1)&BN_MASK2;
				*p=ln;
				} while (ln == 0);
			}
d574 1
d579 7
a585 6
void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n,
	     int tna, int tnb, BN_ULONG *t)
	{
	int i,j,n2=n*2;
	int c1,c2,neg;
	BN_ULONG ln,lo,*p;
d588 2
a589 2
	fprintf(stderr," bn_mul_part_recursive (%d%+d) * (%d%+d)\n",
		n, tna, n, tnb);
d591 2
a592 3
	if (n < 8)
		{
		bn_mul_normal(r,a,n+tna,b,n+tnb);
d594 1
a594 1
		}
d597 4
a600 5
	c1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);
	c2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);
	neg=0;
	switch (c1*3+c2)
		{
d602 2
a603 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d608 3
a610 3
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */
		neg=1;
d617 3
a619 3
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
		neg=1;
d624 2
a625 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);
d627 1
a627 1
		}
d631 6
a636 8
	if (n == 4)
		{
		bn_mul_comba4(&(t[n2]),t,&(t[n]));
		bn_mul_comba4(r,a,b);
		bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);
		memset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));
		}
	else
d638 11
a648 13
	if (n == 8)
		{
		bn_mul_comba8(&(t[n2]),t,&(t[n]));
		bn_mul_comba8(r,a,b);
		bn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);
		memset(&(r[n2+tna+tnb]),0,sizeof(BN_ULONG)*(n2-tna-tnb));
		}
	else
		{
		p= &(t[n2*2]);
		bn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);
		bn_mul_recursive(r,a,b,n,0,0,p);
		i=n/2;
d655 6
a660 6
		if (j == 0)
			{
			bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),
				i,tna-i,tnb-i,p);
			memset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2));
			}
d662 6
a667 6
				{
				bn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]),
					i,tna-i,tnb-i,p);
				memset(&(r[n2+tna+tnb]),0,
					sizeof(BN_ULONG)*(n2-tna-tnb));
				}
d669 9
a677 12
			{
			memset(&(r[n2]),0,sizeof(BN_ULONG)*n2);
			if (tna < BN_MUL_RECURSIVE_SIZE_NORMAL
				&& tnb < BN_MUL_RECURSIVE_SIZE_NORMAL)
				{
				bn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);
				}
			else
				{
				for (;;)
					{
					i/=2;
d681 1
a681 2
					if (i < tna || i < tnb)
						{
d683 2
a684 2
							&(a[n]),&(b[n]),
							i,tna-i,tnb-i,p);
d686 1
a686 3
						}
					else if (i == tna || i == tnb)
						{
d688 2
a689 2
							&(a[n]),&(b[n]),
							i,tna-i,tnb-i,p);
a690 1
						}
d695 1
d702 1
a702 1
	c1=(int)(bn_add_words(t,r,&(r[n2]),n2));
d705 3
a707 5
		{
		c1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));
		}
	else
		{
d709 2
a710 2
		c1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));
		}
d717 3
a719 4
	c1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));
	if (c1)
		{
		p= &(r[n+n2]);
d721 2
a722 2
		ln=(lo+c1)&BN_MASK2;
		*p=ln;
d726 2
a727 3
		if (ln < (BN_ULONG)c1)
			{
			do	{
d730 3
a732 4
				ln=(lo+1)&BN_MASK2;
				*p=ln;
				} while (ln == 0);
			}
d735 1
d740 4
a743 4
void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
	     BN_ULONG *t)
	{
	int n=n2/2;
d746 1
a746 1
	fprintf(stderr," bn_mul_low_recursive %d * %d\n",n2,n2);
d749 11
a759 15
	bn_mul_recursive(r,a,b,n,0,0,&(t[0]));
	if (n >= BN_MUL_LOW_RECURSIVE_SIZE_NORMAL)
		{
		bn_mul_low_recursive(&(t[0]),&(a[0]),&(b[n]),n,&(t[n2]));
		bn_add_words(&(r[n]),&(r[n]),&(t[0]),n);
		bn_mul_low_recursive(&(t[0]),&(a[n]),&(b[0]),n,&(t[n2]));
		bn_add_words(&(r[n]),&(r[n]),&(t[0]),n);
		}
	else
		{
		bn_mul_low_normal(&(t[0]),&(a[0]),&(b[n]),n);
		bn_mul_low_normal(&(t[n]),&(a[n]),&(b[0]),n);
		bn_add_words(&(r[n]),&(r[n]),&(t[0]),n);
		bn_add_words(&(r[n]),&(r[n]),&(t[n]),n);
		}
d761 1
d768 8
a775 7
void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l, int n2,
	     BN_ULONG *t)
	{
	int i,n;
	int c1,c2;
	int neg,oneg,zero;
	BN_ULONG ll,lc,*lp,*mp;
d778 1
a778 1
	fprintf(stderr," bn_mul_high %d * %d\n",n2,n2);
d780 1
a780 1
	n=n2/2;
d783 4
a786 5
	neg=zero=0;
	c1=bn_cmp_words(&(a[0]),&(a[n]),n);
	c2=bn_cmp_words(&(b[n]),&(b[0]),n);
	switch (c1*3+c2)
		{
d788 2
a789 2
		bn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);
		bn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);
d792 1
a792 1
		zero=1;
d795 3
a797 3
		bn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);
		bn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);
		neg=1;
d802 1
a802 1
		zero=1;
d805 3
a807 3
		bn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);
		bn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);
		neg=1;
d810 1
a810 1
		zero=1;
d813 2
a814 2
		bn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);
		bn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);
d816 3
a818 3
		}
		
	oneg=neg;
d822 4
a825 6
	if (n == 8)
		{
		bn_mul_comba8(&(t[0]),&(r[0]),&(r[n]));
		bn_mul_comba8(r,&(a[n]),&(b[n]));
		}
	else
d827 4
a830 4
		{
		bn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,0,0,&(t[n2]));
		bn_mul_recursive(r,&(a[n]),&(b[n]),n,0,0,&(t[n2]));
		}
d838 7
a844 10
	if (l != NULL)
		{
		lp= &(t[n2+n]);
		c1=(int)(bn_add_words(lp,&(r[0]),&(l[0]),n));
		}
	else
		{
		c1=0;
		lp= &(r[0]);
		}
d847 5
a851 6
		neg=(int)(bn_sub_words(&(t[n2]),lp,&(t[0]),n));
	else
		{
		bn_add_words(&(t[n2]),lp,&(t[0]),n);
		neg=0;
		}
d853 8
a860 11
	if (l != NULL)
		{
		bn_sub_words(&(t[n2+n]),&(l[n]),&(t[n2]),n);
		}
	else
		{
		lp= &(t[n2+n]);
		mp= &(t[n2]);
		for (i=0; i<n; i++)
			lp[i]=((~mp[i])+1)&BN_MASK2;
		}
d875 8
a882 11
	if (l != NULL)
		{
		lp= &(t[n2]);
		c1= (int)(bn_add_words(lp,&(t[n2+n]),&(l[0]),n));
		}
	else
		{
		lp= &(t[n2+n]);
		c1=0;
		}
	c1+=(int)(bn_add_words(&(t[n2]),lp,  &(r[0]),n));
d884 1
a884 1
		c1-=(int)(bn_sub_words(&(t[n2]),&(t[n2]),&(t[0]),n));
d886 1
a886 1
		c1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),&(t[0]),n));
d888 2
a889 2
	c2 =(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n2+n]),n));
	c2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(r[n]),n));
d891 1
a891 1
		c2-=(int)(bn_sub_words(&(r[0]),&(r[0]),&(t[n]),n));
d893 2
a894 2
		c2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n]),n));
	
d896 16
a911 20
		{
		i=0;
		if (c1 > 0)
			{
			lc=c1;
			do	{
				ll=(r[i]+lc)&BN_MASK2;
				r[i++]=ll;
				lc=(lc > ll);
				} while (lc);
			}
		else
			{
			lc= -c1;
			do	{
				ll=r[i];
				r[i++]=(ll-lc)&BN_MASK2;
				lc=(lc > ll);
				} while (lc);
			}
d913 1
d915 16
a930 20
		{
		i=n;
		if (c2 > 0)
			{
			lc=c2;
			do	{
				ll=(r[i]+lc)&BN_MASK2;
				r[i++]=ll;
				lc=(lc > ll);
				} while (lc);
			}
		else
			{
			lc= -c2;
			do	{
				ll=r[i];
				r[i++]=(ll-lc)&BN_MASK2;
				lc=(lc > ll);
				} while (lc);
			}
d933 1
d936 5
a940 4
int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
	{
	int ret=0;
	int top,al,bl;
d946 2
a947 2
	BIGNUM *t=NULL;
	int j=0,k;
d951 1
a951 1
	fprintf(stderr,"BN_mul %d * %d\n",a->top,b->top);
d958 2
a959 2
	al=a->top;
	bl=b->top;
d961 1
a961 2
	if ((al == 0) || (bl == 0))
		{
d963 3
a965 3
		return(1);
		}
	top=al+bl;
d968 4
a971 5
	if ((r == a) || (r == b))
		{
		if ((rr = BN_CTX_get(ctx)) == NULL) goto err;
		}
	else
d973 1
a973 1
	rr->neg=a->neg^b->neg;
d976 1
a976 1
	i = al-bl;
d979 1
a979 2
	if (i == 0)
		{
d981 5
a985 5
		if (al == 4)
			{
			if (bn_wexpand(rr,8) == NULL) goto err;
			rr->top=8;
			bn_mul_comba4(rr->d,a->d,b->d);
d987 1
a987 1
			}
d989 5
a993 5
		if (al == 8)
			{
			if (bn_wexpand(rr,16) == NULL) goto err;
			rr->top=16;
			bn_mul_comba8(rr->d,a->d,b->d);
a994 1
			}
d996 1
d999 2
a1000 4
	if ((al >= BN_MULL_SIZE_NORMAL) && (bl >= BN_MULL_SIZE_NORMAL))
		{
		if (i >= -1 && i <= 1)
			{
d1003 1
a1003 2
			if (i >= 0)
				{
d1005 2
a1006 3
				}
			if (i == -1)
				{
d1008 2
a1009 2
				}
			j = 1<<(j-1);
d1011 1
a1011 1
			k = j+j;
d1015 8
a1022 7
			if (al > j || bl > j)
				{
				if (bn_wexpand(t,k*4) == NULL) goto err;
				if (bn_wexpand(rr,k*4) == NULL) goto err;
				bn_mul_part_recursive(rr->d,a->d,b->d,
					j,al-j,bl-j,t->d);
				}
d1024 9
a1032 7
				{
				if (bn_wexpand(t,k*2) == NULL) goto err;
				if (bn_wexpand(rr,k*2) == NULL) goto err;
				bn_mul_recursive(rr->d,a->d,b->d,
					j,al-j,bl-j,t->d);
				}
			rr->top=top;
d1034 1
a1034 1
			}
d1036 1
a1036 2
		if (i == 1 && !BN_get_flags(b,BN_FLG_STATIC_DATA))
			{
d1038 3
a1040 2
			if (bn_wexpand(tmp_bn,al) == NULL) goto err;
			tmp_bn->d[bl]=0;
d1043 1
a1043 3
			}
		else if (i == -1 && !BN_get_flags(a,BN_FLG_STATIC_DATA))
			{
d1045 3
a1047 2
			if (bn_wexpand(tmp_bn,bl) == NULL) goto err;
			tmp_bn->d[al]=0;
d1050 2
a1051 3
			}
		if (i == 0)
			{
d1054 3
a1056 3
			j=BN_num_bits_word((BN_ULONG)al);
			j=1<<(j-1);
			k=j+j;
d1059 15
a1073 12
				{
				if (bn_wexpand(t,k*2) == NULL) goto err;
				if (bn_wexpand(rr,k*2) == NULL) goto err;
				bn_mul_recursive(rr->d,a->d,b->d,al,t->d);
				}
			else
				{
				if (bn_wexpand(t,k*4) == NULL) goto err;
				if (bn_wexpand(rr,k*4) == NULL) goto err;
				bn_mul_part_recursive(rr->d,a->d,b->d,al-j,j,t->d);
				}
			rr->top=top;
d1075 1
a1075 1
			}
d1077 1
a1077 1
		}
d1079 4
a1082 3
	if (bn_wexpand(rr,top) == NULL) goto err;
	rr->top=top;
	bn_mul_normal(rr->d,a->d,al,b->d,bl);
d1088 3
a1090 2
	if (r != rr) BN_copy(r,rr);
	ret=1;
d1094 2
a1095 2
	return(ret);
	}
d1097 3
a1099 2
void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)
	{
d1103 1
a1103 1
	fprintf(stderr," bn_mul_normal %d * %d\n",na,nb);
d1106 1
a1106 2
	if (na < nb)
		{
d1110 6
a1115 2
		itmp=na; na=nb; nb=itmp;
		ltmp=a;   a=b;   b=ltmp;
d1117 4
a1120 5
		}
	rr= &(r[na]);
	if (nb <= 0)
		{
		(void)bn_mul_words(r,a,na,0);
d1122 2
a1123 3
		}
	else
		rr[0]=bn_mul_words(r,a,na,b[0]);
d1125 16
a1140 14
	for (;;)
		{
		if (--nb <= 0) return;
		rr[1]=bn_mul_add_words(&(r[1]),a,na,b[1]);
		if (--nb <= 0) return;
		rr[2]=bn_mul_add_words(&(r[2]),a,na,b[2]);
		if (--nb <= 0) return;
		rr[3]=bn_mul_add_words(&(r[3]),a,na,b[3]);
		if (--nb <= 0) return;
		rr[4]=bn_mul_add_words(&(r[4]),a,na,b[4]);
		rr+=4;
		r+=4;
		b+=4;
		}
d1142 1
d1144 3
a1146 2
void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
	{
d1148 1
a1148 1
	fprintf(stderr," bn_mul_low_normal %d * %d\n",n,n);
d1150 1
a1150 1
	bn_mul_words(r,a,n,b[0]);
d1152 15
a1166 13
	for (;;)
		{
		if (--n <= 0) return;
		bn_mul_add_words(&(r[1]),a,n,b[1]);
		if (--n <= 0) return;
		bn_mul_add_words(&(r[2]),a,n,b[2]);
		if (--n <= 0) return;
		bn_mul_add_words(&(r[3]),a,n,b[3]);
		if (--n <= 0) return;
		bn_mul_add_words(&(r[4]),a,n,b[4]);
		r+=4;
		b+=4;
		}
d1168 1
@


1.13
log
@resolve conflicts, fix local changes
@
text
@d554 1
a554 1
	int c1,c2,neg,zero;
d570 1
a570 1
	zero=neg=0;
a577 1
		zero=1;
a586 1
		zero=1;
a593 1
		zero=1;
a1011 1
			int sav_j =0;
a1021 1
			sav_j = j;
@


1.12
log
@resolve conflicts
@
text
@d1031 2
d1035 2
a1036 2
				bn_wexpand(t,k*4);
				bn_wexpand(rr,k*4);
d1042 2
a1043 2
				bn_wexpand(t,k*2);
				bn_wexpand(rr,k*2);
@


1.11
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d59 5
d65 1
d69 309
d392 1
d394 1
a394 1
	     BN_ULONG *t)
d397 1
d402 1
a402 1
	printf(" bn_mul_recursive %d * %d\n",n2,n2);
d412 4
a415 1
	if (n2 == 8)
d421 1
d424 4
a427 2
		/* This should not happen */
		bn_mul_normal(r,a,n2,b,n2);
d431 2
a432 2
	c1=bn_cmp_words(a,&(a[n]),n);
	c2=bn_cmp_words(&(b[n]),b,n);
d437 2
a438 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d444 2
a445 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),&(b[n]),b,      n); /* + */
d454 2
a455 2
		bn_sub_words(t,      a,      &(a[n]),n); /* + */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d462 2
a463 2
		bn_sub_words(t,      a,      &(a[n]),n);
		bn_sub_words(&(t[n]),&(b[n]),b,      n);
d468 2
a469 1
	if (n == 4)
d479 3
a481 1
	else if (n == 8)
d496 1
a496 1
			bn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);
d499 2
a500 2
		bn_mul_recursive(r,a,b,n,p);
		bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,p);
d549 3
a551 2
void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int tn,
	     int n, BN_ULONG *t)
d558 2
a559 1
	printf(" bn_mul_part_recursive %d * %d\n",tn+n,tn+n);
d563 1
a563 2
		i=tn+n;
		bn_mul_normal(r,a,i,b,i);
d568 2
a569 2
	c1=bn_cmp_words(a,&(a[n]),n);
	c2=bn_cmp_words(&(b[n]),b,n);
d574 2
a575 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d581 2
a582 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),&(b[n]),b,      n); /* + */
d591 2
a592 2
		bn_sub_words(t,      a,      &(a[n]),n); /* + */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d599 2
a600 2
		bn_sub_words(t,      a,      &(a[n]),n);
		bn_sub_words(&(t[n]),&(b[n]),b,      n);
d619 2
a620 2
		bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);
		memset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));
d625 2
a626 2
		bn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);
		bn_mul_recursive(r,a,b,n,p);
d630 4
a633 1
		j=tn-i;
d636 2
a637 1
			bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),i,p);
d643 3
a645 3
					j,i,p);
				memset(&(r[n2+tn*2]),0,
					sizeof(BN_ULONG)*(n2-tn*2));
d650 2
a651 1
			if (tn < BN_MUL_RECURSIVE_SIZE_NORMAL)
d653 1
a653 1
				bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);
d660 4
a663 1
					if (i < tn)
d667 1
a667 1
							tn-i,i,p);
d670 1
a670 1
					else if (i == tn)
d674 1
a674 1
							i,p);
d735 1
a735 1
	printf(" bn_mul_low_recursive %d * %d\n",n2,n2);
d738 1
a738 1
	bn_mul_recursive(r,a,b,n,&(t[0]));
d769 1
a769 1
	printf(" bn_mul_high %d * %d\n",n2,n2);
d822 2
a823 2
		bn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,&(t[n2]));
		bn_mul_recursive(r,&(a[n]),&(b[n]),n,&(t[n2]));
d948 1
a950 1
	int ret = 0;
d955 2
a956 2
	BIGNUM *t;
	int j,k;
d960 1
a960 1
	printf("BN_mul %d * %d\n",a->top,b->top);
d972 1
a972 1
		if (!BN_zero(r)) goto err;
d1013 1
a1013 1
		if (i == 1 && !BN_get_flags(b,BN_FLG_STATIC_DATA) && bl<b->dmax)
d1015 39
a1053 4
#if 0	/* tribute to const-ification, bl<b->dmax above covers for this */
			if (bn_wexpand(b,al) == NULL) goto err;
#endif
			b->d[bl]=0;
d1057 1
a1057 1
		else if (i == -1 && !BN_get_flags(a,BN_FLG_STATIC_DATA) && al<a->dmax)
d1059 3
a1061 4
#if 0	/* tribute to const-ification, al<a->dmax above covers for this */
			if (bn_wexpand(a,bl) == NULL) goto err;
#endif
			a->d[al]=0;
a1077 2
				rr->top=top;
				goto end;
a1078 1
#if 0	/* tribute to const-ification, rsa/dsa performance is not affected */
d1081 2
a1082 8
				if (bn_wexpand(a,k) == NULL ) goto err;
				if (bn_wexpand(b,k) == NULL ) goto err;
				if (bn_wexpand(t,k*4) == NULL ) goto err;
				if (bn_wexpand(rr,k*4) == NULL ) goto err;
				for (i=a->top; i<k; i++)
					a->d[i]=0;
				for (i=b->top; i<k; i++)
					b->d[i]=0;
d1087 1
a1088 1
			}
d1098 1
a1098 1
	bn_fix_top(rr);
d1102 1
d1112 1
a1112 1
	printf(" bn_mul_normal %d * %d\n",na,nb);
d1125 7
a1131 1
	rr[0]=bn_mul_words(r,a,na,b[0]);
d1152 1
a1152 1
	printf(" bn_mul_low_normal %d * %d\n",n,n);
@


1.10
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d227 1
a227 1
	unsigned int c1,c2,neg,zero;
d379 1
a379 1
		if (ln < c1)
@


1.9
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@a58 5
#ifndef BN_DEBUG
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
#endif

a59 1
#include <assert.h>
a62 309
#if defined(OPENSSL_NO_ASM) || !(defined(__i386) || defined(__i386__)) || defined(__DJGPP__) /* Assembler implementation exists only for x86 */
/* Here follows specialised variants of bn_add_words() and
   bn_sub_words().  They have the property performing operations on
   arrays of different sizes.  The sizes of those arrays is expressed through
   cl, which is the common length ( basicall, min(len(a),len(b)) ), and dl,
   which is the delta between the two lengths, calculated as len(a)-len(b).
   All lengths are the number of BN_ULONGs...  For the operations that require
   a result array as parameter, it must have the length cl+abs(dl).
   These functions should probably end up in bn_asm.c as soon as there are
   assembler counterparts for the systems that use assembler files.  */

BN_ULONG bn_sub_part_words(BN_ULONG *r,
	const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
	{
	BN_ULONG c, t;

	assert(cl >= 0);
	c = bn_sub_words(r, a, b, cl);

	if (dl == 0)
		return c;

	r += cl;
	a += cl;
	b += cl;

	if (dl < 0)
		{
#ifdef BN_COUNT
		fprintf(stderr, "  bn_sub_part_words %d + %d (dl < 0, c = %d)\n", cl, dl, c);
#endif
		for (;;)
			{
			t = b[0];
			r[0] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			t = b[1];
			r[1] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			t = b[2];
			r[2] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			t = b[3];
			r[3] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			b += 4;
			r += 4;
			}
		}
	else
		{
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, c = %d)\n", cl, dl, c);
#endif
		while(c)
			{
			t = a[0];
			r[0] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			t = a[1];
			r[1] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			t = a[2];
			r[2] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			t = a[3];
			r[3] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			save_dl = dl;
			a += 4;
			r += 4;
			}
		if (dl > 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, c == 0)\n", cl, dl);
#endif
			if (save_dl > dl)
				{
				switch (save_dl - dl)
					{
				case 1:
					r[1] = a[1];
					if (--dl <= 0) break;
				case 2:
					r[2] = a[2];
					if (--dl <= 0) break;
				case 3:
					r[3] = a[3];
					if (--dl <= 0) break;
					}
				a += 4;
				r += 4;
				}
			}
		if (dl > 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, copy)\n", cl, dl);
#endif
			for(;;)
				{
				r[0] = a[0];
				if (--dl <= 0) break;
				r[1] = a[1];
				if (--dl <= 0) break;
				r[2] = a[2];
				if (--dl <= 0) break;
				r[3] = a[3];
				if (--dl <= 0) break;

				a += 4;
				r += 4;
				}
			}
		}
	return c;
	}
#endif

BN_ULONG bn_add_part_words(BN_ULONG *r,
	const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
	{
	BN_ULONG c, l, t;

	assert(cl >= 0);
	c = bn_add_words(r, a, b, cl);

	if (dl == 0)
		return c;

	r += cl;
	a += cl;
	b += cl;

	if (dl < 0)
		{
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, c = %d)\n", cl, dl, c);
#endif
		while (c)
			{
			l=(c+b[0])&BN_MASK2;
			c=(l < c);
			r[0]=l;
			if (++dl >= 0) break;

			l=(c+b[1])&BN_MASK2;
			c=(l < c);
			r[1]=l;
			if (++dl >= 0) break;

			l=(c+b[2])&BN_MASK2;
			c=(l < c);
			r[2]=l;
			if (++dl >= 0) break;

			l=(c+b[3])&BN_MASK2;
			c=(l < c);
			r[3]=l;
			if (++dl >= 0) break;

			save_dl = dl;
			b+=4;
			r+=4;
			}
		if (dl < 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, c == 0)\n", cl, dl);
#endif
			if (save_dl < dl)
				{
				switch (dl - save_dl)
					{
				case 1:
					r[1] = b[1];
					if (++dl >= 0) break;
				case 2:
					r[2] = b[2];
					if (++dl >= 0) break;
				case 3:
					r[3] = b[3];
					if (++dl >= 0) break;
					}
				b += 4;
				r += 4;
				}
			}
		if (dl < 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, copy)\n", cl, dl);
#endif
			for(;;)
				{
				r[0] = b[0];
				if (++dl >= 0) break;
				r[1] = b[1];
				if (++dl >= 0) break;
				r[2] = b[2];
				if (++dl >= 0) break;
				r[3] = b[3];
				if (++dl >= 0) break;

				b += 4;
				r += 4;
				}
			}
		}
	else
		{
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0)\n", cl, dl);
#endif
		while (c)
			{
			t=(a[0]+c)&BN_MASK2;
			c=(t < c);
			r[0]=t;
			if (--dl <= 0) break;

			t=(a[1]+c)&BN_MASK2;
			c=(t < c);
			r[1]=t;
			if (--dl <= 0) break;

			t=(a[2]+c)&BN_MASK2;
			c=(t < c);
			r[2]=t;
			if (--dl <= 0) break;

			t=(a[3]+c)&BN_MASK2;
			c=(t < c);
			r[3]=t;
			if (--dl <= 0) break;

			save_dl = dl;
			a+=4;
			r+=4;
			}
#ifdef BN_COUNT
		fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0, c == 0)\n", cl, dl);
#endif
		if (dl > 0)
			{
			if (save_dl > dl)
				{
				switch (save_dl - dl)
					{
				case 1:
					r[1] = a[1];
					if (--dl <= 0) break;
				case 2:
					r[2] = a[2];
					if (--dl <= 0) break;
				case 3:
					r[3] = a[3];
					if (--dl <= 0) break;
					}
				a += 4;
				r += 4;
				}
			}
		if (dl > 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0, copy)\n", cl, dl);
#endif
			for(;;)
				{
				r[0] = a[0];
				if (--dl <= 0) break;
				r[1] = a[1];
				if (--dl <= 0) break;
				r[2] = a[2];
				if (--dl <= 0) break;
				r[3] = a[3];
				if (--dl <= 0) break;

				a += 4;
				r += 4;
				}
			}
		}
	return c;
	}

d78 1
a78 1
	int dna, int dnb, BN_ULONG *t)
a80 1
	int tna=n+dna, tnb=n+dnb;
d85 1
a85 1
	fprintf(stderr," bn_mul_recursive %d * %d\n",n2,n2);
d95 1
a95 4
	/* Only call bn_mul_comba 8 if n2 == 8 and the
	 * two arrays are complete [steve]
	 */
	if (n2 == 8 && dna == 0 && dnb == 0)
a100 1
	/* Else do normal multiply */
d103 2
a104 4
		bn_mul_normal(r,a,n2+dna,b,n2+dnb);
		if ((dna + dnb) < 0)
			memset(&r[2*n2 + dna + dnb], 0,
				sizeof(BN_ULONG) * -(dna + dnb));
d108 2
a109 2
	c1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);
	c2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);
d114 2
a115 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d121 2
a122 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */
d131 2
a132 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d139 2
a140 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);
d145 1
a145 2
	if (n == 4 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba4 could take
					       extra args to do this well */
d155 1
a155 3
	else if (n == 8 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba8 could
						    take extra args to do this
						    well */
d170 1
a170 1
			bn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);
d173 2
a174 2
		bn_mul_recursive(r,a,b,n,0,0,p);
		bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,dna,dnb,p);
d223 2
a224 2
void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n,
	     int tna, int tnb, BN_ULONG *t)
d231 1
a231 2
	fprintf(stderr," bn_mul_part_recursive (%d+%d) * (%d+%d)\n",
		tna, n, tnb, n);
d235 2
a236 1
		bn_mul_normal(r,a,n+tna,b,n+tnb);
d241 2
a242 2
	c1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);
	c2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);
d247 2
a248 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d254 2
a255 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */
d264 2
a265 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d272 2
a273 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);
d292 2
a293 2
		bn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);
		memset(&(r[n2+tna+tnb]),0,sizeof(BN_ULONG)*(n2-tna-tnb));
d298 2
a299 2
		bn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);
		bn_mul_recursive(r,a,b,n,0,0,p);
d303 1
a303 4
		if (tna > tnb)
			j = tna - i;
		else
			j = tnb - i;
d306 1
a306 2
			bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),
				i,tna-i,tnb-i,p);
d312 3
a314 3
					i,tna-i,tnb-i,p);
				memset(&(r[n2+tna+tnb]),0,
					sizeof(BN_ULONG)*(n2-tna-tnb));
d319 1
a319 2
			if (tna < BN_MUL_RECURSIVE_SIZE_NORMAL
				&& tnb < BN_MUL_RECURSIVE_SIZE_NORMAL)
d321 1
a321 1
				bn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);
d328 1
a328 1
					if (i < tna && i < tnb)
d332 1
a332 1
							i,tna-i,tnb-i,p);
d335 1
a335 1
					else if (i <= tna && i <= tnb)
d339 1
a339 1
							i,tna-i,tnb-i,p);
d400 1
a400 1
	fprintf(stderr," bn_mul_low_recursive %d * %d\n",n2,n2);
d403 1
a403 1
	bn_mul_recursive(r,a,b,n,0,0,&(t[0]));
d434 1
a434 1
	fprintf(stderr," bn_mul_high %d * %d\n",n2,n2);
d487 2
a488 2
		bn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,0,0,&(t[n2]));
		bn_mul_recursive(r,&(a[n]),&(b[n]),n,0,0,&(t[n2]));
a612 1
	int ret=0;
d615 1
d620 2
a621 2
	BIGNUM *t=NULL;
	int j=0,k;
d625 1
a625 1
	fprintf(stderr,"BN_mul %d * %d\n",a->top,b->top);
d678 1
a678 1
		if (i >= -1 && i <= 1)
d680 4
a683 39
			int sav_j =0;
			/* Find out the power of two lower or equal
			   to the longest of the two numbers */
			if (i >= 0)
				{
				j = BN_num_bits_word((BN_ULONG)al);
				}
			if (i == -1)
				{
				j = BN_num_bits_word((BN_ULONG)bl);
				}
			sav_j = j;
			j = 1<<(j-1);
			assert(j <= al || j <= bl);
			k = j+j;
			t = BN_CTX_get(ctx);
			if (al > j || bl > j)
				{
				bn_wexpand(t,k*4);
				bn_wexpand(rr,k*4);
				bn_mul_part_recursive(rr->d,a->d,b->d,
					j,al-j,bl-j,t->d);
				}
			else	/* al <= j || bl <= j */
				{
				bn_wexpand(t,k*2);
				bn_wexpand(rr,k*2);
				bn_mul_recursive(rr->d,a->d,b->d,
					j,al-j,bl-j,t->d);
				}
			rr->top=top;
			goto end;
			}
#if 0
		if (i == 1 && !BN_get_flags(b,BN_FLG_STATIC_DATA))
			{
			BIGNUM *tmp_bn = (BIGNUM *)b;
			if (bn_wexpand(tmp_bn,al) == NULL) goto err;
			tmp_bn->d[bl]=0;
d687 1
a687 1
		else if (i == -1 && !BN_get_flags(a,BN_FLG_STATIC_DATA))
d689 4
a692 3
			BIGNUM *tmp_bn = (BIGNUM *)a;
			if (bn_wexpand(tmp_bn,bl) == NULL) goto err;
			tmp_bn->d[al]=0;
d709 2
d712 1
d715 8
a722 2
				if (bn_wexpand(t,k*4) == NULL) goto err;
				if (bn_wexpand(rr,k*4) == NULL) goto err;
d727 1
a728 1
#endif
d751 1
a751 1
	fprintf(stderr," bn_mul_normal %d * %d\n",na,nb);
d764 1
a764 7
	if (nb <= 0)
		{
		(void)bn_mul_words(r,a,na,0);
		return;
		}
	else
		rr[0]=bn_mul_words(r,a,na,b[0]);
d785 1
a785 1
	fprintf(stderr," bn_mul_low_normal %d * %d\n",n,n);
@


1.8
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d69 1
a69 1
#if defined(OPENSSL_NO_ASM) || !(defined(__i386) || defined(__i386__))/* Assembler implementation exists only for x86 */
@


1.7
log
@Merge openssl-0.9.7-stable-SNAP-20020519
@
text
@d967 1
a967 1
		BN_zero(r);
d1047 1
a1047 1
			bn_wexpand(tmp_bn,al);
d1055 1
a1055 1
			bn_wexpand(tmp_bn,bl);
d1070 2
a1071 2
				bn_wexpand(t,k*2);
				bn_wexpand(rr,k*2);
d1076 2
a1077 2
				bn_wexpand(t,k*4);
				bn_wexpand(rr,k*4);
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d411 4
a414 1
	if (n2 == 8)
d420 1
d423 4
a426 2
		/* This should not happen */
		bn_mul_normal(r,a,n2,b,n2);
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d59 5
d65 1
d69 309
d393 1
a393 1
	     BN_ULONG *t)
d396 1
d401 1
a401 1
	printf(" bn_mul_recursive %d * %d\n",n2,n2);
d424 2
a425 2
	c1=bn_cmp_words(a,&(a[n]),n);
	c2=bn_cmp_words(&(b[n]),b,n);
d430 2
a431 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d437 2
a438 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),&(b[n]),b,      n); /* + */
d447 2
a448 2
		bn_sub_words(t,      a,      &(a[n]),n); /* + */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d455 2
a456 2
		bn_sub_words(t,      a,      &(a[n]),n);
		bn_sub_words(&(t[n]),&(b[n]),b,      n);
d461 2
a462 1
	if (n == 4)
d472 3
a474 1
	else if (n == 8)
d489 1
a489 1
			bn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);
d492 2
a493 2
		bn_mul_recursive(r,a,b,n,p);
		bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,p);
d542 2
a543 2
void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int tn,
	     int n, BN_ULONG *t)
d550 2
a551 1
	printf(" bn_mul_part_recursive %d * %d\n",tn+n,tn+n);
d555 1
a555 2
		i=tn+n;
		bn_mul_normal(r,a,i,b,i);
d560 2
a561 2
	c1=bn_cmp_words(a,&(a[n]),n);
	c2=bn_cmp_words(&(b[n]),b,n);
d566 2
a567 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d573 2
a574 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),&(b[n]),b,      n); /* + */
d583 2
a584 2
		bn_sub_words(t,      a,      &(a[n]),n); /* + */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d591 2
a592 2
		bn_sub_words(t,      a,      &(a[n]),n);
		bn_sub_words(&(t[n]),&(b[n]),b,      n);
d611 2
a612 2
		bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);
		memset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));
d617 2
a618 2
		bn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);
		bn_mul_recursive(r,a,b,n,p);
d622 4
a625 1
		j=tn-i;
d628 2
a629 1
			bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),i,p);
d635 3
a637 3
					j,i,p);
				memset(&(r[n2+tn*2]),0,
					sizeof(BN_ULONG)*(n2-tn*2));
d642 2
a643 1
			if (tn < BN_MUL_RECURSIVE_SIZE_NORMAL)
d645 1
a645 1
				bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);
d652 1
a652 1
					if (i < tn)
d656 1
a656 1
							tn-i,i,p);
d659 1
a659 1
					else if (i == tn)
d663 1
a663 1
							i,p);
d724 1
a724 1
	printf(" bn_mul_low_recursive %d * %d\n",n2,n2);
d727 1
a727 1
	bn_mul_recursive(r,a,b,n,&(t[0]));
d758 1
a758 1
	printf(" bn_mul_high %d * %d\n",n2,n2);
d811 2
a812 2
		bn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,&(t[n2]));
		bn_mul_recursive(r,&(a[n]),&(b[n]),n,&(t[n2]));
d935 1
a935 1
int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
d937 1
a939 1
	int ret = 0;
d944 2
a945 2
	BIGNUM *t;
	int j,k;
d949 1
a949 1
	printf("BN_mul %d * %d\n",a->top,b->top);
d1002 36
d1040 3
a1042 2
			bn_wexpand(b,al);
			b->d[bl]=0;
d1048 3
a1050 2
			bn_wexpand(a,bl);
			a->d[al]=0;
a1069 2
				bn_wexpand(a,k);
				bn_wexpand(b,k);
a1071 4
				for (i=a->top; i<k; i++)
					a->d[i]=0;
				for (i=b->top; i<k; i++)
					b->d[i]=0;
d1077 1
d1100 1
a1100 1
	printf(" bn_mul_normal %d * %d\n",na,nb);
d1113 7
a1119 1
	rr[0]=bn_mul_words(r,a,na,b[0]);
d1140 1
a1140 1
	printf(" bn_mul_low_normal %d * %d\n",n,n);
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@a633 1
	r->neg=a->neg^b->neg;
d649 1
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d64 3
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d69 1
a69 1
 * We calulate
d81 6
a86 5
#ifdef BN_COUNT
printf(" bn_mul_recursive %d * %d\n",n2,n2);
#endif
#ifdef BN_MUL_COMBA
/*	if (n2 == 4)
d91 2
a92 1
	else */ if (n2 == 8)
d97 1
a97 1
#endif
d141 1
a141 1
#ifdef BN_MUL_COMBA
d163 1
a163 1
#endif
d224 1
a224 1
	unsigned int c1;
d227 3
a229 3
#ifdef BN_COUNT
printf(" bn_mul_part_recursive %d * %d\n",tn+n,tn+n);
#endif
d238 39
a276 4
	bn_sub_words(t,      a,      &(a[n]),n); /* + */
	bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */

/*	if (n == 4)
d283 3
a285 1
	else */ if (n == 8)
d350 10
a359 1
	c1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));
d396 3
a398 3
#ifdef BN_COUNT
printf(" bn_mul_low_recursive %d * %d\n",n2,n2);
#endif
d430 3
a432 3
#ifdef BN_COUNT
printf(" bn_mul_high %d * %d\n",n2,n2);
#endif
d475 1
a475 1
#ifdef BN_MUL_COMBA
d482 1
a482 1
#endif
d606 1
a606 1
#endif
d612 4
d618 1
a618 1
	int i,j,k;
d622 1
a622 1
printf("BN_mul %d * %d\n",a->top,b->top);
d640 1
d642 3
a644 1
		rr= &(ctx->bn[ctx->tos+1]);
d646 1
a646 1
		rr=r;
d649 4
a652 1
	if (al == bl)
d654 2
a655 2
#  ifdef BN_MUL_COMBA
/*		if (al == 4)
d657 1
a657 1
			if (bn_wexpand(rr,8) == NULL) return(0);
d662 2
a663 1
		else */ if (al == 8)
d665 1
a665 1
			if (bn_wexpand(rr,16) == NULL) return(0);
a669 14
		else
#  endif
#ifdef BN_RECURSION
		if (al < BN_MULL_SIZE_NORMAL)
#endif
			{
			if (bn_wexpand(rr,top) == NULL) return(0);
			rr->top=top;
			bn_mul_normal(rr->d,a->d,al,b->d,bl);
			goto end;
			}
#  ifdef BN_RECURSION
		goto symetric;
#  endif
d671 1
a671 1
#endif
d673 1
a673 1
	else if ((al < BN_MULL_SIZE_NORMAL) || (bl < BN_MULL_SIZE_NORMAL))
d675 1
a675 9
		if (bn_wexpand(rr,top) == NULL) return(0);
		rr->top=top;
		bn_mul_normal(rr->d,a->d,al,b->d,bl);
		goto end;
		}
	else
		{
		i=(al-bl);
		if ((i ==  1) && !BN_get_flags(b,BN_FLG_STATIC_DATA))
d680 1
a680 1
			goto symetric;
d682 1
a682 1
		else if ((i ==  -1) && !BN_get_flags(a,BN_FLG_STATIC_DATA))
d687 30
a716 1
			goto symetric;
d719 2
a720 4
#endif

	/* asymetric and >= 4 */ 
	if (bn_wexpand(rr,top) == NULL) return(0);
a723 31
#ifdef BN_RECURSION
	if (0)
		{
symetric:
		/* symetric and > 4 */
		/* 16 or larger */
		j=BN_num_bits_word((BN_ULONG)al);
		j=1<<(j-1);
		k=j+j;
		t= &(ctx->bn[ctx->tos]);
		if (al == j) /* exact multiple */
			{
			bn_wexpand(t,k*2);
			bn_wexpand(rr,k*2);
			bn_mul_recursive(rr->d,a->d,b->d,al,t->d);
			}
		else
			{
			bn_wexpand(a,k);
			bn_wexpand(b,k);
			bn_wexpand(t,k*4);
			bn_wexpand(rr,k*4);
			for (i=a->top; i<k; i++)
				a->d[i]=0;
			for (i=b->top; i<k; i++)
				b->d[i]=0;
			bn_mul_part_recursive(rr->d,a->d,b->d,al-j,j,t->d);
			}
		rr->top=top;
		}
#endif
d729 4
a732 1
	return(1);
d740 1
a740 1
printf(" bn_mul_normal %d * %d\n",na,nb);
d774 1
a774 1
printf(" bn_mul_low_normal %d * %d\n",n,n);
a791 1

@


1.1
log
@Initial revision
@
text
@d63 17
a79 10
/* r must be different to a and b */
/* int BN_mmul(r, a, b) */
int BN_mul(r, a, b)
BIGNUM *r;
BIGNUM *a;
BIGNUM *b;
	{
	int i;
	int max,al,bl;
	BN_ULONG *ap,*bp,*rp;
d81 26
a106 3
	al=a->top;
	bl=b->top;
	if ((al == 0) || (bl == 0))
d108 29
a136 2
		r->top=0;
		return(1);
d139 23
a161 11
	max=(al+bl);
	if (bn_wexpand(r,max) == NULL) return(0);
	r->top=max;
	r->neg=a->neg^b->neg;
	ap=a->d;
	bp=b->d;
	rp=r->d;

	rp[al]=bn_mul_words(rp,ap,al,*(bp++));
	rp++;
	for (i=1; i<bl; i++)
d163 7
a169 2
		rp[al]=bn_mul_add_words(rp,ap,al,*(bp++));
		rp++;
a170 3
	if (r->d[max-1] == 0) r->top--;
	return(1);
	}
d172 16
a187 2
#if 0
#include "stack.h"
d189 26
a214 1
int limit=16;
d216 4
a219 1
typedef struct bn_pool_st
d221 13
a233 4
	int used;
	int tos;
	STACK *sk; 
	} BN_POOL;
d235 3
a237 4
BIGNUM *BN_POOL_push(bp)
BN_POOL *bp;
	{
	BIGNUM *ret;
d239 1
a239 1
	if (bp->used >= bp->tos)
d241 11
a251 4
		ret=BN_new();
		sk_push(bp->sk,(char *)ret);
		bp->tos++;
		bp->used++;
d255 82
a336 2
		ret=(BIGNUM *)sk_value(bp->sk,bp->used);
		bp->used++;
a337 1
	return(ret);
d340 5
a344 3
void BN_POOL_pop(bp,num)
BN_POOL *bp;
int num;
d346 21
a366 1
	bp->used-=num;
d369 7
a375 2
int BN_mul(r,a,b)
BIGNUM *r,*a,*b;
d377 4
a380 2
	static BN_POOL bp;
	static init=1;
d382 53
a434 1
	if (init)
d436 120
a555 4
		bp.used=0;
		bp.tos=0;
		bp.sk=sk_new_null();
		init=0;
a556 1
	return(BN_mm(r,a,b,&bp));
d558 1
d560 1
a560 4
/* r must be different to a and b */
int BN_mm(m, A, B, bp)
BIGNUM *m,*A,*B;
BN_POOL *bp;
d562 10
a571 3
	int i,num;
	int an,bn;
	BIGNUM *a,*b,*c,*d,*ac,*bd;
d573 9
a581 3
	an=A->top;
	bn=B->top;
	if ((an <= limit) || (bn <= limit))
d583 2
a584 1
		return(BN_mmul(m,A,B));
d586 1
d588 4
a591 6
	a=BN_POOL_push(bp);
	b=BN_POOL_push(bp);
	c=BN_POOL_push(bp);
	d=BN_POOL_push(bp);
	ac=BN_POOL_push(bp);
	bd=BN_POOL_push(bp);
d593 105
a697 2
	num=(an <= bn)?an:bn;
	num=1<<(BN_num_bits_word(num-1)-1);
d699 3
a701 2
	/* Are going to now chop things into 'num' word chunks. */
	num*=BN_BITS2;
d703 3
a705 3
	BN_copy(a,A);
	BN_mask_bits(a,num);
	BN_rshift(b,A,num);
d707 4
a710 3
	BN_copy(c,B);
	BN_mask_bits(c,num);
	BN_rshift(d,B,num);
d712 2
a713 5
	BN_sub(ac ,b,a);
	BN_sub(bd,c,d);
	BN_mm(m,ac,bd,bp);
	BN_mm(ac,a,c,bp);
	BN_mm(bd,b,d,bp);
d715 3
a717 4
	BN_add(m,m,ac);
	BN_add(m,m,bd);
	BN_lshift(m,m,num);
	BN_lshift(bd,bd,num*2);
d719 14
a732 4
	BN_add(m,m,ac);
	BN_add(m,m,bd);
	BN_POOL_pop(bp,6);
	return(1);
d734 5
d740 17
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a58 5
#ifndef BN_DEBUG
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
#endif

a59 1
#include <assert.h>
d63 6
a68 14
#if defined(OPENSSL_NO_ASM) || !(defined(__i386) || defined(__i386__))/* Assembler implementation exists only for x86 */
/* Here follows specialised variants of bn_add_words() and
   bn_sub_words().  They have the property performing operations on
   arrays of different sizes.  The sizes of those arrays is expressed through
   cl, which is the common length ( basicall, min(len(a),len(b)) ), and dl,
   which is the delta between the two lengths, calculated as len(a)-len(b).
   All lengths are the number of BN_ULONGs...  For the operations that require
   a result array as parameter, it must have the length cl+abs(dl).
   These functions should probably end up in bn_asm.c as soon as there are
   assembler counterparts for the systems that use assembler files.  */

BN_ULONG bn_sub_part_words(BN_ULONG *r,
	const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
d70 3
a72 1
	BN_ULONG c, t;
d74 3
a76 11
	assert(cl >= 0);
	c = bn_sub_words(r, a, b, cl);

	if (dl == 0)
		return c;

	r += cl;
	a += cl;
	b += cl;

	if (dl < 0)
d78 2
a79 28
#ifdef BN_COUNT
		fprintf(stderr, "  bn_sub_part_words %d + %d (dl < 0, c = %d)\n", cl, dl, c);
#endif
		for (;;)
			{
			t = b[0];
			r[0] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			t = b[1];
			r[1] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			t = b[2];
			r[2] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			t = b[3];
			r[3] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			b += 4;
			r += 4;
			}
d81 12
a92 1
	else
d94 2
a95 73
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, c = %d)\n", cl, dl, c);
#endif
		while(c)
			{
			t = a[0];
			r[0] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			t = a[1];
			r[1] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			t = a[2];
			r[2] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			t = a[3];
			r[3] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			save_dl = dl;
			a += 4;
			r += 4;
			}
		if (dl > 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, c == 0)\n", cl, dl);
#endif
			if (save_dl > dl)
				{
				switch (save_dl - dl)
					{
				case 1:
					r[1] = a[1];
					if (--dl <= 0) break;
				case 2:
					r[2] = a[2];
					if (--dl <= 0) break;
				case 3:
					r[3] = a[3];
					if (--dl <= 0) break;
					}
				a += 4;
				r += 4;
				}
			}
		if (dl > 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, copy)\n", cl, dl);
#endif
			for(;;)
				{
				r[0] = a[0];
				if (--dl <= 0) break;
				r[1] = a[1];
				if (--dl <= 0) break;
				r[2] = a[2];
				if (--dl <= 0) break;
				r[3] = a[3];
				if (--dl <= 0) break;

				a += 4;
				r += 4;
				}
			}
d97 2
a98 1
	return c;
a99 1
#endif
d101 2
a102 11
BN_ULONG bn_add_part_words(BN_ULONG *r,
	const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
	{
	BN_ULONG c, l, t;

	assert(cl >= 0);
	c = bn_add_words(r, a, b, cl);

	if (dl == 0)
		return c;
d104 1
a104 3
	r += cl;
	a += cl;
	b += cl;
d106 1
a106 171
	if (dl < 0)
		{
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, c = %d)\n", cl, dl, c);
#endif
		while (c)
			{
			l=(c+b[0])&BN_MASK2;
			c=(l < c);
			r[0]=l;
			if (++dl >= 0) break;

			l=(c+b[1])&BN_MASK2;
			c=(l < c);
			r[1]=l;
			if (++dl >= 0) break;

			l=(c+b[2])&BN_MASK2;
			c=(l < c);
			r[2]=l;
			if (++dl >= 0) break;

			l=(c+b[3])&BN_MASK2;
			c=(l < c);
			r[3]=l;
			if (++dl >= 0) break;

			save_dl = dl;
			b+=4;
			r+=4;
			}
		if (dl < 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, c == 0)\n", cl, dl);
#endif
			if (save_dl < dl)
				{
				switch (dl - save_dl)
					{
				case 1:
					r[1] = b[1];
					if (++dl >= 0) break;
				case 2:
					r[2] = b[2];
					if (++dl >= 0) break;
				case 3:
					r[3] = b[3];
					if (++dl >= 0) break;
					}
				b += 4;
				r += 4;
				}
			}
		if (dl < 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, copy)\n", cl, dl);
#endif
			for(;;)
				{
				r[0] = b[0];
				if (++dl >= 0) break;
				r[1] = b[1];
				if (++dl >= 0) break;
				r[2] = b[2];
				if (++dl >= 0) break;
				r[3] = b[3];
				if (++dl >= 0) break;

				b += 4;
				r += 4;
				}
			}
		}
	else
		{
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0)\n", cl, dl);
#endif
		while (c)
			{
			t=(a[0]+c)&BN_MASK2;
			c=(t < c);
			r[0]=t;
			if (--dl <= 0) break;

			t=(a[1]+c)&BN_MASK2;
			c=(t < c);
			r[1]=t;
			if (--dl <= 0) break;

			t=(a[2]+c)&BN_MASK2;
			c=(t < c);
			r[2]=t;
			if (--dl <= 0) break;

			t=(a[3]+c)&BN_MASK2;
			c=(t < c);
			r[3]=t;
			if (--dl <= 0) break;

			save_dl = dl;
			a+=4;
			r+=4;
			}
#ifdef BN_COUNT
		fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0, c == 0)\n", cl, dl);
#endif
		if (dl > 0)
			{
			if (save_dl > dl)
				{
				switch (save_dl - dl)
					{
				case 1:
					r[1] = a[1];
					if (--dl <= 0) break;
				case 2:
					r[2] = a[2];
					if (--dl <= 0) break;
				case 3:
					r[3] = a[3];
					if (--dl <= 0) break;
					}
				a += 4;
				r += 4;
				}
			}
		if (dl > 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0, copy)\n", cl, dl);
#endif
			for(;;)
				{
				r[0] = a[0];
				if (--dl <= 0) break;
				r[1] = a[1];
				if (--dl <= 0) break;
				r[2] = a[2];
				if (--dl <= 0) break;
				r[3] = a[3];
				if (--dl <= 0) break;

				a += 4;
				r += 4;
				}
			}
		}
	return c;
	}

#ifdef BN_RECURSION
/* Karatsuba recursive multiplication algorithm
 * (cf. Knuth, The Art of Computer Programming, Vol. 2) */

/* r is 2*n2 words in size,
 * a and b are both n2 words in size.
 * n2 must be a power of 2.
 * We multiply and return the result.
 * t must be 2*n2 words in size
 * We calculate
 * a[0]*b[0]
 * a[0]*b[0]+a[1]*b[1]+(a[0]-a[1])*(b[1]-b[0])
 * a[1]*b[1]
 */
void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
	int dna, int dnb, BN_ULONG *t)
d108 4
a111 150
	int n=n2/2,c1,c2;
	int tna=n+dna, tnb=n+dnb;
	unsigned int neg,zero;
	BN_ULONG ln,lo,*p;

# ifdef BN_COUNT
	fprintf(stderr," bn_mul_recursive %d * %d\n",n2,n2);
# endif
# ifdef BN_MUL_COMBA
#  if 0
	if (n2 == 4)
		{
		bn_mul_comba4(r,a,b);
		return;
		}
#  endif
	/* Only call bn_mul_comba 8 if n2 == 8 and the
	 * two arrays are complete [steve]
	 */
	if (n2 == 8 && dna == 0 && dnb == 0)
		{
		bn_mul_comba8(r,a,b);
		return; 
		}
# endif /* BN_MUL_COMBA */
	/* Else do normal multiply */
	if (n2 < BN_MUL_RECURSIVE_SIZE_NORMAL)
		{
		bn_mul_normal(r,a,n2+dna,b,n2+dnb);
		if ((dna + dnb) < 0)
			memset(&r[2*n2 + dna + dnb], 0,
				sizeof(BN_ULONG) * -(dna + dnb));
		return;
		}
	/* r=(a[0]-a[1])*(b[1]-b[0]) */
	c1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);
	c2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);
	zero=neg=0;
	switch (c1*3+c2)
		{
	case -4:
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
		break;
	case -3:
		zero=1;
		break;
	case -2:
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */
		neg=1;
		break;
	case -1:
	case 0:
	case 1:
		zero=1;
		break;
	case 2:
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
		neg=1;
		break;
	case 3:
		zero=1;
		break;
	case 4:
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);
		break;
		}

# ifdef BN_MUL_COMBA
	if (n == 4 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba4 could take
					       extra args to do this well */
		{
		if (!zero)
			bn_mul_comba4(&(t[n2]),t,&(t[n]));
		else
			memset(&(t[n2]),0,8*sizeof(BN_ULONG));
		
		bn_mul_comba4(r,a,b);
		bn_mul_comba4(&(r[n2]),&(a[n]),&(b[n]));
		}
	else if (n == 8 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba8 could
						    take extra args to do this
						    well */
		{
		if (!zero)
			bn_mul_comba8(&(t[n2]),t,&(t[n]));
		else
			memset(&(t[n2]),0,16*sizeof(BN_ULONG));
		
		bn_mul_comba8(r,a,b);
		bn_mul_comba8(&(r[n2]),&(a[n]),&(b[n]));
		}
	else
# endif /* BN_MUL_COMBA */
		{
		p= &(t[n2*2]);
		if (!zero)
			bn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);
		else
			memset(&(t[n2]),0,n2*sizeof(BN_ULONG));
		bn_mul_recursive(r,a,b,n,0,0,p);
		bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,dna,dnb,p);
		}

	/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign
	 * r[10] holds (a[0]*b[0])
	 * r[32] holds (b[1]*b[1])
	 */

	c1=(int)(bn_add_words(t,r,&(r[n2]),n2));

	if (neg) /* if t[32] is negative */
		{
		c1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));
		}
	else
		{
		/* Might have a carry */
		c1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));
		}

	/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])
	 * r[10] holds (a[0]*b[0])
	 * r[32] holds (b[1]*b[1])
	 * c1 holds the carry bits
	 */
	c1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));
	if (c1)
		{
		p= &(r[n+n2]);
		lo= *p;
		ln=(lo+c1)&BN_MASK2;
		*p=ln;

		/* The overflow will stop before we over write
		 * words we should not overwrite */
		if (ln < (BN_ULONG)c1)
			{
			do	{
				p++;
				lo= *p;
				ln=(lo+1)&BN_MASK2;
				*p=ln;
				} while (ln == 0);
			}
		}
	}
d113 2
a114 4
/* n+tn is the word length
 * t needs to be n*4 is size, as does r */
void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n,
	     int tna, int tnb, BN_ULONG *t)
d116 1
a116 13
	int i,j,n2=n*2;
	unsigned int c1,c2,neg,zero;
	BN_ULONG ln,lo,*p;

# ifdef BN_COUNT
	fprintf(stderr," bn_mul_part_recursive (%d+%d) * (%d+%d)\n",
		tna, n, tnb, n);
# endif
	if (n < 8)
		{
		bn_mul_normal(r,a,n+tna,b,n+tnb);
		return;
		}
d118 1
a118 40
	/* r=(a[0]-a[1])*(b[1]-b[0]) */
	c1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);
	c2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);
	zero=neg=0;
	switch (c1*3+c2)
		{
	case -4:
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
		break;
	case -3:
		zero=1;
		/* break; */
	case -2:
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */
		neg=1;
		break;
	case -1:
	case 0:
	case 1:
		zero=1;
		/* break; */
	case 2:
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
		neg=1;
		break;
	case 3:
		zero=1;
		/* break; */
	case 4:
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);
		break;
		}
		/* The zero case isn't yet implemented here. The speedup
		   would probably be negligible. */
# if 0
	if (n == 4)
d120 4
a123 4
		bn_mul_comba4(&(t[n2]),t,&(t[n]));
		bn_mul_comba4(r,a,b);
		bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);
		memset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));
a125 2
# endif
	if (n == 8)
d127 2
a128 103
		bn_mul_comba8(&(t[n2]),t,&(t[n]));
		bn_mul_comba8(r,a,b);
		bn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);
		memset(&(r[n2+tna+tnb]),0,sizeof(BN_ULONG)*(n2-tna-tnb));
		}
	else
		{
		p= &(t[n2*2]);
		bn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);
		bn_mul_recursive(r,a,b,n,0,0,p);
		i=n/2;
		/* If there is only a bottom half to the number,
		 * just do it */
		if (tna > tnb)
			j = tna - i;
		else
			j = tnb - i;
		if (j == 0)
			{
			bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),
				i,tna-i,tnb-i,p);
			memset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2));
			}
		else if (j > 0) /* eg, n == 16, i == 8 and tn == 11 */
				{
				bn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]),
					i,tna-i,tnb-i,p);
				memset(&(r[n2+tna+tnb]),0,
					sizeof(BN_ULONG)*(n2-tna-tnb));
				}
		else /* (j < 0) eg, n == 16, i == 8 and tn == 5 */
			{
			memset(&(r[n2]),0,sizeof(BN_ULONG)*n2);
			if (tna < BN_MUL_RECURSIVE_SIZE_NORMAL
				&& tnb < BN_MUL_RECURSIVE_SIZE_NORMAL)
				{
				bn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);
				}
			else
				{
				for (;;)
					{
					i/=2;
					if (i < tna && i < tnb)
						{
						bn_mul_part_recursive(&(r[n2]),
							&(a[n]),&(b[n]),
							i,tna-i,tnb-i,p);
						break;
						}
					else if (i <= tna && i <= tnb)
						{
						bn_mul_recursive(&(r[n2]),
							&(a[n]),&(b[n]),
							i,tna-i,tnb-i,p);
						break;
						}
					}
				}
			}
		}

	/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign
	 * r[10] holds (a[0]*b[0])
	 * r[32] holds (b[1]*b[1])
	 */

	c1=(int)(bn_add_words(t,r,&(r[n2]),n2));

	if (neg) /* if t[32] is negative */
		{
		c1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));
		}
	else
		{
		/* Might have a carry */
		c1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));
		}

	/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])
	 * r[10] holds (a[0]*b[0])
	 * r[32] holds (b[1]*b[1])
	 * c1 holds the carry bits
	 */
	c1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));
	if (c1)
		{
		p= &(r[n+n2]);
		lo= *p;
		ln=(lo+c1)&BN_MASK2;
		*p=ln;

		/* The overflow will stop before we over write
		 * words we should not overwrite */
		if (ln < c1)
			{
			do	{
				p++;
				lo= *p;
				ln=(lo+1)&BN_MASK2;
				*p=ln;
				} while (ln == 0);
			}
d130 1
d133 3
a135 5
/* a and b must be the same size, which is n2.
 * r needs to be n2 words and t needs to be n2*2
 */
void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
	     BN_ULONG *t)
d137 1
a137 21
	int n=n2/2;

# ifdef BN_COUNT
	fprintf(stderr," bn_mul_low_recursive %d * %d\n",n2,n2);
# endif

	bn_mul_recursive(r,a,b,n,0,0,&(t[0]));
	if (n >= BN_MUL_LOW_RECURSIVE_SIZE_NORMAL)
		{
		bn_mul_low_recursive(&(t[0]),&(a[0]),&(b[n]),n,&(t[n2]));
		bn_add_words(&(r[n]),&(r[n]),&(t[0]),n);
		bn_mul_low_recursive(&(t[0]),&(a[n]),&(b[0]),n,&(t[n2]));
		bn_add_words(&(r[n]),&(r[n]),&(t[0]),n);
		}
	else
		{
		bn_mul_low_normal(&(t[0]),&(a[0]),&(b[n]),n);
		bn_mul_low_normal(&(t[n]),&(a[n]),&(b[0]),n);
		bn_add_words(&(r[n]),&(r[n]),&(t[0]),n);
		bn_add_words(&(r[n]),&(r[n]),&(t[n]),n);
		}
d140 2
a141 7
/* a and b must be the same size, which is n2.
 * r needs to be n2 words and t needs to be n2*2
 * l is the low words of the output.
 * t needs to be n2*3
 */
void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l, int n2,
	     BN_ULONG *t)
d143 2
a144 79
	int i,n;
	int c1,c2;
	int neg,oneg,zero;
	BN_ULONG ll,lc,*lp,*mp;

# ifdef BN_COUNT
	fprintf(stderr," bn_mul_high %d * %d\n",n2,n2);
# endif
	n=n2/2;

	/* Calculate (al-ah)*(bh-bl) */
	neg=zero=0;
	c1=bn_cmp_words(&(a[0]),&(a[n]),n);
	c2=bn_cmp_words(&(b[n]),&(b[0]),n);
	switch (c1*3+c2)
		{
	case -4:
		bn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);
		bn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);
		break;
	case -3:
		zero=1;
		break;
	case -2:
		bn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);
		bn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);
		neg=1;
		break;
	case -1:
	case 0:
	case 1:
		zero=1;
		break;
	case 2:
		bn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);
		bn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);
		neg=1;
		break;
	case 3:
		zero=1;
		break;
	case 4:
		bn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);
		bn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);
		break;
		}
		
	oneg=neg;
	/* t[10] = (a[0]-a[1])*(b[1]-b[0]) */
	/* r[10] = (a[1]*b[1]) */
# ifdef BN_MUL_COMBA
	if (n == 8)
		{
		bn_mul_comba8(&(t[0]),&(r[0]),&(r[n]));
		bn_mul_comba8(r,&(a[n]),&(b[n]));
		}
	else
# endif
		{
		bn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,0,0,&(t[n2]));
		bn_mul_recursive(r,&(a[n]),&(b[n]),n,0,0,&(t[n2]));
		}

	/* s0 == low(al*bl)
	 * s1 == low(ah*bh)+low((al-ah)*(bh-bl))+low(al*bl)+high(al*bl)
	 * We know s0 and s1 so the only unknown is high(al*bl)
	 * high(al*bl) == s1 - low(ah*bh+s0+(al-ah)*(bh-bl))
	 * high(al*bl) == s1 - (r[0]+l[0]+t[0])
	 */
	if (l != NULL)
		{
		lp= &(t[n2+n]);
		c1=(int)(bn_add_words(lp,&(r[0]),&(l[0]),n));
		}
	else
		{
		c1=0;
		lp= &(r[0]);
		}
d146 1
a146 79
	if (neg)
		neg=(int)(bn_sub_words(&(t[n2]),lp,&(t[0]),n));
	else
		{
		bn_add_words(&(t[n2]),lp,&(t[0]),n);
		neg=0;
		}

	if (l != NULL)
		{
		bn_sub_words(&(t[n2+n]),&(l[n]),&(t[n2]),n);
		}
	else
		{
		lp= &(t[n2+n]);
		mp= &(t[n2]);
		for (i=0; i<n; i++)
			lp[i]=((~mp[i])+1)&BN_MASK2;
		}

	/* s[0] = low(al*bl)
	 * t[3] = high(al*bl)
	 * t[10] = (a[0]-a[1])*(b[1]-b[0]) neg is the sign
	 * r[10] = (a[1]*b[1])
	 */
	/* R[10] = al*bl
	 * R[21] = al*bl + ah*bh + (a[0]-a[1])*(b[1]-b[0])
	 * R[32] = ah*bh
	 */
	/* R[1]=t[3]+l[0]+r[0](+-)t[0] (have carry/borrow)
	 * R[2]=r[0]+t[3]+r[1](+-)t[1] (have carry/borrow)
	 * R[3]=r[1]+(carry/borrow)
	 */
	if (l != NULL)
		{
		lp= &(t[n2]);
		c1= (int)(bn_add_words(lp,&(t[n2+n]),&(l[0]),n));
		}
	else
		{
		lp= &(t[n2+n]);
		c1=0;
		}
	c1+=(int)(bn_add_words(&(t[n2]),lp,  &(r[0]),n));
	if (oneg)
		c1-=(int)(bn_sub_words(&(t[n2]),&(t[n2]),&(t[0]),n));
	else
		c1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),&(t[0]),n));

	c2 =(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n2+n]),n));
	c2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(r[n]),n));
	if (oneg)
		c2-=(int)(bn_sub_words(&(r[0]),&(r[0]),&(t[n]),n));
	else
		c2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n]),n));
	
	if (c1 != 0) /* Add starting at r[0], could be +ve or -ve */
		{
		i=0;
		if (c1 > 0)
			{
			lc=c1;
			do	{
				ll=(r[i]+lc)&BN_MASK2;
				r[i++]=ll;
				lc=(lc > ll);
				} while (lc);
			}
		else
			{
			lc= -c1;
			do	{
				ll=r[i];
				r[i++]=(ll-lc)&BN_MASK2;
				lc=(lc > ll);
				} while (lc);
			}
		}
	if (c2 != 0) /* Add starting at r[1] */
d148 4
a151 19
		i=n;
		if (c2 > 0)
			{
			lc=c2;
			do	{
				ll=(r[i]+lc)&BN_MASK2;
				r[i++]=ll;
				lc=(lc > ll);
				} while (lc);
			}
		else
			{
			lc= -c2;
			do	{
				ll=r[i];
				r[i++]=(ll-lc)&BN_MASK2;
				lc=(lc > ll);
				} while (lc);
			}
d153 1
a154 1
#endif /* BN_RECURSION */
d156 4
a159 1
int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
d161 3
a163 28
	int ret=0;
	int top,al,bl;
	BIGNUM *rr;
#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
	int i;
#endif
#ifdef BN_RECURSION
	BIGNUM *t=NULL;
	int j=0,k;
#endif

#ifdef BN_COUNT
	fprintf(stderr,"BN_mul %d * %d\n",a->top,b->top);
#endif

	bn_check_top(a);
	bn_check_top(b);
	bn_check_top(r);

	al=a->top;
	bl=b->top;

	if ((al == 0) || (bl == 0))
		{
		if (!BN_zero(r)) goto err;
		return(1);
		}
	top=al+bl;
d165 3
a167 2
	BN_CTX_start(ctx);
	if ((r == a) || (r == b))
d169 1
a169 1
		if ((rr = BN_CTX_get(ctx)) == NULL) goto err;
a170 3
	else
		rr = r;
	rr->neg=a->neg^b->neg;
d172 6
a177 108
#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
	i = al-bl;
#endif
#ifdef BN_MUL_COMBA
	if (i == 0)
		{
# if 0
		if (al == 4)
			{
			if (bn_wexpand(rr,8) == NULL) goto err;
			rr->top=8;
			bn_mul_comba4(rr->d,a->d,b->d);
			goto end;
			}
# endif
		if (al == 8)
			{
			if (bn_wexpand(rr,16) == NULL) goto err;
			rr->top=16;
			bn_mul_comba8(rr->d,a->d,b->d);
			goto end;
			}
		}
#endif /* BN_MUL_COMBA */
#ifdef BN_RECURSION
	if ((al >= BN_MULL_SIZE_NORMAL) && (bl >= BN_MULL_SIZE_NORMAL))
		{
		if (i >= -1 && i <= 1)
			{
			int sav_j =0;
			/* Find out the power of two lower or equal
			   to the longest of the two numbers */
			if (i >= 0)
				{
				j = BN_num_bits_word((BN_ULONG)al);
				}
			if (i == -1)
				{
				j = BN_num_bits_word((BN_ULONG)bl);
				}
			sav_j = j;
			j = 1<<(j-1);
			assert(j <= al || j <= bl);
			k = j+j;
			t = BN_CTX_get(ctx);
			if (al > j || bl > j)
				{
				bn_wexpand(t,k*4);
				bn_wexpand(rr,k*4);
				bn_mul_part_recursive(rr->d,a->d,b->d,
					j,al-j,bl-j,t->d);
				}
			else	/* al <= j || bl <= j */
				{
				bn_wexpand(t,k*2);
				bn_wexpand(rr,k*2);
				bn_mul_recursive(rr->d,a->d,b->d,
					j,al-j,bl-j,t->d);
				}
			rr->top=top;
			goto end;
			}
#if 0
		if (i == 1 && !BN_get_flags(b,BN_FLG_STATIC_DATA))
			{
			BIGNUM *tmp_bn = (BIGNUM *)b;
			if (bn_wexpand(tmp_bn,al) == NULL) goto err;
			tmp_bn->d[bl]=0;
			bl++;
			i--;
			}
		else if (i == -1 && !BN_get_flags(a,BN_FLG_STATIC_DATA))
			{
			BIGNUM *tmp_bn = (BIGNUM *)a;
			if (bn_wexpand(tmp_bn,bl) == NULL) goto err;
			tmp_bn->d[al]=0;
			al++;
			i++;
			}
		if (i == 0)
			{
			/* symmetric and > 4 */
			/* 16 or larger */
			j=BN_num_bits_word((BN_ULONG)al);
			j=1<<(j-1);
			k=j+j;
			t = BN_CTX_get(ctx);
			if (al == j) /* exact multiple */
				{
				if (bn_wexpand(t,k*2) == NULL) goto err;
				if (bn_wexpand(rr,k*2) == NULL) goto err;
				bn_mul_recursive(rr->d,a->d,b->d,al,t->d);
				}
			else
				{
				if (bn_wexpand(t,k*4) == NULL) goto err;
				if (bn_wexpand(rr,k*4) == NULL) goto err;
				bn_mul_part_recursive(rr->d,a->d,b->d,al-j,j,t->d);
				}
			rr->top=top;
			goto end;
			}
#endif
		}
#endif /* BN_RECURSION */
	if (bn_wexpand(rr,top) == NULL) goto err;
	rr->top=top;
	bn_mul_normal(rr->d,a->d,al,b->d,bl);
d179 2
a180 10
#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
end:
#endif
	bn_fix_top(rr);
	if (r != rr) BN_copy(r,rr);
	ret=1;
err:
	BN_CTX_end(ctx);
	return(ret);
	}
d182 2
a183 3
void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)
	{
	BN_ULONG *rr;
d185 3
a187 3
#ifdef BN_COUNT
	fprintf(stderr," bn_mul_normal %d * %d\n",na,nb);
#endif
d189 3
a191 4
	if (na < nb)
		{
		int itmp;
		BN_ULONG *ltmp;
d193 5
a197 2
		itmp=na; na=nb; nb=itmp;
		ltmp=a;   a=b;   b=ltmp;
d199 4
a202 9
		}
	rr= &(r[na]);
	if (nb <= 0)
		{
		(void)bn_mul_words(r,a,na,0);
		return;
		}
	else
		rr[0]=bn_mul_words(r,a,na,b[0]);
d204 4
a207 14
	for (;;)
		{
		if (--nb <= 0) return;
		rr[1]=bn_mul_add_words(&(r[1]),a,na,b[1]);
		if (--nb <= 0) return;
		rr[2]=bn_mul_add_words(&(r[2]),a,na,b[2]);
		if (--nb <= 0) return;
		rr[3]=bn_mul_add_words(&(r[3]),a,na,b[3]);
		if (--nb <= 0) return;
		rr[4]=bn_mul_add_words(&(r[4]),a,na,b[4]);
		rr+=4;
		r+=4;
		b+=4;
		}
a208 5

void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
	{
#ifdef BN_COUNT
	fprintf(stderr," bn_mul_low_normal %d * %d\n",n,n);
a209 16
	bn_mul_words(r,a,n,b[0]);

	for (;;)
		{
		if (--n <= 0) return;
		bn_mul_add_words(&(r[1]),a,n,b[1]);
		if (--n <= 0) return;
		bn_mul_add_words(&(r[2]),a,n,b[2]);
		if (--n <= 0) return;
		bn_mul_add_words(&(r[3]),a,n,b[3]);
		if (--n <= 0) return;
		bn_mul_add_words(&(r[4]),a,n,b[4]);
		r+=4;
		b+=4;
		}
	}
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d69 1
a69 1
#if defined(OPENSSL_NO_ASM) || !(defined(__i386) || defined(__i386__)) || defined(__DJGPP__) /* Assembler implementation exists only for x86 */
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d59 5
d65 1
d69 309
d393 1
a393 1
	     BN_ULONG *t)
d396 1
d401 1
a401 1
	printf(" bn_mul_recursive %d * %d\n",n2,n2);
d411 4
a414 1
	if (n2 == 8)
d420 1
d423 4
a426 2
		/* This should not happen */
		bn_mul_normal(r,a,n2,b,n2);
d430 2
a431 2
	c1=bn_cmp_words(a,&(a[n]),n);
	c2=bn_cmp_words(&(b[n]),b,n);
d436 2
a437 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d443 2
a444 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),&(b[n]),b,      n); /* + */
d453 2
a454 2
		bn_sub_words(t,      a,      &(a[n]),n); /* + */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d461 2
a462 2
		bn_sub_words(t,      a,      &(a[n]),n);
		bn_sub_words(&(t[n]),&(b[n]),b,      n);
d467 2
a468 1
	if (n == 4)
d478 3
a480 1
	else if (n == 8)
d495 1
a495 1
			bn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);
d498 2
a499 2
		bn_mul_recursive(r,a,b,n,p);
		bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,p);
d548 2
a549 2
void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int tn,
	     int n, BN_ULONG *t)
d556 2
a557 1
	printf(" bn_mul_part_recursive %d * %d\n",tn+n,tn+n);
d561 1
a561 2
		i=tn+n;
		bn_mul_normal(r,a,i,b,i);
d566 2
a567 2
	c1=bn_cmp_words(a,&(a[n]),n);
	c2=bn_cmp_words(&(b[n]),b,n);
d572 2
a573 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d579 2
a580 2
		bn_sub_words(t,      &(a[n]),a,      n); /* - */
		bn_sub_words(&(t[n]),&(b[n]),b,      n); /* + */
d589 2
a590 2
		bn_sub_words(t,      a,      &(a[n]),n); /* + */
		bn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */
d597 2
a598 2
		bn_sub_words(t,      a,      &(a[n]),n);
		bn_sub_words(&(t[n]),&(b[n]),b,      n);
d617 2
a618 2
		bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);
		memset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));
d623 2
a624 2
		bn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);
		bn_mul_recursive(r,a,b,n,p);
d628 4
a631 1
		j=tn-i;
d634 2
a635 1
			bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),i,p);
d641 3
a643 3
					j,i,p);
				memset(&(r[n2+tn*2]),0,
					sizeof(BN_ULONG)*(n2-tn*2));
d648 2
a649 1
			if (tn < BN_MUL_RECURSIVE_SIZE_NORMAL)
d651 1
a651 1
				bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);
d658 1
a658 1
					if (i < tn)
d662 1
a662 1
							tn-i,i,p);
d665 1
a665 1
					else if (i == tn)
d669 1
a669 1
							i,p);
d730 1
a730 1
	printf(" bn_mul_low_recursive %d * %d\n",n2,n2);
d733 1
a733 1
	bn_mul_recursive(r,a,b,n,&(t[0]));
d764 1
a764 1
	printf(" bn_mul_high %d * %d\n",n2,n2);
d817 2
a818 2
		bn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,&(t[n2]));
		bn_mul_recursive(r,&(a[n]),&(b[n]),n,&(t[n2]));
d943 1
a945 1
	int ret = 0;
d950 2
a951 2
	BIGNUM *t;
	int j,k;
d955 1
a955 1
	printf("BN_mul %d * %d\n",a->top,b->top);
d1008 1
a1008 1
		if (i == 1 && !BN_get_flags(b,BN_FLG_STATIC_DATA) && bl<b->dmax)
d1010 39
a1048 4
#if 0	/* tribute to const-ification, bl<b->dmax above covers for this */
			if (bn_wexpand(b,al) == NULL) goto err;
#endif
			b->d[bl]=0;
d1052 1
a1052 1
		else if (i == -1 && !BN_get_flags(a,BN_FLG_STATIC_DATA) && al<a->dmax)
d1054 3
a1056 4
#if 0	/* tribute to const-ification, al<a->dmax above covers for this */
			if (bn_wexpand(a,bl) == NULL) goto err;
#endif
			a->d[al]=0;
a1072 2
				rr->top=top;
				goto end;
a1073 1
#if 0	/* tribute to const-ification, rsa/dsa performance is not affected */
d1076 2
a1077 8
				if (bn_wexpand(a,k) == NULL ) goto err;
				if (bn_wexpand(b,k) == NULL ) goto err;
				if (bn_wexpand(t,k*4) == NULL ) goto err;
				if (bn_wexpand(rr,k*4) == NULL ) goto err;
				for (i=a->top; i<k; i++)
					a->d[i]=0;
				for (i=b->top; i<k; i++)
					b->d[i]=0;
d1082 1
a1083 1
			}
d1106 1
a1106 1
	printf(" bn_mul_normal %d * %d\n",na,nb);
d1119 7
a1125 1
	rr[0]=bn_mul_words(r,a,na,b[0]);
d1146 1
a1146 1
	printf(" bn_mul_low_normal %d * %d\n",n,n);
@


1.1.1.5
log
@import 0.9.7c
@
text
@d227 1
a227 1
	int c1,c2,neg,zero;
d379 1
a379 1
		if (ln < (BN_ULONG)c1)
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@a58 5
#ifndef BN_DEBUG
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
#endif

a59 1
#include <assert.h>
a62 309
#if defined(OPENSSL_NO_ASM) || !defined(OPENSSL_BN_ASM_PART_WORDS)
/* Here follows specialised variants of bn_add_words() and
   bn_sub_words().  They have the property performing operations on
   arrays of different sizes.  The sizes of those arrays is expressed through
   cl, which is the common length ( basicall, min(len(a),len(b)) ), and dl,
   which is the delta between the two lengths, calculated as len(a)-len(b).
   All lengths are the number of BN_ULONGs...  For the operations that require
   a result array as parameter, it must have the length cl+abs(dl).
   These functions should probably end up in bn_asm.c as soon as there are
   assembler counterparts for the systems that use assembler files.  */

BN_ULONG bn_sub_part_words(BN_ULONG *r,
	const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
	{
	BN_ULONG c, t;

	assert(cl >= 0);
	c = bn_sub_words(r, a, b, cl);

	if (dl == 0)
		return c;

	r += cl;
	a += cl;
	b += cl;

	if (dl < 0)
		{
#ifdef BN_COUNT
		fprintf(stderr, "  bn_sub_part_words %d + %d (dl < 0, c = %d)\n", cl, dl, c);
#endif
		for (;;)
			{
			t = b[0];
			r[0] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			t = b[1];
			r[1] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			t = b[2];
			r[2] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			t = b[3];
			r[3] = (0-t-c)&BN_MASK2;
			if (t != 0) c=1;
			if (++dl >= 0) break;

			b += 4;
			r += 4;
			}
		}
	else
		{
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, c = %d)\n", cl, dl, c);
#endif
		while(c)
			{
			t = a[0];
			r[0] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			t = a[1];
			r[1] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			t = a[2];
			r[2] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			t = a[3];
			r[3] = (t-c)&BN_MASK2;
			if (t != 0) c=0;
			if (--dl <= 0) break;

			save_dl = dl;
			a += 4;
			r += 4;
			}
		if (dl > 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, c == 0)\n", cl, dl);
#endif
			if (save_dl > dl)
				{
				switch (save_dl - dl)
					{
				case 1:
					r[1] = a[1];
					if (--dl <= 0) break;
				case 2:
					r[2] = a[2];
					if (--dl <= 0) break;
				case 3:
					r[3] = a[3];
					if (--dl <= 0) break;
					}
				a += 4;
				r += 4;
				}
			}
		if (dl > 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_sub_part_words %d + %d (dl > 0, copy)\n", cl, dl);
#endif
			for(;;)
				{
				r[0] = a[0];
				if (--dl <= 0) break;
				r[1] = a[1];
				if (--dl <= 0) break;
				r[2] = a[2];
				if (--dl <= 0) break;
				r[3] = a[3];
				if (--dl <= 0) break;

				a += 4;
				r += 4;
				}
			}
		}
	return c;
	}
#endif

BN_ULONG bn_add_part_words(BN_ULONG *r,
	const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
	{
	BN_ULONG c, l, t;

	assert(cl >= 0);
	c = bn_add_words(r, a, b, cl);

	if (dl == 0)
		return c;

	r += cl;
	a += cl;
	b += cl;

	if (dl < 0)
		{
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, c = %d)\n", cl, dl, c);
#endif
		while (c)
			{
			l=(c+b[0])&BN_MASK2;
			c=(l < c);
			r[0]=l;
			if (++dl >= 0) break;

			l=(c+b[1])&BN_MASK2;
			c=(l < c);
			r[1]=l;
			if (++dl >= 0) break;

			l=(c+b[2])&BN_MASK2;
			c=(l < c);
			r[2]=l;
			if (++dl >= 0) break;

			l=(c+b[3])&BN_MASK2;
			c=(l < c);
			r[3]=l;
			if (++dl >= 0) break;

			save_dl = dl;
			b+=4;
			r+=4;
			}
		if (dl < 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, c == 0)\n", cl, dl);
#endif
			if (save_dl < dl)
				{
				switch (dl - save_dl)
					{
				case 1:
					r[1] = b[1];
					if (++dl >= 0) break;
				case 2:
					r[2] = b[2];
					if (++dl >= 0) break;
				case 3:
					r[3] = b[3];
					if (++dl >= 0) break;
					}
				b += 4;
				r += 4;
				}
			}
		if (dl < 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_add_part_words %d + %d (dl < 0, copy)\n", cl, dl);
#endif
			for(;;)
				{
				r[0] = b[0];
				if (++dl >= 0) break;
				r[1] = b[1];
				if (++dl >= 0) break;
				r[2] = b[2];
				if (++dl >= 0) break;
				r[3] = b[3];
				if (++dl >= 0) break;

				b += 4;
				r += 4;
				}
			}
		}
	else
		{
		int save_dl = dl;
#ifdef BN_COUNT
		fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0)\n", cl, dl);
#endif
		while (c)
			{
			t=(a[0]+c)&BN_MASK2;
			c=(t < c);
			r[0]=t;
			if (--dl <= 0) break;

			t=(a[1]+c)&BN_MASK2;
			c=(t < c);
			r[1]=t;
			if (--dl <= 0) break;

			t=(a[2]+c)&BN_MASK2;
			c=(t < c);
			r[2]=t;
			if (--dl <= 0) break;

			t=(a[3]+c)&BN_MASK2;
			c=(t < c);
			r[3]=t;
			if (--dl <= 0) break;

			save_dl = dl;
			a+=4;
			r+=4;
			}
#ifdef BN_COUNT
		fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0, c == 0)\n", cl, dl);
#endif
		if (dl > 0)
			{
			if (save_dl > dl)
				{
				switch (save_dl - dl)
					{
				case 1:
					r[1] = a[1];
					if (--dl <= 0) break;
				case 2:
					r[2] = a[2];
					if (--dl <= 0) break;
				case 3:
					r[3] = a[3];
					if (--dl <= 0) break;
					}
				a += 4;
				r += 4;
				}
			}
		if (dl > 0)
			{
#ifdef BN_COUNT
			fprintf(stderr, "  bn_add_part_words %d + %d (dl > 0, copy)\n", cl, dl);
#endif
			for(;;)
				{
				r[0] = a[0];
				if (--dl <= 0) break;
				r[1] = a[1];
				if (--dl <= 0) break;
				r[2] = a[2];
				if (--dl <= 0) break;
				r[3] = a[3];
				if (--dl <= 0) break;

				a += 4;
				r += 4;
				}
			}
		}
	return c;
	}

a76 1
/* dnX may not be positive, but n2/2+dnX has to be */
d78 1
a78 1
	int dna, int dnb, BN_ULONG *t)
a80 1
	int tna=n+dna, tnb=n+dnb;
d85 1
a85 1
	fprintf(stderr," bn_mul_recursive %d%+d * %d%+d\n",n2,dna,n2,dnb);
d95 1
a95 4
	/* Only call bn_mul_comba 8 if n2 == 8 and the
	 * two arrays are complete [steve]
	 */
	if (n2 == 8 && dna == 0 && dnb == 0)
a100 1
	/* Else do normal multiply */
d103 2
a104 4
		bn_mul_normal(r,a,n2+dna,b,n2+dnb);
		if ((dna + dnb) < 0)
			memset(&r[2*n2 + dna + dnb], 0,
				sizeof(BN_ULONG) * -(dna + dnb));
d108 2
a109 2
	c1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);
	c2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);
d114 2
a115 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d121 2
a122 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */
d131 2
a132 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d139 2
a140 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);
d145 1
a145 2
	if (n == 4 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba4 could take
					       extra args to do this well */
d155 1
a155 3
	else if (n == 8 && dna == 0 && dnb == 0) /* XXX: bn_mul_comba8 could
						    take extra args to do this
						    well */
d170 1
a170 1
			bn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);
d173 2
a174 2
		bn_mul_recursive(r,a,b,n,0,0,p);
		bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,dna,dnb,p);
d223 2
a224 3
/* tnX may not be negative but less than n */
void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n,
	     int tna, int tnb, BN_ULONG *t)
d231 1
a231 2
	fprintf(stderr," bn_mul_part_recursive (%d%+d) * (%d%+d)\n",
		n, tna, n, tnb);
d235 2
a236 1
		bn_mul_normal(r,a,n+tna,b,n+tnb);
d241 2
a242 2
	c1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);
	c2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);
d247 2
a248 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d254 2
a255 2
		bn_sub_part_words(t,      &(a[n]),a,      tna,tna-n); /* - */
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n); /* + */
d264 2
a265 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna); /* + */
		bn_sub_part_words(&(t[n]),b,      &(b[n]),tnb,n-tnb); /* - */
d272 2
a273 2
		bn_sub_part_words(t,      a,      &(a[n]),tna,n-tna);
		bn_sub_part_words(&(t[n]),&(b[n]),b,      tnb,tnb-n);
d292 2
a293 2
		bn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);
		memset(&(r[n2+tna+tnb]),0,sizeof(BN_ULONG)*(n2-tna-tnb));
d298 2
a299 2
		bn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);
		bn_mul_recursive(r,a,b,n,0,0,p);
d303 1
a303 4
		if (tna > tnb)
			j = tna - i;
		else
			j = tnb - i;
d306 1
a306 2
			bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),
				i,tna-i,tnb-i,p);
d312 3
a314 3
					i,tna-i,tnb-i,p);
				memset(&(r[n2+tna+tnb]),0,
					sizeof(BN_ULONG)*(n2-tna-tnb));
d319 1
a319 2
			if (tna < BN_MUL_RECURSIVE_SIZE_NORMAL
				&& tnb < BN_MUL_RECURSIVE_SIZE_NORMAL)
d321 1
a321 1
				bn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);
d328 1
a328 4
					/* these simplified conditions work
					 * exclusively because difference
					 * between tna and tnb is 1 or 0 */
					if (i < tna || i < tnb)
d332 1
a332 1
							i,tna-i,tnb-i,p);
d335 1
a335 1
					else if (i == tna || i == tnb)
d339 1
a339 1
							i,tna-i,tnb-i,p);
d400 1
a400 1
	fprintf(stderr," bn_mul_low_recursive %d * %d\n",n2,n2);
d403 1
a403 1
	bn_mul_recursive(r,a,b,n,0,0,&(t[0]));
d434 1
a434 1
	fprintf(stderr," bn_mul_high %d * %d\n",n2,n2);
d487 2
a488 2
		bn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,0,0,&(t[n2]));
		bn_mul_recursive(r,&(a[n]),&(b[n]),n,0,0,&(t[n2]));
a612 1
	int ret=0;
d615 1
d620 2
a621 2
	BIGNUM *t=NULL;
	int j=0,k;
d625 1
a625 1
	fprintf(stderr,"BN_mul %d * %d\n",a->top,b->top);
d637 1
a637 1
		BN_zero(r);
d678 1
a678 1
		if (i >= -1 && i <= 1)
d680 4
a683 39
			int sav_j =0;
			/* Find out the power of two lower or equal
			   to the longest of the two numbers */
			if (i >= 0)
				{
				j = BN_num_bits_word((BN_ULONG)al);
				}
			if (i == -1)
				{
				j = BN_num_bits_word((BN_ULONG)bl);
				}
			sav_j = j;
			j = 1<<(j-1);
			assert(j <= al || j <= bl);
			k = j+j;
			t = BN_CTX_get(ctx);
			if (al > j || bl > j)
				{
				bn_wexpand(t,k*4);
				bn_wexpand(rr,k*4);
				bn_mul_part_recursive(rr->d,a->d,b->d,
					j,al-j,bl-j,t->d);
				}
			else	/* al <= j || bl <= j */
				{
				bn_wexpand(t,k*2);
				bn_wexpand(rr,k*2);
				bn_mul_recursive(rr->d,a->d,b->d,
					j,al-j,bl-j,t->d);
				}
			rr->top=top;
			goto end;
			}
#if 0
		if (i == 1 && !BN_get_flags(b,BN_FLG_STATIC_DATA))
			{
			BIGNUM *tmp_bn = (BIGNUM *)b;
			if (bn_wexpand(tmp_bn,al) == NULL) goto err;
			tmp_bn->d[bl]=0;
d687 1
a687 1
		else if (i == -1 && !BN_get_flags(a,BN_FLG_STATIC_DATA))
d689 4
a692 3
			BIGNUM *tmp_bn = (BIGNUM *)a;
			if (bn_wexpand(tmp_bn,bl) == NULL) goto err;
			tmp_bn->d[al]=0;
d709 2
d712 1
d715 8
a722 2
				if (bn_wexpand(t,k*4) == NULL) goto err;
				if (bn_wexpand(rr,k*4) == NULL) goto err;
d727 1
a728 1
#endif
d738 1
a738 1
	bn_correct_top(rr);
a741 1
	bn_check_top(r);
d751 1
a751 1
	fprintf(stderr," bn_mul_normal %d * %d\n",na,nb);
d764 1
a764 7
	if (nb <= 0)
		{
		(void)bn_mul_words(r,a,na,0);
		return;
		}
	else
		rr[0]=bn_mul_words(r,a,na,b[0]);
d785 1
a785 1
	fprintf(stderr," bn_mul_low_normal %d * %d\n",n,n);
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@a1030 2
			if (t == NULL)
				goto err;
d1033 2
a1034 2
				if (bn_wexpand(t,k*4) == NULL) goto err;
				if (bn_wexpand(rr,k*4) == NULL) goto err;
d1040 2
a1041 2
				if (bn_wexpand(t,k*2) == NULL) goto err;
				if (bn_wexpand(rr,k*2) == NULL) goto err;
@


1.1.1.8
log
@import OpenSSL 1.0.0e
@
text
@d554 1
a554 1
	int c1,c2,neg;
d570 1
a570 1
	neg=0;
d578 1
d588 1
d596 1
d1015 1
d1026 1
@


