head	1.15;
access;
symbols
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14;
locks; strict;
comment	@ * @;


1.15
date	2017.05.02.03.59.44;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Dm63V7JYy6WzetfM;

1.14
date	2015.02.25.15.39.49;	author bcook;	state Exp;
branches;
next	1.13;
commitid	nC7C8zA8FXXV2GZG;

1.13
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.12;
commitid	yQEL1wOWIearrW15;

1.12
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.11;
commitid	nzndm3zqPmFurSaK;

1.11
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	mJUVYpkFBZ0Zv2bG;

1.10
date	2014.05.23.16.11.55;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2014.05.08.13.20.49;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2014.05.01.20.40.55;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.57.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.09.16;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.35.43;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.57;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.27.05.05.31;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@use freezero() instead of memset/explicit_bzero + free.  Substantially
reduces conditional logic (-218, +82).

MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH cache alignment calculation bn/bn_exp.c
wasn'tt quite right.  Two other tricky bits with ASN1_STRING_FLAG_NDEF and
BN_FLG_STATIC_DATA where the condition cannot be collapsed completely.

Passes regress.  ok beck
@
text
@/* $OpenBSD: bn_asm.c,v 1.14 2015/02/25 15:39:49 bcook Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#ifndef BN_DEBUG
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
#endif

#include <assert.h>
#include <stdio.h>

#include <openssl/opensslconf.h>

#include "bn_lcl.h"

#if defined(BN_LLONG) || defined(BN_UMULT_HIGH)

BN_ULONG
bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
{
	BN_ULONG c1 = 0;

	assert(num >= 0);
	if (num <= 0)
		return (c1);

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (num & ~3) {
		mul_add(rp[0], ap[0], w, c1);
		mul_add(rp[1], ap[1], w, c1);
		mul_add(rp[2], ap[2], w, c1);
		mul_add(rp[3], ap[3], w, c1);
		ap += 4;
		rp += 4;
		num -= 4;
	}
#endif
	while (num) {
		mul_add(rp[0], ap[0], w, c1);
		ap++;
		rp++;
		num--;
	}

	return (c1);
}

BN_ULONG
bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
{
	BN_ULONG c1 = 0;

	assert(num >= 0);
	if (num <= 0)
		return (c1);

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (num & ~3) {
		mul(rp[0], ap[0], w, c1);
		mul(rp[1], ap[1], w, c1);
		mul(rp[2], ap[2], w, c1);
		mul(rp[3], ap[3], w, c1);
		ap += 4;
		rp += 4;
		num -= 4;
	}
#endif
	while (num) {
		mul(rp[0], ap[0], w, c1);
		ap++;
		rp++;
		num--;
	}
	return (c1);
}

void
bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)
{
	assert(n >= 0);
	if (n <= 0)
		return;

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (n & ~3) {
		sqr(r[0], r[1], a[0]);
		sqr(r[2], r[3], a[1]);
		sqr(r[4], r[5], a[2]);
		sqr(r[6], r[7], a[3]);
		a += 4;
		r += 8;
		n -= 4;
	}
#endif
	while (n) {
		sqr(r[0], r[1], a[0]);
		a++;
		r += 2;
		n--;
	}
}

#else /* !(defined(BN_LLONG) || defined(BN_UMULT_HIGH)) */

BN_ULONG
bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
{
	BN_ULONG c = 0;
	BN_ULONG bl, bh;

	assert(num >= 0);
	if (num <= 0)
		return ((BN_ULONG)0);

	bl = LBITS(w);
	bh = HBITS(w);

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (num & ~3) {
		mul_add(rp[0], ap[0], bl, bh, c);
		mul_add(rp[1], ap[1], bl, bh, c);
		mul_add(rp[2], ap[2], bl, bh, c);
		mul_add(rp[3], ap[3], bl, bh, c);
		ap += 4;
		rp += 4;
		num -= 4;
	}
#endif
	while (num) {
		mul_add(rp[0], ap[0], bl, bh, c);
		ap++;
		rp++;
		num--;
	}
	return (c);
}

BN_ULONG
bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
{
	BN_ULONG carry = 0;
	BN_ULONG bl, bh;

	assert(num >= 0);
	if (num <= 0)
		return ((BN_ULONG)0);

	bl = LBITS(w);
	bh = HBITS(w);

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (num & ~3) {
		mul(rp[0], ap[0], bl, bh, carry);
		mul(rp[1], ap[1], bl, bh, carry);
		mul(rp[2], ap[2], bl, bh, carry);
		mul(rp[3], ap[3], bl, bh, carry);
		ap += 4;
		rp += 4;
		num -= 4;
	}
#endif
	while (num) {
		mul(rp[0], ap[0], bl, bh, carry);
		ap++;
		rp++;
		num--;
	}
	return (carry);
}

void
bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)
{
	assert(n >= 0);
	if (n <= 0)
		return;

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (n & ~3) {
		sqr64(r[0], r[1], a[0]);
		sqr64(r[2], r[3], a[1]);
		sqr64(r[4], r[5], a[2]);
		sqr64(r[6], r[7], a[3]);
		a += 4;
		r += 8;
		n -= 4;
	}
#endif
	while (n) {
		sqr64(r[0], r[1], a[0]);
		a++;
		r += 2;
		n--;
	}
}

#endif /* !(defined(BN_LLONG) || defined(BN_UMULT_HIGH)) */

#if defined(BN_LLONG) && defined(BN_DIV2W)

BN_ULONG
bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)
{
	return ((BN_ULONG)(((((BN_ULLONG)h) << BN_BITS2)|l)/(BN_ULLONG)d));
}

#else

/* Divide h,l by d and return the result. */
/* I need to test this some more :-( */
BN_ULONG
bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)
{
	BN_ULONG dh, dl, q,ret = 0, th, tl, t;
	int i, count = 2;

	if (d == 0)
		return (BN_MASK2);

	i = BN_num_bits_word(d);
	assert((i == BN_BITS2) || (h <= (BN_ULONG)1 << i));

	i = BN_BITS2 - i;
	if (h >= d)
		h -= d;

	if (i) {
		d <<= i;
		h = (h << i) | (l >> (BN_BITS2 - i));
		l <<= i;
	}
	dh = (d & BN_MASK2h) >> BN_BITS4;
	dl = (d & BN_MASK2l);
	for (;;) {
		if ((h >> BN_BITS4) == dh)
			q = BN_MASK2l;
		else
			q = h / dh;

		th = q * dh;
		tl = dl * q;
		for (;;) {
			t = h - th;
			if ((t & BN_MASK2h) ||
			    ((tl) <= (
			    (t << BN_BITS4) |
			    ((l & BN_MASK2h) >> BN_BITS4))))
				break;
			q--;
			th -= dh;
			tl -= dl;
		}
		t = (tl >> BN_BITS4);
		tl = (tl << BN_BITS4) & BN_MASK2h;
		th += t;

		if (l < tl)
			th++;
		l -= tl;
		if (h < th) {
			h += d;
			q--;
		}
		h -= th;

		if (--count == 0)
			break;

		ret = q << BN_BITS4;
		h = ((h << BN_BITS4) | (l >> BN_BITS4)) & BN_MASK2;
		l = (l & BN_MASK2l) << BN_BITS4;
	}
	ret |= q;
	return (ret);
}
#endif /* !defined(BN_LLONG) && defined(BN_DIV2W) */

#ifdef BN_LLONG
BN_ULONG
bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)
{
	BN_ULLONG ll = 0;

	assert(n >= 0);
	if (n <= 0)
		return ((BN_ULONG)0);

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (n & ~3) {
		ll += (BN_ULLONG)a[0] + b[0];
		r[0] = (BN_ULONG)ll & BN_MASK2;
		ll >>= BN_BITS2;
		ll += (BN_ULLONG)a[1] + b[1];
		r[1] = (BN_ULONG)ll & BN_MASK2;
		ll >>= BN_BITS2;
		ll += (BN_ULLONG)a[2] + b[2];
		r[2] = (BN_ULONG)ll & BN_MASK2;
		ll >>= BN_BITS2;
		ll += (BN_ULLONG)a[3] + b[3];
		r[3] = (BN_ULONG)ll & BN_MASK2;
		ll >>= BN_BITS2;
		a += 4;
		b += 4;
		r += 4;
		n -= 4;
	}
#endif
	while (n) {
		ll += (BN_ULLONG)a[0] + b[0];
		r[0] = (BN_ULONG)ll & BN_MASK2;
		ll >>= BN_BITS2;
		a++;
		b++;
		r++;
		n--;
	}
	return ((BN_ULONG)ll);
}
#else /* !BN_LLONG */
BN_ULONG
bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)
{
	BN_ULONG c, l, t;

	assert(n >= 0);
	if (n <= 0)
		return ((BN_ULONG)0);

	c = 0;
#ifndef OPENSSL_SMALL_FOOTPRINT
	while (n & ~3) {
		t = a[0];
		t = (t + c) & BN_MASK2;
		c = (t < c);
		l = (t + b[0]) & BN_MASK2;
		c += (l < t);
		r[0] = l;
		t = a[1];
		t = (t + c) & BN_MASK2;
		c = (t < c);
		l = (t + b[1]) & BN_MASK2;
		c += (l < t);
		r[1] = l;
		t = a[2];
		t = (t + c) & BN_MASK2;
		c = (t < c);
		l = (t + b[2]) & BN_MASK2;
		c += (l < t);
		r[2] = l;
		t = a[3];
		t = (t + c) & BN_MASK2;
		c = (t < c);
		l = (t + b[3]) & BN_MASK2;
		c += (l < t);
		r[3] = l;
		a += 4;
		b += 4;
		r += 4;
		n -= 4;
	}
#endif
	while (n) {
		t = a[0];
		t = (t + c) & BN_MASK2;
		c = (t < c);
		l = (t + b[0]) & BN_MASK2;
		c += (l < t);
		r[0] = l;
		a++;
		b++;
		r++;
		n--;
	}
	return ((BN_ULONG)c);
}
#endif /* !BN_LLONG */

BN_ULONG
bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)
{
	BN_ULONG t1, t2;
	int c = 0;

	assert(n >= 0);
	if (n <= 0)
		return ((BN_ULONG)0);

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (n&~3) {
		t1 = a[0];
		t2 = b[0];
		r[0] = (t1 - t2 - c) & BN_MASK2;
		if (t1 != t2)
			c = (t1 < t2);
		t1 = a[1];
		t2 = b[1];
		r[1] = (t1 - t2 - c) & BN_MASK2;
		if (t1 != t2)
			c = (t1 < t2);
		t1 = a[2];
		t2 = b[2];
		r[2] = (t1 - t2 - c) & BN_MASK2;
		if (t1 != t2)
			c = (t1 < t2);
		t1 = a[3];
		t2 = b[3];
		r[3] = (t1 - t2 - c) & BN_MASK2;
		if (t1 != t2)
			c = (t1 < t2);
		a += 4;
		b += 4;
		r += 4;
		n -= 4;
	}
#endif
	while (n) {
		t1 = a[0];
		t2 = b[0];
		r[0] = (t1 - t2 - c) & BN_MASK2;
		if (t1 != t2)
			c = (t1 < t2);
		a++;
		b++;
		r++;
		n--;
	}
	return (c);
}

#if defined(BN_MUL_COMBA) && !defined(OPENSSL_SMALL_FOOTPRINT)

#undef bn_mul_comba8
#undef bn_mul_comba4
#undef bn_sqr_comba8
#undef bn_sqr_comba4

/* mul_add_c(a,b,c0,c1,c2)  -- c+=a*b for three word number c=(c2,c1,c0) */
/* mul_add_c2(a,b,c0,c1,c2) -- c+=2*a*b for three word number c=(c2,c1,c0) */
/* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */
/* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */

#ifdef BN_LLONG
/*
 * Keep in mind that additions to multiplication result can not
 * overflow, because its high half cannot be all-ones.
 */
#define mul_add_c(a,b,c0,c1,c2)		do {	\
	BN_ULONG hi;				\
	BN_ULLONG t = (BN_ULLONG)(a)*(b);	\
	t += c0;		/* no carry */	\
	c0 = (BN_ULONG)Lw(t);			\
	hi = (BN_ULONG)Hw(t);			\
	c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;	\
	} while(0)

#define mul_add_c2(a,b,c0,c1,c2)	do {	\
	BN_ULONG hi;				\
	BN_ULLONG t = (BN_ULLONG)(a)*(b);	\
	BN_ULLONG tt = t+c0;	/* no carry */	\
	c0 = (BN_ULONG)Lw(tt);			\
	hi = (BN_ULONG)Hw(tt);			\
	c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;	\
	t += c0;		/* no carry */	\
	c0 = (BN_ULONG)Lw(t);			\
	hi = (BN_ULONG)Hw(t);			\
	c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;	\
	} while(0)

#define sqr_add_c(a,i,c0,c1,c2)		do {	\
	BN_ULONG hi;				\
	BN_ULLONG t = (BN_ULLONG)a[i]*a[i];	\
	t += c0;		/* no carry */	\
	c0 = (BN_ULONG)Lw(t);			\
	hi = (BN_ULONG)Hw(t);			\
	c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;	\
	} while(0)

#define sqr_add_c2(a,i,j,c0,c1,c2) \
	mul_add_c2((a)[i],(a)[j],c0,c1,c2)

#elif defined(BN_UMULT_LOHI)
/*
 * Keep in mind that additions to hi can not overflow, because
 * the high word of a multiplication result cannot be all-ones.
 */
#define mul_add_c(a,b,c0,c1,c2)		do {	\
	BN_ULONG ta = (a), tb = (b);		\
	BN_ULONG lo, hi;			\
	BN_UMULT_LOHI(lo,hi,ta,tb);		\
	c0 += lo; hi += (c0<lo)?1:0;		\
	c1 += hi; c2 += (c1<hi)?1:0;		\
	} while(0)

#define mul_add_c2(a,b,c0,c1,c2)	do {	\
	BN_ULONG ta = (a), tb = (b);		\
	BN_ULONG lo, hi, tt;			\
	BN_UMULT_LOHI(lo,hi,ta,tb);		\
	c0 += lo; tt = hi+((c0<lo)?1:0);	\
	c1 += tt; c2 += (c1<tt)?1:0;		\
	c0 += lo; hi += (c0<lo)?1:0;		\
	c1 += hi; c2 += (c1<hi)?1:0;		\
	} while(0)

#define sqr_add_c(a,i,c0,c1,c2)		do {	\
	BN_ULONG ta = (a)[i];			\
	BN_ULONG lo, hi;			\
	BN_UMULT_LOHI(lo,hi,ta,ta);		\
	c0 += lo; hi += (c0<lo)?1:0;		\
	c1 += hi; c2 += (c1<hi)?1:0;		\
	} while(0)

#define sqr_add_c2(a,i,j,c0,c1,c2)	\
	mul_add_c2((a)[i],(a)[j],c0,c1,c2)

#elif defined(BN_UMULT_HIGH)
/*
 * Keep in mind that additions to hi can not overflow, because
 * the high word of a multiplication result cannot be all-ones.
 */
#define mul_add_c(a,b,c0,c1,c2)		do {	\
	BN_ULONG ta = (a), tb = (b);		\
	BN_ULONG lo = ta * tb;			\
	BN_ULONG hi = BN_UMULT_HIGH(ta,tb);	\
	c0 += lo; hi += (c0<lo)?1:0;		\
	c1 += hi; c2 += (c1<hi)?1:0;		\
	} while(0)

#define mul_add_c2(a,b,c0,c1,c2)	do {	\
	BN_ULONG ta = (a), tb = (b), tt;	\
	BN_ULONG lo = ta * tb;			\
	BN_ULONG hi = BN_UMULT_HIGH(ta,tb);	\
	c0 += lo; tt = hi + ((c0<lo)?1:0);	\
	c1 += tt; c2 += (c1<tt)?1:0;		\
	c0 += lo; hi += (c0<lo)?1:0;		\
	c1 += hi; c2 += (c1<hi)?1:0;		\
	} while(0)

#define sqr_add_c(a,i,c0,c1,c2)		do {	\
	BN_ULONG ta = (a)[i];			\
	BN_ULONG lo = ta * ta;			\
	BN_ULONG hi = BN_UMULT_HIGH(ta,ta);	\
	c0 += lo; hi += (c0<lo)?1:0;		\
	c1 += hi; c2 += (c1<hi)?1:0;		\
	} while(0)

#define sqr_add_c2(a,i,j,c0,c1,c2)	\
	mul_add_c2((a)[i],(a)[j],c0,c1,c2)

#else /* !BN_LLONG */
/*
 * Keep in mind that additions to hi can not overflow, because
 * the high word of a multiplication result cannot be all-ones.
 */
#define mul_add_c(a,b,c0,c1,c2)		do {	\
	BN_ULONG lo = LBITS(a), hi = HBITS(a);	\
	BN_ULONG bl = LBITS(b), bh = HBITS(b);	\
	mul64(lo,hi,bl,bh);			\
	c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;	\
	c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;	\
	} while(0)

#define mul_add_c2(a,b,c0,c1,c2)	do {	\
	BN_ULONG tt;				\
	BN_ULONG lo = LBITS(a), hi = HBITS(a);	\
	BN_ULONG bl = LBITS(b), bh = HBITS(b);	\
	mul64(lo,hi,bl,bh);			\
	tt = hi;				\
	c0 = (c0+lo)&BN_MASK2; if (c0<lo) tt++;	\
	c1 = (c1+tt)&BN_MASK2; if (c1<tt) c2++;	\
	c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;	\
	c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;	\
	} while(0)

#define sqr_add_c(a,i,c0,c1,c2)		do {	\
	BN_ULONG lo, hi;			\
	sqr64(lo,hi,(a)[i]);			\
	c0 = (c0+lo)&BN_MASK2; if (c0<lo) hi++;	\
	c1 = (c1+hi)&BN_MASK2; if (c1<hi) c2++;	\
	} while(0)

#define sqr_add_c2(a,i,j,c0,c1,c2) \
	mul_add_c2((a)[i],(a)[j],c0,c1,c2)
#endif /* !BN_LLONG */

void
bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
{
	BN_ULONG c1, c2, c3;

	c1 = 0;
	c2 = 0;
	c3 = 0;
	mul_add_c(a[0], b[0], c1, c2, c3);
	r[0] = c1;
	c1 = 0;
	mul_add_c(a[0], b[1], c2, c3, c1);
	mul_add_c(a[1], b[0], c2, c3, c1);
	r[1] = c2;
	c2 = 0;
	mul_add_c(a[2], b[0], c3, c1, c2);
	mul_add_c(a[1], b[1], c3, c1, c2);
	mul_add_c(a[0], b[2], c3, c1, c2);
	r[2] = c3;
	c3 = 0;
	mul_add_c(a[0], b[3], c1, c2, c3);
	mul_add_c(a[1], b[2], c1, c2, c3);
	mul_add_c(a[2], b[1], c1, c2, c3);
	mul_add_c(a[3], b[0], c1, c2, c3);
	r[3] = c1;
	c1 = 0;
	mul_add_c(a[4], b[0], c2, c3, c1);
	mul_add_c(a[3], b[1], c2, c3, c1);
	mul_add_c(a[2], b[2], c2, c3, c1);
	mul_add_c(a[1], b[3], c2, c3, c1);
	mul_add_c(a[0], b[4], c2, c3, c1);
	r[4] = c2;
	c2 = 0;
	mul_add_c(a[0], b[5], c3, c1, c2);
	mul_add_c(a[1], b[4], c3, c1, c2);
	mul_add_c(a[2], b[3], c3, c1, c2);
	mul_add_c(a[3], b[2], c3, c1, c2);
	mul_add_c(a[4], b[1], c3, c1, c2);
	mul_add_c(a[5], b[0], c3, c1, c2);
	r[5] = c3;
	c3 = 0;
	mul_add_c(a[6], b[0], c1, c2, c3);
	mul_add_c(a[5], b[1], c1, c2, c3);
	mul_add_c(a[4], b[2], c1, c2, c3);
	mul_add_c(a[3], b[3], c1, c2, c3);
	mul_add_c(a[2], b[4], c1, c2, c3);
	mul_add_c(a[1], b[5], c1, c2, c3);
	mul_add_c(a[0], b[6], c1, c2, c3);
	r[6] = c1;
	c1 = 0;
	mul_add_c(a[0], b[7], c2, c3, c1);
	mul_add_c(a[1], b[6], c2, c3, c1);
	mul_add_c(a[2], b[5], c2, c3, c1);
	mul_add_c(a[3], b[4], c2, c3, c1);
	mul_add_c(a[4], b[3], c2, c3, c1);
	mul_add_c(a[5], b[2], c2, c3, c1);
	mul_add_c(a[6], b[1], c2, c3, c1);
	mul_add_c(a[7], b[0], c2, c3, c1);
	r[7] = c2;
	c2 = 0;
	mul_add_c(a[7], b[1], c3, c1, c2);
	mul_add_c(a[6], b[2], c3, c1, c2);
	mul_add_c(a[5], b[3], c3, c1, c2);
	mul_add_c(a[4], b[4], c3, c1, c2);
	mul_add_c(a[3], b[5], c3, c1, c2);
	mul_add_c(a[2], b[6], c3, c1, c2);
	mul_add_c(a[1], b[7], c3, c1, c2);
	r[8] = c3;
	c3 = 0;
	mul_add_c(a[2], b[7], c1, c2, c3);
	mul_add_c(a[3], b[6], c1, c2, c3);
	mul_add_c(a[4], b[5], c1, c2, c3);
	mul_add_c(a[5], b[4], c1, c2, c3);
	mul_add_c(a[6], b[3], c1, c2, c3);
	mul_add_c(a[7], b[2], c1, c2, c3);
	r[9] = c1;
	c1 = 0;
	mul_add_c(a[7], b[3], c2, c3, c1);
	mul_add_c(a[6], b[4], c2, c3, c1);
	mul_add_c(a[5], b[5], c2, c3, c1);
	mul_add_c(a[4], b[6], c2, c3, c1);
	mul_add_c(a[3], b[7], c2, c3, c1);
	r[10] = c2;
	c2 = 0;
	mul_add_c(a[4], b[7], c3, c1, c2);
	mul_add_c(a[5], b[6], c3, c1, c2);
	mul_add_c(a[6], b[5], c3, c1, c2);
	mul_add_c(a[7], b[4], c3, c1, c2);
	r[11] = c3;
	c3 = 0;
	mul_add_c(a[7], b[5], c1, c2, c3);
	mul_add_c(a[6], b[6], c1, c2, c3);
	mul_add_c(a[5], b[7], c1, c2, c3);
	r[12] = c1;
	c1 = 0;
	mul_add_c(a[6], b[7], c2, c3, c1);
	mul_add_c(a[7], b[6], c2, c3, c1);
	r[13] = c2;
	c2 = 0;
	mul_add_c(a[7], b[7], c3, c1, c2);
	r[14] = c3;
	r[15] = c1;
}

void
bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
{
	BN_ULONG c1, c2, c3;

	c1 = 0;
	c2 = 0;
	c3 = 0;
	mul_add_c(a[0], b[0], c1, c2, c3);
	r[0] = c1;
	c1 = 0;
	mul_add_c(a[0], b[1], c2, c3, c1);
	mul_add_c(a[1], b[0], c2, c3, c1);
	r[1] = c2;
	c2 = 0;
	mul_add_c(a[2], b[0], c3, c1, c2);
	mul_add_c(a[1], b[1], c3, c1, c2);
	mul_add_c(a[0], b[2], c3, c1, c2);
	r[2] = c3;
	c3 = 0;
	mul_add_c(a[0], b[3], c1, c2, c3);
	mul_add_c(a[1], b[2], c1, c2, c3);
	mul_add_c(a[2], b[1], c1, c2, c3);
	mul_add_c(a[3], b[0], c1, c2, c3);
	r[3] = c1;
	c1 = 0;
	mul_add_c(a[3], b[1], c2, c3, c1);
	mul_add_c(a[2], b[2], c2, c3, c1);
	mul_add_c(a[1], b[3], c2, c3, c1);
	r[4] = c2;
	c2 = 0;
	mul_add_c(a[2], b[3], c3, c1, c2);
	mul_add_c(a[3], b[2], c3, c1, c2);
	r[5] = c3;
	c3 = 0;
	mul_add_c(a[3], b[3], c1, c2, c3);
	r[6] = c1;
	r[7] = c2;
}

void
bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
{
	BN_ULONG c1, c2, c3;

	c1 = 0;
	c2 = 0;
	c3 = 0;
	sqr_add_c(a, 0, c1, c2, c3);
	r[0] = c1;
	c1 = 0;
	sqr_add_c2(a, 1, 0, c2, c3, c1);
	r[1] = c2;
	c2 = 0;
	sqr_add_c(a, 1, c3, c1, c2);
	sqr_add_c2(a, 2, 0, c3, c1, c2);
	r[2] = c3;
	c3 = 0;
	sqr_add_c2(a, 3, 0, c1, c2, c3);
	sqr_add_c2(a, 2, 1, c1, c2, c3);
	r[3] = c1;
	c1 = 0;
	sqr_add_c(a, 2, c2, c3, c1);
	sqr_add_c2(a, 3, 1, c2, c3, c1);
	sqr_add_c2(a, 4, 0, c2, c3, c1);
	r[4] = c2;
	c2 = 0;
	sqr_add_c2(a, 5, 0, c3, c1, c2);
	sqr_add_c2(a, 4, 1, c3, c1, c2);
	sqr_add_c2(a, 3, 2, c3, c1, c2);
	r[5] = c3;
	c3 = 0;
	sqr_add_c(a, 3, c1, c2, c3);
	sqr_add_c2(a, 4, 2, c1, c2, c3);
	sqr_add_c2(a, 5, 1, c1, c2, c3);
	sqr_add_c2(a, 6, 0, c1, c2, c3);
	r[6] = c1;
	c1 = 0;
	sqr_add_c2(a, 7, 0, c2, c3, c1);
	sqr_add_c2(a, 6, 1, c2, c3, c1);
	sqr_add_c2(a, 5, 2, c2, c3, c1);
	sqr_add_c2(a, 4, 3, c2, c3, c1);
	r[7] = c2;
	c2 = 0;
	sqr_add_c(a, 4, c3, c1, c2);
	sqr_add_c2(a, 5, 3, c3, c1, c2);
	sqr_add_c2(a, 6, 2, c3, c1, c2);
	sqr_add_c2(a, 7, 1, c3, c1, c2);
	r[8] = c3;
	c3 = 0;
	sqr_add_c2(a, 7, 2, c1, c2, c3);
	sqr_add_c2(a, 6, 3, c1, c2, c3);
	sqr_add_c2(a, 5, 4, c1, c2, c3);
	r[9] = c1;
	c1 = 0;
	sqr_add_c(a, 5, c2, c3, c1);
	sqr_add_c2(a, 6, 4, c2, c3, c1);
	sqr_add_c2(a, 7, 3, c2, c3, c1);
	r[10] = c2;
	c2 = 0;
	sqr_add_c2(a, 7, 4, c3, c1, c2);
	sqr_add_c2(a, 6, 5, c3, c1, c2);
	r[11] = c3;
	c3 = 0;
	sqr_add_c(a, 6, c1, c2, c3);
	sqr_add_c2(a, 7, 5, c1, c2, c3);
	r[12] = c1;
	c1 = 0;
	sqr_add_c2(a, 7, 6, c2, c3, c1);
	r[13] = c2;
	c2 = 0;
	sqr_add_c(a, 7, c3, c1, c2);
	r[14] = c3;
	r[15] = c1;
}

void
bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
{
	BN_ULONG c1, c2, c3;

	c1 = 0;
	c2 = 0;
	c3 = 0;
	sqr_add_c(a, 0, c1, c2, c3);
	r[0] = c1;
	c1 = 0;
	sqr_add_c2(a, 1, 0, c2, c3, c1);
	r[1] = c2;
	c2 = 0;
	sqr_add_c(a, 1, c3, c1, c2);
	sqr_add_c2(a, 2, 0, c3, c1, c2);
	r[2] = c3;
	c3 = 0;
	sqr_add_c2(a, 3, 0, c1, c2, c3);
	sqr_add_c2(a, 2, 1, c1, c2, c3);
	r[3] = c1;
	c1 = 0;
	sqr_add_c(a, 2, c2, c3, c1);
	sqr_add_c2(a, 3, 1, c2, c3, c1);
	r[4] = c2;
	c2 = 0;
	sqr_add_c2(a, 3, 2, c3, c1, c2);
	r[5] = c3;
	c3 = 0;
	sqr_add_c(a, 3, c1, c2, c3);
	r[6] = c1;
	r[7] = c2;
}

#ifdef OPENSSL_NO_ASM
#ifdef OPENSSL_BN_ASM_MONT
/*
 * This is essentially reference implementation, which may or may not
 * result in performance improvement. E.g. on IA-32 this routine was
 * observed to give 40% faster rsa1024 private key operations and 10%
 * faster rsa4096 ones, while on AMD64 it improves rsa1024 sign only
 * by 10% and *worsens* rsa4096 sign by 15%. Once again, it's a
 * reference implementation, one to be used as starting point for
 * platform-specific assembler. Mentioned numbers apply to compiler
 * generated code compiled with and without -DOPENSSL_BN_ASM_MONT and
 * can vary not only from platform to platform, but even for compiler
 * versions. Assembler vs. assembler improvement coefficients can
 * [and are known to] differ and are to be documented elsewhere.
 */
int
bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np, const BN_ULONG *n0p, int num)
{
	BN_ULONG c0, c1, ml, *tp, n0;
#ifdef mul64
	BN_ULONG mh;
#endif
	int i = 0, j;

#if 0	/* template for platform-specific implementation */
	if (ap == bp)
		return bn_sqr_mont(rp, ap, np, n0p, num);
#endif
	tp = reallocarray(NULL, num + 2, sizeof(BN_ULONG));
	if (tp == NULL)
		return 0;

	n0 = *n0p;

	c0 = 0;
	ml = bp[0];
#ifdef mul64
	mh = HBITS(ml);
	ml = LBITS(ml);
	for (j = 0; j < num; ++j)
		mul(tp[j], ap[j], ml, mh, c0);
#else
	for (j = 0; j < num; ++j)
		mul(tp[j], ap[j], ml, c0);
#endif

	tp[num] = c0;
	tp[num + 1] = 0;
	goto enter;

	for (i = 0; i < num; i++) {
		c0 = 0;
		ml = bp[i];
#ifdef mul64
		mh = HBITS(ml);
		ml = LBITS(ml);
		for (j = 0; j < num; ++j)
			mul_add(tp[j], ap[j], ml, mh, c0);
#else
		for (j = 0; j < num; ++j)
			mul_add(tp[j], ap[j], ml, c0);
#endif
		c1 = (tp[num] + c0) & BN_MASK2;
		tp[num] = c1;
		tp[num + 1] = (c1 < c0 ? 1 : 0);
enter:
		c1 = tp[0];
		ml = (c1 * n0) & BN_MASK2;
		c0 = 0;
#ifdef mul64
		mh = HBITS(ml);
		ml = LBITS(ml);
		mul_add(c1, np[0], ml, mh, c0);
#else
		mul_add(c1, ml, np[0], c0);
#endif
		for (j = 1; j < num; j++) {
			c1 = tp[j];
#ifdef mul64
			mul_add(c1, np[j], ml, mh, c0);
#else
			mul_add(c1, ml, np[j], c0);
#endif
			tp[j - 1] = c1 & BN_MASK2;
		}
		c1 = (tp[num] + c0) & BN_MASK2;
		tp[num - 1] = c1;
		tp[num] = tp[num + 1] + (c1 < c0 ? 1 : 0);
	}

	if (tp[num] != 0 || tp[num - 1] >= np[num - 1]) {
		c0 = bn_sub_words(rp, tp, np, num);
		if (tp[num] != 0 || c0 == 0) {
			goto out;
		}
	}
	memcpy(rp, tp, num * sizeof(BN_ULONG));
out:
	freezero(tp, (num + 2) * sizeof(BN_ULONG));
	return 1;
}
#else
/*
 * Return value of 0 indicates that multiplication/convolution was not
 * performed to signal the caller to fall down to alternative/original
 * code-path.
 */
int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np, const BN_ULONG *n0, int num)
	{	return 0;
}
#endif /* OPENSSL_BN_ASM_MONT */
#endif

#else /* !BN_MUL_COMBA */

/* hmm... is it faster just to do a multiply? */
#undef bn_sqr_comba4
void
bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
{
	BN_ULONG t[8];
	bn_sqr_normal(r, a, 4, t);
}

#undef bn_sqr_comba8
void
bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
{
	BN_ULONG t[16];
	bn_sqr_normal(r, a, 8, t);
}

void
bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
{
	r[4] = bn_mul_words(&(r[0]), a, 4, b[0]);
	r[5] = bn_mul_add_words(&(r[1]), a, 4, b[1]);
	r[6] = bn_mul_add_words(&(r[2]), a, 4, b[2]);
	r[7] = bn_mul_add_words(&(r[3]), a, 4, b[3]);
}

void
bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
{
	r[8] = bn_mul_words(&(r[0]), a, 8, b[0]);
	r[9] = bn_mul_add_words(&(r[1]), a, 8, b[1]);
	r[10] = bn_mul_add_words(&(r[2]), a, 8, b[2]);
	r[11] = bn_mul_add_words(&(r[3]), a, 8, b[3]);
	r[12] = bn_mul_add_words(&(r[4]), a, 8, b[4]);
	r[13] = bn_mul_add_words(&(r[5]), a, 8, b[5]);
	r[14] = bn_mul_add_words(&(r[6]), a, 8, b[6]);
	r[15] = bn_mul_add_words(&(r[7]), a, 8, b[7]);
}

#ifdef OPENSSL_NO_ASM
#ifdef OPENSSL_BN_ASM_MONT
int
bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
    const BN_ULONG *np, const BN_ULONG *n0p, int num)
{
	BN_ULONG c0, c1, *tp, n0 = *n0p;
	int i = 0, j;

	tp = calloc(NULL, num + 2, sizeof(BN_ULONG));
	if (tp == NULL)
		return 0;

	for (i = 0; i < num; i++) {
		c0 = bn_mul_add_words(tp, ap, num, bp[i]);
		c1 = (tp[num] + c0) & BN_MASK2;
		tp[num] = c1;
		tp[num + 1] = (c1 < c0 ? 1 : 0);

		c0 = bn_mul_add_words(tp, np, num, tp[0] * n0);
		c1 = (tp[num] + c0) & BN_MASK2;
		tp[num] = c1;
		tp[num + 1] += (c1 < c0 ? 1 : 0);
		for (j = 0; j <= num; j++)
			tp[j] = tp[j + 1];
	}

	if (tp[num] != 0 || tp[num - 1] >= np[num - 1]) {
		c0 = bn_sub_words(rp, tp, np, num);
		if (tp[num] != 0 || c0 == 0) {
			goto out;
		}
	}
	memcpy(rp, tp, num * sizeof(BN_ULONG));
out:
	freezero(tp, (num + 2) * sizeof(BN_ULONG));
	return 1;
}
#else
int
bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
    const BN_ULONG *np, const BN_ULONG *n0, int num)
{
	return 0;
}
#endif /* OPENSSL_BN_ASM_MONT */
#endif

#endif /* !BN_MUL_COMBA */
@


1.14
log
@Fix CVE-2014-3570: properly calculate the square of a BIGNUM value.

See https://www.openssl.org/news/secadv_20150108.txt for a more detailed
discussion.

Original OpenSSL patch here:
https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0

The regression test is modified a little for KNF.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_asm.c,v 1.13 2014/07/11 08:44:47 jsing Exp $ */
d992 1
a992 2
	explicit_bzero(tp, (num + 2) * sizeof(BN_ULONG));
	free(tp);
d1083 1
a1083 2
	explicit_bzero(tp, (num + 2) * sizeof(BN_ULONG));
	free(tp);
@


1.13
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_asm.c,v 1.12 2014/07/10 22:45:56 jsing Exp $ */
d498 34
a531 23
#define mul_add_c(a,b,c0,c1,c2) \
	t=(BN_ULLONG)a*b; \
	t1=(BN_ULONG)Lw(t); \
	t2=(BN_ULONG)Hw(t); \
	c0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \
	c1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;

#define mul_add_c2(a,b,c0,c1,c2) \
	t=(BN_ULLONG)a*b; \
	tt=(t+t)&BN_MASK; \
	if (tt < t) c2++; \
	t1=(BN_ULONG)Lw(tt); \
	t2=(BN_ULONG)Hw(tt); \
	c0=(c0+t1)&BN_MASK2;  \
	if ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \
	c1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;

#define sqr_add_c(a,i,c0,c1,c2) \
	t=(BN_ULLONG)a[i]*a[i]; \
	t1=(BN_ULONG)Lw(t); \
	t2=(BN_ULONG)Hw(t); \
	c0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \
	c1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;
d537 29
a565 23

#define mul_add_c(a,b,c0,c1,c2)	{	\
	BN_ULONG ta=(a),tb=(b);		\
	BN_UMULT_LOHI(t1,t2,ta,tb);	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define mul_add_c2(a,b,c0,c1,c2) {	\
	BN_ULONG ta=(a),tb=(b),t0;	\
	BN_UMULT_LOHI(t0,t1,ta,tb);	\
	t2 = t1+t1; c2 += (t2<t1)?1:0;	\
	t1 = t0+t0; t2 += (t1<t0)?1:0;	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define sqr_add_c(a,i,c0,c1,c2)	{	\
	BN_ULONG ta=(a)[i];		\
	BN_UMULT_LOHI(t1,t2,ta,ta);	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}
d571 29
a599 26

#define mul_add_c(a,b,c0,c1,c2)	{	\
	BN_ULONG ta=(a),tb=(b);		\
	t1 = ta * tb;			\
	t2 = BN_UMULT_HIGH(ta,tb);	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define mul_add_c2(a,b,c0,c1,c2) {	\
	BN_ULONG ta=(a),tb=(b),t0;	\
	t1 = BN_UMULT_HIGH(ta,tb);	\
	t0 = ta * tb;			\
	t2 = t1+t1; c2 += (t2<t1)?1:0;	\
	t1 = t0+t0; t2 += (t1<t0)?1:0;	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define sqr_add_c(a,i,c0,c1,c2)	{	\
	BN_ULONG ta=(a)[i];		\
	t1 = ta * ta;			\
	t2 = BN_UMULT_HIGH(ta,ta);	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}
d605 30
a634 23
#define mul_add_c(a,b,c0,c1,c2) \
	t1=LBITS(a); t2=HBITS(a); \
	bl=LBITS(b); bh=HBITS(b); \
	mul64(t1,t2,bl,bh); \
	c0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \
	c1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;

#define mul_add_c2(a,b,c0,c1,c2) \
	t1=LBITS(a); t2=HBITS(a); \
	bl=LBITS(b); bh=HBITS(b); \
	mul64(t1,t2,bl,bh); \
	if (t2 & BN_TBIT) c2++; \
	t2=(t2+t2)&BN_MASK2; \
	if (t1 & BN_TBIT) t2++; \
	t1=(t1+t1)&BN_MASK2; \
	c0=(c0+t1)&BN_MASK2;  \
	if ((c0 < t1) && (((++t2)&BN_MASK2) == 0)) c2++; \
	c1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;

#define sqr_add_c(a,i,c0,c1,c2) \
	sqr64(t1,t2,(a)[i]); \
	c0=(c0+t1)&BN_MASK2; if ((c0) < t1) t2++; \
	c1=(c1+t2)&BN_MASK2; if ((c1) < t2) c2++;
a642 6
#ifdef BN_LLONG
	BN_ULLONG t;
#elif !defined(BN_UMULT_LOHI) && !defined(BN_UMULT_HIGH)
	BN_ULONG bl, bh;
#endif
	BN_ULONG t1, t2;
a746 6
#ifdef BN_LLONG
	BN_ULLONG t;
#elif !defined(BN_UMULT_LOHI) && !defined(BN_UMULT_HIGH)
	BN_ULONG bl, bh;
#endif
	BN_ULONG t1, t2;
a786 6
#ifdef BN_LLONG
	BN_ULLONG t, tt;
#elif !defined(BN_UMULT_LOHI) && !defined(BN_UMULT_HIGH)
	BN_ULONG bl, bh;
#endif
	BN_ULONG t1, t2;
a862 6
#ifdef BN_LLONG
	BN_ULLONG t, tt;
#elif !defined(BN_UMULT_LOHI) && !defined(BN_UMULT_HIGH)
	BN_ULONG bl, bh;
#endif
	BN_ULONG t1, t2;
@


1.12
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: bn_asm.c,v 1.11 2014/06/12 15:49:28 deraadt Exp $ */
a68 1
#include "cryptlib.h"
@


1.11
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d64 1
d66 3
a68 1
#include <assert.h>
@


1.10
log
@Replace (sometimes conditional) use of alloca with malloc, and clearing
through volatile pointers with explicit_bzero().

ok beck@@ jsing@@
@
text
@d1 1
a1 1
/* crypto/bn/bn_asm.c */
@


1.9
log
@Emergency knfectomie requested by tedu@@.
@
text
@a890 1
#include <alloca.h>
a910 1
	volatile BN_ULONG *vp;
d917 3
a919 1
	vp = tp = alloca((num + 2)*sizeof(BN_ULONG));
d982 1
a982 3
			for (i = 0; i < num + 2; i++)
				vp[i] = 0;
			return 1;
d985 4
a988 4
	for (i = 0; i < num; i++)
		rp[i] = tp[i],	vp[i] = 0;
	vp[num] = 0;
	vp[num + 1] = 0;
a1045 1
#include <alloca.h>
a1050 1
	volatile BN_ULONG *vp;
d1053 3
a1055 4
	vp = tp = alloca((num + 2) * sizeof(BN_ULONG));

	for(i = 0; i <= num; i++)
		tp[i] = 0;
d1074 1
a1074 3
			for (i = 0; i < num + 2; i++)
				vp[i] = 0;
			return 1;
d1077 4
a1080 4
	for (i = 0; i < num; i++)
		rp[i] = tp[i], vp[i] = 0;
	vp[num] = 0;
	vp[num + 1] = 0;
@


1.8
log
@Pass -Werror in the !BN_LLONG !BN_UMULT_LOHI !BN_UMULT_HIGH case.
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d71 4
a74 3
BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
	{
	BN_ULONG c1=0;
d77 2
a78 1
	if (num <= 0) return(c1);
d81 24
a104 21
	while (num&~3)
		{
		mul_add(rp[0],ap[0],w,c1);
		mul_add(rp[1],ap[1],w,c1);
		mul_add(rp[2],ap[2],w,c1);
		mul_add(rp[3],ap[3],w,c1);
		ap+=4; rp+=4; num-=4;
		}
#endif
	while (num)
		{
		mul_add(rp[0],ap[0],w,c1);
		ap++; rp++; num--;
		}
	
	return(c1);
	} 

BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
	{
	BN_ULONG c1=0;
d107 2
a108 1
	if (num <= 0) return(c1);
d111 22
a132 19
	while (num&~3)
		{
		mul(rp[0],ap[0],w,c1);
		mul(rp[1],ap[1],w,c1);
		mul(rp[2],ap[2],w,c1);
		mul(rp[3],ap[3],w,c1);
		ap+=4; rp+=4; num-=4;
		}
#endif
	while (num)
		{
		mul(rp[0],ap[0],w,c1);
		ap++; rp++; num--;
		}
	return(c1);
	} 

void bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)
        {
d134 2
a135 1
	if (n <= 0) return;
d138 15
a152 14
	while (n&~3)
		{
		sqr(r[0],r[1],a[0]);
		sqr(r[2],r[3],a[1]);
		sqr(r[4],r[5],a[2]);
		sqr(r[6],r[7],a[3]);
		a+=4; r+=8; n-=4;
		}
#endif
	while (n)
		{
		sqr(r[0],r[1],a[0]);
		a++; r+=2; n--;
		}
d154 1
d158 5
a162 4
BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
	{
	BN_ULONG c=0;
	BN_ULONG bl,bh;
d165 2
a166 1
	if (num <= 0) return((BN_ULONG)0);
d168 2
a169 2
	bl=LBITS(w);
	bh=HBITS(w);
d172 24
a195 21
	while (num&~3)
		{
		mul_add(rp[0],ap[0],bl,bh,c);
		mul_add(rp[1],ap[1],bl,bh,c);
		mul_add(rp[2],ap[2],bl,bh,c);
		mul_add(rp[3],ap[3],bl,bh,c);
		ap+=4; rp+=4; num-=4;
		}
#endif
	while (num)
		{
		mul_add(rp[0],ap[0],bl,bh,c);
		ap++; rp++; num--;
		}
	return(c);
	} 

BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
	{
	BN_ULONG carry=0;
	BN_ULONG bl,bh;
d198 2
a199 1
	if (num <= 0) return((BN_ULONG)0);
d201 2
a202 2
	bl=LBITS(w);
	bh=HBITS(w);
d205 22
a226 19
	while (num&~3)
		{
		mul(rp[0],ap[0],bl,bh,carry);
		mul(rp[1],ap[1],bl,bh,carry);
		mul(rp[2],ap[2],bl,bh,carry);
		mul(rp[3],ap[3],bl,bh,carry);
		ap+=4; rp+=4; num-=4;
		}
#endif
	while (num)
		{
		mul(rp[0],ap[0],bl,bh,carry);
		ap++; rp++; num--;
		}
	return(carry);
	} 

void bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)
        {
d228 2
a229 1
	if (n <= 0) return;
d232 15
a246 14
	while (n&~3)
		{
		sqr64(r[0],r[1],a[0]);
		sqr64(r[2],r[3],a[1]);
		sqr64(r[4],r[5],a[2]);
		sqr64(r[6],r[7],a[3]);
		a+=4; r+=8; n-=4;
		}
#endif
	while (n)
		{
		sqr64(r[0],r[1],a[0]);
		a++; r+=2; n--;
		}
d248 1
d254 5
a258 4
BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)
	{
	return((BN_ULONG)(((((BN_ULLONG)h)<<BN_BITS2)|l)/(BN_ULLONG)d));
	}
d264 26
a289 25
BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)
	{
	BN_ULONG dh,dl,q,ret=0,th,tl,t;
	int i,count=2;

	if (d == 0) return(BN_MASK2);

	i=BN_num_bits_word(d);
	assert((i == BN_BITS2) || (h <= (BN_ULONG)1<<i));

	i=BN_BITS2-i;
	if (h >= d) h-=d;

	if (i)
		{
		d<<=i;
		h=(h<<i)|(l>>(BN_BITS2-i));
		l<<=i;
		}
	dh=(d&BN_MASK2h)>>BN_BITS4;
	dl=(d&BN_MASK2l);
	for (;;)
		{
		if ((h>>BN_BITS4) == dh)
			q=BN_MASK2l;
d291 1
a291 1
			q=h/dh;
d293 8
a300 9
		th=q*dh;
		tl=dl*q;
		for (;;)
			{
			t=h-th;
			if ((t&BN_MASK2h) ||
				((tl) <= (
					(t<<BN_BITS4)|
					((l&BN_MASK2h)>>BN_BITS4))))
d303 12
a314 12
			th-=dh;
			tl-=dl;
			}
		t=(tl>>BN_BITS4);
		tl=(tl<<BN_BITS4)&BN_MASK2h;
		th+=t;

		if (l < tl) th++;
		l-=tl;
		if (h < th)
			{
			h+=d;
d316 2
a317 2
			}
		h-=th;
d319 2
a320 1
		if (--count == 0) break;
d322 7
a328 7
		ret=q<<BN_BITS4;
		h=((h<<BN_BITS4)|(l>>BN_BITS4))&BN_MASK2;
		l=(l&BN_MASK2l)<<BN_BITS4;
		}
	ret|=q;
	return(ret);
	}
d332 4
a335 3
BN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)
        {
	BN_ULLONG ll=0;
d338 2
a339 1
	if (n <= 0) return((BN_ULONG)0);
d342 27
a368 25
	while (n&~3)
		{
		ll+=(BN_ULLONG)a[0]+b[0];
		r[0]=(BN_ULONG)ll&BN_MASK2;
		ll>>=BN_BITS2;
		ll+=(BN_ULLONG)a[1]+b[1];
		r[1]=(BN_ULONG)ll&BN_MASK2;
		ll>>=BN_BITS2;
		ll+=(BN_ULLONG)a[2]+b[2];
		r[2]=(BN_ULONG)ll&BN_MASK2;
		ll>>=BN_BITS2;
		ll+=(BN_ULLONG)a[3]+b[3];
		r[3]=(BN_ULONG)ll&BN_MASK2;
		ll>>=BN_BITS2;
		a+=4; b+=4; r+=4; n-=4;
		}
#endif
	while (n)
		{
		ll+=(BN_ULLONG)a[0]+b[0];
		r[0]=(BN_ULONG)ll&BN_MASK2;
		ll>>=BN_BITS2;
		a++; b++; r++; n--;
		}
	return((BN_ULONG)ll);
d370 2
d373 4
a376 3
BN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)
        {
	BN_ULONG c,l,t;
d379 2
a380 1
	if (n <= 0) return((BN_ULONG)0);
d382 1
a382 1
	c=0;
d384 42
a425 40
	while (n&~3)
		{
		t=a[0];
		t=(t+c)&BN_MASK2;
		c=(t < c);
		l=(t+b[0])&BN_MASK2;
		c+=(l < t);
		r[0]=l;
		t=a[1];
		t=(t+c)&BN_MASK2;
		c=(t < c);
		l=(t+b[1])&BN_MASK2;
		c+=(l < t);
		r[1]=l;
		t=a[2];
		t=(t+c)&BN_MASK2;
		c=(t < c);
		l=(t+b[2])&BN_MASK2;
		c+=(l < t);
		r[2]=l;
		t=a[3];
		t=(t+c)&BN_MASK2;
		c=(t < c);
		l=(t+b[3])&BN_MASK2;
		c+=(l < t);
		r[3]=l;
		a+=4; b+=4; r+=4; n-=4;
		}
#endif
	while(n)
		{
		t=a[0];
		t=(t+c)&BN_MASK2;
		c=(t < c);
		l=(t+b[0])&BN_MASK2;
		c+=(l < t);
		r[0]=l;
		a++; b++; r++; n--;
		}
	return((BN_ULONG)c);
d427 2
d431 5
a435 4
BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)
        {
	BN_ULONG t1,t2;
	int c=0;
d438 2
a439 1
	if (n <= 0) return((BN_ULONG)0);
d442 37
a478 25
	while (n&~3)
		{
		t1=a[0]; t2=b[0];
		r[0]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		t1=a[1]; t2=b[1];
		r[1]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		t1=a[2]; t2=b[2];
		r[2]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		t1=a[3]; t2=b[3];
		r[3]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		a+=4; b+=4; r+=4; n-=4;
		}
#endif
	while (n)
		{
		t1=a[0]; t2=b[0];
		r[0]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		a++; b++; r++; n--;
		}
	return(c);
d480 2
d611 3
a613 2
void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
	{
d617 1
a617 1
	BN_ULONG bl,bh;
d619 2
a620 101
	BN_ULONG t1,t2;
	BN_ULONG c1,c2,c3;

	c1=0;
	c2=0;
	c3=0;
	mul_add_c(a[0],b[0],c1,c2,c3);
	r[0]=c1;
	c1=0;
	mul_add_c(a[0],b[1],c2,c3,c1);
	mul_add_c(a[1],b[0],c2,c3,c1);
	r[1]=c2;
	c2=0;
	mul_add_c(a[2],b[0],c3,c1,c2);
	mul_add_c(a[1],b[1],c3,c1,c2);
	mul_add_c(a[0],b[2],c3,c1,c2);
	r[2]=c3;
	c3=0;
	mul_add_c(a[0],b[3],c1,c2,c3);
	mul_add_c(a[1],b[2],c1,c2,c3);
	mul_add_c(a[2],b[1],c1,c2,c3);
	mul_add_c(a[3],b[0],c1,c2,c3);
	r[3]=c1;
	c1=0;
	mul_add_c(a[4],b[0],c2,c3,c1);
	mul_add_c(a[3],b[1],c2,c3,c1);
	mul_add_c(a[2],b[2],c2,c3,c1);
	mul_add_c(a[1],b[3],c2,c3,c1);
	mul_add_c(a[0],b[4],c2,c3,c1);
	r[4]=c2;
	c2=0;
	mul_add_c(a[0],b[5],c3,c1,c2);
	mul_add_c(a[1],b[4],c3,c1,c2);
	mul_add_c(a[2],b[3],c3,c1,c2);
	mul_add_c(a[3],b[2],c3,c1,c2);
	mul_add_c(a[4],b[1],c3,c1,c2);
	mul_add_c(a[5],b[0],c3,c1,c2);
	r[5]=c3;
	c3=0;
	mul_add_c(a[6],b[0],c1,c2,c3);
	mul_add_c(a[5],b[1],c1,c2,c3);
	mul_add_c(a[4],b[2],c1,c2,c3);
	mul_add_c(a[3],b[3],c1,c2,c3);
	mul_add_c(a[2],b[4],c1,c2,c3);
	mul_add_c(a[1],b[5],c1,c2,c3);
	mul_add_c(a[0],b[6],c1,c2,c3);
	r[6]=c1;
	c1=0;
	mul_add_c(a[0],b[7],c2,c3,c1);
	mul_add_c(a[1],b[6],c2,c3,c1);
	mul_add_c(a[2],b[5],c2,c3,c1);
	mul_add_c(a[3],b[4],c2,c3,c1);
	mul_add_c(a[4],b[3],c2,c3,c1);
	mul_add_c(a[5],b[2],c2,c3,c1);
	mul_add_c(a[6],b[1],c2,c3,c1);
	mul_add_c(a[7],b[0],c2,c3,c1);
	r[7]=c2;
	c2=0;
	mul_add_c(a[7],b[1],c3,c1,c2);
	mul_add_c(a[6],b[2],c3,c1,c2);
	mul_add_c(a[5],b[3],c3,c1,c2);
	mul_add_c(a[4],b[4],c3,c1,c2);
	mul_add_c(a[3],b[5],c3,c1,c2);
	mul_add_c(a[2],b[6],c3,c1,c2);
	mul_add_c(a[1],b[7],c3,c1,c2);
	r[8]=c3;
	c3=0;
	mul_add_c(a[2],b[7],c1,c2,c3);
	mul_add_c(a[3],b[6],c1,c2,c3);
	mul_add_c(a[4],b[5],c1,c2,c3);
	mul_add_c(a[5],b[4],c1,c2,c3);
	mul_add_c(a[6],b[3],c1,c2,c3);
	mul_add_c(a[7],b[2],c1,c2,c3);
	r[9]=c1;
	c1=0;
	mul_add_c(a[7],b[3],c2,c3,c1);
	mul_add_c(a[6],b[4],c2,c3,c1);
	mul_add_c(a[5],b[5],c2,c3,c1);
	mul_add_c(a[4],b[6],c2,c3,c1);
	mul_add_c(a[3],b[7],c2,c3,c1);
	r[10]=c2;
	c2=0;
	mul_add_c(a[4],b[7],c3,c1,c2);
	mul_add_c(a[5],b[6],c3,c1,c2);
	mul_add_c(a[6],b[5],c3,c1,c2);
	mul_add_c(a[7],b[4],c3,c1,c2);
	r[11]=c3;
	c3=0;
	mul_add_c(a[7],b[5],c1,c2,c3);
	mul_add_c(a[6],b[6],c1,c2,c3);
	mul_add_c(a[5],b[7],c1,c2,c3);
	r[12]=c1;
	c1=0;
	mul_add_c(a[6],b[7],c2,c3,c1);
	mul_add_c(a[7],b[6],c2,c3,c1);
	r[13]=c2;
	c2=0;
	mul_add_c(a[7],b[7],c3,c1,c2);
	r[14]=c3;
	r[15]=c1;
	}
d622 102
a723 2
void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
	{
d727 1
a727 1
	BN_ULONG bl,bh;
d729 2
a730 37
	BN_ULONG t1,t2;
	BN_ULONG c1,c2,c3;

	c1=0;
	c2=0;
	c3=0;
	mul_add_c(a[0],b[0],c1,c2,c3);
	r[0]=c1;
	c1=0;
	mul_add_c(a[0],b[1],c2,c3,c1);
	mul_add_c(a[1],b[0],c2,c3,c1);
	r[1]=c2;
	c2=0;
	mul_add_c(a[2],b[0],c3,c1,c2);
	mul_add_c(a[1],b[1],c3,c1,c2);
	mul_add_c(a[0],b[2],c3,c1,c2);
	r[2]=c3;
	c3=0;
	mul_add_c(a[0],b[3],c1,c2,c3);
	mul_add_c(a[1],b[2],c1,c2,c3);
	mul_add_c(a[2],b[1],c1,c2,c3);
	mul_add_c(a[3],b[0],c1,c2,c3);
	r[3]=c1;
	c1=0;
	mul_add_c(a[3],b[1],c2,c3,c1);
	mul_add_c(a[2],b[2],c2,c3,c1);
	mul_add_c(a[1],b[3],c2,c3,c1);
	r[4]=c2;
	c2=0;
	mul_add_c(a[2],b[3],c3,c1,c2);
	mul_add_c(a[3],b[2],c3,c1,c2);
	r[5]=c3;
	c3=0;
	mul_add_c(a[3],b[3],c1,c2,c3);
	r[6]=c1;
	r[7]=c2;
	}
d732 38
a769 2
void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
	{
d771 1
a771 1
	BN_ULLONG t,tt;
d773 1
a773 1
	BN_ULONG bl,bh;
d775 2
a776 2
	BN_ULONG t1,t2;
	BN_ULONG c1,c2,c3;
d778 74
a851 73
	c1=0;
	c2=0;
	c3=0;
	sqr_add_c(a,0,c1,c2,c3);
	r[0]=c1;
	c1=0;
	sqr_add_c2(a,1,0,c2,c3,c1);
	r[1]=c2;
	c2=0;
	sqr_add_c(a,1,c3,c1,c2);
	sqr_add_c2(a,2,0,c3,c1,c2);
	r[2]=c3;
	c3=0;
	sqr_add_c2(a,3,0,c1,c2,c3);
	sqr_add_c2(a,2,1,c1,c2,c3);
	r[3]=c1;
	c1=0;
	sqr_add_c(a,2,c2,c3,c1);
	sqr_add_c2(a,3,1,c2,c3,c1);
	sqr_add_c2(a,4,0,c2,c3,c1);
	r[4]=c2;
	c2=0;
	sqr_add_c2(a,5,0,c3,c1,c2);
	sqr_add_c2(a,4,1,c3,c1,c2);
	sqr_add_c2(a,3,2,c3,c1,c2);
	r[5]=c3;
	c3=0;
	sqr_add_c(a,3,c1,c2,c3);
	sqr_add_c2(a,4,2,c1,c2,c3);
	sqr_add_c2(a,5,1,c1,c2,c3);
	sqr_add_c2(a,6,0,c1,c2,c3);
	r[6]=c1;
	c1=0;
	sqr_add_c2(a,7,0,c2,c3,c1);
	sqr_add_c2(a,6,1,c2,c3,c1);
	sqr_add_c2(a,5,2,c2,c3,c1);
	sqr_add_c2(a,4,3,c2,c3,c1);
	r[7]=c2;
	c2=0;
	sqr_add_c(a,4,c3,c1,c2);
	sqr_add_c2(a,5,3,c3,c1,c2);
	sqr_add_c2(a,6,2,c3,c1,c2);
	sqr_add_c2(a,7,1,c3,c1,c2);
	r[8]=c3;
	c3=0;
	sqr_add_c2(a,7,2,c1,c2,c3);
	sqr_add_c2(a,6,3,c1,c2,c3);
	sqr_add_c2(a,5,4,c1,c2,c3);
	r[9]=c1;
	c1=0;
	sqr_add_c(a,5,c2,c3,c1);
	sqr_add_c2(a,6,4,c2,c3,c1);
	sqr_add_c2(a,7,3,c2,c3,c1);
	r[10]=c2;
	c2=0;
	sqr_add_c2(a,7,4,c3,c1,c2);
	sqr_add_c2(a,6,5,c3,c1,c2);
	r[11]=c3;
	c3=0;
	sqr_add_c(a,6,c1,c2,c3);
	sqr_add_c2(a,7,5,c1,c2,c3);
	r[12]=c1;
	c1=0;
	sqr_add_c2(a,7,6,c2,c3,c1);
	r[13]=c2;
	c2=0;
	sqr_add_c(a,7,c3,c1,c2);
	r[14]=c3;
	r[15]=c1;
	}

void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
	{
d853 1
a853 1
	BN_ULLONG t,tt;
d855 1
a855 1
	BN_ULONG bl,bh;
d857 2
a858 2
	BN_ULONG t1,t2;
	BN_ULONG c1,c2,c3;
d860 28
a887 28
	c1=0;
	c2=0;
	c3=0;
	sqr_add_c(a,0,c1,c2,c3);
	r[0]=c1;
	c1=0;
	sqr_add_c2(a,1,0,c2,c3,c1);
	r[1]=c2;
	c2=0;
	sqr_add_c(a,1,c3,c1,c2);
	sqr_add_c2(a,2,0,c3,c1,c2);
	r[2]=c3;
	c3=0;
	sqr_add_c2(a,3,0,c1,c2,c3);
	sqr_add_c2(a,2,1,c1,c2,c3);
	r[3]=c1;
	c1=0;
	sqr_add_c(a,2,c2,c3,c1);
	sqr_add_c2(a,3,1,c2,c3,c1);
	r[4]=c2;
	c2=0;
	sqr_add_c2(a,3,2,c3,c1,c2);
	r[5]=c3;
	c3=0;
	sqr_add_c(a,3,c1,c2,c3);
	r[6]=c1;
	r[7]=c2;
	}
d905 4
a908 3
int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0p, int num)
	{
	BN_ULONG c0,c1,ml,*tp,n0;
d913 1
a913 1
	int i=0,j;
d916 2
a917 1
	if (ap==bp)	return bn_sqr_mont(rp,ap,np,n0p,num);
d919 1
a919 1
	vp = tp = alloca((num+2)*sizeof(BN_ULONG));
d928 2
a929 2
	for (j=0;j<num;++j)
		mul(tp[j],ap[j],ml,mh,c0);
d931 2
a932 2
	for (j=0;j<num;++j)
		mul(tp[j],ap[j],ml,c0);
d935 2
a936 2
	tp[num]   = c0;
	tp[num+1] = 0;
d939 1
a939 2
	for(i=0;i<num;i++)
		{
d945 2
a946 2
		for (j=0;j<num;++j)
			mul_add(tp[j],ap[j],ml,mh,c0);
d948 2
a949 2
		for (j=0;j<num;++j)
			mul_add(tp[j],ap[j],ml,c0);
d951 6
a956 6
		c1 = (tp[num] + c0)&BN_MASK2;
		tp[num]   = c1;
		tp[num+1] = (c1<c0?1:0);
	enter:
		c1  = tp[0];
		ml = (c1*n0)&BN_MASK2;
d961 1
a961 1
		mul_add(c1,np[0],ml,mh,c0);
d963 1
a963 1
		mul_add(c1,ml,np[0],c0);
d965 1
a965 2
		for(j=1;j<num;j++)
			{
d968 1
a968 1
			mul_add(c1,np[j],ml,mh,c0);
d970 1
a970 1
			mul_add(c1,ml,np[j],c0);
d972 1
a972 5
			tp[j-1] = c1&BN_MASK2;
			}
		c1        = (tp[num] + c0)&BN_MASK2;
		tp[num-1] = c1;
		tp[num]   = tp[num+1] + (c1<c0?1:0);
d974 4
d979 5
a983 6
	if (tp[num]!=0 || tp[num-1]>=np[num-1])
		{
		c0 = bn_sub_words(rp,tp,np,num);
		if (tp[num]!=0 || c0==0)
			{
			for(i=0;i<num+2;i++)	vp[i] = 0;
a984 1
			}
d986 5
a990 3
	for(i=0;i<num;i++)	rp[i] = tp[i],	vp[i] = 0;
	vp[num]   = 0;
	vp[num+1] = 0;
d992 1
a992 1
	}
d999 3
a1001 2
int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0, int num)
{	return 0;	}
d1009 3
a1011 2
void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
	{
d1013 2
a1014 2
	bn_sqr_normal(r,a,4,t);
	}
d1017 3
a1019 2
void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
	{
d1021 2
a1022 2
	bn_sqr_normal(r,a,8,t);
	}
d1024 21
a1044 19
void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
	{
	r[4]=bn_mul_words(    &(r[0]),a,4,b[0]);
	r[5]=bn_mul_add_words(&(r[1]),a,4,b[1]);
	r[6]=bn_mul_add_words(&(r[2]),a,4,b[2]);
	r[7]=bn_mul_add_words(&(r[3]),a,4,b[3]);
	}

void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
	{
	r[ 8]=bn_mul_words(    &(r[0]),a,8,b[0]);
	r[ 9]=bn_mul_add_words(&(r[1]),a,8,b[1]);
	r[10]=bn_mul_add_words(&(r[2]),a,8,b[2]);
	r[11]=bn_mul_add_words(&(r[3]),a,8,b[3]);
	r[12]=bn_mul_add_words(&(r[4]),a,8,b[4]);
	r[13]=bn_mul_add_words(&(r[5]),a,8,b[5]);
	r[14]=bn_mul_add_words(&(r[6]),a,8,b[6]);
	r[15]=bn_mul_add_words(&(r[7]),a,8,b[7]);
	}
d1049 5
a1053 3
int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0p, int num)
	{
	BN_ULONG c0,c1,*tp,n0=*n0p;
d1055 1
a1055 3
	int i=0,j;

	vp = tp = alloca((num+2)*sizeof(BN_ULONG));
d1057 1
a1057 1
	for(i=0;i<=num;i++)	tp[i]=0;
d1059 2
a1060 13
	for(i=0;i<num;i++)
		{
		c0         = bn_mul_add_words(tp,ap,num,bp[i]);
		c1         = (tp[num] + c0)&BN_MASK2;
		tp[num]    = c1;
		tp[num+1]  = (c1<c0?1:0);

		c0         = bn_mul_add_words(tp,np,num,tp[0]*n0);
		c1         = (tp[num] + c0)&BN_MASK2;
		tp[num]    = c1;
		tp[num+1] += (c1<c0?1:0);
		for(j=0;j<=num;j++)	tp[j]=tp[j+1];
		}
d1062 19
a1080 6
	if (tp[num]!=0 || tp[num-1]>=np[num-1])
		{
		c0 = bn_sub_words(rp,tp,np,num);
		if (tp[num]!=0 || c0==0)
			{
			for(i=0;i<num+2;i++)	vp[i] = 0;
a1081 1
			}
d1083 5
a1087 3
	for(i=0;i<num;i++)	rp[i] = tp[i],	vp[i] = 0;
	vp[num]   = 0;
	vp[num+1] = 0;
d1089 1
a1089 1
	}
d1091 6
a1096 2
int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0, int num)
{	return 0;	}
@


1.7
log
@resolve conflicts, fix local changes
@
text
@d561 1
a561 1
#else
d670 1
a670 1
#else
d715 1
a715 1
#else
d796 1
a796 1
#else
@


1.6
log
@resolve conflicts
@
text
@d78 1
d87 2
a88 1
	if (num)
d90 2
a91 3
		mul_add(rp[0],ap[0],w,c1); if (--num==0) return c1;
		mul_add(rp[1],ap[1],w,c1); if (--num==0) return c1;
		mul_add(rp[2],ap[2],w,c1); return c1;
d104 1
d113 2
a114 1
	if (num)
d116 2
a117 3
		mul(rp[0],ap[0],w,c1); if (--num == 0) return c1;
		mul(rp[1],ap[1],w,c1); if (--num == 0) return c1;
		mul(rp[2],ap[2],w,c1);
d126 2
d136 2
a137 1
	if (n)
d139 2
a140 3
		sqr(r[0],r[1],a[0]); if (--n == 0) return;
		sqr(r[2],r[3],a[1]); if (--n == 0) return;
		sqr(r[4],r[5],a[2]);
d157 2
a158 1
	for (;;)
a160 1
		if (--num == 0) break;
a161 1
		if (--num == 0) break;
a162 1
		if (--num == 0) break;
d164 7
a170 3
		if (--num == 0) break;
		ap+=4;
		rp+=4;
d186 2
a187 1
	for (;;)
a189 1
		if (--num == 0) break;
a190 1
		if (--num == 0) break;
a191 1
		if (--num == 0) break;
d193 7
a199 3
		if (--num == 0) break;
		ap+=4;
		rp+=4;
d208 3
a210 1
	for (;;)
a212 2
		if (--n == 0) break;

a213 2
		if (--n == 0) break;

a214 2
		if (--n == 0) break;

d216 7
a222 4
		if (--n == 0) break;

		a+=4;
		r+=8;
d313 2
a314 1
	for (;;)
a318 2
		if (--n <= 0) break;

a321 2
		if (--n <= 0) break;

a324 2
		if (--n <= 0) break;

d328 9
a336 5
		if (--n <= 0) break;

		a+=4;
		b+=4;
		r+=4;
d349 2
a350 1
	for (;;)
a357 2
		if (--n <= 0) break;

a363 2
		if (--n <= 0) break;

a369 2
		if (--n <= 0) break;

d376 12
a387 5
		if (--n <= 0) break;

		a+=4;
		b+=4;
		r+=4;
d401 2
a402 1
	for (;;)
a406 2
		if (--n <= 0) break;

a409 2
		if (--n <= 0) break;

a412 2
		if (--n <= 0) break;

d416 9
a424 5
		if (--n <= 0) break;

		a+=4;
		b+=4;
		r+=4;
d429 1
a429 1
#ifdef BN_MUL_COMBA
d830 116
d950 1
a950 1
void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a)
d957 1
a957 1
void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a)
d982 47
@


1.5
log
@resolve conflicts
@
text
@d462 28
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d240 1
a240 1
	assert((i == BN_BITS2) || (h > (BN_ULONG)1<<i));
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d71 1
a71 1
BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)
d96 1
a96 1
BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)
d120 1
a120 1
void bn_sqr_words(BN_ULONG *r, BN_ULONG *a, int n)
d142 1
a142 1
BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)
d169 1
a169 1
BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)
d196 1
a196 1
void bn_sqr_words(BN_ULONG *r, BN_ULONG *a, int n)
d299 1
a299 1
BN_ULONG bn_add_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
d335 1
a335 1
BN_ULONG bn_add_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
d385 1
a385 1
BN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)
d676 1
a676 1
void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a)
d757 1
a757 1
void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a)
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d230 1
a230 1
/* Divide h-l by d and return the result. */
d240 2
a241 7
	if ((i != BN_BITS2) && (h > (BN_ULONG)1<<i))
		{
#if !defined(NO_STDIO) && !defined(WIN16)
		fprintf(stderr,"Division would overflow (%d)\n",i);
#endif
		abort();
		}
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d59 5
d65 1
d69 1
a69 1
#ifdef BN_LLONG 
d75 1
a75 1
	bn_check_num(num);
d78 1
a78 1
	for (;;)
a80 1
		if (--num == 0) break;
a81 1
		if (--num == 0) break;
a82 1
		if (--num == 0) break;
d84 7
a90 3
		if (--num == 0) break;
		ap+=4;
		rp+=4;
d100 1
a100 1
	bn_check_num(num);
d103 1
a103 2
	/* for (;;) */
	while (1) /* circumvent egcs-1.1.2 bug */
a105 1
		if (--num == 0) break;
a106 1
		if (--num == 0) break;
a107 1
		if (--num == 0) break;
d109 7
a115 3
		if (--num == 0) break;
		ap+=4;
		rp+=4;
d122 1
a122 1
	bn_check_num(n);
d124 9
a132 1
	for (;;)
d134 3
a136 20
		BN_ULLONG t;

		t=(BN_ULLONG)(a[0])*(a[0]);
		r[0]=Lw(t); r[1]=Hw(t);
		if (--n == 0) break;

		t=(BN_ULLONG)(a[1])*(a[1]);
		r[2]=Lw(t); r[3]=Hw(t);
		if (--n == 0) break;

		t=(BN_ULLONG)(a[2])*(a[2]);
		r[4]=Lw(t); r[5]=Hw(t);
		if (--n == 0) break;

		t=(BN_ULLONG)(a[3])*(a[3]);
		r[6]=Lw(t); r[7]=Hw(t);
		if (--n == 0) break;

		a+=4;
		r+=8;
d140 1
a140 1
#else
d147 1
a147 1
	bn_check_num(num);
d174 1
a174 1
	bn_check_num(num);
d198 1
a198 1
	bn_check_num(n);
d219 1
a219 1
#endif
d301 1
a301 1
#endif
d308 1
a308 1
	bn_check_num(n);
d339 1
a339 1
#else
d344 1
a344 1
	bn_check_num(n);
d388 1
a388 1
#endif
d395 1
a395 1
	bn_check_num(n);
d434 5
d466 33
a498 1
#else
d525 1
a525 1
#endif
d800 1
a800 1
#else
d837 1
a837 1
#endif /* BN_COMBA */
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a58 5
#ifndef BN_DEBUG
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
#endif

a59 1
#include <assert.h>
d63 1
a63 1
#if defined(BN_LLONG) || defined(BN_UMULT_HIGH)
d65 1
a65 1
BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
d69 1
a69 1
	assert(num >= 0);
d72 1
a72 1
	while (num&~3)
d75 1
d77 1
d79 1
d81 3
a83 7
		ap+=4; rp+=4; num-=4;
		}
	if (num)
		{
		mul_add(rp[0],ap[0],w,c1); if (--num==0) return c1;
		mul_add(rp[1],ap[1],w,c1); if (--num==0) return c1;
		mul_add(rp[2],ap[2],w,c1); return c1;
d89 1
a89 1
BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
d93 1
a93 1
	assert(num >= 0);
d96 2
a97 1
	while (num&~3)
d100 1
d102 1
d104 1
d106 3
a108 7
		ap+=4; rp+=4; num-=4;
		}
	if (num)
		{
		mul(rp[0],ap[0],w,c1); if (--num == 0) return c1;
		mul(rp[1],ap[1],w,c1); if (--num == 0) return c1;
		mul(rp[2],ap[2],w,c1);
d113 1
a113 1
void bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)
d115 1
a115 1
	assert(n >= 0);
d117 1
a117 1
	while (n&~3)
d119 20
a138 11
		sqr(r[0],r[1],a[0]);
		sqr(r[2],r[3],a[1]);
		sqr(r[4],r[5],a[2]);
		sqr(r[6],r[7],a[3]);
		a+=4; r+=8; n-=4;
		}
	if (n)
		{
		sqr(r[0],r[1],a[0]); if (--n == 0) return;
		sqr(r[2],r[3],a[1]); if (--n == 0) return;
		sqr(r[4],r[5],a[2]);
d142 1
a142 1
#else /* !(defined(BN_LLONG) || defined(BN_UMULT_HIGH)) */
d144 1
a144 1
BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
d149 1
a149 1
	assert(num >= 0);
d171 1
a171 1
BN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)
d176 1
a176 1
	assert(num >= 0);
d198 1
a198 1
void bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)
d200 1
a200 1
	assert(n >= 0);
d221 1
a221 1
#endif /* !(defined(BN_LLONG) || defined(BN_UMULT_HIGH)) */
d232 1
a232 1
/* Divide h,l by d and return the result. */
d242 7
a248 2
	assert((i == BN_BITS2) || (h > (BN_ULONG)1<<i));

d303 1
a303 1
#endif /* !defined(BN_LLONG) && defined(BN_DIV2W) */
d306 1
a306 1
BN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)
d310 1
a310 1
	assert(n >= 0);
d341 2
a342 2
#else /* !BN_LLONG */
BN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)
d346 1
a346 1
	assert(n >= 0);
d390 1
a390 1
#endif /* !BN_LLONG */
d392 1
a392 1
BN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)
d397 1
a397 1
	assert(n >= 0);
a435 5
/* mul_add_c(a,b,c0,c1,c2)  -- c+=a*b for three word number c=(c2,c1,c0) */
/* mul_add_c2(a,b,c0,c1,c2) -- c+=2*a*b for three word number c=(c2,c1,c0) */
/* sqr_add_c(a,i,c0,c1,c2)  -- c+=a[i]^2 for three word number c=(c2,c1,c0) */
/* sqr_add_c2(a,i,c0,c1,c2) -- c+=2*a[i]*a[j] for three word number c=(c2,c1,c0) */

d463 1
a463 33

#elif defined(BN_UMULT_HIGH)

#define mul_add_c(a,b,c0,c1,c2)	{	\
	BN_ULONG ta=(a),tb=(b);		\
	t1 = ta * tb;			\
	t2 = BN_UMULT_HIGH(ta,tb);	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define mul_add_c2(a,b,c0,c1,c2) {	\
	BN_ULONG ta=(a),tb=(b),t0;	\
	t1 = BN_UMULT_HIGH(ta,tb);	\
	t0 = ta * tb;			\
	t2 = t1+t1; c2 += (t2<t1)?1:0;	\
	t1 = t0+t0; t2 += (t1<t0)?1:0;	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define sqr_add_c(a,i,c0,c1,c2)	{	\
	BN_ULONG ta=(a)[i];		\
	t1 = ta * ta;			\
	t2 = BN_UMULT_HIGH(ta,ta);	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define sqr_add_c2(a,i,j,c0,c1,c2)	\
	mul_add_c2((a)[i],(a)[j],c0,c1,c2)

#else /* !BN_LLONG */
d490 1
a490 1
#endif /* !BN_LLONG */
d646 1
a646 1
void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
d727 1
a727 1
void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
d765 1
a765 1
#else /* !BN_MUL_COMBA */
d802 1
a802 1
#endif /* !BN_MUL_COMBA */
@


1.1.1.2
log
@import of openssl-0.9.7j
@
text
@d240 1
a240 1
	assert((i == BN_BITS2) || (h <= (BN_ULONG)1<<i));
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@a461 28
#elif defined(BN_UMULT_LOHI)

#define mul_add_c(a,b,c0,c1,c2)	{	\
	BN_ULONG ta=(a),tb=(b);		\
	BN_UMULT_LOHI(t1,t2,ta,tb);	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define mul_add_c2(a,b,c0,c1,c2) {	\
	BN_ULONG ta=(a),tb=(b),t0;	\
	BN_UMULT_LOHI(t0,t1,ta,tb);	\
	t2 = t1+t1; c2 += (t2<t1)?1:0;	\
	t1 = t0+t0; t2 += (t1<t0)?1:0;	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define sqr_add_c(a,i,c0,c1,c2)	{	\
	BN_ULONG ta=(a)[i];		\
	BN_UMULT_LOHI(t1,t2,ta,ta);	\
	c0 += t1; t2 += (c0<t1)?1:0;	\
	c1 += t2; c2 += (c1<t2)?1:0;	\
	}

#define sqr_add_c2(a,i,j,c0,c1,c2)	\
	mul_add_c2((a)[i],(a)[j],c0,c1,c2)

@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@a77 1
#ifndef OPENSSL_SMALL_FOOTPRINT
d86 1
a86 2
#endif
	while (num)
d88 3
a90 2
		mul_add(rp[0],ap[0],w,c1);
		ap++; rp++; num--;
a102 1
#ifndef OPENSSL_SMALL_FOOTPRINT
d111 1
a111 2
#endif
	while (num)
d113 3
a115 2
		mul(rp[0],ap[0],w,c1);
		ap++; rp++; num--;
a123 2

#ifndef OPENSSL_SMALL_FOOTPRINT
d132 1
a132 2
#endif
	while (n)
d134 3
a136 2
		sqr(r[0],r[1],a[0]);
		a++; r+=2; n--;
d153 1
a153 2
#ifndef OPENSSL_SMALL_FOOTPRINT
	while (num&~3)
d156 1
d158 1
d160 1
d162 3
a164 7
		ap+=4; rp+=4; num-=4;
		}
#endif
	while (num)
		{
		mul_add(rp[0],ap[0],bl,bh,c);
		ap++; rp++; num--;
d180 1
a180 2
#ifndef OPENSSL_SMALL_FOOTPRINT
	while (num&~3)
d183 1
d185 1
d187 1
d189 3
a191 7
		ap+=4; rp+=4; num-=4;
		}
#endif
	while (num)
		{
		mul(rp[0],ap[0],bl,bh,carry);
		ap++; rp++; num--;
d200 1
a200 3

#ifndef OPENSSL_SMALL_FOOTPRINT
	while (n&~3)
d203 2
d206 2
d209 2
d212 4
a215 7
		a+=4; r+=8; n-=4;
		}
#endif
	while (n)
		{
		sqr64(r[0],r[1],a[0]);
		a++; r+=2; n--;
d306 1
a306 2
#ifndef OPENSSL_SMALL_FOOTPRINT
	while (n&~3)
d311 2
d316 2
d321 2
d326 5
a330 9
		a+=4; b+=4; r+=4; n-=4;
		}
#endif
	while (n)
		{
		ll+=(BN_ULLONG)a[0]+b[0];
		r[0]=(BN_ULONG)ll&BN_MASK2;
		ll>>=BN_BITS2;
		a++; b++; r++; n--;
d343 1
a343 2
#ifndef OPENSSL_SMALL_FOOTPRINT
	while (n&~3)
d351 2
d359 2
d367 2
d375 5
a379 12
		a+=4; b+=4; r+=4; n-=4;
		}
#endif
	while(n)
		{
		t=a[0];
		t=(t+c)&BN_MASK2;
		c=(t < c);
		l=(t+b[0])&BN_MASK2;
		c+=(l < t);
		r[0]=l;
		a++; b++; r++; n--;
d393 1
a393 2
#ifndef OPENSSL_SMALL_FOOTPRINT
	while (n&~3)
d398 2
d403 2
d408 2
d413 5
a417 9
		a+=4; b+=4; r+=4; n-=4;
		}
#endif
	while (n)
		{
		t1=a[0]; t2=b[0];
		r[0]=(t1-t2-c)&BN_MASK2;
		if (t1 != t2) c=(t1 < t2);
		a++; b++; r++; n--;
d422 1
a422 1
#if defined(BN_MUL_COMBA) && !defined(OPENSSL_SMALL_FOOTPRINT)
a822 116

#ifdef OPENSSL_NO_ASM
#ifdef OPENSSL_BN_ASM_MONT
#include <alloca.h>
/*
 * This is essentially reference implementation, which may or may not
 * result in performance improvement. E.g. on IA-32 this routine was
 * observed to give 40% faster rsa1024 private key operations and 10%
 * faster rsa4096 ones, while on AMD64 it improves rsa1024 sign only
 * by 10% and *worsens* rsa4096 sign by 15%. Once again, it's a
 * reference implementation, one to be used as starting point for
 * platform-specific assembler. Mentioned numbers apply to compiler
 * generated code compiled with and without -DOPENSSL_BN_ASM_MONT and
 * can vary not only from platform to platform, but even for compiler
 * versions. Assembler vs. assembler improvement coefficients can
 * [and are known to] differ and are to be documented elsewhere.
 */
int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0p, int num)
	{
	BN_ULONG c0,c1,ml,*tp,n0;
#ifdef mul64
	BN_ULONG mh;
#endif
	volatile BN_ULONG *vp;
	int i=0,j;

#if 0	/* template for platform-specific implementation */
	if (ap==bp)	return bn_sqr_mont(rp,ap,np,n0p,num);
#endif
	vp = tp = alloca((num+2)*sizeof(BN_ULONG));

	n0 = *n0p;

	c0 = 0;
	ml = bp[0];
#ifdef mul64
	mh = HBITS(ml);
	ml = LBITS(ml);
	for (j=0;j<num;++j)
		mul(tp[j],ap[j],ml,mh,c0);
#else
	for (j=0;j<num;++j)
		mul(tp[j],ap[j],ml,c0);
#endif

	tp[num]   = c0;
	tp[num+1] = 0;
	goto enter;

	for(i=0;i<num;i++)
		{
		c0 = 0;
		ml = bp[i];
#ifdef mul64
		mh = HBITS(ml);
		ml = LBITS(ml);
		for (j=0;j<num;++j)
			mul_add(tp[j],ap[j],ml,mh,c0);
#else
		for (j=0;j<num;++j)
			mul_add(tp[j],ap[j],ml,c0);
#endif
		c1 = (tp[num] + c0)&BN_MASK2;
		tp[num]   = c1;
		tp[num+1] = (c1<c0?1:0);
	enter:
		c1  = tp[0];
		ml = (c1*n0)&BN_MASK2;
		c0 = 0;
#ifdef mul64
		mh = HBITS(ml);
		ml = LBITS(ml);
		mul_add(c1,np[0],ml,mh,c0);
#else
		mul_add(c1,ml,np[0],c0);
#endif
		for(j=1;j<num;j++)
			{
			c1 = tp[j];
#ifdef mul64
			mul_add(c1,np[j],ml,mh,c0);
#else
			mul_add(c1,ml,np[j],c0);
#endif
			tp[j-1] = c1&BN_MASK2;
			}
		c1        = (tp[num] + c0)&BN_MASK2;
		tp[num-1] = c1;
		tp[num]   = tp[num+1] + (c1<c0?1:0);
		}

	if (tp[num]!=0 || tp[num-1]>=np[num-1])
		{
		c0 = bn_sub_words(rp,tp,np,num);
		if (tp[num]!=0 || c0==0)
			{
			for(i=0;i<num+2;i++)	vp[i] = 0;
			return 1;
			}
		}
	for(i=0;i<num;i++)	rp[i] = tp[i],	vp[i] = 0;
	vp[num]   = 0;
	vp[num+1] = 0;
	return 1;
	}
#else
/*
 * Return value of 0 indicates that multiplication/convolution was not
 * performed to signal the caller to fall down to alternative/original
 * code-path.
 */
int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0, int num)
{	return 0;	}
#endif /* OPENSSL_BN_ASM_MONT */
#endif

d827 1
a827 1
void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)
d834 1
a834 1
void bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)
a858 47

#ifdef OPENSSL_NO_ASM
#ifdef OPENSSL_BN_ASM_MONT
#include <alloca.h>
int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0p, int num)
	{
	BN_ULONG c0,c1,*tp,n0=*n0p;
	volatile BN_ULONG *vp;
	int i=0,j;

	vp = tp = alloca((num+2)*sizeof(BN_ULONG));

	for(i=0;i<=num;i++)	tp[i]=0;

	for(i=0;i<num;i++)
		{
		c0         = bn_mul_add_words(tp,ap,num,bp[i]);
		c1         = (tp[num] + c0)&BN_MASK2;
		tp[num]    = c1;
		tp[num+1]  = (c1<c0?1:0);

		c0         = bn_mul_add_words(tp,np,num,tp[0]*n0);
		c1         = (tp[num] + c0)&BN_MASK2;
		tp[num]    = c1;
		tp[num+1] += (c1<c0?1:0);
		for(j=0;j<=num;j++)	tp[j]=tp[j+1];
		}

	if (tp[num]!=0 || tp[num-1]>=np[num-1])
		{
		c0 = bn_sub_words(rp,tp,np,num);
		if (tp[num]!=0 || c0==0)
			{
			for(i=0;i<num+2;i++)	vp[i] = 0;
			return 1;
			}
		}
	for(i=0;i<num;i++)	rp[i] = tp[i],	vp[i] = 0;
	vp[num]   = 0;
	vp[num+1] = 0;
	return 1;
	}
#else
int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp, const BN_ULONG *np,const BN_ULONG *n0, int num)
{	return 0;	}
#endif /* OPENSSL_BN_ASM_MONT */
#endif
@


