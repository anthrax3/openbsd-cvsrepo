head	1.30;
access;
symbols;
locks; strict;
comment	@ * @;


1.30
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.29;
commitid	kT0fLt3r4lroFJra;

1.29
date	2017.01.21.10.38.29;	author beck;	state Exp;
branches;
next	1.28;
commitid	hKAfCRL9IRQ9ENaK;

1.28
date	2017.01.21.09.38.58;	author beck;	state Exp;
branches;
next	1.27;
commitid	iyR9b2itDMsxzmrQ;

1.27
date	2017.01.21.04.34.16;	author beck;	state Exp;
branches;
next	1.26;
commitid	sEULB7b2pMrpmvBV;

1.26
date	2016.09.03.17.26.29;	author bcook;	state Exp;
branches;
next	1.25;
commitid	gzVEwruAHfwF5cjp;

1.25
date	2016.09.03.17.21.38;	author bcook;	state Exp;
branches;
next	1.24;
commitid	tNfJCHXW76mEWxif;

1.24
date	2016.09.03.14.37.52;	author bcook;	state Exp;
branches;
next	1.23;
commitid	2um1R7ADZr7unE0q;

1.23
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.22;
commitid	vHznCDK3idwNEFz4;

1.22
date	2015.03.21.08.05.20;	author doug;	state Exp;
branches;
next	1.21;
commitid	aAjfYOuLLKYzi2vC;

1.21
date	2015.02.14.15.13.24;	author miod;	state Exp;
branches;
next	1.20;
commitid	2BrDwkGA3CZnwSS9;

1.20
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.19;
commitid	69Tc75PIK8JcRRsC;

1.19
date	2014.07.11.15.01.49;	author miod;	state Exp;
branches;
next	1.18;
commitid	iXeVCQXZiqSBUfWZ;

1.18
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.17;
commitid	yQEL1wOWIearrW15;

1.17
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.16;
commitid	id8dTrTMtnTn4fqt;

1.16
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	mJUVYpkFBZ0Zv2bG;

1.15
date	2014.06.07.14.41.56;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	2nvnQBrv22dLtvTt;

1.14
date	2014.05.23.16.11.55;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.05.22.21.12.15;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2014.05.08.13.20.49;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.28.21.14.50;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.20;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.17;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.43;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.57;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.06.27.05.05.31;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.10.13.21.23.35;	author djm;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: bn_exp.c,v 1.29 2017/01/21 10:38:29 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdlib.h>
#include <string.h>

#include <openssl/err.h>

#include "bn_lcl.h"
#include "constant_time_locl.h"

/* maximum precomputation table size for *variable* sliding windows */
#define TABLE_SIZE	32

/* this one works - simple but works */
int
BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
{
	int i, bits, ret = 0;
	BIGNUM *v, *rr;

	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
		/* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
		BNerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return -1;
	}

	BN_CTX_start(ctx);
	if ((r == a) || (r == p))
		rr = BN_CTX_get(ctx);
	else
		rr = r;
	v = BN_CTX_get(ctx);
	if (rr == NULL || v == NULL)
		goto err;

	if (BN_copy(v, a) == NULL)
		goto err;
	bits = BN_num_bits(p);

	if (BN_is_odd(p)) {
		if (BN_copy(rr, a) == NULL)
			goto err;
	} else {
		if (!BN_one(rr))
			goto err;
	}

	for (i = 1; i < bits; i++) {
		if (!BN_sqr(v, v, ctx))
			goto err;
		if (BN_is_bit_set(p, i)) {
			if (!BN_mul(rr, rr, v, ctx))
				goto err;
		}
	}
	ret = 1;

err:
	if (r != rr && rr != NULL)
		BN_copy(r, rr);
	BN_CTX_end(ctx);
	bn_check_top(r);
	return (ret);
}

static int
BN_mod_exp_internal(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx, int ct)
{
	int ret;

	bn_check_top(a);
	bn_check_top(p);
	bn_check_top(m);

	/* For even modulus  m = 2^k*m_odd,  it might make sense to compute
	 * a^p mod m_odd  and  a^p mod 2^k  separately (with Montgomery
	 * exponentiation for the odd part), using appropriate exponent
	 * reductions, and combine the results using the CRT.
	 *
	 * For now, we use Montgomery only if the modulus is odd; otherwise,
	 * exponentiation using the reciprocal-based quick remaindering
	 * algorithm is used.
	 *
	 * (Timing obtained with expspeed.c [computations  a^p mod m
	 * where  a, p, m  are of the same length: 256, 512, 1024, 2048,
	 * 4096, 8192 bits], compared to the running time of the
	 * standard algorithm:
	 *
	 *   BN_mod_exp_mont   33 .. 40 %  [AMD K6-2, Linux, debug configuration]
         *                     55 .. 77 %  [UltraSparc processor, but
	 *                                  debug-solaris-sparcv8-gcc conf.]
	 *
	 *   BN_mod_exp_recp   50 .. 70 %  [AMD K6-2, Linux, debug configuration]
	 *                     62 .. 118 % [UltraSparc, debug-solaris-sparcv8-gcc]
	 *
	 * On the Sparc, BN_mod_exp_recp was faster than BN_mod_exp_mont
	 * at 2048 and more bits, but at 512 and 1024 bits, it was
	 * slower even than the standard algorithm!
	 *
	 * "Real" timings [linux-elf, solaris-sparcv9-gcc configurations]
	 * should be obtained when the new Montgomery reduction code
	 * has been integrated into OpenSSL.)
	 */

	if (BN_is_odd(m)) {
		if (a->top == 1 && !a->neg && !ct) {
			BN_ULONG A = a->d[0];
			ret = BN_mod_exp_mont_word(r, A,p, m,ctx, NULL);
		} else
			ret = BN_mod_exp_mont_ct(r, a,p, m,ctx, NULL);
	} else	{
		ret = BN_mod_exp_recp(r, a,p, m, ctx);
	}

	bn_check_top(r);
	return (ret);
}

int
BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx)
{
	return BN_mod_exp_internal(r, a, p, m, ctx,
	    (BN_get_flags(p, BN_FLG_CONSTTIME) != 0));
}

int
BN_mod_exp_ct(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx)
{
	return BN_mod_exp_internal(r, a, p, m, ctx, 1);
}


int
BN_mod_exp_nonct(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx)
{
	return BN_mod_exp_internal(r, a, p, m, ctx, 0);
}


int
BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx)
{
	int i, j, bits, ret = 0, wstart, wend, window, wvalue;
	int start = 1;
	BIGNUM *aa;
	/* Table of variables obtained from 'ctx' */
	BIGNUM *val[TABLE_SIZE];
	BN_RECP_CTX recp;

	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
		/* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
		BNerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return -1;
	}

	bits = BN_num_bits(p);
	if (bits == 0) {
		/* x**0 mod 1 is still zero. */
		if (BN_is_one(m)) {
			ret = 1;
			BN_zero(r);
		} else
			ret = BN_one(r);
		return ret;
	}

	BN_CTX_start(ctx);
	if ((aa = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((val[0] = BN_CTX_get(ctx)) == NULL)
		goto err;

	BN_RECP_CTX_init(&recp);
	if (m->neg) {
		/* ignore sign of 'm' */
		if (!BN_copy(aa, m))
			goto err;
		aa->neg = 0;
		if (BN_RECP_CTX_set(&recp, aa, ctx) <= 0)
			goto err;
	} else {
		if (BN_RECP_CTX_set(&recp, m, ctx) <= 0)
			goto err;
	}

	if (!BN_nnmod(val[0], a, m, ctx))
		goto err;		/* 1 */
	if (BN_is_zero(val[0])) {
		BN_zero(r);
		ret = 1;
		goto err;
	}

	window = BN_window_bits_for_exponent_size(bits);
	if (window > 1) {
		if (!BN_mod_mul_reciprocal(aa, val[0], val[0], &recp, ctx))
			goto err;				/* 2 */
		j = 1 << (window - 1);
		for (i = 1; i < j; i++) {
			if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
			    !BN_mod_mul_reciprocal(val[i], val[i - 1],
			    aa, &recp, ctx))
				goto err;
		}
	}

	start = 1;		/* This is used to avoid multiplication etc
				 * when there is only the value '1' in the
				 * buffer. */
	wvalue = 0;		/* The 'value' of the window */
	wstart = bits - 1;	/* The top bit of the window */
	wend = 0;		/* The bottom bit of the window */

	if (!BN_one(r))
		goto err;

	for (;;) {
		if (BN_is_bit_set(p, wstart) == 0) {
			if (!start)
				if (!BN_mod_mul_reciprocal(r, r,r, &recp, ctx))
					goto err;
			if (wstart == 0)
				break;
			wstart--;
			continue;
		}
		/* We now have wstart on a 'set' bit, we now need to work out
		 * how bit a window to do.  To do this we need to scan
		 * forward until the last set bit before the end of the
		 * window */
		j = wstart;
		wvalue = 1;
		wend = 0;
		for (i = 1; i < window; i++) {
			if (wstart - i < 0)
				break;
			if (BN_is_bit_set(p, wstart - i)) {
				wvalue <<= (i - wend);
				wvalue |= 1;
				wend = i;
			}
		}

		/* wend is the size of the current window */
		j = wend + 1;
		/* add the 'bytes above' */
		if (!start)
			for (i = 0; i < j; i++) {
				if (!BN_mod_mul_reciprocal(r, r,r, &recp, ctx))
					goto err;
			}

		/* wvalue will be an odd number < 2^window */
		if (!BN_mod_mul_reciprocal(r, r,val[wvalue >> 1], &recp, ctx))
			goto err;

		/* move the 'window' down further */
		wstart -= wend + 1;
		wvalue = 0;
		start = 0;
		if (wstart < 0)
			break;
	}
	ret = 1;

err:
	BN_CTX_end(ctx);
	BN_RECP_CTX_free(&recp);
	bn_check_top(r);
	return (ret);
}

static int
BN_mod_exp_mont_internal(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx, BN_MONT_CTX *in_mont, int ct)
{
	int i, j, bits, ret = 0, wstart, wend, window, wvalue;
	int start = 1;
	BIGNUM *d, *r;
	const BIGNUM *aa;
	/* Table of variables obtained from 'ctx' */
	BIGNUM *val[TABLE_SIZE];
	BN_MONT_CTX *mont = NULL;

	if (ct) {
		return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);
	}

	bn_check_top(a);
	bn_check_top(p);
	bn_check_top(m);

	if (!BN_is_odd(m)) {
		BNerror(BN_R_CALLED_WITH_EVEN_MODULUS);
		return (0);
	}

	bits = BN_num_bits(p);
	if (bits == 0) {
		/* x**0 mod 1 is still zero. */
		if (BN_is_one(m)) {
			ret = 1;
			BN_zero(rr);
		} else
			ret = BN_one(rr);
		return ret;
	}

	BN_CTX_start(ctx);
	if ((d = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((r = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((val[0] = BN_CTX_get(ctx)) == NULL)
		goto err;

	/* If this is not done, things will break in the montgomery
	 * part */

	if (in_mont != NULL)
		mont = in_mont;
	else {
		if ((mont = BN_MONT_CTX_new()) == NULL)
			goto err;
		if (!BN_MONT_CTX_set(mont, m, ctx))
			goto err;
	}

	if (a->neg || BN_ucmp(a, m) >= 0) {
		if (!BN_nnmod(val[0], a,m, ctx))
			goto err;
		aa = val[0];
	} else
		aa = a;
	if (BN_is_zero(aa)) {
		BN_zero(rr);
		ret = 1;
		goto err;
	}
	if (!BN_to_montgomery(val[0], aa, mont, ctx))
		goto err; /* 1 */

	window = BN_window_bits_for_exponent_size(bits);
	if (window > 1) {
		if (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx))
			goto err; /* 2 */
		j = 1 << (window - 1);
		for (i = 1; i < j; i++) {
			if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
			    !BN_mod_mul_montgomery(val[i], val[i - 1],
			    d, mont, ctx))
				goto err;
		}
	}

	start = 1;		/* This is used to avoid multiplication etc
				 * when there is only the value '1' in the
				 * buffer. */
	wvalue = 0;		/* The 'value' of the window */
	wstart = bits - 1;	/* The top bit of the window */
	wend = 0;		/* The bottom bit of the window */

	if (!BN_to_montgomery(r, BN_value_one(), mont, ctx))
		goto err;
	for (;;) {
		if (BN_is_bit_set(p, wstart) == 0) {
			if (!start) {
				if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
					goto err;
			}
			if (wstart == 0)
				break;
			wstart--;
			continue;
		}
		/* We now have wstart on a 'set' bit, we now need to work out
		 * how bit a window to do.  To do this we need to scan
		 * forward until the last set bit before the end of the
		 * window */
		j = wstart;
		wvalue = 1;
		wend = 0;
		for (i = 1; i < window; i++) {
			if (wstart - i < 0)
				break;
			if (BN_is_bit_set(p, wstart - i)) {
				wvalue <<= (i - wend);
				wvalue |= 1;
				wend = i;
			}
		}

		/* wend is the size of the current window */
		j = wend + 1;
		/* add the 'bytes above' */
		if (!start)
			for (i = 0; i < j; i++) {
				if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
					goto err;
			}

		/* wvalue will be an odd number < 2^window */
		if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx))
			goto err;

		/* move the 'window' down further */
		wstart -= wend + 1;
		wvalue = 0;
		start = 0;
		if (wstart < 0)
			break;
	}
	if (!BN_from_montgomery(rr, r,mont, ctx))
		goto err;
	ret = 1;

err:
	if ((in_mont == NULL) && (mont != NULL))
		BN_MONT_CTX_free(mont);
	BN_CTX_end(ctx);
	bn_check_top(rr);
	return (ret);
}

int
BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
	return BN_mod_exp_mont_internal(rr, a, p, m, ctx, in_mont,
	    (BN_get_flags(p, BN_FLG_CONSTTIME) != 0));
}

int
BN_mod_exp_mont_ct(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
	return BN_mod_exp_mont_internal(rr, a, p, m, ctx, in_mont, 1);
}

int
BN_mod_exp_mont_nonct(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
	return BN_mod_exp_mont_internal(rr, a, p, m, ctx, in_mont, 0);
}

/* BN_mod_exp_mont_consttime() stores the precomputed powers in a specific layout
 * so that accessing any of these table values shows the same access pattern as far
 * as cache lines are concerned.  The following functions are used to transfer a BIGNUM
 * from/to that table. */

static int
MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top, unsigned char *buf,
    int idx, int window)
{
	int i, j;
	int width = 1 << window;
	BN_ULONG *table = (BN_ULONG *)buf;

	if (top > b->top)
		top = b->top; /* this works because 'buf' is explicitly zeroed */

	for (i = 0, j = idx; i < top; i++, j += width) {
		table[j] = b->d[i];
	}

	return 1;
}

static int
MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx,
    int window)
{
	int i, j;
	int width = 1 << window;
	volatile BN_ULONG *table = (volatile BN_ULONG *)buf;

	if (bn_wexpand(b, top) == NULL)
		return 0;

	if (window <= 3) {
		for (i = 0; i < top; i++, table += width) {
		    BN_ULONG acc = 0;

		    for (j = 0; j < width; j++) {
			acc |= table[j] &
			       ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
		    }

		    b->d[i] = acc;
		}
	} else {
		int xstride = 1 << (window - 2);
		BN_ULONG y0, y1, y2, y3;

		i = idx >> (window - 2);        /* equivalent of idx / xstride */
		idx &= xstride - 1;             /* equivalent of idx % xstride */

		y0 = (BN_ULONG)0 - (constant_time_eq_int(i,0)&1);
		y1 = (BN_ULONG)0 - (constant_time_eq_int(i,1)&1);
		y2 = (BN_ULONG)0 - (constant_time_eq_int(i,2)&1);
		y3 = (BN_ULONG)0 - (constant_time_eq_int(i,3)&1);

		for (i = 0; i < top; i++, table += width) {
		    BN_ULONG acc = 0;

		    for (j = 0; j < xstride; j++) {
			acc |= ( (table[j + 0 * xstride] & y0) |
				 (table[j + 1 * xstride] & y1) |
				 (table[j + 2 * xstride] & y2) |
				 (table[j + 3 * xstride] & y3) )
			       & ((BN_ULONG)0 - (constant_time_eq_int(j,idx)&1));
		    }

		    b->d[i] = acc;
		}
	}
	b->top = top;
	bn_correct_top(b);
	return 1;
}

/* Given a pointer value, compute the next address that is a cache line multiple. */
#define MOD_EXP_CTIME_ALIGN(x_) \
	((unsigned char*)(x_) + (MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH - (((size_t)(x_)) & (MOD_EXP_CTIME_MIN_CACHE_LINE_MASK))))

/* This variant of BN_mod_exp_mont() uses fixed windows and the special
 * precomputation memory layout to limit data-dependency to a minimum
 * to protect secret exponents (cf. the hyper-threading timing attacks
 * pointed out by Colin Percival,
 * http://www.daemonology.net/hyperthreading-considered-harmful/)
 */
int
BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
	int i, bits, ret = 0, window, wvalue;
	int top;
	BN_MONT_CTX *mont = NULL;
	int numPowers;
	unsigned char *powerbufFree = NULL;
	int powerbufLen = 0;
	unsigned char *powerbuf = NULL;
	BIGNUM tmp, am;

	bn_check_top(a);
	bn_check_top(p);
	bn_check_top(m);

	if (!BN_is_odd(m)) {
		BNerror(BN_R_CALLED_WITH_EVEN_MODULUS);
		return (0);
	}

	top = m->top;

	bits = BN_num_bits(p);
	if (bits == 0) {
		/* x**0 mod 1 is still zero. */
		if (BN_is_one(m)) {
			ret = 1;
			BN_zero(rr);
		} else
			ret = BN_one(rr);
		return ret;
	}

	BN_CTX_start(ctx);

	/* Allocate a montgomery context if it was not supplied by the caller.
	 * If this is not done, things will break in the montgomery part.
 	 */
	if (in_mont != NULL)
		mont = in_mont;
	else {
		if ((mont = BN_MONT_CTX_new()) == NULL)
			goto err;
		if (!BN_MONT_CTX_set(mont, m, ctx))
			goto err;
	}

	/* Get the window size to use with size of p. */
	window = BN_window_bits_for_ctime_exponent_size(bits);
#if defined(OPENSSL_BN_ASM_MONT5)
	if (window == 6 && bits <= 1024)
		window = 5;	/* ~5% improvement of 2048-bit RSA sign */
#endif

	/* Allocate a buffer large enough to hold all of the pre-computed
	 * powers of am, am itself and tmp.
	 */
	numPowers = 1 << window;
	powerbufLen = sizeof(m->d[0]) * (top * numPowers +
	    ((2*top) > numPowers ? (2*top) : numPowers));
	if ((powerbufFree = malloc(powerbufLen +
	    MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH)) == NULL)
		goto err;

	powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);
	memset(powerbuf, 0, powerbufLen);

	/* lay down tmp and am right after powers table */
	tmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);
	am.d = tmp.d + top;
	tmp.top = am.top = 0;
	tmp.dmax = am.dmax = top;
	tmp.neg = am.neg = 0;
	tmp.flags = am.flags = BN_FLG_STATIC_DATA;

	/* prepare a^0 in Montgomery domain */
#if 1
	if (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))
		goto err;
#else
	tmp.d[0] = (0 - m - >d[0]) & BN_MASK2;	/* 2^(top*BN_BITS2) - m */
	for (i = 1; i < top; i++)
		tmp.d[i] = (~m->d[i]) & BN_MASK2;
	tmp.top = top;
#endif

	/* prepare a^1 in Montgomery domain */
	if (a->neg || BN_ucmp(a, m) >= 0) {
		if (!BN_mod_ct(&am, a,m, ctx))
			goto err;
		if (!BN_to_montgomery(&am, &am, mont, ctx))
			goto err;
	} else if (!BN_to_montgomery(&am, a,mont, ctx))
		goto err;

#if defined(OPENSSL_BN_ASM_MONT5)
	/* This optimization uses ideas from http://eprint.iacr.org/2011/239,
	 * specifically optimization of cache-timing attack countermeasures
	 * and pre-computation optimization. */

	/* Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as
	 * 512-bit RSA is hardly relevant, we omit it to spare size... */
	if (window == 5 && top > 1) {
		void bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,
		    const void *table, const BN_ULONG *np,
		    const BN_ULONG *n0, int num, int power);
		void bn_scatter5(const BN_ULONG *inp, size_t num,
		    void *table, size_t power);
		void bn_gather5(BN_ULONG *out, size_t num,
		    void *table, size_t power);

		BN_ULONG *np = mont->N.d, *n0 = mont->n0;

		/* BN_to_montgomery can contaminate words above .top
		 * [in BN_DEBUG[_DEBUG] build]... */
		for (i = am.top; i < top; i++)
			am.d[i] = 0;
		for (i = tmp.top; i < top; i++)
			tmp.d[i] = 0;

		bn_scatter5(tmp.d, top, powerbuf, 0);
		bn_scatter5(am.d, am.top, powerbuf, 1);
		bn_mul_mont(tmp.d, am.d, am.d, np, n0, top);
		bn_scatter5(tmp.d, top, powerbuf, 2);

#if 0
		for (i = 3; i < 32; i++) {
			/* Calculate a^i = a^(i-1) * a */
			bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np,
			    n0, top, i - 1);
			bn_scatter5(tmp.d, top, powerbuf, i);
		}
#else
		/* same as above, but uses squaring for 1/2 of operations */
		for (i = 4; i < 32; i*=2) {
			bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
			bn_scatter5(tmp.d, top, powerbuf, i);
		}
		for (i = 3; i < 8; i += 2) {
			int j;
			bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np,
			    n0, top, i - 1);
			bn_scatter5(tmp.d, top, powerbuf, i);
			for (j = 2 * i; j < 32; j *= 2) {
				bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
				bn_scatter5(tmp.d, top, powerbuf, j);
			}
		}
		for (; i < 16; i += 2) {
			bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np,
			    n0, top, i - 1);
			bn_scatter5(tmp.d, top, powerbuf, i);
			bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
			bn_scatter5(tmp.d, top, powerbuf, 2*i);
		}
		for (; i < 32; i += 2) {
			bn_mul_mont_gather5(tmp.d, am.d, powerbuf, np,
			    n0, top, i - 1);
			bn_scatter5(tmp.d, top, powerbuf, i);
		}
#endif
		bits--;
		for (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)
			wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
		bn_gather5(tmp.d, top, powerbuf, wvalue);

		/* Scan the exponent one window at a time starting from the most
		 * significant bits.
		 */
		while (bits >= 0) {
			for (wvalue = 0, i = 0; i < 5; i++, bits--)
				wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);

			bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
			bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
			bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
			bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
			bn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);
			bn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top, wvalue);
		}

		tmp.top = top;
		bn_correct_top(&tmp);
	} else
#endif
	{
		if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0,
		    window))
			goto err;
		if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am,  top, powerbuf, 1,
		    window))
			goto err;

		/* If the window size is greater than 1, then calculate
		 * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1)
		 * (even powers could instead be computed as (a^(i/2))^2
		 * to use the slight performance advantage of sqr over mul).
		 */
		if (window > 1) {
			if (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))
				goto err;
			if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf,
			    2, window))
				goto err;
			for (i = 3; i < numPowers; i++) {
				/* Calculate a^i = a^(i-1) * a */
				if (!BN_mod_mul_montgomery(&tmp, &am, &tmp,
				    mont, ctx))
					goto err;
				if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top,
				    powerbuf, i, window))
					goto err;
			}
		}

		bits--;
		for (wvalue = 0, i = bits % window; i >= 0; i--, bits--)
			wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
		if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp, top, powerbuf,
		    wvalue, window))
			goto err;

		/* Scan the exponent one window at a time starting from the most
		 * significant bits.
		 */
		while (bits >= 0) {
			wvalue = 0; /* The 'value' of the window */

			/* Scan the window, squaring the result as we go */
			for (i = 0; i < window; i++, bits--) {
				if (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp,
				    mont, ctx))
					goto err;
				wvalue = (wvalue << 1) + BN_is_bit_set(p, bits);
			}

			/* Fetch the appropriate pre-computed value from the pre-buf */
			if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf,
			    wvalue, window))
				goto err;

			/* Multiply the result into the intermediate result */
			if (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx))
				goto err;
		}
	}

	/* Convert the final result from montgomery to standard format */
	if (!BN_from_montgomery(rr, &tmp, mont, ctx))
		goto err;
	ret = 1;

err:
	if ((in_mont == NULL) && (mont != NULL))
		BN_MONT_CTX_free(mont);
	if (powerbuf != NULL) {
		explicit_bzero(powerbuf, powerbufLen);
		free(powerbufFree);
	}
	BN_CTX_end(ctx);
	return (ret);
}

int
BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
	BN_MONT_CTX *mont = NULL;
	int b, bits, ret = 0;
	int r_is_one;
	BN_ULONG w, next_w;
	BIGNUM *d, *r, *t;
	BIGNUM *swap_tmp;

#define BN_MOD_MUL_WORD(r, w, m) \
		(BN_mul_word(r, (w)) && \
		(/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \
			(BN_mod_ct(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))
		/* BN_MOD_MUL_WORD is only used with 'w' large,
		 * so the BN_ucmp test is probably more overhead
		 * than always using BN_mod (which uses BN_copy if
		 * a similar test returns true). */
		/* We can use BN_mod and do not need BN_nnmod because our
		 * accumulator is never negative (the result of BN_mod does
		 * not depend on the sign of the modulus).
		 */
#define BN_TO_MONTGOMERY_WORD(r, w, mont) \
		(BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))

	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
		/* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
		BNerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return -1;
	}

	bn_check_top(p);
	bn_check_top(m);

	if (!BN_is_odd(m)) {
		BNerror(BN_R_CALLED_WITH_EVEN_MODULUS);
		return (0);
	}
	if (m->top == 1)
		a %= m->d[0]; /* make sure that 'a' is reduced */

	bits = BN_num_bits(p);
	if (bits == 0) {
		/* x**0 mod 1 is still zero. */
		if (BN_is_one(m)) {
			ret = 1;
			BN_zero(rr);
		} else
			ret = BN_one(rr);
		return ret;
	}
	if (a == 0) {
		BN_zero(rr);
		ret = 1;
		return ret;
	}

	BN_CTX_start(ctx);
	if ((d = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((r = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((t = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (in_mont != NULL)
		mont = in_mont;
	else {
		if ((mont = BN_MONT_CTX_new()) == NULL)
			goto err;
		if (!BN_MONT_CTX_set(mont, m, ctx))
			goto err;
	}

	r_is_one = 1; /* except for Montgomery factor */

	/* bits-1 >= 0 */

	/* The result is accumulated in the product r*w. */
	w = a; /* bit 'bits-1' of 'p' is always set */
	for (b = bits - 2; b >= 0; b--) {
		/* First, square r*w. */
		next_w = w * w;
		if ((next_w / w) != w) /* overflow */
		{
			if (r_is_one) {
				if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
					goto err;
				r_is_one = 0;
			} else {
				if (!BN_MOD_MUL_WORD(r, w, m))
					goto err;
			}
			next_w = 1;
		}
		w = next_w;
		if (!r_is_one) {
			if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
				goto err;
		}

		/* Second, multiply r*w by 'a' if exponent bit is set. */
		if (BN_is_bit_set(p, b)) {
			next_w = w * a;
			if ((next_w / a) != w) /* overflow */
			{
				if (r_is_one) {
					if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
						goto err;
					r_is_one = 0;
				} else {
					if (!BN_MOD_MUL_WORD(r, w, m))
						goto err;
				}
				next_w = a;
			}
			w = next_w;
		}
	}

	/* Finally, set r:=r*w. */
	if (w != 1) {
		if (r_is_one) {
			if (!BN_TO_MONTGOMERY_WORD(r, w, mont))
				goto err;
			r_is_one = 0;
		} else {
			if (!BN_MOD_MUL_WORD(r, w, m))
				goto err;
		}
	}

	if (r_is_one) /* can happen only if a == 1*/
	{
		if (!BN_one(rr))
			goto err;
	} else {
		if (!BN_from_montgomery(rr, r, mont, ctx))
			goto err;
	}
	ret = 1;

err:
	if ((in_mont == NULL) && (mont != NULL))
		BN_MONT_CTX_free(mont);
	BN_CTX_end(ctx);
	bn_check_top(rr);
	return (ret);
}


/* The old fallback, simple version :-) */
int
BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx)
{
	int i, j, bits, ret = 0, wstart, wend, window, wvalue;
	int start = 1;
	BIGNUM *d;
	/* Table of variables obtained from 'ctx' */
	BIGNUM *val[TABLE_SIZE];

	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
		/* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
		BNerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return -1;
	}

	bits = BN_num_bits(p);
	if (bits == 0) {
		/* x**0 mod 1 is still zero. */
		if (BN_is_one(m)) {
			ret = 1;
			BN_zero(r);
		} else
			ret = BN_one(r);
		return ret;
	}

	BN_CTX_start(ctx);
	if ((d = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((val[0] = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_nnmod(val[0],a,m,ctx))
		goto err;		/* 1 */
	if (BN_is_zero(val[0])) {
		BN_zero(r);
		ret = 1;
		goto err;
	}

	window = BN_window_bits_for_exponent_size(bits);
	if (window > 1) {
		if (!BN_mod_mul(d, val[0], val[0], m, ctx))
			goto err;				/* 2 */
		j = 1 << (window - 1);
		for (i = 1; i < j; i++) {
			if (((val[i] = BN_CTX_get(ctx)) == NULL) ||
			    !BN_mod_mul(val[i], val[i - 1], d,m, ctx))
				goto err;
		}
	}

	start = 1;		/* This is used to avoid multiplication etc
				 * when there is only the value '1' in the
				 * buffer. */
	wvalue = 0;		/* The 'value' of the window */
	wstart = bits - 1;	/* The top bit of the window */
	wend = 0;		/* The bottom bit of the window */

	if (!BN_one(r))
		goto err;

	for (;;) {
		if (BN_is_bit_set(p, wstart) == 0) {
			if (!start)
				if (!BN_mod_mul(r, r, r, m, ctx))
					goto err;
			if (wstart == 0)
				break;
			wstart--;
			continue;
		}
		/* We now have wstart on a 'set' bit, we now need to work out
		 * how bit a window to do.  To do this we need to scan
		 * forward until the last set bit before the end of the
		 * window */
		j = wstart;
		wvalue = 1;
		wend = 0;
		for (i = 1; i < window; i++) {
			if (wstart - i < 0)
				break;
			if (BN_is_bit_set(p, wstart - i)) {
				wvalue <<= (i - wend);
				wvalue |= 1;
				wend = i;
			}
		}

		/* wend is the size of the current window */
		j = wend + 1;
		/* add the 'bytes above' */
		if (!start)
			for (i = 0; i < j; i++) {
				if (!BN_mod_mul(r, r, r, m, ctx))
					goto err;
			}

		/* wvalue will be an odd number < 2^window */
		if (!BN_mod_mul(r, r, val[wvalue >> 1], m, ctx))
			goto err;

		/* move the 'window' down further */
		wstart -= wend + 1;
		wvalue = 0;
		start = 0;
		if (wstart < 0)
			break;
	}
	ret = 1;

err:
	BN_CTX_end(ctx);
	bn_check_top(r);
	return (ret);
}
@


1.29
log
@Split out BN_div and BN_mod into ct and nonct versions for Internal use.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.28 2017/01/21 09:38:58 beck Exp $ */
d132 1
a132 1
		BNerr(BN_F_BN_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d266 1
a266 1
		BNerr(BN_F_BN_MOD_EXP_RECP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d408 1
a408 1
		BNerr(BN_F_BN_MOD_EXP_MONT, BN_R_CALLED_WITH_EVEN_MODULUS);
d665 1
a665 2
		BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME,
		    BN_R_CALLED_WITH_EVEN_MODULUS);
d940 1
a940 2
		BNerr(BN_F_BN_MOD_EXP_MONT_WORD,
		    ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d948 1
a948 1
		BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);
d1077 1
a1077 2
		BNerr(BN_F_BN_MOD_EXP_SIMPLE,
		    ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
@


1.28
log
@Make explicit _ct and _nonct versions of bn_mod_exp funcitons that
matter for constant time, and make the public interface only used
external to the library.

This moves us to a model where the important things are constant time
versions unless you ask for them not to be, rather than the opposite.
I'll continue with this method by method.

Add regress tests for same.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.27 2017/01/21 04:34:16 beck Exp $ */
d738 1
a738 1
		if (!BN_mod(&am, a,m, ctx))
d927 1
a927 1
			(BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))
@


1.27
log
@/usr/bin/unifdef -D MONT_MUL_MOD -D MONT_EXP_WORD -D RECP_MUL_MOD -m bn_exp.c
with some style cleanup after. no binary change
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.26 2016/09/03 17:26:29 bcook Exp $ */
d175 3
a177 3
int
BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx)
d216 1
a216 2
		if (a->top == 1 && !a->neg &&
		    (BN_get_flags(p, BN_FLG_CONSTTIME) == 0)) {
d220 1
a220 1
			ret = BN_mod_exp_mont(r, a,p, m,ctx, NULL);
d230 24
d387 3
a389 3
int
BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
    BN_CTX *ctx, BN_MONT_CTX *in_mont)
d399 1
a399 1
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {
d539 21
@


1.26
log
@add constant-time MOD_EXP_CTIME_COPY_FROM_PREBUF.

Patch based on OpenSSL commit d7a854c055ff22fb7da80c3b0e7cb08d248591d0

"Performance penalty varies from platform to platform, and even
key length. For rsa2048 sign it was observed to reach almost 10%."

CVE-2016-0702
ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.25 2016/09/03 17:21:38 bcook Exp $ */
a214 11
#define MONT_MUL_MOD
#define MONT_EXP_WORD
#define RECP_MUL_MOD

#ifdef MONT_MUL_MOD
	/* I have finally been able to take out this pre-condition of
	 * the top bit being set.  It was caused by an error in BN_div
	 * with negatives.  There was also another problem when for a^b%m
	 * a >= m.  eay 07-May-97 */
/*	if ((m->d[m->top-1]&BN_TBIT) && BN_is_odd(m)) */

a215 1
#  ifdef MONT_EXP_WORD
a220 1
#  endif
d222 1
a222 4
	} else
#endif
#ifdef RECP_MUL_MOD
	{
a224 5
#else
	{
		ret = BN_mod_exp_simple(r, a,p, m, ctx);
	}
#endif
@


1.25
log
@BN_mod_exp_mont_consttime: check for zero modulus.

Don't dereference d when top is zero.

Original patch from OpenSSL commit d46e946d2603c64df6e1e4f9db0c70baaf1c4c03
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.24 2016/09/03 14:37:52 bcook Exp $ */
d118 1
d545 1
a545 1
    int idx, int width)
d547 3
a549 1
	size_t i, j;
d553 3
a555 2
	for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
		buf[j] = ((unsigned char*)b->d)[i];
d563 1
a563 1
    int width)
d565 3
a567 1
	size_t i, j;
d572 36
a607 2
	for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
		((unsigned char*)b->d)[i] = buf[j];
a608 1

d814 1
a814 1
		    numPowers))
d817 1
a817 1
		    numPowers))
d829 1
a829 1
			    2, numPowers))
d837 1
a837 1
				    powerbuf, i, numPowers))
d846 1
a846 1
		    wvalue, numPowers))
d865 1
a865 1
			    wvalue, numPowers))
@


1.24
log
@BN_mod_exp_mont_consttime: check for zero modulus.

Don't dereference |d| when |top| is zero. Also test that various
BIGNUM methods behave correctly on zero/even inputs.

Original patch from OpenSSL commit d46e946d2603c64df6e1e4f9db0c70baaf1c4c03
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.23 2015/09/10 15:56:25 jsing Exp $ */
a267 1

d269 6
a274 1
		ret = BN_one(r);
d408 1
d411 6
a416 1
		ret = BN_one(rr);
d612 6
a617 1
		ret = BN_one(rr);
d896 6
a901 1
		ret = BN_one(rr);
d1009 1
a1009 1
	int i, j,bits, ret = 0, wstart, wend, window, wvalue;
a1022 1

d1024 6
a1029 1
		ret = BN_one(r);
@


1.23
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.22 2015/03/21 08:05:20 doug Exp $ */
d592 1
a592 3
	top = m->top;

	if (!(m->d[0] & 1)) {
d597 3
@


1.22
log
@Fix indentation that incorrectly implies a different control flow.

The actual control flow is intentional while the indenting is incorrect.
This is intended to be a cosmetic change.

Verified that each of these was part of a KNF commit that wasn't intending
to change behavior.  Also, double checked against the history of changes in
OpenSSL and BoringSSL.

Addresses Coverity CIDs: 78842, 78859, 78863.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.21 2015/02/14 15:13:24 miod Exp $ */
d828 1
a828 1
		OPENSSL_cleanse(powerbuf, powerbufLen);
@


1.21
log
@Potential NULL dereference in the error path; Coverity CID 21720
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.20 2015/02/09 15:49:22 jsing Exp $ */
d877 2
a878 1
		bits = BN_num_bits(p);
@


1.20
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.19 2014/07/11 15:01:49 miod Exp $ */
d167 1
a167 1
	if (r != rr)
@


1.19
log
@Apparently better fix for OpenSSL PR #3397 (Joyent bug #7704), from OpenSSL
trunk
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.18 2014/07/11 08:44:47 jsing Exp $ */
d275 3
a277 3
	aa = BN_CTX_get(ctx);
	val[0] = BN_CTX_get(ctx);
	if (!aa || !val[0])
d411 5
a415 4
	d = BN_CTX_get(ctx);
	r = BN_CTX_get(ctx);
	val[0] = BN_CTX_get(ctx);
	if (!d || !r || !val[0])
d889 5
a893 4
	d = BN_CTX_get(ctx);
	r = BN_CTX_get(ctx);
	t = BN_CTX_get(ctx);
	if (d == NULL || r == NULL || t == NULL)
d1008 3
a1010 3
	d = BN_CTX_get(ctx);
	val[0] = BN_CTX_get(ctx);
	if (!d || !val[0])
@


1.18
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.17 2014/07/10 13:58:22 jsing Exp $ */
d673 1
a673 1
	if (window == 5) {
@


1.17
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_exp.c,v 1.16 2014/06/12 15:49:28 deraadt Exp $ */
d115 2
a116 1
#include "cryptlib.h"
@


1.16
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d112 2
a116 2

#include <stdlib.h>
@


1.15
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/bn/bn_exp.c */
@


1.14
log
@Replace (sometimes conditional) use of alloca with malloc, and clearing
through volatile pointers with explicit_bzero().

ok beck@@ jsing@@
@
text
@d630 1
a630 1
	if ((powerbufFree = (unsigned char*)malloc(powerbufLen +
@


1.13
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@a116 5
#if defined(__GNUC__)
# ifndef alloca
#  define alloca(s) __builtin_alloca((s))
# endif
#endif
a629 6
#ifdef alloca
	if (powerbufLen < 3072)
		powerbufFree = alloca(powerbufLen +
		    MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);
	else
#endif
a635 5

#ifdef alloca
	if (powerbufLen < 3072)
		powerbufFree = NULL;
#endif
@


1.12
log
@Emergency knfectomie requested by tedu@@.
@
text
@d843 1
a843 2
		if (powerbufFree)
			free(powerbufFree);
@


1.11
log
@Remove WIN32, WIN64 and MINGW32 tentacles.
Also check for _LP64 rather than __arch64__ (the former being more reliable
than __LP64__ or __arch64__) to tell 64-bit int platforms apart from 32-bit
int platforms.

Loosely based upon a diff from Martijn van Duren on tech@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d127 5
a131 4
int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
	{
	int i,bits,ret=0;
	BIGNUM *v,*rr;
d133 1
a133 2
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
		{
d135 1
a135 1
		BNerr(BN_F_BN_EXP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d137 1
a137 1
		}
d145 2
a146 1
	if (rr == NULL || v == NULL) goto err;
d148 3
a150 2
	if (BN_copy(v,a) == NULL) goto err;
	bits=BN_num_bits(p);
d152 7
a158 3
	if (BN_is_odd(p))
		{ if (BN_copy(rr,a) == NULL) goto err; }
	else	{ if (!BN_one(rr)) goto err; }
d160 6
a165 7
	for (i=1; i<bits; i++)
		{
		if (!BN_sqr(v,v,ctx)) goto err;
		if (BN_is_bit_set(p,i))
			{
			if (!BN_mul(rr,rr,v,ctx)) goto err;
			}
d167 3
a169 1
	ret=1;
d171 2
a172 1
	if (r != rr) BN_copy(r,rr);
d175 2
a176 2
	return(ret);
	}
d178 4
a181 4

int BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
	       BN_CTX *ctx)
	{
d205 1
a205 1
	 * 
d229 1
a229 2
	if (BN_is_odd(m))
		{
d231 2
a232 2
		if (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_CONSTTIME) == 0))
			{
d234 2
a235 3
			ret=BN_mod_exp_mont_word(r,A,p,m,ctx,NULL);
			}
		else
d237 2
a238 3
			ret=BN_mod_exp_mont(r,a,p,m,ctx,NULL);
		}
	else
d241 3
a243 1
		{ ret=BN_mod_exp_recp(r,a,p,m,ctx); }
d245 3
a247 1
		{ ret=BN_mod_exp_simple(r,a,p,m,ctx); }
d251 2
a252 3
	return(ret);
	}

d254 6
a259 5
int BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
		    const BIGNUM *m, BN_CTX *ctx)
	{
	int i,j,bits,ret=0,wstart,wend,window,wvalue;
	int start=1;
d265 1
a265 2
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
		{
d267 1
a267 1
		BNerr(BN_F_BN_MOD_EXP_RECP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d269 1
a269 1
		}
d271 1
a271 1
	bits=BN_num_bits(p);
d273 1
a273 2
	if (bits == 0)
		{
d276 1
a276 1
		}
d281 2
a282 1
	if(!aa || !val[0]) goto err;
d285 1
a285 2
	if (m->neg)
		{
d287 2
a288 1
		if (!BN_copy(aa, m)) goto err;
d290 6
a295 6
		if (BN_RECP_CTX_set(&recp,aa,ctx) <= 0) goto err;
		}
	else
		{
		if (BN_RECP_CTX_set(&recp,m,ctx) <= 0) goto err;
		}
d297 3
a299 3
	if (!BN_nnmod(val[0],a,m,ctx)) goto err;		/* 1 */
	if (BN_is_zero(val[0]))
		{
d303 1
a303 1
		}
d306 2
a307 3
	if (window > 1)
		{
		if (!BN_mod_mul_reciprocal(aa,val[0],val[0],&recp,ctx))
d309 5
a313 6
		j=1<<(window-1);
		for (i=1; i<j; i++)
			{
			if(((val[i] = BN_CTX_get(ctx)) == NULL) ||
					!BN_mod_mul_reciprocal(val[i],val[i-1],
						aa,&recp,ctx))
a314 1
			}
d316 8
a323 7
		
	start=1;	/* This is used to avoid multiplication etc
			 * when there is only the value '1' in the
			 * buffer. */
	wvalue=0;	/* The 'value' of the window */
	wstart=bits-1;	/* The top bit of the window */
	wend=0;		/* The bottom bit of the window */
d325 2
a326 1
	if (!BN_one(r)) goto err;
d328 2
a329 4
	for (;;)
		{
		if (BN_is_bit_set(p,wstart) == 0)
			{
d331 4
a334 3
				if (!BN_mod_mul_reciprocal(r,r,r,&recp,ctx))
				goto err;
			if (wstart == 0) break;
d337 1
a337 1
			}
d342 10
a351 12
		j=wstart;
		wvalue=1;
		wend=0;
		for (i=1; i<window; i++)
			{
			if (wstart-i < 0) break;
			if (BN_is_bit_set(p,wstart-i))
				{
				wvalue<<=(i-wend);
				wvalue|=1;
				wend=i;
				}
d353 1
d356 1
a356 1
		j=wend+1;
d359 2
a360 3
			for (i=0; i<j; i++)
				{
				if (!BN_mod_mul_reciprocal(r,r,r,&recp,ctx))
d362 2
a363 2
				}
		
d365 1
a365 1
		if (!BN_mod_mul_reciprocal(r,r,val[wvalue>>1],&recp,ctx))
d369 8
a376 6
		wstart-=wend+1;
		wvalue=0;
		start=0;
		if (wstart < 0) break;
		}
	ret=1;
d381 2
a382 3
	return(ret);
	}

d384 7
a390 6
int BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
		    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
	{
	int i,j,bits,ret=0,wstart,wend,window,wvalue;
	int start=1;
	BIGNUM *d,*r;
d394 1
a394 1
	BN_MONT_CTX *mont=NULL;
d396 1
a396 2
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
		{
d398 1
a398 1
		}
d404 6
a409 8
	if (!BN_is_odd(m))
		{
		BNerr(BN_F_BN_MOD_EXP_MONT,BN_R_CALLED_WITH_EVEN_MODULUS);
		return(0);
		}
	bits=BN_num_bits(p);
	if (bits == 0)
		{
d412 1
a412 1
		}
d418 2
a419 1
	if (!d || !r || !val[0]) goto err;
d425 7
a431 6
		mont=in_mont;
	else
		{
		if ((mont=BN_MONT_CTX_new()) == NULL) goto err;
		if (!BN_MONT_CTX_set(mont,m,ctx)) goto err;
		}
d433 2
a434 3
	if (a->neg || BN_ucmp(a,m) >= 0)
		{
		if (!BN_nnmod(val[0],a,m,ctx))
d436 4
a439 6
		aa= val[0];
		}
	else
		aa=a;
	if (BN_is_zero(aa))
		{
d443 3
a445 2
		}
	if (!BN_to_montgomery(val[0],aa,mont,ctx)) goto err; /* 1 */
d448 8
a455 9
	if (window > 1)
		{
		if (!BN_mod_mul_montgomery(d,val[0],val[0],mont,ctx)) goto err; /* 2 */
		j=1<<(window-1);
		for (i=1; i<j; i++)
			{
			if(((val[i] = BN_CTX_get(ctx)) == NULL) ||
					!BN_mod_mul_montgomery(val[i],val[i-1],
						d,mont,ctx))
a456 1
			}
d458 1
d460 6
a465 6
	start=1;	/* This is used to avoid multiplication etc
			 * when there is only the value '1' in the
			 * buffer. */
	wvalue=0;	/* The 'value' of the window */
	wstart=bits-1;	/* The top bit of the window */
	wend=0;		/* The bottom bit of the window */
d467 10
a476 11
	if (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;
	for (;;)
		{
		if (BN_is_bit_set(p,wstart) == 0)
			{
			if (!start)
				{
				if (!BN_mod_mul_montgomery(r,r,r,mont,ctx))
				goto err;
				}
			if (wstart == 0) break;
d479 1
a479 1
			}
d484 10
a493 12
		j=wstart;
		wvalue=1;
		wend=0;
		for (i=1; i<window; i++)
			{
			if (wstart-i < 0) break;
			if (BN_is_bit_set(p,wstart-i))
				{
				wvalue<<=(i-wend);
				wvalue|=1;
				wend=i;
				}
d495 1
d498 1
a498 1
		j=wend+1;
d501 2
a502 3
			for (i=0; i<j; i++)
				{
				if (!BN_mod_mul_montgomery(r,r,r,mont,ctx))
d504 2
a505 2
				}
		
d507 1
a507 1
		if (!BN_mod_mul_montgomery(r,r,val[wvalue>>1],mont,ctx))
d511 10
a520 7
		wstart-=wend+1;
		wvalue=0;
		start=0;
		if (wstart < 0) break;
		}
	if (!BN_from_montgomery(rr,r,mont,ctx)) goto err;
	ret=1;
d522 2
a523 1
	if ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);
d526 2
a527 2
	return(ret);
	}
d535 4
a538 2
static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top, unsigned char *buf, int idx, int width)
	{
d543 1
a543 2
	for (i = 0, j=idx; i < top * sizeof b->d[0]; i++, j+=width)
		{
d545 1
a545 1
		}
d548 1
a548 1
	}
d550 4
a553 2
static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx, int width)
	{
d559 1
a559 2
	for (i=0, j=idx; i < top * sizeof b->d[0]; i++, j+=width)
		{
d561 1
a561 1
		}
d566 1
a566 1
	}	
d578 5
a582 4
int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
		    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
	{
	int i,bits,ret=0,window,wvalue;
d584 1
a584 2
	BN_MONT_CTX *mont=NULL;

d586 1
a586 1
	unsigned char *powerbufFree=NULL;
d588 1
a588 1
	unsigned char *powerbuf=NULL;
d597 7
a603 8
	if (!(m->d[0] & 1))
		{
		BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME,BN_R_CALLED_WITH_EVEN_MODULUS);
		return(0);
		}
	bits=BN_num_bits(p);
	if (bits == 0)
		{
d606 1
a606 1
		}
d614 7
a620 6
		mont=in_mont;
	else
		{
		if ((mont=BN_MONT_CTX_new()) == NULL) goto err;
		if (!BN_MONT_CTX_set(mont,m,ctx)) goto err;
		}
d625 2
a626 1
	if (window==6 && bits<=1024) window=5;	/* ~5% improvement of 2048-bit RSA sign */
d633 2
a634 2
	powerbufLen = sizeof(m->d[0])*(top*numPowers +
				((2*top)>numPowers?(2*top):numPowers));
d637 2
a638 1
		powerbufFree = alloca(powerbufLen+MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);
d641 2
a642 1
	if ((powerbufFree=(unsigned char*)malloc(powerbufLen+MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH)) == NULL)
d644 1
a644 1
		
d654 5
a658 5
	tmp.d     = (BN_ULONG *)(powerbuf + sizeof(m->d[0])*top*numPowers);
	am.d      = tmp.d + top;
	tmp.top   = am.top  = 0;
	tmp.dmax  = am.dmax = top;
	tmp.neg   = am.neg  = 0;
d663 2
a664 1
 	if (!BN_to_montgomery(&tmp,BN_value_one(),mont,ctx))	goto err;
d666 3
a668 3
	tmp.d[0] = (0-m->d[0])&BN_MASK2;	/* 2^(top*BN_BITS2) - m */
	for (i=1;i<top;i++)
		tmp.d[i] = (~m->d[i])&BN_MASK2;
d673 7
a679 6
	if (a->neg || BN_ucmp(a,m) >= 0)
		{
		if (!BN_mod(&am,a,m,ctx))			goto err;
		if (!BN_to_montgomery(&am,&am,mont,ctx))	goto err;
		}
	else	if (!BN_to_montgomery(&am,a,mont,ctx))		goto err;
d682 28
a709 27
    /* This optimization uses ideas from http://eprint.iacr.org/2011/239,
     * specifically optimization of cache-timing attack countermeasures
     * and pre-computation optimization. */

    /* Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as
     * 512-bit RSA is hardly relevant, we omit it to spare size... */ 
    if (window==5)
	{
	void bn_mul_mont_gather5(BN_ULONG *rp,const BN_ULONG *ap,
			const void *table,const BN_ULONG *np,
			const BN_ULONG *n0,int num,int power);
	void bn_scatter5(const BN_ULONG *inp,size_t num,
			void *table,size_t power);
	void bn_gather5(BN_ULONG *out,size_t num,
			void *table,size_t power);

	BN_ULONG *np=mont->N.d, *n0=mont->n0;

	/* BN_to_montgomery can contaminate words above .top
	 * [in BN_DEBUG[_DEBUG] build]... */
	for (i=am.top; i<top; i++)	am.d[i]=0;
	for (i=tmp.top; i<top; i++)	tmp.d[i]=0;

	bn_scatter5(tmp.d,top,powerbuf,0);
	bn_scatter5(am.d,am.top,powerbuf,1);
	bn_mul_mont(tmp.d,am.d,am.d,np,n0,top);
	bn_scatter5(tmp.d,top,powerbuf,2);
d712 5
a716 5
	for (i=3; i<32; i++)
		{
		/* Calculate a^i = a^(i-1) * a */
		bn_mul_mont_gather5(tmp.d,am.d,powerbuf,np,n0,top,i-1);
		bn_scatter5(tmp.d,top,powerbuf,i);
d719 13
a731 15
	/* same as above, but uses squaring for 1/2 of operations */
	for (i=4; i<32; i*=2)
		{
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_scatter5(tmp.d,top,powerbuf,i);
		}
	for (i=3; i<8; i+=2)
		{
		int j;
		bn_mul_mont_gather5(tmp.d,am.d,powerbuf,np,n0,top,i-1);
		bn_scatter5(tmp.d,top,powerbuf,i);
		for (j=2*i; j<32; j*=2)
			{
			bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
			bn_scatter5(tmp.d,top,powerbuf,j);
d734 11
a744 11
	for (; i<16; i+=2)
		{
		bn_mul_mont_gather5(tmp.d,am.d,powerbuf,np,n0,top,i-1);
		bn_scatter5(tmp.d,top,powerbuf,i);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_scatter5(tmp.d,top,powerbuf,2*i);
		}
	for (; i<32; i+=2)
		{
		bn_mul_mont_gather5(tmp.d,am.d,powerbuf,np,n0,top,i-1);
		bn_scatter5(tmp.d,top,powerbuf,i);
d747 4
a750 4
	bits--;
	for (wvalue=0, i=bits%5; i>=0; i--,bits--)
		wvalue = (wvalue<<1)+BN_is_bit_set(p,bits);
	bn_gather5(tmp.d,top,powerbuf,wvalue);
d752 13
a764 14
	/* Scan the exponent one window at a time starting from the most
	 * significant bits.
	 */
	while (bits >= 0)
		{
		for (wvalue=0, i=0; i<5; i++,bits--)
			wvalue = (wvalue<<1)+BN_is_bit_set(p,bits);

		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont_gather5(tmp.d,tmp.d,powerbuf,np,n0,top,wvalue);
d767 3
a769 4
	tmp.top=top;
	bn_correct_top(&tmp);
	}
    else
d772 6
a777 2
	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers)) goto err;
	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am,  top, powerbuf, 1, numPowers)) goto err;
d779 10
a788 13
	/* If the window size is greater than 1, then calculate
	 * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1)
	 * (even powers could instead be computed as (a^(i/2))^2
	 * to use the slight performance advantage of sqr over mul).
	 */
	if (window > 1)
		{
		if (!BN_mod_mul_montgomery(&tmp,&am,&am,mont,ctx))	goto err;
		if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2, numPowers)) goto err;
		for (i=3; i<numPowers; i++)
			{
			/* Calculate a^i = a^(i-1) * a */
			if (!BN_mod_mul_montgomery(&tmp,&am,&tmp,mont,ctx))
d790 8
a797 1
			if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i, numPowers)) goto err;
d801 37
a837 30
	bits--;
	for (wvalue=0, i=bits%window; i>=0; i--,bits--)
		wvalue = (wvalue<<1)+BN_is_bit_set(p,bits);
	if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp,top,powerbuf,wvalue,numPowers)) goto err;
 
	/* Scan the exponent one window at a time starting from the most
	 * significant bits.
	 */
 	while (bits >= 0)
  		{
 		wvalue=0; /* The 'value' of the window */
 		
 		/* Scan the window, squaring the result as we go */
 		for (i=0; i<window; i++,bits--)
 			{
			if (!BN_mod_mul_montgomery(&tmp,&tmp,&tmp,mont,ctx))	goto err;
			wvalue = (wvalue<<1)+BN_is_bit_set(p,bits);
  			}
 		
		/* Fetch the appropriate pre-computed value from the pre-buf */
		if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue, numPowers)) goto err;

 		/* Multiply the result into the intermediate result */
 		if (!BN_mod_mul_montgomery(&tmp,&tmp,&am,mont,ctx)) goto err;
  		}
	}

 	/* Convert the final result from montgomery to standard format */
	if (!BN_from_montgomery(rr,&tmp,mont,ctx)) goto err;
	ret=1;
d839 7
a845 6
	if ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);
	if (powerbuf!=NULL)
		{
		OPENSSL_cleanse(powerbuf,powerbufLen);
		if (powerbufFree) free(powerbufFree);
		}
d847 2
a848 2
	return(ret);
	}
d850 4
a853 3
int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,
                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
	{
d855 1
a855 1
	int b, bits, ret=0;
d860 1
d876 1
a876 2
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
		{
d878 2
a879 1
		BNerr(BN_F_BN_MOD_EXP_MONT_WORD,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d881 1
a881 1
		}
d886 4
a889 5
	if (!BN_is_odd(m))
		{
		BNerr(BN_F_BN_MOD_EXP_MONT_WORD,BN_R_CALLED_WITH_EVEN_MODULUS);
		return(0);
		}
d892 2
a893 4

	bits = BN_num_bits(p);
	if (bits == 0)
		{
d896 2
a897 3
		}
	if (a == 0)
		{
d901 1
a901 1
		}
d907 2
a908 1
	if (d == NULL || r == NULL || t == NULL) goto err;
d911 7
a917 6
		mont=in_mont;
	else
		{
		if ((mont = BN_MONT_CTX_new()) == NULL) goto err;
		if (!BN_MONT_CTX_set(mont, m, ctx)) goto err;
		}
d925 4
a928 1
	for (b = bits-2; b >= 0; b--)
d930 3
a932 7
		/* First, square r*w. */
		next_w = w*w;
		if ((next_w/w) != w) /* overflow */
			{
			if (r_is_one)
				{
				if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;
d934 4
a937 5
				}
			else
				{
				if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
				}
d939 1
a939 1
			}
d941 4
a944 4
		if (!r_is_one)
			{
			if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) goto err;
			}
d947 3
a949 1
		if (BN_is_bit_set(p, b))
d951 3
a953 6
			next_w = w*a;
			if ((next_w/a) != w) /* overflow */
				{
				if (r_is_one)
					{
					if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;
d955 4
a958 5
					}
				else
					{
					if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
					}
d960 1
a960 1
				}
a961 1
			}
d963 1
d966 4
a969 5
	if (w != 1)
		{
		if (r_is_one)
			{
			if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;
d971 3
a973 5
			}
		else
			{
			if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
			}
d975 1
d978 7
a984 7
		{
		if (!BN_one(rr)) goto err;
		}
	else
		{
		if (!BN_from_montgomery(rr, r, mont, ctx)) goto err;
		}
d986 1
d988 2
a989 1
	if ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);
d992 2
a993 2
	return(ret);
	}
d997 6
a1002 5
int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
		const BIGNUM *m, BN_CTX *ctx)
	{
	int i,j,bits,ret=0,wstart,wend,window,wvalue;
	int start=1;
d1007 1
a1007 2
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
		{
d1009 2
a1010 1
		BNerr(BN_F_BN_MOD_EXP_SIMPLE,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d1012 1
a1012 1
		}
d1014 1
a1014 1
	bits=BN_num_bits(p);
d1016 1
a1016 2
	if (bits == 0)
		{
d1019 1
a1019 1
		}
d1024 2
a1025 1
	if(!d || !val[0]) goto err;
d1027 3
a1029 3
	if (!BN_nnmod(val[0],a,m,ctx)) goto err;		/* 1 */
	if (BN_is_zero(val[0]))
		{
d1033 1
a1033 1
		}
d1036 2
a1037 3
	if (window > 1)
		{
		if (!BN_mod_mul(d,val[0],val[0],m,ctx))
d1039 4
a1042 5
		j=1<<(window-1);
		for (i=1; i<j; i++)
			{
			if(((val[i] = BN_CTX_get(ctx)) == NULL) ||
					!BN_mod_mul(val[i],val[i-1],d,m,ctx))
a1043 1
			}
d1045 1
d1047 6
a1052 6
	start=1;	/* This is used to avoid multiplication etc
			 * when there is only the value '1' in the
			 * buffer. */
	wvalue=0;	/* The 'value' of the window */
	wstart=bits-1;	/* The top bit of the window */
	wend=0;		/* The bottom bit of the window */
d1054 2
a1055 1
	if (!BN_one(r)) goto err;
d1057 2
a1058 4
	for (;;)
		{
		if (BN_is_bit_set(p,wstart) == 0)
			{
d1060 4
a1063 3
				if (!BN_mod_mul(r,r,r,m,ctx))
				goto err;
			if (wstart == 0) break;
d1066 1
a1066 1
			}
d1071 10
a1080 12
		j=wstart;
		wvalue=1;
		wend=0;
		for (i=1; i<window; i++)
			{
			if (wstart-i < 0) break;
			if (BN_is_bit_set(p,wstart-i))
				{
				wvalue<<=(i-wend);
				wvalue|=1;
				wend=i;
				}
d1082 1
d1085 1
a1085 1
		j=wend+1;
d1088 2
a1089 3
			for (i=0; i<j; i++)
				{
				if (!BN_mod_mul(r,r,r,m,ctx))
d1091 2
a1092 2
				}
		
d1094 1
a1094 1
		if (!BN_mod_mul(r,r,val[wvalue>>1],m,ctx))
d1098 8
a1105 6
		wstart-=wend+1;
		wvalue=0;
		start=0;
		if (wstart < 0) break;
		}
	ret=1;
d1109 2
a1110 2
	return(ret);
	}
@


1.10
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d117 1
a117 6
#ifdef _WIN32
# include <malloc.h>
# ifndef alloca
#  define alloca _alloca
# endif
#elif defined(__GNUC__)
@


1.9
log
@resolve conflicts
@
text
@d639 1
a639 1
	if ((powerbufFree=(unsigned char*)OPENSSL_malloc(powerbufLen+MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH)) == NULL)
d826 1
a826 1
		if (powerbufFree) OPENSSL_free(powerbufFree);
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d116 12
d537 1
a537 1
static int MOD_EXP_CTIME_COPY_TO_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx, int width)
d541 2
a542 7
	if (bn_wexpand(b, top) == NULL)
		return 0;
	while (b->top < top)
		{
		b->d[b->top++] = 0;
		}
	
a547 1
	bn_correct_top(b);
d570 1
a570 1
	((unsigned char*)(x_) + (MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH - (((BN_ULONG)(x_)) & (MOD_EXP_CTIME_MIN_CACHE_LINE_MASK))))
d581 1
a581 1
	int i,bits,ret=0,idx,window,wvalue;
a582 2
 	BIGNUM *r;
	const BIGNUM *aa;
d589 1
a589 1
	BIGNUM *computeTemp=NULL, *am=NULL;
a608 1
 	/* Initialize BIGNUM context and allocate intermediate result */
a609 2
	r = BN_CTX_get(ctx);
	if (r == NULL) goto err;
d624 3
d629 1
a629 1
	 * powers of a.
d632 7
a638 1
	powerbufLen = sizeof(m->d[0])*top*numPowers;
d645 4
a648 5
 	/* Initialize the intermediate result. Do this early to save double conversion,
	 * once each for a^0 and intermediate result.
	 */
 	if (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;
	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(r, top, powerbuf, 0, numPowers)) goto err;
d650 17
a666 4
	/* Initialize computeTemp as a^1 with montgomery precalcs */
	computeTemp = BN_CTX_get(ctx);
	am = BN_CTX_get(ctx);
	if (computeTemp==NULL || am==NULL) goto err;
d668 1
d671 91
a761 3
		if (!BN_mod(am,a,m,ctx))
			goto err;
		aa= am;
d763 9
a771 5
	else
		aa=a;
	if (!BN_to_montgomery(am,aa,mont,ctx)) goto err;
	if (!BN_copy(computeTemp, am)) goto err;
	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(am, top, powerbuf, 1, numPowers)) goto err;
d780 3
a782 1
		for (i=2; i<numPowers; i++)
d785 1
a785 1
			if (!BN_mod_mul_montgomery(computeTemp,am,computeTemp,mont,ctx))
d787 1
a787 1
			if (!MOD_EXP_CTIME_COPY_TO_PREBUF(computeTemp, top, powerbuf, i, numPowers)) goto err;
d791 9
a799 18
 	/* Adjust the number of bits up to a multiple of the window size.
 	 * If the exponent length is not a multiple of the window size, then
 	 * this pads the most significant bits with zeros to normalize the
 	 * scanning loop to there's no special cases.
 	 *
 	 * * NOTE: Making the window size a power of two less than the native
	 * * word size ensures that the padded bits won't go past the last
 	 * * word in the internal BIGNUM structure. Going past the end will
 	 * * still produce the correct result, but causes a different branch
 	 * * to be taken in the BN_is_bit_set function.
 	 */
 	bits = ((bits+window-1)/window)*window;
 	idx=bits-1;	/* The top bit of the window */

 	/* Scan the exponent one window at a time starting from the most
 	 * significant bits.
 	 */
 	while (idx >= 0)
d804 1
a804 1
 		for (i=0; i<window; i++,idx--)
d806 2
a807 2
			if (!BN_mod_mul_montgomery(r,r,r,mont,ctx))	goto err;
			wvalue = (wvalue<<1)+BN_is_bit_set(p,idx);
d811 1
a811 1
		if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(computeTemp, top, powerbuf, wvalue, numPowers)) goto err;
d814 1
a814 1
 		if (!BN_mod_mul_montgomery(r,r,computeTemp,mont,ctx)) goto err;
d816 1
d819 1
a819 1
	if (!BN_from_montgomery(rr,r,mont,ctx)) goto err;
d826 1
a826 1
		OPENSSL_free(powerbufFree);
a827 2
 	if (am!=NULL) BN_clear(am);
 	if (computeTemp!=NULL) BN_clear(computeTemp);
a1097 1

@


1.7
log
@resolve conflicts
@
text
@d137 2
a138 1
	if ((v = BN_CTX_get(ctx)) == NULL) goto err;
@


1.6
log
@resolve conflicts
@
text
@d125 1
a125 1
	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
d127 1
a127 1
		/* BN_FLG_EXP_CONSTTIME only supported by BN_mod_exp_mont() */
d158 1
d216 1
a216 1
		if (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) == 0))
d233 1
d242 1
a242 1
	int start=1,ts=0;
d244 2
a245 1
	BIGNUM val[TABLE_SIZE];
d248 1
a248 1
	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
d250 1
a250 1
		/* BN_FLG_EXP_CONSTTIME only supported by BN_mod_exp_mont() */
d264 3
a266 1
	if ((aa = BN_CTX_get(ctx)) == NULL) goto err;
d281 2
a282 5
	BN_init(&(val[0]));
	ts=1;

	if (!BN_nnmod(&(val[0]),a,m,ctx)) goto err;		/* 1 */
	if (BN_is_zero(&(val[0])))
d284 2
a285 1
		ret = BN_zero(r);
d292 1
a292 1
		if (!BN_mod_mul_reciprocal(aa,&(val[0]),&(val[0]),&recp,ctx))
d297 3
a299 2
			BN_init(&val[i]);
			if (!BN_mod_mul_reciprocal(&(val[i]),&(val[i-1]),aa,&recp,ctx))
a301 1
		ts=i;
d353 1
a353 1
		if (!BN_mod_mul_reciprocal(r,r,&(val[wvalue>>1]),&recp,ctx))
a364 2
	for (i=0; i<ts; i++)
		BN_clear_free(&(val[i]));
d366 1
d375 1
a375 1
	int start=1,ts=0;
d378 2
a379 1
	BIGNUM val[TABLE_SIZE];
d382 1
a382 1
	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
d391 1
a391 1
	if (!(m->d[0] & 1))
d406 2
a407 1
	if (d == NULL || r == NULL) goto err;
a419 2
	BN_init(&val[0]);
	ts=1;
d422 1
a422 1
		if (!BN_nnmod(&(val[0]),a,m,ctx))
d424 1
a424 1
		aa= &(val[0]);
d430 2
a431 1
		ret = BN_zero(rr);
d434 1
a434 1
	if (!BN_to_montgomery(&(val[0]),aa,mont,ctx)) goto err; /* 1 */
d439 1
a439 1
		if (!BN_mod_mul_montgomery(d,&(val[0]),&(val[0]),mont,ctx)) goto err; /* 2 */
d443 3
a445 2
			BN_init(&(val[i]));
			if (!BN_mod_mul_montgomery(&(val[i]),&(val[i-1]),d,mont,ctx))
a447 1
		ts=i;
d500 1
a500 1
		if (!BN_mod_mul_montgomery(r,r,&(val[wvalue>>1]),mont,ctx))
d514 1
a514 2
	for (i=0; i<ts; i++)
		BN_clear_free(&(val[i]));
d540 1
a540 1
	bn_fix_top(b);
d557 1
a557 1
	bn_fix_top(b);
d748 1
a748 1
	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
d750 1
a750 1
		/* BN_FLG_EXP_CONSTTIME only supported by BN_mod_exp_mont() */
d758 1
a758 1
	if (m->top == 0 || !(m->d[0] & 1))
d774 2
a775 1
		ret = BN_zero(rr);
d869 1
d875 2
a876 3
int BN_mod_exp_simple(BIGNUM *r,
	const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
	BN_CTX *ctx)
d878 1
a878 1
	int i,j,bits,ret=0,wstart,wend,window,wvalue,ts=0;
d881 2
a882 1
	BIGNUM val[TABLE_SIZE];
d884 1
a884 1
	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
d886 1
a886 1
		/* BN_FLG_EXP_CONSTTIME only supported by BN_mod_exp_mont() */
d900 3
a902 1
	if ((d = BN_CTX_get(ctx)) == NULL) goto err;
d904 2
a905 4
	BN_init(&(val[0]));
	ts=1;
	if (!BN_nnmod(&(val[0]),a,m,ctx)) goto err;		/* 1 */
	if (BN_is_zero(&(val[0])))
d907 2
a908 1
		ret = BN_zero(r);
d915 1
a915 1
		if (!BN_mod_mul(d,&(val[0]),&(val[0]),m,ctx))
d920 2
a921 2
			BN_init(&(val[i]));
			if (!BN_mod_mul(&(val[i]),&(val[i-1]),d,m,ctx))
a923 1
		ts=i;
d975 1
a975 1
		if (!BN_mod_mul(r,r,&(val[wvalue>>1]),m,ctx))
d987 1
a987 2
	for (i=0; i<ts; i++)
		BN_clear_free(&(val[i]));
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
d116 1
d125 7
d215 1
a215 1
		if (a->top == 1 && !a->neg)
d245 7
d379 5
d516 206
d746 7
d879 7
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@a112 1
#include <stdio.h>
a117 24
/* slow but works */
int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
	{
	BIGNUM *t;
	int r=0;

	bn_check_top(a);
	bn_check_top(b);
	bn_check_top(m);

	BN_CTX_start(ctx);
	if ((t = BN_CTX_get(ctx)) == NULL) goto err;
	if (a == b)
		{ if (!BN_sqr(t,a,ctx)) goto err; }
	else
		{ if (!BN_mul(t,a,b,ctx)) goto err; }
	if (!BN_mod(ret,t,m,ctx)) goto err;
	r=1;
err:
	BN_CTX_end(ctx);
	return(r);
	}


d119 1
a119 1
int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx)
d154 1
a154 1
int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
d163 34
d206 2
a207 1
		if (a->top == 1)
d213 1
d241 2
a242 2
		BN_one(r);
		return(1);
d249 11
a259 1
	if (BN_RECP_CTX_set(&recp,m,ctx) <= 0) goto err;
d264 6
a269 1
	if (!BN_mod(&(val[0]),a,m,ctx)) goto err;		/* 1 */
d354 1
a354 1
int BN_mod_exp_mont(BIGNUM *rr, BIGNUM *a, const BIGNUM *p,
d360 1
a360 1
	BIGNUM *aa;
d376 2
a377 2
		BN_one(rr);
		return(1);
d379 1
d398 1
a398 1
	if (BN_ucmp(a,m) >= 0)
d400 1
a400 1
		if (!BN_mod(&(val[0]),a,m,ctx))
d406 5
d510 7
a516 3
		  * so the BN_ucmp test is probably more overhead
		  * than always using BN_mod (which uses BN_copy if
		  * a similar test returns true). */
d523 1
a523 1
	if (!(m->d[0] & 1))
d528 3
d534 7
a540 2
		BN_one(rr);
		return(1);
d542 1
d638 3
a640 2
int BN_mod_exp_simple(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m,
	     BN_CTX *ctx)
d651 2
a652 2
		BN_one(r);
		return(1);
d660 6
a665 1
	if (!BN_mod(&(val[0]),a,m,ctx)) goto err;		/* 1 */
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d58 54
a115 6
#ifdef ATALLA
# include <alloca.h>
# include <atasi.h>
# include <assert.h>
# include <dlfcn.h>
#endif
d117 1
a117 1
#define TABLE_SIZE	16
a141 36
#if 0
/* this one works - simple but works */
int BN_mod_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m, BN_CTX *ctx)
	{
	int i,bits,ret=0;
	BIGNUM *v,*tmp;

	BN_CTX_start(ctx);
	v = BN_CTX_get(ctx);
	tmp = BN_CTX_get(ctx);
	if (v == NULL || tmp == NULL) goto err;

	if (BN_copy(v,a) == NULL) goto err;
	bits=BN_num_bits(p);

	if (BN_is_odd(p))
		{ if (BN_copy(r,a) == NULL) goto err; }
	else	{ if (!BN_one(r)) goto err; }

	for (i=1; i<bits; i++)
		{
		if (!BN_sqr(tmp,v,ctx)) goto err;
		if (!BN_mod(v,tmp,m,ctx)) goto err;
		if (BN_is_bit_set(p,i))
			{
			if (!BN_mul(tmp,r,v,ctx)) goto err;
			if (!BN_mod(r,tmp,m,ctx)) goto err;
			}
		}
	ret=1;
err:
	BN_CTX_end(ctx);
	return(ret);
	}

#endif
a177 166
#ifdef ATALLA

/*
 * This routine will dynamically check for the existance of an Atalla AXL-200
 * SSL accelerator module.  If one is found, the variable
 * asi_accelerator_present is set to 1 and the function pointers
 * ptr_ASI_xxxxxx above will be initialized to corresponding ASI API calls.
 */
typedef int tfnASI_GetPerformanceStatistics(int reset_flag,
					    unsigned int *ret_buf);
typedef int tfnASI_GetHardwareConfig(long card_num, unsigned int *ret_buf);
typedef int tfnASI_RSAPrivateKeyOpFn(RSAPrivateKey * rsaKey,
				     unsigned char *output,
				     unsigned char *input,
				     unsigned int modulus_len);

static tfnASI_GetHardwareConfig *ptr_ASI_GetHardwareConfig;
static tfnASI_RSAPrivateKeyOpFn *ptr_ASI_RSAPrivateKeyOpFn;
static tfnASI_GetPerformanceStatistics *ptr_ASI_GetPerformanceStatistics;
static int asi_accelerator_present;
static int tried_atalla;

void atalla_initialize_accelerator_handle(void)
	{
	void *dl_handle;
	int status;
	unsigned int config_buf[1024]; 
	static int tested;

	if(tested)
		return;

	tested=1;

	bzero((void *)config_buf, 1024);

	/*
	 * Check to see if the library is present on the system
	 */
	dl_handle = dlopen("atasi.so", RTLD_NOW);
	if (dl_handle == (void *) NULL)
		{
/*		printf("atasi.so library is not present on the system\n");
		printf("No HW acceleration available\n");*/
		return;
	        }

	/*
	 * The library is present.  Now we'll check to insure that the
	 * LDM is up and running. First we'll get the address of the
	 * function in the atasi library that we need to see if the
	 * LDM is operating.
	 */

	ptr_ASI_GetHardwareConfig =
	  (tfnASI_GetHardwareConfig *)dlsym(dl_handle,"ASI_GetHardwareConfig");

	if (ptr_ASI_GetHardwareConfig)
		{
		/*
		 * We found the call, now we'll get our config
		 * status.  If we get a non 0 result, the LDM is not
		 * running and we cannot use the Atalla ASI *
		 * library.
		 */
		status = (*ptr_ASI_GetHardwareConfig)(0L, config_buf);
		if (status != 0)
			{
			printf("atasi.so library is present but not initialized\n");
			printf("No HW acceleration available\n");
			return;
			}    
	        }
	else
		{
/*		printf("We found the library, but not the function. Very Strange!\n");*/
		return ;
	      	}

	/* 
	 * It looks like we have acceleration capabilities.  Load up the
	 * pointers to our ASI API calls.
	 */
	ptr_ASI_RSAPrivateKeyOpFn=
	  (tfnASI_RSAPrivateKeyOpFn *)dlsym(dl_handle, "ASI_RSAPrivateKeyOpFn");
	if (ptr_ASI_RSAPrivateKeyOpFn == NULL)
		{
/*		printf("We found the library, but no RSA function. Very Strange!\n");*/
		return;
	        }

	ptr_ASI_GetPerformanceStatistics =
	  (tfnASI_GetPerformanceStatistics *)dlsym(dl_handle, "ASI_GetPerformanceStatistics");
	if (ptr_ASI_GetPerformanceStatistics == NULL)
		{
/*		printf("We found the library, but no stat function. Very Strange!\n");*/
		return;
	      }

	/*
	 * Indicate that acceleration is available
	 */
	asi_accelerator_present = 1;

/*	printf("This system has acceleration!\n");*/

	return;
	}

/* make sure this only gets called once when bn_mod_exp calls bn_mod_exp_mont */
int BN_mod_exp_atalla(BIGNUM *r, BIGNUM *a, const BIGNUM *p, const BIGNUM *m)
	{
	unsigned char *abin;
	unsigned char *pbin;
	unsigned char *mbin;
	unsigned char *rbin;
	int an,pn,mn,ret;
	RSAPrivateKey keydata;

	atalla_initialize_accelerator_handle();
	if(!asi_accelerator_present)
		return 0;


/* We should be able to run without size testing */
# define ASIZE	128
	an=BN_num_bytes(a);
	pn=BN_num_bytes(p);
	mn=BN_num_bytes(m);

	if(an <= ASIZE && pn <= ASIZE && mn <= ASIZE)
	    {
	    int size=mn;

	    assert(an <= mn);
	    abin=alloca(size);
	    memset(abin,'\0',mn);
	    BN_bn2bin(a,abin+size-an);

	    pbin=alloca(pn);
	    BN_bn2bin(p,pbin);

	    mbin=alloca(size);
	    memset(mbin,'\0',mn);
	    BN_bn2bin(m,mbin+size-mn);

	    rbin=alloca(size);

	    memset(&keydata,'\0',sizeof keydata);
	    keydata.privateExponent.data=pbin;
	    keydata.privateExponent.len=pn;
	    keydata.modulus.data=mbin;
	    keydata.modulus.len=size;

	    ret=(*ptr_ASI_RSAPrivateKeyOpFn)(&keydata,rbin,abin,keydata.modulus.len);
/*fprintf(stderr,"!%s\n",BN_bn2hex(a));*/
	    if(!ret)
	        {
		BN_bin2bn(rbin,keydata.modulus.len,r);
/*fprintf(stderr,"?%s\n",BN_bn2hex(r));*/
		return 1;
	        }
	    }
	return 0;
        }
#endif /* def ATALLA */
a187 7
#ifdef ATALLA
	if(BN_mod_exp_atalla(r,a,p,m))
	    return 1;
/* If it fails, try the other methods (but don't try atalla again) */
	tried_atalla=1;
#endif

d196 9
a204 1
		{ ret=BN_mod_exp_mont(r,a,p,m,ctx,NULL); }
a212 4
#ifdef ATALLA
	tried_atalla=0;
#endif

d216 1
a216 1
/* #ifdef RECP_MUL_MOD */
a243 2
	if (!BN_mod_mul_reciprocal(aa,&(val[0]),&(val[0]),&recp,ctx))
		goto err;				/* 2 */
d245 2
a246 11
	if (bits <= 17) /* This is probably 3 or 0x10001, so just do singles */
		window=1;
	else if (bits >= 256)
		window=5;	/* max size of window */
	else if (bits >= 128)
		window=4;
	else
		window=3;

	j=1<<(window-1);
	for (i=1; i<j; i++)
d248 10
a257 3
		BN_init(&val[i]);
		if (!BN_mod_mul_reciprocal(&(val[i]),&(val[i-1]),aa,&recp,ctx))
			goto err;
d259 1
a259 2
	ts=i;

a325 1
/* #endif */
d327 1
a327 1
/* #ifdef MONT_MUL_MOD */
a341 6
#ifdef ATALLA
	if(!tried_atalla && BN_mod_exp_atalla(rr,a,p,m))
	    return 1;
/* If it fails, try the other methods */
#endif

a360 1
#if 1
a363 1
#endif
d373 2
a374 1
		BN_mod(&(val[0]),a,m,ctx);
a379 10
	if (!BN_mod_mul_montgomery(d,&(val[0]),&(val[0]),mont,ctx)) goto err; /* 2 */

	if (bits <= 20) /* This is probably 3 or 0x10001, so just do singles */
		window=1;
	else if (bits >= 256)
		window=5;	/* max size of window */
	else if (bits >= 128)
		window=4;
	else
		window=3;
d381 2
a382 2
	j=1<<(window-1);
	for (i=1; i<j; i++)
d384 9
a392 3
		BN_init(&(val[i]));
		if (!BN_mod_mul_montgomery(&(val[i]),&(val[i-1]),d,mont,ctx))
			goto err;
a393 1
	ts=i;
d402 1
a402 1
        if (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;
d454 1
a454 1
	BN_from_montgomery(rr,r,mont,ctx);
d463 128
a590 1
/* #endif */
a614 11
	if (!BN_mod_mul(d,&(val[0]),&(val[0]),m,ctx))
		goto err;				/* 2 */

	if (bits <= 17) /* This is probably 3 or 0x10001, so just do singles */
		window=1;
	else if (bits >= 256)
		window=5;	/* max size of window */
	else if (bits >= 128)
		window=4;
	else
		window=3;
d616 2
a617 2
	j=1<<(window-1);
	for (i=1; i<j; i++)
d619 10
a628 3
		BN_init(&(val[i]));
		if (!BN_mod_mul(&(val[i]),&(val[i-1]),d,m,ctx))
			goto err;
a629 1
	ts=i;
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d62 6
d81 2
a82 1
	t= &(ctx->bn[ctx->tos++]);
d90 1
a90 1
	ctx->tos--;
d101 4
a104 2
	v= &(ctx->bn[ctx->tos++]);
	tmp= &(ctx->bn[ctx->tos++]);
d125 1
a125 1
	ctx->tos-=2;
d134 1
a134 1
	int i,bits,ret=0,tos;
d137 1
a137 2
	tos=ctx->tos;
	v= &(ctx->bn[ctx->tos++]);
d139 1
a139 1
		rr= &(ctx->bn[ctx->tos++]);
d141 2
a142 1
		rr=r;
a160 1
	ctx->tos=tos;
d162 1
d166 167
d342 7
d366 4
a382 1
	aa= &(ctx->bn[ctx->tos++]);
d390 4
d482 1
a482 1
	ctx->tos--;
d505 6
a515 2
	d= &(ctx->bn[ctx->tos++]);
	r= &(ctx->bn[ctx->tos++]);
d519 1
a519 1
		BN_one(r);
d522 4
d633 1
a633 1
	ctx->tos-=2;
a648 1
	d= &(ctx->bn[ctx->tos++]);
d657 3
d744 1
a744 1
	ctx->tos--;
@


1.1
log
@Initial revision
@
text
@d63 2
d66 1
a66 6
int BN_mod_mul(ret, a, b, m, ctx)
BIGNUM *ret;
BIGNUM *a;
BIGNUM *b;
BIGNUM *m;
BN_CTX *ctx;
d71 5
a75 1
	t=ctx->bn[ctx->tos++];
d79 1
a79 1
		{ if (!BN_mul(t,a,b)) goto err; }
d89 1
a89 3
int BN_mod_exp(r,a,p,m,ctx)
BIGNUM *r,*a,*p,*m;
BN_CTX *ctx;
d94 2
a95 2
	v=ctx->bn[ctx->tos++];
	tmp=ctx->bn[ctx->tos++];
d102 1
a102 1
	else	{ if (BN_one(r)) goto err; }
d110 1
a110 1
			if (!BN_mul(tmp,r,v)) goto err;
d123 1
a123 3
int BN_exp(r,a,p,ctx)
BIGNUM *r,*a,*p;
BN_CTX *ctx;
d125 2
a126 2
	int i,bits,ret=0;
	BIGNUM *v,*tmp;
d128 6
a133 2
	v=ctx->bn[ctx->tos++];
	tmp=ctx->bn[ctx->tos++];
d139 2
a140 2
		{ if (BN_copy(r,a) == NULL) goto err; }
	else	{ if (BN_one(r)) goto err; }
d144 1
a144 1
		if (!BN_sqr(tmp,v,ctx)) goto err;
d147 1
a147 1
			if (!BN_mul(tmp,r,v)) goto err;
d152 2
a153 1
	ctx->tos-=2;
d157 2
a158 6
int BN_mod_exp(r,a,p,m,ctx)
BIGNUM *r;
BIGNUM *a;
BIGNUM *p;
BIGNUM *m;
BN_CTX *ctx;
d162 4
d187 2
a188 6
int BN_mod_exp_recp(r,a,p,m,ctx)
BIGNUM *r;
BIGNUM *a;
BIGNUM *p;
BIGNUM *m;
BN_CTX *ctx;
d190 5
a194 4
	int nb,i,j,bits,ret=0,wstart,wend,window,wvalue;
	int start=1;
	BIGNUM *d,*aa;
	BIGNUM *val[16];
d196 1
a196 2
	d=ctx->bn[ctx->tos++];
	aa=ctx->bn[ctx->tos++];
d204 2
a205 2
	nb=BN_reciprocal(d,m,ctx);
	if (nb == -1) goto err;
d207 5
a211 3
	val[0]=BN_new();
	if (!BN_mod(val[0],a,m,ctx)) goto err;		/* 1 */
	if (!BN_mod_mul_reciprocal(aa,val[0],val[0],m,d,nb,ctx))
d226 2
a227 2
		val[i]=BN_new();
		if (!BN_mod_mul_reciprocal(val[i],val[i-1],aa,m,d,nb,ctx))
d230 1
a230 2
	for (; i<16; i++)
		val[i]=NULL;
d246 1
a246 1
				if (!BN_mod_mul_reciprocal(r,r,r,m,d,nb,ctx))
d276 1
a276 1
				if (!BN_mod_mul_reciprocal(r,r,r,m,d,nb,ctx))
d281 1
a281 1
		if (!BN_mod_mul_reciprocal(r,r,val[wvalue>>1],m,d,nb,ctx))
d292 4
a295 3
	ctx->tos-=2;
	for (i=0; i<16; i++)
		if (val[i] != NULL) BN_clear_free(val[i]);
d301 2
a302 7
int BN_mod_exp_mont(r,a,p,m,ctx,in_mont)
BIGNUM *r;
BIGNUM *a;
BIGNUM *p;
BIGNUM *m;
BN_CTX *ctx;
BN_MONT_CTX *in_mont;
a303 1
#define TABLE_SIZE	16
d305 4
a308 3
	int start=1;
	BIGNUM *d,*aa;
	BIGNUM *val[TABLE_SIZE];
d311 4
d320 2
a321 1
	d=ctx->bn[ctx->tos++];
d342 2
a343 1
	val[0]=BN_new();
d346 2
a347 2
		BN_mod(val[0],a,m,ctx);
		aa=val[0];
d351 2
a352 2
	if (!BN_to_montgomery(val[0],aa,mont,ctx)) goto err; /* 1 */
	if (!BN_mod_mul_montgomery(d,val[0],val[0],mont,ctx)) goto err; /* 2 */
d356 1
a356 1
	else if (bits > 250)
d358 1
a358 1
	else if (bits >= 120)
d366 2
a367 2
		val[i]=BN_new();
		if (!BN_mod_mul_montgomery(val[i],val[i-1],d,mont,ctx))
d370 1
a370 2
	for (; i<TABLE_SIZE; i++)
		val[i]=NULL;
d422 1
a422 1
		if (!BN_mod_mul_montgomery(r,r,val[wvalue>>1],mont,ctx))
d431 1
a431 1
	BN_from_montgomery(r,r,mont,ctx);
d435 3
a437 3
	ctx->tos--;
	for (i=0; i<TABLE_SIZE; i++)
		if (val[i] != NULL) BN_clear_free(val[i]);
d443 2
a444 6
int BN_mod_exp_simple(r,a,p,m,ctx)
BIGNUM *r;
BIGNUM *a;
BIGNUM *p;
BIGNUM *m;
BN_CTX *ctx;
d446 1
a446 1
	int i,j,bits,ret=0,wstart,wend,window,wvalue;
d449 1
a449 1
	BIGNUM *val[16];
d451 1
a451 1
	d=ctx->bn[ctx->tos++];
d460 4
a463 3
	val[0]=BN_new();
	if (!BN_mod(val[0],a,m,ctx)) goto err;		/* 1 */
	if (!BN_mod_mul(d,val[0],val[0],m,ctx))
d478 2
a479 2
		val[i]=BN_new();
		if (!BN_mod_mul(val[i],val[i-1],d,m,ctx))
d482 1
a482 2
	for (; i<16; i++)
		val[i]=NULL;
d533 1
a533 1
		if (!BN_mod_mul(r,r,val[wvalue>>1],m,ctx))
d545 2
a546 2
	for (i=0; i<16; i++)
		if (val[i] != NULL) BN_clear_free(val[i]);
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a57 54
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

d59 1
d63 10
a72 1
#define TABLE_SIZE	32
d74 13
d88 3
a90 1
int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
d93 1
a93 1
	BIGNUM *v,*rr;
d95 2
a96 6
	BN_CTX_start(ctx);
	if ((r == a) || (r == p))
		rr = BN_CTX_get(ctx);
	else
		rr = r;
	if ((v = BN_CTX_get(ctx)) == NULL) goto err;
d102 2
a103 2
		{ if (BN_copy(rr,a) == NULL) goto err; }
	else	{ if (!BN_one(rr)) goto err; }
d107 2
a108 1
		if (!BN_sqr(v,v,ctx)) goto err;
d111 2
a112 1
			if (!BN_mul(rr,rr,v,ctx)) goto err;
d117 1
a117 2
	if (r != rr) BN_copy(r,rr);
	BN_CTX_end(ctx);
d121 1
d123 38
a160 2
int BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
	       BN_CTX *ctx)
a163 38
	bn_check_top(a);
	bn_check_top(p);
	bn_check_top(m);

	/* For even modulus  m = 2^k*m_odd,  it might make sense to compute
	 * a^p mod m_odd  and  a^p mod 2^k  separately (with Montgomery
	 * exponentiation for the odd part), using appropriate exponent
	 * reductions, and combine the results using the CRT.
	 *
	 * For now, we use Montgomery only if the modulus is odd; otherwise,
	 * exponentiation using the reciprocal-based quick remaindering
	 * algorithm is used.
	 *
	 * (Timing obtained with expspeed.c [computations  a^p mod m
	 * where  a, p, m  are of the same length: 256, 512, 1024, 2048,
	 * 4096, 8192 bits], compared to the running time of the
	 * standard algorithm:
	 *
	 *   BN_mod_exp_mont   33 .. 40 %  [AMD K6-2, Linux, debug configuration]
         *                     55 .. 77 %  [UltraSparc processor, but
	 *                                  debug-solaris-sparcv8-gcc conf.]
	 * 
	 *   BN_mod_exp_recp   50 .. 70 %  [AMD K6-2, Linux, debug configuration]
	 *                     62 .. 118 % [UltraSparc, debug-solaris-sparcv8-gcc]
	 *
	 * On the Sparc, BN_mod_exp_recp was faster than BN_mod_exp_mont
	 * at 2048 and more bits, but at 512 and 1024 bits, it was
	 * slower even than the standard algorithm!
	 *
	 * "Real" timings [linux-elf, solaris-sparcv9-gcc configurations]
	 * should be obtained when the new Montgomery reduction code
	 * has been integrated into OpenSSL.)
	 */

#define MONT_MUL_MOD
#define MONT_EXP_WORD
#define RECP_MUL_MOD

d172 1
a172 11
		{
#  ifdef MONT_EXP_WORD
		if (a->top == 1 && !a->neg)
			{
			BN_ULONG A = a->d[0];
			ret=BN_mod_exp_mont_word(r,A,p,m,ctx,NULL);
			}
		else
#  endif
			ret=BN_mod_exp_mont(r,a,p,m,ctx,NULL);
		}
d184 7
a190 3

int BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
		    const BIGNUM *m, BN_CTX *ctx)
d192 4
a195 5
	int i,j,bits,ret=0,wstart,wend,window,wvalue;
	int start=1,ts=0;
	BIGNUM *aa;
	BIGNUM val[TABLE_SIZE];
	BN_RECP_CTX recp;
d197 2
d203 2
a204 2
		ret = BN_one(r);
		return ret;
d206 2
d209 11
a219 11
	BN_CTX_start(ctx);
	if ((aa = BN_CTX_get(ctx)) == NULL) goto err;

	BN_RECP_CTX_init(&recp);
	if (m->neg)
		{
		/* ignore sign of 'm' */
		if (!BN_copy(aa, m)) goto err;
		aa->neg = 0;
		if (BN_RECP_CTX_set(&recp,aa,ctx) <= 0) goto err;
		}
d221 1
a221 6
		{
		if (BN_RECP_CTX_set(&recp,m,ctx) <= 0) goto err;
		}

	BN_init(&(val[0]));
	ts=1;
d223 2
a224 2
	if (!BN_nnmod(&(val[0]),a,m,ctx)) goto err;		/* 1 */
	if (BN_is_zero(&(val[0])))
d226 3
a228 2
		ret = BN_zero(r);
		goto err;
d230 2
a232 15
	window = BN_window_bits_for_exponent_size(bits);
	if (window > 1)
		{
		if (!BN_mod_mul_reciprocal(aa,&(val[0]),&(val[0]),&recp,ctx))
			goto err;				/* 2 */
		j=1<<(window-1);
		for (i=1; i<j; i++)
			{
			BN_init(&val[i]);
			if (!BN_mod_mul_reciprocal(&(val[i]),&(val[i-1]),aa,&recp,ctx))
				goto err;
			}
		ts=i;
		}
		
d247 1
a247 1
				if (!BN_mod_mul_reciprocal(r,r,r,&recp,ctx))
d277 1
a277 1
				if (!BN_mod_mul_reciprocal(r,r,r,&recp,ctx))
d282 1
a282 1
		if (!BN_mod_mul_reciprocal(r,r,&(val[wvalue>>1]),&recp,ctx))
d293 3
a295 4
	BN_CTX_end(ctx);
	for (i=0; i<ts; i++)
		BN_clear_free(&(val[i]));
	BN_RECP_CTX_free(&recp);
d298 1
d300 8
a307 3

int BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
		    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
d309 1
d311 3
a313 4
	int start=1,ts=0;
	BIGNUM *d,*r;
	const BIGNUM *aa;
	BIGNUM val[TABLE_SIZE];
a315 4
	bn_check_top(a);
	bn_check_top(p);
	bn_check_top(m);

d321 1
d325 2
a326 2
		ret = BN_one(rr);
		return ret;
a328 5
	BN_CTX_start(ctx);
	d = BN_CTX_get(ctx);
	r = BN_CTX_get(ctx);
	if (d == NULL || r == NULL) goto err;

d332 1
d336 1
d342 2
a343 3
	BN_init(&val[0]);
	ts=1;
	if (a->neg || BN_ucmp(a,m) >= 0)
d345 2
a346 3
		if (!BN_nnmod(&(val[0]),a,m,ctx))
			goto err;
		aa= &(val[0]);
d350 11
a360 6
	if (BN_is_zero(aa))
		{
		ret = BN_zero(rr);
		goto err;
		}
	if (!BN_to_montgomery(&(val[0]),aa,mont,ctx)) goto err; /* 1 */
d362 2
a363 2
	window = BN_window_bits_for_exponent_size(bits);
	if (window > 1)
d365 3
a367 9
		if (!BN_mod_mul_montgomery(d,&(val[0]),&(val[0]),mont,ctx)) goto err; /* 2 */
		j=1<<(window-1);
		for (i=1; i<j; i++)
			{
			BN_init(&(val[i]));
			if (!BN_mod_mul_montgomery(&(val[i]),&(val[i-1]),d,mont,ctx))
				goto err;
			}
		ts=i;
d369 2
d379 1
a379 1
	if (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;
d422 1
a422 1
		if (!BN_mod_mul_montgomery(r,r,&(val[wvalue>>1]),mont,ctx))
d431 1
a431 1
	if (!BN_from_montgomery(rr,r,mont,ctx)) goto err;
d435 3
a437 3
	BN_CTX_end(ctx);
	for (i=0; i<ts; i++)
		BN_clear_free(&(val[i]));
d440 1
a440 141

int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,
                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
	{
	BN_MONT_CTX *mont = NULL;
	int b, bits, ret=0;
	int r_is_one;
	BN_ULONG w, next_w;
	BIGNUM *d, *r, *t;
	BIGNUM *swap_tmp;
#define BN_MOD_MUL_WORD(r, w, m) \
		(BN_mul_word(r, (w)) && \
		(/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \
			(BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))
		/* BN_MOD_MUL_WORD is only used with 'w' large,
		 * so the BN_ucmp test is probably more overhead
		 * than always using BN_mod (which uses BN_copy if
		 * a similar test returns true). */
		/* We can use BN_mod and do not need BN_nnmod because our
		 * accumulator is never negative (the result of BN_mod does
		 * not depend on the sign of the modulus).
		 */
#define BN_TO_MONTGOMERY_WORD(r, w, mont) \
		(BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))

	bn_check_top(p);
	bn_check_top(m);

	if (m->top == 0 || !(m->d[0] & 1))
		{
		BNerr(BN_F_BN_MOD_EXP_MONT_WORD,BN_R_CALLED_WITH_EVEN_MODULUS);
		return(0);
		}
	if (m->top == 1)
		a %= m->d[0]; /* make sure that 'a' is reduced */

	bits = BN_num_bits(p);
	if (bits == 0)
		{
		ret = BN_one(rr);
		return ret;
		}
	if (a == 0)
		{
		ret = BN_zero(rr);
		return ret;
		}

	BN_CTX_start(ctx);
	d = BN_CTX_get(ctx);
	r = BN_CTX_get(ctx);
	t = BN_CTX_get(ctx);
	if (d == NULL || r == NULL || t == NULL) goto err;

	if (in_mont != NULL)
		mont=in_mont;
	else
		{
		if ((mont = BN_MONT_CTX_new()) == NULL) goto err;
		if (!BN_MONT_CTX_set(mont, m, ctx)) goto err;
		}

	r_is_one = 1; /* except for Montgomery factor */

	/* bits-1 >= 0 */

	/* The result is accumulated in the product r*w. */
	w = a; /* bit 'bits-1' of 'p' is always set */
	for (b = bits-2; b >= 0; b--)
		{
		/* First, square r*w. */
		next_w = w*w;
		if ((next_w/w) != w) /* overflow */
			{
			if (r_is_one)
				{
				if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;
				r_is_one = 0;
				}
			else
				{
				if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
				}
			next_w = 1;
			}
		w = next_w;
		if (!r_is_one)
			{
			if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) goto err;
			}

		/* Second, multiply r*w by 'a' if exponent bit is set. */
		if (BN_is_bit_set(p, b))
			{
			next_w = w*a;
			if ((next_w/a) != w) /* overflow */
				{
				if (r_is_one)
					{
					if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;
					r_is_one = 0;
					}
				else
					{
					if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
					}
				next_w = a;
				}
			w = next_w;
			}
		}

	/* Finally, set r:=r*w. */
	if (w != 1)
		{
		if (r_is_one)
			{
			if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;
			r_is_one = 0;
			}
		else
			{
			if (!BN_MOD_MUL_WORD(r, w, m)) goto err;
			}
		}

	if (r_is_one) /* can happen only if a == 1*/
		{
		if (!BN_one(rr)) goto err;
		}
	else
		{
		if (!BN_from_montgomery(rr, r, mont, ctx)) goto err;
		}
	ret = 1;
err:
	if ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);
	BN_CTX_end(ctx);
	return(ret);
	}

d443 6
a448 3
int BN_mod_exp_simple(BIGNUM *r,
	const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,
	BN_CTX *ctx)
d450 1
a450 1
	int i,j,bits,ret=0,wstart,wend,window,wvalue,ts=0;
d453 1
a453 1
	BIGNUM val[TABLE_SIZE];
d455 1
d460 2
a461 2
		ret = BN_one(r);
		return ret;
d464 13
a476 2
	BN_CTX_start(ctx);
	if ((d = BN_CTX_get(ctx)) == NULL) goto err;
d478 2
a479 4
	BN_init(&(val[0]));
	ts=1;
	if (!BN_nnmod(&(val[0]),a,m,ctx)) goto err;		/* 1 */
	if (BN_is_zero(&(val[0])))
d481 3
a483 17
		ret = BN_zero(r);
		goto err;
		}

	window = BN_window_bits_for_exponent_size(bits);
	if (window > 1)
		{
		if (!BN_mod_mul(d,&(val[0]),&(val[0]),m,ctx))
			goto err;				/* 2 */
		j=1<<(window-1);
		for (i=1; i<j; i++)
			{
			BN_init(&(val[i]));
			if (!BN_mod_mul(&(val[i]),&(val[i-1]),d,m,ctx))
				goto err;
			}
		ts=i;
d485 2
d537 1
a537 1
		if (!BN_mod_mul(r,r,&(val[wvalue>>1]),m,ctx))
d548 3
a550 3
	BN_CTX_end(ctx);
	for (i=0; i<ts; i++)
		BN_clear_free(&(val[i]));
@


1.1.1.3
log
@import of openssl-0.9.7j
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
a115 1
/* maximum precomputation table size for *variable* sliding windows */
a123 7
	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
		{
		/* BN_FLG_EXP_CONSTTIME only supported by BN_mod_exp_mont() */
		BNerr(BN_F_BN_EXP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return -1;
		}

d207 1
a207 1
		if (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) == 0))
a236 7
	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
		{
		/* BN_FLG_EXP_CONSTTIME only supported by BN_mod_exp_mont() */
		BNerr(BN_F_BN_MOD_EXP_RECP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return -1;
		}

a363 5
	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
		{
		return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);
		}

a495 206

/* BN_mod_exp_mont_consttime() stores the precomputed powers in a specific layout
 * so that accessing any of these table values shows the same access pattern as far
 * as cache lines are concerned.  The following functions are used to transfer a BIGNUM
 * from/to that table. */

static int MOD_EXP_CTIME_COPY_TO_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx, int width)
	{
	size_t i, j;

	if (bn_wexpand(b, top) == NULL)
		return 0;
	while (b->top < top)
		{
		b->d[b->top++] = 0;
		}
	
	for (i = 0, j=idx; i < top * sizeof b->d[0]; i++, j+=width)
		{
		buf[j] = ((unsigned char*)b->d)[i];
		}

	bn_fix_top(b);
	return 1;
	}

static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx, int width)
	{
	size_t i, j;

	if (bn_wexpand(b, top) == NULL)
		return 0;

	for (i=0, j=idx; i < top * sizeof b->d[0]; i++, j+=width)
		{
		((unsigned char*)b->d)[i] = buf[j];
		}

	b->top = top;
	bn_fix_top(b);
	return 1;
	}	

/* Given a pointer value, compute the next address that is a cache line multiple. */
#define MOD_EXP_CTIME_ALIGN(x_) \
	((unsigned char*)(x_) + (MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH - (((BN_ULONG)(x_)) & (MOD_EXP_CTIME_MIN_CACHE_LINE_MASK))))

/* This variant of BN_mod_exp_mont() uses fixed windows and the special
 * precomputation memory layout to limit data-dependency to a minimum
 * to protect secret exponents (cf. the hyper-threading timing attacks
 * pointed out by Colin Percival,
 * http://www.daemonology.net/hyperthreading-considered-harmful/)
 */
int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
		    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
	{
	int i,bits,ret=0,idx,window,wvalue;
	int top;
 	BIGNUM *r;
	const BIGNUM *aa;
	BN_MONT_CTX *mont=NULL;

	int numPowers;
	unsigned char *powerbufFree=NULL;
	int powerbufLen = 0;
	unsigned char *powerbuf=NULL;
	BIGNUM *computeTemp=NULL, *am=NULL;

	bn_check_top(a);
	bn_check_top(p);
	bn_check_top(m);

	top = m->top;

	if (!(m->d[0] & 1))
		{
		BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME,BN_R_CALLED_WITH_EVEN_MODULUS);
		return(0);
		}
	bits=BN_num_bits(p);
	if (bits == 0)
		{
		ret = BN_one(rr);
		return ret;
		}

 	/* Initialize BIGNUM context and allocate intermediate result */
	BN_CTX_start(ctx);
	r = BN_CTX_get(ctx);
	if (r == NULL) goto err;

	/* Allocate a montgomery context if it was not supplied by the caller.
	 * If this is not done, things will break in the montgomery part.
 	 */
	if (in_mont != NULL)
		mont=in_mont;
	else
		{
		if ((mont=BN_MONT_CTX_new()) == NULL) goto err;
		if (!BN_MONT_CTX_set(mont,m,ctx)) goto err;
		}

	/* Get the window size to use with size of p. */
	window = BN_window_bits_for_ctime_exponent_size(bits);

	/* Allocate a buffer large enough to hold all of the pre-computed
	 * powers of a.
	 */
	numPowers = 1 << window;
	powerbufLen = sizeof(m->d[0])*top*numPowers;
	if ((powerbufFree=(unsigned char*)OPENSSL_malloc(powerbufLen+MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH)) == NULL)
		goto err;
		
	powerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);
	memset(powerbuf, 0, powerbufLen);

 	/* Initialize the intermediate result. Do this early to save double conversion,
	 * once each for a^0 and intermediate result.
	 */
 	if (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;
	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(r, top, powerbuf, 0, numPowers)) goto err;

	/* Initialize computeTemp as a^1 with montgomery precalcs */
	computeTemp = BN_CTX_get(ctx);
	am = BN_CTX_get(ctx);
	if (computeTemp==NULL || am==NULL) goto err;

	if (a->neg || BN_ucmp(a,m) >= 0)
		{
		if (!BN_mod(am,a,m,ctx))
			goto err;
		aa= am;
		}
	else
		aa=a;
	if (!BN_to_montgomery(am,aa,mont,ctx)) goto err;
	if (!BN_copy(computeTemp, am)) goto err;
	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(am, top, powerbuf, 1, numPowers)) goto err;

	/* If the window size is greater than 1, then calculate
	 * val[i=2..2^winsize-1]. Powers are computed as a*a^(i-1)
	 * (even powers could instead be computed as (a^(i/2))^2
	 * to use the slight performance advantage of sqr over mul).
	 */
	if (window > 1)
		{
		for (i=2; i<numPowers; i++)
			{
			/* Calculate a^i = a^(i-1) * a */
			if (!BN_mod_mul_montgomery(computeTemp,am,computeTemp,mont,ctx))
				goto err;
			if (!MOD_EXP_CTIME_COPY_TO_PREBUF(computeTemp, top, powerbuf, i, numPowers)) goto err;
			}
		}

 	/* Adjust the number of bits up to a multiple of the window size.
 	 * If the exponent length is not a multiple of the window size, then
 	 * this pads the most significant bits with zeros to normalize the
 	 * scanning loop to there's no special cases.
 	 *
 	 * * NOTE: Making the window size a power of two less than the native
	 * * word size ensures that the padded bits won't go past the last
 	 * * word in the internal BIGNUM structure. Going past the end will
 	 * * still produce the correct result, but causes a different branch
 	 * * to be taken in the BN_is_bit_set function.
 	 */
 	bits = ((bits+window-1)/window)*window;
 	idx=bits-1;	/* The top bit of the window */

 	/* Scan the exponent one window at a time starting from the most
 	 * significant bits.
 	 */
 	while (idx >= 0)
  		{
 		wvalue=0; /* The 'value' of the window */
 		
 		/* Scan the window, squaring the result as we go */
 		for (i=0; i<window; i++,idx--)
 			{
			if (!BN_mod_mul_montgomery(r,r,r,mont,ctx))	goto err;
			wvalue = (wvalue<<1)+BN_is_bit_set(p,idx);
  			}
 		
		/* Fetch the appropriate pre-computed value from the pre-buf */
		if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(computeTemp, top, powerbuf, wvalue, numPowers)) goto err;

 		/* Multiply the result into the intermediate result */
 		if (!BN_mod_mul_montgomery(r,r,computeTemp,mont,ctx)) goto err;
  		}

 	/* Convert the final result from montgomery to standard format */
	if (!BN_from_montgomery(rr,r,mont,ctx)) goto err;
	ret=1;
err:
	if ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);
	if (powerbuf!=NULL)
		{
		OPENSSL_cleanse(powerbuf,powerbufLen);
		OPENSSL_free(powerbufFree);
		}
 	if (am!=NULL) BN_clear(am);
 	if (computeTemp!=NULL) BN_clear(computeTemp);
	BN_CTX_end(ctx);
	return(ret);
	}

a519 7
	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
		{
		/* BN_FLG_EXP_CONSTTIME only supported by BN_mod_exp_mont() */
		BNerr(BN_F_BN_MOD_EXP_MONT_WORD,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return -1;
		}

a645 7

	if (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)
		{
		/* BN_FLG_EXP_CONSTTIME only supported by BN_mod_exp_mont() */
		BNerr(BN_F_BN_MOD_EXP_SIMPLE,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return -1;
		}
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d125 1
a125 1
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
d127 1
a127 1
		/* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
a157 1
	bn_check_top(r);
d215 1
a215 1
		if (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_CONSTTIME) == 0))
a231 1
	bn_check_top(r);
d240 1
a240 1
	int start=1;
d242 1
a242 2
	/* Table of variables obtained from 'ctx' */
	BIGNUM *val[TABLE_SIZE];
d245 1
a245 1
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
d247 1
a247 1
		/* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
d261 1
a261 3
	aa = BN_CTX_get(ctx);
	val[0] = BN_CTX_get(ctx);
	if(!aa || !val[0]) goto err;
d276 5
a280 2
	if (!BN_nnmod(val[0],a,m,ctx)) goto err;		/* 1 */
	if (BN_is_zero(val[0]))
d282 1
a282 2
		BN_zero(r);
		ret = 1;
d289 1
a289 1
		if (!BN_mod_mul_reciprocal(aa,val[0],val[0],&recp,ctx))
d294 2
a295 3
			if(((val[i] = BN_CTX_get(ctx)) == NULL) ||
					!BN_mod_mul_reciprocal(val[i],val[i-1],
						aa,&recp,ctx))
d298 1
d350 1
a350 1
		if (!BN_mod_mul_reciprocal(r,r,val[wvalue>>1],&recp,ctx))
d362 2
a364 1
	bn_check_top(r);
d373 1
a373 1
	int start=1;
d376 1
a376 2
	/* Table of variables obtained from 'ctx' */
	BIGNUM *val[TABLE_SIZE];
d379 1
a379 1
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
d388 1
a388 1
	if (!BN_is_odd(m))
d403 1
a403 2
	val[0] = BN_CTX_get(ctx);
	if (!d || !r || !val[0]) goto err;
d416 2
d420 1
a420 1
		if (!BN_nnmod(val[0],a,m,ctx))
d422 1
a422 1
		aa= val[0];
d428 1
a428 2
		BN_zero(rr);
		ret = 1;
d431 1
a431 1
	if (!BN_to_montgomery(val[0],aa,mont,ctx)) goto err; /* 1 */
d436 1
a436 1
		if (!BN_mod_mul_montgomery(d,val[0],val[0],mont,ctx)) goto err; /* 2 */
d440 2
a441 3
			if(((val[i] = BN_CTX_get(ctx)) == NULL) ||
					!BN_mod_mul_montgomery(val[i],val[i-1],
						d,mont,ctx))
d444 1
d497 1
a497 1
		if (!BN_mod_mul_montgomery(r,r,val[wvalue>>1],mont,ctx))
d511 2
a512 1
	bn_check_top(rr);
d538 1
a538 1
	bn_correct_top(b);
d555 1
a555 1
	bn_correct_top(b);
d746 1
a746 1
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
d748 1
a748 1
		/* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
d756 1
a756 1
	if (!BN_is_odd(m))
d772 1
a772 2
		BN_zero(rr);
		ret = 1;
a865 1
	bn_check_top(rr);
d871 3
a873 2
int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
		const BIGNUM *m, BN_CTX *ctx)
d875 1
a875 1
	int i,j,bits,ret=0,wstart,wend,window,wvalue;
d878 1
a878 2
	/* Table of variables obtained from 'ctx' */
	BIGNUM *val[TABLE_SIZE];
d880 1
a880 1
	if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0)
d882 1
a882 1
		/* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
d896 1
a896 3
	d = BN_CTX_get(ctx);
	val[0] = BN_CTX_get(ctx);
	if(!d || !val[0]) goto err;
d898 4
a901 2
	if (!BN_nnmod(val[0],a,m,ctx)) goto err;		/* 1 */
	if (BN_is_zero(val[0]))
d903 1
a903 2
		BN_zero(r);
		ret = 1;
d910 1
a910 1
		if (!BN_mod_mul(d,val[0],val[0],m,ctx))
d915 2
a916 2
			if(((val[i] = BN_CTX_get(ctx)) == NULL) ||
					!BN_mod_mul(val[i],val[i-1],d,m,ctx))
d919 1
d971 1
a971 1
		if (!BN_mod_mul(r,r,val[wvalue>>1],m,ctx))
d983 2
a984 1
	bn_check_top(r);
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d137 1
a137 2
	v = BN_CTX_get(ctx);
	if (rr == NULL || v == NULL) goto err;
@


1.1.1.6
log
@import OpenSSL-1.0.1c
@
text
@a115 12
#include <stdlib.h>
#ifdef _WIN32
# include <malloc.h>
# ifndef alloca
#  define alloca _alloca
# endif
#elif defined(__GNUC__)
# ifndef alloca
#  define alloca(s) __builtin_alloca((s))
# endif
#endif

d525 1
a525 1
static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top, unsigned char *buf, int idx, int width)
d529 7
a535 2
	if (top > b->top)
		top = b->top; /* this works because 'buf' is explicitly zeroed */
d541 1
d564 1
a564 1
	((unsigned char*)(x_) + (MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH - (((size_t)(x_)) & (MOD_EXP_CTIME_MIN_CACHE_LINE_MASK))))
d575 1
a575 1
	int i,bits,ret=0,window,wvalue;
d577 2
d585 1
a585 1
	BIGNUM tmp, am;
d605 1
d607 2
a622 3
#if defined(OPENSSL_BN_ASM_MONT5)
	if (window==6 && bits<=1024) window=5;	/* ~5% improvement of 2048-bit RSA sign */
#endif
d625 1
a625 1
	 * powers of am, am itself and tmp.
d628 1
a628 7
	powerbufLen = sizeof(m->d[0])*(top*numPowers +
				((2*top)>numPowers?(2*top):numPowers));
#ifdef alloca
	if (powerbufLen < 3072)
		powerbufFree = alloca(powerbufLen+MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);
	else
#endif
d635 5
a639 4
#ifdef alloca
	if (powerbufLen < 3072)
		powerbufFree = NULL;
#endif
d641 4
a644 17
	/* lay down tmp and am right after powers table */
	tmp.d     = (BN_ULONG *)(powerbuf + sizeof(m->d[0])*top*numPowers);
	am.d      = tmp.d + top;
	tmp.top   = am.top  = 0;
	tmp.dmax  = am.dmax = top;
	tmp.neg   = am.neg  = 0;
	tmp.flags = am.flags = BN_FLG_STATIC_DATA;

	/* prepare a^0 in Montgomery domain */
#if 1
 	if (!BN_to_montgomery(&tmp,BN_value_one(),mont,ctx))	goto err;
#else
	tmp.d[0] = (0-m->d[0])&BN_MASK2;	/* 2^(top*BN_BITS2) - m */
	for (i=1;i<top;i++)
		tmp.d[i] = (~m->d[i])&BN_MASK2;
	tmp.top = top;
#endif
a645 1
	/* prepare a^1 in Montgomery domain */
d648 3
a650 2
		if (!BN_mod(&am,a,m,ctx))			goto err;
		if (!BN_to_montgomery(&am,&am,mont,ctx))	goto err;
d652 5
a656 98
	else	if (!BN_to_montgomery(&am,a,mont,ctx))		goto err;

#if defined(OPENSSL_BN_ASM_MONT5)
    /* This optimization uses ideas from http://eprint.iacr.org/2011/239,
     * specifically optimization of cache-timing attack countermeasures
     * and pre-computation optimization. */

    /* Dedicated window==4 case improves 512-bit RSA sign by ~15%, but as
     * 512-bit RSA is hardly relevant, we omit it to spare size... */ 
    if (window==5)
	{
	void bn_mul_mont_gather5(BN_ULONG *rp,const BN_ULONG *ap,
			const void *table,const BN_ULONG *np,
			const BN_ULONG *n0,int num,int power);
	void bn_scatter5(const BN_ULONG *inp,size_t num,
			void *table,size_t power);
	void bn_gather5(BN_ULONG *out,size_t num,
			void *table,size_t power);

	BN_ULONG *np=mont->N.d, *n0=mont->n0;

	/* BN_to_montgomery can contaminate words above .top
	 * [in BN_DEBUG[_DEBUG] build]... */
	for (i=am.top; i<top; i++)	am.d[i]=0;
	for (i=tmp.top; i<top; i++)	tmp.d[i]=0;

	bn_scatter5(tmp.d,top,powerbuf,0);
	bn_scatter5(am.d,am.top,powerbuf,1);
	bn_mul_mont(tmp.d,am.d,am.d,np,n0,top);
	bn_scatter5(tmp.d,top,powerbuf,2);

#if 0
	for (i=3; i<32; i++)
		{
		/* Calculate a^i = a^(i-1) * a */
		bn_mul_mont_gather5(tmp.d,am.d,powerbuf,np,n0,top,i-1);
		bn_scatter5(tmp.d,top,powerbuf,i);
		}
#else
	/* same as above, but uses squaring for 1/2 of operations */
	for (i=4; i<32; i*=2)
		{
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_scatter5(tmp.d,top,powerbuf,i);
		}
	for (i=3; i<8; i+=2)
		{
		int j;
		bn_mul_mont_gather5(tmp.d,am.d,powerbuf,np,n0,top,i-1);
		bn_scatter5(tmp.d,top,powerbuf,i);
		for (j=2*i; j<32; j*=2)
			{
			bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
			bn_scatter5(tmp.d,top,powerbuf,j);
			}
		}
	for (; i<16; i+=2)
		{
		bn_mul_mont_gather5(tmp.d,am.d,powerbuf,np,n0,top,i-1);
		bn_scatter5(tmp.d,top,powerbuf,i);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_scatter5(tmp.d,top,powerbuf,2*i);
		}
	for (; i<32; i+=2)
		{
		bn_mul_mont_gather5(tmp.d,am.d,powerbuf,np,n0,top,i-1);
		bn_scatter5(tmp.d,top,powerbuf,i);
		}
#endif
	bits--;
	for (wvalue=0, i=bits%5; i>=0; i--,bits--)
		wvalue = (wvalue<<1)+BN_is_bit_set(p,bits);
	bn_gather5(tmp.d,top,powerbuf,wvalue);

	/* Scan the exponent one window at a time starting from the most
	 * significant bits.
	 */
	while (bits >= 0)
		{
		for (wvalue=0, i=0; i<5; i++,bits--)
			wvalue = (wvalue<<1)+BN_is_bit_set(p,bits);

		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont(tmp.d,tmp.d,tmp.d,np,n0,top);
		bn_mul_mont_gather5(tmp.d,tmp.d,powerbuf,np,n0,top,wvalue);
		}

	tmp.top=top;
	bn_correct_top(&tmp);
	}
    else
#endif
	{
	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers)) goto err;
	if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am,  top, powerbuf, 1, numPowers)) goto err;
d665 1
a665 3
		if (!BN_mod_mul_montgomery(&tmp,&am,&am,mont,ctx))	goto err;
		if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 2, numPowers)) goto err;
		for (i=3; i<numPowers; i++)
d668 1
a668 1
			if (!BN_mod_mul_montgomery(&tmp,&am,&tmp,mont,ctx))
d670 1
a670 1
			if (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, i, numPowers)) goto err;
d674 18
a691 9
	bits--;
	for (wvalue=0, i=bits%window; i>=0; i--,bits--)
		wvalue = (wvalue<<1)+BN_is_bit_set(p,bits);
	if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&tmp,top,powerbuf,wvalue,numPowers)) goto err;
 
	/* Scan the exponent one window at a time starting from the most
	 * significant bits.
	 */
 	while (bits >= 0)
d696 1
a696 1
 		for (i=0; i<window; i++,bits--)
d698 2
a699 2
			if (!BN_mod_mul_montgomery(&tmp,&tmp,&tmp,mont,ctx))	goto err;
			wvalue = (wvalue<<1)+BN_is_bit_set(p,bits);
d703 1
a703 1
		if (!MOD_EXP_CTIME_COPY_FROM_PREBUF(&am, top, powerbuf, wvalue, numPowers)) goto err;
d706 1
a706 1
 		if (!BN_mod_mul_montgomery(&tmp,&tmp,&am,mont,ctx)) goto err;
a707 1
	}
d710 1
a710 1
	if (!BN_from_montgomery(rr,&tmp,mont,ctx)) goto err;
d717 1
a717 1
		if (powerbufFree) OPENSSL_free(powerbufFree);
d719 2
d991 1
@


