head	1.37;
access;
symbols
	OPENBSD_6_1:1.37.0.2
	OPENBSD_6_1_BASE:1.37;
locks; strict;
comment	@ * @;


1.37
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.36;
commitid	kT0fLt3r4lroFJra;

1.36
date	2016.03.15.20.50.22;	author krw;	state Exp;
branches;
next	1.35;
commitid	JZR2bOwahEjnBJaG;

1.35
date	2016.03.04.16.23.30;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	1XEMxcBWn26RC9Sb;

1.34
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.33;
commitid	vHznCDK3idwNEFz4;

1.33
date	2014.07.12.16.03.36;	author miod;	state Exp;
branches;
next	1.32;
commitid	G74O1dmRukKsW7IJ;

1.32
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.31;
commitid	yQEL1wOWIearrW15;

1.31
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.30;
commitid	nzndm3zqPmFurSaK;

1.30
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.29;
commitid	id8dTrTMtnTn4fqt;

1.29
date	2014.07.09.11.10.50;	author bcook;	state Exp;
branches;
next	1.28;
commitid	lHJTcoC4c5BhEOGj;

1.28
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	mJUVYpkFBZ0Zv2bG;

1.27
date	2014.05.29.21.19.30;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.05.08.13.20.49;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.05.07.21.09.03;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.07.21.06.05;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2014.05.07.13.45.29;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2014.05.05.18.38.42;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.24.21.31.02;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.23.19.14.59;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.09.12.15.31;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.29.21.12.50;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.25.19.53.59;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.05.11.05.07;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.02.58;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.21;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.18;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.44;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.58;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.36.35;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.42;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.41.35;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.01.09.12.13.52;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.36;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.04.13.15.16.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: bn_lib.c,v 1.36 2016/03/15 20:50:22 krw Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#ifndef BN_DEBUG
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
#endif

#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/err.h>

#include "bn_lcl.h"

/* This stuff appears to be completely unused, so is deprecated */
#ifndef OPENSSL_NO_DEPRECATED
/* For a 32 bit machine
 * 2 -   4 ==  128
 * 3 -   8 ==  256
 * 4 -  16 ==  512
 * 5 -  32 == 1024
 * 6 -  64 == 2048
 * 7 - 128 == 4096
 * 8 - 256 == 8192
 */
static int bn_limit_bits = 0;
static int bn_limit_num = 8;        /* (1<<bn_limit_bits) */
static int bn_limit_bits_low = 0;
static int bn_limit_num_low = 8;    /* (1<<bn_limit_bits_low) */
static int bn_limit_bits_high = 0;
static int bn_limit_num_high = 8;   /* (1<<bn_limit_bits_high) */
static int bn_limit_bits_mont = 0;
static int bn_limit_num_mont = 8;   /* (1<<bn_limit_bits_mont) */

void
BN_set_params(int mult, int high, int low, int mont)
{
	if (mult >= 0) {
		if (mult > (int)(sizeof(int) * 8) - 1)
			mult = sizeof(int) * 8 - 1;
		bn_limit_bits = mult;
		bn_limit_num = 1 << mult;
	}
	if (high >= 0) {
		if (high > (int)(sizeof(int) * 8) - 1)
			high = sizeof(int) * 8 - 1;
		bn_limit_bits_high = high;
		bn_limit_num_high = 1 << high;
	}
	if (low >= 0) {
		if (low > (int)(sizeof(int) * 8) - 1)
			low = sizeof(int) * 8 - 1;
		bn_limit_bits_low = low;
		bn_limit_num_low = 1 << low;
	}
	if (mont >= 0) {
		if (mont > (int)(sizeof(int) * 8) - 1)
			mont = sizeof(int) * 8 - 1;
		bn_limit_bits_mont = mont;
		bn_limit_num_mont = 1 << mont;
	}
}

int
BN_get_params(int which)
{
	if (which == 0)
		return (bn_limit_bits);
	else if (which == 1)
		return (bn_limit_bits_high);
	else if (which == 2)
		return (bn_limit_bits_low);
	else if (which == 3)
		return (bn_limit_bits_mont);
	else
		return (0);
}
#endif

const BIGNUM *
BN_value_one(void)
{
	static const BN_ULONG data_one = 1L;
	static const BIGNUM const_one = {
		(BN_ULONG *)&data_one, 1, 1, 0, BN_FLG_STATIC_DATA
	};

	return (&const_one);
}

int
BN_num_bits_word(BN_ULONG l)
{
	static const unsigned char bits[256] = {
		0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
		5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	};

#ifdef _LP64
	if (l & 0xffffffff00000000L) {
		if (l & 0xffff000000000000L) {
			if (l & 0xff00000000000000L) {
				return (bits[(int)(l >> 56)] + 56);
			} else
				return (bits[(int)(l >> 48)] + 48);
		} else {
			if (l & 0x0000ff0000000000L) {
				return (bits[(int)(l >> 40)] + 40);
			} else
				return (bits[(int)(l >> 32)] + 32);
		}
	} else
#endif
	{
		if (l & 0xffff0000L) {
			if (l & 0xff000000L)
				return (bits[(int)(l >> 24L)] + 24);
			else
				return (bits[(int)(l >> 16L)] + 16);
		} else {
			if (l & 0xff00L)
				return (bits[(int)(l >> 8)] + 8);
			else
				return (bits[(int)(l)]);
		}
	}
}

int
BN_num_bits(const BIGNUM *a)
{
	int i = a->top - 1;

	bn_check_top(a);

	if (BN_is_zero(a))
		return 0;
	return ((i * BN_BITS2) + BN_num_bits_word(a->d[i]));
}

void
BN_clear_free(BIGNUM *a)
{
	int i;

	if (a == NULL)
		return;
	bn_check_top(a);
	if (a->d != NULL && !(BN_get_flags(a, BN_FLG_STATIC_DATA))) {
		explicit_bzero(a->d, a->dmax * sizeof(a->d[0]));
		free(a->d);
	}
	i = BN_get_flags(a, BN_FLG_MALLOCED);
	explicit_bzero(a, sizeof(BIGNUM));
	if (i)
		free(a);
}

void
BN_free(BIGNUM *a)
{
	BN_clear_free(a);
}

void
BN_init(BIGNUM *a)
{
	memset(a, 0, sizeof(BIGNUM));
	bn_check_top(a);
}

BIGNUM *
BN_new(void)
{
	BIGNUM *ret;

	if ((ret = malloc(sizeof(BIGNUM))) == NULL) {
		BNerror(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}
	ret->flags = BN_FLG_MALLOCED;
	ret->top = 0;
	ret->neg = 0;
	ret->dmax = 0;
	ret->d = NULL;
	bn_check_top(ret);
	return (ret);
}

/* This is used both by bn_expand2() and bn_dup_expand() */
/* The caller MUST check that words > b->dmax before calling this */
static BN_ULONG *
bn_expand_internal(const BIGNUM *b, int words)
{
	BN_ULONG *A, *a = NULL;
	const BN_ULONG *B;
	int i;

	bn_check_top(b);

	if (words > (INT_MAX/(4*BN_BITS2))) {
		BNerror(BN_R_BIGNUM_TOO_LONG);
		return NULL;
	}
	if (BN_get_flags(b, BN_FLG_STATIC_DATA)) {
		BNerror(BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
		return (NULL);
	}
	a = A = reallocarray(NULL, words, sizeof(BN_ULONG));
	if (A == NULL) {
		BNerror(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}
#if 1
	B = b->d;
	/* Check if the previous number needs to be copied */
	if (B != NULL) {
		for (i = b->top >> 2; i > 0; i--, A += 4, B += 4) {
			/*
			 * The fact that the loop is unrolled
			 * 4-wise is a tribute to Intel. It's
			 * the one that doesn't have enough
			 * registers to accommodate more data.
			 * I'd unroll it 8-wise otherwise:-)
			 *
			 *		<appro@@fy.chalmers.se>
			 */
			BN_ULONG a0, a1, a2, a3;
			a0 = B[0];
			a1 = B[1];
			a2 = B[2];
			a3 = B[3];
			A[0] = a0;
			A[1] = a1;
			A[2] = a2;
			A[3] = a3;
		}
		switch (b->top & 3) {
		case 3:
			A[2] = B[2];
		case 2:
			A[1] = B[1];
		case 1:
			A[0] = B[0];
		}
	}

#else
	memset(A, 0, sizeof(BN_ULONG) * words);
	memcpy(A, b->d, sizeof(b->d[0]) * b->top);
#endif

	return (a);
}

/* This is an internal function that can be used instead of bn_expand2()
 * when there is a need to copy BIGNUMs instead of only expanding the
 * data part, while still expanding them.
 * Especially useful when needing to expand BIGNUMs that are declared
 * 'const' and should therefore not be changed.
 * The reason to use this instead of a BN_dup() followed by a bn_expand2()
 * is memory allocation overhead.  A BN_dup() followed by a bn_expand2()
 * will allocate new memory for the BIGNUM data twice, and free it once,
 * while bn_dup_expand() makes sure allocation is made only once.
 */

#ifndef OPENSSL_NO_DEPRECATED
BIGNUM *
bn_dup_expand(const BIGNUM *b, int words)
{
	BIGNUM *r = NULL;

	bn_check_top(b);

	/* This function does not work if
	 *      words <= b->dmax && top < words
	 * because BN_dup() does not preserve 'dmax'!
	 * (But bn_dup_expand() is not used anywhere yet.)
	 */

	if (words > b->dmax) {
		BN_ULONG *a = bn_expand_internal(b, words);

		if (a) {
			r = BN_new();
			if (r) {
				r->top = b->top;
				r->dmax = words;
				r->neg = b->neg;
				r->d = a;
			} else {
				/* r == NULL, BN_new failure */
				free(a);
			}
		}
		/* If a == NULL, there was an error in allocation in
		   bn_expand_internal(), and NULL should be returned */
	} else {
		r = BN_dup(b);
	}

	bn_check_top(r);
	return r;
}
#endif

/* This is an internal function that should not be used in applications.
 * It ensures that 'b' has enough room for a 'words' word number
 * and initialises any unused part of b->d with leading zeros.
 * It is mostly used by the various BIGNUM routines. If there is an error,
 * NULL is returned. If not, 'b' is returned. */

BIGNUM *
bn_expand2(BIGNUM *b, int words)
{
	bn_check_top(b);

	if (words > b->dmax) {
		BN_ULONG *a = bn_expand_internal(b, words);
		if (!a)
			return NULL;
		if (b->d) {
			explicit_bzero(b->d, b->dmax * sizeof(b->d[0]));
			free(b->d);
		}
		b->d = a;
		b->dmax = words;
	}

/* None of this should be necessary because of what b->top means! */
#if 0
	/* NB: bn_wexpand() calls this only if the BIGNUM really has to grow */
	if (b->top < b->dmax) {
		int i;
		BN_ULONG *A = &(b->d[b->top]);
		for (i = (b->dmax - b->top) >> 3; i > 0; i--, A += 8) {
			A[0] = 0;
			A[1] = 0;
			A[2] = 0;
			A[3] = 0;
			A[4] = 0;
			A[5] = 0;
			A[6] = 0;
			A[7] = 0;
		}
		for (i = (b->dmax - b->top)&7; i > 0; i--, A++)
			A[0] = 0;
		assert(A == &(b->d[b->dmax]));
	}
#endif
	bn_check_top(b);
	return b;
}

BIGNUM *
BN_dup(const BIGNUM *a)
{
	BIGNUM *t;

	if (a == NULL)
		return NULL;
	bn_check_top(a);

	t = BN_new();
	if (t == NULL)
		return NULL;
	if (!BN_copy(t, a)) {
		BN_free(t);
		return NULL;
	}
	bn_check_top(t);
	return t;
}

BIGNUM *
BN_copy(BIGNUM *a, const BIGNUM *b)
{
	int i;
	BN_ULONG *A;
	const BN_ULONG *B;

	bn_check_top(b);

	if (a == b)
		return (a);
	if (bn_wexpand(a, b->top) == NULL)
		return (NULL);

#if 1
	A = a->d;
	B = b->d;
	for (i = b->top >> 2; i > 0; i--, A += 4, B += 4) {
		BN_ULONG a0, a1, a2, a3;
		a0 = B[0];
		a1 = B[1];
		a2 = B[2];
		a3 = B[3];
		A[0] = a0;
		A[1] = a1;
		A[2] = a2;
		A[3] = a3;
	}
	switch (b->top & 3) {
	case 3:
		A[2] = B[2];
	case 2:
		A[1] = B[1];
	case 1:
		A[0] = B[0];
	}
#else
	memcpy(a->d, b->d, sizeof(b->d[0]) * b->top);
#endif

	a->top = b->top;
	a->neg = b->neg;
	bn_check_top(a);
	return (a);
}

void
BN_swap(BIGNUM *a, BIGNUM *b)
{
	int flags_old_a, flags_old_b;
	BN_ULONG *tmp_d;
	int tmp_top, tmp_dmax, tmp_neg;

	bn_check_top(a);
	bn_check_top(b);

	flags_old_a = a->flags;
	flags_old_b = b->flags;

	tmp_d = a->d;
	tmp_top = a->top;
	tmp_dmax = a->dmax;
	tmp_neg = a->neg;

	a->d = b->d;
	a->top = b->top;
	a->dmax = b->dmax;
	a->neg = b->neg;

	b->d = tmp_d;
	b->top = tmp_top;
	b->dmax = tmp_dmax;
	b->neg = tmp_neg;

	a->flags = (flags_old_a & BN_FLG_MALLOCED) |
	    (flags_old_b & BN_FLG_STATIC_DATA);
	b->flags = (flags_old_b & BN_FLG_MALLOCED) |
	    (flags_old_a & BN_FLG_STATIC_DATA);
	bn_check_top(a);
	bn_check_top(b);
}

void
BN_clear(BIGNUM *a)
{
	bn_check_top(a);
	if (a->d != NULL)
		memset(a->d, 0, a->dmax * sizeof(a->d[0]));
	a->top = 0;
	a->neg = 0;
}

BN_ULONG
BN_get_word(const BIGNUM *a)
{
	if (a->top > 1)
		return BN_MASK2;
	else if (a->top == 1)
		return a->d[0];
	/* a->top == 0 */
	return 0;
}

BIGNUM *
bn_expand(BIGNUM *a, int bits)
{
	if (bits > (INT_MAX - BN_BITS2 + 1))
		return (NULL);

	if (((bits + BN_BITS2 - 1) / BN_BITS2) <= a->dmax)
		return (a);

	return bn_expand2(a, (bits + BN_BITS2 - 1) / BN_BITS2);
}

int
BN_set_word(BIGNUM *a, BN_ULONG w)
{
	bn_check_top(a);
	if (bn_expand(a, (int)sizeof(BN_ULONG) * 8) == NULL)
		return (0);
	a->neg = 0;
	a->d[0] = w;
	a->top = (w ? 1 : 0);
	bn_check_top(a);
	return (1);
}

BIGNUM *
BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)
{
	unsigned int i, m;
	unsigned int n;
	BN_ULONG l;
	BIGNUM *bn = NULL;

	if (ret == NULL)
		ret = bn = BN_new();
	if (ret == NULL)
		return (NULL);
	bn_check_top(ret);
	l = 0;
	n = len;
	if (n == 0) {
		ret->top = 0;
		return (ret);
	}
	i = ((n - 1) / BN_BYTES) + 1;
	m = ((n - 1) % (BN_BYTES));
	if (bn_wexpand(ret, (int)i) == NULL) {
		BN_free(bn);
		return NULL;
	}
	ret->top = i;
	ret->neg = 0;
	while (n--) {
		l = (l << 8L) | *(s++);
		if (m-- == 0) {
			ret->d[--i] = l;
			l = 0;
			m = BN_BYTES - 1;
		}
	}
	/* need to call this due to clear byte at top if avoiding
	 * having the top bit set (-ve number) */
	bn_correct_top(ret);
	return (ret);
}

/* ignore negative */
int
BN_bn2bin(const BIGNUM *a, unsigned char *to)
{
	int n, i;
	BN_ULONG l;

	bn_check_top(a);
	n = i=BN_num_bytes(a);
	while (i--) {
		l = a->d[i / BN_BYTES];
		*(to++) = (unsigned char)(l >> (8 * (i % BN_BYTES))) & 0xff;
	}
	return (n);
}

int
BN_ucmp(const BIGNUM *a, const BIGNUM *b)
{
	int i;
	BN_ULONG t1, t2, *ap, *bp;

	bn_check_top(a);
	bn_check_top(b);

	i = a->top - b->top;
	if (i != 0)
		return (i);
	ap = a->d;
	bp = b->d;
	for (i = a->top - 1; i >= 0; i--) {
		t1 = ap[i];
		t2 = bp[i];
		if (t1 != t2)
			return ((t1 > t2) ? 1 : -1);
	}
	return (0);
}

int
BN_cmp(const BIGNUM *a, const BIGNUM *b)
{
	int i;
	int gt, lt;
	BN_ULONG t1, t2;

	if ((a == NULL) || (b == NULL)) {
		if (a != NULL)
			return (-1);
		else if (b != NULL)
			return (1);
		else
			return (0);
	}

	bn_check_top(a);
	bn_check_top(b);

	if (a->neg != b->neg) {
		if (a->neg)
			return (-1);
		else
			return (1);
	}
	if (a->neg == 0) {
		gt = 1;
		lt = -1;
	} else {
		gt = -1;
		lt = 1;
	}

	if (a->top > b->top)
		return (gt);
	if (a->top < b->top)
		return (lt);
	for (i = a->top - 1; i >= 0; i--) {
		t1 = a->d[i];
		t2 = b->d[i];
		if (t1 > t2)
			return (gt);
		if (t1 < t2)
			return (lt);
	}
	return (0);
}

int
BN_set_bit(BIGNUM *a, int n)
{
	int i, j, k;

	if (n < 0)
		return 0;

	i = n / BN_BITS2;
	j = n % BN_BITS2;
	if (a->top <= i) {
		if (bn_wexpand(a, i + 1) == NULL)
			return (0);
		for (k = a->top; k < i + 1; k++)
			a->d[k] = 0;
		a->top = i + 1;
	}

	a->d[i] |= (((BN_ULONG)1) << j);
	bn_check_top(a);
	return (1);
}

int
BN_clear_bit(BIGNUM *a, int n)
{
	int i, j;

	bn_check_top(a);
	if (n < 0)
		return 0;

	i = n / BN_BITS2;
	j = n % BN_BITS2;
	if (a->top <= i)
		return (0);

	a->d[i] &= (~(((BN_ULONG)1) << j));
	bn_correct_top(a);
	return (1);
}

int
BN_is_bit_set(const BIGNUM *a, int n)
{
	int i, j;

	bn_check_top(a);
	if (n < 0)
		return 0;
	i = n / BN_BITS2;
	j = n % BN_BITS2;
	if (a->top <= i)
		return 0;
	return (int)(((a->d[i]) >> j) & ((BN_ULONG)1));
}

int
BN_mask_bits(BIGNUM *a, int n)
{
	int b, w;

	bn_check_top(a);
	if (n < 0)
		return 0;

	w = n / BN_BITS2;
	b = n % BN_BITS2;
	if (w >= a->top)
		return 0;
	if (b == 0)
		a->top = w;
	else {
		a->top = w + 1;
		a->d[w] &= ~(BN_MASK2 << b);
	}
	bn_correct_top(a);
	return (1);
}

void
BN_set_negative(BIGNUM *a, int b)
{
	if (b && !BN_is_zero(a))
		a->neg = 1;
	else
		a->neg = 0;
}

int
bn_cmp_words(const BN_ULONG *a, const BN_ULONG *b, int n)
{
	int i;
	BN_ULONG aa, bb;

	aa = a[n - 1];
	bb = b[n - 1];
	if (aa != bb)
		return ((aa > bb) ? 1 : -1);
	for (i = n - 2; i >= 0; i--) {
		aa = a[i];
		bb = b[i];
		if (aa != bb)
			return ((aa > bb) ? 1 : -1);
	}
	return (0);
}

/* Here follows a specialised variants of bn_cmp_words().  It has the
   property of performing the operation on arrays of different sizes.
   The sizes of those arrays is expressed through cl, which is the
   common length ( basicall, min(len(a),len(b)) ), and dl, which is the
   delta between the two lengths, calculated as len(a)-len(b).
   All lengths are the number of BN_ULONGs...  */

int
bn_cmp_part_words(const BN_ULONG *a, const BN_ULONG *b, int cl, int dl)
{
	int n, i;

	n = cl - 1;

	if (dl < 0) {
		for (i = dl; i < 0; i++) {
			if (b[n - i] != 0)
				return -1; /* a < b */
		}
	}
	if (dl > 0) {
		for (i = dl; i > 0; i--) {
			if (a[n + i] != 0)
				return 1; /* a > b */
		}
	}
	return bn_cmp_words(a, b, cl);
}

/*
 * Constant-time conditional swap of a and b.
 * a and b are swapped if condition is not 0.  The code assumes that at most one bit of condition is set.
 * nwords is the number of words to swap.  The code assumes that at least nwords are allocated in both a and b,
 * and that no more than nwords are used by either a or b.
 * a and b cannot be the same number
 */
void
BN_consttime_swap(BN_ULONG condition, BIGNUM *a, BIGNUM *b, int nwords)
{
	BN_ULONG t;
	int i;

	bn_wcheck_size(a, nwords);
	bn_wcheck_size(b, nwords);

	assert(a != b);
	assert((condition & (condition - 1)) == 0);
	assert(sizeof(BN_ULONG) >= sizeof(int));

	condition = ((condition - 1) >> (BN_BITS2 - 1)) - 1;

	t = (a->top^b->top) & condition;
	a->top ^= t;
	b->top ^= t;

#define BN_CONSTTIME_SWAP(ind) \
	do { \
		t = (a->d[ind] ^ b->d[ind]) & condition; \
		a->d[ind] ^= t; \
		b->d[ind] ^= t; \
	} while (0)


	switch (nwords) {
	default:
		for (i = 10; i < nwords; i++)
			BN_CONSTTIME_SWAP(i);
		/* Fallthrough */
	case 10: BN_CONSTTIME_SWAP(9); /* Fallthrough */
	case 9: BN_CONSTTIME_SWAP(8); /* Fallthrough */
	case 8: BN_CONSTTIME_SWAP(7); /* Fallthrough */
	case 7: BN_CONSTTIME_SWAP(6); /* Fallthrough */
	case 6: BN_CONSTTIME_SWAP(5); /* Fallthrough */
	case 5: BN_CONSTTIME_SWAP(4); /* Fallthrough */
	case 4: BN_CONSTTIME_SWAP(3); /* Fallthrough */
	case 3: BN_CONSTTIME_SWAP(2); /* Fallthrough */
	case 2: BN_CONSTTIME_SWAP(1); /* Fallthrough */
	case 1:
		BN_CONSTTIME_SWAP(0);
	}
#undef BN_CONSTTIME_SWAP
}
@


1.36
log
@'accomodate' -> 'accommodate' in comments.

Started by diff from Mical Mazurek.
@
text
@d1 1
a1 1
/* $OpenBSD: bn_lib.c,v 1.35 2016/03/04 16:23:30 deraadt Exp $ */
d252 1
a252 1
		BNerr(BN_F_BN_NEW, ERR_R_MALLOC_FAILURE);
d276 1
a276 1
		BNerr(BN_F_BN_EXPAND_INTERNAL, BN_R_BIGNUM_TOO_LONG);
d280 1
a280 2
		BNerr(BN_F_BN_EXPAND_INTERNAL,
		    BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
d285 1
a285 1
		BNerr(BN_F_BN_EXPAND_INTERNAL, ERR_R_MALLOC_FAILURE);
@


1.35
log
@graduate bn_expand() to a real function.  the openssl version of this
uses a macro with multiple-evaluations of arguments (different amount
than the previous version..), but doug/bcook's inline version makes
BIGNUM not opaque [problem spotted by naddy]
ok doug
@
text
@d1 1
a1 1
/* $OpenBSD: bn_lib.c,v 1.34 2015/09/10 15:56:25 jsing Exp $ */
d298 1
a298 1
			 * registers to accomodate more data.
@


1.34
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_lib.c,v 1.33 2014/07/12 16:03:36 miod Exp $ */
d551 12
@


1.33
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_lib.c,v 1.32 2014/07/11 08:44:48 jsing Exp $ */
d224 1
a224 1
		OPENSSL_cleanse(a->d, a->dmax * sizeof(a->d[0]));
d228 1
a228 1
	OPENSSL_cleanse(a, sizeof(BIGNUM));
d398 1
a398 1
			OPENSSL_cleanse(b->d, b->dmax * sizeof(b->d[0]));
@


1.32
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_lib.c,v 1.31 2014/07/10 22:45:56 jsing Exp $ */
d588 1
a588 2
		if (bn)
			BN_free(bn);
@


1.31
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: bn_lib.c,v 1.30 2014/07/10 13:58:22 jsing Exp $ */
d71 2
a72 1
#include "cryptlib.h"
@


1.30
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_lib.c,v 1.29 2014/07/09 11:10:50 bcook Exp $ */
d68 2
@


1.29
log
@remove unused, private version strings except SSL_version_str

Also remove unused des_ver.h, which exports some of these strings, but is not installed.

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: bn_lib.c,v 1.28 2014/06/12 15:49:28 deraadt Exp $ */
d67 2
@


1.28
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a68 2

const char BN_version[] = "Big Number" OPENSSL_VERSION_PTEXT;
@


1.27
log
@ok, next pass after review:  when possible, put the reallocarray arguments
in the "size_t nmemb, size_t size"
@
text
@d1 1
a1 1
/* crypto/bn/bn_lib.c */
@


1.26
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d281 1
a281 1
	a = A = reallocarray(NULL, sizeof(BN_ULONG), words);
@


1.25
log
@Emergency knfectomie requested by tedu@@.
@
text
@d248 1
a248 1
	if ((ret = (BIGNUM *)malloc(sizeof(BIGNUM))) == NULL) {
d281 1
a281 1
	a = A = (BN_ULONG *)malloc(sizeof(BN_ULONG)*words);
@


1.24
log
@with the first bug it uncovered fixed, clear all bignums again.

i've never worked on codebase so resistant to efforts to improve it.
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d70 1
a70 1
const char BN_version[]="Big Number" OPENSSL_VERSION_PTEXT;
d83 8
a90 8
static int bn_limit_bits=0;
static int bn_limit_num=8;        /* (1<<bn_limit_bits) */
static int bn_limit_bits_low=0;
static int bn_limit_num_low=8;    /* (1<<bn_limit_bits_low) */
static int bn_limit_bits_high=0;
static int bn_limit_num_high=8;   /* (1<<bn_limit_bits_high) */
static int bn_limit_bits_mont=0;
static int bn_limit_num_mont=8;   /* (1<<bn_limit_bits_mont) */
d92 26
a117 30
void BN_set_params(int mult, int high, int low, int mont)
	{
	if (mult >= 0)
		{
		if (mult > (int)(sizeof(int)*8)-1)
			mult=sizeof(int)*8-1;
		bn_limit_bits=mult;
		bn_limit_num=1<<mult;
		}
	if (high >= 0)
		{
		if (high > (int)(sizeof(int)*8)-1)
			high=sizeof(int)*8-1;
		bn_limit_bits_high=high;
		bn_limit_num_high=1<<high;
		}
	if (low >= 0)
		{
		if (low > (int)(sizeof(int)*8)-1)
			low=sizeof(int)*8-1;
		bn_limit_bits_low=low;
		bn_limit_num_low=1<<low;
		}
	if (mont >= 0)
		{
		if (mont > (int)(sizeof(int)*8)-1)
			mont=sizeof(int)*8-1;
		bn_limit_bits_mont=mont;
		bn_limit_num_mont=1<<mont;
		}
d119 1
d121 14
a134 8
int BN_get_params(int which)
	{
	if      (which == 0) return(bn_limit_bits);
	else if (which == 1) return(bn_limit_bits_high);
	else if (which == 2) return(bn_limit_bits_low);
	else if (which == 3) return(bn_limit_bits_mont);
	else return(0);
	}
d137 7
a143 4
const BIGNUM *BN_value_one(void)
	{
	static const BN_ULONG data_one=1L;
	static const BIGNUM const_one={(BN_ULONG *)&data_one,1,1,0,BN_FLG_STATIC_DATA};
d145 2
a146 2
	return(&const_one);
	}
d148 21
a168 20
int BN_num_bits_word(BN_ULONG l)
	{
	static const unsigned char bits[256]={
		0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,
		5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
		6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
		7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
		8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
		8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
		8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
		8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
		8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
		8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
		8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
		8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
		};
d171 11
a181 18
	if (l & 0xffffffff00000000L)
		{
		if (l & 0xffff000000000000L)
			{
			if (l & 0xff00000000000000L)
				{
				return(bits[(int)(l>>56)]+56);
				}
			else	return(bits[(int)(l>>48)]+48);
			}
		else
			{
			if (l & 0x0000ff0000000000L)
				{
				return(bits[(int)(l>>40)]+40);
				}
			else	return(bits[(int)(l>>32)]+32);
			}
d183 1
a183 1
	else
d185 2
a186 3
		{
		if (l & 0xffff0000L)
			{
d188 4
a191 5
				return(bits[(int)(l>>24L)]+24);
			else	return(bits[(int)(l>>16L)]+16);
			}
		else
			{
d193 3
a195 4
				return(bits[(int)(l>>8)]+8);
			else	
				return(bits[(int)(l   )]  );
			}
d198 1
d200 3
a202 2
int BN_num_bits(const BIGNUM *a)
	{
d204 1
d207 4
a210 3
	if (BN_is_zero(a)) return 0;
	return ((i*BN_BITS2) + BN_num_bits_word(a->d[i]));
	}
d212 3
a214 2
void BN_clear_free(BIGNUM *a)
	{
d217 2
a218 1
	if (a == NULL) return;
d220 2
a221 3
	if (a->d != NULL && !(BN_get_flags(a,BN_FLG_STATIC_DATA)))
		{
		OPENSSL_cleanse(a->d,a->dmax*sizeof(a->d[0]));
d223 3
a225 3
		}
	i=BN_get_flags(a,BN_FLG_MALLOCED);
	OPENSSL_cleanse(a,sizeof(BIGNUM));
d228 1
a228 1
	}
d236 4
a239 3
void BN_init(BIGNUM *a)
	{
	memset(a,0,sizeof(BIGNUM));
d241 1
a241 1
	}
d243 3
a245 2
BIGNUM *BN_new(void)
	{
d248 9
a256 10
	if ((ret=(BIGNUM *)malloc(sizeof(BIGNUM))) == NULL)
		{
		BNerr(BN_F_BN_NEW,ERR_R_MALLOC_FAILURE);
		return(NULL);
		}
	ret->flags=BN_FLG_MALLOCED;
	ret->top=0;
	ret->neg=0;
	ret->dmax=0;
	ret->d=NULL;
d258 2
a259 2
	return(ret);
	}
d263 4
a266 3
static BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)
	{
	BN_ULONG *A,*a = NULL;
d272 2
a273 3
	if (words > (INT_MAX/(4*BN_BITS2)))
		{
		BNerr(BN_F_BN_EXPAND_INTERNAL,BN_R_BIGNUM_TOO_LONG);
d275 11
a285 12
		}
	if (BN_get_flags(b,BN_FLG_STATIC_DATA))
		{
		BNerr(BN_F_BN_EXPAND_INTERNAL,BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
		return(NULL);
		}
	a=A=(BN_ULONG *)malloc(sizeof(BN_ULONG)*words);
	if (A == NULL)
		{
		BNerr(BN_F_BN_EXPAND_INTERNAL,ERR_R_MALLOC_FAILURE);
		return(NULL);
		}
d287 1
a287 1
	B=b->d;
d289 2
a290 4
	if (B != NULL)
		{
		for (i=b->top>>2; i>0; i--,A+=4,B+=4)
			{
d300 17
a316 10
			BN_ULONG a0,a1,a2,a3;
			a0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];
			A[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;
			}
		switch (b->top&3)
			{
		case 3:	A[2]=B[2];
		case 2:	A[1]=B[1];
		case 1:	A[0]=B[0];
			}
d318 1
d321 2
a322 2
	memset(A,0,sizeof(BN_ULONG)*words);
	memcpy(A,b->d,sizeof(b->d[0])*b->top);
d324 3
a326 3
		
	return(a);
	}
d340 3
a342 2
BIGNUM *bn_dup_expand(const BIGNUM *b, int words)
	{
d353 1
a353 2
	if (words > b->dmax)
		{
d356 1
a356 2
		if (a)
			{
d358 1
a358 2
			if (r)
				{
d363 1
a363 3
				}
			else
				{
a365 1
				}
d367 1
d370 1
a370 3
		}
	else
		{
d372 1
a372 1
		}
d376 1
a376 1
	}
d385 3
a387 2
BIGNUM *bn_expand2(BIGNUM *b, int words)
	{
d390 1
a390 2
	if (words > b->dmax)
		{
d392 3
a394 2
		if(!a) return NULL;
		if(b->d) {
d398 3
a400 3
		b->d=a;
		b->dmax=words;
		}
d405 1
a405 2
	if (b->top < b->dmax)
		{
d408 12
a419 7
		for (i=(b->dmax - b->top)>>3; i>0; i--,A+=8)
			{
			A[0]=0; A[1]=0; A[2]=0; A[3]=0;
			A[4]=0; A[5]=0; A[6]=0; A[7]=0;
			}
		for (i=(b->dmax - b->top)&7; i>0; i--,A++)
			A[0]=0;
d421 1
a421 1
		}
d425 1
a425 1
	}
d427 3
a429 2
BIGNUM *BN_dup(const BIGNUM *a)
	{
d432 2
a433 1
	if (a == NULL) return NULL;
d437 3
a439 3
	if (t == NULL) return NULL;
	if(!BN_copy(t, a))
		{
d442 1
a442 1
		}
d445 1
a445 1
	}
d447 3
a449 2
BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)
	{
d456 4
a459 2
	if (a == b) return(a);
	if (bn_wexpand(a,b->top) == NULL) return(NULL);
d462 21
a482 14
	A=a->d;
	B=b->d;
	for (i=b->top>>2; i>0; i--,A+=4,B+=4)
		{
		BN_ULONG a0,a1,a2,a3;
		a0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];
		A[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;
		}
	switch (b->top&3)
		{
		case 3: A[2]=B[2];
		case 2: A[1]=B[1];
		case 1: A[0]=B[0];
		}
d484 1
a484 1
	memcpy(a->d,b->d,sizeof(b->d[0])*b->top);
d487 2
a488 2
	a->top=b->top;
	a->neg=b->neg;
d490 2
a491 2
	return(a);
	}
d493 3
a495 2
void BN_swap(BIGNUM *a, BIGNUM *b)
	{
d499 1
a499 1
	
d510 1
a510 1
	
d515 1
a515 1
	
d520 5
a524 3
	
	a->flags = (flags_old_a & BN_FLG_MALLOCED) | (flags_old_b & BN_FLG_STATIC_DATA);
	b->flags = (flags_old_b & BN_FLG_MALLOCED) | (flags_old_a & BN_FLG_STATIC_DATA);
d527 1
a527 1
	}
d529 3
a531 2
void BN_clear(BIGNUM *a)
	{
d534 4
a537 4
		memset(a->d,0,a->dmax*sizeof(a->d[0]));
	a->top=0;
	a->neg=0;
	}
d539 3
a541 2
BN_ULONG BN_get_word(const BIGNUM *a)
	{
d548 1
a548 1
	}
d550 3
a552 2
int BN_set_word(BIGNUM *a, BN_ULONG w)
	{
d554 2
a555 1
	if (bn_expand(a,(int)sizeof(BN_ULONG)*8) == NULL) return(0);
d560 2
a561 2
	return(1);
	}
d563 4
a566 3
BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)
	{
	unsigned int i,m;
d569 1
a569 1
	BIGNUM  *bn = NULL;
d573 2
a574 1
	if (ret == NULL) return(NULL);
d576 11
a586 12
	l=0;
	n=len;
	if (n == 0)
		{
		ret->top=0;
		return(ret);
		}
	i=((n-1)/BN_BYTES)+1;
	m=((n-1)%(BN_BYTES));
	if (bn_wexpand(ret, (int)i) == NULL)
		{
		if (bn) BN_free(bn);
d588 9
d598 1
a598 12
	ret->top=i;
	ret->neg=0;
	while (n--)
		{
		l=(l<<8L)| *(s++);
		if (m-- == 0)
			{
			ret->d[--i]=l;
			l=0;
			m=BN_BYTES-1;
			}
		}
d602 2
a603 2
	return(ret);
	}
d606 4
a609 3
int BN_bn2bin(const BIGNUM *a, unsigned char *to)
	{
	int n,i;
d613 4
a616 7
	n=i=BN_num_bytes(a);
	while (i--)
		{
		l=a->d[i/BN_BYTES];
		*(to++)=(unsigned char)(l>>(8*(i%BN_BYTES)))&0xff;
		}
	return(n);
d618 2
d621 3
a623 2
int BN_ucmp(const BIGNUM *a, const BIGNUM *b)
	{
d625 1
a625 1
	BN_ULONG t1,t2,*ap,*bp;
d630 8
a637 8
	i=a->top-b->top;
	if (i != 0) return(i);
	ap=a->d;
	bp=b->d;
	for (i=a->top-1; i>=0; i--)
		{
		t1= ap[i];
		t2= bp[i];
d639 1
a639 3
			return((t1 > t2) ? 1 : -1);
		}
	return(0);
d641 2
d644 3
a646 2
int BN_cmp(const BIGNUM *a, const BIGNUM *b)
	{
d648 2
a649 2
	int gt,lt;
	BN_ULONG t1,t2;
d651 1
a651 2
	if ((a == NULL) || (b == NULL))
		{
d653 1
a653 1
			return(-1);
d655 1
a655 1
			return(1);
d657 2
a658 2
			return(0);
		}
d663 1
a663 2
	if (a->neg != b->neg)
		{
d665 23
a687 17
			return(-1);
		else	return(1);
		}
	if (a->neg == 0)
		{ gt=1; lt= -1; }
	else	{ gt= -1; lt=1; }

	if (a->top > b->top) return(gt);
	if (a->top < b->top) return(lt);
	for (i=a->top-1; i>=0; i--)
		{
		t1=a->d[i];
		t2=b->d[i];
		if (t1 > t2) return(gt);
		if (t1 < t2) return(lt);
		}
	return(0);
d689 2
d692 4
a695 3
int BN_set_bit(BIGNUM *a, int n)
	{
	int i,j,k;
d700 9
a708 9
	i=n/BN_BITS2;
	j=n%BN_BITS2;
	if (a->top <= i)
		{
		if (bn_wexpand(a,i+1) == NULL) return(0);
		for(k=a->top; k<i+1; k++)
			a->d[k]=0;
		a->top=i+1;
		}
d710 1
a710 1
	a->d[i]|=(((BN_ULONG)1)<<j);
d712 2
a713 2
	return(1);
	}
d715 4
a718 3
int BN_clear_bit(BIGNUM *a, int n)
	{
	int i,j;
d721 2
a722 1
	if (n < 0) return 0;
d724 4
a727 3
	i=n/BN_BITS2;
	j=n%BN_BITS2;
	if (a->top <= i) return(0);
d729 1
a729 1
	a->d[i]&=(~(((BN_ULONG)1)<<j));
d731 2
a732 2
	return(1);
	}
d734 4
a737 3
int BN_is_bit_set(const BIGNUM *a, int n)
	{
	int i,j;
d740 8
a747 6
	if (n < 0) return 0;
	i=n/BN_BITS2;
	j=n%BN_BITS2;
	if (a->top <= i) return 0;
	return (int)(((a->d[i])>>j)&((BN_ULONG)1));
	}
d749 4
a752 3
int BN_mask_bits(BIGNUM *a, int n)
	{
	int b,w;
d755 2
a756 1
	if (n < 0) return 0;
d758 4
a761 3
	w=n/BN_BITS2;
	b=n%BN_BITS2;
	if (w >= a->top) return 0;
d763 5
a767 6
		a->top=w;
	else
		{
		a->top=w+1;
		a->d[w]&= ~(BN_MASK2<<b);
		}
d769 2
a770 2
	return(1);
	}
d772 3
a774 2
void BN_set_negative(BIGNUM *a, int b)
	{
d779 1
a779 1
	}
d781 3
a783 2
int bn_cmp_words(const BN_ULONG *a, const BN_ULONG *b, int n)
	{
d785 1
a785 1
	BN_ULONG aa,bb;
d787 9
a795 10
	aa=a[n-1];
	bb=b[n-1];
	if (aa != bb) return((aa > bb)?1:-1);
	for (i=n-2; i>=0; i--)
		{
		aa=a[i];
		bb=b[i];
		if (aa != bb) return((aa > bb)?1:-1);
		}
	return(0);
d797 2
d807 6
a812 5
int bn_cmp_part_words(const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
	{
	int n,i;
	n = cl-1;
d814 3
a816 5
	if (dl < 0)
		{
		for (i=dl; i<0; i++)
			{
			if (b[n-i] != 0)
a817 1
			}
d819 4
a822 5
	if (dl > 0)
		{
		for (i=dl; i>0; i--)
			{
			if (a[n+i] != 0)
a823 1
			}
a824 1
	return bn_cmp_words(a,b,cl);
d826 2
d829 2
a830 2
/* 
 * Constant-time conditional swap of a and b.  
d836 3
a838 2
void BN_consttime_swap(BN_ULONG condition, BIGNUM *a, BIGNUM *b, int nwords)
	{
d865 1
a865 1
		for (i = 10; i < nwords; i++) 
d877 2
a878 1
	case 1: BN_CONSTTIME_SWAP(0);
@


1.23
log
@in BN_clear_free, don't cleanse the data if the static data flag is set.
much debugging work done by otto. ok miod otto.

side note: BN_FLG_STATIC_DATA doesn't actually mean the data is static.
it's also used to indicate the data may be secretly shared behind your back
as a sort of poor man's refcounting, but without the refcounting.
@
text
@d228 5
a232 16
void BN_free(BIGNUM *a)
	{
	if (a == NULL) return;
	bn_check_top(a);
	if ((a->d != NULL) && !(BN_get_flags(a,BN_FLG_STATIC_DATA)))
		free(a->d);
	if (a->flags & BN_FLG_MALLOCED)
		free(a);
	else
		{
#ifndef OPENSSL_NO_DEPRECATED
		a->flags|=BN_FLG_FREE;
#endif
		a->d = NULL;
		}
	}
d391 4
a394 1
		if(b->d) free(b->d);
@


1.22
log
@revert, thanks sthen
@
text
@d217 1
a217 1
	if (a->d != NULL)
d220 1
a220 2
		if (!(BN_get_flags(a,BN_FLG_STATIC_DATA)))
			free(a->d);
@


1.21
log
@inspired by a cloudflare diff, cleanse old memory when expanding a bignum.
however, instead of trying to audit all the places where a secret bignum
is used, apply the big hammer and clear all bignums when freed.
ok deraadt miod
@
text
@d229 16
a244 5
void
BN_free(BIGNUM *a)
{
	BN_clear_free(a);
}
d403 1
a403 4
		if(b->d) {
			OPENSSL_cleanse(b->d, b->dmax * sizeof(b->d[0]));
			free(b->d);
		}
@


1.20
log
@Try to clean the maze of <openssl/bn.h> defines regarding the BN internals.

The intent of this change is to only keep support for two kind of architectures:
- those with 32-bit int and long, and 64-bit long long, where
  ``long * long -> long long'' multiplication routines are available.
- those with 64-bit int and long, and no 128-bit long long type.

This gets rid of the SIXTY_FOUR_BIT_LONG, SIXTY_FOUR_BIT (not the same!),
THIRTY_TWO_BIT, SIXTEEN_BIT and EIGHT_BIT defines.

After this change, the types and defines are as follows:

arch:           64bit           32bit           rationale
BN_LLONG        undefined       defined         defined if l * l -> ll
BN_ULLONG       undefined       u long long     result of BN_LONG * BN_LONG
BN_ULONG        u long          u int           native register size
BN_LONG         long            int             the same, signed
BN_BITS         128             64              size of 2*BN_ULONG in bits
BN_BYTES        8               4               size of 2*BN_ULONG in bytes
BN_BITS2        64              32              BN_BITS / 2

Tested on various 32-bit and 64-bit OpenBSD systems of various endianness.
@
text
@d229 5
a233 16
void BN_free(BIGNUM *a)
	{
	if (a == NULL) return;
	bn_check_top(a);
	if ((a->d != NULL) && !(BN_get_flags(a,BN_FLG_STATIC_DATA)))
		free(a->d);
	if (a->flags & BN_FLG_MALLOCED)
		free(a);
	else
		{
#ifndef OPENSSL_NO_DEPRECATED
		a->flags|=BN_FLG_FREE;
#endif
		a->d = NULL;
		}
	}
d392 4
a395 1
		if(b->d) free(b->d);
@


1.19
log
@I'm glad to know that Ultrix CC has a bug optimizing switch() statements
lacking an explicit `case 0:' construct. But Ultrix has been dead for more than
15 years, really. Don't give it any reason to move out of its coffin.
@
text
@d163 1
a163 1
#if defined(SIXTY_FOUR_BIT_LONG)
a183 23
#else
#ifdef SIXTY_FOUR_BIT
	if (l & 0xffffffff00000000LL)
		{
		if (l & 0xffff000000000000LL)
			{
			if (l & 0xff00000000000000LL)
				{
				return(bits[(int)(l>>56)]+56);
				}
			else	return(bits[(int)(l>>48)]+48);
			}
		else
			{
			if (l & 0x0000ff0000000000LL)
				{
				return(bits[(int)(l>>40)]+40);
				}
			else	return(bits[(int)(l>>32)]+32);
			}
		}
	else
#endif
a185 1
#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)
a192 1
#endif
a193 1
#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)
a196 1
#endif
@


1.18
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a347 4
		case 0: /* workaround for ultrix cc: without 'case 0', the optimizer does
		         * the switch table by doing a=top&3; a--; goto jump_table[a];
		         * which fails for top== 0 */
			;
a498 1
		case 0: ; /* ultrix cc workaround, see comments in bn_expand_internal */
@


1.17
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d248 1
a248 1
			OPENSSL_free(a->d);
d253 1
a253 1
		OPENSSL_free(a);
d261 1
a261 1
		OPENSSL_free(a->d);
d263 1
a263 1
		OPENSSL_free(a);
d283 1
a283 1
	if ((ret=(BIGNUM *)OPENSSL_malloc(sizeof(BIGNUM))) == NULL)
d317 1
a317 1
	a=A=(BN_ULONG *)OPENSSL_malloc(sizeof(BN_ULONG)*words);
d404 1
a404 1
				OPENSSL_free(a);
d434 1
a434 1
		if(b->d) OPENSSL_free(b->d);
@


1.16
log
@resolve conflicts
@
text
@d827 52
@


1.15
log
@resolve conflicts, fix local changes
@
text
@a141 19
char *BN_options(void)
	{
	static int init=0;
	static char data[16];

	if (!init)
		{
		init++;
#ifdef BN_LLONG
		BIO_snprintf(data,sizeof data,"bn(%d,%d)",
			     (int)sizeof(BN_ULLONG)*8,(int)sizeof(BN_ULONG)*8);
#else
		BIO_snprintf(data,sizeof data,"bn(%d,%d)",
			     (int)sizeof(BN_ULONG)*8,(int)sizeof(BN_ULONG)*8);
#endif
		}
	return(data);
	}

@


1.14
log
@resolve conflicts
@
text
@d136 2
a137 2
	static BN_ULONG data_one=1L;
	static BIGNUM const_one={&data_one,1,1,0,BN_FLG_STATIC_DATA};
d142 19
d163 1
a163 1
	static const char bits[256]={
d238 1
a238 1
#if defined(SIXTEEN_BIT) || defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)
d766 1
a766 1
	return(((a->d[i])>>j)&((BN_ULONG)1));
@


1.13
log
@resolve conflicts
@
text
@a141 19
char *BN_options(void)
	{
	static int init=0;
	static char data[16];

	if (!init)
		{
		init++;
#ifdef BN_LLONG
		BIO_snprintf(data,sizeof data,"bn(%d,%d)",
			     (int)sizeof(BN_ULLONG)*8,(int)sizeof(BN_ULONG)*8);
#else
		BIO_snprintf(data,sizeof data,"bn(%d,%d)",
			     (int)sizeof(BN_ULONG)*8,(int)sizeof(BN_ULONG)*8);
#endif
		}
	return(data);
	}

@


1.12
log
@merge 0.9.7d
@
text
@d70 1
a70 1
const char *BN_version="Big Number" OPENSSL_VERSION_PTEXT;
d72 2
d96 1
a96 1
		if (mult > (sizeof(int)*8)-1)
d103 1
a103 1
		if (high > (sizeof(int)*8)-1)
d110 1
a110 1
		if (low > (sizeof(int)*8)-1)
d117 1
a117 1
		if (mont > (sizeof(int)*8)-1)
d132 1
d137 1
a137 1
	static BIGNUM const_one={&data_one,1,1,0};
d250 1
a250 3
	BN_ULONG l;
	int i;

d253 2
a254 5
	if (a->top == 0) return(0);
	l=a->d[a->top-1];
	assert(l != 0);
	i=(a->top-1)*BN_BITS2;
	return(i+BN_num_bits_word(l));
d262 1
d278 1
a280 1
	a->flags|=BN_FLG_FREE; /* REMOVE? */
d283 7
d295 1
d312 1
d324 2
a330 2

	bn_check_top(b);	
d336 1
a336 1
	a=A=(BN_ULONG *)OPENSSL_malloc(sizeof(BN_ULONG)*(words+1));
a373 11
	/* Now need to zero any data between b->top and b->max */
	/* XXX Why? */

	A= &(a[b->top]);
	for (i=(words - b->top)>>3; i>0; i--,A+=8)
		{
		A[0]=0; A[1]=0; A[2]=0; A[3]=0;
		A[4]=0; A[5]=0; A[6]=0; A[7]=0;
		}
	for (i=(words - b->top)&7; i>0; i--,A++)
		A[0]=0;
d375 1
a375 1
	memset(A,0,sizeof(BN_ULONG)*(words+1));
d393 1
d398 2
d405 1
a405 1
	
d434 1
d437 1
d440 2
a441 1
 * It ensures that 'b' has enough room for a 'words' word number number.
d447 2
d452 21
a472 10

		if (a)
			{
			if (b->d)
				OPENSSL_free(b->d);
			b->d=a;
			b->dmax=words;
			}
		else
			b = NULL;
d474 2
d481 1
a481 1
	BIGNUM *r, *t;
a483 1

d487 3
a489 4
	if (t == NULL) return(NULL);
	r = BN_copy(t, a);
	/* now  r == t || r == NULL */
	if (r == NULL)
d491 4
a494 1
	return r;
a527 1
/*	memset(&(a->d[b->top]),0,sizeof(a->d[0])*(a->max-b->top));*/
a528 2
	if ((a->top == 0) && (a->d != NULL))
		a->d[0]=0;
d530 1
d540 3
d563 2
a566 1

d569 1
d578 6
a583 17
	int i,n;
	BN_ULONG ret=0;

	n=BN_num_bytes(a);
	if (n > sizeof(BN_ULONG))
		return(BN_MASK2);
	for (i=a->top-1; i>=0; i--)
		{
#ifndef SIXTY_FOUR_BIT /* the data item > unsigned long */
		ret<<=BN_BITS4; /* stops the compiler complaining */
		ret<<=BN_BITS4;
#else
		ret=0;
#endif
		ret|=a->d[i];
		}
	return(ret);
d588 6
a593 22
	int i,n;
	if (bn_expand(a,sizeof(BN_ULONG)*8) == NULL) return(0);

	n=sizeof(BN_ULONG)/BN_BYTES;
	a->neg=0;
	a->top=0;
	a->d[0]=(BN_ULONG)w&BN_MASK2;
	if (a->d[0] != 0) a->top=1;
	for (i=1; i<n; i++)
		{
		/* the following is done instead of
		 * w>>=BN_BITS2 so compilers don't complain
		 * on builds where sizeof(long) == BN_TYPES */
#ifndef SIXTY_FOUR_BIT /* the data item > unsigned long */
		w>>=BN_BITS4;
		w>>=BN_BITS4;
#else
		w=0;
#endif
		a->d[i]=(BN_ULONG)w&BN_MASK2;
		if (a->d[i] != 0) a->top=i+1;
		}
d602 1
d604 2
a605 1
	if (ret == NULL) ret=BN_new();
d607 1
a614 2
	if (bn_expand(ret,(int)(n+2)*8) == NULL)
		return(NULL);
d617 5
d624 1
a624 1
	while (n-- > 0)
d636 1
a636 1
	bn_fix_top(ret);
d646 1
d648 1
a648 1
	while (i-- > 0)
d673 1
a673 1
			return(t1 > t2?1:-1);
d723 3
d737 1
d745 3
d753 1
a753 1
	bn_fix_top(a);
d761 2
a762 1
	if (n < 0) return(0);
d765 2
a766 2
	if (a->top <= i) return(0);
	return((a->d[i]&(((BN_ULONG)1)<<j))?1:0);
d773 3
d778 1
a778 1
	if (w >= a->top) return(0);
d786 1
a786 1
	bn_fix_top(a);
d788 8
@


1.11
log
@Revert BN_cmp() change. Its arguments are const. Spotted by miod@@.

ok deraadt@@
@
text
@d148 2
a149 2
		snprintf(data,sizeof data,"bn(%d,%d)",(int)sizeof(BN_ULLONG)*8,
			(int)sizeof(BN_ULONG)*8);
d151 2
a152 2
		snprintf(data,sizeof data,"bn(%d,%d)",(int)sizeof(BN_ULONG)*8,
			(int)sizeof(BN_ULONG)*8);
@


1.10
log
@Add extra calls to bn_fix_top() in BN_cmp(), since some functions may
leave an invalid BN.

ok markus@@ deraadt@@
@
text
@a704 3
	bn_fix_top(a);
	bn_fix_top(b);

@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d705 3
@


1.8
log
@Trivial sprintf() -> snprintf() changes. ok deraadt@@
@
text
@d266 1
a266 1
		memset(a->d,0,a->dmax*sizeof(a->d[0]));
d271 1
a271 1
	memset(a,0,sizeof(BIGNUM));
@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d148 1
a148 1
		sprintf(data,"bn(%d,%d)",(int)sizeof(BN_ULLONG)*8,
d151 1
a151 1
		sprintf(data,"bn(%d,%d)",(int)sizeof(BN_ULONG)*8,
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d400 6
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d131 1
a131 1
BIGNUM *BN_value_one(void)
d308 3
a310 6
/* This is an internal function that should not be used in applications.
 * It ensures that 'b' has enough room for a 'words' word number number.
 * It is mostly used by the various BIGNUM routines. If there is an error,
 * NULL is returned. If not, 'b' is returned. */

BIGNUM *bn_expand2(BIGNUM *b, int words)
d312 1
a312 1
	BN_ULONG *A,*a;
d316 5
a320 1
	bn_check_top(b);
d322 16
a337 1
	if (words > b->dmax)
d339 1
a339 1
		if (words > (INT_MAX/(4*BN_BITS2)))
d341 12
a352 2
			BNerr(BN_F_BN_EXPAND2,BN_R_BIGNUM_TOO_LONG);
			return NULL;
d354 1
a354 3
			
		bn_check_top(b);	
		if (BN_get_flags(b,BN_FLG_STATIC_DATA))
d356 7
a362 2
			BNerr(BN_F_BN_EXPAND2,BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
			return(NULL);
d364 41
a404 2
		a=A=(BN_ULONG *)OPENSSL_malloc(sizeof(BN_ULONG)*(words+1));
		if (A == NULL)
d406 2
a407 36
			BNerr(BN_F_BN_EXPAND2,ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
#if 1
		B=b->d;
		/* Check if the previous number needs to be copied */
		if (B != NULL)
			{
#if 0
			/* This lot is an unrolled loop to copy b->top 
			 * BN_ULONGs from B to A
			 */
/*
 * I have nothing against unrolling but it's usually done for
 * several reasons, namely:
 * - minimize percentage of decision making code, i.e. branches;
 * - avoid cache trashing;
 * - make it possible to schedule loads earlier;
 * Now let's examine the code below. The cornerstone of C is
 * "programmer is always right" and that's what we love it for:-)
 * For this very reason C compilers have to be paranoid when it
 * comes to data aliasing and assume the worst. Yeah, but what
 * does it mean in real life? This means that loop body below will
 * be compiled to sequence of loads immediately followed by stores
 * as compiler assumes the worst, something in A==B+1 style. As a
 * result CPU pipeline is going to starve for incoming data. Secondly
 * if A and B happen to share same cache line such code is going to
 * cause severe cache trashing. Both factors have severe impact on
 * performance of modern CPUs and this is the reason why this
 * particular piece of code is #ifdefed away and replaced by more
 * "friendly" version found in #else section below. This comment
 * also applies to BN_copy function.
 *
 *					<appro@@fy.chalmers.se>
 */
			for (i=b->top&(~7); i>0; i-=8)
d409 4
a412 4
				A[0]=B[0]; A[1]=B[1]; A[2]=B[2]; A[3]=B[3];
				A[4]=B[4]; A[5]=B[5]; A[6]=B[6]; A[7]=B[7];
				A+=8;
				B+=8;
d414 1
a414 31
			switch (b->top&7)
				{
			case 7:
				A[6]=B[6];
			case 6:
				A[5]=B[5];
			case 5:
				A[4]=B[4];
			case 4:
				A[3]=B[3];
			case 3:
				A[2]=B[2];
			case 2:
				A[1]=B[1];
			case 1:
				A[0]=B[0];
			case 0:
				/* I need the 'case 0' entry for utrix cc.
				 * If the optimizer is turned on, it does the
				 * switch table by doing
				 * a=top&7
				 * a--;
				 * goto jump_table[a];
				 * If top is 0, this makes us jump to 0xffffffc 
				 * which is rather bad :-(.
				 * eric 23-Apr-1998
				 */
				;
				}
#else
			for (i=b->top>>2; i>0; i--,A+=4,B+=4)
d416 2
a417 12
				/*
				 * The fact that the loop is unrolled
				 * 4-wise is a tribute to Intel. It's
				 * the one that doesn't have enough
				 * registers to accomodate more data.
				 * I'd unroll it 8-wise otherwise:-)
				 *
				 *		<appro@@fy.chalmers.se>
				 */
				BN_ULONG a0,a1,a2,a3;
				a0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];
				A[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;
a418 9
			switch (b->top&3)
				{
				case 3:	A[2]=B[2];
				case 2:	A[1]=B[1];
				case 1:	A[0]=B[0];
				case 0:	; /* ultrix cc workaround, see above */
				}
#endif
			OPENSSL_free(b->d);
d420 10
d431 4
a434 2
		b->d=a;
		b->dmax=words;
d436 5
a440 1
		/* Now need to zero any data between b->top and b->max */
d442 1
a442 2
		A= &(b->d[b->top]);
		for (i=(b->dmax - b->top)>>3; i>0; i--,A+=8)
d444 4
a447 2
			A[0]=0; A[1]=0; A[2]=0; A[3]=0;
			A[4]=0; A[5]=0; A[6]=0; A[7]=0;
d449 2
a450 12
		for (i=(b->dmax - b->top)&7; i>0; i--,A++)
			A[0]=0;
#else
			memset(A,0,sizeof(BN_ULONG)*(words+1));
			memcpy(A,b->d,sizeof(b->d[0])*b->top);
			b->d=a;
			b->max=words;
#endif
		
/*		memset(&(p[b->max]),0,((words+1)-b->max)*sizeof(BN_ULONG)); */
/*	{ int i; for (i=b->max; i<words+1; i++) p[i]=i;} */

d452 1
a452 1
	return(b);
d457 1
a457 1
	BIGNUM *r;
d463 7
a469 3
	r=BN_new();
	if (r == NULL) return(NULL);
	return((BIGNUM *)BN_copy(r,a));
d497 1
a497 1
		case 0: ; /* ultrix cc workaround, see comments in bn_expand2 */
d511 29
d548 1
a548 1
BN_ULONG BN_get_word(BIGNUM *a)
a595 1
/* ignore negative */
d616 1
d771 1
a771 1
int bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n)
d788 31
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d65 1
d323 6
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d59 6
d253 1
a254 7
	if (l == 0)
		{
#if !defined(NO_STDIO) && !defined(WIN16)
		fprintf(stderr,"BAD TOP VALUE\n");
#endif
		abort();
		}
d265 1
a265 1
		memset(a->d,0,a->max*sizeof(a->d[0]));
d267 1
a267 1
			Free(a->d);
d272 1
a272 1
		Free(a);
d279 1
a279 1
		Free(a->d);
d282 1
a282 1
		Free(a);
d294 1
a294 1
	if ((ret=(BIGNUM *)Malloc(sizeof(BIGNUM))) == NULL)
d302 1
a302 1
	ret->max=0;
d320 1
a320 1
	if (words > b->max)
d328 1
a328 1
		a=A=(BN_ULONG *)Malloc(sizeof(BN_ULONG)*(words+1));
d426 1
a426 1
			Free(b->d);
d430 1
a430 1
		b->max=words;
d435 1
a435 1
		for (i=(b->max - b->top)>>3; i>0; i--,A+=8)
d440 1
a440 1
		for (i=(b->max - b->top)&7; i>0; i--,A++)
d511 1
a511 1
		memset(a->d,0,a->max*sizeof(a->d[0]));
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d74 8
a81 8
OPENSSL_GLOBAL int bn_limit_bits=0;
OPENSSL_GLOBAL int bn_limit_num=8;        /* (1<<bn_limit_bits) */
OPENSSL_GLOBAL int bn_limit_bits_low=0;
OPENSSL_GLOBAL int bn_limit_num_low=8;    /* (1<<bn_limit_bits_low) */
OPENSSL_GLOBAL int bn_limit_bits_high=0;
OPENSSL_GLOBAL int bn_limit_num_high=8;   /* (1<<bn_limit_bits_high) */
OPENSSL_GLOBAL int bn_limit_bits_mont=0;
OPENSSL_GLOBAL int bn_limit_num_mont=8;   /* (1<<bn_limit_bits_mont) */
d307 4
a310 36

BN_CTX *BN_CTX_new(void)
	{
	BN_CTX *ret;

	ret=(BN_CTX *)Malloc(sizeof(BN_CTX));
	if (ret == NULL)
		{
		BNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);
		return(NULL);
		}

	BN_CTX_init(ret);
	ret->flags=BN_FLG_MALLOCED;
	return(ret);
	}

void BN_CTX_init(BN_CTX *ctx)
	{
	memset(ctx,0,sizeof(BN_CTX));
	ctx->tos=0;
	ctx->flags=0;
	}

void BN_CTX_free(BN_CTX *c)
	{
	int i;

	if(c == NULL)
	    return;

	for (i=0; i<BN_CTX_NUM; i++)
		BN_clear_free(&(c->bn[i]));
	if (c->flags & BN_FLG_MALLOCED)
		Free(c);
	}
d360 1
a360 1
 * particulare piece of code is #ifdefed away and replaced by more
d391 1
a391 1
				 * If the optimiser is turned on, it does the
@


1.1
log
@Initial revision
@
text
@d63 1
a63 1
char *BN_version="Big Number part of SSLeay 0.9.0b 29-Jun-1998";
d65 60
a124 1
BIGNUM *BN_value_one()
d132 1
a132 1
char *BN_options()
d151 1
a151 2
int BN_num_bits_word(l)
BN_ULONG l;
d153 1
a153 1
	static char bits[256]={
d172 1
a172 1
#ifdef SIXTY_FOUR_BIT_LONG
d179 1
a179 1
				return(bits[l>>56]+56);
d181 1
a181 1
			else	return(bits[l>>48]+48);
d187 1
a187 1
				return(bits[l>>40]+40);
d189 1
a189 1
			else	return(bits[l>>32]+32);
d201 1
a201 1
				return(bits[l>>56]+56);
d203 1
a203 1
			else	return(bits[l>>48]+48);
d209 1
a209 1
				return(bits[l>>40]+40);
d211 1
a211 1
			else	return(bits[l>>32]+32);
d222 2
a223 2
				return(bits[l>>24L]+24);
			else	return(bits[l>>16L]+16);
d230 1
a230 1
				return(bits[l>>8]+8);
d233 1
a233 1
				return(bits[l   ]  );
d238 1
a238 2
int BN_num_bits(a)
BIGNUM *a;
d243 2
d258 1
a258 2
void BN_clear_free(a)
BIGNUM *a;
d260 2
d266 2
a267 1
		Free(a->d);
d269 1
d271 2
a272 1
	Free(a);
d275 1
a275 2
void BN_free(a)
BIGNUM *a;
d278 10
a287 2
	if (a->d != NULL) Free(a->d);
	Free(a);
d290 1
a290 1
BIGNUM *BN_new()
a292 1
	BN_ULONG *p;
d294 6
a299 2
	ret=(BIGNUM *)Malloc(sizeof(BIGNUM));
	if (ret == NULL) goto err;
d302 2
a303 6
	ret->max=(BN_DEFAULT_BITS/BN_BITS2);
	p=(BN_ULONG *)Malloc(sizeof(BN_ULONG)*(ret->max+1));
	if (p == NULL) goto err;
	ret->d=p;

	memset(p,0,(ret->max+1)*sizeof(p[0]));
a304 3
err:
	BNerr(BN_F_BN_NEW,ERR_R_MALLOC_FAILURE);
	return(NULL);
d307 2
a308 1
BN_CTX *BN_CTX_new()
a310 2
	BIGNUM *n;
	int i,j;
d313 1
a313 3
	if (ret == NULL) goto err2;

	for (i=0; i<BN_CTX_NUM; i++)
d315 2
a316 3
		n=BN_new();
		if (n == NULL) goto err;
		ret->bn[i]=n;
d319 4
a322 3
	/* There is actually an extra one, this is for debugging my
	 * stuff */
	ret->bn[BN_CTX_NUM]=NULL;
d324 5
a328 9
	ret->tos=0;
	return(ret);
err:
	for (j=0; j<i; j++)
		BN_free(ret->bn[j]);
	Free(ret);
err2:
	BNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);
	return(NULL);
d331 1
a331 2
void BN_CTX_free(c)
BN_CTX *c;
d335 3
d339 3
a341 2
		BN_clear_free(c->bn[i]);
	Free(c);
d344 1
a344 3
BIGNUM *bn_expand2(b, words)
BIGNUM *b;
int words;
d346 5
a350 1
	BN_ULONG *p;
d354 8
a361 2
		p=(BN_ULONG *)Realloc(b->d,sizeof(BN_ULONG)*(words+1));
		if (p == NULL)
d366 96
a461 2
		b->d=p;
		memset(&(p[b->max]),0,((words+1)-b->max)*sizeof(BN_ULONG));
d463 21
d488 1
a488 2
BIGNUM *BN_dup(a)
BIGNUM *a;
d492 4
d501 1
a501 3
BIGNUM *BN_copy(a, b)
BIGNUM *a;
BIGNUM *b;
d504 4
a507 1
	BN_ULONG *A,*B;
d515 1
a515 1
	for (i=b->top&(~7); i>0; i-=8)
d517 10
a526 27
		A[0]=B[0];
		A[1]=B[1];
		A[2]=B[2];
		A[3]=B[3];
		A[4]=B[4];
		A[5]=B[5];
		A[6]=B[6];
		A[7]=B[7];
		A+=8;
		B+=8;
		}
	switch (b->top&7)
		{
	case 7:
		A[6]=B[6];
	case 6:
		A[5]=B[5];
	case 5:
		A[4]=B[4];
	case 4:
		A[3]=B[3];
	case 3:
		A[2]=B[2];
	case 2:
		A[1]=B[1];
	case 1:
		A[0]=B[0];
d534 1
a534 1
	if (a->top == 0)
d540 1
a540 2
void BN_clear(a)
BIGNUM *a;
d542 2
a543 1
	memset(a->d,0,a->max*sizeof(a->d[0]));
d548 1
a548 2
unsigned long BN_get_word(a)
BIGNUM *a;
d551 1
a551 1
	unsigned long ret=0;
d554 1
a554 2
	if (n > sizeof(unsigned long))
#ifdef SIXTY_FOUR_BIT_LONG
a555 3
#else
		return(0xFFFFFFFFL);
#endif
d561 2
d569 1
a569 3
int BN_set_word(a,w)
BIGNUM *a;
unsigned long w;
d572 1
a572 1
	if (bn_expand(a,sizeof(unsigned long)*8) == NULL) return(0);
d574 1
a574 1
	n=sizeof(unsigned long)/BN_BYTES;
d587 2
d597 1
a597 4
BIGNUM *BN_bin2bn(s, len, ret)
unsigned char *s;
int len;
BIGNUM *ret;
d634 1
a634 3
int BN_bn2bin(a, to)
BIGNUM *a;
unsigned char *to;
d648 1
a648 3
int BN_ucmp(a, b)
BIGNUM *a;
BIGNUM *b;
d653 3
d670 1
a670 3
int BN_cmp(a, b)
BIGNUM *a;
BIGNUM *b;
d685 4
d711 1
a711 3
int BN_set_bit(a, n)
BIGNUM *a;
int n;
d713 1
a713 1
	int i,j;
d719 3
a721 1
		if (bn_expand(a,n) == NULL) return(0);
d725 1
a725 1
	a->d[i]|=(1L<<j);
d729 1
a729 3
int BN_clear_bit(a, n)
BIGNUM *a;
int n;
d737 2
a738 1
	a->d[i]&=(~(1L<<j));
d742 1
a742 3
int BN_is_bit_set(a, n)
BIGNUM *a;
int n;
d753 1
a753 3
int BN_mask_bits(a,n)
BIGNUM *a;
int n;
a765 5
		while ((w >= 0) && (a->d[w] == 0))
			{
			a->top--;
			w--;
			}
d767 1
d770 18
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a58 7
#ifndef BN_DEBUG
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
#endif

#include <assert.h>
#include <limits.h>
d63 1
a63 60
const char *BN_version="Big Number" OPENSSL_VERSION_PTEXT;

/* For a 32 bit machine
 * 2 -   4 ==  128
 * 3 -   8 ==  256
 * 4 -  16 ==  512
 * 5 -  32 == 1024
 * 6 -  64 == 2048
 * 7 - 128 == 4096
 * 8 - 256 == 8192
 */
static int bn_limit_bits=0;
static int bn_limit_num=8;        /* (1<<bn_limit_bits) */
static int bn_limit_bits_low=0;
static int bn_limit_num_low=8;    /* (1<<bn_limit_bits_low) */
static int bn_limit_bits_high=0;
static int bn_limit_num_high=8;   /* (1<<bn_limit_bits_high) */
static int bn_limit_bits_mont=0;
static int bn_limit_num_mont=8;   /* (1<<bn_limit_bits_mont) */

void BN_set_params(int mult, int high, int low, int mont)
	{
	if (mult >= 0)
		{
		if (mult > (sizeof(int)*8)-1)
			mult=sizeof(int)*8-1;
		bn_limit_bits=mult;
		bn_limit_num=1<<mult;
		}
	if (high >= 0)
		{
		if (high > (sizeof(int)*8)-1)
			high=sizeof(int)*8-1;
		bn_limit_bits_high=high;
		bn_limit_num_high=1<<high;
		}
	if (low >= 0)
		{
		if (low > (sizeof(int)*8)-1)
			low=sizeof(int)*8-1;
		bn_limit_bits_low=low;
		bn_limit_num_low=1<<low;
		}
	if (mont >= 0)
		{
		if (mont > (sizeof(int)*8)-1)
			mont=sizeof(int)*8-1;
		bn_limit_bits_mont=mont;
		bn_limit_num_mont=1<<mont;
		}
	}

int BN_get_params(int which)
	{
	if      (which == 0) return(bn_limit_bits);
	else if (which == 1) return(bn_limit_bits_high);
	else if (which == 2) return(bn_limit_bits_low);
	else if (which == 3) return(bn_limit_bits_mont);
	else return(0);
	}
d65 1
a65 1
const BIGNUM *BN_value_one(void)
d73 1
a73 1
char *BN_options(void)
d92 2
a93 1
int BN_num_bits_word(BN_ULONG l)
d95 1
a95 1
	static const char bits[256]={
d114 1
a114 1
#if defined(SIXTY_FOUR_BIT_LONG)
d121 1
a121 1
				return(bits[(int)(l>>56)]+56);
d123 1
a123 1
			else	return(bits[(int)(l>>48)]+48);
d129 1
a129 1
				return(bits[(int)(l>>40)]+40);
d131 1
a131 1
			else	return(bits[(int)(l>>32)]+32);
d143 1
a143 1
				return(bits[(int)(l>>56)]+56);
d145 1
a145 1
			else	return(bits[(int)(l>>48)]+48);
d151 1
a151 1
				return(bits[(int)(l>>40)]+40);
d153 1
a153 1
			else	return(bits[(int)(l>>32)]+32);
d164 2
a165 2
				return(bits[(int)(l>>24L)]+24);
			else	return(bits[(int)(l>>16L)]+16);
d172 1
a172 1
				return(bits[(int)(l>>8)]+8);
d175 1
a175 1
				return(bits[(int)(l   )]  );
d180 2
a181 1
int BN_num_bits(const BIGNUM *a)
a185 2
	bn_check_top(a);

a187 1
	assert(l != 0);
d189 7
d199 2
a200 1
void BN_clear_free(BIGNUM *a)
a201 2
	int i;

d205 2
a206 3
		memset(a->d,0,a->dmax*sizeof(a->d[0]));
		if (!(BN_get_flags(a,BN_FLG_STATIC_DATA)))
			OPENSSL_free(a->d);
a207 1
	i=BN_get_flags(a,BN_FLG_MALLOCED);
d209 1
a209 2
	if (i)
		OPENSSL_free(a);
d212 2
a213 1
void BN_free(BIGNUM *a)
d216 2
a217 5
	if ((a->d != NULL) && !(BN_get_flags(a,BN_FLG_STATIC_DATA)))
		OPENSSL_free(a->d);
	a->flags|=BN_FLG_FREE; /* REMOVE? */
	if (a->flags & BN_FLG_MALLOCED)
		OPENSSL_free(a);
d220 1
a220 6
void BN_init(BIGNUM *a)
	{
	memset(a,0,sizeof(BIGNUM));
	}

BIGNUM *BN_new(void)
d223 1
d225 2
a226 6
	if ((ret=(BIGNUM *)OPENSSL_malloc(sizeof(BIGNUM))) == NULL)
		{
		BNerr(BN_F_BN_NEW,ERR_R_MALLOC_FAILURE);
		return(NULL);
		}
	ret->flags=BN_FLG_MALLOCED;
d229 6
a234 2
	ret->dmax=0;
	ret->d=NULL;
d236 3
d241 1
a241 3
/* This is used both by bn_expand2() and bn_dup_expand() */
/* The caller MUST check that words > b->dmax before calling this */
static BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)
d243 3
a245 3
	BN_ULONG *A,*a = NULL;
	const BN_ULONG *B;
	int i;
d247 2
a248 5
	if (words > (INT_MAX/(4*BN_BITS2)))
		{
		BNerr(BN_F_BN_EXPAND_INTERNAL,BN_R_BIGNUM_TOO_LONG);
		return NULL;
		}
d250 1
a250 2
	bn_check_top(b);	
	if (BN_get_flags(b,BN_FLG_STATIC_DATA))
d252 3
a254 39
		BNerr(BN_F_BN_EXPAND_INTERNAL,BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
		return(NULL);
		}
	a=A=(BN_ULONG *)OPENSSL_malloc(sizeof(BN_ULONG)*(words+1));
	if (A == NULL)
		{
		BNerr(BN_F_BN_EXPAND_INTERNAL,ERR_R_MALLOC_FAILURE);
		return(NULL);
		}
#if 1
	B=b->d;
	/* Check if the previous number needs to be copied */
	if (B != NULL)
		{
		for (i=b->top>>2; i>0; i--,A+=4,B+=4)
			{
			/*
			 * The fact that the loop is unrolled
			 * 4-wise is a tribute to Intel. It's
			 * the one that doesn't have enough
			 * registers to accomodate more data.
			 * I'd unroll it 8-wise otherwise:-)
			 *
			 *		<appro@@fy.chalmers.se>
			 */
			BN_ULONG a0,a1,a2,a3;
			a0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];
			A[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;
			}
		switch (b->top&3)
			{
		case 3:	A[2]=B[2];
		case 2:	A[1]=B[1];
		case 1:	A[0]=B[0];
		case 0: /* workaround for ultrix cc: without 'case 0', the optimizer does
		         * the switch table by doing a=top&3; a--; goto jump_table[a];
		         * which fails for top== 0 */
			;
			}
d257 3
a259 2
	/* Now need to zero any data between b->top and b->max */
	/* XXX Why? */
d261 9
a269 14
	A= &(a[b->top]);
	for (i=(words - b->top)>>3; i>0; i--,A+=8)
		{
		A[0]=0; A[1]=0; A[2]=0; A[3]=0;
		A[4]=0; A[5]=0; A[6]=0; A[7]=0;
		}
	for (i=(words - b->top)&7; i>0; i--,A++)
		A[0]=0;
#else
	memset(A,0,sizeof(BN_ULONG)*(words+1));
	memcpy(A,b->d,sizeof(b->d[0])*b->top);
#endif
		
	return(a);
d272 2
a273 12
/* This is an internal function that can be used instead of bn_expand2()
 * when there is a need to copy BIGNUMs instead of only expanding the
 * data part, while still expanding them.
 * Especially useful when needing to expand BIGNUMs that are declared
 * 'const' and should therefore not be changed.
 * The reason to use this instead of a BN_dup() followed by a bn_expand2()
 * is memory allocation overhead.  A BN_dup() followed by a bn_expand2()
 * will allocate new memory for the BIGNUM data twice, and free it once,
 * while bn_dup_expand() makes sure allocation is made only once.
 */

BIGNUM *bn_dup_expand(const BIGNUM *b, int words)
d275 1
a275 29
	BIGNUM *r = NULL;

	if (words > b->dmax)
		{
		BN_ULONG *a = bn_expand_internal(b, words);

		if (a)
			{
			r = BN_new();
			if (r)
				{
				r->top = b->top;
				r->dmax = words;
				r->neg = b->neg;
				r->d = a;
				}
			else
				{
				/* r == NULL, BN_new failure */
				OPENSSL_free(a);
				}
			}
		/* If a == NULL, there was an error in allocation in
		   bn_expand_internal(), and NULL should be returned */
		}
	else
		{
		r = BN_dup(b);
		}
d277 3
a279 1
	return r;
d282 5
a286 4
/* This is an internal function that should not be used in applications.
 * It ensures that 'b' has enough room for a 'words' word number number.
 * It is mostly used by the various BIGNUM routines. If there is an error,
 * NULL is returned. If not, 'b' is returned. */
d288 1
a288 3
BIGNUM *bn_expand2(BIGNUM *b, int words)
	{
	if (words > b->dmax)
d290 2
a291 3
		BN_ULONG *a = bn_expand_internal(b, words);

		if (a)
d293 2
a294 4
			if (b->d)
				OPENSSL_free(b->d);
			b->d=a;
			b->dmax=words;
d296 3
a298 2
		else
			b = NULL;
d300 1
a300 1
	return b;
d303 2
a304 1
BIGNUM *BN_dup(const BIGNUM *a)
d306 1
a306 5
	BIGNUM *r, *t;

	if (a == NULL) return NULL;

	bn_check_top(a);
d308 3
a310 7
	t = BN_new();
	if (t == NULL) return(NULL);
	r = BN_copy(t, a);
	/* now  r == t || r == NULL */
	if (r == NULL)
		BN_free(t);
	return r;
d313 3
a315 1
BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)
d318 1
a318 4
	BN_ULONG *A;
	const BN_ULONG *B;

	bn_check_top(b);
d326 1
a326 1
	for (i=b->top>>2; i>0; i--,A+=4,B+=4)
d328 27
a354 10
		BN_ULONG a0,a1,a2,a3;
		a0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];
		A[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;
		}
	switch (b->top&3)
		{
		case 3: A[2]=B[2];
		case 2: A[1]=B[1];
		case 1: A[0]=B[0];
		case 0: ; /* ultrix cc workaround, see comments in bn_expand_internal */
d362 1
a362 1
	if ((a->top == 0) && (a->d != NULL))
d368 2
a369 30
void BN_swap(BIGNUM *a, BIGNUM *b)
	{
	int flags_old_a, flags_old_b;
	BN_ULONG *tmp_d;
	int tmp_top, tmp_dmax, tmp_neg;
	
	flags_old_a = a->flags;
	flags_old_b = b->flags;

	tmp_d = a->d;
	tmp_top = a->top;
	tmp_dmax = a->dmax;
	tmp_neg = a->neg;
	
	a->d = b->d;
	a->top = b->top;
	a->dmax = b->dmax;
	a->neg = b->neg;
	
	b->d = tmp_d;
	b->top = tmp_top;
	b->dmax = tmp_dmax;
	b->neg = tmp_neg;
	
	a->flags = (flags_old_a & BN_FLG_MALLOCED) | (flags_old_b & BN_FLG_STATIC_DATA);
	b->flags = (flags_old_b & BN_FLG_MALLOCED) | (flags_old_a & BN_FLG_STATIC_DATA);
	}


void BN_clear(BIGNUM *a)
d371 1
a371 2
	if (a->d != NULL)
		memset(a->d,0,a->dmax*sizeof(a->d[0]));
d376 2
a377 1
BN_ULONG BN_get_word(const BIGNUM *a)
d380 1
a380 1
	BN_ULONG ret=0;
d383 2
a384 1
	if (n > sizeof(BN_ULONG))
d386 3
a393 2
#else
		ret=0;
d400 3
a402 1
int BN_set_word(BIGNUM *a, BN_ULONG w)
d405 1
a405 1
	if (bn_expand(a,sizeof(BN_ULONG)*8) == NULL) return(0);
d407 1
a407 1
	n=sizeof(BN_ULONG)/BN_BYTES;
a419 2
#else
		w=0;
d427 5
a431 1
BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)
a450 1
	ret->neg=0;
d468 3
a470 1
int BN_bn2bin(const BIGNUM *a, unsigned char *to)
d484 3
a486 1
int BN_ucmp(const BIGNUM *a, const BIGNUM *b)
a490 3
	bn_check_top(a);
	bn_check_top(b);

d505 3
a507 1
int BN_cmp(const BIGNUM *a, const BIGNUM *b)
a521 4

	bn_check_top(a);
	bn_check_top(b);

d544 3
a546 1
int BN_set_bit(BIGNUM *a, int n)
d548 1
a548 1
	int i,j,k;
d554 1
a554 3
		if (bn_wexpand(a,i+1) == NULL) return(0);
		for(k=a->top; k<i+1; k++)
			a->d[k]=0;
d558 1
a558 1
	a->d[i]|=(((BN_ULONG)1)<<j);
d562 3
a564 1
int BN_clear_bit(BIGNUM *a, int n)
d572 1
a572 2
	a->d[i]&=(~(((BN_ULONG)1)<<j));
	bn_fix_top(a);
d576 3
a578 1
int BN_is_bit_set(const BIGNUM *a, int n)
d589 3
a591 1
int BN_mask_bits(BIGNUM *a, int n)
d604 1
a604 38
		}
	bn_fix_top(a);
	return(1);
	}

int bn_cmp_words(const BN_ULONG *a, const BN_ULONG *b, int n)
	{
	int i;
	BN_ULONG aa,bb;

	aa=a[n-1];
	bb=b[n-1];
	if (aa != bb) return((aa > bb)?1:-1);
	for (i=n-2; i>=0; i--)
		{
		aa=a[i];
		bb=b[i];
		if (aa != bb) return((aa > bb)?1:-1);
		}
	return(0);
	}

/* Here follows a specialised variants of bn_cmp_words().  It has the
   property of performing the operation on arrays of different sizes.
   The sizes of those arrays is expressed through cl, which is the
   common length ( basicall, min(len(a),len(b)) ), and dl, which is the
   delta between the two lengths, calculated as len(a)-len(b).
   All lengths are the number of BN_ULONGs...  */

int bn_cmp_part_words(const BN_ULONG *a, const BN_ULONG *b,
	int cl, int dl)
	{
	int n,i;
	n = cl-1;

	if (dl < 0)
		{
		for (i=dl; i<0; i++)
d606 2
a607 2
			if (b[n-i] != 0)
				return -1; /* a < b */
d610 1
a610 9
	if (dl > 0)
		{
		for (i=dl; i>0; i--)
			{
			if (a[n+i] != 0)
				return 1; /* a > b */
			}
		}
	return bn_cmp_words(a,b,cl);
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a399 6
	/* This function does not work if
	 *      words <= b->dmax && top < words
	 * because BN_dup() does not preserve 'dmax'!
	 * (But bn_dup_expand() is not used anywhere yet.)
	 */
	
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d266 1
a266 1
		OPENSSL_cleanse(a->d,a->dmax*sizeof(a->d[0]));
d271 1
a271 1
	OPENSSL_cleanse(a,sizeof(BIGNUM));
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@d148 2
a149 2
		BIO_snprintf(data,sizeof data,"bn(%d,%d)",
			     (int)sizeof(BN_ULLONG)*8,(int)sizeof(BN_ULONG)*8);
d151 2
a152 2
		BIO_snprintf(data,sizeof data,"bn(%d,%d)",
			     (int)sizeof(BN_ULONG)*8,(int)sizeof(BN_ULONG)*8);
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d70 1
a70 1
const char BN_version[]="Big Number" OPENSSL_VERSION_PTEXT;
a71 2
/* This stuff appears to be completely unused, so is deprecated */
#ifndef OPENSSL_NO_DEPRECATED
d94 1
a94 1
		if (mult > (int)(sizeof(int)*8)-1)
d101 1
a101 1
		if (high > (int)(sizeof(int)*8)-1)
d108 1
a108 1
		if (low > (int)(sizeof(int)*8)-1)
d115 1
a115 1
		if (mont > (int)(sizeof(int)*8)-1)
a129 1
#endif
d134 1
a134 1
	static BIGNUM const_one={&data_one,1,1,0,BN_FLG_STATIC_DATA};
d247 3
a249 1
	int i = a->top - 1;
d252 5
a256 2
	if (BN_is_zero(a)) return 0;
	return ((i*BN_BITS2) + BN_num_bits_word(a->d[i]));
a263 1
	bn_check_top(a);
a278 1
	bn_check_top(a);
d281 1
a283 7
	else
		{
#ifndef OPENSSL_NO_DEPRECATED
		a->flags|=BN_FLG_FREE;
#endif
		a->d = NULL;
		}
a288 1
	bn_check_top(a);
a304 1
	bn_check_top(ret);
a315 2
	bn_check_top(b);

d321 2
d328 1
a328 1
	a=A=(BN_ULONG *)OPENSSL_malloc(sizeof(BN_ULONG)*words);
d366 11
d378 1
a378 1
	memset(A,0,sizeof(BN_ULONG)*words);
a395 1
#ifndef OPENSSL_NO_DEPRECATED
a399 2
	bn_check_top(b);

d405 1
a405 1

a433 1
	bn_check_top(r);
a435 1
#endif
d438 1
a438 2
 * It ensures that 'b' has enough room for a 'words' word number
 * and initialises any unused part of b->d with leading zeros.
a443 2
	bn_check_top(b);

d447 10
a456 21
		if(!a) return NULL;
		if(b->d) OPENSSL_free(b->d);
		b->d=a;
		b->dmax=words;
		}

/* None of this should be necessary because of what b->top means! */
#if 0
	/* NB: bn_wexpand() calls this only if the BIGNUM really has to grow */
	if (b->top < b->dmax)
		{
		int i;
		BN_ULONG *A = &(b->d[b->top]);
		for (i=(b->dmax - b->top)>>3; i>0; i--,A+=8)
			{
			A[0]=0; A[1]=0; A[2]=0; A[3]=0;
			A[4]=0; A[5]=0; A[6]=0; A[7]=0;
			}
		for (i=(b->dmax - b->top)&7; i>0; i--,A++)
			A[0]=0;
		assert(A == &(b->d[b->dmax]));
a457 2
#endif
	bn_check_top(b);
d463 1
a463 1
	BIGNUM *t;
d466 1
d470 4
a473 3
	if (t == NULL) return NULL;
	if(!BN_copy(t, a))
		{
d475 1
a475 4
		return NULL;
		}
	bn_check_top(t);
	return t;
d509 1
d511 2
a513 1
	bn_check_top(a);
a522 3
	bn_check_top(a);
	bn_check_top(b);

a542 2
	bn_check_top(a);
	bn_check_top(b);
d545 1
a547 1
	bn_check_top(a);
d556 17
a572 6
	if (a->top > 1)
		return BN_MASK2;
	else if (a->top == 1)
		return a->d[0];
	/* a->top == 0 */
	return 0;
d577 22
a598 6
	bn_check_top(a);
	if (bn_expand(a,(int)sizeof(BN_ULONG)*8) == NULL) return(0);
	a->neg = 0;
	a->d[0] = w;
	a->top = (w ? 1 : 0);
	bn_check_top(a);
a606 1
	BIGNUM  *bn = NULL;
d608 1
a608 2
	if (ret == NULL)
		ret = bn = BN_new();
a609 1
	bn_check_top(ret);
d617 2
a620 5
	if (bn_wexpand(ret, (int)i) == NULL)
		{
		if (bn) BN_free(bn);
		return NULL;
		}
d623 1
a623 1
	while (n--)
d635 1
a635 1
	bn_correct_top(ret);
a644 1
	bn_check_top(a);
d646 1
a646 1
	while (i--)
d671 1
a671 1
			return((t1 > t2) ? 1 : -1);
a720 3
	if (n < 0)
		return 0;

a731 1
	bn_check_top(a);
a738 3
	bn_check_top(a);
	if (n < 0) return 0;

d744 1
a744 1
	bn_correct_top(a);
d752 1
a752 2
	bn_check_top(a);
	if (n < 0) return 0;
d755 2
a756 2
	if (a->top <= i) return 0;
	return(((a->d[i])>>j)&((BN_ULONG)1));
a762 3
	bn_check_top(a);
	if (n < 0) return 0;

d765 1
a765 1
	if (w >= a->top) return 0;
d773 1
a773 1
	bn_correct_top(a);
a774 8
	}

void BN_set_negative(BIGNUM *a, int b)
	{
	if (b && !BN_is_zero(a))
		a->neg = 1;
	else
		a->neg = 0;
@


1.1.1.7
log
@import openssl-0.9.8j
@
text
@d142 19
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d136 2
a137 2
	static const BN_ULONG data_one=1L;
	static const BIGNUM const_one={(BN_ULONG *)&data_one,1,1,0,BN_FLG_STATIC_DATA};
a141 19
char *BN_options(void)
	{
	static int init=0;
	static char data[16];

	if (!init)
		{
		init++;
#ifdef BN_LLONG
		BIO_snprintf(data,sizeof data,"bn(%d,%d)",
			     (int)sizeof(BN_ULLONG)*8,(int)sizeof(BN_ULONG)*8);
#else
		BIO_snprintf(data,sizeof data,"bn(%d,%d)",
			     (int)sizeof(BN_ULONG)*8,(int)sizeof(BN_ULONG)*8);
#endif
		}
	return(data);
	}

d144 1
a144 1
	static const unsigned char bits[256]={
d219 1
a219 1
#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)
d747 1
a747 1
	return (int)(((a->d[i])>>j)&((BN_ULONG)1));
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@d142 19
@


1.1.1.10
log
@Import OpenSSL 1.0.1g
@
text
@a826 52

/* 
 * Constant-time conditional swap of a and b.  
 * a and b are swapped if condition is not 0.  The code assumes that at most one bit of condition is set.
 * nwords is the number of words to swap.  The code assumes that at least nwords are allocated in both a and b,
 * and that no more than nwords are used by either a or b.
 * a and b cannot be the same number
 */
void BN_consttime_swap(BN_ULONG condition, BIGNUM *a, BIGNUM *b, int nwords)
	{
	BN_ULONG t;
	int i;

	bn_wcheck_size(a, nwords);
	bn_wcheck_size(b, nwords);

	assert(a != b);
	assert((condition & (condition - 1)) == 0);
	assert(sizeof(BN_ULONG) >= sizeof(int));

	condition = ((condition - 1) >> (BN_BITS2 - 1)) - 1;

	t = (a->top^b->top) & condition;
	a->top ^= t;
	b->top ^= t;

#define BN_CONSTTIME_SWAP(ind) \
	do { \
		t = (a->d[ind] ^ b->d[ind]) & condition; \
		a->d[ind] ^= t; \
		b->d[ind] ^= t; \
	} while (0)


	switch (nwords) {
	default:
		for (i = 10; i < nwords; i++) 
			BN_CONSTTIME_SWAP(i);
		/* Fallthrough */
	case 10: BN_CONSTTIME_SWAP(9); /* Fallthrough */
	case 9: BN_CONSTTIME_SWAP(8); /* Fallthrough */
	case 8: BN_CONSTTIME_SWAP(7); /* Fallthrough */
	case 7: BN_CONSTTIME_SWAP(6); /* Fallthrough */
	case 6: BN_CONSTTIME_SWAP(5); /* Fallthrough */
	case 5: BN_CONSTTIME_SWAP(4); /* Fallthrough */
	case 4: BN_CONSTTIME_SWAP(3); /* Fallthrough */
	case 3: BN_CONSTTIME_SWAP(2); /* Fallthrough */
	case 2: BN_CONSTTIME_SWAP(1); /* Fallthrough */
	case 1: BN_CONSTTIME_SWAP(0);
	}
#undef BN_CONSTTIME_SWAP
}
@


