head	1.15;
access;
symbols
	butholakala:1.13
	openssl_1_0_1_g:1.1.1.7
	OPENBSD_5_5:1.13.0.16
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.12
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	openssl_1_0_1_c:1.1.1.7
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	openssl_1_0_0_f:1.1.1.7
	openssl_1_0_0_e:1.1.1.7
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	openssh_1_0_0_a:1.1.1.7
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	openssl_0_9_8_k:1.1.1.6
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	openssl_0_9_8_j:1.1.1.6
	openssl_0_9_8_h:1.1.1.6
	pre_openssl_0_9_8h:1.11
	OPENBSD_4_4:1.11.0.14
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.12
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.10
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	openssl_0_9_7j:1.1.1.5
	openssl:1.1.1
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENSSL_0_9_7C:1.1.1.3
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.15
date	2014.04.18.13.13.50;	author tedu;	state dead;
branches;
next	1.14;

1.14
date	2014.04.15.16.52.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.29.05.39.25;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.16.12.18.21;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.10.16.31.55;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.22.00.03.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.02;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.15.06.18.42;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.11.14;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.48;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.40.52;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.43;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.49;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.14;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@egd support is too dangerous to leave where somebody might find it.
ok deraadt.
@
text
@/* crypto/rand/rand_egd.c */
/* Written by Ulf Moeller and Lutz Jaenicke for the OpenSSL project. */
/* ====================================================================
 * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <openssl/e_os2.h>
#include <openssl/rand.h>
#include <openssl/buffer.h>

/*
 * Query the EGD <URL: http://www.lothar.com/tech/crypto/>.
 *
 * This module supplies three routines:
 *
 * RAND_query_egd_bytes(path, buf, bytes)
 *   will actually query "bytes" bytes of entropy form the egd-socket located
 *   at path and will write them to buf (if supplied) or will directly feed
 *   it to RAND_seed() if buf==NULL.
 *   The number of bytes is not limited by the maximum chunk size of EGD,
 *   which is 255 bytes. If more than 255 bytes are wanted, several chunks
 *   of entropy bytes are requested. The connection is left open until the
 *   query is competed.
 *   RAND_query_egd_bytes() returns with
 *     -1  if an error occured during connection or communication.
 *     num the number of bytes read from the EGD socket. This number is either
 *         the number of bytes requested or smaller, if the EGD pool is
 *         drained and the daemon signals that the pool is empty.
 *   This routine does not touch any RAND_status(). This is necessary, since
 *   PRNG functions may call it during initialization.
 *
 * RAND_egd_bytes(path, bytes) will query "bytes" bytes and have them
 *   used to seed the PRNG.
 *   RAND_egd_bytes() is a wrapper for RAND_query_egd_bytes() with buf=NULL.
 *   Unlike RAND_query_egd_bytes(), RAND_status() is used to test the
 *   seed status so that the return value can reflect the seed state:
 *     -1  if an error occured during connection or communication _or_
 *         if the PRNG has still not received the required seeding.
 *     num the number of bytes read from the EGD socket. This number is either
 *         the number of bytes requested or smaller, if the EGD pool is
 *         drained and the daemon signals that the pool is empty.
 *
 * RAND_egd(path) will query 255 bytes and use the bytes retreived to seed
 *   the PRNG.
 *   RAND_egd() is a wrapper for RAND_egd_bytes() with numbytes=255.
 */

int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)
	{
	return(-1);
	}
int RAND_egd(const char *path)
	{
	return(-1);
	}

int RAND_egd_bytes(const char *path,int bytes)
	{
	return(-1);
	}
@


1.14
log
@Replace the old OpenSSL PRNG by direct use of arc4random_buf(), keeping the
existing RAND interfaces unchanged.

All interfaces allowing external feed or seed of the RNG (either from a file
or a local entropy gathering daemon) are kept for ABI compatibility, but are
no longer do anything.

While the OpenSSL PRNG was required 15+ years ago when many systems lacked
proper entropy collection, things have evolved and one can reasonably assume
it is better to use the kernel (system global) entropy pool rather than trying
to build one's own and having to compensate for thread scheduling...

<RANT>
Whoever thought that RAND_screen(), feeding the PRNG with the contents of the
local workstation's display, under Win32, was a smart idea, ought to be banned
from security programming.
</RANT>

ok beck@@ deraadt@@ tedu@@
@
text
@@


1.13
log
@resolve conflicts, fix local changes
@
text
@a97 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_VOS) || defined(OPENSSL_SYS_BEOS)
a110 192
#else
#include <openssl/opensslconf.h>
#include OPENSSL_UNISTD
#include <sys/types.h>
#include <sys/socket.h>
#ifndef NO_SYS_UN_H
# ifdef OPENSSL_SYS_VXWORKS
#   include <streams/un.h>
# else
#   include <sys/un.h>
# endif
#else
struct	sockaddr_un {
	short	sun_family;		/* AF_UNIX */
	char	sun_path[108];		/* path name (gag) */
};
#endif /* NO_SYS_UN_H */
#include <string.h>
#include <errno.h>

#ifndef offsetof
#  define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
#endif

int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)
	{
	int ret = 0;
	struct sockaddr_un addr;
	int len, num, numbytes;
	int fd = -1;
	int success;
	unsigned char egdbuf[2], tempbuf[255], *retrievebuf;

	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	if (strlen(path) >= sizeof(addr.sun_path))
		return (-1);
	BUF_strlcpy(addr.sun_path,path,sizeof addr.sun_path);
	len = offsetof(struct sockaddr_un, sun_path) + strlen(path);
	fd = socket(AF_UNIX, SOCK_STREAM, 0);
	if (fd == -1) return (-1);
	success = 0;
	while (!success)
	    {
	    if (connect(fd, (struct sockaddr *)&addr, len) == 0)
	       success = 1;
	    else
		{
		switch (errno)
		    {
#ifdef EINTR
		    case EINTR:
#endif
#ifdef EAGAIN
		    case EAGAIN:
#endif
#ifdef EINPROGRESS
		    case EINPROGRESS:
#endif
#ifdef EALREADY
		    case EALREADY:
#endif
			/* No error, try again */
			break;
#ifdef EISCONN
		    case EISCONN:
			success = 1;
			break;
#endif
		    default:
			goto err;	/* failure */
		    }
		}
	    }

	while(bytes > 0)
	    {
	    egdbuf[0] = 1;
	    egdbuf[1] = bytes < 255 ? bytes : 255;
	    numbytes = 0;
	    while (numbytes != 2)
		{
	        num = write(fd, egdbuf + numbytes, 2 - numbytes);
	        if (num >= 0)
		    numbytes += num;
	    	else
		    {
		    switch (errno)
		    	{
#ifdef EINTR
		    	case EINTR:
#endif
#ifdef EAGAIN
		    	case EAGAIN:
#endif
			    /* No error, try again */
			    break;
		    	default:
			    ret = -1;
			    goto err;	/* failure */
			}
		    }
		}
	    numbytes = 0;
	    while (numbytes != 1)
		{
	        num = read(fd, egdbuf, 1);
	        if (num == 0)
			goto err;	/* descriptor closed */
		else if (num > 0)
		    numbytes += num;
	    	else
		    {
		    switch (errno)
		    	{
#ifdef EINTR
		    	case EINTR:
#endif
#ifdef EAGAIN
		    	case EAGAIN:
#endif
			    /* No error, try again */
			    break;
		    	default:
			    ret = -1;
			    goto err;	/* failure */
			}
		    }
		}
	    if(egdbuf[0] == 0)
		goto err;
	    if (buf)
		retrievebuf = buf + ret;
	    else
		retrievebuf = tempbuf;
	    numbytes = 0;
	    while (numbytes != egdbuf[0])
		{
	        num = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes);
		if (num == 0)
			goto err;	/* descriptor closed */
	        else if (num > 0)
		    numbytes += num;
	    	else
		    {
		    switch (errno)
		    	{
#ifdef EINTR
		    	case EINTR:
#endif
#ifdef EAGAIN
		    	case EAGAIN:
#endif
			    /* No error, try again */
			    break;
		    	default:
			    ret = -1;
			    goto err;	/* failure */
			}
		    }
		}
	    ret += egdbuf[0];
	    bytes -= egdbuf[0];
	    if (!buf)
		RAND_seed(tempbuf, egdbuf[0]);
	    }
 err:
	if (fd != -1) close(fd);
	return(ret);
	}


int RAND_egd_bytes(const char *path, int bytes)
	{
	int num, ret = 0;

	num = RAND_query_egd_bytes(path, NULL, bytes);
	if (num < 1) goto err;
	if (RAND_status() == 1)
	    ret = num;
 err:
	return(ret);
	}


int RAND_egd(const char *path)
	{
	return (RAND_egd_bytes(path, 255));
	}


#endif
@


1.12
log
@resolve conflicts
@
text
@d98 1
a98 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_VOS)
@


1.11
log
@resolve conflicts
@
text
@d98 1
a98 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_VOS)
@


1.10
log
@merge 0.9.7d
@
text
@d98 1
a98 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VXWORKS)
d219 3
a221 1
	        if (num >= 0)
d251 3
a253 1
	        if (num >= 0)
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d59 1
d149 1
a149 1
	strlcpy(addr.sun_path,path,sizeof addr.sun_path);
@


1.8
log
@Less strcpy/strcat/sprintf. tdeval@@ ok.
@
text
@d97 1
a97 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(__DJGPP__)
d117 1
a117 1
# ifdef OPENSSL_SYS_VSWORKS
d146 1
a146 1
	if (strlen(path) > sizeof(addr.sun_path))
@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d148 1
a148 1
	strcpy(addr.sun_path,path);
@


1.6
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d97 1
a97 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS)
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d97 1
a97 1
#if defined(OPENSSL_SYS_WIN32) || defined(VMS) || defined(__VMS)
@


1.4
log
@openssl-engine-0.9.6a merge
@
text
@d2 1
a2 1
/* Written by Ulf Moeller for the OpenSSL project. */
d57 1
d60 35
a94 1
/* Query the EGD <URL: http://www.lothar.com/tech/crypto/>.
d97 5
a101 1
#if defined(WIN32) || defined(VMS) || defined(__VMS)
d117 5
a121 1
#include <sys/un.h>
d129 1
d135 1
a135 33
int RAND_egd(const char *path)
	{
	int ret = -1;
	struct sockaddr_un addr;
	int len, num;
	int fd = -1;
	unsigned char buf[256];

	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	if (strlen(path) > sizeof(addr.sun_path))
		return (-1);
	strcpy(addr.sun_path,path);
	len = offsetof(struct sockaddr_un, sun_path) + strlen(path);
	fd = socket(AF_UNIX, SOCK_STREAM, 0);
	if (fd == -1) return (-1);
	if (connect(fd, (struct sockaddr *)&addr, len) == -1) goto err;
	buf[0] = 1;
	buf[1] = 255;
	write(fd, buf, 2);
	if (read(fd, buf, 1) != 1) goto err;
	if (buf[0] == 0) goto err;
	num = read(fd, buf, 255);
	if (num < 1) goto err;
	RAND_seed(buf, num);
	if (RAND_status() == 1)
		ret = num;
 err:
	if (fd != -1) close(fd);
	return(ret);
	}

int RAND_egd_bytes(const char *path,int bytes)
d139 1
a139 1
	int len, num;
d141 2
a142 1
	unsigned char buf[255];
d152 33
a184 1
	if (connect(fd, (struct sockaddr *)&addr, len) == -1) goto err;
d188 4
a191 4
	    buf[0] = 1;
	    buf[1] = bytes < 255 ? bytes : 255;
	    write(fd, buf, 2);
	    if (read(fd, buf, 1) != 1)
d193 20
a212 2
		ret=-1;
		goto err;
d214 2
a215 4
	    if(buf[0] == 0)
		goto err;
	    num = read(fd, buf, buf[0]);
	    if (num < 1)
d217 22
a238 1
		ret=-1;
d240 6
a245 3
		}
	    RAND_seed(buf, num);
	    if (RAND_status() != 1)
d247 20
a266 2
		ret=-1;
		goto err;
d268 4
a271 2
	    ret += num;
	    bytes-=num;
d276 19
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d77 1
d79 6
@


1.2
log
@OpenSSL 0.9.5a merge
@
text
@d67 5
d115 52
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d100 1
a100 1
    if (buf[0] == 0) goto err;
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d2 1
a2 1
/* Written by Ulf Moeller and Lutz Jaenicke for the OpenSSL project. */
a56 1
#include <openssl/e_os2.h>
d59 1
a59 35
/*
 * Query the EGD <URL: http://www.lothar.com/tech/crypto/>.
 *
 * This module supplies three routines:
 *
 * RAND_query_egd_bytes(path, buf, bytes)
 *   will actually query "bytes" bytes of entropy form the egd-socket located
 *   at path and will write them to buf (if supplied) or will directly feed
 *   it to RAND_seed() if buf==NULL.
 *   The number of bytes is not limited by the maximum chunk size of EGD,
 *   which is 255 bytes. If more than 255 bytes are wanted, several chunks
 *   of entropy bytes are requested. The connection is left open until the
 *   query is competed.
 *   RAND_query_egd_bytes() returns with
 *     -1  if an error occured during connection or communication.
 *     num the number of bytes read from the EGD socket. This number is either
 *         the number of bytes requested or smaller, if the EGD pool is
 *         drained and the daemon signals that the pool is empty.
 *   This routine does not touch any RAND_status(). This is necessary, since
 *   PRNG functions may call it during initialization.
 *
 * RAND_egd_bytes(path, bytes) will query "bytes" bytes and have them
 *   used to seed the PRNG.
 *   RAND_egd_bytes() is a wrapper for RAND_query_egd_bytes() with buf=NULL.
 *   Unlike RAND_query_egd_bytes(), RAND_status() is used to test the
 *   seed status so that the return value can reflect the seed state:
 *     -1  if an error occured during connection or communication _or_
 *         if the PRNG has still not received the required seeding.
 *     num the number of bytes read from the EGD socket. This number is either
 *         the number of bytes requested or smaller, if the EGD pool is
 *         drained and the daemon signals that the pool is empty.
 *
 * RAND_egd(path) will query 255 bytes and use the bytes retreived to seed
 *   the PRNG.
 *   RAND_egd() is a wrapper for RAND_egd_bytes() with numbytes=255.
d62 1
a62 5
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS)
int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)
	{
	return(-1);
	}
a66 5

int RAND_egd_bytes(const char *path,int bytes)
	{
	return(-1);
	}
d72 1
a72 12
#ifndef NO_SYS_UN_H
# ifdef OPENSSL_SYS_VSWORKS
#   include <streams/un.h>
# else
#   include <sys/un.h>
# endif
#else
struct	sockaddr_un {
	short	sun_family;		/* AF_UNIX */
	char	sun_path[108];		/* path name (gag) */
};
#endif /* NO_SYS_UN_H */
a73 1
#include <errno.h>
d79 1
a79 1
int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)
d81 1
a81 1
	int ret = 0;
d83 1
a83 1
	int len, num, numbytes;
d85 1
a85 2
	int success;
	unsigned char egdbuf[2], tempbuf[255], *retrievebuf;
d95 7
a101 132
	success = 0;
	while (!success)
	    {
	    if (connect(fd, (struct sockaddr *)&addr, len) == 0)
	       success = 1;
	    else
		{
		switch (errno)
		    {
#ifdef EINTR
		    case EINTR:
#endif
#ifdef EAGAIN
		    case EAGAIN:
#endif
#ifdef EINPROGRESS
		    case EINPROGRESS:
#endif
#ifdef EALREADY
		    case EALREADY:
#endif
			/* No error, try again */
			break;
#ifdef EISCONN
		    case EISCONN:
			success = 1;
			break;
#endif
		    default:
			goto err;	/* failure */
		    }
		}
	    }

	while(bytes > 0)
	    {
	    egdbuf[0] = 1;
	    egdbuf[1] = bytes < 255 ? bytes : 255;
	    numbytes = 0;
	    while (numbytes != 2)
		{
	        num = write(fd, egdbuf + numbytes, 2 - numbytes);
	        if (num >= 0)
		    numbytes += num;
	    	else
		    {
		    switch (errno)
		    	{
#ifdef EINTR
		    	case EINTR:
#endif
#ifdef EAGAIN
		    	case EAGAIN:
#endif
			    /* No error, try again */
			    break;
		    	default:
			    ret = -1;
			    goto err;	/* failure */
			}
		    }
		}
	    numbytes = 0;
	    while (numbytes != 1)
		{
	        num = read(fd, egdbuf, 1);
	        if (num >= 0)
		    numbytes += num;
	    	else
		    {
		    switch (errno)
		    	{
#ifdef EINTR
		    	case EINTR:
#endif
#ifdef EAGAIN
		    	case EAGAIN:
#endif
			    /* No error, try again */
			    break;
		    	default:
			    ret = -1;
			    goto err;	/* failure */
			}
		    }
		}
	    if(egdbuf[0] == 0)
		goto err;
	    if (buf)
		retrievebuf = buf + ret;
	    else
		retrievebuf = tempbuf;
	    numbytes = 0;
	    while (numbytes != egdbuf[0])
		{
	        num = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes);
	        if (num >= 0)
		    numbytes += num;
	    	else
		    {
		    switch (errno)
		    	{
#ifdef EINTR
		    	case EINTR:
#endif
#ifdef EAGAIN
		    	case EAGAIN:
#endif
			    /* No error, try again */
			    break;
		    	default:
			    ret = -1;
			    goto err;	/* failure */
			}
		    }
		}
	    ret += egdbuf[0];
	    bytes -= egdbuf[0];
	    if (!buf)
		RAND_seed(tempbuf, egdbuf[0]);
	    }
 err:
	if (fd != -1) close(fd);
	return(ret);
	}


int RAND_egd_bytes(const char *path, int bytes)
	{
	int num, ret = 0;

	num = RAND_query_egd_bytes(path, NULL, bytes);
d103 1
d105 1
a105 1
	    ret = num;
d107 1
a109 8


int RAND_egd(const char *path)
	{
	return (RAND_egd_bytes(path, 255));
	}


@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@d97 1
a97 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(__DJGPP__)
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d97 1
a97 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VXWORKS)
d117 1
a117 1
# ifdef OPENSSL_SYS_VXWORKS
d146 1
a146 1
	if (strlen(path) >= sizeof(addr.sun_path))
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@a58 1
#include <openssl/buffer.h>
d148 1
a148 1
	BUF_strlcpy(addr.sun_path,path,sizeof addr.sun_path);
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d98 1
a98 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_VOS)
d219 1
a219 3
	        if (num == 0)
			goto err;	/* descriptor closed */
		else if (num > 0)
d249 1
a249 3
		if (num == 0)
			goto err;	/* descriptor closed */
	        else if (num > 0)
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d98 1
a98 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_VOS)
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d98 1
a98 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_VOS) || defined(OPENSSL_SYS_BEOS)
@


