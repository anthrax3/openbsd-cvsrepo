head	1.42;
access;
symbols;
locks; strict;
comment	@ * @;


1.42
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.41;
commitid	vHznCDK3idwNEFz4;

1.41
date	2015.07.18.22.46.42;	author beck;	state Exp;
branches;
next	1.40;
commitid	fGuKA1TeaJiX3Crq;

1.40
date	2014.10.22.13.02.04;	author jsing;	state Exp;
branches;
next	1.39;
commitid	PjnBgKe6Buhbf937;

1.39
date	2014.07.14.00.01.39;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	Hkj32IedPnEXpH1X;

1.38
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	mJUVYpkFBZ0Zv2bG;

1.37
date	2014.05.24.15.25.23;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.19.00.41.38;	author beck;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.18.14.37.41;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.18.13.19.03;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.18.11.31.16;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.16.03.21.29;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.15.16.52.50;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.13.19.50.56;	author beck;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.26;

1.26
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.29.05.39.25;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.03.15.12.45;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.10.16.31.55;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.20.18.14.36;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.22.00.03.17;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.12.18.15.59;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.02.23.03.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.15.02.58.03;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.02.04.10.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.16.23.50.12;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.16.21.46.36;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.16.04.47.06;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.42;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.11.15;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.33;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.56;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.56;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.48;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.43;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.49;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.14;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.35;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.59;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.13;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.10.13.21.23.42;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@/* $OpenBSD: randfile.c,v 1.41 2015/07/18 22:46:42 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include <openssl/crypto.h>
#include <openssl/rand.h>
#include <openssl/buffer.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#undef BUFSIZE
#define BUFSIZE	1024
#define RAND_DATA 1024

/* Note that these functions should not be used. */

int
RAND_load_file(const char *file, long bytes)
{
	/* the "whole" file */
	if (bytes == -1)
		return 123456;
	else
		return bytes;
}

int
RAND_write_file(const char *file)
{
	unsigned char buf[BUFSIZE];
	int i, ret = 0;
	FILE *out = NULL;
	int n, fd;
	struct stat sb;

	/*
	 * If this file is a device, avoid opening it.
	 * XXX TOCTOU
	 */
	if (stat(file, &sb) != -1 &&
	    (S_ISBLK(sb.st_mode) || S_ISCHR(sb.st_mode))) {
		return (1);
	}

	fd = open(file, O_WRONLY|O_CREAT, 0600);
	if (fd == -1)
		return (1);
	out = fdopen(fd, "wb");

	if (out == NULL) {
		close(fd);
		return (1);
	}

	n = RAND_DATA;
	for (;;) {
		i = (n > BUFSIZE) ? BUFSIZE : n;
		n -= BUFSIZE;
		arc4random_buf(buf, i);
		i = fwrite(buf, 1, i, out);
		if (i <= 0) {
			ret = 0;
			break;
		}
		ret += i;
		if (n <= 0)
			break;
	}

	fclose(out);
	explicit_bzero(buf, BUFSIZE);
	return ret;
}

const char *
RAND_file_name(char * buf, size_t size)
{
	if (strlcpy(buf, "/dev/urandom", size) >= size)
		return (NULL);
	return buf;
}
@


1.41
log
@rand_err doesn't exist anymore, coverity 78808
ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: randfile.c,v 1.40 2014/10/22 13:02:04 jsing Exp $ */
d133 1
a133 1
	OPENSSL_cleanse(buf, BUFSIZE);
@


1.40
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: randfile.c,v 1.39 2014/07/14 00:01:39 deraadt Exp $ */
d93 1
a93 1
	int i, ret = 0, rand_err = 0;
d134 1
a134 1
	return (rand_err ? -1 : ret);
@


1.39
log
@Improve RAND_write_file(), chmod crud, etc.
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: randfile.c,v 1.38 2014/06/12 15:49:30 deraadt Exp $ */
d121 1
a121 2
		if (RAND_bytes(buf, i) <= 0)
			rand_err = 1;
@


1.38
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d62 1
d95 1
a95 1
	int n;
d98 7
a104 10
	i = stat(file, &sb);
	if (i != -1) {
		if (S_ISBLK(sb.st_mode) || S_ISCHR(sb.st_mode)) {
			/* this file is a device. we don't write back to it.
			 * we "succeed" on the assumption this is some sort
			 * of random device. Otherwise attempting to write to
			 * and chmod the device causes problems.
			 */
			return (1);
		}
d107 8
a114 6
	{
		/* chmod(..., 0600) is too late to protect the file,
		 * permissions should be restrictive from the start */
		int fd = open(file, O_WRONLY|O_CREAT, 0600);
		if (fd != -1)
			out = fdopen(fd, "wb");
a116 6
	if (out == NULL)
		out = fopen(file, "wb");
	if (out == NULL)
		goto err;

	chmod(file, 0600);
a134 2

err:
d139 1
a139 1
RAND_file_name(char *buf, size_t size)
@


1.37
log
@KNF.
@
text
@d1 1
a1 1
/* crypto/rand/randfile.c */
@


1.36
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d78 2
a79 1
int RAND_load_file(const char *file, long bytes)
d88 3
a90 2
int RAND_write_file(const char *file)
	{
d92 1
a92 1
	int i,ret=0,rand_err=0;
d96 11
a106 11
	
	i=stat(file,&sb);
	if (i != -1) { 
	  if (S_ISBLK(sb.st_mode) || S_ISCHR(sb.st_mode)) {
	    /* this file is a device. we don't write back to it. 
	     * we "succeed" on the assumption this is some sort 
	     * of random device. Otherwise attempting to write to 
	     * and chmod the device causes problems.
	     */
	    return(1); 
	  }
d110 5
a114 5
	/* chmod(..., 0600) is too late to protect the file,
	 * permissions should be restrictive from the start */
	int fd = open(file, O_WRONLY|O_CREAT, 0600);
	if (fd != -1)
		out = fdopen(fd, "wb");
d118 3
a120 2
		out = fopen(file,"wb");
	if (out == NULL) goto err;
d122 14
a135 12
	chmod(file,0600);
	n=RAND_DATA;
	for (;;)
		{
		i=(n > BUFSIZE)?BUFSIZE:n;
		n-=BUFSIZE;
		if (RAND_bytes(buf,i) <= 0)
			rand_err=1;
		i=fwrite(buf,1,i,out);
		if (i <= 0)
			{
			ret=0;
d137 1
a137 4
			}
		ret+=i;
		if (n <= 0) break;
                }
d140 2
a141 1
	OPENSSL_cleanse(buf,BUFSIZE);
d144 1
a144 1
	}
d146 2
a147 1
const char *RAND_file_name(char *buf, size_t size)
d149 2
a150 2
	if (strlcpy(buf,"/dev/urandom",size) >= size)
		return(NULL);
@


1.35
log
@Put the final pieces from e_os.h in the required places, and remove it.
"dance on it's grave" says beck
ok guenther beck
@
text
@d145 1
a145 1
	if (BUF_strlcpy(buf,"/dev/urandom",size) >= size)
@


1.34
log
@another round of chemo for the RAND code to provide clarity.
ok deraadt
@
text
@a63 1
#include "e_os.h"
@


1.33
log
@define RFILE only in the file that needs it
@
text
@d77 1
a77 4
#define RFILE           ".rnd"

/* Note that these functions are intended for seed files only.
 * Entropy devices and EGD sockets are handled in rand_unix.c */
d145 5
a149 43
	{
	char *s=NULL;
	struct stat sb;

	if (OPENSSL_issetugid() == 0)
		s=getenv("RANDFILE");
	if (s != NULL && *s && strlen(s) + 1 < size)
		{
		if (BUF_strlcpy(buf,s,size) >= size)
			return NULL;
		}
	else
		{
		if (OPENSSL_issetugid() == 0)
			s=getenv("HOME");
		if (s && *s && strlen(s)+strlen(RFILE)+2 < size)
			{
			BUF_strlcpy(buf,s,size);
			BUF_strlcat(buf,"/",size);
			BUF_strlcat(buf,RFILE,size);
			}
		else
		  	buf[0] = '\0'; /* no file name */
		}

	/* given that all random loads just fail if the file can't be 
	 * seen on a stat, we stat the file we're returning, if it
	 * fails, use /dev/arandom instead. this allows the user to 
	 * use their own source for good random data, but defaults
	 * to something hopefully decent if that isn't available. 
	 */

	if (!buf[0])
		if (BUF_strlcpy(buf,"/dev/arandom",size) >= size) {
			return(NULL);
		}	
	if (stat(buf,&sb) == -1)
		if (BUF_strlcpy(buf,"/dev/arandom",size) >= size) {
			return(NULL);
		}	

	return(buf);
	}
@


1.32
log
@API compat fix. RAND_load_file can never fail now. discovered and ok beck.
@
text
@d77 1
a77 1
/* #define RFILE ".rnd" - defined in ../../e_os.h */
@


1.31
log
@Replace the old OpenSSL PRNG by direct use of arc4random_buf(), keeping the
existing RAND interfaces unchanged.

All interfaces allowing external feed or seed of the RNG (either from a file
or a local entropy gathering daemon) are kept for ABI compatibility, but are
no longer do anything.

While the OpenSSL PRNG was required 15+ years ago when many systems lacked
proper entropy collection, things have evolved and one can reasonably assume
it is better to use the kernel (system global) entropy pool rather than trying
to build one's own and having to compensate for thread scheduling...

<RANT>
Whoever thought that RAND_screen(), feeding the PRNG with the contents of the
local workstation's display, under Win32, was a smart idea, ought to be banned
from security programming.
</RANT>

ok beck@@ deraadt@@ tedu@@
@
text
@d83 7
a89 3
	{
	return(0);
	}
@


1.30
log
@Remove some stuff that isn't needed.
ok miod@@ deraadt@@
@
text
@a58 5
/* We need to define this to get macros like S_IFBLK and S_IFCHR */
#if !defined(OPENSSL_SYS_VXWORKS)
#define _XOPEN_SOURCE 500
#endif

d69 3
a71 16
#ifdef OPENSSL_SYS_VMS
#include <unixio.h>
#endif
#ifndef NO_SYS_TYPES_H
# include <sys/types.h>
#endif
#ifndef OPENSSL_NO_POSIX_IO
# include <sys/stat.h>
#endif

#ifdef _WIN32
#define stat	_stat
#define chmod	_chmod
#define open	_open
#define fdopen	_fdopen
#endif
a76 8
#ifdef OPENSSL_SYS_VMS
/* This declaration is a nasty hack to get around vms' extension to fopen
 * for passing in sharing options being disabled by our /STANDARD=ANSI89 */
static FILE *(*const vms_fopen)(const char *, const char *, ...) =
    (FILE *(*)(const char *, const char *, ...))fopen;
#define VMS_OPEN_ATTRS "shr=get,put,upd,del","ctx=bin,stm","rfm=stm","rat=none","mrs=0"
#endif

d84 1
a84 69
	/* If bytes >= 0, read up to 'bytes' bytes.
	 * if bytes == -1, read complete file. */

	unsigned char buf[BUFSIZE];
#ifndef OPENSSL_NO_POSIX_IO
	struct stat sb;
#endif
	int i,ret=0,n;
	FILE *in;

	if (file == NULL) return(0);

#ifndef OPENSSL_NO_POSIX_IO
#ifdef PURIFY
	/* struct stat can have padding and unused fields that may not be
	 * initialized in the call to stat(). We need to clear the entire
	 * structure before calling RAND_add() to avoid complaints from
	 * applications such as Valgrind.
	 */
	memset(&sb, 0, sizeof(sb));
#endif
	if (stat(file,&sb) < 0) return(0);
	RAND_add(&sb,sizeof(sb),0.0);
#endif
	if (bytes == 0) return(ret);

#ifdef OPENSSL_SYS_VMS
	in=vms_fopen(file,"rb",VMS_OPEN_ATTRS);
#else
	in=fopen(file,"rb");
#endif
	if (in == NULL) goto err;
#if defined(S_IFBLK) && defined(S_IFCHR) && !defined(OPENSSL_NO_POSIX_IO)
	if (sb.st_mode & (S_IFBLK | S_IFCHR)) {
	  /* this file is a device. we don't want read an infinite number
	   * of bytes from a random device, nor do we want to use buffered
	   * I/O because we will waste system entropy. 
	   */
	  bytes = (bytes == -1) ? 2048 : bytes; /* ok, is 2048 enough? */
#ifndef OPENSSL_NO_SETVBUF_IONBF
	  setvbuf(in, NULL, _IONBF, 0); /* don't do buffered reads */
#endif /* ndef OPENSSL_NO_SETVBUF_IONBF */
	}
#endif
	for (;;)
		{
		if (bytes > 0)
			n = (bytes < BUFSIZE)?(int)bytes:BUFSIZE;
		else
			n = BUFSIZE;
		i=fread(buf,1,n,in);
		if (i <= 0) break;
#ifdef PURIFY
		RAND_add(buf,i,(double)i);
#else
		/* even if n != i, use the full array */
		RAND_add(buf,n,(double)i);
#endif
		ret+=i;
		if (bytes > 0)
			{
			bytes-=n;
			if (bytes <= 0) break;
			}
		}
	fclose(in);
	OPENSSL_cleanse(buf,BUFSIZE);
err:
	return(ret);
a92 1
#ifndef OPENSSL_NO_POSIX_IO
a96 1
#if defined(S_ISBLK) && defined(S_ISCHR)
a104 1
#endif
a105 1
#endif
a106 1
#if defined(O_CREAT) && !defined(OPENSSL_NO_POSIX_IO) && !defined(OPENSSL_SYS_VMS)
a107 3
#ifndef O_BINARY
#define O_BINARY 0
#endif
d110 1
a110 1
	int fd = open(file, O_WRONLY|O_CREAT|O_BINARY, 0600);
a113 1
#endif
a114 24
#ifdef OPENSSL_SYS_VMS
	/* VMS NOTE: Prior versions of this routine created a _new_
	 * version of the rand file for each call into this routine, then
	 * deleted all existing versions named ;-1, and finally renamed
	 * the current version as ';1'. Under concurrent usage, this
	 * resulted in an RMS race condition in rename() which could
	 * orphan files (see vms message help for RMS$_REENT). With the
	 * fopen() calls below, openssl/VMS now shares the top-level
	 * version of the rand file. Note that there may still be
	 * conditions where the top-level rand file is locked. If so, this
	 * code will then create a new version of the rand file. Without
	 * the delete and rename code, this can result in ascending file
	 * versions that stop at version 32767, and this routine will then
	 * return an error. The remedy for this is to recode the calling
	 * application to avoid concurrent use of the rand file, or
	 * synchronize usage at the application level. Also consider
	 * whether or not you NEED a persistent rand file in a concurrent
	 * use situation. 
	 */

	out = vms_fopen(file,"rb+",VMS_OPEN_ATTRS);
	if (out == NULL)
		out = vms_fopen(file,"wb",VMS_OPEN_ATTRS);
#else
a116 1
#endif
a118 1
#ifndef NO_CHMOD
a119 1
#endif
a145 1
#ifdef __OpenBSD__
a146 1
#endif
a158 6
#ifdef DEFAULT_HOME
		if (s == NULL)
			{
			s = DEFAULT_HOME;
			}
#endif
a161 1
#ifndef OPENSSL_SYS_VMS
a162 1
#endif
a168 1
#ifdef __OpenBSD__
a184 1
#endif
@


1.29
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d113 1
a113 1
	MS_STATIC unsigned char buf[BUFSIZE];
@


1.28
log
@resolve conflicts
@
text
@d60 1
d62 1
@


1.27
log
@openssl-1.0.0e: resolve conflicts
@
text
@d140 1
a140 1
#if defined(S_IFBLK) && defined(S_IFCHR) && !defined(OPNESSL_NO_POSIX_IO)
@


1.26
log
@resolve conflicts, fix local changes
@
text
@d147 1
d149 1
a273 1
	int ok = 0;
a301 1
			ok = 1;
d315 1
a315 1
	if (!ok)
@


1.25
log
@resolve conflicts
@
text
@d78 1
a78 3
#ifdef MAC_OS_pre_X
# include <stat.h>
#else
d112 1
d114 1
d120 9
d131 1
d140 1
a140 1
#if defined(S_IFBLK) && defined(S_IFCHR)
d183 1
d188 2
a189 2
#if defined(S_IFBLK) && defined(S_IFCHR)
	  if (sb.st_mode & (S_IFBLK | S_IFCHR)) {
d199 1
d201 1
a201 1
#if defined(O_CREAT) && !defined(OPENSSL_SYS_WIN32) && !defined(OPENSSL_SYS_VMS)
d203 3
a205 2
	/* For some reason Win32 can't write to files created this way */
	
d208 1
a208 1
	int fd = open(file, O_CREAT, 0600);
@


1.24
log
@resolve conflicts
@
text
@d264 1
a264 1
	if (issetugid() == 0)
d273 1
a273 1
		if (issetugid() == 0)
@


1.23
log
@resolve conflicts
@
text
@d84 7
d95 8
d124 3
d128 1
d189 1
a189 1
#if defined(O_CREAT) && !defined(OPENSSL_SYS_WIN32)
d200 25
d227 1
a248 19
#ifdef OPENSSL_SYS_VMS
	/* Try to delete older versions of the file, until there aren't
	   any */
	{
	char *tmpf;

	tmpf = OPENSSL_malloc(strlen(file) + 4);  /* to add ";-1" and a nul */
	if (tmpf)
		{
		strcpy(tmpf, file);
		strcat(tmpf, ";-1");
		while(delete(tmpf) == 0)
			;
		rename(file,";1"); /* Make sure it's version 1, or we
				      will reach the limit (32767) at
				      some point... */
		}
	}
#endif /* OPENSSL_SYS_VMS */
@


1.22
log
@resolve conflicts
@
text
@d105 2
a106 4
	i=stat(file,&sb);
	/* If the state fails, put some crap in anyway */
	RAND_add(&sb,sizeof(sb),0);
	if (i < 0) return(0);
d129 3
d133 2
a134 1
		RAND_add(buf,n,i);
@


1.21
log
@resolve conflicts
@
text
@d60 1
a60 1
#define _XOPEN_SOURCE 1
@


1.20
log
@merge 0.9.7d
@
text
@d169 1
d177 1
@


1.19
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d59 3
d70 1
d113 1
d122 1
d156 1
d165 1
d230 1
d232 1
d238 1
a238 1
		if (strlcpy(buf,s,size) >= size)
d253 1
a253 1
			strlcpy(buf,s,size);
d255 1
a255 1
			strlcat(buf,"/",size);
d257 1
a257 1
			strlcat(buf,RFILE,size);
d273 1
a273 1
		if (strlcpy(buf,"/dev/arandom",size) >= size) {
d277 1
a277 1
		if (strlcpy(buf,"/dev/arandom",size) >= size) {
@


1.18
log
@str{cat,cpy}/sprintf cleanup. markus@@, deraadt@@ ok
@
text
@d135 1
a135 1
	memset(buf,0,BUFSIZE);
d213 1
a213 1
	memset(buf,0,BUFSIZE);
d228 2
a229 2
		strlcpy(buf,s,size);
		ok = 1;
@


1.17
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d245 1
a245 1
			strcat(buf,"/");
@


1.16
log
@merge with 0.9.7-beta1
@
text
@d147 1
a147 1

@


1.15
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d102 3
a104 5
	if (i < 0) { 
	  /* If the state fails, put some crap in anyway */
	  RAND_add(&sb,sizeof(sb),0);
	  return(0);
	}
d106 1
d220 1
a220 1
	char *s = NULL;
d225 1
a225 1
		s = getenv("RANDFILE");
a273 1

@


1.14
log
@fix to match documented behaviour. RAND_file_name must return a pointer to
buf, not something else.
@
text
@d64 5
a68 1
#ifdef VMS
a79 4
#include "openssl/e_os.h"
#include <openssl/crypto.h>
#include <openssl/rand.h>

d161 1
a161 1
#if defined(O_CREAT) && !defined(WIN32)
d193 1
a193 1
#ifdef VMS
d211 1
a211 1
#endif /* VMS */
d245 1
a245 1
#ifndef VMS
d255 1
a255 1
#ifdef DEVRANDOM
d258 1
a258 1
	 * fails, use DEVRANDOM instead. this allows the user to 
d264 1
a264 1
		if (strlcpy(buf,DEVRANDOM,size) >= size) {
d268 1
a268 1
		if (strlcpy(buf,DEVRANDOM,size) >= size) {
@


1.13
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d222 1
a222 1
	char *ret=NULL;
d230 1
a230 1
		ret=buf;
d249 1
a249 1
			ret=buf;
d258 1
a258 1
	 * fails, use DEVRANDOM instead. the allows the user to 
d263 8
a270 2
	if (ret == NULL)
		ret = DEVRANDOM;
a271 2
	if (stat(ret,&sb) == -1)
		ret = DEVRANDOM;
d273 1
a273 1
	return(ret);
@


1.12
log
@openssl-engine-0.9.6a merge
@
text
@d236 6
d251 1
a251 1
		  else
@


1.11
log
@make sure s always has enough from for trailing \0. even though strlcpy will
truncate, thanks to itojun@@
@
text
@d76 1
a76 1
#include <openssl/e_os.h>
d86 3
d219 1
a219 1
const char *RAND_file_name(char *buf, int size)
d245 2
d265 1
@


1.10
log
@do not honour environment variables if issetugid, and even more strongly support the random device
@
text
@d224 1
a224 1
	if (s != NULL && *s && strlen(s) < size)
@


1.9
log
@openssl-engine-0.9.6 merge
@
text
@d218 1
a218 1
	char *s;
d222 3
a224 2
	s=getenv("RANDFILE");
	if (s != NULL)
d226 1
a226 2
		strncpy(buf,s,size-1);
		buf[size-1]='\0';
d231 3
a233 6
		s=getenv("HOME");
		if (s == NULL || *s == '\0') 
		  ret = RFILE;
		if (((int)(strlen(s)+strlen(RFILE)+2)) > size) 
			ret=RFILE;
		else 
d235 1
a235 1
			 strlcpy(buf,s,size);
d237 1
a237 1
			 strcat(buf,"/");
d239 2
a240 2
			 strlcat(buf,RFILE,size);
			 ret=buf;
d243 1
d252 3
d256 1
a256 1
	  ret = DEVRANDOM;
a259 1

@


1.8
log
@$HOME paranoia: never use getenv("HOME") w/o checking for NULL and non-zero
@
text
@a63 2
#include "openssl/e_os.h"

d76 1
d141 1
a141 1
	int i,ret=0,err=0;
d158 1
a158 1
#if defined(O_CREAT) && defined(O_EXCL) && !defined(WIN32)
d160 6
a165 6

        /* chmod(..., 0600) is too late to protect the file,
         * permissions should be restrictive from the start */
        int fd = open(file, O_CREAT | O_EXCL, 0600);
        if (fd != -1)
                out = fdopen(fd, "wb");
d167 3
a169 3
        if (out == NULL)
                out = fopen(file,"wb");
        if (out == NULL) goto err;
d180 1
a180 1
			err=1;
d196 1
a196 1
	tmpf = Malloc(strlen(file) + 4);  /* to add ";-1" and a nul */
d213 1
a213 1
	return(err ? -1 : ret);
@


1.7
log
@Fix strcpy/strcat abuse and fix stupid behaviour of the default
RAND_file_name - changed so that it stats the filename it returns
before returing it. If the file won't stat, return DEVRANDOM (for us
/dev/arandom) instead, thus making the default behaviour moderately
intelligent.
@
text
@d233 1
a233 1
		if (s == NULL) 
@


1.6
log
@Fix randfile so it doesn't attempt to chmod and write entropy back to
devices. This caused people's /dev/arandom's to be permitted 600,
which causes rsa to fail to get random data, which results in all
kinds of fun with ssh :)
@
text
@d221 1
d233 7
a239 4
		if (s == NULL) return(RFILE);
		if (((int)(strlen(s)+strlen(RFILE)+2)) > size)
			return(RFILE);
		strcpy(buf,s);
d241 1
a241 1
		strcat(buf,"/");
d243 3
a245 2
		strcat(buf,RFILE);
		ret=buf;
d247 11
d260 1
@


1.5
log
@Fix this for the case where the file is a device - make sure we don't
attempt to read from a device forever.
@
text
@d145 14
a158 1
	
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d100 5
a104 3
	/* If the state fails, put some crap in anyway */
	RAND_add(&sb,sizeof(sb),0);
	if (i < 0) return(0);
a105 1

d108 8
d130 1
a130 1
			if (bytes == 0) break;
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d136 3
d140 9
a148 14
#ifdef VMS
	/* Under VMS, fopen(file, "wb") will create a new version of the
	   same file.  This is not good, so let's try updating an existing
	   one, and create file only if it doesn't already exist. */
	/* At the same time, if we just update a file, we also need to
	   truncate it, and unfortunately, ftruncate() and truncate() do
	   not exist everywhere.  All that remains is to delete old versions
	   of the random data file (done at the end). */
#if 0
	out=fopen(file,"rb+");
	if (out == NULL && errno != ENOENT)
		goto err;
#endif
#endif
a149 13
	if (out == NULL)
		{
#if defined O_CREAT && defined O_EXCL
		/* chmod(..., 0600) is too late to protect the file,
		 * permissions should be restrictive from the start */
		int fd = open(file, O_CREAT | O_EXCL, 0600);
		if (fd != -1)
			out = fdopen(fd, "wb");
#else		
		out=fopen(file,"wb");
#endif
		}
	if (out == NULL) goto err;
d168 1
a168 1
		}
a169 6
	/* We may have updated an existing file using mode "rb+",
	 * now remove any old extra bytes */
#if 0
	if (ret > 0)
		ftruncate(fileno(out), ret);
#else
d187 1
a187 2
#endif
#endif
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@a62 3
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/types.h>
d66 13
d85 1
a85 1
/* #define RFILE ".rand" - defined in ../../e_os.h */
d89 3
d101 1
a101 2
	RAND_seed(&sb,sizeof(sb));
	ret+=sizeof(sb);
d103 1
a103 1
	if (bytes <= 0) return(ret);
d109 4
a112 1
		n=(bytes < BUFSIZE)?(int)bytes:BUFSIZE;
d116 1
a116 1
		RAND_seed(buf,n);
d118 5
a122 2
		bytes-=n;
		if (bytes <= 0) break;
d133 2
a134 2
	int i,ret=0;
	FILE *out;
d137 2
a138 1
	/* Under VMS, fopen(file, "wb") will craete a new version of the
d140 6
a145 3
	   one, and create file only if it doesn't already exist.  This
	   should be completely harmless on system that have no file
	   versions.					-- Richard Levitte */
d147 6
a152 1
	if (out == NULL && errno == ENOENT)
d154 7
a160 1
		errno = 0;
d162 1
d165 1
d167 1
d173 2
a174 1
		RAND_bytes(buf,i);
d184 27
d214 1
a214 1
	return(ret);
d217 1
a217 1
char *RAND_file_name(char *buf, int size)
@


1.1
log
@Initial revision
@
text
@d59 1
d61 3
a63 1
#include "cryptlib.h"
d66 4
a69 1
#include "rand.h"
d77 1
a77 3
int RAND_load_file(file,bytes)
char *file;
long bytes;
d88 1
a88 1
	RAND_seed((unsigned char *)&sb,sizeof(sb));
d93 1
a93 1
	in=fopen(file,"r");
d112 1
a112 2
int RAND_write_file(file)
char *file;
d119 11
a129 1
	out=fopen(file,"w");
d153 1
a153 3
char *RAND_file_name(buf,size)
char *buf;
int size;
d172 1
d174 1
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a58 1
#include <errno.h>
d60 4
a63 18
#include <stdlib.h>
#include <string.h>

#include "e_os.h"
#include <openssl/crypto.h>
#include <openssl/rand.h>

#ifdef OPENSSL_SYS_VMS
#include <unixio.h>
#endif
#ifndef NO_SYS_TYPES_H
# include <sys/types.h>
#endif
#ifdef MAC_OS_pre_X
# include <stat.h>
#else
# include <sys/stat.h>
#endif
d69 1
a69 4
/* #define RFILE ".rnd" - defined in ../../e_os.h */

/* Note that these functions are intended for seed files only.
 * Entropy devices and EGD sockets are handled in rand_unix.c */
d71 3
a73 1
int RAND_load_file(const char *file, long bytes)
a74 3
	/* If bytes >= 0, read up to 'bytes' bytes.
	 * if bytes == -1, read complete file. */

d84 2
a85 1
	RAND_add(&sb,sizeof(sb),0);
d87 1
a87 1
	if (bytes == 0) return(ret);
d89 1
a89 1
	in=fopen(file,"rb");
d93 1
a93 4
		if (bytes > 0)
			n = (bytes < BUFSIZE)?(int)bytes:BUFSIZE;
		else
			n = BUFSIZE;
d97 1
a97 1
		RAND_add(buf,n,i);
d99 2
a100 5
		if (bytes > 0)
			{
			bytes-=n;
			if (bytes <= 0) break;
			}
d108 2
a109 1
int RAND_write_file(const char *file)
d112 2
a113 2
	int i,ret=0,rand_err=0;
	FILE *out = NULL;
d115 2
a116 12
	
#if defined(O_CREAT) && !defined(OPENSSL_SYS_WIN32)
	/* For some reason Win32 can't write to files created this way */
	
	/* chmod(..., 0600) is too late to protect the file,
	 * permissions should be restrictive from the start */
	int fd = open(file, O_CREAT, 0600);
	if (fd != -1)
		out = fdopen(fd, "wb");
#endif
	if (out == NULL)
		out = fopen(file,"wb");
a117 2

#ifndef NO_CHMOD
a118 1
#endif
d124 1
a124 2
		if (RAND_bytes(buf,i) <= 0)
			rand_err=1;
a132 17
                }
#ifdef OPENSSL_SYS_VMS
	/* Try to delete older versions of the file, until there aren't
	   any */
	{
	char *tmpf;

	tmpf = OPENSSL_malloc(strlen(file) + 4);  /* to add ";-1" and a nul */
	if (tmpf)
		{
		strcpy(tmpf, file);
		strcat(tmpf, ";-1");
		while(delete(tmpf) == 0)
			;
		rename(file,";1"); /* Make sure it's version 1, or we
				      will reach the limit (32767) at
				      some point... */
a133 3
	}
#endif /* OPENSSL_SYS_VMS */

d137 1
a137 1
	return (rand_err ? -1 : ret);
d140 3
a142 1
const char *RAND_file_name(char *buf, size_t size)
d144 1
a144 1
	char *s=NULL;
d147 1
a147 2
	if (OPENSSL_issetugid() == 0)
		s=getenv("RANDFILE");
d156 8
a163 19
		if (OPENSSL_issetugid() == 0)
			s=getenv("HOME");
#ifdef DEFAULT_HOME
		if (s == NULL)
			{
			s = DEFAULT_HOME;
			}
#endif
		if (s != NULL && (strlen(s)+strlen(RFILE)+2 < size))
			{
			strcpy(buf,s);
#ifndef OPENSSL_SYS_VMS
			strcat(buf,"/");
#endif
			strcat(buf,RFILE);
			ret=buf;
			}
		else
		  	buf[0] = '\0'; /* no file name */
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d127 1
a127 1
	OPENSSL_cleanse(buf,BUFSIZE);
d192 1
a192 1
	OPENSSL_cleanse(buf,BUFSIZE);
d206 2
a207 3
		if(strlen(s) >= size)
			return NULL;
		strcpy(buf,s);
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@a58 3
/* We need to define this to get macros like S_IFBLK and S_IFCHR */
#define _XOPEN_SOURCE 1

a66 1
#include <openssl/buffer.h>
a108 10
#if defined(S_IFBLK) && defined(S_IFCHR)
	if (sb.st_mode & (S_IFBLK | S_IFCHR)) {
	  /* this file is a device. we don't want read an infinite number
	   * of bytes from a random device, nor do we want to use buffered
	   * I/O because we will waste system entropy. 
	   */
	  bytes = (bytes == -1) ? 2048 : bytes; /* ok, is 2048 enough? */
	  setvbuf(in, NULL, _IONBF, 0); /* don't do buffered reads */
	}
#endif
a137 1
	struct stat sb;
a138 14
	i=stat(file,&sb);
	if (i != -1) { 
#if defined(S_IFBLK) && defined(S_IFCHR)
	  if (sb.st_mode & (S_IFBLK | S_IFCHR)) {
	    /* this file is a device. we don't write back to it. 
	     * we "succeed" on the assumption this is some sort 
	     * of random device. Otherwise attempting to write to 
	     * and chmod the device causes problems.
	     */
	    return(1); 
	  }
#endif
	}

d200 1
a200 4
	int ok = 0;
#ifdef __OpenBSD__
	struct stat sb;
#endif
d204 1
a204 1
	if (s != NULL && *s && strlen(s) + 1 < size)
d206 1
a206 1
		if (BUF_strlcpy(buf,s,size) >= size)
d208 2
d221 1
a221 1
		if (s && *s && strlen(s)+strlen(RFILE)+2 < size)
d223 1
a223 1
			BUF_strlcpy(buf,s,size);
d225 1
a225 1
			BUF_strlcat(buf,"/",size);
d227 2
a228 2
			BUF_strlcat(buf,RFILE,size);
			ok = 1;
d233 1
a233 20

#ifdef __OpenBSD__
	/* given that all random loads just fail if the file can't be 
	 * seen on a stat, we stat the file we're returning, if it
	 * fails, use /dev/arandom instead. this allows the user to 
	 * use their own source for good random data, but defaults
	 * to something hopefully decent if that isn't available. 
	 */

	if (!ok)
		if (BUF_strlcpy(buf,"/dev/arandom",size) >= size) {
			return(NULL);
		}	
	if (stat(buf,&sb) == -1)
		if (BUF_strlcpy(buf,"/dev/arandom",size) >= size) {
			return(NULL);
		}	

#endif
	return(buf);
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a168 1
	{
a175 1
	}
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d60 1
a60 1
#define _XOPEN_SOURCE 500
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d105 4
a108 2
	if (stat(file,&sb) < 0) return(0);
	RAND_add(&sb,sizeof(sb),0.0);
a130 3
#ifdef PURIFY
		RAND_add(buf,i,(double)i);
#else
d132 1
a132 2
		RAND_add(buf,n,(double)i);
#endif
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a83 7
#ifdef _WIN32
#define stat	_stat
#define chmod	_chmod
#define open	_open
#define fdopen	_fdopen
#endif

a87 8
#ifdef OPENSSL_SYS_VMS
/* This declaration is a nasty hack to get around vms' extension to fopen
 * for passing in sharing options being disabled by our /STANDARD=ANSI89 */
static FILE *(*const vms_fopen)(const char *, const char *, ...) =
    (FILE *(*)(const char *, const char *, ...))fopen;
#define VMS_OPEN_ATTRS "shr=get,put,upd,del","ctx=bin,stm","rfm=stm","rat=none","mrs=0"
#endif

a108 3
#ifdef OPENSSL_SYS_VMS
	in=vms_fopen(file,"rb",VMS_OPEN_ATTRS);
#else
a109 1
#endif
d170 1
a170 1
#if defined(O_CREAT) && !defined(OPENSSL_SYS_WIN32) && !defined(OPENSSL_SYS_VMS)
a180 25

#ifdef OPENSSL_SYS_VMS
	/* VMS NOTE: Prior versions of this routine created a _new_
	 * version of the rand file for each call into this routine, then
	 * deleted all existing versions named ;-1, and finally renamed
	 * the current version as ';1'. Under concurrent usage, this
	 * resulted in an RMS race condition in rename() which could
	 * orphan files (see vms message help for RMS$_REENT). With the
	 * fopen() calls below, openssl/VMS now shares the top-level
	 * version of the rand file. Note that there may still be
	 * conditions where the top-level rand file is locked. If so, this
	 * code will then create a new version of the rand file. Without
	 * the delete and rename code, this can result in ascending file
	 * versions that stop at version 32767, and this routine will then
	 * return an error. The remedy for this is to recode the calling
	 * application to avoid concurrent use of the rand file, or
	 * synchronize usage at the application level. Also consider
	 * whether or not you NEED a persistent rand file in a concurrent
	 * use situation. 
	 */

	out = vms_fopen(file,"rb+",VMS_OPEN_ATTRS);
	if (out == NULL)
		out = vms_fopen(file,"wb",VMS_OPEN_ATTRS);
#else
a182 1
#endif
d204 19
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d78 3
a80 1
#ifndef OPENSSL_NO_POSIX_IO
a113 1
#ifndef OPENSSL_NO_POSIX_IO
a114 1
#endif
a119 9
#ifndef OPENSSL_NO_POSIX_IO
#ifdef PURIFY
	/* struct stat can have padding and unused fields that may not be
	 * initialized in the call to stat(). We need to clear the entire
	 * structure before calling RAND_add() to avoid complaints from
	 * applications such as Valgrind.
	 */
	memset(&sb, 0, sizeof(sb));
#endif
a121 1
#endif
d130 1
a130 1
#if defined(S_IFBLK) && defined(S_IFCHR) && !defined(OPNESSL_NO_POSIX_IO)
a172 1
#ifndef OPENSSL_NO_POSIX_IO
d177 2
a178 2
#if defined(S_ISBLK) && defined(S_ISCHR)
	  if (S_ISBLK(sb.st_mode) || S_ISCHR(sb.st_mode)) {
a187 1
#endif
d189 1
a189 1
#if defined(O_CREAT) && !defined(OPENSSL_NO_POSIX_IO) && !defined(OPENSSL_SYS_VMS)
d191 2
a192 3
#ifndef O_BINARY
#define O_BINARY 0
#endif
d195 1
a195 1
	int fd = open(file, O_WRONLY|O_CREAT|O_BINARY, 0600);
@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@a146 1
#ifndef OPENSSL_NO_SETVBUF_IONBF
a147 1
#endif /* ndef OPENSSL_NO_SETVBUF_IONBF */
d272 1
d301 1
d315 1
a315 1
	if (!buf[0])
@


1.1.1.11
log
@import OpenSSL-1.0.1c
@
text
@d140 1
a140 1
#if defined(S_IFBLK) && defined(S_IFCHR) && !defined(OPENSSL_NO_POSIX_IO)
@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@a59 1
#if !defined(OPENSSL_SYS_VXWORKS)
a60 1
#endif
@


