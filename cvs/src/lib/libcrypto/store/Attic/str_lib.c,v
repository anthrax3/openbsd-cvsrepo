head	1.13;
access;
symbols
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	butholakala:1.1.1.2
	openssl_1_0_1_g:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.16
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.12
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	openssl_1_0_1_c:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.6
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.8
	openssl_1_0_0_f:1.1.1.2
	openssl_1_0_0_e:1.1.1.2
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	openssh_1_0_0_a:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.8
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.4
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	openssl_0_9_8_k:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	openssl_0_9_8_j:1.1.1.1
	openssl_0_9_8_h:1.1.1.1
	openssl:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.02.10.11.16.33;	author jsing;	state dead;
branches;
next	1.12;
commitid	u8KgFcebA5Hs8Hgb;

1.12
date	2014.11.18.03.28.05;	author tedu;	state Exp;
branches;
next	1.11;
commitid	UtItdNUXNaRhKkyD;

1.11
date	2014.10.16.03.19.02;	author beck;	state Exp;
branches;
next	1.10;
commitid	id4pE5GZpJTmZzW6;

1.10
date	2014.07.10.22.45.58;	author jsing;	state Exp;
branches;
next	1.9;
commitid	nzndm3zqPmFurSaK;

1.9
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	mJUVYpkFBZ0Zv2bG;

1.8
date	2014.06.11.01.53.02;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	4evB2EbwDYaBfe0g;

1.7
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	2nvnQBrv22dLtvTt;

1.6
date	2014.05.29.16.42.04;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2014.05.26.11.24.48;	author jsing;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.17.21.32.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.17.10.56.25;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove crypto/store - part of which is "currently highly experimental".
This code is not compiled in and OPENSSL_NO_STORE is already defined in
opensslfeatures.h. No symbol removal for libcrypto.

ok beck@@
@
text
@/* $OpenBSD: str_lib.c,v 1.12 2014/11/18 03:28:05 tedu Exp $ */
/* Written by Richard Levitte (richard@@levitte.org) for the OpenSSL
 * project 2003.
 */
/* ====================================================================
 * Copyright (c) 2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/bn.h>
#include <openssl/err.h>
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif
#include <openssl/sha.h>
#include <openssl/x509.h>
#include "str_locl.h"

const char * const STORE_object_type_string[STORE_OBJECT_TYPE_NUM + 1] = {
	0,
	"X.509 Certificate",
	"X.509 CRL",
	"Private Key",
	"Public Key",
	"Number",
	"Arbitrary Data"
};

const int STORE_param_sizes[STORE_PARAM_TYPE_NUM + 1] = {
	0,
	sizeof(int),		/* EVP_TYPE */
	sizeof(size_t),		/* BITS */
	-1,			/* KEY_PARAMETERS */
	0			/* KEY_NO_PARAMETERS */
};

const int STORE_attr_sizes[STORE_ATTR_TYPE_NUM + 1] = {
	0,
	-1,			/* FRIENDLYNAME:	C string */
	SHA_DIGEST_LENGTH,	/* KEYID:		SHA1 digest, 160 bits */
	SHA_DIGEST_LENGTH,	/* ISSUERKEYID:		SHA1 digest, 160 bits */
	SHA_DIGEST_LENGTH,	/* SUBJECTKEYID:	SHA1 digest, 160 bits */
	SHA_DIGEST_LENGTH,	/* ISSUERSERIALHASH:	SHA1 digest, 160 bits */
	sizeof(X509_NAME *),	/* ISSUER:		X509_NAME * */
	sizeof(BIGNUM *),	/* SERIAL:		BIGNUM * */
	sizeof(X509_NAME *),	/* SUBJECT:		X509_NAME * */
	SHA_DIGEST_LENGTH,	/* CERTHASH:		SHA1 digest, 160 bits */
	-1,			/* EMAIL:		C string */
	-1,			/* FILENAME:		C string */
};

STORE *
STORE_new_method(const STORE_METHOD *method)
{
	STORE *ret;

	if (method == NULL) {
		STOREerr(STORE_F_STORE_NEW_METHOD, ERR_R_PASSED_NULL_PARAMETER);
		return NULL;
	}

	ret = malloc(sizeof(STORE));
	if (ret == NULL) {
		STOREerr(STORE_F_STORE_NEW_METHOD, ERR_R_MALLOC_FAILURE);
		return NULL;
	}

	ret->meth = method;

	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_STORE, ret, &ret->ex_data);
	if (ret->meth->init && !ret->meth->init(ret)) {
		STORE_free(ret);
		ret = NULL;
	}
	return ret;
}

STORE *
STORE_new_engine(ENGINE *engine)
{
	STORE *ret = NULL;
	ENGINE *e = engine;
	const STORE_METHOD *meth = 0;

#ifdef OPENSSL_NO_ENGINE
	e = NULL;
#else
	if (engine) {
		if (!ENGINE_init(engine)) {
			STOREerr(STORE_F_STORE_NEW_ENGINE, ERR_R_ENGINE_LIB);
			return NULL;
		}
		e = engine;
	} else {
		STOREerr(STORE_F_STORE_NEW_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
		return NULL;
	}
	if (e) {
		meth = ENGINE_get_STORE(e);
		if (!meth) {
			STOREerr(STORE_F_STORE_NEW_ENGINE,
			    ERR_R_ENGINE_LIB);
			ENGINE_finish(e);
			return NULL;
		}
	}
#endif

	ret = STORE_new_method(meth);
	if (ret == NULL) {
		STOREerr(STORE_F_STORE_NEW_ENGINE, ERR_R_STORE_LIB);
		return NULL;
	}

	ret->engine = e;

	return (ret);
}

void
STORE_free(STORE *store)
{
	if (store == NULL)
		return;
	if (store->meth->clean)
		store->meth->clean(store);
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_STORE, store, &store->ex_data);
	free(store);
}

int
STORE_ctrl(STORE *store, int cmd, long i, void *p, void (*f)(void))
{
	if (store == NULL) {
		STOREerr(STORE_F_STORE_CTRL, ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (store->meth->ctrl)
		return store->meth->ctrl(store, cmd, i, p, f);
	STOREerr(STORE_F_STORE_CTRL, STORE_R_NO_CONTROL_FUNCTION);
	return 0;
}


int
STORE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_STORE, argl, argp,
	    new_func, dup_func, free_func);
}

int
STORE_set_ex_data(STORE *r, int idx, void *arg)
{
	return (CRYPTO_set_ex_data(&r->ex_data, idx, arg));
}

void *
STORE_get_ex_data(STORE *r, int idx)
{
	return (CRYPTO_get_ex_data(&r->ex_data, idx));
}

const STORE_METHOD *
STORE_get_method(STORE *store)
{
	return store->meth;
}

const STORE_METHOD *
STORE_set_method(STORE *store, const STORE_METHOD *meth)
{
	store->meth = meth;
	return store->meth;
}


/* API helpers */

#define check_store(s,fncode,fnname,fnerrcode) \
	do \
		{ \
		if ((s) == NULL || (s)->meth == NULL) \
			{ \
			STOREerr((fncode), ERR_R_PASSED_NULL_PARAMETER); \
			return 0; \
			} \
		if ((s)->meth->fnname == NULL) \
			{ \
			STOREerr((fncode), (fnerrcode)); \
			return 0; \
			} \
		} \
	while(0)

/* API functions */

X509 *STORE_get_certificate(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	X509 *x;

	check_store(s, STORE_F_STORE_GET_CERTIFICATE,
	    get_object, STORE_R_NO_GET_OBJECT_FUNCTION);

	object = s->meth->get_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,
	    attributes, parameters);
	if (!object || !object->data.x509.certificate) {
		STOREerr(STORE_F_STORE_GET_CERTIFICATE,
		    STORE_R_FAILED_GETTING_CERTIFICATE);
		return 0;
	}
	CRYPTO_add(&object->data.x509.certificate->references,
	    1, CRYPTO_LOCK_X509);
	x = object->data.x509.certificate;
	STORE_OBJECT_free(object);
	return x;
}

int
STORE_store_certificate(STORE *s, X509 *data, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	int i;

	check_store(s, STORE_F_STORE_CERTIFICATE,
	    store_object, STORE_R_NO_STORE_OBJECT_FUNCTION);

	object = STORE_OBJECT_new();
	if (!object) {
		STOREerr(STORE_F_STORE_STORE_CERTIFICATE,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}

	CRYPTO_add(&data->references, 1, CRYPTO_LOCK_X509);
	object->data.x509.certificate = data;

	i = s->meth->store_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,
	    object, attributes, parameters);

	STORE_OBJECT_free(object);

	if (!i) {
		STOREerr(STORE_F_STORE_STORE_CERTIFICATE,
		    STORE_R_FAILED_STORING_CERTIFICATE);
		return 0;
	}
	return 1;
}

int
STORE_modify_certificate(STORE *s, OPENSSL_ITEM search_attributes[],
    OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
    OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_MODIFY_CERTIFICATE,
	    modify_object, STORE_R_NO_MODIFY_OBJECT_FUNCTION);

	if (!s->meth->modify_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,
	    search_attributes, add_attributes, modify_attributes,
	    delete_attributes, parameters)) {
		STOREerr(STORE_F_STORE_MODIFY_CERTIFICATE,
		    STORE_R_FAILED_MODIFYING_CERTIFICATE);
		return 0;
	}
	return 1;
}

int
STORE_revoke_certificate(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_REVOKE_CERTIFICATE,
	    revoke_object, STORE_R_NO_REVOKE_OBJECT_FUNCTION);

	if (!s->meth->revoke_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,
	    attributes, parameters)) {
		STOREerr(STORE_F_STORE_REVOKE_CERTIFICATE,
		    STORE_R_FAILED_REVOKING_CERTIFICATE);
		return 0;
	}
	return 1;
}

int
STORE_delete_certificate(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_DELETE_CERTIFICATE,
	    delete_object, STORE_R_NO_DELETE_OBJECT_FUNCTION);

	if (!s->meth->delete_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,
	    attributes, parameters)) {
		STOREerr(STORE_F_STORE_DELETE_CERTIFICATE,
		    STORE_R_FAILED_DELETING_CERTIFICATE);
		return 0;
	}
	return 1;
}

void *
STORE_list_certificate_start(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	void *handle;

	check_store(s, STORE_F_STORE_LIST_CERTIFICATE_START,
	    list_object_start, STORE_R_NO_LIST_OBJECT_START_FUNCTION);

	handle = s->meth->list_object_start(s,
	    STORE_OBJECT_TYPE_X509_CERTIFICATE, attributes, parameters);
	if (!handle) {
		STOREerr(STORE_F_STORE_LIST_CERTIFICATE_START,
		    STORE_R_FAILED_LISTING_CERTIFICATES);
		return 0;
	}
	return handle;
}

X509 *
STORE_list_certificate_next(STORE *s, void *handle)
{
	STORE_OBJECT *object;
	X509 *x;

	check_store(s, STORE_F_STORE_LIST_CERTIFICATE_NEXT,
	    list_object_next, STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);

	object = s->meth->list_object_next(s, handle);
	if (!object || !object->data.x509.certificate) {
		STOREerr(STORE_F_STORE_LIST_CERTIFICATE_NEXT,
		    STORE_R_FAILED_LISTING_CERTIFICATES);
		return 0;
	}
	CRYPTO_add(&object->data.x509.certificate->references,
	    1, CRYPTO_LOCK_X509);
	x = object->data.x509.certificate;
	STORE_OBJECT_free(object);
	return x;
}

int
STORE_list_certificate_end(STORE *s, void *handle)
{
	check_store(s, STORE_F_STORE_LIST_CERTIFICATE_END,
	    list_object_end, STORE_R_NO_LIST_OBJECT_END_FUNCTION);

	if (!s->meth->list_object_end(s, handle)) {
		STOREerr(STORE_F_STORE_LIST_CERTIFICATE_END,
		    STORE_R_FAILED_LISTING_CERTIFICATES);
		return 0;
	}
	return 1;
}

int
STORE_list_certificate_endp(STORE *s, void *handle)
{
	check_store(s, STORE_F_STORE_LIST_CERTIFICATE_ENDP,
	    list_object_endp, STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);

	if (!s->meth->list_object_endp(s, handle)) {
		STOREerr(STORE_F_STORE_LIST_CERTIFICATE_ENDP,
		    STORE_R_FAILED_LISTING_CERTIFICATES);
		return 0;
	}
	return 1;
}

EVP_PKEY *
STORE_generate_key(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	EVP_PKEY *pkey;

	check_store(s, STORE_F_STORE_GENERATE_KEY,
	    generate_object, STORE_R_NO_GENERATE_OBJECT_FUNCTION);

	object = s->meth->generate_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,
	    attributes, parameters);
	if (!object || !object->data.key) {
		STOREerr(STORE_F_STORE_GENERATE_KEY,
		    STORE_R_FAILED_GENERATING_KEY);
		return 0;
	}
	CRYPTO_add(&object->data.key->references, 1, CRYPTO_LOCK_EVP_PKEY);
	pkey = object->data.key;
	STORE_OBJECT_free(object);
	return pkey;
}

EVP_PKEY *
STORE_get_private_key(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	EVP_PKEY *pkey;

	check_store(s, STORE_F_STORE_GET_PRIVATE_KEY,
	    get_object, STORE_R_NO_GET_OBJECT_FUNCTION);

	object = s->meth->get_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,
	    attributes, parameters);
	if (!object || !object->data.key) {
		STOREerr(STORE_F_STORE_GET_PRIVATE_KEY,
		    STORE_R_FAILED_GETTING_KEY);
		return 0;
	}
	CRYPTO_add(&object->data.key->references, 1, CRYPTO_LOCK_EVP_PKEY);
	pkey = object->data.key;
	STORE_OBJECT_free(object);
	return pkey;
}

int
STORE_store_private_key(STORE *s, EVP_PKEY *data, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	int i;

	check_store(s, STORE_F_STORE_STORE_PRIVATE_KEY,
	    store_object, STORE_R_NO_STORE_OBJECT_FUNCTION);

	object = STORE_OBJECT_new();
	if (!object) {
		STOREerr(STORE_F_STORE_STORE_PRIVATE_KEY,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}
	object->data.key = EVP_PKEY_new();
	if (!object->data.key) {
		STOREerr(STORE_F_STORE_STORE_PRIVATE_KEY,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}

	CRYPTO_add(&data->references, 1, CRYPTO_LOCK_EVP_PKEY);
	object->data.key = data;

	i = s->meth->store_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY, object,
	    attributes, parameters);

	STORE_OBJECT_free(object);

	if (!i) {
		STOREerr(STORE_F_STORE_STORE_PRIVATE_KEY,
		    STORE_R_FAILED_STORING_KEY);
		return 0;
	}
	return i;
}

int
STORE_modify_private_key(STORE *s, OPENSSL_ITEM search_attributes[],
    OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
    OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_MODIFY_PRIVATE_KEY,
	    modify_object, STORE_R_NO_MODIFY_OBJECT_FUNCTION);

	if (!s->meth->modify_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,
	    search_attributes, add_attributes, modify_attributes,
	    delete_attributes, parameters)) {
		STOREerr(STORE_F_STORE_MODIFY_PRIVATE_KEY,
		    STORE_R_FAILED_MODIFYING_PRIVATE_KEY);
		return 0;
	}
	return 1;
}

int
STORE_revoke_private_key(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	int i;

	check_store(s, STORE_F_STORE_REVOKE_PRIVATE_KEY,
	    revoke_object, STORE_R_NO_REVOKE_OBJECT_FUNCTION);

	i = s->meth->revoke_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,
	    attributes, parameters);

	if (!i) {
		STOREerr(STORE_F_STORE_REVOKE_PRIVATE_KEY,
		    STORE_R_FAILED_REVOKING_KEY);
		return 0;
	}
	return i;
}

int
STORE_delete_private_key(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_DELETE_PRIVATE_KEY,
	    delete_object, STORE_R_NO_DELETE_OBJECT_FUNCTION);

	if (!s->meth->delete_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,
	    attributes, parameters)) {
		STOREerr(STORE_F_STORE_DELETE_PRIVATE_KEY,
		    STORE_R_FAILED_DELETING_KEY);
		return 0;
	}
	return 1;
}

void *
STORE_list_private_key_start(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	void *handle;

	check_store(s, STORE_F_STORE_LIST_PRIVATE_KEY_START,
	    list_object_start, STORE_R_NO_LIST_OBJECT_START_FUNCTION);

	handle = s->meth->list_object_start(s, STORE_OBJECT_TYPE_PRIVATE_KEY,
	    attributes, parameters);
	if (!handle) {
		STOREerr(STORE_F_STORE_LIST_PRIVATE_KEY_START,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	return handle;
}

EVP_PKEY *
STORE_list_private_key_next(STORE *s, void *handle)
{
	STORE_OBJECT *object;
	EVP_PKEY *pkey;

	check_store(s, STORE_F_STORE_LIST_PRIVATE_KEY_NEXT,
	    list_object_next, STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);

	object = s->meth->list_object_next(s, handle);
	if (!object || !object->data.key) {
		STOREerr(STORE_F_STORE_LIST_PRIVATE_KEY_NEXT,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	CRYPTO_add(&object->data.key->references, 1, CRYPTO_LOCK_EVP_PKEY);
	pkey = object->data.key;
	STORE_OBJECT_free(object);
	return pkey;
}

int
STORE_list_private_key_end(STORE *s, void *handle)
{
	check_store(s, STORE_F_STORE_LIST_PRIVATE_KEY_END,
	    list_object_end, STORE_R_NO_LIST_OBJECT_END_FUNCTION);

	if (!s->meth->list_object_end(s, handle)) {
		STOREerr(STORE_F_STORE_LIST_PRIVATE_KEY_END,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	return 1;
}

int
STORE_list_private_key_endp(STORE *s, void *handle)
{
	check_store(s, STORE_F_STORE_LIST_PRIVATE_KEY_ENDP,
	    list_object_endp, STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);

	if (!s->meth->list_object_endp(s, handle)) {
		STOREerr(STORE_F_STORE_LIST_PRIVATE_KEY_ENDP,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	return 1;
}

EVP_PKEY *
STORE_get_public_key(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	EVP_PKEY *pkey;

	check_store(s, STORE_F_STORE_GET_PUBLIC_KEY,
	    get_object, STORE_R_NO_GET_OBJECT_FUNCTION);

	object = s->meth->get_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY,
	    attributes, parameters);
	if (!object || !object->data.key) {
		STOREerr(STORE_F_STORE_GET_PUBLIC_KEY,
		    STORE_R_FAILED_GETTING_KEY);
		return 0;
	}
	CRYPTO_add(&object->data.key->references, 1, CRYPTO_LOCK_EVP_PKEY);
	pkey = object->data.key;
	STORE_OBJECT_free(object);
	return pkey;
}

int
STORE_store_public_key(STORE *s, EVP_PKEY *data, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	int i;

	check_store(s, STORE_F_STORE_STORE_PUBLIC_KEY,
	    store_object, STORE_R_NO_STORE_OBJECT_FUNCTION);

	object = STORE_OBJECT_new();
	if (!object) {
		STOREerr(STORE_F_STORE_STORE_PUBLIC_KEY,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}
	object->data.key = EVP_PKEY_new();
	if (!object->data.key) {
		STOREerr(STORE_F_STORE_STORE_PUBLIC_KEY,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}

	CRYPTO_add(&data->references, 1, CRYPTO_LOCK_EVP_PKEY);
	object->data.key = data;

	i = s->meth->store_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY, object,
	    attributes, parameters);

	STORE_OBJECT_free(object);

	if (!i) {
		STOREerr(STORE_F_STORE_STORE_PUBLIC_KEY,
		    STORE_R_FAILED_STORING_KEY);
		return 0;
	}
	return i;
}

int
STORE_modify_public_key(STORE *s, OPENSSL_ITEM search_attributes[],
    OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
    OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_MODIFY_PUBLIC_KEY,
	    modify_object, STORE_R_NO_MODIFY_OBJECT_FUNCTION);

	if (!s->meth->modify_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY,
	    search_attributes, add_attributes, modify_attributes,
	    delete_attributes, parameters)) {
		STOREerr(STORE_F_STORE_MODIFY_PUBLIC_KEY,
		    STORE_R_FAILED_MODIFYING_PUBLIC_KEY);
		return 0;
	}
	return 1;
}

int
STORE_revoke_public_key(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	int i;

	check_store(s, STORE_F_STORE_REVOKE_PUBLIC_KEY,
	    revoke_object, STORE_R_NO_REVOKE_OBJECT_FUNCTION);

	i = s->meth->revoke_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY,
	    attributes, parameters);

	if (!i) {
		STOREerr(STORE_F_STORE_REVOKE_PUBLIC_KEY,
		    STORE_R_FAILED_REVOKING_KEY);
		return 0;
	}
	return i;
}

int
STORE_delete_public_key(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_DELETE_PUBLIC_KEY,
	    delete_object, STORE_R_NO_DELETE_OBJECT_FUNCTION);

	if (!s->meth->delete_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY,
	    attributes, parameters)) {
		STOREerr(STORE_F_STORE_DELETE_PUBLIC_KEY,
		    STORE_R_FAILED_DELETING_KEY);
		return 0;
	}
	return 1;
}

void *
STORE_list_public_key_start(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	void *handle;

	check_store(s, STORE_F_STORE_LIST_PUBLIC_KEY_START,
	    list_object_start, STORE_R_NO_LIST_OBJECT_START_FUNCTION);

	handle = s->meth->list_object_start(s, STORE_OBJECT_TYPE_PUBLIC_KEY,
	    attributes, parameters);
	if (!handle) {
		STOREerr(STORE_F_STORE_LIST_PUBLIC_KEY_START,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	return handle;
}

EVP_PKEY *
STORE_list_public_key_next(STORE *s, void *handle)
{
	STORE_OBJECT *object;
	EVP_PKEY *pkey;

	check_store(s, STORE_F_STORE_LIST_PUBLIC_KEY_NEXT,
	    list_object_next, STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);

	object = s->meth->list_object_next(s, handle);
	if (!object || !object->data.key) {
		STOREerr(STORE_F_STORE_LIST_PUBLIC_KEY_NEXT,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	CRYPTO_add(&object->data.key->references, 1, CRYPTO_LOCK_EVP_PKEY);
	pkey = object->data.key;
	STORE_OBJECT_free(object);
	return pkey;
}

int
STORE_list_public_key_end(STORE *s, void *handle)
{
	check_store(s, STORE_F_STORE_LIST_PUBLIC_KEY_END,
	    list_object_end, STORE_R_NO_LIST_OBJECT_END_FUNCTION);

	if (!s->meth->list_object_end(s, handle)) {
		STOREerr(STORE_F_STORE_LIST_PUBLIC_KEY_END,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	return 1;
}

int
STORE_list_public_key_endp(STORE *s, void *handle)
{
	check_store(s, STORE_F_STORE_LIST_PUBLIC_KEY_ENDP,
	    list_object_endp, STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);

	if (!s->meth->list_object_endp(s, handle)) {
		STOREerr(STORE_F_STORE_LIST_PUBLIC_KEY_ENDP,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	return 1;
}

X509_CRL *
STORE_generate_crl(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	X509_CRL *crl;

	check_store(s, STORE_F_STORE_GENERATE_CRL,
	    generate_object, STORE_R_NO_GENERATE_CRL_FUNCTION);

	object = s->meth->generate_object(s, STORE_OBJECT_TYPE_X509_CRL,
	    attributes, parameters);
	if (!object || !object->data.crl) {
		STOREerr(STORE_F_STORE_GENERATE_CRL,
		    STORE_R_FAILED_GENERATING_CRL);
		return 0;
	}
	CRYPTO_add(&object->data.crl->references, 1, CRYPTO_LOCK_X509_CRL);
	crl = object->data.crl;
	STORE_OBJECT_free(object);
	return crl;
}

X509_CRL *
STORE_get_crl(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	X509_CRL *crl;

	check_store(s, STORE_F_STORE_GET_CRL,
	    get_object, STORE_R_NO_GET_OBJECT_FUNCTION);

	object = s->meth->get_object(s, STORE_OBJECT_TYPE_X509_CRL,
	    attributes, parameters);
	if (!object || !object->data.crl) {
		STOREerr(STORE_F_STORE_GET_CRL,
		    STORE_R_FAILED_GETTING_KEY);
		return 0;
	}
	CRYPTO_add(&object->data.crl->references, 1, CRYPTO_LOCK_X509_CRL);
	crl = object->data.crl;
	STORE_OBJECT_free(object);
	return crl;
}

int
STORE_store_crl(STORE *s, X509_CRL *data, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	int i;

	check_store(s, STORE_F_STORE_STORE_CRL,
	    store_object, STORE_R_NO_STORE_OBJECT_FUNCTION);

	object = STORE_OBJECT_new();
	if (!object) {
		STOREerr(STORE_F_STORE_STORE_CRL,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}

	CRYPTO_add(&data->references, 1, CRYPTO_LOCK_X509_CRL);
	object->data.crl = data;

	i = s->meth->store_object(s, STORE_OBJECT_TYPE_X509_CRL, object,
	    attributes, parameters);

	STORE_OBJECT_free(object);

	if (!i) {
		STOREerr(STORE_F_STORE_STORE_CRL,
		    STORE_R_FAILED_STORING_KEY);
		return 0;
	}
	return i;
}

int
STORE_modify_crl(STORE *s, OPENSSL_ITEM search_attributes[],
    OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
    OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_MODIFY_CRL,
	    modify_object, STORE_R_NO_MODIFY_OBJECT_FUNCTION);

	if (!s->meth->modify_object(s, STORE_OBJECT_TYPE_X509_CRL,
	    search_attributes, add_attributes, modify_attributes,
	    delete_attributes, parameters)) {
		STOREerr(STORE_F_STORE_MODIFY_CRL,
		    STORE_R_FAILED_MODIFYING_CRL);
		return 0;
	}
	return 1;
}

int
STORE_delete_crl(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_DELETE_CRL,
	    delete_object, STORE_R_NO_DELETE_OBJECT_FUNCTION);

	if (!s->meth->delete_object(s, STORE_OBJECT_TYPE_X509_CRL,
	    attributes, parameters)) {
		STOREerr(STORE_F_STORE_DELETE_CRL,
		    STORE_R_FAILED_DELETING_KEY);
		return 0;
	}
	return 1;
}

void *
STORE_list_crl_start(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	void *handle;

	check_store(s, STORE_F_STORE_LIST_CRL_START,
	    list_object_start, STORE_R_NO_LIST_OBJECT_START_FUNCTION);

	handle = s->meth->list_object_start(s, STORE_OBJECT_TYPE_X509_CRL,
	    attributes, parameters);
	if (!handle) {
		STOREerr(STORE_F_STORE_LIST_CRL_START,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	return handle;
}

X509_CRL *
STORE_list_crl_next(STORE *s, void *handle)
{
	STORE_OBJECT *object;
	X509_CRL *crl;

	check_store(s, STORE_F_STORE_LIST_CRL_NEXT,
	    list_object_next, STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);

	object = s->meth->list_object_next(s, handle);
	if (!object || !object->data.crl) {
		STOREerr(STORE_F_STORE_LIST_CRL_NEXT,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	CRYPTO_add(&object->data.crl->references, 1, CRYPTO_LOCK_X509_CRL);
	crl = object->data.crl;
	STORE_OBJECT_free(object);
	return crl;
}

int
STORE_list_crl_end(STORE *s, void *handle)
{
	check_store(s, STORE_F_STORE_LIST_CRL_END,
	    list_object_end, STORE_R_NO_LIST_OBJECT_END_FUNCTION);

	if (!s->meth->list_object_end(s, handle)) {
		STOREerr(STORE_F_STORE_LIST_CRL_END,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	return 1;
}

int
STORE_list_crl_endp(STORE *s, void *handle)
{
	check_store(s, STORE_F_STORE_LIST_CRL_ENDP,
	    list_object_endp, STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);

	if (!s->meth->list_object_endp(s, handle)) {
		STOREerr(STORE_F_STORE_LIST_CRL_ENDP,
		    STORE_R_FAILED_LISTING_KEYS);
		return 0;
	}
	return 1;
}

int
STORE_store_number(STORE *s, BIGNUM *data, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	int i;

	check_store(s, STORE_F_STORE_STORE_NUMBER,
	    store_object, STORE_R_NO_STORE_OBJECT_NUMBER_FUNCTION);

	object = STORE_OBJECT_new();
	if (!object) {
		STOREerr(STORE_F_STORE_STORE_NUMBER,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}

	object->data.number = data;

	i = s->meth->store_object(s, STORE_OBJECT_TYPE_NUMBER, object,
	    attributes, parameters);

	STORE_OBJECT_free(object);

	if (!i) {
		STOREerr(STORE_F_STORE_STORE_NUMBER,
		    STORE_R_FAILED_STORING_NUMBER);
		return 0;
	}
	return 1;
}

int
STORE_modify_number(STORE *s, OPENSSL_ITEM search_attributes[],
    OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
    OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_MODIFY_NUMBER,
	    modify_object, STORE_R_NO_MODIFY_OBJECT_FUNCTION);

	if (!s->meth->modify_object(s, STORE_OBJECT_TYPE_NUMBER,
	    search_attributes, add_attributes, modify_attributes,
	    delete_attributes, parameters)) {
		STOREerr(STORE_F_STORE_MODIFY_NUMBER,
		    STORE_R_FAILED_MODIFYING_NUMBER);
		return 0;
	}
	return 1;
}

BIGNUM *
STORE_get_number(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	BIGNUM *n;

	check_store(s, STORE_F_STORE_GET_NUMBER,
	    get_object, STORE_R_NO_GET_OBJECT_NUMBER_FUNCTION);

	object = s->meth->get_object(s, STORE_OBJECT_TYPE_NUMBER, attributes,
	    parameters);
	if (!object || !object->data.number) {
		STOREerr(STORE_F_STORE_GET_NUMBER,
		    STORE_R_FAILED_GETTING_NUMBER);
		return 0;
	}
	n = object->data.number;
	object->data.number = NULL;
	STORE_OBJECT_free(object);
	return n;
}

int
STORE_delete_number(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_DELETE_NUMBER,
	    delete_object, STORE_R_NO_DELETE_NUMBER_FUNCTION);

	if (!s->meth->delete_object(s, STORE_OBJECT_TYPE_NUMBER, attributes,
	    parameters)) {
		STOREerr(STORE_F_STORE_DELETE_NUMBER,
		    STORE_R_FAILED_DELETING_NUMBER);
		return 0;
	}
	return 1;
}

int
STORE_store_arbitrary(STORE *s, BUF_MEM *data, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	int i;

	check_store(s, STORE_F_STORE_STORE_ARBITRARY,
	    store_object, STORE_R_NO_STORE_OBJECT_ARBITRARY_FUNCTION);

	object = STORE_OBJECT_new();
	if (!object) {
		STOREerr(STORE_F_STORE_STORE_ARBITRARY,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}

	object->data.arbitrary = data;

	i = s->meth->store_object(s, STORE_OBJECT_TYPE_ARBITRARY, object,
	    attributes, parameters);

	STORE_OBJECT_free(object);

	if (!i) {
		STOREerr(STORE_F_STORE_STORE_ARBITRARY,
		    STORE_R_FAILED_STORING_ARBITRARY);
		return 0;
	}
	return 1;
}

int
STORE_modify_arbitrary(STORE *s, OPENSSL_ITEM search_attributes[],
    OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
    OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_MODIFY_ARBITRARY,
	    modify_object, STORE_R_NO_MODIFY_OBJECT_FUNCTION);

	if (!s->meth->modify_object(s, STORE_OBJECT_TYPE_ARBITRARY,
	    search_attributes, add_attributes, modify_attributes,
	    delete_attributes, parameters)) {
		STOREerr(STORE_F_STORE_MODIFY_ARBITRARY,
		    STORE_R_FAILED_MODIFYING_ARBITRARY);
		return 0;
	}
	return 1;
}

BUF_MEM *
STORE_get_arbitrary(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	STORE_OBJECT *object;
	BUF_MEM *b;

	check_store(s, STORE_F_STORE_GET_ARBITRARY,
	    get_object, STORE_R_NO_GET_OBJECT_ARBITRARY_FUNCTION);

	object = s->meth->get_object(s, STORE_OBJECT_TYPE_ARBITRARY,
	    attributes, parameters);
	if (!object || !object->data.arbitrary) {
		STOREerr(STORE_F_STORE_GET_ARBITRARY,
		    STORE_R_FAILED_GETTING_ARBITRARY);
		return 0;
	}
	b = object->data.arbitrary;
	object->data.arbitrary = NULL;
	STORE_OBJECT_free(object);
	return b;
}

int
STORE_delete_arbitrary(STORE *s, OPENSSL_ITEM attributes[],
    OPENSSL_ITEM parameters[])
{
	check_store(s, STORE_F_STORE_DELETE_ARBITRARY,
	    delete_object, STORE_R_NO_DELETE_ARBITRARY_FUNCTION);

	if (!s->meth->delete_object(s, STORE_OBJECT_TYPE_ARBITRARY, attributes,
	    parameters)) {
		STOREerr(STORE_F_STORE_DELETE_ARBITRARY,
		    STORE_R_FAILED_DELETING_ARBITRARY);
		return 0;
	}
	return 1;
}

STORE_OBJECT *
STORE_OBJECT_new(void)
{
	return calloc(1, sizeof(STORE_OBJECT));
}

void
STORE_OBJECT_free(STORE_OBJECT *data)
{
	if (!data)
		return;
	switch (data->type) {
	case STORE_OBJECT_TYPE_X509_CERTIFICATE:
		X509_free(data->data.x509.certificate);
		break;
	case STORE_OBJECT_TYPE_X509_CRL:
		X509_CRL_free(data->data.crl);
		break;
	case STORE_OBJECT_TYPE_PRIVATE_KEY:
	case STORE_OBJECT_TYPE_PUBLIC_KEY:
		EVP_PKEY_free(data->data.key);
		break;
	case STORE_OBJECT_TYPE_NUMBER:
		BN_free(data->data.number);
		break;
	case STORE_OBJECT_TYPE_ARBITRARY:
		BUF_MEM_free(data->data.arbitrary);
		break;
	}
	free(data);
}

IMPLEMENT_STACK_OF(STORE_OBJECT*)


struct STORE_attr_info_st {
	unsigned char set[(STORE_ATTR_TYPE_NUM + 8) / 8];
	union {
		char *cstring;
		unsigned char *sha1string;
		X509_NAME *dn;
		BIGNUM *number;
		void *any;
	} values[STORE_ATTR_TYPE_NUM + 1];
	size_t value_sizes[STORE_ATTR_TYPE_NUM + 1];
};

#define ATTR_IS_SET(a,i)	((i) > 0 && (i) < STORE_ATTR_TYPE_NUM \
				&& ((a)->set[(i) / 8] & (1 << ((i) % 8))))
#define SET_ATTRBIT(a,i)	((a)->set[(i) / 8] |= (1 << ((i) % 8)))
#define CLEAR_ATTRBIT(a,i)	((a)->set[(i) / 8] &= ~(1 << ((i) % 8)))

STORE_ATTR_INFO *
STORE_ATTR_INFO_new(void)
{
	return malloc(sizeof(STORE_ATTR_INFO));
}

static void
STORE_ATTR_INFO_attr_free(STORE_ATTR_INFO *attrs,
    STORE_ATTR_TYPES code)
{
	if (ATTR_IS_SET(attrs, code)) {
		switch (code) {
		case STORE_ATTR_FRIENDLYNAME:
		case STORE_ATTR_EMAIL:
		case STORE_ATTR_FILENAME:
			STORE_ATTR_INFO_modify_cstr(attrs, code, NULL, 0);
			break;
		case STORE_ATTR_KEYID:
		case STORE_ATTR_ISSUERKEYID:
		case STORE_ATTR_SUBJECTKEYID:
		case STORE_ATTR_ISSUERSERIALHASH:
		case STORE_ATTR_CERTHASH:
			STORE_ATTR_INFO_modify_sha1str(attrs, code, NULL, 0);
			break;
		case STORE_ATTR_ISSUER:
		case STORE_ATTR_SUBJECT:
			STORE_ATTR_INFO_modify_dn(attrs, code, NULL);
			break;
		case STORE_ATTR_SERIAL:
			STORE_ATTR_INFO_modify_number(attrs, code, NULL);
			break;
		default:
			break;
		}
	}
}

int
STORE_ATTR_INFO_free(STORE_ATTR_INFO *attrs)
{
	if (attrs) {
		STORE_ATTR_TYPES i;
		for (i = 0; i++ < STORE_ATTR_TYPE_NUM; )
			STORE_ATTR_INFO_attr_free(attrs, i);
		free(attrs);
	}
	return 1;
}

char *
STORE_ATTR_INFO_get0_cstr(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_GET0_CSTR,
		    ERR_R_PASSED_NULL_PARAMETER);
		return NULL;
	}
	if (ATTR_IS_SET(attrs, code))
		return attrs->values[code].cstring;
	STOREerr(STORE_F_STORE_ATTR_INFO_GET0_CSTR, STORE_R_NO_VALUE);
	return NULL;
}

unsigned char *
STORE_ATTR_INFO_get0_sha1str(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_GET0_SHA1STR,
		    ERR_R_PASSED_NULL_PARAMETER);
		return NULL;
	}
	if (ATTR_IS_SET(attrs, code))
		return attrs->values[code].sha1string;
	STOREerr(STORE_F_STORE_ATTR_INFO_GET0_SHA1STR, STORE_R_NO_VALUE);
	return NULL;
}

X509_NAME *
STORE_ATTR_INFO_get0_dn(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_GET0_DN,
		    ERR_R_PASSED_NULL_PARAMETER);
		return NULL;
	}
	if (ATTR_IS_SET(attrs, code))
		return attrs->values[code].dn;
	STOREerr(STORE_F_STORE_ATTR_INFO_GET0_DN, STORE_R_NO_VALUE);
	return NULL;
}

BIGNUM *
STORE_ATTR_INFO_get0_number(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_GET0_NUMBER,
		    ERR_R_PASSED_NULL_PARAMETER);
		return NULL;
	}
	if (ATTR_IS_SET(attrs, code))
		return attrs->values[code].number;
	STOREerr(STORE_F_STORE_ATTR_INFO_GET0_NUMBER, STORE_R_NO_VALUE);
	return NULL;
}

int
STORE_ATTR_INFO_set_cstr(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
    char *cstr, size_t cstr_size)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_SET_CSTR,
		    ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (!ATTR_IS_SET(attrs, code)) {
		if ((attrs->values[code].cstring = strndup(cstr, cstr_size)))
			return 1;
		STOREerr(STORE_F_STORE_ATTR_INFO_SET_CSTR,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}
	STOREerr(STORE_F_STORE_ATTR_INFO_SET_CSTR, STORE_R_ALREADY_HAS_A_VALUE);
	return 0;
}

int
STORE_ATTR_INFO_set_sha1str(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
    unsigned char *sha1str, size_t sha1str_size)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_SET_SHA1STR,
		    ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (!ATTR_IS_SET(attrs, code)) {
		if ((attrs->values[code].sha1string =
		    (unsigned char *)BUF_memdup(sha1str,
		    sha1str_size)))
			return 1;
		STOREerr(STORE_F_STORE_ATTR_INFO_SET_SHA1STR,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}
	STOREerr(STORE_F_STORE_ATTR_INFO_SET_SHA1STR,
	    STORE_R_ALREADY_HAS_A_VALUE);
	return 0;
}

int
STORE_ATTR_INFO_set_dn(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
    X509_NAME *dn)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_SET_DN,
		    ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (!ATTR_IS_SET(attrs, code)) {
		if ((attrs->values[code].dn = X509_NAME_dup(dn)))
			return 1;
		STOREerr(STORE_F_STORE_ATTR_INFO_SET_DN,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}
	STOREerr(STORE_F_STORE_ATTR_INFO_SET_DN, STORE_R_ALREADY_HAS_A_VALUE);
	return 0;
}

int
STORE_ATTR_INFO_set_number(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
    BIGNUM *number)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_SET_NUMBER,
		    ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (!ATTR_IS_SET(attrs, code)) {
		if ((attrs->values[code].number = BN_dup(number)))
			return 1;
		STOREerr(STORE_F_STORE_ATTR_INFO_SET_NUMBER,
		    ERR_R_MALLOC_FAILURE);
		return 0;
	}
	STOREerr(STORE_F_STORE_ATTR_INFO_SET_NUMBER,
	    STORE_R_ALREADY_HAS_A_VALUE);
	return 0;
}

int
STORE_ATTR_INFO_modify_cstr(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
    char *cstr, size_t cstr_size)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_MODIFY_CSTR,
		    ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (ATTR_IS_SET(attrs, code)) {
		free(attrs->values[code].cstring);
		attrs->values[code].cstring = NULL;
		CLEAR_ATTRBIT(attrs, code);
	}
	return STORE_ATTR_INFO_set_cstr(attrs, code, cstr, cstr_size);
}

int
STORE_ATTR_INFO_modify_sha1str(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
    unsigned char *sha1str, size_t sha1str_size)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_MODIFY_SHA1STR,
		    ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (ATTR_IS_SET(attrs, code)) {
		free(attrs->values[code].sha1string);
		attrs->values[code].sha1string = NULL;
		CLEAR_ATTRBIT(attrs, code);
	}
	return STORE_ATTR_INFO_set_sha1str(attrs, code, sha1str, sha1str_size);
}

int
STORE_ATTR_INFO_modify_dn(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
    X509_NAME *dn)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_MODIFY_DN,
		    ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (ATTR_IS_SET(attrs, code)) {
		free(attrs->values[code].dn);
		attrs->values[code].dn = NULL;
		CLEAR_ATTRBIT(attrs, code);
	}
	return STORE_ATTR_INFO_set_dn(attrs, code, dn);
}

int
STORE_ATTR_INFO_modify_number(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
    BIGNUM *number)
{
	if (!attrs) {
		STOREerr(STORE_F_STORE_ATTR_INFO_MODIFY_NUMBER,
		    ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (ATTR_IS_SET(attrs, code)) {
		free(attrs->values[code].number);
		attrs->values[code].number = NULL;
		CLEAR_ATTRBIT(attrs, code);
	}
	return STORE_ATTR_INFO_set_number(attrs, code, number);
}

struct attr_list_ctx_st {
	OPENSSL_ITEM *attributes;
};

void *
STORE_parse_attrs_start(OPENSSL_ITEM *attributes)
{
	if (attributes) {
		struct attr_list_ctx_st *context =
		    malloc(sizeof(struct attr_list_ctx_st));

		if (context)
			context->attributes = attributes;
		else
			STOREerr(STORE_F_STORE_PARSE_ATTRS_START,
			    ERR_R_MALLOC_FAILURE);
		return context;
	}
	STOREerr(STORE_F_STORE_PARSE_ATTRS_START, ERR_R_PASSED_NULL_PARAMETER);
	return 0;
}

STORE_ATTR_INFO *
STORE_parse_attrs_next(void *handle)
{
	struct attr_list_ctx_st *context = (struct attr_list_ctx_st *)handle;

	if (context && context->attributes) {
		STORE_ATTR_INFO *attrs = NULL;

		while (context->attributes &&
		    context->attributes->code != STORE_ATTR_OR &&
		    context->attributes->code != STORE_ATTR_END) {
			switch (context->attributes->code) {
			case STORE_ATTR_FRIENDLYNAME:
			case STORE_ATTR_EMAIL:
			case STORE_ATTR_FILENAME:
				if (!attrs)
					attrs = STORE_ATTR_INFO_new();
				if (attrs == NULL) {
					STOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT,
					    ERR_R_MALLOC_FAILURE);
					goto err;
				}
				STORE_ATTR_INFO_set_cstr(attrs,
				    context->attributes->code,
				    context->attributes->value,
				    context->attributes->value_size);
				break;
			case STORE_ATTR_KEYID:
			case STORE_ATTR_ISSUERKEYID:
			case STORE_ATTR_SUBJECTKEYID:
			case STORE_ATTR_ISSUERSERIALHASH:
			case STORE_ATTR_CERTHASH:
				if (!attrs)
					attrs = STORE_ATTR_INFO_new();
				if (attrs == NULL) {
					STOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT,
					    ERR_R_MALLOC_FAILURE);
					goto err;
				}
				STORE_ATTR_INFO_set_sha1str(attrs,
				    context->attributes->code,
				    context->attributes->value,
				    context->attributes->value_size);
				break;
			case STORE_ATTR_ISSUER:
			case STORE_ATTR_SUBJECT:
				if (!attrs)
					attrs = STORE_ATTR_INFO_new();
				if (attrs == NULL) {
					STOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT,
					    ERR_R_MALLOC_FAILURE);
					goto err;
				}
				STORE_ATTR_INFO_modify_dn(attrs,
				    context->attributes->code,
				    context->attributes->value);
				break;
			case STORE_ATTR_SERIAL:
				if (!attrs)
					attrs = STORE_ATTR_INFO_new();
				if (attrs == NULL) {
					STOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT,
					    ERR_R_MALLOC_FAILURE);
					goto err;
				}
				STORE_ATTR_INFO_modify_number(attrs,
				    context->attributes->code,
				    context->attributes->value);
				break;
			}
			context->attributes++;
		}
		if (context->attributes->code == STORE_ATTR_OR)
			context->attributes++;
		return attrs;

err:
		while (context->attributes &&
		    context->attributes->code != STORE_ATTR_OR &&
		    context->attributes->code != STORE_ATTR_END)
			context->attributes++;
		if (context->attributes->code == STORE_ATTR_OR)
			context->attributes++;
		return NULL;
	}
	STOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT, ERR_R_PASSED_NULL_PARAMETER);
	return NULL;
}

int
STORE_parse_attrs_end(void *handle)
{
	struct attr_list_ctx_st *context = (struct attr_list_ctx_st *)handle;

	if (context && context->attributes) {
#if 0
		OPENSSL_ITEM *attributes = context->attributes;
#endif
		free(context);
		return 1;
	}
	STOREerr(STORE_F_STORE_PARSE_ATTRS_END, ERR_R_PASSED_NULL_PARAMETER);
	return 0;
}

int
STORE_parse_attrs_endp(void *handle)
{
	struct attr_list_ctx_st *context = (struct attr_list_ctx_st *)handle;

	if (context && context->attributes) {
		return context->attributes->code == STORE_ATTR_END;
	}
	STOREerr(STORE_F_STORE_PARSE_ATTRS_ENDP, ERR_R_PASSED_NULL_PARAMETER);
	return 0;
}

static int
attr_info_compare_compute_range(const unsigned char *abits,
    const unsigned char *bbits, unsigned int *alowp, unsigned int *ahighp,
    unsigned int *blowp, unsigned int *bhighp)
{
	unsigned int alow = (unsigned int) - 1, ahigh = 0;
	unsigned int blow = (unsigned int) - 1, bhigh = 0;
	int i, res = 0;

	for (i = 0; i < (STORE_ATTR_TYPE_NUM + 8) / 8; i++, abits++, bbits++) {
		if (res == 0) {
			if (*abits < *bbits)
				res = -1;
			if (*abits > *bbits)
				res = 1;
		}
		if (*abits) {
			if (alow == (unsigned int) - 1) {
				alow = i * 8;
				if (!(*abits & 0x01))
					alow++;
				if (!(*abits & 0x02))
					alow++;
				if (!(*abits & 0x04))
					alow++;
				if (!(*abits & 0x08))
					alow++;
				if (!(*abits & 0x10))
					alow++;
				if (!(*abits & 0x20))
					alow++;
				if (!(*abits & 0x40))
					alow++;
			}
			ahigh = i * 8 + 7;
			if (!(*abits & 0x80))
				ahigh++;
			if (!(*abits & 0x40))
				ahigh++;
			if (!(*abits & 0x20))
				ahigh++;
			if (!(*abits & 0x10))
				ahigh++;
			if (!(*abits & 0x08))
				ahigh++;
			if (!(*abits & 0x04))
				ahigh++;
			if (!(*abits & 0x02))
				ahigh++;
		}
		if (*bbits) {
			if (blow == (unsigned int) - 1) {
				blow = i * 8;
				if (!(*bbits & 0x01))
					blow++;
				if (!(*bbits & 0x02))
					blow++;
				if (!(*bbits & 0x04))
					blow++;
				if (!(*bbits & 0x08))
					blow++;
				if (!(*bbits & 0x10))
					blow++;
				if (!(*bbits & 0x20))
					blow++;
				if (!(*bbits & 0x40))
					blow++;
			}
			bhigh = i * 8 + 7;
			if (!(*bbits & 0x80))
				bhigh++;
			if (!(*bbits & 0x40))
				bhigh++;
			if (!(*bbits & 0x20))
				bhigh++;
			if (!(*bbits & 0x10))
				bhigh++;
			if (!(*bbits & 0x08))
				bhigh++;
			if (!(*bbits & 0x04))
				bhigh++;
			if (!(*bbits & 0x02))
				bhigh++;
		}
	}
	if (ahigh + alow < bhigh + blow)
		res = -1;
	if (ahigh + alow > bhigh + blow)
		res = 1;
	if (alowp)
		*alowp = alow;
	if (ahighp)
		*ahighp = ahigh;
	if (blowp)
		*blowp = blow;
	if (bhighp)
		*bhighp = bhigh;
	return res;
}

int
STORE_ATTR_INFO_compare(const STORE_ATTR_INFO * const *a,
    const STORE_ATTR_INFO * const *b)
{
	if (a == b)
		return 0;
	if (!a)
		return -1;
	if (!b)
		return 1;
	return attr_info_compare_compute_range((*a)->set, (*b)->set,
	    0, 0, 0, 0);
}

int
STORE_ATTR_INFO_in_range(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)
{
	unsigned int alow, ahigh, blow, bhigh;

	if (a == b)
		return 1;
	if (!a)
		return 0;
	if (!b)
		return 0;
	attr_info_compare_compute_range(a->set, b->set,
	    &alow, &ahigh, &blow, &bhigh);
	if (alow >= blow && ahigh <= bhigh)
		return 1;
	return 0;
}

int
STORE_ATTR_INFO_in(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)
{
	unsigned char *abits, *bbits;
	int i;

	if (a == b)
		return 1;
	if (!a)
		return 0;
	if (!b)
		return 0;
	abits = a->set;
	bbits = b->set;
	for (i = 0; i < (STORE_ATTR_TYPE_NUM + 8) / 8; i++, abits++, bbits++) {
		if (*abits && (*bbits & *abits) != *abits)
			return 0;
	}
	return 1;
}

int
STORE_ATTR_INFO_in_ex(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)
{
	STORE_ATTR_TYPES i;

	if (a == b)
		return 1;
	if (!STORE_ATTR_INFO_in(a, b))
		return 0;
	for (i = 1; i < STORE_ATTR_TYPE_NUM; i++)
		if (ATTR_IS_SET(a, i)) {
			switch (i) {
			case STORE_ATTR_FRIENDLYNAME:
			case STORE_ATTR_EMAIL:
			case STORE_ATTR_FILENAME:
				if (strcmp(a->values[i].cstring,
				    b->values[i].cstring))
					return 0;
				break;
			case STORE_ATTR_KEYID:
			case STORE_ATTR_ISSUERKEYID:
			case STORE_ATTR_SUBJECTKEYID:
			case STORE_ATTR_ISSUERSERIALHASH:
			case STORE_ATTR_CERTHASH:
				if (memcmp(a->values[i].sha1string,
				    b->values[i].sha1string,
				    a->value_sizes[i]))
					return 0;
				break;
			case STORE_ATTR_ISSUER:
			case STORE_ATTR_SUBJECT:
				if (X509_NAME_cmp(a->values[i].dn,
				    b->values[i].dn))
					return 0;
				break;
			case STORE_ATTR_SERIAL:
				if (BN_cmp(a->values[i].number,
				    b->values[i].number))
					return 0;
				break;
			default:
				break;
			}
		}

	return 1;
}
@


1.12
log
@further BUF_strdup conversion: these places should be safe to rely on
the function argument not being NULL
@
text
@d1 1
a1 1
/* $OpenBSD: str_lib.c,v 1.11 2014/10/16 03:19:02 beck Exp $ */
@


1.11
log
@Get rid of the last remaining BUF_strdup and BUF_strlcpy and friends, use
intrinsic functions everywhere, and wrap these functions in an
#ifndef LIBRESSL_INTERNAL to make sure we don't bring their use back.
@
text
@d1 1
a1 1
/* $OpenBSD: str_lib.c,v 1.10 2014/07/10 22:45:58 jsing Exp $ */
d1344 1
a1344 1
		if (cstr && (attrs->values[code].cstring = strndup(cstr, cstr_size)))
@


1.10
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: str_lib.c,v 1.9 2014/06/12 15:49:30 deraadt Exp $ */
d1344 1
a1344 1
		if ((attrs->values[code].cstring = BUF_strndup(cstr, cstr_size)))
@


1.9
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 3
@


1.8
log
@c-file-style hints, begone; ok beck
@
text
@d1 1
a1 1
/* crypto/store/str_lib.c */
@


1.7
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/store/str_lib.c -*- mode:C; c-file-style: "eay" -*- */
@


1.6
log
@use calloc, from Benjamin Baier
@
text
@d112 1
a112 1
	ret = (STORE *)malloc(sizeof(STORE));
d1229 1
a1229 1
	return (STORE_ATTR_INFO *)malloc(sizeof(STORE_ATTR_INFO));
d1492 2
a1493 1
		    (struct attr_list_ctx_st *)malloc(sizeof(struct attr_list_ctx_st));
@


1.5
log
@KNF.
@
text
@d1177 1
a1177 5
	STORE_OBJECT *object = malloc(sizeof(STORE_OBJECT));

	if (object)
		memset(object, 0, sizeof(STORE_OBJECT));
	return object;
@


1.4
log
@kill REF_PRINT/REF_CHECK debugging framework noone would use
ok miod
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d69 1
a69 2
const char * const STORE_object_type_string[STORE_OBJECT_TYPE_NUM+1] =
	{
d77 1
a77 1
	};
d79 1
a79 2
const int STORE_param_sizes[STORE_PARAM_TYPE_NUM+1] =
	{
d85 1
a85 1
	};	
d87 1
a87 2
const int STORE_attr_sizes[STORE_ATTR_TYPE_NUM+1] =
	{
d100 1
a100 1
	};	
d102 3
a104 2
STORE *STORE_new_method(const STORE_METHOD *method)
	{
d107 2
a108 3
	if (method == NULL)
		{
		STOREerr(STORE_F_STORE_NEW_METHOD,ERR_R_PASSED_NULL_PARAMETER);
d110 1
a110 1
		}
d112 3
a114 4
	ret=(STORE *)malloc(sizeof(STORE));
	if (ret == NULL)
		{
		STOREerr(STORE_F_STORE_NEW_METHOD,ERR_R_MALLOC_FAILURE);
d116 1
a116 1
		}
d118 1
a118 1
	ret->meth=method;
d121 1
a121 2
	if (ret->meth->init && !ret->meth->init(ret))
		{
d124 1
a124 1
		}
d126 1
a126 1
	}
d128 3
a130 2
STORE *STORE_new_engine(ENGINE *engine)
	{
d138 2
a139 4
	if (engine)
		{
		if (!ENGINE_init(engine))
			{
d142 1
a142 1
			}
d144 2
a145 4
		}
	else
		{
		STOREerr(STORE_F_STORE_NEW_ENGINE,ERR_R_PASSED_NULL_PARAMETER);
d147 2
a148 3
		}
	if(e)
		{
d150 1
a150 2
		if(!meth)
			{
d152 1
a152 1
				ERR_R_ENGINE_LIB);
a154 1
			}
d156 1
d160 2
a161 3
	if (ret == NULL)
		{
		STOREerr(STORE_F_STORE_NEW_ENGINE,ERR_R_STORE_LIB);
d163 1
a163 1
		}
d167 2
a168 2
	return(ret);
	}
d170 3
a172 2
void STORE_free(STORE *store)
	{
d179 1
a179 1
	}
d181 5
a185 5
int STORE_ctrl(STORE *store, int cmd, long i, void *p, void (*f)(void))
	{
	if (store == NULL)
		{
		STOREerr(STORE_F_STORE_CTRL,ERR_R_PASSED_NULL_PARAMETER);
d187 1
a187 1
		}
d190 1
a190 1
	STOREerr(STORE_F_STORE_CTRL,STORE_R_NO_CONTROL_FUNCTION);
d192 1
a192 1
	}
d195 4
a198 3
int STORE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
        {
d200 2
a201 12
				new_func, dup_func, free_func);
        }

int STORE_set_ex_data(STORE *r, int idx, void *arg)
	{
	return(CRYPTO_set_ex_data(&r->ex_data,idx,arg));
	}

void *STORE_get_ex_data(STORE *r, int idx)
	{
	return(CRYPTO_get_ex_data(&r->ex_data,idx));
	}
d203 15
a217 2
const STORE_METHOD *STORE_get_method(STORE *store)
	{
d219 1
a219 1
	}
d221 4
a224 3
const STORE_METHOD *STORE_set_method(STORE *store, const STORE_METHOD *meth)
	{
	store->meth=meth;
d226 1
a226 1
	}
d250 2
a251 2
	OPENSSL_ITEM parameters[])
	{
d255 2
a256 2
	check_store(s,STORE_F_STORE_GET_CERTIFICATE,
		get_object,STORE_R_NO_GET_OBJECT_FUNCTION);
d259 2
a260 3
		attributes, parameters);
	if (!object || !object->data.x509.certificate)
		{
d262 1
a262 1
			STORE_R_FAILED_GETTING_CERTIFICATE);
d264 3
a266 2
		}
	CRYPTO_add(&object->data.x509.certificate->references,1,CRYPTO_LOCK_X509);
d270 1
a270 1
	}
d272 4
a275 3
int STORE_store_certificate(STORE *s, X509 *data, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d279 2
a280 2
	check_store(s,STORE_F_STORE_CERTIFICATE,
		store_object,STORE_R_NO_STORE_OBJECT_FUNCTION);
d283 1
a283 2
	if (!object)
		{
d285 1
a285 1
			ERR_R_MALLOC_FAILURE);
d287 3
a289 3
		}
	
	CRYPTO_add(&data->references,1,CRYPTO_LOCK_X509);
d293 1
a293 1
		object, attributes, parameters);
d297 1
a297 2
	if (!i)
		{
d299 1
a299 1
			STORE_R_FAILED_STORING_CERTIFICATE);
d301 1
a301 1
		}
d303 1
a303 1
	}
d305 7
a311 6
int STORE_modify_certificate(STORE *s, OPENSSL_ITEM search_attributes[],
	OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
	OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_MODIFY_CERTIFICATE,
		modify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);
d314 2
a315 3
		    search_attributes, add_attributes, modify_attributes,
		    delete_attributes, parameters))
		{
d317 1
a317 1
			STORE_R_FAILED_MODIFYING_CERTIFICATE);
d319 1
a319 1
		}
d321 1
a321 1
	}
d323 6
a328 5
int STORE_revoke_certificate(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_REVOKE_CERTIFICATE,
		revoke_object,STORE_R_NO_REVOKE_OBJECT_FUNCTION);
d331 1
a331 2
		    attributes, parameters))
		{
d333 1
a333 1
			STORE_R_FAILED_REVOKING_CERTIFICATE);
d335 1
a335 1
		}
d337 1
a337 1
	}
d339 6
a344 5
int STORE_delete_certificate(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_DELETE_CERTIFICATE,
		delete_object,STORE_R_NO_DELETE_OBJECT_FUNCTION);
d347 1
a347 2
		    attributes, parameters))
		{
d349 1
a349 1
			STORE_R_FAILED_DELETING_CERTIFICATE);
d351 1
a351 1
		}
d353 1
a353 1
	}
d355 4
a358 3
void *STORE_list_certificate_start(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d361 2
a362 2
	check_store(s,STORE_F_STORE_LIST_CERTIFICATE_START,
		list_object_start,STORE_R_NO_LIST_OBJECT_START_FUNCTION);
d365 2
a366 3
		STORE_OBJECT_TYPE_X509_CERTIFICATE, attributes, parameters);
	if (!handle)
		{
d368 1
a368 1
			STORE_R_FAILED_LISTING_CERTIFICATES);
d370 1
a370 1
		}
d372 1
a372 1
	}
d374 3
a376 2
X509 *STORE_list_certificate_next(STORE *s, void *handle)
	{
d380 2
a381 2
	check_store(s,STORE_F_STORE_LIST_CERTIFICATE_NEXT,
		list_object_next,STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);
d384 1
a384 2
	if (!object || !object->data.x509.certificate)
		{
d386 1
a386 1
			STORE_R_FAILED_LISTING_CERTIFICATES);
d388 3
a390 2
		}
	CRYPTO_add(&object->data.x509.certificate->references,1,CRYPTO_LOCK_X509);
d394 1
a394 1
	}
d396 5
a400 4
int STORE_list_certificate_end(STORE *s, void *handle)
	{
	check_store(s,STORE_F_STORE_LIST_CERTIFICATE_END,
		list_object_end,STORE_R_NO_LIST_OBJECT_END_FUNCTION);
d402 1
a402 2
	if (!s->meth->list_object_end(s, handle))
		{
d404 1
a404 1
			STORE_R_FAILED_LISTING_CERTIFICATES);
d406 1
a406 1
		}
d408 1
a408 1
	}
d410 5
a414 4
int STORE_list_certificate_endp(STORE *s, void *handle)
	{
	check_store(s,STORE_F_STORE_LIST_CERTIFICATE_ENDP,
		list_object_endp,STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);
d416 1
a416 2
	if (!s->meth->list_object_endp(s, handle))
		{
d418 1
a418 1
			STORE_R_FAILED_LISTING_CERTIFICATES);
d420 1
a420 1
		}
d422 1
a422 1
	}
d424 4
a427 3
EVP_PKEY *STORE_generate_key(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d431 2
a432 2
	check_store(s,STORE_F_STORE_GENERATE_KEY,
		generate_object,STORE_R_NO_GENERATE_OBJECT_FUNCTION);
d435 2
a436 3
		attributes, parameters);
	if (!object || !object->data.key)
		{
d438 1
a438 1
			STORE_R_FAILED_GENERATING_KEY);
d440 2
a441 2
		}
	CRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);
d445 1
a445 1
	}
d447 4
a450 3
EVP_PKEY *STORE_get_private_key(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d454 2
a455 2
	check_store(s,STORE_F_STORE_GET_PRIVATE_KEY,
		get_object,STORE_R_NO_GET_OBJECT_FUNCTION);
d458 2
a459 3
		attributes, parameters);
	if (!object || !object->data.key)
		{
d461 1
a461 1
			STORE_R_FAILED_GETTING_KEY);
d463 2
a464 2
		}
	CRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);
d468 1
a468 1
	}
d470 4
a473 3
int STORE_store_private_key(STORE *s, EVP_PKEY *data, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d477 2
a478 2
	check_store(s,STORE_F_STORE_STORE_PRIVATE_KEY,
		store_object,STORE_R_NO_STORE_OBJECT_FUNCTION);
d481 1
a481 2
	if (!object)
		{
d483 1
a483 1
			ERR_R_MALLOC_FAILURE);
d485 1
a485 1
		}
d487 1
a487 2
	if (!object->data.key)
		{
d489 1
a489 1
			ERR_R_MALLOC_FAILURE);
d491 3
a493 3
		}
	
	CRYPTO_add(&data->references,1,CRYPTO_LOCK_EVP_PKEY);
d497 1
a497 1
		attributes, parameters);
d501 1
a501 2
	if (!i)
		{
d503 1
a503 1
			STORE_R_FAILED_STORING_KEY);
d505 1
a505 1
		}
d507 1
a507 1
	}
d509 7
a515 6
int STORE_modify_private_key(STORE *s, OPENSSL_ITEM search_attributes[],
	OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
	OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_MODIFY_PRIVATE_KEY,
		modify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);
d518 2
a519 3
		    search_attributes, add_attributes, modify_attributes,
		    delete_attributes, parameters))
		{
d521 1
a521 1
			STORE_R_FAILED_MODIFYING_PRIVATE_KEY);
d523 1
a523 1
		}
d525 1
a525 1
	}
d527 4
a530 3
int STORE_revoke_private_key(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d533 2
a534 2
	check_store(s,STORE_F_STORE_REVOKE_PRIVATE_KEY,
		revoke_object,STORE_R_NO_REVOKE_OBJECT_FUNCTION);
d537 1
a537 1
		attributes, parameters);
d539 1
a539 2
	if (!i)
		{
d541 1
a541 1
			STORE_R_FAILED_REVOKING_KEY);
d543 1
a543 1
		}
d545 8
a552 1
	}
a553 6
int STORE_delete_private_key(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_DELETE_PRIVATE_KEY,
		delete_object,STORE_R_NO_DELETE_OBJECT_FUNCTION);
	
d555 1
a555 2
		    attributes, parameters))
		{
d557 1
a557 1
			STORE_R_FAILED_DELETING_KEY);
d559 1
a559 1
		}
d561 1
a561 1
	}
d563 4
a566 3
void *STORE_list_private_key_start(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d569 2
a570 2
	check_store(s,STORE_F_STORE_LIST_PRIVATE_KEY_START,
		list_object_start,STORE_R_NO_LIST_OBJECT_START_FUNCTION);
d573 2
a574 3
		attributes, parameters);
	if (!handle)
		{
d576 1
a576 1
			STORE_R_FAILED_LISTING_KEYS);
d578 1
a578 1
		}
d580 1
a580 1
	}
d582 3
a584 2
EVP_PKEY *STORE_list_private_key_next(STORE *s, void *handle)
	{
d588 2
a589 2
	check_store(s,STORE_F_STORE_LIST_PRIVATE_KEY_NEXT,
		list_object_next,STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);
d592 1
a592 2
	if (!object || !object->data.key)
		{
d594 1
a594 1
			STORE_R_FAILED_LISTING_KEYS);
d596 2
a597 2
		}
	CRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);
d601 1
a601 1
	}
d603 5
a607 4
int STORE_list_private_key_end(STORE *s, void *handle)
	{
	check_store(s,STORE_F_STORE_LIST_PRIVATE_KEY_END,
		list_object_end,STORE_R_NO_LIST_OBJECT_END_FUNCTION);
d609 1
a609 2
	if (!s->meth->list_object_end(s, handle))
		{
d611 1
a611 1
			STORE_R_FAILED_LISTING_KEYS);
d613 1
a613 1
		}
d615 1
a615 1
	}
d617 5
a621 4
int STORE_list_private_key_endp(STORE *s, void *handle)
	{
	check_store(s,STORE_F_STORE_LIST_PRIVATE_KEY_ENDP,
		list_object_endp,STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);
d623 1
a623 2
	if (!s->meth->list_object_endp(s, handle))
		{
d625 1
a625 1
			STORE_R_FAILED_LISTING_KEYS);
d627 1
a627 1
		}
d629 1
a629 1
	}
d631 4
a634 3
EVP_PKEY *STORE_get_public_key(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d638 2
a639 2
	check_store(s,STORE_F_STORE_GET_PUBLIC_KEY,
		get_object,STORE_R_NO_GET_OBJECT_FUNCTION);
d642 2
a643 3
		attributes, parameters);
	if (!object || !object->data.key)
		{
d645 1
a645 1
			STORE_R_FAILED_GETTING_KEY);
d647 2
a648 2
		}
	CRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);
d652 1
a652 1
	}
d654 4
a657 3
int STORE_store_public_key(STORE *s, EVP_PKEY *data, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d661 2
a662 2
	check_store(s,STORE_F_STORE_STORE_PUBLIC_KEY,
		store_object,STORE_R_NO_STORE_OBJECT_FUNCTION);
d665 1
a665 2
	if (!object)
		{
d667 1
a667 1
			ERR_R_MALLOC_FAILURE);
d669 1
a669 1
		}
d671 1
a671 2
	if (!object->data.key)
		{
d673 1
a673 1
			ERR_R_MALLOC_FAILURE);
d675 3
a677 3
		}
	
	CRYPTO_add(&data->references,1,CRYPTO_LOCK_EVP_PKEY);
d681 1
a681 1
		attributes, parameters);
d685 1
a685 2
	if (!i)
		{
d687 1
a687 1
			STORE_R_FAILED_STORING_KEY);
d689 1
a689 1
		}
d691 1
a691 1
	}
d693 7
a699 6
int STORE_modify_public_key(STORE *s, OPENSSL_ITEM search_attributes[],
	OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
	OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_MODIFY_PUBLIC_KEY,
		modify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);
d702 2
a703 3
		    search_attributes, add_attributes, modify_attributes,
		    delete_attributes, parameters))
		{
d705 1
a705 1
			STORE_R_FAILED_MODIFYING_PUBLIC_KEY);
d707 1
a707 1
		}
d709 1
a709 1
	}
d711 4
a714 3
int STORE_revoke_public_key(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d717 2
a718 2
	check_store(s,STORE_F_STORE_REVOKE_PUBLIC_KEY,
		revoke_object,STORE_R_NO_REVOKE_OBJECT_FUNCTION);
d721 1
a721 1
		attributes, parameters);
d723 1
a723 2
	if (!i)
		{
d725 1
a725 1
			STORE_R_FAILED_REVOKING_KEY);
d727 1
a727 1
		}
d729 8
a736 1
	}
a737 6
int STORE_delete_public_key(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_DELETE_PUBLIC_KEY,
		delete_object,STORE_R_NO_DELETE_OBJECT_FUNCTION);
	
d739 1
a739 2
		    attributes, parameters))
		{
d741 1
a741 1
			STORE_R_FAILED_DELETING_KEY);
d743 1
a743 1
		}
d745 1
a745 1
	}
d747 4
a750 3
void *STORE_list_public_key_start(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d753 2
a754 2
	check_store(s,STORE_F_STORE_LIST_PUBLIC_KEY_START,
		list_object_start,STORE_R_NO_LIST_OBJECT_START_FUNCTION);
d757 2
a758 3
		attributes, parameters);
	if (!handle)
		{
d760 1
a760 1
			STORE_R_FAILED_LISTING_KEYS);
d762 1
a762 1
		}
d764 1
a764 1
	}
d766 3
a768 2
EVP_PKEY *STORE_list_public_key_next(STORE *s, void *handle)
	{
d772 2
a773 2
	check_store(s,STORE_F_STORE_LIST_PUBLIC_KEY_NEXT,
		list_object_next,STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);
d776 1
a776 2
	if (!object || !object->data.key)
		{
d778 1
a778 1
			STORE_R_FAILED_LISTING_KEYS);
d780 2
a781 2
		}
	CRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);
d785 1
a785 1
	}
d787 5
a791 4
int STORE_list_public_key_end(STORE *s, void *handle)
	{
	check_store(s,STORE_F_STORE_LIST_PUBLIC_KEY_END,
		list_object_end,STORE_R_NO_LIST_OBJECT_END_FUNCTION);
d793 1
a793 2
	if (!s->meth->list_object_end(s, handle))
		{
d795 1
a795 1
			STORE_R_FAILED_LISTING_KEYS);
d797 1
a797 1
		}
d799 1
a799 1
	}
d801 5
a805 4
int STORE_list_public_key_endp(STORE *s, void *handle)
	{
	check_store(s,STORE_F_STORE_LIST_PUBLIC_KEY_ENDP,
		list_object_endp,STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);
d807 1
a807 2
	if (!s->meth->list_object_endp(s, handle))
		{
d809 1
a809 1
			STORE_R_FAILED_LISTING_KEYS);
d811 1
a811 1
		}
d813 1
a813 1
	}
d815 4
a818 3
X509_CRL *STORE_generate_crl(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d822 2
a823 2
	check_store(s,STORE_F_STORE_GENERATE_CRL,
		generate_object,STORE_R_NO_GENERATE_CRL_FUNCTION);
d826 2
a827 3
		attributes, parameters);
	if (!object || !object->data.crl)
		{
d829 1
a829 1
			STORE_R_FAILED_GENERATING_CRL);
d831 2
a832 2
		}
	CRYPTO_add(&object->data.crl->references,1,CRYPTO_LOCK_X509_CRL);
d836 1
a836 1
	}
d838 4
a841 3
X509_CRL *STORE_get_crl(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d845 2
a846 2
	check_store(s,STORE_F_STORE_GET_CRL,
		get_object,STORE_R_NO_GET_OBJECT_FUNCTION);
d849 2
a850 3
		attributes, parameters);
	if (!object || !object->data.crl)
		{
d852 1
a852 1
			STORE_R_FAILED_GETTING_KEY);
d854 2
a855 2
		}
	CRYPTO_add(&object->data.crl->references,1,CRYPTO_LOCK_X509_CRL);
d859 1
a859 1
	}
d861 4
a864 3
int STORE_store_crl(STORE *s, X509_CRL *data, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d868 2
a869 2
	check_store(s,STORE_F_STORE_STORE_CRL,
		store_object,STORE_R_NO_STORE_OBJECT_FUNCTION);
d872 1
a872 2
	if (!object)
		{
d874 1
a874 1
			ERR_R_MALLOC_FAILURE);
d876 3
a878 3
		}
	
	CRYPTO_add(&data->references,1,CRYPTO_LOCK_X509_CRL);
d882 1
a882 1
		attributes, parameters);
d886 1
a886 2
	if (!i)
		{
d888 1
a888 1
			STORE_R_FAILED_STORING_KEY);
d890 1
a890 1
		}
d892 1
a892 1
	}
d894 7
a900 6
int STORE_modify_crl(STORE *s, OPENSSL_ITEM search_attributes[],
	OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
	OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_MODIFY_CRL,
		modify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);
d903 2
a904 3
		    search_attributes, add_attributes, modify_attributes,
		    delete_attributes, parameters))
		{
d906 1
a906 1
			STORE_R_FAILED_MODIFYING_CRL);
d908 1
a908 1
		}
d910 8
a917 1
	}
a918 6
int STORE_delete_crl(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_DELETE_CRL,
		delete_object,STORE_R_NO_DELETE_OBJECT_FUNCTION);
	
d920 1
a920 2
		    attributes, parameters))
		{
d922 1
a922 1
			STORE_R_FAILED_DELETING_KEY);
d924 1
a924 1
		}
d926 1
a926 1
	}
d928 4
a931 3
void *STORE_list_crl_start(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d934 2
a935 2
	check_store(s,STORE_F_STORE_LIST_CRL_START,
		list_object_start,STORE_R_NO_LIST_OBJECT_START_FUNCTION);
d938 2
a939 3
		attributes, parameters);
	if (!handle)
		{
d941 1
a941 1
			STORE_R_FAILED_LISTING_KEYS);
d943 1
a943 1
		}
d945 1
a945 1
	}
d947 3
a949 2
X509_CRL *STORE_list_crl_next(STORE *s, void *handle)
	{
d953 2
a954 2
	check_store(s,STORE_F_STORE_LIST_CRL_NEXT,
		list_object_next,STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);
d957 1
a957 2
	if (!object || !object->data.crl)
		{
d959 1
a959 1
			STORE_R_FAILED_LISTING_KEYS);
d961 2
a962 2
		}
	CRYPTO_add(&object->data.crl->references,1,CRYPTO_LOCK_X509_CRL);
d966 1
a966 1
	}
d968 5
a972 4
int STORE_list_crl_end(STORE *s, void *handle)
	{
	check_store(s,STORE_F_STORE_LIST_CRL_END,
		list_object_end,STORE_R_NO_LIST_OBJECT_END_FUNCTION);
d974 1
a974 2
	if (!s->meth->list_object_end(s, handle))
		{
d976 1
a976 1
			STORE_R_FAILED_LISTING_KEYS);
d978 1
a978 1
		}
d980 1
a980 1
	}
d982 5
a986 4
int STORE_list_crl_endp(STORE *s, void *handle)
	{
	check_store(s,STORE_F_STORE_LIST_CRL_ENDP,
		list_object_endp,STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);
d988 1
a988 2
	if (!s->meth->list_object_endp(s, handle))
		{
d990 1
a990 1
			STORE_R_FAILED_LISTING_KEYS);
d992 1
a992 1
		}
d994 1
a994 1
	}
d996 4
a999 3
int STORE_store_number(STORE *s, BIGNUM *data, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d1003 2
a1004 2
	check_store(s,STORE_F_STORE_STORE_NUMBER,
		store_object,STORE_R_NO_STORE_OBJECT_NUMBER_FUNCTION);
d1007 1
a1007 2
	if (!object)
		{
d1009 1
a1009 1
			ERR_R_MALLOC_FAILURE);
d1011 2
a1012 2
		}
	
d1016 1
a1016 1
		attributes, parameters);
d1020 1
a1020 2
	if (!i)
		{
d1022 1
a1022 1
			STORE_R_FAILED_STORING_NUMBER);
d1024 1
a1024 1
		}
d1026 1
a1026 1
	}
d1028 7
a1034 6
int STORE_modify_number(STORE *s, OPENSSL_ITEM search_attributes[],
	OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
	OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_MODIFY_NUMBER,
		modify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);
d1037 2
a1038 3
		    search_attributes, add_attributes, modify_attributes,
		    delete_attributes, parameters))
		{
d1040 1
a1040 1
			STORE_R_FAILED_MODIFYING_NUMBER);
d1042 1
a1042 1
		}
d1044 1
a1044 1
	}
d1046 4
a1049 3
BIGNUM *STORE_get_number(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d1053 2
a1054 2
	check_store(s,STORE_F_STORE_GET_NUMBER,
		get_object,STORE_R_NO_GET_OBJECT_NUMBER_FUNCTION);
d1057 2
a1058 3
		parameters);
	if (!object || !object->data.number)
		{
d1060 1
a1060 1
			STORE_R_FAILED_GETTING_NUMBER);
d1062 1
a1062 1
		}
d1067 1
a1067 1
	}
d1069 6
a1074 5
int STORE_delete_number(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_DELETE_NUMBER,
		delete_object,STORE_R_NO_DELETE_NUMBER_FUNCTION);
d1077 1
a1077 2
		    parameters))
		{
d1079 1
a1079 1
			STORE_R_FAILED_DELETING_NUMBER);
d1081 1
a1081 1
		}
d1083 1
a1083 1
	}
d1085 4
a1088 3
int STORE_store_arbitrary(STORE *s, BUF_MEM *data, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d1092 2
a1093 2
	check_store(s,STORE_F_STORE_STORE_ARBITRARY,
		store_object,STORE_R_NO_STORE_OBJECT_ARBITRARY_FUNCTION);
d1096 1
a1096 2
	if (!object)
		{
d1098 1
a1098 1
			ERR_R_MALLOC_FAILURE);
d1100 2
a1101 2
		}
	
d1105 1
a1105 1
		attributes, parameters);
d1109 1
a1109 2
	if (!i)
		{
d1111 1
a1111 1
			STORE_R_FAILED_STORING_ARBITRARY);
d1113 1
a1113 1
		}
d1115 1
a1115 1
	}
d1117 7
a1123 6
int STORE_modify_arbitrary(STORE *s, OPENSSL_ITEM search_attributes[],
	OPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],
	OPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_MODIFY_ARBITRARY,
		modify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);
d1126 2
a1127 3
		    search_attributes, add_attributes, modify_attributes,
		    delete_attributes, parameters))
		{
d1129 1
a1129 1
			STORE_R_FAILED_MODIFYING_ARBITRARY);
d1131 1
a1131 1
		}
d1133 1
a1133 1
	}
d1135 4
a1138 3
BUF_MEM *STORE_get_arbitrary(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
d1142 2
a1143 2
	check_store(s,STORE_F_STORE_GET_ARBITRARY,
		get_object,STORE_R_NO_GET_OBJECT_ARBITRARY_FUNCTION);
d1146 2
a1147 3
		attributes, parameters);
	if (!object || !object->data.arbitrary)
		{
d1149 1
a1149 1
			STORE_R_FAILED_GETTING_ARBITRARY);
d1151 1
a1151 1
		}
d1156 1
a1156 1
	}
d1158 6
a1163 5
int STORE_delete_arbitrary(STORE *s, OPENSSL_ITEM attributes[],
	OPENSSL_ITEM parameters[])
	{
	check_store(s,STORE_F_STORE_DELETE_ARBITRARY,
		delete_object,STORE_R_NO_DELETE_ARBITRARY_FUNCTION);
d1166 1
a1166 2
		    parameters))
		{
d1168 1
a1168 1
			STORE_R_FAILED_DELETING_ARBITRARY);
d1170 1
a1170 1
		}
d1172 1
a1172 1
	}
d1174 3
a1176 2
STORE_OBJECT *STORE_OBJECT_new(void)
	{
d1178 3
a1180 1
	if (object) memset(object, 0, sizeof(STORE_OBJECT));
d1182 8
a1189 6
	}
void STORE_OBJECT_free(STORE_OBJECT *data)
	{
	if (!data) return;
	switch (data->type)
		{
d1206 1
a1206 1
		}
d1208 1
a1208 1
	}
d1213 1
a1213 2
struct STORE_attr_info_st
	{
d1215 1
a1215 2
	union
		{
d1221 3
a1223 3
		} values[STORE_ATTR_TYPE_NUM+1];
	size_t value_sizes[STORE_ATTR_TYPE_NUM+1];
	};
d1230 3
a1232 2
STORE_ATTR_INFO *STORE_ATTR_INFO_new(void)
	{
d1234 8
a1241 8
	}
static void STORE_ATTR_INFO_attr_free(STORE_ATTR_INFO *attrs,
	STORE_ATTR_TYPES code)
	{
	if (ATTR_IS_SET(attrs,code))
		{
		switch(code)
			{
a1262 1
			}
d1265 6
a1270 4
int STORE_ATTR_INFO_free(STORE_ATTR_INFO *attrs)
	{
	if (attrs)
		{
d1272 1
a1272 1
		for(i = 0; i++ < STORE_ATTR_TYPE_NUM;)
d1275 1
a1275 1
		}
d1277 6
a1282 5
	}
char *STORE_ATTR_INFO_get0_cstr(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)
	{
	if (!attrs)
		{
d1284 1
a1284 1
			ERR_R_PASSED_NULL_PARAMETER);
d1286 2
a1287 2
		}
	if (ATTR_IS_SET(attrs,code))
d1289 1
a1289 2
	STOREerr(STORE_F_STORE_ATTR_INFO_GET0_CSTR,
		STORE_R_NO_VALUE);
d1291 6
a1296 6
	}
unsigned char *STORE_ATTR_INFO_get0_sha1str(STORE_ATTR_INFO *attrs,
	STORE_ATTR_TYPES code)
	{
	if (!attrs)
		{
d1298 1
a1298 1
			ERR_R_PASSED_NULL_PARAMETER);
d1300 2
a1301 2
		}
	if (ATTR_IS_SET(attrs,code))
d1303 1
a1303 2
	STOREerr(STORE_F_STORE_ATTR_INFO_GET0_SHA1STR,
		STORE_R_NO_VALUE);
d1305 6
a1310 5
	}
X509_NAME *STORE_ATTR_INFO_get0_dn(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)
	{
	if (!attrs)
		{
d1312 1
a1312 1
			ERR_R_PASSED_NULL_PARAMETER);
d1314 2
a1315 2
		}
	if (ATTR_IS_SET(attrs,code))
d1317 1
a1317 2
	STOREerr(STORE_F_STORE_ATTR_INFO_GET0_DN,
		STORE_R_NO_VALUE);
d1319 6
a1324 5
	}
BIGNUM *STORE_ATTR_INFO_get0_number(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)
	{
	if (!attrs)
		{
d1326 1
a1326 1
			ERR_R_PASSED_NULL_PARAMETER);
d1328 2
a1329 2
		}
	if (ATTR_IS_SET(attrs,code))
d1331 1
a1331 2
	STOREerr(STORE_F_STORE_ATTR_INFO_GET0_NUMBER,
		STORE_R_NO_VALUE);
d1333 7
a1339 6
	}
int STORE_ATTR_INFO_set_cstr(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
	char *cstr, size_t cstr_size)
	{
	if (!attrs)
		{
d1341 1
a1341 1
			ERR_R_PASSED_NULL_PARAMETER);
d1343 2
a1344 3
		}
	if (!ATTR_IS_SET(attrs,code))
		{
d1348 1
a1348 1
			ERR_R_MALLOC_FAILURE);
d1350 1
a1350 1
		}
d1353 7
a1359 6
	}
int STORE_ATTR_INFO_set_sha1str(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
	unsigned char *sha1str, size_t sha1str_size)
	{
	if (!attrs)
		{
d1361 1
a1361 1
			ERR_R_PASSED_NULL_PARAMETER);
d1363 2
a1364 3
		}
	if (!ATTR_IS_SET(attrs,code))
		{
d1366 2
a1367 2
			    (unsigned char *)BUF_memdup(sha1str,
				    sha1str_size)))
d1370 1
a1370 1
			ERR_R_MALLOC_FAILURE);
d1372 3
a1374 2
		}
	STOREerr(STORE_F_STORE_ATTR_INFO_SET_SHA1STR, STORE_R_ALREADY_HAS_A_VALUE);
d1376 7
a1382 6
	}
int STORE_ATTR_INFO_set_dn(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
	X509_NAME *dn)
	{
	if (!attrs)
		{
d1384 1
a1384 1
			ERR_R_PASSED_NULL_PARAMETER);
d1386 2
a1387 3
		}
	if (!ATTR_IS_SET(attrs,code))
		{
d1391 1
a1391 1
			ERR_R_MALLOC_FAILURE);
d1393 1
a1393 1
		}
d1396 7
a1402 6
	}
int STORE_ATTR_INFO_set_number(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
	BIGNUM *number)
	{
	if (!attrs)
		{
d1404 1
a1404 1
			ERR_R_PASSED_NULL_PARAMETER);
d1406 2
a1407 3
		}
	if (!ATTR_IS_SET(attrs,code))
		{
d1411 1
a1411 1
			ERR_R_MALLOC_FAILURE);
d1413 3
a1415 2
		}
	STOREerr(STORE_F_STORE_ATTR_INFO_SET_NUMBER, STORE_R_ALREADY_HAS_A_VALUE);
d1417 7
a1423 6
	}
int STORE_ATTR_INFO_modify_cstr(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
	char *cstr, size_t cstr_size)
	{
	if (!attrs)
		{
d1425 1
a1425 1
			ERR_R_PASSED_NULL_PARAMETER);
d1427 2
a1428 3
		}
	if (ATTR_IS_SET(attrs,code))
		{
d1432 1
a1432 1
		}
d1434 7
a1440 6
	}
int STORE_ATTR_INFO_modify_sha1str(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
	unsigned char *sha1str, size_t sha1str_size)
	{
	if (!attrs)
		{
d1442 1
a1442 1
			ERR_R_PASSED_NULL_PARAMETER);
d1444 2
a1445 3
		}
	if (ATTR_IS_SET(attrs,code))
		{
d1449 1
a1449 1
		}
d1451 7
a1457 6
	}
int STORE_ATTR_INFO_modify_dn(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
	X509_NAME *dn)
	{
	if (!attrs)
		{
d1459 1
a1459 1
			ERR_R_PASSED_NULL_PARAMETER);
d1461 2
a1462 3
		}
	if (ATTR_IS_SET(attrs,code))
		{
d1466 1
a1466 1
		}
d1468 7
a1474 6
	}
int STORE_ATTR_INFO_modify_number(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,
	BIGNUM *number)
	{
	if (!attrs)
		{
d1476 1
a1476 1
			ERR_R_PASSED_NULL_PARAMETER);
d1478 2
a1479 3
		}
	if (ATTR_IS_SET(attrs,code))
		{
d1483 1
a1483 1
		}
d1485 1
a1485 1
	}
d1487 1
a1487 2
struct attr_list_ctx_st
	{
d1489 6
a1494 5
	};
void *STORE_parse_attrs_start(OPENSSL_ITEM *attributes)
	{
	if (attributes)
		{
d1496 1
a1496 1
			(struct attr_list_ctx_st *)malloc(sizeof(struct attr_list_ctx_st));
d1501 1
a1501 1
				ERR_R_MALLOC_FAILURE);
d1503 1
a1503 1
		}
d1506 5
a1510 3
	}
STORE_ATTR_INFO *STORE_parse_attrs_next(void *handle)
	{
d1513 1
a1513 2
	if (context && context->attributes)
		{
d1516 4
a1519 6
		while(context->attributes
			&& context->attributes->code != STORE_ATTR_OR
			&& context->attributes->code != STORE_ATTR_END)
			{
			switch(context->attributes->code)
				{
d1523 3
a1525 3
				if (!attrs) attrs = STORE_ATTR_INFO_new();
				if (attrs == NULL)
					{
d1527 1
a1527 1
						ERR_R_MALLOC_FAILURE);
d1529 1
a1529 1
					}
d1531 3
a1533 3
					context->attributes->code,
					context->attributes->value,
					context->attributes->value_size);
d1540 3
a1542 3
				if (!attrs) attrs = STORE_ATTR_INFO_new();
				if (attrs == NULL)
					{
d1544 1
a1544 1
						ERR_R_MALLOC_FAILURE);
d1546 1
a1546 1
					}
d1548 3
a1550 3
					context->attributes->code,
					context->attributes->value,
					context->attributes->value_size);
d1554 3
a1556 3
				if (!attrs) attrs = STORE_ATTR_INFO_new();
				if (attrs == NULL)
					{
d1558 1
a1558 1
						ERR_R_MALLOC_FAILURE);
d1560 1
a1560 1
					}
d1562 2
a1563 2
					context->attributes->code,
					context->attributes->value);
d1566 3
a1568 3
				if (!attrs) attrs = STORE_ATTR_INFO_new();
				if (attrs == NULL)
					{
d1570 1
a1570 1
						ERR_R_MALLOC_FAILURE);
d1572 1
a1572 1
					}
d1574 2
a1575 2
					context->attributes->code,
					context->attributes->value);
d1577 1
a1577 1
				}
d1579 1
a1579 1
			}
d1583 5
a1587 4
	err:
		while(context->attributes
			&& context->attributes->code != STORE_ATTR_OR
			&& context->attributes->code != STORE_ATTR_END)
d1592 1
a1592 1
		}
d1595 5
a1599 3
	}
int STORE_parse_attrs_end(void *handle)
	{
d1602 1
a1602 2
	if (context && context->attributes)
		{
d1608 1
a1608 1
		}
d1611 1
a1611 1
	}
d1613 3
a1615 2
int STORE_parse_attrs_endp(void *handle)
	{
d1618 1
a1618 2
	if (context && context->attributes)
		{
d1620 1
a1620 1
		}
d1623 1
a1623 1
	}
d1625 7
a1631 7
static int attr_info_compare_compute_range(
	const unsigned char *abits, const unsigned char *bbits,
	unsigned int *alowp, unsigned int *ahighp,
	unsigned int *blowp, unsigned int *bhighp)
	{
	unsigned int alow = (unsigned int)-1, ahigh = 0;
	unsigned int blow = (unsigned int)-1, bhigh = 0;
d1634 24
a1657 6
	for (i = 0; i < (STORE_ATTR_TYPE_NUM + 8) / 8; i++, abits++, bbits++)
		{
		if (res == 0)
			{
			if (*abits < *bbits) res = -1;
			if (*abits > *bbits) res = 1;
a1658 13
		if (*abits)
			{
			if (alow == (unsigned int)-1)
				{
				alow = i * 8;
				if (!(*abits & 0x01)) alow++;
				if (!(*abits & 0x02)) alow++;
				if (!(*abits & 0x04)) alow++;
				if (!(*abits & 0x08)) alow++;
				if (!(*abits & 0x10)) alow++;
				if (!(*abits & 0x20)) alow++;
				if (!(*abits & 0x40)) alow++;
				}
d1660 32
a1691 7
			if (!(*abits & 0x80)) ahigh++;
			if (!(*abits & 0x40)) ahigh++;
			if (!(*abits & 0x20)) ahigh++;
			if (!(*abits & 0x10)) ahigh++;
			if (!(*abits & 0x08)) ahigh++;
			if (!(*abits & 0x04)) ahigh++;
			if (!(*abits & 0x02)) ahigh++;
a1692 13
		if (*bbits)
			{
			if (blow == (unsigned int)-1)
				{
				blow = i * 8;
				if (!(*bbits & 0x01)) blow++;
				if (!(*bbits & 0x02)) blow++;
				if (!(*bbits & 0x04)) blow++;
				if (!(*bbits & 0x08)) blow++;
				if (!(*bbits & 0x10)) blow++;
				if (!(*bbits & 0x20)) blow++;
				if (!(*bbits & 0x40)) blow++;
				}
d1694 28
a1721 15
			if (!(*bbits & 0x80)) bhigh++;
			if (!(*bbits & 0x40)) bhigh++;
			if (!(*bbits & 0x20)) bhigh++;
			if (!(*bbits & 0x10)) bhigh++;
			if (!(*bbits & 0x08)) bhigh++;
			if (!(*bbits & 0x04)) bhigh++;
			if (!(*bbits & 0x02)) bhigh++;
			}
		}
	if (ahigh + alow < bhigh + blow) res = -1;
	if (ahigh + alow > bhigh + blow) res = 1;
	if (alowp) *alowp = alow;
	if (ahighp) *ahighp = ahigh;
	if (blowp) *blowp = blow;
	if (bhighp) *bhighp = bhigh;
d1723 1
a1723 1
	}
d1725 17
a1741 11
int STORE_ATTR_INFO_compare(const STORE_ATTR_INFO * const *a,
			    const STORE_ATTR_INFO * const *b)
	{
	if (a == b) return 0;
	if (!a) return -1;
	if (!b) return 1;
	return attr_info_compare_compute_range((*a)->set, (*b)->set, 0, 0, 0, 0);
	}

int STORE_ATTR_INFO_in_range(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)
	{
d1744 6
a1749 3
	if (a == b) return 1;
	if (!a) return 0;
	if (!b) return 0;
d1751 1
a1751 1
		&alow, &ahigh, &blow, &bhigh);
d1755 1
a1755 1
	}
d1757 3
a1759 2
int STORE_ATTR_INFO_in(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)
	{
d1763 6
a1768 3
	if (a == b) return 1;
	if (!a) return 0;
	if (!b) return 0;
d1771 1
a1771 2
	for (i = 0; i < (STORE_ATTR_TYPE_NUM + 8) / 8; i++, abits++, bbits++)
		{
d1774 1
a1774 1
		}
d1776 1
a1776 1
	}
d1778 3
a1780 2
int STORE_ATTR_INFO_in_ex(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)
	{
d1783 4
a1786 2
	if (a == b) return 1;
	if (!STORE_ATTR_INFO_in(a, b)) return 0;
d1788 2
a1789 4
		if (ATTR_IS_SET(a, i))
			{
			switch(i)
				{
d1794 1
a1794 1
					    b->values[i].cstring))
d1803 2
a1804 2
					    b->values[i].sha1string,
					    a->value_sizes[i]))
d1810 1
a1810 1
					    b->values[i].dn))
d1815 1
a1815 1
					    b->values[i].number))
a1819 1
				}
d1821 1
d1824 1
a1824 1
	}
@


1.3
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a271 3
#ifdef REF_PRINT
	REF_PRINT("X509",data);
#endif
a294 3
#ifdef REF_PRINT
	REF_PRINT("X509",data);
#endif
a395 3
#ifdef REF_PRINT
	REF_PRINT("X509",data);
#endif
a446 3
#ifdef REF_PRINT
	REF_PRINT("EVP_PKEY",data);
#endif
a469 3
#ifdef REF_PRINT
	REF_PRINT("EVP_PKEY",data);
#endif
a499 3
#ifdef REF_PRINT
	REF_PRINT("EVP_PKEY",data);
#endif
a604 3
#ifdef REF_PRINT
	REF_PRINT("EVP_PKEY",data);
#endif
a655 3
#ifdef REF_PRINT
	REF_PRINT("EVP_PKEY",data);
#endif
a685 3
#ifdef REF_PRINT
	REF_PRINT("EVP_PKEY",data);
#endif
a790 3
#ifdef REF_PRINT
	REF_PRINT("EVP_PKEY",data);
#endif
a841 3
#ifdef REF_PRINT
	REF_PRINT("X509_CRL",data);
#endif
a864 3
#ifdef REF_PRINT
	REF_PRINT("X509_CRL",data);
#endif
a887 3
#ifdef REF_PRINT
	REF_PRINT("X509_CRL",data);
#endif
a972 3
#ifdef REF_PRINT
	REF_PRINT("X509_CRL",data);
#endif
@


1.2
log
@remove duplicated tests in if statements
ok krw@@ sthen@@ deraadt@@
@
text
@d115 1
a115 1
	ret=(STORE *)OPENSSL_malloc(sizeof(STORE));
d188 1
a188 1
	OPENSSL_free(store);
d1230 1
a1230 1
	STORE_OBJECT *object = OPENSSL_malloc(sizeof(STORE_OBJECT));
d1256 1
a1256 1
	OPENSSL_free(data);
d1283 1
a1283 1
	return (STORE_ATTR_INFO *)OPENSSL_malloc(sizeof(STORE_ATTR_INFO));
d1323 1
a1323 1
		OPENSSL_free(attrs);
d1477 1
a1477 1
		OPENSSL_free(attrs->values[code].cstring);
d1494 1
a1494 1
		OPENSSL_free(attrs->values[code].sha1string);
d1511 1
a1511 1
		OPENSSL_free(attrs->values[code].dn);
d1528 1
a1528 1
		OPENSSL_free(attrs->values[code].number);
d1544 1
a1544 1
			(struct attr_list_ctx_st *)OPENSSL_malloc(sizeof(struct attr_list_ctx_st));
d1653 1
a1653 1
		OPENSSL_free(context);
@


1.1
log
@Initial revision
@
text
@d475 1
a475 1
	if (!object || !object->data.key || !object->data.key)
d616 1
a616 1
	if (!object || !object->data.key || !object->data.key)
d670 1
a670 1
	if (!object || !object->data.key || !object->data.key)
d811 1
a811 1
	if (!object || !object->data.key || !object->data.key)
d1673 1
a1673 1
	unsigned char *abits, unsigned char *bbits,
d1742 2
a1743 1
int STORE_ATTR_INFO_compare(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)
d1748 1
a1748 1
	return attr_info_compare_compute_range(a->set, b->set, 0, 0, 0, 0);
d1750 1
d1764 1
d1782 1
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.0a
@
text
@d1673 1
a1673 1
	const unsigned char *abits, const unsigned char *bbits,
d1742 1
a1742 2
int STORE_ATTR_INFO_compare(const STORE_ATTR_INFO * const *a,
			    const STORE_ATTR_INFO * const *b)
d1747 1
a1747 1
	return attr_info_compare_compute_range((*a)->set, (*b)->set, 0, 0, 0, 0);
a1748 1

a1761 1

a1778 1

@

