head	1.40;
access;
symbols
	OPENBSD_6_1_BASE:1.40;
locks; strict;
comment	@ * @;


1.40
date	2015.09.17.09.51.40;	author bcook;	state Exp;
branches;
next	1.39;
commitid	GY2hNZLkMCNJZtN0;

1.39
date	2015.09.13.16.56.11;	author miod;	state Exp;
branches;
next	1.38;
commitid	0b5fDyJXn1VKqels;

1.38
date	2015.09.13.10.02.49;	author miod;	state Exp;
branches;
next	1.37;
commitid	TOlJlYmAKCXz3l7H;

1.37
date	2015.09.10.16.35.15;	author jsing;	state Exp;
branches;
next	1.36;
commitid	KqIayHqoHpTTuiG0;

1.36
date	2015.09.10.16.07.58;	author jsing;	state Exp;
branches;
next	1.35;
commitid	tuz17rV3kJQY4DqV;

1.35
date	2015.06.20.12.01.54;	author jsing;	state Exp;
branches;
next	1.34;
commitid	5jDWu54nW802daRf;

1.34
date	2015.04.11.16.16.15;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	lnb130mvt8k6weCi;

1.33
date	2015.02.07.13.19.15;	author doug;	state Exp;
branches;
next	1.32;
commitid	gtwLkRyWx0K1HbzX;

1.32
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.31;
commitid	nzndm3zqPmFurSaK;

1.31
date	2014.06.24.19.33.10;	author miod;	state Exp;
branches;
next	1.30;
commitid	PeXoFMYhE4j9rymq;

1.30
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	mJUVYpkFBZ0Zv2bG;

1.29
date	2014.06.01.11.16.08;	author miod;	state Exp;
branches;
next	1.28;
commitid	G9wswhkl7VRt8e4D;

1.28
date	2014.05.29.20.21.22;	author beck;	state Exp;
branches;
next	1.27;

1.27
date	2014.05.25.17.29.51;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2014.05.24.09.16.07;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2014.05.23.03.20.11;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2014.05.22.21.57.25;	author beck;	state Exp;
branches;
next	1.23;

1.23
date	2014.05.01.11.11.37;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.20.14.32.19;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.18.18.33.18;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.17.16.17.41;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.15.20.06.09;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.15.17.46.16;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.15.13.42.55;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.13.23.50.02;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.13.15.25.29;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.09.12.15.22;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.27.05.06.55;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.16;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.10;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.02.54;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.02;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.28;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.23;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.33;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.33;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.40;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.34.27;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.04.29.05.37.01;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.06.27.05.05.30;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.01.09.12.13.50;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.02;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.33;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.40
log
@include stdint.h for uint64_t

noted by Bernard Spil
@
text
@/* $OpenBSD: crypto.h,v 1.39 2015/09/13 16:56:11 miod Exp $ */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECDH support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef HEADER_CRYPTO_H
#define HEADER_CRYPTO_H

#include <openssl/opensslconf.h>

#include <openssl/stack.h>
#include <openssl/safestack.h>
#include <openssl/opensslv.h>
#include <openssl/ossl_typ.h>

#ifdef  __cplusplus
extern "C" {
#endif

/* Backward compatibility to SSLeay */
/* This is more to be used to check the correct DLL is being used
 * in the MS world. */
#define SSLEAY_VERSION_NUMBER	OPENSSL_VERSION_NUMBER
#define SSLEAY_VERSION		0
/* #define SSLEAY_OPTIONS	1 no longer supported */
#define SSLEAY_CFLAGS		2
#define SSLEAY_BUILT_ON		3
#define SSLEAY_PLATFORM		4
#define SSLEAY_DIR		5

/* A generic structure to pass assorted data in a expandable way */
typedef struct openssl_item_st {
	int code;
	void *value;		/* Not used for flag attributes */
	size_t value_size;	/* Max size of value for output, length for input */
	size_t *value_length;	/* Returned length of value for output */
} OPENSSL_ITEM;


/* When changing the CRYPTO_LOCK_* list, be sure to maintain the text lock
 * names in cryptlib.c
 */

#define	CRYPTO_LOCK_ERR			1
#define	CRYPTO_LOCK_EX_DATA		2
#define	CRYPTO_LOCK_X509		3
#define	CRYPTO_LOCK_X509_INFO		4
#define	CRYPTO_LOCK_X509_PKEY		5
#define CRYPTO_LOCK_X509_CRL		6
#define CRYPTO_LOCK_X509_REQ		7
#define CRYPTO_LOCK_DSA			8
#define CRYPTO_LOCK_RSA			9
#define CRYPTO_LOCK_EVP_PKEY		10
#define CRYPTO_LOCK_X509_STORE		11
#define CRYPTO_LOCK_SSL_CTX		12
#define CRYPTO_LOCK_SSL_CERT		13
#define CRYPTO_LOCK_SSL_SESSION		14
#define CRYPTO_LOCK_SSL_SESS_CERT	15
#define CRYPTO_LOCK_SSL			16
#define CRYPTO_LOCK_SSL_METHOD		17
#define CRYPTO_LOCK_RAND		18
#define CRYPTO_LOCK_RAND2		19
#define CRYPTO_LOCK_MALLOC		20
#define CRYPTO_LOCK_BIO			21
#define CRYPTO_LOCK_GETHOSTBYNAME	22
#define CRYPTO_LOCK_GETSERVBYNAME	23
#define CRYPTO_LOCK_READDIR		24
#define CRYPTO_LOCK_RSA_BLINDING	25
#define CRYPTO_LOCK_DH			26
#define CRYPTO_LOCK_MALLOC2		27
#define CRYPTO_LOCK_DSO			28
#define CRYPTO_LOCK_DYNLOCK		29
#define CRYPTO_LOCK_ENGINE		30
#define CRYPTO_LOCK_UI			31
#define CRYPTO_LOCK_ECDSA               32
#define CRYPTO_LOCK_EC			33
#define CRYPTO_LOCK_ECDH		34
#define CRYPTO_LOCK_BN  		35
#define CRYPTO_LOCK_EC_PRE_COMP		36
#define CRYPTO_LOCK_STORE		37
#define CRYPTO_LOCK_COMP		38
#define CRYPTO_LOCK_FIPS		39
#define CRYPTO_LOCK_FIPS2		40
#define CRYPTO_NUM_LOCKS		41

#define CRYPTO_LOCK		1
#define CRYPTO_UNLOCK		2
#define CRYPTO_READ		4
#define CRYPTO_WRITE		8

#ifndef OPENSSL_NO_LOCKING
#ifndef CRYPTO_w_lock
#define CRYPTO_w_lock(type)	\
	CRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)
#define CRYPTO_w_unlock(type)	\
	CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)
#define CRYPTO_r_lock(type)	\
	CRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ,type,__FILE__,__LINE__)
#define CRYPTO_r_unlock(type)	\
	CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ,type,__FILE__,__LINE__)
#define CRYPTO_add(addr,amount,type)	\
	CRYPTO_add_lock(addr,amount,type,__FILE__,__LINE__)
#endif
#else
#define CRYPTO_w_lock(a)
#define CRYPTO_w_unlock(a)
#define CRYPTO_r_lock(a)
#define CRYPTO_r_unlock(a)
#define CRYPTO_add(a,b,c)	((*(a))+=(b))
#endif

/* Some applications as well as some parts of OpenSSL need to allocate
   and deallocate locks in a dynamic fashion.  The following typedef
   makes this possible in a type-safe manner.  */
/* struct CRYPTO_dynlock_value has to be defined by the application. */
typedef struct {
	int references;
	struct CRYPTO_dynlock_value *data;
} CRYPTO_dynlock;


/* The following can be used to detect memory leaks in the SSLeay library.
 * It used, it turns on malloc checking */

#define CRYPTO_MEM_CHECK_OFF	0x0	/* an enume */
#define CRYPTO_MEM_CHECK_ON	0x1	/* a bit */
#define CRYPTO_MEM_CHECK_ENABLE	0x2	/* a bit */
#define CRYPTO_MEM_CHECK_DISABLE 0x3	/* an enume */

/* The following are bit values to turn on or off options connected to the
 * malloc checking functionality */

/* Adds time to the memory checking information */
#define V_CRYPTO_MDEBUG_TIME	0x1 /* a bit */
/* Adds thread number to the memory checking information */
#define V_CRYPTO_MDEBUG_THREAD	0x2 /* a bit */

#define V_CRYPTO_MDEBUG_ALL (V_CRYPTO_MDEBUG_TIME | V_CRYPTO_MDEBUG_THREAD)


/* predec of the BIO type */
typedef struct bio_st BIO_dummy;

struct crypto_ex_data_st {
	STACK_OF(void) *sk;
};
DECLARE_STACK_OF(void)

/* This stuff is basically class callback functions
 * The current classes are SSL_CTX, SSL, SSL_SESSION, and a few more */

typedef struct crypto_ex_data_func_st {
	long argl;	/* Arbitary long */
	void *argp;	/* Arbitary void * */
	CRYPTO_EX_new *new_func;
	CRYPTO_EX_free *free_func;
	CRYPTO_EX_dup *dup_func;
} CRYPTO_EX_DATA_FUNCS;

DECLARE_STACK_OF(CRYPTO_EX_DATA_FUNCS)

/* Per class, we have a STACK of CRYPTO_EX_DATA_FUNCS for each CRYPTO_EX_DATA
 * entry.
 */

#define CRYPTO_EX_INDEX_BIO		0
#define CRYPTO_EX_INDEX_SSL		1
#define CRYPTO_EX_INDEX_SSL_CTX		2
#define CRYPTO_EX_INDEX_SSL_SESSION	3
#define CRYPTO_EX_INDEX_X509_STORE	4
#define CRYPTO_EX_INDEX_X509_STORE_CTX	5
#define CRYPTO_EX_INDEX_RSA		6
#define CRYPTO_EX_INDEX_DSA		7
#define CRYPTO_EX_INDEX_DH		8
#define CRYPTO_EX_INDEX_ENGINE		9
#define CRYPTO_EX_INDEX_X509		10
#define CRYPTO_EX_INDEX_UI		11
#define CRYPTO_EX_INDEX_ECDSA		12
#define CRYPTO_EX_INDEX_ECDH		13
#define CRYPTO_EX_INDEX_COMP		14
#define CRYPTO_EX_INDEX_STORE		15

/* Dynamically assigned indexes start from this value (don't use directly, use
 * via CRYPTO_ex_data_new_class). */
#define CRYPTO_EX_INDEX_USER		100

#define CRYPTO_malloc_init()		(0)
#define CRYPTO_malloc_debug_init()	(0)

#if defined CRYPTO_MDEBUG_ALL || defined CRYPTO_MDEBUG_TIME || defined CRYPTO_MDEBUG_THREAD
# ifndef CRYPTO_MDEBUG /* avoid duplicate #define */
#  define CRYPTO_MDEBUG
# endif
#endif

int CRYPTO_mem_ctrl(int mode);
int CRYPTO_is_mem_check_on(void);

/* for applications */
#define MemCheck_start() CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON)
#define MemCheck_stop()	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_OFF)

#define OPENSSL_malloc(num)	CRYPTO_malloc((int)num,__FILE__,__LINE__)
#define OPENSSL_strdup(str)	CRYPTO_strdup((str),__FILE__,__LINE__)
#define OPENSSL_realloc(addr,num) \
	CRYPTO_realloc((char *)addr,(int)num,__FILE__,__LINE__)
#define OPENSSL_realloc_clean(addr,old_num,num) \
	CRYPTO_realloc_clean(addr,old_num,num,__FILE__,__LINE__)
#define OPENSSL_remalloc(addr,num) \
	CRYPTO_remalloc((char **)addr,(int)num,__FILE__,__LINE__)
#define OPENSSL_freeFunc	CRYPTO_free
#define OPENSSL_free(addr)	CRYPTO_free(addr)

#define OPENSSL_malloc_locked(num) \
	CRYPTO_malloc_locked((int)num,__FILE__,__LINE__)
#define OPENSSL_free_locked(addr) CRYPTO_free_locked(addr)


const char *SSLeay_version(int type);
unsigned long SSLeay(void);

/* An opaque type representing an implementation of "ex_data" support */
typedef struct st_CRYPTO_EX_DATA_IMPL	CRYPTO_EX_DATA_IMPL;
/* Return an opaque pointer to the current "ex_data" implementation */
const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void);
/* Sets the "ex_data" implementation to be used (if it's not too late) */
int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i);
/* Get a new "ex_data" class, and return the corresponding "class_index" */
int CRYPTO_ex_data_new_class(void);
/* Within a given class, get/register a new index */
int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,
    CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
    CRYPTO_EX_free *free_func);
/* Initialise/duplicate/free CRYPTO_EX_DATA variables corresponding to a given
 * class (invokes whatever per-class callbacks are applicable) */
int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);
int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
    CRYPTO_EX_DATA *from);
void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);
/* Get/set data in a CRYPTO_EX_DATA variable corresponding to a particular index
 * (relative to the class type involved) */
int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val);
void *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx);
/* This function cleans up all "ex_data" state. It mustn't be called under
 * potential race-conditions. */
void CRYPTO_cleanup_all_ex_data(void);

int CRYPTO_get_new_lockid(char *name);

int CRYPTO_num_locks(void); /* return CRYPTO_NUM_LOCKS (shared libs!) */
void CRYPTO_lock(int mode, int type, const char *file, int line);
void CRYPTO_set_locking_callback(void (*func)(int mode, int type,
    const char *file, int line));
void (*CRYPTO_get_locking_callback(void))(int mode, int type,
    const char *file, int line);
void CRYPTO_set_add_lock_callback(int (*func)(int *num, int mount, int type,
    const char *file, int line));
int (*CRYPTO_get_add_lock_callback(void))(int *num, int mount, int type,
    const char *file, int line);

/* Don't use this structure directly. */
typedef struct crypto_threadid_st {
	void *ptr;
	unsigned long val;
} CRYPTO_THREADID;
/* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */
void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);
void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);
int CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID *));
void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);
void CRYPTO_THREADID_current(CRYPTO_THREADID *id);
int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a, const CRYPTO_THREADID *b);
void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest, const CRYPTO_THREADID *src);
unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);
#ifndef OPENSSL_NO_DEPRECATED
void CRYPTO_set_id_callback(unsigned long (*func)(void));
unsigned long (*CRYPTO_get_id_callback(void))(void);
unsigned long CRYPTO_thread_id(void);
#endif

const char *CRYPTO_get_lock_name(int type);
int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,
    int line);

int CRYPTO_get_new_dynlockid(void);
void CRYPTO_destroy_dynlockid(int i);
struct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i);
void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*dyn_create_function)(const char *file, int line));
void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)(int mode, struct CRYPTO_dynlock_value *l, const char *file, int line));
void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)(struct CRYPTO_dynlock_value *l, const char *file, int line));
struct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback(void))(const char *file, int line);
void (*CRYPTO_get_dynlock_lock_callback(void))(int mode, struct CRYPTO_dynlock_value *l, const char *file, int line);
void (*CRYPTO_get_dynlock_destroy_callback(void))(struct CRYPTO_dynlock_value *l, const char *file, int line);

/* CRYPTO_set_mem_functions includes CRYPTO_set_locked_mem_functions --
 * call the latter last if you need different functions */
int CRYPTO_set_mem_functions(void *(*m)(size_t), void *(*r)(void *, size_t), void (*f)(void *));
int CRYPTO_set_locked_mem_functions(void *(*m)(size_t), void (*free_func)(void *));
int CRYPTO_set_mem_ex_functions(void *(*m)(size_t, const char *, int),
    void *(*r)(void *, size_t, const char *, int), void (*f)(void *));
int CRYPTO_set_locked_mem_ex_functions(void *(*m)(size_t, const char *, int),
    void (*free_func)(void *));
int CRYPTO_set_mem_debug_functions(
    void (*m)(void *, int, const char *, int, int),
    void (*r)(void *, void *, int, const char *, int, int),
    void (*f)(void *, int), void (*so)(long), long (*go)(void));
void CRYPTO_get_mem_functions(void *(**m)(size_t), void *(**r)(void *, size_t),
    void (**f)(void *));
void CRYPTO_get_locked_mem_functions(void *(**m)(size_t), void (**f)(void *));
void CRYPTO_get_mem_ex_functions(void *(**m)(size_t, const char *, int),
    void *(**r)(void *, size_t, const char *, int), void (**f)(void *));
void CRYPTO_get_locked_mem_ex_functions(void *(**m)(size_t, const char *, int),
    void (**f)(void *));
void CRYPTO_get_mem_debug_functions(
    void (**m)(void *, int, const char *, int, int),
    void (**r)(void *, void *, int, const char *, int, int),
    void (**f)(void *, int), void (**so)(long), long (**go)(void));

#ifndef LIBRESSL_INTERNAL
void *CRYPTO_malloc_locked(int num, const char *file, int line);
void CRYPTO_free_locked(void *ptr);
void *CRYPTO_malloc(int num, const char *file, int line);
char *CRYPTO_strdup(const char *str, const char *file, int line);
void CRYPTO_free(void *ptr);
void *CRYPTO_realloc(void *addr, int num, const char *file, int line);
#endif

void *CRYPTO_realloc_clean(void *addr, int old_num, int num,
    const char *file, int line);
void *CRYPTO_remalloc(void *addr, int num, const char *file, int line);

#ifndef LIBRESSL_INTERNAL
void OPENSSL_cleanse(void *ptr, size_t len);
#endif

void CRYPTO_set_mem_debug_options(long bits);
long CRYPTO_get_mem_debug_options(void);

#define CRYPTO_push_info(info) \
        CRYPTO_push_info_(info, __FILE__, __LINE__);
int CRYPTO_push_info_(const char *info, const char *file, int line);
int CRYPTO_pop_info(void);
int CRYPTO_remove_all_info(void);


/* Default debugging functions (enabled by CRYPTO_malloc_debug_init() macro;
 * used as default in CRYPTO_MDEBUG compilations): */
/* The last argument has the following significance:
 *
 * 0:	called before the actual memory allocation has taken place
 * 1:	called after the actual memory allocation has taken place
 */
void CRYPTO_dbg_malloc(void *addr, int num, const char *file, int line, int before_p)
	__attribute__ ((deprecated));
void CRYPTO_dbg_realloc(void *addr1, void *addr2, int num, const char *file, int line, int before_p)
	__attribute__ ((deprecated));
void CRYPTO_dbg_free(void *addr, int before_p)
	__attribute__ ((deprecated));
/* Tell the debugging code about options.  By default, the following values
 * apply:
 *
 * 0:                           Clear all options.
 * V_CRYPTO_MDEBUG_TIME (1):    Set the "Show Time" option.
 * V_CRYPTO_MDEBUG_THREAD (2):  Set the "Show Thread Number" option.
 * V_CRYPTO_MDEBUG_ALL (3):     1 + 2
 */
void CRYPTO_dbg_set_options(long bits)
	__attribute__ ((deprecated));
long CRYPTO_dbg_get_options(void)
	__attribute__ ((deprecated));


void CRYPTO_mem_leaks_fp(FILE *);
void CRYPTO_mem_leaks(struct bio_st *bio);
/* unsigned long order, char *file, int line, int num_bytes, char *addr */
typedef void *CRYPTO_MEM_LEAK_CB(unsigned long, const char *, int, int, void *);
void CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb);

/* die if we have to */
void OpenSSLDie(const char *file, int line, const char *assertion);
#define OPENSSL_assert(e)       (void)((e) ? 0 : (OpenSSLDie(__FILE__, __LINE__, #e),1))

uint64_t OPENSSL_cpu_caps(void);

int OPENSSL_isservice(void);

void OPENSSL_init(void);

#ifndef LIBRESSL_INTERNAL
/* CRYPTO_memcmp returns zero iff the |len| bytes at |a| and |b| are equal. It
 * takes an amount of time dependent on |len|, but independent of the contents
 * of |a| and |b|. Unlike memcmp, it cannot be used to put elements into a
 * defined order as the return value when a != b is undefined, other than to be
 * non-zero. */
int CRYPTO_memcmp(const void *a, const void *b, size_t len);
#endif

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_CRYPTO_strings(void);

/* Error codes for the CRYPTO functions. */

/* Function codes. */
#define CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX		 100
#define CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID		 103
#define CRYPTO_F_CRYPTO_GET_NEW_LOCKID			 101
#define CRYPTO_F_CRYPTO_SET_EX_DATA			 102
#define CRYPTO_F_DEF_ADD_INDEX				 104
#define CRYPTO_F_DEF_GET_CLASS				 105
#define CRYPTO_F_FIPS_MODE_SET				 109
#define CRYPTO_F_INT_DUP_EX_DATA			 106
#define CRYPTO_F_INT_FREE_EX_DATA			 107
#define CRYPTO_F_INT_NEW_EX_DATA			 108

/* Reason codes. */
#define CRYPTO_R_FIPS_MODE_NOT_SUPPORTED		 101
#define CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK		 100

#ifdef  __cplusplus
}
#endif
#endif
@


1.39
log
@Since a major bump of libcrypto is coming, remove OPENSSL_ia32cap and
OPENSSL_ia32cap_loc; nothing in ports uses them besides embedded copies of
OpenSSL. This opens the `all hell gets loose' window.
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.h,v 1.38 2015/09/13 10:02:49 miod Exp $ */
d117 1
@


1.38
log
@Add a new interface, OPENSSL_cpu_caps(), to return the currently running
cpu's specific hardware capabilities users of libcrypto might be interested
in, as an integer value. This deprecates the existing OPENSSL_ia32cap()
macro and the OPENSSL_ia32cap_loc() function (which returns the pointer so
that you can mess with stuff you shouldn't mess with).

Interpreting the value returned by OPENSSL_cpu_caps() is, of course,
machine-dependent.

Minor version bump for libcrypto.
ok beck@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.h,v 1.37 2015/09/10 16:35:15 jsing Exp $ */
a495 3

unsigned long *OPENSSL_ia32cap_loc(void);
#define OPENSSL_ia32cap (*(OPENSSL_ia32cap_loc()))
@


1.37
log
@Put OPENSSL_cleanse under #ifndef LIBRESSL_INTERNAL.
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.h,v 1.36 2015/09/10 16:07:58 jsing Exp $ */
d499 3
@


1.36
log
@CRYPTO_set_mem_debug_functions() and CRYPTO_set_mem_functions() are already
noops, so neuter the CRYPTO_malloc_init and CRYPTO_malloc_debug_init
macros.

With input from miod@@

ok beck@@ bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.h,v 1.35 2015/06/20 12:01:54 jsing Exp $ */
d441 1
d446 1
d448 1
@


1.35
log
@Put CRYPTO_memcmp() under #ifndef LIBRESSL_INTERNAL.

ok doug@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.h,v 1.34 2015/04/11 16:16:15 deraadt Exp $ */
d301 2
a302 6
/* This is the default callbacks, but we can have others as well:
 * this is needed in Win32 where the application malloc and the
 * library malloc may not be the same.
 */
#define CRYPTO_malloc_init()	CRYPTO_set_mem_functions(\
	malloc, realloc, free)
a308 11

/* Set standard debugging functions (not done by default
 * unless CRYPTO_MDEBUG is defined) */
#define CRYPTO_malloc_debug_init()	do {\
	CRYPTO_set_mem_debug_functions(\
		CRYPTO_dbg_malloc,\
		CRYPTO_dbg_realloc,\
		CRYPTO_dbg_free,\
		CRYPTO_dbg_set_options,\
		CRYPTO_dbg_get_options);\
	} while(0)
@


1.34
log
@Send OPENSSL_issetugid() straight to hell, no final cigarette.

The issetugid() API is supposed to make a strong promise where "0
means it is safe to look at the environment".  Way back in the past
someone on the OpenSSL team responded to the environment access danger
by creating a wrapper called OPENSSL_issetugid, and went to use it a
number of places.  However, by default on systems lacking true
issetugid(), OPENSSL_issetugid returns 0.  0 indicating safely.  False
safety.  Which means OPENSSL_issetugid() fails to make any sort of
promise about safety, in fact it is just the opposite.

Can you believe the OpenSSL team?

This nastiness was noticed over the years, however noone could gain traction
and get it fixed in OpenSSL.  Also see a paragraph about this in
http://www.tedunangst.com/flak/post/worst-common-denominator-programming

ok jsing
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.h,v 1.33 2015/02/07 13:19:15 doug Exp $ */
d515 1
d522 1
@


1.33
log
@Delete a lot of #if 0 code in libressl.

There are a few instances where #if 1 is removed but the code remains.

Based on the following OpenSSL commits.  Some of the commits weren't
strictly deletions so they are going to be split up into separate commits.

6f91b017bbb7140f816721141ac156d1b828a6b3
3d47c1d331fdc7574d2275cda1a630ccdb624b08
dfb56425b68314b2b57e17c82c1df42e7a015132
c8fa2356a00cbaada8963f739e5570298311a060
f16a64d11f55c01f56baa62ebf1dec7f8fe718cb
9ccc00ef6ea65567622e40c49aca43f2c6d79cdb
02a938c953b3e1ced71d9a832de1618f907eb96d
75d0ebef2aef7a2c77b27575b8da898e22f3ccd5
d6fbb194095312f4722c81c9362dbd0de66cb656
6f1a93ad111c7dfe36a09a976c4c009079b19ea1
1a5adcfb5edfe23908b350f8757df405b0f5f71f
8de24b792743d11e1d5a0dcd336a49368750c577
a2b18e657ea1a932d125154f4e13ab2258796d90
8e964419603d2478dfb391c66e7ccb2dcc9776b4
32dfde107636ac9bc62a5b3233fe2a54dbc27008

input + ok jsing@@, miod@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.h,v 1.32 2014/07/10 22:45:56 jsing Exp $ */
a349 2

int OPENSSL_issetugid(void);
@


1.32
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.h,v 1.31 2014/06/24 19:33:10 miod Exp $ */
a143 14

/* Already declared in ossl_typ.h */
#if 0
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
/* Called when a new object is created */
typedef int CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
    int idx, long argl, void *argp);
/* Called when an object is free()ed */
typedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
    int idx, long argl, void *argp);
/* Called when we need to dup an object */
typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from,
    void *from_d, int idx, long argl, void *argp);
#endif
@


1.31
log
@Remove ancient workaround for previous century's compilers in the declaration
of CRYPTO_EX_DATA; riding upon the libcrypto major bump.
@
text
@d1 1
a1 1
/* $OpenBSD: crypto.h,v 1.30 2014/06/12 15:49:27 deraadt Exp $ */
d117 3
a122 2
#include <stdlib.h>

a123 2

#include <stdio.h>
@


1.30
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a274 1
	int dummy; /* gcc is screwing up this data structure :-( */
@


1.29
log
@Add a deprecated attribute to all CRYPTO_dbg_ functions.
ok deraadt@@
@
text
@d1 1
a1 1
/* crypto/crypto.h */
@


1.28
log
@Everything sane has stdio, and FILE *. we don't need ifdefs for this.
ok to firebomb from tedu@@
@
text
@a347 5
/* for library-internal use */
#define MemCheck_on()	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ENABLE)
#define MemCheck_off()	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_DISABLE)
#define is_MemCheck_on() CRYPTO_is_mem_check_on()

d497 6
a502 3
void CRYPTO_dbg_malloc(void *addr, int num, const char *file, int line, int before_p);
void CRYPTO_dbg_realloc(void *addr1, void *addr2, int num, const char *file, int line, int before_p);
void CRYPTO_dbg_free(void *addr, int before_p);
d511 4
a514 2
void CRYPTO_dbg_set_options(long bits);
long CRYPTO_dbg_get_options(void);
@


1.27
log
@define LIBRESSL_INTERNAL, and use it to hide the bad stuff from ourselves
ok beck
@
text
@a123 1
#ifndef OPENSSL_NO_FP_API
a124 1
#endif
a516 1
#ifndef OPENSSL_NO_FP_API
a517 1
#endif
@


1.26
log
@Almost nothing actually needs to include <openssl/e_os2.h>, however by
including it they get <openssl/opensslconf.h>. So instead of pulling in
<openssl/e_os2.h>, just pull in <openssl/opensslconf.h>.

"go ahead" miod@@
@
text
@a318 1

d473 1
d480 1
@


1.25
log
@don't deprecate until at least the base src tree is clean.
@
text
@d122 1
a122 1
#include <openssl/e_os2.h>
@


1.24
log
@Mark the malloc wrapper functions as deprecated so warnings will
happen on their use.
ok miod@@
@
text
@d474 6
a479 10
void *CRYPTO_malloc_locked(int num, const char *file, int line)
    __attribute__((deprecated));
void CRYPTO_free_locked(void *ptr) __attribute__((deprecated));
void *CRYPTO_malloc(int num, const char *file, int line)
    __attribute__((deprecated));
char *CRYPTO_strdup(const char *str, const char *file, int line)
    __attribute__((deprecated));
void CRYPTO_free(void *ptr) __attribute__((deprecated));
void *CRYPTO_realloc(void *addr, int num, const char *file, int line)
    __attribute__((deprecated));
d486 2
a487 2
void CRYPTO_set_mem_debug_options(long bits) __attribute__((deprecated));
long CRYPTO_get_mem_debug_options(void) __attribute__((deprecated));
@


1.23
log
@Remove fips_md_init() macro indirection for digest algorithms, used by the
OpenSSL FIPS module to prevent forbidden digests to be allowed.
No functional change but readability.

ok deraadt@@
@
text
@d474 10
a483 6
void *CRYPTO_malloc_locked(int num, const char *file, int line);
void CRYPTO_free_locked(void *ptr);
void *CRYPTO_malloc(int num, const char *file, int line);
char *CRYPTO_strdup(const char *str, const char *file, int line);
void CRYPTO_free(void *ptr);
void *CRYPTO_realloc(void *addr, int num, const char *file, int line);
d490 2
a491 2
void CRYPTO_set_mem_debug_options(long bits);
long CRYPTO_get_mem_debug_options(void);
@


1.22
log
@More KNF.
@
text
@a535 6
#define fips_md_init(alg) fips_md_init_ctx(alg, alg)

#define fips_md_init_ctx(alg, cx) \
	int alg##_Init(cx##_CTX *c)
#define fips_cipher_abort(alg) while(0)

@


1.21
log
@typo
@
text
@d10 1
a10 1
 *    notice, this list of conditions and the following disclaimer. 
d61 1
a61 1
 * 
d68 1
a68 1
 * 
d75 1
a75 1
 * 
d90 1
a90 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d93 1
a93 1
 * 
d105 1
a105 1
 * 
d113 1
a113 1
 * ECDH support in OpenSSL originally developed by 
@


1.20
log
@Fully kill FIPS API. Forcible certification conflicts with the goals of a
free software project. ok beck deraadt

Ports calling FIPS_mode_set(1): mongodb
@
text
@d171 1
a171 1
/* When changing the CRYPTO_LOCK_* list, be sure to maintin the text lock
@


1.19
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok beck deraadt
@
text
@a533 3
int FIPS_mode(void);
int FIPS_mode_set(int r);

@


1.18
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@a540 15
#ifdef OPENSSL_FIPS
#define fips_md_init_ctx(alg, cx) \
	int alg##_Init(cx##_CTX *c) \
	{ \
	if (FIPS_mode()) OpenSSLDie(__FILE__, __LINE__, \
		"Low level API call to digest " #alg " forbidden in FIPS mode!"); \
	return private_##alg##_Init(c); \
	} \
	int private_##alg##_Init(cx##_CTX *c)

#define fips_cipher_abort(alg) \
	if (FIPS_mode()) OpenSSLDie(__FILE__, __LINE__, \
		"Low level API call to cipher " #alg " forbidden in FIPS mode!")

#else
a543 1
#endif
@


1.17
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a132 4
#ifdef CHARSET_EBCDIC
#include <openssl/ebcdic.h>
#endif

@


1.16
log
@Cope with the removal of openssl/symhacks.h
@
text
@d157 1
a157 1
					int idx, long argl, void *argp);
d160 1
a160 1
					int idx, long argl, void *argp);
d162 2
a163 2
typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d, 
					int idx, long argl, void *argp);
d167 1
a167 2
typedef struct openssl_item_st
	{
d172 1
a172 1
	} OPENSSL_ITEM;
d251 1
a251 2
typedef struct
	{
d254 1
a254 1
	} CRYPTO_dynlock;
d279 1
a279 2
struct crypto_ex_data_st
	{
d282 1
a282 1
	};
d288 1
a288 2
typedef struct crypto_ex_data_func_st
	{
d294 1
a294 1
	} CRYPTO_EX_DATA_FUNCS;
d391 2
a392 2
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func);
d397 1
a397 1
		CRYPTO_EX_DATA *from);
d402 1
a402 1
void *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad,int idx);
d410 9
a418 9
void CRYPTO_lock(int mode, int type,const char *file,int line);
void CRYPTO_set_locking_callback(void (*func)(int mode,int type,
					      const char *file,int line));
void (*CRYPTO_get_locking_callback(void))(int mode,int type,const char *file,
		int line);
void CRYPTO_set_add_lock_callback(int (*func)(int *num,int mount,int type,
					      const char *file, int line));
int (*CRYPTO_get_add_lock_callback(void))(int *num,int mount,int type,
					  const char *file,int line);
d421 1
a421 2
typedef struct crypto_threadid_st
	{
d424 1
a424 1
	} CRYPTO_THREADID;
d441 2
a442 2
int CRYPTO_add_lock(int *pointer,int amount,int type, const char *file,
		    int line);
d450 3
a452 3
struct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback(void))(const char *file,int line);
void (*CRYPTO_get_dynlock_lock_callback(void))(int mode, struct CRYPTO_dynlock_value *l, const char *file,int line);
void (*CRYPTO_get_dynlock_destroy_callback(void))(struct CRYPTO_dynlock_value *l, const char *file,int line);
d456 1
a456 1
int CRYPTO_set_mem_functions(void *(*m)(size_t),void *(*r)(void *,size_t), void (*f)(void *));
d458 10
a467 11
int CRYPTO_set_mem_ex_functions(void *(*m)(size_t,const char *,int),
                                void *(*r)(void *,size_t,const char *,int),
                                void (*f)(void *));
int CRYPTO_set_locked_mem_ex_functions(void *(*m)(size_t,const char *,int),
                                       void (*free_func)(void *));
int CRYPTO_set_mem_debug_functions(void (*m)(void *,int,const char *,int,int),
				   void (*r)(void *,void *,int,const char *,int,int),
				   void (*f)(void *,int),
				   void (*so)(long),
				   long (*go)(void));
void CRYPTO_get_mem_functions(void *(**m)(size_t),void *(**r)(void *, size_t), void (**f)(void *));
d469 8
a476 10
void CRYPTO_get_mem_ex_functions(void *(**m)(size_t,const char *,int),
                                 void *(**r)(void *, size_t,const char *,int),
                                 void (**f)(void *));
void CRYPTO_get_locked_mem_ex_functions(void *(**m)(size_t,const char *,int),
                                        void (**f)(void *));
void CRYPTO_get_mem_debug_functions(void (**m)(void *,int,const char *,int,int),
				    void (**r)(void *,void *,int,const char *,int,int),
				    void (**f)(void *,int),
				    void (**so)(long),
				    long (**go)(void));
d483 4
a486 4
void *CRYPTO_realloc(void *addr,int num, const char *file, int line);
void *CRYPTO_realloc_clean(void *addr,int old_num,int num,const char *file,
			   int line);
void *CRYPTO_remalloc(void *addr,int num, const char *file, int line);
d507 3
a509 3
void CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p);
void CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p);
void CRYPTO_dbg_free(void *addr,int before_p);
d531 1
a531 1
void OpenSSLDie(const char *file,int line,const char *assertion);
@


1.15
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a136 4
/* Resolve problems on some operating systems with symbol names that clash
   one way or another */
#include <openssl/symhacks.h>

@


1.14
log
@resolve conflicts
@
text
@d491 1
a491 1
void CRYPTO_free_locked(void *);
d494 1
a494 1
void CRYPTO_free(void *);
d576 7
@


1.13
log
@resolve conflicts, fix local changes
@
text
@d550 27
d592 1
d598 1
@


1.12
log
@resolve conflicts
@
text
@d3 1
a3 1
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
a221 3
#ifndef OPENSSL_FIPS
#define CRYPTO_NUM_LOCKS		39
#else
a224 1
#endif
d287 1
a287 1
	STACK *sk;
d290 1
d347 8
a354 1
void CRYPTO_malloc_debug_init(void);
d427 17
d447 2
a452 3
void int_CRYPTO_set_do_dynlock_callback(
	void (*do_dynlock_cb)(int mode, int type, const char *file, int line));

a476 4
void CRYPTO_set_mem_info_functions(
	int  (*push_info_fn)(const char *info, const char *file, int line),
	int  (*pop_info_fn)(void),
	int (*remove_all_info_fn)(void));
a532 3
int CRYPTO_dbg_push_info(const char *info, const char *file, int line);
int CRYPTO_dbg_pop_info(void);
int CRYPTO_dbg_remove_all_info(void);
a549 54
#ifdef OPENSSL_FIPS
#define FIPS_ERROR_IGNORED(alg) OpenSSLDie(__FILE__, __LINE__, \
		alg " previous FIPS forbidden algorithm error ignored");

#define FIPS_BAD_ABORT(alg) OpenSSLDie(__FILE__, __LINE__, \
		#alg " Algorithm forbidden in FIPS mode");

#ifdef OPENSSL_FIPS_STRICT
#define FIPS_BAD_ALGORITHM(alg) FIPS_BAD_ABORT(alg)
#else
#define FIPS_BAD_ALGORITHM(alg) \
	{ \
	FIPSerr(FIPS_F_HASH_FINAL,FIPS_R_NON_FIPS_METHOD); \
	ERR_add_error_data(2, "Algorithm=", #alg); \
	return 0; \
	}
#endif

/* Low level digest API blocking macro */

#define FIPS_NON_FIPS_MD_Init(alg) \
	int alg##_Init(alg##_CTX *c) \
		{ \
		if (FIPS_mode()) \
			FIPS_BAD_ALGORITHM(alg) \
		return private_##alg##_Init(c); \
		} \
	int private_##alg##_Init(alg##_CTX *c)

/* For ciphers the API often varies from cipher to cipher and each needs to
 * be treated as a special case. Variable key length ciphers (Blowfish, RC4,
 * CAST) however are very similar and can use a blocking macro.
 */

#define FIPS_NON_FIPS_VCIPHER_Init(alg) \
	void alg##_set_key(alg##_KEY *key, int len, const unsigned char *data) \
		{ \
		if (FIPS_mode()) \
			FIPS_BAD_ABORT(alg) \
		private_##alg##_set_key(key, len, data); \
		} \
	void private_##alg##_set_key(alg##_KEY *key, int len, \
					const unsigned char *data)

#else

#define FIPS_NON_FIPS_VCIPHER_Init(alg) \
	void alg##_set_key(alg##_KEY *key, int len, const unsigned char *data)

#define FIPS_NON_FIPS_MD_Init(alg) \
	int alg##_Init(alg##_CTX *c) 

#endif /* def OPENSSL_FIPS */

a554 3

#define OPENSSL_HAVE_INIT	1
void OPENSSL_init(void);
@


1.11
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d222 1
d224 5
d350 1
a350 8
#define CRYPTO_malloc_debug_init()	do {\
	CRYPTO_set_mem_debug_functions(\
		CRYPTO_dbg_malloc,\
		CRYPTO_dbg_realloc,\
		CRYPTO_dbg_free,\
		CRYPTO_dbg_set_options,\
		CRYPTO_dbg_get_options);\
	} while(0)
d365 1
d430 3
d457 4
d477 1
d517 3
d537 54
d596 3
@


1.10
log
@resolve conflicts
@
text
@d524 1
@


1.9
log
@resolve conflicts
@
text
@d2 53
d111 5
d122 2
d131 1
d156 24
d184 5
a188 5
#define CRYPTO_LOCK_ERR			1
#define CRYPTO_LOCK_EX_DATA		2
#define CRYPTO_LOCK_X509		3
#define CRYPTO_LOCK_X509_INFO		4
#define CRYPTO_LOCK_X509_PKEY		5
d215 8
a222 4
#define CRYPTO_LOCK_HWCRHK		32 /* This is a HACK which will disappear in 0.9.8 */
#define CRYPTO_LOCK_FIPS		33
#define CRYPTO_LOCK_FIPS2		34
#define CRYPTO_NUM_LOCKS		35
d283 1
a283 1
typedef struct crypto_ex_data_st
d287 1
a287 11
	} CRYPTO_EX_DATA;

/* Called when a new object is created */
typedef int CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
					int idx, long argl, void *argp);
/* Called when an object is free()ed */
typedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
					int idx, long argl, void *argp);
/* Called when we need to dup an object */
typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d, 
					int idx, long argl, void *argp);
d319 4
d520 1
a520 53
#define OPENSSL_assert(e)	(void)((e) ? 0 : (OpenSSLDie(__FILE__, __LINE__, #e),1))

#ifdef OPENSSL_FIPS
#define FIPS_ERROR_IGNORED(alg) OpenSSLDie(__FILE__, __LINE__, \
		alg " previous FIPS forbidden algorithm error ignored");

#define FIPS_BAD_ABORT(alg) OpenSSLDie(__FILE__, __LINE__, \
		#alg " Algorithm forbidden in FIPS mode");

#ifdef OPENSSL_FIPS_STRICT
#define FIPS_BAD_ALGORITHM(alg) FIPS_BAD_ABORT(alg)
#else
#define FIPS_BAD_ALGORITHM(alg) \
	{ \
	FIPSerr(FIPS_F_HASH_FINAL,FIPS_R_NON_FIPS_METHOD); \
	ERR_add_error_data(2, "Algorithm=", #alg); \
	return 0; \
	}
#endif

/* Low level digest API blocking macro */

#define FIPS_NON_FIPS_MD_Init(alg) \
	int alg##_Init(alg##_CTX *c) \
		{ \
		if (FIPS_mode()) \
			FIPS_BAD_ALGORITHM(alg) \
		return private_##alg##_Init(c); \
		} \
	int private_##alg##_Init(alg##_CTX *c)

/* For ciphers the API often varies from cipher to cipher and each needs to
 * be treated as a special case. Variable key length ciphers (Blowfish, RC4,
 * CAST) however are very similar and can use a blocking macro.
 */

#define FIPS_NON_FIPS_VCIPHER_Init(alg) \
	void alg##_set_key(alg##_KEY *key, int len, const unsigned char *data) \
		{ \
		if (FIPS_mode()) \
			FIPS_BAD_ABORT(alg) \
		private_##alg##_set_key(key, len, data); \
		} \
	void private_##alg##_set_key(alg##_KEY *key, int len, \
					const unsigned char *data)

#else

#define FIPS_NON_FIPS_VCIPHER_Init(alg) \
	void alg##_set_key(alg##_KEY *key, int len, const unsigned char *data)

#define FIPS_NON_FIPS_MD_Init(alg) \
	int alg##_Init(alg##_CTX *c) 
d522 2
a523 1
#endif /* def OPENSSL_FIPS */
@


1.8
log
@resolve conflicts
@
text
@d437 1
a437 1
#define OPENSSL_assert(e)	((e) ? (void)0 : OpenSSLDie(__FILE__, __LINE__, #e))
a439 3
int FIPS_mode(void);
void *FIPS_rand_check(void);

@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d131 3
a133 1
#define CRYPTO_NUM_LOCKS		33
d438 57
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d99 5
a103 5
#define	CRYPTO_LOCK_ERR			1
#define	CRYPTO_LOCK_EX_DATA		2
#define	CRYPTO_LOCK_X509		3
#define	CRYPTO_LOCK_X509_INFO		4
#define	CRYPTO_LOCK_X509_PKEY		5
d109 23
a131 21
#define	CRYPTO_LOCK_X509_STORE		11
#define	CRYPTO_LOCK_SSL_CTX		12
#define	CRYPTO_LOCK_SSL_CERT		13
#define	CRYPTO_LOCK_SSL_SESSION		14
#define	CRYPTO_LOCK_SSL_SESS_CERT	15
#define	CRYPTO_LOCK_SSL			16
#define	CRYPTO_LOCK_RAND		17
#define	CRYPTO_LOCK_RAND2		18
#define	CRYPTO_LOCK_MALLOC		19
#define	CRYPTO_LOCK_BIO			20
#define	CRYPTO_LOCK_GETHOSTBYNAME	21
#define	CRYPTO_LOCK_GETSERVBYNAME	22
#define	CRYPTO_LOCK_READDIR		23
#define	CRYPTO_LOCK_RSA_BLINDING	24
#define	CRYPTO_LOCK_DH			25
#define	CRYPTO_LOCK_MALLOC2		26
#define	CRYPTO_LOCK_DSO			27
#define	CRYPTO_LOCK_DYNLOCK		28
#define	CRYPTO_LOCK_ENGINE		29
#define	CRYPTO_LOCK_UI			30
#define	CRYPTO_NUM_LOCKS		31
d153 1
a153 1
#define	CRYPTO_w_unlock(a)
d283 2
d387 2
d391 2
d433 3
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d64 1
a64 1
#ifndef NO_FP_API
d93 1
d100 1
a100 1
#define	CRYPTO_LOCK_ERR_HASH		2
d116 14
a129 12
#define	CRYPTO_LOCK_MALLOC		18
#define	CRYPTO_LOCK_BIO			19
#define	CRYPTO_LOCK_GETHOSTBYNAME	20
#define	CRYPTO_LOCK_GETSERVBYNAME	21
#define	CRYPTO_LOCK_READDIR		22
#define	CRYPTO_LOCK_RSA_BLINDING	23
#define	CRYPTO_LOCK_DH			24
#define	CRYPTO_LOCK_MALLOC2		25
#define	CRYPTO_LOCK_DSO			26
#define	CRYPTO_LOCK_DYNLOCK		27
#define	CRYPTO_LOCK_ENGINE		28
#define	CRYPTO_NUM_LOCKS		29
d136 1
a136 1
#ifndef NO_LOCKING
d230 10
d296 20
a315 2
int CRYPTO_get_ex_new_index(int idx, STACK_OF(CRYPTO_EX_DATA_FUNCS) **skp, long argl, void *argp,
	     CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
d317 4
a320 5
void *CRYPTO_get_ex_data(CRYPTO_EX_DATA *ad,int idx);
int CRYPTO_dup_ex_data(STACK_OF(CRYPTO_EX_DATA_FUNCS) *meth, CRYPTO_EX_DATA *to,
	     CRYPTO_EX_DATA *from);
void CRYPTO_free_ex_data(STACK_OF(CRYPTO_EX_DATA_FUNCS) *meth, void *obj, CRYPTO_EX_DATA *ad);
void CRYPTO_new_ex_data(STACK_OF(CRYPTO_EX_DATA_FUNCS) *meth, void *obj, CRYPTO_EX_DATA *ad);
d355 5
d367 5
d394 3
a404 1

d408 4
a411 4
 * 0:	Clear all options.
 * 1:	Set the "Show Time" option.
 * 2:	Set the "Show Thread Number" option.
 * 3:	1 + 2
d416 2
a417 1
#ifndef NO_FP_API
d422 2
a423 1
void CRYPTO_mem_leaks_cb(void (*cb)(unsigned long, const char *, int, int, void *));
a424 1
void ERR_load_CRYPTO_strings(void);
d430 1
d439 5
a451 1

@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d281 2
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@a61 4
#ifdef  __cplusplus
extern "C" {
#endif

d76 6
a81 2
#if defined(VMS) || defined(__VMS)
#include "vms_idhacks.h"
a83 1

d123 4
a126 1
#define	CRYPTO_NUM_LOCKS		26
d154 11
d246 5
a250 5
		(void (*)())CRYPTO_dbg_malloc,\
		(void (*)())CRYPTO_dbg_realloc,\
		(void (*)())CRYPTO_dbg_free,\
		(void (*)())CRYPTO_dbg_set_options,\
		(long (*)())CRYPTO_dbg_get_options);\
d265 2
a266 2
#define Malloc(num)	CRYPTO_malloc((int)num,__FILE__,__LINE__)
#define Realloc(addr,num) \
d268 1
a268 1
#define Remalloc(addr,num) \
d270 2
a271 2
#define FreeFunc	CRYPTO_free
#define Free(addr)	CRYPTO_free(addr)
d273 3
a275 8
#define Malloc_locked(num) CRYPTO_malloc_locked((int)num,__FILE__,__LINE__)
#define Free_locked(addr) CRYPTO_free_locked(addr)


/* Case insensiteve linking causes problems.... */
#if defined(WIN16) || defined(VMS)
#define ERR_load_CRYPTO_strings	ERR_load_CRYPTOlib_strings
#endif
d309 10
d323 5
a327 1
int CRYPTO_set_mem_debug_functions(void (*m)(),void (*r)(),void (*f)(),void (*so)(),long (*go)());
d330 5
a334 1
void CRYPTO_get_mem_debug_functions(void (**m)(),void (**r)(),void (**f)(),void (**so)(),long (**go)());
d377 1
a377 1
void CRYPTO_mem_leaks_cb(void (*cb)());
d390 1
d395 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d66 2
d73 1
d80 5
d122 3
a124 1
#define	CRYPTO_NUM_LOCKS		24
d160 10
a169 8
/*
typedef struct crypto_mem_st
	{
	char *(*malloc_func)();
	char *(*realloc_func)();
	void (*free_func)();
	} CRYPTO_MEM_FUNC;
*/
d180 10
d191 2
a192 1
 * The current classes are SSL_CTX, SSL, SSL_SESION, and a few more */
d196 4
a199 11
	char *argp;	/* Arbitary char * */
	/* Called when a new object is created */
	int (*new_func)(/*char *obj,
			char *item,int index,long argl,char *argp*/);
	/* Called when this object is free()ed */
	void (*free_func)(/*char *obj,
			char *item,int index,long argl,char *argp*/);

	/* Called when we need to dup this one */
	int (*dup_func)(/*char *obj_to,char *obj_from,
			char **new,int index,long argl,char *argp*/);
d202 2
d215 5
a219 1
/* Use this for win32 DLL's */
d221 1
a221 12
	(char *(*)())malloc,\
	(char *(*)())realloc,\
	(void (*)())free)

#ifdef CRYPTO_MDEBUG_ALL
# ifndef CRYPTO_MDEBUG_TIME
#  define CRYPTO_MDEBUG_TIME
# endif
# ifndef CRYPTO_MDEBUG_THREAD
#  define CRYPTO_MDEBUG_THREAD
# endif
#endif
d223 1
a223 1
#if defined CRYPTO_MDEBUG_TIME || defined CRYPTO_MDEBUG_THREAD
d229 15
a243 1
#ifdef CRYPTO_MDEBUG
d246 2
d250 3
a252 1
#define Malloc(num)	CRYPTO_dbg_malloc((int)num,__FILE__,__LINE__)
d254 1
a254 1
	CRYPTO_dbg_realloc((char *)addr,(int)num,__FILE__,__LINE__)
d256 1
a256 14
	CRYPTO_dbg_remalloc((char **)addr,(int)num,__FILE__,__LINE__)
#define FreeFunc	CRYPTO_dbg_free
#define Free(addr)	CRYPTO_dbg_free(addr)
#define Malloc_locked(num) CRYPTO_malloc_locked((int)num)
#define Free_locked(addr) CRYPTO_free_locked(addr)
#else
#define MemCheck_start()
#define MemCheck_stop()
#define MemCheck_on()
#define MemCheck_off()
#define Remalloc	CRYPTO_remalloc
#if defined(WIN32) || defined(MFUNC)
#define Malloc		CRYPTO_malloc
#define Realloc(a,n)	CRYPTO_realloc(a,(n))
d259 2
a260 1
#define Malloc_locked	CRYPTO_malloc_locked
d262 1
a262 9
#else
#define Malloc		malloc
#define Realloc		realloc
#define FreeFunc	free
#define Free(addr)	free(addr)
#define Malloc_locked	malloc
#define Free_locked(addr) free(addr)
#endif /* WIN32 || MFUNC */
#endif /* MDEBUG */
d273 8
a280 7
int CRYPTO_get_ex_new_index(int idx,STACK **sk,long argl,char *argp,
	int (*new_func)(),int (*dup_func)(),void (*free_func)());
int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad,int idx,char *val);
char *CRYPTO_get_ex_data(CRYPTO_EX_DATA *ad,int idx);
int CRYPTO_dup_ex_data(STACK *meth,CRYPTO_EX_DATA *from,CRYPTO_EX_DATA *to);
void CRYPTO_free_ex_data(STACK *meth,char *obj,CRYPTO_EX_DATA *ad);
void CRYPTO_new_ex_data(STACK *meth, char *obj, CRYPTO_EX_DATA *ad);
a281 1
int CRYPTO_mem_ctrl(int mode);
d301 8
a308 4
void CRYPTO_set_mem_functions(char *(*m)(),char *(*r)(), void (*free_func)());
void CRYPTO_get_mem_functions(char *(**m)(),char *(**r)(), void (**f)());
void CRYPTO_set_locked_mem_functions(char *(*m)(), void (*free_func)());
void CRYPTO_get_locked_mem_functions(char *(**m)(), void (**f)());
d310 1
a310 1
void *CRYPTO_malloc_locked(int num);
d312 1
a312 1
void *CRYPTO_malloc(int num);
d314 31
a344 2
void *CRYPTO_realloc(void *addr,int num);
void *CRYPTO_remalloc(void *addr,int num);
a345 4
void *CRYPTO_dbg_malloc(int num,const char *file,int line);
void *CRYPTO_dbg_realloc(void *addr,int num,const char *file,int line);
void CRYPTO_dbg_free(void *);
void *CRYPTO_dbg_remalloc(void *addr,int num,const char *file,int line);
d353 1
a353 1
void ERR_load_CRYPTO_strings(void );
@


1.1
log
@Initial revision
@
text
@d66 6
a71 1
#include "stack.h"
d73 5
d80 1
a80 2
#define SSLEAY_VERSION_NUMBER	0x0902	/* Version 0.5.1c would be 0513 */

d85 1
d105 10
a114 7
#define	CRYPTO_LOCK_SSL			15
#define	CRYPTO_LOCK_RAND		16
#define	CRYPTO_LOCK_MALLOC		17
#define	CRYPTO_LOCK_BIO			18
#define	CRYPTO_LOCK_BIO_GETHOSTBYNAME	19
#define CRYPTO_LOCK_RSA_BLINDING	20
#define	CRYPTO_NUM_LOCKS		21
d121 1
d133 7
a139 1

d145 4
a148 2
#define CRYPTO_MEM_CHECK_OFF	0x0
#define CRYPTO_MEM_CHECK_ON	0x1
d203 15
d219 4
d229 3
a231 1
#define Free(addr)	CRYPTO_dbg_free((char *)(addr))
d233 4
d240 1
a240 1
#define Realloc(a,n)	CRYPTO_realloc((char *)(a),(n))
d242 3
a244 1
#define Free(addr)	CRYPTO_free((char *)(addr))
d249 3
a251 1
#define Free(addr)	free((char *)(addr))
d256 1
a256 1
#ifdef WIN16
a259 1
#ifndef NOPROTO
d261 1
a261 1
char *SSLeay_version(int type);
d274 6
a279 4
void CRYPTO_lock(int mode, int type,char *file,int line);
void CRYPTO_set_locking_callback(void (*func)(int mode,int type,char *file,
		int line));
void (*CRYPTO_get_locking_callback(void))(int mode,int type,char *file,
d281 4
a284 4
void CRYPTO_set_add_lock_callback(int (*func)(int *num,int mount,
		int type,char *file, int line));
int (*CRYPTO_get_add_lock_callback(void))(int *num,int mount,
		int type,char *file,int line);
d288 3
a290 2
char *CRYPTO_get_lock_name(int type);
int CRYPTO_add_lock(int *pointer,int amount,int type, char *file,int line);
d294 2
d297 11
a307 9
char *CRYPTO_malloc(int num);
char *CRYPTO_realloc(char *addr,int num);
void CRYPTO_free(char *);
char *CRYPTO_remalloc(char *addr,int num);

char *CRYPTO_dbg_malloc(int num,char *file,int line);
char *CRYPTO_dbg_realloc(char *addr,int num,char *file,int line);
void CRYPTO_dbg_free(char *);
char *CRYPTO_dbg_remalloc(char *addr,int num,char *file,int line);
d317 4
a320 44
#else 

int CRYPTO_get_ex_new_index();
int CRYPTO_set_ex_data();
char *CRYPTO_get_ex_data();
int CRYPTO_dup_ex_data();
void CRYPTO_free_ex_data();
void CRYPTO_new_ex_data();

int CRYPTO_mem_ctrl();
char *SSLeay_version();
unsigned long SSLeay();

int CRYPTO_get_new_lockid();
void CRYPTO_lock();
void CRYPTO_set_locking_callback();
void (*CRYPTO_get_locking_callback())();
void CRYPTO_set_add_lock_callback();
int (*CRYPTO_get_add_lock_callback())();
void CRYPTO_set_id_callback();
unsigned long (*CRYPTO_get_id_callback())();
unsigned long CRYPTO_thread_id();
char *CRYPTO_get_lock_name();
int CRYPTO_add_lock();

void CRYPTO_set_mem_functions();
void CRYPTO_get_mem_functions();
char *CRYPTO_malloc();
char *CRYPTO_realloc();
void CRYPTO_free();
char *CRYPTO_remalloc();
char *CRYPTO_dbg_remalloc();
char *CRYPTO_dbg_malloc();
char *CRYPTO_dbg_realloc();
void CRYPTO_dbg_free();
#ifndef NO_FP_API
void CRYPTO_mem_leaks_fp();
#endif
void CRYPTO_mem_leaks();
void CRYPTO_mem_leaks_cb();

void ERR_load_CRYPTO_strings();

#endif
a321 1
/* BEGIN ERROR CODES */
d330 1
a330 1
 
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a61 18
#include <stdlib.h>

#ifndef OPENSSL_NO_FP_API
#include <stdio.h>
#endif

#include <openssl/stack.h>
#include <openssl/safestack.h>
#include <openssl/opensslv.h>

#ifdef CHARSET_EBCDIC
#include <openssl/ebcdic.h>
#endif

/* Resolve problems on some operating systems with symbol names that clash
   one way or another */
#include <openssl/symhacks.h>

d66 2
a67 1
/* Backward compatibility to SSLeay */
d70 2
a71 1
#define SSLEAY_VERSION_NUMBER	OPENSSL_VERSION_NUMBER
a75 2
#define SSLEAY_PLATFORM		4
#define SSLEAY_DIR		5
d82 1
a82 1
#define	CRYPTO_LOCK_EX_DATA		2
d95 7
a101 17
#define	CRYPTO_LOCK_SSL_SESS_CERT	15
#define	CRYPTO_LOCK_SSL			16
#define	CRYPTO_LOCK_RAND		17
#define	CRYPTO_LOCK_RAND2		18
#define	CRYPTO_LOCK_MALLOC		19
#define	CRYPTO_LOCK_BIO			20
#define	CRYPTO_LOCK_GETHOSTBYNAME	21
#define	CRYPTO_LOCK_GETSERVBYNAME	22
#define	CRYPTO_LOCK_READDIR		23
#define	CRYPTO_LOCK_RSA_BLINDING	24
#define	CRYPTO_LOCK_DH			25
#define	CRYPTO_LOCK_MALLOC2		26
#define	CRYPTO_LOCK_DSO			27
#define	CRYPTO_LOCK_DYNLOCK		28
#define	CRYPTO_LOCK_ENGINE		29
#define	CRYPTO_LOCK_UI			30
#define	CRYPTO_NUM_LOCKS		31
a107 1
#ifndef OPENSSL_NO_LOCKING
d119 1
a120 18
#else
#define CRYPTO_w_lock(a)
#define	CRYPTO_w_unlock(a)
#define CRYPTO_r_lock(a)
#define CRYPTO_r_unlock(a)
#define CRYPTO_add(a,b,c)	((*(a))+=(b))
#endif

/* Some applications as well as some parts of OpenSSL need to allocate
   and deallocate locks in a dynamic fashion.  The following typedef
   makes this possible in a type-safe manner.  */
/* struct CRYPTO_dynlock_value has to be defined by the application. */
typedef struct
	{
	int references;
	struct CRYPTO_dynlock_value *data;
	} CRYPTO_dynlock;

d125 2
a126 14
#define CRYPTO_MEM_CHECK_OFF	0x0	/* an enume */
#define CRYPTO_MEM_CHECK_ON	0x1	/* a bit */
#define CRYPTO_MEM_CHECK_ENABLE	0x2	/* a bit */
#define CRYPTO_MEM_CHECK_DISABLE 0x3	/* an enume */

/* The following are bit values to turn on or off options connected to the
 * malloc checking functionality */

/* Adds time to the memory checking information */
#define V_CRYPTO_MDEBUG_TIME	0x1 /* a bit */
/* Adds thread number to the memory checking information */
#define V_CRYPTO_MDEBUG_THREAD	0x2 /* a bit */

#define V_CRYPTO_MDEBUG_ALL (V_CRYPTO_MDEBUG_TIME | V_CRYPTO_MDEBUG_THREAD)
d128 8
a145 10
/* Called when a new object is created */
typedef int CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
					int idx, long argl, void *argp);
/* Called when an object is free()ed */
typedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
					int idx, long argl, void *argp);
/* Called when we need to dup an object */
typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d, 
					int idx, long argl, void *argp);

d147 1
a147 2
 * The current classes are SSL_CTX, SSL, SSL_SESSION, and a few more */

d151 11
a161 4
	void *argp;	/* Arbitary void * */
	CRYPTO_EX_new *new_func;
	CRYPTO_EX_free *free_func;
	CRYPTO_EX_dup *dup_func;
a163 2
DECLARE_STACK_OF(CRYPTO_EX_DATA_FUNCS)

a173 10
#define CRYPTO_EX_INDEX_RSA		6
#define CRYPTO_EX_INDEX_DSA		7
#define CRYPTO_EX_INDEX_DH		8
#define CRYPTO_EX_INDEX_ENGINE		9
#define CRYPTO_EX_INDEX_X509		10
#define CRYPTO_EX_INDEX_UI		11

/* Dynamically assigned indexes start from this value (don't use directly, use
 * via CRYPTO_ex_data_new_class). */
#define CRYPTO_EX_INDEX_USER		100
d175 1
a175 5

/* This is the default callbacks, but we can have others as well:
 * this is needed in Win32 where the application malloc and the
 * library malloc may not be the same.
 */
d177 30
a206 6
	malloc, realloc, free)

#if defined CRYPTO_MDEBUG_ALL || defined CRYPTO_MDEBUG_TIME || defined CRYPTO_MDEBUG_THREAD
# ifndef CRYPTO_MDEBUG /* avoid duplicate #define */
#  define CRYPTO_MDEBUG
# endif
d209 1
a209 34
/* Set standard debugging functions (not done by default
 * unless CRYPTO_MDEBUG is defined) */
#define CRYPTO_malloc_debug_init()	do {\
	CRYPTO_set_mem_debug_functions(\
		CRYPTO_dbg_malloc,\
		CRYPTO_dbg_realloc,\
		CRYPTO_dbg_free,\
		CRYPTO_dbg_set_options,\
		CRYPTO_dbg_get_options);\
	} while(0)

int CRYPTO_mem_ctrl(int mode);
int CRYPTO_is_mem_check_on(void);

/* for applications */
#define MemCheck_start() CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON)
#define MemCheck_stop()	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_OFF)

/* for library-internal use */
#define MemCheck_on()	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ENABLE)
#define MemCheck_off()	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_DISABLE)
#define is_MemCheck_on() CRYPTO_is_mem_check_on()

#define OPENSSL_malloc(num)	CRYPTO_malloc((int)num,__FILE__,__LINE__)
#define OPENSSL_realloc(addr,num) \
	CRYPTO_realloc((char *)addr,(int)num,__FILE__,__LINE__)
#define OPENSSL_remalloc(addr,num) \
	CRYPTO_remalloc((char **)addr,(int)num,__FILE__,__LINE__)
#define OPENSSL_freeFunc	CRYPTO_free
#define OPENSSL_free(addr)	CRYPTO_free(addr)

#define OPENSSL_malloc_locked(num) \
	CRYPTO_malloc_locked((int)num,__FILE__,__LINE__)
#define OPENSSL_free_locked(addr) CRYPTO_free_locked(addr)
d211 1
a211 2

const char *SSLeay_version(int type);
d214 7
a220 27
int OPENSSL_issetugid(void);

/* An opaque type representing an implementation of "ex_data" support */
typedef struct st_CRYPTO_EX_DATA_IMPL	CRYPTO_EX_DATA_IMPL;
/* Return an opaque pointer to the current "ex_data" implementation */
const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void);
/* Sets the "ex_data" implementation to be used (if it's not too late) */
int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i);
/* Get a new "ex_data" class, and return the corresponding "class_index" */
int CRYPTO_ex_data_new_class(void);
/* Within a given class, get/register a new index */
int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,
		CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
		CRYPTO_EX_free *free_func);
/* Initialise/duplicate/free CRYPTO_EX_DATA variables corresponding to a given
 * class (invokes whatever per-class callbacks are applicable) */
int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);
int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
		CRYPTO_EX_DATA *from);
void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);
/* Get/set data in a CRYPTO_EX_DATA variable corresponding to a particular index
 * (relative to the class type involved) */
int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val);
void *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad,int idx);
/* This function cleans up all "ex_data" state. It mustn't be called under
 * potential race-conditions. */
void CRYPTO_cleanup_all_ex_data(void);
d222 1
d224 4
a227 6

int CRYPTO_num_locks(void); /* return CRYPTO_NUM_LOCKS (shared libs!) */
void CRYPTO_lock(int mode, int type,const char *file,int line);
void CRYPTO_set_locking_callback(void (*func)(int mode,int type,
					      const char *file,int line));
void (*CRYPTO_get_locking_callback(void))(int mode,int type,const char *file,
d229 4
a232 4
void CRYPTO_set_add_lock_callback(int (*func)(int *num,int mount,int type,
					      const char *file, int line));
int (*CRYPTO_get_add_lock_callback(void))(int *num,int mount,int type,
					  const char *file,int line);
d236 2
a237 78
const char *CRYPTO_get_lock_name(int type);
int CRYPTO_add_lock(int *pointer,int amount,int type, const char *file,
		    int line);

int CRYPTO_get_new_dynlockid(void);
void CRYPTO_destroy_dynlockid(int i);
struct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i);
void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*dyn_create_function)(const char *file, int line));
void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)(int mode, struct CRYPTO_dynlock_value *l, const char *file, int line));
void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)(struct CRYPTO_dynlock_value *l, const char *file, int line));
struct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback(void))(const char *file,int line);
void (*CRYPTO_get_dynlock_lock_callback(void))(int mode, struct CRYPTO_dynlock_value *l, const char *file,int line);
void (*CRYPTO_get_dynlock_destroy_callback(void))(struct CRYPTO_dynlock_value *l, const char *file,int line);

/* CRYPTO_set_mem_functions includes CRYPTO_set_locked_mem_functions --
 * call the latter last if you need different functions */
int CRYPTO_set_mem_functions(void *(*m)(size_t),void *(*r)(void *,size_t), void (*f)(void *));
int CRYPTO_set_locked_mem_functions(void *(*m)(size_t), void (*free_func)(void *));
int CRYPTO_set_mem_ex_functions(void *(*m)(size_t,const char *,int),
                                void *(*r)(void *,size_t,const char *,int),
                                void (*f)(void *));
int CRYPTO_set_locked_mem_ex_functions(void *(*m)(size_t,const char *,int),
                                       void (*free_func)(void *));
int CRYPTO_set_mem_debug_functions(void (*m)(void *,int,const char *,int,int),
				   void (*r)(void *,void *,int,const char *,int,int),
				   void (*f)(void *,int),
				   void (*so)(long),
				   long (*go)(void));
void CRYPTO_get_mem_functions(void *(**m)(size_t),void *(**r)(void *, size_t), void (**f)(void *));
void CRYPTO_get_locked_mem_functions(void *(**m)(size_t), void (**f)(void *));
void CRYPTO_get_mem_ex_functions(void *(**m)(size_t,const char *,int),
                                 void *(**r)(void *, size_t,const char *,int),
                                 void (**f)(void *));
void CRYPTO_get_locked_mem_ex_functions(void *(**m)(size_t,const char *,int),
                                        void (**f)(void *));
void CRYPTO_get_mem_debug_functions(void (**m)(void *,int,const char *,int,int),
				    void (**r)(void *,void *,int,const char *,int,int),
				    void (**f)(void *,int),
				    void (**so)(long),
				    long (**go)(void));

void *CRYPTO_malloc_locked(int num, const char *file, int line);
void CRYPTO_free_locked(void *);
void *CRYPTO_malloc(int num, const char *file, int line);
void CRYPTO_free(void *);
void *CRYPTO_realloc(void *addr,int num, const char *file, int line);
void *CRYPTO_remalloc(void *addr,int num, const char *file, int line);

void CRYPTO_set_mem_debug_options(long bits);
long CRYPTO_get_mem_debug_options(void);

#define CRYPTO_push_info(info) \
        CRYPTO_push_info_(info, __FILE__, __LINE__);
int CRYPTO_push_info_(const char *info, const char *file, int line);
int CRYPTO_pop_info(void);
int CRYPTO_remove_all_info(void);


/* Default debugging functions (enabled by CRYPTO_malloc_debug_init() macro;
 * used as default in CRYPTO_MDEBUG compilations): */
/* The last argument has the following significance:
 *
 * 0:	called before the actual memory allocation has taken place
 * 1:	called after the actual memory allocation has taken place
 */
void CRYPTO_dbg_malloc(void *addr,int num,const char *file,int line,int before_p);
void CRYPTO_dbg_realloc(void *addr1,void *addr2,int num,const char *file,int line,int before_p);
void CRYPTO_dbg_free(void *addr,int before_p);
/* Tell the debugging code about options.  By default, the following values
 * apply:
 *
 * 0:                           Clear all options.
 * V_CRYPTO_MDEBUG_TIME (1):    Set the "Show Time" option.
 * V_CRYPTO_MDEBUG_THREAD (2):  Set the "Show Thread Number" option.
 * V_CRYPTO_MDEBUG_ALL (3):     1 + 2
 */
void CRYPTO_dbg_set_options(long bits);
long CRYPTO_dbg_get_options(void);
d239 2
d242 10
a251 1
#ifndef OPENSSL_NO_FP_API
d256 5
a260 2
typedef void *CRYPTO_MEM_LEAK_CB(unsigned long, const char *, int, int, void *);
void CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb);
d262 42
a305 5
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_CRYPTO_strings(void);

a309 1
#define CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID		 103
a311 5
#define CRYPTO_F_DEF_ADD_INDEX				 104
#define CRYPTO_F_DEF_GET_CLASS				 105
#define CRYPTO_F_INT_DUP_EX_DATA			 106
#define CRYPTO_F_INT_FREE_EX_DATA			 107
#define CRYPTO_F_INT_NEW_EX_DATA			 108
d314 1
a314 2
#define CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK		 100

d319 1
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d99 5
a103 5
#define CRYPTO_LOCK_ERR			1
#define CRYPTO_LOCK_EX_DATA		2
#define CRYPTO_LOCK_X509		3
#define CRYPTO_LOCK_X509_INFO		4
#define CRYPTO_LOCK_X509_PKEY		5
d109 21
a129 23
#define CRYPTO_LOCK_X509_STORE		11
#define CRYPTO_LOCK_SSL_CTX		12
#define CRYPTO_LOCK_SSL_CERT		13
#define CRYPTO_LOCK_SSL_SESSION		14
#define CRYPTO_LOCK_SSL_SESS_CERT	15
#define CRYPTO_LOCK_SSL			16
#define CRYPTO_LOCK_SSL_METHOD		17
#define CRYPTO_LOCK_RAND		18
#define CRYPTO_LOCK_RAND2		19
#define CRYPTO_LOCK_MALLOC		20
#define CRYPTO_LOCK_BIO			21
#define CRYPTO_LOCK_GETHOSTBYNAME	22
#define CRYPTO_LOCK_GETSERVBYNAME	23
#define CRYPTO_LOCK_READDIR		24
#define CRYPTO_LOCK_RSA_BLINDING	25
#define CRYPTO_LOCK_DH			26
#define CRYPTO_LOCK_MALLOC2		27
#define CRYPTO_LOCK_DSO			28
#define CRYPTO_LOCK_DYNLOCK		29
#define CRYPTO_LOCK_ENGINE		30
#define CRYPTO_LOCK_UI			31
#define CRYPTO_LOCK_HWCRHK		32 /* This is a HACK which will disappear in 0.9.8 */
#define CRYPTO_NUM_LOCKS		33
d151 1
a151 1
#define CRYPTO_w_unlock(a)
a280 2
#define OPENSSL_realloc_clean(addr,old_num,num) \
	CRYPTO_realloc_clean(addr,old_num,num,__FILE__,__LINE__)
a382 2
void *CRYPTO_realloc_clean(void *addr,int old_num,int num,const char *file,
			   int line);
a384 2
void OPENSSL_cleanse(void *ptr, size_t len);

a424 3
/* die if we have to */
void OpenSSLDie(const char *file,int line,const char *assertion);
#define OPENSSL_assert(e)	((e) ? (void)0 : OpenSSLDie(__FILE__, __LINE__, #e))
@


1.1.1.4
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d131 1
a131 3
#define CRYPTO_LOCK_FIPS		33
#define CRYPTO_LOCK_FIPS2		34
#define CRYPTO_NUM_LOCKS		35
a435 57

#ifdef OPENSSL_FIPS
int FIPS_mode(void);
void *FIPS_rand_check(void);

#define FIPS_ERROR_IGNORED(alg) OpenSSLDie(__FILE__, __LINE__, \
		alg " previous FIPS forbidden algorithm error ignored");

#define FIPS_BAD_ABORT(alg) OpenSSLDie(__FILE__, __LINE__, \
		#alg " Algorithm forbidden in FIPS mode");

#ifdef OPENSSL_FIPS_STRICT
#define FIPS_BAD_ALGORITHM(alg) FIPS_BAD_ABORT(alg)
#else
#define FIPS_BAD_ALGORITHM(alg) \
	{ \
	FIPSerr(FIPS_F_HASH_FINAL,FIPS_R_NON_FIPS_METHOD); \
	ERR_add_error_data(2, "Algorithm=", #alg); \
	return 0; \
	}
#endif

/* Low level digest API blocking macro */

#define FIPS_NON_FIPS_MD_Init(alg) \
	int alg##_Init(alg##_CTX *c) \
		{ \
		if (FIPS_mode()) \
			FIPS_BAD_ALGORITHM(alg) \
		return private_##alg##_Init(c); \
		} \
	int private_##alg##_Init(alg##_CTX *c)

/* For ciphers the API often varies from cipher to cipher and each needs to
 * be treated as a special case. Variable key length ciphers (Blowfish, RC4,
 * CAST) however are very similar and can use a blocking macro.
 */

#define FIPS_NON_FIPS_VCIPHER_Init(alg) \
	void alg##_set_key(alg##_KEY *key, int len, const unsigned char *data) \
		{ \
		if (FIPS_mode()) \
			FIPS_BAD_ABORT(alg) \
		private_##alg##_set_key(key, len, data); \
		} \
	void private_##alg##_set_key(alg##_KEY *key, int len, \
					const unsigned char *data)

#else

#define FIPS_NON_FIPS_VCIPHER_Init(alg) \
	void alg##_set_key(alg##_KEY *key, int len, const unsigned char *data)

#define FIPS_NON_FIPS_MD_Init(alg) \
	int alg##_Init(alg##_CTX *c) 

#endif /* def OPENSSL_FIPS */
@


1.1.1.5
log
@import of openssl-0.9.7j
@
text
@d437 1
a437 1
#define OPENSSL_assert(e)	(void)((e) ? 0 : (OpenSSLDie(__FILE__, __LINE__, #e),1))
d440 3
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@a1 53
/* ====================================================================
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
a57 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECDH support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
a63 2
#include <openssl/e_os2.h>

a70 1
#include <openssl/ossl_typ.h>
a94 24
/* Already declared in ossl_typ.h */
#if 0
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
/* Called when a new object is created */
typedef int CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
					int idx, long argl, void *argp);
/* Called when an object is free()ed */
typedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
					int idx, long argl, void *argp);
/* Called when we need to dup an object */
typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from, void *from_d, 
					int idx, long argl, void *argp);
#endif

/* A generic structure to pass assorted data in a expandable way */
typedef struct openssl_item_st
	{
	int code;
	void *value;		/* Not used for flag attributes */
	size_t value_size;	/* Max size of value for output, length for input */
	size_t *value_length;	/* Returned length of value for output */
	} OPENSSL_ITEM;


d99 5
a103 5
#define	CRYPTO_LOCK_ERR			1
#define	CRYPTO_LOCK_EX_DATA		2
#define	CRYPTO_LOCK_X509		3
#define	CRYPTO_LOCK_X509_INFO		4
#define	CRYPTO_LOCK_X509_PKEY		5
d130 4
a133 8
#define CRYPTO_LOCK_ECDSA               32
#define CRYPTO_LOCK_EC			33
#define CRYPTO_LOCK_ECDH		34
#define CRYPTO_LOCK_BN  		35
#define CRYPTO_LOCK_EC_PRE_COMP		36
#define CRYPTO_LOCK_STORE		37
#define CRYPTO_LOCK_COMP		38
#define CRYPTO_NUM_LOCKS		39
d194 1
a194 1
struct crypto_ex_data_st
d198 11
a208 1
	};
a239 4
#define CRYPTO_EX_INDEX_ECDSA		12
#define CRYPTO_EX_INDEX_ECDH		13
#define CRYPTO_EX_INDEX_COMP		14
#define CRYPTO_EX_INDEX_STORE		15
d437 53
a489 1
#define OPENSSL_assert(e)       (void)((e) ? 0 : (OpenSSLDie(__FILE__, __LINE__, #e),1))
d491 1
a491 2
unsigned long *OPENSSL_ia32cap_loc(void);
#define OPENSSL_ia32cap (*(OPENSSL_ia32cap_loc()))
@


1.1.1.7
log
@import openssl-0.9.8j
@
text
@a221 1
#ifndef OPENSSL_FIPS
a222 5
#else
#define CRYPTO_LOCK_FIPS		39
#define CRYPTO_LOCK_FIPS2		40
#define CRYPTO_NUM_LOCKS		41
#endif
d344 8
a351 1
void CRYPTO_malloc_debug_init(void);
a365 1
#define OPENSSL_strdup(str)	CRYPTO_strdup((str),__FILE__,__LINE__)
a429 3
void int_CRYPTO_set_do_dynlock_callback(
	void (*do_dynlock_cb)(int mode, int type, const char *file, int line));

a453 4
void CRYPTO_set_mem_info_functions(
	int  (*push_info_fn)(const char *info, const char *file, int line),
	int  (*pop_info_fn)(void),
	int (*remove_all_info_fn)(void));
a469 1
char *CRYPTO_strdup(const char *str, const char *file, int line);
a508 3
int CRYPTO_dbg_push_info(const char *info, const char *file, int line);
int CRYPTO_dbg_pop_info(void);
int CRYPTO_dbg_remove_all_info(void);
a523 55
int OPENSSL_isservice(void);

#ifdef OPENSSL_FIPS
#define FIPS_ERROR_IGNORED(alg) OpenSSLDie(__FILE__, __LINE__, \
		alg " previous FIPS forbidden algorithm error ignored");

#define FIPS_BAD_ABORT(alg) OpenSSLDie(__FILE__, __LINE__, \
		#alg " Algorithm forbidden in FIPS mode");

#ifdef OPENSSL_FIPS_STRICT
#define FIPS_BAD_ALGORITHM(alg) FIPS_BAD_ABORT(alg)
#else
#define FIPS_BAD_ALGORITHM(alg) \
	{ \
	FIPSerr(FIPS_F_HASH_FINAL,FIPS_R_NON_FIPS_METHOD); \
	ERR_add_error_data(2, "Algorithm=", #alg); \
	return 0; \
	}
#endif

/* Low level digest API blocking macro */

#define FIPS_NON_FIPS_MD_Init(alg) \
	int alg##_Init(alg##_CTX *c) \
		{ \
		if (FIPS_mode()) \
			FIPS_BAD_ALGORITHM(alg) \
		return private_##alg##_Init(c); \
		} \
	int private_##alg##_Init(alg##_CTX *c)

/* For ciphers the API often varies from cipher to cipher and each needs to
 * be treated as a special case. Variable key length ciphers (Blowfish, RC4,
 * CAST) however are very similar and can use a blocking macro.
 */

#define FIPS_NON_FIPS_VCIPHER_Init(alg) \
	void alg##_set_key(alg##_KEY *key, int len, const unsigned char *data) \
		{ \
		if (FIPS_mode()) \
			FIPS_BAD_ABORT(alg) \
		private_##alg##_set_key(key, len, data); \
		} \
	void private_##alg##_set_key(alg##_KEY *key, int len, \
					const unsigned char *data)

#else

#define FIPS_NON_FIPS_VCIPHER_Init(alg) \
	void alg##_set_key(alg##_KEY *key, int len, const unsigned char *data)

#define FIPS_NON_FIPS_MD_Init(alg) \
	int alg##_Init(alg##_CTX *c) 

#endif /* def OPENSSL_FIPS */
a529 3

#define OPENSSL_HAVE_INIT	1
void OPENSSL_init(void);
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d3 1
a3 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
d222 3
d228 1
d291 1
a291 1
	STACK_OF(void) *sk;
a293 1
DECLARE_STACK_OF(void)
d350 1
a350 8
#define CRYPTO_malloc_debug_init()	do {\
	CRYPTO_set_mem_debug_functions(\
		CRYPTO_dbg_malloc,\
		CRYPTO_dbg_realloc,\
		CRYPTO_dbg_free,\
		CRYPTO_dbg_set_options,\
		CRYPTO_dbg_get_options);\
	} while(0)
a422 17

/* Don't use this structure directly. */
typedef struct crypto_threadid_st
	{
	void *ptr;
	unsigned long val;
	} CRYPTO_THREADID;
/* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */
void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);
void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);
int CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID *));
void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);
void CRYPTO_THREADID_current(CRYPTO_THREADID *id);
int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a, const CRYPTO_THREADID *b);
void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest, const CRYPTO_THREADID *src);
unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);
#ifndef OPENSSL_NO_DEPRECATED
a425 2
#endif

d430 3
d457 4
d517 3
d537 54
d596 3
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@a549 27
int FIPS_mode(void);
int FIPS_mode_set(int r);

void OPENSSL_init(void);

#define fips_md_init(alg) fips_md_init_ctx(alg, alg)

#ifdef OPENSSL_FIPS
#define fips_md_init_ctx(alg, cx) \
	int alg##_Init(cx##_CTX *c) \
	{ \
	if (FIPS_mode()) OpenSSLDie(__FILE__, __LINE__, \
		"Low level API call to digest " #alg " forbidden in FIPS mode!"); \
	return private_##alg##_Init(c); \
	} \
	int private_##alg##_Init(cx##_CTX *c)

#define fips_cipher_abort(alg) \
	if (FIPS_mode()) OpenSSLDie(__FILE__, __LINE__, \
		"Low level API call to cipher " #alg " forbidden in FIPS mode!")

#else
#define fips_md_init_ctx(alg, cx) \
	int alg##_Init(cx##_CTX *c)
#define fips_cipher_abort(alg) while(0)
#endif

a564 1
#define CRYPTO_F_FIPS_MODE_SET				 109
a569 1
#define CRYPTO_R_FIPS_MODE_NOT_SUPPORTED		 101
@


1.1.1.10
log
@Import OpenSSL 1.0.1g
@
text
@d491 1
a491 1
void CRYPTO_free_locked(void *ptr);
d494 1
a494 1
void CRYPTO_free(void *ptr);
a575 7

/* CRYPTO_memcmp returns zero iff the |len| bytes at |a| and |b| are equal. It
 * takes an amount of time dependent on |len|, but independent of the contents
 * of |a| and |b|. Unlike memcmp, it cannot be used to put elements into a
 * defined order as the return value when a != b is undefined, other than to be
 * non-zero. */
int CRYPTO_memcmp(const void *a, const void *b, size_t len);
@


