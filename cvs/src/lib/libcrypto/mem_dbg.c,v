head	1.22;
access;
symbols;
locks; strict;
comment	@ * @;


1.22
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	mJUVYpkFBZ0Zv2bG;

1.21
date	2014.05.30.20.10.00;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.29.20.21.22;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.28.19.04.59;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.20.14.32.19;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.16.18.28.08;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.16.14.31.03;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.15.13.41.53;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.12.07.57.43;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.09.12.15.22;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.08.08.03.12;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.03.15.12.44;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.16.12.18.20;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.10;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.22.00.02.54;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.57.03;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.15.06.18.31;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.08.30;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.42;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.34.27;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.20.41.32;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.13.50;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.02;	author djm;	state Exp;
branches;
next	;


desc
@@


1.22
log
@tags as requested by miod and tedu
@
text
@/* $OpenBSD$ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <openssl/crypto.h>
#include <openssl/bio.h>
#include <openssl/lhash.h>

int
CRYPTO_mem_ctrl(int mode)
{
	return (CRYPTO_MEM_CHECK_OFF);
}

int
CRYPTO_is_mem_check_on(void)
{
	return (0);
}


void
CRYPTO_dbg_set_options(long bits)
{
	return;
}

long
CRYPTO_dbg_get_options(void)
{
	return (0);
}

int
CRYPTO_push_info_(const char *info, const char *file, int line)
{
	return (0);
}

int
CRYPTO_pop_info(void)
{
	return (0);
}

int
CRYPTO_remove_all_info(void)
{
	return (0);
}

void
CRYPTO_dbg_malloc(void *addr, int num, const char *file, int line,
    int before_p)
{
	/* CRYPTO_dbg_malloc is no longer permitted */
	abort();
}

void
CRYPTO_dbg_free(void *addr, int before_p)
{
	/* CRYPTO_dbg_free is no longer permitted */
	abort();
}

void
CRYPTO_dbg_realloc(void *addr1, void *addr2, int num,
    const char *file, int line, int before_p)
{
	/* CRYPTO_dbg_realloc is no longer permitted */
	abort();
}

void
CRYPTO_mem_leaks(BIO *b)
{
	return;
}

void
CRYPTO_mem_leaks_fp(FILE *fp)
{
	return;
}


void
CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)
{
	return;
}
@


1.21
log
@Don't add potentially nasty stderr uses to dead CRYPTO_dbg_mem functions.
But do use the abort(), which we are hoping all future vendors will move
towards the more modern "do not flush streams"; hint hint, if you didn't
do that already, there are grave risks because much software brings risk
without that behaviour. We didn't cause the change.. POSIX did...
ok beck
@
text
@d1 1
a1 1
/* crypto/mem_dbg.c */
@


1.20
log
@Everything sane has stdio, and FILE *. we don't need ifdefs for this.
ok to firebomb from tedu@@
@
text
@d165 1
a165 1
	fprintf(stderr, "this is a bad idea");
d172 1
a172 1
	fprintf(stderr, "this is a bad idea");
d180 1
a180 1
	fprintf(stderr, "this is a bad idea");
@


1.19
log
@Leftover includes and local declarations; from Gebruiker Schoot
@
text
@a189 1
#ifndef OPENSSL_NO_FP_API
a194 1
#endif
@


1.18
log
@More KNF.
@
text
@a113 2
#include <time.h>
#include "cryptlib.h"
a114 1
#include <openssl/buffer.h>
a197 2

typedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;
@


1.17
log
@delete a few leftovers
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d130 1
a130 1
	return(0);
d143 1
a143 1
	return(0);
d149 1
a149 1
	return(0);
d155 1
a155 1
	return(0);
d161 1
a161 1
	return(0);
@


1.16
log
@Make this byzantine horror a shell of it's former self by stubbing the
functions. The ability to set the debug mem functions died with mem.c,
but some of the rest of this is still exposed API so we can't delete it..
yet...
ok tedu@@
@
text
@a120 2
static int mh_mode = CRYPTO_MEM_CHECK_OFF;

d124 1
a124 1
	return (mh_mode);
a163 2

static unsigned long break_order_num = 0;
@


1.15
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@d114 1
a114 1
#include <time.h>	
a121 91
/* The state changes to CRYPTO_MEM_CHECK_ON | CRYPTO_MEM_CHECK_ENABLE
 * when the application asks for it (usually after library initialisation
 * for which no book-keeping is desired).
 *
 * State CRYPTO_MEM_CHECK_ON exists only temporarily when the library
 * thinks that certain allocations should not be checked (e.g. the data
 * structures used for memory checking).  It is not suitable as an initial
 * state: the library will unexpectedly enable memory checking when it
 * executes one of those sections that want to disable checking
 * temporarily.
 *
 * State CRYPTO_MEM_CHECK_ENABLE without ..._ON makes no sense whatsoever.
 */

static unsigned long order = 0; /* number of memory requests */

DECLARE_LHASH_OF(MEM);
static LHASH_OF(MEM) *mh = NULL; /* hash - table of memory requests
				  * (address as key); access requires
				  * MALLOC2 lock */

typedef struct app_mem_info_st
/* For application-defined information (static C-string `info')
 * to be displayed in memory leak list.
 * Each thread has its own stack.  For applications, there is
 *   CRYPTO_push_info("...")     to push an entry,
 *   CRYPTO_pop_info()           to pop an entry,
 *   CRYPTO_remove_all_info()    to pop all entries.
 */
{
	CRYPTO_THREADID threadid;
	const char *file;
	int line;
	const char *info;
	struct app_mem_info_st *next; /* tail of thread's stack */
	int references;
} APP_INFO;

static void app_info_free(APP_INFO *);

DECLARE_LHASH_OF(APP_INFO);
static LHASH_OF(APP_INFO) *amih = NULL; /* hash - table with those
					 * app_mem_info_st's that are at
					 * the top of their thread's
					 * stack (with `thread' as key);
					 * access requires MALLOC2
					 * lock */

typedef struct mem_st
/* memory-block description */
{
	void *addr;
	int num;
	const char *file;
	int line;
	CRYPTO_THREADID threadid;
	unsigned long order;
	time_t time;
	APP_INFO *app_info;
} MEM;

static long options =             /* extra information to be recorded */
#if defined(CRYPTO_MDEBUG_TIME) || defined(CRYPTO_MDEBUG_ALL)
V_CRYPTO_MDEBUG_TIME |
#endif
#if defined(CRYPTO_MDEBUG_THREAD) || defined(CRYPTO_MDEBUG_ALL)
V_CRYPTO_MDEBUG_THREAD |
#endif
0;


static unsigned int num_disable = 0; /* num_disable > 0
				      *     iff
				      * mh_mode == CRYPTO_MEM_CHECK_ON (w/o ..._ENABLE)
				      */

/* Valid iff num_disable > 0.  CRYPTO_LOCK_MALLOC2 is locked exactly in this
 * case (by the thread named in disabling_thread).
 */
static CRYPTO_THREADID disabling_threadid;

static void
app_info_free(APP_INFO *inf)
{
	if (--(inf->references) <= 0) {
		if (inf->next != NULL) {
			app_info_free(inf->next);
		}
		OPENSSL_free(inf);
	}
}
d126 1
a126 62
	int ret = mh_mode;

	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
	switch (mode) {
	/* for applications (not to be called while multiple threads
	 * use the library): */
	case CRYPTO_MEM_CHECK_ON: /* aka MemCheck_start() */
		mh_mode = CRYPTO_MEM_CHECK_ON|CRYPTO_MEM_CHECK_ENABLE;
		num_disable = 0;
		break;
	case CRYPTO_MEM_CHECK_OFF: /* aka MemCheck_stop() */
		mh_mode = 0;
		num_disable = 0; /* should be true *before* MemCheck_stop is used,
		                    or there'll be a lot of confusion */
		break;

		/* switch off temporarily (for library-internal use): */
	case CRYPTO_MEM_CHECK_DISABLE: /* aka MemCheck_off() */
		if (mh_mode & CRYPTO_MEM_CHECK_ON) {
			CRYPTO_THREADID cur;
			CRYPTO_THREADID_current(&cur);
			if (!num_disable || CRYPTO_THREADID_cmp(&disabling_threadid, &cur)) /* otherwise we already have the MALLOC2 lock */
			{
				/* Long-time lock CRYPTO_LOCK_MALLOC2 must not be claimed while
				 * we're holding CRYPTO_LOCK_MALLOC, or we'll deadlock if
				 * somebody else holds CRYPTO_LOCK_MALLOC2 (and cannot release
				 * it because we block entry to this function).
				 * Give them a chance, first, and then claim the locks in
				 * appropriate order (long-time lock first).
				 */
				CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
				/* Note that after we have waited for CRYPTO_LOCK_MALLOC2
				 * and CRYPTO_LOCK_MALLOC, we'll still be in the right
				 * "case" and "if" branch because MemCheck_start and
				 * MemCheck_stop may never be used while there are multiple
				 * OpenSSL threads. */
				CRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);
				CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
				mh_mode &= ~CRYPTO_MEM_CHECK_ENABLE;
				CRYPTO_THREADID_cpy(&disabling_threadid, &cur);
			}
			num_disable++;
		}
		break;
	case CRYPTO_MEM_CHECK_ENABLE: /* aka MemCheck_on() */
		if (mh_mode & CRYPTO_MEM_CHECK_ON) {
			if (num_disable) /* always true, or something is going wrong */
			{
				num_disable--;
				if (num_disable == 0) {
					mh_mode|=CRYPTO_MEM_CHECK_ENABLE;
					CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);
				}
			}
		}
		break;

	default:
		break;
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
	return (ret);
d132 1
a132 13
	int ret = 0;

	if (mh_mode & CRYPTO_MEM_CHECK_ON) {
		CRYPTO_THREADID cur;
		CRYPTO_THREADID_current(&cur);
		CRYPTO_r_lock(CRYPTO_LOCK_MALLOC);

		ret = (mh_mode & CRYPTO_MEM_CHECK_ENABLE) ||
		    CRYPTO_THREADID_cmp(&disabling_threadid, &cur);

		CRYPTO_r_unlock(CRYPTO_LOCK_MALLOC);
	}
	return (ret);
d139 1
a139 1
	options = bits;
d145 1
a145 89
	return options;
}

static int
mem_cmp(const MEM *a, const MEM *b)
{
#ifdef _WIN64
	const char *ap = (const char *)a->addr,
	*bp = (const char *)b->addr;
	if (ap == bp)
		return 0;
	else if (ap > bp)	return 1;
		else		return -1;
#else
	return (const char *)a->addr - (const char *)b->addr;
#endif
}

static IMPLEMENT_LHASH_COMP_FN(mem, MEM)

static unsigned long
mem_hash(const MEM *a)
{
	unsigned long ret;

	ret = (unsigned long)a->addr;

	ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;
	return (ret);
}

static
IMPLEMENT_LHASH_HASH_FN(mem, MEM)

/* static int app_info_cmp(APP_INFO *a, APP_INFO *b) */
static int
app_info_cmp(const void *a_void, const void *b_void)
{
	return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void)->threadid,
	    &((const APP_INFO *)b_void)->threadid);
}

static IMPLEMENT_LHASH_COMP_FN(app_info, APP_INFO)

static unsigned long
app_info_hash(const APP_INFO *a)
{
	unsigned long ret;

	ret = CRYPTO_THREADID_hash(&a->threadid);
	/* This is left in as a "who am I to question legacy?" measure */
	ret = ret * 17851 + (ret >> 14) * 7 + (ret >> 4) * 251;
	return (ret);
}

static IMPLEMENT_LHASH_HASH_FN(app_info, APP_INFO)

static APP_INFO
*pop_info(void)
{
	APP_INFO tmp;
	APP_INFO *ret = NULL;

	if (amih != NULL) {
		CRYPTO_THREADID_current(&tmp.threadid);
		if ((ret = lh_APP_INFO_delete(amih, &tmp)) != NULL) {
			APP_INFO *next = ret->next;

			if (next != NULL) {
				next->references++;
				(void)lh_APP_INFO_insert(amih, next);
			}
#ifdef LEVITTE_DEBUG_MEM
			if (CRYPTO_THREADID_cmp(&ret->threadid, &tmp.threadid)) {
				fprintf(stderr, "pop_info(): deleted info has other thread ID (%lu) than the current thread (%lu)!!!!\n",
				CRYPTO_THREADID_hash(&ret->threadid),
				CRYPTO_THREADID_hash(&tmp.threadid));
				abort();
			}
#endif
			if (--(ret->references) <= 0) {
				ret->next = NULL;
				if (next != NULL)
					next->references--;
				OPENSSL_free(ret);
			}
		}
	}
	return (ret);
d151 1
a151 41
	APP_INFO *ami, *amim;
	int ret = 0;

	if (is_MemCheck_on()) {
		MemCheck_off(); /* obtain MALLOC2 lock */

		if ((ami = (APP_INFO *)OPENSSL_malloc(sizeof(APP_INFO))) == NULL) {
			ret = 0;
			goto err;
		}
		if (amih == NULL) {
			if ((amih = lh_APP_INFO_new()) == NULL) {
				OPENSSL_free(ami);
				ret = 0;
				goto err;
			}
		}

		CRYPTO_THREADID_current(&ami->threadid);
		ami->file = file;
		ami->line = line;
		ami->info = info;
		ami->references = 1;
		ami->next = NULL;

		if ((amim = lh_APP_INFO_insert(amih, ami)) != NULL) {
#ifdef LEVITTE_DEBUG_MEM
			if (CRYPTO_THREADID_cmp(&ami->threadid, &amim->threadid)) {
				fprintf(stderr, "CRYPTO_push_info(): previous info has other thread ID (%lu) than the current thread (%lu)!!!!\n",
				CRYPTO_THREADID_hash(&amim->threadid),
				CRYPTO_THREADID_hash(&ami->threadid));
				abort();
			}
#endif
			ami->next = amim;
		}
		err:
		MemCheck_on(); /* release MALLOC2 lock */
	}

	return (ret);
d157 1
a157 11
	int ret = 0;

	if (is_MemCheck_on()) /* _must_ be true, or something went severely wrong */
	{
		MemCheck_off(); /* obtain MALLOC2 lock */

		ret = (pop_info() != NULL);

		MemCheck_on(); /* release MALLOC2 lock */
	}
	return (ret);
d163 1
a163 12
	int ret = 0;

	if (is_MemCheck_on()) /* _must_ be true */
	{
		MemCheck_off(); /* obtain MALLOC2 lock */

		while (pop_info() != NULL)
		ret++;

		MemCheck_on(); /* release MALLOC2 lock */
	}
	return (ret);
d172 2
a173 74
	MEM *m, *mm;
	APP_INFO tmp, *amim;

	switch (before_p & 127) {
	case 0:
		break;
	case 1:
		if (addr == NULL)
			break;

		if (is_MemCheck_on()) {
			MemCheck_off(); /* make sure we hold MALLOC2 lock */
			if ((m = (MEM *)OPENSSL_malloc(sizeof(MEM))) == NULL) {
				OPENSSL_free(addr);
				MemCheck_on(); /* release MALLOC2 lock
				                * if num_disabled drops to 0 */
				return;
			}
			if (mh == NULL) {
				if ((mh = lh_MEM_new()) == NULL) {
					OPENSSL_free(addr);
					OPENSSL_free(m);
					addr = NULL;
					goto err;
				}
			}

			m->addr = addr;
			m->file = file;
			m->line = line;
			m->num = num;
			if (options & V_CRYPTO_MDEBUG_THREAD)
				CRYPTO_THREADID_current(&m->threadid);
			else
				memset(&m->threadid, 0, sizeof(m->threadid));

			if (order == break_order_num) {
				/* BREAK HERE */
				m->order = order;
			}
			m->order = order++;
#ifdef LEVITTE_DEBUG_MEM
			fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] %c 0x%p (%d)\n",
			    m->order,
			    (before_p & 128) ? '*' : '+',
			    m->addr, m->num);
#endif
			if (options & V_CRYPTO_MDEBUG_TIME)
				m->time = time(NULL);
			else
				m->time = 0;

			CRYPTO_THREADID_current(&tmp.threadid);
			m->app_info = NULL;
			if (amih != NULL &&
			    (amim = lh_APP_INFO_retrieve(amih, &tmp)) != NULL) {
				m->app_info = amim;
				amim->references++;
			}

			if ((mm = lh_MEM_insert(mh, m)) != NULL) {
				/* Not good, but don't sweat it */
				if (mm->app_info != NULL) {
					mm->app_info->references--;
				}
				OPENSSL_free(mm);
			}
err:
			MemCheck_on(); /* release MALLOC2 lock
			                * if num_disabled drops to 0 */
		}
		break;
	}
	return;
d179 2
a180 29
	MEM m, *mp;

	switch (before_p) {
	case 0:
		if (addr == NULL)
			break;

		if (is_MemCheck_on() && (mh != NULL)) {
			MemCheck_off(); /* make sure we hold MALLOC2 lock */

			m.addr = addr;
			mp = lh_MEM_delete(mh, &m);
			if (mp != NULL) {
#ifdef LEVITTE_DEBUG_MEM
				fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] - 0x%p (%d)\n",
				mp->order, mp->addr, mp->num);
#endif
				if (mp->app_info != NULL)
					app_info_free(mp->app_info);
				OPENSSL_free(mp);
			}

			MemCheck_on(); /* release MALLOC2 lock
			                * if num_disabled drops to 0 */
		}
		break;
	case 1:
		break;
	}
d187 2
a188 42
	MEM m, *mp;

#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM: --> CRYPTO_dbg_malloc(addr1 = %p, addr2 = %p, num = %d, file = \"%s\", line = %d, before_p = %d)\n",
	addr1, addr2, num, file, line, before_p);
#endif

	switch (before_p) {
	case 0:
		break;
	case 1:
		if (addr2 == NULL)
			break;

		if (addr1 == NULL) {
			CRYPTO_dbg_malloc(addr2, num, file, line, 128 | before_p);
			break;
		}

		if (is_MemCheck_on()) {
			MemCheck_off(); /* make sure we hold MALLOC2 lock */

			m.addr = addr1;
			mp = lh_MEM_delete(mh, &m);
			if (mp != NULL) {
#ifdef LEVITTE_DEBUG_MEM
				fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] * 0x%p (%d) -> 0x%p (%d)\n",
				    mp->order,
				    mp->addr, mp->num,
				    addr2, num);
#endif
				mp->addr = addr2;
				mp->num = num;
				(void)lh_MEM_insert(mh, mp);
			}

			MemCheck_on(); /* release MALLOC2 lock
			                * if num_disabled drops to 0 */
		}
		break;
	}
	return;
a190 93

typedef struct mem_leak_st {
	BIO *bio;
	int chunks;
	long bytes;
} MEM_LEAK;

static void
print_leak_doall_arg(const MEM *m, MEM_LEAK *l)
{
	char buf[1024];
	char *bufp = buf;
	APP_INFO *amip;
	int ami_cnt;
	struct tm *lcl = NULL;
	CRYPTO_THREADID ti;

#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))

	if (m->addr == (char *)l->bio)
		return;

	if (options & V_CRYPTO_MDEBUG_TIME) {
		lcl = localtime(&m->time);

		(void) snprintf(bufp, BUF_REMAIN, "[%02d:%02d:%02d] ",
		lcl->tm_hour, lcl->tm_min, lcl->tm_sec);
		bufp += strlen(bufp);
	}

	(void) snprintf(bufp, BUF_REMAIN, "%5lu file=%s, line=%d, ",
	m->order, m->file, m->line);
	bufp += strlen(bufp);

	if (options & V_CRYPTO_MDEBUG_THREAD) {
		(void) snprintf(bufp, BUF_REMAIN, "thread=%lu, ",
		CRYPTO_THREADID_hash(&m->threadid));
		bufp += strlen(bufp);
	}

	(void) snprintf(bufp, BUF_REMAIN, "number=%d, address=%08lX\n",
	m->num,(unsigned long)m->addr);
	bufp += strlen(bufp);

	BIO_puts(l->bio, buf);

	l->chunks++;
	l->bytes += m->num;

	amip = m->app_info;
	ami_cnt = 0;
	if (!amip)
		return;
	CRYPTO_THREADID_cpy(&ti, &amip->threadid);

	do {
		int buf_len;
		int info_len;

		ami_cnt++;
		memset(buf, '>', ami_cnt);
		(void) snprintf(buf + ami_cnt, sizeof buf - ami_cnt,
		" thread=%lu, file=%s, line=%d, info=\"",
		CRYPTO_THREADID_hash(&amip->threadid), amip->file,
		amip->line);
		buf_len = strlen(buf);
		info_len = strlen(amip->info);
		if (128 - buf_len - 3 < info_len) {
			memcpy(buf + buf_len, amip->info, 128 - buf_len - 3);
			buf_len = 128 - 3;
		} else {
			BUF_strlcpy(buf + buf_len, amip->info,
			sizeof buf - buf_len);
			buf_len = strlen(buf);
		}
		(void) snprintf(buf + buf_len, sizeof buf - buf_len, "\"\n");

		BIO_puts(l->bio, buf);

		amip = amip->next;
	} while (amip && !CRYPTO_THREADID_cmp(&amip->threadid, &ti));

#ifdef LEVITTE_DEBUG_MEM
	if (amip) {
		fprintf(stderr, "Thread switch detected in backtrace!!!!\n");
		abort();
	}
#endif
}

static
IMPLEMENT_LHASH_DOALL_ARG_FN(print_leak, const MEM, MEM_LEAK)

d194 1
a194 59
	MEM_LEAK ml;

	if (mh == NULL && amih == NULL)
		return;

	MemCheck_off(); /* obtain MALLOC2 lock */

	ml.bio = b;
	ml.bytes = 0;
	ml.chunks = 0;
	if (mh != NULL)
		lh_MEM_doall_arg(mh, LHASH_DOALL_ARG_FN(print_leak),
		    MEM_LEAK, &ml);
	if (ml.chunks != 0) {
		BIO_printf(b, "%ld bytes leaked in %d chunks\n",
		ml.bytes, ml.chunks);
#ifdef CRYPTO_MDEBUG_ABORT
		abort();
#endif
	} else {
		/* Make sure that, if we found no leaks, memory-leak debugging itself
		 * does not introduce memory leaks (which might irritate
		 * external debugging tools).
		 * (When someone enables leak checking, but does not call
		 * this function, we declare it to be their fault.)
		 *
		 * XXX    This should be in CRYPTO_mem_leaks_cb,
		 * and CRYPTO_mem_leaks should be implemented by
		 * using CRYPTO_mem_leaks_cb.
		 * (Also there should be a variant of lh_doall_arg
		 * that takes a function pointer instead of a void *;
		 * this would obviate the ugly and illegal
		 * void_fn_to_char kludge in CRYPTO_mem_leaks_cb.
		 * Otherwise the code police will come and get us.)
		 */
		int old_mh_mode;

		CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);

		/* avoid deadlock when lh_free() uses CRYPTO_dbg_free(),
		 * which uses CRYPTO_is_mem_check_on */
		old_mh_mode = mh_mode;
		mh_mode = CRYPTO_MEM_CHECK_OFF;

		if (mh != NULL) {
			lh_MEM_free(mh);
			mh = NULL;
		}
		if (amih != NULL) {
			if (lh_APP_INFO_num_items(amih) == 0) {
				lh_APP_INFO_free(amih);
				amih = NULL;
			}
		}

		mh_mode = old_mh_mode;
		CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
	}
	MemCheck_on(); /* release MALLOC2 lock */
d201 1
a201 15
	BIO *b;

	if (mh == NULL)
		return;
	/* Need to turn off memory checking when allocated BIOs ... especially
	 * as we're creating them at a time when we're trying to check we've not
	 * left anything un-free()'d!! */
	MemCheck_off();
	b = BIO_new(BIO_s_file());
	MemCheck_on();
	if (!b)
		return;
	BIO_set_fp(b, fp, BIO_NOCLOSE);
	CRYPTO_mem_leaks(b);
	BIO_free(b);
a205 13

/* FIXME: We really don't allow much to the callback.  For example, it has
   no chance of reaching the info stack for the item it processes.  Should
   it really be this way?  -- Richard Levitte */
/* NB: The prototypes have been typedef'd to CRYPTO_MEM_LEAK_CB inside crypto.h
 * If this code is restructured, remove the callback type if it is no longer
 * needed. -- Geoff Thorpe */

/* Can't pass CRYPTO_MEM_LEAK_CB directly to lh_MEM_doall_arg because it
 * is a function pointer and conversion to void * is prohibited. Instead
 * pass its address
 */

a207 8
static void
cb_leak_doall_arg(const MEM *m, PCRYPTO_MEM_LEAK_CB *cb)
{
	(*cb)(m->order, m->file, m->line, m->num, m->addr);
}

static IMPLEMENT_LHASH_DOALL_ARG_FN(cb_leak, const MEM, PCRYPTO_MEM_LEAK_CB)

d211 1
a211 6
	if (mh == NULL)
		return;
	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);
	lh_MEM_doall_arg(mh, LHASH_DOALL_ARG_FN(cb_leak), PCRYPTO_MEM_LEAK_CB,
	&cb);
	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);
@


1.14
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d668 1
a668 1
		BIO_snprintf(bufp, BUF_REMAIN, "[%02d:%02d:%02d] ",
d673 1
a673 1
	BIO_snprintf(bufp, BUF_REMAIN, "%5lu file=%s, line=%d, ",
d678 1
a678 1
		BIO_snprintf(bufp, BUF_REMAIN, "thread=%lu, ",
d683 1
a683 1
	BIO_snprintf(bufp, BUF_REMAIN, "number=%d, address=%08lX\n",
d704 1
a704 1
		BIO_snprintf(buf + ami_cnt, sizeof buf - ami_cnt,
d718 1
a718 1
		BIO_snprintf(buf + buf_len, sizeof buf - buf_len, "\"\n");
@


1.13
log
@resolve conflicts, fix local changes
@
text
@d121 1
a121 1
static int mh_mode=CRYPTO_MEM_CHECK_OFF;
d139 3
a141 4
static LHASH_OF(MEM) *mh=NULL; /* hash-table of memory requests
				* (address as key); access requires
				* MALLOC2 lock */

d151 1
a151 1
	{
d158 1
a158 1
	} APP_INFO;
d163 6
a168 6
static LHASH_OF(APP_INFO) *amih=NULL; /* hash-table with those
				       * app_mem_info_st's that are at
				       * the top of their thread's
				       * stack (with `thread' as key);
				       * access requires MALLOC2
				       * lock */
d172 1
a172 1
	{
d181 1
a181 1
	} MEM;
d185 1
a185 1
	V_CRYPTO_MDEBUG_TIME |
d188 1
a188 1
	V_CRYPTO_MDEBUG_THREAD |
d190 1
a190 1
	0;
d194 3
a196 3
                                      *     iff
                                      * mh_mode == CRYPTO_MEM_CHECK_ON (w/o ..._ENABLE)
                                      */
d203 5
a207 6
static void app_info_free(APP_INFO *inf)
	{
	if (--(inf->references) <= 0)
		{
		if (inf->next != NULL)
			{
d209 1
a209 1
			}
a210 1
		}
d212 1
d214 4
a217 3
int CRYPTO_mem_ctrl(int mode)
	{
	int ret=mh_mode;
d220 1
a220 2
	switch (mode)
		{
d233 1
a233 1
	/* switch off temporarily (for library-internal use): */
d235 1
a235 2
		if (mh_mode & CRYPTO_MEM_CHECK_ON)
			{
d239 1
a239 1
				{
d257 1
a257 1
				}
d259 1
a259 1
			}
d262 2
a263 1
		if (mh_mode & CRYPTO_MEM_CHECK_ON)
a264 2
			if (num_disable) /* always true, or something is going wrong */
				{
d266 1
a266 2
				if (num_disable == 0)
					{
a268 1
					}
d271 1
d276 1
a276 1
		}
d278 2
a279 2
	return(ret);
	}
d281 3
a283 2
int CRYPTO_is_mem_check_on(void)
	{
d286 1
a286 2
	if (mh_mode & CRYPTO_MEM_CHECK_ON)
		{
d291 2
a292 2
		ret = (mh_mode & CRYPTO_MEM_CHECK_ENABLE)
		        || CRYPTO_THREADID_cmp(&disabling_threadid, &cur);
d295 3
a297 3
		}
	return(ret);
	}	
d300 3
a302 2
void CRYPTO_dbg_set_options(long bits)
	{
d304 1
a304 1
	}
d306 3
a308 2
long CRYPTO_dbg_get_options(void)
	{
d310 1
a310 1
	}
d312 3
a314 2
static int mem_cmp(const MEM *a, const MEM *b)
	{
d316 6
a321 5
	const char *ap=(const char *)a->addr,
		   *bp=(const char *)b->addr;
	if (ap==bp)	return 0;
	else if (ap>bp)	return 1;
	else		return -1;
d325 2
a326 1
	}
d329 3
a331 2
static unsigned long mem_hash(const MEM *a)
	{
d334 5
a338 1
	ret=(unsigned long)a->addr;
d340 2
a341 4
	ret=ret*17851+(ret>>14)*7+(ret>>4)*251;
	return(ret);
	}
static IMPLEMENT_LHASH_HASH_FN(mem, MEM)
d344 3
a346 2
static int app_info_cmp(const void *a_void, const void *b_void)
	{
d348 3
a350 2
				&((const APP_INFO *)b_void)->threadid);
	}
d353 3
a355 2
static unsigned long app_info_hash(const APP_INFO *a)
	{
d360 4
a363 3
	ret=ret*17851+(ret>>14)*7+(ret>>4)*251;
	return(ret);
	}
d366 3
a368 2
static APP_INFO *pop_info(void)
	{
d372 1
a372 2
	if (amih != NULL)
		{
d374 2
a375 3
		if ((ret=lh_APP_INFO_delete(amih,&tmp)) != NULL)
			{
			APP_INFO *next=ret->next;
d377 1
a377 2
			if (next != NULL)
				{
d379 2
a380 2
				(void)lh_APP_INFO_insert(amih,next);
				}
d382 1
a382 2
			if (CRYPTO_THREADID_cmp(&ret->threadid, &tmp.threadid))
				{
d384 2
a385 2
					CRYPTO_THREADID_hash(&ret->threadid),
					CRYPTO_THREADID_hash(&tmp.threadid));
d387 1
a387 1
				}
d389 1
a389 2
			if (--(ret->references) <= 0)
				{
a393 1
				}
a395 1
	return(ret);
d397 2
d400 3
a402 2
int CRYPTO_push_info_(const char *info, const char *file, int line)
	{
d404 1
a404 1
	int ret=0;
d406 1
a406 2
	if (is_MemCheck_on())
		{
d409 2
a410 3
		if ((ami = (APP_INFO *)OPENSSL_malloc(sizeof(APP_INFO))) == NULL)
			{
			ret=0;
d412 3
a414 5
			}
		if (amih == NULL)
			{
			if ((amih=lh_APP_INFO_new()) == NULL)
				{
d416 1
a416 1
				ret=0;
a417 1
				}
d419 1
d422 5
a426 5
		ami->file=file;
		ami->line=line;
		ami->info=info;
		ami->references=1;
		ami->next=NULL;
d428 1
a428 2
		if ((amim=lh_APP_INFO_insert(amih,ami)) != NULL)
			{
d430 1
a430 2
			if (CRYPTO_THREADID_cmp(&ami->threadid, &amim->threadid))
				{
d432 2
a433 2
					CRYPTO_THREADID_hash(&amim->threadid),
					CRYPTO_THREADID_hash(&ami->threadid));
d435 1
a435 1
				}
d437 3
a439 3
			ami->next=amim;
			}
 err:
d441 1
a441 1
		}
d443 2
a444 2
	return(ret);
	}
d446 4
a449 3
int CRYPTO_pop_info(void)
	{
	int ret=0;
d452 1
a452 1
		{
d455 1
a455 1
		ret=(pop_info() != NULL);
a457 2
		}
	return(ret);
d459 2
d462 4
a465 3
int CRYPTO_remove_all_info(void)
	{
	int ret=0;
d468 1
a468 1
		{
d471 2
a472 2
		while(pop_info() != NULL)
			ret++;
a474 2
		}
	return(ret);
d476 2
d480 7
a486 6
static unsigned long break_order_num=0;
void CRYPTO_dbg_malloc(void *addr, int num, const char *file, int line,
	int before_p)
	{
	MEM *m,*mm;
	APP_INFO tmp,*amim;
d488 1
a488 2
	switch(before_p & 127)
		{
d495 1
a495 2
		if (is_MemCheck_on())
			{
d497 1
a497 2
			if ((m=(MEM *)OPENSSL_malloc(sizeof(MEM))) == NULL)
				{
d502 3
a504 5
				}
			if (mh == NULL)
				{
				if ((mh=lh_MEM_new()) == NULL)
					{
d507 1
a507 1
					addr=NULL;
a508 1
					}
d510 1
d512 4
a515 4
			m->addr=addr;
			m->file=file;
			m->line=line;
			m->num=num;
d521 1
a521 2
			if (order == break_order_num)
				{
d523 3
a525 3
				m->order=order;
				}
			m->order=order++;
d528 3
a530 3
				m->order,
				(before_p & 128) ? '*' : '+',
				m->addr, m->num);
d533 1
a533 1
				m->time=time(NULL);
d535 1
a535 1
				m->time=0;
d538 3
a540 4
			m->app_info=NULL;
			if (amih != NULL
			    && (amim=lh_APP_INFO_retrieve(amih,&tmp)) != NULL)
				{
d543 1
a543 1
				}
d545 1
a545 2
			if ((mm=lh_MEM_insert(mh, m)) != NULL)
				{
d547 1
a547 2
				if (mm->app_info != NULL)
					{
d549 1
a549 1
					}
d551 2
a552 2
				}
		err:
d555 1
a555 1
			}
d557 1
a557 1
		}
d559 1
a559 1
	}
d561 4
a564 3
void CRYPTO_dbg_free(void *addr, int before_p)
	{
	MEM m,*mp;
d566 1
a566 2
	switch(before_p)
		{
d571 1
a571 2
		if (is_MemCheck_on() && (mh != NULL))
			{
d574 3
a576 4
			m.addr=addr;
			mp=lh_MEM_delete(mh,&m);
			if (mp != NULL)
				{
d578 1
a578 1
			fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] - 0x%p (%d)\n",
d584 1
a584 1
				}
d588 1
a588 1
			}
a591 1
		}
d593 1
d595 5
a599 4
void CRYPTO_dbg_realloc(void *addr1, void *addr2, int num,
	const char *file, int line, int before_p)
	{
	MEM m,*mp;
d603 1
a603 1
		addr1, addr2, num, file, line, before_p);
d606 1
a606 2
	switch(before_p)
		{
d613 1
a613 2
		if (addr1 == NULL)
			{
d616 1
a616 1
			}
d618 1
a618 2
		if (is_MemCheck_on())
			{
d621 3
a623 4
			m.addr=addr1;
			mp=lh_MEM_delete(mh,&m);
			if (mp != NULL)
				{
d626 8
a633 8
					mp->order,
					mp->addr, mp->num,
					addr2, num);
#endif
				mp->addr=addr2;
				mp->num=num;
				(void)lh_MEM_insert(mh,mp);
				}
d637 1
a637 1
			}
d639 1
a639 1
		}
d641 1
a641 1
	}
d644 1
a644 2
typedef struct mem_leak_st
	{
d648 1
a648 1
	} MEM_LEAK;
d650 3
a652 2
static void print_leak_doall_arg(const MEM *m, MEM_LEAK *l)
	{
d662 2
a663 2
	if(m->addr == (char *)l->bio)
	    return;
d665 1
a665 2
	if (options & V_CRYPTO_MDEBUG_TIME)
		{
d667 1
a667 1
	
d669 1
a669 1
			lcl->tm_hour,lcl->tm_min,lcl->tm_sec);
d671 1
a671 1
		}
d674 1
a674 1
		m->order,m->file,m->line);
d677 1
a677 2
	if (options & V_CRYPTO_MDEBUG_THREAD)
		{
d679 1
a679 1
			CRYPTO_THREADID_hash(&m->threadid));
d681 1
a681 1
		}
d684 1
a684 1
		m->num,(unsigned long)m->addr);
d687 2
a688 2
	BIO_puts(l->bio,buf);
	
d690 1
a690 1
	l->bytes+=m->num;
d692 2
a693 2
	amip=m->app_info;
	ami_cnt=0;
d698 1
a698 2
	do
		{
d703 1
a703 1
		memset(buf,'>',ami_cnt);
d705 6
a710 7
			" thread=%lu, file=%s, line=%d, info=\"",
			CRYPTO_THREADID_hash(&amip->threadid), amip->file,
			amip->line);
		buf_len=strlen(buf);
		info_len=strlen(amip->info);
		if (128 - buf_len - 3 < info_len)
			{
d713 1
a713 3
			}
		else
			{
d715 1
a715 1
				    sizeof buf - buf_len);
d717 1
a717 1
			}
d719 2
a720 2
		
		BIO_puts(l->bio,buf);
d723 1
a723 2
		}
	while(amip && !CRYPTO_THREADID_cmp(&amip->threadid, &ti));
d726 1
a726 2
	if (amip)
		{
d729 1
a729 1
		}
d731 1
a731 1
	}
d733 2
a734 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(print_leak, const MEM, MEM_LEAK)
d736 3
a738 2
void CRYPTO_mem_leaks(BIO *b)
	{
d746 3
a748 3
	ml.bio=b;
	ml.bytes=0;
	ml.chunks=0;
d750 5
a754 6
		lh_MEM_doall_arg(mh, LHASH_DOALL_ARG_FN(print_leak), MEM_LEAK,
				 &ml);
	if (ml.chunks != 0)
		{
		BIO_printf(b,"%ld bytes leaked in %d chunks\n",
			   ml.bytes,ml.chunks);
d758 1
a758 3
		}
	else
		{
d783 1
a783 2
		if (mh != NULL)
			{
d786 3
a788 5
			}
		if (amih != NULL)
			{
			if (lh_APP_INFO_num_items(amih) == 0) 
				{
a790 1
				}
d792 1
d796 1
a796 1
		}
d798 1
a798 1
	}
d801 3
a803 2
void CRYPTO_mem_leaks_fp(FILE *fp)
	{
d806 2
a807 1
	if (mh == NULL) return;
d814 3
a816 2
	if(!b) return;
	BIO_set_fp(b,fp,BIO_NOCLOSE);
d819 1
a819 1
	}
d838 5
a842 4
static void cb_leak_doall_arg(const MEM *m, PCRYPTO_MEM_LEAK_CB *cb)
	{
	(*cb)(m->order,m->file,m->line,m->num,m->addr);
	}
d846 5
a850 3
void CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)
	{
	if (mh == NULL) return;
d853 1
a853 1
			 &cb);
d855 1
a855 1
	}
@


1.12
log
@convert a strdup (into a purpose-allocated buffer) in libcrypto to a
memcpy to avoid linker deprecation warnings; pointed out by dkrause@@
@
text
@d58 53
d137 5
a141 2
static LHASH *mh=NULL; /* hash-table of memory requests (address as key);
                        * access requires MALLOC2 lock */
d152 2
a153 2
	{	
	unsigned long thread;
d163 7
a169 4
static LHASH *amih=NULL; /* hash-table with those app_mem_info_st's
                          * that are at the top of their thread's stack
                          * (with `thread' as key);
                          * access requires MALLOC2 lock */
d178 1
a178 1
	unsigned long thread;
d198 5
a202 5
static unsigned long disabling_thread = 0; /* Valid iff num_disable > 0.
                                            * CRYPTO_LOCK_MALLOC2 is locked
                                            * exactly in this case (by the
                                            * thread named in disabling_thread).
                                            */
d239 3
a241 1
			if (!num_disable || (disabling_thread != CRYPTO_thread_id())) /* otherwise we already have the MALLOC2 lock */
d259 1
a259 1
				disabling_thread=CRYPTO_thread_id();
d292 2
d297 1
a297 1
			|| (disabling_thread != CRYPTO_thread_id());
d315 1
a315 2
/* static int mem_cmp(MEM *a, MEM *b) */
static int mem_cmp(const void *a_void, const void *b_void)
d318 4
a321 4
	const char *a=(const char *)((const MEM *)a_void)->addr,
		   *b=(const char *)((const MEM *)b_void)->addr;
	if (a==b)	return 0;
	else if (a>b)	return 1;
d324 1
a324 2
	return((const char *)((const MEM *)a_void)->addr
		- (const char *)((const MEM *)b_void)->addr);
d327 1
d329 1
a329 2
/* static unsigned long mem_hash(MEM *a) */
static unsigned long mem_hash(const void *a_void)
d333 1
a333 1
	ret=(unsigned long)((const MEM *)a_void)->addr;
d338 1
d343 2
a344 2
	return(((const APP_INFO *)a_void)->thread
		!= ((const APP_INFO *)b_void)->thread);
d346 1
d348 1
a348 2
/* static unsigned long app_info_hash(APP_INFO *a) */
static unsigned long app_info_hash(const void *a_void)
d352 2
a353 2
	ret=(unsigned long)((const APP_INFO *)a_void)->thread;

d357 1
d366 2
a367 2
		tmp.thread=CRYPTO_thread_id();
		if ((ret=(APP_INFO *)lh_delete(amih,&tmp)) != NULL)
d374 1
a374 1
				lh_insert(amih,(char *)next);
d377 1
a377 1
			if (ret->thread != tmp.thread)
d380 2
a381 1
					ret->thread, tmp.thread);
d397 1
a397 1
int CRYPTO_dbg_push_info(const char *info, const char *file, int line)
d413 1
a413 1
			if ((amih=lh_new(app_info_hash, app_info_cmp)) == NULL)
d421 1
a421 1
		ami->thread=CRYPTO_thread_id();
d428 1
a428 1
		if ((amim=(APP_INFO *)lh_insert(amih,(char *)ami)) != NULL)
d431 1
a431 1
			if (ami->thread != amim->thread)
d434 2
a435 1
					amim->thread, ami->thread);
d448 1
a448 1
int CRYPTO_dbg_pop_info(void)
d463 1
a463 1
int CRYPTO_dbg_remove_all_info(void)
d507 1
a507 1
				if ((mh=lh_new(mem_hash, mem_cmp)) == NULL)
d521 1
a521 1
				m->thread=CRYPTO_thread_id();
d523 1
a523 1
				m->thread=0;
d532 1
a532 1
			fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5d] %c 0x%p (%d)\n",
d542 1
a542 1
			tmp.thread=CRYPTO_thread_id();
d545 1
a545 1
				&& (amim=(APP_INFO *)lh_retrieve(amih,(char *)&tmp)) != NULL)
d551 1
a551 1
			if ((mm=(MEM *)lh_insert(mh,(char *)m)) != NULL)
d584 1
a584 1
			mp=(MEM *)lh_delete(mh,(char *)&m);
d588 1
a588 1
			fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5d] - 0x%p (%d)\n",
d634 1
a634 1
			mp=(MEM *)lh_delete(mh,(char *)&m);
d638 1
a638 1
				fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5d] * 0x%p (%d) -> 0x%p (%d)\n",
d645 1
a645 1
				lh_insert(mh,(char *)mp);
d664 1
a664 1
static void print_leak(const MEM *m, MEM_LEAK *l)
d671 1
a671 1
	unsigned long ti;
d693 2
a694 1
		BIO_snprintf(bufp, BUF_REMAIN, "thread=%lu, ", m->thread);
d711 2
a712 2
	ti=amip->thread;
	
d722 2
a723 1
			amip->thread, amip->file, amip->line);
d743 2
a744 2
	while(amip && amip->thread == ti);
		
d754 1
a754 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(print_leak, const MEM *, MEM_LEAK *)
d769 2
a770 2
		lh_doall_arg(mh, LHASH_DOALL_ARG_FN(print_leak),
				(char *)&ml);
d775 3
d790 1
a790 1
		 * (Also their should be a variant of lh_doall_arg
d807 1
a807 1
			lh_free(mh);
d812 1
a812 1
			if (lh_num_items(amih) == 0) 
d814 1
a814 1
				lh_free(amih);
d852 9
a860 1
static void cb_leak(const MEM *m, CRYPTO_MEM_LEAK_CB **cb)
d862 1
a862 1
	(**cb)(m->order,m->file,m->line,m->num,m->addr);
d865 1
a865 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(cb_leak, const MEM *, CRYPTO_MEM_LEAK_CB **)
d871 2
a872 1
	lh_doall_arg(mh, LHASH_DOALL_ARG_FN(cb_leak), &cb);
a873 23
	}

void CRYPTO_malloc_debug_init(void)
	{
	CRYPTO_set_mem_debug_functions(
		CRYPTO_dbg_malloc,
		CRYPTO_dbg_realloc,
		CRYPTO_dbg_free,
		CRYPTO_dbg_set_options,
		CRYPTO_dbg_get_options);
	CRYPTO_set_mem_info_functions(
		CRYPTO_dbg_push_info,
		CRYPTO_dbg_pop_info,
		CRYPTO_dbg_remove_all_info);
	}

char *CRYPTO_strdup(const char *str, const char *file, int line)
	{
	size_t len = strlen(str)+1;
	char *ret = CRYPTO_malloc(len, file, line);

	memcpy(ret, str, len);
	return ret;
@


1.11
log
@resolve conflicts
@
text
@d813 2
a814 1
	char *ret = CRYPTO_malloc(strlen(str)+1, file, line);
d816 1
a816 1
	strcpy(ret, str);
@


1.10
log
@resolve conflicts
@
text
@d333 1
a333 1
int CRYPTO_push_info_(const char *info, const char *file, int line)
d383 1
a383 1
int CRYPTO_pop_info(void)
d398 1
a398 1
int CRYPTO_remove_all_info(void)
d795 22
@


1.9
log
@merge 0.9.7d
@
text
@d62 1
a66 1
#include "cryptlib.h"
d255 7
d264 1
@


1.8
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d609 1
a609 1
		snprintf(bufp, BUF_REMAIN, "[%02d:%02d:%02d] ",
d614 1
a614 1
	snprintf(bufp, BUF_REMAIN, "%5lu file=%s, line=%d, ",
d620 1
a620 1
		snprintf(bufp, BUF_REMAIN, "thread=%lu, ", m->thread);
d624 1
a624 1
	snprintf(bufp, BUF_REMAIN, "number=%d, address=%08lX\n",
d646 1
a646 1
		snprintf(buf + ami_cnt, sizeof buf - ami_cnt,
d658 2
a659 2
			strlcpy(buf + buf_len, amip->info,
				sizeof buf - buf_len);
d662 1
a662 1
		snprintf(buf + buf_len, sizeof buf - buf_len, "\"\n");
@


1.7
log
@str{cat,cpy}/sprintf cleanup. markus@@, deraadt@@ ok
@
text
@d105 2
d145 12
d519 1
a519 3
					{
					mp->app_info->references--;
					}
a683 1
	char buf[80];
d698 2
a699 3
		snprintf(buf,sizeof buf,"%ld bytes leaked in %d chunks\n",
			ml.bytes,ml.chunks);
		BIO_puts(b,buf);
@


1.6
log
@Less strcpy/strcat/sprintf. tdeval@@ ok.
@
text
@d588 2
d597 1
a597 1
		sprintf(bufp, "[%02d:%02d:%02d] ",
d602 1
a602 1
	sprintf(bufp, "%5lu file=%s, line=%d, ",
d608 1
a608 1
		sprintf(bufp, "thread=%lu, ", m->thread);
d612 1
a612 1
	sprintf(bufp, "number=%d, address=%08lX\n",
d687 1
a687 1
		sprintf(buf,"%ld bytes leaked in %d chunks\n",
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d632 1
a632 1
		sprintf(buf + ami_cnt,
d644 2
a645 1
			strcpy(buf + buf_len, amip->info);
d648 1
a648 1
		sprintf(buf + buf_len, "\"\n");
@


1.4
log
@openssl-engine-0.9.6a merge
@
text
@d238 2
a239 1
static int mem_cmp(MEM *a, MEM *b)
d241 2
a242 1
	return((char *)a->addr - (char *)b->addr);
d245 2
a246 1
static unsigned long mem_hash(MEM *a)
d250 1
a250 1
	ret=(unsigned long)a->addr;
d256 2
a257 1
static int app_info_cmp(APP_INFO *a, APP_INFO *b)
d259 2
a260 1
	return(a->thread != b->thread);
d263 2
a264 1
static unsigned long app_info_hash(APP_INFO *a)
d268 1
a268 1
	ret=(unsigned long)a->thread;
d274 1
a274 1
static APP_INFO *pop_info()
d291 1
a291 1
#ifdef LEVITTE_DEBUG
d327 1
a327 1
			if ((amih=lh_new(app_info_hash,app_info_cmp)) == NULL)
d344 1
a344 1
#ifdef LEVITTE_DEBUG
d420 1
a420 1
				if ((mh=lh_new(mem_hash,mem_cmp)) == NULL)
d444 2
a445 2
#ifdef LEVITTE_DEBUG
			fprintf(stderr, "LEVITTE_DEBUG: [%5d] %c 0x%p (%d)\n",
d500 2
a501 2
#ifdef LEVITTE_DEBUG
			fprintf(stderr, "LEVITTE_DEBUG: [%5d] - 0x%p (%d)\n",
d525 2
a526 2
#ifdef LEVITTE_DEBUG
	fprintf(stderr, "LEVITTE_DEBUG: --> CRYPTO_dbg_malloc(addr1 = %p, addr2 = %p, num = %d, file = \"%s\", line = %d, before_p = %d)\n",
d552 2
a553 2
#ifdef LEVITTE_DEBUG
				fprintf(stderr, "LEVITTE_DEBUG: [%5d] * 0x%p (%d) -> 0x%p (%d)\n",
d579 1
a579 1
static void print_leak(MEM *m, MEM_LEAK *l)
d655 1
a655 1
#ifdef LEVITTE_DEBUG
d664 2
d680 2
a681 1
		lh_doall_arg(mh,(void (*)())print_leak,(char *)&ml);
d734 1
a734 1
#ifndef NO_FP_API
d740 7
a746 2
	if ((b=BIO_new(BIO_s_file())) == NULL)
		return;
d758 4
a761 2
static void cb_leak(MEM *m,
		    void (**cb)(unsigned long, const char *, int, int, void *))
d766 3
a768 1
void CRYPTO_mem_leaks_cb(void (*cb)(unsigned long, const char *, int, int, void *))
d772 1
a772 1
	lh_doall_arg(mh,(void (*)())cb_leak,(void *)&cb);
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d84 2
a85 1
static LHASH *mh=NULL; /* hash-table of memory requests (address as key) */
d107 2
a108 1
                          * (with `thread' as key) */
d133 9
a141 1
static unsigned long disabling_thread = 0;
d150 2
a151 1
	/* for applications: */
d154 1
a154 1
		disabling_thread = 0;
d158 2
a159 1
		disabling_thread = 0;
d166 1
a166 2
			mh_mode&= ~CRYPTO_MEM_CHECK_ENABLE;
			if (disabling_thread != CRYPTO_thread_id()) /* otherwise we already have the MALLOC2 lock */
d183 1
d186 1
d192 1
a192 2
			mh_mode|=CRYPTO_MEM_CHECK_ENABLE;
			if (disabling_thread != 0)
d194 6
a199 2
				disabling_thread=0;
				CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);
d217 1
a217 1
		CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
d220 1
a220 1
			&& disabling_thread != CRYPTO_thread_id();
d222 1
a222 1
		CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
d312 1
a312 1
		MemCheck_off(); /* obtains CRYPTO_LOCK_MALLOC2 */
d349 1
a349 1
		MemCheck_on(); /* releases CRYPTO_LOCK_MALLOC2 */
d361 1
a361 1
		MemCheck_off(); /* obtains CRYPTO_LOCK_MALLOC2 */
d365 1
a365 1
		MemCheck_on(); /* releases CRYPTO_LOCK_MALLOC2 */
d376 1
a376 1
		MemCheck_off(); /* obtains CRYPTO_LOCK_MALLOC2 */
d381 1
a381 1
		MemCheck_on(); /* releases CRYPTO_LOCK_MALLOC2 */
d404 1
a404 1
			MemCheck_off(); /* obtains CRYPTO_LOCK_MALLOC2 */
d408 2
a409 1
				MemCheck_on(); /* releases CRYPTO_LOCK_MALLOC2 */
d468 2
a469 1
			MemCheck_on(); /* releases CRYPTO_LOCK_MALLOC2 */
d488 1
a488 1
			MemCheck_off();
d505 2
a506 1
			MemCheck_on(); /* releases CRYPTO_LOCK_MALLOC2 */
d540 1
a540 1
			MemCheck_off(); /* obtains CRYPTO_LOCK_MALLOC2 */
d557 2
a558 1
			MemCheck_on(); /* releases CRYPTO_LOCK_MALLOC2 */
d665 3
a670 1
	MemCheck_off(); /* obtains CRYPTO_LOCK_MALLOC2 */
d696 2
d699 6
d718 2
d722 1
a722 7
	MemCheck_on(); /* releases CRYPTO_LOCK_MALLOC2 */

#if 0
	lh_stats_bio(mh,b);
	lh_node_stats_bio(mh,b);
	lh_node_usage_stats_bio(mh,b);
#endif
@


1.2
log
@OpenSSL 0.9.5a merge
@
text
@d111 1
a111 1
	char *addr;
d224 1
a224 1
	return(a->addr - b->addr);
d282 1
a282 1
				Free(ret);
d298 1
a298 1
		if ((ami = (APP_INFO *)Malloc(sizeof(APP_INFO))) == NULL)
d307 1
a307 1
				Free(ami);
d389 1
a389 1
			if ((m=(MEM *)Malloc(sizeof(MEM))) == NULL)
d391 1
a391 1
				Free(addr);
d399 2
a400 2
					Free(addr);
					Free(m);
d448 1
a448 1
				Free(mm);
d484 1
a484 1
				Free(mp);
a698 26
union void_fn_to_char_u
	{
	char *char_p;
	void (*fn_p)();
	};

static void cb_leak(MEM *m, char *cb)
	{
	union void_fn_to_char_u mem_callback;

	mem_callback.char_p=cb;
	mem_callback.fn_p(m->order,m->file,m->line,m->num,m->addr);
	}

void CRYPTO_mem_leaks_cb(void (*cb)())
	{
	union void_fn_to_char_u mem_cb;

	if (mh == NULL) return;
	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);
	mem_cb.fn_p=cb;
	lh_doall_arg(mh,(void (*)())cb_leak,mem_cb.char_p);
	mem_cb.char_p=NULL;
	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);
	}

d713 18
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d643 2
a644 1
	if (mh == NULL) return;
d648 3
a650 3
	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);
	lh_doall_arg(mh,(void (*)())print_leak,(char *)&ml);
	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);
d657 34
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d84 1
a84 2
static LHASH *mh=NULL; /* hash-table of memory requests (address as key);
                        * access requires MALLOC2 lock */
d106 1
a106 2
                          * (with `thread' as key);
                          * access requires MALLOC2 lock */
d111 1
a111 1
	void *addr;
d131 1
a131 9
static unsigned int num_disable = 0; /* num_disable > 0
                                      *     iff
                                      * mh_mode == CRYPTO_MEM_CHECK_ON (w/o ..._ENABLE)
                                      */
static unsigned long disabling_thread = 0; /* Valid iff num_disable > 0.
                                            * CRYPTO_LOCK_MALLOC2 is locked
                                            * exactly in this case (by the
                                            * thread named in disabling_thread).
                                            */
d140 1
a140 2
	/* for applications (not to be called while multiple threads
	 * use the library): */
d143 1
a143 1
		num_disable = 0;
d147 1
a147 2
		num_disable = 0; /* should be true *before* MemCheck_stop is used,
		                    or there'll be a lot of confusion */
d154 2
a155 1
			if (!num_disable || (disabling_thread != CRYPTO_thread_id())) /* otherwise we already have the MALLOC2 lock */
a171 1
				mh_mode &= ~CRYPTO_MEM_CHECK_ENABLE;
a173 1
			num_disable++;
d179 2
a180 1
			if (num_disable) /* always true, or something is going wrong */
d182 2
a183 6
				num_disable--;
				if (num_disable == 0)
					{
					mh_mode|=CRYPTO_MEM_CHECK_ENABLE;
					CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);
					}
d201 1
a201 1
		CRYPTO_r_lock(CRYPTO_LOCK_MALLOC);
d204 1
a204 1
			|| (disabling_thread != CRYPTO_thread_id());
d206 1
a206 1
		CRYPTO_r_unlock(CRYPTO_LOCK_MALLOC);
d222 1
a222 2
/* static int mem_cmp(MEM *a, MEM *b) */
static int mem_cmp(const void *a_void, const void *b_void)
d224 1
a224 2
	return((const char *)((const MEM *)a_void)->addr
		- (const char *)((const MEM *)b_void)->addr);
d227 1
a227 2
/* static unsigned long mem_hash(MEM *a) */
static unsigned long mem_hash(const void *a_void)
d231 1
a231 1
	ret=(unsigned long)((const MEM *)a_void)->addr;
d237 1
a237 2
/* static int app_info_cmp(APP_INFO *a, APP_INFO *b) */
static int app_info_cmp(const void *a_void, const void *b_void)
d239 1
a239 2
	return(((const APP_INFO *)a_void)->thread
		!= ((const APP_INFO *)b_void)->thread);
d242 1
a242 2
/* static unsigned long app_info_hash(APP_INFO *a) */
static unsigned long app_info_hash(const void *a_void)
d246 1
a246 1
	ret=(unsigned long)((const APP_INFO *)a_void)->thread;
d252 1
a252 1
static APP_INFO *pop_info(void)
d269 1
a269 1
#ifdef LEVITTE_DEBUG_MEM
d282 1
a282 1
				OPENSSL_free(ret);
d296 1
a296 1
		MemCheck_off(); /* obtain MALLOC2 lock */
d298 1
a298 1
		if ((ami = (APP_INFO *)OPENSSL_malloc(sizeof(APP_INFO))) == NULL)
d305 1
a305 1
			if ((amih=lh_new(app_info_hash, app_info_cmp)) == NULL)
d307 1
a307 1
				OPENSSL_free(ami);
d322 1
a322 1
#ifdef LEVITTE_DEBUG_MEM
d333 1
a333 1
		MemCheck_on(); /* release MALLOC2 lock */
d345 1
a345 1
		MemCheck_off(); /* obtain MALLOC2 lock */
d349 1
a349 1
		MemCheck_on(); /* release MALLOC2 lock */
d360 1
a360 1
		MemCheck_off(); /* obtain MALLOC2 lock */
d365 1
a365 1
		MemCheck_on(); /* release MALLOC2 lock */
d388 2
a389 2
			MemCheck_off(); /* make sure we hold MALLOC2 lock */
			if ((m=(MEM *)OPENSSL_malloc(sizeof(MEM))) == NULL)
d391 2
a392 3
				OPENSSL_free(addr);
				MemCheck_on(); /* release MALLOC2 lock
				                * if num_disabled drops to 0 */
d397 1
a397 1
				if ((mh=lh_new(mem_hash, mem_cmp)) == NULL)
d399 2
a400 2
					OPENSSL_free(addr);
					OPENSSL_free(m);
d421 2
a422 2
#ifdef LEVITTE_DEBUG_MEM
			fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5d] %c 0x%p (%d)\n",
d448 1
a448 1
				OPENSSL_free(mm);
d451 1
a451 2
			MemCheck_on(); /* release MALLOC2 lock
			                * if num_disabled drops to 0 */
d470 1
a470 1
			MemCheck_off(); /* make sure we hold MALLOC2 lock */
d476 2
a477 2
#ifdef LEVITTE_DEBUG_MEM
			fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5d] - 0x%p (%d)\n",
d484 1
a484 1
				OPENSSL_free(mp);
d487 1
a487 2
			MemCheck_on(); /* release MALLOC2 lock
			                * if num_disabled drops to 0 */
d500 2
a501 2
#ifdef LEVITTE_DEBUG_MEM
	fprintf(stderr, "LEVITTE_DEBUG_MEM: --> CRYPTO_dbg_malloc(addr1 = %p, addr2 = %p, num = %d, file = \"%s\", line = %d, before_p = %d)\n",
d521 1
a521 1
			MemCheck_off(); /* make sure we hold MALLOC2 lock */
d527 2
a528 2
#ifdef LEVITTE_DEBUG_MEM
				fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5d] * 0x%p (%d) -> 0x%p (%d)\n",
d538 1
a538 2
			MemCheck_on(); /* release MALLOC2 lock
			                * if num_disabled drops to 0 */
d553 1
a553 1
static void print_leak(const MEM *m, MEM_LEAK *l)
d629 1
a629 1
#ifdef LEVITTE_DEBUG_MEM
a637 2
static IMPLEMENT_LHASH_DOALL_ARG_FN(print_leak, const MEM *, MEM_LEAK *)

d643 1
a643 5
	if (mh == NULL && amih == NULL)
		return;

	MemCheck_off(); /* obtain MALLOC2 lock */

d647 3
a649 3
	if (mh != NULL)
		lh_doall_arg(mh, LHASH_DOALL_ARG_FN(print_leak),
				(char *)&ml);
a655 18
	else
		{
		/* Make sure that, if we found no leaks, memory-leak debugging itself
		 * does not introduce memory leaks (which might irritate
		 * external debugging tools).
		 * (When someone enables leak checking, but does not call
		 * this function, we declare it to be their fault.)
		 *
		 * XXX    This should be in CRYPTO_mem_leaks_cb,
		 * and CRYPTO_mem_leaks should be implemented by
		 * using CRYPTO_mem_leaks_cb.
		 * (Also their should be a variant of lh_doall_arg
		 * that takes a function pointer instead of a void *;
		 * this would obviate the ugly and illegal
		 * void_fn_to_char kludge in CRYPTO_mem_leaks_cb.
		 * Otherwise the code police will come and get us.)
		 */
		int old_mh_mode;
d657 16
a672 1
		CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
d674 3
a676 4
		/* avoid deadlock when lh_free() uses CRYPTO_dbg_free(),
		 * which uses CRYPTO_is_mem_check_on */
		old_mh_mode = mh_mode;
		mh_mode = CRYPTO_MEM_CHECK_OFF;
d678 3
a680 13
		if (mh != NULL)
			{
			lh_free(mh);
			mh = NULL;
			}
		if (amih != NULL)
			{
			if (lh_num_items(amih) == 0) 
				{
				lh_free(amih);
				amih = NULL;
				}
			}
d682 6
a687 4
		mh_mode = old_mh_mode;
		CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
		}
	MemCheck_on(); /* release MALLOC2 lock */
d690 1
a690 1
#ifndef OPENSSL_NO_FP_API
d696 2
a697 7
	/* Need to turn off memory checking when allocated BIOs ... especially
	 * as we're creating them at a time when we're trying to check we've not
	 * left anything un-free()'d!! */
	MemCheck_off();
	b = BIO_new(BIO_s_file());
	MemCheck_on();
	if(!b) return;
a703 22


/* FIXME: We really don't allow much to the callback.  For example, it has
   no chance of reaching the info stack for the item it processes.  Should
   it really be this way?  -- Richard Levitte */
/* NB: The prototypes have been typedef'd to CRYPTO_MEM_LEAK_CB inside crypto.h
 * If this code is restructured, remove the callback type if it is no longer
 * needed. -- Geoff Thorpe */
static void cb_leak(const MEM *m, CRYPTO_MEM_LEAK_CB **cb)
	{
	(**cb)(m->order,m->file,m->line,m->num,m->addr);
	}

static IMPLEMENT_LHASH_DOALL_ARG_FN(cb_leak, const MEM *, CRYPTO_MEM_LEAK_CB **)

void CRYPTO_mem_leaks_cb(CRYPTO_MEM_LEAK_CB *cb)
	{
	if (mh == NULL) return;
	CRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);
	lh_doall_arg(mh, LHASH_DOALL_ARG_FN(cb_leak), &cb);
	CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);
	}
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@a104 2
static void app_info_free(APP_INFO *);

a142 12
static void app_info_free(APP_INFO *inf)
	{
	if (--(inf->references) <= 0)
		{
		if (inf->next != NULL)
			{
			app_info_free(inf->next);
			}
		OPENSSL_free(inf);
		}
	}

d505 3
a507 1
					app_info_free(mp->app_info);
d669 1
d684 3
a686 2
		BIO_printf(b,"%ld bytes leaked in %d chunks\n",
			   ml.bytes,ml.chunks);
@


1.1.1.3
log
@import openssl-0.9.7d
@
text
@a599 2
#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))

d607 1
a607 1
		BIO_snprintf(bufp, BUF_REMAIN, "[%02d:%02d:%02d] ",
d612 1
a612 1
	BIO_snprintf(bufp, BUF_REMAIN, "%5lu file=%s, line=%d, ",
d618 1
a618 1
		BIO_snprintf(bufp, BUF_REMAIN, "thread=%lu, ", m->thread);
d622 1
a622 1
	BIO_snprintf(bufp, BUF_REMAIN, "number=%d, address=%08lX\n",
d644 1
a644 1
		BIO_snprintf(buf + ami_cnt, sizeof buf - ami_cnt,
d656 1
a656 2
			BUF_strlcpy(buf + buf_len, amip->info,
				    sizeof buf - buf_len);
d659 1
a659 1
		BIO_snprintf(buf + buf_len, sizeof buf - buf_len, "\"\n");
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@a61 1
#include "cryptlib.h"
d66 1
a254 7
#ifdef _WIN64
	const char *a=(const char *)((const MEM *)a_void)->addr,
		   *b=(const char *)((const MEM *)b_void)->addr;
	if (a==b)	return 0;
	else if (a>b)	return 1;
	else		return -1;
#else
a256 1
#endif
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@d333 1
a333 1
int CRYPTO_dbg_push_info(const char *info, const char *file, int line)
d383 1
a383 1
int CRYPTO_dbg_pop_info(void)
d398 1
a398 1
int CRYPTO_dbg_remove_all_info(void)
a794 22
	}

void CRYPTO_malloc_debug_init(void)
	{
	CRYPTO_set_mem_debug_functions(
		CRYPTO_dbg_malloc,
		CRYPTO_dbg_realloc,
		CRYPTO_dbg_free,
		CRYPTO_dbg_set_options,
		CRYPTO_dbg_get_options);
	CRYPTO_set_mem_info_functions(
		CRYPTO_dbg_push_info,
		CRYPTO_dbg_pop_info,
		CRYPTO_dbg_remove_all_info);
	}

char *CRYPTO_strdup(const char *str, const char *file, int line)
	{
	char *ret = CRYPTO_malloc(strlen(str)+1, file, line);

	strcpy(ret, str);
	return ret;
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d84 2
a85 5

DECLARE_LHASH_OF(MEM);
static LHASH_OF(MEM) *mh=NULL; /* hash-table of memory requests
				* (address as key); access requires
				* MALLOC2 lock */
d96 2
a97 2
	{
	CRYPTO_THREADID threadid;
d107 4
a110 7
DECLARE_LHASH_OF(APP_INFO);
static LHASH_OF(APP_INFO) *amih=NULL; /* hash-table with those
				       * app_mem_info_st's that are at
				       * the top of their thread's
				       * stack (with `thread' as key);
				       * access requires MALLOC2
				       * lock */
d119 1
a119 1
	CRYPTO_THREADID threadid;
d139 5
a143 5

/* Valid iff num_disable > 0.  CRYPTO_LOCK_MALLOC2 is locked exactly in this
 * case (by the thread named in disabling_thread).
 */
static CRYPTO_THREADID disabling_threadid;
d180 1
a180 3
			CRYPTO_THREADID cur;
			CRYPTO_THREADID_current(&cur);
			if (!num_disable || CRYPTO_THREADID_cmp(&disabling_threadid, &cur)) /* otherwise we already have the MALLOC2 lock */
d198 1
a198 1
				CRYPTO_THREADID_cpy(&disabling_threadid, &cur);
a230 2
		CRYPTO_THREADID cur;
		CRYPTO_THREADID_current(&cur);
d234 1
a234 1
		        || CRYPTO_THREADID_cmp(&disabling_threadid, &cur);
d252 2
a253 1
static int mem_cmp(const MEM *a, const MEM *b)
d256 4
a259 4
	const char *ap=(const char *)a->addr,
		   *bp=(const char *)b->addr;
	if (ap==bp)	return 0;
	else if (ap>bp)	return 1;
d262 2
a263 1
	return (const char *)a->addr - (const char *)b->addr;
a265 1
static IMPLEMENT_LHASH_COMP_FN(mem, MEM)
d267 2
a268 1
static unsigned long mem_hash(const MEM *a)
d272 1
a272 1
	ret=(unsigned long)a->addr;
a276 1
static IMPLEMENT_LHASH_HASH_FN(mem, MEM)
d281 2
a282 2
	return CRYPTO_THREADID_cmp(&((const APP_INFO *)a_void)->threadid,
				&((const APP_INFO *)b_void)->threadid);
a283 1
static IMPLEMENT_LHASH_COMP_FN(app_info, APP_INFO)
d285 2
a286 1
static unsigned long app_info_hash(const APP_INFO *a)
d290 2
a291 2
	ret = CRYPTO_THREADID_hash(&a->threadid);
	/* This is left in as a "who am I to question legacy?" measure */
a294 1
static IMPLEMENT_LHASH_HASH_FN(app_info, APP_INFO)
d303 2
a304 2
		CRYPTO_THREADID_current(&tmp.threadid);
		if ((ret=lh_APP_INFO_delete(amih,&tmp)) != NULL)
d311 1
a311 1
				(void)lh_APP_INFO_insert(amih,next);
d314 1
a314 1
			if (CRYPTO_THREADID_cmp(&ret->threadid, &tmp.threadid))
d317 1
a317 2
					CRYPTO_THREADID_hash(&ret->threadid),
					CRYPTO_THREADID_hash(&tmp.threadid));
d333 1
a333 1
int CRYPTO_push_info_(const char *info, const char *file, int line)
d349 1
a349 1
			if ((amih=lh_APP_INFO_new()) == NULL)
d357 1
a357 1
		CRYPTO_THREADID_current(&ami->threadid);
d364 1
a364 1
		if ((amim=lh_APP_INFO_insert(amih,ami)) != NULL)
d367 1
a367 1
			if (CRYPTO_THREADID_cmp(&ami->threadid, &amim->threadid))
d370 1
a370 2
					CRYPTO_THREADID_hash(&amim->threadid),
					CRYPTO_THREADID_hash(&ami->threadid));
d383 1
a383 1
int CRYPTO_pop_info(void)
d398 1
a398 1
int CRYPTO_remove_all_info(void)
d442 1
a442 1
				if ((mh=lh_MEM_new()) == NULL)
d456 1
a456 1
				CRYPTO_THREADID_current(&m->threadid);
d458 1
a458 1
				memset(&m->threadid, 0, sizeof(m->threadid));
d467 1
a467 1
			fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] %c 0x%p (%d)\n",
d477 1
a477 1
			CRYPTO_THREADID_current(&tmp.threadid);
d480 1
a480 1
			    && (amim=lh_APP_INFO_retrieve(amih,&tmp)) != NULL)
d486 1
a486 1
			if ((mm=lh_MEM_insert(mh, m)) != NULL)
d519 1
a519 1
			mp=lh_MEM_delete(mh,&m);
d523 1
a523 1
			fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] - 0x%p (%d)\n",
d569 1
a569 1
			mp=lh_MEM_delete(mh,&m);
d573 1
a573 1
				fprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] * 0x%p (%d) -> 0x%p (%d)\n",
d580 1
a580 1
				(void)lh_MEM_insert(mh,mp);
d599 1
a599 1
static void print_leak_doall_arg(const MEM *m, MEM_LEAK *l)
d606 1
a606 1
	CRYPTO_THREADID ti;
d628 1
a628 2
		BIO_snprintf(bufp, BUF_REMAIN, "thread=%lu, ",
			CRYPTO_THREADID_hash(&m->threadid));
d645 2
a646 2
	CRYPTO_THREADID_cpy(&ti, &amip->threadid);

d656 1
a656 2
			CRYPTO_THREADID_hash(&amip->threadid), amip->file,
			amip->line);
d676 2
a677 2
	while(amip && !CRYPTO_THREADID_cmp(&amip->threadid, &ti));

d687 1
a687 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(print_leak, const MEM, MEM_LEAK)
d702 2
a703 2
		lh_MEM_doall_arg(mh, LHASH_DOALL_ARG_FN(print_leak), MEM_LEAK,
				 &ml);
a707 3
#ifdef CRYPTO_MDEBUG_ABORT
		abort();
#endif
d720 1
a720 1
		 * (Also there should be a variant of lh_doall_arg
d737 1
a737 1
			lh_MEM_free(mh);
d742 1
a742 1
			if (lh_APP_INFO_num_items(amih) == 0) 
d744 1
a744 1
				lh_APP_INFO_free(amih);
d782 1
a782 9

/* Can't pass CRYPTO_MEM_LEAK_CB directly to lh_MEM_doall_arg because it
 * is a function pointer and conversion to void * is prohibited. Instead
 * pass its address
 */

typedef CRYPTO_MEM_LEAK_CB *PCRYPTO_MEM_LEAK_CB;

static void cb_leak_doall_arg(const MEM *m, PCRYPTO_MEM_LEAK_CB *cb)
d784 1
a784 1
	(*cb)(m->order,m->file,m->line,m->num,m->addr);
d787 1
a787 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(cb_leak, const MEM, PCRYPTO_MEM_LEAK_CB)
d793 1
a793 2
	lh_MEM_doall_arg(mh, LHASH_DOALL_ARG_FN(cb_leak), PCRYPTO_MEM_LEAK_CB,
			 &cb);
d795 22
@


