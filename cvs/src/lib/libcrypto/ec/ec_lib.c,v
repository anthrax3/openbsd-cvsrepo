head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23;
locks; strict;
comment	@ * @;


1.23
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.22;
commitid	kT0fLt3r4lroFJra;

1.22
date	2016.09.03.12.10.40;	author beck;	state Exp;
branches;
next	1.21;
commitid	r1pIYZblZcsD1bx9;

1.21
date	2016.09.03.12.00.24;	author beck;	state Exp;
branches;
next	1.20;
commitid	tqsezUYa9RqTKJ3E;

1.20
date	2015.10.13.15.25.18;	author jsing;	state Exp;
branches;
next	1.19;
commitid	zfoBfa00yy2qcED1;

1.19
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.18;
commitid	vHznCDK3idwNEFz4;

1.18
date	2015.05.20.04.33.35;	author miod;	state Exp;
branches;
next	1.17;
commitid	8bghpUDWJ4RW3dSg;

1.17
date	2015.04.29.00.11.12;	author doug;	state Exp;
branches;
next	1.16;
commitid	DUDpybhZMBt1ldZh;

1.16
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.15;
commitid	69Tc75PIK8JcRRsC;

1.15
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.14;
commitid	G74O1dmRukKsW7IJ;

1.14
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.13;
commitid	nzndm3zqPmFurSaK;

1.13
date	2014.07.09.11.10.50;	author bcook;	state Exp;
branches;
next	1.12;
commitid	lHJTcoC4c5BhEOGj;

1.12
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	mJUVYpkFBZ0Zv2bG;

1.11
date	2014.05.30.02.52.11;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2014.05.06.03.56.27;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.15.18.55.21;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches
	1.6.4.1
	1.6.8.1;
next	1.5;

1.5
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.13;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.17;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.08;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.39;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.04.13.15.16.33;	author miod;	state Exp;
branches;
next	;

1.6.4.1
date	2014.08.09.16.55.55;	author tedu;	state Exp;
branches;
next	;
commitid	M9vFauFXshUDHG4j;

1.6.8.1
date	2014.08.09.16.54.57;	author tedu;	state Exp;
branches;
next	;
commitid	iDBdpZ9JdHGZqIAL;


desc
@@


1.23
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: ec_lib.c,v 1.22 2016/09/03 12:10:40 beck Exp $ */
/*
 * Originally written by Bodo Moeller for the OpenSSL project.
 */
/* ====================================================================
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * Binary polynomial ECC support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */

#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/err.h>
#include <openssl/opensslv.h>

#include "ec_lcl.h"

/* functions for EC_GROUP objects */

EC_GROUP *
EC_GROUP_new(const EC_METHOD * meth)
{
	EC_GROUP *ret;

	if (meth == NULL) {
		ECerror(EC_R_SLOT_FULL);
		return NULL;
	}
	if (meth->group_init == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return NULL;
	}
	ret = malloc(sizeof *ret);
	if (ret == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	ret->meth = meth;

	ret->extra_data = NULL;

	ret->generator = NULL;
	BN_init(&ret->order);
	BN_init(&ret->cofactor);

	ret->curve_name = 0;
	ret->asn1_flag = 0;
	ret->asn1_form = POINT_CONVERSION_UNCOMPRESSED;

	ret->seed = NULL;
	ret->seed_len = 0;

	if (!meth->group_init(ret)) {
		free(ret);
		return NULL;
	}
	return ret;
}


void 
EC_GROUP_free(EC_GROUP * group)
{
	if (!group)
		return;

	if (group->meth->group_finish != 0)
		group->meth->group_finish(group);

	EC_EX_DATA_free_all_data(&group->extra_data);

	EC_POINT_free(group->generator);
	BN_free(&group->order);
	BN_free(&group->cofactor);

	free(group->seed);

	free(group);
}


void 
EC_GROUP_clear_free(EC_GROUP * group)
{
	if (!group)
		return;

	if (group->meth->group_clear_finish != 0)
		group->meth->group_clear_finish(group);
	else if (group->meth->group_finish != 0)
		group->meth->group_finish(group);

	EC_EX_DATA_clear_free_all_data(&group->extra_data);

	EC_POINT_clear_free(group->generator);
	BN_clear_free(&group->order);
	BN_clear_free(&group->cofactor);

	if (group->seed) {
		explicit_bzero(group->seed, group->seed_len);
		free(group->seed);
	}
	explicit_bzero(group, sizeof *group);
	free(group);
}


int 
EC_GROUP_copy(EC_GROUP * dest, const EC_GROUP * src)
{
	EC_EXTRA_DATA *d;

	if (dest->meth->group_copy == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (dest->meth != src->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	if (dest == src)
		return 1;

	EC_EX_DATA_free_all_data(&dest->extra_data);

	for (d = src->extra_data; d != NULL; d = d->next) {
		void *t = d->dup_func(d->data);

		if (t == NULL)
			return 0;
		if (!EC_EX_DATA_set_data(&dest->extra_data, t, d->dup_func,
		    d->free_func, d->clear_free_func))
			return 0;
	}

	if (src->generator != NULL) {
		if (dest->generator == NULL) {
			dest->generator = EC_POINT_new(dest);
			if (dest->generator == NULL)
				return 0;
		}
		if (!EC_POINT_copy(dest->generator, src->generator))
			return 0;
	} else {
		/* src->generator == NULL */
		EC_POINT_clear_free(dest->generator);
		dest->generator = NULL;
	}

	if (!BN_copy(&dest->order, &src->order))
		return 0;
	if (!BN_copy(&dest->cofactor, &src->cofactor))
		return 0;

	dest->curve_name = src->curve_name;
	dest->asn1_flag = src->asn1_flag;
	dest->asn1_form = src->asn1_form;

	if (src->seed) {
		free(dest->seed);
		dest->seed = malloc(src->seed_len);
		if (dest->seed == NULL)
			return 0;
		memcpy(dest->seed, src->seed, src->seed_len);
		dest->seed_len = src->seed_len;
	} else {
		free(dest->seed);
		dest->seed = NULL;
		dest->seed_len = 0;
	}


	return dest->meth->group_copy(dest, src);
}


EC_GROUP *
EC_GROUP_dup(const EC_GROUP * a)
{
	EC_GROUP *t = NULL;

	if ((a != NULL) && ((t = EC_GROUP_new(a->meth)) != NULL) &&
	    (!EC_GROUP_copy(t, a))) {
		EC_GROUP_free(t);
		t = NULL;
	}
	return t;
}


const EC_METHOD *
EC_GROUP_method_of(const EC_GROUP *group)
{
	return group->meth;
}


int 
EC_METHOD_get_field_type(const EC_METHOD *meth)
{
	return meth->field_type;
}


int 
EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,
    const BIGNUM *order, const BIGNUM *cofactor)
{
	if (generator == NULL) {
		ECerror(ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	if (group->generator == NULL) {
		group->generator = EC_POINT_new(group);
		if (group->generator == NULL)
			return 0;
	}
	if (!EC_POINT_copy(group->generator, generator))
		return 0;

	if (order != NULL) {
		if (!BN_copy(&group->order, order))
			return 0;
	} else
		BN_zero(&group->order);

	if (cofactor != NULL) {
		if (!BN_copy(&group->cofactor, cofactor))
			return 0;
	} else
		BN_zero(&group->cofactor);

	return 1;
}


const EC_POINT *
EC_GROUP_get0_generator(const EC_GROUP *group)
{
	return group->generator;
}


int 
EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx)
{
	if (!BN_copy(order, &group->order))
		return 0;

	return !BN_is_zero(order);
}


int 
EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor, BN_CTX *ctx)
{
	if (!BN_copy(cofactor, &group->cofactor))
		return 0;

	return !BN_is_zero(&group->cofactor);
}


void 
EC_GROUP_set_curve_name(EC_GROUP * group, int nid)
{
	group->curve_name = nid;
}


int 
EC_GROUP_get_curve_name(const EC_GROUP * group)
{
	return group->curve_name;
}


void 
EC_GROUP_set_asn1_flag(EC_GROUP * group, int flag)
{
	group->asn1_flag = flag;
}


int 
EC_GROUP_get_asn1_flag(const EC_GROUP * group)
{
	return group->asn1_flag;
}


void 
EC_GROUP_set_point_conversion_form(EC_GROUP * group,
    point_conversion_form_t form)
{
	group->asn1_form = form;
}


point_conversion_form_t 
EC_GROUP_get_point_conversion_form(const EC_GROUP * group)
{
	return group->asn1_form;
}


size_t 
EC_GROUP_set_seed(EC_GROUP * group, const unsigned char *p, size_t len)
{
	if (group->seed) {
		free(group->seed);
		group->seed = NULL;
		group->seed_len = 0;
	}
	if (!len || !p)
		return 1;

	if ((group->seed = malloc(len)) == NULL)
		return 0;
	memcpy(group->seed, p, len);
	group->seed_len = len;

	return len;
}


unsigned char *
EC_GROUP_get0_seed(const EC_GROUP * group)
{
	return group->seed;
}


size_t 
EC_GROUP_get_seed_len(const EC_GROUP * group)
{
	return group->seed_len;
}


int 
EC_GROUP_set_curve_GFp(EC_GROUP * group, const BIGNUM * p, const BIGNUM * a,
    const BIGNUM * b, BN_CTX * ctx)
{
	if (group->meth->group_set_curve == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	return group->meth->group_set_curve(group, p, a, b, ctx);
}


int 
EC_GROUP_get_curve_GFp(const EC_GROUP * group, BIGNUM * p, BIGNUM * a,
    BIGNUM * b, BN_CTX * ctx)
{
	if (group->meth->group_get_curve == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	return group->meth->group_get_curve(group, p, a, b, ctx);
}

#ifndef OPENSSL_NO_EC2M
int 
EC_GROUP_set_curve_GF2m(EC_GROUP * group, const BIGNUM * p, const BIGNUM * a,
    const BIGNUM * b, BN_CTX * ctx)
{
	if (group->meth->group_set_curve == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	return group->meth->group_set_curve(group, p, a, b, ctx);
}


int 
EC_GROUP_get_curve_GF2m(const EC_GROUP * group, BIGNUM * p, BIGNUM * a,
    BIGNUM * b, BN_CTX * ctx)
{
	if (group->meth->group_get_curve == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	return group->meth->group_get_curve(group, p, a, b, ctx);
}
#endif

int 
EC_GROUP_get_degree(const EC_GROUP * group)
{
	if (group->meth->group_get_degree == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	return group->meth->group_get_degree(group);
}


int 
EC_GROUP_check_discriminant(const EC_GROUP * group, BN_CTX * ctx)
{
	if (group->meth->group_check_discriminant == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	return group->meth->group_check_discriminant(group, ctx);
}


int 
EC_GROUP_cmp(const EC_GROUP * a, const EC_GROUP * b, BN_CTX * ctx)
{
	int r = 0;
	BIGNUM *a1, *a2, *a3, *b1, *b2, *b3;
	BN_CTX *ctx_new = NULL;

	/* compare the field types */
	if (EC_METHOD_get_field_type(EC_GROUP_method_of(a)) !=
	    EC_METHOD_get_field_type(EC_GROUP_method_of(b)))
		return 1;
	/* compare the curve name (if present in both) */
	if (EC_GROUP_get_curve_name(a) && EC_GROUP_get_curve_name(b) &&
	    EC_GROUP_get_curve_name(a) != EC_GROUP_get_curve_name(b))
		return 1;

	if (!ctx)
		ctx_new = ctx = BN_CTX_new();
	if (!ctx)
		return -1;

	BN_CTX_start(ctx);
	if ((a1 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((a2 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((a3 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((b1 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((b2 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((b3 = BN_CTX_get(ctx)) == NULL)
		goto err;

	/*
	 * XXX This approach assumes that the external representation of
	 * curves over the same field type is the same.
	 */
	if (!a->meth->group_get_curve(a, a1, a2, a3, ctx) ||
	    !b->meth->group_get_curve(b, b1, b2, b3, ctx))
		r = 1;

	if (r || BN_cmp(a1, b1) || BN_cmp(a2, b2) || BN_cmp(a3, b3))
		r = 1;

	/* XXX EC_POINT_cmp() assumes that the methods are equal */
	if (r || EC_POINT_cmp(a, EC_GROUP_get0_generator(a),
		EC_GROUP_get0_generator(b), ctx))
		r = 1;

	if (!r) {
		/* compare the order and cofactor */
		if (!EC_GROUP_get_order(a, a1, ctx) ||
		    !EC_GROUP_get_order(b, b1, ctx) ||
		    !EC_GROUP_get_cofactor(a, a2, ctx) ||
		    !EC_GROUP_get_cofactor(b, b2, ctx))
			goto err;
		if (BN_cmp(a1, b1) || BN_cmp(a2, b2))
			r = 1;
	}
	BN_CTX_end(ctx);
	if (ctx_new)
		BN_CTX_free(ctx);

	return r;

err:
	BN_CTX_end(ctx);
	if (ctx_new)
		BN_CTX_free(ctx);
	return -1;
}


/* this has 'package' visibility */
int 
EC_EX_DATA_set_data(EC_EXTRA_DATA ** ex_data, void *data,
    void *(*dup_func) (void *),
    void (*free_func) (void *),
    void (*clear_free_func) (void *))
{
	EC_EXTRA_DATA *d;

	if (ex_data == NULL)
		return 0;

	for (d = *ex_data; d != NULL; d = d->next) {
		if (d->dup_func == dup_func && d->free_func == free_func &&
		    d->clear_free_func == clear_free_func) {
			ECerror(EC_R_SLOT_FULL);
			return 0;
		}
	}

	if (data == NULL)
		/* no explicit entry needed */
		return 1;

	d = malloc(sizeof *d);
	if (d == NULL)
		return 0;

	d->data = data;
	d->dup_func = dup_func;
	d->free_func = free_func;
	d->clear_free_func = clear_free_func;

	d->next = *ex_data;
	*ex_data = d;

	return 1;
}

/* this has 'package' visibility */
void *
EC_EX_DATA_get_data(const EC_EXTRA_DATA * ex_data,
    void *(*dup_func) (void *),
    void (*free_func) (void *),
    void (*clear_free_func) (void *))
{
	const EC_EXTRA_DATA *d;

	for (d = ex_data; d != NULL; d = d->next) {
		if (d->dup_func == dup_func && d->free_func == free_func && d->clear_free_func == clear_free_func)
			return d->data;
	}

	return NULL;
}

/* this has 'package' visibility */
void 
EC_EX_DATA_free_data(EC_EXTRA_DATA ** ex_data,
    void *(*dup_func) (void *),
    void (*free_func) (void *),
    void (*clear_free_func) (void *))
{
	EC_EXTRA_DATA **p;

	if (ex_data == NULL)
		return;

	for (p = ex_data; *p != NULL; p = &((*p)->next)) {
		if ((*p)->dup_func == dup_func &&
		    (*p)->free_func == free_func &&
		    (*p)->clear_free_func == clear_free_func) {
			EC_EXTRA_DATA *next = (*p)->next;

			(*p)->free_func((*p)->data);
			free(*p);

			*p = next;
			return;
		}
	}
}

/* this has 'package' visibility */
void 
EC_EX_DATA_clear_free_data(EC_EXTRA_DATA ** ex_data,
    void *(*dup_func) (void *),
    void (*free_func) (void *),
    void (*clear_free_func) (void *))
{
	EC_EXTRA_DATA **p;

	if (ex_data == NULL)
		return;

	for (p = ex_data; *p != NULL; p = &((*p)->next)) {
		if ((*p)->dup_func == dup_func &&
		    (*p)->free_func == free_func &&
		    (*p)->clear_free_func == clear_free_func) {
			EC_EXTRA_DATA *next = (*p)->next;

			(*p)->clear_free_func((*p)->data);
			free(*p);

			*p = next;
			return;
		}
	}
}

/* this has 'package' visibility */
void 
EC_EX_DATA_free_all_data(EC_EXTRA_DATA ** ex_data)
{
	EC_EXTRA_DATA *d;

	if (ex_data == NULL)
		return;

	d = *ex_data;
	while (d) {
		EC_EXTRA_DATA *next = d->next;

		d->free_func(d->data);
		free(d);

		d = next;
	}
	*ex_data = NULL;
}

/* this has 'package' visibility */
void 
EC_EX_DATA_clear_free_all_data(EC_EXTRA_DATA ** ex_data)
{
	EC_EXTRA_DATA *d;

	if (ex_data == NULL)
		return;

	d = *ex_data;
	while (d) {
		EC_EXTRA_DATA *next = d->next;

		d->clear_free_func(d->data);
		free(d);

		d = next;
	}
	*ex_data = NULL;
}


/* functions for EC_POINT objects */

EC_POINT *
EC_POINT_new(const EC_GROUP * group)
{
	EC_POINT *ret;

	if (group == NULL) {
		ECerror(ERR_R_PASSED_NULL_PARAMETER);
		return NULL;
	}
	if (group->meth->point_init == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return NULL;
	}
	ret = malloc(sizeof *ret);
	if (ret == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	ret->meth = group->meth;

	if (!ret->meth->point_init(ret)) {
		free(ret);
		return NULL;
	}
	return ret;
}


void 
EC_POINT_free(EC_POINT * point)
{
	if (!point)
		return;

	if (point->meth->point_finish != 0)
		point->meth->point_finish(point);
	free(point);
}


void 
EC_POINT_clear_free(EC_POINT * point)
{
	if (!point)
		return;

	if (point->meth->point_clear_finish != 0)
		point->meth->point_clear_finish(point);
	else if (point->meth->point_finish != 0)
		point->meth->point_finish(point);
	explicit_bzero(point, sizeof *point);
	free(point);
}


int 
EC_POINT_copy(EC_POINT * dest, const EC_POINT * src)
{
	if (dest->meth->point_copy == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (dest->meth != src->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	if (dest == src)
		return 1;
	return dest->meth->point_copy(dest, src);
}


EC_POINT *
EC_POINT_dup(const EC_POINT * a, const EC_GROUP * group)
{
	EC_POINT *t;
	int r;

	if (a == NULL)
		return NULL;

	t = EC_POINT_new(group);
	if (t == NULL)
		return (NULL);
	r = EC_POINT_copy(t, a);
	if (!r) {
		EC_POINT_free(t);
		return NULL;
	} else
		return t;
}


const EC_METHOD *
EC_POINT_method_of(const EC_POINT * point)
{
	return point->meth;
}


int 
EC_POINT_set_to_infinity(const EC_GROUP * group, EC_POINT * point)
{
	if (group->meth->point_set_to_infinity == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->point_set_to_infinity(group, point);
}


int 
EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,
    const BIGNUM *x, const BIGNUM *y, const BIGNUM *z, BN_CTX *ctx)
{
	if (group->meth->point_set_Jprojective_coordinates_GFp == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->point_set_Jprojective_coordinates_GFp(group, point, x, y, z, ctx);
}


int 
EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,
    const EC_POINT *point, BIGNUM *x, BIGNUM *y, BIGNUM *z, BN_CTX *ctx)
{
	if (group->meth->point_get_Jprojective_coordinates_GFp == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->point_get_Jprojective_coordinates_GFp(group, point, x, y, z, ctx);
}


int 
EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,
    const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)
{
	if (group->meth->point_set_affine_coordinates == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->point_set_affine_coordinates(group, point, x, y, ctx);
}

#ifndef OPENSSL_NO_EC2M
int 
EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *point,
    const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)
{
	if (group->meth->point_set_affine_coordinates == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->point_set_affine_coordinates(group, point, x, y, ctx);
}
#endif

int 
EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group, const EC_POINT *point,
    BIGNUM *x, BIGNUM *y, BN_CTX *ctx)
{
	if (group->meth->point_get_affine_coordinates == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->point_get_affine_coordinates(group, point, x, y, ctx);
}

#ifndef OPENSSL_NO_EC2M
int 
EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group, const EC_POINT *point,
    BIGNUM *x, BIGNUM *y, BN_CTX *ctx)
{
	if (group->meth->point_get_affine_coordinates == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->point_get_affine_coordinates(group, point, x, y, ctx);
}
#endif

int 
EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
    const EC_POINT *b, BN_CTX *ctx)
{
	if (group->meth->add == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if ((group->meth != r->meth) || (r->meth != a->meth) || (a->meth != b->meth)) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->add(group, r, a, b, ctx);
}


int 
EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx)
{
	if (group->meth->dbl == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if ((group->meth != r->meth) || (r->meth != a->meth)) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->dbl(group, r, a, ctx);
}


int 
EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx)
{
	if (group->meth->invert == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != a->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->invert(group, a, ctx);
}


int 
EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)
{
	if (group->meth->is_at_infinity == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->is_at_infinity(group, point);
}


int 
EC_POINT_is_on_curve(const EC_GROUP * group, const EC_POINT * point, BN_CTX * ctx)
{
	if (group->meth->is_on_curve == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->is_on_curve(group, point, ctx);
}


int 
EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b,
    BN_CTX * ctx)
{
	if (group->meth->point_cmp == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return -1;
	}
	if ((group->meth != a->meth) || (a->meth != b->meth)) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return -1;
	}
	return group->meth->point_cmp(group, a, b, ctx);
}


int 
EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
{
	if (group->meth->make_affine == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (group->meth != point->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	return group->meth->make_affine(group, point, ctx);
}


int 
EC_POINTs_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[],
    BN_CTX *ctx)
{
	size_t i;

	if (group->meth->points_make_affine == 0) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	for (i = 0; i < num; i++) {
		if (group->meth != points[i]->meth) {
			ECerror(EC_R_INCOMPATIBLE_OBJECTS);
			return 0;
		}
	}
	return group->meth->points_make_affine(group, num, points, ctx);
}


/* Functions for point multiplication.
 *
 * If group->meth->mul is 0, we use the wNAF-based implementations in ec_mult.c;
 * otherwise we dispatch through methods.
 */

int 
EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
    size_t num, const EC_POINT *points[], const BIGNUM *scalars[], BN_CTX *ctx)
{
	if (group->meth->mul == 0)
		/* use default */
		return ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);

	return group->meth->mul(group, r, scalar, num, points, scalars, ctx);
}

int 
EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
    const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
	/* just a convenient interface to EC_POINTs_mul() */

	const EC_POINT *points[1];
	const BIGNUM *scalars[1];

	points[0] = point;
	scalars[0] = p_scalar;

	return EC_POINTs_mul(group, r, g_scalar,
	    (point != NULL && p_scalar != NULL),
	    points, scalars, ctx);
}

int 
EC_GROUP_precompute_mult(EC_GROUP * group, BN_CTX * ctx)
{
	if (group->meth->mul == 0)
		/* use default */
		return ec_wNAF_precompute_mult(group, ctx);

	if (group->meth->precompute_mult != 0)
		return group->meth->precompute_mult(group, ctx);
	else
		return 1;	/* nothing to do, so report success */
}

int 
EC_GROUP_have_precompute_mult(const EC_GROUP * group)
{
	if (group->meth->mul == 0)
		/* use default */
		return ec_wNAF_have_precompute_mult(group);

	if (group->meth->have_precompute_mult != 0)
		return group->meth->have_precompute_mult(group);
	else
		return 0;	/* cannot tell whether precomputation has
				 * been performed */
}

EC_KEY *
ECParameters_dup(EC_KEY *key)
{
	unsigned char *p = NULL;
	EC_KEY *k = NULL;
	int len;

	if (key == NULL)
		return (NULL);

	if ((len = i2d_ECParameters(key, &p)) > 0)
		k = d2i_ECParameters(NULL, (const unsigned char **)&p, len);

	return (k);	
}
@


1.22
log
@remove unused variable
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.21 2016/09/03 12:00:24 beck Exp $ */
d81 1
a81 1
		ECerr(EC_F_EC_GROUP_NEW, EC_R_SLOT_FULL);
d85 1
a85 1
		ECerr(EC_F_EC_GROUP_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d90 1
a90 1
		ECerr(EC_F_EC_GROUP_NEW, ERR_R_MALLOC_FAILURE);
d169 1
a169 1
		ECerr(EC_F_EC_GROUP_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d173 1
a173 1
		ECerr(EC_F_EC_GROUP_COPY, EC_R_INCOMPATIBLE_OBJECTS);
d265 1
a265 1
		ECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);
d401 1
a401 1
		ECerr(EC_F_EC_GROUP_SET_CURVE_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d413 1
a413 1
		ECerr(EC_F_EC_GROUP_GET_CURVE_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d425 1
a425 1
		ECerr(EC_F_EC_GROUP_SET_CURVE_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d437 1
a437 1
		ECerr(EC_F_EC_GROUP_GET_CURVE_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d448 1
a448 1
		ECerr(EC_F_EC_GROUP_GET_DEGREE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d459 1
a459 1
		ECerr(EC_F_EC_GROUP_CHECK_DISCRIMINANT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d556 1
a556 1
			ECerr(EC_F_EC_EX_DATA_SET_DATA, EC_R_SLOT_FULL);
d702 1
a702 1
		ECerr(EC_F_EC_POINT_NEW, ERR_R_PASSED_NULL_PARAMETER);
d706 1
a706 1
		ECerr(EC_F_EC_POINT_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d711 1
a711 1
		ECerr(EC_F_EC_POINT_NEW, ERR_R_MALLOC_FAILURE);
d755 1
a755 1
		ECerr(EC_F_EC_POINT_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d759 1
a759 1
		ECerr(EC_F_EC_POINT_COPY, EC_R_INCOMPATIBLE_OBJECTS);
d800 1
a800 1
		ECerr(EC_F_EC_POINT_SET_TO_INFINITY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d804 1
a804 1
		ECerr(EC_F_EC_POINT_SET_TO_INFINITY, EC_R_INCOMPATIBLE_OBJECTS);
d816 1
a816 1
		ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d820 1
a820 1
		ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);
d832 1
a832 1
		ECerr(EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d836 1
a836 1
		ECerr(EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);
d848 1
a848 1
		ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d852 1
a852 1
		ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);
d864 1
a864 1
		ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d868 1
a868 1
		ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M, EC_R_INCOMPATIBLE_OBJECTS);
d880 1
a880 1
		ECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d884 1
a884 1
		ECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);
d896 1
a896 1
		ECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d900 1
a900 1
		ECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M, EC_R_INCOMPATIBLE_OBJECTS);
d912 1
a912 1
		ECerr(EC_F_EC_POINT_ADD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d916 1
a916 1
		ECerr(EC_F_EC_POINT_ADD, EC_R_INCOMPATIBLE_OBJECTS);
d927 1
a927 1
		ECerr(EC_F_EC_POINT_DBL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d931 1
a931 1
		ECerr(EC_F_EC_POINT_DBL, EC_R_INCOMPATIBLE_OBJECTS);
d942 1
a942 1
		ECerr(EC_F_EC_POINT_INVERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d946 1
a946 1
		ECerr(EC_F_EC_POINT_INVERT, EC_R_INCOMPATIBLE_OBJECTS);
d957 1
a957 1
		ECerr(EC_F_EC_POINT_IS_AT_INFINITY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d961 1
a961 1
		ECerr(EC_F_EC_POINT_IS_AT_INFINITY, EC_R_INCOMPATIBLE_OBJECTS);
d972 1
a972 1
		ECerr(EC_F_EC_POINT_IS_ON_CURVE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d976 1
a976 1
		ECerr(EC_F_EC_POINT_IS_ON_CURVE, EC_R_INCOMPATIBLE_OBJECTS);
d988 1
a988 1
		ECerr(EC_F_EC_POINT_CMP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d992 1
a992 1
		ECerr(EC_F_EC_POINT_CMP, EC_R_INCOMPATIBLE_OBJECTS);
d1003 1
a1003 1
		ECerr(EC_F_EC_POINT_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d1007 1
a1007 1
		ECerr(EC_F_EC_POINT_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
d1021 1
a1021 1
		ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d1026 1
a1026 1
			ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
@


1.21
log
@Fix some very unnecessary convoultion.
ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.20 2015/10/13 15:25:18 jsing Exp $ */
a235 1
	int ok = 0;
@


1.20
log
@Convert ECParameters_dup() from a macro that uses ASN1_dup_of() into an
actual function. This removes the last ASN1_dup_of usage from the tree.

Feedback from doug@@ and miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.19 2015/09/10 15:56:25 jsing Exp $ */
d238 2
a239 12
	if (a == NULL)
		return NULL;

	if ((t = EC_GROUP_new(a->meth)) == NULL)
		return (NULL);
	if (!EC_GROUP_copy(t, a))
		goto err;

	ok = 1;

err:
	if (!ok) {
d241 3
a243 3
		return NULL;
	} else
		return t;
@


1.19
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.18 2015/05/20 04:33:35 miod Exp $ */
d1104 16
@


1.18
log
@No need to check the return value of memcpy() if you actually checked this
pointer for NULL the line above; ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.17 2015/04/29 00:11:12 doug Exp $ */
d155 1
a155 1
		OPENSSL_cleanse(group->seed, group->seed_len);
d158 1
a158 1
	OPENSSL_cleanse(group, sizeof *group);
d757 1
a757 1
	OPENSSL_cleanse(point, sizeof *point);
@


1.17
log
@Add missing BN_CTX_end() calls.

After calling BN_CTX_start(), there must be a BN_CTX_end() before
returning.  There were missing BN_CTX_end() calls in error paths.  One diff
chunk was simply removing redundant code related to this.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.16 2015/02/09 15:49:22 jsing Exp $ */
d219 1
a219 2
		if (!memcpy(dest->seed, src->seed, src->seed_len))
			return 0;
@


1.16
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.15 2014/07/12 16:03:37 miod Exp $ */
d534 2
a535 6
		    !EC_GROUP_get_cofactor(b, b2, ctx)) {
			BN_CTX_end(ctx);
			if (ctx_new)
				BN_CTX_free(ctx);
			return -1;
		}
@


1.15
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.14 2014/07/10 22:45:57 jsing Exp $ */
d500 13
a512 12
	a1 = BN_CTX_get(ctx);
	a2 = BN_CTX_get(ctx);
	a3 = BN_CTX_get(ctx);
	b1 = BN_CTX_get(ctx);
	b2 = BN_CTX_get(ctx);
	b3 = BN_CTX_get(ctx);
	if (!b3) {
		BN_CTX_end(ctx);
		if (ctx_new)
			BN_CTX_free(ctx);
		return -1;
	}
d548 6
@


1.14
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.13 2014/07/09 11:10:50 bcook Exp $ */
d127 1
a127 2
	if (group->generator != NULL)
		EC_POINT_free(group->generator);
d150 1
a150 2
	if (group->generator != NULL)
		EC_POINT_clear_free(group->generator);
d201 2
a202 4
		if (dest->generator != NULL) {
			EC_POINT_clear_free(dest->generator);
			dest->generator = NULL;
		}
d251 1
a251 2
		if (t)
			EC_GROUP_free(t);
@


1.13
log
@remove unused, private version strings except SSL_version_str

Also remove unused des_ver.h, which exports some of these strings, but is not installed.

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_lib.c,v 1.12 2014/06/12 15:49:29 deraadt Exp $ */
d65 2
@


1.12
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a69 3

static const char EC_version[] = "EC" OPENSSL_VERSION_PTEXT;

@


1.11
log
@no need for null check before free. from Brendan MacDonell
@
text
@d1 1
a1 1
/* crypto/ec/ec_lib.c */
@


1.10
log
@knf approximation
@
text
@d133 1
a133 2
	if (group->seed)
		free(group->seed);
d220 1
a220 2
		if (dest->seed)
			free(dest->seed);
d228 1
a228 2
		if (dest->seed)
			free(dest->seed);
@


1.9
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d60 1
a60 1
 * Binary polynomial ECC support in OpenSSL originally developed by 
d76 3
a78 2
EC_GROUP *EC_GROUP_new(const EC_METHOD *meth)
	{
d81 1
a81 2
	if (meth == NULL)
		{
d84 2
a85 3
		}
	if (meth->group_init == 0)
		{
d88 1
a88 2
		}

d90 1
a90 2
	if (ret == NULL)
		{
d93 1
a93 2
		}

d102 3
a104 3
	ret->curve_name = 0;	
	ret->asn1_flag  = 0;
	ret->asn1_form  = POINT_CONVERSION_UNCOMPRESSED;
d109 1
a109 2
	if (!meth->group_init(ret))
		{
d112 1
a112 2
		}
	
d114 1
a114 1
	}
d117 5
a121 3
void EC_GROUP_free(EC_GROUP *group)
	{
	if (!group) return;
d137 2
a138 2
	}
 
d140 5
a144 3
void EC_GROUP_clear_free(EC_GROUP *group)
	{
	if (!group) return;
d158 1
a158 2
	if (group->seed)
		{
d161 1
a161 2
		}

d164 1
a164 1
	}
d167 3
a169 2
int EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)
	{
d172 1
a172 2
	if (dest->meth->group_copy == 0)
		{
d175 2
a176 3
		}
	if (dest->meth != src->meth)
		{
d179 1
a179 1
		}
d182 1
a182 1
	
d185 1
a185 2
	for (d = src->extra_data; d != NULL; d = d->next)
		{
d187 1
a187 1
		
d190 2
a191 1
		if (!EC_EX_DATA_set_data(&dest->extra_data, t, d->dup_func, d->free_func, d->clear_free_func))
d193 1
a193 1
		}
d195 2
a196 4
	if (src->generator != NULL)
		{
		if (dest->generator == NULL)
			{
d198 2
a199 3
			if (dest->generator == NULL) return 0;
			}
		if (!EC_POINT_copy(dest->generator, src->generator)) return 0;
d201 3
a203 2
	else
		{
d205 1
a205 2
		if (dest->generator != NULL)
			{
a207 1
			}
d209 1
d211 4
a214 2
	if (!BN_copy(&dest->order, &src->order)) return 0;
	if (!BN_copy(&dest->cofactor, &src->cofactor)) return 0;
d217 2
a218 2
	dest->asn1_flag  = src->asn1_flag;
	dest->asn1_form  = src->asn1_form;
d220 1
a220 2
	if (src->seed)
		{
d229 1
a229 3
		}
	else
		{
d234 2
a235 2
		}
	
d238 1
a238 1
	}
d241 3
a243 2
EC_GROUP *EC_GROUP_dup(const EC_GROUP *a)
	{
d247 2
a248 1
	if (a == NULL) return NULL;
d250 4
a253 2
	if ((t = EC_GROUP_new(a->meth)) == NULL) return(NULL);
	if (!EC_GROUP_copy(t, a)) goto err;
d257 4
a260 4
  err:	
	if (!ok)
		{
		if (t) EC_GROUP_free(t);
d262 3
a264 3
		}
	else return t;
	}
d267 3
a269 2
const EC_METHOD *EC_GROUP_method_of(const EC_GROUP *group)
	{
d271 1
a271 1
	}
d274 5
a278 4
int EC_METHOD_get_field_type(const EC_METHOD *meth)
        {
        return meth->field_type;
        }
d281 5
a285 4
int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor)
	{
	if (generator == NULL)
		{
d287 3
a289 5
		return 0   ;
		}

	if (group->generator == NULL)
		{
d291 5
a295 3
		if (group->generator == NULL) return 0;
		}
	if (!EC_POINT_copy(group->generator, generator)) return 0;
d297 4
a300 3
	if (order != NULL)
		{ if (!BN_copy(&group->order, order)) return 0; }	
	else
d303 4
a306 3
	if (cofactor != NULL)
		{ if (!BN_copy(&group->cofactor, cofactor)) return 0; }	
	else
d310 1
a310 1
	}
d313 3
a315 2
const EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group)
	{
d317 1
a317 1
	}
d320 3
a322 2
int EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx)
	{
d327 1
a327 1
	}
d330 3
a332 2
int EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor, BN_CTX *ctx)
	{
d337 1
a337 1
	}
d340 3
a342 2
void EC_GROUP_set_curve_name(EC_GROUP *group, int nid)
	{
d344 1
a344 1
	}
d347 3
a349 2
int EC_GROUP_get_curve_name(const EC_GROUP *group)
	{
d351 1
a351 1
	}
d354 3
a356 2
void EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag)
	{
d358 1
a358 1
	}
d361 3
a363 2
int EC_GROUP_get_asn1_flag(const EC_GROUP *group)
	{
d365 1
a365 1
	}
d368 4
a371 3
void EC_GROUP_set_point_conversion_form(EC_GROUP *group, 
                                        point_conversion_form_t form)
	{
d373 1
a373 1
	}
d376 3
a378 2
point_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *group)
	{
d380 1
a380 1
	}
d383 4
a386 4
size_t EC_GROUP_set_seed(EC_GROUP *group, const unsigned char *p, size_t len)
	{
	if (group->seed)
		{
d390 1
a390 2
		}

d400 1
a400 1
	}
d403 3
a405 2
unsigned char *EC_GROUP_get0_seed(const EC_GROUP *group)
	{
d407 1
a407 1
	}
d410 3
a412 2
size_t EC_GROUP_get_seed_len(const EC_GROUP *group)
	{
d414 1
a414 1
	}
d417 5
a421 4
int EC_GROUP_set_curve_GFp(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
	{
	if (group->meth->group_set_curve == 0)
		{
d424 1
a424 1
		}
d426 1
a426 1
	}
d429 5
a433 4
int EC_GROUP_get_curve_GFp(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
	{
	if (group->meth->group_get_curve == 0)
		{
d436 1
a436 1
		}
d438 1
a438 1
	}
d441 5
a445 4
int EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
	{
	if (group->meth->group_set_curve == 0)
		{
d448 1
a448 1
		}
d450 1
a450 1
	}
d453 5
a457 4
int EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
	{
	if (group->meth->group_get_curve == 0)
		{
d460 1
a460 1
		}
d462 1
a462 1
	}
d465 4
a468 4
int EC_GROUP_get_degree(const EC_GROUP *group)
	{
	if (group->meth->group_get_degree == 0)
		{
d471 1
a471 1
		}
d473 1
a473 1
	}
d476 4
a479 4
int EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)
	{
	if (group->meth->group_check_discriminant == 0)
		{
d482 1
a482 1
		}
d484 1
a484 1
	}
d487 4
a490 3
int EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx)
	{
	int    r = 0;
d494 1
a494 1
	/* compare the field types*/
d507 1
a507 1
	
d515 1
a515 2
	if (!b3)
		{
d520 4
a523 4
		}

	/* XXX This approach assumes that the external representation
	 * of curves over the same field type is the same.
d534 1
a534 1
	    EC_GROUP_get0_generator(b), ctx))
d537 1
a537 2
	if (!r)
		{
d542 1
a542 2
		    !EC_GROUP_get_cofactor(b, b2, ctx))
			{
d547 1
a547 1
			}
d550 1
a550 2
		}

d556 1
a556 1
	}
d560 6
a565 3
int EC_EX_DATA_set_data(EC_EXTRA_DATA **ex_data, void *data,
	void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))
	{
d571 3
a573 4
	for (d = *ex_data; d != NULL; d = d->next)
		{
		if (d->dup_func == dup_func && d->free_func == free_func && d->clear_free_func == clear_free_func)
			{
a575 1
			}
d577 1
d596 1
a596 1
	}
d599 6
a604 3
void *EC_EX_DATA_get_data(const EC_EXTRA_DATA *ex_data,
	void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))
	{
d607 1
a607 2
	for (d = ex_data; d != NULL; d = d->next)
		{
d610 2
a611 2
		}
	
d613 1
a613 1
	}
d616 6
a621 3
void EC_EX_DATA_free_data(EC_EXTRA_DATA **ex_data,
	void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))
	{
d627 4
a630 4
	for (p = ex_data; *p != NULL; p = &((*p)->next))
		{
		if ((*p)->dup_func == dup_func && (*p)->free_func == free_func && (*p)->clear_free_func == clear_free_func)
			{
d635 1
a635 1
			
a637 1
			}
d640 1
d643 6
a648 3
void EC_EX_DATA_clear_free_data(EC_EXTRA_DATA **ex_data,
	void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))
	{
d654 4
a657 4
	for (p = ex_data; *p != NULL; p = &((*p)->next))
		{
		if ((*p)->dup_func == dup_func && (*p)->free_func == free_func && (*p)->clear_free_func == clear_free_func)
			{
d662 1
a662 1
			
a664 1
			}
d667 1
d670 3
a672 2
void EC_EX_DATA_free_all_data(EC_EXTRA_DATA **ex_data)
	{
d679 1
a679 2
	while (d)
		{
d681 1
a681 1
		
d684 1
a684 1
		
d686 1
a686 1
		}
d688 1
a688 1
	}
d691 3
a693 2
void EC_EX_DATA_clear_free_all_data(EC_EXTRA_DATA **ex_data)
	{
d700 1
a700 2
	while (d)
		{
d702 1
a702 1
		
d705 1
a705 1
		
d707 1
a707 1
		}
d709 1
a709 1
	}
d714 3
a716 2
EC_POINT *EC_POINT_new(const EC_GROUP *group)
	{
d719 1
a719 2
	if (group == NULL)
		{
d722 2
a723 3
		}
	if (group->meth->point_init == 0)
		{
d726 1
a726 2
		}

d728 1
a728 2
	if (ret == NULL)
		{
d731 2
a732 1
		}
d734 1
a734 4
	ret->meth = group->meth;
	
	if (!ret->meth->point_init(ret))
		{
d737 1
a737 2
		}
	
d739 1
a739 1
	}
d742 5
a746 3
void EC_POINT_free(EC_POINT *point)
	{
	if (!point) return;
d751 2
a752 2
	}
 
d754 5
a758 3
void EC_POINT_clear_free(EC_POINT *point)
	{
	if (!point) return;
d766 1
a766 1
	}
d769 4
a772 4
int EC_POINT_copy(EC_POINT *dest, const EC_POINT *src)
	{
	if (dest->meth->point_copy == 0)
		{
d775 2
a776 3
		}
	if (dest->meth != src->meth)
		{
d779 1
a779 1
		}
d783 1
a783 1
	}
d786 3
a788 2
EC_POINT *EC_POINT_dup(const EC_POINT *a, const EC_GROUP *group)
	{
d792 2
a793 1
	if (a == NULL) return NULL;
d796 2
a797 1
	if (t == NULL) return(NULL);
d799 1
a799 2
	if (!r)
		{
d802 3
a804 3
		}
	else return t;
	}
d807 3
a809 2
const EC_METHOD *EC_POINT_method_of(const EC_POINT *point)
	{
d811 1
a811 1
	}
d814 4
a817 4
int EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point)
	{
	if (group->meth->point_set_to_infinity == 0)
		{
d820 2
a821 3
		}
	if (group->meth != point->meth)
		{
d824 1
a824 1
		}
d826 1
a826 1
	}
d829 5
a833 5
int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x, const BIGNUM *y, const BIGNUM *z, BN_CTX *ctx)
	{
	if (group->meth->point_set_Jprojective_coordinates_GFp == 0)
		{
d836 2
a837 3
		}
	if (group->meth != point->meth)
		{
d840 1
a840 1
		}
d842 1
a842 1
	}
d845 5
a849 5
int EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group, const EC_POINT *point,
	BIGNUM *x, BIGNUM *y, BIGNUM *z, BN_CTX *ctx)
	{
	if (group->meth->point_get_Jprojective_coordinates_GFp == 0)
		{
d852 2
a853 3
		}
	if (group->meth != point->meth)
		{
d856 1
a856 1
		}
d858 1
a858 1
	}
d861 5
a865 5
int EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)
	{
	if (group->meth->point_set_affine_coordinates == 0)
		{
d868 2
a869 3
		}
	if (group->meth != point->meth)
		{
d872 1
a872 1
		}
d874 1
a874 1
	}
d877 5
a881 5
int EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)
	{
	if (group->meth->point_set_affine_coordinates == 0)
		{
d884 2
a885 3
		}
	if (group->meth != point->meth)
		{
d888 1
a888 1
		}
d890 1
a890 1
	}
d893 5
a897 5
int EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group, const EC_POINT *point,
	BIGNUM *x, BIGNUM *y, BN_CTX *ctx)
	{
	if (group->meth->point_get_affine_coordinates == 0)
		{
d900 2
a901 3
		}
	if (group->meth != point->meth)
		{
d904 1
a904 1
		}
d906 1
a906 1
	}
d909 5
a913 5
int EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group, const EC_POINT *point,
	BIGNUM *x, BIGNUM *y, BN_CTX *ctx)
	{
	if (group->meth->point_get_affine_coordinates == 0)
		{
d916 2
a917 3
		}
	if (group->meth != point->meth)
		{
d920 1
a920 1
		}
d922 1
a922 1
	}
d925 5
a929 4
int EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)
	{
	if (group->meth->add == 0)
		{
d932 2
a933 3
		}
	if ((group->meth != r->meth) || (r->meth != a->meth) || (a->meth != b->meth))
		{
d936 1
a936 1
		}
d938 1
a938 1
	}
d941 4
a944 4
int EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx)
	{
	if (group->meth->dbl == 0)
		{
d947 2
a948 3
		}
	if ((group->meth != r->meth) || (r->meth != a->meth))
		{
d951 1
a951 1
		}
d953 1
a953 1
	}
d956 4
a959 4
int EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx)
	{
	if (group->meth->invert == 0)
		{
d962 2
a963 3
		}
	if (group->meth != a->meth)
		{
d966 1
a966 1
		}
d968 1
a968 1
	}
d971 4
a974 4
int EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)
	{
	if (group->meth->is_at_infinity == 0)
		{
d977 2
a978 3
		}
	if (group->meth != point->meth)
		{
d981 1
a981 1
		}
d983 1
a983 1
	}
d986 4
a989 4
int EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point, BN_CTX *ctx)
	{
	if (group->meth->is_on_curve == 0)
		{
d992 2
a993 3
		}
	if (group->meth != point->meth)
		{
d996 1
a996 1
		}
d998 1
a998 1
	}
d1001 5
a1005 4
int EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)
	{
	if (group->meth->point_cmp == 0)
		{
d1008 2
a1009 3
		}
	if ((group->meth != a->meth) || (a->meth != b->meth))
		{
d1012 1
a1012 1
		}
d1014 1
a1014 1
	}
d1017 4
a1020 4
int EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
	{
	if (group->meth->make_affine == 0)
		{
d1023 2
a1024 3
		}
	if (group->meth != point->meth)
		{
d1027 1
a1027 1
		}
d1029 1
a1029 1
	}
d1032 4
a1035 2
int EC_POINTs_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[], BN_CTX *ctx)
	{
d1038 1
a1038 2
	if (group->meth->points_make_affine == 0)
		{
d1041 3
a1043 5
		}
	for (i = 0; i < num; i++)
		{
		if (group->meth != points[i]->meth)
			{
a1045 1
			}
d1047 1
d1049 1
a1049 1
	}
d1058 4
a1061 3
int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
	size_t num, const EC_POINT *points[], const BIGNUM *scalars[], BN_CTX *ctx)
	{
d1067 1
a1067 1
	}
d1069 4
a1072 3
int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
	const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
	{
d1081 8
a1088 5
	return EC_POINTs_mul(group, r, g_scalar, (point != NULL && p_scalar != NULL), points, scalars, ctx);
	}

int EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
	{
d1096 2
a1097 2
		return 1; /* nothing to do, so report success */
	}
d1099 3
a1101 2
int EC_GROUP_have_precompute_mult(const EC_GROUP *group)
	{
d1109 3
a1111 2
		return 0; /* cannot tell whether precomputation has been performed */
	}
@


1.8
log
@In EC_POINT_invert(), actually check the correct function pointer for NULL
before attempting to invoke it; trivial one-liner in OpenSSL RT #2569 ignored
for 2.5 years.
@
text
@d91 1
a91 1
	ret = OPENSSL_malloc(sizeof *ret);
d115 1
a115 1
		OPENSSL_free(ret);
d138 1
a138 1
		OPENSSL_free(group->seed);
d140 1
a140 1
	OPENSSL_free(group);
d163 1
a163 1
		OPENSSL_free(group->seed);
d167 1
a167 1
	OPENSSL_free(group);
d229 2
a230 2
			OPENSSL_free(dest->seed);
		dest->seed = OPENSSL_malloc(src->seed_len);
d240 1
a240 1
			OPENSSL_free(dest->seed);
d378 1
a378 1
		OPENSSL_free(group->seed);
d386 1
a386 1
	if ((group->seed = OPENSSL_malloc(len)) == NULL)
d570 1
a570 1
	d = OPENSSL_malloc(sizeof *d);
d616 1
a616 1
			OPENSSL_free(*p);
d640 1
a640 1
			OPENSSL_free(*p);
d662 1
a662 1
		OPENSSL_free(d);
d683 1
a683 1
		OPENSSL_free(d);
d708 1
a708 1
	ret = OPENSSL_malloc(sizeof *ret);
d719 1
a719 1
		OPENSSL_free(ret);
d733 1
a733 1
	OPENSSL_free(point);
d746 1
a746 1
	OPENSSL_free(point);
@


1.7
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d945 1
a945 1
	if (group->meth->dbl == 0)
@


1.6
log
@resolve conflicts
@
text
@d483 1
a483 1
	/* compare the curve name (if present) */
d485 2
a486 2
	    EC_GROUP_get_curve_name(a) == EC_GROUP_get_curve_name(b))
		return 0;
d996 1
a996 1
		return 0;
d1001 1
a1001 1
		return 0;
@


1.6.4.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d945 1
a945 1
	if (group->meth->invert == 0)
@


1.6.8.1
log
@backport relevant security fixes from openssl 1.0.1i
tested by bcook jsg
@
text
@d945 1
a945 1
	if (group->meth->invert == 0)
@


1.5
log
@resolve conflicts, fix local changes
@
text
@d428 1
a428 1

d449 1
a449 1

d859 1
a859 1

d875 1
a875 1

d893 1
a893 1

d909 1
a909 69


int EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x, int y_bit, BN_CTX *ctx)
	{
	if (group->meth->point_set_compressed_coordinates == 0)
		{
		ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
		}
	if (group->meth != point->meth)
		{
		ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
		}
	return group->meth->point_set_compressed_coordinates(group, point, x, y_bit, ctx);
	}


int EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x, int y_bit, BN_CTX *ctx)
	{
	if (group->meth->point_set_compressed_coordinates == 0)
		{
		ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
		}
	if (group->meth != point->meth)
		{
		ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M, EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
		}
	return group->meth->point_set_compressed_coordinates(group, point, x, y_bit, ctx);
	}


size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *point, point_conversion_form_t form,
        unsigned char *buf, size_t len, BN_CTX *ctx)
	{
	if (group->meth->point2oct == 0)
		{
		ECerr(EC_F_EC_POINT_POINT2OCT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
		}
	if (group->meth != point->meth)
		{
		ECerr(EC_F_EC_POINT_POINT2OCT, EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
		}
	return group->meth->point2oct(group, point, form, buf, len, ctx);
	}


int EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *point,
        const unsigned char *buf, size_t len, BN_CTX *ctx)
	{
	if (group->meth->oct2point == 0)
		{
		ECerr(EC_F_EC_POINT_OCT2POINT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
		}
	if (group->meth != point->meth)
		{
		ECerr(EC_F_EC_POINT_OCT2POINT, EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
		}
	return group->meth->oct2point(group, point, buf, len, ctx);
	}

@


1.4
log
@resolve conflicts
@
text
@d82 1
a82 1
		ECerr(EC_F_EC_GROUP_NEW, ERR_R_PASSED_NULL_PARAMETER);
d743 1
a743 1
	else if (point->meth != NULL && point->meth->point_finish != 0)
@


1.3
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d2 3
d6 1
a6 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d58 5
d101 12
a112 4
	ret->extra_data_dup_func = 0;
	ret->extra_data_free_func = 0;
	ret->extra_data_clear_free_func = 0;
	
d130 9
a138 1
	EC_GROUP_free_extra_data(group);
d150 1
a150 1
	else if (group->meth != NULL && group->meth->group_finish != 0)
d153 12
a164 1
	EC_GROUP_clear_free_extra_data(group);
d173 2
d188 22
a209 2
	EC_GROUP_clear_free_extra_data(dest);
	if (src->extra_data_dup_func)
d211 2
a212 1
		if (src->extra_data != NULL)
d214 2
a215 3
			dest->extra_data = src->extra_data_dup_func(src->extra_data);
			if (dest->extra_data == NULL)
				return 0;
d217 4
d222 14
a235 3
		dest->extra_data_dup_func = src->extra_data_dup_func;
		dest->extra_data_free_func = src->extra_data_free_func;
		dest->extra_data_clear_free_func = src->extra_data_clear_free_func;
d237 8
d250 22
d278 129
d409 1
a409 1
	if (group->meth->group_set_curve_GFp == 0)
d414 1
a414 1
	return group->meth->group_set_curve_GFp(group, p, a, b, ctx);
d420 1
a420 1
	if (group->meth->group_get_curve_GFp == 0)
d425 1
a425 1
	return group->meth->group_get_curve_GFp(group, p, a, b, ctx);
d429 1
a429 1
int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor)
d431 1
a431 1
	if (group->meth->group_set_generator == 0)
d433 1
a433 1
		ECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d436 1
a436 1
	return group->meth->group_set_generator(group, generator, order, cofactor);
d440 1
a440 1
EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group)
d442 1
a442 1
	if (group->meth->group_get0_generator == 0)
d444 1
a444 1
		ECerr(EC_F_EC_GROUP_GET0_GENERATOR, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d447 1
a447 1
	return group->meth->group_get0_generator(group);
d451 1
a451 1
int EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx)
d453 1
a453 1
	if (group->meth->group_get_order == 0)
d455 1
a455 1
		ECerr(EC_F_EC_GROUP_GET_ORDER, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d458 1
a458 1
	return group->meth->group_get_order(group, order, ctx);
d462 1
a462 1
int EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor, BN_CTX *ctx)
d464 1
a464 1
	if (group->meth->group_get_cofactor == 0)
d466 1
a466 1
		ECerr(EC_F_EC_GROUP_GET_COFACTOR, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d469 1
a469 1
	return group->meth->group_get_cofactor(group, cofactor, ctx);
d473 1
a473 3
/* this has 'package' visibility */
int EC_GROUP_set_extra_data(EC_GROUP *group, void *extra_data, void *(*extra_data_dup_func)(void *),
	void (*extra_data_free_func)(void *), void (*extra_data_clear_free_func)(void *))
d475 11
a485 6
	if ((group->extra_data != NULL)
		|| (group->extra_data_dup_func != 0)
		|| (group->extra_data_free_func != 0)
		|| (group->extra_data_clear_free_func != 0))
		{
		ECerr(EC_F_EC_GROUP_SET_EXTRA_DATA, EC_R_SLOT_FULL);
d487 51
d540 5
a544 5
	group->extra_data = extra_data;
	group->extra_data_dup_func = extra_data_dup_func;
	group->extra_data_free_func = extra_data_free_func;
	group->extra_data_clear_free_func = extra_data_clear_free_func;
	return 1;
d549 2
a550 2
void *EC_GROUP_get_extra_data(const EC_GROUP *group, void *(*extra_data_dup_func)(void *),
	void (*extra_data_free_func)(void *), void (*extra_data_clear_free_func)(void *))
d552 12
a563 8
	if ((group->extra_data_dup_func != extra_data_dup_func)
		|| (group->extra_data_free_func != extra_data_free_func)
		|| (group->extra_data_clear_free_func != extra_data_clear_free_func))
		{
#if 0 /* this was an error in 0.9.7, but that does not make a lot of sense */
		ECerr(..._F_EC_GROUP_GET_EXTRA_DATA, ..._R_NO_SUCH_EXTRA_DATA);
#endif
		return NULL;
d566 17
a582 1
	return group->extra_data;
d585 14
d601 2
a602 1
void EC_GROUP_free_extra_data(EC_GROUP *group)
d604 18
a621 6
	if (group->extra_data_free_func)
		group->extra_data_free_func(group->extra_data);
	group->extra_data = NULL;
	group->extra_data_dup_func = 0;
	group->extra_data_free_func = 0;
	group->extra_data_clear_free_func = 0;
d624 23
d649 1
a649 1
void EC_GROUP_clear_free_extra_data(EC_GROUP *group)
d651 16
a666 8
	if (group->extra_data_clear_free_func)
		group->extra_data_clear_free_func(group->extra_data);
	else if (group->extra_data_free_func)
		group->extra_data_free_func(group->extra_data);
	group->extra_data = NULL;
	group->extra_data_dup_func = 0;
	group->extra_data_free_func = 0;
	group->extra_data_clear_free_func = 0;
d669 20
d768 19
d846 1
a846 1
	if (group->meth->point_set_affine_coordinates_GFp == 0)
d856 18
a873 1
	return group->meth->point_set_affine_coordinates_GFp(group, point, x, y, ctx);
d880 1
a880 1
	if (group->meth->point_get_affine_coordinates_GFp == 0)
d890 18
a907 1
	return group->meth->point_get_affine_coordinates_GFp(group, point, x, y, ctx);
d914 1
a914 1
	if (group->meth->point_set_compressed_coordinates_GFp == 0)
d924 18
a941 1
	return group->meth->point_set_compressed_coordinates_GFp(group, point, x, y_bit, ctx);
d1015 1
a1015 1
		ECerr(EC_F_EC_POINT_DBL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d1020 1
a1020 1
		ECerr(EC_F_EC_POINT_DBL, EC_R_INCOMPATIBLE_OBJECTS);
d1109 55
@


1.2
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d131 1
a131 1
	memset(group, 0, sizeof *group);
d271 3
a273 1
		ECerr(EC_F_EC_GROUP_GET_EXTRA_DATA, EC_R_NO_SUCH_EXTRA_DATA);
d362 1
a362 1
	memset(point, 0, sizeof *point);
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d109 2
d122 2
d344 2
d354 2
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a108 2
	if (!group) return;

a119 2
	if (!group) return;

a339 2
	if (!point) return;

a347 2
	if (!point) return;

@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d131 1
a131 1
	OPENSSL_cleanse(group, sizeof *group);
d271 1
a271 3
#if 0 /* this was an error in 0.9.7, but that does not make a lot of sense */
		ECerr(..._F_EC_GROUP_GET_EXTRA_DATA, ..._R_NO_SUCH_EXTRA_DATA);
#endif
d360 1
a360 1
	OPENSSL_cleanse(point, sizeof *point);
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@a1 3
/*
 * Originally written by Bodo Moeller for the OpenSSL project.
 */
d3 1
a3 1
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
a54 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * Binary polynomial ECC support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
d93 4
a96 12

	ret->generator = NULL;
	BN_init(&ret->order);
	BN_init(&ret->cofactor);

	ret->curve_name = 0;	
	ret->asn1_flag  = 0;
	ret->asn1_form  = POINT_CONVERSION_UNCOMPRESSED;

	ret->seed = NULL;
	ret->seed_len = 0;

d114 1
a114 9
	EC_EX_DATA_free_all_data(&group->extra_data);

	if (group->generator != NULL)
		EC_POINT_free(group->generator);
	BN_free(&group->order);
	BN_free(&group->cofactor);

	if (group->seed)
		OPENSSL_free(group->seed);
d126 1
a126 1
	else if (group->meth->group_finish != 0)
d129 1
a129 12
	EC_EX_DATA_clear_free_all_data(&group->extra_data);

	if (group->generator != NULL)
		EC_POINT_clear_free(group->generator);
	BN_clear_free(&group->order);
	BN_clear_free(&group->cofactor);

	if (group->seed)
		{
		OPENSSL_cleanse(group->seed, group->seed_len);
		OPENSSL_free(group->seed);
		}
a137 2
	EC_EXTRA_DATA *d;

d151 2
a152 22
	EC_EX_DATA_free_all_data(&dest->extra_data);

	for (d = src->extra_data; d != NULL; d = d->next)
		{
		void *t = d->dup_func(d->data);
		
		if (t == NULL)
			return 0;
		if (!EC_EX_DATA_set_data(&dest->extra_data, t, d->dup_func, d->free_func, d->clear_free_func))
			return 0;
		}

	if (src->generator != NULL)
		{
		if (dest->generator == NULL)
			{
			dest->generator = EC_POINT_new(dest);
			if (dest->generator == NULL) return 0;
			}
		if (!EC_POINT_copy(dest->generator, src->generator)) return 0;
		}
	else
d154 1
a154 2
		/* src->generator == NULL */
		if (dest->generator != NULL)
d156 3
a158 2
			EC_POINT_clear_free(dest->generator);
			dest->generator = NULL;
a159 4
		}

	if (!BN_copy(&dest->order, &src->order)) return 0;
	if (!BN_copy(&dest->cofactor, &src->cofactor)) return 0;
d161 3
a163 14
	dest->curve_name = src->curve_name;
	dest->asn1_flag  = src->asn1_flag;
	dest->asn1_form  = src->asn1_form;

	if (src->seed)
		{
		if (dest->seed)
			OPENSSL_free(dest->seed);
		dest->seed = OPENSSL_malloc(src->seed_len);
		if (dest->seed == NULL)
			return 0;
		if (!memcpy(dest->seed, src->seed, src->seed_len))
			return 0;
		dest->seed_len = src->seed_len;
a164 8
	else
		{
		if (dest->seed)
			OPENSSL_free(dest->seed);
		dest->seed = NULL;
		dest->seed_len = 0;
		}
	
a169 22
EC_GROUP *EC_GROUP_dup(const EC_GROUP *a)
	{
	EC_GROUP *t = NULL;
	int ok = 0;

	if (a == NULL) return NULL;

	if ((t = EC_GROUP_new(a->meth)) == NULL) return(NULL);
	if (!EC_GROUP_copy(t, a)) goto err;

	ok = 1;

  err:	
	if (!ok)
		{
		if (t) EC_GROUP_free(t);
		return NULL;
		}
	else return t;
	}


a175 129
int EC_METHOD_get_field_type(const EC_METHOD *meth)
        {
        return meth->field_type;
        }


int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor)
	{
	if (generator == NULL)
		{
		ECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);
		return 0   ;
		}

	if (group->generator == NULL)
		{
		group->generator = EC_POINT_new(group);
		if (group->generator == NULL) return 0;
		}
	if (!EC_POINT_copy(group->generator, generator)) return 0;

	if (order != NULL)
		{ if (!BN_copy(&group->order, order)) return 0; }	
	else
		BN_zero(&group->order);

	if (cofactor != NULL)
		{ if (!BN_copy(&group->cofactor, cofactor)) return 0; }	
	else
		BN_zero(&group->cofactor);

	return 1;
	}


const EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group)
	{
	return group->generator;
	}


int EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx)
	{
	if (!BN_copy(order, &group->order))
		return 0;

	return !BN_is_zero(order);
	}


int EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor, BN_CTX *ctx)
	{
	if (!BN_copy(cofactor, &group->cofactor))
		return 0;

	return !BN_is_zero(&group->cofactor);
	}


void EC_GROUP_set_curve_name(EC_GROUP *group, int nid)
	{
	group->curve_name = nid;
	}


int EC_GROUP_get_curve_name(const EC_GROUP *group)
	{
	return group->curve_name;
	}


void EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag)
	{
	group->asn1_flag = flag;
	}


int EC_GROUP_get_asn1_flag(const EC_GROUP *group)
	{
	return group->asn1_flag;
	}


void EC_GROUP_set_point_conversion_form(EC_GROUP *group, 
                                        point_conversion_form_t form)
	{
	group->asn1_form = form;
	}


point_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *group)
	{
	return group->asn1_form;
	}


size_t EC_GROUP_set_seed(EC_GROUP *group, const unsigned char *p, size_t len)
	{
	if (group->seed)
		{
		OPENSSL_free(group->seed);
		group->seed = NULL;
		group->seed_len = 0;
		}

	if (!len || !p)
		return 1;

	if ((group->seed = OPENSSL_malloc(len)) == NULL)
		return 0;
	memcpy(group->seed, p, len);
	group->seed_len = len;

	return len;
	}


unsigned char *EC_GROUP_get0_seed(const EC_GROUP *group)
	{
	return group->seed;
	}


size_t EC_GROUP_get_seed_len(const EC_GROUP *group)
	{
	return group->seed_len;
	}


d178 1
a178 1
	if (group->meth->group_set_curve == 0)
d183 1
a183 1
	return group->meth->group_set_curve(group, p, a, b, ctx);
d189 1
a189 1
	if (group->meth->group_get_curve == 0)
d194 1
a194 1
	return group->meth->group_get_curve(group, p, a, b, ctx);
d198 1
a198 1
int EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
d200 1
a200 1
	if (group->meth->group_set_curve == 0)
d202 1
a202 1
		ECerr(EC_F_EC_GROUP_SET_CURVE_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d205 1
a205 1
	return group->meth->group_set_curve(group, p, a, b, ctx);
d209 1
a209 1
int EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
d211 1
a211 1
	if (group->meth->group_get_curve == 0)
d213 1
a213 1
		ECerr(EC_F_EC_GROUP_GET_CURVE_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d216 1
a216 1
	return group->meth->group_get_curve(group, p, a, b, ctx);
d220 1
a220 1
int EC_GROUP_get_degree(const EC_GROUP *group)
d222 1
a222 1
	if (group->meth->group_get_degree == 0)
d224 1
a224 1
		ECerr(EC_F_EC_GROUP_GET_DEGREE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d227 1
a227 1
	return group->meth->group_get_degree(group);
d231 1
a231 1
int EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)
d233 1
a233 1
	if (group->meth->group_check_discriminant == 0)
d235 1
a235 1
		ECerr(EC_F_EC_GROUP_CHECK_DISCRIMINANT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d238 1
a238 1
	return group->meth->group_check_discriminant(group, ctx);
d242 3
a244 1
int EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx)
d246 6
a251 11
	int    r = 0;
	BIGNUM *a1, *a2, *a3, *b1, *b2, *b3;
	BN_CTX *ctx_new = NULL;

	/* compare the field types*/
	if (EC_METHOD_get_field_type(EC_GROUP_method_of(a)) !=
	    EC_METHOD_get_field_type(EC_GROUP_method_of(b)))
		return 1;
	/* compare the curve name (if present) */
	if (EC_GROUP_get_curve_name(a) && EC_GROUP_get_curve_name(b) &&
	    EC_GROUP_get_curve_name(a) == EC_GROUP_get_curve_name(b))
a252 51

	if (!ctx)
		ctx_new = ctx = BN_CTX_new();
	if (!ctx)
		return -1;
	
	BN_CTX_start(ctx);
	a1 = BN_CTX_get(ctx);
	a2 = BN_CTX_get(ctx);
	a3 = BN_CTX_get(ctx);
	b1 = BN_CTX_get(ctx);
	b2 = BN_CTX_get(ctx);
	b3 = BN_CTX_get(ctx);
	if (!b3)
		{
		BN_CTX_end(ctx);
		if (ctx_new)
			BN_CTX_free(ctx);
		return -1;
		}

	/* XXX This approach assumes that the external representation
	 * of curves over the same field type is the same.
	 */
	if (!a->meth->group_get_curve(a, a1, a2, a3, ctx) ||
	    !b->meth->group_get_curve(b, b1, b2, b3, ctx))
		r = 1;

	if (r || BN_cmp(a1, b1) || BN_cmp(a2, b2) || BN_cmp(a3, b3))
		r = 1;

	/* XXX EC_POINT_cmp() assumes that the methods are equal */
	if (r || EC_POINT_cmp(a, EC_GROUP_get0_generator(a),
	    EC_GROUP_get0_generator(b), ctx))
		r = 1;

	if (!r)
		{
		/* compare the order and cofactor */
		if (!EC_GROUP_get_order(a, a1, ctx) ||
		    !EC_GROUP_get_order(b, b1, ctx) ||
		    !EC_GROUP_get_cofactor(a, a2, ctx) ||
		    !EC_GROUP_get_cofactor(b, b2, ctx))
			{
			BN_CTX_end(ctx);
			if (ctx_new)
				BN_CTX_free(ctx);
			return -1;
			}
		if (BN_cmp(a1, b1) || BN_cmp(a2, b2))
			r = 1;
d255 5
a259 5
	BN_CTX_end(ctx);
	if (ctx_new)
		BN_CTX_free(ctx);

	return r;
d264 2
a265 2
int EC_EX_DATA_set_data(EC_EXTRA_DATA **ex_data, void *data,
	void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))
d267 8
a274 12
	EC_EXTRA_DATA *d;

	if (ex_data == NULL)
		return 0;

	for (d = *ex_data; d != NULL; d = d->next)
		{
		if (d->dup_func == dup_func && d->free_func == free_func && d->clear_free_func == clear_free_func)
			{
			ECerr(EC_F_EC_EX_DATA_SET_DATA, EC_R_SLOT_FULL);
			return 0;
			}
d277 1
a277 17
	if (data == NULL)
		/* no explicit entry needed */
		return 1;

	d = OPENSSL_malloc(sizeof *d);
	if (d == NULL)
		return 0;

	d->data = data;
	d->dup_func = dup_func;
	d->free_func = free_func;
	d->clear_free_func = clear_free_func;

	d->next = *ex_data;
	*ex_data = d;

	return 1;
a279 14
/* this has 'package' visibility */
void *EC_EX_DATA_get_data(const EC_EXTRA_DATA *ex_data,
	void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))
	{
	const EC_EXTRA_DATA *d;

	for (d = ex_data; d != NULL; d = d->next)
		{
		if (d->dup_func == dup_func && d->free_func == free_func && d->clear_free_func == clear_free_func)
			return d->data;
		}
	
	return NULL;
	}
d282 1
a282 2
void EC_EX_DATA_free_data(EC_EXTRA_DATA **ex_data,
	void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))
d284 6
a289 18
	EC_EXTRA_DATA **p;

	if (ex_data == NULL)
		return;

	for (p = ex_data; *p != NULL; p = &((*p)->next))
		{
		if ((*p)->dup_func == dup_func && (*p)->free_func == free_func && (*p)->clear_free_func == clear_free_func)
			{
			EC_EXTRA_DATA *next = (*p)->next;

			(*p)->free_func((*p)->data);
			OPENSSL_free(*p);
			
			*p = next;
			return;
			}
		}
a291 23
/* this has 'package' visibility */
void EC_EX_DATA_clear_free_data(EC_EXTRA_DATA **ex_data,
	void *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))
	{
	EC_EXTRA_DATA **p;

	if (ex_data == NULL)
		return;

	for (p = ex_data; *p != NULL; p = &((*p)->next))
		{
		if ((*p)->dup_func == dup_func && (*p)->free_func == free_func && (*p)->clear_free_func == clear_free_func)
			{
			EC_EXTRA_DATA *next = (*p)->next;

			(*p)->clear_free_func((*p)->data);
			OPENSSL_free(*p);
			
			*p = next;
			return;
			}
		}
	}
d294 1
a294 1
void EC_EX_DATA_free_all_data(EC_EXTRA_DATA **ex_data)
d296 8
a303 16
	EC_EXTRA_DATA *d;

	if (ex_data == NULL)
		return;

	d = *ex_data;
	while (d)
		{
		EC_EXTRA_DATA *next = d->next;
		
		d->free_func(d->data);
		OPENSSL_free(d);
		
		d = next;
		}
	*ex_data = NULL;
a305 20
/* this has 'package' visibility */
void EC_EX_DATA_clear_free_all_data(EC_EXTRA_DATA **ex_data)
	{
	EC_EXTRA_DATA *d;

	if (ex_data == NULL)
		return;

	d = *ex_data;
	while (d)
		{
		EC_EXTRA_DATA *next = d->next;
		
		d->clear_free_func(d->data);
		OPENSSL_free(d);
		
		d = next;
		}
	*ex_data = NULL;
	}
a384 19
EC_POINT *EC_POINT_dup(const EC_POINT *a, const EC_GROUP *group)
	{
	EC_POINT *t;
	int r;

	if (a == NULL) return NULL;

	t = EC_POINT_new(group);
	if (t == NULL) return(NULL);
	r = EC_POINT_copy(t, a);
	if (!r)
		{
		EC_POINT_free(t);
		return NULL;
		}
	else return t;
	}


d444 1
a444 1
	if (group->meth->point_set_affine_coordinates == 0)
d454 1
a454 18
	return group->meth->point_set_affine_coordinates(group, point, x, y, ctx);
	}


int EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)
	{
	if (group->meth->point_set_affine_coordinates == 0)
		{
		ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
		}
	if (group->meth != point->meth)
		{
		ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M, EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
		}
	return group->meth->point_set_affine_coordinates(group, point, x, y, ctx);
d461 1
a461 1
	if (group->meth->point_get_affine_coordinates == 0)
d471 1
a471 18
	return group->meth->point_get_affine_coordinates(group, point, x, y, ctx);
	}


int EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group, const EC_POINT *point,
	BIGNUM *x, BIGNUM *y, BN_CTX *ctx)
	{
	if (group->meth->point_get_affine_coordinates == 0)
		{
		ECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
		}
	if (group->meth != point->meth)
		{
		ECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M, EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
		}
	return group->meth->point_get_affine_coordinates(group, point, x, y, ctx);
d478 1
a478 1
	if (group->meth->point_set_compressed_coordinates == 0)
d488 1
a488 18
	return group->meth->point_set_compressed_coordinates(group, point, x, y_bit, ctx);
	}


int EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group, EC_POINT *point,
	const BIGNUM *x, int y_bit, BN_CTX *ctx)
	{
	if (group->meth->point_set_compressed_coordinates == 0)
		{
		ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
		}
	if (group->meth != point->meth)
		{
		ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M, EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
		}
	return group->meth->point_set_compressed_coordinates(group, point, x, y_bit, ctx);
d562 1
a562 1
		ECerr(EC_F_EC_POINT_INVERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d567 1
a567 1
		ECerr(EC_F_EC_POINT_INVERT, EC_R_INCOMPATIBLE_OBJECTS);
a655 55
	}


/* Functions for point multiplication.
 *
 * If group->meth->mul is 0, we use the wNAF-based implementations in ec_mult.c;
 * otherwise we dispatch through methods.
 */

int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
	size_t num, const EC_POINT *points[], const BIGNUM *scalars[], BN_CTX *ctx)
	{
	if (group->meth->mul == 0)
		/* use default */
		return ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);

	return group->meth->mul(group, r, scalar, num, points, scalars, ctx);
	}

int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
	const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
	{
	/* just a convenient interface to EC_POINTs_mul() */

	const EC_POINT *points[1];
	const BIGNUM *scalars[1];

	points[0] = point;
	scalars[0] = p_scalar;

	return EC_POINTs_mul(group, r, g_scalar, (point != NULL && p_scalar != NULL), points, scalars, ctx);
	}

int EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
	{
	if (group->meth->mul == 0)
		/* use default */
		return ec_wNAF_precompute_mult(group, ctx);

	if (group->meth->precompute_mult != 0)
		return group->meth->precompute_mult(group, ctx);
	else
		return 1; /* nothing to do, so report success */
	}

int EC_GROUP_have_precompute_mult(const EC_GROUP *group)
	{
	if (group->meth->mul == 0)
		/* use default */
		return ec_wNAF_have_precompute_mult(group);

	if (group->meth->have_precompute_mult != 0)
		return group->meth->have_precompute_mult(group);
	else
		return 0; /* cannot tell whether precomputation has been performed */
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d82 1
a82 1
		ECerr(EC_F_EC_GROUP_NEW, EC_R_SLOT_FULL);
d743 1
a743 1
	else if (point->meth->point_finish != 0)
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@d428 1
a428 1
#ifndef OPENSSL_NO_EC2M
d449 1
a449 1
#endif
d859 1
a859 1
#ifndef OPENSSL_NO_EC2M
d875 1
a875 1
#endif
d893 1
a893 1
#ifndef OPENSSL_NO_EC2M
d909 69
a977 1
#endif
@


1.1.1.6
log
@Import OpenSSL 1.0.1g
@
text
@d483 1
a483 1
	/* compare the curve name (if present in both) */
d485 2
a486 2
	    EC_GROUP_get_curve_name(a) != EC_GROUP_get_curve_name(b))
		return 1;
d996 1
a996 1
		return -1;
d1001 1
a1001 1
		return -1;
@


