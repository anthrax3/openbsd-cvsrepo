head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23;
locks; strict;
comment	@ * @;


1.23
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.22;
commitid	kT0fLt3r4lroFJra;

1.22
date	2016.03.20.16.50.29;	author krw;	state Exp;
branches;
next	1.21;
commitid	uggNb1ponNWeI9Go;

1.21
date	2015.10.16.15.15.39;	author jsing;	state Exp;
branches;
next	1.20;
commitid	Ams8GGdTSb22QfcG;

1.20
date	2015.10.16.15.12.30;	author jsing;	state Exp;
branches;
next	1.19;
commitid	bDtKutzbNOo2abMZ;

1.19
date	2015.10.16.15.09.28;	author jsing;	state Exp;
branches;
next	1.18;
commitid	l1wH7rWzOpjSOAfY;

1.18
date	2015.09.29.13.54.40;	author jsing;	state Exp;
branches;
next	1.17;
commitid	9PWAq0wK5n99tjDV;

1.17
date	2015.09.10.14.29.22;	author jsing;	state Exp;
branches;
next	1.16;
commitid	cSgOurQTPleE0uzG;

1.16
date	2015.07.29.14.58.34;	author jsing;	state Exp;
branches;
next	1.15;
commitid	rYgS8cWcS59JYkBV;

1.15
date	2015.07.25.14.36.39;	author jsing;	state Exp;
branches;
next	1.14;
commitid	CKklanYwkQYaFJyN;

1.14
date	2015.03.20.03.02.51;	author doug;	state Exp;
branches;
next	1.13;
commitid	SFcv1cJ5noVMBCSI;

1.13
date	2015.03.19.14.00.22;	author tedu;	state Exp;
branches;
next	1.12;
commitid	Ix1rLPv61p1TR5LF;

1.12
date	2015.02.10.05.43.09;	author jsing;	state Exp;
branches
	1.12.4.1;
next	1.11;
commitid	ZiJHBcBxA18Ospnt;

1.11
date	2015.02.10.04.01.26;	author jsing;	state Exp;
branches;
next	1.10;
commitid	fmu4kkA16bcgKkFQ;

1.10
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches
	1.10.4.1;
next	1.9;
commitid	G74O1dmRukKsW7IJ;

1.9
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.8;
commitid	nzndm3zqPmFurSaK;

1.8
date	2014.07.01.21.26.27;	author miod;	state Exp;
branches;
next	1.7;
commitid	StV5bDirED6zxJAg;

1.7
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	mJUVYpkFBZ0Zv2bG;

1.6
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2014.05.22.21.12.16;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2014.05.07.21.18.53;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2014.05.06.03.56.27;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.10.13.21.23.39;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.04.13.15.16.33;	author miod;	state Exp;
branches;
next	;

1.10.4.1
date	2015.03.19.14.02.22;	author tedu;	state Exp;
branches;
next	;
commitid	bYTbbXa7PWk8y7To;

1.12.4.1
date	2015.03.19.14.01.16;	author tedu;	state Exp;
branches;
next	;
commitid	dQgHc1qjfDF6g1rY;


desc
@@


1.23
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: ec_asn1.c,v 1.22 2016/03/20 16:50:29 krw Exp $ */
/*
 * Written by Nils Larsch for the OpenSSL project.
 */
/* ====================================================================
 * Copyright (c) 2000-2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <string.h>

#include <openssl/opensslconf.h>

#include "ec_lcl.h"
#include <openssl/err.h>
#include <openssl/asn1t.h>
#include <openssl/objects.h>

int 
EC_GROUP_get_basis_type(const EC_GROUP * group)
{
	int i = 0;

	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
	    NID_X9_62_characteristic_two_field)
		/* everything else is currently not supported */
		return 0;

	while (group->poly[i] != 0)
		i++;

	if (i == 4)
		return NID_X9_62_ppBasis;
	else if (i == 2)
		return NID_X9_62_tpBasis;
	else
		/* everything else is currently not supported */
		return 0;
}
#ifndef OPENSSL_NO_EC2M
int 
EC_GROUP_get_trinomial_basis(const EC_GROUP * group, unsigned int *k)
{
	if (group == NULL)
		return 0;

	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
	    NID_X9_62_characteristic_two_field
	    || !((group->poly[0] != 0) && (group->poly[1] != 0) && (group->poly[2] == 0))) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (k)
		*k = group->poly[1];

	return 1;
}
int 
EC_GROUP_get_pentanomial_basis(const EC_GROUP * group, unsigned int *k1,
    unsigned int *k2, unsigned int *k3)
{
	if (group == NULL)
		return 0;

	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
	    NID_X9_62_characteristic_two_field
	    || !((group->poly[0] != 0) && (group->poly[1] != 0) && (group->poly[2] != 0) && (group->poly[3] != 0) && (group->poly[4] == 0))) {
		ECerror(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		return 0;
	}
	if (k1)
		*k1 = group->poly[3];
	if (k2)
		*k2 = group->poly[2];
	if (k3)
		*k3 = group->poly[1];

	return 1;
}
#endif


/* some structures needed for the asn1 encoding */
typedef struct x9_62_pentanomial_st {
	long k1;
	long k2;
	long k3;
} X9_62_PENTANOMIAL;

typedef struct x9_62_characteristic_two_st {
	long m;
	ASN1_OBJECT *type;
	union {
		char *ptr;
		/* NID_X9_62_onBasis */
		ASN1_NULL *onBasis;
		/* NID_X9_62_tpBasis */
		ASN1_INTEGER *tpBasis;
		/* NID_X9_62_ppBasis */
		X9_62_PENTANOMIAL *ppBasis;
		/* anything else */
		ASN1_TYPE *other;
	} p;
} X9_62_CHARACTERISTIC_TWO;

typedef struct x9_62_fieldid_st {
	ASN1_OBJECT *fieldType;
	union {
		char *ptr;
		/* NID_X9_62_prime_field */
		ASN1_INTEGER *prime;
		/* NID_X9_62_characteristic_two_field */
		X9_62_CHARACTERISTIC_TWO *char_two;
		/* anything else */
		ASN1_TYPE *other;
	} p;
} X9_62_FIELDID;

typedef struct x9_62_curve_st {
	ASN1_OCTET_STRING *a;
	ASN1_OCTET_STRING *b;
	ASN1_BIT_STRING *seed;
} X9_62_CURVE;

typedef struct ec_parameters_st {
	long version;
	X9_62_FIELDID *fieldID;
	X9_62_CURVE *curve;
	ASN1_OCTET_STRING *base;
	ASN1_INTEGER *order;
	ASN1_INTEGER *cofactor;
} ECPARAMETERS;

struct ecpk_parameters_st {
	int type;
	union {
		ASN1_OBJECT *named_curve;
		ECPARAMETERS *parameters;
		ASN1_NULL *implicitlyCA;
	} value;
} /* ECPKPARAMETERS */ ;

/* SEC1 ECPrivateKey */
typedef struct ec_privatekey_st {
	long version;
	ASN1_OCTET_STRING *privateKey;
	ECPKPARAMETERS *parameters;
	ASN1_BIT_STRING *publicKey;
} EC_PRIVATEKEY;

/* the OpenSSL ASN.1 definitions */
static const ASN1_TEMPLATE X9_62_PENTANOMIAL_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(X9_62_PENTANOMIAL, k1),
		.field_name = "k1",
		.item = &LONG_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(X9_62_PENTANOMIAL, k2),
		.field_name = "k2",
		.item = &LONG_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(X9_62_PENTANOMIAL, k3),
		.field_name = "k3",
		.item = &LONG_it,
	},
};

const ASN1_ITEM X9_62_PENTANOMIAL_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = X9_62_PENTANOMIAL_seq_tt,
	.tcount = sizeof(X9_62_PENTANOMIAL_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(X9_62_PENTANOMIAL),
	.sname = "X9_62_PENTANOMIAL",
};

X9_62_PENTANOMIAL *X9_62_PENTANOMIAL_new(void);
void X9_62_PENTANOMIAL_free(X9_62_PENTANOMIAL *a);

X9_62_PENTANOMIAL *
X9_62_PENTANOMIAL_new(void)
{
	return (X9_62_PENTANOMIAL*)ASN1_item_new(&X9_62_PENTANOMIAL_it);
}

void
X9_62_PENTANOMIAL_free(X9_62_PENTANOMIAL *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &X9_62_PENTANOMIAL_it);
}

static const ASN1_TEMPLATE char_two_def_tt = {
	.flags = 0,
	.tag = 0,
	.offset = offsetof(X9_62_CHARACTERISTIC_TWO, p.other),
	.field_name = "p.other",
	.item = &ASN1_ANY_it,
};

static const ASN1_ADB_TABLE X9_62_CHARACTERISTIC_TWO_adbtbl[] = {
	{
		.value = NID_X9_62_onBasis,
		.tt = {
			.flags = 0,
			.tag = 0,
			.offset = offsetof(X9_62_CHARACTERISTIC_TWO, p.onBasis),
			.field_name = "p.onBasis",
			.item = &ASN1_NULL_it,
		},
	
	},
	{
		.value = NID_X9_62_tpBasis,
		.tt = {
			.flags = 0,
			.tag = 0,
			.offset = offsetof(X9_62_CHARACTERISTIC_TWO, p.tpBasis),
			.field_name = "p.tpBasis",
			.item = &ASN1_INTEGER_it,
		},
	
	},
	{
		.value = NID_X9_62_ppBasis,
		.tt = {
			.flags = 0,
			.tag = 0,
			.offset = offsetof(X9_62_CHARACTERISTIC_TWO, p.ppBasis),
			.field_name = "p.ppBasis",
			.item = &X9_62_PENTANOMIAL_it,
		},
	
	},
};

static const ASN1_ADB X9_62_CHARACTERISTIC_TWO_adb = {
	.flags = 0,
	.offset = offsetof(X9_62_CHARACTERISTIC_TWO, type),
	.app_items = 0,
	.tbl = X9_62_CHARACTERISTIC_TWO_adbtbl,
	.tblcount = sizeof(X9_62_CHARACTERISTIC_TWO_adbtbl) / sizeof(ASN1_ADB_TABLE),
	.default_tt = &char_two_def_tt,
	.null_tt = NULL,
};

static const ASN1_TEMPLATE X9_62_CHARACTERISTIC_TWO_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(X9_62_CHARACTERISTIC_TWO, m),
		.field_name = "m",
		.item = &LONG_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(X9_62_CHARACTERISTIC_TWO, type),
		.field_name = "type",
		.item = &ASN1_OBJECT_it,
	},
	{
		.flags = ASN1_TFLG_ADB_OID,
		.tag = -1,
		.offset = 0,
		.field_name = "X9_62_CHARACTERISTIC_TWO",
		.item = (const ASN1_ITEM *)&X9_62_CHARACTERISTIC_TWO_adb,
	},
};

const ASN1_ITEM X9_62_CHARACTERISTIC_TWO_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = X9_62_CHARACTERISTIC_TWO_seq_tt,
	.tcount = sizeof(X9_62_CHARACTERISTIC_TWO_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(X9_62_CHARACTERISTIC_TWO),
	.sname = "X9_62_CHARACTERISTIC_TWO",
};
X9_62_CHARACTERISTIC_TWO *X9_62_CHARACTERISTIC_TWO_new(void);
void X9_62_CHARACTERISTIC_TWO_free(X9_62_CHARACTERISTIC_TWO *a);

X9_62_CHARACTERISTIC_TWO *
X9_62_CHARACTERISTIC_TWO_new(void)
{
	return (X9_62_CHARACTERISTIC_TWO*)ASN1_item_new(&X9_62_CHARACTERISTIC_TWO_it);
}

void
X9_62_CHARACTERISTIC_TWO_free(X9_62_CHARACTERISTIC_TWO *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &X9_62_CHARACTERISTIC_TWO_it);
}
static const ASN1_TEMPLATE fieldID_def_tt = {
	.flags = 0,
	.tag = 0,
	.offset = offsetof(X9_62_FIELDID, p.other),
	.field_name = "p.other",
	.item = &ASN1_ANY_it,
};

static const ASN1_ADB_TABLE X9_62_FIELDID_adbtbl[] = {
	{
		.value = NID_X9_62_prime_field,
		.tt = {
			.flags = 0,
			.tag = 0,
			.offset = offsetof(X9_62_FIELDID, p.prime),
			.field_name = "p.prime",
			.item = &ASN1_INTEGER_it,
		},
	
	},
	{
		.value = NID_X9_62_characteristic_two_field,
		.tt = {
			.flags = 0,
			.tag = 0,
			.offset = offsetof(X9_62_FIELDID, p.char_two),
			.field_name = "p.char_two",
			.item = &X9_62_CHARACTERISTIC_TWO_it,
		},
	
	},
};

static const ASN1_ADB X9_62_FIELDID_adb = {
	.flags = 0,
	.offset = offsetof(X9_62_FIELDID, fieldType),
	.app_items = 0,
	.tbl = X9_62_FIELDID_adbtbl,
	.tblcount = sizeof(X9_62_FIELDID_adbtbl) / sizeof(ASN1_ADB_TABLE),
	.default_tt = &fieldID_def_tt,
	.null_tt = NULL,
};

static const ASN1_TEMPLATE X9_62_FIELDID_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(X9_62_FIELDID, fieldType),
		.field_name = "fieldType",
		.item = &ASN1_OBJECT_it,
	},
	{
		.flags = ASN1_TFLG_ADB_OID,
		.tag = -1,
		.offset = 0,
		.field_name = "X9_62_FIELDID",
		.item = (const ASN1_ITEM *)&X9_62_FIELDID_adb,
	},
};

const ASN1_ITEM X9_62_FIELDID_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = X9_62_FIELDID_seq_tt,
	.tcount = sizeof(X9_62_FIELDID_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(X9_62_FIELDID),
	.sname = "X9_62_FIELDID",
};

static const ASN1_TEMPLATE X9_62_CURVE_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(X9_62_CURVE, a),
		.field_name = "a",
		.item = &ASN1_OCTET_STRING_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(X9_62_CURVE, b),
		.field_name = "b",
		.item = &ASN1_OCTET_STRING_it,
	},
	{
		.flags = ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(X9_62_CURVE, seed),
		.field_name = "seed",
		.item = &ASN1_BIT_STRING_it,
	},
};

const ASN1_ITEM X9_62_CURVE_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = X9_62_CURVE_seq_tt,
	.tcount = sizeof(X9_62_CURVE_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(X9_62_CURVE),
	.sname = "X9_62_CURVE",
};

static const ASN1_TEMPLATE ECPARAMETERS_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(ECPARAMETERS, version),
		.field_name = "version",
		.item = &LONG_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(ECPARAMETERS, fieldID),
		.field_name = "fieldID",
		.item = &X9_62_FIELDID_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(ECPARAMETERS, curve),
		.field_name = "curve",
		.item = &X9_62_CURVE_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(ECPARAMETERS, base),
		.field_name = "base",
		.item = &ASN1_OCTET_STRING_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(ECPARAMETERS, order),
		.field_name = "order",
		.item = &ASN1_INTEGER_it,
	},
	{
		.flags = ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(ECPARAMETERS, cofactor),
		.field_name = "cofactor",
		.item = &ASN1_INTEGER_it,
	},
};

const ASN1_ITEM ECPARAMETERS_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = ECPARAMETERS_seq_tt,
	.tcount = sizeof(ECPARAMETERS_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(ECPARAMETERS),
	.sname = "ECPARAMETERS",
};
ECPARAMETERS *ECPARAMETERS_new(void);
void ECPARAMETERS_free(ECPARAMETERS *a);

ECPARAMETERS *
ECPARAMETERS_new(void)
{
	return (ECPARAMETERS*)ASN1_item_new(&ECPARAMETERS_it);
}

void
ECPARAMETERS_free(ECPARAMETERS *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &ECPARAMETERS_it);
}

static const ASN1_TEMPLATE ECPKPARAMETERS_ch_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(ECPKPARAMETERS, value.named_curve),
		.field_name = "value.named_curve",
		.item = &ASN1_OBJECT_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(ECPKPARAMETERS, value.parameters),
		.field_name = "value.parameters",
		.item = &ECPARAMETERS_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(ECPKPARAMETERS, value.implicitlyCA),
		.field_name = "value.implicitlyCA",
		.item = &ASN1_NULL_it,
	},
};

const ASN1_ITEM ECPKPARAMETERS_it = {
	.itype = ASN1_ITYPE_CHOICE,
	.utype = offsetof(ECPKPARAMETERS, type),
	.templates = ECPKPARAMETERS_ch_tt,
	.tcount = sizeof(ECPKPARAMETERS_ch_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(ECPKPARAMETERS),
	.sname = "ECPKPARAMETERS",
};

ECPKPARAMETERS *ECPKPARAMETERS_new(void);
void ECPKPARAMETERS_free(ECPKPARAMETERS *a);
ECPKPARAMETERS *d2i_ECPKPARAMETERS(ECPKPARAMETERS **a, const unsigned char **in, long len);
int i2d_ECPKPARAMETERS(const ECPKPARAMETERS *a, unsigned char **out);

ECPKPARAMETERS *
d2i_ECPKPARAMETERS(ECPKPARAMETERS **a, const unsigned char **in, long len)
{
	return (ECPKPARAMETERS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &ECPKPARAMETERS_it);
}

int
i2d_ECPKPARAMETERS(const ECPKPARAMETERS *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &ECPKPARAMETERS_it);
}

ECPKPARAMETERS *
ECPKPARAMETERS_new(void)
{
	return (ECPKPARAMETERS *)ASN1_item_new(&ECPKPARAMETERS_it);
}

void
ECPKPARAMETERS_free(ECPKPARAMETERS *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &ECPKPARAMETERS_it);
}

static const ASN1_TEMPLATE EC_PRIVATEKEY_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(EC_PRIVATEKEY, version),
		.field_name = "version",
		.item = &LONG_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(EC_PRIVATEKEY, privateKey),
		.field_name = "privateKey",
		.item = &ASN1_OCTET_STRING_it,
	},
	{
		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(EC_PRIVATEKEY, parameters),
		.field_name = "parameters",
		.item = &ECPKPARAMETERS_it,
	},
	{
		.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 1,
		.offset = offsetof(EC_PRIVATEKEY, publicKey),
		.field_name = "publicKey",
		.item = &ASN1_BIT_STRING_it,
	},
};

const ASN1_ITEM EC_PRIVATEKEY_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = EC_PRIVATEKEY_seq_tt,
	.tcount = sizeof(EC_PRIVATEKEY_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(EC_PRIVATEKEY),
	.sname = "EC_PRIVATEKEY",
};

EC_PRIVATEKEY *EC_PRIVATEKEY_new(void);
void EC_PRIVATEKEY_free(EC_PRIVATEKEY *a);
EC_PRIVATEKEY *d2i_EC_PRIVATEKEY(EC_PRIVATEKEY **a, const unsigned char **in, long len);
int i2d_EC_PRIVATEKEY(const EC_PRIVATEKEY *a, unsigned char **out);

EC_PRIVATEKEY *
d2i_EC_PRIVATEKEY(EC_PRIVATEKEY **a, const unsigned char **in, long len)
{
	return (EC_PRIVATEKEY *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &EC_PRIVATEKEY_it);
}

int
i2d_EC_PRIVATEKEY(const EC_PRIVATEKEY *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &EC_PRIVATEKEY_it);
}

EC_PRIVATEKEY *
EC_PRIVATEKEY_new(void)
{
	return (EC_PRIVATEKEY *)ASN1_item_new(&EC_PRIVATEKEY_it);
}

void
EC_PRIVATEKEY_free(EC_PRIVATEKEY *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &EC_PRIVATEKEY_it);
}
/* some declarations of internal function */

/* ec_asn1_group2field() sets the values in a X9_62_FIELDID object */
static int ec_asn1_group2fieldid(const EC_GROUP *, X9_62_FIELDID *);
/* ec_asn1_group2curve() sets the values in a X9_62_CURVE object */
static int ec_asn1_group2curve(const EC_GROUP *, X9_62_CURVE *);
/* ec_asn1_parameters2group() creates a EC_GROUP object from a
 * ECPARAMETERS object */
static EC_GROUP *ec_asn1_parameters2group(const ECPARAMETERS *);
/* ec_asn1_group2parameters() creates a ECPARAMETERS object from a
 * EC_GROUP object */
static ECPARAMETERS *ec_asn1_group2parameters(const EC_GROUP *, ECPARAMETERS *);
/* ec_asn1_pkparameters2group() creates a EC_GROUP object from a
 * ECPKPARAMETERS object */
static EC_GROUP *ec_asn1_pkparameters2group(const ECPKPARAMETERS *);
/* ec_asn1_group2pkparameters() creates a ECPKPARAMETERS object from a
 * EC_GROUP object */
static ECPKPARAMETERS *ec_asn1_group2pkparameters(const EC_GROUP *,
    ECPKPARAMETERS *);


/* the function definitions */

static int
ec_asn1_group2fieldid(const EC_GROUP * group, X9_62_FIELDID * field)
{
	int ok = 0, nid;
	BIGNUM *tmp = NULL;

	if (group == NULL || field == NULL)
		return 0;

	/* clear the old values (if necessary) */
	if (field->fieldType != NULL)
		ASN1_OBJECT_free(field->fieldType);
	if (field->p.other != NULL)
		ASN1_TYPE_free(field->p.other);

	nid = EC_METHOD_get_field_type(EC_GROUP_method_of(group));
	/* set OID for the field */
	if ((field->fieldType = OBJ_nid2obj(nid)) == NULL) {
		ECerror(ERR_R_OBJ_LIB);
		goto err;
	}
	if (nid == NID_X9_62_prime_field) {
		if ((tmp = BN_new()) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		/* the parameters are specified by the prime number p */
		if (!EC_GROUP_get_curve_GFp(group, tmp, NULL, NULL, NULL)) {
			ECerror(ERR_R_EC_LIB);
			goto err;
		}
		/* set the prime number */
		field->p.prime = BN_to_ASN1_INTEGER(tmp, NULL);
		if (field->p.prime == NULL) {
			ECerror(ERR_R_ASN1_LIB);
			goto err;
		}
	} else			/* nid == NID_X9_62_characteristic_two_field */
#ifdef OPENSSL_NO_EC2M
	{
		ECerror(EC_R_GF2M_NOT_SUPPORTED);
		goto err;
	}
#else
	{
		int field_type;
		X9_62_CHARACTERISTIC_TWO *char_two;

		field->p.char_two = X9_62_CHARACTERISTIC_TWO_new();
		char_two = field->p.char_two;

		if (char_two == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		char_two->m = (long) EC_GROUP_get_degree(group);

		field_type = EC_GROUP_get_basis_type(group);

		if (field_type == 0) {
			ECerror(ERR_R_EC_LIB);
			goto err;
		}
		/* set base type OID */
		if ((char_two->type = OBJ_nid2obj(field_type)) == NULL) {
			ECerror(ERR_R_OBJ_LIB);
			goto err;
		}
		if (field_type == NID_X9_62_tpBasis) {
			unsigned int k;

			if (!EC_GROUP_get_trinomial_basis(group, &k))
				goto err;

			char_two->p.tpBasis = ASN1_INTEGER_new();
			if (!char_two->p.tpBasis) {
				ECerror(ERR_R_MALLOC_FAILURE);
				goto err;
			}
			if (!ASN1_INTEGER_set(char_two->p.tpBasis, (long) k)) {
				ECerror(ERR_R_ASN1_LIB);
				goto err;
			}
		} else if (field_type == NID_X9_62_ppBasis) {
			unsigned int k1, k2, k3;

			if (!EC_GROUP_get_pentanomial_basis(group, &k1, &k2, &k3))
				goto err;

			char_two->p.ppBasis = X9_62_PENTANOMIAL_new();
			if (!char_two->p.ppBasis) {
				ECerror(ERR_R_MALLOC_FAILURE);
				goto err;
			}
			/* set k? values */
			char_two->p.ppBasis->k1 = (long) k1;
			char_two->p.ppBasis->k2 = (long) k2;
			char_two->p.ppBasis->k3 = (long) k3;
		} else {	/* field_type == NID_X9_62_onBasis */
			/* for ONB the parameters are (asn1) NULL */
			char_two->p.onBasis = ASN1_NULL_new();
			if (!char_two->p.onBasis) {
				ECerror(ERR_R_MALLOC_FAILURE);
				goto err;
			}
		}
	}
#endif

	ok = 1;

err:
	BN_free(tmp);
	return (ok);
}

static int 
ec_asn1_group2curve(const EC_GROUP * group, X9_62_CURVE * curve)
{
	int ok = 0, nid;
	BIGNUM *tmp_1 = NULL, *tmp_2 = NULL;
	unsigned char *buffer_1 = NULL, *buffer_2 = NULL, *a_buf = NULL,
	*b_buf = NULL;
	size_t len_1, len_2;
	unsigned char char_zero = 0;

	if (!group || !curve || !curve->a || !curve->b)
		return 0;

	if ((tmp_1 = BN_new()) == NULL || (tmp_2 = BN_new()) == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	nid = EC_METHOD_get_field_type(EC_GROUP_method_of(group));

	/* get a and b */
	if (nid == NID_X9_62_prime_field) {
		if (!EC_GROUP_get_curve_GFp(group, NULL, tmp_1, tmp_2, NULL)) {
			ECerror(ERR_R_EC_LIB);
			goto err;
		}
	}
#ifndef OPENSSL_NO_EC2M
	else {			/* nid == NID_X9_62_characteristic_two_field */
		if (!EC_GROUP_get_curve_GF2m(group, NULL, tmp_1, tmp_2, NULL)) {
			ECerror(ERR_R_EC_LIB);
			goto err;
		}
	}
#endif
	len_1 = (size_t) BN_num_bytes(tmp_1);
	len_2 = (size_t) BN_num_bytes(tmp_2);

	if (len_1 == 0) {
		/* len_1 == 0 => a == 0 */
		a_buf = &char_zero;
		len_1 = 1;
	} else {
		if ((buffer_1 = malloc(len_1)) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if ((len_1 = BN_bn2bin(tmp_1, buffer_1)) == 0) {
			ECerror(ERR_R_BN_LIB);
			goto err;
		}
		a_buf = buffer_1;
	}

	if (len_2 == 0) {
		/* len_2 == 0 => b == 0 */
		b_buf = &char_zero;
		len_2 = 1;
	} else {
		if ((buffer_2 = malloc(len_2)) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if ((len_2 = BN_bn2bin(tmp_2, buffer_2)) == 0) {
			ECerror(ERR_R_BN_LIB);
			goto err;
		}
		b_buf = buffer_2;
	}

	/* set a and b */
	if (!ASN1_STRING_set(curve->a, a_buf, len_1) ||
	    !ASN1_STRING_set(curve->b, b_buf, len_2)) {
		ECerror(ERR_R_ASN1_LIB);
		goto err;
	}
	/* set the seed (optional) */
	if (group->seed) {
		if (!curve->seed)
			if ((curve->seed = ASN1_BIT_STRING_new()) == NULL) {
				ECerror(ERR_R_MALLOC_FAILURE);
				goto err;
			}
		curve->seed->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
		curve->seed->flags |= ASN1_STRING_FLAG_BITS_LEFT;
		if (!ASN1_BIT_STRING_set(curve->seed, group->seed,
			(int) group->seed_len)) {
			ECerror(ERR_R_ASN1_LIB);
			goto err;
		}
	} else {
		if (curve->seed) {
			ASN1_BIT_STRING_free(curve->seed);
			curve->seed = NULL;
		}
	}

	ok = 1;

err:
	free(buffer_1);
	free(buffer_2);
	BN_free(tmp_1);
	BN_free(tmp_2);
	return (ok);
}

static ECPARAMETERS *
ec_asn1_group2parameters(const EC_GROUP * group, ECPARAMETERS * param)
{
	int ok = 0;
	size_t len = 0;
	ECPARAMETERS *ret = NULL;
	BIGNUM *tmp = NULL;
	unsigned char *buffer = NULL;
	const EC_POINT *point = NULL;
	point_conversion_form_t form;

	if ((tmp = BN_new()) == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	if (param == NULL) {
		if ((ret = ECPARAMETERS_new()) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
	} else
		ret = param;

	/* set the version (always one) */
	ret->version = (long) 0x1;

	/* set the fieldID */
	if (!ec_asn1_group2fieldid(group, ret->fieldID)) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	/* set the curve */
	if (!ec_asn1_group2curve(group, ret->curve)) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	/* set the base point */
	if ((point = EC_GROUP_get0_generator(group)) == NULL) {
		ECerror(EC_R_UNDEFINED_GENERATOR);
		goto err;
	}
	form = EC_GROUP_get_point_conversion_form(group);

	len = EC_POINT_point2oct(group, point, form, NULL, len, NULL);
	if (len == 0) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	if ((buffer = malloc(len)) == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	if (!EC_POINT_point2oct(group, point, form, buffer, len, NULL)) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	if (ret->base == NULL && (ret->base = ASN1_OCTET_STRING_new()) == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	if (!ASN1_OCTET_STRING_set(ret->base, buffer, len)) {
		ECerror(ERR_R_ASN1_LIB);
		goto err;
	}
	/* set the order */
	if (!EC_GROUP_get_order(group, tmp, NULL)) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	ret->order = BN_to_ASN1_INTEGER(tmp, ret->order);
	if (ret->order == NULL) {
		ECerror(ERR_R_ASN1_LIB);
		goto err;
	}
	/* set the cofactor (optional) */
	if (EC_GROUP_get_cofactor(group, tmp, NULL)) {
		ret->cofactor = BN_to_ASN1_INTEGER(tmp, ret->cofactor);
		if (ret->cofactor == NULL) {
			ECerror(ERR_R_ASN1_LIB);
			goto err;
		}
	}
	ok = 1;

err:	if (!ok) {
		if (ret && !param)
			ECPARAMETERS_free(ret);
		ret = NULL;
	}
	BN_free(tmp);
	free(buffer);
	return (ret);
}

ECPKPARAMETERS *
ec_asn1_group2pkparameters(const EC_GROUP * group, ECPKPARAMETERS * params)
{
	int ok = 1, tmp;
	ECPKPARAMETERS *ret = params;

	if (ret == NULL) {
		if ((ret = ECPKPARAMETERS_new()) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			return NULL;
		}
	} else {
		if (ret->type == 0 && ret->value.named_curve)
			ASN1_OBJECT_free(ret->value.named_curve);
		else if (ret->type == 1 && ret->value.parameters)
			ECPARAMETERS_free(ret->value.parameters);
	}

	if (EC_GROUP_get_asn1_flag(group)) {
		/*
		 * use the asn1 OID to describe the elliptic curve
		 * parameters
		 */
		tmp = EC_GROUP_get_curve_name(group);
		if (tmp) {
			ret->type = 0;
			if ((ret->value.named_curve = OBJ_nid2obj(tmp)) == NULL)
				ok = 0;
		} else
			/* we don't kmow the nid => ERROR */
			ok = 0;
	} else {
		/* use the ECPARAMETERS structure */
		ret->type = 1;
		if ((ret->value.parameters = ec_asn1_group2parameters(
			    group, NULL)) == NULL)
			ok = 0;
	}

	if (!ok) {
		ECPKPARAMETERS_free(ret);
		return NULL;
	}
	return ret;
}

static EC_GROUP *
ec_asn1_parameters2group(const ECPARAMETERS * params)
{
	int ok = 0, tmp;
	EC_GROUP *ret = NULL;
	BIGNUM *p = NULL, *a = NULL, *b = NULL;
	EC_POINT *point = NULL;
	long field_bits;

	if (!params->fieldID || !params->fieldID->fieldType ||
	    !params->fieldID->p.ptr) {
		ECerror(EC_R_ASN1_ERROR);
		goto err;
	}
	/* now extract the curve parameters a and b */
	if (!params->curve || !params->curve->a ||
	    !params->curve->a->data || !params->curve->b ||
	    !params->curve->b->data) {
		ECerror(EC_R_ASN1_ERROR);
		goto err;
	}
	a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);
	if (a == NULL) {
		ECerror(ERR_R_BN_LIB);
		goto err;
	}
	b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);
	if (b == NULL) {
		ECerror(ERR_R_BN_LIB);
		goto err;
	}
	/* get the field parameters */
	tmp = OBJ_obj2nid(params->fieldID->fieldType);
	if (tmp == NID_X9_62_characteristic_two_field)
#ifdef OPENSSL_NO_EC2M
	{
		ECerror(EC_R_GF2M_NOT_SUPPORTED);
		goto err;
	}
#else
	{
		X9_62_CHARACTERISTIC_TWO *char_two;

		char_two = params->fieldID->p.char_two;

		field_bits = char_two->m;
		if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
			ECerror(EC_R_FIELD_TOO_LARGE);
			goto err;
		}
		if ((p = BN_new()) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		/* get the base type */
		tmp = OBJ_obj2nid(char_two->type);

		if (tmp == NID_X9_62_tpBasis) {
			long tmp_long;

			if (!char_two->p.tpBasis) {
				ECerror(EC_R_ASN1_ERROR);
				goto err;
			}
			tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);

			if (!(char_two->m > tmp_long && tmp_long > 0)) {
				ECerror(EC_R_INVALID_TRINOMIAL_BASIS);
				goto err;
			}
			/* create the polynomial */
			if (!BN_set_bit(p, (int) char_two->m))
				goto err;
			if (!BN_set_bit(p, (int) tmp_long))
				goto err;
			if (!BN_set_bit(p, 0))
				goto err;
		} else if (tmp == NID_X9_62_ppBasis) {
			X9_62_PENTANOMIAL *penta;

			penta = char_two->p.ppBasis;
			if (!penta) {
				ECerror(EC_R_ASN1_ERROR);
				goto err;
			}
			if (!(char_two->m > penta->k3 && penta->k3 > penta->k2 && penta->k2 > penta->k1 && penta->k1 > 0)) {
				ECerror(EC_R_INVALID_PENTANOMIAL_BASIS);
				goto err;
			}
			/* create the polynomial */
			if (!BN_set_bit(p, (int) char_two->m))
				goto err;
			if (!BN_set_bit(p, (int) penta->k1))
				goto err;
			if (!BN_set_bit(p, (int) penta->k2))
				goto err;
			if (!BN_set_bit(p, (int) penta->k3))
				goto err;
			if (!BN_set_bit(p, 0))
				goto err;
		} else if (tmp == NID_X9_62_onBasis) {
			ECerror(EC_R_NOT_IMPLEMENTED);
			goto err;
		} else {	/* error */
			ECerror(EC_R_ASN1_ERROR);
			goto err;
		}

		/* create the EC_GROUP structure */
		ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);
	}
#endif
	else if (tmp == NID_X9_62_prime_field) {
		/* we have a curve over a prime field */
		/* extract the prime number */
		if (!params->fieldID->p.prime) {
			ECerror(EC_R_ASN1_ERROR);
			goto err;
		}
		p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);
		if (p == NULL) {
			ECerror(ERR_R_ASN1_LIB);
			goto err;
		}
		if (BN_is_negative(p) || BN_is_zero(p)) {
			ECerror(EC_R_INVALID_FIELD);
			goto err;
		}
		field_bits = BN_num_bits(p);
		if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {
			ECerror(EC_R_FIELD_TOO_LARGE);
			goto err;
		}
		/* create the EC_GROUP structure */
		ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);
	} else {
		ECerror(EC_R_INVALID_FIELD);
		goto err;
	}

	if (ret == NULL) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	/* extract seed (optional) */
	if (params->curve->seed != NULL) {
		free(ret->seed);
		if (!(ret->seed = malloc(params->curve->seed->length))) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		memcpy(ret->seed, params->curve->seed->data,
		    params->curve->seed->length);
		ret->seed_len = params->curve->seed->length;
	}
	if (!params->order || !params->base || !params->base->data) {
		ECerror(EC_R_ASN1_ERROR);
		goto err;
	}
	if ((point = EC_POINT_new(ret)) == NULL)
		goto err;

	/* set the point conversion form */
	EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)
	    (params->base->data[0] & ~0x01));

	/* extract the ec point */
	if (!EC_POINT_oct2point(ret, point, params->base->data,
		params->base->length, NULL)) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	/* extract the order */
	if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {
		ECerror(ERR_R_ASN1_LIB);
		goto err;
	}
	if (BN_is_negative(a) || BN_is_zero(a)) {
		ECerror(EC_R_INVALID_GROUP_ORDER);
		goto err;
	}
	if (BN_num_bits(a) > (int) field_bits + 1) {	/* Hasse bound */
		ECerror(EC_R_INVALID_GROUP_ORDER);
		goto err;
	}
	/* extract the cofactor (optional) */
	if (params->cofactor == NULL) {
		BN_free(b);
		b = NULL;
	} else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {
		ECerror(ERR_R_ASN1_LIB);
		goto err;
	}
	/* set the generator, order and cofactor (if present) */
	if (!EC_GROUP_set_generator(ret, point, a, b)) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	ok = 1;

err:	if (!ok) {
		EC_GROUP_clear_free(ret);
		ret = NULL;
	}
	BN_free(p);
	BN_free(a);
	BN_free(b);
	EC_POINT_free(point);
	return (ret);
}

EC_GROUP *
ec_asn1_pkparameters2group(const ECPKPARAMETERS * params)
{
	EC_GROUP *ret = NULL;
	int tmp = 0;

	if (params == NULL) {
		ECerror(EC_R_MISSING_PARAMETERS);
		return NULL;
	}
	if (params->type == 0) {/* the curve is given by an OID */
		tmp = OBJ_obj2nid(params->value.named_curve);
		if ((ret = EC_GROUP_new_by_curve_name(tmp)) == NULL) {
			ECerror(EC_R_EC_GROUP_NEW_BY_NAME_FAILURE);
			return NULL;
		}
		EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_NAMED_CURVE);
	} else if (params->type == 1) {	/* the parameters are given by a
					 * ECPARAMETERS structure */
		ret = ec_asn1_parameters2group(params->value.parameters);
		if (!ret) {
			ECerror(ERR_R_EC_LIB);
			return NULL;
		}
		EC_GROUP_set_asn1_flag(ret, 0x0);
	} else if (params->type == 2) {	/* implicitlyCA */
		return NULL;
	} else {
		ECerror(EC_R_ASN1_ERROR);
		return NULL;
	}

	return ret;
}

/* EC_GROUP <-> DER encoding of ECPKPARAMETERS */

EC_GROUP *
d2i_ECPKParameters(EC_GROUP ** a, const unsigned char **in, long len)
{
	EC_GROUP *group = NULL;
	ECPKPARAMETERS *params = NULL;

	if ((params = d2i_ECPKPARAMETERS(NULL, in, len)) == NULL) {
		ECerror(EC_R_D2I_ECPKPARAMETERS_FAILURE);
		goto err;
	}
	if ((group = ec_asn1_pkparameters2group(params)) == NULL) {
		ECerror(EC_R_PKPARAMETERS2GROUP_FAILURE);
		goto err;
	}

	if (a != NULL) {
		EC_GROUP_clear_free(*a);
		*a = group;
	}

err:
	ECPKPARAMETERS_free(params);
	return (group);
}

int 
i2d_ECPKParameters(const EC_GROUP * a, unsigned char **out)
{
	int ret = 0;
	ECPKPARAMETERS *tmp = ec_asn1_group2pkparameters(a, NULL);
	if (tmp == NULL) {
		ECerror(EC_R_GROUP2PKPARAMETERS_FAILURE);
		return 0;
	}
	if ((ret = i2d_ECPKPARAMETERS(tmp, out)) == 0) {
		ECerror(EC_R_I2D_ECPKPARAMETERS_FAILURE);
		ECPKPARAMETERS_free(tmp);
		return 0;
	}
	ECPKPARAMETERS_free(tmp);
	return (ret);
}

/* some EC_KEY functions */

EC_KEY *
d2i_ECPrivateKey(EC_KEY ** a, const unsigned char **in, long len)
{
	EC_KEY *ret = NULL;
	EC_PRIVATEKEY *priv_key = NULL;

	if ((priv_key = EC_PRIVATEKEY_new()) == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	if ((priv_key = d2i_EC_PRIVATEKEY(&priv_key, in, len)) == NULL) {
		ECerror(ERR_R_EC_LIB);
		EC_PRIVATEKEY_free(priv_key);
		return NULL;
	}
	if (a == NULL || *a == NULL) {
		if ((ret = EC_KEY_new()) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
	} else
		ret = *a;

	if (priv_key->parameters) {
		EC_GROUP_clear_free(ret->group);
		ret->group = ec_asn1_pkparameters2group(priv_key->parameters);
	}
	if (ret->group == NULL) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	ret->version = priv_key->version;

	if (priv_key->privateKey) {
		ret->priv_key = BN_bin2bn(
		    ASN1_STRING_data(priv_key->privateKey),
		    ASN1_STRING_length(priv_key->privateKey),
		    ret->priv_key);
		if (ret->priv_key == NULL) {
			ECerror(ERR_R_BN_LIB);
			goto err;
		}
	} else {
		ECerror(EC_R_MISSING_PRIVATE_KEY);
		goto err;
	}

	if (priv_key->publicKey) {
		const unsigned char *pub_oct;
		size_t pub_oct_len;

		EC_POINT_clear_free(ret->pub_key);
		ret->pub_key = EC_POINT_new(ret->group);
		if (ret->pub_key == NULL) {
			ECerror(ERR_R_EC_LIB);
			goto err;
		}
		pub_oct = ASN1_STRING_data(priv_key->publicKey);
		pub_oct_len = ASN1_STRING_length(priv_key->publicKey);
		/* save the point conversion form */
		ret->conv_form = (point_conversion_form_t) (pub_oct[0] & ~0x01);
		if (!EC_POINT_oct2point(ret->group, ret->pub_key,
			pub_oct, pub_oct_len, NULL)) {
			ECerror(ERR_R_EC_LIB);
			goto err;
		}
	}

	EC_PRIVATEKEY_free(priv_key);
	if (a != NULL)
		*a = ret;
	return (ret);

err:
	if (a == NULL || *a != ret)
		EC_KEY_free(ret);
	if (priv_key)
		EC_PRIVATEKEY_free(priv_key);

	return (NULL);
}

int 
i2d_ECPrivateKey(EC_KEY * a, unsigned char **out)
{
	int ret = 0, ok = 0;
	unsigned char *buffer = NULL;
	size_t buf_len = 0, tmp_len;
	EC_PRIVATEKEY *priv_key = NULL;

	if (a == NULL || a->group == NULL || a->priv_key == NULL) {
		ECerror(ERR_R_PASSED_NULL_PARAMETER);
		goto err;
	}
	if ((priv_key = EC_PRIVATEKEY_new()) == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	priv_key->version = a->version;

	buf_len = (size_t) BN_num_bytes(a->priv_key);
	buffer = malloc(buf_len);
	if (buffer == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	if (!BN_bn2bin(a->priv_key, buffer)) {
		ECerror(ERR_R_BN_LIB);
		goto err;
	}
	if (!ASN1_STRING_set(priv_key->privateKey, buffer, buf_len)) {
		ECerror(ERR_R_ASN1_LIB);
		goto err;
	}
	if (!(a->enc_flag & EC_PKEY_NO_PARAMETERS)) {
		if ((priv_key->parameters = ec_asn1_group2pkparameters(
			    a->group, priv_key->parameters)) == NULL) {
			ECerror(ERR_R_EC_LIB);
			goto err;
		}
	}
	if (!(a->enc_flag & EC_PKEY_NO_PUBKEY) && a->pub_key != NULL) {
		priv_key->publicKey = ASN1_BIT_STRING_new();
		if (priv_key->publicKey == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		tmp_len = EC_POINT_point2oct(a->group, a->pub_key,
		    a->conv_form, NULL, 0, NULL);

		if (tmp_len > buf_len) {
			unsigned char *tmp_buffer = realloc(buffer, tmp_len);
			if (!tmp_buffer) {
				ECerror(ERR_R_MALLOC_FAILURE);
				goto err;
			}
			buffer = tmp_buffer;
			buf_len = tmp_len;
		}
		if (!EC_POINT_point2oct(a->group, a->pub_key,
			a->conv_form, buffer, buf_len, NULL)) {
			ECerror(ERR_R_EC_LIB);
			goto err;
		}
		priv_key->publicKey->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
		priv_key->publicKey->flags |= ASN1_STRING_FLAG_BITS_LEFT;
		if (!ASN1_STRING_set(priv_key->publicKey, buffer,
			buf_len)) {
			ECerror(ERR_R_ASN1_LIB);
			goto err;
		}
	}
	if ((ret = i2d_EC_PRIVATEKEY(priv_key, out)) == 0) {
		ECerror(ERR_R_EC_LIB);
		goto err;
	}
	ok = 1;
err:
	free(buffer);
	if (priv_key)
		EC_PRIVATEKEY_free(priv_key);
	return (ok ? ret : 0);
}

int 
i2d_ECParameters(EC_KEY * a, unsigned char **out)
{
	if (a == NULL) {
		ECerror(ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	return i2d_ECPKParameters(a->group, out);
}

EC_KEY *
d2i_ECParameters(EC_KEY ** a, const unsigned char **in, long len)
{
	EC_KEY *ret;

	if (in == NULL || *in == NULL) {
		ECerror(ERR_R_PASSED_NULL_PARAMETER);
		return NULL;
	}
	if (a == NULL || *a == NULL) {
		if ((ret = EC_KEY_new()) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			return NULL;
		}
	} else
		ret = *a;

	if (!d2i_ECPKParameters(&ret->group, in, len)) {
		ECerror(ERR_R_EC_LIB);
		if (a == NULL || *a != ret)
			EC_KEY_free(ret);
		return NULL;
	}

	if (a != NULL)
		*a = ret;
	return ret;
}

EC_KEY *
o2i_ECPublicKey(EC_KEY ** a, const unsigned char **in, long len)
{
	EC_KEY *ret = NULL;

	if (a == NULL || (*a) == NULL || (*a)->group == NULL) {
		/*
		 * sorry, but a EC_GROUP-structur is necessary to set the
		 * public key
		 */
		ECerror(ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	ret = *a;
	if (ret->pub_key == NULL &&
	    (ret->pub_key = EC_POINT_new(ret->group)) == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	if (!EC_POINT_oct2point(ret->group, ret->pub_key, *in, len, NULL)) {
		ECerror(ERR_R_EC_LIB);
		return 0;
	}
	/* save the point conversion form */
	ret->conv_form = (point_conversion_form_t) (*in[0] & ~0x01);
	*in += len;
	return ret;
}

int 
i2o_ECPublicKey(EC_KEY * a, unsigned char **out)
{
	size_t buf_len = 0;
	int new_buffer = 0;

	if (a == NULL) {
		ECerror(ERR_R_PASSED_NULL_PARAMETER);
		return 0;
	}
	buf_len = EC_POINT_point2oct(a->group, a->pub_key,
	    a->conv_form, NULL, 0, NULL);

	if (out == NULL || buf_len == 0)
		/* out == NULL => just return the length of the octet string */
		return buf_len;

	if (*out == NULL) {
		if ((*out = malloc(buf_len)) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		new_buffer = 1;
	}
	if (!EC_POINT_point2oct(a->group, a->pub_key, a->conv_form,
		*out, buf_len, NULL)) {
		ECerror(ERR_R_EC_LIB);
		if (new_buffer) {
			free(*out);
			*out = NULL;
		}
		return 0;
	}
	if (!new_buffer)
		*out += buf_len;
	return buf_len;
}
@


1.22
log
@" the the " -> " the ", or in a couple of cases replace the superfluous
"the" with the obviously intended word.

Started with a "the the" spotted by Mihal Mazurek.
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.21 2015/10/16 15:15:39 jsing Exp $ */
d99 1
a99 1
		ECerr(EC_F_EC_GROUP_GET_TRINOMIAL_BASIS, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d117 1
a117 1
		ECerr(EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d699 1
a699 1
		ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);
d704 1
a704 1
			ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
d709 1
a709 1
			ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);
d715 1
a715 1
			ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);
d721 1
a721 1
		ECerr(EC_F_EC_ASN1_GROUP2FIELDID, EC_R_GF2M_NOT_SUPPORTED);
d733 1
a733 1
			ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
d741 1
a741 1
			ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);
d746 1
a746 1
			ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);
d757 1
a757 1
				ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
d761 1
a761 2
				ECerr(EC_F_EC_ASN1_GROUP2FIELDID,
				    ERR_R_ASN1_LIB);
d772 1
a772 1
				ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
d783 1
a783 1
				ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
d811 1
a811 1
		ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
d819 1
a819 1
			ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_EC_LIB);
d826 1
a826 1
			ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_EC_LIB);
d840 1
a840 2
			ECerr(EC_F_EC_ASN1_GROUP2CURVE,
			    ERR_R_MALLOC_FAILURE);
d844 1
a844 1
			ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_BN_LIB);
d856 1
a856 2
			ECerr(EC_F_EC_ASN1_GROUP2CURVE,
			    ERR_R_MALLOC_FAILURE);
d860 1
a860 1
			ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_BN_LIB);
d869 1
a869 1
		ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);
d876 1
a876 1
				ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
d883 1
a883 1
			ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);
d915 1
a915 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);
d920 1
a920 2
			ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS,
			    ERR_R_MALLOC_FAILURE);
d931 1
a931 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);
d936 1
a936 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);
d941 1
a941 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, EC_R_UNDEFINED_GENERATOR);
d948 1
a948 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);
d952 1
a952 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);
d956 1
a956 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);
d960 1
a960 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);
d964 1
a964 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_ASN1_LIB);
d969 1
a969 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);
d974 1
a974 1
		ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_ASN1_LIB);
d981 1
a981 1
			ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_ASN1_LIB);
d1005 1
a1005 2
			ECerr(EC_F_EC_ASN1_GROUP2PKPARAMETERS,
			    ERR_R_MALLOC_FAILURE);
d1054 1
a1054 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);
d1061 1
a1061 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);
d1066 1
a1066 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_BN_LIB);
d1071 1
a1071 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_BN_LIB);
d1079 1
a1079 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_GF2M_NOT_SUPPORTED);
d1090 1
a1090 1
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_FIELD_TOO_LARGE);
d1094 1
a1094 1
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_MALLOC_FAILURE);
d1104 1
a1104 1
				ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);
d1110 1
a1110 1
				ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_TRINOMIAL_BASIS);
d1125 1
a1125 1
				ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);
d1129 1
a1129 1
				ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_PENTANOMIAL_BASIS);
d1144 1
a1144 1
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_NOT_IMPLEMENTED);
d1147 1
a1147 1
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);
d1159 1
a1159 1
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);
d1164 1
a1164 1
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);
d1168 1
a1168 1
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_FIELD);
d1173 1
a1173 1
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_FIELD_TOO_LARGE);
d1179 1
a1179 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_FIELD);
d1184 1
a1184 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);
d1191 1
a1191 2
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP,
			    ERR_R_MALLOC_FAILURE);
d1199 1
a1199 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);
d1212 1
a1212 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);
d1217 1
a1217 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);
d1221 1
a1221 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_GROUP_ORDER);
d1225 1
a1225 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_GROUP_ORDER);
d1233 1
a1233 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);
d1238 1
a1238 1
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);
d1261 1
a1261 2
		ECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP,
		    EC_R_MISSING_PARAMETERS);
d1267 1
a1267 2
			ECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP,
			    EC_R_EC_GROUP_NEW_BY_NAME_FAILURE);
d1275 1
a1275 1
			ECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP, ERR_R_EC_LIB);
d1282 1
a1282 1
		ECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP, EC_R_ASN1_ERROR);
d1298 1
a1298 1
		ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_D2I_ECPKPARAMETERS_FAILURE);
d1302 1
a1302 1
		ECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_PKPARAMETERS2GROUP_FAILURE);
d1322 1
a1322 1
		ECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_GROUP2PKPARAMETERS_FAILURE);
d1326 1
a1326 1
		ECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_I2D_ECPKPARAMETERS_FAILURE);
d1343 1
a1343 1
		ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
d1347 1
a1347 1
		ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
d1353 1
a1353 1
			ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
d1364 1
a1364 1
		ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
d1375 1
a1375 2
			ECerr(EC_F_D2I_ECPRIVATEKEY,
			    ERR_R_BN_LIB);
d1379 1
a1379 2
		ECerr(EC_F_D2I_ECPRIVATEKEY,
		    EC_R_MISSING_PRIVATE_KEY);
d1390 1
a1390 1
			ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
d1399 1
a1399 1
			ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
d1427 1
a1427 2
		ECerr(EC_F_I2D_ECPRIVATEKEY,
		    ERR_R_PASSED_NULL_PARAMETER);
d1431 1
a1431 2
		ECerr(EC_F_I2D_ECPRIVATEKEY,
		    ERR_R_MALLOC_FAILURE);
d1439 1
a1439 2
		ECerr(EC_F_I2D_ECPRIVATEKEY,
		    ERR_R_MALLOC_FAILURE);
d1443 1
a1443 1
		ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_BN_LIB);
d1447 1
a1447 1
		ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_ASN1_LIB);
d1453 1
a1453 1
			ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
d1460 1
a1460 2
			ECerr(EC_F_I2D_ECPRIVATEKEY,
			    ERR_R_MALLOC_FAILURE);
d1469 1
a1469 1
				ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
d1477 1
a1477 1
			ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
d1484 1
a1484 1
			ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_ASN1_LIB);
d1489 1
a1489 1
		ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
d1504 1
a1504 1
		ECerr(EC_F_I2D_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);
d1516 1
a1516 1
		ECerr(EC_F_D2I_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);
d1521 1
a1521 1
			ECerr(EC_F_D2I_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
d1528 1
a1528 1
		ECerr(EC_F_D2I_ECPARAMETERS, ERR_R_EC_LIB);
d1549 1
a1549 1
		ECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);
d1555 1
a1555 1
		ECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);
d1559 1
a1559 1
		ECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_EC_LIB);
d1575 1
a1575 1
		ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);
d1587 1
a1587 1
			ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);
d1594 1
a1594 1
		ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_EC_LIB);
@


1.21
log
@Remove pointless externs - the structs are declared in the same files a
few lines above.
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.20 2015/10/16 15:12:30 jsing Exp $ */
d1022 1
a1022 1
		 * use the asn1 OID to describe the the elliptic curve
@


1.20
log
@Expand DECLARE_ASN1_ALLOC_FUNCTIONS and DECLARE_ASN1_FUNCTIONS_const
macros. The only change in the generated assembly is due to line numbering.
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.19 2015/10/16 15:09:28 jsing Exp $ */
a561 1
extern const ASN1_ITEM ECPKPARAMETERS_it;
a632 1
extern const ASN1_ITEM EC_PRIVATEKEY_it;
@


1.19
log
@Remove pointless uses of DECLARE_ASN1_ENCODE_FUNCTIONS_const.

DECLARE_ASN1_FUNCTIONS_const already includes this macro so using both
means we end up with duplicate function prototypes and externs.
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.18 2015/09/29 13:54:40 jsing Exp $ */
d235 2
a236 1
DECLARE_ASN1_ALLOC_FUNCTIONS(X9_62_PENTANOMIAL)
d337 2
a338 1
DECLARE_ASN1_ALLOC_FUNCTIONS(X9_62_CHARACTERISTIC_TWO)
d509 2
a510 1
DECLARE_ASN1_ALLOC_FUNCTIONS(ECPARAMETERS)
d558 5
a562 1
DECLARE_ASN1_FUNCTIONS_const(ECPKPARAMETERS)
d630 5
a634 1
DECLARE_ASN1_FUNCTIONS_const(EC_PRIVATEKEY)
@


1.18
log
@Replace remaining M_ASN1_BIT_STRING_(new|free) macros with calls to
ASN1_BIT_STRING_(new|free).

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.17 2015/09/10 14:29:22 jsing Exp $ */
d554 1
a555 1
DECLARE_ASN1_ENCODE_FUNCTIONS_const(ECPKPARAMETERS, ECPKPARAMETERS)
d622 1
a623 1
DECLARE_ASN1_ENCODE_FUNCTIONS_const(EC_PRIVATEKEY, EC_PRIVATEKEY)
@


1.17
log
@Replace remaining M_ASN1_STRING_* macros with calls to ASN1_STRING_*.
This is not the same as the macro expansion, however the ASN1_STRING_*
functions do match the macro expansions.

ok doug@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.16 2015/07/29 14:58:34 jsing Exp $ */
d1462 1
a1462 1
		priv_key->publicKey = M_ASN1_BIT_STRING_new();
@


1.16
log
@Expand obsolete M_ASN1.*(cmp|dup|print|set) macros - no change in generated
assembly.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.15 2015/07/25 14:36:39 jsing Exp $ */
d1370 2
a1371 2
		    M_ASN1_STRING_data(priv_key->privateKey),
		    M_ASN1_STRING_length(priv_key->privateKey),
d1394 2
a1395 2
		pub_oct = M_ASN1_STRING_data(priv_key->publicKey);
		pub_oct_len = M_ASN1_STRING_length(priv_key->publicKey);
@


1.15
log
@Expand ASN.1 template macros - the generated assembly only differs by
changes to line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.14 2015/03/20 03:02:51 doug Exp $ */
d861 2
a862 2
	if (!M_ASN1_OCTET_STRING_set(curve->a, a_buf, len_1) ||
	    !M_ASN1_OCTET_STRING_set(curve->b, b_buf, len_2)) {
d1450 1
a1450 1
	if (!M_ASN1_OCTET_STRING_set(priv_key->privateKey, buffer, buf_len)) {
d1487 1
a1487 1
		if (!M_ASN1_BIT_STRING_set(priv_key->publicKey, buffer,
@


1.14
log
@Fix a memory leak in an error path.

From OpenSSL commit 5e5d53d341fd9a9b9cc0a58eb3690832ca7a511f.

ok guenther@@, logan@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.13 2015/03/19 14:00:22 tedu Exp $ */
d201 33
a233 5
ASN1_SEQUENCE(X9_62_PENTANOMIAL) = {
	ASN1_SIMPLE(X9_62_PENTANOMIAL, k1, LONG),
	ASN1_SIMPLE(X9_62_PENTANOMIAL, k2, LONG),
	ASN1_SIMPLE(X9_62_PENTANOMIAL, k3, LONG)
} ASN1_SEQUENCE_END(X9_62_PENTANOMIAL)
d249 87
a335 13
ASN1_ADB_TEMPLATE(char_two_def) = ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.other, ASN1_ANY);

ASN1_ADB(X9_62_CHARACTERISTIC_TWO) = {
	ADB_ENTRY(NID_X9_62_onBasis, ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.onBasis, ASN1_NULL)),
	ADB_ENTRY(NID_X9_62_tpBasis, ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.tpBasis, ASN1_INTEGER)),
	ADB_ENTRY(NID_X9_62_ppBasis, ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, p.ppBasis, X9_62_PENTANOMIAL))
} ASN1_ADB_END(X9_62_CHARACTERISTIC_TWO, 0, type, 0, &char_two_def_tt, NULL);

ASN1_SEQUENCE(X9_62_CHARACTERISTIC_TWO) = {
	ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, m, LONG),
	ASN1_SIMPLE(X9_62_CHARACTERISTIC_TWO, type, ASN1_OBJECT),
	ASN1_ADB_OBJECT(X9_62_CHARACTERISTIC_TWO)
} ASN1_SEQUENCE_END(X9_62_CHARACTERISTIC_TWO)
d349 158
a506 26
ASN1_ADB_TEMPLATE(fieldID_def) = ASN1_SIMPLE(X9_62_FIELDID, p.other, ASN1_ANY);

ASN1_ADB(X9_62_FIELDID) = {
	ADB_ENTRY(NID_X9_62_prime_field, ASN1_SIMPLE(X9_62_FIELDID, p.prime, ASN1_INTEGER)),
	ADB_ENTRY(NID_X9_62_characteristic_two_field, ASN1_SIMPLE(X9_62_FIELDID, p.char_two, X9_62_CHARACTERISTIC_TWO))
} ASN1_ADB_END(X9_62_FIELDID, 0, fieldType, 0, &fieldID_def_tt, NULL);

ASN1_SEQUENCE(X9_62_FIELDID) = {
	ASN1_SIMPLE(X9_62_FIELDID, fieldType, ASN1_OBJECT),
	ASN1_ADB_OBJECT(X9_62_FIELDID)
} ASN1_SEQUENCE_END(X9_62_FIELDID)

ASN1_SEQUENCE(X9_62_CURVE) = {
	ASN1_SIMPLE(X9_62_CURVE, a, ASN1_OCTET_STRING),
	ASN1_SIMPLE(X9_62_CURVE, b, ASN1_OCTET_STRING),
	ASN1_OPT(X9_62_CURVE, seed, ASN1_BIT_STRING)
} ASN1_SEQUENCE_END(X9_62_CURVE)

ASN1_SEQUENCE(ECPARAMETERS) = {
	ASN1_SIMPLE(ECPARAMETERS, version, LONG),
	ASN1_SIMPLE(ECPARAMETERS, fieldID, X9_62_FIELDID),
	ASN1_SIMPLE(ECPARAMETERS, curve, X9_62_CURVE),
	ASN1_SIMPLE(ECPARAMETERS, base, ASN1_OCTET_STRING),
	ASN1_SIMPLE(ECPARAMETERS, order, ASN1_INTEGER),
	ASN1_OPT(ECPARAMETERS, cofactor, ASN1_INTEGER)
} ASN1_SEQUENCE_END(ECPARAMETERS)
d521 33
a553 5
ASN1_CHOICE(ECPKPARAMETERS) = {
	ASN1_SIMPLE(ECPKPARAMETERS, value.named_curve, ASN1_OBJECT),
	ASN1_SIMPLE(ECPKPARAMETERS, value.parameters, ECPARAMETERS),
	ASN1_SIMPLE(ECPKPARAMETERS, value.implicitlyCA, ASN1_NULL)
} ASN1_CHOICE_END(ECPKPARAMETERS)
d582 40
a621 6
ASN1_SEQUENCE(EC_PRIVATEKEY) = {
	ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
	ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
	ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
	ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
} ASN1_SEQUENCE_END(EC_PRIVATEKEY)
@


1.13
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.12 2015/02/10 05:43:09 jsing Exp $ */
d1238 2
@


1.12
log
@Expand the IMPLEMENT_ASN1_ALLOC_FUNCTIONS macro so that the code is visible
and functions can be readily located.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.11 2015/02/10 04:01:26 jsing Exp $ */
d1002 1
a1002 2
		ECPKPARAMETERS_free(params);
		return NULL;
d1006 1
a1006 2
		ECPKPARAMETERS_free(params);
		return NULL;
d1008 2
a1009 1
	if (a && *a)
a1010 1
	if (a)
d1012 1
d1014 1
a1041 1
	int ok = 0;
d1056 1
a1056 2
			ECerr(EC_F_D2I_ECPRIVATEKEY,
			    ERR_R_MALLOC_FAILURE);
a1058 2
		if (a)
			*a = ret;
d1108 6
a1113 1
	ok = 1;
d1115 2
a1116 5
	if (!ok) {
		if (ret)
			EC_KEY_free(ret);
		ret = NULL;
	}
d1120 1
a1120 1
	return (ret);
a1232 2
		if (a)
			*a = ret;
d1240 3
@


1.12.4.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.12 2015/02/10 05:43:09 jsing Exp $ */
d1002 2
a1003 1
		goto err;
d1007 2
a1008 1
		goto err;
d1010 1
a1010 2

	if (a != NULL) {
d1012 1
a1013 1
	}
a1014 1
err:
d1042 1
d1057 2
a1058 1
			ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
d1061 2
d1112 1
a1112 6

	EC_PRIVATEKEY_free(priv_key);
	if (a != NULL)
		*a = ret;
	return (ret);

d1114 5
a1118 2
	if (a == NULL || *a != ret)
		EC_KEY_free(ret);
d1122 1
a1122 1
	return (NULL);
d1235 2
a1243 3

	if (a != NULL)
		*a = ret;
@


1.11
log
@Expand the IMPLEMENT_ASN1_FUNCTIONS_{const,fname,name} macros so that the
code is visible and functions can be readily located.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.10 2014/07/12 16:03:37 miod Exp $ */
d208 12
a219 1
IMPLEMENT_ASN1_ALLOC_FUNCTIONS(X9_62_PENTANOMIAL)
d235 12
a246 1
IMPLEMENT_ASN1_ALLOC_FUNCTIONS(X9_62_CHARACTERISTIC_TWO)
d274 12
a285 1
IMPLEMENT_ASN1_ALLOC_FUNCTIONS(ECPARAMETERS)
@


1.10
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.9 2014/07/10 22:45:57 jsing Exp $ */
d261 25
a285 1
IMPLEMENT_ASN1_FUNCTIONS_const(ECPKPARAMETERS)
d295 25
a319 1
IMPLEMENT_ASN1_FUNCTIONS_const(EC_PRIVATEKEY)
@


1.10.4.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.10 2014/07/12 16:03:37 miod Exp $ */
d921 2
a922 1
		goto err;
d926 2
a927 1
		goto err;
d929 1
a929 2

	if (a != NULL) {
d931 1
a932 1
	}
a933 1
err:
d961 1
d976 2
a977 1
			ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
d980 2
d1031 1
a1031 6

	EC_PRIVATEKEY_free(priv_key);
	if (a != NULL)
		*a = ret;
	return (ret);

d1033 5
a1037 2
	if (a == NULL || *a != ret)
		EC_KEY_free(ret);
d1041 1
a1041 1
	return (NULL);
d1154 2
a1162 3

	if (a != NULL)
		*a = ret;
@


1.9
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.8 2014/07/01 21:26:27 miod Exp $ */
d407 2
a408 2
err:	if (tmp)
		BN_free(tmp);
d512 2
a513 1
err:	free(buffer_1);
d515 2
a516 4
	if (tmp_1)
		BN_free(tmp_1);
	if (tmp_2)
		BN_free(tmp_2);
d610 1
a610 2
	if (tmp)
		BN_free(tmp);
d850 2
a851 4
		if (b) {
			BN_free(b);
			b = NULL;
		}
d864 1
a864 2
		if (ret)
			EC_GROUP_clear_free(ret);
d867 4
a870 8
	if (p)
		BN_free(p);
	if (a)
		BN_free(a);
	if (b)
		BN_free(b);
	if (point)
		EC_POINT_free(point);
d986 1
a986 2
		if (ret->group)
			EC_GROUP_clear_free(ret->group);
d1015 1
a1015 2
		if (ret->pub_key)
			EC_POINT_clear_free(ret->pub_key);
@


1.8
log
@Avoid a NULL deref in i2d_ECPrivateKey() when an EC_KEY lacks the public key
member (which is perfectly acceptable).

From BoringSSL (Adam Langley), commit f71a27920a903c9c36bcb31e68781b17674d3fd2
@
text
@d1 1
a1 1
/* $OpenBSD: ec_asn1.c,v 1.7 2014/06/12 15:49:29 deraadt Exp $ */
d60 3
a66 1

@


1.7
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1095 1
a1095 1
	if (!(a->enc_flag & EC_PKEY_NO_PUBKEY)) {
@


1.6
log
@more: no need for null check before free
ok tedu guenther
@
text
@d1 1
a1 1
/* crypto/ec/ec_asn1.c */
@


1.5
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d808 1
a808 2
		if (ret->seed != NULL)
			free(ret->seed);
@


1.4
log
@don't free memory unless we allocated it.
reported to openssl by David Ramos (rt 3338)
stealing commit from logan, who's run away. ok miod.
@
text
@d510 2
a511 4
err:	if (buffer_1)
		free(buffer_1);
	if (buffer_2)
		free(buffer_2);
d611 1
a611 2
	if (buffer)
		free(buffer);
d1134 1
a1134 2
	if (buffer)
		free(buffer);
@


1.3
log
@knf approximation
@
text
@d1236 4
a1239 2
		free(*out);
		*out = NULL;
@


1.2
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d66 4
a69 3
int EC_GROUP_get_basis_type(const EC_GROUP *group)
	{
	int i=0;
d72 1
a72 1
		NID_X9_62_characteristic_two_field)
d86 1
a86 1
	}
d88 3
a90 2
int EC_GROUP_get_trinomial_basis(const EC_GROUP *group, unsigned int *k)
	{
d96 1
a96 2
	    || !((group->poly[0] != 0) && (group->poly[1] != 0) && (group->poly[2] == 0)))
		{
d99 1
a99 2
		}

d104 5
a108 4
	}
int EC_GROUP_get_pentanomial_basis(const EC_GROUP *group, unsigned int *k1,
	unsigned int *k2, unsigned int *k3)
	{
d114 1
a114 2
	    || !((group->poly[0] != 0) && (group->poly[1] != 0) && (group->poly[2] != 0) && (group->poly[3] != 0) && (group->poly[4] == 0)))
		{
d117 1
a117 2
		}

d126 1
a126 1
	}
d135 1
a135 1
	} X9_62_PENTANOMIAL;
d139 2
a140 2
	ASN1_OBJECT  *type;
	union	{
d143 1
a143 1
		ASN1_NULL    *onBasis;
d150 2
a151 2
		} p;
	} X9_62_CHARACTERISTIC_TWO;
d154 2
a155 2
        ASN1_OBJECT *fieldType;
	union	{
d163 2
a164 2
		} p;
	} X9_62_FIELDID;
d167 4
a170 4
        ASN1_OCTET_STRING *a;
        ASN1_OCTET_STRING *b;
        ASN1_BIT_STRING   *seed;
        } X9_62_CURVE;
d173 7
a179 7
        long              version;
        X9_62_FIELDID     *fieldID;
        X9_62_CURVE       *curve;
        ASN1_OCTET_STRING *base;
        ASN1_INTEGER      *order;
        ASN1_INTEGER      *cofactor;
        } ECPARAMETERS;
d182 1
a182 1
	int	type;
d184 1
a184 1
		ASN1_OBJECT  *named_curve;
d186 1
a186 1
		ASN1_NULL    *implicitlyCA;
d188 1
a188 1
	}/* ECPKPARAMETERS */;
d192 1
a192 1
	long              version;
d194 3
a196 3
        ECPKPARAMETERS    *parameters;
	ASN1_BIT_STRING   *publicKey;
	} EC_PRIVATEKEY;
a220 1

a222 1

a248 1

a256 1

a266 1

a269 1

d272 1
a272 1
/* ec_asn1_group2field() sets the values in a X9_62_FIELDID object */ 
d274 1
a274 1
/* ec_asn1_group2curve() sets the values in a X9_62_CURVE object */ 
d278 2
a279 2
static EC_GROUP *ec_asn1_parameters2group(const ECPARAMETERS *); 
/* ec_asn1_group2parameters() creates a ECPARAMETERS object from a 
d281 1
a281 1
static ECPARAMETERS *ec_asn1_group2parameters(const EC_GROUP *,ECPARAMETERS *);
d284 2
a285 2
static EC_GROUP *ec_asn1_pkparameters2group(const ECPKPARAMETERS *); 
/* ec_asn1_group2pkparameters() creates a ECPKPARAMETERS object from a 
d287 2
a288 2
static ECPKPARAMETERS *ec_asn1_group2pkparameters(const EC_GROUP *, 
	ECPKPARAMETERS *);
d293 6
a298 5
static int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)
	{
	int			ok=0, nid;
	BIGNUM			*tmp = NULL;
	
d310 1
a310 2
	if ((field->fieldType = OBJ_nid2obj(nid)) == NULL)
		{
d313 3
a315 6
		}

	if (nid == NID_X9_62_prime_field)
		{
		if ((tmp = BN_new()) == NULL) 
			{
d318 1
a318 1
			}
d320 1
a320 2
		if (!EC_GROUP_get_curve_GFp(group, tmp, NULL, NULL, NULL))
			{
d323 1
a323 1
			}
d325 2
a326 3
		field->p.prime = BN_to_ASN1_INTEGER(tmp,NULL);
		if (field->p.prime == NULL)
			{
a328 1
			}
d330 1
a330 1
	else	/* nid == NID_X9_62_characteristic_two_field */
d332 1
a332 1
		{
d335 1
a335 1
		}
d337 2
a338 2
		{
		int		field_type;
d344 1
a344 2
		if (char_two == NULL)
			{
d347 2
a348 3
			}
	
		char_two->m = (long)EC_GROUP_get_degree(group);
d352 1
a352 2
		if (field_type == 0)
			{
d355 1
a355 1
			}
d357 1
a357 2
		if ((char_two->type = OBJ_nid2obj(field_type)) == NULL)
			{
d360 2
a361 4
			}

		if (field_type == NID_X9_62_tpBasis)
			{
d368 1
a368 2
			if (!char_two->p.tpBasis)
				{
d371 2
a372 3
				}
			if (!ASN1_INTEGER_set(char_two->p.tpBasis, (long)k))
				{
d374 1
a374 1
					ERR_R_ASN1_LIB);
a375 1
				}
d377 1
a377 2
		else if (field_type == NID_X9_62_ppBasis)
			{
d384 1
a384 2
			if (!char_two->p.ppBasis)
				{
d387 1
a387 2
				}

d389 4
a392 6
			char_two->p.ppBasis->k1 = (long)k1;
			char_two->p.ppBasis->k2 = (long)k2;
			char_two->p.ppBasis->k3 = (long)k3;
			}
		else /* field_type == NID_X9_62_onBasis */
			{
d395 1
a395 2
			if (!char_two->p.onBasis)
				{
a397 1
				}
d400 1
d405 1
a405 1
err :	if (tmp)
d407 1
a407 1
	return(ok);
d410 8
a417 7
static int ec_asn1_group2curve(const EC_GROUP *group, X9_62_CURVE *curve)
	{
	int           ok=0, nid;
	BIGNUM        *tmp_1=NULL, *tmp_2=NULL;
	unsigned char *buffer_1=NULL, *buffer_2=NULL,
	              *a_buf=NULL, *b_buf=NULL;
	size_t        len_1, len_2;
d423 1
a423 2
	if ((tmp_1 = BN_new()) == NULL || (tmp_2 = BN_new()) == NULL)
		{
d426 1
a426 2
		}

d430 2
a431 4
	if (nid == NID_X9_62_prime_field)
		{
		if (!EC_GROUP_get_curve_GFp(group, NULL, tmp_1, tmp_2, NULL))
			{
a433 1
			}
d435 1
d437 2
a438 4
	else	/* nid == NID_X9_62_characteristic_two_field */
		{
		if (!EC_GROUP_get_curve_GF2m(group, NULL, tmp_1, tmp_2, NULL))
			{
a440 1
			}
d442 1
d444 2
a445 2
	len_1 = (size_t)BN_num_bytes(tmp_1);
	len_2 = (size_t)BN_num_bytes(tmp_2);
d447 1
a447 2
	if (len_1 == 0)
		{
d451 2
a452 5
		}
	else
		{
		if ((buffer_1 = malloc(len_1)) == NULL)
			{
d454 1
a454 1
			      ERR_R_MALLOC_FAILURE);
d456 2
a457 3
			}
		if ( (len_1 = BN_bn2bin(tmp_1, buffer_1)) == 0)
			{
d460 1
a460 1
			}
d462 1
a462 1
		}
d464 1
a464 2
	if (len_2 == 0)
		{
d468 2
a469 5
		}
	else
		{
		if ((buffer_2 = malloc(len_2)) == NULL)
			{
d471 1
a471 1
			      ERR_R_MALLOC_FAILURE);
d473 2
a474 3
			}
		if ( (len_2 = BN_bn2bin(tmp_2, buffer_2)) == 0)
			{
d477 1
a477 1
			}
d479 2
a480 2
		}
	
d483 1
a483 2
	    !M_ASN1_OCTET_STRING_set(curve->b, b_buf, len_2))
		{
d486 1
a486 2
		}
	
d488 1
a488 2
	if (group->seed)
		{	
d490 1
a490 2
			if ((curve->seed = ASN1_BIT_STRING_new()) == NULL)
				{
d493 2
a494 2
				}
		curve->seed->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);
d496 2
a497 3
		if (!ASN1_BIT_STRING_set(curve->seed, group->seed, 
		                         (int)group->seed_len))
			{
a499 1
			}
d501 2
a502 4
	else
		{
		if (curve->seed)
			{
a504 1
			}
d506 1
d518 2
a519 2
	return(ok);
	}
d521 9
a529 9
static ECPARAMETERS *ec_asn1_group2parameters(const EC_GROUP *group,
                                              ECPARAMETERS *param)
	{
	int	ok=0;
	size_t  len=0;
	ECPARAMETERS   *ret=NULL;
	BIGNUM	       *tmp=NULL;
	unsigned char  *buffer=NULL;
	const EC_POINT *point=NULL;
d532 1
a532 2
	if ((tmp = BN_new()) == NULL)
		{
d535 6
d542 1
a542 11

	if (param == NULL)
	{
		if ((ret = ECPARAMETERS_new()) == NULL)
			{
			ECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, 
			      ERR_R_MALLOC_FAILURE);
			goto err;
			}
	}
	else
d546 1
a546 1
	ret->version = (long)0x1;
d549 1
a549 2
	if (!ec_asn1_group2fieldid(group, ret->fieldID))
		{
d552 1
a552 2
		}

d554 1
a554 2
	if (!ec_asn1_group2curve(group, ret->curve))
		{
d557 1
a557 2
		}

d559 1
a559 2
	if ((point = EC_GROUP_get0_generator(group)) == NULL)
		{
d562 1
a562 2
		}

d566 1
a566 2
	if (len == 0)
		{
d569 2
a570 3
		}
	if ((buffer = malloc(len)) == NULL)
		{
d573 2
a574 3
		}
	if (!EC_POINT_point2oct(group, point, form, buffer, len, NULL))
		{
d577 2
a578 3
		}
	if (ret->base == NULL && (ret->base = ASN1_OCTET_STRING_new()) == NULL)
		{
d581 2
a582 3
		}
	if (!ASN1_OCTET_STRING_set(ret->base, buffer, len))
		{
d585 1
a585 2
		}

d587 1
a587 2
	if (!EC_GROUP_get_order(group, tmp, NULL))
		{
d590 1
a590 1
		}
d592 1
a592 2
	if (ret->order == NULL)
		{
d595 1
a595 2
		}

d597 1
a597 2
	if (EC_GROUP_get_cofactor(group, tmp, NULL))
		{
d599 1
a599 2
		if (ret->cofactor == NULL)
			{
a601 1
			}
d603 1
a603 1

d606 1
a606 2
err :	if(!ok)
		{
d610 1
a610 1
		}
d615 2
a616 2
	return(ret);
	}
d618 4
a621 4
ECPKPARAMETERS *ec_asn1_group2pkparameters(const EC_GROUP *group, 
                                           ECPKPARAMETERS *params)
	{
	int            ok = 1, tmp;
d624 4
a627 6
	if (ret == NULL)
		{
		if ((ret = ECPKPARAMETERS_new()) == NULL)
			{
			ECerr(EC_F_EC_ASN1_GROUP2PKPARAMETERS, 
			      ERR_R_MALLOC_FAILURE);
a628 1
			}
d630 1
a630 2
	else
		{
d635 1
a635 1
		}
d637 4
a640 4
	if (EC_GROUP_get_asn1_flag(group))
		{
		/* use the asn1 OID to describe the
		 * the elliptic curve parameters
d643 1
a643 2
		if (tmp)
			{
d647 1
a647 2
			}
		else
d650 1
a650 3
		}
	else
		{	
d654 1
a654 1
		     group, NULL)) == NULL)
d656 1
a656 1
		}
d658 1
a658 2
	if (!ok)
		{
d661 1
a661 1
		}
d663 10
a672 1
	}
d674 2
a675 11
static EC_GROUP *ec_asn1_parameters2group(const ECPARAMETERS *params)
	{
	int			ok = 0, tmp;
	EC_GROUP		*ret = NULL;
	BIGNUM			*p = NULL, *a = NULL, *b = NULL;
	EC_POINT		*point=NULL;
	long    		field_bits;

	if (!params->fieldID || !params->fieldID->fieldType || 
	    !params->fieldID->p.ptr)
		{
d678 1
a678 2
		}

d680 1
a680 1
	if (!params->curve || !params->curve->a || 
d682 1
a682 2
	    !params->curve->b->data)
		{
d685 1
a685 1
		}
d687 1
a687 2
	if (a == NULL)
		{
d690 1
a690 1
		}
d692 1
a692 2
	if (b == NULL)
		{
d695 1
a695 2
		}

d700 1
a700 1
		{
d703 1
a703 1
		}
d705 1
a705 1
		{
d711 1
a711 2
		if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS)
			{
d714 2
a715 4
			}

		if ((p = BN_new()) == NULL)
			{
d718 1
a718 2
			}

d722 1
a722 2
		if (tmp ==  NID_X9_62_tpBasis)
			{
d725 1
a725 2
			if (!char_two->p.tpBasis)
				{
d728 1
a728 2
				}

d731 1
a731 2
			if (!(char_two->m > tmp_long && tmp_long > 0))
				{
d734 1
a734 2
				}
			
d736 1
a736 1
			if (!BN_set_bit(p, (int)char_two->m))
d738 1
a738 1
			if (!BN_set_bit(p, (int)tmp_long))
d742 1
a742 3
			}
		else if (tmp == NID_X9_62_ppBasis)
			{
d746 1
a746 2
			if (!penta)
				{
d749 2
a750 4
				}

			if (!(char_two->m > penta->k3 && penta->k3 > penta->k2 && penta->k2 > penta->k1 && penta->k1 > 0))
				{
d753 1
a753 2
				}
			
d755 11
a765 8
			if (!BN_set_bit(p, (int)char_two->m)) goto err;
			if (!BN_set_bit(p, (int)penta->k1)) goto err;
			if (!BN_set_bit(p, (int)penta->k2)) goto err;
			if (!BN_set_bit(p, (int)penta->k3)) goto err;
			if (!BN_set_bit(p, 0)) goto err;
			}
		else if (tmp == NID_X9_62_onBasis)
			{
d768 1
a768 3
			}
		else /* error */
			{
d771 1
a771 1
			}
d775 1
a775 1
		}
d777 1
a777 2
	else if (tmp == NID_X9_62_prime_field)
		{
d780 1
a780 2
		if (!params->fieldID->p.prime)
			{
d783 1
a783 1
			}
d785 1
a785 2
		if (p == NULL)
			{
d788 2
a789 4
			}

		if (BN_is_negative(p) || BN_is_zero(p))
			{
d792 1
a792 2
			}

d794 1
a794 2
		if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS)
			{
d797 1
a797 2
			}

d800 1
a800 3
		}
	else
		{
d803 1
a803 1
		}
d805 1
a805 2
	if (ret == NULL)
		{
d808 1
a808 2
		}

d810 1
a810 2
	if (params->curve->seed != NULL)
		{
d813 3
a815 4
		if (!(ret->seed = malloc(params->curve->seed->length)))
			{
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, 
			      ERR_R_MALLOC_FAILURE);
d817 3
a819 3
			}
		memcpy(ret->seed, params->curve->seed->data, 
		       params->curve->seed->length);
d821 2
a822 4
		}

	if (!params->order || !params->base || !params->base->data)
		{
d825 3
a827 3
		}

	if ((point = EC_POINT_new(ret)) == NULL) goto err;
d831 1
a831 1
				(params->base->data[0] & ~0x01));
d834 2
a835 3
	if (!EC_POINT_oct2point(ret, point, params->base->data, 
		                params->base->length, NULL))
		{
d838 1
a838 2
		}

d840 1
a840 2
	if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL)
		{
d843 2
a844 3
		}
	if (BN_is_negative(a) || BN_is_zero(a))
		{
d847 2
a848 3
		}
	if (BN_num_bits(a) > (int)field_bits + 1) /* Hasse bound */
		{
d851 1
a851 2
		}
	
d853 2
a854 4
	if (params->cofactor == NULL)
		{
		if (b)
			{
a856 1
			}
d858 4
a861 6
	else
		if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL)
			{
			ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);
			goto err;
			}
d863 1
a863 2
	if (!EC_GROUP_set_generator(ret, point, a, b))
		{
d866 1
a866 2
		}

d869 2
a870 3
err:	if (!ok)
		{
		if (ret) 
d873 2
a874 3
		}

	if (p)	
d876 1
a876 1
	if (a)	
d878 1
a878 1
	if (b)	
d880 1
a880 1
	if (point)	
d882 1
a882 1
	return(ret);
d885 9
a893 9
EC_GROUP *ec_asn1_pkparameters2group(const ECPKPARAMETERS *params)
	{
	EC_GROUP *ret=NULL;
	int      tmp=0;

	if (params == NULL)
		{
		ECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP, 
		      EC_R_MISSING_PARAMETERS);
d895 2
a896 4
		}

	if (params->type == 0)
		{ /* the curve is given by an OID */
d898 3
a900 4
		if ((ret = EC_GROUP_new_by_curve_name(tmp)) == NULL)
			{
			ECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP, 
			      EC_R_EC_GROUP_NEW_BY_NAME_FAILURE);
d902 1
a902 1
			}
d904 2
a905 4
		}
	else if (params->type == 1)
		{ /* the parameters are given by a ECPARAMETERS
		   * structure */
d907 1
a907 2
		if (!ret)
			{
d910 1
a910 1
			}
d912 1
a912 3
		}
	else if (params->type == 2)
		{ /* implicitlyCA */
d914 1
a914 3
		}
	else
		{
d917 1
a917 1
		}
d920 1
a920 1
	}
d924 5
a928 4
EC_GROUP *d2i_ECPKParameters(EC_GROUP **a, const unsigned char **in, long len)
	{
	EC_GROUP	*group  = NULL;
	ECPKPARAMETERS	*params = NULL;
d930 1
a930 2
	if ((params = d2i_ECPKPARAMETERS(NULL, in, len)) == NULL)
		{
d934 2
a935 4
		}
	
	if ((group = ec_asn1_pkparameters2group(params)) == NULL)
		{
d938 2
a939 4
		return NULL; 
		}

	
d946 2
a947 2
	return(group);
	}
d949 6
a954 6
int i2d_ECPKParameters(const EC_GROUP *a, unsigned char **out)
	{
	int		ret=0;
	ECPKPARAMETERS	*tmp = ec_asn1_group2pkparameters(a, NULL);
	if (tmp == NULL)
		{
d957 2
a958 3
		}
	if ((ret = i2d_ECPKPARAMETERS(tmp, out)) == 0)
		{
d962 1
a962 1
		}	
d964 2
a965 2
	return(ret);
	}
d969 6
a974 5
EC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)
	{
	int             ok=0;
	EC_KEY          *ret=NULL;
	EC_PRIVATEKEY   *priv_key=NULL;
d976 1
a976 2
	if ((priv_key = EC_PRIVATEKEY_new()) == NULL)
		{
d979 2
a980 4
		}

	if ((priv_key = d2i_EC_PRIVATEKEY(&priv_key, in, len)) == NULL)
		{
d984 3
a986 6
		}

	if (a == NULL || *a == NULL)
		{
		if ((ret = EC_KEY_new()) == NULL)	
			{
d988 1
a988 1
                                 ERR_R_MALLOC_FAILURE);
d990 1
a990 1
			}
d993 1
a993 2
		}
	else
d996 1
a996 2
	if (priv_key->parameters)
		{
d1000 2
a1001 4
		}

	if (ret->group == NULL)
		{
d1004 1
a1004 2
		}

d1007 1
a1007 2
	if (priv_key->privateKey)
		{
d1009 4
a1012 5
			M_ASN1_STRING_data(priv_key->privateKey),
			M_ASN1_STRING_length(priv_key->privateKey),
			ret->priv_key);
		if (ret->priv_key == NULL)
			{
d1014 1
a1014 1
                              ERR_R_BN_LIB);
a1015 1
			}
d1017 3
a1019 4
	else
		{
		ECerr(EC_F_D2I_ECPRIVATEKEY, 
                      EC_R_MISSING_PRIVATE_KEY);
d1021 1
a1021 1
		}
d1023 1
a1023 2
	if (priv_key->publicKey)
		{
d1030 1
a1030 2
		if (ret->pub_key == NULL)
			{
d1033 2
a1034 2
			}
		pub_oct     = M_ASN1_STRING_data(priv_key->publicKey);
d1037 1
a1037 1
		ret->conv_form = (point_conversion_form_t)(pub_oct[0] & ~0x01);
d1039 1
a1039 2
			pub_oct, pub_oct_len, NULL))
			{
a1041 1
			}
d1043 1
a1043 1

d1046 1
a1046 2
	if (!ok)
		{
d1050 1
a1050 2
		}

d1054 2
a1055 2
	return(ret);
	}
d1057 7
a1063 6
int	i2d_ECPrivateKey(EC_KEY *a, unsigned char **out)
	{
	int             ret=0, ok=0;
	unsigned char   *buffer=NULL;
	size_t          buf_len=0, tmp_len;
	EC_PRIVATEKEY   *priv_key=NULL;
d1065 1
a1065 2
	if (a == NULL || a->group == NULL || a->priv_key == NULL)
		{
d1067 1
a1067 1
                      ERR_R_PASSED_NULL_PARAMETER);
d1069 2
a1070 4
		}

	if ((priv_key = EC_PRIVATEKEY_new()) == NULL)
		{
d1072 1
a1072 1
                      ERR_R_MALLOC_FAILURE);
d1074 1
a1074 2
		}

d1077 1
a1077 1
	buf_len = (size_t)BN_num_bytes(a->priv_key);
d1079 1
a1079 2
	if (buffer == NULL)
		{
d1081 1
a1081 1
                      ERR_R_MALLOC_FAILURE);
d1083 2
a1084 4
		}
	
	if (!BN_bn2bin(a->priv_key, buffer))
		{
d1087 2
a1088 4
		}

	if (!M_ASN1_OCTET_STRING_set(priv_key->privateKey, buffer, buf_len))
		{
d1091 2
a1092 4
		}	

	if (!(a->enc_flag & EC_PKEY_NO_PARAMETERS))
		{
d1094 1
a1094 2
			a->group, priv_key->parameters)) == NULL)
			{
a1096 1
			}
d1098 2
a1099 3

	if (!(a->enc_flag & EC_PKEY_NO_PUBKEY))
		{
d1101 1
a1101 2
		if (priv_key->publicKey == NULL)
			{
d1103 1
a1103 1
				ERR_R_MALLOC_FAILURE);
d1105 3
a1107 1
			}
d1109 1
a1109 5
		tmp_len = EC_POINT_point2oct(a->group, a->pub_key, 
				a->conv_form, NULL, 0, NULL);

		if (tmp_len > buf_len)
			{
d1111 1
a1111 2
			if (!tmp_buffer)
				{
d1114 1
a1114 1
				}
d1117 3
a1119 5
			}

		if (!EC_POINT_point2oct(a->group, a->pub_key, 
			a->conv_form, buffer, buf_len, NULL))
			{
d1122 2
a1123 3
			}

		priv_key->publicKey->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);
d1125 2
a1126 3
		if (!M_ASN1_BIT_STRING_set(priv_key->publicKey, buffer, 
				buf_len))
			{
a1128 1
			}
d1130 2
a1131 3

	if ((ret = i2d_EC_PRIVATEKEY(priv_key, out)) == 0)
		{
d1134 2
a1135 2
		}
	ok=1;
d1141 2
a1142 2
	return(ok?ret:0);
	}
d1144 4
a1147 4
int i2d_ECParameters(EC_KEY *a, unsigned char **out)
	{
	if (a == NULL)
		{
d1150 1
a1150 1
		}
d1152 1
a1152 1
	}
d1154 4
a1157 3
EC_KEY *d2i_ECParameters(EC_KEY **a, const unsigned char **in, long len)
	{
	EC_KEY   *ret;
d1159 1
a1159 2
	if (in == NULL || *in == NULL)
		{
d1162 3
a1164 6
		}

	if (a == NULL || *a == NULL)
		{
		if ((ret = EC_KEY_new()) == NULL)
			{
d1167 1
a1167 1
			}
d1170 1
a1170 2
		}
	else
d1173 1
a1173 2
	if (!d2i_ECPKParameters(&ret->group, in, len))
		{
d1176 1
a1176 2
		}

d1178 1
a1178 1
	}
d1180 10
a1189 8
EC_KEY *o2i_ECPublicKey(EC_KEY **a, const unsigned char **in, long len)
	{
	EC_KEY *ret=NULL;

	if (a == NULL || (*a) == NULL || (*a)->group == NULL)
		{
		/* sorry, but a EC_GROUP-structur is necessary
                 * to set the public key */
d1192 1
a1192 1
		}
d1194 2
a1195 3
	if (ret->pub_key == NULL && 
		(ret->pub_key = EC_POINT_new(ret->group)) == NULL)
		{
d1198 2
a1199 3
		}
	if (!EC_POINT_oct2point(ret->group, ret->pub_key, *in, len, NULL))
		{
d1202 1
a1202 1
		}
d1204 1
a1204 1
	ret->conv_form = (point_conversion_form_t)(*in[0] & ~0x01);
d1207 1
a1207 1
	}
d1209 4
a1212 3
int i2o_ECPublicKey(EC_KEY *a, unsigned char **out)
	{
        size_t buf_len=0;
d1215 1
a1215 2
        if (a == NULL) 
		{
d1218 3
a1220 4
		}

        buf_len = EC_POINT_point2oct(a->group, a->pub_key, 
                              a->conv_form, NULL, 0, NULL);
d1223 1
a1223 1
	/* out == NULL => just return the length of the octet string */
d1226 2
a1227 4
	if (*out == NULL)
		{
		if ((*out = malloc(buf_len)) == NULL)
			{
d1230 1
a1230 1
			}
d1232 3
a1234 4
		}
        if (!EC_POINT_point2oct(a->group, a->pub_key, a->conv_form,
				*out, buf_len, NULL))
		{
d1239 1
a1239 1
		}
d1243 1
a1243 1
	}
@


1.1
log
@Initial revision
@
text
@d86 1
a86 1

d92 2
a93 1
	if (EC_GROUP_method_of(group)->group_set_curve != ec_GF2m_simple_group_set_curve
a104 1

d111 2
a112 1
	if (EC_GROUP_method_of(group)->group_set_curve != ec_GF2m_simple_group_set_curve
d128 1
a128 1

d344 6
d429 1
d467 1
d476 1
a476 1

d488 1
a488 1
		if ((buffer_1 = OPENSSL_malloc(len_1)) == NULL)
d510 1
a510 1
		if ((buffer_2 = OPENSSL_malloc(len_2)) == NULL)
d562 1
a562 1
		OPENSSL_free(buffer_1);
d564 1
a564 1
		OPENSSL_free(buffer_2);
d633 1
a633 1
	if ((buffer = OPENSSL_malloc(len)) == NULL)
d689 1
a689 1
		OPENSSL_free(buffer);
a786 1

d788 6
d879 1
d928 2
a929 2
			OPENSSL_free(ret->seed);
		if (!(ret->seed = OPENSSL_malloc(params->curve->seed->length)))
d1083 1
d1250 1
a1250 1
	buffer = OPENSSL_malloc(buf_len);
d1295 1
a1295 1
			unsigned char *tmp_buffer = OPENSSL_realloc(buffer, tmp_len);
d1330 1
a1330 1
		OPENSSL_free(buffer);
d1427 1
a1427 1
		if ((*out = OPENSSL_malloc(buf_len)) == NULL)
d1438 1
a1438 1
		OPENSSL_free(*out);
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.1c
@
text
@d86 1
a86 1
#ifndef OPENSSL_NO_EC2M
d104 1
d127 1
a127 1
#endif
a342 6
#ifdef OPENSSL_NO_EC2M
		{
		ECerr(EC_F_EC_ASN1_GROUP2FIELDID, EC_R_GF2M_NOT_SUPPORTED);
		goto err;
		}
#else
a421 1
#endif
a458 1
#ifndef OPENSSL_NO_EC2M
d467 1
a467 1
#endif
d778 1
a779 6
#ifdef OPENSSL_NO_EC2M
		{
		ECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_GF2M_NOT_SUPPORTED);
		goto err;
		}
#else
a864 1
#endif
a1067 1
		ECPKPARAMETERS_free(params);
@


1.1.1.3
log
@Import OpenSSL 1.0.1g
@
text
@d92 1
a92 2
	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
	    NID_X9_62_characteristic_two_field
d110 1
a110 2
	if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=
	    NID_X9_62_characteristic_two_field
@


