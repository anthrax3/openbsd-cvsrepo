head	1.20;
access;
symbols;
locks; strict;
comment	@ * @;


1.20
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.19;
commitid	kT0fLt3r4lroFJra;

1.19
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.18;
commitid	vHznCDK3idwNEFz4;

1.18
date	2015.02.15.08.44.35;	author miod;	state Exp;
branches;
next	1.17;
commitid	KU7iW6ZkZDTsHhZD;

1.17
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.16;
commitid	69Tc75PIK8JcRRsC;

1.16
date	2015.02.07.13.19.15;	author doug;	state Exp;
branches;
next	1.15;
commitid	gtwLkRyWx0K1HbzX;

1.15
date	2014.11.11.06.23.43;	author guenther;	state Exp;
branches;
next	1.14;
commitid	p0fBVBH3MNmp6587;

1.14
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.13;
commitid	G74O1dmRukKsW7IJ;

1.13
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	mJUVYpkFBZ0Zv2bG;

1.12
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	2nvnQBrv22dLtvTt;

1.11
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2014.05.29.21.19.30;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2014.05.06.03.56.27;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.13;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.18;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.08;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.11.21.14.30;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2011.11.03.02.32.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: ec_mult.c,v 1.19 2015/09/10 15:56:25 jsing Exp $ */
/*
 * Originally written by Bodo Moeller and Nils Larsch for the OpenSSL project.
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * Portions of this software developed by SUN MICROSYSTEMS, INC.,
 * and contributed to the OpenSSL project.
 */

#include <string.h>

#include <openssl/err.h>

#include "ec_lcl.h"


/*
 * This file implements the wNAF-based interleaving multi-exponentation method
 * (<URL:http://www.informatik.tu-darmstadt.de/TI/Mitarbeiter/moeller.html#multiexp>);
 * for multiplication with precomputation, we use wNAF splitting
 * (<URL:http://www.informatik.tu-darmstadt.de/TI/Mitarbeiter/moeller.html#fastexp>).
 */




/* structure for precomputed multiples of the generator */
typedef struct ec_pre_comp_st {
	const EC_GROUP *group;	/* parent EC_GROUP object */
	size_t blocksize;	/* block size for wNAF splitting */
	size_t numblocks;	/* max. number of blocks for which we have
				 * precomputation */
	size_t w;		/* window size */
	EC_POINT **points;	/* array with pre-calculated multiples of
				 * generator: 'num' pointers to EC_POINT
				 * objects followed by a NULL */
	size_t num;		/* numblocks * 2^(w-1) */
	int references;
} EC_PRE_COMP;

/* functions to manage EC_PRE_COMP within the EC_GROUP extra_data framework */
static void *ec_pre_comp_dup(void *);
static void ec_pre_comp_free(void *);
static void ec_pre_comp_clear_free(void *);

static EC_PRE_COMP *
ec_pre_comp_new(const EC_GROUP * group)
{
	EC_PRE_COMP *ret = NULL;

	if (!group)
		return NULL;

	ret = malloc(sizeof(EC_PRE_COMP));
	if (!ret) {
		ECerror(ERR_R_MALLOC_FAILURE);
		return ret;
	}
	ret->group = group;
	ret->blocksize = 8;	/* default */
	ret->numblocks = 0;
	ret->w = 4;		/* default */
	ret->points = NULL;
	ret->num = 0;
	ret->references = 1;
	return ret;
}

static void *
ec_pre_comp_dup(void *src_)
{
	EC_PRE_COMP *src = src_;

	/* no need to actually copy, these objects never change! */

	CRYPTO_add(&src->references, 1, CRYPTO_LOCK_EC_PRE_COMP);

	return src_;
}

static void 
ec_pre_comp_free(void *pre_)
{
	int i;
	EC_PRE_COMP *pre = pre_;

	if (!pre)
		return;

	i = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);
	if (i > 0)
		return;

	if (pre->points) {
		EC_POINT **p;

		for (p = pre->points; *p != NULL; p++)
			EC_POINT_free(*p);
		free(pre->points);
	}
	free(pre);
}

static void 
ec_pre_comp_clear_free(void *pre_)
{
	int i;
	EC_PRE_COMP *pre = pre_;

	if (!pre)
		return;

	i = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);
	if (i > 0)
		return;

	if (pre->points) {
		EC_POINT **p;

		for (p = pre->points; *p != NULL; p++) {
			EC_POINT_clear_free(*p);
			explicit_bzero(p, sizeof *p);
		}
		free(pre->points);
	}
	explicit_bzero(pre, sizeof *pre);
	free(pre);
}




/* Determine the modified width-(w+1) Non-Adjacent Form (wNAF) of 'scalar'.
 * This is an array  r[]  of values that are either zero or odd with an
 * absolute value less than  2^w  satisfying
 *     scalar = \sum_j r[j]*2^j
 * where at most one of any  w+1  consecutive digits is non-zero
 * with the exception that the most significant digit may be only
 * w-1 zeros away from that next non-zero digit.
 */
static signed char *
compute_wNAF(const BIGNUM * scalar, int w, size_t * ret_len)
{
	int window_val;
	int ok = 0;
	signed char *r = NULL;
	int sign = 1;
	int bit, next_bit, mask;
	size_t len = 0, j;

	if (BN_is_zero(scalar)) {
		r = malloc(1);
		if (!r) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		r[0] = 0;
		*ret_len = 1;
		return r;
	}
	if (w <= 0 || w > 7) {
		/* 'signed char' can represent integers with
		 * absolute values less than 2^7 */
		ECerror(ERR_R_INTERNAL_ERROR);
		goto err;
	}
	bit = 1 << w;		/* at most 128 */
	next_bit = bit << 1;	/* at most 256 */
	mask = next_bit - 1;	/* at most 255 */

	if (BN_is_negative(scalar)) {
		sign = -1;
	}
	if (scalar->d == NULL || scalar->top == 0) {
		ECerror(ERR_R_INTERNAL_ERROR);
		goto err;
	}
	len = BN_num_bits(scalar);
	r = malloc(len + 1);	/* modified wNAF may be one digit longer than
				 * binary representation (*ret_len will be
				 * set to the actual length, i.e. at most
				 * BN_num_bits(scalar) + 1) */
	if (r == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	window_val = scalar->d[0] & mask;
	j = 0;
	while ((window_val != 0) || (j + w + 1 < len)) {
		/* if j+w+1 >= len, window_val will not increase */
		int digit = 0;

		/* 0 <= window_val <= 2^(w+1) */
		if (window_val & 1) {
			/* 0 < window_val < 2^(w+1) */
			if (window_val & bit) {
				digit = window_val - next_bit;	/* -2^w < digit < 0 */

#if 1				/* modified wNAF */
				if (j + w + 1 >= len) {
					/*
					 * special case for generating
					 * modified wNAFs: no new bits will
					 * be added into window_val, so using
					 * a positive digit here will
					 * decrease the total length of the
					 * representation
					 */

					digit = window_val & (mask >> 1);	/* 0 < digit < 2^w */
				}
#endif
			} else {
				digit = window_val;	/* 0 < digit < 2^w */
			}

			if (digit <= -bit || digit >= bit || !(digit & 1)) {
				ECerror(ERR_R_INTERNAL_ERROR);
				goto err;
			}
			window_val -= digit;

			/*
			 * now window_val is 0 or 2^(w+1) in standard wNAF
			 * generation; for modified window NAFs, it may also
			 * be 2^w
			 */
			if (window_val != 0 && window_val != next_bit && window_val != bit) {
				ECerror(ERR_R_INTERNAL_ERROR);
				goto err;
			}
		}
		r[j++] = sign * digit;

		window_val >>= 1;
		window_val += bit * BN_is_bit_set(scalar, j + w);

		if (window_val > next_bit) {
			ECerror(ERR_R_INTERNAL_ERROR);
			goto err;
		}
	}

	if (j > len + 1) {
		ECerror(ERR_R_INTERNAL_ERROR);
		goto err;
	}
	len = j;
	ok = 1;

err:
	if (!ok) {
		free(r);
		r = NULL;
	}
	if (ok)
		*ret_len = len;
	return r;
}


/* TODO: table should be optimised for the wNAF-based implementation,
 *       sometimes smaller windows will give better performance
 *       (thus the boundaries should be increased)
 */
#define EC_window_bits_for_scalar_size(b) \
		((size_t) \
		 ((b) >= 2000 ? 6 : \
		  (b) >=  800 ? 5 : \
		  (b) >=  300 ? 4 : \
		  (b) >=   70 ? 3 : \
		  (b) >=   20 ? 2 : \
		  1))

/* Compute
 *      \sum scalars[i]*points[i],
 * also including
 *      scalar*generator
 * in the addition if scalar != NULL
 */
int 
ec_wNAF_mul(const EC_GROUP * group, EC_POINT * r, const BIGNUM * scalar,
    size_t num, const EC_POINT * points[], const BIGNUM * scalars[], BN_CTX * ctx)
{
	BN_CTX *new_ctx = NULL;
	const EC_POINT *generator = NULL;
	EC_POINT *tmp = NULL;
	size_t totalnum;
	size_t blocksize = 0, numblocks = 0;	/* for wNAF splitting */
	size_t pre_points_per_block = 0;
	size_t i, j;
	int k;
	int r_is_inverted = 0;
	int r_is_at_infinity = 1;
	size_t *wsize = NULL;	/* individual window sizes */
	signed char **wNAF = NULL;	/* individual wNAFs */
	signed char *tmp_wNAF = NULL;
	size_t *wNAF_len = NULL;
	size_t max_len = 0;
	size_t num_val;
	EC_POINT **val = NULL;	/* precomputation */
	EC_POINT **v;
	EC_POINT ***val_sub = NULL;	/* pointers to sub-arrays of 'val' or
					 * 'pre_comp->points' */
	const EC_PRE_COMP *pre_comp = NULL;
	int num_scalar = 0;	/* flag: will be set to 1 if 'scalar' must be
				 * treated like other scalars, i.e.
				 * precomputation is not available */
	int ret = 0;

	if (group->meth != r->meth) {
		ECerror(EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
	}
	if ((scalar == NULL) && (num == 0)) {
		return EC_POINT_set_to_infinity(group, r);
	}
	for (i = 0; i < num; i++) {
		if (group->meth != points[i]->meth) {
			ECerror(EC_R_INCOMPATIBLE_OBJECTS);
			return 0;
		}
	}

	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			goto err;
	}
	if (scalar != NULL) {
		generator = EC_GROUP_get0_generator(group);
		if (generator == NULL) {
			ECerror(EC_R_UNDEFINED_GENERATOR);
			goto err;
		}
		/* look if we can use precomputed multiples of generator */

		pre_comp = EC_EX_DATA_get_data(group->extra_data, ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free);

		if (pre_comp && pre_comp->numblocks &&
		    (EC_POINT_cmp(group, generator, pre_comp->points[0], ctx) == 0)) {
			blocksize = pre_comp->blocksize;

			/*
			 * determine maximum number of blocks that wNAF
			 * splitting may yield (NB: maximum wNAF length is
			 * bit length plus one)
			 */
			numblocks = (BN_num_bits(scalar) / blocksize) + 1;

			/*
			 * we cannot use more blocks than we have
			 * precomputation for
			 */
			if (numblocks > pre_comp->numblocks)
				numblocks = pre_comp->numblocks;

			pre_points_per_block = (size_t) 1 << (pre_comp->w - 1);

			/* check that pre_comp looks sane */
			if (pre_comp->num != (pre_comp->numblocks * pre_points_per_block)) {
				ECerror(ERR_R_INTERNAL_ERROR);
				goto err;
			}
		} else {
			/* can't use precomputation */
			pre_comp = NULL;
			numblocks = 1;
			num_scalar = 1;	/* treat 'scalar' like 'num'-th
					 * element of 'scalars' */
		}
	}
	totalnum = num + numblocks;

	/* includes space for pivot */
	wNAF = reallocarray(NULL, (totalnum + 1), sizeof wNAF[0]);
	if (wNAF == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	wNAF[0] = NULL;		/* preliminary pivot */

	wsize = reallocarray(NULL, totalnum, sizeof wsize[0]);
	wNAF_len = reallocarray(NULL, totalnum, sizeof wNAF_len[0]);
	val_sub = reallocarray(NULL, totalnum, sizeof val_sub[0]);

	if (wsize == NULL || wNAF_len == NULL || val_sub == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	/* num_val will be the total number of temporarily precomputed points */
	num_val = 0;

	for (i = 0; i < num + num_scalar; i++) {
		size_t bits;

		bits = i < num ? BN_num_bits(scalars[i]) : BN_num_bits(scalar);
		wsize[i] = EC_window_bits_for_scalar_size(bits);
		num_val += (size_t) 1 << (wsize[i] - 1);
		wNAF[i + 1] = NULL;	/* make sure we always have a pivot */
		wNAF[i] = compute_wNAF((i < num ? scalars[i] : scalar), wsize[i], &wNAF_len[i]);
		if (wNAF[i] == NULL)
			goto err;
		if (wNAF_len[i] > max_len)
			max_len = wNAF_len[i];
	}

	if (numblocks) {
		/* we go here iff scalar != NULL */

		if (pre_comp == NULL) {
			if (num_scalar != 1) {
				ECerror(ERR_R_INTERNAL_ERROR);
				goto err;
			}
			/* we have already generated a wNAF for 'scalar' */
		} else {
			size_t tmp_len = 0;

			if (num_scalar != 0) {
				ECerror(ERR_R_INTERNAL_ERROR);
				goto err;
			}
			/*
			 * use the window size for which we have
			 * precomputation
			 */
			wsize[num] = pre_comp->w;
			tmp_wNAF = compute_wNAF(scalar, wsize[num], &tmp_len);
			if (tmp_wNAF == NULL)
				goto err;

			if (tmp_len <= max_len) {
				/*
				 * One of the other wNAFs is at least as long
				 * as the wNAF belonging to the generator, so
				 * wNAF splitting will not buy us anything.
				 */

				numblocks = 1;
				totalnum = num + 1;	/* don't use wNAF
							 * splitting */
				wNAF[num] = tmp_wNAF;
				tmp_wNAF = NULL;
				wNAF[num + 1] = NULL;
				wNAF_len[num] = tmp_len;
				if (tmp_len > max_len)
					max_len = tmp_len;
				/*
				 * pre_comp->points starts with the points
				 * that we need here:
				 */
				val_sub[num] = pre_comp->points;
			} else {
				/*
				 * don't include tmp_wNAF directly into wNAF
				 * array - use wNAF splitting and include the
				 * blocks
				 */

				signed char *pp;
				EC_POINT **tmp_points;

				if (tmp_len < numblocks * blocksize) {
					/*
					 * possibly we can do with fewer
					 * blocks than estimated
					 */
					numblocks = (tmp_len + blocksize - 1) / blocksize;
					if (numblocks > pre_comp->numblocks) {
						ECerror(ERR_R_INTERNAL_ERROR);
						goto err;
					}
					totalnum = num + numblocks;
				}
				/* split wNAF in 'numblocks' parts */
				pp = tmp_wNAF;
				tmp_points = pre_comp->points;

				for (i = num; i < totalnum; i++) {
					if (i < totalnum - 1) {
						wNAF_len[i] = blocksize;
						if (tmp_len < blocksize) {
							ECerror(ERR_R_INTERNAL_ERROR);
							goto err;
						}
						tmp_len -= blocksize;
					} else
						/*
						 * last block gets whatever
						 * is left (this could be
						 * more or less than
						 * 'blocksize'!)
						 */
						wNAF_len[i] = tmp_len;

					wNAF[i + 1] = NULL;
					wNAF[i] = malloc(wNAF_len[i]);
					if (wNAF[i] == NULL) {
						ECerror(ERR_R_MALLOC_FAILURE);
						goto err;
					}
					memcpy(wNAF[i], pp, wNAF_len[i]);
					if (wNAF_len[i] > max_len)
						max_len = wNAF_len[i];

					if (*tmp_points == NULL) {
						ECerror(ERR_R_INTERNAL_ERROR);
						goto err;
					}
					val_sub[i] = tmp_points;
					tmp_points += pre_points_per_block;
					pp += blocksize;
				}
			}
		}
	}
	/*
	 * All points we precompute now go into a single array 'val'.
	 * 'val_sub[i]' is a pointer to the subarray for the i-th point, or
	 * to a subarray of 'pre_comp->points' if we already have
	 * precomputation.
	 */
	val = reallocarray(NULL, (num_val + 1), sizeof val[0]);
	if (val == NULL) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	val[num_val] = NULL;	/* pivot element */

	/* allocate points for precomputation */
	v = val;
	for (i = 0; i < num + num_scalar; i++) {
		val_sub[i] = v;
		for (j = 0; j < ((size_t) 1 << (wsize[i] - 1)); j++) {
			*v = EC_POINT_new(group);
			if (*v == NULL)
				goto err;
			v++;
		}
	}
	if (!(v == val + num_val)) {
		ECerror(ERR_R_INTERNAL_ERROR);
		goto err;
	}
	if (!(tmp = EC_POINT_new(group)))
		goto err;

	/*
	 * prepare precomputed values: val_sub[i][0] :=     points[i]
	 * val_sub[i][1] := 3 * points[i] val_sub[i][2] := 5 * points[i] ...
	 */
	for (i = 0; i < num + num_scalar; i++) {
		if (i < num) {
			if (!EC_POINT_copy(val_sub[i][0], points[i]))
				goto err;
		} else {
			if (!EC_POINT_copy(val_sub[i][0], generator))
				goto err;
		}

		if (wsize[i] > 1) {
			if (!EC_POINT_dbl(group, tmp, val_sub[i][0], ctx))
				goto err;
			for (j = 1; j < ((size_t) 1 << (wsize[i] - 1)); j++) {
				if (!EC_POINT_add(group, val_sub[i][j], val_sub[i][j - 1], tmp, ctx))
					goto err;
			}
		}
	}

	if (!EC_POINTs_make_affine(group, num_val, val, ctx))
		goto err;

	r_is_at_infinity = 1;

	for (k = max_len - 1; k >= 0; k--) {
		if (!r_is_at_infinity) {
			if (!EC_POINT_dbl(group, r, r, ctx))
				goto err;
		}
		for (i = 0; i < totalnum; i++) {
			if (wNAF_len[i] > (size_t) k) {
				int digit = wNAF[i][k];
				int is_neg;

				if (digit) {
					is_neg = digit < 0;

					if (is_neg)
						digit = -digit;

					if (is_neg != r_is_inverted) {
						if (!r_is_at_infinity) {
							if (!EC_POINT_invert(group, r, ctx))
								goto err;
						}
						r_is_inverted = !r_is_inverted;
					}
					/* digit > 0 */

					if (r_is_at_infinity) {
						if (!EC_POINT_copy(r, val_sub[i][digit >> 1]))
							goto err;
						r_is_at_infinity = 0;
					} else {
						if (!EC_POINT_add(group, r, r, val_sub[i][digit >> 1], ctx))
							goto err;
					}
				}
			}
		}
	}

	if (r_is_at_infinity) {
		if (!EC_POINT_set_to_infinity(group, r))
			goto err;
	} else {
		if (r_is_inverted)
			if (!EC_POINT_invert(group, r, ctx))
				goto err;
	}

	ret = 1;

err:
	BN_CTX_free(new_ctx);
	EC_POINT_free(tmp);
	free(wsize);
	free(wNAF_len);
	free(tmp_wNAF);
	if (wNAF != NULL) {
		signed char **w;

		for (w = wNAF; *w != NULL; w++)
			free(*w);

		free(wNAF);
	}
	if (val != NULL) {
		for (v = val; *v != NULL; v++)
			EC_POINT_clear_free(*v);
		free(val);
	}
	free(val_sub);
	return ret;
}


/* ec_wNAF_precompute_mult()
 * creates an EC_PRE_COMP object with preprecomputed multiples of the generator
 * for use with wNAF splitting as implemented in ec_wNAF_mul().
 *
 * 'pre_comp->points' is an array of multiples of the generator
 * of the following form:
 * points[0] =     generator;
 * points[1] = 3 * generator;
 * ...
 * points[2^(w-1)-1] =     (2^(w-1)-1) * generator;
 * points[2^(w-1)]   =     2^blocksize * generator;
 * points[2^(w-1)+1] = 3 * 2^blocksize * generator;
 * ...
 * points[2^(w-1)*(numblocks-1)-1] = (2^(w-1)) *  2^(blocksize*(numblocks-2)) * generator
 * points[2^(w-1)*(numblocks-1)]   =              2^(blocksize*(numblocks-1)) * generator
 * ...
 * points[2^(w-1)*numblocks-1]     = (2^(w-1)) *  2^(blocksize*(numblocks-1)) * generator
 * points[2^(w-1)*numblocks]       = NULL
 */
int 
ec_wNAF_precompute_mult(EC_GROUP * group, BN_CTX * ctx)
{
	const EC_POINT *generator;
	EC_POINT *tmp_point = NULL, *base = NULL, **var;
	BN_CTX *new_ctx = NULL;
	BIGNUM *order;
	size_t i, bits, w, pre_points_per_block, blocksize, numblocks,
	 num;
	EC_POINT **points = NULL;
	EC_PRE_COMP *pre_comp;
	int ret = 0;

	/* if there is an old EC_PRE_COMP object, throw it away */
	EC_EX_DATA_free_data(&group->extra_data, ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free);

	if ((pre_comp = ec_pre_comp_new(group)) == NULL)
		return 0;

	generator = EC_GROUP_get0_generator(group);
	if (generator == NULL) {
		ECerror(EC_R_UNDEFINED_GENERATOR);
		goto err;
	}
	if (ctx == NULL) {
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			goto err;
	}
	BN_CTX_start(ctx);
	if ((order = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!EC_GROUP_get_order(group, order, ctx))
		goto err;
	if (BN_is_zero(order)) {
		ECerror(EC_R_UNKNOWN_ORDER);
		goto err;
	}
	bits = BN_num_bits(order);
	/*
	 * The following parameters mean we precompute (approximately) one
	 * point per bit.
	 * 
	 * TBD: The combination  8, 4  is perfect for 160 bits; for other bit
	 * lengths, other parameter combinations might provide better
	 * efficiency.
	 */
	blocksize = 8;
	w = 4;
	if (EC_window_bits_for_scalar_size(bits) > w) {
		/* let's not make the window too small ... */
		w = EC_window_bits_for_scalar_size(bits);
	}
	numblocks = (bits + blocksize - 1) / blocksize;	/* max. number of blocks
							 * to use for wNAF
							 * splitting */

	pre_points_per_block = (size_t) 1 << (w - 1);
	num = pre_points_per_block * numblocks;	/* number of points to
						 * compute and store */

	points = reallocarray(NULL, (num + 1), sizeof(EC_POINT *));
	if (!points) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	var = points;
	var[num] = NULL;	/* pivot */
	for (i = 0; i < num; i++) {
		if ((var[i] = EC_POINT_new(group)) == NULL) {
			ECerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}

	if (!(tmp_point = EC_POINT_new(group)) || !(base = EC_POINT_new(group))) {
		ECerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	if (!EC_POINT_copy(base, generator))
		goto err;

	/* do the precomputation */
	for (i = 0; i < numblocks; i++) {
		size_t j;

		if (!EC_POINT_dbl(group, tmp_point, base, ctx))
			goto err;

		if (!EC_POINT_copy(*var++, base))
			goto err;

		for (j = 1; j < pre_points_per_block; j++, var++) {
			/* calculate odd multiples of the current base point */
			if (!EC_POINT_add(group, *var, tmp_point, *(var - 1), ctx))
				goto err;
		}

		if (i < numblocks - 1) {
			/*
			 * get the next base (multiply current one by
			 * 2^blocksize)
			 */
			size_t k;

			if (blocksize <= 2) {
				ECerror(ERR_R_INTERNAL_ERROR);
				goto err;
			}
			if (!EC_POINT_dbl(group, base, tmp_point, ctx))
				goto err;
			for (k = 2; k < blocksize; k++) {
				if (!EC_POINT_dbl(group, base, base, ctx))
					goto err;
			}
		}
	}

	if (!EC_POINTs_make_affine(group, num, points, ctx))
		goto err;

	pre_comp->group = group;
	pre_comp->blocksize = blocksize;
	pre_comp->numblocks = numblocks;
	pre_comp->w = w;
	pre_comp->points = points;
	points = NULL;
	pre_comp->num = num;

	if (!EC_EX_DATA_set_data(&group->extra_data, pre_comp,
		ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free))
		goto err;
	pre_comp = NULL;

	ret = 1;
err:
	if (ctx != NULL)
		BN_CTX_end(ctx);
	BN_CTX_free(new_ctx);
	ec_pre_comp_free(pre_comp);
	if (points) {
		EC_POINT **p;

		for (p = points; *p != NULL; p++)
			EC_POINT_free(*p);
		free(points);
	}
	EC_POINT_free(tmp_point);
	EC_POINT_free(base);
	return ret;
}


int 
ec_wNAF_have_precompute_mult(const EC_GROUP * group)
{
	if (EC_EX_DATA_get_data(group->extra_data, ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free) != NULL)
		return 1;
	else
		return 0;
}
@


1.19
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_mult.c,v 1.18 2015/02/15 08:44:35 miod Exp $ */
d110 1
a110 1
		ECerr(EC_F_EC_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
d208 1
a208 1
			ECerr(EC_F_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);
d218 1
a218 1
		ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
d229 1
a229 1
		ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
d238 1
a238 1
		ECerr(EC_F_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);
d272 1
a272 1
				ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
d283 1
a283 1
				ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
d293 1
a293 1
			ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
d299 1
a299 1
		ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
d366 1
a366 1
		ECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);
d374 1
a374 1
			ECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);
d387 1
a387 1
			ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);
d416 1
a416 1
				ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
d432 1
a432 1
		ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
d443 1
a443 1
		ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
d469 1
a469 1
				ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
d477 1
a477 1
				ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
d527 1
a527 1
						ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
d540 1
a540 1
							ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
d556 1
a556 1
						ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
d564 1
a564 1
						ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
d582 1
a582 1
		ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
d599 1
a599 1
		ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
d746 1
a746 1
		ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNDEFINED_GENERATOR);
d761 1
a761 1
		ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNKNOWN_ORDER);
d789 1
a789 1
		ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);
d796 1
a796 1
			ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);
d802 1
a802 1
		ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);
d832 1
a832 1
				ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_INTERNAL_ERROR);
@


1.18
log
@In ec_wNAF_mul(), move the declaration of tmp_wNAF higher in scope, so that
all the function's exit paths can make sure it gets freed. Coverity CID 78861
tweaks & ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_mult.c,v 1.17 2015/02/09 15:49:22 jsing Exp $ */
d176 1
a176 1
			OPENSSL_cleanse(p, sizeof *p);
d180 1
a180 1
	OPENSSL_cleanse(pre, sizeof *pre);
@


1.17
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_mult.c,v 1.16 2015/02/07 13:19:15 doug Exp $ */
d351 1
a473 1
			signed char *tmp_wNAF = NULL;
d486 1
a486 1
			if (!tmp_wNAF)
d500 1
a556 1
						free(tmp_wNAF);
a564 1
						free(tmp_wNAF);
a570 1
				free(tmp_wNAF);
d687 1
@


1.16
log
@Delete a lot of #if 0 code in libressl.

There are a few instances where #if 1 is removed but the code remains.

Based on the following OpenSSL commits.  Some of the commits weren't
strictly deletions so they are going to be split up into separate commits.

6f91b017bbb7140f816721141ac156d1b828a6b3
3d47c1d331fdc7574d2275cda1a630ccdb624b08
dfb56425b68314b2b57e17c82c1df42e7a015132
c8fa2356a00cbaada8963f739e5570298311a060
f16a64d11f55c01f56baa62ebf1dec7f8fe718cb
9ccc00ef6ea65567622e40c49aca43f2c6d79cdb
02a938c953b3e1ced71d9a832de1618f907eb96d
75d0ebef2aef7a2c77b27575b8da898e22f3ccd5
d6fbb194095312f4722c81c9362dbd0de66cb656
6f1a93ad111c7dfe36a09a976c4c009079b19ea1
1a5adcfb5edfe23908b350f8757df405b0f5f71f
8de24b792743d11e1d5a0dcd336a49368750c577
a2b18e657ea1a932d125154f4e13ab2258796d90
8e964419603d2478dfb391c66e7ccb2dcc9776b4
32dfde107636ac9bc62a5b3233fe2a54dbc27008

input + ok jsing@@, miod@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_mult.c,v 1.15 2014/11/11 06:23:43 guenther Exp $ */
d756 1
a756 2
	order = BN_CTX_get(ctx);
	if (order == NULL)
@


1.15
log
@Don't free garbage in ec_wNAF_mul() if wNAF could be allocated but
other allocations in the same block couldn't.

problem pointed out by David Ramos on the openssl-dev list
ok miod@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_mult.c,v 1.14 2014/07/12 16:03:37 miod Exp $ */
a629 2
#if 1				/* optional; EC_window_bits_for_scalar_size
				 * assumes we do this step */
a631 1
#endif
@


1.14
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ec_mult.c,v 1.13 2014/06/12 15:49:29 deraadt Exp $ */
d428 9
a438 2
	/* includes space for pivot */
	wNAF = reallocarray(NULL, (totalnum + 1), sizeof wNAF[0]);
d441 1
a441 1
	if (!wsize || !wNAF_len || !wNAF || !val_sub) {
a444 1
	wNAF[0] = NULL;		/* preliminary pivot */
@


1.13
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d682 2
a683 4
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
	if (tmp != NULL)
		EC_POINT_free(tmp);
d863 2
a864 4
	if (new_ctx != NULL)
		BN_CTX_free(new_ctx);
	if (pre_comp)
		ec_pre_comp_free(pre_comp);
d872 2
a873 4
	if (tmp_point)
		EC_POINT_free(tmp_point);
	if (base)
		EC_POINT_free(base);
@


1.12
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/ec/ec_mult.c */
@


1.11
log
@more: no need for null check before free
ok tedu guenther
@
text
@d108 1
a108 1
	ret = (EC_PRE_COMP *) malloc(sizeof(EC_PRE_COMP));
@


1.10
log
@ok, next pass after review:  when possible, put the reallocarray arguments
in the "size_t nmemb, size_t size"
@
text
@d686 2
a687 4
	if (wsize != NULL)
		free(wsize);
	if (wNAF_len != NULL)
		free(wNAF_len);
a698 1

d701 1
a701 3
	if (val_sub != NULL) {
		free(val_sub);
	}
@


1.9
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d793 1
a793 1
	points = reallocarray(NULL, sizeof(EC_POINT *), (num + 1));
@


1.8
log
@knf approximation
@
text
@d428 5
a432 5
	wsize = malloc(totalnum * sizeof wsize[0]);
	wNAF_len = malloc(totalnum * sizeof wNAF_len[0]);
	wNAF = malloc((totalnum + 1) * sizeof wNAF[0]);	/* includes space for
							 * pivot */
	val_sub = malloc(totalnum * sizeof val_sub[0]);
d576 1
a576 1
	val = malloc((num_val + 1) * sizeof val[0]);
d793 1
a793 1
	points = malloc(sizeof(EC_POINT *) * (num + 1));
@


1.7
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d83 9
a91 7
	const EC_GROUP *group; /* parent EC_GROUP object */
	size_t blocksize;      /* block size for wNAF splitting */
	size_t numblocks;      /* max. number of blocks for which we have precomputation */
	size_t w;              /* window size */
	EC_POINT **points;     /* array with pre-calculated multiples of generator:
	                        * 'num' pointers to EC_POINT objects followed by a NULL */
	size_t num;            /* numblocks * 2^(w-1) */
d94 1
a94 1
 
d100 3
a102 2
static EC_PRE_COMP *ec_pre_comp_new(const EC_GROUP *group)
	{
d108 2
a109 3
	ret = (EC_PRE_COMP *)malloc(sizeof(EC_PRE_COMP));
	if (!ret)
		{
d112 1
a112 1
		}
d114 1
a114 1
	ret->blocksize = 8; /* default */
d116 1
a116 1
	ret->w = 4; /* default */
d121 1
a121 1
	}
d123 3
a125 2
static void *ec_pre_comp_dup(void *src_)
	{
d133 1
a133 1
	}
d135 3
a137 2
static void ec_pre_comp_free(void *pre_)
	{
d148 1
a148 2
	if (pre->points)
		{
d154 1
a154 1
		}
d156 1
a156 1
	}
d158 3
a160 2
static void ec_pre_comp_clear_free(void *pre_)
	{
d171 1
a171 2
	if (pre->points)
		{
d174 1
a174 2
		for (p = pre->points; *p != NULL; p++)
			{
d177 1
a177 1
			}
d179 1
a179 1
		}
d182 1
a182 1
	}
d195 3
a197 2
static signed char *compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)
	{
d204 2
a205 3
	
	if (BN_is_zero(scalar))
		{
d207 1
a207 2
		if (!r)
			{
d210 1
a210 1
			}
d214 4
a217 4
		}
		
	if (w <= 0 || w > 7) /* 'signed char' can represent integers with absolute values less than 2^7 */
		{
d220 4
a223 4
		}
	bit = 1 << w; /* at most 128 */
	next_bit = bit << 1; /* at most 256 */
	mask = next_bit - 1; /* at most 255 */
d225 1
a225 2
	if (BN_is_negative(scalar))
		{
d227 2
a228 4
		}

	if (scalar->d == NULL || scalar->top == 0)
		{
d231 1
a231 2
		}

d233 5
a237 5
	r = malloc(len + 1); /* modified wNAF may be one digit longer than binary representation
	                              * (*ret_len will be set to the actual length, i.e. at most
	                              * BN_num_bits(scalar) + 1) */
	if (r == NULL)
		{
d240 1
a240 1
		}
d243 2
a244 2
	while ((window_val != 0) || (j + w + 1 < len)) /* if j+w+1 >= len, window_val will not increase */
		{
d248 4
d253 10
a262 3
		if (window_val & 1)
			{
			/* 0 < window_val < 2^(w+1) */
d264 2
a265 14
			if (window_val & bit)
				{
				digit = window_val - next_bit; /* -2^w < digit < 0 */

#if 1 /* modified wNAF */
				if (j + w + 1 >= len)
					{
					/* special case for generating modified wNAFs:
					 * no new bits will be added into window_val,
					 * so using a positive digit here will decrease
					 * the total length of the representation */
					
					digit = window_val & (mask >> 1); /* 0 < digit < 2^w */
					}
d267 5
a271 8
				}
			else
				{
				digit = window_val; /* 0 < digit < 2^w */
				}
			
			if (digit <= -bit || digit >= bit || !(digit & 1))
				{
d274 1
a274 2
				}

d277 4
a280 2
			/* now window_val is 0 or 2^(w+1) in standard wNAF generation;
			 * for modified window NAFs, it may also be 2^w
d282 1
a282 2
			if (window_val != 0 && window_val != next_bit && window_val != bit)
				{
a284 1
				}
d286 1
a286 1

d292 1
a292 2
		if (window_val > next_bit)
			{
a294 1
			}
d296 1
d298 1
a298 2
	if (j > len + 1)
		{
d301 1
a301 1
		}
d305 2
a306 3
 err:
	if (!ok)
		{
d309 1
a309 1
		}
d313 1
a313 1
	}
d335 4
a338 3
int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
	size_t num, const EC_POINT *points[], const BIGNUM *scalars[], BN_CTX *ctx)
	{
d343 1
a343 1
	size_t blocksize = 0, numblocks = 0; /* for wNAF splitting */
d349 2
a350 2
	size_t *wsize = NULL; /* individual window sizes */
	signed char **wNAF = NULL; /* individual wNAFs */
d354 1
a354 1
	EC_POINT **val = NULL; /* precomputation */
d356 2
a357 1
	EC_POINT ***val_sub = NULL; /* pointers to sub-arrays of 'val' or 'pre_comp->points' */
d359 3
a361 2
	int num_scalar = 0; /* flag: will be set to 1 if 'scalar' must be treated like other scalars,
	                     * i.e. precomputation is not available */
d363 2
a364 3
	
	if (group->meth != r->meth)
		{
d367 2
a368 4
		}

	if ((scalar == NULL) && (num == 0))
		{
d370 3
a372 6
		}

	for (i = 0; i < num; i++)
		{
		if (group->meth != points[i]->meth)
			{
a374 1
			}
d376 1
d378 1
a378 2
	if (ctx == NULL)
		{
d382 2
a383 4
		}

	if (scalar != NULL)
		{
d385 1
a385 2
		if (generator == NULL)
			{
d388 1
a388 2
			}
		
d393 2
a394 2
		if (pre_comp && pre_comp->numblocks && (EC_POINT_cmp(group, generator, pre_comp->points[0], ctx) == 0))
			{
d397 5
a401 2
			/* determine maximum number of blocks that wNAF splitting may yield
			 * (NB: maximum wNAF length is bit length plus one) */
d404 4
a407 1
			/* we cannot use more blocks than we have precomputation for */
d411 1
a411 1
			pre_points_per_block = (size_t)1 << (pre_comp->w - 1);
d414 1
a414 2
			if (pre_comp->num != (pre_comp->numblocks * pre_points_per_block))
				{
a416 1
				}
d418 1
a418 2
		else
			{
d422 2
a423 2
			num_scalar = 1; /* treat 'scalar' like 'num'-th element of 'scalars' */
			}
d425 1
a425 1
	
d428 1
a428 1
	wsize    = malloc(totalnum * sizeof wsize[0]);
d430 5
a434 5
	wNAF     = malloc((totalnum + 1) * sizeof wNAF[0]); /* includes space for pivot */
	val_sub  = malloc(totalnum * sizeof val_sub[0]);
		 
	if (!wsize || !wNAF_len || !wNAF || !val_sub)
		{
d437 2
a438 3
		}

	wNAF[0] = NULL;	/* preliminary pivot */
d443 1
a443 2
	for (i = 0; i < num + num_scalar; i++)
		{
d448 2
a449 2
		num_val += (size_t)1 << (wsize[i] - 1);
		wNAF[i + 1] = NULL; /* make sure we always have a pivot */
d455 1
a455 1
		}
d457 1
a457 2
	if (numblocks)
		{
d459 3
a461 5
		
		if (pre_comp == NULL)
			{
			if (num_scalar != 1)
				{
d464 1
a464 1
				}
d466 1
a466 3
			}
		else
			{
d469 2
a470 3
			
			if (num_scalar != 0)
				{
d473 5
a477 3
				}

			/* use the window size for which we have precomputation */
d483 6
a488 5
			if (tmp_len <= max_len)
				{
				/* One of the other wNAFs is at least as long
				 * as the wNAF belonging to the generator,
				 * so wNAF splitting will not buy us anything. */
d491 2
a492 1
				totalnum = num + 1; /* don't use wNAF splitting */
d498 4
a501 1
				/* pre_comp->points starts with the points that we need here: */
d503 6
a508 5
				}
			else
				{
				/* don't include tmp_wNAF directly into wNAF array
				 * - use wNAF splitting and include the blocks */
d512 6
a517 4
				
				if (tmp_len < numblocks * blocksize)
					{
					/* possibly we can do with fewer blocks than estimated */
d519 1
a519 2
					if (numblocks > pre_comp->numblocks)
						{
d522 1
a522 1
						}
d524 1
a524 2
					}
				
d529 2
a530 4
				for (i = num; i < totalnum; i++)
					{
					if (i < totalnum - 1)
						{
d532 1
a532 2
						if (tmp_len < blocksize)
							{
d535 1
a535 1
							}
d537 7
a543 4
						}
					else
						/* last block gets whatever is left
						 * (this could be more or less than 'blocksize'!) */
d545 1
a545 1
					
d548 1
a548 2
					if (wNAF[i] == NULL)
						{
d552 1
a552 1
						}
d557 1
a557 2
					if (*tmp_points == NULL)
						{
d561 1
a561 1
						}
d565 1
a565 1
					}
a566 1
				}
d569 7
a575 4

	/* All points we precompute now go into a single array 'val'.
	 * 'val_sub[i]' is a pointer to the subarray for the i-th point,
	 * or to a subarray of 'pre_comp->points' if we already have precomputation. */
d577 1
a577 2
	if (val == NULL)
		{
d580 2
a581 2
		}
	val[num_val] = NULL; /* pivot element */
d585 1
a585 2
	for (i = 0; i < num + num_scalar; i++)
		{
d587 1
a587 2
		for (j = 0; j < ((size_t)1 << (wsize[i] - 1)); j++)
			{
d589 2
a590 1
			if (*v == NULL) goto err;
a591 1
			}
d593 2
a594 2
	if (!(v == val + num_val))
		{
d597 1
a597 2
		}

d601 3
a603 5
	/* prepare precomputed values:
	 *    val_sub[i][0] :=     points[i]
	 *    val_sub[i][1] := 3 * points[i]
	 *    val_sub[i][2] := 5 * points[i]
	 *    ...
d605 15
a619 18
	for (i = 0; i < num + num_scalar; i++)
		{
		if (i < num)
			{
			if (!EC_POINT_copy(val_sub[i][0], points[i])) goto err;
			}
		else
			{
			if (!EC_POINT_copy(val_sub[i][0], generator)) goto err;
			}

		if (wsize[i] > 1)
			{
			if (!EC_POINT_dbl(group, tmp, val_sub[i][0], ctx)) goto err;
			for (j = 1; j < ((size_t)1 << (wsize[i] - 1)); j++)
				{
				if (!EC_POINT_add(group, val_sub[i][j], val_sub[i][j - 1], tmp, ctx)) goto err;
				}
d622 1
d624 2
a625 1
#if 1 /* optional; EC_window_bits_for_scalar_size assumes we do this step */
d632 7
a638 11
	for (k = max_len - 1; k >= 0; k--)
		{
		if (!r_is_at_infinity)
			{
			if (!EC_POINT_dbl(group, r, r, ctx)) goto err;
			}
		
		for (i = 0; i < totalnum; i++)
			{
			if (wNAF_len[i] > (size_t)k)
				{
d642 1
a642 2
				if (digit) 
					{
d648 5
a652 6
					if (is_neg != r_is_inverted)
						{
						if (!r_is_at_infinity)
							{
							if (!EC_POINT_invert(group, r, ctx)) goto err;
							}
d654 1
a654 2
						}

d657 3
a659 3
					if (r_is_at_infinity)
						{
						if (!EC_POINT_copy(r, val_sub[i][digit >> 1])) goto err;
d661 3
a663 5
						}
					else
						{
						if (!EC_POINT_add(group, r, r, val_sub[i][digit >> 1], ctx)) goto err;
						}
d668 1
d670 4
a673 6
	if (r_is_at_infinity)
		{
		if (!EC_POINT_set_to_infinity(group, r)) goto err;
		}
	else
		{
d675 4
a678 3
			if (!EC_POINT_invert(group, r, ctx)) goto err;
		}
	
d681 1
a681 1
 err:
d690 1
a690 2
	if (wNAF != NULL)
		{
d692 1
a692 1
		
d695 1
a695 1
		
d697 2
a698 3
		}
	if (val != NULL)
		{
d703 2
a704 3
		}
	if (val_sub != NULL)
		{
d706 1
a706 1
		}
d708 1
a708 1
	}
d714 1
a714 1
 * 
d730 3
a732 2
int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
	{
d737 2
a738 1
	size_t i, bits, w, pre_points_per_block, blocksize, numblocks, num;
d750 1
a750 2
	if (generator == NULL)
		{
d753 2
a754 4
		}

	if (ctx == NULL)
		{
d758 1
a758 2
		}
	
d761 6
a766 5
	if (order == NULL) goto err;
	
	if (!EC_GROUP_get_order(group, order, ctx)) goto err;		
	if (BN_is_zero(order))
		{
d769 1
a769 2
		}

d771 6
a776 5
	/* The following parameters mean we precompute (approximately)
	 * one point per bit.
	 *
	 * TBD: The combination  8, 4  is perfect for 160 bits; for other
	 * bit lengths, other parameter combinations might provide better
d781 1
a781 2
	if (EC_window_bits_for_scalar_size(bits) > w)
		{
d784 8
a791 1
		}
d793 2
a794 8
	numblocks = (bits + blocksize - 1) / blocksize; /* max. number of blocks to use for wNAF splitting */
	
	pre_points_per_block = (size_t)1 << (w - 1);
	num = pre_points_per_block * numblocks; /* number of points to compute and store */

	points = malloc(sizeof (EC_POINT*)*(num + 1));
	if (!points)
		{
d797 1
a797 2
		}

d799 3
a801 5
	var[num] = NULL; /* pivot */
	for (i = 0; i < num; i++)
		{
		if ((var[i] = EC_POINT_new(group)) == NULL)
			{
a803 1
			}
d805 1
d807 1
a807 2
	if (!(tmp_point = EC_POINT_new(group)) || !(base = EC_POINT_new(group)))
		{
d810 1
a810 2
		}	
	
d813 1
a813 1
	
d815 1
a815 2
	for (i = 0; i < numblocks; i++)
		{
d824 1
a824 2
		for (j = 1; j < pre_points_per_block; j++, var++)
			{
d828 1
a828 1
			}
d830 5
a834 3
		if (i < numblocks - 1)
			{
			/* get the next base (multiply current one by 2^blocksize) */
d837 1
a837 2
			if (blocksize <= 2)
				{
d840 1
a840 2
				}				

d843 2
a844 3
			for (k = 2; k < blocksize; k++)
				{
				if (!EC_POINT_dbl(group,base,base,ctx))
a845 1
				}
d847 2
a848 1
 		}
d852 1
a852 1
	
d867 1
a867 1
 err:
d874 1
a874 2
	if (points)
		{
d880 1
a880 1
		}
d886 1
a886 1
	}
d889 3
a891 2
int ec_wNAF_have_precompute_mult(const EC_GROUP *group)
	{
d896 1
a896 1
	}
@


1.6
log
@openssl-1.0.0e: resolve conflicts
@
text
@d105 1
a105 1
	ret = (EC_PRE_COMP *)OPENSSL_malloc(sizeof(EC_PRE_COMP));
d150 1
a150 1
		OPENSSL_free(pre->points);
d152 1
a152 1
	OPENSSL_free(pre);
d176 1
a176 1
		OPENSSL_free(pre->points);
d179 1
a179 1
	OPENSSL_free(pre);
d204 1
a204 1
		r = OPENSSL_malloc(1);
d236 1
a236 1
	r = OPENSSL_malloc(len + 1); /* modified wNAF may be one digit longer than binary representation
d318 1
a318 1
		OPENSSL_free(r);
d444 4
a447 4
	wsize    = OPENSSL_malloc(totalnum * sizeof wsize[0]);
	wNAF_len = OPENSSL_malloc(totalnum * sizeof wNAF_len[0]);
	wNAF     = OPENSSL_malloc((totalnum + 1) * sizeof wNAF[0]); /* includes space for pivot */
	val_sub  = OPENSSL_malloc(totalnum * sizeof val_sub[0]);
d563 1
a563 1
					wNAF[i] = OPENSSL_malloc(wNAF_len[i]);
d567 1
a567 1
						OPENSSL_free(tmp_wNAF);
d577 1
a577 1
						OPENSSL_free(tmp_wNAF);
d584 1
a584 1
				OPENSSL_free(tmp_wNAF);
d592 1
a592 1
	val = OPENSSL_malloc((num_val + 1) * sizeof val[0]);
d719 1
a719 1
		OPENSSL_free(wsize);
d721 1
a721 1
		OPENSSL_free(wNAF_len);
d727 1
a727 1
			OPENSSL_free(*w);
d729 1
a729 1
		OPENSSL_free(wNAF);
d736 1
a736 1
		OPENSSL_free(val);
d740 1
a740 1
		OPENSSL_free(val_sub);
d828 1
a828 1
	points = OPENSSL_malloc(sizeof (EC_POINT*)*(num + 1));
d924 1
a924 1
		OPENSSL_free(points);
@


1.5
log
@resolve conflicts, fix local changes
@
text
@d172 1
d174 2
a175 1
		OPENSSL_cleanse(pre->points, sizeof pre->points);
d178 1
a178 1
	OPENSSL_cleanse(pre, sizeof pre);
@


1.4
log
@resolve conflicts
@
text
@d227 6
a241 6

	if (scalar->d == NULL || scalar->top == 0)
		{
		ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
		goto err;
		}
d422 1
a422 1
			pre_points_per_block = 1u << (pre_comp->w - 1);
d464 1
a464 1
		num_val += 1u << (wsize[i] - 1);
d603 1
a603 1
		for (j = 0; j < (1u << (wsize[i] - 1)); j++)
d639 1
a639 1
			for (j = 1; j < (1u << (wsize[i] - 1)); j++)
d823 1
a823 1
	pre_points_per_block = 1u << (w - 1);
@


1.3
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d2 3
d6 1
a6 1
 * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
d58 7
d71 99
a169 1
/* TODO: optional precomputation of multiples of the generator */
d171 8
a180 4
/*
 * wNAF-based interleaving multi-exponentation method
 * (<URL:http://www.informatik.tu-darmstadt.de/TI/Mitarbeiter/moeller.html#multiexp>)
 */
d183 1
a183 1
/* Determine the width-(w+1) Non-Adjacent Form (wNAF) of 'scalar'.
d187 3
a189 1
 * where at most one of any  w+1  consecutive digits is non-zero.
d191 1
a191 1
static signed char *compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len, BN_CTX *ctx)
d193 1
a193 1
	BIGNUM *c;
d200 13
a212 4
	BN_CTX_start(ctx);
	c = BN_CTX_get(ctx);
	if (c == NULL) goto err;
	
d222 1
a222 2
	if (!BN_copy(c, scalar)) goto err;
	if (c->neg)
a224 1
		c->neg = 0;
d227 9
a235 3
	len = BN_num_bits(c) + 1; /* wNAF may be one digit longer than binary representation */
	r = OPENSSL_malloc(len);
	if (r == NULL) goto err;
d237 6
d244 1
a244 1
	while (!BN_is_zero(c))
d246 3
a248 1
		int u = 0;
d250 1
a250 1
		if (BN_is_odd(c)) 
d252 3
a254 1
			if (c->d == NULL || c->top == 0)
d256 13
a268 2
				ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
				goto err;
d270 1
a270 2
			u = c->d[0] & mask;
			if (u & bit)
d272 1
a272 3
				u -= next_bit;
				/* u < 0 */
				if (!BN_add_word(c, -u)) goto err;
d274 2
a275 1
			else
d277 2
a278 2
				/* u > 0 */
				if (!BN_sub_word(c, u)) goto err;
d281 6
a286 1
			if (u <= -bit || u >= bit || !(u & 1) || c->neg)
d293 6
a298 3
		r[j++] = sign * u;
		
		if (BN_is_odd(c))
a302 1
		if (!BN_rshift1(c, c)) goto err;
d305 1
a305 1
	if (j > len)
a313 1
	BN_CTX_end(ctx);
d336 1
a336 1
		   1))
d344 1
a344 1
int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
d348 1
a348 1
	EC_POINT *generator = NULL;
d351 2
d364 4
a367 1
	EC_POINT ***val_sub = NULL; /* pointers to sub-arrays of 'val' */
d372 1
a372 1
		ECerr(EC_F_EC_POINTS_MUL, EC_R_INCOMPATIBLE_OBJECTS);
d381 16
d402 28
a429 2
			ECerr(EC_F_EC_POINTS_MUL, EC_R_UNDEFINED_GENERATOR);
			return 0;
d431 1
a431 5
		}
	
	for (i = 0; i < num; i++)
		{
		if (group->meth != points[i]->meth)
d433 4
a436 2
			ECerr(EC_F_EC_POINTS_MUL, EC_R_INCOMPATIBLE_OBJECTS);
			return 0;
d439 2
d442 1
a442 3
	totalnum = num + (scalar != NULL);

	wsize = OPENSSL_malloc(totalnum * sizeof wsize[0]);
d444 4
a447 2
	wNAF = OPENSSL_malloc((totalnum + 1) * sizeof wNAF[0]);
	if (wNAF != NULL)
d449 2
a450 1
		wNAF[0] = NULL; /* preliminary pivot */
a451 1
	if (wsize == NULL || wNAF_len == NULL || wNAF == NULL) goto err;
d453 3
a455 1
	/* num_val := total number of points to precompute */
d457 2
a458 1
	for (i = 0; i < totalnum; i++)
d465 6
d473 117
a589 2
	/* all precomputed points go into a single array 'val',
	 * 'val_sub[i]' is a pointer to the subarray for the i-th point */
d591 5
a595 1
	if (val == NULL) goto err;
a597 3
	val_sub = OPENSSL_malloc(totalnum * sizeof val_sub[0]);
	if (val_sub == NULL) goto err;

d600 1
a600 1
	for (i = 0; i < totalnum; i++)
d612 1
a612 1
		ECerr(EC_F_EC_POINTS_MUL, ERR_R_INTERNAL_ERROR);
d616 2
a617 9
	if (ctx == NULL)
		{
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			goto err;
		}
	
	tmp = EC_POINT_new(group);
	if (tmp == NULL) goto err;
d625 1
a625 1
	for (i = 0; i < totalnum; i++)
a643 6

		wNAF[i + 1] = NULL; /* make sure we always have a pivot */
		wNAF[i] = compute_wNAF((i < num ? scalars[i] : scalar), wsize[i], &wNAF_len[i], ctx);
		if (wNAF[i] == NULL) goto err;
		if (wNAF_len[i] > max_len)
			max_len = wNAF_len[i];
d647 2
a648 1
	if (!EC_POINTs_make_affine(group, num_val, val, ctx)) goto err;
d744 20
a763 13
int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar, const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
	{
	const EC_POINT *points[1];
	const BIGNUM *scalars[1];

	points[0] = point;
	scalars[0] = p_scalar;

	return EC_POINTs_mul(group, r, g_scalar, (point != NULL && p_scalar != NULL), points, scalars, ctx);
	}


int EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
d766 1
d769 3
d774 6
d783 2
a784 2
		ECerr(EC_F_EC_GROUP_PRECOMPUTE_MULT, EC_R_UNDEFINED_GENERATOR);
		return 0;
d791 1
a791 1
			return 0;
d798 1
a798 1
	if (!EC_GROUP_get_order(group, order, ctx)) return 0;
d801 1
a801 1
		ECerr(EC_F_EC_GROUP_PRECOMPUTE_MULT, EC_R_UNKNOWN_ORDER);
d805 102
a906 1
	/* TODO */
a908 1
	
d910 2
a911 1
	BN_CTX_end(ctx);
d914 14
d929 9
@


1.2
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d178 7
a184 6
		((b) >= 2000 ? 6 : \
		 (b) >=  800 ? 5 : \
		 (b) >=  300 ? 4 : \
		 (b) >=   70 ? 3 : \
		 (b) >=   20 ? 2 : \
		  1)
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d212 11
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@a211 11
	if (group->meth != r->meth)
		{
		ECerr(EC_F_EC_POINTS_MUL, EC_R_INCOMPATIBLE_OBJECTS);
		return 0;
		}

	if ((scalar == NULL) && (num == 0))
		{
		return EC_POINT_set_to_infinity(group, r);
		}

@


1.1.1.3
log
@import 0.9.7c
@
text
@d178 6
a183 7
		((size_t) \
		 ((b) >= 2000 ? 6 : \
		  (b) >=  800 ? 5 : \
		  (b) >=  300 ? 4 : \
		  (b) >=   70 ? 3 : \
		  (b) >=   20 ? 2 : \
		   1))
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@a1 3
/*
 * Originally written by Bodo Moeller and Nils Larsch for the OpenSSL project.
 */
d3 1
a3 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
a54 7
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * Portions of this software developed by SUN MICROSYSTEMS, INC.,
 * and contributed to the OpenSSL project.
 */

#include <string.h>
d61 1
a61 6
/*
 * This file implements the wNAF-based interleaving multi-exponentation method
 * (<URL:http://www.informatik.tu-darmstadt.de/TI/Mitarbeiter/moeller.html#multiexp>);
 * for multiplication with precomputation, we use wNAF splitting
 * (<URL:http://www.informatik.tu-darmstadt.de/TI/Mitarbeiter/moeller.html#fastexp>).
 */
d65 4
a68 101

/* structure for precomputed multiples of the generator */
typedef struct ec_pre_comp_st {
	const EC_GROUP *group; /* parent EC_GROUP object */
	size_t blocksize;      /* block size for wNAF splitting */
	size_t numblocks;      /* max. number of blocks for which we have precomputation */
	size_t w;              /* window size */
	EC_POINT **points;     /* array with pre-calculated multiples of generator:
	                        * 'num' pointers to EC_POINT objects followed by a NULL */
	size_t num;            /* numblocks * 2^(w-1) */
	int references;
} EC_PRE_COMP;
 
/* functions to manage EC_PRE_COMP within the EC_GROUP extra_data framework */
static void *ec_pre_comp_dup(void *);
static void ec_pre_comp_free(void *);
static void ec_pre_comp_clear_free(void *);

static EC_PRE_COMP *ec_pre_comp_new(const EC_GROUP *group)
	{
	EC_PRE_COMP *ret = NULL;

	if (!group)
		return NULL;

	ret = (EC_PRE_COMP *)OPENSSL_malloc(sizeof(EC_PRE_COMP));
	if (!ret)
		{
		ECerr(EC_F_EC_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
		return ret;
		}
	ret->group = group;
	ret->blocksize = 8; /* default */
	ret->numblocks = 0;
	ret->w = 4; /* default */
	ret->points = NULL;
	ret->num = 0;
	ret->references = 1;
	return ret;
	}

static void *ec_pre_comp_dup(void *src_)
	{
	EC_PRE_COMP *src = src_;

	/* no need to actually copy, these objects never change! */

	CRYPTO_add(&src->references, 1, CRYPTO_LOCK_EC_PRE_COMP);

	return src_;
	}

static void ec_pre_comp_free(void *pre_)
	{
	int i;
	EC_PRE_COMP *pre = pre_;

	if (!pre)
		return;

	i = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);
	if (i > 0)
		return;

	if (pre->points)
		{
		EC_POINT **p;

		for (p = pre->points; *p != NULL; p++)
			EC_POINT_free(*p);
		OPENSSL_free(pre->points);
		}
	OPENSSL_free(pre);
	}

static void ec_pre_comp_clear_free(void *pre_)
	{
	int i;
	EC_PRE_COMP *pre = pre_;

	if (!pre)
		return;

	i = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);
	if (i > 0)
		return;

	if (pre->points)
		{
		EC_POINT **p;

		for (p = pre->points; *p != NULL; p++)
			EC_POINT_clear_free(*p);
		OPENSSL_cleanse(pre->points, sizeof pre->points);
		OPENSSL_free(pre->points);
		}
	OPENSSL_cleanse(pre, sizeof pre);
	OPENSSL_free(pre);
	}


d71 1
a71 1
/* Determine the modified width-(w+1) Non-Adjacent Form (wNAF) of 'scalar'.
d75 1
a75 3
 * where at most one of any  w+1  consecutive digits is non-zero
 * with the exception that the most significant digit may be only
 * w-1 zeros away from that next non-zero digit.
d77 1
a77 1
static signed char *compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)
d79 1
a79 1
	int window_val;
d86 4
a89 13
	if (BN_is_zero(scalar))
		{
		r = OPENSSL_malloc(1);
		if (!r)
			{
			ECerr(EC_F_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);
			goto err;
			}
		r[0] = 0;
		*ret_len = 1;
		return r;
		}
		
d99 2
a100 1
	if (BN_is_negative(scalar))
d103 1
d106 3
a108 9
	len = BN_num_bits(scalar);
	r = OPENSSL_malloc(len + 1); /* modified wNAF may be one digit longer than binary representation
	                              * (*ret_len will be set to the actual length, i.e. at most
	                              * BN_num_bits(scalar) + 1) */
	if (r == NULL)
		{
		ECerr(EC_F_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);
		goto err;
		}
a109 6
	if (scalar->d == NULL || scalar->top == 0)
		{
		ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
		goto err;
		}
	window_val = scalar->d[0] & mask;
d111 1
a111 1
	while ((window_val != 0) || (j + w + 1 < len)) /* if j+w+1 >= len, window_val will not increase */
d113 1
a113 3
		int digit = 0;

		/* 0 <= window_val <= 2^(w+1) */
d115 1
a115 1
		if (window_val & 1)
d117 1
a117 3
			/* 0 < window_val < 2^(w+1) */

			if (window_val & bit)
d119 2
a120 13
				digit = window_val - next_bit; /* -2^w < digit < 0 */

#if 1 /* modified wNAF */
				if (j + w + 1 >= len)
					{
					/* special case for generating modified wNAFs:
					 * no new bits will be added into window_val,
					 * so using a positive digit here will decrease
					 * the total length of the representation */
					
					digit = window_val & (mask >> 1); /* 0 < digit < 2^w */
					}
#endif
d122 2
a123 1
			else
d125 3
a127 1
				digit = window_val; /* 0 < digit < 2^w */
d129 1
a129 2
			
			if (digit <= -bit || digit >= bit || !(digit & 1))
d131 2
a132 2
				ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
				goto err;
d135 1
a135 6
			window_val -= digit;

			/* now window_val is 0 or 2^(w+1) in standard wNAF generation;
			 * for modified window NAFs, it may also be 2^w
			 */
			if (window_val != 0 && window_val != next_bit && window_val != bit)
d142 3
a144 6
		r[j++] = sign * digit;

		window_val >>= 1;
		window_val += bit * BN_is_bit_set(scalar, j + w);

		if (window_val > next_bit)
d149 1
d152 1
a152 1
	if (j > len + 1)
d161 1
d184 1
a184 1
		  1))
d192 1
a192 1
int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
d196 1
a196 1
	const EC_POINT *generator = NULL;
a198 2
	size_t blocksize = 0, numblocks = 0; /* for wNAF splitting */
	size_t pre_points_per_block = 0;
d210 1
a210 4
	EC_POINT ***val_sub = NULL; /* pointers to sub-arrays of 'val' or 'pre_comp->points' */
	const EC_PRE_COMP *pre_comp = NULL;
	int num_scalar = 0; /* flag: will be set to 1 if 'scalar' must be treated like other scalars,
	                     * i.e. precomputation is not available */
d215 1
a215 1
		ECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);
d224 1
a224 1
	for (i = 0; i < num; i++)
d226 2
a227 1
		if (group->meth != points[i]->meth)
d229 1
a229 1
			ECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);
d233 2
a234 2

	if (ctx == NULL)
d236 1
a236 9
		ctx = new_ctx = BN_CTX_new();
		if (ctx == NULL)
			goto err;
		}

	if (scalar != NULL)
		{
		generator = EC_GROUP_get0_generator(group);
		if (generator == NULL)
d238 2
a239 2
			ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);
			goto err;
d241 1
a241 12
		
		/* look if we can use precomputed multiples of generator */

		pre_comp = EC_EX_DATA_get_data(group->extra_data, ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free);

		if (pre_comp && pre_comp->numblocks && (EC_POINT_cmp(group, generator, pre_comp->points[0], ctx) == 0))
			{
			blocksize = pre_comp->blocksize;

			/* determine maximum number of blocks that wNAF splitting may yield
			 * (NB: maximum wNAF length is bit length plus one) */
			numblocks = (BN_num_bits(scalar) / blocksize) + 1;
d243 1
a243 23
			/* we cannot use more blocks than we have precomputation for */
			if (numblocks > pre_comp->numblocks)
				numblocks = pre_comp->numblocks;

			pre_points_per_block = 1u << (pre_comp->w - 1);

			/* check that pre_comp looks sane */
			if (pre_comp->num != (pre_comp->numblocks * pre_points_per_block))
				{
				ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
				goto err;
				}
			}
		else
			{
			/* can't use precomputation */
			pre_comp = NULL;
			numblocks = 1;
			num_scalar = 1; /* treat 'scalar' like 'num'-th element of 'scalars' */
			}
		}
	
	totalnum = num + numblocks;
d245 1
a245 1
	wsize    = OPENSSL_malloc(totalnum * sizeof wsize[0]);
d247 2
a248 4
	wNAF     = OPENSSL_malloc((totalnum + 1) * sizeof wNAF[0]); /* includes space for pivot */
	val_sub  = OPENSSL_malloc(totalnum * sizeof val_sub[0]);
		 
	if (!wsize || !wNAF_len || !wNAF || !val_sub)
d250 1
a250 2
		ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
		goto err;
d252 1
d254 1
a254 3
	wNAF[0] = NULL;	/* preliminary pivot */

	/* num_val will be the total number of temporarily precomputed points */
d256 1
a256 2

	for (i = 0; i < num + num_scalar; i++)
a262 6
		wNAF[i + 1] = NULL; /* make sure we always have a pivot */
		wNAF[i] = compute_wNAF((i < num ? scalars[i] : scalar), wsize[i], &wNAF_len[i]);
		if (wNAF[i] == NULL)
			goto err;
		if (wNAF_len[i] > max_len)
			max_len = wNAF_len[i];
d265 2
a266 117
	if (numblocks)
		{
		/* we go here iff scalar != NULL */
		
		if (pre_comp == NULL)
			{
			if (num_scalar != 1)
				{
				ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
				goto err;
				}
			/* we have already generated a wNAF for 'scalar' */
			}
		else
			{
			signed char *tmp_wNAF = NULL;
			size_t tmp_len = 0;
			
			if (num_scalar != 0)
				{
				ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
				goto err;
				}

			/* use the window size for which we have precomputation */
			wsize[num] = pre_comp->w;
			tmp_wNAF = compute_wNAF(scalar, wsize[num], &tmp_len);
			if (!tmp_wNAF)
				goto err;

			if (tmp_len <= max_len)
				{
				/* One of the other wNAFs is at least as long
				 * as the wNAF belonging to the generator,
				 * so wNAF splitting will not buy us anything. */

				numblocks = 1;
				totalnum = num + 1; /* don't use wNAF splitting */
				wNAF[num] = tmp_wNAF;
				wNAF[num + 1] = NULL;
				wNAF_len[num] = tmp_len;
				if (tmp_len > max_len)
					max_len = tmp_len;
				/* pre_comp->points starts with the points that we need here: */
				val_sub[num] = pre_comp->points;
				}
			else
				{
				/* don't include tmp_wNAF directly into wNAF array
				 * - use wNAF splitting and include the blocks */

				signed char *pp;
				EC_POINT **tmp_points;
				
				if (tmp_len < numblocks * blocksize)
					{
					/* possibly we can do with fewer blocks than estimated */
					numblocks = (tmp_len + blocksize - 1) / blocksize;
					if (numblocks > pre_comp->numblocks)
						{
						ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
						goto err;
						}
					totalnum = num + numblocks;
					}
				
				/* split wNAF in 'numblocks' parts */
				pp = tmp_wNAF;
				tmp_points = pre_comp->points;

				for (i = num; i < totalnum; i++)
					{
					if (i < totalnum - 1)
						{
						wNAF_len[i] = blocksize;
						if (tmp_len < blocksize)
							{
							ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
							goto err;
							}
						tmp_len -= blocksize;
						}
					else
						/* last block gets whatever is left
						 * (this could be more or less than 'blocksize'!) */
						wNAF_len[i] = tmp_len;
					
					wNAF[i + 1] = NULL;
					wNAF[i] = OPENSSL_malloc(wNAF_len[i]);
					if (wNAF[i] == NULL)
						{
						ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
						OPENSSL_free(tmp_wNAF);
						goto err;
						}
					memcpy(wNAF[i], pp, wNAF_len[i]);
					if (wNAF_len[i] > max_len)
						max_len = wNAF_len[i];

					if (*tmp_points == NULL)
						{
						ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
						OPENSSL_free(tmp_wNAF);
						goto err;
						}
					val_sub[i] = tmp_points;
					tmp_points += pre_points_per_block;
					pp += blocksize;
					}
				OPENSSL_free(tmp_wNAF);
				}
			}
		}

	/* All points we precompute now go into a single array 'val'.
	 * 'val_sub[i]' is a pointer to the subarray for the i-th point,
	 * or to a subarray of 'pre_comp->points' if we already have precomputation. */
d268 1
a268 5
	if (val == NULL)
		{
		ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
		goto err;
		}
d271 3
d276 1
a276 1
	for (i = 0; i < num + num_scalar; i++)
d288 1
a288 1
		ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
d292 9
a300 2
	if (!(tmp = EC_POINT_new(group)))
		goto err;
d308 1
a308 1
	for (i = 0; i < num + num_scalar; i++)
d327 6
d336 1
a336 2
	if (!EC_POINTs_make_affine(group, num_val, val, ctx))
		goto err;
d432 13
a444 20
/* ec_wNAF_precompute_mult()
 * creates an EC_PRE_COMP object with preprecomputed multiples of the generator
 * for use with wNAF splitting as implemented in ec_wNAF_mul().
 * 
 * 'pre_comp->points' is an array of multiples of the generator
 * of the following form:
 * points[0] =     generator;
 * points[1] = 3 * generator;
 * ...
 * points[2^(w-1)-1] =     (2^(w-1)-1) * generator;
 * points[2^(w-1)]   =     2^blocksize * generator;
 * points[2^(w-1)+1] = 3 * 2^blocksize * generator;
 * ...
 * points[2^(w-1)*(numblocks-1)-1] = (2^(w-1)) *  2^(blocksize*(numblocks-2)) * generator
 * points[2^(w-1)*(numblocks-1)]   =              2^(blocksize*(numblocks-1)) * generator
 * ...
 * points[2^(w-1)*numblocks-1]     = (2^(w-1)) *  2^(blocksize*(numblocks-1)) * generator
 * points[2^(w-1)*numblocks]       = NULL
 */
int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
a446 1
	EC_POINT *tmp_point = NULL, *base = NULL, **var;
a448 3
	size_t i, bits, w, pre_points_per_block, blocksize, numblocks, num;
	EC_POINT **points = NULL;
	EC_PRE_COMP *pre_comp;
a450 6
	/* if there is an old EC_PRE_COMP object, throw it away */
	EC_EX_DATA_free_data(&group->extra_data, ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free);

	if ((pre_comp = ec_pre_comp_new(group)) == NULL)
		return 0;

d454 2
a455 2
		ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNDEFINED_GENERATOR);
		goto err;
d462 1
a462 1
			goto err;
d469 1
a469 1
	if (!EC_GROUP_get_order(group, order, ctx)) goto err;		
d472 1
a472 1
		ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNKNOWN_ORDER);
d476 1
a476 15
	bits = BN_num_bits(order);
	/* The following parameters mean we precompute (approximately)
	 * one point per bit.
	 *
	 * TBD: The combination  8, 4  is perfect for 160 bits; for other
	 * bit lengths, other parameter combinations might provide better
	 * efficiency.
	 */
	blocksize = 8;
	w = 4;
	if (EC_window_bits_for_scalar_size(bits) > w)
		{
		/* let's not make the window too small ... */
		w = EC_window_bits_for_scalar_size(bits);
		}
d478 1
a478 1
	numblocks = (bits + blocksize - 1) / blocksize; /* max. number of blocks to use for wNAF splitting */
a479 86
	pre_points_per_block = 1u << (w - 1);
	num = pre_points_per_block * numblocks; /* number of points to compute and store */

	points = OPENSSL_malloc(sizeof (EC_POINT*)*(num + 1));
	if (!points)
		{
		ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);
		goto err;
		}

	var = points;
	var[num] = NULL; /* pivot */
	for (i = 0; i < num; i++)
		{
		if ((var[i] = EC_POINT_new(group)) == NULL)
			{
			ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);
			goto err;
			}
		}

	if (!(tmp_point = EC_POINT_new(group)) || !(base = EC_POINT_new(group)))
		{
		ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);
		goto err;
		}	
	
	if (!EC_POINT_copy(base, generator))
		goto err;
	
	/* do the precomputation */
	for (i = 0; i < numblocks; i++)
		{
		size_t j;

		if (!EC_POINT_dbl(group, tmp_point, base, ctx))
			goto err;

		if (!EC_POINT_copy(*var++, base))
			goto err;

		for (j = 1; j < pre_points_per_block; j++, var++)
			{
			/* calculate odd multiples of the current base point */
			if (!EC_POINT_add(group, *var, tmp_point, *(var - 1), ctx))
				goto err;
			}

		if (i < numblocks - 1)
			{
			/* get the next base (multiply current one by 2^blocksize) */
			size_t k;

			if (blocksize <= 2)
				{
				ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_INTERNAL_ERROR);
				goto err;
				}				

			if (!EC_POINT_dbl(group, base, tmp_point, ctx))
				goto err;
			for (k = 2; k < blocksize; k++)
				{
				if (!EC_POINT_dbl(group,base,base,ctx))
					goto err;
				}
			}
 		}

	if (!EC_POINTs_make_affine(group, num, points, ctx))
		goto err;
	
	pre_comp->group = group;
	pre_comp->blocksize = blocksize;
	pre_comp->numblocks = numblocks;
	pre_comp->w = w;
	pre_comp->points = points;
	points = NULL;
	pre_comp->num = num;

	if (!EC_EX_DATA_set_data(&group->extra_data, pre_comp,
		ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free))
		goto err;
	pre_comp = NULL;

	ret = 1;
d481 1
a481 2
	if (ctx != NULL)
		BN_CTX_end(ctx);
a483 14
	if (pre_comp)
		ec_pre_comp_free(pre_comp);
	if (points)
		{
		EC_POINT **p;

		for (p = points; *p != NULL; p++)
			EC_POINT_free(*p);
		OPENSSL_free(points);
		}
	if (tmp_point)
		EC_POINT_free(tmp_point);
	if (base)
		EC_POINT_free(base);
a484 9
	}


int ec_wNAF_have_precompute_mult(const EC_GROUP *group)
	{
	if (EC_EX_DATA_get_data(group->extra_data, ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free) != NULL)
		return 1;
	else
		return 0;
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@a226 6
	if (scalar->d == NULL || scalar->top == 0)
		{
		ECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
		goto err;
		}

d236 6
d422 1
a422 1
			pre_points_per_block = (size_t)1 << (pre_comp->w - 1);
d464 1
a464 1
		num_val += (size_t)1 << (wsize[i] - 1);
d603 1
a603 1
		for (j = 0; j < ((size_t)1 << (wsize[i] - 1)); j++)
d639 1
a639 1
			for (j = 1; j < ((size_t)1 << (wsize[i] - 1)); j++)
d823 1
a823 1
	pre_points_per_block = (size_t)1 << (w - 1);
@


1.1.1.6
log
@import OpenSSL 1.0.0e
@
text
@a171 1
			{
d173 1
a173 2
			OPENSSL_cleanse(p, sizeof *p);
			}
d176 1
a176 1
	OPENSSL_cleanse(pre, sizeof *pre);
@


