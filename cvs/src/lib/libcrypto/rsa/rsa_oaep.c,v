head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26;
locks; strict;
comment	@ * @;


1.26
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.25;
commitid	kT0fLt3r4lroFJra;

1.25
date	2015.06.20.12.01.14;	author jsing;	state Exp;
branches;
next	1.24;
commitid	f0RvWCt8nx38ad6r;

1.24
date	2014.10.22.13.02.04;	author jsing;	state Exp;
branches;
next	1.23;
commitid	PjnBgKe6Buhbf937;

1.23
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.22;
commitid	yQEL1wOWIearrW15;

1.22
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.21;
commitid	nzndm3zqPmFurSaK;

1.21
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.20;
commitid	id8dTrTMtnTn4fqt;

1.20
date	2014.07.10.11.25.13;	author tedu;	state Exp;
branches;
next	1.19;
commitid	Pv7aSK7aYL3NQSpP;

1.19
date	2014.07.09.19.51.38;	author jsing;	state Exp;
branches;
next	1.18;
commitid	1XPBWlejiS4drgFK;

1.18
date	2014.07.09.17.08.40;	author miod;	state Exp;
branches;
next	1.17;
commitid	qZG3CIJOb00YDN3u;

1.17
date	2014.07.09.08.20.08;	author miod;	state Exp;
branches;
next	1.16;
commitid	JPwi7kYvSgWTaIWo;

1.16
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	mJUVYpkFBZ0Zv2bG;

1.15
date	2014.05.30.06.24.17;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2013.02.14.15.11.43;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.09.12.15.52;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.09;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.11.40;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.43;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.53;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.06.27.05.05.35;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.13.59;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.10;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2011.11.03.02.32.14;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.10.13.21.23.43;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: rsa_oaep.c,v 1.25 2015/06/20 12:01:14 jsing Exp $ */
/* Written by Ulf Moeller. This software is distributed on an "AS IS"
   basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. */

/* EME-OAEP as defined in RFC 2437 (PKCS #1 v2.0) */

/* See Victor Shoup, "OAEP reconsidered," Nov. 2000,
 * <URL: http://www.shoup.net/papers/oaep.ps.Z>
 * for problems with the security proof for the
 * original OAEP scheme, which EME-OAEP is based on.
 *
 * A new proof can be found in E. Fujisaki, T. Okamoto,
 * D. Pointcheval, J. Stern, "RSA-OEAP is Still Alive!",
 * Dec. 2000, <URL: http://eprint.iacr.org/2000/061/>.
 * The new proof has stronger requirements for the
 * underlying permutation: "partial-one-wayness" instead
 * of one-wayness.  For the RSA function, this is
 * an equivalent notion.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/opensslconf.h>

#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)

#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/rsa.h>
#include <openssl/sha.h>

static int MGF1(unsigned char *mask, long len, const unsigned char *seed,
    long seedlen);

int
RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,
    const unsigned char *from, int flen, const unsigned char *param, int plen)
{
	int i, emlen = tlen - 1;
	unsigned char *db, *seed;
	unsigned char *dbmask, seedmask[SHA_DIGEST_LENGTH];

	if (flen > emlen - 2 * SHA_DIGEST_LENGTH - 1) {
		RSAerror(RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
		return 0;
	}

	if (emlen < 2 * SHA_DIGEST_LENGTH + 1) {
		RSAerror(RSA_R_KEY_SIZE_TOO_SMALL);
		return 0;
	}

	to[0] = 0;
	seed = to + 1;
	db = to + SHA_DIGEST_LENGTH + 1;

	if (!EVP_Digest((void *)param, plen, db, NULL, EVP_sha1(), NULL))
		return 0;
	memset(db + SHA_DIGEST_LENGTH, 0,
	    emlen - flen - 2 * SHA_DIGEST_LENGTH - 1);
	db[emlen - flen - SHA_DIGEST_LENGTH - 1] = 0x01;
	memcpy(db + emlen - flen - SHA_DIGEST_LENGTH, from, flen);
	arc4random_buf(seed, SHA_DIGEST_LENGTH);

	dbmask = malloc(emlen - SHA_DIGEST_LENGTH);
	if (dbmask == NULL) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		return 0;
	}

	if (MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed,
	    SHA_DIGEST_LENGTH) < 0)
		return 0;
	for (i = 0; i < emlen - SHA_DIGEST_LENGTH; i++)
		db[i] ^= dbmask[i];

	if (MGF1(seedmask, SHA_DIGEST_LENGTH, db,
	    emlen - SHA_DIGEST_LENGTH) < 0)
		return 0;
	for (i = 0; i < SHA_DIGEST_LENGTH; i++)
		seed[i] ^= seedmask[i];

	free(dbmask);
	return 1;
}

int
RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,
    const unsigned char *from, int flen, int num, const unsigned char *param,
    int plen)
{
	int i, dblen, mlen = -1;
	const unsigned char *maskeddb;
	int lzero;
	unsigned char *db = NULL;
	unsigned char seed[SHA_DIGEST_LENGTH], phash[SHA_DIGEST_LENGTH];
	unsigned char *padded_from;
	int bad = 0;

	if (--num < 2 * SHA_DIGEST_LENGTH + 1)
		/*
		 * 'num' is the length of the modulus, i.e. does not depend
		 * on the particular ciphertext.
		 */
		goto decoding_err;

	lzero = num - flen;
	if (lzero < 0) {
		/*
		 * signalling this error immediately after detection might allow
		 * for side-channel attacks (e.g. timing if 'plen' is huge
		 * -- cf. James H. Manger, "A Chosen Ciphertext Attack on RSA
		 * Optimal Asymmetric Encryption Padding (OAEP) [...]",
		 * CRYPTO 2001), so we use a 'bad' flag
		 */
		bad = 1;
		lzero = 0;
		flen = num; /* don't overflow the memcpy to padded_from */
	}

	dblen = num - SHA_DIGEST_LENGTH;
	db = malloc(dblen + num);
	if (db == NULL) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		return -1;
	}

	/*
	 * Always do this zero-padding copy (even when lzero == 0)
	 * to avoid leaking timing info about the value of lzero.
	 */
	padded_from = db + dblen;
	memset(padded_from, 0, lzero);
	memcpy(padded_from + lzero, from, flen);

	maskeddb = padded_from + SHA_DIGEST_LENGTH;

	if (MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen))
		return -1;
	for (i = 0; i < SHA_DIGEST_LENGTH; i++)
		seed[i] ^= padded_from[i];

	if (MGF1(db, dblen, seed, SHA_DIGEST_LENGTH))
		return -1;
	for (i = 0; i < dblen; i++)
		db[i] ^= maskeddb[i];

	if (!EVP_Digest((void *)param, plen, phash, NULL, EVP_sha1(), NULL))
		return -1;

	if (timingsafe_memcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)
		goto decoding_err;
	else {
		for (i = SHA_DIGEST_LENGTH; i < dblen; i++)
			if (db[i] != 0x00)
				break;
		if (i == dblen || db[i] != 0x01)
			goto decoding_err;
		else {
			/* everything looks OK */

			mlen = dblen - ++i;
			if (tlen < mlen) {
				RSAerror(RSA_R_DATA_TOO_LARGE);
				mlen = -1;
			} else
				memcpy(to, db + i, mlen);
		}
	}
	free(db);
	return mlen;

decoding_err:
	/*
	 * To avoid chosen ciphertext attacks, the error message should not
	 * reveal which kind of decoding error happened
	 */
	RSAerror(RSA_R_OAEP_DECODING_ERROR);
	free(db);
	return -1;
}

int
PKCS1_MGF1(unsigned char *mask, long len, const unsigned char *seed,
    long seedlen, const EVP_MD *dgst)
{
	long i, outlen = 0;
	unsigned char cnt[4];
	EVP_MD_CTX c;
	unsigned char md[EVP_MAX_MD_SIZE];
	int mdlen;
	int rv = -1;

	EVP_MD_CTX_init(&c);
	mdlen = EVP_MD_size(dgst);
	if (mdlen < 0)
		goto err;
	for (i = 0; outlen < len; i++) {
		cnt[0] = (unsigned char)((i >> 24) & 255);
		cnt[1] = (unsigned char)((i >> 16) & 255);
		cnt[2] = (unsigned char)((i >> 8)) & 255;
		cnt[3] = (unsigned char)(i & 255);
		if (!EVP_DigestInit_ex(&c, dgst, NULL) ||
		    !EVP_DigestUpdate(&c, seed, seedlen) ||
		    !EVP_DigestUpdate(&c, cnt, 4))
			goto err;
		if (outlen + mdlen <= len) {
			if (!EVP_DigestFinal_ex(&c, mask + outlen, NULL))
				goto err;
			outlen += mdlen;
		} else {
			if (!EVP_DigestFinal_ex(&c, md, NULL))
				goto err;
			memcpy(mask + outlen, md, len - outlen);
			outlen = len;
		}
	}
	rv = 0;
err:
	EVP_MD_CTX_cleanup(&c);
	return rv;
}

static int
MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)
{
	return PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());
}
#endif
@


1.25
log
@Replace remaining CRYPTO_memcmp() calls with timingsafe_memcmp().

ok doug@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_oaep.c,v 1.24 2014/10/22 13:02:04 jsing Exp $ */
d47 1
a47 2
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP,
		    RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
d52 1
a52 2
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP,
		    RSA_R_KEY_SIZE_TOO_SMALL);
d70 1
a70 1
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
d127 1
a127 2
		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP,
		    ERR_R_MALLOC_FAILURE);
d167 1
a167 2
				RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP,
				    RSA_R_DATA_TOO_LARGE);
d181 1
a181 1
	RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);
@


1.24
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_oaep.c,v 1.23 2014/07/11 08:44:49 jsing Exp $ */
d157 1
a157 1
	if (CRYPTO_memcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)
@


1.23
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_oaep.c,v 1.22 2014/07/10 22:45:57 jsing Exp $ */
d22 1
a31 1
#include <openssl/rand.h>
d68 1
a68 2
	if (RAND_bytes(seed, SHA_DIGEST_LENGTH) <= 0)
		return 0;
@


1.22
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_oaep.c,v 1.21 2014/07/10 13:58:23 jsing Exp $ */
d27 1
a27 1
#include "cryptlib.h"
d29 1
a29 1
#include <openssl/rsa.h>
d32 1
@


1.21
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_oaep.c,v 1.20 2014/07/10 11:25:13 tedu Exp $ */
d23 2
@


1.20
log
@delete some casts. ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_oaep.c,v 1.19 2014/07/09 19:51:38 jsing Exp $ */
d21 2
a24 1
#include <stdio.h>
@


1.19
log
@More KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_oaep.c,v 1.18 2014/07/09 17:08:40 miod Exp $ */
d63 1
a63 1
	memcpy(db + emlen - flen - SHA_DIGEST_LENGTH, from, (unsigned int)flen);
@


1.18
log
@Unifdef -UPKCS_TESTVECT - we don't want the random data used in OAEP padding
to get overwritten by a known value, ever.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_oaep.c,v 1.17 2014/07/09 08:20:08 miod Exp $ */
d11 1
a11 1
 * 
d32 1
a32 1
	    long seedlen);
d145 1
a145 1
  
d207 1
a207 1
		if (!EVP_DigestInit_ex(&c,dgst, NULL) ||
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_oaep.c,v 1.16 2014/06/12 15:49:30 deraadt Exp $ */
a65 5
#ifdef PKCS_TESTVECT
	memcpy(seed,
	   "\xaa\xfd\x12\xf6\x59\xca\xe6\x34\x89\xb4\x79\xe5\x07\x6d\xde\xc2\xf0\x6c\xb5\x8f",
	   20);
#endif
@


1.16
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d31 2
a32 2
static int MGF1(unsigned char *mask, long len,
	const unsigned char *seed, long seedlen);
d34 4
a37 4
int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,
	const unsigned char *from, int flen,
	const unsigned char *param, int plen)
	{
d42 1
a42 2
	if (flen > emlen - 2 * SHA_DIGEST_LENGTH - 1)
		{
d44 1
a44 1
		   RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
d46 1
a46 1
		}
d48 3
a50 3
	if (emlen < 2 * SHA_DIGEST_LENGTH + 1)
		{
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_KEY_SIZE_TOO_SMALL);
d52 1
a52 1
		}
d61 1
a61 1
		emlen - flen - 2 * SHA_DIGEST_LENGTH - 1);
d63 1
a63 1
	memcpy(db + emlen - flen - SHA_DIGEST_LENGTH, from, (unsigned int) flen);
d73 1
a73 2
	if (dbmask == NULL)
		{
d76 1
a76 1
		}
d78 2
a79 1
	if (MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH) < 0)
d84 2
a85 1
	if (MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH) < 0)
d92 1
a92 1
	}
d94 5
a98 4
int RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,
	const unsigned char *from, int flen, int num,
	const unsigned char *param, int plen)
	{
d102 2
a103 1
	unsigned char *db = NULL, seed[SHA_DIGEST_LENGTH], phash[SHA_DIGEST_LENGTH];
d108 4
a111 2
		/* 'num' is the length of the modulus, i.e. does not depend on the
		 * particular ciphertext. */
d115 3
a117 3
	if (lzero < 0)
		{
		/* signalling this error immediately after detection might allow
d119 4
a122 3
		 * -- cf. James H. Manger, "A Chosen Ciphertext Attack on RSA Optimal
		 * Asymmetric Encryption Padding (OAEP) [...]", CRYPTO 2001),
		 * so we use a 'bad' flag */
d126 1
a126 1
		}
d130 3
a132 3
	if (db == NULL)
		{
		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
d134 1
a134 1
		}
d136 4
a139 2
	/* Always do this zero-padding copy (even when lzero == 0)
	 * to avoid leaking timing info about the value of lzero. */
d161 1
a161 2
	else
		{
d167 1
a167 2
		else
			{
d171 3
a173 3
			if (tlen < mlen)
				{
				RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_DATA_TOO_LARGE);
d175 1
a175 2
				}
			else
a176 1
			}
d178 1
d183 4
a186 2
	/* to avoid chosen ciphertext attacks, the error message should not reveal
	 * which kind of decoding error happened */
d190 1
a190 1
	}
d192 4
a195 3
int PKCS1_MGF1(unsigned char *mask, long len,
	const unsigned char *seed, long seedlen, const EVP_MD *dgst)
	{
d207 1
a207 2
	for (i = 0; outlen < len; i++)
		{
d212 3
a214 3
		if (!EVP_DigestInit_ex(&c,dgst, NULL)
			|| !EVP_DigestUpdate(&c, seed, seedlen)
			|| !EVP_DigestUpdate(&c, cnt, 4))
d216 1
a216 2
		if (outlen + mdlen <= len)
			{
d220 1
a220 3
			}
		else
			{
a224 1
			}
d226 1
d228 1
a228 1
	err:
d231 1
a231 1
	}
d233 3
a235 3
static int MGF1(unsigned char *mask, long len, const unsigned char *seed,
		 long seedlen)
	{
d237 1
a237 1
	}
@


1.15
log
@more: no need to null check before free; ok guenther
@
text
@d1 1
a1 1
/* crypto/rsa/rsa_oaep.c */
@


1.14
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d182 1
a182 1
	if (db != NULL) free(db);
@


1.13
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d73 1
a73 1
	dbmask = OPENSSL_malloc(emlen - SHA_DIGEST_LENGTH);
d90 1
a90 1
	OPENSSL_free(dbmask);
d124 1
a124 1
	db = OPENSSL_malloc(dblen + num);
d175 1
a175 1
	OPENSSL_free(db);
d182 1
a182 1
	if (db != NULL) OPENSSL_free(db);
@


1.12
log
@cherry pick bugfixes for http://www.openssl.org/news/secadv_20130205.txt
from the openssl git (changes between openssl 1.0.1c and 1.0.1d).
ok djm@@
@
text
@d152 1
a152 1
	if (timingsafe_bcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)
@


1.11
log
@resolve conflicts
@
text
@d152 1
a152 1
	if (memcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)
@


1.10
log
@openssl-1.0.0e: resolve conflicts
@
text
@d59 2
a60 1
	EVP_Digest((void *)param, plen, db, NULL, EVP_sha1(), NULL);
d149 2
a150 1
	EVP_Digest((void *)param, plen, phash, NULL, EVP_sha1(), NULL);
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d192 1
d197 1
a197 1
		return -1;
d204 4
a207 3
		EVP_DigestInit_ex(&c,dgst, NULL);
		EVP_DigestUpdate(&c, seed, seedlen);
		EVP_DigestUpdate(&c, cnt, 4);
d210 2
a211 1
			EVP_DigestFinal_ex(&c, mask + outlen, NULL);
d216 2
a217 1
			EVP_DigestFinal_ex(&c, md, NULL);
d222 2
d225 1
a225 1
	return 0;
@


1.8
log
@resolve conflicts
@
text
@d31 1
a31 1
int MGF1(unsigned char *mask, long len,
a54 7
	dbmask = OPENSSL_malloc(emlen - SHA_DIGEST_LENGTH);
	if (dbmask == NULL)
		{
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
		return 0;
		}

d72 9
a80 1
	MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH);
d84 2
a85 1
	MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH);
d138 2
a139 1
	MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen);
d143 2
a144 1
	MGF1(db, dblen, seed, SHA_DIGEST_LENGTH);
d194 3
a196 1
	mdlen = M_EVP_MD_size(dgst);
d222 2
a223 1
int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)
@


1.7
log
@resolve conflicts
@
text
@d190 1
a190 1
	mdlen = EVP_MD_size(dgst);
@


1.6
log
@resolve conflicts
@
text
@d31 3
d79 1
a79 2
	PKCS1_MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH,
								EVP_sha1());
d83 1
a83 2
	PKCS1_MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH,
								EVP_sha1());
d99 1
a109 2
		/* lzero == -1 */

d117 1
a118 1
	maskeddb = from - lzero + SHA_DIGEST_LENGTH;
d121 1
a121 1
	db = OPENSSL_malloc(dblen);
d124 1
a124 1
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
d128 11
a138 3
	PKCS1_MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen, EVP_sha1());
	for (i = lzero; i < SHA_DIGEST_LENGTH; i++)
		seed[i] ^= from[i - lzero];
d140 1
a140 1
	PKCS1_MGF1(db, dblen, seed, SHA_DIGEST_LENGTH, EVP_sha1());
d153 1
a153 1
		if (db[i] != 0x01 || i++ >= dblen)
d159 1
a159 1
			mlen = dblen - i;
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a30 3
int MGF1(unsigned char *mask, long len,
	const unsigned char *seed, long seedlen);

d76 2
a77 1
	MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH);
d81 2
a82 1
	MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH);
d128 1
a128 1
	MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen);
d132 1
a132 1
	MGF1(db, dblen, seed, SHA_DIGEST_LENGTH);
d172 2
a173 2
int MGF1(unsigned char *mask, long len,
	const unsigned char *seed, long seedlen)
d178 2
a179 1
	unsigned char md[SHA_DIGEST_LENGTH];
d182 1
d189 1
a189 1
		EVP_DigestInit_ex(&c,EVP_sha1(), NULL);
d192 1
a192 1
		if (outlen + SHA_DIGEST_LENGTH <= len)
d195 1
a195 1
			outlen += SHA_DIGEST_LENGTH;
d206 5
@


1.4
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d5 1
a5 1
/* EME_OAEP as defined in RFC 2437 (PKCS #1 v2.0) */
d7 16
a22 1
#if !defined(NO_SHA) && !defined(NO_SHA1)
d27 2
a29 1
#include <openssl/rand.h>
d31 2
a32 1
int MGF1(unsigned char *mask, long len, unsigned char *seed, long seedlen);
d35 6
a40 5
	     unsigned char *from, int flen, unsigned char *param, int plen)
    {
    int i, emlen = tlen - 1;
    unsigned char *db, *seed;
    unsigned char *dbmask, seedmask[SHA_DIGEST_LENGTH];
d42 12
a53 6
    if (flen > emlen - 2 * SHA_DIGEST_LENGTH - 1)
	{
	RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP,
	       RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
	return (0);
	}
d55 6
a60 12
    if (emlen < 2 * SHA_DIGEST_LENGTH + 1)
	{
	RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_KEY_SIZE_TOO_SMALL);
	return (0);
	}
    
    dbmask = OPENSSL_malloc(emlen - SHA_DIGEST_LENGTH);
    if (dbmask == NULL)
	{
	RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
	return (0);
	}
d62 11
a72 11
    to[0] = 0;
    seed = to + 1;
    db = to + SHA_DIGEST_LENGTH + 1;

    SHA1(param, plen, db);
    memset(db + SHA_DIGEST_LENGTH, 0,
	   emlen - flen - 2 * SHA_DIGEST_LENGTH - 1);
    db[emlen - flen - SHA_DIGEST_LENGTH - 1] = 0x01;
    memcpy(db + emlen - flen - SHA_DIGEST_LENGTH, from, (unsigned int) flen);
    if (RAND_bytes(seed, SHA_DIGEST_LENGTH) <= 0)
    	return (0);
d74 1
a74 1
    memcpy(seed,
d79 11
a89 11
    MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH);
    for (i = 0; i < emlen - SHA_DIGEST_LENGTH; i++)
	db[i] ^= dbmask[i];

    MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH);
    for (i = 0; i < SHA_DIGEST_LENGTH; i++)
	seed[i] ^= seedmask[i];

    OPENSSL_free(dbmask);
    return (1);
    }
d92 2
a93 19
	     unsigned char *from, int flen, int num, unsigned char *param,
	     int plen)
    {
    int i, dblen, mlen = -1;
    unsigned char *maskeddb;
    int lzero;
    unsigned char *db = NULL, seed[SHA_DIGEST_LENGTH], phash[SHA_DIGEST_LENGTH];

    if (--num < 2 * SHA_DIGEST_LENGTH + 1)
	goto decoding_err;

    lzero = num - flen;
    if (lzero < 0)
	goto decoding_err;
    maskeddb = from - lzero + SHA_DIGEST_LENGTH;
    
    dblen = num - SHA_DIGEST_LENGTH;
    db = OPENSSL_malloc(dblen);
    if (db == NULL)
d95 33
a127 3
	RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
	return (-1);
	}
d129 3
a131 3
    MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen);
    for (i = lzero; i < SHA_DIGEST_LENGTH; i++)
	seed[i] ^= from[i - lzero];
d133 8
a140 15
    MGF1(db, dblen, seed, SHA_DIGEST_LENGTH);
    for (i = 0; i < dblen; i++)
	db[i] ^= maskeddb[i];

    SHA1(param, plen, phash);

    if (memcmp(db, phash, SHA_DIGEST_LENGTH) != 0)
	goto decoding_err;
    else
	{
	for (i = SHA_DIGEST_LENGTH; i < dblen; i++)
	    if (db[i] != 0x00)
		break;
	if (db[i] != 0x01 || i++ >= dblen)
	  goto decoding_err;
d142 22
a163 13
	    {
	    mlen = dblen - i;
	    if (tlen < mlen)
		{
		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_DATA_TOO_LARGE);
		mlen = -1;
		}
	    else
		memcpy(to, db + i, mlen);
	    }
	}
    OPENSSL_free(db);
    return (mlen);
d166 14
a179 13
    /* to avoid chosen ciphertext attacks, the error message should not reveal
     * which kind of decoding error happened */
    RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);
    if (db != NULL) OPENSSL_free(db);
    return -1;
    }

int MGF1(unsigned char *mask, long len, unsigned char *seed, long seedlen)
    {
    long i, outlen = 0;
    unsigned char cnt[4];
    SHA_CTX c;
    unsigned char md[SHA_DIGEST_LENGTH];
d181 24
a204 18
    for (i = 0; outlen < len; i++)
	{
	cnt[0] = (i >> 24) & 255, cnt[1] = (i >> 16) & 255,
	  cnt[2] = (i >> 8) & 255, cnt[3] = i & 255;
	SHA1_Init(&c);
	SHA1_Update(&c, seed, seedlen);
	SHA1_Update(&c, cnt, 4);
	if (outlen + SHA_DIGEST_LENGTH <= len)
	    {
	    SHA1_Final(mask + outlen, &c);
	    outlen += SHA_DIGEST_LENGTH;
	    }
	else
	    {
	    SHA1_Final(md, &c);
	    memcpy(mask + outlen, md, len - outlen);
	    outlen = len;
	    }
a205 2
    return (0);
    }
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d80 1
a80 1
    unsigned char *db, seed[SHA_DIGEST_LENGTH], phash[SHA_DIGEST_LENGTH];
d83 1
a83 4
	{
	RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);
	return (-1);
	}
d85 5
a97 3
    lzero = num - flen;
    maskeddb = from - lzero + SHA_DIGEST_LENGTH;
    
d109 1
a109 1
	RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);
d116 1
a116 2
	    RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP,
		   RSA_R_OAEP_DECODING_ERROR);
d122 1
a122 1
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_DATA_TOO_LARGE);
d131 7
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d37 1
a37 1
    dbmask = Malloc(emlen - SHA_DIGEST_LENGTH);
d69 1
a69 1
    Free(dbmask);
d89 1
a89 1
    db = Malloc(dblen);
d131 1
a131 1
    Free(db);
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d53 2
a54 1
    RAND_bytes(seed, SHA_DIGEST_LENGTH);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d5 1
a5 1
/* EME-OAEP as defined in RFC 2437 (PKCS #1 v2.0) */
d7 1
a7 16
/* See Victor Shoup, "OAEP reconsidered," Nov. 2000,
 * <URL: http://www.shoup.net/papers/oaep.ps.Z>
 * for problems with the security proof for the
 * original OAEP scheme, which EME-OAEP is based on.
 * 
 * A new proof can be found in E. Fujisaki, T. Okamoto,
 * D. Pointcheval, J. Stern, "RSA-OEAP is Still Alive!",
 * Dec. 2000, <URL: http://eprint.iacr.org/2000/061/>.
 * The new proof has stronger requirements for the
 * underlying permutation: "partial-one-wayness" instead
 * of one-wayness.  For the RSA function, this is
 * an equivalent notion.
 */


#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
d12 1
a12 1
#include <openssl/evp.h>
a13 1
#include <openssl/sha.h>
d15 1
a15 2
int MGF1(unsigned char *mask, long len,
	const unsigned char *seed, long seedlen);
d18 7
a24 2
	const unsigned char *from, int flen,
	const unsigned char *param, int plen)
d26 4
a29 3
	int i, emlen = tlen - 1;
	unsigned char *db, *seed;
	unsigned char *dbmask, seedmask[SHA_DIGEST_LENGTH];
d31 12
a42 19
	if (flen > emlen - 2 * SHA_DIGEST_LENGTH - 1)
		{
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP,
		   RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
		return 0;
		}

	if (emlen < 2 * SHA_DIGEST_LENGTH + 1)
		{
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_KEY_SIZE_TOO_SMALL);
		return 0;
		}

	dbmask = OPENSSL_malloc(emlen - SHA_DIGEST_LENGTH);
	if (dbmask == NULL)
		{
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
		return 0;
		}
d44 10
a53 11
	to[0] = 0;
	seed = to + 1;
	db = to + SHA_DIGEST_LENGTH + 1;

	EVP_Digest((void *)param, plen, db, NULL, EVP_sha1(), NULL);
	memset(db + SHA_DIGEST_LENGTH, 0,
		emlen - flen - 2 * SHA_DIGEST_LENGTH - 1);
	db[emlen - flen - SHA_DIGEST_LENGTH - 1] = 0x01;
	memcpy(db + emlen - flen - SHA_DIGEST_LENGTH, from, (unsigned int) flen);
	if (RAND_bytes(seed, SHA_DIGEST_LENGTH) <= 0)
		return 0;
d55 1
a55 1
	memcpy(seed,
d60 11
a70 7
	MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH);
	for (i = 0; i < emlen - SHA_DIGEST_LENGTH; i++)
		db[i] ^= dbmask[i];

	MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH);
	for (i = 0; i < SHA_DIGEST_LENGTH; i++)
		seed[i] ^= seedmask[i];
d72 13
a84 2
	OPENSSL_free(dbmask);
	return 1;
d87 3
a89 3
int RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,
	const unsigned char *from, int flen, int num,
	const unsigned char *param, int plen)
d91 3
a93 33
	int i, dblen, mlen = -1;
	const unsigned char *maskeddb;
	int lzero;
	unsigned char *db = NULL, seed[SHA_DIGEST_LENGTH], phash[SHA_DIGEST_LENGTH];
	int bad = 0;

	if (--num < 2 * SHA_DIGEST_LENGTH + 1)
		/* 'num' is the length of the modulus, i.e. does not depend on the
		 * particular ciphertext. */
		goto decoding_err;

	lzero = num - flen;
	if (lzero < 0)
		{
		/* lzero == -1 */

		/* signalling this error immediately after detection might allow
		 * for side-channel attacks (e.g. timing if 'plen' is huge
		 * -- cf. James H. Manger, "A Chosen Ciphertext Attack on RSA Optimal
		 * Asymmetric Encryption Padding (OAEP) [...]", CRYPTO 2001),
		 * so we use a 'bad' flag */
		bad = 1;
		lzero = 0;
		}
	maskeddb = from - lzero + SHA_DIGEST_LENGTH;

	dblen = num - SHA_DIGEST_LENGTH;
	db = OPENSSL_malloc(dblen);
	if (db == NULL)
		{
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
		return -1;
		}
d95 6
a100 3
	MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen);
	for (i = lzero; i < SHA_DIGEST_LENGTH; i++)
		seed[i] ^= from[i - lzero];
d102 3
a104 3
	MGF1(db, dblen, seed, SHA_DIGEST_LENGTH);
	for (i = 0; i < dblen; i++)
		db[i] ^= maskeddb[i];
d106 1
a106 1
	EVP_Digest((void *)param, plen, phash, NULL, EVP_sha1(), NULL);
d108 10
a117 2
	if (memcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)
		goto decoding_err;
d119 10
a128 29
		{
		for (i = SHA_DIGEST_LENGTH; i < dblen; i++)
			if (db[i] != 0x00)
				break;
		if (db[i] != 0x01 || i++ >= dblen)
			goto decoding_err;
		else
			{
			/* everything looks OK */

			mlen = dblen - i;
			if (tlen < mlen)
				{
				RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_DATA_TOO_LARGE);
				mlen = -1;
				}
			else
				memcpy(to, db + i, mlen);
			}
		}
	OPENSSL_free(db);
	return mlen;

decoding_err:
	/* to avoid chosen ciphertext attacks, the error message should not reveal
	 * which kind of decoding error happened */
	RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);
	if (db != NULL) OPENSSL_free(db);
	return -1;
d130 10
d141 1
a141 2
int MGF1(unsigned char *mask, long len,
	const unsigned char *seed, long seedlen)
d143 16
a158 29
	long i, outlen = 0;
	unsigned char cnt[4];
	EVP_MD_CTX c;
	unsigned char md[SHA_DIGEST_LENGTH];

	EVP_MD_CTX_init(&c);
	for (i = 0; outlen < len; i++)
		{
		cnt[0] = (unsigned char)((i >> 24) & 255);
		cnt[1] = (unsigned char)((i >> 16) & 255);
		cnt[2] = (unsigned char)((i >> 8)) & 255;
		cnt[3] = (unsigned char)(i & 255);
		EVP_DigestInit_ex(&c,EVP_sha1(), NULL);
		EVP_DigestUpdate(&c, seed, seedlen);
		EVP_DigestUpdate(&c, cnt, 4);
		if (outlen + SHA_DIGEST_LENGTH <= len)
			{
			EVP_DigestFinal_ex(&c, mask + outlen, NULL);
			outlen += SHA_DIGEST_LENGTH;
			}
		else
			{
			EVP_DigestFinal_ex(&c, md, NULL);
			memcpy(mask + outlen, md, len - outlen);
			outlen = len;
			}
		}
	EVP_MD_CTX_cleanup(&c);
	return 0;
d160 2
@


1.1.1.2
log
@import of openssl-0.9.7j
@
text
@d31 3
d79 1
a79 2
	PKCS1_MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH,
								EVP_sha1());
d83 1
a83 2
	PKCS1_MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH,
								EVP_sha1());
d129 1
a129 1
	PKCS1_MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen, EVP_sha1());
d133 1
a133 1
	PKCS1_MGF1(db, dblen, seed, SHA_DIGEST_LENGTH, EVP_sha1());
d173 2
a174 2
int PKCS1_MGF1(unsigned char *mask, long len,
	const unsigned char *seed, long seedlen, const EVP_MD *dgst)
d179 1
a179 2
	unsigned char md[EVP_MAX_MD_SIZE];
	int mdlen;
a181 1
	mdlen = EVP_MD_size(dgst);
d188 1
a188 1
		EVP_DigestInit_ex(&c,dgst, NULL);
d191 1
a191 1
		if (outlen + mdlen <= len)
d194 1
a194 1
			outlen += mdlen;
a204 5
	}

int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)
	{
	return PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@a30 3
int MGF1(unsigned char *mask, long len,
	const unsigned char *seed, long seedlen);

d76 2
a77 1
	MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH);
d81 2
a82 1
	MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH);
a97 1
	unsigned char *padded_from;
d108 2
a116 1
		flen = num; /* don't overflow the memcpy to padded_from */
d118 1
d121 1
a121 1
	db = OPENSSL_malloc(dblen + num);
d124 1
a124 1
		RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
d128 3
a130 11
	/* Always do this zero-padding copy (even when lzero == 0)
	 * to avoid leaking timing info about the value of lzero. */
	padded_from = db + dblen;
	memset(padded_from, 0, lzero);
	memcpy(padded_from + lzero, from, flen);

	maskeddb = padded_from + SHA_DIGEST_LENGTH;

	MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen);
	for (i = 0; i < SHA_DIGEST_LENGTH; i++)
		seed[i] ^= padded_from[i];
d132 1
a132 1
	MGF1(db, dblen, seed, SHA_DIGEST_LENGTH);
d145 1
a145 1
		if (i == dblen || db[i] != 0x01)
d151 1
a151 1
			mlen = dblen - ++i;
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d190 1
a190 1
	mdlen = M_EVP_MD_size(dgst);
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d31 1
a31 1
static int MGF1(unsigned char *mask, long len,
d55 7
d79 1
a79 9
	dbmask = OPENSSL_malloc(emlen - SHA_DIGEST_LENGTH);
	if (dbmask == NULL)
		{
		RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);
		return 0;
		}

	if (MGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH) < 0)
		return 0;
d83 1
a83 2
	if (MGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH) < 0)
		return 0;
d136 1
a136 2
	if (MGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen))
		return -1;
d140 1
a140 2
	if (MGF1(db, dblen, seed, SHA_DIGEST_LENGTH))
		return -1;
d190 1
a190 3
	mdlen = EVP_MD_size(dgst);
	if (mdlen < 0)
		return -1;
d216 1
a216 2
static int MGF1(unsigned char *mask, long len, const unsigned char *seed,
		 long seedlen)
@


1.1.1.6
log
@import OpenSSL 1.0.0e
@
text
@a191 1
	int rv = -1;
d196 1
a196 1
		goto err;
d203 3
a205 4
		if (!EVP_DigestInit_ex(&c,dgst, NULL)
			|| !EVP_DigestUpdate(&c, seed, seedlen)
			|| !EVP_DigestUpdate(&c, cnt, 4))
			goto err;
d208 1
a208 2
			if (!EVP_DigestFinal_ex(&c, mask + outlen, NULL))
				goto err;
d213 1
a213 2
			if (!EVP_DigestFinal_ex(&c, md, NULL))
				goto err;
a217 2
	rv = 0;
	err:
d219 1
a219 1
	return rv;
@


1.1.1.7
log
@import OpenSSL-1.0.1c
@
text
@d59 1
a59 2
	if (!EVP_Digest((void *)param, plen, db, NULL, EVP_sha1(), NULL))
		return 0;
d148 1
a148 2
	if (!EVP_Digest((void *)param, plen, phash, NULL, EVP_sha1(), NULL))
		return -1;
@


1.1.1.8
log
@Import OpenSSL 1.0.1g
@
text
@d152 1
a152 1
	if (CRYPTO_memcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)
@


