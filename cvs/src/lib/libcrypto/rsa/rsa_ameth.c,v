head	1.18;
access;
symbols
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18;
locks; strict;
comment	@ * @;


1.18
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.17;
commitid	kT0fLt3r4lroFJra;

1.17
date	2016.12.30.15.47.07;	author jsing;	state Exp;
branches;
next	1.16;
commitid	gZAJJOIbPZAkKtNw;

1.16
date	2016.10.19.16.49.11;	author jsing;	state Exp;
branches;
next	1.15;
commitid	jPDvHFzYCLsD7MQG;

1.15
date	2015.12.03.23.03.10;	author beck;	state Exp;
branches;
next	1.14;
commitid	XEQub5s6Jurttym0;

1.14
date	2015.02.11.04.05.14;	author beck;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;
commitid	BiQ5VBK0FHpjQNna;

1.13
date	2015.02.11.03.55.42;	author beck;	state Exp;
branches;
next	1.12;
commitid	1omCojArcEf3nCrU;

1.12
date	2014.07.11.12.59.10;	author miod;	state Exp;
branches;
next	1.11;
commitid	Go785HpH6LyO6JB7;

1.11
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.10;
commitid	yQEL1wOWIearrW15;

1.10
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.9;
commitid	nzndm3zqPmFurSaK;

1.9
date	2014.07.09.22.55.17;	author tedu;	state Exp;
branches;
next	1.8;
commitid	5JdGfnLK1lLuGWd1;

1.8
date	2014.07.09.19.51.38;	author jsing;	state Exp;
branches;
next	1.7;
commitid	1XPBWlejiS4drgFK;

1.7
date	2014.07.09.08.20.08;	author miod;	state Exp;
branches;
next	1.6;
commitid	JPwi7kYvSgWTaIWo;

1.6
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	mJUVYpkFBZ0Zv2bG;

1.5
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	2nvnQBrv22dLtvTt;

1.4
date	2014.05.30.06.24.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.27.20.26.49;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.01.22.54.10;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.10.01.22.54.10;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2012.10.13.21.23.43;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;

1.14.4.1
date	2015.12.04.04.15.53;	author beck;	state Exp;
branches;
next	;
commitid	FrWUOw7Vphn3bAdz;

1.14.6.1
date	2015.12.04.04.13.43;	author beck;	state Exp;
branches;
next	;
commitid	zeOq9uRAQQlG7MHf;


desc
@@


1.18
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: rsa_ameth.c,v 1.17 2016/12/30 15:47:07 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2006.
 */
/* ====================================================================
 * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>

#include <openssl/opensslconf.h>

#include <openssl/asn1t.h>
#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/rsa.h>
#include <openssl/x509.h>


#include "asn1_locl.h"

static int
rsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
{
	unsigned char *penc = NULL;
	int penclen;

	penclen = i2d_RSAPublicKey(pkey->pkey.rsa, &penc);
	if (penclen <= 0)
		return 0;
	if (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(EVP_PKEY_RSA),
	    V_ASN1_NULL, NULL, penc, penclen))
		return 1;

	free(penc);
	return 0;
}

static int
rsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)
{
	const unsigned char *p;
	int pklen;
	RSA *rsa = NULL;

	if (!X509_PUBKEY_get0_param(NULL, &p, &pklen, NULL, pubkey))
		return 0;
	if (!(rsa = d2i_RSAPublicKey(NULL, &p, pklen))) {
		RSAerror(ERR_R_RSA_LIB);
		return 0;
	}
	EVP_PKEY_assign_RSA (pkey, rsa);
	return 1;
}

static int
rsa_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
{
	if (BN_cmp(b->pkey.rsa->n, a->pkey.rsa->n) != 0 ||
	    BN_cmp(b->pkey.rsa->e, a->pkey.rsa->e) != 0)
		return 0;
	return 1;
}

static int
old_rsa_priv_decode(EVP_PKEY *pkey, const unsigned char **pder, int derlen)
{
	RSA *rsa;

	if (!(rsa = d2i_RSAPrivateKey (NULL, pder, derlen))) {
		RSAerror(ERR_R_RSA_LIB);
		return 0;
	}
	EVP_PKEY_assign_RSA(pkey, rsa);
	return 1;
}

static int
old_rsa_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)
{
	return i2d_RSAPrivateKey(pkey->pkey.rsa, pder);
}

static int
rsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
{
	unsigned char *rk = NULL;
	int rklen;

	rklen = i2d_RSAPrivateKey(pkey->pkey.rsa, &rk);

	if (rklen <= 0) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		return 0;
	}

	if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_rsaEncryption), 0,
	    V_ASN1_NULL, NULL, rk, rklen)) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		return 0;
	}

	return 1;
}

static int
rsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)
{
	const unsigned char *p;
	int pklen;

	if (!PKCS8_pkey_get0(NULL, &p, &pklen, NULL, p8))
		return 0;
	return old_rsa_priv_decode(pkey, &p, pklen);
}

static int
int_rsa_size(const EVP_PKEY *pkey)
{
	return RSA_size(pkey->pkey.rsa);
}

static int
rsa_bits(const EVP_PKEY *pkey)
{
	return BN_num_bits(pkey->pkey.rsa->n);
}

static void
int_rsa_free(EVP_PKEY *pkey)
{
	RSA_free(pkey->pkey.rsa);
}

static void
update_buflen(const BIGNUM *b, size_t *pbuflen)
{
	size_t i;

	if (!b)
		return;
	if (*pbuflen < (i = (size_t)BN_num_bytes(b)))
		*pbuflen = i;
}

static int
do_rsa_print(BIO *bp, const RSA *x, int off, int priv)
{
	char *str;
	const char *s;
	unsigned char *m = NULL;
	int ret = 0, mod_len = 0;
	size_t buf_len = 0;

	update_buflen(x->n, &buf_len);
	update_buflen(x->e, &buf_len);

	if (priv) {
		update_buflen(x->d, &buf_len);
		update_buflen(x->p, &buf_len);
		update_buflen(x->q, &buf_len);
		update_buflen(x->dmp1, &buf_len);
		update_buflen(x->dmq1, &buf_len);
		update_buflen(x->iqmp, &buf_len);
	}

	m = malloc(buf_len + 10);
	if (m == NULL) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (x->n != NULL)
		mod_len = BN_num_bits(x->n);

	if (!BIO_indent(bp, off, 128))
		goto err;

	if (priv && x->d) {
		if (BIO_printf(bp, "Private-Key: (%d bit)\n", mod_len) <= 0)
			goto err;
		str = "modulus:";
		s = "publicExponent:";
	} else {
		if (BIO_printf(bp, "Public-Key: (%d bit)\n", mod_len) <= 0)
			goto err;
		str = "Modulus:";
		s= "Exponent:";
	}
	if (!ASN1_bn_print(bp, str, x->n, m, off))
		goto err;
	if (!ASN1_bn_print(bp, s, x->e, m, off))
		goto err;
	if (priv) {
		if (!ASN1_bn_print(bp, "privateExponent:", x->d,m, off))
			goto err;
		if (!ASN1_bn_print(bp, "prime1:", x->p, m, off))
			goto err;
		if (!ASN1_bn_print(bp, "prime2:", x->q, m, off))
			goto err;
		if (!ASN1_bn_print(bp, "exponent1:", x->dmp1, m, off))
			goto err;
		if (!ASN1_bn_print(bp, "exponent2:", x->dmq1, m, off))
			goto err;
		if (!ASN1_bn_print(bp, "coefficient:", x->iqmp, m, off))
			goto err;
	}
	ret = 1;
err:
	free(m);
	return (ret);
}

static int
rsa_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent, ASN1_PCTX *ctx)
{
	return do_rsa_print(bp, pkey->pkey.rsa, indent, 0);
}

static int
rsa_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent, ASN1_PCTX *ctx)
{
	return do_rsa_print(bp, pkey->pkey.rsa, indent, 1);
}

static RSA_PSS_PARAMS *
rsa_pss_decode(const X509_ALGOR *alg, X509_ALGOR **pmaskHash)
{
	const unsigned char *p;
	int plen;
	RSA_PSS_PARAMS *pss;

	*pmaskHash = NULL;

	if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
		return NULL;

	p = alg->parameter->value.sequence->data;
	plen = alg->parameter->value.sequence->length;
	pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

	if (!pss)
		return NULL;

	if (pss->maskGenAlgorithm) {
		ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
		if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1 &&
		    param && param->type == V_ASN1_SEQUENCE) {
			p = param->value.sequence->data;
			plen = param->value.sequence->length;
			*pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
		}
	}

	return pss;
}

static int
rsa_pss_param_print(BIO *bp, RSA_PSS_PARAMS *pss, X509_ALGOR *maskHash,
    int indent)
{
	int rv = 0;

	if (!pss) {
		if (BIO_puts(bp, " (INVALID PSS PARAMETERS)\n") <= 0)
			return 0;
		return 1;
	}
	if (BIO_puts(bp, "\n") <= 0)
		goto err;
	if (!BIO_indent(bp, indent, 128))
		goto err;
	if (BIO_puts(bp, "Hash Algorithm: ") <= 0)
		goto err;

	if (pss->hashAlgorithm) {
		if (i2a_ASN1_OBJECT(bp, pss->hashAlgorithm->algorithm) <= 0)
			goto err;
	} else if (BIO_puts(bp, "sha1 (default)") <= 0)
		goto err;

	if (BIO_puts(bp, "\n") <= 0)
		goto err;

	if (!BIO_indent(bp, indent, 128))
		goto err;

	if (BIO_puts(bp, "Mask Algorithm: ") <= 0)
		goto err;
	if (pss->maskGenAlgorithm) {
		if (i2a_ASN1_OBJECT(bp, pss->maskGenAlgorithm->algorithm) <= 0)
			goto err;
		if (BIO_puts(bp, " with ") <= 0)
			goto err;
		if (maskHash) {
			if (i2a_ASN1_OBJECT(bp, maskHash->algorithm) <= 0)
				goto err;
		} else if (BIO_puts(bp, "INVALID") <= 0)
			goto err;
	} else if (BIO_puts(bp, "mgf1 with sha1 (default)") <= 0)
		goto err;
	BIO_puts(bp, "\n");

	if (!BIO_indent(bp, indent, 128))
		goto err;
	if (BIO_puts(bp, "Salt Length: 0x") <= 0)
		goto err;
	if (pss->saltLength) {
		if (i2a_ASN1_INTEGER(bp, pss->saltLength) <= 0)
			goto err;
	} else if (BIO_puts(bp, "14 (default)") <= 0)
		goto err;
	BIO_puts(bp, "\n");

	if (!BIO_indent(bp, indent, 128))
		goto err;
	if (BIO_puts(bp, "Trailer Field: 0x") <= 0)
		goto err;
	if (pss->trailerField) {
		if (i2a_ASN1_INTEGER(bp, pss->trailerField) <= 0)
			goto err;
	} else if (BIO_puts(bp, "BC (default)") <= 0)
		goto err;
	BIO_puts(bp, "\n");

	rv = 1;

err:
	return rv;
}

static int
rsa_sig_print(BIO *bp, const X509_ALGOR *sigalg, const ASN1_STRING *sig,
    int indent, ASN1_PCTX *pctx)
{
	if (OBJ_obj2nid(sigalg->algorithm) == NID_rsassaPss) {
		int rv;
		RSA_PSS_PARAMS *pss;
		X509_ALGOR *maskHash;
		pss = rsa_pss_decode(sigalg, &maskHash);
		rv = rsa_pss_param_print(bp, pss, maskHash, indent);
		if (pss)
			RSA_PSS_PARAMS_free(pss);
		if (maskHash)
			X509_ALGOR_free(maskHash);
		if (!rv)
			return 0;
	} else if (!sig && BIO_puts(bp, "\n") <= 0)
		return 0;
	if (sig)
		return X509_signature_dump(bp, sig, indent);
	return 1;
}

static int
rsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
{
	X509_ALGOR *alg = NULL;

	switch (op) {
	case ASN1_PKEY_CTRL_PKCS7_SIGN:
		if (arg1 == 0)
			PKCS7_SIGNER_INFO_get0_algs(arg2, NULL, NULL, &alg);
		break;

	case ASN1_PKEY_CTRL_PKCS7_ENCRYPT:
		if (arg1 == 0)
			PKCS7_RECIP_INFO_get0_alg(arg2, &alg);
		break;

	case ASN1_PKEY_CTRL_DEFAULT_MD_NID:
		*(int *)arg2 = NID_sha1;
		return 1;

	default:
		return -2;
	}

	if (alg)
		X509_ALGOR_set0(alg, OBJ_nid2obj(NID_rsaEncryption),
		    V_ASN1_NULL, 0);

	return 1;
}

/* Customised RSA item verification routine. This is called
 * when a signature is encountered requiring special handling. We
 * currently only handle PSS.
 */
static int
rsa_item_verify(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,
    X509_ALGOR *sigalg, ASN1_BIT_STRING *sig, EVP_PKEY *pkey)
{
	int rv = -1;
	int saltlen;
	const EVP_MD *mgf1md = NULL, *md = NULL;
	RSA_PSS_PARAMS *pss;
	X509_ALGOR *maskHash;
	EVP_PKEY_CTX *pkctx;

	/* Sanity check: make sure it is PSS */
	if (OBJ_obj2nid(sigalg->algorithm) != NID_rsassaPss) {
		RSAerror(RSA_R_UNSUPPORTED_SIGNATURE_TYPE);
		return -1;
	}

	/* Decode PSS parameters */
	pss = rsa_pss_decode(sigalg, &maskHash);

	if (pss == NULL) {
		RSAerror(RSA_R_INVALID_PSS_PARAMETERS);
		goto err;
	}
	/* Check mask and lookup mask hash algorithm */
	if (pss->maskGenAlgorithm) {
		if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) != NID_mgf1) {
			RSAerror(RSA_R_UNSUPPORTED_MASK_ALGORITHM);
			goto err;
		}
		if (!maskHash) {
			RSAerror(RSA_R_UNSUPPORTED_MASK_PARAMETER);
			goto err;
		}
		mgf1md = EVP_get_digestbyobj(maskHash->algorithm);
		if (mgf1md == NULL) {
			RSAerror(RSA_R_UNKNOWN_MASK_DIGEST);
			goto err;
		}
	} else
		mgf1md = EVP_sha1();

	if (pss->hashAlgorithm) {
		md = EVP_get_digestbyobj(pss->hashAlgorithm->algorithm);
		if (md == NULL) {
			RSAerror(RSA_R_UNKNOWN_PSS_DIGEST);
			goto err;
		}
	} else
		md = EVP_sha1();

	if (pss->saltLength) {
		saltlen = ASN1_INTEGER_get(pss->saltLength);

		/* Could perform more salt length sanity checks but the main
		 * RSA routines will trap other invalid values anyway.
		 */
		if (saltlen < 0) {
			RSAerror(RSA_R_INVALID_SALT_LENGTH);
			goto err;
		}
	} else
		saltlen = 20;

	/* low-level routines support only trailer field 0xbc (value 1)
	 * and PKCS#1 says we should reject any other value anyway.
	 */
	if (pss->trailerField && ASN1_INTEGER_get(pss->trailerField) != 1) {
		RSAerror(RSA_R_INVALID_TRAILER);
		goto err;
	}

	/* We have all parameters now set up context */

	if (!EVP_DigestVerifyInit(ctx, &pkctx, md, NULL, pkey))
		goto err;

	if (EVP_PKEY_CTX_set_rsa_padding(pkctx, RSA_PKCS1_PSS_PADDING) <= 0)
		goto err;

	if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, saltlen) <= 0)
		goto err;

	if (EVP_PKEY_CTX_set_rsa_mgf1_md(pkctx, mgf1md) <= 0)
		goto err;
	/* Carry on */
	rv = 2;

err:
	RSA_PSS_PARAMS_free(pss);
	if (maskHash)
		X509_ALGOR_free(maskHash);
	return rv;
}

static int
rsa_item_sign(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,
    X509_ALGOR *alg1, X509_ALGOR *alg2, ASN1_BIT_STRING *sig)
{
	int pad_mode;
	EVP_PKEY_CTX *pkctx = ctx->pctx;

	if (EVP_PKEY_CTX_get_rsa_padding(pkctx, &pad_mode) <= 0)
		return 0;
	if (pad_mode == RSA_PKCS1_PADDING)
		return 2;
	if (pad_mode == RSA_PKCS1_PSS_PADDING) {
		const EVP_MD *sigmd, *mgf1md;
		RSA_PSS_PARAMS *pss = NULL;
		X509_ALGOR *mgf1alg = NULL;
		ASN1_STRING *os1 = NULL, *os2 = NULL;
		EVP_PKEY *pk = EVP_PKEY_CTX_get0_pkey(pkctx);
		int saltlen, rv = 0;

		sigmd = EVP_MD_CTX_md(ctx);
		if (EVP_PKEY_CTX_get_rsa_mgf1_md(pkctx, &mgf1md) <= 0)
			goto err;
		if (!EVP_PKEY_CTX_get_rsa_pss_saltlen(pkctx, &saltlen))
			goto err;
		if (saltlen == -1)
			saltlen = EVP_MD_size(sigmd);
		else if (saltlen == -2) {
			saltlen = EVP_PKEY_size(pk) - EVP_MD_size(sigmd) - 2;
			if (((EVP_PKEY_bits(pk) - 1) & 0x7) == 0)
				saltlen--;
		}
		pss = RSA_PSS_PARAMS_new();
		if (!pss)
			goto err;
		if (saltlen != 20) {
			pss->saltLength = ASN1_INTEGER_new();
			if (!pss->saltLength)
				goto err;
			if (!ASN1_INTEGER_set(pss->saltLength, saltlen))
				goto err;
		}
		if (EVP_MD_type(sigmd) != NID_sha1) {
			pss->hashAlgorithm = X509_ALGOR_new();
			if (!pss->hashAlgorithm)
				goto err;
			X509_ALGOR_set_md(pss->hashAlgorithm, sigmd);
		}
		if (EVP_MD_type(mgf1md) != NID_sha1) {
			ASN1_STRING *stmp = NULL;
			/* need to embed algorithm ID inside another */
			mgf1alg = X509_ALGOR_new();
			X509_ALGOR_set_md(mgf1alg, mgf1md);
			if (!ASN1_item_pack(mgf1alg, &X509_ALGOR_it,
			    &stmp))
				goto err;
			pss->maskGenAlgorithm = X509_ALGOR_new();
			if (!pss->maskGenAlgorithm)
				goto err;
			X509_ALGOR_set0(pss->maskGenAlgorithm,
			    OBJ_nid2obj(NID_mgf1), V_ASN1_SEQUENCE, stmp);
		}
		/* Finally create string with pss parameter encoding. */
		if (!ASN1_item_pack(pss, &RSA_PSS_PARAMS_it, &os1))
			goto err;
		if (alg2) {
			os2 = ASN1_STRING_dup(os1);
			if (!os2)
				goto err;
			X509_ALGOR_set0(alg2, OBJ_nid2obj(NID_rsassaPss),
			    V_ASN1_SEQUENCE, os2);
		}
		X509_ALGOR_set0(alg1, OBJ_nid2obj(NID_rsassaPss),
		    V_ASN1_SEQUENCE, os1);
		os1 = os2 = NULL;
		rv = 3;
err:
		if (mgf1alg)
			X509_ALGOR_free(mgf1alg);
		if (pss)
			RSA_PSS_PARAMS_free(pss);
		ASN1_STRING_free(os1);
		return rv;
	}
	return 2;
}

const EVP_PKEY_ASN1_METHOD rsa_asn1_meths[] = {
	{
		.pkey_id = EVP_PKEY_RSA,
		.pkey_base_id = EVP_PKEY_RSA,
		.pkey_flags = ASN1_PKEY_SIGPARAM_NULL,

		.pem_str = "RSA",
		.info = "OpenSSL RSA method",

		.pub_decode = rsa_pub_decode,
		.pub_encode = rsa_pub_encode,
		.pub_cmp = rsa_pub_cmp,
		.pub_print = rsa_pub_print,

		.priv_decode = rsa_priv_decode,
		.priv_encode = rsa_priv_encode,
		.priv_print = rsa_priv_print,

		.pkey_size = int_rsa_size,
		.pkey_bits = rsa_bits,

		.sig_print = rsa_sig_print,

		.pkey_free = int_rsa_free,
		.pkey_ctrl = rsa_pkey_ctrl,
		.old_priv_decode = old_rsa_priv_decode,
		.old_priv_encode = old_rsa_priv_encode,
		.item_verify = rsa_item_verify,
		.item_sign = rsa_item_sign
	},

	{
		.pkey_id = EVP_PKEY_RSA2,
		.pkey_base_id = EVP_PKEY_RSA,
		.pkey_flags = ASN1_PKEY_ALIAS
	}
};
@


1.17
log
@Expand ASN1_ITEM_rptr macros - no change in generated assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.16 2016/10/19 16:49:11 jsing Exp $ */
d99 1
a99 1
		RSAerr(RSA_F_RSA_PUB_DECODE, ERR_R_RSA_LIB);
d121 1
a121 1
		RSAerr(RSA_F_OLD_RSA_PRIV_DECODE, ERR_R_RSA_LIB);
d143 1
a143 1
		RSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
d149 1
a149 1
		RSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
d219 1
a219 1
		RSAerr(RSA_F_DO_RSA_PRINT, ERR_R_MALLOC_FAILURE);
d453 1
a453 1
		RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNSUPPORTED_SIGNATURE_TYPE);
d461 1
a461 1
		RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_INVALID_PSS_PARAMETERS);
d467 1
a467 2
			RSAerr(RSA_F_RSA_ITEM_VERIFY,
			    RSA_R_UNSUPPORTED_MASK_ALGORITHM);
d471 1
a471 2
			RSAerr(RSA_F_RSA_ITEM_VERIFY,
			    RSA_R_UNSUPPORTED_MASK_PARAMETER);
d476 1
a476 2
			RSAerr(RSA_F_RSA_ITEM_VERIFY,
			    RSA_R_UNKNOWN_MASK_DIGEST);
d485 1
a485 1
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNKNOWN_PSS_DIGEST);
d498 1
a498 2
			RSAerr(RSA_F_RSA_ITEM_VERIFY,
			    RSA_R_INVALID_SALT_LENGTH);
d508 1
a508 1
		RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_INVALID_TRAILER);
@


1.16
log
@unifdef OPENSSL_NO_CMS
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.15 2015/12/03 23:03:10 beck Exp $ */
d591 1
a591 1
			if (!ASN1_item_pack(mgf1alg, ASN1_ITEM_rptr(X509_ALGOR),
d601 1
a601 1
		if (!ASN1_item_pack(pss, ASN1_ITEM_rptr(RSA_PSS_PARAMS), &os1))
@


1.15
log
@Fix for OpenSSL CVE-2015-3194
ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.14 2015/02/11 04:05:14 beck Exp $ */
a68 3
#ifndef OPENSSL_NO_CMS
#include <openssl/cms.h>
#endif
a419 11
#ifndef OPENSSL_NO_CMS
	case ASN1_PKEY_CTRL_CMS_SIGN:
		if (arg1 == 0)
			CMS_SignerInfo_get0_algs(arg2, NULL, NULL, NULL, &alg);
		break;

	case ASN1_PKEY_CTRL_CMS_ENVELOPE:
		if (arg1 == 0)
			CMS_RecipientInfo_ktri_get0_algs(arg2, NULL, NULL, &alg);
		break;
#endif
@


1.14
log
@Guenther has plans for OPENSSL_NO_CMS, so revert this for the moment.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.13 2015/02/11 03:55:42 beck Exp $ */
d301 1
a301 1
		    param->type == V_ASN1_SEQUENCE) {
@


1.14.4.1
log
@patch for OpenSSL CVE-2015-3194
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.14 2015/02/11 04:05:14 beck Exp $ */
d301 1
a301 1
		    param && param->type == V_ASN1_SEQUENCE) {
@


1.14.6.1
log
@patch for OpenSSL CVE-2015-3194
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.14 2015/02/11 04:05:14 beck Exp $ */
d301 1
a301 1
		    param && param->type == V_ASN1_SEQUENCE) {
@


1.13
log
@get rid of OPENSSL_NO_CMS code we do not use.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.12 2014/07/11 12:59:10 miod Exp $ */
d69 3
d423 11
@


1.12
log
@Remove duplicate 0x for salt len in output; Martin Kaiser via OpenSSL trunk.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.11 2014/07/11 08:44:49 jsing Exp $ */
a68 3
#ifndef OPENSSL_NO_CMS
#include <openssl/cms.h>
#endif
a419 11
#ifndef OPENSSL_NO_CMS
	case ASN1_PKEY_CTRL_CMS_SIGN:
		if (arg1 == 0)
			CMS_SignerInfo_get0_algs(arg2, NULL, NULL, NULL, &alg);
		break;

	case ASN1_PKEY_CTRL_CMS_ENVELOPE:
		if (arg1 == 0)
			CMS_RecipientInfo_ktri_get0_algs(arg2, NULL, NULL, &alg);
		break;
#endif
@


1.11
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.10 2014/07/10 22:45:57 jsing Exp $ */
d364 1
a364 1
	} else if (BIO_puts(bp, "0x14 (default)") <= 0)
@


1.10
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.9 2014/07/09 22:55:17 tedu Exp $ */
a62 1
#include "cryptlib.h"
d64 3
d68 1
a68 2
#include <openssl/rsa.h>
#include <openssl/bn.h>
d72 1
@


1.9
log
@ASN1_STRING_free can handle NULL, so callers don't need to check. ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.8 2014/07/09 19:51:38 jsing Exp $ */
d60 3
@


1.8
log
@More KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.7 2014/07/09 08:20:08 miod Exp $ */
d628 1
a628 2
		if (os1)
			ASN1_STRING_free(os1);
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_ameth.c,v 1.6 2014/06/12 15:49:30 deraadt Exp $ */
d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d107 2
a108 2
	if (BN_cmp(b->pkey.rsa->n,a->pkey.rsa->n) != 0 ||
	    BN_cmp(b->pkey.rsa->e,a->pkey.rsa->e) != 0)
d259 1
a259 1
	return(ret);
d285 1
d292 1
a292 1
	
d355 1
a355 1
			goto err;
d373 1
a373 1
	
d407 1
d427 1
a427 1
	break;
d445 2
a446 2
/* Customised RSA item verification routine. This is called 
 * when a signature is encountered requiring special handling. We 
d465 1
d550 1
a550 1
   X509_ALGOR *alg1, X509_ALGOR *alg2, ASN1_BIT_STRING *sig)
@


1.6
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d70 3
a72 2
static int rsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
	{
d75 1
d80 1
a80 1
				V_ASN1_NULL, NULL, penc, penclen))
d85 1
a85 1
	}
d87 3
a89 2
static int rsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)
	{
d93 1
d96 1
a96 2
	if (!(rsa = d2i_RSAPublicKey(NULL, &p, pklen)))
		{
d99 1
a99 1
		}
d102 1
a102 1
	}
d104 6
a109 5
static int rsa_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
	{
	if (BN_cmp(b->pkey.rsa->n,a->pkey.rsa->n) != 0
		|| BN_cmp(b->pkey.rsa->e,a->pkey.rsa->e) != 0)
			return 0;
d111 1
a111 1
	}
d113 3
a115 3
static int old_rsa_priv_decode(EVP_PKEY *pkey,
					const unsigned char **pder, int derlen)
	{
d117 2
a118 2
	if (!(rsa = d2i_RSAPrivateKey (NULL, pder, derlen)))
		{
d121 1
a121 1
		}
d124 1
a124 1
	}
d126 3
a128 2
static int old_rsa_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)
	{
d130 1
a130 1
	}
d132 3
a134 2
static int rsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
	{
d137 1
d140 2
a141 3
	if (rklen <= 0)
		{
		RSAerr(RSA_F_RSA_PRIV_ENCODE,ERR_R_MALLOC_FAILURE);
d143 1
a143 1
		}
d146 2
a147 3
				V_ASN1_NULL, NULL, rk, rklen))
		{
		RSAerr(RSA_F_RSA_PRIV_ENCODE,ERR_R_MALLOC_FAILURE);
d149 1
a149 1
		}
d152 1
a152 1
	}
d154 3
a156 2
static int rsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)
	{
d159 1
d163 1
a163 1
	}
d165 3
a167 2
static int int_rsa_size(const EVP_PKEY *pkey)
	{
d169 1
a169 1
	}
d171 3
a173 2
static int rsa_bits(const EVP_PKEY *pkey)
	{
d175 1
a175 1
	}
d177 3
a179 2
static void int_rsa_free(EVP_PKEY *pkey)
	{
d181 1
a181 1
	}
d183 4
a187 3
static void update_buflen(const BIGNUM *b, size_t *pbuflen)
	{
	size_t i;
d191 2
a192 2
			*pbuflen = i;
	}
d194 3
a196 2
static int do_rsa_print(BIO *bp, const RSA *x, int off, int priv)
	{
d199 3
a201 3
	unsigned char *m=NULL;
	int ret=0, mod_len = 0;
	size_t buf_len=0;
d206 1
a206 2
	if (priv)
		{
d213 1
a213 1
		}
d215 3
a217 4
	m = malloc(buf_len+10);
	if (m == NULL)
		{
		RSAerr(RSA_F_DO_RSA_PRINT,ERR_R_MALLOC_FAILURE);
d219 1
a219 1
		}
d224 1
a224 1
	if(!BIO_indent(bp,off,128))
d227 3
a229 4
	if (priv && x->d)
		{
		if (BIO_printf(bp,"Private-Key: (%d bit)\n", mod_len)
			<= 0) goto err;
d232 3
a234 5
		}
	else
		{
		if (BIO_printf(bp,"Public-Key: (%d bit)\n", mod_len)
			<= 0) goto err;
d237 4
a240 3
		}
	if (!ASN1_bn_print(bp,str,x->n,m,off)) goto err;
	if (!ASN1_bn_print(bp,s,x->e,m,off))
d242 2
a243 3
	if (priv)
		{
		if (!ASN1_bn_print(bp,"privateExponent:",x->d,m,off))
d245 1
a245 1
		if (!ASN1_bn_print(bp,"prime1:",x->p,m,off))
d247 1
a247 1
		if (!ASN1_bn_print(bp,"prime2:",x->q,m,off))
d249 1
a249 1
		if (!ASN1_bn_print(bp,"exponent1:",x->dmp1,m,off))
d251 1
a251 1
		if (!ASN1_bn_print(bp,"exponent2:",x->dmq1,m,off))
d253 1
a253 1
		if (!ASN1_bn_print(bp,"coefficient:",x->iqmp,m,off))
d255 2
a256 2
		}
	ret=1;
d260 1
a260 1
	}
d262 3
a264 3
static int rsa_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *ctx)
	{
d266 1
a266 2
	}

d268 3
a270 3
static int rsa_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *ctx)
	{
d272 1
a272 1
	}
d274 3
a276 3
static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
					X509_ALGOR **pmaskHash)
	{
d292 1
a292 2
	if (pss->maskGenAlgorithm)
		{
d294 2
a295 3
		if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
			&& param->type == V_ASN1_SEQUENCE)
			{
a298 1
			}
d300 1
d303 1
a303 1
	}
d305 4
a308 3
static int rsa_pss_param_print(BIO *bp, RSA_PSS_PARAMS *pss, 
				X509_ALGOR *maskHash, int indent)
	{
d310 2
a311 2
	if (!pss)
		{
d315 1
a315 1
		}
d323 1
a323 2
	if (pss->hashAlgorithm)
		{
d326 1
a326 2
		}
	else if (BIO_puts(bp, "sha1 (default)") <= 0)
d336 2
a337 3
			goto err;
	if (pss->maskGenAlgorithm)
		{
d342 1
a342 2
		if (maskHash)
			{
d344 2
d347 1
a347 5
			}
		else if (BIO_puts(bp, "INVALID") <= 0)
			goto err;
		}
	else if (BIO_puts(bp, "mgf1 with sha1 (default)") <= 0)
d355 1
a355 2
	if (pss->saltLength)
		{
d358 1
a358 2
		}
	else if (BIO_puts(bp, "0x14 (default)") <= 0)
d365 2
a366 3
			goto err;
	if (pss->trailerField)
		{
d369 1
a369 2
		}
	else if (BIO_puts(bp, "BC (default)") <= 0)
d375 1
a375 1
	err:
d377 1
d379 5
a383 8
	}

static int rsa_sig_print(BIO *bp, const X509_ALGOR *sigalg,
					const ASN1_STRING *sig,
					int indent, ASN1_PCTX *pctx)
	{
	if (OBJ_obj2nid(sigalg->algorithm) == NID_rsassaPss)
		{
d395 1
a395 2
		}
	else if (!sig && BIO_puts(bp, "\n") <= 0)
d400 1
a400 1
	}
d402 3
a404 2
static int rsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
	{
d406 2
a407 4
	switch (op)
		{

		case ASN1_PKEY_CTRL_PKCS7_SIGN:
d412 1
a412 1
		case ASN1_PKEY_CTRL_PKCS7_ENCRYPT:
d417 1
a417 1
		case ASN1_PKEY_CTRL_CMS_SIGN:
d422 1
a422 1
		case ASN1_PKEY_CTRL_CMS_ENVELOPE:
d425 1
a425 1
		break;
d428 1
a428 1
		case ASN1_PKEY_CTRL_DEFAULT_MD_NID:
d432 1
a432 1
		default:
d434 1
a434 2

		}
d438 1
a438 1
							V_ASN1_NULL, 0);
d441 1
a441 2

	}
d447 4
a450 6


static int rsa_item_verify(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,
			X509_ALGOR *sigalg, ASN1_BIT_STRING *sig,
			EVP_PKEY *pkey)
	{
d457 1
d459 1
a459 2
	if (OBJ_obj2nid(sigalg->algorithm) != NID_rsassaPss)
		{
d462 1
a462 1
		}
d466 1
a466 2
	if (pss == NULL)
		{
d469 7
d477 3
a479 11
	/* Check mask and lookup mask hash algorithm */
	if (pss->maskGenAlgorithm)
		{
		if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) != NID_mgf1)
			{
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNSUPPORTED_MASK_ALGORITHM);
			goto err;
			}
		if (!maskHash)
			{
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNSUPPORTED_MASK_PARAMETER);
d481 1
a481 1
			}
d483 3
a485 3
		if (mgf1md == NULL)
			{
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNKNOWN_MASK_DIGEST);
a486 1
			}
d488 1
a488 1
	else
d491 1
a491 2
	if (pss->hashAlgorithm)
		{
d493 1
a493 2
		if (md == NULL)
			{
a495 1
			}
d497 1
a497 1
	else
d500 1
a500 2
	if (pss->saltLength)
		{
d506 3
a508 3
		if (saltlen < 0)
			{
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_INVALID_SALT_LENGTH);
a509 1
			}
d511 1
a511 1
	else
d517 1
a517 2
	if (pss->trailerField && ASN1_INTEGER_get(pss->trailerField) != 1)
		{
d520 1
a520 1
		}
d538 1
a538 1
	err:
d543 1
a543 1
	}
d545 4
a548 4
static int rsa_item_sign(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,
				X509_ALGOR *alg1, X509_ALGOR *alg2, 
				ASN1_BIT_STRING *sig)
	{
d551 1
d556 1
a556 2
	if (pad_mode == RSA_PKCS1_PSS_PADDING)
		{
d563 1
d571 1
a571 2
		else if (saltlen == -2)
			{
d575 1
a575 1
			}
d579 1
a579 2
		if (saltlen != 20)
			{
d585 2
a586 3
			}
		if (EVP_MD_type(sigmd) != NID_sha1)
			{
d591 2
a592 3
			}
		if (EVP_MD_type(mgf1md) != NID_sha1)
			{
d598 2
a599 2
									&stmp))
					goto err;
d604 2
a605 3
					OBJ_nid2obj(NID_mgf1),
					V_ASN1_SEQUENCE, stmp);
			}
d609 1
a609 2
		if (alg2)
			{
d614 2
a615 2
						V_ASN1_SEQUENCE, os2);
			}
d617 1
a617 1
					V_ASN1_SEQUENCE, os1);
d620 1
a620 1
		err:
d628 1
a628 2
		
		}
d630 1
a630 1
	}
@


1.5
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/rsa/rsa_ameth.c */
@


1.4
log
@more: no need to null check before free; ok guenther
@
text
@d204 1
a204 1
	m=(unsigned char *)malloc(buf_len+10);
@


1.3
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d251 1
a251 1
	if (m != NULL) free(m);
@


1.2
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d660 1
a660 1
const EVP_PKEY_ASN1_METHOD rsa_asn1_meths[] = 
d662 35
a696 37
		{
		EVP_PKEY_RSA,
		EVP_PKEY_RSA,
		ASN1_PKEY_SIGPARAM_NULL,

		"RSA",
		"OpenSSL RSA method",

		rsa_pub_decode,
		rsa_pub_encode,
		rsa_pub_cmp,
		rsa_pub_print,

		rsa_priv_decode,
		rsa_priv_encode,
		rsa_priv_print,

		int_rsa_size,
		rsa_bits,

		0,0,0,0,0,0,

		rsa_sig_print,
		int_rsa_free,
		rsa_pkey_ctrl,
		old_rsa_priv_decode,
		old_rsa_priv_encode,
		rsa_item_verify,
		rsa_item_sign
		},

		{
		EVP_PKEY_RSA2,
		EVP_PKEY_RSA,
		ASN1_PKEY_ALIAS
		}
	};
@


1.1
log
@Initial revision
@
text
@d81 1
a81 1
	OPENSSL_free(penc);
d204 1
a204 1
	m=(unsigned char *)OPENSSL_malloc(buf_len+10);
d251 1
a251 1
	if (m != NULL) OPENSSL_free(m);
d268 141
d454 205
d684 1
d688 3
a690 1
		old_rsa_priv_encode
@


1.1.1.1
log
@import OpenSSL-1.0.0a
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.1c
@
text
@a267 141
static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
					X509_ALGOR **pmaskHash)
	{
	const unsigned char *p;
	int plen;
	RSA_PSS_PARAMS *pss;

	*pmaskHash = NULL;

	if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)
		return NULL;
	p = alg->parameter->value.sequence->data;
	plen = alg->parameter->value.sequence->length;
	pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);

	if (!pss)
		return NULL;
	
	if (pss->maskGenAlgorithm)
		{
		ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;
		if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1
			&& param->type == V_ASN1_SEQUENCE)
			{
			p = param->value.sequence->data;
			plen = param->value.sequence->length;
			*pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);
			}
		}

	return pss;
	}

static int rsa_pss_param_print(BIO *bp, RSA_PSS_PARAMS *pss, 
				X509_ALGOR *maskHash, int indent)
	{
	int rv = 0;
	if (!pss)
		{
		if (BIO_puts(bp, " (INVALID PSS PARAMETERS)\n") <= 0)
			return 0;
		return 1;
		}
	if (BIO_puts(bp, "\n") <= 0)
		goto err;
	if (!BIO_indent(bp, indent, 128))
		goto err;
	if (BIO_puts(bp, "Hash Algorithm: ") <= 0)
		goto err;

	if (pss->hashAlgorithm)
		{
		if (i2a_ASN1_OBJECT(bp, pss->hashAlgorithm->algorithm) <= 0)
			goto err;
		}
	else if (BIO_puts(bp, "sha1 (default)") <= 0)
		goto err;

	if (BIO_puts(bp, "\n") <= 0)
		goto err;

	if (!BIO_indent(bp, indent, 128))
		goto err;

	if (BIO_puts(bp, "Mask Algorithm: ") <= 0)
			goto err;
	if (pss->maskGenAlgorithm)
		{
		if (i2a_ASN1_OBJECT(bp, pss->maskGenAlgorithm->algorithm) <= 0)
			goto err;
		if (BIO_puts(bp, " with ") <= 0)
			goto err;
		if (maskHash)
			{
			if (i2a_ASN1_OBJECT(bp, maskHash->algorithm) <= 0)
			goto err;
			}
		else if (BIO_puts(bp, "INVALID") <= 0)
			goto err;
		}
	else if (BIO_puts(bp, "mgf1 with sha1 (default)") <= 0)
		goto err;
	BIO_puts(bp, "\n");

	if (!BIO_indent(bp, indent, 128))
		goto err;
	if (BIO_puts(bp, "Salt Length: ") <= 0)
			goto err;
	if (pss->saltLength)
		{
		if (i2a_ASN1_INTEGER(bp, pss->saltLength) <= 0)
			goto err;
		}
	else if (BIO_puts(bp, "20 (default)") <= 0)
		goto err;
	BIO_puts(bp, "\n");

	if (!BIO_indent(bp, indent, 128))
		goto err;
	if (BIO_puts(bp, "Trailer Field: ") <= 0)
			goto err;
	if (pss->trailerField)
		{
		if (i2a_ASN1_INTEGER(bp, pss->trailerField) <= 0)
			goto err;
		}
	else if (BIO_puts(bp, "0xbc (default)") <= 0)
		goto err;
	BIO_puts(bp, "\n");
	
	rv = 1;

	err:
	return rv;

	}

static int rsa_sig_print(BIO *bp, const X509_ALGOR *sigalg,
					const ASN1_STRING *sig,
					int indent, ASN1_PCTX *pctx)
	{
	if (OBJ_obj2nid(sigalg->algorithm) == NID_rsassaPss)
		{
		int rv;
		RSA_PSS_PARAMS *pss;
		X509_ALGOR *maskHash;
		pss = rsa_pss_decode(sigalg, &maskHash);
		rv = rsa_pss_param_print(bp, pss, maskHash, indent);
		if (pss)
			RSA_PSS_PARAMS_free(pss);
		if (maskHash)
			X509_ALGOR_free(maskHash);
		if (!rv)
			return 0;
		}
	else if (!sig && BIO_puts(bp, "\n") <= 0)
		return 0;
	if (sig)
		return X509_signature_dump(bp, sig, indent);
	return 1;
	}
a312 205
/* Customised RSA item verification routine. This is called 
 * when a signature is encountered requiring special handling. We 
 * currently only handle PSS.
 */


static int rsa_item_verify(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,
			X509_ALGOR *sigalg, ASN1_BIT_STRING *sig,
			EVP_PKEY *pkey)
	{
	int rv = -1;
	int saltlen;
	const EVP_MD *mgf1md = NULL, *md = NULL;
	RSA_PSS_PARAMS *pss;
	X509_ALGOR *maskHash;
	EVP_PKEY_CTX *pkctx;
	/* Sanity check: make sure it is PSS */
	if (OBJ_obj2nid(sigalg->algorithm) != NID_rsassaPss)
		{
		RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNSUPPORTED_SIGNATURE_TYPE);
		return -1;
		}
	/* Decode PSS parameters */
	pss = rsa_pss_decode(sigalg, &maskHash);

	if (pss == NULL)
		{
		RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_INVALID_PSS_PARAMETERS);
		goto err;
		}
	/* Check mask and lookup mask hash algorithm */
	if (pss->maskGenAlgorithm)
		{
		if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) != NID_mgf1)
			{
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNSUPPORTED_MASK_ALGORITHM);
			goto err;
			}
		if (!maskHash)
			{
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNSUPPORTED_MASK_PARAMETER);
			goto err;
			}
		mgf1md = EVP_get_digestbyobj(maskHash->algorithm);
		if (mgf1md == NULL)
			{
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNKNOWN_MASK_DIGEST);
			goto err;
			}
		}
	else
		mgf1md = EVP_sha1();

	if (pss->hashAlgorithm)
		{
		md = EVP_get_digestbyobj(pss->hashAlgorithm->algorithm);
		if (md == NULL)
			{
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNKNOWN_PSS_DIGEST);
			goto err;
			}
		}
	else
		md = EVP_sha1();

	if (pss->saltLength)
		{
		saltlen = ASN1_INTEGER_get(pss->saltLength);

		/* Could perform more salt length sanity checks but the main
		 * RSA routines will trap other invalid values anyway.
		 */
		if (saltlen < 0)
			{
			RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_INVALID_SALT_LENGTH);
			goto err;
			}
		}
	else
		saltlen = 20;

	/* low-level routines support only trailer field 0xbc (value 1)
	 * and PKCS#1 says we should reject any other value anyway.
	 */
	if (pss->trailerField && ASN1_INTEGER_get(pss->trailerField) != 1)
		{
		RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_INVALID_TRAILER);
		goto err;
		}

	/* We have all parameters now set up context */

	if (!EVP_DigestVerifyInit(ctx, &pkctx, md, NULL, pkey))
		goto err;

	if (EVP_PKEY_CTX_set_rsa_padding(pkctx, RSA_PKCS1_PSS_PADDING) <= 0)
		goto err;

	if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, saltlen) <= 0)
		goto err;

	if (EVP_PKEY_CTX_set_rsa_mgf1_md(pkctx, mgf1md) <= 0)
		goto err;
	/* Carry on */
	rv = 2;

	err:
	RSA_PSS_PARAMS_free(pss);
	if (maskHash)
		X509_ALGOR_free(maskHash);
	return rv;
	}

static int rsa_item_sign(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,
				X509_ALGOR *alg1, X509_ALGOR *alg2, 
				ASN1_BIT_STRING *sig)
	{
	int pad_mode;
	EVP_PKEY_CTX *pkctx = ctx->pctx;
	if (EVP_PKEY_CTX_get_rsa_padding(pkctx, &pad_mode) <= 0)
		return 0;
	if (pad_mode == RSA_PKCS1_PADDING)
		return 2;
	if (pad_mode == RSA_PKCS1_PSS_PADDING)
		{
		const EVP_MD *sigmd, *mgf1md;
		RSA_PSS_PARAMS *pss = NULL;
		X509_ALGOR *mgf1alg = NULL;
		ASN1_STRING *os1 = NULL, *os2 = NULL;
		EVP_PKEY *pk = EVP_PKEY_CTX_get0_pkey(pkctx);
		int saltlen, rv = 0;
		sigmd = EVP_MD_CTX_md(ctx);
		if (EVP_PKEY_CTX_get_rsa_mgf1_md(pkctx, &mgf1md) <= 0)
			goto err;
		if (!EVP_PKEY_CTX_get_rsa_pss_saltlen(pkctx, &saltlen))
			goto err;
		if (saltlen == -1)
			saltlen = EVP_MD_size(sigmd);
		else if (saltlen == -2)
			{
			saltlen = EVP_PKEY_size(pk) - EVP_MD_size(sigmd) - 2;
			if (((EVP_PKEY_bits(pk) - 1) & 0x7) == 0)
				saltlen--;
			}
		pss = RSA_PSS_PARAMS_new();
		if (!pss)
			goto err;
		if (saltlen != 20)
			{
			pss->saltLength = ASN1_INTEGER_new();
			if (!pss->saltLength)
				goto err;
			if (!ASN1_INTEGER_set(pss->saltLength, saltlen))
				goto err;
			}
		if (EVP_MD_type(sigmd) != NID_sha1)
			{
			pss->hashAlgorithm = X509_ALGOR_new();
			if (!pss->hashAlgorithm)
				goto err;
			X509_ALGOR_set_md(pss->hashAlgorithm, sigmd);
			}
		if (EVP_MD_type(mgf1md) != NID_sha1)
			{
			ASN1_STRING *stmp = NULL;
			/* need to embed algorithm ID inside another */
			mgf1alg = X509_ALGOR_new();
			X509_ALGOR_set_md(mgf1alg, mgf1md);
			if (!ASN1_item_pack(mgf1alg, ASN1_ITEM_rptr(X509_ALGOR),
									&stmp))
					goto err;
			pss->maskGenAlgorithm = X509_ALGOR_new();
			if (!pss->maskGenAlgorithm)
				goto err;
			X509_ALGOR_set0(pss->maskGenAlgorithm,
					OBJ_nid2obj(NID_mgf1),
					V_ASN1_SEQUENCE, stmp);
			}
		/* Finally create string with pss parameter encoding. */
		if (!ASN1_item_pack(pss, ASN1_ITEM_rptr(RSA_PSS_PARAMS), &os1))
			goto err;
		if (alg2)
			{
			os2 = ASN1_STRING_dup(os1);
			if (!os2)
				goto err;
			X509_ALGOR_set0(alg2, OBJ_nid2obj(NID_rsassaPss),
						V_ASN1_SEQUENCE, os2);
			}
		X509_ALGOR_set0(alg1, OBJ_nid2obj(NID_rsassaPss),
					V_ASN1_SEQUENCE, os1);
		os1 = os2 = NULL;
		rv = 3;
		err:
		if (mgf1alg)
			X509_ALGOR_free(mgf1alg);
		if (pss)
			RSA_PSS_PARAMS_free(pss);
		if (os1)
			ASN1_STRING_free(os1);
		return rv;
		
		}
	return 2;
	}
a337 1
		rsa_sig_print,
d341 1
a341 3
		old_rsa_priv_encode,
		rsa_item_verify,
		rsa_item_sign
@


1.1.1.3
log
@Import OpenSSL 1.0.1g
@
text
@d354 1
a354 1
	if (BIO_puts(bp, "Salt Length: 0x") <= 0)
d361 1
a361 1
	else if (BIO_puts(bp, "0x14 (default)") <= 0)
d367 1
a367 1
	if (BIO_puts(bp, "Trailer Field: 0x") <= 0)
d374 1
a374 1
	else if (BIO_puts(bp, "BC (default)") <= 0)
@


