head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.2
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14;
locks; strict;
comment	@ * @;


1.14
date	2016.12.21.15.49.29;	author jsing;	state Exp;
branches;
next	1.13;
commitid	ggG71MfP76PRyLln;

1.13
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	mJUVYpkFBZ0Zv2bG;

1.12
date	2014.05.26.13.01.58;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.05.15.13.53.47;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.05.11.12.05.27;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.15.20.06.10;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.29.05.39.22;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.15.02.57.46;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.28;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.12.20.47.38;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.10;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.44;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.13.56;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.07;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.10.13.21.23.40;	author djm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Explicitly export a list of symbols from libcrypto.

Move the "internal" BN functions from bn.h to bn_lcl.h and stop exporting
the bn_* symbols. These are documented as only being intended for internal
use, so why they were placed in a public header is beyond me...

This hides 363 previously exported symbols, most of which exist in headers
that are not installed and were never intended to be public. This also
removes a few crusty old things that should have died long ago (like
_ossl_old_des_read_pw). But don't worry... there are still 3451 symbols
exported from the library.

With input and testing from inoguchi@@.

ok beck@@ inoguchi@@
@
text
@/* $OpenBSD: evp_locl.h,v 1.13 2014/06/12 15:49:29 deraadt Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

__BEGIN_HIDDEN_DECLS

/* Macros to code block cipher wrappers */

/* Wrapper functions for each cipher mode */

#define BLOCK_CIPHER_ecb_loop() \
	size_t i, bl; \
	bl = ctx->cipher->block_size;\
	if(inl < bl) return 1;\
	inl -= bl; \
	for(i=0; i <= inl; i+=bl)

#define BLOCK_CIPHER_func_ecb(cname, cprefix, kstruct, ksched) \
static int cname##_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
{\
	BLOCK_CIPHER_ecb_loop() \
		cprefix##_ecb_encrypt(in + i, out + i, &((kstruct *)ctx->cipher_data)->ksched, ctx->encrypt);\
	return 1;\
}

#define EVP_MAXCHUNK ((size_t)1<<(sizeof(long)*8-2))

#define BLOCK_CIPHER_func_ofb(cname, cprefix, cbits, kstruct, ksched) \
static int cname##_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
{\
	while(inl>=EVP_MAXCHUNK)\
	    {\
	    cprefix##_ofb##cbits##_encrypt(in, out, (long)EVP_MAXCHUNK, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num);\
	    inl-=EVP_MAXCHUNK;\
	    in +=EVP_MAXCHUNK;\
	    out+=EVP_MAXCHUNK;\
	    }\
	if (inl)\
	    cprefix##_ofb##cbits##_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num);\
	return 1;\
}

#define BLOCK_CIPHER_func_cbc(cname, cprefix, kstruct, ksched) \
static int cname##_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
{\
	while(inl>=EVP_MAXCHUNK) \
	    {\
	    cprefix##_cbc_encrypt(in, out, (long)EVP_MAXCHUNK, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, ctx->encrypt);\
	    inl-=EVP_MAXCHUNK;\
	    in +=EVP_MAXCHUNK;\
	    out+=EVP_MAXCHUNK;\
	    }\
	if (inl)\
	    cprefix##_cbc_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, ctx->encrypt);\
	return 1;\
}

#define BLOCK_CIPHER_func_cfb(cname, cprefix, cbits, kstruct, ksched) \
static int cname##_cfb##cbits##_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
{\
	size_t chunk=EVP_MAXCHUNK;\
	if (cbits==1)  chunk>>=3;\
	if (inl<chunk) chunk=inl;\
	while(inl && inl>=chunk)\
	    {\
            cprefix##_cfb##cbits##_encrypt(in, out, (long)((cbits==1) && !(ctx->flags & EVP_CIPH_FLAG_LENGTH_BITS) ?inl*8:inl), &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num, ctx->encrypt);\
	    inl-=chunk;\
	    in +=chunk;\
	    out+=chunk;\
	    if(inl<chunk) chunk=inl;\
	    }\
	return 1;\
}

#define BLOCK_CIPHER_all_funcs(cname, cprefix, cbits, kstruct, ksched) \
	BLOCK_CIPHER_func_cbc(cname, cprefix, kstruct, ksched) \
	BLOCK_CIPHER_func_cfb(cname, cprefix, cbits, kstruct, ksched) \
	BLOCK_CIPHER_func_ecb(cname, cprefix, kstruct, ksched) \
	BLOCK_CIPHER_func_ofb(cname, cprefix, cbits, kstruct, ksched)

#define BLOCK_CIPHER_def1(cname, nmode, mode, MODE, kstruct, nid, block_size, \
			  key_len, iv_len, flags, init_key, cleanup, \
			  set_asn1, get_asn1, ctrl) \
static const EVP_CIPHER cname##_##mode = { \
	nid##_##nmode, block_size, key_len, iv_len, \
	flags | EVP_CIPH_##MODE##_MODE, \
	init_key, \
	cname##_##mode##_cipher, \
	cleanup, \
	sizeof(kstruct), \
	set_asn1, get_asn1,\
	ctrl, \
	NULL \
}; \
const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }

#define BLOCK_CIPHER_def_cbc(cname, kstruct, nid, block_size, key_len, \
			     iv_len, flags, init_key, cleanup, set_asn1, \
			     get_asn1, ctrl) \
BLOCK_CIPHER_def1(cname, cbc, cbc, CBC, kstruct, nid, block_size, key_len, \
		  iv_len, flags, init_key, cleanup, set_asn1, get_asn1, ctrl)

#define BLOCK_CIPHER_def_cfb(cname, kstruct, nid, key_len, \
			     iv_len, cbits, flags, init_key, cleanup, \
			     set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def1(cname, cfb##cbits, cfb##cbits, CFB, kstruct, nid, 1, \
		  key_len, iv_len, flags, init_key, cleanup, set_asn1, \
		  get_asn1, ctrl)

#define BLOCK_CIPHER_def_ofb(cname, kstruct, nid, key_len, \
			     iv_len, cbits, flags, init_key, cleanup, \
			     set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def1(cname, ofb##cbits, ofb, OFB, kstruct, nid, 1, \
		  key_len, iv_len, flags, init_key, cleanup, set_asn1, \
		  get_asn1, ctrl)

#define BLOCK_CIPHER_def_ecb(cname, kstruct, nid, block_size, key_len, \
			     flags, init_key, cleanup, set_asn1, \
			     get_asn1, ctrl) \
BLOCK_CIPHER_def1(cname, ecb, ecb, ECB, kstruct, nid, block_size, key_len, \
		  0, flags, init_key, cleanup, set_asn1, get_asn1, ctrl)

#define BLOCK_CIPHER_defs(cname, kstruct, \
			  nid, block_size, key_len, iv_len, cbits, flags, \
			  init_key, cleanup, set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def_cbc(cname, kstruct, nid, block_size, key_len, iv_len, flags, \
		     init_key, cleanup, set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def_cfb(cname, kstruct, nid, key_len, iv_len, cbits, \
		     flags, init_key, cleanup, set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def_ofb(cname, kstruct, nid, key_len, iv_len, cbits, \
		     flags, init_key, cleanup, set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def_ecb(cname, kstruct, nid, block_size, key_len, flags, \
		     init_key, cleanup, set_asn1, get_asn1, ctrl)


/*
#define BLOCK_CIPHER_defs(cname, kstruct, \
				nid, block_size, key_len, iv_len, flags,\
				 init_key, cleanup, set_asn1, get_asn1, ctrl)\
static const EVP_CIPHER cname##_cbc = {\
	nid##_cbc, block_size, key_len, iv_len, \
	flags | EVP_CIPH_CBC_MODE,\
	init_key,\
	cname##_cbc_cipher,\
	cleanup,\
	sizeof(EVP_CIPHER_CTX)-sizeof((((EVP_CIPHER_CTX *)NULL)->c))+\
		sizeof((((EVP_CIPHER_CTX *)NULL)->c.kstruct)),\
	set_asn1, get_asn1,\
	ctrl, \
	NULL \
};\
const EVP_CIPHER *EVP_##cname##_cbc(void) { return &cname##_cbc; }\
static const EVP_CIPHER cname##_cfb = {\
	nid##_cfb64, 1, key_len, iv_len, \
	flags | EVP_CIPH_CFB_MODE,\
	init_key,\
	cname##_cfb_cipher,\
	cleanup,\
	sizeof(EVP_CIPHER_CTX)-sizeof((((EVP_CIPHER_CTX *)NULL)->c))+\
		sizeof((((EVP_CIPHER_CTX *)NULL)->c.kstruct)),\
	set_asn1, get_asn1,\
	ctrl,\
	NULL \
};\
const EVP_CIPHER *EVP_##cname##_cfb(void) { return &cname##_cfb; }\
static const EVP_CIPHER cname##_ofb = {\
	nid##_ofb64, 1, key_len, iv_len, \
	flags | EVP_CIPH_OFB_MODE,\
	init_key,\
	cname##_ofb_cipher,\
	cleanup,\
	sizeof(EVP_CIPHER_CTX)-sizeof((((EVP_CIPHER_CTX *)NULL)->c))+\
		sizeof((((EVP_CIPHER_CTX *)NULL)->c.kstruct)),\
	set_asn1, get_asn1,\
	ctrl,\
	NULL \
};\
const EVP_CIPHER *EVP_##cname##_ofb(void) { return &cname##_ofb; }\
static const EVP_CIPHER cname##_ecb = {\
	nid##_ecb, block_size, key_len, iv_len, \
	flags | EVP_CIPH_ECB_MODE,\
	init_key,\
	cname##_ecb_cipher,\
	cleanup,\
	sizeof(EVP_CIPHER_CTX)-sizeof((((EVP_CIPHER_CTX *)NULL)->c))+\
		sizeof((((EVP_CIPHER_CTX *)NULL)->c.kstruct)),\
	set_asn1, get_asn1,\
	ctrl,\
	NULL \
};\
const EVP_CIPHER *EVP_##cname##_ecb(void) { return &cname##_ecb; }
*/

#define IMPLEMENT_BLOCK_CIPHER(cname, ksched, cprefix, kstruct, nid, \
			       block_size, key_len, iv_len, cbits, \
			       flags, init_key, \
			       cleanup, set_asn1, get_asn1, ctrl) \
	BLOCK_CIPHER_all_funcs(cname, cprefix, cbits, kstruct, ksched) \
	BLOCK_CIPHER_defs(cname, kstruct, nid, block_size, key_len, iv_len, \
			  cbits, flags, init_key, cleanup, set_asn1, \
			  get_asn1, ctrl)

#define EVP_C_DATA(kstruct, ctx)	((kstruct *)(ctx)->cipher_data)

#define IMPLEMENT_CFBR(cipher,cprefix,kstruct,ksched,keysize,cbits,iv_len) \
	BLOCK_CIPHER_func_cfb(cipher##_##keysize,cprefix,cbits,kstruct,ksched) \
	BLOCK_CIPHER_def_cfb(cipher##_##keysize,kstruct, \
			     NID_##cipher##_##keysize, keysize/8, iv_len, cbits, \
			     0, cipher##_init_key, NULL, \
			     EVP_CIPHER_set_asn1_iv, \
			     EVP_CIPHER_get_asn1_iv, \
			     NULL)

										struct evp_pkey_ctx_st {
	/* Method associated with this operation */
	const EVP_PKEY_METHOD *pmeth;
	/* Engine that implements this method or NULL if builtin */
	ENGINE *engine;
	/* Key: may be NULL */
	EVP_PKEY *pkey;
	/* Peer key for key agreement, may be NULL */
	EVP_PKEY *peerkey;
	/* Actual operation */
	int operation;
	/* Algorithm specific data */
	void *data;
	/* Application specific data */
	void *app_data;
	/* Keygen callback */
	EVP_PKEY_gen_cb *pkey_gencb;
	/* implementation specific keygen data */
	int *keygen_info;
	int keygen_info_count;
} /* EVP_PKEY_CTX */;

#define EVP_PKEY_FLAG_DYNAMIC	1

struct evp_pkey_method_st {
	int pkey_id;
	int flags;

	int (*init)(EVP_PKEY_CTX *ctx);
	int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src);
	void (*cleanup)(EVP_PKEY_CTX *ctx);

	int (*paramgen_init)(EVP_PKEY_CTX *ctx);
	int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);

	int (*keygen_init)(EVP_PKEY_CTX *ctx);
	int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);

	int (*sign_init)(EVP_PKEY_CTX *ctx);
	int (*sign)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
	    const unsigned char *tbs, size_t tbslen);

	int (*verify_init)(EVP_PKEY_CTX *ctx);
	int (*verify)(EVP_PKEY_CTX *ctx,
	    const unsigned char *sig, size_t siglen,
	    const unsigned char *tbs, size_t tbslen);

	int (*verify_recover_init)(EVP_PKEY_CTX *ctx);
	int (*verify_recover)(EVP_PKEY_CTX *ctx,
	    unsigned char *rout, size_t *routlen,
	    const unsigned char *sig, size_t siglen);

	int (*signctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);
	int (*signctx)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
	    EVP_MD_CTX *mctx);

	int (*verifyctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);
	int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig,
	    int siglen, EVP_MD_CTX *mctx);

	int (*encrypt_init)(EVP_PKEY_CTX *ctx);
	int (*encrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
	    const unsigned char *in, size_t inlen);

	int (*decrypt_init)(EVP_PKEY_CTX *ctx);
	int (*decrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
	    const unsigned char *in, size_t inlen);

	int (*derive_init)(EVP_PKEY_CTX *ctx);
	int (*derive)(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);

	int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2);
	int (*ctrl_str)(EVP_PKEY_CTX *ctx, const char *type, const char *value);
} /* EVP_PKEY_METHOD */;

void evp_pkey_set_cb_translate(BN_GENCB *cb, EVP_PKEY_CTX *ctx);

int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
    ASN1_TYPE *param, const EVP_CIPHER *c, const EVP_MD *md, int en_de);

/* EVP_AEAD represents a specific AEAD algorithm. */
struct evp_aead_st {
	unsigned char key_len;
	unsigned char nonce_len;
	unsigned char overhead;
	unsigned char max_tag_len;

	int (*init)(struct evp_aead_ctx_st*, const unsigned char *key,
	    size_t key_len, size_t tag_len);
	void (*cleanup)(struct evp_aead_ctx_st*);

	int (*seal)(const struct evp_aead_ctx_st *ctx, unsigned char *out,
	    size_t *out_len, size_t max_out_len, const unsigned char *nonce,
	    size_t nonce_len, const unsigned char *in, size_t in_len,
	    const unsigned char *ad, size_t ad_len);

	int (*open)(const struct evp_aead_ctx_st *ctx, unsigned char *out,
	    size_t *out_len, size_t max_out_len, const unsigned char *nonce,
	    size_t nonce_len, const unsigned char *in, size_t in_len,
	    const unsigned char *ad, size_t ad_len);
};

__END_HIDDEN_DECLS
@


1.13
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d59 2
d369 2
@


1.12
log
@Implement an improved version of the EVP AEAD API. The
EVP_AEAD_CTX_{open,seal} functions previously returned an ssize_t that was
overloaded to indicate success/failure, along with the number of bytes
written as output. This change adds an explicit *out_len argument which
is used to return the number of output bytes and the return value is now
an int that is purely used to identify success or failure.

This change effectively rides the last libcrypto crank (although I do not
expect there to be many users of the EVP AEAD API currently).

Thanks to Adam Langley for providing the improved code that this diff is
based on.

ok miod@@
@
text
@d1 1
a1 1
/* evp_locl.h */
@


1.11
log
@Add an AEAD EVP interface to libcrypto, along with AES-GCM AEAD
implementations. This largely pulls in Adam Langley's AEAD patches from
Chromium's OpenSSL.

ok miod@@
@
text
@d357 4
a360 4
	ssize_t (*seal)(const struct evp_aead_ctx_st *ctx, unsigned char *out,
	    size_t max_out_len, const unsigned char *nonce, size_t nonce_len,
	    const unsigned char *in, size_t in_len, const unsigned char *ad,
	    size_t ad_len);
d362 4
a365 4
	ssize_t (*open)(const struct evp_aead_ctx_st *ctx, unsigned char *out,
	    size_t max_out_len, const unsigned char *nonce, size_t nonce_len,
	    const unsigned char *in, size_t in_len, const unsigned char *ad,
	    size_t ad_len);
@


1.10
log
@KNF.
@
text
@d345 22
@


1.9
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok beck deraadt
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d68 1
a68 1
	for(i=0; i <= inl; i+=bl) 
d266 1
a266 2
struct evp_pkey_ctx_st
	{
d286 1
a286 1
	} /* EVP_PKEY_CTX */;
d290 1
a290 2
struct evp_pkey_method_st
	{
d306 1
a306 1
				const unsigned char *tbs, size_t tbslen);
d310 2
a311 2
				const unsigned char *sig, size_t siglen,
				const unsigned char *tbs, size_t tbslen);
d315 2
a316 2
				unsigned char *rout, size_t *routlen,
				const unsigned char *sig, size_t siglen);
d320 1
a320 1
					EVP_MD_CTX *mctx);
d323 2
a324 2
	int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig,int siglen,
					EVP_MD_CTX *mctx);
d328 1
a328 1
					const unsigned char *in, size_t inlen);
d332 1
a332 1
					const unsigned char *in, size_t inlen);
d339 1
a339 3


	} /* EVP_PKEY_METHOD */;
d344 1
a344 2
			     ASN1_TYPE *param,
			     const EVP_CIPHER *c, const EVP_MD *md, int en_de);
@


1.8
log
@resolve conflicts
@
text
@a349 36

#ifdef OPENSSL_FIPS

#ifdef OPENSSL_DOING_MAKEDEPEND
#undef SHA1_Init
#undef SHA1_Update
#undef SHA224_Init
#undef SHA256_Init
#undef SHA384_Init
#undef SHA512_Init
#undef DES_set_key_unchecked
#endif

#define RIPEMD160_Init	private_RIPEMD160_Init
#define WHIRLPOOL_Init	private_WHIRLPOOL_Init
#define MD5_Init	private_MD5_Init
#define MD4_Init	private_MD4_Init
#define MD2_Init	private_MD2_Init
#define MDC2_Init	private_MDC2_Init
#define SHA_Init	private_SHA_Init
#define SHA1_Init	private_SHA1_Init
#define SHA224_Init	private_SHA224_Init
#define SHA256_Init	private_SHA256_Init
#define SHA384_Init	private_SHA384_Init
#define SHA512_Init	private_SHA512_Init

#define BF_set_key	private_BF_set_key
#define CAST_set_key	private_CAST_set_key
#define idea_set_encrypt_key	private_idea_set_encrypt_key
#define SEED_set_key	private_SEED_set_key
#define RC2_set_key	private_RC2_set_key
#define RC4_set_key	private_RC4_set_key
#define DES_set_key_unchecked	private_DES_set_key_unchecked
#define Camellia_set_key	private_Camellia_set_key

#endif
@


1.7
log
@resolve conflicts, fix local changes
@
text
@d346 40
@


1.6
log
@resolve conflicts
@
text
@d64 1
a64 1
	unsigned int i, bl; \
d71 1
a71 1
static int cname##_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int inl) \
d78 2
d81 1
a81 1
static int cname##_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int inl) \
d83 9
a91 1
	cprefix##_ofb##cbits##_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num);\
d96 1
a96 1
static int cname##_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int inl) \
d98 9
a106 1
	cprefix##_cbc_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, ctx->encrypt);\
d111 1
a111 1
static int cname##_cfb##cbits##_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int inl) \
d113 11
a123 1
	cprefix##_cfb##cbits##_encrypt(in, out, (long)((cbits==1) && !(ctx->flags & EVP_CIPH_FLAG_LENGTH_BITS) ?inl*8:inl), &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num, ctx->encrypt);\
d170 1
a170 1
			     iv_len, flags, init_key, cleanup, set_asn1, \
d173 1
a173 1
		  iv_len, flags, init_key, cleanup, set_asn1, get_asn1, ctrl)
d184 1
a184 1
BLOCK_CIPHER_def_ecb(cname, kstruct, nid, block_size, key_len, iv_len, flags, \
d257 1
a257 1
#define IMPLEMENT_CFBR(cipher,cprefix,kstruct,ksched,keysize,cbits,iv_len,fl) \
d261 80
a340 2
			     (fl)|EVP_CIPH_FLAG_DEFAULT_ASN1, \
			     cipher##_init_key, NULL, NULL, NULL, NULL)
a341 14
#ifdef OPENSSL_FIPS
#define RC2_set_key	private_RC2_set_key
#define RC4_set_key	private_RC4_set_key
#define CAST_set_key	private_CAST_set_key
#define RC5_32_set_key	private_RC5_32_set_key
#define BF_set_key	private_BF_set_key
#define Camellia_set_key private_Camellia_set_key
#define idea_set_encrypt_key private_idea_set_encrypt_key

#define MD5_Init	private_MD5_Init
#define MD4_Init	private_MD4_Init
#define MD2_Init	private_MD2_Init
#define MDC2_Init	private_MDC2_Init
#define SHA_Init	private_SHA_Init
d343 1
a343 1
#endif
d345 1
@


1.5
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
d95 1
a95 1
	cprefix##_cfb##cbits##_encrypt(in, out, (long)(cbits==1?inl*8:inl), &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num, ctx->encrypt);\
d229 1
a229 1
#define IMPLEMENT_CFBR(cipher,cprefix,kstruct,ksched,keysize,cbits,iv_len) \
d233 20
a252 4
			     0, cipher##_init_key, NULL, \
			     EVP_CIPHER_set_asn1_iv, \
			     EVP_CIPHER_get_asn1_iv, \
			     NULL)
@


1.4
log
@resolve conflicts
@
text
@d68 1
a68 1
	for(i=0; i <= inl; i+=bl) \
d95 1
a95 1
	cprefix##_cfb##cbits##_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num, ctx->encrypt);\
d229 1
a229 1
#define IMPLEMENT_CFBR(cipher,cprefix,kstruct,ksched,keysize,cbits,iv_len,flags) \
d233 1
a233 1
			     flags, cipher##_init_key, NULL, \
a236 16

#ifdef OPENSSL_FIPS
#define RC2_set_key	private_RC2_set_key
#define RC4_set_key	private_RC4_set_key
#define CAST_set_key	private_CAST_set_key
#define RC5_32_set_key	private_RC5_32_set_key
#define BF_set_key	private_BF_set_key
#define idea_set_encrypt_key private_idea_set_encrypt_key

#define MD5_Init	private_MD5_Init
#define MD4_Init	private_MD4_Init
#define MD2_Init	private_MD2_Init
#define MDC2_Init	private_MDC2_Init
#define SHA_Init	private_SHA_Init

#endif
@


1.3
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d93 1
a93 1
static int cname##_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int inl) \
d130 1
a130 1
BLOCK_CIPHER_def1(cname, cfb##cbits, cfb, CFB, kstruct, nid, 1, \
d228 25
@


1.2
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d127 1
a127 1
#define BLOCK_CIPHER_def_cfb(cname, kstruct, nid, block_size, key_len, \
d130 1
a130 1
BLOCK_CIPHER_def1(cname, cfb##cbits, cfb, CFB, kstruct, nid, block_size, \
d134 1
a134 1
#define BLOCK_CIPHER_def_ofb(cname, kstruct, nid, block_size, key_len, \
d137 1
a137 1
BLOCK_CIPHER_def1(cname, ofb##cbits, ofb, OFB, kstruct, nid, block_size, \
d152 1
a152 1
BLOCK_CIPHER_def_cfb(cname, kstruct, nid, block_size, key_len, iv_len, cbits, \
d154 1
a154 1
BLOCK_CIPHER_def_ofb(cname, kstruct, nid, block_size, key_len, iv_len, cbits, \
@


1.1
log
@openssl-engine-0.9.6 merge
@
text
@d64 5
a68 4
	unsigned int i; \
	if(inl < 8) return 1;\
	inl -= 8; \
	for(i=0; i <= inl; i+=8) \
d70 1
a70 1
#define BLOCK_CIPHER_func_ecb(cname, cprefix, kname) \
d74 1
a74 1
		cprefix##_ecb_encrypt(in + i, out + i, &ctx->c.kname, ctx->encrypt);\
d78 1
a78 1
#define BLOCK_CIPHER_func_ofb(cname, cprefix, kname) \
d81 1
a81 1
	cprefix##_ofb64_encrypt(in, out, (long)inl, &ctx->c.kname, ctx->iv, &ctx->num);\
d85 1
a85 1
#define BLOCK_CIPHER_func_cbc(cname, cprefix, kname) \
d88 1
a88 1
	cprefix##_cbc_encrypt(in, out, (long)inl, &ctx->c.kname, ctx->iv, ctx->encrypt);\
d92 1
a92 1
#define BLOCK_CIPHER_func_cfb(cname, cprefix, kname) \
d95 1
a95 1
	cprefix##_cfb64_encrypt(in, out, (long)inl, &ctx->c.kname, ctx->iv, &ctx->num, ctx->encrypt);\
d99 47
a145 5
#define BLOCK_CIPHER_all_funcs(cname, cprefix, kname) \
	BLOCK_CIPHER_func_cbc(cname, cprefix, kname) \
	BLOCK_CIPHER_func_cfb(cname, cprefix, kname) \
	BLOCK_CIPHER_func_ecb(cname, cprefix, kname) \
	BLOCK_CIPHER_func_ofb(cname, cprefix, kname)
d148 14
d164 1
a164 1
static EVP_CIPHER cname##_cbc = {\
d176 2
a177 2
EVP_CIPHER *EVP_##cname##_cbc(void) { return &cname##_cbc; }\
static EVP_CIPHER cname##_cfb = {\
d189 2
a190 2
EVP_CIPHER *EVP_##cname##_cfb(void) { return &cname##_cfb; }\
static EVP_CIPHER cname##_ofb = {\
d202 2
a203 2
EVP_CIPHER *EVP_##cname##_ofb(void) { return &cname##_ofb; }\
static EVP_CIPHER cname##_ecb = {\
d215 2
a216 3
EVP_CIPHER *EVP_##cname##_ecb(void) { return &cname##_ecb; }


d218 8
a225 6
#define IMPLEMENT_BLOCK_CIPHER(cname, kname, cprefix, kstruct, \
				nid, block_size, key_len, iv_len, flags, \
				 init_key, cleanup, set_asn1, get_asn1, ctrl) \
	BLOCK_CIPHER_all_funcs(cname, cprefix, kname) \
	BLOCK_CIPHER_defs(cname, kstruct, nid, block_size, key_len, iv_len, flags,\
		 init_key, cleanup, set_asn1, get_asn1, ctrl) 
d227 1
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d64 4
a67 5
	unsigned int i, bl; \
	bl = ctx->cipher->block_size;\
	if(inl < bl) return 1;\
	inl -= bl; \
	for(i=0; i <= inl; i+=bl) \
d69 1
a69 1
#define BLOCK_CIPHER_func_ecb(cname, cprefix, kstruct, ksched) \
d73 1
a73 1
		cprefix##_ecb_encrypt(in + i, out + i, &((kstruct *)ctx->cipher_data)->ksched, ctx->encrypt);\
d77 1
a77 1
#define BLOCK_CIPHER_func_ofb(cname, cprefix, cbits, kstruct, ksched) \
d80 1
a80 1
	cprefix##_ofb##cbits##_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num);\
d84 1
a84 1
#define BLOCK_CIPHER_func_cbc(cname, cprefix, kstruct, ksched) \
d87 1
a87 1
	cprefix##_cbc_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, ctx->encrypt);\
d91 1
a91 1
#define BLOCK_CIPHER_func_cfb(cname, cprefix, cbits, kstruct, ksched) \
d94 1
a94 1
	cprefix##_cfb##cbits##_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num, ctx->encrypt);\
d98 5
a102 47
#define BLOCK_CIPHER_all_funcs(cname, cprefix, cbits, kstruct, ksched) \
	BLOCK_CIPHER_func_cbc(cname, cprefix, kstruct, ksched) \
	BLOCK_CIPHER_func_cfb(cname, cprefix, cbits, kstruct, ksched) \
	BLOCK_CIPHER_func_ecb(cname, cprefix, kstruct, ksched) \
	BLOCK_CIPHER_func_ofb(cname, cprefix, cbits, kstruct, ksched)

#define BLOCK_CIPHER_def1(cname, nmode, mode, MODE, kstruct, nid, block_size, \
			  key_len, iv_len, flags, init_key, cleanup, \
			  set_asn1, get_asn1, ctrl) \
static const EVP_CIPHER cname##_##mode = { \
	nid##_##nmode, block_size, key_len, iv_len, \
	flags | EVP_CIPH_##MODE##_MODE, \
	init_key, \
	cname##_##mode##_cipher, \
	cleanup, \
	sizeof(kstruct), \
	set_asn1, get_asn1,\
	ctrl, \
	NULL \
}; \
const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }

#define BLOCK_CIPHER_def_cbc(cname, kstruct, nid, block_size, key_len, \
			     iv_len, flags, init_key, cleanup, set_asn1, \
			     get_asn1, ctrl) \
BLOCK_CIPHER_def1(cname, cbc, cbc, CBC, kstruct, nid, block_size, key_len, \
		  iv_len, flags, init_key, cleanup, set_asn1, get_asn1, ctrl)

#define BLOCK_CIPHER_def_cfb(cname, kstruct, nid, block_size, key_len, \
			     iv_len, cbits, flags, init_key, cleanup, \
			     set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def1(cname, cfb##cbits, cfb, CFB, kstruct, nid, block_size, \
		  key_len, iv_len, flags, init_key, cleanup, set_asn1, \
		  get_asn1, ctrl)

#define BLOCK_CIPHER_def_ofb(cname, kstruct, nid, block_size, key_len, \
			     iv_len, cbits, flags, init_key, cleanup, \
			     set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def1(cname, ofb##cbits, ofb, OFB, kstruct, nid, block_size, \
		  key_len, iv_len, flags, init_key, cleanup, set_asn1, \
		  get_asn1, ctrl)

#define BLOCK_CIPHER_def_ecb(cname, kstruct, nid, block_size, key_len, \
			     iv_len, flags, init_key, cleanup, set_asn1, \
			     get_asn1, ctrl) \
BLOCK_CIPHER_def1(cname, ecb, ecb, ECB, kstruct, nid, block_size, key_len, \
		  iv_len, flags, init_key, cleanup, set_asn1, get_asn1, ctrl)
a104 14
			  nid, block_size, key_len, iv_len, cbits, flags, \
			  init_key, cleanup, set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def_cbc(cname, kstruct, nid, block_size, key_len, iv_len, flags, \
		     init_key, cleanup, set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def_cfb(cname, kstruct, nid, block_size, key_len, iv_len, cbits, \
		     flags, init_key, cleanup, set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def_ofb(cname, kstruct, nid, block_size, key_len, iv_len, cbits, \
		     flags, init_key, cleanup, set_asn1, get_asn1, ctrl) \
BLOCK_CIPHER_def_ecb(cname, kstruct, nid, block_size, key_len, iv_len, flags, \
		     init_key, cleanup, set_asn1, get_asn1, ctrl)


/*
#define BLOCK_CIPHER_defs(cname, kstruct, \
d107 1
a107 1
static const EVP_CIPHER cname##_cbc = {\
d119 2
a120 2
const EVP_CIPHER *EVP_##cname##_cbc(void) { return &cname##_cbc; }\
static const EVP_CIPHER cname##_cfb = {\
d132 2
a133 2
const EVP_CIPHER *EVP_##cname##_cfb(void) { return &cname##_cfb; }\
static const EVP_CIPHER cname##_ofb = {\
d145 2
a146 2
const EVP_CIPHER *EVP_##cname##_ofb(void) { return &cname##_ofb; }\
static const EVP_CIPHER cname##_ecb = {\
d158 3
a160 2
const EVP_CIPHER *EVP_##cname##_ecb(void) { return &cname##_ecb; }
*/
d162 6
a167 8
#define IMPLEMENT_BLOCK_CIPHER(cname, ksched, cprefix, kstruct, nid, \
			       block_size, key_len, iv_len, cbits, \
			       flags, init_key, \
			       cleanup, set_asn1, get_asn1, ctrl) \
	BLOCK_CIPHER_all_funcs(cname, cprefix, cbits, kstruct, ksched) \
	BLOCK_CIPHER_defs(cname, kstruct, nid, block_size, key_len, iv_len, \
			  cbits, flags, init_key, cleanup, set_asn1, \
			  get_asn1, ctrl)
a168 1
#define EVP_C_DATA(kstruct, ctx)	((kstruct *)(ctx)->cipher_data)
@


1.1.1.2
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d127 1
a127 1
#define BLOCK_CIPHER_def_cfb(cname, kstruct, nid, key_len, \
d130 1
a130 1
BLOCK_CIPHER_def1(cname, cfb##cbits, cfb, CFB, kstruct, nid, 1, \
d134 1
a134 1
#define BLOCK_CIPHER_def_ofb(cname, kstruct, nid, key_len, \
d137 1
a137 1
BLOCK_CIPHER_def1(cname, ofb##cbits, ofb, OFB, kstruct, nid, 1, \
d152 1
a152 1
BLOCK_CIPHER_def_cfb(cname, kstruct, nid, key_len, iv_len, cbits, \
d154 1
a154 1
BLOCK_CIPHER_def_ofb(cname, kstruct, nid, key_len, iv_len, cbits, \
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d93 1
a93 1
static int cname##_cfb##cbits##_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int inl) \
d130 1
a130 1
BLOCK_CIPHER_def1(cname, cfb##cbits, cfb##cbits, CFB, kstruct, nid, 1, \
a227 25

#define IMPLEMENT_CFBR(cipher,cprefix,kstruct,ksched,keysize,cbits,iv_len,flags) \
	BLOCK_CIPHER_func_cfb(cipher##_##keysize,cprefix,cbits,kstruct,ksched) \
	BLOCK_CIPHER_def_cfb(cipher##_##keysize,kstruct, \
			     NID_##cipher##_##keysize, keysize/8, iv_len, cbits, \
			     flags, cipher##_init_key, NULL, \
			     EVP_CIPHER_set_asn1_iv, \
			     EVP_CIPHER_get_asn1_iv, \
			     NULL)

#ifdef OPENSSL_FIPS
#define RC2_set_key	private_RC2_set_key
#define RC4_set_key	private_RC4_set_key
#define CAST_set_key	private_CAST_set_key
#define RC5_32_set_key	private_RC5_32_set_key
#define BF_set_key	private_BF_set_key
#define idea_set_encrypt_key private_idea_set_encrypt_key

#define MD5_Init	private_MD5_Init
#define MD4_Init	private_MD4_Init
#define MD2_Init	private_MD2_Init
#define MDC2_Init	private_MDC2_Init
#define SHA_Init	private_SHA_Init

#endif
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d68 1
a68 1
	for(i=0; i <= inl; i+=bl) 
d95 1
a95 1
	cprefix##_cfb##cbits##_encrypt(in, out, (long)(cbits==1?inl*8:inl), &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num, ctx->encrypt);\
d229 1
a229 1
#define IMPLEMENT_CFBR(cipher,cprefix,kstruct,ksched,keysize,cbits,iv_len) \
d233 1
a233 1
			     0, cipher##_init_key, NULL, \
d237 16
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
d95 1
a95 1
	cprefix##_cfb##cbits##_encrypt(in, out, (long)((cbits==1) && !(ctx->flags & EVP_CIPH_FLAG_LENGTH_BITS) ?inl*8:inl), &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num, ctx->encrypt);\
d229 1
a229 1
#define IMPLEMENT_CFBR(cipher,cprefix,kstruct,ksched,keysize,cbits,iv_len,fl) \
d233 4
a236 20
			     (fl)|EVP_CIPH_FLAG_DEFAULT_ASN1, \
			     cipher##_init_key, NULL, NULL, NULL, NULL)

#ifdef OPENSSL_FIPS
#define RC2_set_key	private_RC2_set_key
#define RC4_set_key	private_RC4_set_key
#define CAST_set_key	private_CAST_set_key
#define RC5_32_set_key	private_RC5_32_set_key
#define BF_set_key	private_BF_set_key
#define Camellia_set_key private_Camellia_set_key
#define idea_set_encrypt_key private_idea_set_encrypt_key

#define MD5_Init	private_MD5_Init
#define MD4_Init	private_MD4_Init
#define MD2_Init	private_MD2_Init
#define MDC2_Init	private_MDC2_Init
#define SHA_Init	private_SHA_Init

#endif

@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d64 1
a64 1
	size_t i, bl; \
d71 1
a71 1
static int cname##_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
a77 2
#define EVP_MAXCHUNK ((size_t)1<<(sizeof(long)*8-2))

d79 1
a79 1
static int cname##_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
d81 1
a81 9
	while(inl>=EVP_MAXCHUNK)\
	    {\
	    cprefix##_ofb##cbits##_encrypt(in, out, (long)EVP_MAXCHUNK, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num);\
	    inl-=EVP_MAXCHUNK;\
	    in +=EVP_MAXCHUNK;\
	    out+=EVP_MAXCHUNK;\
	    }\
	if (inl)\
	    cprefix##_ofb##cbits##_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num);\
d86 1
a86 1
static int cname##_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
d88 1
a88 9
	while(inl>=EVP_MAXCHUNK) \
	    {\
	    cprefix##_cbc_encrypt(in, out, (long)EVP_MAXCHUNK, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, ctx->encrypt);\
	    inl-=EVP_MAXCHUNK;\
	    in +=EVP_MAXCHUNK;\
	    out+=EVP_MAXCHUNK;\
	    }\
	if (inl)\
	    cprefix##_cbc_encrypt(in, out, (long)inl, &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, ctx->encrypt);\
d93 1
a93 1
static int cname##_cfb##cbits##_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
d95 1
a95 11
	size_t chunk=EVP_MAXCHUNK;\
	if (cbits==1)  chunk>>=3;\
	if (inl<chunk) chunk=inl;\
	while(inl && inl>=chunk)\
	    {\
            cprefix##_cfb##cbits##_encrypt(in, out, (long)((cbits==1) && !(ctx->flags & EVP_CIPH_FLAG_LENGTH_BITS) ?inl*8:inl), &((kstruct *)ctx->cipher_data)->ksched, ctx->iv, &ctx->num, ctx->encrypt);\
	    inl-=chunk;\
	    in +=chunk;\
	    out+=chunk;\
	    if(inl<chunk) chunk=inl;\
	    }\
d142 1
a142 1
			     flags, init_key, cleanup, set_asn1, \
d145 1
a145 1
		  0, flags, init_key, cleanup, set_asn1, get_asn1, ctrl)
d156 1
a156 1
BLOCK_CIPHER_def_ecb(cname, kstruct, nid, block_size, key_len, flags, \
d229 1
a229 1
#define IMPLEMENT_CFBR(cipher,cprefix,kstruct,ksched,keysize,cbits,iv_len) \
d233 2
a234 80
			     0, cipher##_init_key, NULL, \
			     EVP_CIPHER_set_asn1_iv, \
			     EVP_CIPHER_get_asn1_iv, \
			     NULL)

struct evp_pkey_ctx_st
	{
	/* Method associated with this operation */
	const EVP_PKEY_METHOD *pmeth;
	/* Engine that implements this method or NULL if builtin */
	ENGINE *engine;
	/* Key: may be NULL */
	EVP_PKEY *pkey;
	/* Peer key for key agreement, may be NULL */
	EVP_PKEY *peerkey;
	/* Actual operation */
	int operation;
	/* Algorithm specific data */
	void *data;
	/* Application specific data */
	void *app_data;
	/* Keygen callback */
	EVP_PKEY_gen_cb *pkey_gencb;
	/* implementation specific keygen data */
	int *keygen_info;
	int keygen_info_count;
	} /* EVP_PKEY_CTX */;

#define EVP_PKEY_FLAG_DYNAMIC	1

struct evp_pkey_method_st
	{
	int pkey_id;
	int flags;

	int (*init)(EVP_PKEY_CTX *ctx);
	int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src);
	void (*cleanup)(EVP_PKEY_CTX *ctx);

	int (*paramgen_init)(EVP_PKEY_CTX *ctx);
	int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);

	int (*keygen_init)(EVP_PKEY_CTX *ctx);
	int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);

	int (*sign_init)(EVP_PKEY_CTX *ctx);
	int (*sign)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
				const unsigned char *tbs, size_t tbslen);

	int (*verify_init)(EVP_PKEY_CTX *ctx);
	int (*verify)(EVP_PKEY_CTX *ctx,
				const unsigned char *sig, size_t siglen,
				const unsigned char *tbs, size_t tbslen);

	int (*verify_recover_init)(EVP_PKEY_CTX *ctx);
	int (*verify_recover)(EVP_PKEY_CTX *ctx,
				unsigned char *rout, size_t *routlen,
				const unsigned char *sig, size_t siglen);

	int (*signctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);
	int (*signctx)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
					EVP_MD_CTX *mctx);

	int (*verifyctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);
	int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig,int siglen,
					EVP_MD_CTX *mctx);

	int (*encrypt_init)(EVP_PKEY_CTX *ctx);
	int (*encrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
					const unsigned char *in, size_t inlen);

	int (*decrypt_init)(EVP_PKEY_CTX *ctx);
	int (*decrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
					const unsigned char *in, size_t inlen);

	int (*derive_init)(EVP_PKEY_CTX *ctx);
	int (*derive)(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);

	int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2);
	int (*ctrl_str)(EVP_PKEY_CTX *ctx, const char *type, const char *value);
d236 14
d251 1
a251 1
	} /* EVP_PKEY_METHOD */;
a252 1
void evp_pkey_set_cb_translate(BN_GENCB *cb, EVP_PKEY_CTX *ctx);
@


1.1.1.7
log
@import OpenSSL-1.0.1c
@
text
@a345 40

int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
			     ASN1_TYPE *param,
			     const EVP_CIPHER *c, const EVP_MD *md, int en_de);

#ifdef OPENSSL_FIPS

#ifdef OPENSSL_DOING_MAKEDEPEND
#undef SHA1_Init
#undef SHA1_Update
#undef SHA224_Init
#undef SHA256_Init
#undef SHA384_Init
#undef SHA512_Init
#undef DES_set_key_unchecked
#endif

#define RIPEMD160_Init	private_RIPEMD160_Init
#define WHIRLPOOL_Init	private_WHIRLPOOL_Init
#define MD5_Init	private_MD5_Init
#define MD4_Init	private_MD4_Init
#define MD2_Init	private_MD2_Init
#define MDC2_Init	private_MDC2_Init
#define SHA_Init	private_SHA_Init
#define SHA1_Init	private_SHA1_Init
#define SHA224_Init	private_SHA224_Init
#define SHA256_Init	private_SHA256_Init
#define SHA384_Init	private_SHA384_Init
#define SHA512_Init	private_SHA512_Init

#define BF_set_key	private_BF_set_key
#define CAST_set_key	private_CAST_set_key
#define idea_set_encrypt_key	private_idea_set_encrypt_key
#define SEED_set_key	private_SEED_set_key
#define RC2_set_key	private_RC2_set_key
#define RC4_set_key	private_RC4_set_key
#define DES_set_key_unchecked	private_DES_set_key_unchecked
#define Camellia_set_key	private_Camellia_set_key

#endif
@


