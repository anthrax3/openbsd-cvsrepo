head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.2
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14;
locks; strict;
comment	@ * @;


1.14
date	2015.10.12.06.05.52;	author guenther;	state Exp;
branches;
next	1.13;
commitid	XtM3j06CHORsUpUU;

1.13
date	2014.10.18.17.20.40;	author jsing;	state Exp;
branches;
next	1.12;
commitid	8tb4v3IC8S2vzfHj;

1.12
date	2014.07.22.18.10.48;	author miod;	state Exp;
branches;
next	1.11;
commitid	iGNbrRmhpMOkiz6b;

1.11
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.10;
commitid	yQEL1wOWIearrW15;

1.10
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.9;
commitid	nzndm3zqPmFurSaK;

1.9
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	mJUVYpkFBZ0Zv2bG;

1.8
date	2014.05.15.15.55.55;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2014.05.08.15.13.06;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.29.05.39.21;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.15.02.57.41;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.27;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.05.37.10;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.13.56;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.07;	author djm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@unifdef EVP_CHECK_DES_KEY: Ben Kaduk noticed it has a syntax error; that
error was present in the original 2004 commit, so it hasn't been used in
over 11 years, thus exceeding our deprecation requirements by over a decade.
OpenSSL has chosen to *fix it*; we'll gladly watch it burn

ok jsing@@
@
text
@/* $OpenBSD: e_des.c,v 1.13 2014/10/18 17:20:40 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>

#include <openssl/opensslconf.h>

#ifndef OPENSSL_NO_DES

#include <openssl/evp.h>
#include <openssl/des.h>
#include <openssl/objects.h>

#include "evp_locl.h"

static int des_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc);
static int des_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr);

/* Because of various casts and different names can't use IMPLEMENT_BLOCK_CIPHER */

static int
des_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t inl)
{
	BLOCK_CIPHER_ecb_loop()
		DES_ecb_encrypt((DES_cblock *)(in + i), (DES_cblock *)(out + i),
		    ctx->cipher_data, ctx->encrypt);
	return 1;
}

static int
des_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t inl)
{
	while (inl >= EVP_MAXCHUNK) {
		DES_ofb64_encrypt(in, out, (long)EVP_MAXCHUNK, ctx->cipher_data,
		    (DES_cblock *)ctx->iv, &ctx->num);
		inl -= EVP_MAXCHUNK;
		in += EVP_MAXCHUNK;
		out += EVP_MAXCHUNK;
	}
	if (inl)
		DES_ofb64_encrypt(in, out, (long)inl, ctx->cipher_data,
		    (DES_cblock *)ctx->iv, &ctx->num);
	return 1;
}

static int
des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t inl)
{
	while (inl >= EVP_MAXCHUNK) {
		DES_ncbc_encrypt(in, out, (long)EVP_MAXCHUNK, ctx->cipher_data,
		    (DES_cblock *)ctx->iv, ctx->encrypt);
		inl -= EVP_MAXCHUNK;
		in += EVP_MAXCHUNK;
		out += EVP_MAXCHUNK;
	}
	if (inl)
		DES_ncbc_encrypt(in, out, (long)inl, ctx->cipher_data,
		    (DES_cblock *)ctx->iv, ctx->encrypt);
	return 1;
}

static int
des_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t inl)
{
	while (inl >= EVP_MAXCHUNK) {
		DES_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK, ctx->cipher_data,
		    (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);
		inl -= EVP_MAXCHUNK;
		in += EVP_MAXCHUNK;
		out += EVP_MAXCHUNK;
	}
	if (inl)
		DES_cfb64_encrypt(in, out, (long)inl, ctx->cipher_data,
		    (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);
	return 1;
}

/* Although we have a CFB-r implementation for DES, it doesn't pack the right
   way, so wrap it here */
static int
des_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t inl)
{
	size_t n, chunk = EVP_MAXCHUNK/8;
	unsigned char c[1], d[1];

	if (inl < chunk)
		chunk = inl;

	while (inl && inl >= chunk) {
		for (n = 0; n < chunk*8; ++n) {
			c[0] = (in[n / 8] & (1 << (7 - n % 8))) ? 0x80 : 0;
			DES_cfb_encrypt(c, d, 1, 1, ctx->cipher_data,
			    (DES_cblock *)ctx->iv, ctx->encrypt);
			out[n / 8] = (out[n / 8] &
			    ~(0x80 >> (unsigned int)(n % 8))) |
			    ((d[0] & 0x80) >> (unsigned int)(n % 8));
		}
		inl -= chunk;
		in += chunk;
		out += chunk;
		if (inl < chunk)
			chunk = inl;
	}

	return 1;
}

static int
des_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t inl)
{
	while (inl >= EVP_MAXCHUNK) {
		DES_cfb_encrypt(in, out, 8, (long)EVP_MAXCHUNK,
		    ctx->cipher_data, (DES_cblock *)ctx->iv, ctx->encrypt);
		inl -= EVP_MAXCHUNK;
		in += EVP_MAXCHUNK;
		out += EVP_MAXCHUNK;
	}
	if (inl)
		DES_cfb_encrypt(in, out, 8, (long)inl, ctx->cipher_data,
		    (DES_cblock *)ctx->iv, ctx->encrypt);
	return 1;
}

BLOCK_CIPHER_defs(des, DES_key_schedule, NID_des, 8, 8, 8, 64,
    EVP_CIPH_RAND_KEY, des_init_key, NULL,
    EVP_CIPHER_set_asn1_iv,
    EVP_CIPHER_get_asn1_iv,
    des_ctrl)

BLOCK_CIPHER_def_cfb(des, DES_key_schedule, NID_des, 8, 8, 1,
    EVP_CIPH_RAND_KEY, des_init_key, NULL,
    EVP_CIPHER_set_asn1_iv,
    EVP_CIPHER_get_asn1_iv, des_ctrl)

BLOCK_CIPHER_def_cfb(des, DES_key_schedule, NID_des, 8, 8, 8,
    EVP_CIPH_RAND_KEY, des_init_key, NULL,
    EVP_CIPHER_set_asn1_iv,
    EVP_CIPHER_get_asn1_iv, des_ctrl)

static int
des_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	DES_cblock *deskey = (DES_cblock *)key;

	DES_set_key_unchecked(deskey, ctx->cipher_data);
	return 1;
}

static int
des_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
{
	switch (type) {
	case EVP_CTRL_RAND_KEY:
		if (DES_random_key((DES_cblock *)ptr) == 0)
			return 0;
		return 1;

	default:
		return -1;
	}
}

#endif
@


1.13
log
@None of these need to include <openssl/rand.h>
@
text
@d1 1
a1 1
/* $OpenBSD: e_des.c,v 1.12 2014/07/22 18:10:48 miod Exp $ */
a207 4
#ifdef EVP_CHECK_DES_KEY
	if (DES_set_key_checked(deskey, ctx->cipher_data) != 0)
		return 0;
#else
a208 1
#endif
@


1.12
log
@Now that DES_random_key() can be trusted, use it to generate DES keys in the
EVP_CTRL_RAND_KEY method handlers, rather than generating a random odd key and
not even checking it against the weak keys list.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_des.c,v 1.11 2014/07/11 08:44:48 jsing Exp $ */
a67 1
#include <openssl/rand.h>
@


1.11
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_des.c,v 1.10 2014/07/10 22:45:57 jsing Exp $ */
d83 2
a84 2
	DES_ecb_encrypt((DES_cblock *)(in + i), (DES_cblock *)(out + i),
	    ctx->cipher_data, ctx->encrypt);
d223 1
a223 1
		if (RAND_bytes(ptr, 8) <= 0)
a224 1
		DES_set_odd_parity((DES_cblock *)ptr);
@


1.10
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: e_des.c,v 1.9 2014/06/12 15:49:29 deraadt Exp $ */
a62 1
#include "cryptlib.h"
d64 1
d66 1
d68 2
a70 2
#include <openssl/des.h>
#include <openssl/rand.h>
@


1.9
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 3
@


1.8
log
@More KNF.
@
text
@d1 1
a1 1
/* crypto/evp/e_des.c */
@


1.7
log
@KNF.
@
text
@d178 1
a178 1
		DES_cfb_encrypt(in, out, 8,(long)inl, ctx->cipher_data,
d189 1
a189 1
BLOCK_CIPHER_def_cfb(des, DES_key_schedule, NID_des, 8,8, 1,
d194 1
a194 1
BLOCK_CIPHER_def_cfb(des, DES_key_schedule, NID_des, 8,8, 8,
@


1.6
log
@resolve conflicts, fix local changes
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d69 1
a69 1
			const unsigned char *iv, int enc);
d74 3
a76 2
static int des_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			  const unsigned char *in, size_t inl)
d79 2
a80 1
		DES_ecb_encrypt((DES_cblock *)(in + i), (DES_cblock *)(out + i), ctx->cipher_data, ctx->encrypt);
d84 3
a86 2
static int des_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			  const unsigned char *in, size_t inl)
d88 1
a88 2
	while(inl>=EVP_MAXCHUNK)
		{
d90 5
a94 5
				(DES_cblock *)ctx->iv, &ctx->num);
		inl-=EVP_MAXCHUNK;
		in +=EVP_MAXCHUNK;
		out+=EVP_MAXCHUNK;
		}
d97 1
a97 1
				(DES_cblock *)ctx->iv, &ctx->num);
d101 3
a103 2
static int des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			  const unsigned char *in, size_t inl)
d105 1
a105 2
	while(inl>=EVP_MAXCHUNK)
		{
d107 5
a111 5
				(DES_cblock *)ctx->iv, ctx->encrypt);
		inl-=EVP_MAXCHUNK;
		in +=EVP_MAXCHUNK;
		out+=EVP_MAXCHUNK;
		}
d114 1
a114 1
				(DES_cblock *)ctx->iv, ctx->encrypt);
d118 3
a120 2
static int des_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			    const unsigned char *in, size_t inl)
d122 7
a128 8
	while(inl>=EVP_MAXCHUNK)
		{
		DES_cfb64_encrypt(in,out, (long)EVP_MAXCHUNK, ctx->cipher_data,
				(DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);
		inl-=EVP_MAXCHUNK;
		in +=EVP_MAXCHUNK;
		out+=EVP_MAXCHUNK;
		}
d131 1
a131 1
			  (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);
d137 45
a181 43
static int des_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			   const unsigned char *in, size_t inl)
    {
    size_t n,chunk=EVP_MAXCHUNK/8;
    unsigned char c[1],d[1];

    if (inl<chunk) chunk=inl;

    while (inl && inl>=chunk)
	{
	for(n=0 ; n < chunk*8; ++n)
	    {
	    c[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;
	    DES_cfb_encrypt(c,d,1,1,ctx->cipher_data,(DES_cblock *)ctx->iv,
			ctx->encrypt);
	    out[n/8]=(out[n/8]&~(0x80 >> (unsigned int)(n%8))) |
		     ((d[0]&0x80) >> (unsigned int)(n%8));
	    }
	inl-=chunk;
	in +=chunk;
	out+=chunk;
	if (inl<chunk) chunk=inl;
	}

    return 1;
    }

static int des_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			   const unsigned char *in, size_t inl)
    {
    while (inl>=EVP_MAXCHUNK)
	{
	DES_cfb_encrypt(in,out,8,(long)EVP_MAXCHUNK,ctx->cipher_data,
			(DES_cblock *)ctx->iv,ctx->encrypt);
	inl-=EVP_MAXCHUNK;
	in +=EVP_MAXCHUNK;
	out+=EVP_MAXCHUNK;
	}
    if (inl)
	DES_cfb_encrypt(in,out,8,(long)inl,ctx->cipher_data,
			(DES_cblock *)ctx->iv,ctx->encrypt);
    return 1;
    }
d184 20
a203 14
			EVP_CIPH_RAND_KEY, des_init_key, NULL,
			EVP_CIPHER_set_asn1_iv,
			EVP_CIPHER_get_asn1_iv,
			des_ctrl)

BLOCK_CIPHER_def_cfb(des,DES_key_schedule,NID_des,8,8,1,
		     EVP_CIPH_RAND_KEY, des_init_key,NULL,
		     EVP_CIPHER_set_asn1_iv,
		     EVP_CIPHER_get_asn1_iv,des_ctrl)

BLOCK_CIPHER_def_cfb(des,DES_key_schedule,NID_des,8,8,8,
		     EVP_CIPH_RAND_KEY,des_init_key,NULL,
		     EVP_CIPHER_set_asn1_iv,
		     EVP_CIPHER_get_asn1_iv,des_ctrl)
a204 4
static int des_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
			const unsigned char *iv, int enc)
	{
	DES_cblock *deskey = (DES_cblock *)key;
d206 1
a206 1
	if(DES_set_key_checked(deskey,ctx->cipher_data) != 0)
d209 1
a209 1
	DES_set_key_unchecked(deskey,ctx->cipher_data);
d212 1
a212 1
	}
d214 4
a217 5
static int des_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
	{
	
	switch(type)
		{
a225 1
		}
d227 1
@


1.5
log
@resolve conflicts
@
text
@d75 1
a75 1
			  const unsigned char *in, unsigned int inl)
d83 1
a83 1
			  const unsigned char *in, unsigned int inl)
d85 11
a95 1
	DES_ofb64_encrypt(in, out, (long)inl, ctx->cipher_data, (DES_cblock *)ctx->iv, &ctx->num);
d100 1
a100 1
			  const unsigned char *in, unsigned int inl)
d102 11
a112 2
	DES_ncbc_encrypt(in, out, (long)inl, ctx->cipher_data,
			 (DES_cblock *)ctx->iv, ctx->encrypt);
d117 1
a117 1
			    const unsigned char *in, unsigned int inl)
d119 10
a128 1
	DES_cfb64_encrypt(in, out, (long)inl, ctx->cipher_data,
d136 1
a136 1
			   const unsigned char *in, unsigned int inl)
d138 1
a138 1
    unsigned int n;
d141 3
a143 1
    for(n=0 ; n < inl ; ++n)
d145 4
a148 2
	c[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;
	DES_cfb_encrypt(c,d,1,1,ctx->cipher_data,(DES_cblock *)ctx->iv,
d150 7
a156 1
	out[n/8]=(out[n/8]&~(0x80 >> (n%8)))|((d[0]&0x80) >> (n%8));
d158 1
d163 1
a163 1
			   const unsigned char *in, unsigned int inl)
d165 11
a175 2
    DES_cfb_encrypt(in,out,8,inl,ctx->cipher_data,(DES_cblock *)ctx->iv,
		    ctx->encrypt);
d180 1
a180 2
			EVP_CIPH_RAND_KEY,
			des_init_key, NULL,
d186 1
a186 2
		     EVP_CIPH_RAND_KEY,
		     des_init_key, NULL,
d191 1
a191 2
		     EVP_CIPH_RAND_KEY,
		     des_init_key,NULL,
@


1.4
log
@resolve conflicts
@
text
@d132 2
a133 1
			EVP_CIPH_RAND_KEY, des_init_key, NULL,
d139 2
a140 1
		     EVP_CIPH_RAND_KEY, des_init_key,NULL,
d145 2
a146 1
		     EVP_CIPH_RAND_KEY,des_init_key,NULL,
@


1.3
log
@resolve conflicts
@
text
@d66 1
d70 1
d132 1
a132 1
			EVP_CIPH_FLAG_FIPS, des_init_key, NULL,
d135 1
a135 1
			NULL)
d138 1
a138 1
		     EVP_CIPH_FLAG_FIPS,des_init_key,NULL,
d140 1
a140 1
		     EVP_CIPHER_get_asn1_iv,NULL)
d143 1
a143 1
		     EVP_CIPH_FLAG_FIPS,des_init_key,NULL,
d145 1
a145 1
		     EVP_CIPHER_get_asn1_iv,NULL)
d151 4
a154 1

d156 1
d158 16
@


1.2
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a58 1
#ifndef OPENSSL_NO_DES
d61 1
d95 2
a96 2
static int des_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			  const unsigned char *in, unsigned int inl)
d103 26
d130 1
a130 1
			0, des_init_key, NULL,
d135 9
@


1.1
log
@openssl-engine-0.9.6 merge
@
text
@d59 1
a59 1
#ifndef NO_DES
d65 1
d76 1
a76 1
		des_ecb_encrypt((des_cblock *)(in + i), (des_cblock *)(out + i), ctx->c.des_ks, ctx->encrypt);
d83 1
a83 1
	des_ofb64_encrypt(in, out, (long)inl, ctx->c.des_ks, (des_cblock *)ctx->iv, &ctx->num);
d90 2
a91 2
	des_ncbc_encrypt(in, out, (long)inl, ctx->c.des_ks,
			 (des_cblock *)ctx->iv, ctx->encrypt);
d98 2
a99 2
	des_cfb64_encrypt(in, out, (long)inl, ctx->c.des_ks,
			  (des_cblock *)ctx->iv, &ctx->num, ctx->encrypt);
d103 1
a103 1
BLOCK_CIPHER_defs(des, des_ks, NID_des, 8, 8, 8,
d113 1
a113 1
	des_cblock *deskey = (des_cblock *)key;
d115 1
a115 1
	des_set_key_unchecked(deskey,ctx->c.des_ks);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d59 1
a59 1
#ifndef OPENSSL_NO_DES
a64 1
#include <openssl/des.h>
d75 1
a75 1
		DES_ecb_encrypt((DES_cblock *)(in + i), (DES_cblock *)(out + i), ctx->cipher_data, ctx->encrypt);
d82 1
a82 1
	DES_ofb64_encrypt(in, out, (long)inl, ctx->cipher_data, (DES_cblock *)ctx->iv, &ctx->num);
d89 2
a90 2
	DES_ncbc_encrypt(in, out, (long)inl, ctx->cipher_data,
			 (DES_cblock *)ctx->iv, ctx->encrypt);
d97 2
a98 2
	DES_cfb64_encrypt(in, out, (long)inl, ctx->cipher_data,
			  (DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);
d102 1
a102 1
BLOCK_CIPHER_defs(des, DES_key_schedule, NID_des, 8, 8, 8, 64,
d112 1
a112 1
	DES_cblock *deskey = (DES_cblock *)key;
d114 1
a114 1
	DES_set_key_unchecked(deskey,ctx->cipher_data);
@


1.1.1.2
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d59 1
a61 1
#ifndef OPENSSL_NO_DES
d95 2
a96 2
static int des_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			    const unsigned char *in, unsigned int inl)
a102 26
/* Although we have a CFB-r implementation for DES, it doesn't pack the right
   way, so wrap it here */
static int des_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			   const unsigned char *in, unsigned int inl)
    {
    unsigned int n;
    unsigned char c[1],d[1];

    for(n=0 ; n < inl ; ++n)
	{
	c[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;
	DES_cfb_encrypt(c,d,1,1,ctx->cipher_data,(DES_cblock *)ctx->iv,
			ctx->encrypt);
	out[n/8]=(out[n/8]&~(0x80 >> (n%8)))|((d[0]&0x80) >> (n%8));
	}
    return 1;
    }

static int des_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
			   const unsigned char *in, unsigned int inl)
    {
    DES_cfb_encrypt(in,out,8,inl,ctx->cipher_data,(DES_cblock *)ctx->iv,
		    ctx->encrypt);
    return 1;
    }

d104 1
a104 1
			EVP_CIPH_FLAG_FIPS, des_init_key, NULL,
a108 9
BLOCK_CIPHER_def_cfb(des,DES_key_schedule,NID_des,8,8,1,
		     EVP_CIPH_FLAG_FIPS,des_init_key,NULL,
		     EVP_CIPHER_set_asn1_iv,
		     EVP_CIPHER_get_asn1_iv,NULL)

BLOCK_CIPHER_def_cfb(des,DES_key_schedule,NID_des,8,8,8,
		     EVP_CIPH_FLAG_FIPS,des_init_key,NULL,
		     EVP_CIPHER_set_asn1_iv,
		     EVP_CIPHER_get_asn1_iv,NULL)
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@a65 1
#include <openssl/rand.h>
a68 1
static int des_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr);
d130 1
a130 1
			EVP_CIPH_RAND_KEY, des_init_key, NULL,
d133 1
a133 1
			des_ctrl)
d136 1
a136 1
		     EVP_CIPH_RAND_KEY, des_init_key,NULL,
d138 1
a138 1
		     EVP_CIPHER_get_asn1_iv,des_ctrl)
d141 1
a141 1
		     EVP_CIPH_RAND_KEY,des_init_key,NULL,
d143 1
a143 1
		     EVP_CIPHER_get_asn1_iv,des_ctrl)
d149 1
a149 4
#ifdef EVP_CHECK_DES_KEY
	if(DES_set_key_checked(deskey,ctx->cipher_data) != 0)
		return 0;
#else
a150 1
#endif
a151 16
	}

static int des_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
	{
	
	switch(type)
		{
	case EVP_CTRL_RAND_KEY:
		if (RAND_bytes(ptr, 8) <= 0)
			return 0;
		DES_set_odd_parity((DES_cblock *)ptr);
		return 1;

	default:
		return -1;
		}
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d132 1
a132 2
			EVP_CIPH_RAND_KEY,
			des_init_key, NULL,
d138 1
a138 2
		     EVP_CIPH_RAND_KEY,
		     des_init_key, NULL,
d143 1
a143 2
		     EVP_CIPH_RAND_KEY,
		     des_init_key,NULL,
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d75 1
a75 1
			  const unsigned char *in, size_t inl)
d83 1
a83 1
			  const unsigned char *in, size_t inl)
d85 1
a85 11
	while(inl>=EVP_MAXCHUNK)
		{
		DES_ofb64_encrypt(in, out, (long)EVP_MAXCHUNK, ctx->cipher_data,
				(DES_cblock *)ctx->iv, &ctx->num);
		inl-=EVP_MAXCHUNK;
		in +=EVP_MAXCHUNK;
		out+=EVP_MAXCHUNK;
		}
	if (inl)
		DES_ofb64_encrypt(in, out, (long)inl, ctx->cipher_data,
				(DES_cblock *)ctx->iv, &ctx->num);
d90 1
a90 1
			  const unsigned char *in, size_t inl)
d92 2
a93 11
	while(inl>=EVP_MAXCHUNK)
		{
		DES_ncbc_encrypt(in, out, (long)EVP_MAXCHUNK, ctx->cipher_data,
				(DES_cblock *)ctx->iv, ctx->encrypt);
		inl-=EVP_MAXCHUNK;
		in +=EVP_MAXCHUNK;
		out+=EVP_MAXCHUNK;
		}
	if (inl)
		DES_ncbc_encrypt(in, out, (long)inl, ctx->cipher_data,
				(DES_cblock *)ctx->iv, ctx->encrypt);
d98 1
a98 1
			    const unsigned char *in, size_t inl)
d100 1
a100 10
	while(inl>=EVP_MAXCHUNK)
		{
		DES_cfb64_encrypt(in,out, (long)EVP_MAXCHUNK, ctx->cipher_data,
				(DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);
		inl-=EVP_MAXCHUNK;
		in +=EVP_MAXCHUNK;
		out+=EVP_MAXCHUNK;
		}
	if (inl)
		DES_cfb64_encrypt(in, out, (long)inl, ctx->cipher_data,
d108 1
a108 1
			   const unsigned char *in, size_t inl)
d110 1
a110 1
    size_t n,chunk=EVP_MAXCHUNK/8;
d113 1
a113 3
    if (inl<chunk) chunk=inl;

    while (inl && inl>=chunk)
d115 2
a116 4
	for(n=0 ; n < chunk*8; ++n)
	    {
	    c[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;
	    DES_cfb_encrypt(c,d,1,1,ctx->cipher_data,(DES_cblock *)ctx->iv,
d118 1
a118 7
	    out[n/8]=(out[n/8]&~(0x80 >> (unsigned int)(n%8))) |
		     ((d[0]&0x80) >> (unsigned int)(n%8));
	    }
	inl-=chunk;
	in +=chunk;
	out+=chunk;
	if (inl<chunk) chunk=inl;
a119 1

d124 1
a124 1
			   const unsigned char *in, size_t inl)
d126 2
a127 11
    while (inl>=EVP_MAXCHUNK)
	{
	DES_cfb_encrypt(in,out,8,(long)EVP_MAXCHUNK,ctx->cipher_data,
			(DES_cblock *)ctx->iv,ctx->encrypt);
	inl-=EVP_MAXCHUNK;
	in +=EVP_MAXCHUNK;
	out+=EVP_MAXCHUNK;
	}
    if (inl)
	DES_cfb_encrypt(in,out,8,(long)inl,ctx->cipher_data,
			(DES_cblock *)ctx->iv,ctx->encrypt);
d132 2
a133 1
			EVP_CIPH_RAND_KEY, des_init_key, NULL,
d139 2
a140 1
		     EVP_CIPH_RAND_KEY, des_init_key,NULL,
d145 2
a146 1
		     EVP_CIPH_RAND_KEY,des_init_key,NULL,
@


