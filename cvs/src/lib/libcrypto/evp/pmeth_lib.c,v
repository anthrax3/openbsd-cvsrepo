head	1.13;
access;
symbols
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13;
locks; strict;
comment	@ * @;


1.13
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.12;
commitid	kT0fLt3r4lroFJra;

1.12
date	2017.01.21.04.38.23;	author jsing;	state Exp;
branches;
next	1.11;
commitid	ZH0cfraAcedHrO0V;

1.11
date	2015.02.11.03.19.37;	author doug;	state Exp;
branches;
next	1.10;
commitid	5KSZBoxiLebzObKt;

1.10
date	2014.11.09.19.17.13;	author miod;	state Exp;
branches;
next	1.9;
commitid	QrgOG8zcUIADOfFd;

1.9
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.8;
commitid	G74O1dmRukKsW7IJ;

1.8
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.7;
commitid	yQEL1wOWIearrW15;

1.7
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.6;
commitid	nzndm3zqPmFurSaK;

1.6
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.5;
commitid	id8dTrTMtnTn4fqt;

1.5
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	mJUVYpkFBZ0Zv2bG;

1.4
date	2014.05.25.20.28.50;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2014.05.07.17.42.51;	author jsing;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.01.22.54.08;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.10.01.22.54.08;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.11.03.02.32.11;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.10.13.21.23.40;	author djm;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: pmeth_lib.c,v 1.12 2017/01/21 04:38:23 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2006.
 */
/* ====================================================================
 * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/objects.h>

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include "asn1_locl.h"
#include "evp_locl.h"

typedef int sk_cmp_fn_type(const char * const *a, const char * const *b);

DECLARE_STACK_OF(EVP_PKEY_METHOD)
STACK_OF(EVP_PKEY_METHOD) *app_pkey_methods = NULL;

extern const EVP_PKEY_METHOD rsa_pkey_meth, dh_pkey_meth, dsa_pkey_meth;
extern const EVP_PKEY_METHOD ec_pkey_meth, hmac_pkey_meth, cmac_pkey_meth;
extern const EVP_PKEY_METHOD gostimit_pkey_meth, gostr01_pkey_meth;

static const EVP_PKEY_METHOD *standard_methods[] = {
#ifndef OPENSSL_NO_RSA
	&rsa_pkey_meth,
#endif
#ifndef OPENSSL_NO_DH
	&dh_pkey_meth,
#endif
#ifndef OPENSSL_NO_DSA
	&dsa_pkey_meth,
#endif
#ifndef OPENSSL_NO_EC
	&ec_pkey_meth,
#endif
#ifndef OPENSSL_NO_GOST
	&gostr01_pkey_meth,
	&gostimit_pkey_meth,
#endif
	&hmac_pkey_meth,
	&cmac_pkey_meth,
};

static int pmeth_cmp_BSEARCH_CMP_FN(const void *, const void *);
static int pmeth_cmp(const EVP_PKEY_METHOD * const *, const EVP_PKEY_METHOD * const *);
static const EVP_PKEY_METHOD * *OBJ_bsearch_pmeth(const EVP_PKEY_METHOD * *key, const EVP_PKEY_METHOD * const *base, int num);

static int
pmeth_cmp(const EVP_PKEY_METHOD * const *a, const EVP_PKEY_METHOD * const *b)
{
	return ((*a)->pkey_id - (*b)->pkey_id);
}


static int
pmeth_cmp_BSEARCH_CMP_FN(const void *a_, const void *b_)
{
	const EVP_PKEY_METHOD * const *a = a_;
	const EVP_PKEY_METHOD * const *b = b_;
	return pmeth_cmp(a, b);
}

static const EVP_PKEY_METHOD * *
OBJ_bsearch_pmeth(const EVP_PKEY_METHOD * *key, const EVP_PKEY_METHOD * const *base, int num)
{
	return (const EVP_PKEY_METHOD * *)OBJ_bsearch_(key, base, num, sizeof(const EVP_PKEY_METHOD *),
	    pmeth_cmp_BSEARCH_CMP_FN);
}

const EVP_PKEY_METHOD *
EVP_PKEY_meth_find(int type)
{
	EVP_PKEY_METHOD tmp;
	const EVP_PKEY_METHOD *t = &tmp, **ret;

	tmp.pkey_id = type;
	if (app_pkey_methods) {
		int idx;
		idx = sk_EVP_PKEY_METHOD_find(app_pkey_methods, &tmp);
		if (idx >= 0)
			return sk_EVP_PKEY_METHOD_value(app_pkey_methods, idx);
	}
	ret = OBJ_bsearch_pmeth(&t, standard_methods,
	    sizeof(standard_methods)/sizeof(EVP_PKEY_METHOD *));
	if (!ret || !*ret)
		return NULL;
	return *ret;
}

static EVP_PKEY_CTX *
int_ctx_new(EVP_PKEY *pkey, ENGINE *e, int id)
{
	EVP_PKEY_CTX *ret;
	const EVP_PKEY_METHOD *pmeth;

	if (id == -1) {
		if (!pkey || !pkey->ameth)
			return NULL;
		id = pkey->ameth->pkey_id;
	}
#ifndef OPENSSL_NO_ENGINE
	if (pkey && pkey->engine)
		e = pkey->engine;
	/* Try to find an ENGINE which implements this method */
	if (e) {
		if (!ENGINE_init(e)) {
			EVPerror(ERR_R_ENGINE_LIB);
			return NULL;
		}
	} else
		e = ENGINE_get_pkey_meth_engine(id);

	/* If an ENGINE handled this method look it up. Othewise
	 * use internal tables.
	 */

	if (e)
		pmeth = ENGINE_get_pkey_meth(e, id);
	else
#endif
		pmeth = EVP_PKEY_meth_find(id);

	if (pmeth == NULL) {
		EVPerror(EVP_R_UNSUPPORTED_ALGORITHM);
		return NULL;
	}

	ret = malloc(sizeof(EVP_PKEY_CTX));
	if (!ret) {
#ifndef OPENSSL_NO_ENGINE
		if (e)
			ENGINE_finish(e);
#endif
		EVPerror(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	ret->engine = e;
	ret->pmeth = pmeth;
	ret->operation = EVP_PKEY_OP_UNDEFINED;
	ret->pkey = pkey;
	ret->peerkey = NULL;
	ret->pkey_gencb = 0;
	if (pkey)
		CRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);
	ret->data = NULL;

	if (pmeth->init) {
		if (pmeth->init(ret) <= 0) {
			EVP_PKEY_CTX_free(ret);
			return NULL;
		}
	}

	return ret;
}

EVP_PKEY_METHOD*
EVP_PKEY_meth_new(int id, int flags)
{
	EVP_PKEY_METHOD *pmeth;

	pmeth = calloc(1, sizeof(EVP_PKEY_METHOD));
	if (!pmeth)
		return NULL;

	pmeth->pkey_id = id;
	pmeth->flags = flags | EVP_PKEY_FLAG_DYNAMIC;

	pmeth->init = 0;
	pmeth->copy = 0;
	pmeth->cleanup = 0;
	pmeth->paramgen_init = 0;
	pmeth->paramgen = 0;
	pmeth->keygen_init = 0;
	pmeth->keygen = 0;
	pmeth->sign_init = 0;
	pmeth->sign = 0;
	pmeth->verify_init = 0;
	pmeth->verify = 0;
	pmeth->verify_recover_init = 0;
	pmeth->verify_recover = 0;
	pmeth->signctx_init = 0;
	pmeth->signctx = 0;
	pmeth->verifyctx_init = 0;
	pmeth->verifyctx = 0;
	pmeth->encrypt_init = 0;
	pmeth->encrypt = 0;
	pmeth->decrypt_init = 0;
	pmeth->decrypt = 0;
	pmeth->derive_init = 0;
	pmeth->derive = 0;
	pmeth->ctrl = 0;
	pmeth->ctrl_str = 0;

	return pmeth;
}

void
EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags, const EVP_PKEY_METHOD *meth)
{
	if (ppkey_id)
		*ppkey_id = meth->pkey_id;
	if (pflags)
		*pflags = meth->flags;
}

void
EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src)
{
	dst->init = src->init;
	dst->copy = src->copy;
	dst->cleanup = src->cleanup;

	dst->paramgen_init = src->paramgen_init;
	dst->paramgen = src->paramgen;

	dst->keygen_init = src->keygen_init;
	dst->keygen = src->keygen;

	dst->sign_init = src->sign_init;
	dst->sign = src->sign;

	dst->verify_init = src->verify_init;
	dst->verify = src->verify;

	dst->verify_recover_init = src->verify_recover_init;
	dst->verify_recover = src->verify_recover;

	dst->signctx_init = src->signctx_init;
	dst->signctx = src->signctx;

	dst->verifyctx_init = src->verifyctx_init;
	dst->verifyctx = src->verifyctx;

	dst->encrypt_init = src->encrypt_init;
	dst->encrypt = src->encrypt;

	dst->decrypt_init = src->decrypt_init;
	dst->decrypt = src->decrypt;

	dst->derive_init = src->derive_init;
	dst->derive = src->derive;

	dst->ctrl = src->ctrl;
	dst->ctrl_str = src->ctrl_str;
}

void
EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth)
{
	if (pmeth && (pmeth->flags & EVP_PKEY_FLAG_DYNAMIC))
		free(pmeth);
}

EVP_PKEY_CTX *
EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e)
{
	return int_ctx_new(pkey, e, -1);
}

EVP_PKEY_CTX *
EVP_PKEY_CTX_new_id(int id, ENGINE *e)
{
	return int_ctx_new(NULL, e, id);
}

EVP_PKEY_CTX *
EVP_PKEY_CTX_dup(EVP_PKEY_CTX *pctx)
{
	EVP_PKEY_CTX *rctx;

	if (!pctx->pmeth || !pctx->pmeth->copy)
		return NULL;
#ifndef OPENSSL_NO_ENGINE
	/* Make sure it's safe to copy a pkey context using an ENGINE */
	if (pctx->engine && !ENGINE_init(pctx->engine)) {
		EVPerror(ERR_R_ENGINE_LIB);
		return 0;
	}
#endif
	rctx = malloc(sizeof(EVP_PKEY_CTX));
	if (!rctx)
		return NULL;

	rctx->pmeth = pctx->pmeth;
#ifndef OPENSSL_NO_ENGINE
	rctx->engine = pctx->engine;
#endif

	if (pctx->pkey)
		CRYPTO_add(&pctx->pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);

	rctx->pkey = pctx->pkey;

	if (pctx->peerkey)
		CRYPTO_add(&pctx->peerkey->references, 1, CRYPTO_LOCK_EVP_PKEY);

	rctx->peerkey = pctx->peerkey;

	rctx->data = NULL;
	rctx->app_data = NULL;
	rctx->operation = pctx->operation;

	if (pctx->pmeth->copy(rctx, pctx) > 0)
		return rctx;

	EVP_PKEY_CTX_free(rctx);
	return NULL;
}

int
EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth)
{
	if (app_pkey_methods == NULL) {
		app_pkey_methods = sk_EVP_PKEY_METHOD_new(pmeth_cmp);
		if (!app_pkey_methods)
			return 0;
	}
	if (!sk_EVP_PKEY_METHOD_push(app_pkey_methods, pmeth))
		return 0;
	sk_EVP_PKEY_METHOD_sort(app_pkey_methods);
	return 1;
}

void
EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx)
{
	if (ctx == NULL)
		return;
	if (ctx->pmeth && ctx->pmeth->cleanup)
		ctx->pmeth->cleanup(ctx);
	EVP_PKEY_free(ctx->pkey);
	EVP_PKEY_free(ctx->peerkey);
#ifndef OPENSSL_NO_ENGINE
	if (ctx->engine)
		/* The EVP_PKEY_CTX we used belongs to an ENGINE, release the
		 * functional reference we held for this reason. */
		ENGINE_finish(ctx->engine);
#endif
	free(ctx);
}

int
EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype, int cmd,
    int p1, void *p2)
{
	int ret;

	if (!ctx || !ctx->pmeth || !ctx->pmeth->ctrl) {
		EVPerror(EVP_R_COMMAND_NOT_SUPPORTED);
		return -2;
	}
	if ((keytype != -1) && (ctx->pmeth->pkey_id != keytype))
		return -1;

	if (ctx->operation == EVP_PKEY_OP_UNDEFINED) {
		EVPerror(EVP_R_NO_OPERATION_SET);
		return -1;
	}

	if ((optype != -1) && !(ctx->operation & optype)) {
		EVPerror(EVP_R_INVALID_OPERATION);
		return -1;
	}

	ret = ctx->pmeth->ctrl(ctx, cmd, p1, p2);

	if (ret == -2)
		EVPerror(EVP_R_COMMAND_NOT_SUPPORTED);

	return ret;

}

int
EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *name, const char *value)
{
	if (!ctx || !ctx->pmeth || !ctx->pmeth->ctrl_str) {
		EVPerror(EVP_R_COMMAND_NOT_SUPPORTED);
		return -2;
	}
	if (!strcmp(name, "digest")) {
		const EVP_MD *md;
		if (!value || !(md = EVP_get_digestbyname(value))) {
			EVPerror(EVP_R_INVALID_DIGEST);
			return 0;
		}
		return EVP_PKEY_CTX_set_signature_md(ctx, md);
	}
	return ctx->pmeth->ctrl_str(ctx, name, value);
}

int
EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx)
{
	return ctx->operation;
}

void
EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen)
{
	ctx->keygen_info = dat;
	ctx->keygen_info_count = datlen;
}

void
EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data)
{
	ctx->data = data;
}

void *
EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx)
{
	return ctx->data;
}

EVP_PKEY *
EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx)
{
	return ctx->pkey;
}

EVP_PKEY *
EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx)
{
	return ctx->peerkey;
}

void
EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data)
{
	ctx->app_data = data;
}

void *
EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx)
{
	return ctx->app_data;
}

void
EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,
    int (*init)(EVP_PKEY_CTX *ctx))
{
	pmeth->init = init;
}

void
EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,
    int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src))
{
	pmeth->copy = copy;
}

void
EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,
    void (*cleanup)(EVP_PKEY_CTX *ctx))
{
	pmeth->cleanup = cleanup;
}

void
EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,
    int (*paramgen_init)(EVP_PKEY_CTX *ctx),
    int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey))
{
	pmeth->paramgen_init = paramgen_init;
	pmeth->paramgen = paramgen;
}

void
EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,
    int (*keygen_init)(EVP_PKEY_CTX *ctx),
    int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey))
{
	pmeth->keygen_init = keygen_init;
	pmeth->keygen = keygen;
}

void
EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,
    int (*sign_init)(EVP_PKEY_CTX *ctx),
    int (*sign)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
    const unsigned char *tbs, size_t tbslen))
{
	pmeth->sign_init = sign_init;
	pmeth->sign = sign;
}

void
EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,
    int (*verify_init)(EVP_PKEY_CTX *ctx),
    int (*verify)(EVP_PKEY_CTX *ctx, const unsigned char *sig, size_t siglen,
    const unsigned char *tbs, size_t tbslen))
{
	pmeth->verify_init = verify_init;
	pmeth->verify = verify;
}

void
EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,
    int (*verify_recover_init)(EVP_PKEY_CTX *ctx),
    int (*verify_recover)(EVP_PKEY_CTX *ctx,
    unsigned char *sig, size_t *siglen,
    const unsigned char *tbs, size_t tbslen))
{
	pmeth->verify_recover_init = verify_recover_init;
	pmeth->verify_recover = verify_recover;
}

void
EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,
    int (*signctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
    int (*signctx)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
    EVP_MD_CTX *mctx))
{
	pmeth->signctx_init = signctx_init;
	pmeth->signctx = signctx;
}

void
EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,
    int (*verifyctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
    int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig, int siglen,
    EVP_MD_CTX *mctx))
{
	pmeth->verifyctx_init = verifyctx_init;
	pmeth->verifyctx = verifyctx;
}

void
EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,
    int (*encrypt_init)(EVP_PKEY_CTX *ctx),
    int (*encryptfn)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
    const unsigned char *in, size_t inlen))
{
	pmeth->encrypt_init = encrypt_init;
	pmeth->encrypt = encryptfn;
}

void
EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,
    int (*decrypt_init)(EVP_PKEY_CTX *ctx),
    int (*decrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
    const unsigned char *in, size_t inlen))
{
	pmeth->decrypt_init = decrypt_init;
	pmeth->decrypt = decrypt;
}

void
EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,
    int (*derive_init)(EVP_PKEY_CTX *ctx),
    int (*derive)(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen))
{
	pmeth->derive_init = derive_init;
	pmeth->derive = derive;
}

void
EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,
    int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2),
    int (*ctrl_str)(EVP_PKEY_CTX *ctx, const char *type, const char *value))
{
	pmeth->ctrl = ctrl;
	pmeth->ctrl_str = ctrl_str;
}
@


1.12
log
@Expand DECLARE_OBJ_BSEARCH_CMP_FN and IMPLEMENT_OBJ_BSEARCH_CMP_FN macros.

No change to generated assembly excluding line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: pmeth_lib.c,v 1.11 2015/02/11 03:19:37 doug Exp $ */
d169 1
a169 1
			EVPerr(EVP_F_INT_CTX_NEW, ERR_R_ENGINE_LIB);
d186 1
a186 1
		EVPerr(EVP_F_INT_CTX_NEW, EVP_R_UNSUPPORTED_ALGORITHM);
d196 1
a196 1
		EVPerr(EVP_F_INT_CTX_NEW, ERR_R_MALLOC_FAILURE);
d339 1
a339 1
		EVPerr(EVP_F_EVP_PKEY_CTX_DUP, ERR_R_ENGINE_LIB);
d412 1
a412 1
		EVPerr(EVP_F_EVP_PKEY_CTX_CTRL, EVP_R_COMMAND_NOT_SUPPORTED);
d419 1
a419 1
		EVPerr(EVP_F_EVP_PKEY_CTX_CTRL, EVP_R_NO_OPERATION_SET);
d424 1
a424 1
		EVPerr(EVP_F_EVP_PKEY_CTX_CTRL, EVP_R_INVALID_OPERATION);
d431 1
a431 1
		EVPerr(EVP_F_EVP_PKEY_CTX_CTRL, EVP_R_COMMAND_NOT_SUPPORTED);
d441 1
a441 2
		EVPerr(EVP_F_EVP_PKEY_CTX_CTRL_STR,
		    EVP_R_COMMAND_NOT_SUPPORTED);
d447 1
a447 2
			EVPerr(EVP_F_EVP_PKEY_CTX_CTRL_STR,
			    EVP_R_INVALID_DIGEST);
@


1.11
log
@Enable building with -DOPENSSL_NO_DEPRECATED.

If you didn't enable deprecated code, there were missing err.h and
bn.h includes.  This commit allows building with or without deprecated
code.

This was not derived from an OpenSSL commit.  However, they recently
enabled OPENSSL_NO_DEPRECATED in git and fixed these header problems
in a different way.

Verified with clang that this only changes line numbers in the generated
asm.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmeth_lib.c,v 1.10 2014/11/09 19:17:13 miod Exp $ */
d106 3
a108 2
DECLARE_OBJ_BSEARCH_CMP_FN(const EVP_PKEY_METHOD *, const EVP_PKEY_METHOD *,
    pmeth);
d116 15
a130 2
IMPLEMENT_OBJ_BSEARCH_CMP_FN(const EVP_PKEY_METHOD *, const EVP_PKEY_METHOD *,
    pmeth);
@


1.10
log
@GOST crypto algorithms (well, most of them), ported from the removed GOST
engine to regular EVP citizens, contributed by Dmitry Eremin-Solenikov;
libcrypto bits only for now.

This is a verbatim import of Dmitry's work, and does not compile in this
state; the forthcoming commits will address these issues.

None of the GOST code is enabled in libcrypto yet, for it still gets
compiled with OPENSSL_NO_GOST defined. However, the public header gost.h
will be installed.
@
text
@d1 1
a1 1
/* $OpenBSD: pmeth_lib.c,v 1.9 2014/07/12 16:03:37 miod Exp $ */
d65 1
@


1.9
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmeth_lib.c,v 1.8 2014/07/11 08:44:48 jsing Exp $ */
d82 1
d97 4
d102 1
a102 1
	&cmac_pkey_meth
@


1.8
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmeth_lib.c,v 1.7 2014/07/10 22:45:57 jsing Exp $ */
d374 2
a375 4
	if (ctx->pkey)
		EVP_PKEY_free(ctx->pkey);
	if (ctx->peerkey)
		EVP_PKEY_free(ctx->peerkey);
@


1.7
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: pmeth_lib.c,v 1.6 2014/07/10 13:58:22 jsing Exp $ */
d65 1
a65 1
#include "cryptlib.h"
d67 1
a67 1
#include <openssl/evp.h>
d71 1
@


1.6
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmeth_lib.c,v 1.5 2014/06/12 15:49:29 deraadt Exp $ */
d62 2
@


1.5
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d61 2
@


1.4
log
@calloc instead of malloc/memset. from Benjamin Baier
@
text
@d1 1
a1 1
/* pmeth_lib.c */
@


1.3
log
@KNF.
@
text
@d199 1
a199 1
	pmeth = malloc(sizeof(EVP_PKEY_METHOD));
a201 2

	memset(pmeth, 0, sizeof(EVP_PKEY_METHOD));
@


1.2
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d78 1
a78 2
static const EVP_PKEY_METHOD *standard_methods[] =
	{
d93 1
a93 1
	};
d96 1
a96 1
			   pmeth);
d98 5
a102 5
static int pmeth_cmp(const EVP_PKEY_METHOD * const *a,
		     const EVP_PKEY_METHOD * const *b)
	{
        return ((*a)->pkey_id - (*b)->pkey_id);
	}
d105 1
a105 1
			     pmeth);
d107 3
a109 2
const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type)
	{
d112 1
d114 1
a114 2
	if (app_pkey_methods)
		{
d119 1
a119 1
		}
d121 1
a121 1
			  sizeof(standard_methods)/sizeof(EVP_PKEY_METHOD *));
d125 1
a125 1
	}
d127 3
a129 2
static EVP_PKEY_CTX *int_ctx_new(EVP_PKEY *pkey, ENGINE *e, int id)
	{
d132 2
a133 2
	if (id == -1)
		{
d137 1
a137 1
		}
d142 3
a144 5
	if (e)
		{
		if (!ENGINE_init(e))
			{
			EVPerr(EVP_F_INT_CTX_NEW,ERR_R_ENGINE_LIB);
a145 1
			}
d147 1
a147 1
	else
d160 2
a161 3
	if (pmeth == NULL)
		{
		EVPerr(EVP_F_INT_CTX_NEW,EVP_R_UNSUPPORTED_ALGORITHM);
d163 1
a163 1
		}
d166 1
a166 2
	if (!ret)
		{
d171 1
a171 1
		EVPerr(EVP_F_INT_CTX_NEW,ERR_R_MALLOC_FAILURE);
d173 1
a173 1
		}
d181 1
a181 1
		CRYPTO_add(&pkey->references,1,CRYPTO_LOCK_EVP_PKEY);
d184 2
a185 4
	if (pmeth->init)
		{
		if (pmeth->init(ret) <= 0)
			{
a187 1
			}
d189 1
d192 1
a192 1
	}
d194 3
a196 2
EVP_PKEY_METHOD* EVP_PKEY_meth_new(int id, int flags)
	{
d198 1
d235 1
a235 1
	}
d237 3
a239 3
void EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,
				const EVP_PKEY_METHOD *meth)
	{
d244 1
a244 4
	}

void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src)
	{
d246 3
d285 1
a285 1
	}
d287 3
a289 2
void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth)
	{
d292 1
a292 1
	}
d294 3
a296 2
EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e)
	{
d298 1
a298 1
	}
d300 3
a302 2
EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e)
	{
d304 1
a304 1
	}
d306 3
a308 2
EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *pctx)
	{
d310 1
d315 2
a316 3
	if (pctx->engine && !ENGINE_init(pctx->engine))
		{
		EVPerr(EVP_F_EVP_PKEY_CTX_DUP,ERR_R_ENGINE_LIB);
d318 1
a318 1
		}
d330 1
a330 1
		CRYPTO_add(&pctx->pkey->references,1,CRYPTO_LOCK_EVP_PKEY);
d335 1
a335 1
		CRYPTO_add(&pctx->peerkey->references,1,CRYPTO_LOCK_EVP_PKEY);
d348 1
d350 4
a353 6
	}

int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth)
	{
	if (app_pkey_methods == NULL)
		{
d357 1
a357 1
		}
d362 1
a362 1
	}
d364 3
a366 2
void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx)
	{
d376 1
a376 1
	if(ctx->engine)
d382 1
a382 1
	}
d384 4
a387 3
int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
				int cmd, int p1, void *p2)
	{
d389 2
a390 2
	if (!ctx || !ctx->pmeth || !ctx->pmeth->ctrl)
		{
d393 1
a393 1
		}
d397 1
a397 2
	if (ctx->operation == EVP_PKEY_OP_UNDEFINED)
		{
d400 1
a400 1
		}
d402 1
a402 2
	if ((optype != -1) && !(ctx->operation & optype))
		{
d405 1
a405 1
		}
d414 1
a414 1
	}
d416 4
a419 5
int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx,
					const char *name, const char *value)
	{
	if (!ctx || !ctx->pmeth || !ctx->pmeth->ctrl_str)
		{
d421 1
a421 1
						EVP_R_COMMAND_NOT_SUPPORTED);
d423 2
a424 3
		}
	if (!strcmp(name, "digest"))
		{
d426 1
a426 2
		if (!value || !(md = EVP_get_digestbyname(value)))
			{
d428 1
a428 1
						EVP_R_INVALID_DIGEST);
d430 1
a430 1
			}
d432 1
a432 1
		}
d434 1
a434 1
	}
d436 3
a438 2
int EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx)
	{
d440 1
a440 1
	}
d442 3
a444 2
void EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen)
	{
d447 1
a447 1
	}
d449 3
a451 2
void EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data)
	{
d453 1
a453 1
	}
d455 3
a457 2
void *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx)
	{
d459 1
a459 1
	}
d461 3
a463 2
EVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx)
	{
d465 1
a465 1
	}
d467 3
a469 2
EVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx)
	{
d471 5
a475 4
	}
	
void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data)
	{
d477 1
a477 1
	}
d479 3
a481 2
void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx)
	{
d483 1
a483 1
	}
d485 4
a488 3
void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,
	int (*init)(EVP_PKEY_CTX *ctx))
	{
d490 1
a490 1
	}
d492 4
a495 3
void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,
	int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src))
	{
d497 1
a497 1
	}
d499 4
a502 3
void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,
	void (*cleanup)(EVP_PKEY_CTX *ctx))
	{
d504 1
a504 1
	}
d506 5
a510 4
void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,
	int (*paramgen_init)(EVP_PKEY_CTX *ctx),
	int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey))
	{
d513 1
a513 1
	}
d515 5
a519 4
void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,
	int (*keygen_init)(EVP_PKEY_CTX *ctx),
	int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey))
	{
d522 1
a522 1
	}
d524 6
a529 5
void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,
	int (*sign_init)(EVP_PKEY_CTX *ctx),
	int (*sign)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
					const unsigned char *tbs, size_t tbslen))
	{
d532 1
a532 1
	}
d534 6
a539 5
void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,
	int (*verify_init)(EVP_PKEY_CTX *ctx),
	int (*verify)(EVP_PKEY_CTX *ctx, const unsigned char *sig, size_t siglen,
					const unsigned char *tbs, size_t tbslen))
	{
d542 1
a542 1
	}
d544 7
a550 6
void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,
	int (*verify_recover_init)(EVP_PKEY_CTX *ctx),
	int (*verify_recover)(EVP_PKEY_CTX *ctx,
					unsigned char *sig, size_t *siglen,
					const unsigned char *tbs, size_t tbslen))
	{
d553 1
a553 1
	}
d555 6
a560 5
void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,
	int (*signctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
	int (*signctx)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
					EVP_MD_CTX *mctx))
	{
d563 1
a563 1
	}
d565 6
a570 5
void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,
	int (*verifyctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
	int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig,int siglen,
					EVP_MD_CTX *mctx))
	{
d573 1
a573 1
	}
d575 6
a580 5
void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,
	int (*encrypt_init)(EVP_PKEY_CTX *ctx),
	int (*encryptfn)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
					const unsigned char *in, size_t inlen))
	{
d583 1
a583 1
	}
d585 6
a590 5
void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,
	int (*decrypt_init)(EVP_PKEY_CTX *ctx),
	int (*decrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
					const unsigned char *in, size_t inlen))
	{
d593 1
a593 1
	}
d595 5
a599 4
void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,
	int (*derive_init)(EVP_PKEY_CTX *ctx),
	int (*derive)(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen))
	{
d602 1
a602 1
	}
d604 5
a608 4
void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,
	int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2),
	int (*ctrl_str)(EVP_PKEY_CTX *ctx, const char *type, const char *value))
	{
d611 1
a611 1
	}
@


1.1
log
@Initial revision
@
text
@d76 1
a76 1
extern const EVP_PKEY_METHOD ec_pkey_meth, hmac_pkey_meth;
d93 1
d138 2
d168 1
a168 1
	ret = OPENSSL_malloc(sizeof(EVP_PKEY_CTX));
d203 1
a203 1
	pmeth = OPENSSL_malloc(sizeof(EVP_PKEY_METHOD));
d207 2
d241 50
d294 1
a294 1
		OPENSSL_free(pmeth);
d320 1
a320 1
	rctx = OPENSSL_malloc(sizeof(EVP_PKEY_CTX));
d381 1
a381 1
	OPENSSL_free(ctx);
@


1.1.1.1
log
@import OpenSSL-1.0.0a
@
text
@@


1.1.1.2
log
@import OpenSSL 1.0.0e
@
text
@a136 2
	if (pkey && pkey->engine)
		e = pkey->engine;
@


1.1.1.3
log
@import OpenSSL-1.0.1c
@
text
@d76 1
a76 1
extern const EVP_PKEY_METHOD ec_pkey_meth, hmac_pkey_meth, cmac_pkey_meth;
a92 1
	&cmac_pkey_meth
a205 2
	memset(pmeth, 0, sizeof(EVP_PKEY_METHOD));

a235 50
	}

void EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,
				const EVP_PKEY_METHOD *meth)
	{
	if (ppkey_id)
		*ppkey_id = meth->pkey_id;
	if (pflags)
		*pflags = meth->flags;
	}

void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src)
	{

	dst->init = src->init;
	dst->copy = src->copy;
	dst->cleanup = src->cleanup;

	dst->paramgen_init = src->paramgen_init;
	dst->paramgen = src->paramgen;

	dst->keygen_init = src->keygen_init;
	dst->keygen = src->keygen;

	dst->sign_init = src->sign_init;
	dst->sign = src->sign;

	dst->verify_init = src->verify_init;
	dst->verify = src->verify;

	dst->verify_recover_init = src->verify_recover_init;
	dst->verify_recover = src->verify_recover;

	dst->signctx_init = src->signctx_init;
	dst->signctx = src->signctx;

	dst->verifyctx_init = src->verifyctx_init;
	dst->verifyctx = src->verifyctx;

	dst->encrypt_init = src->encrypt_init;
	dst->encrypt = src->encrypt;

	dst->decrypt_init = src->decrypt_init;
	dst->decrypt = src->decrypt;

	dst->derive_init = src->derive_init;
	dst->derive = src->derive;

	dst->ctrl = src->ctrl;
	dst->ctrl_str = src->ctrl_str;
@


