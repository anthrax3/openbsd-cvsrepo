head	1.52;
access;
symbols
	OPENBSD_6_1:1.52.0.4
	OPENBSD_6_1_BASE:1.52;
locks; strict;
comment	@ * @;


1.52
date	2017.02.28.14.15.37;	author jsing;	state Exp;
branches;
next	1.51;
commitid	GHDJGMOUxdrdvQbZ;

1.51
date	2016.05.30.13.42.54;	author beck;	state Exp;
branches;
next	1.50;
commitid	P66xC6CnwAnLazTN;

1.50
date	2016.04.28.16.06.53;	author jsing;	state Exp;
branches;
next	1.49;
commitid	82vUQnYEexbUmRFI;

1.49
date	2015.11.02.15.40.53;	author reyk;	state Exp;
branches;
next	1.48;
commitid	IRH03kez31ofxOKM;

1.48
date	2015.09.14.01.45.03;	author doug;	state Exp;
branches;
next	1.47;
commitid	WI3ltGMbnAaZXz3O;

1.47
date	2015.09.13.23.36.21;	author doug;	state Exp;
branches;
next	1.46;
commitid	4CxCgJZcnC9PKUvF;

1.46
date	2015.09.13.21.09.56;	author doug;	state Exp;
branches;
next	1.45;
commitid	e818W60lrMrFrzEk;

1.45
date	2015.06.20.01.07.24;	author doug;	state Exp;
branches;
next	1.44;
commitid	odUD1eZ4N02tuzg5;

1.44
date	2015.02.10.11.45.09;	author jsing;	state Exp;
branches;
next	1.43;
commitid	znaecaAmULZs71gX;

1.43
date	2015.02.10.09.52.35;	author miod;	state Exp;
branches;
next	1.42;
commitid	elQcISUWkrkujoI4;

1.42
date	2015.02.08.22.22.13;	author miod;	state Exp;
branches;
next	1.41;
commitid	jcbJq2JO7b0geMCo;

1.41
date	2015.02.07.13.19.15;	author doug;	state Exp;
branches;
next	1.40;
commitid	gtwLkRyWx0K1HbzX;

1.40
date	2014.11.09.19.17.13;	author miod;	state Exp;
branches;
next	1.39;
commitid	QrgOG8zcUIADOfFd;

1.39
date	2014.07.11.15.28.27;	author tedu;	state Exp;
branches;
next	1.38;
commitid	107BaPD3FBKItWlY;

1.38
date	2014.06.24.19.31.50;	author miod;	state Exp;
branches;
next	1.37;
commitid	OUHEvv0Yogw78Iii;

1.37
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	mJUVYpkFBZ0Zv2bG;

1.36
date	2014.05.30.03.31.29;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2014.05.26.13.01.58;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2014.05.17.16.00.53;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2014.05.17.15.48.14;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.16.14.24.36;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.15.15.09.01;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.15.13.53.47;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.11.12.05.27;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.05.01.16.06.24;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.14.18.07.45;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.13.23.50.02;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2013.01.26.06.10.22;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.01.17.44.20;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.29.05.41.40;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.29.05.39.21;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.23.17.02.25;	author hshoexer;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.10.20.14.31;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.10.16.31.55;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.21.01.49.11;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.03.09;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.16.21.31.58;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.45;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.10.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.14;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.35;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.35;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.28;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.39.15;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.41.43;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.10;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.33;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.56;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.07;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2012.10.13.21.23.40;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Add an EVP interface that provides concatenated MD5+SHA1 hashes, which are
used in various parts of TLS 1.0/1.1.

This will allow for code simplification in libssl.

The same interface exists in OpenSSL 1.1.

ok beck@@ deraadt@@ inoguchi@@ millert@@
@
text
@/* $OpenBSD: evp.h,v 1.51 2016/05/30 13:42:54 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#ifndef HEADER_ENVELOPE_H
#define HEADER_ENVELOPE_H

#include <openssl/opensslconf.h>

#include <openssl/ossl_typ.h>

#ifndef OPENSSL_NO_BIO
#include <openssl/bio.h>
#endif

/*
#define EVP_RC2_KEY_SIZE		16
#define EVP_RC4_KEY_SIZE		16
#define EVP_BLOWFISH_KEY_SIZE		16
#define EVP_CAST5_KEY_SIZE		16
#define EVP_RC5_32_12_16_KEY_SIZE	16
*/
#define EVP_MAX_MD_SIZE			64	/* longest known is SHA512 */
#define EVP_MAX_KEY_LENGTH		64
#define EVP_MAX_IV_LENGTH		16
#define EVP_MAX_BLOCK_LENGTH		32

#define PKCS5_SALT_LEN			8
/* Default PKCS#5 iteration count */
#define PKCS5_DEFAULT_ITER		2048

#include <openssl/objects.h>

#define EVP_PK_RSA	0x0001
#define EVP_PK_DSA	0x0002
#define EVP_PK_DH	0x0004
#define EVP_PK_EC	0x0008
#define EVP_PKT_SIGN	0x0010
#define EVP_PKT_ENC	0x0020
#define EVP_PKT_EXCH	0x0040
#define EVP_PKS_RSA	0x0100
#define EVP_PKS_DSA	0x0200
#define EVP_PKS_EC	0x0400
#define EVP_PKT_EXP	0x1000 /* <= 512 bit key */

#define EVP_PKEY_NONE	NID_undef
#define EVP_PKEY_RSA	NID_rsaEncryption
#define EVP_PKEY_RSA2	NID_rsa
#define EVP_PKEY_DSA	NID_dsa
#define EVP_PKEY_DSA1	NID_dsa_2
#define EVP_PKEY_DSA2	NID_dsaWithSHA
#define EVP_PKEY_DSA3	NID_dsaWithSHA1
#define EVP_PKEY_DSA4	NID_dsaWithSHA1_2
#define EVP_PKEY_DH	NID_dhKeyAgreement
#define EVP_PKEY_EC	NID_X9_62_id_ecPublicKey
#define EVP_PKEY_GOSTR01 NID_id_GostR3410_2001
#define EVP_PKEY_GOSTIMIT NID_id_Gost28147_89_MAC
#define EVP_PKEY_HMAC	NID_hmac
#define EVP_PKEY_CMAC	NID_cmac
#define EVP_PKEY_GOSTR12_256 NID_id_tc26_gost3410_2012_256
#define EVP_PKEY_GOSTR12_512 NID_id_tc26_gost3410_2012_512

#ifdef	__cplusplus
extern "C" {
#endif

/* Type needs to be a bit field
 * Sub-type needs to be for variations on the method, as in, can it do
 * arbitrary encryption.... */
struct evp_pkey_st {
	int type;
	int save_type;
	int references;
	const EVP_PKEY_ASN1_METHOD *ameth;
	ENGINE *engine;
	union	{
		char *ptr;
#ifndef OPENSSL_NO_RSA
		struct rsa_st *rsa;	/* RSA */
#endif
#ifndef OPENSSL_NO_DSA
		struct dsa_st *dsa;	/* DSA */
#endif
#ifndef OPENSSL_NO_DH
		struct dh_st *dh;	/* DH */
#endif
#ifndef OPENSSL_NO_EC
		struct ec_key_st *ec;	/* ECC */
#endif
#ifndef OPENSSL_NO_GOST
		struct gost_key_st *gost; /* GOST */
#endif
	} pkey;
	int save_parameters;
	STACK_OF(X509_ATTRIBUTE) *attributes; /* [ 0 ] */
} /* EVP_PKEY */;

#define EVP_PKEY_MO_SIGN	0x0001
#define EVP_PKEY_MO_VERIFY	0x0002
#define EVP_PKEY_MO_ENCRYPT	0x0004
#define EVP_PKEY_MO_DECRYPT	0x0008

typedef int evp_sign_method(int type, const unsigned char *m,
    unsigned int m_length, unsigned char *sigret, unsigned int *siglen,
    void *key);
typedef int evp_verify_method(int type, const unsigned char *m,
    unsigned int m_length, const unsigned char *sigbuf, unsigned int siglen,
    void *key);

#ifndef EVP_MD
struct env_md_st {
	int type;
	int pkey_type;
	int md_size;
	unsigned long flags;
	int (*init)(EVP_MD_CTX *ctx);
	int (*update)(EVP_MD_CTX *ctx, const void *data, size_t count);
	int (*final)(EVP_MD_CTX *ctx, unsigned char *md);
	int (*copy)(EVP_MD_CTX *to, const EVP_MD_CTX *from);
	int (*cleanup)(EVP_MD_CTX *ctx);

	evp_sign_method *sign;
	evp_verify_method *verify;
	int required_pkey_type[5]; /*EVP_PKEY_xxx */
	int block_size;
	int ctx_size; /* how big does the ctx->md_data need to be */
	/* control function */
	int (*md_ctrl)(EVP_MD_CTX *ctx, int cmd, int p1, void *p2);
} /* EVP_MD */;

#define EVP_MD_FLAG_ONESHOT	0x0001 /* digest can only handle a single
					* block */

#define EVP_MD_FLAG_PKEY_DIGEST	0x0002 /* digest is a "clone" digest used
					* which is a copy of an existing
					* one for a specific public key type.
					* EVP_dss1() etc */

/* Digest uses EVP_PKEY_METHOD for signing instead of MD specific signing */

#define EVP_MD_FLAG_PKEY_METHOD_SIGNATURE	0x0004

/* DigestAlgorithmIdentifier flags... */

#define EVP_MD_FLAG_DIGALGID_MASK		0x0018

/* NULL or absent parameter accepted. Use NULL */

#define EVP_MD_FLAG_DIGALGID_NULL		0x0000

/* NULL or absent parameter accepted. Use NULL for PKCS#1 otherwise absent */

#define EVP_MD_FLAG_DIGALGID_ABSENT		0x0008

/* Custom handling via ctrl */

#define EVP_MD_FLAG_DIGALGID_CUSTOM		0x0018

#define EVP_MD_FLAG_FIPS	0x0400 /* Note if suitable for use in FIPS mode */

/* Digest ctrls */

#define	EVP_MD_CTRL_DIGALGID			0x1
#define	EVP_MD_CTRL_MICALG			0x2
#define	EVP_MD_CTRL_SET_KEY			0x3
#define	EVP_MD_CTRL_GOST_SET_SBOX		0x4

/* Minimum Algorithm specific ctrl value */

#define	EVP_MD_CTRL_ALG_CTRL			0x1000

#define EVP_PKEY_NULL_method	NULL,NULL,{0,0,0,0}

#ifndef OPENSSL_NO_DSA
#define EVP_PKEY_DSA_method	(evp_sign_method *)DSA_sign, \
				(evp_verify_method *)DSA_verify, \
				{EVP_PKEY_DSA,EVP_PKEY_DSA2,EVP_PKEY_DSA3, \
					EVP_PKEY_DSA4,0}
#else
#define EVP_PKEY_DSA_method	EVP_PKEY_NULL_method
#endif

#ifndef OPENSSL_NO_ECDSA
#define EVP_PKEY_ECDSA_method   (evp_sign_method *)ECDSA_sign, \
				(evp_verify_method *)ECDSA_verify, \
                                 {EVP_PKEY_EC,0,0,0}
#else
#define EVP_PKEY_ECDSA_method   EVP_PKEY_NULL_method
#endif

#ifndef OPENSSL_NO_RSA
#define EVP_PKEY_RSA_method	(evp_sign_method *)RSA_sign, \
				(evp_verify_method *)RSA_verify, \
				{EVP_PKEY_RSA,EVP_PKEY_RSA2,0,0}
#define EVP_PKEY_RSA_ASN1_OCTET_STRING_method \
				(evp_sign_method *)RSA_sign_ASN1_OCTET_STRING, \
				(evp_verify_method *)RSA_verify_ASN1_OCTET_STRING, \
				{EVP_PKEY_RSA,EVP_PKEY_RSA2,0,0}
#else
#define EVP_PKEY_RSA_method	EVP_PKEY_NULL_method
#define EVP_PKEY_RSA_ASN1_OCTET_STRING_method EVP_PKEY_NULL_method
#endif

#endif /* !EVP_MD */

struct env_md_ctx_st {
	const EVP_MD *digest;
	ENGINE *engine; /* functional reference if 'digest' is ENGINE-provided */
	unsigned long flags;
	void *md_data;
	/* Public key context for sign/verify */
	EVP_PKEY_CTX *pctx;
	/* Update function: usually copied from EVP_MD */
	int (*update)(EVP_MD_CTX *ctx, const void *data, size_t count);
} /* EVP_MD_CTX */;

/* values for EVP_MD_CTX flags */

#define EVP_MD_CTX_FLAG_ONESHOT		0x0001 /* digest update will be called
						* once only */
#define EVP_MD_CTX_FLAG_CLEANED		0x0002 /* context has already been
						* cleaned */
#define EVP_MD_CTX_FLAG_REUSE		0x0004 /* Don't free up ctx->md_data
						* in EVP_MD_CTX_cleanup */
/* FIPS and pad options are ignored in 1.0.0, definitions are here
 * so we don't accidentally reuse the values for other purposes.
 */

#define EVP_MD_CTX_FLAG_NON_FIPS_ALLOW	0x0008	/* Allow use of non FIPS digest
						 * in FIPS mode */

/* The following PAD options are also currently ignored in 1.0.0, digest
 * parameters are handled through EVP_DigestSign*() and EVP_DigestVerify*()
 * instead.
 */
#define EVP_MD_CTX_FLAG_PAD_MASK	0xF0	/* RSA mode to use */
#define EVP_MD_CTX_FLAG_PAD_PKCS1	0x00	/* PKCS#1 v1.5 mode */
#define EVP_MD_CTX_FLAG_PAD_X931	0x10	/* X9.31 mode */
#define EVP_MD_CTX_FLAG_PAD_PSS		0x20	/* PSS mode */

#define EVP_MD_CTX_FLAG_NO_INIT		0x0100 /* Don't initialize md_data */

struct evp_cipher_st {
	int nid;
	int block_size;
	int key_len;		/* Default value for variable length ciphers */
	int iv_len;
	unsigned long flags;	/* Various flags */
	int (*init)(EVP_CIPHER_CTX *ctx, const unsigned char *key,
	    const unsigned char *iv, int enc);	/* init key */
	int (*do_cipher)(EVP_CIPHER_CTX *ctx, unsigned char *out,
	    const unsigned char *in, size_t inl);/* encrypt/decrypt data */
	int (*cleanup)(EVP_CIPHER_CTX *); /* cleanup ctx */
	int ctx_size;		/* how big ctx->cipher_data needs to be */
	int (*set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *); /* Populate a ASN1_TYPE with parameters */
	int (*get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *); /* Get parameters from a ASN1_TYPE */
	int (*ctrl)(EVP_CIPHER_CTX *, int type, int arg, void *ptr); /* Miscellaneous operations */
	void *app_data;		/* Application data */
} /* EVP_CIPHER */;

/* Values for cipher flags */

/* Modes for ciphers */

#define		EVP_CIPH_STREAM_CIPHER		0x0
#define		EVP_CIPH_ECB_MODE		0x1
#define		EVP_CIPH_CBC_MODE		0x2
#define		EVP_CIPH_CFB_MODE		0x3
#define		EVP_CIPH_OFB_MODE		0x4
#define		EVP_CIPH_CTR_MODE		0x5
#define		EVP_CIPH_GCM_MODE		0x6
#define		EVP_CIPH_CCM_MODE		0x7
#define		EVP_CIPH_XTS_MODE		0x10001
#define 	EVP_CIPH_MODE			0xF0007
/* Set if variable length cipher */
#define 	EVP_CIPH_VARIABLE_LENGTH	0x8
/* Set if the iv handling should be done by the cipher itself */
#define 	EVP_CIPH_CUSTOM_IV		0x10
/* Set if the cipher's init() function should be called if key is NULL */
#define 	EVP_CIPH_ALWAYS_CALL_INIT	0x20
/* Call ctrl() to init cipher parameters */
#define 	EVP_CIPH_CTRL_INIT		0x40
/* Don't use standard key length function */
#define 	EVP_CIPH_CUSTOM_KEY_LENGTH	0x80
/* Don't use standard block padding */
#define 	EVP_CIPH_NO_PADDING		0x100
/* cipher handles random key generation */
#define 	EVP_CIPH_RAND_KEY		0x200
/* cipher has its own additional copying logic */
#define 	EVP_CIPH_CUSTOM_COPY		0x400
/* Allow use default ASN1 get/set iv */
#define		EVP_CIPH_FLAG_DEFAULT_ASN1	0x1000
/* Buffer length in bits not bytes: CFB1 mode only */
#define		EVP_CIPH_FLAG_LENGTH_BITS	0x2000
/* Note if suitable for use in FIPS mode */
#define		EVP_CIPH_FLAG_FIPS		0x4000
/* Allow non FIPS cipher in FIPS mode */
#define		EVP_CIPH_FLAG_NON_FIPS_ALLOW	0x8000
/* Cipher handles any and all padding logic as well
 * as finalisation.
 */
#define 	EVP_CIPH_FLAG_CUSTOM_CIPHER	0x100000
#define		EVP_CIPH_FLAG_AEAD_CIPHER	0x200000

/* ctrl() values */

#define		EVP_CTRL_INIT			0x0
#define 	EVP_CTRL_SET_KEY_LENGTH		0x1
#define 	EVP_CTRL_GET_RC2_KEY_BITS	0x2
#define 	EVP_CTRL_SET_RC2_KEY_BITS	0x3
#define 	EVP_CTRL_GET_RC5_ROUNDS		0x4
#define 	EVP_CTRL_SET_RC5_ROUNDS		0x5
#define 	EVP_CTRL_RAND_KEY		0x6
#define 	EVP_CTRL_PBE_PRF_NID		0x7
#define 	EVP_CTRL_COPY			0x8
#define 	EVP_CTRL_GCM_SET_IVLEN		0x9
#define 	EVP_CTRL_GCM_GET_TAG		0x10
#define 	EVP_CTRL_GCM_SET_TAG		0x11
#define		EVP_CTRL_GCM_SET_IV_FIXED	0x12
#define		EVP_CTRL_GCM_IV_GEN		0x13
#define		EVP_CTRL_CCM_SET_IVLEN		EVP_CTRL_GCM_SET_IVLEN
#define		EVP_CTRL_CCM_GET_TAG		EVP_CTRL_GCM_GET_TAG
#define		EVP_CTRL_CCM_SET_TAG		EVP_CTRL_GCM_SET_TAG
#define		EVP_CTRL_CCM_SET_L		0x14
#define		EVP_CTRL_CCM_SET_MSGLEN		0x15
/* AEAD cipher deduces payload length and returns number of bytes
 * required to store MAC and eventual padding. Subsequent call to
 * EVP_Cipher even appends/verifies MAC.
 */
#define		EVP_CTRL_AEAD_TLS1_AAD		0x16
/* Used by composite AEAD ciphers, no-op in GCM, CCM... */
#define		EVP_CTRL_AEAD_SET_MAC_KEY	0x17
/* Set the GCM invocation field, decrypt only */
#define		EVP_CTRL_GCM_SET_IV_INV		0x18
/* Set the S-BOX NID for GOST ciphers */
#define		EVP_CTRL_GOST_SET_SBOX		0x19

/* GCM TLS constants */
/* Length of fixed part of IV derived from PRF */
#define EVP_GCM_TLS_FIXED_IV_LEN			4
/* Length of explicit part of IV part of TLS records */
#define EVP_GCM_TLS_EXPLICIT_IV_LEN			8
/* Length of tag for TLS */
#define EVP_GCM_TLS_TAG_LEN				16

typedef struct evp_cipher_info_st {
	const EVP_CIPHER *cipher;
	unsigned char iv[EVP_MAX_IV_LENGTH];
} EVP_CIPHER_INFO;

struct evp_cipher_ctx_st {
	const EVP_CIPHER *cipher;
	ENGINE *engine;	/* functional reference if 'cipher' is ENGINE-provided */
	int encrypt;		/* encrypt or decrypt */
	int buf_len;		/* number we have left */

	unsigned char  oiv[EVP_MAX_IV_LENGTH];	/* original iv */
	unsigned char  iv[EVP_MAX_IV_LENGTH];	/* working iv */
	unsigned char buf[EVP_MAX_BLOCK_LENGTH];/* saved partial block */
	int num;				/* used by cfb/ofb/ctr mode */

	void *app_data;		/* application stuff */
	int key_len;		/* May change for variable length cipher */
	unsigned long flags;	/* Various flags */
	void *cipher_data; /* per EVP data */
	int final_used;
	int block_mask;
	unsigned char final[EVP_MAX_BLOCK_LENGTH];/* possible final block */
} /* EVP_CIPHER_CTX */;

typedef struct evp_Encode_Ctx_st {
	int num;	/* number saved in a partial encode/decode */
	int length;	/* The length is either the output line length
			 * (in input bytes) or the shortest input line
			 * length that is ok.  Once decoding begins,
			 * the length is adjusted up each time a longer
			 * line is decoded */
	unsigned char enc_data[80];	/* data to encode */
	int line_num;	/* number read on current line */
	int expect_nl;
} EVP_ENCODE_CTX;

/* Password based encryption function */
typedef int (EVP_PBE_KEYGEN)(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
    ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de);

#ifndef OPENSSL_NO_RSA
#define EVP_PKEY_assign_RSA(pkey,rsa) EVP_PKEY_assign((pkey),EVP_PKEY_RSA,\
					(char *)(rsa))
#endif

#ifndef OPENSSL_NO_DSA
#define EVP_PKEY_assign_DSA(pkey,dsa) EVP_PKEY_assign((pkey),EVP_PKEY_DSA,\
					(char *)(dsa))
#endif

#ifndef OPENSSL_NO_DH
#define EVP_PKEY_assign_DH(pkey,dh) EVP_PKEY_assign((pkey),EVP_PKEY_DH,\
					(char *)(dh))
#endif

#ifndef OPENSSL_NO_EC
#define EVP_PKEY_assign_EC_KEY(pkey,eckey) EVP_PKEY_assign((pkey),EVP_PKEY_EC,\
                                        (char *)(eckey))
#endif

#ifndef OPENSSL_NO_GOST
#define EVP_PKEY_assign_GOST(pkey,gostkey) EVP_PKEY_assign((pkey),EVP_PKEY_GOSTR01,\
                                        (char *)(gostkey))
#endif

/* Add some extra combinations */
#define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))
#define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))
#define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))
#define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))

int EVP_MD_type(const EVP_MD *md);
#define EVP_MD_nid(e)			EVP_MD_type(e)
#define EVP_MD_name(e)			OBJ_nid2sn(EVP_MD_nid(e))
int EVP_MD_pkey_type(const EVP_MD *md);
int EVP_MD_size(const EVP_MD *md);
int EVP_MD_block_size(const EVP_MD *md);
unsigned long EVP_MD_flags(const EVP_MD *md);

const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);
#define EVP_MD_CTX_size(e)		EVP_MD_size(EVP_MD_CTX_md(e))
#define EVP_MD_CTX_block_size(e)	EVP_MD_block_size(EVP_MD_CTX_md(e))
#define EVP_MD_CTX_type(e)		EVP_MD_type(EVP_MD_CTX_md(e))

int EVP_CIPHER_nid(const EVP_CIPHER *cipher);
#define EVP_CIPHER_name(e)		OBJ_nid2sn(EVP_CIPHER_nid(e))
int EVP_CIPHER_block_size(const EVP_CIPHER *cipher);
int EVP_CIPHER_key_length(const EVP_CIPHER *cipher);
int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);
unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher);
#define EVP_CIPHER_mode(e)		(EVP_CIPHER_flags(e) & EVP_CIPH_MODE)

const EVP_CIPHER * EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in);
void * EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);
void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data);
#define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
unsigned long EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx);
#define EVP_CIPHER_CTX_mode(e)		(EVP_CIPHER_CTX_flags(e) & EVP_CIPH_MODE)

#define EVP_ENCODE_LENGTH(l)	(((l+2)/3*4)+(l/48+1)*2+80)
#define EVP_DECODE_LENGTH(l)	((l+3)/4*3+80)

#define EVP_SignInit_ex(a,b,c)		EVP_DigestInit_ex(a,b,c)
#define EVP_SignInit(a,b)		EVP_DigestInit(a,b)
#define EVP_SignUpdate(a,b,c)		EVP_DigestUpdate(a,b,c)
#define	EVP_VerifyInit_ex(a,b,c)	EVP_DigestInit_ex(a,b,c)
#define	EVP_VerifyInit(a,b)		EVP_DigestInit(a,b)
#define	EVP_VerifyUpdate(a,b,c)		EVP_DigestUpdate(a,b,c)
#define EVP_OpenUpdate(a,b,c,d,e)	EVP_DecryptUpdate(a,b,c,d,e)
#define EVP_SealUpdate(a,b,c,d,e)	EVP_EncryptUpdate(a,b,c,d,e)
#define EVP_DigestSignUpdate(a,b,c)	EVP_DigestUpdate(a,b,c)
#define EVP_DigestVerifyUpdate(a,b,c)	EVP_DigestUpdate(a,b,c)

#define BIO_set_md(b,md)		BIO_ctrl(b,BIO_C_SET_MD,0,(char *)md)
#define BIO_get_md(b,mdp)		BIO_ctrl(b,BIO_C_GET_MD,0,(char *)mdp)
#define BIO_get_md_ctx(b,mdcp)     BIO_ctrl(b,BIO_C_GET_MD_CTX,0,(char *)mdcp)
#define BIO_set_md_ctx(b,mdcp)     BIO_ctrl(b,BIO_C_SET_MD_CTX,0,(char *)mdcp)
#define BIO_get_cipher_status(b)	BIO_ctrl(b,BIO_C_GET_CIPHER_STATUS,0,NULL)
#define BIO_get_cipher_ctx(b,c_pp)	BIO_ctrl(b,BIO_C_GET_CIPHER_CTX,0,(char *)c_pp)

int EVP_Cipher(EVP_CIPHER_CTX *c, unsigned char *out, const unsigned char *in,
    unsigned int inl);

#define EVP_add_cipher_alias(n,alias) \
	OBJ_NAME_add((alias),OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS,(n))
#define EVP_add_digest_alias(n,alias) \
	OBJ_NAME_add((alias),OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS,(n))
#define EVP_delete_cipher_alias(alias) \
	OBJ_NAME_remove(alias,OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS);
#define EVP_delete_digest_alias(alias) \
	OBJ_NAME_remove(alias,OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS);

void EVP_MD_CTX_init(EVP_MD_CTX *ctx);
int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
EVP_MD_CTX *EVP_MD_CTX_create(void);
void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);
int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in);
void EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags);
void EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags);
int EVP_MD_CTX_ctrl(EVP_MD_CTX *ctx, int type, int arg, void *ptr);
int EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx, int flags);
int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);
int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);
int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);
int EVP_Digest(const void *data, size_t count, unsigned char *md,
    unsigned int *size, const EVP_MD *type, ENGINE *impl);

int EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in);
int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);

int EVP_read_pw_string(char *buf, int length, const char *prompt, int verify);
int EVP_read_pw_string_min(char *buf, int minlen, int maxlen,
    const char *prompt, int verify);
void EVP_set_pw_prompt(const char *prompt);
char *EVP_get_pw_prompt(void);

int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,
    const unsigned char *salt, const unsigned char *data, int datal, int count,
    unsigned char *key, unsigned char *iv);

void EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags);
void EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags);
int EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx, int flags);

int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
    const unsigned char *key, const unsigned char *iv);
int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
    ENGINE *impl, const unsigned char *key, const unsigned char *iv);
int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
    const unsigned char *in, int inl);
int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
#ifndef LIBRESSL_INTERNAL
int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
#endif

int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
    const unsigned char *key, const unsigned char *iv);
int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
    ENGINE *impl, const unsigned char *key, const unsigned char *iv);
int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
    const unsigned char *in, int inl);
int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
#ifndef LIBRESSL_INTERNAL
int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
#endif

int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
    const unsigned char *key, const unsigned char *iv, int enc);
int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
    ENGINE *impl, const unsigned char *key, const unsigned char *iv, int enc);
int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
    const unsigned char *in, int inl);
int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
#ifndef LIBRESSL_INTERNAL
int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
#endif
	
int EVP_SignFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s,
    EVP_PKEY *pkey);

int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf,
    unsigned int siglen, EVP_PKEY *pkey);

int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
    const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, size_t *siglen);

int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
    const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, unsigned char *sig, size_t siglen);

int EVP_OpenInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
    const unsigned char *ek, int ekl, const unsigned char *iv, EVP_PKEY *priv);
int EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
    unsigned char **ek, int *ekl, unsigned char *iv, EVP_PKEY **pubk,
    int npubk);
int EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

void EVP_EncodeInit(EVP_ENCODE_CTX *ctx);
void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,
    const unsigned char *in, int inl);
void EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl);
int EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);

void EVP_DecodeInit(EVP_ENCODE_CTX *ctx);
int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,
    const unsigned char *in, int inl);
int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl);
int EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);

void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a);
int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad);
int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);

#ifndef OPENSSL_NO_BIO
BIO_METHOD *BIO_f_md(void);
BIO_METHOD *BIO_f_base64(void);
BIO_METHOD *BIO_f_cipher(void);
void BIO_set_cipher(BIO *b, const EVP_CIPHER *c, const unsigned char *k,
    const unsigned char *i, int enc);
#endif

const EVP_MD *EVP_md_null(void);
#ifndef OPENSSL_NO_MD4
const EVP_MD *EVP_md4(void);
#endif
#ifndef OPENSSL_NO_MD5
const EVP_MD *EVP_md5(void);
const EVP_MD *EVP_md5_sha1(void);
#endif
#ifndef OPENSSL_NO_SHA
const EVP_MD *EVP_sha1(void);
const EVP_MD *EVP_dss(void);
const EVP_MD *EVP_dss1(void);
const EVP_MD *EVP_ecdsa(void);
#endif
#ifndef OPENSSL_NO_SHA256
const EVP_MD *EVP_sha224(void);
const EVP_MD *EVP_sha256(void);
#endif
#ifndef OPENSSL_NO_SHA512
const EVP_MD *EVP_sha384(void);
const EVP_MD *EVP_sha512(void);
#endif
#ifndef OPENSSL_NO_RIPEMD
const EVP_MD *EVP_ripemd160(void);
#endif
#ifndef OPENSSL_NO_WHIRLPOOL
const EVP_MD *EVP_whirlpool(void);
#endif
#ifndef OPENSSL_NO_GOST
const EVP_MD *EVP_gostr341194(void);
const EVP_MD *EVP_gost2814789imit(void);
const EVP_MD *EVP_streebog256(void);
const EVP_MD *EVP_streebog512(void);
#endif
const EVP_CIPHER *EVP_enc_null(void);		/* does nothing :-) */
#ifndef OPENSSL_NO_DES
const EVP_CIPHER *EVP_des_ecb(void);
const EVP_CIPHER *EVP_des_ede(void);
const EVP_CIPHER *EVP_des_ede3(void);
const EVP_CIPHER *EVP_des_ede_ecb(void);
const EVP_CIPHER *EVP_des_ede3_ecb(void);
const EVP_CIPHER *EVP_des_cfb64(void);
# define EVP_des_cfb EVP_des_cfb64
const EVP_CIPHER *EVP_des_cfb1(void);
const EVP_CIPHER *EVP_des_cfb8(void);
const EVP_CIPHER *EVP_des_ede_cfb64(void);
# define EVP_des_ede_cfb EVP_des_ede_cfb64
const EVP_CIPHER *EVP_des_ede3_cfb64(void);
# define EVP_des_ede3_cfb EVP_des_ede3_cfb64
const EVP_CIPHER *EVP_des_ede3_cfb1(void);
const EVP_CIPHER *EVP_des_ede3_cfb8(void);
const EVP_CIPHER *EVP_des_ofb(void);
const EVP_CIPHER *EVP_des_ede_ofb(void);
const EVP_CIPHER *EVP_des_ede3_ofb(void);
const EVP_CIPHER *EVP_des_cbc(void);
const EVP_CIPHER *EVP_des_ede_cbc(void);
const EVP_CIPHER *EVP_des_ede3_cbc(void);
const EVP_CIPHER *EVP_desx_cbc(void);
#endif
#ifndef OPENSSL_NO_RC4
const EVP_CIPHER *EVP_rc4(void);
const EVP_CIPHER *EVP_rc4_40(void);
#ifndef OPENSSL_NO_MD5
const EVP_CIPHER *EVP_rc4_hmac_md5(void);
#endif
#endif
#ifndef OPENSSL_NO_IDEA
const EVP_CIPHER *EVP_idea_ecb(void);
const EVP_CIPHER *EVP_idea_cfb64(void);
# define EVP_idea_cfb EVP_idea_cfb64
const EVP_CIPHER *EVP_idea_ofb(void);
const EVP_CIPHER *EVP_idea_cbc(void);
#endif
#ifndef OPENSSL_NO_RC2
const EVP_CIPHER *EVP_rc2_ecb(void);
const EVP_CIPHER *EVP_rc2_cbc(void);
const EVP_CIPHER *EVP_rc2_40_cbc(void);
const EVP_CIPHER *EVP_rc2_64_cbc(void);
const EVP_CIPHER *EVP_rc2_cfb64(void);
# define EVP_rc2_cfb EVP_rc2_cfb64
const EVP_CIPHER *EVP_rc2_ofb(void);
#endif
#ifndef OPENSSL_NO_BF
const EVP_CIPHER *EVP_bf_ecb(void);
const EVP_CIPHER *EVP_bf_cbc(void);
const EVP_CIPHER *EVP_bf_cfb64(void);
# define EVP_bf_cfb EVP_bf_cfb64
const EVP_CIPHER *EVP_bf_ofb(void);
#endif
#ifndef OPENSSL_NO_CAST
const EVP_CIPHER *EVP_cast5_ecb(void);
const EVP_CIPHER *EVP_cast5_cbc(void);
const EVP_CIPHER *EVP_cast5_cfb64(void);
# define EVP_cast5_cfb EVP_cast5_cfb64
const EVP_CIPHER *EVP_cast5_ofb(void);
#endif
#ifndef OPENSSL_NO_AES
const EVP_CIPHER *EVP_aes_128_ecb(void);
const EVP_CIPHER *EVP_aes_128_cbc(void);
const EVP_CIPHER *EVP_aes_128_cfb1(void);
const EVP_CIPHER *EVP_aes_128_cfb8(void);
const EVP_CIPHER *EVP_aes_128_cfb128(void);
# define EVP_aes_128_cfb EVP_aes_128_cfb128
const EVP_CIPHER *EVP_aes_128_ofb(void);
const EVP_CIPHER *EVP_aes_128_ctr(void);
const EVP_CIPHER *EVP_aes_128_ccm(void);
const EVP_CIPHER *EVP_aes_128_gcm(void);
const EVP_CIPHER *EVP_aes_128_xts(void);
const EVP_CIPHER *EVP_aes_192_ecb(void);
const EVP_CIPHER *EVP_aes_192_cbc(void);
const EVP_CIPHER *EVP_aes_192_cfb1(void);
const EVP_CIPHER *EVP_aes_192_cfb8(void);
const EVP_CIPHER *EVP_aes_192_cfb128(void);
# define EVP_aes_192_cfb EVP_aes_192_cfb128
const EVP_CIPHER *EVP_aes_192_ofb(void);
const EVP_CIPHER *EVP_aes_192_ctr(void);
const EVP_CIPHER *EVP_aes_192_ccm(void);
const EVP_CIPHER *EVP_aes_192_gcm(void);
const EVP_CIPHER *EVP_aes_256_ecb(void);
const EVP_CIPHER *EVP_aes_256_cbc(void);
const EVP_CIPHER *EVP_aes_256_cfb1(void);
const EVP_CIPHER *EVP_aes_256_cfb8(void);
const EVP_CIPHER *EVP_aes_256_cfb128(void);
# define EVP_aes_256_cfb EVP_aes_256_cfb128
const EVP_CIPHER *EVP_aes_256_ofb(void);
const EVP_CIPHER *EVP_aes_256_ctr(void);
const EVP_CIPHER *EVP_aes_256_ccm(void);
const EVP_CIPHER *EVP_aes_256_gcm(void);
const EVP_CIPHER *EVP_aes_256_xts(void);
#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void);
const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void);
#endif
#endif
#ifndef OPENSSL_NO_CAMELLIA
const EVP_CIPHER *EVP_camellia_128_ecb(void);
const EVP_CIPHER *EVP_camellia_128_cbc(void);
const EVP_CIPHER *EVP_camellia_128_cfb1(void);
const EVP_CIPHER *EVP_camellia_128_cfb8(void);
const EVP_CIPHER *EVP_camellia_128_cfb128(void);
# define EVP_camellia_128_cfb EVP_camellia_128_cfb128
const EVP_CIPHER *EVP_camellia_128_ofb(void);
const EVP_CIPHER *EVP_camellia_192_ecb(void);
const EVP_CIPHER *EVP_camellia_192_cbc(void);
const EVP_CIPHER *EVP_camellia_192_cfb1(void);
const EVP_CIPHER *EVP_camellia_192_cfb8(void);
const EVP_CIPHER *EVP_camellia_192_cfb128(void);
# define EVP_camellia_192_cfb EVP_camellia_192_cfb128
const EVP_CIPHER *EVP_camellia_192_ofb(void);
const EVP_CIPHER *EVP_camellia_256_ecb(void);
const EVP_CIPHER *EVP_camellia_256_cbc(void);
const EVP_CIPHER *EVP_camellia_256_cfb1(void);
const EVP_CIPHER *EVP_camellia_256_cfb8(void);
const EVP_CIPHER *EVP_camellia_256_cfb128(void);
# define EVP_camellia_256_cfb EVP_camellia_256_cfb128
const EVP_CIPHER *EVP_camellia_256_ofb(void);
#endif

#ifndef OPENSSL_NO_CHACHA
const EVP_CIPHER *EVP_chacha20(void);
#endif

#ifndef OPENSSL_NO_GOST
const EVP_CIPHER *EVP_gost2814789_ecb(void);
const EVP_CIPHER *EVP_gost2814789_cfb64(void);
const EVP_CIPHER *EVP_gost2814789_cnt(void);
#endif

void OPENSSL_add_all_algorithms_noconf(void);
void OPENSSL_add_all_algorithms_conf(void);

#ifdef OPENSSL_LOAD_CONF
#define OpenSSL_add_all_algorithms() OPENSSL_add_all_algorithms_conf()
#else
#define OpenSSL_add_all_algorithms() OPENSSL_add_all_algorithms_noconf()
#endif

void OpenSSL_add_all_ciphers(void);
void OpenSSL_add_all_digests(void);

#define SSLeay_add_all_algorithms() OpenSSL_add_all_algorithms()
#define SSLeay_add_all_ciphers() OpenSSL_add_all_ciphers()
#define SSLeay_add_all_digests() OpenSSL_add_all_digests()

int EVP_add_cipher(const EVP_CIPHER *cipher);
int EVP_add_digest(const EVP_MD *digest);

const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
const EVP_MD *EVP_get_digestbyname(const char *name);
void EVP_cleanup(void);

void EVP_CIPHER_do_all(void (*fn)(const EVP_CIPHER *ciph, const char *from,
    const char *to, void *x), void *arg);
void EVP_CIPHER_do_all_sorted(void (*fn)(const EVP_CIPHER *ciph,
    const char *from, const char *to, void *x), void *arg);

void EVP_MD_do_all(void (*fn)(const EVP_MD *ciph, const char *from,
    const char *to, void *x), void *arg);
void EVP_MD_do_all_sorted(void (*fn)(const EVP_MD *ciph, const char *from,
    const char *to, void *x), void *arg);

int EVP_PKEY_decrypt_old(unsigned char *dec_key, const unsigned char *enc_key,
    int enc_key_len, EVP_PKEY *private_key);
int EVP_PKEY_encrypt_old(unsigned char *enc_key, const unsigned char *key,
    int key_len, EVP_PKEY *pub_key);
int EVP_PKEY_type(int type);
int EVP_PKEY_id(const EVP_PKEY *pkey);
int EVP_PKEY_base_id(const EVP_PKEY *pkey);
int EVP_PKEY_bits(EVP_PKEY *pkey);
int EVP_PKEY_size(EVP_PKEY *pkey);
int EVP_PKEY_set_type(EVP_PKEY *pkey, int type);
int EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len);
int EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key);
void *EVP_PKEY_get0(EVP_PKEY *pkey);

#ifndef OPENSSL_NO_RSA
struct rsa_st;
int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, struct rsa_st *key);
struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);
#endif
#ifndef OPENSSL_NO_DSA
struct dsa_st;
int EVP_PKEY_set1_DSA(EVP_PKEY *pkey, struct dsa_st *key);
struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);
#endif
#ifndef OPENSSL_NO_DH
struct dh_st;
int EVP_PKEY_set1_DH(EVP_PKEY *pkey, struct dh_st *key);
struct dh_st *EVP_PKEY_get1_DH(EVP_PKEY *pkey);
#endif
#ifndef OPENSSL_NO_EC
struct ec_key_st;
int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, struct ec_key_st *key);
struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);
#endif
#ifndef OPENSSL_NO_GOST
struct gost_key_st;
#endif

EVP_PKEY *EVP_PKEY_new(void);
void EVP_PKEY_free(EVP_PKEY *pkey);

EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
    long length);
int i2d_PublicKey(EVP_PKEY *a, unsigned char **pp);

EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
    long length);
EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
    long length);
int i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp);

int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);
int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);
int EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode);
int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);

int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);

int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey, int indent,
    ASN1_PCTX *pctx);
int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey, int indent,
    ASN1_PCTX *pctx);
int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey, int indent,
    ASN1_PCTX *pctx);

int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);

int EVP_CIPHER_type(const EVP_CIPHER *ctx);

/* calls methods */
int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);

/* These are used by EVP_CIPHER methods */
int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type);

/* PKCS5 password based encryption */
int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
    ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de);
int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
    const unsigned char *salt, int saltlen, int iter, int keylen,
    unsigned char *out);
int PKCS5_PBKDF2_HMAC(const char *pass, int passlen, const unsigned char *salt,
    int saltlen, int iter, const EVP_MD *digest, int keylen,
    unsigned char *out);
int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
    ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,
    int en_de);

void PKCS5_PBE_add(void);

int EVP_PBE_CipherInit (ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
    ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de);

/* PBE type */

/* Can appear as the outermost AlgorithmIdentifier */
#define EVP_PBE_TYPE_OUTER	0x0
/* Is an PRF type OID */
#define EVP_PBE_TYPE_PRF	0x1

int EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid, int md_nid,
    EVP_PBE_KEYGEN *keygen);
int EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,
    EVP_PBE_KEYGEN *keygen);
int EVP_PBE_find(int type, int pbe_nid, int *pcnid, int *pmnid,
    EVP_PBE_KEYGEN **pkeygen);
void EVP_PBE_cleanup(void);

#define ASN1_PKEY_ALIAS		0x1
#define ASN1_PKEY_DYNAMIC	0x2
#define ASN1_PKEY_SIGPARAM_NULL	0x4

#define ASN1_PKEY_CTRL_PKCS7_SIGN	0x1
#define ASN1_PKEY_CTRL_PKCS7_ENCRYPT	0x2
#define ASN1_PKEY_CTRL_DEFAULT_MD_NID	0x3
#define ASN1_PKEY_CTRL_CMS_SIGN		0x5
#define ASN1_PKEY_CTRL_CMS_ENVELOPE	0x7

int EVP_PKEY_asn1_get_count(void);
const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx);
const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type);
const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe,
    const char *str, int len);
int EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth);
int EVP_PKEY_asn1_add_alias(int to, int from);
int EVP_PKEY_asn1_get0_info(int *ppkey_id, int *pkey_base_id, int *ppkey_flags,
    const char **pinfo, const char **ppem_str,
    const EVP_PKEY_ASN1_METHOD *ameth);

const EVP_PKEY_ASN1_METHOD* EVP_PKEY_get0_asn1(EVP_PKEY *pkey);
EVP_PKEY_ASN1_METHOD* EVP_PKEY_asn1_new(int id, int flags, const char *pem_str,
    const char *info);
void EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst,
    const EVP_PKEY_ASN1_METHOD *src);
void EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth);
void EVP_PKEY_asn1_set_public(EVP_PKEY_ASN1_METHOD *ameth,
    int (*pub_decode)(EVP_PKEY *pk, X509_PUBKEY *pub),
    int (*pub_encode)(X509_PUBKEY *pub, const EVP_PKEY *pk),
    int (*pub_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
    int (*pub_print)(BIO *out, const EVP_PKEY *pkey, int indent,
    ASN1_PCTX *pctx),
    int (*pkey_size)(const EVP_PKEY *pk),
    int (*pkey_bits)(const EVP_PKEY *pk));
void EVP_PKEY_asn1_set_private(EVP_PKEY_ASN1_METHOD *ameth,
    int (*priv_decode)(EVP_PKEY *pk, PKCS8_PRIV_KEY_INFO *p8inf),
    int (*priv_encode)(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pk),
    int (*priv_print)(BIO *out, const EVP_PKEY *pkey, int indent,
    ASN1_PCTX *pctx));
void EVP_PKEY_asn1_set_param(EVP_PKEY_ASN1_METHOD *ameth,
    int (*param_decode)(EVP_PKEY *pkey, const unsigned char **pder, int derlen),
    int (*param_encode)(const EVP_PKEY *pkey, unsigned char **pder),
    int (*param_missing)(const EVP_PKEY *pk),
    int (*param_copy)(EVP_PKEY *to, const EVP_PKEY *from),
    int (*param_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
    int (*param_print)(BIO *out, const EVP_PKEY *pkey, int indent,
    ASN1_PCTX *pctx));

void EVP_PKEY_asn1_set_free(EVP_PKEY_ASN1_METHOD *ameth,
    void (*pkey_free)(EVP_PKEY *pkey));
void EVP_PKEY_asn1_set_ctrl(EVP_PKEY_ASN1_METHOD *ameth,
    int (*pkey_ctrl)(EVP_PKEY *pkey, int op, long arg1, void *arg2));

#define EVP_PKEY_OP_UNDEFINED		0
#define EVP_PKEY_OP_PARAMGEN		(1<<1)
#define EVP_PKEY_OP_KEYGEN		(1<<2)
#define EVP_PKEY_OP_SIGN		(1<<3)
#define EVP_PKEY_OP_VERIFY		(1<<4)
#define EVP_PKEY_OP_VERIFYRECOVER	(1<<5)
#define EVP_PKEY_OP_SIGNCTX		(1<<6)
#define EVP_PKEY_OP_VERIFYCTX		(1<<7)
#define EVP_PKEY_OP_ENCRYPT		(1<<8)
#define EVP_PKEY_OP_DECRYPT		(1<<9)
#define EVP_PKEY_OP_DERIVE		(1<<10)

#define EVP_PKEY_OP_TYPE_SIG	\
	(EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY | EVP_PKEY_OP_VERIFYRECOVER \
		| EVP_PKEY_OP_SIGNCTX | EVP_PKEY_OP_VERIFYCTX)

#define EVP_PKEY_OP_TYPE_CRYPT \
	(EVP_PKEY_OP_ENCRYPT | EVP_PKEY_OP_DECRYPT)

#define EVP_PKEY_OP_TYPE_NOGEN \
	(EVP_PKEY_OP_SIG | EVP_PKEY_OP_CRYPT | EVP_PKEY_OP_DERIVE)

#define EVP_PKEY_OP_TYPE_GEN \
		(EVP_PKEY_OP_PARAMGEN | EVP_PKEY_OP_KEYGEN)

#define	 EVP_PKEY_CTX_set_signature_md(ctx, md)	\
		EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_TYPE_SIG,  \
					EVP_PKEY_CTRL_MD, 0, (void *)md)

#define EVP_PKEY_CTRL_MD		1
#define EVP_PKEY_CTRL_PEER_KEY		2

#define EVP_PKEY_CTRL_PKCS7_ENCRYPT	3
#define EVP_PKEY_CTRL_PKCS7_DECRYPT	4

#define EVP_PKEY_CTRL_PKCS7_SIGN	5

#define EVP_PKEY_CTRL_SET_MAC_KEY	6

#define EVP_PKEY_CTRL_DIGESTINIT	7

/* Used by GOST key encryption in TLS */
#define EVP_PKEY_CTRL_SET_IV 		8

#define EVP_PKEY_CTRL_CMS_ENCRYPT	9
#define EVP_PKEY_CTRL_CMS_DECRYPT	10
#define EVP_PKEY_CTRL_CMS_SIGN		11

#define EVP_PKEY_CTRL_CIPHER		12

#define EVP_PKEY_ALG_CTRL		0x1000


#define EVP_PKEY_FLAG_AUTOARGLEN	2
/* Method handles all operations: don't assume any digest related
 * defaults.
 */
#define EVP_PKEY_FLAG_SIGCTX_CUSTOM	4

const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type);
EVP_PKEY_METHOD* EVP_PKEY_meth_new(int id, int flags);
void EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,
    const EVP_PKEY_METHOD *meth);
void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src);
void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth);
int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth);

EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);
EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);
EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);
void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);

int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype, int cmd,
    int p1, void *p2);
int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
    const char *value);

int EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx);
void EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen);

EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e, const unsigned char *key,
    int keylen);

void EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data);
void *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx);
EVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx);

EVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx);

void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);
void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);

int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_sign(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
    const unsigned char *tbs, size_t tbslen);
int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_verify(EVP_PKEY_CTX *ctx, const unsigned char *sig, size_t siglen,
    const unsigned char *tbs, size_t tbslen);
int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx, unsigned char *rout,
    size_t *routlen, const unsigned char *sig, size_t siglen);
int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
    const unsigned char *in, size_t inlen);
int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
    const unsigned char *in, size_t inlen);

int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);
int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);

typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);

int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);

void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);
EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);

int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);

void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,
    int (*init)(EVP_PKEY_CTX *ctx));

void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,
    int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src));

void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,
    void (*cleanup)(EVP_PKEY_CTX *ctx));

void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,
    int (*paramgen_init)(EVP_PKEY_CTX *ctx),
    int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));

void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,
    int (*keygen_init)(EVP_PKEY_CTX *ctx),
    int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));

void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,
    int (*sign_init)(EVP_PKEY_CTX *ctx),
    int (*sign)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
    const unsigned char *tbs, size_t tbslen));

void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,
    int (*verify_init)(EVP_PKEY_CTX *ctx),
    int (*verify)(EVP_PKEY_CTX *ctx, const unsigned char *sig, size_t siglen,
    const unsigned char *tbs, size_t tbslen));

void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,
    int (*verify_recover_init)(EVP_PKEY_CTX *ctx),
    int (*verify_recover)(EVP_PKEY_CTX *ctx, unsigned char *sig,
    size_t *siglen, const unsigned char *tbs, size_t tbslen));

void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,
    int (*signctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
    int (*signctx)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
    EVP_MD_CTX *mctx));

void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,
    int (*verifyctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
    int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig, int siglen,
    EVP_MD_CTX *mctx));

void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,
    int (*encrypt_init)(EVP_PKEY_CTX *ctx),
    int (*encryptfn)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
    const unsigned char *in, size_t inlen));

void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,
    int (*decrypt_init)(EVP_PKEY_CTX *ctx),
    int (*decrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
    const unsigned char *in, size_t inlen));

void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,
    int (*derive_init)(EVP_PKEY_CTX *ctx),
    int (*derive)(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen));

void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,
    int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2),
    int (*ctrl_str)(EVP_PKEY_CTX *ctx, const char *type, const char *value));

/* Authenticated Encryption with Additional Data.
 *
 * AEAD couples confidentiality and integrity in a single primtive. AEAD
 * algorithms take a key and then can seal and open individual messages. Each
 * message has a unique, per-message nonce and, optionally, additional data
 * which is authenticated but not included in the output. */

struct evp_aead_st;
typedef struct evp_aead_st EVP_AEAD;

#ifndef OPENSSL_NO_AES
/* EVP_aes_128_gcm is AES-128 in Galois Counter Mode. */
const EVP_AEAD *EVP_aead_aes_128_gcm(void);
/* EVP_aes_256_gcm is AES-256 in Galois Counter Mode. */
const EVP_AEAD *EVP_aead_aes_256_gcm(void);
#endif

#if !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)
/* EVP_aead_chacha20_poly1305 is ChaCha20 with a Poly1305 authenticator. */
const EVP_AEAD *EVP_aead_chacha20_poly1305(void);
const EVP_AEAD *EVP_aead_chacha20_poly1305_old(void);
#endif

/* EVP_AEAD_key_length returns the length of the keys used. */
size_t EVP_AEAD_key_length(const EVP_AEAD *aead);

/* EVP_AEAD_nonce_length returns the length of the per-message nonce. */
size_t EVP_AEAD_nonce_length(const EVP_AEAD *aead);

/* EVP_AEAD_max_overhead returns the maximum number of additional bytes added
 * by the act of sealing data with the AEAD. */
size_t EVP_AEAD_max_overhead(const EVP_AEAD *aead);

/* EVP_AEAD_max_tag_len returns the maximum tag length when using this AEAD.
 * This * is the largest value that can be passed as a tag length to
 * EVP_AEAD_CTX_init. */
size_t EVP_AEAD_max_tag_len(const EVP_AEAD *aead);

/* An EVP_AEAD_CTX represents an AEAD algorithm configured with a specific key
 * and message-independent IV. */
typedef struct evp_aead_ctx_st {
	const EVP_AEAD *aead;
	/* aead_state is an opaque pointer to the AEAD specific state. */
	void *aead_state;
} EVP_AEAD_CTX;

/* EVP_AEAD_MAX_TAG_LENGTH is the maximum tag length used by any AEAD
 * defined in this header. */
#define EVP_AEAD_MAX_TAG_LENGTH 16

/* EVP_AEAD_DEFAULT_TAG_LENGTH is a magic value that can be passed to
 * EVP_AEAD_CTX_init to indicate that the default tag length for an AEAD
 * should be used. */
#define EVP_AEAD_DEFAULT_TAG_LENGTH 0

/* EVP_AEAD_init initializes the context for the given AEAD algorithm.
 * The implementation argument may be NULL to choose the default implementation.
 * Authentication tags may be truncated by passing a tag length. A tag length
 * of zero indicates the default tag length should be used. */
int EVP_AEAD_CTX_init(EVP_AEAD_CTX *ctx, const EVP_AEAD *aead,
    const unsigned char *key, size_t key_len, size_t tag_len, ENGINE *impl);

/* EVP_AEAD_CTX_cleanup frees any data allocated for this context. */
void EVP_AEAD_CTX_cleanup(EVP_AEAD_CTX *ctx);

/* EVP_AEAD_CTX_seal encrypts and authenticates the input and authenticates
 * any additional data (AD), the result being written as output. One is
 * returned on success, otherwise zero.
 *
 * This function may be called (with the same EVP_AEAD_CTX) concurrently with
 * itself or EVP_AEAD_CTX_open.
 *
 * At most max_out_len bytes are written as output and, in order to ensure
 * success, this value should be the length of the input plus the result of
 * EVP_AEAD_overhead. On successful return, out_len is set to the actual
 * number of bytes written.
 *
 * The length of the nonce is must be equal to the result of
 * EVP_AEAD_nonce_length for this AEAD.
 *
 * EVP_AEAD_CTX_seal never results in a partial output. If max_out_len is
 * insufficient, zero will be returned and out_len will be set to zero.
 *
 * If the input and output are aliased then out must be <= in. */
int EVP_AEAD_CTX_seal(const EVP_AEAD_CTX *ctx, unsigned char *out,
    size_t *out_len, size_t max_out_len, const unsigned char *nonce,
    size_t nonce_len, const unsigned char *in, size_t in_len,
    const unsigned char *ad, size_t ad_len);

/* EVP_AEAD_CTX_open authenticates the input and additional data, decrypting
 * the input and writing it as output. One is returned on success, otherwise
 * zero.
 *
 * This function may be called (with the same EVP_AEAD_CTX) concurrently with
 * itself or EVP_AEAD_CTX_seal.
 *
 * At most the number of input bytes are written as output. In order to ensure
 * success, max_out_len should be at least the same as the input length. On
 * successful return out_len is set to the actual number of bytes written.
 *
 * The length of nonce must be equal to the result of EVP_AEAD_nonce_length
 * for this AEAD.
 *
 * EVP_AEAD_CTX_open never results in a partial output. If max_out_len is
 * insufficient, zero will be returned and out_len will be set to zero.
 *
 * If the input and output are aliased then out must be <= in. */
int EVP_AEAD_CTX_open(const EVP_AEAD_CTX *ctx, unsigned char *out,
    size_t *out_len, size_t max_out_len, const unsigned char *nonce,
    size_t nonce_len, const unsigned char *in, size_t in_len,
    const unsigned char *ad, size_t ad_len);

void EVP_add_alg_module(void);

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_EVP_strings(void);

/* Error codes for the EVP functions. */

/* Function codes. */
#define EVP_F_AEAD_AES_GCM_INIT				 187
#define EVP_F_AEAD_AES_GCM_OPEN				 188
#define EVP_F_AEAD_AES_GCM_SEAL				 189
#define EVP_F_AEAD_CHACHA20_POLY1305_INIT		 192
#define EVP_F_AEAD_CHACHA20_POLY1305_OPEN		 193
#define EVP_F_AEAD_CHACHA20_POLY1305_SEAL		 194
#define EVP_F_AEAD_CTX_OPEN				 185
#define EVP_F_AEAD_CTX_SEAL				 186
#define EVP_F_AESNI_INIT_KEY				 165
#define EVP_F_AESNI_XTS_CIPHER				 176
#define EVP_F_AES_INIT_KEY				 133
#define EVP_F_AES_XTS					 172
#define EVP_F_AES_XTS_CIPHER				 175
#define EVP_F_ALG_MODULE_INIT				 177
#define EVP_F_CAMELLIA_INIT_KEY				 159
#define EVP_F_CMAC_INIT					 173
#define EVP_F_D2I_PKEY					 100
#define EVP_F_DO_SIGVER_INIT				 161
#define EVP_F_DSAPKEY2PKCS8				 134
#define EVP_F_DSA_PKEY2PKCS8				 135
#define EVP_F_ECDSA_PKEY2PKCS8				 129
#define EVP_F_ECKEY_PKEY2PKCS8				 132
#define EVP_F_EVP_AEAD_CTX_INIT				 180
#define EVP_F_EVP_AEAD_CTX_OPEN				 190
#define EVP_F_EVP_AEAD_CTX_SEAL				 191
#define EVP_F_EVP_BYTESTOKEY				 200
#define EVP_F_EVP_CIPHERINIT_EX				 123
#define EVP_F_EVP_CIPHER_CTX_COPY			 163
#define EVP_F_EVP_CIPHER_CTX_CTRL			 124
#define EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH		 122
#define EVP_F_EVP_CIPHER_GET_ASN1_IV			 201
#define EVP_F_EVP_CIPHER_SET_ASN1_IV			 202
#define EVP_F_EVP_DECRYPTFINAL_EX			 101
#define EVP_F_EVP_DECRYPTUPDATE				 199
#define EVP_F_EVP_DIGESTFINAL_EX			 196
#define EVP_F_EVP_DIGESTINIT_EX				 128
#define EVP_F_EVP_ENCRYPTFINAL_EX			 127
#define EVP_F_EVP_ENCRYPTUPDATE				 198
#define EVP_F_EVP_MD_CTX_COPY_EX			 110
#define EVP_F_EVP_MD_CTX_CTRL				 195
#define EVP_F_EVP_MD_SIZE				 162
#define EVP_F_EVP_OPENINIT				 102
#define EVP_F_EVP_PBE_ALG_ADD				 115
#define EVP_F_EVP_PBE_ALG_ADD_TYPE			 160
#define EVP_F_EVP_PBE_CIPHERINIT			 116
#define EVP_F_EVP_PKCS82PKEY				 111
#define EVP_F_EVP_PKCS82PKEY_BROKEN			 136
#define EVP_F_EVP_PKEY2PKCS8_BROKEN			 113
#define EVP_F_EVP_PKEY_COPY_PARAMETERS			 103
#define EVP_F_EVP_PKEY_CTX_CTRL				 137
#define EVP_F_EVP_PKEY_CTX_CTRL_STR			 150
#define EVP_F_EVP_PKEY_CTX_DUP				 156
#define EVP_F_EVP_PKEY_DECRYPT				 104
#define EVP_F_EVP_PKEY_DECRYPT_INIT			 138
#define EVP_F_EVP_PKEY_DECRYPT_OLD			 151
#define EVP_F_EVP_PKEY_DERIVE				 153
#define EVP_F_EVP_PKEY_DERIVE_INIT			 154
#define EVP_F_EVP_PKEY_DERIVE_SET_PEER			 155
#define EVP_F_EVP_PKEY_ENCRYPT				 105
#define EVP_F_EVP_PKEY_ENCRYPT_INIT			 139
#define EVP_F_EVP_PKEY_ENCRYPT_OLD			 152
#define EVP_F_EVP_PKEY_GET1_DH				 119
#define EVP_F_EVP_PKEY_GET1_DSA				 120
#define EVP_F_EVP_PKEY_GET1_ECDSA			 130
#define EVP_F_EVP_PKEY_GET1_EC_KEY			 131
#define EVP_F_EVP_PKEY_GET1_RSA				 121
#define EVP_F_EVP_PKEY_KEYGEN				 146
#define EVP_F_EVP_PKEY_KEYGEN_INIT			 147
#define EVP_F_EVP_PKEY_NEW				 106
#define EVP_F_EVP_PKEY_PARAMGEN				 148
#define EVP_F_EVP_PKEY_PARAMGEN_INIT			 149
#define EVP_F_EVP_PKEY_SIGN				 140
#define EVP_F_EVP_PKEY_SIGN_INIT			 141
#define EVP_F_EVP_PKEY_VERIFY				 142
#define EVP_F_EVP_PKEY_VERIFY_INIT			 143
#define EVP_F_EVP_PKEY_VERIFY_RECOVER			 144
#define EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT		 145
#define EVP_F_EVP_RIJNDAEL				 126
#define EVP_F_EVP_SIGNFINAL				 107
#define EVP_F_EVP_VERIFYFINAL				 108
#define EVP_F_FIPS_CIPHERINIT				 166
#define EVP_F_FIPS_CIPHER_CTX_COPY			 170
#define EVP_F_FIPS_CIPHER_CTX_CTRL			 167
#define EVP_F_FIPS_CIPHER_CTX_SET_KEY_LENGTH		 171
#define EVP_F_FIPS_DIGESTINIT				 168
#define EVP_F_FIPS_MD_CTX_COPY				 169
#define EVP_F_HMAC_INIT_EX				 174
#define EVP_F_INT_CTX_NEW				 157
#define EVP_F_PKCS5_PBE_KEYIVGEN			 117
#define EVP_F_PKCS5_V2_PBE_KEYIVGEN			 118
#define EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN			 164
#define EVP_F_PKCS8_SET_BROKEN				 112
#define EVP_F_PKEY_SET_TYPE				 158
#define EVP_F_RC2_GET_ASN1_TYPE_AND_IV			 197
#define EVP_F_RC2_MAGIC_TO_METH				 109
#define EVP_F_RC5_CTRL					 125

/* Reason codes. */
#define EVP_R_AES_IV_SETUP_FAILED			 162
#define EVP_R_AES_KEY_SETUP_FAILED			 143
#define EVP_R_ASN1_LIB					 140
#define EVP_R_BAD_BLOCK_LENGTH				 136
#define EVP_R_BAD_DECRYPT				 100
#define EVP_R_BAD_KEY_LENGTH				 137
#define EVP_R_BN_DECODE_ERROR				 112
#define EVP_R_BN_PUBKEY_ERROR				 113
#define EVP_R_BUFFER_TOO_SMALL				 155
#define EVP_R_CAMELLIA_KEY_SETUP_FAILED			 157
#define EVP_R_CIPHER_PARAMETER_ERROR			 122
#define EVP_R_COMMAND_NOT_SUPPORTED			 147
#define EVP_R_CTRL_NOT_IMPLEMENTED			 132
#define EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED		 133
#define EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH		 138
#define EVP_R_DECODE_ERROR				 114
#define EVP_R_DIFFERENT_KEY_TYPES			 101
#define EVP_R_DIFFERENT_PARAMETERS			 153
#define EVP_R_DISABLED_FOR_FIPS				 163
#define EVP_R_ENCODE_ERROR				 115
#define EVP_R_ERROR_LOADING_SECTION			 165
#define EVP_R_ERROR_SETTING_FIPS_MODE			 166
#define EVP_R_EVP_PBE_CIPHERINIT_ERROR			 119
#define EVP_R_EXPECTING_AN_RSA_KEY			 127
#define EVP_R_EXPECTING_A_DH_KEY			 128
#define EVP_R_EXPECTING_A_DSA_KEY			 129
#define EVP_R_EXPECTING_A_ECDSA_KEY			 141
#define EVP_R_EXPECTING_A_EC_KEY			 142
#define EVP_R_FIPS_MODE_NOT_SUPPORTED			 167
#define EVP_R_INITIALIZATION_ERROR			 134
#define EVP_R_INPUT_NOT_INITIALIZED			 111
#define EVP_R_INVALID_DIGEST				 152
#define EVP_R_INVALID_FIPS_MODE				 168
#define EVP_R_INVALID_KEY_LENGTH			 130
#define EVP_R_INVALID_OPERATION				 148
#define EVP_R_IV_TOO_LARGE				 102
#define EVP_R_KEYGEN_FAILURE				 120
#define EVP_R_MESSAGE_DIGEST_IS_NULL			 159
#define EVP_R_METHOD_NOT_SUPPORTED			 144
#define EVP_R_MISSING_PARAMETERS			 103
#define EVP_R_NO_CIPHER_SET				 131
#define EVP_R_NO_DEFAULT_DIGEST				 158
#define EVP_R_NO_DIGEST_SET				 139
#define EVP_R_NO_DSA_PARAMETERS				 116
#define EVP_R_NO_KEY_SET				 154
#define EVP_R_NO_OPERATION_SET				 149
#define EVP_R_NO_SIGN_FUNCTION_CONFIGURED		 104
#define EVP_R_NO_VERIFY_FUNCTION_CONFIGURED		 105
#define EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE	 150
#define EVP_R_OPERATON_NOT_INITIALIZED			 151
#define EVP_R_OUTPUT_ALIASES_INPUT			 172
#define EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE			 117
#define EVP_R_PRIVATE_KEY_DECODE_ERROR			 145
#define EVP_R_PRIVATE_KEY_ENCODE_ERROR			 146
#define EVP_R_PUBLIC_KEY_NOT_RSA			 106
#define EVP_R_TAG_TOO_LARGE				 171
#define EVP_R_TOO_LARGE					 164
#define EVP_R_UNKNOWN_CIPHER				 160
#define EVP_R_UNKNOWN_DIGEST				 161
#define EVP_R_UNKNOWN_OPTION				 169
#define EVP_R_UNKNOWN_PBE_ALGORITHM			 121
#define EVP_R_UNSUPORTED_NUMBER_OF_ROUNDS		 135
#define EVP_R_UNSUPPORTED_ALGORITHM			 156
#define EVP_R_UNSUPPORTED_CIPHER			 107
#define EVP_R_UNSUPPORTED_KEYLENGTH			 123
#define EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION	 124
#define EVP_R_UNSUPPORTED_KEY_SIZE			 108
#define EVP_R_UNSUPPORTED_PRF				 125
#define EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM		 118
#define EVP_R_UNSUPPORTED_SALT_TYPE			 126
#define EVP_R_WRONG_FINAL_BLOCK_LENGTH			 109
#define EVP_R_WRONG_PUBLIC_KEY_TYPE			 110

#ifdef  __cplusplus
}
#endif
#endif
@


1.51
log
@deprecate internal use of EVP_[Cipher|Encrypt|Decrypt]_Final.
14 years ago these were changed in OpenSSL to be the same
as the _ex functions. We use the _ex functions only internally
to ensure it is obvious the ctx must be cleared.
ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.50 2016/04/28 16:06:53 jsing Exp $ */
d662 1
@


1.50
log
@Rename EVP_aead_chacha20_poly1305() to EVP_aead_chacha20_poly1305_old()
and replace with EVP_aead_chacha20_poly1305_ietf(). The IETF version will
become the standard version.

Discussed with many.
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.49 2015/11/02 15:40:53 reyk Exp $ */
d578 1
d580 1
d588 2
d591 1
a591 1
int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
d599 2
d602 2
a603 2
int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

@


1.49
log
@Add EVP_aead_chacha20_poly1305_ietf() - The informational RFC 7539,
"ChaCha20 and Poly1305 for IETF Protocols", introduced a modified AEAD
construction that is incompatible with the common style that has been
already used in TLS with EVP_aead_chacha20_poly1305().  The IETF
version also adds a constant (salt) that is prepended to the nonce.

OK mikeb@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.48 2015/09/14 01:45:03 doug Exp $ */
d1218 1
a1218 1
const EVP_AEAD *EVP_aead_chacha20_poly1305_ietf(void);
@


1.48
log
@Temporarily revive MD4 for MS CHAP support.
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.47 2015/09/13 23:36:21 doug Exp $ */
d1218 1
@


1.47
log
@Remove MD4 support from LibreSSL.

MD4 should have been removed a long time ago.  Also, RFC 6150 moved it to
historic in 2011.  Rides the major crank from removing SHA-0.

Discussed with many including beck@@, millert@@, djm@@, sthen@@
ok jsing@@, input + ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.46 2015/09/13 21:09:56 doug Exp $ */
d651 3
@


1.46
log
@Remove SHA-0 support.

SHA-0 was withdrawn shortly after publication 20 years ago and replaced
with SHA-1.  This will require a major crank.

ok bcook@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.45 2015/06/20 01:07:24 doug Exp $ */
a650 3
#ifndef OPENSSL_NO_MD4
const EVP_MD *EVP_md4(void);
#endif
@


1.45
log
@Remove obsolete MDC-2DES from libcrypto.

ok deraadt@@ jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.44 2015/02/10 11:45:09 jsing Exp $ */
a657 1
const EVP_MD *EVP_sha(void);
@


1.44
log
@unifdef OPENSSL_NO_RC5
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.43 2015/02/10 09:52:35 miod Exp $ */
a670 3
#endif
#ifndef OPENSSL_NO_MDC2
const EVP_MD *EVP_mdc2(void);
@


1.43
log
@Replace assert() and OPENSSL_assert() calls with proper error return paths.
Careful review, feedback & ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.42 2015/02/08 22:22:13 miod Exp $ */
a747 7
#endif
#ifndef OPENSSL_NO_RC5
const EVP_CIPHER *EVP_rc5_32_12_16_cbc(void);
const EVP_CIPHER *EVP_rc5_32_12_16_ecb(void);
const EVP_CIPHER *EVP_rc5_32_12_16_cfb64(void);
# define EVP_rc5_32_12_16_cfb EVP_rc5_32_12_16_cfb64
const EVP_CIPHER *EVP_rc5_32_12_16_ofb(void);
@


1.42
log
@Move a few typedef up in this file in order to be able to use them in env_md_st
and get rid of a silly FIXME comment.
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.41 2015/02/07 13:19:15 doug Exp $ */
d1356 1
d1361 2
d1364 2
d1368 1
d1424 1
@


1.41
log
@Delete a lot of #if 0 code in libressl.

There are a few instances where #if 1 is removed but the code remains.

Based on the following OpenSSL commits.  Some of the commits weren't
strictly deletions so they are going to be split up into separate commits.

6f91b017bbb7140f816721141ac156d1b828a6b3
3d47c1d331fdc7574d2275cda1a630ccdb624b08
dfb56425b68314b2b57e17c82c1df42e7a015132
c8fa2356a00cbaada8963f739e5570298311a060
f16a64d11f55c01f56baa62ebf1dec7f8fe718cb
9ccc00ef6ea65567622e40c49aca43f2c6d79cdb
02a938c953b3e1ced71d9a832de1618f907eb96d
75d0ebef2aef7a2c77b27575b8da898e22f3ccd5
d6fbb194095312f4722c81c9362dbd0de66cb656
6f1a93ad111c7dfe36a09a976c4c009079b19ea1
1a5adcfb5edfe23908b350f8757df405b0f5f71f
8de24b792743d11e1d5a0dcd336a49368750c577
a2b18e657ea1a932d125154f4e13ab2258796d90
8e964419603d2478dfb391c66e7ccb2dcc9776b4
32dfde107636ac9bc62a5b3233fe2a54dbc27008

input + ok jsing@@, miod@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.40 2014/11/09 19:17:13 miod Exp $ */
d157 7
d176 2
a177 6
	/* FIXME: prototype these some day */
	int (*sign)(int type, const unsigned char *m, unsigned int m_length,
	    unsigned char *sigret, unsigned int *siglen, void *key);
	int (*verify)(int type, const unsigned char *m, unsigned int m_length,
	    const unsigned char *sigbuf, unsigned int siglen,
	    void *key);
a183 7

typedef int evp_sign_method(int type, const unsigned char *m,
    unsigned int m_length, unsigned char *sigret, unsigned int *siglen,
    void *key);
typedef int evp_verify_method(int type, const unsigned char *m,
    unsigned int m_length, const unsigned char *sigbuf, unsigned int siglen,
    void *key);
@


1.40
log
@GOST crypto algorithms (well, most of them), ported from the removed GOST
engine to regular EVP citizens, contributed by Dmitry Eremin-Solenikov;
libcrypto bits only for now.

This is a verbatim import of Dmitry's work, and does not compile in this
state; the forthcoming commits will address these issues.

None of the GOST code is enabled in libcrypto yet, for it still gets
compiled with OPENSSL_NO_GOST defined. However, the public header gost.h
will be installed.
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.39 2014/07/11 15:28:27 tedu Exp $ */
a703 4
#if 0
const EVP_CIPHER *EVP_des_ede_cfb1(void);
const EVP_CIPHER *EVP_des_ede_cfb8(void);
#endif
@


1.39
log
@OPENSSL_ALGORITHM_DEFINES has been removed from conf.h, no need for it now
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.38 2014/06/24 19:31:50 miod Exp $ */
d110 2
d114 2
d144 3
d223 2
d393 2
d465 5
d549 1
d685 6
d830 6
d903 3
d1372 1
@


1.38
log
@Remove BIO_f_reliable(), guilty of playing with EVP_MD_CTX internals it
should not know anything about. Verified not to be used in ports; riding upon
the recent libcrypto major bump.
@
text
@d1 1
a1 1
/* $OpenBSD: evp.h,v 1.37 2014/06/12 15:49:29 deraadt Exp $ */
d62 1
a62 7
#ifdef OPENSSL_ALGORITHM_DEFINES
# include <openssl/opensslconf.h>
#else
# define OPENSSL_ALGORITHM_DEFINES
# include <openssl/opensslconf.h>
# undef OPENSSL_ALGORITHM_DEFINES
#endif
@


1.37
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a638 1
BIO_METHOD *BIO_f_reliable(void);
@


1.36
log
@remove CONST_STRICT. ok beck deraadt
@
text
@d1 1
a1 1
/* crypto/evp/evp.h */
@


1.35
log
@Implement an improved version of the EVP AEAD API. The
EVP_AEAD_CTX_{open,seal} functions previously returned an ssize_t that was
overloaded to indicate success/failure, along with the number of bytes
written as output. This change adds an explicit *out_len argument which
is used to return the number of output bytes and the return value is now
an int that is purely used to identify success or failure.

This change effectively rides the last libcrypto crank (although I do not
expect there to be many users of the EVP AEAD API currently).

Thanks to Adam Langley for providing the improved code that this diff is
based on.

ok miod@@
@
text
@d513 1
a513 5
#ifdef CONST_STRICT
void BIO_set_md(BIO *, const EVP_MD *md);
#else
# define BIO_set_md(b,md)		BIO_ctrl(b,BIO_C_SET_MD,0,(char *)md)
#endif
@


1.34
log
@no no md2
@
text
@d1261 2
a1262 2
 * any additional data (AD). The result is written as output, with the number
 * of bytes written being returned, or -1 on error.
d1269 2
a1270 1
 * EVP_AEAD_overhead.
d1276 1
a1276 1
 * insufficient, -1 will be returned.
d1279 4
a1282 4
ssize_t EVP_AEAD_CTX_seal(const EVP_AEAD_CTX *ctx, unsigned char *out,
    size_t max_out_len, const unsigned char *nonce, size_t nonce_len,
    const unsigned char *in, size_t in_len, const unsigned char *ad,
    size_t ad_len);
d1285 2
a1286 2
 * the input and writing it as output. The number of bytes decrypted and
 * written as output is returned, or -1 on error.
d1292 2
a1293 1
 * success, max_out_len should be at least the same as the input length.
d1299 1
a1299 1
 * insufficient, -1 will be returned.
d1302 4
a1305 4
ssize_t EVP_AEAD_CTX_open(const EVP_AEAD_CTX *ctx, unsigned char *out,
    size_t max_out_len, const unsigned char *nonce, size_t nonce_len,
    const unsigned char *in, size_t in_len, const unsigned char *ad,
    size_t ad_len);
@


1.33
log
@no no seed
@
text
@a648 3
#ifndef OPENSSL_NO_MD2
const EVP_MD *EVP_md2(void);
#endif
@


1.32
log
@When OPENSSL_LOAD_CONF was added it ended up with more #if 0 code,
more #ifdefs and a new source file that contains a single function.

Nuke the #if 0 code that is now a macro and move the single function in
evp_acnf.c to c_all.c, which is where the other code lives. While here,
tidy evp.h slightly, remove an unnecessary #ifdef __OpenBSD__ and nuke
a comment that is now a lie.

ok miod@@
@
text
@a816 8
#ifndef OPENSSL_NO_SEED
const EVP_CIPHER *EVP_seed_ecb(void);
const EVP_CIPHER *EVP_seed_cbc(void);
const EVP_CIPHER *EVP_seed_cfb128(void);
# define EVP_seed_cfb EVP_seed_cfb128
const EVP_CIPHER *EVP_seed_ofb(void);
#endif

@


1.31
log
@Add a ChaCha20-Poly1305 AEAD EVP implementation to libcrypto, from Adam
Langley's Chromium OpenSSL patches.

ok miod@@
@
text
@d833 1
a833 2
#define OpenSSL_add_all_algorithms() \
		OPENSSL_add_all_algorithms_conf()
d835 1
a835 2
#define OpenSSL_add_all_algorithms() \
		OPENSSL_add_all_algorithms_noconf()
d840 1
@


1.30
log
@Add an AEAD EVP interface to libcrypto, along with AES-GCM AEAD
implementations. This largely pulls in Adam Langley's AEAD patches from
Chromium's OpenSSL.

ok miod@@
@
text
@d1225 5
d1331 3
@


1.29
log
@KNF.
@
text
@d1208 104
d1323 5
d1342 3
d1460 1
d1465 1
@


1.28
log
@Provide an EVP implementation for ChaCha.

ok miod@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d126 1
a126 2
struct evp_pkey_st
	{
d146 1
a146 1
		} pkey;
d149 1
a149 1
	} /* EVP_PKEY */;
d157 1
a157 2
struct env_md_st
	{
d163 3
a165 3
	int (*update)(EVP_MD_CTX *ctx,const void *data,size_t count);
	int (*final)(EVP_MD_CTX *ctx,unsigned char *md);
	int (*copy)(EVP_MD_CTX *to,const EVP_MD_CTX *from);
d170 1
a170 1
		    unsigned char *sigret, unsigned int *siglen, void *key);
d172 2
a173 2
		      const unsigned char *sigbuf, unsigned int siglen,
		      void *key);
d179 1
a179 1
	} /* EVP_MD */;
d181 6
a186 6
typedef int evp_sign_method(int type,const unsigned char *m,
			    unsigned int m_length,unsigned char *sigret,
			    unsigned int *siglen, void *key);
typedef int evp_verify_method(int type,const unsigned char *m,
			    unsigned int m_length,const unsigned char *sigbuf,
			    unsigned int siglen, void *key);
d242 1
a242 1
#else   
d261 1
a261 2
struct env_md_ctx_st
	{
d269 2
a270 2
	int (*update)(EVP_MD_CTX *ctx,const void *data,size_t count);
	} /* EVP_MD_CTX */;
d298 1
a298 2
struct evp_cipher_st
	{
d305 1
a305 1
		    const unsigned char *iv, int enc);	/* init key */
d307 1
a307 1
			 const unsigned char *in, size_t inl);/* encrypt/decrypt data */
d314 1
a314 1
	} /* EVP_CIPHER */;
d399 1
a399 2
typedef struct evp_cipher_info_st
	{
d402 1
a402 1
	} EVP_CIPHER_INFO;
d404 1
a404 2
struct evp_cipher_ctx_st
	{
d422 1
a422 1
	} /* EVP_CIPHER_CTX */;
d424 1
a424 2
typedef struct evp_Encode_Ctx_st
	{
d434 1
a434 1
	} EVP_ENCODE_CTX;
d438 1
a438 2
		ASN1_TYPE *param, const EVP_CIPHER *cipher,
                const EVP_MD *md, int en_de);
d469 1
a469 1
int EVP_MD_pkey_type(const EVP_MD *md);	
d509 1
a509 1
#define EVP_SealUpdate(a,b,c,d,e)	EVP_EncryptUpdate(a,b,c,d,e)	
d514 1
a514 1
void BIO_set_md(BIO *,const EVP_MD *md);
d524 2
a525 4
int EVP_Cipher(EVP_CIPHER_CTX *c,
		unsigned char *out,
		const unsigned char *in,
		unsigned int inl);
d536 2
a537 2
void	EVP_MD_CTX_init(EVP_MD_CTX *ctx);
int	EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
d539 90
a628 96
void	EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);
int     EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);  
void	EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags);
void	EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags);
int 	EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx,int flags);
int	EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);
int	EVP_DigestUpdate(EVP_MD_CTX *ctx,const void *d,
			 size_t cnt);
int	EVP_DigestFinal_ex(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s);
int	EVP_Digest(const void *data, size_t count,
		unsigned char *md, unsigned int *size, const EVP_MD *type, ENGINE *impl);

int     EVP_MD_CTX_copy(EVP_MD_CTX *out,const EVP_MD_CTX *in);  
int	EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
int	EVP_DigestFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s);

int	EVP_read_pw_string(char *buf,int length,const char *prompt,int verify);
int	EVP_read_pw_string_min(char *buf,int minlen,int maxlen,const char *prompt,int verify);
void	EVP_set_pw_prompt(const char *prompt);
char *	EVP_get_pw_prompt(void);

int	EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,
		const unsigned char *salt, const unsigned char *data,
		int datal, int count, unsigned char *key,unsigned char *iv);

void	EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags);
void	EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags);
int 	EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx,int flags);

int	EVP_EncryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
		const unsigned char *key, const unsigned char *iv);
int	EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
		const unsigned char *key, const unsigned char *iv);
int	EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
		int *outl, const unsigned char *in, int inl);
int	EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
int	EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

int	EVP_DecryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
		const unsigned char *key, const unsigned char *iv);
int	EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
		const unsigned char *key, const unsigned char *iv);
int	EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
		int *outl, const unsigned char *in, int inl);
int	EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
int	EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

int	EVP_CipherInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
		       const unsigned char *key,const unsigned char *iv,
		       int enc);
int	EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
		       const unsigned char *key,const unsigned char *iv,
		       int enc);
int	EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
		int *outl, const unsigned char *in, int inl);
int	EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
int	EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);

int	EVP_SignFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s,
		EVP_PKEY *pkey);

int	EVP_VerifyFinal(EVP_MD_CTX *ctx,const unsigned char *sigbuf,
		unsigned int siglen,EVP_PKEY *pkey);

int	EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
			const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int	EVP_DigestSignFinal(EVP_MD_CTX *ctx,
			unsigned char *sigret, size_t *siglen);

int	EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
			const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int	EVP_DigestVerifyFinal(EVP_MD_CTX *ctx,
			unsigned char *sig, size_t siglen);

int	EVP_OpenInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
		const unsigned char *ek, int ekl, const unsigned char *iv,
		EVP_PKEY *priv);
int	EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

int	EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
		 unsigned char **ek, int *ekl, unsigned char *iv,
		EVP_PKEY **pubk, int npubk);
int	EVP_SealFinal(EVP_CIPHER_CTX *ctx,unsigned char *out,int *outl);

void	EVP_EncodeInit(EVP_ENCODE_CTX *ctx);
void	EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl,
		const unsigned char *in,int inl);
void	EVP_EncodeFinal(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl);
int	EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);

void	EVP_DecodeInit(EVP_ENCODE_CTX *ctx);
int	EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl,
		const unsigned char *in, int inl);
int	EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned
		char *out, int *outl);
int	EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);
d644 2
a645 2
void BIO_set_cipher(BIO *b,const EVP_CIPHER *c,const unsigned char *k,
		const unsigned char *i, int enc);
d853 2
a854 2
void EVP_CIPHER_do_all(void (*fn)(const EVP_CIPHER *ciph,
		const char *from, const char *to, void *x), void *arg);
d856 1
a856 1
		const char *from, const char *to, void *x), void *arg);
d858 18
a875 20
void EVP_MD_do_all(void (*fn)(const EVP_MD *ciph,
		const char *from, const char *to, void *x), void *arg);
void EVP_MD_do_all_sorted(void (*fn)(const EVP_MD *ciph,
		const char *from, const char *to, void *x), void *arg);

int		EVP_PKEY_decrypt_old(unsigned char *dec_key,
			const unsigned char *enc_key,int enc_key_len,
			EVP_PKEY *private_key);
int		EVP_PKEY_encrypt_old(unsigned char *enc_key,
			const unsigned char *key,int key_len,
			EVP_PKEY *pub_key);
int		EVP_PKEY_type(int type);
int		EVP_PKEY_id(const EVP_PKEY *pkey);
int		EVP_PKEY_base_id(const EVP_PKEY *pkey);
int		EVP_PKEY_bits(EVP_PKEY *pkey);
int		EVP_PKEY_size(EVP_PKEY *pkey);
int 		EVP_PKEY_set_type(EVP_PKEY *pkey,int type);
int		EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len);
int 		EVP_PKEY_assign(EVP_PKEY *pkey,int type,void *key);
void *		EVP_PKEY_get0(EVP_PKEY *pkey);
d879 1
a879 1
int EVP_PKEY_set1_RSA(EVP_PKEY *pkey,struct rsa_st *key);
d884 1
a884 1
int EVP_PKEY_set1_DSA(EVP_PKEY *pkey,struct dsa_st *key);
d889 1
a889 1
int EVP_PKEY_set1_DH(EVP_PKEY *pkey,struct dh_st *key);
d894 1
a894 1
int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,struct ec_key_st *key);
d898 2
a899 2
EVP_PKEY *	EVP_PKEY_new(void);
void		EVP_PKEY_free(EVP_PKEY *pkey);
d901 9
a909 9
EVP_PKEY *	d2i_PublicKey(int type,EVP_PKEY **a, const unsigned char **pp,
			long length);
int		i2d_PublicKey(EVP_PKEY *a, unsigned char **pp);

EVP_PKEY *	d2i_PrivateKey(int type,EVP_PKEY **a, const unsigned char **pp,
			long length);
EVP_PKEY *	d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
			long length);
int		i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp);
d913 1
a913 1
int EVP_PKEY_save_parameters(EVP_PKEY *pkey,int mode);
d918 6
a923 6
int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx);
int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx);
int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx);
d934 2
a935 2
int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c,ASN1_TYPE *type);
int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c,ASN1_TYPE *type);
d939 1
a939 2
			 ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,
			 int en_de);
d941 5
a945 6
			   const unsigned char *salt, int saltlen, int iter,
			   int keylen, unsigned char *out);
int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
			   const unsigned char *salt, int saltlen, int iter,
			   const EVP_MD *digest,
		      int keylen, unsigned char *out);
d947 2
a948 2
			 ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,
			 int en_de);
d953 1
a953 1
	     ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de);
d963 1
a963 1
	     EVP_PBE_KEYGEN *keygen);
d965 3
a967 3
		    EVP_PBE_KEYGEN *keygen);
int EVP_PBE_find(int type, int pbe_nid,
			int *pcnid, int *pmnid, EVP_PBE_KEYGEN **pkeygen);
d984 1
a984 1
					const char *str, int len);
d988 2
a989 2
				const char **pinfo, const char **ppem_str,
					const EVP_PKEY_ASN1_METHOD *ameth);
d992 4
a995 4
EVP_PKEY_ASN1_METHOD* EVP_PKEY_asn1_new(int id, int flags,
					const char *pem_str, const char *info);
void EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst, 
			const EVP_PKEY_ASN1_METHOD *src);
d998 7
a1004 7
		int (*pub_decode)(EVP_PKEY *pk, X509_PUBKEY *pub),
		int (*pub_encode)(X509_PUBKEY *pub, const EVP_PKEY *pk),
		int (*pub_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
		int (*pub_print)(BIO *out, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *pctx),
		int (*pkey_size)(const EVP_PKEY *pk),
		int (*pkey_bits)(const EVP_PKEY *pk));
d1006 4
a1009 4
		int (*priv_decode)(EVP_PKEY *pk, PKCS8_PRIV_KEY_INFO *p8inf),
		int (*priv_encode)(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pk),
		int (*priv_print)(BIO *out, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *pctx));
d1011 7
a1017 8
		int (*param_decode)(EVP_PKEY *pkey,
				const unsigned char **pder, int derlen),
		int (*param_encode)(const EVP_PKEY *pkey, unsigned char **pder),
		int (*param_missing)(const EVP_PKEY *pk),
		int (*param_copy)(EVP_PKEY *to, const EVP_PKEY *from),
		int (*param_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
		int (*param_print)(BIO *out, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *pctx));
d1020 1
a1020 1
		void (*pkey_free)(EVP_PKEY *pkey));
d1022 1
a1022 3
		int (*pkey_ctrl)(EVP_PKEY *pkey, int op,
							long arg1, void *arg2));

d1086 1
a1086 1
				const EVP_PKEY_METHOD *meth);
d1096 2
a1097 2
int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
				int cmd, int p1, void *p2);
d1099 1
a1099 1
						const char *value);
d1104 2
a1105 2
EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,
				const unsigned char *key, int keylen);
d1117 2
a1118 3
int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
			unsigned char *sig, size_t *siglen,
			const unsigned char *tbs, size_t tbslen);
d1120 2
a1121 3
int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
			const unsigned char *sig, size_t siglen,
			const unsigned char *tbs, size_t tbslen);
d1123 2
a1124 3
int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
			unsigned char *rout, size_t *routlen,
			const unsigned char *sig, size_t siglen);
d1126 2
a1127 3
int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,
			unsigned char *out, size_t *outlen,
			const unsigned char *in, size_t inlen);
d1129 2
a1130 3
int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,
			unsigned char *out, size_t *outlen,
			const unsigned char *in, size_t inlen);
d1149 1
a1149 1
	int (*init)(EVP_PKEY_CTX *ctx));
d1152 1
a1152 1
	int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src));
d1155 1
a1155 1
	void (*cleanup)(EVP_PKEY_CTX *ctx));
d1158 2
a1159 2
	int (*paramgen_init)(EVP_PKEY_CTX *ctx),
	int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));
d1162 2
a1163 2
	int (*keygen_init)(EVP_PKEY_CTX *ctx),
	int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));
d1166 3
a1168 3
	int (*sign_init)(EVP_PKEY_CTX *ctx),
	int (*sign)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
					const unsigned char *tbs, size_t tbslen));
d1171 3
a1173 3
	int (*verify_init)(EVP_PKEY_CTX *ctx),
	int (*verify)(EVP_PKEY_CTX *ctx, const unsigned char *sig, size_t siglen,
					const unsigned char *tbs, size_t tbslen));
d1176 3
a1178 4
	int (*verify_recover_init)(EVP_PKEY_CTX *ctx),
	int (*verify_recover)(EVP_PKEY_CTX *ctx,
					unsigned char *sig, size_t *siglen,
					const unsigned char *tbs, size_t tbslen));
d1181 3
a1183 3
	int (*signctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
	int (*signctx)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
					EVP_MD_CTX *mctx));
d1186 3
a1188 3
	int (*verifyctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
	int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig,int siglen,
					EVP_MD_CTX *mctx));
d1191 3
a1193 3
	int (*encrypt_init)(EVP_PKEY_CTX *ctx),
	int (*encryptfn)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
					const unsigned char *in, size_t inlen));
d1196 3
a1198 3
	int (*decrypt_init)(EVP_PKEY_CTX *ctx),
	int (*decrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
					const unsigned char *in, size_t inlen));
d1201 2
a1202 2
	int (*derive_init)(EVP_PKEY_CTX *ctx),
	int (*derive)(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen));
d1205 2
a1206 3
	int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2),
	int (*ctrl_str)(EVP_PKEY_CTX *ctx,
					const char *type, const char *value));
@


1.27
log
@unifdef -U OPENBSD_DEV_CRYPTO and OPENSSL_OPENBSD_DEV_CRYPTO. This code was the
early attempt at getting kernel-assisted crypto(4) used by libcrypto, before
the engine API existed, and has been #if 0'd out for ages anyway.
No API/ABI change.
@
text
@d841 4
@


1.26
log
@Cope with the removal of openssl/symhacks.h
@
text
@a725 9
/* This should now be supported through the dev_crypto ENGINE. But also, why are
 * rc4 and md5 declarations made here inside a "NO_DES" precompiler branch? */
#if 0
# ifdef OPENSSL_OPENBSD_DEV_CRYPTO
const EVP_CIPHER *EVP_dev_crypto_des_ede3_cbc(void);
const EVP_CIPHER *EVP_dev_crypto_rc4(void);
const EVP_MD *EVP_dev_crypto_md5(void);
# endif
#endif
@


1.25
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a71 2
#include <openssl/symhacks.h>

@


1.24
log
@remove ACSS, crank libcrypto major; ok markus@@ deraadt@@
@
text
@d791 1
a792 1
const EVP_CIPHER *EVP_aes_128_ccm(void);
d802 1
a803 1
const EVP_CIPHER *EVP_aes_192_ccm(void);
d812 1
a813 1
const EVP_CIPHER *EVP_aes_256_ccm(void);
d1245 2
d1261 1
d1355 2
d1363 1
d1367 1
d1392 1
@


1.23
log
@resolve conflicts
@
text
@a396 3
/* OpenBSD extension */
#define		EVP_CTRL_SET_ACSS_MODE		0x80

a818 3
#endif
#ifndef OPENSSL_NO_ACSS
const EVP_CIPHER *EVP_acss(void);
@


1.22
log
@resolve conflicts, fix local changes
@
text
@d86 1
a86 1
#define EVP_MAX_KEY_LENGTH		32
d119 1
d220 2
d331 4
d356 9
d377 30
a406 1
#define		EVP_CTRL_SET_ACSS_MODE		0x9
d424 1
a424 1
	int num;				/* used by cfb/ofb mode */
d744 3
a792 1
#if 0
d794 3
a796 1
#endif
a803 1
#if 0
d805 2
a806 1
#endif
a813 1
#if 0
d815 6
d1108 2
d1114 4
d1121 3
d1141 1
a1141 1
				unsigned char *key, int keylen);
d1260 2
a1261 1
#define	EVP_F_AESNI_INIT_KEY				 165
d1263 2
d1266 1
d1321 7
d1331 1
d1338 1
d1356 1
d1388 1
@


1.21
log
@AES-NI engine support for OpenSSL.
This is code mostly picked up from upstream OpenSSL, or to be more exact
a diff from David Woodhouse <dwmw2 at infradead dot org>.

Remember to make includes before doing a build!

no objections from djm@@
OK deraadt@@, reyk@@ (AES is about 4.25x faster on his x201 now)
@
text
@a77 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

d118 1
d132 2
a157 67
#if 0
/* This structure is required to tie the message digest and signing together.
 * The lookup can be done by md/pkey_method, oid, oid/pkey_method, or
 * oid, md and pkey.
 * This is required because for various smart-card perform the digest and
 * signing/verification on-board.  To handle this case, the specific
 * EVP_MD and EVP_PKEY_METHODs need to be closely associated.
 * When a PKEY is created, it will have a EVP_PKEY_METHOD associated with it.
 * This can either be software or a token to provide the required low level
 * routines.
 */
typedef struct evp_pkey_md_st
	{
	int oid;
	EVP_MD *md;
	EVP_PKEY_METHOD *pkey;
	} EVP_PKEY_MD;

#define EVP_rsa_md2() \
		EVP_PKEY_MD_add(NID_md2WithRSAEncryption,\
			EVP_rsa_pkcs1(),EVP_md2())
#define EVP_rsa_md5() \
		EVP_PKEY_MD_add(NID_md5WithRSAEncryption,\
			EVP_rsa_pkcs1(),EVP_md5())
#define EVP_rsa_sha0() \
		EVP_PKEY_MD_add(NID_shaWithRSAEncryption,\
			EVP_rsa_pkcs1(),EVP_sha())
#define EVP_rsa_sha1() \
		EVP_PKEY_MD_add(NID_sha1WithRSAEncryption,\
			EVP_rsa_pkcs1(),EVP_sha1())
#define EVP_rsa_ripemd160() \
		EVP_PKEY_MD_add(NID_ripemd160WithRSA,\
			EVP_rsa_pkcs1(),EVP_ripemd160())
#define EVP_rsa_mdc2() \
		EVP_PKEY_MD_add(NID_mdc2WithRSA,\
			EVP_rsa_octet_string(),EVP_mdc2())
#define EVP_dsa_sha() \
		EVP_PKEY_MD_add(NID_dsaWithSHA,\
			EVP_dsa(),EVP_sha())
#define EVP_dsa_sha1() \
		EVP_PKEY_MD_add(NID_dsaWithSHA1,\
			EVP_dsa(),EVP_sha1())

typedef struct evp_pkey_method_st
	{
	char *name;
	int flags;
	int type;		/* RSA, DSA, an SSLeay specific constant */
	int oid;		/* For the pub-key type */
	int encrypt_oid;	/* pub/priv key encryption */

	int (*sign)();
	int (*verify)();
	struct	{
		int (*set)();	/* get and/or set the underlying type */
		int (*get)();
		int (*encrypt)();
		int (*decrypt)();
		int (*i2d)();
		int (*d2i)();
		int (*dup)();
		} pub,priv;
	int (*set_asn1_parameters)();
	int (*get_asn1_parameters)();
	} EVP_PKEY_METHOD;
#endif

d180 2
a190 6
typedef struct
	{
	EVP_MD_CTX *mctx;
	void *key;
	} EVP_MD_SVCTX;

d194 26
a219 1
#define EVP_MD_FLAG_FIPS	0x0400 /* Note if suitable for use in FIPS mode */
d221 6
a226 1
#define EVP_MD_FLAG_SVCTX	0x0800 /* pass EVP_MD_SVCTX to sign/verify */
d268 4
d282 4
d289 4
d297 2
a298 4
#define M_EVP_MD_CTX_FLAG_PSS_SALT(ctx) \
		((ctx->flags>>16) &0xFFFF) /* seed length */
#define EVP_MD_CTX_FLAG_PSS_MDLEN	0xFFFF	/* salt len same as digest */
#define EVP_MD_CTX_FLAG_PSS_MREC	0xFFFE	/* salt max or auto recovered */
d310 1
a310 1
			 const unsigned char *in, unsigned int inl);/* encrypt/decrypt data */
d328 1
a328 1
#define 	EVP_CIPH_MODE			0x7
d343 2
a344 4
/* Note if suitable for use in FIPS mode */
#define		EVP_CIPH_FLAG_FIPS		0x400
/* Allow non FIPS cipher in FIPS mode */
#define		EVP_CIPH_FLAG_NON_FIPS_ALLOW	0x800
d358 4
a361 2
#define		EVP_CTRL_SET_ACSS_MODE		0x6
#define 	EVP_CTRL_RAND_KEY		0x7
a433 12
/* Macros to reduce FIPS dependencies: do NOT use in applications */
#define M_EVP_MD_size(e)		((e)->md_size)
#define M_EVP_MD_block_size(e)		((e)->block_size)
#define M_EVP_MD_CTX_set_flags(ctx,flgs) ((ctx)->flags|=(flgs))
#define M_EVP_MD_CTX_clear_flags(ctx,flgs) ((ctx)->flags&=~(flgs))
#define M_EVP_MD_CTX_test_flags(ctx,flgs) ((ctx)->flags&(flgs))
#define M_EVP_MD_type(e)			((e)->type)
#define M_EVP_MD_CTX_type(e)		M_EVP_MD_type(M_EVP_MD_CTX_md(e))
#define M_EVP_MD_CTX_md(e)			((e)->digest)

#define M_EVP_CIPHER_CTX_set_flags(ctx,flgs) ((ctx)->flags|=(flgs))

d440 1
d442 1
a442 1
const EVP_MD * EVP_MD_CTX_md(const EVP_MD_CTX *ctx);
d460 1
d478 2
d526 1
d573 10
d655 3
d828 11
a838 1
int		EVP_PKEY_decrypt(unsigned char *dec_key,
d841 1
a841 1
int		EVP_PKEY_encrypt(unsigned char *enc_key,
d845 2
d849 4
a852 1
int 		EVP_PKEY_assign(EVP_PKEY *pkey,int type,char *key);
d895 9
d921 4
d933 10
d945 2
d949 238
a1186 17
#ifdef OPENSSL_FIPS
#ifndef OPENSSL_NO_ENGINE
void int_EVP_MD_set_engine_callbacks(
	int (*eng_md_init)(ENGINE *impl),
	int (*eng_md_fin)(ENGINE *impl),
	int (*eng_md_evp)
		(EVP_MD_CTX *ctx, const EVP_MD **ptype, ENGINE *impl));
void int_EVP_MD_init_engine_callbacks(void);
void int_EVP_CIPHER_set_engine_callbacks(
	int (*eng_ciph_fin)(ENGINE *impl),
	int (*eng_ciph_evp)
		(EVP_CIPHER_CTX *ctx, const EVP_CIPHER **pciph, ENGINE *impl));
void int_EVP_CIPHER_init_engine_callbacks(void);
#endif
#endif

void EVP_add_alg_module(void);
a1198 1
#define EVP_F_ALG_MODULE_INIT				 138
d1201 1
a1201 4
#define EVP_F_DO_EVP_ENC_ENGINE				 140
#define EVP_F_DO_EVP_ENC_ENGINE_FULL			 141
#define EVP_F_DO_EVP_MD_ENGINE				 139
#define EVP_F_DO_EVP_MD_ENGINE_FULL			 142
a1205 1
#define EVP_F_EVP_CIPHERINIT				 137
d1207 1
a1210 1
#define EVP_F_EVP_DIGESTINIT				 136
d1214 1
d1217 1
d1220 1
d1223 3
d1227 5
d1233 2
d1240 2
d1243 8
d1254 1
d1258 1
d1270 1
d1273 1
d1279 1
a1279 1
#define EVP_R_DISABLED_FOR_FIPS				 144
a1280 2
#define EVP_R_ERROR_LOADING_SECTION			 145
#define EVP_R_ERROR_SETTING_FIPS_MODE			 146
a1286 1
#define EVP_R_FIPS_MODE_NOT_SUPPORTED			 147
d1289 1
a1289 1
#define EVP_R_INVALID_FIPS_MODE				 148
d1291 1
d1294 2
d1298 1
d1301 2
d1305 2
d1308 2
d1311 2
a1312 1
#define EVP_R_UNKNOWN_OPTION				 149
d1315 1
a1324 1
#define EVP_R_SEED_KEY_SETUP_FAILED			 162
@


1.20
log
@resolve conflicts
@
text
@d962 1
@


1.19
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d78 4
d257 6
d266 4
d323 9
d375 8
d466 12
d573 4
d935 18
d963 1
d966 4
d974 1
d979 1
d1021 1
d1023 2
d1031 1
d1034 1
d1046 1
@


1.18
log
@resolve conflicts
@
text
@d306 2
@


1.17
log
@resolve conflicts
@
text
@a77 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

d85 1
a85 1
#define EVP_MAX_MD_SIZE			64	/* longest known SHA512 */
d99 1
d105 1
d117 1
d142 3
d230 1
a230 1
	int (*update)(EVP_MD_CTX *ctx,const void *data,unsigned long count);
d236 5
a240 2
	int (*sign)();
	int (*verify)();
d246 7
a254 1
#define EVP_MD_FLAG_FIPS	0x0400 /* Note if suitable for use in FIPS mode */
d259 2
a260 1
#define EVP_PKEY_DSA_method	DSA_sign,DSA_verify, \
d267 8
d276 2
a277 1
#define EVP_PKEY_RSA_method	RSA_sign,RSA_verify, \
d280 2
a281 2
				RSA_sign_ASN1_OCTET_STRING, \
				RSA_verify_ASN1_OCTET_STRING, \
a306 3
#define EVP_MD_CTX_FLAG_NON_FIPS_ALLOW	0x0008	/* Allow use of non FIPS digest
						 * in FIPS mode */

d348 2
a349 4
/* Note if suitable for use in FIPS mode */
#define		EVP_CIPH_FLAG_FIPS		0x400
/* Allow non FIPS cipher in FIPS mode */
#define		EVP_CIPH_FLAG_NON_FIPS_ALLOW	0x800
d360 1
d422 5
d433 1
a433 1
#define EVP_MD_type(e)			((e)->type)
d436 8
a443 8
#define EVP_MD_pkey_type(e)		((e)->pkey_type)
#define EVP_MD_size(e)			((e)->md_size)
#define EVP_MD_block_size(e)		((e)->block_size)

#define EVP_MD_CTX_md(e)		((e)->digest)
#define EVP_MD_CTX_size(e)		EVP_MD_size((e)->digest)
#define EVP_MD_CTX_block_size(e)	EVP_MD_block_size((e)->digest)
#define EVP_MD_CTX_type(e)		EVP_MD_type((e)->digest)
d445 1
a445 1
#define EVP_CIPHER_nid(e)		((e)->nid)
d447 13
a459 13
#define EVP_CIPHER_block_size(e)	((e)->block_size)
#define EVP_CIPHER_key_length(e)	((e)->key_len)
#define EVP_CIPHER_iv_length(e)		((e)->iv_len)
#define EVP_CIPHER_flags(e)		((e)->flags)
#define EVP_CIPHER_mode(e)		(((e)->flags) & EVP_CIPH_MODE)

#define EVP_CIPHER_CTX_cipher(e)	((e)->cipher)
#define EVP_CIPHER_CTX_nid(e)		((e)->cipher->nid)
#define EVP_CIPHER_CTX_block_size(e)	((e)->cipher->block_size)
#define EVP_CIPHER_CTX_key_length(e)	((e)->key_len)
#define EVP_CIPHER_CTX_iv_length(e)	((e)->cipher->iv_len)
#define EVP_CIPHER_CTX_get_app_data(e)	((e)->app_data)
#define EVP_CIPHER_CTX_set_app_data(e,d) ((e)->app_data=(char *)(d))
d461 2
a462 5
#define EVP_CIPHER_CTX_flags(e)		((e)->cipher->flags)
#define EVP_CIPHER_CTX_set_flags(ctx,flgs) ((ctx)->flags|=(flgs))
#define EVP_CIPHER_CTX_clear_flags(ctx,flgs) ((ctx)->flags&=~(flgs))
#define EVP_CIPHER_CTX_test_flags(ctx,flgs) ((ctx)->flags&(flgs))
#define EVP_CIPHER_CTX_mode(e)		((e)->cipher->flags & EVP_CIPH_MODE)
d487 4
a490 1
#define	EVP_Cipher(c,o,i,l)	(c)->cipher->do_cipher((c),(o),(i),(l))
d506 3
a508 3
#define EVP_MD_CTX_set_flags(ctx,flgs) ((ctx)->flags|=(flgs))
#define EVP_MD_CTX_clear_flags(ctx,flgs) ((ctx)->flags&=~(flgs))
#define EVP_MD_CTX_test_flags(ctx,flgs) ((ctx)->flags&(flgs))
d511 1
a511 1
			 unsigned int cnt);
d513 1
a513 1
int	EVP_Digest(void *data, unsigned int count,
d521 1
a521 1
void	EVP_set_pw_prompt(char *prompt);
d560 1
a560 1
int	EVP_VerifyFinal(EVP_MD_CTX *ctx,unsigned char *sigbuf,
d563 3
a565 2
int	EVP_OpenInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,unsigned char *ek,
		int ekl,unsigned char *iv,EVP_PKEY *priv);
d568 3
a570 2
int	EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, unsigned char **ek,
		int *ekl, unsigned char *iv,EVP_PKEY **pubk, int npubk);
d574 2
a575 2
void	EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx,unsigned char *out,
		int *outl,unsigned char *in,int inl);
d581 1
a581 1
		unsigned char *in, int inl);
d588 2
d593 1
d600 2
a601 2
void BIO_set_cipher(BIO *b,const EVP_CIPHER *c,unsigned char *k,
	unsigned char *i, int enc);
d619 2
a620 1
#ifdef OPENSSL_FIPS
a628 2
#endif
#endif
d749 31
d805 3
a807 2
int		EVP_PKEY_decrypt(unsigned char *dec_key,unsigned char *enc_key,
			int enc_key_len,EVP_PKEY *private_key);
d809 2
a810 1
			unsigned char *key,int key_len,EVP_PKEY *pub_key);
d831 5
a835 1

d839 2
a840 1
EVP_PKEY *	d2i_PublicKey(int type,EVP_PKEY **a, unsigned char **pp,
d844 1
a844 1
EVP_PKEY *	d2i_PrivateKey(int type,EVP_PKEY **a, unsigned char **pp,
d846 1
a846 1
EVP_PKEY *	d2i_AutoPrivateKey(EVP_PKEY **a, unsigned char **pp,
d850 2
a851 2
int EVP_PKEY_copy_parameters(EVP_PKEY *to,EVP_PKEY *from);
int EVP_PKEY_missing_parameters(EVP_PKEY *pkey);
d853 3
a855 1
int EVP_PKEY_cmp_parameters(EVP_PKEY *a,EVP_PKEY *b);
d872 1
a872 1
			   unsigned char *salt, int saltlen, int iter,
d895 2
a896 1
#define EVP_F_AES_INIT_KEY				 129
d898 5
a902 3
#define EVP_F_EVP_ADD_CIPHER				 130
#define EVP_F_EVP_ADD_DIGEST				 131
#define EVP_F_EVP_CIPHERINIT				 123
d905 4
a908 6
#define EVP_F_EVP_DECRYPTFINAL				 101
#define EVP_F_EVP_DIGESTINIT				 128
#define EVP_F_EVP_ENCRYPTFINAL				 127
#define EVP_F_EVP_GET_CIPHERBYNAME			 132
#define EVP_F_EVP_GET_DIGESTBYNAME			 133
#define EVP_F_EVP_MD_CTX_COPY				 110
d913 1
a913 2
#define EVP_F_EVP_PKCS8_SET_BROKEN			 112
#define EVP_F_EVP_PKEY2PKCS8				 113
d919 2
d928 1
d933 2
a934 1
#define EVP_R_AES_KEY_SETUP_FAILED			 140
d940 1
a946 1
#define EVP_R_DISABLED_FOR_FIPS				 141
d952 2
d978 1
@


1.16
log
@increase EVP_MAX_MD_SIZE to something sane (big enough for SHA512)
@
text
@d89 1
a89 1
#define EVP_MAX_MD_SIZE			64 /* to fit SHA512 */
d592 10
@


1.15
log
@resolve conflicts
@
text
@d89 1
a89 1
#define EVP_MAX_MD_SIZE			(16+20) /* The SSLv3 md5+sha1 type */
@


1.14
log
@merge 0.9.7d
@
text
@d78 4
d243 1
d286 3
d330 4
d440 3
d464 1
d606 14
a619 3
const EVP_CIPHER *EVP_des_cfb(void);
const EVP_CIPHER *EVP_des_ede_cfb(void);
const EVP_CIPHER *EVP_des_ede3_cfb(void);
d643 2
a644 1
const EVP_CIPHER *EVP_idea_cfb(void);
d653 2
a654 1
const EVP_CIPHER *EVP_rc2_cfb(void);
d660 2
a661 1
const EVP_CIPHER *EVP_bf_cfb(void);
d667 2
a668 1
const EVP_CIPHER *EVP_cast5_cfb(void);
d674 2
a675 1
const EVP_CIPHER *EVP_rc5_32_12_16_cfb(void);
d681 4
a684 1
const EVP_CIPHER *EVP_aes_128_cfb(void);
d691 4
a694 1
const EVP_CIPHER *EVP_aes_192_cfb(void);
d701 4
a704 1
const EVP_CIPHER *EVP_aes_256_cfb(void);
d819 1
d821 2
d829 2
d854 1
d866 1
@


1.13
log
@enable acss.
ok @@deraadt @@markus

Also bump minor version.
ok @@deraadt
@
text
@d278 2
@


1.12
log
@evp.h should not pull in all other header files, especially
since it's supposed to hid the specific ciphers.
this change also avoids problems when evp is used together
with kerberos (and <des.h>).
ok deraadt@@
@
text
@d329 1
d666 3
@


1.11
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@a76 45
#ifndef OPENSSL_NO_MD2
#include <openssl/md2.h>
#endif
#ifndef OPENSSL_NO_MD4
#include <openssl/md4.h>
#endif
#ifndef OPENSSL_NO_MD5
#include <openssl/md5.h>
#endif
#ifndef OPENSSL_NO_SHA
#include <openssl/sha.h>
#endif
#ifndef OPENSSL_NO_RIPEMD
#include <openssl/ripemd.h>
#endif
#ifndef OPENSSL_NO_DES
#include <openssl/des.h>
#endif
#ifndef OPENSSL_NO_RC4
#include <openssl/rc4.h>
#endif
#ifndef OPENSSL_NO_RC2
#include <openssl/rc2.h>
#endif
#ifndef OPENSSL_NO_RC5
#include <openssl/rc5.h>
#endif
#ifndef OPENSSL_NO_BF
#include <openssl/blowfish.h>
#endif
#ifndef OPENSSL_NO_CAST
#include <openssl/cast.h>
#endif
#ifndef OPENSSL_NO_IDEA
#include <openssl/idea.h>
#endif
#if 0
/* mdc2 uses the new DES_ API, but DES_ is not defined if kerberos is used, too */
#ifndef OPENSSL_NO_MDC2
#include <openssl/mdc2.h>
#endif
#endif
#ifndef OPENSSL_NO_AES
#include <openssl/aes.h>
#endif
a92 12

#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif

#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif

#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
@


1.10
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d77 45
d139 12
d642 2
@


1.9
log
@Merge openssl-0.9.7-stable-SNAP-20020519
@
text
@d644 5
d651 5
d658 5
@


1.8
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d187 1
a187 1
			EVP_dsa(),EVP_mdc2())
d528 1
a528 1
void	EVP_SealFinal(EVP_CIPHER_CTX *ctx,unsigned char *out,int *outl);
@


1.7
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d70 5
a74 1
#ifndef NO_BIO
a76 39
#ifndef NO_MD2
#include <openssl/md2.h>
#endif
#ifndef NO_MD4
#include <openssl/md4.h>
#endif
#ifndef NO_MD5
#include <openssl/md5.h>
#endif
#ifndef NO_SHA
#include <openssl/sha.h>
#endif
#ifndef NO_RIPEMD
#include <openssl/ripemd.h>
#endif
#ifndef NO_DES
#include <openssl/des.h>
#endif
#ifndef NO_RC4
#include <openssl/rc4.h>
#endif
#ifndef NO_RC2
#include <openssl/rc2.h>
#endif
#ifndef NO_RC5
#include <openssl/rc5.h>
#endif
#ifndef NO_BF
#include <openssl/blowfish.h>
#endif
#ifndef NO_CAST
#include <openssl/cast.h>
#endif
#ifndef NO_IDEA
#include <openssl/idea.h>
#endif
#ifndef NO_MDC2
#include <openssl/mdc2.h>
#endif
d78 1
d84 1
d86 3
a88 2
#define EVP_MAX_KEY_LENGTH		24
#define EVP_MAX_IV_LENGTH		8
a93 12
#ifndef NO_RSA
#include <openssl/rsa.h>
#endif

#ifndef NO_DSA
#include <openssl/dsa.h>
#endif

#ifndef NO_DH
#include <openssl/dh.h>
#endif

d123 1
a123 1
typedef struct evp_pkey_st
d130 1
a130 1
#ifndef NO_RSA
d133 1
a133 1
#ifndef NO_DSA
d136 1
a136 1
#ifndef NO_DH
d142 1
a142 1
	} EVP_PKEY;
d217 1
a217 1
typedef struct env_md_st
d222 6
a227 3
	void (*init)();
	void (*update)();
	void (*final)();
d229 1
d234 2
a235 3
	int ctx_size; /* how big does the ctx need to be */
	} EVP_MD;

d237 2
d242 1
a242 1
#ifndef NO_DSA
d250 1
a250 1
#ifndef NO_RSA
d264 1
a264 1
typedef struct env_md_ctx_st
d267 11
a277 25
	union	{
		unsigned char base[4];
#ifndef NO_MD2
		MD2_CTX md2;
#endif
#ifndef NO_MD5
		MD5_CTX md5;
#endif
#ifndef NO_MD4
		MD4_CTX md4;
#endif
#ifndef NO_RIPEMD
		RIPEMD160_CTX ripemd160;
#endif
#ifndef NO_SHA
		SHA_CTX sha;
#endif
#ifndef NO_MDC2
		MDC2_CTX mdc2;
#endif
		} md;
	} EVP_MD_CTX;

typedef struct evp_cipher_st EVP_CIPHER;
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
d291 1
a291 1
	int ctx_size;		/* how big the ctx needs to be */
d296 1
a296 1
	};
d318 2
d339 1
d345 1
a345 1
	unsigned char buf[EVP_MAX_IV_LENGTH];	/* saved partial block */
d350 6
a355 46
	union	{
#ifndef NO_RC4
		struct
			{
			unsigned char key[EVP_RC4_KEY_SIZE];
			RC4_KEY ks;	/* working key */
			} rc4;
#endif
#ifndef NO_DES
		des_key_schedule des_ks;/* key schedule */
		struct
			{
			des_key_schedule ks;/* key schedule */
			des_cblock inw;
			des_cblock outw;
			} desx_cbc;
		struct
			{
			des_key_schedule ks1;/* key schedule */
			des_key_schedule ks2;/* key schedule (for ede) */
			des_key_schedule ks3;/* key schedule (for ede3) */
			} des_ede;
#endif
#ifndef NO_IDEA
		IDEA_KEY_SCHEDULE idea_ks;/* key schedule */
#endif
#ifndef NO_RC2
		struct {
			int key_bits;	/* effective key bits */
			RC2_KEY ks;/* key schedule */
		} rc2;
#endif
#ifndef NO_RC5
		struct {
			int rounds;	/* number of rounds */
			RC5_32_KEY ks;/* key schedule */
		} rc5;
#endif
#ifndef NO_BF
		BF_KEY bf_ks;/* key schedule */
#endif
#ifndef NO_CAST
		CAST_KEY cast_ks;/* key schedule */
#endif
		} c;
	};
d372 2
a373 2
		ASN1_TYPE *param, EVP_CIPHER *cipher,
                EVP_MD *md, int en_de);
d375 1
a375 1
#ifndef NO_RSA
d380 1
a380 1
#ifndef NO_DSA
d385 1
a385 1
#ifndef NO_DH
d397 2
d409 1
d414 1
a414 1
#define EVP_CIPHER_mode(e)		((e)->flags) & EVP_CIPH_MODE)
d430 1
d433 1
d460 10
a469 4

int     EVP_MD_CTX_copy(EVP_MD_CTX *out,EVP_MD_CTX *in);  
void	EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
void	EVP_DigestUpdate(EVP_MD_CTX *ctx,const void *d,
d471 7
a477 1
void	EVP_DigestFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s);
d483 8
a490 6
int     EVP_BytesToKey(const EVP_CIPHER *type, EVP_MD *md,
		const unsigned char *salt, const unsigned char *data, int datal,
       		int count, unsigned char *key, unsigned char *iv);

int	EVP_EncryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
		unsigned char *key, unsigned char *iv);
d492 2
a493 1
		int *outl, unsigned char *in, int inl);
d496 4
a499 2
int	EVP_DecryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
		unsigned char *key, unsigned char *iv);
d501 1
a501 1
		int *outl, unsigned char *in, int inl);
d503 1
d505 6
a510 2
int	EVP_CipherInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
		       unsigned char *key,unsigned char *iv,int enc);
d512 1
a512 1
		int *outl, unsigned char *in, int inl);
d514 1
d522 1
a522 1
int	EVP_OpenInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,unsigned char *ek,
d526 1
a526 1
int	EVP_SealInit(EVP_CIPHER_CTX *ctx, EVP_CIPHER *type, unsigned char **ek,
a542 2
void	ERR_load_EVP_strings(void );

d546 1
d549 1
a549 1
#ifndef NO_BIO
d558 101
a658 73
EVP_MD *EVP_md_null(void);
#ifndef NO_MD2
EVP_MD *EVP_md2(void);
#endif
#ifndef NO_MD4
EVP_MD *EVP_md4(void);
#endif
#ifndef NO_MD5
EVP_MD *EVP_md5(void);
#endif
#ifndef NO_SHA
EVP_MD *EVP_sha(void);
EVP_MD *EVP_sha1(void);
EVP_MD *EVP_dss(void);
EVP_MD *EVP_dss1(void);
#endif
#ifndef NO_MDC2
EVP_MD *EVP_mdc2(void);
#endif
#ifndef NO_RIPEMD
EVP_MD *EVP_ripemd160(void);
#endif
EVP_CIPHER *EVP_enc_null(void);		/* does nothing :-) */
#ifndef NO_DES
EVP_CIPHER *EVP_des_ecb(void);
EVP_CIPHER *EVP_des_ede(void);
EVP_CIPHER *EVP_des_ede3(void);
EVP_CIPHER *EVP_des_cfb(void);
EVP_CIPHER *EVP_des_ede_cfb(void);
EVP_CIPHER *EVP_des_ede3_cfb(void);
EVP_CIPHER *EVP_des_ofb(void);
EVP_CIPHER *EVP_des_ede_ofb(void);
EVP_CIPHER *EVP_des_ede3_ofb(void);
EVP_CIPHER *EVP_des_cbc(void);
EVP_CIPHER *EVP_des_ede_cbc(void);
EVP_CIPHER *EVP_des_ede3_cbc(void);
EVP_CIPHER *EVP_desx_cbc(void);
#endif
#ifndef NO_RC4
EVP_CIPHER *EVP_rc4(void);
EVP_CIPHER *EVP_rc4_40(void);
#endif
#ifndef NO_IDEA
EVP_CIPHER *EVP_idea_ecb(void);
EVP_CIPHER *EVP_idea_cfb(void);
EVP_CIPHER *EVP_idea_ofb(void);
EVP_CIPHER *EVP_idea_cbc(void);
#endif
#ifndef NO_RC2
EVP_CIPHER *EVP_rc2_ecb(void);
EVP_CIPHER *EVP_rc2_cbc(void);
EVP_CIPHER *EVP_rc2_40_cbc(void);
EVP_CIPHER *EVP_rc2_64_cbc(void);
EVP_CIPHER *EVP_rc2_cfb(void);
EVP_CIPHER *EVP_rc2_ofb(void);
#endif
#ifndef NO_BF
EVP_CIPHER *EVP_bf_ecb(void);
EVP_CIPHER *EVP_bf_cbc(void);
EVP_CIPHER *EVP_bf_cfb(void);
EVP_CIPHER *EVP_bf_ofb(void);
#endif
#ifndef NO_CAST
EVP_CIPHER *EVP_cast5_ecb(void);
EVP_CIPHER *EVP_cast5_cbc(void);
EVP_CIPHER *EVP_cast5_cfb(void);
EVP_CIPHER *EVP_cast5_ofb(void);
#endif
#ifndef NO_RC5
EVP_CIPHER *EVP_rc5_32_12_16_cbc(void);
EVP_CIPHER *EVP_rc5_32_12_16_ecb(void);
EVP_CIPHER *EVP_rc5_32_12_16_cfb(void);
EVP_CIPHER *EVP_rc5_32_12_16_ofb(void);
d660 1
a660 1
void OpenSSL_add_all_algorithms(void);
d667 2
a668 2
int EVP_add_cipher(EVP_CIPHER *cipher);
int EVP_add_digest(EVP_MD *digest);
d682 15
a696 11
#ifndef NO_RSA
int 		EVP_PKEY_set1_RSA(EVP_PKEY *pkey,RSA *key);
RSA *		EVP_PKEY_get1_RSA(EVP_PKEY *pkey);
#endif
#ifndef NO_DSA
int 		EVP_PKEY_set1_DSA(EVP_PKEY *pkey,DSA *key);
DSA *		EVP_PKEY_get1_DSA(EVP_PKEY *pkey);
#endif
#ifndef NO_DH
int 		EVP_PKEY_set1_DH(EVP_PKEY *pkey,DH *key);
DH *		EVP_PKEY_get1_DH(EVP_PKEY *pkey);
d698 2
d729 1
a729 1
			 ASN1_TYPE *param, EVP_CIPHER *cipher, EVP_MD *md,
d735 1
a735 1
			 ASN1_TYPE *param, EVP_CIPHER *cipher, EVP_MD *md,
d742 1
a742 1
int EVP_PBE_alg_add(int nid, EVP_CIPHER *cipher, EVP_MD *md,
d750 1
d760 2
d776 1
d785 1
d787 1
d793 1
d808 1
a829 1

@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d556 3
a558 3
int	EVP_BytesToKey(const EVP_CIPHER *type,EVP_MD *md,unsigned char *salt,
		unsigned char *data, int datal, int count,
		unsigned char *key,unsigned char *iv);
@


1.5
log
@typo
@
text
@d465 1
d468 3
d473 3
d478 1
d622 1
d624 2
d627 2
d630 2
d636 2
d639 2
d642 1
a642 1

d644 1
d658 2
d662 2
d668 2
d676 2
d682 2
d688 2
d694 1
a694 1

@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@a246 1
		int
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d62 6
a67 2
#ifdef	__cplusplus
extern "C" {
d70 3
d76 3
d160 4
d185 1
a185 1
	STACK /*X509_ATTRIBUTE*/ *attributes; /* [ 0 ] */
d315 3
d330 4
a333 1
typedef struct evp_cipher_st
d337 1
a337 1
	int key_len;
d339 6
a344 3
	void (*init)();		/* init for encryption */
	void (*do_cipher)();	/* encrypt data */
	void (*cleanup)();	/* used by cipher method */ 
d346 35
a380 5
	/* int set_asn1_parameters(EVP_CIPHER_CTX,ASN1_TYPE *); */
	int (*set_asn1_parameters)(); /* Populate a ASN1_TYPE with parameters */
	/* int get_asn1_parameters(EVP_CIPHER_CTX,ASN1_TYPE *); */
	int (*get_asn1_parameters)(); /* Get parameters from a ASN1_TYPE */
	} EVP_CIPHER;
d388 1
a388 1
typedef struct evp_cipher_ctx_st
d399 2
a400 1
	char *app_data;		/* application stuff */
d428 4
a431 1
		RC2_KEY rc2_ks;/* key schedule */
d434 4
a437 1
		RC5_32_KEY rc5_ks;/* key schedule */
d446 1
a446 1
	} EVP_CIPHER_CTX;
d493 2
d499 1
a499 1
#define EVP_CIPHER_CTX_key_length(e)	((e)->cipher->key_len)
d504 2
d553 1
a553 1
void	EVP_EncryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
d555 1
a555 1
void	EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
d557 1
a557 1
void	EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
d559 1
a559 1
void	EVP_DecryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
d561 1
a561 1
void	EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
d565 1
a565 1
void	EVP_CipherInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
d567 1
a567 1
void	EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
d601 3
a603 1
void EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
d605 1
a605 1
#ifdef HEADER_BIO_H
d616 1
d753 3
d776 1
d783 2
d792 1
d794 1
d798 1
d805 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d152 1
a152 1
 * arbitary encryption.... */
d346 1
a346 1
	char *app_data;		/* aplication stuff */
d424 1
d427 1
a427 1
#define EVP_MD_CTX_type(e)		((e)->digest)
d525 1
a525 1
int	EVP_EncodeBlock(unsigned char *t, unsigned char *f, int n);
d532 1
a532 2
int	EVP_DecodeBlock(unsigned char *t, unsigned
		char *f, int n);
d597 6
a602 3
void SSLeay_add_all_algorithms(void);
void SSLeay_add_all_ciphers(void);
void SSLeay_add_all_digests(void);
d619 12
d639 2
d697 3
d716 3
d722 1
a722 1
#define EVP_R_MISSING_PARMATERS				 103
@


1.1
log
@Initial revision
@
text
@d67 1
a67 1
#include "md2.h"
d70 1
a70 1
#include "md5.h"
d72 2
a73 2
#if !defined(NO_SHA) || !defined(NO_SHA1)
#include "sha.h"
d76 1
a76 1
#include "ripemd.h"
d79 1
a79 1
#include "des.h"
d82 1
a82 1
#include "rc4.h"
d85 1
a85 1
#include "rc2.h"
d88 1
a88 1
#include "rc5.h"
d90 2
a91 2
#ifndef NO_BLOWFISH
#include "blowfish.h"
d94 1
a94 1
#include "cast.h"
d97 1
a97 1
#include "idea.h"
d100 1
a100 1
#include "mdc2.h"
d112 4
d117 1
a117 3
#include "rsa.h"
#else
#define RSA	long
d121 1
a121 3
#include "dsa.h"
#else
#define DSA	long
d125 1
a125 3
#include "dh.h"
#else
#define DH	long
d128 1
a128 1
#include "objects.h"
d160 1
d162 2
d165 2
d168 1
d171 1
a171 5
#ifdef HEADER_STACK_H
	STACK /* X509_ATTRIBUTE */ *attributes; /* [ 0 ] */
#else
	char /* X509_ATTRIBUTE */ *attributes; /* [ 0 ] */
#endif
d186 1
a186 1
 * When a PKEY is created, it will have a EVP_PKEY_METHOD ossociated with it.
d197 1
a197 1
#define EVP_rsa_md2()
d200 1
a200 1
#define EVP_rsa_md5()
d203 1
a203 1
#define EVP_rsa_sha0()
d206 1
a206 1
#define EVP_rsa_sha1()
d209 1
a209 1
#define EVP_rsa_ripemd160()
d212 1
a212 1
#define EVP_rsa_mdc2()
d215 1
a215 1
#define EVP_dsa_sha()
d218 1
a218 1
#define EVP_dsa_sha1()
d264 2
d292 1
a292 1
	EVP_MD *digest;
d301 1
a301 1
#ifndef NO_MD5
d304 1
a304 1
#if !defined(NO_SHA) || !defined(NO_SHA1)
d331 1
a331 1
	EVP_CIPHER *cipher;
d337 1
a337 1
	EVP_CIPHER *cipher;
d360 2
a361 2
			C_Block inw;
			C_Block outw;
d379 1
a379 1
#ifndef NO_BLOWFISH
d401 5
d440 1
d452 5
a456 1
#define BIO_set_md(b,md)		BIO_ctrl(b,BIO_C_SET_MD,0,(char *)md)
d460 1
d464 8
a471 1
#ifndef NOPROTO
d473 5
a477 2
void	EVP_DigestInit(EVP_MD_CTX *ctx, EVP_MD *type);
void	EVP_DigestUpdate(EVP_MD_CTX *ctx,unsigned char *d,unsigned int cnt);
d480 1
a480 1
int	EVP_read_pw_string(char *buf,int length,char *prompt,int verify);
d484 1
a484 1
int	EVP_BytesToKey(EVP_CIPHER *type,EVP_MD *md,unsigned char *salt,
d488 1
a488 3
EVP_CIPHER *EVP_get_cipherbyname(char *name);

void	EVP_EncryptInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,
d494 1
a494 1
void	EVP_DecryptInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,
d500 2
a501 2
void	EVP_CipherInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type, unsigned char *key,
		unsigned char *iv,int enc);
d543 2
a544 1
void BIO_set_cipher(BIO *b,EVP_CIPHER *c,unsigned char *k,
d581 1
a602 2
int EVP_add_alias(char *name,char *alias);
int EVP_delete_alias(char *name);
d604 2
a605 2
EVP_CIPHER *EVP_get_cipherbyname(char *name);
EVP_MD *EVP_get_digestbyname(char *name);
d631 2
d641 18
a658 1
#else
d660 4
a663 3
void	EVP_DigestInit();
void	EVP_DigestUpdate();
void	EVP_DigestFinal();
a664 140
int	EVP_read_pw_string();
void	EVP_set_pw_prompt();
char *	EVP_get_pw_prompt();

int	EVP_BytesToKey();

EVP_CIPHER *EVP_get_cipherbyname();

void	EVP_EncryptInit();
void	EVP_EncryptUpdate();
void	EVP_EncryptFinal();

void	EVP_DecryptInit();
void	EVP_DecryptUpdate();
int	EVP_DecryptFinal();

void	EVP_CipherInit();
void	EVP_CipherUpdate();
int	EVP_CipherFinal();

int	EVP_SignFinal();

int	EVP_VerifyFinal();

int	EVP_OpenInit();
int	EVP_OpenFinal();

int	EVP_SealInit();
void	EVP_SealFinal();

void	EVP_EncodeInit();
void	EVP_EncodeUpdate();
void	EVP_EncodeFinal();
int	EVP_EncodeBlock();

void	EVP_DecodeInit();
int	EVP_DecodeUpdate();
int	EVP_DecodeFinal();
int	EVP_DecodeBlock();

void	ERR_load_EVP_strings();

void EVP_CIPHER_CTX_init();
void EVP_CIPHER_CTX_cleanup();

#ifdef HEADER_BIO_H
BIO_METHOD *BIO_f_md();
BIO_METHOD *BIO_f_base64();
BIO_METHOD *BIO_f_cipher();
void BIO_set_cipher();
#endif

EVP_MD *EVP_md_null();
EVP_MD *EVP_md2();
EVP_MD *EVP_md5();
EVP_MD *EVP_sha();
EVP_MD *EVP_sha1();
EVP_MD *EVP_dss();
EVP_MD *EVP_dss1();
EVP_MD *EVP_mdc2();

EVP_CIPHER *EVP_enc_null();
EVP_CIPHER *EVP_des_ecb();
EVP_CIPHER *EVP_des_ede();
EVP_CIPHER *EVP_des_ede3();
EVP_CIPHER *EVP_des_cfb();
EVP_CIPHER *EVP_des_ede_cfb();
EVP_CIPHER *EVP_des_ede3_cfb();
EVP_CIPHER *EVP_des_ofb();
EVP_CIPHER *EVP_des_ede_ofb();
EVP_CIPHER *EVP_des_ede3_ofb();
EVP_CIPHER *EVP_des_cbc();
EVP_CIPHER *EVP_des_ede_cbc();
EVP_CIPHER *EVP_des_ede3_cbc();
EVP_CIPHER *EVP_desx_cbc();
EVP_CIPHER *EVP_rc4();
EVP_CIPHER *EVP_rc4_40();
EVP_CIPHER *EVP_idea_ecb();
EVP_CIPHER *EVP_idea_cfb();
EVP_CIPHER *EVP_idea_ofb();
EVP_CIPHER *EVP_idea_cbc();
EVP_CIPHER *EVP_rc2_ecb();
EVP_CIPHER *EVP_rc2_cbc();
EVP_CIPHER *EVP_rc2_40_cbc();
EVP_CIPHER *EVP_rc2_cfb();
EVP_CIPHER *EVP_rc2_ofb();
EVP_CIPHER *EVP_bf_ecb();
EVP_CIPHER *EVP_bf_cbc();
EVP_CIPHER *EVP_bf_cfb();
EVP_CIPHER *EVP_bf_ofb();
EVP_CIPHER *EVP_cast5_ecb();
EVP_CIPHER *EVP_cast5_cbc();
EVP_CIPHER *EVP_cast5_cfb();
EVP_CIPHER *EVP_cast5_ofb();
EVP_CIPHER *EVP_rc5_32_12_16_cbc();
EVP_CIPHER *EVP_rc5_32_12_16_ecb();
EVP_CIPHER *EVP_rc5_32_12_16_cfb();
EVP_CIPHER *EVP_rc5_32_12_16_ofb();

void SSLeay_add_all_algorithms();
void SSLeay_add_all_ciphers();
void SSLeay_add_all_digests();

int EVP_add_cipher();
int EVP_add_digest();
int EVP_add_alias();
int EVP_delete_alias();

EVP_CIPHER *EVP_get_cipherbyname();
EVP_MD *EVP_get_digestbyname();
void EVP_cleanup();

int		EVP_PKEY_decrypt();
int		EVP_PKEY_encrypt();
int		EVP_PKEY_type();
int		EVP_PKEY_bits();
int		EVP_PKEY_size();
int 		EVP_PKEY_assign();
EVP_PKEY *	EVP_PKEY_new();
void		EVP_PKEY_free();
EVP_PKEY *	d2i_PublicKey();
int		i2d_PublicKey();

EVP_PKEY *	d2i_PrivateKey();
int		i2d_PrivateKey();

int EVP_PKEY_copy_parameters();
int EVP_PKEY_missing_parameters();
int EVP_PKEY_save_parameters();
int EVP_PKEY_cmp_parameters();

int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);

int EVP_CIPHER_set_asn1_iv();
int EVP_CIPHER_get_asn1_iv();

#endif

/* BEGIN ERROR CODES */
d670 1
d672 5
d683 3
d689 4
d694 3
d698 1
d700 1
d703 1
d705 1
d707 9
a715 3
#define EVP_R_WRONG_FINAL_BLOCK_LENGTH			 108
#define EVP_R_WRONG_PUBLIC_KEY_TYPE			 109
 
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d62 2
a63 6
#ifdef OPENSSL_ALGORITHM_DEFINES
# include <openssl/opensslconf.h>
#else
# define OPENSSL_ALGORITHM_DEFINES
# include <openssl/opensslconf.h>
# undef OPENSSL_ALGORITHM_DEFINES
d66 35
a100 6
#include <openssl/ossl_typ.h>

#include <openssl/symhacks.h>

#ifndef OPENSSL_NO_BIO
#include <openssl/bio.h>
a102 1
/*
a107 1
*/
d109 14
a122 7
#define EVP_MAX_KEY_LENGTH		32
#define EVP_MAX_IV_LENGTH		16
#define EVP_MAX_BLOCK_LENGTH		32

#define PKCS5_SALT_LEN			8
/* Default PKCS#5 iteration count */
#define PKCS5_DEFAULT_ITER		2048
d124 7
a130 1
#include <openssl/objects.h>
a151 4
#ifdef	__cplusplus
extern "C" {
#endif

d154 2
a155 2
 * arbitrary encryption.... */
struct evp_pkey_st
a161 1
#ifndef OPENSSL_NO_RSA
a162 2
#endif
#ifndef OPENSSL_NO_DSA
a163 2
#endif
#ifndef OPENSSL_NO_DH
a164 1
#endif
d167 6
a172 2
	STACK_OF(X509_ATTRIBUTE) *attributes; /* [ 0 ] */
	} /* EVP_PKEY */;
d186 1
a186 1
 * When a PKEY is created, it will have a EVP_PKEY_METHOD associated with it.
d197 1
a197 1
#define EVP_rsa_md2() \
d200 1
a200 1
#define EVP_rsa_md5() \
d203 1
a203 1
#define EVP_rsa_sha0() \
d206 1
a206 1
#define EVP_rsa_sha1() \
d209 1
a209 1
#define EVP_rsa_ripemd160() \
d212 1
a212 1
#define EVP_rsa_mdc2() \
d215 1
a215 1
#define EVP_dsa_sha() \
d217 2
a218 2
			EVP_dsa(),EVP_sha())
#define EVP_dsa_sha1() \
d233 1
d248 1
a248 1
struct env_md_st
d253 3
a255 6
	unsigned long flags;
	int (*init)(EVP_MD_CTX *ctx);
	int (*update)(EVP_MD_CTX *ctx,const void *data,unsigned long count);
	int (*final)(EVP_MD_CTX *ctx,unsigned char *md);
	int (*copy)(EVP_MD_CTX *to,const EVP_MD_CTX *from);
	int (*cleanup)(EVP_MD_CTX *ctx);
a256 1
	/* FIXME: prototype these some day */
d261 2
a262 5
	int ctx_size; /* how big does the ctx->md_data need to be */
	} /* EVP_MD */;

#define EVP_MD_FLAG_ONESHOT	0x0001 /* digest can only handle a single
					* block */
d266 1
a266 1
#ifndef OPENSSL_NO_DSA
d274 1
a274 1
#ifndef OPENSSL_NO_RSA
d288 1
a288 1
struct env_md_ctx_st
d290 20
a309 12
	const EVP_MD *digest;
	ENGINE *engine; /* functional reference if 'digest' is ENGINE-provided */
	unsigned long flags;
	void *md_data;
	} /* EVP_MD_CTX */;

/* values for EVP_MD_CTX flags */

#define EVP_MD_CTX_FLAG_ONESHOT		0x0001 /* digest update will be called
						* once only */
#define EVP_MD_CTX_FLAG_CLEANED		0x0002 /* context has already been
						* cleaned */
d311 1
a311 1
struct evp_cipher_st
d315 1
a315 1
	int key_len;		/* Default value for variable length ciphers */
d317 9
a325 44
	unsigned long flags;	/* Various flags */
	int (*init)(EVP_CIPHER_CTX *ctx, const unsigned char *key,
		    const unsigned char *iv, int enc);	/* init key */
	int (*do_cipher)(EVP_CIPHER_CTX *ctx, unsigned char *out,
			 const unsigned char *in, unsigned int inl);/* encrypt/decrypt data */
	int (*cleanup)(EVP_CIPHER_CTX *); /* cleanup ctx */
	int ctx_size;		/* how big ctx->cipher_data needs to be */
	int (*set_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *); /* Populate a ASN1_TYPE with parameters */
	int (*get_asn1_parameters)(EVP_CIPHER_CTX *, ASN1_TYPE *); /* Get parameters from a ASN1_TYPE */
	int (*ctrl)(EVP_CIPHER_CTX *, int type, int arg, void *ptr); /* Miscellaneous operations */
	void *app_data;		/* Application data */
	} /* EVP_CIPHER */;

/* Values for cipher flags */

/* Modes for ciphers */

#define		EVP_CIPH_STREAM_CIPHER		0x0
#define		EVP_CIPH_ECB_MODE		0x1
#define		EVP_CIPH_CBC_MODE		0x2
#define		EVP_CIPH_CFB_MODE		0x3
#define		EVP_CIPH_OFB_MODE		0x4
#define 	EVP_CIPH_MODE			0x7
/* Set if variable length cipher */
#define 	EVP_CIPH_VARIABLE_LENGTH	0x8
/* Set if the iv handling should be done by the cipher itself */
#define 	EVP_CIPH_CUSTOM_IV		0x10
/* Set if the cipher's init() function should be called if key is NULL */
#define 	EVP_CIPH_ALWAYS_CALL_INIT	0x20
/* Call ctrl() to init cipher parameters */
#define 	EVP_CIPH_CTRL_INIT		0x40
/* Don't use standard key length function */
#define 	EVP_CIPH_CUSTOM_KEY_LENGTH	0x80
/* Don't use standard block padding */
#define 	EVP_CIPH_NO_PADDING		0x100

/* ctrl() values */

#define		EVP_CTRL_INIT			0x0
#define 	EVP_CTRL_SET_KEY_LENGTH		0x1
#define 	EVP_CTRL_GET_RC2_KEY_BITS	0x2
#define 	EVP_CTRL_SET_RC2_KEY_BITS	0x3
#define 	EVP_CTRL_GET_RC5_ROUNDS		0x4
#define 	EVP_CTRL_SET_RC5_ROUNDS		0x5
d329 1
a329 1
	const EVP_CIPHER *cipher;
d333 1
a333 1
struct evp_cipher_ctx_st
d335 1
a335 2
	const EVP_CIPHER *cipher;
	ENGINE *engine;	/* functional reference if 'cipher' is ENGINE-provided */
d341 1
a341 1
	unsigned char buf[EVP_MAX_BLOCK_LENGTH];/* saved partial block */
d344 41
a384 8
	void *app_data;		/* application stuff */
	int key_len;		/* May change for variable length cipher */
	unsigned long flags;	/* Various flags */
	void *cipher_data; /* per EVP data */
	int final_used;
	int block_mask;
	unsigned char final[EVP_MAX_BLOCK_LENGTH];/* possible final block */
	} /* EVP_CIPHER_CTX */;
a398 6
/* Password based encryption function */
typedef int (EVP_PBE_KEYGEN)(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
		ASN1_TYPE *param, const EVP_CIPHER *cipher,
                const EVP_MD *md, int en_de);

#ifndef OPENSSL_NO_RSA
a400 3
#endif

#ifndef OPENSSL_NO_DSA
a402 3
#endif

#ifndef OPENSSL_NO_DH
a404 1
#endif
a412 2
#define EVP_MD_nid(e)			EVP_MD_type(e)
#define EVP_MD_name(e)			OBJ_nid2sn(EVP_MD_nid(e))
a416 1
#define EVP_MD_CTX_md(e)		((e)->digest)
d419 1
a419 1
#define EVP_MD_CTX_type(e)		EVP_MD_type((e)->digest)
a421 1
#define EVP_CIPHER_name(e)		OBJ_nid2sn(EVP_CIPHER_nid(e))
a424 2
#define EVP_CIPHER_flags(e)		((e)->flags)
#define EVP_CIPHER_mode(e)		(((e)->flags) & EVP_CIPH_MODE)
d429 1
a429 1
#define EVP_CIPHER_CTX_key_length(e)	((e)->key_len)
a432 3
#define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
#define EVP_CIPHER_CTX_flags(e)		((e)->cipher->flags)
#define EVP_CIPHER_CTX_mode(e)		((e)->cipher->flags & EVP_CIPH_MODE)
a436 1
#define EVP_SignInit_ex(a,b,c)		EVP_DigestInit_ex(a,b,c)
a438 1
#define	EVP_VerifyInit_ex(a,b,c)	EVP_DigestInit_ex(a,b,c)
d444 1
a444 5
#ifdef CONST_STRICT
void BIO_set_md(BIO *,const EVP_MD *md);
#else
# define BIO_set_md(b,md)		BIO_ctrl(b,BIO_C_SET_MD,0,(char *)md)
#endif
a447 1
#define BIO_get_cipher_ctx(b,c_pp)	BIO_ctrl(b,BIO_C_GET_CIPHER_CTX,0,(char *)c_pp)
d451 1
a451 27
#define EVP_add_cipher_alias(n,alias) \
	OBJ_NAME_add((alias),OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS,(n))
#define EVP_add_digest_alias(n,alias) \
	OBJ_NAME_add((alias),OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS,(n))
#define EVP_delete_cipher_alias(alias) \
	OBJ_NAME_remove(alias,OBJ_NAME_TYPE_CIPHER_METH|OBJ_NAME_ALIAS);
#define EVP_delete_digest_alias(alias) \
	OBJ_NAME_remove(alias,OBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS);

void	EVP_MD_CTX_init(EVP_MD_CTX *ctx);
int	EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
EVP_MD_CTX *EVP_MD_CTX_create(void);
void	EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);
int     EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);  
#define EVP_MD_CTX_set_flags(ctx,flgs) ((ctx)->flags|=(flgs))
#define EVP_MD_CTX_clear_flags(ctx,flgs) ((ctx)->flags&=~(flgs))
#define EVP_MD_CTX_test_flags(ctx,flgs) ((ctx)->flags&(flgs))
int	EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);
int	EVP_DigestUpdate(EVP_MD_CTX *ctx,const void *d,
			 unsigned int cnt);
int	EVP_DigestFinal_ex(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s);
int	EVP_Digest(void *data, unsigned int count,
		unsigned char *md, unsigned int *size, const EVP_MD *type, ENGINE *impl);

int     EVP_MD_CTX_copy(EVP_MD_CTX *out,const EVP_MD_CTX *in);  
int	EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
int	EVP_DigestFinal(EVP_MD_CTX *ctx,unsigned char *md,unsigned int *s);
d453 5
a457 1
int	EVP_read_pw_string(char *buf,int length,const char *prompt,int verify);
d461 16
a476 19
int	EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,
		const unsigned char *salt, const unsigned char *data,
		int datal, int count, unsigned char *key,unsigned char *iv);

int	EVP_EncryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
		const unsigned char *key, const unsigned char *iv);
int	EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
		const unsigned char *key, const unsigned char *iv);
int	EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
		int *outl, const unsigned char *in, int inl);
int	EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
int	EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);

int	EVP_DecryptInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
		const unsigned char *key, const unsigned char *iv);
int	EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
		const unsigned char *key, const unsigned char *iv);
int	EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
		int *outl, const unsigned char *in, int inl);
a477 1
int	EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
d479 4
a482 8
int	EVP_CipherInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher,
		       const unsigned char *key,const unsigned char *iv,
		       int enc);
int	EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,
		       const unsigned char *key,const unsigned char *iv,
		       int enc);
int	EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
		int *outl, const unsigned char *in, int inl);
a483 1
int	EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);
d491 1
a491 1
int	EVP_OpenInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,unsigned char *ek,
d495 1
a495 1
int	EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, unsigned char **ek,
d497 1
a497 1
int	EVP_SealFinal(EVP_CIPHER_CTX *ctx,unsigned char *out,int *outl);
d503 1
a503 1
int	EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);
d510 4
a513 1
int	EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);
d516 1
a516 4
int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad);
int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
d518 1
a518 1
#ifndef OPENSSL_NO_BIO
d522 1
a522 2
BIO_METHOD *BIO_f_reliable(void);
void BIO_set_cipher(BIO *b,const EVP_CIPHER *c,unsigned char *k,
d526 56
a581 109
const EVP_MD *EVP_md_null(void);
#ifndef OPENSSL_NO_MD2
const EVP_MD *EVP_md2(void);
#endif
#ifndef OPENSSL_NO_MD4
const EVP_MD *EVP_md4(void);
#endif
#ifndef OPENSSL_NO_MD5
const EVP_MD *EVP_md5(void);
#endif
#ifndef OPENSSL_NO_SHA
const EVP_MD *EVP_sha(void);
const EVP_MD *EVP_sha1(void);
const EVP_MD *EVP_dss(void);
const EVP_MD *EVP_dss1(void);
#endif
#ifndef OPENSSL_NO_MDC2
const EVP_MD *EVP_mdc2(void);
#endif
#ifndef OPENSSL_NO_RIPEMD
const EVP_MD *EVP_ripemd160(void);
#endif
const EVP_CIPHER *EVP_enc_null(void);		/* does nothing :-) */
#ifndef OPENSSL_NO_DES
const EVP_CIPHER *EVP_des_ecb(void);
const EVP_CIPHER *EVP_des_ede(void);
const EVP_CIPHER *EVP_des_ede3(void);
const EVP_CIPHER *EVP_des_cfb(void);
const EVP_CIPHER *EVP_des_ede_cfb(void);
const EVP_CIPHER *EVP_des_ede3_cfb(void);
const EVP_CIPHER *EVP_des_ofb(void);
const EVP_CIPHER *EVP_des_ede_ofb(void);
const EVP_CIPHER *EVP_des_ede3_ofb(void);
const EVP_CIPHER *EVP_des_cbc(void);
const EVP_CIPHER *EVP_des_ede_cbc(void);
const EVP_CIPHER *EVP_des_ede3_cbc(void);
const EVP_CIPHER *EVP_desx_cbc(void);
/* This should now be supported through the dev_crypto ENGINE. But also, why are
 * rc4 and md5 declarations made here inside a "NO_DES" precompiler branch? */
#if 0
# ifdef OPENSSL_OPENBSD_DEV_CRYPTO
const EVP_CIPHER *EVP_dev_crypto_des_ede3_cbc(void);
const EVP_CIPHER *EVP_dev_crypto_rc4(void);
const EVP_MD *EVP_dev_crypto_md5(void);
# endif
#endif
#endif
#ifndef OPENSSL_NO_RC4
const EVP_CIPHER *EVP_rc4(void);
const EVP_CIPHER *EVP_rc4_40(void);
#endif
#ifndef OPENSSL_NO_IDEA
const EVP_CIPHER *EVP_idea_ecb(void);
const EVP_CIPHER *EVP_idea_cfb(void);
const EVP_CIPHER *EVP_idea_ofb(void);
const EVP_CIPHER *EVP_idea_cbc(void);
#endif
#ifndef OPENSSL_NO_RC2
const EVP_CIPHER *EVP_rc2_ecb(void);
const EVP_CIPHER *EVP_rc2_cbc(void);
const EVP_CIPHER *EVP_rc2_40_cbc(void);
const EVP_CIPHER *EVP_rc2_64_cbc(void);
const EVP_CIPHER *EVP_rc2_cfb(void);
const EVP_CIPHER *EVP_rc2_ofb(void);
#endif
#ifndef OPENSSL_NO_BF
const EVP_CIPHER *EVP_bf_ecb(void);
const EVP_CIPHER *EVP_bf_cbc(void);
const EVP_CIPHER *EVP_bf_cfb(void);
const EVP_CIPHER *EVP_bf_ofb(void);
#endif
#ifndef OPENSSL_NO_CAST
const EVP_CIPHER *EVP_cast5_ecb(void);
const EVP_CIPHER *EVP_cast5_cbc(void);
const EVP_CIPHER *EVP_cast5_cfb(void);
const EVP_CIPHER *EVP_cast5_ofb(void);
#endif
#ifndef OPENSSL_NO_RC5
const EVP_CIPHER *EVP_rc5_32_12_16_cbc(void);
const EVP_CIPHER *EVP_rc5_32_12_16_ecb(void);
const EVP_CIPHER *EVP_rc5_32_12_16_cfb(void);
const EVP_CIPHER *EVP_rc5_32_12_16_ofb(void);
#endif
#ifndef OPENSSL_NO_AES
const EVP_CIPHER *EVP_aes_128_ecb(void);
const EVP_CIPHER *EVP_aes_128_cbc(void);
const EVP_CIPHER *EVP_aes_128_cfb(void);
const EVP_CIPHER *EVP_aes_128_ofb(void);
#if 0
const EVP_CIPHER *EVP_aes_128_ctr(void);
#endif
const EVP_CIPHER *EVP_aes_192_ecb(void);
const EVP_CIPHER *EVP_aes_192_cbc(void);
const EVP_CIPHER *EVP_aes_192_cfb(void);
const EVP_CIPHER *EVP_aes_192_ofb(void);
#if 0
const EVP_CIPHER *EVP_aes_192_ctr(void);
#endif
const EVP_CIPHER *EVP_aes_256_ecb(void);
const EVP_CIPHER *EVP_aes_256_cbc(void);
const EVP_CIPHER *EVP_aes_256_cfb(void);
const EVP_CIPHER *EVP_aes_256_ofb(void);
#if 0
const EVP_CIPHER *EVP_aes_256_ctr(void);
#endif
#endif

void OPENSSL_add_all_algorithms_noconf(void);
void OPENSSL_add_all_algorithms_conf(void);
d583 2
a584 19
#ifdef OPENSSL_LOAD_CONF
#define OpenSSL_add_all_algorithms() \
		OPENSSL_add_all_algorithms_conf()
#else
#define OpenSSL_add_all_algorithms() \
		OPENSSL_add_all_algorithms_noconf()
#endif

void OpenSSL_add_all_ciphers(void);
void OpenSSL_add_all_digests(void);
#define SSLeay_add_all_algorithms() OpenSSL_add_all_algorithms()
#define SSLeay_add_all_ciphers() OpenSSL_add_all_ciphers()
#define SSLeay_add_all_digests() OpenSSL_add_all_digests()

int EVP_add_cipher(const EVP_CIPHER *cipher);
int EVP_add_digest(const EVP_MD *digest);

const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
const EVP_MD *EVP_get_digestbyname(const char *name);
a594 18

#ifndef OPENSSL_NO_RSA
struct rsa_st;
int EVP_PKEY_set1_RSA(EVP_PKEY *pkey,struct rsa_st *key);
struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);
#endif
#ifndef OPENSSL_NO_DSA
struct dsa_st;
int EVP_PKEY_set1_DSA(EVP_PKEY *pkey,struct dsa_st *key);
struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);
#endif
#ifndef OPENSSL_NO_DH
struct dh_st;
int EVP_PKEY_set1_DH(EVP_PKEY *pkey,struct dh_st *key);
struct dh_st *EVP_PKEY_get1_DH(EVP_PKEY *pkey);
#endif


a602 2
EVP_PKEY *	d2i_AutoPrivateKey(EVP_PKEY **a, unsigned char **pp,
			long length);
a609 2
int EVP_CIPHER_type(const EVP_CIPHER *ctx);

d618 144
a761 18
/* PKCS5 password based encryption */
int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
			 ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,
			 int en_de);
int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
			   unsigned char *salt, int saltlen, int iter,
			   int keylen, unsigned char *out);
int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
			 ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,
			 int en_de);

void PKCS5_PBE_add(void);

int EVP_PBE_CipherInit (ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
	     ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de);
int EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,
		    EVP_PBE_KEYGEN *keygen);
void EVP_PBE_cleanup(void);
a763 5
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_EVP_strings(void);

a767 3
#define EVP_F_EVP_CIPHERINIT				 123
#define EVP_F_EVP_CIPHER_CTX_CTRL			 124
#define EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH		 122
a768 3
#define EVP_F_EVP_DIGESTINIT				 128
#define EVP_F_EVP_ENCRYPTFINAL				 127
#define EVP_F_EVP_MD_CTX_COPY				 110
a769 5
#define EVP_F_EVP_PBE_ALG_ADD				 115
#define EVP_F_EVP_PBE_CIPHERINIT			 116
#define EVP_F_EVP_PKCS82PKEY				 111
#define EVP_F_EVP_PKCS8_SET_BROKEN			 112
#define EVP_F_EVP_PKEY2PKCS8				 113
a772 3
#define EVP_F_EVP_PKEY_GET1_DH				 119
#define EVP_F_EVP_PKEY_GET1_DSA				 120
#define EVP_F_EVP_PKEY_GET1_RSA				 121
a773 1
#define EVP_F_EVP_RIJNDAEL				 126
a775 4
#define EVP_F_PKCS5_PBE_KEYIVGEN			 117
#define EVP_F_PKCS5_V2_PBE_KEYIVGEN			 118
#define EVP_F_RC2_MAGIC_TO_METH				 109
#define EVP_F_RC5_CTRL					 125
a777 1
#define EVP_R_BAD_BLOCK_LENGTH				 136
a778 8
#define EVP_R_BAD_KEY_LENGTH				 137
#define EVP_R_BN_DECODE_ERROR				 112
#define EVP_R_BN_PUBKEY_ERROR				 113
#define EVP_R_CIPHER_PARAMETER_ERROR			 122
#define EVP_R_CTRL_NOT_IMPLEMENTED			 132
#define EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED		 133
#define EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH		 138
#define EVP_R_DECODE_ERROR				 114
a779 8
#define EVP_R_ENCODE_ERROR				 115
#define EVP_R_EVP_PBE_CIPHERINIT_ERROR			 119
#define EVP_R_EXPECTING_AN_RSA_KEY			 127
#define EVP_R_EXPECTING_A_DH_KEY			 128
#define EVP_R_EXPECTING_A_DSA_KEY			 129
#define EVP_R_INITIALIZATION_ERROR			 134
#define EVP_R_INPUT_NOT_INITIALIZED			 111
#define EVP_R_INVALID_KEY_LENGTH			 130
d781 1
a781 5
#define EVP_R_KEYGEN_FAILURE				 120
#define EVP_R_MISSING_PARAMETERS			 103
#define EVP_R_NO_CIPHER_SET				 131
#define EVP_R_NO_DIGEST_SET				 139
#define EVP_R_NO_DSA_PARAMETERS				 116
a783 1
#define EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE			 117
a784 2
#define EVP_R_UNKNOWN_PBE_ALGORITHM			 121
#define EVP_R_UNSUPORTED_NUMBER_OF_ROUNDS		 135
d786 3
a788 9
#define EVP_R_UNSUPPORTED_KEYLENGTH			 123
#define EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION	 124
#define EVP_R_UNSUPPORTED_KEY_SIZE			 108
#define EVP_R_UNSUPPORTED_PRF				 125
#define EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM		 118
#define EVP_R_UNSUPPORTED_SALT_TYPE			 126
#define EVP_R_WRONG_FINAL_BLOCK_LENGTH			 109
#define EVP_R_WRONG_PUBLIC_KEY_TYPE			 110

d793 1
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a76 42
#ifndef OPENSSL_NO_MD2
#include <openssl/md2.h>
#endif
#ifndef OPENSSL_NO_MD4
#include <openssl/md4.h>
#endif
#ifndef OPENSSL_NO_MD5
#include <openssl/md5.h>
#endif
#ifndef OPENSSL_NO_SHA
#include <openssl/sha.h>
#endif
#ifndef OPENSSL_NO_RIPEMD
#include <openssl/ripemd.h>
#endif
#ifndef OPENSSL_NO_DES
#include <openssl/des.h>
#endif
#ifndef OPENSSL_NO_RC4
#include <openssl/rc4.h>
#endif
#ifndef OPENSSL_NO_RC2
#include <openssl/rc2.h>
#endif
#ifndef OPENSSL_NO_RC5
#include <openssl/rc5.h>
#endif
#ifndef OPENSSL_NO_BF
#include <openssl/blowfish.h>
#endif
#ifndef OPENSSL_NO_CAST
#include <openssl/cast.h>
#endif
#ifndef OPENSSL_NO_IDEA
#include <openssl/idea.h>
#endif
#ifndef OPENSSL_NO_MDC2
#include <openssl/mdc2.h>
#endif
#ifndef OPENSSL_NO_AES
#include <openssl/aes.h>
#endif
a93 12
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif

#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif

#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif

a584 2
const EVP_CIPHER *EVP_des_ede_ecb(void);
const EVP_CIPHER *EVP_des_ede3_ecb(void);
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@a331 2
#define EVP_MD_CTX_FLAG_REUSE		0x0004 /* Don't free up ctx->md_data
						* in EVP_MD_CTX_cleanup */
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a119 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a292 1
#define EVP_MD_FLAG_FIPS	0x0400 /* Note if suitable for use in FIPS mode */
a334 3
#define EVP_MD_CTX_FLAG_NON_FIPS_ALLOW	0x0008	/* Allow use of non FIPS digest
						 * in FIPS mode */

a375 4
/* Note if suitable for use in FIPS mode */
#define		EVP_CIPH_FLAG_FIPS		0x400
/* Allow non FIPS cipher in FIPS mode */
#define		EVP_CIPH_FLAG_NON_FIPS_ALLOW	0x800
a480 3
#define EVP_CIPHER_CTX_set_flags(ctx,flgs) ((ctx)->flags|=(flgs))
#define EVP_CIPHER_CTX_clear_flags(ctx,flgs) ((ctx)->flags&=~(flgs))
#define EVP_CIPHER_CTX_test_flags(ctx,flgs) ((ctx)->flags&(flgs))
a501 1
#define BIO_set_md_ctx(b,mdcp)     BIO_ctrl(b,BIO_C_SET_MD_CTX,0,(char *)mdcp)
d643 3
a645 14
const EVP_CIPHER *EVP_des_cfb64(void);
# define EVP_des_cfb EVP_des_cfb64
const EVP_CIPHER *EVP_des_cfb1(void);
const EVP_CIPHER *EVP_des_cfb8(void);
const EVP_CIPHER *EVP_des_ede_cfb64(void);
# define EVP_des_ede_cfb EVP_des_ede_cfb64
#if 0
const EVP_CIPHER *EVP_des_ede_cfb1(void);
const EVP_CIPHER *EVP_des_ede_cfb8(void);
#endif
const EVP_CIPHER *EVP_des_ede3_cfb64(void);
# define EVP_des_ede3_cfb EVP_des_ede3_cfb64
const EVP_CIPHER *EVP_des_ede3_cfb1(void);
const EVP_CIPHER *EVP_des_ede3_cfb8(void);
d669 1
a669 2
const EVP_CIPHER *EVP_idea_cfb64(void);
# define EVP_idea_cfb EVP_idea_cfb64
d678 1
a678 2
const EVP_CIPHER *EVP_rc2_cfb64(void);
# define EVP_rc2_cfb EVP_rc2_cfb64
d684 1
a684 2
const EVP_CIPHER *EVP_bf_cfb64(void);
# define EVP_bf_cfb EVP_bf_cfb64
d690 1
a690 2
const EVP_CIPHER *EVP_cast5_cfb64(void);
# define EVP_cast5_cfb EVP_cast5_cfb64
d696 1
a696 2
const EVP_CIPHER *EVP_rc5_32_12_16_cfb64(void);
# define EVP_rc5_32_12_16_cfb EVP_rc5_32_12_16_cfb64
d702 1
a702 4
const EVP_CIPHER *EVP_aes_128_cfb1(void);
const EVP_CIPHER *EVP_aes_128_cfb8(void);
const EVP_CIPHER *EVP_aes_128_cfb128(void);
# define EVP_aes_128_cfb EVP_aes_128_cfb128
d709 1
a709 4
const EVP_CIPHER *EVP_aes_192_cfb1(void);
const EVP_CIPHER *EVP_aes_192_cfb8(void);
const EVP_CIPHER *EVP_aes_192_cfb128(void);
# define EVP_aes_192_cfb EVP_aes_192_cfb128
d716 1
a716 4
const EVP_CIPHER *EVP_aes_256_cfb1(void);
const EVP_CIPHER *EVP_aes_256_cfb8(void);
const EVP_CIPHER *EVP_aes_256_cfb128(void);
# define EVP_aes_256_cfb EVP_aes_256_cfb128
a827 1
#define EVP_F_AES_INIT_KEY				 129
a828 2
#define EVP_F_EVP_ADD_CIPHER				 130
#define EVP_F_EVP_ADD_DIGEST				 131
a834 2
#define EVP_F_EVP_GET_CIPHERBYNAME			 132
#define EVP_F_EVP_GET_DIGESTBYNAME			 133
a857 1
#define EVP_R_AES_KEY_SETUP_FAILED			 140
a868 1
#define EVP_R_DISABLED_FOR_FIPS				 141
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@a86 1
#ifndef OPENSSL_FIPS
a87 3
#else
#include <openssl/fips_sha.h>
#endif
d131 1
a131 5
#ifdef OPENSSL_FIPS
#define EVP_MAX_MD_SIZE			64	/* longest known SHA512 */
#else
#define EVP_MAX_MD_SIZE			(16+20)	/* The SSLv3 md5+sha1 type */
#endif
a644 10
#ifdef OPENSSL_FIPS
#ifndef OPENSSL_NO_SHA256
const EVP_MD *EVP_sha224(void);
const EVP_MD *EVP_sha256(void);
#endif
#ifndef OPENSSL_NO_SHA512
const EVP_MD *EVP_sha384(void);
const EVP_MD *EVP_sha512(void);
#endif
#endif
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d77 50
d135 5
a139 1
#define EVP_MAX_MD_SIZE			64	/* longest known is SHA512 */
d148 12
a164 1
#define EVP_PK_EC	0x0008
a169 1
#define EVP_PKS_EC	0x0400
a180 1
#define EVP_PKEY_EC	NID_X9_62_id_ecPublicKey
a204 3
#ifndef OPENSSL_NO_EC
		struct ec_key_st *ec;	/* ECC */
#endif
d290 1
a290 1
	int (*update)(EVP_MD_CTX *ctx,const void *data,size_t count);
d296 2
a297 5
	int (*sign)(int type, const unsigned char *m, unsigned int m_length,
		    unsigned char *sigret, unsigned int *siglen, void *key);
	int (*verify)(int type, const unsigned char *m, unsigned int m_length,
		      const unsigned char *sigbuf, unsigned int siglen,
		      void *key);
a302 7
typedef int evp_sign_method(int type,const unsigned char *m,
			    unsigned int m_length,unsigned char *sigret,
			    unsigned int *siglen, void *key);
typedef int evp_verify_method(int type,const unsigned char *m,
			    unsigned int m_length,const unsigned char *sigbuf,
			    unsigned int siglen, void *key);

d305 1
d310 1
a310 2
#define EVP_PKEY_DSA_method	(evp_sign_method *)DSA_sign, \
				(evp_verify_method *)DSA_verify, \
a316 8
#ifndef OPENSSL_NO_ECDSA
#define EVP_PKEY_ECDSA_method   (evp_sign_method *)ECDSA_sign, \
				(evp_verify_method *)ECDSA_verify, \
                                 {EVP_PKEY_EC,0,0,0}
#else   
#define EVP_PKEY_ECDSA_method   EVP_PKEY_NULL_method
#endif

d318 1
a318 2
#define EVP_PKEY_RSA_method	(evp_sign_method *)RSA_sign, \
				(evp_verify_method *)RSA_verify, \
d321 2
a322 2
				(evp_sign_method *)RSA_sign_ASN1_OCTET_STRING, \
				(evp_verify_method *)RSA_verify_ASN1_OCTET_STRING, \
d348 3
d392 4
a395 2
/* cipher handles random key generation */
#define 	EVP_CIPH_RAND_KEY		0x200
a404 1
#define 	EVP_CTRL_RAND_KEY		0x6
a465 5
#ifndef OPENSSL_NO_EC
#define EVP_PKEY_assign_EC_KEY(pkey,eckey) EVP_PKEY_assign((pkey),EVP_PKEY_EC,\
                                        (char *)(eckey))
#endif

d472 1
a472 1
int EVP_MD_type(const EVP_MD *md);
d475 8
a482 8
int EVP_MD_pkey_type(const EVP_MD *md);	
int EVP_MD_size(const EVP_MD *md);
int EVP_MD_block_size(const EVP_MD *md);

const EVP_MD * EVP_MD_CTX_md(const EVP_MD_CTX *ctx);
#define EVP_MD_CTX_size(e)		EVP_MD_size(EVP_MD_CTX_md(e))
#define EVP_MD_CTX_block_size(e)	EVP_MD_block_size(EVP_MD_CTX_md(e))
#define EVP_MD_CTX_type(e)		EVP_MD_type(EVP_MD_CTX_md(e))
d484 1
a484 1
int EVP_CIPHER_nid(const EVP_CIPHER *cipher);
d486 13
a498 13
int EVP_CIPHER_block_size(const EVP_CIPHER *cipher);
int EVP_CIPHER_key_length(const EVP_CIPHER *cipher);
int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);
unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher);
#define EVP_CIPHER_mode(e)		(EVP_CIPHER_flags(e) & EVP_CIPH_MODE)

const EVP_CIPHER * EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);
int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);
void * EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);
void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data);
d500 5
a504 2
unsigned long EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx);
#define EVP_CIPHER_CTX_mode(e)		(EVP_CIPHER_CTX_flags(e) & EVP_CIPH_MODE)
d529 1
a529 4
int EVP_Cipher(EVP_CIPHER_CTX *c,
		unsigned char *out,
		const unsigned char *in,
		unsigned int inl);
d545 3
a547 3
void	EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags);
void	EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags);
int 	EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx,int flags);
d550 1
a550 1
			 size_t cnt);
d552 1
a552 1
int	EVP_Digest(const void *data, size_t count,
d560 1
a560 1
void	EVP_set_pw_prompt(const char *prompt);
d599 1
a599 1
int	EVP_VerifyFinal(EVP_MD_CTX *ctx,const unsigned char *sigbuf,
d602 2
a603 3
int	EVP_OpenInit(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *type,
		const unsigned char *ek, int ekl, const unsigned char *iv,
		EVP_PKEY *priv);
d606 2
a607 3
int	EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
		 unsigned char **ek, int *ekl, unsigned char *iv,
		EVP_PKEY **pubk, int npubk);
d611 2
a612 2
void	EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx,unsigned char *out,int *outl,
		const unsigned char *in,int inl);
d618 1
a618 1
		const unsigned char *in, int inl);
a624 2
EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a);
a627 1
int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);
d634 2
a635 2
void BIO_set_cipher(BIO *b,const EVP_CIPHER *c,const unsigned char *k,
		const unsigned char *i, int enc);
d653 1
a653 2
const EVP_MD *EVP_ecdsa(void);
#endif
d662 2
a780 31
#ifndef OPENSSL_NO_CAMELLIA
const EVP_CIPHER *EVP_camellia_128_ecb(void);
const EVP_CIPHER *EVP_camellia_128_cbc(void);
const EVP_CIPHER *EVP_camellia_128_cfb1(void);
const EVP_CIPHER *EVP_camellia_128_cfb8(void);
const EVP_CIPHER *EVP_camellia_128_cfb128(void);
# define EVP_camellia_128_cfb EVP_camellia_128_cfb128
const EVP_CIPHER *EVP_camellia_128_ofb(void);
const EVP_CIPHER *EVP_camellia_192_ecb(void);
const EVP_CIPHER *EVP_camellia_192_cbc(void);
const EVP_CIPHER *EVP_camellia_192_cfb1(void);
const EVP_CIPHER *EVP_camellia_192_cfb8(void);
const EVP_CIPHER *EVP_camellia_192_cfb128(void);
# define EVP_camellia_192_cfb EVP_camellia_192_cfb128
const EVP_CIPHER *EVP_camellia_192_ofb(void);
const EVP_CIPHER *EVP_camellia_256_ecb(void);
const EVP_CIPHER *EVP_camellia_256_cbc(void);
const EVP_CIPHER *EVP_camellia_256_cfb1(void);
const EVP_CIPHER *EVP_camellia_256_cfb8(void);
const EVP_CIPHER *EVP_camellia_256_cfb128(void);
# define EVP_camellia_256_cfb EVP_camellia_256_cfb128
const EVP_CIPHER *EVP_camellia_256_ofb(void);
#endif

#ifndef OPENSSL_NO_SEED
const EVP_CIPHER *EVP_seed_ecb(void);
const EVP_CIPHER *EVP_seed_cbc(void);
const EVP_CIPHER *EVP_seed_cfb128(void);
# define EVP_seed_cfb EVP_seed_cfb128
const EVP_CIPHER *EVP_seed_ofb(void);
#endif
d806 2
a807 3
int		EVP_PKEY_decrypt(unsigned char *dec_key,
			const unsigned char *enc_key,int enc_key_len,
			EVP_PKEY *private_key);
d809 1
a809 2
			const unsigned char *key,int key_len,
			EVP_PKEY *pub_key);
d830 1
a830 5
#ifndef OPENSSL_NO_EC
struct ec_key_st;
int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey,struct ec_key_st *key);
struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);
#endif
d834 1
a834 2

EVP_PKEY *	d2i_PublicKey(int type,EVP_PKEY **a, const unsigned char **pp,
d838 1
a838 1
EVP_PKEY *	d2i_PrivateKey(int type,EVP_PKEY **a, const unsigned char **pp,
d840 1
a840 1
EVP_PKEY *	d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
d844 2
a845 2
int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);
int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);
d847 1
a847 3
int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);

int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);
d864 1
a864 1
			   const unsigned char *salt, int saltlen, int iter,
d887 1
a887 2
#define EVP_F_AES_INIT_KEY				 133
#define EVP_F_CAMELLIA_INIT_KEY				 159
d889 3
a891 5
#define EVP_F_DSAPKEY2PKCS8				 134
#define EVP_F_DSA_PKEY2PKCS8				 135
#define EVP_F_ECDSA_PKEY2PKCS8				 129
#define EVP_F_ECKEY_PKEY2PKCS8				 132
#define EVP_F_EVP_CIPHERINIT_EX				 123
d894 6
a899 4
#define EVP_F_EVP_DECRYPTFINAL_EX			 101
#define EVP_F_EVP_DIGESTINIT_EX				 128
#define EVP_F_EVP_ENCRYPTFINAL_EX			 127
#define EVP_F_EVP_MD_CTX_COPY_EX			 110
d904 2
a905 1
#define EVP_F_EVP_PKEY2PKCS8_BROKEN			 113
a910 2
#define EVP_F_EVP_PKEY_GET1_ECDSA			 130
#define EVP_F_EVP_PKEY_GET1_EC_KEY			 131
a917 1
#define EVP_F_PKCS8_SET_BROKEN				 112
d922 1
a922 2
#define EVP_R_AES_KEY_SETUP_FAILED			 143
#define EVP_R_ASN1_LIB					 140
a927 1
#define EVP_R_CAMELLIA_KEY_SETUP_FAILED			 157
d934 1
a939 2
#define EVP_R_EXPECTING_A_ECDSA_KEY			 141
#define EVP_R_EXPECTING_A_EC_KEY			 142
a963 1
#define EVP_R_SEED_KEY_SETUP_FAILED			 162
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a77 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a252 6
typedef struct
	{
	EVP_MD_CTX *mctx;
	void *key;
	} EVP_MD_SVCTX;

a255 4
#define EVP_MD_FLAG_FIPS	0x0400 /* Note if suitable for use in FIPS mode */

#define EVP_MD_FLAG_SVCTX	0x0800 /* pass EVP_MD_SVCTX to sign/verify */

a305 11
#define EVP_MD_CTX_FLAG_NON_FIPS_ALLOW	0x0008	/* Allow use of non FIPS digest
						 * in FIPS mode */

#define EVP_MD_CTX_FLAG_PAD_MASK	0xF0	/* RSA mode to use */
#define EVP_MD_CTX_FLAG_PAD_PKCS1	0x00	/* PKCS#1 v1.5 mode */
#define EVP_MD_CTX_FLAG_PAD_X931	0x10	/* X9.31 mode */
#define EVP_MD_CTX_FLAG_PAD_PSS		0x20	/* PSS mode */
#define M_EVP_MD_CTX_FLAG_PSS_SALT(ctx) \
		((ctx->flags>>16) &0xFFFF) /* seed length */
#define EVP_MD_CTX_FLAG_PSS_MDLEN	0xFFFF	/* salt len same as digest */
#define EVP_MD_CTX_FLAG_PSS_MREC	0xFFFE	/* salt max or auto recovered */
a349 8
/* Note if suitable for use in FIPS mode */
#define		EVP_CIPH_FLAG_FIPS		0x400
/* Allow non FIPS cipher in FIPS mode */
#define		EVP_CIPH_FLAG_NON_FIPS_ALLOW	0x800
/* Allow use default ASN1 get/set iv */
#define		EVP_CIPH_FLAG_DEFAULT_ASN1	0x1000
/* Buffer length in bits not bytes: CFB1 mode only */
#define		EVP_CIPH_FLAG_LENGTH_BITS	0x2000
a431 12
/* Macros to reduce FIPS dependencies: do NOT use in applications */
#define M_EVP_MD_size(e)		((e)->md_size)
#define M_EVP_MD_block_size(e)		((e)->block_size)
#define M_EVP_MD_CTX_set_flags(ctx,flgs) ((ctx)->flags|=(flgs))
#define M_EVP_MD_CTX_clear_flags(ctx,flgs) ((ctx)->flags&=~(flgs))
#define M_EVP_MD_CTX_test_flags(ctx,flgs) ((ctx)->flags&(flgs))
#define M_EVP_MD_type(e)			((e)->type)
#define M_EVP_MD_CTX_type(e)		M_EVP_MD_type(M_EVP_MD_CTX_md(e))
#define M_EVP_MD_CTX_md(e)			((e)->digest)

#define M_EVP_CIPHER_CTX_set_flags(ctx,flgs) ((ctx)->flags|=(flgs))

a526 4
void	EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags);
void	EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags);
int 	EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx,int flags);

a881 18
#ifdef OPENSSL_FIPS
#ifndef OPENSSL_NO_ENGINE
void int_EVP_MD_set_engine_callbacks(
	int (*eng_md_init)(ENGINE *impl),
	int (*eng_md_fin)(ENGINE *impl),
	int (*eng_md_evp)
		(EVP_MD_CTX *ctx, const EVP_MD **ptype, ENGINE *impl));
void int_EVP_MD_init_engine_callbacks(void);
void int_EVP_CIPHER_set_engine_callbacks(
	int (*eng_ciph_fin)(ENGINE *impl),
	int (*eng_ciph_evp)
		(EVP_CIPHER_CTX *ctx, const EVP_CIPHER **pciph, ENGINE *impl));
void int_EVP_CIPHER_init_engine_callbacks(void);
#endif
#endif

void EVP_add_alg_module(void);

a891 1
#define EVP_F_ALG_MODULE_INIT				 138
a893 4
#define EVP_F_DO_EVP_ENC_ENGINE				 140
#define EVP_F_DO_EVP_ENC_ENGINE_FULL			 141
#define EVP_F_DO_EVP_MD_ENGINE				 139
#define EVP_F_DO_EVP_MD_ENGINE_FULL			 142
a897 1
#define EVP_F_EVP_CIPHERINIT				 137
a901 1
#define EVP_F_EVP_DIGESTINIT				 136
a942 1
#define EVP_R_DISABLED_FOR_FIPS				 144
a943 2
#define EVP_R_ERROR_LOADING_SECTION			 145
#define EVP_R_ERROR_SETTING_FIPS_MODE			 146
a949 1
#define EVP_R_FIPS_MODE_NOT_SUPPORTED			 147
a951 1
#define EVP_R_INVALID_FIPS_MODE				 148
a962 1
#define EVP_R_UNKNOWN_OPTION				 149
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d78 4
a121 1
#define EVP_PKEY_HMAC	NID_hmac
a134 2
	const EVP_PKEY_ASN1_METHOD *ameth;
	ENGINE *engine;
d159 67
a247 2
	/* control function */
	int (*md_ctrl)(EVP_MD_CTX *ctx, int cmd, int p1, void *p2);
d257 6
d266 1
a266 26
#define EVP_MD_FLAG_PKEY_DIGEST	0x0002 /* digest is a "clone" digest used
					* which is a copy of an existing
					* one for a specific public key type.
					* EVP_dss1() etc */

/* Digest uses EVP_PKEY_METHOD for signing instead of MD specific signing */

#define EVP_MD_FLAG_PKEY_METHOD_SIGNATURE	0x0004

/* DigestAlgorithmIdentifier flags... */

#define EVP_MD_FLAG_DIGALGID_MASK		0x0018

/* NULL or absent parameter accepted. Use NULL */

#define EVP_MD_FLAG_DIGALGID_NULL		0x0000

/* NULL or absent parameter accepted. Use NULL for PKCS#1 otherwise absent */

#define EVP_MD_FLAG_DIGALGID_ABSENT		0x0008

/* Custom handling via ctrl */

#define EVP_MD_FLAG_DIGALGID_CUSTOM		0x0018

/* Digest ctrls */
d268 1
a268 6
#define	EVP_MD_CTRL_DIGALGID			0x1
#define	EVP_MD_CTRL_MICALG			0x2

/* Minimum Algorithm specific ctrl value */

#define	EVP_MD_CTRL_ALG_CTRL			0x1000
a309 4
	/* Public key context for sign/verify */
	EVP_PKEY_CTX *pctx;
	/* Update function: usually copied from EVP_MD */
	int (*update)(EVP_MD_CTX *ctx,const void *data,size_t count);
a319 4
/* FIPS and pad options are ignored in 1.0.0, definitions are here
 * so we don't accidentally reuse the values for other purposes.
 */

a322 4
/* The following PAD options are also currently ignored in 1.0.0, digest
 * parameters are handled through EVP_DigestSign*() and EVP_DigestVerify*()
 * instead.
 */
d327 4
a330 2

#define EVP_MD_CTX_FLAG_NO_INIT		0x0100 /* Don't initialize md_data */
d342 1
a342 1
			 const unsigned char *in, size_t inl);/* encrypt/decrypt data */
d360 1
a360 1
#define 	EVP_CIPH_MODE			0xF0007
d375 4
a378 2
/* cipher has its own additional copying logic */
#define 	EVP_CIPH_CUSTOM_COPY		0x400
a392 2
#define 	EVP_CTRL_PBE_PRF_NID		0x7
#define 	EVP_CTRL_COPY			0x8
d465 12
a482 1
unsigned long EVP_MD_flags(const EVP_MD *md);
d484 1
a484 1
const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);
a501 1
int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in);
a518 2
#define EVP_DigestSignUpdate(a,b,c)	EVP_DigestUpdate(a,b,c)
#define EVP_DigestVerifyUpdate(a,b,c)	EVP_DigestUpdate(a,b,c)
a564 1
int	EVP_read_pw_string_min(char *buf,int minlen,int maxlen,const char *prompt,int verify);
a610 10
int	EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
			const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int	EVP_DigestSignFinal(EVP_MD_CTX *ctx,
			unsigned char *sigret, size_t *siglen);

int	EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
			const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
int	EVP_DigestVerifyFinal(EVP_MD_CTX *ctx,
			unsigned char *sig, size_t siglen);

a682 3
#ifndef OPENSSL_NO_WHIRLPOOL
const EVP_MD *EVP_whirlpool(void);
#endif
d850 1
a850 11
void EVP_CIPHER_do_all(void (*fn)(const EVP_CIPHER *ciph,
		const char *from, const char *to, void *x), void *arg);
void EVP_CIPHER_do_all_sorted(void (*fn)(const EVP_CIPHER *ciph,
		const char *from, const char *to, void *x), void *arg);

void EVP_MD_do_all(void (*fn)(const EVP_MD *ciph,
		const char *from, const char *to, void *x), void *arg);
void EVP_MD_do_all_sorted(void (*fn)(const EVP_MD *ciph,
		const char *from, const char *to, void *x), void *arg);

int		EVP_PKEY_decrypt_old(unsigned char *dec_key,
d853 1
a853 1
int		EVP_PKEY_encrypt_old(unsigned char *enc_key,
a856 2
int		EVP_PKEY_id(const EVP_PKEY *pkey);
int		EVP_PKEY_base_id(const EVP_PKEY *pkey);
d859 1
a859 4
int 		EVP_PKEY_set_type(EVP_PKEY *pkey,int type);
int		EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len);
int 		EVP_PKEY_assign(EVP_PKEY *pkey,int type,void *key);
void *		EVP_PKEY_get0(EVP_PKEY *pkey);
a901 9
int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx);
int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx);
int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx);

int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);

a918 4
int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
			   const unsigned char *salt, int saltlen, int iter,
			   const EVP_MD *digest,
		      int keylen, unsigned char *out);
a926 10

/* PBE type */

/* Can appear as the outermost AlgorithmIdentifier */
#define EVP_PBE_TYPE_OUTER	0x0
/* Is an PRF type OID */
#define EVP_PBE_TYPE_PRF	0x1

int EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid, int md_nid,
	     EVP_PBE_KEYGEN *keygen);
a928 2
int EVP_PBE_find(int type, int pbe_nid,
			int *pcnid, int *pmnid, EVP_PBE_KEYGEN **pkeygen);
d931 17
a947 238
#define ASN1_PKEY_ALIAS		0x1
#define ASN1_PKEY_DYNAMIC	0x2
#define ASN1_PKEY_SIGPARAM_NULL	0x4

#define ASN1_PKEY_CTRL_PKCS7_SIGN	0x1
#define ASN1_PKEY_CTRL_PKCS7_ENCRYPT	0x2
#define ASN1_PKEY_CTRL_DEFAULT_MD_NID	0x3
#define ASN1_PKEY_CTRL_CMS_SIGN		0x5
#define ASN1_PKEY_CTRL_CMS_ENVELOPE	0x7

int EVP_PKEY_asn1_get_count(void);
const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx);
const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type);
const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe,
					const char *str, int len);
int EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth);
int EVP_PKEY_asn1_add_alias(int to, int from);
int EVP_PKEY_asn1_get0_info(int *ppkey_id, int *pkey_base_id, int *ppkey_flags,
				const char **pinfo, const char **ppem_str,
					const EVP_PKEY_ASN1_METHOD *ameth);

const EVP_PKEY_ASN1_METHOD* EVP_PKEY_get0_asn1(EVP_PKEY *pkey);
EVP_PKEY_ASN1_METHOD* EVP_PKEY_asn1_new(int id, int flags,
					const char *pem_str, const char *info);
void EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst, 
			const EVP_PKEY_ASN1_METHOD *src);
void EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth);
void EVP_PKEY_asn1_set_public(EVP_PKEY_ASN1_METHOD *ameth,
		int (*pub_decode)(EVP_PKEY *pk, X509_PUBKEY *pub),
		int (*pub_encode)(X509_PUBKEY *pub, const EVP_PKEY *pk),
		int (*pub_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
		int (*pub_print)(BIO *out, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *pctx),
		int (*pkey_size)(const EVP_PKEY *pk),
		int (*pkey_bits)(const EVP_PKEY *pk));
void EVP_PKEY_asn1_set_private(EVP_PKEY_ASN1_METHOD *ameth,
		int (*priv_decode)(EVP_PKEY *pk, PKCS8_PRIV_KEY_INFO *p8inf),
		int (*priv_encode)(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pk),
		int (*priv_print)(BIO *out, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *pctx));
void EVP_PKEY_asn1_set_param(EVP_PKEY_ASN1_METHOD *ameth,
		int (*param_decode)(EVP_PKEY *pkey,
				const unsigned char **pder, int derlen),
		int (*param_encode)(const EVP_PKEY *pkey, unsigned char **pder),
		int (*param_missing)(const EVP_PKEY *pk),
		int (*param_copy)(EVP_PKEY *to, const EVP_PKEY *from),
		int (*param_cmp)(const EVP_PKEY *a, const EVP_PKEY *b),
		int (*param_print)(BIO *out, const EVP_PKEY *pkey, int indent,
							ASN1_PCTX *pctx));

void EVP_PKEY_asn1_set_free(EVP_PKEY_ASN1_METHOD *ameth,
		void (*pkey_free)(EVP_PKEY *pkey));
void EVP_PKEY_asn1_set_ctrl(EVP_PKEY_ASN1_METHOD *ameth,
		int (*pkey_ctrl)(EVP_PKEY *pkey, int op,
							long arg1, void *arg2));


#define EVP_PKEY_OP_UNDEFINED		0
#define EVP_PKEY_OP_PARAMGEN		(1<<1)
#define EVP_PKEY_OP_KEYGEN		(1<<2)
#define EVP_PKEY_OP_SIGN		(1<<3)
#define EVP_PKEY_OP_VERIFY		(1<<4)
#define EVP_PKEY_OP_VERIFYRECOVER	(1<<5)
#define EVP_PKEY_OP_SIGNCTX		(1<<6)
#define EVP_PKEY_OP_VERIFYCTX		(1<<7)
#define EVP_PKEY_OP_ENCRYPT		(1<<8)
#define EVP_PKEY_OP_DECRYPT		(1<<9)
#define EVP_PKEY_OP_DERIVE		(1<<10)

#define EVP_PKEY_OP_TYPE_SIG	\
	(EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY | EVP_PKEY_OP_VERIFYRECOVER \
		| EVP_PKEY_OP_SIGNCTX | EVP_PKEY_OP_VERIFYCTX)

#define EVP_PKEY_OP_TYPE_CRYPT \
	(EVP_PKEY_OP_ENCRYPT | EVP_PKEY_OP_DECRYPT)

#define EVP_PKEY_OP_TYPE_NOGEN \
	(EVP_PKEY_OP_SIG | EVP_PKEY_OP_CRYPT | EVP_PKEY_OP_DERIVE)

#define EVP_PKEY_OP_TYPE_GEN \
		(EVP_PKEY_OP_PARAMGEN | EVP_PKEY_OP_KEYGEN)

#define	 EVP_PKEY_CTX_set_signature_md(ctx, md)	\
		EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_TYPE_SIG,  \
					EVP_PKEY_CTRL_MD, 0, (void *)md)

#define EVP_PKEY_CTRL_MD		1
#define EVP_PKEY_CTRL_PEER_KEY		2

#define EVP_PKEY_CTRL_PKCS7_ENCRYPT	3
#define EVP_PKEY_CTRL_PKCS7_DECRYPT	4

#define EVP_PKEY_CTRL_PKCS7_SIGN	5

#define EVP_PKEY_CTRL_SET_MAC_KEY	6

#define EVP_PKEY_CTRL_DIGESTINIT	7

/* Used by GOST key encryption in TLS */
#define EVP_PKEY_CTRL_SET_IV 		8

#define EVP_PKEY_CTRL_CMS_ENCRYPT	9
#define EVP_PKEY_CTRL_CMS_DECRYPT	10
#define EVP_PKEY_CTRL_CMS_SIGN		11

#define EVP_PKEY_ALG_CTRL		0x1000


#define EVP_PKEY_FLAG_AUTOARGLEN	2

const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type);
EVP_PKEY_METHOD* EVP_PKEY_meth_new(int id, int flags);
void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth);
int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth);

EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);
EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);
EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);
void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);

int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
				int cmd, int p1, void *p2);
int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
						const char *value);

int EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx);
void EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen);

EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,
				unsigned char *key, int keylen);

void EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data);
void *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx);
EVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx);

EVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx);

void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);
void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);

int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
			unsigned char *sig, size_t *siglen,
			const unsigned char *tbs, size_t tbslen);
int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
			const unsigned char *sig, size_t siglen,
			const unsigned char *tbs, size_t tbslen);
int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
			unsigned char *rout, size_t *routlen,
			const unsigned char *sig, size_t siglen);
int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,
			unsigned char *out, size_t *outlen,
			const unsigned char *in, size_t inlen);
int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,
			unsigned char *out, size_t *outlen,
			const unsigned char *in, size_t inlen);

int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);
int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);

typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);

int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);

void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);
EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);

int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);

void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,
	int (*init)(EVP_PKEY_CTX *ctx));

void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,
	int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src));

void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,
	void (*cleanup)(EVP_PKEY_CTX *ctx));

void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,
	int (*paramgen_init)(EVP_PKEY_CTX *ctx),
	int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));

void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,
	int (*keygen_init)(EVP_PKEY_CTX *ctx),
	int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey));

void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,
	int (*sign_init)(EVP_PKEY_CTX *ctx),
	int (*sign)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
					const unsigned char *tbs, size_t tbslen));

void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,
	int (*verify_init)(EVP_PKEY_CTX *ctx),
	int (*verify)(EVP_PKEY_CTX *ctx, const unsigned char *sig, size_t siglen,
					const unsigned char *tbs, size_t tbslen));

void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,
	int (*verify_recover_init)(EVP_PKEY_CTX *ctx),
	int (*verify_recover)(EVP_PKEY_CTX *ctx,
					unsigned char *sig, size_t *siglen,
					const unsigned char *tbs, size_t tbslen));

void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,
	int (*signctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
	int (*signctx)(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
					EVP_MD_CTX *mctx));

void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,
	int (*verifyctx_init)(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx),
	int (*verifyctx)(EVP_PKEY_CTX *ctx, const unsigned char *sig,int siglen,
					EVP_MD_CTX *mctx));

void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,
	int (*encrypt_init)(EVP_PKEY_CTX *ctx),
	int (*encryptfn)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
					const unsigned char *in, size_t inlen));

void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,
	int (*decrypt_init)(EVP_PKEY_CTX *ctx),
	int (*decrypt)(EVP_PKEY_CTX *ctx, unsigned char *out, size_t *outlen,
					const unsigned char *in, size_t inlen));

void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,
	int (*derive_init)(EVP_PKEY_CTX *ctx),
	int (*derive)(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen));

void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,
	int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2),
	int (*ctrl_str)(EVP_PKEY_CTX *ctx,
					const char *type, const char *value));
d959 1
d962 4
a965 1
#define EVP_F_DO_SIGVER_INIT				 161
d970 1
a971 1
#define EVP_F_EVP_CIPHER_CTX_COPY			 163
d975 1
a978 1
#define EVP_F_EVP_MD_SIZE				 162
a980 1
#define EVP_F_EVP_PBE_ALG_ADD_TYPE			 160
a982 1
#define EVP_F_EVP_PKCS82PKEY_BROKEN			 136
a984 3
#define EVP_F_EVP_PKEY_CTX_CTRL				 137
#define EVP_F_EVP_PKEY_CTX_CTRL_STR			 150
#define EVP_F_EVP_PKEY_CTX_DUP				 156
a985 5
#define EVP_F_EVP_PKEY_DECRYPT_INIT			 138
#define EVP_F_EVP_PKEY_DECRYPT_OLD			 151
#define EVP_F_EVP_PKEY_DERIVE				 153
#define EVP_F_EVP_PKEY_DERIVE_INIT			 154
#define EVP_F_EVP_PKEY_DERIVE_SET_PEER			 155
a986 2
#define EVP_F_EVP_PKEY_ENCRYPT_INIT			 139
#define EVP_F_EVP_PKEY_ENCRYPT_OLD			 152
a991 2
#define EVP_F_EVP_PKEY_KEYGEN				 146
#define EVP_F_EVP_PKEY_KEYGEN_INIT			 147
a992 8
#define EVP_F_EVP_PKEY_PARAMGEN				 148
#define EVP_F_EVP_PKEY_PARAMGEN_INIT			 149
#define EVP_F_EVP_PKEY_SIGN				 140
#define EVP_F_EVP_PKEY_SIGN_INIT			 141
#define EVP_F_EVP_PKEY_VERIFY				 142
#define EVP_F_EVP_PKEY_VERIFY_INIT			 143
#define EVP_F_EVP_PKEY_VERIFY_RECOVER			 144
#define EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT		 145
a995 1
#define EVP_F_INT_CTX_NEW				 157
a998 1
#define EVP_F_PKEY_SET_TYPE				 158
a1009 1
#define EVP_R_BUFFER_TOO_SMALL				 155
a1011 1
#define EVP_R_COMMAND_NOT_SUPPORTED			 147
d1017 1
a1017 1
#define EVP_R_DIFFERENT_PARAMETERS			 153
d1019 2
d1027 1
d1030 1
a1030 1
#define EVP_R_INVALID_DIGEST				 152
a1031 1
#define EVP_R_INVALID_OPERATION				 148
a1033 2
#define EVP_R_MESSAGE_DIGEST_IS_NULL			 159
#define EVP_R_METHOD_NOT_SUPPORTED			 144
a1035 1
#define EVP_R_NO_DEFAULT_DIGEST				 158
a1037 2
#define EVP_R_NO_KEY_SET				 154
#define EVP_R_NO_OPERATION_SET				 149
a1039 2
#define EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE	 150
#define EVP_R_OPERATON_NOT_INITIALIZED			 151
a1040 2
#define EVP_R_PRIVATE_KEY_DECODE_ERROR			 145
#define EVP_R_PRIVATE_KEY_ENCODE_ERROR			 146
d1042 1
a1042 2
#define EVP_R_UNKNOWN_CIPHER				 160
#define EVP_R_UNKNOWN_DIGEST				 161
a1044 1
#define EVP_R_UNSUPPORTED_ALGORITHM			 156
d1054 1
@


1.1.1.10
log
@import OpenSSL-1.0.1c
@
text
@d86 1
a86 1
#define EVP_MAX_KEY_LENGTH		64
a118 1
#define EVP_PKEY_CMAC	NID_cmac
a218 2
#define EVP_MD_FLAG_FIPS	0x0400 /* Note if suitable for use in FIPS mode */

a327 4
#define		EVP_CIPH_CTR_MODE		0x5
#define		EVP_CIPH_GCM_MODE		0x6
#define		EVP_CIPH_CCM_MODE		0x7
#define		EVP_CIPH_XTS_MODE		0x10001
a348 9
/* Note if suitable for use in FIPS mode */
#define		EVP_CIPH_FLAG_FIPS		0x4000
/* Allow non FIPS cipher in FIPS mode */
#define		EVP_CIPH_FLAG_NON_FIPS_ALLOW	0x8000
/* Cipher handles any and all padding logic as well
 * as finalisation.
 */
#define 	EVP_CIPH_FLAG_CUSTOM_CIPHER	0x100000
#define		EVP_CIPH_FLAG_AEAD_CIPHER	0x200000
a360 28
#define 	EVP_CTRL_GCM_SET_IVLEN		0x9
#define 	EVP_CTRL_GCM_GET_TAG		0x10
#define 	EVP_CTRL_GCM_SET_TAG		0x11
#define		EVP_CTRL_GCM_SET_IV_FIXED	0x12
#define		EVP_CTRL_GCM_IV_GEN		0x13
#define		EVP_CTRL_CCM_SET_IVLEN		EVP_CTRL_GCM_SET_IVLEN
#define		EVP_CTRL_CCM_GET_TAG		EVP_CTRL_GCM_GET_TAG
#define		EVP_CTRL_CCM_SET_TAG		EVP_CTRL_GCM_SET_TAG
#define		EVP_CTRL_CCM_SET_L		0x14
#define		EVP_CTRL_CCM_SET_MSGLEN		0x15
/* AEAD cipher deduces payload length and returns number of bytes
 * required to store MAC and eventual padding. Subsequent call to
 * EVP_Cipher even appends/verifies MAC.
 */
#define		EVP_CTRL_AEAD_TLS1_AAD		0x16
/* Used by composite AEAD ciphers, no-op in GCM, CCM... */
#define		EVP_CTRL_AEAD_SET_MAC_KEY	0x17
/* Set the GCM invocation field, decrypt only */
#define		EVP_CTRL_GCM_SET_IV_INV		0x18

/* GCM TLS constants */
/* Length of fixed part of IV derived from PRF */
#define EVP_GCM_TLS_FIXED_IV_LEN			4
/* Length of explicit part of IV part of TLS records */
#define EVP_GCM_TLS_EXPLICIT_IV_LEN			8
/* Length of tag for TLS */
#define EVP_GCM_TLS_TAG_LEN				16

d378 1
a378 1
	int num;				/* used by cfb/ofb/ctr mode */
a697 3
#ifndef OPENSSL_NO_MD5
const EVP_CIPHER *EVP_rc4_hmac_md5(void);
#endif
d744 1
d746 1
a746 3
const EVP_CIPHER *EVP_aes_128_gcm(void);
const EVP_CIPHER *EVP_aes_128_ccm(void);
const EVP_CIPHER *EVP_aes_128_xts(void);
d754 1
d756 1
a756 2
const EVP_CIPHER *EVP_aes_192_gcm(void);
const EVP_CIPHER *EVP_aes_192_ccm(void);
d764 1
a765 6
const EVP_CIPHER *EVP_aes_256_gcm(void);
const EVP_CIPHER *EVP_aes_256_ccm(void);
const EVP_CIPHER *EVP_aes_256_xts(void);
#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void);
const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void);
a1049 2
#define EVP_PKEY_CTRL_CIPHER		12

a1053 4
/* Method handles all operations: don't assume any digest related
 * defaults.
 */
#define EVP_PKEY_FLAG_SIGCTX_CUSTOM	4
a1056 3
void EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,
				const EVP_PKEY_METHOD *meth);
void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src);
d1074 1
a1074 1
				const unsigned char *key, int keylen);
a1192 2
#define EVP_F_AESNI_INIT_KEY				 165
#define EVP_F_AESNI_XTS_CIPHER				 176
a1193 2
#define EVP_F_AES_XTS					 172
#define EVP_F_AES_XTS_CIPHER				 175
a1194 1
#define EVP_F_CMAC_INIT					 173
a1248 7
#define EVP_F_FIPS_CIPHERINIT				 166
#define EVP_F_FIPS_CIPHER_CTX_COPY			 170
#define EVP_F_FIPS_CIPHER_CTX_CTRL			 167
#define EVP_F_FIPS_CIPHER_CTX_SET_KEY_LENGTH		 171
#define EVP_F_FIPS_DIGESTINIT				 168
#define EVP_F_FIPS_MD_CTX_COPY				 169
#define EVP_F_HMAC_INIT_EX				 174
a1251 1
#define EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN			 164
a1257 1
#define EVP_R_AES_IV_SETUP_FAILED			 162
a1274 1
#define EVP_R_DISABLED_FOR_FIPS				 163
a1305 1
#define EVP_R_TOO_LARGE					 164
@


1.1.1.11
log
@Import OpenSSL 1.0.1g
@
text
@d405 1
d792 1
a793 1
const EVP_CIPHER *EVP_aes_128_gcm(void);
d803 1
a804 1
const EVP_CIPHER *EVP_aes_192_gcm(void);
d813 1
a814 1
const EVP_CIPHER *EVP_aes_256_gcm(void);
a1245 2
void EVP_add_alg_module(void);

a1259 1
#define EVP_F_ALG_MODULE_INIT				 177
a1352 2
#define EVP_R_ERROR_LOADING_SECTION			 165
#define EVP_R_ERROR_SETTING_FIPS_MODE			 166
a1358 1
#define EVP_R_FIPS_MODE_NOT_SUPPORTED			 167
a1361 1
#define EVP_R_INVALID_FIPS_MODE				 168
a1385 1
#define EVP_R_UNKNOWN_OPTION				 169
@


