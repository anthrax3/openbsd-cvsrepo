head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.2
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19;
locks; strict;
comment	@ * @;


1.19
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.18;
commitid	kT0fLt3r4lroFJra;

1.18
date	2014.10.18.17.20.40;	author jsing;	state Exp;
branches;
next	1.17;
commitid	8tb4v3IC8S2vzfHj;

1.17
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.16;
commitid	G74O1dmRukKsW7IJ;

1.16
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.15;
commitid	yQEL1wOWIearrW15;

1.15
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	mJUVYpkFBZ0Zv2bG;

1.14
date	2014.05.08.15.42.26;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.12.14.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.22;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.03.15.12.45;	author ho;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.46;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.39;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.10.20;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.15;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.28;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.20.41.43;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.10;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.44;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.13.56;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.07;	author djm;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: evp_pkey.c,v 1.18 2014/10/18 17:20:40 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999.
 */
/* ====================================================================
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <stdlib.h>

#include <openssl/err.h>
#include <openssl/x509.h>

#include "asn1_locl.h"

/* Extract a private key from a PKCS8 structure */

EVP_PKEY *
EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)
{
	EVP_PKEY *pkey = NULL;
	ASN1_OBJECT *algoid;
	char obj_tmp[80];

	if (!PKCS8_pkey_get0(&algoid, NULL, NULL, NULL, p8))
		return NULL;

	if (!(pkey = EVP_PKEY_new())) {
		EVPerror(ERR_R_MALLOC_FAILURE);
		return NULL;
	}

	if (!EVP_PKEY_set_type(pkey, OBJ_obj2nid(algoid))) {
		EVPerror(EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
		i2t_ASN1_OBJECT(obj_tmp, 80, algoid);
		ERR_asprintf_error_data("TYPE=%s", obj_tmp);
		goto error;
	}

	if (pkey->ameth->priv_decode) {
		if (!pkey->ameth->priv_decode(pkey, p8)) {
			EVPerror(EVP_R_PRIVATE_KEY_DECODE_ERROR);
			goto error;
		}
	} else {
		EVPerror(EVP_R_METHOD_NOT_SUPPORTED);
		goto error;
	}

	return pkey;

error:
	EVP_PKEY_free(pkey);
	return NULL;
}

PKCS8_PRIV_KEY_INFO *
EVP_PKEY2PKCS8(EVP_PKEY *pkey)
{
	return EVP_PKEY2PKCS8_broken(pkey, PKCS8_OK);
}

/* Turn a private key into a PKCS8 structure */

PKCS8_PRIV_KEY_INFO *
EVP_PKEY2PKCS8_broken(EVP_PKEY *pkey, int broken)
{
	PKCS8_PRIV_KEY_INFO *p8;

	if (!(p8 = PKCS8_PRIV_KEY_INFO_new())) {
		EVPerror(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	p8->broken = broken;

	if (pkey->ameth) {
		if (pkey->ameth->priv_encode) {
			if (!pkey->ameth->priv_encode(p8, pkey)) {
				EVPerror(EVP_R_PRIVATE_KEY_ENCODE_ERROR);
				goto error;
			}
		} else {
			EVPerror(EVP_R_METHOD_NOT_SUPPORTED);
			goto error;
		}
	} else {
		EVPerror(EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
		goto error;
	}
	return p8;

error:
	PKCS8_PRIV_KEY_INFO_free(p8);
	return NULL;
}

PKCS8_PRIV_KEY_INFO *
PKCS8_set_broken(PKCS8_PRIV_KEY_INFO *p8, int broken)
{
	switch (broken) {
	case PKCS8_OK:
		p8->broken = PKCS8_OK;
		return p8;
		break;

	case PKCS8_NO_OCTET:
		p8->broken = PKCS8_NO_OCTET;
		p8->pkey->type = V_ASN1_SEQUENCE;
		return p8;
		break;

	default:
		EVPerror(EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);
		return NULL;
	}
}

/* EVP_PKEY attribute functions */

int
EVP_PKEY_get_attr_count(const EVP_PKEY *key)
{
	return X509at_get_attr_count(key->attributes);
}

int
EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid, int lastpos)
{
	return X509at_get_attr_by_NID(key->attributes, nid, lastpos);
}

int
EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, ASN1_OBJECT *obj, int lastpos)
{
	return X509at_get_attr_by_OBJ(key->attributes, obj, lastpos);
}

X509_ATTRIBUTE *
EVP_PKEY_get_attr(const EVP_PKEY *key, int loc)
{
	return X509at_get_attr(key->attributes, loc);
}

X509_ATTRIBUTE *
EVP_PKEY_delete_attr(EVP_PKEY *key, int loc)
{
	return X509at_delete_attr(key->attributes, loc);
}

int
EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr)
{
	if (X509at_add1_attr(&key->attributes, attr))
		return 1;
	return 0;
}

int
EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key, const ASN1_OBJECT *obj, int type,
    const unsigned char *bytes, int len)
{
	if (X509at_add1_attr_by_OBJ(&key->attributes, obj, type, bytes, len))
		return 1;
	return 0;
}

int
EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key, int nid, int type,
    const unsigned char *bytes, int len)
{
	if (X509at_add1_attr_by_NID(&key->attributes, nid, type, bytes, len))
		return 1;
	return 0;
}

int
EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key, const char *attrname, int type,
    const unsigned char *bytes, int len)
{
	if (X509at_add1_attr_by_txt(&key->attributes, attrname, type,
	    bytes, len))
		return 1;
	return 0;
}
@


1.18
log
@None of these need to include <openssl/rand.h>
@
text
@d1 1
a1 1
/* $OpenBSD: evp_pkey.c,v 1.17 2014/07/12 16:03:37 miod Exp $ */
d80 1
a80 1
		EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_MALLOC_FAILURE);
d85 1
a85 2
		EVPerr(EVP_F_EVP_PKCS82PKEY,
		    EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
d93 1
a93 2
			EVPerr(EVP_F_EVP_PKCS82PKEY,
			    EVP_R_PRIVATE_KEY_DECODE_ERROR);
d97 1
a97 1
		EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_METHOD_NOT_SUPPORTED);
d122 1
a122 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN, ERR_R_MALLOC_FAILURE);
d130 1
a130 2
				EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,
				    EVP_R_PRIVATE_KEY_ENCODE_ERROR);
d134 1
a134 2
			EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,
			    EVP_R_METHOD_NOT_SUPPORTED);
d138 1
a138 2
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,
		    EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
d164 1
a164 1
		EVPerr(EVP_F_PKCS8_SET_BROKEN, EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);
@


1.17
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp_pkey.c,v 1.16 2014/07/11 08:44:48 jsing Exp $ */
a62 1
#include <openssl/rand.h>
@


1.16
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: evp_pkey.c,v 1.15 2014/06/12 15:49:29 deraadt Exp $ */
d107 1
a107 1
	EVP_PKEY_free (pkey);
@


1.15
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d61 3
a63 1
#include "cryptlib.h"
d65 1
a65 1
#include <openssl/rand.h>
@


1.14
log
@KNF.
@
text
@d1 1
a1 1
/* evp_pkey.c */
@


1.13
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d68 2
a69 1
EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)
d79 1
a79 1
		EVPerr(EVP_F_EVP_PKCS82PKEY,ERR_R_MALLOC_FAILURE);
d83 3
a85 3
	if (!EVP_PKEY_set_type(pkey, OBJ_obj2nid(algoid)))
		{
		EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
d89 1
a89 1
		}
d91 2
a92 4
	if (pkey->ameth->priv_decode)
		{
		if (!pkey->ameth->priv_decode(pkey, p8))
			{
d94 1
a94 1
					EVP_R_PRIVATE_KEY_DECODE_ERROR);
a95 1
			}
d97 1
a97 2
	else
		{
d100 1
a100 1
		}
d104 1
a104 1
	error:
d109 2
a110 1
PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey)
d117 2
a118 1
PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8_broken(EVP_PKEY *pkey, int broken)
d122 2
a123 2
	if (!(p8 = PKCS8_PRIV_KEY_INFO_new())) {	
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);
d128 3
a130 6
	if (pkey->ameth)
		{
		if (pkey->ameth->priv_encode)
			{
			if (!pkey->ameth->priv_encode(p8, pkey))
				{
d132 1
a132 1
					EVP_R_PRIVATE_KEY_ENCODE_ERROR);
a133 1
				}
d135 1
a135 2
		else
			{
d137 1
a137 1
					EVP_R_METHOD_NOT_SUPPORTED);
a138 1
			}
d140 1
a140 2
	else
		{
d142 1
a142 1
				EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
d144 1
a144 1
		}
d146 2
a147 1
	error:
d152 2
a153 1
PKCS8_PRIV_KEY_INFO *PKCS8_set_broken(PKCS8_PRIV_KEY_INFO *p8, int broken)
d156 1
a156 2

		case PKCS8_OK:
d161 1
a161 1
		case PKCS8_NO_OCTET:
d167 2
a168 2
		default:
		EVPerr(EVP_F_PKCS8_SET_BROKEN,EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);
d175 2
a176 1
int EVP_PKEY_get_attr_count(const EVP_PKEY *key)
d181 2
a182 2
int EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid,
			  int lastpos)
d187 2
a188 2
int EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, ASN1_OBJECT *obj,
			  int lastpos)
d193 2
a194 1
X509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *key, int loc)
d199 2
a200 1
X509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *key, int loc)
d205 2
a206 1
int EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr)
d208 2
a209 1
	if(X509at_add1_attr(&key->attributes, attr)) return 1;
d213 3
a215 3
int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key,
			const ASN1_OBJECT *obj, int type,
			const unsigned char *bytes, int len)
d217 2
a218 2
	if(X509at_add1_attr_by_OBJ(&key->attributes, obj,
				type, bytes, len)) return 1;
d222 3
a224 3
int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key,
			int nid, int type,
			const unsigned char *bytes, int len)
d226 2
a227 2
	if(X509at_add1_attr_by_NID(&key->attributes, nid,
				type, bytes, len)) return 1;
d231 7
a237 6
int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key,
			const char *attrname, int type,
			const unsigned char *bytes, int len)
{
	if(X509at_add1_attr_by_txt(&key->attributes, attrname,
				type, bytes, len)) return 1;
@


1.12
log
@Do not feed RSA private key information to the random subsystem as
entropy.  It might be fed to a pluggable random subsystem....

What were they thinking?!

ok guenther
@
text
@d86 1
a86 1
		ERR_add_error_data(2, "TYPE=", obj_tmp);
@


1.11
log
@resolve conflicts, fix local changes
@
text
@a152 2
	RAND_add(p8->pkey->value.octet_string->data,
		 p8->pkey->value.octet_string->length, 0.0);
@


1.10
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
d64 1
a64 14
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
#include <openssl/bn.h>

#ifndef OPENSSL_NO_DSA
static int dsa_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8inf, EVP_PKEY *pkey);
#endif
#ifndef OPENSSL_NO_EC
static int eckey_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8inf, EVP_PKEY *pkey);
#endif
d71 1
a71 23
#ifndef OPENSSL_NO_RSA
	RSA *rsa = NULL;
#endif
#ifndef OPENSSL_NO_DSA
	DSA *dsa = NULL;
	ASN1_TYPE *t1, *t2;
	ASN1_INTEGER *privkey;
	STACK_OF(ASN1_TYPE) *ndsa = NULL;
#endif
#ifndef OPENSSL_NO_EC
	EC_KEY *eckey = NULL;
	const unsigned char *p_tmp;
#endif
#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_EC)
	ASN1_TYPE    *param = NULL;	
	BN_CTX *ctx = NULL;
	int plen;
#endif
	X509_ALGOR *a;
	const unsigned char *p;
	const unsigned char *cp;
	int pkeylen;
	int  nid;
d74 3
a76 9
	if(p8->pkey->type == V_ASN1_OCTET_STRING) {
		p8->broken = PKCS8_OK;
		p = p8->pkey->value.octet_string->data;
		pkeylen = p8->pkey->value.octet_string->length;
	} else {
		p8->broken = PKCS8_NO_OCTET;
		p = p8->pkey->value.sequence->data;
		pkeylen = p8->pkey->value.sequence->length;
	}
a80 113
	a = p8->pkeyalg;
	nid = OBJ_obj2nid(a->algorithm);
	switch(nid)
	{
#ifndef OPENSSL_NO_RSA
		case NID_rsaEncryption:
		cp = p;
		if (!(rsa = d2i_RSAPrivateKey (NULL,&cp, pkeylen))) {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			return NULL;
		}
		EVP_PKEY_assign_RSA (pkey, rsa);
		break;
#endif
#ifndef OPENSSL_NO_DSA
		case NID_dsa:
		/* PKCS#8 DSA is weird: you just get a private key integer
	         * and parameters in the AlgorithmIdentifier the pubkey must
		 * be recalculated.
		 */
	
		/* Check for broken DSA PKCS#8, UGH! */
		if(*p == (V_ASN1_SEQUENCE|V_ASN1_CONSTRUCTED)) {
		    if(!(ndsa = ASN1_seq_unpack_ASN1_TYPE(p, pkeylen, 
							  d2i_ASN1_TYPE,
							  ASN1_TYPE_free))) {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto dsaerr;
		    }
		    if(sk_ASN1_TYPE_num(ndsa) != 2 ) {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto dsaerr;
		    }
		    /* Handle Two broken types:
		     * SEQUENCE {parameters, priv_key}
		     * SEQUENCE {pub_key, priv_key}
		     */

		    t1 = sk_ASN1_TYPE_value(ndsa, 0);
		    t2 = sk_ASN1_TYPE_value(ndsa, 1);
		    if(t1->type == V_ASN1_SEQUENCE) {
			p8->broken = PKCS8_EMBEDDED_PARAM;
			param = t1;
		    } else if(a->parameter->type == V_ASN1_SEQUENCE) {
			p8->broken = PKCS8_NS_DB;
			param = a->parameter;
		    } else {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto dsaerr;
		    }

		    if(t2->type != V_ASN1_INTEGER) {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto dsaerr;
		    }
		    privkey = t2->value.integer;
		} else {
			if (!(privkey=d2i_ASN1_INTEGER (NULL, &p, pkeylen))) {
				EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
				goto dsaerr;
			}
			param = p8->pkeyalg->parameter;
		}
		if (!param || (param->type != V_ASN1_SEQUENCE)) {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto dsaerr;
		}
		cp = p = param->value.sequence->data;
		plen = param->value.sequence->length;
		if (!(dsa = d2i_DSAparams (NULL, &cp, plen))) {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto dsaerr;
		}
		/* We have parameters now set private key */
		if (!(dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL))) {
			EVPerr(EVP_F_EVP_PKCS82PKEY,EVP_R_BN_DECODE_ERROR);
			goto dsaerr;
		}
		/* Calculate public key (ouch!) */
		if (!(dsa->pub_key = BN_new())) {
			EVPerr(EVP_F_EVP_PKCS82PKEY,ERR_R_MALLOC_FAILURE);
			goto dsaerr;
		}
		if (!(ctx = BN_CTX_new())) {
			EVPerr(EVP_F_EVP_PKCS82PKEY,ERR_R_MALLOC_FAILURE);
			goto dsaerr;
		}
			
		if (!BN_mod_exp(dsa->pub_key, dsa->g,
						 dsa->priv_key, dsa->p, ctx)) {
			
			EVPerr(EVP_F_EVP_PKCS82PKEY,EVP_R_BN_PUBKEY_ERROR);
			goto dsaerr;
		}

		EVP_PKEY_assign_DSA(pkey, dsa);
		BN_CTX_free (ctx);
		if(ndsa) sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
		else ASN1_INTEGER_free(privkey);
		break;
		dsaerr:
		BN_CTX_free (ctx);
		sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
		DSA_free(dsa);
		EVP_PKEY_free(pkey);
		return NULL;
		break;
#endif
#ifndef OPENSSL_NO_EC
		case NID_X9_62_id_ecPublicKey:
		p_tmp = p;
		/* extract the ec parameters */
		param = p8->pkeyalg->parameter;
d82 1
a82 2
		if (!param || ((param->type != V_ASN1_SEQUENCE) &&
		    (param->type != V_ASN1_OBJECT)))
d84 4
a87 2
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto ecerr;
d90 1
a90 1
		if (param->type == V_ASN1_SEQUENCE)
d92 1
a92 4
			cp = p = param->value.sequence->data;
			plen = param->value.sequence->length;

			if (!(eckey = d2i_ECParameters(NULL, &cp, plen)))
d94 3
a96 3
				EVPerr(EVP_F_EVP_PKCS82PKEY,
					EVP_R_DECODE_ERROR);
				goto ecerr;
d99 1
a99 1
		else
d101 2
a102 20
			EC_GROUP *group;
			cp = p = param->value.object->data;
			plen = param->value.object->length;

			/* type == V_ASN1_OBJECT => the parameters are given
			 * by an asn1 OID
			 */
			if ((eckey = EC_KEY_new()) == NULL)
			{
				EVPerr(EVP_F_EVP_PKCS82PKEY,
					ERR_R_MALLOC_FAILURE);
				goto ecerr;
			}
			group = EC_GROUP_new_by_curve_name(OBJ_obj2nid(a->parameter->value.object));
			if (group == NULL)
				goto ecerr;
			EC_GROUP_set_asn1_flag(group, OPENSSL_EC_NAMED_CURVE);
			if (EC_KEY_set_group(eckey, group) == 0)
				goto ecerr;
			EC_GROUP_free(group);
d105 1
a105 6
		/* We have parameters now set private key */
		if (!d2i_ECPrivateKey(&eckey, &p_tmp, pkeylen))
		{
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto ecerr;
		}
d107 3
a109 59
		/* calculate public key (if necessary) */
		if (EC_KEY_get0_public_key(eckey) == NULL)
		{
			const BIGNUM *priv_key;
			const EC_GROUP *group;
			EC_POINT *pub_key;
			/* the public key was not included in the SEC1 private
			 * key => calculate the public key */
			group   = EC_KEY_get0_group(eckey);
			pub_key = EC_POINT_new(group);
			if (pub_key == NULL)
			{
				EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);
				goto ecerr;
			}
			if (!EC_POINT_copy(pub_key, EC_GROUP_get0_generator(group)))
			{
				EC_POINT_free(pub_key);
				EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);
				goto ecerr;
			}
			priv_key = EC_KEY_get0_private_key(eckey);
			if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))
			{
				EC_POINT_free(pub_key);
				EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);
				goto ecerr;
			}
			if (EC_KEY_set_public_key(eckey, pub_key) == 0)
			{
				EC_POINT_free(pub_key);
				EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);
				goto ecerr;
			}
			EC_POINT_free(pub_key);
		}

		EVP_PKEY_assign_EC_KEY(pkey, eckey);
		if (ctx)
			BN_CTX_free(ctx);
		break;
ecerr:
		if (ctx)
			BN_CTX_free(ctx);
		if (eckey)
			EC_KEY_free(eckey);
		if (pkey)
			EVP_PKEY_free(pkey);
		return NULL;
#endif
		default:
		EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
		if (!a->algorithm) BUF_strlcpy (obj_tmp, "NULL", sizeof obj_tmp);
		else i2t_ASN1_OBJECT(obj_tmp, 80, a->algorithm);
		ERR_add_error_data(2, "TYPE=", obj_tmp);
		EVP_PKEY_free (pkey);
		return NULL;
	}
	return pkey;
d128 18
a145 24
	if (!ASN1_INTEGER_set(p8->version, 0)) {
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);
		PKCS8_PRIV_KEY_INFO_free (p8);
		return NULL;
	}
	if (!(p8->pkeyalg->parameter = ASN1_TYPE_new ())) {
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);
		PKCS8_PRIV_KEY_INFO_free (p8);
		return NULL;
	}
	p8->pkey->type = V_ASN1_OCTET_STRING;
	switch (EVP_PKEY_type(pkey->type)) {
#ifndef OPENSSL_NO_RSA
		case EVP_PKEY_RSA:

		if(p8->broken == PKCS8_NO_OCTET) p8->pkey->type = V_ASN1_SEQUENCE;

		p8->pkeyalg->algorithm = OBJ_nid2obj(NID_rsaEncryption);
		p8->pkeyalg->parameter->type = V_ASN1_NULL;
		if (!ASN1_pack_string_of (EVP_PKEY,pkey, i2d_PrivateKey,
					 &p8->pkey->value.octet_string)) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);
			PKCS8_PRIV_KEY_INFO_free (p8);
			return NULL;
d147 1
a147 14
		break;
#endif
#ifndef OPENSSL_NO_DSA
		case EVP_PKEY_DSA:
		if(!dsa_pkey2pkcs8(p8, pkey)) {
			PKCS8_PRIV_KEY_INFO_free (p8);
			return NULL;
		}

		break;
#endif
#ifndef OPENSSL_NO_EC
		case EVP_PKEY_EC:
		if (!eckey_pkey2pkcs8(p8, pkey))
d149 3
a151 2
			PKCS8_PRIV_KEY_INFO_free(p8);
			return(NULL);
a152 7
		break;
#endif
		default:
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
		PKCS8_PRIV_KEY_INFO_free (p8);
		return NULL;
	}
d156 3
a180 295

#ifndef OPENSSL_NO_DSA
static int dsa_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8, EVP_PKEY *pkey)
{
	ASN1_STRING *params = NULL;
	ASN1_INTEGER *prkey = NULL;
	ASN1_TYPE *ttmp = NULL;
	STACK_OF(ASN1_TYPE) *ndsa = NULL;
	unsigned char *p = NULL, *q;
	int len;

	p8->pkeyalg->algorithm = OBJ_nid2obj(NID_dsa);
	len = i2d_DSAparams (pkey->pkey.dsa, NULL);
	if (!(p = OPENSSL_malloc(len))) {
		EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
		goto err;
	}
	q = p;
	i2d_DSAparams (pkey->pkey.dsa, &q);
	if (!(params = ASN1_STRING_new())) {
		EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
		goto err;
	}
	if (!ASN1_STRING_set(params, p, len)) {
		EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
		goto err;
	}
	OPENSSL_free(p);
	p = NULL;
	/* Get private key into integer */
	if (!(prkey = BN_to_ASN1_INTEGER (pkey->pkey.dsa->priv_key, NULL))) {
		EVPerr(EVP_F_DSA_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
		goto err;
	}

	switch(p8->broken) {

		case PKCS8_OK:
		case PKCS8_NO_OCTET:

		if (!ASN1_pack_string_of(ASN1_INTEGER,prkey, i2d_ASN1_INTEGER,
					 &p8->pkey->value.octet_string)) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}

		M_ASN1_INTEGER_free (prkey);
		prkey = NULL;
		p8->pkeyalg->parameter->value.sequence = params;
		params = NULL;
		p8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;

		break;

		case PKCS8_NS_DB:

		p8->pkeyalg->parameter->value.sequence = params;
		params = NULL;
		p8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;
		if (!(ndsa = sk_ASN1_TYPE_new_null())) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (!(ttmp = ASN1_TYPE_new())) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (!(ttmp->value.integer =
			BN_to_ASN1_INTEGER(pkey->pkey.dsa->pub_key, NULL))) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
			goto err;
		}
		ttmp->type = V_ASN1_INTEGER;
		if (!sk_ASN1_TYPE_push(ndsa, ttmp)) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}

		if (!(ttmp = ASN1_TYPE_new())) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		ttmp->value.integer = prkey;
		prkey = NULL;
		ttmp->type = V_ASN1_INTEGER;
		if (!sk_ASN1_TYPE_push(ndsa, ttmp)) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		ttmp = NULL;

		if (!(p8->pkey->value.octet_string = ASN1_OCTET_STRING_new())) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}

		if (!ASN1_seq_pack_ASN1_TYPE(ndsa, i2d_ASN1_TYPE,
					 &p8->pkey->value.octet_string->data,
					 &p8->pkey->value.octet_string->length)) {

			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
		break;

		case PKCS8_EMBEDDED_PARAM:

		p8->pkeyalg->parameter->type = V_ASN1_NULL;
		if (!(ndsa = sk_ASN1_TYPE_new_null())) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (!(ttmp = ASN1_TYPE_new())) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		ttmp->value.sequence = params;
		params = NULL;
		ttmp->type = V_ASN1_SEQUENCE;
		if (!sk_ASN1_TYPE_push(ndsa, ttmp)) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}

		if (!(ttmp = ASN1_TYPE_new())) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		ttmp->value.integer = prkey;
		prkey = NULL;
		ttmp->type = V_ASN1_INTEGER;
		if (!sk_ASN1_TYPE_push(ndsa, ttmp)) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		ttmp = NULL;

		if (!(p8->pkey->value.octet_string = ASN1_OCTET_STRING_new())) {
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}

		if (!ASN1_seq_pack_ASN1_TYPE(ndsa, i2d_ASN1_TYPE,
					 &p8->pkey->value.octet_string->data,
					 &p8->pkey->value.octet_string->length)) {

			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
		break;
	}
	return 1;
err:
	if (p != NULL) OPENSSL_free(p);
	if (params != NULL) ASN1_STRING_free(params);
	if (prkey != NULL) M_ASN1_INTEGER_free(prkey);
	if (ttmp != NULL) ASN1_TYPE_free(ttmp);
	if (ndsa != NULL) sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
	return 0;
}
#endif

#ifndef OPENSSL_NO_EC
static int eckey_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8, EVP_PKEY *pkey)
{
	EC_KEY		*ec_key;
	const EC_GROUP  *group;
	unsigned char	*p, *pp;
	int 		nid, i, ret = 0;
	unsigned int    tmp_flags, old_flags;

	ec_key = pkey->pkey.ec;
	if (ec_key == NULL || (group = EC_KEY_get0_group(ec_key)) == NULL) 
	{
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, EVP_R_MISSING_PARAMETERS);
		return 0;
	}

	/* set the ec parameters OID */
	if (p8->pkeyalg->algorithm)
		ASN1_OBJECT_free(p8->pkeyalg->algorithm);

	p8->pkeyalg->algorithm = OBJ_nid2obj(NID_X9_62_id_ecPublicKey);

	/* set the ec parameters */

	if (p8->pkeyalg->parameter)
	{
		ASN1_TYPE_free(p8->pkeyalg->parameter);
		p8->pkeyalg->parameter = NULL;
	}

	if ((p8->pkeyalg->parameter = ASN1_TYPE_new()) == NULL)
	{
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	
	if (EC_GROUP_get_asn1_flag(group)
                     && (nid = EC_GROUP_get_curve_name(group)))
	{
		/* we have a 'named curve' => just set the OID */
		p8->pkeyalg->parameter->type = V_ASN1_OBJECT;
		p8->pkeyalg->parameter->value.object = OBJ_nid2obj(nid);
	}
	else	/* explicit parameters */
	{
		if ((i = i2d_ECParameters(ec_key, NULL)) == 0)
		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);
			return 0;
		}
		if ((p = (unsigned char *) OPENSSL_malloc(i)) == NULL)
		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);
			return 0;
		}	
		pp = p;
		if (!i2d_ECParameters(ec_key, &pp))
		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);
			OPENSSL_free(p);
			return 0;
		}
		p8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;
		if ((p8->pkeyalg->parameter->value.sequence 
			= ASN1_STRING_new()) == NULL)
		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_ASN1_LIB);
			OPENSSL_free(p);
			return 0;
		}
		ASN1_STRING_set(p8->pkeyalg->parameter->value.sequence, p, i);
		OPENSSL_free(p);
	}

	/* set the private key */

	/* do not include the parameters in the SEC1 private key
	 * see PKCS#11 12.11 */
	old_flags = EC_KEY_get_enc_flags(pkey->pkey.ec);
	tmp_flags = old_flags | EC_PKEY_NO_PARAMETERS;
	EC_KEY_set_enc_flags(pkey->pkey.ec, tmp_flags);
	i = i2d_ECPrivateKey(pkey->pkey.ec, NULL);
	if (!i)
	{
		EC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);
		return 0;
	}
	p = (unsigned char *) OPENSSL_malloc(i);
	if (!p)
	{
		EC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	pp = p;
	if (!i2d_ECPrivateKey(pkey->pkey.ec, &pp))
	{
		EC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);
		OPENSSL_free(p);
		return 0;
	}
	/* restore old encoding flags */
	EC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);

	switch(p8->broken) {

		case PKCS8_OK:
		p8->pkey->value.octet_string = ASN1_OCTET_STRING_new();
		if (!p8->pkey->value.octet_string ||
		    !M_ASN1_OCTET_STRING_set(p8->pkey->value.octet_string,
		    (const void *)p, i))

		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);
		}
		else
			ret = 1;
		break;
		case PKCS8_NO_OCTET:		/* RSA specific */
		case PKCS8_NS_DB:		/* DSA specific */
		case PKCS8_EMBEDDED_PARAM:	/* DSA specific */
		default:
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
	}
	OPENSSL_cleanse(p, (size_t)i);
	OPENSSL_free(p);
	return ret;
}
#endif
@


1.9
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.8
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d64 7
d75 3
d81 1
a81 1
EVP_PKEY *EVP_PKCS82PKEY (PKCS8_PRIV_KEY_INFO *p8)
d89 1
a90 1
	ASN1_TYPE *t1, *t2, *param = NULL;
d92 7
d103 1
a103 1
	unsigned char *p;
d106 1
d123 2
a124 1
	switch (OBJ_obj2nid(a->algorithm))
d230 106
d359 1
a359 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d364 1
a364 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d369 1
a369 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d382 1
a382 1
		if (!ASN1_pack_string ((char *)pkey, i2d_PrivateKey,
d384 1
a384 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d399 9
d409 1
a409 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
d414 1
a414 1
		 p8->pkey->value.octet_string->length, 0);
d434 1
a434 1
		EVPerr(EVP_F_EVP_PKCS8_SET_BROKEN,EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);
a435 2
		break;
		
d452 1
a452 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d458 1
a458 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d462 1
a462 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d469 1
a469 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
d478 1
a478 1
		if (!ASN1_pack_string((char *)prkey, i2d_ASN1_INTEGER,
d480 1
a480 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d498 1
a498 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d502 1
a502 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d507 1
a507 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
d512 1
a512 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d517 1
a517 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d524 1
a524 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d530 1
a530 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d538 1
a538 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d548 1
a548 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d552 1
a552 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d559 1
a559 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d564 1
a564 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d571 1
a571 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d577 1
a577 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d585 1
a585 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d601 194
@


1.7
log
@merge 0.9.7d
@
text
@d238 5
a242 1
	ASN1_INTEGER_set (p8->version, 0);
d310 5
a314 5
	ASN1_STRING *params;
	ASN1_INTEGER *prkey;
	ASN1_TYPE *ttmp;
	STACK_OF(ASN1_TYPE) *ndsa;
	unsigned char *p, *q;
d321 1
a321 2
		PKCS8_PRIV_KEY_INFO_free (p8);
		return 0;
d325 8
a332 2
	params = ASN1_STRING_new();
	ASN1_STRING_set(params, p, len);
d334 1
d338 1
a338 1
		return 0;
d349 1
a349 2
			M_ASN1_INTEGER_free (prkey);
			return 0;
d353 1
d355 1
d363 1
d365 10
a374 3
		ndsa = sk_ASN1_TYPE_new_null();
		ttmp = ASN1_TYPE_new();
		if (!(ttmp->value.integer = BN_to_ASN1_INTEGER (pkey->pkey.dsa->pub_key, NULL))) {
d376 1
a376 2
			PKCS8_PRIV_KEY_INFO_free(p8);
			return 0;
d379 4
a382 1
		sk_ASN1_TYPE_push(ndsa, ttmp);
d384 4
a387 1
		ttmp = ASN1_TYPE_new();
d389 1
d391 5
a395 1
		sk_ASN1_TYPE_push(ndsa, ttmp);
d397 4
a400 1
		p8->pkey->value.octet_string = ASN1_OCTET_STRING_new();
d407 1
a407 3
			sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
			M_ASN1_INTEGER_free(prkey);
			return 0;
d415 8
a422 2
		ndsa = sk_ASN1_TYPE_new_null();
		ttmp = ASN1_TYPE_new();
d424 1
d426 4
a429 1
		sk_ASN1_TYPE_push(ndsa, ttmp);
d431 4
a434 1
		ttmp = ASN1_TYPE_new();
d436 1
d438 5
a442 1
		sk_ASN1_TYPE_push(ndsa, ttmp);
d444 4
a447 1
		p8->pkey->value.octet_string = ASN1_OCTET_STRING_new();
d454 1
a454 3
			sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
			M_ASN1_INTEGER_free (prkey);
			return 0;
d460 7
@


1.6
log
@str{cat,cpy}/sprintf cleanup. markus@@, deraadt@@ ok
@
text
@d213 1
a213 1
		if (!a->algorithm) strlcpy (obj_tmp, "NULL", sizeof obj_tmp);
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d213 1
a213 1
		if (!a->algorithm) strcpy (obj_tmp, "NULL");
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d65 1
d67 1
d74 1
a74 1
#ifndef NO_RSA
d77 1
a77 1
#ifndef NO_DSA
d87 1
d107 1
a107 1
#ifndef NO_RSA
d109 2
a110 1
		if (!(rsa = d2i_RSAPrivateKey (NULL, &p, pkeylen))) {
d117 1
a117 1
#ifndef NO_DSA
d170 1
a170 1
		p = param->value.sequence->data;
d172 1
a172 1
		if (!(dsa = d2i_DSAparams (NULL, &p, plen))) {
d246 1
a246 1
#ifndef NO_RSA
d261 1
a261 1
#ifndef NO_DSA
d303 1
a303 1
#ifndef NO_DSA
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d79 1
a79 1
	STACK *ndsa = NULL;
d122 3
a124 3
		    if(!(ndsa = ASN1_seq_unpack(p, pkeylen, 
					(char *(*)())d2i_ASN1_TYPE,
							 ASN1_TYPE_free))) {
d128 1
a128 1
		    if(sk_num(ndsa) != 2 ) {
d137 2
a138 2
		    t1 = (ASN1_TYPE *)sk_value(ndsa, 0);
		    t2 = (ASN1_TYPE *)sk_value(ndsa, 1);
d196 1
a196 1
		if(ndsa) sk_pop_free(ndsa, ASN1_TYPE_free);
d201 1
a201 1
		sk_pop_free(ndsa, ASN1_TYPE_free);
d305 1
a305 1
	STACK *ndsa;
d308 1
d311 1
a311 1
	if (!(p = Malloc(len))) {
d320 1
a320 1
	Free(p);
d349 1
a349 1
		ndsa = sk_new_null();
d357 1
a357 1
		sk_push(ndsa, (char *)ttmp);
d362 1
a362 1
		sk_push(ndsa, (char *)ttmp);
d366 1
a366 1
		if (!ASN1_seq_pack(ndsa, i2d_ASN1_TYPE,
d371 1
a371 1
			sk_pop_free(ndsa, ASN1_TYPE_free);
d375 1
a375 1
		sk_pop_free(ndsa, ASN1_TYPE_free);
d381 1
a381 1
		ndsa = sk_new_null();
d385 1
a385 1
		sk_push(ndsa, (char *)ttmp);
d390 1
a390 1
		sk_push(ndsa, (char *)ttmp);
d394 1
a394 1
		if (!ASN1_seq_pack(ndsa, i2d_ASN1_TYPE,
d399 1
a399 1
			sk_pop_free(ndsa, ASN1_TYPE_free);
d403 1
a403 1
		sk_pop_free(ndsa, ASN1_TYPE_free);
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d136 1
a136 1
                     
d155 8
a162 1
		} else if (!(privkey=d2i_ASN1_INTEGER (NULL, &p, pkeylen))) {
d196 2
a197 1
		sk_pop_free(ndsa, ASN1_TYPE_free);
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d65 2
d71 1
a71 1
	EVP_PKEY *pkey;
d73 1
a73 1
	RSA *rsa;
d76 5
a80 4
	DSA *dsa;
	ASN1_INTEGER *dsapriv;
	STACK *ndsa;
	BN_CTX *ctx;
d88 2
a89 2
	switch (p8->broken) {
		case PKCS8_OK:
d92 2
a93 3
		break;

		case PKCS8_NO_OCTET:
a95 6
		break;

		default:
		EVPerr(EVP_F_EVP_PKCS82PKEY,EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);
		return NULL;
		break;
d120 1
a120 1
		/* Check for broken Netscape Database DSA PKCS#8, UGH! */
d123 2
a124 2
					(char *(*)())d2i_ASN1_INTEGER,
							 ASN1_STRING_free))) {
d126 1
a126 1
			return NULL;
d130 23
a152 2
			sk_pop_free(ndsa, ASN1_STRING_free);
			return NULL;
d154 2
a155 3
		    dsapriv = (ASN1_INTEGER *) sk_pop(ndsa);
		    sk_pop_free(ndsa, ASN1_STRING_free);
		} else if (!(dsapriv=d2i_ASN1_INTEGER (NULL, &p, pkeylen))) {
d157 1
a157 6
			return NULL;
		}
		/* Retrieve parameters */
		if (a->parameter->type != V_ASN1_SEQUENCE) {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_NO_DSA_PARAMETERS);
			return NULL;
d159 2
a160 2
		p = a->parameter->value.sequence->data;
		plen = a->parameter->value.sequence->length;
d163 1
a163 1
			return NULL;
d166 1
a166 1
		if (!(dsa->priv_key = ASN1_INTEGER_to_BN(dsapriv, NULL))) {
d168 1
a168 2
			DSA_free (dsa);
			return NULL;
d173 1
a173 2
			DSA_free (dsa);
			return NULL;
d177 1
a177 2
			DSA_free (dsa);
			return NULL;
d184 1
a184 3
			BN_CTX_free (ctx);
			DSA_free (dsa);
			return NULL;
d187 1
a187 1
		EVP_PKEY_assign_DSA (pkey, dsa);
d189 8
d210 5
d217 1
a217 1
PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey)
d220 1
a220 5
#ifndef NO_DSA
	ASN1_INTEGER *dpkey;
	unsigned char *p, *q;
	int len;
#endif
d225 1
d232 1
d237 2
d251 1
a251 6
		p8->pkeyalg->algorithm = OBJ_nid2obj(NID_dsa);

		/* get paramaters and place in AlgorithmIdentifier */
		len = i2d_DSAparams (pkey->pkey.dsa, NULL);
		if (!(p = Malloc(len))) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d255 1
a255 21
		q = p;
		i2d_DSAparams (pkey->pkey.dsa, &q);
		p8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;
		p8->pkeyalg->parameter->value.sequence = ASN1_STRING_new();
		ASN1_STRING_set(p8->pkeyalg->parameter->value.sequence, p, len);
		Free(p);
		/* Get private key into an integer and pack */
		if (!(dpkey = BN_to_ASN1_INTEGER (pkey->pkey.dsa->priv_key, NULL))) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
			PKCS8_PRIV_KEY_INFO_free (p8);
			return NULL;
		}
		
		if (!ASN1_pack_string((char *)dpkey, i2d_ASN1_INTEGER,
					 &p8->pkey->value.octet_string)) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			ASN1_INTEGER_free (dpkey);
			PKCS8_PRIV_KEY_INFO_free (p8);
			return NULL;
		}
		ASN1_INTEGER_free (dpkey);
d263 2
a264 3
	p8->pkey->type = V_ASN1_OCTET_STRING;
	RAND_seed (p8->pkey->value.octet_string->data,
					 p8->pkey->value.octet_string->length);
d291 28
d320 80
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a64 4
#ifndef OPENSSL_NO_DSA
static int dsa_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8inf, EVP_PKEY *pkey);
#endif

d69 9
a77 10
	EVP_PKEY *pkey = NULL;
#ifndef OPENSSL_NO_RSA
	RSA *rsa = NULL;
#endif
#ifndef OPENSSL_NO_DSA
	DSA *dsa = NULL;
	ASN1_INTEGER *privkey;
	ASN1_TYPE *t1, *t2, *param = NULL;
	STACK_OF(ASN1_TYPE) *ndsa = NULL;
	BN_CTX *ctx = NULL;
a81 1
	const unsigned char *cp;
d85 2
a86 2
	if(p8->pkey->type == V_ASN1_OCTET_STRING) {
		p8->broken = PKCS8_OK;
d89 3
a91 2
	} else {
		p8->broken = PKCS8_NO_OCTET;
d94 6
d108 1
a108 1
#ifndef OPENSSL_NO_RSA
d110 1
a110 2
		cp = p;
		if (!(rsa = d2i_RSAPrivateKey (NULL,&cp, pkeylen))) {
d117 1
a117 1
#ifndef OPENSSL_NO_DSA
d124 1
a124 1
		/* Check for broken DSA PKCS#8, UGH! */
d126 3
a128 3
		    if(!(ndsa = ASN1_seq_unpack_ASN1_TYPE(p, pkeylen, 
							  d2i_ASN1_TYPE,
							  ASN1_TYPE_free))) {
d130 1
a130 1
			goto dsaerr;
d132 1
a132 1
		    if(sk_ASN1_TYPE_num(ndsa) != 2 ) {
d134 2
a135 1
			goto dsaerr;
d137 3
a139 14
		    /* Handle Two broken types:
		     * SEQUENCE {parameters, priv_key}
		     * SEQUENCE {pub_key, priv_key}
		     */

		    t1 = sk_ASN1_TYPE_value(ndsa, 0);
		    t2 = sk_ASN1_TYPE_value(ndsa, 1);
		    if(t1->type == V_ASN1_SEQUENCE) {
			p8->broken = PKCS8_EMBEDDED_PARAM;
			param = t1;
		    } else if(a->parameter->type == V_ASN1_SEQUENCE) {
			p8->broken = PKCS8_NS_DB;
			param = a->parameter;
		    } else {
d141 1
a141 14
			goto dsaerr;
		    }

		    if(t2->type != V_ASN1_INTEGER) {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto dsaerr;
		    }
		    privkey = t2->value.integer;
		} else {
			if (!(privkey=d2i_ASN1_INTEGER (NULL, &p, pkeylen))) {
				EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
				goto dsaerr;
			}
			param = p8->pkeyalg->parameter;
d143 4
a146 3
		if (!param || (param->type != V_ASN1_SEQUENCE)) {
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto dsaerr;
d148 3
a150 3
		cp = p = param->value.sequence->data;
		plen = param->value.sequence->length;
		if (!(dsa = d2i_DSAparams (NULL, &cp, plen))) {
d152 1
a152 1
			goto dsaerr;
d155 1
a155 1
		if (!(dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL))) {
d157 2
a158 1
			goto dsaerr;
d163 2
a164 1
			goto dsaerr;
d168 2
a169 1
			goto dsaerr;
d176 3
a178 1
			goto dsaerr;
d181 1
a181 6
		EVP_PKEY_assign_DSA(pkey, dsa);
		BN_CTX_free (ctx);
		if(ndsa) sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
		else ASN1_INTEGER_free(privkey);
		break;
		dsaerr:
a182 4
		sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
		DSA_free(dsa);
		EVP_PKEY_free(pkey);
		return NULL;
a195 5
PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey)
{
	return EVP_PKEY2PKCS8_broken(pkey, PKCS8_OK);
}

d198 1
a198 1
PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8_broken(EVP_PKEY *pkey, int broken)
d201 5
a205 1

a209 1
	p8->broken = broken;
a215 1
	p8->pkey->type = V_ASN1_OCTET_STRING;
d217 1
a217 1
#ifndef OPENSSL_NO_RSA
a219 2
		if(p8->broken == PKCS8_NO_OCTET) p8->pkey->type = V_ASN1_SEQUENCE;

d230 1
a230 1
#ifndef OPENSSL_NO_DSA
d232 26
a257 1
		if(!dsa_pkey2pkcs8(p8, pkey)) {
d261 1
a261 1

d269 3
a271 2
	RAND_add(p8->pkey->value.octet_string->data,
		 p8->pkey->value.octet_string->length, 0);
a297 98
#ifndef OPENSSL_NO_DSA
static int dsa_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8, EVP_PKEY *pkey)
{
	ASN1_STRING *params;
	ASN1_INTEGER *prkey;
	ASN1_TYPE *ttmp;
	STACK_OF(ASN1_TYPE) *ndsa;
	unsigned char *p, *q;
	int len;

	p8->pkeyalg->algorithm = OBJ_nid2obj(NID_dsa);
	len = i2d_DSAparams (pkey->pkey.dsa, NULL);
	if (!(p = OPENSSL_malloc(len))) {
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
		PKCS8_PRIV_KEY_INFO_free (p8);
		return 0;
	}
	q = p;
	i2d_DSAparams (pkey->pkey.dsa, &q);
	params = ASN1_STRING_new();
	ASN1_STRING_set(params, p, len);
	OPENSSL_free(p);
	/* Get private key into integer */
	if (!(prkey = BN_to_ASN1_INTEGER (pkey->pkey.dsa->priv_key, NULL))) {
		EVPerr(EVP_F_EVP_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
		return 0;
	}

	switch(p8->broken) {

		case PKCS8_OK:
		case PKCS8_NO_OCTET:

		if (!ASN1_pack_string((char *)prkey, i2d_ASN1_INTEGER,
					 &p8->pkey->value.octet_string)) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			M_ASN1_INTEGER_free (prkey);
			return 0;
		}

		M_ASN1_INTEGER_free (prkey);
		p8->pkeyalg->parameter->value.sequence = params;
		p8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;

		break;

		case PKCS8_NS_DB:

		p8->pkeyalg->parameter->value.sequence = params;
		p8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;
		ndsa = sk_ASN1_TYPE_new_null();
		ttmp = ASN1_TYPE_new();
		if (!(ttmp->value.integer = BN_to_ASN1_INTEGER (pkey->pkey.dsa->pub_key, NULL))) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
			PKCS8_PRIV_KEY_INFO_free(p8);
			return 0;
		}
		ttmp->type = V_ASN1_INTEGER;
		sk_ASN1_TYPE_push(ndsa, ttmp);

		ttmp = ASN1_TYPE_new();
		ttmp->value.integer = prkey;
		ttmp->type = V_ASN1_INTEGER;
		sk_ASN1_TYPE_push(ndsa, ttmp);

		p8->pkey->value.octet_string = ASN1_OCTET_STRING_new();

		if (!ASN1_seq_pack_ASN1_TYPE(ndsa, i2d_ASN1_TYPE,
					 &p8->pkey->value.octet_string->data,
					 &p8->pkey->value.octet_string->length)) {

			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
			M_ASN1_INTEGER_free(prkey);
			return 0;
		}
		sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
		break;

		case PKCS8_EMBEDDED_PARAM:

		p8->pkeyalg->parameter->type = V_ASN1_NULL;
		ndsa = sk_ASN1_TYPE_new_null();
		ttmp = ASN1_TYPE_new();
		ttmp->value.sequence = params;
		ttmp->type = V_ASN1_SEQUENCE;
		sk_ASN1_TYPE_push(ndsa, ttmp);

		ttmp = ASN1_TYPE_new();
		ttmp->value.integer = prkey;
		ttmp->type = V_ASN1_INTEGER;
		sk_ASN1_TYPE_push(ndsa, ttmp);

		p8->pkey->value.octet_string = ASN1_OCTET_STRING_new();

		if (!ASN1_seq_pack_ASN1_TYPE(ndsa, i2d_ASN1_TYPE,
					 &p8->pkey->value.octet_string->data,
					 &p8->pkey->value.octet_string->length)) {
a298 11
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
			M_ASN1_INTEGER_free (prkey);
			return 0;
		}
		sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
		break;
	}
	return 1;
}
#endif
@


1.1.1.2
log
@import openssl-0.9.7d
@
text
@d213 1
a213 1
		if (!a->algorithm) BUF_strlcpy (obj_tmp, "NULL", sizeof obj_tmp);
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d238 1
a238 5
	if (!ASN1_INTEGER_set(p8->version, 0)) {
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
		PKCS8_PRIV_KEY_INFO_free (p8);
		return NULL;
	}
d306 5
a310 5
	ASN1_STRING *params = NULL;
	ASN1_INTEGER *prkey = NULL;
	ASN1_TYPE *ttmp = NULL;
	STACK_OF(ASN1_TYPE) *ndsa = NULL;
	unsigned char *p = NULL, *q;
d317 2
a318 1
		goto err;
d322 2
a323 8
	if (!(params = ASN1_STRING_new())) {
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
		goto err;
	}
	if (!ASN1_STRING_set(params, p, len)) {
		EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
		goto err;
	}
a324 1
	p = NULL;
d328 1
a328 1
		goto err;
d339 2
a340 1
			goto err;
a343 1
		prkey = NULL;
a344 1
		params = NULL;
a351 1
		params = NULL;
d353 3
a355 10
		if (!(ndsa = sk_ASN1_TYPE_new_null())) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (!(ttmp = ASN1_TYPE_new())) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (!(ttmp->value.integer =
			BN_to_ASN1_INTEGER(pkey->pkey.dsa->pub_key, NULL))) {
d357 2
a358 1
			goto err;
d361 1
a361 4
		if (!sk_ASN1_TYPE_push(ndsa, ttmp)) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
d363 1
a363 4
		if (!(ttmp = ASN1_TYPE_new())) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
a364 1
		prkey = NULL;
d366 1
a366 5
		if (!sk_ASN1_TYPE_push(ndsa, ttmp)) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		ttmp = NULL;
d368 1
a368 4
		if (!(p8->pkey->value.octet_string = ASN1_OCTET_STRING_new())) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
d375 3
a377 1
			goto err;
d385 2
a386 8
		if (!(ndsa = sk_ASN1_TYPE_new_null())) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (!(ttmp = ASN1_TYPE_new())) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
a387 1
		params = NULL;
d389 1
a389 4
		if (!sk_ASN1_TYPE_push(ndsa, ttmp)) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
d391 1
a391 4
		if (!(ttmp = ASN1_TYPE_new())) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
a392 1
		prkey = NULL;
d394 1
a394 5
		if (!sk_ASN1_TYPE_push(ndsa, ttmp)) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
		ttmp = NULL;
d396 1
a396 4
		if (!(p8->pkey->value.octet_string = ASN1_OCTET_STRING_new())) {
			EVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
			goto err;
		}
d403 3
a405 1
			goto err;
a410 7
err:
	if (p != NULL) OPENSSL_free(p);
	if (params != NULL) ASN1_STRING_free(params);
	if (prkey != NULL) M_ASN1_INTEGER_free(prkey);
	if (ttmp != NULL) ASN1_TYPE_free(ttmp);
	if (ndsa != NULL) sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);
	return 0;
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
a63 7
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
#include <openssl/bn.h>
a67 3
#ifndef OPENSSL_NO_EC
static int eckey_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8inf, EVP_PKEY *pkey);
#endif
d71 1
a71 1
EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)
a78 1
	ASN1_TYPE *t1, *t2;
d80 1
a81 7
#endif
#ifndef OPENSSL_NO_EC
	EC_KEY *eckey = NULL;
	const unsigned char *p_tmp;
#endif
#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_EC)
	ASN1_TYPE    *param = NULL;	
d86 1
a86 1
	const unsigned char *p;
a88 1
	int  nid;
d105 1
a105 2
	nid = OBJ_obj2nid(a->algorithm);
	switch(nid)
a210 106
#ifndef OPENSSL_NO_EC
		case NID_X9_62_id_ecPublicKey:
		p_tmp = p;
		/* extract the ec parameters */
		param = p8->pkeyalg->parameter;

		if (!param || ((param->type != V_ASN1_SEQUENCE) &&
		    (param->type != V_ASN1_OBJECT)))
		{
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto ecerr;
		}

		if (param->type == V_ASN1_SEQUENCE)
		{
			cp = p = param->value.sequence->data;
			plen = param->value.sequence->length;

			if (!(eckey = d2i_ECParameters(NULL, &cp, plen)))
			{
				EVPerr(EVP_F_EVP_PKCS82PKEY,
					EVP_R_DECODE_ERROR);
				goto ecerr;
			}
		}
		else
		{
			EC_GROUP *group;
			cp = p = param->value.object->data;
			plen = param->value.object->length;

			/* type == V_ASN1_OBJECT => the parameters are given
			 * by an asn1 OID
			 */
			if ((eckey = EC_KEY_new()) == NULL)
			{
				EVPerr(EVP_F_EVP_PKCS82PKEY,
					ERR_R_MALLOC_FAILURE);
				goto ecerr;
			}
			group = EC_GROUP_new_by_curve_name(OBJ_obj2nid(a->parameter->value.object));
			if (group == NULL)
				goto ecerr;
			EC_GROUP_set_asn1_flag(group, OPENSSL_EC_NAMED_CURVE);
			if (EC_KEY_set_group(eckey, group) == 0)
				goto ecerr;
			EC_GROUP_free(group);
		}

		/* We have parameters now set private key */
		if (!d2i_ECPrivateKey(&eckey, &p_tmp, pkeylen))
		{
			EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);
			goto ecerr;
		}

		/* calculate public key (if necessary) */
		if (EC_KEY_get0_public_key(eckey) == NULL)
		{
			const BIGNUM *priv_key;
			const EC_GROUP *group;
			EC_POINT *pub_key;
			/* the public key was not included in the SEC1 private
			 * key => calculate the public key */
			group   = EC_KEY_get0_group(eckey);
			pub_key = EC_POINT_new(group);
			if (pub_key == NULL)
			{
				EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);
				goto ecerr;
			}
			if (!EC_POINT_copy(pub_key, EC_GROUP_get0_generator(group)))
			{
				EC_POINT_free(pub_key);
				EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);
				goto ecerr;
			}
			priv_key = EC_KEY_get0_private_key(eckey);
			if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))
			{
				EC_POINT_free(pub_key);
				EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);
				goto ecerr;
			}
			if (EC_KEY_set_public_key(eckey, pub_key) == 0)
			{
				EC_POINT_free(pub_key);
				EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);
				goto ecerr;
			}
			EC_POINT_free(pub_key);
		}

		EVP_PKEY_assign_EC_KEY(pkey, eckey);
		if (ctx)
			BN_CTX_free(ctx);
		break;
ecerr:
		if (ctx)
			BN_CTX_free(ctx);
		if (eckey)
			EC_KEY_free(eckey);
		if (pkey)
			EVP_PKEY_free(pkey);
		return NULL;
#endif
d234 1
a234 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);
d239 1
a239 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);
d244 1
a244 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);
d257 1
a257 1
		if (!ASN1_pack_string_of (EVP_PKEY,pkey, i2d_PrivateKey,
d259 1
a259 1
			EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);
a273 9
#ifndef OPENSSL_NO_EC
		case EVP_PKEY_EC:
		if (!eckey_pkey2pkcs8(p8, pkey))
		{
			PKCS8_PRIV_KEY_INFO_free(p8);
			return(NULL);
		}
		break;
#endif
d275 1
a275 1
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
d280 1
a280 1
		 p8->pkey->value.octet_string->length, 0.0);
d300 1
a300 1
		EVPerr(EVP_F_PKCS8_SET_BROKEN,EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);
d302 2
d320 1
a320 1
		EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d326 1
a326 1
		EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d330 1
a330 1
		EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d337 1
a337 1
		EVPerr(EVP_F_DSA_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
d346 1
a346 1
		if (!ASN1_pack_string_of(ASN1_INTEGER,prkey, i2d_ASN1_INTEGER,
d348 1
a348 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d366 1
a366 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d370 1
a370 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d375 1
a375 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
d380 1
a380 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d385 1
a385 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d392 1
a392 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d398 1
a398 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d406 1
a406 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d416 1
a416 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d420 1
a420 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d427 1
a427 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d432 1
a432 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d439 1
a439 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d445 1
a445 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
d453 1
a453 1
			EVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);
a468 194

#ifndef OPENSSL_NO_EC
static int eckey_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8, EVP_PKEY *pkey)
{
	EC_KEY		*ec_key;
	const EC_GROUP  *group;
	unsigned char	*p, *pp;
	int 		nid, i, ret = 0;
	unsigned int    tmp_flags, old_flags;

	ec_key = pkey->pkey.ec;
	if (ec_key == NULL || (group = EC_KEY_get0_group(ec_key)) == NULL) 
	{
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, EVP_R_MISSING_PARAMETERS);
		return 0;
	}

	/* set the ec parameters OID */
	if (p8->pkeyalg->algorithm)
		ASN1_OBJECT_free(p8->pkeyalg->algorithm);

	p8->pkeyalg->algorithm = OBJ_nid2obj(NID_X9_62_id_ecPublicKey);

	/* set the ec parameters */

	if (p8->pkeyalg->parameter)
	{
		ASN1_TYPE_free(p8->pkeyalg->parameter);
		p8->pkeyalg->parameter = NULL;
	}

	if ((p8->pkeyalg->parameter = ASN1_TYPE_new()) == NULL)
	{
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	
	if (EC_GROUP_get_asn1_flag(group)
                     && (nid = EC_GROUP_get_curve_name(group)))
	{
		/* we have a 'named curve' => just set the OID */
		p8->pkeyalg->parameter->type = V_ASN1_OBJECT;
		p8->pkeyalg->parameter->value.object = OBJ_nid2obj(nid);
	}
	else	/* explicit parameters */
	{
		if ((i = i2d_ECParameters(ec_key, NULL)) == 0)
		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);
			return 0;
		}
		if ((p = (unsigned char *) OPENSSL_malloc(i)) == NULL)
		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);
			return 0;
		}	
		pp = p;
		if (!i2d_ECParameters(ec_key, &pp))
		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);
			OPENSSL_free(p);
			return 0;
		}
		p8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;
		if ((p8->pkeyalg->parameter->value.sequence 
			= ASN1_STRING_new()) == NULL)
		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_ASN1_LIB);
			OPENSSL_free(p);
			return 0;
		}
		ASN1_STRING_set(p8->pkeyalg->parameter->value.sequence, p, i);
		OPENSSL_free(p);
	}

	/* set the private key */

	/* do not include the parameters in the SEC1 private key
	 * see PKCS#11 12.11 */
	old_flags = EC_KEY_get_enc_flags(pkey->pkey.ec);
	tmp_flags = old_flags | EC_PKEY_NO_PARAMETERS;
	EC_KEY_set_enc_flags(pkey->pkey.ec, tmp_flags);
	i = i2d_ECPrivateKey(pkey->pkey.ec, NULL);
	if (!i)
	{
		EC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);
		return 0;
	}
	p = (unsigned char *) OPENSSL_malloc(i);
	if (!p)
	{
		EC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	pp = p;
	if (!i2d_ECPrivateKey(pkey->pkey.ec, &pp))
	{
		EC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);
		EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);
		OPENSSL_free(p);
		return 0;
	}
	/* restore old encoding flags */
	EC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);

	switch(p8->broken) {

		case PKCS8_OK:
		p8->pkey->value.octet_string = ASN1_OCTET_STRING_new();
		if (!p8->pkey->value.octet_string ||
		    !M_ASN1_OCTET_STRING_set(p8->pkey->value.octet_string,
		    (const void *)p, i))

		{
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);
		}
		else
			ret = 1;
		break;
		case PKCS8_NO_OCTET:		/* RSA specific */
		case PKCS8_NS_DB:		/* DSA specific */
		case PKCS8_EMBEDDED_PARAM:	/* DSA specific */
		default:
			EVPerr(EVP_F_ECKEY_PKEY2PKCS8,EVP_R_ENCODE_ERROR);
	}
	OPENSSL_cleanse(p, (size_t)i);
	OPENSSL_free(p);
	return ret;
}
#endif

/* EVP_PKEY attribute functions */

int EVP_PKEY_get_attr_count(const EVP_PKEY *key)
{
	return X509at_get_attr_count(key->attributes);
}

int EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid,
			  int lastpos)
{
	return X509at_get_attr_by_NID(key->attributes, nid, lastpos);
}

int EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, ASN1_OBJECT *obj,
			  int lastpos)
{
	return X509at_get_attr_by_OBJ(key->attributes, obj, lastpos);
}

X509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *key, int loc)
{
	return X509at_get_attr(key->attributes, loc);
}

X509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *key, int loc)
{
	return X509at_delete_attr(key->attributes, loc);
}

int EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr)
{
	if(X509at_add1_attr(&key->attributes, attr)) return 1;
	return 0;
}

int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key,
			const ASN1_OBJECT *obj, int type,
			const unsigned char *bytes, int len)
{
	if(X509at_add1_attr_by_OBJ(&key->attributes, obj,
				type, bytes, len)) return 1;
	return 0;
}

int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key,
			int nid, int type,
			const unsigned char *bytes, int len)
{
	if(X509at_add1_attr_by_NID(&key->attributes, nid,
				type, bytes, len)) return 1;
	return 0;
}

int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key,
			const char *attrname, int type,
			const unsigned char *bytes, int len)
{
	if(X509at_add1_attr_by_txt(&key->attributes, attrname,
				type, bytes, len)) return 1;
	return 0;
}
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
d64 14
a77 1
#include "asn1_locl.h"
d84 23
a106 1
	ASN1_OBJECT *algoid;
d109 9
a117 3
	if (!PKCS8_pkey_get0(&algoid, NULL, NULL, NULL, p8))
		return NULL;

d122 113
d236 2
a237 1
	if (!EVP_PKEY_set_type(pkey, OBJ_obj2nid(algoid)))
d239 2
a240 4
		EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
		i2t_ASN1_OBJECT(obj_tmp, 80, algoid);
		ERR_add_error_data(2, "TYPE=", obj_tmp);
		goto error;
d243 1
a243 1
	if (pkey->ameth->priv_decode)
d245 4
a248 1
		if (!pkey->ameth->priv_decode(pkey, p8))
d250 3
a252 3
			EVPerr(EVP_F_EVP_PKCS82PKEY,
					EVP_R_PRIVATE_KEY_DECODE_ERROR);
			goto error;
d255 26
a280 1
	else
d282 2
a283 2
		EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_METHOD_NOT_SUPPORTED);
		goto error;
d286 58
a344 4

	error:
	EVP_PKEY_free (pkey);
	return NULL;
d363 33
d397 5
a401 1
	if (pkey->ameth)
d403 2
a404 21
		if (pkey->ameth->priv_encode)
			{
			if (!pkey->ameth->priv_encode(p8, pkey))
				{
				EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,
					EVP_R_PRIVATE_KEY_ENCODE_ERROR);
				goto error;
				}
			}
		else
			{
			EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,
					EVP_R_METHOD_NOT_SUPPORTED);
			goto error;
			}
		}
	else
		{
		EVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,
				EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
		goto error;
d406 7
a415 3
	error:
	PKCS8_PRIV_KEY_INFO_free(p8);
	return NULL;
d438 295
@


