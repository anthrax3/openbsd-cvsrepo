head	1.17;
access;
symbols
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17;
locks; strict;
comment	@ * @;


1.17
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.16;
commitid	kT0fLt3r4lroFJra;

1.16
date	2014.07.12.22.26.01;	author miod;	state Exp;
branches;
next	1.15;
commitid	cEv0qp7GiO8rtzhW;

1.15
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.14;
commitid	yQEL1wOWIearrW15;

1.14
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.13;
commitid	nzndm3zqPmFurSaK;

1.13
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	mJUVYpkFBZ0Zv2bG;

1.12
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	2nvnQBrv22dLtvTt;

1.11
date	2014.05.07.17.42.51;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.21.32.37;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.46;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.10.21;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.16;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.35;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.35;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.30;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.44;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.08;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2011.11.03.02.32.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: p_lib.c,v 1.16 2014/07/12 22:26:01 miod Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>

#include <openssl/opensslconf.h>

#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/x509.h>

#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif

#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include "asn1_locl.h"

static void EVP_PKEY_free_it(EVP_PKEY *x);

int
EVP_PKEY_bits(EVP_PKEY *pkey)
{
	if (pkey && pkey->ameth && pkey->ameth->pkey_bits)
		return pkey->ameth->pkey_bits(pkey);
	return 0;
}

int
EVP_PKEY_size(EVP_PKEY *pkey)
{
	if (pkey && pkey->ameth && pkey->ameth->pkey_size)
		return pkey->ameth->pkey_size(pkey);
	return 0;
}

int
EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode)
{
#ifndef OPENSSL_NO_DSA
	if (pkey->type == EVP_PKEY_DSA) {
		int ret = pkey->save_parameters;

		if (mode >= 0)
			pkey->save_parameters = mode;
		return (ret);
	}
#endif
#ifndef OPENSSL_NO_EC
	if (pkey->type == EVP_PKEY_EC) {
		int ret = pkey->save_parameters;

		if (mode >= 0)
			pkey->save_parameters = mode;
		return (ret);
	}
#endif
	return (0);
}

int
EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)
{
	if (to->type != from->type) {
		EVPerror(EVP_R_DIFFERENT_KEY_TYPES);
		goto err;
	}

	if (EVP_PKEY_missing_parameters(from)) {
		EVPerror(EVP_R_MISSING_PARAMETERS);
		goto err;
	}
	if (from->ameth && from->ameth->param_copy)
		return from->ameth->param_copy(to, from);

err:
	return 0;
}

int
EVP_PKEY_missing_parameters(const EVP_PKEY *pkey)
{
	if (pkey->ameth && pkey->ameth->param_missing)
		return pkey->ameth->param_missing(pkey);
	return 0;
}

int
EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)
{
	if (a->type != b->type)
		return -1;
	if (a->ameth && a->ameth->param_cmp)
		return a->ameth->param_cmp(a, b);
	return -2;
}

int
EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
{
	if (a->type != b->type)
		return -1;

	if (a->ameth) {
		int ret;
		/* Compare parameters if the algorithm has them */
		if (a->ameth->param_cmp) {
			ret = a->ameth->param_cmp(a, b);
			if (ret <= 0)
				return ret;
		}

		if (a->ameth->pub_cmp)
			return a->ameth->pub_cmp(a, b);
	}

	return -2;
}

EVP_PKEY *
EVP_PKEY_new(void)
{
	EVP_PKEY *ret;

	ret = malloc(sizeof(EVP_PKEY));
	if (ret == NULL) {
		EVPerror(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}
	ret->type = EVP_PKEY_NONE;
	ret->save_type = EVP_PKEY_NONE;
	ret->references = 1;
	ret->ameth = NULL;
	ret->engine = NULL;
	ret->pkey.ptr = NULL;
	ret->attributes = NULL;
	ret->save_parameters = 1;
	return (ret);
}

/* Setup a public key ASN1 method and ENGINE from a NID or a string.
 * If pkey is NULL just return 1 or 0 if the algorithm exists.
 */

static int
pkey_set_type(EVP_PKEY *pkey, int type, const char *str, int len)
{
	const EVP_PKEY_ASN1_METHOD *ameth;
	ENGINE *e = NULL;
	if (pkey) {
		if (pkey->pkey.ptr)
			EVP_PKEY_free_it(pkey);
		/* If key type matches and a method exists then this
		 * lookup has succeeded once so just indicate success.
		 */
		if ((type == pkey->save_type) && pkey->ameth)
			return 1;
#ifndef OPENSSL_NO_ENGINE
		/* If we have an ENGINE release it */
		if (pkey->engine) {
			ENGINE_finish(pkey->engine);
			pkey->engine = NULL;
		}
#endif
	}
	if (str)
		ameth = EVP_PKEY_asn1_find_str(&e, str, len);
	else
		ameth = EVP_PKEY_asn1_find(&e, type);
#ifndef OPENSSL_NO_ENGINE
	if (!pkey && e)
		ENGINE_finish(e);
#endif
	if (!ameth) {
		EVPerror(EVP_R_UNSUPPORTED_ALGORITHM);
		return 0;
	}
	if (pkey) {
		pkey->ameth = ameth;
		pkey->engine = e;

		pkey->type = pkey->ameth->pkey_id;
		pkey->save_type = type;
	}
	return 1;
}

int
EVP_PKEY_set_type(EVP_PKEY *pkey, int type)
{
	return pkey_set_type(pkey, type, NULL, -1);
}

int
EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len)
{
	return pkey_set_type(pkey, EVP_PKEY_NONE, str, len);
}

int
EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key)
{
	if (!EVP_PKEY_set_type(pkey, type))
		return 0;
	pkey->pkey.ptr = key;
	return (key != NULL);
}

void *
EVP_PKEY_get0(EVP_PKEY *pkey)
{
	return pkey->pkey.ptr;
}

#ifndef OPENSSL_NO_RSA
int
EVP_PKEY_set1_RSA(EVP_PKEY *pkey, RSA *key)
{
	int ret = EVP_PKEY_assign_RSA(pkey, key);
	if (ret)
		RSA_up_ref(key);
	return ret;
}

RSA *
EVP_PKEY_get1_RSA(EVP_PKEY *pkey)
{
	if (pkey->type != EVP_PKEY_RSA) {
		EVPerror(EVP_R_EXPECTING_AN_RSA_KEY);
		return NULL;
	}
	RSA_up_ref(pkey->pkey.rsa);
	return pkey->pkey.rsa;
}
#endif

#ifndef OPENSSL_NO_DSA
int
EVP_PKEY_set1_DSA(EVP_PKEY *pkey, DSA *key)
{
	int ret = EVP_PKEY_assign_DSA(pkey, key);
	if (ret)
		DSA_up_ref(key);
	return ret;
}

DSA *
EVP_PKEY_get1_DSA(EVP_PKEY *pkey)
{
	if (pkey->type != EVP_PKEY_DSA) {
		EVPerror(EVP_R_EXPECTING_A_DSA_KEY);
		return NULL;
	}
	DSA_up_ref(pkey->pkey.dsa);
	return pkey->pkey.dsa;
}
#endif

#ifndef OPENSSL_NO_EC

int
EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, EC_KEY *key)
{
	int ret = EVP_PKEY_assign_EC_KEY(pkey, key);
	if (ret)
		EC_KEY_up_ref(key);
	return ret;
}

EC_KEY *
EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey)
{
	if (pkey->type != EVP_PKEY_EC) {
		EVPerror(EVP_R_EXPECTING_A_EC_KEY);
		return NULL;
	}
	EC_KEY_up_ref(pkey->pkey.ec);
	return pkey->pkey.ec;
}
#endif


#ifndef OPENSSL_NO_DH

int
EVP_PKEY_set1_DH(EVP_PKEY *pkey, DH *key)
{
	int ret = EVP_PKEY_assign_DH(pkey, key);
	if (ret)
		DH_up_ref(key);
	return ret;
}

DH *
EVP_PKEY_get1_DH(EVP_PKEY *pkey)
{
	if (pkey->type != EVP_PKEY_DH) {
		EVPerror(EVP_R_EXPECTING_A_DH_KEY);
		return NULL;
	}
	DH_up_ref(pkey->pkey.dh);
	return pkey->pkey.dh;
}
#endif

int
EVP_PKEY_type(int type)
{
	int ret;
	const EVP_PKEY_ASN1_METHOD *ameth;
	ENGINE *e;
	ameth = EVP_PKEY_asn1_find(&e, type);
	if (ameth)
		ret = ameth->pkey_id;
	else
		ret = NID_undef;
#ifndef OPENSSL_NO_ENGINE
	if (e)
		ENGINE_finish(e);
#endif
	return ret;
}

int
EVP_PKEY_id(const EVP_PKEY *pkey)
{
	return pkey->type;
}

int
EVP_PKEY_base_id(const EVP_PKEY *pkey)
{
	return EVP_PKEY_type(pkey->type);
}

void
EVP_PKEY_free(EVP_PKEY *x)
{
	int i;

	if (x == NULL)
		return;

	i = CRYPTO_add(&x->references, -1, CRYPTO_LOCK_EVP_PKEY);
	if (i > 0)
		return;

	EVP_PKEY_free_it(x);
	if (x->attributes)
		sk_X509_ATTRIBUTE_pop_free(x->attributes, X509_ATTRIBUTE_free);
	free(x);
}

static void
EVP_PKEY_free_it(EVP_PKEY *x)
{
	if (x->ameth && x->ameth->pkey_free) {
		x->ameth->pkey_free(x);
		x->pkey.ptr = NULL;
	}
#ifndef OPENSSL_NO_ENGINE
	if (x->engine) {
		ENGINE_finish(x->engine);
		x->engine = NULL;
	}
#endif
}

static int
unsup_alg(BIO *out, const EVP_PKEY *pkey, int indent, const char *kstr)
{
	BIO_indent(out, indent, 128);
	BIO_printf(out, "%s algorithm \"%s\" unsupported\n",
	    kstr, OBJ_nid2ln(pkey->type));
	return 1;
}

int
EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey, int indent,
    ASN1_PCTX *pctx)
{
	if (pkey->ameth && pkey->ameth->pub_print)
		return pkey->ameth->pub_print(out, pkey, indent, pctx);

	return unsup_alg(out, pkey, indent, "Public Key");
}

int
EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey, int indent,
    ASN1_PCTX *pctx)
{
	if (pkey->ameth && pkey->ameth->priv_print)
		return pkey->ameth->priv_print(out, pkey, indent, pctx);

	return unsup_alg(out, pkey, indent, "Private Key");
}

int
EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey, int indent,
    ASN1_PCTX *pctx)
{
	if (pkey->ameth && pkey->ameth->param_print)
		return pkey->ameth->param_print(out, pkey, indent, pctx);
	return unsup_alg(out, pkey, indent, "Parameters");
}

int
EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid)
{
	if (!pkey->ameth || !pkey->ameth->pkey_ctrl)
		return -2;
	return pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_DEFAULT_MD_NID,
	    0, pnid);
}

@


1.16
log
@No need to include asn1_mac.h here.
@
text
@d1 1
a1 1
/* $OpenBSD: p_lib.c,v 1.15 2014/07/11 08:44:48 jsing Exp $ */
d131 1
a131 2
		EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,
		    EVP_R_DIFFERENT_KEY_TYPES);
d136 1
a136 2
		EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,
		    EVP_R_MISSING_PARAMETERS);
d193 1
a193 1
		EVPerr(EVP_F_EVP_PKEY_NEW, ERR_R_MALLOC_FAILURE);
d241 1
a241 1
		EVPerr(EVP_F_PKEY_SET_TYPE, EVP_R_UNSUPPORTED_ALGORITHM);
d295 1
a295 1
		EVPerr(EVP_F_EVP_PKEY_GET1_RSA, EVP_R_EXPECTING_AN_RSA_KEY);
d317 1
a317 1
		EVPerr(EVP_F_EVP_PKEY_GET1_DSA, EVP_R_EXPECTING_A_DSA_KEY);
d340 1
a340 1
		EVPerr(EVP_F_EVP_PKEY_GET1_EC_KEY, EVP_R_EXPECTING_A_EC_KEY);
d364 1
a364 1
		EVPerr(EVP_F_EVP_PKEY_GET1_DH, EVP_R_EXPECTING_A_DH_KEY);
@


1.15
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: p_lib.c,v 1.14 2014/07/10 22:45:57 jsing Exp $ */
a62 1
#include <openssl/asn1_mac.h>
@


1.14
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: p_lib.c,v 1.13 2014/06/12 15:49:29 deraadt Exp $ */
d63 1
a63 1
#include "cryptlib.h"
d66 1
a67 2
#include <openssl/evp.h>
#include <openssl/asn1_mac.h>
d69 3
a71 2
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
d76 2
a77 2
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
@


1.13
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 3
@


1.12
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/evp/p_lib.c */
@


1.11
log
@KNF.
@
text
@d191 1
a191 1
	ret = (EVP_PKEY *)malloc(sizeof(EVP_PKEY));
@


1.10
log
@kill REF_PRINT/REF_CHECK debugging framework noone would use
ok miod
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d85 3
a87 2
int EVP_PKEY_bits(EVP_PKEY *pkey)
	{
d91 1
a91 1
	}
d93 3
a95 2
int EVP_PKEY_size(EVP_PKEY *pkey)
	{
d99 1
a99 1
	}
d101 3
a103 2
int EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode)
	{
d105 2
a106 3
	if (pkey->type == EVP_PKEY_DSA)
		{
		int ret=pkey->save_parameters;
d109 3
a111 3
			pkey->save_parameters=mode;
		return(ret);
		}
d114 1
a114 2
	if (pkey->type == EVP_PKEY_EC)
		{
d119 2
a120 2
		return(ret);
		}
d122 2
a123 2
	return(0);
	}
d125 6
a130 5
int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)
	{
	if (to->type != from->type)
		{
		EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_DIFFERENT_KEY_TYPES);
d132 1
a132 1
		}
d134 3
a136 3
	if (EVP_PKEY_missing_parameters(from))
		{
		EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_MISSING_PARAMETERS);
d138 1
a138 1
		}
d141 1
d144 1
a144 1
	}
d146 3
a148 2
int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey)
	{
d152 1
a152 1
	}
d154 3
a156 2
int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)
	{
d162 1
a162 1
	}
d164 3
a166 2
int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
	{
d170 1
a170 2
	if (a->ameth)
		{
d173 1
a173 2
		if (a->ameth->param_cmp)
			{
d177 1
a177 1
			}
d181 1
a181 1
		}
d184 1
a184 1
	}
d186 3
a188 2
EVP_PKEY *EVP_PKEY_new(void)
	{
d191 15
a205 16
	ret=(EVP_PKEY *)malloc(sizeof(EVP_PKEY));
	if (ret == NULL)
		{
		EVPerr(EVP_F_EVP_PKEY_NEW,ERR_R_MALLOC_FAILURE);
		return(NULL);
		}
	ret->type=EVP_PKEY_NONE;
	ret->save_type=EVP_PKEY_NONE;
	ret->references=1;
	ret->ameth=NULL;
	ret->engine=NULL;
	ret->pkey.ptr=NULL;
	ret->attributes=NULL;
	ret->save_parameters=1;
	return(ret);
	}
d211 3
a213 2
static int pkey_set_type(EVP_PKEY *pkey, int type, const char *str, int len)
	{
d216 1
a216 2
	if (pkey)
		{
d226 1
a226 2
		if (pkey->engine)
			{
d229 1
a229 1
			}
d231 1
a231 1
		}
d240 1
a240 2
	if (!ameth)
		{
d243 2
a244 3
		}
	if (pkey)
		{
d249 2
a250 2
		pkey->save_type=type;
		}
d252 1
a252 1
	}
d254 3
a256 2
int EVP_PKEY_set_type(EVP_PKEY *pkey, int type)
	{
d258 1
a258 1
	}
d260 3
a262 2
int EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len)
	{
d264 1
a264 1
	}
d266 3
a268 2
int EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key)
	{
d271 1
a271 1
	pkey->pkey.ptr=key;
d273 1
a273 1
	}
d275 3
a277 2
void *EVP_PKEY_get0(EVP_PKEY *pkey)
	{
d279 1
a279 1
	}
d282 2
a283 1
int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, RSA *key)
d286 1
a286 1
	if(ret)
d291 4
a294 3
RSA *EVP_PKEY_get1_RSA(EVP_PKEY *pkey)
	{
	if(pkey->type != EVP_PKEY_RSA) {
d304 2
a305 1
int EVP_PKEY_set1_DSA(EVP_PKEY *pkey, DSA *key)
d308 1
a308 1
	if(ret)
d313 4
a316 3
DSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey)
	{
	if(pkey->type != EVP_PKEY_DSA) {
d327 2
a328 1
int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, EC_KEY *key)
d330 1
a330 1
	int ret = EVP_PKEY_assign_EC_KEY(pkey,key);
d336 2
a337 1
EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey)
d339 1
a339 2
	if (pkey->type != EVP_PKEY_EC)
	{
d351 2
a352 1
int EVP_PKEY_set1_DH(EVP_PKEY *pkey, DH *key)
d355 1
a355 1
	if(ret)
d360 4
a363 3
DH *EVP_PKEY_get1_DH(EVP_PKEY *pkey)
	{
	if(pkey->type != EVP_PKEY_DH) {
d372 3
a374 2
int EVP_PKEY_type(int type)
	{
d388 1
a388 1
	}
d390 3
a392 2
int EVP_PKEY_id(const EVP_PKEY *pkey)
	{
d394 1
a394 1
	}
d396 3
a398 2
int EVP_PKEY_base_id(const EVP_PKEY *pkey)
	{
d400 1
a400 1
	}
d402 3
a404 2
void EVP_PKEY_free(EVP_PKEY *x)
	{
d407 2
a408 1
	if (x == NULL) return;
d410 3
a412 2
	i=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_EVP_PKEY);
	if (i > 0) return;
d418 1
a418 1
	}
d420 4
a423 4
static void EVP_PKEY_free_it(EVP_PKEY *x)
	{
	if (x->ameth && x->ameth->pkey_free)
		{
d426 1
a426 1
		}
d428 1
a428 2
	if (x->engine)
		{
d431 1
a431 1
		}
d433 1
a433 1
	}
d435 3
a437 3
static int unsup_alg(BIO *out, const EVP_PKEY *pkey, int indent,
				const char *kstr)
	{
d440 1
a440 1
						kstr, OBJ_nid2ln(pkey->type));
d442 1
a442 1
	}
d444 4
a447 3
int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx)
	{
d450 1
a450 1
	
d452 1
a452 1
	}
d454 4
a457 3
int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx)
	{
d460 1
a460 1
	
d462 1
a462 1
	}
d464 4
a467 3
int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx)
	{
d471 1
a471 1
	}
d473 3
a475 2
int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid)
	{
d479 2
a480 2
						0, pnid);
	}
@


1.9
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a393 3
#ifdef REF_PRINT
	REF_PRINT("EVP_PKEY",x);
#endif
d395 1
a395 7
#ifdef REF_CHECK
	if (i < 0)
		{
		fprintf(stderr,"EVP_PKEY_free, bad reference count\n");
		abort();
		}
#endif
@


1.8
log
@openssl-1.0.0e: resolve conflicts
@
text
@d186 1
a186 1
	ret=(EVP_PKEY *)OPENSSL_malloc(sizeof(EVP_PKEY));
d408 1
a408 1
	OPENSSL_free(x);
@


1.7
log
@resolve conflicts, fix local changes
@
text
@d414 1
d416 2
@


1.6
log
@resolve conflicts
@
text
@d77 6
d87 3
a89 35
	if (0)
		return 0;
#ifndef OPENSSL_NO_RSA
	else if (pkey->type == EVP_PKEY_RSA)
		return(BN_num_bits(pkey->pkey.rsa->n));
#endif
#ifndef OPENSSL_NO_DSA
	else if (pkey->type == EVP_PKEY_DSA)
		return(BN_num_bits(pkey->pkey.dsa->p));
#endif
#ifndef OPENSSL_NO_EC
	else if (pkey->type == EVP_PKEY_EC)
		{
		BIGNUM *order = BN_new();
		const EC_GROUP *group;
		int ret;

		if (!order)
			{
			ERR_clear_error();
			return 0;
			}
		group = EC_KEY_get0_group(pkey->pkey.ec);
		if (!EC_GROUP_get_order(group, order, NULL))
			{
			ERR_clear_error();
			return 0;
			}

		ret = BN_num_bits(order);
		BN_free(order);
		return ret;
		}
#endif
	return(0);
d94 3
a96 17
	if (pkey == NULL)
		return(0);
#ifndef OPENSSL_NO_RSA
	if (pkey->type == EVP_PKEY_RSA)
		return(RSA_size(pkey->pkey.rsa));
	else
#endif
#ifndef OPENSSL_NO_DSA
		if (pkey->type == EVP_PKEY_DSA)
		return(DSA_size(pkey->pkey.dsa));
#endif
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
		return(ECDSA_size(pkey->pkey.ec));
#endif

	return(0);
d137 2
a138 30
#ifndef OPENSSL_NO_DSA
	if (to->type == EVP_PKEY_DSA)
		{
		BIGNUM *a;

		if ((a=BN_dup(from->pkey.dsa->p)) == NULL) goto err;
		if (to->pkey.dsa->p != NULL) BN_free(to->pkey.dsa->p);
		to->pkey.dsa->p=a;

		if ((a=BN_dup(from->pkey.dsa->q)) == NULL) goto err;
		if (to->pkey.dsa->q != NULL) BN_free(to->pkey.dsa->q);
		to->pkey.dsa->q=a;

		if ((a=BN_dup(from->pkey.dsa->g)) == NULL) goto err;
		if (to->pkey.dsa->g != NULL) BN_free(to->pkey.dsa->g);
		to->pkey.dsa->g=a;
		}
#endif
#ifndef OPENSSL_NO_EC
	if (to->type == EVP_PKEY_EC)
		{
		EC_GROUP *group = EC_GROUP_dup(EC_KEY_get0_group(from->pkey.ec));
		if (group == NULL)
			goto err;
		if (EC_KEY_set_group(to->pkey.ec, group) == 0)
			goto err;
		EC_GROUP_free(group);
		}
#endif
	return(1);
d140 1
a140 1
	return(0);
d145 3
a147 19
#ifndef OPENSSL_NO_DSA
	if (pkey->type == EVP_PKEY_DSA)
		{
		DSA *dsa;

		dsa=pkey->pkey.dsa;
		if ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))
			return(1);
		}
#endif
#ifndef OPENSSL_NO_EC
	if (pkey->type == EVP_PKEY_EC)
		{
		if (EC_KEY_get0_group(pkey->pkey.ec) == NULL)
			return(1);
		}
#endif

	return(0);
d152 5
a156 23
#ifndef OPENSSL_NO_DSA
	if ((a->type == EVP_PKEY_DSA) && (b->type == EVP_PKEY_DSA))
		{
		if (	BN_cmp(a->pkey.dsa->p,b->pkey.dsa->p) ||
			BN_cmp(a->pkey.dsa->q,b->pkey.dsa->q) ||
			BN_cmp(a->pkey.dsa->g,b->pkey.dsa->g))
			return(0);
		else
			return(1);
		}
#endif
#ifndef OPENSSL_NO_EC
	if (a->type == EVP_PKEY_EC && b->type == EVP_PKEY_EC)
		{
		const EC_GROUP *group_a = EC_KEY_get0_group(a->pkey.ec),
		               *group_b = EC_KEY_get0_group(b->pkey.ec);
		if (EC_GROUP_cmp(group_a, group_b, NULL))
			return 0;
		else
			return 1;
		}
#endif
	return(-1);
d164 1
a164 4
	if (EVP_PKEY_cmp_parameters(a, b) == 0)
		return 0;

	switch (a->type)
d166 3
a168 22
#ifndef OPENSSL_NO_RSA
	case EVP_PKEY_RSA:
		if (BN_cmp(b->pkey.rsa->n,a->pkey.rsa->n) != 0
			|| BN_cmp(b->pkey.rsa->e,a->pkey.rsa->e) != 0)
			return 0;
		break;
#endif
#ifndef OPENSSL_NO_DSA
	case EVP_PKEY_DSA:
		if (BN_cmp(b->pkey.dsa->pub_key,a->pkey.dsa->pub_key) != 0)
			return 0;
		break;
#endif
#ifndef OPENSSL_NO_EC
	case EVP_PKEY_EC:
		{
		int  r;
		const EC_GROUP *group = EC_KEY_get0_group(b->pkey.ec);
		const EC_POINT *pa = EC_KEY_get0_public_key(a->pkey.ec),
		               *pb = EC_KEY_get0_public_key(b->pkey.ec);
		r = EC_POINT_cmp(group, pa, pb, NULL);
		if (r != 0)
d170 3
a172 4
			if (r == 1)
				return 0;
			else
				return -2;
d174 3
a176 9
		}
 		break;
#endif
#ifndef OPENSSL_NO_DH
	case EVP_PKEY_DH:
		return -2;
#endif
	default:
		return -2;
d179 1
a179 1
	return 1;
d193 1
d195 2
d203 56
a258 1
int EVP_PKEY_assign(EVP_PKEY *pkey, int type, char *key)
d260 7
a266 5
	if (pkey == NULL) return(0);
	if (pkey->pkey.ptr != NULL)
		EVP_PKEY_free_it(pkey);
	pkey->type=EVP_PKEY_type(type);
	pkey->save_type=type;
d268 6
a273 1
	return(key != NULL);
d362 23
a384 18
	switch (type)
		{
	case EVP_PKEY_RSA:
	case EVP_PKEY_RSA2:
		return(EVP_PKEY_RSA);
	case EVP_PKEY_DSA:
	case EVP_PKEY_DSA1:
	case EVP_PKEY_DSA2:
	case EVP_PKEY_DSA3:
	case EVP_PKEY_DSA4:
		return(EVP_PKEY_DSA);
	case EVP_PKEY_DH:
		return(EVP_PKEY_DH);
	case EVP_PKEY_EC:
		return(EVP_PKEY_EC);
	default:
		return(NID_undef);
		}
d413 4
a416 1
	switch (x->type)
d418 3
a420 5
#ifndef OPENSSL_NO_RSA
	case EVP_PKEY_RSA:
	case EVP_PKEY_RSA2:
		RSA_free(x->pkey.rsa);
		break;
d422 43
a464 19
#ifndef OPENSSL_NO_DSA
	case EVP_PKEY_DSA:
	case EVP_PKEY_DSA2:
	case EVP_PKEY_DSA3:
	case EVP_PKEY_DSA4:
		DSA_free(x->pkey.dsa);
		break;
#endif
#ifndef OPENSSL_NO_EC
	case EVP_PKEY_EC:
		EC_KEY_free(x->pkey.ec);
		break;
#endif
#ifndef OPENSSL_NO_DH
	case EVP_PKEY_DH:
		DH_free(x->pkey.dh);
		break;
#endif
		}
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d61 2
d67 9
d81 2
d84 1
a84 1
	if (pkey->type == EVP_PKEY_RSA)
a85 1
	else
d88 1
a88 1
		if (pkey->type == EVP_PKEY_DSA)
d91 24
d131 5
d151 10
d164 1
a164 1
int EVP_PKEY_copy_parameters(EVP_PKEY *to, EVP_PKEY *from)
d195 11
d211 1
a211 1
int EVP_PKEY_missing_parameters(EVP_PKEY *pkey)
d223 8
d234 1
a234 1
int EVP_PKEY_cmp_parameters(EVP_PKEY *a, EVP_PKEY *b)
d247 11
d261 52
d382 23
d441 2
d467 2
d488 5
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d67 1
d70 1
a70 1
#ifndef NO_RSA
d75 1
a75 1
#ifndef NO_DSA
d86 1
a86 1
#ifndef NO_RSA
d91 1
a91 1
#ifndef NO_DSA
d100 1
a100 1
#ifndef NO_DSA
d103 1
a103 1
		int ret=pkey->save_parameters=mode;
d126 1
a126 1
#ifndef NO_DSA
d151 1
a151 1
#ifndef NO_DSA
d166 1
a166 1
#ifndef NO_DSA
d209 1
a209 1
#ifndef NO_RSA
d213 2
a214 1
	if(ret) CRYPTO_add(&key->references, 1, CRYPTO_LOCK_RSA);
d224 1
a224 1
	CRYPTO_add(&pkey->pkey.rsa->references, 1, CRYPTO_LOCK_RSA);
d229 1
a229 1
#ifndef NO_DSA
d233 2
a234 1
	if(ret) CRYPTO_add(&key->references, 1, CRYPTO_LOCK_DSA);
d244 1
a244 1
	CRYPTO_add(&pkey->pkey.dsa->references, 1, CRYPTO_LOCK_DSA);
d249 1
a249 1
#ifndef NO_DH
d254 2
a255 1
	if(ret) CRYPTO_add(&key->references, 1, CRYPTO_LOCK_DH);
d265 1
a265 1
	CRYPTO_add(&pkey->pkey.dh->references, 1, CRYPTO_LOCK_DH);
d316 1
a316 1
#ifndef NO_RSA
d322 1
a322 1
#ifndef NO_DSA
d330 1
a330 1
#ifndef NO_DH
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d183 1
a183 1
	ret=(EVP_PKEY *)Malloc(sizeof(EVP_PKEY));
d305 1
a305 1
	Free(x);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d122 1
a122 1
		EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_MISSING_PARMATERS);
d205 1
a205 1
	return(1);
d208 58
d305 1
a305 1
	Free((char *)x);
@


1.1
log
@Initial revision
@
text
@d61 4
a64 4
#include "objects.h"
#include "evp.h"
#include "asn1_mac.h"
#include "x509.h"
a65 4
/* EVPerr(EVP_F_D2I_PKEY,EVP_R_UNSUPPORTED_CIPHER); */
/* EVPerr(EVP_F_D2I_PKEY,EVP_R_IV_TOO_LARGE); */

#ifndef NOPROTO
d67 1
a67 6
#else
static void EVP_PKEY_free_it();
#endif

int EVP_PKEY_bits(pkey)
EVP_PKEY *pkey;
d81 1
a81 2
int EVP_PKEY_size(pkey)
EVP_PKEY *pkey;
d83 2
d97 1
a97 3
int EVP_PKEY_save_parameters(pkey,mode)
EVP_PKEY *pkey;
int mode;
d112 1
a112 2
int EVP_PKEY_copy_parameters(to,from)
EVP_PKEY *to,*from;
d148 1
a148 2
int EVP_PKEY_missing_parameters(pkey)
EVP_PKEY *pkey;
d163 1
a163 2
int EVP_PKEY_cmp_parameters(a,b)
EVP_PKEY *a,*b;
d179 1
a179 1
EVP_PKEY *EVP_PKEY_new()
d197 1
a197 4
int EVP_PKEY_assign(pkey,type,key)
EVP_PKEY *pkey;
int type;
char *key;
d208 1
a208 2
int EVP_PKEY_type(type)
int type;
d228 1
a228 2
void EVP_PKEY_free(x)
EVP_PKEY *x;
d250 1
a250 2
static void EVP_PKEY_free_it(x)
EVP_PKEY *x;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 4
a64 4
#include <openssl/objects.h>
#include <openssl/evp.h>
#include <openssl/asn1_mac.h>
#include <openssl/x509.h>
d66 4
d71 3
d75 2
a76 1
int EVP_PKEY_bits(EVP_PKEY *pkey)
d78 1
a78 1
#ifndef OPENSSL_NO_RSA
d83 1
a83 1
#ifndef OPENSSL_NO_DSA
d90 2
a91 1
int EVP_PKEY_size(EVP_PKEY *pkey)
d93 1
a93 3
	if (pkey == NULL)
		return(0);
#ifndef OPENSSL_NO_RSA
d98 1
a98 1
#ifndef OPENSSL_NO_DSA
d105 3
a107 1
int EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode)
d109 1
a109 1
#ifndef OPENSSL_NO_DSA
d112 1
a112 1
		int ret=pkey->save_parameters;
d122 2
a123 1
int EVP_PKEY_copy_parameters(EVP_PKEY *to, EVP_PKEY *from)
d133 1
a133 1
		EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_MISSING_PARAMETERS);
d136 1
a136 1
#ifndef OPENSSL_NO_DSA
d159 2
a160 1
int EVP_PKEY_missing_parameters(EVP_PKEY *pkey)
d162 1
a162 1
#ifndef OPENSSL_NO_DSA
d175 2
a176 1
int EVP_PKEY_cmp_parameters(EVP_PKEY *a, EVP_PKEY *b)
d178 1
a178 1
#ifndef OPENSSL_NO_DSA
d192 1
a192 1
EVP_PKEY *EVP_PKEY_new(void)
d196 1
a196 1
	ret=(EVP_PKEY *)OPENSSL_malloc(sizeof(EVP_PKEY));
d210 4
a213 1
int EVP_PKEY_assign(EVP_PKEY *pkey, int type, char *key)
d221 1
a221 37
	return(key != NULL);
	}

#ifndef OPENSSL_NO_RSA
int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, RSA *key)
{
	int ret = EVP_PKEY_assign_RSA(pkey, key);
	if(ret)
		RSA_up_ref(key);
	return ret;
}

RSA *EVP_PKEY_get1_RSA(EVP_PKEY *pkey)
	{
	if(pkey->type != EVP_PKEY_RSA) {
		EVPerr(EVP_F_EVP_PKEY_GET1_RSA, EVP_R_EXPECTING_AN_RSA_KEY);
		return NULL;
	}
	RSA_up_ref(pkey->pkey.rsa);
	return pkey->pkey.rsa;
}
#endif

#ifndef OPENSSL_NO_DSA
int EVP_PKEY_set1_DSA(EVP_PKEY *pkey, DSA *key)
{
	int ret = EVP_PKEY_assign_DSA(pkey, key);
	if(ret)
		DSA_up_ref(key);
	return ret;
}

DSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey)
	{
	if(pkey->type != EVP_PKEY_DSA) {
		EVPerr(EVP_F_EVP_PKEY_GET1_DSA, EVP_R_EXPECTING_A_DSA_KEY);
		return NULL;
a222 25
	DSA_up_ref(pkey->pkey.dsa);
	return pkey->pkey.dsa;
}
#endif

#ifndef OPENSSL_NO_DH

int EVP_PKEY_set1_DH(EVP_PKEY *pkey, DH *key)
{
	int ret = EVP_PKEY_assign_DH(pkey, key);
	if(ret)
		DH_up_ref(key);
	return ret;
}

DH *EVP_PKEY_get1_DH(EVP_PKEY *pkey)
	{
	if(pkey->type != EVP_PKEY_DH) {
		EVPerr(EVP_F_EVP_PKEY_GET1_DH, EVP_R_EXPECTING_A_DH_KEY);
		return NULL;
	}
	DH_up_ref(pkey->pkey.dh);
	return pkey->pkey.dh;
}
#endif
d224 2
a225 1
int EVP_PKEY_type(int type)
d245 2
a246 1
void EVP_PKEY_free(EVP_PKEY *x)
d265 1
a265 1
	OPENSSL_free(x);
d268 2
a269 1
static void EVP_PKEY_free_it(EVP_PKEY *x)
d273 1
a273 1
#ifndef OPENSSL_NO_RSA
d279 1
a279 1
#ifndef OPENSSL_NO_DSA
d287 1
a287 1
#ifndef OPENSSL_NO_DH
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@a60 2
#include <openssl/bn.h>
#include <openssl/err.h>
a64 9
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
a69 2
	if (0)
		return 0;
d71 1
a71 1
	else if (pkey->type == EVP_PKEY_RSA)
d73 1
d76 1
a76 1
	else if (pkey->type == EVP_PKEY_DSA)
a78 24
#ifndef OPENSSL_NO_EC
	else if (pkey->type == EVP_PKEY_EC)
		{
		BIGNUM *order = BN_new();
		const EC_GROUP *group;
		int ret;

		if (!order)
			{
			ERR_clear_error();
			return 0;
			}
		group = EC_KEY_get0_group(pkey->pkey.ec);
		if (!EC_GROUP_get_order(group, order, NULL))
			{
			ERR_clear_error();
			return 0;
			}

		ret = BN_num_bits(order);
		BN_free(order);
		return ret;
		}
#endif
a94 5
#ifndef OPENSSL_NO_ECDSA
		if (pkey->type == EVP_PKEY_EC)
		return(ECDSA_size(pkey->pkey.ec));
#endif

a109 10
#ifndef OPENSSL_NO_EC
	if (pkey->type == EVP_PKEY_EC)
		{
		int ret = pkey->save_parameters;

		if (mode >= 0)
			pkey->save_parameters = mode;
		return(ret);
		}
#endif
d113 1
a113 1
int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)
a143 11
#ifndef OPENSSL_NO_EC
	if (to->type == EVP_PKEY_EC)
		{
		EC_GROUP *group = EC_GROUP_dup(EC_KEY_get0_group(from->pkey.ec));
		if (group == NULL)
			goto err;
		if (EC_KEY_set_group(to->pkey.ec, group) == 0)
			goto err;
		EC_GROUP_free(group);
		}
#endif
d149 1
a149 1
int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey)
a160 8
#ifndef OPENSSL_NO_EC
	if (pkey->type == EVP_PKEY_EC)
		{
		if (EC_KEY_get0_group(pkey->pkey.ec) == NULL)
			return(1);
		}
#endif

d164 1
a164 1
int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)
a176 11
#ifndef OPENSSL_NO_EC
	if (a->type == EVP_PKEY_EC && b->type == EVP_PKEY_EC)
		{
		const EC_GROUP *group_a = EC_KEY_get0_group(a->pkey.ec),
		               *group_b = EC_KEY_get0_group(b->pkey.ec);
		if (EC_GROUP_cmp(group_a, group_b, NULL))
			return 0;
		else
			return 1;
		}
#endif
a179 52
int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
	{
	if (a->type != b->type)
		return -1;

	if (EVP_PKEY_cmp_parameters(a, b) == 0)
		return 0;

	switch (a->type)
		{
#ifndef OPENSSL_NO_RSA
	case EVP_PKEY_RSA:
		if (BN_cmp(b->pkey.rsa->n,a->pkey.rsa->n) != 0
			|| BN_cmp(b->pkey.rsa->e,a->pkey.rsa->e) != 0)
			return 0;
		break;
#endif
#ifndef OPENSSL_NO_DSA
	case EVP_PKEY_DSA:
		if (BN_cmp(b->pkey.dsa->pub_key,a->pkey.dsa->pub_key) != 0)
			return 0;
		break;
#endif
#ifndef OPENSSL_NO_EC
	case EVP_PKEY_EC:
		{
		int  r;
		const EC_GROUP *group = EC_KEY_get0_group(b->pkey.ec);
		const EC_POINT *pa = EC_KEY_get0_public_key(a->pkey.ec),
		               *pb = EC_KEY_get0_public_key(b->pkey.ec);
		r = EC_POINT_cmp(group, pa, pb, NULL);
		if (r != 0)
			{
			if (r == 1)
				return 0;
			else
				return -2;
			}
		}
 		break;
#endif
#ifndef OPENSSL_NO_DH
	case EVP_PKEY_DH:
		return -2;
#endif
	default:
		return -2;
		}

	return 1;
	}

a248 23
#ifndef OPENSSL_NO_EC

int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, EC_KEY *key)
{
	int ret = EVP_PKEY_assign_EC_KEY(pkey,key);
	if (ret)
		EC_KEY_up_ref(key);
	return ret;
}

EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey)
{
	if (pkey->type != EVP_PKEY_EC)
	{
		EVPerr(EVP_F_EVP_PKEY_GET1_EC_KEY, EVP_R_EXPECTING_A_EC_KEY);
		return NULL;
	}
	EC_KEY_up_ref(pkey->pkey.ec);
	return pkey->pkey.ec;
}
#endif


a284 2
	case EVP_PKEY_EC:
		return(EVP_PKEY_EC);
a308 2
	if (x->attributes)
		sk_X509_ATTRIBUTE_pop_free(x->attributes, X509_ATTRIBUTE_free);
a327 5
		break;
#endif
#ifndef OPENSSL_NO_EC
	case EVP_PKEY_EC:
		EC_KEY_free(x->pkey.ec);
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@a76 6
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include "asn1_locl.h"

d81 35
a115 3
	if (pkey && pkey->ameth && pkey->ameth->pkey_bits)
		return pkey->ameth->pkey_bits(pkey);
	return 0;
d120 17
a136 3
	if (pkey && pkey->ameth && pkey->ameth->pkey_size)
		return pkey->ameth->pkey_size(pkey);
	return 0;
d177 30
a206 2
	if (from->ameth && from->ameth->param_copy)
		return from->ameth->param_copy(to, from);
d208 1
a208 1
	return 0;
d213 19
a231 3
	if (pkey->ameth && pkey->ameth->param_missing)
		return pkey->ameth->param_missing(pkey);
	return 0;
d236 23
a258 5
	if (a->type != b->type)
		return -1;
	if (a->ameth && a->ameth->param_cmp)
		return a->ameth->param_cmp(a, b);
	return -2;
d266 20
a285 1
	if (a->ameth)
d287 6
a292 3
		int ret;
		/* Compare parameters if the algorithm has them */
		if (a->ameth->param_cmp)
d294 4
a297 3
			ret = a->ameth->param_cmp(a, b);
			if (ret <= 0)
				return ret;
d299 9
a307 3

		if (a->ameth->pub_cmp)
			return a->ameth->pub_cmp(a, b);
d310 1
a310 1
	return -2;
a323 1
	ret->save_type=EVP_PKEY_NONE;
a324 2
	ret->ameth=NULL;
	ret->engine=NULL;
d331 1
a331 56
/* Setup a public key ASN1 method and ENGINE from a NID or a string.
 * If pkey is NULL just return 1 or 0 if the algorithm exists.
 */

static int pkey_set_type(EVP_PKEY *pkey, int type, const char *str, int len)
	{
	const EVP_PKEY_ASN1_METHOD *ameth;
	ENGINE *e = NULL;
	if (pkey)
		{
		if (pkey->pkey.ptr)
			EVP_PKEY_free_it(pkey);
		/* If key type matches and a method exists then this
		 * lookup has succeeded once so just indicate success.
		 */
		if ((type == pkey->save_type) && pkey->ameth)
			return 1;
#ifndef OPENSSL_NO_ENGINE
		/* If we have an ENGINE release it */
		if (pkey->engine)
			{
			ENGINE_finish(pkey->engine);
			pkey->engine = NULL;
			}
#endif
		}
	if (str)
		ameth = EVP_PKEY_asn1_find_str(&e, str, len);
	else
		ameth = EVP_PKEY_asn1_find(&e, type);
#ifndef OPENSSL_NO_ENGINE
	if (!pkey && e)
		ENGINE_finish(e);
#endif
	if (!ameth)
		{
		EVPerr(EVP_F_PKEY_SET_TYPE, EVP_R_UNSUPPORTED_ALGORITHM);
		return 0;
		}
	if (pkey)
		{
		pkey->ameth = ameth;
		pkey->engine = e;

		pkey->type = pkey->ameth->pkey_id;
		pkey->save_type=type;
		}
	return 1;
	}

int EVP_PKEY_set_type(EVP_PKEY *pkey, int type)
	{
	return pkey_set_type(pkey, type, NULL, -1);
	}

int EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len)
d333 5
a337 7
	return pkey_set_type(pkey, EVP_PKEY_NONE, str, len);
	}

int EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key)
	{
	if (!EVP_PKEY_set_type(pkey, type))
		return 0;
d339 1
a339 6
	return (key != NULL);
	}

void *EVP_PKEY_get0(EVP_PKEY *pkey)
	{
	return pkey->pkey.ptr;
d428 18
a445 23
	int ret;
	const EVP_PKEY_ASN1_METHOD *ameth;
	ENGINE *e;
	ameth = EVP_PKEY_asn1_find(&e, type);
	if (ameth)
		ret = ameth->pkey_id;
	else
		ret = NID_undef;
#ifndef OPENSSL_NO_ENGINE
	if (e)
		ENGINE_finish(e);
#endif
	return ret;
	}

int EVP_PKEY_id(const EVP_PKEY *pkey)
	{
	return pkey->type;
	}

int EVP_PKEY_base_id(const EVP_PKEY *pkey)
	{
	return EVP_PKEY_type(pkey->type);
d474 1
a474 4
	if (x->ameth && x->ameth->pkey_free)
		x->ameth->pkey_free(x);
#ifndef OPENSSL_NO_ENGINE
	if (x->engine)
d476 24
a499 2
		ENGINE_finish(x->engine);
		x->engine = NULL;
a500 44
#endif
	}

static int unsup_alg(BIO *out, const EVP_PKEY *pkey, int indent,
				const char *kstr)
	{
	BIO_indent(out, indent, 128);
	BIO_printf(out, "%s algorithm \"%s\" unsupported\n",
						kstr, OBJ_nid2ln(pkey->type));
	return 1;
	}

int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx)
	{
	if (pkey->ameth && pkey->ameth->pub_print)
		return pkey->ameth->pub_print(out, pkey, indent, pctx);
	
	return unsup_alg(out, pkey, indent, "Public Key");
	}

int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx)
	{
	if (pkey->ameth && pkey->ameth->priv_print)
		return pkey->ameth->priv_print(out, pkey, indent, pctx);
	
	return unsup_alg(out, pkey, indent, "Private Key");
	}

int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,
				int indent, ASN1_PCTX *pctx)
	{
	if (pkey->ameth && pkey->ameth->param_print)
		return pkey->ameth->param_print(out, pkey, indent, pctx);
	return unsup_alg(out, pkey, indent, "Parameters");
	}

int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid)
	{
	if (!pkey->ameth || !pkey->ameth->pkey_ctrl)
		return -2;
	return pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_DEFAULT_MD_NID,
						0, pnid);
@


1.1.1.5
log
@import OpenSSL 1.0.0e
@
text
@a413 1
		{
a414 2
		x->pkey.ptr = NULL;
		}
@


