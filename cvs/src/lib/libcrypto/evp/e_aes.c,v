head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.4
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.33.0.4
	OPENBSD_6_1_BASE:1.33;
locks; strict;
comment	@ * @;


1.34
date	2017.05.02.03.59.44;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Dm63V7JYy6WzetfM;

1.33
date	2017.01.31.13.17.21;	author inoguchi;	state Exp;
branches;
next	1.32;
commitid	AsClCxJVtjsC29vv;

1.32
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.31;
commitid	kT0fLt3r4lroFJra;

1.31
date	2016.11.04.17.30.30;	author miod;	state Exp;
branches;
next	1.30;
commitid	uVQFi30uotTYOUA9;

1.30
date	2016.11.04.13.56.05;	author miod;	state Exp;
branches;
next	1.29;
commitid	TilmOttV27QFPTgF;

1.29
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.28;
commitid	vHznCDK3idwNEFz4;

1.28
date	2015.06.20.12.01.14;	author jsing;	state Exp;
branches;
next	1.27;
commitid	f0RvWCt8nx38ad6r;

1.27
date	2015.02.10.09.50.12;	author miod;	state Exp;
branches;
next	1.26;
commitid	vXPcwCc8wnLZxSX4;

1.26
date	2014.10.22.13.02.04;	author jsing;	state Exp;
branches;
next	1.25;
commitid	PjnBgKe6Buhbf937;

1.25
date	2014.07.12.19.31.03;	author miod;	state Exp;
branches;
next	1.24;
commitid	ES7DdmK4RdtHLXur;

1.24
date	2014.07.11.14.38.51;	author miod;	state Exp;
branches;
next	1.23;
commitid	odmGBdZLs9eCHLA0;

1.23
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.22;
commitid	nzndm3zqPmFurSaK;

1.22
date	2014.06.15.22.53.21;	author tedu;	state Exp;
branches;
next	1.21;
commitid	GFQJ0e39uuFvcb73;

1.21
date	2014.06.15.15.41.25;	author jsing;	state Exp;
branches;
next	1.20;
commitid	xnwIyeaBR93Ozrxx;

1.20
date	2014.06.15.15.39.43;	author jsing;	state Exp;
branches;
next	1.19;
commitid	FbGzW5hmXLpadR02;

1.19
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	mJUVYpkFBZ0Zv2bG;

1.18
date	2014.05.26.13.01.58;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2014.05.22.21.56.02;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2014.05.15.14.06.13;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.15.13.53.47;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.08.15.29.00;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2014.05.08.15.13.06;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.07.23.14;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.55;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.29.05.39.21;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.27;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.19;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.10;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.06.27.05.05.33;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.01.09.12.13.56;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.07;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2012.10.13.21.23.40;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.34
log
@use freezero() instead of memset/explicit_bzero + free.  Substantially
reduces conditional logic (-218, +82).

MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH cache alignment calculation bn/bn_exp.c
wasn'tt quite right.  Two other tricky bits with ASN1_STRING_FLAG_NDEF and
BN_FLG_STATIC_DATA where the condition cannot be collapsed completely.

Passes regress.  ok beck
@
text
@/* $OpenBSD: e_aes.c,v 1.33 2017/01/31 13:17:21 inoguchi Exp $ */
/* ====================================================================
 * Copyright (c) 2001-2011 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 */

#include <stdlib.h>
#include <string.h>

#include <openssl/opensslconf.h>

#ifndef OPENSSL_NO_AES
#include <openssl/aes.h>
#include <openssl/err.h>
#include <openssl/evp.h>

#include "evp_locl.h"
#include "modes_lcl.h"

typedef struct {
	AES_KEY ks;
	block128_f block;
	union {
		cbc128_f cbc;
		ctr128_f ctr;
	} stream;
} EVP_AES_KEY;

typedef struct {
	AES_KEY ks;		/* AES key schedule to use */
	int key_set;		/* Set if key initialised */
	int iv_set;		/* Set if an iv is set */
	GCM128_CONTEXT gcm;
	unsigned char *iv;	/* Temporary IV store */
	int ivlen;		/* IV length */
	int taglen;
	int iv_gen;		/* It is OK to generate IVs */
	int tls_aad_len;	/* TLS AAD length */
	ctr128_f ctr;
} EVP_AES_GCM_CTX;

typedef struct {
	AES_KEY ks1, ks2;	/* AES key schedules to use */
	XTS128_CONTEXT xts;
	void (*stream)(const unsigned char *in, unsigned char *out,
	    size_t length, const AES_KEY *key1, const AES_KEY *key2,
	    const unsigned char iv[16]);
} EVP_AES_XTS_CTX;

typedef struct {
	AES_KEY ks;		/* AES key schedule to use */
	int key_set;		/* Set if key initialised */
	int iv_set;		/* Set if an iv is set */
	int tag_set;		/* Set if tag is valid */
	int len_set;		/* Set if message length set */
	int L, M;		/* L and M parameters from RFC3610 */
	CCM128_CONTEXT ccm;
	ccm128_f str;
} EVP_AES_CCM_CTX;

#define MAXBITCHUNK	((size_t)1<<(sizeof(size_t)*8-4))

#ifdef VPAES_ASM
int vpaes_set_encrypt_key(const unsigned char *userKey, int bits,
    AES_KEY *key);
int vpaes_set_decrypt_key(const unsigned char *userKey, int bits,
    AES_KEY *key);

void vpaes_encrypt(const unsigned char *in, unsigned char *out,
    const AES_KEY *key);
void vpaes_decrypt(const unsigned char *in, unsigned char *out,
    const AES_KEY *key);

void vpaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
    size_t length, const AES_KEY *key, unsigned char *ivec, int enc);
#endif
#ifdef BSAES_ASM
void bsaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
    size_t length, const AES_KEY *key, unsigned char ivec[16], int enc);
void bsaes_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
    size_t len, const AES_KEY *key, const unsigned char ivec[16]);
void bsaes_xts_encrypt(const unsigned char *inp, unsigned char *out,
    size_t len, const AES_KEY *key1, const AES_KEY *key2,
    const unsigned char iv[16]);
void bsaes_xts_decrypt(const unsigned char *inp, unsigned char *out,
    size_t len, const AES_KEY *key1, const AES_KEY *key2,
    const unsigned char iv[16]);
#endif
#ifdef AES_CTR_ASM
void AES_ctr32_encrypt(const unsigned char *in, unsigned char *out,
    size_t blocks, const AES_KEY *key,
    const unsigned char ivec[AES_BLOCK_SIZE]);
#endif
#ifdef AES_XTS_ASM
void AES_xts_encrypt(const char *inp, char *out, size_t len,
    const AES_KEY *key1, const AES_KEY *key2, const unsigned char iv[16]);
void AES_xts_decrypt(const char *inp, char *out, size_t len,
    const AES_KEY *key1, const AES_KEY *key2, const unsigned char iv[16]);
#endif

#if	defined(AES_ASM) &&				(  \
	((defined(__i386)	|| defined(__i386__)	|| \
	  defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \
	defined(__x86_64)	|| defined(__x86_64__)	|| \
	defined(_M_AMD64)	|| defined(_M_X64)	|| \
	defined(__INTEL__)				)

#include "x86_arch.h"

#ifdef VPAES_ASM
#define VPAES_CAPABLE	(OPENSSL_cpu_caps() & CPUCAP_MASK_SSSE3)
#endif
#ifdef BSAES_ASM
#define BSAES_CAPABLE	VPAES_CAPABLE
#endif
/*
 * AES-NI section
 */
#define	AESNI_CAPABLE	(OPENSSL_cpu_caps() & CPUCAP_MASK_AESNI)

int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
    AES_KEY *key);
int aesni_set_decrypt_key(const unsigned char *userKey, int bits,
    AES_KEY *key);

void aesni_encrypt(const unsigned char *in, unsigned char *out,
    const AES_KEY *key);
void aesni_decrypt(const unsigned char *in, unsigned char *out,
    const AES_KEY *key);

void aesni_ecb_encrypt(const unsigned char *in, unsigned char *out,
    size_t length, const AES_KEY *key, int enc);
void aesni_cbc_encrypt(const unsigned char *in, unsigned char *out,
    size_t length, const AES_KEY *key, unsigned char *ivec, int enc);

void aesni_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
    size_t blocks, const void *key, const unsigned char *ivec);

void aesni_xts_encrypt(const unsigned char *in, unsigned char *out,
    size_t length, const AES_KEY *key1, const AES_KEY *key2,
    const unsigned char iv[16]);

void aesni_xts_decrypt(const unsigned char *in, unsigned char *out,
    size_t length, const AES_KEY *key1, const AES_KEY *key2,
    const unsigned char iv[16]);

void aesni_ccm64_encrypt_blocks (const unsigned char *in, unsigned char *out,
    size_t blocks, const void *key, const unsigned char ivec[16],
    unsigned char cmac[16]);

void aesni_ccm64_decrypt_blocks (const unsigned char *in, unsigned char *out,
    size_t blocks, const void *key, const unsigned char ivec[16],
    unsigned char cmac[16]);

static int
aesni_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	int ret, mode;
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	mode = ctx->cipher->flags & EVP_CIPH_MODE;
	if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE) &&
	    !enc) {
		ret = aesni_set_decrypt_key(key, ctx->key_len * 8,
		    ctx->cipher_data);
		dat->block = (block128_f)aesni_decrypt;
		dat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?
		    (cbc128_f)aesni_cbc_encrypt : NULL;
	} else {
		ret = aesni_set_encrypt_key(key, ctx->key_len * 8,
		    ctx->cipher_data);
		dat->block = (block128_f)aesni_encrypt;
		if (mode == EVP_CIPH_CBC_MODE)
			dat->stream.cbc = (cbc128_f)aesni_cbc_encrypt;
		else if (mode == EVP_CIPH_CTR_MODE)
			dat->stream.ctr = (ctr128_f)aesni_ctr32_encrypt_blocks;
		else
			dat->stream.cbc = NULL;
	}

	if (ret < 0) {
		EVPerror(EVP_R_AES_KEY_SETUP_FAILED);
		return 0;
	}

	return 1;
}

static int
aesni_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	aesni_cbc_encrypt(in, out, len, ctx->cipher_data, ctx->iv,
	    ctx->encrypt);

	return 1;
}

static int
aesni_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	size_t	bl = ctx->cipher->block_size;

	if (len < bl)
		return 1;

	aesni_ecb_encrypt(in, out, len, ctx->cipher_data, ctx->encrypt);

	return 1;
}

#define aesni_ofb_cipher aes_ofb_cipher
static int aesni_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len);

#define aesni_cfb_cipher aes_cfb_cipher
static int aesni_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len);

#define aesni_cfb8_cipher aes_cfb8_cipher
static int aesni_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len);

#define aesni_cfb1_cipher aes_cfb1_cipher
static int aesni_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len);

#define aesni_ctr_cipher aes_ctr_cipher
static int aesni_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len);

static int
aesni_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	EVP_AES_GCM_CTX *gctx = ctx->cipher_data;

	if (!iv && !key)
		return 1;
	if (key) {
		aesni_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks);
		CRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,
		    (block128_f)aesni_encrypt);
		gctx->ctr = (ctr128_f)aesni_ctr32_encrypt_blocks;
		/* If we have an iv can set it directly, otherwise use
		 * saved IV.
		 */
		if (iv == NULL && gctx->iv_set)
			iv = gctx->iv;
		if (iv) {
			CRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);
			gctx->iv_set = 1;
		}
		gctx->key_set = 1;
	} else {
		/* If key set use IV, otherwise copy */
		if (gctx->key_set)
			CRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);
		else
			memcpy(gctx->iv, iv, gctx->ivlen);
		gctx->iv_set = 1;
		gctx->iv_gen = 0;
	}
	return 1;
}

#define aesni_gcm_cipher aes_gcm_cipher
static int aesni_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len);

static int
aesni_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	EVP_AES_XTS_CTX *xctx = ctx->cipher_data;

	if (!iv && !key)
		return 1;

	if (key) {
		/* key_len is two AES keys */
		if (enc) {
			aesni_set_encrypt_key(key, ctx->key_len * 4,
			    &xctx->ks1);
			xctx->xts.block1 = (block128_f)aesni_encrypt;
			xctx->stream = aesni_xts_encrypt;
		} else {
			aesni_set_decrypt_key(key, ctx->key_len * 4,
			    &xctx->ks1);
			xctx->xts.block1 = (block128_f)aesni_decrypt;
			xctx->stream = aesni_xts_decrypt;
		}

		aesni_set_encrypt_key(key + ctx->key_len / 2,
		    ctx->key_len * 4, &xctx->ks2);
		xctx->xts.block2 = (block128_f)aesni_encrypt;

		xctx->xts.key1 = &xctx->ks1;
	}

	if (iv) {
		xctx->xts.key2 = &xctx->ks2;
		memcpy(ctx->iv, iv, 16);
	}

	return 1;
}

#define aesni_xts_cipher aes_xts_cipher
static int aesni_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len);

static int
aesni_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	EVP_AES_CCM_CTX *cctx = ctx->cipher_data;

	if (!iv && !key)
		return 1;
	if (key) {
		aesni_set_encrypt_key(key, ctx->key_len * 8, &cctx->ks);
		CRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,
		    &cctx->ks, (block128_f)aesni_encrypt);
		cctx->str = enc ? (ccm128_f)aesni_ccm64_encrypt_blocks :
		    (ccm128_f)aesni_ccm64_decrypt_blocks;
		cctx->key_set = 1;
	}
	if (iv) {
		memcpy(ctx->iv, iv, 15 - cctx->L);
		cctx->iv_set = 1;
	}
	return 1;
}

#define aesni_ccm_cipher aes_ccm_cipher
static int aesni_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len);

#define BLOCK_CIPHER_generic(n,keylen,blocksize,ivlen,nmode,mode,MODE,fl) \
static const EVP_CIPHER aesni_##keylen##_##mode = {			\
	.nid = n##_##keylen##_##nmode,					\
	.block_size = blocksize,					\
	.key_len = keylen / 8,						\
	.iv_len = ivlen, 						\
	.flags = fl | EVP_CIPH_##MODE##_MODE,				\
	.init = aesni_init_key,						\
	.do_cipher = aesni_##mode##_cipher,				\
	.ctx_size = sizeof(EVP_AES_KEY)					\
};									\
static const EVP_CIPHER aes_##keylen##_##mode = {			\
	.nid = n##_##keylen##_##nmode,					\
	.block_size = blocksize,					\
	.key_len = keylen / 8,						\
	.iv_len = ivlen, 						\
	.flags = fl | EVP_CIPH_##MODE##_MODE,				\
	.init = aes_init_key,						\
	.do_cipher = aes_##mode##_cipher,				\
	.ctx_size = sizeof(EVP_AES_KEY)					\
};									\
const EVP_CIPHER *							\
EVP_aes_##keylen##_##mode(void)						\
{									\
	return AESNI_CAPABLE ?						\
	    &aesni_##keylen##_##mode : &aes_##keylen##_##mode;		\
}

#define BLOCK_CIPHER_custom(n,keylen,blocksize,ivlen,mode,MODE,fl)	\
static const EVP_CIPHER aesni_##keylen##_##mode = {			\
	.nid = n##_##keylen##_##mode,					\
	.block_size = blocksize,					\
	.key_len =							\
	    (EVP_CIPH_##MODE##_MODE == EVP_CIPH_XTS_MODE ? 2 : 1) *	\
	    keylen / 8,							\
	.iv_len = ivlen,						\
	.flags = fl | EVP_CIPH_##MODE##_MODE,				\
	.init = aesni_##mode##_init_key,				\
	.do_cipher = aesni_##mode##_cipher,				\
	.cleanup = aes_##mode##_cleanup,				\
	.ctx_size = sizeof(EVP_AES_##MODE##_CTX),			\
	.ctrl = aes_##mode##_ctrl					\
};									\
static const EVP_CIPHER aes_##keylen##_##mode = {			\
	.nid = n##_##keylen##_##mode,					\
	.block_size = blocksize,					\
	.key_len =							\
	    (EVP_CIPH_##MODE##_MODE == EVP_CIPH_XTS_MODE ? 2 : 1) *	\
	    keylen / 8,							\
	.iv_len = ivlen,						\
	.flags = fl | EVP_CIPH_##MODE##_MODE,				\
	.init = aes_##mode##_init_key,					\
	.do_cipher = aes_##mode##_cipher,				\
	.cleanup = aes_##mode##_cleanup,				\
	.ctx_size = sizeof(EVP_AES_##MODE##_CTX),			\
	.ctrl = aes_##mode##_ctrl					\
};									\
const EVP_CIPHER *							\
EVP_aes_##keylen##_##mode(void)						\
{									\
	return AESNI_CAPABLE ?						\
	    &aesni_##keylen##_##mode : &aes_##keylen##_##mode;		\
}

#else

#define BLOCK_CIPHER_generic(n,keylen,blocksize,ivlen,nmode,mode,MODE,fl) \
static const EVP_CIPHER aes_##keylen##_##mode = {			\
	.nid = n##_##keylen##_##nmode,					\
	.block_size = blocksize,					\
	.key_len = keylen / 8,						\
	.iv_len = ivlen,						\
	.flags = fl | EVP_CIPH_##MODE##_MODE,				\
	.init = aes_init_key,						\
	.do_cipher = aes_##mode##_cipher,				\
	.ctx_size = sizeof(EVP_AES_KEY)					\
};									\
const EVP_CIPHER *							\
EVP_aes_##keylen##_##mode(void)						\
{									\
	return &aes_##keylen##_##mode;					\
}

#define BLOCK_CIPHER_custom(n,keylen,blocksize,ivlen,mode,MODE,fl)	\
static const EVP_CIPHER aes_##keylen##_##mode = {			\
	.nid = n##_##keylen##_##mode,					\
	.block_size = blocksize,					\
	.key_len =							\
	    (EVP_CIPH_##MODE##_MODE == EVP_CIPH_XTS_MODE ? 2 : 1) *	\
	    keylen / 8,							\
	.iv_len = ivlen,						\
	.flags = fl | EVP_CIPH_##MODE##_MODE,				\
	.init = aes_##mode##_init_key,					\
	.do_cipher = aes_##mode##_cipher,				\
	.cleanup = aes_##mode##_cleanup,				\
	.ctx_size = sizeof(EVP_AES_##MODE##_CTX),			\
	.ctrl = aes_##mode##_ctrl					\
};									\
const EVP_CIPHER *							\
EVP_aes_##keylen##_##mode(void)						\
{									\
	return &aes_##keylen##_##mode;					\
}

#endif

#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)		\
	BLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
	BLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)

static int
aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	int ret, mode;
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	mode = ctx->cipher->flags & EVP_CIPH_MODE;
	if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE) &&
	    !enc)
#ifdef BSAES_CAPABLE
		if (BSAES_CAPABLE && mode == EVP_CIPH_CBC_MODE) {
			ret = AES_set_decrypt_key(key, ctx->key_len * 8,
			    &dat->ks);
			dat->block = (block128_f)AES_decrypt;
			dat->stream.cbc = (cbc128_f)bsaes_cbc_encrypt;
		} else
#endif
#ifdef VPAES_CAPABLE
		if (VPAES_CAPABLE) {
			ret = vpaes_set_decrypt_key(key, ctx->key_len * 8,
			    &dat->ks);
			dat->block = (block128_f)vpaes_decrypt;
			dat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?
			    (cbc128_f)vpaes_cbc_encrypt : NULL;
		} else
#endif
		{
			ret = AES_set_decrypt_key(key, ctx->key_len * 8,
			    &dat->ks);
			dat->block = (block128_f)AES_decrypt;
			dat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?
			    (cbc128_f)AES_cbc_encrypt : NULL;
		} else
#ifdef BSAES_CAPABLE
		if (BSAES_CAPABLE && mode == EVP_CIPH_CTR_MODE) {
			ret = AES_set_encrypt_key(key, ctx->key_len * 8,
			    &dat->ks);
			dat->block = (block128_f)AES_encrypt;
			dat->stream.ctr = (ctr128_f)bsaes_ctr32_encrypt_blocks;
		} else
#endif
#ifdef VPAES_CAPABLE
		if (VPAES_CAPABLE) {
			ret = vpaes_set_encrypt_key(key, ctx->key_len * 8,
			    &dat->ks);
			dat->block = (block128_f)vpaes_encrypt;
			dat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?
			    (cbc128_f)vpaes_cbc_encrypt : NULL;
		} else
#endif
		{
			ret = AES_set_encrypt_key(key, ctx->key_len * 8,
			    &dat->ks);
			dat->block = (block128_f)AES_encrypt;
			dat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?
			    (cbc128_f)AES_cbc_encrypt : NULL;
#ifdef AES_CTR_ASM
			if (mode == EVP_CIPH_CTR_MODE)
				dat->stream.ctr = (ctr128_f)AES_ctr32_encrypt;
#endif
		}

	if (ret < 0) {
		EVPerror(EVP_R_AES_KEY_SETUP_FAILED);
		return 0;
	}

	return 1;
}

static int
aes_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	if (dat->stream.cbc)
		(*dat->stream.cbc)(in, out, len, &dat->ks, ctx->iv,
		    ctx->encrypt);
	else if (ctx->encrypt)
		CRYPTO_cbc128_encrypt(in, out, len, &dat->ks, ctx->iv,
		    dat->block);
	else
		CRYPTO_cbc128_decrypt(in, out, len, &dat->ks, ctx->iv,
		    dat->block);

	return 1;
}

static int
aes_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	size_t	bl = ctx->cipher->block_size;
	size_t	i;
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	if (len < bl)
		return 1;

	for (i = 0, len -= bl; i <= len; i += bl)
		(*dat->block)(in + i, out + i, &dat->ks);

	return 1;
}

static int
aes_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	CRYPTO_ofb128_encrypt(in, out, len, &dat->ks, ctx->iv, &ctx->num,
	    dat->block);
	return 1;
}

static int
aes_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	CRYPTO_cfb128_encrypt(in, out, len, &dat->ks, ctx->iv, &ctx->num,
	    ctx->encrypt, dat->block);
	return 1;
}

static int
aes_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	CRYPTO_cfb128_8_encrypt(in, out, len, &dat->ks, ctx->iv, &ctx->num,
	    ctx->encrypt, dat->block);
	return 1;
}

static int
aes_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	if (ctx->flags&EVP_CIPH_FLAG_LENGTH_BITS) {
		CRYPTO_cfb128_1_encrypt(in, out, len, &dat->ks, ctx->iv,
		    &ctx->num, ctx->encrypt, dat->block);
		return 1;
	}

	while (len >= MAXBITCHUNK) {
		CRYPTO_cfb128_1_encrypt(in, out, MAXBITCHUNK*8, &dat->ks,
		    ctx->iv, &ctx->num, ctx->encrypt, dat->block);
		len -= MAXBITCHUNK;
	}
	if (len)
		CRYPTO_cfb128_1_encrypt(in, out, len*8, &dat->ks,
		    ctx->iv, &ctx->num, ctx->encrypt, dat->block);

	return 1;
}

static int aes_ctr_cipher (EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	unsigned int num = ctx->num;
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	if (dat->stream.ctr)
		CRYPTO_ctr128_encrypt_ctr32(in, out, len, &dat->ks,
		    ctx->iv, ctx->buf, &num, dat->stream.ctr);
	else
		CRYPTO_ctr128_encrypt(in, out, len, &dat->ks,
		    ctx->iv, ctx->buf, &num, dat->block);
	ctx->num = (size_t)num;
	return 1;
}

BLOCK_CIPHER_generic_pack(NID_aes, 128, EVP_CIPH_FLAG_FIPS)
BLOCK_CIPHER_generic_pack(NID_aes, 192, EVP_CIPH_FLAG_FIPS)
BLOCK_CIPHER_generic_pack(NID_aes, 256, EVP_CIPH_FLAG_FIPS)

static int
aes_gcm_cleanup(EVP_CIPHER_CTX *c)
{
	EVP_AES_GCM_CTX *gctx = c->cipher_data;

	if (gctx->iv != c->iv)
		free(gctx->iv);
	explicit_bzero(gctx, sizeof(*gctx));
	return 1;
}

/* increment counter (64-bit int) by 1 */
static void
ctr64_inc(unsigned char *counter)
{
	int n = 8;
	unsigned char  c;

	do {
		--n;
		c = counter[n];
		++c;
		counter[n] = c;
		if (c)
			return;
	} while (n);
}

static int
aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
{
	EVP_AES_GCM_CTX *gctx = c->cipher_data;

	switch (type) {
	case EVP_CTRL_INIT:
		gctx->key_set = 0;
		gctx->iv_set = 0;
		gctx->ivlen = c->cipher->iv_len;
		gctx->iv = c->iv;
		gctx->taglen = -1;
		gctx->iv_gen = 0;
		gctx->tls_aad_len = -1;
		return 1;

	case EVP_CTRL_GCM_SET_IVLEN:
		if (arg <= 0)
			return 0;
		/* Allocate memory for IV if needed */
		if ((arg > EVP_MAX_IV_LENGTH) && (arg > gctx->ivlen)) {
			if (gctx->iv != c->iv)
				free(gctx->iv);
			gctx->iv = malloc(arg);
			if (!gctx->iv)
				return 0;
		}
		gctx->ivlen = arg;
		return 1;

	case EVP_CTRL_GCM_SET_TAG:
		if (arg <= 0 || arg > 16 || c->encrypt)
			return 0;
		memcpy(c->buf, ptr, arg);
		gctx->taglen = arg;
		return 1;

	case EVP_CTRL_GCM_GET_TAG:
		if (arg <= 0 || arg > 16 || !c->encrypt || gctx->taglen < 0)
			return 0;
		memcpy(ptr, c->buf, arg);
		return 1;

	case EVP_CTRL_GCM_SET_IV_FIXED:
		/* Special case: -1 length restores whole IV */
		if (arg == -1) {
			memcpy(gctx->iv, ptr, gctx->ivlen);
			gctx->iv_gen = 1;
			return 1;
		}
		/* Fixed field must be at least 4 bytes and invocation field
		 * at least 8.
		 */
		if ((arg < 4) || (gctx->ivlen - arg) < 8)
			return 0;
		if (arg)
			memcpy(gctx->iv, ptr, arg);
		if (c->encrypt)
			arc4random_buf(gctx->iv + arg, gctx->ivlen - arg);
		gctx->iv_gen = 1;
		return 1;

	case EVP_CTRL_GCM_IV_GEN:
		if (gctx->iv_gen == 0 || gctx->key_set == 0)
			return 0;
		CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);
		if (arg <= 0 || arg > gctx->ivlen)
			arg = gctx->ivlen;
		memcpy(ptr, gctx->iv + gctx->ivlen - arg, arg);
		/* Invocation field will be at least 8 bytes in size and
		 * so no need to check wrap around or increment more than
		 * last 8 bytes.
		 */
		ctr64_inc(gctx->iv + gctx->ivlen - 8);
		gctx->iv_set = 1;
		return 1;

	case EVP_CTRL_GCM_SET_IV_INV:
		if (gctx->iv_gen == 0 || gctx->key_set == 0 || c->encrypt)
			return 0;
		memcpy(gctx->iv + gctx->ivlen - arg, ptr, arg);
		CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);
		gctx->iv_set = 1;
		return 1;

	case EVP_CTRL_AEAD_TLS1_AAD:
		/* Save the AAD for later use */
		if (arg != 13)
			return 0;
		memcpy(c->buf, ptr, arg);
		gctx->tls_aad_len = arg;
		{
			unsigned int len = c->buf[arg - 2] << 8 |
			    c->buf[arg - 1];

			/* Correct length for explicit IV */
			if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)
				return 0;
			len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;

			/* If decrypting correct for tag too */
			if (!c->encrypt) {
				if (len < EVP_GCM_TLS_TAG_LEN)
					return 0;
				len -= EVP_GCM_TLS_TAG_LEN;
			}
			c->buf[arg - 2] = len >> 8;
			c->buf[arg - 1] = len & 0xff;
		}
		/* Extra padding: tag appended to record */
		return EVP_GCM_TLS_TAG_LEN;

	case EVP_CTRL_COPY:
	    {
		EVP_CIPHER_CTX *out = ptr;
		EVP_AES_GCM_CTX *gctx_out = out->cipher_data;

		if (gctx->gcm.key) {
			if (gctx->gcm.key != &gctx->ks)
				return 0;
			gctx_out->gcm.key = &gctx_out->ks;
		}
		if (gctx->iv == c->iv)
			gctx_out->iv = out->iv;
		else {
			gctx_out->iv = malloc(gctx->ivlen);
			if (!gctx_out->iv)
				return 0;
			memcpy(gctx_out->iv, gctx->iv, gctx->ivlen);
		}
		return 1;
	    }

	default:
		return -1;

	}
}

static ctr128_f
aes_gcm_set_key(AES_KEY *aes_key, GCM128_CONTEXT *gcm_ctx,
    const unsigned char *key, size_t key_len)
{
#ifdef BSAES_CAPABLE
	if (BSAES_CAPABLE) {
		AES_set_encrypt_key(key, key_len * 8, aes_key);
		CRYPTO_gcm128_init(gcm_ctx, aes_key, (block128_f)AES_encrypt);
		return (ctr128_f)bsaes_ctr32_encrypt_blocks;
	} else
#endif
#ifdef VPAES_CAPABLE
	if (VPAES_CAPABLE) {
		vpaes_set_encrypt_key(key, key_len * 8, aes_key);
		CRYPTO_gcm128_init(gcm_ctx, aes_key, (block128_f)vpaes_encrypt);
		return NULL;
	} else
#endif
		(void)0; /* terminate potentially open 'else' */

	AES_set_encrypt_key(key, key_len * 8, aes_key);
	CRYPTO_gcm128_init(gcm_ctx, aes_key, (block128_f)AES_encrypt);
#ifdef AES_CTR_ASM
	return (ctr128_f)AES_ctr32_encrypt;
#else
	return NULL;
#endif
}

static int
aes_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	EVP_AES_GCM_CTX *gctx = ctx->cipher_data;

	if (!iv && !key)
		return 1;
	if (key) {
		gctx->ctr = aes_gcm_set_key(&gctx->ks, &gctx->gcm,
		    key, ctx->key_len);

		/* If we have an iv can set it directly, otherwise use
		 * saved IV.
		 */
		if (iv == NULL && gctx->iv_set)
			iv = gctx->iv;
		if (iv) {
			CRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);
			gctx->iv_set = 1;
		}
		gctx->key_set = 1;
	} else {
		/* If key set use IV, otherwise copy */
		if (gctx->key_set)
			CRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);
		else
			memcpy(gctx->iv, iv, gctx->ivlen);
		gctx->iv_set = 1;
		gctx->iv_gen = 0;
	}
	return 1;
}

/* Handle TLS GCM packet format. This consists of the last portion of the IV
 * followed by the payload and finally the tag. On encrypt generate IV,
 * encrypt payload and write the tag. On verify retrieve IV, decrypt payload
 * and verify tag.
 */

static int
aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	EVP_AES_GCM_CTX *gctx = ctx->cipher_data;
	int rv = -1;

	/* Encrypt/decrypt must be performed in place */
	if (out != in ||
	    len < (EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN))
		return -1;

	/* Set IV from start of buffer or generate IV and write to start
	 * of buffer.
	 */
	if (EVP_CIPHER_CTX_ctrl(ctx, ctx->encrypt ?
	    EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV,
	    EVP_GCM_TLS_EXPLICIT_IV_LEN, out) <= 0)
		goto err;

	/* Use saved AAD */
	if (CRYPTO_gcm128_aad(&gctx->gcm, ctx->buf, gctx->tls_aad_len))
		goto err;

	/* Fix buffer and length to point to payload */
	in += EVP_GCM_TLS_EXPLICIT_IV_LEN;
	out += EVP_GCM_TLS_EXPLICIT_IV_LEN;
	len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;
	if (ctx->encrypt) {
		/* Encrypt payload */
		if (gctx->ctr) {
			if (CRYPTO_gcm128_encrypt_ctr32(&gctx->gcm, in, out,
			    len, gctx->ctr))
				goto err;
		} else {
			if (CRYPTO_gcm128_encrypt(&gctx->gcm, in, out, len))
				goto err;
		}
		out += len;

		/* Finally write tag */
		CRYPTO_gcm128_tag(&gctx->gcm, out, EVP_GCM_TLS_TAG_LEN);
		rv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;
	} else {
		/* Decrypt */
		if (gctx->ctr) {
			if (CRYPTO_gcm128_decrypt_ctr32(&gctx->gcm, in, out,
			    len, gctx->ctr))
				goto err;
		} else {
			if (CRYPTO_gcm128_decrypt(&gctx->gcm, in, out, len))
				goto err;
		}
		/* Retrieve tag */
		CRYPTO_gcm128_tag(&gctx->gcm, ctx->buf, EVP_GCM_TLS_TAG_LEN);

		/* If tag mismatch wipe buffer */
		if (memcmp(ctx->buf, in + len, EVP_GCM_TLS_TAG_LEN)) {
			explicit_bzero(out, len);
			goto err;
		}
		rv = len;
	}

err:
	gctx->iv_set = 0;
	gctx->tls_aad_len = -1;
	return rv;
}

static int
aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	EVP_AES_GCM_CTX *gctx = ctx->cipher_data;

	/* If not set up, return error */
	if (!gctx->key_set)
		return -1;

	if (gctx->tls_aad_len >= 0)
		return aes_gcm_tls_cipher(ctx, out, in, len);

	if (!gctx->iv_set)
		return -1;

	if (in) {
		if (out == NULL) {
			if (CRYPTO_gcm128_aad(&gctx->gcm, in, len))
				return -1;
		} else if (ctx->encrypt) {
			if (gctx->ctr) {
				if (CRYPTO_gcm128_encrypt_ctr32(&gctx->gcm,
				    in, out, len, gctx->ctr))
					return -1;
			} else {
				if (CRYPTO_gcm128_encrypt(&gctx->gcm,
				    in, out, len))
					return -1;
			}
		} else {
			if (gctx->ctr) {
				if (CRYPTO_gcm128_decrypt_ctr32(&gctx->gcm,
				    in, out, len, gctx->ctr))
					return -1;
			} else {
				if (CRYPTO_gcm128_decrypt(&gctx->gcm,
				    in, out, len))
					return -1;
			}
		}
		return len;
	} else {
		if (!ctx->encrypt) {
			if (gctx->taglen < 0)
				return -1;
			if (CRYPTO_gcm128_finish(&gctx->gcm, ctx->buf,
			    gctx->taglen) != 0)
				return -1;
			gctx->iv_set = 0;
			return 0;
		}
		CRYPTO_gcm128_tag(&gctx->gcm, ctx->buf, 16);
		gctx->taglen = 16;

		/* Don't reuse the IV */
		gctx->iv_set = 0;
		return 0;
	}

}

#define CUSTOM_FLAGS \
    ( EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV | \
      EVP_CIPH_FLAG_CUSTOM_CIPHER | EVP_CIPH_ALWAYS_CALL_INIT | \
      EVP_CIPH_CTRL_INIT | EVP_CIPH_CUSTOM_COPY )

BLOCK_CIPHER_custom(NID_aes, 128, 1, 12, gcm, GCM,
    EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_AEAD_CIPHER|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes, 192, 1, 12, gcm, GCM,
    EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_AEAD_CIPHER|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes, 256, 1, 12, gcm, GCM,
    EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_AEAD_CIPHER|CUSTOM_FLAGS)

static int
aes_xts_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
{
	EVP_AES_XTS_CTX *xctx = c->cipher_data;

	switch (type) {
	case EVP_CTRL_INIT:
		/*
		 * key1 and key2 are used as an indicator both key and IV
		 * are set
		 */
		xctx->xts.key1 = NULL;
		xctx->xts.key2 = NULL;
		return 1;

	case EVP_CTRL_COPY:
	    {
		EVP_CIPHER_CTX *out = ptr;
		EVP_AES_XTS_CTX *xctx_out = out->cipher_data;

		if (xctx->xts.key1) {
			if (xctx->xts.key1 != &xctx->ks1)
				return 0;
			xctx_out->xts.key1 = &xctx_out->ks1;
		}
		if (xctx->xts.key2) {
			if (xctx->xts.key2 != &xctx->ks2)
				return 0;
			xctx_out->xts.key2 = &xctx_out->ks2;
		}
		return 1;
	    }
	}
	return -1;
}

static int
aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	EVP_AES_XTS_CTX *xctx = ctx->cipher_data;

	if (!iv && !key)
		return 1;

	if (key) do {
#ifdef AES_XTS_ASM
		xctx->stream = enc ? AES_xts_encrypt : AES_xts_decrypt;
#else
		xctx->stream = NULL;
#endif
		/* key_len is two AES keys */
#ifdef BSAES_CAPABLE
		if (BSAES_CAPABLE)
			xctx->stream = enc ? bsaes_xts_encrypt :
			    bsaes_xts_decrypt;
		else
#endif
#ifdef VPAES_CAPABLE
		if (VPAES_CAPABLE) {
			if (enc) {
				vpaes_set_encrypt_key(key, ctx->key_len * 4,
				    &xctx->ks1);
				xctx->xts.block1 = (block128_f)vpaes_encrypt;
			} else {
				vpaes_set_decrypt_key(key, ctx->key_len * 4,
				    &xctx->ks1);
				xctx->xts.block1 = (block128_f)vpaes_decrypt;
			}

			vpaes_set_encrypt_key(key + ctx->key_len / 2,
			    ctx->key_len * 4, &xctx->ks2);
			xctx->xts.block2 = (block128_f)vpaes_encrypt;

			xctx->xts.key1 = &xctx->ks1;
			break;
		} else
#endif
			(void)0;	/* terminate potentially open 'else' */

		if (enc) {
			AES_set_encrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)AES_encrypt;
		} else {
			AES_set_decrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)AES_decrypt;
		}

		AES_set_encrypt_key(key + ctx->key_len / 2,
		    ctx->key_len * 4, &xctx->ks2);
		xctx->xts.block2 = (block128_f)AES_encrypt;

		xctx->xts.key1 = &xctx->ks1;
	} while (0);

	if (iv) {
		xctx->xts.key2 = &xctx->ks2;
		memcpy(ctx->iv, iv, 16);
	}

	return 1;
}

static int
aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	EVP_AES_XTS_CTX *xctx = ctx->cipher_data;

	if (!xctx->xts.key1 || !xctx->xts.key2)
		return 0;
	if (!out || !in || len < AES_BLOCK_SIZE)
		return 0;

	if (xctx->stream)
		(*xctx->stream)(in, out, len, xctx->xts.key1, xctx->xts.key2,
		    ctx->iv);
	else if (CRYPTO_xts128_encrypt(&xctx->xts, ctx->iv, in, out, len,
	    ctx->encrypt))
		return 0;
	return 1;
}

#define aes_xts_cleanup NULL

#define XTS_FLAGS \
    ( EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV | \
      EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT | EVP_CIPH_CUSTOM_COPY )

BLOCK_CIPHER_custom(NID_aes, 128, 1, 16, xts, XTS, EVP_CIPH_FLAG_FIPS|XTS_FLAGS)
BLOCK_CIPHER_custom(NID_aes, 256, 1, 16, xts, XTS, EVP_CIPH_FLAG_FIPS|XTS_FLAGS)

static int
aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
{
	EVP_AES_CCM_CTX *cctx = c->cipher_data;

	switch (type) {
	case EVP_CTRL_INIT:
		cctx->key_set = 0;
		cctx->iv_set = 0;
		cctx->L = 8;
		cctx->M = 12;
		cctx->tag_set = 0;
		cctx->len_set = 0;
		return 1;

	case EVP_CTRL_CCM_SET_IVLEN:
		arg = 15 - arg;

	case EVP_CTRL_CCM_SET_L:
		if (arg < 2 || arg > 8)
			return 0;
		cctx->L = arg;
		return 1;

	case EVP_CTRL_CCM_SET_TAG:
		if ((arg & 1) || arg < 4 || arg > 16)
			return 0;
		if ((c->encrypt && ptr) || (!c->encrypt && !ptr))
			return 0;
		if (ptr) {
			cctx->tag_set = 1;
			memcpy(c->buf, ptr, arg);
		}
		cctx->M = arg;
		return 1;

	case EVP_CTRL_CCM_GET_TAG:
		if (!c->encrypt || !cctx->tag_set)
			return 0;
		if (!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg))
			return 0;
		cctx->tag_set = 0;
		cctx->iv_set = 0;
		cctx->len_set = 0;
		return 1;

	case EVP_CTRL_COPY:
	    {
		EVP_CIPHER_CTX *out = ptr;
		EVP_AES_CCM_CTX *cctx_out = out->cipher_data;

		if (cctx->ccm.key) {
			if (cctx->ccm.key != &cctx->ks)
				return 0;
			cctx_out->ccm.key = &cctx_out->ks;
		}
		return 1;
	    }

	default:
		return -1;
	}
}

static int
aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
    const unsigned char *iv, int enc)
{
	EVP_AES_CCM_CTX *cctx = ctx->cipher_data;

	if (!iv && !key)
		return 1;
	if (key) do {
#ifdef VPAES_CAPABLE
		if (VPAES_CAPABLE) {
			vpaes_set_encrypt_key(key, ctx->key_len*8, &cctx->ks);
			CRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,
			    &cctx->ks, (block128_f)vpaes_encrypt);
			cctx->str = NULL;
			cctx->key_set = 1;
			break;
		}
#endif
		AES_set_encrypt_key(key, ctx->key_len * 8, &cctx->ks);
		CRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,
		    &cctx->ks, (block128_f)AES_encrypt);
		cctx->str = NULL;
		cctx->key_set = 1;
	} while (0);
	if (iv) {
		memcpy(ctx->iv, iv, 15 - cctx->L);
		cctx->iv_set = 1;
	}
	return 1;
}

static int
aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
    const unsigned char *in, size_t len)
{
	EVP_AES_CCM_CTX *cctx = ctx->cipher_data;
	CCM128_CONTEXT *ccm = &cctx->ccm;

	/* If not set up, return error */
	if (!cctx->iv_set && !cctx->key_set)
		return -1;
	if (!ctx->encrypt && !cctx->tag_set)
		return -1;

	if (!out) {
		if (!in) {
			if (CRYPTO_ccm128_setiv(ccm, ctx->iv, 15 - cctx->L,
			    len))
				return -1;
			cctx->len_set = 1;
			return len;
		}
		/* If have AAD need message length */
		if (!cctx->len_set && len)
			return -1;
		CRYPTO_ccm128_aad(ccm, in, len);
		return len;
	}
	/* EVP_*Final() doesn't return any data */
	if (!in)
		return 0;
	/* If not set length yet do it */
	if (!cctx->len_set) {
		if (CRYPTO_ccm128_setiv(ccm, ctx->iv, 15 - cctx->L, len))
			return -1;
		cctx->len_set = 1;
	}
	if (ctx->encrypt) {
		if (cctx->str ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len,
		    cctx->str) : CRYPTO_ccm128_encrypt(ccm, in, out, len))
			return -1;
		cctx->tag_set = 1;
		return len;
	} else {
		int rv = -1;
		if (cctx->str ? !CRYPTO_ccm128_decrypt_ccm64(ccm, in, out, len,
		    cctx->str) : !CRYPTO_ccm128_decrypt(ccm, in, out, len)) {
			unsigned char tag[16];
			if (CRYPTO_ccm128_tag(ccm, tag, cctx->M)) {
				if (!memcmp(tag, ctx->buf, cctx->M))
					rv = len;
			}
		}
		if (rv == -1)
			explicit_bzero(out, len);
		cctx->iv_set = 0;
		cctx->tag_set = 0;
		cctx->len_set = 0;
		return rv;
	}

}

#define aes_ccm_cleanup NULL

BLOCK_CIPHER_custom(NID_aes, 128, 1, 12, ccm, CCM,
    EVP_CIPH_FLAG_FIPS|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes, 192, 1, 12, ccm, CCM,
    EVP_CIPH_FLAG_FIPS|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes, 256, 1, 12, ccm, CCM,
    EVP_CIPH_FLAG_FIPS|CUSTOM_FLAGS)

#define EVP_AEAD_AES_GCM_TAG_LEN 16

struct aead_aes_gcm_ctx {
	union {
		double align;
		AES_KEY ks;
	} ks;
	GCM128_CONTEXT gcm;
	ctr128_f ctr;
	unsigned char tag_len;
};

static int
aead_aes_gcm_init(EVP_AEAD_CTX *ctx, const unsigned char *key, size_t key_len,
    size_t tag_len)
{
	struct aead_aes_gcm_ctx *gcm_ctx;
	const size_t key_bits = key_len * 8;

	/* EVP_AEAD_CTX_init should catch this. */
	if (key_bits != 128 && key_bits != 256) {
		EVPerror(EVP_R_BAD_KEY_LENGTH);
		return 0;
	}

	if (tag_len == EVP_AEAD_DEFAULT_TAG_LENGTH)
		tag_len = EVP_AEAD_AES_GCM_TAG_LEN;

	if (tag_len > EVP_AEAD_AES_GCM_TAG_LEN) {
		EVPerror(EVP_R_TAG_TOO_LARGE);
		return 0;
	}

	gcm_ctx = malloc(sizeof(struct aead_aes_gcm_ctx));
	if (gcm_ctx == NULL)
		return 0;

#ifdef AESNI_CAPABLE
	if (AESNI_CAPABLE) {
		aesni_set_encrypt_key(key, key_bits, &gcm_ctx->ks.ks);
		CRYPTO_gcm128_init(&gcm_ctx->gcm, &gcm_ctx->ks.ks,
		    (block128_f)aesni_encrypt);
		gcm_ctx->ctr = (ctr128_f) aesni_ctr32_encrypt_blocks;
	} else
#endif
	{
		gcm_ctx->ctr = aes_gcm_set_key(&gcm_ctx->ks.ks, &gcm_ctx->gcm,
		    key, key_len);
	}
	gcm_ctx->tag_len = tag_len;
	ctx->aead_state = gcm_ctx;

	return 1;
}

static void
aead_aes_gcm_cleanup(EVP_AEAD_CTX *ctx)
{
	struct aead_aes_gcm_ctx *gcm_ctx = ctx->aead_state;

	freezero(gcm_ctx, sizeof(*gcm_ctx));
}

static int
aead_aes_gcm_seal(const EVP_AEAD_CTX *ctx, unsigned char *out, size_t *out_len,
    size_t max_out_len, const unsigned char *nonce, size_t nonce_len,
    const unsigned char *in, size_t in_len, const unsigned char *ad,
    size_t ad_len)
{
	const struct aead_aes_gcm_ctx *gcm_ctx = ctx->aead_state;
	GCM128_CONTEXT gcm;
	size_t bulk = 0;

	if (max_out_len < in_len + gcm_ctx->tag_len) {
		EVPerror(EVP_R_BUFFER_TOO_SMALL);
		return 0;
	}

	memcpy(&gcm, &gcm_ctx->gcm, sizeof(gcm));
	CRYPTO_gcm128_setiv(&gcm, nonce, nonce_len);

	if (ad_len > 0 && CRYPTO_gcm128_aad(&gcm, ad, ad_len))
		return 0;

	if (gcm_ctx->ctr) {
		if (CRYPTO_gcm128_encrypt_ctr32(&gcm, in + bulk, out + bulk,
		    in_len - bulk, gcm_ctx->ctr))
			return 0;
	} else {
		if (CRYPTO_gcm128_encrypt(&gcm, in + bulk, out + bulk,
		    in_len - bulk))
			return 0;
	}

	CRYPTO_gcm128_tag(&gcm, out + in_len, gcm_ctx->tag_len);
	*out_len = in_len + gcm_ctx->tag_len;

	return 1;
}

static int
aead_aes_gcm_open(const EVP_AEAD_CTX *ctx, unsigned char *out, size_t *out_len,
    size_t max_out_len, const unsigned char *nonce, size_t nonce_len,
    const unsigned char *in, size_t in_len, const unsigned char *ad,
    size_t ad_len)
{
	const struct aead_aes_gcm_ctx *gcm_ctx = ctx->aead_state;
	unsigned char tag[EVP_AEAD_AES_GCM_TAG_LEN];
	GCM128_CONTEXT gcm;
	size_t plaintext_len;
	size_t bulk = 0;

	if (in_len < gcm_ctx->tag_len) {
		EVPerror(EVP_R_BAD_DECRYPT);
		return 0;
	}

	plaintext_len = in_len - gcm_ctx->tag_len;

	if (max_out_len < plaintext_len) {
		EVPerror(EVP_R_BUFFER_TOO_SMALL);
		return 0;
	}

	memcpy(&gcm, &gcm_ctx->gcm, sizeof(gcm));
	CRYPTO_gcm128_setiv(&gcm, nonce, nonce_len);

	if (CRYPTO_gcm128_aad(&gcm, ad, ad_len))
		return 0;

	if (gcm_ctx->ctr) {
		if (CRYPTO_gcm128_decrypt_ctr32(&gcm, in + bulk, out + bulk,
		    in_len - bulk - gcm_ctx->tag_len, gcm_ctx->ctr))
			return 0;
	} else {
		if (CRYPTO_gcm128_decrypt(&gcm, in + bulk, out + bulk,
		    in_len - bulk - gcm_ctx->tag_len))
			return 0;
	}

	CRYPTO_gcm128_tag(&gcm, tag, gcm_ctx->tag_len);
	if (timingsafe_memcmp(tag, in + plaintext_len, gcm_ctx->tag_len) != 0) {
		EVPerror(EVP_R_BAD_DECRYPT);
		return 0;
	}

	*out_len = plaintext_len;

	return 1;
}

static const EVP_AEAD aead_aes_128_gcm = {
	.key_len = 16,
	.nonce_len = 12,
	.overhead = EVP_AEAD_AES_GCM_TAG_LEN,
	.max_tag_len = EVP_AEAD_AES_GCM_TAG_LEN,

	.init = aead_aes_gcm_init,
	.cleanup = aead_aes_gcm_cleanup,
	.seal = aead_aes_gcm_seal,
	.open = aead_aes_gcm_open,
};

static const EVP_AEAD aead_aes_256_gcm = {
	.key_len = 32,
	.nonce_len = 12,
	.overhead = EVP_AEAD_AES_GCM_TAG_LEN,
	.max_tag_len = EVP_AEAD_AES_GCM_TAG_LEN,

	.init = aead_aes_gcm_init,
	.cleanup = aead_aes_gcm_cleanup,
	.seal = aead_aes_gcm_seal,
	.open = aead_aes_gcm_open,
};

const EVP_AEAD *
EVP_aead_aes_128_gcm(void)
{
	return &aead_aes_128_gcm;
}

const EVP_AEAD *
EVP_aead_aes_256_gcm(void)
{
	return &aead_aes_256_gcm;
}

#endif
@


1.33
log
@LibreSSL : Truncated packet could crash via OOB read

This patch is originally from master branch of OpenSSL.
- 2198b3a crypto/evp: harden AEAD ciphers.
- 8e20499 crypto/evp: harden RC4_MD5 cipher.

ok tom@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.32 2017/01/29 17:49:23 beck Exp $ */
d1425 1
a1425 2
	explicit_bzero(gcm_ctx, sizeof(*gcm_ctx));
	free(gcm_ctx);
@


1.32
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.31 2016/11/04 17:30:30 miod Exp $ */
d810 2
d815 3
a817 1
			if (!c->encrypt)
d819 1
@


1.31
log
@Replace all uses of magic numbers when operating on OPENSSL_ia32_P[] by
meaningful constants in a private header file, so that reviewers can actually
get a chance to figure out what the code is attempting to do without knowing
all cpuid bits.

While there, turn it from an array of two 32-bit ints into a properly aligned
64-bit int.

Use of OPENSSL_ia32_P is now restricted to the assembler parts. C code will
now always use OPENSSL_cpu_caps() and check for the proper bits in the
whole 64-bit word it returns.

i386 tests and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.30 2016/11/04 13:56:05 miod Exp $ */
d228 1
a228 1
		EVPerr(EVP_F_AESNI_INIT_KEY, EVP_R_AES_KEY_SETUP_FAILED);
d566 1
a566 1
		EVPerr(EVP_F_AES_INIT_KEY, EVP_R_AES_KEY_SETUP_FAILED);
d1381 1
a1381 1
		EVPerr(EVP_F_AEAD_AES_GCM_INIT, EVP_R_BAD_KEY_LENGTH);
d1389 1
a1389 1
		EVPerr(EVP_F_AEAD_AES_GCM_INIT, EVP_R_TAG_TOO_LARGE);
d1435 1
a1435 1
		EVPerr(EVP_F_AEAD_AES_GCM_SEAL, EVP_R_BUFFER_TOO_SMALL);
d1474 1
a1474 1
		EVPerr(EVP_F_AEAD_AES_GCM_OPEN, EVP_R_BAD_DECRYPT);
d1481 1
a1481 1
		EVPerr(EVP_F_AEAD_AES_GCM_OPEN, EVP_R_BUFFER_TOO_SMALL);
d1503 1
a1503 1
		EVPerr(EVP_F_AEAD_AES_GCM_OPEN, EVP_R_BAD_DECRYPT);
@


1.30
log
@Remove I386_ONLY define. It was only used to prefer a
faster-on-genuine-80386-but-slower-on-80486-onwards innstruction sequence in
the SHA512 code, and had not been enabled in years, if at all.

ok tom@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.29 2015/09/10 15:56:25 jsing Exp $ */
d153 1
a153 1
extern unsigned int OPENSSL_ia32cap_P[];
d156 1
a156 1
#define VPAES_CAPABLE	(OPENSSL_ia32cap_P[1]&(1<<(41-32)))
d164 1
a164 1
#define	AESNI_CAPABLE	(OPENSSL_ia32cap_P[1]&(1<<(57-32)))
@


1.29
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.28 2015/06/20 12:01:14 jsing Exp $ */
d146 1
a146 1
#if	defined(AES_ASM) && !defined(I386_ONLY) &&	(  \
d153 1
a153 1
extern unsigned int OPENSSL_ia32cap_P[2];
@


1.28
log
@Replace remaining CRYPTO_memcmp() calls with timingsafe_memcmp().

ok doug@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.27 2015/02/10 09:50:12 miod Exp $ */
d693 1
a693 1
	OPENSSL_cleanse(gctx, sizeof(*gctx));
d975 1
a975 1
			OPENSSL_cleanse(out, len);
d1342 1
a1342 1
			OPENSSL_cleanse(out, len);
d1420 1
a1420 1
	OPENSSL_cleanse(gcm_ctx, sizeof(*gcm_ctx));
@


1.27
log
@Remove unnecessary include of assert.h
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.26 2014/10/22 13:02:04 jsing Exp $ */
d1502 1
a1502 1
	if (CRYPTO_memcmp(tag, in + plaintext_len, gcm_ctx->tag_len) != 0) {
@


1.26
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.25 2014/07/12 19:31:03 miod Exp $ */
a51 1
#include <assert.h>
@


1.25
log
@Make the BLOCK_CIPHER_{generic,custom} macros expand to more readable struct
definitions using C99 field initializers. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.24 2014/07/11 14:38:51 miod Exp $ */
d53 1
a61 1
#include <openssl/rand.h>
d772 2
a773 3
		if (c->encrypt &&
		    RAND_bytes(gctx->iv + arg, gctx->ivlen - arg) <= 0)
			return 0;
@


1.24
log
@Fix copy for CCM, GCM and XTS.

Internal pointers in CCM, GCM and XTS contexts should either be
NULL or set to point to the appropriate key schedule. This needs
to be adjusted when copying contexts.

OpenSSL PR #3272 with further fixes, from OpenSSL trunk
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.23 2014/07/10 22:45:57 jsing Exp $ */
d388 63
a450 42
#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
static const EVP_CIPHER aesni_##keylen##_##mode = { \
	nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aesni_init_key,			\
	aesni_##mode##_cipher,		\
	NULL,				\
	sizeof(EVP_AES_KEY),		\
	NULL,NULL,NULL,NULL }; \
static const EVP_CIPHER aes_##keylen##_##mode = { \
	nid##_##keylen##_##nmode,blocksize,	\
	keylen/8,ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aes_init_key,			\
	aes_##mode##_cipher,		\
	NULL,				\
	sizeof(EVP_AES_KEY),		\
	NULL,NULL,NULL,NULL }; \
const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }

#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
static const EVP_CIPHER aesni_##keylen##_##mode = { \
	nid##_##keylen##_##mode,blocksize, \
	(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aesni_##mode##_init_key,	\
	aesni_##mode##_cipher,		\
	aes_##mode##_cleanup,		\
	sizeof(EVP_AES_##MODE##_CTX),	\
	NULL,NULL,aes_##mode##_ctrl,NULL }; \
static const EVP_CIPHER aes_##keylen##_##mode = { \
	nid##_##keylen##_##mode,blocksize, \
	(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aes_##mode##_init_key,		\
	aes_##mode##_cipher,		\
	aes_##mode##_cleanup,		\
	sizeof(EVP_AES_##MODE##_CTX),	\
	NULL,NULL,aes_##mode##_ctrl,NULL }; \
const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
d454 38
a491 24
#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
static const EVP_CIPHER aes_##keylen##_##mode = { \
	nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aes_init_key,			\
	aes_##mode##_cipher,		\
	NULL,				\
	sizeof(EVP_AES_KEY),		\
	NULL,NULL,NULL,NULL }; \
const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
{ return &aes_##keylen##_##mode; }

#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
static const EVP_CIPHER aes_##keylen##_##mode = { \
	nid##_##keylen##_##mode,blocksize, \
	(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aes_##mode##_init_key,		\
	aes_##mode##_cipher,		\
	aes_##mode##_cleanup,		\
	sizeof(EVP_AES_##MODE##_CTX),	\
	NULL,NULL,aes_##mode##_ctrl,NULL }; \
const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
{ return &aes_##keylen##_##mode; }
@


1.23
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.22 2014/06/15 22:53:21 tedu Exp $ */
d788 21
d1016 4
a1019 3
#define CUSTOM_FLAGS	(EVP_CIPH_FLAG_DEFAULT_ASN1 \
		| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \
		| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)
d1033 14
a1046 2
	if (type != EVP_CTRL_INIT)
		return -1;
d1048 14
a1061 4
	/* key1 and key2 are used as an indicator both key and IV are set */
	xctx->xts.key1 = NULL;
	xctx->xts.key2 = NULL;
	return 1;
d1153 3
a1155 2
#define XTS_FLAGS	(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \
			 | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)
d1205 13
@


1.22
log
@free iv, then cleanse. from Cyril Jouve
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.21 2014/06/15 15:41:25 jsing Exp $ */
d52 3
d56 1
d58 2
d61 2
a62 4
#include <openssl/err.h>
#include <string.h>
#include <assert.h>
#include <openssl/aes.h>
a64 1
#include <openssl/rand.h>
@


1.21
log
@Add missing OPENSSL_cleanse() in aead_aes_gcm_cleanup().

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: e_aes.c,v 1.19 2014/06/12 15:49:29 deraadt Exp $ */
a653 1
	OPENSSL_cleanse(gctx, sizeof(*gctx));
d656 1
@


1.20
log
@The OPENSSL_cleanse() in aes_gcm_cleanup() only cleans the gcm field of the
EVP_AES_GCM_CTX, leaving the AES key untouched - clean the entire context,
rather than just part of it.

ok beck@@ miod@@
@
text
@d1326 1
@


1.19
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d654 1
a654 1
	OPENSSL_cleanse(&gctx->gcm, sizeof(gctx->gcm));
@


1.18
log
@Implement an improved version of the EVP AEAD API. The
EVP_AEAD_CTX_{open,seal} functions previously returned an ssize_t that was
overloaded to indicate success/failure, along with the number of bytes
written as output. This change adds an explicit *out_len argument which
is used to return the number of output bytes and the return value is now
an int that is purely used to identify success or failure.

This change effectively rides the last libcrypto crank (although I do not
expect there to be many users of the EVP AEAD API currently).

Thanks to Adam Langley for providing the improved code that this diff is
based on.

ok miod@@
@
text
@d1 1
@


1.17
log
@Convert OPENSSL_malloc stuff back to intrinsics, a few were missed
as new stuff was brought in.
ok miod@@
@
text
@d1284 1
d1287 1
a1287 1
		return 0;  /* EVP_AEAD_CTX_init should catch this. */
d1328 2
a1329 2
static ssize_t
aead_aes_gcm_seal(const EVP_AEAD_CTX *ctx, unsigned char *out,
a1333 1
	size_t bulk = 0;
d1336 1
d1340 1
a1340 1
		return -1;
d1347 1
a1347 1
		return -1;
d1352 1
a1352 1
			return -1;
d1356 1
a1356 1
			return -1;
d1360 3
a1362 1
	return in_len + gcm_ctx->tag_len;
d1365 2
a1366 2
static ssize_t
aead_aes_gcm_open(const EVP_AEAD_CTX *ctx, unsigned char *out,
a1370 1
	size_t bulk = 0;
a1372 1
	size_t out_len;
d1374 2
d1379 1
a1379 1
		return -1;
d1382 1
a1382 1
	out_len = in_len - gcm_ctx->tag_len;
d1384 1
a1384 1
	if (max_out_len < out_len) {
d1386 1
a1386 1
		return -1;
d1393 1
a1393 1
		return -1;
d1398 1
a1398 1
			return -1;
d1402 1
a1402 1
			return -1;
d1406 1
a1406 1
	if (CRYPTO_memcmp(tag, in + out_len, gcm_ctx->tag_len) != 0) {
d1408 1
a1408 1
		return -1;
d1411 3
a1413 1
	return out_len;
@


1.16
log
@KNF.
@
text
@d1297 1
a1297 1
	gcm_ctx = OPENSSL_malloc(sizeof(struct aead_aes_gcm_ctx));
d1324 1
a1324 1
	OPENSSL_free(gcm_ctx);
@


1.15
log
@Add an AEAD EVP interface to libcrypto, along with AES-GCM AEAD
implementations. This largely pulls in Adam Langley's AEAD patches from
Chromium's OpenSSL.

ok miod@@
@
text
@d661 2
a662 1
ctr64_inc(unsigned char *counter) {
d995 1
a995 1
BLOCK_CIPHER_custom(NID_aes, 128, 1,12, gcm, GCM,
d997 1
a997 1
BLOCK_CIPHER_custom(NID_aes, 192, 1,12, gcm, GCM,
d999 1
a999 1
BLOCK_CIPHER_custom(NID_aes, 256, 1,12, gcm, GCM,
d1108 2
a1109 2
BLOCK_CIPHER_custom(NID_aes, 128, 1,16, xts, XTS, EVP_CIPH_FLAG_FIPS|XTS_FLAGS)
BLOCK_CIPHER_custom(NID_aes, 256, 1,16, xts, XTS, EVP_CIPH_FLAG_FIPS|XTS_FLAGS)
d1258 1
a1258 1
BLOCK_CIPHER_custom(NID_aes, 128, 1,12, ccm, CCM,
d1260 1
a1260 1
BLOCK_CIPHER_custom(NID_aes, 192, 1,12, ccm, CCM,
d1262 1
a1262 1
BLOCK_CIPHER_custom(NID_aes, 256, 1,12, ccm, CCM,
d1394 1
a1394 1
		    in_len-bulk-gcm_ctx->tag_len, gcm_ctx->ctr))
@


1.14
log
@Nuke OPENSSL_FIPS - having #ifdefs inside a #ifndef for the same thing
is amusing.

ok deraadt@@
@
text
@d789 29
d827 2
a828 33
		do {
#ifdef BSAES_CAPABLE
			if (BSAES_CAPABLE) {
				AES_set_encrypt_key(key, ctx->key_len * 8,
				    &gctx->ks);
				CRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,
				    (block128_f)AES_encrypt);
				gctx->ctr =
				    (ctr128_f)bsaes_ctr32_encrypt_blocks;
				break;
			} else
#endif
#ifdef VPAES_CAPABLE
			if (VPAES_CAPABLE) {
				vpaes_set_encrypt_key(key, ctx->key_len * 8,
				    &gctx->ks);
				CRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,
				    (block128_f)vpaes_encrypt);
				gctx->ctr = NULL;
				break;
			} else
#endif
				(void)0; /* terminate potentially open 'else' */

			AES_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks);
			CRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,
			    (block128_f)AES_encrypt);
#ifdef AES_CTR_ASM
			gctx->ctr = (ctr128_f)AES_ctr32_encrypt;
#else
			gctx->ctr = NULL;
#endif
		} while (0);
d1263 182
@


1.13
log
@KNF.
@
text
@a58 1
#ifndef OPENSSL_FIPS
a693 5
#ifdef OPENSSL_FIPS
		if (FIPS_module_mode() &&
		    !(c->flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW) && arg < 12)
			return 0;
#endif
a1094 9
#ifdef OPENSSL_FIPS
	/* Requirement of SP800-38E */
	if (FIPS_module_mode() &&
	    !(ctx->flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW) &&
	    (len > (1UL << 20) * 16)) {
		EVPerr(EVP_F_AES_XTS_CIPHER, EVP_R_TOO_LARGE);
		return 0;
	}
#endif
a1265 1
#endif
@


1.12
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d9 1
a9 1
 *    notice, this list of conditions and the following disclaimer. 
d63 1
a63 2
typedef struct
	{
d70 1
a70 1
	} EVP_AES_KEY;
d72 1
a72 2
typedef struct
	{
d83 1
a83 1
	} EVP_AES_GCM_CTX;
d85 1
a85 2
typedef struct
	{
d88 4
a91 5
	void     (*stream)(const unsigned char *in,
			unsigned char *out, size_t length,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);
	} EVP_AES_XTS_CTX;
d93 1
a93 2
typedef struct
	{
d102 1
a102 1
	} EVP_AES_CCM_CTX;
d108 1
a108 1
			AES_KEY *key);
d110 1
a110 1
			AES_KEY *key);
d113 1
a113 1
			const AES_KEY *key);
d115 1
a115 1
			const AES_KEY *key);
d117 2
a118 5
void vpaes_cbc_encrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key,
			unsigned char *ivec, int enc);
d122 1
a122 2
			size_t length, const AES_KEY *key,
			unsigned char ivec[16], int enc);
d124 1
a124 2
			size_t len, const AES_KEY *key,
			const unsigned char ivec[16]);
d126 2
a127 2
			size_t len, const AES_KEY *key1,
			const AES_KEY *key2, const unsigned char iv[16]);
d129 2
a130 2
			size_t len, const AES_KEY *key1,
			const AES_KEY *key2, const unsigned char iv[16]);
d134 2
a135 2
			size_t blocks, const AES_KEY *key,
			const unsigned char ivec[AES_BLOCK_SIZE]);
d138 4
a141 6
void AES_xts_encrypt(const char *inp,char *out,size_t len,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);
void AES_xts_decrypt(const char *inp,char *out,size_t len,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);
d165 1
a165 1
			AES_KEY *key);
d167 1
a167 1
			AES_KEY *key);
d170 1
a170 1
			const AES_KEY *key);
d172 1
a172 1
			const AES_KEY *key);
d174 28
a201 46
void aesni_ecb_encrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key,
			int enc);
void aesni_cbc_encrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key,
			unsigned char *ivec, int enc);

void aesni_ctr32_encrypt_blocks(const unsigned char *in,
			unsigned char *out,
			size_t blocks,
			const void *key,
			const unsigned char *ivec);

void aesni_xts_encrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);

void aesni_xts_decrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);

void aesni_ccm64_encrypt_blocks (const unsigned char *in,
			unsigned char *out,
			size_t blocks,
			const void *key,
			const unsigned char ivec[16],
			unsigned char cmac[16]);

void aesni_ccm64_decrypt_blocks (const unsigned char *in,
			unsigned char *out,
			size_t blocks,
			const void *key,
			const unsigned char ivec[16],
			unsigned char cmac[16]);

static int aesni_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
		   const unsigned char *iv, int enc)
	{
d206 14
a219 15
	if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
	    && !enc)
		{ 
		ret = aesni_set_decrypt_key(key, ctx->key_len*8, ctx->cipher_data);
		dat->block	= (block128_f)aesni_decrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)aesni_cbc_encrypt :
					NULL;
		}
	else	{
		ret = aesni_set_encrypt_key(key, ctx->key_len*8, ctx->cipher_data);
		dat->block	= (block128_f)aesni_encrypt;
		if (mode==EVP_CIPH_CBC_MODE)
			dat->stream.cbc	= (cbc128_f)aesni_cbc_encrypt;
		else if (mode==EVP_CIPH_CTR_MODE)
d223 1
a223 1
		}
d225 2
a226 3
	if(ret < 0)
		{
		EVPerr(EVP_F_AESNI_INIT_KEY,EVP_R_AES_KEY_SETUP_FAILED);
d228 1
a228 1
		}
d231 1
a231 1
	}
d233 3
a235 2
static int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in, size_t len)
d237 2
a238 1
	aesni_cbc_encrypt(in,out,len,ctx->cipher_data,ctx->iv,ctx->encrypt);
d243 3
a245 2
static int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in, size_t len)
d249 2
a250 1
	if (len<bl)	return 1;
d252 1
a252 1
	aesni_ecb_encrypt(in,out,len,ctx->cipher_data,ctx->encrypt);
d258 2
a259 2
static int aesni_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len);
d262 2
a263 2
static int aesni_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len);
d266 2
a267 2
static int aesni_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len);
d270 2
a271 2
static int aesni_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len);
d275 1
a275 1
		const unsigned char *in, size_t len);
d277 4
a280 3
static int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
d282 1
d285 1
a285 2
	if (key)
		{
d288 1
a288 1
				(block128_f)aesni_encrypt);
d295 1
a295 2
		if (iv)
			{
d298 1
a298 1
			}
d300 1
a300 3
		}
	else
		{
d308 1
a308 1
		}
d310 1
a310 1
	}
d314 1
a314 1
		const unsigned char *in, size_t len);
d316 4
a319 3
static int aesni_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
d321 1
d325 1
a325 2
	if (key)
		{
d327 3
a329 3
		if (enc)
			{
			aesni_set_encrypt_key(key, ctx->key_len * 4, &xctx->ks1);
d332 3
a334 4
			}
		else
			{
			aesni_set_decrypt_key(key, ctx->key_len * 4, &xctx->ks1);
d337 1
a337 1
			}
d339 2
a340 2
		aesni_set_encrypt_key(key + ctx->key_len/2,
						ctx->key_len * 4, &xctx->ks2);
d344 1
a344 1
		}
d346 1
a346 2
	if (iv)
		{
d349 1
a349 1
		}
d352 1
a352 1
	}
d356 1
a356 1
		const unsigned char *in, size_t len);
d358 4
a361 3
static int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
d363 1
d366 1
a366 2
	if (key)
		{
d369 3
a371 3
					&cctx->ks, (block128_f)aesni_encrypt);
		cctx->str = enc?(ccm128_f)aesni_ccm64_encrypt_blocks :
				(ccm128_f)aesni_ccm64_decrypt_blocks;
d373 2
a374 3
		}
	if (iv)
		{
d377 1
a377 1
		}
d379 1
a379 1
	}
d383 1
a383 1
		const unsigned char *in, size_t len);
d465 4
a468 3
static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
		   const unsigned char *iv, int enc)
	{
d473 2
a474 2
	if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
	    && !enc)
d476 6
a481 7
	    if (BSAES_CAPABLE && mode==EVP_CIPH_CBC_MODE)
		{
		ret = AES_set_decrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)AES_decrypt;
		dat->stream.cbc	= (cbc128_f)bsaes_cbc_encrypt;
		}
	    else
d484 7
a490 9
	    if (VPAES_CAPABLE)
		{
		ret = vpaes_set_decrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)vpaes_decrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)vpaes_cbc_encrypt :
					NULL;
		}
	    else
d493 6
a498 7
		ret = AES_set_decrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)AES_decrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)AES_cbc_encrypt :
					NULL;
		}
	else
d500 6
a505 7
	    if (BSAES_CAPABLE && mode==EVP_CIPH_CTR_MODE)
		{
		ret = AES_set_encrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)AES_encrypt;
		dat->stream.ctr	= (ctr128_f)bsaes_ctr32_encrypt_blocks;
		}
	    else
d508 7
a514 9
	    if (VPAES_CAPABLE)
		{
		ret = vpaes_set_encrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)vpaes_encrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)vpaes_cbc_encrypt :
					NULL;
		}
	    else
d517 5
a521 5
		ret = AES_set_encrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)AES_encrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)AES_cbc_encrypt :
					NULL;
d523 2
a524 2
		if (mode==EVP_CIPH_CTR_MODE)
			dat->stream.ctr = (ctr128_f)AES_ctr32_encrypt;
d528 2
a529 3
	if(ret < 0)
		{
		EVPerr(EVP_F_AES_INIT_KEY,EVP_R_AES_KEY_SETUP_FAILED);
d531 1
a531 1
		}
d534 1
a534 1
	}
d536 3
a538 2
static int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in, size_t len)
d543 2
a544 1
		(*dat->stream.cbc)(in,out,len,&dat->ks,ctx->iv,ctx->encrypt);
d546 2
a547 1
		CRYPTO_cbc128_encrypt(in,out,len,&dat->ks,ctx->iv,dat->block);
d549 2
a550 1
		CRYPTO_cbc128_decrypt(in,out,len,&dat->ks,ctx->iv,dat->block);
d555 3
a557 2
static int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in, size_t len)
d563 2
a564 1
	if (len<bl)	return 1;
d566 2
a567 2
	for (i=0,len-=bl;i<=len;i+=bl)
		(*dat->block)(in+i,out+i,&dat->ks);
d572 3
a574 2
static int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len)
d578 2
a579 2
	CRYPTO_ofb128_encrypt(in,out,len,&dat->ks,
			ctx->iv,&ctx->num,dat->block);
d583 3
a585 2
static int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len)
d589 2
a590 2
	CRYPTO_cfb128_encrypt(in,out,len,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
d594 3
a596 2
static int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len)
d600 2
a601 2
	CRYPTO_cfb128_8_encrypt(in,out,len,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
d605 3
a607 2
static int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len)
d612 2
a613 2
		CRYPTO_cfb128_1_encrypt(in,out,len,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
d617 4
a620 4
	while (len>=MAXBITCHUNK) {
		CRYPTO_cfb128_1_encrypt(in,out,MAXBITCHUNK*8,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
		len-=MAXBITCHUNK;
d623 3
a625 3
		CRYPTO_cfb128_1_encrypt(in,out,len*8,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
	
d630 1
a630 1
		const unsigned char *in, size_t len)
d636 2
a637 2
		CRYPTO_ctr128_encrypt_ctr32(in,out,len,&dat->ks,
			ctx->iv,ctx->buf,&num,dat->stream.ctr);
d639 2
a640 2
		CRYPTO_ctr128_encrypt(in,out,len,&dat->ks,
			ctx->iv,ctx->buf,&num,dat->block);
d645 3
a647 3
BLOCK_CIPHER_generic_pack(NID_aes,128,EVP_CIPH_FLAG_FIPS)
BLOCK_CIPHER_generic_pack(NID_aes,192,EVP_CIPH_FLAG_FIPS)
BLOCK_CIPHER_generic_pack(NID_aes,256,EVP_CIPH_FLAG_FIPS)
d649 3
a651 2
static int aes_gcm_cleanup(EVP_CIPHER_CTX *c)
	{
d653 1
d658 1
a658 1
	}
d661 3
a663 2
static void ctr64_inc(unsigned char *counter) {
	int n=8;
d671 2
a672 1
		if (c) return;
d676 3
a678 2
static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
	{
d680 2
a681 2
	switch (type)
		{
d696 2
a697 2
		if (FIPS_module_mode() && !(c->flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW)
						 && arg < 12)
d701 1
a701 2
		if ((arg > EVP_MAX_IV_LENGTH) && (arg > gctx->ivlen))
			{
d707 1
a707 1
			}
d726 1
a726 2
		if (arg == -1)
			{
d730 1
a730 1
			}
d739 1
a739 1
			RAND_bytes(gctx->iv + arg, gctx->ivlen - arg) <= 0)
d773 4
a776 2
			{
			unsigned int len=c->buf[arg-2]<<8|c->buf[arg-1];
d779 1
d783 3
a785 3
                        c->buf[arg-2] = len>>8;
                        c->buf[arg-1] = len & 0xff;
			}
a791 1
		}
d793 1
d795 4
a798 3
static int aes_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
d800 1
d803 2
a804 2
	if (key)
		{ do {
d806 9
a814 9
		if (BSAES_CAPABLE)
			{
			AES_set_encrypt_key(key,ctx->key_len*8,&gctx->ks);
			CRYPTO_gcm128_init(&gctx->gcm,&gctx->ks,
					(block128_f)AES_encrypt);
			gctx->ctr = (ctr128_f)bsaes_ctr32_encrypt_blocks;
			break;
			}
		else
d817 14
a830 14
		if (VPAES_CAPABLE)
			{
			vpaes_set_encrypt_key(key,ctx->key_len*8,&gctx->ks);
			CRYPTO_gcm128_init(&gctx->gcm,&gctx->ks,
					(block128_f)vpaes_encrypt);
			gctx->ctr = NULL;
			break;
			}
		else
#endif
		(void)0;	/* terminate potentially open 'else' */

		AES_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks);
		CRYPTO_gcm128_init(&gctx->gcm, &gctx->ks, (block128_f)AES_encrypt);
d832 1
a832 1
		gctx->ctr = (ctr128_f)AES_ctr32_encrypt;
d834 1
a834 1
		gctx->ctr = NULL;
d843 1
a843 2
		if (iv)
			{
d846 1
a846 1
			}
d848 1
a848 3
		}
	else
		{
d856 1
a856 1
		}
d858 1
a858 1
	}
d866 4
a869 3
static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len)
	{
d872 1
d874 2
a875 1
	if (out != in || len < (EVP_GCM_TLS_EXPLICIT_IV_LEN+EVP_GCM_TLS_TAG_LEN))
d877 1
d882 2
a883 2
				EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV,
				EVP_GCM_TLS_EXPLICIT_IV_LEN, out) <= 0)
d885 1
d889 1
d894 1
a894 2
	if (ctx->encrypt)
		{
d896 3
a898 5
		if (gctx->ctr)
			{
			if (CRYPTO_gcm128_encrypt_ctr32(&gctx->gcm,
							in, out, len,
							gctx->ctr))
d900 1
a900 2
			}
		else	{
d903 1
a903 1
			}
d905 1
d909 1
a909 3
		}
	else
		{
d911 3
a913 5
		if (gctx->ctr)
			{
			if (CRYPTO_gcm128_decrypt_ctr32(&gctx->gcm,
							in, out, len,
							gctx->ctr))
d915 1
a915 2
			}
		else	{
d918 1
a918 1
			}
d920 2
a921 2
		CRYPTO_gcm128_tag(&gctx->gcm, ctx->buf,
					EVP_GCM_TLS_TAG_LEN);
d923 1
a923 2
		if (memcmp(ctx->buf, in + len, EVP_GCM_TLS_TAG_LEN))
			{
d926 1
a926 1
			}
d928 1
a928 1
		}
d930 1
a930 1
	err:
d934 1
a934 1
	}
d936 4
a939 3
static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len)
	{
d941 1
d951 3
a953 4
	if (in)
		{
		if (out == NULL)
			{
d956 2
a957 5
			}
		else if (ctx->encrypt)
			{
			if (gctx->ctr)
				{
d959 1
a959 2
							in, out, len,
							gctx->ctr))
d961 3
a963 3
				}
			else	{
				if (CRYPTO_gcm128_encrypt(&gctx->gcm, in, out, len))
a964 1
				}
d966 2
a967 4
		else
			{
			if (gctx->ctr)
				{
d969 1
a969 2
							in, out, len,
							gctx->ctr))
d971 3
a973 3
				}
			else	{
				if (CRYPTO_gcm128_decrypt(&gctx->gcm, in, out, len))
a974 1
				}
d976 1
d978 2
a979 5
		}
	else
		{
		if (!ctx->encrypt)
			{
d982 2
a983 2
			if (CRYPTO_gcm128_finish(&gctx->gcm,
					ctx->buf, gctx->taglen) != 0)
d987 1
a987 1
			}
d990 1
d994 1
a994 1
		}
d996 1
a996 1
	}
d1002 6
a1007 6
BLOCK_CIPHER_custom(NID_aes,128,1,12,gcm,GCM,
		EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_AEAD_CIPHER|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes,192,1,12,gcm,GCM,
		EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_AEAD_CIPHER|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes,256,1,12,gcm,GCM,
		EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_AEAD_CIPHER|CUSTOM_FLAGS)
d1009 3
a1011 2
static int aes_xts_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
	{
d1013 1
d1016 1
d1021 1
a1021 1
	}
d1023 4
a1026 3
static int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
d1028 1
d1032 1
a1032 2
	if (key) do
		{
d1041 2
a1042 1
			xctx->stream = enc ? bsaes_xts_encrypt : bsaes_xts_decrypt;
d1046 14
a1059 12
		if (VPAES_CAPABLE)
		    {
		    if (enc)
			{
			vpaes_set_encrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)vpaes_encrypt;
			}
		    else
			{
			vpaes_set_decrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)vpaes_decrypt;
			}
d1061 3
a1063 8
		    vpaes_set_encrypt_key(key + ctx->key_len/2,
						ctx->key_len * 4, &xctx->ks2);
		    xctx->xts.block2 = (block128_f)vpaes_encrypt;

		    xctx->xts.key1 = &xctx->ks1;
		    break;
		    }
		else
d1065 1
a1065 1
		(void)0;	/* terminate potentially open 'else' */
d1067 1
a1067 2
		if (enc)
			{
d1070 1
a1070 3
			}
		else
			{
d1073 1
a1073 1
			}
d1075 2
a1076 2
		AES_set_encrypt_key(key + ctx->key_len/2,
						ctx->key_len * 4, &xctx->ks2);
d1080 1
a1080 1
		} while (0);
d1082 1
a1082 2
	if (iv)
		{
d1085 1
a1085 1
		}
d1088 1
a1088 1
	}
d1090 4
a1093 3
static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len)
	{
d1095 1
d1098 1
a1098 1
	if (!out || !in || len<AES_BLOCK_SIZE)
d1100 1
d1103 3
a1105 3
	if (FIPS_module_mode() && !(ctx->flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW) &&
			(len > (1UL<<20)*16))
		{
d1108 1
a1108 1
		}
d1111 2
a1112 2
		(*xctx->stream)(in, out, len,
				xctx->xts.key1, xctx->xts.key2, ctx->iv);
d1114 1
a1114 1
								ctx->encrypt))
d1117 1
a1117 1
	}
d1124 2
a1125 2
BLOCK_CIPHER_custom(NID_aes,128,1,16,xts,XTS,EVP_CIPH_FLAG_FIPS|XTS_FLAGS)
BLOCK_CIPHER_custom(NID_aes,256,1,16,xts,XTS,EVP_CIPH_FLAG_FIPS|XTS_FLAGS)
d1127 3
a1129 2
static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
	{
d1131 2
a1132 2
	switch (type)
		{
d1144 1
d1156 1
a1156 2
		if (ptr)
			{
d1159 1
a1159 1
			}
d1166 1
a1166 1
		if(!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg))
a1174 2

		}
d1176 1
d1178 4
a1181 3
static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
d1183 1
d1186 1
a1186 2
	if (key) do
		{
d1188 1
a1188 2
		if (VPAES_CAPABLE)
			{
d1191 1
a1191 1
					&cctx->ks, (block128_f)vpaes_encrypt);
d1195 1
a1195 1
			}
d1199 1
a1199 1
					&cctx->ks, (block128_f)AES_encrypt);
d1202 2
a1203 3
		} while (0);
	if (iv)
		{
d1206 1
a1206 1
		}
d1208 1
a1208 1
	}
d1210 4
a1213 3
static int aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len)
	{
d1216 1
d1222 5
a1226 5
	if (!out)
		{
		if (!in)
			{
			if (CRYPTO_ccm128_setiv(ccm, ctx->iv, 15 - cctx->L,len))
d1230 1
a1230 1
			}
d1236 1
a1236 1
		}
d1241 1
a1241 2
	if (!cctx->len_set)
		{
d1245 2
a1246 3
		}
	if (ctx->encrypt)
		{
d1248 1
a1248 2
						cctx->str) :
				CRYPTO_ccm128_encrypt(ccm, in, out, len))
d1252 1
a1252 3
		}
	else
		{
d1255 1
a1255 3
						cctx->str) :
				!CRYPTO_ccm128_decrypt(ccm, in, out, len))
			{
d1257 1
a1257 2
			if (CRYPTO_ccm128_tag(ccm, tag, cctx->M))
				{
a1259 1
				}
d1261 1
d1268 1
a1268 1
		}
d1270 1
a1270 1
	}
d1274 6
a1279 3
BLOCK_CIPHER_custom(NID_aes,128,1,12,ccm,CCM,EVP_CIPH_FLAG_FIPS|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes,192,1,12,ccm,CCM,EVP_CIPH_FLAG_FIPS|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes,256,1,12,ccm,CCM,EVP_CIPH_FLAG_FIPS|CUSTOM_FLAGS)
@


1.11
log
@call the correct decrypt function in aes_cbc_cipher()

From:

commit e9c80e04c1a3b5a0de8e666155ab4ecb2697a77d
Author: Andy Polyakov <appro@@openssl.org>
Date:   Wed Dec 18 21:42:46 2013 +0100

    evp/e_[aes|camellia].c: fix typo in CBC subroutine.

    It worked because it was never called.

Our e_camellia.c does not have this problem.

ok miod@@ deraadt@@
@
text
@d682 1
a682 1
		OPENSSL_free(gctx->iv);
d727 2
a728 2
				OPENSSL_free(gctx->iv);
			gctx->iv = OPENSSL_malloc(arg);
@


1.10
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d584 1
a584 1
		CRYPTO_cbc128_encrypt(in,out,len,&dat->ks,ctx->iv,dat->block);
@


1.9
log
@resolve conflicts
@
text
@d845 1
d847 2
a974 2
	if (!ctx->encrypt && gctx->taglen < 0)
		return -1;
d1016 2
d1089 1
a1089 1
		vpaes_set_encrypt_key(key + ctx->key_len/2,
d1091 1
a1091 1
		xctx->xts.block2 = (block128_f)vpaes_encrypt;
d1093 4
a1096 3
		xctx->xts.key1 = &xctx->ks1;
		break;
		}
d1098 2
d1226 1
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d2 1
a2 1
 * Copyright (c) 2001 The OpenSSL Project.  All rights reserved.
d59 3
a61 3

static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
					const unsigned char *iv, int enc);
d66 5
d73 272
a344 1
#define data(ctx)	EVP_C_DATA(EVP_AES_KEY,ctx)
d346 149
a494 28
IMPLEMENT_BLOCK_CIPHER(aes_128, ks, AES, EVP_AES_KEY,
		       NID_aes_128, 16, 16, 16, 128,
		       0, aes_init_key, NULL, 
		       EVP_CIPHER_set_asn1_iv,
		       EVP_CIPHER_get_asn1_iv,
		       NULL)
IMPLEMENT_BLOCK_CIPHER(aes_192, ks, AES, EVP_AES_KEY,
		       NID_aes_192, 16, 24, 16, 128,
		       0, aes_init_key, NULL, 
		       EVP_CIPHER_set_asn1_iv,
		       EVP_CIPHER_get_asn1_iv,
		       NULL)
IMPLEMENT_BLOCK_CIPHER(aes_256, ks, AES, EVP_AES_KEY,
		       NID_aes_256, 16, 32, 16, 128,
		       0, aes_init_key, NULL, 
		       EVP_CIPHER_set_asn1_iv,
		       EVP_CIPHER_get_asn1_iv,
		       NULL)

#define IMPLEMENT_AES_CFBR(ksize,cbits)	IMPLEMENT_CFBR(aes,AES,EVP_AES_KEY,ks,ksize,cbits,16)

IMPLEMENT_AES_CFBR(128,1)
IMPLEMENT_AES_CFBR(192,1)
IMPLEMENT_AES_CFBR(256,1)

IMPLEMENT_AES_CFBR(128,8)
IMPLEMENT_AES_CFBR(192,8)
IMPLEMENT_AES_CFBR(256,8)
d499 2
a500 1
	int ret;
d502 30
a531 4
	if ((ctx->cipher->flags & EVP_CIPH_MODE) == EVP_CIPH_CFB_MODE
	    || (ctx->cipher->flags & EVP_CIPH_MODE) == EVP_CIPH_OFB_MODE
	    || enc) 
		ret=AES_set_encrypt_key(key, ctx->key_len * 8, ctx->cipher_data);
d533 31
a563 1
		ret=AES_set_decrypt_key(key, ctx->key_len * 8, ctx->cipher_data);
d574 739
@


1.7
log
@resolve conflicts
@
text
@d72 4
a75 3
		       EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_DEFAULT_ASN1,
		       aes_init_key,
		       NULL, NULL, NULL, NULL)
d78 4
a81 3
		       EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_DEFAULT_ASN1,
		       aes_init_key,
		       NULL, NULL, NULL, NULL)
d84 4
a87 3
		       EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_DEFAULT_ASN1,
		       aes_init_key,
		       NULL, NULL, NULL, NULL)
d89 1
a89 1
#define IMPLEMENT_AES_CFBR(ksize,cbits,flags)	IMPLEMENT_CFBR(aes,AES,EVP_AES_KEY,ks,ksize,cbits,16,flags)
d91 3
a93 3
IMPLEMENT_AES_CFBR(128,1,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(192,1,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(256,1,EVP_CIPH_FLAG_FIPS)
d95 3
a97 3
IMPLEMENT_AES_CFBR(128,8,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(192,8,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(256,8,EVP_CIPH_FLAG_FIPS)
@


1.6
log
@resolve conflicts
@
text
@d72 3
a74 4
		       0, aes_init_key, NULL, 
		       EVP_CIPHER_set_asn1_iv,
		       EVP_CIPHER_get_asn1_iv,
		       NULL)
d77 3
a79 4
		       0, aes_init_key, NULL, 
		       EVP_CIPHER_set_asn1_iv,
		       EVP_CIPHER_get_asn1_iv,
		       NULL)
d82 3
a84 4
		       0, aes_init_key, NULL, 
		       EVP_CIPHER_set_asn1_iv,
		       EVP_CIPHER_get_asn1_iv,
		       NULL)
d86 1
a86 1
#define IMPLEMENT_AES_CFBR(ksize,cbits)	IMPLEMENT_CFBR(aes,AES,EVP_AES_KEY,ks,ksize,cbits,16)
d88 3
a90 3
IMPLEMENT_AES_CFBR(128,1)
IMPLEMENT_AES_CFBR(192,1)
IMPLEMENT_AES_CFBR(256,1)
d92 3
a94 3
IMPLEMENT_AES_CFBR(128,8)
IMPLEMENT_AES_CFBR(192,8)
IMPLEMENT_AES_CFBR(256,8)
@


1.5
log
@resolve conflicts
@
text
@d51 1
d56 1
d72 1
a72 1
		       EVP_CIPH_FLAG_FIPS, aes_init_key, NULL, 
d78 1
a78 1
		       EVP_CIPH_FLAG_FIPS, aes_init_key, NULL, 
d84 1
a84 1
		       EVP_CIPH_FLAG_FIPS, aes_init_key, NULL, 
d89 1
a89 1
#define IMPLEMENT_AES_CFBR(ksize,cbits,flags)	IMPLEMENT_CFBR(aes,AES,EVP_AES_KEY,ks,ksize,cbits,16,flags)
d91 7
a97 7
IMPLEMENT_AES_CFBR(128,1,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(192,1,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(256,1,EVP_CIPH_FLAG_FIPS)

IMPLEMENT_AES_CFBR(128,8,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(192,8,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(256,8,EVP_CIPH_FLAG_FIPS)
@


1.4
log
@resolve conflicts
@
text
@d89 3
a91 3
IMPLEMENT_AES_CFBR(128,1,0)
IMPLEMENT_AES_CFBR(192,1,0)
IMPLEMENT_AES_CFBR(256,1,0)
@


1.3
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d70 1
a70 1
		       0, aes_init_key, NULL, 
d76 1
a76 1
		       0, aes_init_key, NULL, 
d82 1
a82 1
		       0, aes_init_key, NULL, 
d87 10
d98 3
a100 1
		   const unsigned char *iv, int enc) {
d105 1
a105 1
		AES_set_encrypt_key(key, ctx->key_len * 8, ctx->cipher_data);
d107 7
a113 1
		AES_set_decrypt_key(key, ctx->key_len * 8, ctx->cipher_data);
d116 1
a116 1
}
@


1.2
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@a54 1
#include <assert.h>
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d91 3
a93 1
	if (enc) 
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d91 1
a91 3
	if ((ctx->cipher->flags & EVP_CIPH_MODE) == EVP_CIPH_CFB_MODE
	    || (ctx->cipher->flags & EVP_CIPH_MODE) == EVP_CIPH_OFB_MODE
	    || enc) 
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d55 1
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d70 1
a70 1
		       EVP_CIPH_FLAG_FIPS, aes_init_key, NULL, 
d76 1
a76 1
		       EVP_CIPH_FLAG_FIPS, aes_init_key, NULL, 
d82 1
a82 1
		       EVP_CIPH_FLAG_FIPS, aes_init_key, NULL, 
a86 10
#define IMPLEMENT_AES_CFBR(ksize,cbits,flags)	IMPLEMENT_CFBR(aes,AES,EVP_AES_KEY,ks,ksize,cbits,16,flags)

IMPLEMENT_AES_CFBR(128,1,0)
IMPLEMENT_AES_CFBR(192,1,0)
IMPLEMENT_AES_CFBR(256,1,0)

IMPLEMENT_AES_CFBR(128,8,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(192,8,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(256,8,EVP_CIPH_FLAG_FIPS)

d88 1
a88 3
		   const unsigned char *iv, int enc)
	{
	int ret;
d93 1
a93 1
		ret=AES_set_encrypt_key(key, ctx->key_len * 8, ctx->cipher_data);
d95 1
a95 7
		ret=AES_set_decrypt_key(key, ctx->key_len * 8, ctx->cipher_data);

	if(ret < 0)
		{
		EVPerr(EVP_F_AES_INIT_KEY,EVP_R_AES_KEY_SETUP_FAILED);
		return 0;
		}
d98 1
a98 1
	}
@


1.1.1.4
log
@import of openssl-0.9.7j
@
text
@d89 3
a91 3
IMPLEMENT_AES_CFBR(128,1,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(192,1,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(256,1,EVP_CIPH_FLAG_FIPS)
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@a50 1
#include <openssl/opensslconf.h>
a54 1
#include <assert.h>
d70 1
a70 1
		       0, aes_init_key, NULL, 
d76 1
a76 1
		       0, aes_init_key, NULL, 
d82 1
a82 1
		       0, aes_init_key, NULL, 
d87 1
a87 1
#define IMPLEMENT_AES_CFBR(ksize,cbits)	IMPLEMENT_CFBR(aes,AES,EVP_AES_KEY,ks,ksize,cbits,16)
d89 7
a95 7
IMPLEMENT_AES_CFBR(128,1)
IMPLEMENT_AES_CFBR(192,1)
IMPLEMENT_AES_CFBR(256,1)

IMPLEMENT_AES_CFBR(128,8)
IMPLEMENT_AES_CFBR(192,8)
IMPLEMENT_AES_CFBR(256,8)
@


1.1.1.6
log
@import openssl-0.9.8j
@
text
@d72 4
a75 3
		       EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_DEFAULT_ASN1,
		       aes_init_key,
		       NULL, NULL, NULL, NULL)
d78 4
a81 3
		       EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_DEFAULT_ASN1,
		       aes_init_key,
		       NULL, NULL, NULL, NULL)
d84 4
a87 3
		       EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_DEFAULT_ASN1,
		       aes_init_key,
		       NULL, NULL, NULL, NULL)
d89 1
a89 1
#define IMPLEMENT_AES_CFBR(ksize,cbits,flags)	IMPLEMENT_CFBR(aes,AES,EVP_AES_KEY,ks,ksize,cbits,16,flags)
d91 3
a93 3
IMPLEMENT_AES_CFBR(128,1,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(192,1,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(256,1,EVP_CIPH_FLAG_FIPS)
d95 3
a97 3
IMPLEMENT_AES_CFBR(128,8,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(192,8,EVP_CIPH_FLAG_FIPS)
IMPLEMENT_AES_CFBR(256,8,EVP_CIPH_FLAG_FIPS)
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d72 3
a74 4
		       0, aes_init_key, NULL, 
		       EVP_CIPHER_set_asn1_iv,
		       EVP_CIPHER_get_asn1_iv,
		       NULL)
d77 3
a79 4
		       0, aes_init_key, NULL, 
		       EVP_CIPHER_set_asn1_iv,
		       EVP_CIPHER_get_asn1_iv,
		       NULL)
d82 3
a84 4
		       0, aes_init_key, NULL, 
		       EVP_CIPHER_set_asn1_iv,
		       EVP_CIPHER_get_asn1_iv,
		       NULL)
d86 1
a86 1
#define IMPLEMENT_AES_CFBR(ksize,cbits)	IMPLEMENT_CFBR(aes,AES,EVP_AES_KEY,ks,ksize,cbits,16)
d88 3
a90 3
IMPLEMENT_AES_CFBR(128,1)
IMPLEMENT_AES_CFBR(192,1)
IMPLEMENT_AES_CFBR(256,1)
d92 3
a94 3
IMPLEMENT_AES_CFBR(128,8)
IMPLEMENT_AES_CFBR(192,8)
IMPLEMENT_AES_CFBR(256,8)
@


1.1.1.8
log
@import OpenSSL-1.0.1c
@
text
@d2 1
a2 1
 * Copyright (c) 2001-2011 The OpenSSL Project.  All rights reserved.
d59 3
a61 3
#ifndef OPENSSL_FIPS
#include "modes_lcl.h"
#include <openssl/rand.h>
a65 5
	block128_f block;
	union {
		cbc128_f cbc;
		ctr128_f ctr;
	} stream;
d68 1
a68 272
typedef struct
	{
	AES_KEY ks;		/* AES key schedule to use */
	int key_set;		/* Set if key initialised */
	int iv_set;		/* Set if an iv is set */
	GCM128_CONTEXT gcm;
	unsigned char *iv;	/* Temporary IV store */
	int ivlen;		/* IV length */
	int taglen;
	int iv_gen;		/* It is OK to generate IVs */
	int tls_aad_len;	/* TLS AAD length */
	ctr128_f ctr;
	} EVP_AES_GCM_CTX;

typedef struct
	{
	AES_KEY ks1, ks2;	/* AES key schedules to use */
	XTS128_CONTEXT xts;
	void     (*stream)(const unsigned char *in,
			unsigned char *out, size_t length,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);
	} EVP_AES_XTS_CTX;

typedef struct
	{
	AES_KEY ks;		/* AES key schedule to use */
	int key_set;		/* Set if key initialised */
	int iv_set;		/* Set if an iv is set */
	int tag_set;		/* Set if tag is valid */
	int len_set;		/* Set if message length set */
	int L, M;		/* L and M parameters from RFC3610 */
	CCM128_CONTEXT ccm;
	ccm128_f str;
	} EVP_AES_CCM_CTX;

#define MAXBITCHUNK	((size_t)1<<(sizeof(size_t)*8-4))

#ifdef VPAES_ASM
int vpaes_set_encrypt_key(const unsigned char *userKey, int bits,
			AES_KEY *key);
int vpaes_set_decrypt_key(const unsigned char *userKey, int bits,
			AES_KEY *key);

void vpaes_encrypt(const unsigned char *in, unsigned char *out,
			const AES_KEY *key);
void vpaes_decrypt(const unsigned char *in, unsigned char *out,
			const AES_KEY *key);

void vpaes_cbc_encrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key,
			unsigned char *ivec, int enc);
#endif
#ifdef BSAES_ASM
void bsaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
			size_t length, const AES_KEY *key,
			unsigned char ivec[16], int enc);
void bsaes_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
			size_t len, const AES_KEY *key,
			const unsigned char ivec[16]);
void bsaes_xts_encrypt(const unsigned char *inp, unsigned char *out,
			size_t len, const AES_KEY *key1,
			const AES_KEY *key2, const unsigned char iv[16]);
void bsaes_xts_decrypt(const unsigned char *inp, unsigned char *out,
			size_t len, const AES_KEY *key1,
			const AES_KEY *key2, const unsigned char iv[16]);
#endif
#ifdef AES_CTR_ASM
void AES_ctr32_encrypt(const unsigned char *in, unsigned char *out,
			size_t blocks, const AES_KEY *key,
			const unsigned char ivec[AES_BLOCK_SIZE]);
#endif
#ifdef AES_XTS_ASM
void AES_xts_encrypt(const char *inp,char *out,size_t len,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);
void AES_xts_decrypt(const char *inp,char *out,size_t len,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);
#endif

#if	defined(AES_ASM) && !defined(I386_ONLY) &&	(  \
	((defined(__i386)	|| defined(__i386__)	|| \
	  defined(_M_IX86)) && defined(OPENSSL_IA32_SSE2))|| \
	defined(__x86_64)	|| defined(__x86_64__)	|| \
	defined(_M_AMD64)	|| defined(_M_X64)	|| \
	defined(__INTEL__)				)

extern unsigned int OPENSSL_ia32cap_P[2];

#ifdef VPAES_ASM
#define VPAES_CAPABLE	(OPENSSL_ia32cap_P[1]&(1<<(41-32)))
#endif
#ifdef BSAES_ASM
#define BSAES_CAPABLE	VPAES_CAPABLE
#endif
/*
 * AES-NI section
 */
#define	AESNI_CAPABLE	(OPENSSL_ia32cap_P[1]&(1<<(57-32)))

int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
			AES_KEY *key);
int aesni_set_decrypt_key(const unsigned char *userKey, int bits,
			AES_KEY *key);

void aesni_encrypt(const unsigned char *in, unsigned char *out,
			const AES_KEY *key);
void aesni_decrypt(const unsigned char *in, unsigned char *out,
			const AES_KEY *key);

void aesni_ecb_encrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key,
			int enc);
void aesni_cbc_encrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key,
			unsigned char *ivec, int enc);

void aesni_ctr32_encrypt_blocks(const unsigned char *in,
			unsigned char *out,
			size_t blocks,
			const void *key,
			const unsigned char *ivec);

void aesni_xts_encrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);

void aesni_xts_decrypt(const unsigned char *in,
			unsigned char *out,
			size_t length,
			const AES_KEY *key1, const AES_KEY *key2,
			const unsigned char iv[16]);

void aesni_ccm64_encrypt_blocks (const unsigned char *in,
			unsigned char *out,
			size_t blocks,
			const void *key,
			const unsigned char ivec[16],
			unsigned char cmac[16]);

void aesni_ccm64_decrypt_blocks (const unsigned char *in,
			unsigned char *out,
			size_t blocks,
			const void *key,
			const unsigned char ivec[16],
			unsigned char cmac[16]);

static int aesni_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
		   const unsigned char *iv, int enc)
	{
	int ret, mode;
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	mode = ctx->cipher->flags & EVP_CIPH_MODE;
	if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
	    && !enc)
		{ 
		ret = aesni_set_decrypt_key(key, ctx->key_len*8, ctx->cipher_data);
		dat->block	= (block128_f)aesni_decrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)aesni_cbc_encrypt :
					NULL;
		}
	else	{
		ret = aesni_set_encrypt_key(key, ctx->key_len*8, ctx->cipher_data);
		dat->block	= (block128_f)aesni_encrypt;
		if (mode==EVP_CIPH_CBC_MODE)
			dat->stream.cbc	= (cbc128_f)aesni_cbc_encrypt;
		else if (mode==EVP_CIPH_CTR_MODE)
			dat->stream.ctr = (ctr128_f)aesni_ctr32_encrypt_blocks;
		else
			dat->stream.cbc = NULL;
		}

	if(ret < 0)
		{
		EVPerr(EVP_F_AESNI_INIT_KEY,EVP_R_AES_KEY_SETUP_FAILED);
		return 0;
		}

	return 1;
	}

static int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in, size_t len)
{
	aesni_cbc_encrypt(in,out,len,ctx->cipher_data,ctx->iv,ctx->encrypt);

	return 1;
}

static int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in, size_t len)
{
	size_t	bl = ctx->cipher->block_size;

	if (len<bl)	return 1;

	aesni_ecb_encrypt(in,out,len,ctx->cipher_data,ctx->encrypt);

	return 1;
}

#define aesni_ofb_cipher aes_ofb_cipher
static int aesni_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len);

#define aesni_cfb_cipher aes_cfb_cipher
static int aesni_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len);

#define aesni_cfb8_cipher aes_cfb8_cipher
static int aesni_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len);

#define aesni_cfb1_cipher aes_cfb1_cipher
static int aesni_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len);

#define aesni_ctr_cipher aes_ctr_cipher
static int aesni_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len);

static int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
	EVP_AES_GCM_CTX *gctx = ctx->cipher_data;
	if (!iv && !key)
		return 1;
	if (key)
		{
		aesni_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks);
		CRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,
				(block128_f)aesni_encrypt);
		gctx->ctr = (ctr128_f)aesni_ctr32_encrypt_blocks;
		/* If we have an iv can set it directly, otherwise use
		 * saved IV.
		 */
		if (iv == NULL && gctx->iv_set)
			iv = gctx->iv;
		if (iv)
			{
			CRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);
			gctx->iv_set = 1;
			}
		gctx->key_set = 1;
		}
	else
		{
		/* If key set use IV, otherwise copy */
		if (gctx->key_set)
			CRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);
		else
			memcpy(gctx->iv, iv, gctx->ivlen);
		gctx->iv_set = 1;
		gctx->iv_gen = 0;
		}
	return 1;
	}

#define aesni_gcm_cipher aes_gcm_cipher
static int aesni_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len);
d70 28
a97 149
static int aesni_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
	EVP_AES_XTS_CTX *xctx = ctx->cipher_data;
	if (!iv && !key)
		return 1;

	if (key)
		{
		/* key_len is two AES keys */
		if (enc)
			{
			aesni_set_encrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)aesni_encrypt;
			xctx->stream = aesni_xts_encrypt;
			}
		else
			{
			aesni_set_decrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)aesni_decrypt;
			xctx->stream = aesni_xts_decrypt;
			}

		aesni_set_encrypt_key(key + ctx->key_len/2,
						ctx->key_len * 4, &xctx->ks2);
		xctx->xts.block2 = (block128_f)aesni_encrypt;

		xctx->xts.key1 = &xctx->ks1;
		}

	if (iv)
		{
		xctx->xts.key2 = &xctx->ks2;
		memcpy(ctx->iv, iv, 16);
		}

	return 1;
	}

#define aesni_xts_cipher aes_xts_cipher
static int aesni_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len);

static int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
	EVP_AES_CCM_CTX *cctx = ctx->cipher_data;
	if (!iv && !key)
		return 1;
	if (key)
		{
		aesni_set_encrypt_key(key, ctx->key_len * 8, &cctx->ks);
		CRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,
					&cctx->ks, (block128_f)aesni_encrypt);
		cctx->str = enc?(ccm128_f)aesni_ccm64_encrypt_blocks :
				(ccm128_f)aesni_ccm64_decrypt_blocks;
		cctx->key_set = 1;
		}
	if (iv)
		{
		memcpy(ctx->iv, iv, 15 - cctx->L);
		cctx->iv_set = 1;
		}
	return 1;
	}

#define aesni_ccm_cipher aes_ccm_cipher
static int aesni_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len);

#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
static const EVP_CIPHER aesni_##keylen##_##mode = { \
	nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aesni_init_key,			\
	aesni_##mode##_cipher,		\
	NULL,				\
	sizeof(EVP_AES_KEY),		\
	NULL,NULL,NULL,NULL }; \
static const EVP_CIPHER aes_##keylen##_##mode = { \
	nid##_##keylen##_##nmode,blocksize,	\
	keylen/8,ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aes_init_key,			\
	aes_##mode##_cipher,		\
	NULL,				\
	sizeof(EVP_AES_KEY),		\
	NULL,NULL,NULL,NULL }; \
const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }

#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
static const EVP_CIPHER aesni_##keylen##_##mode = { \
	nid##_##keylen##_##mode,blocksize, \
	(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aesni_##mode##_init_key,	\
	aesni_##mode##_cipher,		\
	aes_##mode##_cleanup,		\
	sizeof(EVP_AES_##MODE##_CTX),	\
	NULL,NULL,aes_##mode##_ctrl,NULL }; \
static const EVP_CIPHER aes_##keylen##_##mode = { \
	nid##_##keylen##_##mode,blocksize, \
	(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aes_##mode##_init_key,		\
	aes_##mode##_cipher,		\
	aes_##mode##_cleanup,		\
	sizeof(EVP_AES_##MODE##_CTX),	\
	NULL,NULL,aes_##mode##_ctrl,NULL }; \
const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }

#else

#define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
static const EVP_CIPHER aes_##keylen##_##mode = { \
	nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aes_init_key,			\
	aes_##mode##_cipher,		\
	NULL,				\
	sizeof(EVP_AES_KEY),		\
	NULL,NULL,NULL,NULL }; \
const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
{ return &aes_##keylen##_##mode; }

#define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
static const EVP_CIPHER aes_##keylen##_##mode = { \
	nid##_##keylen##_##mode,blocksize, \
	(EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \
	flags|EVP_CIPH_##MODE##_MODE,	\
	aes_##mode##_init_key,		\
	aes_##mode##_cipher,		\
	aes_##mode##_cleanup,		\
	sizeof(EVP_AES_##MODE##_CTX),	\
	NULL,NULL,aes_##mode##_ctrl,NULL }; \
const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
{ return &aes_##keylen##_##mode; }
#endif

#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)		\
	BLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
	BLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,cfb128,cfb,CFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,cfb1,cfb1,CFB,flags)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,cfb8,cfb8,CFB,flags)	\
	BLOCK_CIPHER_generic(nid,keylen,1,16,ctr,ctr,CTR,flags)
d102 1
a102 2
	int ret, mode;
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;
d104 4
a107 30
	mode = ctx->cipher->flags & EVP_CIPH_MODE;
	if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
	    && !enc)
#ifdef BSAES_CAPABLE
	    if (BSAES_CAPABLE && mode==EVP_CIPH_CBC_MODE)
		{
		ret = AES_set_decrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)AES_decrypt;
		dat->stream.cbc	= (cbc128_f)bsaes_cbc_encrypt;
		}
	    else
#endif
#ifdef VPAES_CAPABLE
	    if (VPAES_CAPABLE)
		{
		ret = vpaes_set_decrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)vpaes_decrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)vpaes_cbc_encrypt :
					NULL;
		}
	    else
#endif
		{
		ret = AES_set_decrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)AES_decrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)AES_cbc_encrypt :
					NULL;
		}
d109 1
a109 31
#ifdef BSAES_CAPABLE
	    if (BSAES_CAPABLE && mode==EVP_CIPH_CTR_MODE)
		{
		ret = AES_set_encrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)AES_encrypt;
		dat->stream.ctr	= (ctr128_f)bsaes_ctr32_encrypt_blocks;
		}
	    else
#endif
#ifdef VPAES_CAPABLE
	    if (VPAES_CAPABLE)
		{
		ret = vpaes_set_encrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)vpaes_encrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)vpaes_cbc_encrypt :
					NULL;
		}
	    else
#endif
		{
		ret = AES_set_encrypt_key(key,ctx->key_len*8,&dat->ks);
		dat->block	= (block128_f)AES_encrypt;
		dat->stream.cbc	= mode==EVP_CIPH_CBC_MODE ?
					(cbc128_f)AES_cbc_encrypt :
					NULL;
#ifdef AES_CTR_ASM
		if (mode==EVP_CIPH_CTR_MODE)
			dat->stream.ctr = (ctr128_f)AES_ctr32_encrypt;
#endif
		}
a119 739
static int aes_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in, size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	if (dat->stream.cbc)
		(*dat->stream.cbc)(in,out,len,&dat->ks,ctx->iv,ctx->encrypt);
	else if (ctx->encrypt)
		CRYPTO_cbc128_encrypt(in,out,len,&dat->ks,ctx->iv,dat->block);
	else
		CRYPTO_cbc128_encrypt(in,out,len,&dat->ks,ctx->iv,dat->block);

	return 1;
}

static int aes_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in, size_t len)
{
	size_t	bl = ctx->cipher->block_size;
	size_t	i;
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	if (len<bl)	return 1;

	for (i=0,len-=bl;i<=len;i+=bl)
		(*dat->block)(in+i,out+i,&dat->ks);

	return 1;
}

static int aes_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	CRYPTO_ofb128_encrypt(in,out,len,&dat->ks,
			ctx->iv,&ctx->num,dat->block);
	return 1;
}

static int aes_cfb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	CRYPTO_cfb128_encrypt(in,out,len,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
	return 1;
}

static int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	CRYPTO_cfb128_8_encrypt(in,out,len,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
	return 1;
}

static int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,
	const unsigned char *in,size_t len)
{
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	if (ctx->flags&EVP_CIPH_FLAG_LENGTH_BITS) {
		CRYPTO_cfb128_1_encrypt(in,out,len,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
		return 1;
	}

	while (len>=MAXBITCHUNK) {
		CRYPTO_cfb128_1_encrypt(in,out,MAXBITCHUNK*8,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
		len-=MAXBITCHUNK;
	}
	if (len)
		CRYPTO_cfb128_1_encrypt(in,out,len*8,&dat->ks,
			ctx->iv,&ctx->num,ctx->encrypt,dat->block);
	
	return 1;
}

static int aes_ctr_cipher (EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len)
{
	unsigned int num = ctx->num;
	EVP_AES_KEY *dat = (EVP_AES_KEY *)ctx->cipher_data;

	if (dat->stream.ctr)
		CRYPTO_ctr128_encrypt_ctr32(in,out,len,&dat->ks,
			ctx->iv,ctx->buf,&num,dat->stream.ctr);
	else
		CRYPTO_ctr128_encrypt(in,out,len,&dat->ks,
			ctx->iv,ctx->buf,&num,dat->block);
	ctx->num = (size_t)num;
	return 1;
}

BLOCK_CIPHER_generic_pack(NID_aes,128,EVP_CIPH_FLAG_FIPS)
BLOCK_CIPHER_generic_pack(NID_aes,192,EVP_CIPH_FLAG_FIPS)
BLOCK_CIPHER_generic_pack(NID_aes,256,EVP_CIPH_FLAG_FIPS)

static int aes_gcm_cleanup(EVP_CIPHER_CTX *c)
	{
	EVP_AES_GCM_CTX *gctx = c->cipher_data;
	OPENSSL_cleanse(&gctx->gcm, sizeof(gctx->gcm));
	if (gctx->iv != c->iv)
		OPENSSL_free(gctx->iv);
	return 1;
	}

/* increment counter (64-bit int) by 1 */
static void ctr64_inc(unsigned char *counter) {
	int n=8;
	unsigned char  c;

	do {
		--n;
		c = counter[n];
		++c;
		counter[n] = c;
		if (c) return;
	} while (n);
}

static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
	{
	EVP_AES_GCM_CTX *gctx = c->cipher_data;
	switch (type)
		{
	case EVP_CTRL_INIT:
		gctx->key_set = 0;
		gctx->iv_set = 0;
		gctx->ivlen = c->cipher->iv_len;
		gctx->iv = c->iv;
		gctx->taglen = -1;
		gctx->iv_gen = 0;
		gctx->tls_aad_len = -1;
		return 1;

	case EVP_CTRL_GCM_SET_IVLEN:
		if (arg <= 0)
			return 0;
#ifdef OPENSSL_FIPS
		if (FIPS_module_mode() && !(c->flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW)
						 && arg < 12)
			return 0;
#endif
		/* Allocate memory for IV if needed */
		if ((arg > EVP_MAX_IV_LENGTH) && (arg > gctx->ivlen))
			{
			if (gctx->iv != c->iv)
				OPENSSL_free(gctx->iv);
			gctx->iv = OPENSSL_malloc(arg);
			if (!gctx->iv)
				return 0;
			}
		gctx->ivlen = arg;
		return 1;

	case EVP_CTRL_GCM_SET_TAG:
		if (arg <= 0 || arg > 16 || c->encrypt)
			return 0;
		memcpy(c->buf, ptr, arg);
		gctx->taglen = arg;
		return 1;

	case EVP_CTRL_GCM_GET_TAG:
		if (arg <= 0 || arg > 16 || !c->encrypt || gctx->taglen < 0)
			return 0;
		memcpy(ptr, c->buf, arg);
		return 1;

	case EVP_CTRL_GCM_SET_IV_FIXED:
		/* Special case: -1 length restores whole IV */
		if (arg == -1)
			{
			memcpy(gctx->iv, ptr, gctx->ivlen);
			gctx->iv_gen = 1;
			return 1;
			}
		/* Fixed field must be at least 4 bytes and invocation field
		 * at least 8.
		 */
		if ((arg < 4) || (gctx->ivlen - arg) < 8)
			return 0;
		if (arg)
			memcpy(gctx->iv, ptr, arg);
		if (c->encrypt &&
			RAND_bytes(gctx->iv + arg, gctx->ivlen - arg) <= 0)
			return 0;
		gctx->iv_gen = 1;
		return 1;

	case EVP_CTRL_GCM_IV_GEN:
		if (gctx->iv_gen == 0 || gctx->key_set == 0)
			return 0;
		CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);
		if (arg <= 0 || arg > gctx->ivlen)
			arg = gctx->ivlen;
		memcpy(ptr, gctx->iv + gctx->ivlen - arg, arg);
		/* Invocation field will be at least 8 bytes in size and
		 * so no need to check wrap around or increment more than
		 * last 8 bytes.
		 */
		ctr64_inc(gctx->iv + gctx->ivlen - 8);
		gctx->iv_set = 1;
		return 1;

	case EVP_CTRL_GCM_SET_IV_INV:
		if (gctx->iv_gen == 0 || gctx->key_set == 0 || c->encrypt)
			return 0;
		memcpy(gctx->iv + gctx->ivlen - arg, ptr, arg);
		CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);
		gctx->iv_set = 1;
		return 1;

	case EVP_CTRL_AEAD_TLS1_AAD:
		/* Save the AAD for later use */
		if (arg != 13)
			return 0;
		memcpy(c->buf, ptr, arg);
		gctx->tls_aad_len = arg;
			{
			unsigned int len=c->buf[arg-2]<<8|c->buf[arg-1];
			/* Correct length for explicit IV */
			len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
			/* If decrypting correct for tag too */
			if (!c->encrypt)
				len -= EVP_GCM_TLS_TAG_LEN;
                        c->buf[arg-2] = len>>8;
                        c->buf[arg-1] = len & 0xff;
			}
		/* Extra padding: tag appended to record */
		return EVP_GCM_TLS_TAG_LEN;

	default:
		return -1;

		}
	}

static int aes_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
	EVP_AES_GCM_CTX *gctx = ctx->cipher_data;
	if (!iv && !key)
		return 1;
	if (key)
		{ do {
#ifdef BSAES_CAPABLE
		if (BSAES_CAPABLE)
			{
			AES_set_encrypt_key(key,ctx->key_len*8,&gctx->ks);
			CRYPTO_gcm128_init(&gctx->gcm,&gctx->ks,
					(block128_f)AES_encrypt);
			gctx->ctr = (ctr128_f)bsaes_ctr32_encrypt_blocks;
			break;
			}
		else
#endif
#ifdef VPAES_CAPABLE
		if (VPAES_CAPABLE)
			{
			vpaes_set_encrypt_key(key,ctx->key_len*8,&gctx->ks);
			CRYPTO_gcm128_init(&gctx->gcm,&gctx->ks,
					(block128_f)vpaes_encrypt);
			gctx->ctr = NULL;
			break;
			}
#endif
		AES_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks);
		CRYPTO_gcm128_init(&gctx->gcm, &gctx->ks, (block128_f)AES_encrypt);
#ifdef AES_CTR_ASM
		gctx->ctr = (ctr128_f)AES_ctr32_encrypt;
#else
		gctx->ctr = NULL;
#endif
		} while (0);

		/* If we have an iv can set it directly, otherwise use
		 * saved IV.
		 */
		if (iv == NULL && gctx->iv_set)
			iv = gctx->iv;
		if (iv)
			{
			CRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);
			gctx->iv_set = 1;
			}
		gctx->key_set = 1;
		}
	else
		{
		/* If key set use IV, otherwise copy */
		if (gctx->key_set)
			CRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);
		else
			memcpy(gctx->iv, iv, gctx->ivlen);
		gctx->iv_set = 1;
		gctx->iv_gen = 0;
		}
	return 1;
	}

/* Handle TLS GCM packet format. This consists of the last portion of the IV
 * followed by the payload and finally the tag. On encrypt generate IV,
 * encrypt payload and write the tag. On verify retrieve IV, decrypt payload
 * and verify tag.
 */

static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len)
	{
	EVP_AES_GCM_CTX *gctx = ctx->cipher_data;
	int rv = -1;
	/* Encrypt/decrypt must be performed in place */
	if (out != in || len < (EVP_GCM_TLS_EXPLICIT_IV_LEN+EVP_GCM_TLS_TAG_LEN))
		return -1;
	/* Set IV from start of buffer or generate IV and write to start
	 * of buffer.
	 */
	if (EVP_CIPHER_CTX_ctrl(ctx, ctx->encrypt ?
				EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV,
				EVP_GCM_TLS_EXPLICIT_IV_LEN, out) <= 0)
		goto err;
	/* Use saved AAD */
	if (CRYPTO_gcm128_aad(&gctx->gcm, ctx->buf, gctx->tls_aad_len))
		goto err;
	/* Fix buffer and length to point to payload */
	in += EVP_GCM_TLS_EXPLICIT_IV_LEN;
	out += EVP_GCM_TLS_EXPLICIT_IV_LEN;
	len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;
	if (ctx->encrypt)
		{
		/* Encrypt payload */
		if (gctx->ctr)
			{
			if (CRYPTO_gcm128_encrypt_ctr32(&gctx->gcm,
							in, out, len,
							gctx->ctr))
				goto err;
			}
		else	{
			if (CRYPTO_gcm128_encrypt(&gctx->gcm, in, out, len))
				goto err;
			}
		out += len;
		/* Finally write tag */
		CRYPTO_gcm128_tag(&gctx->gcm, out, EVP_GCM_TLS_TAG_LEN);
		rv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;
		}
	else
		{
		/* Decrypt */
		if (gctx->ctr)
			{
			if (CRYPTO_gcm128_decrypt_ctr32(&gctx->gcm,
							in, out, len,
							gctx->ctr))
				goto err;
			}
		else	{
			if (CRYPTO_gcm128_decrypt(&gctx->gcm, in, out, len))
				goto err;
			}
		/* Retrieve tag */
		CRYPTO_gcm128_tag(&gctx->gcm, ctx->buf,
					EVP_GCM_TLS_TAG_LEN);
		/* If tag mismatch wipe buffer */
		if (memcmp(ctx->buf, in + len, EVP_GCM_TLS_TAG_LEN))
			{
			OPENSSL_cleanse(out, len);
			goto err;
			}
		rv = len;
		}

	err:
	gctx->iv_set = 0;
	gctx->tls_aad_len = -1;
	return rv;
	}

static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len)
	{
	EVP_AES_GCM_CTX *gctx = ctx->cipher_data;
	/* If not set up, return error */
	if (!gctx->key_set)
		return -1;

	if (gctx->tls_aad_len >= 0)
		return aes_gcm_tls_cipher(ctx, out, in, len);

	if (!gctx->iv_set)
		return -1;
	if (!ctx->encrypt && gctx->taglen < 0)
		return -1;
	if (in)
		{
		if (out == NULL)
			{
			if (CRYPTO_gcm128_aad(&gctx->gcm, in, len))
				return -1;
			}
		else if (ctx->encrypt)
			{
			if (gctx->ctr)
				{
				if (CRYPTO_gcm128_encrypt_ctr32(&gctx->gcm,
							in, out, len,
							gctx->ctr))
					return -1;
				}
			else	{
				if (CRYPTO_gcm128_encrypt(&gctx->gcm, in, out, len))
					return -1;
				}
			}
		else
			{
			if (gctx->ctr)
				{
				if (CRYPTO_gcm128_decrypt_ctr32(&gctx->gcm,
							in, out, len,
							gctx->ctr))
					return -1;
				}
			else	{
				if (CRYPTO_gcm128_decrypt(&gctx->gcm, in, out, len))
					return -1;
				}
			}
		return len;
		}
	else
		{
		if (!ctx->encrypt)
			{
			if (CRYPTO_gcm128_finish(&gctx->gcm,
					ctx->buf, gctx->taglen) != 0)
				return -1;
			gctx->iv_set = 0;
			return 0;
			}
		CRYPTO_gcm128_tag(&gctx->gcm, ctx->buf, 16);
		gctx->taglen = 16;
		/* Don't reuse the IV */
		gctx->iv_set = 0;
		return 0;
		}

	}

#define CUSTOM_FLAGS	(EVP_CIPH_FLAG_DEFAULT_ASN1 \
		| EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \
		| EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)

BLOCK_CIPHER_custom(NID_aes,128,1,12,gcm,GCM,
		EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_AEAD_CIPHER|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes,192,1,12,gcm,GCM,
		EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_AEAD_CIPHER|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes,256,1,12,gcm,GCM,
		EVP_CIPH_FLAG_FIPS|EVP_CIPH_FLAG_AEAD_CIPHER|CUSTOM_FLAGS)

static int aes_xts_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
	{
	EVP_AES_XTS_CTX *xctx = c->cipher_data;
	if (type != EVP_CTRL_INIT)
		return -1;
	/* key1 and key2 are used as an indicator both key and IV are set */
	xctx->xts.key1 = NULL;
	xctx->xts.key2 = NULL;
	return 1;
	}

static int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
	EVP_AES_XTS_CTX *xctx = ctx->cipher_data;
	if (!iv && !key)
		return 1;

	if (key) do
		{
#ifdef AES_XTS_ASM
		xctx->stream = enc ? AES_xts_encrypt : AES_xts_decrypt;
#else
		xctx->stream = NULL;
#endif
		/* key_len is two AES keys */
#ifdef BSAES_CAPABLE
		if (BSAES_CAPABLE)
			xctx->stream = enc ? bsaes_xts_encrypt : bsaes_xts_decrypt;
		else
#endif
#ifdef VPAES_CAPABLE
		if (VPAES_CAPABLE)
		    {
		    if (enc)
			{
			vpaes_set_encrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)vpaes_encrypt;
			}
		    else
			{
			vpaes_set_decrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)vpaes_decrypt;
			}

		vpaes_set_encrypt_key(key + ctx->key_len/2,
						ctx->key_len * 4, &xctx->ks2);
		xctx->xts.block2 = (block128_f)vpaes_encrypt;

		xctx->xts.key1 = &xctx->ks1;
		break;
		}
#endif
		if (enc)
			{
			AES_set_encrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)AES_encrypt;
			}
		else
			{
			AES_set_decrypt_key(key, ctx->key_len * 4, &xctx->ks1);
			xctx->xts.block1 = (block128_f)AES_decrypt;
			}

		AES_set_encrypt_key(key + ctx->key_len/2,
						ctx->key_len * 4, &xctx->ks2);
		xctx->xts.block2 = (block128_f)AES_encrypt;

		xctx->xts.key1 = &xctx->ks1;
		} while (0);

	if (iv)
		{
		xctx->xts.key2 = &xctx->ks2;
		memcpy(ctx->iv, iv, 16);
		}

	return 1;
	}

static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len)
	{
	EVP_AES_XTS_CTX *xctx = ctx->cipher_data;
	if (!xctx->xts.key1 || !xctx->xts.key2)
		return 0;
	if (!out || !in || len<AES_BLOCK_SIZE)
		return 0;
#ifdef OPENSSL_FIPS
	/* Requirement of SP800-38E */
	if (FIPS_module_mode() && !(ctx->flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW) &&
			(len > (1UL<<20)*16))
		{
		EVPerr(EVP_F_AES_XTS_CIPHER, EVP_R_TOO_LARGE);
		return 0;
		}
#endif
	if (xctx->stream)
		(*xctx->stream)(in, out, len,
				xctx->xts.key1, xctx->xts.key2, ctx->iv);
	else if (CRYPTO_xts128_encrypt(&xctx->xts, ctx->iv, in, out, len,
								ctx->encrypt))
		return 0;
	return 1;
	}

#define aes_xts_cleanup NULL

#define XTS_FLAGS	(EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \
			 | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT)

BLOCK_CIPHER_custom(NID_aes,128,1,16,xts,XTS,EVP_CIPH_FLAG_FIPS|XTS_FLAGS)
BLOCK_CIPHER_custom(NID_aes,256,1,16,xts,XTS,EVP_CIPH_FLAG_FIPS|XTS_FLAGS)

static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
	{
	EVP_AES_CCM_CTX *cctx = c->cipher_data;
	switch (type)
		{
	case EVP_CTRL_INIT:
		cctx->key_set = 0;
		cctx->iv_set = 0;
		cctx->L = 8;
		cctx->M = 12;
		cctx->tag_set = 0;
		cctx->len_set = 0;
		return 1;

	case EVP_CTRL_CCM_SET_IVLEN:
		arg = 15 - arg;
	case EVP_CTRL_CCM_SET_L:
		if (arg < 2 || arg > 8)
			return 0;
		cctx->L = arg;
		return 1;

	case EVP_CTRL_CCM_SET_TAG:
		if ((arg & 1) || arg < 4 || arg > 16)
			return 0;
		if ((c->encrypt && ptr) || (!c->encrypt && !ptr))
			return 0;
		if (ptr)
			{
			cctx->tag_set = 1;
			memcpy(c->buf, ptr, arg);
			}
		cctx->M = arg;
		return 1;

	case EVP_CTRL_CCM_GET_TAG:
		if (!c->encrypt || !cctx->tag_set)
			return 0;
		if(!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg))
			return 0;
		cctx->tag_set = 0;
		cctx->iv_set = 0;
		cctx->len_set = 0;
		return 1;

	default:
		return -1;

		}
	}

static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
	{
	EVP_AES_CCM_CTX *cctx = ctx->cipher_data;
	if (!iv && !key)
		return 1;
	if (key) do
		{
#ifdef VPAES_CAPABLE
		if (VPAES_CAPABLE)
			{
			vpaes_set_encrypt_key(key, ctx->key_len*8, &cctx->ks);
			CRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,
					&cctx->ks, (block128_f)vpaes_encrypt);
			cctx->key_set = 1;
			break;
			}
#endif
		AES_set_encrypt_key(key, ctx->key_len * 8, &cctx->ks);
		CRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,
					&cctx->ks, (block128_f)AES_encrypt);
		cctx->str = NULL;
		cctx->key_set = 1;
		} while (0);
	if (iv)
		{
		memcpy(ctx->iv, iv, 15 - cctx->L);
		cctx->iv_set = 1;
		}
	return 1;
	}

static int aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
		const unsigned char *in, size_t len)
	{
	EVP_AES_CCM_CTX *cctx = ctx->cipher_data;
	CCM128_CONTEXT *ccm = &cctx->ccm;
	/* If not set up, return error */
	if (!cctx->iv_set && !cctx->key_set)
		return -1;
	if (!ctx->encrypt && !cctx->tag_set)
		return -1;
	if (!out)
		{
		if (!in)
			{
			if (CRYPTO_ccm128_setiv(ccm, ctx->iv, 15 - cctx->L,len))
				return -1;
			cctx->len_set = 1;
			return len;
			}
		/* If have AAD need message length */
		if (!cctx->len_set && len)
			return -1;
		CRYPTO_ccm128_aad(ccm, in, len);
		return len;
		}
	/* EVP_*Final() doesn't return any data */
	if (!in)
		return 0;
	/* If not set length yet do it */
	if (!cctx->len_set)
		{
		if (CRYPTO_ccm128_setiv(ccm, ctx->iv, 15 - cctx->L, len))
			return -1;
		cctx->len_set = 1;
		}
	if (ctx->encrypt)
		{
		if (cctx->str ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len,
						cctx->str) :
				CRYPTO_ccm128_encrypt(ccm, in, out, len))
			return -1;
		cctx->tag_set = 1;
		return len;
		}
	else
		{
		int rv = -1;
		if (cctx->str ? !CRYPTO_ccm128_decrypt_ccm64(ccm, in, out, len,
						cctx->str) :
				!CRYPTO_ccm128_decrypt(ccm, in, out, len))
			{
			unsigned char tag[16];
			if (CRYPTO_ccm128_tag(ccm, tag, cctx->M))
				{
				if (!memcmp(tag, ctx->buf, cctx->M))
					rv = len;
				}
			}
		if (rv == -1)
			OPENSSL_cleanse(out, len);
		cctx->iv_set = 0;
		cctx->tag_set = 0;
		cctx->len_set = 0;
		return rv;
		}

	}

#define aes_ccm_cleanup NULL

BLOCK_CIPHER_custom(NID_aes,128,1,12,ccm,CCM,EVP_CIPH_FLAG_FIPS|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes,192,1,12,ccm,CCM,EVP_CIPH_FLAG_FIPS|CUSTOM_FLAGS)
BLOCK_CIPHER_custom(NID_aes,256,1,12,ccm,CCM,EVP_CIPH_FLAG_FIPS|CUSTOM_FLAGS)

#endif
@


1.1.1.9
log
@Import OpenSSL 1.0.1g
@
text
@a844 1
		else
a845 2
		(void)0;	/* terminate potentially open 'else' */

d972 2
a1014 2
			if (gctx->taglen < 0)
				return -1;
d1086 1
a1086 1
		    vpaes_set_encrypt_key(key + ctx->key_len/2,
d1088 1
a1088 1
		    xctx->xts.block2 = (block128_f)vpaes_encrypt;
d1090 3
a1092 4
		    xctx->xts.key1 = &xctx->ks1;
		    break;
		    }
		else
a1093 2
		(void)0;	/* terminate potentially open 'else' */

a1219 1
			cctx->str = NULL;
@


