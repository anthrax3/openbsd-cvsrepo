head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.2
	OPENBSD_6_1_BASE:1.15;
locks; strict;
comment	@ * @;


1.15
date	2015.10.21.16.36.50;	author jsing;	state Exp;
branches;
next	1.14;
commitid	w8Cw6M2bVmTnHYyN;

1.14
date	2015.10.20.15.50.13;	author jsing;	state Exp;
branches;
next	1.13;
commitid	bzvO8Cm3JPpoTNEt;

1.13
date	2014.10.28.07.35.59;	author jsg;	state Exp;
branches;
next	1.12;
commitid	pi8qF4s0vNCGLEKv;

1.12
date	2014.07.09.16.06.13;	author miod;	state Exp;
branches;
next	1.11;
commitid	WBUBPtdvi23w6jGY;

1.11
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	mJUVYpkFBZ0Zv2bG;

1.10
date	2014.04.27.20.38.39;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.23.19.14.59;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.23.18.40.39;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.29.05.39.25;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.11.22;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.35;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.55;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.55;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.50;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.15;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.06.27.05.05.35;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.10;	author djm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@In the case where len is not a multiple of sizeof(RC4_CHUNK) the RC4 code
will end up doing a read and write of up to 7 bytes beyond the specified
length. This is effectively a non-issue since we read and write back the
same data and due to alignment it is within a page boundary.

Regardless, avoid this by removing the "special" handling for the remaining
length and allow the standard (non-chunk) code to process the remaining
bytes, which does not result in overrun.

Reported by Pascal Cuoq <cuoq at trust-in-soft.com> - thanks!

ok beck@@ miod@@
@
text
@/* $OpenBSD: rc4_enc.c,v 1.14 2015/10/20 15:50:13 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <machine/endian.h>
#include <openssl/rc4.h>
#include "rc4_locl.h"

/* RC4 as implemented from a posting from
 * Newsgroups: sci.crypt
 * From: sterndark@@netcom.com (David Sterndark)
 * Subject: RC4 Algorithm revealed.
 * Message-ID: <sternCvKL4B.Hyy@@netcom.com>
 * Date: Wed, 14 Sep 1994 06:35:31 GMT
 */

void
RC4(RC4_KEY *key, size_t len, const unsigned char *indata,
    unsigned char *outdata)
{
	RC4_INT *d;
	RC4_INT x, y,tx, ty;
	size_t i;

	x = key->x;
	y = key->y;
	d = key->data;

#if defined(RC4_CHUNK)
	/*
	 * The original reason for implementing this(*) was the fact that
	 * pre-21164a Alpha CPUs don't have byte load/store instructions
	 * and e.g. a byte store has to be done with 64-bit load, shift,
	 * and, or and finally 64-bit store. Peaking data and operating
	 * at natural word size made it possible to reduce amount of
	 * instructions as well as to perform early read-ahead without
	 * suffering from RAW (read-after-write) hazard. This resulted
	 * in ~40%(**) performance improvement on 21064 box with gcc.
	 * But it's not only Alpha users who win here:-) Thanks to the
	 * early-n-wide read-ahead this implementation also exhibits
	 * >40% speed-up on SPARC and 20-30% on 64-bit MIPS (depending
	 * on sizeof(RC4_INT)).
	 *
	 * (*)	"this" means code which recognizes the case when input
	 *	and output pointers appear to be aligned at natural CPU
	 *	word boundary
	 * (**)	i.e. according to 'apps/openssl speed rc4' benchmark,
	 *	crypto/rc4/rc4speed.c exhibits almost 70% speed-up...
	 *
	 * Caveats.
	 *
	 * - RC4_CHUNK="unsigned long long" should be a #1 choice for
	 *   UltraSPARC. Unfortunately gcc generates very slow code
	 *   (2.5-3 times slower than one generated by Sun's WorkShop
	 *   C) and therefore gcc (at least 2.95 and earlier) should
	 *   always be told that RC4_CHUNK="unsigned long".
	 *
	 *					<appro@@fy.chalmers.se>
	 */

# define RC4_STEP	( \
			x=(x+1) &0xff,	\
			tx=d[x],	\
			y=(tx+y)&0xff,	\
			ty=d[y],	\
			d[y]=tx,	\
			d[x]=ty,	\
			(RC4_CHUNK)d[(tx+ty)&0xff]\
			)

	if ((((size_t)indata & (sizeof(RC4_CHUNK) - 1)) |
	    ((size_t)outdata & (sizeof(RC4_CHUNK) - 1))) == 0 ) {
		RC4_CHUNK ichunk, otp;

		/*
		 * I reckon we can afford to implement both endian
		 * cases and to decide which way to take at run-time
		 * because the machine code appears to be very compact
		 * and redundant 1-2KB is perfectly tolerable (i.e.
		 * in case the compiler fails to eliminate it:-). By
		 * suggestion from Terrel Larson <terr@@terralogic.net>.
		 *
		 * Special notes.
		 *
		 * - compilers (those I've tried) don't seem to have
		 *   problems eliminating either the operators guarded
		 *   by "if (sizeof(RC4_CHUNK)==8)" or the condition
		 *   expressions themselves so I've got 'em to replace
		 *   corresponding #ifdefs from the previous version;
		 * - I chose to let the redundant switch cases when
		 *   sizeof(RC4_CHUNK)!=8 be (were also #ifdefed
		 *   before);
		 * - in case you wonder "&(sizeof(RC4_CHUNK)*8-1)" in
		 *   [LB]ESHFT guards against "shift is out of range"
		 *   warnings when sizeof(RC4_CHUNK)!=8
		 *
		 *			<appro@@fy.chalmers.se>
		 */
		if (BYTE_ORDER != LITTLE_ENDIAN) {	/* BIG-ENDIAN CASE */
# define BESHFT(c)	(((sizeof(RC4_CHUNK)-(c)-1)*8)&(sizeof(RC4_CHUNK)*8-1))
			for (; len & (0 - sizeof(RC4_CHUNK)); len -= sizeof(RC4_CHUNK)) {
				ichunk  = *(RC4_CHUNK *)indata;
				otp = RC4_STEP << BESHFT(0);
				otp |= RC4_STEP << BESHFT(1);
				otp |= RC4_STEP << BESHFT(2);
				otp |= RC4_STEP << BESHFT(3);
				if (sizeof(RC4_CHUNK) == 8) {
					otp |= RC4_STEP << BESHFT(4);
					otp |= RC4_STEP << BESHFT(5);
					otp |= RC4_STEP << BESHFT(6);
					otp |= RC4_STEP << BESHFT(7);
				}
				*(RC4_CHUNK *)outdata = otp^ichunk;
				indata += sizeof(RC4_CHUNK);
				outdata += sizeof(RC4_CHUNK);
			}
		} else {	/* LITTLE-ENDIAN CASE */
# define LESHFT(c)	(((c)*8)&(sizeof(RC4_CHUNK)*8-1))
			for (; len & (0 - sizeof(RC4_CHUNK)); len -= sizeof(RC4_CHUNK)) {
				ichunk = *(RC4_CHUNK *)indata;
				otp = RC4_STEP;
				otp |= RC4_STEP << 8;
				otp |= RC4_STEP << 16;
				otp |= RC4_STEP << 24;
				if (sizeof(RC4_CHUNK) == 8) {
					otp |= RC4_STEP << LESHFT(4);
					otp |= RC4_STEP << LESHFT(5);
					otp |= RC4_STEP << LESHFT(6);
					otp |= RC4_STEP << LESHFT(7);
				}
				*(RC4_CHUNK *)outdata = otp ^ ichunk;
				indata += sizeof(RC4_CHUNK);
				outdata += sizeof(RC4_CHUNK);
			}
		}
	}
#endif
#define LOOP(in,out) \
		x=((x+1)&0xff); \
		tx=d[x]; \
		y=(tx+y)&0xff; \
		d[x]=ty=d[y]; \
		d[y]=tx; \
		(out) = d[(tx+ty)&0xff]^ (in);

#ifndef RC4_INDEX
#define RC4_LOOP(a,b,i)	LOOP(*((a)++),*((b)++))
#else
#define RC4_LOOP(a,b,i)	LOOP(a[i],b[i])
#endif

	i = len >> 3;
	if (i) {
		for (;;) {
			RC4_LOOP(indata, outdata, 0);
			RC4_LOOP(indata, outdata, 1);
			RC4_LOOP(indata, outdata, 2);
			RC4_LOOP(indata, outdata, 3);
			RC4_LOOP(indata, outdata, 4);
			RC4_LOOP(indata, outdata, 5);
			RC4_LOOP(indata, outdata, 6);
			RC4_LOOP(indata, outdata, 7);
#ifdef RC4_INDEX
			indata += 8;
			outdata += 8;
#endif
			if (--i == 0)
				break;
		}
	}
	i = len&0x07;
	if (i) {
		for (;;) {
			RC4_LOOP(indata, outdata, 0);
			if (--i == 0)
				break;
			RC4_LOOP(indata, outdata, 1);
			if (--i == 0)
				break;
			RC4_LOOP(indata, outdata, 2);
			if (--i == 0)
				break;
			RC4_LOOP(indata, outdata, 3);
			if (--i == 0)
				break;
			RC4_LOOP(indata, outdata, 4);
			if (--i == 0)
				break;
			RC4_LOOP(indata, outdata, 5);
			if (--i == 0)
				break;
			RC4_LOOP(indata, outdata, 6);
			if (--i == 0)
				break;
		}
	}
	key->x = x;
	key->y = y;
}
@


1.14
log
@Lob a style(9) grenade in here.
@
text
@d1 1
a1 1
/* $OpenBSD: rc4_enc.c,v 1.13 2014/10/28 07:35:59 jsg Exp $ */
a170 31
			if (len) {
				RC4_CHUNK mask = (RC4_CHUNK) - 1, ochunk;

				ichunk = *(RC4_CHUNK *)indata;
				ochunk = *(RC4_CHUNK *)outdata;
				otp = 0;
				i = BESHFT(0);
				mask <<= (sizeof(RC4_CHUNK) - len) << 3;
				switch (len & (sizeof(RC4_CHUNK) - 1)) {
				case 7:
					otp = RC4_STEP << i, i -= 8;
				case 6:
					otp |= RC4_STEP << i, i -= 8;
				case 5:
					otp |= RC4_STEP << i, i -= 8;
				case 4:
					otp |= RC4_STEP << i, i -= 8;
				case 3:
					otp |= RC4_STEP << i, i -= 8;
				case 2:
					otp |= RC4_STEP << i, i -= 8;
				case 1:
					otp |= RC4_STEP << i, i -= 8;
				}
				ochunk &= ~mask;
				ochunk |= (otp ^ ichunk) & mask;
				*(RC4_CHUNK *)outdata = ochunk;
			}
			key->x = x;
			key->y = y;
			return;
a188 31
			if (len) {
				RC4_CHUNK mask = (RC4_CHUNK) - 1, ochunk;

				ichunk = *(RC4_CHUNK *)indata;
				ochunk = *(RC4_CHUNK *)outdata;
				otp = 0;
				i = 0;
				mask >>= (sizeof(RC4_CHUNK) - len) << 3;
				switch (len&(sizeof(RC4_CHUNK) - 1)) {
				case 7:
					otp = RC4_STEP, i += 8;
				case 6:
					otp |= RC4_STEP << i, i += 8;
				case 5:
					otp |= RC4_STEP << i, i += 8;
				case 4:
					otp |= RC4_STEP << i, i += 8;
				case 3:
					otp |= RC4_STEP << i, i += 8;
				case 2:
					otp |= RC4_STEP << i, i += 8;
				case 1:
					otp |= RC4_STEP << i, i += 8;
				}
				ochunk &= ~mask;
				ochunk |= (otp ^ ichunk) & mask;
				*(RC4_CHUNK *)outdata = ochunk;
			}
			key->x = x;
			key->y = y;
			return;
@


1.13
log
@deregister; no binary change
ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: rc4_enc.c,v 1.12 2014/07/09 16:06:13 miod Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d71 6
a76 5
void RC4(RC4_KEY *key, size_t len, const unsigned char *indata,
	     unsigned char *outdata)
	{
        RC4_INT *d;
        RC4_INT x,y,tx,ty;
d78 4
a81 4
        
        x=key->x;     
        y=key->y;     
        d=key->data; 
d125 3
a127 4
	if ( ( ((size_t)indata  & (sizeof(RC4_CHUNK)-1)) | 
	       ((size_t)outdata & (sizeof(RC4_CHUNK)-1)) ) == 0 )
		{
		RC4_CHUNK ichunk,otp;
d149 1
a149 1
		 *   warnings when sizeof(RC4_CHUNK)!=8 
d153 1
a153 2
		if (BYTE_ORDER != LITTLE_ENDIAN)
			{	/* BIG-ENDIAN CASE */
d155 1
a155 2
			for (;len&(0-sizeof(RC4_CHUNK));len-=sizeof(RC4_CHUNK))
				{
d157 10
a166 11
				otp  = RC4_STEP<<BESHFT(0);
				otp |= RC4_STEP<<BESHFT(1);
				otp |= RC4_STEP<<BESHFT(2);
				otp |= RC4_STEP<<BESHFT(3);
				if (sizeof(RC4_CHUNK)==8)
					{
					otp |= RC4_STEP<<BESHFT(4);
					otp |= RC4_STEP<<BESHFT(5);
					otp |= RC4_STEP<<BESHFT(6);
					otp |= RC4_STEP<<BESHFT(7);
					}
d168 1
a168 1
				indata  += sizeof(RC4_CHUNK);
d170 3
a172 4
				}
			if (len)
				{
				RC4_CHUNK mask=(RC4_CHUNK)-1, ochunk;
d178 17
a194 11
				mask <<= (sizeof(RC4_CHUNK)-len)<<3;
				switch (len&(sizeof(RC4_CHUNK)-1))
					{
					case 7:	otp  = RC4_STEP<<i, i-=8;
					case 6:	otp |= RC4_STEP<<i, i-=8;
					case 5:	otp |= RC4_STEP<<i, i-=8;
					case 4:	otp |= RC4_STEP<<i, i-=8;
					case 3:	otp |= RC4_STEP<<i, i-=8;
					case 2:	otp |= RC4_STEP<<i, i-=8;
					case 1:	otp |= RC4_STEP<<i, i-=8;
					}
d196 1
a196 1
				ochunk |= (otp^ichunk) & mask;
d198 3
a200 3
				}
			key->x=x;     
			key->y=y;
d202 1
a202 3
			}
		else
			{	/* LITTLE-ENDIAN CASE */
d204 14
a217 16
			for (;len&(0-sizeof(RC4_CHUNK));len-=sizeof(RC4_CHUNK))
				{
				ichunk  = *(RC4_CHUNK *)indata;
				otp  = RC4_STEP;
				otp |= RC4_STEP<<8;
				otp |= RC4_STEP<<16;
				otp |= RC4_STEP<<24;
				if (sizeof(RC4_CHUNK)==8)
					{
					otp |= RC4_STEP<<LESHFT(4);
					otp |= RC4_STEP<<LESHFT(5);
					otp |= RC4_STEP<<LESHFT(6);
					otp |= RC4_STEP<<LESHFT(7);
					}
				*(RC4_CHUNK *)outdata = otp^ichunk;
				indata  += sizeof(RC4_CHUNK);
d219 3
a221 4
				}
			if (len)
				{
				RC4_CHUNK mask=(RC4_CHUNK)-1, ochunk;
d226 18
a243 12
				i   = 0;
				mask >>= (sizeof(RC4_CHUNK)-len)<<3;
				switch (len&(sizeof(RC4_CHUNK)-1))
					{
					case 7:	otp  = RC4_STEP,    i+=8;
					case 6:	otp |= RC4_STEP<<i, i+=8;
					case 5:	otp |= RC4_STEP<<i, i+=8;
					case 4:	otp |= RC4_STEP<<i, i+=8;
					case 3:	otp |= RC4_STEP<<i, i+=8;
					case 2:	otp |= RC4_STEP<<i, i+=8;
					case 1:	otp |= RC4_STEP<<i, i+=8;
					}
d245 1
a245 1
				ochunk |= (otp^ichunk) & mask;
d247 3
a249 3
				}
			key->x=x;     
			key->y=y;
a250 1
			}
d252 1
d268 11
a278 13
	i=len>>3;
	if (i)
		{
		for (;;)
			{
			RC4_LOOP(indata,outdata,0);
			RC4_LOOP(indata,outdata,1);
			RC4_LOOP(indata,outdata,2);
			RC4_LOOP(indata,outdata,3);
			RC4_LOOP(indata,outdata,4);
			RC4_LOOP(indata,outdata,5);
			RC4_LOOP(indata,outdata,6);
			RC4_LOOP(indata,outdata,7);
d280 2
a281 2
			indata+=8;
			outdata+=8;
d283 28
a310 2
			if (--i == 0) break;
			}
a311 16
	i=len&0x07;
	if (i)
		{
		for (;;)
			{
			RC4_LOOP(indata,outdata,0); if (--i == 0) break;
			RC4_LOOP(indata,outdata,1); if (--i == 0) break;
			RC4_LOOP(indata,outdata,2); if (--i == 0) break;
			RC4_LOOP(indata,outdata,3); if (--i == 0) break;
			RC4_LOOP(indata,outdata,4); if (--i == 0) break;
			RC4_LOOP(indata,outdata,5); if (--i == 0) break;
			RC4_LOOP(indata,outdata,6); if (--i == 0) break;
			}
		}               
	key->x=x;     
	key->y=y;
d313 3
@


1.12
log
@Remove leading underscore from _BYTE_ORDER and _{LITTLE,BIG}_ENDIAN, to be
more friendly to systems where the underscore flavours may be defined as empty.
Found the hard way be bcook@@; joint brainstrom with bcook beck and guenther
@
text
@d1 1
a1 1
/* $OpenBSD: rc4_enc.c,v 1.11 2014/06/12 15:49:30 deraadt Exp $ */
d74 2
a75 2
        register RC4_INT *d;
        register RC4_INT x,y,tx,ty;
@


1.11
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d153 1
a153 1
		if (_BYTE_ORDER != _LITTLE_ENDIAN)
@


1.10
log
@typo in comment
@
text
@d1 1
a1 1
/* crypto/rc4/rc4_enc.c */
@


1.9
log
@I'm glad to know that Ultrix CC has a bug optimizing switch() statements
lacking an explicit `case 0:' construct. But Ultrix has been dead for more than
15 years, really. Don't give it any reason to move out of its coffin.
@
text
@d103 1
a103 1
	 * Cavets.
@


1.8
log
@Figure out endianness at compile-time, using _BYTE_ORDER from
<machine/endian.h>, rather than writing 1 to a 32-bit variable and checking
whether the first byte is nonzero.

tweaks and ok matthew@@; ok beck@@ tedu@@
@
text
@a191 5
					case 0: ; /*
						   * it's never the case,
						   * but it has to be here
						   * for ultrix?
						   */
a239 5
					case 0: ; /*
						   * it's never the case,
						   * but it has to be here
						   * for ultrix?
						   */
@


1.7
log
@resolve conflicts, fix local changes
@
text
@d59 1
a127 1
		const union { long one; char little; } is_endian = {1};
d135 1
a135 2
		 * suggestion from Terrel Larson <terr@@terralogic.net>
		 * who also stands for the is_endian union:-)
a138 3
		 * - is_endian is declared automatic as doing otherwise
		 *   (declaring static) prevents gcc from eliminating
		 *   the redundant code;
d153 1
a153 1
		if (!is_endian.little)
@


1.6
log
@resolve conflicts
@
text
@d70 1
a70 1
void RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata,
d75 1
a75 1
	int i;
d123 2
a124 2
	if ( ( ((unsigned long)indata  & (sizeof(RC4_CHUNK)-1)) | 
	       ((unsigned long)outdata & (sizeof(RC4_CHUNK)-1)) ) == 0 )
d160 1
a160 1
			for (;len&~(sizeof(RC4_CHUNK)-1);len-=sizeof(RC4_CHUNK))
d213 1
a213 1
			for (;len&~(sizeof(RC4_CHUNK)-1);len-=sizeof(RC4_CHUNK))
d279 1
a279 1
	i=(int)(len>>3L);
d299 1
a299 1
	i=(int)len&0x07;
@


1.5
log
@resolve conflicts
@
text
@d160 1
a160 1
			for (;len&-sizeof(RC4_CHUNK);len-=sizeof(RC4_CHUNK))
d213 1
a213 1
			for (;len&-sizeof(RC4_CHUNK);len-=sizeof(RC4_CHUNK))
@


1.4
log
@resolve conflicts
@
text
@a79 4
#if defined(__ia64) || defined(__ia64__) || defined(_M_IA64)
	/* see crypto/rc4/asm/rc4-ia64.S for further details... */
	d=(RC4_INT *)(((size_t)(d+255))&~(sizeof(key->data)-1));
#endif
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d80 4
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d70 1
a70 1
void RC4(RC4_KEY *key, unsigned long len, unsigned char *indata,
d81 184
@


1.1
log
@Initial revision
@
text
@d59 1
a59 1
#include "rc4.h"
d70 2
a71 5
void RC4(key, len, indata, outdata)
RC4_KEY *key;
unsigned long len;
unsigned char *indata;
unsigned char *outdata;
a94 1
	i= -(int)len;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d59 1
a59 1
#include <openssl/rc4.h>
d70 5
a74 2
void RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata,
	     unsigned char *outdata)
a83 184
#if defined(RC4_CHUNK)
	/*
	 * The original reason for implementing this(*) was the fact that
	 * pre-21164a Alpha CPUs don't have byte load/store instructions
	 * and e.g. a byte store has to be done with 64-bit load, shift,
	 * and, or and finally 64-bit store. Peaking data and operating
	 * at natural word size made it possible to reduce amount of
	 * instructions as well as to perform early read-ahead without
	 * suffering from RAW (read-after-write) hazard. This resulted
	 * in ~40%(**) performance improvement on 21064 box with gcc.
	 * But it's not only Alpha users who win here:-) Thanks to the
	 * early-n-wide read-ahead this implementation also exhibits
	 * >40% speed-up on SPARC and 20-30% on 64-bit MIPS (depending
	 * on sizeof(RC4_INT)).
	 *
	 * (*)	"this" means code which recognizes the case when input
	 *	and output pointers appear to be aligned at natural CPU
	 *	word boundary
	 * (**)	i.e. according to 'apps/openssl speed rc4' benchmark,
	 *	crypto/rc4/rc4speed.c exhibits almost 70% speed-up...
	 *
	 * Cavets.
	 *
	 * - RC4_CHUNK="unsigned long long" should be a #1 choice for
	 *   UltraSPARC. Unfortunately gcc generates very slow code
	 *   (2.5-3 times slower than one generated by Sun's WorkShop
	 *   C) and therefore gcc (at least 2.95 and earlier) should
	 *   always be told that RC4_CHUNK="unsigned long".
	 *
	 *					<appro@@fy.chalmers.se>
	 */

# define RC4_STEP	( \
			x=(x+1) &0xff,	\
			tx=d[x],	\
			y=(tx+y)&0xff,	\
			ty=d[y],	\
			d[y]=tx,	\
			d[x]=ty,	\
			(RC4_CHUNK)d[(tx+ty)&0xff]\
			)

	if ( ( ((unsigned long)indata  & (sizeof(RC4_CHUNK)-1)) | 
	       ((unsigned long)outdata & (sizeof(RC4_CHUNK)-1)) ) == 0 )
		{
		RC4_CHUNK ichunk,otp;
		const union { long one; char little; } is_endian = {1};

		/*
		 * I reckon we can afford to implement both endian
		 * cases and to decide which way to take at run-time
		 * because the machine code appears to be very compact
		 * and redundant 1-2KB is perfectly tolerable (i.e.
		 * in case the compiler fails to eliminate it:-). By
		 * suggestion from Terrel Larson <terr@@terralogic.net>
		 * who also stands for the is_endian union:-)
		 *
		 * Special notes.
		 *
		 * - is_endian is declared automatic as doing otherwise
		 *   (declaring static) prevents gcc from eliminating
		 *   the redundant code;
		 * - compilers (those I've tried) don't seem to have
		 *   problems eliminating either the operators guarded
		 *   by "if (sizeof(RC4_CHUNK)==8)" or the condition
		 *   expressions themselves so I've got 'em to replace
		 *   corresponding #ifdefs from the previous version;
		 * - I chose to let the redundant switch cases when
		 *   sizeof(RC4_CHUNK)!=8 be (were also #ifdefed
		 *   before);
		 * - in case you wonder "&(sizeof(RC4_CHUNK)*8-1)" in
		 *   [LB]ESHFT guards against "shift is out of range"
		 *   warnings when sizeof(RC4_CHUNK)!=8 
		 *
		 *			<appro@@fy.chalmers.se>
		 */
		if (!is_endian.little)
			{	/* BIG-ENDIAN CASE */
# define BESHFT(c)	(((sizeof(RC4_CHUNK)-(c)-1)*8)&(sizeof(RC4_CHUNK)*8-1))
			for (;len&-sizeof(RC4_CHUNK);len-=sizeof(RC4_CHUNK))
				{
				ichunk  = *(RC4_CHUNK *)indata;
				otp  = RC4_STEP<<BESHFT(0);
				otp |= RC4_STEP<<BESHFT(1);
				otp |= RC4_STEP<<BESHFT(2);
				otp |= RC4_STEP<<BESHFT(3);
				if (sizeof(RC4_CHUNK)==8)
					{
					otp |= RC4_STEP<<BESHFT(4);
					otp |= RC4_STEP<<BESHFT(5);
					otp |= RC4_STEP<<BESHFT(6);
					otp |= RC4_STEP<<BESHFT(7);
					}
				*(RC4_CHUNK *)outdata = otp^ichunk;
				indata  += sizeof(RC4_CHUNK);
				outdata += sizeof(RC4_CHUNK);
				}
			if (len)
				{
				RC4_CHUNK mask=(RC4_CHUNK)-1, ochunk;

				ichunk = *(RC4_CHUNK *)indata;
				ochunk = *(RC4_CHUNK *)outdata;
				otp = 0;
				i = BESHFT(0);
				mask <<= (sizeof(RC4_CHUNK)-len)<<3;
				switch (len&(sizeof(RC4_CHUNK)-1))
					{
					case 7:	otp  = RC4_STEP<<i, i-=8;
					case 6:	otp |= RC4_STEP<<i, i-=8;
					case 5:	otp |= RC4_STEP<<i, i-=8;
					case 4:	otp |= RC4_STEP<<i, i-=8;
					case 3:	otp |= RC4_STEP<<i, i-=8;
					case 2:	otp |= RC4_STEP<<i, i-=8;
					case 1:	otp |= RC4_STEP<<i, i-=8;
					case 0: ; /*
						   * it's never the case,
						   * but it has to be here
						   * for ultrix?
						   */
					}
				ochunk &= ~mask;
				ochunk |= (otp^ichunk) & mask;
				*(RC4_CHUNK *)outdata = ochunk;
				}
			key->x=x;     
			key->y=y;
			return;
			}
		else
			{	/* LITTLE-ENDIAN CASE */
# define LESHFT(c)	(((c)*8)&(sizeof(RC4_CHUNK)*8-1))
			for (;len&-sizeof(RC4_CHUNK);len-=sizeof(RC4_CHUNK))
				{
				ichunk  = *(RC4_CHUNK *)indata;
				otp  = RC4_STEP;
				otp |= RC4_STEP<<8;
				otp |= RC4_STEP<<16;
				otp |= RC4_STEP<<24;
				if (sizeof(RC4_CHUNK)==8)
					{
					otp |= RC4_STEP<<LESHFT(4);
					otp |= RC4_STEP<<LESHFT(5);
					otp |= RC4_STEP<<LESHFT(6);
					otp |= RC4_STEP<<LESHFT(7);
					}
				*(RC4_CHUNK *)outdata = otp^ichunk;
				indata  += sizeof(RC4_CHUNK);
				outdata += sizeof(RC4_CHUNK);
				}
			if (len)
				{
				RC4_CHUNK mask=(RC4_CHUNK)-1, ochunk;

				ichunk = *(RC4_CHUNK *)indata;
				ochunk = *(RC4_CHUNK *)outdata;
				otp = 0;
				i   = 0;
				mask >>= (sizeof(RC4_CHUNK)-len)<<3;
				switch (len&(sizeof(RC4_CHUNK)-1))
					{
					case 7:	otp  = RC4_STEP,    i+=8;
					case 6:	otp |= RC4_STEP<<i, i+=8;
					case 5:	otp |= RC4_STEP<<i, i+=8;
					case 4:	otp |= RC4_STEP<<i, i+=8;
					case 3:	otp |= RC4_STEP<<i, i+=8;
					case 2:	otp |= RC4_STEP<<i, i+=8;
					case 1:	otp |= RC4_STEP<<i, i+=8;
					case 0: ; /*
						   * it's never the case,
						   * but it has to be here
						   * for ultrix?
						   */
					}
				ochunk &= ~mask;
				ochunk |= (otp^ichunk) & mask;
				*(RC4_CHUNK *)outdata = ochunk;
				}
			key->x=x;     
			key->y=y;
			return;
			}
		}
#endif
d98 1
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a79 4
#if defined(__ia64) || defined(__ia64__) || defined(_M_IA64)
	/* see crypto/rc4/asm/rc4-ia64.S for further details... */
	d=(RC4_INT *)(((size_t)(d+255))&~(sizeof(key->data)-1));
#endif
@


1.1.1.4
log
@import of openssl-0.9.7j
@
text
@d80 4
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d160 1
a160 1
			for (;len&~(sizeof(RC4_CHUNK)-1);len-=sizeof(RC4_CHUNK))
d213 1
a213 1
			for (;len&~(sizeof(RC4_CHUNK)-1);len-=sizeof(RC4_CHUNK))
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d70 1
a70 1
void RC4(RC4_KEY *key, size_t len, const unsigned char *indata,
d75 1
a75 1
	size_t i;
d123 2
a124 2
	if ( ( ((size_t)indata  & (sizeof(RC4_CHUNK)-1)) | 
	       ((size_t)outdata & (sizeof(RC4_CHUNK)-1)) ) == 0 )
d160 1
a160 1
			for (;len&(0-sizeof(RC4_CHUNK));len-=sizeof(RC4_CHUNK))
d213 1
a213 1
			for (;len&(0-sizeof(RC4_CHUNK));len-=sizeof(RC4_CHUNK))
d279 1
a279 1
	i=len>>3;
d299 1
a299 1
	i=len&0x07;
@


