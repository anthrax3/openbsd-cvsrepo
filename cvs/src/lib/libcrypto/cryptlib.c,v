head	1.40;
access;
symbols
	OPENBSD_6_1:1.40.0.2
	OPENBSD_6_1_BASE:1.40;
locks; strict;
comment	@ * @;


1.40
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.39;
commitid	kT0fLt3r4lroFJra;

1.39
date	2016.11.04.17.30.30;	author miod;	state Exp;
branches;
next	1.38;
commitid	uVQFi30uotTYOUA9;

1.38
date	2016.11.04.13.56.04;	author miod;	state Exp;
branches;
next	1.37;
commitid	TilmOttV27QFPTgF;

1.37
date	2015.09.13.16.56.11;	author miod;	state Exp;
branches;
next	1.36;
commitid	0b5fDyJXn1VKqels;

1.36
date	2015.09.13.10.02.49;	author miod;	state Exp;
branches;
next	1.35;
commitid	TOlJlYmAKCXz3l7H;

1.35
date	2015.06.27.22.42.02;	author doug;	state Exp;
branches;
next	1.34;
commitid	SCorSKxSjA70Bnvw;

1.34
date	2015.01.22.03.56.27;	author bcook;	state Exp;
branches;
next	1.33;
commitid	wOxILqrTORrmIA4w;

1.33
date	2014.07.22.02.21.20;	author beck;	state Exp;
branches;
next	1.32;
commitid	iBnKYMaAFvJMFyL2;

1.32
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.31;
commitid	yQEL1wOWIearrW15;

1.31
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.30;
commitid	nzndm3zqPmFurSaK;

1.30
date	2014.07.10.22.13.39;	author jsing;	state Exp;
branches;
next	1.29;
commitid	JqSczSY2vDkvb0lV;

1.29
date	2014.07.10.20.02.58;	author jsing;	state Exp;
branches;
next	1.28;
commitid	aEKTOex8gmsqUYet;

1.28
date	2014.07.10.13.58.21;	author jsing;	state Exp;
branches;
next	1.27;
commitid	id8dTrTMtnTn4fqt;

1.27
date	2014.06.20.21.00.46;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	cPW6VxreIaECmYIA;

1.26
date	2014.06.12.15.49.27;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	mJUVYpkFBZ0Zv2bG;

1.25
date	2014.05.31.22.12.52;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	ggWAW7BZqs21VbA4;

1.24
date	2014.05.25.17.50.48;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.21.11.19.28;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.20.14.24.11;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.21.32.37;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.17.17.50.44;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.16.02.42.05;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.15.13.41.53;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.13.19.50.56;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.13.15.25.29;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.13.21.25.12;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.01.22.58.51;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.09.12.15.22;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.06.12.17.48;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.27.05.06.55;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.29.05.39.16;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.35;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.10;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.02;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.08.27;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.23;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.34;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.34;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.40;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.35.06;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.43.28;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.34.26;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.01;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.06.27.05.05.30;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.13.50;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.02;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2011.11.03.02.32.07;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2012.10.13.21.23.33;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: cryptlib.c,v 1.39 2016/11/04 17:30:30 miod Exp $ */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECDH support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */

#include <limits.h>
#include <stdarg.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>

#include <openssl/opensslconf.h>

#include <openssl/crypto.h>
#include <openssl/buffer.h>
#include <openssl/err.h>
#include <openssl/safestack.h>
#include <openssl/sha.h>

DECLARE_STACK_OF(CRYPTO_dynlock)

/* real #defines in crypto.h, keep these upto date */
static const char* const lock_names[CRYPTO_NUM_LOCKS] = {
	"<<ERROR>>",
	"err",
	"ex_data",
	"x509",
	"x509_info",
	"x509_pkey",
	"x509_crl",
	"x509_req",
	"dsa",
	"rsa",
	"evp_pkey",
	"x509_store",
	"ssl_ctx",
	"ssl_cert",
	"ssl_session",
	"ssl_sess_cert",
	"ssl",
	"ssl_method",
	"rand",
	"rand2",
	"debug_malloc",
	"BIO",
	"gethostbyname",
	"getservbyname",
	"readdir",
	"RSA_blinding",
	"dh",
	"debug_malloc2",
	"dso",
	"dynlock",
	"engine",
	"ui",
	"ecdsa",
	"ec",
	"ecdh",
	"bn",
	"ec_pre_comp",
	"store",
	"comp",
	"fips",
	"fips2",
#if CRYPTO_NUM_LOCKS != 41
# error "Inconsistency between crypto.h and cryptlib.c"
#endif
};

/* This is for applications to allocate new type names in the non-dynamic
   array of lock names.  These are numbered with positive numbers.  */
static STACK_OF(OPENSSL_STRING) *app_locks = NULL;

/* For applications that want a more dynamic way of handling threads, the
   following stack is used.  These are externally numbered with negative
   numbers.  */
static STACK_OF(CRYPTO_dynlock) *dyn_locks = NULL;

static void (*locking_callback)(int mode, int type,
    const char *file, int line) = 0;
static int (*add_lock_callback)(int *pointer, int amount,
    int type, const char *file, int line) = 0;
#ifndef OPENSSL_NO_DEPRECATED
static unsigned long (*id_callback)(void) = 0;
#endif
static void (*threadid_callback)(CRYPTO_THREADID *) = 0;
static struct CRYPTO_dynlock_value *(*dynlock_create_callback)(
    const char *file, int line) = 0;
static void (*dynlock_lock_callback)(int mode,
    struct CRYPTO_dynlock_value *l, const char *file, int line) = 0;
static void (*dynlock_destroy_callback)(struct CRYPTO_dynlock_value *l,
    const char *file, int line) = 0;

int
CRYPTO_get_new_lockid(char *name)
{
	char *str;
	int i;

	if ((app_locks == NULL) &&
	    ((app_locks = sk_OPENSSL_STRING_new_null()) == NULL)) {
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
		return (0);
	}
	if (name == NULL || (str = strdup(name)) == NULL) {
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
		return (0);
	}
	i = sk_OPENSSL_STRING_push(app_locks, str);
	if (!i)
		free(str);
	else
		i += CRYPTO_NUM_LOCKS; /* gap of one :-) */
	return (i);
}

int
CRYPTO_num_locks(void)
{
	return CRYPTO_NUM_LOCKS;
}

int
CRYPTO_get_new_dynlockid(void)
{
	int i = 0;
	CRYPTO_dynlock *pointer = NULL;

	if (dynlock_create_callback == NULL) {
		CRYPTOerror(CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK);
		return (0);
	}
	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);
	if ((dyn_locks == NULL) &&
	    ((dyn_locks = sk_CRYPTO_dynlock_new_null()) == NULL)) {
		CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
		return (0);
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	pointer = malloc(sizeof(CRYPTO_dynlock));
	if (pointer == NULL) {
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
		return (0);
	}
	pointer->references = 1;
	pointer->data = dynlock_create_callback(__FILE__, __LINE__);
	if (pointer->data == NULL) {
		free(pointer);
		CRYPTOerror(ERR_R_MALLOC_FAILURE);
		return (0);
	}

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);
	/* First, try to find an existing empty slot */
	i = sk_CRYPTO_dynlock_find(dyn_locks, NULL);
	/* If there was none, push, thereby creating a new one */
	if (i == -1)
		/* Since sk_push() returns the number of items on the
		   stack, not the location of the pushed item, we need
		   to transform the returned number into a position,
		   by decreasing it.  */
		i = sk_CRYPTO_dynlock_push(dyn_locks, pointer) - 1;
	else
		/* If we found a place with a NULL pointer, put our pointer
		   in it.  */
		(void)sk_CRYPTO_dynlock_set(dyn_locks, i, pointer);
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (i == -1) {
		dynlock_destroy_callback(pointer->data, __FILE__, __LINE__);
		free(pointer);
	} else
		i += 1; /* to avoid 0 */
	return -i;
}

void
CRYPTO_destroy_dynlockid(int i)
{
	CRYPTO_dynlock *pointer = NULL;

	if (i)
		i = -i - 1;
	if (dynlock_destroy_callback == NULL)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);

	if (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks)) {
		CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);
		return;
	}
	pointer = sk_CRYPTO_dynlock_value(dyn_locks, i);
	if (pointer != NULL) {
		--pointer->references;
		if (pointer->references <= 0) {
			(void)sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);
		} else
			pointer = NULL;
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (pointer) {
		dynlock_destroy_callback(pointer->data, __FILE__, __LINE__);
		free(pointer);
	}
}

struct CRYPTO_dynlock_value *
CRYPTO_get_dynlock_value(int i)
{
	CRYPTO_dynlock *pointer = NULL;

	if (i)
		i = -i - 1;

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);

	if (dyn_locks != NULL && i < sk_CRYPTO_dynlock_num(dyn_locks))
		pointer = sk_CRYPTO_dynlock_value(dyn_locks, i);
	if (pointer)
		pointer->references++;

	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (pointer)
		return pointer->data;
	return NULL;
}

struct CRYPTO_dynlock_value *
(*CRYPTO_get_dynlock_create_callback(void))(const char *file, int line)
{
	return (dynlock_create_callback);
}

void
(*CRYPTO_get_dynlock_lock_callback(void))(int mode,
    struct CRYPTO_dynlock_value *l, const char *file, int line)
{
	return (dynlock_lock_callback);
}

void
(*CRYPTO_get_dynlock_destroy_callback(void))(struct CRYPTO_dynlock_value *l,
    const char *file, int line)
{
	return (dynlock_destroy_callback);
}

void
CRYPTO_set_dynlock_create_callback(
    struct CRYPTO_dynlock_value *(*func)(const char *file, int line))
{
	dynlock_create_callback = func;
}

void
CRYPTO_set_dynlock_lock_callback(void (*func)(int mode,
    struct CRYPTO_dynlock_value *l, const char *file, int line))
{
	dynlock_lock_callback = func;
}

void
CRYPTO_set_dynlock_destroy_callback(
    void (*func)(struct CRYPTO_dynlock_value *l, const char *file, int line))
{
	dynlock_destroy_callback = func;
}

void
(*CRYPTO_get_locking_callback(void))(int mode, int type, const char *file,
    int line)
{
	return (locking_callback);
}

int
(*CRYPTO_get_add_lock_callback(void))(int *num, int mount, int type,
    const char *file, int line)
{
	return (add_lock_callback);
}

void
CRYPTO_set_locking_callback(void (*func)(int mode, int type,
    const char *file, int line))
{
	/* Calling this here ensures initialisation before any threads
	 * are started.
	 */
	OPENSSL_init();
	locking_callback = func;
}

void
CRYPTO_set_add_lock_callback(int (*func)(int *num, int mount, int type,
    const char *file, int line))
{
	add_lock_callback = func;
}

/* the memset() here and in set_pointer() seem overkill, but for the sake of
 * CRYPTO_THREADID_cmp() this avoids any platform silliness that might cause two
 * "equal" THREADID structs to not be memcmp()-identical. */
void
CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val)
{
	memset(id, 0, sizeof(*id));
	id->val = val;
}

void
CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr)
{
	memset(id, 0, sizeof(*id));
	id->ptr = ptr;
#if ULONG_MAX >= UINTPTR_MAX
	/*s u 'ptr' can be embedded in 'val' without loss of uniqueness */
	id->val = (uintptr_t)id->ptr;
#else
	{
		SHA256_CTX ctx;
		uint8_t results[SHA256_DIGEST_LENGTH];

		SHA256_Init(&ctx);
		SHA256_Update(&ctx, (char *)(&id->ptr), sizeof(id->ptr));
		SHA256_Final(results, &ctx);
		memcpy(&id->val, results, sizeof(id->val));
	}
#endif
}

int
CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))
{
	if (threadid_callback)
		return 0;
	threadid_callback = func;
	return 1;
}

void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *)
{
	return threadid_callback;
}

void
CRYPTO_THREADID_current(CRYPTO_THREADID *id)
{
	if (threadid_callback) {
		threadid_callback(id);
		return;
	}
#ifndef OPENSSL_NO_DEPRECATED
	/* If the deprecated callback was set, fall back to that */
	if (id_callback) {
		CRYPTO_THREADID_set_numeric(id, id_callback());
		return;
	}
#endif
	/* Else pick a backup */
	/* For everything else, default to using the address of 'errno' */
	CRYPTO_THREADID_set_pointer(id, (void*)&errno);
}

int
CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a, const CRYPTO_THREADID *b)
{
	return memcmp(a, b, sizeof(*a));
}

void
CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest, const CRYPTO_THREADID *src)
{
	memcpy(dest, src, sizeof(*src));
}

unsigned long
CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)
{
	return id->val;
}

#ifndef OPENSSL_NO_DEPRECATED
unsigned long (*CRYPTO_get_id_callback(void))(void)
{
	return (id_callback);
}

void
CRYPTO_set_id_callback(unsigned long (*func)(void))
{
	id_callback = func;
}

unsigned long
CRYPTO_thread_id(void)
{
	unsigned long ret = 0;

	if (id_callback == NULL) {
		ret = (unsigned long)getpid();
	} else
		ret = id_callback();
	return (ret);
}
#endif

void
CRYPTO_lock(int mode, int type, const char *file, int line)
{
#ifdef LOCK_DEBUG
	{
		CRYPTO_THREADID id;
		char *rw_text, *operation_text;

		if (mode & CRYPTO_LOCK)
			operation_text = "lock  ";
		else if (mode & CRYPTO_UNLOCK)
			operation_text = "unlock";
		else
			operation_text = "ERROR ";

		if (mode & CRYPTO_READ)
			rw_text = "r";
		else if (mode & CRYPTO_WRITE)
			rw_text = "w";
		else
			rw_text = "ERROR";

		CRYPTO_THREADID_current(&id);
		fprintf(stderr, "lock:%08lx:(%s)%s %-18s %s:%d\n",
		    CRYPTO_THREADID_hash(&id), rw_text, operation_text,
		    CRYPTO_get_lock_name(type), file, line);
	}
#endif
	if (type < 0) {
		if (dynlock_lock_callback != NULL) {
			struct CRYPTO_dynlock_value *pointer =
			    CRYPTO_get_dynlock_value(type);

			OPENSSL_assert(pointer != NULL);

			dynlock_lock_callback(mode, pointer, file, line);

			CRYPTO_destroy_dynlockid(type);
		}
	} else if (locking_callback != NULL)
		locking_callback(mode, type, file, line);
}

int
CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,
    int line)
{
	int ret = 0;

	if (add_lock_callback != NULL) {
#ifdef LOCK_DEBUG
		int before= *pointer;
#endif

		ret = add_lock_callback(pointer, amount, type, file, line);
#ifdef LOCK_DEBUG
		{
			CRYPTO_THREADID id;
			CRYPTO_THREADID_current(&id);
			fprintf(stderr, "ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\n",
			    CRYPTO_THREADID_hash(&id), before, amount, ret,
			    CRYPTO_get_lock_name(type),
			    file, line);
		}
#endif
	} else {
		CRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE, type, file, line);

		ret= *pointer + amount;
#ifdef LOCK_DEBUG
		{
			CRYPTO_THREADID id;
			CRYPTO_THREADID_current(&id);
			fprintf(stderr, "ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\n",
			    CRYPTO_THREADID_hash(&id), *pointer, amount, ret,
			    CRYPTO_get_lock_name(type), file, line);
		}
#endif
		*pointer = ret;
		CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE, type, file, line);
	}
	return (ret);
}

const char *
CRYPTO_get_lock_name(int type)
{
	if (type < 0)
		return("dynamic");
	else if (type < CRYPTO_NUM_LOCKS)
		return (lock_names[type]);
	else if (type - CRYPTO_NUM_LOCKS > sk_OPENSSL_STRING_num(app_locks))
		return("ERROR");
	else
		return (sk_OPENSSL_STRING_value(app_locks,
		    type - CRYPTO_NUM_LOCKS));
}

#if	defined(__i386)   || defined(__i386__)   || defined(_M_IX86) || \
	defined(__INTEL__) || \
	defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)

uint64_t OPENSSL_ia32cap_P;

uint64_t
OPENSSL_cpu_caps(void)
{
	return OPENSSL_ia32cap_P;
}

#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM)
#define OPENSSL_CPUID_SETUP
void
OPENSSL_cpuid_setup(void)
{
	static int trigger = 0;
	uint64_t OPENSSL_ia32_cpuid(void);

	if (trigger)
		return;
	trigger = 1;
	OPENSSL_ia32cap_P = OPENSSL_ia32_cpuid();
}
#endif

#else
uint64_t
OPENSSL_cpu_caps(void)
{
	return 0;
}
#endif

#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)
void
OPENSSL_cpuid_setup(void)
{
}
#endif

static void
OPENSSL_showfatal(const char *fmta, ...)
{
	va_list ap;

	va_start(ap, fmta);
	vfprintf(stderr, fmta, ap);
	va_end(ap);
}

void
OpenSSLDie(const char *file, int line, const char *assertion)
{
	OPENSSL_showfatal(
	    "%s(%d): OpenSSL internal error, assertion failed: %s\n",
	    file, line, assertion);
	abort();
}

int
CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len)
{
	size_t i;
	const unsigned char *a = in_a;
	const unsigned char *b = in_b;
	unsigned char x = 0;

	for (i = 0; i < len; i++)
		x |= a[i] ^ b[i];

	return x;
}
@


1.39
log
@Replace all uses of magic numbers when operating on OPENSSL_ia32_P[] by
meaningful constants in a private header file, so that reviewers can actually
get a chance to figure out what the code is attempting to do without knowing
all cpuid bits.

While there, turn it from an array of two 32-bit ints into a properly aligned
64-bit int.

Use of OPENSSL_ia32_P is now restricted to the assembler parts. C code will
now always use OPENSSL_cpu_caps() and check for the proper bits in the
whole 64-bit word it returns.

i386 tests and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.38 2016/11/04 13:56:04 miod Exp $ */
d213 1
a213 1
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID, ERR_R_MALLOC_FAILURE);
d217 1
a217 1
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID, ERR_R_MALLOC_FAILURE);
d241 1
a241 2
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,
		    CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK);
d248 1
a248 2
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,
		    ERR_R_MALLOC_FAILURE);
d255 1
a255 2
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,
		    ERR_R_MALLOC_FAILURE);
d262 1
a262 2
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,
		    ERR_R_MALLOC_FAILURE);
@


1.38
log
@Remove I386_ONLY define. It was only used to prefer a
faster-on-genuine-80386-but-slower-on-80486-onwards innstruction sequence in
the SHA512 code, and had not been enabled in years, if at all.

ok tom@@ bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.37 2015/09/13 16:56:11 miod Exp $ */
d630 1
a630 1
unsigned int  OPENSSL_ia32cap_P[2];
d635 1
a635 1
	return *(uint64_t *)OPENSSL_ia32cap_P;
a639 1
typedef unsigned long long IA32CAP;
d644 1
a644 2
	IA32CAP OPENSSL_ia32_cpuid(void);
	IA32CAP vec;
d649 1
a649 10

	vec = OPENSSL_ia32_cpuid();

	/*
	 * |(1<<10) sets a reserved bit to signal that variable
	 * was initialized already... This is to avoid interference
	 * with cpuid snippets in ELF .init segment.
	 */
	OPENSSL_ia32cap_P[0] = (unsigned int)vec | (1 << 10);
	OPENSSL_ia32cap_P[1] = (unsigned int)(vec >> 32);
a653 6
unsigned long *
OPENSSL_ia32cap_loc(void)
{
	return NULL;
}

@


1.37
log
@Since a major bump of libcrypto is coming, remove OPENSSL_ia32cap and
OPENSSL_ia32cap_loc; nothing in ports uses them besides embedded copies of
OpenSSL. This opens the `all hell gets loose' window.
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.36 2015/09/13 10:02:49 miod Exp $ */
d638 1
a638 1
#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)
@


1.36
log
@Add a new interface, OPENSSL_cpu_caps(), to return the currently running
cpu's specific hardware capabilities users of libcrypto might be interested
in, as an integer value. This deprecates the existing OPENSSL_ia32cap()
macro and the OPENSSL_ia32cap_loc() function (which returns the pointer so
that you can mess with stuff you shouldn't mess with).

Interpreting the value returned by OPENSSL_cpu_caps() is, of course,
machine-dependent.

Minor version bump for libcrypto.
ok beck@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.35 2015/06/27 22:42:02 doug Exp $ */
a630 12
unsigned long *
OPENSSL_ia32cap_loc(void)
{
	if (sizeof(long) == 4)
		/*
		 * If 32-bit application pulls address of OPENSSL_ia32cap_P[0]
		 * clear second element to maintain the illusion that vector
		 * is 32-bit.
		 */
		OPENSSL_ia32cap_P[1] = 0;
	return (unsigned long *)OPENSSL_ia32cap_P;
}
@


1.35
log
@Fix pointer to unsigned long conversion.

bcook@@ notes that this check really only impacted 64-bit Windows.  Also,
changed the check to be unsigned for consistency.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.34 2015/01/22 03:56:27 bcook Exp $ */
d644 6
d681 6
@


1.34
log
@Assume that the size of a pointer will not change at runtime.

Change the runtime check for whether a long is smaller than a pointer to a
compile-time check. Replace the silly hash for LLP64 platforms.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.33 2014/07/22 02:21:20 beck Exp $ */
d117 1
d119 1
d436 1
a436 1
#if LONG_MAX >= INTPTR_MAX
d438 1
a438 1
	id->val = (unsigned long)id->ptr;
@


1.33
log
@Kill a bunch more BUF_strdup's - these are converted to have a check for
NULL before an intrinsic strdup.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.32 2014/07/11 08:44:47 jsing Exp $ */
d127 1
a428 1
static const unsigned char hash_coeffs[] = { 3, 5, 7, 11, 13, 17, 19, 23 };
a431 4
	unsigned char *dest = (void *)&id->val;
	unsigned int accum = 0;
	unsigned char dnum = sizeof(id->val);

d434 12
a445 22
	if (sizeof(id->val) >= sizeof(id->ptr)) {
		/* 'ptr' can be embedded in 'val' without loss of uniqueness */
		id->val = (unsigned long)id->ptr;
		return;
	}
	/* hash ptr ==> val. Each byte of 'val' gets the mod-256 total of a
	 * linear function over the bytes in 'ptr', the co-efficients of which
	 * are a sequence of low-primes (hash_coeffs is an 8-element cycle) -
	 * the starting prime for the sequence varies for each byte of 'val'
	 * (unique polynomials unless pointers are >64-bit). For added spice,
	 * the totals accumulate rather than restarting from zero, and the index
	 * of the 'val' byte is added each time (position dependence). If I was
	 * a black-belt, I'd scan big-endian pointers in reverse to give
	 * low-order bits more play, but this isn't crypto and I'd prefer nobody
	 * mistake it as such. Plus I'm lazy. */
	while (dnum--) {
		const unsigned char *src = (void *)&id->ptr;
		unsigned char snum = sizeof(id->ptr);
		while (snum--)
			accum += *(src++) * hash_coeffs[(snum + dnum) & 7];
		accum += dnum;
		*(dest++) = accum & 255;
d447 1
@


1.32
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.31 2014/07/10 22:45:56 jsing Exp $ */
d213 1
a213 1
	if ((str = BUF_strdup(name)) == NULL) {
@


1.31
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.30 2014/07/10 22:13:39 jsing Exp $ */
d117 1
d123 3
a125 1
#include "cryptlib.h"
@


1.30
log
@OPENSSL_stderr() is unused so nuke it. OPENSSL_showfatal() is only used by
OpenSSLDie(), which is in the same file, so just make it static.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.29 2014/07/10 20:02:58 jsing Exp $ */
d119 2
@


1.29
log
@Nuke OPENSSL_NONPIC_relocated since nothing uses it.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.28 2014/07/10 13:58:21 jsing Exp $ */
d691 1
a691 2

void
a707 6
}

void *
OPENSSL_stderr(void)
{
	return stderr;
@


1.28
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.27 2014/06/20 21:00:46 deraadt Exp $ */
a682 1
int OPENSSL_NONPIC_relocated = 0;
@


1.27
log
@Remove the OPENSSL_*cap getenv's.  A program should not be able to
change the behaviour of the library in such a complicated fashion.
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: cryptlib.c,v 1.26 2014/06/12 15:49:27 deraadt Exp $ */
d116 3
@


1.26
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a655 1
	char *env;
d659 1
d661 1
a661 9
	trigger = 1;
	if ((env = getenv("OPENSSL_ia32cap"))) {
		int off = (env[0] == '~') ? 1 : 0;
		if (!sscanf(env+off, "%lli",(long long *)&vec))
			vec = strtoul(env + off, NULL, 0);
		if (off)
			vec = OPENSSL_ia32_cpuid() & ~vec;
	} else
		vec = OPENSSL_ia32_cpuid();
@


1.25
log
@annoying whitespace
@
text
@d1 1
a1 1
/* crypto/cryptlib.c */
@


1.24
log
@remove OPENSSL_isservice. not used internally, no sane posix software will
call it, and windows service software can figure this out on its own.
ok beck miod
@
text
@d703 3
a705 3
	va_start (ap, fmta);
	vfprintf (stderr, fmta, ap);
	va_end (ap);
@


1.23
log
@modernize malloc call
@
text
@a707 6
int
OPENSSL_isservice(void)
{
	return 0;
}

@


1.22
log
@More KNF.
@
text
@d244 1
a244 1
	pointer = (CRYPTO_dynlock *)malloc(sizeof(CRYPTO_dynlock));
@


1.21
log
@kill REF_PRINT/REF_CHECK debugging framework noone would use
ok miod
@
text
@d10 1
a10 1
 *    notice, this list of conditions and the following disclaimer. 
d61 1
a61 1
 * 
d68 1
a68 1
 * 
d75 1
a75 1
 * 
d90 1
a90 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d93 1
a93 1
 * 
d105 1
a105 1
 * 
d113 1
a113 1
 * ECDH support in OpenSSL originally developed by 
d200 2
a201 1
	if ((app_locks == NULL) && ((app_locks = sk_OPENSSL_STRING_new_null()) == NULL)) {
d230 2
a231 1
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID, CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK);
d235 2
a236 2
	if ((dyn_locks == NULL)
		&& ((dyn_locks = sk_CRYPTO_dynlock_new_null()) == NULL)) {
d238 2
a239 1
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID, ERR_R_MALLOC_FAILURE);
d246 2
a247 1
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID, ERR_R_MALLOC_FAILURE);
d254 2
a255 1
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID, ERR_R_MALLOC_FAILURE);
d280 1
a280 1
	return - i;
d287 1
d319 1
d338 1
a338 2
(*CRYPTO_get_dynlock_create_callback(void))(
    const char *file, int line)
d343 2
a344 1
void (*CRYPTO_get_dynlock_lock_callback(void))(int mode,
d350 3
a352 2
void (*CRYPTO_get_dynlock_destroy_callback(void))(
    struct CRYPTO_dynlock_value *l, const char *file, int line)
d378 3
a380 2
void (*CRYPTO_get_locking_callback(void))(int mode, int type,
    const char *file, int line)
d385 2
a386 1
int (*CRYPTO_get_add_lock_callback(void))(int *num, int mount, int type,
d540 1
a540 1
			operation_text="lock  ";
d542 1
a542 1
			operation_text="unlock";
d544 1
a544 1
			operation_text="ERROR ";
d547 1
a547 1
			rw_text="r";
d549 1
a549 1
			rw_text="w";
d551 1
a551 1
			rw_text="ERROR";
d555 2
a556 2
		CRYPTO_THREADID_hash(&id), rw_text, operation_text,
		CRYPTO_get_lock_name(type), file, line);
d591 3
a593 3
			CRYPTO_THREADID_hash(&id), before, amount, ret,
			CRYPTO_get_lock_name(type),
			file, line);
d605 2
a606 4
			CRYPTO_THREADID_hash(&id),
			*pointer, amount, ret,
			CRYPTO_get_lock_name(type),
			file, line);
d625 2
a626 1
		return (sk_OPENSSL_STRING_value(app_locks, type - CRYPTO_NUM_LOCKS));
d663 1
a663 1
		int off = (env[0]=='~') ? 1 : 0;
d665 1
a665 1
			vec = strtoul(env+off, NULL, 0);
d667 1
a667 1
			vec = OPENSSL_ia32_cpuid()&~vec;
d671 6
a676 6
    /*
     * |(1<<10) sets a reserved bit to signal that variable
     * was initialized already... This is to avoid interference
     * with cpuid snippets in ELF .init segment.
     */
	OPENSSL_ia32cap_P[0] = (unsigned int)vec|(1 << 10);
d682 4
a685 1
	unsigned long *OPENSSL_ia32cap_loc(void) { return NULL;
@


1.20
log
@some KNF cleanup following the script
@
text
@a295 6
#ifdef REF_CHECK
		if (pointer->references < 0) {
			fprintf(stderr, "CRYPTO_destroy_dynlockid, bad reference count\n");
			abort();
		} else
#endif
@


1.19
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a119 4
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)
static double SSLeay_MSVC5_hack = 0.0; /* and for VC1.5 */
#endif

d315 2
a316 2
struct CRYPTO_dynlock_value
*CRYPTO_get_dynlock_value(int i)
d336 2
a337 1
struct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback(void))(
d445 1
a445 1
		accum += *(src++) * hash_coeffs[(snum + dnum) & 7];
d613 2
a614 2
const char
*CRYPTO_get_lock_name(int type)
d631 2
a632 2
unsigned long
*OPENSSL_ia32cap_loc(void)
a645 3
#if defined(_WIN32)
typedef unsigned __int64 IA32CAP;
#else
a646 1
#endif
d661 2
a662 5
#if defined(_WIN32)
		if (!sscanf(env+off, "%I64i", &vec)) vec = strtoul(env+off, NULL, 0);
#else
		if (!sscanf(env+off, "%lli",(long long *)&vec)) vec = strtoul(env+off, NULL, 0);
#endif
d683 1
d686 3
a688 1
OPENSSL_cpuid_setup(void) {}
d692 2
a693 1
void OPENSSL_showfatal(const char *fmta, ...)
d702 2
a703 1
int OPENSSL_isservice(void)
d717 2
a718 1
void *OPENSSL_stderr(void)
@


1.18
log
@Remove non-posix support. Why is OPENSSL_isservice even here?
Is this a crypto library or a generic platform abstraction library?
"A hack to make Visual C++ 5.0 work correctly" ... time to upgrade.
@
text
@d214 1
a214 1
		OPENSSL_free(str);
d245 1
a245 1
	pointer = (CRYPTO_dynlock *)OPENSSL_malloc(sizeof(CRYPTO_dynlock));
d253 1
a253 1
		OPENSSL_free(pointer);
d276 1
a276 1
		OPENSSL_free(pointer);
d315 1
a315 1
		OPENSSL_free(pointer);
@


1.17
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a203 8
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)
	/* A hack to make Visual C++ 5.0 work correctly when linking as
	 * a DLL using /MT. Without this, the application cannot use
	 * any floating point printf's.
	 * It also seems to be needed for Visual C 1.5 (win16) */
	SSLeay_MSVC5_hack = (double)name[0]*(double)name[1];
#endif

a482 7
#ifdef OPENSSL_SYS_WIN16
	CRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentTask());
#elif defined(OPENSSL_SYS_WIN32)
	CRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentThreadId());
#elif defined(OPENSSL_SYS_BEOS)
	CRYPTO_THREADID_set_numeric(id, (unsigned long)find_thread(NULL));
#else
a484 1
#endif
a522 9
#ifdef OPENSSL_SYS_WIN16
		ret = (unsigned long)GetCurrentTask();
#elif defined(OPENSSL_SYS_WIN32)
		ret = (unsigned long)GetCurrentThreadId();
#elif defined(GETPID_IS_MEANINGLESS)
		ret = 1L;
#elif defined(OPENSSL_SYS_BEOS)
		ret = (unsigned long)find_thread(NULL);
#else
a523 1
#endif
a697 42
#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)
#ifdef __CYGWIN__
/* pick DLL_[PROCESS|THREAD]_[ATTACH|DETACH] definitions */
#include <windows.h>
/* this has side-effect of _WIN32 getting defined, which otherwise
 * is mutually exclusive with __CYGWIN__... */
#endif

/* All we really need to do is remove the 'error' state when a thread
 * detaches */

BOOL WINAPI
DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	switch (fdwReason) {
	case DLL_PROCESS_ATTACH:
		OPENSSL_cpuid_setup();
#if defined(_WIN32_WINNT)
		{
			IMAGE_DOS_HEADER *dos_header = (IMAGE_DOS_HEADER *)hinstDLL;
			IMAGE_NT_HEADERS *nt_headers;

			if (dos_header->e_magic == IMAGE_DOS_SIGNATURE) {
				nt_headers = (IMAGE_NT_HEADERS *)((char *)dos_header
				+ dos_header->e_lfanew);
				if (nt_headers->Signature == IMAGE_NT_SIGNATURE &&
					hinstDLL != (HINSTANCE)(nt_headers->OptionalHeader.ImageBase))
				OPENSSL_NONPIC_relocated = 1;
			}
		}
#endif
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return (TRUE);
}
#endif
a698 154
#if defined(_WIN32) && !defined(__CYGWIN__)
#include <tchar.h>
#include <signal.h>
#ifdef __WATCOMC__
#if defined(_UNICODE) || defined(__UNICODE__)
#define _vsntprintf _vsnwprintf
#else
#define _vsntprintf _vsnprintf
#endif
#endif
#ifdef _MSC_VER
#define alloca _alloca
#endif

#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333
int
OPENSSL_isservice(void)
	{ HWINSTA h;
	DWORD len;
	WCHAR *name;
		static union { void *p;
		int (*f)(void);
	} _OPENSSL_isservice = { NULL };

	if (_OPENSSL_isservice.p == NULL) {
		HANDLE h = GetModuleHandle(NULL);
		if (h != NULL)
			_OPENSSL_isservice.p = GetProcAddress(h, "_OPENSSL_isservice");
		if (_OPENSSL_isservice.p == NULL)
			_OPENSSL_isservice.p = (void *) - 1;
	}

	if (_OPENSSL_isservice.p != (void *) - 1)
		return (*_OPENSSL_isservice.f)();

	(void)GetDesktopWindow(); /* return value is ignored */

	h = GetProcessWindowStation();
	if (h == NULL)
		return -1;

	if (GetUserObjectInformationW (h, UOI_NAME, NULL, 0, &len) ||
		GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	return -1;

	if (len > 512)
		return -1;
	/* paranoia */
	len++, len&=~1;
	/* paranoia */
	name = (WCHAR *)alloca(len + sizeof(WCHAR));
	if (!GetUserObjectInformationW (h, UOI_NAME, name, len, &len))
		return -1;

	len++, len&=~1;
	/* paranoia */
	name[len/sizeof(WCHAR)]=L'\0';	/* paranoia */
#if 1
    /* This doesn't cover "interactive" services [working with real
     * WinSta0's] nor programs started non-interactively by Task
     * Scheduler [those are working with SAWinSta]. */
	if (wcsstr(name, L"Service-0x"))	return 1;
#else
	/* This covers all non-interactive programs such as services. */
	if (!wcsstr(name, L"WinSta0"))	return 1;
#endif
	else				return 0;
}
#else
	int OPENSSL_isservice(void) { return 0;
}
#endif

void OPENSSL_showfatal (const char *fmta,...)
	{ va_list ap;
	TCHAR buf[256];
	const TCHAR *fmt;
#ifdef STD_ERROR_HANDLE	/* what a dirty trick! */
	HANDLE h;

	if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&
		GetFileType(h) != FILE_TYPE_UNKNOWN)
		{	/* must be console application */
		va_start (ap, fmta);
		vfprintf (stderr, fmta, ap);
		va_end (ap);
		return;
	}
#endif

	if (sizeof(TCHAR) == sizeof(char))
		fmt = (const TCHAR *)fmta;
	else do
		{ int    keepgoing;
		size_t len_0 = strlen(fmta) + 1, i;
		WCHAR *fmtw;

		fmtw = (WCHAR *)alloca(len_0*sizeof(WCHAR));
		if (fmtw == NULL) {
			fmt = (const TCHAR *)L"no stack?";
			break;
		}

#ifndef OPENSSL_NO_MULTIBYTE
		if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))
#endif
		for (i = 0;i < len_0;i++) fmtw[i] = (WCHAR)fmta[i];

		for (i = 0; i < len_0; i++)
				{   if (fmtw[i]==L'%') do
				{	keepgoing = 0;
				switch (fmtw[i + 1])
					{   case L'0': case L'1': case L'2': case L'3': case L'4':
				case L'5': case L'6': case L'7': case L'8': case L'9':
				case L'.': case L'*':
				case L'-':
					i++;
					keepgoing = 1;
					break;
				case L's':
					fmtw[i + 1] = L'S';
					break;
				case L'S':
					fmtw[i + 1] = L's';
					break;
				case L'c':
					fmtw[i + 1] = L'C';
					break;
				case L'C':
					fmtw[i + 1] = L'c';
					break;
				}
			} while (keepgoing);
		}
		fmt = (const TCHAR *)fmtw;
	} while (0);

	va_start (ap, fmta);
	_vsntprintf (buf, sizeof(buf)/sizeof(TCHAR) - 1, fmt, ap);
	buf [sizeof(buf)/sizeof(TCHAR) - 1] = _T('\0');
	va_end (ap);

#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333
	/* this -------------v--- guards NT-specific calls */
	if (check_winnt() && OPENSSL_isservice() > 0)
			{	HANDLE h = RegisterEventSource(0, _T("OPENSSL"));
		const TCHAR *pmsg = buf;
		ReportEvent(h, EVENTLOG_ERROR_TYPE, 0, 0, 0, 1, 0, &pmsg, 0);
		DeregisterEventSource(h);
	} else
#endif
	MessageBox (NULL, buf, _T("OpenSSL: FATAL"), MB_OK|MB_ICONSTOP);
}
#else
a711 1
#endif
a718 1
#if !defined(_WIN32) || defined(__CYGWIN__)
a719 5
#else
	/* Win32 abort() customarily shows a dialog, but we just did that... */
	raise(SIGABRT);
	_exit(3);
#endif
@


1.16
log
@Remove some stuff that isn't needed.
ok miod@@ deraadt@@
@
text
@d121 1
a121 1
static double SSLeay_MSVC5_hack=0.0; /* and for VC1.5 */
d127 1
a127 2
static const char* const lock_names[CRYPTO_NUM_LOCKS] =
	{
d172 1
a172 1
	};
d176 1
a176 1
static STACK_OF(OPENSSL_STRING) *app_locks=NULL;
d181 1
a181 2
static STACK_OF(CRYPTO_dynlock) *dyn_locks=NULL;

d183 4
a186 4
static void (*locking_callback)(int mode,int type,
	const char *file,int line)=0;
static int (*add_lock_callback)(int *pointer,int amount,
	int type,const char *file,int line)=0;
d188 1
a188 1
static unsigned long (*id_callback)(void)=0;
d190 3
a192 3
static void (*threadid_callback)(CRYPTO_THREADID *)=0;
static struct CRYPTO_dynlock_value *(*dynlock_create_callback)
	(const char *file,int line)=0;
d194 1
a194 1
	struct CRYPTO_dynlock_value *l, const char *file,int line)=0;
d196 1
a196 1
	const char *file,int line)=0;
d198 3
a200 2
int CRYPTO_get_new_lockid(char *name)
	{
d209 1
a209 1
	SSLeay_MSVC5_hack=(double)name[0]*(double)name[1];
d212 9
a220 11
	if ((app_locks == NULL) && ((app_locks=sk_OPENSSL_STRING_new_null()) == NULL))
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	if ((str=BUF_strdup(name)) == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	i=sk_OPENSSL_STRING_push(app_locks,str);
d224 3
a226 3
		i+=CRYPTO_NUM_LOCKS; /* gap of one :-) */
	return(i);
	}
d228 3
a230 2
int CRYPTO_num_locks(void)
	{
d232 1
a232 1
	}
d234 3
a236 2
int CRYPTO_get_new_dynlockid(void)
	{
d240 4
a243 5
	if (dynlock_create_callback == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK);
		return(0);
		}
d246 1
a246 2
		&& ((dyn_locks=sk_CRYPTO_dynlock_new_null()) == NULL))
		{
d248 3
a250 3
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
d254 4
a257 5
	if (pointer == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
d259 2
a260 3
	pointer->data = dynlock_create_callback(__FILE__,__LINE__);
	if (pointer->data == NULL)
		{
d262 3
a264 3
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
d268 1
a268 1
	i=sk_CRYPTO_dynlock_find(dyn_locks,NULL);
d275 1
a275 1
		i=sk_CRYPTO_dynlock_push(dyn_locks,pointer) - 1;
d279 1
a279 1
		(void)sk_CRYPTO_dynlock_set(dyn_locks,i,pointer);
d282 2
a283 3
	if (i == -1)
		{
		dynlock_destroy_callback(pointer->data,__FILE__,__LINE__);
d285 1
a285 2
		}
	else
d287 2
a288 2
	return -i;
	}
d290 3
a292 2
void CRYPTO_destroy_dynlockid(int i)
	{
d295 1
a295 1
		i = -i-1;
d301 1
a301 2
	if (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))
		{
d304 1
a304 1
		}
d306 1
a306 2
	if (pointer != NULL)
		{
d309 2
a310 3
		if (pointer->references < 0)
			{
			fprintf(stderr,"CRYPTO_destroy_dynlockid, bad reference count\n");
d312 1
a312 2
			}
		else
d314 5
a318 7
			if (pointer->references <= 0)
				{
				(void)sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);
				}
			else
				pointer = NULL;
		}
d321 2
a322 3
	if (pointer)
		{
		dynlock_destroy_callback(pointer->data,__FILE__,__LINE__);
a323 1
		}
d325 1
d327 3
a329 2
struct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)
	{
d332 1
a332 1
		i = -i-1;
d346 1
a346 1
	}
d348 5
a352 5
struct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback(void))
	(const char *file,int line)
	{
	return(dynlock_create_callback);
	}
d355 4
a358 4
	struct CRYPTO_dynlock_value *l, const char *file,int line)
	{
	return(dynlock_lock_callback);
	}
d360 5
a364 5
void (*CRYPTO_get_dynlock_destroy_callback(void))
	(struct CRYPTO_dynlock_value *l, const char *file,int line)
	{
	return(dynlock_destroy_callback);
	}
d366 6
a371 5
void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)
	(const char *file, int line))
	{
	dynlock_create_callback=func;
	}
d373 6
a378 5
void CRYPTO_set_dynlock_lock_callback(void (*func)(int mode,
	struct CRYPTO_dynlock_value *l, const char *file, int line))
	{
	dynlock_lock_callback=func;
	}
d380 6
a385 5
void CRYPTO_set_dynlock_destroy_callback(void (*func)
	(struct CRYPTO_dynlock_value *l, const char *file, int line))
	{
	dynlock_destroy_callback=func;
	}
d387 5
d393 5
a397 11
void (*CRYPTO_get_locking_callback(void))(int mode,int type,const char *file,
		int line)
	{
	return(locking_callback);
	}

int (*CRYPTO_get_add_lock_callback(void))(int *num,int mount,int type,
					  const char *file,int line)
	{
	return(add_lock_callback);
	}
d399 4
a402 3
void CRYPTO_set_locking_callback(void (*func)(int mode,int type,
					      const char *file,int line))
	{
d407 2
a408 2
	locking_callback=func;
	}
d410 6
a415 5
void CRYPTO_set_add_lock_callback(int (*func)(int *num,int mount,int type,
					      const char *file,int line))
	{
	add_lock_callback=func;
	}
d420 3
a422 2
void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val)
	{
d425 1
a425 1
	}
d428 3
a430 2
void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr)
	{
d437 1
a437 2
	if (sizeof(id->val) >= sizeof(id->ptr))
		{
d441 1
a441 1
		}
d452 1
a452 2
	while (dnum--)
		{
d456 1
a456 1
			accum += *(src++) * hash_coeffs[(snum + dnum) & 7];
a458 1
		}
d460 1
d462 3
a464 2
int CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))
	{
d469 1
a469 1
	}
d472 1
a472 1
	{
d474 1
a474 1
	}
d476 4
a479 4
void CRYPTO_THREADID_current(CRYPTO_THREADID *id)
	{
	if (threadid_callback)
		{
d482 1
a482 1
		}
d485 1
a485 2
	if (id_callback)
		{
d488 1
a488 1
		}
d501 1
a501 1
	}
d503 3
a505 2
int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a, const CRYPTO_THREADID *b)
	{
d507 1
a507 1
	}
d509 3
a511 2
void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest, const CRYPTO_THREADID *src)
	{
d513 1
a513 1
	}
d515 3
a517 2
unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)
	{
d519 1
a519 1
	}
d523 3
a525 3
	{
	return(id_callback);
	}
d527 5
a531 4
void CRYPTO_set_id_callback(unsigned long (*func)(void))
	{
	id_callback=func;
	}
d533 4
a536 3
unsigned long CRYPTO_thread_id(void)
	{
	unsigned long ret=0;
d538 1
a538 2
	if (id_callback == NULL)
		{
d540 1
a540 1
		ret=(unsigned long)GetCurrentTask();
d542 1
a542 1
		ret=(unsigned long)GetCurrentThreadId();
d544 1
a544 1
		ret=1L;
d546 1
a546 1
		ret=(unsigned long)find_thread(NULL);
d548 1
a548 1
		ret=(unsigned long)getpid();
d550 4
a553 5
		}
	else
		ret=id_callback();
	return(ret);
	}
d556 4
a559 1
void CRYPTO_lock(int mode, int type, const char *file, int line)
a560 2
#ifdef LOCK_DEBUG
		{
d562 1
a562 1
		char *rw_text,*operation_text;
d579 4
a582 4
		fprintf(stderr,"lock:%08lx:(%s)%s %-18s %s:%d\n",
			CRYPTO_THREADID_hash(&id), rw_text, operation_text,
			CRYPTO_get_lock_name(type), file, line);
		}
d584 4
a587 6
	if (type < 0)
		{
		if (dynlock_lock_callback != NULL)
			{
			struct CRYPTO_dynlock_value *pointer
				= CRYPTO_get_dynlock_value(type);
a593 1
			}
d595 3
a597 4
	else
		if (locking_callback != NULL)
			locking_callback(mode,type,file,line);
	}
d599 4
a602 3
int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,
	     int line)
	{
d605 1
a605 2
	if (add_lock_callback != NULL)
		{
d610 1
a610 1
		ret=add_lock_callback(pointer,amount,type,file,line);
d613 4
a616 4
		CRYPTO_THREADID id;
		CRYPTO_THREADID_current(&id);
		fprintf(stderr,"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\n",
			CRYPTO_THREADID_hash(&id), before,amount,ret,
d618 1
a618 1
			file,line);
d621 2
a622 4
		}
	else
		{
		CRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,file,line);
d624 1
a624 1
		ret= *pointer+amount;
d627 3
a629 3
		CRYPTO_THREADID id;
		CRYPTO_THREADID_current(&id);
		fprintf(stderr,"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\n",
d631 1
a631 1
			*pointer,amount,ret,
d633 1
a633 1
			file,line);
d636 2
a637 4
		*pointer=ret;
		CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,file,line);
		}
	return(ret);
d639 2
d642 3
a644 2
const char *CRYPTO_get_lock_name(int type)
	{
d648 2
a649 2
		return(lock_names[type]);
	else if (type-CRYPTO_NUM_LOCKS > sk_OPENSSL_STRING_num(app_locks))
d652 2
a653 2
		return(sk_OPENSSL_STRING_value(app_locks,type-CRYPTO_NUM_LOCKS));
	}
d660 11
a670 9
unsigned long *OPENSSL_ia32cap_loc(void)
{   if (sizeof(long)==4)
	/*
	 * If 32-bit application pulls address of OPENSSL_ia32cap_P[0]
	 * clear second element to maintain the illusion that vector
	 * is 32-bit.
	 */
	OPENSSL_ia32cap_P[1]=0;
    return (unsigned long *)OPENSSL_ia32cap_P;
d680 14
a693 11
void OPENSSL_cpuid_setup(void)
{ static int trigger=0;
  IA32CAP OPENSSL_ia32_cpuid(void);
  IA32CAP vec;
  char *env;

    if (trigger)	return;

    trigger=1;
    if ((env=getenv("OPENSSL_ia32cap"))) {
	int off = (env[0]=='~')?1:0;
d695 1
a695 1
	if (!sscanf(env+off,"%I64i",&vec)) vec = strtoul(env+off,NULL,0);
d697 1
a697 1
	if (!sscanf(env+off,"%lli",(long long *)&vec)) vec = strtoul(env+off,NULL,0);
d699 4
a702 4
	if (off) vec = OPENSSL_ia32_cpuid()&~vec;
    }
    else
	vec = OPENSSL_ia32_cpuid();
d709 2
a710 2
    OPENSSL_ia32cap_P[0] = (unsigned int)vec|(1<<10);
    OPENSSL_ia32cap_P[1] = (unsigned int)(vec>>32);
d715 2
a716 1
unsigned long *OPENSSL_ia32cap_loc(void) { return NULL; }
d720 2
a721 1
void OPENSSL_cpuid_setup(void) {}
d735 4
a738 5
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason,
	     LPVOID lpvReserved)
	{
	switch(fdwReason)
		{
d743 2
a744 2
		IMAGE_DOS_HEADER *dos_header = (IMAGE_DOS_HEADER *)hinstDLL;
		IMAGE_NT_HEADERS *nt_headers;
d746 6
a751 7
		if (dos_header->e_magic==IMAGE_DOS_SIGNATURE)
			{
			nt_headers = (IMAGE_NT_HEADERS *)((char *)dos_header
						+ dos_header->e_lfanew);
			if (nt_headers->Signature==IMAGE_NT_SIGNATURE &&
			    hinstDLL!=(HINSTANCE)(nt_headers->OptionalHeader.ImageBase))
				OPENSSL_NONPIC_relocated=1;
a761 2
		}
	return(TRUE);
d763 2
d782 25
a806 21
int OPENSSL_isservice(void)
{ HWINSTA h;
  DWORD len;
  WCHAR *name;
  static union { void *p; int (*f)(void); } _OPENSSL_isservice = { NULL };

    if (_OPENSSL_isservice.p == NULL) {
	HANDLE h = GetModuleHandle(NULL);
	if (h != NULL)
	    _OPENSSL_isservice.p = GetProcAddress(h,"_OPENSSL_isservice");
	if (_OPENSSL_isservice.p == NULL)
	    _OPENSSL_isservice.p = (void *)-1;
    }

    if (_OPENSSL_isservice.p != (void *)-1)
	return (*_OPENSSL_isservice.f)();

    (void)GetDesktopWindow(); /* return value is ignored */

    h = GetProcessWindowStation();
    if (h==NULL) return -1;
d808 2
a809 2
    if (GetUserObjectInformationW (h,UOI_NAME,NULL,0,&len) ||
	GetLastError() != ERROR_INSUFFICIENT_BUFFER)
d812 12
a823 8
    if (len>512) return -1;		/* paranoia */
    len++,len&=~1;			/* paranoia */
    name=(WCHAR *)alloca(len+sizeof(WCHAR));
    if (!GetUserObjectInformationW (h,UOI_NAME,name,len,&len))
	return -1;

    len++,len&=~1;			/* paranoia */
    name[len/sizeof(WCHAR)]=L'\0';	/* paranoia */
d828 1
a828 1
    if (wcsstr(name,L"Service-0x"))	return 1;
d830 2
a831 2
    /* This covers all non-interactive programs such as services. */
    if (!wcsstr(name,L"WinSta0"))	return 1;
d833 1
a833 1
    else				return 0;
d836 2
a837 1
int OPENSSL_isservice(void) { return 0; }
d841 3
a843 3
{ va_list ap;
  TCHAR buf[256];
  const TCHAR *fmt;
d845 1
a845 1
  HANDLE h;
d847 8
a854 8
    if ((h=GetStdHandle(STD_ERROR_HANDLE)) != NULL &&
	GetFileType(h)!=FILE_TYPE_UNKNOWN)
    {	/* must be console application */
	va_start (ap,fmta);
	vfprintf (stderr,fmta,ap);
	va_end (ap);
	return;
    }
d857 12
a868 9
    if (sizeof(TCHAR)==sizeof(char))
	fmt=(const TCHAR *)fmta;
    else do
    { int    keepgoing;
      size_t len_0=strlen(fmta)+1,i;
      WCHAR *fmtw;

	fmtw = (WCHAR *)alloca(len_0*sizeof(WCHAR));
	if (fmtw == NULL) { fmt=(const TCHAR *)L"no stack?"; break; }
d871 1
a871 1
	if (!MultiByteToWideChar(CP_ACP,0,fmta,len_0,fmtw,len_0))
d873 1
a873 1
	    for (i=0;i<len_0;i++) fmtw[i]=(WCHAR)fmta[i];
d875 25
a899 12
	for (i=0;i<len_0;i++)
	{   if (fmtw[i]==L'%') do
	    {	keepgoing=0;
		switch (fmtw[i+1])
		{   case L'0': case L'1': case L'2': case L'3': case L'4':
		    case L'5': case L'6': case L'7': case L'8': case L'9':
		    case L'.': case L'*':
		    case L'-':	i++; keepgoing=1; break;
		    case L's':	fmtw[i+1]=L'S';   break;
		    case L'S':	fmtw[i+1]=L's';   break;
		    case L'c':	fmtw[i+1]=L'C';   break;
		    case L'C':	fmtw[i+1]=L'c';   break;
d901 2
a902 4
	    } while (keepgoing);
	}
	fmt = (const TCHAR *)fmtw;
    } while (0);
d904 4
a907 4
    va_start (ap,fmta);
    _vsntprintf (buf,sizeof(buf)/sizeof(TCHAR)-1,fmt,ap);
    buf [sizeof(buf)/sizeof(TCHAR)-1] = _T('\0');
    va_end (ap);
d910 7
a916 8
    /* this -------------v--- guards NT-specific calls */
    if (check_winnt() && OPENSSL_isservice() > 0)
    {	HANDLE h = RegisterEventSource(0,_T("OPENSSL"));
	const TCHAR *pmsg=buf;
	ReportEvent(h,EVENTLOG_ERROR_TYPE,0,0,0,1,0,&pmsg,0);
	DeregisterEventSource(h);
    }
    else
d918 1
a918 1
	MessageBox (NULL,buf,_T("OpenSSL: FATAL"),MB_OK|MB_ICONSTOP);
d921 8
a928 2
void OPENSSL_showfatal (const char *fmta,...)
{ va_list ap;
d930 3
a932 3
    va_start (ap,fmta);
    vfprintf (stderr,fmta,ap);
    va_end (ap);
a933 1
int OPENSSL_isservice (void) { return 0; }
d936 3
a938 2
void OpenSSLDie(const char *file,int line,const char *assertion)
	{
d940 2
a941 2
		"%s(%d): OpenSSL internal error, assertion failed: %s\n",
		file,line,assertion);
d949 1
a949 1
	}
d951 4
a954 1
void *OPENSSL_stderr(void)	{ return stderr; }
d956 3
a958 2
int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len)
	{
d968 1
a968 1
	}
@


1.15
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d185 1
a185 1
static void (MS_FAR *locking_callback)(int mode,int type,
d187 1
a187 1
static int (MS_FAR *add_lock_callback)(int *pointer,int amount,
d190 1
a190 1
static unsigned long (MS_FAR *id_callback)(void)=0;
d192 2
a193 2
static void (MS_FAR *threadid_callback)(CRYPTO_THREADID *)=0;
static struct CRYPTO_dynlock_value *(MS_FAR *dynlock_create_callback)
d195 1
a195 1
static void (MS_FAR *dynlock_lock_callback)(int mode,
d197 1
a197 1
static void (MS_FAR *dynlock_destroy_callback)(struct CRYPTO_dynlock_value *l,
@


1.14
log
@resolve conflicts
@
text
@d507 1
a507 1
	CRYPTO_THREADID_set_pointer(id, &errno);
d707 1
d892 1
a892 1
    if (GetVersion() < 0x80000000 && OPENSSL_isservice() > 0)
d928 13
@


1.13
log
@openssl-1.0.0e: resolve conflicts
@
text
@d412 4
d668 11
a678 2
unsigned long  OPENSSL_ia32cap_P=0;
unsigned long *OPENSSL_ia32cap_loc(void) { return &OPENSSL_ia32cap_P; }
d682 5
d689 2
a690 1
  unsigned long OPENSSL_ia32_cpuid(void);
d696 9
a704 2
    if ((env=getenv("OPENSSL_ia32cap")))
	OPENSSL_ia32cap_P = strtoul(env,NULL,0)|(1<<10);
d706 1
a706 1
	OPENSSL_ia32cap_P = OPENSSL_ia32_cpuid()|(1<<10);
d712 2
@


1.12
log
@resolve conflicts, fix local changes
@
text
@a733 1
		ERR_remove_state(0);
d745 10
a784 3
#ifdef _MSC_VER
    name=(WCHAR *)_alloca(len+sizeof(WCHAR));
#else
a785 1
#endif
d830 1
a830 5
#ifdef _MSC_VER
	fmtw = (WCHAR *)_alloca (len_0*sizeof(WCHAR));
#else
	fmtw = (WCHAR *)alloca (len_0*sizeof(WCHAR));
#endif
@


1.11
log
@resolve conflicts
@
text
@d3 1
a3 1
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
d124 61
d186 1
a186 1
	const char *file,int line)=NULL;
d188 42
a229 2
	int type,const char *file,int line)=NULL;
static unsigned long (MS_FAR *id_callback)(void)=NULL;
d236 161
d421 102
d545 2
d555 1
a555 8

static void (*do_dynlock_cb)(int mode, int type, const char *file, int line);

void int_CRYPTO_set_do_dynlock_callback(
	void (*dyn_cb)(int mode, int type, const char *file, int line))
	{
	do_dynlock_cb = dyn_cb;
	}
d561 1
d578 1
d580 1
a580 1
			CRYPTO_thread_id(), rw_text, operation_text,
d586 11
a596 2
		if (do_dynlock_cb)
			do_dynlock_cb(mode, type, file, line);
d616 3
d620 1
a620 2
			CRYPTO_thread_id(),
			before,amount,ret,
d623 1
d632 3
d636 1
a636 1
			CRYPTO_thread_id(),
d640 1
d648 12
d693 1
a693 1
#if !defined(OPENSSL_CPUID_SETUP)
a697 56

#ifdef OPENSSL_FIPS

#include <tlhelp32.h>
#if defined(__GNUC__) && __GNUC__>=2
static int DllInit(void) __attribute__((constructor));
#elif defined(_MSC_VER)
static int DllInit(void);
# ifdef _WIN64
# pragma section(".CRT$XCU",read)
  __declspec(allocate(".CRT$XCU"))
# else
# pragma data_seg(".CRT$XCU")
# endif
  static int (*p)(void) = DllInit;
# pragma data_seg()
#endif

static int DllInit(void)
{
#if defined(_WIN32_WINNT)
	union	{ int(*f)(void); BYTE *p; } t = { DllInit };
        HANDLE	hModuleSnap = INVALID_HANDLE_VALUE;
	IMAGE_DOS_HEADER *dos_header;
	IMAGE_NT_HEADERS *nt_headers;
	MODULEENTRY32 me32 = {sizeof(me32)};

	hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,0);
	if (hModuleSnap != INVALID_HANDLE_VALUE &&
	    Module32First(hModuleSnap,&me32)) do
		{
		if (t.p >= me32.modBaseAddr &&
		    t.p <  me32.modBaseAddr+me32.modBaseSize)
			{
			dos_header=(IMAGE_DOS_HEADER *)me32.modBaseAddr;
			if (dos_header->e_magic==IMAGE_DOS_SIGNATURE)
				{
				nt_headers=(IMAGE_NT_HEADERS *)
					((BYTE *)dos_header+dos_header->e_lfanew);
				if (nt_headers->Signature==IMAGE_NT_SIGNATURE &&
				    me32.modBaseAddr!=(BYTE*)nt_headers->OptionalHeader.ImageBase)
					OPENSSL_NONPIC_relocated=1;
				}
			break;
			}
		} while (Module32Next(hModuleSnap,&me32));

	if (hModuleSnap != INVALID_HANDLE_VALUE)
		CloseHandle(hModuleSnap);
#endif
	OPENSSL_cpuid_setup();
	return 0;
}

#else

d701 2
a742 2
#endif

d745 1
d752 12
d862 1
a862 1
    if (GetVersion() < 0x80000000 && OPENSSL_isservice())
d888 1
d890 5
@


1.10
log
@resolve conflicts
@
text
@a123 60
DECLARE_STACK_OF(CRYPTO_dynlock)
IMPLEMENT_STACK_OF(CRYPTO_dynlock)

/* real #defines in crypto.h, keep these upto date */
static const char* const lock_names[CRYPTO_NUM_LOCKS] =
	{
	"<<ERROR>>",
	"err",
	"ex_data",
	"x509",
	"x509_info",
	"x509_pkey",
	"x509_crl",
	"x509_req",
	"dsa",
	"rsa",
	"evp_pkey",
	"x509_store",
	"ssl_ctx",
	"ssl_cert",
	"ssl_session",
	"ssl_sess_cert",
	"ssl",
	"ssl_method",
	"rand",
	"rand2",
	"debug_malloc",
	"BIO",
	"gethostbyname",
	"getservbyname",
	"readdir",
	"RSA_blinding",
	"dh",
	"debug_malloc2",
	"dso",
	"dynlock",
	"engine",
	"ui",
	"ecdsa",
	"ec",
	"ecdh",
	"bn",
	"ec_pre_comp",
	"store",
	"comp",
#if CRYPTO_NUM_LOCKS != 39
# error "Inconsistency between crypto.h and cryptlib.c"
#endif
	};

/* This is for applications to allocate new type names in the non-dynamic
   array of lock names.  These are numbered with positive numbers.  */
static STACK *app_locks=NULL;

/* For applications that want a more dynamic way of handling threads, the
   following stack is used.  These are externally numbered with negative
   numbers.  */
static STACK_OF(CRYPTO_dynlock) *dyn_locks=NULL;


a128 37
static struct CRYPTO_dynlock_value *(MS_FAR *dynlock_create_callback)
	(const char *file,int line)=NULL;
static void (MS_FAR *dynlock_lock_callback)(int mode,
	struct CRYPTO_dynlock_value *l, const char *file,int line)=NULL;
static void (MS_FAR *dynlock_destroy_callback)(struct CRYPTO_dynlock_value *l,
	const char *file,int line)=NULL;

int CRYPTO_get_new_lockid(char *name)
	{
	char *str;
	int i;

#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)
	/* A hack to make Visual C++ 5.0 work correctly when linking as
	 * a DLL using /MT. Without this, the application cannot use
	 * and floating point printf's.
	 * It also seems to be needed for Visual C 1.5 (win16) */
	SSLeay_MSVC5_hack=(double)name[0]*(double)name[1];
#endif

	if ((app_locks == NULL) && ((app_locks=sk_new_null()) == NULL))
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	if ((str=BUF_strdup(name)) == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	i=sk_push(app_locks,str);
	if (!i)
		OPENSSL_free(str);
	else
		i+=CRYPTO_NUM_LOCKS; /* gap of one :-) */
	return(i);
	}
a134 161
int CRYPTO_get_new_dynlockid(void)
	{
	int i = 0;
	CRYPTO_dynlock *pointer = NULL;

	if (dynlock_create_callback == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK);
		return(0);
		}
	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);
	if ((dyn_locks == NULL)
		&& ((dyn_locks=sk_CRYPTO_dynlock_new_null()) == NULL))
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	pointer = (CRYPTO_dynlock *)OPENSSL_malloc(sizeof(CRYPTO_dynlock));
	if (pointer == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	pointer->references = 1;
	pointer->data = dynlock_create_callback(__FILE__,__LINE__);
	if (pointer->data == NULL)
		{
		OPENSSL_free(pointer);
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);
	/* First, try to find an existing empty slot */
	i=sk_CRYPTO_dynlock_find(dyn_locks,NULL);
	/* If there was none, push, thereby creating a new one */
	if (i == -1)
		/* Since sk_push() returns the number of items on the
		   stack, not the location of the pushed item, we need
		   to transform the returned number into a position,
		   by decreasing it.  */
		i=sk_CRYPTO_dynlock_push(dyn_locks,pointer) - 1;
	else
		/* If we found a place with a NULL pointer, put our pointer
		   in it.  */
		(void)sk_CRYPTO_dynlock_set(dyn_locks,i,pointer);
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (i == -1)
		{
		dynlock_destroy_callback(pointer->data,__FILE__,__LINE__);
		OPENSSL_free(pointer);
		}
	else
		i += 1; /* to avoid 0 */
	return -i;
	}

void CRYPTO_destroy_dynlockid(int i)
	{
	CRYPTO_dynlock *pointer = NULL;
	if (i)
		i = -i-1;
	if (dynlock_destroy_callback == NULL)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);

	if (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);
		return;
		}
	pointer = sk_CRYPTO_dynlock_value(dyn_locks, i);
	if (pointer != NULL)
		{
		--pointer->references;
#ifdef REF_CHECK
		if (pointer->references < 0)
			{
			fprintf(stderr,"CRYPTO_destroy_dynlockid, bad reference count\n");
			abort();
			}
		else
#endif
			if (pointer->references <= 0)
				{
				(void)sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);
				}
			else
				pointer = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (pointer)
		{
		dynlock_destroy_callback(pointer->data,__FILE__,__LINE__);
		OPENSSL_free(pointer);
		}
	}

struct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)
	{
	CRYPTO_dynlock *pointer = NULL;
	if (i)
		i = -i-1;

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);

	if (dyn_locks != NULL && i < sk_CRYPTO_dynlock_num(dyn_locks))
		pointer = sk_CRYPTO_dynlock_value(dyn_locks, i);
	if (pointer)
		pointer->references++;

	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (pointer)
		return pointer->data;
	return NULL;
	}

struct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback(void))
	(const char *file,int line)
	{
	return(dynlock_create_callback);
	}

void (*CRYPTO_get_dynlock_lock_callback(void))(int mode,
	struct CRYPTO_dynlock_value *l, const char *file,int line)
	{
	return(dynlock_lock_callback);
	}

void (*CRYPTO_get_dynlock_destroy_callback(void))
	(struct CRYPTO_dynlock_value *l, const char *file,int line)
	{
	return(dynlock_destroy_callback);
	}

void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)
	(const char *file, int line))
	{
	dynlock_create_callback=func;
	}

void CRYPTO_set_dynlock_lock_callback(void (*func)(int mode,
	struct CRYPTO_dynlock_value *l, const char *file, int line))
	{
	dynlock_lock_callback=func;
	}

void CRYPTO_set_dynlock_destroy_callback(void (*func)
	(struct CRYPTO_dynlock_value *l, const char *file, int line))
	{
	dynlock_destroy_callback=func;
	}


d190 8
d225 2
a226 11
		if (dynlock_lock_callback != NULL)
			{
			struct CRYPTO_dynlock_value *pointer
				= CRYPTO_get_dynlock_value(type);

			OPENSSL_assert(pointer != NULL);

			dynlock_lock_callback(mode, pointer, file, line);

			CRYPTO_destroy_dynlockid(type);
			}
a270 12
const char *CRYPTO_get_lock_name(int type)
	{
	if (type < 0)
		return("dynamic");
	else if (type < CRYPTO_NUM_LOCKS)
		return(lock_names[type]);
	else if (type-CRYPTO_NUM_LOCKS > sk_num(app_locks))
		return("ERROR");
	else
		return(sk_value(app_locks,type-CRYPTO_NUM_LOCKS));
	}

d273 1
a273 1
	defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64)
d309 56
d406 2
@


1.9
log
@resolve conflicts
@
text
@d2 53
d111 5
a116 2
#include <stdio.h>
#include <string.h>
a117 1
#include <openssl/crypto.h>
d128 1
a128 1
static const char* lock_names[CRYPTO_NUM_LOCKS] =
d162 8
a169 4
	"hwcrhk",		/* This is a HACK which will disappear in 0.9.8 */
	"fips",
	"fips2",
#if CRYPTO_NUM_LOCKS != 35
d280 1
a280 1
		sk_CRYPTO_dynlock_set(dyn_locks,i,pointer);
d322 1
a322 1
				sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);
d542 36
a577 1
int OPENSSL_NONPIC_relocated=0;
d579 5
a583 1
#if defined(_WIN32) && defined(_WINDLL)
d594 1
d623 1
a623 1
#if defined(_WIN32)
d627 1
a627 1
static int IsService(void)
d664 2
d672 1
d683 1
d729 1
a729 1
    if (GetVersion() < 0x80000000 && IsService())
d737 1
a737 15
    {	MSGBOXPARAMS         m;

	m.cbSize             = sizeof(m);
	m.hwndOwner          = NULL;
	m.lpszCaption        = _T("OpenSSL: FATAL");
	m.dwStyle            = MB_OK;
	m.hInstance          = NULL;
	m.lpszIcon           = IDI_ERROR;
	m.dwContextHelpId    = 0;
	m.lpfnMsgBoxCallback = NULL;
	m.dwLanguageId       = MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US);
	m.lpszText           = buf;

	MessageBoxIndirect (&m);
    }
d747 1
a758 76

#ifdef OPENSSL_FIPS

void fips_w_lock(void)		{ CRYPTO_w_lock(CRYPTO_LOCK_FIPS); }
void fips_w_unlock(void)	{ CRYPTO_w_unlock(CRYPTO_LOCK_FIPS); }
void fips_r_lock(void)		{ CRYPTO_r_lock(CRYPTO_LOCK_FIPS); }
void fips_r_unlock(void)	{ CRYPTO_r_unlock(CRYPTO_LOCK_FIPS); }

static int fips_started = 0;
static unsigned long fips_thread = 0;

void fips_set_started(void)
	{
	fips_started = 1;
	}

int fips_is_started(void)
	{
	return fips_started;
	}

int fips_is_owning_thread(void)
	{
	int ret = 0;

	if (fips_is_started())
		{
		CRYPTO_r_lock(CRYPTO_LOCK_FIPS2);
		if (fips_thread != 0 && fips_thread == CRYPTO_thread_id())
			ret = 1;
		CRYPTO_r_unlock(CRYPTO_LOCK_FIPS2);
		}
	return ret;
	}

int fips_set_owning_thread(void)
	{
	int ret = 0;

	if (fips_is_started())
		{
		CRYPTO_w_lock(CRYPTO_LOCK_FIPS2);
		if (fips_thread == 0)
			{
			fips_thread = CRYPTO_thread_id();
			ret = 1;
			}
		CRYPTO_w_unlock(CRYPTO_LOCK_FIPS2);
		}
	return ret;
	}

int fips_clear_owning_thread(void)
	{
	int ret = 0;

	if (fips_is_started())
		{
		CRYPTO_w_lock(CRYPTO_LOCK_FIPS2);
		if (fips_thread == CRYPTO_thread_id())
			{
			fips_thread = 0;
			ret = 1;
			}
		CRYPTO_w_unlock(CRYPTO_LOCK_FIPS2);
		}
	return ret;
	}

unsigned char *fips_signature_witness(void)
	{
	extern unsigned char FIPS_signature[];
	return FIPS_signature;
	}
#endif /* OPENSSL_FIPS */

@


1.8
log
@resolve conflicts
@
text
@d483 2
d496 15
d524 136
d662 1
a662 1
	fprintf(stderr,
d668 2
d671 6
a677 2
static int fips_mode = 0;
static void *fips_rand_check = 0;
d738 1
a738 39
void fips_set_mode(int onoff)
	{
	int owning_thread = fips_is_owning_thread();

	if (fips_is_started())
		{
		if (!owning_thread) CRYPTO_w_lock(CRYPTO_LOCK_FIPS);
		fips_mode = onoff;
		if (!owning_thread) CRYPTO_w_unlock(CRYPTO_LOCK_FIPS);
		}
	}

void fips_set_rand_check(void *rand_check)
	{
	int owning_thread = fips_is_owning_thread();

	if (fips_is_started())
		{
		if (!owning_thread) CRYPTO_w_lock(CRYPTO_LOCK_FIPS);
		fips_rand_check = rand_check;
		if (!owning_thread) CRYPTO_w_unlock(CRYPTO_LOCK_FIPS);
		}
	}

int FIPS_mode(void)
	{
	int ret = 0;
	int owning_thread = fips_is_owning_thread();

	if (fips_is_started())
		{
		if (!owning_thread) CRYPTO_r_lock(CRYPTO_LOCK_FIPS);
		ret = fips_mode;
		if (!owning_thread) CRYPTO_r_unlock(CRYPTO_LOCK_FIPS);
		}
	return ret;
	}

void *FIPS_rand_check(void)
d740 2
a741 10
	void *ret = 0;
	int owning_thread = fips_is_owning_thread();

	if (fips_is_started())
		{
		if (!owning_thread) CRYPTO_r_lock(CRYPTO_LOCK_FIPS);
		ret = fips_rand_check;
		if (!owning_thread) CRYPTO_r_unlock(CRYPTO_LOCK_FIPS);
		}
	return ret;
a742 1

@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d108 3
a110 1
#if CRYPTO_NUM_LOCKS != 33
d483 1
a483 2
#ifdef _DLL
#ifdef OPENSSL_SYS_WIN32
d488 1
a488 1
BOOL WINAPI DLLEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason,
a506 2
#endif

d514 119
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d92 1
d107 2
a108 1
#if CRYPTO_NUM_LOCKS != 31
d211 9
a219 1
		i=sk_CRYPTO_dynlock_push(dyn_locks,pointer);
d222 1
a222 1
	if (!i)
d414 6
a419 2
		struct CRYPTO_dynlock_value *pointer
			= CRYPTO_get_dynlock_value(type);
a420 2
		if (pointer && dynlock_lock_callback)
			{
d422 2
a424 2

		CRYPTO_destroy_dynlockid(type);
d475 1
a475 1
	else if (type-CRYPTO_NUM_LOCKS >= sk_num(app_locks))
d507 8
@


1.5
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d65 1
a65 1
#if defined(WIN32) || defined(WIN16)
d77 1
a77 1
	"err_hash",
d93 1
d105 2
a106 1
#if CRYPTO_NUM_LOCKS != 29
d138 1
a142 1
#if defined(WIN32) || defined(WIN16)
d233 2
d236 1
d362 1
a362 1
#ifdef WIN16
d364 1
a364 1
#elif defined(WIN32)
d470 1
a470 1
#ifdef WIN32
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d244 1
a244 1
			if (--(pointer->references) <= 0)
a398 1
		int i = -type - 1;
d400 1
a400 1
			= CRYPTO_get_dynlock_value(i);
d402 1
a402 1
		if (pointer)
d407 1
a407 1
		CRYPTO_destroy_dynlockid(i);
a432 1
		*pointer=ret;
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d63 1
d69 3
d101 4
a104 1
#if CRYPTO_NUM_LOCKS != 26
d109 2
d113 6
d124 7
d150 2
d153 1
d156 1
a156 1
		Free(str);
d167 150
d397 16
a412 2
	if (locking_callback != NULL)
		locking_callback(mode,type,file,line);
d418 1
a418 1
	int ret;
d457 1
a457 1
		return("ERROR");
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d95 3
a97 1
#if CRYPTO_NUM_LOCKS != 24
d186 1
a186 1
#elif defined(MSDOS)
@


1.1
log
@Initial revision
@
text
@d62 1
a62 2
#include "crypto.h"
#include "date.h"
d69 1
a69 1
static char* lock_names[CRYPTO_NUM_LOCKS] =
d86 1
d91 3
a93 1
	"bio_gethostbyname",
d95 3
a101 1
#ifndef NOPROTO
d103 1
a103 1
	char *file,int line)=NULL;
d105 1
a105 1
	int type,char *file,int line)=NULL;
d107 1
a107 8
#else
static void (MS_FAR *locking_callback)()=NULL;
static int (MS_FAR *add_lock_callback)()=NULL;
static unsigned long (MS_FAR *id_callback)()=NULL;
#endif

int CRYPTO_get_new_lockid(name)
char *name;
d120 5
a124 4
	if (app_locks == NULL)
		if ((app_locks=sk_new_null()) == NULL)
			CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);
			return(0);
d135 7
a141 1
void (*CRYPTO_get_locking_callback(P_V))(P_I_I_P_I)
d146 2
a147 1
int (*CRYPTO_get_add_lock_callback(P_V))(P_IP_I_I_P_I)
d152 2
a153 2
void CRYPTO_set_locking_callback(func)
void (*func)(P_I_I_P_I);
d158 2
a159 2
void CRYPTO_set_add_lock_callback(func)
int (*func)(P_IP_I_I_P_I);
d164 1
a164 1
unsigned long (*CRYPTO_get_id_callback(P_V))(P_V)
d169 1
a169 2
void CRYPTO_set_id_callback(func)
unsigned long (*func)(P_V);
d174 1
a174 1
unsigned long CRYPTO_thread_id()
d195 1
a195 5
void CRYPTO_lock(mode,type,file,line)
int mode;
int type;
char *file;
int line;
d224 2
a225 6
int CRYPTO_add_lock(pointer,amount,type,file,line)
int *pointer;
int amount;
int type;
char *file;
int line;
d263 1
a263 2
char *CRYPTO_get_lock_name(type)
int type;
d281 2
a282 4
BOOL WINAPI DLLEntryPoint(hinstDLL,fdwReason,lpvReserved)
HINSTANCE hinstDLL;
DWORD fdwReason;
LPVOID lpvReserved;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d62 2
a63 2
#include <openssl/crypto.h>
#include <openssl/safestack.h>
d65 1
a65 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)
a68 3
DECLARE_STACK_OF(CRYPTO_dynlock)
IMPLEMENT_STACK_OF(CRYPTO_dynlock)

d70 1
a70 1
static const char* lock_names[CRYPTO_NUM_LOCKS] =
d74 1
a74 1
	"ex_data",
a86 1
	"ssl_sess_cert",
a88 1
	"rand2",
d91 1
a91 3
	"gethostbyname",
	"getservbyname",
	"readdir",
a92 9
	"dh",
	"debug_malloc2",
	"dso",
	"dynlock",
	"engine",
	"ui",
#if CRYPTO_NUM_LOCKS != 31
# error "Inconsistency between crypto.h and cryptlib.c"
#endif
a94 2
/* This is for applications to allocate new type names in the non-dynamic
   array of lock names.  These are numbered with positive numbers.  */
d97 1
a97 6
/* For applications that want a more dynamic way of handling threads, the
   following stack is used.  These are externally numbered with negative
   numbers.  */
static STACK_OF(CRYPTO_dynlock) *dyn_locks=NULL;


d99 1
a99 1
	const char *file,int line)=NULL;
d101 1
a101 1
	int type,const char *file,int line)=NULL;
d103 5
a107 6
static struct CRYPTO_dynlock_value *(MS_FAR *dynlock_create_callback)
	(const char *file,int line)=NULL;
static void (MS_FAR *dynlock_lock_callback)(int mode,
	struct CRYPTO_dynlock_value *l, const char *file,int line)=NULL;
static void (MS_FAR *dynlock_destroy_callback)(struct CRYPTO_dynlock_value *l,
	const char *file,int line)=NULL;
d109 2
a110 1
int CRYPTO_get_new_lockid(char *name)
a114 1
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)
d119 1
d123 4
a126 5
	if ((app_locks == NULL) && ((app_locks=sk_new_null()) == NULL))
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
a127 2
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);
a128 1
		}
d131 1
a131 1
		OPENSSL_free(str);
d137 1
a137 160
int CRYPTO_num_locks(void)
	{
	return CRYPTO_NUM_LOCKS;
	}

int CRYPTO_get_new_dynlockid(void)
	{
	int i = 0;
	CRYPTO_dynlock *pointer = NULL;

	if (dynlock_create_callback == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK);
		return(0);
		}
	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);
	if ((dyn_locks == NULL)
		&& ((dyn_locks=sk_CRYPTO_dynlock_new_null()) == NULL))
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	pointer = (CRYPTO_dynlock *)OPENSSL_malloc(sizeof(CRYPTO_dynlock));
	if (pointer == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	pointer->references = 1;
	pointer->data = dynlock_create_callback(__FILE__,__LINE__);
	if (pointer->data == NULL)
		{
		OPENSSL_free(pointer);
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);
	/* First, try to find an existing empty slot */
	i=sk_CRYPTO_dynlock_find(dyn_locks,NULL);
	/* If there was none, push, thereby creating a new one */
	if (i == -1)
		i=sk_CRYPTO_dynlock_push(dyn_locks,pointer);
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (!i)
		{
		dynlock_destroy_callback(pointer->data,__FILE__,__LINE__);
		OPENSSL_free(pointer);
		}
	else
		i += 1; /* to avoid 0 */
	return -i;
	}

void CRYPTO_destroy_dynlockid(int i)
	{
	CRYPTO_dynlock *pointer = NULL;
	if (i)
		i = -i-1;
	if (dynlock_destroy_callback == NULL)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);

	if (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);
		return;
		}
	pointer = sk_CRYPTO_dynlock_value(dyn_locks, i);
	if (pointer != NULL)
		{
		--pointer->references;
#ifdef REF_CHECK
		if (pointer->references < 0)
			{
			fprintf(stderr,"CRYPTO_destroy_dynlockid, bad reference count\n");
			abort();
			}
		else
#endif
			if (pointer->references <= 0)
				{
				sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);
				}
			else
				pointer = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (pointer)
		{
		dynlock_destroy_callback(pointer->data,__FILE__,__LINE__);
		OPENSSL_free(pointer);
		}
	}

struct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)
	{
	CRYPTO_dynlock *pointer = NULL;
	if (i)
		i = -i-1;

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);

	if (dyn_locks != NULL && i < sk_CRYPTO_dynlock_num(dyn_locks))
		pointer = sk_CRYPTO_dynlock_value(dyn_locks, i);
	if (pointer)
		pointer->references++;

	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (pointer)
		return pointer->data;
	return NULL;
	}

struct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback(void))
	(const char *file,int line)
	{
	return(dynlock_create_callback);
	}

void (*CRYPTO_get_dynlock_lock_callback(void))(int mode,
	struct CRYPTO_dynlock_value *l, const char *file,int line)
	{
	return(dynlock_lock_callback);
	}

void (*CRYPTO_get_dynlock_destroy_callback(void))
	(struct CRYPTO_dynlock_value *l, const char *file,int line)
	{
	return(dynlock_destroy_callback);
	}

void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)
	(const char *file, int line))
	{
	dynlock_create_callback=func;
	}

void CRYPTO_set_dynlock_lock_callback(void (*func)(int mode,
	struct CRYPTO_dynlock_value *l, const char *file, int line))
	{
	dynlock_lock_callback=func;
	}

void CRYPTO_set_dynlock_destroy_callback(void (*func)
	(struct CRYPTO_dynlock_value *l, const char *file, int line))
	{
	dynlock_destroy_callback=func;
	}


void (*CRYPTO_get_locking_callback(void))(int mode,int type,const char *file,
		int line)
d142 1
a142 2
int (*CRYPTO_get_add_lock_callback(void))(int *num,int mount,int type,
					  const char *file,int line)
d147 2
a148 2
void CRYPTO_set_locking_callback(void (*func)(int mode,int type,
					      const char *file,int line))
d153 2
a154 2
void CRYPTO_set_add_lock_callback(int (*func)(int *num,int mount,int type,
					      const char *file,int line))
d159 1
a159 1
unsigned long (*CRYPTO_get_id_callback(void))(void)
d164 2
a165 1
void CRYPTO_set_id_callback(unsigned long (*func)(void))
d170 1
a170 1
unsigned long CRYPTO_thread_id(void)
d176 1
a176 1
#ifdef OPENSSL_SYS_WIN16
d178 1
a178 1
#elif defined(OPENSSL_SYS_WIN32)
d180 1
a180 1
#elif defined(GETPID_IS_MEANINGLESS)
d191 5
a195 1
void CRYPTO_lock(int mode, int type, const char *file, int line)
d220 2
a221 15
	if (type < 0)
		{
		struct CRYPTO_dynlock_value *pointer
			= CRYPTO_get_dynlock_value(type);

		if (pointer && dynlock_lock_callback)
			{
			dynlock_lock_callback(mode, pointer, file, line);
			}

		CRYPTO_destroy_dynlockid(type);
		}
	else
		if (locking_callback != NULL)
			locking_callback(mode,type,file,line);
d224 6
a229 2
int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,
	     int line)
d231 1
a231 1
	int ret = 0;
d247 1
d267 2
a268 1
const char *CRYPTO_get_lock_name(int type)
d271 1
a271 1
		return("dynamic");
d281 1
a281 1
#ifdef OPENSSL_SYS_WIN32
d286 4
a289 2
BOOL WINAPI DLLEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason,
	     LPVOID lpvReserved)
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a494 8

void OpenSSLDie(const char *file,int line,const char *assertion)
    {
    fprintf(stderr,"%s(%d): OpenSSL internal error, assertion failed: %s\n",
	    file,line,assertion);
    abort();
    }

@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d495 8
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@a91 1
	"ssl_method",
d106 1
a106 2
	"hwcrhk",		/* This is a HACK which will disappear in 0.9.8 */
#if CRYPTO_NUM_LOCKS != 33
d209 1
a209 9
		/* Since sk_push() returns the number of items on the
		   stack, not the location of the pushed item, we need
		   to transform the returned number into a position,
		   by decreasing it.  */
		i=sk_CRYPTO_dynlock_push(dyn_locks,pointer) - 1;
	else
		/* If we found a place with a NULL pointer, put our pointer
		   in it.  */
		sk_CRYPTO_dynlock_set(dyn_locks,i,pointer);
d212 1
a212 1
	if (i == -1)
d404 4
a407 1
		if (dynlock_lock_callback != NULL)
a408 5
			struct CRYPTO_dynlock_value *pointer
				= CRYPTO_get_dynlock_value(type);

			OPENSSL_assert(pointer != NULL);

d410 1
d412 1
a412 2
			CRYPTO_destroy_dynlockid(type);
			}
d463 1
a463 1
	else if (type-CRYPTO_NUM_LOCKS > sk_num(app_locks))
a494 8

void OpenSSLDie(const char *file,int line,const char *assertion)
	{
	fprintf(stderr,
		"%s(%d): OpenSSL internal error, assertion failed: %s\n",
		file,line,assertion);
	abort();
	}
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d108 1
a108 3
	"fips",
	"fips2",
#if CRYPTO_NUM_LOCKS != 35
d481 2
a482 1
#if defined(_WIN32) && defined(_WINDLL)
d487 1
a487 1
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason,
d506 2
a514 119

#ifdef OPENSSL_FIPS
static int fips_started = 0;
static int fips_mode = 0;
static void *fips_rand_check = 0;
static unsigned long fips_thread = 0;

void fips_set_started(void)
	{
	fips_started = 1;
	}

int fips_is_started(void)
	{
	return fips_started;
	}

int fips_is_owning_thread(void)
	{
	int ret = 0;

	if (fips_is_started())
		{
		CRYPTO_r_lock(CRYPTO_LOCK_FIPS2);
		if (fips_thread != 0 && fips_thread == CRYPTO_thread_id())
			ret = 1;
		CRYPTO_r_unlock(CRYPTO_LOCK_FIPS2);
		}
	return ret;
	}

int fips_set_owning_thread(void)
	{
	int ret = 0;

	if (fips_is_started())
		{
		CRYPTO_w_lock(CRYPTO_LOCK_FIPS2);
		if (fips_thread == 0)
			{
			fips_thread = CRYPTO_thread_id();
			ret = 1;
			}
		CRYPTO_w_unlock(CRYPTO_LOCK_FIPS2);
		}
	return ret;
	}

int fips_clear_owning_thread(void)
	{
	int ret = 0;

	if (fips_is_started())
		{
		CRYPTO_w_lock(CRYPTO_LOCK_FIPS2);
		if (fips_thread == CRYPTO_thread_id())
			{
			fips_thread = 0;
			ret = 1;
			}
		CRYPTO_w_unlock(CRYPTO_LOCK_FIPS2);
		}
	return ret;
	}

void fips_set_mode(int onoff)
	{
	int owning_thread = fips_is_owning_thread();

	if (fips_is_started())
		{
		if (!owning_thread) CRYPTO_w_lock(CRYPTO_LOCK_FIPS);
		fips_mode = onoff;
		if (!owning_thread) CRYPTO_w_unlock(CRYPTO_LOCK_FIPS);
		}
	}

void fips_set_rand_check(void *rand_check)
	{
	int owning_thread = fips_is_owning_thread();

	if (fips_is_started())
		{
		if (!owning_thread) CRYPTO_w_lock(CRYPTO_LOCK_FIPS);
		fips_rand_check = rand_check;
		if (!owning_thread) CRYPTO_w_unlock(CRYPTO_LOCK_FIPS);
		}
	}

int FIPS_mode(void)
	{
	int ret = 0;
	int owning_thread = fips_is_owning_thread();

	if (fips_is_started())
		{
		if (!owning_thread) CRYPTO_r_lock(CRYPTO_LOCK_FIPS);
		ret = fips_mode;
		if (!owning_thread) CRYPTO_r_unlock(CRYPTO_LOCK_FIPS);
		}
	return ret;
	}

void *FIPS_rand_check(void)
	{
	void *ret = 0;
	int owning_thread = fips_is_owning_thread();

	if (fips_is_started())
		{
		if (!owning_thread) CRYPTO_r_lock(CRYPTO_LOCK_FIPS);
		ret = fips_rand_check;
		if (!owning_thread) CRYPTO_r_unlock(CRYPTO_LOCK_FIPS);
		}
	return ret;
	}

#endif /* OPENSSL_FIPS */

@


1.1.1.7
log
@import of openssl-0.9.7j
@
text
@a482 2
int OPENSSL_NONPIC_relocated=0;

a493 15
#if defined(_WIN32_WINNT)
		{
		IMAGE_DOS_HEADER *dos_header = (IMAGE_DOS_HEADER *)hinstDLL;
		IMAGE_NT_HEADERS *nt_headers;

		if (dos_header->e_magic==IMAGE_DOS_SIGNATURE)
			{
			nt_headers = (IMAGE_NT_HEADERS *)((char *)dos_header
						+ dos_header->e_lfanew);
			if (nt_headers->Signature==IMAGE_NT_SIGNATURE &&
			    hinstDLL!=(HINSTANCE)(nt_headers->OptionalHeader.ImageBase))
				OPENSSL_NONPIC_relocated=1;
			}
		}
#endif
a506 136
#if defined(_WIN32)
#include <tchar.h>

#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333
static int IsService(void)
{ HWINSTA h;
  DWORD len;
  WCHAR *name;

    (void)GetDesktopWindow(); /* return value is ignored */

    h = GetProcessWindowStation();
    if (h==NULL) return -1;

    if (GetUserObjectInformationW (h,UOI_NAME,NULL,0,&len) ||
	GetLastError() != ERROR_INSUFFICIENT_BUFFER)
	return -1;

    if (len>512) return -1;		/* paranoia */
    len++,len&=~1;			/* paranoia */
#ifdef _MSC_VER
    name=(WCHAR *)_alloca(len+sizeof(WCHAR));
#else
    name=(WCHAR *)alloca(len+sizeof(WCHAR));
#endif
    if (!GetUserObjectInformationW (h,UOI_NAME,name,len,&len))
	return -1;

    len++,len&=~1;			/* paranoia */
    name[len/sizeof(WCHAR)]=L'\0';	/* paranoia */
#if 1
    /* This doesn't cover "interactive" services [working with real
     * WinSta0's] nor programs started non-interactively by Task
     * Scheduler [those are working with SAWinSta]. */
    if (wcsstr(name,L"Service-0x"))	return 1;
#else
    /* This covers all non-interactive programs such as services. */
    if (!wcsstr(name,L"WinSta0"))	return 1;
#endif
    else				return 0;
}
#endif

void OPENSSL_showfatal (const char *fmta,...)
{ va_list ap;
  TCHAR buf[256];
  const TCHAR *fmt;
  HANDLE h;

    if ((h=GetStdHandle(STD_ERROR_HANDLE)) != NULL &&
	GetFileType(h)!=FILE_TYPE_UNKNOWN)
    {	/* must be console application */
	va_start (ap,fmta);
	vfprintf (stderr,fmta,ap);
	va_end (ap);
	return;
    }

    if (sizeof(TCHAR)==sizeof(char))
	fmt=(const TCHAR *)fmta;
    else do
    { int    keepgoing;
      size_t len_0=strlen(fmta)+1,i;
      WCHAR *fmtw;

#ifdef _MSC_VER
	fmtw = (WCHAR *)_alloca (len_0*sizeof(WCHAR));
#else
	fmtw = (WCHAR *)alloca (len_0*sizeof(WCHAR));
#endif
	if (fmtw == NULL) { fmt=(const TCHAR *)L"no stack?"; break; }

#ifndef OPENSSL_NO_MULTIBYTE
	if (!MultiByteToWideChar(CP_ACP,0,fmta,len_0,fmtw,len_0))
#endif
	    for (i=0;i<len_0;i++) fmtw[i]=(WCHAR)fmta[i];

	for (i=0;i<len_0;i++)
	{   if (fmtw[i]==L'%') do
	    {	keepgoing=0;
		switch (fmtw[i+1])
		{   case L'0': case L'1': case L'2': case L'3': case L'4':
		    case L'5': case L'6': case L'7': case L'8': case L'9':
		    case L'.': case L'*':
		    case L'-':	i++; keepgoing=1; break;
		    case L's':	fmtw[i+1]=L'S';   break;
		    case L'S':	fmtw[i+1]=L's';   break;
		    case L'c':	fmtw[i+1]=L'C';   break;
		    case L'C':	fmtw[i+1]=L'c';   break;
		}
	    } while (keepgoing);
	}
	fmt = (const TCHAR *)fmtw;
    } while (0);

    va_start (ap,fmta);
    _vsntprintf (buf,sizeof(buf)/sizeof(TCHAR)-1,fmt,ap);
    buf [sizeof(buf)/sizeof(TCHAR)-1] = _T('\0');
    va_end (ap);

#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333
    /* this -------------v--- guards NT-specific calls */
    if (GetVersion() < 0x80000000 && IsService())
    {	HANDLE h = RegisterEventSource(0,_T("OPENSSL"));
	const TCHAR *pmsg=buf;
	ReportEvent(h,EVENTLOG_ERROR_TYPE,0,0,0,1,0,&pmsg,0);
	DeregisterEventSource(h);
    }
    else
#endif
    {	MSGBOXPARAMS         m;

	m.cbSize             = sizeof(m);
	m.hwndOwner          = NULL;
	m.lpszCaption        = _T("OpenSSL: FATAL");
	m.dwStyle            = MB_OK;
	m.hInstance          = NULL;
	m.lpszIcon           = IDI_ERROR;
	m.dwContextHelpId    = 0;
	m.lpfnMsgBoxCallback = NULL;
	m.dwLanguageId       = MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US);
	m.lpszText           = buf;

	MessageBoxIndirect (&m);
    }
}
#else
void OPENSSL_showfatal (const char *fmta,...)
{ va_list ap;

    va_start (ap,fmta);
    vfprintf (stderr,fmta,ap);
    va_end (ap);
}
#endif

d509 1
a509 1
	OPENSSL_showfatal(
a514 2
void *OPENSSL_stderr(void)	{ return stderr; }

a515 6

void fips_w_lock(void)		{ CRYPTO_w_lock(CRYPTO_LOCK_FIPS); }
void fips_w_unlock(void)	{ CRYPTO_w_unlock(CRYPTO_LOCK_FIPS); }
void fips_r_lock(void)		{ CRYPTO_r_lock(CRYPTO_LOCK_FIPS); }
void fips_r_unlock(void)	{ CRYPTO_r_unlock(CRYPTO_LOCK_FIPS); }

d517 2
d579 39
a617 1
unsigned char *fips_signature_witness(void)
d619 10
a628 2
	extern unsigned char FIPS_signature[];
	return FIPS_signature;
d630 1
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@a1 53
/* ====================================================================
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
a57 5
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECDH support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */
d59 2
d62 1
d73 1
a73 1
static const char* const lock_names[CRYPTO_NUM_LOCKS] =
d107 4
a110 8
	"ecdsa",
	"ec",
	"ecdh",
	"bn",
	"ec_pre_comp",
	"store",
	"comp",
#if CRYPTO_NUM_LOCKS != 39
d221 1
a221 1
		(void)sk_CRYPTO_dynlock_set(dyn_locks,i,pointer);
d263 1
a263 1
				(void)sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);
d483 1
a483 36
#if	defined(__i386)   || defined(__i386__)   || defined(_M_IX86) || \
	defined(__INTEL__) || \
	defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64)

unsigned long  OPENSSL_ia32cap_P=0;
unsigned long *OPENSSL_ia32cap_loc(void) { return &OPENSSL_ia32cap_P; }

#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM) && !defined(I386_ONLY)
#define OPENSSL_CPUID_SETUP
void OPENSSL_cpuid_setup(void)
{ static int trigger=0;
  unsigned long OPENSSL_ia32_cpuid(void);
  char *env;

    if (trigger)	return;

    trigger=1;
    if ((env=getenv("OPENSSL_ia32cap")))
	OPENSSL_ia32cap_P = strtoul(env,NULL,0)|(1<<10);
    else
	OPENSSL_ia32cap_P = OPENSSL_ia32_cpuid()|(1<<10);
    /*
     * |(1<<10) sets a reserved bit to signal that variable
     * was initialized already... This is to avoid interference
     * with cpuid snippets in ELF .init segment.
     */
}
#endif

#else
unsigned long *OPENSSL_ia32cap_loc(void) { return NULL; }
#endif
int OPENSSL_NONPIC_relocated = 0;
#if !defined(OPENSSL_CPUID_SETUP)
void OPENSSL_cpuid_setup(void) {}
#endif
d485 1
a485 5
#if (defined(_WIN32) || defined(__CYGWIN__)) && defined(_WINDLL)
#ifdef __CYGWIN__
/* pick DLL_[PROCESS|THREAD]_[ATTACH|DETACH] definitions */
#include <windows.h>
#endif
a495 1
		OPENSSL_cpuid_setup();
d524 1
a524 1
#if defined(_WIN32) && !defined(__CYGWIN__)
d528 1
a528 1
int OPENSSL_isservice(void)
a564 2
#else
int OPENSSL_isservice(void) { return 0; }
a570 1
#ifdef STD_ERROR_HANDLE	/* what a dirty trick! */
a580 1
#endif
d626 1
a626 1
    if (GetVersion() < 0x80000000 && OPENSSL_isservice())
d634 15
a648 1
	MessageBox (NULL,buf,_T("OpenSSL: FATAL"),MB_OK|MB_ICONSTOP);
a657 1
int OPENSSL_isservice (void) { return 0; }
d669 76
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@d124 60
d189 37
d232 161
a447 8
static void (*do_dynlock_cb)(int mode, int type, const char *file, int line);

void int_CRYPTO_set_do_dynlock_callback(
	void (*dyn_cb)(int mode, int type, const char *file, int line))
	{
	do_dynlock_cb = dyn_cb;
	}

d475 11
a485 2
		if (do_dynlock_cb)
			do_dynlock_cb(mode, type, file, line);
d530 12
d544 1
a544 1
	defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)
a579 56

#ifdef OPENSSL_FIPS

#include <tlhelp32.h>
#if defined(__GNUC__) && __GNUC__>=2
static int DllInit(void) __attribute__((constructor));
#elif defined(_MSC_VER)
static int DllInit(void);
# ifdef _WIN64
# pragma section(".CRT$XCU",read)
  __declspec(allocate(".CRT$XCU"))
# else
# pragma data_seg(".CRT$XCU")
# endif
  static int (*p)(void) = DllInit;
# pragma data_seg()
#endif

static int DllInit(void)
{
#if defined(_WIN32_WINNT)
	union	{ int(*f)(void); BYTE *p; } t = { DllInit };
        HANDLE	hModuleSnap = INVALID_HANDLE_VALUE;
	IMAGE_DOS_HEADER *dos_header;
	IMAGE_NT_HEADERS *nt_headers;
	MODULEENTRY32 me32 = {sizeof(me32)};

	hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,0);
	if (hModuleSnap != INVALID_HANDLE_VALUE &&
	    Module32First(hModuleSnap,&me32)) do
		{
		if (t.p >= me32.modBaseAddr &&
		    t.p <  me32.modBaseAddr+me32.modBaseSize)
			{
			dos_header=(IMAGE_DOS_HEADER *)me32.modBaseAddr;
			if (dos_header->e_magic==IMAGE_DOS_SIGNATURE)
				{
				nt_headers=(IMAGE_NT_HEADERS *)
					((BYTE *)dos_header+dos_header->e_lfanew);
				if (nt_headers->Signature==IMAGE_NT_SIGNATURE &&
				    me32.modBaseAddr!=(BYTE*)nt_headers->OptionalHeader.ImageBase)
					OPENSSL_NONPIC_relocated=1;
				}
			break;
			}
		} while (Module32Next(hModuleSnap,&me32));

	if (hModuleSnap != INVALID_HANDLE_VALUE)
		CloseHandle(hModuleSnap);
#endif
	OPENSSL_cpuid_setup();
	return 0;
}

#else

a620 2
#endif

@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@d3 1
a3 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
a123 61
DECLARE_STACK_OF(CRYPTO_dynlock)

/* real #defines in crypto.h, keep these upto date */
static const char* const lock_names[CRYPTO_NUM_LOCKS] =
	{
	"<<ERROR>>",
	"err",
	"ex_data",
	"x509",
	"x509_info",
	"x509_pkey",
	"x509_crl",
	"x509_req",
	"dsa",
	"rsa",
	"evp_pkey",
	"x509_store",
	"ssl_ctx",
	"ssl_cert",
	"ssl_session",
	"ssl_sess_cert",
	"ssl",
	"ssl_method",
	"rand",
	"rand2",
	"debug_malloc",
	"BIO",
	"gethostbyname",
	"getservbyname",
	"readdir",
	"RSA_blinding",
	"dh",
	"debug_malloc2",
	"dso",
	"dynlock",
	"engine",
	"ui",
	"ecdsa",
	"ec",
	"ecdh",
	"bn",
	"ec_pre_comp",
	"store",
	"comp",
	"fips",
	"fips2",
#if CRYPTO_NUM_LOCKS != 41
# error "Inconsistency between crypto.h and cryptlib.c"
#endif
	};

/* This is for applications to allocate new type names in the non-dynamic
   array of lock names.  These are numbered with positive numbers.  */
static STACK_OF(OPENSSL_STRING) *app_locks=NULL;

/* For applications that want a more dynamic way of handling threads, the
   following stack is used.  These are externally numbered with negative
   numbers.  */
static STACK_OF(CRYPTO_dynlock) *dyn_locks=NULL;


d125 1
a125 1
	const char *file,int line)=0;
d127 2
a128 42
	int type,const char *file,int line)=0;
#ifndef OPENSSL_NO_DEPRECATED
static unsigned long (MS_FAR *id_callback)(void)=0;
#endif
static void (MS_FAR *threadid_callback)(CRYPTO_THREADID *)=0;
static struct CRYPTO_dynlock_value *(MS_FAR *dynlock_create_callback)
	(const char *file,int line)=0;
static void (MS_FAR *dynlock_lock_callback)(int mode,
	struct CRYPTO_dynlock_value *l, const char *file,int line)=0;
static void (MS_FAR *dynlock_destroy_callback)(struct CRYPTO_dynlock_value *l,
	const char *file,int line)=0;

int CRYPTO_get_new_lockid(char *name)
	{
	char *str;
	int i;

#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)
	/* A hack to make Visual C++ 5.0 work correctly when linking as
	 * a DLL using /MT. Without this, the application cannot use
	 * any floating point printf's.
	 * It also seems to be needed for Visual C 1.5 (win16) */
	SSLeay_MSVC5_hack=(double)name[0]*(double)name[1];
#endif

	if ((app_locks == NULL) && ((app_locks=sk_OPENSSL_STRING_new_null()) == NULL))
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	if ((str=BUF_strdup(name)) == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	i=sk_OPENSSL_STRING_push(app_locks,str);
	if (!i)
		OPENSSL_free(str);
	else
		i+=CRYPTO_NUM_LOCKS; /* gap of one :-) */
	return(i);
	}
a134 161
int CRYPTO_get_new_dynlockid(void)
	{
	int i = 0;
	CRYPTO_dynlock *pointer = NULL;

	if (dynlock_create_callback == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK);
		return(0);
		}
	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);
	if ((dyn_locks == NULL)
		&& ((dyn_locks=sk_CRYPTO_dynlock_new_null()) == NULL))
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	pointer = (CRYPTO_dynlock *)OPENSSL_malloc(sizeof(CRYPTO_dynlock));
	if (pointer == NULL)
		{
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	pointer->references = 1;
	pointer->data = dynlock_create_callback(__FILE__,__LINE__);
	if (pointer->data == NULL)
		{
		OPENSSL_free(pointer);
		CRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);
		return(0);
		}

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);
	/* First, try to find an existing empty slot */
	i=sk_CRYPTO_dynlock_find(dyn_locks,NULL);
	/* If there was none, push, thereby creating a new one */
	if (i == -1)
		/* Since sk_push() returns the number of items on the
		   stack, not the location of the pushed item, we need
		   to transform the returned number into a position,
		   by decreasing it.  */
		i=sk_CRYPTO_dynlock_push(dyn_locks,pointer) - 1;
	else
		/* If we found a place with a NULL pointer, put our pointer
		   in it.  */
		(void)sk_CRYPTO_dynlock_set(dyn_locks,i,pointer);
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (i == -1)
		{
		dynlock_destroy_callback(pointer->data,__FILE__,__LINE__);
		OPENSSL_free(pointer);
		}
	else
		i += 1; /* to avoid 0 */
	return -i;
	}

void CRYPTO_destroy_dynlockid(int i)
	{
	CRYPTO_dynlock *pointer = NULL;
	if (i)
		i = -i-1;
	if (dynlock_destroy_callback == NULL)
		return;

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);

	if (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);
		return;
		}
	pointer = sk_CRYPTO_dynlock_value(dyn_locks, i);
	if (pointer != NULL)
		{
		--pointer->references;
#ifdef REF_CHECK
		if (pointer->references < 0)
			{
			fprintf(stderr,"CRYPTO_destroy_dynlockid, bad reference count\n");
			abort();
			}
		else
#endif
			if (pointer->references <= 0)
				{
				(void)sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);
				}
			else
				pointer = NULL;
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (pointer)
		{
		dynlock_destroy_callback(pointer->data,__FILE__,__LINE__);
		OPENSSL_free(pointer);
		}
	}

struct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)
	{
	CRYPTO_dynlock *pointer = NULL;
	if (i)
		i = -i-1;

	CRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);

	if (dyn_locks != NULL && i < sk_CRYPTO_dynlock_num(dyn_locks))
		pointer = sk_CRYPTO_dynlock_value(dyn_locks, i);
	if (pointer)
		pointer->references++;

	CRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);

	if (pointer)
		return pointer->data;
	return NULL;
	}

struct CRYPTO_dynlock_value *(*CRYPTO_get_dynlock_create_callback(void))
	(const char *file,int line)
	{
	return(dynlock_create_callback);
	}

void (*CRYPTO_get_dynlock_lock_callback(void))(int mode,
	struct CRYPTO_dynlock_value *l, const char *file,int line)
	{
	return(dynlock_lock_callback);
	}

void (*CRYPTO_get_dynlock_destroy_callback(void))
	(struct CRYPTO_dynlock_value *l, const char *file,int line)
	{
	return(dynlock_destroy_callback);
	}

void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *(*func)
	(const char *file, int line))
	{
	dynlock_create_callback=func;
	}

void CRYPTO_set_dynlock_lock_callback(void (*func)(int mode,
	struct CRYPTO_dynlock_value *l, const char *file, int line))
	{
	dynlock_lock_callback=func;
	}

void CRYPTO_set_dynlock_destroy_callback(void (*func)
	(struct CRYPTO_dynlock_value *l, const char *file, int line))
	{
	dynlock_destroy_callback=func;
	}


a158 102
/* the memset() here and in set_pointer() seem overkill, but for the sake of
 * CRYPTO_THREADID_cmp() this avoids any platform silliness that might cause two
 * "equal" THREADID structs to not be memcmp()-identical. */
void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val)
	{
	memset(id, 0, sizeof(*id));
	id->val = val;
	}

static const unsigned char hash_coeffs[] = { 3, 5, 7, 11, 13, 17, 19, 23 };
void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr)
	{
	unsigned char *dest = (void *)&id->val;
	unsigned int accum = 0;
	unsigned char dnum = sizeof(id->val);

	memset(id, 0, sizeof(*id));
	id->ptr = ptr;
	if (sizeof(id->val) >= sizeof(id->ptr))
		{
		/* 'ptr' can be embedded in 'val' without loss of uniqueness */
		id->val = (unsigned long)id->ptr;
		return;
		}
	/* hash ptr ==> val. Each byte of 'val' gets the mod-256 total of a
	 * linear function over the bytes in 'ptr', the co-efficients of which
	 * are a sequence of low-primes (hash_coeffs is an 8-element cycle) -
	 * the starting prime for the sequence varies for each byte of 'val'
	 * (unique polynomials unless pointers are >64-bit). For added spice,
	 * the totals accumulate rather than restarting from zero, and the index
	 * of the 'val' byte is added each time (position dependence). If I was
	 * a black-belt, I'd scan big-endian pointers in reverse to give
	 * low-order bits more play, but this isn't crypto and I'd prefer nobody
	 * mistake it as such. Plus I'm lazy. */
	while (dnum--)
		{
		const unsigned char *src = (void *)&id->ptr;
		unsigned char snum = sizeof(id->ptr);
		while (snum--)
			accum += *(src++) * hash_coeffs[(snum + dnum) & 7];
		accum += dnum;
		*(dest++) = accum & 255;
		}
	}

int CRYPTO_THREADID_set_callback(void (*func)(CRYPTO_THREADID *))
	{
	if (threadid_callback)
		return 0;
	threadid_callback = func;
	return 1;
	}

void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *)
	{
	return threadid_callback;
	}

void CRYPTO_THREADID_current(CRYPTO_THREADID *id)
	{
	if (threadid_callback)
		{
		threadid_callback(id);
		return;
		}
#ifndef OPENSSL_NO_DEPRECATED
	/* If the deprecated callback was set, fall back to that */
	if (id_callback)
		{
		CRYPTO_THREADID_set_numeric(id, id_callback());
		return;
		}
#endif
	/* Else pick a backup */
#ifdef OPENSSL_SYS_WIN16
	CRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentTask());
#elif defined(OPENSSL_SYS_WIN32)
	CRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentThreadId());
#elif defined(OPENSSL_SYS_BEOS)
	CRYPTO_THREADID_set_numeric(id, (unsigned long)find_thread(NULL));
#else
	/* For everything else, default to using the address of 'errno' */
	CRYPTO_THREADID_set_pointer(id, &errno);
#endif
	}

int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a, const CRYPTO_THREADID *b)
	{
	return memcmp(a, b, sizeof(*a));
	}

void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest, const CRYPTO_THREADID *src)
	{
	memcpy(dest, src, sizeof(*src));
	}

unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)
	{
	return id->val;
	}

#ifndef OPENSSL_NO_DEPRECATED
a180 2
#elif defined(OPENSSL_SYS_BEOS)
		ret=(unsigned long)find_thread(NULL);
d189 8
a196 1
#endif
a201 1
		CRYPTO_THREADID id;
a217 1
		CRYPTO_THREADID_current(&id);
d219 1
a219 1
			CRYPTO_THREADID_hash(&id), rw_text, operation_text,
d225 2
a226 11
		if (dynlock_lock_callback != NULL)
			{
			struct CRYPTO_dynlock_value *pointer
				= CRYPTO_get_dynlock_value(type);

			OPENSSL_assert(pointer != NULL);

			dynlock_lock_callback(mode, pointer, file, line);

			CRYPTO_destroy_dynlockid(type);
			}
a245 3
		{
		CRYPTO_THREADID id;
		CRYPTO_THREADID_current(&id);
d247 2
a248 1
			CRYPTO_THREADID_hash(&id), before,amount,ret,
a250 1
		}
a258 3
		{
		CRYPTO_THREADID id;
		CRYPTO_THREADID_current(&id);
d260 1
a260 1
			CRYPTO_THREADID_hash(&id),
a263 1
		}
a270 12
const char *CRYPTO_get_lock_name(int type)
	{
	if (type < 0)
		return("dynamic");
	else if (type < CRYPTO_NUM_LOCKS)
		return(lock_names[type]);
	else if (type-CRYPTO_NUM_LOCKS > sk_OPENSSL_STRING_num(app_locks))
		return("ERROR");
	else
		return(sk_OPENSSL_STRING_value(app_locks,type-CRYPTO_NUM_LOCKS));
	}

d304 1
a304 1
#if !defined(OPENSSL_CPUID_SETUP) && !defined(OPENSSL_CPUID_OBJ)
d309 56
a367 2
/* this has side-effect of _WIN32 getting defined, which otherwise
 * is mutually exclusive with __CYGWIN__... */
d408 2
a411 1
#include <signal.h>
a417 12
  static union { void *p; int (*f)(void); } _OPENSSL_isservice = { NULL };

    if (_OPENSSL_isservice.p == NULL) {
	HANDLE h = GetModuleHandle(NULL);
	if (h != NULL)
	    _OPENSSL_isservice.p = GetProcAddress(h,"_OPENSSL_isservice");
	if (_OPENSSL_isservice.p == NULL)
	    _OPENSSL_isservice.p = (void *)-1;
    }

    if (_OPENSSL_isservice.p != (void *)-1)
	return (*_OPENSSL_isservice.f)();
d516 1
a516 1
    if (GetVersion() < 0x80000000 && OPENSSL_isservice() > 0)
a541 1
#if !defined(_WIN32) || defined(__CYGWIN__)
a542 5
#else
	/* Win32 abort() customarily shows a dialog, but we just did that... */
	raise(SIGABRT);
	_exit(3);
#endif
@


1.1.1.11
log
@import OpenSSL 1.0.0e
@
text
@d734 1
a745 10
#ifdef __WATCOMC__
#if defined(_UNICODE) || defined(__UNICODE__)
#define _vsntprintf _vsnwprintf
#else
#define _vsntprintf _vsnprintf
#endif
#endif
#ifdef _MSC_VER
#define alloca _alloca
#endif
d776 3
d780 1
d825 5
a829 1
	fmtw = (WCHAR *)alloca(len_0*sizeof(WCHAR));
@


1.1.1.12
log
@import OpenSSL-1.0.1c
@
text
@a411 4
	/* Calling this here ensures initialisation before any threads
	 * are started.
	 */
	OPENSSL_init();
d664 2
a665 11
unsigned int  OPENSSL_ia32cap_P[2];
unsigned long *OPENSSL_ia32cap_loc(void)
{   if (sizeof(long)==4)
	/*
	 * If 32-bit application pulls address of OPENSSL_ia32cap_P[0]
	 * clear second element to maintain the illusion that vector
	 * is 32-bit.
	 */
	OPENSSL_ia32cap_P[1]=0;
    return (unsigned long *)OPENSSL_ia32cap_P;
}
a668 5
#if defined(_WIN32)
typedef unsigned __int64 IA32CAP;
#else
typedef unsigned long long IA32CAP;
#endif
d671 1
a671 2
  IA32CAP OPENSSL_ia32_cpuid(void);
  IA32CAP vec;
d677 2
a678 9
    if ((env=getenv("OPENSSL_ia32cap"))) {
	int off = (env[0]=='~')?1:0;
#if defined(_WIN32)
	if (!sscanf(env+off,"%I64i",&vec)) vec = strtoul(env+off,NULL,0);
#else
	if (!sscanf(env+off,"%lli",(long long *)&vec)) vec = strtoul(env+off,NULL,0);
#endif
	if (off) vec = OPENSSL_ia32_cpuid()&~vec;
    }
d680 1
a680 1
	vec = OPENSSL_ia32_cpuid();
a685 2
    OPENSSL_ia32cap_P[0] = (unsigned int)vec|(1<<10);
    OPENSSL_ia32cap_P[1] = (unsigned int)(vec>>32);
@


1.1.1.13
log
@Import OpenSSL 1.0.1g
@
text
@d507 1
a507 1
	CRYPTO_THREADID_set_pointer(id, (void*)&errno);
a706 1

d891 1
a891 1
    if (check_winnt() && OPENSSL_isservice() > 0)
a926 13

int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len)
	{
	size_t i;
	const unsigned char *a = in_a;
	const unsigned char *b = in_b;
	unsigned char x = 0;

	for (i = 0; i < len; i++)
		x |= a[i] ^ b[i];

	return x;
	}
@


