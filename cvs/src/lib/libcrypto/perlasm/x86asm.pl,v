head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14;
locks; strict;
comment	@# @;


1.14
date	2016.11.04.17.30.30;	author miod;	state Exp;
branches;
next	1.13;
commitid	uVQFi30uotTYOUA9;

1.13
date	2014.06.02.15.08.38;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	tWDKJg0nrCJLQhsu;

1.12
date	2014.04.17.20.17.45;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.29.05.39.24;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.18.12.39.05;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.10.16.31.55;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.41;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.29;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.43;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.40.25;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.35.37;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.13;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.34;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.42;	author djm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Replace all uses of magic numbers when operating on OPENSSL_ia32_P[] by
meaningful constants in a private header file, so that reviewers can actually
get a chance to figure out what the code is attempting to do without knowing
all cpuid bits.

While there, turn it from an array of two 32-bit ints into a properly aligned
64-bit int.

Use of OPENSSL_ia32_P is now restricted to the assembler parts. C code will
now always use OPENSSL_cpu_caps() and check for the proper bits in the
whole 64-bit word it returns.

i386 tests and ok jsing@@
@
text
@#!/usr/bin/env perl

# require 'x86asm.pl';
# &asm_init(<flavor>,"des-586.pl"[,$i386only]);
# &function_begin("foo");
# ...
# &function_end("foo");
# &asm_finish

$out=();
$i386=0;

# AUTOLOAD is this context has quite unpleasant side effect, namely
# that typos in function calls effectively go to assembler output,
# but on the pros side we don't have to implement one subroutine per
# each opcode...
sub ::AUTOLOAD
{ my $opcode = $AUTOLOAD;

    die "more than 4 arguments passed to $opcode" if ($#_>3);

    $opcode =~ s/.*:://;
    if    ($opcode =~ /^push/) { $stack+=4; }
    elsif ($opcode =~ /^pop/)  { $stack-=4; }

    &generic($opcode,@@_) or die "undefined subroutine \&$AUTOLOAD";
}

sub ::emit
{ my $opcode=shift;

    if ($#_==-1)    { push(@@out,"\t$opcode\n");				}
    else            { push(@@out,"\t$opcode\t".join(',',@@_)."\n");	}
}

sub ::emitraw
{ my $opcode=shift;

    if ($#_==-1)    { push(@@out,"$opcode\n");				}
    else            { push(@@out,"$opcode\t".join(',',@@_)."\n");	}
}

sub ::LB
{   $_[0] =~ m/^e?([a-d])x$/o or die "$_[0] does not have a 'low byte'";
  $1."l";
}
sub ::HB
{   $_[0] =~ m/^e?([a-d])x$/o or die "$_[0] does not have a 'high byte'";
  $1."h";
}
sub ::stack_push{ my $num=$_[0]*4; $stack+=$num; &sub("esp",$num);	}
sub ::stack_pop	{ my $num=$_[0]*4; $stack-=$num; &add("esp",$num);	}
sub ::blindpop	{ &pop($_[0]); $stack+=4;				}
sub ::wparam	{ &DWP($stack+4*$_[0],"esp");				}
sub ::swtmp	{ &DWP(4*$_[0],"esp");					}

sub ::bswap
{   if ($i386)	# emulate bswap for i386
    {	&comment("bswap @@_");
	&xchg(&HB(@@_),&LB(@@_));
	&ror (@@_,16);
	&xchg(&HB(@@_),&LB(@@_));
    }
    else
    {	&generic("bswap",@@_);	}
}
# These are made-up opcodes introduced over the years essentially
# by ignorance, just alias them to real ones...
sub ::movb	{ &mov(@@_);	}
sub ::xorb	{ &xor(@@_);	}
sub ::rotl	{ &rol(@@_);	}
sub ::rotr	{ &ror(@@_);	}
sub ::exch	{ &xchg(@@_);	}
sub ::halt	{ &hlt;		}
sub ::movz	{ &movzx(@@_);	}
sub ::pushf	{ &pushfd;	}
sub ::popf	{ &popfd;	}

# 3 argument instructions
sub ::movq
{ my($p1,$p2,$optimize)=@@_;

    if ($optimize && $p1=~/^mm[0-7]$/ && $p2=~/^mm[0-7]$/)
    # movq between mmx registers can sink Intel CPUs
    {	&::pshufw($p1,$p2,0xe4);		}
    else
    {	&::generic("movq",@@_);			}
}

# SSE>2 instructions
my %regrm = (	"eax"=>0, "ecx"=>1, "edx"=>2, "ebx"=>3,
		"esp"=>4, "ebp"=>5, "esi"=>6, "edi"=>7	);
sub ::pextrd
{ my($dst,$src,$imm)=@@_;
    if ("$dst:$src" =~ /(e[a-dsd][ixp]):xmm([0-7])/)
    {	&::data_byte(0x66,0x0f,0x3a,0x16,0xc0|($2<<3)|$regrm{$1},$imm);	}
    else
    {	&::generic("pextrd",@@_);		}
}

sub ::pinsrd
{ my($dst,$src,$imm)=@@_;
    if ("$dst:$src" =~ /xmm([0-7]):(e[a-dsd][ixp])/)
    {	&::data_byte(0x66,0x0f,0x3a,0x22,0xc0|($1<<3)|$regrm{$2},$imm);	}
    else
    {	&::generic("pinsrd",@@_);		}
}

sub ::pshufb
{ my($dst,$src)=@@_;
    if ("$dst:$src" =~ /xmm([0-7]):xmm([0-7])/)
    {	&data_byte(0x66,0x0f,0x38,0x00,0xc0|($1<<3)|$2);	}
    else
    {	&::generic("pshufb",@@_);		}
}

sub ::palignr
{ my($dst,$src,$imm)=@@_;
    if ("$dst:$src" =~ /xmm([0-7]):xmm([0-7])/)
    {	&::data_byte(0x66,0x0f,0x3a,0x0f,0xc0|($1<<3)|$2,$imm);	}
    else
    {	&::generic("palignr",@@_);		}
}

sub ::pclmulqdq
{ my($dst,$src,$imm)=@@_;
    if ("$dst:$src" =~ /xmm([0-7]):xmm([0-7])/)
    {	&::data_byte(0x66,0x0f,0x3a,0x44,0xc0|($1<<3)|$2,$imm);	}
    else
    {	&::generic("pclmulqdq",@@_);		}
}

# label management
$lbdecor="L";		# local label decoration, set by package
$label="000";

sub ::islabel		# see is argument is a known label
{ my $i;
    foreach $i (values %label) { return $i if ($i eq $_[0]); }
  $label{$_[0]};	# can be undef
}

sub ::label		# instantiate a function-scope label
{   if (!defined($label{$_[0]}))
    {	$label{$_[0]}="${lbdecor}${label}${_[0]}"; $label++;   }
  $label{$_[0]};
}

sub ::LABEL		# instantiate a file-scope label
{   $label{$_[0]}=$_[1] if (!defined($label{$_[0]}));
  $label{$_[0]};
}

sub ::static_label	{ &::LABEL($_[0],$lbdecor.$_[0]); }

sub ::set_label_B	{ push(@@out,"@@_:\n"); }
sub ::set_label
{ my $label=&::label($_[0]);
    &::align($_[1]) if ($_[1]>1);
    &::set_label_B($label);
  $label;
}

sub ::wipe_labels	# wipes function-scope labels
{   foreach $i (keys %label)
    {	delete $label{$i} if ($label{$i} =~ /^\Q${lbdecor}\E[0-9]{3}/);	}
}

# subroutine management
sub ::function_begin
{   &function_begin_B(@@_);
    $stack=4;
    &push("ebp");
    &push("ebx");
    &push("esi");
    &push("edi");
}

sub ::function_end
{   &pop("edi");
    &pop("esi");
    &pop("ebx");
    &pop("ebp");
    &ret();
    &function_end_B(@@_);
    $stack=0;
    &wipe_labels();
}

sub ::function_end_A
{   &pop("edi");
    &pop("esi");
    &pop("ebx");
    &pop("ebp");
    &ret();
    $stack+=16;	# readjust esp as if we didn't pop anything
}

sub ::asciz
{ my @@str=unpack("C*",shift);
    push @@str,0;
    while ($#str>15) {
	&data_byte(@@str[0..15]);
	foreach (0..15) { shift @@str; }
    }
    &data_byte(@@str) if (@@str);
}

sub ::asm_finish
{   &file_end();
    print @@out;
}

sub ::asm_init
{ my ($type,$fn,$cpu)=@@_;

    $filename=$fn;
    $i386=$cpu;

    $elf=$cpp=$coff=$aout=$macosx=$win32=$openbsd=$android=0;
    if    (($type eq "elf"))
    {	$elf=1;			require "x86gas.pl";	}
    elsif (($type eq "a\.out"))
    {	$aout=1;		require "x86gas.pl";	}
    elsif (($type eq "coff" or $type eq "gaswin"))
    {	$coff=1;		require "x86gas.pl";	}
    elsif (($type eq "macosx"))
    {	$aout=1; $macosx=1;	require "x86gas.pl";	}
    elsif (($type eq "openbsd-elf"))
    {	$openbsd=$elf=1;	require "x86gas.pl";	}
    elsif (($type eq "openbsd-a.out"))
    {	$openbsd=1;		require "x86gas.pl";	}
    elsif (($type eq "android"))
    {	$elf=1; $android=1;	require "x86gas.pl";	}
    else
    {	print STDERR <<"EOF";
Pick one target type from
	elf	- Linux, FreeBSD, Solaris x86, etc.
	a.out	- DJGPP, elder OpenBSD, etc.
	coff	- GAS/COFF such as Win32 targets
	openbsd-elf	- OpenBSD elf
	openbsd-a.out	- OpenBSD a.out
	macosx	- Mac OS X
EOF
	exit(1);
    }

    $pic=0;
    for (@@ARGV) { $pic=1 if (/\-[fK]PIC/i); }

    ::emitraw("#include \"x86_arch.h\"\n");
    ::emitraw("#include <machine/asm.h>\n") if $openbsd;
    $filename =~ s/\.pl$//;
    &file($filename);
}

1;
@


1.13
log
@A few months back there was a big community fuss regarding direct-use
of the intel RDRAND instruction.  Consensus was RDRAND should probably
only be used as an additional source of entropy in a mixer.

Guess which library bends over backwards to provide easy access to
RDRAND?  Yep.  Guess which applications are using this support?  Not
even one... but still, this is being placed as a trap for someone.

Send this support straight to the abyss.
ok kettenis
@
text
@d251 1
@


1.12
log
@Stop paying lip service to non-AT&T syntax assemblers in the x86 world.
@
text
@a132 8
sub ::rdrand
{ my ($dst)=@@_;
    if ($dst =~ /(e[a-dsd][ixp])/)
    {	&::data_byte(0x0f,0xc7,0xf0|$regrm{$dst});	}
    else
    {	&::generic("rdrand",@@_);	}
}

@


1.11
log
@resolve conflicts
@
text
@d228 1
a228 1
    $elf=$cpp=$coff=$aout=$macosx=$win32=$netware=$mwerks=$openbsd=$android=0;
a234 8
    elsif (($type eq "win32n"))
    {	$win32=1;		require "x86nasm.pl";	}
    elsif (($type eq "nw-nasm"))
    {	$netware=1;		require "x86nasm.pl";	}
    #elsif (($type eq "nw-mwasm"))
    #{	$netware=1; $mwerks=1;	require "x86nasm.pl";	}
    elsif (($type eq "win32"))
    {	$win32=1;		require "x86masm.pl";	}
a248 1
	win32n	- Windows 95/Windows NT NASM format
a250 1
	nw-nasm - NetWare NASM format
@


1.10
log
@resolve conflicts, fix local changes
@
text
@d90 51
d228 1
a228 1
    $elf=$cpp=$coff=$aout=$macosx=$win32=$netware=$mwerks=$openbsd=0;
d249 2
@


1.9
log
@resolve conflicts
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
d4 196
a199 41
# &asm_init("cpp","des-586.pl");
# XXX
# XXX
# main'asm_finish

sub main'asm_finish
	{
	&file_end();
	&asm_finish_cpp() if $cpp;
	print &asm_get_output();
	}

sub main'asm_init
	{
	($type,$fn,$i386)=@@_;
	$filename=$fn;

	$elf=$cpp=$coff=$aout=$win32=$netware=$mwerks=$openbsd=0;
	if (	($type eq "elf"))
		{ $elf=1; require "x86unix.pl"; }
	elsif (	($type eq "openbsd-elf"))
		{ $openbsd=$elf=1; require "x86unix.pl"; }
	elsif (	($type eq "openbsd-a.out"))
		{ $openbsd=1; require "x86unix.pl"; }
	elsif (	($type eq "a.out"))
		{ $aout=1; require "x86unix.pl"; }
	elsif (	($type eq "coff" or $type eq "gaswin"))
		{ $coff=1; require "x86unix.pl"; }
	elsif (	($type eq "cpp"))
		{ $cpp=1; require "x86unix.pl"; }
	elsif (	($type eq "win32"))
		{ $win32=1; require "x86ms.pl"; }
	elsif (	($type eq "win32n"))
		{ $win32=1; require "x86nasm.pl"; }
	elsif (	($type eq "nw-nasm"))
		{ $netware=1; require "x86nasm.pl"; }
	elsif (	($type eq "nw-mwasm"))
		{ $netware=1; $mwerks=1; require "x86nasm.pl"; }
	else
		{
		print STDERR <<"EOF";
d202 1
a202 1
	a.out	- OpenBSD, DJGPP, etc.
a203 1
	win32	- Windows 95/Windows NT
d208 1
a208 1
	nw-mwasm- NetWare Metrowerks Assembler
d210 2
a211 2
		exit(1);
		}
d213 2
a214 2
	$pic=0;
	for (@@ARGV) {	$pic=1 if (/\-[fK]PIC/i);	}
d216 4
a219 73
	&asm_init_output();

&comment("Don't even think of reading this code");
&comment("It was automatically generated by $filename");
&comment("Which is a perl program used to generate the x86 assember for");
&comment("any of ELF, a.out, COFF, Win32, ...");
&comment("eric <eay\@@cryptsoft.com>");
&comment("");

	$filename =~ s/\.pl$//;
	&file($filename);
	}

sub asm_finish_cpp
	{
	return unless $cpp;

	local($tmp,$i);
	foreach $i (&get_labels())
		{
		$tmp.="#define $i _$i\n";
		}
	print <<"EOF";
/* Run the C pre-processor over this file with one of the following defined
 * ELF - elf object files,
 * OUT - a.out object files,
 * BSDI - BSDI style a.out object files
 * SOL - Solaris style elf
 */

#define TYPE(a,b)       .type   a,b
#define SIZE(a,b)       .size   a,b

#if defined(OUT) || (defined(BSDI) && !defined(ELF))
$tmp
#endif

#ifdef OUT
#define OK	1
#define ALIGN	4
#if defined(__CYGWIN__) || defined(__DJGPP__) || (__MINGW32__)
#undef SIZE
#undef TYPE
#define SIZE(a,b)
#define TYPE(a,b)	.def a; .scl 2; .type 32; .endef
#endif /* __CYGWIN || __DJGPP */
#endif

#if defined(BSDI) && !defined(ELF)
#define OK              1
#define ALIGN           4
#undef SIZE
#undef TYPE
#define SIZE(a,b)
#define TYPE(a,b)
#endif

#if defined(ELF) || defined(SOL)
#define OK              1
#define ALIGN           16
#endif

#ifndef OK
You need to define one of
ELF - elf systems - linux-elf, NetBSD and DG-UX
OUT - a.out systems - linux-a.out and FreeBSD
SOL - solaris systems, which are elf with strange comment lines
BSDI - a.out with a very primative version of as.
#endif

/* Let the Assembler begin :-) */
EOF
	}
@


1.8
log
@resolve conflicts
@
text
@d21 1
a21 1
	$elf=$cpp=$sol=$aout=$win32=$gaswin=$openbsd=0;
d30 2
a31 4
	elsif (	($type eq "gaswin"))
		{ $gaswin=1; $aout=1; require "x86unix.pl"; }
	elsif (	($type eq "sol"))
		{ $sol=1; require "x86unix.pl"; }
d38 4
d46 3
a48 4
	elf	- linux, FreeBSD etc
	a.out	- old linux
	sol	- x86 solaris
	cpp	- format so x86unix.cpp can be used
d53 2
d67 1
a67 1
&comment("any of elf, a.out, BSDI, Win32, gaswin (for GNU as on Win32) or Solaris");
d102 1
a102 1
#if defined(__CYGWIN__) || defined(__DJGPP__) || defined(__MINGW32__)
a134 2

sub main'align() {} # swallow align statements in 0.9.7 context
@


1.7
log
@resolve conflicts
@
text
@d99 1
a99 1
#if defined(__CYGWIN__) || defined(__DJGPP__)
@


1.6
log
@use bn_asm_vax.S (from netbsd); test + ok by miod
use asm code for i386, except for the CBC code, because
it is not clean PIC code.
add <machime/asm.h> support to x86unix.pl
tested by: nick (on 30386), henning, djm, tedu, jmc and more;
no shlib minor crank necessary, only internal symbols changed.
@
text
@d133 2
@


1.5
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d21 1
a21 1
	$elf=$cpp=$sol=$aout=$win32=$gaswin=0;
d24 4
d50 2
@


1.4
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d21 1
a21 1
	$cpp=$sol=$aout=$win32=$gaswin=0;
d23 1
a23 1
		{ require "x86unix.pl"; }
d50 3
d97 1
a97 1
#define TYPE(a,b)
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d90 6
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d21 1
a21 1
	$cpp=$sol=$aout=$win32=0;
d26 2
d55 1
a55 1
&comment("any of elf, a.out, BSDI,Win32, or Solaris");
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!/usr/bin/perl
d18 1
a18 1
	($type,$fn)=@@_;
d32 2
d43 1
d81 1
a81 1
#if defined(OUT) || defined(BSDI)
d90 1
a90 1
#ifdef BSDI
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
d18 1
a18 1
	($type,$fn,$i386)=@@_;
d21 1
a21 1
	$cpp=$sol=$aout=$win32=$gaswin=0;
a25 2
	elsif (	($type eq "gaswin"))
		{ $gaswin=1; $aout=1; require "x86unix.pl"; }
a31 2
	elsif (	($type eq "win32n"))
		{ $win32=1; require "x86nasm.pl"; }
a40 1
	win32n	- Windows 95/Windows NT NASM format
d50 1
a50 1
&comment("any of elf, a.out, BSDI, Win32, gaswin (for GNU as on Win32) or Solaris");
d78 1
a78 1
#if defined(OUT) || (defined(BSDI) && !defined(ELF))
d87 1
a87 1
#if defined(BSDI) && !defined(ELF)
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a89 6
#if defined(__CYGWIN__) || defined(__DJGPP__)
#undef SIZE
#undef TYPE
#define SIZE(a,b)
#define TYPE(a,b)
#endif /* __CYGWIN || __DJGPP */
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d21 1
a21 1
	$elf=$cpp=$sol=$aout=$win32=$gaswin=0;
d23 1
a23 1
		{ $elf=1; require "x86unix.pl"; }
a49 3
	$pic=0;
	for (@@ARGV) {	$pic=1 if (/\-[fK]PIC/i);	}

d94 1
a94 1
#define TYPE(a,b)	.def a; .scl 2; .type 32; .endef
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a126 2
sub main'align() {} # swallow align statements in 0.9.7 context

@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d93 1
a93 1
#if defined(__CYGWIN__) || defined(__DJGPP__) || defined(__MINGW32__)
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d21 1
a21 1
	$elf=$cpp=$coff=$aout=$win32=$netware=$mwerks=0;
d26 4
a29 2
	elsif (	($type eq "coff" or $type eq "gaswin"))
		{ $coff=1; require "x86unix.pl"; }
a35 4
	elsif (	($type eq "nw-nasm"))
		{ $netware=1; require "x86nasm.pl"; }
	elsif (	($type eq "nw-mwasm"))
		{ $netware=1; $mwerks=1; require "x86nasm.pl"; }
d40 4
a43 3
	elf	- Linux, FreeBSD, Solaris x86, etc.
	a.out	- OpenBSD, DJGPP, etc.
	coff	- GAS/COFF such as Win32 targets
a45 2
	nw-nasm - NetWare NASM format
	nw-mwasm- NetWare Metrowerks Assembler
d58 1
a58 1
&comment("any of ELF, a.out, COFF, Win32, ...");
d93 1
a93 1
#if defined(__CYGWIN__) || defined(__DJGPP__) || (__MINGW32__)
d126 2
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d1 1
a1 1
#!/usr/bin/env perl
d4 37
a40 185
# &asm_init(<flavor>,"des-586.pl"[,$i386only]);
# &function_begin("foo");
# ...
# &function_end("foo");
# &asm_finish

$out=();
$i386=0;

# AUTOLOAD is this context has quite unpleasant side effect, namely
# that typos in function calls effectively go to assembler output,
# but on the pros side we don't have to implement one subroutine per
# each opcode...
sub ::AUTOLOAD
{ my $opcode = $AUTOLOAD;

    die "more than 4 arguments passed to $opcode" if ($#_>3);

    $opcode =~ s/.*:://;
    if    ($opcode =~ /^push/) { $stack+=4; }
    elsif ($opcode =~ /^pop/)  { $stack-=4; }

    &generic($opcode,@@_) or die "undefined subroutine \&$AUTOLOAD";
}

sub ::emit
{ my $opcode=shift;

    if ($#_==-1)    { push(@@out,"\t$opcode\n");				}
    else            { push(@@out,"\t$opcode\t".join(',',@@_)."\n");	}
}

sub ::LB
{   $_[0] =~ m/^e?([a-d])x$/o or die "$_[0] does not have a 'low byte'";
  $1."l";
}
sub ::HB
{   $_[0] =~ m/^e?([a-d])x$/o or die "$_[0] does not have a 'high byte'";
  $1."h";
}
sub ::stack_push{ my $num=$_[0]*4; $stack+=$num; &sub("esp",$num);	}
sub ::stack_pop	{ my $num=$_[0]*4; $stack-=$num; &add("esp",$num);	}
sub ::blindpop	{ &pop($_[0]); $stack+=4;				}
sub ::wparam	{ &DWP($stack+4*$_[0],"esp");				}
sub ::swtmp	{ &DWP(4*$_[0],"esp");					}

sub ::bswap
{   if ($i386)	# emulate bswap for i386
    {	&comment("bswap @@_");
	&xchg(&HB(@@_),&LB(@@_));
	&ror (@@_,16);
	&xchg(&HB(@@_),&LB(@@_));
    }
    else
    {	&generic("bswap",@@_);	}
}
# These are made-up opcodes introduced over the years essentially
# by ignorance, just alias them to real ones...
sub ::movb	{ &mov(@@_);	}
sub ::xorb	{ &xor(@@_);	}
sub ::rotl	{ &rol(@@_);	}
sub ::rotr	{ &ror(@@_);	}
sub ::exch	{ &xchg(@@_);	}
sub ::halt	{ &hlt;		}
sub ::movz	{ &movzx(@@_);	}
sub ::pushf	{ &pushfd;	}
sub ::popf	{ &popfd;	}

# 3 argument instructions
sub ::movq
{ my($p1,$p2,$optimize)=@@_;

    if ($optimize && $p1=~/^mm[0-7]$/ && $p2=~/^mm[0-7]$/)
    # movq between mmx registers can sink Intel CPUs
    {	&::pshufw($p1,$p2,0xe4);		}
    else
    {	&::generic("movq",@@_);			}
}

# label management
$lbdecor="L";		# local label decoration, set by package
$label="000";

sub ::islabel		# see is argument is a known label
{ my $i;
    foreach $i (values %label) { return $i if ($i eq $_[0]); }
  $label{$_[0]};	# can be undef
}

sub ::label		# instantiate a function-scope label
{   if (!defined($label{$_[0]}))
    {	$label{$_[0]}="${lbdecor}${label}${_[0]}"; $label++;   }
  $label{$_[0]};
}

sub ::LABEL		# instantiate a file-scope label
{   $label{$_[0]}=$_[1] if (!defined($label{$_[0]}));
  $label{$_[0]};
}

sub ::static_label	{ &::LABEL($_[0],$lbdecor.$_[0]); }

sub ::set_label_B	{ push(@@out,"@@_:\n"); }
sub ::set_label
{ my $label=&::label($_[0]);
    &::align($_[1]) if ($_[1]>1);
    &::set_label_B($label);
  $label;
}

sub ::wipe_labels	# wipes function-scope labels
{   foreach $i (keys %label)
    {	delete $label{$i} if ($label{$i} =~ /^\Q${lbdecor}\E[0-9]{3}/);	}
}

# subroutine management
sub ::function_begin
{   &function_begin_B(@@_);
    $stack=4;
    &push("ebp");
    &push("ebx");
    &push("esi");
    &push("edi");
}

sub ::function_end
{   &pop("edi");
    &pop("esi");
    &pop("ebx");
    &pop("ebp");
    &ret();
    &function_end_B(@@_);
    $stack=0;
    &wipe_labels();
}

sub ::function_end_A
{   &pop("edi");
    &pop("esi");
    &pop("ebx");
    &pop("ebp");
    &ret();
    $stack+=16;	# readjust esp as if we didn't pop anything
}

sub ::asciz
{ my @@str=unpack("C*",shift);
    push @@str,0;
    while ($#str>15) {
	&data_byte(@@str[0..15]);
	foreach (0..15) { shift @@str; }
    }
    &data_byte(@@str) if (@@str);
}

sub ::asm_finish
{   &file_end();
    print @@out;
}

sub ::asm_init
{ my ($type,$fn,$cpu)=@@_;

    $filename=$fn;
    $i386=$cpu;

    $elf=$cpp=$coff=$aout=$macosx=$win32=$netware=$mwerks=0;
    if    (($type eq "elf"))
    {	$elf=1;			require "x86gas.pl";	}
    elsif (($type eq "a\.out"))
    {	$aout=1;		require "x86gas.pl";	}
    elsif (($type eq "coff" or $type eq "gaswin"))
    {	$coff=1;		require "x86gas.pl";	}
    elsif (($type eq "win32n"))
    {	$win32=1;		require "x86nasm.pl";	}
    elsif (($type eq "nw-nasm"))
    {	$netware=1;		require "x86nasm.pl";	}
    #elsif (($type eq "nw-mwasm"))
    #{	$netware=1; $mwerks=1;	require "x86nasm.pl";	}
    elsif (($type eq "win32"))
    {	$win32=1;		require "x86masm.pl";	}
    elsif (($type eq "macosx"))
    {	$aout=1; $macosx=1;	require "x86gas.pl";	}
    else
    {	print STDERR <<"EOF";
d43 1
a43 1
	a.out	- DJGPP, elder OpenBSD, etc.
d45 1
d48 1
a48 1
	macosx	- Mac OS X
d50 2
a51 2
	exit(1);
    }
d53 2
a54 2
    $pic=0;
    for (@@ARGV) { $pic=1 if (/\-[fK]PIC/i); }
d56 73
a128 3
    $filename =~ s/\.pl$//;
    &file($filename);
}
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@a82 51
# SSE>2 instructions
my %regrm = (	"eax"=>0, "ecx"=>1, "edx"=>2, "ebx"=>3,
		"esp"=>4, "ebp"=>5, "esi"=>6, "edi"=>7	);
sub ::pextrd
{ my($dst,$src,$imm)=@@_;
    if ("$dst:$src" =~ /(e[a-dsd][ixp]):xmm([0-7])/)
    {	&::data_byte(0x66,0x0f,0x3a,0x16,0xc0|($2<<3)|$regrm{$1},$imm);	}
    else
    {	&::generic("pextrd",@@_);		}
}

sub ::pinsrd
{ my($dst,$src,$imm)=@@_;
    if ("$dst:$src" =~ /xmm([0-7]):(e[a-dsd][ixp])/)
    {	&::data_byte(0x66,0x0f,0x3a,0x22,0xc0|($1<<3)|$regrm{$2},$imm);	}
    else
    {	&::generic("pinsrd",@@_);		}
}

sub ::pshufb
{ my($dst,$src)=@@_;
    if ("$dst:$src" =~ /xmm([0-7]):xmm([0-7])/)
    {	&data_byte(0x66,0x0f,0x38,0x00,0xc0|($1<<3)|$2);	}
    else
    {	&::generic("pshufb",@@_);		}
}

sub ::palignr
{ my($dst,$src,$imm)=@@_;
    if ("$dst:$src" =~ /xmm([0-7]):xmm([0-7])/)
    {	&::data_byte(0x66,0x0f,0x3a,0x0f,0xc0|($1<<3)|$2,$imm);	}
    else
    {	&::generic("palignr",@@_);		}
}

sub ::pclmulqdq
{ my($dst,$src,$imm)=@@_;
    if ("$dst:$src" =~ /xmm([0-7]):xmm([0-7])/)
    {	&::data_byte(0x66,0x0f,0x3a,0x44,0xc0|($1<<3)|$2,$imm);	}
    else
    {	&::generic("pclmulqdq",@@_);		}
}

sub ::rdrand
{ my ($dst)=@@_;
    if ($dst =~ /(e[a-dsd][ixp])/)
    {	&::data_byte(0x0f,0xc7,0xf0|$regrm{$dst});	}
    else
    {	&::generic("rdrand",@@_);	}
}

d170 1
a170 1
    $elf=$cpp=$coff=$aout=$macosx=$win32=$netware=$mwerks=$android=0;
a186 2
    elsif (($type eq "android"))
    {	$elf=1; $android=1;	require "x86gas.pl";	}
@


