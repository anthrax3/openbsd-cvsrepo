head	1.10;
access;
symbols
	butholakala:1.9
	openssl_1_0_1_g:1.1.1.9
	OPENBSD_5_5:1.9.0.8
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	openssl_1_0_1_c:1.1.1.9
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.8
	openssl_1_0_0_f:1.1.1.8
	openssl_1_0_0_e:1.1.1.8
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	openssh_1_0_0_a:1.1.1.8
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	openssl_0_9_8_k:1.1.1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	openssl_0_9_8_j:1.1.1.7
	openssl_0_9_8_h:1.1.1.7
	pre_openssl_0_9_8h:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	openssl_0_9_7j:1.1.1.6
	openssl:1.1.1
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENSSL_0_9_7G:1.1.1.5
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	OPENSSL_0_9_7D:1.1.1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENSSL_0_9_7C:1.1.1.4
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENSSL_0_9_7B:1.1.1.3
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.2
	OPENSSL_0_9_7_BETA3:1.1.1.2
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.1.0.12
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.8
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@# @;


1.10
date	2014.04.17.20.17.45;	author miod;	state dead;
branches;
next	1.9;

1.9
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.29.05.39.24;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.10.16.31.55;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.29;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.43;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.40.26;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.38;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.11.21.16.35;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.13;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.34;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.42;	author djm;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Stop paying lip service to non-AT&T syntax assemblers in the x86 world.
@
text
@#!/usr/bin/env perl

package x86nasm;

*out=\@@::out;

$::lbdecor="L\$";		# local label decoration
$nmdecor=$::netware?"":"_";	# external name decoration
$drdecor=$::mwerks?".":"";	# directive decoration

$initseg="";

sub ::generic
{ my $opcode=shift;
  my $tmp;

    if (!$::mwerks)
    {   if    ($opcode =~ m/^j/o && $#_==0) # optimize jumps
	{   $_[0] = "NEAR $_[0]";   	}
	elsif ($opcode eq "lea" && $#_==1)  # wipe storage qualifier from lea
	{   $_[1] =~ s/^[^\[]*\[/\[/o;	}
	elsif ($opcode eq "clflush" && $#_==0)
	{   $_[0] =~ s/^[^\[]*\[/\[/o;	}
    }
    &::emit($opcode,@@_);
  1;
}
#
# opcodes not covered by ::generic above, mostly inconsistent namings...
#
sub ::call	{ &::emit("call",(&::islabel($_[0]) or "$nmdecor$_[0]")); }
sub ::call_ptr	{ &::emit("call",@@_);	}
sub ::jmp_ptr	{ &::emit("jmp",@@_);	}

sub get_mem
{ my($size,$addr,$reg1,$reg2,$idx)=@@_;
  my($post,$ret);

    if ($size ne "")
    {	$ret .= "$size";
	$ret .= " PTR" if ($::mwerks);
	$ret .= " ";
    }
    $ret .= "[";

    $addr =~ s/^\s+//;
    # prepend global references with optional underscore
    $addr =~ s/^([^\+\-0-9][^\+\-]*)/::islabel($1) or "$nmdecor$1"/ige;
    # put address arithmetic expression in parenthesis
    $addr="($addr)" if ($addr =~ /^.+[\-\+].+$/);

    if (($addr ne "") && ($addr ne 0))
    {	if ($addr !~ /^-/)	{ $ret .= "$addr+"; }
	else			{ $post=$addr;      }
    }

    if ($reg2 ne "")
    {	$idx!=0 or $idx=1;
	$ret .= "$reg2*$idx";
	$ret .= "+$reg1" if ($reg1 ne "");
    }
    else
    {	$ret .= "$reg1";   }

    $ret .= "$post]";
    $ret =~ s/\+\]/]/; # in case $addr was the only argument

  $ret;
}
sub ::BP	{ &get_mem("BYTE",@@_);  }
sub ::DWP	{ &get_mem("DWORD",@@_); }
sub ::WP	{ &get_mem("WORD",@@_);	}
sub ::QWP	{ &get_mem("",@@_);      }
sub ::BC	{ (($::mwerks)?"":"BYTE ")."@@_";  }
sub ::DWC	{ (($::mwerks)?"":"DWORD ")."@@_"; }

sub ::file
{   if ($::mwerks)	{ push(@@out,".section\t.text,64\n"); }
    else
    { my $tmp=<<___;
%ifidn __OUTPUT_FORMAT__,obj
section	code	use32 class=code align=64
%elifidn __OUTPUT_FORMAT__,win32
\$\@@feat.00 equ 1
section	.text	code align=64
%else
section	.text	code
%endif
___
	push(@@out,$tmp);
    }
}

sub ::function_begin_B
{ my $func=shift;
  my $global=($func !~ /^_/);
  my $begin="${::lbdecor}_${func}_begin";

    $begin =~ s/^\@@/./ if ($::mwerks);	# the torture never stops

    &::LABEL($func,$global?"$begin":"$nmdecor$func");
    $func=$nmdecor.$func;

    push(@@out,"${drdecor}global	$func\n")	if ($global);
    push(@@out,"${drdecor}align	16\n");
    push(@@out,"$func:\n");
    push(@@out,"$begin:\n")			if ($global);
    $::stack=4;
}

sub ::function_end_B
{   $::stack=0;
    &::wipe_labels();
}

sub ::file_end
{   if (grep {/\b${nmdecor}OPENSSL_ia32cap_P\b/i} @@out)
    {	my $comm=<<___;
${drdecor}segment	.bss
${drdecor}common	${nmdecor}OPENSSL_ia32cap_P 8
___
	# comment out OPENSSL_ia32cap_P declarations
	grep {s/(^extern\s+${nmdecor}OPENSSL_ia32cap_P)/\;$1/} @@out;
	push (@@out,$comm)
    }
    push (@@out,$initseg) if ($initseg);		
}

sub ::comment {   foreach (@@_) { push(@@out,"\t; $_\n"); }   }

sub ::external_label
{   foreach(@@_)
    {	push(@@out,"${drdecor}extern\t".&::LABEL($_,$nmdecor.$_)."\n");   }
}

sub ::public_label
{   push(@@out,"${drdecor}global\t".&::LABEL($_[0],$nmdecor.$_[0])."\n");  }

sub ::data_byte
{   push(@@out,(($::mwerks)?".byte\t":"db\t").join(',',@@_)."\n");	}
sub ::data_short
{   push(@@out,(($::mwerks)?".word\t":"dw\t").join(',',@@_)."\n");	}
sub ::data_word
{   push(@@out,(($::mwerks)?".long\t":"dd\t").join(',',@@_)."\n");	}

sub ::align
{   push(@@out,"${drdecor}align\t$_[0]\n");	}

sub ::picmeup
{ my($dst,$sym)=@@_;
    &::lea($dst,&::DWP($sym));
}

sub ::initseg
{ my $f=$nmdecor.shift;
    if ($::win32)
    {	$initseg=<<___;
segment	.CRT\$XCU data align=4
extern	$f
dd	$f
___
    }
}

sub ::dataseg
{   if ($mwerks)	{ push(@@out,".section\t.data,4\n");   }
    else		{ push(@@out,"section\t.data align=4\n"); }
}

sub ::safeseh
{ my $nm=shift;
    push(@@out,"%if	__NASM_VERSION_ID__ >= 0x02030000\n");
    push(@@out,"safeseh	".&::LABEL($nm,$nmdecor.$nm)."\n");
    push(@@out,"%endif\n");
}

1;
@


1.9
log
@resolve conflicts
@
text
@@


1.8
log
@resolve conflicts, fix local changes
@
text
@d22 2
d72 1
d120 1
a120 1
${drdecor}common	${nmdecor}OPENSSL_ia32cap_P 4
d141 2
a142 1

d168 7
@


1.7
log
@resolve conflicts
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
d5 1
a5 2
$label="L000";
$under=($main'netware)?'':'_';
d7 18
a24 31
%lb=(	'eax',	'al',
	'ebx',	'bl',
	'ecx',	'cl',
	'edx',	'dl',
	'ax',	'al',
	'bx',	'bl',
	'cx',	'cl',
	'dx',	'dl',
	);

%hb=(	'eax',	'ah',
	'ebx',	'bh',
	'ecx',	'ch',
	'edx',	'dh',
	'ax',	'ah',
	'bx',	'bh',
	'cx',	'ch',
	'dx',	'dh',
	);

sub main'asm_init_output { @@out=(); }
sub main'asm_get_output { return(@@out); }
sub main'get_labels { return(@@labels); }

sub main'external_label
{
	push(@@labels,@@_);
	foreach (@@_) {
		push(@@out,".") if ($main'mwerks);
		push(@@out, "extern\t${under}$_\n");
	}
d26 10
d37 25
a61 50
sub main'LB
	{
	(defined($lb{$_[0]})) || die "$_[0] does not have a 'low byte'\n";
	return($lb{$_[0]});
	}

sub main'HB
	{
	(defined($hb{$_[0]})) || die "$_[0] does not have a 'high byte'\n";
	return($hb{$_[0]});
	}

sub main'BP
	{
	&get_mem("BYTE",@@_);
	}

sub main'DWP
	{
	&get_mem("DWORD",@@_);
	}

sub main'QWP
	{
	&get_mem("",@@_);
	}

sub main'BC
	{
	return (($main'mwerks)?"":"BYTE ")."@@_";
	}

sub main'DWC
	{
	return (($main'mwerks)?"":"DWORD ")."@@_";
	}

sub main'stack_push
	{
	my($num)=@@_;
	$stack+=$num*4;
	&main'sub("esp",$num*4);
	}

sub main'stack_pop
	{
	my($num)=@@_;
	$stack-=$num*4;
	&main'add("esp",$num*4);
	}
d63 20
a82 180
sub get_mem
	{
	my($size,$addr,$reg1,$reg2,$idx)=@@_;
	my($t,$post);
	my($ret)=$size;
	if ($ret ne "")
		{
		$ret .= " PTR" if ($main'mwerks);
		$ret .= " ";
		}
	$ret .= "[";
	$addr =~ s/^\s+//;
	if ($addr =~ /^(.+)\+(.+)$/)
		{
		$reg2=&conv($1);
		$addr="$under$2";
		}
	elsif ($addr =~ /^[_a-z][_a-z0-9]*$/i)
		{
		$addr="$under$addr";
		}

	if ($addr =~ /^.+\-.+$/) { $addr="($addr)"; }

	$reg1="$regs{$reg1}" if defined($regs{$reg1});
	$reg2="$regs{$reg2}" if defined($regs{$reg2});
	if (($addr ne "") && ($addr ne 0))
		{
		if ($addr !~ /^-/)
			{ $ret.="${addr}+"; }
		else	{ $post=$addr; }
		}
	if ($reg2 ne "")
		{
		$t="";
		$t="*$idx" if ($idx != 0);
		$reg1="+".$reg1 if ("$reg1$post" ne "");
		$ret.="$reg2$t$reg1$post]";
		}
	else
		{
		$ret.="$reg1$post]"
		}
	$ret =~ s/\+\]/]/; # in case $addr was the only argument
	return($ret);
	}

sub main'mov	{ &out2("mov",@@_); }
sub main'movb	{ &out2("mov",@@_); }
sub main'and	{ &out2("and",@@_); }
sub main'or	{ &out2("or",@@_); }
sub main'shl	{ &out2("shl",@@_); }
sub main'shr	{ &out2("shr",@@_); }
sub main'xor	{ &out2("xor",@@_); }
sub main'xorb	{ &out2("xor",@@_); }
sub main'add	{ &out2("add",@@_); }
sub main'adc	{ &out2("adc",@@_); }
sub main'sub	{ &out2("sub",@@_); }
sub main'sbb	{ &out2("sbb",@@_); }
sub main'rotl	{ &out2("rol",@@_); }
sub main'rotr	{ &out2("ror",@@_); }
sub main'exch	{ &out2("xchg",@@_); }
sub main'cmp	{ &out2("cmp",@@_); }
sub main'lea	{ &out2("lea",@@_); }
sub main'mul	{ &out1("mul",@@_); }
sub main'imul	{ &out2("imul",@@_); }
sub main'div	{ &out1("div",@@_); }
sub main'dec	{ &out1("dec",@@_); }
sub main'inc	{ &out1("inc",@@_); }
sub main'jmp	{ &out1("jmp",@@_); }
sub main'jmp_ptr { &out1p("jmp",@@_); }

# This is a bit of a kludge: declare all branches as NEAR.
$near=($main'mwerks)?'':'NEAR';
sub main'je	{ &out1("je $near",@@_); }
sub main'jle	{ &out1("jle $near",@@_); }
sub main'jz	{ &out1("jz $near",@@_); }
sub main'jge	{ &out1("jge $near",@@_); }
sub main'jl	{ &out1("jl $near",@@_); }
sub main'ja	{ &out1("ja $near",@@_); }
sub main'jae	{ &out1("jae $near",@@_); }
sub main'jb	{ &out1("jb $near",@@_); }
sub main'jbe	{ &out1("jbe $near",@@_); }
sub main'jc	{ &out1("jc $near",@@_); }
sub main'jnc	{ &out1("jnc $near",@@_); }
sub main'jnz	{ &out1("jnz $near",@@_); }
sub main'jne	{ &out1("jne $near",@@_); }
sub main'jno	{ &out1("jno $near",@@_); }

sub main'push	{ &out1("push",@@_); $stack+=4; }
sub main'pop	{ &out1("pop",@@_); $stack-=4; }
sub main'pushf	{ &out0("pushfd"); $stack+=4; }
sub main'popf	{ &out0("popfd"); $stack-=4; }
sub main'bswap	{ &out1("bswap",@@_); &using486(); }
sub main'not	{ &out1("not",@@_); }
sub main'call	{ &out1("call",($_[0]=~/^\@@L/?'':$under).$_[0]); }
sub main'call_ptr { &out1p("call",@@_); }
sub main'ret	{ &out0("ret"); }
sub main'nop	{ &out0("nop"); }
sub main'test	{ &out2("test",@@_); }
sub main'bt	{ &out2("bt",@@_); }
sub main'leave	{ &out0("leave"); }
sub main'cpuid	{ &out0("cpuid"); }
sub main'rdtsc	{ &out0("rdtsc"); }
sub main'halt	{ &out0("hlt"); }
sub main'movz	{ &out2("movzx",@@_); }
sub main'neg	{ &out1("neg",@@_); }
sub main'cld	{ &out0("cld"); }

# SSE2
sub main'emms	{ &out0("emms"); }
sub main'movd	{ &out2("movd",@@_); }
sub main'movq	{ &out2("movq",@@_); }
sub main'movdqu	{ &out2("movdqu",@@_); }
sub main'movdqa	{ &out2("movdqa",@@_); }
sub main'movdq2q{ &out2("movdq2q",@@_); }
sub main'movq2dq{ &out2("movq2dq",@@_); }
sub main'paddq	{ &out2("paddq",@@_); }
sub main'pmuludq{ &out2("pmuludq",@@_); }
sub main'psrlq	{ &out2("psrlq",@@_); }
sub main'psllq	{ &out2("psllq",@@_); }
sub main'pxor	{ &out2("pxor",@@_); }
sub main'por	{ &out2("por",@@_); }
sub main'pand	{ &out2("pand",@@_); }

sub out2
	{
	my($name,$p1,$p2)=@@_;
	my($l,$t);

	push(@@out,"\t$name\t");
	if (!$main'mwerks and $name eq "lea")
		{
		$p1 =~ s/^[^\[]*\[/\[/;
		$p2 =~ s/^[^\[]*\[/\[/;
		}
	$t=&conv($p1).",";
	$l=length($t);
	push(@@out,$t);
	$l=4-($l+9)/8;
	push(@@out,"\t" x $l);
	push(@@out,&conv($p2));
	push(@@out,"\n");
	}

sub out0
	{
	my($name)=@@_;

	push(@@out,"\t$name\n");
	}

sub out1
	{
	my($name,$p1)=@@_;
	my($l,$t);
	push(@@out,"\t$name\t".&conv($p1)."\n");
	}

sub conv
	{
	my($p)=@@_;
	$p =~ s/0x([0-9A-Fa-f]+)/0$1h/;
	return $p;
	}

sub using486
	{
	return if $using486;
	$using486++;
	grep(s/\.386/\.486/,@@out);
	}

sub main'file
	{
	if ($main'mwerks)	{ push(@@out,".section\t.text\n"); }
	else	{
		local $tmp=<<___;
%ifdef __omf__
section	code	use32 class=code
d84 1
a84 1
section	.text
a86 18
		push(@@out,$tmp);
		}
	}

sub main'function_begin
	{
	my($func,$extra)=@@_;

	push(@@labels,$func);
	push(@@out,".") if ($main'mwerks);
	my($tmp)=<<"EOF";
global	$under$func
$under$func:
	push	ebp
	push	ebx
	push	esi
	push	edi
EOF
d88 44
a131 2
	$stack=20;
	}
d133 8
a140 11
sub main'function_begin_B
	{
	my($func,$extra)=@@_;
	push(@@out,".") if ($main'mwerks);
	my($tmp)=<<"EOF";
global	$under$func
$under$func:
EOF
	push(@@out,$tmp);
	$stack=4;
	}
d142 2
a143 35
sub main'function_end
	{
	my($func)=@@_;

	my($tmp)=<<"EOF";
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret
EOF
	push(@@out,$tmp);
	$stack=0;
	%label=();
	}

sub main'function_end_B
	{
	$stack=0;
	%label=();
	}

sub main'function_end_A
	{
	my($func)=@@_;

	my($tmp)=<<"EOF";
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret
EOF
	push(@@out,$tmp);
	}
d145 4
a148 23
sub main'file_end
	{
	}

sub main'wparam
	{
	my($num)=@@_;

	return(&main'DWP($stack+$num*4,"esp","",0));
	}

sub main'swtmp
	{
	return(&main'DWP($_[0]*4,"esp","",0));
	}

# Should use swtmp, which is above esp.  Linix can trash the stack above esp
#sub main'wtmp
#	{
#	my($num)=@@_;
#
#	return(&main'DWP(-(($num+1)*4),"esp","",0));
#	}
d150 7
a156 80
sub main'comment
	{
	foreach (@@_)
		{
		push(@@out,"\t; $_\n");
		}
	}

sub main'public_label
	{
	$label{$_[0]}="${under}${_[0]}"	if (!defined($label{$_[0]}));
	push(@@out,".") if ($main'mwerks);
	push(@@out,"global\t$label{$_[0]}\n");
	}

sub main'label
	{
	if (!defined($label{$_[0]}))
		{
		$label{$_[0]}="\@@${label}${_[0]}";
		$label++;
		}
	return($label{$_[0]});
	}

sub main'set_label
	{
	if (!defined($label{$_[0]}))
		{
		$label{$_[0]}="\@@${label}${_[0]}";
		$label++;
		}
	if ($_[1]!=0 && $_[1]>1)
		{
		main'align($_[1]);
		}
	push(@@out,"$label{$_[0]}:\n");
	}

sub main'data_byte
	{
	push(@@out,(($main'mwerks)?".byte\t":"DB\t").join(',',@@_)."\n");
	}

sub main'data_word
	{
	push(@@out,(($main'mwerks)?".long\t":"DD\t").join(',',@@_)."\n");
	}

sub main'align
	{
	push(@@out,".") if ($main'mwerks);
	push(@@out,"align\t$_[0]\n");
	}

sub out1p
	{
	my($name,$p1)=@@_;
	my($l,$t);

	push(@@out,"\t$name\t".&conv($p1)."\n");
	}

sub main'picmeup
	{
	local($dst,$sym)=@@_;
	&main'lea($dst,&main'DWP($sym));
	}

sub main'blindpop { &out1("pop",@@_); }

sub main'initseg
	{
	local($f)=@@_;
	if ($main'win32)
		{
		local($tmp)=<<___;
segment	.CRT\$XCU data
extern	$under$f
DD	$under$f
d158 7
a164 3
		push(@@out,$tmp);
		}
	}
@


1.6
log
@resolve conflicts
@
text
@d6 1
d36 2
a37 1
		push(@@out, "extern\t_$_\n");
d63 5
d70 1
a70 1
	return "BYTE @@_";
d75 1
a75 1
	return "DWORD @@_";
d96 7
a102 1
	my($ret)="$size [";
d107 1
a107 1
		$addr="_$2";
d109 1
a109 1
	elsif ($addr =~ /^[_a-zA-Z]/)
d111 1
a111 1
		$addr="_$addr";
d150 1
d157 1
d165 15
a179 14
sub main'je	{ &out1("je NEAR",@@_); }
sub main'jle	{ &out1("jle NEAR",@@_); }
sub main'jz	{ &out1("jz NEAR",@@_); }
sub main'jge	{ &out1("jge NEAR",@@_); }
sub main'jl	{ &out1("jl NEAR",@@_); }
sub main'ja	{ &out1("ja NEAR",@@_); }
sub main'jae	{ &out1("jae NEAR",@@_); }
sub main'jb	{ &out1("jb NEAR",@@_); }
sub main'jbe	{ &out1("jbe NEAR",@@_); }
sub main'jc	{ &out1("jc NEAR",@@_); }
sub main'jnc	{ &out1("jnc NEAR",@@_); }
sub main'jnz	{ &out1("jnz NEAR",@@_); }
sub main'jne	{ &out1("jne NEAR",@@_); }
sub main'jno	{ &out1("jno NEAR",@@_); }
d183 2
d187 2
a188 1
sub main'call	{ &out1("call",($_[0]=~/^\$L/?'':'_').$_[0]); }
d191 6
d198 18
d223 1
a223 1
	if ($name eq "lea")
d267 3
a269 2
	local $tmp;
	$tmp=<<___;
d276 2
a277 1
	push(@@out,$tmp);
d285 1
d287 2
a288 2
global	_$func
_$func:
d301 1
d303 2
a304 2
global	_$func
_$func:
d378 7
d389 1
a389 1
		$label{$_[0]}="\$${label}${_[0]}";
d399 1
a399 1
		$label{$_[0]}="\$${label}${_[0]}";
d402 4
d409 5
d416 7
a422 1
	push(@@out,"\tDD\t$_[0]\n");
d430 1
a430 1
	push(@@out,"\t$name\t ".&conv($p1)."\n");
d440 16
@


1.5
log
@resolve conflicts
@
text
@d224 9
a232 1
	push(@@out, "segment .text use32\n");
@


1.4
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d89 1
a89 1
	my($ret)="[";
d172 1
d180 5
@


1.3
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d155 2
d158 1
@


1.2
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d101 2
d122 1
d166 1
a166 1
sub main'call	{ &out1("call",'_'.$_[0]); }
d328 1
a328 1
		$label{$_[0]}="${label}${_[0]}";
d346 8
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d212 1
a212 1
	push(@@out, "segment .text\n");
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@d212 1
a212 1
	push(@@out, "segment .text use32\n");
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@a100 2
	if ($addr =~ /^.+\-.+$/) { $addr="($addr)"; }

a119 1
	$ret =~ s/\+\]/]/; # in case $addr was the only argument
d163 1
a163 1
sub main'call	{ &out1("call",($_[0]=~/^\$L/?'':'_').$_[0]); }
d325 1
a325 1
		$label{$_[0]}="\$${label}${_[0]}";
a342 8

sub main'picmeup
	{
	local($dst,$sym)=@@_;
	&main'lea($dst,&main'DWP($sym));
	}

sub main'blindpop { &out1("pop",@@_); }
@


1.1.1.4
log
@import 0.9.7c
@
text
@a154 2
sub main'ja	{ &out1("ja NEAR",@@_); }
sub main'jae	{ &out1("jae NEAR",@@_); }
a155 1
sub main'jbe	{ &out1("jbe NEAR",@@_); }
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d89 1
a89 1
	my($ret)="$size [";
a171 1
sub main'movz	{ &out2("movzx",@@_); }
a178 5
	if ($name eq "lea")
		{
		$p1 =~ s/^[^\[]*\[/\[/;
		$p2 =~ s/^[^\[]*\[/\[/;
		}
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d224 1
a224 9
	local $tmp;
	$tmp=<<___;
%ifdef __omf__
section	code	use32 class=code
%else
section	.text
%endif
___
	push(@@out,$tmp);
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@a5 1
$under=($main'netware)?'':'_';
d35 1
a35 2
		push(@@out,".") if ($main'mwerks);
		push(@@out, "extern\t${under}$_\n");
a60 5
sub main'QWP
	{
	&get_mem("",@@_);
	}

d63 1
a63 1
	return (($main'mwerks)?"":"BYTE ")."@@_";
d68 1
a68 1
	return (($main'mwerks)?"":"DWORD ")."@@_";
d89 1
a89 7
	my($ret)=$size;
	if ($ret ne "")
		{
		$ret .= " PTR" if ($main'mwerks);
		$ret .= " ";
		}
	$ret .= "[";
d94 1
a94 1
		$addr="$under$2";
d96 1
a96 1
	elsif ($addr =~ /^[_a-z][_a-z0-9]*$/i)
d98 1
a98 1
		$addr="$under$addr";
a136 1
sub main'sbb	{ &out2("sbb",@@_); }
a142 1
sub main'imul	{ &out2("imul",@@_); }
d150 14
a163 15
$near=($main'mwerks)?'':'NEAR';
sub main'je	{ &out1("je $near",@@_); }
sub main'jle	{ &out1("jle $near",@@_); }
sub main'jz	{ &out1("jz $near",@@_); }
sub main'jge	{ &out1("jge $near",@@_); }
sub main'jl	{ &out1("jl $near",@@_); }
sub main'ja	{ &out1("ja $near",@@_); }
sub main'jae	{ &out1("jae $near",@@_); }
sub main'jb	{ &out1("jb $near",@@_); }
sub main'jbe	{ &out1("jbe $near",@@_); }
sub main'jc	{ &out1("jc $near",@@_); }
sub main'jnc	{ &out1("jnc $near",@@_); }
sub main'jnz	{ &out1("jnz $near",@@_); }
sub main'jne	{ &out1("jne $near",@@_); }
sub main'jno	{ &out1("jno $near",@@_); }
a166 2
sub main'pushf	{ &out0("pushfd"); $stack+=4; }
sub main'popf	{ &out0("popfd"); $stack-=4; }
d169 1
a169 2
sub main'call	{ &out1("call",($_[0]=~/^\@@L/?'':$under).$_[0]); }
sub main'call_ptr { &out1p("call",@@_); }
a171 6
sub main'test	{ &out2("test",@@_); }
sub main'bt	{ &out2("bt",@@_); }
sub main'leave	{ &out0("leave"); }
sub main'cpuid	{ &out0("cpuid"); }
sub main'rdtsc	{ &out0("rdtsc"); }
sub main'halt	{ &out0("hlt"); }
a172 18
sub main'neg	{ &out1("neg",@@_); }
sub main'cld	{ &out0("cld"); }

# SSE2
sub main'emms	{ &out0("emms"); }
sub main'movd	{ &out2("movd",@@_); }
sub main'movq	{ &out2("movq",@@_); }
sub main'movdqu	{ &out2("movdqu",@@_); }
sub main'movdqa	{ &out2("movdqa",@@_); }
sub main'movdq2q{ &out2("movdq2q",@@_); }
sub main'movq2dq{ &out2("movq2dq",@@_); }
sub main'paddq	{ &out2("paddq",@@_); }
sub main'pmuludq{ &out2("pmuludq",@@_); }
sub main'psrlq	{ &out2("psrlq",@@_); }
sub main'psllq	{ &out2("psllq",@@_); }
sub main'pxor	{ &out2("pxor",@@_); }
sub main'por	{ &out2("por",@@_); }
sub main'pand	{ &out2("pand",@@_); }
d180 1
a180 1
	if (!$main'mwerks and $name eq "lea")
d224 2
a225 3
	if ($main'mwerks)	{ push(@@out,".section\t.text\n"); }
	else	{
		local $tmp=<<___;
d232 1
a232 2
		push(@@out,$tmp);
		}
a239 1
	push(@@out,".") if ($main'mwerks);
d241 2
a242 2
global	$under$func
$under$func:
a254 1
	push(@@out,".") if ($main'mwerks);
d256 2
a257 2
global	$under$func
$under$func:
a330 7
sub main'public_label
	{
	$label{$_[0]}="${under}${_[0]}"	if (!defined($label{$_[0]}));
	push(@@out,".") if ($main'mwerks);
	push(@@out,"global\t$label{$_[0]}\n");
	}

d335 1
a335 1
		$label{$_[0]}="\@@${label}${_[0]}";
d345 1
a345 1
		$label{$_[0]}="\@@${label}${_[0]}";
a347 4
	if ($_[1]!=0 && $_[1]>1)
		{
		main'align($_[1]);
		}
a350 5
sub main'data_byte
	{
	push(@@out,(($main'mwerks)?".byte\t":"DB\t").join(',',@@_)."\n");
	}

d353 1
a353 7
	push(@@out,(($main'mwerks)?".long\t":"DD\t").join(',',@@_)."\n");
	}

sub main'align
	{
	push(@@out,".") if ($main'mwerks);
	push(@@out,"align\t$_[0]\n");
d361 1
a361 1
	push(@@out,"\t$name\t".&conv($p1)."\n");
a370 16

sub main'initseg
	{
	local($f)=@@_;
	if ($main'win32)
		{
		local($tmp)=<<___;
segment	.CRT\$XCU data
extern	$under$f
DD	$under$f
___
		push(@@out,$tmp);
		}
	}

1;
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d1 1
a1 1
#!/usr/bin/env perl
d5 2
a6 1
*out=\@@::out;
d8 31
a38 18
$::lbdecor="L\$";		# local label decoration
$nmdecor=$::netware?"":"_";	# external name decoration
$drdecor=$::mwerks?".":"";	# directive decoration

$initseg="";

sub ::generic
{ my $opcode=shift;
  my $tmp;

    if (!$::mwerks)
    {   if    ($opcode =~ m/^j/o && $#_==0) # optimize jumps
	{   $_[0] = "NEAR $_[0]";   	}
	elsif ($opcode eq "lea" && $#_==1)  # wipe storage qualifier from lea
	{   $_[1] =~ s/^[^\[]*\[/\[/o;	}
    }
    &::emit($opcode,@@_);
  1;
d40 51
a90 6
#
# opcodes not covered by ::generic above, mostly inconsistent namings...
#
sub ::call	{ &::emit("call",(&::islabel($_[0]) or "$nmdecor$_[0]")); }
sub ::call_ptr	{ &::emit("call",@@_);	}
sub ::jmp_ptr	{ &::emit("jmp",@@_);	}
d93 179
a271 49
{ my($size,$addr,$reg1,$reg2,$idx)=@@_;
  my($post,$ret);

    if ($size ne "")
    {	$ret .= "$size";
	$ret .= " PTR" if ($::mwerks);
	$ret .= " ";
    }
    $ret .= "[";

    $addr =~ s/^\s+//;
    # prepend global references with optional underscore
    $addr =~ s/^([^\+\-0-9][^\+\-]*)/::islabel($1) or "$nmdecor$1"/ige;
    # put address arithmetic expression in parenthesis
    $addr="($addr)" if ($addr =~ /^.+[\-\+].+$/);

    if (($addr ne "") && ($addr ne 0))
    {	if ($addr !~ /^-/)	{ $ret .= "$addr+"; }
	else			{ $post=$addr;      }
    }

    if ($reg2 ne "")
    {	$idx!=0 or $idx=1;
	$ret .= "$reg2*$idx";
	$ret .= "+$reg1" if ($reg1 ne "");
    }
    else
    {	$ret .= "$reg1";   }

    $ret .= "$post]";
    $ret =~ s/\+\]/]/; # in case $addr was the only argument

  $ret;
}
sub ::BP	{ &get_mem("BYTE",@@_);  }
sub ::DWP	{ &get_mem("DWORD",@@_); }
sub ::QWP	{ &get_mem("",@@_);      }
sub ::BC	{ (($::mwerks)?"":"BYTE ")."@@_";  }
sub ::DWC	{ (($::mwerks)?"":"DWORD ")."@@_"; }

sub ::file
{   if ($::mwerks)	{ push(@@out,".section\t.text,64\n"); }
    else
    { my $tmp=<<___;
%ifidn __OUTPUT_FORMAT__,obj
section	code	use32 class=code align=64
%elifidn __OUTPUT_FORMAT__,win32
\$\@@feat.00 equ 1
section	.text	code align=64
d273 1
a273 1
section	.text	code
d276 18
d295 2
a296 2
    }
}
d298 11
a308 16
sub ::function_begin_B
{ my $func=shift;
  my $global=($func !~ /^_/);
  my $begin="${::lbdecor}_${func}_begin";

    $begin =~ s/^\@@/./ if ($::mwerks);	# the torture never stops

    &::LABEL($func,$global?"$begin":"$nmdecor$func");
    $func=$nmdecor.$func;

    push(@@out,"${drdecor}global	$func\n")	if ($global);
    push(@@out,"${drdecor}align	16\n");
    push(@@out,"$func:\n");
    push(@@out,"$begin:\n")			if ($global);
    $::stack=4;
}
d310 35
a344 4
sub ::function_end_B
{   $::stack=0;
    &::wipe_labels();
}
d346 23
a368 25
sub ::file_end
{   if (grep {/\b${nmdecor}OPENSSL_ia32cap_P\b/i} @@out)
    {	my $comm=<<___;
${drdecor}segment	.bss
${drdecor}common	${nmdecor}OPENSSL_ia32cap_P 4
___
	# comment out OPENSSL_ia32cap_P declarations
	grep {s/(^extern\s+${nmdecor}OPENSSL_ia32cap_P)/\;$1/} @@out;
	push (@@out,$comm)
    }
    push (@@out,$initseg) if ($initseg);		
}

sub ::comment {   foreach (@@_) { push(@@out,"\t; $_\n"); }   }

sub ::external_label
{   foreach(@@_)
    {	push(@@out,"${drdecor}extern\t".&::LABEL($_,$nmdecor.$_)."\n");   }
}

sub ::public_label
{   push(@@out,"${drdecor}global\t".&::LABEL($_[0],$nmdecor.$_[0])."\n");  }

sub ::data_byte
{   push(@@out,(($::mwerks)?".byte\t":"db\t").join(',',@@_)."\n");	}
d370 80
a449 18
sub ::data_word
{   push(@@out,(($::mwerks)?".long\t":"dd\t").join(',',@@_)."\n");	}

sub ::align
{   push(@@out,"${drdecor}align\t$_[0]\n");	}

sub ::picmeup
{ my($dst,$sym)=@@_;
    &::lea($dst,&::DWP($sym));
}

sub ::initseg
{ my $f=$nmdecor.shift;
    if ($::win32)
    {	$initseg=<<___;
segment	.CRT\$XCU data align=4
extern	$f
dd	$f
d451 3
a453 7
    }
}

sub ::dataseg
{   if ($mwerks)	{ push(@@out,".section\t.data,4\n");   }
    else		{ push(@@out,"section\t.data align=4\n"); }
}
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@a21 2
	elsif ($opcode eq "clflush" && $#_==0)
	{   $_[0] =~ s/^[^\[]*\[/\[/o;	}
a69 1
sub ::WP	{ &get_mem("WORD",@@_);	}
d117 1
a117 1
${drdecor}common	${nmdecor}OPENSSL_ia32cap_P 8
d138 1
a138 2
sub ::data_short
{   push(@@out,(($::mwerks)?".word\t":"dw\t").join(',',@@_)."\n");	}
a163 7
}

sub ::safeseh
{ my $nm=shift;
    push(@@out,"%if	__NASM_VERSION_ID__ >= 0x02030000\n");
    push(@@out,"safeseh	".&::LABEL($nm,$nmdecor.$nm)."\n");
    push(@@out,"%endif\n");
@


