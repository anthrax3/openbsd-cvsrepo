head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.2
	OPENBSD_6_1_BASE:1.13;
locks; strict;
comment	@ * @;


1.13
date	2016.12.30.15.38.13;	author jsing;	state Exp;
branches;
next	1.12;
commitid	bRjJ3rgPej1ygmFV;

1.12
date	2014.10.18.17.20.40;	author jsing;	state Exp;
branches;
next	1.11;
commitid	8tb4v3IC8S2vzfHj;

1.11
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.10;
commitid	yQEL1wOWIearrW15;

1.10
date	2014.06.29.17.05.36;	author jsing;	state Exp;
branches;
next	1.9;
commitid	t0SFeQtZd9bpT5Df;

1.9
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	mJUVYpkFBZ0Zv2bG;

1.8
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.22.00.03.16;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.58.01;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.11.09;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.46;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.11.21.16.51;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.06.27.05.05.35;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.13.58;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Expand ASN1_ITEM_rptr macros - no change in generated assembly.
@
text
@/* $OpenBSD: pk7_mime.c,v 1.12 2014/10/18 17:20:40 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project.
 */
/* ====================================================================
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 */

#include <ctype.h>
#include <stdio.h>

#include <openssl/asn1.h>
#include <openssl/x509.h>

/* PKCS#7 wrappers round generalised stream and MIME routines */

int
i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)
{
	return i2d_ASN1_bio_stream(out, (ASN1_VALUE *)p7, in, flags,
	    &PKCS7_it);
}

int
PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)
{
	return PEM_write_bio_ASN1_stream(out, (ASN1_VALUE *) p7, in, flags,
	    "PKCS7", &PKCS7_it);
}

int
SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)
{
	STACK_OF(X509_ALGOR) *mdalgs;
	int ctype_nid = OBJ_obj2nid(p7->type);
	if (ctype_nid == NID_pkcs7_signed)
		mdalgs = p7->d.sign->md_algs;
	else
		mdalgs = NULL;

	flags ^= SMIME_OLDMIME;


	return SMIME_write_ASN1(bio, (ASN1_VALUE *)p7, data, flags,
	    ctype_nid, NID_undef, mdalgs, &PKCS7_it);
}

PKCS7 *
SMIME_read_PKCS7(BIO *bio, BIO **bcont)
{
	return (PKCS7 *)SMIME_read_ASN1(bio, bcont, &PKCS7_it);
}
@


1.12
log
@None of these need to include <openssl/rand.h>
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_mime.c,v 1.11 2014/07/11 08:44:49 jsing Exp $ */
d67 1
a67 1
	    ASN1_ITEM_rptr(PKCS7));
d74 1
a74 1
	    "PKCS7", ASN1_ITEM_rptr(PKCS7));
d91 1
a91 1
	    ctype_nid, NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7));
d97 1
a97 1
	return (PKCS7 *)SMIME_read_ASN1(bio, bcont, ASN1_ITEM_rptr(PKCS7));
@


1.11
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_mime.c,v 1.10 2014/06/29 17:05:36 jsing Exp $ */
a58 1
#include <openssl/rand.h>
@


1.10
log
@KNF.

I just spent too long chasing a bug in here and really should have done
this first. Gem of the day... is it an if test or a for loop? No, it is a
super ifloop!

if (!(flags & PKCS7_NOVERIFY)) for (k = 0; k < sk_X509_num(signers); k++) {
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_mime.c,v 1.9 2014/06/12 15:49:30 deraadt Exp $ */
d55 1
d57 2
a58 2
#include <ctype.h>
#include "cryptlib.h"
a60 1
#include <openssl/asn1.h>
@


1.9
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d64 3
a66 2
int i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)
	{
d68 2
a69 2
					ASN1_ITEM_rptr(PKCS7));
	}
d71 3
a73 2
int PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)
	{
d75 2
a76 3
						"PKCS7",
						ASN1_ITEM_rptr(PKCS7));
	}
d78 3
a80 2
int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)
	{
d92 2
a93 3
					ctype_nid, NID_undef, mdalgs,
					ASN1_ITEM_rptr(PKCS7));	
	}
d95 3
a97 2
PKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont)
	{
d99 1
a99 1
	}
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d1 1
a1 1
/* pk7_mime.c */
@


1.7
log
@resolve conflicts
@
text
@a52 4
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
d60 1
d62 1
a62 1
/* MIME and related routines */
d64 4
a67 54
/* MIME format structures
 * Note that all are translated to lower case apart from
 * parameter values. Quotes are stripped off
 */

typedef struct {
char *param_name;			/* Param name e.g. "micalg" */
char *param_value;			/* Param value e.g. "sha1" */
} MIME_PARAM;

DECLARE_STACK_OF(MIME_PARAM)
IMPLEMENT_STACK_OF(MIME_PARAM)

typedef struct {
char *name;				/* Name of line e.g. "content-type" */
char *value;				/* Value of line e.g. "text/plain" */
STACK_OF(MIME_PARAM) *params;		/* Zero or more parameters */
} MIME_HEADER;

DECLARE_STACK_OF(MIME_HEADER)
IMPLEMENT_STACK_OF(MIME_HEADER)

static int pkcs7_output_data(BIO *bio, BIO *data, PKCS7 *p7, int flags);
static int B64_write_PKCS7(BIO *bio, PKCS7 *p7);
static PKCS7 *B64_read_PKCS7(BIO *bio);
static char * strip_ends(char *name);
static char * strip_start(char *name);
static char * strip_end(char *name);
static MIME_HEADER *mime_hdr_new(char *name, char *value);
static int mime_hdr_addparam(MIME_HEADER *mhdr, char *name, char *value);
static STACK_OF(MIME_HEADER) *mime_parse_hdr(BIO *bio);
static int mime_hdr_cmp(const MIME_HEADER * const *a,
			const MIME_HEADER * const *b);
static int mime_param_cmp(const MIME_PARAM * const *a,
			const MIME_PARAM * const *b);
static void mime_param_free(MIME_PARAM *param);
static int mime_bound_check(char *line, int linelen, char *bound, int blen);
static int multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret);
static int strip_eol(char *linebuf, int *plen);
static MIME_HEADER *mime_hdr_find(STACK_OF(MIME_HEADER) *hdrs, char *name);
static MIME_PARAM *mime_param_find(MIME_HEADER *hdr, char *name);
static void mime_hdr_free(MIME_HEADER *hdr);

#define MAX_SMLEN 1024
#define mime_debug(x) /* x */

/* Base 64 read and write of PKCS#7 structure */

static int B64_write_PKCS7(BIO *bio, PKCS7 *p7)
{
	BIO *b64;
	if(!(b64 = BIO_new(BIO_f_base64()))) {
		PKCS7err(PKCS7_F_B64_WRITE_PKCS7,ERR_R_MALLOC_FAILURE);
		return 0;
a68 7
	bio = BIO_push(b64, bio);
	i2d_PKCS7_bio(bio, p7);
	(void)BIO_flush(bio);
	bio = BIO_pop(bio);
	BIO_free(b64);
	return 1;
}
d70 5
a74 7
static PKCS7 *B64_read_PKCS7(BIO *bio)
{
	BIO *b64;
	PKCS7 *p7;
	if(!(b64 = BIO_new(BIO_f_base64()))) {
		PKCS7err(PKCS7_F_B64_READ_PKCS7,ERR_R_MALLOC_FAILURE);
		return 0;
a75 10
	bio = BIO_push(b64, bio);
	if(!(p7 = d2i_PKCS7_bio(bio, NULL))) 
		PKCS7err(PKCS7_F_B64_READ_PKCS7,PKCS7_R_DECODE_ERROR);
	(void)BIO_flush(bio);
	bio = BIO_pop(bio);
	BIO_free(b64);
	return p7;
}

/* SMIME sender */
d78 5
a82 6
{
	char bound[33], c;
	int i;
	char *mime_prefix, *mime_eol, *msg_type=NULL;
	if (flags & PKCS7_NOOLDMIMETYPE)
		mime_prefix = "application/pkcs7-";
d84 1
a84 1
		mime_prefix = "application/x-pkcs7-";
d86 1
a86 26
	if (flags & PKCS7_CRLFEOL)
		mime_eol = "\r\n";
	else
		mime_eol = "\n";
	if((flags & PKCS7_DETACHED) && data) {
	/* We want multipart/signed */
		/* Generate a random boundary */
		RAND_pseudo_bytes((unsigned char *)bound, 32);
		for(i = 0; i < 32; i++) {
			c = bound[i] & 0xf;
			if(c < 10) c += '0';
			else c += 'A' - 10;
			bound[i] = c;
		}
		bound[32] = 0;
		BIO_printf(bio, "MIME-Version: 1.0%s", mime_eol);
		BIO_printf(bio, "Content-Type: multipart/signed;");
		BIO_printf(bio, " protocol=\"%ssignature\";", mime_prefix);
		BIO_printf(bio, " micalg=sha1; boundary=\"----%s\"%s%s",
						bound, mime_eol, mime_eol);
		BIO_printf(bio, "This is an S/MIME signed message%s%s",
						mime_eol, mime_eol);
		/* Now write out the first part */
		BIO_printf(bio, "------%s%s", bound, mime_eol);
		pkcs7_output_data(bio, data, p7, flags);
		BIO_printf(bio, "%s------%s%s", mime_eol, bound, mime_eol);
a87 1
		/* Headers for signature */
d89 3
a91 11
		BIO_printf(bio, "Content-Type: %ssignature;", mime_prefix); 
		BIO_printf(bio, " name=\"smime.p7s\"%s", mime_eol);
		BIO_printf(bio, "Content-Transfer-Encoding: base64%s",
								mime_eol);
		BIO_printf(bio, "Content-Disposition: attachment;");
		BIO_printf(bio, " filename=\"smime.p7s\"%s%s",
							mime_eol, mime_eol);
		B64_write_PKCS7(bio, p7);
		BIO_printf(bio,"%s------%s--%s%s", mime_eol, bound,
							mime_eol, mime_eol);
		return 1;
a93 76
	/* Determine smime-type header */

	if (PKCS7_type_is_enveloped(p7))
		msg_type = "enveloped-data";
	else if (PKCS7_type_is_signed(p7))
		{
		/* If we have any signers it is signed-data othewise 
		 * certs-only.
		 */
		STACK_OF(PKCS7_SIGNER_INFO) *sinfos;
		sinfos = PKCS7_get_signer_info(p7);
		if (sk_PKCS7_SIGNER_INFO_num(sinfos) > 0)
			msg_type = "signed-data";
		else
			msg_type = "certs-only";
		}
	/* MIME headers */
	BIO_printf(bio, "MIME-Version: 1.0%s", mime_eol);
	BIO_printf(bio, "Content-Disposition: attachment;");
	BIO_printf(bio, " filename=\"smime.p7m\"%s", mime_eol);
	BIO_printf(bio, "Content-Type: %smime;", mime_prefix);
	if (msg_type)
		BIO_printf(bio, " smime-type=%s;", msg_type);
	BIO_printf(bio, " name=\"smime.p7m\"%s", mime_eol);
	BIO_printf(bio, "Content-Transfer-Encoding: base64%s%s",
						mime_eol, mime_eol);
	B64_write_PKCS7(bio, p7);
	BIO_printf(bio, "%s", mime_eol);
	return 1;
}

/* Handle output of PKCS#7 data */


static int pkcs7_output_data(BIO *out, BIO *data, PKCS7 *p7, int flags)
	{
	BIO *tmpbio, *p7bio;

	if (!(flags & PKCS7_STREAM))
		{
		SMIME_crlf_copy(data, out, flags);
		return 1;
		}

	/* Partial sign operation */

	/* Initialize sign operation */
	p7bio = PKCS7_dataInit(p7, out);

	/* Copy data across, computing digests etc */
	SMIME_crlf_copy(data, p7bio, flags);

	/* Must be detached */
	PKCS7_set_detached(p7, 1);

	/* Finalize signatures */
	PKCS7_dataFinal(p7, p7bio);

	/* Now remove any digests prepended to the BIO */

	while (p7bio != out)
		{
		tmpbio = BIO_pop(p7bio);
		BIO_free(p7bio);
		p7bio = tmpbio;
		}

	return 1;

	}

/* SMIME reader: handle multipart/signed and opaque signing.
 * in multipart case the content is placed in a memory BIO
 * pointed to by "bcont". In opaque this is set to NULL
 */

a94 429
{
	BIO *p7in;
	STACK_OF(MIME_HEADER) *headers = NULL;
	STACK_OF(BIO) *parts = NULL;
	MIME_HEADER *hdr;
	MIME_PARAM *prm;
	PKCS7 *p7;
	int ret;

	if(bcont) *bcont = NULL;

	if (!(headers = mime_parse_hdr(bio))) {
		PKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_MIME_PARSE_ERROR);
		return NULL;
	}

	if(!(hdr = mime_hdr_find(headers, "content-type")) || !hdr->value) {
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		PKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_NO_CONTENT_TYPE);
		return NULL;
	}

	/* Handle multipart/signed */

	if(!strcmp(hdr->value, "multipart/signed")) {
		/* Split into two parts */
		prm = mime_param_find(hdr, "boundary");
		if(!prm || !prm->param_value) {
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
			PKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_NO_MULTIPART_BOUNDARY);
			return NULL;
		}
		ret = multi_split(bio, prm->param_value, &parts);
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		if(!ret || (sk_BIO_num(parts) != 2) ) {
			PKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_NO_MULTIPART_BODY_FAILURE);
			sk_BIO_pop_free(parts, BIO_vfree);
			return NULL;
		}

		/* Parse the signature piece */
		p7in = sk_BIO_value(parts, 1);

		if (!(headers = mime_parse_hdr(p7in))) {
			PKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_MIME_SIG_PARSE_ERROR);
			sk_BIO_pop_free(parts, BIO_vfree);
			return NULL;
		}

		/* Get content type */

		if(!(hdr = mime_hdr_find(headers, "content-type")) ||
								 !hdr->value) {
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
			PKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_NO_SIG_CONTENT_TYPE);
			return NULL;
		}

		if(strcmp(hdr->value, "application/x-pkcs7-signature") &&
			strcmp(hdr->value, "application/pkcs7-signature")) {
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
			PKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_SIG_INVALID_MIME_TYPE);
			ERR_add_error_data(2, "type: ", hdr->value);
			sk_BIO_pop_free(parts, BIO_vfree);
			return NULL;
		}
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		/* Read in PKCS#7 */
		if(!(p7 = B64_read_PKCS7(p7in))) {
			PKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_PKCS7_SIG_PARSE_ERROR);
			sk_BIO_pop_free(parts, BIO_vfree);
			return NULL;
		}

		if(bcont) {
			*bcont = sk_BIO_value(parts, 0);
			BIO_free(p7in);
			sk_BIO_free(parts);
		} else sk_BIO_pop_free(parts, BIO_vfree);
		return p7;
	}
		
	/* OK, if not multipart/signed try opaque signature */

	if (strcmp (hdr->value, "application/x-pkcs7-mime") &&
	    strcmp (hdr->value, "application/pkcs7-mime")) {
		PKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_INVALID_MIME_TYPE);
		ERR_add_error_data(2, "type: ", hdr->value);
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		return NULL;
	}

	sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
	
	if(!(p7 = B64_read_PKCS7(bio))) {
		PKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_PKCS7_PARSE_ERROR);
		return NULL;
	}
	return p7;

}

/* Split a multipart/XXX message body into component parts: result is
 * canonical parts in a STACK of bios
 */

static int multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret)
{
	char linebuf[MAX_SMLEN];
	int len, blen;
	int eol = 0, next_eol = 0;
	BIO *bpart = NULL;
	STACK_OF(BIO) *parts;
	char state, part, first;

	blen = strlen(bound);
	part = 0;
	state = 0;
	first = 1;
	parts = sk_BIO_new_null();
	*ret = parts;
	while ((len = BIO_gets(bio, linebuf, MAX_SMLEN)) > 0) {
		state = mime_bound_check(linebuf, len, bound, blen);
		if(state == 1) {
			first = 1;
			part++;
		} else if(state == 2) {
			sk_BIO_push(parts, bpart);
			return 1;
		} else if(part) {
			/* Strip CR+LF from linebuf */
			next_eol = strip_eol(linebuf, &len);
			if(first) {
				first = 0;
				if(bpart) sk_BIO_push(parts, bpart);
				bpart = BIO_new(BIO_s_mem());
				BIO_set_mem_eof_return(bpart, 0);
			} else if (eol)
				BIO_write(bpart, "\r\n", 2);
			eol = next_eol;
			if (len)
				BIO_write(bpart, linebuf, len);
		}
	}
	return 0;
}

/* This is the big one: parse MIME header lines up to message body */

#define MIME_INVALID	0
#define MIME_START	1
#define MIME_TYPE	2
#define MIME_NAME	3
#define MIME_VALUE	4
#define MIME_QUOTE	5
#define MIME_COMMENT	6


static STACK_OF(MIME_HEADER) *mime_parse_hdr(BIO *bio)
{
	char *p, *q, c;
	char *ntmp;
	char linebuf[MAX_SMLEN];
	MIME_HEADER *mhdr = NULL;
	STACK_OF(MIME_HEADER) *headers;
	int len, state, save_state = 0;

	headers = sk_MIME_HEADER_new(mime_hdr_cmp);
	while ((len = BIO_gets(bio, linebuf, MAX_SMLEN)) > 0) {
	/* If whitespace at line start then continuation line */
	if(mhdr && isspace((unsigned char)linebuf[0])) state = MIME_NAME;
	else state = MIME_START;
	ntmp = NULL;
	/* Go through all characters */
	for(p = linebuf, q = linebuf; (c = *p) && (c!='\r') && (c!='\n'); p++) {

	/* State machine to handle MIME headers
	 * if this looks horrible that's because it *is*
         */

		switch(state) {
			case MIME_START:
			if(c == ':') {
				state = MIME_TYPE;
				*p = 0;
				ntmp = strip_ends(q);
				q = p + 1;
			}
			break;

			case MIME_TYPE:
			if(c == ';') {
				mime_debug("Found End Value\n");
				*p = 0;
				mhdr = mime_hdr_new(ntmp, strip_ends(q));
				sk_MIME_HEADER_push(headers, mhdr);
				ntmp = NULL;
				q = p + 1;
				state = MIME_NAME;
			} else if(c == '(') {
				save_state = state;
				state = MIME_COMMENT;
			}
			break;

			case MIME_COMMENT:
			if(c == ')') {
				state = save_state;
			}
			break;

			case MIME_NAME:
			if(c == '=') {
				state = MIME_VALUE;
				*p = 0;
				ntmp = strip_ends(q);
				q = p + 1;
			}
			break ;

			case MIME_VALUE:
			if(c == ';') {
				state = MIME_NAME;
				*p = 0;
				mime_hdr_addparam(mhdr, ntmp, strip_ends(q));
				ntmp = NULL;
				q = p + 1;
			} else if (c == '"') {
				mime_debug("Found Quote\n");
				state = MIME_QUOTE;
			} else if(c == '(') {
				save_state = state;
				state = MIME_COMMENT;
			}
			break;

			case MIME_QUOTE:
			if(c == '"') {
				mime_debug("Found Match Quote\n");
				state = MIME_VALUE;
			}
			break;
		}
	}

	if(state == MIME_TYPE) {
		mhdr = mime_hdr_new(ntmp, strip_ends(q));
		sk_MIME_HEADER_push(headers, mhdr);
	} else if(state == MIME_VALUE)
			 mime_hdr_addparam(mhdr, ntmp, strip_ends(q));
	if(p == linebuf) break;	/* Blank line means end of headers */
}

return headers;

}

static char *strip_ends(char *name)
{
	return strip_end(strip_start(name));
}

/* Strip a parameter of whitespace from start of param */
static char *strip_start(char *name)
{
	char *p, c;
	/* Look for first non white space or quote */
	for(p = name; (c = *p) ;p++) {
		if(c == '"') {
			/* Next char is start of string if non null */
			if(p[1]) return p + 1;
			/* Else null string */
			return NULL;
		}
		if(!isspace((unsigned char)c)) return p;
	}
	return NULL;
}

/* As above but strip from end of string : maybe should handle brackets? */
static char *strip_end(char *name)
{
	char *p, c;
	if(!name) return NULL;
	/* Look for first non white space or quote */
	for(p = name + strlen(name) - 1; p >= name ;p--) {
		c = *p;
		if(c == '"') {
			if(p - 1 == name) return NULL;
			*p = 0;
			return name;
		}
		if(isspace((unsigned char)c)) *p = 0;	
		else return name;
	}
	return NULL;
}

static MIME_HEADER *mime_hdr_new(char *name, char *value)
{
	MIME_HEADER *mhdr;
	char *tmpname, *tmpval, *p;
	int c;
	if(name) {
		if(!(tmpname = BUF_strdup(name))) return NULL;
		for(p = tmpname ; *p; p++) {
			c = *p;
			if(isupper(c)) {
				c = tolower(c);
				*p = c;
			}
		}
	} else tmpname = NULL;
	if(value) {
		if(!(tmpval = BUF_strdup(value))) return NULL;
		for(p = tmpval ; *p; p++) {
			c = *p;
			if(isupper(c)) {
				c = tolower(c);
				*p = c;
			}
		}
	} else tmpval = NULL;
	mhdr = (MIME_HEADER *) OPENSSL_malloc(sizeof(MIME_HEADER));
	if(!mhdr) return NULL;
	mhdr->name = tmpname;
	mhdr->value = tmpval;
	if(!(mhdr->params = sk_MIME_PARAM_new(mime_param_cmp))) return NULL;
	return mhdr;
}
		
static int mime_hdr_addparam(MIME_HEADER *mhdr, char *name, char *value)
{
	char *tmpname, *tmpval, *p;
	int c;
	MIME_PARAM *mparam;
	if(name) {
		tmpname = BUF_strdup(name);
		if(!tmpname) return 0;
		for(p = tmpname ; *p; p++) {
			c = *p;
			if(isupper(c)) {
				c = tolower(c);
				*p = c;
			}
		}
	} else tmpname = NULL;
	if(value) {
		tmpval = BUF_strdup(value);
		if(!tmpval) return 0;
	} else tmpval = NULL;
	/* Parameter values are case sensitive so leave as is */
	mparam = (MIME_PARAM *) OPENSSL_malloc(sizeof(MIME_PARAM));
	if(!mparam) return 0;
	mparam->param_name = tmpname;
	mparam->param_value = tmpval;
	sk_MIME_PARAM_push(mhdr->params, mparam);
	return 1;
}

static int mime_hdr_cmp(const MIME_HEADER * const *a,
			const MIME_HEADER * const *b)
{
	return(strcmp((*a)->name, (*b)->name));
}

static int mime_param_cmp(const MIME_PARAM * const *a,
			const MIME_PARAM * const *b)
{
	return(strcmp((*a)->param_name, (*b)->param_name));
}

/* Find a header with a given name (if possible) */

static MIME_HEADER *mime_hdr_find(STACK_OF(MIME_HEADER) *hdrs, char *name)
{
	MIME_HEADER htmp;
	int idx;
	htmp.name = name;
	idx = sk_MIME_HEADER_find(hdrs, &htmp);
	if(idx < 0) return NULL;
	return sk_MIME_HEADER_value(hdrs, idx);
}

static MIME_PARAM *mime_param_find(MIME_HEADER *hdr, char *name)
{
	MIME_PARAM param;
	int idx;
	param.param_name = name;
	idx = sk_MIME_PARAM_find(hdr->params, &param);
	if(idx < 0) return NULL;
	return sk_MIME_PARAM_value(hdr->params, idx);
}

static void mime_hdr_free(MIME_HEADER *hdr)
{
	if(hdr->name) OPENSSL_free(hdr->name);
	if(hdr->value) OPENSSL_free(hdr->value);
	if(hdr->params) sk_MIME_PARAM_pop_free(hdr->params, mime_param_free);
	OPENSSL_free(hdr);
}

static void mime_param_free(MIME_PARAM *param)
{
	if(param->param_name) OPENSSL_free(param->param_name);
	if(param->param_value) OPENSSL_free(param->param_value);
	OPENSSL_free(param);
}

/* Check for a multipart boundary. Returns:
 * 0 : no boundary
 * 1 : part boundary
 * 2 : final boundary
 */
static int mime_bound_check(char *line, int linelen, char *bound, int blen)
{
	if(linelen == -1) linelen = strlen(line);
	if(blen == -1) blen = strlen(bound);
	/* Quickly eliminate if line length too short */
	if(blen + 2 > linelen) return 0;
	/* Check for part boundary */
	if(!strncmp(line, "--", 2) && !strncmp(line + 2, bound, blen)) {
		if(!strncmp(line + blen + 2, "--", 2)) return 2;
		else return 1;
	}
	return 0;
}

static int strip_eol(char *linebuf, int *plen)
d96 1
a96 14
	int len = *plen;
	char *p, c;
	int is_eol = 0;
	p = linebuf + len - 1;
	for (p = linebuf + len - 1; len > 0; len--, p--)
		{
		c = *p;
		if (c == '\n')
			is_eol = 1;
		else if (c != '\r')
			break;
		}
	*plen = len;
	return is_eol;
@


1.6
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.5
log
@resolve conflicts
@
text
@d3 1
a3 1
 * project 1999.
d89 1
a112 3

typedef void (*stkfree)();

d124 1
a124 1
	BIO_flush(bio);
d141 1
a141 1
	BIO_flush(bio);
d183 1
a183 1
		SMIME_crlf_copy(data, bio, flags);
d197 1
a197 1
						mime_eol, mime_eol);
d232 40
a377 50
}

/* Copy text from one BIO to another making the output CRLF at EOL */
int SMIME_crlf_copy(BIO *in, BIO *out, int flags)
{
	char eol;
	int len;
	char linebuf[MAX_SMLEN];
	if(flags & PKCS7_BINARY) {
		while((len = BIO_read(in, linebuf, MAX_SMLEN)) > 0)
						BIO_write(out, linebuf, len);
		return 1;
	}
	if(flags & PKCS7_TEXT) BIO_printf(out, "Content-Type: text/plain\r\n\r\n");
	while ((len = BIO_gets(in, linebuf, MAX_SMLEN)) > 0) {
		eol = strip_eol(linebuf, &len);
		if (len)
			BIO_write(out, linebuf, len);
		if(eol) BIO_write(out, "\r\n", 2);
	}
	return 1;
}

/* Strip off headers if they are text/plain */
int SMIME_text(BIO *in, BIO *out)
{
	char iobuf[4096];
	int len;
	STACK_OF(MIME_HEADER) *headers;
	MIME_HEADER *hdr;

	if (!(headers = mime_parse_hdr(in))) {
		PKCS7err(PKCS7_F_SMIME_TEXT,PKCS7_R_MIME_PARSE_ERROR);
		return 0;
	}
	if(!(hdr = mime_hdr_find(headers, "content-type")) || !hdr->value) {
		PKCS7err(PKCS7_F_SMIME_TEXT,PKCS7_R_MIME_NO_CONTENT_TYPE);
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		return 0;
	}
	if (strcmp (hdr->value, "text/plain")) {
		PKCS7err(PKCS7_F_SMIME_TEXT,PKCS7_R_INVALID_MIME_TYPE);
		ERR_add_error_data(2, "type: ", hdr->value);
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		return 0;
	}
	sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
	while ((len = BIO_read(in, iobuf, sizeof(iobuf))) > 0)
						BIO_write(out, iobuf, len);
	return 1;
@


1.4
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2003 The OpenSSL Project.  All rights reserved.
d155 1
a155 1
	char *mime_prefix, *mime_eol;
d160 1
d202 17
d224 2
@


1.3
log
@openssl-engine-0.9.6a merge
@
text
@d6 1
a6 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d104 1
a104 1
static int iscrlf(char c);
a152 1
	char linebuf[MAX_SMLEN];
d155 9
d175 1
a175 1
		BIO_printf(bio, "MIME-Version: 1.0\n");
d177 5
a181 3
		BIO_printf(bio, " protocol=\"application/x-pkcs7-signature\";");
		BIO_printf(bio, " micalg=sha1; boundary=\"----%s\"\n\n", bound);
		BIO_printf(bio, "This is an S/MIME signed message\n\n");
d183 3
a185 5
		BIO_printf(bio, "------%s\n", bound);
		if(flags & PKCS7_TEXT) BIO_printf(bio, "Content-Type: text/plain\n\n");
		while((i = BIO_read(data, linebuf, MAX_SMLEN)) > 0) 
						BIO_write(bio, linebuf, i);
		BIO_printf(bio, "\n------%s\n", bound);
d189 7
a195 3
		BIO_printf(bio, "Content-Type: application/x-pkcs7-signature; name=\"smime.p7s\"\n");
		BIO_printf(bio, "Content-Transfer-Encoding: base64\n");
		BIO_printf(bio, "Content-Disposition: attachment; filename=\"smime.p7s\"\n\n");
d197 2
a198 1
		BIO_printf(bio,"\n------%s--\n\n", bound);
d202 7
a208 4
	BIO_printf(bio, "MIME-Version: 1.0\n");
	BIO_printf(bio, "Content-Disposition: attachment; filename=\"smime.p7m\"\n");
	BIO_printf(bio, "Content-Type: application/x-pkcs7-mime; name=\"smime.p7m\"\n");
	BIO_printf(bio, "Content-Transfer-Encoding: base64\n\n");
d210 1
a210 1
	BIO_printf(bio, "\n");
d335 3
a337 6
		eol = 0;
		while(iscrlf(linebuf[len - 1])) {
			len--;
			eol = 1;
		}	
		BIO_write(out, linebuf, len);
d380 1
d400 2
d406 6
a411 5
				
			} else BIO_write(bpart, "\r\n", 2);
			/* Strip CR+LF from linebuf */
			while(iscrlf(linebuf[len - 1])) len--;
			BIO_write(bpart, linebuf, len);
a416 6
static int iscrlf(char c)
{
	if(c == '\r' || c == '\n') return 1;
	return 0;
}

d697 18
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d168 3
a170 3
		BIO_printf(bio, "Content-Type: multipart/signed ; ");
		BIO_printf(bio, "protocol=\"application/x-pkcs7-signature\" ; ");
		BIO_printf(bio, "micalg=sha1 ; boundary=\"----%s\"\n\n", bound);
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d73 8
d83 1
a83 1
STACK /* MIME_PARAM */ *params;		/* Zero or more parameters */
d86 2
a87 5
typedef struct {
char *param_name;			/* Param name e.g. "micalg" */
char *param_value;			/* Param value e.g. "sha1" */
} MIME_PARAM;

d96 5
a100 3
static STACK *mime_parse_hdr(BIO *bio);
static int mime_hdr_cmp(MIME_HEADER **a, MIME_HEADER **b);
static int mime_param_cmp(MIME_PARAM **a, MIME_PARAM **b);
d103 1
a103 1
static int multi_split(BIO *bio, char *bound, STACK **ret);
d105 1
a105 1
static MIME_HEADER *mime_hdr_find(STACK *hdrs, char *name);
d173 1
a173 1
		BIO_printf(bio, "------%s\r\n", bound);
d206 2
a207 2
	STACK *headers = NULL;
	STACK *parts = NULL;
d221 1
a221 1
		sk_pop_free(headers, mime_hdr_free);
d232 1
a232 1
			sk_pop_free(headers, mime_hdr_free);
d237 2
a238 2
		sk_pop_free(headers, mime_hdr_free);
		if(!ret || (sk_num(parts) != 2) ) {
d240 1
a240 1
			sk_pop_free(parts, (stkfree)BIO_free);
d245 1
a245 1
		p7in = (BIO *)sk_value(parts, 1);
d249 1
a249 1
			sk_pop_free(parts, (stkfree)BIO_free);
d257 1
a257 1
			sk_pop_free(headers, mime_hdr_free);
d264 1
a264 1
			sk_pop_free(headers, mime_hdr_free);
d267 1
a267 1
			sk_pop_free(parts, (stkfree)BIO_free);
d270 1
a270 1
		sk_pop_free(headers, mime_hdr_free);
d274 1
a274 1
			sk_pop_free(parts, (stkfree)BIO_free);
d279 1
a279 1
			*bcont = (BIO *)sk_value(parts, 0);
d281 2
a282 2
			sk_free(parts);
		} else sk_pop_free(parts, (stkfree)BIO_free);
d292 1
a292 1
		sk_pop_free(headers, mime_hdr_free);
d296 1
a296 1
	sk_pop_free(headers, mime_hdr_free);
d335 1
a335 1
	STACK *headers;
d337 1
d344 1
a344 1
		sk_pop_free(headers, mime_hdr_free);
d350 1
a350 1
		sk_pop_free(headers, mime_hdr_free);
d353 1
a353 1
	sk_pop_free(headers, mime_hdr_free);
d363 1
a363 1
static int multi_split(BIO *bio, char *bound, STACK **ret)
d368 1
a368 1
	STACK *parts;
d370 1
d375 1
a375 1
	parts = sk_new(NULL);
d383 1
a383 1
			sk_push(parts, (char *)bpart);
d388 1
a388 1
				if(bpart) sk_push(parts, (char *)bpart);
d417 1
a417 1
static STACK *mime_parse_hdr(BIO *bio)
d423 1
a423 1
	STACK *headers;
d425 2
a426 1
	headers = sk_new(mime_hdr_cmp);
d454 1
a454 1
				sk_push(headers, (char *)mhdr);
d506 1
a506 1
		sk_push(headers, (char *)mhdr);
d582 1
a582 1
	mhdr = (MIME_HEADER *) Malloc(sizeof(MIME_HEADER));
d586 1
a586 1
	if(!(mhdr->params = sk_new(mime_param_cmp))) return NULL;
d611 1
a611 1
	mparam = (MIME_PARAM *) Malloc(sizeof(MIME_PARAM));
d615 1
a615 1
	sk_push(mhdr->params, (char *)mparam);
d619 2
a620 1
static int mime_hdr_cmp(MIME_HEADER **a, MIME_HEADER **b)
d625 2
a626 1
static int mime_param_cmp(MIME_PARAM **a, MIME_PARAM **b)
d633 1
a633 1
static MIME_HEADER *mime_hdr_find(STACK *hdrs, char *name)
d638 1
a638 1
	idx = sk_find(hdrs, (char *)&htmp);
d640 1
a640 1
	return (MIME_HEADER *)sk_value(hdrs, idx);
d648 1
a648 1
	idx = sk_find(hdr->params, (char *)&param);
d650 1
a650 1
	return (MIME_PARAM *)sk_value(hdr->params, idx);
d655 4
a658 4
	if(hdr->name) Free(hdr->name);
	if(hdr->value) Free(hdr->value);
	if(hdr->params) sk_pop_free(hdr->params, mime_param_free);
	Free(hdr);
d663 3
a665 3
	if(param->param_name) Free(param->param_name);
	if(param->param_value) Free(param->param_value);
	Free(param);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d73 6
a82 11
DECLARE_STACK_OF(MIME_PARAM)
IMPLEMENT_STACK_OF(MIME_PARAM)

typedef struct {
char *name;				/* Name of line e.g. "content-type" */
char *value;				/* Value of line e.g. "text/plain" */
STACK_OF(MIME_PARAM) *params;		/* Zero or more parameters */
} MIME_HEADER;

DECLARE_STACK_OF(MIME_HEADER)
IMPLEMENT_STACK_OF(MIME_HEADER)
d91 3
a93 5
static STACK_OF(MIME_HEADER) *mime_parse_hdr(BIO *bio);
static int mime_hdr_cmp(const MIME_HEADER * const *a,
			const MIME_HEADER * const *b);
static int mime_param_cmp(const MIME_PARAM * const *a,
			const MIME_PARAM * const *b);
d96 1
a96 1
static int multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret);
d98 1
a98 1
static MIME_HEADER *mime_hdr_find(STACK_OF(MIME_HEADER) *hdrs, char *name);
d161 3
a163 3
		BIO_printf(bio, "Content-Type: multipart/signed;");
		BIO_printf(bio, " protocol=\"application/x-pkcs7-signature\";");
		BIO_printf(bio, " micalg=sha1; boundary=\"----%s\"\n\n", bound);
d166 1
a166 1
		BIO_printf(bio, "------%s\n", bound);
d199 2
a200 2
	STACK_OF(MIME_HEADER) *headers = NULL;
	STACK_OF(BIO) *parts = NULL;
d214 1
a214 1
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d225 1
a225 1
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d230 2
a231 2
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
		if(!ret || (sk_BIO_num(parts) != 2) ) {
d233 1
a233 1
			sk_BIO_pop_free(parts, BIO_vfree);
d238 1
a238 1
		p7in = sk_BIO_value(parts, 1);
d242 1
a242 1
			sk_BIO_pop_free(parts, BIO_vfree);
d250 1
a250 1
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d257 1
a257 1
			sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d260 1
a260 1
			sk_BIO_pop_free(parts, BIO_vfree);
d263 1
a263 1
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d267 1
a267 1
			sk_BIO_pop_free(parts, BIO_vfree);
d272 1
a272 1
			*bcont = sk_BIO_value(parts, 0);
d274 2
a275 2
			sk_BIO_free(parts);
		} else sk_BIO_pop_free(parts, BIO_vfree);
d285 1
a285 1
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d289 1
a289 1
	sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d328 1
a328 1
	STACK_OF(MIME_HEADER) *headers;
a329 1

d336 1
a336 1
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d342 1
a342 1
		sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d345 1
a345 1
	sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
d355 1
a355 1
static int multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret)
d360 1
a360 1
	STACK_OF(BIO) *parts;
a361 1

d366 1
a366 1
	parts = sk_BIO_new_null();
d374 1
a374 1
			sk_BIO_push(parts, bpart);
d379 1
a379 1
				if(bpart) sk_BIO_push(parts, bpart);
d408 1
a408 1
static STACK_OF(MIME_HEADER) *mime_parse_hdr(BIO *bio)
d414 1
a414 1
	STACK_OF(MIME_HEADER) *headers;
d416 1
a416 2

	headers = sk_MIME_HEADER_new(mime_hdr_cmp);
d444 1
a444 1
				sk_MIME_HEADER_push(headers, mhdr);
d496 1
a496 1
		sk_MIME_HEADER_push(headers, mhdr);
d572 1
a572 1
	mhdr = (MIME_HEADER *) OPENSSL_malloc(sizeof(MIME_HEADER));
d576 1
a576 1
	if(!(mhdr->params = sk_MIME_PARAM_new(mime_param_cmp))) return NULL;
d601 1
a601 1
	mparam = (MIME_PARAM *) OPENSSL_malloc(sizeof(MIME_PARAM));
d605 1
a605 1
	sk_MIME_PARAM_push(mhdr->params, mparam);
d609 1
a609 2
static int mime_hdr_cmp(const MIME_HEADER * const *a,
			const MIME_HEADER * const *b)
d614 1
a614 2
static int mime_param_cmp(const MIME_PARAM * const *a,
			const MIME_PARAM * const *b)
d621 1
a621 1
static MIME_HEADER *mime_hdr_find(STACK_OF(MIME_HEADER) *hdrs, char *name)
d626 1
a626 1
	idx = sk_MIME_HEADER_find(hdrs, &htmp);
d628 1
a628 1
	return sk_MIME_HEADER_value(hdrs, idx);
d636 1
a636 1
	idx = sk_MIME_PARAM_find(hdr->params, &param);
d638 1
a638 1
	return sk_MIME_PARAM_value(hdr->params, idx);
d643 4
a646 4
	if(hdr->name) OPENSSL_free(hdr->name);
	if(hdr->value) OPENSSL_free(hdr->value);
	if(hdr->params) sk_MIME_PARAM_pop_free(hdr->params, mime_param_free);
	OPENSSL_free(hdr);
d651 3
a653 3
	if(param->param_name) OPENSSL_free(param->param_name);
	if(param->param_value) OPENSSL_free(param->param_value);
	OPENSSL_free(param);
@


1.1.1.2
log
@import 0.9.7c
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2003 The OpenSSL Project.  All rights reserved.
d104 1
a104 1
static int strip_eol(char *linebuf, int *plen);
d153 1
a155 9
	char *mime_prefix, *mime_eol;
	if (flags & PKCS7_NOOLDMIMETYPE)
		mime_prefix = "application/pkcs7-";
	else
		mime_prefix = "application/x-pkcs7-";
	if (flags & PKCS7_CRLFEOL)
		mime_eol = "\r\n";
	else
		mime_eol = "\n";
d167 1
a167 1
		BIO_printf(bio, "MIME-Version: 1.0%s", mime_eol);
d169 3
a171 5
		BIO_printf(bio, " protocol=\"%ssignature\";", mime_prefix);
		BIO_printf(bio, " micalg=sha1; boundary=\"----%s\"%s%s",
						bound, mime_eol, mime_eol);
		BIO_printf(bio, "This is an S/MIME signed message%s%s",
						mime_eol, mime_eol);
d173 5
a177 3
		BIO_printf(bio, "------%s%s", bound, mime_eol);
		SMIME_crlf_copy(data, bio, flags);
		BIO_printf(bio, "%s------%s%s", mime_eol, bound, mime_eol);
d181 3
a183 7
		BIO_printf(bio, "Content-Type: %ssignature;", mime_prefix); 
		BIO_printf(bio, " name=\"smime.p7s\"%s", mime_eol);
		BIO_printf(bio, "Content-Transfer-Encoding: base64%s",
								mime_eol);
		BIO_printf(bio, "Content-Disposition: attachment;");
		BIO_printf(bio, " filename=\"smime.p7s\"%s%s",
							mime_eol, mime_eol);
d185 1
a185 2
		BIO_printf(bio,"%s------%s--%s%s", mime_eol, bound,
						mime_eol, mime_eol);
d189 4
a192 7
	BIO_printf(bio, "MIME-Version: 1.0%s", mime_eol);
	BIO_printf(bio, "Content-Disposition: attachment;");
	BIO_printf(bio, " filename=\"smime.p7m\"%s", mime_eol);
	BIO_printf(bio, "Content-Type: %smime;", mime_prefix);
	BIO_printf(bio, " name=\"smime.p7m\"%s", mime_eol);
	BIO_printf(bio, "Content-Transfer-Encoding: base64%s%s",
						mime_eol, mime_eol);
d194 1
a194 1
	BIO_printf(bio, "%s", mime_eol);
d319 6
a324 3
		eol = strip_eol(linebuf, &len);
		if (len)
			BIO_write(out, linebuf, len);
a366 1
	int eol = 0, next_eol = 0;
a385 2
			/* Strip CR+LF from linebuf */
			next_eol = strip_eol(linebuf, &len);
d390 5
a394 6
				BIO_set_mem_eof_return(bpart, 0);
			} else if (eol)
				BIO_write(bpart, "\r\n", 2);
			eol = next_eol;
			if (len)
				BIO_write(bpart, linebuf, len);
d400 6
a685 18

static int strip_eol(char *linebuf, int *plen)
	{
	int len = *plen;
	char *p, c;
	int is_eol = 0;
	p = linebuf + len - 1;
	for (p = linebuf + len - 1; len > 0; len--, p--)
		{
		c = *p;
		if (c == '\n')
			is_eol = 1;
		else if (c != '\r')
			break;
		}
	*plen = len;
	return is_eol;
	}
@


1.1.1.3
log
@import of openssl-0.9.7j
@
text
@d6 1
a6 1
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
d155 1
a155 1
	char *mime_prefix, *mime_eol, *msg_type=NULL;
a159 1

a200 17

	/* Determine smime-type header */

	if (PKCS7_type_is_enveloped(p7))
		msg_type = "enveloped-data";
	else if (PKCS7_type_is_signed(p7))
		{
		/* If we have any signers it is signed-data othewise 
		 * certs-only.
		 */
		STACK_OF(PKCS7_SIGNER_INFO) *sinfos;
		sinfos = PKCS7_get_signer_info(p7);
		if (sk_PKCS7_SIGNER_INFO_num(sinfos) > 0)
			msg_type = "signed-data";
		else
			msg_type = "certs-only";
		}
a205 2
	if (msg_type)
		BIO_printf(bio, " smime-type=%s;", msg_type);
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d3 1
a3 1
 * project.
a88 1
static int pkcs7_output_data(BIO *bio, BIO *data, PKCS7 *p7, int flags);
d112 3
d126 1
a126 1
	(void)BIO_flush(bio);
d143 1
a143 1
	(void)BIO_flush(bio);
d185 1
a185 1
		pkcs7_output_data(bio, data, p7, flags);
d199 1
a199 1
							mime_eol, mime_eol);
a233 40
/* Handle output of PKCS#7 data */


static int pkcs7_output_data(BIO *out, BIO *data, PKCS7 *p7, int flags)
	{
	BIO *tmpbio, *p7bio;

	if (!(flags & PKCS7_STREAM))
		{
		SMIME_crlf_copy(data, out, flags);
		return 1;
		}

	/* Partial sign operation */

	/* Initialize sign operation */
	p7bio = PKCS7_dataInit(p7, out);

	/* Copy data across, computing digests etc */
	SMIME_crlf_copy(data, p7bio, flags);

	/* Must be detached */
	PKCS7_set_detached(p7, 1);

	/* Finalize signatures */
	PKCS7_dataFinal(p7, p7bio);

	/* Now remove any digests prepended to the BIO */

	while (p7bio != out)
		{
		tmpbio = BIO_pop(p7bio);
		BIO_free(p7bio);
		p7bio = tmpbio;
		}

	return 1;

	}

d340 50
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d53 4
a63 1
#include <openssl/asn1.h>
d65 1
a65 1
/* PKCS#7 wrappers round generalised stream and MIME routines */
d67 54
a120 4
int i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)
	{
	return i2d_ASN1_bio_stream(out, (ASN1_VALUE *)p7, in, flags,
					ASN1_ITEM_rptr(PKCS7));
d122 7
d130 7
a136 5
int PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)
	{
	return PEM_write_bio_ASN1_stream(out, (ASN1_VALUE *) p7, in, flags,
						"PKCS7",
						ASN1_ITEM_rptr(PKCS7));
d138 10
d150 86
d237 23
a259 6
	STACK_OF(X509_ALGOR) *mdalgs;
	int ctype_nid = OBJ_obj2nid(p7->type);
	if (ctype_nid == NID_pkcs7_signed)
		mdalgs = p7->d.sign->md_algs;
	else
		mdalgs = NULL;
d261 6
a266 1
	flags ^= SMIME_OLDMIME;
d268 1
a269 3
	return SMIME_write_ASN1(bio, (ASN1_VALUE *)p7, data, flags,
					ctype_nid, NID_undef, mdalgs,
					ASN1_ITEM_rptr(PKCS7));	
d272 5
d278 429
d708 14
a721 1
	return (PKCS7 *)SMIME_read_ASN1(bio, bcont, ASN1_ITEM_rptr(PKCS7));
@


