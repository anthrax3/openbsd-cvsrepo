head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.2
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19;
locks; strict;
comment	@ * @;


1.19
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.18;
commitid	kT0fLt3r4lroFJra;

1.18
date	2015.09.30.18.41.06;	author jsing;	state Exp;
branches;
next	1.17;
commitid	8UbnRNonXjerilzx;

1.17
date	2015.09.30.17.30.15;	author jsing;	state Exp;
branches;
next	1.16;
commitid	f3YLBhwPPENmVqqA;

1.16
date	2015.07.29.14.58.34;	author jsing;	state Exp;
branches;
next	1.15;
commitid	rYgS8cWcS59JYkBV;

1.15
date	2015.03.19.14.00.22;	author tedu;	state Exp;
branches;
next	1.14;
commitid	Ix1rLPv61p1TR5LF;

1.14
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;
commitid	G74O1dmRukKsW7IJ;

1.13
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.12;
commitid	yQEL1wOWIearrW15;

1.12
date	2014.07.08.09.08.27;	author jsing;	state Exp;
branches;
next	1.11;
commitid	9Rg6xohK2oZS7QVf;

1.11
date	2014.06.29.17.05.36;	author jsing;	state Exp;
branches;
next	1.10;
commitid	t0SFeQtZd9bpT5Df;

1.10
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	mJUVYpkFBZ0Zv2bG;

1.9
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.29.05.39.24;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.11.09;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.31;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.46;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.12.20.48.57;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.04.29.05.37.14;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2011.11.03.02.32.13;	author djm;	state Exp;
branches;
next	;

1.14.4.1
date	2015.03.19.14.02.22;	author tedu;	state Exp;
branches;
next	;
commitid	bYTbbXa7PWk8y7To;

1.14.6.1
date	2015.03.19.14.01.16;	author tedu;	state Exp;
branches;
next	;
commitid	dQgHc1qjfDF6g1rY;


desc
@@


1.19
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: pk7_lib.c,v 1.18 2015/09/30 18:41:06 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>

#include <openssl/err.h>
#include <openssl/objects.h>
#include <openssl/x509.h>

#include "asn1_locl.h"

long
PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg)
{
	int nid;
	long ret;

	nid = OBJ_obj2nid(p7->type);

	switch (cmd) {
	case PKCS7_OP_SET_DETACHED_SIGNATURE:
		if (nid == NID_pkcs7_signed) {
			ret = p7->detached = (int)larg;
			if (ret && PKCS7_type_is_data(p7->d.sign->contents)) {
				ASN1_OCTET_STRING *os;
				os = p7->d.sign->contents->d.data;
				ASN1_OCTET_STRING_free(os);
				p7->d.sign->contents->d.data = NULL;
			}
		} else {
			PKCS7error(PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
			ret = 0;
		}
		break;
	case PKCS7_OP_GET_DETACHED_SIGNATURE:
		if (nid == NID_pkcs7_signed) {
			if (!p7->d.sign  || !p7->d.sign->contents->d.ptr)
				ret = 1;
			else
				ret = 0;

			p7->detached = ret;
		} else {
			PKCS7error(PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
			ret = 0;
		}

		break;
	default:
		PKCS7error(PKCS7_R_UNKNOWN_OPERATION);
		ret = 0;
	}
	return (ret);
}

int
PKCS7_content_new(PKCS7 *p7, int type)
{
	PKCS7 *ret = NULL;

	if ((ret = PKCS7_new()) == NULL)
		goto err;
	if (!PKCS7_set_type(ret, type))
		goto err;
	if (!PKCS7_set_content(p7, ret))
		goto err;

	return (1);
err:
	if (ret != NULL)
		PKCS7_free(ret);
	return (0);
}

int
PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data)
{
	int i;

	i = OBJ_obj2nid(p7->type);
	switch (i) {
	case NID_pkcs7_signed:
		if (p7->d.sign->contents != NULL)
			PKCS7_free(p7->d.sign->contents);
		p7->d.sign->contents = p7_data;
		break;
	case NID_pkcs7_digest:
		if (p7->d.digest->contents != NULL)
			PKCS7_free(p7->d.digest->contents);
		p7->d.digest->contents = p7_data;
		break;
	case NID_pkcs7_data:
	case NID_pkcs7_enveloped:
	case NID_pkcs7_signedAndEnveloped:
	case NID_pkcs7_encrypted:
	default:
		PKCS7error(PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
		goto err;
	}
	return (1);
err:
	return (0);
}

int
PKCS7_set_type(PKCS7 *p7, int type)
{
	ASN1_OBJECT *obj;

	/*PKCS7_content_free(p7);*/
	obj=OBJ_nid2obj(type); /* will not fail */

	switch (type) {
	case NID_pkcs7_signed:
		p7->type = obj;
		if ((p7->d.sign = PKCS7_SIGNED_new()) == NULL)
			goto err;
		if (!ASN1_INTEGER_set(p7->d.sign->version, 1)) {
			PKCS7_SIGNED_free(p7->d.sign);
			p7->d.sign = NULL;
			goto err;
		}
		break;
	case NID_pkcs7_data:
		p7->type = obj;
		if ((p7->d.data = ASN1_OCTET_STRING_new()) == NULL)
			goto err;
		break;
	case NID_pkcs7_signedAndEnveloped:
		p7->type = obj;
		if ((p7->d.signed_and_enveloped =
		    PKCS7_SIGN_ENVELOPE_new()) == NULL)
			goto err;
		ASN1_INTEGER_set(p7->d.signed_and_enveloped->version, 1);
		if (!ASN1_INTEGER_set(p7->d.signed_and_enveloped->version, 1))
			goto err;
		p7->d.signed_and_enveloped->enc_data->content_type =
		    OBJ_nid2obj(NID_pkcs7_data);
		break;
	case NID_pkcs7_enveloped:
		p7->type = obj;
		if ((p7->d.enveloped = PKCS7_ENVELOPE_new()) == NULL)
			goto err;
		if (!ASN1_INTEGER_set(p7->d.enveloped->version, 0))
			goto err;
		p7->d.enveloped->enc_data->content_type =
		    OBJ_nid2obj(NID_pkcs7_data);
		break;
	case NID_pkcs7_encrypted:
		p7->type = obj;
		if ((p7->d.encrypted = PKCS7_ENCRYPT_new()) == NULL)
			goto err;
		if (!ASN1_INTEGER_set(p7->d.encrypted->version, 0))
			goto err;
		p7->d.encrypted->enc_data->content_type =
		    OBJ_nid2obj(NID_pkcs7_data);
		break;

	case NID_pkcs7_digest:
		p7->type = obj;
		if ((p7->d.digest = PKCS7_DIGEST_new()) == NULL)
			goto err;
		if (!ASN1_INTEGER_set(p7->d.digest->version, 0))
			goto err;
		break;
	default:
		PKCS7error(PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
		goto err;
	}
	return (1);
err:
	return (0);
}

int
PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other)
{
	p7->type = OBJ_nid2obj(type);
	p7->d.other = other;
	return 1;
}

int
PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *psi)
{
	int i, j, nid;
	X509_ALGOR *alg;
	STACK_OF(PKCS7_SIGNER_INFO) *signer_sk;
	STACK_OF(X509_ALGOR) *md_sk;

	i = OBJ_obj2nid(p7->type);
	switch (i) {
	case NID_pkcs7_signed:
		signer_sk = p7->d.sign->signer_info;
		md_sk = p7->d.sign->md_algs;
		break;
	case NID_pkcs7_signedAndEnveloped:
		signer_sk = p7->d.signed_and_enveloped->signer_info;
		md_sk = p7->d.signed_and_enveloped->md_algs;
		break;
	default:
		PKCS7error(PKCS7_R_WRONG_CONTENT_TYPE);
		return (0);
	}

	nid = OBJ_obj2nid(psi->digest_alg->algorithm);

	/* If the digest is not currently listed, add it */
	j = 0;
	for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {
		alg = sk_X509_ALGOR_value(md_sk, i);
		if (OBJ_obj2nid(alg->algorithm) == nid) {
			j = 1;
			break;
		}
	}
	if (!j) /* we need to add another algorithm */
	{
		if (!(alg = X509_ALGOR_new()) ||
		    !(alg->parameter = ASN1_TYPE_new())) {
			X509_ALGOR_free(alg);
			PKCS7error(ERR_R_MALLOC_FAILURE);
			return (0);
		}
		alg->algorithm = OBJ_nid2obj(nid);
		alg->parameter->type = V_ASN1_NULL;
		if (!sk_X509_ALGOR_push(md_sk, alg)) {
			X509_ALGOR_free(alg);
			return 0;
		}
	}

	if (!sk_PKCS7_SIGNER_INFO_push(signer_sk, psi))
		return 0;
	return (1);
}

int
PKCS7_add_certificate(PKCS7 *p7, X509 *x509)
{
	int i;
	STACK_OF(X509) **sk;

	i = OBJ_obj2nid(p7->type);
	switch (i) {
	case NID_pkcs7_signed:
		sk = &(p7->d.sign->cert);
		break;
	case NID_pkcs7_signedAndEnveloped:
		sk = &(p7->d.signed_and_enveloped->cert);
		break;
	default:
		PKCS7error(PKCS7_R_WRONG_CONTENT_TYPE);
		return (0);
	}

	if (*sk == NULL)
		*sk = sk_X509_new_null();
	if (*sk == NULL) {
		PKCS7error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	CRYPTO_add(&x509->references, 1, CRYPTO_LOCK_X509);
	if (!sk_X509_push(*sk, x509)) {
		X509_free(x509);
		return 0;
	}
	return (1);
}

int
PKCS7_add_crl(PKCS7 *p7, X509_CRL *crl)
{
	int i;
	STACK_OF(X509_CRL) **sk;

	i = OBJ_obj2nid(p7->type);
	switch (i) {
	case NID_pkcs7_signed:
		sk = &(p7->d.sign->crl);
		break;
	case NID_pkcs7_signedAndEnveloped:
		sk = &(p7->d.signed_and_enveloped->crl);
		break;
	default:
		PKCS7error(PKCS7_R_WRONG_CONTENT_TYPE);
		return (0);
	}

	if (*sk == NULL)
		*sk = sk_X509_CRL_new_null();
	if (*sk == NULL) {
		PKCS7error(ERR_R_MALLOC_FAILURE);
		return 0;
	}

	CRYPTO_add(&crl->references, 1, CRYPTO_LOCK_X509_CRL);
	if (!sk_X509_CRL_push(*sk, crl)) {
		X509_CRL_free(crl);
		return 0;
	}
	return (1);
}

int
PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,
    const EVP_MD *dgst)
{
	int ret;

	/* We now need to add another PKCS7_SIGNER_INFO entry */
	if (!ASN1_INTEGER_set(p7i->version, 1))
		goto err;
	if (!X509_NAME_set(&p7i->issuer_and_serial->issuer,
	    X509_get_issuer_name(x509)))
		goto err;

	/* because ASN1_INTEGER_set is used to set a 'long' we will do
	 * things the ugly way. */
	ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
	if (!(p7i->issuer_and_serial->serial =
	    ASN1_STRING_dup(X509_get_serialNumber(x509))))
		goto err;

	/* lets keep the pkey around for a while */
	CRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);
	p7i->pkey = pkey;

	/* Set the algorithms */

	X509_ALGOR_set0(p7i->digest_alg, OBJ_nid2obj(EVP_MD_type(dgst)),
	    V_ASN1_NULL, NULL);

	if (pkey->ameth && pkey->ameth->pkey_ctrl) {
		ret = pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_PKCS7_SIGN,
		    0, p7i);
		if (ret > 0)
			return 1;
		if (ret != -2) {
			PKCS7error(PKCS7_R_SIGNING_CTRL_FAILURE);
			return 0;
		}
	}
	PKCS7error(PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
err:
	return 0;
}

PKCS7_SIGNER_INFO *
PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey, const EVP_MD *dgst)
{
	PKCS7_SIGNER_INFO *si = NULL;

	if (dgst == NULL) {
		int def_nid;
		if (EVP_PKEY_get_default_digest_nid(pkey, &def_nid) <= 0)
			goto err;
		dgst = EVP_get_digestbynid(def_nid);
		if (dgst == NULL) {
			PKCS7error(PKCS7_R_NO_DEFAULT_DIGEST);
			goto err;
		}
	}

	if ((si = PKCS7_SIGNER_INFO_new()) == NULL)
		goto err;
	if (!PKCS7_SIGNER_INFO_set(si, x509, pkey, dgst))
		goto err;
	if (!PKCS7_add_signer(p7, si))
		goto err;
	return (si);
err:
	if (si)
		PKCS7_SIGNER_INFO_free(si);
	return (NULL);
}

int
PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md)
{
	if (PKCS7_type_is_digest(p7)) {
		if (!(p7->d.digest->md->parameter = ASN1_TYPE_new())) {
			PKCS7error(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		p7->d.digest->md->parameter->type = V_ASN1_NULL;
		p7->d.digest->md->algorithm = OBJ_nid2obj(EVP_MD_nid(md));
		return 1;
	}

	PKCS7error(PKCS7_R_WRONG_CONTENT_TYPE);
	return 1;
}

STACK_OF(PKCS7_SIGNER_INFO) *
PKCS7_get_signer_info(PKCS7 *p7)
{
	if (p7 == NULL || p7->d.ptr == NULL)
		return (NULL);
	if (PKCS7_type_is_signed(p7)) {
		return (p7->d.sign->signer_info);
	} else if (PKCS7_type_is_signedAndEnveloped(p7)) {
		return (p7->d.signed_and_enveloped->signer_info);
	} else
		return (NULL);
}

void
PKCS7_SIGNER_INFO_get0_algs(PKCS7_SIGNER_INFO *si, EVP_PKEY **pk,
    X509_ALGOR **pdig, X509_ALGOR **psig)
{
	if (pk)
		*pk = si->pkey;
	if (pdig)
		*pdig = si->digest_alg;
	if (psig)
		*psig = si->digest_enc_alg;
}

void
PKCS7_RECIP_INFO_get0_alg(PKCS7_RECIP_INFO *ri, X509_ALGOR **penc)
{
	if (penc)
		*penc = ri->key_enc_algor;
}

PKCS7_RECIP_INFO *
PKCS7_add_recipient(PKCS7 *p7, X509 *x509)
{
	PKCS7_RECIP_INFO *ri;

	if ((ri = PKCS7_RECIP_INFO_new()) == NULL)
		goto err;
	if (!PKCS7_RECIP_INFO_set(ri, x509))
		goto err;
	if (!PKCS7_add_recipient_info(p7, ri))
		goto err;
	return ri;
err:
	if (ri)
		PKCS7_RECIP_INFO_free(ri);
	return NULL;
}

int
PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri)
{
	int i;
	STACK_OF(PKCS7_RECIP_INFO) *sk;

	i = OBJ_obj2nid(p7->type);
	switch (i) {
	case NID_pkcs7_signedAndEnveloped:
		sk = p7->d.signed_and_enveloped->recipientinfo;
		break;
	case NID_pkcs7_enveloped:
		sk = p7->d.enveloped->recipientinfo;
		break;
	default:
		PKCS7error(PKCS7_R_WRONG_CONTENT_TYPE);
		return (0);
	}

	if (!sk_PKCS7_RECIP_INFO_push(sk, ri))
		return 0;
	return (1);
}

int
PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)
{
	int ret;
	EVP_PKEY *pkey = NULL;
	if (!ASN1_INTEGER_set(p7i->version, 0))
		return 0;
	if (!X509_NAME_set(&p7i->issuer_and_serial->issuer,
	    X509_get_issuer_name(x509)))
		return 0;

	ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
	if (!(p7i->issuer_and_serial->serial =
	    ASN1_STRING_dup(X509_get_serialNumber(x509))))
		return 0;

	pkey = X509_get_pubkey(x509);

	if (!pkey || !pkey->ameth || !pkey->ameth->pkey_ctrl) {
		PKCS7error(PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
		goto err;
	}

	ret = pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_PKCS7_ENCRYPT,
	    0, p7i);
	if (ret == -2) {
		PKCS7error(PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
		goto err;
	}
	if (ret <= 0) {
		PKCS7error(PKCS7_R_ENCRYPTION_CTRL_FAILURE);
		goto err;
	}

	EVP_PKEY_free(pkey);

	CRYPTO_add(&x509->references, 1, CRYPTO_LOCK_X509);
	p7i->cert = x509;

	return 1;

err:
	EVP_PKEY_free(pkey);
	return 0;
}

X509 *
PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si)
{
	if (PKCS7_type_is_signed(p7))
		return(X509_find_by_issuer_and_serial(p7->d.sign->cert,
		    si->issuer_and_serial->issuer,
		    si->issuer_and_serial->serial));
	else
		return (NULL);
}

int
PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)
{
	int i;
	PKCS7_ENC_CONTENT *ec;

	i = OBJ_obj2nid(p7->type);
	switch (i) {
	case NID_pkcs7_signedAndEnveloped:
		ec = p7->d.signed_and_enveloped->enc_data;
		break;
	case NID_pkcs7_enveloped:
		ec = p7->d.enveloped->enc_data;
		break;
	default:
		PKCS7error(PKCS7_R_WRONG_CONTENT_TYPE);
		return (0);
	}

	/* Check cipher OID exists and has data in it*/
	i = EVP_CIPHER_type(cipher);
	if (i == NID_undef) {
		PKCS7error(PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
		return (0);
	}

	ec->cipher = cipher;
	return 1;
}

int
PKCS7_stream(unsigned char ***boundary, PKCS7 *p7)
{
	ASN1_OCTET_STRING *os = NULL;

	switch (OBJ_obj2nid(p7->type)) {
	case NID_pkcs7_data:
		os = p7->d.data;
		break;

	case NID_pkcs7_signedAndEnveloped:
		os = p7->d.signed_and_enveloped->enc_data->enc_data;
		if (os == NULL) {
			os = ASN1_OCTET_STRING_new();
			p7->d.signed_and_enveloped->enc_data->enc_data = os;
		}
		break;

	case NID_pkcs7_enveloped:
		os = p7->d.enveloped->enc_data->enc_data;
		if (os == NULL) {
			os = ASN1_OCTET_STRING_new();
			p7->d.enveloped->enc_data->enc_data = os;
		}
		break;

	case NID_pkcs7_signed:
		os = p7->d.sign->contents->d.data;
		break;

	default:
		os = NULL;
		break;
	}

	if (os == NULL)
		return 0;

	os->flags |= ASN1_STRING_FLAG_NDEF;
	*boundary = &os->data;

	return 1;
}
@


1.18
log
@Replace M_ASN1_OCTET_STRING_(free|new) with ASN1_OCTET_STRING_(free|new).
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.17 2015/09/30 17:30:15 jsing Exp $ */
d86 1
a86 2
			PKCS7err(PKCS7_F_PKCS7_CTRL,
			    PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
d99 1
a99 2
			PKCS7err(PKCS7_F_PKCS7_CTRL,
			    PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
d105 1
a105 1
		PKCS7err(PKCS7_F_PKCS7_CTRL, PKCS7_R_UNKNOWN_OPERATION);
d152 1
a152 2
		PKCS7err(PKCS7_F_PKCS7_SET_CONTENT,
		    PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
d222 1
a222 2
		PKCS7err(PKCS7_F_PKCS7_SET_TYPE,
		    PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
d257 1
a257 1
		PKCS7err(PKCS7_F_PKCS7_ADD_SIGNER, PKCS7_R_WRONG_CONTENT_TYPE);
d277 1
a277 2
			PKCS7err(PKCS7_F_PKCS7_ADD_SIGNER,
			    ERR_R_MALLOC_FAILURE);
d308 1
a308 2
		PKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE,
		    PKCS7_R_WRONG_CONTENT_TYPE);
d315 1
a315 1
		PKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE, ERR_R_MALLOC_FAILURE);
d341 1
a341 1
		PKCS7err(PKCS7_F_PKCS7_ADD_CRL, PKCS7_R_WRONG_CONTENT_TYPE);
d348 1
a348 1
		PKCS7err(PKCS7_F_PKCS7_ADD_CRL, ERR_R_MALLOC_FAILURE);
d395 1
a395 2
			PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SET,
			    PKCS7_R_SIGNING_CTRL_FAILURE);
d399 1
a399 2
	PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SET,
	    PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
d415 1
a415 2
			PKCS7err(PKCS7_F_PKCS7_ADD_SIGNATURE,
			    PKCS7_R_NO_DEFAULT_DIGEST);
d438 1
a438 2
			PKCS7err(PKCS7_F_PKCS7_SET_DIGEST,
			    ERR_R_MALLOC_FAILURE);
d446 1
a446 1
	PKCS7err(PKCS7_F_PKCS7_SET_DIGEST, PKCS7_R_WRONG_CONTENT_TYPE);
d515 1
a515 2
		PKCS7err(PKCS7_F_PKCS7_ADD_RECIPIENT_INFO,
		    PKCS7_R_WRONG_CONTENT_TYPE);
d543 1
a543 2
		PKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,
		    PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
d550 1
a550 2
		PKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,
		    PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
d554 1
a554 2
		PKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,
		    PKCS7_R_ENCRYPTION_CTRL_FAILURE);
d596 1
a596 1
		PKCS7err(PKCS7_F_PKCS7_SET_CIPHER, PKCS7_R_WRONG_CONTENT_TYPE);
d603 1
a603 2
		PKCS7err(PKCS7_F_PKCS7_SET_CIPHER,
		    PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
@


1.17
log
@Replace M_ASN1_INTEGER_(new|free) with ASN1_INTEGER_(new|free) - this is
different from the macro expansion, but the result is the same. Also
replace some ASN1_STRING_dup() with ASN1_INTEGER_dup().

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.16 2015/07/29 14:58:34 jsing Exp $ */
d184 1
a184 1
		if ((p7->d.data = M_ASN1_OCTET_STRING_new()) == NULL)
d639 1
a639 1
			os = M_ASN1_OCTET_STRING_new();
d647 1
a647 1
			os = M_ASN1_OCTET_STRING_new();
@


1.16
log
@Expand obsolete M_ASN1.*(cmp|dup|print|set) macros - no change in generated
assembly.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.15 2015/03/19 14:00:22 tedu Exp $ */
d381 1
a381 1
	M_ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
d546 1
a546 1
	M_ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
@


1.15
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.14 2014/07/12 16:03:37 miod Exp $ */
d383 1
a383 1
	    M_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
d548 1
a548 1
	    M_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
@


1.14
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.13 2014/07/11 08:44:49 jsing Exp $ */
d463 2
@


1.14.4.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.14 2014/07/12 16:03:37 miod Exp $ */
a462 2
	if (p7 == NULL || p7->d.ptr == NULL)
		return (NULL);
@


1.14.6.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.14 2014/07/12 16:03:37 miod Exp $ */
a462 2
	if (p7 == NULL || p7->d.ptr == NULL)
		return (NULL);
@


1.13
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.12 2014/07/08 09:08:27 jsing Exp $ */
d578 1
a578 2
	if (pkey)
		EVP_PKEY_free(pkey);
@


1.12
log
@More KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.11 2014/06/29 17:05:36 jsing Exp $ */
d60 2
a61 1
#include "cryptlib.h"
d64 1
@


1.11
log
@KNF.

I just spent too long chasing a bug in here and really should have done
this first. Gem of the day... is it an if test or a for loop? No, it is a
super ifloop!

if (!(flags & PKCS7_NOVERIFY)) for (k = 0; k < sk_X509_num(signers); k++) {
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_lib.c,v 1.10 2014/06/12 15:49:30 deraadt Exp $ */
d187 3
a189 2
		if ((p7->d.signed_and_enveloped = PKCS7_SIGN_ENVELOPE_new())
			== NULL) goto err;
d193 2
a194 2
		p7->d.signed_and_enveloped->enc_data->content_type
		= OBJ_nid2obj(NID_pkcs7_data);
d198 2
a199 2
		if ((p7->d.enveloped = PKCS7_ENVELOPE_new())
			== NULL) goto err;
d202 2
a203 2
		p7->d.enveloped->enc_data->content_type
		= OBJ_nid2obj(NID_pkcs7_data);
d207 2
a208 2
		if ((p7->d.encrypted = PKCS7_ENCRYPT_new())
			== NULL) goto err;
d211 2
a212 2
		p7->d.encrypted->enc_data->content_type
		= OBJ_nid2obj(NID_pkcs7_data);
d217 2
a218 2
		if ((p7->d.digest = PKCS7_DIGEST_new())
			== NULL) goto err;
d458 2
a459 1
STACK_OF(PKCS7_SIGNER_INFO) *PKCS7_get_signer_info(PKCS7 *p7)
@


1.10
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d65 3
a67 2
long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg)
	{
d71 1
a71 1
	nid=OBJ_obj2nid(p7->type);
d73 1
a73 2
	switch (cmd)
		{
d75 13
a87 16
		if (nid == NID_pkcs7_signed)
			{
			ret=p7->detached=(int)larg;
			if (ret && PKCS7_type_is_data(p7->d.sign->contents))
					{
					ASN1_OCTET_STRING *os;
					os=p7->d.sign->contents->d.data;
					ASN1_OCTET_STRING_free(os);
					p7->d.sign->contents->d.data = NULL;
					}
			}
		else
			{
			PKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
			ret=0;
			}
d90 2
a91 3
		if (nid == NID_pkcs7_signed)
			{
			if(!p7->d.sign  || !p7->d.sign->contents->d.ptr)
d93 3
a95 2
			else ret = 0;
				
d97 6
a102 7
			}
		else
			{
			PKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
			ret=0;
			}
			
d105 2
a106 4
		PKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_UNKNOWN_OPERATION);
		ret=0;
		}
	return(ret);
d108 2
d111 4
a114 3
int PKCS7_content_new(PKCS7 *p7, int type)
	{
	PKCS7 *ret=NULL;
d116 6
a121 3
	if ((ret=PKCS7_new()) == NULL) goto err;
	if (!PKCS7_set_type(ret,type)) goto err;
	if (!PKCS7_set_content(p7,ret)) goto err;
d123 1
a123 1
	return(1);
d125 8
a132 6
	if (ret != NULL) PKCS7_free(ret);
	return(0);
	}

int PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data)
	{
d135 2
a136 3
	i=OBJ_obj2nid(p7->type);
	switch (i)
		{
d140 1
a140 1
		p7->d.sign->contents=p7_data;
d145 1
a145 1
		p7->d.digest->contents=p7_data;
d152 2
a153 1
		PKCS7err(PKCS7_F_PKCS7_SET_CONTENT,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
d155 2
a156 2
		}
	return(1);
d158 2
a159 2
	return(0);
	}
d161 3
a163 2
int PKCS7_set_type(PKCS7 *p7, int type)
	{
d169 1
a169 2
	switch (type)
		{
d171 2
a172 2
		p7->type=obj;
		if ((p7->d.sign=PKCS7_SIGNED_new()) == NULL)
d174 1
a174 2
		if (!ASN1_INTEGER_set(p7->d.sign->version,1))
			{
d176 1
a176 1
			p7->d.sign=NULL;
d178 1
a178 1
			}
d181 2
a182 2
		p7->type=obj;
		if ((p7->d.data=M_ASN1_OCTET_STRING_new()) == NULL)
d186 2
a187 2
		p7->type=obj;
		if ((p7->d.signed_and_enveloped=PKCS7_SIGN_ENVELOPE_new())
d189 2
a190 2
		ASN1_INTEGER_set(p7->d.signed_and_enveloped->version,1);
		if (!ASN1_INTEGER_set(p7->d.signed_and_enveloped->version,1))
d193 1
a193 1
						= OBJ_nid2obj(NID_pkcs7_data);
d196 2
a197 2
		p7->type=obj;
		if ((p7->d.enveloped=PKCS7_ENVELOPE_new())
d199 1
a199 1
		if (!ASN1_INTEGER_set(p7->d.enveloped->version,0))
d202 1
a202 1
						= OBJ_nid2obj(NID_pkcs7_data);
d205 2
a206 2
		p7->type=obj;
		if ((p7->d.encrypted=PKCS7_ENCRYPT_new())
d208 1
a208 1
		if (!ASN1_INTEGER_set(p7->d.encrypted->version,0))
d211 1
a211 1
						= OBJ_nid2obj(NID_pkcs7_data);
d215 2
a216 2
		p7->type=obj;
		if ((p7->d.digest=PKCS7_DIGEST_new())
d218 1
a218 1
		if (!ASN1_INTEGER_set(p7->d.digest->version,0))
d222 2
a223 1
		PKCS7err(PKCS7_F_PKCS7_SET_TYPE,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
d225 2
a226 2
		}
	return(1);
d228 2
a229 2
	return(0);
	}
d231 3
a233 2
int PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other)
	{
d237 1
a237 1
	}
d239 4
a242 3
int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *psi)
	{
	int i,j,nid;
d247 2
a248 3
	i=OBJ_obj2nid(p7->type);
	switch (i)
		{
d250 2
a251 2
		signer_sk=	p7->d.sign->signer_info;
		md_sk=		p7->d.sign->md_algs;
d254 2
a255 2
		signer_sk=	p7->d.signed_and_enveloped->signer_info;
		md_sk=		p7->d.signed_and_enveloped->md_algs;
d258 3
a260 3
		PKCS7err(PKCS7_F_PKCS7_ADD_SIGNER,PKCS7_R_WRONG_CONTENT_TYPE);
		return(0);
		}
d262 1
a262 1
	nid=OBJ_obj2nid(psi->digest_alg->algorithm);
d265 5
a269 7
	j=0;
	for (i=0; i<sk_X509_ALGOR_num(md_sk); i++)
		{
		alg=sk_X509_ALGOR_value(md_sk,i);
		if (OBJ_obj2nid(alg->algorithm) == nid)
			{
			j=1;
a270 1
			}
d272 1
d274 3
a276 4
		{
		if(!(alg=X509_ALGOR_new())
			|| !(alg->parameter = ASN1_TYPE_new()))
			{
d278 5
a282 4
			PKCS7err(PKCS7_F_PKCS7_ADD_SIGNER,ERR_R_MALLOC_FAILURE);
			return(0);
			}
		alg->algorithm=OBJ_nid2obj(nid);
d284 1
a284 2
		if (!sk_X509_ALGOR_push(md_sk,alg))
			{
a286 1
			}
d288 1
d290 1
a290 1
	if (!sk_PKCS7_SIGNER_INFO_push(signer_sk,psi))
d292 2
a293 2
	return(1);
	}
d295 3
a297 2
int PKCS7_add_certificate(PKCS7 *p7, X509 *x509)
	{
d301 2
a302 3
	i=OBJ_obj2nid(p7->type);
	switch (i)
		{
d304 1
a304 1
		sk= &(p7->d.sign->cert);
d307 1
a307 1
		sk= &(p7->d.signed_and_enveloped->cert);
d310 4
a313 3
		PKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE,PKCS7_R_WRONG_CONTENT_TYPE);
		return(0);
		}
d316 2
a317 3
		*sk=sk_X509_new_null();
	if (*sk == NULL)
		{
d320 3
a322 4
		}
	CRYPTO_add(&x509->references,1,CRYPTO_LOCK_X509);
	if (!sk_X509_push(*sk,x509))
		{
a324 2
		}
	return(1);
d326 2
d329 3
a331 2
int PKCS7_add_crl(PKCS7 *p7, X509_CRL *crl)
	{
d335 2
a336 3
	i=OBJ_obj2nid(p7->type);
	switch (i)
		{
d338 1
a338 1
		sk= &(p7->d.sign->crl);
d341 1
a341 1
		sk= &(p7->d.signed_and_enveloped->crl);
d344 3
a346 3
		PKCS7err(PKCS7_F_PKCS7_ADD_CRL,PKCS7_R_WRONG_CONTENT_TYPE);
		return(0);
		}
d349 3
a351 4
		*sk=sk_X509_CRL_new_null();
	if (*sk == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_ADD_CRL,ERR_R_MALLOC_FAILURE);
d353 1
a353 1
		}
d355 2
a356 3
	CRYPTO_add(&crl->references,1,CRYPTO_LOCK_X509_CRL);
	if (!sk_X509_CRL_push(*sk,crl))
		{
a358 2
		}
	return(1);
d360 2
d363 4
a366 3
int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,
	     const EVP_MD *dgst)
	{
d370 1
a370 1
	if (!ASN1_INTEGER_set(p7i->version,1))
d373 1
a373 1
			X509_get_issuer_name(x509)))
d379 2
a380 2
	if (!(p7i->issuer_and_serial->serial=
			M_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
d384 2
a385 2
	CRYPTO_add(&pkey->references,1,CRYPTO_LOCK_EVP_PKEY);
	p7i->pkey=pkey;
d390 1
a390 1
				V_ASN1_NULL, NULL);
d392 1
a392 2
	if (pkey->ameth && pkey->ameth->pkey_ctrl)
		{
d394 1
a394 1
						0, p7i);
d397 1
a397 2
		if (ret != -2)
			{
d399 1
a399 1
					PKCS7_R_SIGNING_CTRL_FAILURE);
a400 1
			}
d402 1
d404 1
a404 1
			PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
d407 1
a407 1
	}
d409 3
a411 3
PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey,
	     const EVP_MD *dgst)
	{
d414 1
a414 2
	if (dgst == NULL)
		{
d419 1
a419 2
		if (dgst == NULL)
			{
d421 1
a421 1
						PKCS7_R_NO_DEFAULT_DIGEST);
a422 1
			}
d424 1
d426 7
a432 4
	if ((si=PKCS7_SIGNER_INFO_new()) == NULL) goto err;
	if (!PKCS7_SIGNER_INFO_set(si,x509,pkey,dgst)) goto err;
	if (!PKCS7_add_signer(p7,si)) goto err;
	return(si);
d436 2
a437 2
	return(NULL);
	}
d439 7
a445 7
int PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md)
	{
	if (PKCS7_type_is_digest(p7))
		{
		if(!(p7->d.digest->md->parameter = ASN1_TYPE_new()))
			{
			PKCS7err(PKCS7_F_PKCS7_SET_DIGEST,ERR_R_MALLOC_FAILURE);
d447 1
a447 1
			}
d451 3
a453 3
		}
		
	PKCS7err(PKCS7_F_PKCS7_SET_DIGEST,PKCS7_R_WRONG_CONTENT_TYPE);
d455 1
a455 1
	}
d458 13
a470 16
	{
	if (PKCS7_type_is_signed(p7))
		{
		return(p7->d.sign->signer_info);
		}
	else if (PKCS7_type_is_signedAndEnveloped(p7))
		{
		return(p7->d.signed_and_enveloped->signer_info);
		}
	else
		return(NULL);
	}

void PKCS7_SIGNER_INFO_get0_algs(PKCS7_SIGNER_INFO *si, EVP_PKEY **pk,
					X509_ALGOR **pdig, X509_ALGOR **psig)
	{
d477 1
a477 1
	}
d479 3
a481 2
void PKCS7_RECIP_INFO_get0_alg(PKCS7_RECIP_INFO *ri, X509_ALGOR **penc)
	{
d484 1
a484 1
	}
d486 3
a488 2
PKCS7_RECIP_INFO *PKCS7_add_recipient(PKCS7 *p7, X509 *x509)
	{
d491 6
a496 3
	if ((ri=PKCS7_RECIP_INFO_new()) == NULL) goto err;
	if (!PKCS7_RECIP_INFO_set(ri,x509)) goto err;
	if (!PKCS7_add_recipient_info(p7,ri)) goto err;
d502 1
a502 1
	}
d504 3
a506 2
int PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri)
	{
d510 2
a511 3
	i=OBJ_obj2nid(p7->type);
	switch (i)
		{
d513 1
a513 1
		sk=	p7->d.signed_and_enveloped->recipientinfo;
d516 1
a516 1
		sk=	p7->d.enveloped->recipientinfo;
d519 4
a522 3
		PKCS7err(PKCS7_F_PKCS7_ADD_RECIPIENT_INFO,PKCS7_R_WRONG_CONTENT_TYPE);
		return(0);
		}
d524 1
a524 1
	if (!sk_PKCS7_RECIP_INFO_push(sk,ri))
d526 2
a527 2
	return(1);
	}
d529 3
a531 2
int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)
	{
d534 1
a534 1
	if (!ASN1_INTEGER_set(p7i->version,0))
d537 1
a537 1
		X509_get_issuer_name(x509)))
d541 2
a542 2
	if (!(p7i->issuer_and_serial->serial=
		M_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
d547 1
a547 2
	if (!pkey || !pkey->ameth || !pkey->ameth->pkey_ctrl)
		{
d549 1
a549 1
			PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
d551 1
a551 1
		}
d554 2
a555 3
						0, p7i);
	if (ret == -2)
		{
d557 1
a557 1
			PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
d559 2
a560 3
		}
	if (ret <= 0)
		{
d562 1
a562 1
				PKCS7_R_ENCRYPTION_CTRL_FAILURE);
d564 1
a564 1
		}
d568 2
a569 2
	CRYPTO_add(&x509->references,1,CRYPTO_LOCK_X509);
	p7i->cert=x509;
d573 1
a573 1
	err:
d577 1
a577 1
	}
d579 3
a581 2
X509 *PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si)
	{
d584 2
a585 2
			si->issuer_and_serial->issuer,
			si->issuer_and_serial->serial));
d587 2
a588 2
		return(NULL);
	}
d590 3
a592 2
int PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)
	{
d596 2
a597 3
	i=OBJ_obj2nid(p7->type);
	switch (i)
		{
d599 1
a599 1
		ec=p7->d.signed_and_enveloped->enc_data;
d602 1
a602 1
		ec=p7->d.enveloped->enc_data;
d605 3
a607 3
		PKCS7err(PKCS7_F_PKCS7_SET_CIPHER,PKCS7_R_WRONG_CONTENT_TYPE);
		return(0);
		}
d611 4
a614 3
	if(i == NID_undef) {
		PKCS7err(PKCS7_F_PKCS7_SET_CIPHER,PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
		return(0);
d619 1
a619 1
	}
d621 3
a623 2
int PKCS7_stream(unsigned char ***boundary, PKCS7 *p7)
	{
d626 2
a627 3
	switch (OBJ_obj2nid(p7->type))
		{
		case NID_pkcs7_data:
d631 1
a631 1
		case NID_pkcs7_signedAndEnveloped:
d633 4
a636 5
		if (os == NULL)
			{
			os=M_ASN1_OCTET_STRING_new();
			p7->d.signed_and_enveloped->enc_data->enc_data=os;
			}
d639 1
a639 1
		case NID_pkcs7_enveloped:
d641 4
a644 5
		if (os == NULL)
			{
			os=M_ASN1_OCTET_STRING_new();
			p7->d.enveloped->enc_data->enc_data=os;
			}
d647 2
a648 2
		case NID_pkcs7_signed:
		os=p7->d.sign->contents->d.data;
d651 1
a651 1
		default:
d654 2
a655 2
		}
	
d663 1
a663 1
	}
@


1.9
log
@openssl-1.0.0e: resolve conflicts
@
text
@d1 1
a1 1
/* crypto/pkcs7/pk7_lib.c */
@


1.8
log
@resolve conflicts, fix local changes
@
text
@a593 1
	ASN1_OBJECT *objtmp;
a615 1
	objtmp = OBJ_nid2obj(i);
@


1.7
log
@resolve conflicts
@
text
@d63 1
d318 1
a318 1
		PKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE,ERR_R_MALLOC_FAILURE);
d369 1
a369 2
	int nid;
	char is_dsa;
a370 4
	if (pkey->type == EVP_PKEY_DSA || pkey->type == EVP_PKEY_EC)
		is_dsa = 1;
	else
		is_dsa = 0;
a389 9
	if (is_dsa) p7i->digest_alg->algorithm=OBJ_nid2obj(NID_sha1);
	else	
		p7i->digest_alg->algorithm=OBJ_nid2obj(EVP_MD_type(dgst));

	if (p7i->digest_alg->parameter != NULL)
		ASN1_TYPE_free(p7i->digest_alg->parameter);
	if ((p7i->digest_alg->parameter=ASN1_TYPE_new()) == NULL)
		goto err;
	p7i->digest_alg->parameter->type=V_ASN1_NULL;
d391 4
a394 4
	if (p7i->digest_enc_alg->parameter != NULL)
		ASN1_TYPE_free(p7i->digest_enc_alg->parameter);
	nid = EVP_PKEY_type(pkey->type);
	if (nid == EVP_PKEY_RSA)
d396 10
a405 17
		p7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_rsaEncryption);
		if (!(p7i->digest_enc_alg->parameter=ASN1_TYPE_new()))
			goto err;
		p7i->digest_enc_alg->parameter->type=V_ASN1_NULL;
		}
	else if (nid == EVP_PKEY_DSA)
		{
#if 1
		/* use 'dsaEncryption' OID for compatibility with other software
		 * (PKCS #7 v1.5 does specify how to handle DSA) ... */
		p7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_dsa);
#else
		/* ... although the 'dsaWithSHA1' OID (as required by RFC 2630 for CMS)
		 * would make more sense. */
		p7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_dsaWithSHA1);
#endif
		p7i->digest_enc_alg->parameter = NULL; /* special case for DSA: omit 'parameter'! */
d407 2
a408 11
	else if (nid == EVP_PKEY_EC)
		{
		p7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_ecdsa_with_SHA1);
		if (!(p7i->digest_enc_alg->parameter=ASN1_TYPE_new()))
			goto err;
		p7i->digest_enc_alg->parameter->type=V_ASN1_NULL;
		}
	else
		return(0);

	return(1);
d410 1
a410 1
	return(0);
d416 15
a430 1
	PKCS7_SIGNER_INFO *si;
d437 2
a438 1
	PKCS7_SIGNER_INFO_free(si);
d474 17
d498 1
a498 1
	return(ri);
d500 3
a502 2
	PKCS7_RECIP_INFO_free(ri);
	return(NULL);
d531 2
d544 25
a568 3
	X509_ALGOR_free(p7i->key_enc_algor);
	if (!(p7i->key_enc_algor= X509_ALGOR_dup(x509->cert_info->key->algor)))
		return 0;
d573 6
a578 1
	return(1);
d623 45
@


1.6
log
@resolve conflicts
@
text
@d141 4
d213 6
d228 7
d274 3
a276 1
			|| !(alg->parameter = ASN1_TYPE_new())) {
d279 1
a279 1
		}
d282 5
a286 1
		sk_X509_ALGOR_push(md_sk,alg);
d289 2
a290 1
	sk_PKCS7_SIGNER_INFO_push(signer_sk,psi);
d315 5
d321 5
a325 1
	sk_X509_push(*sk,x509);
d350 5
d357 5
a361 1
	sk_X509_CRL_push(*sk,crl);
d368 1
d370 5
a374 2
	if (pkey->type == EVP_PKEY_DSA) is_dsa = 1;
	else is_dsa = 0;
a403 2
	p7i->digest_enc_alg->algorithm=OBJ_nid2obj(EVP_PKEY_type(pkey->type));

d406 24
a429 2
	if(is_dsa) p7i->digest_enc_alg->parameter = NULL;
	else {
d433 3
a435 1
	}
d452 1
d456 18
d497 1
d520 2
a521 1
	sk_PKCS7_RECIP_INFO_push(sk,ri);
@


1.5
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d167 6
a172 1
		ASN1_INTEGER_set(p7->d.sign->version,1);
d184 2
d193 2
a194 1
		ASN1_INTEGER_set(p7->d.enveloped->version,0);
d202 2
a203 1
		ASN1_INTEGER_set(p7->d.encrypted->version,0);
d330 5
a334 3
	ASN1_INTEGER_set(p7i->version,1);
	X509_NAME_set(&p7i->issuer_and_serial->issuer,
		X509_get_issuer_name(x509));
d339 3
a341 2
	p7i->issuer_and_serial->serial=
		M_ASN1_INTEGER_dup(X509_get_serialNumber(x509));
d438 5
a442 3
	ASN1_INTEGER_set(p7i->version,0);
	X509_NAME_set(&p7i->issuer_and_serial->issuer,
		X509_get_issuer_name(x509));
d445 3
a447 2
	p7i->issuer_and_serial->serial=
		M_ASN1_INTEGER_dup(X509_get_serialNumber(x509));
d450 2
a451 1
	p7i->key_enc_algor= X509_ALGOR_dup(x509->cert_info->key->algor);
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d77 7
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d87 5
a91 1
			ret=p7->detached;
d151 1
a151 1
	PKCS7_content_free(p7);
d172 2
d180 2
d188 2
d308 1
a308 1
	     EVP_MD *dgst)
d356 1
a356 1
	     EVP_MD *dgst)
d428 1
a428 3
	p7i->key_enc_algor=(X509_ALGOR *)ASN1_dup(i2d_X509_ALGOR,
		(char *(*)())d2i_X509_ALGOR,
		(char *)x509->cert_info->key->algor);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d126 1
a126 1
			PKCS7_content_free(p7->d.sign->contents);
d160 1
a160 1
		if ((p7->d.data=ASN1_OCTET_STRING_new()) == NULL)
a167 3
/*		p7->d.signed_and_enveloped->enc_data->content_type=
			OBJ_nid2obj(NID_pkcs7_encrypted);*/
			
d175 7
a182 1
	case NID_pkcs7_encrypted:
d230 5
a234 1
		alg=X509_ALGOR_new();
d236 1
d300 3
d310 1
a310 1
	ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
d312 1
a312 1
		ASN1_INTEGER_dup(X509_get_serialNumber(x509));
d319 1
a319 2
	if (pkey->type == EVP_PKEY_DSA)
		p7i->digest_alg->algorithm=OBJ_nid2obj(NID_sha1);
d333 6
a338 3
	if ((p7i->digest_enc_alg->parameter=ASN1_TYPE_new()) == NULL)
		goto err;
	p7i->digest_enc_alg->parameter->type=V_ASN1_NULL;
d413 1
a413 1
	ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
d415 1
a415 1
		ASN1_INTEGER_dup(X509_get_serialNumber(x509));
d441 1
d458 7
a464 1
	/* Setup cipher OID */
@


1.1
log
@Initial revision
@
text
@d61 2
a62 2
#include "objects.h"
#include "x509.h"
d64 1
a64 5
long PKCS7_ctrl(p7,cmd,larg,parg)
PKCS7 *p7;
int cmd;
long larg;
char *parg;
d97 2
a98 1
		abort();
d103 1
a103 3
int PKCS7_content_new(p7,type)
PKCS7 *p7;
int type;
d117 1
a117 3
int PKCS7_set_content(p7,p7_data)
PKCS7 *p7;
PKCS7 *p7_data;
d143 1
a143 3
int PKCS7_set_type(p7,type)
PKCS7 *p7;
int type;
d166 11
a176 3
			== NULL)
			goto err;
		ASN1_INTEGER_set(p7->d.sign->version,1);
a178 1
	case NID_pkcs7_enveloped:
d189 1
a189 3
int PKCS7_add_signer(p7,psi)
PKCS7 *p7;
PKCS7_SIGNER_INFO *psi;
d193 2
a194 2
	STACK *signer_sk;
	STACK *md_sk;
d216 1
a216 1
	for (i=0; i<sk_num(md_sk); i++)
d218 1
a218 1
		alg=(X509_ALGOR *)sk_value(md_sk,i);
d229 1
a229 1
		sk_push(md_sk,(char *)alg);
d232 1
a232 1
	sk_push(signer_sk,(char *)psi);
d236 1
a236 3
int PKCS7_add_certificate(p7,x509)
PKCS7 *p7;
X509 *x509;
d239 1
a239 1
	STACK **sk;
d256 1
a256 1
		*sk=sk_new_null();
d258 1
a258 1
	sk_push(*sk,(char *)x509);
d262 1
a262 3
int PKCS7_add_crl(p7,crl)
PKCS7 *p7;
X509_CRL *crl;
d265 1
a265 1
	STACK **sk;
d282 1
a282 1
		*sk=sk_new_null();
d285 1
a285 1
	sk_push(*sk,(char *)crl);
d289 2
a290 5
int PKCS7_SIGNER_INFO_set(p7i,x509,pkey,dgst)
PKCS7_SIGNER_INFO *p7i;
X509 *x509;
EVP_PKEY *pkey;
EVP_MD *dgst;
d308 12
a319 2
	p7i->digest_alg->algorithm=OBJ_nid2obj(EVP_MD_type(dgst));
	p7i->digest_enc_alg->algorithm=OBJ_nid2obj(EVP_MD_pkey_type(dgst));
a320 1
#if 1
a325 1
#endif
d332 2
a333 5
PKCS7_SIGNER_INFO *PKCS7_add_signature(p7,x509,pkey,dgst)
PKCS7 *p7;
X509 *x509;
EVP_PKEY *pkey;
EVP_MD *dgst;
d345 1
a345 2
STACK *PKCS7_get_signer_info(p7)
PKCS7 *p7;
d351 4
d359 1
a359 3
PKCS7_RECIP_INFO *PKCS7_add_recipient(p7,x509)
PKCS7 *p7;
X509 *x509;
d371 1
a371 3
int PKCS7_add_recipient_info(p7,ri)
PKCS7 *p7;
PKCS7_RECIP_INFO *ri;
d374 1
a374 1
	STACK *sk;
d382 3
d390 1
a390 1
	sk_push(sk,(char *)ri);
d394 1
a394 3
int PKCS7_RECIP_INFO_set(p7i,x509)
PKCS7_RECIP_INFO *p7i;
X509 *x509;
d404 5
d415 1
a415 3
X509 *PKCS7_cert_from_signer_info(p7,si)
PKCS7 *p7;
PKCS7_SIGNER_INFO *si;
d425 1
a425 3
int PKCS7_set_cipher(p7,cipher)
PKCS7 *p7;
EVP_CIPHER *cipher;
d436 3
d444 4
a447 2
	ec->algorithm->algorithm=OBJ_nid2obj(EVP_CIPHER_nid(cipher));
	return(ec->algorithm->algorithm != NULL);
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 2
a62 2
#include <openssl/objects.h>
#include <openssl/x509.h>
d64 5
a68 1
long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg)
d91 1
a91 5
			if(!p7->d.sign  || !p7->d.sign->contents->d.ptr)
				ret = 1;
			else ret = 0;
				
			p7->detached = ret;
d101 1
a101 2
		PKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_UNKNOWN_OPERATION);
		ret=0;
d106 3
a108 1
int PKCS7_content_new(PKCS7 *p7, int type)
d122 3
a124 1
int PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data)
d133 1
a133 1
			PKCS7_free(p7->d.sign->contents);
d150 3
a152 1
int PKCS7_set_type(PKCS7 *p7, int type)
d156 1
a156 1
	/*PKCS7_content_free(p7);*/
d169 1
a169 1
		if ((p7->d.data=M_ASN1_OCTET_STRING_new()) == NULL)
d175 3
a177 4
			== NULL) goto err;
		ASN1_INTEGER_set(p7->d.signed_and_enveloped->version,1);
		p7->d.signed_and_enveloped->enc_data->content_type
						= OBJ_nid2obj(NID_pkcs7_data);
d179 1
a180 7
		p7->type=obj;
		if ((p7->d.enveloped=PKCS7_ENVELOPE_new())
			== NULL) goto err;
		ASN1_INTEGER_set(p7->d.enveloped->version,0);
		p7->d.enveloped->enc_data->content_type
						= OBJ_nid2obj(NID_pkcs7_data);
		break;
a181 9
		p7->type=obj;
		if ((p7->d.encrypted=PKCS7_ENCRYPT_new())
			== NULL) goto err;
		ASN1_INTEGER_set(p7->d.encrypted->version,0);
		p7->d.encrypted->enc_data->content_type
						= OBJ_nid2obj(NID_pkcs7_data);
		break;

	case NID_pkcs7_digest:
d191 3
a193 1
int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *psi)
d197 2
a198 2
	STACK_OF(PKCS7_SIGNER_INFO) *signer_sk;
	STACK_OF(X509_ALGOR) *md_sk;
d220 1
a220 1
	for (i=0; i<sk_X509_ALGOR_num(md_sk); i++)
d222 1
a222 1
		alg=sk_X509_ALGOR_value(md_sk,i);
d231 1
a231 5
		if(!(alg=X509_ALGOR_new())
			|| !(alg->parameter = ASN1_TYPE_new())) {
			PKCS7err(PKCS7_F_PKCS7_ADD_SIGNER,ERR_R_MALLOC_FAILURE);
			return(0);
		}
d233 1
a233 2
		alg->parameter->type = V_ASN1_NULL;
		sk_X509_ALGOR_push(md_sk,alg);
d236 1
a236 1
	sk_PKCS7_SIGNER_INFO_push(signer_sk,psi);
d240 3
a242 1
int PKCS7_add_certificate(PKCS7 *p7, X509 *x509)
d245 1
a245 1
	STACK_OF(X509) **sk;
d262 1
a262 1
		*sk=sk_X509_new_null();
d264 1
a264 1
	sk_X509_push(*sk,x509);
d268 3
a270 1
int PKCS7_add_crl(PKCS7 *p7, X509_CRL *crl)
d273 1
a273 1
	STACK_OF(X509_CRL) **sk;
d290 1
a290 1
		*sk=sk_X509_CRL_new_null();
d293 1
a293 1
	sk_X509_CRL_push(*sk,crl);
d297 5
a301 2
int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,
	     const EVP_MD *dgst)
a302 3
	char is_dsa;
	if (pkey->type == EVP_PKEY_DSA) is_dsa = 1;
	else is_dsa = 0;
d310 1
a310 1
	M_ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
d312 1
a312 1
		M_ASN1_INTEGER_dup(X509_get_serialNumber(x509));
d319 2
a320 11
	if (is_dsa) p7i->digest_alg->algorithm=OBJ_nid2obj(NID_sha1);
	else	
		p7i->digest_alg->algorithm=OBJ_nid2obj(EVP_MD_type(dgst));

	if (p7i->digest_alg->parameter != NULL)
		ASN1_TYPE_free(p7i->digest_alg->parameter);
	if ((p7i->digest_alg->parameter=ASN1_TYPE_new()) == NULL)
		goto err;
	p7i->digest_alg->parameter->type=V_ASN1_NULL;

	p7i->digest_enc_alg->algorithm=OBJ_nid2obj(EVP_PKEY_type(pkey->type));
d322 1
d325 4
a328 6
	if(is_dsa) p7i->digest_enc_alg->parameter = NULL;
	else {
		if (!(p7i->digest_enc_alg->parameter=ASN1_TYPE_new()))
			goto err;
		p7i->digest_enc_alg->parameter->type=V_ASN1_NULL;
	}
d335 5
a339 2
PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey,
	     const EVP_MD *dgst)
d351 2
a352 1
STACK_OF(PKCS7_SIGNER_INFO) *PKCS7_get_signer_info(PKCS7 *p7)
a357 4
	else if (PKCS7_type_is_signedAndEnveloped(p7))
		{
		return(p7->d.signed_and_enveloped->signer_info);
		}
d362 3
a364 1
PKCS7_RECIP_INFO *PKCS7_add_recipient(PKCS7 *p7, X509 *x509)
d376 3
a378 1
int PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri)
d381 1
a381 1
	STACK_OF(PKCS7_RECIP_INFO) *sk;
a388 3
	case NID_pkcs7_enveloped:
		sk=	p7->d.enveloped->recipientinfo;
		break;
d394 1
a394 1
	sk_PKCS7_RECIP_INFO_push(sk,ri);
d398 3
a400 1
int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)
d406 1
a406 1
	M_ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
d408 1
a408 4
		M_ASN1_INTEGER_dup(X509_get_serialNumber(x509));

	X509_ALGOR_free(p7i->key_enc_algor);
	p7i->key_enc_algor= X509_ALGOR_dup(x509->cert_info->key->algor);
d416 3
a418 1
X509 *PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si)
d428 3
a430 1
int PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)
a432 1
	ASN1_OBJECT *objtmp;
a440 3
	case NID_pkcs7_enveloped:
		ec=p7->d.enveloped->enc_data;
		break;
d446 2
a447 10
	/* Check cipher OID exists and has data in it*/
	i = EVP_CIPHER_type(cipher);
	if(i == NID_undef) {
		PKCS7err(PKCS7_F_PKCS7_SET_CIPHER,PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
		return(0);
	}
	objtmp = OBJ_nid2obj(i);

	ec->cipher = cipher;
	return 1;
@


1.1.1.3
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@a76 7
			if (ret && PKCS7_type_is_data(p7->d.sign->contents))
					{
					ASN1_OCTET_STRING *os;
					os=p7->d.sign->contents->d.data;
					ASN1_OCTET_STRING_free(os);
					p7->d.sign->contents->d.data = NULL;
					}
@


1.1.1.4
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d167 1
a167 6
		if (!ASN1_INTEGER_set(p7->d.sign->version,1))
			{
			PKCS7_SIGNED_free(p7->d.sign);
			p7->d.sign=NULL;
			goto err;
			}
a178 2
		if (!ASN1_INTEGER_set(p7->d.signed_and_enveloped->version,1))
			goto err;
d186 1
a186 2
		if (!ASN1_INTEGER_set(p7->d.enveloped->version,0))
			goto err;
d194 1
a194 2
		if (!ASN1_INTEGER_set(p7->d.encrypted->version,0))
			goto err;
d321 3
a323 5
	if (!ASN1_INTEGER_set(p7i->version,1))
		goto err;
	if (!X509_NAME_set(&p7i->issuer_and_serial->issuer,
			X509_get_issuer_name(x509)))
		goto err;
d328 2
a329 3
	if (!(p7i->issuer_and_serial->serial=
			M_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
		goto err;
d426 3
a428 5
	if (!ASN1_INTEGER_set(p7i->version,0))
		return 0;
	if (!X509_NAME_set(&p7i->issuer_and_serial->issuer,
		X509_get_issuer_name(x509)))
		return 0;
d431 2
a432 3
	if (!(p7i->issuer_and_serial->serial=
		M_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
		return 0;
d435 1
a435 2
	if (!(p7i->key_enc_algor= X509_ALGOR_dup(x509->cert_info->key->algor)))
		return 0;
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@a140 4
		if (p7->d.digest->contents != NULL)
			PKCS7_free(p7->d.digest->contents);
		p7->d.digest->contents=p7_data;
		break;
a208 6
		p7->type=obj;
		if ((p7->d.digest=PKCS7_DIGEST_new())
			== NULL) goto err;
		if (!ASN1_INTEGER_set(p7->d.digest->version,0))
			goto err;
		break;
a217 7
int PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other)
	{
	p7->type = OBJ_nid2obj(type);
	p7->d.other = other;
	return 1;
	}

d257 1
a257 3
			|| !(alg->parameter = ASN1_TYPE_new()))
			{
			X509_ALGOR_free(alg);
d260 1
a260 1
			}
d263 1
a263 5
		if (!sk_X509_ALGOR_push(md_sk,alg))
			{
			X509_ALGOR_free(alg);
			return 0;
			}
d266 1
a266 2
	if (!sk_PKCS7_SIGNER_INFO_push(signer_sk,psi))
		return 0;
a290 5
	if (*sk == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE,ERR_R_MALLOC_FAILURE);
		return 0;
		}
d292 1
a292 5
	if (!sk_X509_push(*sk,x509))
		{
		X509_free(x509);
		return 0;
		}
a316 5
	if (*sk == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_ADD_CRL,ERR_R_MALLOC_FAILURE);
		return 0;
		}
d319 1
a319 5
	if (!sk_X509_CRL_push(*sk,crl))
		{
		X509_CRL_free(crl);
		return 0;
		}
a325 1
	int nid;
d327 2
a328 5

	if (pkey->type == EVP_PKEY_DSA || pkey->type == EVP_PKEY_EC)
		is_dsa = 1;
	else
		is_dsa = 0;
d358 2
d362 2
a363 4
	nid = EVP_PKEY_type(pkey->type);
	if (nid == EVP_PKEY_RSA)
		{
		p7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_rsaEncryption);
d367 1
a367 23
		}
	else if (nid == EVP_PKEY_DSA)
		{
#if 1
		/* use 'dsaEncryption' OID for compatibility with other software
		 * (PKCS #7 v1.5 does specify how to handle DSA) ... */
		p7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_dsa);
#else
		/* ... although the 'dsaWithSHA1' OID (as required by RFC 2630 for CMS)
		 * would make more sense. */
		p7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_dsaWithSHA1);
#endif
		p7i->digest_enc_alg->parameter = NULL; /* special case for DSA: omit 'parameter'! */
		}
	else if (nid == EVP_PKEY_EC)
		{
		p7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_ecdsa_with_SHA1);
		if (!(p7i->digest_enc_alg->parameter=ASN1_TYPE_new()))
			goto err;
		p7i->digest_enc_alg->parameter->type=V_ASN1_NULL;
		}
	else
		return(0);
a383 1
	PKCS7_SIGNER_INFO_free(si);
a386 18
int PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md)
	{
	if (PKCS7_type_is_digest(p7))
		{
		if(!(p7->d.digest->md->parameter = ASN1_TYPE_new()))
			{
			PKCS7err(PKCS7_F_PKCS7_SET_DIGEST,ERR_R_MALLOC_FAILURE);
			return 0;
			}
		p7->d.digest->md->parameter->type = V_ASN1_NULL;
		p7->d.digest->md->algorithm = OBJ_nid2obj(EVP_MD_nid(md));
		return 1;
		}
		
	PKCS7err(PKCS7_F_PKCS7_SET_DIGEST,PKCS7_R_WRONG_CONTENT_TYPE);
	return 1;
	}

a409 1
	PKCS7_RECIP_INFO_free(ri);
d432 1
a432 2
	if (!sk_PKCS7_RECIP_INFO_push(sk,ri))
		return 0;
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@a62 1
#include "asn1_locl.h"
d317 1
a317 1
		PKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE, ERR_R_MALLOC_FAILURE);
d368 2
a369 1
	int ret;
d371 4
d394 9
d404 24
a427 4
	X509_ALGOR_set0(p7i->digest_alg, OBJ_nid2obj(EVP_MD_type(dgst)),
				V_ASN1_NULL, NULL);

	if (pkey->ameth && pkey->ameth->pkey_ctrl)
d429 4
a432 10
		ret = pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_PKCS7_SIGN,
						0, p7i);
		if (ret > 0)
			return 1;
		if (ret != -2)
			{
			PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SET,
					PKCS7_R_SIGNING_CTRL_FAILURE);
			return 0;
			}
d434 4
a437 2
	PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SET,
			PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
d439 1
a439 1
	return 0;
d445 1
a445 15
	PKCS7_SIGNER_INFO *si = NULL;

	if (dgst == NULL)
		{
		int def_nid;
		if (EVP_PKEY_get_default_digest_nid(pkey, &def_nid) <= 0)
			goto err;
		dgst = EVP_get_digestbynid(def_nid);
		if (dgst == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_ADD_SIGNATURE,
						PKCS7_R_NO_DEFAULT_DIGEST);
			goto err;
			}
		}
d452 1
a452 2
	if (si)
		PKCS7_SIGNER_INFO_free(si);
a487 17
void PKCS7_SIGNER_INFO_get0_algs(PKCS7_SIGNER_INFO *si, EVP_PKEY **pk,
					X509_ALGOR **pdig, X509_ALGOR **psig)
	{
	if (pk)
		*pk = si->pkey;
	if (pdig)
		*pdig = si->digest_alg;
	if (psig)
		*psig = si->digest_enc_alg;
	}

void PKCS7_RECIP_INFO_get0_alg(PKCS7_RECIP_INFO *ri, X509_ALGOR **penc)
	{
	if (penc)
		*penc = ri->key_enc_algor;
	}

d495 1
a495 1
	return ri;
d497 2
a498 3
	if (ri)
		PKCS7_RECIP_INFO_free(ri);
	return NULL;
a526 2
	int ret;
	EVP_PKEY *pkey = NULL;
d538 3
a540 25
	pkey = X509_get_pubkey(x509);

	if (!pkey || !pkey->ameth || !pkey->ameth->pkey_ctrl)
		{
		PKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,
			PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
		goto err;
		}

	ret = pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_PKCS7_ENCRYPT,
						0, p7i);
	if (ret == -2)
		{
		PKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,
			PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
		goto err;
		}
	if (ret <= 0)
		{
		PKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,
				PKCS7_R_ENCRYPTION_CTRL_FAILURE);
		goto err;
		}

	EVP_PKEY_free(pkey);
d545 1
a545 6
	return 1;

	err:
	if (pkey)
		EVP_PKEY_free(pkey);
	return 0;
a589 45
int PKCS7_stream(unsigned char ***boundary, PKCS7 *p7)
	{
	ASN1_OCTET_STRING *os = NULL;

	switch (OBJ_obj2nid(p7->type))
		{
		case NID_pkcs7_data:
		os = p7->d.data;
		break;

		case NID_pkcs7_signedAndEnveloped:
		os = p7->d.signed_and_enveloped->enc_data->enc_data;
		if (os == NULL)
			{
			os=M_ASN1_OCTET_STRING_new();
			p7->d.signed_and_enveloped->enc_data->enc_data=os;
			}
		break;

		case NID_pkcs7_enveloped:
		os = p7->d.enveloped->enc_data->enc_data;
		if (os == NULL)
			{
			os=M_ASN1_OCTET_STRING_new();
			p7->d.enveloped->enc_data->enc_data=os;
			}
		break;

		case NID_pkcs7_signed:
		os=p7->d.sign->contents->d.data;
		break;

		default:
		os = NULL;
		break;
		}
	
	if (os == NULL)
		return 0;

	os->flags |= ASN1_STRING_FLAG_NDEF;
	*boundary = &os->data;

	return 1;
	}
@


1.1.1.7
log
@import OpenSSL 1.0.0e
@
text
@d594 1
d617 1
@


