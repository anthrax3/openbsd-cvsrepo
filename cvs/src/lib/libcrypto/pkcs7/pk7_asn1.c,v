head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.12
date	2015.07.25.15.33.06;	author jsing;	state Exp;
branches;
next	1.11;
commitid	UD0lY57WQq3LpV8y;

1.11
date	2015.02.10.06.37.38;	author jsing;	state Exp;
branches;
next	1.10;
commitid	W9I5ItQvbpGN7naH;

1.10
date	2015.02.10.05.25.45;	author jsing;	state Exp;
branches;
next	1.9;
commitid	HQSAPkY0rIzvWYsC;

1.9
date	2015.02.10.04.21.50;	author jsing;	state Exp;
branches;
next	1.8;
commitid	lmzaeFtqKbLCKhxJ;

1.8
date	2015.02.09.16.04.46;	author jsing;	state Exp;
branches;
next	1.7;
commitid	s9KZYHo6GzIioBCB;

1.7
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.6;
commitid	yQEL1wOWIearrW15;

1.6
date	2014.06.29.17.05.36;	author jsing;	state Exp;
branches;
next	1.5;
commitid	t0SFeQtZd9bpT5Df;

1.5
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	mJUVYpkFBZ0Zv2bG;

1.4
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.45;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2009.01.09.12.13.58;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Expand ASN.1 template macros - no change in generated assembly.
@
text
@/* $OpenBSD: pk7_asn1.c,v 1.11 2015/02/10 06:37:38 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>

#include <openssl/asn1t.h>
#include <openssl/pkcs7.h>
#include <openssl/x509.h>

/* PKCS#7 ASN1 module */

/* This is the ANY DEFINED BY table for the top level PKCS#7 structure */

static const ASN1_TEMPLATE p7default_tt = {
	.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL,
	.tag = 0,
	.offset = offsetof(PKCS7, d.other),
	.field_name = "d.other",
	.item = &ASN1_ANY_it,
};

static const ASN1_ADB_TABLE PKCS7_adbtbl[] = {
	{
		.value = NID_pkcs7_data,
		.tt = {
			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL | ASN1_TFLG_NDEF,
			.tag = 0,
			.offset = offsetof(PKCS7, d.data),
			.field_name = "d.data",
			.item = &ASN1_OCTET_STRING_NDEF_it,
		},
	
	},
	{
		.value = NID_pkcs7_signed,
		.tt = {
			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL | ASN1_TFLG_NDEF,
			.tag = 0,
			.offset = offsetof(PKCS7, d.sign),
			.field_name = "d.sign",
			.item = &PKCS7_SIGNED_it,
		},
	
	},
	{
		.value = NID_pkcs7_enveloped,
		.tt = {
			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL | ASN1_TFLG_NDEF,
			.tag = 0,
			.offset = offsetof(PKCS7, d.enveloped),
			.field_name = "d.enveloped",
			.item = &PKCS7_ENVELOPE_it,
		},
	
	},
	{
		.value = NID_pkcs7_signedAndEnveloped,
		.tt = {
			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL | ASN1_TFLG_NDEF,
			.tag = 0,
			.offset = offsetof(PKCS7, d.signed_and_enveloped),
			.field_name = "d.signed_and_enveloped",
			.item = &PKCS7_SIGN_ENVELOPE_it,
		},
	
	},
	{
		.value = NID_pkcs7_digest,
		.tt = {
			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL | ASN1_TFLG_NDEF,
			.tag = 0,
			.offset = offsetof(PKCS7, d.digest),
			.field_name = "d.digest",
			.item = &PKCS7_DIGEST_it,
		},
	
	},
	{
		.value = NID_pkcs7_encrypted,
		.tt = {
			.flags = ASN1_TFLG_EXPLICIT | ASN1_TFLG_OPTIONAL | ASN1_TFLG_NDEF,
			.tag = 0,
			.offset = offsetof(PKCS7, d.encrypted),
			.field_name = "d.encrypted",
			.item = &PKCS7_ENCRYPT_it,
		},
	
	},
};

static const ASN1_ADB PKCS7_adb = {
	.flags = 0,
	.offset = offsetof(PKCS7, type),
	.app_items = 0,
	.tbl = PKCS7_adbtbl,
	.tblcount = sizeof(PKCS7_adbtbl) / sizeof(ASN1_ADB_TABLE),
	.default_tt = &p7default_tt,
	.null_tt = NULL,
};

/* PKCS#7 streaming support */
static int
pk7_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
{
	ASN1_STREAM_ARG *sarg = exarg;
	PKCS7 **pp7 = (PKCS7 **)pval;

	switch (operation) {
	case ASN1_OP_STREAM_PRE:
		if (PKCS7_stream(&sarg->boundary, *pp7) <= 0)
			return 0;

	case ASN1_OP_DETACHED_PRE:
		sarg->ndef_bio = PKCS7_dataInit(*pp7, sarg->out);
		if (!sarg->ndef_bio)
			return 0;
		break;

	case ASN1_OP_STREAM_POST:
	case ASN1_OP_DETACHED_POST:
		if (PKCS7_dataFinal(*pp7, sarg->ndef_bio) <= 0)
			return 0;
		break;
	}
	return 1;
}

static const ASN1_AUX PKCS7_aux = {
	.app_data = NULL,
	.flags = 0,
	.ref_offset = 0,
	.ref_lock = 0,
	.asn1_cb = pk7_cb,
	.enc_offset = 0,
};
static const ASN1_TEMPLATE PKCS7_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7, type),
		.field_name = "type",
		.item = &ASN1_OBJECT_it,
	},
	{
		.flags = ASN1_TFLG_ADB_OID,
		.tag = -1,
		.offset = 0,
		.field_name = "PKCS7",
		.item = (const ASN1_ITEM *)&PKCS7_adb,
	},
};

const ASN1_ITEM PKCS7_it = {
	.itype = ASN1_ITYPE_NDEF_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_seq_tt,
	.tcount = sizeof(PKCS7_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &PKCS7_aux,
	.size = sizeof(PKCS7),
	.sname = "PKCS7",
};


PKCS7 *
d2i_PKCS7(PKCS7 **a, const unsigned char **in, long len)
{
	return (PKCS7 *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_it);
}

int
i2d_PKCS7(PKCS7 *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_it);
}

PKCS7 *
PKCS7_new(void)
{
	return (PKCS7 *)ASN1_item_new(&PKCS7_it);
}

void
PKCS7_free(PKCS7 *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_it);
}

int
i2d_PKCS7_NDEF(PKCS7 *a, unsigned char **out)
{
	return ASN1_item_ndef_i2d((ASN1_VALUE *)a, out, &PKCS7_it);
}

PKCS7 *
PKCS7_dup(PKCS7 *x)
{
	return ASN1_item_dup(&PKCS7_it, x);
}

static const ASN1_TEMPLATE PKCS7_SIGNED_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNED, version),
		.field_name = "version",
		.item = &ASN1_INTEGER_it,
	},
	{
		.flags = ASN1_TFLG_SET_OF,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNED, md_algs),
		.field_name = "md_algs",
		.item = &X509_ALGOR_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNED, contents),
		.field_name = "contents",
		.item = &PKCS7_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNED, cert),
		.field_name = "cert",
		.item = &X509_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SET_OF | ASN1_TFLG_OPTIONAL,
		.tag = 1,
		.offset = offsetof(PKCS7_SIGNED, crl),
		.field_name = "crl",
		.item = &X509_CRL_it,
	},
	{
		.flags = ASN1_TFLG_SET_OF,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNED, signer_info),
		.field_name = "signer_info",
		.item = &PKCS7_SIGNER_INFO_it,
	},
};

const ASN1_ITEM PKCS7_SIGNED_it = {
	.itype = ASN1_ITYPE_NDEF_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_SIGNED_seq_tt,
	.tcount = sizeof(PKCS7_SIGNED_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(PKCS7_SIGNED),
	.sname = "PKCS7_SIGNED",
};


PKCS7_SIGNED *
d2i_PKCS7_SIGNED(PKCS7_SIGNED **a, const unsigned char **in, long len)
{
	return (PKCS7_SIGNED *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_SIGNED_it);
}

int
i2d_PKCS7_SIGNED(PKCS7_SIGNED *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_SIGNED_it);
}

PKCS7_SIGNED *
PKCS7_SIGNED_new(void)
{
	return (PKCS7_SIGNED *)ASN1_item_new(&PKCS7_SIGNED_it);
}

void
PKCS7_SIGNED_free(PKCS7_SIGNED *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_SIGNED_it);
}

/* Minor tweak to operation: free up EVP_PKEY */
static int
si_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
{
	if (operation == ASN1_OP_FREE_POST) {
		PKCS7_SIGNER_INFO *si = (PKCS7_SIGNER_INFO *)*pval;
		EVP_PKEY_free(si->pkey);
	}
	return 1;
}

static const ASN1_AUX PKCS7_SIGNER_INFO_aux = {
	.app_data = NULL,
	.flags = 0,
	.ref_offset = 0,
	.ref_lock = 0,
	.asn1_cb = si_cb,
	.enc_offset = 0,
};
static const ASN1_TEMPLATE PKCS7_SIGNER_INFO_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNER_INFO, version),
		.field_name = "version",
		.item = &ASN1_INTEGER_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNER_INFO, issuer_and_serial),
		.field_name = "issuer_and_serial",
		.item = &PKCS7_ISSUER_AND_SERIAL_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNER_INFO, digest_alg),
		.field_name = "digest_alg",
		.item = &X509_ALGOR_it,
	},
	/* NB this should be a SET OF but we use a SEQUENCE OF so the
	 * original order * is retained when the structure is reencoded.
	 * Since the attributes are implicitly tagged this will not affect
	 * the encoding.
	 */
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNER_INFO, auth_attr),
		.field_name = "auth_attr",
		.item = &X509_ATTRIBUTE_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNER_INFO, digest_enc_alg),
		.field_name = "digest_enc_alg",
		.item = &X509_ALGOR_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGNER_INFO, enc_digest),
		.field_name = "enc_digest",
		.item = &ASN1_OCTET_STRING_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SET_OF | ASN1_TFLG_OPTIONAL,
		.tag = 1,
		.offset = offsetof(PKCS7_SIGNER_INFO, unauth_attr),
		.field_name = "unauth_attr",
		.item = &X509_ATTRIBUTE_it,
	},
};

const ASN1_ITEM PKCS7_SIGNER_INFO_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_SIGNER_INFO_seq_tt,
	.tcount = sizeof(PKCS7_SIGNER_INFO_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &PKCS7_SIGNER_INFO_aux,
	.size = sizeof(PKCS7_SIGNER_INFO),
	.sname = "PKCS7_SIGNER_INFO",
};


PKCS7_SIGNER_INFO *
d2i_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO **a, const unsigned char **in, long len)
{
	return (PKCS7_SIGNER_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_SIGNER_INFO_it);
}

int
i2d_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_SIGNER_INFO_it);
}

PKCS7_SIGNER_INFO *
PKCS7_SIGNER_INFO_new(void)
{
	return (PKCS7_SIGNER_INFO *)ASN1_item_new(&PKCS7_SIGNER_INFO_it);
}

void
PKCS7_SIGNER_INFO_free(PKCS7_SIGNER_INFO *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_SIGNER_INFO_it);
}

static const ASN1_TEMPLATE PKCS7_ISSUER_AND_SERIAL_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_ISSUER_AND_SERIAL, issuer),
		.field_name = "issuer",
		.item = &X509_NAME_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_ISSUER_AND_SERIAL, serial),
		.field_name = "serial",
		.item = &ASN1_INTEGER_it,
	},
};

const ASN1_ITEM PKCS7_ISSUER_AND_SERIAL_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_ISSUER_AND_SERIAL_seq_tt,
	.tcount = sizeof(PKCS7_ISSUER_AND_SERIAL_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(PKCS7_ISSUER_AND_SERIAL),
	.sname = "PKCS7_ISSUER_AND_SERIAL",
};


PKCS7_ISSUER_AND_SERIAL *
d2i_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL **a, const unsigned char **in, long len)
{
	return (PKCS7_ISSUER_AND_SERIAL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_ISSUER_AND_SERIAL_it);
}

int
i2d_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ISSUER_AND_SERIAL_it);
}

PKCS7_ISSUER_AND_SERIAL *
PKCS7_ISSUER_AND_SERIAL_new(void)
{
	return (PKCS7_ISSUER_AND_SERIAL *)ASN1_item_new(&PKCS7_ISSUER_AND_SERIAL_it);
}

void
PKCS7_ISSUER_AND_SERIAL_free(PKCS7_ISSUER_AND_SERIAL *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_ISSUER_AND_SERIAL_it);
}

static const ASN1_TEMPLATE PKCS7_ENVELOPE_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_ENVELOPE, version),
		.field_name = "version",
		.item = &ASN1_INTEGER_it,
	},
	{
		.flags = ASN1_TFLG_SET_OF,
		.tag = 0,
		.offset = offsetof(PKCS7_ENVELOPE, recipientinfo),
		.field_name = "recipientinfo",
		.item = &PKCS7_RECIP_INFO_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_ENVELOPE, enc_data),
		.field_name = "enc_data",
		.item = &PKCS7_ENC_CONTENT_it,
	},
};

const ASN1_ITEM PKCS7_ENVELOPE_it = {
	.itype = ASN1_ITYPE_NDEF_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_ENVELOPE_seq_tt,
	.tcount = sizeof(PKCS7_ENVELOPE_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(PKCS7_ENVELOPE),
	.sname = "PKCS7_ENVELOPE",
};


PKCS7_ENVELOPE *
d2i_PKCS7_ENVELOPE(PKCS7_ENVELOPE **a, const unsigned char **in, long len)
{
	return (PKCS7_ENVELOPE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_ENVELOPE_it);
}

int
i2d_PKCS7_ENVELOPE(PKCS7_ENVELOPE *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ENVELOPE_it);
}

PKCS7_ENVELOPE *
PKCS7_ENVELOPE_new(void)
{
	return (PKCS7_ENVELOPE *)ASN1_item_new(&PKCS7_ENVELOPE_it);
}

void
PKCS7_ENVELOPE_free(PKCS7_ENVELOPE *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_ENVELOPE_it);
}

/* Minor tweak to operation: free up X509 */
static int
ri_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
{
	if (operation == ASN1_OP_FREE_POST) {
		PKCS7_RECIP_INFO *ri = (PKCS7_RECIP_INFO *)*pval;
		X509_free(ri->cert);
	}
	return 1;
}

static const ASN1_AUX PKCS7_RECIP_INFO_aux = {
	.app_data = NULL,
	.flags = 0,
	.ref_offset = 0,
	.ref_lock = 0,
	.asn1_cb = ri_cb,
	.enc_offset = 0,
};
static const ASN1_TEMPLATE PKCS7_RECIP_INFO_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_RECIP_INFO, version),
		.field_name = "version",
		.item = &ASN1_INTEGER_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_RECIP_INFO, issuer_and_serial),
		.field_name = "issuer_and_serial",
		.item = &PKCS7_ISSUER_AND_SERIAL_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_RECIP_INFO, key_enc_algor),
		.field_name = "key_enc_algor",
		.item = &X509_ALGOR_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_RECIP_INFO, enc_key),
		.field_name = "enc_key",
		.item = &ASN1_OCTET_STRING_it,
	},
};

const ASN1_ITEM PKCS7_RECIP_INFO_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_RECIP_INFO_seq_tt,
	.tcount = sizeof(PKCS7_RECIP_INFO_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &PKCS7_RECIP_INFO_aux,
	.size = sizeof(PKCS7_RECIP_INFO),
	.sname = "PKCS7_RECIP_INFO",
};


PKCS7_RECIP_INFO *
d2i_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO **a, const unsigned char **in, long len)
{
	return (PKCS7_RECIP_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_RECIP_INFO_it);
}

int
i2d_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_RECIP_INFO_it);
}

PKCS7_RECIP_INFO *
PKCS7_RECIP_INFO_new(void)
{
	return (PKCS7_RECIP_INFO *)ASN1_item_new(&PKCS7_RECIP_INFO_it);
}

void
PKCS7_RECIP_INFO_free(PKCS7_RECIP_INFO *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_RECIP_INFO_it);
}

static const ASN1_TEMPLATE PKCS7_ENC_CONTENT_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_ENC_CONTENT, content_type),
		.field_name = "content_type",
		.item = &ASN1_OBJECT_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_ENC_CONTENT, algorithm),
		.field_name = "algorithm",
		.item = &X509_ALGOR_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(PKCS7_ENC_CONTENT, enc_data),
		.field_name = "enc_data",
		.item = &ASN1_OCTET_STRING_NDEF_it,
	},
};

const ASN1_ITEM PKCS7_ENC_CONTENT_it = {
	.itype = ASN1_ITYPE_NDEF_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_ENC_CONTENT_seq_tt,
	.tcount = sizeof(PKCS7_ENC_CONTENT_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(PKCS7_ENC_CONTENT),
	.sname = "PKCS7_ENC_CONTENT",
};


PKCS7_ENC_CONTENT *
d2i_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT **a, const unsigned char **in, long len)
{
	return (PKCS7_ENC_CONTENT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_ENC_CONTENT_it);
}

int
i2d_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ENC_CONTENT_it);
}

PKCS7_ENC_CONTENT *
PKCS7_ENC_CONTENT_new(void)
{
	return (PKCS7_ENC_CONTENT *)ASN1_item_new(&PKCS7_ENC_CONTENT_it);
}

void
PKCS7_ENC_CONTENT_free(PKCS7_ENC_CONTENT *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_ENC_CONTENT_it);
}

static const ASN1_TEMPLATE PKCS7_SIGN_ENVELOPE_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGN_ENVELOPE, version),
		.field_name = "version",
		.item = &ASN1_INTEGER_it,
	},
	{
		.flags = ASN1_TFLG_SET_OF,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGN_ENVELOPE, recipientinfo),
		.field_name = "recipientinfo",
		.item = &PKCS7_RECIP_INFO_it,
	},
	{
		.flags = ASN1_TFLG_SET_OF,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGN_ENVELOPE, md_algs),
		.field_name = "md_algs",
		.item = &X509_ALGOR_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGN_ENVELOPE, enc_data),
		.field_name = "enc_data",
		.item = &PKCS7_ENC_CONTENT_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SET_OF | ASN1_TFLG_OPTIONAL,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGN_ENVELOPE, cert),
		.field_name = "cert",
		.item = &X509_it,
	},
	{
		.flags = ASN1_TFLG_IMPLICIT | ASN1_TFLG_SET_OF | ASN1_TFLG_OPTIONAL,
		.tag = 1,
		.offset = offsetof(PKCS7_SIGN_ENVELOPE, crl),
		.field_name = "crl",
		.item = &X509_CRL_it,
	},
	{
		.flags = ASN1_TFLG_SET_OF,
		.tag = 0,
		.offset = offsetof(PKCS7_SIGN_ENVELOPE, signer_info),
		.field_name = "signer_info",
		.item = &PKCS7_SIGNER_INFO_it,
	},
};

const ASN1_ITEM PKCS7_SIGN_ENVELOPE_it = {
	.itype = ASN1_ITYPE_NDEF_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_SIGN_ENVELOPE_seq_tt,
	.tcount = sizeof(PKCS7_SIGN_ENVELOPE_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(PKCS7_SIGN_ENVELOPE),
	.sname = "PKCS7_SIGN_ENVELOPE",
};


PKCS7_SIGN_ENVELOPE *
d2i_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE **a, const unsigned char **in, long len)
{
	return (PKCS7_SIGN_ENVELOPE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_SIGN_ENVELOPE_it);
}

int
i2d_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_SIGN_ENVELOPE_it);
}

PKCS7_SIGN_ENVELOPE *
PKCS7_SIGN_ENVELOPE_new(void)
{
	return (PKCS7_SIGN_ENVELOPE *)ASN1_item_new(&PKCS7_SIGN_ENVELOPE_it);
}

void
PKCS7_SIGN_ENVELOPE_free(PKCS7_SIGN_ENVELOPE *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_SIGN_ENVELOPE_it);
}

static const ASN1_TEMPLATE PKCS7_ENCRYPT_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_ENCRYPT, version),
		.field_name = "version",
		.item = &ASN1_INTEGER_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_ENCRYPT, enc_data),
		.field_name = "enc_data",
		.item = &PKCS7_ENC_CONTENT_it,
	},
};

const ASN1_ITEM PKCS7_ENCRYPT_it = {
	.itype = ASN1_ITYPE_NDEF_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_ENCRYPT_seq_tt,
	.tcount = sizeof(PKCS7_ENCRYPT_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(PKCS7_ENCRYPT),
	.sname = "PKCS7_ENCRYPT",
};


PKCS7_ENCRYPT *
d2i_PKCS7_ENCRYPT(PKCS7_ENCRYPT **a, const unsigned char **in, long len)
{
	return (PKCS7_ENCRYPT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_ENCRYPT_it);
}

int
i2d_PKCS7_ENCRYPT(PKCS7_ENCRYPT *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ENCRYPT_it);
}

PKCS7_ENCRYPT *
PKCS7_ENCRYPT_new(void)
{
	return (PKCS7_ENCRYPT *)ASN1_item_new(&PKCS7_ENCRYPT_it);
}

void
PKCS7_ENCRYPT_free(PKCS7_ENCRYPT *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_ENCRYPT_it);
}

static const ASN1_TEMPLATE PKCS7_DIGEST_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_DIGEST, version),
		.field_name = "version",
		.item = &ASN1_INTEGER_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_DIGEST, md),
		.field_name = "md",
		.item = &X509_ALGOR_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_DIGEST, contents),
		.field_name = "contents",
		.item = &PKCS7_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(PKCS7_DIGEST, digest),
		.field_name = "digest",
		.item = &ASN1_OCTET_STRING_it,
	},
};

const ASN1_ITEM PKCS7_DIGEST_it = {
	.itype = ASN1_ITYPE_NDEF_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = PKCS7_DIGEST_seq_tt,
	.tcount = sizeof(PKCS7_DIGEST_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(PKCS7_DIGEST),
	.sname = "PKCS7_DIGEST",
};


PKCS7_DIGEST *
d2i_PKCS7_DIGEST(PKCS7_DIGEST **a, const unsigned char **in, long len)
{
	return (PKCS7_DIGEST *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &PKCS7_DIGEST_it);
}

int
i2d_PKCS7_DIGEST(PKCS7_DIGEST *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_DIGEST_it);
}

PKCS7_DIGEST *
PKCS7_DIGEST_new(void)
{
	return (PKCS7_DIGEST *)ASN1_item_new(&PKCS7_DIGEST_it);
}

void
PKCS7_DIGEST_free(PKCS7_DIGEST *a)
{
	ASN1_item_free((ASN1_VALUE *)a, &PKCS7_DIGEST_it);
}

/* Specials for authenticated attributes */

/* When signing attributes we want to reorder them to match the sorted
 * encoding.
 */

static const ASN1_TEMPLATE PKCS7_ATTR_SIGN_item_tt = {
	.flags = ASN1_TFLG_SET_ORDER,
	.tag = 0,
	.offset = 0,
	.field_name = "PKCS7_ATTRIBUTES",
	.item = &X509_ATTRIBUTE_it,
};

const ASN1_ITEM PKCS7_ATTR_SIGN_it = {
	.itype = ASN1_ITYPE_PRIMITIVE,
	.utype = -1,
	.templates = &PKCS7_ATTR_SIGN_item_tt,
	.tcount = 0,
	.funcs = NULL,
	.size = 0,
	.sname = "PKCS7_ATTR_SIGN",
};

/* When verifying attributes we need to use the received order. So
 * we use SEQUENCE OF and tag it to SET OF
 */

static const ASN1_TEMPLATE PKCS7_ATTR_VERIFY_item_tt = {
	.flags = ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_IMPTAG | ASN1_TFLG_UNIVERSAL,
	.tag = V_ASN1_SET,
	.offset = 0,
	.field_name = "PKCS7_ATTRIBUTES",
	.item = &X509_ATTRIBUTE_it,
};

const ASN1_ITEM PKCS7_ATTR_VERIFY_it = {
	.itype = ASN1_ITYPE_PRIMITIVE,
	.utype = -1,
	.templates = &PKCS7_ATTR_VERIFY_item_tt,
	.tcount = 0,
	.funcs = NULL,
	.size = 0,
	.sname = "PKCS7_ATTR_VERIFY",
};


int
PKCS7_print_ctx(BIO *out, PKCS7 *x, int indent, const ASN1_PCTX *pctx)
{
	return ASN1_item_print(out, (ASN1_VALUE *)x, indent,
	    &PKCS7_it, pctx);
}
@


1.11
log
@Expand IMPLEMENT_ASN1_NDEF_FUNCTION and IMPLEMENT_ASN1_PRINT_FUNCTION
macros so that the code is visible and functions can be readily located.

Change has been scripted and there is no change to the generated assembly.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_asn1.c,v 1.10 2015/02/10 05:25:45 jsing Exp $ */
d69 86
a154 17
ASN1_ADB_TEMPLATE(p7default) = ASN1_EXP_OPT(PKCS7, d.other, ASN1_ANY, 0);

ASN1_ADB(PKCS7) = {
	ADB_ENTRY(NID_pkcs7_data,
	    ASN1_NDEF_EXP_OPT(PKCS7, d.data, ASN1_OCTET_STRING_NDEF, 0)),
	ADB_ENTRY(NID_pkcs7_signed,
	    ASN1_NDEF_EXP_OPT(PKCS7, d.sign, PKCS7_SIGNED, 0)),
	ADB_ENTRY(NID_pkcs7_enveloped,
	    ASN1_NDEF_EXP_OPT(PKCS7, d.enveloped, PKCS7_ENVELOPE, 0)),
	ADB_ENTRY(NID_pkcs7_signedAndEnveloped,
	    ASN1_NDEF_EXP_OPT(PKCS7, d.signed_and_enveloped,
		PKCS7_SIGN_ENVELOPE, 0)),
	ADB_ENTRY(NID_pkcs7_digest,
	    ASN1_NDEF_EXP_OPT(PKCS7, d.digest, PKCS7_DIGEST, 0)),
	ADB_ENTRY(NID_pkcs7_encrypted,
	    ASN1_NDEF_EXP_OPT(PKCS7, d.encrypted, PKCS7_ENCRYPT, 0))
} ASN1_ADB_END(PKCS7, 0, type, 0, &p7default_tt, NULL);
d183 34
a216 4
ASN1_NDEF_SEQUENCE_cb(PKCS7, pk7_cb) = {
	ASN1_SIMPLE(PKCS7, type, ASN1_OBJECT),
	ASN1_ADB_OBJECT(PKCS7)
}ASN1_NDEF_SEQUENCE_END_cb(PKCS7, PKCS7)
d256 54
a309 8
ASN1_NDEF_SEQUENCE(PKCS7_SIGNED) = {
	ASN1_SIMPLE(PKCS7_SIGNED, version, ASN1_INTEGER),
	ASN1_SET_OF(PKCS7_SIGNED, md_algs, X509_ALGOR),
	ASN1_SIMPLE(PKCS7_SIGNED, contents, PKCS7),
	ASN1_IMP_SEQUENCE_OF_OPT(PKCS7_SIGNED, cert, X509, 0),
	ASN1_IMP_SET_OF_OPT(PKCS7_SIGNED, crl, X509_CRL, 1),
	ASN1_SET_OF(PKCS7_SIGNED, signer_info, PKCS7_SIGNER_INFO)
} ASN1_NDEF_SEQUENCE_END(PKCS7_SIGNED)
d348 30
a377 5
ASN1_SEQUENCE_cb(PKCS7_SIGNER_INFO, si_cb) = {
	ASN1_SIMPLE(PKCS7_SIGNER_INFO, version, ASN1_INTEGER),
	ASN1_SIMPLE(PKCS7_SIGNER_INFO, issuer_and_serial,
	    PKCS7_ISSUER_AND_SERIAL),
	ASN1_SIMPLE(PKCS7_SIGNER_INFO, digest_alg, X509_ALGOR),
d383 39
a421 6
	ASN1_IMP_SEQUENCE_OF_OPT(PKCS7_SIGNER_INFO, auth_attr,
	    X509_ATTRIBUTE, 0),
	ASN1_SIMPLE(PKCS7_SIGNER_INFO, digest_enc_alg, X509_ALGOR),
	ASN1_SIMPLE(PKCS7_SIGNER_INFO, enc_digest, ASN1_OCTET_STRING),
	ASN1_IMP_SET_OF_OPT(PKCS7_SIGNER_INFO, unauth_attr, X509_ATTRIBUTE, 1)
} ASN1_SEQUENCE_END_cb(PKCS7_SIGNER_INFO, PKCS7_SIGNER_INFO)
d449 26
a474 4
ASN1_SEQUENCE(PKCS7_ISSUER_AND_SERIAL) = {
	ASN1_SIMPLE(PKCS7_ISSUER_AND_SERIAL, issuer, X509_NAME),
	ASN1_SIMPLE(PKCS7_ISSUER_AND_SERIAL, serial, ASN1_INTEGER)
} ASN1_SEQUENCE_END(PKCS7_ISSUER_AND_SERIAL)
d502 33
a534 5
ASN1_NDEF_SEQUENCE(PKCS7_ENVELOPE) = {
	ASN1_SIMPLE(PKCS7_ENVELOPE, version, ASN1_INTEGER),
	ASN1_SET_OF(PKCS7_ENVELOPE, recipientinfo, PKCS7_RECIP_INFO),
	ASN1_SIMPLE(PKCS7_ENVELOPE, enc_data, PKCS7_ENC_CONTENT)
} ASN1_NDEF_SEQUENCE_END(PKCS7_ENVELOPE)
d573 48
a620 7
ASN1_SEQUENCE_cb(PKCS7_RECIP_INFO, ri_cb) = {
	ASN1_SIMPLE(PKCS7_RECIP_INFO, version, ASN1_INTEGER),
	ASN1_SIMPLE(PKCS7_RECIP_INFO, issuer_and_serial,
	    PKCS7_ISSUER_AND_SERIAL),
	ASN1_SIMPLE(PKCS7_RECIP_INFO, key_enc_algor, X509_ALGOR),
	ASN1_SIMPLE(PKCS7_RECIP_INFO, enc_key, ASN1_OCTET_STRING)
} ASN1_SEQUENCE_END_cb(PKCS7_RECIP_INFO, PKCS7_RECIP_INFO)
d648 33
a680 5
ASN1_NDEF_SEQUENCE(PKCS7_ENC_CONTENT) = {
	ASN1_SIMPLE(PKCS7_ENC_CONTENT, content_type, ASN1_OBJECT),
	ASN1_SIMPLE(PKCS7_ENC_CONTENT, algorithm, X509_ALGOR),
	ASN1_IMP_OPT(PKCS7_ENC_CONTENT, enc_data, ASN1_OCTET_STRING_NDEF, 0)
} ASN1_NDEF_SEQUENCE_END(PKCS7_ENC_CONTENT)
d708 61
a768 9
ASN1_NDEF_SEQUENCE(PKCS7_SIGN_ENVELOPE) = {
	ASN1_SIMPLE(PKCS7_SIGN_ENVELOPE, version, ASN1_INTEGER),
	ASN1_SET_OF(PKCS7_SIGN_ENVELOPE, recipientinfo, PKCS7_RECIP_INFO),
	ASN1_SET_OF(PKCS7_SIGN_ENVELOPE, md_algs, X509_ALGOR),
	ASN1_SIMPLE(PKCS7_SIGN_ENVELOPE, enc_data, PKCS7_ENC_CONTENT),
	ASN1_IMP_SET_OF_OPT(PKCS7_SIGN_ENVELOPE, cert, X509, 0),
	ASN1_IMP_SET_OF_OPT(PKCS7_SIGN_ENVELOPE, crl, X509_CRL, 1),
	ASN1_SET_OF(PKCS7_SIGN_ENVELOPE, signer_info, PKCS7_SIGNER_INFO)
} ASN1_NDEF_SEQUENCE_END(PKCS7_SIGN_ENVELOPE)
d796 26
a821 4
ASN1_NDEF_SEQUENCE(PKCS7_ENCRYPT) = {
	ASN1_SIMPLE(PKCS7_ENCRYPT, version, ASN1_INTEGER),
	ASN1_SIMPLE(PKCS7_ENCRYPT, enc_data, PKCS7_ENC_CONTENT)
} ASN1_NDEF_SEQUENCE_END(PKCS7_ENCRYPT)
d849 40
a888 6
ASN1_NDEF_SEQUENCE(PKCS7_DIGEST) = {
	ASN1_SIMPLE(PKCS7_DIGEST, version, ASN1_INTEGER),
	ASN1_SIMPLE(PKCS7_DIGEST, md, X509_ALGOR),
	ASN1_SIMPLE(PKCS7_DIGEST, contents, PKCS7),
	ASN1_SIMPLE(PKCS7_DIGEST, digest, ASN1_OCTET_STRING)
} ASN1_NDEF_SEQUENCE_END(PKCS7_DIGEST)
d922 17
a938 4
ASN1_ITEM_TEMPLATE(PKCS7_ATTR_SIGN) =
    ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SET_ORDER, 0, PKCS7_ATTRIBUTES,
	X509_ATTRIBUTE)
ASN1_ITEM_TEMPLATE_END(PKCS7_ATTR_SIGN)
d944 17
a960 4
ASN1_ITEM_TEMPLATE(PKCS7_ATTR_VERIFY) =
    ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_IMPTAG |
	ASN1_TFLG_UNIVERSAL, V_ASN1_SET, PKCS7_ATTRIBUTES, X509_ATTRIBUTE)
ASN1_ITEM_TEMPLATE_END(PKCS7_ATTR_VERIFY)
@


1.10
log
@Manually expand ASN1_ITEM_rptr macros that should have been expanded with
the IMPLEMENT_ASN1_DUP_FUNCTION macro.
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_asn1.c,v 1.9 2015/02/10 04:21:50 jsing Exp $ */
d144 6
a149 1
IMPLEMENT_ASN1_NDEF_FUNCTION(PKCS7)
d506 7
a512 1
IMPLEMENT_ASN1_PRINT_FUNCTION(PKCS7)
@


1.9
log
@Expand the IMPLEMENT_ASN1_DUP_FUNCTION macro so that the code is visible
and functions can be readily located.

Change has been scripted and the generated assembly only differs by changes
to line numbers.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_asn1.c,v 1.8 2015/02/09 16:04:46 jsing Exp $ */
d149 1
a149 1
	return ASN1_item_dup(ASN1_ITEM_rptr(PKCS7), x);
@


1.8
log
@Expand the IMPLEMENT_ASN1_FUNCTIONS macro so that the code is visible and
functions can be readily located.

Change has been scripted and there is no change to the generated assembly.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_asn1.c,v 1.7 2014/07/11 08:44:49 jsing Exp $ */
d145 6
a150 1
IMPLEMENT_ASN1_DUP_FUNCTION(PKCS7)
@


1.7
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_asn1.c,v 1.6 2014/06/29 17:05:36 jsing Exp $ */
d119 25
a143 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7)
d156 25
a180 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7_SIGNED)
d210 25
a234 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7_SIGNER_INFO)
d241 25
a265 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7_ISSUER_AND_SERIAL)
d273 25
a297 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7_ENVELOPE)
d318 25
a342 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7_RECIP_INFO)
d350 25
a374 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7_ENC_CONTENT)
d386 25
a410 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7_SIGN_ENVELOPE)
d417 25
a441 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7_ENCRYPT)
d450 25
a474 1
IMPLEMENT_ASN1_FUNCTIONS(PKCS7_DIGEST)
@


1.6
log
@KNF.

I just spent too long chasing a bug in here and really should have done
this first. Gem of the day... is it an if test or a for loop? No, it is a
super ifloop!

if (!(flags & PKCS7_NOVERIFY)) for (k = 0; k < sk_X509_num(signers); k++) {
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_asn1.c,v 1.5 2014/06/12 15:49:30 deraadt Exp $ */
d60 1
a60 1
#include "cryptlib.h"
@


1.5
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d72 13
a84 6
	ADB_ENTRY(NID_pkcs7_data, ASN1_NDEF_EXP_OPT(PKCS7, d.data, ASN1_OCTET_STRING_NDEF, 0)),
	ADB_ENTRY(NID_pkcs7_signed, ASN1_NDEF_EXP_OPT(PKCS7, d.sign, PKCS7_SIGNED, 0)),
	ADB_ENTRY(NID_pkcs7_enveloped, ASN1_NDEF_EXP_OPT(PKCS7, d.enveloped, PKCS7_ENVELOPE, 0)),
	ADB_ENTRY(NID_pkcs7_signedAndEnveloped, ASN1_NDEF_EXP_OPT(PKCS7, d.signed_and_enveloped, PKCS7_SIGN_ENVELOPE, 0)),
	ADB_ENTRY(NID_pkcs7_digest, ASN1_NDEF_EXP_OPT(PKCS7, d.digest, PKCS7_DIGEST, 0)),
	ADB_ENTRY(NID_pkcs7_encrypted, ASN1_NDEF_EXP_OPT(PKCS7, d.encrypted, PKCS7_ENCRYPT, 0))
d88 2
a89 2
static int pk7_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
							void *exarg)
d94 2
a95 4
	switch(operation)
		{

		case ASN1_OP_STREAM_PRE:
d98 2
a99 1
		case ASN1_OP_DETACHED_PRE:
d105 2
a106 2
		case ASN1_OP_STREAM_POST:
		case ASN1_OP_DETACHED_POST:
d110 1
a110 2

		}
d135 2
a136 2
static int si_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
							void *exarg)
d138 1
a138 1
	if(operation == ASN1_OP_FREE_POST) {
d147 2
a148 1
	ASN1_SIMPLE(PKCS7_SIGNER_INFO, issuer_and_serial, PKCS7_ISSUER_AND_SERIAL),
d155 2
a156 1
	ASN1_IMP_SEQUENCE_OF_OPT(PKCS7_SIGNER_INFO, auth_attr, X509_ATTRIBUTE, 0),
d180 2
a181 2
static int ri_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
d183 1
a183 1
	if(operation == ASN1_OP_FREE_POST) {
d192 2
a193 1
	ASN1_SIMPLE(PKCS7_RECIP_INFO, issuer_and_serial, PKCS7_ISSUER_AND_SERIAL),
d242 3
a244 2
ASN1_ITEM_TEMPLATE(PKCS7_ATTR_SIGN) = 
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SET_ORDER, 0, PKCS7_ATTRIBUTES, X509_ATTRIBUTE)
d247 1
a247 1
/* When verifying attributes we need to use the received order. So 
d251 3
a253 3
ASN1_ITEM_TEMPLATE(PKCS7_ATTR_VERIFY) = 
	ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF | ASN1_TFLG_IMPTAG | ASN1_TFLG_UNIVERSAL,
				V_ASN1_SET, PKCS7_ATTRIBUTES, X509_ATTRIBUTE)
@


1.4
log
@resolve conflicts, fix local changes
@
text
@d1 1
a1 1
/* pk7_asn.c */
@


1.3
log
@resolve conflicts
@
text
@d80 30
a109 1
ASN1_NDEF_SEQUENCE(PKCS7) = {
d112 1
a112 1
}ASN1_NDEF_SEQUENCE_END(PKCS7)
d130 2
a131 1
static int si_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)
d173 2
a174 1
static int ri_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)
d195 1
a195 1
	ASN1_IMP_OPT(PKCS7_ENC_CONTENT, enc_data, ASN1_OCTET_STRING, 0)
d246 2
@


1.2
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d72 6
a77 6
	ADB_ENTRY(NID_pkcs7_data, ASN1_EXP_OPT(PKCS7, d.data, ASN1_OCTET_STRING, 0)),
	ADB_ENTRY(NID_pkcs7_signed, ASN1_EXP_OPT(PKCS7, d.sign, PKCS7_SIGNED, 0)),
	ADB_ENTRY(NID_pkcs7_enveloped, ASN1_EXP_OPT(PKCS7, d.enveloped, PKCS7_ENVELOPE, 0)),
	ADB_ENTRY(NID_pkcs7_signedAndEnveloped, ASN1_EXP_OPT(PKCS7, d.signed_and_enveloped, PKCS7_SIGN_ENVELOPE, 0)),
	ADB_ENTRY(NID_pkcs7_digest, ASN1_EXP_OPT(PKCS7, d.digest, PKCS7_DIGEST, 0)),
	ADB_ENTRY(NID_pkcs7_encrypted, ASN1_EXP_OPT(PKCS7, d.encrypted, PKCS7_ENCRYPT, 0))
d80 1
a80 1
ASN1_SEQUENCE(PKCS7) = {
d83 1
a83 1
}ASN1_SEQUENCE_END(PKCS7)
d86 1
d89 1
a89 1
ASN1_SEQUENCE(PKCS7_SIGNED) = {
d96 1
a96 1
} ASN1_SEQUENCE_END(PKCS7_SIGNED)
d134 1
a134 1
ASN1_SEQUENCE(PKCS7_ENVELOPE) = {
d138 1
a138 1
} ASN1_SEQUENCE_END(PKCS7_ENVELOPE)
d161 1
a161 1
ASN1_SEQUENCE(PKCS7_ENC_CONTENT) = {
d165 1
a165 1
} ASN1_SEQUENCE_END(PKCS7_ENC_CONTENT)
d169 1
a169 1
ASN1_SEQUENCE(PKCS7_SIGN_ENVELOPE) = {
d177 1
a177 1
} ASN1_SEQUENCE_END(PKCS7_SIGN_ENVELOPE)
d181 1
a181 1
ASN1_SEQUENCE(PKCS7_ENCRYPT) = {
d184 1
a184 1
} ASN1_SEQUENCE_END(PKCS7_ENCRYPT)
d188 1
a188 1
ASN1_SEQUENCE(PKCS7_DIGEST) = {
d193 1
a193 1
} ASN1_SEQUENCE_END(PKCS7_DIGEST)
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import of OpenSSL 0.9.8h
@
text
@d72 6
a77 6
	ADB_ENTRY(NID_pkcs7_data, ASN1_NDEF_EXP_OPT(PKCS7, d.data, ASN1_OCTET_STRING_NDEF, 0)),
	ADB_ENTRY(NID_pkcs7_signed, ASN1_NDEF_EXP_OPT(PKCS7, d.sign, PKCS7_SIGNED, 0)),
	ADB_ENTRY(NID_pkcs7_enveloped, ASN1_NDEF_EXP_OPT(PKCS7, d.enveloped, PKCS7_ENVELOPE, 0)),
	ADB_ENTRY(NID_pkcs7_signedAndEnveloped, ASN1_NDEF_EXP_OPT(PKCS7, d.signed_and_enveloped, PKCS7_SIGN_ENVELOPE, 0)),
	ADB_ENTRY(NID_pkcs7_digest, ASN1_NDEF_EXP_OPT(PKCS7, d.digest, PKCS7_DIGEST, 0)),
	ADB_ENTRY(NID_pkcs7_encrypted, ASN1_NDEF_EXP_OPT(PKCS7, d.encrypted, PKCS7_ENCRYPT, 0))
d80 1
a80 1
ASN1_NDEF_SEQUENCE(PKCS7) = {
d83 1
a83 1
}ASN1_NDEF_SEQUENCE_END(PKCS7)
a85 1
IMPLEMENT_ASN1_NDEF_FUNCTION(PKCS7)
d88 1
a88 1
ASN1_NDEF_SEQUENCE(PKCS7_SIGNED) = {
d95 1
a95 1
} ASN1_NDEF_SEQUENCE_END(PKCS7_SIGNED)
d133 1
a133 1
ASN1_NDEF_SEQUENCE(PKCS7_ENVELOPE) = {
d137 1
a137 1
} ASN1_NDEF_SEQUENCE_END(PKCS7_ENVELOPE)
d160 1
a160 1
ASN1_NDEF_SEQUENCE(PKCS7_ENC_CONTENT) = {
d164 1
a164 1
} ASN1_NDEF_SEQUENCE_END(PKCS7_ENC_CONTENT)
d168 1
a168 1
ASN1_NDEF_SEQUENCE(PKCS7_SIGN_ENVELOPE) = {
d176 1
a176 1
} ASN1_NDEF_SEQUENCE_END(PKCS7_SIGN_ENVELOPE)
d180 1
a180 1
ASN1_NDEF_SEQUENCE(PKCS7_ENCRYPT) = {
d183 1
a183 1
} ASN1_NDEF_SEQUENCE_END(PKCS7_ENCRYPT)
d187 1
a187 1
ASN1_NDEF_SEQUENCE(PKCS7_DIGEST) = {
d192 1
a192 1
} ASN1_NDEF_SEQUENCE_END(PKCS7_DIGEST)
@


1.1.1.3
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d80 1
a80 30
/* PKCS#7 streaming support */
static int pk7_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
							void *exarg)
{
	ASN1_STREAM_ARG *sarg = exarg;
	PKCS7 **pp7 = (PKCS7 **)pval;

	switch(operation)
		{

		case ASN1_OP_STREAM_PRE:
		if (PKCS7_stream(&sarg->boundary, *pp7) <= 0)
			return 0;
		case ASN1_OP_DETACHED_PRE:
		sarg->ndef_bio = PKCS7_dataInit(*pp7, sarg->out);
		if (!sarg->ndef_bio)
			return 0;
		break;

		case ASN1_OP_STREAM_POST:
		case ASN1_OP_DETACHED_POST:
		if (PKCS7_dataFinal(*pp7, sarg->ndef_bio) <= 0)
			return 0;
		break;

		}
	return 1;
}

ASN1_NDEF_SEQUENCE_cb(PKCS7, pk7_cb) = {
d83 1
a83 1
}ASN1_NDEF_SEQUENCE_END_cb(PKCS7, PKCS7)
d101 1
a101 2
static int si_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
							void *exarg)
d143 1
a143 2
static int ri_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
d164 1
a164 1
	ASN1_IMP_OPT(PKCS7_ENC_CONTENT, enc_data, ASN1_OCTET_STRING_NDEF, 0)
a214 2

IMPLEMENT_ASN1_PRINT_FUNCTION(PKCS7)
@


