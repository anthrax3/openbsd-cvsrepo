head	1.42;
access;
symbols
	OPENBSD_6_2:1.42.0.4
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.41.0.4
	OPENBSD_6_1_BASE:1.41;
locks; strict;
comment	@ * @;


1.42
date	2017.05.02.03.59.45;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Dm63V7JYy6WzetfM;

1.41
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.40;
commitid	kT0fLt3r4lroFJra;

1.40
date	2016.12.30.15.38.13;	author jsing;	state Exp;
branches;
next	1.39;
commitid	bRjJ3rgPej1ygmFV;

1.39
date	2016.11.05.15.19.07;	author miod;	state Exp;
branches;
next	1.38;
commitid	Ms5B6ylP8je6xQgm;

1.38
date	2015.09.30.18.41.06;	author jsing;	state Exp;
branches;
next	1.37;
commitid	8UbnRNonXjerilzx;

1.37
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.36;
commitid	vHznCDK3idwNEFz4;

1.36
date	2015.07.29.14.58.34;	author jsing;	state Exp;
branches;
next	1.35;
commitid	rYgS8cWcS59JYkBV;

1.35
date	2015.07.19.18.25.59;	author miod;	state Exp;
branches;
next	1.34;
commitid	tbT3Kkk6NqiyzKgo;

1.34
date	2015.07.18.14.40.59;	author miod;	state Exp;
branches;
next	1.33;
commitid	NrpNH5PdtStO4m1P;

1.33
date	2015.07.15.17.44.20;	author miod;	state Exp;
branches;
next	1.32;
commitid	qRJRajtr1dUJtxez;

1.32
date	2015.03.19.14.00.22;	author tedu;	state Exp;
branches;
next	1.31;
commitid	Ix1rLPv61p1TR5LF;

1.31
date	2015.02.07.13.19.15;	author doug;	state Exp;
branches
	1.31.4.1;
next	1.30;
commitid	gtwLkRyWx0K1HbzX;

1.30
date	2014.10.22.13.02.04;	author jsing;	state Exp;
branches;
next	1.29;
commitid	PjnBgKe6Buhbf937;

1.29
date	2014.07.25.06.05.32;	author doug;	state Exp;
branches
	1.29.4.1;
next	1.28;
commitid	DnBLYuKKjvrWeH3R;

1.28
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.27;
commitid	G74O1dmRukKsW7IJ;

1.27
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.26;
commitid	yQEL1wOWIearrW15;

1.26
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.25;
commitid	id8dTrTMtnTn4fqt;

1.25
date	2014.07.10.12.08.50;	author miod;	state Exp;
branches;
next	1.24;
commitid	OOVNN7iJ3WcuAbmB;

1.24
date	2014.07.02.16.33.19;	author jsing;	state Exp;
branches;
next	1.23;
commitid	1vVJoRMEseAN5hJe;

1.23
date	2014.06.29.17.05.36;	author jsing;	state Exp;
branches;
next	1.22;
commitid	t0SFeQtZd9bpT5Df;

1.22
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	mJUVYpkFBZ0Zv2bG;

1.21
date	2014.05.22.21.12.16;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.06.20.17.16;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.18.21.49.19;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.18.03.28.12;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.29.05.39.24;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.25.16.09.39;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.03.16;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.58.01;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.42;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.11.08;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.31;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.45;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.41;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.11.21.16.49;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.41.48;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.14;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2011.11.03.02.32.13;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2012.10.13.21.23.42;	author djm;	state Exp;
branches;
next	;

1.29.4.1
date	2015.03.19.14.02.22;	author tedu;	state Exp;
branches;
next	;
commitid	bYTbbXa7PWk8y7To;

1.31.4.1
date	2015.03.19.14.01.16;	author tedu;	state Exp;
branches;
next	;
commitid	dQgHc1qjfDF6g1rY;


desc
@@


1.42
log
@use freezero() instead of memset/explicit_bzero + free.  Substantially
reduces conditional logic (-218, +82).

MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH cache alignment calculation bn/bn_exp.c
wasn'tt quite right.  Two other tricky bits with ASN1_STRING_FLAG_NDEF and
BN_FLG_STATIC_DATA where the condition cannot be collapsed completely.

Passes regress.  ok beck
@
text
@/* $OpenBSD: pk7_doit.c,v 1.41 2017/01/29 17:49:23 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/err.h>
#include <openssl/objects.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>

static int add_attribute(STACK_OF(X509_ATTRIBUTE) **sk, int nid, int atrtype,
    void *value);
static ASN1_TYPE *get_attribute(STACK_OF(X509_ATTRIBUTE) *sk, int nid);

static int
PKCS7_type_is_other(PKCS7* p7)
{
	int isOther = 1;

	int nid = OBJ_obj2nid(p7->type);

	switch (nid ) {
	case NID_pkcs7_data:
	case NID_pkcs7_signed:
	case NID_pkcs7_enveloped:
	case NID_pkcs7_signedAndEnveloped:
	case NID_pkcs7_digest:
	case NID_pkcs7_encrypted:
		isOther = 0;
		break;
	default:
		isOther = 1;
	}

	return isOther;

}

static ASN1_OCTET_STRING *
PKCS7_get_octet_string(PKCS7 *p7)
{
	if (PKCS7_type_is_data(p7))
		return p7->d.data;
	if (PKCS7_type_is_other(p7) && p7->d.other &&
	    (p7->d.other->type == V_ASN1_OCTET_STRING))
		return p7->d.other->value.octet_string;
	return NULL;
}

static int
PKCS7_bio_add_digest(BIO **pbio, X509_ALGOR *alg)
{
	BIO *btmp;
	const EVP_MD *md;
	if ((btmp = BIO_new(BIO_f_md())) == NULL) {
		PKCS7error(ERR_R_BIO_LIB);
		goto err;
	}

	md = EVP_get_digestbyobj(alg->algorithm);
	if (md == NULL) {
		PKCS7error(PKCS7_R_UNKNOWN_DIGEST_TYPE);
		goto err;
	}

	BIO_set_md(btmp, md);
	if (*pbio == NULL)
		*pbio = btmp;
	else if (!BIO_push(*pbio, btmp)) {
		PKCS7error(ERR_R_BIO_LIB);
		goto err;
	}
	btmp = NULL;

	return 1;

err:
	BIO_free(btmp);
	return 0;

}

static int
pkcs7_encode_rinfo(PKCS7_RECIP_INFO *ri, unsigned char *key, int keylen)
{
	EVP_PKEY_CTX *pctx = NULL;
	EVP_PKEY *pkey = NULL;
	unsigned char *ek = NULL;
	int ret = 0;
	size_t eklen;

	pkey = X509_get_pubkey(ri->cert);
	if (!pkey)
		return 0;

	pctx = EVP_PKEY_CTX_new(pkey, NULL);
	if (!pctx)
		return 0;

	if (EVP_PKEY_encrypt_init(pctx) <= 0)
		goto err;

	if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_ENCRYPT,
	    EVP_PKEY_CTRL_PKCS7_ENCRYPT, 0, ri) <= 0) {
		PKCS7error(PKCS7_R_CTRL_ERROR);
		goto err;
	}

	if (EVP_PKEY_encrypt(pctx, NULL, &eklen, key, keylen) <= 0)
		goto err;

	ek = malloc(eklen);

	if (ek == NULL) {
		PKCS7error(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (EVP_PKEY_encrypt(pctx, ek, &eklen, key, keylen) <= 0)
		goto err;

	ASN1_STRING_set0(ri->enc_key, ek, eklen);
	ek = NULL;

	ret = 1;

err:
	EVP_PKEY_free(pkey);
	EVP_PKEY_CTX_free(pctx);
	free(ek);
	return ret;
}


static int
pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen, PKCS7_RECIP_INFO *ri,
    EVP_PKEY *pkey)
{
	EVP_PKEY_CTX *pctx = NULL;
	unsigned char *ek = NULL;
	size_t eklen;

	int ret = -1;

	pctx = EVP_PKEY_CTX_new(pkey, NULL);
	if (!pctx)
		return -1;

	if (EVP_PKEY_decrypt_init(pctx) <= 0)
		goto err;

	if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DECRYPT,
	    EVP_PKEY_CTRL_PKCS7_DECRYPT, 0, ri) <= 0) {
		PKCS7error(PKCS7_R_CTRL_ERROR);
		goto err;
	}

	if (EVP_PKEY_decrypt(pctx, NULL, &eklen,
	    ri->enc_key->data, ri->enc_key->length) <= 0)
		goto err;

	ek = malloc(eklen);
	if (ek == NULL) {
		PKCS7error(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (EVP_PKEY_decrypt(pctx, ek, &eklen,
	    ri->enc_key->data, ri->enc_key->length) <= 0) {
		ret = 0;
		PKCS7error(ERR_R_EVP_LIB);
		goto err;
	}

	ret = 1;

	freezero(*pek, *peklen);

	*pek = ek;
	*peklen = eklen;

err:
	EVP_PKEY_CTX_free(pctx);
	if (!ret && ek)
		free(ek);

	return ret;
}

BIO *
PKCS7_dataInit(PKCS7 *p7, BIO *bio)
{
	int i;
	BIO *out = NULL, *btmp = NULL;
	X509_ALGOR *xa = NULL;
	const EVP_CIPHER *evp_cipher = NULL;
	STACK_OF(X509_ALGOR) *md_sk = NULL;
	STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;
	X509_ALGOR *xalg = NULL;
	PKCS7_RECIP_INFO *ri = NULL;
	ASN1_OCTET_STRING *os = NULL;

	if (p7 == NULL) {
		PKCS7error(PKCS7_R_INVALID_NULL_POINTER);
		return NULL;
	}

	/*
	 * The content field in the PKCS7 ContentInfo is optional,
	 * but that really only applies to inner content (precisely,
	 * detached signatures).
	 *
	 * When reading content, missing outer content is therefore
	 * treated as an error.
	 *
	 * When creating content, PKCS7_content_new() must be called
	 * before calling this method, so a NULL p7->d is always
	 * an error.
	 */
	if (p7->d.ptr == NULL) {
		PKCS7error(PKCS7_R_NO_CONTENT);
		return NULL;
	}

	i = OBJ_obj2nid(p7->type);
	p7->state = PKCS7_S_HEADER;

	switch (i) {
	case NID_pkcs7_signed:
		md_sk = p7->d.sign->md_algs;
		os = PKCS7_get_octet_string(p7->d.sign->contents);
		break;
	case NID_pkcs7_signedAndEnveloped:
		rsk = p7->d.signed_and_enveloped->recipientinfo;
		md_sk = p7->d.signed_and_enveloped->md_algs;
		xalg = p7->d.signed_and_enveloped->enc_data->algorithm;
		evp_cipher = p7->d.signed_and_enveloped->enc_data->cipher;
		if (evp_cipher == NULL) {
			PKCS7error(PKCS7_R_CIPHER_NOT_INITIALIZED);
			goto err;
		}
		break;
	case NID_pkcs7_enveloped:
		rsk = p7->d.enveloped->recipientinfo;
		xalg = p7->d.enveloped->enc_data->algorithm;
		evp_cipher = p7->d.enveloped->enc_data->cipher;
		if (evp_cipher == NULL) {
			PKCS7error(PKCS7_R_CIPHER_NOT_INITIALIZED);
			goto err;
		}
		break;
	case NID_pkcs7_digest:
		xa = p7->d.digest->md;
		os = PKCS7_get_octet_string(p7->d.digest->contents);
		break;
	case NID_pkcs7_data:
		break;
	default:
		PKCS7error(PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
		goto err;
	}

	for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++)
		if (!PKCS7_bio_add_digest(&out, sk_X509_ALGOR_value(md_sk, i)))
			goto err;

	if (xa && !PKCS7_bio_add_digest(&out, xa))
		goto err;

	if (evp_cipher != NULL) {
		unsigned char key[EVP_MAX_KEY_LENGTH];
		unsigned char iv[EVP_MAX_IV_LENGTH];
		int keylen, ivlen;
		EVP_CIPHER_CTX *ctx;

		if ((btmp = BIO_new(BIO_f_cipher())) == NULL) {
			PKCS7error(ERR_R_BIO_LIB);
			goto err;
		}
		BIO_get_cipher_ctx(btmp, &ctx);
		keylen = EVP_CIPHER_key_length(evp_cipher);
		ivlen = EVP_CIPHER_iv_length(evp_cipher);
		xalg->algorithm = OBJ_nid2obj(EVP_CIPHER_type(evp_cipher));
		if (ivlen > 0)
			arc4random_buf(iv, ivlen);
		if (EVP_CipherInit_ex(ctx, evp_cipher, NULL, NULL,
		    NULL, 1) <= 0)
			goto err;
		if (EVP_CIPHER_CTX_rand_key(ctx, key) <= 0)
			goto err;
		if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, 1) <= 0)
			goto err;

		if (ivlen > 0) {
			if (xalg->parameter == NULL) {
				xalg->parameter = ASN1_TYPE_new();
				if (xalg->parameter == NULL)
					goto err;
			}
			if (EVP_CIPHER_param_to_asn1(ctx, xalg->parameter) < 0)
				goto err;
		}

		/* Lets do the pub key stuff :-) */
		for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {
			ri = sk_PKCS7_RECIP_INFO_value(rsk, i);
			if (pkcs7_encode_rinfo(ri, key, keylen) <= 0)
				goto err;
		}
		explicit_bzero(key, keylen);

		if (out == NULL)
			out = btmp;
		else
			BIO_push(out, btmp);
		btmp = NULL;
	}

	if (bio == NULL) {
		if (PKCS7_is_detached(p7))
			bio = BIO_new(BIO_s_null());
		else if (os && os->length > 0)
			bio = BIO_new_mem_buf(os->data, os->length);
		if (bio == NULL) {
			bio = BIO_new(BIO_s_mem());
			if (bio == NULL)
				goto err;
			BIO_set_mem_eof_return(bio, 0);
		}
	}
	if (out)
		BIO_push(out, bio);
	else
		out = bio;
	bio = NULL;
	if (0) {
err:
		if (out != NULL)
			BIO_free_all(out);
		if (btmp != NULL)
			BIO_free_all(btmp);
		out = NULL;
	}
	return (out);
}

static int
pkcs7_cmp_ri(PKCS7_RECIP_INFO *ri, X509 *pcert)
{
	int ret;

	ret = X509_NAME_cmp(ri->issuer_and_serial->issuer,
	    pcert->cert_info->issuer);
	if (ret)
		return ret;
	return ASN1_STRING_cmp(pcert->cert_info->serialNumber,
	    ri->issuer_and_serial->serial);
}

/* int */
BIO *
PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
{
	int i, j;
	BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;
	X509_ALGOR *xa;
	ASN1_OCTET_STRING *data_body = NULL;
	const EVP_MD *evp_md;
	const EVP_CIPHER *evp_cipher = NULL;
	EVP_CIPHER_CTX *evp_ctx = NULL;
	X509_ALGOR *enc_alg = NULL;
	STACK_OF(X509_ALGOR) *md_sk = NULL;
	STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;
	PKCS7_RECIP_INFO *ri = NULL;
	unsigned char *ek = NULL, *tkey = NULL;
	int eklen = 0, tkeylen = 0;

	if (p7 == NULL) {
		PKCS7error(PKCS7_R_INVALID_NULL_POINTER);
		return NULL;
	}

	if (p7->d.ptr == NULL) {
		PKCS7error(PKCS7_R_NO_CONTENT);
		return NULL;
	}

	i = OBJ_obj2nid(p7->type);
	p7->state = PKCS7_S_HEADER;

	switch (i) {
	case NID_pkcs7_signed:
		data_body = PKCS7_get_octet_string(p7->d.sign->contents);
		md_sk = p7->d.sign->md_algs;
		break;
	case NID_pkcs7_signedAndEnveloped:
		rsk = p7->d.signed_and_enveloped->recipientinfo;
		md_sk = p7->d.signed_and_enveloped->md_algs;
		data_body = p7->d.signed_and_enveloped->enc_data->enc_data;
		enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;
		evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);
		if (evp_cipher == NULL) {
			PKCS7error(PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
			goto err;
		}
		break;
	case NID_pkcs7_enveloped:
		rsk = p7->d.enveloped->recipientinfo;
		enc_alg = p7->d.enveloped->enc_data->algorithm;
		data_body = p7->d.enveloped->enc_data->enc_data;
		evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);
		if (evp_cipher == NULL) {
			PKCS7error(PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
			goto err;
		}
		break;
	default:
		PKCS7error(PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
		goto err;
	}

	/* We will be checking the signature */
	if (md_sk != NULL) {
		for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {
			xa = sk_X509_ALGOR_value(md_sk, i);
			if ((btmp = BIO_new(BIO_f_md())) == NULL) {
				PKCS7error(ERR_R_BIO_LIB);
				goto err;
			}

			j = OBJ_obj2nid(xa->algorithm);
			evp_md = EVP_get_digestbynid(j);
			if (evp_md == NULL) {
				PKCS7error(PKCS7_R_UNKNOWN_DIGEST_TYPE);
				goto err;
			}

			BIO_set_md(btmp, evp_md);
			if (out == NULL)
				out = btmp;
			else
				BIO_push(out, btmp);
			btmp = NULL;
		}
	}

	if (evp_cipher != NULL) {
		if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {
			PKCS7error(ERR_R_BIO_LIB);
			goto err;
		}

		/* It was encrypted, we need to decrypt the secret key
		 * with the private key */

		/* Find the recipientInfo which matches the passed certificate
		 * (if any)
		 */
		if (pcert) {
			for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {
				ri = sk_PKCS7_RECIP_INFO_value(rsk, i);
				if (!pkcs7_cmp_ri(ri, pcert))
					break;
				ri = NULL;
			}
			if (ri == NULL) {
				PKCS7error(PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
				goto err;
			}
		}

		/* If we haven't got a certificate try each ri in turn */
		if (pcert == NULL) {
			/* Always attempt to decrypt all rinfo even
			 * after sucess as a defence against MMA timing
			 * attacks.
			 */
			for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {
				ri = sk_PKCS7_RECIP_INFO_value(rsk, i);

				if (pkcs7_decrypt_rinfo(&ek, &eklen,
				    ri, pkey) < 0)
					goto err;
				ERR_clear_error();
			}
		} else {
			/* Only exit on fatal errors, not decrypt failure */
			if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)
				goto err;
			ERR_clear_error();
		}

		evp_ctx = NULL;
		BIO_get_cipher_ctx(etmp, &evp_ctx);
		if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL,
		    NULL, 0) <= 0)
			goto err;
		if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0)
			goto err;
		/* Generate random key as MMA defence */
		tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);
		tkey = malloc(tkeylen);
		if (!tkey)
			goto err;
		if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)
			goto err;
		if (ek == NULL) {
			ek = tkey;
			eklen = tkeylen;
			tkey = NULL;
		}

		if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) {
			/* Some S/MIME clients don't use the same key
			 * and effective key length. The key length is
			 * determined by the size of the decrypted RSA key.
			 */
			if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen)) {
				/* Use random key as MMA defence */
				freezero(ek, eklen);
				ek = tkey;
				eklen = tkeylen;
				tkey = NULL;
			}
		}
		/* Clear errors so we don't leak information useful in MMA */
		ERR_clear_error();
		if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0)
			goto err;

		freezero(ek, eklen);
		ek = NULL;
		freezero(tkey, tkeylen);
		tkey = NULL;

		if (out == NULL)
			out = etmp;
		else
			BIO_push(out, etmp);
		etmp = NULL;
	}

	if (PKCS7_is_detached(p7) || (in_bio != NULL)) {
		bio = in_bio;
	} else {
		if (data_body != NULL && data_body->length > 0)
			bio = BIO_new_mem_buf(data_body->data, data_body->length);
		else {
			bio = BIO_new(BIO_s_mem());
			BIO_set_mem_eof_return(bio, 0);
		}
		if (bio == NULL)
			goto err;
	}
	BIO_push(out, bio);

	if (0) {
err:
		freezero(ek, eklen);
		freezero(tkey, tkeylen);
		if (out != NULL)
			BIO_free_all(out);
		if (btmp != NULL)
			BIO_free_all(btmp);
		if (etmp != NULL)
			BIO_free_all(etmp);
		out = NULL;
	}
	return (out);
}

static BIO *
PKCS7_find_digest(EVP_MD_CTX **pmd, BIO *bio, int nid)
{
	for (;;) {
		bio = BIO_find_type(bio, BIO_TYPE_MD);
		if (bio == NULL) {
			PKCS7error(PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
			return NULL;
		}
		BIO_get_md_ctx(bio, pmd);
		if (*pmd == NULL) {
			PKCS7error(ERR_R_INTERNAL_ERROR);
			return NULL;
		}
		if (EVP_MD_CTX_type(*pmd) == nid)
			return bio;
		bio = BIO_next(bio);
	}
	return NULL;
}

static int
do_pkcs7_signed_attrib(PKCS7_SIGNER_INFO *si, EVP_MD_CTX *mctx)
{
	unsigned char md_data[EVP_MAX_MD_SIZE];
	unsigned int md_len;

	/* Add signing time if not already present */
	if (!PKCS7_get_signed_attribute(si, NID_pkcs9_signingTime)) {
		if (!PKCS7_add0_attrib_signing_time(si, NULL)) {
			PKCS7error(ERR_R_MALLOC_FAILURE);
			return 0;
		}
	}

	/* Add digest */
	if (!EVP_DigestFinal_ex(mctx, md_data, &md_len)) {
		PKCS7error(ERR_R_EVP_LIB);
		return 0;
	}
	if (!PKCS7_add1_attrib_digest(si, md_data, md_len)) {
		PKCS7error(ERR_R_MALLOC_FAILURE);
		return 0;
	}

	/* Now sign the attributes */
	if (!PKCS7_SIGNER_INFO_sign(si))
		return 0;

	return 1;
}


int
PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
{
	int ret = 0;
	int i, j;
	BIO *btmp;
	PKCS7_SIGNER_INFO *si;
	EVP_MD_CTX *mdc, ctx_tmp;
	STACK_OF(X509_ATTRIBUTE) *sk;
	STACK_OF(PKCS7_SIGNER_INFO) *si_sk = NULL;
	ASN1_OCTET_STRING *os = NULL;

	if (p7 == NULL) {
		PKCS7error(PKCS7_R_INVALID_NULL_POINTER);
		return 0;
	}

	if (p7->d.ptr == NULL) {
		PKCS7error(PKCS7_R_NO_CONTENT);
		return 0;
	}

	EVP_MD_CTX_init(&ctx_tmp);
	i = OBJ_obj2nid(p7->type);
	p7->state = PKCS7_S_HEADER;

	switch (i) {
	case NID_pkcs7_data:
		os = p7->d.data;
		break;
	case NID_pkcs7_signedAndEnveloped:
		/* XXX */
		si_sk = p7->d.signed_and_enveloped->signer_info;
		os = p7->d.signed_and_enveloped->enc_data->enc_data;
		if (!os) {
			os = ASN1_OCTET_STRING_new();
			if (!os) {
				PKCS7error(ERR_R_MALLOC_FAILURE);
				goto err;
			}
			p7->d.signed_and_enveloped->enc_data->enc_data = os;
		}
		break;
	case NID_pkcs7_enveloped:
		/* XXX */
		os = p7->d.enveloped->enc_data->enc_data;
		if (!os) {
			os = ASN1_OCTET_STRING_new();
			if (!os) {
				PKCS7error(ERR_R_MALLOC_FAILURE);
				goto err;
			}
			p7->d.enveloped->enc_data->enc_data = os;
		}
		break;
	case NID_pkcs7_signed:
		si_sk = p7->d.sign->signer_info;
		os = PKCS7_get_octet_string(p7->d.sign->contents);
		if (!PKCS7_is_detached(p7) && os == NULL) {
			PKCS7error(PKCS7_R_DECODE_ERROR);
			goto err;
		}
		/* If detached data then the content is excluded */
		if (PKCS7_type_is_data(p7->d.sign->contents) && p7->detached) {
			ASN1_OCTET_STRING_free(os);
			os = NULL;
			p7->d.sign->contents->d.data = NULL;
		}
		break;

	case NID_pkcs7_digest:
		os = PKCS7_get_octet_string(p7->d.digest->contents);
		if (os == NULL) {
			PKCS7error(PKCS7_R_DECODE_ERROR);
			goto err;
		}
		/* If detached data then the content is excluded */
		if (PKCS7_type_is_data(p7->d.digest->contents) &&
		    p7->detached) {
			ASN1_OCTET_STRING_free(os);
			os = NULL;
			p7->d.digest->contents->d.data = NULL;
		}
		break;

	default:
		PKCS7error(PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
		goto err;
	}

	if (si_sk != NULL) {
		for (i = 0; i < sk_PKCS7_SIGNER_INFO_num(si_sk); i++) {
			si = sk_PKCS7_SIGNER_INFO_value(si_sk, i);
			if (si->pkey == NULL)
				continue;

			j = OBJ_obj2nid(si->digest_alg->algorithm);

			if ((btmp = PKCS7_find_digest(&mdc, bio, j)) == NULL)
				goto err;

			/* We now have the EVP_MD_CTX, lets do the
			 * signing. */
			if (!EVP_MD_CTX_copy_ex(&ctx_tmp, mdc))
				goto err;

			sk = si->auth_attr;

			/* If there are attributes, we add the digest
			 * attribute and only sign the attributes */
			if (sk_X509_ATTRIBUTE_num(sk) > 0) {
				if (!do_pkcs7_signed_attrib(si, &ctx_tmp))
					goto err;
			} else {
				unsigned char *abuf = NULL;
				unsigned int abuflen;
				abuflen = EVP_PKEY_size(si->pkey);
				abuf = malloc(abuflen);
				if (!abuf)
					goto err;

				if (!EVP_SignFinal(&ctx_tmp, abuf, &abuflen,
				    si->pkey)) {
					PKCS7error(ERR_R_EVP_LIB);
					goto err;
				}
				ASN1_STRING_set0(si->enc_digest, abuf, abuflen);
			}
		}
	} else if (i == NID_pkcs7_digest) {
		unsigned char md_data[EVP_MAX_MD_SIZE];
		unsigned int md_len;

		if (!PKCS7_find_digest(&mdc, bio,
		    OBJ_obj2nid(p7->d.digest->md->algorithm)))
			goto err;
		if (!EVP_DigestFinal_ex(mdc, md_data, &md_len))
			goto err;
		if (ASN1_STRING_set(p7->d.digest->digest, md_data,
		    md_len) == 0)
			goto err;
	}

	if (!PKCS7_is_detached(p7)) {
		/*
		 * NOTE: only reach os == NULL here because detached
		 * digested data support is broken?
		 */
		if (os == NULL)
			goto err;
		if (!(os->flags & ASN1_STRING_FLAG_NDEF)) {
			char *cont;
			long contlen;

			btmp = BIO_find_type(bio, BIO_TYPE_MEM);
			if (btmp == NULL) {
				PKCS7error(PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
				goto err;
			}
			contlen = BIO_get_mem_data(btmp, &cont);
			/*
			 * Mark the BIO read only then we can use its copy
			 * of the data instead of making an extra copy.
			 */
			BIO_set_flags(btmp, BIO_FLAGS_MEM_RDONLY);
			BIO_set_mem_eof_return(btmp, 0);
			ASN1_STRING_set0(os, (unsigned char *)cont, contlen);
		}
	}
	ret = 1;
err:
	EVP_MD_CTX_cleanup(&ctx_tmp);
	return (ret);
}

int
PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)
{
	EVP_MD_CTX mctx;
	EVP_PKEY_CTX *pctx;
	unsigned char *abuf = NULL;
	int alen;
	size_t siglen;
	const EVP_MD *md = NULL;

	md = EVP_get_digestbyobj(si->digest_alg->algorithm);
	if (md == NULL)
		return 0;

	EVP_MD_CTX_init(&mctx);
	if (EVP_DigestSignInit(&mctx, &pctx, md, NULL, si->pkey) <= 0)
		goto err;

	if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
	    EVP_PKEY_CTRL_PKCS7_SIGN, 0, si) <= 0) {
		PKCS7error(PKCS7_R_CTRL_ERROR);
		goto err;
	}

	alen = ASN1_item_i2d((ASN1_VALUE *)si->auth_attr, &abuf,
	    &PKCS7_ATTR_SIGN_it);
	if (!abuf)
		goto err;
	if (EVP_DigestSignUpdate(&mctx, abuf, alen) <= 0)
		goto err;
	free(abuf);
	abuf = NULL;
	if (EVP_DigestSignFinal(&mctx, NULL, &siglen) <= 0)
		goto err;
	abuf = malloc(siglen);
	if (!abuf)
		goto err;
	if (EVP_DigestSignFinal(&mctx, abuf, &siglen) <= 0)
		goto err;

	if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
	    EVP_PKEY_CTRL_PKCS7_SIGN, 1, si) <= 0) {
		PKCS7error(PKCS7_R_CTRL_ERROR);
		goto err;
	}

	EVP_MD_CTX_cleanup(&mctx);

	ASN1_STRING_set0(si->enc_digest, abuf, siglen);

	return 1;

err:
	free(abuf);
	EVP_MD_CTX_cleanup(&mctx);
	return 0;
}

int
PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,
    PKCS7 *p7, PKCS7_SIGNER_INFO *si)
{
	PKCS7_ISSUER_AND_SERIAL *ias;
	int ret = 0, i;
	STACK_OF(X509) *cert;
	X509 *x509;

	if (p7 == NULL) {
		PKCS7error(PKCS7_R_INVALID_NULL_POINTER);
		return 0;
	}

	if (p7->d.ptr == NULL) {
		PKCS7error(PKCS7_R_NO_CONTENT);
		return 0;
	}

	if (PKCS7_type_is_signed(p7)) {
		cert = p7->d.sign->cert;
	} else if (PKCS7_type_is_signedAndEnveloped(p7)) {
		cert = p7->d.signed_and_enveloped->cert;
	} else {
		PKCS7error(PKCS7_R_WRONG_PKCS7_TYPE);
		goto err;
	}
	/* XXXX */
	ias = si->issuer_and_serial;

	x509 = X509_find_by_issuer_and_serial(cert, ias->issuer, ias->serial);

	/* were we able to find the cert in passed to us */
	if (x509 == NULL) {
		PKCS7error(PKCS7_R_UNABLE_TO_FIND_CERTIFICATE);
		goto err;
	}

	/* Lets verify */
	if (!X509_STORE_CTX_init(ctx, cert_store, x509, cert)) {
		PKCS7error(ERR_R_X509_LIB);
		goto err;
	}
	if (X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_SMIME_SIGN) == 0) {
		X509_STORE_CTX_cleanup(ctx);
		goto err;
	}
	i = X509_verify_cert(ctx);
	if (i <= 0) {
		PKCS7error(ERR_R_X509_LIB);
		X509_STORE_CTX_cleanup(ctx);
		goto err;
	}
	X509_STORE_CTX_cleanup(ctx);

	return PKCS7_signatureVerify(bio, p7, si, x509);
err:
	
	return ret;
}

int
PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si, X509 *x509)
{
	ASN1_OCTET_STRING *os;
	EVP_MD_CTX mdc_tmp, *mdc;
	int ret = 0, i;
	int md_type;
	STACK_OF(X509_ATTRIBUTE) *sk;
	BIO *btmp;
	EVP_PKEY *pkey;

	EVP_MD_CTX_init(&mdc_tmp);

	if (!PKCS7_type_is_signed(p7) &&
	    !PKCS7_type_is_signedAndEnveloped(p7)) {
		PKCS7error(PKCS7_R_WRONG_PKCS7_TYPE);
		goto err;
	}

	md_type = OBJ_obj2nid(si->digest_alg->algorithm);

	btmp = bio;
	for (;;) {
		if ((btmp == NULL) ||
		    ((btmp = BIO_find_type(btmp, BIO_TYPE_MD)) == NULL)) {
			PKCS7error(PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
			goto err;
		}
		BIO_get_md_ctx(btmp, &mdc);
		if (mdc == NULL) {
			PKCS7error(ERR_R_INTERNAL_ERROR);
			goto err;
		}
		if (EVP_MD_CTX_type(mdc) == md_type)
			break;
		/* Workaround for some broken clients that put the signature
		 * OID instead of the digest OID in digest_alg->algorithm
		 */
		if (EVP_MD_pkey_type(EVP_MD_CTX_md(mdc)) == md_type)
			break;
		btmp = BIO_next(btmp);
	}

	/* mdc is the digest ctx that we want, unless there are attributes,
	 * in which case the digest is the signed attributes */
	if (!EVP_MD_CTX_copy_ex(&mdc_tmp, mdc))
		goto err;

	sk = si->auth_attr;
	if ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0)) {
		unsigned char md_dat[EVP_MAX_MD_SIZE], *abuf = NULL;
		unsigned int md_len;
		int alen;
		ASN1_OCTET_STRING *message_digest;

		if (!EVP_DigestFinal_ex(&mdc_tmp, md_dat, &md_len))
			goto err;
		message_digest = PKCS7_digest_from_attributes(sk);
		if (!message_digest) {
			PKCS7error(PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
			goto err;
		}
		if ((message_digest->length != (int)md_len) ||
		    (memcmp(message_digest->data, md_dat, md_len))) {
			PKCS7error(PKCS7_R_DIGEST_FAILURE);
			ret = -1;
			goto err;
		}

		if (!EVP_VerifyInit_ex(&mdc_tmp, EVP_get_digestbynid(md_type),
		    NULL))
			goto err;

		alen = ASN1_item_i2d((ASN1_VALUE *)sk, &abuf,
		    &PKCS7_ATTR_VERIFY_it);
		if (alen <= 0) {
			PKCS7error(ERR_R_ASN1_LIB);
			ret = -1;
			goto err;
		}
		if (!EVP_VerifyUpdate(&mdc_tmp, abuf, alen))
			goto err;

		free(abuf);
	}

	os = si->enc_digest;
	pkey = X509_get_pubkey(x509);
	if (!pkey) {
		ret = -1;
		goto err;
	}

	i = EVP_VerifyFinal(&mdc_tmp, os->data, os->length, pkey);
	EVP_PKEY_free(pkey);
	if (i <= 0) {
		PKCS7error(PKCS7_R_SIGNATURE_FAILURE);
		ret = -1;
		goto err;
	} else
		ret = 1;
err:
	EVP_MD_CTX_cleanup(&mdc_tmp);
	return (ret);
}

PKCS7_ISSUER_AND_SERIAL *
PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx)
{
	STACK_OF(PKCS7_RECIP_INFO) *rsk;
	PKCS7_RECIP_INFO *ri;
	int i;

	i = OBJ_obj2nid(p7->type);
	if (i != NID_pkcs7_signedAndEnveloped)
		return NULL;
	if (p7->d.signed_and_enveloped == NULL)
		return NULL;
	rsk = p7->d.signed_and_enveloped->recipientinfo;
	if (rsk == NULL)
		return NULL;
	ri = sk_PKCS7_RECIP_INFO_value(rsk, 0);
	if (sk_PKCS7_RECIP_INFO_num(rsk) <= idx)
		return (NULL);
	ri = sk_PKCS7_RECIP_INFO_value(rsk, idx);
	return (ri->issuer_and_serial);
}

ASN1_TYPE *
PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
	return (get_attribute(si->auth_attr, nid));
}

ASN1_TYPE *
PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
	return (get_attribute(si->unauth_attr, nid));
}

static ASN1_TYPE *
get_attribute(STACK_OF(X509_ATTRIBUTE) *sk, int nid)
{
	int i;
	X509_ATTRIBUTE *xa;
	ASN1_OBJECT *o;

	o = OBJ_nid2obj(nid);
	if (!o || !sk)
		return (NULL);
	for (i = 0; i < sk_X509_ATTRIBUTE_num(sk); i++) {
		xa = sk_X509_ATTRIBUTE_value(sk, i);
		if (OBJ_cmp(xa->object, o) == 0) {
			if (!xa->single && sk_ASN1_TYPE_num(xa->value.set))
				return (sk_ASN1_TYPE_value(xa->value.set, 0));
			else
				return (NULL);
		}
	}
	return (NULL);
}

ASN1_OCTET_STRING *
PKCS7_digest_from_attributes(STACK_OF(X509_ATTRIBUTE) *sk)
{
	ASN1_TYPE *astype;

	if (!(astype = get_attribute(sk, NID_pkcs9_messageDigest)))
		return NULL;
	if (astype->type != V_ASN1_OCTET_STRING)
		return NULL;
	return astype->value.octet_string;
}

int
PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si,
    STACK_OF(X509_ATTRIBUTE) *sk)
{
	int i;

	if (p7si->auth_attr != NULL)
		sk_X509_ATTRIBUTE_pop_free(p7si->auth_attr,
		    X509_ATTRIBUTE_free);
	p7si->auth_attr = sk_X509_ATTRIBUTE_dup(sk);
	if (p7si->auth_attr == NULL)
		return 0;
	for (i = 0; i < sk_X509_ATTRIBUTE_num(sk); i++) {
		if ((sk_X509_ATTRIBUTE_set(p7si->auth_attr, i,
		    X509_ATTRIBUTE_dup(sk_X509_ATTRIBUTE_value(sk, i))))
		    == NULL)
			return (0);
	}
	return (1);
}

int
PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si, STACK_OF(X509_ATTRIBUTE) *sk)
{
	int i;

	if (p7si->unauth_attr != NULL)
		sk_X509_ATTRIBUTE_pop_free(p7si->unauth_attr,
		    X509_ATTRIBUTE_free);
	p7si->unauth_attr = sk_X509_ATTRIBUTE_dup(sk);
	if (p7si->unauth_attr == NULL)
		return 0;
	for (i = 0; i < sk_X509_ATTRIBUTE_num(sk); i++) {
		if ((sk_X509_ATTRIBUTE_set(p7si->unauth_attr, i,
		    X509_ATTRIBUTE_dup(sk_X509_ATTRIBUTE_value(sk, i))))
		    == NULL)
			return (0);
	}
	return (1);
}

int
PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,
    void *value)
{
	return (add_attribute(&(p7si->auth_attr), nid, atrtype, value));
}

int
PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype, void *value)
{
	return (add_attribute(&(p7si->unauth_attr), nid, atrtype, value));
}

static int
add_attribute(STACK_OF(X509_ATTRIBUTE) **sk, int nid, int atrtype, void *value)
{
	X509_ATTRIBUTE *attr = NULL;

	if (*sk == NULL) {
		*sk = sk_X509_ATTRIBUTE_new_null();
		if (*sk == NULL)
			return 0;
new_attrib:
		if (!(attr = X509_ATTRIBUTE_create(nid, atrtype, value)))
			return 0;
		if (!sk_X509_ATTRIBUTE_push(*sk, attr)) {
			X509_ATTRIBUTE_free(attr);
			return 0;
		}
	} else {
		int i;

		for (i = 0; i < sk_X509_ATTRIBUTE_num(*sk); i++) {
			attr = sk_X509_ATTRIBUTE_value(*sk, i);
			if (OBJ_obj2nid(attr->object) == nid) {
				X509_ATTRIBUTE_free(attr);
				attr = X509_ATTRIBUTE_create(nid, atrtype,
				    value);
				if (attr == NULL)
					return 0;
				if (!sk_X509_ATTRIBUTE_set(*sk, i, attr)) {
					X509_ATTRIBUTE_free(attr);
					return 0;
				}
				goto end;
			}
		}
		goto new_attrib;
	}
end:
	return (1);
}
@


1.41
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.40 2016/12/30 15:38:13 jsing Exp $ */
d234 1
a234 4
	if (*pek) {
		explicit_bzero(*pek, *peklen);
		free(*pek);
	}
d577 1
a577 2
				explicit_bzero(ek, eklen);
				free(ek);
d588 4
a591 10
		if (ek) {
			explicit_bzero(ek, eklen);
			free(ek);
			ek = NULL;
		}
		if (tkey) {
			explicit_bzero(tkey, tkeylen);
			free(tkey);
			tkey = NULL;
		}
d616 2
a617 8
		if (ek) {
			explicit_bzero(ek, eklen);
			free(ek);
		}
		if (tkey) {
			explicit_bzero(tkey, tkeylen);
			free(tkey);
		}
@


1.40
log
@Expand ASN1_ITEM_rptr macros - no change in generated assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.39 2016/11/05 15:19:07 miod Exp $ */
d113 1
a113 1
		PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, ERR_R_BIO_LIB);
d119 1
a119 2
		PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,
		    PKCS7_R_UNKNOWN_DIGEST_TYPE);
d127 1
a127 1
		PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, ERR_R_BIO_LIB);
d162 1
a162 1
		PKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, PKCS7_R_CTRL_ERROR);
d172 1
a172 1
		PKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, ERR_R_MALLOC_FAILURE);
d211 1
a211 1
		PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, PKCS7_R_CTRL_ERROR);
d221 1
a221 1
		PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_MALLOC_FAILURE);
d228 1
a228 1
		PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_EVP_LIB);
d264 1
a264 1
		PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_INVALID_NULL_POINTER);
d281 1
a281 1
		PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_NO_CONTENT);
d299 1
a299 2
			PKCS7err(PKCS7_F_PKCS7_DATAINIT,
			    PKCS7_R_CIPHER_NOT_INITIALIZED);
d308 1
a308 2
			PKCS7err(PKCS7_F_PKCS7_DATAINIT,
			    PKCS7_R_CIPHER_NOT_INITIALIZED);
d319 1
a319 2
		PKCS7err(PKCS7_F_PKCS7_DATAINIT,
		    PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
d337 1
a337 1
			PKCS7err(PKCS7_F_PKCS7_DATAINIT, ERR_R_BIO_LIB);
d439 1
a439 2
		PKCS7err(PKCS7_F_PKCS7_DATADECODE,
		    PKCS7_R_INVALID_NULL_POINTER);
d444 1
a444 1
		PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);
d463 1
a463 2
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,
			    PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
d473 1
a473 2
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,
			    PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
d478 1
a478 2
		PKCS7err(PKCS7_F_PKCS7_DATADECODE,
		    PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
d487 1
a487 2
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
				    ERR_R_BIO_LIB);
d494 1
a494 2
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
				    PKCS7_R_UNKNOWN_DIGEST_TYPE);
d509 1
a509 1
			PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);
d527 1
a527 2
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
				    PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
d651 1
a651 2
			PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,
			    PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
d656 1
a656 2
			PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,
			    ERR_R_INTERNAL_ERROR);
d675 1
a675 2
			PKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB,
			    ERR_R_MALLOC_FAILURE);
d682 1
a682 1
		PKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_EVP_LIB);
d686 1
a686 1
		PKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_MALLOC_FAILURE);
d711 1
a711 2
		PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
		    PKCS7_R_INVALID_NULL_POINTER);
d716 1
a716 1
		PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_NO_CONTENT);
d735 1
a735 2
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
				    ERR_R_MALLOC_FAILURE);
d747 1
a747 2
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
				    ERR_R_MALLOC_FAILURE);
d757 1
a757 1
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_DECODE_ERROR);
d771 1
a771 1
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_DECODE_ERROR);
d784 1
a784 2
		PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
		    PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
d821 1
a821 2
					PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
					    ERR_R_EVP_LIB);
d854 1
a854 2
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
				    PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
d893 1
a893 1
		PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);
d915 1
a915 1
		PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);
d941 1
a941 2
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,
		    PKCS7_R_INVALID_NULL_POINTER);
d946 1
a946 1
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_NO_CONTENT);
d955 1
a955 1
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_WRONG_PKCS7_TYPE);
d965 1
a965 2
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,
		    PKCS7_R_UNABLE_TO_FIND_CERTIFICATE);
d971 1
a971 1
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);
d980 1
a980 1
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);
d1007 1
a1007 2
		PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
		    PKCS7_R_WRONG_PKCS7_TYPE);
d1017 1
a1017 2
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
			    PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
d1022 1
a1022 2
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
			    ERR_R_INTERNAL_ERROR);
d1051 1
a1051 2
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
			    PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
d1056 1
a1056 2
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
			    PKCS7_R_DIGEST_FAILURE);
d1068 1
a1068 1
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, ERR_R_ASN1_LIB);
d1088 1
a1088 2
		PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
		    PKCS7_R_SIGNATURE_FAILURE);
@


1.39
log
@More X509_STORE_CTX_set_*() return value checks.

ok beck@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.38 2015/09/30 18:41:06 jsing Exp $ */
d918 1
a918 1
	    ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));
d1093 1
a1093 1
		    ASN1_ITEM_rptr(PKCS7_ATTR_VERIFY));
@


1.38
log
@Replace M_ASN1_OCTET_STRING_(free|new) with ASN1_OCTET_STRING_(free|new).
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.37 2015/09/10 15:56:25 jsing Exp $ */
d814 1
a814 5
			btmp = bio;

			btmp = PKCS7_find_digest(&mdc, btmp, j);

			if (btmp == NULL)
d996 4
a999 1
	X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_SMIME_SIGN);
@


1.37
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.36 2015/07/29 14:58:34 jsing Exp $ */
d748 1
a748 1
			os = M_ASN1_OCTET_STRING_new();
d761 1
a761 1
			os = M_ASN1_OCTET_STRING_new();
d779 1
a779 1
			M_ASN1_OCTET_STRING_free(os);
d794 1
a794 1
			M_ASN1_OCTET_STRING_free(os);
@


1.36
log
@Expand obsolete M_ASN1.*(cmp|dup|print|set) macros - no change in generated
assembly.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.35 2015/07/19 18:25:59 miod Exp $ */
d236 1
a236 1
		OPENSSL_cleanse(*pek, *peklen);
d374 1
a374 1
		OPENSSL_cleanse(key, keylen);
d591 1
a591 1
				OPENSSL_cleanse(ek, eklen);
d604 1
a604 1
			OPENSSL_cleanse(ek, eklen);
d609 1
a609 1
			OPENSSL_cleanse(tkey, tkeylen);
d638 1
a638 1
			OPENSSL_cleanse(ek, eklen);
d642 1
a642 1
			OPENSSL_cleanse(tkey, tkeylen);
@


1.35
log
@Verify ASN1 objects types before attempting to access them as a particular
type.
ok guenther@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.34 2015/07/18 14:40:59 miod Exp $ */
d420 1
a420 1
	return M_ASN1_INTEGER_cmp(pcert->cert_info->serialNumber,
d859 1
a859 1
		if (M_ASN1_OCTET_STRING_set(p7->d.digest->digest, md_data,
@


1.34
log
@Check the return value of ASN1_STRING_set(), for it may fail to allocate
memory. Coverity CID 24810, 24846.
ok bcook@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.33 2015/07/15 17:44:20 miod Exp $ */
d1189 2
@


1.33
log
@Remove dead code. Coverity CID 21688
ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.32 2015/03/19 14:00:22 tedu Exp $ */
d853 1
d859 3
a861 1
		M_ASN1_OCTET_STRING_set(p7->d.digest->digest, md_data, md_len);
@


1.32
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.31 2015/02/07 13:19:15 doug Exp $ */
a633 1
	bio = NULL;
a650 2
		if (bio != NULL)
			BIO_free_all(bio);
@


1.31
log
@Delete a lot of #if 0 code in libressl.

There are a few instances where #if 1 is removed but the code remains.

Based on the following OpenSSL commits.  Some of the commits weren't
strictly deletions so they are going to be split up into separate commits.

6f91b017bbb7140f816721141ac156d1b828a6b3
3d47c1d331fdc7574d2275cda1a630ccdb624b08
dfb56425b68314b2b57e17c82c1df42e7a015132
c8fa2356a00cbaada8963f739e5570298311a060
f16a64d11f55c01f56baa62ebf1dec7f8fe718cb
9ccc00ef6ea65567622e40c49aca43f2c6d79cdb
02a938c953b3e1ced71d9a832de1618f907eb96d
75d0ebef2aef7a2c77b27575b8da898e22f3ccd5
d6fbb194095312f4722c81c9362dbd0de66cb656
6f1a93ad111c7dfe36a09a976c4c009079b19ea1
1a5adcfb5edfe23908b350f8757df405b0f5f71f
8de24b792743d11e1d5a0dcd336a49368750c577
a2b18e657ea1a932d125154f4e13ab2258796d90
8e964419603d2478dfb391c66e7ccb2dcc9776b4
32dfde107636ac9bc62a5b3233fe2a54dbc27008

input + ok jsing@@, miod@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.30 2014/10/22 13:02:04 jsing Exp $ */
d264 22
d442 11
d727 11
d783 1
d798 1
d864 6
a869 7
	if (!PKCS7_is_detached(p7) && !(os->flags & ASN1_STRING_FLAG_NDEF)) {
		char *cont;
		long contlen;
		btmp = BIO_find_type(bio, BIO_TYPE_MEM);
		if (btmp == NULL) {
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
			    PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
d871 18
a889 7
		contlen = BIO_get_mem_data(btmp, &cont);
		/* Mark the BIO read only then we can use its copy of the data
		 * instead of making an extra copy.
		 */
		BIO_set_flags(btmp, BIO_FLAGS_MEM_RDONLY);
		BIO_set_mem_eof_return(btmp, 0);
		ASN1_STRING_set0(os, (unsigned char *)cont, contlen);
d964 11
d1011 1
@


1.31.4.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.31 2015/02/07 13:19:15 doug Exp $ */
a263 22
	if (p7 == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_INVALID_NULL_POINTER);
		return NULL;
	}

	/*
	 * The content field in the PKCS7 ContentInfo is optional,
	 * but that really only applies to inner content (precisely,
	 * detached signatures).
	 *
	 * When reading content, missing outer content is therefore
	 * treated as an error.
	 *
	 * When creating content, PKCS7_content_new() must be called
	 * before calling this method, so a NULL p7->d is always
	 * an error.
	 */
	if (p7->d.ptr == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_NO_CONTENT);
		return NULL;
	}

a419 11
	if (p7 == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATADECODE,
		    PKCS7_R_INVALID_NULL_POINTER);
		return NULL;
	}

	if (p7->d.ptr == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);
		return NULL;
	}

a693 11
	if (p7 == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
		    PKCS7_R_INVALID_NULL_POINTER);
		return 0;
	}

	if (p7->d.ptr == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_NO_CONTENT);
		return 0;
	}

a738 1
			os = NULL;
a752 1
			os = NULL;
d818 7
a824 6
	if (!PKCS7_is_detached(p7)) {
		/*
		 * NOTE: only reach os == NULL here because detached
		 * digested data support is broken?
		 */
		if (os == NULL)
a825 18
		if (!(os->flags & ASN1_STRING_FLAG_NDEF)) {
			char *cont;
			long contlen;

			btmp = BIO_find_type(bio, BIO_TYPE_MEM);
			if (btmp == NULL) {
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
				    PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
				goto err;
			}
			contlen = BIO_get_mem_data(btmp, &cont);
			/*
			 * Mark the BIO read only then we can use its copy
			 * of the data instead of making an extra copy.
			 */
			BIO_set_flags(btmp, BIO_FLAGS_MEM_RDONLY);
			BIO_set_mem_eof_return(btmp, 0);
			ASN1_STRING_set0(os, (unsigned char *)cont, contlen);
d827 7
a907 11
	if (p7 == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,
		    PKCS7_R_INVALID_NULL_POINTER);
		return 0;
	}

	if (p7->d.ptr == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_NO_CONTENT);
		return 0;
	}

a943 1
	
@


1.30
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.29 2014/07/25 06:05:32 doug Exp $ */
a484 9
#if 0
		unsigned char key[EVP_MAX_KEY_LENGTH];
		unsigned char iv[EVP_MAX_IV_LENGTH];
		unsigned char *p;
		int keylen, ivlen;
		int max;
		X509_OBJECT ret;
#endif

a587 1
#if 1
a590 10
#if 0
		bio = BIO_new(BIO_s_mem());
		/* We need to set this so that when we have read all
		 * the data, the encrypt BIO, if present, will read
		 * EOF and encode the last few bytes */
		BIO_set_mem_eof_return(bio, 0);

		if (data_body != NULL && data_body->length > 0)
			BIO_write(bio, (char *)data_body->data, data_body->length);
#else
a598 1
#endif
d602 1
a602 1
#endif
@


1.29
log
@BIO_free() returns immediately when the sole input is NULL.
Remove unnecessary NULL check.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.28 2014/07/12 16:03:37 miod Exp $ */
d60 1
a64 1
#include <openssl/rand.h>
d327 1
a327 2
			if (RAND_pseudo_bytes(iv, ivlen) <= 0)
				goto err;
@


1.29.4.1
log
@Fix several crash causing defects from OpenSSL.
These include:
CVE-2015-0209 - Use After Free following d2i_ECPrivatekey error
CVE-2015-0286 - Segmentation fault in ASN1_TYPE_cmp
CVE-2015-0287 - ASN.1 structure reuse memory corruption
CVE-2015-0288 - X509_to_X509_REQ NULL pointer deref
CVE-2015-0289 - PKCS7 NULL pointer dereferences

Several other issues did not apply or were already fixed.
Refer to https://www.openssl.org/news/secadv_20150319.txt

joint work with beck, doug, guenther, jsing, miod
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.29 2014/07/25 06:05:32 doug Exp $ */
a263 22
	if (p7 == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_INVALID_NULL_POINTER);
		return NULL;
	}

	/*
	 * The content field in the PKCS7 ContentInfo is optional,
	 * but that really only applies to inner content (precisely,
	 * detached signatures).
	 *
	 * When reading content, missing outer content is therefore
	 * treated as an error.
	 *
	 * When creating content, PKCS7_content_new() must be called
	 * before calling this method, so a NULL p7->d is always
	 * an error.
	 */
	if (p7->d.ptr == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_NO_CONTENT);
		return NULL;
	}

a420 11
	if (p7 == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATADECODE,
		    PKCS7_R_INVALID_NULL_POINTER);
		return NULL;
	}

	if (p7->d.ptr == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);
		return NULL;
	}

a715 11
	if (p7 == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
		    PKCS7_R_INVALID_NULL_POINTER);
		return 0;
	}

	if (p7->d.ptr == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_NO_CONTENT);
		return 0;
	}

a760 1
			os = NULL;
a774 1
			os = NULL;
d840 7
a846 6
	if (!PKCS7_is_detached(p7)) {
		/*
		 * NOTE: only reach os == NULL here because detached
		 * digested data support is broken?
		 */
		if (os == NULL)
a847 18
		if (!(os->flags & ASN1_STRING_FLAG_NDEF)) {
			char *cont;
			long contlen;

			btmp = BIO_find_type(bio, BIO_TYPE_MEM);
			if (btmp == NULL) {
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
				    PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
				goto err;
			}
			contlen = BIO_get_mem_data(btmp, &cont);
			/*
			 * Mark the BIO read only then we can use its copy
			 * of the data instead of making an extra copy.
			 */
			BIO_set_flags(btmp, BIO_FLAGS_MEM_RDONLY);
			BIO_set_mem_eof_return(btmp, 0);
			ASN1_STRING_set0(os, (unsigned char *)cont, contlen);
d849 7
a929 11
	if (p7 == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,
		    PKCS7_R_INVALID_NULL_POINTER);
		return 0;
	}

	if (p7->d.ptr == NULL) {
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_NO_CONTENT);
		return 0;
	}

a965 1
	
@


1.28
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.27 2014/07/11 08:44:49 jsing Exp $ */
d136 1
a136 2
	if (btmp)
		BIO_free(btmp);
@


1.27
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.26 2014/07/10 13:58:23 jsing Exp $ */
d187 2
a188 4
	if (pkey)
		EVP_PKEY_free(pkey);
	if (pctx)
		EVP_PKEY_CTX_free(pctx);
d245 1
a245 2
	if (pctx)
		EVP_PKEY_CTX_free(pctx);
@


1.26
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.25 2014/07/10 12:08:50 miod Exp $ */
d62 2
a63 1
#include "cryptlib.h"
a64 1
#include <openssl/objects.h>
a66 1
#include <openssl/err.h>
@


1.25
log
@Remove #if 0 code which dumps your data to stdout.
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.24 2014/07/02 16:33:19 jsing Exp $ */
d60 2
@


1.24
log
@pk7_doit.c r1.20 introduced a NULL check that ensures that the signature
contents are not NULL, however this breaks detached signature processing.
Fix this by allowing the signature contents to be NULL when operating with
a detached signature.

Found the hard way by sthen@@.

ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.23 2014/06/29 17:05:36 jsing Exp $ */
a1039 8
#if 0
			{
				int ii;
				for (ii = 0; ii < message_digest->length; ii++)
					printf("%02X",message_digest->data[ii]); printf(" sent\n");
				for (ii=0; ii<md_len; ii++) printf("%02X",md_dat[ii]); printf(" calc\n");
			}
#endif
@


1.23
log
@KNF.

I just spent too long chasing a bug in here and really should have done
this first. Gem of the day... is it an if test or a for loop? No, it is a
super ifloop!

if (!(flags & PKCS7_NOVERIFY)) for (k = 0; k < sk_X509_num(signers); k++) {
@
text
@d1 1
a1 1
/* $OpenBSD: pk7_doit.c,v 1.22 2014/06/12 15:49:30 deraadt Exp $ */
d757 1
a757 1
		if (os == NULL) {
@


1.22
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d68 1
a68 1
			 void *value);
d71 6
a76 5
static int PKCS7_type_is_other(PKCS7* p7)
	{
	int isOther=1;
	
	int nid=OBJ_obj2nid(p7->type);
d78 1
a78 2
	switch( nid )
		{
d85 1
a85 1
		isOther=0;
d88 2
a89 2
		isOther=1;
		}
d93 1
a93 1
	}
d95 4
a98 3
static ASN1_OCTET_STRING *PKCS7_get_octet_string(PKCS7 *p7)
	{
	if ( PKCS7_type_is_data(p7))
d100 2
a101 2
	if ( PKCS7_type_is_other(p7) && p7->d.other
		&& (p7->d.other->type == V_ASN1_OCTET_STRING))
d104 1
a104 1
	}
d106 3
a108 2
static int PKCS7_bio_add_digest(BIO **pbio, X509_ALGOR *alg)
	{
d111 2
a112 3
	if ((btmp=BIO_new(BIO_f_md())) == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,ERR_R_BIO_LIB);
d114 1
a114 1
		}
d116 4
a119 4
	md=EVP_get_digestbyobj(alg->algorithm);
	if (md == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,PKCS7_R_UNKNOWN_DIGEST_TYPE);
d121 1
a121 1
		}
d123 1
a123 1
	BIO_set_md(btmp,md);
d125 3
a127 4
		*pbio=btmp;
	else if (!BIO_push(*pbio,btmp))
		{
		PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,ERR_R_BIO_LIB);
d129 2
a130 2
		}
	btmp=NULL;
d134 1
a134 1
	err:
d139 1
a139 1
	}
d141 3
a143 3
static int pkcs7_encode_rinfo(PKCS7_RECIP_INFO *ri,
					unsigned char *key, int keylen)
	{
a150 1

d162 1
a162 2
				EVP_PKEY_CTRL_PKCS7_ENCRYPT, 0, ri) <= 0)
		{
d165 1
a165 1
		}
d172 1
a172 2
	if (ek == NULL)
		{
d175 1
a175 1
		}
d185 1
a185 1
	err:
d192 1
a193 1
	}
d195 4
a198 4

static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,
			       PKCS7_RECIP_INFO *ri, EVP_PKEY *pkey)
	{
d213 1
a213 2
				EVP_PKEY_CTRL_PKCS7_DECRYPT, 0, ri) <= 0)
		{
d216 1
a216 1
		}
d219 1
a219 1
				ri->enc_key->data, ri->enc_key->length) <= 0)
d223 1
a223 3

	if (ek == NULL)
		{
d226 1
a226 1
		}
d229 1
a229 2
				ri->enc_key->data, ri->enc_key->length) <= 0)
		{
d233 1
a233 1
		}
d237 1
a237 2
	if (*pek)
		{
d240 1
a240 1
		}
d245 1
a245 1
	err:
d252 1
a252 1
	}
d254 3
a256 2
BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
	{
d258 1
a258 1
	BIO *out=NULL,*btmp=NULL;
d260 6
a265 6
	const EVP_CIPHER *evp_cipher=NULL;
	STACK_OF(X509_ALGOR) *md_sk=NULL;
	STACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;
	X509_ALGOR *xalg=NULL;
	PKCS7_RECIP_INFO *ri=NULL;
	ASN1_OCTET_STRING *os=NULL;
d267 2
a268 2
	i=OBJ_obj2nid(p7->type);
	p7->state=PKCS7_S_HEADER;
d270 1
a270 2
	switch (i)
		{
d272 1
a272 1
		md_sk=p7->d.sign->md_algs;
d276 5
a280 6
		rsk=p7->d.signed_and_enveloped->recipientinfo;
		md_sk=p7->d.signed_and_enveloped->md_algs;
		xalg=p7->d.signed_and_enveloped->enc_data->algorithm;
		evp_cipher=p7->d.signed_and_enveloped->enc_data->cipher;
		if (evp_cipher == NULL)
			{
d282 1
a282 1
						PKCS7_R_CIPHER_NOT_INITIALIZED);
d284 1
a284 1
			}
d287 4
a290 5
		rsk=p7->d.enveloped->recipientinfo;
		xalg=p7->d.enveloped->enc_data->algorithm;
		evp_cipher=p7->d.enveloped->enc_data->cipher;
		if (evp_cipher == NULL)
			{
d292 1
a292 1
						PKCS7_R_CIPHER_NOT_INITIALIZED);
d294 1
a294 1
			}
d303 4
a306 3
		PKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
	        goto err;
		}
d308 1
a308 1
	for (i=0; i<sk_X509_ALGOR_num(md_sk); i++)
d313 1
a313 1
			goto err;
d315 1
a315 2
	if (evp_cipher != NULL)
		{
d318 1
a318 1
		int keylen,ivlen;
d321 2
a322 3
		if ((btmp=BIO_new(BIO_f_cipher())) == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_BIO_LIB);
d324 1
a324 1
			}
d326 2
a327 2
		keylen=EVP_CIPHER_key_length(evp_cipher);
		ivlen=EVP_CIPHER_iv_length(evp_cipher);
d330 1
a330 1
			if (RAND_pseudo_bytes(iv,ivlen) <= 0)
d332 2
a333 1
		if (EVP_CipherInit_ex(ctx, evp_cipher, NULL, NULL, NULL, 1)<=0)
d346 1
a346 1
			if(EVP_CIPHER_param_to_asn1(ctx, xalg->parameter) < 0)
d351 2
a352 3
		for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)
			{
			ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
d355 1
a355 1
			}
d359 1
a359 1
			out=btmp;
d361 3
a363 3
			BIO_push(out,btmp);
		btmp=NULL;
		}
d365 1
a365 2
	if (bio == NULL)
		{
d367 1
a367 1
			bio=BIO_new(BIO_s_null());
d370 2
a371 3
		if(bio == NULL)
			{
			bio=BIO_new(BIO_s_mem());
d374 1
a374 2
			BIO_set_mem_eof_return(bio,0);
			}
d376 1
d378 1
a378 1
		BIO_push(out,bio);
d381 2
a382 3
	bio=NULL;
	if (0)
		{
d388 1
a388 3
		out=NULL;
		}
	return(out);
d390 2
d393 3
a395 2
static int pkcs7_cmp_ri(PKCS7_RECIP_INFO *ri, X509 *pcert)
	{
d397 1
d399 1
a399 1
				pcert->cert_info->issuer);
d403 2
a404 2
					ri->issuer_and_serial->serial);
	}
d407 5
a411 4
BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
	{
	int i,j;
	BIO *out=NULL,*btmp=NULL,*etmp=NULL,*bio=NULL;
d413 1
a413 1
	ASN1_OCTET_STRING *data_body=NULL;
d415 8
a422 8
	const EVP_CIPHER *evp_cipher=NULL;
	EVP_CIPHER_CTX *evp_ctx=NULL;
	X509_ALGOR *enc_alg=NULL;
	STACK_OF(X509_ALGOR) *md_sk=NULL;
	STACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;
	PKCS7_RECIP_INFO *ri=NULL;
       unsigned char *ek = NULL, *tkey = NULL;
       int eklen = 0, tkeylen = 0;
d424 2
a425 2
	i=OBJ_obj2nid(p7->type);
	p7->state=PKCS7_S_HEADER;
d427 1
a427 2
	switch (i)
		{
d429 2
a430 2
		data_body=PKCS7_get_octet_string(p7->d.sign->contents);
		md_sk=p7->d.sign->md_algs;
d433 8
a440 8
		rsk=p7->d.signed_and_enveloped->recipientinfo;
		md_sk=p7->d.signed_and_enveloped->md_algs;
		data_body=p7->d.signed_and_enveloped->enc_data->enc_data;
		enc_alg=p7->d.signed_and_enveloped->enc_data->algorithm;
		evp_cipher=EVP_get_cipherbyobj(enc_alg->algorithm);
		if (evp_cipher == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
d442 1
a442 1
			}
d445 7
a451 7
		rsk=p7->d.enveloped->recipientinfo;
		enc_alg=p7->d.enveloped->enc_data->algorithm;
		data_body=p7->d.enveloped->enc_data->enc_data;
		evp_cipher=EVP_get_cipherbyobj(enc_alg->algorithm);
		if (evp_cipher == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
d453 1
a453 1
			}
d456 4
a459 3
		PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
	        goto err;
		}
d462 6
a467 8
	if (md_sk != NULL)
		{
		for (i=0; i<sk_X509_ALGOR_num(md_sk); i++)
			{
			xa=sk_X509_ALGOR_value(md_sk,i);
			if ((btmp=BIO_new(BIO_f_md())) == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);
d469 1
a469 1
				}
d471 5
a475 5
			j=OBJ_obj2nid(xa->algorithm);
			evp_md=EVP_get_digestbynid(j);
			if (evp_md == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNKNOWN_DIGEST_TYPE);
d477 1
a477 1
				}
d479 1
a479 1
			BIO_set_md(btmp,evp_md);
d481 1
a481 1
				out=btmp;
d483 2
a484 3
				BIO_push(out,btmp);
			btmp=NULL;
			}
d486 1
d488 1
a488 2
	if (evp_cipher != NULL)
		{
d493 1
a493 1
		int keylen,ivlen;
d498 2
a499 3
		if ((etmp=BIO_new(BIO_f_cipher())) == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);
d501 1
a501 1
			}
d509 3
a511 6

		if (pcert)
			{
			for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)
				{
				ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
d514 3
a516 4
				ri=NULL;
				}
			if (ri == NULL)
				{
d518 1
a518 1
				      PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
a519 1
				}
d521 1
d524 1
a524 2
		if (pcert == NULL)
			{
d529 3
a531 4
			for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)
				{
				ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
				
d533 1
a533 1
							ri, pkey) < 0)
a535 1
				}
d537 1
a537 2
		else
			{
d542 1
a542 1
			}
d544 4
a547 3
		evp_ctx=NULL;
		BIO_get_cipher_ctx(etmp,&evp_ctx);
		if (EVP_CipherInit_ex(evp_ctx,evp_cipher,NULL,NULL,NULL,0) <= 0)
d549 1
a549 1
		if (EVP_CIPHER_asn1_to_param(evp_ctx,enc_alg->parameter) < 0)
d558 1
a558 2
		if (ek == NULL)
			{
d562 1
a562 1
			}
d569 1
a569 2
			if(!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen))
				{
d576 2
a577 2
				}
		} 
d580 1
a580 1
		if (EVP_CipherInit_ex(evp_ctx,NULL,NULL,ek,NULL,0) <= 0)
d583 2
a584 3
		if (ek)
			{
			OPENSSL_cleanse(ek,eklen);
d586 4
a589 5
                       ek = NULL;
			}
		if (tkey)
			{
			OPENSSL_cleanse(tkey,tkeylen);
d591 2
a592 2
                       tkey = NULL;
			}
d595 1
a595 1
			out=etmp;
d597 3
a599 3
			BIO_push(out,etmp);
		etmp=NULL;
		}
d602 3
a604 6
	if (PKCS7_is_detached(p7) || (in_bio != NULL))
		{
		bio=in_bio;
		}
	else 
		{
d606 1
a606 1
		bio=BIO_new(BIO_s_mem());
d610 1
a610 1
		BIO_set_mem_eof_return(bio,0);
d613 1
a613 1
			BIO_write(bio,(char *)data_body->data,data_body->length);
d616 1
a616 1
		      bio = BIO_new_mem_buf(data_body->data,data_body->length);
d618 2
a619 2
			bio=BIO_new(BIO_s_mem());
			BIO_set_mem_eof_return(bio,0);
d624 3
a626 3
		}
	BIO_push(out,bio);
	bio=NULL;
d628 1
a628 2
	if (0)
		{
d630 35
a664 33
               if (ek)
                       {
                       OPENSSL_cleanse(ek,eklen);
                       free(ek);
                       }
               if (tkey)
                       {
                       OPENSSL_cleanse(tkey,tkeylen);
                       free(tkey);
                       }
		if (out != NULL) BIO_free_all(out);
		if (btmp != NULL) BIO_free_all(btmp);
		if (etmp != NULL) BIO_free_all(etmp);
		if (bio != NULL) BIO_free_all(bio);
		out=NULL;
		}
	return(out);
	}

static BIO *PKCS7_find_digest(EVP_MD_CTX **pmd, BIO *bio, int nid)
	{
	for (;;)
		{
		bio=BIO_find_type(bio,BIO_TYPE_MD);
		if (bio == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
			return NULL;	
			}
		BIO_get_md_ctx(bio,pmd);
		if (*pmd == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,ERR_R_INTERNAL_ERROR);
d666 1
a666 1
			}	
d669 2
a670 2
		bio=BIO_next(bio);
		}
d672 1
a672 1
	}
d674 3
a676 2
static int do_pkcs7_signed_attrib(PKCS7_SIGNER_INFO *si, EVP_MD_CTX *mctx)
	{
d681 2
a682 4
	if (!PKCS7_get_signed_attribute(si, NID_pkcs9_signingTime))
		{
		if (!PKCS7_add0_attrib_signing_time(si, NULL))
			{
d684 1
a684 1
					ERR_R_MALLOC_FAILURE);
a685 1
			}
d687 1
d690 1
a690 2
	if (!EVP_DigestFinal_ex(mctx, md_data,&md_len))
		{
d693 2
a694 3
		}
	if (!PKCS7_add1_attrib_digest(si, md_data, md_len))
		{
d697 1
a697 1
		}
d701 1
a701 1
			return 0;
d704 8
a711 7
	}
	
				
int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
	{
	int ret=0;
	int i,j;
d714 1
a714 1
	EVP_MD_CTX *mdc,ctx_tmp;
d716 2
a717 2
	STACK_OF(PKCS7_SIGNER_INFO) *si_sk=NULL;
	ASN1_OCTET_STRING *os=NULL;
d720 2
a721 2
	i=OBJ_obj2nid(p7->type);
	p7->state=PKCS7_S_HEADER;
d723 1
a723 2
	switch (i)
		{
d729 1
a729 1
		si_sk=p7->d.signed_and_enveloped->signer_info;
d731 5
a735 6
		if (!os)
			{
			os=M_ASN1_OCTET_STRING_new();
			if (!os)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);
a736 2
				}
			p7->d.signed_and_enveloped->enc_data->enc_data=os;
d738 2
d744 5
a748 6
		if (!os)
			{
			os=M_ASN1_OCTET_STRING_new();
			if (!os)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);
a749 2
				}
			p7->d.enveloped->enc_data->enc_data=os;
d751 2
d755 2
a756 2
		si_sk=p7->d.sign->signer_info;
		os=PKCS7_get_octet_string(p7->d.sign->contents);
d759 1
a759 1
	        	goto err;
d762 1
a762 1
		if(PKCS7_type_is_data(p7->d.sign->contents) && p7->detached) {
d769 1
a769 1
		os=PKCS7_get_octet_string(p7->d.digest->contents);
d772 1
a772 1
	        	goto err;
d775 2
a776 2
		if(PKCS7_type_is_data(p7->d.digest->contents) && p7->detached)
			{
d779 1
a779 1
			}
d783 4
a786 3
		PKCS7err(PKCS7_F_PKCS7_DATAFINAL,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
	        goto err;
		}
d788 3
a790 5
	if (si_sk != NULL)
		{
		for (i=0; i<sk_PKCS7_SIGNER_INFO_num(si_sk); i++)
			{
			si=sk_PKCS7_SIGNER_INFO_value(si_sk,i);
d796 1
a796 1
			btmp=bio;
d805 1
a805 1
			if (!EVP_MD_CTX_copy_ex(&ctx_tmp,mdc))
d808 1
a808 1
			sk=si->auth_attr;
d812 1
a812 2
			if (sk_X509_ATTRIBUTE_num(sk) > 0)
				{
d815 1
a815 3
				}
			else
				{
d824 1
a824 2
							si->pkey))
					{
d826 1
a826 1
							ERR_R_EVP_LIB);
d828 1
a828 1
					}
a829 1
				}
d832 1
a832 2
	else if (i == NID_pkcs7_digest)
		{
d836 1
a836 1
				OBJ_obj2nid(p7->d.digest->md->algorithm)))
d838 1
a838 1
		if (!EVP_DigestFinal_ex(mdc,md_data,&md_len))
d841 1
a841 1
		}
d843 1
a843 2
	if (!PKCS7_is_detached(p7) && !(os->flags & ASN1_STRING_FLAG_NDEF))
		{
d846 4
a849 4
		btmp=BIO_find_type(bio,BIO_TYPE_MEM);
		if (btmp == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL,PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
d851 1
a851 1
			}
d859 2
a860 2
		}
	ret=1;
d863 2
a864 2
	return(ret);
	}
d866 3
a868 2
int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)
	{
d881 1
a881 1
	if (EVP_DigestSignInit(&mctx, &pctx, md,NULL, si->pkey) <= 0)
d885 1
a885 2
				EVP_PKEY_CTRL_PKCS7_SIGN, 0, si) <= 0)
		{
d888 1
a888 1
		}
d890 3
a892 3
	alen = ASN1_item_i2d((ASN1_VALUE *)si->auth_attr,&abuf,
				ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));
	if(!abuf)
d894 1
a894 1
	if (EVP_DigestSignUpdate(&mctx,abuf,alen) <= 0)
d901 1
a901 1
	if(!abuf)
d907 1
a907 2
				EVP_PKEY_CTRL_PKCS7_SIGN, 1, si) <= 0)
		{
d910 1
a910 1
		}
d918 1
a918 1
	err:
d922 1
d924 4
a927 5
	}

int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,
	     PKCS7 *p7, PKCS7_SIGNER_INFO *si)
	{
d929 1
a929 1
	int ret=0,i;
d933 6
a938 11
	if (PKCS7_type_is_signed(p7))
		{
		cert=p7->d.sign->cert;
		}
	else if (PKCS7_type_is_signedAndEnveloped(p7))
		{
		cert=p7->d.signed_and_enveloped->cert;
		}
	else
		{
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_WRONG_PKCS7_TYPE);
d940 1
a940 1
		}
d942 1
a942 1
	ias=si->issuer_and_serial;
d944 1
a944 1
	x509=X509_find_by_issuer_and_serial(cert,ias->issuer,ias->serial);
d947 3
a949 3
	if (x509 == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_UNABLE_TO_FIND_CERTIFICATE);
d951 1
a951 1
		}
d954 2
a955 3
	if(!X509_STORE_CTX_init(ctx,cert_store,x509,cert))
		{
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,ERR_R_X509_LIB);
d957 1
a957 1
		}
d959 3
a961 4
	i=X509_verify_cert(ctx);
	if (i <= 0) 
		{
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,ERR_R_X509_LIB);
d964 1
a964 1
		}
d968 1
a968 1
	err:
d970 1
a970 1
	}
d972 3
a974 3
int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
								X509 *x509)
	{
d976 2
a977 2
	EVP_MD_CTX mdc_tmp,*mdc;
	int ret=0,i;
d985 2
a986 2
	if (!PKCS7_type_is_signed(p7) && 
				!PKCS7_type_is_signedAndEnveloped(p7)) {
d988 1
a988 1
						PKCS7_R_WRONG_PKCS7_TYPE);
d992 1
a992 1
	md_type=OBJ_obj2nid(si->digest_alg->algorithm);
d994 2
a995 3
	btmp=bio;
	for (;;)
		{
d997 1
a997 2
			((btmp=BIO_find_type(btmp,BIO_TYPE_MD)) == NULL))
			{
d999 1
a999 1
					PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
d1001 3
a1003 4
			}
		BIO_get_md_ctx(btmp,&mdc);
		if (mdc == NULL)
			{
d1005 1
a1005 1
							ERR_R_INTERNAL_ERROR);
d1007 1
a1007 1
			}
d1015 2
a1016 2
		btmp=BIO_next(btmp);
		}
d1020 1
a1020 1
	if (!EVP_MD_CTX_copy_ex(&mdc_tmp,mdc))
d1023 2
a1024 3
	sk=si->auth_attr;
	if ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0))
		{
d1026 1
a1026 1
                unsigned int md_len;
d1030 1
a1030 1
		if (!EVP_DigestFinal_ex(&mdc_tmp,md_dat,&md_len))
d1032 2
a1033 3
		message_digest=PKCS7_digest_from_attributes(sk);
		if (!message_digest)
			{
d1035 1
a1035 1
					PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
d1037 1
a1037 1
			}
d1039 2
a1040 1
			(memcmp(message_digest->data,md_dat,md_len)))
d1042 5
a1046 7
#if 0
{
int ii;
for (ii=0; ii<message_digest->length; ii++)
	printf("%02X",message_digest->data[ii]); printf(" sent\n");
for (ii=0; ii<md_len; ii++) printf("%02X",md_dat[ii]); printf(" calc\n");
}
d1049 2
a1050 2
							PKCS7_R_DIGEST_FAILURE);
			ret= -1;
d1052 1
a1052 1
			}
d1054 2
a1055 1
		if (!EVP_VerifyInit_ex(&mdc_tmp,EVP_get_digestbynid(md_type), NULL))
d1059 3
a1061 4
						ASN1_ITEM_rptr(PKCS7_ATTR_VERIFY));
		if (alen <= 0) 
			{
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,ERR_R_ASN1_LIB);
d1064 1
a1064 1
			}
d1069 1
a1069 1
		}
d1071 1
a1071 1
	os=si->enc_digest;
d1073 1
a1073 2
	if (!pkey)
		{
d1076 1
a1076 1
		}
d1078 1
a1078 1
	i=EVP_VerifyFinal(&mdc_tmp,os->data,os->length, pkey);
d1080 1
a1080 2
	if (i <= 0)
		{
d1082 2
a1083 2
						PKCS7_R_SIGNATURE_FAILURE);
		ret= -1;
d1085 2
a1086 3
		}
	else
		ret=1;
d1089 2
a1090 2
	return(ret);
	}
d1092 3
a1094 2
PKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx)
	{
d1099 1
a1099 1
	i=OBJ_obj2nid(p7->type);
d1104 1
a1104 1
	rsk=p7->d.signed_and_enveloped->recipientinfo;
d1107 6
a1112 5
	ri=sk_PKCS7_RECIP_INFO_value(rsk,0);
	if (sk_PKCS7_RECIP_INFO_num(rsk) <= idx) return(NULL);
	ri=sk_PKCS7_RECIP_INFO_value(rsk,idx);
	return(ri->issuer_and_serial);
	}
d1114 5
a1118 4
ASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid)
	{
	return(get_attribute(si->auth_attr,nid));
	}
d1120 5
a1124 4
ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
	{
	return(get_attribute(si->unauth_attr,nid));
	}
d1126 3
a1128 2
static ASN1_TYPE *get_attribute(STACK_OF(X509_ATTRIBUTE) *sk, int nid)
	{
d1133 6
a1138 7
	o=OBJ_nid2obj(nid);
	if (!o || !sk) return(NULL);
	for (i=0; i<sk_X509_ATTRIBUTE_num(sk); i++)
		{
		xa=sk_X509_ATTRIBUTE_value(sk,i);
		if (OBJ_cmp(xa->object,o) == 0)
			{
d1140 1
a1140 1
				return(sk_ASN1_TYPE_value(xa->value.set,0));
d1142 1
a1142 2
				return(NULL);
			}
a1143 1
	return(NULL);
d1145 2
d1148 2
a1149 1
ASN1_OCTET_STRING *PKCS7_digest_from_attributes(STACK_OF(X509_ATTRIBUTE) *sk)
d1152 3
a1154 1
	if(!(astype = get_attribute(sk, NID_pkcs9_messageDigest))) return NULL;
d1158 4
a1161 3
int PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si,
				STACK_OF(X509_ATTRIBUTE) *sk)
	{
d1165 3
a1167 2
		sk_X509_ATTRIBUTE_pop_free(p7si->auth_attr,X509_ATTRIBUTE_free);
	p7si->auth_attr=sk_X509_ATTRIBUTE_dup(sk);
d1170 3
a1172 4
	for (i=0; i<sk_X509_ATTRIBUTE_num(sk); i++)
		{
		if ((sk_X509_ATTRIBUTE_set(p7si->auth_attr,i,
			X509_ATTRIBUTE_dup(sk_X509_ATTRIBUTE_value(sk,i))))
d1174 1
a1174 3
			return(0);
		}
	return(1);
d1176 2
d1179 3
a1181 2
int PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si, STACK_OF(X509_ATTRIBUTE) *sk)
	{
d1186 2
a1187 2
					   X509_ATTRIBUTE_free);
	p7si->unauth_attr=sk_X509_ATTRIBUTE_dup(sk);
d1190 3
a1192 4
	for (i=0; i<sk_X509_ATTRIBUTE_num(sk); i++)
		{
		if ((sk_X509_ATTRIBUTE_set(p7si->unauth_attr,i,
                        X509_ATTRIBUTE_dup(sk_X509_ATTRIBUTE_value(sk,i))))
d1194 1
a1194 3
			return(0);
		}
	return(1);
d1196 2
d1199 6
a1204 5
int PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,
	     void *value)
	{
	return(add_attribute(&(p7si->auth_attr),nid,atrtype,value));
	}
d1206 5
a1210 5
int PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,
	     void *value)
	{
	return(add_attribute(&(p7si->unauth_attr),nid,atrtype,value));
	}
d1212 4
a1215 4
static int add_attribute(STACK_OF(X509_ATTRIBUTE) **sk, int nid, int atrtype,
			 void *value)
	{
	X509_ATTRIBUTE *attr=NULL;
d1217 1
a1217 2
	if (*sk == NULL)
		{
d1220 1
a1220 1
			return 0;	
d1222 1
a1222 1
		if (!(attr=X509_ATTRIBUTE_create(nid,atrtype,value)))
d1224 1
a1224 2
		if (!sk_X509_ATTRIBUTE_push(*sk,attr))
			{
a1226 1
			}
d1228 1
a1228 2
	else
		{
d1231 3
a1233 5
		for (i=0; i<sk_X509_ATTRIBUTE_num(*sk); i++)
			{
			attr=sk_X509_ATTRIBUTE_value(*sk,i);
			if (OBJ_obj2nid(attr->object) == nid)
				{
d1235 2
a1236 1
				attr=X509_ATTRIBUTE_create(nid,atrtype,value);
d1239 1
a1239 2
				if (!sk_X509_ATTRIBUTE_set(*sk,i,attr))
					{
d1242 1
a1242 1
					}
a1243 1
				}
d1245 1
d1247 1
a1247 1
		}
d1249 2
a1250 3
	return(1);
	}

@


1.21
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d1 1
a1 1
/* crypto/pkcs7/pk7_doit.c */
@


1.20
log
@Make sure PKCS7_get_octet_string() return values are checked for NULL.
Reported by David Ramos (and simultaneously to OpenSSL as PR#3339).

ok beck@@ logan@@
@
text
@d193 1
a193 2
	if (ek)
		free(ek);
@


1.19
log
@XXXXXXXXXXXXXXXX -> XXX
XXXXXXXXXXXXXXXXXXXXXXX -> XXXX
@
text
@d642 1
a642 1
		if (data_body->length > 0)
d645 1
a645 1
		if (data_body->length > 0)
d791 4
d804 4
@


1.18
log
@fix another potential double free
ok miod@@ lteo@@ jca@@
@
text
@d760 1
a760 1
		/* XXXXXXXXXXXXXXXX */
d775 1
a775 1
		/* XXXXXXXXXXXXXXXX */
d981 1
a981 1
	/* XXXXXXXXXXXXXXXXXXXXXXX */
@


1.17
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d931 1
d954 1
a954 2
	if (abuf)
		free(abuf);
@


1.16
log
@resolve conflicts
@
text
@d172 1
a172 1
	ek = OPENSSL_malloc(eklen);
d194 1
a194 1
		OPENSSL_free(ek);
d227 1
a227 1
	ek = OPENSSL_malloc(eklen);
d248 1
a248 1
		OPENSSL_free(*pek);
d258 1
a258 1
		OPENSSL_free(ek);
d576 1
a576 1
		tkey = OPENSSL_malloc(tkeylen);
d597 1
a597 1
				OPENSSL_free(ek);
d611 1
a611 1
			OPENSSL_free(ek);
d617 1
a617 1
			OPENSSL_free(tkey);
d664 1
a664 1
                       OPENSSL_free(ek);
d669 1
a669 1
                       OPENSSL_free(tkey);
d849 1
a849 1
				abuf = OPENSSL_malloc(abuflen);
d930 1
a930 1
	OPENSSL_free(abuf);
d933 1
a933 1
	abuf = OPENSSL_malloc(siglen);
d954 1
a954 1
		OPENSSL_free(abuf);
d1116 1
a1116 1
		OPENSSL_free(abuf);
@


1.15
log
@openssl-1.0.0e: resolve conflicts
@
text
@d207 1
a207 1
	int ret = 0;
d211 1
a211 1
		return 0;
d238 1
d245 6
d433 2
a511 2
		unsigned char *ek = NULL;
		int eklen;
a543 1

d546 4
d553 1
d555 2
a556 2
							ri, pkey) > 0)
					break;
a557 7
				ri = NULL;
				}
			if (ri == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
				      PKCS7_R_NO_RECIPIENT_MATCHES_KEY);
				goto err;
d562 2
a563 1
			if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) <= 0)
d565 1
d574 13
d595 6
a600 3
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
					PKCS7_R_DECRYPTED_KEY_IS_WRONG_LENGTH);
				goto err;
d603 2
d612 7
d661 10
d720 5
a724 1
	EVP_DigestFinal_ex(mctx, md_data,&md_len);
d832 2
a833 1
			EVP_MD_CTX_copy_ex(&ctx_tmp,mdc);
d871 2
a872 1
		EVP_DigestFinal_ex(mdc,md_data,&md_len);
d1065 2
a1066 1
	EVP_MD_CTX_copy_ex(&mdc_tmp,mdc);
d1076 2
a1077 1
		EVP_DigestFinal_ex(&mdc_tmp,md_dat,&md_len);
d1102 2
a1103 1
		EVP_VerifyInit_ex(&mdc_tmp,EVP_get_digestbynid(md_type), NULL);
d1113 2
a1114 1
		EVP_VerifyUpdate(&mdc_tmp, abuf, alen);
@


1.14
log
@resolve conflicts, fix local changes
@
text
@a424 1
	X509_ALGOR *xalg=NULL;
a446 1
		xalg=p7->d.signed_and_enveloped->enc_data->algorithm;
a457 1
		xalg=p7->d.enveloped->enc_data->algorithm;
@


1.13
log
@resolve conflicts
@
text
@d141 115
a265 1
	EVP_PKEY *pkey;
d304 2
a322 2
		int jj,max;
		unsigned char *tmp;
d351 1
a351 1
			       goto err;
a354 1
		max=0;
d358 1
a358 6
			if (ri->cert == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_MISSING_CERIPEND_INFO);
				goto err;
				}
			if ((pkey=X509_get_pubkey(ri->cert)) == NULL)
a359 8
			jj=EVP_PKEY_size(pkey);
			EVP_PKEY_free(pkey);
			if (max < jj) max=jj;
			}
		if ((tmp=(unsigned char *)OPENSSL_malloc(max)) == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_MALLOC_FAILURE);
			goto err;
a360 22
		for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)
			{
			ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
			if ((pkey=X509_get_pubkey(ri->cert)) == NULL)
				goto err;
			jj=EVP_PKEY_encrypt(tmp,key,keylen,pkey);
			EVP_PKEY_free(pkey);
			if (jj <= 0)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_EVP_LIB);
				OPENSSL_free(tmp);
				goto err;
				}
			if (!M_ASN1_OCTET_STRING_set(ri->enc_key,tmp,jj))
				{
				PKCS7err(PKCS7_F_PKCS7_DATAINIT,
					ERR_R_MALLOC_FAILURE);
				OPENSSL_free(tmp);
				goto err;
				}
			}
		OPENSSL_free(tmp);
d384 4
a387 1
	BIO_push(out,bio);
a416 1
	unsigned char *tmp=NULL;
d506 2
a507 1
		int jj;
d522 4
a525 2
		if (pcert) {
			for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {
d530 3
a532 2
			}
			if (ri == NULL) {
d536 1
a536 9
			}
		}

		jj=EVP_PKEY_size(pkey);
		tmp=(unsigned char *)OPENSSL_malloc(jj+10);
		if (tmp == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_MALLOC_FAILURE);
			goto err;
d546 2
a547 5
				jj=EVP_PKEY_decrypt(tmp,
					M_ASN1_STRING_data(ri->enc_key),
					M_ASN1_STRING_length(ri->enc_key),
						pkey);
				if (jj > 0)
d561 1
a561 7
			jj=EVP_PKEY_decrypt(tmp,
				M_ASN1_STRING_data(ri->enc_key),
				M_ASN1_STRING_length(ri->enc_key), pkey);
			if (jj <= 0)
				{
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
								ERR_R_EVP_LIB);
a562 1
				}
d572 1
a572 1
		if (jj != EVP_CIPHER_CTX_key_length(evp_ctx)) {
d577 1
a577 1
			if(!EVP_CIPHER_CTX_set_key_length(evp_ctx, jj))
d584 1
a584 1
		if (EVP_CipherInit_ex(evp_ctx,NULL,NULL,tmp,NULL,0) <= 0)
d587 5
a591 1
		OPENSSL_cleanse(tmp,jj);
a638 2
	if (tmp != NULL)
		OPENSSL_free(tmp);
d665 32
a701 2
	BUF_MEM *buf_mem=NULL;
	BUF_MEM *buf=NULL;
d714 3
d720 2
a721 1
		if (!(os=M_ASN1_OCTET_STRING_new()))
d723 7
a729 2
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);
			goto err;
a730 1
		p7->d.signed_and_enveloped->enc_data->enc_data=os;
d734 2
a735 1
		if (!(os=M_ASN1_OCTET_STRING_new()))
d737 7
a743 2
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);
			goto err;
a744 1
		p7->d.enveloped->enc_data->enc_data=os;
d766 3
a772 5
		if ((buf=BUF_MEM_new()) == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_BIO_LIB);
			goto err;
			}
d776 2
a777 1
			if (si->pkey == NULL) continue;
d779 1
a779 1
			j=OBJ_obj2nid(si->digest_alg->algorithm);
a790 5
			if (!BUF_MEM_grow_clean(buf,EVP_PKEY_size(si->pkey)))
				{
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_BIO_LIB);
				goto err;
				}
d796 6
a801 1
			if ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0))
d803 6
a808 24
				unsigned char md_data[EVP_MAX_MD_SIZE], *abuf=NULL;
				unsigned int md_len, alen;
				ASN1_OCTET_STRING *digest;
				ASN1_UTCTIME *sign_time;
				const EVP_MD *md_tmp;

				/* Add signing time if not already present */
				if (!PKCS7_get_signed_attribute(si,
							NID_pkcs9_signingTime))
					{
					if (!(sign_time=X509_gmtime_adj(NULL,0)))
						{
						PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
							ERR_R_MALLOC_FAILURE);
						goto err;
						}
					if (!PKCS7_add_signed_attribute(si,
						NID_pkcs9_signingTime,
						V_ASN1_UTCTIME,sign_time))
						{
						M_ASN1_UTCTIME_free(sign_time);
						goto err;
						}
					}
d810 2
a811 4
				/* Add digest */
				md_tmp=EVP_MD_CTX_md(&ctx_tmp);
				EVP_DigestFinal_ex(&ctx_tmp,md_data,&md_len);
				if (!(digest=M_ASN1_OCTET_STRING_new()))
d814 1
a814 1
						ERR_R_MALLOC_FAILURE);
d817 1
a817 45
				if (!M_ASN1_OCTET_STRING_set(digest,md_data,
								md_len))
					{
					PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
						ERR_R_MALLOC_FAILURE);
					M_ASN1_OCTET_STRING_free(digest);
					goto err;
					}
				if (!PKCS7_add_signed_attribute(si,
					NID_pkcs9_messageDigest,
					V_ASN1_OCTET_STRING,digest))
					{
					M_ASN1_OCTET_STRING_free(digest);
					goto err;
					}

				/* Now sign the attributes */
				EVP_SignInit_ex(&ctx_tmp,md_tmp,NULL);
				alen = ASN1_item_i2d((ASN1_VALUE *)sk,&abuf,
							ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));
				if(!abuf) goto err;
				EVP_SignUpdate(&ctx_tmp,abuf,alen);
				OPENSSL_free(abuf);
				}

#ifndef OPENSSL_NO_DSA
			if (si->pkey->type == EVP_PKEY_DSA)
				ctx_tmp.digest=EVP_dss1();
#endif
#ifndef OPENSSL_NO_ECDSA
 			if (si->pkey->type == EVP_PKEY_EC)
 				ctx_tmp.digest=EVP_ecdsa();
#endif

			if (!EVP_SignFinal(&ctx_tmp,(unsigned char *)buf->data,
				(unsigned int *)&buf->length,si->pkey))
				{
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_EVP_LIB);
				goto err;
				}
			if (!ASN1_STRING_set(si->enc_digest,
				(unsigned char *)buf->data,buf->length))
				{
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_ASN1_LIB);
				goto err;
d832 1
a832 1
	if (!PKCS7_is_detached(p7))
d834 2
d842 1
a842 1
		BIO_get_mem_ptr(btmp,&buf_mem);
d848 1
a848 6
		os->data = (unsigned char *)buf_mem->data;
		os->length = buf_mem->length;
#if 0
		M_ASN1_OCTET_STRING_set(os,
			(unsigned char *)buf_mem->data,buf_mem->length);
#endif
a852 1
	if (buf != NULL) BUF_MEM_free(buf);
d856 60
d1027 2
a1028 1
                unsigned int md_len, alen;
d1060 6
a1077 6
#ifndef OPENSSL_NO_DSA
	if(pkey->type == EVP_PKEY_DSA) mdc_tmp.digest=EVP_dss1();
#endif
#ifndef OPENSSL_NO_ECDSA
	if (pkey->type == EVP_PKEY_EC) mdc_tmp.digest=EVP_ecdsa();
#endif
d1213 3
a1215 2
		if (!(*sk = sk_X509_ATTRIBUTE_new_null()))
			return 0;
@


1.12
log
@resolve conflicts
@
text
@d65 1
d105 36
d145 1
a145 2
	X509_ALGOR *xa;
	const EVP_MD *evp_md;
d152 1
d161 1
d186 4
d195 3
a197 10
	if (md_sk != NULL)
		{
		for (i=0; i<sk_X509_ALGOR_num(md_sk); i++)
			{
			xa=sk_X509_ALGOR_value(md_sk,i);
			if ((btmp=BIO_new(BIO_f_md())) == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_BIO_LIB);
				goto err;
				}
d199 2
a200 15
			evp_md=EVP_get_digestbyobj(xa->algorithm);
			if (evp_md == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_UNKNOWN_DIGEST_TYPE);
				goto err;
				}

			BIO_set_md(btmp,evp_md);
			if (out == NULL)
				out=btmp;
			else
				BIO_push(out,btmp);
			btmp=NULL;
			}
		}
d219 9
a227 1
		if (RAND_bytes(key,keylen) <= 0)
a228 3
		xalg->algorithm = OBJ_nid2obj(EVP_CIPHER_type(evp_cipher));
		if (ivlen > 0) RAND_pseudo_bytes(iv,ivlen);
		EVP_CipherInit_ex(ctx, evp_cipher, NULL, key, iv, 1);
d231 5
a235 2
			if (xalg->parameter == NULL) 
						xalg->parameter=ASN1_TYPE_new();
d237 1
a237 1
								       goto err;
d250 2
a251 1
			pkey=X509_get_pubkey(ri->cert);
d264 2
a265 1
			pkey=X509_get_pubkey(ri->cert);
d296 3
a298 1
		else
d300 4
a303 14
			if (PKCS7_type_is_signed(p7))
				{
				ASN1_OCTET_STRING *os;
				os = PKCS7_get_octet_string(
							p7->d.sign->contents);
				if (os && os->length > 0)
					bio = BIO_new_mem_buf(os->data,
								os->length);
				}
			if(bio == NULL)
				{
				bio=BIO_new(BIO_s_mem());
				BIO_set_mem_eof_return(bio,0);
				}
d305 1
a305 1
	}
d320 11
d441 12
a452 12
		for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {
			ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
			if(!X509_NAME_cmp(ri->issuer_and_serial->issuer,
					pcert->cert_info->issuer) &&
			     !M_ASN1_INTEGER_cmp(pcert->cert_info->serialNumber,
					ri->issuer_and_serial->serial)) break;
			ri=NULL;
		}
		if (ri == NULL) {
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,
				 PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
			goto err;
d463 24
a486 3
		jj=EVP_PKEY_decrypt(tmp, M_ASN1_STRING_data(ri->enc_key),
			M_ASN1_STRING_length(ri->enc_key), pkey);
		if (jj <= 0)
d488 9
a496 2
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_EVP_LIB);
			goto err;
d501 2
a502 1
		EVP_CipherInit_ex(evp_ctx,evp_cipher,NULL,NULL,NULL,0);
d518 2
a519 1
		EVP_CipherInit_ex(evp_ctx,NULL,NULL,tmp,NULL,0);
d553 2
d574 23
d621 1
a621 1
			PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_MALLOC_FAILURE);
d630 1
a630 1
			PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_MALLOC_FAILURE);
d644 11
d661 1
a661 1
			PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_BIO_LIB);
d672 6
a677 20
			for (;;)
				{
				if ((btmp=BIO_find_type(btmp,BIO_TYPE_MD)) 
					== NULL)
					{
					PKCS7err(PKCS7_F_PKCS7_DATASIGN,PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
					goto err;
					}
				BIO_get_md_ctx(btmp,&mdc);
				if (mdc == NULL)
					{
					PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_INTERNAL_ERROR);
					goto err;
					}
				if (EVP_MD_CTX_type(mdc) == j)
					break;
				else
					btmp=BIO_next(btmp);
				}
			
d683 1
a683 1
				PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_BIO_LIB);
d705 1
a705 1
						PKCS7err(PKCS7_F_PKCS7_DATASIGN,
d709 1
a709 1
					PKCS7_add_signed_attribute(si,
d711 5
a715 1
						V_ASN1_UTCTIME,sign_time);
d723 1
a723 1
					PKCS7err(PKCS7_F_PKCS7_DATASIGN,
d730 1
a730 1
					PKCS7err(PKCS7_F_PKCS7_DATASIGN,
d732 1
d735 1
a735 1
				PKCS7_add_signed_attribute(si,
d737 5
a741 1
					V_ASN1_OCTET_STRING,digest);
d756 4
d764 1
a764 1
				PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_EVP_LIB);
d770 1
a770 1
				PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_ASN1_LIB);
d775 10
d791 1
a791 1
			PKCS7err(PKCS7_F_PKCS7_DATASIGN,PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
d972 3
d999 4
a1002 1
	if (i != NID_pkcs7_signedAndEnveloped) return(NULL);
d1004 2
d1059 2
d1079 2
d1110 2
a1111 1
		*sk = sk_X509_ATTRIBUTE_new_null();
d1113 7
a1119 2
		attr=X509_ATTRIBUTE_create(nid,atrtype,value);
		sk_X509_ATTRIBUTE_push(*sk,attr);
d1132 7
a1138 1
				sk_X509_ATTRIBUTE_set(*sk,i,attr);
@


1.11
log
@from openssl, 1.50.2.9, make S/MIME encrypt work again.
@
text
@d242 7
a248 1
			M_ASN1_OCTET_STRING_set(ri->enc_key,tmp,jj);
d529 5
a533 1
		os=M_ASN1_OCTET_STRING_new();
d538 5
a542 1
		os=M_ASN1_OCTET_STRING_new();
d616 6
a621 1
					sign_time=X509_gmtime_adj(NULL,0);
d630 13
a642 2
				digest=M_ASN1_OCTET_STRING_new();
				M_ASN1_OCTET_STRING_set(digest,md_data,md_len);
@


1.10
log
@merge 0.9.7d
@
text
@d260 9
a268 4
			ASN1_OCTET_STRING *os;
			os = PKCS7_get_octet_string(p7->d.sign->contents);
			if (os && os->length > 0)
				bio = BIO_new_mem_buf(os->data, os->length);
@


1.9
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d94 1
a94 1
static int PKCS7_type_is_octet_string(PKCS7* p7)
d96 6
a101 4
	if ( 0==PKCS7_type_is_other(p7) )
		return 0;

	return (V_ASN1_OCTET_STRING==p7->d.other->type) ? 1 : 0;
d106 1
a106 1
	int i,j;
d164 1
a164 2
			j=OBJ_obj2nid(xa->algorithm);
			evp_md=EVP_get_digestbyname(OBJ_nid2sn(j));
d254 2
a255 1
	if (bio == NULL) {
d258 8
a265 16
		else {
			if (PKCS7_type_is_signed(p7) ) { 
				if ( PKCS7_type_is_data(p7->d.sign->contents)) {
					ASN1_OCTET_STRING *os;
					os=p7->d.sign->contents->d.data;
					if (os->length > 0)
						bio = BIO_new_mem_buf(os->data, os->length);
				}
				else if ( PKCS7_type_is_octet_string(p7->d.sign->contents) ) {
					ASN1_OCTET_STRING *os;
					os=p7->d.sign->contents->d.other->value.octet_string;
					if (os->length > 0)
						bio = BIO_new_mem_buf(os->data, os->length);
				}
			}
			if(bio == NULL) {
d268 1
a269 1
		}
d308 1
a308 1
		data_body=p7->d.sign->contents->d.data;
d316 1
a316 1
		evp_cipher=EVP_get_cipherbyname(OBJ_nid2sn(OBJ_obj2nid(enc_alg->algorithm)));
d328 1
a328 1
		evp_cipher=EVP_get_cipherbyname(OBJ_nid2sn(OBJ_obj2nid(enc_alg->algorithm)));
d354 1
a354 1
			evp_md=EVP_get_digestbyname(OBJ_nid2sn(j));
d528 1
a528 1
		os=p7->d.sign->contents->d.data;
d530 1
a530 1
		if(p7->detached) {
@


1.8
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d770 5
@


1.7
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d244 1
a244 1
		memset(key, 0, keylen);
d451 1
a451 1
		memset(tmp,0,jj);
d581 1
a581 1
			if (!BUF_MEM_grow(buf,EVP_PKEY_size(si->pkey)))
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d70 32
d200 1
a200 1
		EVP_CipherInit(ctx, evp_cipher, key, iv, 1);
d254 1
a254 1
		if (p7->detached)
d257 14
a270 7
			if (PKCS7_type_is_signed(p7) &&
				PKCS7_type_is_data(p7->d.sign->contents)) {
				ASN1_OCTET_STRING *os;
				os=p7->d.sign->contents->d.data;
				if (os->length > 0) bio = 
					BIO_new_mem_buf(os->data, os->length);
			} 
d433 1
a433 1
		EVP_CipherInit(evp_ctx,evp_cipher,NULL,NULL,0);
d449 1
a449 1
		EVP_CipherInit(evp_ctx,NULL,tmp,NULL,0);
d461 1
a461 1
	if (p7->detached || (in_bio != NULL))
a512 2
	unsigned char *p,*pp=NULL;
	int x;
d515 1
d569 1
a569 1
					PKCS7err(PKCS7_F_PKCS7_DATASIGN,PKCS7_R_INTERNAL_ERROR);
d580 1
a580 1
			memcpy(&ctx_tmp,mdc,sizeof(ctx_tmp));
d593 2
a594 2
				unsigned char md_data[EVP_MAX_MD_SIZE];
				unsigned int md_len;
d599 9
a607 5
				/* Add signing time */
				sign_time=X509_gmtime_adj(NULL,0);
				PKCS7_add_signed_attribute(si,
					NID_pkcs9_signingTime,
					V_ASN1_UTCTIME,sign_time);
d611 1
a611 1
				EVP_DigestFinal(&ctx_tmp,md_data,&md_len);
d618 7
a624 13
				/* Now sign the mess */
				EVP_SignInit(&ctx_tmp,md_tmp);
				x=i2d_ASN1_SET_OF_X509_ATTRIBUTE(sk,NULL,
					   i2d_X509_ATTRIBUTE,
					   V_ASN1_SET,V_ASN1_UNIVERSAL,IS_SET);
				pp=(unsigned char *)OPENSSL_malloc(x);
				p=pp;
				i2d_ASN1_SET_OF_X509_ATTRIBUTE(sk,&p,
				           i2d_X509_ATTRIBUTE,
					   V_ASN1_SET,V_ASN1_UNIVERSAL,IS_SET);
				EVP_SignUpdate(&ctx_tmp,pp,x);
				OPENSSL_free(pp);
				pp=NULL;
d627 1
a627 1
#ifndef NO_DSA
d647 1
a647 1
	if (!p7->detached)
a667 3
	if (pp != NULL) OPENSSL_free(pp);
	pp=NULL;

d670 1
d709 5
a713 1
	X509_STORE_CTX_init(ctx,cert_store,x509,cert);
a733 1
	unsigned char *pp,*p;
d740 2
d765 1
a765 1
							PKCS7_R_INTERNAL_ERROR);
d775 1
a775 1
	memcpy(&mdc_tmp,mdc,sizeof(mdc_tmp));
d780 2
a781 2
		unsigned char md_dat[EVP_MAX_MD_SIZE];
                unsigned int md_len;
d784 1
a784 1
		EVP_DigestFinal(&mdc_tmp,md_dat,&md_len);
d809 5
a813 12
		EVP_VerifyInit(&mdc_tmp,EVP_get_digestbynid(md_type));
		/* Note: when forming the encoding of the attributes we
		 * shouldn't reorder them or this will break the signature.
		 * This is done by using the IS_SEQUENCE flag.
		 */
		i=i2d_ASN1_SET_OF_X509_ATTRIBUTE(sk,NULL,i2d_X509_ATTRIBUTE,
			V_ASN1_SET,V_ASN1_UNIVERSAL, IS_SEQUENCE);
		pp=OPENSSL_malloc(i);
		p=pp;
		i2d_ASN1_SET_OF_X509_ATTRIBUTE(sk,&p,i2d_X509_ATTRIBUTE,
			V_ASN1_SET,V_ASN1_UNIVERSAL, IS_SEQUENCE);
		EVP_VerifyUpdate(&mdc_tmp,pp,i);
d815 1
a815 1
		OPENSSL_free(pp);
d825 1
a825 1
#ifndef NO_DSA
d841 1
d883 1
a883 1
			if (xa->set && sk_ASN1_TYPE_num(xa->value.set))
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d373 1
a373 1
			return(NULL);
d396 1
a396 1
			return(NULL);
d591 1
d594 1
d788 6
d795 1
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d192 1
a192 1
		if ((tmp=(unsigned char *)Malloc(max)) == NULL)
d206 1
a206 1
				Free(tmp);
d211 1
a211 1
		Free(tmp);
a267 7
#ifndef NO_RC2
	char is_rc2 = 0;
#endif
/*	EVP_PKEY *pkey; */
#if 0
	X509_STORE_CTX s_ctx;
#endif
a307 10
	if(EVP_CIPHER_nid(evp_cipher) == NID_rc2_cbc)
		{
#ifndef NO_RC2		
		is_rc2 = 1; 
#else
		PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
		goto err;
#endif
		}

d377 1
a377 1
		tmp=(unsigned char *)Malloc(jj+10);
d399 1
a399 1
			/* HACK: some S/MIME clients don't use the same key
a401 3
			 * So we hack things to manually set the RC2 key
			 * because we currently can't do this with the EVP
			 * interface.
d403 1
a403 5
#ifndef NO_RC2		
			if(is_rc2) RC2_set_key(&(evp_ctx->c.rc2_ks),jj, tmp,
					EVP_CIPHER_CTX_key_length(evp_ctx)*8);
			else
#endif
d409 2
a410 1
		} else EVP_CipherInit(evp_ctx,NULL,tmp,NULL,0);
d459 1
a459 1
		Free(tmp);
d537 1
a537 1
					btmp=btmp->next_bio;
d581 1
a581 1
				pp=(unsigned char *)Malloc(x);
d587 1
a587 1
				Free(pp);
d630 1
a630 1
	if (pp != NULL) Free(pp);
d729 1
a729 1
		btmp=btmp->next_bio;	
d775 1
a775 1
		pp=Malloc(i);
d781 1
a781 1
		Free(pp);
d912 1
a912 1
		*sk = sk_X509_ATTRIBUTE_new(NULL);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d702 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d64 1
d164 2
a165 1
		RAND_bytes(key,keylen);
d167 1
a167 1
		if (ivlen > 0) RAND_bytes(iv,ivlen);
d209 1
a209 1
			ASN1_OCTET_STRING_set(ri->enc_key,tmp,jj);
d221 1
a221 2
	if (bio == NULL) /* ??????????? */
		{
d224 1
a224 8
		else
			{
			bio=BIO_new(BIO_s_mem());
			/* We need to set this so that when we have read all
			 * the data, the encrypt BIO, if present, will read
			 * EOF and encode the last few bytes */
			BIO_set_mem_eof_return(bio,0);

d226 1
a226 2
				PKCS7_type_is_data(p7->d.sign->contents))
				{
a227 1

d229 6
a234 4
				if (os->length > 0)
					BIO_write(bio,(char *)os->data,
						os->length);
				}
d237 1
d257 1
a257 1
	char *tmp=NULL;
d268 3
d315 10
d383 1
a383 1
			     !ASN1_INTEGER_cmp(pcert->cert_info->serialNumber,
d394 1
a394 1
		tmp=Malloc(jj+10);
d401 2
a402 4
		jj=EVP_PKEY_decrypt((unsigned char *)tmp,
			ASN1_STRING_data(ri->enc_key),
			ASN1_STRING_length(ri->enc_key),
			pkey);
d415 15
a429 3
		if (jj != EVP_CIPHER_CTX_key_length(evp_ctx))
			{
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,
d431 3
a433 3
			goto err;
			}
		EVP_CipherInit(evp_ctx,NULL,(unsigned char *)tmp,NULL,0);
d451 1
d460 8
d509 1
a509 1
		os=ASN1_OCTET_STRING_new();
d514 1
a514 1
		os=ASN1_OCTET_STRING_new();
d522 1
a522 1
			ASN1_OCTET_STRING_free(os);
d557 1
a557 1
				if (EVP_MD_type(EVP_MD_CTX_type(mdc)) == j)
d591 1
a591 1
				md_tmp=EVP_MD_CTX_type(&ctx_tmp);
d593 2
a594 2
				digest=ASN1_OCTET_STRING_new();
				ASN1_OCTET_STRING_set(digest,md_data,md_len);
d641 9
a649 1
		ASN1_OCTET_STRING_set(os,
d651 1
d697 1
d749 1
a749 1
		if (EVP_MD_type(EVP_MD_CTX_type(mdc)) == md_type)
@


1.1
log
@Initial revision
@
text
@d61 9
a69 7
#include "rand.h"
#include "objects.h"
#include "x509.h"

BIO *PKCS7_dataInit(p7,bio)
PKCS7 *p7;
BIO *bio;
d72 1
a72 1
	BIO *out=NULL,*btmp;
d74 4
a77 3
	EVP_MD *evp_md;
	EVP_CIPHER *evp_cipher=NULL;
	STACK *md_sk=NULL,*rsk=NULL;
d93 13
a105 1
		evp_cipher=EVP_get_cipherbyname(OBJ_nid2sn(OBJ_obj2nid(p7->d.signed_and_enveloped->enc_data->algorithm->algorithm)));
d108 2
a109 1
			PKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
a111 1
		xalg=p7->d.signed_and_enveloped->enc_data->algorithm;
d120 1
a120 1
		for (i=0; i<sk_num(md_sk); i++)
d122 6
a127 2
			xa=(X509_ALGOR *)sk_value(md_sk,i);
			if ((btmp=BIO_new(BIO_f_md())) == NULL) goto err;
d142 1
d153 1
d155 6
a160 1
		if ((btmp=BIO_new(BIO_f_cipher())) == NULL) goto err;
a162 11

		if (ivlen > 0)
			{
			ASN1_OCTET_STRING *os;

			RAND_bytes(iv,ivlen);
			os=ASN1_OCTET_STRING_new();
			ASN1_OCTET_STRING_set(os,iv,ivlen);
		/*	ASN1_TYPE_set(xalg->parameter,V_ASN1_OCTET_STRING,
				(char *)os);
		*/	}
d164 10
d177 1
a177 1
		for (i=0; i<sk_num(rsk); i++)
d179 6
a184 2
			ri=(PKCS7_RECIP_INFO *)sk_value(rsk,i);
			if (ri->cert == NULL) abort();
d187 1
d190 6
a195 2
		if ((tmp=(unsigned char *)Malloc(max)) == NULL) abort();
		for (i=0; i<sk_num(rsk); i++)
d197 1
a197 1
			ri=(PKCS7_RECIP_INFO *)sk_value(rsk,i);
d200 7
a206 1
			if (jj <= 0) abort();
d209 2
a210 2

		BIO_set_cipher(btmp,evp_cipher,key,iv,1);
d216 1
d226 5
d244 10
d255 192
d448 9
a456 1
	return(NULL);
d459 1
a459 3
int PKCS7_dataSign(p7,bio)
PKCS7 *p7;
BIO *bio;
d468 2
a469 1
	STACK *sk,*si_sk=NULL;
d485 5
d493 5
d503 1
a503 2
		if ((buf=BUF_MEM_new()) == NULL) goto err;
		for (i=0; i<sk_num(si_sk); i++)
d505 9
a513 5
			si=(PKCS7_SIGNER_INFO *)
				sk_value(si_sk,i);
			if (si->pkey == NULL)
				continue;
			j=OBJ_obj2nid(si->digest_enc_alg->algorithm);
d530 1
a530 1
				if (EVP_MD_pkey_type(EVP_MD_CTX_type(mdc)) == j)
d540 2
d543 1
d546 4
a549 1
			if ((sk != NULL) && (sk_num(sk) != 0))
d551 27
a577 3
				x=i2d_ASN1_SET(sk,NULL,i2d_X509_ATTRIBUTE,
					V_ASN1_SET,V_ASN1_UNIVERSAL);
				pp=(unsigned char *)Malloc(i);
d579 3
a581 2
				i2d_ASN1_SET(sk,&p,i2d_X509_ATTRIBUTE,
					V_ASN1_SET,V_ASN1_UNIVERSAL);
d584 1
d587 3
d592 2
d595 1
d598 2
d601 1
d603 6
a608 3
		if (p7->detached)
			ASN1_OCTET_STRING_set(os,(unsigned char *)"",0);
		else
d610 2
a611 9
			btmp=BIO_find_type(bio,BIO_TYPE_MEM);
			if (btmp == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATASIGN,PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
				goto err;
				}
			BIO_get_mem_ptr(btmp,&buf_mem);
			ASN1_OCTET_STRING_set(os,
				(unsigned char *)buf_mem->data,buf_mem->length);
d613 3
a615 2
		if (pp != NULL) Free(pp);
		pp=NULL;
d617 2
d626 2
a627 6
int PKCS7_dataVerify(cert_store,ctx,bio,p7,si)
X509_STORE *cert_store;
X509_STORE_CTX *ctx;
BIO *bio;
PKCS7 *p7;
PKCS7_SIGNER_INFO *si;
a628 4
	PKCS7_SIGNED *s;
	ASN1_OCTET_STRING *os;
	EVP_MD_CTX mdc_tmp,*mdc;
	unsigned char *pp,*p;
d630 2
a631 3
	int ret=0,md_type,i;
	STACK *sk;
	BIO *btmp;
d634 13
a646 1
	if (!PKCS7_type_is_signed(p7)) abort();
a648 1
	s=p7->d.sign;
d650 1
a650 1
	x509=X509_find_by_issuer_and_serial(s->cert,ias->issuer,ias->serial);
d660 1
a660 1
	X509_STORE_CTX_init(ctx,cert_store,x509,s->cert);
d662 5
a666 1
	if (i <= 0) goto err;
d669 24
a692 1
	/* So we like 'x509', lets check the signature. */
d701 2
a702 1
			PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
d708 2
a709 1
			PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_INTERNAL_ERROR);
d717 2
a718 1
	/* mdc is the digest ctx that we want */
d722 1
a722 1
	if ((sk != NULL) && (sk_num(sk) != 0))
d724 37
a760 3
		i=i2d_ASN1_SET(sk,NULL,i2d_X509_ATTRIBUTE,
			V_ASN1_SET,V_ASN1_UNIVERSAL);
		pp=(unsigned char *)malloc(i);
d762 2
a763 2
		i2d_ASN1_SET(sk,&p,i2d_X509_ATTRIBUTE,
			V_ASN1_SET,V_ASN1_UNIVERSAL);
d765 2
a766 1
		free(pp);
d770 5
a774 2
	i=EVP_VerifyFinal(&mdc_tmp,os->data,os->length,
		X509_get_pubkey(x509));
d777 2
a778 1
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_SIGNATURE_FAILURE);
d786 135
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 7
a67 42
#include <openssl/rand.h>
#include <openssl/objects.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>

static int add_attribute(STACK_OF(X509_ATTRIBUTE) **sk, int nid, int atrtype,
			 void *value);
static ASN1_TYPE *get_attribute(STACK_OF(X509_ATTRIBUTE) *sk, int nid);

static int PKCS7_type_is_other(PKCS7* p7)
	{
	int isOther=1;
	
	int nid=OBJ_obj2nid(p7->type);

	switch( nid )
		{
	case NID_pkcs7_data:
	case NID_pkcs7_signed:
	case NID_pkcs7_enveloped:
	case NID_pkcs7_signedAndEnveloped:
	case NID_pkcs7_digest:
	case NID_pkcs7_encrypted:
		isOther=0;
		break;
	default:
		isOther=1;
		}

	return isOther;

	}

static int PKCS7_type_is_octet_string(PKCS7* p7)
	{
	if ( 0==PKCS7_type_is_other(p7) )
		return 0;

	return (V_ASN1_OCTET_STRING==p7->d.other->type) ? 1 : 0;
	}

BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
d70 1
a70 1
	BIO *out=NULL,*btmp=NULL;
d72 3
a74 4
	const EVP_MD *evp_md;
	const EVP_CIPHER *evp_cipher=NULL;
	STACK_OF(X509_ALGOR) *md_sk=NULL;
	STACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;
d90 1
a90 2
		xalg=p7->d.signed_and_enveloped->enc_data->algorithm;
		evp_cipher=p7->d.signed_and_enveloped->enc_data->cipher;
d93 1
a93 13
			PKCS7err(PKCS7_F_PKCS7_DATAINIT,
						PKCS7_R_CIPHER_NOT_INITIALIZED);
			goto err;
			}
		break;
	case NID_pkcs7_enveloped:
		rsk=p7->d.enveloped->recipientinfo;
		xalg=p7->d.enveloped->enc_data->algorithm;
		evp_cipher=p7->d.enveloped->enc_data->cipher;
		if (evp_cipher == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATAINIT,
						PKCS7_R_CIPHER_NOT_INITIALIZED);
d96 1
d105 1
a105 1
		for (i=0; i<sk_X509_ALGOR_num(md_sk); i++)
d107 2
a108 6
			xa=sk_X509_ALGOR_value(md_sk,i);
			if ((btmp=BIO_new(BIO_f_md())) == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_BIO_LIB);
				goto err;
				}
a122 1
			btmp=NULL;
a132 1
		EVP_CIPHER_CTX *ctx;
d134 1
a134 6
		if ((btmp=BIO_new(BIO_f_cipher())) == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_BIO_LIB);
			goto err;
			}
		BIO_get_cipher_ctx(btmp, &ctx);
d137 12
a148 12
		if (RAND_bytes(key,keylen) <= 0)
			goto err;
		xalg->algorithm = OBJ_nid2obj(EVP_CIPHER_type(evp_cipher));
		if (ivlen > 0) RAND_pseudo_bytes(iv,ivlen);
		EVP_CipherInit_ex(ctx, evp_cipher, NULL, key, iv, 1);

		if (ivlen > 0) {
			if (xalg->parameter == NULL) 
						xalg->parameter=ASN1_TYPE_new();
			if(EVP_CIPHER_param_to_asn1(ctx, xalg->parameter) < 0)
								       goto err;
		}
d152 1
a152 1
		for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)
d154 2
a155 6
			ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
			if (ri->cert == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_MISSING_CERIPEND_INFO);
				goto err;
				}
a157 1
			EVP_PKEY_free(pkey);
d160 2
a161 1
		if ((tmp=(unsigned char *)OPENSSL_malloc(max)) == NULL)
d163 1
a163 6
			PKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_MALLOC_FAILURE);
			goto err;
			}
		for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)
			{
			ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
d166 2
a167 8
			EVP_PKEY_free(pkey);
			if (jj <= 0)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_EVP_LIB);
				OPENSSL_free(tmp);
				goto err;
				}
			M_ASN1_OCTET_STRING_set(ri->enc_key,tmp,jj);
d169 2
a170 2
		OPENSSL_free(tmp);
		memset(key, 0, keylen);
a175 1
		btmp=NULL;
d178 3
a180 2
	if (bio == NULL) {
		if (PKCS7_is_detached(p7))
d182 1
a182 68
		else {
			if (PKCS7_type_is_signed(p7) ) { 
				if ( PKCS7_type_is_data(p7->d.sign->contents)) {
					ASN1_OCTET_STRING *os;
					os=p7->d.sign->contents->d.data;
					if (os->length > 0)
						bio = BIO_new_mem_buf(os->data, os->length);
				}
				else if ( PKCS7_type_is_octet_string(p7->d.sign->contents) ) {
					ASN1_OCTET_STRING *os;
					os=p7->d.sign->contents->d.other->value.octet_string;
					if (os->length > 0)
						bio = BIO_new_mem_buf(os->data, os->length);
				}
			}
			if(bio == NULL) {
				bio=BIO_new(BIO_s_mem());
				BIO_set_mem_eof_return(bio,0);
			}
		}
	}
	BIO_push(out,bio);
	bio=NULL;
	if (0)
		{
err:
		if (out != NULL)
			BIO_free_all(out);
		if (btmp != NULL)
			BIO_free_all(btmp);
		out=NULL;
		}
	return(out);
	}

/* int */
BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
	{
	int i,j;
	BIO *out=NULL,*btmp=NULL,*etmp=NULL,*bio=NULL;
	unsigned char *tmp=NULL;
	X509_ALGOR *xa;
	ASN1_OCTET_STRING *data_body=NULL;
	const EVP_MD *evp_md;
	const EVP_CIPHER *evp_cipher=NULL;
	EVP_CIPHER_CTX *evp_ctx=NULL;
	X509_ALGOR *enc_alg=NULL;
	STACK_OF(X509_ALGOR) *md_sk=NULL;
	STACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;
	X509_ALGOR *xalg=NULL;
	PKCS7_RECIP_INFO *ri=NULL;

	i=OBJ_obj2nid(p7->type);
	p7->state=PKCS7_S_HEADER;

	switch (i)
		{
	case NID_pkcs7_signed:
		data_body=p7->d.sign->contents->d.data;
		md_sk=p7->d.sign->md_algs;
		break;
	case NID_pkcs7_signedAndEnveloped:
		rsk=p7->d.signed_and_enveloped->recipientinfo;
		md_sk=p7->d.signed_and_enveloped->md_algs;
		data_body=p7->d.signed_and_enveloped->enc_data->enc_data;
		enc_alg=p7->d.signed_and_enveloped->enc_data->algorithm;
		evp_cipher=EVP_get_cipherbyname(OBJ_nid2sn(OBJ_obj2nid(enc_alg->algorithm)));
		if (evp_cipher == NULL)
d184 3
a186 29
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
			goto err;
			}
		xalg=p7->d.signed_and_enveloped->enc_data->algorithm;
		break;
	case NID_pkcs7_enveloped:
		rsk=p7->d.enveloped->recipientinfo;
		enc_alg=p7->d.enveloped->enc_data->algorithm;
		data_body=p7->d.enveloped->enc_data->enc_data;
		evp_cipher=EVP_get_cipherbyname(OBJ_nid2sn(OBJ_obj2nid(enc_alg->algorithm)));
		if (evp_cipher == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
			goto err;
			}
		xalg=p7->d.enveloped->enc_data->algorithm;
		break;
	default:
		PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
	        goto err;
		}

	/* We will be checking the signature */
	if (md_sk != NULL)
		{
		for (i=0; i<sk_X509_ALGOR_num(md_sk); i++)
			{
			xa=sk_X509_ALGOR_value(md_sk,i);
			if ((btmp=BIO_new(BIO_f_md())) == NULL)
d188 1
a188 3
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);
				goto err;
				}
d190 4
a193 6
			j=OBJ_obj2nid(xa->algorithm);
			evp_md=EVP_get_digestbyname(OBJ_nid2sn(j));
			if (evp_md == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNKNOWN_DIGEST_TYPE);
				goto err;
a194 55

			BIO_set_md(btmp,evp_md);
			if (out == NULL)
				out=btmp;
			else
				BIO_push(out,btmp);
			btmp=NULL;
			}
		}

	if (evp_cipher != NULL)
		{
#if 0
		unsigned char key[EVP_MAX_KEY_LENGTH];
		unsigned char iv[EVP_MAX_IV_LENGTH];
		unsigned char *p;
		int keylen,ivlen;
		int max;
		X509_OBJECT ret;
#endif
		int jj;

		if ((etmp=BIO_new(BIO_f_cipher())) == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);
			goto err;
			}

		/* It was encrypted, we need to decrypt the secret key
		 * with the private key */

		/* Find the recipientInfo which matches the passed certificate
		 * (if any)
		 */

		for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {
			ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
			if(!X509_NAME_cmp(ri->issuer_and_serial->issuer,
					pcert->cert_info->issuer) &&
			     !M_ASN1_INTEGER_cmp(pcert->cert_info->serialNumber,
					ri->issuer_and_serial->serial)) break;
			ri=NULL;
		}
		if (ri == NULL) {
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,
				 PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
			goto err;
		}

		jj=EVP_PKEY_size(pkey);
		tmp=(unsigned char *)OPENSSL_malloc(jj+10);
		if (tmp == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_MALLOC_FAILURE);
			goto err;
a195 62

		jj=EVP_PKEY_decrypt(tmp, M_ASN1_STRING_data(ri->enc_key),
			M_ASN1_STRING_length(ri->enc_key), pkey);
		if (jj <= 0)
			{
			PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_EVP_LIB);
			goto err;
			}

		evp_ctx=NULL;
		BIO_get_cipher_ctx(etmp,&evp_ctx);
		EVP_CipherInit_ex(evp_ctx,evp_cipher,NULL,NULL,NULL,0);
		if (EVP_CIPHER_asn1_to_param(evp_ctx,enc_alg->parameter) < 0)
			goto err;

		if (jj != EVP_CIPHER_CTX_key_length(evp_ctx)) {
			/* Some S/MIME clients don't use the same key
			 * and effective key length. The key length is
			 * determined by the size of the decrypted RSA key.
			 */
			if(!EVP_CIPHER_CTX_set_key_length(evp_ctx, jj))
				{
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
					PKCS7_R_DECRYPTED_KEY_IS_WRONG_LENGTH);
				goto err;
				}
		} 
		EVP_CipherInit_ex(evp_ctx,NULL,NULL,tmp,NULL,0);

		memset(tmp,0,jj);

		if (out == NULL)
			out=etmp;
		else
			BIO_push(out,etmp);
		etmp=NULL;
		}

#if 1
	if (PKCS7_is_detached(p7) || (in_bio != NULL))
		{
		bio=in_bio;
		}
	else 
		{
#if 0
		bio=BIO_new(BIO_s_mem());
		/* We need to set this so that when we have read all
		 * the data, the encrypt BIO, if present, will read
		 * EOF and encode the last few bytes */
		BIO_set_mem_eof_return(bio,0);

		if (data_body->length > 0)
			BIO_write(bio,(char *)data_body->data,data_body->length);
#else
		if (data_body->length > 0)
		      bio = BIO_new_mem_buf(data_body->data,data_body->length);
		else {
			bio=BIO_new(BIO_s_mem());
			BIO_set_mem_eof_return(bio,0);
		}
#endif
d198 1
a198 4
	bio=NULL;
#endif
	if (0)
		{
d200 1
a200 9
		if (out != NULL) BIO_free_all(out);
		if (btmp != NULL) BIO_free_all(btmp);
		if (etmp != NULL) BIO_free_all(etmp);
		if (bio != NULL) BIO_free_all(bio);
		out=NULL;
		}
	if (tmp != NULL)
		OPENSSL_free(tmp);
	return(out);
d203 3
a205 1
int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
d214 3
a216 2
	STACK_OF(X509_ATTRIBUTE) *sk;
	STACK_OF(PKCS7_SIGNER_INFO) *si_sk=NULL;
a218 1
	EVP_MD_CTX_init(&ctx_tmp);
d227 1
a227 1
		os=M_ASN1_OCTET_STRING_new();
a229 5
	case NID_pkcs7_enveloped:
		/* XXXXXXXXXXXXXXXX */
		os=M_ASN1_OCTET_STRING_new();
		p7->d.enveloped->enc_data->enc_data=os;
		break;
a232 5
		/* If detached data then the content is excluded */
		if(p7->detached) {
			M_ASN1_OCTET_STRING_free(os);
			p7->d.sign->contents->d.data = NULL;
		}
d238 2
a239 6
		if ((buf=BUF_MEM_new()) == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_BIO_LIB);
			goto err;
			}
		for (i=0; i<sk_PKCS7_SIGNER_INFO_num(si_sk); i++)
d241 5
a245 4
			si=sk_PKCS7_SIGNER_INFO_value(si_sk,i);
			if (si->pkey == NULL) continue;

			j=OBJ_obj2nid(si->digest_alg->algorithm);
d259 1
a259 1
					PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_INTERNAL_ERROR);
d262 1
a262 1
				if (EVP_MD_CTX_type(mdc) == j)
d265 1
a265 1
					btmp=BIO_next(btmp);
d270 1
a270 1
			EVP_MD_CTX_copy_ex(&ctx_tmp,mdc);
a271 2
				{
				PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_BIO_LIB);
a272 1
				}
d275 1
a275 4

			/* If there are attributes, we add the digest
			 * attribute and only sign the attributes */
			if ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0))
d277 8
a284 32
				unsigned char md_data[EVP_MAX_MD_SIZE], *abuf=NULL;
				unsigned int md_len, alen;
				ASN1_OCTET_STRING *digest;
				ASN1_UTCTIME *sign_time;
				const EVP_MD *md_tmp;

				/* Add signing time if not already present */
				if (!PKCS7_get_signed_attribute(si,
							NID_pkcs9_signingTime))
					{
					sign_time=X509_gmtime_adj(NULL,0);
					PKCS7_add_signed_attribute(si,
						NID_pkcs9_signingTime,
						V_ASN1_UTCTIME,sign_time);
					}

				/* Add digest */
				md_tmp=EVP_MD_CTX_md(&ctx_tmp);
				EVP_DigestFinal_ex(&ctx_tmp,md_data,&md_len);
				digest=M_ASN1_OCTET_STRING_new();
				M_ASN1_OCTET_STRING_set(digest,md_data,md_len);
				PKCS7_add_signed_attribute(si,
					NID_pkcs9_messageDigest,
					V_ASN1_OCTET_STRING,digest);

				/* Now sign the attributes */
				EVP_SignInit_ex(&ctx_tmp,md_tmp,NULL);
				alen = ASN1_item_i2d((ASN1_VALUE *)sk,&abuf,
							ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));
				if(!abuf) goto err;
				EVP_SignUpdate(&ctx_tmp,abuf,alen);
				OPENSSL_free(abuf);
a286 5
#ifndef OPENSSL_NO_DSA
			if (si->pkey->type == EVP_PKEY_DSA)
				ctx_tmp.digest=EVP_dss1();
#endif

a288 2
				{
				PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_EVP_LIB);
a289 1
				}
d292 8
d301 1
a301 1
				PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_ASN1_LIB);
d304 3
d308 2
a311 21
	if (!PKCS7_is_detached(p7))
		{
		btmp=BIO_find_type(bio,BIO_TYPE_MEM);
		if (btmp == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_DATASIGN,PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
			goto err;
			}
		BIO_get_mem_ptr(btmp,&buf_mem);
		/* Mark the BIO read only then we can use its copy of the data
		 * instead of making an extra copy.
		 */
		BIO_set_flags(btmp, BIO_FLAGS_MEM_RDONLY);
		BIO_set_mem_eof_return(btmp, 0);
		os->data = (unsigned char *)buf_mem->data;
		os->length = buf_mem->length;
#if 0
		M_ASN1_OCTET_STRING_set(os,
			(unsigned char *)buf_mem->data,buf_mem->length);
#endif
		}
a313 1
	EVP_MD_CTX_cleanup(&ctx_tmp);
d318 6
a323 2
int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,
	     PKCS7 *p7, PKCS7_SIGNER_INFO *si)
d325 4
d330 3
a332 2
	int ret=0,i;
	STACK_OF(X509) *cert;
d335 1
a335 13
	if (PKCS7_type_is_signed(p7))
		{
		cert=p7->d.sign->cert;
		}
	else if (PKCS7_type_is_signedAndEnveloped(p7))
		{
		cert=p7->d.signed_and_enveloped->cert;
		}
	else
		{
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_WRONG_PKCS7_TYPE);
		goto err;
		}
d338 1
d340 1
a340 1
	x509=X509_find_by_issuer_and_serial(cert,ias->issuer,ias->serial);
d350 1
a350 6
	if(!X509_STORE_CTX_init(ctx,cert_store,x509,cert))
		{
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,ERR_R_X509_LIB);
		goto err;
		}
	X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_SMIME_SIGN);
d352 1
a352 6
	if (i <= 0) 
		{
		PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,ERR_R_X509_LIB);
		X509_STORE_CTX_cleanup(ctx);
		goto err;
		}
d355 1
a355 25
	return PKCS7_signatureVerify(bio, p7, si, x509);
	err:
	return ret;
	}

int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
								X509 *x509)
	{
	ASN1_OCTET_STRING *os;
	EVP_MD_CTX mdc_tmp,*mdc;
	int ret=0,i;
	int md_type;
	STACK_OF(X509_ATTRIBUTE) *sk;
	BIO *btmp;
	EVP_PKEY *pkey;

	EVP_MD_CTX_init(&mdc_tmp);

	if (!PKCS7_type_is_signed(p7) && 
				!PKCS7_type_is_signedAndEnveloped(p7)) {
		PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
						PKCS7_R_WRONG_PKCS7_TYPE);
		goto err;
	}

d364 1
a364 2
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
					PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
d370 1
a370 2
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
							ERR_R_INTERNAL_ERROR);
d373 1
a373 1
		if (EVP_MD_CTX_type(mdc) == md_type)
d375 1
a375 1
		btmp=BIO_next(btmp);
d378 2
a379 3
	/* mdc is the digest ctx that we want, unless there are attributes,
	 * in which case the digest is the signed attributes */
	EVP_MD_CTX_copy_ex(&mdc_tmp,mdc);
d382 1
a382 1
	if ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0))
d384 8
a391 36
		unsigned char md_dat[EVP_MAX_MD_SIZE], *abuf = NULL;
                unsigned int md_len, alen;
		ASN1_OCTET_STRING *message_digest;

		EVP_DigestFinal_ex(&mdc_tmp,md_dat,&md_len);
		message_digest=PKCS7_digest_from_attributes(sk);
		if (!message_digest)
			{
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
					PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
			goto err;
			}
		if ((message_digest->length != (int)md_len) ||
			(memcmp(message_digest->data,md_dat,md_len)))
			{
#if 0
{
int ii;
for (ii=0; ii<message_digest->length; ii++)
	printf("%02X",message_digest->data[ii]); printf(" sent\n");
for (ii=0; ii<md_len; ii++) printf("%02X",md_dat[ii]); printf(" calc\n");
}
#endif
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
							PKCS7_R_DIGEST_FAILURE);
			ret= -1;
			goto err;
			}

		EVP_VerifyInit_ex(&mdc_tmp,EVP_get_digestbynid(md_type), NULL);

		alen = ASN1_item_i2d((ASN1_VALUE *)sk, &abuf,
						ASN1_ITEM_rptr(PKCS7_ATTR_VERIFY));
		EVP_VerifyUpdate(&mdc_tmp, abuf, alen);

		OPENSSL_free(abuf);
d395 2
a396 12
	pkey = X509_get_pubkey(x509);
	if (!pkey)
		{
		ret = -1;
		goto err;
		}
#ifndef OPENSSL_NO_DSA
	if(pkey->type == EVP_PKEY_DSA) mdc_tmp.digest=EVP_dss1();
#endif

	i=EVP_VerifyFinal(&mdc_tmp,os->data,os->length, pkey);
	EVP_PKEY_free(pkey);
d399 1
a399 2
		PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
						PKCS7_R_SIGNATURE_FAILURE);
a405 1
	EVP_MD_CTX_cleanup(&mdc_tmp);
a406 135
	}

PKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx)
	{
	STACK_OF(PKCS7_RECIP_INFO) *rsk;
	PKCS7_RECIP_INFO *ri;
	int i;

	i=OBJ_obj2nid(p7->type);
	if (i != NID_pkcs7_signedAndEnveloped) return(NULL);
	rsk=p7->d.signed_and_enveloped->recipientinfo;
	ri=sk_PKCS7_RECIP_INFO_value(rsk,0);
	if (sk_PKCS7_RECIP_INFO_num(rsk) <= idx) return(NULL);
	ri=sk_PKCS7_RECIP_INFO_value(rsk,idx);
	return(ri->issuer_and_serial);
	}

ASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid)
	{
	return(get_attribute(si->auth_attr,nid));
	}

ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
	{
	return(get_attribute(si->unauth_attr,nid));
	}

static ASN1_TYPE *get_attribute(STACK_OF(X509_ATTRIBUTE) *sk, int nid)
	{
	int i;
	X509_ATTRIBUTE *xa;
	ASN1_OBJECT *o;

	o=OBJ_nid2obj(nid);
	if (!o || !sk) return(NULL);
	for (i=0; i<sk_X509_ATTRIBUTE_num(sk); i++)
		{
		xa=sk_X509_ATTRIBUTE_value(sk,i);
		if (OBJ_cmp(xa->object,o) == 0)
			{
			if (!xa->single && sk_ASN1_TYPE_num(xa->value.set))
				return(sk_ASN1_TYPE_value(xa->value.set,0));
			else
				return(NULL);
			}
		}
	return(NULL);
	}

ASN1_OCTET_STRING *PKCS7_digest_from_attributes(STACK_OF(X509_ATTRIBUTE) *sk)
{
	ASN1_TYPE *astype;
	if(!(astype = get_attribute(sk, NID_pkcs9_messageDigest))) return NULL;
	return astype->value.octet_string;
}

int PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si,
				STACK_OF(X509_ATTRIBUTE) *sk)
	{
	int i;

	if (p7si->auth_attr != NULL)
		sk_X509_ATTRIBUTE_pop_free(p7si->auth_attr,X509_ATTRIBUTE_free);
	p7si->auth_attr=sk_X509_ATTRIBUTE_dup(sk);
	for (i=0; i<sk_X509_ATTRIBUTE_num(sk); i++)
		{
		if ((sk_X509_ATTRIBUTE_set(p7si->auth_attr,i,
			X509_ATTRIBUTE_dup(sk_X509_ATTRIBUTE_value(sk,i))))
		    == NULL)
			return(0);
		}
	return(1);
	}

int PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si, STACK_OF(X509_ATTRIBUTE) *sk)
	{
	int i;

	if (p7si->unauth_attr != NULL)
		sk_X509_ATTRIBUTE_pop_free(p7si->unauth_attr,
					   X509_ATTRIBUTE_free);
	p7si->unauth_attr=sk_X509_ATTRIBUTE_dup(sk);
	for (i=0; i<sk_X509_ATTRIBUTE_num(sk); i++)
		{
		if ((sk_X509_ATTRIBUTE_set(p7si->unauth_attr,i,
                        X509_ATTRIBUTE_dup(sk_X509_ATTRIBUTE_value(sk,i))))
		    == NULL)
			return(0);
		}
	return(1);
	}

int PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,
	     void *value)
	{
	return(add_attribute(&(p7si->auth_attr),nid,atrtype,value));
	}

int PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,
	     void *value)
	{
	return(add_attribute(&(p7si->unauth_attr),nid,atrtype,value));
	}

static int add_attribute(STACK_OF(X509_ATTRIBUTE) **sk, int nid, int atrtype,
			 void *value)
	{
	X509_ATTRIBUTE *attr=NULL;

	if (*sk == NULL)
		{
		*sk = sk_X509_ATTRIBUTE_new_null();
new_attrib:
		attr=X509_ATTRIBUTE_create(nid,atrtype,value);
		sk_X509_ATTRIBUTE_push(*sk,attr);
		}
	else
		{
		int i;

		for (i=0; i<sk_X509_ATTRIBUTE_num(*sk); i++)
			{
			attr=sk_X509_ATTRIBUTE_value(*sk,i);
			if (OBJ_obj2nid(attr->object) == nid)
				{
				X509_ATTRIBUTE_free(attr);
				attr=X509_ATTRIBUTE_create(nid,atrtype,value);
				sk_X509_ATTRIBUTE_set(*sk,i,attr);
				goto end;
				}
			}
		goto new_attrib;
		}
end:
	return(1);
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d244 1
a244 1
		OPENSSL_cleanse(key, keylen);
d451 1
a451 1
		OPENSSL_cleanse(tmp,jj);
d581 1
a581 1
			if (!BUF_MEM_grow_clean(buf,EVP_PKEY_size(si->pkey)))
@


1.1.1.4
log
@import 0.9.7c
@
text
@a769 5
		/* Workaround for some broken clients that put the signature
		 * OID instead of the digest OID in digest_alg->algorithm
		 */
		if (EVP_MD_pkey_type(EVP_MD_CTX_md(mdc)) == md_type)
			break;
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@d94 1
a94 1
static ASN1_OCTET_STRING *PKCS7_get_octet_string(PKCS7 *p7)
d96 4
a99 6
	if ( PKCS7_type_is_data(p7))
		return p7->d.data;
	if ( PKCS7_type_is_other(p7) && p7->d.other
		&& (p7->d.other->type == V_ASN1_OCTET_STRING))
		return p7->d.other->value.octet_string;
	return NULL;
d104 1
a104 1
	int i;
d162 2
a163 1
			evp_md=EVP_get_digestbyobj(xa->algorithm);
d253 1
a253 2
	if (bio == NULL)
		{
d256 16
a271 8
		else
			{
			ASN1_OCTET_STRING *os;
			os = PKCS7_get_octet_string(p7->d.sign->contents);
			if (os && os->length > 0)
				bio = BIO_new_mem_buf(os->data, os->length);
			if(bio == NULL)
				{
a273 1
				}
d275 1
d314 1
a314 1
		data_body=PKCS7_get_octet_string(p7->d.sign->contents);
d322 1
a322 1
		evp_cipher=EVP_get_cipherbyobj(enc_alg->algorithm);
d334 1
a334 1
		evp_cipher=EVP_get_cipherbyobj(enc_alg->algorithm);
d360 1
a360 1
			evp_md=EVP_get_digestbynid(j);
d534 1
a534 1
		os=PKCS7_get_octet_string(p7->d.sign->contents);
d536 1
a536 1
		if(PKCS7_type_is_data(p7->d.sign->contents) && p7->detached) {
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d242 1
a242 7
			if (!M_ASN1_OCTET_STRING_set(ri->enc_key,tmp,jj))
				{
				PKCS7err(PKCS7_F_PKCS7_DATAINIT,
					ERR_R_MALLOC_FAILURE);
				OPENSSL_free(tmp);
				goto err;
				}
d260 4
a263 9
			if (PKCS7_type_is_signed(p7))
				{
				ASN1_OCTET_STRING *os;
				os = PKCS7_get_octet_string(
							p7->d.sign->contents);
				if (os && os->length > 0)
					bio = BIO_new_mem_buf(os->data,
								os->length);
				}
d518 1
a518 5
		if (!(os=M_ASN1_OCTET_STRING_new()))
			{
			PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_MALLOC_FAILURE);
			goto err;
			}
d523 1
a523 5
		if (!(os=M_ASN1_OCTET_STRING_new()))
			{
			PKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_MALLOC_FAILURE);
			goto err;
			}
d597 1
a597 6
					if (!(sign_time=X509_gmtime_adj(NULL,0)))
						{
						PKCS7err(PKCS7_F_PKCS7_DATASIGN,
							ERR_R_MALLOC_FAILURE);
						goto err;
						}
d606 2
a607 13
				if (!(digest=M_ASN1_OCTET_STRING_new()))
					{
					PKCS7err(PKCS7_F_PKCS7_DATASIGN,
						ERR_R_MALLOC_FAILURE);
					goto err;
					}
				if (!M_ASN1_OCTET_STRING_set(digest,md_data,
								md_len))
					{
					PKCS7err(PKCS7_F_PKCS7_DATASIGN,
						ERR_R_MALLOC_FAILURE);
					goto err;
					}
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@a64 1
#include <openssl/err.h>
a103 36
static int PKCS7_bio_add_digest(BIO **pbio, X509_ALGOR *alg)
	{
	BIO *btmp;
	const EVP_MD *md;
	if ((btmp=BIO_new(BIO_f_md())) == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,ERR_R_BIO_LIB);
		goto err;
		}

	md=EVP_get_digestbyobj(alg->algorithm);
	if (md == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,PKCS7_R_UNKNOWN_DIGEST_TYPE);
		goto err;
		}

	BIO_set_md(btmp,md);
	if (*pbio == NULL)
		*pbio=btmp;
	else if (!BIO_push(*pbio,btmp))
		{
		PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,ERR_R_BIO_LIB);
		goto err;
		}
	btmp=NULL;

	return 1;

	err:
	if (btmp)
		BIO_free(btmp);
	return 0;

	}

d108 2
a109 1
	X509_ALGOR *xa = NULL;
a115 1
	ASN1_OCTET_STRING *os=NULL;
a123 1
		os = PKCS7_get_octet_string(p7->d.sign->contents);
a147 4
	case NID_pkcs7_digest:
		xa = p7->d.digest->md;
		os = PKCS7_get_octet_string(p7->d.digest->contents);
		break;
d153 17
a169 3
	for (i=0; i<sk_X509_ALGOR_num(md_sk); i++)
		if (!PKCS7_bio_add_digest(&out, sk_X509_ALGOR_value(md_sk, i)))
			goto err;
d171 8
a178 2
	if (xa && !PKCS7_bio_add_digest(&out, xa))
			goto err;
d197 2
d200 2
a201 9
		if (ivlen > 0)
			if (RAND_pseudo_bytes(iv,ivlen) <= 0)
				goto err;
		if (EVP_CipherInit_ex(ctx, evp_cipher, NULL, NULL, NULL, 1)<=0)
			goto err;
		if (EVP_CIPHER_CTX_rand_key(ctx, key) <= 0)
			goto err;
		if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, 1) <= 0)
			goto err;
d204 2
a205 5
			if (xalg->parameter == NULL) {
				xalg->parameter = ASN1_TYPE_new();
				if (xalg->parameter == NULL)
					goto err;
			}
d207 1
a207 1
			       goto err;
d220 1
a220 2
			if ((pkey=X509_get_pubkey(ri->cert)) == NULL)
				goto err;
d233 1
a233 2
			if ((pkey=X509_get_pubkey(ri->cert)) == NULL)
				goto err;
d264 1
a264 3
		else if (os && os->length > 0)
			bio = BIO_new_mem_buf(os->data, os->length);
		if(bio == NULL)
d266 14
a279 4
			bio=BIO_new(BIO_s_mem());
			if (bio == NULL)
				goto err;
			BIO_set_mem_eof_return(bio,0);
d281 1
a281 1
		}
a295 11
static int pkcs7_cmp_ri(PKCS7_RECIP_INFO *ri, X509 *pcert)
	{
	int ret;
	ret = X509_NAME_cmp(ri->issuer_and_serial->issuer,
				pcert->cert_info->issuer);
	if (ret)
		return ret;
	return M_ASN1_INTEGER_cmp(pcert->cert_info->serialNumber,
					ri->issuer_and_serial->serial);
	}

d406 12
a417 12
		if (pcert) {
			for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {
				ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
				if (!pkcs7_cmp_ri(ri, pcert))
					break;
				ri=NULL;
			}
			if (ri == NULL) {
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
				      PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
				goto err;
			}
d428 3
a430 3
		/* If we haven't got a certificate try each ri in turn */

		if (pcert == NULL)
d432 2
a433 30
			for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)
				{
				ri=sk_PKCS7_RECIP_INFO_value(rsk,i);
				jj=EVP_PKEY_decrypt(tmp,
					M_ASN1_STRING_data(ri->enc_key),
					M_ASN1_STRING_length(ri->enc_key),
						pkey);
				if (jj > 0)
					break;
				ERR_clear_error();
				ri = NULL;
				}
			if (ri == NULL)
				{
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
				      PKCS7_R_NO_RECIPIENT_MATCHES_KEY);
				goto err;
				}
			}
		else
			{
			jj=EVP_PKEY_decrypt(tmp,
				M_ASN1_STRING_data(ri->enc_key),
				M_ASN1_STRING_length(ri->enc_key), pkey);
			if (jj <= 0)
				{
				PKCS7err(PKCS7_F_PKCS7_DATADECODE,
								ERR_R_EVP_LIB);
				goto err;
				}
d438 1
a438 2
		if (EVP_CipherInit_ex(evp_ctx,evp_cipher,NULL,NULL,NULL,0) <= 0)
			goto err;
d454 1
a454 2
		if (EVP_CipherInit_ex(evp_ctx,NULL,NULL,tmp,NULL,0) <= 0)
			goto err;
a487 2
		if (bio == NULL)
			goto err;
a506 23
static BIO *PKCS7_find_digest(EVP_MD_CTX **pmd, BIO *bio, int nid)
	{
	for (;;)
		{
		bio=BIO_find_type(bio,BIO_TYPE_MD);
		if (bio == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
			return NULL;	
			}
		BIO_get_md_ctx(bio,pmd);
		if (*pmd == NULL)
			{
			PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,ERR_R_INTERNAL_ERROR);
			return NULL;
			}	
		if (EVP_MD_CTX_type(*pmd) == nid)
			return bio;
		bio=BIO_next(bio);
		}
	return NULL;
	}

d531 1
a531 1
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);
d540 1
a540 1
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);
a553 11

	case NID_pkcs7_digest:
		os=PKCS7_get_octet_string(p7->d.digest->contents);
		/* If detached data then the content is excluded */
		if(PKCS7_type_is_data(p7->d.digest->contents) && p7->detached)
			{
			M_ASN1_OCTET_STRING_free(os);
			p7->d.digest->contents->d.data = NULL;
			}
		break;

d560 1
a560 1
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_BIO_LIB);
d571 20
a590 6

			btmp = PKCS7_find_digest(&mdc, btmp, j);

			if (btmp == NULL)
				goto err;

d596 1
a596 1
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_BIO_LIB);
d618 1
a618 1
						PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
d622 1
a622 1
					if (!PKCS7_add_signed_attribute(si,
d624 1
a624 5
						V_ASN1_UTCTIME,sign_time))
						{
						M_ASN1_UTCTIME_free(sign_time);
						goto err;
						}
d632 1
a632 1
					PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
d639 1
a639 1
					PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
a640 1
					M_ASN1_OCTET_STRING_free(digest);
d643 1
a643 1
				if (!PKCS7_add_signed_attribute(si,
d645 1
a645 5
					V_ASN1_OCTET_STRING,digest))
					{
					M_ASN1_OCTET_STRING_free(digest);
					goto err;
					}
a659 4
#ifndef OPENSSL_NO_ECDSA
 			if (si->pkey->type == EVP_PKEY_EC)
 				ctx_tmp.digest=EVP_ecdsa();
#endif
d664 1
a664 1
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_EVP_LIB);
d670 1
a670 1
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_ASN1_LIB);
a674 10
	else if (i == NID_pkcs7_digest)
		{
		unsigned char md_data[EVP_MAX_MD_SIZE];
		unsigned int md_len;
		if (!PKCS7_find_digest(&mdc, bio,
				OBJ_obj2nid(p7->d.digest->md->algorithm)))
			goto err;
		EVP_DigestFinal_ex(mdc,md_data,&md_len);
		M_ASN1_OCTET_STRING_set(p7->d.digest->digest, md_data, md_len);
		}
d681 1
a681 1
			PKCS7err(PKCS7_F_PKCS7_DATAFINAL,PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
a861 3
#ifndef OPENSSL_NO_ECDSA
	if (pkey->type == EVP_PKEY_EC) mdc_tmp.digest=EVP_ecdsa();
#endif
d886 1
a886 4
	if (i != NID_pkcs7_signedAndEnveloped)
		return NULL;
	if (p7->d.signed_and_enveloped == NULL)
		return NULL;
a887 2
	if (rsk == NULL)
		return NULL;
a940 2
	if (p7si->auth_attr == NULL)
		return 0;
a958 2
	if (p7si->unauth_attr == NULL)
		return 0;
d988 1
a988 2
		if (!(*sk = sk_X509_ATTRIBUTE_new_null()))
			return 0;
d990 2
a991 7
		if (!(attr=X509_ATTRIBUTE_create(nid,atrtype,value)))
			return 0;
		if (!sk_X509_ATTRIBUTE_push(*sk,attr))
			{
			X509_ATTRIBUTE_free(attr);
			return 0;
			}
d1004 1
a1004 7
				if (attr == NULL)
					return 0;
				if (!sk_X509_ATTRIBUTE_set(*sk,i,attr))
					{
					X509_ATTRIBUTE_free(attr);
					return 0;
					}
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@a140 115
static int pkcs7_encode_rinfo(PKCS7_RECIP_INFO *ri,
					unsigned char *key, int keylen)
	{
	EVP_PKEY_CTX *pctx = NULL;
	EVP_PKEY *pkey = NULL;
	unsigned char *ek = NULL;
	int ret = 0;
	size_t eklen;

	pkey = X509_get_pubkey(ri->cert);

	if (!pkey)
		return 0;

	pctx = EVP_PKEY_CTX_new(pkey, NULL);
	if (!pctx)
		return 0;

	if (EVP_PKEY_encrypt_init(pctx) <= 0)
		goto err;

	if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_ENCRYPT,
				EVP_PKEY_CTRL_PKCS7_ENCRYPT, 0, ri) <= 0)
		{
		PKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, PKCS7_R_CTRL_ERROR);
		goto err;
		}

	if (EVP_PKEY_encrypt(pctx, NULL, &eklen, key, keylen) <= 0)
		goto err;

	ek = OPENSSL_malloc(eklen);

	if (ek == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, ERR_R_MALLOC_FAILURE);
		goto err;
		}

	if (EVP_PKEY_encrypt(pctx, ek, &eklen, key, keylen) <= 0)
		goto err;

	ASN1_STRING_set0(ri->enc_key, ek, eklen);
	ek = NULL;

	ret = 1;

	err:
	if (pkey)
		EVP_PKEY_free(pkey);
	if (pctx)
		EVP_PKEY_CTX_free(pctx);
	if (ek)
		OPENSSL_free(ek);
	return ret;

	}


static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,
			       PKCS7_RECIP_INFO *ri, EVP_PKEY *pkey)
	{
	EVP_PKEY_CTX *pctx = NULL;
	unsigned char *ek = NULL;
	size_t eklen;

	int ret = 0;

	pctx = EVP_PKEY_CTX_new(pkey, NULL);
	if (!pctx)
		return 0;

	if (EVP_PKEY_decrypt_init(pctx) <= 0)
		goto err;

	if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DECRYPT,
				EVP_PKEY_CTRL_PKCS7_DECRYPT, 0, ri) <= 0)
		{
		PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, PKCS7_R_CTRL_ERROR);
		goto err;
		}

	if (EVP_PKEY_decrypt(pctx, NULL, &eklen,
				ri->enc_key->data, ri->enc_key->length) <= 0)
		goto err;

	ek = OPENSSL_malloc(eklen);

	if (ek == NULL)
		{
		PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_MALLOC_FAILURE);
		goto err;
		}

	if (EVP_PKEY_decrypt(pctx, ek, &eklen,
				ri->enc_key->data, ri->enc_key->length) <= 0)
		{
		PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_EVP_LIB);
		goto err;
		}

	ret = 1;

	*pek = ek;
	*peklen = eklen;

	err:
	if (pctx)
		EVP_PKEY_CTX_free(pctx);
	if (!ret && ek)
		OPENSSL_free(ek);

	return ret;
	}

d151 1
a189 2
	case NID_pkcs7_data:
		break;
d207 2
d237 1
a237 1
				goto err;
d241 1
d245 6
a250 1
			if (pkcs7_encode_rinfo(ri, key, keylen) <= 0)
d252 8
d261 22
d306 1
a306 4
	if (out)
		BIO_push(out,bio);
	else
		out = bio;
d336 1
d426 1
a426 2
		unsigned char *ek = NULL;
		int eklen;
d441 2
a442 4
		if (pcert)
			{
			for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)
				{
d447 2
a448 3
				}
			if (ri == NULL)
				{
d452 9
a460 1
				}
d470 5
a474 2
				if (pkcs7_decrypt_rinfo(&ek, &eklen,
							ri, pkey) > 0)
d488 7
a494 1
			if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) <= 0)
d496 1
d506 1
a506 1
		if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) {
d511 1
a511 1
			if(!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen))
d518 1
a518 1
		if (EVP_CipherInit_ex(evp_ctx,NULL,NULL,ek,NULL,0) <= 0)
d521 1
a521 5
		if (ek)
			{
			OPENSSL_cleanse(ek,eklen);
			OPENSSL_free(ek);
			}
d569 2
a596 32
static int do_pkcs7_signed_attrib(PKCS7_SIGNER_INFO *si, EVP_MD_CTX *mctx)
	{
	unsigned char md_data[EVP_MAX_MD_SIZE];
	unsigned int md_len;

	/* Add signing time if not already present */
	if (!PKCS7_get_signed_attribute(si, NID_pkcs9_signingTime))
		{
		if (!PKCS7_add0_attrib_signing_time(si, NULL))
			{
			PKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB,
					ERR_R_MALLOC_FAILURE);
			return 0;
			}
		}

	/* Add digest */
	EVP_DigestFinal_ex(mctx, md_data,&md_len);
	if (!PKCS7_add1_attrib_digest(si, md_data, md_len))
		{
		PKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_MALLOC_FAILURE);
		return 0;
		}

	/* Now sign the attributes */
	if (!PKCS7_SIGNER_INFO_sign(si))
			return 0;

	return 1;
	}
	
				
d602 2
a615 3
	case NID_pkcs7_data:
		os = p7->d.data;
		break;
d619 1
a619 2
		os = p7->d.signed_and_enveloped->enc_data->enc_data;
		if (!os)
d621 2
a622 7
			os=M_ASN1_OCTET_STRING_new();
			if (!os)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);
				goto err;
				}
			p7->d.signed_and_enveloped->enc_data->enc_data=os;
d624 1
d628 1
a628 2
		os = p7->d.enveloped->enc_data->enc_data;
		if (!os)
d630 2
a631 7
			os=M_ASN1_OCTET_STRING_new();
			if (!os)
				{
				PKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);
				goto err;
				}
			p7->d.enveloped->enc_data->enc_data=os;
d633 1
a654 3
	default:
		PKCS7err(PKCS7_F_PKCS7_DATAFINAL,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
	        goto err;
d659 5
d667 1
a667 2
			if (si->pkey == NULL)
				continue;
d669 1
a669 1
			j = OBJ_obj2nid(si->digest_alg->algorithm);
d681 5
d691 1
a691 1
			if (sk_X509_ATTRIBUTE_num(sk) > 0)
d693 32
a724 1
				if (!do_pkcs7_signed_attrib(si, &ctx_tmp))
d726 7
a732 8
				}
			else
				{
				unsigned char *abuf = NULL;
				unsigned int abuflen;
				abuflen = EVP_PKEY_size(si->pkey);
				abuf = OPENSSL_malloc(abuflen);
				if (!abuf)
d734 4
a737 3

				if (!EVP_SignFinal(&ctx_tmp, abuf, &abuflen,
							si->pkey))
d739 1
a739 2
					PKCS7err(PKCS7_F_PKCS7_DATAFINAL,
							ERR_R_EVP_LIB);
d742 30
a771 1
				ASN1_STRING_set0(si->enc_digest, abuf, abuflen);
d786 1
a786 1
	if (!PKCS7_is_detached(p7) && !(os->flags & ASN1_STRING_FLAG_NDEF))
a787 2
		char *cont;
		long contlen;
d794 1
a794 1
		contlen = BIO_get_mem_data(btmp, &cont);
d800 6
a805 1
		ASN1_STRING_set0(os, (unsigned char *)cont, contlen);
d810 1
a813 60
int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)
	{
	EVP_MD_CTX mctx;
	EVP_PKEY_CTX *pctx;
	unsigned char *abuf = NULL;
	int alen;
	size_t siglen;
	const EVP_MD *md = NULL;

	md = EVP_get_digestbyobj(si->digest_alg->algorithm);
	if (md == NULL)
		return 0;

	EVP_MD_CTX_init(&mctx);
	if (EVP_DigestSignInit(&mctx, &pctx, md,NULL, si->pkey) <= 0)
		goto err;

	if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
				EVP_PKEY_CTRL_PKCS7_SIGN, 0, si) <= 0)
		{
		PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);
		goto err;
		}

	alen = ASN1_item_i2d((ASN1_VALUE *)si->auth_attr,&abuf,
				ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));
	if(!abuf)
		goto err;
	if (EVP_DigestSignUpdate(&mctx,abuf,alen) <= 0)
		goto err;
	OPENSSL_free(abuf);
	if (EVP_DigestSignFinal(&mctx, NULL, &siglen) <= 0)
		goto err;
	abuf = OPENSSL_malloc(siglen);
	if(!abuf)
		goto err;
	if (EVP_DigestSignFinal(&mctx, abuf, &siglen) <= 0)
		goto err;

	if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
				EVP_PKEY_CTRL_PKCS7_SIGN, 1, si) <= 0)
		{
		PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);
		goto err;
		}

	EVP_MD_CTX_cleanup(&mctx);

	ASN1_STRING_set0(si->enc_digest, abuf, siglen);

	return 1;

	err:
	if (abuf)
		OPENSSL_free(abuf);
	EVP_MD_CTX_cleanup(&mctx);
	return 0;

	}

d925 1
a925 2
                unsigned int md_len;
		int alen;
a956 6
		if (alen <= 0) 
			{
			PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,ERR_R_ASN1_LIB);
			ret = -1;
			goto err;
			}
d969 6
d1110 2
a1111 3
		*sk = sk_X509_ATTRIBUTE_new_null();
		if (*sk == NULL)
			return 0;	
@


1.1.1.9
log
@import OpenSSL 1.0.0e
@
text
@d425 1
d448 1
d460 1
@


1.1.1.10
log
@import OpenSSL-1.0.1c
@
text
@d207 1
a207 1
	int ret = -1;
d211 1
a211 1
		return -1;
a237 1
		ret = 0;
a243 6
	if (*pek)
		{
		OPENSSL_cleanse(*pek, *peklen);
		OPENSSL_free(*pek);
		}

a425 2
       unsigned char *ek = NULL, *tkey = NULL;
       int eklen = 0, tkeylen = 0;
d503 2
d537 1
a539 4
			/* Always attempt to decrypt all rinfo even
			 * after sucess as a defence against MMA timing
			 * attacks.
			 */
a542 1
				
d544 2
a545 2
							ri, pkey) < 0)
					goto err;
d547 7
d558 1
a558 2
			/* Only exit on fatal errors, not decrypt failure */
			if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)
a559 1
			ERR_clear_error();
a567 13
		/* Generate random key as MMA defence */
		tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);
		tkey = OPENSSL_malloc(tkeylen);
		if (!tkey)
			goto err;
		if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)
			goto err;
		if (ek == NULL)
			{
			ek = tkey;
			eklen = tkeylen;
			tkey = NULL;
			}
d576 3
a578 6
				/* Use random key as MMA defence */
				OPENSSL_cleanse(ek, eklen);
				OPENSSL_free(ek);
				ek = tkey;
				eklen = tkeylen;
				tkey = NULL;
a580 2
		/* Clear errors so we don't leak information useful in MMA */
		ERR_clear_error();
a587 7
                       ek = NULL;
			}
		if (tkey)
			{
			OPENSSL_cleanse(tkey,tkeylen);
			OPENSSL_free(tkey);
                       tkey = NULL;
a629 10
               if (ek)
                       {
                       OPENSSL_cleanse(ek,eklen);
                       OPENSSL_free(ek);
                       }
               if (tkey)
                       {
                       OPENSSL_cleanse(tkey,tkeylen);
                       OPENSSL_free(tkey);
                       }
d679 1
a679 5
	if (!EVP_DigestFinal_ex(mctx, md_data,&md_len))
		{
		PKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_EVP_LIB);
		return 0;
		}
d787 1
a787 2
			if (!EVP_MD_CTX_copy_ex(&ctx_tmp,mdc))
				goto err;
d825 1
a825 2
		if (!EVP_DigestFinal_ex(mdc,md_data,&md_len))
			goto err;
d1018 1
a1018 2
	if (!EVP_MD_CTX_copy_ex(&mdc_tmp,mdc))
		goto err;
d1028 1
a1028 2
		if (!EVP_DigestFinal_ex(&mdc_tmp,md_dat,&md_len))
			goto err;
d1053 1
a1053 2
		if (!EVP_VerifyInit_ex(&mdc_tmp,EVP_get_digestbynid(md_type), NULL))
			goto err;
d1063 1
a1063 2
		if (!EVP_VerifyUpdate(&mdc_tmp, abuf, alen))
			goto err;
@


