head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21;
locks; strict;
comment	@ * @;


1.21
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.20;
commitid	kT0fLt3r4lroFJra;

1.20
date	2016.03.11.07.08.45;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	MTdM7aVFdRMAzAYE;

1.19
date	2015.09.30.18.04.02;	author jsing;	state Exp;
branches;
next	1.18;
commitid	XW9OIeABPcn8Y4ca;

1.18
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.17;
commitid	G74O1dmRukKsW7IJ;

1.17
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.16;
commitid	yQEL1wOWIearrW15;

1.16
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.15;
commitid	id8dTrTMtnTn4fqt;

1.15
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	mJUVYpkFBZ0Zv2bG;

1.14
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	2nvnQBrv22dLtvTt;

1.13
date	2014.05.27.21.29.43;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2014.05.25.20.28.50;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.05.22.17.27.50;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.27.20.20.59;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.21.16.32.06;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.20.19.55.09;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.16.17.46.23;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.16.16.49.12;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.16.15.39.45;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.16.15.35.36;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: ts_rsp_sign.c,v 1.20 2016/03/11 07:08:45 mmcc Exp $ */
/* Written by Zoltan Glozik (zglozik@@stones.com) for the OpenSSL
 * project 2002.
 */
/* ====================================================================
 * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <sys/time.h>

#include <string.h>

#include <openssl/err.h>
#include <openssl/objects.h>
#include <openssl/pkcs7.h>
#include <openssl/ts.h>

/* Private function declarations. */

static ASN1_INTEGER *def_serial_cb(struct TS_resp_ctx *, void *);
static int def_time_cb(struct TS_resp_ctx *, void *, time_t *sec, long *usec);
static int def_extension_cb(struct TS_resp_ctx *, X509_EXTENSION *, void *);

static void TS_RESP_CTX_init(TS_RESP_CTX *ctx);
static void TS_RESP_CTX_cleanup(TS_RESP_CTX *ctx);
static int TS_RESP_check_request(TS_RESP_CTX *ctx);
static ASN1_OBJECT *TS_RESP_get_policy(TS_RESP_CTX *ctx);
static TS_TST_INFO *TS_RESP_create_tst_info(TS_RESP_CTX *ctx,
    ASN1_OBJECT *policy);
static int TS_RESP_process_extensions(TS_RESP_CTX *ctx);
static int TS_RESP_sign(TS_RESP_CTX *ctx);

static ESS_SIGNING_CERT *ESS_SIGNING_CERT_new_init(X509 *signcert,
    STACK_OF(X509) *certs);
static ESS_CERT_ID *ESS_CERT_ID_new_init(X509 *cert, int issuer_needed);
static int TS_TST_INFO_content_new(PKCS7 *p7);
static int ESS_add_signing_cert(PKCS7_SIGNER_INFO *si, ESS_SIGNING_CERT *sc);

static ASN1_GENERALIZEDTIME *TS_RESP_set_genTime_with_precision(
    ASN1_GENERALIZEDTIME *, time_t, long, unsigned);

/* Default callbacks for response generation. */

static ASN1_INTEGER *
def_serial_cb(struct TS_resp_ctx *ctx, void *data)
{
	ASN1_INTEGER *serial = ASN1_INTEGER_new();

	if (!serial)
		goto err;
	if (!ASN1_INTEGER_set(serial, 1))
		goto err;
	return serial;

err:
	TSerror(ERR_R_MALLOC_FAILURE);
	TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
	    "Error during serial number generation.");
	return NULL;
}

/* Use the gettimeofday function call. */
static int
def_time_cb(struct TS_resp_ctx *ctx, void *data, time_t *sec, long *usec)
{
	struct timeval tv;

	if (gettimeofday(&tv, NULL) != 0) {
		TSerror(TS_R_TIME_SYSCALL_ERROR);
		TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
		    "Time is not available.");
		TS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);
		return 0;
	}
	/* Return time to caller. */
	*sec = tv.tv_sec;
	*usec = tv.tv_usec;

	return 1;
}

static int
def_extension_cb(struct TS_resp_ctx *ctx, X509_EXTENSION *ext, void *data)
{
	/* No extensions are processed here. */
	TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
	    "Unsupported extension.");
	TS_RESP_CTX_add_failure_info(ctx, TS_INFO_UNACCEPTED_EXTENSION);
	return 0;
}

/* TS_RESP_CTX management functions. */

TS_RESP_CTX *
TS_RESP_CTX_new(void)
{
	TS_RESP_CTX *ctx;

	if (!(ctx = calloc(1, sizeof(TS_RESP_CTX)))) {
		TSerror(ERR_R_MALLOC_FAILURE);
		return NULL;
	}

	/* Setting default callbacks. */
	ctx->serial_cb = def_serial_cb;
	ctx->time_cb = def_time_cb;
	ctx->extension_cb = def_extension_cb;

	return ctx;
}

void
TS_RESP_CTX_free(TS_RESP_CTX *ctx)
{
	if (!ctx)
		return;

	X509_free(ctx->signer_cert);
	EVP_PKEY_free(ctx->signer_key);
	sk_X509_pop_free(ctx->certs, X509_free);
	sk_ASN1_OBJECT_pop_free(ctx->policies, ASN1_OBJECT_free);
	ASN1_OBJECT_free(ctx->default_policy);
	sk_EVP_MD_free(ctx->mds);	/* No EVP_MD_free method exists. */
	ASN1_INTEGER_free(ctx->seconds);
	ASN1_INTEGER_free(ctx->millis);
	ASN1_INTEGER_free(ctx->micros);
	free(ctx);
}

int
TS_RESP_CTX_set_signer_cert(TS_RESP_CTX *ctx, X509 *signer)
{
	if (X509_check_purpose(signer, X509_PURPOSE_TIMESTAMP_SIGN, 0) != 1) {
		TSerror(TS_R_INVALID_SIGNER_CERTIFICATE_PURPOSE);
		return 0;
	}
	X509_free(ctx->signer_cert);
	ctx->signer_cert = signer;
	CRYPTO_add(&ctx->signer_cert->references, +1, CRYPTO_LOCK_X509);
	return 1;
}

int
TS_RESP_CTX_set_signer_key(TS_RESP_CTX *ctx, EVP_PKEY *key)
{
	EVP_PKEY_free(ctx->signer_key);
	ctx->signer_key = key;
	CRYPTO_add(&ctx->signer_key->references, +1, CRYPTO_LOCK_EVP_PKEY);

	return 1;
}

int
TS_RESP_CTX_set_def_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *def_policy)
{
	if (ctx->default_policy)
		ASN1_OBJECT_free(ctx->default_policy);
	if (!(ctx->default_policy = OBJ_dup(def_policy)))
		goto err;
	return 1;

err:
	TSerror(ERR_R_MALLOC_FAILURE);
	return 0;
}

int
TS_RESP_CTX_set_certs(TS_RESP_CTX *ctx, STACK_OF(X509) *certs)
{
	int i;

	if (ctx->certs) {
		sk_X509_pop_free(ctx->certs, X509_free);
		ctx->certs = NULL;
	}
	if (!certs)
		return 1;
	if (!(ctx->certs = sk_X509_dup(certs))) {
		TSerror(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	for (i = 0; i < sk_X509_num(ctx->certs); ++i) {
		X509 *cert = sk_X509_value(ctx->certs, i);
		CRYPTO_add(&cert->references, +1, CRYPTO_LOCK_X509);
	}

	return 1;
}

int
TS_RESP_CTX_add_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *policy)
{
	ASN1_OBJECT *copy = NULL;

	/* Create new policy stack if necessary. */
	if (!ctx->policies && !(ctx->policies = sk_ASN1_OBJECT_new_null()))
		goto err;
	if (!(copy = OBJ_dup(policy)))
		goto err;
	if (!sk_ASN1_OBJECT_push(ctx->policies, copy))
		goto err;

	return 1;

err:
	TSerror(ERR_R_MALLOC_FAILURE);
	ASN1_OBJECT_free(copy);
	return 0;
}

int
TS_RESP_CTX_add_md(TS_RESP_CTX *ctx, const EVP_MD *md)
{
	/* Create new md stack if necessary. */
	if (!ctx->mds && !(ctx->mds = sk_EVP_MD_new_null()))
		goto err;
	/* Add the shared md, no copy needed. */
	if (!sk_EVP_MD_push(ctx->mds, (EVP_MD *)md))
		goto err;

	return 1;

err:
	TSerror(ERR_R_MALLOC_FAILURE);
	return 0;
}

#define TS_RESP_CTX_accuracy_free(ctx)		\
	ASN1_INTEGER_free(ctx->seconds);	\
	ctx->seconds = NULL;			\
	ASN1_INTEGER_free(ctx->millis);		\
	ctx->millis = NULL;			\
	ASN1_INTEGER_free(ctx->micros);		\
	ctx->micros = NULL;

int
TS_RESP_CTX_set_accuracy(TS_RESP_CTX *ctx, int secs, int millis, int micros)
{
	TS_RESP_CTX_accuracy_free(ctx);
	if (secs && (!(ctx->seconds = ASN1_INTEGER_new()) ||
	    !ASN1_INTEGER_set(ctx->seconds, secs)))
		goto err;
	if (millis && (!(ctx->millis = ASN1_INTEGER_new()) ||
	    !ASN1_INTEGER_set(ctx->millis, millis)))
		goto err;
	if (micros && (!(ctx->micros = ASN1_INTEGER_new()) ||
	    !ASN1_INTEGER_set(ctx->micros, micros)))
		goto err;

	return 1;

err:
	TS_RESP_CTX_accuracy_free(ctx);
	TSerror(ERR_R_MALLOC_FAILURE);
	return 0;
}

void
TS_RESP_CTX_add_flags(TS_RESP_CTX *ctx, int flags)
{
	ctx->flags |= flags;
}

void
TS_RESP_CTX_set_serial_cb(TS_RESP_CTX *ctx, TS_serial_cb cb, void *data)
{
	ctx->serial_cb = cb;
	ctx->serial_cb_data = data;
}

void
TS_RESP_CTX_set_extension_cb(TS_RESP_CTX *ctx, TS_extension_cb cb, void *data)
{
	ctx->extension_cb = cb;
	ctx->extension_cb_data = data;
}

int
TS_RESP_CTX_set_status_info(TS_RESP_CTX *ctx, int status, const char *text)
{
	TS_STATUS_INFO *si = NULL;
	ASN1_UTF8STRING *utf8_text = NULL;
	int ret = 0;

	if (!(si = TS_STATUS_INFO_new()))
		goto err;
	if (!ASN1_INTEGER_set(si->status, status))
		goto err;
	if (text) {
		if (!(utf8_text = ASN1_UTF8STRING_new()) ||
		    !ASN1_STRING_set(utf8_text, text, strlen(text)))
			goto err;
		if (!si->text && !(si->text = sk_ASN1_UTF8STRING_new_null()))
			goto err;
		if (!sk_ASN1_UTF8STRING_push(si->text, utf8_text))
			goto err;
		utf8_text = NULL;	/* Ownership is lost. */
	}
	if (!TS_RESP_set_status_info(ctx->response, si))
		goto err;
	ret = 1;

err:
	if (!ret)
		TSerror(ERR_R_MALLOC_FAILURE);
	TS_STATUS_INFO_free(si);
	ASN1_UTF8STRING_free(utf8_text);
	return ret;
}

int
TS_RESP_CTX_set_status_info_cond(TS_RESP_CTX *ctx, int status, const char *text)
{
	int ret = 1;
	TS_STATUS_INFO *si = TS_RESP_get_status_info(ctx->response);

	if (ASN1_INTEGER_get(si->status) == TS_STATUS_GRANTED) {
		/* Status has not been set, set it now. */
		ret = TS_RESP_CTX_set_status_info(ctx, status, text);
	}
	return ret;
}

int
TS_RESP_CTX_add_failure_info(TS_RESP_CTX *ctx, int failure)
{
	TS_STATUS_INFO *si = TS_RESP_get_status_info(ctx->response);

	if (!si->failure_info && !(si->failure_info = ASN1_BIT_STRING_new()))
		goto err;
	if (!ASN1_BIT_STRING_set_bit(si->failure_info, failure, 1))
		goto err;
	return 1;

err:
	TSerror(ERR_R_MALLOC_FAILURE);
	return 0;
}

TS_REQ *
TS_RESP_CTX_get_request(TS_RESP_CTX *ctx)
{
	return ctx->request;
}

TS_TST_INFO *
TS_RESP_CTX_get_tst_info(TS_RESP_CTX *ctx)
{
	return ctx->tst_info;
}

int
TS_RESP_CTX_set_clock_precision_digits(TS_RESP_CTX *ctx, unsigned precision)
{
	if (precision > TS_MAX_CLOCK_PRECISION_DIGITS)
		return 0;
	ctx->clock_precision_digits = precision;
	return 1;
}

/* Main entry method of the response generation. */
TS_RESP *
TS_RESP_create_response(TS_RESP_CTX *ctx, BIO *req_bio)
{
	ASN1_OBJECT *policy;
	TS_RESP *response;
	int result = 0;

	TS_RESP_CTX_init(ctx);

	/* Creating the response object. */
	if (!(ctx->response = TS_RESP_new())) {
		TSerror(ERR_R_MALLOC_FAILURE);
		goto end;
	}

	/* Parsing DER request. */
	if (!(ctx->request = d2i_TS_REQ_bio(req_bio, NULL))) {
		TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
		    "Bad request format or "
		    "system error.");
		TS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_DATA_FORMAT);
		goto end;
	}

	/* Setting default status info. */
	if (!TS_RESP_CTX_set_status_info(ctx, TS_STATUS_GRANTED, NULL))
		goto end;

	/* Checking the request format. */
	if (!TS_RESP_check_request(ctx))
		goto end;

	/* Checking acceptable policies. */
	if (!(policy = TS_RESP_get_policy(ctx)))
		goto end;

	/* Creating the TS_TST_INFO object. */
	if (!(ctx->tst_info = TS_RESP_create_tst_info(ctx, policy)))
		goto end;

	/* Processing extensions. */
	if (!TS_RESP_process_extensions(ctx))
		goto end;

	/* Generating the signature. */
	if (!TS_RESP_sign(ctx))
		goto end;

	/* Everything was successful. */
	result = 1;

end:
	if (!result) {
		TSerror(TS_R_RESPONSE_SETUP_ERROR);
		if (ctx->response != NULL) {
			if (TS_RESP_CTX_set_status_info_cond(ctx,
			    TS_STATUS_REJECTION, "Error during response "
			    "generation.") == 0) {
				TS_RESP_free(ctx->response);
				ctx->response = NULL;
			}
		}
	}
	response = ctx->response;
	ctx->response = NULL;	/* Ownership will be returned to caller. */
	TS_RESP_CTX_cleanup(ctx);
	return response;
}

/* Initializes the variable part of the context. */
static void
TS_RESP_CTX_init(TS_RESP_CTX *ctx)
{
	ctx->request = NULL;
	ctx->response = NULL;
	ctx->tst_info = NULL;
}

/* Cleans up the variable part of the context. */
static void
TS_RESP_CTX_cleanup(TS_RESP_CTX *ctx)
{
	TS_REQ_free(ctx->request);
	ctx->request = NULL;
	TS_RESP_free(ctx->response);
	ctx->response = NULL;
	TS_TST_INFO_free(ctx->tst_info);
	ctx->tst_info = NULL;
}

/* Checks the format and content of the request. */
static int
TS_RESP_check_request(TS_RESP_CTX *ctx)
{
	TS_REQ *request = ctx->request;
	TS_MSG_IMPRINT *msg_imprint;
	X509_ALGOR *md_alg;
	int md_alg_id;
	const ASN1_OCTET_STRING *digest;
	EVP_MD *md = NULL;
	int i;

	/* Checking request version. */
	if (TS_REQ_get_version(request) != 1) {
		TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
		    "Bad request version.");
		TS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_REQUEST);
		return 0;
	}

	/* Checking message digest algorithm. */
	msg_imprint = TS_REQ_get_msg_imprint(request);
	md_alg = TS_MSG_IMPRINT_get_algo(msg_imprint);
	md_alg_id = OBJ_obj2nid(md_alg->algorithm);
	for (i = 0; !md && i < sk_EVP_MD_num(ctx->mds); ++i) {
		EVP_MD *current_md = sk_EVP_MD_value(ctx->mds, i);
		if (md_alg_id == EVP_MD_type(current_md))
			md = current_md;
	}
	if (!md) {
		TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
		    "Message digest algorithm is "
		    "not supported.");
		TS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_ALG);
		return 0;
	}

	/* No message digest takes parameter. */
	if (md_alg->parameter &&
	    ASN1_TYPE_get(md_alg->parameter) != V_ASN1_NULL) {
		TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
		    "Superfluous message digest "
		    "parameter.");
		TS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_ALG);
		return 0;
	}
	/* Checking message digest size. */
	digest = TS_MSG_IMPRINT_get_msg(msg_imprint);
	if (digest->length != EVP_MD_size(md)) {
		TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
		    "Bad message digest.");
		TS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_DATA_FORMAT);
		return 0;
	}

	return 1;
}

/* Returns the TSA policy based on the requested and acceptable policies. */
static ASN1_OBJECT *
TS_RESP_get_policy(TS_RESP_CTX *ctx)
{
	ASN1_OBJECT *requested = TS_REQ_get_policy_id(ctx->request);
	ASN1_OBJECT *policy = NULL;
	int i;

	if (ctx->default_policy == NULL) {
		TSerror(TS_R_INVALID_NULL_POINTER);
		return NULL;
	}
	/* Return the default policy if none is requested or the default is
	   requested. */
	if (!requested || !OBJ_cmp(requested, ctx->default_policy))
		policy = ctx->default_policy;

	/* Check if the policy is acceptable. */
	for (i = 0; !policy && i < sk_ASN1_OBJECT_num(ctx->policies); ++i) {
		ASN1_OBJECT *current = sk_ASN1_OBJECT_value(ctx->policies, i);
		if (!OBJ_cmp(requested, current))
			policy = current;
	}
	if (!policy) {
		TSerror(TS_R_UNACCEPTABLE_POLICY);
		TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
		    "Requested policy is not "
		    "supported.");
		TS_RESP_CTX_add_failure_info(ctx, TS_INFO_UNACCEPTED_POLICY);
	}
	return policy;
}

/* Creates the TS_TST_INFO object based on the settings of the context. */
static TS_TST_INFO *
TS_RESP_create_tst_info(TS_RESP_CTX *ctx, ASN1_OBJECT *policy)
{
	int result = 0;
	TS_TST_INFO *tst_info = NULL;
	ASN1_INTEGER *serial = NULL;
	ASN1_GENERALIZEDTIME *asn1_time = NULL;
	time_t sec;
	long usec;
	TS_ACCURACY *accuracy = NULL;
	const ASN1_INTEGER *nonce;
	GENERAL_NAME *tsa_name = NULL;

	if (!(tst_info = TS_TST_INFO_new()))
		goto end;
	if (!TS_TST_INFO_set_version(tst_info, 1))
		goto end;
	if (!TS_TST_INFO_set_policy_id(tst_info, policy))
		goto end;
	if (!TS_TST_INFO_set_msg_imprint(tst_info, ctx->request->msg_imprint))
		goto end;
	if (!(serial = (*ctx->serial_cb)(ctx, ctx->serial_cb_data)) ||
	    !TS_TST_INFO_set_serial(tst_info, serial))
		goto end;
	if (!(*ctx->time_cb)(ctx, ctx->time_cb_data, &sec, &usec) ||
	    !(asn1_time = TS_RESP_set_genTime_with_precision(NULL, sec, usec,
	    ctx->clock_precision_digits)) ||
	    !TS_TST_INFO_set_time(tst_info, asn1_time))
		goto end;

	/* Setting accuracy if needed. */
	if ((ctx->seconds || ctx->millis || ctx->micros) &&
	    !(accuracy = TS_ACCURACY_new()))
		goto end;

	if (ctx->seconds && !TS_ACCURACY_set_seconds(accuracy, ctx->seconds))
		goto end;
	if (ctx->millis && !TS_ACCURACY_set_millis(accuracy, ctx->millis))
		goto end;
	if (ctx->micros && !TS_ACCURACY_set_micros(accuracy, ctx->micros))
		goto end;
	if (accuracy && !TS_TST_INFO_set_accuracy(tst_info, accuracy))
		goto end;

	/* Setting ordering. */
	if ((ctx->flags & TS_ORDERING) &&
	    !TS_TST_INFO_set_ordering(tst_info, 1))
		goto end;

	/* Setting nonce if needed. */
	if ((nonce = TS_REQ_get_nonce(ctx->request)) != NULL &&
	    !TS_TST_INFO_set_nonce(tst_info, nonce))
		goto end;

	/* Setting TSA name to subject of signer certificate. */
	if (ctx->flags & TS_TSA_NAME) {
		if (!(tsa_name = GENERAL_NAME_new()))
			goto end;
		tsa_name->type = GEN_DIRNAME;
		tsa_name->d.dirn =
		    X509_NAME_dup(ctx->signer_cert->cert_info->subject);
		if (!tsa_name->d.dirn)
			goto end;
		if (!TS_TST_INFO_set_tsa(tst_info, tsa_name))
			goto end;
	}

	result = 1;

end:
	if (!result) {
		TS_TST_INFO_free(tst_info);
		tst_info = NULL;
		TSerror(TS_R_TST_INFO_SETUP_ERROR);
		TS_RESP_CTX_set_status_info_cond(ctx, TS_STATUS_REJECTION,
		    "Error during TSTInfo "
		    "generation.");
	}
	GENERAL_NAME_free(tsa_name);
	TS_ACCURACY_free(accuracy);
	ASN1_GENERALIZEDTIME_free(asn1_time);
	ASN1_INTEGER_free(serial);

	return tst_info;
}

/* Processing the extensions of the request. */
static int
TS_RESP_process_extensions(TS_RESP_CTX *ctx)
{
	STACK_OF(X509_EXTENSION) *exts = TS_REQ_get_exts(ctx->request);
	int i;
	int ok = 1;

	for (i = 0; ok && i < sk_X509_EXTENSION_num(exts); ++i) {
		X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);
		/* XXXXX The last argument was previously
		   (void *)ctx->extension_cb, but ISO C doesn't permit
		   converting a function pointer to void *.  For lack of
		   better information, I'm placing a NULL there instead.
		   The callback can pick its own address out from the ctx
		   anyway...
		*/
		ok = (*ctx->extension_cb)(ctx, ext, NULL);
	}

	return ok;
}

/* Functions for signing the TS_TST_INFO structure of the context. */
static int
TS_RESP_sign(TS_RESP_CTX *ctx)
{
	int ret = 0;
	PKCS7 *p7 = NULL;
	PKCS7_SIGNER_INFO *si;
	STACK_OF(X509) *certs;	/* Certificates to include in sc. */
	ESS_SIGNING_CERT *sc = NULL;
	ASN1_OBJECT *oid;
	BIO *p7bio = NULL;
	int i;

	/* Check if signcert and pkey match. */
	if (!X509_check_private_key(ctx->signer_cert, ctx->signer_key)) {
		TSerror(TS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
		goto err;
	}

	/* Create a new PKCS7 signed object. */
	if (!(p7 = PKCS7_new())) {
		TSerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	if (!PKCS7_set_type(p7, NID_pkcs7_signed))
		goto err;

	/* Force SignedData version to be 3 instead of the default 1. */
	if (!ASN1_INTEGER_set(p7->d.sign->version, 3))
		goto err;

	/* Add signer certificate and optional certificate chain. */
	if (TS_REQ_get_cert_req(ctx->request)) {
		PKCS7_add_certificate(p7, ctx->signer_cert);
		if (ctx->certs) {
			for (i = 0; i < sk_X509_num(ctx->certs); ++i) {
				X509 *cert = sk_X509_value(ctx->certs, i);
				PKCS7_add_certificate(p7, cert);
			}
		}
	}

	/* Add a new signer info. */
	if (!(si = PKCS7_add_signature(p7, ctx->signer_cert,
	    ctx->signer_key, EVP_sha1()))) {
		TSerror(TS_R_PKCS7_ADD_SIGNATURE_ERROR);
		goto err;
	}

	/* Add content type signed attribute to the signer info. */
	oid = OBJ_nid2obj(NID_id_smime_ct_TSTInfo);
	if (!PKCS7_add_signed_attribute(si, NID_pkcs9_contentType,
	    V_ASN1_OBJECT, oid)) {
		TSerror(TS_R_PKCS7_ADD_SIGNED_ATTR_ERROR);
		goto err;
	}

	/* Create the ESS SigningCertificate attribute which contains
	   the signer certificate id and optionally the certificate chain. */
	certs = ctx->flags & TS_ESS_CERT_ID_CHAIN ? ctx->certs : NULL;
	if (!(sc = ESS_SIGNING_CERT_new_init(ctx->signer_cert, certs)))
		goto err;

	/* Add SigningCertificate signed attribute to the signer info. */
	if (!ESS_add_signing_cert(si, sc)) {
		TSerror(TS_R_ESS_ADD_SIGNING_CERT_ERROR);
		goto err;
	}

	/* Add a new empty NID_id_smime_ct_TSTInfo encapsulated content. */
	if (!TS_TST_INFO_content_new(p7))
		goto err;

	/* Add the DER encoded tst_info to the PKCS7 structure. */
	if (!(p7bio = PKCS7_dataInit(p7, NULL))) {
		TSerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	/* Convert tst_info to DER. */
	if (!i2d_TS_TST_INFO_bio(p7bio, ctx->tst_info)) {
		TSerror(TS_R_TS_DATASIGN);
		goto err;
	}

	/* Create the signature and add it to the signer info. */
	if (!PKCS7_dataFinal(p7, p7bio)) {
		TSerror(TS_R_TS_DATASIGN);
		goto err;
	}

	/* Set new PKCS7 and TST_INFO objects. */
	TS_RESP_set_tst_info(ctx->response, p7, ctx->tst_info);
	p7 = NULL;		/* Ownership is lost. */
	ctx->tst_info = NULL;	/* Ownership is lost. */

	ret = 1;

err:
	if (!ret)
		TS_RESP_CTX_set_status_info_cond(ctx, TS_STATUS_REJECTION,
	    "Error during signature "
	    "generation.");
	BIO_free_all(p7bio);
	ESS_SIGNING_CERT_free(sc);
	PKCS7_free(p7);
	return ret;
}

static ESS_SIGNING_CERT *
ESS_SIGNING_CERT_new_init(X509 *signcert, STACK_OF(X509) *certs)
{
	ESS_CERT_ID *cid;
	ESS_SIGNING_CERT *sc = NULL;
	int i;

	/* Creating the ESS_CERT_ID stack. */
	if (!(sc = ESS_SIGNING_CERT_new()))
		goto err;
	if (!sc->cert_ids && !(sc->cert_ids = sk_ESS_CERT_ID_new_null()))
		goto err;

	/* Adding the signing certificate id. */
	if (!(cid = ESS_CERT_ID_new_init(signcert, 0)) ||
	    !sk_ESS_CERT_ID_push(sc->cert_ids, cid))
		goto err;
	/* Adding the certificate chain ids. */
	for (i = 0; i < sk_X509_num(certs); ++i) {
		X509 *cert = sk_X509_value(certs, i);
		if (!(cid = ESS_CERT_ID_new_init(cert, 1)) ||
		    !sk_ESS_CERT_ID_push(sc->cert_ids, cid))
			goto err;
	}

	return sc;

err:
	ESS_SIGNING_CERT_free(sc);
	TSerror(ERR_R_MALLOC_FAILURE);
	return NULL;
}

static ESS_CERT_ID *
ESS_CERT_ID_new_init(X509 *cert, int issuer_needed)
{
	ESS_CERT_ID *cid = NULL;
	GENERAL_NAME *name = NULL;

	/* Recompute SHA1 hash of certificate if necessary (side effect). */
	X509_check_purpose(cert, -1, 0);

	if (!(cid = ESS_CERT_ID_new()))
		goto err;
	if (!ASN1_OCTET_STRING_set(cid->hash, cert->sha1_hash,
	    sizeof(cert->sha1_hash)))
		goto err;

	/* Setting the issuer/serial if requested. */
	if (issuer_needed) {
		/* Creating issuer/serial structure. */
		if (!cid->issuer_serial &&
		    !(cid->issuer_serial = ESS_ISSUER_SERIAL_new()))
			goto err;
		/* Creating general name from the certificate issuer. */
		if (!(name = GENERAL_NAME_new()))
			goto err;
		name->type = GEN_DIRNAME;
		if (!(name->d.dirn = X509_NAME_dup(cert->cert_info->issuer)))
			goto err;
		if (!sk_GENERAL_NAME_push(cid->issuer_serial->issuer, name))
			goto err;
		name = NULL;	/* Ownership is lost. */
		/* Setting the serial number. */
		ASN1_INTEGER_free(cid->issuer_serial->serial);
		if (!(cid->issuer_serial->serial =
		    ASN1_INTEGER_dup(cert->cert_info->serialNumber)))
			goto err;
	}

	return cid;

err:
	GENERAL_NAME_free(name);
	ESS_CERT_ID_free(cid);
	TSerror(ERR_R_MALLOC_FAILURE);
	return NULL;
}

static int
TS_TST_INFO_content_new(PKCS7 *p7)
{
	PKCS7 *ret = NULL;
	ASN1_OCTET_STRING *octet_string = NULL;

	/* Create new encapsulated NID_id_smime_ct_TSTInfo content. */
	if (!(ret = PKCS7_new()))
		goto err;
	if (!(ret->d.other = ASN1_TYPE_new()))
		goto err;
	ret->type = OBJ_nid2obj(NID_id_smime_ct_TSTInfo);
	if (!(octet_string = ASN1_OCTET_STRING_new()))
		goto err;
	ASN1_TYPE_set(ret->d.other, V_ASN1_OCTET_STRING, octet_string);
	octet_string = NULL;

	/* Add encapsulated content to signed PKCS7 structure. */
	if (!PKCS7_set_content(p7, ret))
		goto err;

	return 1;

err:
	ASN1_OCTET_STRING_free(octet_string);
	PKCS7_free(ret);
	return 0;
}

static int
ESS_add_signing_cert(PKCS7_SIGNER_INFO *si, ESS_SIGNING_CERT *sc)
{
	ASN1_STRING *seq = NULL;
	unsigned char *p, *pp = NULL;
	int len;

	len = i2d_ESS_SIGNING_CERT(sc, NULL);
	if (!(pp = malloc(len))) {
		TSerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	p = pp;
	i2d_ESS_SIGNING_CERT(sc, &p);
	if (!(seq = ASN1_STRING_new()) || !ASN1_STRING_set(seq, pp, len)) {
		TSerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	free(pp);
	pp = NULL;
	return PKCS7_add_signed_attribute(si,
	    NID_id_smime_aa_signingCertificate, V_ASN1_SEQUENCE, seq);

err:
	ASN1_STRING_free(seq);
	free(pp);

	return 0;
}


static ASN1_GENERALIZEDTIME *
TS_RESP_set_genTime_with_precision(ASN1_GENERALIZEDTIME *asn1_time,
    time_t sec, long usec, unsigned precision)
{
	struct tm *tm = NULL;
	char genTime_str[17 + TS_MAX_CLOCK_PRECISION_DIGITS];
	char usecstr[TS_MAX_CLOCK_PRECISION_DIGITS + 2];
	char *p;
	int rv;

	if (precision > TS_MAX_CLOCK_PRECISION_DIGITS)
		goto err;

	if (!(tm = gmtime(&sec)))
		goto err;

	/*
	 * Put "genTime_str" in GeneralizedTime format.  We work around the
	 * restrictions imposed by rfc3280 (i.e. "GeneralizedTime values MUST
	 * NOT include fractional seconds") and OpenSSL related functions to
	 * meet the rfc3161 requirement: "GeneralizedTime syntax can include
	 * fraction-of-second details".
	 */
	if (precision > 0) {
		/* To make things a bit harder, X.690 | ISO/IEC 8825-1 provides
		   the following restrictions for a DER-encoding, which OpenSSL
		   (specifically ASN1_GENERALIZEDTIME_check() function) doesn't
		   support:
		   "The encoding MUST terminate with a "Z" (which means "Zulu"
		   time). The decimal point element, if present, MUST be the
		   point option ".". The fractional-seconds elements,
		   if present, MUST omit all trailing 0's;
		   if the elements correspond to 0, they MUST be wholly
		   omitted, and the decimal point element also MUST be
		   omitted." */
		(void) snprintf(usecstr, sizeof(usecstr), ".%06ld", usec);
		/* truncate and trim trailing 0 */
		usecstr[precision + 1] = '\0';
		p = usecstr + strlen(usecstr) - 1;
		while (p > usecstr && *p == '0')
			*p-- = '\0';
		/* if we've reached the beginning, delete the . too */
		if (p == usecstr)
			*p = '\0';

	} else {
		/* empty */
		usecstr[0] = '\0';
	}
	rv = snprintf(genTime_str, sizeof(genTime_str),
	    "%04d%02d%02d%02d%02d%02d%sZ",
	    tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
	    tm->tm_hour, tm->tm_min, tm->tm_sec, usecstr);
	if (rv == -1 || rv >= sizeof(genTime_str))
		goto err;

	/* Now call OpenSSL to check and set our genTime value */
	if (!asn1_time && !(asn1_time = ASN1_GENERALIZEDTIME_new()))
		goto err;
	if (!ASN1_GENERALIZEDTIME_set_string(asn1_time, genTime_str)) {
		ASN1_GENERALIZEDTIME_free(asn1_time);
		goto err;
	}

	return asn1_time;

err:
	TSerror(TS_R_COULD_NOT_SET_TIME);
	return NULL;
}
@


1.20
log
@X509_free(3) is NULL-safe, so remove NULL checks before its calls.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ts_rsp_sign.c,v 1.19 2015/09/30 18:04:02 jsing Exp $ */
d106 1
a106 1
	TSerr(TS_F_DEF_SERIAL_CB, ERR_R_MALLOC_FAILURE);
d119 1
a119 1
		TSerr(TS_F_DEF_TIME_CB, TS_R_TIME_SYSCALL_ERROR);
d150 1
a150 1
		TSerr(TS_F_TS_RESP_CTX_NEW, ERR_R_MALLOC_FAILURE);
d184 1
a184 2
		TSerr(TS_F_TS_RESP_CTX_SET_SIGNER_CERT,
		    TS_R_INVALID_SIGNER_CERTIFICATE_PURPOSE);
d213 1
a213 1
	TSerr(TS_F_TS_RESP_CTX_SET_DEF_POLICY, ERR_R_MALLOC_FAILURE);
d229 1
a229 1
		TSerr(TS_F_TS_RESP_CTX_SET_CERTS, ERR_R_MALLOC_FAILURE);
d256 1
a256 1
	TSerr(TS_F_TS_RESP_CTX_ADD_POLICY, ERR_R_MALLOC_FAILURE);
d274 1
a274 1
	TSerr(TS_F_TS_RESP_CTX_ADD_MD, ERR_R_MALLOC_FAILURE);
d304 1
a304 1
	TSerr(TS_F_TS_RESP_CTX_SET_ACCURACY, ERR_R_MALLOC_FAILURE);
d355 1
a355 1
		TSerr(TS_F_TS_RESP_CTX_SET_STATUS_INFO, ERR_R_MALLOC_FAILURE);
d386 1
a386 1
	TSerr(TS_F_TS_RESP_CTX_ADD_FAILURE_INFO, ERR_R_MALLOC_FAILURE);
d423 1
a423 1
		TSerr(TS_F_TS_RESP_CREATE_RESPONSE, ERR_R_MALLOC_FAILURE);
d465 1
a465 1
		TSerr(TS_F_TS_RESP_CREATE_RESPONSE, TS_R_RESPONSE_SETUP_ERROR);
d569 1
a569 1
		TSerr(TS_F_TS_RESP_GET_POLICY, TS_R_INVALID_NULL_POINTER);
d584 1
a584 1
		TSerr(TS_F_TS_RESP_GET_POLICY, TS_R_UNACCEPTABLE_POLICY);
d667 1
a667 1
		TSerr(TS_F_TS_RESP_CREATE_TST_INFO, TS_R_TST_INFO_SETUP_ERROR);
d718 1
a718 2
		TSerr(TS_F_TS_RESP_SIGN,
		    TS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
d724 1
a724 1
		TSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);
d748 1
a748 1
		TSerr(TS_F_TS_RESP_SIGN, TS_R_PKCS7_ADD_SIGNATURE_ERROR);
d756 1
a756 1
		TSerr(TS_F_TS_RESP_SIGN, TS_R_PKCS7_ADD_SIGNED_ATTR_ERROR);
d768 1
a768 1
		TSerr(TS_F_TS_RESP_SIGN, TS_R_ESS_ADD_SIGNING_CERT_ERROR);
d778 1
a778 1
		TSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);
d784 1
a784 1
		TSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);
d790 1
a790 1
		TSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);
d841 1
a841 1
	TSerr(TS_F_ESS_SIGNING_CERT_NEW_INIT, ERR_R_MALLOC_FAILURE);
d887 1
a887 1
	TSerr(TS_F_ESS_CERT_ID_NEW_INIT, ERR_R_MALLOC_FAILURE);
d929 1
a929 1
		TSerr(TS_F_ESS_ADD_SIGNING_CERT, ERR_R_MALLOC_FAILURE);
d935 1
a935 1
		TSerr(TS_F_ESS_ADD_SIGNING_CERT, ERR_R_MALLOC_FAILURE);
d1018 1
a1018 1
	TSerr(TS_F_TS_RESP_SET_GENTIME_WITH_PRECISION, TS_R_COULD_NOT_SET_TIME);
@


1.19
log
@Replace M_ASN1_GENERALIZEDTIME_(new|free) with
ASN1_GENERALIZEDTIME_(new|free).
@
text
@d1 1
a1 1
/* $OpenBSD: ts_rsp_sign.c,v 1.18 2014/07/12 16:03:37 miod Exp $ */
d188 1
a188 2
	if (ctx->signer_cert)
		X509_free(ctx->signer_cert);
@


1.18
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ts_rsp_sign.c,v 1.17 2014/07/11 08:44:49 jsing Exp $ */
d1011 1
a1011 1
	if (!asn1_time && !(asn1_time = M_ASN1_GENERALIZEDTIME_new()))
@


1.17
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ts_rsp_sign.c,v 1.16 2014/07/10 13:58:23 jsing Exp $ */
d198 1
a198 2
	if (ctx->signer_key)
		EVP_PKEY_free(ctx->signer_key);
@


1.16
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ts_rsp_sign.c,v 1.15 2014/06/12 15:49:31 deraadt Exp $ */
d63 1
a63 2
#include "cryptlib.h"

d65 1
a66 1
#include <openssl/pkcs7.h>
@


1.15
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d59 4
a63 2

#include <sys/time.h>
@


1.14
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/ts/ts_resp_sign.c */
@


1.13
log
@Fix a Y2038 problem, by conversion of long to time_t.

The TS_RESP_CTX_set_time_cb() API gets removed. Nothing in the greater
ecosystem ever calls it.  This API needs to be removed, because if
anyone ever calls on a BE 32 system assuming long rather than time_t,
it will be dangerously incompatible.

ok miod guenther
@
text
@d931 1
a931 1
	if (!(pp = (unsigned char *) malloc(len))) {
@


1.12
log
@calloc instead of malloc/memset. from Benjamin Baier
@
text
@d70 1
a70 1
static int def_time_cb(struct TS_resp_ctx *, void *, long *sec, long *usec);
d89 1
a89 1
    ASN1_GENERALIZEDTIME *, long, long, unsigned);
d113 1
a113 1
def_time_cb(struct TS_resp_ctx *ctx, void *data, long *sec, long *usec)
a323 7
TS_RESP_CTX_set_time_cb(TS_RESP_CTX *ctx, TS_time_cb cb, void *data)
{
	ctx->time_cb = cb;
	ctx->time_cb_data = data;
}

void
d603 2
a604 1
	long sec, usec;
d956 1
a956 1
    long sec, long usec, unsigned precision)
a957 1
	time_t time_sec = (time_t) sec;
d967 1
a967 1
	if (!(tm = gmtime(&time_sec)))
@


1.11
log
@Hello? Yes, you're speaking with OPENSSL_SYS_UNIX.

ok beck@@ miod@@
@
text
@d148 1
a148 1
	if (!(ctx = (TS_RESP_CTX *) malloc(sizeof(TS_RESP_CTX)))) {
a151 1
	memset(ctx, 0, sizeof(TS_RESP_CTX));
@


1.10
log
@Put explicit (void) in function declarations and shuffle keywords in some
declaration to pass -Wextra, should we want to add it to CFLAGS.
No binary change.
@
text
@a60 1
#if defined(OPENSSL_SYS_UNIX)
a61 1
#endif
a110 2
#if defined(OPENSSL_SYS_UNIX)

a129 24

#else

/* Use the time function call that provides only seconds precision. */
static int
def_time_cb(struct TS_resp_ctx *ctx, void *data, long *sec, long *usec)
{
	time_t t;

	if (time(&t) == (time_t) - 1) {
		TSerr(TS_F_DEF_TIME_CB, TS_R_TIME_SYSCALL_ERROR);
		TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
		    "Time is not available.");
		TS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);
		return 0;
	}
	/* Return time to caller, only second precision. */
	*sec = (long) t;
	*usec = 0;

	return 1;
}

#endif
@


1.9
log
@KNF.
@
text
@d172 1
a172 1
TS_RESP_CTX_new()
@


1.8
log
@Restore tedu's rev 1.4: snprintf() was reviewed.
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d79 2
a80 2
static TS_TST_INFO *TS_RESP_create_tst_info(TS_RESP_CTX *ctx, 
					    ASN1_OBJECT *policy);
d84 2
a85 2
static ESS_SIGNING_CERT *ESS_SIGNING_CERT_new_init(X509 *signcert, 
						   STACK_OF(X509) *certs);
d91 1
a91 1
	ASN1_GENERALIZEDTIME *, long, long, unsigned);
d95 3
a97 2
static ASN1_INTEGER *def_serial_cb(struct TS_resp_ctx *ctx, void *data)
	{
d99 5
a103 2
	if (!serial) goto err;
	if (!ASN1_INTEGER_set(serial, 1)) goto err;
d105 2
a106 1
 err:
d109 1
a109 1
				    "Error during serial number generation.");
d111 1
a111 1
	}
d116 3
a118 3
static int def_time_cb(struct TS_resp_ctx *ctx, void *data, 
		       long *sec, long *usec)
	{
d120 2
a121 2
	if (gettimeofday(&tv, NULL) != 0) 
		{
d124 1
a124 1
					    "Time is not available.");
d127 1
a127 1
		}
d133 1
a133 1
	}
d138 3
a140 3
static int def_time_cb(struct TS_resp_ctx *ctx, void *data, 
		       long *sec, long *usec)
	{
d142 2
a143 2
	if (time(&t) == (time_t) -1)
		{
d146 1
a146 1
					    "Time is not available.");
d149 1
a149 1
		}
d155 1
a155 1
	}
d159 3
a161 3
static int def_extension_cb(struct TS_resp_ctx *ctx, X509_EXTENSION *ext,
			    void *data)
	{
d164 1
a164 1
				    "Unsupported extension.");
d167 1
a167 1
	}
d171 3
a173 2
TS_RESP_CTX *TS_RESP_CTX_new()
	{
d176 1
a176 2
	if (!(ctx = (TS_RESP_CTX *) malloc(sizeof(TS_RESP_CTX))))
		{
d179 1
a179 1
		}
d188 1
a188 1
	}
d190 5
a194 3
void TS_RESP_CTX_free(TS_RESP_CTX *ctx)
	{
	if (!ctx) return;
d206 1
a206 1
	}
d208 6
a213 6
int TS_RESP_CTX_set_signer_cert(TS_RESP_CTX *ctx, X509 *signer)
	{
	if (X509_check_purpose(signer, X509_PURPOSE_TIMESTAMP_SIGN, 0) != 1)
		{
		TSerr(TS_F_TS_RESP_CTX_SET_SIGNER_CERT, 
		      TS_R_INVALID_SIGNER_CERTIFICATE_PURPOSE);
d215 3
a217 2
		}
	if (ctx->signer_cert) X509_free(ctx->signer_cert);
d221 1
a221 1
	}
d223 5
a227 3
int TS_RESP_CTX_set_signer_key(TS_RESP_CTX *ctx, EVP_PKEY *key)
	{
	if (ctx->signer_key) EVP_PKEY_free(ctx->signer_key);
d232 1
a232 1
	}
d234 7
a240 4
int TS_RESP_CTX_set_def_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *def_policy)
	{
	if (ctx->default_policy) ASN1_OBJECT_free(ctx->default_policy);
	if (!(ctx->default_policy = OBJ_dup(def_policy))) goto err;
d242 2
a243 1
 err:
d246 1
a246 1
	}
d248 3
a250 2
int TS_RESP_CTX_set_certs(TS_RESP_CTX *ctx, STACK_OF(X509) *certs)
	{
d253 1
a253 2
	if (ctx->certs)
		{
d256 4
a259 4
		}
	if (!certs) return 1;
	if (!(ctx->certs = sk_X509_dup(certs))) 
		{
d262 2
a263 3
		}
	for (i = 0; i < sk_X509_num(ctx->certs); ++i)
		{
d266 1
a266 1
		}
d269 1
a269 1
	}
d271 3
a273 2
int TS_RESP_CTX_add_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *policy)
	{
d277 5
a281 1
	if (!ctx->policies && !(ctx->policies = sk_ASN1_OBJECT_new_null())) 
a282 2
	if (!(copy = OBJ_dup(policy))) goto err;
	if (!sk_ASN1_OBJECT_push(ctx->policies, copy)) goto err;
d285 2
a286 1
 err:
d290 1
a290 1
	}
d292 3
a294 2
int TS_RESP_CTX_add_md(TS_RESP_CTX *ctx, const EVP_MD *md)
	{
d296 1
a296 1
	if (!ctx->mds && !(ctx->mds = sk_EVP_MD_new_null())) 
d299 2
a300 1
	if (!sk_EVP_MD_push(ctx->mds, (EVP_MD *)md)) goto err;
d303 2
a304 1
 err:
d307 1
a307 1
	}
d317 3
a319 4
int TS_RESP_CTX_set_accuracy(TS_RESP_CTX *ctx, 
			     int secs, int millis, int micros)
	{

d321 2
a322 2
	if (secs && (!(ctx->seconds = ASN1_INTEGER_new())
		     || !ASN1_INTEGER_set(ctx->seconds, secs)))
d324 2
a325 2
	if (millis && (!(ctx->millis = ASN1_INTEGER_new())
		       || !ASN1_INTEGER_set(ctx->millis, millis)))
d327 2
a328 2
	if (micros && (!(ctx->micros = ASN1_INTEGER_new())
		       || !ASN1_INTEGER_set(ctx->micros, micros)))
d332 2
a333 1
 err:
d337 1
a337 1
	}
d339 3
a341 2
void TS_RESP_CTX_add_flags(TS_RESP_CTX *ctx, int flags)
	{
d343 1
a343 1
	}
d345 3
a347 2
void TS_RESP_CTX_set_serial_cb(TS_RESP_CTX *ctx, TS_serial_cb cb, void *data)
	{
d350 1
a350 1
	}
d352 3
a354 2
void TS_RESP_CTX_set_time_cb(TS_RESP_CTX *ctx, TS_time_cb cb, void *data)
	{
d357 1
a357 1
	}
d359 3
a361 3
void TS_RESP_CTX_set_extension_cb(TS_RESP_CTX *ctx, 
				  TS_extension_cb cb, void *data)
	{
d364 1
a364 1
	}
d366 3
a368 3
int TS_RESP_CTX_set_status_info(TS_RESP_CTX *ctx, 
				int status, const char *text)
	{
d373 7
a379 6
	if (!(si = TS_STATUS_INFO_new())) goto err;
	if (!ASN1_INTEGER_set(si->status, status)) goto err;
	if (text)
		{
		if (!(utf8_text = ASN1_UTF8STRING_new())
		    || !ASN1_STRING_set(utf8_text, text, strlen(text)))
d383 2
a384 1
		if (!sk_ASN1_UTF8STRING_push(si->text, utf8_text)) goto err;
d386 3
a388 2
		}
	if (!TS_RESP_set_status_info(ctx->response, si)) goto err;
d390 2
a391 1
 err:
d397 1
a397 1
	}
d399 3
a401 3
int TS_RESP_CTX_set_status_info_cond(TS_RESP_CTX *ctx, 
				     int status, const char *text)
	{
d405 1
a405 2
	if (ASN1_INTEGER_get(si->status) == TS_STATUS_GRANTED)
		{
d408 1
a408 1
		}
d410 1
a410 1
	}
d412 3
a414 2
int TS_RESP_CTX_add_failure_info(TS_RESP_CTX *ctx, int failure)
	{
d416 1
d422 2
a423 1
 err:
d426 1
a426 1
	}
d428 3
a430 2
TS_REQ *TS_RESP_CTX_get_request(TS_RESP_CTX *ctx)
	{
d432 1
a432 1
	}
d434 3
a436 2
TS_TST_INFO *TS_RESP_CTX_get_tst_info(TS_RESP_CTX *ctx)
	{
d438 1
a438 1
	}
d440 8
a447 7
int TS_RESP_CTX_set_clock_precision_digits(TS_RESP_CTX *ctx, unsigned precision)
       {
       if (precision > TS_MAX_CLOCK_PRECISION_DIGITS)
	       return 0;
       ctx->clock_precision_digits = precision;
       return 1;
       }
d450 3
a452 2
TS_RESP *TS_RESP_create_response(TS_RESP_CTX *ctx, BIO *req_bio)
	{
d460 1
a460 2
	if (!(ctx->response = TS_RESP_new())) 
		{
d463 1
a463 1
		}
d466 1
a466 2
	if (!(ctx->request = d2i_TS_REQ_bio(req_bio, NULL)))
		{
d468 2
a469 2
					    "Bad request format or "
					    "system error.");
d472 1
a472 1
		}
d479 2
a480 1
	if (!TS_RESP_check_request(ctx)) goto end;
d483 2
a484 1
	if (!(policy = TS_RESP_get_policy(ctx))) goto end;
d491 2
a492 1
	if (!TS_RESP_process_extensions(ctx)) goto end;
d495 2
a496 1
	if (!TS_RESP_sign(ctx)) goto end;
d500 3
a502 3
 end:
	if (!result)
		{
d504 1
a504 2
		if (ctx->response != NULL)
			{
d506 2
a507 3
				TS_STATUS_REJECTION, "Error during response "
				"generation.") == 0)
				{
a509 1
				}
d512 1
d517 1
a517 1
	}
d520 3
a522 2
static void TS_RESP_CTX_init(TS_RESP_CTX *ctx)
	{
d526 1
a526 1
	}
d529 3
a531 2
static void TS_RESP_CTX_cleanup(TS_RESP_CTX *ctx)
	{
d538 1
a538 1
	}
d541 3
a543 2
static int TS_RESP_check_request(TS_RESP_CTX *ctx)
	{
d553 1
a553 2
	if (TS_REQ_get_version(request) != 1)
		{
d555 1
a555 1
					    "Bad request version.");
d558 1
a558 1
		}
d564 1
a564 2
	for (i = 0; !md && i < sk_EVP_MD_num(ctx->mds); ++i)
		{
d568 2
a569 3
		}
	if (!md)
		{
d571 2
a572 2
					    "Message digest algorithm is "
					    "not supported.");
d575 1
a575 1
		}
d578 2
a579 3
	if (md_alg->parameter 
	    && ASN1_TYPE_get(md_alg->parameter) != V_ASN1_NULL)
		{
d581 2
a582 2
					    "Superfluous message digest "
					    "parameter.");
d585 1
a585 1
		}
d588 1
a588 2
	if (digest->length != EVP_MD_size(md))
		{
d590 1
a590 1
					    "Bad message digest.");
d593 1
a593 1
		}
d596 1
a596 1
	}
d599 3
a601 2
static ASN1_OBJECT *TS_RESP_get_policy(TS_RESP_CTX *ctx)
	{
d606 1
a606 2
	if (ctx->default_policy == NULL)
		{
d609 1
a609 1
		}
d616 1
a616 2
	for (i = 0; !policy && i < sk_ASN1_OBJECT_num(ctx->policies); ++i)
		{
d620 2
a621 3
		}
	if (!policy)
		{
d624 2
a625 2
					    "Requested policy is not "
					    "supported.");
d627 1
a627 1
		}
d629 1
a629 1
	}
d632 3
a634 3
static TS_TST_INFO *TS_RESP_create_tst_info(TS_RESP_CTX *ctx,
					    ASN1_OBJECT *policy)
	{
d644 6
a649 3
	if (!(tst_info = TS_TST_INFO_new())) goto end;
	if (!TS_TST_INFO_set_version(tst_info, 1)) goto end;
	if (!TS_TST_INFO_set_policy_id(tst_info, policy)) goto end;
d652 2
a653 2
	if (!(serial = (*ctx->serial_cb)(ctx, ctx->serial_cb_data))
	    || !TS_TST_INFO_set_serial(tst_info, serial))
d655 4
a658 5
	if (!(*ctx->time_cb)(ctx, ctx->time_cb_data, &sec, &usec)
            || !(asn1_time = TS_RESP_set_genTime_with_precision(NULL, 
					sec, usec, 
					ctx->clock_precision_digits))
	    || !TS_TST_INFO_set_time(tst_info, asn1_time))
d662 2
a663 2
	if ((ctx->seconds || ctx->millis || ctx->micros) 
	    && !(accuracy = TS_ACCURACY_new()))
d672 1
a672 1
	if (accuracy && !TS_TST_INFO_set_accuracy(tst_info, accuracy)) 
d676 2
a677 2
	if ((ctx->flags & TS_ORDERING) 
	    && !TS_TST_INFO_set_ordering(tst_info, 1))
d679 1
a679 1
	
d681 2
a682 2
	if ((nonce = TS_REQ_get_nonce(ctx->request)) != NULL
	    && !TS_TST_INFO_set_nonce(tst_info, nonce))
d686 3
a688 3
	if (ctx->flags & TS_TSA_NAME)
		{
		if (!(tsa_name = GENERAL_NAME_new())) goto end;
d690 7
a696 5
		tsa_name->d.dirn = 
			X509_NAME_dup(ctx->signer_cert->cert_info->subject);
		if (!tsa_name->d.dirn) goto end;
		if (!TS_TST_INFO_set_tsa(tst_info, tsa_name)) goto end;
		}
d699 3
a701 3
 end:
	if (!result)
		{
d706 3
a708 3
						 "Error during TSTInfo "
						 "generation.");
		}
d713 1
a713 1
	
d715 1
a715 1
	}
d718 3
a720 2
static int TS_RESP_process_extensions(TS_RESP_CTX *ctx)
	{
d725 1
a725 2
	for (i = 0; ok && i < sk_X509_EXTENSION_num(exts); ++i)
		{
d735 1
a735 1
		}
d738 1
a738 1
	}
d741 3
a743 2
static int TS_RESP_sign(TS_RESP_CTX *ctx)
	{
d755 3
a757 3
		TSerr(TS_F_TS_RESP_SIGN, 
		      TS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
                goto err;
d765 2
a766 1
	if (!PKCS7_set_type(p7, NID_pkcs7_signed)) goto err;
d769 2
a770 1
	if (!ASN1_INTEGER_set(p7->d.sign->version, 3)) goto err;
d773 1
a773 2
	if (TS_REQ_get_cert_req(ctx->request))
		{
d775 2
a776 4
		if (ctx->certs)
			{
			for(i = 0; i < sk_X509_num(ctx->certs); ++i) 
				{
a778 1
				}
d781 1
d784 2
a785 3
    	if (!(si = PKCS7_add_signature(p7, ctx->signer_cert, 
				       ctx->signer_key, EVP_sha1())))
		{
d788 1
a788 1
		}
d793 1
a793 2
					V_ASN1_OBJECT, oid))
		{
d796 1
a796 1
		}
d798 1
a798 1
	/* Create the ESS SigningCertificate attribute which contains 
d805 1
a805 2
	if (!ESS_add_signing_cert(si, sc))
		{
d808 1
a808 1
		}	
d811 2
a812 1
	if (!TS_TST_INFO_content_new(p7)) goto err;
d821 1
a821 2
	if (!i2d_TS_TST_INFO_bio(p7bio, ctx->tst_info))
		{
d824 1
a824 1
		}
d827 1
a827 2
        if (!PKCS7_dataFinal(p7, p7bio))
		{
d830 1
a830 1
		}
d838 2
a839 1
 err:
d842 2
a843 2
						 "Error during signature "
						 "generation.");
d848 1
a848 1
	}
d850 3
a852 3
static ESS_SIGNING_CERT *ESS_SIGNING_CERT_new_init(X509 *signcert, 
						   STACK_OF(X509) *certs)
	{
d858 2
a859 1
	if (!(sc = ESS_SIGNING_CERT_new())) goto err;
d864 2
a865 2
	if (!(cid = ESS_CERT_ID_new_init(signcert, 0))
	    || !sk_ESS_CERT_ID_push(sc->cert_ids, cid))
d868 1
a868 2
	for (i = 0; i < sk_X509_num(certs); ++i)
		{
d870 2
a871 2
		if (!(cid = ESS_CERT_ID_new_init(cert, 1))
		    || !sk_ESS_CERT_ID_push(sc->cert_ids, cid))
d873 1
a873 1
		}
d876 1
d881 1
a881 1
	}
d883 3
a885 2
static ESS_CERT_ID *ESS_CERT_ID_new_init(X509 *cert, int issuer_needed)
	{
d888 1
a888 1
	
d892 2
a893 1
	if (!(cid = ESS_CERT_ID_new())) goto err;
d895 1
a895 1
				   sizeof(cert->sha1_hash)))
d899 1
a899 2
	if (issuer_needed)
		{
d901 2
a902 2
		if (!cid->issuer_serial
		    && !(cid->issuer_serial = ESS_ISSUER_SERIAL_new()))
d905 2
a906 1
		if (!(name = GENERAL_NAME_new())) goto err;
d908 1
a908 1
		if (!(name->d.dirn = X509_NAME_dup(cert->cert_info->issuer))) 
d910 1
a910 1
		if (!sk_GENERAL_NAME_push(cid->issuer_serial->issuer, name)) 
d915 2
a916 2
		if (!(cid->issuer_serial->serial = 
		      ASN1_INTEGER_dup(cert->cert_info->serialNumber)))
d918 1
a918 1
		}
d921 1
d927 1
a927 1
	}
d929 3
a931 2
static int TS_TST_INFO_content_new(PKCS7 *p7)
	{
d936 4
a939 2
	if (!(ret = PKCS7_new())) goto err;
	if (!(ret->d.other = ASN1_TYPE_new())) goto err;
d941 2
a942 1
	if (!(octet_string = ASN1_OCTET_STRING_new())) goto err;
d947 2
a948 1
	if (!PKCS7_set_content(p7, ret)) goto err;
d951 2
a952 1
 err:
d956 1
a956 1
	}
d958 3
a960 2
static int ESS_add_signing_cert(PKCS7_SIGNER_INFO *si, ESS_SIGNING_CERT *sc)
	{
d966 1
a966 2
	if (!(pp = (unsigned char *) malloc(len)))
		{
d969 1
a969 1
		}
d972 1
a972 2
	if (!(seq = ASN1_STRING_new()) || !ASN1_STRING_set(seq, pp, len))
		{
d975 7
a981 6
		}
	free(pp); pp = NULL;
	return PKCS7_add_signed_attribute(si, 
					  NID_id_smime_aa_signingCertificate,
					  V_ASN1_SEQUENCE, seq);
 err:
d986 1
a986 1
	}
d990 3
a992 3
TS_RESP_set_genTime_with_precision(ASN1_GENERALIZEDTIME *asn1_time, 
				   long sec, long usec, unsigned precision)
	{
d994 1
a994 1
	struct tm *tm = NULL;	
a1002 1
	
d1006 7
a1012 7
	/* 
	 * Put "genTime_str" in GeneralizedTime format.  We work around the 
	 * restrictions imposed by rfc3280 (i.e. "GeneralizedTime values MUST 
	 * NOT include fractional seconds") and OpenSSL related functions to 
	 * meet the rfc3161 requirement: "GeneralizedTime syntax can include 
	 * fraction-of-second details". 
	 */                   
d1016 1
a1016 1
		   (specifically ASN1_GENERALIZEDTIME_check() function) doesn't 
d1018 4
a1021 4
		   "The encoding MUST terminate with a "Z" (which means "Zulu" 
		   time). The decimal point element, if present, MUST be the 
		   point option ".". The fractional-seconds elements, 
		   if present, MUST omit all trailing 0's; 
d1041 1
a1041 1
	    tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, 
d1049 1
a1049 2
	if (!ASN1_GENERALIZEDTIME_set_string(asn1_time, genTime_str))
		{
d1052 1
a1052 1
		}
d1055 2
a1056 1
 err:
d1059 1
a1059 1
	}
@


1.7
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d986 1
a986 1
		snprintf(usecstr, sizeof(usecstr), ".%06ld", usec);
@


1.6
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d986 1
a986 1
		(void)snprintf(usecstr, sizeof(usecstr), ".%06ld", usec);
@


1.5
log
@Zero-pad usec format to handle values less than 100,000 correctly

ok matthew@@ tedu@@
@
text
@d170 1
a170 1
	if (!(ctx = (TS_RESP_CTX *) OPENSSL_malloc(sizeof(TS_RESP_CTX))))
d198 1
a198 1
	OPENSSL_free(ctx);
d925 1
a925 1
	if (!(pp = (unsigned char *) OPENSSL_malloc(len)))
d937 1
a937 1
	OPENSSL_free(pp); pp = NULL;
d943 1
a943 1
	OPENSSL_free(pp);
@


1.4
log
@Mandatory Surgeon Guenther's Warning: This code could not possibly be
correct because it doesn't zerofill the front of usecs, but that's the
way I found it.
a more thorough emulation of the old code, but with fewer whacky snprintf
pointer arithmetic antics. ok beck guenther
@
text
@d986 1
a986 1
		(void)snprintf(usecstr, sizeof(usecstr), ".%ld", usec);
@


1.3
log
@revert. the full horror has only now revealed itself.
@
text
@d956 3
a958 2
	char *p = genTime_str;
	char *p_end = genTime_str + sizeof(genTime_str);
d974 1
a974 12
	p += BIO_snprintf(p, p_end - p,
			  "%04d%02d%02d%02d%02d%02d",
			  tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, 
			  tm->tm_hour, tm->tm_min, tm->tm_sec);
	if (precision > 0)
	{
		/* Add fraction of seconds (leave space for dot and null). */
		BIO_snprintf(p, 2 + precision, ".%ld", usec);
		/* We cannot use the snprintf return value, 
		   because it might have been truncated. */
		p += strlen(p);

d986 20
a1005 10
		/* Remove trailing zeros. The dot guarantees the exit
		   condition of this loop even if all the digits are zero. */
		while (*--p == '0')
			/* empty */;
		/* p points to either the dot or the last non-zero digit. */
		if (*p != '.') ++p;
		}
	/* Add the trailing Z and the terminating null. */
	*p++ = 'Z';
	*p++ = '\0';
@


1.2
log
@replace some bio_snprintf crazy with regular snprintf.
beck had a diff to convert to strftime, but it's easier to verify this
is functionally the same. ok beck.
@
text
@d956 2
a957 2
	char *p;
	int rv;
d973 2
a974 3
	if (precision > 0) {
		rv = snprintf(genTime_str, sizeof(genTime_str),
			  "%04d%02d%02d%02d%02d%02d.%ldZ",
d976 9
a984 3
			  tm->tm_hour, tm->tm_min, tm->tm_sec, usec);
		if (rv == -1 || rv >= sizeof(genTime_str))
			goto err;
d998 8
a1005 18
		p = strchr(genTime_str, 'Z');
		p--; /* move back in front of Z */
		/* pass over 0s */
		while (*p == '0')
			p--;
		/* if we're not at . we're at an interesting digit */
		if (*p != '.')
			p++;
		*p++ = 'Z';
		*p = 0;
	} else {
		rv = snprintf(genTime_str, sizeof(genTime_str),
			  "%04d%02d%02d%02d%02d%02dZ",
			  tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, 
			  tm->tm_hour, tm->tm_min, tm->tm_sec);
		if (rv == -1 || rv >= sizeof(genTime_str))
			goto err;
	}
@


1.1
log
@Initial revision
@
text
@d956 2
a957 2
	char *p = genTime_str;
	char *p_end = genTime_str + sizeof(genTime_str);
d973 3
a975 2
	p += BIO_snprintf(p, p_end - p,
			  "%04d%02d%02d%02d%02d%02d",
d977 3
a979 9
			  tm->tm_hour, tm->tm_min, tm->tm_sec);
	if (precision > 0)
	{
		/* Add fraction of seconds (leave space for dot and null). */
		BIO_snprintf(p, 2 + precision, ".%ld", usec);
		/* We cannot use the snprintf return value, 
		   because it might have been truncated. */
		p += strlen(p);

d993 18
a1010 8
		while (*--p == '0')
			/* empty */;
		/* p points to either the dot or the last non-zero digit. */
		if (*p != '.') ++p;
		}
	/* Add the trailing Z and the terminating null. */
	*p++ = 'Z';
	*p++ = '\0';
@


1.1.1.1
log
@import OpenSSL-1.0.0a
@
text
@@
