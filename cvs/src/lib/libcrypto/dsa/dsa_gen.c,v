head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.6
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24;
locks; strict;
comment	@ * @;


1.24
date	2017.01.21.10.38.29;	author beck;	state Exp;
branches;
next	1.23;
commitid	hKAfCRL9IRQ9ENaK;

1.23
date	2017.01.21.09.38.59;	author beck;	state Exp;
branches;
next	1.22;
commitid	iyR9b2itDMsxzmrQ;

1.22
date	2015.07.15.18.34.37;	author miod;	state Exp;
branches;
next	1.21;
commitid	kSUqH2VakC6heWIt;

1.21
date	2015.07.15.16.32.29;	author miod;	state Exp;
branches;
next	1.20;
commitid	7YOyS4rCl4gAsoot;

1.20
date	2015.02.15.22.29.02;	author doug;	state Exp;
branches;
next	1.19;
commitid	SZvtRnVOVeKWWqYa;

1.19
date	2015.02.15.08.48.24;	author miod;	state Exp;
branches;
next	1.18;
commitid	b5V1GhLe1EARV68A;

1.18
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.17;
commitid	69Tc75PIK8JcRRsC;

1.17
date	2014.10.22.13.02.04;	author jsing;	state Exp;
branches;
next	1.16;
commitid	PjnBgKe6Buhbf937;

1.16
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.15;
commitid	G74O1dmRukKsW7IJ;

1.15
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.14;
commitid	yQEL1wOWIearrW15;

1.14
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.13;
commitid	id8dTrTMtnTn4fqt;

1.13
date	2014.07.09.10.16.24;	author miod;	state Exp;
branches;
next	1.12;
commitid	7IVFdVxu6X3GaaT8;

1.12
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	mJUVYpkFBZ0Zv2bG;

1.11
date	2014.04.15.20.06.09;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.43;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.29.05.39.20;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.12;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.10.07;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.05;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.46;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.46;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.15;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.08;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.42;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.13.55;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2011.11.03.02.32.10;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2012.10.13.21.23.39;	author djm;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Split out BN_div and BN_mod into ct and nonct versions for Internal use.
ok jsing@@
@
text
@/* $OpenBSD: dsa_gen.c,v 1.23 2017/01/21 09:38:59 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <openssl/opensslconf.h> /* To see if OPENSSL_NO_SHA is defined */

#ifndef OPENSSL_NO_SHA

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/bn.h>
#include <openssl/evp.h>
#include <openssl/sha.h>

#include "bn_lcl.h"
#include "dsa_locl.h"

int
DSA_generate_parameters_ex(DSA *ret, int bits, const unsigned char *seed_in,
    int seed_len, int *counter_ret, unsigned long *h_ret, BN_GENCB *cb)
{
	if (ret->meth->dsa_paramgen)
		return ret->meth->dsa_paramgen(ret, bits, seed_in, seed_len,
		    counter_ret, h_ret, cb);
	else {
		const EVP_MD *evpmd;
		size_t qbits;

		if (bits >= 2048) {
			qbits = 256;
			evpmd = EVP_sha256();
		} else {
			qbits = 160;
			evpmd = EVP_sha1();
		}

		return dsa_builtin_paramgen(ret, bits, qbits, evpmd, seed_in,
		    seed_len, NULL, counter_ret, h_ret, cb);
	}
}

int
dsa_builtin_paramgen(DSA *ret, size_t bits, size_t qbits, const EVP_MD *evpmd,
    const unsigned char *seed_in, size_t seed_len, unsigned char *seed_out,
    int *counter_ret, unsigned long *h_ret, BN_GENCB *cb)
{
	int ok = 0;
	unsigned char seed[SHA256_DIGEST_LENGTH];
	unsigned char md[SHA256_DIGEST_LENGTH];
	unsigned char buf[SHA256_DIGEST_LENGTH], buf2[SHA256_DIGEST_LENGTH];
	BIGNUM *r0, *W, *X, *c, *test;
	BIGNUM *g = NULL, *q = NULL, *p = NULL;
	BN_MONT_CTX *mont = NULL;
	int i, k, n = 0, m = 0, qsize = qbits >> 3;
	int counter = 0;
	int r = 0;
	BN_CTX *ctx = NULL;
	unsigned int h = 2;

	if (qsize != SHA_DIGEST_LENGTH && qsize != SHA224_DIGEST_LENGTH &&
	    qsize != SHA256_DIGEST_LENGTH)
		/* invalid q size */
		return 0;

	if (evpmd == NULL)
		/* use SHA1 as default */
		evpmd = EVP_sha1();

	if (bits < 512)
		bits = 512;

	bits = (bits + 63) / 64 * 64;

	if (seed_len < (size_t)qsize) {
		seed_in = NULL;		/* seed buffer too small -- ignore */
		seed_len = 0;
	}
	/*
	 * App. 2.2 of FIPS PUB 186 allows larger SEED,
	 * but our internal buffers are restricted to 160 bits
	 */
	if (seed_len > (size_t)qsize) 
		seed_len = qsize;
	if (seed_in != NULL)
		memcpy(seed, seed_in, seed_len);
	else if (seed_len != 0)
		goto err;

	if ((mont=BN_MONT_CTX_new()) == NULL)
		goto err;

	if ((ctx=BN_CTX_new()) == NULL)
		goto err;
	BN_CTX_start(ctx);

	if ((r0 = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((g = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((W = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((q = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((X = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((c = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((p = BN_CTX_get(ctx)) == NULL)
		goto err;
	if ((test = BN_CTX_get(ctx)) == NULL)
		goto err;

	if (!BN_lshift(test, BN_value_one(), bits - 1))
		goto err;

	for (;;) {
		for (;;) { /* find q */
			int seed_is_random;

			/* step 1 */
			if (!BN_GENCB_call(cb, 0, m++))
				goto err;

			if (seed_len == 0) {
				arc4random_buf(seed, qsize);
				seed_is_random = 1;
			} else {
				seed_is_random = 0;
				/* use random seed if 'seed_in' turns out
				   to be bad */
				seed_len = 0;
			}
			memcpy(buf, seed, qsize);
			memcpy(buf2, seed, qsize);
			/* precompute "SEED + 1" for step 7: */
			for (i = qsize - 1; i >= 0; i--) {
				buf[i]++;
				if (buf[i] != 0)
					break;
			}

			/* step 2 */
			if (!EVP_Digest(seed, qsize, md,   NULL, evpmd, NULL))
				goto err;
			if (!EVP_Digest(buf,  qsize, buf2, NULL, evpmd, NULL))
				goto err;
			for (i = 0; i < qsize; i++)
				md[i] ^= buf2[i];

			/* step 3 */
			md[0] |= 0x80;
			md[qsize - 1] |= 0x01;
			if (!BN_bin2bn(md, qsize, q))
				goto err;

			/* step 4 */
			r = BN_is_prime_fasttest_ex(q, DSS_prime_checks, ctx,
			    seed_is_random, cb);
			if (r > 0)
				break;
			if (r != 0)
				goto err;

			/* do a callback call */
			/* step 5 */
		}

		if (!BN_GENCB_call(cb, 2, 0))
			goto err;
		if (!BN_GENCB_call(cb, 3, 0))
			goto err;

		/* step 6 */
		counter = 0;
		/* "offset = 2" */

		n = (bits - 1) / 160;

		for (;;) {
			if (counter != 0 && !BN_GENCB_call(cb, 0, counter))
				goto err;

			/* step 7 */
			BN_zero(W);
			/* now 'buf' contains "SEED + offset - 1" */
			for (k = 0; k <= n; k++) {
				/* obtain "SEED + offset + k" by incrementing: */
				for (i = qsize - 1; i >= 0; i--) {
					buf[i]++;
					if (buf[i] != 0)
						break;
				}

				if (!EVP_Digest(buf, qsize, md ,NULL, evpmd,
				    NULL))
					goto err;

				/* step 8 */
				if (!BN_bin2bn(md, qsize, r0))
					goto err;
				if (!BN_lshift(r0, r0, (qsize << 3) * k))
					goto err;
				if (!BN_add(W, W, r0))
					goto err;
			}

			/* more of step 8 */
			if (!BN_mask_bits(W, bits - 1))
				goto err;
			if (!BN_copy(X, W))
				goto err;
			if (!BN_add(X, X, test))
				goto err;

			/* step 9 */
			if (!BN_lshift1(r0, q))
				goto err;
			if (!BN_mod_ct(c, X, r0, ctx))
				goto err;
			if (!BN_sub(r0, c, BN_value_one()))
				goto err;
			if (!BN_sub(p, X, r0))
				goto err;

			/* step 10 */
			if (BN_cmp(p, test) >= 0) {
				/* step 11 */
				r = BN_is_prime_fasttest_ex(p, DSS_prime_checks,
				    ctx, 1, cb);
				if (r > 0)
					goto end; /* found it */
				if (r != 0)
					goto err;
			}

			/* step 13 */
			counter++;
			/* "offset = offset + n + 1" */

			/* step 14 */
			if (counter >= 4096)
				break;
		}
	}
end:
	if (!BN_GENCB_call(cb, 2, 1))
		goto err;

	/* We now need to generate g */
	/* Set r0=(p-1)/q */
	if (!BN_sub(test, p, BN_value_one()))
		goto err;
	if (!BN_div_ct(r0, NULL, test, q, ctx))
		goto err;

	if (!BN_set_word(test, h))
		goto err;
	if (!BN_MONT_CTX_set(mont, p, ctx))
		goto err;

	for (;;) {
		/* g=test^r0%p */
		if (!BN_mod_exp_mont_ct(g, test, r0, p, ctx, mont))
			goto err;
		if (!BN_is_one(g))
			break;
		if (!BN_add(test, test, BN_value_one()))
			goto err;
		h++;
	}

	if (!BN_GENCB_call(cb, 3, 1))
		goto err;

	ok = 1;
err:
	if (ok) {
		BN_free(ret->p);
		BN_free(ret->q);
		BN_free(ret->g);
		ret->p = BN_dup(p);
		ret->q = BN_dup(q);
		ret->g = BN_dup(g);
		if (ret->p == NULL || ret->q == NULL || ret->g == NULL) {
			ok = 0;
			goto err;
		}
		if (counter_ret != NULL)
			*counter_ret = counter;
		if (h_ret != NULL)
			*h_ret = h;
		if (seed_out != NULL)
			memcpy(seed_out, seed, qsize);
	}
	if (ctx) {
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
	}
	BN_MONT_CTX_free(mont);
	return ok;
}
#endif
@


1.23
log
@Make explicit _ct and _nonct versions of bn_mod_exp funcitons that
matter for constant time, and make the public interface only used
external to the library.

This moves us to a model where the important things are constant time
versions unless you ask for them not to be, rather than the opposite.
I'll continue with this method by method.

Add regress tests for same.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.22 2015/07/15 18:34:37 miod Exp $ */
d274 1
a274 1
			if (!BN_mod(c, X, r0, ctx))
d309 1
a309 1
	if (!BN_div(r0, NULL, test, q, ctx))
@


1.22
log
@Fix inverted test in previous. Commit message told what we intended, but
we did not notice my fingers slipping. Noticed by bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.21 2015/07/15 16:32:29 miod Exp $ */
d71 1
d319 1
a319 1
		if (!BN_mod_exp_mont(g, test, r0, p, ctx, mont))
@


1.21
log
@Previous fix for Coverity CID 21785 did not cope correctly with seed_len != 0,
seed_in == NULL case. Since this situation is an error anyway, bail out
early.
with and ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.20 2015/02/15 22:29:02 doug Exp $ */
d141 1
a141 1
	else if (seed_len == 0)
@


1.20
log
@Avoid calling BN_CTX_end() on a context that wasn't started.

In dsa_builtin_paramgen(), if BN_MONT_CTX_new() fails, the BN_CTX_new()
call above it will have allocated a ctx without calling BN_CTX_start() on
it.  The error handling calls BN_CTX_end() when ctx is allocated.

Move the BN_MONT_CTX_new() call up so it will fail first without splitting
up the BN_CTX_new() and BN_CTX_start().

tweak + ok miod@@, ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.19 2015/02/15 08:48:24 miod Exp $ */
d141 2
@


1.19
log
@If we decide to discard the provided seed buffer because its size is not
large enough, do it correctly so that the local seed buffer on the stack
gets properly initialized in the first iteration of the loop.
While there, remove an outdated and bogus comment.
Coverity CID 21785
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.18 2015/02/09 15:49:22 jsing Exp $ */
d142 1
a142 1
	if ((ctx=BN_CTX_new()) == NULL)
d145 1
a145 1
	if ((mont=BN_MONT_CTX_new()) == NULL)
d147 1
a148 1
	BN_CTX_start(ctx);
@


1.18
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.17 2014/10/22 13:02:04 jsing Exp $ */
d129 1
a129 5
	/*
	 * NB: seed_len == 0 is special case: copy generated seed to
 	 * seed_in if it is not NULL.
 	 */
	if (seed_len && seed_len < (size_t)qsize)
d131 2
d177 1
a177 1
			if (!seed_len) {
d345 1
a345 1
		if (seed_out)
@


1.17
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.16 2014/07/12 16:03:37 miod Exp $ */
d151 16
a166 8
	r0 = BN_CTX_get(ctx);
	g = BN_CTX_get(ctx);
	W = BN_CTX_get(ctx);
	q = BN_CTX_get(ctx);
	X = BN_CTX_get(ctx);
	c = BN_CTX_get(ctx);
	p = BN_CTX_get(ctx);
	test = BN_CTX_get(ctx);
@


1.16
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.15 2014/07/11 08:44:48 jsing Exp $ */
d64 1
a68 1
#include <openssl/rand.h>
d172 1
a172 1
				RAND_pseudo_bytes(seed, qsize);
@


1.15
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.14 2014/07/10 13:58:22 jsing Exp $ */
d325 3
a327 6
		if (ret->p)
			BN_free(ret->p);
		if (ret->q)
			BN_free(ret->q);
		if (ret->g)
			BN_free(ret->g);
d346 1
a346 2
	if (mont != NULL)
		BN_MONT_CTX_free(mont);
@


1.14
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.13 2014/07/09 10:16:24 miod Exp $ */
d66 1
a66 1
#include "cryptlib.h"
a67 1
#include <openssl/bn.h>
d70 1
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_gen.c,v 1.12 2014/06/12 15:49:28 deraadt Exp $ */
d64 2
@


1.12
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a58 13
#undef GENUINE_DSA

#ifdef GENUINE_DSA
/* Parameter generation follows the original release of FIPS PUB 186,
 * Appendix 2.2 (i.e. use SHA as defined in FIPS PUB 180) */
#define HASH    EVP_sha()
#else
/* Parameter generation follows the updated Appendix 2.2 for FIPS PUB 186,
 * also Appendix 2.2 of FIPS PUB 186-1 (i.e. use SHA as defined in
 * FIPS PUB 180-1) */
#define HASH    EVP_sha1()
#endif 

d71 5
a75 5
int DSA_generate_parameters_ex(DSA *ret, int bits,
		const unsigned char *seed_in, int seed_len,
		int *counter_ret, unsigned long *h_ret, BN_GENCB *cb)
	{
	if(ret->meth->dsa_paramgen)
d77 2
a78 3
				counter_ret, h_ret, cb);
	else
		{
d80 1
a80 1
		size_t qbits = bits >= 2048 ? 256 : 160;
d82 1
a82 2
		if (bits >= 2048)
			{
d85 1
a85 3
			}
		else
			{
d88 1
a88 1
			}
d90 2
a91 3
		return dsa_builtin_paramgen(ret, bits, qbits, evpmd,
			seed_in, seed_len, NULL, counter_ret, h_ret, cb);
		}
d93 1
d95 6
a100 6
int dsa_builtin_paramgen(DSA *ret, size_t bits, size_t qbits,
	const EVP_MD *evpmd, const unsigned char *seed_in, size_t seed_len,
	unsigned char *seed_out,
	int *counter_ret, unsigned long *h_ret, BN_GENCB *cb)
	{
	int ok=0;
d103 9
a111 9
	unsigned char buf[SHA256_DIGEST_LENGTH],buf2[SHA256_DIGEST_LENGTH];
	BIGNUM *r0,*W,*X,*c,*test;
	BIGNUM *g=NULL,*q=NULL,*p=NULL;
	BN_MONT_CTX *mont=NULL;
	int i, k, n=0, m=0, qsize = qbits >> 3;
	int counter=0;
	int r=0;
	BN_CTX *ctx=NULL;
	unsigned int h=2;
d125 1
a125 1
	bits = (bits+63)/64*64;
d127 2
a128 1
	/* NB: seed_len == 0 is special case: copy generated seed to
d131 1
a131 1
	if (seed_len && (seed_len < (size_t)qsize))
d133 4
d138 1
a138 2
		seed_len = qsize;	/* App. 2.2 of FIPS PUB 186 allows larger SEED,
					 * but our internal buffers are restricted to 160 bits*/
d158 1
a158 1
	if (!BN_lshift(test,BN_value_one(),bits-1))
d161 2
a162 4
	for (;;)
		{
		for (;;) /* find q */
			{
d166 1
a166 1
			if(!BN_GENCB_call(cb, 0, m++))
d169 1
a169 2
			if (!seed_len)
				{
d172 1
a172 3
				}
			else
				{
d174 5
a178 3
				seed_len=0; /* use random seed if 'seed_in' turns out to be bad*/
				}
			memcpy(buf , seed, qsize);
d181 1
a181 2
			for (i = qsize-1; i >= 0; i--)
				{
d185 1
a185 1
				}
d193 1
a193 1
				md[i]^=buf2[i];
d197 1
a197 1
			md[qsize-1] |= 0x01;
d203 1
a203 1
					seed_is_random, cb);
d211 1
a211 1
			}
d213 4
a216 2
		if(!BN_GENCB_call(cb, 2, 0)) goto err;
		if(!BN_GENCB_call(cb, 3, 0)) goto err;
d219 1
a219 1
		counter=0;
d222 1
a222 1
		n=(bits-1)/160;
d224 2
a225 3
		for (;;)
			{
			if ((counter != 0) && !BN_GENCB_call(cb, 0, counter))
d231 1
a231 2
			for (k=0; k<=n; k++)
				{
d233 1
a233 2
				for (i = qsize-1; i >= 0; i--)
					{
d237 1
a237 1
					}
d240 1
a240 1
									NULL))
d246 5
a250 3
				if (!BN_lshift(r0,r0,(qsize << 3)*k)) goto err;
				if (!BN_add(W,W,r0)) goto err;
				}
d253 6
a258 3
			if (!BN_mask_bits(W,bits-1)) goto err;
			if (!BN_copy(X,W)) goto err;
			if (!BN_add(X,X,test)) goto err;
d261 8
a268 4
			if (!BN_lshift1(r0,q)) goto err;
			if (!BN_mod(c,X,r0,ctx)) goto err;
			if (!BN_sub(r0,c,BN_value_one())) goto err;
			if (!BN_sub(p,X,r0)) goto err;
d271 1
a271 2
			if (BN_cmp(p,test) >= 0)
				{
d274 1
a274 1
						ctx, 1, cb);
d276 1
a276 1
						goto end; /* found it */
d279 1
a279 1
				}
d286 2
a287 2
			if (counter >= 4096) break;
			}
d289 1
d291 1
a291 1
	if(!BN_GENCB_call(cb, 2, 1))
d296 4
a299 2
	if (!BN_sub(test,p,BN_value_one())) goto err;
	if (!BN_div(r0,NULL,test,q,ctx)) goto err;
d301 4
a304 2
	if (!BN_set_word(test,h)) goto err;
	if (!BN_MONT_CTX_set(mont,p,ctx)) goto err;
d306 1
a306 2
	for (;;)
		{
d308 6
a313 3
		if (!BN_mod_exp_mont(g,test,r0,p,ctx,mont)) goto err;
		if (!BN_is_one(g)) break;
		if (!BN_add(test,test,BN_value_one())) goto err;
d315 1
a315 1
		}
d317 1
a317 1
	if(!BN_GENCB_call(cb, 3, 1))
d320 1
a320 1
	ok=1;
d322 12
a333 11
	if (ok)
		{
		if(ret->p) BN_free(ret->p);
		if(ret->q) BN_free(ret->q);
		if(ret->g) BN_free(ret->g);
		ret->p=BN_dup(p);
		ret->q=BN_dup(q);
		ret->g=BN_dup(g);
		if (ret->p == NULL || ret->q == NULL || ret->g == NULL)
			{
			ok=0;
d335 5
a339 3
			}
		if (counter_ret != NULL) *counter_ret=counter;
		if (h_ret != NULL) *h_ret=h;
d342 2
a343 3
		}
	if(ctx)
		{
d346 3
a348 2
		}
	if (mont != NULL) BN_MONT_CTX_free(mont);
d350 1
a350 1
	}
@


1.11
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok beck deraadt
@
text
@d1 1
a1 1
/* crypto/dsa/dsa_gen.c */
@


1.10
log
@resolve conflicts
@
text
@a83 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a87 8
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && !(ret->meth->flags & DSA_FLAG_FIPS_METHOD)
			&& !(ret->flags & DSA_FLAG_NON_FIPS_ALLOW))
		{
		DSAerr(DSA_F_DSA_GENERATE_PARAMETERS_EX, DSA_R_NON_FIPS_DSA_METHOD);
		return 0;
		}
#endif
a90 8
#ifdef OPENSSL_FIPS
	else if (FIPS_mode())
		{
		return FIPS_dsa_generate_parameters_ex(ret, bits, 
							seed_in, seed_len,
							counter_ret, h_ret, cb);
		}
#endif
@


1.9
log
@openssl-1.0.0e: resolve conflicts
@
text
@d84 4
d92 8
d103 8
d128 1
a128 1
				seed_in, seed_len, counter_ret, h_ret, cb);
d134 1
d225 4
a228 2
			EVP_Digest(seed, qsize, md,   NULL, evpmd, NULL);
			EVP_Digest(buf,  qsize, buf2, NULL, evpmd, NULL);
d277 3
a279 1
				EVP_Digest(buf, qsize, md ,NULL, evpmd, NULL);
d360 2
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d123 1
a123 1
	int i, k,n=0,b,m=0, qsize = qbits >> 3;
a234 1
		b=(bits-1)-n*160;
@


1.7
log
@resolve conflicts
@
text
@a76 1
#include <time.h>
a79 1
#include <openssl/dsa.h>
d82 1
a82 6

#ifndef OPENSSL_FIPS

static int dsa_builtin_paramgen(DSA *ret, int bits,
		unsigned char *seed_in, int seed_len,
		int *counter_ret, unsigned long *h_ret, BN_GENCB *cb);
d85 1
a85 1
		unsigned char *seed_in, int seed_len,
d91 19
a109 2
	return dsa_builtin_paramgen(ret, bits, seed_in, seed_len,
			counter_ret, h_ret, cb);
d112 3
a114 3
static int dsa_builtin_paramgen(DSA *ret, int bits,
		unsigned char *seed_in, int seed_len,
		int *counter_ret, unsigned long *h_ret, BN_GENCB *cb)
d117 3
a119 3
	unsigned char seed[SHA_DIGEST_LENGTH];
	unsigned char md[SHA_DIGEST_LENGTH];
	unsigned char buf[SHA_DIGEST_LENGTH],buf2[SHA_DIGEST_LENGTH];
d123 1
a123 1
	int k,n=0,i,b,m=0;
d129 13
a141 2
	if (bits < 512) bits=512;
	bits=(bits+63)/64*64;
d146 7
a152 11
	if (seed_len && (seed_len < 20))
		seed_in = NULL; /* seed buffer too small -- ignore */
	if (seed_len > 20) 
		seed_len = 20; /* App. 2.2 of FIPS PUB 186 allows larger SEED,
		                * but our internal buffers are restricted to 160 bits*/
	if ((seed_in != NULL) && (seed_len == 20))
		{
		memcpy(seed,seed_in,seed_len);
		/* set seed_in to NULL to avoid it being copied back */
		seed_in = NULL;
		}
d154 2
a155 1
	if ((ctx=BN_CTX_new()) == NULL) goto err;
d157 2
a158 1
	if ((mont=BN_MONT_CTX_new()) == NULL) goto err;
d185 1
a185 1
				RAND_pseudo_bytes(seed,SHA_DIGEST_LENGTH);
d193 2
a194 2
			memcpy(buf,seed,SHA_DIGEST_LENGTH);
			memcpy(buf2,seed,SHA_DIGEST_LENGTH);
d196 1
a196 1
			for (i=SHA_DIGEST_LENGTH-1; i >= 0; i--)
d199 2
a200 1
				if (buf[i] != 0) break;
d204 3
a206 3
			EVP_Digest(seed,SHA_DIGEST_LENGTH,md,NULL,HASH, NULL);
			EVP_Digest(buf,SHA_DIGEST_LENGTH,buf2,NULL,HASH, NULL);
			for (i=0; i<SHA_DIGEST_LENGTH; i++)
d210 4
a213 3
			md[0]|=0x80;
			md[SHA_DIGEST_LENGTH-1]|=0x01;
			if (!BN_bin2bn(md,SHA_DIGEST_LENGTH,q)) goto err;
d248 1
a248 1
				for (i=SHA_DIGEST_LENGTH-1; i >= 0; i--)
d251 2
a252 1
					if (buf[i] != 0) break;
d255 1
a255 1
				EVP_Digest(buf,SHA_DIGEST_LENGTH,md,NULL,HASH, NULL);
d258 1
a258 1
				if (!BN_bin2bn(md,SHA_DIGEST_LENGTH,r0))
d260 1
a260 1
				if (!BN_lshift(r0,r0,160*k)) goto err;
a333 1
		if (seed_in != NULL) memcpy(seed_in,seed,20);
a344 1
#endif
@


1.6
log
@resolve conflicts
@
text
@d85 2
d324 1
@


1.5
log
@resolve conflicts
@
text
@d72 2
d85 16
a100 2
#ifndef OPENSSL_FIPS
DSA *DSA_generate_parameters(int bits,
d102 1
a102 3
		int *counter_ret, unsigned long *h_ret,
		void (*callback)(int, int, void *),
		void *cb_arg)
d114 1
a114 1
	BN_CTX *ctx=NULL,*ctx2=NULL,*ctx3=NULL;
a115 1
	DSA *ret=NULL;
d120 4
a123 1
	if (seed_len < 20)
d129 1
d131 3
a135 3
	if ((ctx2=BN_CTX_new()) == NULL) goto err;
	if ((ctx3=BN_CTX_new()) == NULL) goto err;
	if ((ret=DSA_new()) == NULL) goto err;
d139 9
a147 10
	BN_CTX_start(ctx2);
	r0 = BN_CTX_get(ctx2);
	g = BN_CTX_get(ctx2);
	W = BN_CTX_get(ctx2);
	q = BN_CTX_get(ctx2);
	X = BN_CTX_get(ctx2);
	c = BN_CTX_get(ctx2);
	p = BN_CTX_get(ctx2);
	test = BN_CTX_get(ctx2);
	if (test == NULL) goto err;
d149 2
a150 1
	if (!BN_lshift(test,BN_value_one(),bits-1)) goto err;
d159 2
a160 1
			if (callback != NULL) callback(0,m++,cb_arg);
d193 2
a194 1
			r = BN_is_prime_fasttest(q, DSS_prime_checks, callback, ctx3, cb_arg, seed_is_random);
d204 2
a205 2
		if (callback != NULL) callback(2,0,cb_arg);
		if (callback != NULL) callback(3,0,cb_arg);
d216 2
a217 2
			if (callback != NULL && counter != 0)
				callback(0,counter,cb_arg);
d220 1
a220 1
			if (!BN_zero(W)) goto err;
d255 2
a256 1
				r = BN_is_prime_fasttest(p, DSS_prime_checks, callback, ctx3, cb_arg, 1);
d272 2
a273 1
	if (callback != NULL) callback(2,1,cb_arg);
d292 2
a293 1
	if (callback != NULL) callback(3,1,cb_arg);
d297 1
a297 5
	if (!ok)
		{
		if (ret != NULL) DSA_free(ret);
		}
	else
d299 3
d310 1
a310 1
		if ((m > 1) && (seed_in != NULL)) memcpy(seed_in,seed,20);
d314 1
a314 2
	if (ctx != NULL) BN_CTX_free(ctx);
	if (ctx2 != NULL)
d316 2
a317 2
		BN_CTX_end(ctx2);
		BN_CTX_free(ctx2);
a318 1
	if (ctx3 != NULL) BN_CTX_free(ctx3);
d320 1
a320 1
	return(ok?ret:NULL);
d322 1
a322 3
#endif /* ndef OPENSSL_FIPS */
#endif /* ndef OPENSSL_NO_SHA */

@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d83 1
d131 1
d133 1
a133 1
	BN_lshift(test,BN_value_one(),bits-1);
d201 1
a201 1
			BN_zero(W);
d217 2
a218 2
				BN_lshift(r0,r0,160*k);
				BN_add(W,W,r0);
d222 3
a224 3
			BN_mask_bits(W,bits-1);
			BN_copy(X,W); /* this should be ok */
			BN_add(X,X,test); /* this should be ok */
d227 4
a230 4
			BN_lshift1(r0,q);
			BN_mod(c,X,r0,ctx);
			BN_sub(r0,c,BN_value_one());
			BN_sub(p,X,r0);
d256 2
a257 2
	BN_sub(test,p,BN_value_one());
	BN_div(r0,NULL,test,q,ctx);
d259 2
a260 2
	BN_set_word(test,h);
	BN_MONT_CTX_set(mont,p,ctx);
d265 1
a265 1
		BN_mod_exp_mont(g,test,r0,p,ctx,mont);
d267 1
a267 1
		BN_add(test,test,BN_value_one());
d284 5
d303 3
a305 1
#endif
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d64 1
a64 1
#define HASH    SHA
d69 1
a69 1
#define HASH    SHA1
d72 1
a72 1
#ifndef NO_SHA
d77 1
a77 1
#include <openssl/sha.h>
d81 1
d83 2
a84 1
DSA *DSA_generate_parameters(int bits, unsigned char *seed_in, int seed_len,
d162 2
a163 2
			HASH(seed,SHA_DIGEST_LENGTH,md);
			HASH(buf,SHA_DIGEST_LENGTH,buf2);
d210 1
a210 1
				HASH(buf,SHA_DIGEST_LENGTH,md);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d62 2
d66 3
d73 1
d83 3
a85 2
	     int *counter_ret, unsigned long *h_ret, void (*callback)(),
	     char *cb_arg)
d96 2
a97 1
	BN_CTX *ctx=NULL,*ctx2=NULL;
d104 5
d114 1
d119 9
a127 8
	r0= &(ctx2->bn[0]);
	g= &(ctx2->bn[1]);
	W= &(ctx2->bn[2]);
	q= &(ctx2->bn[3]);
	X= &(ctx2->bn[4]);
	c= &(ctx2->bn[5]);
	p= &(ctx2->bn[6]);
	test= &(ctx2->bn[7]);
d133 1
a133 1
		for (;;)
d135 2
d141 4
a144 1
				RAND_bytes(seed,SHA_DIGEST_LENGTH);
d146 4
a149 2
				seed_len=0;

d152 1
d168 1
a168 1
			if (!BN_bin2bn(md,SHA_DIGEST_LENGTH,q)) abort();
d171 6
a176 1
			if (DSA_is_prime(q,callback,cb_arg) > 0) break;
d186 1
d193 3
d198 1
d201 1
d211 2
a212 1
				if (!BN_bin2bn(md,SHA_DIGEST_LENGTH,r0)) abort();
d232 5
a236 2
				if (DSA_is_prime(p,callback,cb_arg) > 0)
					goto end;
d241 1
a244 2

			if (callback != NULL) callback(0,counter,cb_arg);
d250 1
a250 1
	/* We now need to gernerate g */
d285 6
a290 1
	if (ctx != NULL) BN_CTX_free(ctx2);
a292 81
	}

int DSA_is_prime(BIGNUM *w, void (*callback)(), char *cb_arg)
	{
	int ok= -1,j,i,n;
	BN_CTX *ctx=NULL,*ctx2=NULL;
	BIGNUM *w_1,*b,*m,*z,*tmp,*mont_1;
	int a;
	BN_MONT_CTX *mont=NULL;

	if (!BN_is_bit_set(w,0)) return(0);

	if ((ctx=BN_CTX_new()) == NULL) goto err;
	if ((ctx2=BN_CTX_new()) == NULL) goto err;
	if ((mont=BN_MONT_CTX_new()) == NULL) goto err;

	m=   &(ctx2->bn[2]);
	b=   &(ctx2->bn[3]);
	z=   &(ctx2->bn[4]);
	w_1= &(ctx2->bn[5]);
	tmp= &(ctx2->bn[6]);
	mont_1= &(ctx2->bn[7]);

	/* step 1 */
	n=50;

	/* step 2 */
	if (!BN_sub(w_1,w,BN_value_one())) goto err;
	for (a=1; !BN_is_bit_set(w_1,a); a++)
		;
	if (!BN_rshift(m,w_1,a)) goto err;

	BN_MONT_CTX_set(mont,w,ctx);
	BN_to_montgomery(mont_1,BN_value_one(),mont,ctx);
	BN_to_montgomery(w_1,w_1,mont,ctx);
	for (i=1; i < n; i++)
		{
		/* step 3 */
		BN_rand(b,BN_num_bits(w)-2/*-1*/,0,0);
		/* BN_set_word(b,0x10001L); */

		/* step 4 */
		j=0;
		if (!BN_mod_exp_mont(z,b,m,w,ctx,mont)) goto err;

		if (!BN_to_montgomery(z,z,mont,ctx)) goto err;

		/* step 5 */
		for (;;)
			{
			if (((j == 0) && (BN_cmp(z,mont_1) == 0)) ||
				(BN_cmp(z,w_1) == 0))
				break;

			/* step 6 */
			if ((j > 0) && (BN_cmp(z,mont_1) == 0))
				{
				ok=0;
				goto err;
				}

			j++;
			if (j >= a)
				{
				ok=0;
				goto err;
				}

			if (!BN_mod_mul_montgomery(z,z,z,mont,ctx)) goto err;
			if (callback != NULL) callback(1,j,cb_arg);
			}
		}

	ok=1;
err:
	if (ok == -1) DSAerr(DSA_F_DSA_IS_PRIME,ERR_R_BN_LIB);
	BN_CTX_free(ctx);
	BN_CTX_free(ctx2);
	BN_MONT_CTX_free(mont);
	
	return(ok);
@


1.1
log
@Initial revision
@
text
@d67 1
d71 8
a78 14
#include "sha.h"
#include "bn.h"
#include "dsa.h"
#include "rand.h"

DSA *DSA_generate_parameters(bits,seed_in,seed_len,counter_ret,h_ret,callback,
	cb_arg)
int bits;
unsigned char *seed_in;
int seed_len;
int *counter_ret;
unsigned long *h_ret;
void (*callback)();
char *cb_arg;
d86 1
d99 14
a112 14
	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;
	ctx2=BN_CTX_new();
	if (ctx2 == NULL) goto err;
	ret=DSA_new();
	if (ret == NULL) goto err;
	r0=ctx2->bn[0];
	g=ctx2->bn[1];
	W=ctx2->bn[2];
	q=ctx2->bn[3];
	X=ctx2->bn[4];
	c=ctx2->bn[5];
	p=ctx2->bn[6];
	test=ctx2->bn[7];
d215 2
a216 2
        BN_sub(test,p,BN_value_one());
        BN_div(r0,NULL,test,q,ctx);
d219 2
d224 1
a224 1
		BN_mod_exp(g,test,r0,p,ctx);
d247 3
a249 2
	BN_CTX_free(ctx);
	BN_CTX_free(ctx2);
d253 1
a253 4
int DSA_is_prime(w, callback,cb_arg)
BIGNUM *w;
void (*callback)();
char *cb_arg;
d257 1
a257 1
	BIGNUM *w_1,*b,*m,*z;
d259 1
d263 10
a272 9
	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;
	ctx2=BN_CTX_new();
	if (ctx2 == NULL) goto err;

	m=  ctx2->bn[2];
	b=  ctx2->bn[3];
	z=  ctx2->bn[4];
	w_1=ctx2->bn[5];
d283 3
d290 1
a290 1
		BN_set_word(b,0x10001L);
d294 3
a296 1
		if (!BN_mod_exp(z,b,m,w,ctx)) goto err;
d301 2
a302 1
			if (((j == 0) && BN_is_one(z)) || (BN_cmp(z,w_1) == 0))
d306 1
a306 1
			if ((j > 0) && BN_is_one(z))
d319 1
a319 1
			if (!BN_mod_mul(z,z,z,w,ctx)) goto err;
d329 1
d333 1
a333 1

@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d62 1
a62 3
/* Parameter generation follows the original release of FIPS PUB 186,
 * Appendix 2.2 (i.e. use SHA as defined in FIPS PUB 180) */
#define HASH    EVP_sha()
d64 1
a64 4
/* Parameter generation follows the updated Appendix 2.2 for FIPS PUB 186,
 * also Appendix 2.2 of FIPS PUB 186-1 (i.e. use SHA as defined in
 * FIPS PUB 180-1) */
#define HASH    EVP_sha1()
a66 2
#ifndef OPENSSL_NO_SHA

d70 14
a83 11
#include <openssl/evp.h>
#include <openssl/bn.h>
#include <openssl/dsa.h>
#include <openssl/rand.h>
#include <openssl/sha.h>

DSA *DSA_generate_parameters(int bits,
		unsigned char *seed_in, int seed_len,
		int *counter_ret, unsigned long *h_ret,
		void (*callback)(int, int, void *),
		void *cb_arg)
a90 1
	BN_MONT_CTX *mont=NULL;
d93 1
a93 2
	int r=0;
	BN_CTX *ctx=NULL,*ctx2=NULL,*ctx3=NULL;
a99 5
	if (seed_len < 20)
		seed_in = NULL; /* seed buffer too small -- ignore */
	if (seed_len > 20) 
		seed_len = 20; /* App. 2.2 of FIPS PUB 186 allows larger SEED,
		                * but our internal buffers are restricted to 160 bits*/
d103 14
a116 16
	if ((ctx=BN_CTX_new()) == NULL) goto err;
	if ((ctx2=BN_CTX_new()) == NULL) goto err;
	if ((ctx3=BN_CTX_new()) == NULL) goto err;
	if ((ret=DSA_new()) == NULL) goto err;

	if ((mont=BN_MONT_CTX_new()) == NULL) goto err;

	BN_CTX_start(ctx2);
	r0 = BN_CTX_get(ctx2);
	g = BN_CTX_get(ctx2);
	W = BN_CTX_get(ctx2);
	q = BN_CTX_get(ctx2);
	X = BN_CTX_get(ctx2);
	c = BN_CTX_get(ctx2);
	p = BN_CTX_get(ctx2);
	test = BN_CTX_get(ctx2);
d122 1
a122 1
		for (;;) /* find q */
a123 2
			int seed_is_random;

d128 1
a128 4
				{
				RAND_pseudo_bytes(seed,SHA_DIGEST_LENGTH);
				seed_is_random = 1;
				}
d130 2
a131 4
				{
				seed_is_random = 0;
				seed_len=0; /* use random seed if 'seed_in' turns out to be bad*/
				}
a133 1
			/* precompute "SEED + 1" for step 7: */
d141 2
a142 2
			EVP_Digest(seed,SHA_DIGEST_LENGTH,md,NULL,HASH, NULL);
			EVP_Digest(buf,SHA_DIGEST_LENGTH,buf2,NULL,HASH, NULL);
d149 1
a149 1
			if (!BN_bin2bn(md,SHA_DIGEST_LENGTH,q)) goto err;
d152 1
a152 6
			r = BN_is_prime_fasttest(q, DSS_prime_checks, callback, ctx3, cb_arg, seed_is_random);
			if (r > 0)
				break;
			if (r != 0)
				goto err;

a161 1
		/* "offset = 2" */
a167 3
			if (callback != NULL && counter != 0)
				callback(0,counter,cb_arg);

a169 1
			/* now 'buf' contains "SEED + offset - 1" */
a171 1
				/* obtain "SEED + offset + k" by incrementing: */
d178 1
a178 1
				EVP_Digest(buf,SHA_DIGEST_LENGTH,md,NULL,HASH, NULL);
d181 1
a181 2
				if (!BN_bin2bn(md,SHA_DIGEST_LENGTH,r0))
					goto err;
d201 2
a202 5
				r = BN_is_prime_fasttest(p, DSS_prime_checks, callback, ctx3, cb_arg, 1);
				if (r > 0)
						goto end; /* found it */
				if (r != 0)
					goto err;
a206 1
			/* "offset = offset + n + 1" */
d210 2
d217 1
a217 1
	/* We now need to generate g */
d219 2
a220 2
	BN_sub(test,p,BN_value_one());
	BN_div(r0,NULL,test,q,ctx);
a222 2
	BN_MONT_CTX_set(mont,p,ctx);

d226 1
a226 1
		BN_mod_exp_mont(g,test,r0,p,ctx,mont);
d249 37
a285 2
	if (ctx != NULL) BN_CTX_free(ctx);
	if (ctx2 != NULL)
d287 31
a317 2
		BN_CTX_end(ctx2);
		BN_CTX_free(ctx2);
d319 8
a326 3
	if (ctx3 != NULL) BN_CTX_free(ctx3);
	if (mont != NULL) BN_MONT_CTX_free(mont);
	return(ok?ret:NULL);
d328 1
a328 1
#endif
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a82 1
#ifndef OPENSSL_FIPS
a129 1
	if (test == NULL) goto err;
d131 1
a131 1
	if (!BN_lshift(test,BN_value_one(),bits-1)) goto err;
d199 1
a199 1
			if (!BN_zero(W)) goto err;
d215 2
a216 2
				if (!BN_lshift(r0,r0,160*k)) goto err;
				if (!BN_add(W,W,r0)) goto err;
d220 3
a222 3
			if (!BN_mask_bits(W,bits-1)) goto err;
			if (!BN_copy(X,W)) goto err;
			if (!BN_add(X,X,test)) goto err;
d225 4
a228 4
			if (!BN_lshift1(r0,q)) goto err;
			if (!BN_mod(c,X,r0,ctx)) goto err;
			if (!BN_sub(r0,c,BN_value_one())) goto err;
			if (!BN_sub(p,X,r0)) goto err;
d254 2
a255 2
	if (!BN_sub(test,p,BN_value_one())) goto err;
	if (!BN_div(r0,NULL,test,q,ctx)) goto err;
d257 2
a258 2
	if (!BN_set_word(test,h)) goto err;
	if (!BN_MONT_CTX_set(mont,p,ctx)) goto err;
d263 1
a263 1
		if (!BN_mod_exp_mont(g,test,r0,p,ctx,mont)) goto err;
d265 1
a265 1
		if (!BN_add(test,test,BN_value_one())) goto err;
a281 5
		if (ret->p == NULL || ret->q == NULL || ret->g == NULL)
			{
			ok=0;
			goto err;
			}
d296 1
a296 3
#endif /* ndef OPENSSL_FIPS */
#endif /* ndef OPENSSL_NO_SHA */

@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@a71 2
#include <openssl/opensslconf.h> /* To see if OPENSSL_NO_SHA is defined */

d83 2
a84 16
static int dsa_builtin_paramgen(DSA *ret, int bits,
		unsigned char *seed_in, int seed_len,
		int *counter_ret, unsigned long *h_ret, BN_GENCB *cb);

int DSA_generate_parameters_ex(DSA *ret, int bits,
		unsigned char *seed_in, int seed_len,
		int *counter_ret, unsigned long *h_ret, BN_GENCB *cb)
	{
	if(ret->meth->dsa_paramgen)
		return ret->meth->dsa_paramgen(ret, bits, seed_in, seed_len,
				counter_ret, h_ret, cb);
	return dsa_builtin_paramgen(ret, bits, seed_in, seed_len,
			counter_ret, h_ret, cb);
	}

static int dsa_builtin_paramgen(DSA *ret, int bits,
d86 3
a88 1
		int *counter_ret, unsigned long *h_ret, BN_GENCB *cb)
d100 1
a100 1
	BN_CTX *ctx=NULL;
d102 1
d107 1
a107 4
	/* NB: seed_len == 0 is special case: copy generated seed to
 	 * seed_in if it is not NULL.
 	 */
	if (seed_len && (seed_len < 20))
a112 1
		{
a113 3
		/* set seed_in to NULL to avoid it being copied back */
		seed_in = NULL;
		}
d116 3
d122 10
a131 9
	BN_CTX_start(ctx);
	r0 = BN_CTX_get(ctx);
	g = BN_CTX_get(ctx);
	W = BN_CTX_get(ctx);
	q = BN_CTX_get(ctx);
	X = BN_CTX_get(ctx);
	c = BN_CTX_get(ctx);
	p = BN_CTX_get(ctx);
	test = BN_CTX_get(ctx);
d133 1
a133 2
	if (!BN_lshift(test,BN_value_one(),bits-1))
		goto err;
d142 1
a142 2
			if(!BN_GENCB_call(cb, 0, m++))
				goto err;
d175 1
a175 2
			r = BN_is_prime_fasttest_ex(q, DSS_prime_checks, ctx,
					seed_is_random, cb);
d185 2
a186 2
		if(!BN_GENCB_call(cb, 2, 0)) goto err;
		if(!BN_GENCB_call(cb, 3, 0)) goto err;
d197 2
a198 2
			if ((counter != 0) && !BN_GENCB_call(cb, 0, counter))
				goto err;
d201 1
a201 1
			BN_zero(W);
d236 1
a236 2
				r = BN_is_prime_fasttest_ex(p, DSS_prime_checks,
						ctx, 1, cb);
d252 1
a252 2
	if(!BN_GENCB_call(cb, 2, 1))
		goto err;
d271 1
a271 2
	if(!BN_GENCB_call(cb, 3, 1))
		goto err;
d275 5
a279 1
	if (ok)
a280 3
		if(ret->p) BN_free(ret->p);
		if(ret->q) BN_free(ret->q);
		if(ret->g) BN_free(ret->g);
d289 1
a289 1
		if (seed_in != NULL) memcpy(seed_in,seed,20);
d293 2
a294 1
	if(ctx)
d296 2
a297 2
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
d299 1
d301 1
a301 1
	return ok;
d303 3
a305 1
#endif
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@a84 2
#ifndef OPENSSL_FIPS

a321 1
#endif
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d77 1
d81 1
d84 6
a89 1
#include "dsa_locl.h"
d92 1
a92 1
		const unsigned char *seed_in, int seed_len,
d98 2
a99 19
	else
		{
		const EVP_MD *evpmd;
		size_t qbits = bits >= 2048 ? 256 : 160;

		if (bits >= 2048)
			{
			qbits = 256;
			evpmd = EVP_sha256();
			}
		else
			{
			qbits = 160;
			evpmd = EVP_sha1();
			}

		return dsa_builtin_paramgen(ret, bits, qbits, evpmd,
				seed_in, seed_len, counter_ret, h_ret, cb);
		}
d102 3
a104 3
int dsa_builtin_paramgen(DSA *ret, size_t bits, size_t qbits,
	const EVP_MD *evpmd, const unsigned char *seed_in, size_t seed_len,
	int *counter_ret, unsigned long *h_ret, BN_GENCB *cb)
d107 3
a109 3
	unsigned char seed[SHA256_DIGEST_LENGTH];
	unsigned char md[SHA256_DIGEST_LENGTH];
	unsigned char buf[SHA256_DIGEST_LENGTH],buf2[SHA256_DIGEST_LENGTH];
d113 1
a113 1
	int i, k,n=0,b,m=0, qsize = qbits >> 3;
d119 2
a120 13
	if (qsize != SHA_DIGEST_LENGTH && qsize != SHA224_DIGEST_LENGTH &&
	    qsize != SHA256_DIGEST_LENGTH)
		/* invalid q size */
		return 0;

	if (evpmd == NULL)
		/* use SHA1 as default */
		evpmd = EVP_sha1();

	if (bits < 512)
		bits = 512;

	bits = (bits+63)/64*64;
d125 11
a135 7
	if (seed_len && (seed_len < (size_t)qsize))
		seed_in = NULL;		/* seed buffer too small -- ignore */
	if (seed_len > (size_t)qsize) 
		seed_len = qsize;	/* App. 2.2 of FIPS PUB 186 allows larger SEED,
					 * but our internal buffers are restricted to 160 bits*/
	if (seed_in != NULL)
		memcpy(seed, seed_in, seed_len);
d137 1
a137 2
	if ((ctx=BN_CTX_new()) == NULL)
		goto err;
d139 1
a139 2
	if ((mont=BN_MONT_CTX_new()) == NULL)
		goto err;
d166 1
a166 1
				RAND_pseudo_bytes(seed, qsize);
d174 2
a175 2
			memcpy(buf , seed, qsize);
			memcpy(buf2, seed, qsize);
d177 1
a177 1
			for (i = qsize-1; i >= 0; i--)
d180 1
a180 2
				if (buf[i] != 0)
					break;
d184 3
a186 3
			EVP_Digest(seed, qsize, md,   NULL, evpmd, NULL);
			EVP_Digest(buf,  qsize, buf2, NULL, evpmd, NULL);
			for (i = 0; i < qsize; i++)
d190 3
a192 4
			md[0] |= 0x80;
			md[qsize-1] |= 0x01;
			if (!BN_bin2bn(md, qsize, q))
				goto err;
d227 1
a227 1
				for (i = qsize-1; i >= 0; i--)
d230 1
a230 2
					if (buf[i] != 0)
						break;
d233 1
a233 1
				EVP_Digest(buf, qsize, md ,NULL, evpmd, NULL);
d236 1
a236 1
				if (!BN_bin2bn(md, qsize, r0))
d238 1
a238 1
				if (!BN_lshift(r0,r0,(qsize << 3)*k)) goto err;
d312 1
d324 1
@


1.1.1.7
log
@import OpenSSL 1.0.0e
@
text
@d123 1
a123 1
	int i, k, n=0, m=0, qsize = qbits >> 3;
d235 1
@


1.1.1.8
log
@import OpenSSL-1.0.1c
@
text
@a83 4
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

a87 8
#ifdef OPENSSL_FIPS
	if (FIPS_mode() && !(ret->meth->flags & DSA_FLAG_FIPS_METHOD)
			&& !(ret->flags & DSA_FLAG_NON_FIPS_ALLOW))
		{
		DSAerr(DSA_F_DSA_GENERATE_PARAMETERS_EX, DSA_R_NON_FIPS_DSA_METHOD);
		return 0;
		}
#endif
a90 8
#ifdef OPENSSL_FIPS
	else if (FIPS_mode())
		{
		return FIPS_dsa_generate_parameters_ex(ret, bits, 
							seed_in, seed_len,
							counter_ret, h_ret, cb);
		}
#endif
d108 1
a108 1
			seed_in, seed_len, NULL, counter_ret, h_ret, cb);
a113 1
	unsigned char *seed_out,
d204 2
a205 4
			if (!EVP_Digest(seed, qsize, md,   NULL, evpmd, NULL))
				goto err;
			if (!EVP_Digest(buf,  qsize, buf2, NULL, evpmd, NULL))
				goto err;
d254 1
a254 3
				if (!EVP_Digest(buf, qsize, md ,NULL, evpmd,
									NULL))
					goto err;
a334 2
		if (seed_out)
			memcpy(seed_out, seed, qsize);
@


