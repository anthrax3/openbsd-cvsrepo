head	1.19;
access;
symbols
	OPENBSD_6_1_BASE:1.19;
locks; strict;
comment	@ * @;


1.19
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.18;
commitid	kT0fLt3r4lroFJra;

1.18
date	2016.12.30.15.28.42;	author jsing;	state Exp;
branches;
next	1.17;
commitid	jQX7vrt5rtXs5TTD;

1.17
date	2016.11.04.18.35.30;	author jsing;	state Exp;
branches;
next	1.16;
commitid	wBWgQMBCuuWRNlyK;

1.16
date	2015.02.14.15.06.55;	author jsing;	state Exp;
branches;
next	1.15;
commitid	S8zbVePR0lnGsw8C;

1.15
date	2015.02.10.05.12.23;	author jsing;	state Exp;
branches;
next	1.14;
commitid	SjcScmJB6ReM8YEr;

1.14
date	2015.01.28.04.14.31;	author beck;	state Exp;
branches;
next	1.13;
commitid	WM4kCdNQZ5icdTod;

1.13
date	2014.10.18.17.20.40;	author jsing;	state Exp;
branches;
next	1.12;
commitid	8tb4v3IC8S2vzfHj;

1.12
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.11;
commitid	yQEL1wOWIearrW15;

1.11
date	2014.07.09.10.16.24;	author miod;	state Exp;
branches;
next	1.10;
commitid	7IVFdVxu6X3GaaT8;

1.10
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	mJUVYpkFBZ0Zv2bG;

1.9
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.17.12.48.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.09.12.15.43;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.12;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.57.31;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.10.06;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.05;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.15;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.13.55;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2012.10.13.21.23.39;	author djm;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: dsa_asn1.c,v 1.18 2016/12/30 15:28:42 jsing Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/asn1.h>
#include <openssl/asn1t.h>
#include <openssl/dsa.h>
#include <openssl/err.h>

/* Override the default new methods */
static int
sig_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
{
	if (operation == ASN1_OP_NEW_PRE) {
		DSA_SIG *sig;

		sig = malloc(sizeof(DSA_SIG));
		if (!sig) {
			DSAerror(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		sig->r = NULL;
		sig->s = NULL;
		*pval = (ASN1_VALUE *)sig;
		return 2;
	}
	return 1;
}

static const ASN1_AUX DSA_SIG_aux = {
	.app_data = NULL,
	.flags = 0,
	.ref_offset = 0,
	.ref_lock = 0,
	.asn1_cb = sig_cb,
	.enc_offset = 0,
};
static const ASN1_TEMPLATE DSA_SIG_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA_SIG, r),
		.field_name = "r",
		.item = &CBIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA_SIG, s),
		.field_name = "s",
		.item = &CBIGNUM_it,
	},
};

const ASN1_ITEM DSA_SIG_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = DSA_SIG_seq_tt,
	.tcount = sizeof(DSA_SIG_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &DSA_SIG_aux,
	.size = sizeof(DSA_SIG),
	.sname = "DSA_SIG",
};


DSA_SIG *
d2i_DSA_SIG(DSA_SIG **a, const unsigned char **in, long len)
{
	return (DSA_SIG *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &DSA_SIG_it);
}

int
i2d_DSA_SIG(const DSA_SIG *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &DSA_SIG_it);
}

/* Override the default free and new methods */
static int
dsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)
{
	if (operation == ASN1_OP_NEW_PRE) {
		*pval = (ASN1_VALUE *)DSA_new();
		if (*pval)
			return 2;
		return 0;
	} else if (operation == ASN1_OP_FREE_PRE) {
		DSA_free((DSA *)*pval);
		*pval = NULL;
		return 2;
	}
	return 1;
}

static const ASN1_AUX DSAPrivateKey_aux = {
	.app_data = NULL,
	.flags = 0,
	.ref_offset = 0,
	.ref_lock = 0,
	.asn1_cb = dsa_cb,
	.enc_offset = 0,
};
static const ASN1_TEMPLATE DSAPrivateKey_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, version),
		.field_name = "version",
		.item = &LONG_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, p),
		.field_name = "p",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, q),
		.field_name = "q",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, g),
		.field_name = "g",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, pub_key),
		.field_name = "pub_key",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, priv_key),
		.field_name = "priv_key",
		.item = &BIGNUM_it,
	},
};

const ASN1_ITEM DSAPrivateKey_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = DSAPrivateKey_seq_tt,
	.tcount = sizeof(DSAPrivateKey_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &DSAPrivateKey_aux,
	.size = sizeof(DSA),
	.sname = "DSA",
};


DSA *
d2i_DSAPrivateKey(DSA **a, const unsigned char **in, long len)
{
	return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &DSAPrivateKey_it);
}

int
i2d_DSAPrivateKey(const DSA *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &DSAPrivateKey_it);
}

static const ASN1_AUX DSAparams_aux = {
	.app_data = NULL,
	.flags = 0,
	.ref_offset = 0,
	.ref_lock = 0,
	.asn1_cb = dsa_cb,
	.enc_offset = 0,
};
static const ASN1_TEMPLATE DSAparams_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, p),
		.field_name = "p",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, q),
		.field_name = "q",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, g),
		.field_name = "g",
		.item = &BIGNUM_it,
	},
};

const ASN1_ITEM DSAparams_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = DSAparams_seq_tt,
	.tcount = sizeof(DSAparams_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &DSAparams_aux,
	.size = sizeof(DSA),
	.sname = "DSA",
};


DSA *
d2i_DSAparams(DSA **a, const unsigned char **in, long len)
{
	return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &DSAparams_it);
}

int
i2d_DSAparams(const DSA *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &DSAparams_it);
}

DSA *
d2i_DSAparams_bio(BIO *bp, DSA **a)
{
	return ASN1_item_d2i_bio(&DSAparams_it, bp, a);
}

int
i2d_DSAparams_bio(BIO *bp, DSA *a)
{
	return ASN1_item_i2d_bio(&DSAparams_it, bp, a);
}

DSA *
d2i_DSAparams_fp(FILE *fp, DSA **a)
{
	return ASN1_item_d2i_fp(&DSAparams_it, fp, a);
}

int
i2d_DSAparams_fp(FILE *fp, DSA *a)
{
	return ASN1_item_i2d_fp(&DSAparams_it, fp, a);
}

/*
 * DSA public key is a bit trickier... its effectively a CHOICE type
 * decided by a field called write_params which can either write out
 * just the public key as an INTEGER or the parameters and public key
 * in a SEQUENCE
 */

static const ASN1_TEMPLATE dsa_pub_internal_seq_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, pub_key),
		.field_name = "pub_key",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, p),
		.field_name = "p",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, q),
		.field_name = "q",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, g),
		.field_name = "g",
		.item = &BIGNUM_it,
	},
};

const ASN1_ITEM dsa_pub_internal_it = {
	.itype = ASN1_ITYPE_SEQUENCE,
	.utype = V_ASN1_SEQUENCE,
	.templates = dsa_pub_internal_seq_tt,
	.tcount = sizeof(dsa_pub_internal_seq_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = NULL,
	.size = sizeof(DSA),
	.sname = "DSA",
};

static const ASN1_AUX DSAPublicKey_aux = {
	.app_data = NULL,
	.flags = 0,
	.ref_offset = 0,
	.ref_lock = 0,
	.asn1_cb = dsa_cb,
	.enc_offset = 0,
};
static const ASN1_TEMPLATE DSAPublicKey_ch_tt[] = {
	{
		.flags = 0,
		.tag = 0,
		.offset = offsetof(DSA, pub_key),
		.field_name = "pub_key",
		.item = &BIGNUM_it,
	},
	{
		.flags = 0 | ASN1_TFLG_COMBINE,
		.tag = 0,
		.offset = 0,
		.field_name = NULL,
		.item = &dsa_pub_internal_it,
	},
};

const ASN1_ITEM DSAPublicKey_it = {
	.itype = ASN1_ITYPE_CHOICE,
	.utype = offsetof(DSA, write_params),
	.templates = DSAPublicKey_ch_tt,
	.tcount = sizeof(DSAPublicKey_ch_tt) / sizeof(ASN1_TEMPLATE),
	.funcs = &DSAPublicKey_aux,
	.size = sizeof(DSA),
	.sname = "DSA",
};


DSA *
d2i_DSAPublicKey(DSA **a, const unsigned char **in, long len)
{
	return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, in, len,
	    &DSAPublicKey_it);
}

int
i2d_DSAPublicKey(const DSA *a, unsigned char **out)
{
	return ASN1_item_i2d((ASN1_VALUE *)a, out, &DSAPublicKey_it);
}

DSA *
DSAparams_dup(DSA *dsa)
{
	return ASN1_item_dup(&DSAparams_it, dsa);
}

int
DSA_sign(int type, const unsigned char *dgst, int dlen, unsigned char *sig,
    unsigned int *siglen, DSA *dsa)
{
	DSA_SIG *s;

	s = DSA_do_sign(dgst, dlen, dsa);
	if (s == NULL) {
		*siglen = 0;
		return 0;
	}
	*siglen = i2d_DSA_SIG(s,&sig);
	DSA_SIG_free(s);
	return 1;
}

/*
 * data has already been hashed (probably with SHA or SHA-1).
 * returns
 *      1: correct signature
 *      0: incorrect signature
 *     -1: error
 */
int
DSA_verify(int type, const unsigned char *dgst, int dgst_len,
    const unsigned char *sigbuf, int siglen, DSA *dsa)
{
	DSA_SIG *s;
	unsigned char *der = NULL;
	const unsigned char *p = sigbuf;
	int derlen = -1;
	int ret = -1;

	s = DSA_SIG_new();
	if (s == NULL)
		return ret;
	if (d2i_DSA_SIG(&s, &p, siglen) == NULL)
		goto err;
	/* Ensure signature uses DER and doesn't have trailing garbage */
	derlen = i2d_DSA_SIG(s, &der);
	if (derlen != siglen || memcmp(sigbuf, der, derlen))
		goto err;
	ret = DSA_do_verify(dgst, dgst_len, s, dsa);
err:
	if (derlen > 0) {
		explicit_bzero(der, derlen);
		free(der);
	}
	DSA_SIG_free(s);
	return ret;
}
@


1.18
log
@Expand ASN1_ITEM_rptr macro - no change in generated assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_asn1.c,v 1.17 2016/11/04 18:35:30 jsing Exp $ */
d76 1
a76 1
			DSAerr(DSA_F_SIG_CB, ERR_R_MALLOC_FAILURE);
@


1.17
log
@Kill a bunch of OLD_ASN1 usage by replacing ASN1_{d2i,i2d}_* with
ASN1_item_{d2i,i2d}_* equivalents.

ok guenther@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_asn1.c,v 1.16 2015/02/14 15:06:55 jsing Exp $ */
d410 1
a410 1
	return ASN1_item_dup(ASN1_ITEM_rptr(DSAparams), dsa);
@


1.16
log
@Expand ASN1_CHOICE*, ASN1_SEQUENCE* and associated macros, making the
data structures visible and easier to review, without having to wade
through layers and layers of asn1t.h macros.

Change has been scripted and there is no change to the generated assembly.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_asn1.c,v 1.15 2015/02/10 05:12:23 jsing Exp $ */
d284 24
@


1.15
log
@Expand the -IMPLEMENT_ASN1_ENCODE_FUNCTIONS_(const_)?fname macros so that
the code is visible and functions can be readily located.

Change has been scripted and there is no change to the generated assembly.

Discussed with beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_asn1.c,v 1.14 2015/01/28 04:14:31 beck Exp $ */
d87 34
a120 4
ASN1_SEQUENCE_cb(DSA_SIG, sig_cb) = {
	ASN1_SIMPLE(DSA_SIG, r, CBIGNUM),
	ASN1_SIMPLE(DSA_SIG, s, CBIGNUM)
} ASN1_SEQUENCE_END_cb(DSA_SIG, DSA_SIG)
d153 62
a214 8
ASN1_SEQUENCE_cb(DSAPrivateKey, dsa_cb) = {
	ASN1_SIMPLE(DSA, version, LONG),
	ASN1_SIMPLE(DSA, p, BIGNUM),
	ASN1_SIMPLE(DSA, q, BIGNUM),
	ASN1_SIMPLE(DSA, g, BIGNUM),
	ASN1_SIMPLE(DSA, pub_key, BIGNUM),
	ASN1_SIMPLE(DSA, priv_key, BIGNUM)
} ASN1_SEQUENCE_END_cb(DSA, DSAPrivateKey)
d230 41
a270 5
ASN1_SEQUENCE_cb(DSAparams, dsa_cb) = {
	ASN1_SIMPLE(DSA, p, BIGNUM),
	ASN1_SIMPLE(DSA, q, BIGNUM),
	ASN1_SIMPLE(DSA, g, BIGNUM),
} ASN1_SEQUENCE_END_cb(DSA, DSAparams)
d293 75
a367 11
ASN1_SEQUENCE(dsa_pub_internal) = {
	ASN1_SIMPLE(DSA, pub_key, BIGNUM),
	ASN1_SIMPLE(DSA, p, BIGNUM),
	ASN1_SIMPLE(DSA, q, BIGNUM),
	ASN1_SIMPLE(DSA, g, BIGNUM)
} ASN1_SEQUENCE_END_name(DSA, dsa_pub_internal)

ASN1_CHOICE_cb(DSAPublicKey, dsa_cb) = {
	ASN1_SIMPLE(DSA, pub_key, BIGNUM),
	ASN1_EX_COMBINE(0, 0, dsa_pub_internal)
} ASN1_CHOICE_END_cb(DSA, DSAPublicKey, write_params)
@


1.14
log
@Fix a number of issues relating to algorithms in signatures, Mostly
from OpenSSL with a hint of boring and some things done here. Addresses
CVE-2014-8275 for OpenSSL fully
ok miod@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_asn1.c,v 1.13 2014/10/18 17:20:40 jsing Exp $ */
d92 13
a104 1
IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA_SIG, DSA_SIG, DSA_SIG)
d132 13
a144 1
IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA, DSAPrivateKey, DSAPrivateKey)
d152 13
a164 1
IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA, DSAparams, DSAparams)
d185 13
a197 1
IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA, DSAPublicKey, DSAPublicKey)
@


1.13
log
@None of these need to include <openssl/rand.h>
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_asn1.c,v 1.12 2014/07/11 08:44:48 jsing Exp $ */
d60 1
d185 3
d193 5
a197 1
	if (d2i_DSA_SIG(&s, &sigbuf, siglen) == NULL)
d201 4
@


1.12
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_asn1.c,v 1.11 2014/07/09 10:16:24 miod Exp $ */
a64 1
#include <openssl/rand.h>
@


1.11
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_asn1.c,v 1.10 2014/06/12 15:49:28 deraadt Exp $ */
d60 1
a60 2
#include "cryptlib.h"
#include <openssl/dsa.h>
d63 2
@


1.10
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d67 2
a68 2
static int sig_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
d70 1
a70 1
	if(operation == ASN1_OP_NEW_PRE) {
d72 1
d74 1
a74 2
		if (!sig)
			{
d77 1
a77 1
			}
d94 2
a95 2
static int dsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
							void *exarg)
d97 1
a97 1
	if(operation == ASN1_OP_NEW_PRE) {
d99 2
a100 1
		if(*pval) return 2;
d102 1
a102 1
	} else if(operation == ASN1_OP_FREE_PRE) {
d129 2
a130 1
/* DSA public key is a bit trickier... its effectively a CHOICE type
d150 3
a152 2
DSA *DSAparams_dup(DSA *dsa)
	{
d154 1
a154 1
	}
d156 4
a159 3
int DSA_sign(int type, const unsigned char *dgst, int dlen, unsigned char *sig,
	     unsigned int *siglen, DSA *dsa)
	{
d161 7
a167 7
	s=DSA_do_sign(dgst,dlen,dsa);
	if (s == NULL)
		{
		*siglen=0;
		return(0);
		}
	*siglen=i2d_DSA_SIG(s,&sig);
d169 2
a170 2
	return(1);
	}
d172 3
a174 2
/* data has already been hashed (probably with SHA or SHA-1). */
/* returns
d179 4
a182 3
int DSA_verify(int type, const unsigned char *dgst, int dgst_len,
	     const unsigned char *sigbuf, int siglen, DSA *dsa)
	{
d184 1
a184 1
	int ret=-1;
d187 5
a191 3
	if (s == NULL) return(ret);
	if (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;
	ret=DSA_do_verify(dgst,dgst_len,s,dsa);
d194 2
a195 2
	return(ret);
	}
@


1.9
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d1 1
a1 1
/* dsa_asn1.c */
@


1.8
log
@1. RAND_seed is now DEPRECATED
2. Even passing a digest in as entropy is sloppy.

But apparently the OpenSSL guys could find no objects of lesser value to
pass to the pluggable random subsystem, and had to resort to private keys
and digests.  Classy.

ok djm
@
text
@d72 1
a72 1
		sig = OPENSSL_malloc(sizeof(DSA_SIG));
@


1.7
log
@resolve conflicts
@
text
@a156 1
	RAND_seed(dgst, dlen);
@


1.6
log
@resolve conflicts, fix local changes
@
text
@d64 1
d91 1
a91 1
IMPLEMENT_ASN1_FUNCTIONS_const(DSA_SIG)
d151 37
@


1.5
log
@resolve conflicts
@
text
@d6 1
a6 1
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
a63 5
#include <openssl/bn.h>
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

d66 2
a67 1
static int sig_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)
d72 5
d80 1
a80 3
		if(sig) return 2;
		DSAerr(DSA_F_SIG_CB, ERR_R_MALLOC_FAILURE);
		return 0;
d90 1
a90 1
IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA_SIG,DSA_SIG,DSA_SIG)
d93 2
a94 1
static int dsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)
d147 1
a147 23
int DSA_sign(int type, const unsigned char *dgst, int dlen, unsigned char *sig,
	     unsigned int *siglen, DSA *dsa)
	{
	DSA_SIG *s;
#ifdef OPENSSL_FIPS
	if(FIPS_mode() && !(dsa->flags & DSA_FLAG_NON_FIPS_ALLOW))
		{
		DSAerr(DSA_F_DSA_SIGN, DSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
		return 0;
		}
#endif
	s=DSA_do_sign(dgst,dlen,dsa);
	if (s == NULL)
		{
		*siglen=0;
		return(0);
		}
	*siglen=i2d_DSA_SIG(s,&sig);
	DSA_SIG_free(s);
	return(1);
	}

int DSA_size(const DSA *r)
d149 1
a149 18
	int ret,i;
	ASN1_INTEGER bs;
	unsigned char buf[4];	/* 4 bytes looks really small.
				   However, i2d_ASN1_INTEGER() will not look
				   beyond the first byte, as long as the second
				   parameter is NULL. */

	i=BN_num_bits(r->q);
	bs.length=(i+7)/8;
	bs.data=buf;
	bs.type=V_ASN1_INTEGER;
	/* If the top bit is set the asn1 encoding is 1 larger. */
	buf[0]=0xff;	

	i=i2d_ASN1_INTEGER(&bs,NULL);
	i+=i; /* r and s */
	ret=ASN1_object_size(1,i,V_ASN1_SEQUENCE);
	return(ret);
a150 29

/* data has already been hashed (probably with SHA or SHA-1). */
/* returns
 *      1: correct signature
 *      0: incorrect signature
 *     -1: error
 */
int DSA_verify(int type, const unsigned char *dgst, int dgst_len,
	     const unsigned char *sigbuf, int siglen, DSA *dsa)
	{
	DSA_SIG *s;
	int ret=-1;
#ifdef OPENSSL_FIPS
	if(FIPS_mode() && !(dsa->flags & DSA_FLAG_NON_FIPS_ALLOW))
		{
		DSAerr(DSA_F_DSA_VERIFY, DSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
		return 0;
		}
#endif

	s = DSA_SIG_new();
	if (s == NULL) return(ret);
	if (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;
	ret=DSA_do_verify(dgst,dgst_len,s,dsa);
err:
	DSA_SIG_free(s);
	return(ret);
	}

@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
d64 5
d91 1
a91 1
IMPLEMENT_ASN1_FUNCTIONS_const(DSA_SIG)
d146 73
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d1 57
a57 1
/* crypto/dsa/dsa_asn1.c */
d63 1
a63 1
#include <openssl/asn1_mac.h>
d65 2
a66 1
DSA_SIG *DSA_SIG_new(void)
d68 17
a84 1
	DSA_SIG *ret;
d86 1
a86 10
	ret = OPENSSL_malloc(sizeof(DSA_SIG));
	if (ret == NULL)
		{
		DSAerr(DSA_F_DSA_SIG_NEW,ERR_R_MALLOC_FAILURE);
		return(NULL);
		}
	ret->r = NULL;
	ret->s = NULL;
	return(ret);
}
d88 2
a89 1
void DSA_SIG_free(DSA_SIG *r)
d91 10
a100 4
	if (r == NULL) return;
	if (r->r) BN_clear_free(r->r);
	if (r->s) BN_clear_free(r->s);
	OPENSSL_free(r);
d103 36
a138 39
int i2d_DSA_SIG(DSA_SIG *v, unsigned char **pp)
{
	int t=0,len;
	ASN1_INTEGER rbs,sbs;
	unsigned char *p;

	rbs.data=OPENSSL_malloc(BN_num_bits(v->r)/8+1);
	if (rbs.data == NULL)
		{
		DSAerr(DSA_F_I2D_DSA_SIG, ERR_R_MALLOC_FAILURE);
		return(0);
		}
	rbs.type=V_ASN1_INTEGER;
	rbs.length=BN_bn2bin(v->r,rbs.data);
	sbs.data=OPENSSL_malloc(BN_num_bits(v->s)/8+1);
	if (sbs.data == NULL)
		{
		OPENSSL_free(rbs.data);
		DSAerr(DSA_F_I2D_DSA_SIG, ERR_R_MALLOC_FAILURE);
		return(0);
		}
	sbs.type=V_ASN1_INTEGER;
	sbs.length=BN_bn2bin(v->s,sbs.data);

	len=i2d_ASN1_INTEGER(&rbs,NULL);
	len+=i2d_ASN1_INTEGER(&sbs,NULL);

	if (pp)
		{
		p=*pp;
		ASN1_put_object(&p,1,len,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);
		i2d_ASN1_INTEGER(&rbs,&p);
		i2d_ASN1_INTEGER(&sbs,&p);
		}
	t=ASN1_object_size(1,len,V_ASN1_SEQUENCE);
	OPENSSL_free(rbs.data);
	OPENSSL_free(sbs.data);
	return(t);
}
d140 1
a140 25
DSA_SIG *d2i_DSA_SIG(DSA_SIG **a, unsigned char **pp, long length)
{
	int i=ERR_R_NESTED_ASN1_ERROR;
	ASN1_INTEGER *bs=NULL;
	M_ASN1_D2I_vars(a,DSA_SIG *,DSA_SIG_new);

	M_ASN1_D2I_Init();
	M_ASN1_D2I_start_sequence();
	M_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);
	if ((ret->r=BN_bin2bn(bs->data,bs->length,ret->r)) == NULL)
		goto err_bn;
	M_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);
	if ((ret->s=BN_bin2bn(bs->data,bs->length,ret->s)) == NULL)
		goto err_bn;
	M_ASN1_BIT_STRING_free(bs);
	M_ASN1_D2I_Finish_2(a);

err_bn:
	i=ERR_R_BN_LIB;
err:
	DSAerr(DSA_F_D2I_DSA_SIG,i);
	if ((ret != NULL) && ((a == NULL) || (*a != ret))) DSA_SIG_free(ret);
	if (bs != NULL) M_ASN1_BIT_STRING_free(bs);
	return(NULL);
}
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d13 1
a13 1
	ret = Malloc(sizeof(DSA_SIG));
d29 1
a29 1
	Free(r);
d38 1
a38 1
	rbs.data=Malloc(BN_num_bits(v->r)/8+1);
d46 1
a46 1
	sbs.data=Malloc(BN_num_bits(v->s)/8+1);
d49 1
a49 1
		Free(rbs.data);
d67 2
a68 2
	Free(rbs.data);
	Free(sbs.data);
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d86 1
a86 1
	ASN1_BIT_STRING_free(bs);
d94 1
a94 1
	if (bs != NULL) ASN1_BIT_STRING_free(bs);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 57
/* dsa_asn1.c */
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d7 1
a7 1
#include <openssl/asn1t.h>
d9 1
a9 2
/* Override the default new methods */
static int sig_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)
d11 11
a21 11
	if(operation == ASN1_OP_NEW_PRE) {
		DSA_SIG *sig;
		sig = OPENSSL_malloc(sizeof(DSA_SIG));
		sig->r = NULL;
		sig->s = NULL;
		*pval = (ASN1_VALUE *)sig;
		if(sig) return 2;
		DSAerr(DSA_F_SIG_CB, ERR_R_MALLOC_FAILURE);
		return 0;
	}
	return 1;
d24 7
a30 4
ASN1_SEQUENCE_cb(DSA_SIG, sig_cb) = {
	ASN1_SIMPLE(DSA_SIG, r, CBIGNUM),
	ASN1_SIMPLE(DSA_SIG, s, CBIGNUM)
} ASN1_SEQUENCE_END_cb(DSA_SIG, DSA_SIG)
d32 39
a70 1
IMPLEMENT_ASN1_FUNCTIONS_const(DSA_SIG)
d72 1
a72 2
/* Override the default free and new methods */
static int dsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)
d74 22
a95 10
	if(operation == ASN1_OP_NEW_PRE) {
		*pval = (ASN1_VALUE *)DSA_new();
		if(*pval) return 2;
		return 0;
	} else if(operation == ASN1_OP_FREE_PRE) {
		DSA_free((DSA *)*pval);
		*pval = NULL;
		return 2;
	}
	return 1;
a96 39

ASN1_SEQUENCE_cb(DSAPrivateKey, dsa_cb) = {
	ASN1_SIMPLE(DSA, version, LONG),
	ASN1_SIMPLE(DSA, p, BIGNUM),
	ASN1_SIMPLE(DSA, q, BIGNUM),
	ASN1_SIMPLE(DSA, g, BIGNUM),
	ASN1_SIMPLE(DSA, pub_key, BIGNUM),
	ASN1_SIMPLE(DSA, priv_key, BIGNUM)
} ASN1_SEQUENCE_END_cb(DSA, DSAPrivateKey)

IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA, DSAPrivateKey, DSAPrivateKey)

ASN1_SEQUENCE_cb(DSAparams, dsa_cb) = {
	ASN1_SIMPLE(DSA, p, BIGNUM),
	ASN1_SIMPLE(DSA, q, BIGNUM),
	ASN1_SIMPLE(DSA, g, BIGNUM),
} ASN1_SEQUENCE_END_cb(DSA, DSAparams)

IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA, DSAparams, DSAparams)

/* DSA public key is a bit trickier... its effectively a CHOICE type
 * decided by a field called write_params which can either write out
 * just the public key as an INTEGER or the parameters and public key
 * in a SEQUENCE
 */

ASN1_SEQUENCE(dsa_pub_internal) = {
	ASN1_SIMPLE(DSA, pub_key, BIGNUM),
	ASN1_SIMPLE(DSA, p, BIGNUM),
	ASN1_SIMPLE(DSA, q, BIGNUM),
	ASN1_SIMPLE(DSA, g, BIGNUM)
} ASN1_SEQUENCE_END_name(DSA, dsa_pub_internal)

ASN1_CHOICE_cb(DSAPublicKey, dsa_cb) = {
	ASN1_SIMPLE(DSA, pub_key, BIGNUM),
	ASN1_EX_COMBINE(0, 0, dsa_pub_internal)
} ASN1_CHOICE_END_cb(DSA, DSAPublicKey, write_params)

IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA, DSAPublicKey, DSAPublicKey)
@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
a63 5
#include <openssl/bn.h>
#ifdef OPENSSL_FIPS
#include <openssl/fips.h>
#endif

d86 1
a86 1
IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA_SIG,DSA_SIG,DSA_SIG)
a140 73

int DSA_sign(int type, const unsigned char *dgst, int dlen, unsigned char *sig,
	     unsigned int *siglen, DSA *dsa)
	{
	DSA_SIG *s;
#ifdef OPENSSL_FIPS
	if(FIPS_mode() && !(dsa->flags & DSA_FLAG_NON_FIPS_ALLOW))
		{
		DSAerr(DSA_F_DSA_SIGN, DSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
		return 0;
		}
#endif
	s=DSA_do_sign(dgst,dlen,dsa);
	if (s == NULL)
		{
		*siglen=0;
		return(0);
		}
	*siglen=i2d_DSA_SIG(s,&sig);
	DSA_SIG_free(s);
	return(1);
	}

int DSA_size(const DSA *r)
	{
	int ret,i;
	ASN1_INTEGER bs;
	unsigned char buf[4];	/* 4 bytes looks really small.
				   However, i2d_ASN1_INTEGER() will not look
				   beyond the first byte, as long as the second
				   parameter is NULL. */

	i=BN_num_bits(r->q);
	bs.length=(i+7)/8;
	bs.data=buf;
	bs.type=V_ASN1_INTEGER;
	/* If the top bit is set the asn1 encoding is 1 larger. */
	buf[0]=0xff;	

	i=i2d_ASN1_INTEGER(&bs,NULL);
	i+=i; /* r and s */
	ret=ASN1_object_size(1,i,V_ASN1_SEQUENCE);
	return(ret);
	}

/* data has already been hashed (probably with SHA or SHA-1). */
/* returns
 *      1: correct signature
 *      0: incorrect signature
 *     -1: error
 */
int DSA_verify(int type, const unsigned char *dgst, int dgst_len,
	     const unsigned char *sigbuf, int siglen, DSA *dsa)
	{
	DSA_SIG *s;
	int ret=-1;
#ifdef OPENSSL_FIPS
	if(FIPS_mode() && !(dsa->flags & DSA_FLAG_NON_FIPS_ALLOW))
		{
		DSAerr(DSA_F_DSA_VERIFY, DSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
		return 0;
		}
#endif

	s = DSA_SIG_new();
	if (s == NULL) return(ret);
	if (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;
	ret=DSA_do_verify(dgst,dgst_len,s,dsa);
err:
	DSA_SIG_free(s);
	return(ret);
	}

@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d6 1
a6 1
 * Copyright (c) 2000-2005 The OpenSSL Project.  All rights reserved.
d64 5
d71 1
a71 2
static int sig_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
								void *exarg)
a75 5
		if (!sig)
			{
			DSAerr(DSA_F_SIG_CB, ERR_R_MALLOC_FAILURE);
			return 0;
			}
d79 3
a81 1
		return 2;
d91 1
a91 1
IMPLEMENT_ASN1_FUNCTIONS_const(DSA_SIG)
d94 1
a94 2
static int dsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
							void *exarg)
d147 23
a169 1
DSA *DSAparams_dup(DSA *dsa)
d171 18
a188 1
	return ASN1_item_dup(ASN1_ITEM_rptr(DSAparams), dsa);
d190 29
@


1.1.1.4
log
@import OpenSSL-1.0.1c
@
text
@a63 1
#include <openssl/rand.h>
d90 1
a90 1
IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA_SIG, DSA_SIG, DSA_SIG)
a149 37
	}

int DSA_sign(int type, const unsigned char *dgst, int dlen, unsigned char *sig,
	     unsigned int *siglen, DSA *dsa)
	{
	DSA_SIG *s;
	RAND_seed(dgst, dlen);
	s=DSA_do_sign(dgst,dlen,dsa);
	if (s == NULL)
		{
		*siglen=0;
		return(0);
		}
	*siglen=i2d_DSA_SIG(s,&sig);
	DSA_SIG_free(s);
	return(1);
	}

/* data has already been hashed (probably with SHA or SHA-1). */
/* returns
 *      1: correct signature
 *      0: incorrect signature
 *     -1: error
 */
int DSA_verify(int type, const unsigned char *dgst, int dgst_len,
	     const unsigned char *sigbuf, int siglen, DSA *dsa)
	{
	DSA_SIG *s;
	int ret=-1;

	s = DSA_SIG_new();
	if (s == NULL) return(ret);
	if (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;
	ret=DSA_do_verify(dgst,dgst_len,s,dsa);
err:
	DSA_SIG_free(s);
	return(ret);
@


