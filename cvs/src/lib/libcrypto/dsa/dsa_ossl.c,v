head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.2
	OPENBSD_6_1_BASE:1.30;
locks; strict;
comment	@ * @;


1.30
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.29;
commitid	kT0fLt3r4lroFJra;

1.29
date	2017.01.21.11.00.46;	author beck;	state Exp;
branches;
next	1.28;
commitid	gA67INk6WgIKVogS;

1.28
date	2017.01.21.10.38.29;	author beck;	state Exp;
branches;
next	1.27;
commitid	hKAfCRL9IRQ9ENaK;

1.27
date	2017.01.21.09.38.59;	author beck;	state Exp;
branches;
next	1.26;
commitid	iyR9b2itDMsxzmrQ;

1.26
date	2016.06.21.04.16.53;	author bcook;	state Exp;
branches;
next	1.25;
commitid	46oO02MQm5wkkTK0;

1.25
date	2016.06.06.23.37.37;	author tedu;	state Exp;
branches;
next	1.24;
commitid	V9P3aECL1h6JX75q;

1.24
date	2016.06.06.10.00.04;	author beck;	state Exp;
branches;
next	1.23;
commitid	rNZsnwX4Be9QvFKQ;

1.23
date	2015.09.10.07.58.28;	author bcook;	state Exp;
branches
	1.23.2.1;
next	1.22;
commitid	9xkwiKpIDJjakxYp;

1.22
date	2014.10.18.17.20.40;	author jsing;	state Exp;
branches
	1.22.6.1;
next	1.21;
commitid	8tb4v3IC8S2vzfHj;

1.21
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.20;
commitid	G74O1dmRukKsW7IJ;

1.20
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.19;
commitid	yQEL1wOWIearrW15;

1.19
date	2014.07.09.10.16.24;	author miod;	state Exp;
branches;
next	1.18;
commitid	7IVFdVxu6X3GaaT8;

1.18
date	2014.06.27.06.07.35;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	d2qNpuBRGDFtF1vS;

1.17
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	mJUVYpkFBZ0Zv2bG;

1.16
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.09.12.15.43;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.04.07.10.32;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2005.04.29.05.39.20;	author djm;	state Exp;
branches
	1.8.2.1
	1.8.4.1;
next	1.7;

1.7
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.12;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.23.07.46.00;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.57.31;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.10.07;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.16;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.05;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.08;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.06.27.05.05.32;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.42;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.01.09.12.13.55;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2011.11.03.02.32.10;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.39;	author djm;	state Exp;
branches;
next	;

1.8.2.1
date	2006.10.05.18.42.22;	author brad;	state Exp;
branches;
next	;

1.8.4.1
date	2006.10.05.17.36.24;	author brad;	state Exp;
branches;
next	;

1.9.2.1
date	2006.11.02.19.56.23;	author brad;	state Exp;
branches;
next	;

1.22.6.1
date	2016.06.06.10.00.50;	author beck;	state Exp;
branches;
next	1.22.6.2;
commitid	SBSNmpqeD6IM3muj;

1.22.6.2
date	2016.06.06.23.39.52;	author tedu;	state Exp;
branches;
next	;
commitid	pZPJ2f3DuJZZIPKW;

1.23.2.1
date	2016.06.06.10.01.17;	author beck;	state Exp;
branches;
next	1.23.2.2;
commitid	LIhOgrMzlaF1jU2O;

1.23.2.2
date	2016.06.06.23.39.23;	author tedu;	state Exp;
branches;
next	;
commitid	i1GKvZEojUj8A62W;


desc
@@


1.30
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: dsa_ossl.c,v 1.29 2017/01/21 11:00:46 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/* Original version from Steven Schoch <schoch@@sheba.arc.nasa.gov> */

#include <stdio.h>

#include <openssl/asn1.h>
#include <openssl/bn.h>
#include <openssl/dsa.h>
#include <openssl/err.h>
#include <openssl/sha.h>

#include "bn_lcl.h"

static DSA_SIG *dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa);
static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,
	    BIGNUM **rp);
static int dsa_do_verify(const unsigned char *dgst, int dgst_len, DSA_SIG *sig,
	    DSA *dsa);
static int dsa_init(DSA *dsa);
static int dsa_finish(DSA *dsa);

static DSA_METHOD openssl_dsa_meth = {
	.name = "OpenSSL DSA method",
	.dsa_do_sign = dsa_do_sign,
	.dsa_sign_setup = dsa_sign_setup,
	.dsa_do_verify = dsa_do_verify,
	.init = dsa_init,
	.finish = dsa_finish
};

const DSA_METHOD *
DSA_OpenSSL(void)
{
	return &openssl_dsa_meth;
}

static DSA_SIG *
dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)
{
	BIGNUM *kinv = NULL, *r = NULL, *s = NULL;
	BIGNUM m;
	BIGNUM xr;
	BN_CTX *ctx = NULL;
	int reason = ERR_R_BN_LIB;
	DSA_SIG *ret = NULL;
	int noredo = 0;

	BN_init(&m);
	BN_init(&xr);

	if (!dsa->p || !dsa->q || !dsa->g) {
		reason = DSA_R_MISSING_PARAMETERS;
		goto err;
	}

	s = BN_new();
	if (s == NULL)
		goto err;
	ctx = BN_CTX_new();
	if (ctx == NULL)
		goto err;
redo:
	if (dsa->kinv == NULL || dsa->r == NULL) {
		if (!DSA_sign_setup(dsa, ctx, &kinv, &r))
			goto err;
	} else {
		kinv = dsa->kinv;
		dsa->kinv = NULL;
		r = dsa->r;
		dsa->r = NULL;
		noredo = 1;
	}

	
	/*
	 * If the digest length is greater than the size of q use the
	 * BN_num_bits(dsa->q) leftmost bits of the digest, see
	 * fips 186-3, 4.2
	 */
	if (dlen > BN_num_bytes(dsa->q))
		dlen = BN_num_bytes(dsa->q);
	if (BN_bin2bn(dgst,dlen,&m) == NULL)
		goto err;

	/* Compute  s = inv(k) (m + xr) mod q */
	if (!BN_mod_mul(&xr, dsa->priv_key, r, dsa->q, ctx))	/* s = xr */
		goto err;
	if (!BN_add(s, &xr, &m))				/* s = m + xr */
		goto err;
	if (BN_cmp(s, dsa->q) > 0)
		if (!BN_sub(s, s, dsa->q))
			goto err;
	if (!BN_mod_mul(s, s, kinv, dsa->q, ctx))
		goto err;

	ret = DSA_SIG_new();
	if (ret == NULL)
		goto err;
	/*
	 * Redo if r or s is zero as required by FIPS 186-3: this is
	 * very unlikely.
	 */
	if (BN_is_zero(r) || BN_is_zero(s)) {
		if (noredo) {
			reason = DSA_R_NEED_NEW_SETUP_VALUES;
			goto err;
		}
		goto redo;
	}
	ret->r = r;
	ret->s = s;
	
err:
	if (!ret) {
		DSAerror(reason);
		BN_free(r);
		BN_free(s);
	}
	BN_CTX_free(ctx);
	BN_clear_free(&m);
	BN_clear_free(&xr);
	BN_clear_free(kinv);
	return ret;
}

static int
dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp)
{
	BN_CTX *ctx;
	BIGNUM k, *kinv = NULL, *r = NULL;
	int ret = 0;

	if (!dsa->p || !dsa->q || !dsa->g) {
		DSAerror(DSA_R_MISSING_PARAMETERS);
		return 0;
	}

	BN_init(&k);

	if (ctx_in == NULL) {
		if ((ctx = BN_CTX_new()) == NULL)
			goto err;
	} else
		ctx = ctx_in;

	if ((r = BN_new()) == NULL)
		goto err;

	/* Get random k */
	do {
		if (!BN_rand_range(&k, dsa->q))
			goto err;
	} while (BN_is_zero(&k));

	BN_set_flags(&k, BN_FLG_CONSTTIME);

	if (dsa->flags & DSA_FLAG_CACHE_MONT_P) {
		if (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,
		    CRYPTO_LOCK_DSA, dsa->p, ctx))
			goto err;
	}

	/* Compute r = (g^k mod p) mod q */

	/*
	 * We do not want timing information to leak the length of k,
	 * so we compute g^k using an equivalent exponent of fixed
	 * length.
	 *
	 * (This is a kludge that we need because the BN_mod_exp_mont()
	 * does not let us specify the desired timing behaviour.)
	 */

	if (!BN_add(&k, &k, dsa->q))
		goto err;
	if (BN_num_bits(&k) <= BN_num_bits(dsa->q)) {
		if (!BN_add(&k, &k, dsa->q))
			goto err;
	}

	if (dsa->meth->bn_mod_exp != NULL) {
		if (!dsa->meth->bn_mod_exp(dsa, r, dsa->g, &k, dsa->p, ctx,
					dsa->method_mont_p))
			goto err;
	} else {
		if (!BN_mod_exp_mont_ct(r, dsa->g, &k, dsa->p, ctx, dsa->method_mont_p))
			goto err;
	}

	if (!BN_mod_ct(r,r,dsa->q,ctx))
		goto err;

	/* Compute  part of 's = inv(k) (m + xr) mod q' */
	if ((kinv = BN_mod_inverse_ct(NULL, &k, dsa->q, ctx)) == NULL)
		goto err;

	BN_clear_free(*kinvp);
	*kinvp = kinv;
	kinv = NULL;
	BN_clear_free(*rp);
	*rp = r;
	ret = 1;
err:
	if (!ret) {
		DSAerror(ERR_R_BN_LIB);
		BN_clear_free(r);
	}
	if (ctx_in == NULL)
		BN_CTX_free(ctx);
	BN_clear_free(&k);
	return ret;
}

static int
dsa_do_verify(const unsigned char *dgst, int dgst_len, DSA_SIG *sig, DSA *dsa)
{
	BN_CTX *ctx;
	BIGNUM u1, u2, t1;
	BN_MONT_CTX *mont = NULL;
	int ret = -1, i;

	if (!dsa->p || !dsa->q || !dsa->g) {
		DSAerror(DSA_R_MISSING_PARAMETERS);
		return -1;
	}

	i = BN_num_bits(dsa->q);
	/* fips 186-3 allows only different sizes for q */
	if (i != 160 && i != 224 && i != 256) {
		DSAerror(DSA_R_BAD_Q_VALUE);
		return -1;
	}

	if (BN_num_bits(dsa->p) > OPENSSL_DSA_MAX_MODULUS_BITS) {
		DSAerror(DSA_R_MODULUS_TOO_LARGE);
		return -1;
	}
	BN_init(&u1);
	BN_init(&u2);
	BN_init(&t1);

	if ((ctx = BN_CTX_new()) == NULL)
		goto err;

	if (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||
	    BN_ucmp(sig->r, dsa->q) >= 0) {
		ret = 0;
		goto err;
	}
	if (BN_is_zero(sig->s) || BN_is_negative(sig->s) ||
	    BN_ucmp(sig->s, dsa->q) >= 0) {
		ret = 0;
		goto err;
	}

	/* Calculate W = inv(S) mod Q
	 * save W in u2 */
	if ((BN_mod_inverse_ct(&u2, sig->s, dsa->q, ctx)) == NULL)
		goto err;

	/* save M in u1 */
	/*
	 * If the digest length is greater than the size of q use the
	 * BN_num_bits(dsa->q) leftmost bits of the digest, see
	 * fips 186-3, 4.2
	 */
	if (dgst_len > (i >> 3))
		dgst_len = (i >> 3);
	if (BN_bin2bn(dgst, dgst_len, &u1) == NULL)
		goto err;

	/* u1 = M * w mod q */
	if (!BN_mod_mul(&u1, &u1, &u2, dsa->q, ctx))
		goto err;

	/* u2 = r * w mod q */
	if (!BN_mod_mul(&u2, sig->r, &u2, dsa->q, ctx))
		goto err;


	if (dsa->flags & DSA_FLAG_CACHE_MONT_P) {
		mont = BN_MONT_CTX_set_locked(&dsa->method_mont_p,
		    CRYPTO_LOCK_DSA, dsa->p, ctx);
		if (!mont)
			goto err;
	}

	if (dsa->meth->dsa_mod_exp != NULL) {
		if (!dsa->meth->dsa_mod_exp(dsa, &t1, dsa->g, &u1, dsa->pub_key, &u2,
						dsa->p, ctx, mont))
			goto err;
	} else {
		if (!BN_mod_exp2_mont(&t1, dsa->g, &u1, dsa->pub_key, &u2, dsa->p, ctx,
						mont))
			goto err;
	}

	/* BN_copy(&u1,&t1); */
	/* let u1 = u1 mod q */
	if (!BN_mod_ct(&u1, &t1, dsa->q, ctx))
		goto err;

	/* V is now in u1.  If the signature is correct, it will be
	 * equal to R. */
	ret = BN_ucmp(&u1, sig->r) == 0;

err:
	if (ret < 0)
		DSAerror(ERR_R_BN_LIB);
	BN_CTX_free(ctx);
	BN_free(&u1);
	BN_free(&u2);
	BN_free(&t1);
	return ret;
}

static int
dsa_init(DSA *dsa)
{
	dsa->flags |= DSA_FLAG_CACHE_MONT_P;
	return 1;
}

static int
dsa_finish(DSA *dsa)
{
	BN_MONT_CTX_free(dsa->method_mont_p);
	return 1;
}

@


1.29
log
@Add ct and nonct versions of BN_mod_inverse for internal use
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.28 2017/01/21 10:38:29 beck Exp $ */
d172 1
a172 1
		DSAerr(DSA_F_DSA_DO_SIGN, reason);
d191 1
a191 1
		DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);
d262 1
a262 1
		DSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);
d280 1
a280 1
		DSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_MISSING_PARAMETERS);
d287 1
a287 1
		DSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_BAD_Q_VALUE);
d292 1
a292 1
		DSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_MODULUS_TOO_LARGE);
d366 1
a366 1
		DSAerr(DSA_F_DSA_DO_VERIFY, ERR_R_BN_LIB);
@


1.28
log
@Split out BN_div and BN_mod into ct and nonct versions for Internal use.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.27 2017/01/21 09:38:59 beck Exp $ */
d251 1
a251 1
	if ((kinv = BN_mod_inverse(NULL, &k, dsa->q, ctx)) == NULL)
d315 1
a315 1
	if ((BN_mod_inverse(&u2, sig->s, dsa->q, ctx)) == NULL)
@


1.27
log
@Make explicit _ct and _nonct versions of bn_mod_exp funcitons that
matter for constant time, and make the public interface only used
external to the library.

This moves us to a model where the important things are constant time
versions unless you ask for them not to be, rather than the opposite.
I'll continue with this method by method.

Add regress tests for same.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.26 2016/06/21 04:16:53 bcook Exp $ */
d247 1
a247 1
	if (!BN_mod(r,r,dsa->q,ctx))
d354 1
a354 1
		
d357 1
a357 1
	if (!BN_mod(&u1, &t1, dsa->q, ctx))
@


1.26
log
@Disable DSA_FLAG_NO_EXP_CONSTTIME, always enable constant-time behavior.

Improved patch from Cesar Pereida. See
https://github.com/libressl-portable/openbsd/pull/61 for more details.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.25 2016/06/06 23:37:37 tedu Exp $ */
d69 2
d243 1
a243 1
		if (!BN_mod_exp_mont(r, dsa->g, &k, dsa->p, ctx, dsa->method_mont_p))
@


1.25
log
@Set BN_FLG_CONSTTIME on the correct variable. beck committed wrong fix.
Mistake noted by Billy Brumley. Many thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.24 2016/06/06 10:00:04 beck Exp $ */
a85 40
/*
 * These macro wrappers replace attempts to use the dsa_mod_exp() and
 * bn_mod_exp() handlers in the DSA_METHOD structure. We avoid the problem of
 * having a the macro work as an expression by bundling an "err_instr". So;
 * 
 *     if (!dsa->meth->bn_mod_exp(dsa, r,dsa->g,&k,dsa->p,ctx,
 *                 dsa->method_mont_p)) goto err;
 *
 * can be replaced by;
 *
 *     DSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, &k, dsa->p, ctx,
 *                 dsa->method_mont_p);
 */

#define DSA_MOD_EXP(err_instr,dsa,rr,a1,p1,a2,p2,m,ctx,in_mont) \
do { \
	int _tmp_res53; \
	if ((dsa)->meth->dsa_mod_exp) \
		_tmp_res53 = (dsa)->meth->dsa_mod_exp((dsa), (rr), \
		    (a1), (p1), (a2), (p2), (m), (ctx), (in_mont)); \
	else \
		_tmp_res53 = BN_mod_exp2_mont((rr), (a1), \
		    (p1), (a2), (p2), (m), (ctx), (in_mont)); \
	if (!_tmp_res53) \
		err_instr; \
} while(0)

#define DSA_BN_MOD_EXP(err_instr,dsa,r,a,p,m,ctx,m_ctx) \
do { \
	int _tmp_res53; \
	if ((dsa)->meth->bn_mod_exp) \
		_tmp_res53 = (dsa)->meth->bn_mod_exp((dsa), (r), \
		    (a), (p), (m), (ctx), (m_ctx)); \
	else \
		_tmp_res53 = BN_mod_exp_mont((r), (a), (p), (m), \
		    (ctx), (m_ctx)); \
	if (!_tmp_res53) \
		err_instr; \
} while(0)

d185 1
a185 1
	BIGNUM k, kq, *K, *kinv = NULL, *r = NULL;
a193 1
	BN_init(&kq);
d210 2
d220 13
a232 2
	if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {
		if (!BN_copy(&kq, &k))
d234 1
d236 4
a239 17
		/*
		 * We do not want timing information to leak the length of k,
		 * so we compute g^k using an equivalent exponent of fixed
		 * length.
		 *
		 * (This is a kludge that we need because the BN_mod_exp_mont()
		 * does not let us specify the desired timing behaviour.)
		 */

		if (!BN_add(&kq, &kq, dsa->q))
			goto err;
		if (BN_num_bits(&kq) <= BN_num_bits(dsa->q)) {
			if (!BN_add(&kq, &kq, dsa->q))
				goto err;
		}

		K = &kq;
d241 2
a242 1
		K = &k;
a244 6
	if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {
		BN_set_flags(K, BN_FLG_CONSTTIME);
	}

	DSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, K, dsa->p, ctx,
	    dsa->method_mont_p);
a265 1
	BN_clear_free(&kq);
d343 10
a352 2
	DSA_MOD_EXP(goto err, dsa, &t1, dsa->g, &u1, dsa->pub_key, &u2, dsa->p,
	    ctx, mont);
@


1.24
log
@Correct a problem that prevents the DSA signing algorithm from running
in constant time even if the flag BN_FLG_CONSTTIME is set. This issue
was reported by Cesar Pereida (Aalto University), Billy Brumley
(Tampere University of Technology), and Yuval Yarom (The University of
Adelaide and NICTA). The fix was developed by Cesar Pereida.
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.23 2015/09/10 07:58:28 bcook Exp $ */
d285 1
a285 1
		BN_set_flags(&k, BN_FLG_CONSTTIME);
@


1.23
log
@Fix an incorrect error check in DSA verify.

From Matt Caswell's OpenSSL commit "RT3192: spurious error in DSA verify".

https://github.com/openssl/openssl/commit/eb63bce040d1cc6147d256f516b59552c018e29b
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.22 2014/10/18 17:20:40 jsing Exp $ */
a249 3
	if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {
		BN_set_flags(&k, BN_FLG_CONSTTIME);
	}
d283 5
@


1.23.2.1
log
@Correct a problem that prevents the DSA signing algorithm from running
in constant time even if the flag BN_FLG_CONSTTIME is set. This issue
was reported by Cesar Pereida (Aalto University), Billy Brumley
(Tampere University of Technology), and Yuval Yarom (The University of
Adelaide and NICTA). The fix was developed by Cesar Pereida
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.23 2015/09/10 07:58:28 bcook Exp $ */
d250 3
a285 5

	if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {
		BN_set_flags(&k, BN_FLG_CONSTTIME);
	}

@


1.23.2.2
log
@Set BN_FLG_CONSTTIME on the correct variable. beck committed wrong fix.
Mistake noted by Billy Brumley. Many thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.23.2.1 2016/06/06 10:01:17 beck Exp $ */
d285 1
a285 1
		BN_set_flags(K, BN_FLG_CONSTTIME);
@


1.22
log
@None of these need to include <openssl/rand.h>
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.21 2014/07/12 16:03:37 miod Exp $ */
d399 1
a399 3
	/* XXX: surely this is wrong - if ret is 0, it just didn't verify;
	   there is no error in BN. Test should be ret == -1 (Ben) */
	if (ret != 1)
@


1.22.6.1
log
@Correct a problem that prevents the DSA signing algorithm from running
in constant time even if the flag BN_FLG_CONSTTIME is set. This issue
was reported by Cesar Pereida (Aalto University), Billy Brumley
(Tampere University of Technology), and Yuval Yarom (The University of
Adelaide and NICTA). The fix was developed by Cesar Pereida
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.22 2014/10/18 17:20:40 jsing Exp $ */
d250 3
a285 5

	if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {
		BN_set_flags(&k, BN_FLG_CONSTTIME);
	}

@


1.22.6.2
log
@Set BN_FLG_CONSTTIME on the correct variable. beck committed wrong fix.
Mistake noted by Billy Brumley. Many thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.22.6.1 2016/06/06 10:00:50 beck Exp $ */
d285 1
a285 1
		BN_set_flags(K, BN_FLG_CONSTTIME);
@


1.21
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.20 2014/07/11 08:44:48 jsing Exp $ */
a66 1
#include <openssl/rand.h>
@


1.20
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.19 2014/07/09 10:16:24 miod Exp $ */
d215 1
a215 2
	if (ctx != NULL)
		BN_CTX_free(ctx);
d218 1
a218 2
	if (kinv != NULL) /* dsa->kinv is NULL now if we used it */
	    BN_clear_free(kinv);
d296 1
a296 2
	if (*kinvp != NULL)
		BN_clear_free(*kinvp);
d299 1
a299 2
	if (*rp != NULL)
		BN_clear_free(*rp);
d305 1
a305 2
		if (r != NULL)
			BN_clear_free(r);
d404 1
a404 2
	if (ctx != NULL)
		BN_CTX_free(ctx);
d421 1
a421 2
	if (dsa->method_mont_p)
		BN_MONT_CTX_free(dsa->method_mont_p);
@


1.19
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.18 2014/06/27 06:07:35 deraadt Exp $ */
d62 2
a63 1
#include "cryptlib.h"
a64 1
#include <openssl/sha.h>
d66 1
d68 1
a68 1
#include <openssl/asn1.h>
@


1.18
log
@hand-KNF macro the do { } while loops
@
text
@d1 1
a1 1
/* $OpenBSD: dsa_ossl.c,v 1.17 2014/06/12 15:49:28 deraadt Exp $ */
d70 2
a71 1
static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp);
d73 1
a73 1
			 DSA *dsa);
d86 2
a87 1
/* These macro wrappers replace attempts to use the dsa_mod_exp() and
d101 11
a111 11
	do { \
		int _tmp_res53; \
		if((dsa)->meth->dsa_mod_exp) \
			_tmp_res53 = (dsa)->meth->dsa_mod_exp((dsa), (rr), \
			    (a1), (p1), (a2), (p2), (m), (ctx), (in_mont)); \
		else \
			_tmp_res53 = BN_mod_exp2_mont((rr), (a1), \
			    (p1), (a2), (p2), (m), (ctx), (in_mont)); \
		if(!_tmp_res53) \
			err_instr; \
	} while(0)
d114 11
a124 11
	do { \
		int _tmp_res53; \
		if((dsa)->meth->bn_mod_exp) \
			_tmp_res53 = (dsa)->meth->bn_mod_exp((dsa), (r), \
			    (a), (p), (m), (ctx), (m_ctx)); \
		else \
			_tmp_res53 = BN_mod_exp_mont((r), (a), (p), (m), \
			    (ctx), (m_ctx)); \
		if(!_tmp_res53) \
			err_instr; \
	} while(0)
d126 2
a127 1
const DSA_METHOD *DSA_OpenSSL(void)
d132 4
a135 3
static DSA_SIG *dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)
	{
	BIGNUM *kinv=NULL,*r=NULL,*s=NULL;
d138 3
a140 3
	BN_CTX *ctx=NULL;
	int reason=ERR_R_BN_LIB;
	DSA_SIG *ret=NULL;
d146 2
a147 3
	if (!dsa->p || !dsa->q || !dsa->g)
		{
		reason=DSA_R_MISSING_PARAMETERS;
d149 1
a149 1
		}
d151 6
a156 4
	s=BN_new();
	if (s == NULL) goto err;
	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;
d158 8
a165 10
	if ((dsa->kinv == NULL) || (dsa->r == NULL))
		{
		if (!DSA_sign_setup(dsa,ctx,&kinv,&r)) goto err;
		}
	else
		{
		kinv=dsa->kinv;
		dsa->kinv=NULL;
		r=dsa->r;
		dsa->r=NULL;
d167 1
a167 1
		}
d170 5
a175 3
		/* if the digest length is greater than the size of q use the
		 * BN_num_bits(dsa->q) leftmost bits of the digest, see
		 * fips 186-3, 4.2 */
d181 15
a195 9
	if (!BN_mod_mul(&xr,dsa->priv_key,r,dsa->q,ctx)) goto err;/* s = xr */
	if (!BN_add(s, &xr, &m)) goto err;		/* s = m + xr */
	if (BN_cmp(s,dsa->q) > 0)
		if (!BN_sub(s,s,dsa->q)) goto err;
	if (!BN_mod_mul(s,s,kinv,dsa->q,ctx)) goto err;

	ret=DSA_SIG_new();
	if (ret == NULL) goto err;
	/* Redo if r or s is zero as required by FIPS 186-3: this is
d198 2
a199 4
	if (BN_is_zero(r) || BN_is_zero(s))
		{
		if (noredo)
			{
d202 1
a202 1
			}
d204 1
a204 1
		}
d209 2
a210 3
	if (!ret)
		{
		DSAerr(DSA_F_DSA_DO_SIGN,reason);
d213 3
a215 2
		}
	if (ctx != NULL) BN_CTX_free(ctx);
d220 2
a221 2
	return(ret);
	}
d223 3
a225 2
static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp)
	{
d227 2
a228 2
	BIGNUM k,kq,*K,*kinv=NULL,*r=NULL;
	int ret=0;
d230 2
a231 3
	if (!dsa->p || !dsa->q || !dsa->g)
		{
		DSAerr(DSA_F_DSA_SIGN_SETUP,DSA_R_MISSING_PARAMETERS);
d233 1
a233 1
		}
d238 5
a242 6
	if (ctx_in == NULL)
		{
		if ((ctx=BN_CTX_new()) == NULL) goto err;
		}
	else
		ctx=ctx_in;
d244 2
a245 1
	if ((r=BN_new()) == NULL) goto err;
d248 5
a252 5
	do
		if (!BN_rand_range(&k, dsa->q)) goto err;
	while (BN_is_zero(&k));
	if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0)
		{
d254 1
a254 1
		}
d256 1
a256 2
	if (dsa->flags & DSA_FLAG_CACHE_MONT_P)
		{
d258 1
a258 2
						CRYPTO_LOCK_DSA,
						dsa->p, ctx))
d260 1
a260 1
		}
d264 3
a266 3
	if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0)
		{
		if (!BN_copy(&kq, &k)) goto err;
d268 4
a271 2
		/* We do not want timing information to leak the length of k,
		 * so we compute g^k using an equivalent exponent of fixed length.
d274 2
a275 1
		 * does not let us specify the desired timing behaviour.) */
d277 6
a282 5
		if (!BN_add(&kq, &kq, dsa->q)) goto err;
		if (BN_num_bits(&kq) <= BN_num_bits(dsa->q))
			{
			if (!BN_add(&kq, &kq, dsa->q)) goto err;
			}
d285 1
a285 3
		}
	else
		{
d287 1
a287 1
		}
d289 3
a291 2
			dsa->method_mont_p);
	if (!BN_mod(r,r,dsa->q,ctx)) goto err;
d294 2
a295 1
	if ((kinv=BN_mod_inverse(NULL,&k,dsa->q,ctx)) == NULL) goto err;
d297 8
a304 6
	if (*kinvp != NULL) BN_clear_free(*kinvp);
	*kinvp=kinv;
	kinv=NULL;
	if (*rp != NULL) BN_clear_free(*rp);
	*rp=r;
	ret=1;
d306 2
a307 3
	if (!ret)
		{
		DSAerr(DSA_F_DSA_SIGN_SETUP,ERR_R_BN_LIB);
d310 3
a312 2
		}
	if (ctx_in == NULL) BN_CTX_free(ctx);
d315 2
a316 2
	return(ret);
	}
d318 3
a320 3
static int dsa_do_verify(const unsigned char *dgst, int dgst_len, DSA_SIG *sig,
			 DSA *dsa)
	{
d322 2
a323 2
	BIGNUM u1,u2,t1;
	BN_MONT_CTX *mont=NULL;
d325 3
a327 3
	if (!dsa->p || !dsa->q || !dsa->g)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_MISSING_PARAMETERS);
d329 1
a329 1
		}
d333 2
a334 3
	if (i != 160 && i != 224 && i != 256)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_BAD_Q_VALUE);
d336 1
a336 1
		}
d338 2
a339 3
	if (BN_num_bits(dsa->p) > OPENSSL_DSA_MAX_MODULUS_BITS)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_MODULUS_TOO_LARGE);
d341 1
a341 1
		}
d346 2
a347 1
	if ((ctx=BN_CTX_new()) == NULL) goto err;
d350 1
a350 2
	    BN_ucmp(sig->r, dsa->q) >= 0)
		{
d353 1
a353 1
		}
d355 1
a355 2
	    BN_ucmp(sig->s, dsa->q) >= 0)
		{
d358 1
a358 1
		}
d362 2
a363 1
	if ((BN_mod_inverse(&u2,sig->s,dsa->q,ctx)) == NULL) goto err;
d366 5
a371 3
		/* if the digest length is greater than the size of q use the
		 * BN_num_bits(dsa->q) leftmost bits of the digest, see
		 * fips 186-3, 4.2 */
d373 2
a374 1
	if (BN_bin2bn(dgst,dgst_len,&u1) == NULL) goto err;
d377 2
a378 1
	if (!BN_mod_mul(&u1,&u1,&u2,dsa->q,ctx)) goto err;
d381 2
a382 1
	if (!BN_mod_mul(&u2,sig->r,&u2,dsa->q,ctx)) goto err;
d385 1
a385 2
	if (dsa->flags & DSA_FLAG_CACHE_MONT_P)
		{
d387 1
a387 1
					CRYPTO_LOCK_DSA, dsa->p, ctx);
d390 1
a390 2
		}

d392 2
a393 1
	DSA_MOD_EXP(goto err, dsa, &t1, dsa->g, &u1, dsa->pub_key, &u2, dsa->p, ctx, mont);
d396 2
a397 1
	if (!BN_mod(&u1,&t1,dsa->q,ctx)) goto err;
d401 1
a401 1
	ret=(BN_ucmp(&u1, sig->r) == 0);
d403 1
a403 1
	err:
d406 4
a409 2
	if (ret != 1) DSAerr(DSA_F_DSA_DO_VERIFY,ERR_R_BN_LIB);
	if (ctx != NULL) BN_CTX_free(ctx);
d413 2
a414 2
	return(ret);
	}
d416 2
a417 1
static int dsa_init(DSA *dsa)
d419 2
a420 2
	dsa->flags|=DSA_FLAG_CACHE_MONT_P;
	return(1);
d423 2
a424 1
static int dsa_finish(DSA *dsa)
d426 1
a426 1
	if(dsa->method_mont_p)
d428 1
a428 1
	return(1);
@


1.17
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d100 9
a108 8
	int _tmp_res53; \
	if((dsa)->meth->dsa_mod_exp) \
		_tmp_res53 = (dsa)->meth->dsa_mod_exp((dsa), (rr), (a1), (p1), \
				(a2), (p2), (m), (ctx), (in_mont)); \
	else \
		_tmp_res53 = BN_mod_exp2_mont((rr), (a1), (p1), (a2), (p2), \
				(m), (ctx), (in_mont)); \
	if(!_tmp_res53) err_instr; \
d110 1
d113 9
a121 7
	int _tmp_res53; \
	if((dsa)->meth->bn_mod_exp) \
		_tmp_res53 = (dsa)->meth->bn_mod_exp((dsa), (r), (a), (p), \
				(m), (ctx), (m_ctx)); \
	else \
		_tmp_res53 = BN_mod_exp_mont((r), (a), (p), (m), (ctx), (m_ctx)); \
	if(!_tmp_res53) err_instr; \
@


1.16
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/* crypto/dsa/dsa_ossl.c */
@


1.15
log
@resolve conflicts
@
text
@d77 6
a82 12
"OpenSSL DSA method",
dsa_do_sign,
dsa_sign_setup,
dsa_do_verify,
NULL, /* dsa_mod_exp, */
NULL, /* dsa_bn_mod_exp, */
dsa_init,
dsa_finish,
0,
NULL,
NULL,
NULL
@


1.14
log
@openssl-1.0.0e: resolve conflicts
@
text
@d139 1
d154 1
a154 1

d165 1
d186 12
@


1.13
log
@resolve conflicts, fix local changes
@
text
@a150 9

	/* reject a excessive digest length (currently at most
	 * dsa-with-SHA256 is supported) */
	if (dlen > SHA256_DIGEST_LENGTH)
		{
		reason=DSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE;
		goto err;
		}

d179 1
a179 1
		BN_sub(s,s,dsa->q);
a318 9

	/* reject a excessive digest length (currently at most
	 * dsa-with-SHA256 is supported) */
	if (dgst_len > SHA256_DIGEST_LENGTH)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
		return -1;
		}

@


1.12
log
@resolve conflicts
@
text
@d64 1
a68 2
#ifndef OPENSSL_FIPS

d72 1
a72 1
		  DSA *dsa);
d137 1
a137 1
	int i,reason=ERR_R_BN_LIB;
d152 3
a154 2
	i=BN_num_bytes(dsa->q); /* should be 20 */
	if ((dlen > i) || (dlen > 50))
d175 8
a182 1
	if (BN_bin2bn(dgst,dlen,&m) == NULL) goto err;
d293 2
a294 2
		if (kinv != NULL) BN_clear_free(kinv);
		if (r != NULL) BN_clear_free(r);
a296 1
	if (kinv != NULL) BN_clear_free(kinv);
d303 1
a303 1
		  DSA *dsa)
d308 1
a308 1
	int ret = -1;
d315 3
a317 1
	if (BN_num_bits(dsa->q) != 160)
d329 8
d361 5
a416 1
#endif
@


1.11
log
@resolve conflicts
@
text
@d68 2
d396 1
@


1.10
log
@openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a67 1
#ifndef OPENSSL_FIPS
a73 6
static int dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1, BIGNUM *p1,
		BIGNUM *a2, BIGNUM *p2, BIGNUM *m, BN_CTX *ctx,
		BN_MONT_CTX *in_mont);
static int dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,
				const BIGNUM *m, BN_CTX *ctx,
				BN_MONT_CTX *m_ctx);
d80 2
a81 2
dsa_mod_exp,
dsa_bn_mod_exp,
d85 2
d90 35
d232 1
a232 1
		BN_set_flags(&k, BN_FLG_EXP_CONSTTIME);
d237 1
a237 1
		if (!BN_MONT_CTX_set_locked((BN_MONT_CTX **)&dsa->method_mont_p,
d267 2
a268 2
	if (!dsa->meth->bn_mod_exp(dsa, r,dsa->g,K,dsa->p,ctx,
		(BN_MONT_CTX *)dsa->method_mont_p)) goto err;
d325 2
a326 1
	if (BN_is_zero(sig->r) || sig->r->neg || BN_ucmp(sig->r, dsa->q) >= 0)
d331 2
a332 1
	if (BN_is_zero(sig->s) || sig->s->neg || BN_ucmp(sig->s, dsa->q) >= 0)
d354 1
a354 2
		mont = BN_MONT_CTX_set_locked(
					(BN_MONT_CTX **)&dsa->method_mont_p,
a359 3
#if 0
	{
	BIGNUM t2;
d361 1
a361 16
	BN_init(&t2);
	/* v = ( g^u1 * y^u2 mod p ) mod q */
	/* let t1 = g ^ u1 mod p */
	if (!BN_mod_exp_mont(&t1,dsa->g,&u1,dsa->p,ctx,mont)) goto err;
	/* let t2 = y ^ u2 mod p */
	if (!BN_mod_exp_mont(&t2,dsa->pub_key,&u2,dsa->p,ctx,mont)) goto err;
	/* let u1 = t1 * t2 mod p */
	if (!BN_mod_mul(&u1,&t1,&t2,dsa->p,ctx)) goto err_bn;
	BN_free(&t2);
	}
	/* let u1 = u1 mod q */
	if (!BN_mod(&u1,&u1,dsa->q,ctx)) goto err;
#else
	{
	if (!dsa->meth->dsa_mod_exp(dsa, &t1,dsa->g,&u1,dsa->pub_key,&u2,
						dsa->p,ctx,mont)) goto err;
d365 1
a365 2
	}
#endif
d371 2
d390 1
a390 1
		BN_MONT_CTX_free((BN_MONT_CTX *)dsa->method_mont_p);
a393 14
static int dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1, BIGNUM *p1,
		BIGNUM *a2, BIGNUM *p2, BIGNUM *m, BN_CTX *ctx,
		BN_MONT_CTX *in_mont)
{
	return BN_mod_exp2_mont(rr, a1, p1, a2, p2, m, ctx, in_mont);
}
	
static int dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,
				const BIGNUM *m, BN_CTX *ctx,
				BN_MONT_CTX *m_ctx)
{
	return BN_mod_exp_mont(r, a, p, m, ctx, m_ctx);
}
#endif
@


1.9
log
@resolve conflicts
@
text
@d277 12
@


1.9.2.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a276 12
	if (BN_num_bits(dsa->q) != 160)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_BAD_Q_VALUE);
		return -1;
		}

	if (BN_num_bits(dsa->p) > OPENSSL_DSA_MAX_MODULUS_BITS)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

@


1.8
log
@resolve conflicts
@
text
@d175 1
a175 1
	BIGNUM k,*kinv=NULL,*r=NULL;
d185 1
a194 1
	kinv=NULL;
d200 4
d205 1
a205 1
	if ((dsa->method_mont_p == NULL) && (dsa->flags & DSA_FLAG_CACHE_MONT_P))
d207 4
a210 3
		if ((dsa->method_mont_p=(char *)BN_MONT_CTX_new()) != NULL)
			if (!BN_MONT_CTX_set((BN_MONT_CTX *)dsa->method_mont_p,
				dsa->p,ctx)) goto err;
d214 24
a237 1
	if (!dsa->meth->bn_mod_exp(dsa, r,dsa->g,&k,dsa->p,ctx,
d260 1
d307 2
a308 1
	if ((dsa->method_mont_p == NULL) && (dsa->flags & DSA_FLAG_CACHE_MONT_P))
d310 5
a314 3
		if ((dsa->method_mont_p=(char *)BN_MONT_CTX_new()) != NULL)
			if (!BN_MONT_CTX_set((BN_MONT_CTX *)dsa->method_mont_p,
				dsa->p,ctx)) goto err;
a315 1
	mont=(BN_MONT_CTX *)dsa->method_mont_p;
@


1.8.2.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a247 12
	if (BN_num_bits(dsa->q) != 160)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_BAD_Q_VALUE);
		return -1;
		}

	if (BN_num_bits(dsa->p) > OPENSSL_DSA_MAX_MODULUS_BITS)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

@


1.8.4.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a247 12
	if (BN_num_bits(dsa->q) != 160)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_BAD_Q_VALUE);
		return -1;
		}

	if (BN_num_bits(dsa->p) > OPENSSL_DSA_MAX_MODULUS_BITS)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d68 1
d350 1
@


1.6
log
@merge with 0.9.7-beta1
@
text
@a66 1
#include <openssl/engine.h>
d108 3
d116 1
a116 2
	BN_init(&m);
	BN_init(&xr);
d182 3
a191 1
	BN_init(&k);
a246 1
	if ((ctx=BN_CTX_new()) == NULL) goto err;
d250 2
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a68 2
int	__BN_rand_range(BIGNUM *r, BIGNUM *range);

d194 1
a194 1
		if (!__BN_rand_range(&k, dsa->q)) goto err;
a344 52


/* random number r:  0 <= r < range */
int	__BN_rand_range(BIGNUM *r, BIGNUM *range)
	{
	int n;

	if (range->neg || BN_is_zero(range))
		{
		/* BNerr(BN_F_BN_RAND_RANGE, BN_R_INVALID_RANGE); */
		return 0;
		}

	n = BN_num_bits(range); /* n > 0 */

	if (n == 1)
		{
		if (!BN_zero(r)) return 0;
		}
	else if (BN_is_bit_set(range, n - 2))
		{
		do
			{
			/* range = 11..._2, so each iteration succeeds with probability >= .75 */
			if (!BN_rand(r, n, -1, 0)) return 0;
			}
		while (BN_cmp(r, range) >= 0);
		}
	else
		{
		/* range = 10..._2,
		 * so  3*range (= 11..._2)  is exactly one bit longer than  range */
		do
			{
			if (!BN_rand(r, n + 1, -1, 0)) return 0;
			/* If  r < 3*range,  use  r := r MOD range
			 * (which is either  r, r - range,  or  r - 2*range).
			 * Otherwise, iterate once more.
			 * Since  3*range = 11..._2, each iteration succeeds with
			 * probability >= .75. */
			if (BN_cmp(r ,range) >= 0)
				{
				if (!BN_sub(r, r, range)) return 0;
				if (BN_cmp(r, range) >= 0)
					if (!BN_sub(r, r, range)) return 0;
				}
			}
		while (BN_cmp(r, range) >= 0);
		}

	return 1;
	}
@


1.4
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d97 1
a97 1
DSA_METHOD *DSA_OpenSSL(void)
d207 1
a207 1
	if (!ENGINE_get_DSA(dsa->engine)->bn_mod_exp(dsa, r,dsa->g,&k,dsa->p,ctx,
d240 5
d301 1
a301 1
	if (!ENGINE_get_DSA(dsa->engine)->dsa_mod_exp(dsa, &t1,dsa->g,&u1,dsa->pub_key,&u2,
@


1.3
log
@import DSA changes from 0.9.6a (Bleichenbacher attack), ok provos@@/deraadt@@
@
text
@d111 5
d178 5
d245 11
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d69 2
d185 3
a187 7
	for (;;)
		{
		if (!BN_rand(&k, BN_num_bits(dsa->q), 0, 0)) goto err;
		if (BN_cmp(&k,dsa->q) >= 0)
			BN_sub(&k,&k,dsa->q);
		if (!BN_is_zero(&k)) break;
		}
d321 52
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d67 1
d185 1
a185 1
		if (!BN_rand(&k, BN_num_bits(dsa->q), 1, 0)) goto err;
d199 1
a199 1
	if (!dsa->meth->bn_mod_exp(dsa, r,dsa->g,&k,dsa->p,ctx,
d277 1
a277 1
	if (!dsa->meth->dsa_mod_exp(dsa, &t1,dsa->g,&u1,dsa->pub_key,&u2,
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a66 1
#include <openssl/engine.h>
d94 1
a94 1
const DSA_METHOD *DSA_OpenSSL(void)
a107 5
	if (!dsa->p || !dsa->q || !dsa->g)
		{
		reason=DSA_R_MISSING_PARAMETERS;
		goto err;
		}
a169 5
	if (!dsa->p || !dsa->q || !dsa->g)
		{
		DSAerr(DSA_F_DSA_SIGN_SETUP,DSA_R_MISSING_PARAMETERS);
		return 0;
		}
d182 7
a188 3
	do
		if (!BN_rand_range(&k, dsa->q)) goto err;
	while (BN_is_zero(&k));
a230 5
	if (!dsa->p || !dsa->q || !dsa->g)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_MISSING_PARAMETERS);
		return -1;
		}
a235 11

	if (BN_is_zero(sig->r) || sig->r->neg || BN_ucmp(sig->r, dsa->q) >= 0)
		{
		ret = 0;
		goto err;
		}
	if (BN_is_zero(sig->s) || sig->s->neg || BN_ucmp(sig->s, dsa->q) >= 0)
		{
		ret = 0;
		goto err;
		}
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d67 1
a108 3
	BN_init(&m);
	BN_init(&xr);

d114 2
a115 1

a180 3

	BN_init(&k);

d188 1
d244 1
a247 2

	if ((ctx=BN_CTX_new()) == NULL) goto err;
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a67 1
#ifndef OPENSSL_FIPS
a348 1
#endif
@


1.1.1.4
log
@import of openssl-0.9.7j
@
text
@d175 1
a175 1
	BIGNUM k,kq,*K,*kinv=NULL,*r=NULL;
a184 1
	BN_init(&kq);
d194 1
a199 4
	if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0)
		{
		BN_set_flags(&k, BN_FLG_EXP_CONSTTIME);
		}
d201 1
a201 1
	if (dsa->flags & DSA_FLAG_CACHE_MONT_P)
d203 3
a205 4
		if (!BN_MONT_CTX_set_locked((BN_MONT_CTX **)&dsa->method_mont_p,
						CRYPTO_LOCK_DSA,
						dsa->p, ctx))
			goto err;
d209 1
a209 24

	if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0)
		{
		if (!BN_copy(&kq, &k)) goto err;

		/* We do not want timing information to leak the length of k,
		 * so we compute g^k using an equivalent exponent of fixed length.
		 *
		 * (This is a kludge that we need because the BN_mod_exp_mont()
		 * does not let us specify the desired timing behaviour.) */

		if (!BN_add(&kq, &kq, dsa->q)) goto err;
		if (BN_num_bits(&kq) <= BN_num_bits(dsa->q))
			{
			if (!BN_add(&kq, &kq, dsa->q)) goto err;
			}

		K = &kq;
		}
	else
		{
		K = &k;
		}
	if (!dsa->meth->bn_mod_exp(dsa, r,dsa->g,K,dsa->p,ctx,
a231 1
	BN_clear_free(&kq);
d278 1
a278 2

	if (dsa->flags & DSA_FLAG_CACHE_MONT_P)
d280 3
a282 5
		mont = BN_MONT_CTX_set_locked(
					(BN_MONT_CTX **)&dsa->method_mont_p,
					CRYPTO_LOCK_DSA, dsa->p, ctx);
		if (!mont)
			goto err;
d284 1
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d68 1
d75 6
d87 2
a88 2
NULL, /* dsa_mod_exp, */
NULL, /* dsa_bn_mod_exp, */
a91 2
NULL,
NULL,
a94 35
/* These macro wrappers replace attempts to use the dsa_mod_exp() and
 * bn_mod_exp() handlers in the DSA_METHOD structure. We avoid the problem of
 * having a the macro work as an expression by bundling an "err_instr". So;
 * 
 *     if (!dsa->meth->bn_mod_exp(dsa, r,dsa->g,&k,dsa->p,ctx,
 *                 dsa->method_mont_p)) goto err;
 *
 * can be replaced by;
 *
 *     DSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, &k, dsa->p, ctx,
 *                 dsa->method_mont_p);
 */

#define DSA_MOD_EXP(err_instr,dsa,rr,a1,p1,a2,p2,m,ctx,in_mont) \
	do { \
	int _tmp_res53; \
	if((dsa)->meth->dsa_mod_exp) \
		_tmp_res53 = (dsa)->meth->dsa_mod_exp((dsa), (rr), (a1), (p1), \
				(a2), (p2), (m), (ctx), (in_mont)); \
	else \
		_tmp_res53 = BN_mod_exp2_mont((rr), (a1), (p1), (a2), (p2), \
				(m), (ctx), (in_mont)); \
	if(!_tmp_res53) err_instr; \
	} while(0)
#define DSA_BN_MOD_EXP(err_instr,dsa,r,a,p,m,ctx,m_ctx) \
	do { \
	int _tmp_res53; \
	if((dsa)->meth->bn_mod_exp) \
		_tmp_res53 = (dsa)->meth->bn_mod_exp((dsa), (r), (a), (p), \
				(m), (ctx), (m_ctx)); \
	else \
		_tmp_res53 = BN_mod_exp_mont((r), (a), (p), (m), (ctx), (m_ctx)); \
	if(!_tmp_res53) err_instr; \
	} while(0)

d202 1
a202 1
		BN_set_flags(&k, BN_FLG_CONSTTIME);
d207 1
a207 1
		if (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,
d237 2
a238 2
	DSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, K, dsa->p, ctx,
			dsa->method_mont_p);
a276 12
	if (BN_num_bits(dsa->q) != 160)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_BAD_Q_VALUE);
		return -1;
		}

	if (BN_num_bits(dsa->p) > OPENSSL_DSA_MAX_MODULUS_BITS)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

d283 1
a283 2
	if (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||
	    BN_ucmp(sig->r, dsa->q) >= 0)
d288 1
a288 2
	if (BN_is_zero(sig->s) || BN_is_negative(sig->s) ||
	    BN_ucmp(sig->s, dsa->q) >= 0)
d310 2
a311 1
		mont = BN_MONT_CTX_set_locked(&dsa->method_mont_p,
d317 3
d321 16
a336 1
	DSA_MOD_EXP(goto err, dsa, &t1, dsa->g, &u1, dsa->pub_key, &u2, dsa->p, ctx, mont);
d340 2
a341 1

a346 2
	/* XXX: surely this is wrong - if ret is 0, it just didn't verify;
	   there is no error in BN. Test should be ret == -1 (Ben) */
d364 1
a364 1
		BN_MONT_CTX_free(dsa->method_mont_p);
d368 14
@


1.1.1.6
log
@import openssl-0.9.8j
@
text
@a67 2
#ifndef OPENSSL_FIPS

a393 1
#endif
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@a63 1
#include <openssl/sha.h>
d68 2
d73 1
a73 1
			 DSA *dsa);
d138 1
a138 1
	int reason=ERR_R_BN_LIB;
d153 2
a154 3
	/* reject a excessive digest length (currently at most
	 * dsa-with-SHA256 is supported) */
	if (dlen > SHA256_DIGEST_LENGTH)
d175 1
a175 8
	
	if (dlen > BN_num_bytes(dsa->q))
		/* if the digest length is greater than the size of q use the
		 * BN_num_bits(dsa->q) leftmost bits of the digest, see
		 * fips 186-3, 4.2 */
		dlen = BN_num_bytes(dsa->q);
	if (BN_bin2bn(dgst,dlen,&m) == NULL)
		goto err;
d286 2
a287 2
		if (r != NULL)
			BN_clear_free(r);
d290 1
d297 1
a297 1
			 DSA *dsa)
d302 1
a302 1
	int ret = -1, i;
d309 1
a309 3
	i = BN_num_bits(dsa->q);
	/* fips 186-3 allows only different sizes for q */
	if (i != 160 && i != 224 && i != 256)
a320 8
	/* reject a excessive digest length (currently at most
	 * dsa-with-SHA256 is supported) */
	if (dgst_len > SHA256_DIGEST_LENGTH)
		{
		DSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
		return -1;
		}

a344 5
	if (dgst_len > (i >> 3))
		/* if the digest length is greater than the size of q use the
		 * BN_num_bits(dsa->q) leftmost bits of the digest, see
		 * fips 186-3, 4.2 */
		dgst_len = (i >> 3);
d396 1
@


1.1.1.8
log
@import OpenSSL 1.0.0e
@
text
@d151 9
d188 1
a188 1
		if (!BN_sub(s,s,dsa->q)) goto err;
d328 9
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@a138 1
	int noredo = 0;
d153 1
a153 1
redo:
a163 1
		noredo = 1;
a183 12
	/* Redo if r or s is zero as required by FIPS 186-3: this is
	 * very unlikely.
	 */
	if (BN_is_zero(r) || BN_is_zero(s))
		{
		if (noredo)
			{
			reason = DSA_R_NEED_NEW_SETUP_VALUES;
			goto err;
			}
		goto redo;
		}
@


