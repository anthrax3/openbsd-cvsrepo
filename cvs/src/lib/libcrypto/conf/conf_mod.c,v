head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27;
locks; strict;
comment	@ * @;


1.27
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.26;
commitid	kT0fLt3r4lroFJra;

1.26
date	2015.04.11.16.03.21;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	WnYuC1gPCzN02uAn;

1.25
date	2014.07.22.02.21.20;	author beck;	state Exp;
branches;
next	1.24;
commitid	iBnKYMaAFvJMFyL2;

1.24
date	2014.07.13.16.03.09;	author beck;	state Exp;
branches;
next	1.23;
commitid	6xdvCwSqBadTW6X3;

1.23
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.22;
commitid	yQEL1wOWIearrW15;

1.22
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.21;
commitid	id8dTrTMtnTn4fqt;

1.21
date	2014.06.23.22.19.02;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	9JQzcWo59KD9HxBQ;

1.20
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	mJUVYpkFBZ0Zv2bG;

1.19
date	2014.05.30.02.52.11;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.20.09.04.56;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.18.15.38.16;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.18.13.38.31;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.17.22.09.37;	author giovanni;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.09.12.15.38;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.20.03.40.06;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.05.11.05.07;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.16.12.18.21;	author ho;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.30.16.00.16;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.12;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.09;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.37.33;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.20.41.38;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.42;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.13.53;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.05;	author djm;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: conf_mod.c,v 1.26 2015/04/11 16:03:21 deraadt Exp $ */
/* Written by Stephen Henson (steve@@openssl.org) for the OpenSSL
 * project 2001.
 */
/* ====================================================================
 * Copyright (c) 2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <openssl/conf.h>
#include <openssl/crypto.h>
#include <openssl/dso.h>
#include <openssl/err.h>
#include <openssl/x509.h>

#define DSO_mod_init_name "OPENSSL_init"
#define DSO_mod_finish_name "OPENSSL_finish"

/* This structure contains a data about supported modules.
 * entries in this table correspond to either dynamic or
 * static modules.
 */

struct conf_module_st {
	/* DSO of this module or NULL if static */
	DSO *dso;
	/* Name of the module */
	char *name;
	/* Init function */
	conf_init_func *init;
	/* Finish function */
	conf_finish_func *finish;
	/* Number of successfully initialized modules */
	int links;
	void *usr_data;
};


/* This structure contains information about modules that have been
 * successfully initialized. There may be more than one entry for a
 * given module.
 */

struct conf_imodule_st {
	CONF_MODULE *pmod;
	char *name;
	char *value;
	unsigned long flags;
	void *usr_data;
};

static STACK_OF(CONF_MODULE) *supported_modules = NULL;
static STACK_OF(CONF_IMODULE) *initialized_modules = NULL;

static void module_free(CONF_MODULE *md);
static void module_finish(CONF_IMODULE *imod);
static int module_run(const CONF *cnf, char *name, char *value,
    unsigned long flags);
static CONF_MODULE *module_add(DSO *dso, const char *name,
    conf_init_func *ifunc, conf_finish_func *ffunc);
static CONF_MODULE *module_find(char *name);
static int module_init(CONF_MODULE *pmod, char *name, char *value,
    const CONF *cnf);
static CONF_MODULE *module_load_dso(const CONF *cnf, char *name, char *value,
    unsigned long flags);

/* Main function: load modules from a CONF structure */

int
CONF_modules_load(const CONF *cnf, const char *appname, unsigned long flags)
{
	STACK_OF(CONF_VALUE) *values;
	CONF_VALUE *vl;
	char *vsection = NULL;

	int ret, i;

	if (!cnf)
		return 1;

	if (appname)
		vsection = NCONF_get_string(cnf, NULL, appname);

	if (!appname || (!vsection && (flags & CONF_MFLAGS_DEFAULT_SECTION)))
		vsection = NCONF_get_string(cnf, NULL, "openssl_conf");

	if (!vsection) {
		ERR_clear_error();
		return 1;
	}

	values = NCONF_get_section(cnf, vsection);

	if (!values)
		return 0;

	for (i = 0; i < sk_CONF_VALUE_num(values); i++) {
		vl = sk_CONF_VALUE_value(values, i);
		ret = module_run(cnf, vl->name, vl->value, flags);
		if (ret <= 0)
			if (!(flags & CONF_MFLAGS_IGNORE_ERRORS))
				return ret;
	}

	return 1;
}

int
CONF_modules_load_file(const char *filename, const char *appname,
    unsigned long flags)
{
	char *file = NULL;
	CONF *conf = NULL;
	int ret = 0;
	conf = NCONF_new(NULL);
	if (!conf)
		goto err;

	if (filename == NULL) {
		file = CONF_get1_default_config_file();
		if (!file)
			goto err;
	} else
		file = (char *)filename;

	if (NCONF_load(conf, file, NULL) <= 0) {
		if ((flags & CONF_MFLAGS_IGNORE_MISSING_FILE) &&
		    (ERR_GET_REASON(ERR_peek_last_error()) ==
		    CONF_R_NO_SUCH_FILE)) {
			ERR_clear_error();
			ret = 1;
		}
		goto err;
	}

	ret = CONF_modules_load(conf, appname, flags);

err:
	if (filename == NULL)
		free(file);
	NCONF_free(conf);

	return ret;
}

static int
module_run(const CONF *cnf, char *name, char *value, unsigned long flags)
{
	CONF_MODULE *md;
	int ret;

	md = module_find(name);

	/* Module not found: try to load DSO */
	if (!md && !(flags & CONF_MFLAGS_NO_DSO))
		md = module_load_dso(cnf, name, value, flags);

	if (!md) {
		if (!(flags & CONF_MFLAGS_SILENT)) {
			CONFerror(CONF_R_UNKNOWN_MODULE_NAME);
			ERR_asprintf_error_data("module=%s", name);
		}
		return -1;
	}

	ret = module_init(md, name, value, cnf);

	if (ret <= 0) {
		if (!(flags & CONF_MFLAGS_SILENT)) {
			CONFerror(CONF_R_MODULE_INITIALIZATION_ERROR);
			ERR_asprintf_error_data
			    ("module=%s, value=%s, retcode=%-8d",
			    name, value, ret);
		}
	}

	return ret;
}

/* Load a module from a DSO */
static CONF_MODULE *
module_load_dso(const CONF *cnf, char *name, char *value, unsigned long flags)
{
	DSO *dso = NULL;
	conf_init_func *ifunc;
	conf_finish_func *ffunc;
	char *path = NULL;
	int errcode = 0;
	CONF_MODULE *md;

	/* Look for alternative path in module section */
	path = NCONF_get_string(cnf, value, "path");
	if (!path) {
		ERR_clear_error();
		path = name;
	}
	dso = DSO_load(NULL, path, NULL, 0);
	if (!dso) {
		errcode = CONF_R_ERROR_LOADING_DSO;
		goto err;
	}
	ifunc = (conf_init_func *)DSO_bind_func(dso, DSO_mod_init_name);
	if (!ifunc) {
		errcode = CONF_R_MISSING_INIT_FUNCTION;
		goto err;
	}
	ffunc = (conf_finish_func *)DSO_bind_func(dso, DSO_mod_finish_name);
	/* All OK, add module */
	md = module_add(dso, name, ifunc, ffunc);

	if (!md)
		goto err;

	return md;

err:
	if (dso)
		DSO_free(dso);
	CONFerror(errcode);
	ERR_asprintf_error_data("module=%s, path=%s", name, path);
	return NULL;
}

/* add module to list */
static CONF_MODULE *
module_add(DSO *dso, const char *name, conf_init_func *ifunc,
    conf_finish_func *ffunc)
{
	CONF_MODULE *tmod = NULL;

	if (name == NULL)
		return NULL;
	if (supported_modules == NULL)
		supported_modules = sk_CONF_MODULE_new_null();
	if (supported_modules == NULL)
		return NULL;
	tmod = malloc(sizeof(CONF_MODULE));
	if (tmod == NULL)
		return NULL;

	tmod->dso = dso;
	tmod->name = strdup(name);
	tmod->init = ifunc;
	tmod->finish = ffunc;
	tmod->links = 0;

	if (!sk_CONF_MODULE_push(supported_modules, tmod)) {
		free(tmod);
		return NULL;
	}

	return tmod;
}

/* Find a module from the list. We allow module names of the
 * form modname.XXXX to just search for modname to allow the
 * same module to be initialized more than once.
 */

static CONF_MODULE *
module_find(char *name)
{
	CONF_MODULE *tmod;
	int i, nchar;
	char *p;

	p = strrchr(name, '.');

	if (p)
		nchar = p - name;
	else
		nchar = strlen(name);

	for (i = 0; i < sk_CONF_MODULE_num(supported_modules); i++) {
		tmod = sk_CONF_MODULE_value(supported_modules, i);
		if (!strncmp(tmod->name, name, nchar))
			return tmod;
	}

	return NULL;
}

/* initialize a module */
static int
module_init(CONF_MODULE *pmod, char *name, char *value, const CONF *cnf)
{
	int ret = 1;
	int init_called = 0;
	CONF_IMODULE *imod = NULL;

	/* Otherwise add initialized module to list */
	imod = malloc(sizeof(CONF_IMODULE));
	if (!imod)
		goto err;

	imod->pmod = pmod;
	imod->name = name ? strdup(name) : NULL;
	imod->value = value ? strdup(value) : NULL;
	imod->usr_data = NULL;

	if (!imod->name || !imod->value)
		goto memerr;

	/* Try to initialize module */
	if (pmod->init) {
		ret = pmod->init(imod, cnf);
		init_called = 1;
		/* Error occurred, exit */
		if (ret <= 0)
			goto err;
	}

	if (initialized_modules == NULL) {
		initialized_modules = sk_CONF_IMODULE_new_null();
		if (!initialized_modules) {
			CONFerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}

	if (!sk_CONF_IMODULE_push(initialized_modules, imod)) {
		CONFerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	pmod->links++;

	return ret;

err:
	/* We've started the module so we'd better finish it */
	if (pmod->finish && init_called)
		pmod->finish(imod);

memerr:
	if (imod) {
		free(imod->name);
		free(imod->value);
		free(imod);
	}

	return -1;
}

/* Unload any dynamic modules that have a link count of zero:
 * i.e. have no active initialized modules. If 'all' is set
 * then all modules are unloaded including static ones.
 */

void
CONF_modules_unload(int all)
{
	int i;
	CONF_MODULE *md;

	CONF_modules_finish();

	/* unload modules in reverse order */
	for (i = sk_CONF_MODULE_num(supported_modules) - 1; i >= 0; i--) {
		md = sk_CONF_MODULE_value(supported_modules, i);
		/* If static or in use and 'all' not set ignore it */
		if (((md->links > 0) || !md->dso) && !all)
			continue;
		/* Since we're working in reverse this is OK */
		(void)sk_CONF_MODULE_delete(supported_modules, i);
		module_free(md);
	}
	if (sk_CONF_MODULE_num(supported_modules) == 0) {
		sk_CONF_MODULE_free(supported_modules);
		supported_modules = NULL;
	}
}

/* unload a single module */
static void
module_free(CONF_MODULE *md)
{
	if (md->dso)
		DSO_free(md->dso);
	free(md->name);
	free(md);
}

/* finish and free up all modules instances */

void
CONF_modules_finish(void)
{
	CONF_IMODULE *imod;

	while (sk_CONF_IMODULE_num(initialized_modules) > 0) {
		imod = sk_CONF_IMODULE_pop(initialized_modules);
		module_finish(imod);
	}
	sk_CONF_IMODULE_free(initialized_modules);
	initialized_modules = NULL;
}

/* finish a module instance */

static void
module_finish(CONF_IMODULE *imod)
{
	if (imod->pmod->finish)
		imod->pmod->finish(imod);
	imod->pmod->links--;
	free(imod->name);
	free(imod->value);
	free(imod);
}

/* Add a static module to OpenSSL */

int
CONF_module_add(const char *name, conf_init_func *ifunc,
    conf_finish_func *ffunc)
{
	if (module_add(NULL, name, ifunc, ffunc))
		return 1;
	else
		return 0;
}

void
CONF_modules_free(void)
{
	CONF_modules_finish();
	CONF_modules_unload(1);
}

/* Utility functions */

const char *
CONF_imodule_get_name(const CONF_IMODULE *md)
{
	return md->name;
}

const char *
CONF_imodule_get_value(const CONF_IMODULE *md)
{
	return md->value;
}

void *
CONF_imodule_get_usr_data(const CONF_IMODULE *md)
{
	return md->usr_data;
}

void
CONF_imodule_set_usr_data(CONF_IMODULE *md, void *usr_data)
{
	md->usr_data = usr_data;
}

CONF_MODULE *
CONF_imodule_get_module(const CONF_IMODULE *md)
{
	return md->pmod;
}

unsigned long
CONF_imodule_get_flags(const CONF_IMODULE *md)
{
	return md->flags;
}

void
CONF_imodule_set_flags(CONF_IMODULE *md, unsigned long flags)
{
	md->flags = flags;
}

void *
CONF_module_get_usr_data(CONF_MODULE *pmod)
{
	return pmod->usr_data;
}

void
CONF_module_set_usr_data(CONF_MODULE *pmod, void *usr_data)
{
	pmod->usr_data = usr_data;
}

/* Return default config file name */

char *
CONF_get1_default_config_file(void)
{
	char *file = NULL;

	if (asprintf(&file, "%s/openssl.cnf",
	    X509_get_default_cert_area()) == -1)
		return (NULL);
	return file;
}

/* This function takes a list separated by 'sep' and calls the
 * callback function giving the start and length of each member
 * optionally stripping leading and trailing whitespace. This can
 * be used to parse comma separated lists for example.
 */

int
CONF_parse_list(const char *list_, int sep, int nospc,
    int (*list_cb)(const char *elem, int len, void *usr), void *arg)
{
	int ret;
	const char *lstart, *tmpend, *p;

	if (list_ == NULL) {
		CONFerror(CONF_R_LIST_CANNOT_BE_NULL);
		return 0;
	}

	lstart = list_;
	for (;;) {
		if (nospc) {
			while (*lstart && isspace((unsigned char)*lstart))
				lstart++;
		}
		p = strchr(lstart, sep);
		if (p == lstart || !*lstart)
			ret = list_cb(NULL, 0, arg);
		else {
			if (p)
				tmpend = p - 1;
			else
				tmpend = lstart + strlen(lstart) - 1;
			if (nospc) {
				while (isspace((unsigned char)*tmpend))
					tmpend--;
			}
			ret = list_cb(lstart, tmpend - lstart + 1, arg);
		}
		if (ret <= 0)
			return ret;
		if (p == NULL)
			return 1;
		lstart = p + 1;
	}
}
@


1.26
log
@Remove all getenv() calls, especially those wrapped by issetugid().
getenv()'s wrapped by issetugid() are safe, but issetugid() is correct
difficult to impliment on many operating systems.  By accident, a grand
experiment was run over the last year, where issetugid() returned 1 (the
safe value) on a few operating systems.  Noone noticed & complained that
certain environment variables were not working.......
ok doug beck jsing, discussion with others
@
text
@d1 1
a1 1
/* $OpenBSD: conf_mod.c,v 1.25 2014/07/22 02:21:20 beck Exp $ */
d214 1
a214 1
			CONFerr(CONF_F_MODULE_RUN, CONF_R_UNKNOWN_MODULE_NAME);
d224 1
a224 2
			CONFerr(CONF_F_MODULE_RUN,
			    CONF_R_MODULE_INITIALIZATION_ERROR);
d273 1
a273 1
	CONFerr(CONF_F_MODULE_LOAD_DSO, errcode);
d370 1
a370 1
			CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE);
d376 1
a376 1
		CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE);
d568 1
a568 1
		CONFerr(CONF_F_CONF_PARSE_LIST, CONF_R_LIST_CANNOT_BE_NULL);
@


1.25
log
@Kill a bunch more BUF_strdup's - these are converted to have a check for
NULL before an intrinsic strdup.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf_mod.c,v 1.24 2014/07/13 16:03:09 beck Exp $ */
a548 4
	if (issetugid() == 0)
		file = getenv("OPENSSL_CONF");
	if (file)
		return strdup(file);
@


1.24
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf_mod.c,v 1.23 2014/07/11 08:44:48 jsing Exp $ */
d286 2
d297 1
a297 1
	tmod->name = BUF_strdup(name);
@


1.23
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf_mod.c,v 1.22 2014/07/10 13:58:22 jsing Exp $ */
d350 2
a351 2
	imod->name = BUF_strdup(name);
	imod->value = BUF_strdup(value);
d550 1
a550 1
		return BUF_strdup(file);
@


1.22
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf_mod.c,v 1.21 2014/06/23 22:19:02 deraadt Exp $ */
d64 1
a65 2
#include "cryptlib.h"
#include <openssl/conf.h>
d67 1
a69 1

a71 1

@


1.21
log
@Since this is a library, place issetugid() before every getenv()
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: conf_mod.c,v 1.20 2014/06/12 15:49:28 deraadt Exp $ */
d59 1
d61 3
a63 1
#include <ctype.h>
@


1.20
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d544 1
a544 1
	char *file;
d546 2
a547 1
	file = getenv("OPENSSL_CONF");
@


1.19
log
@no need for null check before free. from Brendan MacDonell
@
text
@d1 1
a1 1
/* conf_mod.c */
@


1.18
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d389 2
a390 4
		if (imod->name)
			free(imod->name);
		if (imod->value)
			free(imod->value);
@


1.17
log
@KNF.
@
text
@d214 1
a214 1
			ERR_add_error_data(2, "module=", name);
a222 1
			char rcode[DECIMAL_SIZE(ret) + 1];
d225 3
a227 3
			snprintf(rcode, sizeof rcode, "%-8d", ret);
			ERR_add_error_data(6, "module=", name, ", value=",
			    value, ", retcode=", rcode);
d274 1
a274 1
	ERR_add_error_data(4, "module=", name, ", path=", path);
@


1.16
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d77 1
a77 2
struct conf_module_st
	{
d83 1
a83 1
	conf_init_func *init; 
d89 1
a89 1
	};
d97 1
a97 2
struct conf_imodule_st
	{
d103 1
a103 1
	};
d111 1
a111 1
					  unsigned long flags);
d113 1
a113 1
			conf_init_func *ifunc, conf_finish_func *ffunc);
d116 1
a116 1
					   const CONF *cnf);
d118 1
a118 1
									unsigned long flags);
d122 3
a124 3
int CONF_modules_load(const CONF *cnf, const char *appname,
		      unsigned long flags)
	{
d140 1
a140 2
	if (!vsection)
		{
d143 1
a143 1
		}
d150 1
a150 2
	for (i = 0; i < sk_CONF_VALUE_num(values); i++)
		{
d154 1
a154 1
			if(!(flags & CONF_MFLAGS_IGNORE_ERRORS))
d156 1
a156 1
		}
d159 1
d161 4
a164 5
	}

int CONF_modules_load_file(const char *filename, const char *appname,
			   unsigned long flags)
	{
d172 1
a172 2
	if (filename == NULL)
		{
d176 1
a176 2
		}
	else
d179 1
a179 2
	if (NCONF_load(conf, file, NULL) <= 0)
		{
d181 2
a182 2
		  (ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE))
			{
d185 1
a185 1
			}
d187 1
a187 1
		}
d191 1
a191 1
	err:
d197 1
a197 1
	}
d199 3
a201 3
static int module_run(const CONF *cnf, char *name, char *value,
		      unsigned long flags)
	{
d211 2
a212 4
	if (!md)
		{
		if (!(flags & CONF_MFLAGS_SILENT))
			{
d215 1
a215 1
			}
d217 1
a217 1
		}
d221 5
a225 6
	if (ret <= 0)
		{
		if (!(flags & CONF_MFLAGS_SILENT))
			{
			char rcode[DECIMAL_SIZE(ret)+1];
			CONFerr(CONF_F_MODULE_RUN, CONF_R_MODULE_INITIALIZATION_ERROR);
d227 2
a228 2
			ERR_add_error_data(6, "module=", name, ", value=", value, ", retcode=", rcode);
			}
d230 1
d233 1
a233 1
	}
d236 3
a238 3
static CONF_MODULE *module_load_dso(const CONF *cnf, char *name, char *value,
				    unsigned long flags)
	{
d245 1
d248 1
a248 2
	if (!path)
		{
d251 1
a251 1
		}
d253 1
a253 2
	if (!dso)
		{
d256 3
a258 4
		}
        ifunc = (conf_init_func *)DSO_bind_func(dso, DSO_mod_init_name);
	if (!ifunc)
		{
d261 2
a262 2
		}
        ffunc = (conf_finish_func *)DSO_bind_func(dso, DSO_mod_finish_name);
d271 1
a271 1
	err:
d277 1
a277 1
	}
d280 4
a283 3
static CONF_MODULE *module_add(DSO *dso, const char *name,
			       conf_init_func *ifunc, conf_finish_func *ffunc)
	{
d285 1
d300 1
a300 2
	if (!sk_CONF_MODULE_push(supported_modules, tmod))
		{
d303 1
a303 1
		}
d306 1
a306 1
	}
d313 3
a315 2
static CONF_MODULE *module_find(char *name)
	{
d319 1
d324 1
a324 1
	else 
d327 1
a327 2
	for (i = 0; i < sk_CONF_MODULE_num(supported_modules); i++)
		{
d331 1
a331 1
		}
d334 1
a334 2

	}
d337 3
a339 3
static int module_init(CONF_MODULE *pmod, char *name, char *value,
		       const CONF *cnf)
	{
d358 1
a358 2
	if(pmod->init)
		{
d364 1
a364 1
		}
d366 1
a366 2
	if (initialized_modules == NULL)
		{
d368 1
a368 2
		if (!initialized_modules)
			{
a370 1
			}
d372 1
d374 1
a374 2
	if (!sk_CONF_IMODULE_push(initialized_modules, imod))
		{
d377 1
a377 1
		}
d383 1
a383 2
	err:

d388 2
a389 3
	memerr:
	if (imod)
		{
d395 1
a395 1
		}
d398 1
a398 2

	}
d405 3
a407 2
void CONF_modules_unload(int all)
	{
d410 1
d412 1
d414 1
a414 2
	for (i = sk_CONF_MODULE_num(supported_modules) - 1; i >= 0; i--)
		{
d422 2
a423 3
		}
	if (sk_CONF_MODULE_num(supported_modules) == 0)
		{
a425 1
		}
d427 1
d430 3
a432 2
static void module_free(CONF_MODULE *md)
	{
d437 1
a437 1
	}
d441 3
a443 2
void CONF_modules_finish(void)
	{
d445 2
a446 2
	while (sk_CONF_IMODULE_num(initialized_modules) > 0)
		{
d449 1
a449 1
		}
d452 1
a452 1
	}
d456 3
a458 2
static void module_finish(CONF_IMODULE *imod)
	{
d465 1
a465 1
	}
d469 4
a472 3
int CONF_module_add(const char *name, conf_init_func *ifunc, 
		    conf_finish_func *ffunc)
	{
d477 1
a477 1
	}
d479 3
a481 2
void CONF_modules_free(void)
	{
d484 1
a484 1
	}
d488 3
a490 2
const char *CONF_imodule_get_name(const CONF_IMODULE *md)
	{
d492 1
a492 1
	}
d494 3
a496 2
const char *CONF_imodule_get_value(const CONF_IMODULE *md)
	{
d498 1
a498 1
	}
d500 3
a502 2
void *CONF_imodule_get_usr_data(const CONF_IMODULE *md)
	{
d504 1
a504 1
	}
d506 3
a508 2
void CONF_imodule_set_usr_data(CONF_IMODULE *md, void *usr_data)
	{
d510 1
a510 1
	}
d512 3
a514 2
CONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)
	{
d516 1
a516 1
	}
d518 3
a520 2
unsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)
	{
d522 1
a522 1
	}
d524 3
a526 2
void CONF_imodule_set_flags(CONF_IMODULE *md, unsigned long flags)
	{
d528 1
a528 1
	}
d530 3
a532 2
void *CONF_module_get_usr_data(CONF_MODULE *pmod)
	{
d534 1
a534 1
	}
d536 3
a538 2
void CONF_module_set_usr_data(CONF_MODULE *pmod, void *usr_data)
	{
d540 1
a540 1
	}
d550 1
a550 1
	if (file) 
d552 2
a553 1
	if (asprintf(&file, "%s/openssl.cnf", X509_get_default_cert_area()) == -1)
d564 4
a567 3
int CONF_parse_list(const char *list_, int sep, int nospc,
	int (*list_cb)(const char *elem, int len, void *usr), void *arg)
	{
d571 1
a571 2
	if(list_ == NULL)
		{
d574 1
a574 1
		}
d577 3
a579 5
	for(;;)
		{
		if (nospc)
			{
			while(*lstart && isspace((unsigned char)*lstart))
d581 1
a581 1
			}
d585 1
a585 2
		else
			{
d588 1
a588 1
			else 
d590 2
a591 3
			if (nospc)
				{
				while(isspace((unsigned char)*tmpend))
d593 1
a593 1
				}
d595 1
a595 1
			}
a600 1
		}
d602 1
a602 1

@


1.15
log
@use the portable construct around asprintf; pointed out by halex
@
text
@d236 1
a236 1
			(void) snprintf(rcode, sizeof rcode, "%-8d", ret);
@


1.14
log
@in CONF_get1_default_config_file(), don't calculate a buffer size,
malloc it, do unbounded strlcpy's to it... but instead of asnprintf.
While there, let's put a '/' between the two path components!  Wonder
how old that bug is..
ok guenther
@
text
@d554 2
a555 1
	asprintf(&file, "%s/openssl.cnf", X509_get_default_cert_area());
@


1.13
log
@
more spring VMS cleanup
ok miod@@ lteo@@
@
text
@d546 3
a548 2
char *CONF_get1_default_config_file(void)
	{
a549 1
	int len;
d554 1
a554 11

	len = strlen(X509_get_default_cert_area());
	len += strlen(OPENSSL_CONF);

	file = malloc(len + 1);

	if (!file)
		return NULL;
	BUF_strlcpy(file,X509_get_default_cert_area(),len + 1);
	BUF_strlcat(file,OPENSSL_CONF,len + 1);

d556 1
a556 1
	}
@


1.12
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a555 3
#ifndef OPENSSL_SYS_VMS
	len++;
#endif
a562 3
#ifndef OPENSSL_SYS_VMS
	BUF_strlcat(file,"/",len + 1);
#endif
@


1.11
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@d200 1
a200 1
		OPENSSL_free(file);
d299 1
a299 1
	tmod = OPENSSL_malloc(sizeof(CONF_MODULE));
d311 1
a311 1
		OPENSSL_free(tmod);
d355 1
a355 1
	imod = OPENSSL_malloc(sizeof(CONF_IMODULE));
d407 1
a407 1
			OPENSSL_free(imod->name);
d409 2
a410 2
			OPENSSL_free(imod->value);
		OPENSSL_free(imod);
d450 2
a451 2
	OPENSSL_free(md->name);
	OPENSSL_free(md);
d475 3
a477 3
	OPENSSL_free(imod->name);
	OPENSSL_free(imod->value);
	OPENSSL_free(imod);
d561 1
a561 1
	file = OPENSSL_malloc(len + 1);
@


1.10
log
@resolve conflicts, fix local changes
@
text
@d236 1
a236 1
			BIO_snprintf(rcode, sizeof rcode, "%-8d", ret);
@


1.9
log
@resolve conflicts
@
text
@d585 7
a592 1

@


1.8
log
@resolve conflicts
@
text
@d591 1
a591 1
			while(isspace((unsigned char)*lstart))
@


1.7
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Stephen Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.6
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d129 1
a129 1
	char *vsection;
d136 2
a137 2
	if (appname == NULL)
		appname = "openssl_conf";
d139 2
a140 1
	vsection = NCONF_get_string(cnf, NULL, appname); 
d235 1
a235 1
			CONFerr(CONF_F_CONF_MODULES_LOAD, CONF_R_MODULE_INITIALIZATION_ERROR);
d258 1
a258 1
		ERR_get_error();
d435 1
a435 1
		sk_CONF_MODULE_delete(supported_modules, i);
@


1.5
log
@merge 0.9.7d
@
text
@d590 1
a590 1
			while(*lstart && isspace((unsigned char)*lstart))
@


1.4
log
@Trivial sprintf() -> snprintf() changes. ok deraadt@@
@
text
@d235 1
a235 1
			snprintf(rcode, sizeof rcode, "%-8d", ret);
d564 1
a564 1
	strlcpy(file,X509_get_default_cert_area(),len + 1);
d566 1
a566 1
	strlcat(file,"/",len + 1);
d568 1
a568 1
	strlcat(file,OPENSSL_CONF,len + 1);
d579 1
a579 1
int CONF_parse_list(const char *list, int sep, int nospc,
d584 1
a584 1
	lstart = list;
@


1.3
log
@Less strcpy/strcat/sprintf. tdeval@@ ok.
@
text
@d235 1
a235 1
			sprintf(rcode, "%-8d", ret);
@


1.2
log
@sync with http://www.openssl.org/news/patch_20020730_0_9_7.txt
(adds fix for unused kerberos and engine code, and some more
assertions, as well as a 64bit integer string fix for conf_mod.c)
@
text
@d564 1
a564 1
	strcpy(file,X509_get_default_cert_area());
d566 1
a566 1
	strcat(file,"/");
d568 1
a568 1
	strcat(file,OPENSSL_CONF);
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d233 1
a233 1
			char rcode[10];
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@d233 1
a233 1
			char rcode[DECIMAL_SIZE(ret)+1];
@


1.1.1.3
log
@import openssl-0.9.7d
@
text
@d235 1
a235 1
			BIO_snprintf(rcode, sizeof rcode, "%-8d", ret);
d564 1
a564 1
	BUF_strlcpy(file,X509_get_default_cert_area(),len + 1);
d566 1
a566 1
	BUF_strlcat(file,"/",len + 1);
d568 1
a568 1
	BUF_strlcat(file,OPENSSL_CONF,len + 1);
d579 1
a579 1
int CONF_parse_list(const char *list_, int sep, int nospc,
d584 1
a584 1
	lstart = list_;
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d129 1
a129 1
	char *vsection = NULL;
d136 2
a137 2
	if (appname)
		vsection = NCONF_get_string(cnf, NULL, appname);
d139 1
a139 2
	if (!appname || (!vsection && (flags & CONF_MFLAGS_DEFAULT_SECTION)))
		vsection = NCONF_get_string(cnf, NULL, "openssl_conf");
d234 1
a234 1
			CONFerr(CONF_F_MODULE_RUN, CONF_R_MODULE_INITIALIZATION_ERROR);
d257 1
a257 1
		ERR_clear_error();
d434 1
a434 1
		(void)sk_CONF_MODULE_delete(supported_modules, i);
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Stephen Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d585 1
a586 7
	if(list_ == NULL)
		{
		CONFerr(CONF_F_CONF_PARSE_LIST, CONF_R_LIST_CANNOT_BE_NULL);
		return 0;
		}

	lstart = list_;
@


