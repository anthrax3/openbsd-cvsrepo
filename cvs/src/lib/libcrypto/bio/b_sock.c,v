head	1.66;
access;
symbols
	OPENBSD_6_1:1.63.0.4
	OPENBSD_6_1_BASE:1.63;
locks; strict;
comment	@ * @;


1.66
date	2017.04.30.05.43.05;	author beck;	state Exp;
branches;
next	1.65;
commitid	IYauH85ec1R9FOlV;

1.65
date	2017.04.30.05.09.22;	author beck;	state Exp;
branches;
next	1.64;
commitid	7Myx9zgd1zIPIx24;

1.64
date	2017.04.30.04.18.58;	author beck;	state Exp;
branches;
next	1.63;
commitid	VxpuNSHhdkkZZoz9;

1.63
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.62;
commitid	kT0fLt3r4lroFJra;

1.62
date	2016.12.20.23.14.37;	author beck;	state Exp;
branches;
next	1.61;
commitid	eZW4hvcFp780Nhlq;

1.61
date	2014.12.03.22.14.38;	author bcook;	state Exp;
branches;
next	1.60;
commitid	eyhmVH3WXomJUIFD;

1.60
date	2014.12.03.21.55.51;	author bcook;	state Exp;
branches;
next	1.59;
commitid	B4tsOjVxJ4mu4DjV;

1.59
date	2014.11.26.05.37.26;	author bcook;	state Exp;
branches;
next	1.58;
commitid	gSfIogusXsvZaqAh;

1.58
date	2014.10.13.02.49.53;	author bcook;	state Exp;
branches;
next	1.57;
commitid	zZZmGtiQZAjCKqPd;

1.57
date	2014.10.13.02.39.09;	author bcook;	state Exp;
branches;
next	1.56;
commitid	VvwuDhmHxpenTtKI;

1.56
date	2014.07.16.10.43.06;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	PFHOuY8nugaBXESR;

1.55
date	2014.07.13.16.03.09;	author beck;	state Exp;
branches;
next	1.54;
commitid	6xdvCwSqBadTW6X3;

1.54
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.53;
commitid	yQEL1wOWIearrW15;

1.53
date	2014.07.10.21.57.40;	author miod;	state Exp;
branches;
next	1.52;
commitid	VT1DuA4AiaWbW93V;

1.52
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.51;
commitid	id8dTrTMtnTn4fqt;

1.51
date	2014.07.10.09.33.45;	author bcook;	state Exp;
branches;
next	1.50;
commitid	9i4beIgJXf0VRbEz;

1.50
date	2014.07.09.23.46.14;	author bcook;	state Exp;
branches;
next	1.49;
commitid	yvLrpAu2tkSD6JZp;

1.49
date	2014.07.09.15.19.52;	author bcook;	state Exp;
branches;
next	1.48;
commitid	kjTFeGv8AzKiIfpv;

1.48
date	2014.07.08.11.08.37;	author jsing;	state Exp;
branches;
next	1.47;
commitid	PbxKzlviac0uCM2R;

1.47
date	2014.07.08.11.05.41;	author jsing;	state Exp;
branches;
next	1.46;
commitid	PiNj5oYjQPNjr6lK;

1.46
date	2014.07.08.10.12.48;	author jsing;	state Exp;
branches;
next	1.45;
commitid	KiRX8dP3OrX6G0zA;

1.45
date	2014.07.08.09.46.44;	author jsing;	state Exp;
branches;
next	1.44;
commitid	zDTsa3MxZ9EBbSzA;

1.44
date	2014.07.08.09.06.49;	author jsing;	state Exp;
branches;
next	1.43;
commitid	ROTsNSSVTj4kwwOH;

1.43
date	2014.06.24.17.42.54;	author jsing;	state Exp;
branches;
next	1.42;
commitid	kESZ412koy9EWsfi;

1.42
date	2014.06.24.17.30.00;	author jsing;	state Exp;
branches;
next	1.41;
commitid	TaaCgAUQiHT8Zvyp;

1.41
date	2014.06.22.16.47.08;	author jsing;	state Exp;
branches;
next	1.40;
commitid	7BpxFspvwp28RWQJ;

1.40
date	2014.06.22.15.38.28;	author jsing;	state Exp;
branches;
next	1.39;
commitid	GHuhXcHp11jYJViu;

1.39
date	2014.06.22.14.41.10;	author jsing;	state Exp;
branches;
next	1.38;
commitid	MfMA4kud7U369nxn;

1.38
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	mJUVYpkFBZ0Zv2bG;

1.37
date	2014.06.08.14.19.24;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	bohd0oMxPNPmTY0c;

1.36
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2014.05.05.16.19.23;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2014.05.05.16.16.37;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.26.18.56.37;	author beck;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.23.20.59.36;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.23.20.22.37;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.23.20.21.23;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.18.21.41.15;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.18.14.37.41;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.18.11.33.33;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.17.22.22.28;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.17.22.19.56;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.13.29.21;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.16.19.42.24;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.16.15.00.28;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.15.17.25.41;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.15.16.37.21;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.13.23.31.37;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.06.09.22.53;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.00.02.57;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.16;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.07;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.39;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.55;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.36.15;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.39;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.41.35;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2011.11.03.02.32.08;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.35;	author djm;	state Exp;
branches;
next	;


desc
@@


1.66
log
@Make BIO_get_host_ip just yet another getaddrinfo wrapper
@
text
@/* $OpenBSD: b_sock.c,v 1.65 2017/04/30 05:09:22 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <sys/ioctl.h>
#include <sys/socket.h>
#include <string.h>

#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/tcp.h>

#include <errno.h>
#include <limits.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <openssl/err.h>

int
BIO_get_host_ip(const char *str, unsigned char *ip)
{
	struct addrinfo *res = NULL;
	struct addrinfo hints = {
		.ai_family = AF_INET,
		.ai_socktype = SOCK_STREAM,
		.ai_flags = AI_PASSIVE,
	};
	uint32_t *iap = (in_addr_t *)ip;
	int error;

	if (str == NULL) {
		ERR_asprintf_error_data("NULL host provided");
		return (0);
	}

	if ((error = getaddrinfo(str, NULL, &hints, &res)) != 0) {
		BIOerror(BIO_R_BAD_HOSTNAME_LOOKUP);
		ERR_asprintf_error_data("getaddrinfo: host='%s' : %s'", str,
		    gai_strerror(error));
		return (0);
	}
	*iap = (uint32_t)(((struct sockaddr_in *)(res->ai_addr))->sin_addr.s_addr);
	freeaddrinfo(res);
	return (1);
}

int
BIO_get_port(const char *str, unsigned short *port_ptr)
{
	struct addrinfo *res = NULL;
	struct addrinfo hints = {
		.ai_family = AF_UNSPEC,
		.ai_socktype = SOCK_STREAM,
		.ai_flags = AI_PASSIVE,
	};
	int error;

	if (str == NULL) {
		BIOerror(BIO_R_NO_PORT_SPECIFIED);
		return (0);
	}

	if ((error = getaddrinfo(NULL, str, &hints, &res)) != 0) {
		ERR_asprintf_error_data("getaddrinfo: service='%s' : %s'", str,
		    gai_strerror(error));
		return (0);
	}
	*port_ptr = ntohs(((struct sockaddr_in *)(res->ai_addr))->sin_port);
	freeaddrinfo(res);
	return (1);
}

int
BIO_sock_error(int sock)
{
	socklen_t len;
	int err;

	len = sizeof(err);
	if (getsockopt(sock, SOL_SOCKET, SO_ERROR, &err, &len) != 0)
		return (1);
	return (err);
}

struct hostent *
BIO_gethostbyname(const char *name)
{
	return gethostbyname(name);
}

int
BIO_socket_ioctl(int fd, long type, void *arg)
{
	int ret;

	ret = ioctl(fd, type, arg);
	if (ret < 0)
		SYSerror(errno);
	return (ret);
}

int
BIO_get_accept_socket(char *host, int bind_mode)
{
	struct addrinfo hints = {
		.ai_family = AF_INET,
		.ai_socktype = SOCK_STREAM,
		.ai_flags = AI_PASSIVE,
	};
	struct addrinfo *res = NULL;
	char *h, *p, *str = NULL;
	int error, ret = 0, s = -1;

	if (host == NULL || (str = strdup(host)) == NULL)
		return (-1);
	p = NULL;
	h = str;
	if ((p = strrchr(str, ':')) == NULL) {
		BIOerror(BIO_R_NO_PORT_SPECIFIED);
		goto err;
	}
	*p++ = '\0';
	if (*p == '\0') {
		BIOerror(BIO_R_NO_PORT_SPECIFIED);
		goto err;
	}
	if (*h == '\0' || strcmp(h, "*") == 0)
		h = NULL;

	if ((error = getaddrinfo(h, p, &hints, &res)) != 0) {
		ERR_asprintf_error_data("getaddrinfo: '%s:%s': %s'", h, p,
		    gai_strerror(error));
		goto err;
	}
	if (h == NULL) {
		struct sockaddr_in *sin = (struct sockaddr_in *)res->ai_addr;
		sin->sin_addr.s_addr = INADDR_ANY;
	}

	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (s == -1) {
		SYSerror(errno);
		ERR_asprintf_error_data("host='%s'", host);
		BIOerror(BIO_R_UNABLE_TO_CREATE_SOCKET);
		goto err;
	}
	if (bind_mode == BIO_BIND_REUSEADDR) {
		int i = 1;

		ret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &i, sizeof(i));
		bind_mode = BIO_BIND_NORMAL;
	}
	if (bind(s, res->ai_addr, res->ai_addrlen) == -1) {
		SYSerror(errno);
		ERR_asprintf_error_data("host='%s'", host);
		BIOerror(BIO_R_UNABLE_TO_BIND_SOCKET);
		goto err;
	}
	if (listen(s, SOMAXCONN) == -1) {
		SYSerror(errno);
		ERR_asprintf_error_data("host='%s'", host);
		BIOerror(BIO_R_UNABLE_TO_LISTEN_SOCKET);
		goto err;
	}
	ret = 1;

err:
	free(str);
	freeaddrinfo(res);
	if ((ret == 0) && (s != -1)) {
		close(s);
		s = -1;
	}
	return (s);
}

int
BIO_accept(int sock, char **addr)
{
	char   h[NI_MAXHOST], s[NI_MAXSERV];
	struct sockaddr_in sin;
	socklen_t sin_len = sizeof(sin);
	int ret = -1;

	if (addr == NULL)
		goto end;

	ret = accept(sock, (struct sockaddr *)&sin, &sin_len);
	if (ret == -1) {
		if (BIO_sock_should_retry(ret))
			return -2;
		SYSerror(errno);
		BIOerror(BIO_R_ACCEPT_ERROR);
		goto end;
	}
	/* XXX Crazy API. Can't be helped */
	if (*addr != NULL) {
		free(*addr);
		*addr = NULL;
	}

	if (sin.sin_family != AF_INET)
		goto end;

	if (getnameinfo((struct sockaddr *)&sin, sin_len, h, sizeof(h),
		s, sizeof(s), NI_NUMERICHOST|NI_NUMERICSERV) != 0)
		goto end;

	if ((asprintf(addr, "%s:%s", h, s)) == -1) {
		BIOerror(ERR_R_MALLOC_FAILURE);
		*addr = NULL;
		goto end;
	}
end:
	return (ret);
}

int
BIO_set_tcp_ndelay(int s, int on)
{
	return (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(on)) == 0);
}
@


1.65
log
@Rework BIO_accept to be more like modern code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.64 2017/04/30 04:18:58 beck Exp $ */
d81 12
a92 13
	int i;
	int err = 1;
	struct hostent *he;

	if (inet_pton(AF_INET, str, ip) == 1)
		return (1);

	/* do a gethostbyname */
	CRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);
	he = BIO_gethostbyname(str);
	if (he == NULL) {
		BIOerror(BIO_R_BAD_HOSTNAME_LOOKUP);
		goto err;
d95 5
a99 3
	if (he->h_addrtype != AF_INET) {
		BIOerror(BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);
		goto err;
d101 3
a103 11
	for (i = 0; i < 4; i++)
		ip[i] = he->h_addr_list[0][i];
	err = 0;

err:
	CRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);
	if (err) {
		ERR_asprintf_error_data("host=%s", str);
		return 0;
	} else
		return 1;
@


1.64
log
@Microsoft Windows hates BIO_get_accept_socket in portable. Fix it to
not be awful or have any claims on supporting ipv6 when it does so
very badly
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.63 2017/01/29 17:49:22 beck Exp $ */
d246 3
d250 5
a254 16
	unsigned long l;
	unsigned short port;
	char *p, *tmp;

	struct {
		socklen_t len;
		union {
			struct sockaddr sa;
			struct sockaddr_in sa_in;
			struct sockaddr_in6 sa_in6;
		} from;
	} sa;

	sa.len = sizeof(sa.from);
	memset(&sa.from, 0, sizeof(sa.from));
	ret = accept(sock, &sa.from.sa, &sa.len);
d262 5
d268 1
a268 1
	if (addr == NULL)
d271 2
a272 22
	do {
		char   h[NI_MAXHOST], s[NI_MAXSERV];
		size_t nl;

		if (getnameinfo(&sa.from.sa, sa.len, h, sizeof(h),
		    s, sizeof(s), NI_NUMERICHOST|NI_NUMERICSERV))
			break;
		nl = strlen(h) + strlen(s) + 2;
		p = *addr;
		if (p)
			*p = '\0';
		if (!(tmp = realloc(p, nl))) {
			close(ret);
			ret = -1;
			free(p);
			*addr = NULL;
			BIOerror(ERR_R_MALLOC_FAILURE);
			goto end;
		}
		p = tmp;
		*addr = p;
		snprintf(*addr, nl, "%s:%s", h, s);
d274 4
a277 2
	} while (0);
	if (sa.from.sa.sa_family != AF_INET)
d279 1
a279 15
	l = ntohl(sa.from.sa_in.sin_addr.s_addr);
	port = ntohs(sa.from.sa_in.sin_port);
	if (*addr == NULL) {
		if ((p = malloc(24)) == NULL) {
			close(ret);
			ret = -1;
			BIOerror(ERR_R_MALLOC_FAILURE);
			goto end;
		}
		*addr = p;
	}
	snprintf(*addr, 24, "%d.%d.%d.%d:%d",
	    (unsigned char)(l >> 24L) & 0xff, (unsigned char)(l >> 16L) & 0xff,
	    (unsigned char)(l >> 8L) & 0xff, (unsigned char)(l) & 0xff, port);

@


1.63
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.62 2016/12/20 23:14:37 beck Exp $ */
d171 8
a178 13
	int ret = 0;
	union {
		struct sockaddr sa;
		struct sockaddr_in sa_in;
		struct sockaddr_in6 sa_in6;
	} server, client;
	int s = -1, cs, addrlen;
	unsigned char ip[4];
	unsigned short port;
	char *str = NULL, *e;
	char *h, *p;
	unsigned long l;
	int err_num;
d182 1
a182 2

	h = p = NULL;
d184 11
a194 46
	for (e = str; *e; e++) {
		if (*e == ':') {
			p = e;
		} else if (*e == '/') {
			*e = '\0';
			break;
		}
	}
	/* points at last ':', '::port' is special [see below] */
	if (p)
		*p++ = '\0';
	else
		p = h, h = NULL;

	do {
		struct addrinfo *res, hint;

		/*
		 * '::port' enforces IPv6 wildcard listener. Some OSes,
		 * e.g. Solaris, default to IPv6 without any hint. Also
		 * note that commonly IPv6 wildchard socket can service
		 * IPv4 connections just as well...
		 */
		memset(&hint, 0, sizeof(hint));
		hint.ai_flags = AI_PASSIVE;
		if (h) {
			if (strchr(h, ':')) {
				if (h[1] == '\0')
					h = NULL;
				hint.ai_family = AF_INET6;
			} else if (h[0] == '*' && h[1] == '\0') {
				hint.ai_family = AF_INET;
				h = NULL;
			}
		}

		if (getaddrinfo(h, p, &hint, &res))
			break;

		addrlen = res->ai_addrlen <= sizeof(server) ?
		    res->ai_addrlen : sizeof(server);
		memcpy(&server, res->ai_addr, addrlen);

		freeaddrinfo(res);
		goto again;
	} while (0);
d196 3
a198 1
	if (!BIO_get_port(p, &port))
d200 4
a203 16

	memset((char *)&server, 0, sizeof(server));
	server.sa_in.sin_family = AF_INET;
	server.sa_in.sin_port = htons(port);
	addrlen = sizeof(server.sa_in);

	if (h == NULL || strcmp(h, "*") == 0)
		server.sa_in.sin_addr.s_addr = INADDR_ANY;
	else {
		if (!BIO_get_host_ip(h, &(ip[0])))
			goto err;
		l = (unsigned long)((unsigned long)ip[0]<<24L)|
		    ((unsigned long)ip[1]<<16L)|
		    ((unsigned long)ip[2]<< 8L)|
		    ((unsigned long)ip[3]);
		server.sa_in.sin_addr.s_addr = htonl(l);
d206 1
a206 2
again:
	s = socket(server.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
d209 1
a209 1
		ERR_asprintf_error_data("port='%s'", host);
a212 1

d219 3
a221 32
	if (bind(s, &server.sa, addrlen) == -1) {
		err_num = errno;
		if ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) &&
		    (err_num == EADDRINUSE)) {
			client = server;
			if (h == NULL || strcmp(h, "*") == 0) {
				if (client.sa.sa_family == AF_INET6) {
					memset(&client.sa_in6.sin6_addr, 0,
					    sizeof(client.sa_in6.sin6_addr));
					client.sa_in6.sin6_addr.s6_addr[15] = 1;
				} else if (client.sa.sa_family == AF_INET) {
					client.sa_in.sin_addr.s_addr =
					    htonl(0x7F000001);
				} else
					goto err;
			}
			cs = socket(client.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
			if (cs != -1) {
				int ii;
				ii = connect(cs, &client.sa, addrlen);
				close(cs);
				if (ii == -1) {
					bind_mode = BIO_BIND_REUSEADDR;
					close(s);
					goto again;
				}
				/* else error */
			}
			/* else error */
		}
		SYSerror(err_num);
		ERR_asprintf_error_data("port='%s'", host);
d227 1
a227 1
		ERR_asprintf_error_data("port='%s'", host);
d232 1
d235 1
@


1.62
log
@Delete completely useless crap and just use getaddrinfo. Fix man page
while we're at it.
Note for the nostalgic, since "wais" is still an alias in /etc/services
it will continue to work..
ok deraadt@@ millert@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.61 2014/12/03 22:14:38 bcook Exp $ */
d92 1
a92 1
		BIOerr(BIO_F_BIO_GET_HOST_IP, BIO_R_BAD_HOSTNAME_LOOKUP);
d97 1
a97 2
		BIOerr(BIO_F_BIO_GET_HOST_IP,
		    BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);
d125 1
a125 1
		BIOerr(BIO_F_BIO_GET_PORT, BIO_R_NO_PORT_SPECIFIED);
d164 1
a164 1
		SYSerr(SYS_F_IOCTLSOCKET, errno);
d260 1
a260 1
		SYSerr(SYS_F_SOCKET, errno);
d262 1
a262 2
		BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,
		    BIO_R_UNABLE_TO_CREATE_SOCKET);
d302 1
a302 1
		SYSerr(SYS_F_BIND, err_num);
d304 1
a304 2
		BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,
		    BIO_R_UNABLE_TO_BIND_SOCKET);
d308 1
a308 1
		SYSerr(SYS_F_BIND, errno);
d310 1
a310 2
		BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,
		    BIO_R_UNABLE_TO_LISTEN_SOCKET);
d346 2
a347 2
		SYSerr(SYS_F_ACCEPT, errno);
		BIOerr(BIO_F_BIO_ACCEPT, BIO_R_ACCEPT_ERROR);
d370 1
a370 1
			BIOerr(BIO_F_BIO_ACCEPT, ERR_R_MALLOC_FAILURE);
d386 1
a386 1
			BIOerr(BIO_F_BIO_ACCEPT, ERR_R_MALLOC_FAILURE);
@


1.61
log
@Move Windows OS-specific functions to make porting easier.

Several functions that need to be redefined for a Windows port are right
in the middle of other code that is relatively portable. This patch
isolates the functions that need Windows-specific implementations so
they can be built conditionally in the portable tree.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.60 2014/12/03 21:55:51 bcook Exp $ */
d123 1
a123 2
	long port;
	char *ep;
d130 3
a132 36
	errno = 0;
	port = strtol(str, &ep, 10);
	if (str[0] != '\0' && *ep == '\0') {
		if (errno == ERANGE && (port == LONG_MAX || port == LONG_MIN)) {
			BIOerr(BIO_F_BIO_GET_PORT, BIO_R_INVALID_PORT_NUMBER);
			return (0);
		}
		if (port < 0 || port > 65535) {
			BIOerr(BIO_F_BIO_GET_PORT, BIO_R_INVALID_PORT_NUMBER);
			return (0);
		}
		goto done;
	}

	if (getaddrinfo(NULL, str, &hints, &res) == 0) {
		port = ntohs(((struct sockaddr_in *)(res->ai_addr))->sin_port);
		goto done;
	}

	if (strcmp(str, "http") == 0)
		port = 80;
	else if (strcmp(str, "telnet") == 0)
		port = 23;
	else if (strcmp(str, "socks") == 0)
		port = 1080;
	else if (strcmp(str, "https") == 0)
		port = 443;
	else if (strcmp(str, "ssl") == 0)
		port = 443;
	else if (strcmp(str, "ftp") == 0)
		port = 21;
	else if (strcmp(str, "gopher") == 0)
		port = 70;
	else {
		SYSerr(SYS_F_GETSERVBYNAME, errno);
		ERR_asprintf_error_data("service='%s'", str);
d135 2
a136 5

done:
	if (res)
		freeaddrinfo(res);
	*port_ptr = (unsigned short)port;
@


1.60
log
@We're not supporting 16-bit Windows, remove cast.

ok jsing@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.59 2014/11/26 05:37:26 bcook Exp $ */
a67 1
#include <fcntl.h>
a195 11
BIO_sock_init(void)
{
	return (1);
}

void
BIO_sock_cleanup(void)
{
}

int
a443 11
}

int
BIO_socket_nbio(int s, int mode)
{
	int flags = fcntl(s, F_GETFD);
	if (mode && !(flags & O_NONBLOCK))
		return (fcntl(s, F_SETFL, flags | O_NONBLOCK) != -1);
	else if (!mode && (flags & O_NONBLOCK))
		return (fcntl(s, F_SETFL, flags & ~O_NONBLOCK) != -1);
	return (1);
@


1.59
log
@normalize set/getsockopt usage.

Remove the remaining random casts on optval. Fixups for this can be handled by
the portability layer all in once place.

Remove remaining fake socklen_t unions, though beck@@ points out that this also
removes support for socklen_t changing its length at runtime. RIP.

ok tedu@@ beck@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.58 2014/10/13 02:49:53 bcook Exp $ */
d97 1
a97 2
	/* cast to short because of win16 winsock definition */
	if ((short)he->h_addrtype != AF_INET) {
@


1.58
log
@The return value on success of fcntl(F_SETFL) is not actually specified,
only that it returns -1 on failure.

pointed out by guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.57 2014/10/13 02:39:09 bcook Exp $ */
d321 1
a321 2
		ret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&i,
		    sizeof(i));
@


1.57
log
@Use O_NONBLOCK over FIONBIO.

Prefer this because it is the POSIX standard and has consistent behavior
across platforms.

Use BIO_socket_nbio consistently across the tree.

from Jonas 'Sortie' Termansen, ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.56 2014/07/16 10:43:06 deraadt Exp $ */
d465 1
a465 1
		return (fcntl(s, F_SETFL, flags | O_NONBLOCK) == 0);
d467 1
a467 1
		return (fcntl(s, F_SETFL, flags & ~O_NONBLOCK) == 0);
@


1.56
log
@do not need a variable to track locking, since all code paths have it
locked throughout.
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.55 2014/07/13 16:03:09 beck Exp $ */
d68 1
d463 6
a468 1
	return (BIO_socket_ioctl(s, FIONBIO, &mode) == 0);
@


1.55
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.54 2014/07/11 08:44:47 jsing Exp $ */
a82 1
	int locked = 0;
a89 1
	locked = 1;
d107 1
a107 2
	if (locked)
		CRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);
@


1.54
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.53 2014/07/10 21:57:40 miod Exp $ */
d238 1
a238 1
	if ((str = BUF_strdup(host)) == NULL)
@


1.53
log
@Simplify realloc() usage; ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.52 2014/07/10 13:58:22 jsing Exp $ */
d75 2
a76 2

#include "cryptlib.h"
@


1.52
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.51 2014/07/10 09:33:45 bcook Exp $ */
d420 1
a420 1
		if (p) {
d422 1
a422 13
			if (!(tmp = realloc(p, nl))) {
				close(ret);
				ret = -1;
				free(p);
				*addr = NULL;
				BIOerr(BIO_F_BIO_ACCEPT, ERR_R_MALLOC_FAILURE);
				goto end;
			}
			p = tmp;
		} else {
			p = malloc(nl);
		}
		if (p == NULL) {
d425 2
d430 1
@


1.51
log
@replace getservbyname_r with getaddrinfo for portability

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.50 2014/07/09 23:46:14 bcook Exp $ */
d61 1
@


1.50
log
@include <limits.h> for LONG_MIN/LONG_MAX.

Also remove <sys/filio.h> added from previous commit.
This was the wrong way to get FIONBIO.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.49 2014/07/09 15:19:52 bcook Exp $ */
d120 6
a125 2
	struct servent_data sd;
	struct servent se;
d148 2
a149 3
	memset(&sd, 0, sizeof(sd));
	if (getservbyname_r(str, "tcp", &se, &sd) == 0) {
		port = ntohs((unsigned short)se.s_port);
d174 2
@


1.49
log
@add <sys/filio.h> header for FIONBIO

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.48 2014/07/08 11:08:37 jsing Exp $ */
a58 1
#include <sys/filio.h>
d67 1
@


1.48
log
@Pretty much everything has SO_REUSEADDR - nuke the #ifdefs.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.47 2014/07/08 11:05:41 jsing Exp $ */
d59 1
@


1.47
log
@We have EAI_FAMILY - remove the #ifdefs.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.46 2014/07/08 10:12:48 jsing Exp $ */
a312 1
#ifdef SO_REUSEADDR
a319 1
#endif
a320 1
#ifdef SO_REUSEADDR
a349 1
#endif
@


1.46
log
@More KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.45 2014/07/08 09:46:44 jsing Exp $ */
a249 1
#ifdef EAI_FAMILY
a281 1
#endif
a407 1
#ifdef EAI_FAMILY
a440 1
#endif
@


1.45
log
@Avoid locking in BIO_get_port() by using getservbyname_r() instead of
getservbyname(). While here, provide a common/single return path.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.44 2014/07/08 09:06:49 jsing Exp $ */
d98 2
a99 1
		BIOerr(BIO_F_BIO_GET_HOST_IP, BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);
d244 1
d246 1
a246 1
		*p++='\0';	/* points at last ':', '::port' is special [see below] */
d254 2
a255 1
		/* '::port' enforces IPv6 wildcard listener. Some OSes,
d258 2
a259 1
		 * IPv4 connections just as well...  */
d310 2
a311 1
		BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET, BIO_R_UNABLE_TO_CREATE_SOCKET);
d319 2
a320 1
		ret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&i, sizeof(i));
d332 2
a333 1
					memset(&client.sa_in6.sin6_addr, 0, sizeof(client.sa_in6.sin6_addr));
d336 2
a337 1
					client.sa_in.sin_addr.s_addr = htonl(0x7F000001);
d358 2
a359 1
		BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET, BIO_R_UNABLE_TO_BIND_SOCKET);
d365 2
a366 1
		BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET, BIO_R_UNABLE_TO_LISTEN_SOCKET);
@


1.44
log
@Simplify various BIO_sock_* fuctions - less code, better variable names,
correct types and fewer casts.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.43 2014/06/24 17:42:54 jsing Exp $ */
d118 2
a119 1
	struct servent *s;
d139 2
d142 4
a145 2
		*port_ptr = (unsigned short)port;
		return (1);
d147 19
a165 27
	
	CRYPTO_w_lock(CRYPTO_LOCK_GETSERVBYNAME);
	s = getservbyname(str, "tcp");
	if (s != NULL)
		*port_ptr = ntohs((unsigned short)s->s_port);
	CRYPTO_w_unlock(CRYPTO_LOCK_GETSERVBYNAME);

	if (s == NULL) {
		if (strcmp(str, "http") == 0)
			*port_ptr = 80;
		else if (strcmp(str, "telnet") == 0)
			*port_ptr = 23;
		else if (strcmp(str, "socks") == 0)
			*port_ptr = 1080;
		else if (strcmp(str, "https") == 0)
			*port_ptr = 443;
		else if (strcmp(str, "ssl") == 0)
			*port_ptr = 443;
		else if (strcmp(str, "ftp") == 0)
			*port_ptr = 21;
		else if (strcmp(str, "gopher") == 0)
			*port_ptr = 70;
		else {
			SYSerr(SYS_F_GETSERVBYNAME, errno);
			ERR_asprintf_error_data("service='%s'", str);
			return (0);
		}
d167 3
@


1.43
log
@Replace 48 lines of code with a single inet_pton() call. The previous
handrolled version could not even make use of sscanf(), since that would
not work with a certain antiquated compiler.

It is worth noting that there is a tiny change in behaviour - previously
calling BIO_get_host_ip() with something that looked like it might be a
valid IP address (for example, "1." or even ".") would result in it
returning failure rather than trying a BIO_gethostbyname() - now we'll
always try a BIO_gethostbyname() if it was not a valid IPv4 address.

ok beck@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.42 2014/06/24 17:30:00 jsing Exp $ */
d176 2
a177 2
	int j, i;
	int size;
d179 2
a180 8
	size = sizeof(int);
	/* Note: under Windows the third parameter is of type (char *)
	 * whereas under other systems it is (void *) if you don't have
	 * a cast it will choke the compiler: if you do have a cast then
	 * you can either go for (char *) or (void *).
	 */
	i = getsockopt(sock, SOL_SOCKET, SO_ERROR, (void *)&j, (void *)&size);
	if (i < 0)
d182 1
a182 2
	else
		return (j);
d205 1
a205 1
	int i;
d207 2
a208 4
#  define ARG arg

	i = ioctl(fd, type, ARG);
	if (i < 0)
d210 1
a210 1
	return (i);
d465 1
a465 7
	int ret = -1;
	int l;

	l = mode;
	ret = BIO_socket_ioctl(s, FIONBIO, &l);

	return (ret == 0);
@


1.42
log
@Actually make BIO_set_tcp_ndelay() work - TCP_NODELAY will not magically
appear by itself.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.41 2014/06/22 16:47:08 jsing Exp $ */
d62 1
a75 2
static int get_ip(const char *str, unsigned char *ip);

d84 1
a84 9
	i = get_ip(str, ip);
	if (i < 0) {
		BIOerr(BIO_F_BIO_GET_HOST_IP, BIO_R_INVALID_IP_ADDRESS);
		goto err;
	}

	/* If the string actually contained an IP address, we need not do
	   anything more */
	if (i > 0)
a219 36
}

/* The reason I have implemented this instead of using sscanf is because
 * Visual C 1.52c gives an unresolved external when linking a DLL :-( */
static int
get_ip(const char *str, unsigned char ip[4])
{
	unsigned int tmp[4];
	int num = 0, c, ok = 0;

	tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;

	for (;;) {
		c= *(str++);
		if ((c >= '0') && (c <= '9')) {
			ok = 1;
			tmp[num] = tmp[num]*10 + c-'0';
			if (tmp[num] > 255)
				return (0);
		} else if (c == '.') {
			if (!ok)
				return (-1);
			if (num == 3)
				return (0);
			num++;
			ok = 0;
		} else if (c == '\0' && (num == 3) && ok)
			break;
		else
			return (0);
	}
	ip[0] = tmp[0];
	ip[1] = tmp[1];
	ip[2] = tmp[2];
	ip[3] = tmp[3];
	return (1);
@


1.41
log
@BIO_sock_init() no longer does anything, so stop calling it.
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.40 2014/06/22 15:38:28 jsing Exp $ */
d63 1
d513 1
a513 15
	int ret = 0;
#if defined(TCP_NODELAY) && (defined(IPPROTO_TCP) || defined(SOL_TCP))
	int opt;

#ifdef SOL_TCP
	opt = SOL_TCP;
#else
#ifdef IPPROTO_TCP
	opt = IPPROTO_TCP;
#endif
#endif

	ret = setsockopt(s, opt, TCP_NODELAY, (char *)&on, sizeof(on));
#endif
	return (ret == 0);
@


1.40
log
@Just use SOMAXCONN and IPPROTO_TCP, since we know we have them.
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.39 2014/06/22 14:41:10 jsing Exp $ */
a89 5
	/* At this point, we have something that is most probably correct
	   in some way, so let's init the socket. */
	if (BIO_sock_init() != 1)
		return 0; /* don't generate another error code here */

a205 1

a281 3

	if (BIO_sock_init() != 1)
		return (-1);
@


1.39
log
@In BIO_get_port(), use strol() with appropriate range checks rather than
an atoi() followed by an unsigned short cast. This stops things like "-1"
and "66536" from being considered to be "valid" port numbers.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: b_sock.c,v 1.38 2014/06/12 15:49:28 deraadt Exp $ */
a73 10
#define SOCKET_PROTOCOL IPPROTO_TCP

#ifdef SO_MAXCONN
#define MAX_LISTEN  SO_MAXCONN
#elif defined(SOMAXCONN)
#define MAX_LISTEN  SOMAXCONN
#else
#define MAX_LISTEN  32
#endif

d364 1
a364 1
	s = socket(server.sa.sa_family, SOCK_STREAM, SOCKET_PROTOCOL);
d395 1
a395 1
			cs = socket(client.sa.sa_family, SOCK_STREAM, SOCKET_PROTOCOL);
d415 1
a415 1
	if (listen(s, MAX_LISTEN) == -1) {
@


1.38
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a140 1
	int i;
d142 2
d146 1
a146 1
		BIOerr(BIO_F_BIO_GET_PORT, BIO_R_NO_PORT_DEFINED);
d149 42
a190 29
	i = atoi(str);
	if (i != 0)
		*port_ptr = (unsigned short)i;
	else {
		CRYPTO_w_lock(CRYPTO_LOCK_GETSERVBYNAME);
		s = getservbyname(str, "tcp");
		if (s != NULL)
			*port_ptr = ntohs((unsigned short)s->s_port);
		CRYPTO_w_unlock(CRYPTO_LOCK_GETSERVBYNAME);
		if (s == NULL) {
			if (strcmp(str, "http") == 0)
				*port_ptr = 80;
			else if (strcmp(str, "telnet") == 0)
				*port_ptr = 23;
			else if (strcmp(str, "socks") == 0)
				*port_ptr = 1080;
			else if (strcmp(str, "https") == 0)
				*port_ptr = 443;
			else if (strcmp(str, "ssl") == 0)
				*port_ptr = 443;
			else if (strcmp(str, "ftp") == 0)
				*port_ptr = 21;
			else if (strcmp(str, "gopher") == 0)
				*port_ptr = 70;
			else {
				SYSerr(SYS_F_GETSERVBYNAME, errno);
				ERR_asprintf_error_data("service='%s'", str);
				return (0);
			}
@


1.37
log
@Stop using DSO_global_lookup to reach getaddrinfo() and friends
discussed with tedu, ok jsing
@
text
@d1 1
a1 1
/* crypto/bio/b_sock.c */
@


1.36
log
@more: no need for null check before free
ok tedu guenther
@
text
@a70 1
#include <openssl/dso.h>
a307 10
		static union {
			void *p;
			int (*f)(const char *, const char *,
			    const struct addrinfo *,
			    struct addrinfo **);
		} p_getaddrinfo = {NULL};
		static union {
			void *p;
			void (*f)(struct addrinfo *);
		} p_freeaddrinfo = {NULL};
a309 8
		if (p_getaddrinfo.p == NULL) {
			if ((p_getaddrinfo.p = DSO_global_lookup("getaddrinfo"))==NULL ||
			    (p_freeaddrinfo.p = DSO_global_lookup("freeaddrinfo"))==NULL)
				p_getaddrinfo.p = (void*) - 1;
		}
		if (p_getaddrinfo.p == (void *) - 1)
			break;

d327 1
a327 1
		if ((*p_getaddrinfo.f)(h, p, &hint, &res))
d334 1
a334 1
		(*p_freeaddrinfo.f)(res);
a461 18
		static union {
			void *p;
			int (*f)(const struct sockaddr *,
			socklen_t, char *, size_t,
			    char *, size_t, int);
		} p_getnameinfo = {NULL};
		/* 2nd argument to getnameinfo is specified to
		 * be socklen_t. Unfortunately there is a number
		 * of environments where socklen_t is not defined.
		 * As it's passed by value, it's safe to pass it
		 * as size_t... <appro> */

		if (p_getnameinfo.p == NULL) {
			if ((p_getnameinfo.p = DSO_global_lookup("getnameinfo")) == NULL)
				p_getnameinfo.p = (void*) - 1;
		}
		if (p_getnameinfo.p == (void *) - 1)
			break;
d463 1
a463 1
		if ((*p_getnameinfo.f)(&sa.from.sa, sa.len, h, sizeof(h),
@


1.35
log
@Sort and group includes.
@
text
@d438 1
a438 2
	if (str != NULL)
		free(str);
@


1.34
log
@Repair BIO_socket_nbio operation.

ok miod@@
@
text
@d60 3
d64 2
d69 1
a69 2
#include <errno.h>
#include "cryptlib.h"
d71 1
a71 1
#include <sys/ioctl.h>
d73 1
a73 6
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>


#include <openssl/dso.h>
@


1.33
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d59 2
a579 1
#ifdef FIONBIO
d581 1
a581 1
#endif
@


1.32
log
@The usual idiom to cope with systems not defining socklen_t is to add a
#define socklen_t int
somewhere (or a typedef, whatever gives you an integer type of the size
your system expects as the 3rd argument of accept(2), really).

OpenSSL here is a bit more creative by using an union of an int and a size_t,
and extra code if sizeof(int) != sizeof(size_t) in order to recover the
proper size. With a comment mentioning that this has no chance to work on
a platform with a stack growing up and accept() returning an int, fortunately
this seems to work on HP-UX.

Switch to the light side of the force and declare and use socklen_t variables,
period. If your system does not define socklen_t, consider bringing it back
to your vendor for a refund.

ok matthew@@ tedu@@
@
text
@d132 1
a132 1
		ERR_add_error_data(2, "host=", str);
d174 1
a174 1
				ERR_add_error_data(3, "service='", str, "'");
d381 1
a381 1
		ERR_add_error_data(3, "port='", host, "'");
d425 1
a425 1
		ERR_add_error_data(3, "port='", host, "'");
d431 1
a431 1
		ERR_add_error_data(3, "port='", host, "'");
@


1.31
log
@close socket in failure cases too
@
text
@d455 1
a455 25
		/*
		 * As for following union. Trouble is that there are platforms
		 * that have socklen_t and there are platforms that don't, on
		 * some platforms socklen_t is int and on some size_t. So what
		 * one can do? One can cook #ifdef spaghetti, which is nothing
		 * but masochistic. Or one can do union between int and size_t.
		 * One naturally does it primarily for 64-bit platforms where
		 * sizeof(int) != sizeof(size_t). But would it work? Note that
		 * if size_t member is initialized to 0, then later int member
		 * assignment naturally does the job on little-endian platforms
		 * regardless accept's expectations! What about big-endians?
		 * If accept expects int*, then it works, and if size_t*, then
		 * length value would appear as unreasonably large. But this
		 * won't prevent it from filling in the address structure. The
		 * trouble of course would be if accept returns more data than
		 * actual buffer can accomodate and overwrite stack... That's
		 * where early OPENSSL_assert comes into picture. Besides, the
		 * only 64-bit big-endian platform found so far that expects
		 * size_t* is HP-UX, where stack grows towards higher address.
		 * <appro>
		 */
		union {
			size_t s;
			int i;
		} len;
d463 1
a463 2
	sa.len.s = 0;
	sa.len.i = sizeof(sa.from);
d465 1
a465 6
	ret = accept(sock, &sa.from.sa, (void *)&sa.len);
	if (sizeof(sa.len.i) != sizeof(sa.len.s) && sa.len.i == 0) {
		OPENSSL_assert(sa.len.s <= sizeof(sa.from));
		sa.len.i = (int)sa.len.s;
		/* use sa.len.i from this point */
	}
d484 1
a484 1
			size_t/*socklen_t*/, char *, size_t,
d500 1
a500 1
		if ((*p_getnameinfo.f)(&sa.from.sa, sa.len.i, h, sizeof(h),
@


1.30
log
@if realloc failed, BIO_accept would leak memory and return NULL, causing
caller to crash. Fix leak and return an error instead. from Chad Loder
@
text
@d538 1
d550 1
d566 1
@


1.29
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d452 1
a452 1
	char *p;
d537 8
a544 1
			p = realloc(p, nl);
d549 1
d564 1
@


1.28
log
@unifdef NO_SOCK
@
text
@d546 1
a546 1
		(void) snprintf(*addr, nl, "%s:%s", h, s);
d561 1
a561 1
	(void) snprintf(*addr, 24, "%d.%d.%d.%d:%d",
@


1.27
log
@Put the final pieces from e_os.h in the required places, and remove it.
"dance on it's grave" says beck
ok guenther beck
@
text
@a70 1
#ifndef OPENSSL_NO_SOCK
a600 1
#endif
@


1.26
log
@unistd.h for protos where needed
@
text
@a275 1
#if OPENSSL_USE_IPV6
a276 1
#endif
a338 1
#if OPENSSL_USE_IPV6
a339 3
#else
				h = NULL;
#endif
a401 1
#if OPENSSL_USE_IPV6
d405 1
a405 3
				} else
#endif
				if (client.sa.sa_family == AF_INET) {
a483 1
#if OPENSSL_USE_IPV6
a484 1
#endif
@


1.25
log
@more windows/netware leftovers
@
text
@d61 1
@


1.24
log
@delete if 0 code
@
text
@a83 15
#if defined(OPENSSL_SYS_WINDOWS) || (defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK))
static int wsa_init_done = 0;
#endif

/*
 * WSAAPI specifier is required to make indirect calls to run-time
 * linked WinSock 2 functions used in this module, to be specific
 * [get|free]addrinfo and getnameinfo. This is because WinSock uses
 * uses non-C calling convention, __stdcall vs. __cdecl, on x86
 * Windows. On non-WinSock platforms WSAAPI needs to be void.
 */
#ifndef WSAAPI
#define WSAAPI
#endif

d312 1
a312 1
			int (WSAAPI *f)(const char *, const char *,
d318 1
a318 1
			void (WSAAPI *f)(struct addrinfo *);
d524 1
a524 1
			int (WSAAPI *f)(const struct sockaddr *,
@


1.23
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@a98 12
#if 0
static unsigned long BIO_ghbn_hits = 0L;
static unsigned long BIO_ghbn_miss = 0L;

#define GHBN_NUM	4
static struct ghbn_cache_st {
	char name[129];
	struct hostent *ent;
	unsigned long order;
} ghbn_cache[GHBN_NUM];
#endif

a99 4
#if 0
static void ghbn_free(struct hostent *a);
static struct hostent *ghbn_dup(struct hostent *a);
#endif
a186 4
#if 0
			else if (strcmp(str, "wais") == 0)
				*port_ptr = 21;
#endif
a202 4
#if defined(OPENSSL_SYS_BEOS_R5)
	return 0;
#endif

a238 3
#ifdef __DJGPP__
	i = ioctl(fd, type, (char *)arg);
#else
a241 1
#endif /* __DJGPP__ */
@


1.22
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a61 1
#define USE_SOCKETS
d64 2
a65 1
#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_BSDSOCK)
d67 2
a68 5
#if defined(NETWARE_CLIB)
#include <sys/ioctl.h>
NETDB_DEFINE_CONTEXT
#endif
#endif
@


1.21
log
@Revert unintended whitespace changes.
@
text
@d493 1
a493 1
		OPENSSL_free(str);
d594 1
a594 1
			p = OPENSSL_realloc(p, nl);
d596 1
a596 1
			p = OPENSSL_malloc(nl);
d612 1
a612 1
		if ((p = OPENSSL_malloc(24)) == NULL) {
@


1.20
log
@> As I walk through the valley of the shadow of death
> I take a look at my life and realize there's nothin' left
> Cause I've been blasting and laughing so long,
> That even my mama thinks that my mind is gone
Remove even more unspeakable evil being perpetuated in the name of VMS.
(and lesser evils done in the name of others.)
ok miod
@
text
@d212 1
a212 1
				ERR_add_error_data(3, "service = '", str, "'");
d433 1
a433 1
		ERR_add_error_data(3, "port = '", host, "'");
d480 1
a480 1
		ERR_add_error_data(3, "port = '", host, "'");
d486 1
a486 1
		ERR_add_error_data(3, "port = '", host, "'");
@


1.19
log
@More KNF.
@
text
@a186 6
		/* Note: under VMS with SOCKETSHR, it seems like the first
		 * parameter is 'char *', instead of 'const char *'
		 */
#ifndef CONST_STRICT
		s = getservbyname((char *)str, "tcp");
#else
a187 1
#endif
d243 2
a244 123
#if 0
long
BIO_ghbn_ctrl(int cmd, int iarg, char *parg)
{
	int i;
	char **p;

	switch (cmd) {
	case BIO_GHBN_CTRL_HITS:
		return (BIO_ghbn_hits);
		/* break; */
	case BIO_GHBN_CTRL_MISSES:
		return (BIO_ghbn_miss);
		/* break; */
	case BIO_GHBN_CTRL_CACHE_SIZE:
		return (GHBN_NUM);
		/* break; */
	case BIO_GHBN_CTRL_GET_ENTRY:
		if ((iarg >= 0) && (iarg < GHBN_NUM) &&
		    (ghbn_cache[iarg].order > 0)) {
			p = (char **)parg;
			if (p == NULL)
				return (0);
			*p = ghbn_cache[iarg].name;
			ghbn_cache[iarg].name[128] = '\0';
			return (1);
		}
		return (0);
		/* break; */
	case BIO_GHBN_CTRL_FLUSH:
		for (i = 0; i < GHBN_NUM; i++)
			ghbn_cache[i].order = 0;
		break;
	default:
		return (0);
	}
	return (1);
}
#endif

#if 0
static struct hostent
*ghbn_dup(struct hostent *a)
{
	struct hostent *ret;
	int i, j;

	MemCheck_off();
	ret = (struct hostent *)OPENSSL_malloc(sizeof(struct hostent));
	if (ret == NULL)
		return (NULL);
	memset(ret, 0, sizeof(struct hostent));

	for (i = 0; a->h_aliases[i] != NULL; i++)
		;
	i++;
	ret->h_aliases = (char **)OPENSSL_malloc(i*sizeof(char *));
	if (ret->h_aliases == NULL)
		goto err;
	memset(ret->h_aliases, 0, i*sizeof(char *));

	for (i = 0; a->h_addr_list[i] != NULL; i++)
		;
	i++;
	ret->h_addr_list = (char **)OPENSSL_malloc(i*sizeof(char *));
	if (ret->h_addr_list == NULL)
		goto err;
	memset(ret->h_addr_list, 0, i*sizeof(char *));

	j = strlen(a->h_name) + 1;
	if ((ret->h_name = OPENSSL_malloc(j)) == NULL)
		goto err;
	memcpy((char *)ret->h_name, a->h_name, j);
	for (i = 0; a->h_aliases[i] != NULL; i++) {
		j = strlen(a->h_aliases[i]) + 1;
		if ((ret->h_aliases[i] = OPENSSL_malloc(j)) == NULL)
			goto err;
		memcpy(ret->h_aliases[i], a->h_aliases[i], j);
	}
	ret->h_length = a->h_length;
	ret->h_addrtype = a->h_addrtype;
	for (i = 0; a->h_addr_list[i] != NULL; i++) {
		if ((ret->h_addr_list[i] = OPENSSL_malloc(a->h_length)) == NULL)
			goto err;
		memcpy(ret->h_addr_list[i], a->h_addr_list[i], a->h_length);
	}
	if (0) {
err:
		if (ret != NULL)
			ghbn_free(ret);
		ret = NULL;
	}
	MemCheck_on();
	return (ret);
}

static void
ghbn_free(struct hostent *a)
{
	int i;

	if (a == NULL)
		return;

	if (a->h_aliases != NULL) {
		for (i = 0; a->h_aliases[i] != NULL; i++)
			OPENSSL_free(a->h_aliases[i]);
		OPENSSL_free(a->h_aliases);
	}
	if (a->h_addr_list != NULL) {
		for (i = 0; a->h_addr_list[i] != NULL; i++)
			OPENSSL_free(a->h_addr_list[i]);
		OPENSSL_free(a->h_addr_list);
	}
	if (a->h_name != NULL)
		OPENSSL_free(a->h_name);
	OPENSSL_free(a);
}

#endif

struct hostent
*BIO_gethostbyname(const char *name)
a245 6
#if 1
	/* Caching gethostbyname() results forever is wrong,
	 * so we have to let the true gethostbyname() worry about this */
#if (defined(NETWARE_BSDSOCK) && !defined(__NOVELL_LIBC__))
	return gethostbyname((char*)name);
#else
a246 76
#endif
#else
	struct hostent *ret;
	int i, lowi = 0, j;
	unsigned long low = (unsigned long) - 1;


#  if 0
	/* It doesn't make sense to use locking here: The function interface
	 * is not thread-safe, because threads can never be sure when
	 * some other thread destroys the data they were given a pointer to.
	 */
	CRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);
#  endif
	j = strlen(name);
	if (j < 128) {
		for (i = 0; i < GHBN_NUM; i++) {
			if (low > ghbn_cache[i].order) {
				low = ghbn_cache[i].order;
				lowi = i;
			}
			if (ghbn_cache[i].order > 0) {
				if (strncmp(name, ghbn_cache[i].name, 128) == 0)
					break;
			}
		}
	} else
		i = GHBN_NUM;

	if (i == GHBN_NUM) /* no hit*/
	{
		BIO_ghbn_miss++;
		/* Note: under VMS with SOCKETSHR, it seems like the first
		 * parameter is 'char *', instead of 'const char *'
		 */
#  ifndef CONST_STRICT
		ret = gethostbyname((char *)name);
#  else
		ret = gethostbyname(name);
#  endif

		if (ret == NULL)
			goto end;
		if (j > 128) /* too big to cache */
		{
#  if 0
			/* If we were trying to make this function thread-safe (which
			 * is bound to fail), we'd have to give up in this case
			 * (or allocate more memory). */
			ret = NULL;
#  endif
			goto end;
		}

		/* else add to cache */
		if (ghbn_cache[lowi].ent != NULL)
			ghbn_free(ghbn_cache[lowi].ent); /* XXX not thread-safe */
		ghbn_cache[lowi].name[0] = '\0';

		if ((ret = ghbn_cache[lowi].ent = ghbn_dup(ret)) == NULL) {
			BIOerr(BIO_F_BIO_GETHOSTBYNAME, ERR_R_MALLOC_FAILURE);
			goto end;
		}
		strncpy(ghbn_cache[lowi].name, name, 128);
		ghbn_cache[lowi].order = BIO_ghbn_miss + BIO_ghbn_hits;
	} else {
		BIO_ghbn_hits++;
		ret = ghbn_cache[i].ent;
		ghbn_cache[i].order = BIO_ghbn_miss + BIO_ghbn_hits;
	}
end:
#  if 0
	CRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);
#  endif
	return (ret);
#endif
a252 25
#ifdef WATT32
	extern int _watt_do_exit;
	_watt_do_exit = 0;
	/* don't make sock_init() call exit() */
	if (sock_init())
		return (-1);
#endif

#if defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
	WORD wVerReq;
	WSADATA wsaData;
	int err;

	if (!wsa_init_done) {
		wsa_init_done = 1;
		wVerReq = MAKEWORD( 2, 0 );
		err = WSAStartup(wVerReq, &wsaData);
		if (err != 0) {
			SYSerr(SYS_F_WSASTARTUP, err);
			BIOerr(BIO_F_BIO_SOCK_INIT, BIO_R_WSASTARTUP);
			return (-1);
		}
	}
#endif

a258 6
#if   defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
	if (wsa_init_done) {
		wsa_init_done = 0;
		WSACleanup();
	}
#endif
a260 2
#if !defined(OPENSSL_SYS_VMS) || __VMS_VER >= 70000000

a268 20
# if defined(OPENSSL_SYS_VMS)
	/* 2011-02-18 SMS.
	 * VMS ioctl() can't tolerate a 64-bit "void *arg", but we
	 * observe that all the consumers pass in an "unsigned long *",
	 * so we arrange a local copy with a short pointer, and use
	 * that, instead.
	 */
#  if __INITIAL_POINTER_SIZE == 64
#   define ARG arg_32p
#   pragma pointer_size save
#   pragma pointer_size 32
	unsigned long arg_32;
	unsigned long *arg_32p;
#   pragma pointer_size restore
	arg_32p = &arg_32;
	arg_32 = *((unsigned long *) arg);
#  else /* __INITIAL_POINTER_SIZE == 64 */
#   define ARG arg
#  endif /* __INITIAL_POINTER_SIZE == 64 [else] */
# else /* defined(OPENSSL_SYS_VMS) */
a269 1
# endif /* defined(OPENSSL_SYS_VMS) [else] */
a276 1
#endif /* __VMS_VER */
@


1.18
log
@Toss a `unifdef -U OPENSSL_SYS_WINDOWS' bomb into crypto/bio.

ok miod@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d243 1
a243 1
	i = getsockopt(sock, SOL_SOCKET, SO_ERROR,(void *)&j,(void *)&size);
d320 3
a322 2
	if ((ret->h_name = OPENSSL_malloc(j)) == NULL) goto err;
		memcpy((char *)ret->h_name, a->h_name, j);
d325 3
a327 2
		if ((ret->h_aliases[i] = OPENSSL_malloc(j)) == NULL) goto err;
			memcpy(ret->h_aliases[i], a->h_aliases[i], j);
d372 2
a373 1
*BIO_gethostbyname(const char *name) {
d510 1
a510 1
	i = ioctl(fd, type,(char *)arg);
d568 1
a568 1
		break;
d624 2
a625 2
			const struct addrinfo *,
			struct addrinfo **);
d636 1
a636 1
			p_getaddrinfo.p = (void*) - 1;
d638 2
a639 1
		if (p_getaddrinfo.p == (void *) - 1) break;
d687 1
a687 2
		l = (unsigned long)
		    ((unsigned long)ip[0]<<24L)|
d707 1
a707 1
		ret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR,(char *)&i, sizeof(i));
d715 1
a715 2
		(err_num == EADDRINUSE))
		{
d812 1
a812 1
	ret = accept(sock, &sa.from.sa,(void *)&sa.len);
d819 3
a821 2
		if (BIO_sock_should_retry(ret)) return -2;
			SYSerr(SYS_F_ACCEPT, errno);
d836 1
a836 1
			    size_t/*socklen_t*/, char *, size_t,
d906 1
a906 1
	ret = setsockopt(s, opt, TCP_NODELAY,(char *)&on, sizeof(on));
@


1.17
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a459 21
#ifdef OPENSSL_SYS_WINDOWS
	static struct WSAData wsa_state;

	if (!wsa_init_done) {
		int err;

		wsa_init_done = 1;
		memset(&wsa_state, 0, sizeof(wsa_state));
		/* Not making wsa_state available to the rest of the
		 * code is formally wrong. But the structures we use
		 * are [beleived to be] invariable among Winsock DLLs,
		 * while API availability is [expected to be] probed
		 * at run-time with DSO_global_lookup. */
		if (WSAStartup(0x0202, &wsa_state) != 0) {
			err = WSAGetLastError();
			SYSerr(SYS_F_WSASTARTUP, err);
			BIOerr(BIO_F_BIO_SOCK_INIT, BIO_R_WSASTARTUP);
			return (-1);
		}
	}
#endif /* OPENSSL_SYS_WINDOWS */
d491 1
a491 9
#ifdef OPENSSL_SYS_WINDOWS
	if (wsa_init_done) {
		wsa_init_done = 0;
#if 0		/* this call is claimed to be non-present in Winsock2 */
		WSACancelBlockingCall();
#endif
		WSACleanup();
	}
#elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
a711 6
#ifdef OPENSSL_SYS_WINDOWS
			/* Some versions of Windows define EADDRINUSE to
			 * a dummy value.
			 */
		(err_num == WSAEADDRINUSE))
#else
a712 1
#endif
@


1.16
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@d88 1
a88 1
static int wsa_init_done=0;
d103 2
a104 2
static unsigned long BIO_ghbn_hits=0L;
static unsigned long BIO_ghbn_miss=0L;
d107 1
a107 2
static struct ghbn_cache_st
	{
d111 1
a111 1
	} ghbn_cache[GHBN_NUM];
d114 1
a114 1
static int get_ip(const char *str,unsigned char *ip);
d119 4
a122 2
int BIO_get_host_ip(const char *str, unsigned char *ip)
	{
d128 3
a130 4
	i=get_ip(str,ip);
	if (i < 0)
		{
		BIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_INVALID_IP_ADDRESS);
d132 1
a132 1
		}
d141 2
a142 1
	if (i > 0) return(1);
d147 3
a149 4
	he=BIO_gethostbyname(str);
	if (he == NULL)
		{
		BIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_BAD_HOSTNAME_LOOKUP);
d151 1
a151 1
		}
d154 2
a155 3
	if ((short)he->h_addrtype != AF_INET)
		{
		BIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);
d157 3
a159 3
		}
	for (i=0; i<4; i++)
		ip[i]=he->h_addr_list[0][i];
d162 1
a162 1
 err:
d165 2
a166 3
	if (err)
		{
		ERR_add_error_data(2,"host=",str);
d168 1
a168 2
		}
	else
d170 1
a170 1
	}
d172 3
a174 2
int BIO_get_port(const char *str, unsigned short *port_ptr)
	{
d178 5
a182 6
	if (str == NULL)
		{
		BIOerr(BIO_F_BIO_GET_PORT,BIO_R_NO_PORT_DEFINED);
		return(0);
		}
	i=atoi(str);
d184 2
a185 3
		*port_ptr=(unsigned short)i;
	else
		{
d191 1
a191 1
		s=getservbyname((char *)str,"tcp");
d193 1
a193 1
		s=getservbyname(str,"tcp");
d195 2
a196 2
		if(s != NULL)
			*port_ptr=ntohs((unsigned short)s->s_port);
d198 15
a212 16
		if(s == NULL)
			{
			if (strcmp(str,"http") == 0)
				*port_ptr=80;
			else if (strcmp(str,"telnet") == 0)
				*port_ptr=23;
			else if (strcmp(str,"socks") == 0)
				*port_ptr=1080;
			else if (strcmp(str,"https") == 0)
				*port_ptr=443;
			else if (strcmp(str,"ssl") == 0)
				*port_ptr=443;
			else if (strcmp(str,"ftp") == 0)
				*port_ptr=21;
			else if (strcmp(str,"gopher") == 0)
				*port_ptr=70;
d214 2
a215 2
			else if (strcmp(str,"wais") == 0)
				*port_ptr=21;
d217 4
a220 6
			else
				{
				SYSerr(SYS_F_GETSERVBYNAME,errno);
				ERR_add_error_data(3,"service='",str,"'");
				return(0);
				}
a222 1
	return(1);
d224 2
d227 4
a230 3
int BIO_sock_error(int sock)
	{
	int j,i;
d232 1
a232 1
		 
d236 2
a237 2
		 
	size=sizeof(int);
d243 1
a243 1
	i=getsockopt(sock,SOL_SOCKET,SO_ERROR,(void *)&j,(void *)&size);
d245 1
a245 1
		return(1);
d247 2
a248 2
		return(j);
	}
d251 3
a253 2
long BIO_ghbn_ctrl(int cmd, int iarg, char *parg)
	{
d257 1
a257 2
	switch (cmd)
		{
d259 1
a259 1
		return(BIO_ghbn_hits);
d262 1
a262 1
		return(BIO_ghbn_miss);
d265 1
a265 1
		return(GHBN_NUM);
d268 10
a277 10
		if ((iarg >= 0) && (iarg <GHBN_NUM) &&
			(ghbn_cache[iarg].order > 0))
			{
			p=(char **)parg;
			if (p == NULL) return(0);
			*p=ghbn_cache[iarg].name;
			ghbn_cache[iarg].name[128]='\0';
			return(1);
			}
		return(0);
d280 2
a281 2
		for (i=0; i<GHBN_NUM; i++)
			ghbn_cache[i].order=0;
d284 1
a284 3
		return(0);
		}
	return(1);
d286 2
d291 3
a293 2
static struct hostent *ghbn_dup(struct hostent *a)
	{
d295 1
a295 1
	int i,j;
d298 4
a301 3
	ret=(struct hostent *)OPENSSL_malloc(sizeof(struct hostent));
	if (ret == NULL) return(NULL);
	memset(ret,0,sizeof(struct hostent));
d303 1
a303 1
	for (i=0; a->h_aliases[i] != NULL; i++)
d311 1
a311 1
	for (i=0; a->h_addr_list[i] != NULL; i++)
d314 1
a314 1
	ret->h_addr_list=(char **)OPENSSL_malloc(i*sizeof(char *));
d319 12
a330 14
	j=strlen(a->h_name)+1;
	if ((ret->h_name=OPENSSL_malloc(j)) == NULL) goto err;
	memcpy((char *)ret->h_name,a->h_name,j);
	for (i=0; a->h_aliases[i] != NULL; i++)
		{
		j=strlen(a->h_aliases[i])+1;
		if ((ret->h_aliases[i]=OPENSSL_malloc(j)) == NULL) goto err;
		memcpy(ret->h_aliases[i],a->h_aliases[i],j);
		}
	ret->h_length=a->h_length;
	ret->h_addrtype=a->h_addrtype;
	for (i=0; a->h_addr_list[i] != NULL; i++)
		{
		if ((ret->h_addr_list[i]=OPENSSL_malloc(a->h_length)) == NULL)
d332 4
a335 5
		memcpy(ret->h_addr_list[i],a->h_addr_list[i],a->h_length);
		}
	if (0)
		{
err:	
d338 2
a339 2
		ret=NULL;
		}
d341 2
a342 2
	return(ret);
	}
d344 3
a346 2
static void ghbn_free(struct hostent *a)
	{
d349 2
a350 2
	if(a == NULL)
	    return;
d352 2
a353 3
	if (a->h_aliases != NULL)
		{
		for (i=0; a->h_aliases[i] != NULL; i++)
d356 3
a358 4
		}
	if (a->h_addr_list != NULL)
		{
		for (i=0; a->h_addr_list[i] != NULL; i++)
d361 3
a363 2
		}
	if (a->h_name != NULL) OPENSSL_free(a->h_name);
d365 1
a365 1
	}
d369 2
a370 2
struct hostent *BIO_gethostbyname(const char *name)
	{
d381 2
a382 2
	int i,lowi=0,j;
	unsigned long low= (unsigned long)-1;
d392 9
a400 13
	j=strlen(name);
	if (j < 128)
		{
		for (i=0; i<GHBN_NUM; i++)
			{
			if (low > ghbn_cache[i].order)
				{
				low=ghbn_cache[i].order;
				lowi=i;
				}
			if (ghbn_cache[i].order > 0)
				{
				if (strncmp(name,ghbn_cache[i].name,128) == 0)
a401 1
				}
d404 2
a405 2
	else
		i=GHBN_NUM;
d408 1
a408 1
		{
d414 1
a414 1
		ret=gethostbyname((char *)name);
d416 1
a416 1
		ret=gethostbyname(name);
d422 1
a422 1
			{
d430 1
a430 1
			}
d437 2
a438 3
		if((ret=ghbn_cache[lowi].ent=ghbn_dup(ret)) == NULL)
			{
			BIOerr(BIO_F_BIO_GETHOSTBYNAME,ERR_R_MALLOC_FAILURE);
a439 3
			}
		strncpy(ghbn_cache[lowi].name,name,128);
		ghbn_cache[lowi].order=BIO_ghbn_miss+BIO_ghbn_hits;
d441 3
a443 2
	else
		{
d445 3
a447 3
		ret= ghbn_cache[i].ent;
		ghbn_cache[i].order=BIO_ghbn_miss+BIO_ghbn_hits;
		}
d452 1
a452 1
	return(ret);
d454 1
a454 1
	}
d457 3
a459 2
int BIO_sock_init(void)
	{
d463 1
a463 2
	if (!wsa_init_done)
		{
d465 3
a467 3
	  
		wsa_init_done=1;
		memset(&wsa_state,0,sizeof(wsa_state));
d473 5
a477 7
		if (WSAStartup(0x0202,&wsa_state)!=0)
			{
			err=WSAGetLastError();
			SYSerr(SYS_F_WSASTARTUP,err);
			BIOerr(BIO_F_BIO_SOCK_INIT,BIO_R_WSASTARTUP);
			return(-1);
			}
d479 1
d483 2
a484 1
	_watt_do_exit = 0;    /* don't make sock_init() call exit() */
d490 12
a501 15
    WORD wVerReq;
    WSADATA wsaData;
    int err;

    if (!wsa_init_done)
    {
        wsa_init_done=1;
        wVerReq = MAKEWORD( 2, 0 );
        err = WSAStartup(wVerReq,&wsaData);
        if (err != 0)
        {
            SYSerr(SYS_F_WSASTARTUP,err);
            BIOerr(BIO_F_BIO_SOCK_INIT,BIO_R_WSASTARTUP);
            return(-1);
			}
d503 1
d506 2
a507 2
	return(1);
	}
d509 3
a511 2
void BIO_sock_cleanup(void)
	{
d513 2
a514 3
	if (wsa_init_done)
		{
		wsa_init_done=0;
d519 1
a519 1
		}
d521 4
a524 5
   if (wsa_init_done)
        {
        wsa_init_done=0;
        WSACleanup();
		}
d526 1
a526 1
	}
d530 3
a532 2
int BIO_socket_ioctl(int fd, long type, void *arg)
	{
d536 1
a536 1
	i=ioctl(fd,type,(char *)arg);
d561 1
a561 1
	i=ioctl(fd,type,ARG);
d564 3
a566 3
		SYSerr(SYS_F_IOCTLSOCKET,errno);
	return(i);
	}
d571 3
a573 2
static int get_ip(const char *str, unsigned char ip[4])
	{
d575 1
a575 1
	int num=0,c,ok=0;
d577 1
a577 1
	tmp[0]=tmp[1]=tmp[2]=tmp[3]=0;
d579 1
a579 2
	for (;;)
		{
d581 10
a590 10
		if ((c >= '0') && (c <= '9'))
			{
			ok=1;
			tmp[num]=tmp[num]*10+c-'0';
			if (tmp[num] > 255) return(0);
			}
		else if (c == '.')
			{
			if (!ok) return(-1);
			if (num == 3) return(0);
d592 3
a594 4
			ok=0;
			}
		else if (c == '\0' && (num == 3) && ok)
			break;
d596 1
a596 7
			return(0);
		}
	ip[0]=tmp[0];
	ip[1]=tmp[1];
	ip[2]=tmp[2];
	ip[3]=tmp[3];
	return(1);
d598 11
a608 4

int BIO_get_accept_socket(char *host, int bind_mode)
	{
	int ret=0;
d615 2
a616 2
	} server,client;
	int s=-1,cs,addrlen;
d619 2
a620 2
	char *str=NULL,*e;
	char *h,*p;
d624 2
a625 1
	if (BIO_sock_init() != 1) return(-1);
d627 2
a628 1
	if ((str=BUF_strdup(host)) == NULL) return(-1);
d630 7
a636 11
	h=p=NULL;
	h=str;
	for (e=str; *e; e++)
		{
		if (*e == ':')
			{
			p=e;
			}
		else if (*e == '/')
			{
			*e='\0';
a637 1
			}
d639 5
a643 2
	if (p)	*p++='\0';	/* points at last ':', '::port' is special [see below] */
	else	p=h,h=NULL;
d647 8
a654 6
	static union {	void *p;
			int (WSAAPI *f)(const char *,const char *,
				 const struct addrinfo *,
				 struct addrinfo **);
			} p_getaddrinfo = {NULL};
	static union {	void *p;
d656 2
a657 2
			} p_freeaddrinfo = {NULL};
	struct addrinfo *res,hint;
d659 17
a675 19
	if (p_getaddrinfo.p==NULL)
		{
		if ((p_getaddrinfo.p=DSO_global_lookup("getaddrinfo"))==NULL ||
		    (p_freeaddrinfo.p=DSO_global_lookup("freeaddrinfo"))==NULL)
			p_getaddrinfo.p=(void*)-1;
		}
	if (p_getaddrinfo.p==(void *)-1) break;

	/* '::port' enforces IPv6 wildcard listener. Some OSes,
	 * e.g. Solaris, default to IPv6 without any hint. Also
	 * note that commonly IPv6 wildchard socket can service
	 * IPv4 connections just as well...  */
	memset(&hint,0,sizeof(hint));
	hint.ai_flags = AI_PASSIVE;
	if (h)
		{
		if (strchr(h,':'))
			{
			if (h[1]=='\0') h=NULL;
d677 1
a677 1
			hint.ai_family = AF_INET6;
d679 1
a679 1
			h=NULL;
d681 3
a683 5
			}
	    	else if (h[0]=='*' && h[1]=='\0')
			{
			hint.ai_family = AF_INET;
			h=NULL;
d687 2
a688 1
	if ((*p_getaddrinfo.f)(h,p,&hint,&res)) break;
d690 3
a692 4
	addrlen = res->ai_addrlen<=sizeof(server) ?
			res->ai_addrlen :
			sizeof(server);
	memcpy(&server, res->ai_addr, addrlen);
d694 2
a695 2
	(*p_freeaddrinfo.f)(res);
	goto again;
d699 2
a700 1
	if (!BIO_get_port(p,&port)) goto err;
d702 3
a704 3
	memset((char *)&server,0,sizeof(server));
	server.sa_in.sin_family=AF_INET;
	server.sa_in.sin_port=htons(port);
d707 12
a718 12
	if (h == NULL || strcmp(h,"*") == 0)
		server.sa_in.sin_addr.s_addr=INADDR_ANY;
	else
		{
                if (!BIO_get_host_ip(h,&(ip[0]))) goto err;
		l=(unsigned long)
			((unsigned long)ip[0]<<24L)|
			((unsigned long)ip[1]<<16L)|
			((unsigned long)ip[2]<< 8L)|
			((unsigned long)ip[3]);
		server.sa_in.sin_addr.s_addr=htonl(l);
		}
d721 5
a725 6
	s=socket(server.sa.sa_family,SOCK_STREAM,SOCKET_PROTOCOL);
	if (s == -1)
		{
		SYSerr(SYS_F_SOCKET,errno);
		ERR_add_error_data(3,"port='",host,"'");
		BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_CREATE_SOCKET);
d727 1
a727 1
		}
d730 2
a731 3
	if (bind_mode == BIO_BIND_REUSEADDR)
		{
		int i=1;
d733 3
a735 3
		ret=setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i));
		bind_mode=BIO_BIND_NORMAL;
		}
d737 1
a737 2
	if (bind(s,&server.sa,addrlen) == -1)
		{
d739 1
a739 1
		err_num=errno;
d745 1
a745 1
			(err_num == WSAEADDRINUSE))
d747 1
a747 1
			(err_num == EADDRINUSE))
d749 1
a749 1
			{
d751 1
a751 2
			if (h == NULL || strcmp(h,"*") == 0)
				{
d753 12
a764 16
				if (client.sa.sa_family == AF_INET6)
					{
					memset(&client.sa_in6.sin6_addr,0,sizeof(client.sa_in6.sin6_addr));
					client.sa_in6.sin6_addr.s6_addr[15]=1;
					}
				else
#endif
				if (client.sa.sa_family == AF_INET)
					{
					client.sa_in.sin_addr.s_addr=htonl(0x7F000001);
					}
				else	goto err;
				}
			cs=socket(client.sa.sa_family,SOCK_STREAM,SOCKET_PROTOCOL);
			if (cs != -1)
				{
d766 1
a766 1
				ii=connect(cs,&client.sa,addrlen);
d768 2
a769 3
				if (ii == -1)
					{
					bind_mode=BIO_BIND_REUSEADDR;
d772 1
a772 1
					}
d774 1
a774 1
				}
d776 1
a776 1
			}
d778 3
a780 3
		SYSerr(SYS_F_BIND,err_num);
		ERR_add_error_data(3,"port='",host,"'");
		BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_BIND_SOCKET);
d782 5
a786 6
		}
	if (listen(s,MAX_LISTEN) == -1)
		{
		SYSerr(SYS_F_BIND,errno);
		ERR_add_error_data(3,"port='",host,"'");
		BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_LISTEN_SOCKET);
d788 2
a789 2
		}
	ret=1;
d791 3
a793 3
	if (str != NULL) OPENSSL_free(str);
	if ((ret == 0) && (s != -1))
		{
d795 1
a795 3
		s= -1;
		}
	return(s);
d797 2
d800 4
a803 3
int BIO_accept(int sock, char **addr)
	{
	int ret=-1;
d809 28
a836 25
	/*
	 * As for following union. Trouble is that there are platforms
	 * that have socklen_t and there are platforms that don't, on
	 * some platforms socklen_t is int and on some size_t. So what
	 * one can do? One can cook #ifdef spaghetti, which is nothing
	 * but masochistic. Or one can do union between int and size_t.
	 * One naturally does it primarily for 64-bit platforms where
	 * sizeof(int) != sizeof(size_t). But would it work? Note that
	 * if size_t member is initialized to 0, then later int member
	 * assignment naturally does the job on little-endian platforms
	 * regardless accept's expectations! What about big-endians?
	 * If accept expects int*, then it works, and if size_t*, then
	 * length value would appear as unreasonably large. But this
	 * won't prevent it from filling in the address structure. The
	 * trouble of course would be if accept returns more data than
	 * actual buffer can accomodate and overwrite stack... That's
	 * where early OPENSSL_assert comes into picture. Besides, the
	 * only 64-bit big-endian platform found so far that expects
	 * size_t* is HP-UX, where stack grows towards higher address.
	 * <appro>
	 */
	union { size_t s; int i; } len;
	union {
		struct sockaddr sa;
		struct sockaddr_in sa_in;
d838 1
a838 1
		struct sockaddr_in6 sa_in6;
d843 6
a848 7
	sa.len.s=0;
	sa.len.i=sizeof(sa.from);
	memset(&sa.from,0,sizeof(sa.from));
	ret=accept(sock,&sa.from.sa,(void *)&sa.len);
	if (sizeof(sa.len.i)!=sizeof(sa.len.s) && sa.len.i==0)
		{
		OPENSSL_assert(sa.len.s<=sizeof(sa.from));
d851 5
a855 6
		}
	if (ret == -1)
		{
		if(BIO_sock_should_retry(ret)) return -2;
		SYSerr(SYS_F_ACCEPT,errno);
		BIOerr(BIO_F_BIO_ACCEPT,BIO_R_ACCEPT_ERROR);
d857 1
a857 1
		}
d859 2
a860 1
	if (addr == NULL) goto end;
d864 20
a883 11
	char   h[NI_MAXHOST],s[NI_MAXSERV];
	size_t nl;
	static union {	void *p;
			int (WSAAPI *f)(const struct sockaddr *,size_t/*socklen_t*/,
				 char *,size_t,char *,size_t,int);
			} p_getnameinfo = {NULL};
			/* 2nd argument to getnameinfo is specified to
			 * be socklen_t. Unfortunately there is a number
			 * of environments where socklen_t is not defined.
			 * As it's passed by value, it's safe to pass it
			 * as size_t... <appro> */
d885 14
a898 4
	if (p_getnameinfo.p==NULL)
		{
		if ((p_getnameinfo.p=DSO_global_lookup("getnameinfo"))==NULL)
			p_getnameinfo.p=(void*)-1;
d900 6
a905 11
	if (p_getnameinfo.p==(void *)-1) break;

	if ((*p_getnameinfo.f)(&sa.from.sa,sa.len.i,h,sizeof(h),s,sizeof(s),
	    NI_NUMERICHOST|NI_NUMERICSERV)) break;
	nl = strlen(h)+strlen(s)+2;
	p = *addr;
	if (p)	{ *p = '\0'; p = OPENSSL_realloc(p,nl);	}
	else	{ p = OPENSSL_malloc(nl);		}
	if (p==NULL)
		{
		BIOerr(BIO_F_BIO_ACCEPT,ERR_R_MALLOC_FAILURE);
d907 5
a911 14
		}
	*addr = p;
	(void) snprintf(*addr,nl,"%s:%s",h,s);
	goto end;
	} while(0);
#endif
	if (sa.from.sa.sa_family != AF_INET) goto end;
	l=ntohl(sa.from.sa_in.sin_addr.s_addr);
	port=ntohs(sa.from.sa_in.sin_port);
	if (*addr == NULL)
		{
		if ((p=OPENSSL_malloc(24)) == NULL)
			{
			BIOerr(BIO_F_BIO_ACCEPT,ERR_R_MALLOC_FAILURE);
a912 2
			}
		*addr=p;
d914 6
a919 6
	(void) snprintf(*addr,24,"%d.%d.%d.%d:%d",
		     (unsigned char)(l>>24L)&0xff,
		     (unsigned char)(l>>16L)&0xff,
		     (unsigned char)(l>> 8L)&0xff,
		     (unsigned char)(l     )&0xff,
		     port);
d921 2
a922 2
	return(ret);
	}
d924 4
a927 3
int BIO_set_tcp_ndelay(int s, int on)
	{
	int ret=0;
d932 1
a932 1
	opt=SOL_TCP;
d935 1
a935 1
	opt=IPPROTO_TCP;
d938 2
a939 2
	
	ret=setsockopt(s,opt,TCP_NODELAY,(char *)&on,sizeof(on));
d941 2
a942 2
	return(ret == 0);
	}
d944 4
a947 3
int BIO_socket_nbio(int s, int mode)
	{
	int ret= -1;
d950 1
a950 1
	l=mode;
d952 1
a952 1
	ret=BIO_socket_ioctl(s,FIONBIO,&l);
d954 2
a955 2
	return(ret == 0);
	}
@


1.15
log
@Remove various horrible socket syscall wrappers, especially SHUTDOWN*
which did shutdown + close, all nasty and surprising.  Use the raw
syscalls that everyone knows the behaviour of.
ok beck matthew
@
text
@d919 1
a919 1
	BIO_snprintf(*addr,nl,"%s:%s",h,s);
d935 1
a935 1
	BIO_snprintf(*addr,24,"%d.%d.%d.%d:%d",
@


1.14
log
@resolve conflicts
@
text
@d224 1
a224 1
				SYSerr(SYS_F_GETSERVBYNAME,get_last_socket_error());
d552 1
a552 1
	i=ioctlsocket(fd,type,(char *)arg);
d577 1
a577 1
	i=ioctlsocket(fd,type,ARG);
d580 1
a580 1
		SYSerr(SYS_F_IOCTLSOCKET,get_last_socket_error());
d632 1
a632 1
	int s=INVALID_SOCKET,cs,addrlen;
d640 1
a640 1
	if (BIO_sock_init() != 1) return(INVALID_SOCKET);
d642 1
a642 1
	if ((str=BUF_strdup(host)) == NULL) return(INVALID_SOCKET);
d739 1
a739 1
	if (s == INVALID_SOCKET)
d741 1
a741 1
		SYSerr(SYS_F_SOCKET,get_last_socket_error());
d759 1
a759 1
		err_num=get_last_socket_error();
d788 1
a788 1
			if (cs != INVALID_SOCKET)
d792 2
a793 2
				closesocket(cs);
				if (ii == INVALID_SOCKET)
d796 1
a796 1
					closesocket(s);
d811 1
a811 1
		SYSerr(SYS_F_BIND,get_last_socket_error());
d819 1
a819 1
	if ((ret == 0) && (s != INVALID_SOCKET))
d821 2
a822 2
		closesocket(s);
		s= INVALID_SOCKET;
d829 1
a829 1
	int ret=INVALID_SOCKET;
d876 1
a876 1
	if (ret == INVALID_SOCKET)
d879 1
a879 1
		SYSerr(SYS_F_ACCEPT,get_last_socket_error());
@


1.13
log
@openssl-1.0.0e: resolve conflicts
@
text
@a962 1
#endif
d975 1
@


1.12
log
@resolve conflicts, fix local changes
@
text
@d554 24
a577 1
	i=ioctlsocket(fd,type,arg);
d686 1
d699 2
d702 1
@


1.11
log
@resolve conflicts
@
text
@d75 2
a76 3
#ifdef OPENSSL_SYS_WIN16
#define SOCKET_PROTOCOL 0 /* more microsoft stupidity */
#else
a77 1
#endif
d91 11
d238 4
d482 6
a487 1
		if (WSAStartup(0x0101,&wsa_state)!=0)
d531 2
a532 2
#ifndef OPENSSL_SYS_WINCE
		WSACancelBlockingCall();	/* Winsock 1.1 specific */
d602 8
a609 2
	struct sockaddr_in server,client;
	int s=INVALID_SOCKET,cs;
d613 1
a613 1
	const char *h,*p;
d627 1
a627 2
			p= &(e[1]);
			*e='\0';
d635 2
d638 38
a675 4
	if (p == NULL)
		{
		p=h;
		h="*";
d678 12
d693 3
a695 2
	server.sin_family=AF_INET;
	server.sin_port=htons(port);
d697 2
a698 2
	if (strcmp(h,"*") == 0)
		server.sin_addr.s_addr=INADDR_ANY;
d707 1
a707 1
		server.sin_addr.s_addr=htonl(l);
d711 1
a711 1
	s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);
d729 1
a729 1
	if (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)
d734 6
d741 1
d743 18
a760 4
			memcpy((char *)&client,(char *)&server,sizeof(server));
			if (strcmp(h,"*") == 0)
				client.sin_addr.s_addr=htonl(0x7F000001);
			cs=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);
d764 1
a764 2
				ii=connect(cs,(struct sockaddr *)&client,
					sizeof(client));
a802 1
	static struct sockaddr_in from;
a804 1
	int len;
d807 21
a827 6
	memset((char *)&from,0,sizeof(from));
	len=sizeof(from);
	/* Note: under VMS with SOCKETSHR the fourth parameter is currently
	 * of type (int *) whereas under other systems it is (void *) if
	 * you don't have a cast it will choke the compiler: if you do
	 * have a cast then you can either go for (int *) or (void *).
d829 20
a848 1
	ret=accept(sock,(struct sockaddr *)&from,(void *)&len);
d859 40
a898 2
	l=ntohl(from.sin_addr.s_addr);
	port=ntohs(from.sin_port);
@


1.10
log
@merge 0.9.7d
@
text
@a58 2
#ifndef OPENSSL_NO_SOCK

d65 9
d89 1
a89 1
#ifdef OPENSSL_SYS_WINDOWS
a184 1
 		s=getservbyname(
d186 3
a188 1
		    (char *)
a189 1
		    str,"tcp");
d367 3
d371 1
a410 1
		ret=gethostbyname(
d412 3
a414 1
		    (char *)
a415 1
		    name);
a466 3
#ifdef SIGINT
		signal(SIGINT,(void (*)(int))BIO_sock_cleanup);
#endif
d484 20
d514 1
a514 1
		WSACancelBlockingCall();
d517 6
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d712 6
a717 6
	snprintf(*addr,24,"%d.%d.%d.%d:%d",
		 (unsigned char)(l>>24L)&0xff,
		 (unsigned char)(l>>16L)&0xff,
		 (unsigned char)(l>> 8L)&0xff,
		 (unsigned char)(l     )&0xff,
		 port);
@


1.8
log
@sprintf->snprintf. deraadt@@ suggestions and ok
@
text
@d86 1
d97 1
d235 1
d273 1
d470 6
d485 1
d487 1
d495 1
a495 1
int BIO_socket_ioctl(int fd, long type, unsigned long *arg)
d745 1
a745 1
	unsigned long l;
@


1.7
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d700 6
a705 6
	sprintf(*addr,"%d.%d.%d.%d:%d",
		(unsigned char)(l>>24L)&0xff,
		(unsigned char)(l>>16L)&0xff,
		(unsigned char)(l>> 8L)&0xff,
		(unsigned char)(l     )&0xff,
		port);
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d487 3
d491 1
@


1.5
log
@openssl-engine-0.9.6a merge
@
text
@d59 1
a59 1
#ifndef NO_SOCK
d68 1
a68 1
#ifdef WIN16
d75 2
a77 2
#elif defined(SO_MAXCONN)
#define MAX_LISTEN  SO_MAXCONN
d82 1
a82 1
#ifdef WINDOWS
d98 1
d101 1
d271 1
d349 2
d353 5
a361 1
/*	return(gethostbyname(name)); */
d363 5
a367 4
#if 0 /* It doesn't make sense to use locking here: The function interface
	   * is not thread-safe, because threads can never be sure when
	   * some other thread destroys the data they were given a pointer to.
	   */
d369 1
a369 1
#endif
d397 1
a397 1
#ifndef CONST_STRICT
d399 1
a399 1
#endif
d406 4
a409 3
#if 0 /* If we were trying to make this function thread-safe (which
	   * is bound to fail), we'd have to give up in this case
	   * (or allocate more memory). */
d411 1
a411 1
#endif
d435 1
a435 1
#if 0
d437 2
a439 1
	return(ret);
d442 1
d445 1
a445 1
#ifdef WINDOWS
d465 1
a465 1
#endif /* WINDOWS */
d471 1
a471 1
#ifdef WINDOWS
d481 1
a481 1
#if !defined(VMS) || __VMS_VER >= 70000000
d510 1
a510 1
			if (tmp[num] > 255) return(-1);
d515 1
a515 1
			if (num == 3) break;
d519 1
a519 1
		else if ((num == 3) && ok)
d677 1
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d116 2
a117 2
	if (!BIO_sock_init())
		return(0); /* don't generate another error code here */
d522 1
a522 1
	int s= -1,cs;
d525 1
a525 1
	char *str,*e;
d530 1
a530 1
	if (!BIO_sock_init()) return(INVALID_SOCKET);
d556 1
a556 1
	if (!BIO_get_port(p,&port)) return(INVALID_SOCKET);
d566 1
a566 1
		if (!BIO_get_host_ip(h,&(ip[0]))) return(INVALID_SOCKET);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@a107 1
	if (i > 0) return(1);
d114 2
a115 1
	/* do a gethostbyname */
d119 5
d275 1
a275 1
	ret=(struct hostent *)Malloc(sizeof(struct hostent));
d282 1
a282 1
	ret->h_aliases = (char **)Malloc(i*sizeof(char *));
d290 1
a290 1
	ret->h_addr_list=(char **)Malloc(i*sizeof(char *));
d296 1
a296 1
	if ((ret->h_name=Malloc(j)) == NULL) goto err;
d301 1
a301 1
		if ((ret->h_aliases[i]=Malloc(j)) == NULL) goto err;
d308 1
a308 1
		if ((ret->h_addr_list[i]=Malloc(a->h_length)) == NULL)
d333 2
a334 2
			Free(a->h_aliases[i]);
		Free(a->h_aliases);
d339 2
a340 2
			Free(a->h_addr_list[i]);
		Free(a->h_addr_list);
d342 2
a343 2
	if (a->h_name != NULL) Free(a->h_name);
	Free(a);
d636 1
a636 1
	if (str != NULL) Free(str);
d675 1
a675 1
		if ((p=Malloc(24)) == NULL)
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d166 8
a173 1
 		s=getservbyname(str,"tcp");
d292 1
a292 1
	memcpy((char *)ret->h_name,a->h_name,j+1);
d297 1
a297 1
		memcpy(ret->h_aliases[i],a->h_aliases[i],j+1);
d337 1
a337 1
	if (a->h_name != NULL) Free((char *)a->h_name);
d378 8
a385 1
		ret=gethostbyname(name);
@


1.1
log
@Initial revision
@
text
@d66 1
a66 3
#include "bio.h"

/*	BIOerr(BIO_F_WSASTARTUP,BIO_R_WSASTARTUP ); */
d97 1
a97 2
#ifndef NOPROTO
static int get_ip(char *str,unsigned char *ip);
d100 1
a100 9
#else
static int get_ip();
static void ghbn_free();
static struct hostent *ghbn_dup();
#endif

int BIO_get_host_ip(str,ip)
char *str;
unsigned char *ip;
d103 2
d112 1
a112 2
		ERR_add_error_data(2,"host=",str);
		return(0);
a113 3
	else
		{ /* do a gethostbyname */
		if (!BIO_sock_init()) return(0);
d115 12
a126 7
		he=BIO_gethostbyname(str);
		if (he == NULL)
			{
			BIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_BAD_HOSTNAME_LOOKUP);
			ERR_add_error_data(2,"host=",str);
			return(0);
			}
d128 17
a144 9
		/* cast to short because of win16 winsock definition */
		if ((short)he->h_addrtype != AF_INET)
			{
			BIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);
			ERR_add_error_data(2,"host=",str);
			return(0);
			}
		for (i=0; i<4; i++)
			ip[i]=he->h_addr_list[0][i];
d146 2
a147 1
	return(1);
d150 1
a150 3
int BIO_get_port(str,port_ptr)
char *str;
short *port_ptr;
d165 6
a170 2
		s=getservbyname(str,"tcp");
		if (s == NULL)
a195 1
			return(1);
a196 1
		*port_ptr=htons((unsigned short)s->s_port);
d201 1
a201 2
int BIO_sock_error(sock)
int sock;
d203 2
a204 1
	int j,i,size;
d207 6
a212 2

	i=getsockopt(sock,SOL_SOCKET,SO_ERROR,(char *)&j,&size);
d219 1
a219 4
long BIO_ghbn_ctrl(cmd,iarg,parg)
int cmd;
int iarg;
char *parg;
d228 1
a228 1
		break;
d231 1
a231 1
		break;
d234 1
a234 1
		break;
d246 1
a246 1
		break;
d257 1
a257 2
static struct hostent *ghbn_dup(a)
struct hostent *a;
d262 2
a263 1
	ret=(struct hostent *)malloc(sizeof(struct hostent));
d270 4
a273 3
	ret->h_aliases=(char **)malloc(sizeof(char *)*i);
	memset(ret->h_aliases,0,sizeof(char *)*i);
	if (ret == NULL) goto err;
d278 4
a281 3
	ret->h_addr_list=(char **)malloc(sizeof(char *)*i);
	memset(ret->h_addr_list,0,sizeof(char *)*i);
	if (ret->h_addr_list == NULL) goto err;
d284 2
a285 2
	if ((ret->h_name=malloc(j)) == NULL) goto err;
	memcpy((char *)ret->h_name,a->h_name,j);
d289 2
a290 2
		if ((ret->h_aliases[i]=malloc(j)) == NULL) goto err;
		memcpy(ret->h_aliases[i],a->h_aliases[i],j);
d296 1
a296 1
		if ((ret->h_addr_list[i]=malloc(a->h_length)) == NULL)
d300 8
a308 4
err:	
	if (ret != NULL)
		ghbn_free(ret);
	return(NULL);
d311 1
a311 2
static void ghbn_free(a)
struct hostent *a;
d315 3
d321 2
a322 2
			free(a->h_aliases[i]);
		free(a->h_aliases);
d327 2
a328 2
			free(a->h_addr_list[i]);
		free(a->h_addr_list);
d330 2
a331 2
	if (a->h_name != NULL) free((char *)a->h_name);
	free(a);
d334 1
a334 2
struct hostent *BIO_gethostbyname(name)
char *name;
d342 6
a347 1
	CRYPTO_w_lock(CRYPTO_LOCK_BIO_GETHOSTBYNAME);
d373 11
a383 2
		if (ret == NULL) return(NULL);
		if (j > 128) return(ret); /* too big to cache */
d387 2
a388 1
			ghbn_free(ghbn_cache[lowi].ent);
d390 5
a395 1
		ghbn_cache[lowi].ent=ghbn_dup(ret);
d404 4
a407 1
	CRYPTO_w_unlock(CRYPTO_LOCK_BIO_GETHOSTBYNAME);
d411 1
a411 1
int BIO_sock_init()
d437 1
a437 1
void BIO_sock_cleanup()
d449 3
a451 4
int BIO_socket_ioctl(fd,type,arg)
int fd;
long type;
unsigned long *arg;
d460 1
d464 1
a464 3
static int get_ip(str,ip)
char *str;
unsigned char ip[4];
d499 1
a499 2
int BIO_get_accept_socket(host)
char *host;
d502 2
a503 2
	struct sockaddr_in server;
	int s= -1;
d505 3
a507 2
	short port;
	char *str,*h,*p,*e;
d509 1
d541 1
a541 1
	server.sin_port=htons((unsigned short)port);
d550 3
a552 3
			((unsigned long)ip[0]<<16L)|
			((unsigned long)ip[0]<< 8L)|
			((unsigned long)ip[0]);
d556 1
d565 10
d577 27
a603 1
		SYSerr(SYS_F_BIND,get_last_socket_error());
a619 1
#ifdef WINDOWS
a620 3
#else
		close(s);
#endif
d626 1
a626 3
int BIO_accept(sock,addr)
int sock;
char **addr;
d631 1
a631 1
	short port;
d637 6
a642 1
	ret=accept(sock,(struct sockaddr *)&from,&len);
d673 1
a673 3
int BIO_set_tcp_ndelay(s,on)
int s;
int on;
d693 11
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d59 1
a59 1
#ifndef OPENSSL_NO_SOCK
d66 1
a66 1
#include <openssl/bio.h>
d68 3
a70 1
#ifdef OPENSSL_SYS_WIN16
d77 2
a79 2
#elif defined(SOMAXCONN)
#define MAX_LISTEN  SOMAXCONN
d84 1
a84 1
#ifdef OPENSSL_SYS_WINDOWS
d99 2
a100 2
static int get_ip(const char *str,unsigned char *ip);
#if 0
d103 4
d108 4
a111 1
int BIO_get_host_ip(const char *str, unsigned char *ip)
a113 2
	int err = 1;
	int locked = 0;
d117 1
d121 2
a122 1
		goto err;
d124 3
d128 7
a134 4
	/* At this point, we have something that is most probably correct
	   in some way, so let's init the socket. */
	if (BIO_sock_init() != 1)
		return 0; /* don't generate another error code here */
d136 9
a144 12
	/* If the string actually contained an IP address, we need not do
	   anything more */
	if (i > 0) return(1);

	/* do a gethostbyname */
	CRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);
	locked = 1;
	he=BIO_gethostbyname(str);
	if (he == NULL)
		{
		BIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_BAD_HOSTNAME_LOOKUP);
		goto err;
d146 1
a146 21

	/* cast to short because of win16 winsock definition */
	if ((short)he->h_addrtype != AF_INET)
		{
		BIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);
		goto err;
		}
	for (i=0; i<4; i++)
		ip[i]=he->h_addr_list[0][i];
	err = 0;

 err:
	if (locked)
		CRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);
	if (err)
		{
		ERR_add_error_data(2,"host=",str);
		return 0;
		}
	else
		return 1;
d149 3
a151 1
int BIO_get_port(const char *str, unsigned short *port_ptr)
d166 2
a167 13
		CRYPTO_w_lock(CRYPTO_LOCK_GETSERVBYNAME);
		/* Note: under VMS with SOCKETSHR, it seems like the first
		 * parameter is 'char *', instead of 'const char *'
		 */
 		s=getservbyname(
#ifndef CONST_STRICT
		    (char *)
#endif
		    str,"tcp");
		if(s != NULL)
			*port_ptr=ntohs((unsigned short)s->s_port);
		CRYPTO_w_unlock(CRYPTO_LOCK_GETSERVBYNAME);
		if(s == NULL)
d193 1
d195 1
d200 2
a201 1
int BIO_sock_error(int sock)
d203 1
a203 2
	int j,i;
	int size;
d206 2
a207 6
	/* Note: under Windows the third parameter is of type (char *)
	 * whereas under other systems it is (void *) if you don't have
	 * a cast it will choke the compiler: if you do have a cast then
	 * you can either go for (char *) or (void *).
	 */
	i=getsockopt(sock,SOL_SOCKET,SO_ERROR,(void *)&j,(void *)&size);
d214 4
a217 1
long BIO_ghbn_ctrl(int cmd, int iarg, char *parg)
d226 1
a226 1
		/* break; */
d229 1
a229 1
		/* break; */
d232 1
a232 1
		/* break; */
d244 1
a244 1
		/* break; */
d255 2
a256 2
#if 0
static struct hostent *ghbn_dup(struct hostent *a)
d261 1
a261 2
	MemCheck_off();
	ret=(struct hostent *)OPENSSL_malloc(sizeof(struct hostent));
d268 3
a270 4
	ret->h_aliases = (char **)OPENSSL_malloc(i*sizeof(char *));
	if (ret->h_aliases == NULL)
		goto err;
	memset(ret->h_aliases, 0, i*sizeof(char *));
d275 3
a277 4
	ret->h_addr_list=(char **)OPENSSL_malloc(i*sizeof(char *));
	if (ret->h_addr_list == NULL)
		goto err;
	memset(ret->h_addr_list, 0, i*sizeof(char *));
d280 1
a280 1
	if ((ret->h_name=OPENSSL_malloc(j)) == NULL) goto err;
d285 1
a285 1
		if ((ret->h_aliases[i]=OPENSSL_malloc(j)) == NULL) goto err;
d292 1
a292 1
		if ((ret->h_addr_list[i]=OPENSSL_malloc(a->h_length)) == NULL)
d296 1
a296 2
	if (0)
		{
d298 3
a300 6
		if (ret != NULL)
			ghbn_free(ret);
		ret=NULL;
		}
	MemCheck_on();
	return(ret);
d303 2
a304 1
static void ghbn_free(struct hostent *a)
a307 3
	if(a == NULL)
	    return;

d311 2
a312 2
			OPENSSL_free(a->h_aliases[i]);
		OPENSSL_free(a->h_aliases);
d317 2
a318 2
			OPENSSL_free(a->h_addr_list[i]);
		OPENSSL_free(a->h_addr_list);
d320 2
a321 2
	if (a->h_name != NULL) OPENSSL_free(a->h_name);
	OPENSSL_free(a);
d324 2
a325 3
#endif

struct hostent *BIO_gethostbyname(const char *name)
a326 5
#if 1
	/* Caching gethostbyname() results forever is wrong,
	 * so we have to let the true gethostbyname() worry about this */
	return gethostbyname(name);
#else
d331 1
d333 1
a333 7
#  if 0
	/* It doesn't make sense to use locking here: The function interface
	 * is not thread-safe, because threads can never be sure when
	 * some other thread destroys the data they were given a pointer to.
	 */
	CRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);
#  endif
d357 1
a357 8
		/* Note: under VMS with SOCKETSHR, it seems like the first
		 * parameter is 'char *', instead of 'const char *'
		 */
		ret=gethostbyname(
#  ifndef CONST_STRICT
		    (char *)
#  endif
		    name);
d359 2
a360 12
		if (ret == NULL)
			goto end;
		if (j > 128) /* too big to cache */
			{
#  if 0
			/* If we were trying to make this function thread-safe (which
			 * is bound to fail), we'd have to give up in this case
			 * (or allocate more memory). */
			ret = NULL;
#  endif
			goto end;
			}
d364 1
a364 2
			ghbn_free(ghbn_cache[lowi].ent); /* XXX not thread-safe */
		ghbn_cache[lowi].name[0] = '\0';
a365 5
		if((ret=ghbn_cache[lowi].ent=ghbn_dup(ret)) == NULL)
			{
			BIOerr(BIO_F_BIO_GETHOSTBYNAME,ERR_R_MALLOC_FAILURE);
			goto end;
			}
d367 1
d376 1
a376 4
end:
#  if 0
	CRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);
#  endif
a377 1
#endif
d380 1
a380 2

int BIO_sock_init(void)
d382 1
a382 1
#ifdef OPENSSL_SYS_WINDOWS
d402 1
a402 1
#endif /* OPENSSL_SYS_WINDOWS */
d406 1
a406 1
void BIO_sock_cleanup(void)
d408 1
a408 1
#ifdef OPENSSL_SYS_WINDOWS
d418 4
a421 3
#if !defined(OPENSSL_SYS_VMS) || __VMS_VER >= 70000000

int BIO_socket_ioctl(int fd, long type, unsigned long *arg)
a429 1
#endif /* __VMS_VER */
d433 3
a435 1
static int get_ip(const char *str, unsigned char ip[4])
d449 1
a449 1
			if (tmp[num] > 255) return(0);
d454 1
a454 1
			if (num == 3) return(0);
d458 1
a458 1
		else if (c == '\0' && (num == 3) && ok)
d470 2
a471 1
int BIO_get_accept_socket(char *host, int bind_mode)
d474 2
a475 2
	struct sockaddr_in server,client;
	int s=INVALID_SOCKET,cs;
d477 2
a478 3
	unsigned short port;
	char *str=NULL,*e;
	const char *h,*p;
a479 1
	int err_num;
d481 1
a481 1
	if (BIO_sock_init() != 1) return(INVALID_SOCKET);
d507 1
a507 1
	if (!BIO_get_port(p,&port)) goto err;
d511 1
a511 1
	server.sin_port=htons(port);
d517 1
a517 1
                if (!BIO_get_host_ip(h,&(ip[0]))) goto err;
d520 3
a522 3
			((unsigned long)ip[1]<<16L)|
			((unsigned long)ip[2]<< 8L)|
			((unsigned long)ip[3]);
a525 1
again:
a533 10

#ifdef SO_REUSEADDR
	if (bind_mode == BIO_BIND_REUSEADDR)
		{
		int i=1;

		ret=setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i));
		bind_mode=BIO_BIND_NORMAL;
		}
#endif
d536 1
a536 27
#ifdef SO_REUSEADDR
		err_num=get_last_socket_error();
		if ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) &&
			(err_num == EADDRINUSE))
			{
			memcpy((char *)&client,(char *)&server,sizeof(server));
			if (strcmp(h,"*") == 0)
				client.sin_addr.s_addr=htonl(0x7F000001);
			cs=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);
			if (cs != INVALID_SOCKET)
				{
				int ii;
				ii=connect(cs,(struct sockaddr *)&client,
					sizeof(client));
				closesocket(cs);
				if (ii == INVALID_SOCKET)
					{
					bind_mode=BIO_BIND_REUSEADDR;
					closesocket(s);
					goto again;
					}
				/* else error */
				}
			/* else error */
			}
#endif
		SYSerr(SYS_F_BIND,err_num);
d550 1
a550 1
	if (str != NULL) OPENSSL_free(str);
d553 1
d555 3
d563 3
a565 1
int BIO_accept(int sock, char **addr)
d570 1
a570 1
	unsigned short port;
d576 1
a576 6
	/* Note: under VMS with SOCKETSHR the fourth parameter is currently
	 * of type (int *) whereas under other systems it is (void *) if
	 * you don't have a cast it will choke the compiler: if you do
	 * have a cast then you can either go for (int *) or (void *).
	 */
	ret=accept(sock,(struct sockaddr *)&from,(void *)&len);
a578 1
		if(BIO_sock_should_retry(ret)) return -2;
d590 1
a590 1
		if ((p=OPENSSL_malloc(24)) == NULL)
d607 3
a609 1
int BIO_set_tcp_ndelay(int s, int on)
a628 11
int BIO_socket_nbio(int s, int mode)
	{
	int ret= -1;
	unsigned long l;

	l=mode;
#ifdef FIONBIO
	ret=BIO_socket_ioctl(s,FIONBIO,&l);
#endif
	return(ret == 0);
	}
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a486 3
#ifdef __DJGPP__
	i=ioctlsocket(fd,type,(char *)arg);
#else
a487 1
#endif /* __DJGPP__ */
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a85 1
#if 0
a95 1
#endif
a232 1
#if 0
a269 1
#endif
a465 6
#ifdef WATT32
	extern int _watt_do_exit;
	_watt_do_exit = 0;    /* don't make sock_init() call exit() */
	if (sock_init())
		return (-1);
#endif
a474 1
#ifndef OPENSSL_SYS_WINCE
a475 1
#endif
d483 1
a483 1
int BIO_socket_ioctl(int fd, long type, void *arg)
d733 1
a733 1
	int l;
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@d712 6
a717 6
	BIO_snprintf(*addr,24,"%d.%d.%d.%d:%d",
		     (unsigned char)(l>>24L)&0xff,
		     (unsigned char)(l>>16L)&0xff,
		     (unsigned char)(l>> 8L)&0xff,
		     (unsigned char)(l     )&0xff,
		     port);
@


1.1.1.6
log
@import of OpenSSL 0.9.8h
@
text
@d59 2
a66 9
#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_BSDSOCK)
#include <netdb.h>
#if defined(NETWARE_CLIB)
#include <sys/ioctl.h>
NETDB_DEFINE_CONTEXT
#endif
#endif

#ifndef OPENSSL_NO_SOCK
d82 1
a82 1
#if defined(OPENSSL_SYS_WINDOWS) || (defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK))
d178 1
d180 1
a180 3
		s=getservbyname((char *)str,"tcp");
#else
		s=getservbyname(str,"tcp");
d182 1
a359 3
#if (defined(NETWARE_BSDSOCK) && !defined(__NOVELL_LIBC__))
	return gethostbyname((char*)name);
#else
a360 1
#endif
d400 1
d402 1
a402 3
		ret=gethostbyname((char *)name);
#  else
		ret=gethostbyname(name);
d404 1
d456 3
a475 20

#if defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
    WORD wVerReq;
    WSADATA wsaData;
    int err;

    if (!wsa_init_done)
    {
        wsa_init_done=1;
        wVerReq = MAKEWORD( 2, 0 );
        err = WSAStartup(wVerReq,&wsaData);
        if (err != 0)
        {
            SYSerr(SYS_F_WSASTARTUP,err);
            BIOerr(BIO_F_BIO_SOCK_INIT,BIO_R_WSASTARTUP);
            return(-1);
			}
		}
#endif

d486 1
a486 1
		WSACancelBlockingCall();	/* Winsock 1.1 specific */
a488 6
		}
#elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)
   if (wsa_init_done)
        {
        wsa_init_done=0;
        WSACleanup();
@


1.1.1.7
log
@import OpenSSL-1.0.0a
@
text
@d75 3
a77 2
#include <openssl/dso.h>

d79 1
a92 11
/*
 * WSAAPI specifier is required to make indirect calls to run-time
 * linked WinSock 2 functions used in this module, to be specific
 * [get|free]addrinfo and getnameinfo. This is because WinSock uses
 * uses non-C calling convention, __stdcall vs. __cdecl, on x86
 * Windows. On non-WinSock platforms WSAAPI needs to be void.
 */
#ifndef WSAAPI
#define WSAAPI
#endif

a228 4
#if defined(OPENSSL_SYS_BEOS_R5)
	return 0;
#endif
		 
d469 1
a469 6
		/* Not making wsa_state available to the rest of the
		 * code is formally wrong. But the structures we use
		 * are [beleived to be] invariable among Winsock DLLs,
		 * while API availability is [expected to be] probed
		 * at run-time with DSO_global_lookup. */
		if (WSAStartup(0x0202,&wsa_state)!=0)
d513 2
a514 2
#if 0		/* this call is claimed to be non-present in Winsock2 */
		WSACancelBlockingCall();
d584 2
a585 8
	union {
		struct sockaddr sa;
		struct sockaddr_in sa_in;
#if OPENSSL_USE_IPV6
		struct sockaddr_in6 sa_in6;
#endif
	} server,client;
	int s=INVALID_SOCKET,cs,addrlen;
d589 1
a589 1
	char *h,*p;
d603 2
a604 1
			p=e;
a611 2
	if (p)	*p++='\0';	/* points at last ':', '::port' is special [see below] */
	else	p=h,h=NULL;
d613 4
a616 38
#ifdef EAI_FAMILY
	do {
	static union {	void *p;
			int (WSAAPI *f)(const char *,const char *,
				 const struct addrinfo *,
				 struct addrinfo **);
			} p_getaddrinfo = {NULL};
	static union {	void *p;
			void (WSAAPI *f)(struct addrinfo *);
			} p_freeaddrinfo = {NULL};
	struct addrinfo *res,hint;

	if (p_getaddrinfo.p==NULL)
		{
		if ((p_getaddrinfo.p=DSO_global_lookup("getaddrinfo"))==NULL ||
		    (p_freeaddrinfo.p=DSO_global_lookup("freeaddrinfo"))==NULL)
			p_getaddrinfo.p=(void*)-1;
		}
	if (p_getaddrinfo.p==(void *)-1) break;

	/* '::port' enforces IPv6 wildcard listener. Some OSes,
	 * e.g. Solaris, default to IPv6 without any hint. Also
	 * note that commonly IPv6 wildchard socket can service
	 * IPv4 connections just as well...  */
	memset(&hint,0,sizeof(hint));
	if (h)
		{
		if (strchr(h,':'))
			{
			if (h[1]=='\0') h=NULL;
#if OPENSSL_USE_IPV6
			hint.ai_family = AF_INET6;
#else
			h=NULL;
#endif
			}
	    	else if (h[0]=='*' && h[1]=='\0')
			h=NULL;
a618 12
	if ((*p_getaddrinfo.f)(h,p,&hint,&res)) break;

	addrlen = res->ai_addrlen<=sizeof(server) ?
			res->ai_addrlen :
			sizeof(server);
	memcpy(&server, res->ai_addr, addrlen);

	(*p_freeaddrinfo.f)(res);
	goto again;
	} while (0);
#endif

d622 2
a623 3
	server.sa_in.sin_family=AF_INET;
	server.sa_in.sin_port=htons(port);
	addrlen = sizeof(server.sa_in);
d625 2
a626 2
	if (h == NULL || strcmp(h,"*") == 0)
		server.sa_in.sin_addr.s_addr=INADDR_ANY;
d635 1
a635 1
		server.sa_in.sin_addr.s_addr=htonl(l);
d639 1
a639 1
	s=socket(server.sa.sa_family,SOCK_STREAM,SOCKET_PROTOCOL);
d657 1
a657 1
	if (bind(s,&server.sa,addrlen) == -1)
a661 6
#ifdef OPENSSL_SYS_WINDOWS
			/* Some versions of Windows define EADDRINUSE to
			 * a dummy value.
			 */
			(err_num == WSAEADDRINUSE))
#else
a662 1
#endif
d664 4
a667 18
			client = server;
			if (h == NULL || strcmp(h,"*") == 0)
				{
#if OPENSSL_USE_IPV6
				if (client.sa.sa_family == AF_INET6)
					{
					memset(&client.sa_in6.sin6_addr,0,sizeof(client.sa_in6.sin6_addr));
					client.sa_in6.sin6_addr.s6_addr[15]=1;
					}
				else
#endif
				if (client.sa.sa_family == AF_INET)
					{
					client.sa_in.sin_addr.s_addr=htonl(0x7F000001);
					}
				else	goto err;
				}
			cs=socket(client.sa.sa_family,SOCK_STREAM,SOCKET_PROTOCOL);
d671 2
a672 1
				ii=connect(cs,&client.sa,addrlen);
d711 1
d714 1
d717 6
a722 21
	struct {
	/*
	 * As for following union. Trouble is that there are platforms
	 * that have socklen_t and there are platforms that don't, on
	 * some platforms socklen_t is int and on some size_t. So what
	 * one can do? One can cook #ifdef spaghetti, which is nothing
	 * but masochistic. Or one can do union between int and size_t.
	 * One naturally does it primarily for 64-bit platforms where
	 * sizeof(int) != sizeof(size_t). But would it work? Note that
	 * if size_t member is initialized to 0, then later int member
	 * assignment naturally does the job on little-endian platforms
	 * regardless accept's expectations! What about big-endians?
	 * If accept expects int*, then it works, and if size_t*, then
	 * length value would appear as unreasonably large. But this
	 * won't prevent it from filling in the address structure. The
	 * trouble of course would be if accept returns more data than
	 * actual buffer can accomodate and overwrite stack... That's
	 * where early OPENSSL_assert comes into picture. Besides, the
	 * only 64-bit big-endian platform found so far that expects
	 * size_t* is HP-UX, where stack grows towards higher address.
	 * <appro>
d724 1
a724 20
	union { size_t s; int i; } len;
	union {
		struct sockaddr sa;
		struct sockaddr_in sa_in;
#if OPENSSL_USE_IPV6
		struct sockaddr_in6 sa_in6;
#endif
		} from;
	} sa;

	sa.len.s=0;
	sa.len.i=sizeof(sa.from);
	memset(&sa.from,0,sizeof(sa.from));
	ret=accept(sock,&sa.from.sa,(void *)&sa.len);
	if (sizeof(sa.len.i)!=sizeof(sa.len.s) && sa.len.i==0)
		{
		OPENSSL_assert(sa.len.s<=sizeof(sa.from));
		sa.len.i = (int)sa.len.s;
		/* use sa.len.i from this point */
		}
d735 2
a736 40
#ifdef EAI_FAMILY
	do {
	char   h[NI_MAXHOST],s[NI_MAXSERV];
	size_t nl;
	static union {	void *p;
			int (WSAAPI *f)(const struct sockaddr *,size_t/*socklen_t*/,
				 char *,size_t,char *,size_t,int);
			} p_getnameinfo = {NULL};
			/* 2nd argument to getnameinfo is specified to
			 * be socklen_t. Unfortunately there is a number
			 * of environments where socklen_t is not defined.
			 * As it's passed by value, it's safe to pass it
			 * as size_t... <appro> */

	if (p_getnameinfo.p==NULL)
		{
		if ((p_getnameinfo.p=DSO_global_lookup("getnameinfo"))==NULL)
			p_getnameinfo.p=(void*)-1;
		}
	if (p_getnameinfo.p==(void *)-1) break;

	if ((*p_getnameinfo.f)(&sa.from.sa,sa.len.i,h,sizeof(h),s,sizeof(s),
	    NI_NUMERICHOST|NI_NUMERICSERV)) break;
	nl = strlen(h)+strlen(s)+2;
	p = *addr;
	if (p)	{ *p = '\0'; p = OPENSSL_realloc(p,nl);	}
	else	{ p = OPENSSL_malloc(nl);		}
	if (p==NULL)
		{
		BIOerr(BIO_F_BIO_ACCEPT,ERR_R_MALLOC_FAILURE);
		goto end;
		}
	*addr = p;
	BIO_snprintf(*addr,nl,"%s:%s",h,s);
	goto end;
	} while(0);
#endif
	if (sa.from.sa.sa_family != AF_INET) goto end;
	l=ntohl(sa.from.sa_in.sin_addr.s_addr);
	port=ntohs(sa.from.sa_in.sin_port);
@


1.1.1.8
log
@import OpenSSL 1.0.0e
@
text
@d554 1
a554 24
# if defined(OPENSSL_SYS_VMS)
	/* 2011-02-18 SMS.
	 * VMS ioctl() can't tolerate a 64-bit "void *arg", but we
	 * observe that all the consumers pass in an "unsigned long *",
	 * so we arrange a local copy with a short pointer, and use
	 * that, instead.
	 */
#  if __INITIAL_POINTER_SIZE == 64
#   define ARG arg_32p
#   pragma pointer_size save
#   pragma pointer_size 32
	unsigned long arg_32;
	unsigned long *arg_32p;
#   pragma pointer_size restore
	arg_32p = &arg_32;
	arg_32 = *((unsigned long *) arg);
#  else /* __INITIAL_POINTER_SIZE == 64 */
#   define ARG arg
#  endif /* __INITIAL_POINTER_SIZE == 64 [else] */
# else /* defined(OPENSSL_SYS_VMS) */
#  define ARG arg
# endif /* defined(OPENSSL_SYS_VMS) [else] */

	i=ioctlsocket(fd,type,ARG);
a662 1
	hint.ai_flags = AI_PASSIVE;
a674 2
			{
			hint.ai_family = AF_INET;
a675 1
			}
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@d963 1
a975 1
#endif
@


