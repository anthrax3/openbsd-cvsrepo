head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23;
locks; strict;
comment	@ * @;


1.23
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.22;
commitid	kT0fLt3r4lroFJra;

1.22
date	2015.12.23.20.37.23;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	5o0uX3Cl1ddb0aBa;

1.21
date	2015.10.30.15.45.57;	author miod;	state Exp;
branches;
next	1.20;
commitid	QhrN3pc9Qw2DDhdM;

1.20
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	mJUVYpkFBZ0Zv2bG;

1.19
date	2014.06.11.01.53.02;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	4evB2EbwDYaBfe0g;

1.18
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2014.05.24.07.11.39;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.18.14.37.41;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.22.23.27;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.17.17.50.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.15.16.37.21;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.09.12.15.30;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.21.01.49.11;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.17;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.33;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.09.09;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.35.41;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.49.55;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.34.40;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.11.21.12.35;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.13.52;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.35;	author djm;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: bss_bio.c,v 1.22 2015/12/23 20:37:23 mmcc Exp $ */
/* ====================================================================
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

/* Special method for a BIO where the other endpoint is also a BIO
 * of this kind, handled by the same thread (i.e. the "peer" is actually
 * ourselves, wearing a different hat).
 * Such "BIO pairs" are mainly for using the SSL library with I/O interfaces
 * for which no specific BIO method is available.
 * See ssl/ssltest.c for some hints on how this can be used. */

/* BIO_DEBUG implies BIO_PAIR_DEBUG */
#ifdef BIO_DEBUG
# ifndef BIO_PAIR_DEBUG
#  define BIO_PAIR_DEBUG
# endif
#endif

/* disable assert() unless BIO_PAIR_DEBUG has been defined */
#ifndef BIO_PAIR_DEBUG
# ifndef NDEBUG
#  define NDEBUG
# endif
#endif

#include <assert.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>

#include <openssl/bio.h>
#include <openssl/err.h>
#include <openssl/crypto.h>

static int bio_new(BIO *bio);
static int bio_free(BIO *bio);
static int bio_read(BIO *bio, char *buf, int size);
static int bio_write(BIO *bio, const char *buf, int num);
static long bio_ctrl(BIO *bio, int cmd, long num, void *ptr);
static int bio_puts(BIO *bio, const char *str);

static int bio_make_pair(BIO *bio1, BIO *bio2);
static void bio_destroy_pair(BIO *bio);

static BIO_METHOD methods_biop = {
	.type = BIO_TYPE_BIO,
	.name = "BIO pair",
	.bwrite = bio_write,
	.bread = bio_read,
	.bputs = bio_puts,
	.ctrl = bio_ctrl,
	.create = bio_new,
	.destroy = bio_free
};

BIO_METHOD *
BIO_s_bio(void)
{
	return &methods_biop;
}

struct bio_bio_st {
	BIO *peer;	/* NULL if buf == NULL.
			 * If peer != NULL, then peer->ptr is also a bio_bio_st,
			 * and its "peer" member points back to us.
			 * peer != NULL iff init != 0 in the BIO. */

	/* This is for what we write (i.e. reading uses peer's struct): */
	int closed;	/* valid iff peer != NULL */
	size_t len;	/* valid iff buf != NULL; 0 if peer == NULL */
	size_t offset;	/* valid iff buf != NULL; 0 if len == 0 */
	size_t size;
	char *buf;      /* "size" elements (if != NULL) */

	size_t request; /* valid iff peer != NULL; 0 if len != 0,
			 * otherwise set by peer to number of bytes
			 * it (unsuccessfully) tried to read,
	                 * never more than buffer space (size-len) warrants. */
};

static int
bio_new(BIO *bio)
{
	struct bio_bio_st *b;

	b = malloc(sizeof *b);
	if (b == NULL)
		return 0;

	b->peer = NULL;
	b->size = 17 * 1024; /* enough for one TLS record (just a default) */
	b->buf = NULL;

	bio->ptr = b;
	return 1;
}

static int
bio_free(BIO *bio)
{
	struct bio_bio_st *b;

	if (bio == NULL)
		return 0;
	b = bio->ptr;

	assert(b != NULL);

	if (b->peer)
		bio_destroy_pair(bio);

	free(b->buf);
	free(b);
	return 1;
}



static int
bio_read(BIO *bio, char *buf, int size_)
{
	size_t size = size_;
	size_t rest;
	struct bio_bio_st *b, *peer_b;

	BIO_clear_retry_flags(bio);

	if (!bio->init)
		return 0;

	b = bio->ptr;
	assert(b != NULL);
	assert(b->peer != NULL);
	peer_b = b->peer->ptr;
	assert(peer_b != NULL);
	assert(peer_b->buf != NULL);

	peer_b->request = 0; /* will be set in "retry_read" situation */

	if (buf == NULL || size == 0)
		return 0;

	if (peer_b->len == 0) {
		if (peer_b->closed)
			return 0; /* writer has closed, and no data is left */
		else {
			BIO_set_retry_read(bio); /* buffer is empty */
			if (size <= peer_b->size)
				peer_b->request = size;
			else
				/* don't ask for more than the peer can
				 * deliver in one write */
				peer_b->request = peer_b->size;
			return -1;
		}
	}

	/* we can read */
	if (peer_b->len < size)
		size = peer_b->len;

	/* now read "size" bytes */

	rest = size;

	assert(rest > 0);
	do /* one or two iterations */
	{
		size_t chunk;

		assert(rest <= peer_b->len);
		if (peer_b->offset + rest <= peer_b->size)
			chunk = rest;
		else
			/* wrap around ring buffer */
			chunk = peer_b->size - peer_b->offset;
		assert(peer_b->offset + chunk <= peer_b->size);

		memcpy(buf, peer_b->buf + peer_b->offset, chunk);

		peer_b->len -= chunk;
		if (peer_b->len) {
			peer_b->offset += chunk;
			assert(peer_b->offset <= peer_b->size);
			if (peer_b->offset == peer_b->size)
				peer_b->offset = 0;
			buf += chunk;
		} else {
			/* buffer now empty, no need to advance "buf" */
			assert(chunk == rest);
			peer_b->offset = 0;
		}
		rest -= chunk;
	} while (rest);

	return size;
}

/* non-copying interface: provide pointer to available data in buffer
 *    bio_nread0:  return number of available bytes
 *    bio_nread:   also advance index
 * (example usage:  bio_nread0(), read from buffer, bio_nread()
 *  or just         bio_nread(), read from buffer)
 */
/* WARNING: The non-copying interface is largely untested as of yet
 * and may contain bugs. */
static ssize_t
bio_nread0(BIO *bio, char **buf)
{
	struct bio_bio_st *b, *peer_b;
	ssize_t num;

	BIO_clear_retry_flags(bio);

	if (!bio->init)
		return 0;

	b = bio->ptr;
	assert(b != NULL);
	assert(b->peer != NULL);
	peer_b = b->peer->ptr;
	assert(peer_b != NULL);
	assert(peer_b->buf != NULL);

	peer_b->request = 0;

	if (peer_b->len == 0) {
		char dummy;

		/* avoid code duplication -- nothing available for reading */
		return bio_read(bio, &dummy, 1); /* returns 0 or -1 */
	}

	num = peer_b->len;
	if (peer_b->size < peer_b->offset + num)
		/* no ring buffer wrap-around for non-copying interface */
		num = peer_b->size - peer_b->offset;
	assert(num > 0);

	if (buf != NULL)
		*buf = peer_b->buf + peer_b->offset;
	return num;
}

static ssize_t
bio_nread(BIO *bio, char **buf, size_t num_)
{
	struct bio_bio_st *b, *peer_b;
	ssize_t num, available;

	if (num_ > SSIZE_MAX)
		num = SSIZE_MAX;
	else
		num = (ssize_t)num_;

	available = bio_nread0(bio, buf);
	if (num > available)
		num = available;
	if (num <= 0)
		return num;

	b = bio->ptr;
	peer_b = b->peer->ptr;

	peer_b->len -= num;
	if (peer_b->len) {
		peer_b->offset += num;
		assert(peer_b->offset <= peer_b->size);
		if (peer_b->offset == peer_b->size)
			peer_b->offset = 0;
	} else
		peer_b->offset = 0;

	return num;
}


static int
bio_write(BIO *bio, const char *buf, int num_)
{
	size_t num = num_;
	size_t rest;
	struct bio_bio_st *b;

	BIO_clear_retry_flags(bio);

	if (!bio->init || buf == NULL || num == 0)
		return 0;

	b = bio->ptr;

	assert(b != NULL);
	assert(b->peer != NULL);
	assert(b->buf != NULL);

	b->request = 0;
	if (b->closed) {
		/* we already closed */
		BIOerror(BIO_R_BROKEN_PIPE);
		return -1;
	}

	assert(b->len <= b->size);

	if (b->len == b->size) {
		BIO_set_retry_write(bio); /* buffer is full */
		return -1;
	}

	/* we can write */
	if (num > b->size - b->len)
		num = b->size - b->len;

	/* now write "num" bytes */

	rest = num;

	assert(rest > 0);
	do /* one or two iterations */
	{
		size_t write_offset;
		size_t chunk;

		assert(b->len + rest <= b->size);

		write_offset = b->offset + b->len;
		if (write_offset >= b->size)
			write_offset -= b->size;
		/* b->buf[write_offset] is the first byte we can write to. */

		if (write_offset + rest <= b->size)
			chunk = rest;
		else
			/* wrap around ring buffer */
			chunk = b->size - write_offset;

		memcpy(b->buf + write_offset, buf, chunk);

		b->len += chunk;

		assert(b->len <= b->size);

		rest -= chunk;
		buf += chunk;
	} while (rest);

	return num;
}

/* non-copying interface: provide pointer to region to write to
 *   bio_nwrite0:  check how much space is available
 *   bio_nwrite:   also increase length
 * (example usage:  bio_nwrite0(), write to buffer, bio_nwrite()
 *  or just         bio_nwrite(), write to buffer)
 */
static ssize_t
bio_nwrite0(BIO *bio, char **buf)
{
	struct bio_bio_st *b;
	size_t num;
	size_t write_offset;

	BIO_clear_retry_flags(bio);

	if (!bio->init)
		return 0;

	b = bio->ptr;

	assert(b != NULL);
	assert(b->peer != NULL);
	assert(b->buf != NULL);

	b->request = 0;
	if (b->closed) {
		BIOerror(BIO_R_BROKEN_PIPE);
		return -1;
	}

	assert(b->len <= b->size);

	if (b->len == b->size) {
		BIO_set_retry_write(bio);
		return -1;
	}

	num = b->size - b->len;
	write_offset = b->offset + b->len;
	if (write_offset >= b->size)
		write_offset -= b->size;
	if (write_offset + num > b->size)
		/* no ring buffer wrap-around for non-copying interface
		 * (to fulfil the promise by BIO_ctrl_get_write_guarantee,
		 * BIO_nwrite may have to be called twice) */
		num = b->size - write_offset;

	if (buf != NULL)
		*buf = b->buf + write_offset;
	assert(write_offset + num <= b->size);

	return num;
}

static ssize_t
bio_nwrite(BIO *bio, char **buf, size_t num_)
{
	struct bio_bio_st *b;
	ssize_t num, space;

	if (num_ > SSIZE_MAX)
		num = SSIZE_MAX;
	else
		num = (ssize_t)num_;

	space = bio_nwrite0(bio, buf);
	if (num > space)
		num = space;
	if (num <= 0)
		return num;
	b = bio->ptr;
	assert(b != NULL);
	b->len += num;
	assert(b->len <= b->size);

	return num;
}


static long
bio_ctrl(BIO *bio, int cmd, long num, void *ptr)
{
	long ret;
	struct bio_bio_st *b = bio->ptr;

	assert(b != NULL);

	switch (cmd) {
		/* specific CTRL codes */

	case BIO_C_SET_WRITE_BUF_SIZE:
		if (b->peer) {
			BIOerror(BIO_R_IN_USE);
			ret = 0;
		} else if (num == 0) {
			BIOerror(BIO_R_INVALID_ARGUMENT);
			ret = 0;
		} else {
			size_t new_size = num;

			if (b->size != new_size) {
				free(b->buf);
				b->buf = NULL;
				b->size = new_size;
			}
			ret = 1;
		}
		break;

	case BIO_C_GET_WRITE_BUF_SIZE:
		ret = (long) b->size;
		break;

	case BIO_C_MAKE_BIO_PAIR:
		{
			BIO *other_bio = ptr;

			if (bio_make_pair(bio, other_bio))
				ret = 1;
			else
				ret = 0;
		}
		break;

	case BIO_C_DESTROY_BIO_PAIR:
		/* Affects both BIOs in the pair -- call just once!
		 * Or let BIO_free(bio1); BIO_free(bio2); do the job. */
		bio_destroy_pair(bio);
		ret = 1;
		break;

	case BIO_C_GET_WRITE_GUARANTEE:
		/* How many bytes can the caller feed to the next write
		 * without having to keep any? */
		if (b->peer == NULL || b->closed)
			ret = 0;
		else
			ret = (long) b->size - b->len;
		break;

	case BIO_C_GET_READ_REQUEST:
		/* If the peer unsuccessfully tried to read, how many bytes
		 * were requested?  (As with BIO_CTRL_PENDING, that number
		 * can usually be treated as boolean.) */
		ret = (long) b->request;
		break;

	case BIO_C_RESET_READ_REQUEST:
		/* Reset request.  (Can be useful after read attempts
		 * at the other side that are meant to be non-blocking,
		 * e.g. when probing SSL_read to see if any data is
		 * available.) */
		b->request = 0;
		ret = 1;
		break;

	case BIO_C_SHUTDOWN_WR:
		/* similar to shutdown(..., SHUT_WR) */
		b->closed = 1;
		ret = 1;
		break;

	case BIO_C_NREAD0:
		/* prepare for non-copying read */
		ret = (long) bio_nread0(bio, ptr);
		break;

	case BIO_C_NREAD:
		/* non-copying read */
		ret = (long) bio_nread(bio, ptr, (size_t) num);
		break;

	case BIO_C_NWRITE0:
		/* prepare for non-copying write */
		ret = (long) bio_nwrite0(bio, ptr);
		break;

	case BIO_C_NWRITE:
		/* non-copying write */
		ret = (long) bio_nwrite(bio, ptr, (size_t) num);
		break;


		/* standard CTRL codes follow */

	case BIO_CTRL_RESET:
		if (b->buf != NULL) {
			b->len = 0;
			b->offset = 0;
		}
		ret = 0;
		break;


	case BIO_CTRL_GET_CLOSE:
		ret = bio->shutdown;
		break;

	case BIO_CTRL_SET_CLOSE:
		bio->shutdown = (int) num;
		ret = 1;
		break;

	case BIO_CTRL_PENDING:
		if (b->peer != NULL) {
			struct bio_bio_st *peer_b = b->peer->ptr;

			ret = (long) peer_b->len;
		} else
			ret = 0;
		break;

	case BIO_CTRL_WPENDING:
		if (b->buf != NULL)
			ret = (long) b->len;
		else
			ret = 0;
		break;

	case BIO_CTRL_DUP:
		/* See BIO_dup_chain for circumstances we have to expect. */
		{
			BIO *other_bio = ptr;
			struct bio_bio_st *other_b;

			assert(other_bio != NULL);
			other_b = other_bio->ptr;
			assert(other_b != NULL);

			assert(other_b->buf == NULL); /* other_bio is always fresh */

			other_b->size = b->size;
		}

		ret = 1;
		break;

	case BIO_CTRL_FLUSH:
		ret = 1;
		break;

	case BIO_CTRL_EOF:
		{
			BIO *other_bio = ptr;

			if (other_bio) {
				struct bio_bio_st *other_b = other_bio->ptr;

				assert(other_b != NULL);
				ret = other_b->len == 0 && other_b->closed;
			} else
				ret = 1;
		}
		break;

	default:
		ret = 0;
	}
	return ret;
}

static int
bio_puts(BIO *bio, const char *str)
{
	return bio_write(bio, str, strlen(str));
}


static int
bio_make_pair(BIO *bio1, BIO *bio2)
{
	struct bio_bio_st *b1, *b2;

	assert(bio1 != NULL);
	assert(bio2 != NULL);

	b1 = bio1->ptr;
	b2 = bio2->ptr;

	if (b1->peer != NULL || b2->peer != NULL) {
		BIOerror(BIO_R_IN_USE);
		return 0;
	}

	if (b1->buf == NULL) {
		b1->buf = malloc(b1->size);
		if (b1->buf == NULL) {
			BIOerror(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		b1->len = 0;
		b1->offset = 0;
	}

	if (b2->buf == NULL) {
		b2->buf = malloc(b2->size);
		if (b2->buf == NULL) {
			BIOerror(ERR_R_MALLOC_FAILURE);
			return 0;
		}
		b2->len = 0;
		b2->offset = 0;
	}

	b1->peer = bio2;
	b1->closed = 0;
	b1->request = 0;
	b2->peer = bio1;
	b2->closed = 0;
	b2->request = 0;

	bio1->init = 1;
	bio2->init = 1;

	return 1;
}

static void
bio_destroy_pair(BIO *bio)
{
	struct bio_bio_st *b = bio->ptr;

	if (b != NULL) {
		BIO *peer_bio = b->peer;

		if (peer_bio != NULL) {
			struct bio_bio_st *peer_b = peer_bio->ptr;

			assert(peer_b != NULL);
			assert(peer_b->peer == bio);

			peer_b->peer = NULL;
			peer_bio->init = 0;
			assert(peer_b->buf != NULL);
			peer_b->len = 0;
			peer_b->offset = 0;

			b->peer = NULL;
			bio->init = 0;
			assert(b->buf != NULL);
			b->len = 0;
			b->offset = 0;
		}
	}
}


/* Exported convenience functions */
int
BIO_new_bio_pair(BIO **bio1_p, size_t writebuf1, BIO **bio2_p, size_t writebuf2)
{
	BIO *bio1 = NULL, *bio2 = NULL;
	long r;
	int ret = 0;

	bio1 = BIO_new(BIO_s_bio());
	if (bio1 == NULL)
		goto err;
	bio2 = BIO_new(BIO_s_bio());
	if (bio2 == NULL)
		goto err;

	if (writebuf1) {
		r = BIO_set_write_buf_size(bio1, writebuf1);
		if (!r)
			goto err;
	}
	if (writebuf2) {
		r = BIO_set_write_buf_size(bio2, writebuf2);
		if (!r)
			goto err;
	}

	r = BIO_make_bio_pair(bio1, bio2);
	if (!r)
		goto err;
	ret = 1;

	err:
	if (ret == 0) {
		if (bio1) {
			BIO_free(bio1);
			bio1 = NULL;
		}
		if (bio2) {
			BIO_free(bio2);
			bio2 = NULL;
		}
	}

	*bio1_p = bio1;
	*bio2_p = bio2;
	return ret;
}

size_t
BIO_ctrl_get_write_guarantee(BIO *bio)
{
	return BIO_ctrl(bio, BIO_C_GET_WRITE_GUARANTEE, 0, NULL);
}

size_t
BIO_ctrl_get_read_request(BIO *bio)
{
	return BIO_ctrl(bio, BIO_C_GET_READ_REQUEST, 0, NULL);
}

int
BIO_ctrl_reset_read_request(BIO *bio)
{
	return (BIO_ctrl(bio, BIO_C_RESET_READ_REQUEST, 0, NULL) != 0);
}


/* BIO_nread0/nread/nwrite0/nwrite are available only for BIO pairs for now
 * (conceivably some other BIOs could allow non-copying reads and writes too.)
 */
int
BIO_nread0(BIO *bio, char **buf)
{
	long ret;

	if (!bio->init) {
		BIOerror(BIO_R_UNINITIALIZED);
		return -2;
	}

	ret = BIO_ctrl(bio, BIO_C_NREAD0, 0, buf);
	if (ret > INT_MAX)
		return INT_MAX;
	else
		return (int) ret;
}

int
BIO_nread(BIO *bio, char **buf, int num)
{
	int ret;

	if (!bio->init) {
		BIOerror(BIO_R_UNINITIALIZED);
		return -2;
	}

	ret = (int) BIO_ctrl(bio, BIO_C_NREAD, num, buf);
	if (ret > 0)
		bio->num_read += ret;
	return ret;
}

int
BIO_nwrite0(BIO *bio, char **buf)
{
	long ret;

	if (!bio->init) {
		BIOerror(BIO_R_UNINITIALIZED);
		return -2;
	}

	ret = BIO_ctrl(bio, BIO_C_NWRITE0, 0, buf);
	if (ret > INT_MAX)
		return INT_MAX;
	else
		return (int) ret;
}

int
BIO_nwrite(BIO *bio, char **buf, int num)
{
	int ret;

	if (!bio->init) {
		BIOerror(BIO_R_UNINITIALIZED);
		return -2;
	}

	ret = BIO_ctrl(bio, BIO_C_NWRITE, num, buf);
	if (ret > 0)
		bio->num_write += ret;
	return ret;
}
@


1.22
log
@remove NULL-checks before free()
@
text
@d1 1
a1 1
/* $OpenBSD: bss_bio.c,v 1.21 2015/10/30 15:45:57 miod Exp $ */
d351 1
a351 1
		BIOerr(BIO_F_BIO_WRITE, BIO_R_BROKEN_PIPE);
d428 1
a428 1
		BIOerr(BIO_F_BIO_NWRITE0, BIO_R_BROKEN_PIPE);
d494 1
a494 1
			BIOerr(BIO_F_BIO_CTRL, BIO_R_IN_USE);
d497 1
a497 1
			BIOerr(BIO_F_BIO_CTRL, BIO_R_INVALID_ARGUMENT);
d682 1
a682 1
		BIOerr(BIO_F_BIO_MAKE_PAIR, BIO_R_IN_USE);
d689 1
a689 1
			BIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);
d699 1
a699 1
			BIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);
d825 1
a825 1
		BIOerr(BIO_F_BIO_NREAD0, BIO_R_UNINITIALIZED);
d842 1
a842 1
		BIOerr(BIO_F_BIO_NREAD, BIO_R_UNINITIALIZED);
d858 1
a858 1
		BIOerr(BIO_F_BIO_NWRITE0, BIO_R_UNINITIALIZED);
d875 1
a875 1
		BIOerr(BIO_F_BIO_NWRITE, BIO_R_UNINITIALIZED);
@


1.21
log
@Pull in <sys/types.h> to get ssize_t or <stdint.h> to get uint32_t, instead of
relying upon previously included headers to do this, to enhance portability;
from Pascal Cuoq, libressl github pull request #52
@
text
@d1 1
a1 1
/* $OpenBSD: bss_bio.c,v 1.20 2014/06/12 15:49:28 deraadt Exp $ */
d503 2
a504 4
				if (b->buf) {
					free(b->buf);
					b->buf = NULL;
				}
@


1.20
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d81 1
@


1.19
log
@c-file-style hints, begone; ok beck
@
text
@d1 1
a1 1
/* crypto/bio/bss_bio.c */
@


1.18
log
@more: no need for null check before free
ok tedu guenther
@
text
@d1 1
a1 1
/* crypto/bio/bss_bio.c  -*- Mode: C; c-file-style: "eay" -*- */
@


1.17
log
@Spell ssize_t correctly (the incorrect spelling is ossl_ssize_t).

ok miod@@
@
text
@d163 1
a163 4
	if (b->buf != NULL) {
		free(b->buf);
	}

a164 1

@


1.16
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d262 1
a262 1
static ossl_ssize_t
d266 1
a266 1
	ossl_ssize_t num;
d300 1
a300 1
static ossl_ssize_t
d304 1
a304 1
	ossl_ssize_t num, available;
d309 1
a309 1
		num = (ossl_ssize_t)num_;
d411 1
a411 1
static ossl_ssize_t
d459 1
a459 1
static ossl_ssize_t
d463 1
a463 1
	ossl_ssize_t num, space;
d468 1
a468 1
		num = (ossl_ssize_t)num_;
@


1.15
log
@Put the final pieces from e_os.h in the required places, and remove it.
"dance on it's grave" says beck
ok guenther beck
@
text
@d97 8
a104 10
	BIO_TYPE_BIO,
	"BIO pair",
	bio_write,
	bio_read,
	bio_puts,
	NULL /* no bio_gets */,
	bio_ctrl,
	bio_new,
	bio_free,
	NULL /* no bio_callback_ctrl */
@


1.14
log
@don't fake up SSIZE_MAX
@
text
@a85 2
#include "e_os.h"

@


1.13
log
@some KNF cleanup following the script
@
text
@a87 8
/* VxWorks defines SSIZE_MAX with an empty value causing compile errors */
#if defined(OPENSSL_SYS_VXWORKS)
# undef SSIZE_MAX
#endif
#ifndef SSIZE_MAX
# define SSIZE_MAX INT_MAX
#endif

@


1.12
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d119 2
a120 2
BIO_METHOD
*BIO_s_bio(void)
@


1.11
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d149 1
a149 1
	b = OPENSSL_malloc(sizeof *b);
d176 1
a176 1
		OPENSSL_free(b->buf);
d179 1
a179 1
	OPENSSL_free(b);
d519 1
a519 1
					OPENSSL_free(b->buf);
d704 1
a704 1
		b1->buf = OPENSSL_malloc(b1->size);
d714 1
a714 1
		b2->buf = OPENSSL_malloc(b2->size);
@


1.10
log
@resolve conflicts
@
text
@d106 1
a106 2
static BIO_METHOD methods_biop =
{
d119 3
a121 2
BIO_METHOD *BIO_s_bio(void)
	{
d123 7
a129 1
	}
a130 7
struct bio_bio_st
{
	BIO *peer;     /* NULL if buf == NULL.
	                * If peer != NULL, then peer->ptr is also a bio_bio_st,
	                * and its "peer" member points back to us.
	                * peer != NULL iff init != 0 in the BIO. */
	
d132 3
a134 3
	int closed;     /* valid iff peer != NULL */
	size_t len;     /* valid iff buf != NULL; 0 if peer == NULL */
	size_t offset;  /* valid iff buf != NULL; 0 if len == 0 */
d139 2
a140 2
	                 * otherwise set by peer to number of bytes
	                 * it (unsuccessfully) tried to read,
d144 3
a146 2
static int bio_new(BIO *bio)
	{
d148 1
a148 1
	
d154 1
a154 1
	b->size = 17*1024; /* enough for one TLS record (just a default) */
d159 1
a159 1
	}
d161 3
a163 3

static int bio_free(BIO *bio)
	{
d174 2
a175 3
	
	if (b->buf != NULL)
		{
d177 1
a177 1
		}
d182 1
a182 1
	}
d186 3
a188 2
static int bio_read(BIO *bio, char *buf, int size_)
	{
d210 1
a210 2
	if (peer_b->len == 0)
		{
d213 1
a213 2
		else
			{
a221 1
			}
d223 1
d230 1
a230 1
	
d232 1
a232 1
	
d235 1
a235 1
		{
d237 1
a237 1
		
d245 1
a245 1
		
d247 1
a247 1
		
d249 1
a249 2
		if (peer_b->len)
			{
d255 1
a255 3
			}
		else
			{
d259 1
a259 1
			}
d261 2
a262 3
		}
	while (rest);
	
d264 1
a264 1
	}
d274 3
a276 2
static ossl_ssize_t bio_nread0(BIO *bio, char **buf)
	{
d279 1
a279 1
	
d284 1
a284 1
	
d291 1
a291 1
	
d293 2
a294 3
	
	if (peer_b->len == 0)
		{
d296 1
a296 1
		
d299 1
a299 1
		}
d310 1
a310 1
	}
d312 3
a314 2
static ossl_ssize_t bio_nread(BIO *bio, char **buf, size_t num_)
	{
d333 1
a333 2
	if (peer_b->len) 
		{
d338 1
a338 2
		}
	else
d342 1
a342 1
	}
d345 3
a347 2
static int bio_write(BIO *bio, const char *buf, int num_)
	{
d357 2
a358 1
	b = bio->ptr;		
d364 1
a364 2
	if (b->closed)
		{
d368 1
a368 1
		}
d372 1
a372 2
	if (b->len == b->size)
		{
d375 1
a375 1
		}
d380 1
a380 1
	
d384 1
a384 1
	
d387 1
a387 1
		{
d403 1
a403 1
		
d405 1
a405 1
		
d409 1
a409 1
		
d412 1
a412 2
		}
	while (rest);
d415 1
a415 1
	}
d423 3
a425 2
static ossl_ssize_t bio_nwrite0(BIO *bio, char **buf)
	{
d435 2
a436 1
	b = bio->ptr;		
d442 1
a442 2
	if (b->closed)
		{
d445 1
a445 1
		}
d449 1
a449 2
	if (b->len == b->size)
		{
d452 1
a452 1
		}
d469 1
a469 1
	}
d471 3
a473 2
static ossl_ssize_t bio_nwrite(BIO *bio, char **buf, size_t num_)
	{
d493 1
a493 1
	}
d496 3
a498 2
static long bio_ctrl(BIO *bio, int cmd, long num, void *ptr)
	{
d501 1
a501 1
	
d504 2
a505 3
	switch (cmd)
		{
	/* specific CTRL codes */
d508 1
a508 2
		if (b->peer)
			{
d511 1
a511 3
			}
		else if (num == 0)
			{
d514 1
a514 3
			}
		else
			{
d517 2
a518 4
			if (b->size != new_size)
				{
				if (b->buf) 
					{
d521 1
a521 1
					}
d523 1
a523 1
				}
d525 1
a525 1
			}
d534 6
a539 6
		BIO *other_bio = ptr;
		
		if (bio_make_pair(bio, other_bio))
			ret = 1;
		else
			ret = 0;
d542 1
a542 1
		
d585 1
a585 1
		
d590 1
a590 1
		
a599 1
		
d601 2
a602 1
	/* standard CTRL codes follow */
d605 1
a605 2
		if (b->buf != NULL)
			{
d608 1
a608 1
			}
d610 2
a611 1
		break;		
d623 1
a623 2
		if (b->peer != NULL)
			{
d625 1
a625 1
			
d627 1
a627 2
			}
		else
d641 6
a646 8
		BIO *other_bio = ptr;
		struct bio_bio_st *other_b;
		
		assert(other_bio != NULL);
		other_b = other_bio->ptr;
		assert(other_b != NULL);
		
		assert(other_b->buf == NULL); /* other_bio is always fresh */
d648 3
a650 1
		other_b->size = b->size;
d662 9
a670 11
		BIO *other_bio = ptr;
		
		if (other_bio)
			{
			struct bio_bio_st *other_b = other_bio->ptr;
			
			assert(other_b != NULL);
			ret = other_b->len == 0 && other_b->closed;
			}
		else
			ret = 1;
d676 1
a676 1
		}
d678 1
a678 1
	}
d680 3
a682 2
static int bio_puts(BIO *bio, const char *str)
	{
d684 1
a684 1
	}
d687 3
a689 2
static int bio_make_pair(BIO *bio1, BIO *bio2)
	{
d697 2
a698 3
	
	if (b1->peer != NULL || b2->peer != NULL)
		{
d701 3
a703 4
		}
	
	if (b1->buf == NULL)
		{
d705 1
a705 2
		if (b1->buf == NULL)
			{
d708 1
a708 1
			}
d711 3
a713 4
		}
	
	if (b2->buf == NULL)
		{
d715 1
a715 2
		if (b2->buf == NULL)
			{
d718 1
a718 1
			}
d721 2
a722 2
		}
	
d734 1
a734 1
	}
d736 3
a738 2
static void bio_destroy_pair(BIO *bio)
	{
d741 1
a741 2
	if (b != NULL)
		{
d744 1
a744 2
		if (peer_bio != NULL)
			{
d755 1
a755 1
			
a760 1
			}
d763 2
a764 1
 
d767 46
a812 51
int BIO_new_bio_pair(BIO **bio1_p, size_t writebuf1,
	BIO **bio2_p, size_t writebuf2)
	 {
	 BIO *bio1 = NULL, *bio2 = NULL;
	 long r;
	 int ret = 0;

	 bio1 = BIO_new(BIO_s_bio());
	 if (bio1 == NULL)
		 goto err;
	 bio2 = BIO_new(BIO_s_bio());
	 if (bio2 == NULL)
		 goto err;

	 if (writebuf1)
		 {
		 r = BIO_set_write_buf_size(bio1, writebuf1);
		 if (!r)
			 goto err;
		 }
	 if (writebuf2)
		 {
		 r = BIO_set_write_buf_size(bio2, writebuf2);
		 if (!r)
			 goto err;
		 }

	 r = BIO_make_bio_pair(bio1, bio2);
	 if (!r)
		 goto err;
	 ret = 1;

 err:
	 if (ret == 0)
		 {
		 if (bio1)
			 {
			 BIO_free(bio1);
			 bio1 = NULL;
			 }
		 if (bio2)
			 {
			 BIO_free(bio2);
			 bio2 = NULL;
			 }
		 }

	 *bio1_p = bio1;
	 *bio2_p = bio2;
	 return ret;
	 }
d814 3
a816 2
size_t BIO_ctrl_get_write_guarantee(BIO *bio)
	{
d818 1
a818 1
	}
d820 3
a822 2
size_t BIO_ctrl_get_read_request(BIO *bio)
	{
d824 1
a824 1
	}
d826 3
a828 2
int BIO_ctrl_reset_read_request(BIO *bio)
	{
d830 1
a830 1
	}
d836 3
a838 2
int BIO_nread0(BIO *bio, char **buf)
	{
d841 1
a841 2
	if (!bio->init)
		{
d844 1
a844 1
		}
d851 1
a851 1
	}
d853 3
a855 2
int BIO_nread(BIO *bio, char **buf, int num)
	{
d858 1
a858 2
	if (!bio->init)
		{
d861 1
a861 1
		}
d867 1
a867 1
	}
d869 3
a871 2
int BIO_nwrite0(BIO *bio, char **buf)
	{
d874 1
a874 2
	if (!bio->init)
		{
d877 1
a877 1
		}
d884 1
a884 1
	}
d886 3
a888 2
int BIO_nwrite(BIO *bio, char **buf, int num)
	{
d891 1
a891 2
	if (!bio->init)
		{
d894 1
a894 1
		}
d900 1
a900 1
	}
@


1.9
log
@resolve conflicts
@
text
@d280 1
a280 1
static ssize_t bio_nread0(BIO *bio, char **buf)
d283 1
a283 1
	ssize_t num;
d318 1
a318 1
static ssize_t bio_nread(BIO *bio, char **buf, size_t num_)
d321 1
a321 1
	ssize_t num, available;
d326 1
a326 1
		num = (ssize_t)num_;
d431 1
a431 1
static ssize_t bio_nwrite0(BIO *bio, char **buf)
d479 1
a479 1
static ssize_t bio_nwrite(BIO *bio, char **buf, size_t num_)
d482 1
a482 1
	ssize_t num, space;
d487 1
a487 1
		num = (ssize_t)num_;
@


1.8
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d922 1
a922 1
		bio->num_read += ret;
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d2 53
d558 1
a558 1
		/* Effects both BIOs in the pair -- call just once!
@


1.6
log
@Merge openssl-0.9.7-stable-SNAP-20020519
@
text
@a30 1
#include <openssl/err.h>
d36 1
a36 1
#if defined(OPENSSL_SYS_VSWORKS)
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d10 8
d19 3
a21 2
# undef NDEBUG /* avoid conflicting definitions */
# define NDEBUG
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d25 6
a30 1
#include "openssl/e_os.h"
d482 2
a483 1
		num = (long) b->size;
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d33 1
a33 1
static int bio_write(BIO *bio, char *buf, int num);
d35 1
a35 1
static int bio_puts(BIO *bio, char *str);
d83 1
a83 1
	b = Malloc(sizeof *b);
d111 1
a111 1
		Free(b->buf);
d114 1
a114 1
	Free(b);
d286 1
a286 1
static int bio_write(BIO *bio, char *buf, int num_)
d467 1
a467 1
					Free(b->buf);
d631 1
a631 1
static int bio_puts(BIO *bio, char *str)
d655 1
a655 1
		b1->buf = Malloc(b1->size);
d667 1
a667 1
		b2->buf = Malloc(b2->size);
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d22 1
d25 5
d214 1
a214 1
static size_t bio_nread0(BIO *bio, char **buf)
d217 1
a217 1
	size_t num;
d252 1
a252 1
static size_t bio_nread(BIO *bio, char **buf, size_t num)
d255 6
a260 1
	size_t available;
d265 1
a265 1
	if (num == 0)
d365 1
a365 1
static size_t bio_nwrite0(BIO *bio, char **buf)
d413 1
a413 1
static size_t bio_nwrite(BIO *bio, char **buf, size_t num)
d416 6
a421 1
	size_t space;
d426 1
a426 1
	if (num == 0)
d528 5
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d16 1
d44 2
a45 1
	bio_free
d69 1
a69 1
	                 * it (unsuccesfully) tried to read,
d200 75
d348 72
d483 1
a483 1
		 * withouth having to keep any? */
d491 1
a491 1
		/* If the peer unsuccesfully tried to read, how many bytes
d497 9
d512 15
d761 75
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a9 8
/* BIO_DEBUG implies BIO_PAIR_DEBUG */
#ifdef BIO_DEBUG
# ifndef BIO_PAIR_DEBUG
#  define BIO_PAIR_DEBUG
# endif
#endif

/* disable assert() unless BIO_PAIR_DEBUG has been defined */
d11 2
a12 3
# ifndef NDEBUG
#  define NDEBUG
# endif
a15 1
#include <limits.h>
a20 1
#include <openssl/err.h>
a22 10
#include "e_os.h"

/* VxWorks defines SSIZE_MAX with an empty value causing compile errors */
#if defined(OPENSSL_SYS_VSWORKS)
# undef SSIZE_MAX
#endif
#ifndef SSIZE_MAX
# define SSIZE_MAX INT_MAX
#endif

d26 1
a26 1
static int bio_write(BIO *bio, const char *buf, int num);
d28 1
a28 1
static int bio_puts(BIO *bio, const char *str);
d43 1
a43 2
	bio_free,
	NULL /* no bio_callback_ctrl */
d67 1
a67 1
	                 * it (unsuccessfully) tried to read,
d75 1
a75 1
	b = OPENSSL_malloc(sizeof *b);
d103 1
a103 1
		OPENSSL_free(b->buf);
d106 1
a106 1
	OPENSSL_free(b);
d198 1
a198 81
/* non-copying interface: provide pointer to available data in buffer
 *    bio_nread0:  return number of available bytes
 *    bio_nread:   also advance index
 * (example usage:  bio_nread0(), read from buffer, bio_nread()
 *  or just         bio_nread(), read from buffer)
 */
/* WARNING: The non-copying interface is largely untested as of yet
 * and may contain bugs. */
static ssize_t bio_nread0(BIO *bio, char **buf)
	{
	struct bio_bio_st *b, *peer_b;
	ssize_t num;
	
	BIO_clear_retry_flags(bio);

	if (!bio->init)
		return 0;
	
	b = bio->ptr;
	assert(b != NULL);
	assert(b->peer != NULL);
	peer_b = b->peer->ptr;
	assert(peer_b != NULL);
	assert(peer_b->buf != NULL);
	
	peer_b->request = 0;
	
	if (peer_b->len == 0)
		{
		char dummy;
		
		/* avoid code duplication -- nothing available for reading */
		return bio_read(bio, &dummy, 1); /* returns 0 or -1 */
		}

	num = peer_b->len;
	if (peer_b->size < peer_b->offset + num)
		/* no ring buffer wrap-around for non-copying interface */
		num = peer_b->size - peer_b->offset;
	assert(num > 0);

	if (buf != NULL)
		*buf = peer_b->buf + peer_b->offset;
	return num;
	}

static ssize_t bio_nread(BIO *bio, char **buf, size_t num_)
	{
	struct bio_bio_st *b, *peer_b;
	ssize_t num, available;

	if (num_ > SSIZE_MAX)
		num = SSIZE_MAX;
	else
		num = (ssize_t)num_;

	available = bio_nread0(bio, buf);
	if (num > available)
		num = available;
	if (num <= 0)
		return num;

	b = bio->ptr;
	peer_b = b->peer->ptr;

	peer_b->len -= num;
	if (peer_b->len) 
		{
		peer_b->offset += num;
		assert(peer_b->offset <= peer_b->size);
		if (peer_b->offset == peer_b->size)
			peer_b->offset = 0;
		}
	else
		peer_b->offset = 0;

	return num;
	}


static int bio_write(BIO *bio, const char *buf, int num_)
a270 77
/* non-copying interface: provide pointer to region to write to
 *   bio_nwrite0:  check how much space is available
 *   bio_nwrite:   also increase length
 * (example usage:  bio_nwrite0(), write to buffer, bio_nwrite()
 *  or just         bio_nwrite(), write to buffer)
 */
static ssize_t bio_nwrite0(BIO *bio, char **buf)
	{
	struct bio_bio_st *b;
	size_t num;
	size_t write_offset;

	BIO_clear_retry_flags(bio);

	if (!bio->init)
		return 0;

	b = bio->ptr;		
	assert(b != NULL);
	assert(b->peer != NULL);
	assert(b->buf != NULL);

	b->request = 0;
	if (b->closed)
		{
		BIOerr(BIO_F_BIO_NWRITE0, BIO_R_BROKEN_PIPE);
		return -1;
		}

	assert(b->len <= b->size);

	if (b->len == b->size)
		{
		BIO_set_retry_write(bio);
		return -1;
		}

	num = b->size - b->len;
	write_offset = b->offset + b->len;
	if (write_offset >= b->size)
		write_offset -= b->size;
	if (write_offset + num > b->size)
		/* no ring buffer wrap-around for non-copying interface
		 * (to fulfil the promise by BIO_ctrl_get_write_guarantee,
		 * BIO_nwrite may have to be called twice) */
		num = b->size - write_offset;

	if (buf != NULL)
		*buf = b->buf + write_offset;
	assert(write_offset + num <= b->size);

	return num;
	}

static ssize_t bio_nwrite(BIO *bio, char **buf, size_t num_)
	{
	struct bio_bio_st *b;
	ssize_t num, space;

	if (num_ > SSIZE_MAX)
		num = SSIZE_MAX;
	else
		num = (ssize_t)num_;

	space = bio_nwrite0(bio, buf);
	if (num > space)
		num = space;
	if (num <= 0)
		return num;
	b = bio->ptr;
	assert(b != NULL);
	b->len += num;
	assert(b->len <= b->size);

	return num;
	}

d302 1
a302 1
					OPENSSL_free(b->buf);
d312 1
a312 2
		ret = (long) b->size;
		break;
d334 1
a334 1
		 * without having to keep any? */
d342 1
a342 1
		/* If the peer unsuccessfully tried to read, how many bytes
a347 9
	case BIO_C_RESET_READ_REQUEST:
		/* Reset request.  (Can be useful after read attempts
		 * at the other side that are meant to be non-blocking,
		 * e.g. when probing SSL_read to see if any data is
		 * available.) */
		b->request = 0;
		ret = 1;
		break;

a353 20
	case BIO_C_NREAD0:
		/* prepare for non-copying read */
		ret = (long) bio_nread0(bio, ptr);
		break;
		
	case BIO_C_NREAD:
		/* non-copying read */
		ret = (long) bio_nread(bio, ptr, (size_t) num);
		break;
		
	case BIO_C_NWRITE0:
		/* prepare for non-copying write */
		ret = (long) bio_nwrite0(bio, ptr);
		break;

	case BIO_C_NWRITE:
		/* non-copying write */
		ret = (long) bio_nwrite(bio, ptr, (size_t) num);
		break;
		
d437 1
a437 1
static int bio_puts(BIO *bio, const char *str)
d461 1
a461 1
		b1->buf = OPENSSL_malloc(b1->size);
d473 1
a473 1
		b2->buf = OPENSSL_malloc(b2->size);
a587 75
	}

int BIO_ctrl_reset_read_request(BIO *bio)
	{
	return (BIO_ctrl(bio, BIO_C_RESET_READ_REQUEST, 0, NULL) != 0);
	}


/* BIO_nread0/nread/nwrite0/nwrite are available only for BIO pairs for now
 * (conceivably some other BIOs could allow non-copying reads and writes too.)
 */
int BIO_nread0(BIO *bio, char **buf)
	{
	long ret;

	if (!bio->init)
		{
		BIOerr(BIO_F_BIO_NREAD0, BIO_R_UNINITIALIZED);
		return -2;
		}

	ret = BIO_ctrl(bio, BIO_C_NREAD0, 0, buf);
	if (ret > INT_MAX)
		return INT_MAX;
	else
		return (int) ret;
	}

int BIO_nread(BIO *bio, char **buf, int num)
	{
	int ret;

	if (!bio->init)
		{
		BIOerr(BIO_F_BIO_NREAD, BIO_R_UNINITIALIZED);
		return -2;
		}

	ret = (int) BIO_ctrl(bio, BIO_C_NREAD, num, buf);
	if (ret > 0)
		bio->num_read += ret;
	return ret;
	}

int BIO_nwrite0(BIO *bio, char **buf)
	{
	long ret;

	if (!bio->init)
		{
		BIOerr(BIO_F_BIO_NWRITE0, BIO_R_UNINITIALIZED);
		return -2;
		}

	ret = BIO_ctrl(bio, BIO_C_NWRITE0, 0, buf);
	if (ret > INT_MAX)
		return INT_MAX;
	else
		return (int) ret;
	}

int BIO_nwrite(BIO *bio, char **buf, int num)
	{
	int ret;

	if (!bio->init)
		{
		BIOerr(BIO_F_BIO_NWRITE, BIO_R_UNINITIALIZED);
		return -2;
		}

	ret = BIO_ctrl(bio, BIO_C_NWRITE, num, buf);
	if (ret > 0)
		bio->num_read += ret;
	return ret;
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d31 1
d37 1
a37 1
#if defined(OPENSSL_SYS_VXWORKS)
@


1.1.1.3
log
@import 0.9.7c
@
text
@a1 53
/* ====================================================================
 * Copyright (c) 1998-2003 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d505 1
a505 1
		/* Affects both BIOs in the pair -- call just once!
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d922 1
a922 1
		bio->num_write += ret;
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@d280 1
a280 1
static ossl_ssize_t bio_nread0(BIO *bio, char **buf)
d283 1
a283 1
	ossl_ssize_t num;
d318 1
a318 1
static ossl_ssize_t bio_nread(BIO *bio, char **buf, size_t num_)
d321 1
a321 1
	ossl_ssize_t num, available;
d326 1
a326 1
		num = (ossl_ssize_t)num_;
d431 1
a431 1
static ossl_ssize_t bio_nwrite0(BIO *bio, char **buf)
d479 1
a479 1
static ossl_ssize_t bio_nwrite(BIO *bio, char **buf, size_t num_)
d482 1
a482 1
	ossl_ssize_t num, space;
d487 1
a487 1
		num = (ossl_ssize_t)num_;
@


