head	1.41;
access;
symbols
	OPENBSD_6_1_BASE:1.41;
locks; strict;
comment	@ * @;


1.41
date	2015.07.20.23.15.28;	author doug;	state Exp;
branches;
next	1.40;
commitid	9toy6kWKTrMm8C8g;

1.40
date	2015.02.09.10.55.33;	author jsing;	state Exp;
branches;
next	1.39;
commitid	Z6KDBDy9dx0pVjhP;

1.39
date	2015.01.12.02.15.23;	author doug;	state Exp;
branches;
next	1.38;
commitid	52PdwvfRM7EDtz9i;

1.38
date	2015.01.03.18.07.29;	author doug;	state Exp;
branches;
next	1.37;
commitid	6gx81bTJ7ZObtBfS;

1.37
date	2014.11.26.05.41.44;	author bcook;	state Exp;
branches;
next	1.36;
commitid	3WmuISnRKG9tRgKq;

1.36
date	2014.11.26.05.39.06;	author bcook;	state Exp;
branches;
next	1.35;
commitid	1oCg3OjARCffTlYx;

1.35
date	2014.11.26.05.37.26;	author bcook;	state Exp;
branches;
next	1.34;
commitid	gSfIogusXsvZaqAh;

1.34
date	2014.11.26.05.01.47;	author bcook;	state Exp;
branches;
next	1.33;
commitid	umc9lFRDbYfvubbI;

1.33
date	2014.08.24.16.08.30;	author bcook;	state Exp;
branches;
next	1.32;
commitid	Mm5gfFXskDIUoUYv;

1.32
date	2014.07.11.12.17.46;	author miod;	state Exp;
branches;
next	1.31;
commitid	OUSrOeyVAxEe7moy;

1.31
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.30;
commitid	yQEL1wOWIearrW15;

1.30
date	2014.07.10.22.45.56;	author jsing;	state Exp;
branches;
next	1.29;
commitid	nzndm3zqPmFurSaK;

1.29
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.28;
commitid	id8dTrTMtnTn4fqt;

1.28
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	mJUVYpkFBZ0Zv2bG;

1.27
date	2014.06.03.06.24.08;	author logan;	state Exp;
branches;
next	1.26;
commitid	XQJfcPJp6lTo3MtU;

1.26
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.26.11.08.59;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.23.20.59.36;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.21.13.13.43;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.21.11.12.49;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.18.14.37.41;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.18.11.33.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.17.22.22.28;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.17.22.19.56;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.17.20.58.08;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.17.17.50.45;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.16.19.42.24;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.16.13.01.09;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.15.17.25.41;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.15.16.37.21;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.14.00.00.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.13.23.31.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.13.23.05.18;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.01.09.12.13.52;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2011.11.03.02.32.08;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.35;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.04.13.15.16.33;	author miod;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Correct #if/else logic in BIO's dgram_ctrl.

Coverity issue 72741 noticed that ret is being overwritten before use.
The actual issue is that the #if/else logic is guarding the wrong
lines.  Besides impacting ret, this also made the case's break logic
wrong because it was in the wrong location.

ok bcook@@ beck@@
@
text
@/* $OpenBSD: bss_dgram.c,v 1.40 2015/02/09 10:55:33 jsing Exp $ */
/* 
 * DTLS implementation written by Nagendra Modadugu
 * (nagendra@@cs.stanford.edu) for the OpenSSL project 2005.  
 */
/* ====================================================================
 * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <sys/socket.h>
#include <sys/time.h>

#include <netinet/in.h>

#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <openssl/opensslconf.h>

#include <openssl/bio.h>

#ifndef OPENSSL_NO_DGRAM


static int dgram_write(BIO *h, const char *buf, int num);
static int dgram_read(BIO *h, char *buf, int size);
static int dgram_puts(BIO *h, const char *str);
static long dgram_ctrl(BIO *h, int cmd, long arg1, void *arg2);
static int dgram_new(BIO *h);
static int dgram_free(BIO *data);
static int dgram_clear(BIO *bio);


static int BIO_dgram_should_retry(int s);

static BIO_METHOD methods_dgramp = {
	.type = BIO_TYPE_DGRAM,
	.name = "datagram socket",
	.bwrite = dgram_write,
	.bread = dgram_read,
	.bputs = dgram_puts,
	.ctrl = dgram_ctrl,
	.create = dgram_new,
	.destroy = dgram_free
};


typedef struct bio_dgram_data_st {
	union {
		struct sockaddr sa;
		struct sockaddr_in sa_in;
		struct sockaddr_in6 sa_in6;
	} peer;
	unsigned int connected;
	unsigned int _errno;
	unsigned int mtu;
	struct timeval next_timeout;
	struct timeval socket_timeout;
} bio_dgram_data;


BIO_METHOD *
BIO_s_datagram(void)
{
	return (&methods_dgramp);
}

BIO *
BIO_new_dgram(int fd, int close_flag)
{
	BIO *ret;

	ret = BIO_new(BIO_s_datagram());
	if (ret == NULL)
		return (NULL);
	BIO_set_fd(ret, fd, close_flag);
	return (ret);
}

static int
dgram_new(BIO *bi)
{
	bio_dgram_data *data = NULL;

	bi->init = 0;
	bi->num = 0;
	data = calloc(1, sizeof(bio_dgram_data));
	if (data == NULL)
		return 0;
	bi->ptr = data;

	bi->flags = 0;
	return (1);
}

static int
dgram_free(BIO *a)
{
	bio_dgram_data *data;

	if (a == NULL)
		return (0);
	if (!dgram_clear(a))
		return 0;

	data = (bio_dgram_data *)a->ptr;
	free(data);

	return (1);
}

static int
dgram_clear(BIO *a)
{
	if (a == NULL)
		return (0);
	if (a->shutdown) {
		if (a->init) {
			shutdown(a->num, SHUT_RDWR);
			close(a->num);
		}
		a->init = 0;
		a->flags = 0;
	}
	return (1);
}

static void
dgram_adjust_rcv_timeout(BIO *b)
{
#if defined(SO_RCVTIMEO)
	bio_dgram_data *data = (bio_dgram_data *)b->ptr;

	/* Is a timer active? */
	if (data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0) {
		struct timeval timenow, timeleft;

		/* Read current socket timeout */
		socklen_t sz = sizeof(data->socket_timeout);
		if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
		    &(data->socket_timeout), &sz) < 0) {
			perror("getsockopt");
		}

		/* Get current time */
		gettimeofday(&timenow, NULL);

		/* Calculate time left until timer expires */
		memcpy(&timeleft, &(data->next_timeout), sizeof(struct timeval));
		timeleft.tv_sec -= timenow.tv_sec;
		timeleft.tv_usec -= timenow.tv_usec;
		if (timeleft.tv_usec < 0) {
			timeleft.tv_sec--;
			timeleft.tv_usec += 1000000;
		}

		if (timeleft.tv_sec < 0) {
			timeleft.tv_sec = 0;
			timeleft.tv_usec = 1;
		}

		/* Adjust socket timeout if next handhake message timer
		 * will expire earlier.
		 */
		if ((data->socket_timeout.tv_sec == 0 &&
		    data->socket_timeout.tv_usec == 0) ||
		    (data->socket_timeout.tv_sec > timeleft.tv_sec) ||
		    (data->socket_timeout.tv_sec == timeleft.tv_sec &&
		    data->socket_timeout.tv_usec >= timeleft.tv_usec)) {
			if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
			    &timeleft, sizeof(struct timeval)) < 0) {
				perror("setsockopt");
			}
		}
	}
#endif
}

static void
dgram_reset_rcv_timeout(BIO *b)
{
#if defined(SO_RCVTIMEO)
	bio_dgram_data *data = (bio_dgram_data *)b->ptr;

	/* Is a timer active? */
	if (data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0) {
		if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
		    &(data->socket_timeout), sizeof(struct timeval)) < 0) {
			perror("setsockopt");
		}
	}
#endif
}

static int
dgram_read(BIO *b, char *out, int outl)
{
	int ret = 0;
	bio_dgram_data *data = (bio_dgram_data *)b->ptr;

	struct	{
		socklen_t len;
		union	{
			struct sockaddr sa;
			struct sockaddr_in sa_in;
			struct sockaddr_in6 sa_in6;
		} peer;
	} sa;

	sa.len = sizeof(sa.peer);

	if (out != NULL) {
		errno = 0;
		memset(&sa.peer, 0, sizeof(sa.peer));
		dgram_adjust_rcv_timeout(b);
		ret = recvfrom(b->num, out, outl, 0, &sa.peer.sa, &sa.len);

		if (! data->connected  && ret >= 0)
			BIO_ctrl(b, BIO_CTRL_DGRAM_SET_PEER, 0, &sa.peer);

		BIO_clear_retry_flags(b);
		if (ret < 0) {
			if (BIO_dgram_should_retry(ret)) {
				BIO_set_retry_read(b);
				data->_errno = errno;
			}
		}

		dgram_reset_rcv_timeout(b);
	}
	return (ret);
}

static int
dgram_write(BIO *b, const char *in, int inl)
{
	int ret;
	bio_dgram_data *data = (bio_dgram_data *)b->ptr;
	errno = 0;

	if (data->connected)
		ret = write(b->num, in, inl);
	else {
		int peerlen = sizeof(data->peer);

		if (data->peer.sa.sa_family == AF_INET)
			peerlen = sizeof(data->peer.sa_in);
		else if (data->peer.sa.sa_family == AF_INET6)
			peerlen = sizeof(data->peer.sa_in6);
		ret = sendto(b->num, in, inl, 0, &data->peer.sa, peerlen);
	}

	BIO_clear_retry_flags(b);
	if (ret <= 0) {
		if (BIO_dgram_should_retry(ret)) {
			BIO_set_retry_write(b);

			data->_errno = errno;
			/*
			 * higher layers are responsible for querying MTU,
			 * if necessary
			 */
		}
	}
	return (ret);
}

static long
dgram_ctrl(BIO *b, int cmd, long num, void *ptr)
{
	long ret = 1;
	int *ip;
	struct sockaddr *to = NULL;
	bio_dgram_data *data = NULL;
#if (defined(IP_MTU_DISCOVER) || defined(IP_MTU))
	int sockopt_val = 0;
	socklen_t sockopt_len;	/* assume that system supporting IP_MTU is
				 * modern enough to define socklen_t */
	socklen_t addr_len;
	union	{
		struct sockaddr	sa;
		struct sockaddr_in s4;
		struct sockaddr_in6 s6;
	} addr;
#endif

	data = (bio_dgram_data *)b->ptr;

	switch (cmd) {
	case BIO_CTRL_RESET:
		num = 0;
	case BIO_C_FILE_SEEK:
		ret = 0;
		break;
	case BIO_C_FILE_TELL:
	case BIO_CTRL_INFO:
		ret = 0;
		break;
	case BIO_C_SET_FD:
		dgram_clear(b);
		b->num= *((int *)ptr);
		b->shutdown = (int)num;
		b->init = 1;
		break;
	case BIO_C_GET_FD:
		if (b->init) {
			ip = (int *)ptr;
			if (ip != NULL)
				*ip = b->num;
			ret = b->num;
		} else
			ret = -1;
		break;
	case BIO_CTRL_GET_CLOSE:
		ret = b->shutdown;
		break;
	case BIO_CTRL_SET_CLOSE:
		b->shutdown = (int)num;
		break;
	case BIO_CTRL_PENDING:
	case BIO_CTRL_WPENDING:
		ret = 0;
		break;
	case BIO_CTRL_DUP:
	case BIO_CTRL_FLUSH:
		ret = 1;
		break;
	case BIO_CTRL_DGRAM_CONNECT:
		to = (struct sockaddr *)ptr;
		switch (to->sa_family) {
		case AF_INET:
			memcpy(&data->peer, to, sizeof(data->peer.sa_in));
			break;
		case AF_INET6:
			memcpy(&data->peer, to, sizeof(data->peer.sa_in6));
			break;
		default:
			memcpy(&data->peer, to, sizeof(data->peer.sa));
			break;
		}
		break;
		/* (Linux)kernel sets DF bit on outgoing IP packets */
	case BIO_CTRL_DGRAM_MTU_DISCOVER:
#if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DO)
		addr_len = (socklen_t)sizeof(addr);
		memset((void *)&addr, 0, sizeof(addr));
		if (getsockname(b->num, &addr.sa, &addr_len) < 0) {
			ret = 0;
			break;
		}
		switch (addr.sa.sa_family) {
		case AF_INET:
			sockopt_val = IP_PMTUDISC_DO;
			ret = setsockopt(b->num, IPPROTO_IP, IP_MTU_DISCOVER,
			    &sockopt_val, sizeof(sockopt_val));
			if (ret < 0)
				perror("setsockopt");
			break;
#if defined(IPV6_MTU_DISCOVER) && defined(IPV6_PMTUDISC_DO)
		case AF_INET6:
			sockopt_val = IPV6_PMTUDISC_DO;
			ret = setsockopt(b->num, IPPROTO_IPV6,
			    IPV6_MTU_DISCOVER, &sockopt_val,
			    sizeof(sockopt_val));
			if (ret < 0)
				perror("setsockopt");
			break;
#endif
		default:
			ret = -1;
			break;
		}
#else
		ret = -1;
#endif
		break;
	case BIO_CTRL_DGRAM_QUERY_MTU:
#if defined(IP_MTU)
		addr_len = (socklen_t)sizeof(addr);
		memset((void *)&addr, 0, sizeof(addr));
		if (getsockname(b->num, &addr.sa, &addr_len) < 0) {
			ret = 0;
			break;
		}
		sockopt_len = sizeof(sockopt_val);
		switch (addr.sa.sa_family) {
		case AF_INET:
			ret = getsockopt(b->num, IPPROTO_IP, IP_MTU,
			    &sockopt_val, &sockopt_len);
			if (ret < 0 || sockopt_val < 0) {
				ret = 0;
			} else {
				/* we assume that the transport protocol is UDP and no
				 * IP options are used.
				 */
				data->mtu = sockopt_val - 8 - 20;
				ret = data->mtu;
			}
			break;
#if defined(IPV6_MTU)
		case AF_INET6:
			ret = getsockopt(b->num, IPPROTO_IPV6, IPV6_MTU,
			    &sockopt_val, &sockopt_len);
			if (ret < 0 || sockopt_val < 0) {
				ret = 0;
			} else {
				/* we assume that the transport protocol is UDP and no
				 * IPV6 options are used.
				 */
				data->mtu = sockopt_val - 8 - 40;
				ret = data->mtu;
			}
			break;
#endif
default:
			ret = 0;
			break;
		}
#else
		ret = 0;
#endif
		break;
	case BIO_CTRL_DGRAM_GET_FALLBACK_MTU:
		switch (data->peer.sa.sa_family) {
		case AF_INET:
			ret = 576 - 20 - 8;
			break;
		case AF_INET6:
#ifdef IN6_IS_ADDR_V4MAPPED
			if (IN6_IS_ADDR_V4MAPPED(&data->peer.sa_in6.sin6_addr))
				ret = 576 - 20 - 8;
			else
#endif
				ret = 1280 - 40 - 8;
			break;
		default:
			ret = 576 - 20 - 8;
			break;
		}
		break;
	case BIO_CTRL_DGRAM_GET_MTU:
		return data->mtu;
		break;
	case BIO_CTRL_DGRAM_SET_MTU:
		data->mtu = num;
		ret = num;
		break;
	case BIO_CTRL_DGRAM_SET_CONNECTED:
		to = (struct sockaddr *)ptr;

		if (to != NULL) {
			data->connected = 1;
			switch (to->sa_family) {
			case AF_INET:
				memcpy(&data->peer, to, sizeof(data->peer.sa_in));
				break;
			case AF_INET6:
				memcpy(&data->peer, to, sizeof(data->peer.sa_in6));
				break;
			default:
				memcpy(&data->peer, to, sizeof(data->peer.sa));
				break;
			}
		} else {
			data->connected = 0;
			memset(&(data->peer), 0, sizeof(data->peer));
		}
		break;
	case BIO_CTRL_DGRAM_GET_PEER:
		switch (data->peer.sa.sa_family) {
		case AF_INET:
			ret = sizeof(data->peer.sa_in);
			break;
		case AF_INET6:
			ret = sizeof(data->peer.sa_in6);
			break;
		default:
			ret = sizeof(data->peer.sa);
			break;
		}
		if (num == 0 || num > ret)
			num = ret;
		memcpy(ptr, &data->peer, (ret = num));
		break;
	case BIO_CTRL_DGRAM_SET_PEER:
		to = (struct sockaddr *) ptr;
		switch (to->sa_family) {
		case AF_INET:
			memcpy(&data->peer, to, sizeof(data->peer.sa_in));
			break;
		case AF_INET6:
			memcpy(&data->peer, to, sizeof(data->peer.sa_in6));
			break;
		default:
			memcpy(&data->peer, to, sizeof(data->peer.sa));
			break;
		}
		break;
	case BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT:
		memcpy(&(data->next_timeout), ptr, sizeof(struct timeval));
		break;
#if defined(SO_RCVTIMEO)
	case BIO_CTRL_DGRAM_SET_RECV_TIMEOUT:
		if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, ptr,
		    sizeof(struct timeval)) < 0) {
			perror("setsockopt");
			ret = -1;
		}
		break;
	case BIO_CTRL_DGRAM_GET_RECV_TIMEOUT:
		{
			socklen_t sz = sizeof(struct timeval);
			if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
			    ptr, &sz) < 0) {
				perror("getsockopt");
				ret = -1;
			} else
				ret = sz;
		}
		break;
#endif
#if defined(SO_SNDTIMEO)
	case BIO_CTRL_DGRAM_SET_SEND_TIMEOUT:
		if (setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO, ptr,
		    sizeof(struct timeval)) < 0) {
			perror("setsockopt");
			ret = -1;
		}
		break;
	case BIO_CTRL_DGRAM_GET_SEND_TIMEOUT:
		{
			socklen_t sz = sizeof(struct timeval);
			if (getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,
			    ptr, &sz) < 0) {
				perror("getsockopt");
				ret = -1;
			} else
				ret = sz;
		}
		break;
#endif
	case BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP:
		/* fall-through */
	case BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP:
		if (data->_errno == EAGAIN) {
			ret = 1;
			data->_errno = 0;
		} else
			ret = 0;
		break;
#ifdef EMSGSIZE
	case BIO_CTRL_DGRAM_MTU_EXCEEDED:
		if (data->_errno == EMSGSIZE) {
			ret = 1;
			data->_errno = 0;
		} else
			ret = 0;
		break;
#endif
	default:
		ret = 0;
		break;
	}
	return (ret);
}

static int
dgram_puts(BIO *bp, const char *str)
{
	int n, ret;

	n = strlen(str);
	ret = dgram_write(bp, str, n);
	return (ret);
}


static int
BIO_dgram_should_retry(int i)
{
	int err;

	if ((i == 0) || (i == -1)) {
		err = errno;
		return (BIO_dgram_non_fatal_error(err));
	}
	return (0);
}

int
BIO_dgram_non_fatal_error(int err)
{
	switch (err) {
	case EINTR:
	case EAGAIN:
	case EINPROGRESS:
	case EALREADY:
		return (1);
	default:
		break;
	}
	return (0);
}

#endif
@


1.40
log
@Jettison SCTP support in BIO dgram.

OpenBSD does not have SCTP support and it sees little use in the wild.
OPENSSL_NO_SCTP is already specified via opensslfeatures.h, hence this
is a code removal only and symbols should remain unchanged.

ok beck@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.39 2015/01/12 02:15:23 doug Exp $ */
d426 1
d428 1
a428 1
#else
a429 1
#endif
@


1.39
log
@Fix a memory leak in bss_dgram.

Free data->saved_message.data.  Based on OpenSSL commit:
41cd41c4416f545a18ead37e09e437c75fa07c95 except this version sets a->ptr
to NULL to avoid accidental reuse and handles malloc failing.

ok beck@@, input + ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.38 2015/01/03 18:07:29 doug Exp $ */
a76 6
#ifndef OPENSSL_NO_SCTP
#include <netinet/sctp.h>
#include <fcntl.h>
#define OPENSSL_SCTP_DATA_CHUNK_TYPE            0x00
#define OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE 0xc0
#endif
a85 12
#ifndef OPENSSL_NO_SCTP
static int dgram_sctp_write(BIO *h, const char *buf, int num);
static int dgram_sctp_read(BIO *h, char *buf, int size);
static int dgram_sctp_puts(BIO *h, const char *str);
static long dgram_sctp_ctrl(BIO *h, int cmd, long arg1, void *arg2);
static int dgram_sctp_new(BIO *h);
static int dgram_sctp_free(BIO *data);
#ifdef SCTP_AUTHENTICATION_EVENT
static void dgram_sctp_handle_auth_free_key_event(BIO *b,
    union sctp_notification *snp);
#endif
#endif
a99 12
#ifndef OPENSSL_NO_SCTP
static BIO_METHOD methods_dgramp_sctp = {
	.type = BIO_TYPE_DGRAM_SCTP,
	.name = "datagram sctp socket",
	.bwrite = dgram_sctp_write,
	.bread = dgram_sctp_read,
	.bputs = dgram_sctp_puts,
	.ctrl = dgram_sctp_ctrl,
	.create = dgram_sctp_new,
	.destroy = dgram_sctp_free
};
#endif
a113 29
#ifndef OPENSSL_NO_SCTP
typedef struct bio_dgram_sctp_save_message_st {
	BIO *bio;
	char *data;
	int length;
} bio_dgram_sctp_save_message;

typedef struct bio_dgram_sctp_data_st {
	union {
		struct sockaddr sa;
		struct sockaddr_in sa_in;
		struct sockaddr_in6 sa_in6;
	} peer;
	unsigned int connected;
	unsigned int _errno;
	unsigned int mtu;
	struct bio_dgram_sctp_sndinfo sndinfo;
	struct bio_dgram_sctp_rcvinfo rcvinfo;
	struct bio_dgram_sctp_prinfo prinfo;
	void (*handle_notifications)(BIO *bio, void *context, void *buf);
	void* notification_context;
	int in_handshake;
	int ccs_rcvd;
	int ccs_sent;
	int save_shutdown;
	int peer_auth_tested;
	bio_dgram_sctp_save_message saved_message;
} bio_dgram_sctp_data;
#endif
a629 934
#ifndef OPENSSL_NO_SCTP
BIO_METHOD *
BIO_s_datagram_sctp(void)
{
	return (&methods_dgramp_sctp);
}

BIO *
BIO_new_dgram_sctp(int fd, int close_flag)
{
	BIO *bio;
	int ret, optval = 20000;
	int auth_data = 0, auth_forward = 0;
	unsigned char *p;
	struct sctp_authchunk auth;
	struct sctp_authchunks *authchunks;
	socklen_t sockopt_len;
#ifdef SCTP_AUTHENTICATION_EVENT
#ifdef SCTP_EVENT
	struct sctp_event event;
#else
	struct sctp_event_subscribe event;
#endif
#endif

	bio = BIO_new(BIO_s_datagram_sctp());
	if (bio == NULL)
		return (NULL);
	BIO_set_fd(bio, fd, close_flag);

	/* Activate SCTP-AUTH for DATA and FORWARD-TSN chunks */
	auth.sauth_chunk = OPENSSL_SCTP_DATA_CHUNK_TYPE;
	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_AUTH_CHUNK, &auth, sizeof(struct sctp_authchunk));
	if (ret < 0)
		goto err;
	auth.sauth_chunk = OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE;
	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_AUTH_CHUNK, &auth, sizeof(struct sctp_authchunk));
	if (ret < 0)
		goto err;

	/* Test if activation was successful. When using accept(),
	 * SCTP-AUTH has to be activated for the listening socket
	 * already, otherwise the connected socket won't use it. */
	sockopt_len = (socklen_t)(sizeof(sctp_assoc_t) + 256 * sizeof(uint8_t));
	authchunks = calloc(1, sockopt_len);
	if (authchunks == NULL)
		goto err;
	ret = getsockopt(fd, IPPROTO_SCTP, SCTP_LOCAL_AUTH_CHUNKS, authchunks, &sockopt_len);
	if (ret < 0) {
		free(authchunks);
		goto err;
	}

	for (p = (unsigned char*) authchunks->gauth_chunks;
	    p < (unsigned char*) authchunks + sockopt_len;
	    p += sizeof(uint8_t)) {
		if (*p == OPENSSL_SCTP_DATA_CHUNK_TYPE)
			auth_data = 1;
		if (*p == OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE)
			auth_forward = 1;
	}

	free(authchunks);

	OPENSSL_assert(auth_data);
	OPENSSL_assert(auth_forward);

#ifdef SCTP_AUTHENTICATION_EVENT
#ifdef SCTP_EVENT
	memset(&event, 0, sizeof(struct sctp_event));
	event.se_assoc_id = 0;
	event.se_type = SCTP_AUTHENTICATION_EVENT;
	event.se_on = 1;
	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(struct sctp_event));
	if (ret < 0)
		goto err;
#else
	sockopt_len = (socklen_t) sizeof(struct sctp_event_subscribe);
	ret = getsockopt(fd, IPPROTO_SCTP, SCTP_EVENTS, &event, &sockopt_len);
	if (ret < 0)
		goto err;

	event.sctp_authentication_event = 1;

	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_EVENTS, &event, sizeof(struct sctp_event_subscribe));
	if (ret < 0)
		goto err;
#endif
#endif

	/* Disable partial delivery by setting the min size
	 * larger than the max record size of 2^14 + 2048 + 13
	 */
	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_PARTIAL_DELIVERY_POINT, &optval, sizeof(optval));
	if (ret < 0)
		goto err;

	return (bio);

err:
	BIO_vfree(bio);
	return (NULL);
}

int
BIO_dgram_is_sctp(BIO *bio)
{
	return (BIO_method_type(bio) == BIO_TYPE_DGRAM_SCTP);
}

static int
dgram_sctp_new(BIO *bi)
{
	bio_dgram_sctp_data *data = NULL;

	bi->init = 0;
	bi->num = 0;
	data = calloc(1, sizeof(bio_dgram_sctp_data));
	if (data == NULL)
		return 0;
#ifdef SCTP_PR_SCTP_NONE
	data->prinfo.pr_policy = SCTP_PR_SCTP_NONE;
#endif
	bi->ptr = data;

	bi->flags = 0;
	return (1);
}

static int
dgram_sctp_free(BIO *a)
{
	bio_dgram_sctp_data *data;

	if (a == NULL)
		return (0);
	if (! dgram_clear(a))
		return 0;

	data = (bio_dgram_sctp_data *)a->ptr;
	if (data != NULL) {
		free(data->saved_message.data);
		free(data);
		a->ptr = NULL;
	}

	return (1);
}

#ifdef SCTP_AUTHENTICATION_EVENT
void
dgram_sctp_handle_auth_free_key_event(BIO *b, union sctp_notification *snp)
{
	int ret;
	struct sctp_authkey_event* authkeyevent = &snp->sn_auth_event;

	if (authkeyevent->auth_indication == SCTP_AUTH_FREE_KEY) {
		struct sctp_authkeyid authkeyid;

		/* delete key */
		authkeyid.scact_keynumber = authkeyevent->auth_keynumber;
		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_DELETE_KEY,
		    &authkeyid, sizeof(struct sctp_authkeyid));
	}
}
#endif

static int
dgram_sctp_read(BIO *b, char *out, int outl)
{
	int ret = 0, n = 0, i, optval;
	socklen_t optlen;
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *)b->ptr;
	union sctp_notification *snp;
	struct msghdr msg;
	struct iovec iov;
	struct cmsghdr *cmsg;
	char cmsgbuf[512];

	if (out != NULL) {
		errno = 0;

		do {
			memset(&data->rcvinfo, 0, sizeof(struct bio_dgram_sctp_rcvinfo));
			iov.iov_base = out;
			iov.iov_len = outl;
			msg.msg_name = NULL;
			msg.msg_namelen = 0;
			msg.msg_iov = &iov;
			msg.msg_iovlen = 1;
			msg.msg_control = cmsgbuf;
			msg.msg_controllen = 512;
			msg.msg_flags = 0;
			n = recvmsg(b->num, &msg, 0);

			if (msg.msg_controllen > 0) {
				for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
					if (cmsg->cmsg_level != IPPROTO_SCTP)
						continue;
#ifdef SCTP_RCVINFO
					if (cmsg->cmsg_type == SCTP_RCVINFO) {
						struct sctp_rcvinfo *rcvinfo;

						rcvinfo = (struct sctp_rcvinfo *)CMSG_DATA(cmsg);
						data->rcvinfo.rcv_sid = rcvinfo->rcv_sid;
						data->rcvinfo.rcv_ssn = rcvinfo->rcv_ssn;
						data->rcvinfo.rcv_flags = rcvinfo->rcv_flags;
						data->rcvinfo.rcv_ppid = rcvinfo->rcv_ppid;
						data->rcvinfo.rcv_tsn = rcvinfo->rcv_tsn;
						data->rcvinfo.rcv_cumtsn = rcvinfo->rcv_cumtsn;
						data->rcvinfo.rcv_context = rcvinfo->rcv_context;
					}
#endif
#ifdef SCTP_SNDRCV
					if (cmsg->cmsg_type == SCTP_SNDRCV) {
						struct sctp_sndrcvinfo *sndrcvinfo;

						sndrcvinfo = (struct sctp_sndrcvinfo *)CMSG_DATA(cmsg);
						data->rcvinfo.rcv_sid = sndrcvinfo->sinfo_stream;
						data->rcvinfo.rcv_ssn = sndrcvinfo->sinfo_ssn;
						data->rcvinfo.rcv_flags = sndrcvinfo->sinfo_flags;
						data->rcvinfo.rcv_ppid = sndrcvinfo->sinfo_ppid;
						data->rcvinfo.rcv_tsn = sndrcvinfo->sinfo_tsn;
						data->rcvinfo.rcv_cumtsn = sndrcvinfo->sinfo_cumtsn;
						data->rcvinfo.rcv_context = sndrcvinfo->sinfo_context;
					}
#endif
				}
			}

			if (n <= 0) {
				if (n < 0)
					ret = n;
				break;
			}

			if (msg.msg_flags & MSG_NOTIFICATION) {
				snp = (union sctp_notification*) out;
				if (snp->sn_header.sn_type == SCTP_SENDER_DRY_EVENT) {
#ifdef SCTP_EVENT
					struct sctp_event event;
#else
					struct sctp_event_subscribe event;
					socklen_t eventsize;
#endif
					/* If a message has been delayed until the socket
					 * is dry, it can be sent now.
					 */
					if (data->saved_message.length > 0) {
						dgram_sctp_write(data->saved_message.bio, data->saved_message.data,
						data->saved_message.length);
						free(data->saved_message.data);
						data->saved_message.data = NULL;
						data->saved_message.length = 0;
					}

					/* disable sender dry event */
#ifdef SCTP_EVENT
					memset(&event, 0, sizeof(struct sctp_event));
					event.se_assoc_id = 0;
					event.se_type = SCTP_SENDER_DRY_EVENT;
					event.se_on = 0;
					i = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(struct sctp_event));
					if (i < 0) {
						ret = i;
						break;
					}
#else
					eventsize = sizeof(struct sctp_event_subscribe);
					i = getsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, &eventsize);
					if (i < 0) {
						ret = i;
						break;
					}

					event.sctp_sender_dry_event = 0;

					i = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, sizeof(struct sctp_event_subscribe));
					if (i < 0) {
						ret = i;
						break;
					}
#endif
				}

#ifdef SCTP_AUTHENTICATION_EVENT
				if (snp->sn_header.sn_type == SCTP_AUTHENTICATION_EVENT)
					dgram_sctp_handle_auth_free_key_event(b, snp);
#endif

				if (data->handle_notifications != NULL)
					data->handle_notifications(b, data->notification_context, (void*) out);

				memset(out, 0, outl);
			} else
				ret += n;
		}
		while ((msg.msg_flags & MSG_NOTIFICATION) && (msg.msg_flags & MSG_EOR) && (ret < outl));

		if (ret > 0 && !(msg.msg_flags & MSG_EOR)) {
			/* Partial message read, this should never happen! */

			/* The buffer was too small, this means the peer sent
			 * a message that was larger than allowed. */
			if (ret == outl)
				return -1;

			/* Test if socket buffer can handle max record
			 * size (2^14 + 2048 + 13)
			 */
			optlen = (socklen_t) sizeof(int);
			ret = getsockopt(b->num, SOL_SOCKET, SO_RCVBUF, &optval, &optlen);
			if (ret >= 0)
				OPENSSL_assert(optval >= 18445);

			/* Test if SCTP doesn't partially deliver below
			 * max record size (2^14 + 2048 + 13)
			 */
			optlen = (socklen_t) sizeof(int);
			ret = getsockopt(b->num, IPPROTO_SCTP,
			    SCTP_PARTIAL_DELIVERY_POINT, &optval, &optlen);
			if (ret >= 0)
				OPENSSL_assert(optval >= 18445);

			/* Partially delivered notification??? Probably a bug.... */
			OPENSSL_assert(!(msg.msg_flags & MSG_NOTIFICATION));

			/* Everything seems ok till now, so it's most likely
			 * a message dropped by PR-SCTP.
			 */
			memset(out, 0, outl);
			BIO_set_retry_read(b);
			return -1;
		}

		BIO_clear_retry_flags(b);
		if (ret < 0) {
			if (BIO_dgram_should_retry(ret)) {
				BIO_set_retry_read(b);
				data->_errno = errno;
			}
		}

		/* Test if peer uses SCTP-AUTH before continuing */
		if (!data->peer_auth_tested) {
			int ii, auth_data = 0, auth_forward = 0;
			unsigned char *p;
			struct sctp_authchunks *authchunks;

			optlen = (socklen_t)(sizeof(sctp_assoc_t) + 256 * sizeof(uint8_t));
			authchunks = calloc(1, optlen);
			if (authchunks == NULL) {
				BIOerr(BIO_F_DGRAM_SCTP_READ,
				    ERR_R_MALLOC_ERROR);
				return (-1);
			}
			ii = getsockopt(b->num, IPPROTO_SCTP, SCTP_PEER_AUTH_CHUNKS, authchunks, &optlen);
			if (ii >= 0) {
				for (p = (unsigned char*) authchunks->gauth_chunks;
				     p < (unsigned char*) authchunks + optlen;
				     p += sizeof(uint8_t)) {
					if (*p == OPENSSL_SCTP_DATA_CHUNK_TYPE)
						auth_data = 1;
					if (*p == OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE)
						auth_forward = 1;
				}
			}

			free(authchunks);

			if (!auth_data || !auth_forward) {
				BIOerr(BIO_F_DGRAM_SCTP_READ, BIO_R_CONNECT_ERROR);
				return -1;
			}

			data->peer_auth_tested = 1;
		}
	}
	return (ret);
}

static int
dgram_sctp_write(BIO *b, const char *in, int inl)
{
	int ret;
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *)b->ptr;
	struct bio_dgram_sctp_sndinfo *sinfo = &(data->sndinfo);
	struct bio_dgram_sctp_prinfo *pinfo = &(data->prinfo);
	struct bio_dgram_sctp_sndinfo handshake_sinfo;
	struct iovec iov[1];
	struct msghdr msg;
	struct cmsghdr *cmsg;
#if defined(SCTP_SNDINFO) && defined(SCTP_PRINFO)
	char cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndinfo)) + CMSG_SPACE(sizeof(struct sctp_prinfo))];
	struct sctp_sndinfo *sndinfo;
	struct sctp_prinfo *prinfo;
#else
	char cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];
	struct sctp_sndrcvinfo *sndrcvinfo;
#endif

	errno = 0;

	/* If we're send anything else than application data,
	 * disable all user parameters and flags.
	 */
	if (in[0] != 23) {
		memset(&handshake_sinfo, 0, sizeof(struct bio_dgram_sctp_sndinfo));
#ifdef SCTP_SACK_IMMEDIATELY
		handshake_sinfo.snd_flags = SCTP_SACK_IMMEDIATELY;
#endif
		sinfo = &handshake_sinfo;
	}

	/* If we have to send a shutdown alert message and the
	 * socket is not dry yet, we have to save it and send it
	 * as soon as the socket gets dry.
	 */
	if (data->save_shutdown && !BIO_dgram_sctp_wait_for_dry(b)) {
		data->saved_message.bio = b;
		free(data->saved_message.data);
		data->saved_message.data = malloc(inl);
		if (data->saved_message.data == NULL) {
			data->_errno = ENOMEM;
			return -1;
		}
		memcpy(data->saved_message.data, in, inl);
		data->saved_message.length = inl;
		return inl;
	}

	iov[0].iov_base = (char *)in;
	iov[0].iov_len = inl;
	msg.msg_name = NULL;
	msg.msg_namelen = 0;
	msg.msg_iov = iov;
	msg.msg_iovlen = 1;
	msg.msg_control = (caddr_t)cmsgbuf;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;
#if defined(SCTP_SNDINFO) && defined(SCTP_PRINFO)
	cmsg = (struct cmsghdr *)cmsgbuf;
	cmsg->cmsg_level = IPPROTO_SCTP;
	cmsg->cmsg_type = SCTP_SNDINFO;
	cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndinfo));
	sndinfo = (struct sctp_sndinfo *)CMSG_DATA(cmsg);
	memset(sndinfo, 0, sizeof(struct sctp_sndinfo));
	sndinfo->snd_sid = sinfo->snd_sid;
	sndinfo->snd_flags = sinfo->snd_flags;
	sndinfo->snd_ppid = sinfo->snd_ppid;
	sndinfo->snd_context = sinfo->snd_context;
	msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndinfo));

	cmsg = (struct cmsghdr *)&cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndinfo))];
	cmsg->cmsg_level = IPPROTO_SCTP;
	cmsg->cmsg_type = SCTP_PRINFO;
	cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_prinfo));
	prinfo = (struct sctp_prinfo *)CMSG_DATA(cmsg);
	memset(prinfo, 0, sizeof(struct sctp_prinfo));
	prinfo->pr_policy = pinfo->pr_policy;
	prinfo->pr_value = pinfo->pr_value;
	msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_prinfo));
#else
	cmsg = (struct cmsghdr *)cmsgbuf;
	cmsg->cmsg_level = IPPROTO_SCTP;
	cmsg->cmsg_type = SCTP_SNDRCV;
	cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));
	sndrcvinfo = (struct sctp_sndrcvinfo *)CMSG_DATA(cmsg);
	memset(sndrcvinfo, 0, sizeof(struct sctp_sndrcvinfo));
	sndrcvinfo->sinfo_stream = sinfo->snd_sid;
	sndrcvinfo->sinfo_flags = sinfo->snd_flags;
	sndrcvinfo->sinfo_ppid = sinfo->snd_ppid;
	sndrcvinfo->sinfo_context = sinfo->snd_context;
	sndrcvinfo->sinfo_timetolive = pinfo->pr_value;
	msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndrcvinfo));
#endif

	ret = sendmsg(b->num, &msg, 0);

	BIO_clear_retry_flags(b);
	if (ret <= 0) {
		if (BIO_dgram_should_retry(ret)) {
			BIO_set_retry_write(b);

			data->_errno = errno;
		}
	}
	return (ret);
}

static long
dgram_sctp_ctrl(BIO *b, int cmd, long num, void *ptr)
{
	long ret = 1;
	bio_dgram_sctp_data *data = NULL;
	socklen_t sockopt_len = 0;
	struct sctp_authkeyid authkeyid;

	data = (bio_dgram_sctp_data *)b->ptr;

	switch (cmd) {
	case BIO_CTRL_DGRAM_QUERY_MTU:
		/* Set to maximum (2^14)
		 * and ignore user input to enable transport
		 * protocol fragmentation.
		 * Returns always 2^14.
		 */
		data->mtu = 16384;
		ret = data->mtu;
		break;
	case BIO_CTRL_DGRAM_SET_MTU:
		/* Set to maximum (2^14)
		 * and ignore input to enable transport
		 * protocol fragmentation.
		 * Returns always 2^14.
		 */
		data->mtu = 16384;
		ret = data->mtu;
		break;
	case BIO_CTRL_DGRAM_SET_CONNECTED:
	case BIO_CTRL_DGRAM_CONNECT:
		/* Returns always -1. */
		ret = -1;
		break;
	case BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT:
		/* SCTP doesn't need the DTLS timer
		 * Returns always 1.
		 */
		break;
	case BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE:
		if (num > 0)
			data->in_handshake = 1;
		else
			data->in_handshake = 0;

		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_NODELAY, &data->in_handshake, sizeof(int));
		break;
	case BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY:
	    {
		struct sctp_authkey *authkey;

		/* New shared key for SCTP AUTH.
		 * Returns 0 on success, -1 otherwise.
		 */

		/* Get active key */
		sockopt_len = sizeof(struct sctp_authkeyid);
		ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY,
		    &authkeyid, &sockopt_len);
		if (ret < 0)
			break;

		/* Add new key */
		sockopt_len = sizeof(struct sctp_authkey) + 64 * sizeof(uint8_t);
		authkey = calloc(1, sockopt_len);
		if (authkey == NULL) {
			ret = -1;
			break;
		}
		authkey->sca_keynumber = authkeyid.scact_keynumber + 1;
		authkey->sca_keylength = 64;
		memcpy(&authkey->sca_key[0], ptr, 64 * sizeof(uint8_t));

		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_KEY, authkey,
		    sockopt_len);
		free(authkey);
		if (ret < 0)
			break;

		/* Reset active key */
		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY,
		    &authkeyid, sizeof(struct sctp_authkeyid));
		if (ret < 0)
			break;
	    }
		break;
	case BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY:
		/* Returns 0 on success, -1 otherwise. */

		/* Get active key */
		sockopt_len = sizeof(struct sctp_authkeyid);
		ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY,
		    &authkeyid, &sockopt_len);
		if (ret < 0)
			break;

		/* Set active key */
		authkeyid.scact_keynumber = authkeyid.scact_keynumber + 1;
		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY,
		    &authkeyid, sizeof(struct sctp_authkeyid));
		if (ret < 0)
			break;

		/* CCS has been sent, so remember that and fall through
		 * to check if we need to deactivate an old key
		 */
		data->ccs_sent = 1;

	case BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD:
		/* Returns 0 on success, -1 otherwise. */

		/* Has this command really been called or is this just a fall-through? */
		if (cmd == BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD)
			data->ccs_rcvd = 1;

		/* CSS has been both, received and sent, so deactivate an old key */
		if (data->ccs_rcvd == 1 && data->ccs_sent == 1) {
			/* Get active key */
			sockopt_len = sizeof(struct sctp_authkeyid);
			ret = getsockopt(b->num, IPPROTO_SCTP,
			    SCTP_AUTH_ACTIVE_KEY, &authkeyid, &sockopt_len);
			if (ret < 0)
				break;

			/* Deactivate key or delete second last key if
			 * SCTP_AUTHENTICATION_EVENT is not available.
			 */
			authkeyid.scact_keynumber = authkeyid.scact_keynumber - 1;
#ifdef SCTP_AUTH_DEACTIVATE_KEY
			sockopt_len = sizeof(struct sctp_authkeyid);
			ret = setsockopt(b->num, IPPROTO_SCTP,
			    SCTP_AUTH_DEACTIVATE_KEY, &authkeyid, sockopt_len);
			if (ret < 0)
				break;
#endif
#ifndef SCTP_AUTHENTICATION_EVENT
			if (authkeyid.scact_keynumber > 0) {
				authkeyid.scact_keynumber = authkeyid.scact_keynumber - 1;
				ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_DELETE_KEY,
				    &authkeyid, sizeof(struct sctp_authkeyid));
				if (ret < 0)
					break;
			}
#endif

			data->ccs_rcvd = 0;
			data->ccs_sent = 0;
		}
		break;
	case BIO_CTRL_DGRAM_SCTP_GET_SNDINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_sndinfo))
			num = sizeof(struct bio_dgram_sctp_sndinfo);

		memcpy(ptr, &(data->sndinfo), num);
		ret = num;
		break;
	case BIO_CTRL_DGRAM_SCTP_SET_SNDINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_sndinfo))
			num = sizeof(struct bio_dgram_sctp_sndinfo);

		memcpy(&(data->sndinfo), ptr, num);
		break;
	case BIO_CTRL_DGRAM_SCTP_GET_RCVINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_rcvinfo))
			num = sizeof(struct bio_dgram_sctp_rcvinfo);

		memcpy(ptr, &data->rcvinfo, num);

		ret = num;
		break;
	case BIO_CTRL_DGRAM_SCTP_SET_RCVINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_rcvinfo))
			num = sizeof(struct bio_dgram_sctp_rcvinfo);

		memcpy(&(data->rcvinfo), ptr, num);
		break;
	case BIO_CTRL_DGRAM_SCTP_GET_PRINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_prinfo))
			num = sizeof(struct bio_dgram_sctp_prinfo);

		memcpy(ptr, &(data->prinfo), num);
		ret = num;
		break;
	case BIO_CTRL_DGRAM_SCTP_SET_PRINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_prinfo))
			num = sizeof(struct bio_dgram_sctp_prinfo);

		memcpy(&(data->prinfo), ptr, num);
		break;
	case BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN:
		/* Returns always 1. */
		if (num > 0)
			data->save_shutdown = 1;
		else
			data->save_shutdown = 0;
		break;

	default:
		/* Pass to default ctrl function to
		 * process SCTP unspecific commands
		 */
		ret = dgram_ctrl(b, cmd, num, ptr);
		break;
	}
	return (ret);
}

int
BIO_dgram_sctp_notification_cb(BIO *b,
    void (*handle_notifications)(BIO *bio, void *context, void *buf),
    void *context)
{
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *) b->ptr;

	if (handle_notifications != NULL) {
		data->handle_notifications = handle_notifications;
		data->notification_context = context;
	} else
		return -1;

	return 0;
}

int
BIO_dgram_sctp_wait_for_dry(BIO *b)
{
	int is_dry = 0;
	int n, sockflags, ret;
	union sctp_notification snp;
	struct msghdr msg;
	struct iovec iov;
#ifdef SCTP_EVENT
	struct sctp_event event;
#else
	struct sctp_event_subscribe event;
	socklen_t eventsize;
#endif
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *)b->ptr;

	/* set sender dry event */
#ifdef SCTP_EVENT
	memset(&event, 0, sizeof(struct sctp_event));
	event.se_assoc_id = 0;
	event.se_type = SCTP_SENDER_DRY_EVENT;
	event.se_on = 1;
	ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(struct sctp_event));
#else
	eventsize = sizeof(struct sctp_event_subscribe);
	ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, &eventsize);
	if (ret < 0)
		return -1;

	event.sctp_sender_dry_event = 1;

	ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, sizeof(struct sctp_event_subscribe));
#endif
	if (ret < 0)
		return -1;

	/* peek for notification */
	memset(&snp, 0, sizeof(union sctp_notification));
	iov.iov_base = (char *)&snp;
	iov.iov_len = sizeof(union sctp_notification);
	msg.msg_name = NULL;
	msg.msg_namelen = 0;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = NULL;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;

	n = recvmsg(b->num, &msg, MSG_PEEK);
	if (n <= 0) {
		if ((n < 0) && (errno != EAGAIN) && (errno != EWOULDBLOCK))
			return -1;
		else
			return 0;
	}

	/* if we find a notification, process it and try again if necessary */
	while (msg.msg_flags & MSG_NOTIFICATION) {
		memset(&snp, 0, sizeof(union sctp_notification));
		iov.iov_base = (char *)&snp;
		iov.iov_len = sizeof(union sctp_notification);
		msg.msg_name = NULL;
		msg.msg_namelen = 0;
		msg.msg_iov = &iov;
		msg.msg_iovlen = 1;
		msg.msg_control = NULL;
		msg.msg_controllen = 0;
		msg.msg_flags = 0;

		n = recvmsg(b->num, &msg, 0);
		if (n <= 0) {
			if ((n < 0) && (errno != EAGAIN) && (errno != EWOULDBLOCK))
				return -1;
			else
				return is_dry;
		}

		if (snp.sn_header.sn_type == SCTP_SENDER_DRY_EVENT) {
			is_dry = 1;

			/* disable sender dry event */
#ifdef SCTP_EVENT
			memset(&event, 0, sizeof(struct sctp_event));
			event.se_assoc_id = 0;
			event.se_type = SCTP_SENDER_DRY_EVENT;
			event.se_on = 0;
			ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(struct sctp_event));
#else
			eventsize = (socklen_t) sizeof(struct sctp_event_subscribe);
			ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, &eventsize);
			if (ret < 0)
				return -1;

			event.sctp_sender_dry_event = 0;

			ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, sizeof(struct sctp_event_subscribe));
#endif
			if (ret < 0)
				return -1;
		}

#ifdef SCTP_AUTHENTICATION_EVENT
		if (snp.sn_header.sn_type == SCTP_AUTHENTICATION_EVENT)
			dgram_sctp_handle_auth_free_key_event(b, &snp);
#endif

		if (data->handle_notifications != NULL)
			data->handle_notifications(b, data->notification_context, (void*) &snp);

		/* found notification, peek again */
		memset(&snp, 0, sizeof(union sctp_notification));
		iov.iov_base = (char *)&snp;
		iov.iov_len = sizeof(union sctp_notification);
		msg.msg_name = NULL;
		msg.msg_namelen = 0;
		msg.msg_iov = &iov;
		msg.msg_iovlen = 1;
		msg.msg_control = NULL;
		msg.msg_controllen = 0;
		msg.msg_flags = 0;

		/* if we have seen the dry already, don't wait */
		if (is_dry) {
			sockflags = fcntl(b->num, F_GETFL, 0);
			fcntl(b->num, F_SETFL, O_NONBLOCK);
		}

		n = recvmsg(b->num, &msg, MSG_PEEK);

		if (is_dry) {
			fcntl(b->num, F_SETFL, sockflags);
		}

		if (n <= 0) {
			if ((n < 0) && (errno != EAGAIN) && (errno != EWOULDBLOCK))
				return -1;
			else
				return is_dry;
		}
	}

	/* read anything else */
	return is_dry;
}

int
BIO_dgram_sctp_msg_waiting(BIO *b)
{
	int n, sockflags;
	union sctp_notification snp;
	struct msghdr msg;
	struct iovec iov;
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *)b->ptr;

	/* Check if there are any messages waiting to be read */
	do
	{
		memset(&snp, 0, sizeof(union sctp_notification));
		iov.iov_base = (char *)&snp;
		iov.iov_len = sizeof(union sctp_notification);
		msg.msg_name = NULL;
		msg.msg_namelen = 0;
		msg.msg_iov = &iov;
		msg.msg_iovlen = 1;
		msg.msg_control = NULL;
		msg.msg_controllen = 0;
		msg.msg_flags = 0;

		sockflags = fcntl(b->num, F_GETFL, 0);
		fcntl(b->num, F_SETFL, O_NONBLOCK);
		n = recvmsg(b->num, &msg, MSG_PEEK);
		fcntl(b->num, F_SETFL, sockflags);

		/* if notification, process and try again */
		if (n > 0 && (msg.msg_flags & MSG_NOTIFICATION)) {
#ifdef SCTP_AUTHENTICATION_EVENT
			if (snp.sn_header.sn_type == SCTP_AUTHENTICATION_EVENT)
				dgram_sctp_handle_auth_free_key_event(b, &snp);
#endif

			memset(&snp, 0, sizeof(union sctp_notification));
			iov.iov_base = (char *)&snp;
			iov.iov_len = sizeof(union sctp_notification);
			msg.msg_name = NULL;
			msg.msg_namelen = 0;
			msg.msg_iov = &iov;
			msg.msg_iovlen = 1;
			msg.msg_control = NULL;
			msg.msg_controllen = 0;
			msg.msg_flags = 0;
			n = recvmsg(b->num, &msg, 0);

			if (data->handle_notifications != NULL)
				data->handle_notifications(b, data->notification_context, (void*) &snp);
		}

	} while (n > 0 && (msg.msg_flags & MSG_NOTIFICATION));

	/* Return 1 if there is a message to be read, return 0 otherwise. */
	if (n > 0)
		return 1;
	else
		return 0;
}

static int
dgram_sctp_puts(BIO *bp, const char *str)
{
	int n, ret;

	n = strlen(str);
	ret = dgram_sctp_write(bp, str, n);
	return (ret);
}
#endif
@


1.38
log
@Fix incorrect OPENSSL_assert() usage.

Instead of asserting, return an error code for I/O errors.  This is based
on OpenSSL commit 2521fcd8527008ceb3e4748f95b0ed4e2d70cfef.  Added checks
for two calloc()s while I'm here.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.37 2014/11/26 05:41:44 bcook Exp $ */
d829 5
a833 1
	free(data);
d941 1
d1109 1
a1109 1
		data->saved_message.length = inl;
d1111 4
d1116 1
@


1.37
log
@remove superflous gettimeofday wrapper.

ok beck@@ tedu@@ miod@@ guenther@@ doug@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.36 2014/11/26 05:39:06 bcook Exp $ */
d722 2
a723 1
	OPENSSL_assert(ret >= 0);
d726 2
a727 1
	OPENSSL_assert(ret >= 0);
d734 2
d737 4
a740 1
	OPENSSL_assert(ret >= 0);
d763 2
a764 1
	OPENSSL_assert(ret >= 0);
d768 2
a769 1
	OPENSSL_assert(ret >= 0);
d774 2
a775 1
	OPENSSL_assert(ret >= 0);
d783 2
a784 1
	OPENSSL_assert(ret >= 0);
d787 4
d947 4
a950 1
					OPENSSL_assert(i >= 0);
d954 4
a957 1
					OPENSSL_assert(i >= 0);
d962 4
a965 1
					OPENSSL_assert(i >= 0);
d996 2
a997 2
			OPENSSL_assert(ret >= 0);
			OPENSSL_assert(optval >= 18445);
d1005 2
a1006 2
			OPENSSL_assert(ret >= 0);
			OPENSSL_assert(optval >= 18445);
d1035 5
d1041 9
a1049 9
			OPENSSL_assert(ii >= 0);

			for (p = (unsigned char*) authchunks->gauth_chunks;
			    p < (unsigned char*) authchunks + optlen;
			    p += sizeof(uint8_t)) {
				if (*p == OPENSSL_SCTP_DATA_CHUNK_TYPE)
					auth_data = 1;
				if (*p == OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE)
					auth_forward = 1;
@


1.36
log
@memset like a normal human.

ok beck@@ tedu@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.35 2014/11/26 05:37:26 bcook Exp $ */
a106 2
static void get_current_time(struct timeval *t);

d258 1
a258 1
		get_current_time(&timenow);
a1609 5
}

static void
get_current_time(struct timeval *t) {
	gettimeofday(t, NULL);
@


1.35
log
@normalize set/getsockopt usage.

Remove the remaining random casts on optval. Fixups for this can be handled by
the portability layer all in once place.

Remove remaining fake socklen_t unions, though beck@@ points out that this also
removes support for socklen_t changing its length at runtime. RIP.

ok tedu@@ beck@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.34 2014/11/26 05:01:47 bcook Exp $ */
d328 1
a328 1
		memset(&sa.peer, 0x00, sizeof(sa.peer));
d580 1
a580 1
			memset(&(data->peer), 0x00, sizeof(data->peer));
d855 1
a855 1
			memset(&data->rcvinfo, 0x00, sizeof(struct bio_dgram_sctp_rcvinfo));
d1064 1
a1064 1
		memset(&handshake_sinfo, 0x00, sizeof(struct bio_dgram_sctp_sndinfo));
d1408 1
a1408 1
	memset(&snp, 0x00, sizeof(union sctp_notification));
d1429 1
a1429 1
		memset(&snp, 0x00, sizeof(union sctp_notification));
d1481 1
a1481 1
		memset(&snp, 0x00, sizeof(union sctp_notification));
d1528 1
a1528 1
		memset(&snp, 0x00, sizeof(union sctp_notification));
d1551 1
a1551 1
			memset(&snp, 0x00, sizeof(union sctp_notification));
@


1.34
log
@Linux has had IP_MTU since 2005, don't force it.

ok beck@@ miod@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.33 2014/08/24 16:08:30 bcook Exp $ */
a246 3
		union { size_t s;
		int i;
	} sz = {0};
d253 1
a253 1
		sz.i = sizeof(data->socket_timeout);
d255 1
a255 1
		    &(data->socket_timeout), (void *)&sz) < 0) {
d257 1
a257 2
		} else if (sizeof(sz.s) != sizeof(sz.i) && sz.i == 0)
			OPENSSL_assert(sz.s <= sizeof(data->socket_timeout));
d468 3
a470 3
			if ((ret = setsockopt(b->num, IPPROTO_IP,
			    IP_MTU_DISCOVER, &sockopt_val,
			    sizeof(sockopt_val))) < 0)
d476 1
a476 1
			if ((ret = setsockopt(b->num, IPPROTO_IPV6,
d478 2
a479 1
			    sizeof(sockopt_val))) < 0)
d502 3
a504 3
			if ((ret = getsockopt(b->num, IPPROTO_IP, IP_MTU,
			    (void *)&sockopt_val, &sockopt_len)) < 0 ||
			    sockopt_val < 0) {
d516 3
a518 3
			if ((ret = getsockopt(b->num, IPPROTO_IPV6, IPV6_MTU,
			    (void *)&sockopt_val, &sockopt_len)) < 0 ||
			    sockopt_val < 0) {
d626 1
a626 5
			union {
				size_t s;
				int i;
			} sz = {0};
			sz.i = sizeof(struct timeval);
d628 1
a628 1
			    ptr, (void *)&sz) < 0) {
a630 3
			} else if (sizeof(sz.s)!=sizeof(sz.i) && sz.i==0) {
				OPENSSL_assert(sz.s <= sizeof(struct timeval));
				ret = (int)sz.s;
d632 1
a632 1
				ret = sz.i;
d646 1
a646 5
			union {
				size_t s;
				int i;
			} sz = {0};
			sz.i = sizeof(struct timeval);
d648 1
a648 1
			    ptr, (void *)&sz) < 0) {
a650 3
			} else if (sizeof(sz.s) != sizeof(sz.i) && sz.i == 0) {
				OPENSSL_assert(sz.s <= sizeof(struct timeval));
				ret = (int)sz.s;
d652 1
a652 1
				ret = sz.i;
d1281 1
a1281 1
				&authkeyid, sizeof(struct sctp_authkeyid));
@


1.33
log
@Include <sys/time.h> to get struct timeval

The crypto/bio/bss_dgram.c file assumes that another file indirectly
includes <stdlib.h> that includes <sys/time.h>.

from Jonas 'Sortie' Termansen

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.32 2014/07/11 12:17:46 miod Exp $ */
a83 4
#if defined(OPENSSL_SYS_LINUX) && !defined(IP_MTU)
#define IP_MTU      14 /* linux is lame */
#endif

d393 1
a393 1
#if defined(OPENSSL_SYS_LINUX) && (defined(IP_MTU_DISCOVER) || defined(IP_MTU))
d462 1
a462 1
#if defined(OPENSSL_SYS_LINUX) && defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DO)
d495 1
a495 1
#if defined(OPENSSL_SYS_LINUX) && defined(IP_MTU)
@


1.32
log
@Missing calloc() return value check in dgram_sctp_ctrl(); from Kurt Roeckx via
OpenSSL trunk
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.31 2014/07/11 08:44:47 jsing Exp $ */
d61 1
@


1.31
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.30 2014/07/10 22:45:56 jsing Exp $ */
a1168 1
	struct sctp_authkey *authkey;
d1210 3
d1219 2
a1220 1
		ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY, &authkeyid, &sockopt_len);
d1227 4
d1235 2
a1236 1
		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_KEY, authkey, sockopt_len);
d1243 1
a1243 1
		&authkeyid, sizeof(struct sctp_authkeyid));
d1246 1
a1246 1

d1253 2
a1254 1
		ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY, &authkeyid, &sockopt_len);
d1261 1
a1261 1
		&authkeyid, sizeof(struct sctp_authkeyid));
d1281 2
a1282 1
			ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY, &authkeyid, &sockopt_len);
d1292 2
a1293 2
			ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_DEACTIVATE_KEY,
			&authkeyid, sockopt_len);
@


1.30
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.29 2014/07/10 13:58:22 jsing Exp $ */
a71 1
#include "cryptlib.h"
@


1.29
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_dgram.c,v 1.28 2014/06/12 15:49:28 deraadt Exp $ */
d69 2
@


1.28
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 3
d64 2
d67 1
a67 1
#include <errno.h>
d69 1
a71 3
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>
@


1.27
log
@Fix memory leak.

(From Martin Brejcha)

OK from tedu@@, miod@@ and deraadt@@
@
text
@d1 1
a1 1
/* crypto/bio/bio_dgram.c */
@


1.26
log
@more: no need for null check before free
ok tedu guenther
@
text
@d1225 1
@


1.25
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d220 1
a220 2
	if (data != NULL)
		free(data);
d832 1
a832 2
	if (data != NULL)
		free(data);
@


1.24
log
@This is not FreeBSD.

ok miod@@
@
text
@d109 8
a116 10
	BIO_TYPE_DGRAM,
	"datagram socket",
	dgram_write,
	dgram_read,
	dgram_puts,
	NULL, /* dgram_gets, */
	dgram_ctrl,
	dgram_new,
	dgram_free,
	NULL,
d121 8
a128 10
	BIO_TYPE_DGRAM_SCTP,
	"datagram sctp socket",
	dgram_sctp_write,
	dgram_sctp_read,
	dgram_sctp_puts,
	NULL, /* dgram_gets, */
	dgram_sctp_ctrl,
	dgram_sctp_new,
	dgram_sctp_free,
	NULL,
@


1.23
log
@The usual idiom to cope with systems not defining socklen_t is to add a
#define socklen_t int
somewhere (or a typedef, whatever gives you an integer type of the size
your system expects as the 3rd argument of accept(2), really).

OpenSSL here is a bit more creative by using an union of an int and a size_t,
and extra code if sizeof(int) != sizeof(size_t) in order to recover the
proper size. With a comment mentioning that this has no chance to work on
a platform with a stack growing up and accept() returning an int, fortunately
this seems to work on HP-UX.

Switch to the light side of the force and declare and use socklen_t variables,
period. If your system does not define socklen_t, consider bringing it back
to your vendor for a refund.

ok matthew@@ tedu@@
@
text
@a82 10
#if defined(__FreeBSD__) && defined(IN6_IS_ADDR_V4MAPPED)
/* Standard definition causes type-punning problems. */
#undef IN6_IS_ADDR_V4MAPPED
#define s6_addr32 __u6_addr.__u6_addr32
#define IN6_IS_ADDR_V4MAPPED(a)               \
        (((a)->s6_addr32[0] == 0) &&          \
         ((a)->s6_addr32[1] == 0) &&          \
         ((a)->s6_addr32[2] == htonl(0x0000ffff)))
#endif

a1144 3
#ifdef __FreeBSD__
	sndrcvinfo->sinfo_flags |= pinfo->pr_policy;
#endif
a1226 4
#ifndef __FreeBSD__
		/* This field is missing in FreeBSD 8.2 and earlier,
		 * and FreeBSD 8.3 and higher work without it.
		 */
a1227 1
#endif
@


1.22
log
@wrong calloc, see people do care
@
text
@d334 1
a334 7
		/*
		 * See commentary in b_sock.c. <appro>
		 */
		union	{
			size_t s;
			int i;
		} len;
d342 1
a342 2
	sa.len.s = 0;
	sa.len.i = sizeof(sa.peer);
d348 1
a348 5
		ret = recvfrom(b->num, out, outl, 0, &sa.peer.sa,(void *)&sa.len);
		if (sizeof(sa.len.i) != sizeof(sa.len.s) && sa.len.i == 0) {
			OPENSSL_assert(sa.len.s <= sizeof(sa.peer));
			sa.len.i = (int)sa.len.s;
		}
@


1.21
log
@Bring malloc/calloc/realloc sequences to modern standard
ok guenther
@
text
@d1121 2
a1122 1
		data->saved_message.data = calloc(1, inl);
@


1.20
log
@Put the final pieces from e_os.h in the required places, and remove it.
"dance on it's grave" says beck
ok guenther beck
@
text
@d214 1
a214 1
	data = malloc(sizeof(bio_dgram_data));
a216 1
	memset(data, 0x00, sizeof(bio_dgram_data));
d775 1
a775 2
	authchunks = malloc(sockopt_len);
	memset(authchunks, 0, sizeof(sockopt_len));
d835 1
a835 1
	data = malloc(sizeof(bio_dgram_sctp_data));
a837 1
	memset(data, 0x00, sizeof(bio_dgram_sctp_data));
d1055 1
a1055 2
			authchunks = malloc(optlen);
			memset(authchunks, 0, sizeof(optlen));
d1121 1
a1121 2
		data->saved_message.data = malloc(inl);
		memcpy(data->saved_message.data, in, inl);
d1248 1
a1248 2
		authkey = malloc(sockopt_len);
		memset(authkey, 0x00, sockopt_len);
@


1.19
log
@unistd.h for protos where needed
@
text
@a149 1
#if OPENSSL_USE_IPV6
a150 1
#endif
a169 1
#if OPENSSL_USE_IPV6
a170 1
#endif
a344 1
#if OPENSSL_USE_IPV6
a345 1
#endif
a391 1
#if OPENSSL_USE_IPV6
a393 1
#endif
a426 1
#if OPENSSL_USE_IPV6
a427 1
#endif
a477 1
#if OPENSSL_USE_IPV6
a480 1
#endif
d503 1
a503 1
#if OPENSSL_USE_IPV6 && defined(IPV6_MTU_DISCOVER) && defined(IPV6_PMTUDISC_DO)
d543 1
a543 1
#if OPENSSL_USE_IPV6 && defined(IPV6_MTU)
a570 1
#if OPENSSL_USE_IPV6
a578 1
#endif
a599 1
#if OPENSSL_USE_IPV6
a602 1
#endif
a616 1
#if OPENSSL_USE_IPV6
a619 1
#endif
a633 1
#if OPENSSL_USE_IPV6
a636 1
#endif
@


1.18
log
@more windows/netware leftovers
@
text
@d63 1
@


1.17
log
@delete if 0 code
@
text
@a400 3
#if defined(NETWARE_CLIB) && defined(NETWARE_BSDSOCK)
		ret = sendto(b->num, (char *)in, inl, 0, &data->peer.sa, peerlen);
#else
a401 1
#endif
@


1.16
log
@Mostly gut e_os.h:
USE_SOCKETS is unrelated to using sockets, but just pulls in .h files.  It
makes every file buy a kitchen sink, because 11 files forgot to.
EXIT() is really exit(), a gentle surprise
but... OPENSSL_EXIT() is really just return(), because noone compiles the
openssl command non-monolithic anymore
@
text
@d414 4
a417 6

#if 0 /* higher layers are responsible for querying MTU, if necessary */
			if (data->_errno == EMSGSIZE)
				/* retrieve the new MTU */
			BIO_ctrl(b, BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);
#endif
d487 4
a490 10
#if 0
		if (connect(b->num, to, sizeof(struct sockaddr)) < 0) {
			perror("connect");
			ret = 0;
		} else {
#endif
			switch (to->sa_family) {
			case AF_INET:
				memcpy(&data->peer, to, sizeof(data->peer.sa_in));
				break;
d492 7
a498 9
			case AF_INET6:
				memcpy(&data->peer, to, sizeof(data->peer.sa_in6));
				break;
#endif
			default:
				memcpy(&data->peer, to, sizeof(data->peer.sa));
				break;
			}
#if 0
a499 1
#endif
@


1.15
log
@some KNF cleanup following the script
@
text
@a62 1
#define USE_SOCKETS
d64 4
a68 1
#include <openssl/bio.h>
@


1.14
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d190 2
a191 2
BIO_METHOD
*BIO_s_datagram(void)
d196 2
a197 2
BIO
*BIO_new_dgram(int fd, int close_flag)
d767 2
a768 2
BIO_METHOD
*BIO_s_datagram_sctp(void)
d773 2
a774 2
BIO
*BIO_new_dgram_sctp(int fd, int close_flag)
@


1.13
log
@> As I walk through the valley of the shadow of death
> I take a look at my life and realize there's nothin' left
> Cause I've been blasting and laughing so long,
> That even my mama thinks that my mind is gone
Remove even more unspeakable evil being perpetuated in the name of VMS.
(and lesser evils done in the name of others.)
ok miod
@
text
@d215 1
a215 1
	data = OPENSSL_malloc(sizeof(bio_dgram_data));
d237 1
a237 1
		OPENSSL_free(data);
d808 1
a808 1
	authchunks = OPENSSL_malloc(sockopt_len);
d822 1
a822 1
	OPENSSL_free(authchunks);
d869 1
a869 1
	data = OPENSSL_malloc(sizeof(bio_dgram_sctp_data));
d894 1
a894 1
		OPENSSL_free(data);
d1001 1
a1001 1
						OPENSSL_free(data->saved_message.data);
d1090 1
a1090 1
			authchunks = OPENSSL_malloc(optlen);
d1104 1
a1104 1
			OPENSSL_free(authchunks);
d1157 1
a1157 1
		data->saved_message.data = OPENSSL_malloc(inl);
d1285 1
a1285 1
		authkey = OPENSSL_malloc(sockopt_len);
@


1.12
log
@Clean up non-fatal error handling - we know which error numbers we have
defined.

ok miod@@ beck@@
@
text
@a68 4
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS)
#include <sys/timeb.h>
#endif

a87 6
#endif

#ifdef WATT32
#define sock_write SockWrite  /* Watt-32 uses same names */
#define sock_read  SockRead
#define sock_puts  SockPuts
@


1.11
log
@Toss a `unifdef -U OPENSSL_SYS_WINDOWS' bomb into crypto/bio.

ok miod@@
@
text
@a1689 12

#ifdef EWOULDBLOCK
# ifdef WSAEWOULDBLOCK
#  if WSAEWOULDBLOCK != EWOULDBLOCK
	case EWOULDBLOCK:
#  endif
# else
	case EWOULDBLOCK:
# endif
#endif

#ifdef EINTR
a1690 4
#endif

#ifdef EAGAIN
#if EWOULDBLOCK != EAGAIN
a1691 8
# endif
#endif

#ifdef EPROTO
	case EPROTO:
#endif

#ifdef EINPROGRESS
a1692 3
#endif

#ifdef EALREADY
a1693 2
#endif

a1694 1
		/* break; */
@


1.10
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@a281 12
#ifdef OPENSSL_SYS_WINDOWS
		int timeout;

		sz.i = sizeof(timeout);
		if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
		    (void*)&timeout, &sz.i) < 0) {
			perror("getsockopt");
		} else {
			data->socket_timeout.tv_sec = timeout / 1000;
			data->socket_timeout.tv_usec = (timeout % 1000) * 1000;
		}
#else
a287 1
#endif
a313 7
#ifdef OPENSSL_SYS_WINDOWS
			timeout = timeleft.tv_sec * 1000 + timeleft.tv_usec / 1000;
			if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
			    (void*)&timeout, sizeof(timeout)) < 0) {
				perror("setsockopt");
			}
#else
a317 1
#endif
a330 8
#ifdef OPENSSL_SYS_WINDOWS
		int timeout = data->socket_timeout.tv_sec * 1000 +
		data->socket_timeout.tv_usec / 1000;
		if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
		    (void*)&timeout, sizeof(timeout)) < 0) {
			perror("setsockopt");
		}
#else
a334 1
#endif
a688 11
#ifdef OPENSSL_SYS_WINDOWS
		{
			struct timeval *tv = (struct timeval *)ptr;
			int timeout = tv->tv_sec * 1000 + tv->tv_usec/1000;
			if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
			    (void*)&timeout, sizeof(timeout)) < 0) {
				perror("setsockopt");
				ret = -1;
			}
		}
#else
a693 1
#endif
a700 15
#ifdef OPENSSL_SYS_WINDOWS
			int timeout;
			struct timeval *tv = (struct timeval *)ptr;

			sz.i = sizeof(timeout);
			if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
			    (void*)&timeout, &sz.i) < 0) {
				perror("getsockopt");
				ret = -1;
			} else {
				tv->tv_sec = timeout / 1000;
				tv->tv_usec = (timeout % 1000) * 1000;
				ret = sizeof(*tv);
			}
#else
a710 1
#endif
a715 11
#ifdef OPENSSL_SYS_WINDOWS
		{
			struct timeval *tv = (struct timeval *)ptr;
			int timeout = tv->tv_sec * 1000 + tv->tv_usec/1000;
			if (setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,
			    (void*)&timeout, sizeof(timeout)) < 0) {
				perror("setsockopt");
				ret = -1;
			}
		}
#else
a720 1
#endif
a727 15
#ifdef OPENSSL_SYS_WINDOWS
			int timeout;
			struct timeval *tv = (struct timeval *)ptr;

			sz.i = sizeof(timeout);
			if (getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,
			    (void*)&timeout, &sz.i) < 0) {
				perror("getsockopt");
				ret = -1;
			} else {
				tv->tv_sec = timeout / 1000;
				tv->tv_usec = (timeout % 1000) * 1000;
				ret = sizeof(*tv);
			}
#else
a737 1
#endif
d744 1
a744 6
#ifdef OPENSSL_SYS_WINDOWS
		if (data->_errno == WSAETIMEDOUT)
#else
		if (data->_errno == EAGAIN)
#endif
		{
a1680 10

#if defined(OPENSSL_SYS_WINDOWS)
	/* If the socket return value (i) is -1
	 * and err is unexpectedly 0 at this point,
	 * the error code was overwritten by
	 * another system call before this error
	 * handling is called.
	 */
#endif

a1689 11
#if defined(OPENSSL_SYS_WINDOWS)
# if defined(WSAEWOULDBLOCK)
	case WSAEWOULDBLOCK:
# endif

# if 0 /* This appears to always be an error */
#  if defined(WSAENOTCONN)
	case WSAENOTCONN:
#  endif
# endif
#endif
@


1.9
log
@two SHUTDOWN2 got away; noticed by beck
@
text
@d116 2
a117 1
static void dgram_sctp_handle_auth_free_key_event(BIO *b, union sctp_notification *snp);
d125 1
a125 2
static BIO_METHOD methods_dgramp=
	{
d136 1
a136 1
	};
d139 1
a139 2
static BIO_METHOD methods_dgramp_sctp=
	{
d150 1
a150 1
	};
d153 1
a153 2
typedef struct bio_dgram_data_st
	{
d166 1
a166 1
	} bio_dgram_data;
d169 5
a173 6
typedef struct bio_dgram_sctp_save_message_st
	{
        BIO *bio;
        char *data;
        int length;
	} bio_dgram_sctp_save_message;
d175 1
a175 2
typedef struct bio_dgram_sctp_data_st
	{
d197 1
a197 1
	} bio_dgram_sctp_data;
d200 5
a204 4
BIO_METHOD *BIO_s_datagram(void)
	{
	return(&methods_dgramp);
	}
d206 3
a208 2
BIO *BIO_new_dgram(int fd, int close_flag)
	{
d211 6
a216 5
	ret=BIO_new(BIO_s_datagram());
	if (ret == NULL) return(NULL);
	BIO_set_fd(ret,fd,close_flag);
	return(ret);
	}
d218 3
a220 2
static int dgram_new(BIO *bi)
	{
d223 2
a224 2
	bi->init=0;
	bi->num=0;
d229 1
a229 1
    bi->ptr = data;
d231 3
a233 3
	bi->flags=0;
	return(1);
	}
d235 3
a237 2
static int dgram_free(BIO *a)
	{
d240 3
a242 2
	if (a == NULL) return(0);
	if ( ! dgram_clear(a))
d246 2
a247 1
	if(data != NULL) OPENSSL_free(data);
d249 2
a250 2
	return(1);
	}
d252 7
a258 7
static int dgram_clear(BIO *a)
	{
	if (a == NULL) return(0);
	if (a->shutdown)
		{
		if (a->init)
			{
a260 3
			}
		a->init=0;
		a->flags=0;
d262 2
a263 1
	return(1);
d265 2
d268 3
a270 2
static void dgram_adjust_rcv_timeout(BIO *b)
	{
d273 3
a275 1
	union { size_t s; int i; } sz = {0};
d278 1
a278 2
	if (data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0)
		{
d287 3
a289 4
					   (void*)&timeout, &sz.i) < 0)
			{ perror("getsockopt"); }
		else
			{
d292 1
a292 1
			}
d295 5
a299 5
		if ( getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, 
						&(data->socket_timeout), (void *)&sz) < 0)
			{ perror("getsockopt"); }
		else if (sizeof(sz.s)!=sizeof(sz.i) && sz.i==0)
			OPENSSL_assert(sz.s<=sizeof(data->socket_timeout));
d309 1
a309 2
		if (timeleft.tv_usec < 0)
			{
d312 1
a312 1
			}
d314 1
a314 2
		if (timeleft.tv_sec < 0)
			{
d317 1
a317 1
			}
d322 5
a326 5
		if ((data->socket_timeout.tv_sec == 0 && data->socket_timeout.tv_usec == 0) ||
			(data->socket_timeout.tv_sec > timeleft.tv_sec) ||
			(data->socket_timeout.tv_sec == timeleft.tv_sec &&
			 data->socket_timeout.tv_usec >= timeleft.tv_usec))
			{
d330 3
a332 2
						   (void*)&timeout, sizeof(timeout)) < 0)
				{ perror("setsockopt"); }
d334 4
a337 3
			if ( setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, &timeleft,
							sizeof(struct timeval)) < 0)
				{ perror("setsockopt"); }
a338 1
			}
d340 1
d342 1
a342 1
	}
d344 3
a346 2
static void dgram_reset_rcv_timeout(BIO *b)
	{
d351 1
a351 2
	if (data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0)
		{
d354 1
a354 1
					  data->socket_timeout.tv_usec / 1000;
d356 3
a358 2
					   (void*)&timeout, sizeof(timeout)) < 0)
			{ perror("setsockopt"); }
d360 3
a362 4
		if ( setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, &(data->socket_timeout),
						sizeof(struct timeval)) < 0)
			{ perror("setsockopt"); }
#endif
d366 2
d369 4
a372 3
static int dgram_read(BIO *b, char *out, int outl)
	{
	int ret=0;
d376 10
a385 7
	/*
	 * See commentary in b_sock.c. <appro>
	 */
	union	{ size_t s; int i; } len;
	union	{
		struct sockaddr sa;
		struct sockaddr_in sa_in;
d387 1
a387 1
		struct sockaddr_in6 sa_in6;
d392 2
a393 2
	sa.len.s=0;
	sa.len.i=sizeof(sa.peer);
d395 1
a395 2
	if (out != NULL)
		{
d399 3
a401 4
		ret=recvfrom(b->num,out,outl,0,&sa.peer.sa,(void *)&sa.len);
		if (sizeof(sa.len.i)!=sizeof(sa.len.s) && sa.len.i==0)
			{
			OPENSSL_assert(sa.len.s<=sizeof(sa.peer));
d403 1
a403 1
			}
d405 1
a405 1
		if ( ! data->connected  && ret >= 0)
d409 2
a410 4
		if (ret < 0)
			{
			if (BIO_dgram_should_retry(ret))
				{
a412 1
				}
d414 1
a416 2
		}
	return(ret);
d418 2
d421 3
a423 2
static int dgram_write(BIO *b, const char *in, int inl)
	{
d428 3
a430 4
	if ( data->connected )
		ret=write(b->num,in,inl);
	else
		{
d440 1
a440 1
		ret=sendto(b->num, (char *)in, inl, 0, &data->peer.sa, peerlen);
d442 1
a442 1
		ret=sendto(b->num, in, inl, 0, &data->peer.sa, peerlen);
d444 1
a444 1
		}
d447 4
a450 5
	if (ret <= 0)
		{
		if (BIO_dgram_should_retry(ret))
			{
			BIO_set_retry_write(b);  
d454 1
a454 1
			if ( data->_errno == EMSGSIZE)
d456 1
a456 1
				BIO_ctrl(b, BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);
a457 1
			}
a458 1
	return(ret);
d460 2
d463 4
a466 3
static long dgram_ctrl(BIO *b, int cmd, long num, void *ptr)
	{
	long ret=1;
d481 1
a481 1
		} addr;
d486 1
a486 2
	switch (cmd)
		{
d488 1
a488 1
		num=0;
d490 1
a490 1
		ret=0;
d494 1
a494 1
		ret=0;
d499 2
a500 2
		b->shutdown=(int)num;
		b->init=1;
d503 7
a509 8
		if (b->init)
			{
			ip=(int *)ptr;
			if (ip != NULL) *ip=b->num;
			ret=b->num;
			}
		else
			ret= -1;
d512 1
a512 1
		ret=b->shutdown;
d515 1
a515 1
		b->shutdown=(int)num;
d519 1
a519 1
		ret=0;
d523 1
a523 1
		ret=1;
d528 4
a531 4
		if (connect(b->num, to, sizeof(struct sockaddr)) < 0)
			{ perror("connect"); ret = 0; }
		else
			{
d533 4
a536 5
			switch (to->sa_family)
				{
				case AF_INET:
					memcpy(&data->peer,to,sizeof(data->peer.sa_in));
					break;
d538 3
a540 3
				case AF_INET6:
					memcpy(&data->peer,to,sizeof(data->peer.sa_in6));
					break;
d542 4
a545 4
				default:
					memcpy(&data->peer,to,sizeof(data->peer.sa));
					break;
				}
d547 1
a547 1
			}
d555 1
a555 2
		if (getsockname(b->num, &addr.sa, &addr_len) < 0)
			{
d558 2
a559 3
			}
		switch (addr.sa.sa_family)
			{
d562 3
a564 2
			if ((ret = setsockopt(b->num, IPPROTO_IP, IP_MTU_DISCOVER,
				&sockopt_val, sizeof(sockopt_val))) < 0)
d570 3
a572 2
			if ((ret = setsockopt(b->num, IPPROTO_IPV6, IPV6_MTU_DISCOVER,
				&sockopt_val, sizeof(sockopt_val))) < 0)
d579 1
a579 1
			}
d588 1
a588 2
		if (getsockname(b->num, &addr.sa, &addr_len) < 0)
			{
d591 1
a591 1
			}
d593 1
a593 2
		switch (addr.sa.sa_family)
			{
d595 3
a597 3
			if ((ret = getsockopt(b->num, IPPROTO_IP, IP_MTU, (void *)&sockopt_val,
				&sockopt_len)) < 0 || sockopt_val < 0)
				{
d599 1
a599 3
				}
			else
				{
d605 1
a605 1
				}
d609 3
a611 3
			if ((ret = getsockopt(b->num, IPPROTO_IPV6, IPV6_MTU, (void *)&sockopt_val,
				&sockopt_len)) < 0 || sockopt_val < 0)
				{
d613 1
a613 3
				}
			else
				{
d619 1
a619 1
				}
d622 1
a622 1
		default:
d625 1
a625 1
			}
d631 4
a634 5
		switch (data->peer.sa.sa_family)
			{
			case AF_INET:
				ret = 576 - 20 - 8;
				break;
d636 1
a636 1
			case AF_INET6:
d638 3
a640 3
				if (IN6_IS_ADDR_V4MAPPED(&data->peer.sa_in6.sin6_addr))
					ret = 576 - 20 - 8;
				else
d642 2
a643 2
					ret = 1280 - 40 - 8;
				break;
d645 4
a648 4
			default:
				ret = 576 - 20 - 8;
				break;
			}
d660 1
a660 2
		if ( to != NULL)
			{
d662 4
a665 5
			switch (to->sa_family)
				{
				case AF_INET:
					memcpy(&data->peer,to,sizeof(data->peer.sa_in));
					break;
d667 3
a669 3
				case AF_INET6:
					memcpy(&data->peer,to,sizeof(data->peer.sa_in6));
					break;
d671 3
a673 4
				default:
					memcpy(&data->peer,to,sizeof(data->peer.sa));
					break;
				}
d675 1
a675 2
		else
			{
d678 1
a678 1
			}
d681 4
a684 5
		switch (data->peer.sa.sa_family)
			{
			case AF_INET:
				ret=sizeof(data->peer.sa_in);
				break;
d686 3
a688 3
			case AF_INET6:
				ret=sizeof(data->peer.sa_in6);
				break;
d690 7
a696 7
			default:
				ret=sizeof(data->peer.sa);
				break;
			}
		if (num==0 || num>ret)
			num=ret;
		memcpy(ptr,&data->peer,(ret=num));
d700 4
a703 5
		switch (to->sa_family)
			{
			case AF_INET:
				memcpy(&data->peer,to,sizeof(data->peer.sa_in));
				break;
d705 3
a707 3
			case AF_INET6:
				memcpy(&data->peer,to,sizeof(data->peer.sa_in6));
				break;
d709 4
a712 4
			default:
				memcpy(&data->peer,to,sizeof(data->peer.sa));
				break;
			}
d721 7
a727 5
		struct timeval *tv = (struct timeval *)ptr;
		int timeout = tv->tv_sec * 1000 + tv->tv_usec/1000;
		if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
			(void*)&timeout, sizeof(timeout)) < 0)
			{ perror("setsockopt"); ret = -1; }
d730 5
a734 3
		if ( setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, ptr,
			sizeof(struct timeval)) < 0)
			{ perror("setsockopt");	ret = -1; }
d739 4
a742 1
		union { size_t s; int i; } sz = {0};
d744 2
a745 2
		int timeout;
		struct timeval *tv = (struct timeval *)ptr;
d747 9
a755 9
		sz.i = sizeof(timeout);
		if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
			(void*)&timeout, &sz.i) < 0)
			{ perror("getsockopt"); ret = -1; }
		else
			{
			tv->tv_sec = timeout / 1000;
			tv->tv_usec = (timeout % 1000) * 1000;
			ret = sizeof(*tv);
d758 10
a767 11
		sz.i = sizeof(struct timeval);
		if ( getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, 
			ptr, (void *)&sz) < 0)
			{ perror("getsockopt"); ret = -1; }
		else if (sizeof(sz.s)!=sizeof(sz.i) && sz.i==0)
			{
			OPENSSL_assert(sz.s<=sizeof(struct timeval));
			ret = (int)sz.s;
			}
		else
			ret = sz.i;
d776 7
a782 5
		struct timeval *tv = (struct timeval *)ptr;
		int timeout = tv->tv_sec * 1000 + tv->tv_usec/1000;
		if (setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,
			(void*)&timeout, sizeof(timeout)) < 0)
			{ perror("setsockopt"); ret = -1; }
d785 5
a789 3
		if ( setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO, ptr,
			sizeof(struct timeval)) < 0)
			{ perror("setsockopt");	ret = -1; }
d794 4
a797 1
		union { size_t s; int i; } sz = {0};
d799 2
a800 2
		int timeout;
		struct timeval *tv = (struct timeval *)ptr;
d802 9
a810 9
		sz.i = sizeof(timeout);
		if (getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,
			(void*)&timeout, &sz.i) < 0)
			{ perror("getsockopt"); ret = -1; }
		else
			{
			tv->tv_sec = timeout / 1000;
			tv->tv_usec = (timeout % 1000) * 1000;
			ret = sizeof(*tv);
d813 10
a822 11
		sz.i = sizeof(struct timeval);
		if ( getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO, 
			ptr, (void *)&sz) < 0)
			{ perror("getsockopt"); ret = -1; }
		else if (sizeof(sz.s)!=sizeof(sz.i) && sz.i==0)
			{
			OPENSSL_assert(sz.s<=sizeof(struct timeval));
			ret = (int)sz.s;
			}
		else
			ret = sz.i;
d831 1
a831 1
		if ( data->_errno == WSAETIMEDOUT)
d833 1
a833 1
		if ( data->_errno == EAGAIN)
d835 1
a835 1
			{
d838 1
a838 2
			}
		else
d843 1
a843 2
		if ( data->_errno == EMSGSIZE)
			{
d846 1
a846 2
			}
		else
d851 1
a851 1
		ret=0;
a852 2
		}
	return(ret);
d854 2
d857 4
a860 3
static int dgram_puts(BIO *bp, const char *str)
	{
	int n,ret;
d862 4
a865 4
	n=strlen(str);
	ret=dgram_write(bp,str,n);
	return(ret);
	}
d868 5
a872 4
BIO_METHOD *BIO_s_datagram_sctp(void)
	{
	return(&methods_dgramp_sctp);
	}
d874 3
a876 2
BIO *BIO_new_dgram_sctp(int fd, int close_flag)
	{
d892 4
a895 3
	bio=BIO_new(BIO_s_datagram_sctp());
	if (bio == NULL) return(NULL);
	BIO_set_fd(bio,fd,close_flag);
d915 8
a922 7
	     p < (unsigned char*) authchunks + sockopt_len;
	     p += sizeof(uint8_t))
		{
		if (*p == OPENSSL_SCTP_DATA_CHUNK_TYPE) auth_data = 1;
		if (*p == OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE) auth_forward = 1;
		}
		
d954 2
a955 2
	return(bio);
	}
d957 3
a959 2
int BIO_dgram_is_sctp(BIO *bio)
	{
d961 1
a961 1
	}
d963 3
a965 2
static int dgram_sctp_new(BIO *bi)
	{
d968 2
a969 2
	bi->init=0;
	bi->num=0;
d977 1
a977 1
    bi->ptr = data;
d979 3
a981 3
	bi->flags=0;
	return(1);
	}
d983 3
a985 2
static int dgram_sctp_free(BIO *a)
	{
d988 3
a990 2
	if (a == NULL) return(0);
	if ( ! dgram_clear(a))
d994 2
a995 1
	if(data != NULL) OPENSSL_free(data);
d997 2
a998 2
	return(1);
	}
d1001 3
a1003 2
void dgram_sctp_handle_auth_free_key_event(BIO *b, union sctp_notification *snp)
	{
d1007 1
a1007 2
	if (authkeyevent->auth_indication == SCTP_AUTH_FREE_KEY)
		{
d1013 1
a1013 2
		      &authkeyid, sizeof(struct sctp_authkeyid));
		}
d1015 1
d1018 3
a1020 2
static int dgram_sctp_read(BIO *b, char *out, int outl)
	{
d1030 1
a1030 2
	if (out != NULL)
		{
d1033 1
a1033 2
		do
			{
d1046 2
a1047 4
			if (msg.msg_controllen > 0)
				{
				for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg))
					{
d1051 1
a1051 2
					if (cmsg->cmsg_type == SCTP_RCVINFO)
						{
d1062 1
a1062 1
						}
d1065 1
a1065 2
					if (cmsg->cmsg_type == SCTP_SNDRCV)
						{
d1076 1
a1076 1
						}
a1077 1
					}
d1079 1
d1081 1
a1081 2
			if (n <= 0)
				{
d1085 1
a1085 1
				}
d1087 1
a1087 2
			if (msg.msg_flags & MSG_NOTIFICATION)
				{
d1089 1
a1089 2
				if (snp->sn_header.sn_type == SCTP_SENDER_DRY_EVENT)
					{
d1099 1
a1099 2
					if (data->saved_message.length > 0)
						{
d1101 1
a1101 1
						                 data->saved_message.length);
d1104 1
a1104 1
						}
d1124 1
a1124 1
					}
d1135 1
a1135 2
				}
			else
d1137 1
a1137 1
			}
d1140 1
a1140 2
		if (ret > 0 && !(msg.msg_flags & MSG_EOR))
			{
d1160 2
a1161 2
			ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_PARTIAL_DELIVERY_POINT,
			                 &optval, &optlen);
d1174 1
a1174 1
			}
d1177 2
a1178 4
		if (ret < 0)
			{
			if (BIO_dgram_should_retry(ret))
				{
a1180 1
				}
d1182 1
d1185 1
a1185 2
		if (!data->peer_auth_tested)
			{
d1197 7
a1203 6
				 p < (unsigned char*) authchunks + optlen;
				 p += sizeof(uint8_t))
				{
				if (*p == OPENSSL_SCTP_DATA_CHUNK_TYPE) auth_data = 1;
				if (*p == OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE) auth_forward = 1;
				}
d1207 2
a1208 3
			if (!auth_data || !auth_forward)
				{
				BIOerr(BIO_F_DGRAM_SCTP_READ,BIO_R_CONNECT_ERROR);
d1210 1
a1210 1
				}
a1212 1
			}
a1213 1
	return(ret);
d1215 2
d1218 3
a1220 2
static int dgram_sctp_write(BIO *b, const char *in, int inl)
	{
d1255 1
a1255 2
	if (data->save_shutdown && !BIO_dgram_sctp_wait_for_dry(b))
	{
d1315 4
a1318 5
	if (ret <= 0)
		{
		if (BIO_dgram_should_retry(ret))
			{
			BIO_set_retry_write(b);  
a1319 1
			}
a1320 1
	return(ret);
d1322 2
d1325 4
a1328 3
static long dgram_sctp_ctrl(BIO *b, int cmd, long num, void *ptr)
	{
	long ret=1;
d1336 1
a1336 2
	switch (cmd)
		{
d1381 2
a1382 1
		if (ret < 0) break;
d1398 2
a1399 1
		if (ret < 0) break;
d1403 3
a1405 2
		      &authkeyid, sizeof(struct sctp_authkeyid));
		if (ret < 0) break;
d1414 2
a1415 1
		if (ret < 0) break;
d1420 3
a1422 2
		      &authkeyid, sizeof(struct sctp_authkeyid));
		if (ret < 0) break;
d1437 1
a1437 2
		if (data->ccs_rcvd == 1 && data->ccs_sent == 1)
			{
d1441 2
a1442 1
			if (ret < 0) break;
d1451 3
a1453 2
			      &authkeyid, sockopt_len);
			if (ret < 0) break;
d1456 1
a1456 2
			if (authkeyid.scact_keynumber > 0)
				{
d1459 4
a1462 3
					  &authkeyid, sizeof(struct sctp_authkeyid));
				if (ret < 0) break;
				}
d1467 1
a1467 1
			}
d1527 1
a1527 1
		ret=dgram_ctrl(b, cmd, num, ptr);
a1528 2
		}
	return(ret);
d1530 2
d1533 5
a1537 4
int BIO_dgram_sctp_notification_cb(BIO *b,
                                   void (*handle_notifications)(BIO *bio, void *context, void *buf),
                                   void *context)
	{
d1540 1
a1540 2
	if (handle_notifications != NULL)
		{
d1543 1
a1543 2
		}
	else
d1547 1
a1547 1
	}
d1549 2
a1550 1
int BIO_dgram_sctp_wait_for_dry(BIO *b)
d1577 1
a1577 1
	
d1579 1
a1579 1
	
d1598 1
a1598 2
	if (n <= 0)
		{
d1603 1
a1603 1
		}
d1606 1
a1606 2
	while (msg.msg_flags & MSG_NOTIFICATION)
		{
d1619 1
a1619 2
		if (n <= 0)
			{
d1624 3
a1626 4
			}
		
		if (snp.sn_header.sn_type == SCTP_SENDER_DRY_EVENT)
			{
d1648 1
a1648 1
			}
d1671 1
a1671 2
		if (is_dry)
			{
d1674 1
a1674 1
			}
d1678 1
a1678 2
		if (is_dry)
			{
d1680 1
a1680 1
			}
d1682 1
a1682 2
		if (n <= 0)
			{
a1686 1
			}
d1688 1
d1694 3
a1696 2
int BIO_dgram_sctp_msg_waiting(BIO *b)
	{
d1705 1
a1705 1
		{
d1723 1
a1723 2
		if (n > 0 && (msg.msg_flags & MSG_NOTIFICATION))
			{
d1743 1
a1743 1
			}
d1745 1
a1745 1
		} while (n > 0 && (msg.msg_flags & MSG_NOTIFICATION));
d1752 1
a1752 1
	}
d1754 4
a1757 3
static int dgram_sctp_puts(BIO *bp, const char *str)
	{
	int n,ret;
d1759 4
a1762 4
	n=strlen(str);
	ret=dgram_sctp_write(bp,str,n);
	return(ret);
	}
d1765 3
a1767 2
static int BIO_dgram_should_retry(int i)
	{
d1770 2
a1771 3
	if ((i == 0) || (i == -1))
		{
		err=errno;
d1782 1
a1782 3
		return(BIO_dgram_non_fatal_error(err));
		}
	return(0);
d1784 2
d1787 4
a1790 4
int BIO_dgram_non_fatal_error(int err)
	{
	switch (err)
		{
d1835 1
a1835 1
		return(1);
a1838 2
		}
	return(0);
d1840 2
d1843 2
a1844 2
static void get_current_time(struct timeval *t)
	{
d1846 1
a1846 1
	}
@


1.8
log
@Remove various horrible socket syscall wrappers, especially SHUTDOWN*
which did shutdown + close, all nasty and surprising.  Use the raw
syscalls that everyone knows the behaviour of.
ok beck matthew
@
text
@d256 2
a257 1
			SHUTDOWN2(a->num);
@


1.7
log
@Flense a variety of windows support stuff, and a strange gettimeofday function.
ok deraadt@@
@
text
@d386 1
a386 1
		clear_socket_error();
d405 1
a405 1
				data->_errno = get_last_socket_error();
d418 1
a418 1
	clear_socket_error();
d421 1
a421 1
		ret=writesocket(b->num,in,inl);
d445 1
a445 1
			data->_errno = get_last_socket_error();
d1021 1
a1021 1
		clear_socket_error();
d1183 1
a1183 1
				data->_errno = get_last_socket_error();
d1241 1
a1241 1
	clear_socket_error();
d1324 1
a1324 1
			data->_errno = get_last_socket_error();
d1599 1
a1599 1
		if ((n < 0) && (get_last_socket_error() != EAGAIN) && (get_last_socket_error() != EWOULDBLOCK))
d1622 1
a1622 1
			if ((n < 0) && (get_last_socket_error() != EAGAIN) && (get_last_socket_error() != EWOULDBLOCK))
d1689 1
a1689 1
			if ((n < 0) && (get_last_socket_error() != EAGAIN) && (get_last_socket_error() != EWOULDBLOCK))
d1776 1
a1776 1
		err=get_last_socket_error();
@


1.6
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a1849 11
#ifdef OPENSSL_SYS_WIN32
	struct _timeb tb;
	_ftime(&tb);
	t->tv_sec = (long)tb.time;
	t->tv_usec = (long)tb.millitm * 1000;
#elif defined(OPENSSL_SYS_VMS)
	struct timeb tb;
	ftime(&tb);
	t->tv_sec = (long)tb.time;
	t->tv_usec = (long)tb.millitm * 1000;
#else
a1850 1
#endif
@


1.5
log
@resolve conflicts
@
text
@d80 1
a80 1
#ifdef OPENSSL_SYS_LINUX
d84 10
d268 1
a268 1
	int sz = sizeof(int);
d278 2
d281 1
a281 1
					   (void*)&timeout, &sz) < 0)
d289 1
d293 2
d463 4
a466 5
#if defined(IP_MTU_DISCOVER) || defined(IP_MTU)
	long sockopt_val = 0;
	unsigned int sockopt_len = 0;
#endif
#ifdef OPENSSL_SYS_LINUX
d548 1
a548 1
#ifdef OPENSSL_SYS_LINUX
a555 1
		sockopt_len = sizeof(sockopt_val);
d564 1
a564 1
#if OPENSSL_USE_IPV6 && defined(IPV6_MTU_DISCOVER)
d581 1
a581 1
#ifdef OPENSSL_SYS_LINUX
d743 2
d746 1
a746 2
		{
		int timeout, sz = sizeof(timeout);
d748 2
d751 1
a751 1
			(void*)&timeout, &sz) < 0)
a758 1
		}
d760 1
d762 1
a762 1
			ptr, (void *)&ret) < 0)
d764 7
d772 1
d792 2
d795 1
a795 2
		{
		int timeout, sz = sizeof(timeout);
d797 2
d800 1
a800 1
			(void*)&timeout, &sz) < 0)
a807 1
		}
d809 1
d811 1
a811 1
			ptr, (void *)&ret) < 0)
d813 7
d821 1
d909 2
a910 2
	
	for (p = (unsigned char*) authchunks + sizeof(sctp_assoc_t);
a992 1
	unsigned int sockopt_len = 0;
a1001 1
		sockopt_len = sizeof(struct sctp_authkeyid);
d1003 1
a1003 1
		      &authkeyid, sockopt_len);
d1200 1
a1200 1
			for (p = (unsigned char*) authchunks + sizeof(sctp_assoc_t);
d1334 1
a1334 1
	unsigned int sockopt_len = 0;
@


1.4
log
@openssl-1.0.0e: resolve conflicts
@
text
@d73 7
d98 12
d128 16
d160 34
d619 21
d830 906
@


1.3
log
@resolve conflicts, fix local changes
@
text
@a59 1
#ifndef OPENSSL_NO_DGRAM
d67 1
a310 1
		dgram_reset_rcv_timeout(b);
d324 2
d344 1
a344 1
#if OPENSSL_USE_IVP6
d749 7
a755 3
#if defined(OPENSSL_SYS_WINDOWS) && 0 /* more microsoft stupidity? perhaps not? Ben 4/1/99 */
		if ((i == -1) && (err == 0))
			return(1);
a817 1
#endif
d835 2
@


1.2
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d69 5
d75 1
d93 2
d111 7
a117 1
	struct sockaddr peer;
d121 2
d184 94
a277 1
	
d283 16
a298 2
	struct sockaddr peer;
	int peerlen = sizeof(peer);
d303 9
a311 7
		memset(&peer, 0x00, peerlen);
		/* Last arg in recvfrom is signed on some platforms and
		 * unsigned on others. It is of type socklen_t on some
		 * but this is not universal. Cast to (void *) to avoid
		 * compiler warnings.
		 */
		ret=recvfrom(b->num,out,outl,0,&peer,(void *)&peerlen);
d313 2
a314 2
		if ( ! data->connected  && ret > 0)
			BIO_ctrl(b, BIO_CTRL_DGRAM_CONNECT, 0, &peer);
d317 1
a317 1
		if (ret <= 0)
d335 12
a346 3
    if ( data->connected )
        ret=writesocket(b->num,in,inl);
    else
d348 1
a348 1
        ret=sendto(b->num, (char *)in, inl, 0, &data->peer, sizeof(data->peer));
d350 1
a350 1
        ret=sendto(b->num, in, inl, 0, &data->peer, sizeof(data->peer));
d352 1
d357 1
a357 1
		if (BIO_sock_should_retry(ret))
d378 1
d381 11
d444 14
a457 1
			memcpy(&(data->peer),to, sizeof(struct sockaddr));
a462 1
#ifdef IP_MTU_DISCOVER
d464 31
a494 4
		sockopt_val = IP_PMTUDISC_DO;
		if ((ret = setsockopt(b->num, IPPROTO_IP, IP_MTU_DISCOVER,
			&sockopt_val, sizeof(sockopt_val))) < 0)
			perror("setsockopt");
d498 10
a507 5
         sockopt_len = sizeof(sockopt_val);
		if ((ret = getsockopt(b->num, IPPROTO_IP, IP_MTU, (void *)&sockopt_val,
			&sockopt_len)) < 0 || sockopt_val < 0)
			{ ret = 0; }
		else
d509 35
a543 2
			data->mtu = sockopt_val;
			ret = data->mtu;
d545 3
d562 14
a575 1
			memcpy(&(data->peer),to, sizeof(struct sockaddr));
d580 37
a616 1
			memset(&(data->peer), 0x00, sizeof(struct sockaddr));
d619 3
a621 5
    case BIO_CTRL_DGRAM_SET_PEER:
        to = (struct sockaddr *) ptr;

        memcpy(&(data->peer), to, sizeof(struct sockaddr));
        break;
a783 4
#if defined(ENOTCONN)
	case ENOTCONN:
#endif

a805 5
/* DF bit set, and packet larger than MTU */
#ifdef EMSGSIZE
	case EMSGSIZE:
#endif

d814 17
@


1.1
log
@Initial revision
@
text
@d85 1
a85 1
int BIO_dgram_should_retry(int s);
d348 1
d350 9
d362 1
d365 15
d383 1
d385 2
d388 9
d400 1
d403 15
d421 1
d423 1
d427 3
d431 1
d466 1
a466 1
int BIO_dgram_should_retry(int i)
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import openssl-0.9.8j
@
text
@d85 1
a85 1
static int BIO_dgram_should_retry(int s);
a347 1
#if defined(SO_RCVTIMEO)
a348 9
#ifdef OPENSSL_SYS_WINDOWS
		{
		struct timeval *tv = (struct timeval *)ptr;
		int timeout = tv->tv_sec * 1000 + tv->tv_usec/1000;
		if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
			(void*)&timeout, sizeof(timeout)) < 0)
			{ perror("setsockopt"); ret = -1; }
		}
#else
a351 1
#endif
a353 15
#ifdef OPENSSL_SYS_WINDOWS
		{
		int timeout, sz = sizeof(timeout);
		struct timeval *tv = (struct timeval *)ptr;
		if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
			(void*)&timeout, &sz) < 0)
			{ perror("getsockopt"); ret = -1; }
		else
			{
			tv->tv_sec = timeout / 1000;
			tv->tv_usec = (timeout % 1000) * 1000;
			ret = sizeof(*tv);
			}
		}
#else
a356 1
#endif
a357 2
#endif
#if defined(SO_SNDTIMEO)
a358 9
#ifdef OPENSSL_SYS_WINDOWS
		{
		struct timeval *tv = (struct timeval *)ptr;
		int timeout = tv->tv_sec * 1000 + tv->tv_usec/1000;
		if (setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,
			(void*)&timeout, sizeof(timeout)) < 0)
			{ perror("setsockopt"); ret = -1; }
		}
#else
a361 1
#endif
a363 15
#ifdef OPENSSL_SYS_WINDOWS
		{
		int timeout, sz = sizeof(timeout);
		struct timeval *tv = (struct timeval *)ptr;
		if (getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,
			(void*)&timeout, &sz) < 0)
			{ perror("getsockopt"); ret = -1; }
		else
			{
			tv->tv_sec = timeout / 1000;
			tv->tv_usec = (timeout % 1000) * 1000;
			ret = sizeof(*tv);
			}
		}
#else
a366 1
#endif
a367 1
#endif
a370 3
#ifdef OPENSSL_SYS_WINDOWS
		if ( data->_errno == WSAETIMEDOUT)
#else
a371 1
#endif
d406 1
a406 1
static int BIO_dgram_should_retry(int i)
@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@a68 5
#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_VMS)
#include <sys/timeb.h>
#endif

#ifdef OPENSSL_SYS_LINUX
a69 1
#endif
a86 2
static void get_current_time(struct timeval *t);

d103 1
a103 7
	union {
		struct sockaddr sa;
		struct sockaddr_in sa_in;
#if OPENSSL_USE_IPV6
		struct sockaddr_in6 sa_in6;
#endif
	} peer;
a106 2
	struct timeval next_timeout;
	struct timeval socket_timeout;
d168 1
a168 94

static void dgram_adjust_rcv_timeout(BIO *b)
	{
#if defined(SO_RCVTIMEO)
	bio_dgram_data *data = (bio_dgram_data *)b->ptr;
	int sz = sizeof(int);

	/* Is a timer active? */
	if (data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0)
		{
		struct timeval timenow, timeleft;

		/* Read current socket timeout */
#ifdef OPENSSL_SYS_WINDOWS
		int timeout;
		if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
					   (void*)&timeout, &sz) < 0)
			{ perror("getsockopt"); }
		else
			{
			data->socket_timeout.tv_sec = timeout / 1000;
			data->socket_timeout.tv_usec = (timeout % 1000) * 1000;
			}
#else
		if ( getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, 
						&(data->socket_timeout), (void *)&sz) < 0)
			{ perror("getsockopt"); }
#endif

		/* Get current time */
		get_current_time(&timenow);

		/* Calculate time left until timer expires */
		memcpy(&timeleft, &(data->next_timeout), sizeof(struct timeval));
		timeleft.tv_sec -= timenow.tv_sec;
		timeleft.tv_usec -= timenow.tv_usec;
		if (timeleft.tv_usec < 0)
			{
			timeleft.tv_sec--;
			timeleft.tv_usec += 1000000;
			}

		if (timeleft.tv_sec < 0)
			{
			timeleft.tv_sec = 0;
			timeleft.tv_usec = 1;
			}

		/* Adjust socket timeout if next handhake message timer
		 * will expire earlier.
		 */
		if ((data->socket_timeout.tv_sec == 0 && data->socket_timeout.tv_usec == 0) ||
			(data->socket_timeout.tv_sec > timeleft.tv_sec) ||
			(data->socket_timeout.tv_sec == timeleft.tv_sec &&
			 data->socket_timeout.tv_usec >= timeleft.tv_usec))
			{
#ifdef OPENSSL_SYS_WINDOWS
			timeout = timeleft.tv_sec * 1000 + timeleft.tv_usec / 1000;
			if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
						   (void*)&timeout, sizeof(timeout)) < 0)
				{ perror("setsockopt"); }
#else
			if ( setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, &timeleft,
							sizeof(struct timeval)) < 0)
				{ perror("setsockopt"); }
#endif
			}
		}
#endif
	}

static void dgram_reset_rcv_timeout(BIO *b)
	{
#if defined(SO_RCVTIMEO)
	bio_dgram_data *data = (bio_dgram_data *)b->ptr;

	/* Is a timer active? */
	if (data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0)
		{
#ifdef OPENSSL_SYS_WINDOWS
		int timeout = data->socket_timeout.tv_sec * 1000 +
					  data->socket_timeout.tv_usec / 1000;
		if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,
					   (void*)&timeout, sizeof(timeout)) < 0)
			{ perror("setsockopt"); }
#else
		if ( setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, &(data->socket_timeout),
						sizeof(struct timeval)) < 0)
			{ perror("setsockopt"); }
#endif
		}
#endif
	}

d174 2
a175 16
	struct	{
	/*
	 * See commentary in b_sock.c. <appro>
	 */
	union	{ size_t s; int i; } len;
	union	{
		struct sockaddr sa;
		struct sockaddr_in sa_in;
#if OPENSSL_USE_IPV6
		struct sockaddr_in6 sa_in6;
#endif
		} peer;
	} sa;

	sa.len.s=0;
	sa.len.i=sizeof(sa.peer);
d180 7
a186 9
		memset(&sa.peer, 0x00, sizeof(sa.peer));
		dgram_adjust_rcv_timeout(b);
		ret=recvfrom(b->num,out,outl,0,&sa.peer.sa,(void *)&sa.len);
		if (sizeof(sa.len.i)!=sizeof(sa.len.s) && sa.len.i==0)
			{
			OPENSSL_assert(sa.len.s<=sizeof(sa.peer));
			sa.len.i = (int)sa.len.s;
			}
		dgram_reset_rcv_timeout(b);
d188 2
a189 2
		if ( ! data->connected  && ret >= 0)
			BIO_ctrl(b, BIO_CTRL_DGRAM_SET_PEER, 0, &sa.peer);
d192 1
a192 1
		if (ret < 0)
d210 3
a212 12
	if ( data->connected )
		ret=writesocket(b->num,in,inl);
	else
		{
		int peerlen = sizeof(data->peer);

		if (data->peer.sa.sa_family == AF_INET)
			peerlen = sizeof(data->peer.sa_in);
#if OPENSSL_USE_IVP6
		else if (data->peer.sa.sa_family == AF_INET6)
			peerlen = sizeof(data->peer.sa_in6);
#endif
d214 1
a214 1
		ret=sendto(b->num, (char *)in, inl, 0, &data->peer.sa, peerlen);
d216 1
a216 1
		ret=sendto(b->num, in, inl, 0, &data->peer.sa, peerlen);
a217 1
		}
d222 1
a222 1
		if (BIO_dgram_should_retry(ret))
a242 1
#if defined(IP_MTU_DISCOVER) || defined(IP_MTU)
a244 11
#endif
#ifdef OPENSSL_SYS_LINUX
	socklen_t addr_len;
	union	{
		struct sockaddr	sa;
		struct sockaddr_in s4;
#if OPENSSL_USE_IPV6
		struct sockaddr_in6 s6;
#endif
		} addr;
#endif
d297 1
a297 14
			switch (to->sa_family)
				{
				case AF_INET:
					memcpy(&data->peer,to,sizeof(data->peer.sa_in));
					break;
#if OPENSSL_USE_IPV6
				case AF_INET6:
					memcpy(&data->peer,to,sizeof(data->peer.sa_in6));
					break;
#endif
				default:
					memcpy(&data->peer,to,sizeof(data->peer.sa));
					break;
				}
d303 1
d305 4
a308 31
#ifdef OPENSSL_SYS_LINUX
		addr_len = (socklen_t)sizeof(addr);
		memset((void *)&addr, 0, sizeof(addr));
		if (getsockname(b->num, &addr.sa, &addr_len) < 0)
			{
			ret = 0;
			break;
			}
		sockopt_len = sizeof(sockopt_val);
		switch (addr.sa.sa_family)
			{
		case AF_INET:
			sockopt_val = IP_PMTUDISC_DO;
			if ((ret = setsockopt(b->num, IPPROTO_IP, IP_MTU_DISCOVER,
				&sockopt_val, sizeof(sockopt_val))) < 0)
				perror("setsockopt");
			break;
#if OPENSSL_USE_IPV6 && defined(IPV6_MTU_DISCOVER)
		case AF_INET6:
			sockopt_val = IPV6_PMTUDISC_DO;
			if ((ret = setsockopt(b->num, IPPROTO_IPV6, IPV6_MTU_DISCOVER,
				&sockopt_val, sizeof(sockopt_val))) < 0)
				perror("setsockopt");
			break;
#endif
		default:
			ret = -1;
			break;
			}
		ret = -1;
#else
d312 5
a316 4
#ifdef OPENSSL_SYS_LINUX
		addr_len = (socklen_t)sizeof(addr);
		memset((void *)&addr, 0, sizeof(addr));
		if (getsockname(b->num, &addr.sa, &addr_len) < 0)
d318 2
a319 41
			ret = 0;
			break;
			}
		sockopt_len = sizeof(sockopt_val);
		switch (addr.sa.sa_family)
			{
		case AF_INET:
			if ((ret = getsockopt(b->num, IPPROTO_IP, IP_MTU, (void *)&sockopt_val,
				&sockopt_len)) < 0 || sockopt_val < 0)
				{
				ret = 0;
				}
			else
				{
				/* we assume that the transport protocol is UDP and no
				 * IP options are used.
				 */
				data->mtu = sockopt_val - 8 - 20;
				ret = data->mtu;
				}
			break;
#if OPENSSL_USE_IPV6 && defined(IPV6_MTU)
		case AF_INET6:
			if ((ret = getsockopt(b->num, IPPROTO_IPV6, IPV6_MTU, (void *)&sockopt_val,
				&sockopt_len)) < 0 || sockopt_val < 0)
				{
				ret = 0;
				}
			else
				{
				/* we assume that the transport protocol is UDP and no
				 * IPV6 options are used.
				 */
				data->mtu = sockopt_val - 8 - 40;
				ret = data->mtu;
				}
			break;
#endif
		default:
			ret = 0;
			break;
a320 3
#else
		ret = 0;
#endif
d335 1
a335 14
			switch (to->sa_family)
				{
				case AF_INET:
					memcpy(&data->peer,to,sizeof(data->peer.sa_in));
					break;
#if OPENSSL_USE_IPV6
				case AF_INET6:
					memcpy(&data->peer,to,sizeof(data->peer.sa_in6));
					break;
#endif
				default:
					memcpy(&data->peer,to,sizeof(data->peer.sa));
					break;
				}
d340 1
a340 1
			memset(&(data->peer), 0x00, sizeof(data->peer));
d343 5
a347 39
	case BIO_CTRL_DGRAM_GET_PEER:
		switch (data->peer.sa.sa_family)
			{
			case AF_INET:
				ret=sizeof(data->peer.sa_in);
				break;
#if OPENSSL_USE_IPV6
			case AF_INET6:
				ret=sizeof(data->peer.sa_in6);
				break;
#endif
			default:
				ret=sizeof(data->peer.sa);
				break;
			}
		if (num==0 || num>ret)
			num=ret;
		memcpy(ptr,&data->peer,(ret=num));
		break;
	case BIO_CTRL_DGRAM_SET_PEER:
		to = (struct sockaddr *) ptr;
		switch (to->sa_family)
			{
			case AF_INET:
				memcpy(&data->peer,to,sizeof(data->peer.sa_in));
				break;
#if OPENSSL_USE_IPV6
			case AF_INET6:
				memcpy(&data->peer,to,sizeof(data->peer.sa_in6));
				break;
#endif
			default:
				memcpy(&data->peer,to,sizeof(data->peer.sa));
				break;
			}
		break;
	case BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT:
		memcpy(&(data->next_timeout), ptr, sizeof(struct timeval));
		break;
d510 4
d536 5
a548 17

static void get_current_time(struct timeval *t)
	{
#ifdef OPENSSL_SYS_WIN32
	struct _timeb tb;
	_ftime(&tb);
	t->tv_sec = (long)tb.time;
	t->tv_usec = (long)tb.millitm * 1000;
#elif defined(OPENSSL_SYS_VMS)
	struct timeb tb;
	ftime(&tb);
	t->tv_sec = (long)tb.time;
	t->tv_usec = (long)tb.millitm * 1000;
#else
	gettimeofday(t, NULL);
#endif
	}
@


1.1.1.4
log
@import OpenSSL 1.0.0e
@
text
@d60 1
a67 1
#ifndef OPENSSL_NO_DGRAM
d311 1
a324 2

		dgram_reset_rcv_timeout(b);
d343 1
a343 1
#if OPENSSL_USE_IPV6
d748 3
a750 7
#if defined(OPENSSL_SYS_WINDOWS)
	/* If the socket return value (i) is -1
	 * and err is unexpectedly 0 at this point,
	 * the error code was overwritten by
	 * another system call before this error
	 * handling is called.
	 */
d813 1
a830 2

#endif
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@a72 7
#ifndef OPENSSL_NO_SCTP
#include <netinet/sctp.h>
#include <fcntl.h>
#define OPENSSL_SCTP_DATA_CHUNK_TYPE            0x00
#define OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE 0xc0
#endif

a90 12
#ifndef OPENSSL_NO_SCTP
static int dgram_sctp_write(BIO *h, const char *buf, int num);
static int dgram_sctp_read(BIO *h, char *buf, int size);
static int dgram_sctp_puts(BIO *h, const char *str);
static long dgram_sctp_ctrl(BIO *h, int cmd, long arg1, void *arg2);
static int dgram_sctp_new(BIO *h);
static int dgram_sctp_free(BIO *data);
#ifdef SCTP_AUTHENTICATION_EVENT
static void dgram_sctp_handle_auth_free_key_event(BIO *b, union sctp_notification *snp);
#endif
#endif

a108 16
#ifndef OPENSSL_NO_SCTP
static BIO_METHOD methods_dgramp_sctp=
	{
	BIO_TYPE_DGRAM_SCTP,
	"datagram sctp socket",
	dgram_sctp_write,
	dgram_sctp_read,
	dgram_sctp_puts,
	NULL, /* dgram_gets, */
	dgram_sctp_ctrl,
	dgram_sctp_new,
	dgram_sctp_free,
	NULL,
	};
#endif

a124 34
#ifndef OPENSSL_NO_SCTP
typedef struct bio_dgram_sctp_save_message_st
	{
        BIO *bio;
        char *data;
        int length;
	} bio_dgram_sctp_save_message;

typedef struct bio_dgram_sctp_data_st
	{
	union {
		struct sockaddr sa;
		struct sockaddr_in sa_in;
#if OPENSSL_USE_IPV6
		struct sockaddr_in6 sa_in6;
#endif
	} peer;
	unsigned int connected;
	unsigned int _errno;
	unsigned int mtu;
	struct bio_dgram_sctp_sndinfo sndinfo;
	struct bio_dgram_sctp_rcvinfo rcvinfo;
	struct bio_dgram_sctp_prinfo prinfo;
	void (*handle_notifications)(BIO *bio, void *context, void *buf);
	void* notification_context;
	int in_handshake;
	int ccs_rcvd;
	int ccs_sent;
	int save_shutdown;
	int peer_auth_tested;
	bio_dgram_sctp_save_message saved_message;
	} bio_dgram_sctp_data;
#endif

a549 21
	case BIO_CTRL_DGRAM_GET_FALLBACK_MTU:
		switch (data->peer.sa.sa_family)
			{
			case AF_INET:
				ret = 576 - 20 - 8;
				break;
#if OPENSSL_USE_IPV6
			case AF_INET6:
#ifdef IN6_IS_ADDR_V4MAPPED
				if (IN6_IS_ADDR_V4MAPPED(&data->peer.sa_in6.sin6_addr))
					ret = 576 - 20 - 8;
				else
#endif
					ret = 1280 - 40 - 8;
				break;
#endif
			default:
				ret = 576 - 20 - 8;
				break;
			}
		break;
a739 906

#ifndef OPENSSL_NO_SCTP
BIO_METHOD *BIO_s_datagram_sctp(void)
	{
	return(&methods_dgramp_sctp);
	}

BIO *BIO_new_dgram_sctp(int fd, int close_flag)
	{
	BIO *bio;
	int ret, optval = 20000;
	int auth_data = 0, auth_forward = 0;
	unsigned char *p;
	struct sctp_authchunk auth;
	struct sctp_authchunks *authchunks;
	socklen_t sockopt_len;
#ifdef SCTP_AUTHENTICATION_EVENT
#ifdef SCTP_EVENT
	struct sctp_event event;
#else
	struct sctp_event_subscribe event;
#endif
#endif

	bio=BIO_new(BIO_s_datagram_sctp());
	if (bio == NULL) return(NULL);
	BIO_set_fd(bio,fd,close_flag);

	/* Activate SCTP-AUTH for DATA and FORWARD-TSN chunks */
	auth.sauth_chunk = OPENSSL_SCTP_DATA_CHUNK_TYPE;
	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_AUTH_CHUNK, &auth, sizeof(struct sctp_authchunk));
	OPENSSL_assert(ret >= 0);
	auth.sauth_chunk = OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE;
	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_AUTH_CHUNK, &auth, sizeof(struct sctp_authchunk));
	OPENSSL_assert(ret >= 0);

	/* Test if activation was successful. When using accept(),
	 * SCTP-AUTH has to be activated for the listening socket
	 * already, otherwise the connected socket won't use it. */
	sockopt_len = (socklen_t)(sizeof(sctp_assoc_t) + 256 * sizeof(uint8_t));
	authchunks = OPENSSL_malloc(sockopt_len);
	memset(authchunks, 0, sizeof(sockopt_len));
	ret = getsockopt(fd, IPPROTO_SCTP, SCTP_LOCAL_AUTH_CHUNKS, authchunks, &sockopt_len);
	OPENSSL_assert(ret >= 0);
	
	for (p = (unsigned char*) authchunks + sizeof(sctp_assoc_t);
	     p < (unsigned char*) authchunks + sockopt_len;
	     p += sizeof(uint8_t))
		{
		if (*p == OPENSSL_SCTP_DATA_CHUNK_TYPE) auth_data = 1;
		if (*p == OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE) auth_forward = 1;
		}
		
	OPENSSL_free(authchunks);

	OPENSSL_assert(auth_data);
	OPENSSL_assert(auth_forward);

#ifdef SCTP_AUTHENTICATION_EVENT
#ifdef SCTP_EVENT
	memset(&event, 0, sizeof(struct sctp_event));
	event.se_assoc_id = 0;
	event.se_type = SCTP_AUTHENTICATION_EVENT;
	event.se_on = 1;
	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(struct sctp_event));
	OPENSSL_assert(ret >= 0);
#else
	sockopt_len = (socklen_t) sizeof(struct sctp_event_subscribe);
	ret = getsockopt(fd, IPPROTO_SCTP, SCTP_EVENTS, &event, &sockopt_len);
	OPENSSL_assert(ret >= 0);

	event.sctp_authentication_event = 1;

	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_EVENTS, &event, sizeof(struct sctp_event_subscribe));
	OPENSSL_assert(ret >= 0);
#endif
#endif

	/* Disable partial delivery by setting the min size
	 * larger than the max record size of 2^14 + 2048 + 13
	 */
	ret = setsockopt(fd, IPPROTO_SCTP, SCTP_PARTIAL_DELIVERY_POINT, &optval, sizeof(optval));
	OPENSSL_assert(ret >= 0);

	return(bio);
	}

int BIO_dgram_is_sctp(BIO *bio)
	{
	return (BIO_method_type(bio) == BIO_TYPE_DGRAM_SCTP);
	}

static int dgram_sctp_new(BIO *bi)
	{
	bio_dgram_sctp_data *data = NULL;

	bi->init=0;
	bi->num=0;
	data = OPENSSL_malloc(sizeof(bio_dgram_sctp_data));
	if (data == NULL)
		return 0;
	memset(data, 0x00, sizeof(bio_dgram_sctp_data));
#ifdef SCTP_PR_SCTP_NONE
	data->prinfo.pr_policy = SCTP_PR_SCTP_NONE;
#endif
    bi->ptr = data;

	bi->flags=0;
	return(1);
	}

static int dgram_sctp_free(BIO *a)
	{
	bio_dgram_sctp_data *data;

	if (a == NULL) return(0);
	if ( ! dgram_clear(a))
		return 0;

	data = (bio_dgram_sctp_data *)a->ptr;
	if(data != NULL) OPENSSL_free(data);

	return(1);
	}

#ifdef SCTP_AUTHENTICATION_EVENT
void dgram_sctp_handle_auth_free_key_event(BIO *b, union sctp_notification *snp)
	{
	unsigned int sockopt_len = 0;
	int ret;
	struct sctp_authkey_event* authkeyevent = &snp->sn_auth_event;

	if (authkeyevent->auth_indication == SCTP_AUTH_FREE_KEY)
		{
		struct sctp_authkeyid authkeyid;

		/* delete key */
		authkeyid.scact_keynumber = authkeyevent->auth_keynumber;
		sockopt_len = sizeof(struct sctp_authkeyid);
		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_DELETE_KEY,
		      &authkeyid, sockopt_len);
		}
	}
#endif

static int dgram_sctp_read(BIO *b, char *out, int outl)
	{
	int ret = 0, n = 0, i, optval;
	socklen_t optlen;
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *)b->ptr;
	union sctp_notification *snp;
	struct msghdr msg;
	struct iovec iov;
	struct cmsghdr *cmsg;
	char cmsgbuf[512];

	if (out != NULL)
		{
		clear_socket_error();

		do
			{
			memset(&data->rcvinfo, 0x00, sizeof(struct bio_dgram_sctp_rcvinfo));
			iov.iov_base = out;
			iov.iov_len = outl;
			msg.msg_name = NULL;
			msg.msg_namelen = 0;
			msg.msg_iov = &iov;
			msg.msg_iovlen = 1;
			msg.msg_control = cmsgbuf;
			msg.msg_controllen = 512;
			msg.msg_flags = 0;
			n = recvmsg(b->num, &msg, 0);

			if (msg.msg_controllen > 0)
				{
				for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg))
					{
					if (cmsg->cmsg_level != IPPROTO_SCTP)
						continue;
#ifdef SCTP_RCVINFO
					if (cmsg->cmsg_type == SCTP_RCVINFO)
						{
						struct sctp_rcvinfo *rcvinfo;

						rcvinfo = (struct sctp_rcvinfo *)CMSG_DATA(cmsg);
						data->rcvinfo.rcv_sid = rcvinfo->rcv_sid;
						data->rcvinfo.rcv_ssn = rcvinfo->rcv_ssn;
						data->rcvinfo.rcv_flags = rcvinfo->rcv_flags;
						data->rcvinfo.rcv_ppid = rcvinfo->rcv_ppid;
						data->rcvinfo.rcv_tsn = rcvinfo->rcv_tsn;
						data->rcvinfo.rcv_cumtsn = rcvinfo->rcv_cumtsn;
						data->rcvinfo.rcv_context = rcvinfo->rcv_context;
						}
#endif
#ifdef SCTP_SNDRCV
					if (cmsg->cmsg_type == SCTP_SNDRCV)
						{
						struct sctp_sndrcvinfo *sndrcvinfo;

						sndrcvinfo = (struct sctp_sndrcvinfo *)CMSG_DATA(cmsg);
						data->rcvinfo.rcv_sid = sndrcvinfo->sinfo_stream;
						data->rcvinfo.rcv_ssn = sndrcvinfo->sinfo_ssn;
						data->rcvinfo.rcv_flags = sndrcvinfo->sinfo_flags;
						data->rcvinfo.rcv_ppid = sndrcvinfo->sinfo_ppid;
						data->rcvinfo.rcv_tsn = sndrcvinfo->sinfo_tsn;
						data->rcvinfo.rcv_cumtsn = sndrcvinfo->sinfo_cumtsn;
						data->rcvinfo.rcv_context = sndrcvinfo->sinfo_context;
						}
#endif
					}
				}

			if (n <= 0)
				{
				if (n < 0)
					ret = n;
				break;
				}

			if (msg.msg_flags & MSG_NOTIFICATION)
				{
				snp = (union sctp_notification*) out;
				if (snp->sn_header.sn_type == SCTP_SENDER_DRY_EVENT)
					{
#ifdef SCTP_EVENT
					struct sctp_event event;
#else
					struct sctp_event_subscribe event;
					socklen_t eventsize;
#endif
					/* If a message has been delayed until the socket
					 * is dry, it can be sent now.
					 */
					if (data->saved_message.length > 0)
						{
						dgram_sctp_write(data->saved_message.bio, data->saved_message.data,
						                 data->saved_message.length);
						OPENSSL_free(data->saved_message.data);
						data->saved_message.length = 0;
						}

					/* disable sender dry event */
#ifdef SCTP_EVENT
					memset(&event, 0, sizeof(struct sctp_event));
					event.se_assoc_id = 0;
					event.se_type = SCTP_SENDER_DRY_EVENT;
					event.se_on = 0;
					i = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(struct sctp_event));
					OPENSSL_assert(i >= 0);
#else
					eventsize = sizeof(struct sctp_event_subscribe);
					i = getsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, &eventsize);
					OPENSSL_assert(i >= 0);

					event.sctp_sender_dry_event = 0;

					i = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, sizeof(struct sctp_event_subscribe));
					OPENSSL_assert(i >= 0);
#endif
					}

#ifdef SCTP_AUTHENTICATION_EVENT
				if (snp->sn_header.sn_type == SCTP_AUTHENTICATION_EVENT)
					dgram_sctp_handle_auth_free_key_event(b, snp);
#endif

				if (data->handle_notifications != NULL)
					data->handle_notifications(b, data->notification_context, (void*) out);

				memset(out, 0, outl);
				}
			else
				ret += n;
			}
		while ((msg.msg_flags & MSG_NOTIFICATION) && (msg.msg_flags & MSG_EOR) && (ret < outl));

		if (ret > 0 && !(msg.msg_flags & MSG_EOR))
			{
			/* Partial message read, this should never happen! */

			/* The buffer was too small, this means the peer sent
			 * a message that was larger than allowed. */
			if (ret == outl)
				return -1;

			/* Test if socket buffer can handle max record
			 * size (2^14 + 2048 + 13)
			 */
			optlen = (socklen_t) sizeof(int);
			ret = getsockopt(b->num, SOL_SOCKET, SO_RCVBUF, &optval, &optlen);
			OPENSSL_assert(ret >= 0);
			OPENSSL_assert(optval >= 18445);

			/* Test if SCTP doesn't partially deliver below
			 * max record size (2^14 + 2048 + 13)
			 */
			optlen = (socklen_t) sizeof(int);
			ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_PARTIAL_DELIVERY_POINT,
			                 &optval, &optlen);
			OPENSSL_assert(ret >= 0);
			OPENSSL_assert(optval >= 18445);

			/* Partially delivered notification??? Probably a bug.... */
			OPENSSL_assert(!(msg.msg_flags & MSG_NOTIFICATION));

			/* Everything seems ok till now, so it's most likely
			 * a message dropped by PR-SCTP.
			 */
			memset(out, 0, outl);
			BIO_set_retry_read(b);
			return -1;
			}

		BIO_clear_retry_flags(b);
		if (ret < 0)
			{
			if (BIO_dgram_should_retry(ret))
				{
				BIO_set_retry_read(b);
				data->_errno = get_last_socket_error();
				}
			}

		/* Test if peer uses SCTP-AUTH before continuing */
		if (!data->peer_auth_tested)
			{
			int ii, auth_data = 0, auth_forward = 0;
			unsigned char *p;
			struct sctp_authchunks *authchunks;

			optlen = (socklen_t)(sizeof(sctp_assoc_t) + 256 * sizeof(uint8_t));
			authchunks = OPENSSL_malloc(optlen);
			memset(authchunks, 0, sizeof(optlen));
			ii = getsockopt(b->num, IPPROTO_SCTP, SCTP_PEER_AUTH_CHUNKS, authchunks, &optlen);
			OPENSSL_assert(ii >= 0);

			for (p = (unsigned char*) authchunks + sizeof(sctp_assoc_t);
				 p < (unsigned char*) authchunks + optlen;
				 p += sizeof(uint8_t))
				{
				if (*p == OPENSSL_SCTP_DATA_CHUNK_TYPE) auth_data = 1;
				if (*p == OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE) auth_forward = 1;
				}

			OPENSSL_free(authchunks);

			if (!auth_data || !auth_forward)
				{
				BIOerr(BIO_F_DGRAM_SCTP_READ,BIO_R_CONNECT_ERROR);
				return -1;
				}

			data->peer_auth_tested = 1;
			}
		}
	return(ret);
	}

static int dgram_sctp_write(BIO *b, const char *in, int inl)
	{
	int ret;
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *)b->ptr;
	struct bio_dgram_sctp_sndinfo *sinfo = &(data->sndinfo);
	struct bio_dgram_sctp_prinfo *pinfo = &(data->prinfo);
	struct bio_dgram_sctp_sndinfo handshake_sinfo;
	struct iovec iov[1];
	struct msghdr msg;
	struct cmsghdr *cmsg;
#if defined(SCTP_SNDINFO) && defined(SCTP_PRINFO)
	char cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndinfo)) + CMSG_SPACE(sizeof(struct sctp_prinfo))];
	struct sctp_sndinfo *sndinfo;
	struct sctp_prinfo *prinfo;
#else
	char cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];
	struct sctp_sndrcvinfo *sndrcvinfo;
#endif

	clear_socket_error();

	/* If we're send anything else than application data,
	 * disable all user parameters and flags.
	 */
	if (in[0] != 23) {
		memset(&handshake_sinfo, 0x00, sizeof(struct bio_dgram_sctp_sndinfo));
#ifdef SCTP_SACK_IMMEDIATELY
		handshake_sinfo.snd_flags = SCTP_SACK_IMMEDIATELY;
#endif
		sinfo = &handshake_sinfo;
	}

	/* If we have to send a shutdown alert message and the
	 * socket is not dry yet, we have to save it and send it
	 * as soon as the socket gets dry.
	 */
	if (data->save_shutdown && !BIO_dgram_sctp_wait_for_dry(b))
	{
		data->saved_message.bio = b;
		data->saved_message.length = inl;
		data->saved_message.data = OPENSSL_malloc(inl);
		memcpy(data->saved_message.data, in, inl);
		return inl;
	}

	iov[0].iov_base = (char *)in;
	iov[0].iov_len = inl;
	msg.msg_name = NULL;
	msg.msg_namelen = 0;
	msg.msg_iov = iov;
	msg.msg_iovlen = 1;
	msg.msg_control = (caddr_t)cmsgbuf;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;
#if defined(SCTP_SNDINFO) && defined(SCTP_PRINFO)
	cmsg = (struct cmsghdr *)cmsgbuf;
	cmsg->cmsg_level = IPPROTO_SCTP;
	cmsg->cmsg_type = SCTP_SNDINFO;
	cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndinfo));
	sndinfo = (struct sctp_sndinfo *)CMSG_DATA(cmsg);
	memset(sndinfo, 0, sizeof(struct sctp_sndinfo));
	sndinfo->snd_sid = sinfo->snd_sid;
	sndinfo->snd_flags = sinfo->snd_flags;
	sndinfo->snd_ppid = sinfo->snd_ppid;
	sndinfo->snd_context = sinfo->snd_context;
	msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndinfo));

	cmsg = (struct cmsghdr *)&cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndinfo))];
	cmsg->cmsg_level = IPPROTO_SCTP;
	cmsg->cmsg_type = SCTP_PRINFO;
	cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_prinfo));
	prinfo = (struct sctp_prinfo *)CMSG_DATA(cmsg);
	memset(prinfo, 0, sizeof(struct sctp_prinfo));
	prinfo->pr_policy = pinfo->pr_policy;
	prinfo->pr_value = pinfo->pr_value;
	msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_prinfo));
#else
	cmsg = (struct cmsghdr *)cmsgbuf;
	cmsg->cmsg_level = IPPROTO_SCTP;
	cmsg->cmsg_type = SCTP_SNDRCV;
	cmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));
	sndrcvinfo = (struct sctp_sndrcvinfo *)CMSG_DATA(cmsg);
	memset(sndrcvinfo, 0, sizeof(struct sctp_sndrcvinfo));
	sndrcvinfo->sinfo_stream = sinfo->snd_sid;
	sndrcvinfo->sinfo_flags = sinfo->snd_flags;
#ifdef __FreeBSD__
	sndrcvinfo->sinfo_flags |= pinfo->pr_policy;
#endif
	sndrcvinfo->sinfo_ppid = sinfo->snd_ppid;
	sndrcvinfo->sinfo_context = sinfo->snd_context;
	sndrcvinfo->sinfo_timetolive = pinfo->pr_value;
	msg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndrcvinfo));
#endif

	ret = sendmsg(b->num, &msg, 0);

	BIO_clear_retry_flags(b);
	if (ret <= 0)
		{
		if (BIO_dgram_should_retry(ret))
			{
			BIO_set_retry_write(b);  
			data->_errno = get_last_socket_error();
			}
		}
	return(ret);
	}

static long dgram_sctp_ctrl(BIO *b, int cmd, long num, void *ptr)
	{
	long ret=1;
	bio_dgram_sctp_data *data = NULL;
	unsigned int sockopt_len = 0;
	struct sctp_authkeyid authkeyid;
	struct sctp_authkey *authkey;

	data = (bio_dgram_sctp_data *)b->ptr;

	switch (cmd)
		{
	case BIO_CTRL_DGRAM_QUERY_MTU:
		/* Set to maximum (2^14)
		 * and ignore user input to enable transport
		 * protocol fragmentation.
		 * Returns always 2^14.
		 */
		data->mtu = 16384;
		ret = data->mtu;
		break;
	case BIO_CTRL_DGRAM_SET_MTU:
		/* Set to maximum (2^14)
		 * and ignore input to enable transport
		 * protocol fragmentation.
		 * Returns always 2^14.
		 */
		data->mtu = 16384;
		ret = data->mtu;
		break;
	case BIO_CTRL_DGRAM_SET_CONNECTED:
	case BIO_CTRL_DGRAM_CONNECT:
		/* Returns always -1. */
		ret = -1;
		break;
	case BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT:
		/* SCTP doesn't need the DTLS timer
		 * Returns always 1.
		 */
		break;
	case BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE:
		if (num > 0)
			data->in_handshake = 1;
		else
			data->in_handshake = 0;

		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_NODELAY, &data->in_handshake, sizeof(int));
		break;
	case BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY:
		/* New shared key for SCTP AUTH.
		 * Returns 0 on success, -1 otherwise.
		 */

		/* Get active key */
		sockopt_len = sizeof(struct sctp_authkeyid);
		ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY, &authkeyid, &sockopt_len);
		if (ret < 0) break;

		/* Add new key */
		sockopt_len = sizeof(struct sctp_authkey) + 64 * sizeof(uint8_t);
		authkey = OPENSSL_malloc(sockopt_len);
		memset(authkey, 0x00, sockopt_len);
		authkey->sca_keynumber = authkeyid.scact_keynumber + 1;
#ifndef __FreeBSD__
		/* This field is missing in FreeBSD 8.2 and earlier,
		 * and FreeBSD 8.3 and higher work without it.
		 */
		authkey->sca_keylength = 64;
#endif
		memcpy(&authkey->sca_key[0], ptr, 64 * sizeof(uint8_t));

		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_KEY, authkey, sockopt_len);
		if (ret < 0) break;

		/* Reset active key */
		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY,
		      &authkeyid, sizeof(struct sctp_authkeyid));
		if (ret < 0) break;

		break;
	case BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY:
		/* Returns 0 on success, -1 otherwise. */

		/* Get active key */
		sockopt_len = sizeof(struct sctp_authkeyid);
		ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY, &authkeyid, &sockopt_len);
		if (ret < 0) break;

		/* Set active key */
		authkeyid.scact_keynumber = authkeyid.scact_keynumber + 1;
		ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY,
		      &authkeyid, sizeof(struct sctp_authkeyid));
		if (ret < 0) break;

		/* CCS has been sent, so remember that and fall through
		 * to check if we need to deactivate an old key
		 */
		data->ccs_sent = 1;

	case BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD:
		/* Returns 0 on success, -1 otherwise. */

		/* Has this command really been called or is this just a fall-through? */
		if (cmd == BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD)
			data->ccs_rcvd = 1;

		/* CSS has been both, received and sent, so deactivate an old key */
		if (data->ccs_rcvd == 1 && data->ccs_sent == 1)
			{
			/* Get active key */
			sockopt_len = sizeof(struct sctp_authkeyid);
			ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY, &authkeyid, &sockopt_len);
			if (ret < 0) break;

			/* Deactivate key or delete second last key if
			 * SCTP_AUTHENTICATION_EVENT is not available.
			 */
			authkeyid.scact_keynumber = authkeyid.scact_keynumber - 1;
#ifdef SCTP_AUTH_DEACTIVATE_KEY
			sockopt_len = sizeof(struct sctp_authkeyid);
			ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_DEACTIVATE_KEY,
			      &authkeyid, sockopt_len);
			if (ret < 0) break;
#endif
#ifndef SCTP_AUTHENTICATION_EVENT
			if (authkeyid.scact_keynumber > 0)
				{
				authkeyid.scact_keynumber = authkeyid.scact_keynumber - 1;
				ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_DELETE_KEY,
					  &authkeyid, sizeof(struct sctp_authkeyid));
				if (ret < 0) break;
				}
#endif

			data->ccs_rcvd = 0;
			data->ccs_sent = 0;
			}
		break;
	case BIO_CTRL_DGRAM_SCTP_GET_SNDINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_sndinfo))
			num = sizeof(struct bio_dgram_sctp_sndinfo);

		memcpy(ptr, &(data->sndinfo), num);
		ret = num;
		break;
	case BIO_CTRL_DGRAM_SCTP_SET_SNDINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_sndinfo))
			num = sizeof(struct bio_dgram_sctp_sndinfo);

		memcpy(&(data->sndinfo), ptr, num);
		break;
	case BIO_CTRL_DGRAM_SCTP_GET_RCVINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_rcvinfo))
			num = sizeof(struct bio_dgram_sctp_rcvinfo);

		memcpy(ptr, &data->rcvinfo, num);

		ret = num;
		break;
	case BIO_CTRL_DGRAM_SCTP_SET_RCVINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_rcvinfo))
			num = sizeof(struct bio_dgram_sctp_rcvinfo);

		memcpy(&(data->rcvinfo), ptr, num);
		break;
	case BIO_CTRL_DGRAM_SCTP_GET_PRINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_prinfo))
			num = sizeof(struct bio_dgram_sctp_prinfo);

		memcpy(ptr, &(data->prinfo), num);
		ret = num;
		break;
	case BIO_CTRL_DGRAM_SCTP_SET_PRINFO:
		/* Returns the size of the copied struct. */
		if (num > (long) sizeof(struct bio_dgram_sctp_prinfo))
			num = sizeof(struct bio_dgram_sctp_prinfo);

		memcpy(&(data->prinfo), ptr, num);
		break;
	case BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN:
		/* Returns always 1. */
		if (num > 0)
			data->save_shutdown = 1;
		else
			data->save_shutdown = 0;
		break;

	default:
		/* Pass to default ctrl function to
		 * process SCTP unspecific commands
		 */
		ret=dgram_ctrl(b, cmd, num, ptr);
		break;
		}
	return(ret);
	}

int BIO_dgram_sctp_notification_cb(BIO *b,
                                   void (*handle_notifications)(BIO *bio, void *context, void *buf),
                                   void *context)
	{
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *) b->ptr;

	if (handle_notifications != NULL)
		{
		data->handle_notifications = handle_notifications;
		data->notification_context = context;
		}
	else
		return -1;

	return 0;
	}

int BIO_dgram_sctp_wait_for_dry(BIO *b)
{
	int is_dry = 0;
	int n, sockflags, ret;
	union sctp_notification snp;
	struct msghdr msg;
	struct iovec iov;
#ifdef SCTP_EVENT
	struct sctp_event event;
#else
	struct sctp_event_subscribe event;
	socklen_t eventsize;
#endif
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *)b->ptr;

	/* set sender dry event */
#ifdef SCTP_EVENT
	memset(&event, 0, sizeof(struct sctp_event));
	event.se_assoc_id = 0;
	event.se_type = SCTP_SENDER_DRY_EVENT;
	event.se_on = 1;
	ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(struct sctp_event));
#else
	eventsize = sizeof(struct sctp_event_subscribe);
	ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, &eventsize);
	if (ret < 0)
		return -1;
	
	event.sctp_sender_dry_event = 1;
	
	ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, sizeof(struct sctp_event_subscribe));
#endif
	if (ret < 0)
		return -1;

	/* peek for notification */
	memset(&snp, 0x00, sizeof(union sctp_notification));
	iov.iov_base = (char *)&snp;
	iov.iov_len = sizeof(union sctp_notification);
	msg.msg_name = NULL;
	msg.msg_namelen = 0;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = NULL;
	msg.msg_controllen = 0;
	msg.msg_flags = 0;

	n = recvmsg(b->num, &msg, MSG_PEEK);
	if (n <= 0)
		{
		if ((n < 0) && (get_last_socket_error() != EAGAIN) && (get_last_socket_error() != EWOULDBLOCK))
			return -1;
		else
			return 0;
		}

	/* if we find a notification, process it and try again if necessary */
	while (msg.msg_flags & MSG_NOTIFICATION)
		{
		memset(&snp, 0x00, sizeof(union sctp_notification));
		iov.iov_base = (char *)&snp;
		iov.iov_len = sizeof(union sctp_notification);
		msg.msg_name = NULL;
		msg.msg_namelen = 0;
		msg.msg_iov = &iov;
		msg.msg_iovlen = 1;
		msg.msg_control = NULL;
		msg.msg_controllen = 0;
		msg.msg_flags = 0;

		n = recvmsg(b->num, &msg, 0);
		if (n <= 0)
			{
			if ((n < 0) && (get_last_socket_error() != EAGAIN) && (get_last_socket_error() != EWOULDBLOCK))
				return -1;
			else
				return is_dry;
			}
		
		if (snp.sn_header.sn_type == SCTP_SENDER_DRY_EVENT)
			{
			is_dry = 1;

			/* disable sender dry event */
#ifdef SCTP_EVENT
			memset(&event, 0, sizeof(struct sctp_event));
			event.se_assoc_id = 0;
			event.se_type = SCTP_SENDER_DRY_EVENT;
			event.se_on = 0;
			ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(struct sctp_event));
#else
			eventsize = (socklen_t) sizeof(struct sctp_event_subscribe);
			ret = getsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, &eventsize);
			if (ret < 0)
				return -1;

			event.sctp_sender_dry_event = 0;

			ret = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, sizeof(struct sctp_event_subscribe));
#endif
			if (ret < 0)
				return -1;
			}

#ifdef SCTP_AUTHENTICATION_EVENT
		if (snp.sn_header.sn_type == SCTP_AUTHENTICATION_EVENT)
			dgram_sctp_handle_auth_free_key_event(b, &snp);
#endif

		if (data->handle_notifications != NULL)
			data->handle_notifications(b, data->notification_context, (void*) &snp);

		/* found notification, peek again */
		memset(&snp, 0x00, sizeof(union sctp_notification));
		iov.iov_base = (char *)&snp;
		iov.iov_len = sizeof(union sctp_notification);
		msg.msg_name = NULL;
		msg.msg_namelen = 0;
		msg.msg_iov = &iov;
		msg.msg_iovlen = 1;
		msg.msg_control = NULL;
		msg.msg_controllen = 0;
		msg.msg_flags = 0;

		/* if we have seen the dry already, don't wait */
		if (is_dry)
			{
			sockflags = fcntl(b->num, F_GETFL, 0);
			fcntl(b->num, F_SETFL, O_NONBLOCK);
			}

		n = recvmsg(b->num, &msg, MSG_PEEK);

		if (is_dry)
			{
			fcntl(b->num, F_SETFL, sockflags);
			}

		if (n <= 0)
			{
			if ((n < 0) && (get_last_socket_error() != EAGAIN) && (get_last_socket_error() != EWOULDBLOCK))
				return -1;
			else
				return is_dry;
			}
		}

	/* read anything else */
	return is_dry;
}

int BIO_dgram_sctp_msg_waiting(BIO *b)
	{
	int n, sockflags;
	union sctp_notification snp;
	struct msghdr msg;
	struct iovec iov;
	bio_dgram_sctp_data *data = (bio_dgram_sctp_data *)b->ptr;

	/* Check if there are any messages waiting to be read */
	do
		{
		memset(&snp, 0x00, sizeof(union sctp_notification));
		iov.iov_base = (char *)&snp;
		iov.iov_len = sizeof(union sctp_notification);
		msg.msg_name = NULL;
		msg.msg_namelen = 0;
		msg.msg_iov = &iov;
		msg.msg_iovlen = 1;
		msg.msg_control = NULL;
		msg.msg_controllen = 0;
		msg.msg_flags = 0;

		sockflags = fcntl(b->num, F_GETFL, 0);
		fcntl(b->num, F_SETFL, O_NONBLOCK);
		n = recvmsg(b->num, &msg, MSG_PEEK);
		fcntl(b->num, F_SETFL, sockflags);

		/* if notification, process and try again */
		if (n > 0 && (msg.msg_flags & MSG_NOTIFICATION))
			{
#ifdef SCTP_AUTHENTICATION_EVENT
			if (snp.sn_header.sn_type == SCTP_AUTHENTICATION_EVENT)
				dgram_sctp_handle_auth_free_key_event(b, &snp);
#endif

			memset(&snp, 0x00, sizeof(union sctp_notification));
			iov.iov_base = (char *)&snp;
			iov.iov_len = sizeof(union sctp_notification);
			msg.msg_name = NULL;
			msg.msg_namelen = 0;
			msg.msg_iov = &iov;
			msg.msg_iovlen = 1;
			msg.msg_control = NULL;
			msg.msg_controllen = 0;
			msg.msg_flags = 0;
			n = recvmsg(b->num, &msg, 0);

			if (data->handle_notifications != NULL)
				data->handle_notifications(b, data->notification_context, (void*) &snp);
			}

		} while (n > 0 && (msg.msg_flags & MSG_NOTIFICATION));

	/* Return 1 if there is a message to be read, return 0 otherwise. */
	if (n > 0)
		return 1;
	else
		return 0;
	}

static int dgram_sctp_puts(BIO *bp, const char *str)
	{
	int n,ret;

	n=strlen(str);
	ret=dgram_sctp_write(bp,str,n);
	return(ret);
	}
#endif
@


1.1.1.6
log
@Import OpenSSL 1.0.1g
@
text
@d80 1
a80 1
#if defined(OPENSSL_SYS_LINUX) && !defined(IP_MTU)
a83 10
#if defined(__FreeBSD__) && defined(IN6_IS_ADDR_V4MAPPED)
/* Standard definition causes type-punning problems. */
#undef IN6_IS_ADDR_V4MAPPED
#define s6_addr32 __u6_addr.__u6_addr32
#define IN6_IS_ADDR_V4MAPPED(a)               \
        (((a)->s6_addr32[0] == 0) &&          \
         ((a)->s6_addr32[1] == 0) &&          \
         ((a)->s6_addr32[2] == htonl(0x0000ffff)))
#endif

d258 1
a258 1
	union { size_t s; int i; } sz = {0};
a267 2

		sz.i = sizeof(timeout);
d269 1
a269 1
					   (void*)&timeout, &sz.i) < 0)
a276 1
		sz.i = sizeof(data->socket_timeout);
a279 2
		else if (sizeof(sz.s)!=sizeof(sz.i) && sz.i==0)
			OPENSSL_assert(sz.s<=sizeof(data->socket_timeout));
d448 5
a452 4
#if defined(OPENSSL_SYS_LINUX) && (defined(IP_MTU_DISCOVER) || defined(IP_MTU))
	int sockopt_val = 0;
	socklen_t sockopt_len;	/* assume that system supporting IP_MTU is
				 * modern enough to define socklen_t */
d534 1
a534 1
#if defined(OPENSSL_SYS_LINUX) && defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DO)
d542 1
d551 1
a551 1
#if OPENSSL_USE_IPV6 && defined(IPV6_MTU_DISCOVER) && defined(IPV6_PMTUDISC_DO)
d568 1
a568 1
#if defined(OPENSSL_SYS_LINUX) && defined(IP_MTU)
d730 1
d732 1
a732 3
		union { size_t s; int i; } sz = {0};
#ifdef OPENSSL_SYS_WINDOWS
		int timeout;
a733 2

		sz.i = sizeof(timeout);
d735 1
a735 1
			(void*)&timeout, &sz.i) < 0)
d743 1
a744 1
		sz.i = sizeof(struct timeval);
d746 1
a746 1
			ptr, (void *)&sz) < 0)
a747 7
		else if (sizeof(sz.s)!=sizeof(sz.i) && sz.i==0)
			{
			OPENSSL_assert(sz.s<=sizeof(struct timeval));
			ret = (int)sz.s;
			}
		else
			ret = sz.i;
a748 1
		}
d768 1
d770 1
a770 3
		union { size_t s; int i; } sz = {0};
#ifdef OPENSSL_SYS_WINDOWS
		int timeout;
a771 2

		sz.i = sizeof(timeout);
d773 1
a773 1
			(void*)&timeout, &sz.i) < 0)
d781 1
a782 1
		sz.i = sizeof(struct timeval);
d784 1
a784 1
			ptr, (void *)&sz) < 0)
a785 7
		else if (sizeof(sz.s)!=sizeof(sz.i) && sz.i==0)
			{
			OPENSSL_assert(sz.s<=sizeof(struct timeval));
			ret = (int)sz.s;
			}
		else
			ret = sz.i;
a786 1
		}
d874 2
a875 2

	for (p = (unsigned char*) authchunks->gauth_chunks;
d958 1
d968 1
d970 1
a970 1
		      &authkeyid, sizeof(struct sctp_authkeyid));
d1167 1
a1167 1
			for (p = (unsigned char*) authchunks->gauth_chunks;
d1301 1
a1301 1
	socklen_t sockopt_len = 0;
@


