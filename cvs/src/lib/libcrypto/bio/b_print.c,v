head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.2
	OPENBSD_6_1_BASE:1.25;
locks; strict;
comment	@ * @;


1.25
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	mJUVYpkFBZ0Zv2bG;

1.24
date	2014.06.11.15.40.52;	author jsing;	state Exp;
branches;
next	1.23;
commitid	f7d4iLAPMoB9baw0;

1.23
date	2014.06.11.15.08.43;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	0qgtzi3un7XBy0V0;

1.22
date	2014.04.21.11.18.34;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.16.15.00.28;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.15.16.37.21;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.29.05.39.18;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.23.15.10.24;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.21.01.49.11;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.01.19.51.17;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.00.02.57;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.57.16;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.33;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.07;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.39;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.55;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.12.20.44.35;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.39;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.12.32;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.41.35;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.37.04;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.06.27.05.05.31;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	;


desc
@@


1.25
log
@tags as requested by miod and tedu
@
text
@/* $OpenBSD: b_print.c,v 1.24 2014/06/11 15:40:52 jsing Exp $ */

/* Theo de Raadt places this file in the public domain. */

#include <openssl/bio.h>

int
BIO_printf(BIO *bio, const char *format, ...)
{
	va_list args;
	int ret;

	va_start(args, format);
	ret = BIO_vprintf(bio, format, args);
	va_end(args);
	return (ret);
}

#ifdef HAVE_FUNOPEN
static int
_BIO_write(void *cookie, const char *buf, int nbytes)
{
	return BIO_write(cookie, buf, nbytes);
}

int
BIO_vprintf(BIO *bio, const char *format, va_list args)
{
	int ret;
	FILE *fp;

	fp = funopen(bio, NULL, &_BIO_write, NULL, NULL);
	if (fp == NULL) {
		ret = -1;
		goto fail;
	}
	ret = vfprintf(fp, format, args);
	fclose(fp);
fail:
	return (ret);
}

#else /* !HAVE_FUNOPEN */

int
BIO_vprintf(BIO *bio, const char *format, va_list args)
{
	int ret;
	char *buf = NULL;

	ret = vasprintf(&buf, format, args);
	if (buf == NULL) {
		ret = -1;
		goto fail;
	}
	BIO_write(bio, buf, ret);
	free(buf);
fail:
	return (ret);
}

#endif /* HAVE_FUNOPEN */

/*
 * BIO_snprintf and BIO_vsnprintf return -1 for overflow,
 * due to the history of this API.  Justification:
 *
 * Traditional snprintf surfaced in 4.4BSD, and returned
 * "number of bytes wanted". Solaris and Windows opted to
 * return -1.  A draft standard was written which returned -1.
 * Due to the large volume of code already using the first
 * semantics, the draft was repaired before standardization to
 * specify "number of bytes wanted" plus "-1 for character conversion
 * style errors".  Solaris adapted to this rule, but Windows stuck
 * with -1.
 *
 * Original OpenSSL comment which is full of lies:
 *
 * "In case of truncation, return -1 like traditional snprintf.
 * (Current drafts for ISO/IEC 9899 say snprintf should return
 * the number of characters that would have been written,
 * had the buffer been large enough.)"
 */
int
BIO_snprintf(char *buf, size_t n, const char *format, ...)
{
	va_list args;
	int ret;

	va_start(args, format);
	ret = vsnprintf(buf, n, format, args);
	va_end(args);

	if (ret >= n || ret == -1)
		return (-1);
	return (ret);
}

int
BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)
{
	int ret;

	ret = vsnprintf(buf, n, format, args);

	if (ret >= n || ret == -1)
		return (-1);
	return (ret);
}
@


1.24
log
@Tsk. Tsk. Someone forgot to compile test the other half.
@
text
@d1 2
a2 1
/*	$OpenBSD: b_print.c,v 1.23 2014/06/11 15:08:43 deraadt Exp $	*/
@


1.23
log
@Provide support for non-funopen systems.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: b_print.c,v 1.22 2014/04/21 11:18:34 deraadt Exp $	*/
d52 1
a52 1
		ret = -1
@


1.22
log
@Replace entire printf-like guts with calls to libc snprintf.
funopen(3) is used to interface to BIO descriptors.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a5 6
static int
_BIO_write(void *cookie, const char *buf, int nbytes)
{
	return BIO_write(cookie, buf, nbytes);
}

d18 7
d28 1
a29 1
	int ret;
d41 21
@


1.21
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d1 2
a2 68
/* crypto/bio/b_print.c */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/* disable assert() unless BIO_DEBUG has been defined */
#ifndef BIO_DEBUG
# ifndef NDEBUG
#  define NDEBUG
# endif
#endif

/*
 * Stolen from tjh's ssl/ssl_trc.c stuff.
 */
a3 10
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include <limits.h>
#include "cryptlib.h"
#ifndef NO_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <openssl/bn.h>         /* To get BN_LLONG properly defined */
d6 2
a7 88
#if defined(BN_LLONG) || defined(SIXTY_FOUR_BIT)
# ifndef HAVE_LONG_LONG
#  define HAVE_LONG_LONG 1
# endif
#endif

/***************************************************************************/

/*
 * Copyright Patrick Powell 1995
 * This code is based on code written by Patrick Powell <papowell@@astart.com>
 * It may be used for any purpose as long as this notice remains intact
 * on all source code distributions.
 */

/*
 * This code contains numerious changes and enhancements which were
 * made by lots of contributors over the last years to Patrick Powell's
 * original code:
 *
 * o Patrick Powell <papowell@@astart.com>      (1995)
 * o Brandon Long <blong@@fiction.net>          (1996, for Mutt)
 * o Thomas Roessler <roessler@@guug.de>        (1998, for Mutt)
 * o Michael Elkins <me@@cs.hmc.edu>            (1998, for Mutt)
 * o Andrew Tridgell <tridge@@samba.org>        (1998, for Samba)
 * o Luke Mewburn <lukem@@netbsd.org>           (1999, for LukemFTP)
 * o Ralf S. Engelschall <rse@@engelschall.com> (1999, for Pth)
 * o ...                                       (for OpenSSL)
 */

#ifdef HAVE_LONG_DOUBLE
#define LDOUBLE long double
#else
#define LDOUBLE double
#endif

#ifdef HAVE_LONG_LONG
# if defined(_WIN32) && !defined(__GNUC__)
# define LLONG __int64
# else
# define LLONG long long
# endif
#else
#define LLONG long
#endif

static void fmtstr(char **, char **, size_t *, size_t *, const char *,
    int, int, int);
static void fmtint(char **, char **, size_t *, size_t *, LLONG, int,
    int, int, int);
static void fmtfp(char **, char **, size_t *, size_t *, LDOUBLE,
    int, int, int);
static void doapr_outch(char **, char **, size_t *, size_t *, int);
static void _dopr(char **sbuffer, char **buffer, size_t *maxlen,
    size_t *retlen, int *truncated, const char *format, va_list args);

/* format read states */
#define DP_S_DEFAULT    0
#define DP_S_FLAGS      1
#define DP_S_MIN        2
#define DP_S_DOT        3
#define DP_S_MAX        4
#define DP_S_MOD        5
#define DP_S_CONV       6
#define DP_S_DONE       7

/* format flags - Bits */
#define DP_F_MINUS      (1 << 0)
#define DP_F_PLUS       (1 << 1)
#define DP_F_SPACE      (1 << 2)
#define DP_F_NUM        (1 << 3)
#define DP_F_ZERO       (1 << 4)
#define DP_F_UP         (1 << 5)
#define DP_F_UNSIGNED   (1 << 6)

/* conversion flags */
#define DP_C_SHORT      1
#define DP_C_LONG       2
#define DP_C_LDOUBLE    3
#define DP_C_LLONG      4

/* some handy macros */
#define char_to_int(p) (p - '0')
#define OSSL_MAX(p,q) ((p >= q) ? p : q)

static void
_dopr(char **sbuffer, char **buffer, size_t *maxlen, size_t *retlen,
    int *truncated, const char *format, va_list args)
d9 1
a9 253
	char ch;
	LLONG value;
	LDOUBLE fvalue;
	char *strvalue;
	int min;
	int max;
	int state;
	int flags;
	int cflags;
	size_t currlen;

	state = DP_S_DEFAULT;
	flags = currlen = cflags = min = 0;
	max = -1;
	ch = *format++;

	while (state != DP_S_DONE) {
		if (ch == '\0' || (buffer == NULL && currlen >= *maxlen))
			state = DP_S_DONE;

		switch (state) {
		case DP_S_DEFAULT:
			if (ch == '%')
				state = DP_S_FLAGS;
			else
				doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);
			ch = *format++;
			break;
		case DP_S_FLAGS:
			switch (ch) {
			case '-':
				flags |= DP_F_MINUS;
				ch = *format++;
				break;
			case '+':
				flags |= DP_F_PLUS;
				ch = *format++;
				break;
			case ' ':
				flags |= DP_F_SPACE;
				ch = *format++;
				break;
			case '#':
				flags |= DP_F_NUM;
				ch = *format++;
				break;
			case '0':
				flags |= DP_F_ZERO;
				ch = *format++;
				break;
			default:
				state = DP_S_MIN;
				break;
			}
			break;
		case DP_S_MIN:
			if (isdigit((unsigned char)ch)) {
				min = 10 * min + char_to_int(ch);
				ch = *format++;
			} else if (ch == '*') {
				min = va_arg(args, int);
				ch = *format++;
				state = DP_S_DOT;
			} else
				state = DP_S_DOT;
			break;
		case DP_S_DOT:
			if (ch == '.') {
				state = DP_S_MAX;
				ch = *format++;
			} else
				state = DP_S_MOD;
			break;
		case DP_S_MAX:
			if (isdigit((unsigned char)ch)) {
				if (max < 0)
					max = 0;
				max = 10 * max + char_to_int(ch);
				ch = *format++;
			} else if (ch == '*') {
				max = va_arg(args, int);
				ch = *format++;
				state = DP_S_MOD;
			} else
				state = DP_S_MOD;
			break;
		case DP_S_MOD:
			switch (ch) {
			case 'h':
				cflags = DP_C_SHORT;
				ch = *format++;
				break;
			case 'l':
				if (*format == 'l') {
					cflags = DP_C_LLONG;
					format++;
				} else
					cflags = DP_C_LONG;
				ch = *format++;
				break;
			case 'q':
				cflags = DP_C_LLONG;
				ch = *format++;
				break;
			case 'L':
				cflags = DP_C_LDOUBLE;
				ch = *format++;
				break;
			default:
				break;
			}
			state = DP_S_CONV;
			break;
		case DP_S_CONV:
			switch (ch) {
			case 'd':
			case 'i':
				switch (cflags) {
				case DP_C_SHORT:
					value = (short int)va_arg(args, int);
					break;
				case DP_C_LONG:
					value = va_arg(args, long int);
					break;
				case DP_C_LLONG:
					value = va_arg(args, LLONG);
					break;
				default:
					value = va_arg(args, int);
					break;
				}
				fmtint(sbuffer, buffer, &currlen, maxlen,
				    value, 10, min, max, flags);
				break;
			case 'X':
				flags |= DP_F_UP;
				/* FALLTHROUGH */
			case 'x':
			case 'o':
			case 'u':
				flags |= DP_F_UNSIGNED;
				switch (cflags) {
				case DP_C_SHORT:
					value = (unsigned short int)va_arg(
					    args, unsigned int);
					break;
				case DP_C_LONG:
					value = (LLONG)va_arg(args,
					    unsigned long int);
					break;
				case DP_C_LLONG:
					value = va_arg(args, unsigned LLONG);
					break;
				default:
					value = (LLONG)va_arg(args,
					    unsigned int);
					break;
				}
				fmtint(sbuffer, buffer, &currlen, maxlen, value,
				    ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),
				    min, max, flags);
				break;
			case 'f':
				if (cflags == DP_C_LDOUBLE)
					fvalue = va_arg(args, LDOUBLE);
				else
					fvalue = va_arg(args, double);
				fmtfp(sbuffer, buffer, &currlen, maxlen,
				    fvalue, min, max, flags);
				break;
			case 'E':
				flags |= DP_F_UP;
			case 'e':
				if (cflags == DP_C_LDOUBLE)
					fvalue = va_arg(args, LDOUBLE);
				else
					fvalue = va_arg(args, double);
				break;
			case 'G':
				flags |= DP_F_UP;
			case 'g':
				if (cflags == DP_C_LDOUBLE)
					fvalue = va_arg(args, LDOUBLE);
				else
					fvalue = va_arg(args, double);
				break;
			case 'c':
				doapr_outch(sbuffer, buffer, &currlen, maxlen,
				    va_arg(args, int));
				break;
			case 's':
				strvalue = va_arg(args, char *);
				if (max < 0) {
					if (buffer)
						max = INT_MAX;
					else
						max = *maxlen;
				}
				fmtstr(sbuffer, buffer, &currlen, maxlen,
				    strvalue, flags, min, max);
				break;
			case 'p':
				value = (long)va_arg(args, void *);
				fmtint(sbuffer, buffer, &currlen, maxlen,
				    value, 16, min, max, flags|DP_F_NUM);
				break;
			case 'n': /* XXX */
				if (cflags == DP_C_SHORT) {
					short int *num;
					num = va_arg(args, short int *);
					*num = currlen;
				} else if (cflags == DP_C_LONG) { /* XXX */
					long int *num;
					num = va_arg(args, long int *);
					*num = (long int) currlen;
				} else if (cflags == DP_C_LLONG) { /* XXX */
					LLONG *num;
					num = va_arg(args, LLONG *);
					*num = (LLONG) currlen;
				} else {
					int    *num;
					num = va_arg(args, int *);
					*num = currlen;
				}
				break;
			case '%':
				doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);
				break;
			case 'w':
				/* not supported yet, treat as next char */
				ch = *format++;
				break;
			default:
				/* unknown, skip */
				break;
			}
			ch = *format++;
			state = DP_S_DEFAULT;
			flags = cflags = min = 0;
			max = -1;
			break;
		case DP_S_DONE:
			break;
		default:
			break;
		}
	}
	*truncated = (currlen > *maxlen - 1);
	if (*truncated)
		currlen = *maxlen - 1;
	doapr_outch(sbuffer, buffer, &currlen, maxlen, '\0');
	*retlen = currlen - 1;
	return;
d12 2
a13 311
static void
fmtstr(char **sbuffer, char **buffer, size_t *currlen, size_t *maxlen,
    const char *value, int flags, int min, int max)
{
	int padlen, strln;
	int cnt = 0;

	if (value == 0)
		value = "<NULL>";
	for (strln = 0; value[strln]; ++strln)
		;
	padlen = min - strln;
	if (padlen < 0)
		padlen = 0;
	if (flags & DP_F_MINUS)
		padlen = -padlen;

	while ((padlen > 0) && (cnt < max)) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
		--padlen;
		++cnt;
	}
	while (*value && (cnt < max)) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, *value++);
		++cnt;
	}
	while ((padlen < 0) && (cnt < max)) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
		++padlen;
		++cnt;
	}
}

static void
fmtint(char **sbuffer, char **buffer, size_t *currlen, size_t *maxlen,
    LLONG value, int base, int min, int max, int flags)
{
	int signvalue = 0;
	const char *prefix = "";
	unsigned LLONG uvalue;
	char convert[DECIMAL_SIZE(value) + 3];
	int place = 0;
	int spadlen = 0;
	int zpadlen = 0;
	int caps = 0;

	if (max < 0)
		max = 0;
	uvalue = value;
	if (!(flags & DP_F_UNSIGNED)) {
		if (value < 0) {
			signvalue = '-';
			uvalue = -value;
		} else if (flags & DP_F_PLUS)
			signvalue = '+';
		else if (flags & DP_F_SPACE)
			signvalue = ' ';
	}
	if (flags & DP_F_NUM) {
		if (base == 8)
			prefix = "0";
		if (base == 16)
			prefix = "0x";
	}
	if (flags & DP_F_UP)
		caps = 1;
	do {
		convert[place++] = (caps ? "0123456789ABCDEF" :
		    "0123456789abcdef")[uvalue % (unsigned) base];
		uvalue = (uvalue / (unsigned) base);
	} while (uvalue && (place < (int)sizeof(convert)));
	if (place == sizeof(convert))
		place--;
	convert[place] = 0;

	zpadlen = max - place;
	spadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0) -
	    strlen(prefix);
	if (zpadlen < 0)
		zpadlen = 0;
	if (spadlen < 0)
		spadlen = 0;
	if (flags & DP_F_ZERO) {
		zpadlen = OSSL_MAX(zpadlen, spadlen);
		spadlen = 0;
	}
	if (flags & DP_F_MINUS)
		spadlen = -spadlen;

	/* spaces */
	while (spadlen > 0) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
		--spadlen;
	}

	/* sign */
	if (signvalue)
		doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);

	/* prefix */
	while (*prefix) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, *prefix);
		prefix++;
	}

	/* zeros */
	if (zpadlen > 0) {
		while (zpadlen > 0) {
			doapr_outch(sbuffer, buffer, currlen, maxlen, '0');
			--zpadlen;
		}
	}
	/* digits */
	while (place > 0)
		doapr_outch(sbuffer, buffer, currlen, maxlen, convert[--place]);

	/* left justified spaces */
	while (spadlen < 0) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
		++spadlen;
	}
	return;
}

static LDOUBLE
abs_val(LDOUBLE value)
{
	LDOUBLE result = value;
	if (value < 0)
		result = -value;
	return result;
}

static LDOUBLE
pow_10(int in_exp)
{
	LDOUBLE result = 1;
	while (in_exp) {
		result *= 10;
		in_exp--;
	}
	return result;
}

static long
roundv(LDOUBLE value)
{
	long intpart;
	intpart = (long) value;
	value = value - intpart;
	if (value >= 0.5)
		intpart++;
	return intpart;
}

static void
fmtfp(char **sbuffer, char **buffer, size_t *currlen, size_t *maxlen,
    LDOUBLE fvalue, int min, int max, int flags)
{
	int signvalue = 0;
	LDOUBLE ufvalue;
	char iconvert[20];
	char fconvert[20];
	int iplace = 0;
	int fplace = 0;
	int padlen = 0;
	int zpadlen = 0;
	int caps = 0;
	long intpart;
	long fracpart;
	long max10;

	if (max < 0)
		max = 6;
	ufvalue = abs_val(fvalue);
	if (fvalue < 0)
		signvalue = '-';
	else if (flags & DP_F_PLUS)
		signvalue = '+';
	else if (flags & DP_F_SPACE)
		signvalue = ' ';

	intpart = (long)ufvalue;

	/* sorry, we only support 9 digits past the decimal because of our
	   conversion method */
	if (max > 9)
		max = 9;

	/* we "cheat" by converting the fractional part to integer by
	   multiplying by a factor of 10 */
	max10 = roundv(pow_10(max));
	fracpart = roundv(pow_10(max) * (ufvalue - intpart));

	if (fracpart >= max10) {
		intpart++;
		fracpart -= max10;
	}

	/* convert integer part */
	do {
		iconvert[iplace++] = (caps ? "0123456789ABCDEF" :
		    "0123456789abcdef")[intpart % 10];
		intpart = (intpart / 10);
	} while (intpart && (iplace < (int)sizeof(iconvert)));
	if (iplace == sizeof iconvert)
		iplace--;
	iconvert[iplace] = 0;

	/* convert fractional part */
	do {
		fconvert[fplace++] = (caps ? "0123456789ABCDEF" :
		    "0123456789abcdef")[fracpart % 10];
		fracpart = (fracpart / 10);
	} while (fplace < max);
	if (fplace == sizeof fconvert)
		fplace--;
	fconvert[fplace] = 0;

	/* -1 for decimal point, another -1 if we are printing a sign */
	padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);
	zpadlen = max - fplace;
	if (zpadlen < 0)
		zpadlen = 0;
	if (padlen < 0)
		padlen = 0;
	if (flags & DP_F_MINUS)
		padlen = -padlen;

	if ((flags & DP_F_ZERO) && (padlen > 0)) {
		if (signvalue) {
			doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);
			--padlen;
			signvalue = 0;
		}
		while (padlen > 0) {
			doapr_outch(sbuffer, buffer, currlen, maxlen, '0');
			--padlen;
		}
	}
	while (padlen > 0) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
		--padlen;
	}
	if (signvalue)
		doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);

	while (iplace > 0)
		doapr_outch(sbuffer, buffer, currlen, maxlen, iconvert[--iplace]);

	/*
	 * Decimal point. This should probably use locale to find the correct
	 * char to print out.
	 */
	if (max > 0 || (flags & DP_F_NUM)) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, '.');

		while (fplace > 0)
			doapr_outch(sbuffer, buffer, currlen, maxlen, fconvert[--fplace]);
	}
	while (zpadlen > 0) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, '0');
		--zpadlen;
	}

	while (padlen < 0) {
		doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
		++padlen;
	}
}

static void
doapr_outch(char **sbuffer, char **buffer, size_t *currlen, size_t *maxlen,
    int c)
{
	/* If we haven't at least one buffer, someone has doe a big booboo */
	assert(*sbuffer != NULL || buffer != NULL);

	if (buffer) {
		while (*currlen >= *maxlen) {
			if (*buffer == NULL) {
				if (*maxlen == 0)
					*maxlen = 1024;
				*buffer = malloc(*maxlen);
				if (*currlen > 0) {
					assert(*sbuffer != NULL);
					memcpy(*buffer, *sbuffer, *currlen);
				}
				*sbuffer = NULL;
			} else {
				*maxlen += 1024;
				*buffer = realloc(*buffer, *maxlen);
			}
		}
		/* What to do if *buffer is NULL? */
		assert(*sbuffer != NULL || *buffer != NULL);
	}

	if (*currlen < *maxlen) {
		if (*sbuffer)
			(*sbuffer)[(*currlen)++] = (char)c;
		else
			(*buffer)[(*currlen)++] = (char)c;
	}

	return;
}

/***************************************************************************/

int BIO_printf (BIO *bio, const char *format, ...)
a18 1

a19 1

d24 2
a25 1
int BIO_vprintf (BIO *bio, const char *format, va_list args)
d27 1
d29 9
a37 20
	size_t retlen;
	char hugebuf[1024*2];	/* Was previously 10k, which is unreasonable
				   in small - stack environments, like threads
				   or DOS programs. */
	char *hugebufp = hugebuf;
	size_t hugebufsize = sizeof(hugebuf);
	char *dynbuf = NULL;
	int ignored;

	dynbuf = NULL;
	CRYPTO_push_info("doapr()");
	_dopr(&hugebufp, &dynbuf, &hugebufsize, &retlen, &ignored,
	    format, args);
	if (dynbuf) {
		ret = BIO_write(bio, dynbuf, (int)retlen);
		free(dynbuf);
	} else {
		ret = BIO_write(bio, hugebuf, (int)retlen);
	}
	CRYPTO_pop_info();
d41 20
a60 4
/* As snprintf is not available everywhere, we provide our own implementation.
 * This function has nothing to do with BIOs, but it's closely related
 * to BIO_printf, and we need *some* name prefix ...
 * (XXX  the function should be renamed, but to what?) */
d68 2
d71 2
a72 3
	ret = BIO_vsnprintf(buf, n, format, args);

	va_end(args);
d79 1
a79 2
	size_t retlen;
	int truncated;
d81 1
a81 1
	_dopr(&buf, NULL, &n, &retlen, &truncated, format, args);
d83 3
a85 8
	if (truncated)
		/* In case of truncation, return -1 like traditional snprintf.
		 * (Current drafts for ISO/IEC 9899 say snprintf should return
		 * the number of characters that would have been written,
		 * had the buffer been large enough.) */
		return -1;
	else
		return (retlen <= INT_MAX) ? (int)retlen : -1;
@


1.20
log
@More KNF.
@
text
@d709 1
a709 1
				*buffer = OPENSSL_malloc(*maxlen);
d717 1
a717 1
				*buffer = OPENSSL_realloc(*buffer, *maxlen);
d767 1
a767 1
		OPENSSL_free(dynbuf);
@


1.19
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
/* 
d339 1
a339 1
				fvalue, min, max, flags);
d359 1
a359 1
				va_arg(args, int));
d674 1
a674 1
	doapr_outch(sbuffer, buffer, currlen, maxlen, iconvert[--iplace]);
d684 1
a684 1
		doapr_outch(sbuffer, buffer, currlen, maxlen, fconvert[--fplace]);
@


1.18
log
@resolve conflicts, fix local changes
@
text
@d128 9
a136 10
static void fmtstr     (char **, char **, size_t *, size_t *,
			const char *, int, int, int);
static void fmtint     (char **, char **, size_t *, size_t *,
			LLONG, int, int, int, int);
static void fmtfp      (char **, char **, size_t *, size_t *,
			LDOUBLE, int, int, int);
static void doapr_outch (char **, char **, size_t *, size_t *, int);
static void _dopr(char **sbuffer, char **buffer,
		  size_t *maxlen, size_t *retlen, int *truncated,
		  const char *format, va_list args);
d168 248
a415 205
_dopr(
    char **sbuffer,
    char **buffer,
    size_t *maxlen,
    size_t *retlen,
    int *truncated,
    const char *format,
    va_list args)
{
    char ch;
    LLONG value;
    LDOUBLE fvalue;
    char *strvalue;
    int min;
    int max;
    int state;
    int flags;
    int cflags;
    size_t currlen;

    state = DP_S_DEFAULT;
    flags = currlen = cflags = min = 0;
    max = -1;
    ch = *format++;

    while (state != DP_S_DONE) {
        if (ch == '\0' || (buffer == NULL && currlen >= *maxlen))
            state = DP_S_DONE;

        switch (state) {
        case DP_S_DEFAULT:
            if (ch == '%')
                state = DP_S_FLAGS;
            else
                doapr_outch(sbuffer,buffer, &currlen, maxlen, ch);
            ch = *format++;
            break;
        case DP_S_FLAGS:
            switch (ch) {
            case '-':
                flags |= DP_F_MINUS;
                ch = *format++;
                break;
            case '+':
                flags |= DP_F_PLUS;
                ch = *format++;
                break;
            case ' ':
                flags |= DP_F_SPACE;
                ch = *format++;
                break;
            case '#':
                flags |= DP_F_NUM;
                ch = *format++;
                break;
            case '0':
                flags |= DP_F_ZERO;
                ch = *format++;
                break;
            default:
                state = DP_S_MIN;
                break;
            }
            break;
        case DP_S_MIN:
            if (isdigit((unsigned char)ch)) {
                min = 10 * min + char_to_int(ch);
                ch = *format++;
            } else if (ch == '*') {
                min = va_arg(args, int);
                ch = *format++;
                state = DP_S_DOT;
            } else
                state = DP_S_DOT;
            break;
        case DP_S_DOT:
            if (ch == '.') {
                state = DP_S_MAX;
                ch = *format++;
            } else
                state = DP_S_MOD;
            break;
        case DP_S_MAX:
            if (isdigit((unsigned char)ch)) {
                if (max < 0)
                    max = 0;
                max = 10 * max + char_to_int(ch);
                ch = *format++;
            } else if (ch == '*') {
                max = va_arg(args, int);
                ch = *format++;
                state = DP_S_MOD;
            } else
                state = DP_S_MOD;
            break;
        case DP_S_MOD:
            switch (ch) {
            case 'h':
                cflags = DP_C_SHORT;
                ch = *format++;
                break;
            case 'l':
                if (*format == 'l') {
                    cflags = DP_C_LLONG;
                    format++;
                } else
                    cflags = DP_C_LONG;
                ch = *format++;
                break;
            case 'q':
                cflags = DP_C_LLONG;
                ch = *format++;
                break;
            case 'L':
                cflags = DP_C_LDOUBLE;
                ch = *format++;
                break;
            default:
                break;
            }
            state = DP_S_CONV;
            break;
        case DP_S_CONV:
            switch (ch) {
            case 'd':
            case 'i':
                switch (cflags) {
                case DP_C_SHORT:
                    value = (short int)va_arg(args, int);
                    break;
                case DP_C_LONG:
                    value = va_arg(args, long int);
                    break;
                case DP_C_LLONG:
                    value = va_arg(args, LLONG);
                    break;
                default:
                    value = va_arg(args, int);
                    break;
                }
                fmtint(sbuffer, buffer, &currlen, maxlen,
                       value, 10, min, max, flags);
                break;
            case 'X':
                flags |= DP_F_UP;
                /* FALLTHROUGH */
            case 'x':
            case 'o':
            case 'u':
                flags |= DP_F_UNSIGNED;
                switch (cflags) {
                case DP_C_SHORT:
                    value = (unsigned short int)va_arg(args, unsigned int);
                    break;
                case DP_C_LONG:
                    value = (LLONG) va_arg(args,
                        unsigned long int);
                    break;
                case DP_C_LLONG:
                    value = va_arg(args, unsigned LLONG);
                    break;
                default:
                    value = (LLONG) va_arg(args,
                        unsigned int);
                    break;
                }
                fmtint(sbuffer, buffer, &currlen, maxlen, value,
                       ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),
                       min, max, flags);
                break;
            case 'f':
                if (cflags == DP_C_LDOUBLE)
                    fvalue = va_arg(args, LDOUBLE);
                else
                    fvalue = va_arg(args, double);
                fmtfp(sbuffer, buffer, &currlen, maxlen,
                      fvalue, min, max, flags);
                break;
            case 'E':
                flags |= DP_F_UP;
            case 'e':
                if (cflags == DP_C_LDOUBLE)
                    fvalue = va_arg(args, LDOUBLE);
                else
                    fvalue = va_arg(args, double);
                break;
            case 'G':
                flags |= DP_F_UP;
            case 'g':
                if (cflags == DP_C_LDOUBLE)
                    fvalue = va_arg(args, LDOUBLE);
                else
                    fvalue = va_arg(args, double);
                break;
            case 'c':
                doapr_outch(sbuffer, buffer, &currlen, maxlen,
                    va_arg(args, int));
                break;
            case 's':
                strvalue = va_arg(args, char *);
                if (max < 0) {
		    if (buffer)
			max = INT_MAX;
		    else
			max = *maxlen;
d417 7
a423 55
                fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,
                       flags, min, max);
                break;
            case 'p':
                value = (long)va_arg(args, void *);
                fmtint(sbuffer, buffer, &currlen, maxlen,
                    value, 16, min, max, flags|DP_F_NUM);
                break;
            case 'n': /* XXX */
                if (cflags == DP_C_SHORT) {
                    short int *num;
                    num = va_arg(args, short int *);
                    *num = currlen;
                } else if (cflags == DP_C_LONG) { /* XXX */
                    long int *num;
                    num = va_arg(args, long int *);
                    *num = (long int) currlen;
                } else if (cflags == DP_C_LLONG) { /* XXX */
                    LLONG *num;
                    num = va_arg(args, LLONG *);
                    *num = (LLONG) currlen;
                } else {
                    int    *num;
                    num = va_arg(args, int *);
                    *num = currlen;
                }
                break;
            case '%':
                doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);
                break;
            case 'w':
                /* not supported yet, treat as next char */
                ch = *format++;
                break;
            default:
                /* unknown, skip */
                break;
            }
            ch = *format++;
            state = DP_S_DEFAULT;
            flags = cflags = min = 0;
            max = -1;
            break;
        case DP_S_DONE:
            break;
        default:
            break;
        }
    }
    *truncated = (currlen > *maxlen - 1);
    if (*truncated)
        currlen = *maxlen - 1;
    doapr_outch(sbuffer, buffer, &currlen, maxlen, '\0');
    *retlen = currlen - 1;
    return;
d427 30
a456 37
fmtstr(
    char **sbuffer,
    char **buffer,
    size_t *currlen,
    size_t *maxlen,
    const char *value,
    int flags,
    int min,
    int max)
{
    int padlen, strln;
    int cnt = 0;

    if (value == 0)
        value = "<NULL>";
    for (strln = 0; value[strln]; ++strln)
        ;
    padlen = min - strln;
    if (padlen < 0)
        padlen = 0;
    if (flags & DP_F_MINUS)
        padlen = -padlen;

    while ((padlen > 0) && (cnt < max)) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        --padlen;
        ++cnt;
    }
    while (*value && (cnt < max)) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, *value++);
        ++cnt;
    }
    while ((padlen < 0) && (cnt < max)) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        ++padlen;
        ++cnt;
    }
d460 88
a547 94
fmtint(
    char **sbuffer,
    char **buffer,
    size_t *currlen,
    size_t *maxlen,
    LLONG value,
    int base,
    int min,
    int max,
    int flags)
{
    int signvalue = 0;
    const char *prefix = "";
    unsigned LLONG uvalue;
    char convert[DECIMAL_SIZE(value)+3];
    int place = 0;
    int spadlen = 0;
    int zpadlen = 0;
    int caps = 0;

    if (max < 0)
        max = 0;
    uvalue = value;
    if (!(flags & DP_F_UNSIGNED)) {
        if (value < 0) {
            signvalue = '-';
            uvalue = -value;
        } else if (flags & DP_F_PLUS)
            signvalue = '+';
        else if (flags & DP_F_SPACE)
            signvalue = ' ';
    }
    if (flags & DP_F_NUM) {
	if (base == 8) prefix = "0";
	if (base == 16) prefix = "0x";
    }
    if (flags & DP_F_UP)
        caps = 1;
    do {
        convert[place++] =
            (caps ? "0123456789ABCDEF" : "0123456789abcdef")
            [uvalue % (unsigned) base];
        uvalue = (uvalue / (unsigned) base);
    } while (uvalue && (place < (int)sizeof(convert)));
    if (place == sizeof(convert))
        place--;
    convert[place] = 0;

    zpadlen = max - place;
    spadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0) - strlen(prefix);
    if (zpadlen < 0)
        zpadlen = 0;
    if (spadlen < 0)
        spadlen = 0;
    if (flags & DP_F_ZERO) {
        zpadlen = OSSL_MAX(zpadlen, spadlen);
        spadlen = 0;
    }
    if (flags & DP_F_MINUS)
        spadlen = -spadlen;

    /* spaces */
    while (spadlen > 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        --spadlen;
    }

    /* sign */
    if (signvalue)
        doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);

    /* prefix */
    while (*prefix) {
	doapr_outch(sbuffer, buffer, currlen, maxlen, *prefix);
	prefix++;
    }

    /* zeros */
    if (zpadlen > 0) {
        while (zpadlen > 0) {
            doapr_outch(sbuffer, buffer, currlen, maxlen, '0');
            --zpadlen;
        }
    }
    /* digits */
    while (place > 0)
        doapr_outch(sbuffer, buffer, currlen, maxlen, convert[--place]);

    /* left justified spaces */
    while (spadlen < 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        ++spadlen;
    }
    return;
d553 4
a556 4
    LDOUBLE result = value;
    if (value < 0)
        result = -value;
    return result;
d562 6
a567 6
    LDOUBLE result = 1;
    while (in_exp) {
        result *= 10;
        in_exp--;
    }
    return result;
d573 6
a578 6
    long intpart;
    intpart = (long) value;
    value = value - intpart;
    if (value >= 0.5)
        intpart++;
    return intpart;
d582 113
a694 122
fmtfp(
    char **sbuffer,
    char **buffer,
    size_t *currlen,
    size_t *maxlen,
    LDOUBLE fvalue,
    int min,
    int max,
    int flags)
{
    int signvalue = 0;
    LDOUBLE ufvalue;
    char iconvert[20];
    char fconvert[20];
    int iplace = 0;
    int fplace = 0;
    int padlen = 0;
    int zpadlen = 0;
    int caps = 0;
    long intpart;
    long fracpart;
    long max10;

    if (max < 0)
        max = 6;
    ufvalue = abs_val(fvalue);
    if (fvalue < 0)
        signvalue = '-';
    else if (flags & DP_F_PLUS)
        signvalue = '+';
    else if (flags & DP_F_SPACE)
        signvalue = ' ';

    intpart = (long)ufvalue;

    /* sorry, we only support 9 digits past the decimal because of our
       conversion method */
    if (max > 9)
        max = 9;

    /* we "cheat" by converting the fractional part to integer by
       multiplying by a factor of 10 */
    max10 = roundv(pow_10(max));
    fracpart = roundv(pow_10(max) * (ufvalue - intpart));

    if (fracpart >= max10) {
        intpart++;
        fracpart -= max10;
    }

    /* convert integer part */
    do {
        iconvert[iplace++] =
            (caps ? "0123456789ABCDEF"
              : "0123456789abcdef")[intpart % 10];
        intpart = (intpart / 10);
    } while (intpart && (iplace < (int)sizeof(iconvert)));
    if (iplace == sizeof iconvert)
        iplace--;
    iconvert[iplace] = 0;

    /* convert fractional part */
    do {
        fconvert[fplace++] =
            (caps ? "0123456789ABCDEF"
              : "0123456789abcdef")[fracpart % 10];
        fracpart = (fracpart / 10);
    } while (fplace < max);
    if (fplace == sizeof fconvert)
        fplace--;
    fconvert[fplace] = 0;

    /* -1 for decimal point, another -1 if we are printing a sign */
    padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);
    zpadlen = max - fplace;
    if (zpadlen < 0)
        zpadlen = 0;
    if (padlen < 0)
        padlen = 0;
    if (flags & DP_F_MINUS)
        padlen = -padlen;

    if ((flags & DP_F_ZERO) && (padlen > 0)) {
        if (signvalue) {
            doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);
            --padlen;
            signvalue = 0;
        }
        while (padlen > 0) {
            doapr_outch(sbuffer, buffer, currlen, maxlen, '0');
            --padlen;
        }
    }
    while (padlen > 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        --padlen;
    }
    if (signvalue)
        doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);

    while (iplace > 0)
        doapr_outch(sbuffer, buffer, currlen, maxlen, iconvert[--iplace]);

    /*
     * Decimal point. This should probably use locale to find the correct
     * char to print out.
     */
    if (max > 0 || (flags & DP_F_NUM)) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, '.');

        while (fplace > 0)
            doapr_outch(sbuffer, buffer, currlen, maxlen, fconvert[--fplace]);
    }
    while (zpadlen > 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, '0');
        --zpadlen;
    }

    while (padlen < 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        ++padlen;
    }
d698 1
a698 5
doapr_outch(
    char **sbuffer,
    char **buffer,
    size_t *currlen,
    size_t *maxlen,
d701 2
a702 2
    /* If we haven't at least one buffer, someone has doe a big booboo */
    assert(*sbuffer != NULL || buffer != NULL);
d704 15
a718 9
    if (buffer) {
	while (*currlen >= *maxlen) {
	    if (*buffer == NULL) {
		if (*maxlen == 0)
		    *maxlen = 1024;
		*buffer = OPENSSL_malloc(*maxlen);
		if (*currlen > 0) {
		    assert(*sbuffer != NULL);
		    memcpy(*buffer, *sbuffer, *currlen);
d720 10
a729 16
		*sbuffer = NULL;
	    } else {
		*maxlen += 1024;
		*buffer = OPENSSL_realloc(*buffer, *maxlen);
	    }
	}
	/* What to do if *buffer is NULL? */
	assert(*sbuffer != NULL || *buffer != NULL);
    }

    if (*currlen < *maxlen) {
	if (*sbuffer)
	    (*sbuffer)[(*currlen)++] = (char)c;
	else
	    (*buffer)[(*currlen)++] = (char)c;
    }
d731 1
a731 1
    return;
d737 1
a737 1
	{
d746 2
a747 2
	return(ret);
	}
d750 1
a750 1
	{
d754 1
a754 1
				   in small-stack environments, like threads
d763 4
a766 5
	_dopr(&hugebufp, &dynbuf, &hugebufsize,
		&retlen, &ignored, format, args);
	if (dynbuf)
		{
		ret=BIO_write(bio, dynbuf, (int)retlen);
d768 3
a770 5
		}
	else
		{
		ret=BIO_write(bio, hugebuf, (int)retlen);
		}
d772 2
a773 2
	return(ret);
	}
d779 3
a781 2
int BIO_snprintf(char *buf, size_t n, const char *format, ...)
	{
d790 2
a791 2
	return(ret);
	}
d793 3
a795 2
int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)
	{
d809 1
a809 1
	}
@


1.17
log
@resolve conflicts
@
text
@d118 2
a119 2
#if HAVE_LONG_LONG
# if defined(OPENSSL_SYS_WIN32) && !defined(__GNUC__)
a810 1
 * In case of overflow or error, this returns -1.
d835 1
a835 1
		/* In case of truncation, return -1 unlike traditional snprintf.
d838 1
a838 1
		 * had the buffer been large enough, as it did historically.) */
@


1.16
log
@resolve conflicts
@
text
@d82 1
a82 1
#ifdef BN_LLONG
d120 1
a120 1
# define LLONG _int64
d485 1
a485 1
    char *prefix = "";
d516 2
a517 2
    } while (uvalue && (place < sizeof convert));
    if (place == sizeof convert)
d622 1
d643 2
a644 1
    fracpart = roundv((pow_10(max)) * (ufvalue - intpart));
d646 1
a646 1
    if (fracpart >= (long)pow_10(max)) {
d648 1
a648 1
        fracpart -= (long)pow_10(max);
d657 1
a657 1
    } while (intpart && (iplace < sizeof iconvert));
@


1.15
log
@resolve conflicts
@
text
@d579 1
a579 1
pow10(int in_exp)
d642 1
a642 1
    fracpart = roundv((pow10(max)) * (ufvalue - intpart));
d644 1
a644 1
    if (fracpart >= (long)pow10(max)) {
d646 1
a646 1
        fracpart -= (long)pow10(max);
@


1.14
log
@fix lies about snprintf
@
text
@d644 1
a644 1
    if (fracpart >= pow10(max)) {
@


1.13
log
@merge 0.9.7d
@
text
@d809 1
d834 1
a834 1
		/* In case of truncation, return -1 like traditional snprintf.
d837 1
a837 1
		 * had the buffer been large enough.) */
@


1.12
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d579 1
a579 1
pow10(int exp)
d582 1
a582 1
    while (exp) {
d584 1
a584 1
        exp--;
d655 2
a656 2
    } while (intpart && (iplace < sizeof iplace));
    if (iplace == sizeof iplace)
d667 1
a667 1
    if (fplace == sizeof fplace)
@


1.11
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d839 1
a839 1
		return (retlen <= INT_MAX) ? retlen : -1;
@


1.10
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d381 1
a381 1
                    value, 16, min, max, flags);
d485 1
d487 1
a487 1
    char convert[20];
d505 4
d516 2
a517 2
    } while (uvalue && (place < 20));
    if (place == 20)
d522 1
a522 1
    spadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0);
d544 6
d655 2
a656 2
    } while (intpart && (iplace < 20));
    if (iplace == 20)
d667 1
a667 1
    if (fplace == 20)
d706 1
a706 1
    if (max > 0) {
@


1.9
log
@Merge openssl-0.9.7-stable-SNAP-20020519
@
text
@d112 1
a112 1
#if HAVE_LONG_DOUBLE
@


1.8
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d59 7
a725 1
		assert(*sbuffer != NULL);
d729 2
a730 1
		if (*currlen > 0)
d732 1
d772 3
a774 1
	MS_STATIC char hugebuf[1024*10];
@


1.7
log
@merge openssl 0.9.6b-engine

Note that this is a maintenence release, API's appear *not* to have changed.
As such, I have only increased the minor number on these libraries
@
text
@d112 1
a112 1
# if defined(WIN32) && !defined(__GNUC__)
d572 1
a572 1
round(LDOUBLE value)
d624 1
a624 1
    fracpart = round((pow10(max)) * (ufvalue - intpart));
@


1.6
log
@openssl-engine-0.9.6a merge
@
text
@d112 5
a116 1
#define LLONG long long
d159 1
a159 1
#define MAX(p,q) ((p >= q) ? p : q)
d510 1
a510 1
    spadlen = min - MAX(max, place) - (signvalue ? 1 : 0);
d516 1
a516 1
        zpadlen = MAX(zpadlen, spadlen);
d648 1
a648 1
    } while (fracpart && (fplace < 20));
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d72 1
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@a63 1
#include <stdarg.h>
d80 1
a80 42
static void dopr (char *buffer, size_t maxlen, size_t *retlen,
	const char *format, va_list args);
#ifdef USE_ALLOCATING_PRINT
static void doapr (char **buffer, size_t *retlen,
	const char *format, va_list args);
#endif

int BIO_printf (BIO *bio, ...)
	{
	va_list args;
	char *format;
	int ret;
	size_t retlen;
#ifdef USE_ALLOCATING_PRINT
	char *hugebuf;
#else
	MS_STATIC char hugebuf[1024*2]; /* 10k in one chunk is the limit */
#endif

	va_start(args, bio);
	format=va_arg(args, char *);

#ifndef USE_ALLOCATING_PRINT
	hugebuf[0]='\0';
	dopr(hugebuf, sizeof(hugebuf), &retlen, format, args);
#else
	hugebuf = NULL;
	CRYPTO_push_info("doapr()");
	doapr(&hugebuf, &retlen, format, args);
	if (hugebuf)
		{
#endif
		ret=BIO_write(bio, hugebuf, (int)retlen);

#ifdef USE_ALLOCATING_PRINT
		Free(hugebuf);
		}
	CRYPTO_pop_info();
#endif
	va_end(args);
	return(ret);
	}
d101 1
d116 9
a124 19
static void fmtstr     (void (*)(char **, size_t *, size_t *, int),
			char **, size_t *, size_t *, const char *, int, int,
			int);
static void fmtint     (void (*)(char **, size_t *, size_t *, int),
			char **, size_t *, size_t *, LLONG, int, int, int, int);
static void fmtfp      (void (*)(char **, size_t *, size_t *, int),
			char **, size_t *, size_t *, LDOUBLE, int, int, int);
#ifndef USE_ALLOCATING_PRINT
static int dopr_isbig (size_t, size_t);
static int dopr_copy (size_t);
static void dopr_outch (char **, size_t *, size_t *, int);
#else
static int doapr_isbig (size_t, size_t);
static int doapr_copy (size_t);
static void doapr_outch (char **, size_t *, size_t *, int);
#endif
static void _dopr(void (*)(char **, size_t *, size_t *, int),
		  int (*)(size_t, size_t), int (*)(size_t),
		  char **buffer, size_t *maxlen, size_t *retlen,
a155 27
#ifndef USE_ALLOCATING_PRINT
static void
dopr(
    char *buffer,
    size_t maxlen,
    size_t *retlen,
    const char *format,
    va_list args)
{
    _dopr(dopr_outch, dopr_isbig, dopr_copy,
	  &buffer, &maxlen, retlen, format, args);
}

#else
static void
doapr(
    char **buffer,
    size_t *retlen,
    const char *format,
    va_list args)
{
    size_t dummy_maxlen = 0;
    _dopr(doapr_outch, doapr_isbig, doapr_copy,
	  buffer, &dummy_maxlen, retlen, format, args);
}
#endif

d158 1
a158 3
    void (*outch_fn)(char **, size_t *, size_t *, int),
    int (*isbig_fn)(size_t, size_t),
    int (*copy_fn)(size_t),
d162 1
d183 1
a183 1
        if ((ch == '\0') || (*isbig_fn)(currlen, *maxlen))
d191 1
a191 1
                (*outch_fn)(buffer, &currlen, maxlen, ch);
d297 2
a298 2
                fmtint(outch_fn, buffer, &currlen, maxlen,
		       value, 10, min, max, flags);
d323 1
a323 1
                fmtint(outch_fn, buffer, &currlen, maxlen, value,
d332 2
a333 2
                fmtfp(outch_fn, buffer, &currlen, maxlen,
		      fvalue, min, max, flags);
d352 1
a352 1
                (*outch_fn)(buffer, &currlen, maxlen,
d357 8
a364 4
                if (max < 0)
                    max = (*copy_fn)(*maxlen);
                fmtstr(outch_fn, buffer, &currlen, maxlen, strvalue,
		       flags, min, max);
d368 1
a368 1
                fmtint(outch_fn, buffer, &currlen, maxlen,
d391 1
a391 1
                (*outch_fn)(buffer, &currlen, maxlen, ch);
d412 2
a413 1
    if (currlen >= *maxlen - 1)
d415 2
a416 2
    (*buffer)[currlen] = '\0';
    *retlen = currlen;
d422 1
a422 1
    void (*outch_fn)(char **, size_t *, size_t *, int),
d445 1
a445 1
        (*outch_fn)(buffer, currlen, maxlen, ' ');
d450 1
a450 1
        (*outch_fn)(buffer, currlen, maxlen, *value++);
d454 1
a454 1
        (*outch_fn)(buffer, currlen, maxlen, ' ');
d462 1
a462 1
    void (*outch_fn)(char **, size_t *, size_t *, int),
d519 1
a519 1
        (*outch_fn)(buffer, currlen, maxlen, ' ');
d525 1
a525 1
        (*outch_fn)(buffer, currlen, maxlen, signvalue);
d530 1
a530 1
            (*outch_fn)(buffer, currlen, maxlen, '0');
d536 1
a536 1
        (*outch_fn)(buffer, currlen, maxlen, convert[--place]);
d540 1
a540 1
        (*outch_fn)(buffer, currlen, maxlen, ' ');
d579 1
a579 1
    void (*outch_fn)(char **, size_t *, size_t *, int),
d660 1
a660 1
            (*outch_fn)(buffer, currlen, maxlen, signvalue);
d665 1
a665 1
            (*outch_fn)(buffer, currlen, maxlen, '0');
d670 1
a670 1
        (*outch_fn)(buffer, currlen, maxlen, ' ');
d674 1
a674 1
        (*outch_fn)(buffer, currlen, maxlen, signvalue);
d677 1
a677 1
        (*outch_fn)(buffer, currlen, maxlen, iconvert[--iplace]);
d684 1
a684 1
        (*outch_fn)(buffer, currlen, maxlen, '.');
d687 1
a687 1
            (*outch_fn)(buffer, currlen, maxlen, fconvert[--fplace]);
d690 1
a690 1
        (*outch_fn)(buffer, currlen, maxlen, '0');
d695 1
a695 1
        (*outch_fn)(buffer, currlen, maxlen, ' ');
a699 35
static int
dopr_copy(
    size_t len)
{
    return len;
}

#ifdef USE_ALLOCATING_PRINT
static int
doapr_copy(
    size_t len)
{
    /* Return as high an integer as possible */
    return INT_MAX;
}
#endif

static int
dopr_isbig(
    size_t currlen,
    size_t maxlen)
{
    return currlen > maxlen;
}

#ifdef USE_ALLOCATING_PRINT
static int
doapr_isbig(
    size_t currlen,
    size_t maxlen)
{
    return 0;
}
#endif

d701 2
a702 1
dopr_outch(
d708 21
a728 4
    if (*currlen < *maxlen)
        (*buffer)[(*currlen)++] = (char)c;
    return;
}
d730 5
a734 16
#ifdef USE_ALLOCATING_PRINT
static void
doapr_outch(
    char **buffer,
    size_t *currlen,
    size_t *maxlen,
    int c)
{
    if (*buffer == NULL) {
	if (*maxlen == 0)
	    *maxlen = 1024;
	*buffer = Malloc(*maxlen);
    }
    while (*currlen >= *maxlen) {
	*maxlen += 1024;
	*buffer = Realloc(*buffer, *maxlen);
a735 2
    /* What to do if *buffer is NULL? */
    assert(*buffer != NULL);
a736 1
    (*buffer)[(*currlen)++] = (char)c;
d739 76
a814 1
#endif
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d67 2
d77 1
a77 1
#  define HAVE_LONG_LONG
d83 4
d94 3
d98 1
d103 1
d106 8
a113 1
	ret=BIO_write(bio, hugebuf, (int)retlen);
d115 5
d157 20
a176 4
static void fmtstr     (char *, size_t *, size_t, char *, int, int, int);
static void fmtint     (char *, size_t *, size_t, LLONG, int, int, int, int);
static void fmtfp      (char *, size_t *, size_t, LDOUBLE, int, int, int);
static void dopr_outch (char *, size_t *, size_t, int);
d207 1
d216 29
d262 1
a262 1
        if ((ch == '\0') || (currlen >= maxlen))
d270 1
a270 1
                dopr_outch(buffer, &currlen, maxlen, ch);
d376 2
a377 1
                fmtint(buffer, &currlen, maxlen, value, 10, min, max, flags);
d402 1
a402 1
                fmtint(buffer, &currlen, maxlen, value,
d411 2
a412 1
                fmtfp(buffer, &currlen, maxlen, fvalue, min, max, flags);
d431 1
a431 1
                dopr_outch(buffer, &currlen, maxlen,
d437 3
a439 3
                    max = maxlen;
                fmtstr(buffer, &currlen, maxlen, strvalue,
                    flags, min, max);
d443 1
a443 1
                fmtint(buffer, &currlen, maxlen,
d466 1
a466 1
                dopr_outch(buffer, &currlen, maxlen, ch);
d487 3
a489 3
    if (currlen >= maxlen - 1)
        currlen = maxlen - 1;
    buffer[currlen] = '\0';
d496 2
a497 1
    char *buffer,
d499 2
a500 2
    size_t maxlen,
    char *value,
d519 1
a519 1
        dopr_outch(buffer, currlen, maxlen, ' ');
d524 1
a524 1
        dopr_outch(buffer, currlen, maxlen, *value++);
d528 1
a528 1
        dopr_outch(buffer, currlen, maxlen, ' ');
d536 2
a537 1
    char *buffer,
d539 1
a539 1
    size_t maxlen,
d593 1
a593 1
        dopr_outch(buffer, currlen, maxlen, ' ');
d599 1
a599 1
        dopr_outch(buffer, currlen, maxlen, signvalue);
d604 1
a604 1
            dopr_outch(buffer, currlen, maxlen, '0');
d610 1
a610 1
        dopr_outch(buffer, currlen, maxlen, convert[--place]);
d614 1
a614 1
        dopr_outch(buffer, currlen, maxlen, ' ');
d653 2
a654 1
    char *buffer,
d656 1
a656 1
    size_t maxlen,
d734 1
a734 1
            dopr_outch(buffer, currlen, maxlen, signvalue);
d739 1
a739 1
            dopr_outch(buffer, currlen, maxlen, '0');
d744 1
a744 1
        dopr_outch(buffer, currlen, maxlen, ' ');
d748 1
a748 1
        dopr_outch(buffer, currlen, maxlen, signvalue);
d751 1
a751 1
        dopr_outch(buffer, currlen, maxlen, iconvert[--iplace]);
d758 1
a758 1
        dopr_outch(buffer, currlen, maxlen, '.');
d761 1
a761 1
            dopr_outch(buffer, currlen, maxlen, fconvert[--fplace]);
d764 1
a764 1
        dopr_outch(buffer, currlen, maxlen, '0');
d769 1
a769 1
        dopr_outch(buffer, currlen, maxlen, ' ');
d774 35
d811 14
a824 1
    char *buffer,
d826 1
a826 1
    size_t maxlen,
d829 13
a841 2
    if (*currlen < maxlen)
        buffer[(*currlen)++] = (char)c;
d844 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d65 2
d68 3
d73 9
d87 1
d94 2
a95 4

	vsprintf(hugebuf,format,args);

	ret=BIO_write(bio,hugebuf,strlen(hugebuf));
d101 610
@


1.1
log
@Initial revision
@
text
@d64 1
d66 1
a66 1
#include "bio.h"
d68 1
a68 2
int BIO_printf ( VAR_PLIST( BIO *, bio ) )
VAR_ALIST
d70 1
a70 1
	VAR_BDEFN(args, BIO *, bio);
d75 2
a76 2
	VAR_INIT(args, BIO *, bio);
	VAR_ARG(args, char *, format);
a79 4
/* no-one uses _doprnt anymore and it appears to be broken under SunOS 4.1.4 */
#if 0 && defined(sun) && !defined(VAR_ANSI) /**/
	_doprnt(hugebuf,format,args);
#else /* !sun */
a80 1
#endif /* sun */
d84 1
a84 1
	VAR_END( args );
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a58 7
/* disable assert() unless BIO_DEBUG has been defined */
#ifndef BIO_DEBUG
# ifndef NDEBUG
#  define NDEBUG
# endif
#endif

a63 4
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include <limits.h>
d65 1
a65 547
#ifndef NO_SYS_TYPES_H
#include <sys/types.h>
#endif
#include <openssl/bn.h>         /* To get BN_LLONG properly defined */
#include <openssl/bio.h>

#ifdef BN_LLONG
# ifndef HAVE_LONG_LONG
#  define HAVE_LONG_LONG 1
# endif
#endif

/***************************************************************************/

/*
 * Copyright Patrick Powell 1995
 * This code is based on code written by Patrick Powell <papowell@@astart.com>
 * It may be used for any purpose as long as this notice remains intact
 * on all source code distributions.
 */

/*
 * This code contains numerious changes and enhancements which were
 * made by lots of contributors over the last years to Patrick Powell's
 * original code:
 *
 * o Patrick Powell <papowell@@astart.com>      (1995)
 * o Brandon Long <blong@@fiction.net>          (1996, for Mutt)
 * o Thomas Roessler <roessler@@guug.de>        (1998, for Mutt)
 * o Michael Elkins <me@@cs.hmc.edu>            (1998, for Mutt)
 * o Andrew Tridgell <tridge@@samba.org>        (1998, for Samba)
 * o Luke Mewburn <lukem@@netbsd.org>           (1999, for LukemFTP)
 * o Ralf S. Engelschall <rse@@engelschall.com> (1999, for Pth)
 * o ...                                       (for OpenSSL)
 */

#if HAVE_LONG_DOUBLE
#define LDOUBLE long double
#else
#define LDOUBLE double
#endif

#if HAVE_LONG_LONG
# if defined(OPENSSL_SYS_WIN32) && !defined(__GNUC__)
# define LLONG _int64
# else
# define LLONG long long
# endif
#else
#define LLONG long
#endif

static void fmtstr     (char **, char **, size_t *, size_t *,
			const char *, int, int, int);
static void fmtint     (char **, char **, size_t *, size_t *,
			LLONG, int, int, int, int);
static void fmtfp      (char **, char **, size_t *, size_t *,
			LDOUBLE, int, int, int);
static void doapr_outch (char **, char **, size_t *, size_t *, int);
static void _dopr(char **sbuffer, char **buffer,
		  size_t *maxlen, size_t *retlen, int *truncated,
		  const char *format, va_list args);

/* format read states */
#define DP_S_DEFAULT    0
#define DP_S_FLAGS      1
#define DP_S_MIN        2
#define DP_S_DOT        3
#define DP_S_MAX        4
#define DP_S_MOD        5
#define DP_S_CONV       6
#define DP_S_DONE       7

/* format flags - Bits */
#define DP_F_MINUS      (1 << 0)
#define DP_F_PLUS       (1 << 1)
#define DP_F_SPACE      (1 << 2)
#define DP_F_NUM        (1 << 3)
#define DP_F_ZERO       (1 << 4)
#define DP_F_UP         (1 << 5)
#define DP_F_UNSIGNED   (1 << 6)

/* conversion flags */
#define DP_C_SHORT      1
#define DP_C_LONG       2
#define DP_C_LDOUBLE    3
#define DP_C_LLONG      4

/* some handy macros */
#define char_to_int(p) (p - '0')
#define OSSL_MAX(p,q) ((p >= q) ? p : q)

static void
_dopr(
    char **sbuffer,
    char **buffer,
    size_t *maxlen,
    size_t *retlen,
    int *truncated,
    const char *format,
    va_list args)
{
    char ch;
    LLONG value;
    LDOUBLE fvalue;
    char *strvalue;
    int min;
    int max;
    int state;
    int flags;
    int cflags;
    size_t currlen;

    state = DP_S_DEFAULT;
    flags = currlen = cflags = min = 0;
    max = -1;
    ch = *format++;

    while (state != DP_S_DONE) {
        if (ch == '\0' || (buffer == NULL && currlen >= *maxlen))
            state = DP_S_DONE;

        switch (state) {
        case DP_S_DEFAULT:
            if (ch == '%')
                state = DP_S_FLAGS;
            else
                doapr_outch(sbuffer,buffer, &currlen, maxlen, ch);
            ch = *format++;
            break;
        case DP_S_FLAGS:
            switch (ch) {
            case '-':
                flags |= DP_F_MINUS;
                ch = *format++;
                break;
            case '+':
                flags |= DP_F_PLUS;
                ch = *format++;
                break;
            case ' ':
                flags |= DP_F_SPACE;
                ch = *format++;
                break;
            case '#':
                flags |= DP_F_NUM;
                ch = *format++;
                break;
            case '0':
                flags |= DP_F_ZERO;
                ch = *format++;
                break;
            default:
                state = DP_S_MIN;
                break;
            }
            break;
        case DP_S_MIN:
            if (isdigit((unsigned char)ch)) {
                min = 10 * min + char_to_int(ch);
                ch = *format++;
            } else if (ch == '*') {
                min = va_arg(args, int);
                ch = *format++;
                state = DP_S_DOT;
            } else
                state = DP_S_DOT;
            break;
        case DP_S_DOT:
            if (ch == '.') {
                state = DP_S_MAX;
                ch = *format++;
            } else
                state = DP_S_MOD;
            break;
        case DP_S_MAX:
            if (isdigit((unsigned char)ch)) {
                if (max < 0)
                    max = 0;
                max = 10 * max + char_to_int(ch);
                ch = *format++;
            } else if (ch == '*') {
                max = va_arg(args, int);
                ch = *format++;
                state = DP_S_MOD;
            } else
                state = DP_S_MOD;
            break;
        case DP_S_MOD:
            switch (ch) {
            case 'h':
                cflags = DP_C_SHORT;
                ch = *format++;
                break;
            case 'l':
                if (*format == 'l') {
                    cflags = DP_C_LLONG;
                    format++;
                } else
                    cflags = DP_C_LONG;
                ch = *format++;
                break;
            case 'q':
                cflags = DP_C_LLONG;
                ch = *format++;
                break;
            case 'L':
                cflags = DP_C_LDOUBLE;
                ch = *format++;
                break;
            default:
                break;
            }
            state = DP_S_CONV;
            break;
        case DP_S_CONV:
            switch (ch) {
            case 'd':
            case 'i':
                switch (cflags) {
                case DP_C_SHORT:
                    value = (short int)va_arg(args, int);
                    break;
                case DP_C_LONG:
                    value = va_arg(args, long int);
                    break;
                case DP_C_LLONG:
                    value = va_arg(args, LLONG);
                    break;
                default:
                    value = va_arg(args, int);
                    break;
                }
                fmtint(sbuffer, buffer, &currlen, maxlen,
                       value, 10, min, max, flags);
                break;
            case 'X':
                flags |= DP_F_UP;
                /* FALLTHROUGH */
            case 'x':
            case 'o':
            case 'u':
                flags |= DP_F_UNSIGNED;
                switch (cflags) {
                case DP_C_SHORT:
                    value = (unsigned short int)va_arg(args, unsigned int);
                    break;
                case DP_C_LONG:
                    value = (LLONG) va_arg(args,
                        unsigned long int);
                    break;
                case DP_C_LLONG:
                    value = va_arg(args, unsigned LLONG);
                    break;
                default:
                    value = (LLONG) va_arg(args,
                        unsigned int);
                    break;
                }
                fmtint(sbuffer, buffer, &currlen, maxlen, value,
                       ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),
                       min, max, flags);
                break;
            case 'f':
                if (cflags == DP_C_LDOUBLE)
                    fvalue = va_arg(args, LDOUBLE);
                else
                    fvalue = va_arg(args, double);
                fmtfp(sbuffer, buffer, &currlen, maxlen,
                      fvalue, min, max, flags);
                break;
            case 'E':
                flags |= DP_F_UP;
            case 'e':
                if (cflags == DP_C_LDOUBLE)
                    fvalue = va_arg(args, LDOUBLE);
                else
                    fvalue = va_arg(args, double);
                break;
            case 'G':
                flags |= DP_F_UP;
            case 'g':
                if (cflags == DP_C_LDOUBLE)
                    fvalue = va_arg(args, LDOUBLE);
                else
                    fvalue = va_arg(args, double);
                break;
            case 'c':
                doapr_outch(sbuffer, buffer, &currlen, maxlen,
                    va_arg(args, int));
                break;
            case 's':
                strvalue = va_arg(args, char *);
                if (max < 0) {
		    if (buffer)
			max = INT_MAX;
		    else
			max = *maxlen;
		}
                fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,
                       flags, min, max);
                break;
            case 'p':
                value = (long)va_arg(args, void *);
                fmtint(sbuffer, buffer, &currlen, maxlen,
                    value, 16, min, max, flags);
                break;
            case 'n': /* XXX */
                if (cflags == DP_C_SHORT) {
                    short int *num;
                    num = va_arg(args, short int *);
                    *num = currlen;
                } else if (cflags == DP_C_LONG) { /* XXX */
                    long int *num;
                    num = va_arg(args, long int *);
                    *num = (long int) currlen;
                } else if (cflags == DP_C_LLONG) { /* XXX */
                    LLONG *num;
                    num = va_arg(args, LLONG *);
                    *num = (LLONG) currlen;
                } else {
                    int    *num;
                    num = va_arg(args, int *);
                    *num = currlen;
                }
                break;
            case '%':
                doapr_outch(sbuffer, buffer, &currlen, maxlen, ch);
                break;
            case 'w':
                /* not supported yet, treat as next char */
                ch = *format++;
                break;
            default:
                /* unknown, skip */
                break;
            }
            ch = *format++;
            state = DP_S_DEFAULT;
            flags = cflags = min = 0;
            max = -1;
            break;
        case DP_S_DONE:
            break;
        default:
            break;
        }
    }
    *truncated = (currlen > *maxlen - 1);
    if (*truncated)
        currlen = *maxlen - 1;
    doapr_outch(sbuffer, buffer, &currlen, maxlen, '\0');
    *retlen = currlen - 1;
    return;
}

static void
fmtstr(
    char **sbuffer,
    char **buffer,
    size_t *currlen,
    size_t *maxlen,
    const char *value,
    int flags,
    int min,
    int max)
{
    int padlen, strln;
    int cnt = 0;

    if (value == 0)
        value = "<NULL>";
    for (strln = 0; value[strln]; ++strln)
        ;
    padlen = min - strln;
    if (padlen < 0)
        padlen = 0;
    if (flags & DP_F_MINUS)
        padlen = -padlen;

    while ((padlen > 0) && (cnt < max)) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        --padlen;
        ++cnt;
    }
    while (*value && (cnt < max)) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, *value++);
        ++cnt;
    }
    while ((padlen < 0) && (cnt < max)) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        ++padlen;
        ++cnt;
    }
}

static void
fmtint(
    char **sbuffer,
    char **buffer,
    size_t *currlen,
    size_t *maxlen,
    LLONG value,
    int base,
    int min,
    int max,
    int flags)
{
    int signvalue = 0;
    unsigned LLONG uvalue;
    char convert[20];
    int place = 0;
    int spadlen = 0;
    int zpadlen = 0;
    int caps = 0;

    if (max < 0)
        max = 0;
    uvalue = value;
    if (!(flags & DP_F_UNSIGNED)) {
        if (value < 0) {
            signvalue = '-';
            uvalue = -value;
        } else if (flags & DP_F_PLUS)
            signvalue = '+';
        else if (flags & DP_F_SPACE)
            signvalue = ' ';
    }
    if (flags & DP_F_UP)
        caps = 1;
    do {
        convert[place++] =
            (caps ? "0123456789ABCDEF" : "0123456789abcdef")
            [uvalue % (unsigned) base];
        uvalue = (uvalue / (unsigned) base);
    } while (uvalue && (place < 20));
    if (place == 20)
        place--;
    convert[place] = 0;

    zpadlen = max - place;
    spadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0);
    if (zpadlen < 0)
        zpadlen = 0;
    if (spadlen < 0)
        spadlen = 0;
    if (flags & DP_F_ZERO) {
        zpadlen = OSSL_MAX(zpadlen, spadlen);
        spadlen = 0;
    }
    if (flags & DP_F_MINUS)
        spadlen = -spadlen;

    /* spaces */
    while (spadlen > 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        --spadlen;
    }

    /* sign */
    if (signvalue)
        doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);

    /* zeros */
    if (zpadlen > 0) {
        while (zpadlen > 0) {
            doapr_outch(sbuffer, buffer, currlen, maxlen, '0');
            --zpadlen;
        }
    }
    /* digits */
    while (place > 0)
        doapr_outch(sbuffer, buffer, currlen, maxlen, convert[--place]);

    /* left justified spaces */
    while (spadlen < 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        ++spadlen;
    }
    return;
}

static LDOUBLE
abs_val(LDOUBLE value)
{
    LDOUBLE result = value;
    if (value < 0)
        result = -value;
    return result;
}

static LDOUBLE
pow10(int exp)
{
    LDOUBLE result = 1;
    while (exp) {
        result *= 10;
        exp--;
    }
    return result;
}

static long
roundv(LDOUBLE value)
{
    long intpart;
    intpart = (long) value;
    value = value - intpart;
    if (value >= 0.5)
        intpart++;
    return intpart;
}

static void
fmtfp(
    char **sbuffer,
    char **buffer,
    size_t *currlen,
    size_t *maxlen,
    LDOUBLE fvalue,
    int min,
    int max,
    int flags)
{
    int signvalue = 0;
    LDOUBLE ufvalue;
    char iconvert[20];
    char fconvert[20];
    int iplace = 0;
    int fplace = 0;
    int padlen = 0;
    int zpadlen = 0;
    int caps = 0;
    long intpart;
    long fracpart;

    if (max < 0)
        max = 6;
    ufvalue = abs_val(fvalue);
    if (fvalue < 0)
        signvalue = '-';
    else if (flags & DP_F_PLUS)
        signvalue = '+';
    else if (flags & DP_F_SPACE)
        signvalue = ' ';

    intpart = (long)ufvalue;
d67 2
a68 132
    /* sorry, we only support 9 digits past the decimal because of our
       conversion method */
    if (max > 9)
        max = 9;

    /* we "cheat" by converting the fractional part to integer by
       multiplying by a factor of 10 */
    fracpart = roundv((pow10(max)) * (ufvalue - intpart));

    if (fracpart >= pow10(max)) {
        intpart++;
        fracpart -= (long)pow10(max);
    }

    /* convert integer part */
    do {
        iconvert[iplace++] =
            (caps ? "0123456789ABCDEF"
              : "0123456789abcdef")[intpart % 10];
        intpart = (intpart / 10);
    } while (intpart && (iplace < 20));
    if (iplace == 20)
        iplace--;
    iconvert[iplace] = 0;

    /* convert fractional part */
    do {
        fconvert[fplace++] =
            (caps ? "0123456789ABCDEF"
              : "0123456789abcdef")[fracpart % 10];
        fracpart = (fracpart / 10);
    } while (fplace < max);
    if (fplace == 20)
        fplace--;
    fconvert[fplace] = 0;

    /* -1 for decimal point, another -1 if we are printing a sign */
    padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);
    zpadlen = max - fplace;
    if (zpadlen < 0)
        zpadlen = 0;
    if (padlen < 0)
        padlen = 0;
    if (flags & DP_F_MINUS)
        padlen = -padlen;

    if ((flags & DP_F_ZERO) && (padlen > 0)) {
        if (signvalue) {
            doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);
            --padlen;
            signvalue = 0;
        }
        while (padlen > 0) {
            doapr_outch(sbuffer, buffer, currlen, maxlen, '0');
            --padlen;
        }
    }
    while (padlen > 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        --padlen;
    }
    if (signvalue)
        doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);

    while (iplace > 0)
        doapr_outch(sbuffer, buffer, currlen, maxlen, iconvert[--iplace]);

    /*
     * Decimal point. This should probably use locale to find the correct
     * char to print out.
     */
    if (max > 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, '.');

        while (fplace > 0)
            doapr_outch(sbuffer, buffer, currlen, maxlen, fconvert[--fplace]);
    }
    while (zpadlen > 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, '0');
        --zpadlen;
    }

    while (padlen < 0) {
        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');
        ++padlen;
    }
}

static void
doapr_outch(
    char **sbuffer,
    char **buffer,
    size_t *currlen,
    size_t *maxlen,
    int c)
{
    /* If we haven't at least one buffer, someone has doe a big booboo */
    assert(*sbuffer != NULL || buffer != NULL);

    if (buffer) {
	while (*currlen >= *maxlen) {
	    if (*buffer == NULL) {
		if (*maxlen == 0)
		    *maxlen = 1024;
		*buffer = OPENSSL_malloc(*maxlen);
		if (*currlen > 0) {
		    assert(*sbuffer != NULL);
		    memcpy(*buffer, *sbuffer, *currlen);
		}
		*sbuffer = NULL;
	    } else {
		*maxlen += 1024;
		*buffer = OPENSSL_realloc(*buffer, *maxlen);
	    }
	}
	/* What to do if *buffer is NULL? */
	assert(*sbuffer != NULL || *buffer != NULL);
    }

    if (*currlen < *maxlen) {
	if (*sbuffer)
	    (*sbuffer)[(*currlen)++] = (char)c;
	else
	    (*buffer)[(*currlen)++] = (char)c;
    }

    return;
}

/***************************************************************************/

int BIO_printf (BIO *bio, const char *format, ...)
d70 2
a71 1
	va_list args;
d73 1
d75 2
a76 1
	va_start(args, format);
d78 1
a78 1
	ret = BIO_vprintf(bio, format, args);
d80 6
a85 32
	va_end(args);
	return(ret);
	}

int BIO_vprintf (BIO *bio, const char *format, va_list args)
	{
	int ret;
	size_t retlen;
	char hugebuf[1024*2];	/* Was previously 10k, which is unreasonable
				   in small-stack environments, like threads
				   or DOS programs. */
	char *hugebufp = hugebuf;
	size_t hugebufsize = sizeof(hugebuf);
	char *dynbuf = NULL;
	int ignored;

	dynbuf = NULL;
	CRYPTO_push_info("doapr()");
	_dopr(&hugebufp, &dynbuf, &hugebufsize,
		&retlen, &ignored, format, args);
	if (dynbuf)
		{
		ret=BIO_write(bio, dynbuf, (int)retlen);
		OPENSSL_free(dynbuf);
		}
	else
		{
		ret=BIO_write(bio, hugebuf, (int)retlen);
		}
	CRYPTO_pop_info();
	return(ret);
	}
d87 1
a87 12
/* As snprintf is not available everywhere, we provide our own implementation.
 * This function has nothing to do with BIOs, but it's closely related
 * to BIO_printf, and we need *some* name prefix ...
 * (XXX  the function should be renamed, but to what?) */
int BIO_snprintf(char *buf, size_t n, const char *format, ...)
	{
	va_list args;
	int ret;

	va_start(args, format);

	ret = BIO_vsnprintf(buf, n, format, args);
d89 1
a89 1
	va_end(args);
a92 16
int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)
	{
	size_t retlen;
	int truncated;

	_dopr(&buf, NULL, &n, &retlen, &truncated, format, args);

	if (truncated)
		/* In case of truncation, return -1 like traditional snprintf.
		 * (Current drafts for ISO/IEC 9899 say snprintf should return
		 * the number of characters that would have been written,
		 * had the buffer been large enough.) */
		return -1;
	else
		return (retlen <= INT_MAX) ? retlen : -1;
	}
@


1.1.1.3
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d112 1
a112 1
#ifdef HAVE_LONG_DOUBLE
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d381 1
a381 1
                    value, 16, min, max, flags|DP_F_NUM);
a484 1
    char *prefix = "";
d486 1
a486 1
    char convert[DECIMAL_SIZE(value)+3];
a503 4
    if (flags & DP_F_NUM) {
	if (base == 8) prefix = "0";
	if (base == 16) prefix = "0x";
    }
d511 2
a512 2
    } while (uvalue && (place < sizeof convert));
    if (place == sizeof convert)
d517 1
a517 1
    spadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0) - strlen(prefix);
a538 6
    /* prefix */
    while (*prefix) {
	doapr_outch(sbuffer, buffer, currlen, maxlen, *prefix);
	prefix++;
    }

d644 2
a645 2
    } while (intpart && (iplace < sizeof iplace));
    if (iplace == sizeof iplace)
d656 1
a656 1
    if (fplace == sizeof fplace)
d695 1
a695 1
    if (max > 0 || (flags & DP_F_NUM)) {
@


1.1.1.5
log
@import 0.9.7c
@
text
@d839 1
a839 1
		return (retlen <= INT_MAX) ? (int)retlen : -1;
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d579 1
a579 1
pow10(int in_exp)
d582 1
a582 1
    while (in_exp) {
d584 1
a584 1
        in_exp--;
d655 2
a656 2
    } while (intpart && (iplace < sizeof iconvert));
    if (iplace == sizeof iconvert)
d667 1
a667 1
    if (fplace == sizeof fconvert)
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d644 1
a644 1
    if (fracpart >= (long)pow10(max)) {
@


1.1.1.8
log
@import of openssl-0.9.7j
@
text
@d579 1
a579 1
pow_10(int in_exp)
d642 1
a642 1
    fracpart = roundv((pow_10(max)) * (ufvalue - intpart));
d644 1
a644 1
    if (fracpart >= (long)pow_10(max)) {
d646 1
a646 1
        fracpart -= (long)pow_10(max);
@


1.1.1.9
log
@import of OpenSSL 0.9.8h
@
text
@d82 1
a82 1
#if defined(BN_LLONG) || defined(SIXTY_FOUR_BIT)
d120 1
a120 1
# define LLONG __int64
d485 1
a485 1
    const char *prefix = "";
d516 2
a517 2
    } while (uvalue && (place < (int)sizeof(convert)));
    if (place == sizeof(convert))
a621 1
    long max10;
d642 1
a642 2
    max10 = roundv(pow_10(max));
    fracpart = roundv(pow_10(max) * (ufvalue - intpart));
d644 1
a644 1
    if (fracpart >= max10) {
d646 1
a646 1
        fracpart -= max10;
d655 1
a655 1
    } while (intpart && (iplace < (int)sizeof(iconvert)));
@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@d118 2
a119 2
#ifdef HAVE_LONG_LONG
# if defined(_WIN32) && !defined(__GNUC__)
@


