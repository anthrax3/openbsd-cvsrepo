head	1.32;
access;
symbols;
locks; strict;
comment	@ * @;


1.32
date	2017.01.29.17.49.22;	author beck;	state Exp;
branches;
next	1.31;
commitid	kT0fLt3r4lroFJra;

1.31
date	2014.11.11.19.26.12;	author miod;	state Exp;
branches;
next	1.30;
commitid	4CKhmgtEPtZmYN5j;

1.30
date	2014.07.11.08.44.47;	author jsing;	state Exp;
branches;
next	1.29;
commitid	yQEL1wOWIearrW15;

1.29
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.28;
commitid	id8dTrTMtnTn4fqt;

1.28
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	mJUVYpkFBZ0Zv2bG;

1.27
date	2014.05.29.18.27.52;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.26.18.56.37;	author beck;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.19.00.41.37;	author beck;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.17.50.45;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.16.19.54.20;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.16.19.42.24;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.15.17.25.41;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.15.16.37.22;	author jsing;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.13.23.31.37;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.13.19.50.56;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.01.22.58.53;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.09.12.15.30;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.06.12.17.49;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.29.05.39.18;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.13;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.12.02.18.36;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.03.15.12.44;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.10.16.31.54;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.11;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.18;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.09;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.41;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.37;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.49.56;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.36.23;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.34.40;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.12.36;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.41.35;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.37.04;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.41;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.13.52;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.04;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2011.11.03.02.32.08;	author djm;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: bss_file.c,v 1.31 2014/11/11 19:26:12 miod Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/*
 * 03-Dec-1997	rdenny@@dc3.com  Fix bug preventing use of stdin/stdout
 *		with binary data (e.g. asn1parse -inform DER < xxx) under
 *		Windows
 */

#ifndef HEADER_BSS_FILE_C
#define HEADER_BSS_FILE_C

#if defined(__linux) || defined(__sun) || defined(__hpux)
/* Following definition aliases fopen to fopen64 on above mentioned
 * platforms. This makes it possible to open and sequentially access
 * files larger than 2GB from 32-bit application. It does not allow to
 * traverse them beyond 2GB with fseek/ftell, but on the other hand *no*
 * 32-bit platform permits that, not with fseek/ftell. Not to mention
 * that breaking 2GB limit for seeking would require surgery to *our*
 * API. But sequential access suffices for practical cases when you
 * can run into large files, such as fingerprinting, so we can let API
 * alone. For reference, the list of 32-bit platforms which allow for
 * sequential access of large files without extra "magic" comprise *BSD,
 * Darwin, IRIX...
 */
#ifndef _FILE_OFFSET_BITS
#define _FILE_OFFSET_BITS 64
#endif
#endif

#include <errno.h>
#include <stdio.h>
#include <string.h>

#include <openssl/bio.h>
#include <openssl/err.h>

static int file_write(BIO *h, const char *buf, int num);
static int file_read(BIO *h, char *buf, int size);
static int file_puts(BIO *h, const char *str);
static int file_gets(BIO *h, char *str, int size);
static long file_ctrl(BIO *h, int cmd, long arg1, void *arg2);
static int file_new(BIO *h);
static int file_free(BIO *data);

static BIO_METHOD methods_filep = {
	.type = BIO_TYPE_FILE,
	.name = "FILE pointer",
	.bwrite = file_write,
	.bread = file_read,
	.bputs = file_puts,
	.bgets = file_gets,
	.ctrl = file_ctrl,
	.create = file_new,
	.destroy = file_free
};

BIO *
BIO_new_file(const char *filename, const char *mode)
{
	BIO  *ret;
	FILE *file = NULL;

	file = fopen(filename, mode);

	if (file == NULL) {
		SYSerror(errno);
		ERR_asprintf_error_data("fopen('%s', '%s')", filename, mode);
		if (errno == ENOENT)
			BIOerror(BIO_R_NO_SUCH_FILE);
		else
			BIOerror(ERR_R_SYS_LIB);
		return (NULL);
	}
	if ((ret = BIO_new(BIO_s_file())) == NULL) {
		fclose(file);
		return (NULL);
	}

	BIO_set_fp(ret, file, BIO_CLOSE);
	return (ret);
}

BIO *
BIO_new_fp(FILE *stream, int close_flag)
{
	BIO *ret;

	if ((ret = BIO_new(BIO_s_file())) == NULL)
		return (NULL);

	BIO_set_fp(ret, stream, close_flag);
	return (ret);
}

BIO_METHOD *
BIO_s_file(void)
{
	return (&methods_filep);
}

static int
file_new(BIO *bi)
{
	bi->init = 0;
	bi->num = 0;
	bi->ptr = NULL;
	bi->flags=0;
	return (1);
}

static int
file_free(BIO *a)
{
	if (a == NULL)
		return (0);
	if (a->shutdown) {
		if ((a->init) && (a->ptr != NULL)) {
			fclose (a->ptr);
			a->ptr = NULL;
			a->flags = 0;
		}
		a->init = 0;
	}
	return (1);
}

static int
file_read(BIO *b, char *out, int outl)
{
	int ret = 0;

	if (b->init && out != NULL) {
		ret = fread(out, 1, outl, (FILE *)b->ptr);
		if (ret == 0 && ferror((FILE *)b->ptr)) {
			SYSerror(errno);
			BIOerror(ERR_R_SYS_LIB);
			ret = -1;
		}
	}
	return (ret);
}

static int
file_write(BIO *b, const char *in, int inl)
{
	int ret = 0;

	if (b->init && in != NULL)
		ret = fwrite(in, 1, inl, (FILE *)b->ptr);
	return (ret);
}

static long
file_ctrl(BIO *b, int cmd, long num, void *ptr)
{
	long ret = 1;
	FILE *fp = (FILE *)b->ptr;
	FILE **fpp;
	char p[4];

	switch (cmd) {
	case BIO_C_FILE_SEEK:
	case BIO_CTRL_RESET:
		ret = (long)fseek(fp, num, 0);
		break;
	case BIO_CTRL_EOF:
		ret = (long)feof(fp);
		break;
	case BIO_C_FILE_TELL:
	case BIO_CTRL_INFO:
		ret = ftell(fp);
		break;
	case BIO_C_SET_FILE_PTR:
		file_free(b);
		b->shutdown = (int)num&BIO_CLOSE;
		b->ptr = ptr;
		b->init = 1;
		break;
	case BIO_C_SET_FILENAME:
		file_free(b);
		b->shutdown = (int)num&BIO_CLOSE;
		if (num & BIO_FP_APPEND) {
			if (num & BIO_FP_READ)
				strlcpy(p, "a+", sizeof p);
			else	strlcpy(p, "a", sizeof p);
		} else if ((num & BIO_FP_READ) && (num & BIO_FP_WRITE))
			strlcpy(p, "r+", sizeof p);
		else if (num & BIO_FP_WRITE)
			strlcpy(p, "w", sizeof p);
		else if (num & BIO_FP_READ)
			strlcpy(p, "r", sizeof p);
		else {
			BIOerror(BIO_R_BAD_FOPEN_MODE);
			ret = 0;
			break;
		}
		fp = fopen(ptr, p);
		if (fp == NULL) {
			SYSerror(errno);
			ERR_asprintf_error_data("fopen('%s', '%s')", ptr, p);
			BIOerror(ERR_R_SYS_LIB);
			ret = 0;
			break;
		}
		b->ptr = fp;
		b->init = 1;
		break;
	case BIO_C_GET_FILE_PTR:
		/* the ptr parameter is actually a FILE ** in this case. */
		if (ptr != NULL) {
			fpp = (FILE **)ptr;
			*fpp = (FILE *)b->ptr;
		}
		break;
	case BIO_CTRL_GET_CLOSE:
		ret = (long)b->shutdown;
		break;
	case BIO_CTRL_SET_CLOSE:
		b->shutdown = (int)num;
		break;
	case BIO_CTRL_FLUSH:
		fflush((FILE *)b->ptr);
		break;
	case BIO_CTRL_DUP:
		ret = 1;
		break;

	case BIO_CTRL_WPENDING:
	case BIO_CTRL_PENDING:
	case BIO_CTRL_PUSH:
	case BIO_CTRL_POP:
	default:
		ret = 0;
		break;
	}
	return (ret);
}

static int
file_gets(BIO *bp, char *buf, int size)
{
	int ret = 0;

	buf[0] = '\0';
	if (!fgets(buf, size,(FILE *)bp->ptr))
		goto err;
	if (buf[0] != '\0')
		ret = strlen(buf);
err:
	return (ret);
}

static int
file_puts(BIO *bp, const char *str)
{
	int n, ret;

	n = strlen(str);
	ret = file_write(bp, str, n);
	return (ret);
}


#endif /* HEADER_BSS_FILE_C */
@


1.31
log
@f{read,write} take a number of items and an item size as arguments, and
return the number of items read of written.

When you intend to return the number of bytes actually processed, it is
wise to pass 1 as the item size and the size as the number of items.

But in *some* places, the OpenSSL does the opposite, and has extra logic
to change a successful return of 1 (item processed) into the real size.

And, guess why it does that? Because of old VMS, for they (used to) have a
substandard stdio implementation.

Note that this change causes the return values of BIO_dump_fp() and
BIO_dump_indent_fp() to no longer be useless (actual number of callback calls),
but actual bytes output. Given the irrelevance of the return value before,
it is unlikely that anything depends upon it (and if something does, it
probably has other problems in need for a fix...)

ok tedu@@ beck@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_file.c,v 1.30 2014/07/11 08:44:47 jsing Exp $ */
d122 1
a122 1
		SYSerr(SYS_F_FOPEN, errno);
d125 1
a125 1
			BIOerr(BIO_F_BIO_NEW_FILE, BIO_R_NO_SUCH_FILE);
d127 1
a127 1
			BIOerr(BIO_F_BIO_NEW_FILE, ERR_R_SYS_LIB);
d191 2
a192 2
			SYSerr(SYS_F_FREAD, errno);
			BIOerr(BIO_F_FILE_READ, ERR_R_SYS_LIB);
d249 1
a249 1
			BIOerr(BIO_F_FILE_CTRL, BIO_R_BAD_FOPEN_MODE);
d255 1
a255 1
			SYSerr(SYS_F_FOPEN, errno);
d257 1
a257 1
			BIOerr(BIO_F_FILE_CTRL, ERR_R_SYS_LIB);
@


1.30
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_file.c,v 1.29 2014/07/10 13:58:22 jsing Exp $ */
d188 2
a189 2
	if (b->init && (out != NULL)) {
		ret = fread(out, 1,(int)outl,(FILE *)b->ptr);
d204 2
a205 9
	if (b->init && (in != NULL)) {
		ret = fwrite(in,(int)inl, 1,(FILE *)b->ptr);
		if (ret)
			ret = inl;
		/* ret=fwrite(in,1,(int)inl,(FILE *)b->ptr); */
		/* according to Tim Hudson <tjh@@cryptsoft.com>, the commented
		 * out version above can cause 'inl' write calls under
		 * some stupid stdio implementations (VMS) */
	}
@


1.29
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: bss_file.c,v 1.28 2014/06/12 15:49:28 deraadt Exp $ */
a89 1
#include "cryptlib.h"
@


1.28
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d86 1
d88 2
a89 1
#include <errno.h>
a92 1

@


1.27
log
@Any sane platform has stdio. Stop pretending we will ever use a platform
that does not.
"fire bomb" tedu@@
@
text
@d1 1
a1 1
/* crypto/bio/bss_file.c */
@


1.26
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@a91 1
#if !defined(OPENSSL_NO_STDIO)
a325 1
#endif /* OPENSSL_NO_STDIO */
@


1.25
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d103 9
a111 10
	BIO_TYPE_FILE,
	"FILE pointer",
	file_write,
	file_read,
	file_puts,
	file_gets,
	file_ctrl,
	file_new,
	file_free,
	NULL,
@


1.24
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d125 1
a125 1
		ERR_add_error_data(5, "fopen('", filename, "', '", mode, "')");
d265 1
a265 1
			ERR_add_error_data(5, "fopen('", ptr, "', '", p, "')");
@


1.23
log
@some KNF cleanup following the script
@
text
@d249 2
a250 2
				BUF_strlcpy(p, "a+", sizeof p);
			else	BUF_strlcpy(p, "a", sizeof p);
d252 1
a252 1
			BUF_strlcpy(p, "r+", sizeof p);
d254 1
a254 1
			BUF_strlcpy(p, "w", sizeof p);
d256 1
a256 1
			BUF_strlcpy(p, "r", sizeof p);
@


1.22
log
@- Why do we hide from the OpenSSL police, dad?
- Because they're not like us, son. They use macros to wrap stdio routines,
  for an undocumented (OPENSSL_USE_APPLINK) use case, which only serves to
  obfuscate the code.

ok tedu@@
@
text
@d115 2
a116 2
BIO
*BIO_new_file(const char *filename, const char *mode)
d141 2
a142 2
BIO
*BIO_new_fp(FILE *stream, int close_flag)
d153 2
a154 2
BIO_METHOD
*BIO_s_file(void)
@


1.21
log
@> As I walk through the valley of the shadow of death
> I take a look at my life and realize there's nothin' left
> Cause I've been blasting and laughing so long,
> That even my mama thinks that my mind is gone
Remove even more unspeakable evil being perpetuated in the name of VMS.
(and lesser evils done in the name of others.)
ok miod
@
text
@d89 1
a89 1
#include "bio_lcl.h"
a136 1
	BIO_clear_flags(ret, BIO_FLAGS_UPLINK); /* we did fopen -> we disengage UPLINK */
a148 1
	BIO_set_flags(ret, BIO_FLAGS_UPLINK); /* redundant, left for documentation puposes */
d165 1
a165 1
	bi->flags=BIO_FLAGS_UPLINK; /* default to UPLINK */
d176 1
a176 4
			if (a->flags&BIO_FLAGS_UPLINK)
				UP_fclose (a->ptr);
			else
				fclose (a->ptr);
d178 1
a178 1
			a->flags = BIO_FLAGS_UPLINK;
d191 2
a192 6
		if (b->flags&BIO_FLAGS_UPLINK)
			ret = UP_fread(out, 1,(int)outl, b->ptr);
		else
			ret = fread(out, 1,(int)outl,(FILE *)b->ptr);
		if (ret == 0 && (b->flags & BIO_FLAGS_UPLINK) ?
		    UP_ferror((FILE *)b->ptr) : ferror((FILE *)b->ptr)) {
d207 1
a207 4
		if (b->flags&BIO_FLAGS_UPLINK)
			ret = UP_fwrite(in,(int)inl, 1, b->ptr);
		else
			ret = fwrite(in,(int)inl, 1,(FILE *)b->ptr);
d229 1
a229 4
		if (b->flags&BIO_FLAGS_UPLINK)
			ret = (long)UP_fseek(b->ptr, num, 0);
		else
			ret = (long)fseek(fp, num, 0);
d232 1
a232 4
		if (b->flags&BIO_FLAGS_UPLINK)
			ret = (long)UP_feof(fp);
		else
			ret = (long)feof(fp);
d236 1
a236 4
		if (b->flags&BIO_FLAGS_UPLINK)
			ret = UP_ftell(b->ptr);
		else
			ret = ftell(fp);
a242 12
#if BIO_FLAGS_UPLINK!=0
#if defined(_IOB_ENTRIES)
		/* Safety net to catch purely internal BIO_set_fp calls */
		if ((size_t)ptr >= (size_t)stdin &&
			(size_t)ptr <  (size_t)(stdin + _IOB_ENTRIES))
		BIO_clear_flags(b, BIO_FLAGS_UPLINK);
#endif
#endif
#ifdef UP_fsetmod
		if (b->flags&BIO_FLAGS_UPLINK)
			UP_fsetmod(b->ptr,(char)((num&BIO_FP_TEXT)?'t':'b'));
#endif
a271 1
		BIO_clear_flags(b, BIO_FLAGS_UPLINK); /* we did fopen -> we disengage UPLINK */
d287 1
a287 4
		if (b->flags&BIO_FLAGS_UPLINK)
			UP_fflush(b->ptr);
		else
			fflush((FILE *)b->ptr);
d310 2
a311 7
	if (bp->flags&BIO_FLAGS_UPLINK) {
		if (!UP_fgets(buf, size, bp->ptr))
			goto err;
	} else {
		if (!fgets(buf, size,(FILE *)bp->ptr))
			goto err;
	}
@


1.20
log
@Toss a `unifdef -U OPENSSL_SYS_WINDOWS' bomb into crypto/bio.

ok miod@@
@
text
@a91 4
#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)
#include <nwfileio.h>
#endif

a120 37
#if defined(_WIN32) && defined(CP_UTF8)
	int sz, len_0 = (int)strlen(filename) + 1;
	DWORD flags;

	/*
	 * Basically there are three cases to cover: a) filename is
	 * pure ASCII string; b) actual UTF-8 encoded string and
	 * c) locale-ized string, i.e. one containing 8-bit
	 * characters that are meaningful in current system locale.
	 * If filename is pure ASCII or real UTF-8 encoded string,
	 * MultiByteToWideChar succeeds and _wfopen works. If
	 * filename is locale-ized string, chances are that
	 * MultiByteToWideChar fails reporting
	 * ERROR_NO_UNICODE_TRANSLATION, in which case we fall
	 * back to fopen...
	 */
	if ((sz = MultiByteToWideChar(CP_UTF8,(flags = MB_ERR_INVALID_CHARS),
	    filename, len_0, NULL, 0)) > 0 ||
	    (GetLastError() == ERROR_INVALID_FLAGS &&
	    (sz = MultiByteToWideChar(CP_UTF8,(flags = 0),
	    filename, len_0, NULL, 0)) > 0)) {
		WCHAR  wmode[8];
		WCHAR *wfilename = _alloca(sz*sizeof(WCHAR));

		if (MultiByteToWideChar(CP_UTF8, flags, filename, len_0,
		    wfilename, sz) && MultiByteToWideChar(CP_UTF8, 0, mode,
		    strlen(mode) + 1, wmode,
		    sizeof(wmode) / sizeof(wmode[0])) &&
		    (file = _wfopen(wfilename, wmode)) == NULL &&
		    (errno == ENOENT || errno == EBADF)
		)	/* UTF - 8 decode succeeded, but no file, filename
			 * could still have been locale-ized... */
			file = fopen(filename, mode);
	} else if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION) {
		file = fopen(filename, mode);
	}
#else
a122 1
#endif
a264 3
#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)
#define _IOB_ENTRIES 20
#endif
a274 29
		else
#endif
		{
#if   defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)
			int fd = fileno((FILE*)ptr);
			/* Under CLib there are differences in file modes */
			if (num & BIO_FP_TEXT)
				setmode(fd, O_TEXT);
			else
				setmode(fd, O_BINARY);
#elif defined(OPENSSL_SYS_MSDOS)
			int fd = fileno((FILE*)ptr);
			/* Set correct text/binary mode */
			if (num & BIO_FP_TEXT)
				_setmode(fd, _O_TEXT);
			/* Dangerous to set stdin/stdout to raw (unless redirected) */
			else {
				if (fd == STDIN_FILENO || fd == STDOUT_FILENO) {
					if (isatty(fd) <= 0)
						_setmode(fd, _O_BINARY);
				} else
					_setmode(fd, _O_BINARY);
			}
#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)
			int fd = fileno((FILE*)ptr);
			if (num & BIO_FP_TEXT)
				setmode(fd, O_TEXT);
			else
				setmode(fd, O_BINARY);
a275 1
		}
a294 12
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)
		if (!(num & BIO_FP_TEXT))
			strcat(p, "b");
		else
			strcat(p, "t");
#endif
#if defined(OPENSSL_SYS_NETWARE)
		if (!(num & BIO_FP_TEXT))
			strcat(p, "b");
		else
			strcat(p, "t");
#endif
@


1.19
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d323 1
a323 7
#if defined(OPENSSL_SYS_WINDOWS)
			int fd = _fileno((FILE*)ptr);
			if (num & BIO_FP_TEXT)
				_setmode(fd, _O_TEXT);
			else
				_setmode(fd, _O_BINARY);
#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)
@


1.18
log
@Remove various horrible socket syscall wrappers, especially SHUTDOWN*
which did shutdown + close, all nasty and surprising.  Use the raw
syscalls that everyone knows the behaviour of.
ok beck matthew
@
text
@d105 2
a106 2
static BIO_METHOD methods_filep=
	{
d117 1
a117 1
	};
d119 3
a121 2
BIO *BIO_new_file(const char *filename, const char *mode)
	{
d123 1
a123 1
	FILE *file=NULL;
d126 1
a126 1
	int sz, len_0 = (int)strlen(filename)+1;
d141 5
a145 7
	if ((sz=MultiByteToWideChar(CP_UTF8,(flags=MB_ERR_INVALID_CHARS),
					filename,len_0,NULL,0))>0 ||
	    (GetLastError()==ERROR_INVALID_FLAGS &&
	     (sz=MultiByteToWideChar(CP_UTF8,(flags=0),
					filename,len_0,NULL,0))>0)
	   )
		{
d149 7
a155 7
		if (MultiByteToWideChar(CP_UTF8,flags,
					filename,len_0,wfilename,sz) &&
		    MultiByteToWideChar(CP_UTF8,0,mode,strlen(mode)+1,
			    		wmode,sizeof(wmode)/sizeof(wmode[0])) &&
		    (file=_wfopen(wfilename,wmode))==NULL &&
		    (errno==ENOENT || errno==EBADF)
		   )	/* UTF-8 decode succeeded, but no file, filename
d157 4
a160 6
			file = fopen(filename,mode);
		}
	else if (GetLastError()==ERROR_NO_UNICODE_TRANSLATION)
		{
		file = fopen(filename,mode);
		}
d162 2
a163 1
	file=fopen(filename,mode);	
d165 1
a165 2
	if (file == NULL)
		{
d167 1
a167 1
		ERR_add_error_data(5,"fopen('",filename,"','",mode,"')");
d169 1
a169 1
			BIOerr(BIO_F_BIO_NEW_FILE,BIO_R_NO_SUCH_FILE);
d171 4
a174 5
			BIOerr(BIO_F_BIO_NEW_FILE,ERR_R_SYS_LIB);
		return(NULL);
		}
	if ((ret=BIO_new(BIO_s_file())) == NULL)
		{
d176 1
a176 6
		return(NULL);
		}

	BIO_clear_flags(ret,BIO_FLAGS_UPLINK); /* we did fopen -> we disengage UPLINK */
	BIO_set_fp(ret,file,BIO_CLOSE);
	return(ret);
d179 8
a186 2
BIO *BIO_new_fp(FILE *stream, int close_flag)
	{
d189 2
a190 2
	if ((ret=BIO_new(BIO_s_file())) == NULL)
		return(NULL);
d192 17
a208 15
	BIO_set_flags(ret,BIO_FLAGS_UPLINK); /* redundant, left for documentation puposes */
	BIO_set_fp(ret,stream,close_flag);
	return(ret);
	}

BIO_METHOD *BIO_s_file(void)
	{
	return(&methods_filep);
	}

static int file_new(BIO *bi)
	{
	bi->init=0;
	bi->num=0;
	bi->ptr=NULL;
d210 2
a211 2
	return(1);
	}
d213 7
a219 7
static int file_free(BIO *a)
	{
	if (a == NULL) return(0);
	if (a->shutdown)
		{
		if ((a->init) && (a->ptr != NULL))
			{
d224 2
a225 4
			a->ptr=NULL;
			a->flags=BIO_FLAGS_UPLINK;
			}
		a->init=0;
d227 1
a227 1
	return(1);
d229 7
a235 4
	
static int file_read(BIO *b, char *out, int outl)
	{
	int ret=0;
d237 1
a237 2
	if (b->init && (out != NULL))
		{
d239 1
a239 1
			ret=UP_fread(out,1,(int)outl,b->ptr);
d241 3
a243 3
			ret=fread(out,1,(int)outl,(FILE *)b->ptr);
		if(ret == 0 && (b->flags&BIO_FLAGS_UPLINK)?UP_ferror((FILE *)b->ptr):ferror((FILE *)b->ptr))
			{
d245 2
a246 3
			BIOerr(BIO_F_FILE_READ,ERR_R_SYS_LIB);
			ret=-1;
			}
a247 1
	return(ret);
d249 2
d252 4
a255 3
static int file_write(BIO *b, const char *in, int inl)
	{
	int ret=0;
d257 1
a257 2
	if (b->init && (in != NULL))
		{
d259 1
a259 1
			ret=UP_fwrite(in,(int)inl,1,b->ptr);
d261 1
a261 1
			ret=fwrite(in,(int)inl,1,(FILE *)b->ptr);
d263 1
a263 1
			ret=inl;
a267 2
		}
	return(ret);
d269 2
d272 5
a276 4
static long file_ctrl(BIO *b, int cmd, long num, void *ptr)
	{
	long ret=1;
	FILE *fp=(FILE *)b->ptr;
d280 1
a280 2
	switch (cmd)
		{
d284 1
a284 1
			ret=(long)UP_fseek(b->ptr,num,0);
d286 1
a286 1
			ret=(long)fseek(fp,num,0);
d290 1
a290 1
			ret=(long)UP_feof(fp);
d292 1
a292 1
			ret=(long)feof(fp);
d297 1
a297 1
			ret=UP_ftell(b->ptr);
d299 1
a299 1
			ret=ftell(fp);
d303 3
a305 3
		b->shutdown=(int)num&BIO_CLOSE;
		b->ptr=ptr;
		b->init=1;
d313 2
a314 2
		    (size_t)ptr <  (size_t)(stdin+_IOB_ENTRIES))
			BIO_clear_flags(b,BIO_FLAGS_UPLINK);
d324 5
a328 5
		int fd = _fileno((FILE*)ptr);
		if (num & BIO_FP_TEXT)
			_setmode(fd,_O_TEXT);
		else
			_setmode(fd,_O_BINARY);
d330 6
a335 6
		int fd = fileno((FILE*)ptr);
		/* Under CLib there are differences in file modes */
		if (num & BIO_FP_TEXT)
			setmode(fd,O_TEXT);
		else
			setmode(fd,O_BINARY);
d337 11
a347 14
		int fd = fileno((FILE*)ptr);
		/* Set correct text/binary mode */
		if (num & BIO_FP_TEXT)
			_setmode(fd,_O_TEXT);
		/* Dangerous to set stdin/stdout to raw (unless redirected) */
		else
			{
			if (fd == STDIN_FILENO || fd == STDOUT_FILENO)
				{
				if (isatty(fd) <= 0)
					_setmode(fd,_O_BINARY);
				}
			else
				_setmode(fd,_O_BINARY);
d350 5
a354 5
		int fd = fileno((FILE*)ptr);
		if (num & BIO_FP_TEXT)
			setmode(fd, O_TEXT);
		else
			setmode(fd, O_BINARY);
d360 2
a361 3
		b->shutdown=(int)num&BIO_CLOSE;
		if (num & BIO_FP_APPEND)
			{
d363 4
a366 5
				BUF_strlcpy(p,"a+",sizeof p);
			else	BUF_strlcpy(p,"a",sizeof p);
			}
		else if ((num & BIO_FP_READ) && (num & BIO_FP_WRITE))
			BUF_strlcpy(p,"r+",sizeof p);
d368 1
a368 1
			BUF_strlcpy(p,"w",sizeof p);
d370 4
a373 5
			BUF_strlcpy(p,"r",sizeof p);
		else
			{
			BIOerr(BIO_F_FILE_CTRL,BIO_R_BAD_FOPEN_MODE);
			ret=0;
d375 1
a375 1
			}
d378 1
a378 1
			strcat(p,"b");
d380 1
a380 1
			strcat(p,"t");
d384 1
a384 1
			strcat(p,"b");
d386 1
a386 1
			strcat(p,"t");
d388 2
a389 3
		fp=fopen(ptr,p);
		if (fp == NULL)
			{
d391 3
a393 3
			ERR_add_error_data(5,"fopen('",ptr,"','",p,"')");
			BIOerr(BIO_F_FILE_CTRL,ERR_R_SYS_LIB);
			ret=0;
d395 4
a398 4
			}
		b->ptr=fp;
		b->init=1;
		BIO_clear_flags(b,BIO_FLAGS_UPLINK); /* we did fopen -> we disengage UPLINK */
d402 4
a405 5
		if (ptr != NULL)
			{
			fpp=(FILE **)ptr;
			*fpp=(FILE *)b->ptr;
			}
d408 1
a408 1
		ret=(long)b->shutdown;
d411 1
a411 1
		b->shutdown=(int)num;
d420 1
a420 1
		ret=1;
d428 1
a428 1
		ret=0;
a429 2
		}
	return(ret);
d431 2
d434 8
a441 8
static int file_gets(BIO *bp, char *buf, int size)
	{
	int ret=0;

	buf[0]='\0';
	if (bp->flags&BIO_FLAGS_UPLINK)
		{
		if (!UP_fgets(buf,size,bp->ptr))
d443 2
a444 4
		}
	else
		{
		if (!fgets(buf,size,(FILE *)bp->ptr))
d446 1
a446 1
		}
d448 14
a461 13
		ret=strlen(buf);
	err:
	return(ret);
	}

static int file_puts(BIO *bp, const char *str)
	{
	int n,ret;

	n=strlen(str);
	ret=file_write(bp,str,n);
	return(ret);
	}
a465 2


@


1.17
log
@Remove some stuff that isn't needed.
ok miod@@ deraadt@@
@
text
@d169 1
a169 1
		SYSerr(SYS_F_FOPEN,get_last_sys_error());
d245 1
a245 1
			SYSerr(SYS_F_FREAD,get_last_sys_error());
d398 1
a398 1
			SYSerr(SYS_F_FOPEN,get_last_sys_error());
@


1.16
log
@openssl-1.0.0e: resolve conflicts
@
text
@d98 7
a104 7
static int MS_CALLBACK file_write(BIO *h, const char *buf, int num);
static int MS_CALLBACK file_read(BIO *h, char *buf, int size);
static int MS_CALLBACK file_puts(BIO *h, const char *str);
static int MS_CALLBACK file_gets(BIO *h, char *str, int size);
static long MS_CALLBACK file_ctrl(BIO *h, int cmd, long arg1, void *arg2);
static int MS_CALLBACK file_new(BIO *h);
static int MS_CALLBACK file_free(BIO *data);
d205 1
a205 1
static int MS_CALLBACK file_new(BIO *bi)
d214 1
a214 1
static int MS_CALLBACK file_free(BIO *a)
d233 1
a233 1
static int MS_CALLBACK file_read(BIO *b, char *out, int outl)
d253 1
a253 1
static int MS_CALLBACK file_write(BIO *b, const char *in, int inl)
d273 1
a273 1
static long MS_CALLBACK file_ctrl(BIO *b, int cmd, long num, void *ptr)
d443 1
a443 1
static int MS_CALLBACK file_gets(BIO *bp, char *buf, int size)
d464 1
a464 1
static int MS_CALLBACK file_puts(BIO *bp, const char *str)
@


1.15
log
@resolve conflicts, fix local changes
@
text
@d126 1
d140 4
a143 1
	if ((sz=MultiByteToWideChar(CP_UTF8,MB_ERR_INVALID_CHARS,
d145 1
d150 1
a150 1
		if (MultiByteToWideChar(CP_UTF8,MB_ERR_INVALID_CHARS,
d154 2
a155 1
		    (file=_wfopen(wfilename,wmode))==NULL && errno==ENOENT
@


1.14
log
@resolve conflicts
@
text
@d121 5
a125 2
	BIO *ret;
	FILE *file;
d127 35
a161 1
	if ((file=fopen(filename,mode)) == NULL)
d171 1
a171 1
	if ((ret=BIO_new(BIO_s_file_internal())) == NULL)
d281 1
a281 1
			ret=(long)fseek(fp,num,SEEK_SET);
d312 1
a312 1
#ifdef UP_fsetmode
d314 1
a314 1
			UP_fsetmode(b->ptr,num&BIO_FP_TEXT?'t':'b');
d326 1
a326 2
         /* Under CLib there are differences in file modes
         */
d347 1
a347 1
#elif defined(OPENSSL_SYS_OS2)
d443 4
a446 1
		UP_fgets(buf,size,bp->ptr);
d448 4
a451 1
		fgets(buf,size,(FILE *)bp->ptr);
d454 1
@


1.13
log
@resolve conflicts
@
text
@d282 1
a282 1
		int fd = fileno((FILE*)ptr);
@


1.12
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d68 18
d89 1
a89 1
#include <openssl/bio.h>
d92 4
d135 2
d138 1
d140 1
d152 1
d167 1
d178 4
a181 1
			fclose((FILE *)a->ptr);
d183 1
d196 5
a200 2
		ret=fread(out,1,(int)outl,(FILE *)b->ptr);
		if(ret == 0 && ferror((FILE *)b->ptr))
d216 5
a220 1
		if (fwrite(in,(int)inl,1,(FILE *)b->ptr))
d241 4
a244 1
		ret=(long)fseek(fp,num,SEEK_SET);
d247 4
a250 1
		ret=(long)feof(fp);
d254 4
a257 1
		ret=ftell(fp);
d262 1
a262 1
		b->ptr=(char *)ptr;
d264 16
d287 8
d347 6
d362 1
a362 1
		b->ptr=(char *)fp;
d364 1
d381 4
a384 1
		fflush((FILE *)b->ptr);
d406 4
a409 1
	fgets(buf,size,(FILE *)bp->ptr);
@


1.11
log
@resolve conflicts
@
text
@d202 1
a202 1
		ret=(long)fseek(fp,num,0);
@


1.10
log
@merge 0.9.7d
@
text
@d216 1
d218 1
d220 1
a220 1
			_setmode(fileno((FILE *)ptr),_O_TEXT);
d222 1
a222 1
			_setmode(fileno((FILE *)ptr),_O_BINARY);
a223 1
		{
a238 1
		}
d240 1
d242 1
a242 1
			setmode(fileno((FILE *)ptr), O_TEXT);
d244 1
a244 1
			setmode(fileno((FILE *)ptr), O_BINARY);
d246 1
d269 1
a269 1
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2)
@


1.9
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d252 2
a253 2
				strlcpy(p,"a+",sizeof p);
			else	strlcpy(p,"a",sizeof p);
d256 1
a256 1
			strlcpy(p,"r+",sizeof p);
d258 1
a258 1
			strlcpy(p,"w",sizeof p);
d260 1
a260 1
			strlcpy(p,"r",sizeof p);
@


1.8
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d216 1
a216 2
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS)
		/* Set correct text/binary mode */
d221 18
@


1.7
log
@str{cat,cpy}/sprintf cleanup. markus@@, deraadt@@ ok
@
text
@d250 1
a250 1
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS)
@


1.6
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d235 2
a236 2
				strcpy(p,"a+");
			else	strcpy(p,"a");
d239 1
a239 1
			strcpy(p,"r+");
d241 1
a241 1
			strcpy(p,"w");
d243 1
a243 1
			strcpy(p,"r");
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d165 6
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d74 1
a74 1
#if !defined(NO_STDIO)
d106 4
a109 1
		BIOerr(BIO_F_BIO_NEW_FILE,ERR_R_SYS_LIB);
d210 1
a210 1
#if defined(MSDOS) || defined(WINDOWS)
d216 5
d244 1
a244 1
#if defined(MSDOS) || defined(WINDOWS)
d314 1
a314 1
#endif /* NO_STDIO */
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d76 5
a80 5
static int MS_CALLBACK file_write(BIO *h,char *buf,int num);
static int MS_CALLBACK file_read(BIO *h,char *buf,int size);
static int MS_CALLBACK file_puts(BIO *h,char *str);
static int MS_CALLBACK file_gets(BIO *h,char *str,int size);
static long MS_CALLBACK file_ctrl(BIO *h,int cmd,long arg1,char *arg2);
d166 1
a166 1
static int MS_CALLBACK file_write(BIO *b, char *in, int inl)
d182 1
a182 1
static long MS_CALLBACK file_ctrl(BIO *b, int cmd, long num, char *ptr)
d297 1
a297 1
static int MS_CALLBACK file_puts(BIO *bp, char *str)
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d94 1
d175 1
a175 1
		/* acording to Tim Hudson <tjh@@cryptsoft.com>, the commented
@


1.1
log
@Initial revision
@
text
@d71 2
a72 2
#include "bio.h"
#include "err.h"
a75 1
#ifndef NOPROTO
a82 10
#else
static int MS_CALLBACK file_write();
static int MS_CALLBACK file_read();
static int MS_CALLBACK file_puts();
static int MS_CALLBACK file_gets();
static long MS_CALLBACK file_ctrl();
static int MS_CALLBACK file_new();
static int MS_CALLBACK file_free();
#endif

d96 1
a96 3
BIO *BIO_new_file(filename,mode)
char *filename;
char *mode;
d115 1
a115 3
BIO *BIO_new_fp(stream,close_flag)
FILE *stream;
int close_flag;
d126 1
a126 1
BIO_METHOD *BIO_s_file()
d131 1
a131 2
static int MS_CALLBACK file_new(bi)
BIO *bi;
d139 1
a139 2
static int MS_CALLBACK file_free(a)
BIO *a;
d154 1
a154 4
static int MS_CALLBACK file_read(b,out,outl)
BIO *b;
char *out;
int outl;
d165 1
a165 4
static int MS_CALLBACK file_write(b,in,inl)
BIO *b;
char *in;
int inl;
d181 1
a181 5
static long MS_CALLBACK file_ctrl(b,cmd,num,ptr)
BIO *b;
int cmd;
long num;
char *ptr;
d190 1
d197 1
d203 1
a203 1
		b->shutdown=(int)num;
d285 1
a285 4
static int MS_CALLBACK file_gets(bp,buf,size)
BIO *bp;
char *buf;
int size;
d296 1
a296 3
static int MS_CALLBACK file_puts(bp,str)
BIO *bp;
char *str;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d71 2
a72 2
#include <openssl/bio.h>
#include <openssl/err.h>
d74 1
a74 1
#if !defined(OPENSSL_NO_STDIO)
d76 6
a81 5
static int MS_CALLBACK file_write(BIO *h, const char *buf, int num);
static int MS_CALLBACK file_read(BIO *h, char *buf, int size);
static int MS_CALLBACK file_puts(BIO *h, const char *str);
static int MS_CALLBACK file_gets(BIO *h, char *str, int size);
static long MS_CALLBACK file_ctrl(BIO *h, int cmd, long arg1, void *arg2);
d84 10
a104 1
	NULL,
d107 3
a109 1
BIO *BIO_new_file(const char *filename, const char *mode)
d118 1
a118 4
		if (errno == ENOENT)
			BIOerr(BIO_F_BIO_NEW_FILE,BIO_R_NO_SUCH_FILE);
		else
			BIOerr(BIO_F_BIO_NEW_FILE,ERR_R_SYS_LIB);
d128 3
a130 1
BIO *BIO_new_fp(FILE *stream, int close_flag)
d141 1
a141 1
BIO_METHOD *BIO_s_file(void)
d146 2
a147 1
static int MS_CALLBACK file_new(BIO *bi)
d155 2
a156 1
static int MS_CALLBACK file_free(BIO *a)
d171 4
a174 1
static int MS_CALLBACK file_read(BIO *b, char *out, int outl)
d185 4
a188 1
static int MS_CALLBACK file_write(BIO *b, const char *in, int inl)
d197 1
a197 1
		/* according to Tim Hudson <tjh@@cryptsoft.com>, the commented
d204 5
a208 1
static long MS_CALLBACK file_ctrl(BIO *b, int cmd, long num, void *ptr)
a216 1
	case BIO_C_FILE_SEEK:
a222 1
	case BIO_C_FILE_TELL:
d228 1
a228 1
		b->shutdown=(int)num&BIO_CLOSE;
d231 1
a231 1
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS)
a236 5
#elif defined(OPENSSL_SYS_OS2)
		if (num & BIO_FP_TEXT)
			setmode(fileno((FILE *)ptr), O_TEXT);
		else
			setmode(fileno((FILE *)ptr), O_BINARY);
d260 1
a260 1
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS)
d310 4
a313 1
static int MS_CALLBACK file_gets(BIO *bp, char *buf, int size)
d324 3
a326 1
static int MS_CALLBACK file_puts(BIO *bp, const char *str)
d335 1
a335 1
#endif /* OPENSSL_NO_STDIO */
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a164 6
		if(ret == 0 && ferror((FILE *)b->ptr))
			{
			SYSerr(SYS_F_FREAD,get_last_sys_error());
			BIOerr(BIO_F_FILE_READ,ERR_R_SYS_LIB);
			ret=-1;
			}
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d250 1
a250 1
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2)
@


1.1.1.5
log
@import 0.9.7c
@
text
@d216 2
a217 1
#if defined(OPENSSL_SYS_WINDOWS)
a221 18
#elif defined(OPENSSL_SYS_MSDOS)
		{
		int fd = fileno((FILE*)ptr);
		/* Set correct text/binary mode */
		if (num & BIO_FP_TEXT)
			_setmode(fd,_O_TEXT);
		/* Dangerous to set stdin/stdout to raw (unless redirected) */
		else
			{
			if (fd == STDIN_FILENO || fd == STDOUT_FILENO)
				{
				if (isatty(fd) <= 0)
					_setmode(fd,_O_BINARY);
				}
			else
				_setmode(fd,_O_BINARY);
			}
		}
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d252 2
a253 2
				BUF_strlcpy(p,"a+",sizeof p);
			else	BUF_strlcpy(p,"a",sizeof p);
d256 1
a256 1
			BUF_strlcpy(p,"r+",sizeof p);
d258 1
a258 1
			BUF_strlcpy(p,"w",sizeof p);
d260 1
a260 1
			BUF_strlcpy(p,"r",sizeof p);
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a215 1
		{
a216 1
		int fd = fileno((FILE*)ptr);
d218 1
a218 1
			_setmode(fd,_O_TEXT);
d220 1
a220 1
			_setmode(fd,_O_BINARY);
d222 1
d238 1
a239 1
		int fd = fileno((FILE*)ptr);
d241 1
a241 1
			setmode(fd, O_TEXT);
d243 1
a243 1
			setmode(fd, O_BINARY);
a244 1
		}
d267 1
a267 1
#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@a67 18
#if defined(__linux) || defined(__sun) || defined(__hpux)
/* Following definition aliases fopen to fopen64 on above mentioned
 * platforms. This makes it possible to open and sequentially access
 * files larger than 2GB from 32-bit application. It does not allow to
 * traverse them beyond 2GB with fseek/ftell, but on the other hand *no*
 * 32-bit platform permits that, not with fseek/ftell. Not to mention
 * that breaking 2GB limit for seeking would require surgery to *our*
 * API. But sequential access suffices for practical cases when you
 * can run into large files, such as fingerprinting, so we can let API
 * alone. For reference, the list of 32-bit platforms which allow for
 * sequential access of large files without extra "magic" comprise *BSD,
 * Darwin, IRIX...
 */
#ifndef _FILE_OFFSET_BITS
#define _FILE_OFFSET_BITS 64
#endif
#endif

d71 1
a71 1
#include "bio_lcl.h"
a73 4
#if defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)
#include <nwfileio.h>
#endif

a112 2
		{
		fclose(file);
a113 1
		}
a114 1
	BIO_clear_flags(ret,BIO_FLAGS_UPLINK); /* we did fopen -> we disengage UPLINK */
a125 1
	BIO_set_flags(ret,BIO_FLAGS_UPLINK); /* redundant, left for documentation puposes */
a139 1
	bi->flags=BIO_FLAGS_UPLINK; /* default to UPLINK */
d150 1
a150 4
			if (a->flags&BIO_FLAGS_UPLINK)
				UP_fclose (a->ptr);
			else
				fclose (a->ptr);
a151 1
			a->flags=BIO_FLAGS_UPLINK;
d164 2
a165 5
		if (b->flags&BIO_FLAGS_UPLINK)
			ret=UP_fread(out,1,(int)outl,b->ptr);
		else
			ret=fread(out,1,(int)outl,(FILE *)b->ptr);
		if(ret == 0 && (b->flags&BIO_FLAGS_UPLINK)?UP_ferror((FILE *)b->ptr):ferror((FILE *)b->ptr))
d181 1
a181 5
		if (b->flags&BIO_FLAGS_UPLINK)
			ret=UP_fwrite(in,(int)inl,1,b->ptr);
		else
			ret=fwrite(in,(int)inl,1,(FILE *)b->ptr);
		if (ret)
d202 1
a202 4
		if (b->flags&BIO_FLAGS_UPLINK)
			ret=(long)UP_fseek(b->ptr,num,0);
		else
			ret=(long)fseek(fp,num,0);
d205 1
a205 4
		if (b->flags&BIO_FLAGS_UPLINK)
			ret=(long)UP_feof(fp);
		else
			ret=(long)feof(fp);
d209 1
a209 4
		if (b->flags&BIO_FLAGS_UPLINK)
			ret=UP_ftell(b->ptr);
		else
			ret=ftell(fp);
d214 1
a214 1
		b->ptr=ptr;
a215 16
#if BIO_FLAGS_UPLINK!=0
#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)
#define _IOB_ENTRIES 20
#endif
#if defined(_IOB_ENTRIES)
		/* Safety net to catch purely internal BIO_set_fp calls */
		if ((size_t)ptr >= (size_t)stdin &&
		    (size_t)ptr <  (size_t)(stdin+_IOB_ENTRIES))
			BIO_clear_flags(b,BIO_FLAGS_UPLINK);
#endif
#endif
#ifdef UP_fsetmode
		if (b->flags&BIO_FLAGS_UPLINK)
			UP_fsetmode(b->ptr,num&BIO_FP_TEXT?'t':'b');
		else
#endif
a222 8
#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)
		int fd = fileno((FILE*)ptr);
         /* Under CLib there are differences in file modes
         */
		if (num & BIO_FP_TEXT)
			setmode(fd,O_TEXT);
		else
			setmode(fd,O_BINARY);
a274 6
#if defined(OPENSSL_SYS_NETWARE)
		if (!(num & BIO_FP_TEXT))
			strcat(p,"b");
		else
			strcat(p,"t");
#endif
d284 1
a284 1
		b->ptr=fp;
a285 1
		BIO_clear_flags(b,BIO_FLAGS_UPLINK); /* we did fopen -> we disengage UPLINK */
d302 1
a302 4
		if (b->flags&BIO_FLAGS_UPLINK)
			UP_fflush(b->ptr);
		else
			fflush((FILE *)b->ptr);
d324 1
a324 4
	if (bp->flags&BIO_FLAGS_UPLINK)
		UP_fgets(buf,size,bp->ptr);
	else
		fgets(buf,size,(FILE *)bp->ptr);
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@d282 1
a282 1
		int fd = _fileno((FILE*)ptr);
@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@d121 2
a122 5
	BIO  *ret;
	FILE *file=NULL;

#if defined(_WIN32) && defined(CP_UTF8)
	int sz, len_0 = (int)strlen(filename)+1;
d124 1
a124 35
	/*
	 * Basically there are three cases to cover: a) filename is
	 * pure ASCII string; b) actual UTF-8 encoded string and
	 * c) locale-ized string, i.e. one containing 8-bit
	 * characters that are meaningful in current system locale.
	 * If filename is pure ASCII or real UTF-8 encoded string,
	 * MultiByteToWideChar succeeds and _wfopen works. If
	 * filename is locale-ized string, chances are that
	 * MultiByteToWideChar fails reporting
	 * ERROR_NO_UNICODE_TRANSLATION, in which case we fall
	 * back to fopen...
	 */
	if ((sz=MultiByteToWideChar(CP_UTF8,MB_ERR_INVALID_CHARS,
					filename,len_0,NULL,0))>0)
		{
		WCHAR  wmode[8];
		WCHAR *wfilename = _alloca(sz*sizeof(WCHAR));

		if (MultiByteToWideChar(CP_UTF8,MB_ERR_INVALID_CHARS,
					filename,len_0,wfilename,sz) &&
		    MultiByteToWideChar(CP_UTF8,0,mode,strlen(mode)+1,
			    		wmode,sizeof(wmode)/sizeof(wmode[0])) &&
		    (file=_wfopen(wfilename,wmode))==NULL && errno==ENOENT
		   )	/* UTF-8 decode succeeded, but no file, filename
			 * could still have been locale-ized... */
			file = fopen(filename,mode);
		}
	else if (GetLastError()==ERROR_NO_UNICODE_TRANSLATION)
		{
		file = fopen(filename,mode);
		}
#else
	file=fopen(filename,mode);	
#endif
	if (file == NULL)
d134 1
a134 1
	if ((ret=BIO_new(BIO_s_file())) == NULL)
d275 1
a275 1
#ifdef UP_fsetmod
d277 1
a277 1
			UP_fsetmod(b->ptr,(char)((num&BIO_FP_TEXT)?'t':'b'));
d289 2
a290 1
		/* Under CLib there are differences in file modes */
d311 1
a311 1
#elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)
d407 1
a407 4
		{
		if (!UP_fgets(buf,size,bp->ptr))
			goto err;
		}
d409 1
a409 4
		{
		if (!fgets(buf,size,(FILE *)bp->ptr))
			goto err;
		}
a411 1
	err:
@


1.1.1.11
log
@import OpenSSL 1.0.0e
@
text
@a125 1
	DWORD flags;
d139 1
a139 4
	if ((sz=MultiByteToWideChar(CP_UTF8,(flags=MB_ERR_INVALID_CHARS),
					filename,len_0,NULL,0))>0 ||
	    (GetLastError()==ERROR_INVALID_FLAGS &&
	     (sz=MultiByteToWideChar(CP_UTF8,(flags=0),
a140 1
	   )
d145 1
a145 1
		if (MultiByteToWideChar(CP_UTF8,flags,
d149 1
a149 2
		    (file=_wfopen(wfilename,wmode))==NULL &&
		    (errno==ENOENT || errno==EBADF)
@


