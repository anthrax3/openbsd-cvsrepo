head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22;
locks; strict;
comment	@ * @;


1.22
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.21;
commitid	kT0fLt3r4lroFJra;

1.21
date	2015.07.18.21.21.28;	author beck;	state Exp;
branches;
next	1.20;
commitid	HWCs3xBbgfOVshNw;

1.20
date	2015.02.10.11.22.21;	author jsing;	state Exp;
branches;
next	1.19;
commitid	LaAI4ax0sm4T2bQg;

1.19
date	2014.10.28.05.46.56;	author miod;	state Exp;
branches;
next	1.18;
commitid	hDZmp09ZEY5wcTE1;

1.18
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	mJUVYpkFBZ0Zv2bG;

1.17
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	2nvnQBrv22dLtvTt;

1.16
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.25.13.32.51;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.24.09.16.08;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.19.16.42.26;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.17.20.42.18;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.29.05.39.23;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.15;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.53;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.15.06.18.40;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.19.11.10.48;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	99.09.29.04.36.25;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.40;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2005.04.29.05.37.12;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.08;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: o_names.c,v 1.21 2015/07/18 21:21:28 beck Exp $ */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/err.h>
#include <openssl/lhash.h>
#include <openssl/objects.h>
#include <openssl/safestack.h>

/* I use the ex_data stuff to manage the identifiers for the obj_name_types
 * that applications may define.  I only really use the free function field.
 */
DECLARE_LHASH_OF(OBJ_NAME);
static LHASH_OF(OBJ_NAME) *names_lh = NULL;
static int names_type_num = OBJ_NAME_TYPE_NUM;

typedef struct name_funcs_st {
	unsigned long (*hash_func)(const char *name);
	int (*cmp_func)(const char *a, const char *b);
	void (*free_func)(const char *, int, const char *);
} NAME_FUNCS;

DECLARE_STACK_OF(NAME_FUNCS)

static STACK_OF(NAME_FUNCS) *name_funcs_stack;

/* The LHASH callbacks now use the raw "void *" prototypes and do per-variable
 * casting in the functions. This prevents function pointer casting without the
 * need for macro-generated wrapper functions. */

/* static unsigned long obj_name_hash(OBJ_NAME *a); */
static unsigned long obj_name_hash(const void *a_void);
/* static int obj_name_cmp(OBJ_NAME *a,OBJ_NAME *b); */
static int obj_name_cmp(const void *a_void, const void *b_void);

static IMPLEMENT_LHASH_HASH_FN(obj_name, OBJ_NAME)
static IMPLEMENT_LHASH_COMP_FN(obj_name, OBJ_NAME)

int
OBJ_NAME_init(void)
{
	if (names_lh != NULL)
		return (1);
	names_lh = lh_OBJ_NAME_new();
	return (names_lh != NULL);
}

int
OBJ_NAME_new_index(unsigned long (*hash_func)(const char *),
    int (*cmp_func)(const char *, const char *),
    void (*free_func)(const char *, int, const char *))
{
	int ret;
	int i;
	NAME_FUNCS *name_funcs;

	if (name_funcs_stack == NULL)
		name_funcs_stack = sk_NAME_FUNCS_new_null();
	if (name_funcs_stack == NULL)
		return (0);

	ret = names_type_num;
	names_type_num++;
	for (i = sk_NAME_FUNCS_num(name_funcs_stack); i < names_type_num; i++) {
		name_funcs = malloc(sizeof(NAME_FUNCS));
		if (!name_funcs) {
			OBJerror(ERR_R_MALLOC_FAILURE);
			return (0);
		}
		name_funcs->hash_func = lh_strhash;
		name_funcs->cmp_func = strcmp;
		name_funcs->free_func = NULL;
		if (sk_NAME_FUNCS_push(name_funcs_stack, name_funcs) == 0) {
			free(name_funcs);
			OBJerror(ERR_R_MALLOC_FAILURE);
			return (0);
		}
	}
	name_funcs = sk_NAME_FUNCS_value(name_funcs_stack, ret);
	if (hash_func != NULL)
		name_funcs->hash_func = hash_func;
	if (cmp_func != NULL)
		name_funcs->cmp_func = cmp_func;
	if (free_func != NULL)
		name_funcs->free_func = free_func;
	return (ret);
}

/* static int obj_name_cmp(OBJ_NAME *a, OBJ_NAME *b) */
static int
obj_name_cmp(const void *a_void, const void *b_void)
{
	int ret;
	const OBJ_NAME *a = (const OBJ_NAME *)a_void;
	const OBJ_NAME *b = (const OBJ_NAME *)b_void;

	ret = a->type - b->type;
	if (ret == 0) {
		if ((name_funcs_stack != NULL) &&
		    (sk_NAME_FUNCS_num(name_funcs_stack) > a->type)) {
			ret = sk_NAME_FUNCS_value(name_funcs_stack,
			    a->type)->cmp_func(a->name, b->name);
		} else
			ret = strcmp(a->name, b->name);
	}
	return (ret);
}

/* static unsigned long obj_name_hash(OBJ_NAME *a) */
static unsigned long
obj_name_hash(const void *a_void)
{
	unsigned long ret;
	const OBJ_NAME *a = (const OBJ_NAME *)a_void;

	if ((name_funcs_stack != NULL) &&
	    (sk_NAME_FUNCS_num(name_funcs_stack) > a->type)) {
		ret = sk_NAME_FUNCS_value(name_funcs_stack,
		    a->type)->hash_func(a->name);
	} else {
		ret = lh_strhash(a->name);
	}
	ret ^= a->type;
	return (ret);
}

const char *
OBJ_NAME_get(const char *name, int type)
{
	OBJ_NAME on, *ret;
	int num = 0, alias;

	if (name == NULL)
		return (NULL);
	if ((names_lh == NULL) && !OBJ_NAME_init())
		return (NULL);

	alias = type&OBJ_NAME_ALIAS;
	type&= ~OBJ_NAME_ALIAS;

	on.name = name;
	on.type = type;

	for (;;) {
		ret = lh_OBJ_NAME_retrieve(names_lh, &on);
		if (ret == NULL)
			return (NULL);
		if ((ret->alias) && !alias) {
			if (++num > 10)
				return (NULL);
			on.name = ret->data;
		} else {
			return (ret->data);
		}
	}
}

int
OBJ_NAME_add(const char *name, int type, const char *data)
{
	OBJ_NAME *onp, *ret;
	int alias;

	if ((names_lh == NULL) && !OBJ_NAME_init())
		return (0);

	alias = type & OBJ_NAME_ALIAS;
	type &= ~OBJ_NAME_ALIAS;

	onp = malloc(sizeof(OBJ_NAME));
	if (onp == NULL) {
		/* ERROR */
		return (0);
	}

	onp->name = name;
	onp->alias = alias;
	onp->type = type;
	onp->data = data;

	ret = lh_OBJ_NAME_insert(names_lh, onp);
	if (ret != NULL) {
		/* free things */
		if ((name_funcs_stack != NULL) &&
		    (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type)) {
			/* XXX: I'm not sure I understand why the free
			 * function should get three arguments...
			 * -- Richard Levitte
			 */
			sk_NAME_FUNCS_value(
			    name_funcs_stack, ret->type)->free_func(
			    ret->name, ret->type, ret->data);
		}
		free(ret);
	} else {
		if (lh_OBJ_NAME_error(names_lh)) {
			/* ERROR */
			return (0);
		}
	}
	return (1);
}

int
OBJ_NAME_remove(const char *name, int type)
{
	OBJ_NAME on, *ret;

	if (names_lh == NULL)
		return (0);

	type &= ~OBJ_NAME_ALIAS;
	on.name = name;
	on.type = type;
	ret = lh_OBJ_NAME_delete(names_lh, &on);
	if (ret != NULL) {
		/* free things */
		if ((name_funcs_stack != NULL) &&
		    (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type)) {
			/* XXX: I'm not sure I understand why the free
			 * function should get three arguments...
			 * -- Richard Levitte
			 */
			sk_NAME_FUNCS_value(
			    name_funcs_stack, ret->type)->free_func(
			    ret->name, ret->type, ret->data);
		}
		free(ret);
		return (1);
	} else
		return (0);
}

struct doall {
	int type;
	void (*fn)(const OBJ_NAME *, void *arg);
	void *arg;
};

static void
do_all_fn_doall_arg(const OBJ_NAME *name, struct doall *d)
{
	if (name->type == d->type)
		d->fn(name, d->arg);
}

static IMPLEMENT_LHASH_DOALL_ARG_FN(do_all_fn, const OBJ_NAME, struct doall)

void
OBJ_NAME_do_all(int type, void (*fn)(const OBJ_NAME *, void *arg), void *arg)
{
	struct doall d;

	d.type = type;
	d.fn = fn;
	d.arg = arg;

	lh_OBJ_NAME_doall_arg(names_lh, LHASH_DOALL_ARG_FN(do_all_fn),
	    struct doall, &d);
}

struct doall_sorted {
	int type;
	int n;
	const OBJ_NAME **names;
};

static void
do_all_sorted_fn(const OBJ_NAME *name, void *d_)
{
	struct doall_sorted *d = d_;

	if (name->type != d->type)
		return;

	d->names[d->n++] = name;
}

static int
do_all_sorted_cmp(const void *n1_, const void *n2_)
{
	const OBJ_NAME * const *n1 = n1_;
	const OBJ_NAME * const *n2 = n2_;

	return strcmp((*n1)->name, (*n2)->name);
}

void
OBJ_NAME_do_all_sorted(int type, void (*fn)(const OBJ_NAME *, void *arg),
    void *arg)
{
	struct doall_sorted d;
	int n;

	d.type = type;
	d.names = reallocarray(NULL, lh_OBJ_NAME_num_items(names_lh),
	    sizeof *d.names);
	d.n = 0;
	if (d.names != NULL) {
		OBJ_NAME_do_all(type, do_all_sorted_fn, &d);

		qsort((void *)d.names, d.n, sizeof *d.names, do_all_sorted_cmp);

		for (n = 0; n < d.n; ++n)
			fn(d.names[n], arg);

		free(d.names);
	}
}

static int free_type;

static void
names_lh_free_doall(OBJ_NAME *onp)
{
	if (onp == NULL)
		return;

	if (free_type < 0 || free_type == onp->type)
		OBJ_NAME_remove(onp->name, onp->type);
}

static IMPLEMENT_LHASH_DOALL_FN(names_lh_free, OBJ_NAME)

static void
name_funcs_free(NAME_FUNCS *ptr)
{
	free(ptr);
}

void
OBJ_NAME_cleanup(int type)
{
	unsigned long down_load;

	if (names_lh == NULL)
		return;

	free_type = type;
	down_load = lh_OBJ_NAME_down_load(names_lh);
	lh_OBJ_NAME_down_load(names_lh) = 0;

	lh_OBJ_NAME_doall(names_lh, LHASH_DOALL_FN(names_lh_free));
	if (type < 0) {
		lh_OBJ_NAME_free(names_lh);
		sk_NAME_FUNCS_pop_free(name_funcs_stack, name_funcs_free);
		names_lh = NULL;
		name_funcs_stack = NULL;
	} else
		lh_OBJ_NAME_down_load(names_lh) = down_load;
}
@


1.21
log
@Coverity ID 78910 - Yet another stupid API designed to not show failures. do the
lease worst alternative and do nothing rather than dereference NULL, but having
a function with fundamentally broken API to simply make a list of strings, sort them,
and call a function with each string as an argument is really quite silly....

and of course it was exposed API that the ecosystem uses that we can't delete.. yet.

ok miod@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: o_names.c,v 1.20 2015/02/10 11:22:21 jsing Exp $ */
d70 1
a70 1
			OBJerr(OBJ_F_OBJ_NAME_NEW_INDEX, ERR_R_MALLOC_FAILURE);
d78 1
a78 1
			OBJerr(OBJ_F_OBJ_NAME_NEW_INDEX, ERR_R_MALLOC_FAILURE);
@


1.20
log
@Remove more IMPLEMENT_STACK_OF noops that have been hiding for the last
15 years.
@
text
@d1 1
a1 1
/* $OpenBSD: o_names.c,v 1.19 2014/10/28 05:46:56 miod Exp $ */
d302 2
a303 1
	OBJ_NAME_do_all(type, do_all_sorted_fn, &d);
d305 1
a305 1
	qsort((void *)d.names, d.n, sizeof *d.names, do_all_sorted_cmp);
d307 2
a308 2
	for (n = 0; n < d.n; ++n)
		fn(d.names[n], arg);
d310 2
a311 1
	free((void *)d.names);
@


1.19
log
@Check the result of sk_*_push() operations for failure.
ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: o_names.c,v 1.18 2014/06/12 15:49:30 deraadt Exp $ */
a26 1
IMPLEMENT_STACK_OF(NAME_FUNCS)
@


1.18
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d77 5
a81 1
		sk_NAME_FUNCS_push(name_funcs_stack, name_funcs);
@


1.17
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
@


1.16
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d169 1
a169 1
	onp = (OBJ_NAME *)malloc(sizeof(OBJ_NAME));
@


1.15
log
@Turn off MemCheck_on and MemCheck_off. These calls are pointless since the
crypto memory debugging code has been castrated.

ok miod@@ "kill it" beck@@
@
text
@d295 2
a296 1
	d.names = malloc(lh_OBJ_NAME_num_items(names_lh)*sizeof *d.names);
@


1.14
log
@Almost nothing actually needs to include <openssl/e_os2.h>, however by
including it they get <openssl/opensslconf.h>. So instead of pulling in
<openssl/e_os2.h>, just pull in <openssl/opensslconf.h>.

"go ahead" miod@@
@
text
@a46 1
	MemCheck_off();
a47 1
	MemCheck_on();
d60 1
a60 2
	if (name_funcs_stack == NULL) {
		MemCheck_off();
d62 1
a62 4
		MemCheck_on();
	}
	if (name_funcs_stack == NULL) {
		/* ERROR */
d64 1
a64 1
	}
a67 1
		MemCheck_off();
a68 1
		MemCheck_on();
a75 1
		MemCheck_off();
a76 1
		MemCheck_on();
@


1.13
log
@KNF.
@
text
@d5 2
a10 1
#include <openssl/e_os2.h>
@


1.12
log
@a little less obfuscation
@
text
@d15 2
a16 2
static LHASH_OF(OBJ_NAME) *names_lh=NULL;
static int names_type_num=OBJ_NAME_TYPE_NUM;
d18 1
a18 2
typedef struct name_funcs_st
	{
d20 1
a20 1
	int (*cmp_func)(const char *a,const char *b);
d22 1
a22 1
	} NAME_FUNCS;
d36 1
a36 1
static int obj_name_cmp(const void *a_void,const void *b_void);
d41 5
a45 3
int OBJ_NAME_init(void)
	{
	if (names_lh != NULL) return(1);
d47 1
a47 1
	names_lh=lh_OBJ_NAME_new();
d49 2
a50 2
	return(names_lh != NULL);
	}
d52 5
a56 4
int OBJ_NAME_new_index(unsigned long (*hash_func)(const char *),
	int (*cmp_func)(const char *, const char *),
	void (*free_func)(const char *, int, const char *))
	{
d61 1
a61 2
	if (name_funcs_stack == NULL)
		{
d63 1
a63 1
		name_funcs_stack=sk_NAME_FUNCS_new_null();
d65 2
a66 3
		}
	if (name_funcs_stack == NULL)
		{
d68 3
a70 3
		return(0);
		}
	ret=names_type_num;
d72 1
a72 2
	for (i=sk_NAME_FUNCS_num(name_funcs_stack); i<names_type_num; i++)
		{
d76 4
a79 5
		if (!name_funcs)
			{
			OBJerr(OBJ_F_OBJ_NAME_NEW_INDEX,ERR_R_MALLOC_FAILURE);
			return(0);
			}
d84 1
a84 1
		sk_NAME_FUNCS_push(name_funcs_stack,name_funcs);
d86 1
a86 1
		}
d94 2
a95 2
	return(ret);
	}
d98 3
a100 2
static int obj_name_cmp(const void *a_void, const void *b_void)
	{
d105 8
a112 13
	ret=a->type-b->type;
	if (ret == 0)
		{
		if ((name_funcs_stack != NULL)
			&& (sk_NAME_FUNCS_num(name_funcs_stack) > a->type))
			{
			ret=sk_NAME_FUNCS_value(name_funcs_stack,
				a->type)->cmp_func(a->name,b->name);
			}
		else
			ret=strcmp(a->name,b->name);
		}
	return(ret);
d114 2
d118 3
a120 2
static unsigned long obj_name_hash(const void *a_void)
	{
d124 21
a144 17
	if ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > a->type))
		{
		ret=sk_NAME_FUNCS_value(name_funcs_stack,
			a->type)->hash_func(a->name);
		}
	else
		{
		ret=lh_strhash(a->name);
		}
	ret^=a->type;
	return(ret);
	}

const char *OBJ_NAME_get(const char *name, int type)
	{
	OBJ_NAME on,*ret;
	int num=0,alias;
d146 1
a146 4
	if (name == NULL) return(NULL);
	if ((names_lh == NULL) && !OBJ_NAME_init()) return(NULL);

	alias=type&OBJ_NAME_ALIAS;
d149 2
a150 2
	on.name=name;
	on.type=type;
d152 18
a169 19
	for (;;)
	{
		ret=lh_OBJ_NAME_retrieve(names_lh,&on);
		if (ret == NULL) return(NULL);
		if ((ret->alias) && !alias)
			{
			if (++num > 10) return(NULL);
			on.name=ret->data;
			}
		else
			{
			return(ret->data);
			}
		}
	}

int OBJ_NAME_add(const char *name, int type, const char *data)
	{
	OBJ_NAME *onp,*ret;
d172 2
a173 1
	if ((names_lh == NULL) && !OBJ_NAME_init()) return(0);
d175 2
a176 2
	alias=type&OBJ_NAME_ALIAS;
	type&= ~OBJ_NAME_ALIAS;
d178 2
a179 3
	onp=(OBJ_NAME *)malloc(sizeof(OBJ_NAME));
	if (onp == NULL)
		{
d181 7
a187 2
		return(0);
		}
d189 2
a190 8
	onp->name=name;
	onp->alias=alias;
	onp->type=type;
	onp->data=data;

	ret=lh_OBJ_NAME_insert(names_lh,onp);
	if (ret != NULL)
		{
d192 2
a193 2
		if ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type))
			{
d198 4
a201 3
			sk_NAME_FUNCS_value(name_funcs_stack,
				ret->type)->free_func(ret->name,ret->type,ret->data);
			}
d203 2
a204 5
		}
	else
		{
		if (lh_OBJ_NAME_error(names_lh))
			{
d206 1
a206 2
			return(0);
			}
a207 1
	return(1);
d209 2
d212 4
a215 3
int OBJ_NAME_remove(const char *name, int type)
	{
	OBJ_NAME on,*ret;
d217 2
a218 1
	if (names_lh == NULL) return(0);
d220 5
a224 6
	type&= ~OBJ_NAME_ALIAS;
	on.name=name;
	on.type=type;
	ret=lh_OBJ_NAME_delete(names_lh,&on);
	if (ret != NULL)
		{
d226 2
a227 2
		if ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type))
			{
d232 4
a235 3
			sk_NAME_FUNCS_value(name_funcs_stack,
				ret->type)->free_func(ret->name,ret->type,ret->data);
			}
d237 4
a240 5
		return(1);
		}
	else
		return(0);
	}
d242 1
a242 2
struct doall
	{
d244 1
a244 1
	void (*fn)(const OBJ_NAME *,void *arg);
d246 1
a246 1
	};
d248 6
a253 5
static void do_all_fn_doall_arg(const OBJ_NAME *name,struct doall *d)
	{
	if(name->type == d->type)
		d->fn(name,d->arg);
	}
d257 3
a259 2
void OBJ_NAME_do_all(int type,void (*fn)(const OBJ_NAME *,void *arg),void *arg)
	{
d262 3
a264 3
	d.type=type;
	d.fn=fn;
	d.arg=arg;
d267 2
a268 2
			      struct doall, &d);
	}
d270 1
a270 2
struct doall_sorted
	{
d274 1
a274 1
	};
d276 4
a279 3
static void do_all_sorted_fn(const OBJ_NAME *name,void *d_)
	{
	struct doall_sorted *d=d_;
d281 1
a281 1
	if(name->type != d->type)
d284 2
a285 7
	d->names[d->n++]=name;
	}

static int do_all_sorted_cmp(const void *n1_,const void *n2_)
	{
	const OBJ_NAME * const *n1=n1_;
	const OBJ_NAME * const *n2=n2_;
d287 13
a299 6
	return strcmp((*n1)->name,(*n2)->name);
	}

void OBJ_NAME_do_all_sorted(int type,void (*fn)(const OBJ_NAME *,void *arg),
				void *arg)
	{
d303 4
a306 4
	d.type=type;
	d.names=malloc(lh_OBJ_NAME_num_items(names_lh)*sizeof *d.names);
	d.n=0;
	OBJ_NAME_do_all(type,do_all_sorted_fn,&d);
d308 1
a308 1
	qsort((void *)d.names,d.n,sizeof *d.names,do_all_sorted_cmp);
d310 2
a311 2
	for(n=0 ; n < d.n ; ++n)
		fn(d.names[n],arg);
d314 1
a314 1
	}
d318 3
a320 2
static void names_lh_free_doall(OBJ_NAME *onp)
	{
d325 2
a326 2
		OBJ_NAME_remove(onp->name,onp->type);
	}
d330 3
a332 2
static void name_funcs_free(NAME_FUNCS *ptr)
	{
d334 1
a334 1
	}
d336 3
a338 2
void OBJ_NAME_cleanup(int type)
	{
d341 6
a346 1
	if (names_lh == NULL) return;
d348 2
a349 7
	free_type=type;
	down_load=lh_OBJ_NAME_down_load(names_lh);
	lh_OBJ_NAME_down_load(names_lh)=0;

	lh_OBJ_NAME_doall(names_lh,LHASH_DOALL_FN(names_lh_free));
	if (type < 0)
		{
d351 2
a352 2
		sk_NAME_FUNCS_pop_free(name_funcs_stack,name_funcs_free);
		names_lh=NULL;
d354 3
a356 5
		}
	else
		lh_OBJ_NAME_down_load(names_lh)=down_load;
	}

@


1.11
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a10 11
/* Later versions of DEC C has started to add lnkage information to certain
 * functions, which makes it tricky to use them as values to regular function
 * pointers.  One way is to define a macro that takes care of casting them
 * correctly.
 */
#ifdef OPENSSL_SYS_VMS_DECC
# define OPENSSL_strcmp (int (*)(const char *,const char *))strcmp
#else
# define OPENSSL_strcmp strcmp
#endif

d83 2
a84 6
		name_funcs->cmp_func = OPENSSL_strcmp;
		name_funcs->free_func = 0; /* NULL is often declared to
						* ((void *)0), which according
						* to Compaq C is not really
						* compatible with a function
						* pointer.	-- Richard Levitte*/
@


1.10
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d86 1
a86 1
		name_funcs = OPENSSL_malloc(sizeof(NAME_FUNCS));
d195 1
a195 1
	onp=(OBJ_NAME *)OPENSSL_malloc(sizeof(OBJ_NAME));
d220 1
a220 1
		OPENSSL_free(ret);
d255 1
a255 1
		OPENSSL_free(ret);
d321 1
a321 1
	d.names=OPENSSL_malloc(lh_OBJ_NAME_num_items(names_lh)*sizeof *d.names);
d330 1
a330 1
	OPENSSL_free((void *)d.names);
d348 1
a348 1
	OPENSSL_free(ptr);
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d76 1
a76 1
	if ((name_funcs_stack == NULL))
@


1.8
log
@resolve conflicts
@
text
@d25 2
a26 1
static LHASH *names_lh=NULL;
d50 3
d57 1
a57 1
	names_lh=lh_new(obj_name_hash, obj_name_cmp);
d171 1
a171 1
		ret=(OBJ_NAME *)lh_retrieve(names_lh,&on);
d207 1
a207 1
	ret=(OBJ_NAME *)lh_insert(names_lh,onp);
d224 1
a224 1
		if (lh_error(names_lh))
d242 1
a242 1
	ret=(OBJ_NAME *)lh_delete(names_lh,&on);
d269 1
a269 1
static void do_all_fn(const OBJ_NAME *name,struct doall *d)
d275 1
a275 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(do_all_fn, const OBJ_NAME *, struct doall *)
d285 2
a286 1
	lh_doall_arg(names_lh,LHASH_DOALL_ARG_FN(do_all_fn),&d);
d321 1
a321 1
	d.names=OPENSSL_malloc(lh_num_items(names_lh)*sizeof *d.names);
d335 3
a337 3
static void names_lh_free(OBJ_NAME *onp)
{
	if(onp == NULL)
d340 1
a340 2
	if ((free_type < 0) || (free_type == onp->type))
		{
a341 1
		}
d344 1
a344 1
static IMPLEMENT_LHASH_DOALL_FN(names_lh_free, OBJ_NAME *)
d358 2
a359 2
	down_load=names_lh->down_load;
	names_lh->down_load=0;
d361 1
a361 1
	lh_doall(names_lh,LHASH_DOALL_FN(names_lh_free));
d364 1
a364 1
		lh_free(names_lh);
d370 1
a370 1
		names_lh->down_load=down_load;
@


1.7
log
@resolve conflicts
@
text
@d114 2
a115 2
	OBJ_NAME *a = (OBJ_NAME *)a_void;
	OBJ_NAME *b = (OBJ_NAME *)b_void;
d136 1
a136 1
	OBJ_NAME *a = (OBJ_NAME *)a_void;
@


1.6
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d5 1
d84 5
a88 1
		if (!name_funcs) return(0);
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d82 2
d91 1
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d8 12
d29 3
a31 3
	unsigned long (*hash_func)();
	int (*cmp_func)();
	void (*free_func)();
d39 8
a46 2
static unsigned long obj_name_hash(OBJ_NAME *a);
static int obj_name_cmp(OBJ_NAME *a,OBJ_NAME *b);
d52 1
a52 1
	names_lh=lh_new(obj_name_hash,obj_name_cmp);
d58 1
a58 1
	int (*cmp_func)(const void *, const void *),
d83 1
a83 1
		name_funcs->cmp_func = (int (*)())strcmp;
d85 4
a88 4
					    * ((void *)0), which according
					    * to Compaq C is not really
					    * compatible with a function
					    * pointer.  -- Richard Levitte*/
d102 2
a103 1
static int obj_name_cmp(OBJ_NAME *a, OBJ_NAME *b)
d106 2
d115 2
a116 2
			ret=sk_NAME_FUNCS_value(name_funcs_stack,a->type)
				->cmp_func(a->name,b->name);
d124 2
a125 1
static unsigned long obj_name_hash(OBJ_NAME *a)
d128 1
d132 2
a133 2
		ret=sk_NAME_FUNCS_value(name_funcs_stack,a->type)
			->hash_func(a->name);
d158 1
a158 1
		{
d205 2
a206 2
			sk_NAME_FUNCS_value(name_funcs_stack,ret->type)
				->free_func(ret->name,ret->type,ret->data);
d240 2
a241 2
			sk_NAME_FUNCS_value(name_funcs_stack,ret->type)
				->free_func(ret->name,ret->type,ret->data);
d250 70
d322 1
a322 1
static void names_lh_free(OBJ_NAME *onp, int type)
d325 1
a325 1
	    return;
d333 2
d350 1
a350 1
	lh_doall(names_lh,names_lh_free);
@


1.3
log
@OpenSSL 0.9.5a merge
@
text
@d39 3
a41 2
int OBJ_NAME_new_index(unsigned long (*hash_func)(), int (*cmp_func)(),
	     void (*free_func)())
d63 1
a63 1
		name_funcs = Malloc(sizeof(NAME_FUNCS));
d160 1
a160 1
	onp=(OBJ_NAME *)Malloc(sizeof(OBJ_NAME));
d185 1
a185 1
		Free(ret);
d220 1
a220 1
		Free(ret);
d242 1
a242 1
	Free(ptr);
@


1.2
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d25 1
a25 1
STACK_OF(NAME_FUNCS) *name_funcs_stack;
@


1.1
log
@OpenSSL 0.9.4 merge
@
text
@d7 1
d14 12
a25 3
static STACK *names_cmp=NULL;
static STACK *names_hash=NULL;
static STACK *names_free=NULL;
d44 1
d46 1
a46 1
	if (names_free == NULL)
d49 1
a49 3
		names_hash=sk_new_null();
		names_cmp=sk_new_null();
		names_free=sk_new_null();
d52 1
a52 1
	if ((names_free == NULL) || (names_hash == NULL) || (names_cmp == NULL))
d59 1
a59 1
	for (i=sk_num(names_free); i<names_type_num; i++)
d62 9
a70 3
		sk_push(names_hash,(char *)strcmp);
		sk_push(names_cmp,(char *)lh_strhash);
		sk_push(names_free,NULL);
d73 1
d75 1
a75 1
		sk_set(names_hash,ret,(char *)hash_func);
d77 1
a77 1
		sk_set(names_cmp,ret,(char *)cmp_func);
d79 1
a79 1
		sk_set(names_free,ret,(char *)free_func);
a85 1
	int (*cmp)();
d90 2
a91 1
		if ((names_cmp != NULL) && (sk_num(names_cmp) > a->type))
d93 2
a94 2
			cmp=(int (*)())sk_value(names_cmp,a->type);
			ret=cmp(a->name,b->name);
a104 1
	unsigned long (*hash)();
d106 1
a106 1
	if ((names_hash != NULL) && (sk_num(names_hash) > a->type))
d108 2
a109 2
		hash=(unsigned long (*)())sk_value(names_hash,a->type);
		ret=hash(a->name);
d135 1
a135 1
		ret=(OBJ_NAME *)lh_retrieve(names_lh,(char *)&on);
a150 1
	void (*f)();
d171 1
a171 1
	ret=(OBJ_NAME *)lh_insert(names_lh,(char *)onp);
d175 1
a175 1
		if ((names_free != NULL) && (sk_num(names_free) > ret->type))
d177 6
a182 2
			f=(void (*)())sk_value(names_free,ret->type);
			f(ret->name,ret->type,ret->data);
d184 1
a184 1
		Free((char *)ret);
a199 1
	void (*f)();
d206 1
a206 1
	ret=(OBJ_NAME *)lh_delete(names_lh,(char *)&on);
d210 1
a210 1
		if ((names_free != NULL) && (sk_num(names_free) > type))
d212 6
a217 2
			f=(void (*)())sk_value(names_free,type);
			f(ret->name,ret->type,ret->data);
d219 1
a219 1
		Free((char *)ret);
d239 5
d258 1
a258 3
		sk_free(names_hash);
		sk_free(names_cmp);
		sk_free(names_free);
d260 1
a260 3
		names_hash=NULL;
		names_cmp=NULL;
		names_free=NULL;
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@a6 13
#include <openssl/safestack.h>
#include <openssl/e_os2.h>

/* Later versions of DEC C has started to add lnkage information to certain
 * functions, which makes it tricky to use them as values to regular function
 * pointers.  One way is to define a macro that takes care of casting them
 * correctly.
 */
#ifdef OPENSSL_SYS_VMS_DECC
# define OPENSSL_strcmp (int (*)(const char *,const char *))strcmp
#else
# define OPENSSL_strcmp strcmp
#endif
d13 3
d17 2
a18 20
typedef struct name_funcs_st
	{
	unsigned long (*hash_func)(const char *name);
	int (*cmp_func)(const char *a,const char *b);
	void (*free_func)(const char *, int, const char *);
	} NAME_FUNCS;

DECLARE_STACK_OF(NAME_FUNCS)
IMPLEMENT_STACK_OF(NAME_FUNCS)

static STACK_OF(NAME_FUNCS) *name_funcs_stack;

/* The LHASH callbacks now use the raw "void *" prototypes and do per-variable
 * casting in the functions. This prevents function pointer casting without the
 * need for macro-generated wrapper functions. */

/* static unsigned long obj_name_hash(OBJ_NAME *a); */
static unsigned long obj_name_hash(const void *a_void);
/* static int obj_name_cmp(OBJ_NAME *a,OBJ_NAME *b); */
static int obj_name_cmp(const void *a_void,const void *b_void);
d24 1
a24 1
	names_lh=lh_new(obj_name_hash, obj_name_cmp);
d29 2
a30 3
int OBJ_NAME_new_index(unsigned long (*hash_func)(const char *),
	int (*cmp_func)(const char *, const char *),
	void (*free_func)(const char *, int, const char *))
a33 1
	NAME_FUNCS *name_funcs;
d35 1
a35 1
	if (name_funcs_stack == NULL)
d38 3
a40 1
		name_funcs_stack=sk_NAME_FUNCS_new_null();
d43 1
a43 1
	if ((name_funcs_stack == NULL))
d50 1
a50 1
	for (i=sk_NAME_FUNCS_num(name_funcs_stack); i<names_type_num; i++)
d53 3
a55 12
		name_funcs = OPENSSL_malloc(sizeof(NAME_FUNCS));
		MemCheck_on();
		if (!name_funcs) return(0);
		name_funcs->hash_func = lh_strhash;
		name_funcs->cmp_func = OPENSSL_strcmp;
		name_funcs->free_func = 0; /* NULL is often declared to
						* ((void *)0), which according
						* to Compaq C is not really
						* compatible with a function
						* pointer.	-- Richard Levitte*/
		MemCheck_off();
		sk_NAME_FUNCS_push(name_funcs_stack,name_funcs);
a57 1
	name_funcs = sk_NAME_FUNCS_value(name_funcs_stack, ret);
d59 1
a59 1
		name_funcs->hash_func = hash_func;
d61 1
a61 1
		name_funcs->cmp_func = cmp_func;
d63 1
a63 1
		name_funcs->free_func = free_func;
d67 1
a67 2
/* static int obj_name_cmp(OBJ_NAME *a, OBJ_NAME *b) */
static int obj_name_cmp(const void *a_void, const void *b_void)
d70 1
a70 2
	OBJ_NAME *a = (OBJ_NAME *)a_void;
	OBJ_NAME *b = (OBJ_NAME *)b_void;
d75 1
a75 2
		if ((name_funcs_stack != NULL)
			&& (sk_NAME_FUNCS_num(name_funcs_stack) > a->type))
d77 2
a78 2
			ret=sk_NAME_FUNCS_value(name_funcs_stack,
				a->type)->cmp_func(a->name,b->name);
d86 1
a86 2
/* static unsigned long obj_name_hash(OBJ_NAME *a) */
static unsigned long obj_name_hash(const void *a_void)
d89 1
a89 1
	OBJ_NAME *a = (OBJ_NAME *)a_void;
d91 1
a91 1
	if ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > a->type))
d93 2
a94 2
		ret=sk_NAME_FUNCS_value(name_funcs_stack,
			a->type)->hash_func(a->name);
d119 2
a120 2
	{
		ret=(OBJ_NAME *)lh_retrieve(names_lh,&on);
d136 1
d145 1
a145 1
	onp=(OBJ_NAME *)OPENSSL_malloc(sizeof(OBJ_NAME));
d157 1
a157 1
	ret=(OBJ_NAME *)lh_insert(names_lh,onp);
d161 1
a161 1
		if ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type))
d163 2
a164 6
			/* XXX: I'm not sure I understand why the free
			 * function should get three arguments...
			 * -- Richard Levitte
			 */
			sk_NAME_FUNCS_value(name_funcs_stack,
				ret->type)->free_func(ret->name,ret->type,ret->data);
d166 1
a166 1
		OPENSSL_free(ret);
d182 1
d189 1
a189 1
	ret=(OBJ_NAME *)lh_delete(names_lh,&on);
d193 1
a193 1
		if ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type))
d195 2
a196 6
			/* XXX: I'm not sure I understand why the free
			 * function should get three arguments...
			 * -- Richard Levitte
			 */
			sk_NAME_FUNCS_value(name_funcs_stack,
				ret->type)->free_func(ret->name,ret->type,ret->data);
d198 1
a198 1
		OPENSSL_free(ret);
a204 70
struct doall
	{
	int type;
	void (*fn)(const OBJ_NAME *,void *arg);
	void *arg;
	};

static void do_all_fn(const OBJ_NAME *name,struct doall *d)
	{
	if(name->type == d->type)
		d->fn(name,d->arg);
	}

static IMPLEMENT_LHASH_DOALL_ARG_FN(do_all_fn, const OBJ_NAME *, struct doall *)

void OBJ_NAME_do_all(int type,void (*fn)(const OBJ_NAME *,void *arg),void *arg)
	{
	struct doall d;

	d.type=type;
	d.fn=fn;
	d.arg=arg;

	lh_doall_arg(names_lh,LHASH_DOALL_ARG_FN(do_all_fn),&d);
	}

struct doall_sorted
	{
	int type;
	int n;
	const OBJ_NAME **names;
	};

static void do_all_sorted_fn(const OBJ_NAME *name,void *d_)
	{
	struct doall_sorted *d=d_;

	if(name->type != d->type)
		return;

	d->names[d->n++]=name;
	}

static int do_all_sorted_cmp(const void *n1_,const void *n2_)
	{
	const OBJ_NAME * const *n1=n1_;
	const OBJ_NAME * const *n2=n2_;

	return strcmp((*n1)->name,(*n2)->name);
	}

void OBJ_NAME_do_all_sorted(int type,void (*fn)(const OBJ_NAME *,void *arg),
				void *arg)
	{
	struct doall_sorted d;
	int n;

	d.type=type;
	d.names=OPENSSL_malloc(lh_num_items(names_lh)*sizeof *d.names);
	d.n=0;
	OBJ_NAME_do_all(type,do_all_sorted_fn,&d);

	qsort((void *)d.names,d.n,sizeof *d.names,do_all_sorted_cmp);

	for(n=0 ; n < d.n ; ++n)
		fn(d.names[n],arg);

	OPENSSL_free((void *)d.names);
	}

d207 1
a207 1
static void names_lh_free(OBJ_NAME *onp)
d210 1
a210 1
		return;
a217 7
static IMPLEMENT_LHASH_DOALL_FN(names_lh_free, OBJ_NAME *)

static void name_funcs_free(NAME_FUNCS *ptr)
	{
	OPENSSL_free(ptr);
	}

d228 1
a228 1
	lh_doall(names_lh,LHASH_DOALL_FN(names_lh_free));
d232 3
a234 1
		sk_NAME_FUNCS_pop_free(name_funcs_stack,name_funcs_free);
d236 3
a238 1
		name_funcs_stack = NULL;
@


1.1.1.2
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a4 1
#include <openssl/err.h>
d83 1
a83 5
		if (!name_funcs)
			{
			OBJerr(OBJ_F_OBJ_NAME_NEW_INDEX,ERR_R_MALLOC_FAILURE);
			return(0);
			}
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d114 2
a115 2
	const OBJ_NAME *a = (const OBJ_NAME *)a_void;
	const OBJ_NAME *b = (const OBJ_NAME *)b_void;
d136 1
a136 1
	const OBJ_NAME *a = (const OBJ_NAME *)a_void;
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d25 1
a25 2
DECLARE_LHASH_OF(OBJ_NAME);
static LHASH_OF(OBJ_NAME) *names_lh=NULL;
a48 3
static IMPLEMENT_LHASH_HASH_FN(obj_name, OBJ_NAME)
static IMPLEMENT_LHASH_COMP_FN(obj_name, OBJ_NAME)

d53 1
a53 1
	names_lh=lh_OBJ_NAME_new();
d167 1
a167 1
		ret=lh_OBJ_NAME_retrieve(names_lh,&on);
d203 1
a203 1
	ret=lh_OBJ_NAME_insert(names_lh,onp);
d220 1
a220 1
		if (lh_OBJ_NAME_error(names_lh))
d238 1
a238 1
	ret=lh_OBJ_NAME_delete(names_lh,&on);
d265 1
a265 1
static void do_all_fn_doall_arg(const OBJ_NAME *name,struct doall *d)
d271 1
a271 1
static IMPLEMENT_LHASH_DOALL_ARG_FN(do_all_fn, const OBJ_NAME, struct doall)
d281 1
a281 2
	lh_OBJ_NAME_doall_arg(names_lh, LHASH_DOALL_ARG_FN(do_all_fn),
			      struct doall, &d);
d316 1
a316 1
	d.names=OPENSSL_malloc(lh_OBJ_NAME_num_items(names_lh)*sizeof *d.names);
d330 3
a332 3
static void names_lh_free_doall(OBJ_NAME *onp)
	{
	if (onp == NULL)
d335 2
a336 1
	if (free_type < 0 || free_type == onp->type)
d338 1
d341 1
a341 1
static IMPLEMENT_LHASH_DOALL_FN(names_lh_free, OBJ_NAME)
d355 2
a356 2
	down_load=lh_OBJ_NAME_down_load(names_lh);
	lh_OBJ_NAME_down_load(names_lh)=0;
d358 1
a358 1
	lh_OBJ_NAME_doall(names_lh,LHASH_DOALL_FN(names_lh_free));
d361 1
a361 1
		lh_OBJ_NAME_free(names_lh);
d367 1
a367 1
		lh_OBJ_NAME_down_load(names_lh)=down_load;
@


1.1.1.5
log
@Import OpenSSL 1.0.1g
@
text
@d76 1
a76 1
	if (name_funcs_stack == NULL)
@


