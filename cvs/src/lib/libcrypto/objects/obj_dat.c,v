head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39;
locks; strict;
comment	@ * @;


1.39
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.38;
commitid	kT0fLt3r4lroFJra;

1.38
date	2017.01.21.04.44.43;	author jsing;	state Exp;
branches;
next	1.37;
commitid	zHxe3oRsmPbecUWd;

1.37
date	2016.12.22.16.57.38;	author inoguchi;	state Exp;
branches;
next	1.36;
commitid	7QI63POIsT9cgwVT;

1.36
date	2016.07.17.21.23.50;	author bcook;	state Exp;
branches;
next	1.35;
commitid	c1p1MiTTHyYjwwaP;

1.35
date	2015.10.14.21.54.10;	author tedu;	state Exp;
branches;
next	1.34;
commitid	aAHJ5map6oBMuDbX;

1.34
date	2015.10.14.21.25.16;	author beck;	state Exp;
branches;
next	1.33;
commitid	wIBu5o22ZkUE55IZ;

1.33
date	2015.10.14.21.12.10;	author tedu;	state Exp;
branches;
next	1.32;
commitid	UdUL7SwsLZbjhDWx;

1.32
date	2015.10.14.21.02.08;	author beck;	state Exp;
branches;
next	1.31;
commitid	Gz7jQIV4QAjoe4My;

1.31
date	2014.08.08.04.53.43;	author guenther;	state Exp;
branches
	1.31.2.1
	1.31.6.1
	1.31.8.1;
next	1.30;
commitid	4P1BbzAa8YBmRYyU;

1.30
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.29;
commitid	yQEL1wOWIearrW15;

1.29
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.28;
commitid	nzndm3zqPmFurSaK;

1.28
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.27;
commitid	id8dTrTMtnTn4fqt;

1.27
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	mJUVYpkFBZ0Zv2bG;

1.26
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	2nvnQBrv22dLtvTt;

1.25
date	2014.06.01.22.42.45;	author beck;	state Exp;
branches;
next	1.24;
commitid	NpFHf8625H20V9wY;

1.24
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.20.18.53.37;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.19.16.42.26;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.19.00.41.38;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.18.19.38.26;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.15.17.46.17;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.13.19.50.56;	author beck;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.29.05.39.23;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.05.11.05.08;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.30.11.08.05;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.15;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.57.53;	author beck;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2000.03.19.11.10.48;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.25;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.53;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.53;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.34;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.39.44;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.12.20.48.01;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.05.11.21.35.28;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.20.41.45;	author markus;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.04.29.05.37.12;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.08;	author djm;	state Exp;
branches;
next	;

1.4.4.1
date	2002.07.30.11.07.33;	author miod;	state Exp;
branches;
next	;

1.4.6.1
date	2002.07.30.15.47.52;	author jason;	state Exp;
branches;
next	;

1.31.2.1
date	2015.10.15.02.23.05;	author tedu;	state Exp;
branches;
next	;
commitid	ER54v3fpqj5MDfGP;

1.31.6.1
date	2015.10.15.02.23.25;	author tedu;	state Exp;
branches;
next	;
commitid	3qWq2P6WIWkANcOC;

1.31.8.1
date	2015.10.15.02.23.38;	author tedu;	state Exp;
branches;
next	;
commitid	Ilyf6ygRHQLk4vhA;


desc
@@


1.39
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: obj_dat.c,v 1.38 2017/01/21 04:44:43 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/asn1.h>
#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/lhash.h>
#include <openssl/objects.h>

/* obj_dat.h is generated from objects.h by obj_dat.pl */
#include "obj_dat.h"

static int sn_cmp_BSEARCH_CMP_FN(const void *, const void *);
static int sn_cmp(const ASN1_OBJECT * const *, unsigned int const *);
static unsigned int *OBJ_bsearch_sn(const ASN1_OBJECT * *key, unsigned int const *base, int num);
static int ln_cmp_BSEARCH_CMP_FN(const void *, const void *);
static int ln_cmp(const ASN1_OBJECT * const *, unsigned int const *);
static unsigned int *OBJ_bsearch_ln(const ASN1_OBJECT * *key, unsigned int const *base, int num);
static int obj_cmp_BSEARCH_CMP_FN(const void *, const void *);
static int obj_cmp(const ASN1_OBJECT * const *, unsigned int const *);
static unsigned int *OBJ_bsearch_obj(const ASN1_OBJECT * *key, unsigned int const *base, int num);

#define ADDED_DATA	0
#define ADDED_SNAME	1
#define ADDED_LNAME	2
#define ADDED_NID	3

typedef struct added_obj_st {
	int type;
	ASN1_OBJECT *obj;
} ADDED_OBJ;
DECLARE_LHASH_OF(ADDED_OBJ);

static int new_nid = NUM_NID;
static LHASH_OF(ADDED_OBJ) *added = NULL;

static int sn_cmp(const ASN1_OBJECT * const *a, const unsigned int *b)
{
	return (strcmp((*a)->sn, nid_objs[*b].sn));
}


static int
sn_cmp_BSEARCH_CMP_FN(const void *a_, const void *b_)
{
	const ASN1_OBJECT * const *a = a_;
	unsigned int const *b = b_;
	return sn_cmp(a, b);
}

static unsigned int *
OBJ_bsearch_sn(const ASN1_OBJECT * *key, unsigned int const *base, int num)
{
	return (unsigned int *)OBJ_bsearch_(key, base, num, sizeof(unsigned int),
	    sn_cmp_BSEARCH_CMP_FN);
}

static int ln_cmp(const ASN1_OBJECT * const *a, const unsigned int *b)
{
	return (strcmp((*a)->ln, nid_objs[*b].ln));
}


static int
ln_cmp_BSEARCH_CMP_FN(const void *a_, const void *b_)
{
	const ASN1_OBJECT * const *a = a_;
	unsigned int const *b = b_;
	return ln_cmp(a, b);
}

static unsigned int *
OBJ_bsearch_ln(const ASN1_OBJECT * *key, unsigned int const *base, int num)
{
	return (unsigned int *)OBJ_bsearch_(key, base, num, sizeof(unsigned int),
	    ln_cmp_BSEARCH_CMP_FN);
}

static unsigned long
added_obj_hash(const ADDED_OBJ *ca)
{
	const ASN1_OBJECT *a;
	int i;
	unsigned long ret = 0;
	unsigned char *p;

	a = ca->obj;
	switch (ca->type) {
	case ADDED_DATA:
		ret = a->length << 20L;
		p = (unsigned char *)a->data;
		for (i = 0; i < a->length; i++)
			ret ^= p[i] << ((i * 3) % 24);
		break;
	case ADDED_SNAME:
		ret = lh_strhash(a->sn);
		break;
	case ADDED_LNAME:
		ret = lh_strhash(a->ln);
		break;
	case ADDED_NID:
		ret = a->nid;
		break;
	default:
		/* abort(); */
		return 0;
	}
	ret &= 0x3fffffffL;
	ret |= ca->type << 30L;
	return (ret);
}
static IMPLEMENT_LHASH_HASH_FN(added_obj, ADDED_OBJ)

static int
added_obj_cmp(const ADDED_OBJ *ca, const ADDED_OBJ *cb)
{
	ASN1_OBJECT *a, *b;
	int i;

	i = ca->type - cb->type;
	if (i)
		return (i);
	a = ca->obj;
	b = cb->obj;
	switch (ca->type) {
	case ADDED_DATA:
		i = (a->length - b->length);
		if (i)
			return (i);
		return (memcmp(a->data, b->data, (size_t)a->length));
	case ADDED_SNAME:
		if (a->sn == NULL)
			return (-1);
		else if (b->sn == NULL)
			return (1);
		else
			return (strcmp(a->sn, b->sn));
	case ADDED_LNAME:
		if (a->ln == NULL)
			return (-1);
		else if (b->ln == NULL)
			return (1);
		else
			return (strcmp(a->ln, b->ln));
	case ADDED_NID:
		return (a->nid - b->nid);
	default:
		/* abort(); */
		return 0;
	}
}
static IMPLEMENT_LHASH_COMP_FN(added_obj, ADDED_OBJ)

static int
init_added(void)
{
	if (added != NULL)
		return (1);
	added = lh_ADDED_OBJ_new();
	return (added != NULL);
}

static void
cleanup1_doall(ADDED_OBJ *a)
{
	a->obj->nid = 0;
	a->obj->flags |= ASN1_OBJECT_FLAG_DYNAMIC |
	    ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
	    ASN1_OBJECT_FLAG_DYNAMIC_DATA;
}

static void cleanup2_doall(ADDED_OBJ *a)
{
	a->obj->nid++;
}

static void
cleanup3_doall(ADDED_OBJ *a)
{
	if (--a->obj->nid == 0)
		ASN1_OBJECT_free(a->obj);
	free(a);
}

static IMPLEMENT_LHASH_DOALL_FN(cleanup1, ADDED_OBJ)
static IMPLEMENT_LHASH_DOALL_FN(cleanup2, ADDED_OBJ)
static IMPLEMENT_LHASH_DOALL_FN(cleanup3, ADDED_OBJ)

/* The purpose of obj_cleanup_defer is to avoid EVP_cleanup() attempting
 * to use freed up OIDs. If neccessary the actual freeing up of OIDs is
 * delayed.
 */

int obj_cleanup_defer = 0;

void
check_defer(int nid)
{
	if (!obj_cleanup_defer && nid >= NUM_NID)
		obj_cleanup_defer = 1;
}

void
OBJ_cleanup(void)
{
	if (obj_cleanup_defer) {
		obj_cleanup_defer = 2;
		return;
	}
	if (added == NULL)
		return;
	lh_ADDED_OBJ_down_load(added) = 0;
	lh_ADDED_OBJ_doall(added, LHASH_DOALL_FN(cleanup1)); /* zero counters */
	lh_ADDED_OBJ_doall(added, LHASH_DOALL_FN(cleanup2)); /* set counters */
	lh_ADDED_OBJ_doall(added, LHASH_DOALL_FN(cleanup3)); /* free objects */
	lh_ADDED_OBJ_free(added);
	added = NULL;
}

int
OBJ_new_nid(int num)
{
	int i;

	i = new_nid;
	new_nid += num;
	return (i);
}

int
OBJ_add_object(const ASN1_OBJECT *obj)
{
	ASN1_OBJECT *o;
	ADDED_OBJ *ao[4] = {NULL, NULL, NULL, NULL}, *aop;
	int i;

	if (added == NULL)
		if (!init_added())
			return (0);
	if ((o = OBJ_dup(obj)) == NULL)
		goto err;
	if (!(ao[ADDED_NID] = malloc(sizeof(ADDED_OBJ))))
		goto err2;
	if ((o->length != 0) && (obj->data != NULL))
		if (!(ao[ADDED_DATA] = malloc(sizeof(ADDED_OBJ))))
			goto err2;
	if (o->sn != NULL)
		if (!(ao[ADDED_SNAME] = malloc(sizeof(ADDED_OBJ))))
			goto err2;
	if (o->ln != NULL)
		if (!(ao[ADDED_LNAME] = malloc(sizeof(ADDED_OBJ))))
			goto err2;

	for (i = ADDED_DATA; i <= ADDED_NID; i++) {
		if (ao[i] != NULL) {
			ao[i]->type = i;
			ao[i]->obj = o;
			aop = lh_ADDED_OBJ_insert(added, ao[i]);
			/* memory leak, buit should not normally matter */
			free(aop);
		}
	}
	o->flags &= ~(ASN1_OBJECT_FLAG_DYNAMIC |
	    ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
	    ASN1_OBJECT_FLAG_DYNAMIC_DATA);

	return (o->nid);

err2:
	OBJerror(ERR_R_MALLOC_FAILURE);
err:
	for (i = ADDED_DATA; i <= ADDED_NID; i++)
		free(ao[i]);
	free(o);
	return (NID_undef);
}

ASN1_OBJECT *
OBJ_nid2obj(int n)
{
	ADDED_OBJ ad, *adp;
	ASN1_OBJECT ob;

	if ((n >= 0) && (n < NUM_NID)) {
		if ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {
			OBJerror(OBJ_R_UNKNOWN_NID);
			return (NULL);
		}
		return ((ASN1_OBJECT *)&(nid_objs[n]));
	} else if (added == NULL)
		return (NULL);
	else {
		ad.type = ADDED_NID;
		ad.obj = &ob;
		ob.nid = n;
		adp = lh_ADDED_OBJ_retrieve(added, &ad);
		if (adp != NULL)
			return (adp->obj);
		else {
			OBJerror(OBJ_R_UNKNOWN_NID);
			return (NULL);
		}
	}
}

const char *
OBJ_nid2sn(int n)
{
	ADDED_OBJ ad, *adp;
	ASN1_OBJECT ob;

	if ((n >= 0) && (n < NUM_NID)) {
		if ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {
			OBJerror(OBJ_R_UNKNOWN_NID);
			return (NULL);
		}
		return (nid_objs[n].sn);
	} else if (added == NULL)
		return (NULL);
	else {
		ad.type = ADDED_NID;
		ad.obj = &ob;
		ob.nid = n;
		adp = lh_ADDED_OBJ_retrieve(added, &ad);
		if (adp != NULL)
			return (adp->obj->sn);
		else {
			OBJerror(OBJ_R_UNKNOWN_NID);
			return (NULL);
		}
	}
}

const char *
OBJ_nid2ln(int n)
{
	ADDED_OBJ ad, *adp;
	ASN1_OBJECT ob;

	if ((n >= 0) && (n < NUM_NID)) {
		if ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {
			OBJerror(OBJ_R_UNKNOWN_NID);
			return (NULL);
		}
		return (nid_objs[n].ln);
	} else if (added == NULL)
		return (NULL);
	else {
		ad.type = ADDED_NID;
		ad.obj = &ob;
		ob.nid = n;
		adp = lh_ADDED_OBJ_retrieve(added, &ad);
		if (adp != NULL)
			return (adp->obj->ln);
		else {
			OBJerror(OBJ_R_UNKNOWN_NID);
			return (NULL);
		}
	}
}

static int
obj_cmp(const ASN1_OBJECT * const *ap, const unsigned int *bp)
{
	int j;
	const ASN1_OBJECT *a= *ap;
	const ASN1_OBJECT *b = &nid_objs[*bp];

	j = (a->length - b->length);
	if (j)
		return (j);
	return (memcmp(a->data, b->data, a->length));
}


static int
obj_cmp_BSEARCH_CMP_FN(const void *a_, const void *b_)
{
	const ASN1_OBJECT * const *a = a_;
	unsigned int const *b = b_;
	return obj_cmp(a, b);
}

static unsigned int *
OBJ_bsearch_obj(const ASN1_OBJECT * *key, unsigned int const *base, int num)
{
	return (unsigned int *)OBJ_bsearch_(key, base, num, sizeof(unsigned int),
	    obj_cmp_BSEARCH_CMP_FN);
}

int
OBJ_obj2nid(const ASN1_OBJECT *a)
{
	const unsigned int *op;
	ADDED_OBJ ad, *adp;

	if (a == NULL)
		return (NID_undef);
	if (a->nid != 0)
		return (a->nid);

	if (added != NULL) {
		ad.type = ADDED_DATA;
		ad.obj=(ASN1_OBJECT *)a; /* XXX: ugly but harmless */
		adp = lh_ADDED_OBJ_retrieve(added, &ad);
		if (adp != NULL)
			return (adp->obj->nid);
	}
	op = OBJ_bsearch_obj(&a, obj_objs, NUM_OBJ);
	if (op == NULL)
		return (NID_undef);
	return (nid_objs[*op].nid);
}

/* Convert an object name into an ASN1_OBJECT
 * if "noname" is not set then search for short and long names first.
 * This will convert the "dotted" form into an object: unlike OBJ_txt2nid
 * it can be used with any objects, not just registered ones.
 */

ASN1_OBJECT *
OBJ_txt2obj(const char *s, int no_name)
{
	int nid = NID_undef;
	ASN1_OBJECT *op = NULL;
	unsigned char *buf;
	unsigned char *p;
	const unsigned char *cp;
	int i, j;

	if (!no_name) {
		if (((nid = OBJ_sn2nid(s)) != NID_undef) ||
		    ((nid = OBJ_ln2nid(s)) != NID_undef) )
			return OBJ_nid2obj(nid);
	}

	/* Work out size of content octets */
	i = a2d_ASN1_OBJECT(NULL, 0, s, -1);
	if (i <= 0) {
		/* Don't clear the error */
		/*ERR_clear_error();*/
		return NULL;
	}
	/* Work out total size */
	j = ASN1_object_size(0, i, V_ASN1_OBJECT);

	if ((buf = malloc(j)) == NULL)
		return NULL;

	p = buf;
	/* Write out tag+length */
	ASN1_put_object(&p, 0, i, V_ASN1_OBJECT, V_ASN1_UNIVERSAL);
	/* Write out contents */
	a2d_ASN1_OBJECT(p, i, s, -1);

	cp = buf;
	op = d2i_ASN1_OBJECT(NULL, &cp, j);
	free(buf);
	return op;
}

int
OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
{
	int i, ret = 0, len, nid, first = 1, use_bn;
	BIGNUM *bl = NULL;
	unsigned long l;
	const unsigned char *p;

	/* Ensure that, at every state, |buf| is NUL-terminated. */
	if (buf_len > 0)
		buf[0] = '\0';

	if ((a == NULL) || (a->data == NULL))
		goto err;

	if (!no_name && (nid = OBJ_obj2nid(a)) != NID_undef) {
		const char *s;
		s = OBJ_nid2ln(nid);
		if (s == NULL)
			s = OBJ_nid2sn(nid);
		if (s) {
			ret = strlcpy(buf, s, buf_len);
			goto out;
		}
	}

	len = a->length;
	p = a->data;

	while (len > 0) {
		l = 0;
		use_bn = 0;
		for (;;) {
			unsigned char c = *p++;
			len--;
			if ((len == 0) && (c & 0x80))
				goto err;
			if (use_bn) {
				if (!BN_add_word(bl, c & 0x7f))
					goto err;
			} else
				l |= c & 0x7f;
			if (!(c & 0x80))
				break;
			if (!use_bn && (l > (ULONG_MAX >> 7L))) {
				if (!bl && !(bl = BN_new()))
					goto err;
				if (!BN_set_word(bl, l))
					goto err;
				use_bn = 1;
			}
			if (use_bn) {
				if (!BN_lshift(bl, bl, 7))
					goto err;
			} else
				l <<= 7L;
		}

		if (first) {
			first = 0;
			if (l >= 80) {
				i = 2;
				if (use_bn) {
					if (!BN_sub_word(bl, 80))
						goto err;
				} else
					l -= 80;
			} else {
				i = (int)(l / 40);
				l -= (long)(i * 40);
			}
			if (buf_len > 1) {
				*buf++ = i + '0';
				*buf = '\0';
				buf_len--;
			}
			ret++;
		}

		if (use_bn) {
			char *bndec;

			bndec = BN_bn2dec(bl);
			if (!bndec)
				goto err;
			i = snprintf(buf, buf_len, ".%s", bndec);
			free(bndec);
			if (i == -1)
				goto err;
			if (i >= buf_len) {
				buf_len = 0;
			} else {
				buf += i;
				buf_len -= i;
			}
			ret += i;
		} else {
			i = snprintf(buf, buf_len, ".%lu", l);
			if (i == -1)
				goto err;
			if (i >= buf_len) {
				buf_len = 0;
			} else {
				buf += i;
				buf_len -= i;
			}
			ret += i;
			l = 0;
		}
	}

out:
	BN_free(bl);
	return ret;

err:
	ret = 0;
	goto out;
}

int
OBJ_txt2nid(const char *s)
{
	ASN1_OBJECT *obj;
	int nid;

	obj = OBJ_txt2obj(s, 0);
	nid = OBJ_obj2nid(obj);
	ASN1_OBJECT_free(obj);
	return nid;
}

int
OBJ_ln2nid(const char *s)
{
	ASN1_OBJECT o;
	const ASN1_OBJECT *oo = &o;
	ADDED_OBJ ad, *adp;
	const unsigned int *op;

	o.ln = s;
	if (added != NULL) {
		ad.type = ADDED_LNAME;
		ad.obj = &o;
		adp = lh_ADDED_OBJ_retrieve(added, &ad);
		if (adp != NULL)
			return (adp->obj->nid);
	}
	op = OBJ_bsearch_ln(&oo, ln_objs, NUM_LN);
	if (op == NULL)
		return (NID_undef);
	return (nid_objs[*op].nid);
}

int
OBJ_sn2nid(const char *s)
{
	ASN1_OBJECT o;
	const ASN1_OBJECT *oo = &o;
	ADDED_OBJ ad, *adp;
	const unsigned int *op;

	o.sn = s;
	if (added != NULL) {
		ad.type = ADDED_SNAME;
		ad.obj = &o;
		adp = lh_ADDED_OBJ_retrieve(added, &ad);
		if (adp != NULL)
			return (adp->obj->nid);
	}
	op = OBJ_bsearch_sn(&oo, sn_objs, NUM_SN);
	if (op == NULL)
		return (NID_undef);
	return (nid_objs[*op].nid);
}

const void *
OBJ_bsearch_(const void *key, const void *base, int num, int size,
    int (*cmp)(const void *, const void *))
{
	return OBJ_bsearch_ex_(key, base, num, size, cmp, 0);
}

const void *
OBJ_bsearch_ex_(const void *key, const void *base_, int num, int size,
    int (*cmp)(const void *, const void *), int flags)
{
	const char *base = base_;
	int l, h, i = 0, c = 0;
	const char *p = NULL;

	if (num == 0)
		return (NULL);
	l = 0;
	h = num;
	while (l < h) {
		i = (l + h) / 2;
		p = &(base[i * size]);
		c = (*cmp)(key, p);
		if (c < 0)
			h = i;
		else if (c > 0)
			l = i + 1;
		else
			break;
	}
	if (c != 0 && !(flags & OBJ_BSEARCH_VALUE_ON_NOMATCH))
		p = NULL;
	else if (c == 0 && (flags & OBJ_BSEARCH_FIRST_VALUE_ON_MATCH)) {
		while (i > 0 && (*cmp)(key, &(base[(i - 1) * size])) == 0)
			i--;
		p = &(base[i * size]);
	}
	return (p);
}

int
OBJ_create_objects(BIO *in)
{
	char buf[512];
	int i, num = 0;
	char *o, *s, *l = NULL;

	for (;;) {
		s = o = NULL;
		i = BIO_gets(in, buf, 512);
		if (i <= 0)
			return (num);
		buf[i - 1] = '\0';
		if (!isalnum((unsigned char)buf[0]))
			return (num);
		o = s=buf;
		while (isdigit((unsigned char)*s) || (*s == '.'))
			s++;
		if (*s != '\0') {
			*(s++) = '\0';
			while (isspace((unsigned char)*s))
				s++;
			if (*s == '\0')
				s = NULL;
			else {
				l = s;
				while ((*l != '\0') &&
				    !isspace((unsigned char)*l))
					l++;
				if (*l != '\0') {
					*(l++) = '\0';
					while (isspace((unsigned char)*l))
						l++;
					if (*l == '\0')
						l = NULL;
				} else
					l = NULL;
			}
		} else
			s = NULL;
		if ((o == NULL) || (*o == '\0'))
			return (num);
		if (!OBJ_create(o, s, l))
			return (num);
		num++;
	}
	/* return(num); */
}

int
OBJ_create(const char *oid, const char *sn, const char *ln)
{
	int ok = 0;
	ASN1_OBJECT *op = NULL;
	unsigned char *buf;
	int i;

	i = a2d_ASN1_OBJECT(NULL, 0, oid, -1);
	if (i <= 0)
		return (0);

	if ((buf = malloc(i)) == NULL) {
		OBJerror(ERR_R_MALLOC_FAILURE);
		return (0);
	}
	i = a2d_ASN1_OBJECT(buf, i, oid, -1);
	if (i == 0)
		goto err;
	op = (ASN1_OBJECT *)ASN1_OBJECT_create(OBJ_new_nid(1), buf, i, sn, ln);
	if (op == NULL)
		goto err;
	ok = OBJ_add_object(op);

err:
	ASN1_OBJECT_free(op);
	free(buf);
	return (ok);
}
@


1.38
log
@Expand DECLARE_OBJ_BSEARCH_CMP_FN and IMPLEMENT_OBJ_BSEARCH_CMP_FN macros.

No change to generated assembly excluding line numbers.
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.37 2016/12/22 16:57:38 inoguchi Exp $ */
d332 1
a332 1
	OBJerr(OBJ_F_OBJ_ADD_OBJECT, ERR_R_MALLOC_FAILURE);
d348 1
a348 1
			OBJerr(OBJ_F_OBJ_NID2OBJ, OBJ_R_UNKNOWN_NID);
d362 1
a362 1
			OBJerr(OBJ_F_OBJ_NID2OBJ, OBJ_R_UNKNOWN_NID);
d376 1
a376 1
			OBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);
d390 1
a390 1
			OBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);
d404 1
a404 1
			OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);
d418 1
a418 1
			OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);
d802 1
a802 1
		OBJerr(OBJ_F_OBJ_CREATE, ERR_R_MALLOC_FAILURE);
@


1.37
log
@OBJ_obj2txt() should return the total amount of space required
reported by @@rhenium on GitHub
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.36 2016/07/17 21:23:50 bcook Exp $ */
d75 9
a83 3
DECLARE_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, sn);
DECLARE_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, ln);
DECLARE_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, obj);
d104 15
a118 1
IMPLEMENT_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, sn);
d125 15
a139 1
IMPLEMENT_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, ln);
d437 15
a451 1
IMPLEMENT_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, obj);
@


1.36
log
@remove unused OPENSSL_NO_OBJECT case

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.35 2015/10/14 21:54:10 tedu Exp $ */
a554 4
		if (buf_len <= 0) {
			ret = 0;
			goto out;
		}
@


1.35
log
@better fix for overrun reported by Qualys Security.
buf is at all times kept nul terminated, so there is no need to enforce
this again upon exit. (no need to move buf around after we exahust space.)
ok beck miod
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.34 2015/10/14 21:25:16 beck Exp $ */
a72 1
#ifndef OPENSSL_NO_OBJECT
a73 12
#else
/* You will have to load all the objects needed manually in the application */
#define NUM_NID 0
#define NUM_SN 0
#define NUM_LN 0
#define NUM_OBJ 0
static const unsigned char lvalues[1];
static const ASN1_OBJECT nid_objs[1];
static const unsigned int sn_objs[1];
static const unsigned int ln_objs[1];
static const unsigned int obj_objs[1];
#endif
@


1.34
log
@Bail out early if we have no buf_len
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.33 2015/10/14 21:12:10 tedu Exp $ */
a582 1
				buf += buf_len - 1;
a593 1
				buf += buf_len - 1;
a609 1
	buf[0] = '\0';
@


1.33
log
@fix a memory leak reported by Qualys Security.
move the bndec variable in tighter since it's not used elsewhere in the
loop, then always free it after use.
ok bcook miod
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.32 2015/10/14 21:02:08 beck Exp $ */
d568 4
@


1.32
log
@Ensure we don't write a 0 byte past end of the buffer in the error case.
ok bcook@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.31 2014/08/08 04:53:43 guenther Exp $ */
a493 1
	char *bndec = NULL;
d569 2
d575 1
a602 1
	free(bndec);
@


1.31
log
@Fix CVE-2014-3508, pretty printing and OID validation:
 - make sure the output buffer is always NUL terminated if buf_len
   was initially greater than zero.
 - reject OIDs that are too long, too short, or not in proper base-127

Based on
https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=0042fb5fd1c9d257d713b15a1f45da05cf5c1c87

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.30 2014/07/11 08:44:49 jsing Exp $ */
d577 1
a577 1
				buf += buf_len;
d589 1
a589 1
				buf += buf_len;
@


1.31.8.1
log
@pull up fixes for leak and overrun
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.31 2014/08/08 04:53:43 guenther Exp $ */
d494 1
a569 2
			char *bndec;

a573 1
			free(bndec);
d577 1
d589 1
d601 1
d607 1
@


1.31.6.1
log
@pull up fixes for leak and overrun
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.31 2014/08/08 04:53:43 guenther Exp $ */
d494 1
a569 2
			char *bndec;

a573 1
			free(bndec);
d577 1
d589 1
d601 1
d607 1
@


1.31.2.1
log
@pull up fixes for leak and overrun
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.31 2014/08/08 04:53:43 guenther Exp $ */
d494 1
a569 2
			char *bndec;

a573 1
			free(bndec);
d577 1
d589 1
d601 1
d607 1
@


1.30
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.29 2014/07/10 22:45:57 jsing Exp $ */
d498 4
d561 1
a561 1
			if (buf_len > 0) {
d563 1
@


1.29
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.28 2014/07/10 13:58:22 jsing Exp $ */
d66 3
a68 1
#include "cryptlib.h"
a69 1
#include <openssl/asn1.h>
a70 1
#include <openssl/bn.h>
@


1.28
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: obj_dat.c,v 1.27 2014/06/12 15:49:30 deraadt Exp $ */
d63 2
@


1.27
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a58 1
#include <stdio.h>
d61 3
@


1.26
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/objects/obj_dat.c */
@


1.25
log
@Clean up some of the nightmare of string and pointer arithmatic in
this nasty function.

This gets rid of the nasty tmp variables used to hold temporary strings
and the DECIMAL_SIZE hack. it gets rid of the rather pointless null checks
for buf (since the original code dereferences it before checking). It also
gets rid of the insane possibility this could return -1 when stuff is
using the return values to compute lengths All the failure cases now
return 0 and an empty string like the first error case in the original
code.
ok miod@@ tedu@@
@
text
@d279 1
a279 1
	if (!(ao[ADDED_NID] = (ADDED_OBJ *)malloc(sizeof(ADDED_OBJ))))
d282 1
a282 1
		if (!(ao[ADDED_DATA] = (ADDED_OBJ *)malloc(sizeof(ADDED_OBJ))))
d285 1
a285 1
		if (!(ao[ADDED_SNAME] = (ADDED_OBJ *)malloc(sizeof(ADDED_OBJ))))
d288 1
a288 1
		if (!(ao[ADDED_LNAME] = (ADDED_OBJ *)malloc(sizeof(ADDED_OBJ))))
d470 1
a470 1
	if ((buf = (unsigned char *)malloc(j)) == NULL)
d759 1
a759 1
	if ((buf = (unsigned char *)malloc(i)) == NULL) {
@


1.24
log
@more: no need for null check before free
ok tedu guenther
@
text
@d488 3
a490 2
	int i, n = 0, len, nid, first, use_bn;
	BIGNUM *bl;
a492 1
	char tbuf[DECIMAL_SIZE(l) + 1];
d494 2
a495 4
	if ((a == NULL) || (a->data == NULL)) {
		buf[0] = '\0';
		return (0);
	}
d503 2
a504 4
			if (buf)
				strlcpy(buf, s, buf_len);
			n = strlen(s);
			return n;
a510 3
	first = 1;
	bl = NULL;

d553 1
a553 1
			if (buf && (buf_len > 0)) {
d557 1
a557 1
			n++;
a560 1
			char *bndec;
d564 9
a572 14
			i = strlen(bndec);
			if (buf) {
				if (buf_len > 0) {
					*buf++ = '.';
					buf_len--;
				}
				strlcpy(buf, bndec, buf_len);
				if (i > buf_len) {
					buf += buf_len;
					buf_len = 0;
				} else {
					buf += i;
					buf_len -= i;
				}
d574 1
a574 3
			n++;
			n += i;
			free(bndec);
d576 9
a584 11
			(void) snprintf(tbuf, sizeof tbuf, ".%lu", l);
			i = strlen(tbuf);
			if (buf && (buf_len > 0)) {
				strlcpy(buf, tbuf, buf_len);
				if (i > buf_len) {
					buf += buf_len;
					buf_len = 0;
				} else {
					buf += i;
					buf_len -= i;
				}
d586 1
a586 1
			n += i;
d591 4
a594 3
	if (bl)
		BN_free(bl);
	return n;
d597 3
a599 3
	if (bl)
		BN_free(bl);
	return -1;
@


1.23
log
@Restore beck's rev 1.21: snprintf() was reviewed
@
text
@d297 1
a297 2
			if (aop != NULL)
				free(aop);
d310 2
a311 4
		if (ao[i] != NULL)
			free(ao[i]);
	if (o != NULL)
		free(o);
@


1.22
log
@KNF.
@
text
@d594 1
a594 1
			snprintf(tbuf, sizeof tbuf, ".%lu", l);
@


1.21
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d93 1
a93 2
typedef struct added_obj_st
	{
d96 1
a96 1
	} ADDED_OBJ;
d99 2
a100 2
static int new_nid=NUM_NID;
static LHASH_OF(ADDED_OBJ) *added=NULL;
d103 3
a105 1
	{ return(strcmp((*a)->sn,nid_objs[*b].sn)); }
d110 3
a112 1
	{ return(strcmp((*a)->ln,nid_objs[*b].ln)); }
d116 3
a118 2
static unsigned long added_obj_hash(const ADDED_OBJ *ca)
	{
d121 1
a121 1
	unsigned long ret=0;
d124 2
a125 3
	a=ca->obj;
	switch (ca->type)
		{
d127 4
a130 4
		ret=a->length<<20L;
		p=(unsigned char *)a->data;
		for (i=0; i<a->length; i++)
			ret^=p[i]<<((i*3)%24);
d133 1
a133 1
		ret=lh_strhash(a->sn);
d136 1
a136 1
		ret=lh_strhash(a->ln);
d139 1
a139 1
		ret=a->nid;
a143 4
		}
	ret&=0x3fffffffL;
	ret|=ca->type<<30L;
	return(ret);
d145 4
d151 4
a154 3
static int added_obj_cmp(const ADDED_OBJ *ca, const ADDED_OBJ *cb)
	{
	ASN1_OBJECT *a,*b;
d157 6
a162 6
	i=ca->type-cb->type;
	if (i) return(i);
	a=ca->obj;
	b=cb->obj;
	switch (ca->type)
		{
d164 4
a167 3
		i=(a->length - b->length);
		if (i) return(i);
		return(memcmp(a->data,b->data,(size_t)a->length));
d169 6
a174 3
		if (a->sn == NULL) return(-1);
		else if (b->sn == NULL) return(1);
		else return(strcmp(a->sn,b->sn));
d176 6
a181 3
		if (a->ln == NULL) return(-1);
		else if (b->ln == NULL) return(1);
		else return(strcmp(a->ln,b->ln));
d183 1
a183 1
		return(a->nid-b->nid);
a186 1
		}
d188 1
d191 8
a198 6
static int init_added(void)
	{
	if (added != NULL) return(1);
	added=lh_ADDED_OBJ_new();
	return(added != NULL);
	}
d200 8
a207 7
static void cleanup1_doall(ADDED_OBJ *a)
	{
	a->obj->nid=0;
	a->obj->flags|=ASN1_OBJECT_FLAG_DYNAMIC|
	                ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|
			ASN1_OBJECT_FLAG_DYNAMIC_DATA;
	}
d210 3
a212 1
	{ a->obj->nid++; }
d214 3
a216 2
static void cleanup3_doall(ADDED_OBJ *a)
	{
d220 1
a220 1
	}
d233 3
a235 2
void check_defer(int nid)
	{
d237 2
a238 2
			obj_cleanup_defer = 1;
	}
d240 4
a243 4
void OBJ_cleanup(void)
	{
	if (obj_cleanup_defer)
		{
d245 4
a248 3
		return ;
		}
	if (added == NULL) return;
d250 3
a252 3
	lh_ADDED_OBJ_doall(added,LHASH_DOALL_FN(cleanup1)); /* zero counters */
	lh_ADDED_OBJ_doall(added,LHASH_DOALL_FN(cleanup2)); /* set counters */
	lh_ADDED_OBJ_doall(added,LHASH_DOALL_FN(cleanup3)); /* free objects */
d254 2
a255 2
	added=NULL;
	}
d257 3
a259 2
int OBJ_new_nid(int num)
	{
d262 4
a265 4
	i=new_nid;
	new_nid+=num;
	return(i);
	}
d267 3
a269 2
int OBJ_add_object(const ASN1_OBJECT *obj)
	{
d271 1
a271 1
	ADDED_OBJ *ao[4]={NULL,NULL,NULL,NULL},*aop;
d275 6
a280 3
		if (!init_added()) return(0);
	if ((o=OBJ_dup(obj)) == NULL) goto err;
	if (!(ao[ADDED_NID]=(ADDED_OBJ *)malloc(sizeof(ADDED_OBJ)))) goto err2;
d282 2
a283 1
		if (!(ao[ADDED_DATA]=(ADDED_OBJ *)malloc(sizeof(ADDED_OBJ)))) goto err2;
d285 2
a286 1
		if (!(ao[ADDED_SNAME]=(ADDED_OBJ *)malloc(sizeof(ADDED_OBJ)))) goto err2;
d288 2
a289 1
		if (!(ao[ADDED_LNAME]=(ADDED_OBJ *)malloc(sizeof(ADDED_OBJ)))) goto err2;
d291 5
a295 7
	for (i=ADDED_DATA; i<=ADDED_NID; i++)
		{
		if (ao[i] != NULL)
			{
			ao[i]->type=i;
			ao[i]->obj=o;
			aop=lh_ADDED_OBJ_insert(added,ao[i]);
a298 1
			}
d300 6
a305 2
	o->flags&= ~(ASN1_OBJECT_FLAG_DYNAMIC|ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|
			ASN1_OBJECT_FLAG_DYNAMIC_DATA);
a306 1
	return(o->nid);
d308 1
a308 1
	OBJerr(OBJ_F_OBJ_ADD_OBJECT,ERR_R_MALLOC_FAILURE);
d310 7
a316 5
	for (i=ADDED_DATA; i<=ADDED_NID; i++)
		if (ao[i] != NULL) free(ao[i]);
	if (o != NULL) free(o);
	return(NID_undef);
	}
d318 4
a321 3
ASN1_OBJECT *OBJ_nid2obj(int n)
	{
	ADDED_OBJ ad,*adp;
d324 13
a336 17
	if ((n >= 0) && (n < NUM_NID))
		{
		if ((n != NID_undef) && (nid_objs[n].nid == NID_undef))
			{
			OBJerr(OBJ_F_OBJ_NID2OBJ,OBJ_R_UNKNOWN_NID);
			return(NULL);
			}
		return((ASN1_OBJECT *)&(nid_objs[n]));
		}
	else if (added == NULL)
		return(NULL);
	else
		{
		ad.type=ADDED_NID;
		ad.obj= &ob;
		ob.nid=n;
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
d338 4
a341 6
			return(adp->obj);
		else
			{
			OBJerr(OBJ_F_OBJ_NID2OBJ,OBJ_R_UNKNOWN_NID);
			return(NULL);
			}
d344 1
d346 4
a349 3
const char *OBJ_nid2sn(int n)
	{
	ADDED_OBJ ad,*adp;
d352 13
a364 17
	if ((n >= 0) && (n < NUM_NID))
		{
		if ((n != NID_undef) && (nid_objs[n].nid == NID_undef))
			{
			OBJerr(OBJ_F_OBJ_NID2SN,OBJ_R_UNKNOWN_NID);
			return(NULL);
			}
		return(nid_objs[n].sn);
		}
	else if (added == NULL)
		return(NULL);
	else
		{
		ad.type=ADDED_NID;
		ad.obj= &ob;
		ob.nid=n;
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
d366 4
a369 6
			return(adp->obj->sn);
		else
			{
			OBJerr(OBJ_F_OBJ_NID2SN,OBJ_R_UNKNOWN_NID);
			return(NULL);
			}
d372 1
d374 4
a377 3
const char *OBJ_nid2ln(int n)
	{
	ADDED_OBJ ad,*adp;
d380 13
a392 17
	if ((n >= 0) && (n < NUM_NID))
		{
		if ((n != NID_undef) && (nid_objs[n].nid == NID_undef))
			{
			OBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);
			return(NULL);
			}
		return(nid_objs[n].ln);
		}
	else if (added == NULL)
		return(NULL);
	else
		{
		ad.type=ADDED_NID;
		ad.obj= &ob;
		ob.nid=n;
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
d394 4
a397 6
			return(adp->obj->ln);
		else
			{
			OBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);
			return(NULL);
			}
d400 1
d402 3
a404 2
static int obj_cmp(const ASN1_OBJECT * const *ap, const unsigned int *bp)
	{
d407 1
a407 1
	const ASN1_OBJECT *b= &nid_objs[*bp];
d409 5
a413 4
	j=(a->length - b->length);
        if (j) return(j);
	return(memcmp(a->data,b->data,a->length));
	}
d417 3
a419 2
int OBJ_obj2nid(const ASN1_OBJECT *a)
	{
d421 1
a421 1
	ADDED_OBJ ad,*adp;
d424 1
a424 1
		return(NID_undef);
d426 1
a426 1
		return(a->nid);
d428 2
a429 3
	if (added != NULL)
		{
		ad.type=ADDED_DATA;
d431 5
a435 4
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
		if (adp != NULL) return (adp->obj->nid);
		}
	op=OBJ_bsearch_obj(&a, obj_objs, NUM_OBJ);
d437 3
a439 3
		return(NID_undef);
	return(nid_objs[*op].nid);
	}
d447 3
a449 2
ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)
	{
d451 1
a451 1
	ASN1_OBJECT *op=NULL;
d457 4
a460 4
	if(!no_name) {
		if( ((nid = OBJ_sn2nid(s)) != NID_undef) ||
			((nid = OBJ_ln2nid(s)) != NID_undef) ) 
					return OBJ_nid2obj(nid);
d464 1
a464 1
	i=a2d_ASN1_OBJECT(NULL,0,s,-1);
d471 1
a471 1
	j = ASN1_object_size(0,i,V_ASN1_OBJECT);
d473 2
a474 1
	if((buf=(unsigned char *)malloc(j)) == NULL) return NULL;
d478 1
a478 1
	ASN1_put_object(&p,0,i,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);
d480 1
a480 1
	a2d_ASN1_OBJECT(p,i,s,-1);
d482 2
a483 2
	cp=buf;
	op=d2i_ASN1_OBJECT(NULL,&cp,j);
d486 1
a486 1
	}
d488 2
a489 1
int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
d491 1
a491 1
	int i,n=0,len,nid, first, use_bn;
d498 2
a499 2
		buf[0]='\0';
		return(0);
d502 1
a502 3

	if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)
		{
d504 1
a504 1
		s=OBJ_nid2ln(nid);
d506 2
a507 3
			s=OBJ_nid2sn(nid);
		if (s)
			{
d509 2
a510 2
				strlcpy(buf,s,buf_len);
			n=strlen(s);
a511 1
			}
d513 1
d515 2
a516 3

	len=a->length;
	p=a->data;
d521 2
a522 3
	while (len > 0)
		{
		l=0;
d524 1
a524 2
		for (;;)
			{
d529 1
a529 2
			if (use_bn)
				{
d532 2
a533 3
				}
			else
				l |= c  & 0x7f;
d536 1
a536 2
			if (!use_bn && (l > (ULONG_MAX >> 7L)))
				{
d542 2
a543 3
				}
			if (use_bn)
				{
d546 3
a548 4
				}
			else
				l<<=7L;
			}
d550 1
a550 2
		if (first)
			{
d552 1
a552 2
			if (l >= 80)
				{
d554 1
a554 2
				if (use_bn)
					{
d557 1
a557 2
					}
				else
d559 5
a563 8
				}
			else
				{
				i=(int)(l/40);
				l-=(long)(i*40);
				}
			if (buf && (buf_len > 0))
				{
d566 1
a566 1
				}
d568 1
a568 1
			}
d570 1
a570 2
		if (use_bn)
			{
d576 2
a577 4
			if (buf)
				{
				if (buf_len > 0)
					{
d580 3
a582 4
					}
				strlcpy(buf,bndec,buf_len);
				if (i > buf_len)
					{
d585 3
a587 6
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
d589 1
d593 6
a598 10
			}
		else
			{
			snprintf(tbuf,sizeof tbuf,".%lu",l);
			i=strlen(tbuf);
			if (buf && (buf_len > 0))
				{
				strlcpy(buf,tbuf,buf_len);
				if (i > buf_len)
					{
d601 3
a603 6
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
a604 2
			n+=i;
			l=0;
d606 2
d609 1
d615 1
a615 1
	err:
d621 2
a622 1
int OBJ_txt2nid(const char *s)
d626 1
d633 3
a635 2
int OBJ_ln2nid(const char *s)
	{
d637 2
a638 2
	const ASN1_OBJECT *oo= &o;
	ADDED_OBJ ad,*adp;
d641 7
a647 11
	o.ln=s;
	if (added != NULL)
		{
		ad.type=ADDED_LNAME;
		ad.obj= &o;
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
		if (adp != NULL) return (adp->obj->nid);
		}
	op=OBJ_bsearch_ln(&oo, ln_objs, NUM_LN);
	if (op == NULL) return(NID_undef);
	return(nid_objs[*op].nid);
d649 5
d655 3
a657 2
int OBJ_sn2nid(const char *s)
	{
d659 2
a660 2
	const ASN1_OBJECT *oo= &o;
	ADDED_OBJ ad,*adp;
d663 7
a669 11
	o.sn=s;
	if (added != NULL)
		{
		ad.type=ADDED_SNAME;
		ad.obj= &o;
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
		if (adp != NULL) return (adp->obj->nid);
		}
	op=OBJ_bsearch_sn(&oo, sn_objs, NUM_SN);
	if (op == NULL) return(NID_undef);
	return(nid_objs[*op].nid);
d671 5
d677 4
a680 3
const void *OBJ_bsearch_(const void *key, const void *base, int num, int size,
			 int (*cmp)(const void *, const void *))
	{
d682 1
a682 1
	}
d684 6
a689 7
const void *OBJ_bsearch_ex_(const void *key, const void *base_, int num,
			    int size,
			    int (*cmp)(const void *, const void *),
			    int flags)
	{
	const char *base=base_;
	int l,h,i=0,c=0;
d692 8
a699 8
	if (num == 0) return(NULL);
	l=0;
	h=num;
	while (l < h)
		{
		i=(l+h)/2;
		p= &(base[i*size]);
		c=(*cmp)(key,p);
d701 1
a701 1
			h=i;
d703 1
a703 1
			l=i+1;
d706 1
a706 1
		}
d709 2
a710 3
	else if (c == 0 && (flags & OBJ_BSEARCH_FIRST_VALUE_ON_MATCH))
		{
		while(i > 0 && (*cmp)(key,&(base[(i-1)*size])) == 0)
d712 1
a712 3
		p = &(base[i*size]);
		}
	return(p);
d714 2
d717 3
a719 2
int OBJ_create_objects(BIO *in)
	{
d721 2
a722 2
	int i,num=0;
	char *o,*s,*l=NULL;
d724 9
a732 8
	for (;;)
		{
		s=o=NULL;
		i=BIO_gets(in,buf,512);
		if (i <= 0) return(num);
		buf[i-1]='\0';
		if (!isalnum((unsigned char)buf[0])) return(num);
		o=s=buf;
d735 2
a736 3
		if (*s != '\0')
			{
			*(s++)='\0';
d740 5
a744 5
				s=NULL;
			else
				{
				l=s;
				while ((*l != '\0') && !isspace((unsigned char)*l))
d746 2
a747 3
				if (*l != '\0')
					{
					*(l++)='\0';
d750 11
a760 10
					if (*l == '\0') l=NULL;
					}
				else
					l=NULL;
				}
			}
		else
			s=NULL;
		if ((o == NULL) || (*o == '\0')) return(num);
		if (!OBJ_create(o,s,l)) return(num);
d762 1
a762 1
		}
d764 1
a764 1
	}
d766 5
a770 4
int OBJ_create(const char *oid, const char *sn, const char *ln)
	{
	int ok=0;
	ASN1_OBJECT *op=NULL;
d774 9
a782 9
	i=a2d_ASN1_OBJECT(NULL,0,oid,-1);
	if (i <= 0) return(0);

	if ((buf=(unsigned char *)malloc(i)) == NULL)
		{
		OBJerr(OBJ_F_OBJ_CREATE,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	i=a2d_ASN1_OBJECT(buf,i,oid,-1);
d785 2
a786 2
	op=(ASN1_OBJECT *)ASN1_OBJECT_create(OBJ_new_nid(1),buf,i,sn,ln);
	if (op == NULL) 
d788 2
a789 1
	ok=OBJ_add_object(op);
d793 2
a794 3
	return(ok);
	}

@


1.20
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d597 1
a597 1
			(void) snprintf(tbuf,sizeof tbuf,".%lu",l);
@


1.19
log
@Shrink a local buffer to the size it really needs to be; this is the only
discrepancy found while checking proper {HEX,DECIMAL}_SIZE macro usage, which
is confusing enough.
tweaks and ok jca@@, ok guenther@@
@
text
@d489 1
a489 1
				BUF_strlcpy(buf,s,buf_len);
d579 1
a579 1
				BUF_strlcpy(buf,bndec,buf_len);
d601 1
a601 1
				BUF_strlcpy(buf,tbuf,buf_len);
@


1.18
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d472 1
a472 1
	char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
@


1.17
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@d202 1
a202 1
	OPENSSL_free(a);
d256 1
a256 1
	if (!(ao[ADDED_NID]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;
d258 1
a258 1
		if (!(ao[ADDED_DATA]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;
d260 1
a260 1
		if (!(ao[ADDED_SNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;
d262 1
a262 1
		if (!(ao[ADDED_LNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;
d273 1
a273 1
				OPENSSL_free(aop);
d284 2
a285 2
		if (ao[i] != NULL) OPENSSL_free(ao[i]);
	if (o != NULL) OPENSSL_free(o);
d452 1
a452 1
	if((buf=(unsigned char *)OPENSSL_malloc(j)) == NULL) return NULL;
d462 1
a462 1
	OPENSSL_free(buf);
d593 1
a593 1
			OPENSSL_free(bndec);
d777 1
a777 1
	if ((buf=(unsigned char *)OPENSSL_malloc(i)) == NULL)
d791 1
a791 1
	OPENSSL_free(buf);
@


1.16
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@a707 16
#ifdef CHARSET_EBCDIC
/* THIS IS A KLUDGE - Because the *_obj is sorted in ASCII order, and
 * I don't have perl (yet), we revert to a *LINEAR* search
 * when the object wasn't found in the binary search.
 */
	if (c != 0)
		{
		for (i=0; i<num; ++i)
			{
			p= &(base[i*size]);
			c = (*cmp)(key,p);
			if (c == 0 || (c < 0 && (flags & OBJ_BSEARCH_VALUE_ON_NOMATCH)))
				return p;
			}
		}
#endif
@


1.15
log
@Remove some stuff that isn't needed.
ok miod@@ deraadt@@
@
text
@d597 1
a597 1
			BIO_snprintf(tbuf,sizeof tbuf,".%lu",l);
@


1.14
log
@resolve conflicts, fix local changes
@
text
@d737 1
a737 1
	MS_STATIC char buf[512];
@


1.13
log
@resolve conflicts
@
text
@d77 5
a81 5
static unsigned char lvalues[1];
static ASN1_OBJECT nid_objs[1];
static ASN1_OBJECT *sn_objs[1];
static ASN1_OBJECT *ln_objs[1];
static ASN1_OBJECT *obj_objs[1];
d84 4
a87 3
static int sn_cmp(const void *a, const void *b);
static int ln_cmp(const void *a, const void *b);
static int obj_cmp(const void *a, const void *b);
d98 1
d101 6
a106 1
static LHASH *added=NULL;
d108 2
a109 5
static int sn_cmp(const void *a, const void *b)
	{
	const ASN1_OBJECT * const *ap = a, * const *bp = b;
	return(strcmp((*ap)->sn,(*bp)->sn));
	}
d111 1
a111 5
static int ln_cmp(const void *a, const void *b)
	{ 
	const ASN1_OBJECT * const *ap = a, * const *bp = b;
	return(strcmp((*ap)->ln,(*bp)->ln));
	}
d113 1
a113 2
/* static unsigned long add_hash(ADDED_OBJ *ca) */
static unsigned long add_hash(const void *ca_void)
a118 1
	const ADDED_OBJ *ca = (const ADDED_OBJ *)ca_void;
d146 1
d148 1
a148 2
/* static int add_cmp(ADDED_OBJ *ca, ADDED_OBJ *cb) */
static int add_cmp(const void *ca_void, const void *cb_void)
a151 2
	const ADDED_OBJ *ca = (const ADDED_OBJ *)ca_void;
	const ADDED_OBJ *cb = (const ADDED_OBJ *)cb_void;
d178 1
d183 1
a183 1
	added=lh_new(add_hash,add_cmp);
d187 1
a187 1
static void cleanup1(ADDED_OBJ *a)
d195 1
a195 1
static void cleanup2(ADDED_OBJ *a)
d198 1
a198 1
static void cleanup3(ADDED_OBJ *a)
d205 16
a220 3
static IMPLEMENT_LHASH_DOALL_FN(cleanup1, ADDED_OBJ *)
static IMPLEMENT_LHASH_DOALL_FN(cleanup2, ADDED_OBJ *)
static IMPLEMENT_LHASH_DOALL_FN(cleanup3, ADDED_OBJ *)
d224 5
d230 5
a234 5
	added->down_load=0;
	lh_doall(added,LHASH_DOALL_FN(cleanup1)); /* zero counters */
	lh_doall(added,LHASH_DOALL_FN(cleanup2)); /* set counters */
	lh_doall(added,LHASH_DOALL_FN(cleanup3)); /* free objects */
	lh_free(added);
d270 1
a270 1
			aop=(ADDED_OBJ *)lh_insert(added,ao[i]);
d310 1
a310 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d342 1
a342 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d374 1
a374 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d385 13
d400 1
a400 1
	ASN1_OBJECT **op;
d412 1
a412 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d415 1
a415 2
	op=(ASN1_OBJECT **)OBJ_bsearch((const char *)&a,(const char *)obj_objs,
		NUM_OBJ, sizeof(ASN1_OBJECT *),obj_cmp);
d418 1
a418 1
	return((*op)->nid);
d471 1
a471 1
	unsigned char *p;
d486 7
a492 4
		if (buf)
			BUF_strlcpy(buf,s,buf_len);
		n=strlen(s);
		return n;
d640 2
a641 1
	ASN1_OBJECT o,*oo= &o,**op;
d643 1
d650 1
a650 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d653 1
a653 2
	op=(ASN1_OBJECT **)OBJ_bsearch((char *)&oo,(char *)ln_objs, NUM_LN,
		sizeof(ASN1_OBJECT *),ln_cmp);
d655 1
a655 1
	return((*op)->nid);
d660 2
a661 1
	ASN1_OBJECT o,*oo= &o,**op;
d663 1
d670 1
a670 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d673 1
a673 2
	op=(ASN1_OBJECT **)OBJ_bsearch((char *)&oo,(char *)sn_objs,NUM_SN,
		sizeof(ASN1_OBJECT *),sn_cmp);
d675 1
a675 1
	return((*op)->nid);
d678 2
a679 13
static int obj_cmp(const void *ap, const void *bp)
	{
	int j;
	const ASN1_OBJECT *a= *(ASN1_OBJECT * const *)ap;
	const ASN1_OBJECT *b= *(ASN1_OBJECT * const *)bp;

	j=(a->length - b->length);
        if (j) return(j);
	return(memcmp(a->data,b->data,a->length));
        }

const char *OBJ_bsearch(const char *key, const char *base, int num, int size,
	int (*cmp)(const void *, const void *))
d681 1
a681 1
	return OBJ_bsearch_ex(key, base, num, size, cmp, 0);
d684 4
a687 2
const char *OBJ_bsearch_ex(const char *key, const char *base, int num,
	int size, int (*cmp)(const void *, const void *), int flags)
d689 1
@


1.12
log
@resolve conflicts
@
text
@d61 1
d66 1
d120 1
a120 1
	ADDED_OBJ *ca = (ADDED_OBJ *)ca_void;
d154 2
a155 2
	ADDED_OBJ *ca = (ADDED_OBJ *)ca_void;
	ADDED_OBJ *cb = (ADDED_OBJ *)cb_void;
d166 1
a166 1
		return(memcmp(a->data,b->data,a->length));
d387 2
a388 2
	op=(ASN1_OBJECT **)OBJ_bsearch((char *)&a,(char *)obj_objs,NUM_OBJ,
		sizeof(ASN1_OBJECT *),obj_cmp);
d404 3
a406 1
	unsigned char *buf,*p;
d418 2
a419 2
		/* Clear the error */
		ERR_get_error();
d432 3
a434 3
	
	p=buf;
	op=d2i_ASN1_OBJECT(NULL,&p,j);
d441 2
a442 1
	int i,idx=0,n=0,len,nid;
a444 1
	const char *s;
a446 2
	if (buf_len <= 0) return(0);

a451 3
	if (no_name || (nid=OBJ_obj2nid(a)) == NID_undef) {
		len=a->length;
		p=a->data;
d453 21
a473 1
		idx=0;
d475 32
a506 17
		while (idx < a->length) {
			l|=(p[idx]&0x7f);
			if (!(p[idx] & 0x80)) break;
			l<<=7L;
			idx++;
		}
		idx++;
		i=(int)(l/40);
		if (i > 2) i=2;
		l-=(long)(i*40);

		BIO_snprintf(tbuf,sizeof tbuf,"%d.%lu",i,l);
		i=strlen(tbuf);
		BUF_strlcpy(buf,tbuf,buf_len);
		buf_len-=i;
		buf+=i;
		n+=i;
d508 36
a543 6
		l=0;
		for (; idx<len; idx++) {
			l|=p[idx]&0x7f;
			if (!(p[idx] & 0x80)) {
				BIO_snprintf(tbuf,sizeof tbuf,".%lu",l);
				i=strlen(tbuf);
d545 40
a584 5
					BUF_strlcpy(buf,tbuf,buf_len);
				buf_len-=i;
				buf+=i;
				n+=i;
				l=0;
a585 1
			l<<=7L;
d587 9
a595 8
	} else {
		s=OBJ_nid2ln(nid);
		if (s == NULL)
			s=OBJ_nid2sn(nid);
		BUF_strlcpy(buf,s,buf_len);
		n=strlen(s);
	}
	return(n);
d621 1
a621 1
	op=(ASN1_OBJECT **)OBJ_bsearch((char *)&oo,(char *)ln_objs,NUM_LN,
d649 2
a650 2
	ASN1_OBJECT *a= *(ASN1_OBJECT **)ap;
	ASN1_OBJECT *b= *(ASN1_OBJECT **)bp;
d660 8
a667 2
	int l,h,i,c;
	const char *p;
d682 1
a682 1
			return(p);
d689 10
a698 5
	for (i=0; i<num; ++i) {
		p= &(base[i*size]);
		if ((*cmp)(key,p) == 0)
			return p;
	}
d700 9
a708 1
	return(NULL);
@


1.11
log
@merge 0.9.7d
@
text
@d239 1
a239 1
	if (!(ao[ADDED_NID]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err;
d241 1
a241 1
		ao[ADDED_DATA]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ));
d243 1
a243 1
		ao[ADDED_SNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ));
d245 1
a245 1
		ao[ADDED_LNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ));
d263 2
d653 1
a653 1
		OBJerr(OBJ_F_OBJ_CREATE,OBJ_R_MALLOC_FAILURE);
@


1.10
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d465 1
a465 1
		snprintf(tbuf,sizeof tbuf,"%d.%lu",i,l);
d476 1
a476 1
				snprintf(tbuf,sizeof tbuf,".%lu",l);
@


1.9
log
@Trivial sprintf() -> snprintf() changes. ok deraadt@@
@
text
@d467 1
a467 1
		strncpy(buf,tbuf,buf_len);
d479 1
a479 1
					strncpy(buf,tbuf,buf_len);
d491 1
a491 1
		strncpy(buf,s,buf_len);
a493 1
	buf[buf_len-1]='\0';
@


1.8
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d465 1
a465 1
		sprintf(tbuf,"%d.%lu",i,l);
d476 1
a476 1
				sprintf(tbuf,".%lu",l);
@


1.7
log
@apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@d428 1
a428 1
	op=d2i_ASN1_OBJECT(NULL,&p,i);
@


1.6
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d439 1
a439 1
	char tbuf[32];
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d239 1
a239 1
	ao[ADDED_NID]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ));
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d67 1
a67 1
#ifndef NO_OBJECT
d111 2
a112 1
static unsigned long add_hash(ADDED_OBJ *ca)
d114 1
a114 1
	ASN1_OBJECT *a;
d118 1
d147 2
a148 1
static int add_cmp(ADDED_OBJ *ca, ADDED_OBJ *cb)
d152 2
a178 1
	return(1); /* should not get here */
d206 4
d214 3
a216 3
	lh_doall(added,cleanup1); /* zero counters */
	lh_doall(added,cleanup2); /* set counters */
	lh_doall(added,cleanup3); /* free objects */
d230 1
a230 1
int OBJ_add_object(ASN1_OBJECT *obj)
d366 1
a366 1
int OBJ_obj2nid(ASN1_OBJECT *a)
d379 1
a379 1
		ad.obj=a;
d433 1
a433 1
int OBJ_obj2txt(char *buf, int buf_len, ASN1_OBJECT *a, int no_name)
d448 1
a448 2
	nid=OBJ_obj2nid(a);
	if ((nid == NID_undef) || no_name) {
d498 1
a498 1
int OBJ_txt2nid(char *s)
d557 2
a558 1
char *OBJ_bsearch(char *key, char *base, int num, int size, int (*cmp)(const void *, const void *))
d561 1
a561 1
	char *p;
d640 1
a640 1
int OBJ_create(char *oid, char *sn, char *ln)
d656 2
@


1.4.6.1
log
@Pull in patch from current:
Fix (markus), errata 013:
apply patches from OpenSSL Security Advisory [30 July 2002],
http://marc.theaimsgroup.com/?l=openssl-dev&m=102802395104110&w=2
@
text
@d431 1
a431 1
	char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
@


1.4.4.1
log
@Errata #030 (markus):
Fixes for the "OpenSSL Security Advisory [30 July 2002]"
@
text
@d431 1
a431 1
	char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d82 3
a84 3
static int sn_cmp(ASN1_OBJECT **a, ASN1_OBJECT **b);
static int ln_cmp(ASN1_OBJECT **a, ASN1_OBJECT **b);
static int obj_cmp(ASN1_OBJECT **a, ASN1_OBJECT **b);
d99 5
a103 2
static int sn_cmp(ASN1_OBJECT **ap, ASN1_OBJECT **bp)
	{ return(strcmp((*ap)->sn,(*bp)->sn)); }
d105 5
a109 2
static int ln_cmp(ASN1_OBJECT **ap, ASN1_OBJECT **bp)
	{ return(strcmp((*ap)->ln,(*bp)->ln)); }
d137 2
a138 1
		abort();
d171 2
a172 1
		abort();
d199 1
a199 1
	Free(a);
d231 1
a231 1
	ao[ADDED_NID]=(ADDED_OBJ *)Malloc(sizeof(ADDED_OBJ));
d233 1
a233 1
		ao[ADDED_DATA]=(ADDED_OBJ *)Malloc(sizeof(ADDED_OBJ));
d235 1
a235 1
		ao[ADDED_SNAME]=(ADDED_OBJ *)Malloc(sizeof(ADDED_OBJ));
d237 1
a237 1
		ao[ADDED_LNAME]=(ADDED_OBJ *)Malloc(sizeof(ADDED_OBJ));
d248 1
a248 1
				Free(aop);
d257 2
a258 2
		if (ao[i] != NULL) Free(ao[i]);
	if (o != NULL) Free(o);
d376 1
a376 1
		sizeof(ASN1_OBJECT *),(int (*)())obj_cmp);
d411 1
a411 1
	if((buf=(unsigned char *)Malloc(j)) == NULL) return NULL;
d421 1
a421 1
	Free(buf);
d515 1
a515 1
		sizeof(ASN1_OBJECT *),(int (*)())ln_cmp);
d534 1
a534 1
		sizeof(ASN1_OBJECT *),(int (*)())sn_cmp);
d539 1
a539 1
static int obj_cmp(ASN1_OBJECT **ap, ASN1_OBJECT **bp)
d542 2
a543 2
	ASN1_OBJECT *a= *ap;
	ASN1_OBJECT *b= *bp;
d550 1
a550 1
char *OBJ_bsearch(char *key, char *base, int num, int size, int (*cmp)())
d642 1
a642 1
	if ((buf=(unsigned char *)Malloc(i)) == NULL)
d654 1
a654 1
	Free(buf);
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d217 1
a217 1
	ADDED_OBJ *ao[4],*aop;
a222 4
	ao[ADDED_DATA]=NULL;
	ao[ADDED_SNAME]=NULL;
	ao[ADDED_LNAME]=NULL;
	ao[ADDED_NID]=NULL;
d237 1
a237 1
			aop=(ADDED_OBJ *)lh_insert(added,(char *)ao[i]);
d275 1
a275 1
		adp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);
d307 1
a307 1
		adp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);
d339 1
a339 1
		adp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);
d364 1
a364 1
		adp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);
d503 1
a503 1
		adp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);
d522 1
a522 1
		adp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);
d646 1
a646 1
	Free((char *)buf);
@


1.1
log
@Initial revision
@
text
@d62 3
a64 3
#include "lhash.h"
#include "asn1.h"
#include "objects.h"
d67 1
d69 12
a81 1
#ifndef NOPROTO
a84 6
#else
static int sn_cmp();
static int ln_cmp();
static int obj_cmp();
#endif

d99 1
a99 3
static int sn_cmp(ap,bp)
ASN1_OBJECT **ap;
ASN1_OBJECT **bp;
d102 1
a102 3
static int ln_cmp(ap,bp)
ASN1_OBJECT **ap;
ASN1_OBJECT **bp;
d105 1
a105 2
static unsigned long add_hash(ca)
ADDED_OBJ *ca;
d138 1
a138 2
static int add_cmp(ca,cb)
ADDED_OBJ *ca,*cb;
d166 1
d169 1
a169 1
static int init_added()
d176 1
a176 2
static void cleanup1(a)
ADDED_OBJ *a;
d180 2
a181 1
	                ASN1_OBJECT_FLAG_DYNAMIC_STRINGS;
d184 1
a184 2
static void cleanup2(a)
ADDED_OBJ *a;
d187 1
a187 2
static void cleanup3(a)
ADDED_OBJ *a;
d194 1
a194 1
void OBJ_cleanup()
d205 1
a205 2
int OBJ_new_nid(num)
int num;
d214 1
a214 2
int OBJ_add_object(obj)
ASN1_OBJECT *obj;
d247 3
a249 1
	o->flags&= ~(ASN1_OBJECT_FLAG_DYNAMIC|ASN1_OBJECT_FLAG_DYNAMIC_STRINGS);
d258 1
a258 2
ASN1_OBJECT *OBJ_nid2obj(n)
int n;
d290 1
a290 2
char *OBJ_nid2sn(n)
int n;
d322 1
a322 2
char *OBJ_nid2ln(n)
int n;
d354 1
a354 2
int OBJ_obj2nid(a)
ASN1_OBJECT *a;
d378 50
a427 14
int OBJ_txt2nid(s)
char *s;
	{
	int ret;

	ret=OBJ_sn2nid(s);
	if (ret == NID_undef)
		{
		ret=OBJ_ln2nid(s);
		if (ret == NID_undef)
			{
			ASN1_OBJECT *op=NULL;
			unsigned char *buf,*p;
			int i;
d429 1
a429 7
			i=a2d_ASN1_OBJECT(NULL,0,s,-1);
			if (i <= 0)
				{
				/* clear the error */
				ERR_get_error();
				return(0);
				}
d431 42
a472 9
			if ((buf=(unsigned char *)Malloc(i)) == NULL)
				return(NID_undef);
			a2d_ASN1_OBJECT(buf,i,s,-1);
			p=buf;
			op=d2i_ASN1_OBJECT(NULL,&p,i);
			if (op == NULL) return(NID_undef);
			ret=OBJ_obj2nid(op);
			ASN1_OBJECT_free(op);
			Free(buf);
d474 1
d476 20
a495 2
	return(ret);
	}
d497 1
a497 2
int OBJ_ln2nid(s)
char *s;
d516 1
a516 2
int OBJ_sn2nid(s)
char *s;
d535 1
a535 3
static int obj_cmp(ap, bp)
ASN1_OBJECT **ap;
ASN1_OBJECT **bp;
d546 1
a546 6
char *OBJ_bsearch(key,base,num,size,cmp)
char *key;
char *base;
int num;
int size;
int (*cmp)();
d566 11
d580 1
a580 2
int OBJ_create_objects(in)
BIO *in;
d583 1
a583 1
	int i,num= -1;
d592 1
a592 1
		if (!isalnum(buf[0])) return(num);
d594 1
a594 1
		while (isdigit(*s) || (*s == '.'))
d599 1
a599 1
			while (isspace(*s))
d606 1
a606 1
				while ((*l != '\0') && !isspace(*l))
d611 1
a611 1
					while (isspace(*l))
d625 1
a625 1
	return(num);
d628 1
a628 4
int OBJ_create(oid,sn,ln)
char *oid;
char *sn;
char *ln;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d62 3
a64 3
#include <openssl/lhash.h>
#include <openssl/asn1.h>
#include <openssl/objects.h>
a66 1
#ifndef OPENSSL_NO_OBJECT
d68 5
d74 3
a76 10
/* You will have to load all the objects needed manually in the application */
#define NUM_NID 0
#define NUM_SN 0
#define NUM_LN 0
#define NUM_OBJ 0
static unsigned char lvalues[1];
static ASN1_OBJECT nid_objs[1];
static ASN1_OBJECT *sn_objs[1];
static ASN1_OBJECT *ln_objs[1];
static ASN1_OBJECT *obj_objs[1];
a78 3
static int sn_cmp(const void *a, const void *b);
static int ln_cmp(const void *a, const void *b);
static int obj_cmp(const void *a, const void *b);
d93 9
a101 5
static int sn_cmp(const void *a, const void *b)
	{
	const ASN1_OBJECT * const *ap = a, * const *bp = b;
	return(strcmp((*ap)->sn,(*bp)->sn));
	}
d103 2
a104 8
static int ln_cmp(const void *a, const void *b)
	{ 
	const ASN1_OBJECT * const *ap = a, * const *bp = b;
	return(strcmp((*ap)->ln,(*bp)->ln));
	}

/* static unsigned long add_hash(ADDED_OBJ *ca) */
static unsigned long add_hash(const void *ca_void)
d106 1
a106 1
	const ASN1_OBJECT *a;
a109 1
	ADDED_OBJ *ca = (ADDED_OBJ *)ca_void;
d130 1
a130 2
		/* abort(); */
		return 0;
d137 2
a138 2
/* static int add_cmp(ADDED_OBJ *ca, ADDED_OBJ *cb) */
static int add_cmp(const void *ca_void, const void *cb_void)
a141 2
	ADDED_OBJ *ca = (ADDED_OBJ *)ca_void;
	ADDED_OBJ *cb = (ADDED_OBJ *)cb_void;
d164 1
a164 2
		/* abort(); */
		return 0;
d168 1
a168 1
static int init_added(void)
d175 2
a176 1
static void cleanup1(ADDED_OBJ *a)
d180 1
a180 2
	                ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|
			ASN1_OBJECT_FLAG_DYNAMIC_DATA;
d183 2
a184 1
static void cleanup2(ADDED_OBJ *a)
d187 2
a188 1
static void cleanup3(ADDED_OBJ *a)
d192 1
a192 1
	OPENSSL_free(a);
d195 1
a195 5
static IMPLEMENT_LHASH_DOALL_FN(cleanup1, ADDED_OBJ *)
static IMPLEMENT_LHASH_DOALL_FN(cleanup2, ADDED_OBJ *)
static IMPLEMENT_LHASH_DOALL_FN(cleanup3, ADDED_OBJ *)

void OBJ_cleanup(void)
d199 3
a201 3
	lh_doall(added,LHASH_DOALL_FN(cleanup1)); /* zero counters */
	lh_doall(added,LHASH_DOALL_FN(cleanup2)); /* set counters */
	lh_doall(added,LHASH_DOALL_FN(cleanup3)); /* free objects */
d206 2
a207 1
int OBJ_new_nid(int num)
d216 2
a217 1
int OBJ_add_object(const ASN1_OBJECT *obj)
d220 1
a220 1
	ADDED_OBJ *ao[4]={NULL,NULL,NULL,NULL},*aop;
d226 5
a230 1
	if (!(ao[ADDED_NID]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err;
d232 1
a232 1
		ao[ADDED_DATA]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ));
d234 1
a234 1
		ao[ADDED_SNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ));
d236 1
a236 1
		ao[ADDED_LNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ));
d244 1
a244 1
			aop=(ADDED_OBJ *)lh_insert(added,ao[i]);
d247 1
a247 1
				OPENSSL_free(aop);
d250 1
a250 3
	o->flags&= ~(ASN1_OBJECT_FLAG_DYNAMIC|ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|
			ASN1_OBJECT_FLAG_DYNAMIC_DATA);

d254 2
a255 2
		if (ao[i] != NULL) OPENSSL_free(ao[i]);
	if (o != NULL) OPENSSL_free(o);
d259 2
a260 1
ASN1_OBJECT *OBJ_nid2obj(int n)
d281 1
a281 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d292 2
a293 1
const char *OBJ_nid2sn(int n)
d314 1
a314 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d325 2
a326 1
const char *OBJ_nid2ln(int n)
d347 1
a347 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d358 2
a359 1
int OBJ_obj2nid(const ASN1_OBJECT *a)
d372 2
a373 2
		ad.obj=(ASN1_OBJECT *)a; /* XXX: ugly but harmless */
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d377 1
a377 1
		sizeof(ASN1_OBJECT *),obj_cmp);
d383 2
a384 7
/* Convert an object name into an ASN1_OBJECT
 * if "noname" is not set then search for short and long names first.
 * This will convert the "dotted" form into an object: unlike OBJ_txt2nid
 * it can be used with any objects, not just registered ones.
 */

ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)
d386 1
a386 4
	int nid = NID_undef;
	ASN1_OBJECT *op=NULL;
	unsigned char *buf,*p;
	int i, j;
d388 9
a396 37
	if(!no_name) {
		if( ((nid = OBJ_sn2nid(s)) != NID_undef) ||
			((nid = OBJ_ln2nid(s)) != NID_undef) ) 
					return OBJ_nid2obj(nid);
	}

	/* Work out size of content octets */
	i=a2d_ASN1_OBJECT(NULL,0,s,-1);
	if (i <= 0) {
		/* Clear the error */
		ERR_get_error();
		return NULL;
	}
	/* Work out total size */
	j = ASN1_object_size(0,i,V_ASN1_OBJECT);

	if((buf=(unsigned char *)OPENSSL_malloc(j)) == NULL) return NULL;

	p = buf;
	/* Write out tag+length */
	ASN1_put_object(&p,0,i,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);
	/* Write out contents */
	a2d_ASN1_OBJECT(p,i,s,-1);
	
	p=buf;
	op=d2i_ASN1_OBJECT(NULL,&p,i);
	OPENSSL_free(buf);
	return op;
	}

int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
{
	int i,idx=0,n=0,len,nid;
	unsigned long l;
	unsigned char *p;
	const char *s;
	char tbuf[32];
d398 7
a404 6
	if (buf_len <= 0) return(0);

	if ((a == NULL) || (a->data == NULL)) {
		buf[0]='\0';
		return(0);
	}
d406 9
a414 36
	if (no_name || (nid=OBJ_obj2nid(a)) == NID_undef) {
		len=a->length;
		p=a->data;

		idx=0;
		l=0;
		while (idx < a->length) {
			l|=(p[idx]&0x7f);
			if (!(p[idx] & 0x80)) break;
			l<<=7L;
			idx++;
		}
		idx++;
		i=(int)(l/40);
		if (i > 2) i=2;
		l-=(long)(i*40);

		sprintf(tbuf,"%d.%lu",i,l);
		i=strlen(tbuf);
		strncpy(buf,tbuf,buf_len);
		buf_len-=i;
		buf+=i;
		n+=i;

		l=0;
		for (; idx<len; idx++) {
			l|=p[idx]&0x7f;
			if (!(p[idx] & 0x80)) {
				sprintf(tbuf,".%lu",l);
				i=strlen(tbuf);
				if (buf_len > 0)
					strncpy(buf,tbuf,buf_len);
				buf_len-=i;
				buf+=i;
				n+=i;
				l=0;
a415 1
			l<<=7L;
d417 2
a418 10
	} else {
		s=OBJ_nid2ln(nid);
		if (s == NULL)
			s=OBJ_nid2sn(nid);
		strncpy(buf,s,buf_len);
		n=strlen(s);
	}
	buf[buf_len-1]='\0';
	return(n);
}
d420 2
a421 11
int OBJ_txt2nid(const char *s)
{
	ASN1_OBJECT *obj;
	int nid;
	obj = OBJ_txt2obj(s, 0);
	nid = OBJ_obj2nid(obj);
	ASN1_OBJECT_free(obj);
	return nid;
}

int OBJ_ln2nid(const char *s)
d431 1
a431 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d435 1
a435 1
		sizeof(ASN1_OBJECT *),ln_cmp);
d440 2
a441 1
int OBJ_sn2nid(const char *s)
d451 1
a451 1
		adp=(ADDED_OBJ *)lh_retrieve(added,&ad);
d455 1
a455 1
		sizeof(ASN1_OBJECT *),sn_cmp);
d460 3
a462 1
static int obj_cmp(const void *ap, const void *bp)
d465 2
a466 2
	ASN1_OBJECT *a= *(ASN1_OBJECT **)ap;
	ASN1_OBJECT *b= *(ASN1_OBJECT **)bp;
d473 6
a478 2
const char *OBJ_bsearch(const char *key, const char *base, int num, int size,
	int (*cmp)(const void *, const void *))
d481 1
a481 1
	const char *p;
a497 11
#ifdef CHARSET_EBCDIC
/* THIS IS A KLUDGE - Because the *_obj is sorted in ASCII order, and
 * I don't have perl (yet), we revert to a *LINEAR* search
 * when the object wasn't found in the binary search.
 */
	for (i=0; i<num; ++i) {
		p= &(base[i*size]);
		if ((*cmp)(key,p) == 0)
			return p;
	}
#endif
d501 2
a502 1
int OBJ_create_objects(BIO *in)
d505 1
a505 1
	int i,num=0;
d514 1
a514 1
		if (!isalnum((unsigned char)buf[0])) return(num);
d516 1
a516 1
		while (isdigit((unsigned char)*s) || (*s == '.'))
d521 1
a521 1
			while (isspace((unsigned char)*s))
d528 1
a528 1
				while ((*l != '\0') && !isspace((unsigned char)*l))
d533 1
a533 1
					while (isspace((unsigned char)*l))
d547 1
a547 1
	/* return(num); */
d550 4
a553 1
int OBJ_create(const char *oid, const char *sn, const char *ln)
d563 1
a563 1
	if ((buf=(unsigned char *)OPENSSL_malloc(i)) == NULL)
a568 2
	if (i == 0)
		goto err;
d575 1
a575 1
	OPENSSL_free(buf);
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@d439 1
a439 1
	char tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];
@


1.1.1.4
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d428 1
a428 1
	op=d2i_ASN1_OBJECT(NULL,&p,j);
@


1.1.1.5
log
@import 0.9.7b (without idea and rc5)
@
text
@d467 1
a467 1
		BUF_strlcpy(buf,tbuf,buf_len);
d479 1
a479 1
					BUF_strlcpy(buf,tbuf,buf_len);
d491 1
a491 1
		BUF_strlcpy(buf,s,buf_len);
d494 1
@


1.1.1.6
log
@import openssl-0.9.7d
@
text
@d465 1
a465 1
		BIO_snprintf(tbuf,sizeof tbuf,"%d.%lu",i,l);
d476 1
a476 1
				BIO_snprintf(tbuf,sizeof tbuf,".%lu",l);
@


1.1.1.7
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d239 1
a239 1
	if (!(ao[ADDED_NID]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;
d241 1
a241 1
		if (!(ao[ADDED_DATA]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;
d243 1
a243 1
		if (!(ao[ADDED_SNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;
d245 1
a245 1
		if (!(ao[ADDED_LNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;
a262 2
err2:
	OBJerr(OBJ_F_OBJ_ADD_OBJECT,ERR_R_MALLOC_FAILURE);
d651 1
a651 1
		OBJerr(OBJ_F_OBJ_CREATE,ERR_R_MALLOC_FAILURE);
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@a60 1
#include <limits.h>
a64 1
#include <openssl/bn.h>
d118 1
a118 1
	const ADDED_OBJ *ca = (const ADDED_OBJ *)ca_void;
d152 2
a153 2
	const ADDED_OBJ *ca = (const ADDED_OBJ *)ca_void;
	const ADDED_OBJ *cb = (const ADDED_OBJ *)cb_void;
d164 1
a164 1
		return(memcmp(a->data,b->data,(size_t)a->length));
d385 2
a386 2
	op=(ASN1_OBJECT **)OBJ_bsearch((const char *)&a,(const char *)obj_objs,
		NUM_OBJ, sizeof(ASN1_OBJECT *),obj_cmp);
d402 1
a402 3
	unsigned char *buf;
	unsigned char *p;
	const unsigned char *cp;
d414 2
a415 2
		/* Don't clear the error */
		/*ERR_clear_error();*/
d428 3
a430 3

	cp=buf;
	op=d2i_ASN1_OBJECT(NULL,&cp,j);
d437 1
a437 2
	int i,n=0,len,nid, first, use_bn;
	BIGNUM *bl;
d440 1
d443 2
d450 3
d454 19
a472 11
	if (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)
		{
		const char *s;
		s=OBJ_nid2ln(nid);
		if (s == NULL)
			s=OBJ_nid2sn(nid);
		if (buf)
			BUF_strlcpy(buf,s,buf_len);
		n=strlen(s);
		return n;
		}
a473 9

	len=a->length;
	p=a->data;

	first = 1;
	bl = NULL;

	while (len > 0)
		{
d475 5
a479 69
		use_bn = 0;
		for (;;)
			{
			unsigned char c = *p++;
			len--;
			if ((len == 0) && (c & 0x80))
				goto err;
			if (use_bn)
				{
				if (!BN_add_word(bl, c & 0x7f))
					goto err;
				}
			else
				l |= c  & 0x7f;
			if (!(c & 0x80))
				break;
			if (!use_bn && (l > (ULONG_MAX >> 7L)))
				{
				if (!bl && !(bl = BN_new()))
					goto err;
				if (!BN_set_word(bl, l))
					goto err;
				use_bn = 1;
				}
			if (use_bn)
				{
				if (!BN_lshift(bl, bl, 7))
					goto err;
				}
			else
				l<<=7L;
			}

		if (first)
			{
			first = 0;
			if (l >= 80)
				{
				i = 2;
				if (use_bn)
					{
					if (!BN_sub_word(bl, 80))
						goto err;
					}
				else
					l -= 80;
				}
			else
				{
				i=(int)(l/40);
				l-=(long)(i*40);
				}
			if (buf && (buf_len > 0))
				{
				*buf++ = i + '0';
				buf_len--;
				}
			n++;
			}

		if (use_bn)
			{
			char *bndec;
			bndec = BN_bn2dec(bl);
			if (!bndec)
				goto err;
			i = strlen(bndec);
			if (buf)
				{
d481 5
a485 40
					{
					*buf++ = '.';
					buf_len--;
					}
				BUF_strlcpy(buf,bndec,buf_len);
				if (i > buf_len)
					{
					buf += buf_len;
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n++;
			n += i;
			OPENSSL_free(bndec);
			}
		else
			{
			BIO_snprintf(tbuf,sizeof tbuf,".%lu",l);
			i=strlen(tbuf);
			if (buf && (buf_len > 0))
				{
				BUF_strlcpy(buf,tbuf,buf_len);
				if (i > buf_len)
					{
					buf += buf_len;
					buf_len = 0;
					}
				else
					{
					buf+=i;
					buf_len-=i;
					}
				}
			n+=i;
			l=0;
d487 1
d489 8
a496 9

	if (bl)
		BN_free(bl);
	return n;

	err:
	if (bl)
		BN_free(bl);
	return -1;
d522 1
a522 1
	op=(ASN1_OBJECT **)OBJ_bsearch((char *)&oo,(char *)ln_objs, NUM_LN,
d550 2
a551 2
	const ASN1_OBJECT *a= *(ASN1_OBJECT * const *)ap;
	const ASN1_OBJECT *b= *(ASN1_OBJECT * const *)bp;
d561 2
a562 8
	return OBJ_bsearch_ex(key, base, num, size, cmp, 0);
	}

const char *OBJ_bsearch_ex(const char *key, const char *base, int num,
	int size, int (*cmp)(const void *, const void *), int flags)
	{
	int l,h,i=0,c=0;
	const char *p = NULL;
d577 1
a577 1
			break;
d584 5
a588 10
	if (c != 0)
		{
		for (i=0; i<num; ++i)
			{
			p= &(base[i*size]);
			c = (*cmp)(key,p);
			if (c == 0 || (c < 0 && (flags & OBJ_BSEARCH_VALUE_ON_NOMATCH)))
				return p;
			}
		}
d590 1
a590 9
	if (c != 0 && !(flags & OBJ_BSEARCH_VALUE_ON_NOMATCH))
		p = NULL;
	else if (c == 0 && (flags & OBJ_BSEARCH_FIRST_VALUE_ON_MATCH))
		{
		while(i > 0 && (*cmp)(key,&(base[(i-1)*size])) == 0)
			i--;
		p = &(base[i*size]);
		}
	return(p);
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d77 5
a81 5
static const unsigned char lvalues[1];
static const ASN1_OBJECT nid_objs[1];
static const unsigned int sn_objs[1];
static const unsigned int ln_objs[1];
static const unsigned int obj_objs[1];
d84 3
a86 4
DECLARE_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, sn);
DECLARE_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, ln);
DECLARE_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, obj);

a96 1
DECLARE_LHASH_OF(ADDED_OBJ);
d99 1
a99 1
static LHASH_OF(ADDED_OBJ) *added=NULL;
d101 5
a105 2
static int sn_cmp(const ASN1_OBJECT * const *a, const unsigned int *b)
	{ return(strcmp((*a)->sn,nid_objs[*b].sn)); }
d107 5
a111 4
IMPLEMENT_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, sn);

static int ln_cmp(const ASN1_OBJECT * const *a, const unsigned int *b)
	{ return(strcmp((*a)->ln,nid_objs[*b].ln)); }
d113 2
a114 3
IMPLEMENT_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, ln);

static unsigned long added_obj_hash(const ADDED_OBJ *ca)
d120 1
a147 1
static IMPLEMENT_LHASH_HASH_FN(added_obj, ADDED_OBJ)
d149 2
a150 1
static int added_obj_cmp(const ADDED_OBJ *ca, const ADDED_OBJ *cb)
d154 2
a181 1
static IMPLEMENT_LHASH_COMP_FN(added_obj, ADDED_OBJ)
d186 1
a186 1
	added=lh_ADDED_OBJ_new();
d190 1
a190 1
static void cleanup1_doall(ADDED_OBJ *a)
d198 1
a198 1
static void cleanup2_doall(ADDED_OBJ *a)
d201 1
a201 1
static void cleanup3_doall(ADDED_OBJ *a)
d208 3
a210 16
static IMPLEMENT_LHASH_DOALL_FN(cleanup1, ADDED_OBJ)
static IMPLEMENT_LHASH_DOALL_FN(cleanup2, ADDED_OBJ)
static IMPLEMENT_LHASH_DOALL_FN(cleanup3, ADDED_OBJ)

/* The purpose of obj_cleanup_defer is to avoid EVP_cleanup() attempting
 * to use freed up OIDs. If neccessary the actual freeing up of OIDs is
 * delayed.
 */

int obj_cleanup_defer = 0;

void check_defer(int nid)
	{
	if (!obj_cleanup_defer && nid >= NUM_NID)
			obj_cleanup_defer = 1;
	}
a213 5
	if (obj_cleanup_defer)
		{
		obj_cleanup_defer = 2;
		return ;
		}
d215 5
a219 5
	lh_ADDED_OBJ_down_load(added) = 0;
	lh_ADDED_OBJ_doall(added,LHASH_DOALL_FN(cleanup1)); /* zero counters */
	lh_ADDED_OBJ_doall(added,LHASH_DOALL_FN(cleanup2)); /* set counters */
	lh_ADDED_OBJ_doall(added,LHASH_DOALL_FN(cleanup3)); /* free objects */
	lh_ADDED_OBJ_free(added);
d255 1
a255 1
			aop=lh_ADDED_OBJ_insert(added,ao[i]);
d295 1
a295 1
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
d327 1
a327 1
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
d359 1
a359 1
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
a369 13
static int obj_cmp(const ASN1_OBJECT * const *ap, const unsigned int *bp)
	{
	int j;
	const ASN1_OBJECT *a= *ap;
	const ASN1_OBJECT *b= &nid_objs[*bp];

	j=(a->length - b->length);
        if (j) return(j);
	return(memcmp(a->data,b->data,a->length));
	}

IMPLEMENT_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, obj);

d372 1
a372 1
	const unsigned int *op;
d384 1
a384 1
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
d387 2
a388 1
	op=OBJ_bsearch_obj(&a, obj_objs, NUM_OBJ);
d391 1
a391 1
	return(nid_objs[*op].nid);
d444 1
a444 1
	const unsigned char *p;
d459 4
a462 7
		if (s)
			{
			if (buf)
				BUF_strlcpy(buf,s,buf_len);
			n=strlen(s);
			return n;
			}
d610 1
a610 2
	ASN1_OBJECT o;
	const ASN1_OBJECT *oo= &o;
a611 1
	const unsigned int *op;
d618 1
a618 1
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
d621 2
a622 1
	op=OBJ_bsearch_ln(&oo, ln_objs, NUM_LN);
d624 1
a624 1
	return(nid_objs[*op].nid);
d629 1
a629 2
	ASN1_OBJECT o;
	const ASN1_OBJECT *oo= &o;
a630 1
	const unsigned int *op;
d637 1
a637 1
		adp=lh_ADDED_OBJ_retrieve(added,&ad);
d640 2
a641 1
	op=OBJ_bsearch_sn(&oo, sn_objs, NUM_SN);
d643 1
a643 1
	return(nid_objs[*op].nid);
d646 13
a658 2
const void *OBJ_bsearch_(const void *key, const void *base, int num, int size,
			 int (*cmp)(const void *, const void *))
d660 1
a660 1
	return OBJ_bsearch_ex_(key, base, num, size, cmp, 0);
d663 2
a664 4
const void *OBJ_bsearch_ex_(const void *key, const void *base_, int num,
			    int size,
			    int (*cmp)(const void *, const void *),
			    int flags)
a665 1
	const char *base=base_;
@


