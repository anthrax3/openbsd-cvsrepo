head	1.29;
access;
symbols;
locks; strict;
comment	@ * @;


1.29
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.28;
commitid	kT0fLt3r4lroFJra;

1.28
date	2015.02.07.13.19.15;	author doug;	state Exp;
branches;
next	1.27;
commitid	gtwLkRyWx0K1HbzX;

1.27
date	2014.07.11.08.44.48;	author jsing;	state Exp;
branches;
next	1.26;
commitid	yQEL1wOWIearrW15;

1.26
date	2014.07.10.13.58.22;	author jsing;	state Exp;
branches;
next	1.25;
commitid	id8dTrTMtnTn4fqt;

1.25
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	mJUVYpkFBZ0Zv2bG;

1.24
date	2014.06.11.01.53.02;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	4evB2EbwDYaBfe0g;

1.23
date	2014.05.30.06.22.57;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.27.20.26.48;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.23.21.55.26;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.23.21.54.30;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.20.22.31.55;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.19.15.30.17;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.17.13.37.48;	author beck;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.15.20.13.09;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.22.17.11.37;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.18.18.06.09;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.06.12.20.16;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.30.13.08.02;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.07.03.45.33;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.15.02.29.13;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.15.02.57.33;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.16;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.11.11.21.14.23;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.06.27.05.05.32;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2011.11.03.02.32.10;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2012.10.13.21.23.39;	author djm;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: dso_dlfcn.c,v 1.28 2015/02/07 13:19:15 doug Exp $ */
/* Written by Geoff Thorpe (geoff@@geoffthorpe.net) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/dso.h>
#include <openssl/err.h>

#ifndef DSO_DLFCN
DSO_METHOD *
DSO_METHOD_dlfcn(void)
{
	return NULL;
}
#else

#ifdef HAVE_DLFCN_H
# include <dlfcn.h>
# define HAVE_DLINFO 1
#endif

/* Part of the hack in "dlfcn_load" ... */
#define DSO_MAX_TRANSLATED_SIZE 256

static int dlfcn_load(DSO *dso);
static int dlfcn_unload(DSO *dso);
static void *dlfcn_bind_var(DSO *dso, const char *symname);
static DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname);
static char *dlfcn_name_converter(DSO *dso, const char *filename);
static char *dlfcn_merger(DSO *dso, const char *filespec1,
    const char *filespec2);
static int dlfcn_pathbyaddr(void *addr, char *path, int sz);
static void *dlfcn_globallookup(const char *name);

static DSO_METHOD dso_meth_dlfcn = {
	.name = "OpenSSL 'dlfcn' shared library method",
	.dso_load = dlfcn_load,
	.dso_unload = dlfcn_unload,
	.dso_bind_var = dlfcn_bind_var,
	.dso_bind_func = dlfcn_bind_func,
	.dso_name_converter = dlfcn_name_converter,
	.dso_merger = dlfcn_merger,
	.pathbyaddr = dlfcn_pathbyaddr,
	.globallookup = dlfcn_globallookup
};

DSO_METHOD *
DSO_METHOD_dlfcn(void)
{
	return (&dso_meth_dlfcn);
}

/* For this DSO_METHOD, our meth_data STACK will contain;
 * (i) the handle (void*) returned from dlopen().
 */

static int
dlfcn_load(DSO *dso)
{
	void *ptr = NULL;
	/* See applicable comments in dso_dl.c */
	char *filename = DSO_convert_filename(dso, NULL);
	int flags = RTLD_LAZY;

	if (filename == NULL) {
		DSOerror(DSO_R_NO_FILENAME);
		goto err;
	}

	if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)
		flags |= RTLD_GLOBAL;
	ptr = dlopen(filename, flags);
	if (ptr == NULL) {
		DSOerror(DSO_R_LOAD_FAILED);
		ERR_asprintf_error_data("filename(%s): %s", filename,
		    dlerror());
		goto err;
	}
	if (!sk_void_push(dso->meth_data, (char *)ptr)) {
		DSOerror(DSO_R_STACK_ERROR);
		goto err;
	}
	/* Success */
	dso->loaded_filename = filename;
	return (1);

err:
	/* Cleanup! */
	free(filename);
	if (ptr != NULL)
		dlclose(ptr);
	return (0);
}

static int
dlfcn_unload(DSO *dso)
{
	void *ptr;
	if (dso == NULL) {
		DSOerror(ERR_R_PASSED_NULL_PARAMETER);
		return (0);
	}
	if (sk_void_num(dso->meth_data) < 1)
		return (1);
	ptr = sk_void_pop(dso->meth_data);
	if (ptr == NULL) {
		DSOerror(DSO_R_NULL_HANDLE);
		/* Should push the value back onto the stack in
		 * case of a retry. */
		sk_void_push(dso->meth_data, ptr);
		return (0);
	}
	/* For now I'm not aware of any errors associated with dlclose() */
	dlclose(ptr);
	return (1);
}

static void *
dlfcn_bind_var(DSO *dso, const char *symname)
{
	void *ptr, *sym;

	if ((dso == NULL) || (symname == NULL)) {
		DSOerror(ERR_R_PASSED_NULL_PARAMETER);
		return (NULL);
	}
	if (sk_void_num(dso->meth_data) < 1) {
		DSOerror(DSO_R_STACK_ERROR);
		return (NULL);
	}
	ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);
	if (ptr == NULL) {
		DSOerror(DSO_R_NULL_HANDLE);
		return (NULL);
	}
	sym = dlsym(ptr, symname);
	if (sym == NULL) {
		DSOerror(DSO_R_SYM_FAILURE);
		ERR_asprintf_error_data("symname(%s): %s", symname, dlerror());
		return (NULL);
	}
	return (sym);
}

static DSO_FUNC_TYPE
dlfcn_bind_func(DSO *dso, const char *symname)
{
	void *ptr;
	union {
		DSO_FUNC_TYPE sym;
		void *dlret;
	} u;

	if ((dso == NULL) || (symname == NULL)) {
		DSOerror(ERR_R_PASSED_NULL_PARAMETER);
		return (NULL);
	}
	if (sk_void_num(dso->meth_data) < 1) {
		DSOerror(DSO_R_STACK_ERROR);
		return (NULL);
	}
	ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);
	if (ptr == NULL) {
		DSOerror(DSO_R_NULL_HANDLE);
		return (NULL);
	}
	u.dlret = dlsym(ptr, symname);
	if (u.dlret == NULL) {
		DSOerror(DSO_R_SYM_FAILURE);
		ERR_asprintf_error_data("symname(%s): %s", symname, dlerror());
		return (NULL);
	}
	return u.sym;
}

static char *
dlfcn_merger(DSO *dso, const char *filespec1, const char *filespec2)
{
	char *merged;

	if (!filespec1 && !filespec2) {
		DSOerror(ERR_R_PASSED_NULL_PARAMETER);
		return (NULL);
	}
	/* If the first file specification is a rooted path, it rules.
	   same goes if the second file specification is missing. */
	if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {
		merged = strdup(filespec1);
		if (!merged) {
			DSOerror(ERR_R_MALLOC_FAILURE);
			return (NULL);
		}
	}
	/* If the first file specification is missing, the second one rules. */
	else if (!filespec1) {
		merged = strdup(filespec2);
		if (!merged) {
			DSOerror(ERR_R_MALLOC_FAILURE);
			return (NULL);
		}
	} else
		/* This part isn't as trivial as it looks.  It assumes that
		   the second file specification really is a directory, and
		   makes no checks whatsoever.  Therefore, the result becomes
		   the concatenation of filespec2 followed by a slash followed
		   by filespec1. */
	{
		size_t spec2len, len;

		spec2len = strlen(filespec2);
		len = spec2len + (filespec1 ? strlen(filespec1) : 0);

		if (filespec2 && filespec2[spec2len - 1] == '/') {
			spec2len--;
			len--;
		}
		merged = malloc(len + 2);
		if (!merged) {
			DSOerror(ERR_R_MALLOC_FAILURE);
			return (NULL);
		}
		strlcpy(merged, filespec2, len + 2);
		merged[spec2len] = '/';
		strlcpy(&merged[spec2len + 1], filespec1, len + 1 - spec2len);
	}
	return (merged);
}

#define DSO_ext	".so"
#define DSO_extlen 3

static char *
dlfcn_name_converter(DSO *dso, const char *filename)
{
	char *translated;
	int ret;

	if (strchr(filename, '/') == NULL) {
		/* Bare name, so convert to "%s.so" or "lib%s.so" */
		if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
			ret = asprintf(&translated, "lib%s" DSO_ext, filename);
		else
			ret = asprintf(&translated, "%s" DSO_ext, filename);
		if (ret == -1)
			translated = NULL;
	} else {
		/* Full path, so just duplicate it */
		translated = strdup(filename);
	}

	if (translated == NULL)
		DSOerror(DSO_R_NAME_TRANSLATION_FAILED);
	return (translated);
}

static int
dlfcn_pathbyaddr(void *addr, char *path, int sz)
{
	Dl_info dli;
	int len;

	if (addr == NULL) {
		union{
			int(*f)(void*, char*, int);
			void *p;
		} t = { dlfcn_pathbyaddr };
		addr = t.p;
	}

	if (dladdr(addr, &dli)) {
		len = (int)strlen(dli.dli_fname);
		if (sz <= 0)
			return len + 1;
		if (len >= sz)
			len = sz - 1;
		memcpy(path, dli.dli_fname, len);
		path[len++] = 0;
		return len;
	}

	ERR_asprintf_error_data("dlfcn_pathbyaddr(): %s", dlerror());
	return -1;
}

static void *
dlfcn_globallookup(const char *name)
{
	void *ret = NULL, *handle = dlopen(NULL, RTLD_LAZY);

	if (handle) {
		ret = dlsym(handle, name);
		dlclose(handle);
	}

	return ret;
}
#endif /* DSO_DLFCN */
@


1.28
log
@Delete a lot of #if 0 code in libressl.

There are a few instances where #if 1 is removed but the code remains.

Based on the following OpenSSL commits.  Some of the commits weren't
strictly deletions so they are going to be split up into separate commits.

6f91b017bbb7140f816721141ac156d1b828a6b3
3d47c1d331fdc7574d2275cda1a630ccdb624b08
dfb56425b68314b2b57e17c82c1df42e7a015132
c8fa2356a00cbaada8963f739e5570298311a060
f16a64d11f55c01f56baa62ebf1dec7f8fe718cb
9ccc00ef6ea65567622e40c49aca43f2c6d79cdb
02a938c953b3e1ced71d9a832de1618f907eb96d
75d0ebef2aef7a2c77b27575b8da898e22f3ccd5
d6fbb194095312f4722c81c9362dbd0de66cb656
6f1a93ad111c7dfe36a09a976c4c009079b19ea1
1a5adcfb5edfe23908b350f8757df405b0f5f71f
8de24b792743d11e1d5a0dcd336a49368750c577
a2b18e657ea1a932d125154f4e13ab2258796d90
8e964419603d2478dfb391c66e7ccb2dcc9776b4
32dfde107636ac9bc62a5b3233fe2a54dbc27008

input + ok jsing@@, miod@@, tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: dso_dlfcn.c,v 1.27 2014/07/11 08:44:48 jsing Exp $ */
d122 1
a122 1
		DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);
d130 1
a130 1
		DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);
d136 1
a136 1
		DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);
d156 1
a156 1
		DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);
d163 1
a163 1
		DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);
d180 1
a180 1
		DSOerr(DSO_F_DLFCN_BIND_VAR, ERR_R_PASSED_NULL_PARAMETER);
d184 1
a184 1
		DSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_STACK_ERROR);
d189 1
a189 1
		DSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_NULL_HANDLE);
d194 1
a194 1
		DSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_SYM_FAILURE);
d211 1
a211 1
		DSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);
d215 1
a215 1
		DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR);
d220 1
a220 1
		DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE);
d225 1
a225 1
		DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE);
d238 1
a238 2
		DSOerr(DSO_F_DLFCN_MERGER,
		    ERR_R_PASSED_NULL_PARAMETER);
d246 1
a246 1
			DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
d254 1
a254 1
			DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
d275 1
a275 1
			DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
d308 1
a308 2
		DSOerr(DSO_F_DLFCN_NAME_CONVERTER,
		    DSO_R_NAME_TRANSLATION_FAILED);
@


1.27
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dso_dlfcn.c,v 1.26 2014/07/10 13:58:22 jsing Exp $ */
a84 6
#if 0
static int dlfcn_unbind(DSO *dso, char *symname, void *symptr);
static int dlfcn_init(DSO *dso);
static int dlfcn_finish(DSO *dso);
static long dlfcn_ctrl(DSO *dso, int cmd, long larg, void *parg);
#endif
@


1.26
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dso_dlfcn.c,v 1.25 2014/06/12 15:49:29 deraadt Exp $ */
a61 1
#include "cryptlib.h"
d63 1
@


1.25
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 2
@


1.24
log
@c-file-style hints, begone; ok beck
@
text
@d1 1
a1 1
/* dso_dlfcn.c */
@


1.23
log
@more: no need for null check before free
ok tedu guenther
@
text
@d1 1
a1 1
/* dso_dlfcn.c -*- mode:C; c-file-style: "eay" -*- */
@


1.22
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d149 1
a149 2
	if (filename != NULL)
		free(filename);
@


1.21
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d96 9
a104 17
	"OpenSSL 'dlfcn' shared library method",
	dlfcn_load,
	dlfcn_unload,
	dlfcn_bind_var,
	dlfcn_bind_func,
/* For now, "unbind" doesn't exist */
#if 0
	NULL, /* unbind_var */
	NULL, /* unbind_func */
#endif
	NULL, /* ctrl */
	dlfcn_name_converter,
	dlfcn_merger,
	NULL, /* init */
	NULL, /* finish */
	dlfcn_pathbyaddr,
	dlfcn_globallookup
@


1.20
log
@fix some variables
@
text
@d143 2
a144 1
		ERR_add_error_data(4, "filename(", filename, "): ", dlerror());
d208 1
a208 1
		ERR_add_error_data(4, "symname(", symname, "): ", dlerror());
d239 1
a239 1
		ERR_add_error_data(4, "symname(", symname, "): ", dlerror());
d352 1
a352 1
	ERR_add_error_data(4, "dlfcn_pathbyaddr(): ", dlerror());
@


1.19
log
@replace a bunch of hand duped strings with strdup
@
text
@a247 1
	size_t len;
d277 1
a277 1
		int spec2len, len;
@


1.18
log
@Eliminate duplicated logic by switching from malloc+snprintf to asprintf

ok beck@@
@
text
@d258 1
a258 2
		len = strlen(filespec1) + 1;
		merged = malloc(len);
a262 1
		strlcpy(merged, filespec1, len);
d266 1
a266 2
		len = strlen(filespec2) + 1;
		merged = malloc(strlen(filespec2) + 1);
a270 1
		strlcpy(merged, filespec2, len);
@


1.17
log
@KNF.
@
text
@d310 1
a310 1
	int len, rsize, transform;
d312 2
a313 6
	len = strlen(filename);
	rsize = len + 1;
	transform = (strstr(filename, "/") == NULL);
	if (transform) {
		/* We will convert this to "%s.so" or "lib%s.so" etc */
		rsize += DSO_extlen;	/* The length of ".so" */
d315 8
a322 1
			rsize += 3; /* The length of "lib" */
d324 2
a325 2
	translated = malloc(rsize);
	if (translated == NULL) {
a327 9
		return (NULL);
	}
	if (transform) {
		if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
			snprintf(translated, rsize, "lib%s" DSO_ext, filename);
		else
			snprintf(translated, rsize, "%s" DSO_ext, filename);
	} else
		snprintf(translated, rsize, "%s", filename);
@


1.16
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d64 3
a66 2
DSO_METHOD *DSO_METHOD_dlfcn(void)
	{
d68 1
a68 1
	}
d91 2
a92 2
	const char *filespec2);
static int dlfcn_pathbyaddr(void *addr,char *path,int sz);
d113 1
a113 1
	};
d115 5
a119 4
DSO_METHOD *DSO_METHOD_dlfcn(void)
	{
	return(&dso_meth_dlfcn);
	}
d125 3
a127 2
static int dlfcn_load(DSO *dso)
	{
d133 2
a134 3
	if(filename == NULL)
		{
		DSOerr(DSO_F_DLFCN_LOAD,DSO_R_NO_FILENAME);
d136 1
a136 1
		}
d141 2
a142 3
	if(ptr == NULL)
		{
		DSOerr(DSO_F_DLFCN_LOAD,DSO_R_LOAD_FAILED);
d145 3
a147 4
		}
	if(!sk_void_push(dso->meth_data, (char *)ptr))
		{
		DSOerr(DSO_F_DLFCN_LOAD,DSO_R_STACK_ERROR);
d149 1
a149 1
		}
d152 2
a153 1
	return(1);
d156 1
a156 1
	if(filename != NULL)
d158 1
a158 1
	if(ptr != NULL)
d160 1
a160 1
	return(0);
d163 3
a165 2
static int dlfcn_unload(DSO *dso)
	{
d167 6
a172 7
	if(dso == NULL)
		{
		DSOerr(DSO_F_DLFCN_UNLOAD,ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if(sk_void_num(dso->meth_data) < 1)
		return(1);
d174 2
a175 3
	if(ptr == NULL)
		{
		DSOerr(DSO_F_DLFCN_UNLOAD,DSO_R_NULL_HANDLE);
d179 2
a180 2
		return(0);
		}
d183 2
a184 2
	return(1);
	}
d186 3
a188 2
static void *dlfcn_bind_var(DSO *dso, const char *symname)
	{
d191 8
a198 10
	if((dso == NULL) || (symname == NULL))
		{
		DSOerr(DSO_F_DLFCN_BIND_VAR,ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
	if(sk_void_num(dso->meth_data) < 1)
		{
		DSOerr(DSO_F_DLFCN_BIND_VAR,DSO_R_STACK_ERROR);
		return(NULL);
		}
d200 4
a203 5
	if(ptr == NULL)
		{
		DSOerr(DSO_F_DLFCN_BIND_VAR,DSO_R_NULL_HANDLE);
		return(NULL);
		}
d205 2
a206 3
	if(sym == NULL)
		{
		DSOerr(DSO_F_DLFCN_BIND_VAR,DSO_R_SYM_FAILURE);
d208 1
a208 3
		return(NULL);
		}
	return(sym);
d210 2
d213 3
a215 2
static DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)
	{
d222 8
a229 10
	if((dso == NULL) || (symname == NULL))
		{
		DSOerr(DSO_F_DLFCN_BIND_FUNC,ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
	if(sk_void_num(dso->meth_data) < 1)
		{
		DSOerr(DSO_F_DLFCN_BIND_FUNC,DSO_R_STACK_ERROR);
		return(NULL);
		}
d231 4
a234 5
	if(ptr == NULL)
		{
		DSOerr(DSO_F_DLFCN_BIND_FUNC,DSO_R_NULL_HANDLE);
		return(NULL);
		}
d236 2
a237 3
	if(u.dlret == NULL)
		{
		DSOerr(DSO_F_DLFCN_BIND_FUNC,DSO_R_SYM_FAILURE);
d239 2
a240 2
		return(NULL);
		}
d242 1
a242 1
	}
d244 3
a246 3
static char *dlfcn_merger(DSO *dso, const char *filespec1,
	const char *filespec2)
	{
d250 1
a250 2
	if(!filespec1 && !filespec2)
		{
d252 3
a254 3
				ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
d257 1
a257 2
	if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/'))
		{
d260 1
a260 2
		if(!merged)
			{
d262 2
a263 2
			return(NULL);
			}
d265 1
a265 1
		}
d267 1
a267 2
	else if (!filespec1)
		{
d270 4
a273 6
		if(!merged)
			{
			DSOerr(DSO_F_DLFCN_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
d275 1
a275 2
		}
	else
d281 1
a281 1
		{
d287 1
a287 2
		if(filespec2 && filespec2[spec2len - 1] == '/')
			{
d290 1
a290 1
			}
d292 4
a295 6
		if(!merged)
			{
			DSOerr(DSO_F_DLFCN_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
a298 2
		}
	return(merged);
d300 2
d306 3
a308 2
static char *dlfcn_name_converter(DSO *dso, const char *filename)
	{
d315 1
a315 2
	if(transform)
		{
d320 1
a320 1
		}
d322 1
a322 2
	if(translated == NULL)
		{
d324 4
a327 5
				DSO_R_NAME_TRANSLATION_FAILED);
		return(NULL);
		}
	if(transform)
		{
d332 1
a332 2
		}
	else
d334 2
a335 2
	return(translated);
	}
d337 3
a339 2
static int dlfcn_pathbyaddr(void *addr,char *path,int sz)
	{
d343 5
a347 4
	if (addr == NULL)
		{
		union	{ int(*f)(void*,char*,int); void *p; } t =
			{ dlfcn_pathbyaddr };
d349 1
a349 1
		}
d351 1
a351 2
	if (dladdr(addr,&dli))
		{
d353 6
a358 4
		if (sz <= 0) return len+1;
		if (len >= sz) len=sz-1;
		memcpy(path,dli.dli_fname,len);
		path[len++]=0;
d360 1
a360 1
		}
d364 6
a369 1
	}
d371 2
a372 7
static void *dlfcn_globallookup(const char *name)
	{
	void *ret = NULL,*handle = dlopen(NULL,RTLD_LAZY);
	
	if (handle)
		{
		ret = dlsym(handle,name);
d374 1
a374 1
		}
d377 1
a377 1
	}
@


1.15
log
@Just like every web browser expands until it can read mail, every modular
library expands until it has its own dlfcn wrapper, and libcrypto is no
exception.

Remove the non-dlfcn DSO methods.

This causes public DSO_METHOD_{beos,dl,vms,win32} to disappear (major bump
coming soon). Note that portable software ought to use DSO_METHOD_openssl
instead of picking the backend directly (which makes one wonder why the
backends are exposed, as it is unlikely that more than one can work on
your system).

ok beck@@ deraadt@@
@
text
@d156 1
a156 1
		OPENSSL_free(filename);
d267 1
a267 1
		merged = OPENSSL_malloc(len);
d279 1
a279 1
		merged = OPENSSL_malloc(strlen(filespec2) + 1);
d305 1
a305 1
		merged = OPENSSL_malloc(len + 2);
d337 1
a337 1
	translated = OPENSSL_malloc(rsize);
@


1.14
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a58 10
/* We need to do this early, because stdio.h includes the header files
   that handle _GNU_SOURCE and other similar macros.  Defining it later
   is simply too late, because those headers are protected from re-
   inclusion.  */
#ifdef __linux
# ifndef _GNU_SOURCE
#  define _GNU_SOURCE	/* make sure dladdr is declared */
# endif
#endif

a70 3
# ifdef __osf__
#  define __EXTENSIONS__
# endif
a72 7
# if defined(_AIX) || defined(__CYGWIN__) || \
     defined(__SCO_VERSION__) || defined(_SCO_ELF) || \
     (defined(__osf__) && !defined(RTLD_NEXT))     || \
     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \
	defined(__ANDROID__)
#  undef HAVE_DLINFO
# endif
a118 24
/* Prior to using the dlopen() function, we should decide on the flag
 * we send. There's a few different ways of doing this and it's a
 * messy venn-diagram to match up which platforms support what. So
 * as we don't have autoconf yet, I'm implementing a hack that could
 * be hacked further relatively easily to deal with cases as we find
 * them. Initially this is to cope with OpenBSD. */
#if defined(__OpenBSD__) || defined(__NetBSD__)
#	ifdef DL_LAZY
#		define DLOPEN_FLAG DL_LAZY
#	else
#		ifdef RTLD_NOW
#			define DLOPEN_FLAG RTLD_NOW
#		else
#			define DLOPEN_FLAG 0
#		endif
#	endif
#else
#	ifdef OPENSSL_SYS_SUNOS
#		define DLOPEN_FLAG 1
#	else
#		define DLOPEN_FLAG RTLD_NOW /* Hope this works everywhere else */
#	endif
#endif

d128 1
a128 1
	int flags = DLOPEN_FLAG;
a135 1
#ifdef RTLD_GLOBAL
a137 1
#endif
a318 4
#ifdef OPENSSL_SYS_MACOSX
#define DSO_ext	".dylib"
#define DSO_extlen 6
#else
a320 2
#endif

a355 39
#if defined(__sgi) && !defined(__OpenBSD__)
/*
This is a quote from IRIX manual for dladdr(3c):

     <dlfcn.h> does not contain a prototype for dladdr or definition of
     Dl_info.  The #include <dlfcn.h>  in the SYNOPSIS line is traditional,
     but contains no dladdr prototype and no IRIX library contains an
     implementation.  Write your own declaration based on the code below.

     The following code is dependent on internal interfaces that are not
     part of the IRIX compatibility guarantee; however, there is no future
     intention to change this interface, so on a practical level, the code
     below is safe to use on IRIX.
*/
#include <rld_interface.h>
#ifndef _RLD_INTERFACE_DLFCN_H_DLADDR
#define _RLD_INTERFACE_DLFCN_H_DLADDR
typedef struct Dl_info {
    const char * dli_fname;
    void       * dli_fbase;
    const char * dli_sname;
    void       * dli_saddr;
    int          dli_version;
    int          dli_reserved1;
    long         dli_reserved[4];
} Dl_info;
#else
typedef struct Dl_info Dl_info;
#endif
#define _RLD_DLADDR             14

static int dladdr(void *address, Dl_info *dl)
{
	void *v;
	v = _rld_new_interface(_RLD_DLADDR,address,dl);
	return (int)v;
}
#endif /* __sgi */

a357 1
#ifdef HAVE_DLINFO
a378 1
#endif
@


1.13
log
@Restore r1.10, lost during last update:
  Disable use of dladdr() on a.out arches, they do not provide it (yet);
@
text
@d89 1
a89 1
     (defined(__OpenBSD__) && (!defined(__ELF__) || !defined(RTLD_SELF))) || \
@


1.12
log
@resolve conflicts
@
text
@d89 1
a89 1
     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \
@


1.11
log
@openssl-1.0.0e: resolve conflicts
@
text
@d89 2
a90 1
     (defined(__OpenBSD__) && (!defined(__ELF__) || !defined(RTLD_SELF)))
@


1.10
log
@Disable use of dladdr() on a.out arches, they do not provide it (yet); ok djm@@
@
text
@d88 1
@


1.9
log
@resolve conflicts, fix local changes
@
text
@d88 1
a88 1
     (defined(__OpenBSD__) && !defined(RTLD_SELF))
@


1.8
log
@remerge local tweaks, update per-arch configuration headers, update
Makefiles, crank shlib_version
@
text
@d59 10
d81 10
a90 1
#include <dlfcn.h>
d109 2
d127 3
a129 1
	NULL  /* finish */
d189 1
a189 1
	if(!sk_push(dso->meth_data, (char *)ptr))
d214 1
a214 1
	if(sk_num(dso->meth_data) < 1)
d216 1
a216 1
	ptr = (void *)sk_pop(dso->meth_data);
d222 1
a222 1
		sk_push(dso->meth_data, (char *)ptr);
d239 1
a239 1
	if(sk_num(dso->meth_data) < 1)
d244 1
a244 1
	ptr = (void *)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);
d263 4
a266 1
	DSO_FUNC_TYPE sym, *tsym = &sym;
d273 1
a273 1
	if(sk_num(dso->meth_data) < 1)
d278 1
a278 1
	ptr = (void *)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);
d284 2
a285 2
	*(void **)(tsym) = dlsym(ptr, symname);
	if(sym == NULL)
d291 1
a291 1
	return(sym);
d308 1
a308 1
	if (!filespec2 || filespec1[0] == '/')
d314 1
a314 2
			DSOerr(DSO_F_DLFCN_MERGER,
				ERR_R_MALLOC_FAILURE);
d341 1
a341 1
		spec2len = (filespec2 ? strlen(filespec2) : 0);
d363 9
d382 2
a383 2
		/* We will convert this to "%s.so" or "lib%s.so" */
		rsize += 3;	/* The length of ".so" */
d397 1
a397 1
			snprintf(translated, rsize, "lib%s.so", filename);
d399 1
a399 1
			snprintf(translated, rsize, "%s.so", filename);
d406 79
@


1.7
log
@resolve conflicts
@
text
@d272 1
d284 2
a285 1
		merged = OPENSSL_malloc(strlen(filespec1) + 1);
d292 1
a292 1
		strcpy(merged, filespec1);
d297 1
d305 1
a305 1
		strcpy(merged, filespec2);
d331 1
a331 1
		strcpy(merged, filespec2);
d333 1
a333 1
		strcpy(&merged[spec2len + 1], filespec1);
@


1.6
log
@resolve conflicts
@
text
@d1 1
a1 1
/* dso_dlfcn.c */
a58 4
#ifdef __linux
#define _GNU_SOURCE
#endif

d88 2
d104 1
d147 1
d154 6
a159 1
	ptr = dlopen(filename, DLOPEN_FLAG);
d258 1
a258 1
	*(void**)(tsym) = dlsym(ptr, symname);
d268 67
a368 28
#ifdef OPENSSL_FIPS
static void dlfcn_ref_point(){}

int DSO_pathbyaddr(void *addr,char *path,int sz)
	{
	Dl_info dli;
	int len;

	if (addr == NULL)
		{
		union { void(*f)(void); void *p; } t = { dlfcn_ref_point };
		addr = t.p;
		}

	if (dladdr(addr,&dli))
		{
		len = (int)strlen(dli.dli_fname);
		if (sz <= 0) return len+1;
		if (len >= sz) len=sz-1;
		memcpy(path,dli.dli_fname,len);
		path[len++]=0;
		return len;
		}

	ERR_add_error_data(4, "dlfcn_pathbyaddr(): ", dlerror());
	return -1;
	}
#endif
@


1.5
log
@enable openssl DSO (typo, it's -DDSO_DLFCN not -DSO_DLFCN); Douglas Santos
@
text
@d59 4
d235 1
a235 1
	DSO_FUNC_TYPE sym;
d253 1
a253 1
	sym = (DSO_FUNC_TYPE)dlsym(ptr, symname);
d297 28
@


1.4
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d284 1
a284 1
			sprintf(translated, "lib%s.so", filename);
d286 1
a286 1
			sprintf(translated, "%s.so", filename);
d289 1
a289 1
		sprintf(translated, "%s", filename);
@


1.3
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d128 5
a132 1
#	define DLOPEN_FLAG RTLD_NOW /* Hope this works everywhere else */
@


1.2
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d117 1
a117 1
#ifdef __OpenBSD__
@


1.1
log
@openssl-engine-0.9.6 merge
@
text
@d77 1
a77 1
static int dlfcn_load(DSO *dso, const char *filename);
d85 1
d87 1
a87 1
static long dlfcn_ctrl(DSO *dso, int cmd, long larg, void *parg);
d100 2
a101 1
	dlfcn_ctrl,
d135 1
a135 1
static int dlfcn_load(DSO *dso, const char *filename)
d137 3
a139 3
	void *ptr;
	char translated[DSO_MAX_TRANSLATED_SIZE];
	int len;
d141 1
a141 8
	/* NB: This is a hideous hack, but I'm not yet sure what
	 * to replace it with. This attempts to convert any filename,
	 * that looks like it has no path information, into a
	 * translated form, e. "blah" -> "libblah.so" */
	len = strlen(filename);
	if((dso->flags & DSO_FLAG_NAME_TRANSLATION) &&
			(len + 6 < DSO_MAX_TRANSLATED_SIZE) &&
			(strstr(filename, "/") == NULL))
d143 2
a144 6
		sprintf(translated, "lib%s.so", filename);
		ptr = dlopen(translated, DLOPEN_FLAG);
		}
	else
		{
		ptr = dlopen(filename, DLOPEN_FLAG);
d146 1
d150 2
a151 1
		return(0);
d156 1
a156 2
		dlclose(ptr);
		return(0);
d158 2
d161 8
a168 1
	}
d218 1
d249 1
d255 1
a255 1
static long dlfcn_ctrl(DSO *dso, int cmd, long larg, void *parg)
d257 15
a271 1
	if(dso == NULL)
d273 3
a275 2
		DSOerr(DSO_F_DLFCN_CTRL,ERR_R_PASSED_NULL_PARAMETER);
		return(-1);
d277 1
a277 1
	switch(cmd)
d279 4
a282 10
	case DSO_CTRL_GET_FLAGS:
		return dso->flags;
	case DSO_CTRL_SET_FLAGS:
		dso->flags = (int)larg;
		return(0);
	case DSO_CTRL_OR_FLAGS:
		dso->flags |= (int)larg;
		return(0);
	default:
		break;
d284 3
a286 2
	DSOerr(DSO_F_DLFCN_CTRL,DSO_R_UNKNOWN_COMMAND);
	return(-1);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d77 1
a77 1
static int dlfcn_load(DSO *dso);
d85 1
a86 2
#endif
static char *dlfcn_name_converter(DSO *dso, const char *filename);
d99 1
a99 2
	NULL, /* ctrl */
	dlfcn_name_converter,
d115 1
a115 1
#if defined(__OpenBSD__) || defined(__NetBSD__)
d133 1
a133 1
static int dlfcn_load(DSO *dso)
d135 3
a137 3
	void *ptr = NULL;
	/* See applicable comments in dso_dl.c */
	char *filename = DSO_convert_filename(dso, NULL);
d139 8
a146 1
	if(filename == NULL)
d148 6
a153 2
		DSOerr(DSO_F_DLFCN_LOAD,DSO_R_NO_FILENAME);
		goto err;
a154 1
	ptr = dlopen(filename, DLOPEN_FLAG);
d158 1
a158 2
		ERR_add_error_data(4, "filename(", filename, "): ", dlerror());
		goto err;
d163 2
a164 1
		goto err;
a165 2
	/* Success */
	dso->loaded_filename = filename;
d167 1
a167 8
err:
	/* Cleanup! */
	if(filename != NULL)
		OPENSSL_free(filename);
	if(ptr != NULL)
		dlclose(ptr);
	return(0);
}
a216 1
		ERR_add_error_data(4, "symname(", symname, "): ", dlerror());
a246 1
		ERR_add_error_data(4, "symname(", symname, "): ", dlerror());
d252 1
a252 1
static char *dlfcn_name_converter(DSO *dso, const char *filename)
d254 1
a254 7
	char *translated;
	int len, rsize, transform;

	len = strlen(filename);
	rsize = len + 1;
	transform = (strstr(filename, "/") == NULL);
	if(transform)
d256 2
a257 4
		/* We will convert this to "%s.so" or "lib%s.so" */
		rsize += 3;	/* The length of ".so" */
		if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
			rsize += 3; /* The length of "lib" */
d259 1
a259 2
	translated = OPENSSL_malloc(rsize);
	if(translated == NULL)
d261 10
a270 3
		DSOerr(DSO_F_DLFCN_NAME_CONVERTER,
				DSO_R_NAME_TRANSLATION_FAILED);
		return(NULL);
d272 2
a273 10
	if(transform)
		{
		if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
			sprintf(translated, "lib%s.so", filename);
		else
			sprintf(translated, "%s.so", filename);
		}
	else
		sprintf(translated, "%s", filename);
	return(translated);
@


1.1.1.2
log
@import 0.9.7c
@
text
@d128 1
a128 5
#	ifdef OPENSSL_SYS_SUNOS
#		define DLOPEN_FLAG 1
#	else
#		define DLOPEN_FLAG RTLD_NOW /* Hope this works everywhere else */
#	endif
@


1.1.1.3
log
@import of openssl-0.9.7j
@
text
@a58 4
#ifdef __linux
#define _GNU_SOURCE
#endif

d231 1
a231 1
	DSO_FUNC_TYPE sym, *tsym = &sym;
d249 1
a249 1
	*(void**)(tsym) = dlsym(ptr, symname);
a292 28
#ifdef OPENSSL_FIPS
static void dlfcn_ref_point(){}

int DSO_pathbyaddr(void *addr,char *path,int sz)
	{
	Dl_info dli;
	int len;

	if (addr == NULL)
		{
		union { void(*f)(void); void *p; } t = { dlfcn_ref_point };
		addr = t.p;
		}

	if (dladdr(addr,&dli))
		{
		len = (int)strlen(dli.dli_fname);
		if (sz <= 0) return len+1;
		if (len >= sz) len=sz-1;
		memcpy(path,dli.dli_fname,len);
		path[len++]=0;
		return len;
		}

	ERR_add_error_data(4, "dlfcn_pathbyaddr(): ", dlerror());
	return -1;
	}
#endif
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d1 1
a1 1
/* dso_dlfcn.c -*- mode:C; c-file-style: "eay" -*- */
d59 4
a91 2
static char *dlfcn_merger(DSO *dso, const char *filespec1,
	const char *filespec2);
a105 1
	dlfcn_merger,
a147 1
	int flags = DLOPEN_FLAG;
d154 1
a154 6

#ifdef RTLD_GLOBAL
	if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)
		flags |= RTLD_GLOBAL;
#endif
	ptr = dlopen(filename, flags);
d253 1
a253 1
	*(void **)(tsym) = dlsym(ptr, symname);
a262 67
static char *dlfcn_merger(DSO *dso, const char *filespec1,
	const char *filespec2)
	{
	char *merged;

	if(!filespec1 && !filespec2)
		{
		DSOerr(DSO_F_DLFCN_MERGER,
				ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
	/* If the first file specification is a rooted path, it rules.
	   same goes if the second file specification is missing. */
	if (!filespec2 || filespec1[0] == '/')
		{
		merged = OPENSSL_malloc(strlen(filespec1) + 1);
		if(!merged)
			{
			DSOerr(DSO_F_DLFCN_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
		strcpy(merged, filespec1);
		}
	/* If the first file specification is missing, the second one rules. */
	else if (!filespec1)
		{
		merged = OPENSSL_malloc(strlen(filespec2) + 1);
		if(!merged)
			{
			DSOerr(DSO_F_DLFCN_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
		strcpy(merged, filespec2);
		}
	else
		/* This part isn't as trivial as it looks.  It assumes that
		   the second file specification really is a directory, and
		   makes no checks whatsoever.  Therefore, the result becomes
		   the concatenation of filespec2 followed by a slash followed
		   by filespec1. */
		{
		int spec2len, len;

		spec2len = (filespec2 ? strlen(filespec2) : 0);
		len = spec2len + (filespec1 ? strlen(filespec1) : 0);

		if(filespec2 && filespec2[spec2len - 1] == '/')
			{
			spec2len--;
			len--;
			}
		merged = OPENSSL_malloc(len + 2);
		if(!merged)
			{
			DSOerr(DSO_F_DLFCN_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
		strcpy(merged, filespec2);
		merged[spec2len] = '/';
		strcpy(&merged[spec2len + 1], filespec1);
		}
	return(merged);
	}

d297 28
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@a58 10
/* We need to do this early, because stdio.h includes the header files
   that handle _GNU_SOURCE and other similar macros.  Defining it later
   is simply too late, because those headers are protected from re-
   inclusion.  */
#ifdef __linux
# ifndef _GNU_SOURCE
#  define _GNU_SOURCE	/* make sure dladdr is declared */
# endif
#endif

d71 1
a71 10
# ifdef __osf__
#  define __EXTENSIONS__
# endif
# include <dlfcn.h>
# define HAVE_DLINFO 1
# if defined(_AIX) || defined(__CYGWIN__) || \
     defined(__SCO_VERSION__) || defined(_SCO_ELF) || \
     (defined(__OpenBSD__) && !defined(RTLD_SELF))
#  undef HAVE_DLINFO
# endif
a89 2
static int dlfcn_pathbyaddr(void *addr,char *path,int sz);
static void *dlfcn_globallookup(const char *name);
d106 1
a106 3
	NULL, /* finish */
	dlfcn_pathbyaddr,
	dlfcn_globallookup
d166 1
a166 1
	if(!sk_void_push(dso->meth_data, (char *)ptr))
d191 1
a191 1
	if(sk_void_num(dso->meth_data) < 1)
d193 1
a193 1
	ptr = sk_void_pop(dso->meth_data);
d199 1
a199 1
		sk_void_push(dso->meth_data, ptr);
d216 1
a216 1
	if(sk_void_num(dso->meth_data) < 1)
d221 1
a221 1
	ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);
d240 1
a240 4
	union {
		DSO_FUNC_TYPE sym;
		void *dlret;
	} u;
d247 1
a247 1
	if(sk_void_num(dso->meth_data) < 1)
d252 1
a252 1
	ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);
d258 2
a259 2
	u.dlret = dlsym(ptr, symname);
	if(u.dlret == NULL)
d265 1
a265 1
	return u.sym;
d281 1
a281 1
	if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/'))
d286 2
a287 1
			DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
d313 1
a313 1
		spec2len = strlen(filespec2);
a334 9
#ifdef OPENSSL_SYS_MACOSX
#define DSO_ext	".dylib"
#define DSO_extlen 6
#else
#define DSO_ext	".so"
#define DSO_extlen 3
#endif


d345 2
a346 2
		/* We will convert this to "%s.so" or "lib%s.so" etc */
		rsize += DSO_extlen;	/* The length of ".so" */
d360 1
a360 1
			sprintf(translated, "lib%s" DSO_ext, filename);
d362 1
a362 1
			sprintf(translated, "%s" DSO_ext, filename);
a368 79
#ifdef __sgi
/*
This is a quote from IRIX manual for dladdr(3c):

     <dlfcn.h> does not contain a prototype for dladdr or definition of
     Dl_info.  The #include <dlfcn.h>  in the SYNOPSIS line is traditional,
     but contains no dladdr prototype and no IRIX library contains an
     implementation.  Write your own declaration based on the code below.

     The following code is dependent on internal interfaces that are not
     part of the IRIX compatibility guarantee; however, there is no future
     intention to change this interface, so on a practical level, the code
     below is safe to use on IRIX.
*/
#include <rld_interface.h>
#ifndef _RLD_INTERFACE_DLFCN_H_DLADDR
#define _RLD_INTERFACE_DLFCN_H_DLADDR
typedef struct Dl_info {
    const char * dli_fname;
    void       * dli_fbase;
    const char * dli_sname;
    void       * dli_saddr;
    int          dli_version;
    int          dli_reserved1;
    long         dli_reserved[4];
} Dl_info;
#else
typedef struct Dl_info Dl_info;
#endif
#define _RLD_DLADDR             14

static int dladdr(void *address, Dl_info *dl)
{
	void *v;
	v = _rld_new_interface(_RLD_DLADDR,address,dl);
	return (int)v;
}
#endif /* __sgi */

static int dlfcn_pathbyaddr(void *addr,char *path,int sz)
	{
#ifdef HAVE_DLINFO
	Dl_info dli;
	int len;

	if (addr == NULL)
		{
		union	{ int(*f)(void*,char*,int); void *p; } t =
			{ dlfcn_pathbyaddr };
		addr = t.p;
		}

	if (dladdr(addr,&dli))
		{
		len = (int)strlen(dli.dli_fname);
		if (sz <= 0) return len+1;
		if (len >= sz) len=sz-1;
		memcpy(path,dli.dli_fname,len);
		path[len++]=0;
		return len;
		}

	ERR_add_error_data(4, "dlfcn_pathbyaddr(): ", dlerror());
#endif
	return -1;
	}

static void *dlfcn_globallookup(const char *name)
	{
	void *ret = NULL,*handle = dlopen(NULL,RTLD_LAZY);
	
	if (handle)
		{
		ret = dlsym(handle,name);
		dlclose(handle);
		}

	return ret;
	}
@


1.1.1.6
log
@import OpenSSL 1.0.0e
@
text
@a87 1
     (defined(__osf__) && !defined(RTLD_NEXT))     || \
@


1.1.1.7
log
@import OpenSSL-1.0.1c
@
text
@d89 1
a89 2
     (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \
	defined(__ANDROID__)
@


