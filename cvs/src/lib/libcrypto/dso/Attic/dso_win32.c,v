head	1.8;
access;
symbols
	butholakala:1.7
	openssl_1_0_1_g:1.1.1.6
	OPENBSD_5_5:1.7.0.16
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.12
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	openssl_1_0_1_c:1.1.1.6
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	openssl_1_0_0_f:1.1.1.6
	openssl_1_0_0_e:1.1.1.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	openssh_1_0_0_a:1.1.1.6
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	openssl_0_9_8_k:1.1.1.5
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	openssl_0_9_8_j:1.1.1.5
	openssl_0_9_8_h:1.1.1.5
	pre_openssl_0_9_8h:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	openssl_0_9_7j:1.1.1.4
	openssl:1.1.1
	OPENBSD_3_9:1.4.0.4
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENSSL_0_9_7G:1.1.1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	OPENSSL_0_9_7D:1.1.1.2
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	OPENSSL_0_9_7C:1.1.1.2
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENSSL_0_9_7B:1.1.1.2
	OPENBSD_3_3:1.2.0.4
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.1
	OPENSSL_0_9_7_BETA3:1.1.1.1
	OPENSSL_0_9_7_BETA1:1.1.1.1
	OPENSSL:1.1.1
	OPENBSD_3_1:1.1.0.6
	OPENBSD_3_1_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9:1.1.0.2
	OPENBSD_2_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.04.15.20.13.09;	author miod;	state dead;
branches;
next	1.7;

1.7
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.27.05.07.01;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.29.05.39.21;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.12.02.18.37;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.15.02.29.13;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.15.02.57.34;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.17;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.07;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.09;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.06.27.05.05.33;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.06.12.15.43;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.06;	author djm;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Just like every web browser expands until it can read mail, every modular
library expands until it has its own dlfcn wrapper, and libcrypto is no
exception.

Remove the non-dlfcn DSO methods.

This causes public DSO_METHOD_{beos,dl,vms,win32} to disappear (major bump
coming soon). Note that portable software ought to use DSO_METHOD_openssl
instead of picking the backend directly (which makes one wonder why the
backends are exposed, as it is unlikely that more than one can work on
your system).

ok beck@@ deraadt@@
@
text
@/* dso_win32.c -*- mode:C; c-file-style: "eay" -*- */
/* Written by Geoff Thorpe (geoff@@geoffthorpe.net) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>
#include "cryptlib.h"
#include <openssl/dso.h>

#if !defined(DSO_WIN32)
DSO_METHOD *DSO_METHOD_win32(void)
	{
	return NULL;
	}
#else

#ifdef _WIN32_WCE
# if _WIN32_WCE < 300
static FARPROC GetProcAddressA(HMODULE hModule,LPCSTR lpProcName)
	{
	WCHAR lpProcNameW[64];
	int i;

	for (i=0;lpProcName[i] && i<64;i++)
		lpProcNameW[i] = (WCHAR)lpProcName[i];
	if (i==64) return NULL;
	lpProcNameW[i] = 0;

	return GetProcAddressW(hModule,lpProcNameW);
	}
# endif
# undef GetProcAddress
# define GetProcAddress GetProcAddressA

static HINSTANCE LoadLibraryA(LPCSTR lpLibFileName)
	{
	WCHAR *fnamw;
	size_t len_0=strlen(lpLibFileName)+1,i;

#ifdef _MSC_VER
	fnamw = (WCHAR *)_alloca (len_0*sizeof(WCHAR));
#else
	fnamw = (WCHAR *)alloca (len_0*sizeof(WCHAR));
#endif
	if (fnamw == NULL)
		{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
		}

#if defined(_WIN32_WCE) && _WIN32_WCE>=101
	if (!MultiByteToWideChar(CP_ACP,0,lpLibFileName,len_0,fnamw,len_0))
#endif
		for (i=0;i<len_0;i++) fnamw[i]=(WCHAR)lpLibFileName[i];

	return LoadLibraryW(fnamw);
	}
#endif

/* Part of the hack in "win32_load" ... */
#define DSO_MAX_TRANSLATED_SIZE 256

static int win32_load(DSO *dso);
static int win32_unload(DSO *dso);
static void *win32_bind_var(DSO *dso, const char *symname);
static DSO_FUNC_TYPE win32_bind_func(DSO *dso, const char *symname);
#if 0
static int win32_unbind_var(DSO *dso, char *symname, void *symptr);
static int win32_unbind_func(DSO *dso, char *symname, DSO_FUNC_TYPE symptr);
static int win32_init(DSO *dso);
static int win32_finish(DSO *dso);
static long win32_ctrl(DSO *dso, int cmd, long larg, void *parg);
#endif
static char *win32_name_converter(DSO *dso, const char *filename);
static char *win32_merger(DSO *dso, const char *filespec1,
	const char *filespec2);
static int win32_pathbyaddr(void *addr,char *path,int sz);
static void *win32_globallookup(const char *name);

static const char *openssl_strnchr(const char *string, int c, size_t len);

static DSO_METHOD dso_meth_win32 = {
	"OpenSSL 'win32' shared library method",
	win32_load,
	win32_unload,
	win32_bind_var,
	win32_bind_func,
/* For now, "unbind" doesn't exist */
#if 0
	NULL, /* unbind_var */
	NULL, /* unbind_func */
#endif
	NULL, /* ctrl */
	win32_name_converter,
	win32_merger,
	NULL, /* init */
	NULL, /* finish */
	win32_pathbyaddr,
	win32_globallookup
	};

DSO_METHOD *DSO_METHOD_win32(void)
	{
	return(&dso_meth_win32);
	}

/* For this DSO_METHOD, our meth_data STACK will contain;
 * (i) a pointer to the handle (HINSTANCE) returned from
 *     LoadLibrary(), and copied.
 */

static int win32_load(DSO *dso)
	{
	HINSTANCE h = NULL, *p = NULL;
	/* See applicable comments from dso_dl.c */
	char *filename = DSO_convert_filename(dso, NULL);

	if(filename == NULL)
		{
		DSOerr(DSO_F_WIN32_LOAD,DSO_R_NO_FILENAME);
		goto err;
		}
	h = LoadLibraryA(filename);
	if(h == NULL)
		{
		DSOerr(DSO_F_WIN32_LOAD,DSO_R_LOAD_FAILED);
		ERR_add_error_data(3, "filename(", filename, ")");
		goto err;
		}
	p = (HINSTANCE *)OPENSSL_malloc(sizeof(HINSTANCE));
	if(p == NULL)
		{
		DSOerr(DSO_F_WIN32_LOAD,ERR_R_MALLOC_FAILURE);
		goto err;
		}
	*p = h;
	if(!sk_void_push(dso->meth_data, p))
		{
		DSOerr(DSO_F_WIN32_LOAD,DSO_R_STACK_ERROR);
		goto err;
		}
	/* Success */
	dso->loaded_filename = filename;
	return(1);
err:
	/* Cleanup !*/
	if(filename != NULL)
		OPENSSL_free(filename);
	if(p != NULL)
		OPENSSL_free(p);
	if(h != NULL)
		FreeLibrary(h);
	return(0);
	}

static int win32_unload(DSO *dso)
	{
	HINSTANCE *p;
	if(dso == NULL)
		{
		DSOerr(DSO_F_WIN32_UNLOAD,ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if(sk_void_num(dso->meth_data) < 1)
		return(1);
	p = sk_void_pop(dso->meth_data);
	if(p == NULL)
		{
		DSOerr(DSO_F_WIN32_UNLOAD,DSO_R_NULL_HANDLE);
		return(0);
		}
	if(!FreeLibrary(*p))
		{
		DSOerr(DSO_F_WIN32_UNLOAD,DSO_R_UNLOAD_FAILED);
		/* We should push the value back onto the stack in
		 * case of a retry. */
		sk_void_push(dso->meth_data, p);
		return(0);
		}
	/* Cleanup */
	OPENSSL_free(p);
	return(1);
	}

/* Using GetProcAddress for variables? TODO: Check this out in
 * the Win32 API docs, there's probably a variant for variables. */
static void *win32_bind_var(DSO *dso, const char *symname)
	{
	HINSTANCE *ptr;
	void *sym;

	if((dso == NULL) || (symname == NULL))
		{
		DSOerr(DSO_F_WIN32_BIND_VAR,ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
	if(sk_void_num(dso->meth_data) < 1)
		{
		DSOerr(DSO_F_WIN32_BIND_VAR,DSO_R_STACK_ERROR);
		return(NULL);
		}
	ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);
	if(ptr == NULL)
		{
		DSOerr(DSO_F_WIN32_BIND_VAR,DSO_R_NULL_HANDLE);
		return(NULL);
		}
	sym = GetProcAddress(*ptr, symname);
	if(sym == NULL)
		{
		DSOerr(DSO_F_WIN32_BIND_VAR,DSO_R_SYM_FAILURE);
		ERR_add_error_data(3, "symname(", symname, ")");
		return(NULL);
		}
	return(sym);
	}

static DSO_FUNC_TYPE win32_bind_func(DSO *dso, const char *symname)
	{
	HINSTANCE *ptr;
	void *sym;

	if((dso == NULL) || (symname == NULL))
		{
		DSOerr(DSO_F_WIN32_BIND_FUNC,ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
	if(sk_void_num(dso->meth_data) < 1)
		{
		DSOerr(DSO_F_WIN32_BIND_FUNC,DSO_R_STACK_ERROR);
		return(NULL);
		}
	ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);
	if(ptr == NULL)
		{
		DSOerr(DSO_F_WIN32_BIND_FUNC,DSO_R_NULL_HANDLE);
		return(NULL);
		}
	sym = GetProcAddress(*ptr, symname);
	if(sym == NULL)
		{
		DSOerr(DSO_F_WIN32_BIND_FUNC,DSO_R_SYM_FAILURE);
		ERR_add_error_data(3, "symname(", symname, ")");
		return(NULL);
		}
	return((DSO_FUNC_TYPE)sym);
	}

struct file_st
	{
	const char *node; int nodelen;
	const char *device; int devicelen;
	const char *predir; int predirlen;
	const char *dir; int dirlen;
	const char *file; int filelen;
	};

static struct file_st *win32_splitter(DSO *dso, const char *filename,
	int assume_last_is_dir)
	{
	struct file_st *result = NULL;
	enum { IN_NODE, IN_DEVICE, IN_FILE } position;
	const char *start = filename;
	char last;

	if (!filename)
		{
		DSOerr(DSO_F_WIN32_SPLITTER,DSO_R_NO_FILENAME);
		/*goto err;*/
		return(NULL);
		}

	result = OPENSSL_malloc(sizeof(struct file_st));
	if(result == NULL)
		{
		DSOerr(DSO_F_WIN32_SPLITTER,
			ERR_R_MALLOC_FAILURE);
		return(NULL);
		}

	memset(result, 0, sizeof(struct file_st));
	position = IN_DEVICE;

	if((filename[0] == '\\' && filename[1] == '\\')
		|| (filename[0] == '/' && filename[1] == '/'))
		{
		position = IN_NODE;
		filename += 2;
		start = filename;
		result->node = start;
		}

	do
		{
		last = filename[0];
		switch(last)
			{
		case ':':
			if(position != IN_DEVICE)
				{
				DSOerr(DSO_F_WIN32_SPLITTER,
					DSO_R_INCORRECT_FILE_SYNTAX);
				/*goto err;*/
				OPENSSL_free(result);
				return(NULL);
				}
			result->device = start;
			result->devicelen = (int)(filename - start);
			position = IN_FILE;
			start = ++filename;
			result->dir = start;
			break;
		case '\\':
		case '/':
			if(position == IN_NODE)
				{
				result->nodelen = (int)(filename - start);
				position = IN_FILE;
				start = ++filename;
				result->dir = start;
				}
			else if(position == IN_DEVICE)
				{
				position = IN_FILE;
				filename++;
				result->dir = start;
				result->dirlen = (int)(filename - start);
				start = filename;
				}
			else
				{
				filename++;
				result->dirlen += (int)(filename - start);
				start = filename;
				}
			break;
		case '\0':
			if(position == IN_NODE)
				{
				result->nodelen = (int)(filename - start);
				}
			else
				{
				if(filename - start > 0)
					{
					if (assume_last_is_dir)
						{
						if (position == IN_DEVICE)
							{
							result->dir = start;
							result->dirlen = 0;
							}
						result->dirlen +=
							(int)(filename - start);
						}
					else
						{
						result->file = start;
						result->filelen =
							(int)(filename - start);
						}
					}
				}
			break;
		default:
			filename++;
			break;
			}
		}
	while(last);

	if(!result->nodelen) result->node = NULL;
	if(!result->devicelen) result->device = NULL;
	if(!result->dirlen) result->dir = NULL;
	if(!result->filelen) result->file = NULL;

	return(result);
	}

static char *win32_joiner(DSO *dso, const struct file_st *file_split)
	{
	int len = 0, offset = 0;
	char *result = NULL;
	const char *start;

	if(!file_split)
		{
		DSOerr(DSO_F_WIN32_JOINER,
				ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
	if(file_split->node)
		{
		len += 2 + file_split->nodelen;	/* 2 for starting \\ */
		if(file_split->predir || file_split->dir || file_split->file)
			len++;	/* 1 for ending \ */
		}
	else if(file_split->device)
		{
		len += file_split->devicelen + 1; /* 1 for ending : */
		}
	len += file_split->predirlen;
	if(file_split->predir && (file_split->dir || file_split->file))
		{
		len++;	/* 1 for ending \ */
		}
	len += file_split->dirlen;
	if(file_split->dir && file_split->file)
		{
		len++;	/* 1 for ending \ */
		}
	len += file_split->filelen;

	if(!len)
		{
		DSOerr(DSO_F_WIN32_JOINER, DSO_R_EMPTY_FILE_STRUCTURE);
		return(NULL);
		}

	result = OPENSSL_malloc(len + 1);
	if (!result)
		{
		DSOerr(DSO_F_WIN32_JOINER,
			ERR_R_MALLOC_FAILURE);
		return(NULL);
		}

	if(file_split->node)
		{
		strcpy(&result[offset], "\\\\"); offset += 2;
		strncpy(&result[offset], file_split->node,
			file_split->nodelen); offset += file_split->nodelen;
		if(file_split->predir || file_split->dir || file_split->file)
			{
			result[offset] = '\\'; offset++;
			}
		}
	else if(file_split->device)
		{
		strncpy(&result[offset], file_split->device,
			file_split->devicelen); offset += file_split->devicelen;
		result[offset] = ':'; offset++;
		}
	start = file_split->predir;
	while(file_split->predirlen > (start - file_split->predir))
		{
		const char *end = openssl_strnchr(start, '/',
			file_split->predirlen - (start - file_split->predir));
		if(!end)
			end = start
				+ file_split->predirlen
				- (start - file_split->predir);
		strncpy(&result[offset], start,
			end - start); offset += (int)(end - start);
		result[offset] = '\\'; offset++;
		start = end + 1;
		}
#if 0 /* Not needed, since the directory converter above already appeneded
	 a backslash */
	if(file_split->predir && (file_split->dir || file_split->file))
		{
		result[offset] = '\\'; offset++;
		}
#endif
	start = file_split->dir;
	while(file_split->dirlen > (start - file_split->dir))
		{
		const char *end = openssl_strnchr(start, '/',
			file_split->dirlen - (start - file_split->dir));
		if(!end)
			end = start
				+ file_split->dirlen
				- (start - file_split->dir);
		strncpy(&result[offset], start,
			end - start); offset += (int)(end - start);
		result[offset] = '\\'; offset++;
		start = end + 1;
		}
#if 0 /* Not needed, since the directory converter above already appeneded
	 a backslash */
	if(file_split->dir && file_split->file)
		{
		result[offset] = '\\'; offset++;
		}
#endif
	strncpy(&result[offset], file_split->file,
		file_split->filelen); offset += file_split->filelen;
	result[offset] = '\0';
	return(result);
	}

static char *win32_merger(DSO *dso, const char *filespec1, const char *filespec2)
	{
	char *merged = NULL;
	struct file_st *filespec1_split = NULL;
	struct file_st *filespec2_split = NULL;

	if(!filespec1 && !filespec2)
		{
		DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
	if (!filespec2)
		{
		merged = OPENSSL_malloc(strlen(filespec1) + 1);
		if(!merged)
			{
			DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
		strcpy(merged, filespec1);
		}
	else if (!filespec1)
		{
		merged = OPENSSL_malloc(strlen(filespec2) + 1);
		if(!merged)
			{
			DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
		strcpy(merged, filespec2);
		}
	else
		{
		filespec1_split = win32_splitter(dso, filespec1, 0);
		if (!filespec1_split)
			{
			DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
		filespec2_split = win32_splitter(dso, filespec2, 1);
		if (!filespec2_split)
			{
			DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_MALLOC_FAILURE);
			OPENSSL_free(filespec1_split);
			return(NULL);
			}

		/* Fill in into filespec1_split */
		if (!filespec1_split->node && !filespec1_split->device)
			{
			filespec1_split->node = filespec2_split->node;
			filespec1_split->nodelen = filespec2_split->nodelen;
			filespec1_split->device = filespec2_split->device;
			filespec1_split->devicelen = filespec2_split->devicelen;
			}
		if (!filespec1_split->dir)
			{
			filespec1_split->dir = filespec2_split->dir;
			filespec1_split->dirlen = filespec2_split->dirlen;
			}
		else if (filespec1_split->dir[0] != '\\'
			&& filespec1_split->dir[0] != '/')
			{
			filespec1_split->predir = filespec2_split->dir;
			filespec1_split->predirlen = filespec2_split->dirlen;
			}
		if (!filespec1_split->file)
			{
			filespec1_split->file = filespec2_split->file;
			filespec1_split->filelen = filespec2_split->filelen;
			}

		merged = win32_joiner(dso, filespec1_split);
		}
	OPENSSL_free(filespec1_split);
	OPENSSL_free(filespec2_split);
	return(merged);
	}

static char *win32_name_converter(DSO *dso, const char *filename)
	{
	char *translated;
	int len, transform;

	len = strlen(filename);
	transform = ((strstr(filename, "/") == NULL) &&
			(strstr(filename, "\\") == NULL) &&
			(strstr(filename, ":") == NULL));
	if(transform)
		/* We will convert this to "%s.dll" */
		translated = OPENSSL_malloc(len + 5);
	else
		/* We will simply duplicate filename */
		translated = OPENSSL_malloc(len + 1);
	if(translated == NULL)
		{
		DSOerr(DSO_F_WIN32_NAME_CONVERTER,
				DSO_R_NAME_TRANSLATION_FAILED); 
		return(NULL);   
		}
	if(transform)
		sprintf(translated, "%s.dll", filename);
	else
		sprintf(translated, "%s", filename);
	return(translated);
	}

static const char *openssl_strnchr(const char *string, int c, size_t len)
	{
	size_t i;
	const char *p;
	for (i = 0, p = string; i < len && *p; i++, p++)
		{
		if (*p == c)
			return p;
		}
	return NULL;
	}

#include <tlhelp32.h>
#ifdef _WIN32_WCE
# define DLLNAME "TOOLHELP.DLL"
#else
# ifdef MODULEENTRY32
# undef MODULEENTRY32	/* unmask the ASCII version! */
# endif
# define DLLNAME "KERNEL32.DLL"
#endif

typedef HANDLE (WINAPI *CREATETOOLHELP32SNAPSHOT)(DWORD, DWORD);
typedef BOOL (WINAPI *CLOSETOOLHELP32SNAPSHOT)(HANDLE);
typedef BOOL (WINAPI *MODULE32)(HANDLE, MODULEENTRY32 *);

static int win32_pathbyaddr(void *addr,char *path,int sz)
	{
	HMODULE dll;
	HANDLE hModuleSnap = INVALID_HANDLE_VALUE; 
	MODULEENTRY32 me32; 
	CREATETOOLHELP32SNAPSHOT create_snap;
	CLOSETOOLHELP32SNAPSHOT  close_snap;
	MODULE32 module_first, module_next;
	int len;
 
	if (addr == NULL)
		{
		union	{ int(*f)(void*,char*,int); void *p; } t =
			{ win32_pathbyaddr };
		addr = t.p;
		}

	dll = LoadLibrary(TEXT(DLLNAME));
	if (dll == NULL)
		{
		DSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_UNSUPPORTED);
		return -1;
		}

	create_snap = (CREATETOOLHELP32SNAPSHOT)
		GetProcAddress(dll,"CreateToolhelp32Snapshot");
	if (create_snap == NULL)
		{
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_UNSUPPORTED);
		return -1;
		}
	/* We take the rest for granted... */
#ifdef _WIN32_WCE
	close_snap = (CLOSETOOLHELP32SNAPSHOT)
		GetProcAddress(dll,"CloseToolhelp32Snapshot");
#else
	close_snap = (CLOSETOOLHELP32SNAPSHOT)CloseHandle;
#endif
	module_first = (MODULE32)GetProcAddress(dll,"Module32First");
	module_next  = (MODULE32)GetProcAddress(dll,"Module32Next");

	hModuleSnap = (*create_snap)(TH32CS_SNAPMODULE,0); 
	if( hModuleSnap == INVALID_HANDLE_VALUE ) 
		{ 
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_UNSUPPORTED);
		return -1;
		} 
 
	me32.dwSize = sizeof(me32); 
 
	if(!(*module_first)(hModuleSnap,&me32)) 
		{ 
		(*close_snap)(hModuleSnap);
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_FAILURE);
		return -1;
		}
 
	do	{ 
		if ((BYTE *)addr >= me32.modBaseAddr &&
		    (BYTE *)addr <  me32.modBaseAddr+me32.modBaseSize)
			{
			(*close_snap)(hModuleSnap);
			FreeLibrary(dll);
#ifdef _WIN32_WCE
# if _WIN32_WCE >= 101
			return WideCharToMultiByte(CP_ACP,0,me32.szExePath,-1,
							path,sz,NULL,NULL);
# else
			len = (int)wcslen(me32.szExePath);
			if (sz <= 0) return len+1;
			if (len >= sz) len=sz-1;
			for(i=0;i<len;i++)
				path[i] = (char)me32.szExePath[i];
			path[len++] = 0;
			return len;
# endif
#else
			len = (int)strlen(me32.szExePath);
			if (sz <= 0) return len+1;
			if (len >= sz) len=sz-1;
			memcpy(path,me32.szExePath,len);
			path[len++] = 0;
			return len;
#endif
			} 
		} while((*module_next)(hModuleSnap, &me32)); 
 
	(*close_snap)(hModuleSnap); 
	FreeLibrary(dll);
	return 0;
	}

static void *win32_globallookup(const char *name)
	{
	HMODULE dll;
	HANDLE hModuleSnap = INVALID_HANDLE_VALUE;
	MODULEENTRY32 me32;
	CREATETOOLHELP32SNAPSHOT create_snap;
	CLOSETOOLHELP32SNAPSHOT  close_snap;
	MODULE32 module_first, module_next;
	FARPROC ret=NULL;

	dll = LoadLibrary(TEXT(DLLNAME));
	if (dll == NULL)
		{
		DSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);
		return NULL;
		}

	create_snap = (CREATETOOLHELP32SNAPSHOT)
		GetProcAddress(dll,"CreateToolhelp32Snapshot");
	if (create_snap == NULL)
		{
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);
		return NULL;
		}
	/* We take the rest for granted... */
#ifdef _WIN32_WCE
	close_snap = (CLOSETOOLHELP32SNAPSHOT)
		GetProcAddress(dll,"CloseToolhelp32Snapshot");
#else
	close_snap = (CLOSETOOLHELP32SNAPSHOT)CloseHandle;
#endif
	module_first = (MODULE32)GetProcAddress(dll,"Module32First");
	module_next  = (MODULE32)GetProcAddress(dll,"Module32Next");

	hModuleSnap = (*create_snap)(TH32CS_SNAPMODULE,0);
	if( hModuleSnap == INVALID_HANDLE_VALUE )
		{
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);
		return NULL;
		}

	me32.dwSize = sizeof(me32);

	if (!(*module_first)(hModuleSnap,&me32))
		{
		(*close_snap)(hModuleSnap);
		FreeLibrary(dll);
		return NULL;
		}

	do	{
		if ((ret = GetProcAddress(me32.hModule,name)))
			{
			(*close_snap)(hModuleSnap);
			FreeLibrary(dll);
			return ret;
			}
		} while((*module_next)(hModuleSnap,&me32));

	(*close_snap)(hModuleSnap); 
	FreeLibrary(dll);
	return NULL;
	}
#endif /* DSO_WIN32 */
@


1.7
log
@resolve conflicts, fix local changes
@
text
@@


1.6
log
@resolve conflicts
@
text
@d99 5
a103 1
	if (fnamw == NULL) return NULL;
d131 2
d151 3
a153 1
	NULL  /* finish */
d191 1
a191 1
	if(!sk_push(dso->meth_data, (char *)p))
d218 1
a218 1
	if(sk_num(dso->meth_data) < 1)
d220 1
a220 1
	p = (HINSTANCE *)sk_pop(dso->meth_data);
d231 1
a231 1
		sk_push(dso->meth_data, (char *)p);
d251 1
a251 1
	if(sk_num(dso->meth_data) < 1)
d256 1
a256 1
	ptr = (HINSTANCE *)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);
d282 1
a282 1
	if(sk_num(dso->meth_data) < 1)
d287 1
a287 1
	ptr = (HINSTANCE *)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);
d338 2
a339 2
	if(filename[0] == '\\' && filename[1] == '\\'
		|| filename[0] == '/' && filename[1] == '/')
d358 1
d362 1
a362 1
			result->devicelen = filename - start;
d371 1
a371 1
				result->nodelen = filename - start;
d381 1
a381 1
				result->dirlen = filename - start;
d387 1
a387 1
				result->dirlen += filename - start;
d394 1
a394 1
				result->nodelen = filename - start;
d408 1
a408 1
							filename - start;
d414 1
a414 1
							filename - start;
d508 1
a508 1
			end - start); offset += end - start;
d529 1
a529 1
			end - start); offset += end - start;
d625 2
d670 55
d726 119
a844 1
#endif /* OPENSSL_SYS_WIN32 */
@


1.5
log
@resolve conflicts
@
text
@d1 1
a1 1
/* dso_win32.c */
d88 20
d125 4
d143 1
d295 324
d646 13
@


1.4
log
@resolve conflicts
@
text
@d71 19
d144 1
a144 1
	h = LoadLibrary(filename);
@


1.3
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d64 1
a64 1
#if !defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WINCE)
@


1.2
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d64 1
a64 1
#ifndef OPENSSL_SYS_WIN32
@


1.1
log
@openssl-engine-0.9.6 merge
@
text
@d64 1
a64 1
#ifndef WIN32
d74 1
a74 1
static int win32_load(DSO *dso, const char *filename);
d83 1
d85 1
a85 1
static long win32_ctrl(DSO *dso, int cmd, long larg, void *parg);
d98 2
a99 1
	win32_ctrl,
d114 1
a114 1
static int win32_load(DSO *dso, const char *filename)
d116 5
a120 15
	HINSTANCE h, *p;
	char translated[DSO_MAX_TRANSLATED_SIZE];
	int len;

	/* NB: This is a hideous hack, but I'm not yet sure what
	 * to replace it with. This attempts to convert any filename,
	 * that looks like it has no path information, into a
	 * translated form, e. "blah" -> "blah.dll" ... I'm more
	 * comfortable putting hacks into win32 code though ;-) */
	len = strlen(filename);
	if((dso->flags & DSO_FLAG_NAME_TRANSLATION) &&
			(len + 4 < DSO_MAX_TRANSLATED_SIZE) &&
			(strstr(filename, "/") == NULL) &&
			(strstr(filename, "\\") == NULL) &&
			(strstr(filename, ":") == NULL))
d122 2
a123 2
		sprintf(translated, "%s.dll", filename);
		h = LoadLibrary(translated);
d125 1
a125 2
	else
		h = LoadLibrary(filename);
d129 2
a130 1
		return(0);
d136 1
a136 2
		FreeLibrary(h);
		return(0);
d142 1
a142 3
		FreeLibrary(h);
		OPENSSL_free(p);
		return(0);
d144 2
d147 9
d214 1
d245 1
d251 27
a277 23
static long win32_ctrl(DSO *dso, int cmd, long larg, void *parg)
        {
        if(dso == NULL)
                {
                DSOerr(DSO_F_WIN32_CTRL,ERR_R_PASSED_NULL_PARAMETER);
                return(-1);
                }
        switch(cmd)
                {
        case DSO_CTRL_GET_FLAGS:
                return dso->flags;
        case DSO_CTRL_SET_FLAGS:
                dso->flags = (int)larg;
                return(0);
        case DSO_CTRL_OR_FLAGS:
                dso->flags |= (int)larg;
                return(0);
        default:
                break;
                }
        DSOerr(DSO_F_WIN32_CTRL,DSO_R_UNKNOWN_COMMAND);
        return(-1);
        }
d279 1
a279 1
#endif /* WIN32 */
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d64 1
a64 1
#ifndef OPENSSL_SYS_WIN32
d74 1
a74 1
static int win32_load(DSO *dso);
d83 1
a84 2
#endif
static char *win32_name_converter(DSO *dso, const char *filename);
d97 1
a97 2
	NULL, /* ctrl */
	win32_name_converter,
d112 1
a112 1
static int win32_load(DSO *dso)
d114 15
a128 5
	HINSTANCE h = NULL, *p = NULL;
	/* See applicable comments from dso_dl.c */
	char *filename = DSO_convert_filename(dso, NULL);

	if(filename == NULL)
d130 2
a131 2
		DSOerr(DSO_F_WIN32_LOAD,DSO_R_NO_FILENAME);
		goto err;
d133 2
a134 1
	h = LoadLibrary(filename);
d138 1
a138 2
		ERR_add_error_data(3, "filename(", filename, ")");
		goto err;
d144 2
a145 1
		goto err;
d151 3
a153 1
		goto err;
a154 2
	/* Success */
	dso->loaded_filename = filename;
a155 9
err:
	/* Cleanup !*/
	if(filename != NULL)
		OPENSSL_free(filename);
	if(p != NULL)
		OPENSSL_free(p);
	if(h != NULL)
		FreeLibrary(h);
	return(0);
a213 1
		ERR_add_error_data(3, "symname(", symname, ")");
a243 1
		ERR_add_error_data(3, "symname(", symname, ")");
d249 23
a271 27
static char *win32_name_converter(DSO *dso, const char *filename)
	{
	char *translated;
	int len, transform;

	len = strlen(filename);
	transform = ((strstr(filename, "/") == NULL) &&
			(strstr(filename, "\\") == NULL) &&
			(strstr(filename, ":") == NULL));
	if(transform)
		/* We will convert this to "%s.dll" */
		translated = OPENSSL_malloc(len + 5);
	else
		/* We will simply duplicate filename */
		translated = OPENSSL_malloc(len + 1);
	if(translated == NULL)
		{
		DSOerr(DSO_F_WIN32_NAME_CONVERTER,
				DSO_R_NAME_TRANSLATION_FAILED); 
		return(NULL);   
		}
	if(transform)
		sprintf(translated, "%s.dll", filename);
	else
		sprintf(translated, "%s", filename);
	return(translated);
	}
d273 1
a273 1
#endif /* OPENSSL_SYS_WIN32 */
@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@d64 1
a64 1
#if !defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WINCE)
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d64 1
a64 1
#if !defined(DSO_WIN32)
@


1.1.1.4
log
@import of openssl-0.9.7j
@
text
@a70 19
#ifdef _WIN32_WCE
# if _WIN32_WCE < 300
static FARPROC GetProcAddressA(HMODULE hModule,LPCSTR lpProcName)
	{
	WCHAR lpProcNameW[64];
	int i;

	for (i=0;lpProcName[i] && i<64;i++)
		lpProcNameW[i] = (WCHAR)lpProcName[i];
	if (i==64) return NULL;
	lpProcNameW[i] = 0;

	return GetProcAddressW(hModule,lpProcNameW);
	}
# endif
# undef GetProcAddress
# define GetProcAddress GetProcAddressA
#endif

d125 1
a125 1
	h = LoadLibraryA(filename);
@


1.1.1.5
log
@import of OpenSSL 0.9.8h
@
text
@d1 1
a1 1
/* dso_win32.c -*- mode:C; c-file-style: "eay" -*- */
a87 20

static HINSTANCE LoadLibraryA(LPCSTR lpLibFileName)
	{
	WCHAR *fnamw;
	size_t len_0=strlen(lpLibFileName)+1,i;

#ifdef _MSC_VER
	fnamw = (WCHAR *)_alloca (len_0*sizeof(WCHAR));
#else
	fnamw = (WCHAR *)alloca (len_0*sizeof(WCHAR));
#endif
	if (fnamw == NULL) return NULL;

#if defined(_WIN32_WCE) && _WIN32_WCE>=101
	if (!MultiByteToWideChar(CP_ACP,0,lpLibFileName,len_0,fnamw,len_0))
#endif
		for (i=0;i<len_0;i++) fnamw[i]=(WCHAR)lpLibFileName[i];

	return LoadLibraryW(fnamw);
	}
a104 4
static char *win32_merger(DSO *dso, const char *filespec1,
	const char *filespec2);

static const char *openssl_strnchr(const char *string, int c, size_t len);
a118 1
	win32_merger,
a269 324
struct file_st
	{
	const char *node; int nodelen;
	const char *device; int devicelen;
	const char *predir; int predirlen;
	const char *dir; int dirlen;
	const char *file; int filelen;
	};

static struct file_st *win32_splitter(DSO *dso, const char *filename,
	int assume_last_is_dir)
	{
	struct file_st *result = NULL;
	enum { IN_NODE, IN_DEVICE, IN_FILE } position;
	const char *start = filename;
	char last;

	if (!filename)
		{
		DSOerr(DSO_F_WIN32_SPLITTER,DSO_R_NO_FILENAME);
		/*goto err;*/
		return(NULL);
		}

	result = OPENSSL_malloc(sizeof(struct file_st));
	if(result == NULL)
		{
		DSOerr(DSO_F_WIN32_SPLITTER,
			ERR_R_MALLOC_FAILURE);
		return(NULL);
		}

	memset(result, 0, sizeof(struct file_st));
	position = IN_DEVICE;

	if(filename[0] == '\\' && filename[1] == '\\'
		|| filename[0] == '/' && filename[1] == '/')
		{
		position = IN_NODE;
		filename += 2;
		start = filename;
		result->node = start;
		}

	do
		{
		last = filename[0];
		switch(last)
			{
		case ':':
			if(position != IN_DEVICE)
				{
				DSOerr(DSO_F_WIN32_SPLITTER,
					DSO_R_INCORRECT_FILE_SYNTAX);
				/*goto err;*/
				return(NULL);
				}
			result->device = start;
			result->devicelen = filename - start;
			position = IN_FILE;
			start = ++filename;
			result->dir = start;
			break;
		case '\\':
		case '/':
			if(position == IN_NODE)
				{
				result->nodelen = filename - start;
				position = IN_FILE;
				start = ++filename;
				result->dir = start;
				}
			else if(position == IN_DEVICE)
				{
				position = IN_FILE;
				filename++;
				result->dir = start;
				result->dirlen = filename - start;
				start = filename;
				}
			else
				{
				filename++;
				result->dirlen += filename - start;
				start = filename;
				}
			break;
		case '\0':
			if(position == IN_NODE)
				{
				result->nodelen = filename - start;
				}
			else
				{
				if(filename - start > 0)
					{
					if (assume_last_is_dir)
						{
						if (position == IN_DEVICE)
							{
							result->dir = start;
							result->dirlen = 0;
							}
						result->dirlen +=
							filename - start;
						}
					else
						{
						result->file = start;
						result->filelen =
							filename - start;
						}
					}
				}
			break;
		default:
			filename++;
			break;
			}
		}
	while(last);

	if(!result->nodelen) result->node = NULL;
	if(!result->devicelen) result->device = NULL;
	if(!result->dirlen) result->dir = NULL;
	if(!result->filelen) result->file = NULL;

	return(result);
	}

static char *win32_joiner(DSO *dso, const struct file_st *file_split)
	{
	int len = 0, offset = 0;
	char *result = NULL;
	const char *start;

	if(!file_split)
		{
		DSOerr(DSO_F_WIN32_JOINER,
				ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
	if(file_split->node)
		{
		len += 2 + file_split->nodelen;	/* 2 for starting \\ */
		if(file_split->predir || file_split->dir || file_split->file)
			len++;	/* 1 for ending \ */
		}
	else if(file_split->device)
		{
		len += file_split->devicelen + 1; /* 1 for ending : */
		}
	len += file_split->predirlen;
	if(file_split->predir && (file_split->dir || file_split->file))
		{
		len++;	/* 1 for ending \ */
		}
	len += file_split->dirlen;
	if(file_split->dir && file_split->file)
		{
		len++;	/* 1 for ending \ */
		}
	len += file_split->filelen;

	if(!len)
		{
		DSOerr(DSO_F_WIN32_JOINER, DSO_R_EMPTY_FILE_STRUCTURE);
		return(NULL);
		}

	result = OPENSSL_malloc(len + 1);
	if (!result)
		{
		DSOerr(DSO_F_WIN32_JOINER,
			ERR_R_MALLOC_FAILURE);
		return(NULL);
		}

	if(file_split->node)
		{
		strcpy(&result[offset], "\\\\"); offset += 2;
		strncpy(&result[offset], file_split->node,
			file_split->nodelen); offset += file_split->nodelen;
		if(file_split->predir || file_split->dir || file_split->file)
			{
			result[offset] = '\\'; offset++;
			}
		}
	else if(file_split->device)
		{
		strncpy(&result[offset], file_split->device,
			file_split->devicelen); offset += file_split->devicelen;
		result[offset] = ':'; offset++;
		}
	start = file_split->predir;
	while(file_split->predirlen > (start - file_split->predir))
		{
		const char *end = openssl_strnchr(start, '/',
			file_split->predirlen - (start - file_split->predir));
		if(!end)
			end = start
				+ file_split->predirlen
				- (start - file_split->predir);
		strncpy(&result[offset], start,
			end - start); offset += end - start;
		result[offset] = '\\'; offset++;
		start = end + 1;
		}
#if 0 /* Not needed, since the directory converter above already appeneded
	 a backslash */
	if(file_split->predir && (file_split->dir || file_split->file))
		{
		result[offset] = '\\'; offset++;
		}
#endif
	start = file_split->dir;
	while(file_split->dirlen > (start - file_split->dir))
		{
		const char *end = openssl_strnchr(start, '/',
			file_split->dirlen - (start - file_split->dir));
		if(!end)
			end = start
				+ file_split->dirlen
				- (start - file_split->dir);
		strncpy(&result[offset], start,
			end - start); offset += end - start;
		result[offset] = '\\'; offset++;
		start = end + 1;
		}
#if 0 /* Not needed, since the directory converter above already appeneded
	 a backslash */
	if(file_split->dir && file_split->file)
		{
		result[offset] = '\\'; offset++;
		}
#endif
	strncpy(&result[offset], file_split->file,
		file_split->filelen); offset += file_split->filelen;
	result[offset] = '\0';
	return(result);
	}

static char *win32_merger(DSO *dso, const char *filespec1, const char *filespec2)
	{
	char *merged = NULL;
	struct file_st *filespec1_split = NULL;
	struct file_st *filespec2_split = NULL;

	if(!filespec1 && !filespec2)
		{
		DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_PASSED_NULL_PARAMETER);
		return(NULL);
		}
	if (!filespec2)
		{
		merged = OPENSSL_malloc(strlen(filespec1) + 1);
		if(!merged)
			{
			DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
		strcpy(merged, filespec1);
		}
	else if (!filespec1)
		{
		merged = OPENSSL_malloc(strlen(filespec2) + 1);
		if(!merged)
			{
			DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
		strcpy(merged, filespec2);
		}
	else
		{
		filespec1_split = win32_splitter(dso, filespec1, 0);
		if (!filespec1_split)
			{
			DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_MALLOC_FAILURE);
			return(NULL);
			}
		filespec2_split = win32_splitter(dso, filespec2, 1);
		if (!filespec2_split)
			{
			DSOerr(DSO_F_WIN32_MERGER,
				ERR_R_MALLOC_FAILURE);
			OPENSSL_free(filespec1_split);
			return(NULL);
			}

		/* Fill in into filespec1_split */
		if (!filespec1_split->node && !filespec1_split->device)
			{
			filespec1_split->node = filespec2_split->node;
			filespec1_split->nodelen = filespec2_split->nodelen;
			filespec1_split->device = filespec2_split->device;
			filespec1_split->devicelen = filespec2_split->devicelen;
			}
		if (!filespec1_split->dir)
			{
			filespec1_split->dir = filespec2_split->dir;
			filespec1_split->dirlen = filespec2_split->dirlen;
			}
		else if (filespec1_split->dir[0] != '\\'
			&& filespec1_split->dir[0] != '/')
			{
			filespec1_split->predir = filespec2_split->dir;
			filespec1_split->predirlen = filespec2_split->dirlen;
			}
		if (!filespec1_split->file)
			{
			filespec1_split->file = filespec2_split->file;
			filespec1_split->filelen = filespec2_split->filelen;
			}

		merged = win32_joiner(dso, filespec1_split);
		}
	return(merged);
	}

a296 13

static const char *openssl_strnchr(const char *string, int c, size_t len)
	{
	size_t i;
	const char *p;
	for (i = 0, p = string; i < len && *p; i++, p++)
		{
		if (*p == c)
			return p;
		}
	return NULL;
	}

@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d99 1
a99 5
	if (fnamw == NULL)
		{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
		}
a126 2
static int win32_pathbyaddr(void *addr,char *path,int sz);
static void *win32_globallookup(const char *name);
d145 1
a145 3
	NULL, /* finish */
	win32_pathbyaddr,
	win32_globallookup
d183 1
a183 1
	if(!sk_void_push(dso->meth_data, p))
d210 1
a210 1
	if(sk_void_num(dso->meth_data) < 1)
d212 1
a212 1
	p = sk_void_pop(dso->meth_data);
d223 1
a223 1
		sk_void_push(dso->meth_data, p);
d243 1
a243 1
	if(sk_void_num(dso->meth_data) < 1)
d248 1
a248 1
	ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);
d274 1
a274 1
	if(sk_void_num(dso->meth_data) < 1)
d279 1
a279 1
	ptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);
d330 2
a331 2
	if((filename[0] == '\\' && filename[1] == '\\')
		|| (filename[0] == '/' && filename[1] == '/'))
a349 1
				OPENSSL_free(result);
d353 1
a353 1
			result->devicelen = (int)(filename - start);
d362 1
a362 1
				result->nodelen = (int)(filename - start);
d372 1
a372 1
				result->dirlen = (int)(filename - start);
d378 1
a378 1
				result->dirlen += (int)(filename - start);
d385 1
a385 1
				result->nodelen = (int)(filename - start);
d399 1
a399 1
							(int)(filename - start);
d405 1
a405 1
							(int)(filename - start);
d499 1
a499 1
			end - start); offset += (int)(end - start);
d520 1
a520 1
			end - start); offset += (int)(end - start);
a615 2
	OPENSSL_free(filespec1_split);
	OPENSSL_free(filespec2_split);
a658 55
#include <tlhelp32.h>
#ifdef _WIN32_WCE
# define DLLNAME "TOOLHELP.DLL"
#else
# ifdef MODULEENTRY32
# undef MODULEENTRY32	/* unmask the ASCII version! */
# endif
# define DLLNAME "KERNEL32.DLL"
#endif

typedef HANDLE (WINAPI *CREATETOOLHELP32SNAPSHOT)(DWORD, DWORD);
typedef BOOL (WINAPI *CLOSETOOLHELP32SNAPSHOT)(HANDLE);
typedef BOOL (WINAPI *MODULE32)(HANDLE, MODULEENTRY32 *);

static int win32_pathbyaddr(void *addr,char *path,int sz)
	{
	HMODULE dll;
	HANDLE hModuleSnap = INVALID_HANDLE_VALUE; 
	MODULEENTRY32 me32; 
	CREATETOOLHELP32SNAPSHOT create_snap;
	CLOSETOOLHELP32SNAPSHOT  close_snap;
	MODULE32 module_first, module_next;
	int len;
 
	if (addr == NULL)
		{
		union	{ int(*f)(void*,char*,int); void *p; } t =
			{ win32_pathbyaddr };
		addr = t.p;
		}

	dll = LoadLibrary(TEXT(DLLNAME));
	if (dll == NULL)
		{
		DSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_UNSUPPORTED);
		return -1;
		}

	create_snap = (CREATETOOLHELP32SNAPSHOT)
		GetProcAddress(dll,"CreateToolhelp32Snapshot");
	if (create_snap == NULL)
		{
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_UNSUPPORTED);
		return -1;
		}
	/* We take the rest for granted... */
#ifdef _WIN32_WCE
	close_snap = (CLOSETOOLHELP32SNAPSHOT)
		GetProcAddress(dll,"CloseToolhelp32Snapshot");
#else
	close_snap = (CLOSETOOLHELP32SNAPSHOT)CloseHandle;
#endif
	module_first = (MODULE32)GetProcAddress(dll,"Module32First");
	module_next  = (MODULE32)GetProcAddress(dll,"Module32Next");
d660 1
a660 119
	hModuleSnap = (*create_snap)(TH32CS_SNAPMODULE,0); 
	if( hModuleSnap == INVALID_HANDLE_VALUE ) 
		{ 
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_UNSUPPORTED);
		return -1;
		} 
 
	me32.dwSize = sizeof(me32); 
 
	if(!(*module_first)(hModuleSnap,&me32)) 
		{ 
		(*close_snap)(hModuleSnap);
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_FAILURE);
		return -1;
		}
 
	do	{ 
		if ((BYTE *)addr >= me32.modBaseAddr &&
		    (BYTE *)addr <  me32.modBaseAddr+me32.modBaseSize)
			{
			(*close_snap)(hModuleSnap);
			FreeLibrary(dll);
#ifdef _WIN32_WCE
# if _WIN32_WCE >= 101
			return WideCharToMultiByte(CP_ACP,0,me32.szExePath,-1,
							path,sz,NULL,NULL);
# else
			len = (int)wcslen(me32.szExePath);
			if (sz <= 0) return len+1;
			if (len >= sz) len=sz-1;
			for(i=0;i<len;i++)
				path[i] = (char)me32.szExePath[i];
			path[len++] = 0;
			return len;
# endif
#else
			len = (int)strlen(me32.szExePath);
			if (sz <= 0) return len+1;
			if (len >= sz) len=sz-1;
			memcpy(path,me32.szExePath,len);
			path[len++] = 0;
			return len;
#endif
			} 
		} while((*module_next)(hModuleSnap, &me32)); 
 
	(*close_snap)(hModuleSnap); 
	FreeLibrary(dll);
	return 0;
	}

static void *win32_globallookup(const char *name)
	{
	HMODULE dll;
	HANDLE hModuleSnap = INVALID_HANDLE_VALUE;
	MODULEENTRY32 me32;
	CREATETOOLHELP32SNAPSHOT create_snap;
	CLOSETOOLHELP32SNAPSHOT  close_snap;
	MODULE32 module_first, module_next;
	FARPROC ret=NULL;

	dll = LoadLibrary(TEXT(DLLNAME));
	if (dll == NULL)
		{
		DSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);
		return NULL;
		}

	create_snap = (CREATETOOLHELP32SNAPSHOT)
		GetProcAddress(dll,"CreateToolhelp32Snapshot");
	if (create_snap == NULL)
		{
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);
		return NULL;
		}
	/* We take the rest for granted... */
#ifdef _WIN32_WCE
	close_snap = (CLOSETOOLHELP32SNAPSHOT)
		GetProcAddress(dll,"CloseToolhelp32Snapshot");
#else
	close_snap = (CLOSETOOLHELP32SNAPSHOT)CloseHandle;
#endif
	module_first = (MODULE32)GetProcAddress(dll,"Module32First");
	module_next  = (MODULE32)GetProcAddress(dll,"Module32Next");

	hModuleSnap = (*create_snap)(TH32CS_SNAPMODULE,0);
	if( hModuleSnap == INVALID_HANDLE_VALUE )
		{
		FreeLibrary(dll);
		DSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);
		return NULL;
		}

	me32.dwSize = sizeof(me32);

	if (!(*module_first)(hModuleSnap,&me32))
		{
		(*close_snap)(hModuleSnap);
		FreeLibrary(dll);
		return NULL;
		}

	do	{
		if ((ret = GetProcAddress(me32.hModule,name)))
			{
			(*close_snap)(hModuleSnap);
			FreeLibrary(dll);
			return ret;
			}
		} while((*module_next)(hModuleSnap,&me32));

	(*close_snap)(hModuleSnap); 
	FreeLibrary(dll);
	return NULL;
	}
#endif /* DSO_WIN32 */
@


