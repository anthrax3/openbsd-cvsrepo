head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.6
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17;
locks; strict;
comment	@ * @;


1.17
date	2016.09.04.16.10.38;	author jsing;	state Exp;
branches;
next	1.16;
commitid	t2vwk4xYuB07Cpdq;

1.16
date	2016.09.04.15.53.03;	author jsing;	state Exp;
branches;
next	1.15;
commitid	DuaZ1v2l8q1Tmk99;

1.15
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.14;
commitid	yQEL1wOWIearrW15;

1.14
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.13;
commitid	nzndm3zqPmFurSaK;

1.13
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	mJUVYpkFBZ0Zv2bG;

1.12
date	2014.05.29.20.21.22;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.21.15.39.52;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.15.20.06.10;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.29.05.39.24;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.15;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.10.53;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.27;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.53;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.53;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.41;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.04.29.05.37.13;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.01.09.12.13.57;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Sort and group functions.
@
text
@/* $OpenBSD: pem_all.c,v 1.16 2016/09/04 15:53:03 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>

#include <openssl/opensslconf.h>

#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/pkcs7.h>
#include <openssl/x509.h>

#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif

#ifndef OPENSSL_NO_RSA
static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa);
#endif
#ifndef OPENSSL_NO_DSA
static DSA *pkey_get_dsa(EVP_PKEY *key, DSA **dsa);
#endif

#ifndef OPENSSL_NO_EC
static EC_KEY *pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey);
#endif


X509_REQ *
PEM_read_X509_REQ(FILE *fp, X509_REQ **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_X509_REQ, PEM_STRING_X509_REQ, fp,
	    (void **)x, cb, u);
}

int
PEM_write_X509_REQ(FILE *fp, X509_REQ *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_X509_REQ, PEM_STRING_X509_REQ, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

X509_REQ *
PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_X509_REQ, PEM_STRING_X509_REQ, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_REQ, PEM_STRING_X509_REQ, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}

int
PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_X509_REQ, PEM_STRING_X509_REQ_OLD, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

int
PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_REQ, PEM_STRING_X509_REQ_OLD, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}

X509_CRL *
PEM_read_X509_CRL(FILE *fp, X509_CRL **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_X509_CRL, PEM_STRING_X509_CRL, fp,
	    (void **)x, cb, u);
}

int
PEM_write_X509_CRL(FILE *fp, X509_CRL *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_X509_CRL, PEM_STRING_X509_CRL, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

X509_CRL *
PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_X509_CRL, PEM_STRING_X509_CRL, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_CRL, PEM_STRING_X509_CRL, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}

PKCS7 *
PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_PKCS7, PEM_STRING_PKCS7, fp,
	    (void **)x, cb, u);
}

int
PEM_write_PKCS7(FILE *fp, PKCS7 *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_PKCS7, PEM_STRING_PKCS7, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

PKCS7 *
PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_PKCS7, PEM_STRING_PKCS7, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_PKCS7, PEM_STRING_PKCS7, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}

int
PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_NETSCAPE_CERT_SEQUENCE, PEM_STRING_X509, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

NETSCAPE_CERT_SEQUENCE *
PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_NETSCAPE_CERT_SEQUENCE, PEM_STRING_X509, fp,
	    (void **)x, cb, u);
}

NETSCAPE_CERT_SEQUENCE *
PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_NETSCAPE_CERT_SEQUENCE, PEM_STRING_X509, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_NETSCAPE_CERT_SEQUENCE, PEM_STRING_X509, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}

#ifndef OPENSSL_NO_RSA

/* We treat RSA or DSA private keys as a special case.
 *
 * For private keys we read in an EVP_PKEY structure with
 * PEM_read_bio_PrivateKey() and extract the relevant private
 * key: this means can handle "traditional" and PKCS#8 formats
 * transparently.
 */

static RSA *
pkey_get_rsa(EVP_PKEY *key, RSA **rsa)
{
	RSA *rtmp;

	if (!key)
		return NULL;
	rtmp = EVP_PKEY_get1_RSA(key);
	EVP_PKEY_free(key);
	if (!rtmp)
		return NULL;
	if (rsa) {
		RSA_free(*rsa);
		*rsa = rtmp;
	}
	return rtmp;
}

RSA *
PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb, void *u)
{
	EVP_PKEY *pktmp;

	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
	return pkey_get_rsa(pktmp, rsa);
}

int
PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
{
        return PEM_ASN1_write((i2d_of_void *)i2d_RSAPrivateKey, PEM_STRING_RSA, fp,
	    x, enc, kstr, klen, cb, u);
}

RSA *
PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb, void *u)
{
	EVP_PKEY *pktmp;

	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
	return pkey_get_rsa(pktmp, rsa);
}

int
PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x,
    const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb,
    void *u)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSAPrivateKey, PEM_STRING_RSA, bp,
	    x, enc, kstr, klen, cb, u);
}

RSA *
PEM_read_RSAPublicKey(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_RSAPublicKey, PEM_STRING_RSA_PUBLIC, fp,
	    (void **)x, cb, u);
}

int
PEM_write_RSAPublicKey(FILE *fp, const RSA *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_RSAPublicKey, PEM_STRING_RSA_PUBLIC, fp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}

RSA *
PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_RSAPublicKey, PEM_STRING_RSA_PUBLIC, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_RSAPublicKey(BIO *bp, const RSA *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSAPublicKey, PEM_STRING_RSA_PUBLIC, bp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}

RSA *
PEM_read_RSA_PUBKEY(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_RSA_PUBKEY, PEM_STRING_PUBLIC, fp,
	    (void **)x, cb, u);
}

int
PEM_write_RSA_PUBKEY(FILE *fp, RSA *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_RSA_PUBKEY, PEM_STRING_PUBLIC, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

RSA *
PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_RSA_PUBKEY, PEM_STRING_PUBLIC, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSA_PUBKEY, PEM_STRING_PUBLIC, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}

#endif

#ifndef OPENSSL_NO_DSA

static DSA *
pkey_get_dsa(EVP_PKEY *key, DSA **dsa)
{
	DSA *dtmp;

	if (!key)
		return NULL;
	dtmp = EVP_PKEY_get1_DSA(key);
	EVP_PKEY_free(key);
	if (!dtmp)
		return NULL;
	if (dsa) {
		DSA_free(*dsa);
		*dsa = dtmp;
	}
	return dtmp;
}

DSA *
PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb, void *u)
{
	EVP_PKEY *pktmp;

	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
	return pkey_get_dsa(pktmp, dsa);	/* will free pktmp */
}

int
PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
{
        return PEM_ASN1_write((i2d_of_void *)i2d_DSAPrivateKey, PEM_STRING_DSA, fp,
	    x, enc, kstr, klen, cb, u);
}

DSA *
PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb, void *u)
{
	EVP_PKEY *pktmp;

	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
	return pkey_get_dsa(pktmp, dsa);	/* will free pktmp */
}

int
PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x,
    const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb,
    void *u)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAPrivateKey, PEM_STRING_DSA, bp,
	    x, enc, kstr, klen, cb, u);
}

DSA *
PEM_read_DSA_PUBKEY(FILE *fp, DSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_DSA_PUBKEY, PEM_STRING_PUBLIC, fp,
	    (void **)x, cb, u);
}

int
PEM_write_DSA_PUBKEY(FILE *fp, DSA *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_DSA_PUBKEY, PEM_STRING_PUBLIC, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

int
PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSA_PUBKEY, PEM_STRING_PUBLIC, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}

DSA *
PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_DSA_PUBKEY, PEM_STRING_PUBLIC, bp,
	    (void **)x, cb, u);
}

DSA *
PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_DSAparams, PEM_STRING_DSAPARAMS, fp,
	    (void **)x, cb, u);
}

int
PEM_write_DSAparams(FILE *fp, const DSA *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_DSAparams, PEM_STRING_DSAPARAMS, fp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}

DSA *
PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_DSAparams, PEM_STRING_DSAPARAMS, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_DSAparams(BIO *bp, const DSA *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAparams, PEM_STRING_DSAPARAMS, bp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}

#endif


#ifndef OPENSSL_NO_EC
static EC_KEY *
pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)
{
	EC_KEY *dtmp;

	if (!key)
		return NULL;
	dtmp = EVP_PKEY_get1_EC_KEY(key);
	EVP_PKEY_free(key);
	if (!dtmp)
		return NULL;
	if (eckey) {
		EC_KEY_free(*eckey);
		*eckey = dtmp;
	}
	return dtmp;
}

EC_GROUP *
PEM_read_ECPKParameters(FILE *fp, EC_GROUP **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_ECPKParameters, PEM_STRING_ECPARAMETERS, fp,
	    (void **)x, cb, u);
}

int
PEM_write_ECPKParameters(FILE *fp, const EC_GROUP *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_ECPKParameters, PEM_STRING_ECPARAMETERS, fp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}

EC_GROUP *
PEM_read_bio_ECPKParameters(BIO *bp, EC_GROUP **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_ECPKParameters, PEM_STRING_ECPARAMETERS, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_ECPKParameters(BIO *bp, const EC_GROUP *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPKParameters, PEM_STRING_ECPARAMETERS, bp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}

EC_KEY *
PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb, void *u)
{
	EVP_PKEY *pktmp;

	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
	return pkey_get_eckey(pktmp, eckey);	/* will free pktmp */
}

int
PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc,
    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
{
        return PEM_ASN1_write((i2d_of_void *)i2d_ECPrivateKey, PEM_STRING_ECPRIVATEKEY, fp,
	    x, enc, kstr, klen, cb, u);
}

EC_KEY *
PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb, void *u)
{
	EVP_PKEY *pktmp;
	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
	return pkey_get_eckey(pktmp, key);	/* will free pktmp */
}

int
PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x,
    const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb,
    void *u)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPrivateKey, PEM_STRING_ECPRIVATEKEY, bp,
	    x, enc, kstr, klen, cb, u);
}

EC_KEY *
PEM_read_EC_PUBKEY(FILE *fp, EC_KEY **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_EC_PUBKEY, PEM_STRING_PUBLIC, fp,
	    (void **)x, cb, u);
}

int
PEM_write_EC_PUBKEY(FILE *fp, EC_KEY *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_EC_PUBKEY, PEM_STRING_PUBLIC, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

EC_KEY *
PEM_read_bio_EC_PUBKEY(BIO *bp, EC_KEY **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_EC_PUBKEY, PEM_STRING_PUBLIC, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_EC_PUBKEY(BIO *bp, EC_KEY *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_EC_PUBKEY, PEM_STRING_PUBLIC, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}

#endif

#ifndef OPENSSL_NO_DH

DH *
PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_DHparams, PEM_STRING_DHPARAMS, fp,
	    (void **)x, cb, u);
}

int
PEM_write_DHparams(FILE *fp, const DH *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_DHparams, PEM_STRING_DHPARAMS, fp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}

DH *
PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_DHparams, PEM_STRING_DHPARAMS, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_DHparams(BIO *bp, const DH *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_DHparams, PEM_STRING_DHPARAMS, bp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}

#endif

EVP_PKEY *
PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_PUBKEY, PEM_STRING_PUBLIC, fp,
	    (void **)x, cb, u);
}

int
PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_PUBKEY, PEM_STRING_PUBLIC, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

EVP_PKEY *
PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_PUBKEY, PEM_STRING_PUBLIC, bp,
	    (void **)x, cb, u);
}

int
PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_PUBKEY, PEM_STRING_PUBLIC, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}
@


1.16
log
@Expand IMPLEMENT_PEM macros.

No change in generated assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: pem_all.c,v 1.15 2014/07/11 08:44:49 jsing Exp $ */
d145 1
a145 1
PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x, pem_password_cb *cb, void *u)
d147 1
a147 1
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_X509_REQ, PEM_STRING_X509_REQ, bp,
d151 7
d159 1
a159 1
PEM_read_X509_REQ(FILE *fp, X509_REQ **x, pem_password_cb *cb, void *u)
d161 1
a161 1
	return PEM_ASN1_read((d2i_of_void *)d2i_X509_REQ, PEM_STRING_X509_REQ, fp,
d173 1
a173 1
PEM_write_X509_REQ(FILE *fp, X509_REQ *x)
d175 1
a175 1
	return PEM_ASN1_write((i2d_of_void *)i2d_X509_REQ, PEM_STRING_X509_REQ, fp,
a178 1

d186 7
d194 1
a194 1
PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x)
d196 1
a196 1
	return PEM_ASN1_write((i2d_of_void *)i2d_X509_REQ, PEM_STRING_X509_REQ_OLD, fp,
a199 1

a206 7
X509_CRL *
PEM_read_X509_CRL(FILE *fp, X509_CRL **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_X509_CRL, PEM_STRING_X509_CRL, fp,
	    (void **)x, cb, u);
}

d214 7
d222 1
a222 1
PEM_write_X509_CRL(FILE *fp, X509_CRL *x)
d224 1
a224 1
	return PEM_ASN1_write((i2d_of_void *)i2d_X509_CRL, PEM_STRING_X509_CRL, fp,
a227 1

a234 7
PKCS7 *
PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_PKCS7, PEM_STRING_PKCS7, fp,
	    (void **)x, cb, u);
}

d243 1
a243 1
PEM_write_PKCS7(FILE *fp, PKCS7 *x)
d245 1
a245 1
	return PEM_ASN1_write((i2d_of_void *)i2d_PKCS7, PEM_STRING_PKCS7, fp,
a248 1

d250 1
a250 1
PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE **x, pem_password_cb *cb, void *u)
d252 1
a252 1
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_NETSCAPE_CERT_SEQUENCE, PEM_STRING_X509, bp,
d257 1
a257 1
PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE **x, pem_password_cb *cb, void *u)
d259 1
a259 1
	return PEM_ASN1_read((d2i_of_void *)d2i_NETSCAPE_CERT_SEQUENCE, PEM_STRING_X509, fp,
a269 8
int
PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_NETSCAPE_CERT_SEQUENCE, PEM_STRING_X509, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}


d299 1
a299 1
PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb, void *u)
d303 1
a303 1
	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
d307 7
d316 1
a316 1
PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb, void *u)
d320 1
a320 1
	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
a323 2


d333 7
d341 1
a341 2
PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
d343 2
a344 2
        return PEM_ASN1_write((i2d_of_void *)i2d_RSAPrivateKey, PEM_STRING_RSA, fp,
	    x, enc, kstr, klen, cb, u);
a346 1

a353 7
RSA *
PEM_read_RSAPublicKey(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_RSAPublicKey, PEM_STRING_RSA_PUBLIC, fp,
	    (void **)x, cb, u);
}

d361 7
d369 1
a369 1
PEM_write_RSAPublicKey(FILE *fp, const RSA *x)
d371 2
a372 2
	return PEM_ASN1_write((i2d_of_void *)i2d_RSAPublicKey, PEM_STRING_RSA_PUBLIC, fp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
a381 7
RSA *
PEM_read_RSA_PUBKEY(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_RSA_PUBKEY, PEM_STRING_PUBLIC, fp,
	    (void **)x, cb, u);
}

a388 7
int
PEM_write_RSA_PUBKEY(FILE *fp, RSA *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_RSA_PUBKEY, PEM_STRING_PUBLIC, fp,
	    x, NULL, NULL, 0, NULL, NULL);
}

d412 1
a412 1
PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb, void *u)
d416 1
a416 1
	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
a419 10

int
PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x,
    const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb,
    void *u)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAPrivateKey, PEM_STRING_DSA, bp,
	    x, enc, kstr, klen, cb, u);
}

d428 8
d437 4
a440 2
DSA *
PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
d442 2
a443 2
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_DSA_PUBKEY, PEM_STRING_PUBLIC, bp,
	    (void **)x, cb, u);
d454 1
a454 1
PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x)
d456 1
a456 1
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSA_PUBKEY, PEM_STRING_PUBLIC, bp,
d461 1
a461 1
PEM_write_DSA_PUBKEY(FILE *fp, DSA *x)
d463 1
a463 1
	return PEM_ASN1_write((i2d_of_void *)i2d_DSA_PUBKEY, PEM_STRING_PUBLIC, fp,
a466 1

d468 1
a468 1
PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb, void *u)
d470 1
a470 12
	EVP_PKEY *pktmp;

	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
	return pkey_get_dsa(pktmp, dsa);	/* will free pktmp */
}



DSA *
PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_DSAparams, PEM_STRING_DSAPARAMS, bp,
d482 1
a482 1
PEM_write_bio_DSAparams(BIO *bp, const DSA *x)
d484 1
a484 1
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAparams, PEM_STRING_DSAPARAMS, bp,
d488 7
d496 1
a496 1
PEM_write_DSAparams(FILE *fp, const DSA *x)
d498 1
a498 1
	return PEM_ASN1_write((i2d_of_void *)i2d_DSAparams, PEM_STRING_DSAPARAMS, fp,
d524 2
a525 2
EC_KEY *
PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb, void *u)
d527 2
a528 3
	EVP_PKEY *pktmp;
	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
	return pkey_get_eckey(pktmp, key);	/* will free pktmp */
d531 6
a544 7
EC_GROUP *
PEM_read_ECPKParameters(FILE *fp, EC_GROUP **x, pem_password_cb *cb, void *u)
{
	return PEM_ASN1_read((d2i_of_void *)d2i_ECPKParameters, PEM_STRING_ECPARAMETERS, fp,
	    (void **)x, cb, u);
}

d552 2
a553 2
int
PEM_write_ECPKParameters(FILE *fp, const EC_GROUP *x)
d555 1
a555 3
	return PEM_ASN1_write((i2d_of_void *)i2d_ECPKParameters, PEM_STRING_ECPARAMETERS, fp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}
d557 2
a558 8

int
PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x,
    const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb,
    void *u)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPrivateKey, PEM_STRING_ECPRIVATEKEY, bp,
	    x, enc, kstr, klen, cb, u);
d569 7
d577 4
a580 2
EC_KEY *
PEM_read_bio_EC_PUBKEY(BIO *bp, EC_KEY **x, pem_password_cb *cb, void *u)
d582 2
a583 2
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_EC_PUBKEY, PEM_STRING_PUBLIC, bp,
	    (void **)x, cb, u);
a593 7
PEM_write_bio_EC_PUBKEY(BIO *bp, EC_KEY *x)
{
	return PEM_ASN1_write_bio((i2d_of_void *)i2d_EC_PUBKEY, PEM_STRING_PUBLIC, bp,
	    x, NULL, NULL, 0, NULL, NULL);
}

int
a599 1

d601 1
a601 1
PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb, void *u)
d603 3
a605 1
	EVP_PKEY *pktmp;
d607 5
a611 2
	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
	return pkey_get_eckey(pktmp, eckey);	/* will free pktmp */
a613 1

a617 1

d619 1
a619 1
PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u)
d621 1
a621 1
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_DHparams, PEM_STRING_DHPARAMS, bp,
d625 7
d633 1
a633 1
PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u)
d635 1
a635 1
	return PEM_ASN1_read((d2i_of_void *)d2i_DHparams, PEM_STRING_DHPARAMS, fp,
a645 7
int
PEM_write_DHparams(FILE *fp, const DH *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_DHparams, PEM_STRING_DHPARAMS, fp,
	    (void *)x, NULL, NULL, 0, NULL, NULL);
}

a647 1

d649 1
a649 1
PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
d651 1
a651 1
	return PEM_ASN1_read_bio((d2i_of_void *)d2i_PUBKEY, PEM_STRING_PUBLIC, bp,
d655 7
d663 1
a663 1
PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
d665 1
a665 1
	return PEM_ASN1_read((d2i_of_void *)d2i_PUBKEY, PEM_STRING_PUBLIC, fp,
a672 7
	    x, NULL, NULL, 0, NULL, NULL);
}

int
PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x)
{
	return PEM_ASN1_write((i2d_of_void *)i2d_PUBKEY, PEM_STRING_PUBLIC, fp,
@


1.15
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_all.c,v 1.14 2014/07/10 22:45:57 jsing Exp $ */
a142 1
IMPLEMENT_PEM_rw(X509_REQ, X509_REQ, PEM_STRING_X509_REQ, X509_REQ)
d144 13
a156 1
IMPLEMENT_PEM_write(X509_REQ_NEW, X509_REQ, PEM_STRING_X509_REQ_OLD, X509_REQ)
d158 6
a163 1
IMPLEMENT_PEM_rw(X509_CRL, X509_CRL, PEM_STRING_X509_CRL, X509_CRL)
d165 6
a170 1
IMPLEMENT_PEM_rw(PKCS7, PKCS7, PEM_STRING_PKCS7, PKCS7)
d172 101
a272 2
IMPLEMENT_PEM_rw(NETSCAPE_CERT_SEQUENCE, NETSCAPE_CERT_SEQUENCE,
    PEM_STRING_X509, NETSCAPE_CERT_SEQUENCE)
a322 1
IMPLEMENT_PEM_write_cb_const(RSAPrivateKey, RSA, PEM_STRING_RSA, RSAPrivateKey)
d324 73
a396 2
IMPLEMENT_PEM_rw_const(RSAPublicKey, RSA, PEM_STRING_RSA_PUBLIC, RSAPublicKey)
IMPLEMENT_PEM_rw(RSA_PUBKEY, RSA, PEM_STRING_PUBLIC, RSA_PUBKEY)
a428 1
IMPLEMENT_PEM_write_cb_const(DSAPrivateKey, DSA, PEM_STRING_DSA, DSAPrivateKey)
d430 45
a474 1
IMPLEMENT_PEM_rw(DSA_PUBKEY, DSA, PEM_STRING_PUBLIC, DSA_PUBKEY)
d487 28
a514 1
IMPLEMENT_PEM_rw_const(DSAparams, DSA, PEM_STRING_DSAPARAMS, DSAparams)
a545 2
IMPLEMENT_PEM_rw_const(ECPKParameters, EC_GROUP, PEM_STRING_ECPARAMETERS,
    ECPKParameters)
d547 20
a566 2
IMPLEMENT_PEM_write_cb(ECPrivateKey, EC_KEY, PEM_STRING_ECPRIVATEKEY,
    ECPrivateKey)
d568 53
a620 1
IMPLEMENT_PEM_rw(EC_PUBKEY, EC_KEY, PEM_STRING_PUBLIC, EC_PUBKEY)
d637 28
a664 1
IMPLEMENT_PEM_rw_const(DHparams, DH, PEM_STRING_DHPARAMS, DHparams)
d668 28
a695 1
IMPLEMENT_PEM_rw(PUBKEY, EVP_PKEY, PEM_STRING_PUBLIC, PUBKEY)
@


1.14
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: pem_all.c,v 1.13 2014/06/12 15:49:30 deraadt Exp $ */
a115 1
#include "cryptlib.h"
d118 2
d121 3
a123 4
#include <openssl/pkcs7.h>
#include <openssl/pem.h>
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
d128 2
a129 2
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
@


1.13
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d113 3
@


1.12
log
@Everything sane has stdio, and FILE *. we don't need ifdefs for this.
ok to firebomb from tedu@@
@
text
@d1 1
a1 1
/* crypto/pem/pem_all.c */
@


1.11
log
@KNF.
@
text
@a188 1
#ifndef OPENSSL_NO_FP_API
a198 1
#endif
a239 1
#ifndef OPENSSL_NO_FP_API
a249 1
#endif
a290 1
#ifndef OPENSSL_NO_FP_API
a300 1
#endif
@


1.10
log
@remove FIPS mode support. people who require FIPS can buy something that
meets their needs, but dumping it in here only penalizes the rest of us.
ok beck deraadt
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d149 1
a149 1
					PEM_STRING_X509, NETSCAPE_CERT_SEQUENCE)
d162 2
a163 1
static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa)
d166 3
a168 1
	if(!key) return NULL;
d171 3
a173 2
	if(!rtmp) return NULL;
	if(rsa) {
d180 2
a181 2
RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb,
								void *u)
d184 1
d191 2
a192 2
RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb,
								void *u)
d195 1
d211 2
a212 1
static DSA *pkey_get_dsa(EVP_PKEY *key, DSA **dsa)
d215 3
a217 1
	if(!key) return NULL;
d220 3
a222 2
	if(!dtmp) return NULL;
	if(dsa) {
d229 2
a230 2
DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb,
								void *u)
d233 1
d244 2
a245 2
DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb,
								void *u)
d248 1
d261 2
a262 1
static EC_KEY *pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)
d265 3
a267 1
	if(!key) return NULL;
d270 4
a273 4
	if(!dtmp) return NULL;
	if(eckey) 
	{
 		EC_KEY_free(*eckey);
d279 2
a280 2
EC_KEY *PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb,
							void *u)
d287 2
a288 1
IMPLEMENT_PEM_rw_const(ECPKParameters, EC_GROUP, PEM_STRING_ECPARAMETERS, ECPKParameters)
d290 2
a291 3


IMPLEMENT_PEM_write_cb(ECPrivateKey, EC_KEY, PEM_STRING_ECPRIVATEKEY, ECPrivateKey)
d296 3
a298 3
 
EC_KEY *PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb,
 								void *u)
d301 1
@


1.9
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a195 51
#ifdef OPENSSL_FIPS

int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_RSA(k, x);

		ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSAPrivateKey,
					PEM_STRING_RSA,bp,x,enc,kstr,klen,cb,u);
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;

		EVP_PKEY_set1_RSA(k, x);

		ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write((i2d_of_void *)i2d_RSAPrivateKey,
					PEM_STRING_RSA,fp,x,enc,kstr,klen,cb,u);
}
#endif

#else

a197 2
#endif

a226 49
#ifdef OPENSSL_FIPS

int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_DSA(k, x);

		ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAPrivateKey,
					PEM_STRING_DSA,bp,x,enc,kstr,klen,cb,u);
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_DSA(k, x);
		ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write((i2d_of_void *)i2d_DSAPrivateKey,
					PEM_STRING_DSA,fp,x,enc,kstr,klen,cb,u);
}
#endif

#else

a228 2
#endif

a275 51
#ifdef OPENSSL_FIPS

int PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_EC_KEY(k, x);

		ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPrivateKey,
						PEM_STRING_ECPRIVATEKEY,
						bp,x,enc,kstr,klen,cb,u);
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_EC_KEY(k, x);
		ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write((i2d_of_void *)i2d_ECPrivateKey,
						PEM_STRING_ECPRIVATEKEY,
						fp,x,enc,kstr,klen,cb,u);
}
#endif

#else

a276 2

#endif
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d196 51
d248 3
d280 49
d330 3
d378 53
d432 2
@


1.7
log
@resolve conflicts
@
text
@a112 1
#undef SSLEAY_MACROS
a195 39
#ifdef OPENSSL_FIPS

int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_RSA(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;

	EVP_PKEY_set1_RSA(k, x);

	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}
#endif

#else

a196 3

#endif

d223 1
a223 35
	return pkey_get_dsa(pktmp, dsa);
}

#ifdef OPENSSL_FIPS

int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_DSA(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_DSA(k, x);
	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
a224 3
#endif

#else
a226 3

#endif

d236 1
a236 1
	return pkey_get_dsa(pktmp, dsa);
d267 1
a267 1
	return pkey_get_eckey(pktmp, key);
a271 39


#ifdef OPENSSL_FIPS

int PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_EC_KEY(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_EC_KEY(k, x);
	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}
#endif

#else

a273 2
#endif

d283 1
a283 1
	return pkey_get_eckey(pktmp, eckey);
a295 61

/* The PrivateKey case is not that straightforward.
 *   IMPLEMENT_PEM_rw_cb(PrivateKey, EVP_PKEY, PEM_STRING_EVP_PKEY, PrivateKey)
 * does not work, RSA and DSA keys have specific strings.
 * (When reading, parameter PEM_STRING_EVP_PKEY is a wildcard for anything
 * appropriate.)
 */

#ifdef OPENSSL_FIPS

static const char *pkey_str(EVP_PKEY *x)
	{
	switch (x->type)
		{
		case EVP_PKEY_RSA:
		return PEM_STRING_RSA;

		case EVP_PKEY_DSA:
		return PEM_STRING_DSA;

		case EVP_PKEY_EC:
		return PEM_STRING_ECPRIVATEKEY;

		default:
		return NULL;
		}
	}


int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
	{
		if (FIPS_mode())
			return PEM_write_bio_PKCS8PrivateKey(bp, x, enc,
						(char *)kstr, klen, cb, u);
		else
                	return PEM_ASN1_write_bio((i2d_of_void *)i2d_PrivateKey,
			pkey_str(x), bp,(char *)x,enc,kstr,klen,cb,u);
	}

#ifndef OPENSSL_NO_FP_API
int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
	{
		if (FIPS_mode())
			return PEM_write_PKCS8PrivateKey(fp, x, enc,
						(char *)kstr, klen, cb, u);
		else
                	return PEM_ASN1_write((i2d_of_void *)i2d_PrivateKey,
			pkey_str(x), fp,(char *)x,enc,kstr,klen,cb,u);
	}
#endif

#else
IMPLEMENT_PEM_write_cb(PrivateKey, EVP_PKEY, ((x->type == EVP_PKEY_DSA)?PEM_STRING_DSA:\
			(x->type == EVP_PKEY_RSA)?PEM_STRING_RSA:PEM_STRING_ECPRIVATEKEY), PrivateKey)

#endif

a296 1

@


1.6
log
@resolve conflicts
@
text
@d197 39
d237 3
d269 37
d307 3
d355 39
d396 2
d427 49
d478 2
@


1.5
log
@resolve conflicts
@
text
@d58 53
d120 9
a128 1
#include <openssl/fips.h>
d137 4
d197 2
a198 44
#ifdef OPENSSL_FIPS

int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_RSA(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;

	EVP_PKEY_set1_RSA(k, x);

	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}
#endif

#else

IMPLEMENT_PEM_write_cb(RSAPrivateKey, RSA, PEM_STRING_RSA, RSAPrivateKey)

#endif

IMPLEMENT_PEM_rw(RSAPublicKey, RSA, PEM_STRING_RSA_PUBLIC, RSAPublicKey)
d227 2
d230 1
a230 1
#ifdef OPENSSL_FIPS
d232 6
a237 14
int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_DSA(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
d240 9
a248 4
#ifndef OPENSSL_NO_FP_API
int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
d250 11
a260 9
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_DSA(k, x);
	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
a261 1
#endif
d263 7
a269 1
#else
d271 1
a271 1
IMPLEMENT_PEM_write_cb(DSAPrivateKey, DSA, PEM_STRING_DSA, DSAPrivateKey)
d273 1
a273 1
#endif
d275 1
a275 1
IMPLEMENT_PEM_rw(DSA_PUBKEY, DSA, PEM_STRING_PUBLIC, DSA_PUBKEY)
d278 3
a280 3

DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb,
								void *u)
d284 1
a284 1
	return pkey_get_dsa(pktmp, dsa);
a288 2
IMPLEMENT_PEM_rw(DSAparams, DSA, PEM_STRING_DSAPARAMS, DSAparams)

d293 1
a293 1
IMPLEMENT_PEM_rw(DHparams, DH, PEM_STRING_DHPARAMS, DHparams)
d304 2
a305 36

#ifdef OPENSSL_FIPS

int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
	{
		if (FIPS_mode())
			return PEM_write_bio_PKCS8PrivateKey(bp, x, enc,
						(char *)kstr, klen, cb, u);
		else
                	return PEM_ASN1_write_bio((int (*)())i2d_PrivateKey,
                (((x)->type == EVP_PKEY_DSA)?PEM_STRING_DSA:PEM_STRING_RSA),
                        bp,(char *)x,enc,kstr,klen,cb,u);
	}

#ifndef OPENSSL_NO_FP_API
int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
	{
		if (FIPS_mode())
			return PEM_write_PKCS8PrivateKey(fp, x, enc,
						(char *)kstr, klen, cb, u);
		else
                	return PEM_ASN1_write((int (*)())i2d_PrivateKey,
                (((x)->type == EVP_PKEY_DSA)?PEM_STRING_DSA:PEM_STRING_RSA),
                        fp,(char *)x,enc,kstr,klen,cb,u);
	}
#endif

#else

IMPLEMENT_PEM_write_cb(PrivateKey, EVP_PKEY, ((x->type == EVP_PKEY_DSA)?PEM_STRING_DSA:PEM_STRING_RSA), PrivateKey)

#endif
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d67 1
d132 39
d172 3
d204 38
d243 3
d277 33
d311 2
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d68 1
a68 1
#ifndef NO_RSA
d71 1
a71 1
#ifndef NO_DSA
a74 4
IMPLEMENT_PEM_rw(X509, X509, PEM_STRING_X509, X509)

IMPLEMENT_PEM_rw(X509_AUX, X509, PEM_STRING_X509_TRUSTED, X509_AUX)

a85 3
IMPLEMENT_PEM_rw(PKCS8, X509_SIG, PEM_STRING_PKCS8, X509_SIG)
IMPLEMENT_PEM_rw(PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO, PEM_STRING_PKCS8INF,
							 PKCS8_PRIV_KEY_INFO)
d87 1
a87 1
#ifndef NO_RSA
d119 1
a119 1
#ifndef NO_FP_API
d137 1
a137 1
#ifndef NO_DSA
d164 1
a164 1
#ifndef NO_FP_API
d180 1
a180 1
#ifndef NO_DH
a192 1
IMPLEMENT_PEM_read(PrivateKey, EVP_PKEY, PEM_STRING_EVP_PKEY, PrivateKey)
d196 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d68 7
d77 2
d81 2
d96 41
a136 1
IMPLEMENT_PEM_rw_cb(RSAPrivateKey, RSA, PEM_STRING_RSA, RSAPrivateKey)
d138 1
d140 1
d146 36
a181 1
IMPLEMENT_PEM_rw_cb(DSAPrivateKey, DSA, PEM_STRING_DSA, DSAPrivateKey)
d202 2
@


1.1
log
@Initial revision
@
text
@d62 5
a66 17
#include "bio.h"
#include "evp.h"
#include "x509.h"
#include "pkcs7.h"
#include "pem.h"

#ifndef NO_FP_API
/* The X509 functions */
X509 *PEM_read_X509(fp,x,cb)
FILE *fp;
X509 **x;
int (*cb)();
	{
	return((X509 *)PEM_ASN1_read((char *(*)())d2i_X509,
		PEM_STRING_X509,fp,(char **)x,cb));
	}
#endif
d68 1
a68 18
X509 *PEM_read_bio_X509(bp,x,cb)
BIO *bp;
X509 **x;
int (*cb)();
	{
	return((X509 *)PEM_ASN1_read_bio((char *(*)())d2i_X509,
		PEM_STRING_X509,bp,(char **)x,cb));
	}

#ifndef NO_FP_API
int PEM_write_X509(fp,x)
FILE *fp;
X509 *x;
	{
	return(PEM_ASN1_write((int (*)())i2d_X509,PEM_STRING_X509,fp,
		(char *)x, NULL,NULL,0,NULL));
	}
#endif
d70 1
a70 19
int PEM_write_bio_X509(bp,x)
BIO *bp;
X509 *x;
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_X509,PEM_STRING_X509,bp,
		(char *)x, NULL,NULL,0,NULL));
	}

#ifndef NO_FP_API
/* The X509_REQ functions */
X509_REQ *PEM_read_X509_REQ(fp,x,cb)
FILE *fp;
X509_REQ **x;
int (*cb)();
	{
	return((X509_REQ *)PEM_ASN1_read((char *(*)())d2i_X509_REQ,
		PEM_STRING_X509_REQ,fp,(char **)x,cb));
	}
#endif
d72 1
a72 18
X509_REQ *PEM_read_bio_X509_REQ(bp,x,cb)
BIO *bp;
X509_REQ **x;
int (*cb)();
	{
	return((X509_REQ *)PEM_ASN1_read_bio((char *(*)())d2i_X509_REQ,
		PEM_STRING_X509_REQ,bp,(char **)x,cb));
	}

#ifndef NO_FP_API
int PEM_write_X509_REQ(fp,x)
FILE *fp;
X509_REQ *x;
	{
	return(PEM_ASN1_write((int (*)())i2d_X509_REQ,PEM_STRING_X509_REQ,fp,
		(char *)x, NULL,NULL,0,NULL));
	}
#endif
d74 1
a74 19
int PEM_write_bio_X509_REQ(bp,x)
BIO *bp;
X509_REQ *x;
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_X509_REQ,PEM_STRING_X509_REQ,
		bp,(char *)x, NULL,NULL,0,NULL));
	}

#ifndef NO_FP_API
/* The X509_CRL functions */
X509_CRL *PEM_read_X509_CRL(fp,x,cb)
FILE *fp;
X509_CRL **x;
int (*cb)();
	{
	return((X509_CRL *)PEM_ASN1_read((char *(*)())d2i_X509_CRL,
		PEM_STRING_X509_CRL,fp,(char **)x,cb));
	}
#endif
d76 2
a77 18
X509_CRL *PEM_read_bio_X509_CRL(bp,x,cb)
BIO *bp;
X509_CRL **x;
int (*cb)();
	{
	return((X509_CRL *)PEM_ASN1_read_bio((char *(*)())d2i_X509_CRL,
		PEM_STRING_X509_CRL,bp,(char **)x,cb));
	}

#ifndef NO_FP_API
int PEM_write_X509_CRL(fp,x)
FILE *fp;
X509_CRL *x;
	{
	return(PEM_ASN1_write((int (*)())i2d_X509_CRL,PEM_STRING_X509_CRL,fp,
		(char *)x, NULL,NULL,0,NULL));
	}
#endif
d79 3
a81 7
int PEM_write_bio_X509_CRL(bp,x)
BIO *bp;
X509_CRL *x;
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_X509_CRL,PEM_STRING_X509_CRL,
		bp,(char *)x, NULL,NULL,0,NULL));
	}
a83 20
#ifndef NO_FP_API
/* The RSAPrivateKey functions */
RSA *PEM_read_RSAPrivateKey(fp,x,cb)
FILE *fp;
RSA **x;
int (*cb)();
	{
	return((RSA *)PEM_ASN1_read((char *(*)())d2i_RSAPrivateKey,
		PEM_STRING_RSA,fp,(char **)x,cb));
	}

RSA *PEM_read_RSAPublicKey(fp,x,cb)
FILE *fp;
RSA **x;
int (*cb)();
	{
	return((RSA *)PEM_ASN1_read((char *(*)())d2i_RSAPublicKey,
		PEM_STRING_RSA_PUBLIC,fp,(char **)x,cb));
	}
#endif
d85 1
a85 40
RSA *PEM_read_bio_RSAPrivateKey(bp,x,cb)
BIO *bp;
RSA **x;
int (*cb)();
	{
	return((RSA *)PEM_ASN1_read_bio((char *(*)())d2i_RSAPrivateKey,
		PEM_STRING_RSA,bp,(char **)x,cb));
	}

RSA *PEM_read_bio_RSAPublicKey(bp,x,cb)
BIO *bp;
RSA **x;
int (*cb)();
	{
	return((RSA *)PEM_ASN1_read_bio((char *(*)())d2i_RSAPublicKey,
		PEM_STRING_RSA_PUBLIC,bp,(char **)x,cb));
	}

#ifndef NO_FP_API
int PEM_write_RSAPrivateKey(fp,x,enc,kstr,klen,cb)
FILE *fp;
RSA *x;
EVP_CIPHER *enc;
unsigned char *kstr;
int klen;
int (*cb)();
	{
	return(PEM_ASN1_write((int (*)())i2d_RSAPrivateKey,PEM_STRING_RSA,fp,
		(char *)x,enc,kstr,klen,cb));
	}

int PEM_write_RSAPublicKey(fp,x)
FILE *fp;
RSA *x;
	{
	return(PEM_ASN1_write((int (*)())i2d_RSAPublicKey,
		PEM_STRING_RSA_PUBLIC,fp,
		(char *)x,NULL,NULL,0,NULL));
	}
#endif
d87 1
a87 21
int PEM_write_bio_RSAPrivateKey(bp,x,enc,kstr,klen,cb)
BIO *bp;
RSA *x;
EVP_CIPHER *enc;
unsigned char *kstr;
int klen;
int (*cb)();
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_RSAPrivateKey,PEM_STRING_RSA,
		bp,(char *)x,enc,kstr,klen,cb));
	}

int PEM_write_bio_RSAPublicKey(bp,x)
BIO *bp;
RSA *x;
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_RSAPublicKey,
		PEM_STRING_RSA_PUBLIC,
		bp,(char *)x,NULL,NULL,0,NULL));
	}
#endif /* !NO_RSA */
a88 11
#ifndef NO_DSA
#ifndef NO_FP_API
/* The DSAPrivateKey functions */
DSA *PEM_read_DSAPrivateKey(fp,x,cb)
FILE *fp;
DSA **x;
int (*cb)();
	{
	return((DSA *)PEM_ASN1_read((char *(*)())d2i_DSAPrivateKey,
		PEM_STRING_DSA,fp,(char **)x,cb));
	}
d91 1
a91 35
DSA *PEM_read_bio_DSAPrivateKey(bp,x,cb)
BIO *bp;
DSA **x;
int (*cb)();
	{
	return((DSA *)PEM_ASN1_read_bio((char *(*)())d2i_DSAPrivateKey,
		PEM_STRING_DSA,bp,(char **)x,cb));
	}

#ifndef NO_FP_API
int PEM_write_DSAPrivateKey(fp,x,enc,kstr,klen,cb)
FILE *fp;
DSA *x;
EVP_CIPHER *enc;
unsigned char *kstr;
int klen;
int (*cb)();
	{
	return(PEM_ASN1_write((int (*)())i2d_DSAPrivateKey,PEM_STRING_DSA,fp,
		(char *)x,enc,kstr,klen,cb));
	}
#endif

int PEM_write_bio_DSAPrivateKey(bp,x,enc,kstr,klen,cb)
BIO *bp;
DSA *x;
EVP_CIPHER *enc;
unsigned char *kstr;
int klen;
int (*cb)();
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_DSAPrivateKey,PEM_STRING_DSA,
		bp,(char *)x,enc,kstr,klen,cb));
	}
#endif
d93 1
a93 35
#ifndef NO_FP_API
/* The PrivateKey functions */
EVP_PKEY *PEM_read_PrivateKey(fp,x,cb)
FILE *fp;
EVP_PKEY **x;
int (*cb)();
	{
	return((EVP_PKEY *)PEM_ASN1_read((char *(*)())d2i_PrivateKey,
		PEM_STRING_EVP_PKEY,fp,(char **)x,cb));
	}
#endif

EVP_PKEY *PEM_read_bio_PrivateKey(bp,x,cb)
BIO *bp;
EVP_PKEY **x;
int (*cb)();
	{
	return((EVP_PKEY *)PEM_ASN1_read_bio((char *(*)())d2i_PrivateKey,
		PEM_STRING_EVP_PKEY,bp,(char **)x,cb));
	}

#ifndef NO_FP_API
int PEM_write_PrivateKey(fp,x,enc,kstr,klen,cb)
FILE *fp;
EVP_PKEY *x;
EVP_CIPHER *enc;
unsigned char *kstr;
int klen;
int (*cb)();
	{
	return(PEM_ASN1_write((int (*)())i2d_PrivateKey,
		((x->type == EVP_PKEY_DSA)?PEM_STRING_DSA:PEM_STRING_RSA),
		fp,(char *)x,enc,kstr,klen,cb));
	}
#endif
d95 1
a95 24
int PEM_write_bio_PrivateKey(bp,x,enc,kstr,klen,cb)
BIO *bp;
EVP_PKEY *x;
EVP_CIPHER *enc;
unsigned char *kstr;
int klen;
int (*cb)();
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_PrivateKey,
		((x->type == EVP_PKEY_DSA)?PEM_STRING_DSA:PEM_STRING_RSA),
		bp,(char *)x,enc,kstr,klen,cb));
	}

#ifndef NO_FP_API
/* The PKCS7 functions */
PKCS7 *PEM_read_PKCS7(fp,x,cb)
FILE *fp;
PKCS7 **x;
int (*cb)();
	{
	return((PKCS7 *)PEM_ASN1_read((char *(*)())d2i_PKCS7,
		PEM_STRING_PKCS7,fp,(char **)x,cb));
	}
#endif
a96 17
PKCS7 *PEM_read_bio_PKCS7(bp,x,cb)
BIO *bp;
PKCS7 **x;
int (*cb)();
	{
	return((PKCS7 *)PEM_ASN1_read_bio((char *(*)())d2i_PKCS7,
		PEM_STRING_PKCS7,bp,(char **)x,cb));
	}

#ifndef NO_FP_API
int PEM_write_PKCS7(fp,x)
FILE *fp;
PKCS7 *x;
	{
	return(PEM_ASN1_write((int (*)())i2d_PKCS7,PEM_STRING_PKCS7,fp,
		(char *)x, NULL,NULL,0,NULL));
	}
a98 8
int PEM_write_bio_PKCS7(bp,x)
BIO *bp;
PKCS7 *x;
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_PKCS7,PEM_STRING_PKCS7,bp,
		(char *)x, NULL,NULL,0,NULL));
	}

a99 11
#ifndef NO_FP_API
/* The DHparams functions */
DH *PEM_read_DHparams(fp,x,cb)
FILE *fp;
DH **x;
int (*cb)();
	{
	return((DH *)PEM_ASN1_read((char *(*)())d2i_DHparams,
		PEM_STRING_DHPARAMS,fp,(char **)x,cb));
	}
#endif
d101 1
a101 18
DH *PEM_read_bio_DHparams(bp,x,cb)
BIO *bp;
DH **x;
int (*cb)();
	{
	return((DH *)PEM_ASN1_read_bio((char *(*)())d2i_DHparams,
		PEM_STRING_DHPARAMS,bp,(char **)x,cb));
	}

#ifndef NO_FP_API
int PEM_write_DHparams(fp,x)
FILE *fp;
DH *x;
	{
	return(PEM_ASN1_write((int (*)())i2d_DHparams,PEM_STRING_DHPARAMS,fp,
		(char *)x, NULL,NULL,0,NULL));
	}
#endif
a102 7
int PEM_write_bio_DHparams(bp,x)
BIO *bp;
DH *x;
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_DHparams,PEM_STRING_DHPARAMS,
		bp,(char *)x, NULL,NULL,0,NULL));
	}
a104 40
#ifndef NO_DSA
#ifndef NO_FP_API
/* The DSAparams functions */
DSA *PEM_read_DSAparams(fp,x,cb)
FILE *fp;
DSA **x;
int (*cb)();
	{
	return((DSA *)PEM_ASN1_read((char *(*)())d2i_DSAparams,
		PEM_STRING_DSAPARAMS,fp,(char **)x,cb));
	}
#endif

DSA *PEM_read_bio_DSAparams(bp,x,cb)
BIO *bp;
DSA **x;
int (*cb)();
	{
	return((DSA *)PEM_ASN1_read_bio((char *(*)())d2i_DSAparams,
		PEM_STRING_DSAPARAMS,bp,(char **)x,cb));
	}

#ifndef NO_FP_API
int PEM_write_DSAparams(fp,x)
FILE *fp;
DSA *x;
	{
	return(PEM_ASN1_write((int (*)())i2d_DSAparams,PEM_STRING_DSAPARAMS,fp,
		(char *)x, NULL,NULL,0,NULL));
	}
#endif

int PEM_write_bio_DSAparams(bp,x)
BIO *bp;
DSA *x;
	{
	return(PEM_ASN1_write_bio((int (*)())i2d_DSAparams,PEM_STRING_DSAPARAMS,
		bp,(char *)x, NULL,NULL,0,NULL));
	}
#endif
d106 8
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d62 26
a87 5
#include <openssl/bio.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <openssl/pkcs7.h>
#include <openssl/pem.h>
d89 8
a96 2
#ifndef OPENSSL_NO_RSA
static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa);
d98 19
a116 2
#ifndef OPENSSL_NO_DSA
static DSA *pkey_get_dsa(EVP_PKEY *key, DSA **dsa);
d119 38
a156 1
IMPLEMENT_PEM_rw(X509_REQ, X509_REQ, PEM_STRING_X509_REQ, X509_REQ)
d158 8
a165 1
IMPLEMENT_PEM_write(X509_REQ_NEW, X509_REQ, PEM_STRING_X509_REQ_OLD, X509_REQ)
d167 9
a175 1
IMPLEMENT_PEM_rw(X509_CRL, X509_CRL, PEM_STRING_X509_CRL, X509_CRL)
d177 7
a183 1
IMPLEMENT_PEM_rw(PKCS7, PKCS7, PEM_STRING_PKCS7, PKCS7)
d185 11
a195 2
IMPLEMENT_PEM_rw(NETSCAPE_CERT_SEQUENCE, NETSCAPE_CERT_SEQUENCE,
					PEM_STRING_X509, NETSCAPE_CERT_SEQUENCE)
d197 9
d207 8
a214 1
#ifndef OPENSSL_NO_RSA
d216 8
a223 7
/* We treat RSA or DSA private keys as a special case.
 *
 * For private keys we read in an EVP_PKEY structure with
 * PEM_read_bio_PrivateKey() and extract the relevant private
 * key: this means can handle "traditional" and PKCS#8 formats
 * transparently.
 */
d225 11
a235 10
static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa)
{
	RSA *rtmp;
	if(!key) return NULL;
	rtmp = EVP_PKEY_get1_RSA(key);
	EVP_PKEY_free(key);
	if(!rtmp) return NULL;
	if(rsa) {
		RSA_free(*rsa);
		*rsa = rtmp;
a236 2
	return rtmp;
}
d238 9
a246 7
RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb,
								void *u)
{
	EVP_PKEY *pktmp;
	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
	return pkey_get_rsa(pktmp, rsa);
}
d248 11
a258 1
#ifndef OPENSSL_NO_FP_API
d260 9
a268 7
RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb,
								void *u)
{
	EVP_PKEY *pktmp;
	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
	return pkey_get_rsa(pktmp, rsa);
}
d270 11
d283 8
a290 3
IMPLEMENT_PEM_write_cb(RSAPrivateKey, RSA, PEM_STRING_RSA, RSAPrivateKey)
IMPLEMENT_PEM_rw(RSAPublicKey, RSA, PEM_STRING_RSA_PUBLIC, RSAPublicKey)
IMPLEMENT_PEM_rw(RSA_PUBKEY, RSA, PEM_STRING_PUBLIC, RSA_PUBKEY)
d292 12
d306 12
a317 1
#ifndef OPENSSL_NO_DSA
d319 9
a327 10
static DSA *pkey_get_dsa(EVP_PKEY *key, DSA **dsa)
{
	DSA *dtmp;
	if(!key) return NULL;
	dtmp = EVP_PKEY_get1_DSA(key);
	EVP_PKEY_free(key);
	if(!dtmp) return NULL;
	if(dsa) {
		DSA_free(*dsa);
		*dsa = dtmp;
d329 1
a329 2
	return dtmp;
}
d331 8
a338 7
DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb,
								void *u)
{
	EVP_PKEY *pktmp;
	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
	return pkey_get_dsa(pktmp, dsa);
}
d340 14
a353 2
IMPLEMENT_PEM_write_cb(DSAPrivateKey, DSA, PEM_STRING_DSA, DSAPrivateKey)
IMPLEMENT_PEM_rw(DSA_PUBKEY, DSA, PEM_STRING_PUBLIC, DSA_PUBKEY)
d355 12
a366 1
#ifndef OPENSSL_NO_FP_API
d368 20
a387 7
DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb,
								void *u)
{
	EVP_PKEY *pktmp;
	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
	return pkey_get_dsa(pktmp, dsa);
}
d389 8
d399 7
a405 1
IMPLEMENT_PEM_rw(DSAparams, DSA, PEM_STRING_DSAPARAMS, DSAparams)
d407 11
d420 8
a427 1
#ifndef OPENSSL_NO_DH
d429 9
a437 1
IMPLEMENT_PEM_rw(DHparams, DH, PEM_STRING_DHPARAMS, DHparams)
d439 7
d448 12
d461 8
a468 7
/* The PrivateKey case is not that straightforward.
 *   IMPLEMENT_PEM_rw_cb(PrivateKey, EVP_PKEY, PEM_STRING_EVP_PKEY, PrivateKey)
 * does not work, RSA and DSA keys have specific strings.
 * (When reading, parameter PEM_STRING_EVP_PKEY is a wildcard for anything
 * appropriate.)
 */
IMPLEMENT_PEM_write_cb(PrivateKey, EVP_PKEY, ((x->type == EVP_PKEY_DSA)?PEM_STRING_DSA:PEM_STRING_RSA), PrivateKey)
d470 18
a487 1
IMPLEMENT_PEM_rw(PUBKEY, EVP_PKEY, PEM_STRING_PUBLIC, PUBKEY)
@


1.1.1.3
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a66 1
#include <openssl/fips.h>
a130 39
#ifdef OPENSSL_FIPS

int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_RSA(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;

	EVP_PKEY_set1_RSA(k, x);

	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}
#endif

#else

a131 3

#endif

a160 38

#ifdef OPENSSL_FIPS

int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_DSA(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_DSA(k, x);
	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}
#endif

#else

a161 3

#endif

a192 33

#ifdef OPENSSL_FIPS

int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
	{
		if (FIPS_mode())
			return PEM_write_bio_PKCS8PrivateKey(bp, x, enc,
						(char *)kstr, klen, cb, u);
		else
                	return PEM_ASN1_write_bio((int (*)())i2d_PrivateKey,
                (((x)->type == EVP_PKEY_DSA)?PEM_STRING_DSA:PEM_STRING_RSA),
                        bp,(char *)x,enc,kstr,klen,cb,u);
	}

#ifndef OPENSSL_NO_FP_API
int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
	{
		if (FIPS_mode())
			return PEM_write_PKCS8PrivateKey(fp, x, enc,
						(char *)kstr, klen, cb, u);
		else
                	return PEM_ASN1_write((int (*)())i2d_PrivateKey,
                (((x)->type == EVP_PKEY_DSA)?PEM_STRING_DSA:PEM_STRING_RSA),
                        fp,(char *)x,enc,kstr,klen,cb,u);
	}
#endif

#else

a193 2

#endif
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d67 1
a67 9
#ifndef OPENSSL_NO_RSA
#include <openssl/rsa.h>
#endif
#ifndef OPENSSL_NO_DSA
#include <openssl/dsa.h>
#endif
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
a75 4
#ifndef OPENSSL_NO_EC
static EC_KEY *pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey);
#endif

d132 44
a175 2
IMPLEMENT_PEM_write_cb_const(RSAPrivateKey, RSA, PEM_STRING_RSA, RSAPrivateKey)
IMPLEMENT_PEM_rw_const(RSAPublicKey, RSA, PEM_STRING_RSA_PUBLIC, RSAPublicKey)
a203 2
IMPLEMENT_PEM_write_cb_const(DSAPrivateKey, DSA, PEM_STRING_DSA, DSAPrivateKey)
IMPLEMENT_PEM_rw(DSA_PUBKEY, DSA, PEM_STRING_PUBLIC, DSA_PUBKEY)
d205 1
a205 1
#ifndef OPENSSL_NO_FP_API
d207 14
a220 6
DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb,
								void *u)
{
	EVP_PKEY *pktmp;
	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
	return pkey_get_dsa(pktmp, dsa);
d223 4
a226 9
#endif

IMPLEMENT_PEM_rw_const(DSAparams, DSA, PEM_STRING_DSAPARAMS, DSAparams)

#endif


#ifndef OPENSSL_NO_EC
static EC_KEY *pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)
d228 9
a236 11
	EC_KEY *dtmp;
	if(!key) return NULL;
	dtmp = EVP_PKEY_get1_EC_KEY(key);
	EVP_PKEY_free(key);
	if(!dtmp) return NULL;
	if(eckey) 
	{
 		EC_KEY_free(*eckey);
		*eckey = dtmp;
	}
	return dtmp;
d238 1
d240 1
a240 7
EC_KEY *PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb,
							void *u)
{
	EVP_PKEY *pktmp;
	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
	return pkey_get_eckey(pktmp, key);
}
d242 1
a242 1
IMPLEMENT_PEM_rw_const(ECPKParameters, EC_GROUP, PEM_STRING_ECPARAMETERS, ECPKParameters)
d244 1
a244 1
IMPLEMENT_PEM_write_cb(ECPrivateKey, EC_KEY, PEM_STRING_ECPRIVATEKEY, ECPrivateKey)
d246 1
a246 1
IMPLEMENT_PEM_rw(EC_PUBKEY, EC_KEY, PEM_STRING_PUBLIC, EC_PUBKEY)
d249 3
a251 3
 
EC_KEY *PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb,
 								void *u)
d255 1
a255 1
	return pkey_get_eckey(pktmp, eckey);
d260 2
d266 1
a266 1
IMPLEMENT_PEM_rw_const(DHparams, DH, PEM_STRING_DHPARAMS, DHparams)
d277 36
a312 2
IMPLEMENT_PEM_write_cb(PrivateKey, EVP_PKEY, ((x->type == EVP_PKEY_DSA)?PEM_STRING_DSA:\
			(x->type == EVP_PKEY_RSA)?PEM_STRING_RSA:PEM_STRING_ECPRIVATEKEY), PrivateKey)
@


1.1.1.5
log
@import openssl-0.9.8j
@
text
@a196 39
#ifdef OPENSSL_FIPS

int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_RSA(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;

	EVP_PKEY_set1_RSA(k, x);

	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}
#endif

#else

a197 3

#endif

a226 37
#ifdef OPENSSL_FIPS

int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_DSA(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_DSA(k, x);
	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}
#endif

#else

a227 3

#endif

a272 39


#ifdef OPENSSL_FIPS

int PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_EC_KEY(k, x);

	ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	EVP_PKEY *k;
	int ret;
	k = EVP_PKEY_new();
	if (!k)
		return 0;
	EVP_PKEY_set1_EC_KEY(k, x);
	ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
	EVP_PKEY_free(k);
	return ret;
}
#endif

#else

a274 2
#endif

a303 49

#ifdef OPENSSL_FIPS

static const char *pkey_str(EVP_PKEY *x)
	{
	switch (x->type)
		{
		case EVP_PKEY_RSA:
		return PEM_STRING_RSA;

		case EVP_PKEY_DSA:
		return PEM_STRING_DSA;

		case EVP_PKEY_EC:
		return PEM_STRING_ECPRIVATEKEY;

		default:
		return NULL;
		}
	}


int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
	{
		if (FIPS_mode())
			return PEM_write_bio_PKCS8PrivateKey(bp, x, enc,
						(char *)kstr, klen, cb, u);
		else
                	return PEM_ASN1_write_bio((i2d_of_void *)i2d_PrivateKey,
			pkey_str(x), bp,(char *)x,enc,kstr,klen,cb,u);
	}

#ifndef OPENSSL_NO_FP_API
int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
	{
		if (FIPS_mode())
			return PEM_write_PKCS8PrivateKey(fp, x, enc,
						(char *)kstr, klen, cb, u);
		else
                	return PEM_ASN1_write((i2d_of_void *)i2d_PrivateKey,
			pkey_str(x), fp,(char *)x,enc,kstr,klen,cb,u);
	}
#endif

#else
a305 2

#endif
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@d113 1
d197 39
d237 3
d266 35
a300 1
	return pkey_get_dsa(pktmp, dsa);	/* will free pktmp */
d302 3
d307 3
d319 1
a319 1
	return pkey_get_dsa(pktmp, dsa);	/* will free pktmp */
d350 1
a350 1
	return pkey_get_eckey(pktmp, key);	/* will free pktmp */
d355 39
d396 2
d407 1
a407 1
	return pkey_get_eckey(pktmp, eckey);	/* will free pktmp */
d420 61
d482 1
@


1.1.1.7
log
@Import OpenSSL 1.0.1g
@
text
@a195 51
#ifdef OPENSSL_FIPS

int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_RSA(k, x);

		ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSAPrivateKey,
					PEM_STRING_RSA,bp,x,enc,kstr,klen,cb,u);
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;

		EVP_PKEY_set1_RSA(k, x);

		ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write((i2d_of_void *)i2d_RSAPrivateKey,
					PEM_STRING_RSA,fp,x,enc,kstr,klen,cb,u);
}
#endif

#else

a196 3

#endif

a225 49
#ifdef OPENSSL_FIPS

int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_DSA(k, x);

		ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAPrivateKey,
					PEM_STRING_DSA,bp,x,enc,kstr,klen,cb,u);
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_DSA(k, x);
		ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write((i2d_of_void *)i2d_DSAPrivateKey,
					PEM_STRING_DSA,fp,x,enc,kstr,klen,cb,u);
}
#endif

#else

a226 3

#endif

a271 53


#ifdef OPENSSL_FIPS

int PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_EC_KEY(k, x);

		ret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPrivateKey,
						PEM_STRING_ECPRIVATEKEY,
						bp,x,enc,kstr,klen,cb,u);
}

#ifndef OPENSSL_NO_FP_API
int PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc,
                                               unsigned char *kstr, int klen,
                                               pem_password_cb *cb, void *u)
{
	if (FIPS_mode())
		{
		EVP_PKEY *k;
		int ret;
		k = EVP_PKEY_new();
		if (!k)
			return 0;
		EVP_PKEY_set1_EC_KEY(k, x);
		ret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);
		EVP_PKEY_free(k);
		return ret;
		}
	else
		return PEM_ASN1_write((i2d_of_void *)i2d_ECPrivateKey,
						PEM_STRING_ECPRIVATEKEY,
						fp,x,enc,kstr,klen,cb,u);
}
#endif

#else

a272 2

#endif
@


