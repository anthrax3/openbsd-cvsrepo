head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18;
locks; strict;
comment	@ * @;


1.18
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.17;
commitid	kT0fLt3r4lroFJra;

1.17
date	2017.01.21.09.38.59;	author beck;	state Exp;
branches;
next	1.16;
commitid	iyR9b2itDMsxzmrQ;

1.16
date	2016.03.02.14.28.14;	author beck;	state Exp;
branches;
next	1.15;
commitid	l0752uIyfOSbKxfw;

1.15
date	2016.03.02.05.02.35;	author beck;	state Exp;
branches;
next	1.14;
commitid	GNjxohCrH4y5DOeQ;

1.14
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.13;
commitid	vHznCDK3idwNEFz4;

1.13
date	2015.05.15.11.00.14;	author jsg;	state Exp;
branches;
next	1.12;
commitid	DVhfXEEmSZcth64F;

1.12
date	2014.10.22.13.02.04;	author jsing;	state Exp;
branches;
next	1.11;
commitid	PjnBgKe6Buhbf937;

1.11
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.10;
commitid	G74O1dmRukKsW7IJ;

1.10
date	2014.07.11.15.35.53;	author miod;	state Exp;
branches;
next	1.9;
commitid	cxrnTzvuLpL2Vfy9;

1.9
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.8;
commitid	yQEL1wOWIearrW15;

1.8
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.7;
commitid	nzndm3zqPmFurSaK;

1.7
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.6;
commitid	id8dTrTMtnTn4fqt;

1.6
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	mJUVYpkFBZ0Zv2bG;

1.5
date	2014.05.22.21.12.16;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2014.04.21.15.39.52;	author jsing;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.17.17.30.22;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2011.11.03.02.32.12;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.10.13.21.23.42;	author djm;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: pvkfmt.c,v 1.17 2017/01/21 09:38:59 beck Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2005.
 */
/* ====================================================================
 * Copyright (c) 2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

/* Support for PVK format keys and related structures (such a PUBLICKEYBLOB
 * and PRIVATEKEYBLOB).
 */

#include <stdlib.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/pem.h>

#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DSA)
#include <openssl/dsa.h>
#include <openssl/rsa.h>

#include "bn_lcl.h"

/* Utility function: read a DWORD (4 byte unsigned integer) in little endian
 * format
 */

static unsigned int
read_ledword(const unsigned char **in)
{
	const unsigned char *p = *in;
	unsigned int ret;

	ret = *p++;
	ret |= (*p++ << 8);
	ret |= (*p++ << 16);
	ret |= (*p++ << 24);
	*in = p;
	return ret;
}

/* Read a BIGNUM in little endian format. The docs say that this should take up
 * bitlen/8 bytes.
 */

static int
read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
{
	const unsigned char *p;
	unsigned char *tmpbuf, *q;
	unsigned int i;

	p = *in + nbyte - 1;
	tmpbuf = malloc(nbyte);
	if (!tmpbuf)
		return 0;
	q = tmpbuf;
	for (i = 0; i < nbyte; i++)
		*q++ = *p--;
	*r = BN_bin2bn(tmpbuf, nbyte, NULL);
	free(tmpbuf);
	if (*r) {
		*in += nbyte;
		return 1;
	} else
		return 0;
}


/* Convert private key blob to EVP_PKEY: RSA and DSA keys supported */

#define MS_PUBLICKEYBLOB	0x6
#define MS_PRIVATEKEYBLOB	0x7
#define MS_RSA1MAGIC		0x31415352L
#define MS_RSA2MAGIC		0x32415352L
#define MS_DSS1MAGIC		0x31535344L
#define MS_DSS2MAGIC		0x32535344L

#define MS_KEYALG_RSA_KEYX	0xa400
#define MS_KEYALG_DSS_SIGN	0x2200

#define MS_KEYTYPE_KEYX		0x1
#define MS_KEYTYPE_SIGN		0x2

/* The PVK file magic number: seems to spell out "bobsfile", who is Bob? */
#define MS_PVKMAGIC		0xb0b5f11eL
/* Salt length for PVK files */
#define PVK_SALTLEN		0x10

static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
    unsigned int bitlen, int ispub);
static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
    unsigned int bitlen, int ispub);

static int
do_blob_header(const unsigned char **in, unsigned int length,
    unsigned int *pmagic, unsigned int *pbitlen, int *pisdss, int *pispub)
{
	const unsigned char *p = *in;

	if (length < 16)
		return 0;
	/* bType */
	if (*p == MS_PUBLICKEYBLOB) {
		if (*pispub == 0) {
			PEMerror(PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
			return 0;
		}
		*pispub = 1;
	} else if (*p == MS_PRIVATEKEYBLOB) {
		if (*pispub == 1) {
			PEMerror(PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
			return 0;
		}
		*pispub = 0;
	} else
		return 0;
	p++;
	/* Version */
	if (*p++ != 0x2) {
		PEMerror(PEM_R_BAD_VERSION_NUMBER);
		return 0;
	}
	/* Ignore reserved, aiKeyAlg */
	p += 6;
	*pmagic = read_ledword(&p);
	*pbitlen = read_ledword(&p);
	if (*pbitlen > 65536) {
		PEMerror(PEM_R_INCONSISTENT_HEADER);
		return 0;
	}
	*pisdss = 0;
	switch (*pmagic) {

	case MS_DSS1MAGIC:
		*pisdss = 1;
	case MS_RSA1MAGIC:
		if (*pispub == 0) {
			PEMerror(PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
			return 0;
		}
		break;

	case MS_DSS2MAGIC:
		*pisdss = 1;
	case MS_RSA2MAGIC:
		if (*pispub == 1) {
			PEMerror(PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
			return 0;
		}
		break;

	default:
		PEMerror(PEM_R_BAD_MAGIC_NUMBER);
		return -1;
	}
	*in = p;
	return 1;
}

static unsigned int
blob_length(unsigned bitlen, int isdss, int ispub)
{
	unsigned int nbyte, hnbyte;

	nbyte = (bitlen + 7) >> 3;
	hnbyte = (bitlen + 15) >> 4;
	if (isdss) {

		/* Expected length: 20 for q + 3 components bitlen each + 24
		 * for seed structure.
		 */
		if (ispub)
			return 44 + 3 * nbyte;
		/* Expected length: 20 for q, priv, 2 bitlen components + 24
		 * for seed structure.
		 */
		else
			return 64 + 2 * nbyte;
	} else {
		/* Expected length: 4 for 'e' + 'n' */
		if (ispub)
			return 4 + nbyte;
		else
		/* Expected length: 4 for 'e' and 7 other components.
		 * 2 components are bitlen size, 5 are bitlen/2
		 */
				return 4 + 2*nbyte + 5*hnbyte;
	}

}

static EVP_PKEY *
do_b2i(const unsigned char **in, unsigned int length, int ispub)
{
	const unsigned char *p = *in;
	unsigned int bitlen, magic;
	int isdss;

	if (do_blob_header(&p, length, &magic, &bitlen, &isdss, &ispub) <= 0) {
		PEMerror(PEM_R_KEYBLOB_HEADER_PARSE_ERROR);
		return NULL;
	}
	length -= 16;
	if (length < blob_length(bitlen, isdss, ispub)) {
		PEMerror(PEM_R_KEYBLOB_TOO_SHORT);
		return NULL;
	}
	if (isdss)
		return b2i_dss(&p, length, bitlen, ispub);
	else
		return b2i_rsa(&p, length, bitlen, ispub);
}

static EVP_PKEY *
do_b2i_bio(BIO *in, int ispub)
{
	const unsigned char *p;
	unsigned char hdr_buf[16], *buf = NULL;
	unsigned int bitlen, magic, length;
	int isdss;
	EVP_PKEY *ret = NULL;

	if (BIO_read(in, hdr_buf, 16) != 16) {
		PEMerror(PEM_R_KEYBLOB_TOO_SHORT);
		return NULL;
	}
	p = hdr_buf;
	if (do_blob_header(&p, 16, &magic, &bitlen, &isdss, &ispub) <= 0)
		return NULL;

	length = blob_length(bitlen, isdss, ispub);
	buf = malloc(length);
	if (!buf) {
		PEMerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	p = buf;
	if (BIO_read(in, buf, length) != (int)length) {
		PEMerror(PEM_R_KEYBLOB_TOO_SHORT);
		goto err;
	}

	if (isdss)
		ret = b2i_dss(&p, length, bitlen, ispub);
	else
		ret = b2i_rsa(&p, length, bitlen, ispub);

err:
	free(buf);
	return ret;
}

static EVP_PKEY *
b2i_dss(const unsigned char **in, unsigned int length, unsigned int bitlen,
    int ispub)
{
	const unsigned char *p = *in;
	EVP_PKEY *ret = NULL;
	DSA *dsa = NULL;
	BN_CTX *ctx = NULL;
	unsigned int nbyte;

	nbyte = (bitlen + 7) >> 3;

	dsa = DSA_new();
	ret = EVP_PKEY_new();
	if (!dsa || !ret)
		goto memerr;
	if (!read_lebn(&p, nbyte, &dsa->p))
		goto memerr;
	if (!read_lebn(&p, 20, &dsa->q))
		goto memerr;
	if (!read_lebn(&p, nbyte, &dsa->g))
		goto memerr;
	if (ispub) {
		if (!read_lebn(&p, nbyte, &dsa->pub_key))
			goto memerr;
	} else {
		if (!read_lebn(&p, 20, &dsa->priv_key))
			goto memerr;
		/* Calculate public key */
		if (!(dsa->pub_key = BN_new()))
			goto memerr;
		if (!(ctx = BN_CTX_new()))
			goto memerr;
		if (!BN_mod_exp_ct(dsa->pub_key, dsa->g,
		    dsa->priv_key, dsa->p, ctx))
			goto memerr;
		BN_CTX_free(ctx);
	}

	EVP_PKEY_set1_DSA(ret, dsa);
	DSA_free(dsa);
	*in = p;
	return ret;

memerr:
	PEMerror(ERR_R_MALLOC_FAILURE);
	DSA_free(dsa);
	EVP_PKEY_free(ret);
	BN_CTX_free(ctx);
	return NULL;
}

static EVP_PKEY *
b2i_rsa(const unsigned char **in, unsigned int length, unsigned int bitlen,
    int ispub)
{
	const unsigned char *p = *in;
	EVP_PKEY *ret = NULL;
	RSA *rsa = NULL;
	unsigned int nbyte, hnbyte;

	nbyte = (bitlen + 7) >> 3;
	hnbyte = (bitlen + 15) >> 4;
	rsa = RSA_new();
	ret = EVP_PKEY_new();
	if (!rsa || !ret)
		goto memerr;
	rsa->e = BN_new();
	if (!rsa->e)
		goto memerr;
	if (!BN_set_word(rsa->e, read_ledword(&p)))
		goto memerr;
	if (!read_lebn(&p, nbyte, &rsa->n))
		goto memerr;
	if (!ispub) {
		if (!read_lebn(&p, hnbyte, &rsa->p))
			goto memerr;
		if (!read_lebn(&p, hnbyte, &rsa->q))
			goto memerr;
		if (!read_lebn(&p, hnbyte, &rsa->dmp1))
			goto memerr;
		if (!read_lebn(&p, hnbyte, &rsa->dmq1))
			goto memerr;
		if (!read_lebn(&p, hnbyte, &rsa->iqmp))
			goto memerr;
		if (!read_lebn(&p, nbyte, &rsa->d))
			goto memerr;
	}

	EVP_PKEY_set1_RSA(ret, rsa);
	RSA_free(rsa);
	*in = p;
	return ret;

memerr:
	PEMerror(ERR_R_MALLOC_FAILURE);
	RSA_free(rsa);
	EVP_PKEY_free(ret);
	return NULL;
}

EVP_PKEY *
b2i_PrivateKey(const unsigned char **in, long length)
{
	return do_b2i(in, length, 0);
}

EVP_PKEY *
b2i_PublicKey(const unsigned char **in, long length)
{
	return do_b2i(in, length, 1);
}

EVP_PKEY *
b2i_PrivateKey_bio(BIO *in)
{
	return do_b2i_bio(in, 0);
}

EVP_PKEY *
b2i_PublicKey_bio(BIO *in)
{
	return do_b2i_bio(in, 1);
}

static void
write_ledword(unsigned char **out, unsigned int dw)
{
	unsigned char *p = *out;

	*p++ = dw & 0xff;
	*p++ = (dw >> 8) & 0xff;
	*p++ = (dw >> 16) & 0xff;
	*p++ = (dw >> 24) & 0xff;
	*out = p;
}

static void
write_lebn(unsigned char **out, const BIGNUM *bn, int len)
{
	int nb, i;
	unsigned char *p = *out, *q, c;

	nb = BN_num_bytes(bn);
	BN_bn2bin(bn, p);
	q = p + nb - 1;
	/* In place byte order reversal */
	for (i = 0; i < nb / 2; i++) {
		c = *p;
		*p++ = *q;
		*q-- = c;
	}
	*out += nb;
	/* Pad with zeroes if we have to */
	if (len > 0) {
		len -= nb;
		if (len > 0) {
			memset(*out, 0, len);
			*out += len;
		}
	}
}


static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *magic);
static int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *magic);

static void write_rsa(unsigned char **out, RSA *rsa, int ispub);
static void write_dsa(unsigned char **out, DSA *dsa, int ispub);

static int
do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)
{
	unsigned char *p;
	unsigned int bitlen, magic = 0, keyalg;
	int outlen, noinc = 0;

	if (pk->type == EVP_PKEY_DSA) {
		bitlen = check_bitlen_dsa(pk->pkey.dsa, ispub, &magic);
		keyalg = MS_KEYALG_DSS_SIGN;
	} else if (pk->type == EVP_PKEY_RSA) {
		bitlen = check_bitlen_rsa(pk->pkey.rsa, ispub, &magic);
		keyalg = MS_KEYALG_RSA_KEYX;
	} else
		return -1;
	if (bitlen == 0)
		return -1;
	outlen = 16 + blob_length(bitlen,
	    keyalg == MS_KEYALG_DSS_SIGN ? 1 : 0, ispub);
	if (out == NULL)
		return outlen;
	if (*out)
		p = *out;
	else {
		p = malloc(outlen);
		if (!p)
			return -1;
		*out = p;
		noinc = 1;
	}
	if (ispub)
		*p++ = MS_PUBLICKEYBLOB;
	else
		*p++ = MS_PRIVATEKEYBLOB;
	*p++ = 0x2;
	*p++ = 0;
	*p++ = 0;
	write_ledword(&p, keyalg);
	write_ledword(&p, magic);
	write_ledword(&p, bitlen);
	if (keyalg == MS_KEYALG_DSS_SIGN)
		write_dsa(&p, pk->pkey.dsa, ispub);
	else
		write_rsa(&p, pk->pkey.rsa, ispub);
	if (!noinc)
		*out += outlen;
	return outlen;
}

static int
do_i2b_bio(BIO *out, EVP_PKEY *pk, int ispub)
{
	unsigned char *tmp = NULL;
	int outlen, wrlen;

	outlen = do_i2b(&tmp, pk, ispub);
	if (outlen < 0)
		return -1;
	wrlen = BIO_write(out, tmp, outlen);
	free(tmp);
	if (wrlen == outlen)
		return outlen;
	return -1;
}

static int
check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *pmagic)
{
	int bitlen;

	bitlen = BN_num_bits(dsa->p);
	if ((bitlen & 7) || (BN_num_bits(dsa->q) != 160) ||
	    (BN_num_bits(dsa->g) > bitlen))
		goto badkey;
	if (ispub) {
		if (BN_num_bits(dsa->pub_key) > bitlen)
			goto badkey;
		*pmagic = MS_DSS1MAGIC;
	} else {
		if (BN_num_bits(dsa->priv_key) > 160)
			goto badkey;
		*pmagic = MS_DSS2MAGIC;
	}

	return bitlen;

badkey:
	PEMerror(PEM_R_UNSUPPORTED_KEY_COMPONENTS);
	return 0;
}

static int
check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
{
	int nbyte, hnbyte, bitlen;

	if (BN_num_bits(rsa->e) > 32)
		goto badkey;
	bitlen = BN_num_bits(rsa->n);
	nbyte = BN_num_bytes(rsa->n);
	hnbyte = (BN_num_bits(rsa->n) + 15) >> 4;
	if (ispub) {
		*pmagic = MS_RSA1MAGIC;
		return bitlen;
	} else {
		*pmagic = MS_RSA2MAGIC;
		/* For private key each component must fit within nbyte or
		 * hnbyte.
		 */
		if (BN_num_bytes(rsa->d) > nbyte)
			goto badkey;
		if ((BN_num_bytes(rsa->iqmp) > hnbyte) ||
		    (BN_num_bytes(rsa->p) > hnbyte) ||
		    (BN_num_bytes(rsa->q) > hnbyte) ||
		    (BN_num_bytes(rsa->dmp1) > hnbyte) ||
		    (BN_num_bytes(rsa->dmq1) > hnbyte))
			goto badkey;
	}
	return bitlen;

badkey:
	PEMerror(PEM_R_UNSUPPORTED_KEY_COMPONENTS);
	return 0;
}

static void
write_rsa(unsigned char **out, RSA *rsa, int ispub)
{
	int nbyte, hnbyte;

	nbyte = BN_num_bytes(rsa->n);
	hnbyte = (BN_num_bits(rsa->n) + 15) >> 4;
	write_lebn(out, rsa->e, 4);
	write_lebn(out, rsa->n, -1);
	if (ispub)
		return;
	write_lebn(out, rsa->p, hnbyte);
	write_lebn(out, rsa->q, hnbyte);
	write_lebn(out, rsa->dmp1, hnbyte);
	write_lebn(out, rsa->dmq1, hnbyte);
	write_lebn(out, rsa->iqmp, hnbyte);
	write_lebn(out, rsa->d, nbyte);
}

static void
write_dsa(unsigned char **out, DSA *dsa, int ispub)
{
	int nbyte;

	nbyte = BN_num_bytes(dsa->p);
	write_lebn(out, dsa->p, nbyte);
	write_lebn(out, dsa->q, 20);
	write_lebn(out, dsa->g, nbyte);
	if (ispub)
		write_lebn(out, dsa->pub_key, nbyte);
	else
		write_lebn(out, dsa->priv_key, 20);
	/* Set "invalid" for seed structure values */
	memset(*out, 0xff, 24);
	*out += 24;
	return;
}

int
i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk)
{
	return do_i2b_bio(out, pk, 0);
}

int
i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk)
{
	return do_i2b_bio(out, pk, 1);
}

#ifndef OPENSSL_NO_RC4

static int
do_PVK_header(const unsigned char **in, unsigned int length, int skip_magic,
    unsigned int *psaltlen, unsigned int *pkeylen)
{
	const unsigned char *p = *in;
	unsigned int pvk_magic, is_encrypted;

	if (skip_magic) {
		if (length < 20) {
			PEMerror(PEM_R_PVK_TOO_SHORT);
			return 0;
		}
		length -= 20;
	} else {
		if (length < 24) {
			PEMerror(PEM_R_PVK_TOO_SHORT);
			return 0;
		}
		length -= 24;
		pvk_magic = read_ledword(&p);
		if (pvk_magic != MS_PVKMAGIC) {
			PEMerror(PEM_R_BAD_MAGIC_NUMBER);
			return 0;
		}
	}
	/* Skip reserved */
	p += 4;
	/*keytype = */read_ledword(&p);
	is_encrypted = read_ledword(&p);
	*psaltlen = read_ledword(&p);
	*pkeylen = read_ledword(&p);
	if (*psaltlen > 65536 || *pkeylen > 65536) {
		PEMerror(PEM_R_ERROR_CONVERTING_PRIVATE_KEY);
		return 0;
	}

	if (is_encrypted && !*psaltlen) {
		PEMerror(PEM_R_INCONSISTENT_HEADER);
		return 0;
	}

	*in = p;
	return 1;
}

static int
derive_pvk_key(unsigned char *key, const unsigned char *salt,
    unsigned int saltlen, const unsigned char *pass, int passlen)
{
	EVP_MD_CTX mctx;
	int rv = 1;

	EVP_MD_CTX_init(&mctx);
	if (!EVP_DigestInit_ex(&mctx, EVP_sha1(), NULL) ||
	    !EVP_DigestUpdate(&mctx, salt, saltlen) ||
	    !EVP_DigestUpdate(&mctx, pass, passlen) ||
	    !EVP_DigestFinal_ex(&mctx, key, NULL))
		rv = 0;

	EVP_MD_CTX_cleanup(&mctx);
	return rv;
}

static EVP_PKEY *
do_PVK_body(const unsigned char **in, unsigned int saltlen,
    unsigned int keylen, pem_password_cb *cb, void *u)
{
	EVP_PKEY *ret = NULL;
	const unsigned char *p = *in;
	unsigned int magic;
	unsigned char *enctmp = NULL, *q;
	EVP_CIPHER_CTX cctx;

	EVP_CIPHER_CTX_init(&cctx);
	if (saltlen) {
		char psbuf[PEM_BUFSIZE];
		unsigned char keybuf[20];
		int enctmplen, inlen;

		if (cb)
			inlen = cb(psbuf, PEM_BUFSIZE, 0, u);
		else
			inlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
		if (inlen <= 0) {
			PEMerror(PEM_R_BAD_PASSWORD_READ);
			goto err;
		}
		enctmp = malloc(keylen + 8);
		if (!enctmp) {
			PEMerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (!derive_pvk_key(keybuf, p, saltlen, (unsigned char *)psbuf,
		    inlen)) {
			goto err;
		}
		p += saltlen;
		/* Copy BLOBHEADER across, decrypt rest */
		memcpy(enctmp, p, 8);
		p += 8;
		if (keylen < 8) {
			PEMerror(PEM_R_PVK_TOO_SHORT);
			goto err;
		}
		inlen = keylen - 8;
		q = enctmp + 8;
		if (!EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf, NULL))
			goto err;
		if (!EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen))
			goto err;
		if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen, &enctmplen))
			goto err;
		magic = read_ledword((const unsigned char **)&q);
		if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC) {
			q = enctmp + 8;
			memset(keybuf + 5, 0, 11);
			if (!EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf,
			    NULL))
				goto err;
			explicit_bzero(keybuf, 20);
			if (!EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen))
				goto err;
			if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen,
			    &enctmplen))
				goto err;
			magic = read_ledword((const unsigned char **)&q);
			if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC) {
				PEMerror(PEM_R_BAD_DECRYPT);
				goto err;
			}
		} else
			explicit_bzero(keybuf, 20);
		p = enctmp;
	}

	ret = b2i_PrivateKey(&p, keylen);

err:
	EVP_CIPHER_CTX_cleanup(&cctx);
	if (enctmp && saltlen)
		free(enctmp);
	return ret;
}


EVP_PKEY *
b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u)
{
	unsigned char pvk_hdr[24], *buf = NULL;
	const unsigned char *p;
	size_t buflen;
	EVP_PKEY *ret = NULL;
	unsigned int saltlen, keylen;

	if (BIO_read(in, pvk_hdr, 24) != 24) {
		PEMerror(PEM_R_PVK_DATA_TOO_SHORT);
		return NULL;
	}
	p = pvk_hdr;

	if (!do_PVK_header(&p, 24, 0, &saltlen, &keylen))
		return 0;
	buflen = keylen + saltlen;
	buf = malloc(buflen);
	if (!buf) {
		PEMerror(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	p = buf;
	if (BIO_read(in, buf, buflen) != buflen) {
		PEMerror(PEM_R_PVK_DATA_TOO_SHORT);
		goto err;
	}
	ret = do_PVK_body(&p, saltlen, keylen, cb, u);

err:
	if (buf) {
		explicit_bzero(buf, buflen);
		free(buf);
	}
	return ret;
}

static int
i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel, pem_password_cb *cb,
    void *u)
{
	int outlen = 24, pklen;
	unsigned char *p, *salt = NULL;
	EVP_CIPHER_CTX cctx;

	EVP_CIPHER_CTX_init(&cctx);
	if (enclevel)
		outlen += PVK_SALTLEN;
	pklen = do_i2b(NULL, pk, 0);
	if (pklen < 0)
		return -1;
	outlen += pklen;
	if (!out)
		return outlen;
	if (*out)
		p = *out;
	else {
		p = malloc(outlen);
		if (!p) {
			PEMerror(ERR_R_MALLOC_FAILURE);
			return -1;
		}
		*out = p;
	}

	write_ledword(&p, MS_PVKMAGIC);
	write_ledword(&p, 0);
	if (pk->type == EVP_PKEY_DSA)
		write_ledword(&p, MS_KEYTYPE_SIGN);
	else
		write_ledword(&p, MS_KEYTYPE_KEYX);
	write_ledword(&p, enclevel ? 1 : 0);
	write_ledword(&p, enclevel ? PVK_SALTLEN : 0);
	write_ledword(&p, pklen);
	if (enclevel) {
		arc4random_buf(p, PVK_SALTLEN);
		salt = p;
		p += PVK_SALTLEN;
	}
	do_i2b(&p, pk, 0);
	if (enclevel == 0)
		return outlen;
	else {
		char psbuf[PEM_BUFSIZE];
		unsigned char keybuf[20];
		int enctmplen, inlen;
		if (cb)
			inlen = cb(psbuf, PEM_BUFSIZE, 1, u);
		else
			inlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 1, u);
		if (inlen <= 0) {
			PEMerror(PEM_R_BAD_PASSWORD_READ);
			goto error;
		}
		if (!derive_pvk_key(keybuf, salt, PVK_SALTLEN,
		    (unsigned char *)psbuf, inlen))
			goto error;
		if (enclevel == 1)
			memset(keybuf + 5, 0, 11);
		p = salt + PVK_SALTLEN + 8;
		if (!EVP_EncryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf, NULL))
			goto error;
		explicit_bzero(keybuf, 20);
		if (!EVP_DecryptUpdate(&cctx, p, &enctmplen, p, pklen - 8))
			goto error;
		if (!EVP_DecryptFinal_ex(&cctx, p + enctmplen, &enctmplen))
			goto error;
	}
	EVP_CIPHER_CTX_cleanup(&cctx);
	return outlen;

error:
	EVP_CIPHER_CTX_cleanup(&cctx);
	return -1;
}

int
i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel, pem_password_cb *cb, void *u)
{
	unsigned char *tmp = NULL;
	int outlen, wrlen;

	outlen = i2b_PVK(&tmp, pk, enclevel, cb, u);
	if (outlen < 0)
		return -1;
	wrlen = BIO_write(out, tmp, outlen);
	free(tmp);
	if (wrlen == outlen) {
		PEMerror(PEM_R_BIO_WRITE_FAILURE);
		return outlen;
	}
	return -1;
}

#endif

#endif
@


1.17
log
@Make explicit _ct and _nonct versions of bn_mod_exp funcitons that
matter for constant time, and make the public interface only used
external to the library.

This moves us to a model where the important things are constant time
versions unless you ask for them not to be, rather than the opposite.
I'll continue with this method by method.

Add regress tests for same.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.16 2016/03/02 14:28:14 beck Exp $ */
d160 1
a160 2
			PEMerr(PEM_F_DO_BLOB_HEADER,
			    PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
d166 1
a166 2
			PEMerr(PEM_F_DO_BLOB_HEADER,
			    PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
d175 1
a175 1
		PEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_BAD_VERSION_NUMBER);
d183 1
a183 1
		PEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_INCONSISTENT_HEADER);
d193 1
a193 2
			PEMerr(PEM_F_DO_BLOB_HEADER,
			    PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
d202 1
a202 2
			PEMerr(PEM_F_DO_BLOB_HEADER,
			    PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
d208 1
a208 1
		PEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_BAD_MAGIC_NUMBER);
d255 1
a255 1
		PEMerr(PEM_F_DO_B2I, PEM_R_KEYBLOB_HEADER_PARSE_ERROR);
d260 1
a260 1
		PEMerr(PEM_F_DO_B2I, PEM_R_KEYBLOB_TOO_SHORT);
d279 1
a279 1
		PEMerr(PEM_F_DO_B2I_BIO, PEM_R_KEYBLOB_TOO_SHORT);
d289 1
a289 1
		PEMerr(PEM_F_DO_B2I_BIO, ERR_R_MALLOC_FAILURE);
d294 1
a294 1
		PEMerr(PEM_F_DO_B2I_BIO, PEM_R_KEYBLOB_TOO_SHORT);
d353 1
a353 1
	PEMerr(PEM_F_B2I_DSS, ERR_R_MALLOC_FAILURE);
d403 1
a403 1
	PEMerr(PEM_F_B2I_RSA, ERR_R_MALLOC_FAILURE);
d565 1
a565 1
	PEMerr(PEM_F_CHECK_BITLEN_DSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
d599 1
a599 1
	PEMerr(PEM_F_CHECK_BITLEN_RSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
d664 1
a664 1
			PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);
d670 1
a670 1
			PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);
d676 1
a676 1
			PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_BAD_MAGIC_NUMBER);
d687 1
a687 1
		PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_ERROR_CONVERTING_PRIVATE_KEY);
d692 1
a692 1
		PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_INCONSISTENT_HEADER);
d739 1
a739 1
			PEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_PASSWORD_READ);
d744 1
a744 1
			PEMerr(PEM_F_DO_PVK_BODY, ERR_R_MALLOC_FAILURE);
d756 1
a756 1
			PEMerr(PEM_F_DO_PVK_BODY, PEM_R_PVK_TOO_SHORT);
d782 1
a782 1
				PEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_DECRYPT);
d810 1
a810 1
		PEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);
d820 1
a820 1
		PEMerr(PEM_F_B2I_PVK_BIO, ERR_R_MALLOC_FAILURE);
d825 1
a825 1
		PEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);
d860 1
a860 1
			PEMerr(PEM_F_I2B_PVK, ERR_R_MALLOC_FAILURE);
d892 1
a892 1
			PEMerr(PEM_F_I2B_PVK, PEM_R_BAD_PASSWORD_READ);
d929 1
a929 1
		PEMerr(PEM_F_I2B_PVK_BIO, PEM_R_BIO_WRITE_FAILURE);
@


1.16
log
@fix the rest of the read_ledword() calls used as lengths to be bounded.
inspired by guido vranken https://guidovranken.wordpress.com/2016/03/01/public-disclosure-malformed-private-keys-lead-to-heap-corruption-in-b2i_pvk_bio/
ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.15 2016/03/02 05:02:35 beck Exp $ */
d76 2
d345 1
a345 1
		if (!BN_mod_exp(dsa->pub_key, dsa->g,
@


1.15
log
@bound lengths coming out of a pem file to something like reality
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.14 2015/09/10 15:56:25 jsing Exp $ */
d182 4
@


1.14
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.13 2015/05/15 11:00:14 jsg Exp $ */
d684 4
d803 1
a803 1
	int buflen;
d815 1
a815 1
	buflen = (int) keylen + saltlen;
@


1.13
log
@Fix return paths with missing EVP_CIPHER_CTX_cleanup() calls.
ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.12 2014/10/22 13:02:04 jsing Exp $ */
d768 1
a768 1
			OPENSSL_cleanse(keybuf, 20);
d780 1
a780 1
			OPENSSL_cleanse(keybuf, 20);
d826 1
a826 1
		OPENSSL_cleanse(buf, buflen);
d897 1
a897 1
		OPENSSL_cleanse(keybuf, 20);
@


1.12
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.11 2014/07/12 16:03:37 miod Exp $ */
d734 1
a734 1
			return NULL;
d739 1
a739 1
			return NULL;
d743 1
a743 2
			free(enctmp);
			return NULL;
d751 1
a751 2
			free(enctmp);
			return NULL;
@


1.11
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.10 2014/07/11 15:35:53 miod Exp $ */
d63 1
a70 1
#include <openssl/rand.h>
d872 1
a872 2
		if (RAND_bytes(p, PVK_SALTLEN) <= 0)
			goto error;
@


1.10
log
@Missing bounds check in do_PVK_body(); OpenSSL RT #2277, from OpenSSL trunk,
but without a memory leak.
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.9 2014/07/11 08:44:49 jsing Exp $ */
d352 3
a354 6
	if (dsa)
		DSA_free(dsa);
	if (ret)
		EVP_PKEY_free(ret);
	if (ctx)
		BN_CTX_free(ctx);
d402 2
a403 4
	if (rsa)
		RSA_free(rsa);
	if (ret)
		EVP_PKEY_free(ret);
@


1.9
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.8 2014/07/10 22:45:57 jsing Exp $ */
d725 1
a726 1
	EVP_CIPHER_CTX cctx;
d732 1
d746 2
a747 2
		if (!derive_pvk_key(keybuf, p, saltlen,
			    (unsigned char *)psbuf, inlen)) {
d755 5
@


1.8
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.7 2014/07/10 13:58:23 jsing Exp $ */
d67 2
a68 1
#include "cryptlib.h"
d71 1
a71 1
#include <openssl/bn.h>
@


1.7
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pvkfmt.c,v 1.6 2014/06/12 15:49:30 deraadt Exp $ */
d64 2
@


1.6
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d62 2
@


1.5
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d1 1
@


1.4
log
@KNF.
@
text
@d296 1
a296 2
	if (buf)
		free(buf);
@


1.3
log
@fix some of the leaks
ok miod@@ looks good deraadt@@
@
text
@d12 1
a12 1
 *    notice, this list of conditions and the following disclaimer. 
d74 3
a76 2
static unsigned int read_ledword(const unsigned char **in)
	{
d79 1
d86 1
a86 1
	}
d88 1
a88 1
/* Read a BIGNUM in little endian format. The docs say that this should take up 
d92 3
a94 2
static int read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
	{
d98 1
d108 1
a108 2
	if (*r)
		{
d111 1
a111 2
		}
	else
d113 1
a113 1
	}
d137 1
a137 1
						unsigned int bitlen, int ispub);
d139 1
a139 1
						unsigned int bitlen, int ispub);
d141 4
a144 4
static int do_blob_header(const unsigned char **in, unsigned int length,
				unsigned int *pmagic, unsigned int *pbitlen,
				int *pisdss, int *pispub)
	{
d146 1
d150 2
a151 4
	if (*p == MS_PUBLICKEYBLOB)
		{
		if (*pispub == 0)
			{
d153 1
a153 1
					PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
d155 1
a155 1
			}
d157 2
a158 5
		}
	else if (*p == MS_PRIVATEKEYBLOB)
		{
		if (*pispub == 1)
			{
d160 1
a160 1
					PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
d162 1
a162 1
			}
d164 1
a164 2
		}
	else
d168 1
a168 2
	if (*p++ != 0x2)
		{
d171 1
a171 1
		}
d173 1
a173 1
	p+= 6;
d177 1
a177 2
	switch (*pmagic)
		{
d179 1
a179 1
		case MS_DSS1MAGIC:
d181 2
a182 3
		case MS_RSA1MAGIC:
		if (*pispub == 0)
			{
d184 1
a184 1
					PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
d186 1
a186 1
			}
d189 1
a189 1
		case MS_DSS2MAGIC:
d191 2
a192 3
		case MS_RSA2MAGIC:
		if (*pispub == 1)
			{
d194 1
a194 1
					PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
d196 1
a196 1
			}
d199 1
a199 1
		default:
d202 1
a202 1
		}
d205 1
a205 1
	}
d207 3
a209 2
static unsigned int blob_length(unsigned bitlen, int isdss, int ispub)
	{
d211 1
d214 1
a214 2
	if (isdss)
		{
d220 1
a220 1
			return  44 + 3 * nbyte;
d226 1
a226 3
		}
	else
		{
d234 2
a235 2
			return 4 + 2*nbyte + 5*hnbyte;
		}
d237 1
a237 1
	}
d239 3
a241 3
static EVP_PKEY *do_b2i(const unsigned char **in, unsigned int length,
								int ispub)
	{
d245 2
a246 2
	if (do_blob_header(&p, length, &magic, &bitlen, &isdss, &ispub) <= 0)
		{
d249 1
a249 1
		}
d251 1
a251 2
	if (length < blob_length(bitlen, isdss, ispub))
		{
d254 1
a254 1
		}
d259 1
a259 1
	}
d261 3
a263 2
static EVP_PKEY *do_b2i_bio(BIO *in, int ispub)
	{
d269 2
a270 2
	if (BIO_read(in, hdr_buf, 16) != 16)
		{
d273 1
a273 1
		}
d280 1
a280 2
	if (!buf)
		{
d283 1
a283 1
		}
d285 1
a285 2
	if (BIO_read(in, buf, length) != (int)length)
		{
d288 1
a288 1
		}
d295 1
a295 1
	err:
d299 1
a299 1
	}
d301 4
a304 3
static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
						unsigned int bitlen, int ispub)
	{
d310 1
d323 1
a323 2
	if (ispub)
		{
d326 1
a326 3
		}
	else
		{
a333 1
			
d335 1
a335 2
						 dsa->priv_key, dsa->p, ctx))
			
d338 1
a338 1
		}
d345 1
a345 1
	memerr:
d354 1
a354 1
	}
d356 4
a359 4
static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
						unsigned int bitlen, int ispub)
		
	{
d364 1
d378 1
a378 2
	if (!ispub)
		{
d391 1
a391 1
		}
d397 2
a398 1
	memerr:
d405 1
a405 1
	}
d407 3
a409 2
EVP_PKEY *b2i_PrivateKey(const unsigned char **in, long length)
	{
d411 1
a411 1
	}
d413 3
a415 2
EVP_PKEY *b2i_PublicKey(const unsigned char **in, long length)
	{
d417 1
a417 1
	}
d419 3
a421 3

EVP_PKEY *b2i_PrivateKey_bio(BIO *in)
	{
d423 1
a423 1
	}
d425 3
a427 2
EVP_PKEY *b2i_PublicKey_bio(BIO *in)
	{
d429 1
a429 1
	}
d431 3
a433 2
static void write_ledword(unsigned char **out, unsigned int dw)
	{
d435 1
d437 3
a439 3
	*p++ = (dw>>8) & 0xff;
	*p++ = (dw>>16) & 0xff;
	*p++ = (dw>>24) & 0xff;
d441 1
a441 1
	}
d443 3
a445 2
static void write_lebn(unsigned char **out, const BIGNUM *bn, int len)
	{
d448 1
d453 1
a453 2
	for (i = 0; i < nb/2; i++)
		{
d457 1
a457 1
		}
d460 1
a460 2
	if (len > 0)
		{
d462 1
a462 2
		if (len > 0)
			{
a464 1
			}
d467 1
d475 4
a478 3
	
static int do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)
	{
d482 2
a483 2
	if (pk->type == EVP_PKEY_DSA)
		{
d486 1
a486 3
		}
	else if (pk->type == EVP_PKEY_RSA)
		{
d489 1
a489 2
		}
	else
d494 1
a494 1
			keyalg == MS_KEYALG_DSS_SIGN ? 1 : 0, ispub);
d499 1
a499 2
	else
		{
d505 1
a505 1
		}
d523 1
a523 1
	}
d525 3
a527 2
static int do_i2b_bio(BIO *out, EVP_PKEY *pk, int ispub)
	{
d530 1
d539 1
a539 1
	}
d541 3
a543 2
static int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *pmagic)
	{
d545 1
d547 2
a548 2
	if ((bitlen & 7) || (BN_num_bits(dsa->q) != 160)
		|| (BN_num_bits(dsa->g) > bitlen))
d550 1
a550 2
	if (ispub)
		{
d554 1
a554 3
		}
	else
		{
d558 2
a559 2
		}
	
d561 2
a562 1
	badkey:
d565 1
a565 1
	}
d567 3
a569 2
static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
	{
d571 1
d577 1
a577 2
	if (ispub)
		{
d580 1
a580 3
		}
	else
	{
d587 5
a591 5
		if ((BN_num_bytes(rsa->iqmp) > hnbyte)
			|| (BN_num_bytes(rsa->p) > hnbyte)
			|| (BN_num_bytes(rsa->q) > hnbyte)
			|| (BN_num_bytes(rsa->dmp1) > hnbyte)
			|| (BN_num_bytes(rsa->dmq1) > hnbyte))
d595 2
a596 1
	badkey:
d599 1
a599 1
	}
d601 4
a605 3
static void write_rsa(unsigned char **out, RSA *rsa, int ispub)
	{
	int nbyte, hnbyte;
d618 1
a618 1
	}
d620 3
a622 3
	
static void write_dsa(unsigned char **out, DSA *dsa, int ispub)
	{
d624 1
d637 1
a637 2
	}
	
d639 3
a641 2
int i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk)
	{
d643 1
a643 1
	}
d645 3
a647 2
int i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk)
	{
d649 1
a649 1
	}
d653 4
a656 5
static int do_PVK_header(const unsigned char **in, unsigned int length,
		int skip_magic,
	       	unsigned int *psaltlen, unsigned int *pkeylen)
		
	{
d659 3
a661 4
	if (skip_magic)
		{
		if (length < 20)
			{
d664 1
a664 1
			}
d666 2
a667 5
		}
	else
		{
		if (length < 24)
			{
d670 1
a670 1
			}
d673 1
a673 2
		if (pvk_magic != MS_PVKMAGIC)
			{
a675 1
			}
d677 1
d685 1
a685 2
	if (is_encrypted && !*psaltlen)
		{
d688 1
a688 1
		}
d692 1
a692 1
	}
d694 4
a697 4
static int derive_pvk_key(unsigned char *key, 
			const unsigned char *salt, unsigned int saltlen,
			const unsigned char *pass, int passlen)
	{
d700 1
d702 5
a706 5
	if (!EVP_DigestInit_ex(&mctx, EVP_sha1(), NULL)
		|| !EVP_DigestUpdate(&mctx, salt, saltlen)
		|| !EVP_DigestUpdate(&mctx, pass, passlen)
		|| !EVP_DigestFinal_ex(&mctx, key, NULL))
			rv = 0;
d710 1
a710 2
	}
	
d712 4
a715 4
static EVP_PKEY *do_PVK_body(const unsigned char **in,
		unsigned int saltlen, unsigned int keylen,
		pem_password_cb *cb, void *u)
	{
d720 1
d723 1
a723 2
	if (saltlen)
		{
d728 1
a728 1
			inlen=cb(psbuf,PEM_BUFSIZE,0,u);
d730 3
a732 4
			inlen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);
		if (inlen <= 0)
			{
			PEMerr(PEM_F_DO_PVK_BODY,PEM_R_BAD_PASSWORD_READ);
d734 1
a734 1
			}
d736 1
a736 2
		if (!enctmp)
			{
d739 1
a739 1
			}
d758 1
a758 2
		if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC)
			{
d762 1
a762 1
								NULL))
d768 1
a768 1
								&enctmplen))
d771 1
a771 2
			if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC)
				{
a773 1
				}
d775 1
a775 1
		else
d778 1
a778 1
		}
d781 2
a782 1
	err:
d787 1
a787 1
	}
d790 3
a792 2
EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u)
	{
d798 2
a799 2
	if (BIO_read(in, pvk_hdr, 24) != 24)
		{
d802 1
a802 1
		}
d809 1
a809 2
	if (!buf)
		{
d812 1
a812 1
		}
d814 1
a814 2
	if (BIO_read(in, buf, buflen) != buflen)
		{
d817 1
a817 1
		}
d820 2
a821 3
	err:
	if (buf)
		{
d824 1
a824 1
		}
d826 1
a826 1
	}
d828 4
a831 5
	
	
static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
		pem_password_cb *cb, void *u)
	{
d835 1
d847 1
a847 2
	else
		{
d849 2
a850 3
		if (!p)
			{
			PEMerr(PEM_F_I2B_PVK,ERR_R_MALLOC_FAILURE);
d852 1
a852 1
			}
d854 1
a854 1
		}
d863 1
a863 1
	write_ledword(&p, enclevel ? PVK_SALTLEN: 0);
d865 1
a865 2
	if (enclevel)
		{
d870 1
a870 1
		}
d874 1
a874 2
	else
		{
d879 1
a879 1
			inlen=cb(psbuf,PEM_BUFSIZE,1,u);
d881 3
a883 4
			inlen=PEM_def_callback(psbuf,PEM_BUFSIZE,1,u);
		if (inlen <= 0)
			{
			PEMerr(PEM_F_I2B_PVK,PEM_R_BAD_PASSWORD_READ);
d885 1
a885 1
			}
d887 1
a887 1
			    (unsigned char *)psbuf, inlen))
d899 1
a899 1
		}
d903 1
a903 1
	error:
d906 1
a906 1
	}
d908 3
a910 3
int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,
		pem_password_cb *cb, void *u)
	{
d913 1
d919 1
a919 2
	if (wrlen == outlen)
		{
d922 1
a922 1
		}
d924 1
a924 1
	}
@


1.2
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d756 2
a757 1
			    (unsigned char *)psbuf, inlen))
d759 1
@


1.1
log
@Initial revision
@
text
@d96 1
a96 1
	tmpbuf = OPENSSL_malloc(nbyte);
d103 1
a103 1
	OPENSSL_free(tmpbuf);
d287 1
a287 1
	buf = OPENSSL_malloc(length);
d307 1
a307 1
		OPENSSL_free(buf);
d511 1
a511 1
		p = OPENSSL_malloc(outlen);
d544 1
a544 1
	OPENSSL_free(tmp);
d665 1
a665 1
	unsigned int pvk_magic, keytype, is_encrypted;
d692 1
a692 1
	keytype = read_ledword(&p);
d712 1
d714 6
a719 4
	EVP_DigestInit_ex(&mctx, EVP_sha1(), NULL);
	EVP_DigestUpdate(&mctx, salt, saltlen);
	EVP_DigestUpdate(&mctx, pass, passlen);
	EVP_DigestFinal_ex(&mctx, key, NULL);
d721 1
a721 1
	return 1;
d733 2
a738 1
		EVP_CIPHER_CTX cctx;
d749 1
a749 1
		enctmp = OPENSSL_malloc(keylen + 8);
d764 6
a769 4
		EVP_CIPHER_CTX_init(&cctx);
		EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf, NULL);
		EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen);
		EVP_DecryptFinal_ex(&cctx, q + enctmplen, &enctmplen);
d775 3
a777 2
			EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf,
								NULL);
d779 5
a783 3
			EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen);
			EVP_DecryptFinal_ex(&cctx, q + enctmplen,
								&enctmplen);
a786 1
				EVP_CIPHER_CTX_cleanup(&cctx);
a792 1
		EVP_CIPHER_CTX_cleanup(&cctx);
d798 1
d800 1
a800 1
		OPENSSL_free(enctmp);
d822 1
a822 1
	buf = OPENSSL_malloc(buflen);
d840 1
a840 1
		OPENSSL_free(buf);
d850 1
a850 1
	int outlen = 24, noinc, pklen;
d852 2
a862 1
		{
a863 2
		noinc = 0;
		}
d866 1
a866 1
		p = OPENSSL_malloc(outlen);
a872 1
		noinc = 1;
a897 1
		EVP_CIPHER_CTX cctx;
d914 2
a915 2
		EVP_CIPHER_CTX_init(&cctx);
		EVP_EncryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf, NULL);
d917 4
a920 3
		EVP_DecryptUpdate(&cctx, p, &enctmplen, p, pklen - 8);
		EVP_DecryptFinal_ex(&cctx, p + enctmplen, &enctmplen);
		EVP_CIPHER_CTX_cleanup(&cctx);
d922 1
d926 1
d939 1
a939 1
	OPENSSL_free(tmp);
@


1.1.1.1
log
@import OpenSSL-1.0.0a
@
text
@@


1.1.1.2
log
@import OpenSSL 1.0.0e
@
text
@d665 1
a665 1
	unsigned int pvk_magic, is_encrypted;
d692 1
a692 1
	/*keytype = */read_ledword(&p);
d842 1
a842 1
	int outlen = 24, pklen;
d853 1
d855 2
d866 1
@


1.1.1.3
log
@import OpenSSL-1.0.1c
@
text
@a711 1
	int rv = 1;
d713 4
a716 6
	if (!EVP_DigestInit_ex(&mctx, EVP_sha1(), NULL)
		|| !EVP_DigestUpdate(&mctx, salt, saltlen)
		|| !EVP_DigestUpdate(&mctx, pass, passlen)
		|| !EVP_DigestFinal_ex(&mctx, key, NULL))
			rv = 0;

d718 1
a718 1
	return rv;
a729 2
	EVP_CIPHER_CTX cctx;
	EVP_CIPHER_CTX_init(&cctx);
d734 1
d760 4
a763 6
		if (!EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf, NULL))
			goto err;
		if (!EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen))
			goto err;
		if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen, &enctmplen))
			goto err;
d769 2
a770 3
			if (!EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf,
								NULL))
				goto err;
d772 3
a774 5
			if (!EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen))
				goto err;
			if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen,
								&enctmplen))
				goto err;
d778 1
d785 1
a790 1
	EVP_CIPHER_CTX_cleanup(&cctx);
a843 2
	EVP_CIPHER_CTX cctx;
	EVP_CIPHER_CTX_init(&cctx);
d888 1
d905 2
a906 2
		if (!EVP_EncryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf, NULL))
			goto error;
d908 3
a910 4
		if (!EVP_DecryptUpdate(&cctx, p, &enctmplen, p, pklen - 8))
			goto error;
		if (!EVP_DecryptFinal_ex(&cctx, p + enctmplen, &enctmplen))
			goto error;
a911 1
	EVP_CIPHER_CTX_cleanup(&cctx);
a914 1
	EVP_CIPHER_CTX_cleanup(&cctx);
@


