head	1.44;
access;
symbols
	OPENBSD_6_1_BASE:1.44;
locks; strict;
comment	@ * @;


1.44
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.43;
commitid	kT0fLt3r4lroFJra;

1.43
date	2016.10.19.16.49.11;	author jsing;	state Exp;
branches;
next	1.42;
commitid	jPDvHFzYCLsD7MQG;

1.42
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.41;
commitid	vHznCDK3idwNEFz4;

1.41
date	2015.07.19.18.29.31;	author miod;	state Exp;
branches;
next	1.40;
commitid	tXLDcP80XKVov5z5;

1.40
date	2015.07.16.02.14.48;	author miod;	state Exp;
branches;
next	1.39;
commitid	0RohIfLCZH5gcCLV;

1.39
date	2015.02.11.04.05.14;	author beck;	state Exp;
branches;
next	1.38;
commitid	BiQ5VBK0FHpjQNna;

1.38
date	2015.02.11.03.55.42;	author beck;	state Exp;
branches;
next	1.37;
commitid	1omCojArcEf3nCrU;

1.37
date	2015.02.11.03.19.37;	author doug;	state Exp;
branches;
next	1.36;
commitid	5KSZBoxiLebzObKt;

1.36
date	2015.02.10.09.52.35;	author miod;	state Exp;
branches;
next	1.35;
commitid	elQcISUWkrkujoI4;

1.35
date	2014.10.22.13.02.04;	author jsing;	state Exp;
branches;
next	1.34;
commitid	PjnBgKe6Buhbf937;

1.34
date	2014.07.23.20.43.56;	author miod;	state Exp;
branches;
next	1.33;
commitid	wCpGbEhEuf8uGQVg;

1.33
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.32;
commitid	yQEL1wOWIearrW15;

1.32
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.31;
commitid	nzndm3zqPmFurSaK;

1.31
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.30;
commitid	id8dTrTMtnTn4fqt;

1.30
date	2014.07.10.11.25.13;	author tedu;	state Exp;
branches;
next	1.29;
commitid	Pv7aSK7aYL3NQSpP;

1.29
date	2014.07.09.11.10.51;	author bcook;	state Exp;
branches;
next	1.28;
commitid	lHJTcoC4c5BhEOGj;

1.28
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	mJUVYpkFBZ0Zv2bG;

1.27
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	2nvnQBrv22dLtvTt;

1.26
date	2014.06.01.05.12.50;	author jsing;	state Exp;
branches;
next	1.25;
commitid	y3gq3XQlaiMTc40o;

1.25
date	2014.05.29.21.07.43;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2014.05.29.20.21.22;	author beck;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.21.15.44.13;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.21.15.39.52;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.19.00.41.38;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.17.12.14.26;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.15.17.46.17;	author beck;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.29.05.39.24;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.03.15.12.45;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.14.11.18.03;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.15;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.57.57;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.41;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.10.54;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.28;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.54;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.42;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.12.20.48.38;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.35.36;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.41.47;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.13;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.57;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.12;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: pem_lib.c,v 1.43 2016/10/19 16:49:11 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/buffer.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/objects.h>
#include <openssl/pem.h>
#include <openssl/pkcs12.h>
#include <openssl/x509.h>

#ifndef OPENSSL_NO_DES
#include <openssl/des.h>
#endif
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif

#include "asn1_locl.h"

#define MIN_LENGTH	4

static int load_iv(char **fromp, unsigned char *to, int num);
static int check_pem(const char *nm, const char *name);
int pem_check_suffix(const char *pem_str, const char *suffix);

/* XXX LSSL ABI XXX return value and `num' ought to be size_t */
int
PEM_def_callback(char *buf, int num, int w, void *key)
{
	size_t l;
	int i;
	const char *prompt;

	if (num < 0)
		return -1;

	if (key) {
		l = strlen(key);
		if (l > (size_t)num)
			l = (size_t)num;
		memcpy(buf, key, l);
		return (int)l;
	}

	prompt = EVP_get_pw_prompt();
	if (prompt == NULL)
		prompt = "Enter PEM pass phrase:";

	for (;;) {
		i = EVP_read_pw_string_min(buf, MIN_LENGTH, num, prompt, w);
		if (i != 0) {
			PEMerror(PEM_R_PROBLEMS_GETTING_PASSWORD);
			memset(buf, 0, num);
			return (-1);
		}
		l = strlen(buf);
		if (l < MIN_LENGTH) {
			fprintf(stderr, "phrase is too short, "
			    "needs to be at least %zu chars\n",
			    (size_t)MIN_LENGTH);
		} else
			break;
	}
	return (int)l;
}

void
PEM_proc_type(char *buf, int type)
{
	const char *str;

	if (type == PEM_TYPE_ENCRYPTED)
		str = "ENCRYPTED";
	else if (type == PEM_TYPE_MIC_CLEAR)
		str = "MIC-CLEAR";
	else if (type == PEM_TYPE_MIC_ONLY)
		str = "MIC-ONLY";
	else
		str = "BAD-TYPE";

	strlcat(buf, "Proc-Type: 4,", PEM_BUFSIZE);
	strlcat(buf, str, PEM_BUFSIZE);
	strlcat(buf, "\n", PEM_BUFSIZE);
}

void
PEM_dek_info(char *buf, const char *type, int len, char *str)
{
	static const unsigned char map[17] = "0123456789ABCDEF";
	long i;
	int j;

	strlcat(buf, "DEK-Info: ", PEM_BUFSIZE);
	strlcat(buf, type, PEM_BUFSIZE);
	strlcat(buf, ",", PEM_BUFSIZE);
	j = strlen(buf);
	if (j + (len * 2) + 1 > PEM_BUFSIZE)
		return;
	for (i = 0; i < len; i++) {
		buf[j + i * 2] = map[(str[i] >> 4) & 0x0f];
		buf[j + i * 2 + 1] = map[(str[i]) & 0x0f];
	}
	buf[j + i * 2] = '\n';
	buf[j + i * 2 + 1] = '\0';
}

void *
PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
    pem_password_cb *cb, void *u)
{
	BIO *b;
	void *ret;

	if ((b = BIO_new(BIO_s_file())) == NULL) {
		PEMerror(ERR_R_BUF_LIB);
		return (0);
	}
	BIO_set_fp(b, fp, BIO_NOCLOSE);
	ret = PEM_ASN1_read_bio(d2i, name, b, x, cb, u);
	BIO_free(b);
	return (ret);
}

static int
check_pem(const char *nm, const char *name)
{
	/* Normal matching nm and name */
	if (!strcmp(nm, name))
		return 1;

	/* Make PEM_STRING_EVP_PKEY match any private key */

	if (!strcmp(name, PEM_STRING_EVP_PKEY)) {
		int slen;
		const EVP_PKEY_ASN1_METHOD *ameth;
		if (!strcmp(nm, PEM_STRING_PKCS8))
			return 1;
		if (!strcmp(nm, PEM_STRING_PKCS8INF))
			return 1;
		slen = pem_check_suffix(nm, "PRIVATE KEY");
		if (slen > 0) {
			/* NB: ENGINE implementations wont contain
			 * a deprecated old private key decode function
			 * so don't look for them.
			 */
			ameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);
			if (ameth && ameth->old_priv_decode)
				return 1;
		}
		return 0;
	}

	if (!strcmp(name, PEM_STRING_PARAMETERS)) {
		int slen;
		const EVP_PKEY_ASN1_METHOD *ameth;
		slen = pem_check_suffix(nm, "PARAMETERS");
		if (slen > 0) {
			ENGINE *e;
			ameth = EVP_PKEY_asn1_find_str(&e, nm, slen);
			if (ameth) {
				int r;
				if (ameth->param_decode)
					r = 1;
				else
					r = 0;
#ifndef OPENSSL_NO_ENGINE
				if (e)
					ENGINE_finish(e);
#endif
				return r;
			}
		}
		return 0;
	}

	/* Permit older strings */

	if (!strcmp(nm, PEM_STRING_X509_OLD) &&
	    !strcmp(name, PEM_STRING_X509))
		return 1;

	if (!strcmp(nm, PEM_STRING_X509_REQ_OLD) &&
	    !strcmp(name, PEM_STRING_X509_REQ))
		return 1;

	/* Allow normal certs to be read as trusted certs */
	if (!strcmp(nm, PEM_STRING_X509) &&
	    !strcmp(name, PEM_STRING_X509_TRUSTED))
		return 1;

	if (!strcmp(nm, PEM_STRING_X509_OLD) &&
	    !strcmp(name, PEM_STRING_X509_TRUSTED))
		return 1;

	/* Some CAs use PKCS#7 with CERTIFICATE headers */
	if (!strcmp(nm, PEM_STRING_X509) &&
	    !strcmp(name, PEM_STRING_PKCS7))
		return 1;

	if (!strcmp(nm, PEM_STRING_PKCS7_SIGNED) &&
	    !strcmp(name, PEM_STRING_PKCS7))
		return 1;


	return 0;
}

int
PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
    const char *name, BIO *bp, pem_password_cb *cb, void *u)
{
	EVP_CIPHER_INFO cipher;
	char *nm = NULL, *header = NULL;
	unsigned char *data = NULL;
	long len;
	int ret = 0;

	for (;;) {
		if (!PEM_read_bio(bp, &nm, &header, &data, &len)) {
			if (ERR_GET_REASON(ERR_peek_error()) ==
			    PEM_R_NO_START_LINE)
				ERR_asprintf_error_data("Expecting: %s", name);
			return 0;
		}
		if (check_pem(nm, name))
			break;
		free(nm);
		free(header);
		free(data);
	}
	if (!PEM_get_EVP_CIPHER_INFO(header, &cipher))
		goto err;
	if (!PEM_do_header(&cipher, data, &len, cb, u))
		goto err;

	*pdata = data;
	*plen = len;

	if (pnm)
		*pnm = nm;

	ret = 1;

err:
	if (!ret || !pnm)
		free(nm);
	free(header);
	if (!ret)
		free(data);
	return ret;
}

int
PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp, void *x,
    const EVP_CIPHER *enc, unsigned char *kstr, int klen,
    pem_password_cb *callback, void *u)
{
	BIO *b;
	int ret;

	if ((b = BIO_new(BIO_s_file())) == NULL) {
		PEMerror(ERR_R_BUF_LIB);
		return (0);
	}
	BIO_set_fp(b, fp, BIO_NOCLOSE);
	ret = PEM_ASN1_write_bio(i2d, name, b, x, enc, kstr, klen, callback, u);
	BIO_free(b);
	return (ret);
}

int
PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, void *x,
    const EVP_CIPHER *enc, unsigned char *kstr, int klen,
    pem_password_cb *callback, void *u)
{
	EVP_CIPHER_CTX ctx;
	int dsize = 0, i, j, ret = 0;
	unsigned char *p, *data = NULL;
	const char *objstr = NULL;
	char buf[PEM_BUFSIZE];
	unsigned char key[EVP_MAX_KEY_LENGTH];
	unsigned char iv[EVP_MAX_IV_LENGTH];

	if (enc != NULL) {
		objstr = OBJ_nid2sn(EVP_CIPHER_nid(enc));
		if (objstr == NULL) {
			PEMerror(PEM_R_UNSUPPORTED_CIPHER);
			goto err;
		}
	}

	if ((dsize = i2d(x, NULL)) < 0) {
		PEMerror(ERR_R_ASN1_LIB);
		dsize = 0;
		goto err;
	}
	/* dzise + 8 bytes are needed */
	/* actually it needs the cipher block size extra... */
	data = malloc(dsize + 20);
	if (data == NULL) {
		PEMerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	p = data;
	i = i2d(x, &p);

	if (enc != NULL) {
		if (kstr == NULL) {
			if (callback == NULL)
				klen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);
			else
				klen = (*callback)(buf, PEM_BUFSIZE, 1, u);
			if (klen <= 0) {
				PEMerror(PEM_R_READ_KEY);
				goto err;
			}
			kstr = (unsigned char *)buf;
		}
		if ((size_t)enc->iv_len > sizeof(iv)) {
			PEMerror(EVP_R_IV_TOO_LARGE);
			goto err;
		}
		arc4random_buf(iv, enc->iv_len); /* Generate a salt */
		/* The 'iv' is used as the iv and as a salt.  It is
		 * NOT taken from the BytesToKey function */
		if (!EVP_BytesToKey(enc, EVP_md5(), iv, kstr, klen, 1,
		    key, NULL))
			goto err;

		if (kstr == (unsigned char *)buf)
			explicit_bzero(buf, PEM_BUFSIZE);

		if (strlen(objstr) + 23 + 2 * enc->iv_len + 13 > sizeof buf) {
			PEMerror(ASN1_R_BUFFER_TOO_SMALL);
			goto err;
		}

		buf[0] = '\0';
		PEM_proc_type(buf, PEM_TYPE_ENCRYPTED);
		PEM_dek_info(buf, objstr, enc->iv_len, (char *)iv);
		/* k=strlen(buf); */

		EVP_CIPHER_CTX_init(&ctx);
		ret = 1;
		if (!EVP_EncryptInit_ex(&ctx, enc, NULL, key, iv) ||
		    !EVP_EncryptUpdate(&ctx, data, &j, data, i) ||
		    !EVP_EncryptFinal_ex(&ctx, &(data[j]), &i))
			ret = 0;
		EVP_CIPHER_CTX_cleanup(&ctx);
		if (ret == 0)
			goto err;
		i += j;
	} else {
		ret = 1;
		buf[0] = '\0';
	}
	i = PEM_write_bio(bp, name, buf, data, i);
	if (i <= 0)
		ret = 0;
err:
	explicit_bzero(key, sizeof(key));
	explicit_bzero(iv, sizeof(iv));
	explicit_bzero((char *)&ctx, sizeof(ctx));
	explicit_bzero(buf, PEM_BUFSIZE);
	if (data != NULL) {
		explicit_bzero(data, (unsigned int)dsize);
		free(data);
	}
	return (ret);
}

int
PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
    pem_password_cb *callback, void *u)
{
	int i, j, o, klen;
	long len;
	EVP_CIPHER_CTX ctx;
	unsigned char key[EVP_MAX_KEY_LENGTH];
	char buf[PEM_BUFSIZE];

	len = *plen;

	if (cipher->cipher == NULL)
		return (1);
	if (callback == NULL)
		klen = PEM_def_callback(buf, PEM_BUFSIZE, 0, u);
	else
		klen = callback(buf, PEM_BUFSIZE, 0, u);
	if (klen <= 0) {
		PEMerror(PEM_R_BAD_PASSWORD_READ);
		return (0);
	}
	if (!EVP_BytesToKey(cipher->cipher, EVP_md5(), &(cipher->iv[0]),
	    (unsigned char *)buf, klen, 1, key, NULL))
		return 0;

	j = (int)len;
	EVP_CIPHER_CTX_init(&ctx);
	o = EVP_DecryptInit_ex(&ctx, cipher->cipher, NULL, key,
	    &(cipher->iv[0]));
	if (o)
		o = EVP_DecryptUpdate(&ctx, data, &i, data, j);
	if (o)
		o = EVP_DecryptFinal_ex(&ctx, &(data[i]), &j);
	EVP_CIPHER_CTX_cleanup(&ctx);
	explicit_bzero((char *)buf, sizeof(buf));
	explicit_bzero((char *)key, sizeof(key));
	if (!o) {
		PEMerror(PEM_R_BAD_DECRYPT);
		return (0);
	}
	*plen = j + i;
	return (1);
}

int
PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
{
	const EVP_CIPHER *enc = NULL;
	char *p, c;
	char **header_pp = &header;

	cipher->cipher = NULL;
	if ((header == NULL) || (*header == '\0') || (*header == '\n'))
		return (1);
	if (strncmp(header, "Proc-Type: ", 11) != 0) {
		PEMerror(PEM_R_NOT_PROC_TYPE);
		return (0);
	}
	header += 11;
	if (*header != '4')
		return (0);
	header++;
	if (*header != ',')
		return (0);
	header++;
	if (strncmp(header, "ENCRYPTED", 9) != 0) {
		PEMerror(PEM_R_NOT_ENCRYPTED);
		return (0);
	}
	for (; (*header != '\n') && (*header != '\0'); header++)
		;
	if (*header == '\0') {
		PEMerror(PEM_R_SHORT_HEADER);
		return (0);
	}
	header++;
	if (strncmp(header, "DEK-Info: ", 10) != 0) {
		PEMerror(PEM_R_NOT_DEK_INFO);
		return (0);
	}
	header += 10;

	p = header;
	for (;;) {
		c= *header;
		if (!(	((c >= 'A') && (c <= 'Z')) || (c == '-') ||
		    ((c >= '0') && (c <= '9'))))
			break;
		header++;
	}
	*header = '\0';
	cipher->cipher = enc = EVP_get_cipherbyname(p);
	*header = c;
	header++;

	if (enc == NULL) {
		PEMerror(PEM_R_UNSUPPORTED_ENCRYPTION);
		return (0);
	}
	if (!load_iv(header_pp, &(cipher->iv[0]), enc->iv_len))
		return (0);

	return (1);
}

static int
load_iv(char **fromp, unsigned char *to, int num)
{
	int v, i;
	char *from;

	from= *fromp;
	for (i = 0; i < num; i++)
		to[i] = 0;
	num *= 2;
	for (i = 0; i < num; i++) {
		if ((*from >= '0') && (*from <= '9'))
			v = *from - '0';
		else if ((*from >= 'A') && (*from <= 'F'))
			v = *from - 'A' + 10;
		else if ((*from >= 'a') && (*from <= 'f'))
			v = *from - 'a' + 10;
		else {
			PEMerror(PEM_R_BAD_IV_CHARS);
			return (0);
		}
		from++;
		to[i / 2] |= v << (long)((!(i & 1)) * 4);
	}

	*fromp = from;
	return (1);
}

int
PEM_write(FILE *fp, char *name, char *header, unsigned char *data, long len)
{
	BIO *b;
	int ret;

	if ((b = BIO_new(BIO_s_file())) == NULL) {
		PEMerror(ERR_R_BUF_LIB);
		return (0);
	}
	BIO_set_fp(b, fp, BIO_NOCLOSE);
	ret = PEM_write_bio(b, name, header, data, len);
	BIO_free(b);
	return (ret);
}

int
PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data,
    long len)
{
	int nlen, n, i, j, outl;
	unsigned char *buf = NULL;
	EVP_ENCODE_CTX ctx;
	int reason = ERR_R_BUF_LIB;

	EVP_EncodeInit(&ctx);
	nlen = strlen(name);

	if ((BIO_write(bp, "-----BEGIN ", 11) != 11) ||
	    (BIO_write(bp, name, nlen) != nlen) ||
	    (BIO_write(bp, "-----\n", 6) != 6))
		goto err;

	i = strlen(header);
	if (i > 0) {
		if ((BIO_write(bp, header, i) != i) ||
		    (BIO_write(bp, "\n", 1) != 1))
			goto err;
	}

	buf = reallocarray(NULL, PEM_BUFSIZE, 8);
	if (buf == NULL) {
		reason = ERR_R_MALLOC_FAILURE;
		goto err;
	}

	i = j = 0;
	while (len > 0) {
		n = (int)((len > (PEM_BUFSIZE * 5)) ? (PEM_BUFSIZE * 5) : len);
		EVP_EncodeUpdate(&ctx, buf, &outl, &(data[j]), n);
		if ((outl) && (BIO_write(bp, (char *)buf, outl) != outl))
			goto err;
		i += outl;
		len -= n;
		j += n;
	}
	EVP_EncodeFinal(&ctx, buf, &outl);
	if ((outl > 0) && (BIO_write(bp, (char *)buf, outl) != outl))
		goto err;
	explicit_bzero(buf, PEM_BUFSIZE * 8);
	free(buf);
	buf = NULL;
	if ((BIO_write(bp, "-----END ", 9) != 9) ||
	    (BIO_write(bp, name, nlen) != nlen) ||
	    (BIO_write(bp, "-----\n", 6) != 6))
		goto err;
	return (i + outl);

err:
	if (buf) {
		explicit_bzero(buf, PEM_BUFSIZE * 8);
		free(buf);
	}
	PEMerror(reason);
	return (0);
}

int
PEM_read(FILE *fp, char **name, char **header, unsigned char **data, long *len)
{
	BIO *b;
	int ret;

	if ((b = BIO_new(BIO_s_file())) == NULL) {
		PEMerror(ERR_R_BUF_LIB);
		return (0);
	}
	BIO_set_fp(b, fp, BIO_NOCLOSE);
	ret = PEM_read_bio(b, name, header, data, len);
	BIO_free(b);
	return (ret);
}

int
PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
    long *len)
{
	EVP_ENCODE_CTX ctx;
	int end = 0, i, k, bl = 0, hl = 0, nohead = 0;
	char buf[256];
	BUF_MEM *nameB;
	BUF_MEM *headerB;
	BUF_MEM *dataB, *tmpB;

	nameB = BUF_MEM_new();
	headerB = BUF_MEM_new();
	dataB = BUF_MEM_new();
	if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL)) {
		BUF_MEM_free(nameB);
		BUF_MEM_free(headerB);
		BUF_MEM_free(dataB);
		PEMerror(ERR_R_MALLOC_FAILURE);
		return (0);
	}

	buf[254] = '\0';
	for (;;) {
		i = BIO_gets(bp, buf, 254);

		if (i <= 0) {
			PEMerror(PEM_R_NO_START_LINE);
			goto err;
		}

		while ((i >= 0) && (buf[i] <= ' '))
			i--;
		buf[++i] = '\n';
		buf[++i] = '\0';

		if (strncmp(buf, "-----BEGIN ", 11) == 0) {
			i = strlen(&(buf[11]));

			if (strncmp(&(buf[11 + i - 6]), "-----\n", 6) != 0)
				continue;
			if (!BUF_MEM_grow(nameB, i + 9)) {
				PEMerror(ERR_R_MALLOC_FAILURE);
				goto err;
			}
			memcpy(nameB->data, &(buf[11]), i - 6);
			nameB->data[i - 6] = '\0';
			break;
		}
	}
	hl = 0;
	if (!BUF_MEM_grow(headerB, 256)) {
		PEMerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	headerB->data[0] = '\0';
	for (;;) {
		i = BIO_gets(bp, buf, 254);
		if (i <= 0)
			break;

		while ((i >= 0) && (buf[i] <= ' '))
			i--;
		buf[++i] = '\n';
		buf[++i] = '\0';

		if (buf[0] == '\n')
			break;
		if (!BUF_MEM_grow(headerB, hl + i + 9)) {
			PEMerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (strncmp(buf, "-----END ", 9) == 0) {
			nohead = 1;
			break;
		}
		memcpy(&(headerB->data[hl]), buf, i);
		headerB->data[hl + i] = '\0';
		hl += i;
	}

	bl = 0;
	if (!BUF_MEM_grow(dataB, 1024)) {
		PEMerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}
	dataB->data[0] = '\0';
	if (!nohead) {
		for (;;) {
			i = BIO_gets(bp, buf, 254);
			if (i <= 0)
				break;

			while ((i >= 0) && (buf[i] <= ' '))
				i--;
			buf[++i] = '\n';
			buf[++i] = '\0';

			if (i != 65)
				end = 1;
			if (strncmp(buf, "-----END ", 9) == 0)
				break;
			if (i > 65)
				break;
			if (!BUF_MEM_grow_clean(dataB, i + bl + 9)) {
				PEMerror(ERR_R_MALLOC_FAILURE);
				goto err;
			}
			memcpy(&(dataB->data[bl]), buf, i);
			dataB->data[bl + i] = '\0';
			bl += i;
			if (end) {
				buf[0] = '\0';
				i = BIO_gets(bp, buf, 254);
				if (i <= 0)
					break;

				while ((i >= 0) && (buf[i] <= ' '))
					i--;
				buf[++i] = '\n';
				buf[++i] = '\0';

				break;
			}
		}
	} else {
		tmpB = headerB;
		headerB = dataB;
		dataB = tmpB;
		bl = hl;
	}
	i = strlen(nameB->data);
	if ((strncmp(buf, "-----END ", 9) != 0) ||
	    (strncmp(nameB->data, &(buf[9]), i) != 0) ||
	    (strncmp(&(buf[9 + i]), "-----\n", 6) != 0)) {
		PEMerror(PEM_R_BAD_END_LINE);
		goto err;
	}

	EVP_DecodeInit(&ctx);
	i = EVP_DecodeUpdate(&ctx,
	    (unsigned char *)dataB->data, &bl,
	    (unsigned char *)dataB->data, bl);
	if (i < 0) {
		PEMerror(PEM_R_BAD_BASE64_DECODE);
		goto err;
	}
	i = EVP_DecodeFinal(&ctx, (unsigned char *)&(dataB->data[bl]), &k);
	if (i < 0) {
		PEMerror(PEM_R_BAD_BASE64_DECODE);
		goto err;
	}
	bl += k;

	if (bl == 0)
		goto err;
	*name = nameB->data;
	*header = headerB->data;
	*data = (unsigned char *)dataB->data;
	*len = bl;
	free(nameB);
	free(headerB);
	free(dataB);
	return (1);

err:
	BUF_MEM_free(nameB);
	BUF_MEM_free(headerB);
	BUF_MEM_free(dataB);
	return (0);
}

/* Check pem string and return prefix length.
 * If for example the pem_str == "RSA PRIVATE KEY" and suffix = "PRIVATE KEY"
 * the return value is 3 for the string "RSA".
 */

int
pem_check_suffix(const char *pem_str, const char *suffix)
{
	int pem_len = strlen(pem_str);
	int suffix_len = strlen(suffix);
	const char *p;

	if (suffix_len + 1 >= pem_len)
		return 0;
	p = pem_str + pem_len - suffix_len;
	if (strcmp(p, suffix))
		return 0;
	p--;
	if (*p != ' ')
		return 0;
	return p - pem_str;
}
@


1.43
log
@unifdef OPENSSL_NO_CMS
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.42 2015/09/10 15:56:25 jsing Exp $ */
d115 1
a115 2
			PEMerr(PEM_F_PEM_DEF_CALLBACK,
			    PEM_R_PROBLEMS_GETTING_PASSWORD);
d178 1
a178 1
		PEMerr(PEM_F_PEM_ASN1_READ, ERR_R_BUF_LIB);
d325 1
a325 1
		PEMerr(PEM_F_PEM_ASN1_WRITE, ERR_R_BUF_LIB);
d350 1
a350 2
			PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,
			    PEM_R_UNSUPPORTED_CIPHER);
d356 1
a356 1
		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_ASN1_LIB);
d364 1
a364 1
		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_MALLOC_FAILURE);
d377 1
a377 2
				PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,
				    PEM_R_READ_KEY);
d383 1
a383 1
			PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, EVP_R_IV_TOO_LARGE);
d397 1
a397 2
			PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,
			    ASN1_R_BUFFER_TOO_SMALL);
d454 1
a454 1
		PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_PASSWORD_READ);
d473 1
a473 1
		PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_DECRYPT);
d491 1
a491 1
		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_PROC_TYPE);
d502 1
a502 1
		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_ENCRYPTED);
d508 1
a508 1
		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_SHORT_HEADER);
d513 1
a513 1
		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_DEK_INFO);
d532 1
a532 2
		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,
		    PEM_R_UNSUPPORTED_ENCRYPTION);
d559 1
a559 1
			PEMerr(PEM_F_LOAD_IV, PEM_R_BAD_IV_CHARS);
d577 1
a577 1
		PEMerr(PEM_F_PEM_WRITE, ERR_R_BUF_LIB);
d643 1
a643 1
	PEMerr(PEM_F_PEM_WRITE_BIO, reason);
d654 1
a654 1
		PEMerr(PEM_F_PEM_READ, ERR_R_BUF_LIB);
d681 1
a681 1
		PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
d690 1
a690 1
			PEMerr(PEM_F_PEM_READ_BIO, PEM_R_NO_START_LINE);
d705 1
a705 2
				PEMerr(PEM_F_PEM_READ_BIO,
				    ERR_R_MALLOC_FAILURE);
d715 1
a715 1
		PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
d732 1
a732 1
			PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
d746 1
a746 1
		PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
d768 1
a768 2
				PEMerr(PEM_F_PEM_READ_BIO,
				    ERR_R_MALLOC_FAILURE);
d798 1
a798 1
		PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_END_LINE);
d807 1
a807 1
		PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);
d812 1
a812 1
		PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);
@


1.42
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.41 2015/07/19 18:29:31 miod Exp $ */
a267 9
#ifndef OPENSSL_NO_CMS
	if (!strcmp(nm, PEM_STRING_X509) &&
	    !strcmp(name, PEM_STRING_CMS))
		return 1;
	/* Allow CMS to be read from PKCS#7 headers */
	if (!strcmp(nm, PEM_STRING_PKCS7) &&
	    !strcmp(name, PEM_STRING_CMS))
		return 1;
#endif
@


1.41
log
@Drop stupid (int) casts for the arguments of malloc() and friends. This is
not 16-bit MS-DOS anymore.
ok bcook@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.40 2015/07/16 02:14:48 miod Exp $ */
d406 1
a406 1
			OPENSSL_cleanse(buf, PEM_BUFSIZE);
d437 4
a440 4
	OPENSSL_cleanse(key, sizeof(key));
	OPENSSL_cleanse(iv, sizeof(iv));
	OPENSSL_cleanse((char *)&ctx, sizeof(ctx));
	OPENSSL_cleanse(buf, PEM_BUFSIZE);
d442 1
a442 1
		OPENSSL_cleanse(data, (unsigned int)dsize);
d483 2
a484 2
	OPENSSL_cleanse((char *)buf, sizeof(buf));
	OPENSSL_cleanse((char *)key, sizeof(key));
d643 1
a643 1
	OPENSSL_cleanse(buf, PEM_BUFSIZE * 8);
d654 1
a654 1
		OPENSSL_cleanse(buf, PEM_BUFSIZE * 8);
@


1.40
log
@Make sure the `reject negative sizes' logic introduced in 1.34 is actually
applied to all code paths.
ok beck@@ bcook@@ doug@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.39 2015/02/11 04:05:14 beck Exp $ */
d373 1
a373 1
	data = malloc((unsigned int)dsize + 20);
@


1.39
log
@Guenther has plans for OPENSSL_NO_CMS, so revert this for the moment.
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.38 2015/02/11 03:55:42 beck Exp $ */
d97 3
a101 2
		if (num < 0)
			return -1;
@


1.38
log
@get rid of OPENSSL_NO_CMS code we do not use.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.37 2015/02/11 03:19:37 doug Exp $ */
d267 9
@


1.37
log
@Enable building with -DOPENSSL_NO_DEPRECATED.

If you didn't enable deprecated code, there were missing err.h and
bn.h includes.  This commit allows building with or without deprecated
code.

This was not derived from an OpenSSL commit.  However, they recently
enabled OPENSSL_NO_DEPRECATED in git and fixed these header problems
in a different way.

Verified with clang that this only changes line numbers in the generated
asm.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.36 2015/02/10 09:52:35 miod Exp $ */
a266 9
#ifndef OPENSSL_NO_CMS
	if (!strcmp(nm, PEM_STRING_X509) &&
	    !strcmp(name, PEM_STRING_CMS))
		return 1;
	/* Allow CMS to be read from PKCS#7 headers */
	if (!strcmp(nm, PEM_STRING_PKCS7) &&
	    !strcmp(name, PEM_STRING_CMS))
		return 1;
#endif
@


1.36
log
@Replace assert() and OPENSSL_assert() calls with proper error return paths.
Careful review, feedback & ok doug@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.35 2014/10/22 13:02:04 jsing Exp $ */
d67 1
@


1.35
log
@Use arc4random_buf() instead of RAND_bytes() or RAND_pseudo_bytes().

arc4random_buf() is guaranteed to always succeed - it is worth noting
that a number of the replaced function calls were already missing return
value checks.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.34 2014/07/23 20:43:56 miod Exp $ */
d392 4
a395 1
		OPENSSL_assert(enc->iv_len <= (int)sizeof(iv));
d406 5
a410 2
		OPENSSL_assert(strlen(objstr) + 23 +
		    2 * enc->iv_len + 13 <= sizeof buf);
@


1.34
log
@Make sure PEM_def_callback() correctly handles negative buffer sizes; all uses
within libcrypto are safe, but until we can change this function prototype to
use size_t instead of int, better be safe than sorry.

tweaks and ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.33 2014/07/11 08:44:49 jsing Exp $ */
d61 1
a70 1
#include <openssl/rand.h>
d393 1
a393 2
		if (RAND_pseudo_bytes(iv, enc->iv_len) < 0) /* Generate a salt */
			goto err;
@


1.33
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.32 2014/07/10 22:45:57 jsing Exp $ */
d88 1
d92 2
a93 1
	int i, j;
d97 7
a103 4
		i = strlen(key);
		i = (i > num) ? num : i;
		memcpy(buf, key, i);
		return (i);
d118 5
a122 3
		j = strlen(buf);
		if (j < MIN_LENGTH) {
			fprintf(stderr, "phrase is too short, needs to be at least %d chars\n", MIN_LENGTH);
d126 1
a126 1
	return (j);
@


1.32
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.31 2014/07/10 13:58:23 jsing Exp $ */
a64 1
#include "cryptlib.h"
d66 1
d68 2
a69 1
#include <openssl/evp.h>
d72 1
a72 3
#include <openssl/pem.h>
#include <openssl/pkcs12.h>
#include "asn1_locl.h"
d79 2
@


1.31
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.30 2014/07/10 11:25:13 tedu Exp $ */
d62 2
@


1.30
log
@delete some casts. ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.29 2014/07/09 11:10:51 bcook Exp $ */
d59 1
d61 2
a62 1
#include <ctype.h>
@


1.29
log
@remove unused, private version strings except SSL_version_str

Also remove unused des_ver.h, which exports some of these strings, but is not installed.

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: pem_lib.c,v 1.28 2014/06/12 15:49:30 deraadt Exp $ */
d105 1
a105 1
			memset(buf, 0, (unsigned int)num);
@


1.28
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a75 2

const char PEM_version[] = "PEM" OPENSSL_VERSION_PTEXT;
@


1.27
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/pem/pem_lib.c */
@


1.26
log
@Avoid the use of an uninitialised variable. In reality, this is a non-issue
since the calculated value is not actually used in the uninitialised case.
Change the code so that we only do the calculation if we actually need it.

Issue detected by clang and reported by both brad@@ and Brent Cook.
@
text
@d361 1
a361 1
	data = (unsigned char *)malloc((unsigned int)dsize + 20);
@


1.25
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@a467 1
	j += i;
d472 1
a472 1
	*plen = j;
@


1.24
log
@Everything sane has stdio, and FILE *. we don't need ifdefs for this.
ok to firebomb from tedu@@
@
text
@d608 1
a608 1
	buf = malloc(PEM_BUFSIZE * 8);
@


1.23
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@a87 6
#ifdef OPENSSL_NO_FP_API
	/* We should not ever call the default callback routine from
	 * windows. */
	PEMerr(PEM_F_PEM_DEF_CALLBACK, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return (-1);
#else
a116 1
#endif
a158 1
#ifndef OPENSSL_NO_FP_API
a174 1
#endif
a313 1
#ifndef OPENSSL_NO_FP_API
a330 1
#endif
a567 1
#ifndef OPENSSL_NO_FP_API
a582 1
#endif
a644 1
#ifndef OPENSSL_NO_FP_API
a659 1
#endif
@


1.22
log
@More KNF.
@
text
@d292 1
a292 1
				ERR_add_error_data(2, "Expecting: ", name);
@


1.21
log
@KNF.
@
text
@d504 1
a504 1
		return(0);
d507 1
a507 1
		return(0);
@


1.20
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d77 1
a77 1
const char PEM_version[]="PEM" OPENSSL_VERSION_PTEXT;
d81 1
a81 1
static int load_iv(char **fromp,unsigned char *to, int num);
d85 3
a87 2
int PEM_def_callback(char *buf, int num, int w, void *key)
	{
d91 2
a92 2
	PEMerr(PEM_F_PEM_DEF_CALLBACK,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
	return(-1);
d94 1
a94 1
	int i,j;
d96 6
a101 5
	if(key) {
		i=strlen(key);
		i=(i > num)?num:i;
		memcpy(buf,key,i);
		return(i);
d104 1
a104 1
	prompt=EVP_get_pw_prompt();
d106 1
a106 1
		prompt="Enter PEM pass phrase:";
d108 12
a119 15
	for (;;)
		{
		i=EVP_read_pw_string_min(buf,MIN_LENGTH,num,prompt,w);
		if (i != 0)
			{
			PEMerr(PEM_F_PEM_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
			memset(buf,0,(unsigned int)num);
			return(-1);
			}
		j=strlen(buf);
		if (j < MIN_LENGTH)
			{
			fprintf(stderr,"phrase is too short, needs to be at least %d chars\n",MIN_LENGTH);
			}
		else
d121 2
a122 2
		}
	return(j);
d124 1
a124 1
	}
d126 3
a128 2
void PEM_proc_type(char *buf, int type)
	{
d132 1
a132 1
		str="ENCRYPTED";
d134 1
a134 1
		str="MIC-CLEAR";
d136 1
a136 1
		str="MIC-ONLY";
d138 6
a143 6
		str="BAD-TYPE";
		
	strlcat(buf,"Proc-Type: 4,",PEM_BUFSIZE);
	strlcat(buf,str,PEM_BUFSIZE);
	strlcat(buf,"\n",PEM_BUFSIZE);
	}
d145 4
a148 3
void PEM_dek_info(char *buf, const char *type, int len, char *str)
	{
	static const unsigned char map[17]="0123456789ABCDEF";
d152 4
a155 4
	strlcat(buf,"DEK-Info: ",PEM_BUFSIZE);
	strlcat(buf,type,PEM_BUFSIZE);
	strlcat(buf,",",PEM_BUFSIZE);
	j=strlen(buf);
d157 4
a160 8
        	return;
	for (i=0; i<len; i++)
		{
		buf[j+i*2]  =map[(str[i]>>4)&0x0f];
		buf[j+i*2+1]=map[(str[i]   )&0x0f];
		}
	buf[j+i*2]='\n';
	buf[j+i*2+1]='\0';
d162 3
d167 16
a182 16
void *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
		    pem_password_cb *cb, void *u)
	{
        BIO *b;
        void *ret;

        if ((b=BIO_new(BIO_s_file())) == NULL)
		{
		PEMerr(PEM_F_PEM_ASN1_READ,ERR_R_BUF_LIB);
                return(0);
		}
        BIO_set_fp(b,fp,BIO_NOCLOSE);
        ret=PEM_ASN1_read_bio(d2i,name,b,x,cb,u);
        BIO_free(b);
        return(ret);
	}
d185 2
a186 1
static int check_pem(const char *nm, const char *name)
d189 2
a190 1
	if (!strcmp(nm,name)) return 1;
d194 1
a194 2
	if(!strcmp(name,PEM_STRING_EVP_PKEY))
		{
d197 1
a197 1
		if(!strcmp(nm,PEM_STRING_PKCS8))
d199 1
a199 1
		if(!strcmp(nm,PEM_STRING_PKCS8INF))
d201 2
a202 3
		slen = pem_check_suffix(nm, "PRIVATE KEY"); 
		if (slen > 0)
			{
d210 1
a210 1
			}
d212 1
a212 1
		}
d214 1
a214 2
	if(!strcmp(name,PEM_STRING_PARAMETERS))
		{
d217 2
a218 3
		slen = pem_check_suffix(nm, "PARAMETERS"); 
		if (slen > 0)
			{
d221 1
a221 2
			if (ameth)
				{
a231 1
				}
d233 1
d235 1
a235 1
		}
d239 7
a245 5
	if(!strcmp(nm,PEM_STRING_X509_OLD) &&
		!strcmp(name,PEM_STRING_X509)) return 1;

	if(!strcmp(nm,PEM_STRING_X509_REQ_OLD) &&
		!strcmp(name,PEM_STRING_X509_REQ)) return 1;
d248 7
a254 5
	if(!strcmp(nm,PEM_STRING_X509) &&
		!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;

	if(!strcmp(nm,PEM_STRING_X509_OLD) &&
		!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;
d257 7
a263 5
	if(!strcmp(nm, PEM_STRING_X509) &&
		!strcmp(name, PEM_STRING_PKCS7)) return 1;

	if(!strcmp(nm, PEM_STRING_PKCS7_SIGNED) &&
		!strcmp(name, PEM_STRING_PKCS7)) return 1;
d266 3
a268 2
	if(!strcmp(nm, PEM_STRING_X509) &&
		!strcmp(name, PEM_STRING_CMS)) return 1;
d270 3
a272 2
	if(!strcmp(nm, PEM_STRING_PKCS7) &&
		!strcmp(name, PEM_STRING_CMS)) return 1;
d278 4
a281 3
int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
	     pem_password_cb *cb, void *u)
	{
d283 2
a284 2
	char *nm=NULL,*header=NULL;
	unsigned char *data=NULL;
d288 4
a291 5
	for (;;)
		{
		if (!PEM_read_bio(bp,&nm,&header,&data,&len)) {
			if(ERR_GET_REASON(ERR_peek_error()) ==
				PEM_R_NO_START_LINE)
d295 2
a296 1
		if(check_pem(nm, name)) break;
d300 5
a304 3
		}
	if (!PEM_get_EVP_CIPHER_INFO(header,&cipher)) goto err;
	if (!PEM_do_header(&cipher,data,&len,cb,u)) goto err;
d315 2
a316 1
	if (!ret || !pnm) free(nm);
d318 2
a319 1
	if (!ret) free(data);
d321 1
a321 1
	}
d324 17
a340 17
int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,
		   void *x, const EVP_CIPHER *enc, unsigned char *kstr,
		   int klen, pem_password_cb *callback, void *u)
        {
        BIO *b;
        int ret;

        if ((b=BIO_new(BIO_s_file())) == NULL)
		{
		PEMerr(PEM_F_PEM_ASN1_WRITE,ERR_R_BUF_LIB);
                return(0);
		}
        BIO_set_fp(b,fp,BIO_NOCLOSE);
        ret=PEM_ASN1_write_bio(i2d,name,b,x,enc,kstr,klen,callback,u);
        BIO_free(b);
        return(ret);
        }
d343 5
a347 4
int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
		       void *x, const EVP_CIPHER *enc, unsigned char *kstr,
		       int klen, pem_password_cb *callback, void *u)
	{
d349 3
a351 3
	int dsize=0,i,j,ret=0;
	unsigned char *p,*data=NULL;
	const char *objstr=NULL;
d355 6
a360 7
	
	if (enc != NULL)
		{
		objstr=OBJ_nid2sn(EVP_CIPHER_nid(enc));
		if (objstr == NULL)
			{
			PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_UNSUPPORTED_CIPHER);
a361 1
			}
d363 1
d365 3
a367 4
	if ((dsize=i2d(x,NULL)) < 0)
		{
		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_ASN1_LIB);
		dsize=0;
d369 1
a369 1
		}
d372 3
a374 4
	data=(unsigned char *)malloc((unsigned int)dsize+20);
	if (data == NULL)
		{
		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);
d376 6
a381 8
		}
	p=data;
	i=i2d(x,&p);

	if (enc != NULL)
		{
		if (kstr == NULL)
			{
d383 1
a383 1
				klen=PEM_def_callback(buf,PEM_BUFSIZE,1,u);
d385 4
a388 4
				klen=(*callback)(buf,PEM_BUFSIZE,1,u);
			if (klen <= 0)
				{
				PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_READ_KEY);
a389 2
				}
			kstr=(unsigned char *)buf;
d391 2
d394 1
a394 1
		if (RAND_pseudo_bytes(iv,enc->iv_len) < 0) /* Generate a salt */
d398 2
a399 1
		if (!EVP_BytesToKey(enc,EVP_md5(),iv,kstr,klen,1,key,NULL))
d402 2
a403 1
		if (kstr == (unsigned char *)buf) OPENSSL_cleanse(buf,PEM_BUFSIZE);
d405 2
a406 1
		OPENSSL_assert(strlen(objstr)+23+2*enc->iv_len+13 <= sizeof buf);
d408 3
a410 3
		buf[0]='\0';
		PEM_proc_type(buf,PEM_TYPE_ENCRYPTED);
		PEM_dek_info(buf,objstr,enc->iv_len,(char *)iv);
d415 3
a417 3
		if (!EVP_EncryptInit_ex(&ctx,enc,NULL,key,iv)
			|| !EVP_EncryptUpdate(&ctx,data,&j,data,i)
			|| !EVP_EncryptFinal_ex(&ctx,&(data[j]),&i))
d422 8
a429 9
		i+=j;
		}
	else
		{
		ret=1;
		buf[0]='\0';
		}
	i=PEM_write_bio(bp,name,buf,data,i);
	if (i <= 0) ret=0;
d431 6
a436 7
	OPENSSL_cleanse(key,sizeof(key));
	OPENSSL_cleanse(iv,sizeof(iv));
	OPENSSL_cleanse((char *)&ctx,sizeof(ctx));
	OPENSSL_cleanse(buf,PEM_BUFSIZE);
	if (data != NULL)
		{
		OPENSSL_cleanse(data,(unsigned int)dsize);
a437 2
		}
	return(ret);
d439 2
d442 5
a446 4
int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
	     pem_password_cb *callback,void *u)
	{
	int i,j,o,klen;
d452 1
a452 1
	len= *plen;
d454 2
a455 1
	if (cipher->cipher == NULL) return(1);
d457 1
a457 1
		klen=PEM_def_callback(buf,PEM_BUFSIZE,0,u);
d459 7
a465 8
		klen=callback(buf,PEM_BUFSIZE,0,u);
	if (klen <= 0)
		{
		PEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_PASSWORD_READ);
		return(0);
		}
	if (!EVP_BytesToKey(cipher->cipher,EVP_md5(),&(cipher->iv[0]),
		(unsigned char *)buf,klen,1,key,NULL))
d468 1
a468 1
	j=(int)len;
d470 2
a471 1
	o = EVP_DecryptInit_ex(&ctx,cipher->cipher,NULL, key,&(cipher->iv[0]));
d473 1
a473 1
		o = EVP_DecryptUpdate(&ctx,data,&i,data,j);
d475 1
a475 1
		o = EVP_DecryptFinal_ex(&ctx,&(data[i]),&j);
d477 6
a482 10
	OPENSSL_cleanse((char *)buf,sizeof(buf));
	OPENSSL_cleanse((char *)key,sizeof(key));
	j+=i;
	if (!o)
		{
		PEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_DECRYPT);
		return(0);
		}
	*plen=j;
	return(1);
d484 3
d488 5
a492 4
int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
	{
	const EVP_CIPHER *enc=NULL;
	char *p,c;
d495 1
a495 1
	cipher->cipher=NULL;
d497 16
a512 8
		return(1);
	if (strncmp(header,"Proc-Type: ",11) != 0)
		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_PROC_TYPE); return(0); }
	header+=11;
	if (*header != '4') return(0); header++;
	if (*header != ',') return(0); header++;
	if (strncmp(header,"ENCRYPTED",9) != 0)
		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_ENCRYPTED); return(0); }
d515 4
a518 2
	if (*header == '\0')
		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_SHORT_HEADER); return(0); }
d520 8
a527 7
	if (strncmp(header,"DEK-Info: ",10) != 0)
		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_DEK_INFO); return(0); }
	header+=10;

	p=header;
	for (;;)
		{
d530 1
a530 1
			((c >= '0') && (c <= '9'))))
d533 4
a536 4
		}
	*header='\0';
	cipher->cipher=enc=EVP_get_cipherbyname(p);
	*header=c;
d539 7
a545 7
	if (enc == NULL)
		{
		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_UNSUPPORTED_ENCRYPTION);
		return(0);
		}
	if (!load_iv(header_pp,&(cipher->iv[0]),enc->iv_len))
		return(0);
d547 2
a548 2
	return(1);
	}
d550 4
a553 3
static int load_iv(char **fromp, unsigned char *to, int num)
	{
	int v,i;
d557 4
a560 4
	for (i=0; i<num; i++) to[i]=0;
	num*=2;
	for (i=0; i<num; i++)
		{
d562 1
a562 1
			v= *from-'0';
d564 1
a564 1
			v= *from-'A'+10;
d566 5
a570 6
			v= *from-'a'+10;
		else
			{
			PEMerr(PEM_F_LOAD_IV,PEM_R_BAD_IV_CHARS);
			return(0);
			}
d572 2
a573 2
		to[i/2]|=v<<(long)((!(i&1))*4);
		}
d575 3
a577 3
	*fromp=from;
	return(1);
	}
d580 15
a594 16
int PEM_write(FILE *fp, char *name, char *header, unsigned char *data,
	     long len)
        {
        BIO *b;
        int ret;

        if ((b=BIO_new(BIO_s_file())) == NULL)
		{
		PEMerr(PEM_F_PEM_WRITE,ERR_R_BUF_LIB);
                return(0);
		}
        BIO_set_fp(b,fp,BIO_NOCLOSE);
        ret=PEM_write_bio(b, name, header, data,len);
        BIO_free(b);
        return(ret);
        }
d597 5
a601 4
int PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data,
	     long len)
	{
	int nlen,n,i,j,outl;
d604 2
a605 2
	int reason=ERR_R_BUF_LIB;
	
d607 6
a612 1
	nlen=strlen(name);
d614 4
a617 10
	if (	(BIO_write(bp,"-----BEGIN ",11) != 11) ||
		(BIO_write(bp,name,nlen) != nlen) ||
		(BIO_write(bp,"-----\n",6) != 6))
		goto err;
		
	i=strlen(header);
	if (i > 0)
		{
		if (	(BIO_write(bp,header,i) != i) ||
			(BIO_write(bp,"\n",1) != 1))
d619 1
a619 1
		}
d621 3
a623 4
	buf = malloc(PEM_BUFSIZE*8);
	if (buf == NULL)
		{
		reason=ERR_R_MALLOC_FAILURE;
d625 1
a625 1
		}
d627 5
a631 6
	i=j=0;
	while (len > 0)
		{
		n=(int)((len>(PEM_BUFSIZE*5))?(PEM_BUFSIZE*5):len);
		EVP_EncodeUpdate(&ctx,buf,&outl,&(data[j]),n);
		if ((outl) && (BIO_write(bp,(char *)buf,outl) != outl))
d633 8
a640 7
		i+=outl;
		len-=n;
		j+=n;
		}
	EVP_EncodeFinal(&ctx,buf,&outl);
	if ((outl > 0) && (BIO_write(bp,(char *)buf,outl) != outl)) goto err;
	OPENSSL_cleanse(buf, PEM_BUFSIZE*8);
d643 3
a645 3
	if (	(BIO_write(bp,"-----END ",9) != 9) ||
		(BIO_write(bp,name,nlen) != nlen) ||
		(BIO_write(bp,"-----\n",6) != 6))
d647 2
a648 1
	return(i+outl);
d651 1
a651 1
		OPENSSL_cleanse(buf, PEM_BUFSIZE*8);
d654 3
a656 3
	PEMerr(PEM_F_PEM_WRITE_BIO,reason);
	return(0);
	}
d659 15
a673 16
int PEM_read(FILE *fp, char **name, char **header, unsigned char **data,
	     long *len)
        {
        BIO *b;
        int ret;

        if ((b=BIO_new(BIO_s_file())) == NULL)
		{
		PEMerr(PEM_F_PEM_READ,ERR_R_BUF_LIB);
                return(0);
		}
        BIO_set_fp(b,fp,BIO_NOCLOSE);
        ret=PEM_read_bio(b, name, header, data,len);
        BIO_free(b);
        return(ret);
        }
d676 4
a679 3
int PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
	     long *len)
	{
d681 1
a681 1
	int end=0,i,k,bl=0,hl=0,nohead=0;
d685 6
a690 7
	BUF_MEM *dataB,*tmpB;
	
	nameB=BUF_MEM_new();
	headerB=BUF_MEM_new();
	dataB=BUF_MEM_new();
	if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL))
		{
d694 3
a696 3
		PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
		return(0);
		}
d698 3
a700 4
	buf[254]='\0';
	for (;;)
		{
		i=BIO_gets(bp,buf,254);
d702 2
a703 3
		if (i <= 0)
			{
			PEMerr(PEM_F_PEM_READ_BIO,PEM_R_NO_START_LINE);
d705 1
a705 1
			}
d707 4
a710 2
		while ((i >= 0) && (buf[i] <= ' ')) i--;
		buf[++i]='\n'; buf[++i]='\0';
d712 2
a713 3
		if (strncmp(buf,"-----BEGIN ",11) == 0)
			{
			i=strlen(&(buf[11]));
d715 1
a715 1
			if (strncmp(&(buf[11+i-6]),"-----\n",6) != 0)
d717 3
a719 3
			if (!BUF_MEM_grow(nameB,i+9))
				{
				PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
d721 23
a743 3
				}
			memcpy(nameB->data,&(buf[11]),i-6);
			nameB->data[i-6]='\0';
d745 3
a747 1
			}
d749 2
a750 18
	hl=0;
	if (!BUF_MEM_grow(headerB,256))
		{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
	headerB->data[0]='\0';
	for (;;)
		{
		i=BIO_gets(bp,buf,254);
		if (i <= 0) break;

		while ((i >= 0) && (buf[i] <= ' ')) i--;
		buf[++i]='\n'; buf[++i]='\0';

		if (buf[0] == '\n') break;
		if (!BUF_MEM_grow(headerB,hl+i+9))
			{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
		if (strncmp(buf,"-----END ",9) == 0)
			{
			nohead=1;
d752 5
a756 16
			}
		memcpy(&(headerB->data[hl]),buf,i);
		headerB->data[hl+i]='\0';
		hl+=i;
		}

	bl=0;
	if (!BUF_MEM_grow(dataB,1024))
		{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
	dataB->data[0]='\0';
	if (!nohead)
		{
		for (;;)
			{
			i=BIO_gets(bp,buf,254);
			if (i <= 0) break;
d758 11
a768 2
			while ((i >= 0) && (buf[i] <= ' ')) i--;
			buf[++i]='\n'; buf[++i]='\0';
d770 10
a779 2
			if (i != 65) end=1;
			if (strncmp(buf,"-----END ",9) == 0)
d781 3
a783 4
			if (i > 65) break;
			if (!BUF_MEM_grow_clean(dataB,i+bl+9))
				{
				PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
d785 14
a798 12
				}
			memcpy(&(dataB->data[bl]),buf,i);
			dataB->data[bl+i]='\0';
			bl+=i;
			if (end)
				{
				buf[0]='\0';
				i=BIO_gets(bp,buf,254);
				if (i <= 0) break;

				while ((i >= 0) && (buf[i] <= ' ')) i--;
				buf[++i]='\n'; buf[++i]='\0';
a800 1
				}
d803 11
a813 13
	else
		{
		tmpB=headerB;
		headerB=dataB;
		dataB=tmpB;
		bl=hl;
		}
	i=strlen(nameB->data);
	if (	(strncmp(buf,"-----END ",9) != 0) ||
		(strncmp(nameB->data,&(buf[9]),i) != 0) ||
		(strncmp(&(buf[9+i]),"-----\n",6) != 0))
		{
		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_END_LINE);
d815 1
a815 1
		}
d818 20
a837 21
	i=EVP_DecodeUpdate(&ctx,
		(unsigned char *)dataB->data,&bl,
		(unsigned char *)dataB->data,bl);
	if (i < 0)
		{
		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);
		goto err;
		}
	i=EVP_DecodeFinal(&ctx,(unsigned char *)&(dataB->data[bl]),&k);
	if (i < 0)
		{
		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);
		goto err;
		}
	bl+=k;

	if (bl == 0) goto err;
	*name=nameB->data;
	*header=headerB->data;
	*data=(unsigned char *)dataB->data;
	*len=bl;
d841 2
a842 1
	return(1);
d847 2
a848 2
	return(0);
	}
d855 3
a857 2
int pem_check_suffix(const char *pem_str, const char *suffix)
	{
d861 1
d871 1
a871 2
	}

@


1.19
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d140 3
a142 3
	BUF_strlcat(buf,"Proc-Type: 4,",PEM_BUFSIZE);
	BUF_strlcat(buf,str,PEM_BUFSIZE);
	BUF_strlcat(buf,"\n",PEM_BUFSIZE);
d151 3
a153 3
	BUF_strlcat(buf,"DEK-Info: ",PEM_BUFSIZE);
	BUF_strlcat(buf,type,PEM_BUFSIZE);
	BUF_strlcat(buf,",",PEM_BUFSIZE);
@


1.18
log
@Do not feed RSA private key information to the random subsystem as
entropy.  It might be fed to a pluggable random subsystem....

What were they thinking?!

ok guenther
@
text
@d291 3
a293 3
		OPENSSL_free(nm);
		OPENSSL_free(header);
		OPENSSL_free(data);
d307 3
a309 3
	if (!ret || !pnm) OPENSSL_free(nm);
	OPENSSL_free(header);
	if (!ret) OPENSSL_free(data);
d363 1
a363 1
	data=(unsigned char *)OPENSSL_malloc((unsigned int)dsize+20);
d430 1
a430 1
		OPENSSL_free(data);
d602 1
a602 1
	buf = OPENSSL_malloc(PEM_BUFSIZE*8);
d623 1
a623 1
	OPENSSL_free(buf);
d633 1
a633 1
		OPENSSL_free(buf);
d812 3
a814 3
	OPENSSL_free(nameB);
	OPENSSL_free(headerB);
	OPENSSL_free(dataB);
@


1.17
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@a386 1
		RAND_add(data,i,0);/* put in the RSA key. */
@


1.16
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a384 4
#ifdef CHARSET_EBCDIC
			/* Convert the pass phrase from EBCDIC */
			ebcdic2ascii(buf, buf, klen);
#endif
a456 5
#ifdef CHARSET_EBCDIC
	/* Convert the pass phrase from EBCDIC */
	ebcdic2ascii(buf, buf, klen);
#endif

a509 1
#ifndef CHARSET_EBCDIC
a512 5
#else
		if (!(	isupper(c) || (c == '-') ||
			isdigit(c)))
			break;
#endif
@


1.15
log
@openssl-1.0.0e: resolve conflicts
@
text
@d397 2
a398 1
		EVP_BytesToKey(enc,EVP_md5(),iv,kstr,klen,1,key,NULL);
d410 5
a414 3
		EVP_EncryptInit_ex(&ctx,enc,NULL,key,iv);
		EVP_EncryptUpdate(&ctx,data,&j,data,i);
		EVP_EncryptFinal_ex(&ctx,&(data[j]),&i);
d416 2
a418 1
		ret=1;
d466 3
a468 2
	EVP_BytesToKey(cipher->cipher,EVP_md5(),&(cipher->iv[0]),
		(unsigned char *)buf,klen,1,key,NULL);
d472 5
a476 3
	EVP_DecryptInit_ex(&ctx,cipher->cipher,NULL, key,&(cipher->iv[0]));
	EVP_DecryptUpdate(&ctx,data,&i,data,j);
	o=EVP_DecryptFinal_ex(&ctx,&(data[i]),&j);
@


1.14
log
@resolve conflicts, fix local changes
@
text
@a484 1
	int o;
a523 1
	o=OBJ_sn2nid(p);
@


1.13
log
@resolve conflicts
@
text
@d60 1
d69 1
d73 3
d83 1
d108 1
a108 1
		i=EVP_read_pw_string(buf,num,prompt,w);
d192 21
a212 2
	if(!strcmp(nm,PEM_STRING_PKCS8) &&
		!strcmp(name,PEM_STRING_EVP_PKEY)) return 1;
d214 25
a238 5
	if(!strcmp(nm,PEM_STRING_PKCS8INF) &&
		 !strcmp(name,PEM_STRING_EVP_PKEY)) return 1;

	if(!strcmp(nm,PEM_STRING_RSA) &&
		!strcmp(name,PEM_STRING_EVP_PKEY)) return 1;
a239 5
	if(!strcmp(nm,PEM_STRING_DSA) &&
		 !strcmp(name,PEM_STRING_EVP_PKEY)) return 1;

 	if(!strcmp(nm,PEM_STRING_ECPRIVATEKEY) &&
 		 !strcmp(name,PEM_STRING_EVP_PKEY)) return 1;
d262 8
d315 1
a315 1
		   char *x, const EVP_CIPHER *enc, unsigned char *kstr,
d334 1
a334 1
		       char *x, const EVP_CIPHER *enc, unsigned char *kstr,
d833 22
@


1.12
log
@resolve conflicts
@
text
@d219 3
@


1.11
log
@resolve conflicts
@
text
@d72 1
a72 1
const char *PEM_version="PEM" OPENSSL_VERSION_PTEXT;
d84 1
a84 1
	PEMerr(PEM_F_DEF_CALLBACK,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d105 1
a105 1
			PEMerr(PEM_F_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
d161 2
a162 2
char *PEM_ASN1_read(char *(*d2i)(), const char *name, FILE *fp, char **x,
	     pem_password_cb *cb, void *u)
d165 1
a165 1
        char *ret;
d198 2
d263 3
a265 3
int PEM_ASN1_write(int (*i2d)(), const char *name, FILE *fp, char *x,
	     const EVP_CIPHER *enc, unsigned char *kstr, int klen,
	     pem_password_cb *callback, void *u)
d282 3
a284 3
int PEM_ASN1_write_bio(int (*i2d)(), const char *name, BIO *bp, char *x,
	     const EVP_CIPHER *enc, unsigned char *kstr, int klen,
	     pem_password_cb *callback, void *u)
d341 1
a341 1
		OPENSSL_assert(enc->iv_len <= sizeof iv);
d582 1
d591 2
a592 1
	if (buf)
d594 1
@


1.10
log
@merge 0.9.7d
@
text
@d76 1
a76 1
static int load_iv(unsigned char **fromp,unsigned char *to, int num);
d304 1
a304 1
		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);
d435 1
d482 2
a483 1
	if (!load_iv((unsigned char **)&header,&(cipher->iv[0]),enc->iv_len)) return(0);
d488 1
a488 1
static int load_iv(unsigned char **fromp, unsigned char *to, int num)
d491 1
a491 1
	unsigned char *from;
d628 3
@


1.9
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d134 3
a136 3
	strlcat(buf,"Proc-Type: 4,",PEM_BUFSIZE);
	strlcat(buf,str,PEM_BUFSIZE);
	strlcat(buf,"\n",PEM_BUFSIZE);
d145 3
a147 3
	strlcat(buf,"DEK-Info: ",PEM_BUFSIZE);
	strlcat(buf,type,PEM_BUFSIZE);
	strlcat(buf,",",PEM_BUFSIZE);
d538 1
a538 1
	unsigned char *buf;
d558 1
a558 1
	buf=(unsigned char *)OPENSSL_malloc(PEM_BUFSIZE*8);
d579 1
d586 2
@


1.8
log
@str{cat,cpy}/sprintf cleanup. markus@@, deraadt@@ ok
@
text
@d141 1
a141 1
	static unsigned char map[17]="0123456789ABCDEF";
d254 1
a254 1
	if (!pnm) OPENSSL_free(nm);
d309 1
d339 1
d346 3
a348 1
		if (kstr == (unsigned char *)buf) memset(buf,0,PEM_BUFSIZE);
d371 4
a374 4
	memset(key,0,sizeof(key));
	memset(iv,0,sizeof(iv));
	memset((char *)&ctx,0,sizeof(ctx));
	memset(buf,0,PEM_BUFSIZE);
d377 1
a377 1
		memset(data,0,(unsigned int)dsize);
d418 2
a419 2
	memset((char *)buf,0,sizeof(buf));
	memset((char *)key,0,sizeof(key));
d700 1
a700 1
			if (!BUF_MEM_grow(dataB,i+bl+9))
@


1.7
log
@merge with openssl-0.9.7-stable-SNAP-20020911,
new minor for libcrypto (_X509_REQ_print_ex)
tested by miod@@, pb@@
@
text
@d134 3
a136 3
	strcat(buf,"Proc-Type: 4,");
	strcat(buf,str);
	strcat(buf,"\n");
d145 3
a147 3
	strcat(buf,"DEK-Info: ");
	strcat(buf,type);
	strcat(buf,",");
d149 2
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d369 5
a373 2
	memset(data,0,(unsigned int)dsize);
	OPENSSL_free(data);
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d68 1
a68 1
#ifndef NO_DES
a75 1
static int def_callback(char *buf, int num, int w, void *userdata);
a77 8
static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder,
				int nid, const EVP_CIPHER *enc,
				char *kstr, int klen,
				pem_password_cb *cb, void *u);
static int do_pk8pkey_fp(FILE *bp, EVP_PKEY *x, int isder,
				int nid, const EVP_CIPHER *enc,
				char *kstr, int klen,
				pem_password_cb *cb, void *u);
d79 1
a79 1
static int def_callback(char *buf, int num, int w, void *key)
d81 1
a81 1
#ifdef NO_FP_API
d158 1
a158 1
#ifndef NO_FP_API
d218 1
a218 1
char *PEM_ASN1_read_bio(char *(*d2i)(), const char *name, BIO *bp, char **x,
d223 1
a223 1
	unsigned char *p=NULL,*data=NULL;
d225 1
a225 1
	char *ret=NULL;
d233 1
a233 1
			return(NULL);
d242 9
a250 40
	p=data;
	if (strcmp(name,PEM_STRING_EVP_PKEY) == 0) {
		if (strcmp(nm,PEM_STRING_RSA) == 0)
			ret=d2i(EVP_PKEY_RSA,x,&p,len);
		else if (strcmp(nm,PEM_STRING_DSA) == 0)
			ret=d2i(EVP_PKEY_DSA,x,&p,len);
		else if (strcmp(nm,PEM_STRING_PKCS8INF) == 0) {
			PKCS8_PRIV_KEY_INFO *p8inf;
			p8inf=d2i_PKCS8_PRIV_KEY_INFO(
					(PKCS8_PRIV_KEY_INFO **) x, &p, len);
			ret = (char *)EVP_PKCS82PKEY(p8inf);
			PKCS8_PRIV_KEY_INFO_free(p8inf);
		} else if (strcmp(nm,PEM_STRING_PKCS8) == 0) {
			PKCS8_PRIV_KEY_INFO *p8inf;
			X509_SIG *p8;
			int klen;
			char psbuf[PEM_BUFSIZE];
			p8 = d2i_X509_SIG(NULL, &p, len);
			if(!p8) goto p8err;
			if (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);
			else klen=def_callback(psbuf,PEM_BUFSIZE,0,u);
			if (klen <= 0) {
				PEMerr(PEM_F_PEM_ASN1_READ_BIO,
						PEM_R_BAD_PASSWORD_READ);
				goto err;
			}
			p8inf = M_PKCS8_decrypt(p8, psbuf, klen);
			X509_SIG_free(p8);
			if(!p8inf) goto p8err;
			ret = (char *)EVP_PKCS82PKEY(p8inf);
			if(x) {
				if(*x) EVP_PKEY_free((EVP_PKEY *)*x);
				*x = ret;
			}
			PKCS8_PRIV_KEY_INFO_free(p8inf);
		}
	} else	ret=d2i(x,&p,len);
p8err:
	if (ret == NULL)
		PEMerr(PEM_F_PEM_ASN1_READ_BIO,ERR_R_ASN1_LIB);
d252 1
a252 1
	OPENSSL_free(nm);
d254 2
a255 2
	OPENSSL_free(data);
	return(ret);
d258 1
a258 1
#ifndef NO_FP_API
d321 1
a321 1
				klen=def_callback(buf,PEM_BUFSIZE,1,u);
d336 1
a336 1
		if (RAND_pseudo_bytes(iv,8) < 0)	/* Generate a salt */
d346 1
a346 1
		PEM_dek_info(buf,objstr,8,(char *)iv);
d348 3
a350 2
	
		EVP_EncryptInit(&ctx,enc,key,iv);
d352 2
a353 1
		EVP_EncryptFinal(&ctx,&(data[j]),&i);
d387 1
a387 1
		klen=def_callback(buf,PEM_BUFSIZE,0,u);
d404 2
a405 1
	EVP_DecryptInit(&ctx,cipher->cipher,key,&(cipher->iv[0]));
d407 1
a407 1
	o=EVP_DecryptFinal(&ctx,&(data[i]),&j);
d472 1
a472 1
	if (!load_iv((unsigned char **)&header,&(cipher->iv[0]),8)) return(0);
d506 1
a506 1
#ifndef NO_FP_API
d580 1
a580 1
#ifndef NO_FP_API
a759 167

/* These functions write a private key in PKCS#8 format: it is a "drop in"
 * replacement for PEM_write_bio_PrivateKey() and friends. As usual if 'enc'
 * is NULL then it uses the unencrypted private key form. The 'nid' versions
 * uses PKCS#5 v1.5 PBE algorithms whereas the others use PKCS#5 v2.0.
 */

int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
				  char *kstr, int klen,
				  pem_password_cb *cb, void *u)
{
	return do_pk8pkey(bp, x, 0, nid, NULL, kstr, klen, cb, u);
}

int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
				  char *kstr, int klen,
				  pem_password_cb *cb, void *u)
{
	return do_pk8pkey(bp, x, 0, -1, enc, kstr, klen, cb, u);
}

int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
				  char *kstr, int klen,
				  pem_password_cb *cb, void *u)
{
	return do_pk8pkey(bp, x, 1, -1, enc, kstr, klen, cb, u);
}

int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
				  char *kstr, int klen,
				  pem_password_cb *cb, void *u)
{
	return do_pk8pkey(bp, x, 1, nid, NULL, kstr, klen, cb, u);
}

static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
				  char *kstr, int klen,
				  pem_password_cb *cb, void *u)
{
	X509_SIG *p8;
	PKCS8_PRIV_KEY_INFO *p8inf;
	char buf[PEM_BUFSIZE];
	int ret;
	if(!(p8inf = EVP_PKEY2PKCS8(x))) {
		PEMerr(PEM_F_PEM_WRITE_BIO_PKCS8PRIVATEKEY,
					PEM_R_ERROR_CONVERTING_PRIVATE_KEY);
		return 0;
	}
	if(enc || (nid != -1)) {
		if(!kstr) {
			if(!cb) klen = def_callback(buf, PEM_BUFSIZE, 1, u);
			else klen = cb(buf, PEM_BUFSIZE, 1, u);
			if(klen <= 0) {
				PEMerr(PEM_F_PEM_WRITE_BIO_PKCS8PRIVATEKEY,
								PEM_R_READ_KEY);
				PKCS8_PRIV_KEY_INFO_free(p8inf);
				return 0;
			}
				
			kstr = buf;
		}
		p8 = PKCS8_encrypt(nid, enc, kstr, klen, NULL, 0, 0, p8inf);
		if(kstr == buf) memset(buf, 0, klen);
		PKCS8_PRIV_KEY_INFO_free(p8inf);
		if(isder) ret = i2d_PKCS8_bio(bp, p8);
		else ret = PEM_write_bio_PKCS8(bp, p8);
		X509_SIG_free(p8);
		return ret;
	} else {
		if(isder) ret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
		else ret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);
		PKCS8_PRIV_KEY_INFO_free(p8inf);
		return ret;
	}
}

/* Finally the DER version to read PKCS#8 encrypted private keys. It has to be
 * here to access the default callback.
 */

EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
	PKCS8_PRIV_KEY_INFO *p8inf = NULL;
	X509_SIG *p8 = NULL;
	int klen;
	EVP_PKEY *ret;
	char psbuf[PEM_BUFSIZE];
	p8 = d2i_PKCS8_bio(bp, NULL);
	if(!p8) return NULL;
	if (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);
	else klen=def_callback(psbuf,PEM_BUFSIZE,0,u);
	if (klen <= 0) {
		PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_BIO, PEM_R_BAD_PASSWORD_READ);
		X509_SIG_free(p8);
		return NULL;	
	}
	p8inf = M_PKCS8_decrypt(p8, psbuf, klen);
	X509_SIG_free(p8);
	if(!p8inf) return NULL;
	ret = EVP_PKCS82PKEY(p8inf);
	PKCS8_PRIV_KEY_INFO_free(p8inf);
	if(!ret) return NULL;
	if(x) {
		if(*x) EVP_PKEY_free(*x);
		*x = ret;
	}
	return ret;
}

#ifndef NO_FP_API

int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
				  char *kstr, int klen,
				  pem_password_cb *cb, void *u)
{
	return do_pk8pkey_fp(fp, x, 1, -1, enc, kstr, klen, cb, u);
}

int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,
				  char *kstr, int klen,
				  pem_password_cb *cb, void *u)
{
	return do_pk8pkey_fp(fp, x, 1, nid, NULL, kstr, klen, cb, u);
}

int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
				  char *kstr, int klen,
				  pem_password_cb *cb, void *u)
{
	return do_pk8pkey_fp(fp, x, 0, nid, NULL, kstr, klen, cb, u);
}

int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
			      char *kstr, int klen, pem_password_cb *cb, void *u)
{
	return do_pk8pkey_fp(fp, x, 0, -1, enc, kstr, klen, cb, u);
}

static int do_pk8pkey_fp(FILE *fp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
				  char *kstr, int klen,
				  pem_password_cb *cb, void *u)
{
	BIO *bp;
	int ret;
	if(!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
		PEMerr(PEM_F_PEM_F_DO_PK8KEY_FP,ERR_R_BUF_LIB);
                return(0);
	}
	ret = do_pk8pkey(bp, x, isder, nid, enc, kstr, klen, cb, u);
	BIO_free(bp);
	return ret;
}

EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
	BIO *bp;
	EVP_PKEY *ret;
	if(!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
		PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_FP,ERR_R_BUF_LIB);
                return NULL;
	}
	ret = d2i_PKCS8PrivateKey_bio(bp, x, cb, u);
	BIO_free(bp);
	return ret;
}

#endif
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d245 3
a247 3
		Free(nm);
		Free(header);
		Free(data);
d292 3
a294 3
	Free(nm);
	Free(header);
	Free(data);
d347 1
a347 1
	data=(unsigned char *)Malloc((unsigned int)dsize+20);
d408 1
a408 1
	Free(data);
d586 1
a586 1
	buf=(unsigned char *)Malloc(PEM_BUFSIZE*8);
d606 1
a606 1
	Free(buf);
d787 3
a789 3
	Free(nameB);
	Free(headerB);
	Free(dataB);
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d376 1
a376 1
		if (RAND_bytes(iv,8) <= 0)	/* Generate a salt */
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d78 9
d88 1
a88 1
static int def_callback(char *buf, int num, int w, void *userdata)
d98 6
d186 41
d238 7
a244 16
		if (!PEM_read_bio(bp,&nm,&header,&data,&len)) return(NULL);
		if (	(strcmp(nm,name) == 0) ||
			((strcmp(nm,PEM_STRING_RSA) == 0) &&
			 (strcmp(name,PEM_STRING_EVP_PKEY) == 0)) ||
			((strcmp(nm,PEM_STRING_DSA) == 0) &&
			 (strcmp(name,PEM_STRING_EVP_PKEY) == 0)) ||
			((strcmp(nm,PEM_STRING_PKCS8) == 0) &&
			 (strcmp(name,PEM_STRING_EVP_PKEY) == 0)) ||
			((strcmp(nm,PEM_STRING_PKCS8INF) == 0) &&
			 (strcmp(name,PEM_STRING_EVP_PKEY) == 0)) ||
			((strcmp(nm,PEM_STRING_X509_OLD) == 0) &&
			 (strcmp(name,PEM_STRING_X509) == 0)) ||
			((strcmp(nm,PEM_STRING_X509_REQ_OLD) == 0) &&
			 (strcmp(name,PEM_STRING_X509_REQ) == 0)) 
			)
			break;
d268 1
a268 1
			p8 = d2i_X509_SIG((X509_SIG **)x, &p, len);
d281 4
d375 3
a377 2
		RAND_seed(data,i);/* put in the RSA key. */
		RAND_bytes(iv,8);	/* Generate a salt */
d798 4
a801 4
/* This function writes a private key in PKCS#8 format: it is a "drop in"
 * replacement for PEM_write_bio_PrivateKey(). As usual if 'enc' is NULL then
 * it uses the unencrypted private key form. It uses PKCS#5 v2.0 password based
 * encryption algorithms.
d804 7
d815 21
d845 1
a845 1
	if(enc) {
d858 1
a858 1
		p8 = PKCS8_encrypt(-1, enc, kstr, klen, NULL, 0, 0, p8inf);
d861 2
a862 1
		ret = PEM_write_bio_PKCS8(bp, p8);
d866 2
a867 1
		ret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);
d873 56
d932 7
d942 1
a942 1
		PEMerr(PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY,ERR_R_BUF_LIB);
d945 1
a945 1
	ret = PEM_write_bio_PKCS8PrivateKey(bp, x, enc, kstr, klen, cb, u);
d949 15
@


1.1
log
@Initial revision
@
text
@d61 7
a67 6
#include "buffer.h"
#include "objects.h"
#include "evp.h"
#include "rand.h"
#include "x509.h"
#include "pem.h"
d69 1
a69 1
#include "des.h"
d72 1
a72 1
char *PEM_version="PEM part of SSLeay 0.9.0b 29-Jun-1998";
d76 1
a76 6
/* PEMerr(PEM_F_PEM_WRITE_BIO,ERR_R_MALLOC_FAILURE);
 * PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
 */

#ifndef NOPROTO
static int def_callback(char *buf, int num, int w);
a77 4
#else
static int def_callback();
static int load_iv();
#endif
d79 1
a79 4
static int def_callback(buf, num, w)
char *buf;
int num;
int w;
d88 1
a88 1
	char *prompt;
d115 1
a115 3
void PEM_proc_type(buf, type)
char *buf;
int type;
d117 1
a117 1
	char *str;
d133 1
a133 5
void PEM_dek_info(buf, type, len, str)
char *buf;
char *type;
int len;
char *str;
d153 2
a154 6
char *PEM_ASN1_read(d2i,name,fp, x, cb)
char *(*d2i)();
char *name;
FILE *fp;
char **x;
int (*cb)();
d165 1
a165 1
        ret=PEM_ASN1_read_bio(d2i,name,b,x,cb);
d171 2
a172 6
char *PEM_ASN1_read_bio(d2i,name,bp, x, cb)
char *(*d2i)();
char *name;
BIO *bp;
char **x;
int (*cb)();
d188 4
d195 1
a195 1
			 (strcmp(name,PEM_STRING_X509_REQ) == 0))
d203 1
a203 1
	if (!PEM_do_header(&cipher,data,&len,cb)) goto err;
d205 1
a205 2
	if (strcmp(name,PEM_STRING_EVP_PKEY) == 0)
		{
d210 25
d236 2
a237 2
	else	
		ret=d2i(x,&p,len);
d248 3
a250 9
int PEM_ASN1_write(i2d,name,fp, x, enc, kstr, klen, callback)
int (*i2d)();
char *name;
FILE *fp;
char *x;
EVP_CIPHER *enc;
unsigned char *kstr;
int klen;
int (*callback)();
d261 1
a261 1
        ret=PEM_ASN1_write_bio(i2d,name,b,x,enc,kstr,klen,callback);
d267 3
a269 9
int PEM_ASN1_write_bio(i2d,name,bp, x, enc, kstr, klen, callback)
int (*i2d)();
char *name;
BIO *bp;
char *x;
EVP_CIPHER *enc;
unsigned char *kstr;
int klen;
int (*callback)();
d274 1
a274 2
	char *objstr=NULL;
#define PEM_BUFSIZE	1024
d310 1
a310 1
				klen=def_callback(buf,PEM_BUFSIZE,1);
d312 1
a312 1
				klen=(*callback)(buf,PEM_BUFSIZE,1);
d318 4
d360 2
a361 5
int PEM_do_header(cipher, data, plen, callback)
EVP_CIPHER_INFO *cipher;
unsigned char *data;
long *plen;
int (*callback)();
d373 1
a373 1
		klen=def_callback(buf,PEM_BUFSIZE,0);
d375 1
a375 1
		klen=callback(buf,PEM_BUFSIZE,0);
d381 5
d406 1
a406 3
int PEM_get_EVP_CIPHER_INFO(header,cipher)
char *header;
EVP_CIPHER_INFO *cipher;
d409 1
a409 1
	EVP_CIPHER *enc=NULL;
d435 1
d439 5
d462 1
a462 3
static int load_iv(fromp,to,num)
unsigned char **fromp,*to;
int num;
d492 2
a493 6
int PEM_write(fp, name, header, data,len)
FILE *fp;
char *name;
char *header;
unsigned char *data;
long len;
d510 2
a511 6
int PEM_write_bio(bp, name, header, data,len)
BIO *bp;
char *name;
char *header;
unsigned char *data;
long len;
d566 2
a567 6
int PEM_read(fp, name, header, data,len)
FILE *fp;
char **name;
char **header;
unsigned char **data;
long *len;
d584 2
a585 6
int PEM_read_bio(bp, name, header, data, len)
BIO *bp;
char **name;
char **header;
unsigned char **data;
long *len;
d628 1
a628 1
			strncpy(nameB->data,&(buf[11]),(unsigned int)i-6);
d653 1
a653 1
		strncpy(&(headerB->data[hl]),buf,(unsigned int)i);
d681 1
a681 1
			strncpy(&(dataB->data[bl]),buf,(unsigned int)i);
d706 1
a706 1
		(strncmp(nameB->data,&(buf[9]),(unsigned int)i) != 0) ||
d745 59
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 8
a68 9
#include <openssl/buffer.h>
#include <openssl/objects.h>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/pkcs12.h>
#ifndef OPENSSL_NO_DES
#include <openssl/des.h>
d71 1
a71 1
const char *PEM_version="PEM" OPENSSL_VERSION_PTEXT;
d75 6
d82 4
a85 1
static int check_pem(const char *nm, const char *name);
d87 4
a90 1
int PEM_def_callback(char *buf, int num, int w, void *key)
d92 1
a92 1
#ifdef OPENSSL_NO_FP_API
d99 1
a99 7
	const char *prompt;
	if(key) {
		i=strlen(key);
		i=(i > num)?num:i;
		memcpy(buf,key,i);
		return(i);
	}
d126 3
a128 1
void PEM_proc_type(char *buf, int type)
d130 1
a130 1
	const char *str;
d146 5
a150 1
void PEM_dek_info(char *buf, const char *type, int len, char *str)
d169 7
a175 3
#ifndef OPENSSL_NO_FP_API
char *PEM_ASN1_read(char *(*d2i)(), const char *name, FILE *fp, char **x,
	     pem_password_cb *cb, void *u)
d186 1
a186 1
        ret=PEM_ASN1_read_bio(d2i,name,b,x,cb,u);
d192 6
a197 43
static int check_pem(const char *nm, const char *name)
{
	/* Normal matching nm and name */
	if (!strcmp(nm,name)) return 1;

	/* Make PEM_STRING_EVP_PKEY match any private key */

	if(!strcmp(nm,PEM_STRING_PKCS8) &&
		!strcmp(name,PEM_STRING_EVP_PKEY)) return 1;

	if(!strcmp(nm,PEM_STRING_PKCS8INF) &&
		 !strcmp(name,PEM_STRING_EVP_PKEY)) return 1;

	if(!strcmp(nm,PEM_STRING_RSA) &&
		!strcmp(name,PEM_STRING_EVP_PKEY)) return 1;

	if(!strcmp(nm,PEM_STRING_DSA) &&
		 !strcmp(name,PEM_STRING_EVP_PKEY)) return 1;

	/* Permit older strings */

	if(!strcmp(nm,PEM_STRING_X509_OLD) &&
		!strcmp(name,PEM_STRING_X509)) return 1;

	if(!strcmp(nm,PEM_STRING_X509_REQ_OLD) &&
		!strcmp(name,PEM_STRING_X509_REQ)) return 1;

	/* Allow normal certs to be read as trusted certs */
	if(!strcmp(nm,PEM_STRING_X509) &&
		!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;

	if(!strcmp(nm,PEM_STRING_X509_OLD) &&
		!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;

	/* Some CAs use PKCS#7 with CERTIFICATE headers */
	if(!strcmp(nm, PEM_STRING_X509) &&
		!strcmp(name, PEM_STRING_PKCS7)) return 1;

	return 0;
}

int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
	     pem_password_cb *cb, void *u)
d201 1
a201 1
	unsigned char *data=NULL;
d203 1
a203 1
	int ret = 0;
d207 15
a221 10
		if (!PEM_read_bio(bp,&nm,&header,&data,&len)) {
			if(ERR_GET_REASON(ERR_peek_error()) ==
				PEM_R_NO_START_LINE)
				ERR_add_error_data(2, "Expecting: ", name);
			return 0;
		}
		if(check_pem(nm, name)) break;
		OPENSSL_free(nm);
		OPENSSL_free(header);
		OPENSSL_free(data);
d224 13
a236 10
	if (!PEM_do_header(&cipher,data,&len,cb,u)) goto err;

	*pdata = data;
	*plen = len;

	if (pnm)
		*pnm = nm;

	ret = 1;

d238 4
a241 4
	if (!pnm) OPENSSL_free(nm);
	OPENSSL_free(header);
	if (!ret) OPENSSL_free(data);
	return ret;
d244 10
a253 4
#ifndef OPENSSL_NO_FP_API
int PEM_ASN1_write(int (*i2d)(), const char *name, FILE *fp, char *x,
	     const EVP_CIPHER *enc, unsigned char *kstr, int klen,
	     pem_password_cb *callback, void *u)
d264 1
a264 1
        ret=PEM_ASN1_write_bio(i2d,name,b,x,enc,kstr,klen,callback,u);
d270 9
a278 3
int PEM_ASN1_write_bio(int (*i2d)(), const char *name, BIO *bp, char *x,
	     const EVP_CIPHER *enc, unsigned char *kstr, int klen,
	     pem_password_cb *callback, void *u)
d283 2
a284 1
	const char *objstr=NULL;
d306 1
a306 1
	data=(unsigned char *)OPENSSL_malloc((unsigned int)dsize+20);
d320 1
a320 1
				klen=PEM_def_callback(buf,PEM_BUFSIZE,1,u);
d322 1
a322 1
				klen=(*callback)(buf,PEM_BUFSIZE,1,u);
a327 4
#ifdef CHARSET_EBCDIC
			/* Convert the pass phrase from EBCDIC */
			ebcdic2ascii(buf, buf, klen);
#endif
d330 2
a331 3
		RAND_add(data,i,0);/* put in the RSA key. */
		if (RAND_pseudo_bytes(iv,enc->iv_len) < 0) /* Generate a salt */
			goto err;
d340 1
a340 1
		PEM_dek_info(buf,objstr,enc->iv_len,(char *)iv);
d342 2
a343 3

		EVP_CIPHER_CTX_init(&ctx);
		EVP_EncryptInit_ex(&ctx,enc,NULL,key,iv);
d345 1
a345 2
		EVP_EncryptFinal_ex(&ctx,&(data[j]),&i);
		EVP_CIPHER_CTX_cleanup(&ctx);
d362 1
a362 1
	OPENSSL_free(data);
d366 5
a370 2
int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
	     pem_password_cb *callback,void *u)
d382 1
a382 1
		klen=PEM_def_callback(buf,PEM_BUFSIZE,0,u);
d384 1
a384 1
		klen=callback(buf,PEM_BUFSIZE,0,u);
a389 5
#ifdef CHARSET_EBCDIC
	/* Convert the pass phrase from EBCDIC */
	ebcdic2ascii(buf, buf, klen);
#endif

d394 1
a394 2
	EVP_CIPHER_CTX_init(&ctx);
	EVP_DecryptInit_ex(&ctx,cipher->cipher,NULL, key,&(cipher->iv[0]));
d396 1
a396 1
	o=EVP_DecryptFinal_ex(&ctx,&(data[i]),&j);
d410 3
a412 1
int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
d415 1
a415 1
	const EVP_CIPHER *enc=NULL;
a440 1
#ifndef CHARSET_EBCDIC
a443 5
#else
		if (!(	isupper(c) || (c == '-') ||
			isdigit(c)))
			break;
#endif
d457 1
a457 1
	if (!load_iv((unsigned char **)&header,&(cipher->iv[0]),enc->iv_len)) return(0);
d462 3
a464 1
static int load_iv(unsigned char **fromp, unsigned char *to, int num)
d493 7
a499 3
#ifndef OPENSSL_NO_FP_API
int PEM_write(FILE *fp, char *name, char *header, unsigned char *data,
	     long len)
d516 6
a521 2
int PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data,
	     long len)
d544 1
a544 1
	buf=(unsigned char *)OPENSSL_malloc(PEM_BUFSIZE*8);
d564 1
a564 1
	OPENSSL_free(buf);
d575 7
a581 3
#ifndef OPENSSL_NO_FP_API
int PEM_read(FILE *fp, char **name, char **header, unsigned char **data,
	     long *len)
d598 6
a603 2
int PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
	     long *len)
d646 1
a646 1
			memcpy(nameB->data,&(buf[11]),i-6);
d671 1
a671 1
		memcpy(&(headerB->data[hl]),buf,i);
d699 1
a699 1
			memcpy(&(dataB->data[bl]),buf,i);
d724 1
a724 1
		(strncmp(nameB->data,&(buf[9]),i) != 0) ||
d753 3
a755 3
	OPENSSL_free(nameB);
	OPENSSL_free(headerB);
	OPENSSL_free(dataB);
@


1.1.1.3
log
@import openssl-0.9.7-stable-SNAP-20020911 (without idea)
@
text
@d369 2
a370 5
	if (data != NULL)
		{
		memset(data,0,(unsigned int)dsize);
		OPENSSL_free(data);
		}
@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@d141 1
a141 1
	static const unsigned char map[17]="0123456789ABCDEF";
d252 1
a252 1
	if (!ret || !pnm) OPENSSL_free(nm);
a306 1
	/* actually it needs the cipher block size extra... */
a335 1
		OPENSSL_assert(enc->iv_len <= sizeof iv);
d342 1
a342 3
		if (kstr == (unsigned char *)buf) OPENSSL_cleanse(buf,PEM_BUFSIZE);

		OPENSSL_assert(strlen(objstr)+23+2*enc->iv_len+13 <= sizeof buf);
d365 4
a368 4
	OPENSSL_cleanse(key,sizeof(key));
	OPENSSL_cleanse(iv,sizeof(iv));
	OPENSSL_cleanse((char *)&ctx,sizeof(ctx));
	OPENSSL_cleanse(buf,PEM_BUFSIZE);
d371 1
a371 1
		OPENSSL_cleanse(data,(unsigned int)dsize);
d412 2
a413 2
	OPENSSL_cleanse((char *)buf,sizeof(buf));
	OPENSSL_cleanse((char *)key,sizeof(key));
d694 1
a694 1
			if (!BUF_MEM_grow_clean(dataB,i+bl+9))
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@d134 3
a136 3
	BUF_strlcat(buf,"Proc-Type: 4,",PEM_BUFSIZE);
	BUF_strlcat(buf,str,PEM_BUFSIZE);
	BUF_strlcat(buf,"\n",PEM_BUFSIZE);
d145 3
a147 3
	BUF_strlcat(buf,"DEK-Info: ",PEM_BUFSIZE);
	BUF_strlcat(buf,type,PEM_BUFSIZE);
	BUF_strlcat(buf,",",PEM_BUFSIZE);
a148 2
	if (j + (len * 2) + 1 > PEM_BUFSIZE)
        	return;
d536 1
a536 1
	unsigned char *buf = NULL;
d556 1
a556 1
	buf = OPENSSL_malloc(PEM_BUFSIZE*8);
a576 1
	buf = NULL;
a582 2
	if (buf)
		OPENSSL_free(buf);
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d76 1
a76 1
static int load_iv(char **fromp,unsigned char *to, int num);
d304 1
a304 1
		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_ASN1_LIB);
a434 1
	char **header_pp = &header;
d481 1
a481 2
	if (!load_iv(header_pp,&(cipher->iv[0]),enc->iv_len))
		return(0);
d486 1
a486 1
static int load_iv(char **fromp, unsigned char *to, int num)
d489 1
a489 1
	char *from;
a625 3
		BUF_MEM_free(nameB);
		BUF_MEM_free(headerB);
		BUF_MEM_free(dataB);
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d72 1
a72 1
const char PEM_version[]="PEM" OPENSSL_VERSION_PTEXT;
d84 1
a84 1
	PEMerr(PEM_F_PEM_DEF_CALLBACK,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d105 1
a105 1
			PEMerr(PEM_F_PEM_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
d161 2
a162 2
void *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
		    pem_password_cb *cb, void *u)
d165 1
a165 1
        void *ret;
a197 2
 	if(!strcmp(nm,PEM_STRING_ECPRIVATEKEY) &&
 		 !strcmp(name,PEM_STRING_EVP_PKEY)) return 1;
d261 3
a263 3
int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,
		   char *x, const EVP_CIPHER *enc, unsigned char *kstr,
		   int klen, pem_password_cb *callback, void *u)
d280 3
a282 3
int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
		       char *x, const EVP_CIPHER *enc, unsigned char *kstr,
		       int klen, pem_password_cb *callback, void *u)
d339 1
a339 1
		OPENSSL_assert(enc->iv_len <= (int)sizeof(iv));
a579 1
	OPENSSL_cleanse(buf, PEM_BUFSIZE*8);
d588 1
a588 2
	if (buf) {
		OPENSSL_cleanse(buf, PEM_BUFSIZE*8);
a589 1
	}
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@a218 3
	if(!strcmp(nm, PEM_STRING_PKCS7_SIGNED) &&
		!strcmp(name, PEM_STRING_PKCS7)) return 1;

@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@a59 1
#include <ctype.h>
a67 1
#include "asn1_locl.h"
a70 3
#ifndef OPENSSL_NO_ENGINE
#include <openssl/engine.h>
#endif
a77 1
int pem_check_suffix(const char *pem_str, const char *suffix);
d102 1
a102 1
		i=EVP_read_pw_string_min(buf,MIN_LENGTH,num,prompt,w);
d186 8
a193 21
	if(!strcmp(name,PEM_STRING_EVP_PKEY))
		{
		int slen;
		const EVP_PKEY_ASN1_METHOD *ameth;
		if(!strcmp(nm,PEM_STRING_PKCS8))
			return 1;
		if(!strcmp(nm,PEM_STRING_PKCS8INF))
			return 1;
		slen = pem_check_suffix(nm, "PRIVATE KEY"); 
		if (slen > 0)
			{
			/* NB: ENGINE implementations wont contain
			 * a deprecated old private key decode function
			 * so don't look for them.
			 */
			ameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);
			if (ameth && ameth->old_priv_decode)
				return 1;
			}
		return 0;
		}
d195 2
a196 25
	if(!strcmp(name,PEM_STRING_PARAMETERS))
		{
		int slen;
		const EVP_PKEY_ASN1_METHOD *ameth;
		slen = pem_check_suffix(nm, "PARAMETERS"); 
		if (slen > 0)
			{
			ENGINE *e;
			ameth = EVP_PKEY_asn1_find_str(&e, nm, slen);
			if (ameth)
				{
				int r;
				if (ameth->param_decode)
					r = 1;
				else
					r = 0;
#ifndef OPENSSL_NO_ENGINE
				if (e)
					ENGINE_finish(e);
#endif
				return r;
				}
			}
		return 0;
		}
d198 2
a221 8
#ifndef OPENSSL_NO_CMS
	if(!strcmp(nm, PEM_STRING_X509) &&
		!strcmp(name, PEM_STRING_CMS)) return 1;
	/* Allow CMS to be read from PKCS#7 headers */
	if(!strcmp(nm, PEM_STRING_PKCS7) &&
		!strcmp(name, PEM_STRING_CMS)) return 1;
#endif

d267 1
a267 1
		   void *x, const EVP_CIPHER *enc, unsigned char *kstr,
d286 1
a286 1
		       void *x, const EVP_CIPHER *enc, unsigned char *kstr,
a784 22

/* Check pem string and return prefix length.
 * If for example the pem_str == "RSA PRIVATE KEY" and suffix = "PRIVATE KEY"
 * the return value is 3 for the string "RSA".
 */

int pem_check_suffix(const char *pem_str, const char *suffix)
	{
	int pem_len = strlen(pem_str);
	int suffix_len = strlen(suffix);
	const char *p;
	if (suffix_len + 1 >= pem_len)
		return 0;
	p = pem_str + pem_len - suffix_len;
	if (strcmp(p, suffix))
		return 0;
	p--;
	if (*p != ' ')
		return 0;
	return p - pem_str;
	}

@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@d485 1
d525 1
@


1.1.1.11
log
@Import OpenSSL 1.0.1g
@
text
@d397 1
a397 2
		if (!EVP_BytesToKey(enc,EVP_md5(),iv,kstr,klen,1,key,NULL))
			goto err;
d409 3
a411 5
		ret = 1;
		if (!EVP_EncryptInit_ex(&ctx,enc,NULL,key,iv)
			|| !EVP_EncryptUpdate(&ctx,data,&j,data,i)
			|| !EVP_EncryptFinal_ex(&ctx,&(data[j]),&i))
			ret = 0;
a412 2
		if (ret == 0)
			goto err;
d414 1
d462 2
a463 3
	if (!EVP_BytesToKey(cipher->cipher,EVP_md5(),&(cipher->iv[0]),
		(unsigned char *)buf,klen,1,key,NULL))
		return 0;
d467 3
a469 5
	o = EVP_DecryptInit_ex(&ctx,cipher->cipher,NULL, key,&(cipher->iv[0]));
	if (o)
		o = EVP_DecryptUpdate(&ctx,data,&i,data,j);
	if (o)
		o = EVP_DecryptFinal_ex(&ctx,&(data[i]),&j);
@


