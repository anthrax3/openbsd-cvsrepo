head	1.4;
access;
symbols
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.4
	OPENBSD_6_1_BASE:1.4;
locks; strict;
comment	@# @;


1.4
date	2010.10.01.22.58.54;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.18.12.39.05;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.35.53;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.39;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.39;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.08;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.10.01.22.54.05;	author djm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@resolve conflicts, fix local changes
@
text
@#!/usr/local/bin/perl

# define for pentium pro friendly version
$ppro=1;

$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
push(@@INC,"${dir}","${dir}../../perlasm");
require "x86asm.pl";
require "cbc.pl";

&asm_init($ARGV[0],"cast-586.pl",$ARGV[$#ARGV] eq "386");

$CAST_ROUNDS=16;
$L="edi";
$R="esi";
$K="ebp";
$tmp1="ecx";
$tmp2="ebx";
$tmp3="eax";
$tmp4="edx";
$S1="CAST_S_table0";
$S2="CAST_S_table1";
$S3="CAST_S_table2";
$S4="CAST_S_table3";

@@F1=("add","xor","sub");
@@F2=("xor","sub","add");
@@F3=("sub","add","xor");

&CAST_encrypt("CAST_encrypt",1);
&CAST_encrypt("CAST_decrypt",0);
&cbc("CAST_cbc_encrypt","CAST_encrypt","CAST_decrypt",1,4,5,3,-1,-1) unless $main'openbsd;

&asm_finish();

sub CAST_encrypt {
    local($name,$enc)=@@_;

    local($win_ex)=<<"EOF";
EXTERN	_CAST_S_table0:DWORD
EXTERN	_CAST_S_table1:DWORD
EXTERN	_CAST_S_table2:DWORD
EXTERN	_CAST_S_table3:DWORD
EOF
    &main::external_label(
			  "CAST_S_table0",
			  "CAST_S_table1",
			  "CAST_S_table2",
			  "CAST_S_table3",
			  );

    &function_begin_B($name,$win_ex);

    &comment("");

    &push("ebp");
    &push("ebx");
    &mov($tmp2,&wparam(0));
    &mov($K,&wparam(1));
    &push("esi");
    &push("edi");

    &comment("Load the 2 words");
    &mov($L,&DWP(0,$tmp2,"",0));
    &mov($R,&DWP(4,$tmp2,"",0));

    &comment('Get short key flag');
    &mov($tmp3,&DWP(128,$K,"",0));
    if($enc) {
	&push($tmp3);
    } else {
	&or($tmp3,$tmp3);
	&jnz(&label('cast_dec_skip'));
    }

    &xor($tmp3,	$tmp3);

    # encrypting part

    if ($enc) {
	&E_CAST( 0,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 1,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 2,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 3,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 4,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 5,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 6,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 7,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 8,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 9,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(10,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(11,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&comment('test short key flag');
	&pop($tmp4);
	&or($tmp4,$tmp4);
	&jnz(&label('cast_enc_done'));
	&E_CAST(12,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(13,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(14,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(15,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
    } else {
	&E_CAST(15,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(14,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(13,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(12,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&set_label('cast_dec_skip');
	&E_CAST(11,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(10,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 9,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 8,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 7,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 6,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 5,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 4,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 3,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 2,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 1,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 0,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
    }

    &set_label('cast_enc_done') if $enc;
# Why the nop? - Ben 17/1/99
    &nop();
    &mov($tmp3,&wparam(0));
    &mov(&DWP(4,$tmp3,"",0),$L);
    &mov(&DWP(0,$tmp3,"",0),$R);
    &function_end($name);
}

sub E_CAST {
    local($i,$S,$L,$R,$K,$OP1,$OP2,$OP3,$tmp1,$tmp2,$tmp3,$tmp4)=@@_;
    # Ri needs to have 16 pre added.

    &comment("round $i");
    &mov(	$tmp4,		&DWP($i*8,$K,"",1));

    &mov(	$tmp1,		&DWP($i*8+4,$K,"",1));
    &$OP1(	$tmp4,		$R);

    &rotl(	$tmp4,		&LB($tmp1));

    if ($ppro) {
	&mov(	$tmp2,		$tmp4);		# B
	&xor(	$tmp1,		$tmp1);
	
	&movb(	&LB($tmp1),	&HB($tmp4));	# A
	&and(	$tmp2,		0xff);

	&shr(	$tmp4,		16); 		#
	&xor(	$tmp3,		$tmp3);
    } else {
	&mov(	$tmp2,		$tmp4);		# B
	&movb(	&LB($tmp1),	&HB($tmp4));	# A	# BAD BAD BAD
	
	&shr(	$tmp4,		16); 		#
	&and(	$tmp2,		0xff);
    }

    &movb(	&LB($tmp3),	&HB($tmp4));	# C	# BAD BAD BAD
    &and(	$tmp4,		0xff);		# D

    &mov(	$tmp1,		&DWP($S1,"",$tmp1,4));
    &mov(	$tmp2,		&DWP($S2,"",$tmp2,4));

    &$OP2(	$tmp1,		$tmp2);
    &mov(	$tmp2,		&DWP($S3,"",$tmp3,4));

    &$OP3(	$tmp1,		$tmp2);
    &mov(	$tmp2,		&DWP($S4,"",$tmp4,4));

    &$OP1(	$tmp1,		$tmp2);
    # XXX

    &xor(	$L,		$tmp1);
    # XXX
}

@


1.3
log
@use bn_asm_vax.S (from netbsd); test + ok by miod
use asm code for i386, except for the CBC code, because
it is not clean PIC code.
add <machime/asm.h> support to x86unix.pl
tested by: nick (on 30386), henning, djm, tedu, jmc and more;
no shlib minor crank necessary, only internal symbols changed.
@
text
@d6 2
a7 1
push(@@INC,"perlasm","../../perlasm");
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d31 1
a31 1
&cbc("CAST_cbc_encrypt","CAST_encrypt","CAST_decrypt",1,4,5,3,-1,-1);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!/usr/bin/perl
d10 1
a10 1
&asm_init($ARGV[0],"cast-586.pl");
d35 2
a36 3
sub CAST_encrypt
	{
	local($name,$enc)=@@_;
d38 1
a38 1
	local($win_ex)=<<"EOF";
d44 133
a176 123
	&main'external_label(
		"CAST_S_table0",
		"CAST_S_table1",
		"CAST_S_table2",
		"CAST_S_table3",
		);

	&function_begin_B($name,$win_ex);

	&comment("");

	&push("ebp");
	&push("ebx");
	&mov($tmp2,&wparam(0));
	&mov($K,&wparam(1));
	&push("esi");
	&push("edi");

	&comment("Load the 2 words");
	&mov($L,&DWP(0,$tmp2,"",0));
	&mov($R,&DWP(4,$tmp2,"",0));

	&xor(	$tmp3,	$tmp3);

	# encrypting part

	if ($enc)
		{
		&E_CAST( 0,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 1,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 2,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 3,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 4,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 5,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 6,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 7,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 8,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 9,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(10,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(11,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(12,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(13,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(14,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(15,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4,1);
		}
	else
		{
		&E_CAST(15,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(14,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(13,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(12,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(11,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST(10,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 9,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 8,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 7,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 6,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 5,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 4,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 3,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 2,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 1,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
		&E_CAST( 0,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4,1);
		}

	&nop();
	&mov(&DWP(4,$tmp3,"",0),$L);
	&mov(&DWP(0,$tmp3,"",0),$R);
	&function_end($name);
	}

sub E_CAST
	{
	local($i,$S,$L,$R,$K,$OP1,$OP2,$OP3,$tmp1,$tmp2,$tmp3,$tmp4,$lst)=@@_;
	# Ri needs to have 16 pre added.

	&comment("round $i");
	&mov(	$tmp4,		&DWP($i*8,$K,"",1));

	&mov(	$tmp1,		&DWP($i*8+4,$K,"",1));# must be word
	&$OP1(	$tmp4,		$R);

	&rotl(	$tmp4,		&LB($tmp1));

	if ($ppro)
		{
		&mov(	$tmp2,		$tmp4);		# B
		&xor(	$tmp1,		$tmp1);

		&movb(	&LB($tmp1),	&HB($tmp4));	# A
		&and(	$tmp2,		0xff);

		&shr(	$tmp4,		16); 		#
		&xor(	$tmp3,		$tmp3);
		}
	else
		{
		&mov(	$tmp2,		$tmp4);		# B
		&movb(	&LB($tmp1),	&HB($tmp4));	# A	# BAD BAD BAD

		&shr(	$tmp4,		16); 		#
		&and(	$tmp2,		0xff);
		}

	&movb(	&LB($tmp3),	&HB($tmp4));	# C	# BAD BAD BAD
	&and(	$tmp4,		0xff);		# D

	&mov(	$tmp1,		&DWP($S1,"",$tmp1,4));
	&mov(	$tmp2,		&DWP($S2,"",$tmp2,4));

	&$OP2(	$tmp1,		$tmp2);
	&mov(	$tmp2,		&DWP($S3,"",$tmp3,4));

	&$OP3(	$tmp1,		$tmp2);
	&mov(	$tmp2,		&DWP($S4,"",$tmp4,4));

	&$OP1(	$tmp1,		$tmp2);
	 &mov($tmp3,&wparam(0)) if $lst;
	 # XXX

	&xor(	$L,		$tmp1);
	 # XXX
	}
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
d10 1
a10 1
&asm_init($ARGV[0],"cast-586.pl",$ARGV[$#ARGV] eq "386");
d35 3
a37 2
sub CAST_encrypt {
    local($name,$enc)=@@_;
d39 1
a39 1
    local($win_ex)=<<"EOF";
d45 123
a167 133
    &main::external_label(
			  "CAST_S_table0",
			  "CAST_S_table1",
			  "CAST_S_table2",
			  "CAST_S_table3",
			  );

    &function_begin_B($name,$win_ex);

    &comment("");

    &push("ebp");
    &push("ebx");
    &mov($tmp2,&wparam(0));
    &mov($K,&wparam(1));
    &push("esi");
    &push("edi");

    &comment("Load the 2 words");
    &mov($L,&DWP(0,$tmp2,"",0));
    &mov($R,&DWP(4,$tmp2,"",0));

    &comment('Get short key flag');
    &mov($tmp3,&DWP(128,$K,"",0));
    if($enc) {
	&push($tmp3);
    } else {
	&or($tmp3,$tmp3);
	&jnz(&label('cast_dec_skip'));
    }

    &xor($tmp3,	$tmp3);

    # encrypting part

    if ($enc) {
	&E_CAST( 0,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 1,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 2,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 3,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 4,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 5,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 6,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 7,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 8,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 9,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(10,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(11,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&comment('test short key flag');
	&pop($tmp4);
	&or($tmp4,$tmp4);
	&jnz(&label('cast_enc_done'));
	&E_CAST(12,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(13,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(14,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(15,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
    } else {
	&E_CAST(15,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(14,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(13,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(12,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&set_label('cast_dec_skip');
	&E_CAST(11,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST(10,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 9,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 8,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 7,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 6,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 5,$S,$L,$R,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 4,$S,$R,$L,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 3,$S,$L,$R,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 2,$S,$R,$L,$K,@@F3,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 1,$S,$L,$R,$K,@@F2,$tmp1,$tmp2,$tmp3,$tmp4);
	&E_CAST( 0,$S,$R,$L,$K,@@F1,$tmp1,$tmp2,$tmp3,$tmp4);
    }

    &set_label('cast_enc_done') if $enc;
# Why the nop? - Ben 17/1/99
    &nop();
    &mov($tmp3,&wparam(0));
    &mov(&DWP(4,$tmp3,"",0),$L);
    &mov(&DWP(0,$tmp3,"",0),$R);
    &function_end($name);
}

sub E_CAST {
    local($i,$S,$L,$R,$K,$OP1,$OP2,$OP3,$tmp1,$tmp2,$tmp3,$tmp4)=@@_;
    # Ri needs to have 16 pre added.

    &comment("round $i");
    &mov(	$tmp4,		&DWP($i*8,$K,"",1));

    &mov(	$tmp1,		&DWP($i*8+4,$K,"",1));
    &$OP1(	$tmp4,		$R);

    &rotl(	$tmp4,		&LB($tmp1));

    if ($ppro) {
	&mov(	$tmp2,		$tmp4);		# B
	&xor(	$tmp1,		$tmp1);
	
	&movb(	&LB($tmp1),	&HB($tmp4));	# A
	&and(	$tmp2,		0xff);

	&shr(	$tmp4,		16); 		#
	&xor(	$tmp3,		$tmp3);
    } else {
	&mov(	$tmp2,		$tmp4);		# B
	&movb(	&LB($tmp1),	&HB($tmp4));	# A	# BAD BAD BAD
	
	&shr(	$tmp4,		16); 		#
	&and(	$tmp2,		0xff);
    }

    &movb(	&LB($tmp3),	&HB($tmp4));	# C	# BAD BAD BAD
    &and(	$tmp4,		0xff);		# D

    &mov(	$tmp1,		&DWP($S1,"",$tmp1,4));
    &mov(	$tmp2,		&DWP($S2,"",$tmp2,4));

    &$OP2(	$tmp1,		$tmp2);
    &mov(	$tmp2,		&DWP($S3,"",$tmp3,4));

    &$OP3(	$tmp1,		$tmp2);
    &mov(	$tmp2,		&DWP($S4,"",$tmp4,4));

    &$OP1(	$tmp1,		$tmp2);
    # XXX

    &xor(	$L,		$tmp1);
    # XXX
}

@


1.1.1.3
log
@import OpenSSL-1.0.0a
@
text
@d6 1
a6 2
$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
push(@@INC,"${dir}","${dir}../../perlasm");
@


