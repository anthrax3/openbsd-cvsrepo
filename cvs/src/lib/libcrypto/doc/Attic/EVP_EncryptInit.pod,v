head	1.18;
access;
symbols;
locks; strict;
comment	@# @;


1.18
date	2016.11.03.09.35.34;	author schwarze;	state dead;
branches;
next	1.17;
commitid	3WfE7ZbXXRiIqemG;

1.17
date	2016.09.22.04.28.24;	author bcook;	state Exp;
branches;
next	1.16;
commitid	eBhzgFxH7gomp175;

1.16
date	2016.09.03.14.54.25;	author bcook;	state Exp;
branches;
next	1.15;
commitid	V58HU85rmOVCkawv;

1.15
date	2015.11.11.22.14.40;	author jmc;	state Exp;
branches;
next	1.14;
commitid	eNNq8UNxWW0rsWWg;

1.14
date	2015.09.22.08.08.07;	author sobrado;	state Exp;
branches;
next	1.13;
commitid	yt6ZAILseiFaXq7L;

1.13
date	2014.07.11.16.18.14;	author miod;	state Exp;
branches;
next	1.12;
commitid	KFr43un1Uq8AaqNL;

1.12
date	2014.07.10.14.14.04;	author miod;	state Exp;
branches;
next	1.11;
commitid	VVoKhghxvV7qSanI;

1.11
date	2014.07.10.13.08.58;	author miod;	state Exp;
branches;
next	1.10;
commitid	x57mQDu0Rgvs2ML3;

1.10
date	2014.05.04.22.26.33;	author jim;	state Exp;
branches;
next	1.9;

1.9
date	2014.05.04.21.46.36;	author jim;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.29.05.39.29;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.12.02.18.39;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.10.16.31.56;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.15.02.29.19;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.02.58.27;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.12.58;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.17;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.43.17;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.36.15;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.04.29.05.37.23;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.06.27.05.05.37;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.04.13.15.16.35;	author miod;	state Exp;
branches;
next	;


desc
@@


1.18
log
@convert EVP manuals from pod to mdoc
@
text
@=pod

=head1 NAME

EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate,
EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate,
EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate,
EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length,
EVP_CIPHER_CTX_ctrl, EVP_CIPHER_CTX_cleanup, EVP_EncryptInit,
EVP_EncryptFinal, EVP_DecryptInit, EVP_DecryptFinal,
EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname,
EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid,
EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length,
EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher,
EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length,
EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data,
EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags,
EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param,
EVP_CIPHER_CTX_set_padding,  EVP_enc_null, EVP_des_cbc, EVP_des_ecb,
EVP_des_cfb, EVP_des_ofb, EVP_des_ede_cbc, EVP_des_ede, EVP_des_ede_ofb,
EVP_des_ede_cfb, EVP_des_ede3_cbc, EVP_des_ede3, EVP_des_ede3_ofb,
EVP_des_ede3_cfb, EVP_desx_cbc, EVP_rc4, EVP_rc4_40, EVP_idea_cbc,
EVP_idea_ecb, EVP_idea_cfb, EVP_idea_ofb, EVP_idea_cbc, EVP_rc2_cbc,
EVP_rc2_ecb, EVP_rc2_cfb, EVP_rc2_ofb, EVP_rc2_40_cbc, EVP_rc2_64_cbc,
EVP_bf_cbc, EVP_bf_ecb, EVP_bf_cfb, EVP_bf_ofb, EVP_cast5_cbc,
EVP_cast5_ecb, EVP_cast5_cfb, EVP_cast5_ofb,
EVP_aes_128_gcm, EVP_aes_192_gcm, EVP_aes_256_gcm, EVP_aes_128_ccm,
EVP_aes_192_ccm, EVP_aes_256_ccm, EVP_rc5_32_12_16_cbc,
EVP_rc5_32_12_16_cfb, EVP_rc5_32_12_16_ecb, EVP_rc5_32_12_16_ofb
- EVP cipher routines

=head1 SYNOPSIS

 #include <openssl/evp.h>

 void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);

 int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
	 ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl);

 int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
	 ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);
 int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
 int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl);

 int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
 int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv, int enc);
 int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
 int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
 int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
 int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);

 const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
 #define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))
 #define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))

 #define EVP_CIPHER_nid(e)		((e)->nid)
 #define EVP_CIPHER_block_size(e)	((e)->block_size)
 #define EVP_CIPHER_key_length(e)	((e)->key_len)
 #define EVP_CIPHER_iv_length(e)		((e)->iv_len)
 #define EVP_CIPHER_flags(e)		((e)->flags)
 #define EVP_CIPHER_mode(e)		((e)->flags) & EVP_CIPH_MODE)
 int EVP_CIPHER_type(const EVP_CIPHER *ctx);

 #define EVP_CIPHER_CTX_cipher(e)	((e)->cipher)
 #define EVP_CIPHER_CTX_nid(e)		((e)->cipher->nid)
 #define EVP_CIPHER_CTX_block_size(e)	((e)->cipher->block_size)
 #define EVP_CIPHER_CTX_key_length(e)	((e)->key_len)
 #define EVP_CIPHER_CTX_iv_length(e)	((e)->cipher->iv_len)
 #define EVP_CIPHER_CTX_get_app_data(e)	((e)->app_data)
 #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)->app_data=(char *)(d))
 #define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
 #define EVP_CIPHER_CTX_flags(e)		((e)->cipher->flags)
 #define EVP_CIPHER_CTX_mode(e)		((e)->cipher->flags & EVP_CIPH_MODE)

 int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
 int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);

=head1 DESCRIPTION

The EVP cipher routines are a high level interface to certain
symmetric ciphers.

EVP_CIPHER_CTX_init() initializes cipher context B<ctx>.

EVP_EncryptInit_ex() sets up cipher context B<ctx> for encryption
with cipher B<type> from ENGINE B<impl>. B<ctx> must be initialized
before calling this function. B<type> is normally supplied
by a function such as EVP_aes_256_cbc(). If B<impl> is NULL then the
default implementation is used. B<key> is the symmetric key to use
and B<iv> is the IV to use (if necessary), the actual number of bytes
used for the key and IV depends on the cipher. It is possible to set
all parameters to NULL except B<type> in an initial call and supply
the remaining parameters in subsequent calls, all of which have B<type>
set to NULL. This is done when the default cipher parameters are not
appropriate.

EVP_EncryptUpdate() encrypts B<inl> bytes from the buffer B<in> and
writes the encrypted version to B<out>. This function can be called
multiple times to encrypt successive blocks of data. The amount
of data written depends on the block alignment of the encrypted data:
as a result the amount of data written may be anything from zero bytes
to (inl + cipher_block_size - 1) so B<outl> should contain sufficient
room. The actual number of bytes written is placed in B<outl>.

If padding is enabled (the default) then EVP_EncryptFinal_ex() encrypts
the "final" data, that is any data that remains in a partial block.
It uses L<standard block padding|/NOTES> (aka PKCS padding). The encrypted
final data is written to B<out> which should have sufficient space for
one cipher block. The number of bytes written is placed in B<outl>. After
this function is called the encryption operation is finished and no further
calls to EVP_EncryptUpdate() should be made.

If padding is disabled then EVP_EncryptFinal_ex() will not encrypt any more
data and it will return an error if any data remains in a partial block:
that is if the total data length is not a multiple of the block size.

EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the
corresponding decryption operations. EVP_DecryptFinal() will return an
error code if padding is enabled and the final block is not correctly
formatted. The parameters and restrictions are identical to the encryption
operations except that if padding is enabled the decrypted data buffer B<out>
passed to EVP_DecryptUpdate() should have sufficient room for
(B<inl> + cipher_block_size) bytes unless the cipher block size is 1 in
which case B<inl> bytes is sufficient.

EVP_CipherInit_ex(), EVP_CipherUpdate() and EVP_CipherFinal_ex() are
functions that can be used for decryption or encryption. The operation
performed depends on the value of the B<enc> parameter. It should be set
to 1 for encryption, 0 for decryption and -1 to leave the value unchanged
(the actual value of 'enc' being supplied in a previous call).

EVP_CIPHER_CTX_cleanup() clears all information from a cipher context
and free up any allocated memory associate with it. It should be called
after all operations using a cipher are complete so sensitive information
does not remain in memory.

EVP_EncryptInit(), EVP_DecryptInit() and EVP_CipherInit() behave in a
similar way to EVP_EncryptInit_ex(), EVP_DecryptInit_ex and
EVP_CipherInit_ex() except the B<ctx> parameter does not need to be
initialized and they always use the default cipher implementation.

EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal() are
identical to EVP_EncryptFinal_ex(), EVP_DecryptFinal_ex() and
EVP_CipherFinal_ex(). In previous releases of OpenSSL they also used to clean
up the B<ctx>, but this is no longer done and EVP_CIPHER_CTX_clean()
must be called to free any context resources.

EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj()
return an EVP_CIPHER structure when passed a cipher name, a NID or an
ASN1_OBJECT structure.

EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return the NID of a cipher when
passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX> structure.  The actual NID
value is an internal value which may not have a corresponding OBJECT
IDENTIFIER.

EVP_CIPHER_CTX_set_padding() enables or disables padding. By default
encryption operations are padded using standard block padding and the
padding is checked and removed when decrypting. If the B<pad> parameter
is zero then no padding is performed, the total amount of data encrypted
or decrypted must then be a multiple of the block size or an error will
occur.

EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key
length of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX>
structure. The constant B<EVP_MAX_KEY_LENGTH> is the maximum key length
for all ciphers. Note: although EVP_CIPHER_key_length() is fixed for a
given cipher, the value of EVP_CIPHER_CTX_key_length() may be different
for variable key length ciphers.

EVP_CIPHER_CTX_set_key_length() sets the key length of the cipher ctx.
If the cipher is a fixed length cipher then attempting to set the key
length to any value other than the fixed value is an error.

EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV
length of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX>.
It will return zero if the cipher does not use an IV.  The constant
B<EVP_MAX_IV_LENGTH> is the maximum IV length for all ciphers.

EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block
size of a cipher when passed an B<EVP_CIPHER> or B<EVP_CIPHER_CTX>
structure. The constant B<EVP_MAX_IV_LENGTH> is also the maximum block
length for all ciphers.

EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the type of the passed
cipher or context. This "type" is the actual NID of the cipher OBJECT
IDENTIFIER as such it ignores the cipher parameters and 40 bit RC2 and
128 bit RC2 have the same NID. If the cipher does not have an object
identifier or does not have ASN1 support this function will return
B<NID_undef>.

EVP_CIPHER_CTX_cipher() returns the B<EVP_CIPHER> structure when passed
an B<EVP_CIPHER_CTX> structure.

EVP_CIPHER_mode() and EVP_CIPHER_CTX_mode() return the block cipher mode:
EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE or
EVP_CIPH_OFB_MODE. If the cipher is a stream cipher then
EVP_CIPH_STREAM_CIPHER is returned.

EVP_CIPHER_param_to_asn1() sets the AlgorithmIdentifier "parameter" based
on the passed cipher. This will typically include any parameters and an
IV. The cipher IV (if any) must be set when this call is made. This call
should be made before the cipher is actually "used" (before any
EVP_EncryptUpdate(), EVP_DecryptUpdate() calls for example). This function
may fail if the cipher does not have any ASN1 support.

EVP_CIPHER_asn1_to_param() sets the cipher parameters based on an ASN1
AlgorithmIdentifier "parameter". The precise effect depends on the cipher
In the case of RC2, for example, it will set the IV and effective key length.
This function should be called after the base cipher type is set but before
the key is set. For example EVP_CipherInit() will be called with the IV and
key set to NULL, EVP_CIPHER_asn1_to_param() will be called and finally
EVP_CipherInit() again with all parameters except the key set to NULL. It is
possible for this function to fail if the cipher does not have any ASN1 support
or the parameters cannot be set (for example the RC2 effective key length
is not supported.

EVP_CIPHER_CTX_ctrl() allows various cipher specific parameters to be determined
and set. Currently only the RC2 effective key length and the number of rounds of
RC5 can be set.

=head1 RETURN VALUES

EVP_EncryptInit_ex(), EVP_EncryptUpdate() and EVP_EncryptFinal_ex()
return 1 for success and 0 for failure.

EVP_DecryptInit_ex() and EVP_DecryptUpdate() return 1 for success and 0 for
failure.  EVP_DecryptFinal_ex() returns 0 if the decrypt failed or 1 for
success.

EVP_CipherInit_ex() and EVP_CipherUpdate() return 1 for success and 0 for
failure.  EVP_CipherFinal_ex() returns 0 for a decryption failure or 1 for
success.

EVP_CIPHER_CTX_cleanup() returns 1 for success and 0 for failure.

EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj()
return an B<EVP_CIPHER> structure or NULL on error.

EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return a NID.

EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block
size.

EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key
length.

EVP_CIPHER_CTX_set_padding() always returns 1.

EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV
length or zero if the cipher does not use an IV.

EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the NID of the cipher's
OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER.

EVP_CIPHER_CTX_cipher() returns an B<EVP_CIPHER> structure.

EVP_CIPHER_param_to_asn1() and EVP_CIPHER_asn1_to_param() return 1 for
success or zero for failure.

=head1 CIPHER LISTING

All algorithms have a fixed key length unless otherwise stated.

=over 4

=item EVP_enc_null(void)

Null cipher: does nothing.

=item EVP_aes_128_cbc(void), EVP_aes_128_ecb(void), EVP_aes_128_cfb(void), EVP_aes_128_ofb(void)

128-bit AES in CBC, ECB, CFB and OFB modes respectively.

=item EVP_aes_192_cbc(void), EVP_aes_192_ecb(void), EVP_aes_192_cfb(void), EVP_aes_192_ofb(void)

192-bit AES in CBC, ECB, CFB and OFB modes respectively.

=item EVP_aes_256_cbc(void), EVP_aes_256_ecb(void), EVP_aes_256_cfb(void), EVP_aes_256_ofb(void)

256-bit AES in CBC, ECB, CFB and OFB modes respectively.

=item EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)

DES in CBC, ECB, CFB and OFB modes respectively.

=item EVP_des_ede_cbc(void), EVP_des_ede(), EVP_des_ede_ofb(void),
EVP_des_ede_cfb(void)

Two key triple DES in CBC, ECB, CFB and OFB modes respectively.

=item EVP_des_ede3_cbc(void), EVP_des_ede3(), EVP_des_ede3_ofb(void),
EVP_des_ede3_cfb(void)

Three key triple DES in CBC, ECB, CFB and OFB modes respectively.

=item EVP_desx_cbc(void)

DESX algorithm in CBC mode.

=item EVP_rc4(void)

RC4 stream cipher. This is a variable key length cipher with default key length
128 bits.

=item EVP_rc4_40(void)

RC4 stream cipher with 40 bit key length. This is obsolete and new code should
use EVP_rc4() and the EVP_CIPHER_CTX_set_key_length() function.

=item EVP_idea_cbc() EVP_idea_ecb(void), EVP_idea_cfb(void),
EVP_idea_ofb(void), EVP_idea_cbc(void)

IDEA encryption algorithm in CBC, ECB, CFB and OFB modes respectively.

=item EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)

RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a
variable key length cipher with an additional parameter called "effective key
bits" or "effective key length".  By default both are set to 128 bits.

=item EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)

RC2 algorithm in CBC mode with a default key length and effective key length of
40 and 64 bits.  These are obsolete and new code should use EVP_rc2_cbc(),
EVP_CIPHER_CTX_set_key_length() and EVP_CIPHER_CTX_ctrl() to set the key length
and effective key length.

=item EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);

Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This
is a variable key length cipher.

=item EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void),
EVP_cast5_ofb(void)

CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is
a variable key length cipher.

=item EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void),
EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)

RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a
variable key length cipher with an additional "number of rounds" parameter. By
default the key length is set to 128 bits and 12 rounds.

=back

=head1 NOTES

Where possible the B<EVP> interface to symmetric ciphers should be used in
preference to the low level interfaces. This is because the code then becomes
transparent to the cipher used and much more flexible.

PKCS padding works by adding B<n> padding bytes of value B<n> to make the total
length of the encrypted data a multiple of the block size. Padding is always
added so if the data is already a multiple of the block size B<n> will equal
the block size. For example if the block size is 8 and 11 bytes are to be
encrypted then 5 padding bytes of value 5 will be added.

When decrypting the final block is checked to see if it has the correct form.

Although the decryption operation can produce an error if padding is enabled,
it is not a strong test that the input data or key is correct. A random block
has better than 1 in 256 chance of being of the correct format and problems with
the input data earlier on will not produce a final decrypt error.

If padding is disabled then the decryption operation will always succeed if
the total amount of data decrypted is a multiple of the block size.

The functions EVP_EncryptInit(), EVP_EncryptFinal(), EVP_DecryptInit(),
EVP_CipherInit() and EVP_CipherFinal() are obsolete but are retained for
compatibility with existing code. New code should use EVP_EncryptInit_ex(),
EVP_EncryptFinal_ex(), EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(),
EVP_CipherInit_ex() and EVP_CipherFinal_ex() because they can reuse an
existing context without allocating and freeing it up on each call.

=head1 BUGS

For RC5 the number of rounds can currently only be set to 8, 12 or 16. This is
a limitation of the current RC5 code rather than the EVP interface.

EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers with
default key lengths. If custom ciphers exceed these values the results are
unpredictable. This is because it has become standard practice to define a
generic key as a fixed unsigned char array containing EVP_MAX_KEY_LENGTH bytes.

The ASN1 code is incomplete (and sometimes inaccurate) it has only been tested
for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC mode.

=head1 EXAMPLES

Get the number of rounds used in RC5:

 int nrounds;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &nrounds);

Get the RC2 effective key length:

 int key_bits;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC2_KEY_BITS, 0, &key_bits);

Set the number of rounds used in RC5:

 int nrounds;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC5_ROUNDS, nrounds, NULL);

Set the effective key length used in RC2:

 int key_bits;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);

Encrypt a string using blowfish:

 int
 do_crypt(char *outfile)
 {
	unsigned char outbuf[1024];
	int outlen, tmplen;
	/*
	 * Bogus key and IV: we'd normally set these from
	 * another source.
	 */
	unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
	unsigned char iv[] = {1,2,3,4,5,6,7,8};
	const char intext[] = "Some Crypto Text";
	EVP_CIPHER_CTX ctx;
	FILE *out;
	EVP_CIPHER_CTX_init(&ctx);
	EVP_EncryptInit_ex(&ctx, EVP_bf_cbc(), NULL, key, iv);

	if (!EVP_EncryptUpdate(&ctx, outbuf, &outlen, intext,
	    strlen(intext))) {
		/* Error */
		return 0;
	}
	/*
	 * Buffer passed to EVP_EncryptFinal() must be after data just
	 * encrypted to avoid overwriting it.
	 */
	if (!EVP_EncryptFinal_ex(&ctx, outbuf + outlen, &tmplen)) {
		/* Error */
		return 0;
	}
	outlen += tmplen;
	EVP_CIPHER_CTX_cleanup(&ctx);
	/*
	 * Need binary mode for fopen because encrypted data is
	 * binary data. Also cannot use strlen() on it because
	 * it won't be NUL terminated and may contain embedded
	 * NULs.
	 */
	out = fopen(outfile, "wb");
	fwrite(outbuf, 1, outlen, out);
	fclose(out);
	return 1;
 }

The ciphertext from the above example can be decrypted using the B<openssl>
utility with the command line:

 S<openssl bf -in cipher.bin -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708 -d>

General encryption, decryption function example using FILE I/O and RC2 with an
80 bit key:

 int
 do_crypt(FILE *in, FILE *out, int do_encrypt)
 {
	/* Allow enough space in output buffer for additional block */
	inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];
	int inlen, outlen;
	/*
	 * Bogus key and IV: we'd normally set these from
	 * another source.
	 */
	unsigned char key[] = "0123456789";
	unsigned char iv[] = "12345678";

	/* Don't set key or IV because we will modify the parameters */
	EVP_CIPHER_CTX_init(&ctx);
	EVP_CipherInit_ex(&ctx, EVP_rc2(), NULL, NULL, NULL, do_encrypt);
	EVP_CIPHER_CTX_set_key_length(&ctx, 10);
	/* We finished modifying parameters so now we can set key and IV */
	EVP_CipherInit_ex(&ctx, NULL, NULL, key, iv, do_encrypt);

	for(;;) {
		inlen = fread(inbuf, 1, 1024, in);
		if (inlen <= 0)
			break;
		if (!EVP_CipherUpdate(&ctx, outbuf, &outlen, inbuf,
		    inlen)) {
			/* Error */
			EVP_CIPHER_CTX_cleanup(&ctx);
			return 0;
		}
		fwrite(outbuf, 1, outlen, out);
	}
	if (!EVP_CipherFinal_ex(&ctx, outbuf, &outlen)) {
		/* Error */
		EVP_CIPHER_CTX_cleanup(&ctx);
		return 0;
	}
	fwrite(outbuf, 1, outlen, out);

	EVP_CIPHER_CTX_cleanup(&ctx);
	return 1;
 }

=head1 SEE ALSO

L<evp(3)|evp(3)>

=head1 HISTORY

EVP_CIPHER_CTX_init(), EVP_EncryptInit_ex(), EVP_EncryptFinal_ex(),
EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), EVP_CipherInit_ex(),
EVP_CipherFinal_ex() and EVP_CIPHER_CTX_set_padding() appeared in
OpenSSL 0.9.7.

=cut
@


1.17
log
@revert documentation update for the clearning behavior we already reverted
@
text
@@


1.16
log
@deprecate EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal()

This switches EVP_CipherFinal() to work as EVP_EncryptFinal() and
EVP_DecryptFinal() do, always clearing the cipher context on completion.
Indicate that, since it is not possible to tell whether this function will
clear the context (the API has changed over time in OpenSSL), it is better to
use the _ex() variants and explicitly clear instead.

ok beck@@
@
text
@d173 1
a173 5
must be called to free any context resources. As of LibreSSL 2.4,
EVP_EncryptFinal() and EVP_DecryptFinal() will always clean up, and
EVP_CipherFinal() also cleans up as of LibreSSL 2.5. The use of
EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal() is not
recommended.
@


1.15
log
@add missing functions to NAME, or otherwise correct the mlink
entry for them;

feedback/ok schwarze
@
text
@d26 1
a26 1
EVP_cast5_ecb, EVP_cast5_cfb, EVP_cast5_ofb, 
d171 7
a177 3
EVP_CipherFinal_ex(). In previous releases they also used to clean up
the B<ctx>, but this is no longer done and EVP_CIPHER_CTX_clean()
must be called to free any context resources.
@


1.14
log
@typos in documentation; better wording, suggested by jmc@@

ok jmc@@
@
text
@d28 3
a30 1
EVP_aes_192_ccm, EVP_aes_256_ccm - EVP cipher routines
@


1.13
log
@Huge documentation update for libcrypto and libssl, mostly from Matt Caswell,
Jeff Trawick, Jean-Paul Calderone, Michal Bozon, Jeffrey Walton and Rich Salz,
via OpenSSL trunk (with some parts not applying to us, such as SSLv2 support,
at least partially removed).
@
text
@d108 1
a108 1
EVP_CIPHER_CTX_init() initializes cipher contex B<ctx>.
@


1.12
log
@Try and fix the horrible coding style of the example code snippets.
@
text
@d19 10
a28 1
EVP_CIPHER_CTX_set_padding - EVP cipher routines
d167 5
a171 4
EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal() behave in a
similar way to EVP_EncryptFinal_ex(), EVP_DecryptFinal_ex() and
EVP_CipherFinal_ex() except B<ctx> is automatically cleaned up
after the call.
@


1.11
log
@Attempt to (incompletely) document EVP_aes_*().

When EVP_des_cbc() was suggested, suggest EVP_aes_256_cbc() instead.

Remove mention of EVP_des_ede3_cbc() being the algorithm of choice for S/MIME.

Don't mention US-export limited RC2 algorithms, you'd better not know about
them.
@
text
@d430 3
a432 2
 int do_crypt(char *outfile)
 	{
d435 2
a436 1
	/* Bogus key and IV: we'd normally set these from
d441 1
a441 1
	char intext[] = "Some Crypto Text";
d447 2
a448 2
	if(!EVP_EncryptUpdate(&ctx, outbuf, &outlen, intext, strlen(intext)))
		{
d451 3
a453 2
		}
	/* Buffer passed to EVP_EncryptFinal() must be after data just
d456 1
a456 2
	if(!EVP_EncryptFinal_ex(&ctx, outbuf + outlen, &tmplen))
		{
d459 1
a459 1
		}
d462 2
a463 1
	/* Need binary mode for fopen because encrypted data is
d465 2
a466 2
         * it wont be null terminated and may contain embedded
	 * nulls.
d472 1
a472 1
	}
d482 3
a484 2
 int do_crypt(FILE *in, FILE *out, int do_encrypt)
 	{
d488 2
a489 1
	/* Bogus key and IV: we'd normally set these from
d494 1
d502 1
a502 2
	for(;;)
		{
d504 4
a507 3
		if(inlen <= 0) break;
		if(!EVP_CipherUpdate(&ctx, outbuf, &outlen, inbuf, inlen))
			{
d511 1
a511 1
			}
d513 2
a514 3
		}
	if(!EVP_CipherFinal_ex(&ctx, outbuf, &outlen))
		{
d518 1
a518 1
		}
d523 1
a523 2
	}

@


1.10
log
@Improve line wrapping for lines exceeding 80 chars.

ok jmc@@
@
text
@d104 1
a104 1
by a function such as EVP_des_cbc(). If B<impl> is NULL then the
d282 1
a282 1
=item EVP_enc_null()
d285 12
@


1.9
log
@Remove trailing whitespace.

fine jmc@@
@
text
@d242 7
a248 5
EVP_DecryptInit_ex() and EVP_DecryptUpdate() return 1 for success and 0 for failure.
EVP_DecryptFinal_ex() returns 0 if the decrypt failed or 1 for success.

EVP_CipherInit_ex() and EVP_CipherUpdate() return 1 for success and 0 for failure.
EVP_CipherFinal_ex() returns 0 for a decryption failure or 1 for success.
d290 2
a291 1
=item EVP_des_ede_cbc(void), EVP_des_ede(), EVP_des_ede_ofb(void),  EVP_des_ede_cfb(void)
d295 2
a296 1
=item EVP_des_ede3_cbc(void), EVP_des_ede3(), EVP_des_ede3_ofb(void),  EVP_des_ede3_cfb(void)
d306 2
a307 1
RC4 stream cipher. This is a variable key length cipher with default key length 128 bits.
d311 2
a312 2
RC4 stream cipher with 40 bit key length. This is obsolete and new code should use EVP_rc4()
and the EVP_CIPHER_CTX_set_key_length() function.
d314 2
a315 1
=item EVP_idea_cbc() EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), EVP_idea_cbc(void)
d321 3
a323 3
RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
length cipher with an additional parameter called "effective key bits" or "effective key length".
By default both are set to 128 bits.
d327 4
a330 3
RC2 algorithm in CBC mode with a default key length and effective key length of 40 and 64 bits.
These are obsolete and new code should use EVP_rc2_cbc(), EVP_CIPHER_CTX_set_key_length() and
EVP_CIPHER_CTX_ctrl() to set the key length and effective key length.
d334 2
a335 2
Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
length cipher.
d337 2
a338 1
=item EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), EVP_cast5_ofb(void)
d340 2
a341 2
CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
length cipher.
d343 2
a344 1
=item EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)
d346 3
a348 3
RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key length
cipher with an additional "number of rounds" parameter. By default the key length is set to 128
bits and 12 rounds.
@


1.8
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d131 1
a131 1
that is if the total data length is not a multiple of the block size. 
d160 1
a160 1
EVP_CipherFinal_ex() except B<ctx> is automatically cleaned up 
d271 1
a271 1
EVP_CIPHER_param_to_asn1() and EVP_CIPHER_asn1_to_param() return 1 for 
d286 1
a286 1
DES in CBC, ECB, CFB and OFB modes respectively. 
d349 1
a349 1
PKCS padding works by adding B<n> padding bytes of value B<n> to make the total 
d379 1
a379 1
unpredictable. This is because it has become standard practice to define a 
d452 1
a452 1
 
d475 1
a475 1
	for(;;) 
@


1.7
log
@resolve conflicts
@
text
@d155 1
a155 1
EVP_CipherInit_ex() except the B<ctx> paramter does not need to be
@


1.6
log
@resolve conflicts
@
text
@d25 1
a25 1
 int EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);
d239 2
a240 2
EVP_CIPHER_CTX_init, EVP_EncryptInit_ex(), EVP_EncryptUpdate() and
EVP_EncryptFinal_ex() return 1 for success and 0 for failure.
@


1.5
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d482 1
d490 1
@


1.4
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d422 1
a422 1
	EVP_EncryptInit_ex(&ctx, NULL, EVP_bf_cbc(), key, iv);
@


1.3
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d504 5
@


1.2
log
@openssl-engine-0.9.6 merge
@
text
@d5 15
a19 11
EVP_EncryptInit, EVP_EncryptUpdate, EVP_EncryptFinal, EVP_DecryptInit,
EVP_DecryptUpdate, EVP_DecryptFinal, EVP_CipherInit, EVP_CipherUpdate,
EVP_CipherFinal, EVP_CIPHER_CTX_set_key_length, EVP_CIPHER_CTX_ctrl,
EVP_CIPHER_CTX_cleanup, EVP_get_cipherbyname, EVP_get_cipherbynid,
EVP_get_cipherbyobj, EVP_CIPHER_nid, EVP_CIPHER_block_size,
EVP_CIPHER_key_length, EVP_CIPHER_iv_length, EVP_CIPHER_flags,
EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher, EVP_CIPHER_CTX_nid,
EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length, EVP_CIPHER_CTX_iv_length,
EVP_CIPHER_CTX_get_app_data, EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type,
EVP_CIPHER_CTX_flags, EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1,
EVP_CIPHER_asn1_to_param - EVP cipher routines
d25 23
a49 2
 int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
a54 2
 int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
a59 2
 int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
d63 1
d99 13
a111 8
EVP_EncryptInit() initializes a cipher context B<ctx> for encryption
with cipher B<type>. B<type> is normally supplied by a function such
as EVP_des_cbc() . B<key> is the symmetric key to use and B<iv> is the
IV to use (if necessary), the actual number of bytes used for the
key and IV depends on the cipher. It is possible to set all parameters
to NULL except B<type> in an initial call and supply the remaining
parameters in subsequent calls, all of which have B<type> set to NULL.
This is done when the default cipher parameters are not appropriate.
d119 1
a119 1
room.  The actual number of bytes written is placed in B<outl>.
d121 11
a131 6
EVP_EncryptFinal() encrypts the "final" data, that is any data that
remains in a partial block. It uses L<standard block padding|/NOTES> (aka PKCS
padding). The encrypted final data is written to B<out> which should
have sufficient space for one cipher block. The number of bytes written
is placed in B<outl>. After this function is called the encryption operation
is finished and no further calls to EVP_EncryptUpdate() should be made.
d133 1
a133 1
EVP_DecryptInit(), EVP_DecryptUpdate() and EVP_DecryptFinal() are the
d135 27
a161 15
error code if the final block is not correctly formatted. The parameters
and restrictions are identical to the encryption operations except that
the decrypted data buffer B<out> passed to EVP_DecryptUpdate() should
have sufficient room for (B<inl> + cipher_block_size) bytes unless the
cipher block size is 1 in which case B<inl> bytes is sufficient.

EVP_CipherInit(), EVP_CipherUpdate() and EVP_CipherFinal() are functions
that can be used for decryption or encryption. The operation performed
depends on the value of the B<enc> parameter. It should be set to 1 for
encryption, 0 for decryption and -1 to leave the value unchanged (the
actual value of 'enc' being supplied in a previous call).

EVP_CIPHER_CTX_cleanup() clears all information from a cipher context.
It should be called after all operations using a cipher are complete
so sensitive information does not remain in memory.
d172 7
d239 2
a240 2
EVP_EncryptInit(), EVP_EncryptUpdate() and EVP_EncryptFinal() return 1 for success
and 0 for failure.
d242 2
a243 2
EVP_DecryptInit() and EVP_DecryptUpdate() return 1 for success and 0 for failure.
EVP_DecryptFinal() returns 0 if the decrypt failed or 1 for success.
d245 2
a246 2
EVP_CipherInit() and EVP_CipherUpdate() return 1 for success and 0 for failure.
EVP_CipherFinal() returns 1 for a decryption failure or 1 for success.
d261 2
d357 14
a370 11
Although the decryption operation can produce an error, it is not a strong
test that the input data or key is correct. A random block has better than
1 in 256 chance of being of the correct format and problems with the
input data earlier on will not produce a final decrypt error.

The functions EVP_EncryptInit(), EVP_EncryptUpdate(), EVP_EncryptFinal(),
EVP_DecryptInit(), EVP_DecryptUpdate(), EVP_CipherInit() and EVP_CipherUpdate()
and EVP_CIPHER_CTX_cleanup() did not return errors in OpenSSL version 0.9.5a or
earlier. Software only versions of encryption algorithms will never return
error codes for these functions, unless there is a programming error (for example
and attempt to set the key before the cipher is set in EVP_EncryptInit() ).
a376 2
It should be possible to disable PKCS padding: currently it isn't.

d390 1
a390 1
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &i);
d395 1
a395 1
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC2_KEY_BITS, 0, &i);
d400 1
a400 1
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC5_ROUNDS, i, NULL);
d402 94
a495 1
Set the number of rounds used in RC2:
a496 2
 int nrounds;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, i, NULL);
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d5 11
a15 1
EVP_EncryptInit, EVP_EncryptUpdate, EVP_EncryptFinal - EVP cipher routines
d21 1
a21 1
 void EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
d23 1
a23 1
 void EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
d25 1
a25 1
 void EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
d28 1
a28 1
 void EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
d30 1
a30 1
 void EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
d35 1
a35 1
 void EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
d37 1
a37 1
 void EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
d42 3
a44 1
 void EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
d53 4
a56 1
 #define EVP_CIPHER_iv_length(e)	((e)->iv_len)
a57 1
 int EVP_CIPHER_type(const EVP_CIPHER *ctx);
d61 1
a61 1
 #define EVP_CIPHER_CTX_key_length(e)	((e)->cipher->key_len)
d63 2
d66 2
d77 1
a77 1
EVP_EncryptInit() initialises a cipher context B<ctx> for encryption
d83 2
a84 4
parameters in subsequent calls. This is normally done when the 
EVP_CIPHER_asn1_to_param() function is called to set the cipher
parameters from an ASN1 AlgorithmIdentifier and the key from a
different source.
d112 2
a113 1
encryption and 0 for decryption.
d131 7
a137 1
for all ciphers.
d159 5
d180 5
a184 1
does not have an B<EVP_CIPHER> structure).
d188 2
a189 2
EVP_EncryptInit(), EVP_EncryptUpdate() and EVP_EncryptFinal() do not return
values.
d191 1
a191 1
EVP_DecryptInit() and EVP_DecryptUpdate() do not return values.
d194 2
a195 3
EVP_CipherInit() and EVP_CipherUpdate() do not return values.
EVP_CipherFinal() returns 1 for a decryption failure or 1 for success, if
the operation is encryption then it always returns 1.
d197 1
a197 1
EVP_CIPHER_CTX_cleanup() does not return a value.
d221 69
d309 7
d318 31
a348 3
The current B<EVP> cipher interface is not as flexible as it should be. Only
certain "spot" encryption algorithms can be used for ciphers which have various
parameters associated with them (RC2, RC5 for example) this is inadequate.
d350 2
a351 2
Several of the functions do not return error codes because the software versions
can never fail. This is not true of hardware versions.
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d5 1
a5 15
EVP_CIPHER_CTX_init, EVP_EncryptInit_ex, EVP_EncryptUpdate,
EVP_EncryptFinal_ex, EVP_DecryptInit_ex, EVP_DecryptUpdate,
EVP_DecryptFinal_ex, EVP_CipherInit_ex, EVP_CipherUpdate,
EVP_CipherFinal_ex, EVP_CIPHER_CTX_set_key_length,
EVP_CIPHER_CTX_ctrl, EVP_CIPHER_CTX_cleanup, EVP_EncryptInit,
EVP_EncryptFinal, EVP_DecryptInit, EVP_DecryptFinal,
EVP_CipherInit, EVP_CipherFinal, EVP_get_cipherbyname,
EVP_get_cipherbynid, EVP_get_cipherbyobj, EVP_CIPHER_nid,
EVP_CIPHER_block_size, EVP_CIPHER_key_length, EVP_CIPHER_iv_length,
EVP_CIPHER_flags, EVP_CIPHER_mode, EVP_CIPHER_type, EVP_CIPHER_CTX_cipher,
EVP_CIPHER_CTX_nid, EVP_CIPHER_CTX_block_size, EVP_CIPHER_CTX_key_length,
EVP_CIPHER_CTX_iv_length, EVP_CIPHER_CTX_get_app_data,
EVP_CIPHER_CTX_set_app_data, EVP_CIPHER_CTX_type, EVP_CIPHER_CTX_flags,
EVP_CIPHER_CTX_mode, EVP_CIPHER_param_to_asn1, EVP_CIPHER_asn1_to_param,
EVP_CIPHER_CTX_set_padding - EVP cipher routines
d11 3
a13 5
 int EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);

 int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
	 ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
d15 1
a15 1
 int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,
d18 3
a20 3
 int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
	 ENGINE *impl, unsigned char *key, unsigned char *iv);
 int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
a21 17
 int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         ENGINE *impl, unsigned char *key, unsigned char *iv, int enc);
 int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl, unsigned char *in, int inl);
 int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
         int *outl);

 int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
 int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
         int *outl);

 int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
         unsigned char *key, unsigned char *iv);
d25 1
a25 1
 int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
d27 2
d32 1
a32 4
 int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *x, int padding);
 int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
 int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
 int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
d41 2
a42 3
 #define EVP_CIPHER_iv_length(e)		((e)->iv_len)
 #define EVP_CIPHER_flags(e)		((e)->flags)
 #define EVP_CIPHER_mode(e)		((e)->flags) & EVP_CIPH_MODE)
a43 1

d47 1
a47 1
 #define EVP_CIPHER_CTX_key_length(e)	((e)->key_len)
a48 2
 #define EVP_CIPHER_CTX_get_app_data(e)	((e)->app_data)
 #define EVP_CIPHER_CTX_set_app_data(e,d) ((e)->app_data=(char *)(d))
a49 2
 #define EVP_CIPHER_CTX_flags(e)		((e)->cipher->flags)
 #define EVP_CIPHER_CTX_mode(e)		((e)->cipher->flags & EVP_CIPH_MODE)
d59 10
a68 13
EVP_CIPHER_CTX_init() initializes cipher contex B<ctx>.

EVP_EncryptInit_ex() sets up cipher context B<ctx> for encryption
with cipher B<type> from ENGINE B<impl>. B<ctx> must be initialized
before calling this function. B<type> is normally supplied
by a function such as EVP_des_cbc(). If B<impl> is NULL then the
default implementation is used. B<key> is the symmetric key to use
and B<iv> is the IV to use (if necessary), the actual number of bytes
used for the key and IV depends on the cipher. It is possible to set
all parameters to NULL except B<type> in an initial call and supply
the remaining parameters in subsequent calls, all of which have B<type>
set to NULL. This is done when the default cipher parameters are not
appropriate.
d76 1
a76 1
room. The actual number of bytes written is placed in B<outl>.
d78 6
a83 11
If padding is enabled (the default) then EVP_EncryptFinal_ex() encrypts
the "final" data, that is any data that remains in a partial block.
It uses L<standard block padding|/NOTES> (aka PKCS padding). The encrypted
final data is written to B<out> which should have sufficient space for
one cipher block. The number of bytes written is placed in B<outl>. After
this function is called the encryption operation is finished and no further
calls to EVP_EncryptUpdate() should be made.

If padding is disabled then EVP_EncryptFinal_ex() will not encrypt any more
data and it will return an error if any data remains in a partial block:
that is if the total data length is not a multiple of the block size. 
d85 1
a85 1
EVP_DecryptInit_ex(), EVP_DecryptUpdate() and EVP_DecryptFinal_ex() are the
d87 14
a100 27
error code if padding is enabled and the final block is not correctly
formatted. The parameters and restrictions are identical to the encryption
operations except that if padding is enabled the decrypted data buffer B<out>
passed to EVP_DecryptUpdate() should have sufficient room for
(B<inl> + cipher_block_size) bytes unless the cipher block size is 1 in
which case B<inl> bytes is sufficient.

EVP_CipherInit_ex(), EVP_CipherUpdate() and EVP_CipherFinal_ex() are
functions that can be used for decryption or encryption. The operation
performed depends on the value of the B<enc> parameter. It should be set
to 1 for encryption, 0 for decryption and -1 to leave the value unchanged
(the actual value of 'enc' being supplied in a previous call).

EVP_CIPHER_CTX_cleanup() clears all information from a cipher context
and free up any allocated memory associate with it. It should be called
after all operations using a cipher are complete so sensitive information
does not remain in memory.

EVP_EncryptInit(), EVP_DecryptInit() and EVP_CipherInit() behave in a
similar way to EVP_EncryptInit_ex(), EVP_DecryptInit_ex and
EVP_CipherInit_ex() except the B<ctx> paramter does not need to be
initialized and they always use the default cipher implementation.

EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal() behave in a
similar way to EVP_EncryptFinal_ex(), EVP_DecryptFinal_ex() and
EVP_CipherFinal_ex() except B<ctx> is automatically cleaned up 
after the call.
a110 7
EVP_CIPHER_CTX_set_padding() enables or disables padding. By default
encryption operations are padded using standard block padding and the
padding is checked and removed when decrypting. If the B<pad> parameter
is zero then no padding is performed, the total amount of data encrypted
or decrypted must then be a multiple of the block size or an error will
occur.

d114 1
a114 7
for all ciphers. Note: although EVP_CIPHER_key_length() is fixed for a
given cipher, the value of EVP_CIPHER_CTX_key_length() may be different
for variable key length ciphers.

EVP_CIPHER_CTX_set_key_length() sets the key length of the cipher ctx.
If the cipher is a fixed length cipher then attempting to set the key
length to any value other than the fixed value is an error.
a135 5
EVP_CIPHER_mode() and EVP_CIPHER_CTX_mode() return the block cipher mode:
EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE or
EVP_CIPH_OFB_MODE. If the cipher is a stream cipher then
EVP_CIPH_STREAM_CIPHER is returned.

d152 1
a152 5
is not supported.

EVP_CIPHER_CTX_ctrl() allows various cipher specific parameters to be determined
and set. Currently only the RC2 effective key length and the number of rounds of
RC5 can be set.
d156 2
a157 2
EVP_CIPHER_CTX_init, EVP_EncryptInit_ex(), EVP_EncryptUpdate() and
EVP_EncryptFinal_ex() return 1 for success and 0 for failure.
d159 2
a160 2
EVP_DecryptInit_ex() and EVP_DecryptUpdate() return 1 for success and 0 for failure.
EVP_DecryptFinal_ex() returns 0 if the decrypt failed or 1 for success.
d162 3
a164 2
EVP_CipherInit_ex() and EVP_CipherUpdate() return 1 for success and 0 for failure.
EVP_CipherFinal_ex() returns 0 for a decryption failure or 1 for success.
d166 1
a166 1
EVP_CIPHER_CTX_cleanup() returns 1 for success and 0 for failure.
a178 2
EVP_CIPHER_CTX_set_padding() always returns 1.

a189 69
=head1 CIPHER LISTING

All algorithms have a fixed key length unless otherwise stated.

=over 4

=item EVP_enc_null()

Null cipher: does nothing.

=item EVP_des_cbc(void), EVP_des_ecb(void), EVP_des_cfb(void), EVP_des_ofb(void)

DES in CBC, ECB, CFB and OFB modes respectively. 

=item EVP_des_ede_cbc(void), EVP_des_ede(), EVP_des_ede_ofb(void),  EVP_des_ede_cfb(void)

Two key triple DES in CBC, ECB, CFB and OFB modes respectively.

=item EVP_des_ede3_cbc(void), EVP_des_ede3(), EVP_des_ede3_ofb(void),  EVP_des_ede3_cfb(void)

Three key triple DES in CBC, ECB, CFB and OFB modes respectively.

=item EVP_desx_cbc(void)

DESX algorithm in CBC mode.

=item EVP_rc4(void)

RC4 stream cipher. This is a variable key length cipher with default key length 128 bits.

=item EVP_rc4_40(void)

RC4 stream cipher with 40 bit key length. This is obsolete and new code should use EVP_rc4()
and the EVP_CIPHER_CTX_set_key_length() function.

=item EVP_idea_cbc() EVP_idea_ecb(void), EVP_idea_cfb(void), EVP_idea_ofb(void), EVP_idea_cbc(void)

IDEA encryption algorithm in CBC, ECB, CFB and OFB modes respectively.

=item EVP_rc2_cbc(void), EVP_rc2_ecb(void), EVP_rc2_cfb(void), EVP_rc2_ofb(void)

RC2 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
length cipher with an additional parameter called "effective key bits" or "effective key length".
By default both are set to 128 bits.

=item EVP_rc2_40_cbc(void), EVP_rc2_64_cbc(void)

RC2 algorithm in CBC mode with a default key length and effective key length of 40 and 64 bits.
These are obsolete and new code should use EVP_rc2_cbc(), EVP_CIPHER_CTX_set_key_length() and
EVP_CIPHER_CTX_ctrl() to set the key length and effective key length.

=item EVP_bf_cbc(void), EVP_bf_ecb(void), EVP_bf_cfb(void), EVP_bf_ofb(void);

Blowfish encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
length cipher.

=item EVP_cast5_cbc(void), EVP_cast5_ecb(void), EVP_cast5_cfb(void), EVP_cast5_ofb(void)

CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key
length cipher.

=item EVP_rc5_32_12_16_cbc(void), EVP_rc5_32_12_16_ecb(void), EVP_rc5_32_12_16_cfb(void), EVP_rc5_32_12_16_ofb(void)

RC5 encryption algorithm in CBC, ECB, CFB and OFB modes respectively. This is a variable key length
cipher with an additional "number of rounds" parameter. By default the key length is set to 128
bits and 12 rounds.

=back

d204 4
a207 14
Although the decryption operation can produce an error if padding is enabled,
it is not a strong test that the input data or key is correct. A random block
has better than 1 in 256 chance of being of the correct format and problems with
the input data earlier on will not produce a final decrypt error.

If padding is disabled then the decryption operation will always succeed if
the total amount of data decrypted is a multiple of the block size.

The functions EVP_EncryptInit(), EVP_EncryptFinal(), EVP_DecryptInit(),
EVP_CipherInit() and EVP_CipherFinal() are obsolete but are retained for
compatibility with existing code. New code should use EVP_EncryptInit_ex(),
EVP_EncryptFinal_ex(), EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(),
EVP_CipherInit_ex() and EVP_CipherFinal_ex() because they can reuse an
existing context without allocating and freeing it up on each call.
d211 3
a213 122
For RC5 the number of rounds can currently only be set to 8, 12 or 16. This is
a limitation of the current RC5 code rather than the EVP interface.

EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers with
default key lengths. If custom ciphers exceed these values the results are
unpredictable. This is because it has become standard practice to define a 
generic key as a fixed unsigned char array containing EVP_MAX_KEY_LENGTH bytes.

The ASN1 code is incomplete (and sometimes inaccurate) it has only been tested
for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC mode.

=head1 EXAMPLES

Get the number of rounds used in RC5:

 int nrounds;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC5_ROUNDS, 0, &nrounds);

Get the RC2 effective key length:

 int key_bits;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GET_RC2_KEY_BITS, 0, &key_bits);

Set the number of rounds used in RC5:

 int nrounds;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC5_ROUNDS, nrounds, NULL);

Set the effective key length used in RC2:

 int key_bits;
 EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);

Encrypt a string using blowfish:

 int do_crypt(char *outfile)
 	{
	unsigned char outbuf[1024];
	int outlen, tmplen;
	/* Bogus key and IV: we'd normally set these from
	 * another source.
	 */
	unsigned char key[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
	unsigned char iv[] = {1,2,3,4,5,6,7,8};
	char intext[] = "Some Crypto Text";
	EVP_CIPHER_CTX ctx;
	FILE *out;
	EVP_CIPHER_CTX_init(&ctx);
	EVP_EncryptInit_ex(&ctx, NULL, EVP_bf_cbc(), key, iv);

	if(!EVP_EncryptUpdate(&ctx, outbuf, &outlen, intext, strlen(intext)))
		{
		/* Error */
		return 0;
		}
	/* Buffer passed to EVP_EncryptFinal() must be after data just
	 * encrypted to avoid overwriting it.
	 */
	if(!EVP_EncryptFinal_ex(&ctx, outbuf + outlen, &tmplen))
		{
		/* Error */
		return 0;
		}
	outlen += tmplen;
	EVP_CIPHER_CTX_cleanup(&ctx);
	/* Need binary mode for fopen because encrypted data is
	 * binary data. Also cannot use strlen() on it because
         * it wont be null terminated and may contain embedded
	 * nulls.
	 */
	out = fopen(outfile, "wb");
	fwrite(outbuf, 1, outlen, out);
	fclose(out);
	return 1;
	}

The ciphertext from the above example can be decrypted using the B<openssl>
utility with the command line:
 
 S<openssl bf -in cipher.bin -K 000102030405060708090A0B0C0D0E0F -iv 0102030405060708 -d>

General encryption, decryption function example using FILE I/O and RC2 with an
80 bit key:

 int do_crypt(FILE *in, FILE *out, int do_encrypt)
 	{
	/* Allow enough space in output buffer for additional block */
	inbuf[1024], outbuf[1024 + EVP_MAX_BLOCK_LENGTH];
	int inlen, outlen;
	/* Bogus key and IV: we'd normally set these from
	 * another source.
	 */
	unsigned char key[] = "0123456789";
	unsigned char iv[] = "12345678";
	/* Don't set key or IV because we will modify the parameters */
	EVP_CIPHER_CTX_init(&ctx);
	EVP_CipherInit_ex(&ctx, EVP_rc2(), NULL, NULL, NULL, do_encrypt);
	EVP_CIPHER_CTX_set_key_length(&ctx, 10);
	/* We finished modifying parameters so now we can set key and IV */
	EVP_CipherInit_ex(&ctx, NULL, NULL, key, iv, do_encrypt);

	for(;;) 
		{
		inlen = fread(inbuf, 1, 1024, in);
		if(inlen <= 0) break;
		if(!EVP_CipherUpdate(&ctx, outbuf, &outlen, inbuf, inlen))
			{
			/* Error */
			return 0;
			}
		fwrite(outbuf, 1, outlen, out);
		}
	if(!EVP_CipherFinal_ex(&ctx, outbuf, &outlen))
		{
		/* Error */
		return 0;
		}
	fwrite(outbuf, 1, outlen, out);

	EVP_CIPHER_CTX_cleanup(&ctx);
	return 1;
	}
d215 2
@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@a503 5
EVP_CIPHER_CTX_init(), EVP_EncryptInit_ex(), EVP_EncryptFinal_ex(),
EVP_DecryptInit_ex(), EVP_DecryptFinal_ex(), EVP_CipherInit_ex(),
EVP_CipherFinal_ex() and EVP_CIPHER_CTX_set_padding() appeared in
OpenSSL 0.9.7.

@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d422 1
a422 1
	EVP_EncryptInit_ex(&ctx, EVP_bf_cbc(), NULL, key, iv);
@


1.1.1.4
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a481 1
			EVP_CIPHER_CTX_cleanup(&ctx);
a488 1
		EVP_CIPHER_CTX_cleanup(&ctx);
@


1.1.1.5
log
@import of openssl-0.9.7j
@
text
@d25 1
a25 1
 void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a);
d239 2
a240 2
EVP_EncryptInit_ex(), EVP_EncryptUpdate() and EVP_EncryptFinal_ex()
return 1 for success and 0 for failure.
@


1.1.1.6
log
@Import OpenSSL 1.0.1g
@
text
@d155 1
a155 1
EVP_CipherInit_ex() except the B<ctx> parameter does not need to be
@


