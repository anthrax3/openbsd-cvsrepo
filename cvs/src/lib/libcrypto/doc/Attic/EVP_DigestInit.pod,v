head	1.21;
access;
symbols;
locks; strict;
comment	@# @;


1.21
date	2016.11.03.09.35.34;	author schwarze;	state dead;
branches;
next	1.20;
commitid	3WfE7ZbXXRiIqemG;

1.20
date	2015.11.11.22.14.40;	author jmc;	state Exp;
branches;
next	1.19;
commitid	eNNq8UNxWW0rsWWg;

1.19
date	2015.09.17.14.43.23;	author bcook;	state Exp;
branches;
next	1.18;
commitid	hm2e9MAuIdS7Wqnc;

1.18
date	2015.09.17.14.11.29;	author sthen;	state Exp;
branches;
next	1.17;
commitid	IxB70SS4rT0ZdPC2;

1.17
date	2015.09.13.21.09.56;	author doug;	state Exp;
branches;
next	1.16;
commitid	e818W60lrMrFrzEk;

1.16
date	2015.06.20.01.07.25;	author doug;	state Exp;
branches;
next	1.15;
commitid	odUD1eZ4N02tuzg5;

1.15
date	2015.02.14.18.08.20;	author miod;	state Exp;
branches;
next	1.14;
commitid	YLOWvfHDeNNy6eOq;

1.14
date	2014.07.11.16.18.14;	author miod;	state Exp;
branches;
next	1.13;
commitid	KFr43un1Uq8AaqNL;

1.13
date	2014.07.10.14.14.04;	author miod;	state Exp;
branches;
next	1.12;
commitid	VVoKhghxvV7qSanI;

1.12
date	2014.05.04.22.26.33;	author jim;	state Exp;
branches;
next	1.11;

1.11
date	2014.05.04.21.46.36;	author jim;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.58;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.10.16.31.56;	author markus;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.15.02.29.19;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.15.02.58.27;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.03.19.27.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.19.11.12.58;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.51.17;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.22.43.16;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.20.42.00;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.49;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.14;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2012.10.13.21.23.47;	author djm;	state Exp;
branches;
next	;


desc
@@


1.21
log
@convert EVP manuals from pod to mdoc
@
text
@=pod

=head1 NAME

EVP_MD_CTX_init, EVP_MD_CTX_create, EVP_DigestInit_ex, EVP_DigestUpdate,
EVP_DigestFinal_ex, EVP_MD_CTX_cleanup, EVP_MD_CTX_destroy, EVP_MAX_MD_SIZE,
EVP_MD_CTX_copy_ex, EVP_MD_CTX_copy, EVP_MD_type, EVP_MD_pkey_type,
EVP_MD_size, EVP_MD_block_size, EVP_MD_CTX_md, EVP_MD_CTX_size,
EVP_MD_CTX_block_size, EVP_MD_CTX_type, EVP_md_null, EVP_md2, EVP_md5,
EVP_sha1, EVP_sha224, EVP_sha256, EVP_sha384, EVP_sha512, EVP_dss, EVP_dss1,
EVP_ripemd160, EVP_get_digestbyname, EVP_get_digestbynid,
EVP_get_digestbyobj, EVP_DigestInit, EVP_DigestFinal - EVP digest routines

=head1 SYNOPSIS

 #include <openssl/evp.h>

 void EVP_MD_CTX_init(EVP_MD_CTX *ctx);
 EVP_MD_CTX *EVP_MD_CTX_create(void);

 int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);
 int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);
 int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,
        unsigned int *s);

 int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
 void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);

 int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);

 int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
 int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,
        unsigned int *s);

 int EVP_MD_CTX_copy(EVP_MD_CTX *out,EVP_MD_CTX *in);

 #define EVP_MAX_MD_SIZE 64	/* SHA512 */

 int EVP_MD_type(const EVP_MD *md);
 int EVP_MD_pkey_type(const EVP_MD *md);
 int EVP_MD_size(const EVP_MD *md);
 int EVP_MD_block_size(const EVP_MD *md);

 const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);
 #define EVP_MD_CTX_size(e)		EVP_MD_size(EVP_MD_CTX_md(e))
 #define EVP_MD_CTX_block_size(e)	EVP_MD_block_size((e)->digest)
 #define EVP_MD_CTX_type(e)		EVP_MD_type((e)->digest)

 const EVP_MD *EVP_md_null(void);
 const EVP_MD *EVP_md2(void);
 const EVP_MD *EVP_md5(void);
 const EVP_MD *EVP_sha1(void);
 const EVP_MD *EVP_dss(void);
 const EVP_MD *EVP_dss1(void);
 const EVP_MD *EVP_ripemd160(void);

 const EVP_MD *EVP_sha224(void);
 const EVP_MD *EVP_sha256(void);
 const EVP_MD *EVP_sha384(void);
 const EVP_MD *EVP_sha512(void);

 const EVP_MD *EVP_get_digestbyname(const char *name);
 #define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))
 #define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))

=head1 DESCRIPTION

The EVP digest routines are a high level interface to message digests.

EVP_MD_CTX_init() initializes digest context B<ctx>.

EVP_MD_CTX_create() allocates, initializes and returns a digest context.

EVP_DigestInit_ex() sets up digest context B<ctx> to use a digest
B<type> from ENGINE B<impl>. B<ctx> must be initialized before calling this
function. B<type> will typically be supplied by a function such as EVP_sha1().
If B<impl> is NULL then the default implementation of digest B<type> is used.

EVP_DigestUpdate() hashes B<cnt> bytes of data at B<d> into the
digest context B<ctx>. This function can be called several times on the
same B<ctx> to hash additional data.

EVP_DigestFinal_ex() retrieves the digest value from B<ctx> and places
it in B<md>. If the B<s> parameter is not NULL then the number of
bytes of data written (i.e. the length of the digest) will be written
to the integer at B<s>, at most B<EVP_MAX_MD_SIZE> bytes will be written.
After calling EVP_DigestFinal_ex() no additional calls to EVP_DigestUpdate()
can be made, but EVP_DigestInit_ex() can be called to initialize a new
digest operation.

EVP_MD_CTX_cleanup() cleans up digest context B<ctx>, it should be called
after a digest context is no longer needed.

EVP_MD_CTX_destroy() cleans up digest context B<ctx> and frees up the
space allocated to it, it should be called only on a context created
using EVP_MD_CTX_create().

EVP_MD_CTX_copy_ex() can be used to copy the message digest state from
B<in> to B<out>. This is useful if large amounts of data are to be
hashed which only differ in the last few bytes. B<out> must be initialized
before calling this function.

EVP_DigestInit() behaves in the same way as EVP_DigestInit_ex() except
the passed context B<ctx> does not have to be initialized, and it always
uses the default digest implementation.

EVP_DigestFinal() is similar to EVP_DigestFinal_ex() except the digest
context B<ctx> is automatically cleaned up.

EVP_MD_CTX_copy() is similar to EVP_MD_CTX_copy_ex() except the destination
B<out> does not have to be initialized.

EVP_MD_size() and EVP_MD_CTX_size() return the size of the message digest
when passed an B<EVP_MD> or an B<EVP_MD_CTX> structure, i.e. the size of the
hash.

EVP_MD_block_size() and EVP_MD_CTX_block_size() return the block size of the
message digest when passed an B<EVP_MD> or an B<EVP_MD_CTX> structure.

EVP_MD_type() and EVP_MD_CTX_type() return the NID of the OBJECT IDENTIFIER
representing the given message digest when passed an B<EVP_MD> structure.
For example EVP_MD_type(EVP_sha1()) returns B<NID_sha1>. This function is
normally used when setting ASN1 OIDs.

EVP_MD_CTX_md() returns the B<EVP_MD> structure corresponding to the passed
B<EVP_MD_CTX>.

EVP_MD_pkey_type() returns the NID of the public key signing algorithm
associated with this digest. For example EVP_sha1() is associated with RSA so
this will return B<NID_sha1WithRSAEncryption>. Since digests and signature
algorithms are no longer linked this function is only retained for
compatibility reasons.

EVP_md2(), EVP_md5(), EVP_sha1(), EVP_sha224(), EVP_sha256(), EVP_sha384(),
EVP_sha512() and EVP_ripemd160() return B<EVP_MD> structures for the MD2, MD5,
SHA1, SHA224, SHA256, SHA384, SHA512 and RIPEMD160 digest algorithms
respectively.

EVP_dss() and EVP_dss1() return B<EVP_MD> structures for SHA1 digest
algorithms but using DSS (DSA) for the signature algorithm. Note: there is
no need to use these pseudo-digests in OpenSSL 1.0.0 and later, they are
however retained for compatibility.

EVP_md_null() is a "null" message digest that does nothing: i.e. the hash it
returns is of zero length.

EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj()
return an B<EVP_MD> structure when passed a digest name, a digest NID or
an ASN1_OBJECT structure respectively. The digest table must be initialized
using, for example, OpenSSL_add_all_digests() for these functions to work.

=head1 RETURN VALUES

EVP_DigestInit_ex(), EVP_DigestUpdate() and EVP_DigestFinal_ex() return 1 for
success and 0 for failure.

EVP_MD_CTX_copy_ex() returns 1 if successful or 0 for failure.

EVP_MD_type(), EVP_MD_pkey_type() and EVP_MD_type() return the NID of the
corresponding OBJECT IDENTIFIER or NID_undef if none exists.

EVP_MD_size(), EVP_MD_block_size(), EVP_MD_CTX_size() and
EVP_MD_CTX_block_size() return the digest or block size in bytes.

EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha1(), EVP_dss(),
EVP_dss1() and EVP_ripemd160() return pointers to the
corresponding EVP_MD structures.

EVP_get_digestbyname(), EVP_get_digestbynid() and EVP_get_digestbyobj()
return either an B<EVP_MD> structure or NULL if an error occurs.

=head1 NOTES

The B<EVP> interface to message digests should almost always be used in
preference to the low level interfaces. This is because the code then becomes
transparent to the digest used and much more flexible.

New applications should use the SHA2 digest algorithms such as SHA256.
The other digest algorithms are still in common use.

For most applications the B<impl> parameter to EVP_DigestInit_ex() will be
set to NULL to use the default digest implementation.

The functions EVP_DigestInit(), EVP_DigestFinal() and EVP_MD_CTX_copy() are
obsolete but are retained to maintain compatibility with existing code. New
applications should use EVP_DigestInit_ex(), EVP_DigestFinal_ex() and
EVP_MD_CTX_copy_ex() because they can efficiently reuse a digest context
instead of initializing and cleaning it up on each call and allow non default
implementations of digests to be specified.

In OpenSSL 0.9.7 and later if digest contexts are not cleaned up after use
memory leaks will occur.

Stack allocation of EVP_MD_CTX structures is common, for example:

 EVP_MD_CTX mctx;
 EVP_MD_CTX_init(&mctx);

This will cause binary compatibility issues if the size of EVP_MD_CTX
structure changes (this will only happen with a major release of OpenSSL).
Applications wishing to avoid this should use EVP_MD_CTX_create() instead:

 EVP_MD_CTX *mctx;
 mctx = EVP_MD_CTX_create();


=head1 EXAMPLE

This example digests the data "Test Message\n" and "Hello World\n", using the
digest name passed on the command line.

 #include <stdio.h>
 #include <openssl/evp.h>

 int
 main(int argc, char *argv[])
 {
	EVP_MD_CTX *mdctx;
	const EVP_MD *md;
	const char mess1[] = "Test Message\n";
	const char mess2[] = "Hello World\n";
	unsigned char md_value[EVP_MAX_MD_SIZE];
	int md_len, i;

	OpenSSL_add_all_digests();

	if (argc <= 1) {
		printf("Usage: mdtest digestname\n");
		exit(1);
	}

	md = EVP_get_digestbyname(argv[1]);
	if (md == NULL) {
		printf("Unknown message digest %s\n", argv[1]);
		exit(1);
	}

	mdctx = EVP_MD_CTX_create();
	EVP_DigestInit_ex(mdctx, md, NULL);
	EVP_DigestUpdate(mdctx, mess1, strlen(mess1));
	EVP_DigestUpdate(mdctx, mess2, strlen(mess2));
	EVP_DigestFinal_ex(mdctx, md_value, &md_len);
	EVP_MD_CTX_destroy(mdctx);

	printf("Digest is: ");
	for(i = 0; i < md_len; i++)
		printf("%02x", md_value[i]);
	printf("\n");
 }

=head1 SEE ALSO

L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>,
L<md5(3)|md5(3)>, L<ripemd(3)|ripemd(3)>,
L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>

=head1 HISTORY

EVP_DigestInit(), EVP_DigestUpdate() and EVP_DigestFinal() are
available in all versions of SSLeay and OpenSSL.

EVP_MD_CTX_init(), EVP_MD_CTX_create(), EVP_MD_CTX_copy_ex(),
EVP_MD_CTX_cleanup(), EVP_MD_CTX_destroy(), EVP_DigestInit_ex()
and EVP_DigestFinal_ex() were added in OpenSSL 0.9.7.

EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha1(),
EVP_dss(), EVP_dss1() and EVP_ripemd160() were
changed to return truely const EVP_MD * in OpenSSL 0.9.7.

The link between digests and signing algorithms was fixed in OpenSSL 1.0 and
later, so now EVP_sha1() can be used with RSA and DSA, there is no need to
use EVP_dss1() any more.

OpenSSL 1.0 and later does not include the MD2 digest algorithm in the
default configuration due to its security weaknesses.

=cut
@


1.20
log
@add missing functions to NAME, or otherwise correct the mlink
entry for them;

feedback/ok schwarze
@
text
@@


1.19
log
@Remove more EVP_sha() SHA-0 references.
@
text
@d12 1
a12 1
EVP_get_digestbyobj - EVP digest routines
@


1.18
log
@Re-add missing comma from SHA-0 removal which breaks mlinks generation.
Worked out by bcook@@
@
text
@d165 1
a165 1
EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_dss(),
d266 1
a266 1
EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(),
@


1.17
log
@Remove SHA-0 support.

SHA-0 was withdrawn shortly after publication 20 years ago and replaced
with SHA-1.  This will require a major crank.

ok bcook@@, jsing@@
@
text
@d9 1
a9 1
EVP_MD_CTX_block_size, EVP_MD_CTX_type, EVP_md_null, EVP_md2, EVP_md5
@


1.16
log
@Remove obsolete MDC-2DES from libcrypto.

ok deraadt@@ jsing@@ miod@@
@
text
@d9 1
a9 1
EVP_MD_CTX_block_size, EVP_MD_CTX_type, EVP_md_null, EVP_md2, EVP_md5, EVP_sha,
a51 1
 const EVP_MD *EVP_sha(void);
d134 4
a137 4
EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_sha224(), EVP_sha256(),
EVP_sha384(), EVP_sha512() and EVP_ripemd160() return B<EVP_MD>
structures for the MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512
and RIPEMD160 digest algorithms respectively.
d139 1
a139 1
EVP_dss() and EVP_dss1() return B<EVP_MD> structures for SHA and SHA1 digest
@


1.15
log
@Words read better when they are separated by spaces.
@
text
@d11 1
a11 1
EVP_mdc2, EVP_ripemd160, EVP_get_digestbyname, EVP_get_digestbynid,
a55 1
 const EVP_MD *EVP_mdc2(void);
d136 2
a137 2
EVP_sha384(), EVP_sha512(), EVP_mdc2() and EVP_ripemd160() return B<EVP_MD>
structures for the MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512, MDC2
d167 1
a167 1
EVP_dss1(), EVP_mdc2() and EVP_ripemd160() return pointers to the
d255 1
a255 1
L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|ripemd(3)>,
d268 1
a268 1
EVP_dss(), EVP_dss1(), EVP_mdc2() and EVP_ripemd160() were
@


1.14
log
@Huge documentation update for libcrypto and libssl, mostly from Matt Caswell,
Jeff Trawick, Jean-Paul Calderone, Michal Bozon, Jeffrey Walton and Rich Salz,
via OpenSSL trunk (with some parts not applying to us, such as SSLv2 support,
at least partially removed).
@
text
@d78 1
a78 1
function. B<type> will typically be supplied by a functionsuch as EVP_sha1().
@


1.13
log
@Try and fix the horrible coding style of the example code snippets.
@
text
@d164 2
a165 3
EVP_MD_size(), EVP_MD_block_size(), EVP_MD_CTX_size(e), EVP_MD_size(),
EVP_MD_CTX_block_size()	and EVP_MD_block_size() return the digest or block
size in bytes.
@


1.12
log
@Improve line wrapping for lines exceeding 80 chars.

ok jmc@@
@
text
@d218 1
d221 31
a251 31
 EVP_MD_CTX *mdctx;
 const EVP_MD *md;
 char mess1[] = "Test Message\n";
 char mess2[] = "Hello World\n";
 unsigned char md_value[EVP_MAX_MD_SIZE];
 int md_len, i;

 OpenSSL_add_all_digests();

 if(!argv[1]) {
 	printf("Usage: mdtest digestname\n");
	exit(1);
 }

 md = EVP_get_digestbyname(argv[1]);

 if(!md) {
 	printf("Unknown message digest %s\n", argv[1]);
	exit(1);
 }

 mdctx = EVP_MD_CTX_create();
 EVP_DigestInit_ex(mdctx, md, NULL);
 EVP_DigestUpdate(mdctx, mess1, strlen(mess1));
 EVP_DigestUpdate(mdctx, mess2, strlen(mess2));
 EVP_DigestFinal_ex(mdctx, md_value, &md_len);
 EVP_MD_CTX_destroy(mdctx);

 printf("Digest is: ");
 for(i = 0; i < md_len; i++) printf("%02x", md_value[i]);
 printf("\n");
@


1.11
log
@Remove trailing whitespace.

fine jmc@@
@
text
@d7 6
a12 6
EVP_MD_CTX_copy_ex, EVP_MD_CTX_copy, EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size,
EVP_MD_block_size, EVP_MD_CTX_md, EVP_MD_CTX_size, EVP_MD_CTX_block_size, EVP_MD_CTX_type,
EVP_md_null, EVP_md2, EVP_md5, EVP_sha, EVP_sha1, EVP_sha224, EVP_sha256,
EVP_sha384, EVP_sha512, EVP_dss, EVP_dss1, EVP_mdc2,
EVP_ripemd160, EVP_get_digestbyname, EVP_get_digestbynid, EVP_get_digestbyobj -
EVP digest routines
d130 5
a134 5
EVP_MD_pkey_type() returns the NID of the public key signing algorithm associated
with this digest. For example EVP_sha1() is associated with RSA so this will
return B<NID_sha1WithRSAEncryption>. Since digests and signature algorithms
are no longer linked this function is only retained for compatibility
reasons.
@


1.10
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d29 1
a29 1
 int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);  
d35 1
a35 1
 int EVP_MD_CTX_copy(EVP_MD_CTX *out,EVP_MD_CTX *in);  
d40 1
a40 1
 int EVP_MD_pkey_type(const EVP_MD *md);	
d139 1
a139 1
and RIPEMD160 digest algorithms respectively. 
d142 1
a142 1
algorithms but using DSS (DSA) for the signature algorithm. Note: there is 
d181 1
a181 1
New applications should use the SHA2 digest algorithms such as SHA256. 
d187 1
a187 1
The functions EVP_DigestInit(), EVP_DigestFinal() and EVP_MD_CTX_copy() are 
d189 1
a189 1
applications should use EVP_DigestInit_ex(), EVP_DigestFinal_ex() and 
d195 1
a195 1
memory leaks will occur. 
@


1.9
log
@resolve conflicts
@
text
@d255 3
a257 3
L<evp(3)|evp(3)>, L<HMAC(3)|HMAC(3)>, L<MD2(3)|MD2(3)>,
L<MD5(3)|MD5(3)>, L<MDC2(3)|MDC2(3)>, L<RIPEMD160(3)|RIPEMD160(3)>,
L<SHA1(3)|SHA1(3)>
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d9 2
a10 1
EVP_md_null, EVP_md2, EVP_md5, EVP_sha, EVP_sha1, EVP_dss, EVP_dss1, EVP_mdc2,
d37 1
a37 1
 #define EVP_MAX_MD_SIZE (16+20) /* The SSLv3 md5+sha1 type */
d39 4
d44 2
a45 7
 #define EVP_MD_type(e)			((e)->type)
 #define EVP_MD_pkey_type(e)		((e)->pkey_type)
 #define EVP_MD_size(e)			((e)->md_size)
 #define EVP_MD_block_size(e)		((e)->block_size)

 #define EVP_MD_CTX_md(e)		(e)->digest)
 #define EVP_MD_CTX_size(e)		EVP_MD_size((e)->digest)
d59 5
d132 8
a139 6
return B<NID_sha1WithRSAEncryption>. This "link" between digests and signature
algorithms may not be retained in future versions of OpenSSL.

EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_mdc2() and EVP_ripemd160()
return B<EVP_MD> structures for the MD2, MD5, SHA, SHA1, MDC2 and RIPEMD160 digest
algorithms respectively. The associated signature algorithm is RSA in each case.
d181 2
a182 2
SHA1 is the digest of choice for new applications. The other digest algorithms
are still in common use.
d197 13
d220 1
a220 1
 EVP_MD_CTX mdctx;
d241 6
a246 6
 EVP_MD_CTX_init(&mdctx);
 EVP_DigestInit_ex(&mdctx, md, NULL);
 EVP_DigestUpdate(&mdctx, mess1, strlen(mess1));
 EVP_DigestUpdate(&mdctx, mess2, strlen(mess2));
 EVP_DigestFinal_ex(&mdctx, md_value, &md_len);
 EVP_MD_CTX_cleanup(&mdctx);
@


1.7
log
@resolve conflicts
@
text
@d67 1
a67 1
EVP_MD_CTX_init() initializes digest contet B<ctx>.
d69 1
a69 1
EVP_MD_CTX_create() allocates, initializes and returns a digest contet.
d105 1
a105 1
contet B<ctx> is automatically cleaned up.
d135 3
a137 1
algorithms but using DSS (DSA) for the signature algorithm.
a232 6
=head1 BUGS

The link between digests and signing algorithms results in a situation where
EVP_sha1() must be used with RSA and EVP_dss1() must be used with DSS
even though they are identical digests.

d251 7
@


1.6
log
@merge 0.9.7d
@
text
@d21 1
a21 1
 int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);
@


1.5
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d7 1
a7 1
EVP_MD_CTX_copy_ex EVP_MD_CTX_copy, EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size,
@


1.4
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d248 7
a254 2
EVP_DigestInit_ex(), EVP_DigestFinal_ex() and EVP_MD_CTX_copy_ex()
were added in OpenSSL 0.9.7.
@


1.3
log
@openssl-engine-0.9.6 merge
@
text
@d5 4
a8 3
EVP_DigestInit, EVP_DigestUpdate, EVP_DigestFinal, EVP_MAX_MD_SIZE,
EVP_MD_CTX_copy, EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size, EVP_MD_block_size,
EVP_MD_CTX_md, EVP_MD_CTX_size, EVP_MD_CTX_block_size, EVP_MD_CTX_type,
d17 15
a31 3
 void EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
 void EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);
 void EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,
d34 2
a37 1
 int EVP_MD_CTX_copy(EVP_MD_CTX *out,EVP_MD_CTX *in);  
d49 9
a57 9
 EVP_MD *EVP_md_null(void);
 EVP_MD *EVP_md2(void);
 EVP_MD *EVP_md5(void);
 EVP_MD *EVP_sha(void);
 EVP_MD *EVP_sha1(void);
 EVP_MD *EVP_dss(void);
 EVP_MD *EVP_dss1(void);
 EVP_MD *EVP_mdc2(void);
 EVP_MD *EVP_ripemd160(void);
d67 8
a74 3
EVP_DigestInit() initializes a digest context B<ctx> to use a digest
B<type>: this will typically be supplied by a function such as
EVP_sha1().
d80 1
a80 1
EVP_DigestFinal() retrieves the digest value from B<ctx> and places
d84 2
a85 2
After calling EVP_DigestFinal() no additional calls to EVP_DigestUpdate()
can be made, but EVP_DigestInit() can be called to initialize a new
d88 8
a95 1
EVP_MD_CTX_copy() can be used to copy the message digest state from
d97 12
a108 1
hashed which only differ in the last few bytes.
d147 2
a148 1
EVP_DigestInit(), EVP_DigestUpdate() and EVP_DigestFinal() do not return values.
d150 1
a150 1
EVP_MD_CTX_copy() returns 1 if successful or 0 for failure.
d175 13
d219 2
a220 1
 EVP_DigestInit(&mdctx, md);
d223 2
a224 1
 EVP_DigestFinal(&mdctx, md_value, &md_len);
a232 4
Several of the functions do not return values: maybe they should. Although the
internal digest operations will never fail some future hardware based operations
might.

a236 3
The size of an B<EVP_MD_CTX> structure is determined at compile time: this results
in code that must be recompiled if the size of B<EVP_MD_CTX> increases.

d247 3
@


1.2
log
@correct Xr to where we actually install the man pages
@
text
@d5 6
a10 1
EVP_DigestInit, EVP_DigestUpdate, EVP_DigestFinal - EVP digest routines
d53 1
a53 1
EVP_DigestInit() initialises a digest context B<ctx> to use a digest
d58 1
a58 1
digest context B<ctx>. This funtion can be called several times on the
d66 1
a66 1
can be made, but EVP_DigestInit() can be called to initialiase a new
d105 1
a105 1
an ASN1_OBJECT structure respectively. The digest table must be initialised
@


1.1
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d188 3
a190 3
L<evp(3)|evp(3)>, L<hmac(3)|hmac(3)>, L<md2(3)|md2(3)>,
L<md5(3)|md5(3)>, L<mdc2(3)|mdc2(3)>, L<ripemd(3)|ripemd(3)>,
L<sha(3)|sha(3)>, L<digest(1)|digest(1)>
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@d5 1
a5 7
EVP_MD_CTX_init, EVP_MD_CTX_create, EVP_DigestInit_ex, EVP_DigestUpdate,
EVP_DigestFinal_ex, EVP_MD_CTX_cleanup, EVP_MD_CTX_destroy, EVP_MAX_MD_SIZE,
EVP_MD_CTX_copy_ex EVP_MD_CTX_copy, EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size,
EVP_MD_block_size, EVP_MD_CTX_md, EVP_MD_CTX_size, EVP_MD_CTX_block_size, EVP_MD_CTX_type,
EVP_md_null, EVP_md2, EVP_md5, EVP_sha, EVP_sha1, EVP_dss, EVP_dss1, EVP_mdc2,
EVP_ripemd160, EVP_get_digestbyname, EVP_get_digestbynid, EVP_get_digestbyobj -
EVP digest routines
d11 3
a13 6
 void EVP_MD_CTX_init(EVP_MD_CTX *ctx);
 EVP_MD_CTX *EVP_MD_CTX_create(void);

 int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);
 int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, unsigned int cnt);
 int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,
d16 1
a16 8
 int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
 void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);

 int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);  

 int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
 int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,
        unsigned int *s);
a19 3
 #define EVP_MAX_MD_SIZE (16+20) /* The SSLv3 md5+sha1 type */


d30 9
a38 9
 const EVP_MD *EVP_md_null(void);
 const EVP_MD *EVP_md2(void);
 const EVP_MD *EVP_md5(void);
 const EVP_MD *EVP_sha(void);
 const EVP_MD *EVP_sha1(void);
 const EVP_MD *EVP_dss(void);
 const EVP_MD *EVP_dss1(void);
 const EVP_MD *EVP_mdc2(void);
 const EVP_MD *EVP_ripemd160(void);
d48 3
a50 8
EVP_MD_CTX_init() initializes digest contet B<ctx>.

EVP_MD_CTX_create() allocates, initializes and returns a digest contet.

EVP_DigestInit_ex() sets up digest context B<ctx> to use a digest
B<type> from ENGINE B<impl>. B<ctx> must be initialized before calling this
function. B<type> will typically be supplied by a functionsuch as EVP_sha1().
If B<impl> is NULL then the default implementation of digest B<type> is used.
d53 1
a53 1
digest context B<ctx>. This function can be called several times on the
d56 1
a56 1
EVP_DigestFinal_ex() retrieves the digest value from B<ctx> and places
d60 2
a61 2
After calling EVP_DigestFinal_ex() no additional calls to EVP_DigestUpdate()
can be made, but EVP_DigestInit_ex() can be called to initialize a new
d64 1
a64 8
EVP_MD_CTX_cleanup() cleans up digest context B<ctx>, it should be called
after a digest context is no longer needed.

EVP_MD_CTX_destroy() cleans up digest context B<ctx> and frees up the
space allocated to it, it should be called only on a context created
using EVP_MD_CTX_create().

EVP_MD_CTX_copy_ex() can be used to copy the message digest state from
d66 1
a66 12
hashed which only differ in the last few bytes. B<out> must be initialized
before calling this function.

EVP_DigestInit() behaves in the same way as EVP_DigestInit_ex() except
the passed context B<ctx> does not have to be initialized, and it always
uses the default digest implementation.

EVP_DigestFinal() is similar to EVP_DigestFinal_ex() except the digest
contet B<ctx> is automatically cleaned up.

EVP_MD_CTX_copy() is similar to EVP_MD_CTX_copy_ex() except the destination
B<out> does not have to be initialized.
d100 1
a100 1
an ASN1_OBJECT structure respectively. The digest table must be initialized
d105 1
a105 2
EVP_DigestInit_ex(), EVP_DigestUpdate() and EVP_DigestFinal_ex() return 1 for
success and 0 for failure.
d107 1
a107 1
EVP_MD_CTX_copy_ex() returns 1 if successful or 0 for failure.
a131 13
For most applications the B<impl> parameter to EVP_DigestInit_ex() will be
set to NULL to use the default digest implementation.

The functions EVP_DigestInit(), EVP_DigestFinal() and EVP_MD_CTX_copy() are 
obsolete but are retained to maintain compatibility with existing code. New
applications should use EVP_DigestInit_ex(), EVP_DigestFinal_ex() and 
EVP_MD_CTX_copy_ex() because they can efficiently reuse a digest context
instead of initializing and cleaning it up on each call and allow non default
implementations of digests to be specified.

In OpenSSL 0.9.7 and later if digest contexts are not cleaned up after use
memory leaks will occur. 

d163 1
a163 2
 EVP_MD_CTX_init(&mdctx);
 EVP_DigestInit_ex(&mdctx, md, NULL);
d166 1
a166 2
 EVP_DigestFinal_ex(&mdctx, md_value, &md_len);
 EVP_MD_CTX_cleanup(&mdctx);
d175 4
d183 3
a195 3

EVP_DigestInit_ex(), EVP_DigestFinal_ex() and EVP_MD_CTX_copy_ex()
were added in OpenSSL 0.9.7.
@


1.1.1.2
log
@import openssl-0.9.7-beta3
@
text
@d241 1
a241 1
L<sha(3)|sha(3)>, L<dgst(1)|dgst(1)>
d248 2
a249 7
EVP_MD_CTX_init(), EVP_MD_CTX_create(), EVP_MD_CTX_copy_ex(),
EVP_MD_CTX_cleanup(), EVP_MD_CTX_destroy(), EVP_DigestInit_ex()
and EVP_DigestFinal_ex() were added in OpenSSL 0.9.7.

EVP_md_null(), EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(),
EVP_dss(), EVP_dss1(), EVP_mdc2() and EVP_ripemd160() were
changed to return truely const EVP_MD * in OpenSSL 0.9.7.
@


1.1.1.3
log
@import openssl-0.9.7d
@
text
@d7 1
a7 1
EVP_MD_CTX_copy_ex, EVP_MD_CTX_copy, EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size,
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@d21 1
a21 1
 int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d67 1
a67 1
EVP_MD_CTX_init() initializes digest context B<ctx>.
d69 1
a69 1
EVP_MD_CTX_create() allocates, initializes and returns a digest context.
d105 1
a105 1
context B<ctx> is automatically cleaned up.
d135 1
a135 3
algorithms but using DSS (DSA) for the signature algorithm. Note: there is 
no need to use these pseudo-digests in OpenSSL 1.0.0 and later, they are
however retained for compatibility.
d231 6
a254 7

The link between digests and signing algorithms was fixed in OpenSSL 1.0 and
later, so now EVP_sha1() can be used with RSA and DSA, there is no need to
use EVP_dss1() any more.

OpenSSL 1.0 and later does not include the MD2 digest algorithm in the
default configuration due to its security weaknesses.
@


1.1.1.6
log
@import OpenSSL-1.0.1c
@
text
@d9 1
a9 2
EVP_md_null, EVP_md2, EVP_md5, EVP_sha, EVP_sha1, EVP_sha224, EVP_sha256,
EVP_sha384, EVP_sha512, EVP_dss, EVP_dss1, EVP_mdc2,
d36 1
a36 1
 #define EVP_MAX_MD_SIZE 64	/* SHA512 */
a37 4
 int EVP_MD_type(const EVP_MD *md);
 int EVP_MD_pkey_type(const EVP_MD *md);	
 int EVP_MD_size(const EVP_MD *md);
 int EVP_MD_block_size(const EVP_MD *md);
d39 7
a45 2
 const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);
 #define EVP_MD_CTX_size(e)		EVP_MD_size(EVP_MD_CTX_md(e))
a58 5
 const EVP_MD *EVP_sha224(void);
 const EVP_MD *EVP_sha256(void);
 const EVP_MD *EVP_sha384(void);
 const EVP_MD *EVP_sha512(void);

d127 6
a132 8
return B<NID_sha1WithRSAEncryption>. Since digests and signature algorithms
are no longer linked this function is only retained for compatibility
reasons.

EVP_md2(), EVP_md5(), EVP_sha(), EVP_sha1(), EVP_sha224(), EVP_sha256(),
EVP_sha384(), EVP_sha512(), EVP_mdc2() and EVP_ripemd160() return B<EVP_MD>
structures for the MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512, MDC2
and RIPEMD160 digest algorithms respectively. 
d174 2
a175 2
New applications should use the SHA2 digest algorithms such as SHA256. 
The other digest algorithms are still in common use.
a189 13
Stack allocation of EVP_MD_CTX structures is common, for example:

 EVP_MD_CTX mctx;
 EVP_MD_CTX_init(&mctx);

This will cause binary compatibility issues if the size of EVP_MD_CTX
structure changes (this will only happen with a major release of OpenSSL).
Applications wishing to avoid this should use EVP_MD_CTX_create() instead:

 EVP_MD_CTX *mctx;
 mctx = EVP_MD_CTX_create();


d200 1
a200 1
 EVP_MD_CTX *mdctx;
d221 6
a226 6
 mdctx = EVP_MD_CTX_create();
 EVP_DigestInit_ex(mdctx, md, NULL);
 EVP_DigestUpdate(mdctx, mess1, strlen(mess1));
 EVP_DigestUpdate(mdctx, mess2, strlen(mess2));
 EVP_DigestFinal_ex(mdctx, md_value, &md_len);
 EVP_MD_CTX_destroy(mdctx);
@


