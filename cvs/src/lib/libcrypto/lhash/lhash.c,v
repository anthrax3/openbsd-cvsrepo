head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.6
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18;
locks; strict;
comment	@ * @;


1.18
date	2016.11.08.20.20.06;	author miod;	state Exp;
branches;
next	1.17;
commitid	ERl6cF6bT9qLk3eD;

1.17
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.16;
commitid	nzndm3zqPmFurSaK;

1.16
date	2014.07.09.11.10.51;	author bcook;	state Exp;
branches;
next	1.15;
commitid	lHJTcoC4c5BhEOGj;

1.15
date	2014.06.12.15.49.29;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	mJUVYpkFBZ0Zv2bG;

1.14
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	2nvnQBrv22dLtvTt;

1.13
date	2014.05.29.21.42.44;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2014.05.29.21.19.30;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2014.05.29.21.07.42;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.20.13.42.57;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.15.02.29.14;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.15.02.57.49;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.39;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.10.32;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.20;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.48;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.48;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.31;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.44;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.08;	author djm;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Use more homogeneous types and avoid a possible right shift by 32 in
lh_strhash().

ok guenther@@
@
text
@/* $OpenBSD: lhash.c,v 1.17 2014/07/10 22:45:57 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/* Code for dynamic hash table routines
 * Author - Eric Young v 2.0
 *
 * 2.2 eay - added #include "crypto.h" so the memory leak checking code is
 *	     present. eay 18-Jun-98
 *
 * 2.1 eay - Added an 'error in last operation' flag. eay 6-May-98
 *
 * 2.0 eay - Fixed a bug that occurred when using lh_delete
 *	     from inside lh_doall().  As entries were deleted,
 *	     the 'table' was 'contract()ed', making some entries
 *	     jump from the end of the table to the start, there by
 *	     skipping the lh_doall() processing. eay - 4/12/95
 *
 * 1.9 eay - Fixed a memory leak in lh_free, the LHASH_NODEs
 *	     were not being free()ed. 21/11/95
 *
 * 1.8 eay - Put the stats routines into a separate file, lh_stats.c
 *	     19/09/95
 *
 * 1.7 eay - Removed the fputs() for realloc failures - the code
 *           should silently tolerate them.  I have also fixed things
 *           lint complained about 04/05/95
 *
 * 1.6 eay - Fixed an invalid pointers in contract/expand 27/07/92
 *
 * 1.5 eay - Fixed a misuse of realloc in expand 02/03/1992
 *
 * 1.4 eay - Fixed lh_doall so the function can call lh_delete 28/05/91
 *
 * 1.3 eay - Fixed a few lint problems 19/3/1991
 *
 * 1.2 eay - Fixed lh_doall problem 13/3/1991
 *
 * 1.1 eay - Added lh_doall
 *
 * 1.0 eay - First version
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <openssl/opensslconf.h>

#include <openssl/crypto.h>
#include <openssl/lhash.h>

#undef MIN_NODES
#define MIN_NODES	16
#define UP_LOAD		(2*LH_LOAD_MULT) /* load times 256  (default 2) */
#define DOWN_LOAD	(LH_LOAD_MULT)   /* load times 256  (default 1) */

static void expand(_LHASH *lh);
static void contract(_LHASH *lh);
static LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash);

_LHASH *
lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)
{
	_LHASH *ret;
	int i;

	if ((ret = malloc(sizeof(_LHASH))) == NULL)
		goto err0;
	if ((ret->b = reallocarray(NULL, MIN_NODES, sizeof(LHASH_NODE *))) == NULL)
		goto err1;
	for (i = 0; i < MIN_NODES; i++)
		ret->b[i] = NULL;
	ret->comp = ((c == NULL) ? (LHASH_COMP_FN_TYPE)strcmp : c);
	ret->hash = ((h == NULL) ? (LHASH_HASH_FN_TYPE)lh_strhash : h);
	ret->num_nodes = MIN_NODES / 2;
	ret->num_alloc_nodes = MIN_NODES;
	ret->p = 0;
	ret->pmax = MIN_NODES / 2;
	ret->up_load = UP_LOAD;
	ret->down_load = DOWN_LOAD;
	ret->num_items = 0;

	ret->num_expands = 0;
	ret->num_expand_reallocs = 0;
	ret->num_contracts = 0;
	ret->num_contract_reallocs = 0;
	ret->num_hash_calls = 0;
	ret->num_comp_calls = 0;
	ret->num_insert = 0;
	ret->num_replace = 0;
	ret->num_delete = 0;
	ret->num_no_delete = 0;
	ret->num_retrieve = 0;
	ret->num_retrieve_miss = 0;
	ret->num_hash_comps = 0;

	ret->error = 0;
	return (ret);

err1:
	free(ret);
err0:
	return (NULL);
}

void
lh_free(_LHASH *lh)
{
	unsigned int i;
	LHASH_NODE *n, *nn;

	if (lh == NULL)
		return;

	for (i = 0; i < lh->num_nodes; i++) {
		n = lh->b[i];
		while (n != NULL) {
			nn = n->next;
			free(n);
			n = nn;
		}
	}
	free(lh->b);
	free(lh);
}

void *
lh_insert(_LHASH *lh, void *data)
{
	unsigned long hash;
	LHASH_NODE *nn, **rn;
	void *ret;

	lh->error = 0;
	if (lh->up_load <= (lh->num_items * LH_LOAD_MULT / lh->num_nodes))
		expand(lh);

	rn = getrn(lh, data, &hash);

	if (*rn == NULL) {
		if ((nn = malloc(sizeof(LHASH_NODE))) == NULL) {
			lh->error++;
			return (NULL);
		}
		nn->data = data;
		nn->next = NULL;
#ifndef OPENSSL_NO_HASH_COMP
		nn->hash = hash;
#endif
		*rn = nn;
		ret = NULL;
		lh->num_insert++;
		lh->num_items++;
	}
	else /* replace same key */
	{
		ret = (*rn)->data;
		(*rn)->data = data;
		lh->num_replace++;
	}
	return (ret);
}

void *
lh_delete(_LHASH *lh, const void *data)
{
	unsigned long hash;
	LHASH_NODE *nn, **rn;
	void *ret;

	lh->error = 0;
	rn = getrn(lh, data, &hash);

	if (*rn == NULL) {
		lh->num_no_delete++;
		return (NULL);
	} else {
		nn= *rn;
		*rn = nn->next;
		ret = nn->data;
		free(nn);
		lh->num_delete++;
	}

	lh->num_items--;
	if ((lh->num_nodes > MIN_NODES) &&
	    (lh->down_load >= (lh->num_items * LH_LOAD_MULT / lh->num_nodes)))
		contract(lh);

	return (ret);
}

void *
lh_retrieve(_LHASH *lh, const void *data)
{
	unsigned long hash;
	LHASH_NODE **rn;
	void *ret;

	lh->error = 0;
	rn = getrn(lh, data, &hash);

	if (*rn == NULL) {
		lh->num_retrieve_miss++;
		return (NULL);
	} else {
		ret = (*rn)->data;
		lh->num_retrieve++;
	}
	return (ret);
}

static void
doall_util_fn(_LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,
    LHASH_DOALL_ARG_FN_TYPE func_arg, void *arg)
{
	int i;
	LHASH_NODE *a, *n;

	if (lh == NULL)
		return;

	/* reverse the order so we search from 'top to bottom'
	 * We were having memory leaks otherwise */
	for (i = lh->num_nodes - 1; i >= 0; i--) {
		a = lh->b[i];
		while (a != NULL) {
			/* 28/05/91 - eay - n added so items can be deleted
			 * via lh_doall */
			/* 22/05/08 - ben - eh? since a is not passed,
			 * this should not be needed */
			n = a->next;
			if (use_arg)
				func_arg(a->data, arg);
			else
				func(a->data);
			a = n;
		}
	}
}

void
lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func)
{
	doall_util_fn(lh, 0, func, (LHASH_DOALL_ARG_FN_TYPE)0, NULL);
}

void
lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)
{
	doall_util_fn(lh, 1, (LHASH_DOALL_FN_TYPE)0, func, arg);
}

static void
expand(_LHASH *lh)
{
	LHASH_NODE **n, **n1, **n2, *np;
	unsigned int p, i, j;
	unsigned long hash, nni;

	lh->num_nodes++;
	lh->num_expands++;
	p = (int)lh->p++;
	n1 = &(lh->b[p]);
	n2 = &(lh->b[p + (int)lh->pmax]);
	*n2 = NULL;        /* 27/07/92 - eay - undefined pointer bug */
	nni = lh->num_alloc_nodes;

	for (np = *n1; np != NULL; ) {
#ifndef OPENSSL_NO_HASH_COMP
		hash = np->hash;
#else
		hash = lh->hash(np->data);
		lh->num_hash_calls++;
#endif
		if ((hash % nni) != p) { /* move it */
			*n1 = (*n1)->next;
			np->next= *n2;
			*n2 = np;
		} else
			n1 = &((*n1)->next);
		np= *n1;
	}

	if ((lh->p) >= lh->pmax) {
		j = (int)lh->num_alloc_nodes * 2;
		n = reallocarray(lh->b, j, sizeof(LHASH_NODE *));
		if (n == NULL) {
/*			fputs("realloc error in lhash", stderr); */
			lh->error++;
			lh->p = 0;
			return;
		}
		/* else */
		for (i = (int)lh->num_alloc_nodes; i < j; i++)/* 26/02/92 eay */
			n[i] = NULL;			  /* 02/03/92 eay */
		lh->pmax = lh->num_alloc_nodes;
		lh->num_alloc_nodes = j;
		lh->num_expand_reallocs++;
		lh->p = 0;
		lh->b = n;
	}
}

static void
contract(_LHASH *lh)
{
	LHASH_NODE **n, *n1, *np;

	np = lh->b[lh->p + lh->pmax - 1];
	lh->b[lh->p+lh->pmax - 1] = NULL; /* 24/07-92 - eay - weird but :-( */
	if (lh->p == 0) {
		n = reallocarray(lh->b, lh->pmax, sizeof(LHASH_NODE *));
		if (n == NULL) {
/*			fputs("realloc error in lhash", stderr); */
			lh->error++;
			return;
		}
		lh->num_contract_reallocs++;
		lh->num_alloc_nodes /= 2;
		lh->pmax /= 2;
		lh->p = lh->pmax - 1;
		lh->b = n;
	} else
		lh->p--;

	lh->num_nodes--;
	lh->num_contracts++;

	n1 = lh->b[(int)lh->p];
	if (n1 == NULL)
		lh->b[(int)lh->p] = np;
	else {
		while (n1->next != NULL)
			n1 = n1->next;
		n1->next = np;
	}
}

static LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash)
{
	LHASH_NODE **ret, *n1;
	unsigned long hash, nn;
	LHASH_COMP_FN_TYPE cf;

	hash = (*(lh->hash))(data);
	lh->num_hash_calls++;
	*rhash = hash;

	nn = hash % lh->pmax;
	if (nn < lh->p)
		nn = hash % lh->num_alloc_nodes;

	cf = lh->comp;
	ret = &(lh->b[(int)nn]);
	for (n1 = *ret; n1 != NULL; n1 = n1->next) {
#ifndef OPENSSL_NO_HASH_COMP
		lh->num_hash_comps++;
		if (n1->hash != hash) {
			ret = &(n1->next);
			continue;
		}
#endif
		lh->num_comp_calls++;
		if (cf(n1->data, data) == 0)
			break;
		ret = &(n1->next);
	}
	return (ret);
}

/* The following hash seems to work very well on normal text strings
 * no collisions on /usr/dict/words and it distributes on %2^n quite
 * well, not as good as MD5, but still good.
 */
unsigned long
lh_strhash(const char *c)
{
	unsigned long ret = 0;
	unsigned long n, v;
	unsigned int r;

	if (c == NULL || *c == '\0')
		return ret;

	n = 0x100;
	while (*c) {
		v = n | *c;
		n += 0x100;
		if ((r = ((v >> 2) ^ v) & 0x0f) != 0)
			ret = (ret << r) | (ret >> (32 - r));
		ret &= 0xFFFFFFFFUL;
		ret ^= v * v;
		c++;
	}
	return (ret >> 16) ^ ret;
}

unsigned long
lh_num_items(const _LHASH *lh)
{
	return lh ? lh->num_items : 0;
}
@


1.17
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: lhash.c,v 1.16 2014/07/09 11:10:51 bcook Exp $ */
d434 5
a438 11
	long n;
	unsigned long v;
	int r;

	if ((c == NULL) || (*c == '\0'))
		return (ret);
/*
	unsigned char b[16];
	MD5(c,strlen(c),b);
	return(b[0]|(b[1]<<8)|(b[2]<<16)|(b[3]<<24));
*/
d442 1
a442 1
		v = n | (*c);
d444 3
a446 3
		r = (int)((v >> 2) ^ v) & 0x0f;
		ret = (ret << r)|(ret >> (32 - r));
		ret &= 0xFFFFFFFFL;
d450 1
a450 1
	return ((ret >> 16) ^ ret);
@


1.16
log
@remove unused, private version strings except SSL_version_str

Also remove unused des_ver.h, which exports some of these strings, but is not installed.

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: lhash.c,v 1.15 2014/06/12 15:49:29 deraadt Exp $ */
d100 3
@


1.15
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a101 2

const char lh_version[] = "lhash" OPENSSL_VERSION_PTEXT;
@


1.14
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/lhash/lhash.c */
@


1.13
log
@I do not have time to describe how bad the realloc() uses in here, now
being relaced by reallocarray().  you will have to look at the diff.
there can be no explanations for the extra casts.  as beck says,
"Don't go towards the light theo!"
ok beck tedu
@
text
@d194 1
a194 1
		if ((nn = (LHASH_NODE *)malloc(sizeof(LHASH_NODE))) == NULL) {
@


1.12
log
@ok, next pass after review:  when possible, put the reallocarray arguments
in the "size_t nmemb, size_t size"
@
text
@d340 1
a340 2
		n = (LHASH_NODE **)realloc(lh->b,
		    (int)(sizeof(LHASH_NODE *) * j));
d366 1
a366 2
		n = (LHASH_NODE **)realloc(lh->b,
		    (unsigned int)(sizeof(LHASH_NODE *) * lh->pmax));
@


1.11
log
@convert 53 malloc(a*b) to reallocarray(NULL, a, b).  that is 53
potential integer overflows easily changed into an allocation return
of NULL, with errno nicely set if need be.  checks for an allocations
returning NULL are commonplace, or if the object is dereferenced
(quite normal) will result in a nice fault which can be detected &
repaired properly.
ok tedu
@
text
@d122 1
a122 1
	if ((ret->b = reallocarray(NULL, sizeof(LHASH_NODE *), MIN_NODES)) == NULL)
@


1.10
log
@KNF.
@
text
@d122 1
a122 1
	if ((ret->b = malloc(sizeof(LHASH_NODE *) * MIN_NODES)) == NULL)
@


1.9
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d103 1
a103 1
const char lh_version[]="lhash" OPENSSL_VERSION_PTEXT;
d105 1
a105 1
#undef MIN_NODES 
d114 3
a116 2
_LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)
	{
d120 1
a120 1
	if ((ret=malloc(sizeof(_LHASH))) == NULL)
d122 1
a122 1
	if ((ret->b=malloc(sizeof(LHASH_NODE *)*MIN_NODES)) == NULL)
d124 28
a151 25
	for (i=0; i<MIN_NODES; i++)
		ret->b[i]=NULL;
	ret->comp=((c == NULL)?(LHASH_COMP_FN_TYPE)strcmp:c);
	ret->hash=((h == NULL)?(LHASH_HASH_FN_TYPE)lh_strhash:h);
	ret->num_nodes=MIN_NODES/2;
	ret->num_alloc_nodes=MIN_NODES;
	ret->p=0;
	ret->pmax=MIN_NODES/2;
	ret->up_load=UP_LOAD;
	ret->down_load=DOWN_LOAD;
	ret->num_items=0;

	ret->num_expands=0;
	ret->num_expand_reallocs=0;
	ret->num_contracts=0;
	ret->num_contract_reallocs=0;
	ret->num_hash_calls=0;
	ret->num_comp_calls=0;
	ret->num_insert=0;
	ret->num_replace=0;
	ret->num_delete=0;
	ret->num_no_delete=0;
	ret->num_retrieve=0;
	ret->num_retrieve_miss=0;
	ret->num_hash_comps=0;
a152 2
	ret->error=0;
	return(ret);
d156 2
a157 2
	return(NULL);
	}
d159 3
a161 2
void lh_free(_LHASH *lh)
	{
d163 1
a163 1
	LHASH_NODE *n,*nn;
d166 1
a166 1
	    return;
d168 4
a171 6
	for (i=0; i<lh->num_nodes; i++)
		{
		n=lh->b[i];
		while (n != NULL)
			{
			nn=n->next;
d173 1
a173 2
			n=nn;
			}
d175 1
d178 1
a178 1
	}
d180 3
a182 2
void *lh_insert(_LHASH *lh, void *data)
	{
d184 1
a184 1
	LHASH_NODE *nn,**rn;
d187 2
a188 2
	lh->error=0;
	if (lh->up_load <= (lh->num_items*LH_LOAD_MULT/lh->num_nodes))
d191 1
a191 1
	rn=getrn(lh,data,&hash);
d193 2
a194 4
	if (*rn == NULL)
		{
		if ((nn=(LHASH_NODE *)malloc(sizeof(LHASH_NODE))) == NULL)
			{
d196 4
a199 4
			return(NULL);
			}
		nn->data=data;
		nn->next=NULL;
d201 1
a201 1
		nn->hash=hash;
d203 2
a204 2
		*rn=nn;
		ret=NULL;
d207 1
a207 1
		}
d209 3
a211 3
		{
		ret= (*rn)->data;
		(*rn)->data=data;
a212 2
		}
	return(ret);
d214 2
d217 3
a219 2
void *lh_delete(_LHASH *lh, const void *data)
	{
d221 1
a221 1
	LHASH_NODE *nn,**rn;
d224 2
a225 2
	lh->error=0;
	rn=getrn(lh,data,&hash);
d227 1
a227 2
	if (*rn == NULL)
		{
d229 2
a230 4
		return(NULL);
		}
	else
		{
d232 2
a233 2
		*rn=nn->next;
		ret=nn->data;
d236 1
a236 1
		}
d240 1
a240 1
		(lh->down_load >= (lh->num_items*LH_LOAD_MULT/lh->num_nodes)))
d243 2
a244 2
	return(ret);
	}
d246 3
a248 2
void *lh_retrieve(_LHASH *lh, const void *data)
	{
d253 2
a254 2
	lh->error=0;
	rn=getrn(lh,data,&hash);
d256 1
a256 2
	if (*rn == NULL)
		{
d258 3
a260 5
		return(NULL);
		}
	else
		{
		ret= (*rn)->data;
a261 2
		}
	return(ret);
d263 2
d266 4
a269 3
static void doall_util_fn(_LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,
			  LHASH_DOALL_ARG_FN_TYPE func_arg, void *arg)
	{
d271 1
a271 1
	LHASH_NODE *a,*n;
d278 3
a280 5
	for (i=lh->num_nodes-1; i>=0; i--)
		{
		a=lh->b[i];
		while (a != NULL)
			{
d285 3
a287 3
			n=a->next;
			if(use_arg)
				func_arg(a->data,arg);
d290 1
a290 2
			a=n;
			}
d293 1
d295 3
a297 2
void lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func)
	{
d299 1
a299 1
	}
d301 3
a303 2
void lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)
	{
d305 1
a305 1
	}
d307 6
a312 5
static void expand(_LHASH *lh)
	{
	LHASH_NODE **n,**n1,**n2,*np;
	unsigned int p,i,j;
	unsigned long hash,nni;
d316 7
a322 8
	p=(int)lh->p++;
	n1= &(lh->b[p]);
	n2= &(lh->b[p+(int)lh->pmax]);
	*n2=NULL;        /* 27/07/92 - eay - undefined pointer bug */
	nni=lh->num_alloc_nodes;
	
	for (np= *n1; np != NULL; )
		{
d324 1
a324 1
		hash=np->hash;
d326 1
a326 1
		hash=lh->hash(np->data);
d329 2
a330 3
		if ((hash%nni) != p)
			{ /* move it */
			*n1= (*n1)->next;
d332 3
a334 4
			*n2=np;
			}
		else
			n1= &((*n1)->next);
d336 1
a336 1
		}
d338 6
a343 8
	if ((lh->p) >= lh->pmax)
		{
		j=(int)lh->num_alloc_nodes*2;
		n=(LHASH_NODE **)realloc(lh->b,
			(int)(sizeof(LHASH_NODE *)*j));
		if (n == NULL)
			{
/*			fputs("realloc error in lhash",stderr); */
d345 1
a345 1
			lh->p=0;
d347 1
a347 1
			}
d349 4
a352 4
		for (i=(int)lh->num_alloc_nodes; i<j; i++)/* 26/02/92 eay */
			n[i]=NULL;			  /* 02/03/92 eay */
		lh->pmax=lh->num_alloc_nodes;
		lh->num_alloc_nodes=j;
d354 2
a355 3
		lh->p=0;
		lh->b=n;
		}
d357 1
d359 12
a370 13
static void contract(_LHASH *lh)
	{
	LHASH_NODE **n,*n1,*np;

	np=lh->b[lh->p+lh->pmax-1];
	lh->b[lh->p+lh->pmax-1]=NULL; /* 24/07-92 - eay - weird but :-( */
	if (lh->p == 0)
		{
		n=(LHASH_NODE **)realloc(lh->b,
			(unsigned int)(sizeof(LHASH_NODE *)*lh->pmax));
		if (n == NULL)
			{
/*			fputs("realloc error in lhash",stderr); */
d373 1
a373 1
			}
d375 5
a379 6
		lh->num_alloc_nodes/=2;
		lh->pmax/=2;
		lh->p=lh->pmax-1;
		lh->b=n;
		}
	else
d385 1
a385 1
	n1=lh->b[(int)lh->p];
d387 2
a388 3
		lh->b[(int)lh->p]=np;
	else
		{
d390 2
a391 3
			n1=n1->next;
		n1->next=np;
		}
d393 1
d396 3
a398 3
	{
	LHASH_NODE **ret,*n1;
	unsigned long hash,nn;
d401 1
a401 1
	hash=(*(lh->hash))(data);
d403 1
a403 1
	*rhash=hash;
d405 1
a405 1
	nn=hash%lh->pmax;
d407 1
a407 1
		nn=hash%lh->num_alloc_nodes;
d409 3
a411 4
	cf=lh->comp;
	ret= &(lh->b[(int)nn]);
	for (n1= *ret; n1 != NULL; n1=n1->next)
		{
d414 2
a415 3
		if (n1->hash != hash)
			{
			ret= &(n1->next);
d417 1
a417 1
			}
d420 1
a420 1
		if(cf(n1->data,data) == 0)
d422 1
a422 3
		ret= &(n1->next);
		}
	return(ret);
d424 2
d431 4
a434 3
unsigned long lh_strhash(const char *c)
	{
	unsigned long ret=0;
d440 1
a440 1
		return(ret);
d444 1
a444 1
	return(b[0]|(b[1]<<8)|(b[2]<<16)|(b[3]<<24)); 
d447 8
a454 9
	n=0x100;
	while (*c)
		{
		v=n|(*c);
		n+=0x100;
		r= (int)((v>>2)^v)&0x0f;
		ret=(ret<<r)|(ret>>(32-r));
		ret&=0xFFFFFFFFL;
		ret^=v*v;
a455 2
		}
	return((ret>>16)^ret);
d457 2
d460 3
a462 2
unsigned long lh_num_items(const _LHASH *lh)
	{
d464 1
a464 1
	}
@


1.8
log
@resolve conflicts, fix local changes
@
text
@d119 1
a119 1
	if ((ret=OPENSSL_malloc(sizeof(_LHASH))) == NULL)
d121 1
a121 1
	if ((ret->b=OPENSSL_malloc(sizeof(LHASH_NODE *)*MIN_NODES)) == NULL)
d152 1
a152 1
	OPENSSL_free(ret);
d171 1
a171 1
			OPENSSL_free(n);
d175 2
a176 2
	OPENSSL_free(lh->b);
	OPENSSL_free(lh);
d193 1
a193 1
		if ((nn=(LHASH_NODE *)OPENSSL_malloc(sizeof(LHASH_NODE))) == NULL)
d236 1
a236 1
		OPENSSL_free(nn);
d346 1
a346 1
		n=(LHASH_NODE **)OPENSSL_realloc(lh->b,
d374 1
a374 1
		n=(LHASH_NODE **)OPENSSL_realloc(lh->b,
@


1.7
log
@resolve conflicts
@
text
@d110 3
a112 3
static void expand(LHASH *lh);
static void contract(LHASH *lh);
static LHASH_NODE **getrn(LHASH *lh, const void *data, unsigned long *rhash);
d114 1
a114 1
LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)
d116 1
a116 1
	LHASH *ret;
d119 1
a119 1
	if ((ret=(LHASH *)OPENSSL_malloc(sizeof(LHASH))) == NULL)
d121 1
a121 1
	if ((ret->b=(LHASH_NODE **)OPENSSL_malloc(sizeof(LHASH_NODE *)*MIN_NODES)) == NULL)
d157 1
a157 1
void lh_free(LHASH *lh)
d179 1
a179 1
void *lh_insert(LHASH *lh, void *data)
d217 1
a217 1
void *lh_delete(LHASH *lh, const void *data)
d248 1
a248 1
void *lh_retrieve(LHASH *lh, const void *data)
d270 1
a270 1
static void doall_util_fn(LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,
d276 3
d288 2
d300 1
a300 1
void lh_doall(LHASH *lh, LHASH_DOALL_FN_TYPE func)
d305 1
a305 1
void lh_doall_arg(LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)
d310 1
a310 1
static void expand(LHASH *lh)
d366 1
a366 1
static void contract(LHASH *lh)
d405 1
a405 1
static LHASH_NODE **getrn(LHASH *lh, const void *data, unsigned long *rhash)
d472 1
a472 1
unsigned long lh_num_items(const LHASH *lh)
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d103 1
a103 1
const char *lh_version="lhash" OPENSSL_VERSION_PTEXT;
d179 1
a179 1
void *lh_insert(LHASH *lh, const void *data)
d183 1
a183 1
	const void *ret;
d214 1
a214 1
	return((void *)ret);
d221 1
a221 1
	const void *ret;
d245 1
a245 1
	return((void *)ret);
d252 1
a252 1
	const void *ret;
d267 1
a267 1
	return((void *)ret);
d342 1
a342 1
			(unsigned int)sizeof(LHASH_NODE *)*j);
d404 1
a404 1
	int (*cf)();
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d112 1
a112 1
static LHASH_NODE **getrn(LHASH *lh, void *data, unsigned long *rhash);
d114 1
a114 1
LHASH *lh_new(unsigned long (*h)(), int (*c)())
d125 2
a126 2
	ret->comp=((c == NULL)?(int (*)())strcmp:c);
	ret->hash=((h == NULL)?(unsigned long (*)())lh_strhash:h);
d179 1
a179 1
void *lh_insert(LHASH *lh, void *data)
d183 1
a183 1
	void *ret;
d200 1
a200 1
#ifndef NO_HASH_COMP
d214 1
a214 1
	return(ret);
d217 1
a217 1
void *lh_delete(LHASH *lh, void *data)
d221 1
a221 1
	void *ret;
d245 1
a245 1
	return(ret);
d248 1
a248 1
void *lh_retrieve(LHASH *lh, void *data)
d252 1
a252 1
	void *ret;
d267 1
a267 6
	return(ret);
	}

void lh_doall(LHASH *lh, void (*func)())
	{
	lh_doall_arg(lh,func,NULL);
d270 2
a271 1
void lh_doall_arg(LHASH *lh, void (*func)(), void *arg)
d286 4
a289 1
			func(a->data,arg);
d295 10
d321 1
a321 1
#ifndef NO_HASH_COMP
d324 1
a324 1
		hash=(*(lh->hash))(np->data);
d400 1
a400 1
static LHASH_NODE **getrn(LHASH *lh, void *data, unsigned long *rhash)
d418 1
a418 1
#ifndef NO_HASH_COMP
d427 1
a427 1
		if ((*cf)(n1->data,data) == 0)
d467 1
a467 1
unsigned long lh_num_items(LHASH *lh)
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d119 1
a119 1
	if ((ret=(LHASH *)Malloc(sizeof(LHASH))) == NULL)
d121 1
a121 1
	if ((ret->b=(LHASH_NODE **)Malloc(sizeof(LHASH_NODE *)*MIN_NODES)) == NULL)
d152 1
a152 1
	Free(ret);
d171 1
a171 1
			Free(n);
d175 2
a176 2
	Free(lh->b);
	Free(lh);
d193 1
a193 1
		if ((nn=(LHASH_NODE *)Malloc(sizeof(LHASH_NODE))) == NULL)
d236 1
a236 1
		Free(nn);
d332 1
a332 1
		n=(LHASH_NODE **)Realloc(lh->b,
d360 1
a360 1
		n=(LHASH_NODE **)Realloc(lh->b,
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d162 1
a162 1
	if(lh == NULL)
a424 15
/*
unsigned long lh_strhash(char *str)
	{
	int i,l;
	unsigned long ret=0;
	unsigned short *s;

	if (str == NULL) return(0);
	l=(strlen(str)+1)/2;
	s=(unsigned short *)str;
	for (i=0; i<l; i++)
		ret^=(s[i]<<(i&0x0f));
	return(ret);
	} */

d458 4
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d67 1
a67 1
 * 2.0 eay - Fixed a bug that occured when using lh_delete
d71 1
a71 1
 *	     skiping the lh_doall() processing. eay - 4/12/95
a109 3

#define P_CP	char *
#define P_CPP	char *,char *
d112 1
a112 1
static LHASH_NODE **getrn(LHASH *lh, char *data, unsigned long *rhash);
d152 1
a152 1
	Free((char *)ret);
d175 2
a176 2
	Free((char *)lh->b);
	Free((char *)lh);
d179 1
a179 1
char *lh_insert(LHASH *lh, char *data)
d183 1
a183 1
	char *ret;
d217 1
a217 1
char *lh_delete(LHASH *lh, char *data)
d221 1
a221 1
	char *ret;
d236 1
a236 1
		Free((char *)nn);
d248 1
a248 1
char *lh_retrieve(LHASH *lh, char *data)
d252 1
a252 1
	char *ret;
d275 1
a275 1
void lh_doall_arg(LHASH *lh, void (*func)(), char *arg)
d332 1
a332 1
		n=(LHASH_NODE **)Realloc((char *)lh->b,
d360 1
a360 1
		n=(LHASH_NODE **)Realloc((char *)lh->b,
d391 1
a391 1
static LHASH_NODE **getrn(LHASH *lh, char *data, unsigned long *rhash)
d426 1
a426 2
static unsigned long lh_strhash(str)
char *str;
@


1.1
log
@Initial revision
@
text
@a58 2
char *lh_version="lhash part of SSLeay 0.9.0b 29-Jun-1998";

d62 5
d100 4
a103 1
#include "lhash.h"
a109 1
#ifndef NOPROTO
d117 1
a117 13
#else

#define	P_CP
#define P_CPP
static void expand();
static void contract();
static LHASH_NODE **getrn();

#endif

LHASH *lh_new(h, c)
unsigned long (*h)();
int (*c)();
d122 1
a122 1
	if ((ret=(LHASH *)malloc(sizeof(LHASH))) == NULL)
d124 1
a124 1
	if ((ret->b=(LHASH_NODE **)malloc(sizeof(LHASH_NODE *)*MIN_NODES)) == NULL)
d152 1
d155 1
a155 1
	free((char *)ret);
d160 1
a160 2
void lh_free(lh)
LHASH *lh;
d165 3
d174 1
a174 1
			free(n);
d178 2
a179 2
	free((char *)lh->b);
	free((char *)lh);
d182 1
a182 3
char *lh_insert(lh, data)
LHASH *lh;
char *data;
d188 1
d196 3
a198 1
		if ((nn=(LHASH_NODE *)malloc(sizeof(LHASH_NODE))) == NULL)
d200 1
d220 1
a220 3
char *lh_delete(lh, data)
LHASH *lh;
char *data;
d226 1
d239 1
a239 1
		free((char *)nn);
d251 1
a251 3
char *lh_retrieve(lh, data)
LHASH *lh;
char *data;
d257 1
d273 1
a273 3
void lh_doall(lh, func)
LHASH *lh;
void (*func)();
d278 1
a278 4
void lh_doall_arg(lh, func, arg)
LHASH *lh;
void (*func)();
char *arg;
d299 1
a299 2
static void expand(lh)
LHASH *lh;
d335 1
a335 1
		n=(LHASH_NODE **)realloc((char *)lh->b,
d340 1
d355 1
a355 2
static void contract(lh)
LHASH *lh;
d363 1
a363 1
		n=(LHASH_NODE **)realloc((char *)lh->b,
d368 1
d394 1
a394 4
static LHASH_NODE **getrn(lh, data, rhash)
LHASH *lh;
char *data;
unsigned long *rhash;
d448 1
a448 2
unsigned long lh_strhash(c)
char *c;
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d59 2
d64 1
a64 6
 * 2.2 eay - added #include "crypto.h" so the memory leak checking code is
 *	     present. eay 18-Jun-98
 *
 * 2.1 eay - Added an 'error in last operation' flag. eay 6-May-98
 *
 * 2.0 eay - Fixed a bug that occurred when using lh_delete
d68 1
a68 1
 *	     skipping the lh_doall() processing. eay - 4/12/95
d97 1
a97 4
#include <openssl/crypto.h>
#include <openssl/lhash.h>

const char *lh_version="lhash" OPENSSL_VERSION_PTEXT;
d104 4
d110 1
a110 1
static LHASH_NODE **getrn(LHASH *lh, const void *data, unsigned long *rhash);
d112 13
a124 1
LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)
d129 1
a129 1
	if ((ret=(LHASH *)OPENSSL_malloc(sizeof(LHASH))) == NULL)
d131 1
a131 1
	if ((ret->b=(LHASH_NODE **)OPENSSL_malloc(sizeof(LHASH_NODE *)*MIN_NODES)) == NULL)
d135 2
a136 2
	ret->comp=((c == NULL)?(LHASH_COMP_FN_TYPE)strcmp:c);
	ret->hash=((h == NULL)?(LHASH_HASH_FN_TYPE)lh_strhash:h);
a158 1
	ret->error=0;
d161 1
a161 1
	OPENSSL_free(ret);
d166 2
a167 1
void lh_free(LHASH *lh)
a171 3
	if (lh == NULL)
	    return;

d178 1
a178 1
			OPENSSL_free(n);
d182 2
a183 2
	OPENSSL_free(lh->b);
	OPENSSL_free(lh);
d186 3
a188 1
void *lh_insert(LHASH *lh, const void *data)
d192 1
a192 1
	const void *ret;
a193 1
	lh->error=0;
d201 1
a201 3
		if ((nn=(LHASH_NODE *)OPENSSL_malloc(sizeof(LHASH_NODE))) == NULL)
			{
			lh->error++;
a202 1
			}
d205 1
a205 1
#ifndef OPENSSL_NO_HASH_COMP
d219 1
a219 1
	return((void *)ret);
d222 3
a224 1
void *lh_delete(LHASH *lh, const void *data)
d228 1
a228 1
	const void *ret;
a229 1
	lh->error=0;
d242 1
a242 1
		OPENSSL_free(nn);
d251 1
a251 1
	return((void *)ret);
d254 3
a256 1
void *lh_retrieve(LHASH *lh, const void *data)
d260 1
a260 1
	const void *ret;
a261 1
	lh->error=0;
d274 1
a274 1
	return((void *)ret);
d277 11
a287 2
static void doall_util_fn(LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,
			  LHASH_DOALL_ARG_FN_TYPE func_arg, void *arg)
d302 1
a302 4
			if(use_arg)
				func_arg(a->data,arg);
			else
				func(a->data);
d308 2
a309 11
void lh_doall(LHASH *lh, LHASH_DOALL_FN_TYPE func)
	{
	doall_util_fn(lh, 0, func, (LHASH_DOALL_ARG_FN_TYPE)0, NULL);
	}

void lh_doall_arg(LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)
	{
	doall_util_fn(lh, 1, (LHASH_DOALL_FN_TYPE)0, func, arg);
	}

static void expand(LHASH *lh)
d325 1
a325 1
#ifndef OPENSSL_NO_HASH_COMP
d328 1
a328 1
		hash=lh->hash(np->data);
d345 1
a345 1
		n=(LHASH_NODE **)OPENSSL_realloc(lh->b,
a349 1
			lh->error++;
d364 2
a365 1
static void contract(LHASH *lh)
d373 1
a373 1
		n=(LHASH_NODE **)OPENSSL_realloc(lh->b,
a377 1
			lh->error++;
d403 4
a406 1
static LHASH_NODE **getrn(LHASH *lh, const void *data, unsigned long *rhash)
d424 1
a424 1
#ifndef OPENSSL_NO_HASH_COMP
d433 1
a433 1
		if(cf(n1->data,data) == 0)
d440 16
d460 2
a461 1
unsigned long lh_strhash(const char *c)
a489 4
unsigned long lh_num_items(const LHASH *lh)
	{
	return lh ? lh->num_items : 0;
	}
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d103 1
a103 1
const char lh_version[]="lhash" OPENSSL_VERSION_PTEXT;
d179 1
a179 1
void *lh_insert(LHASH *lh, void *data)
d183 1
a183 1
	void *ret;
d214 1
a214 1
	return(ret);
d221 1
a221 1
	void *ret;
d245 1
a245 1
	return(ret);
d252 1
a252 1
	void *ret;
d267 1
a267 1
	return(ret);
d342 1
a342 1
			(int)(sizeof(LHASH_NODE *)*j));
d404 1
a404 1
	LHASH_COMP_FN_TYPE cf;
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@d110 3
a112 3
static void expand(_LHASH *lh);
static void contract(_LHASH *lh);
static LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash);
d114 1
a114 1
_LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)
d116 1
a116 1
	_LHASH *ret;
d119 1
a119 1
	if ((ret=OPENSSL_malloc(sizeof(_LHASH))) == NULL)
d121 1
a121 1
	if ((ret->b=OPENSSL_malloc(sizeof(LHASH_NODE *)*MIN_NODES)) == NULL)
d157 1
a157 1
void lh_free(_LHASH *lh)
d179 1
a179 1
void *lh_insert(_LHASH *lh, void *data)
d217 1
a217 1
void *lh_delete(_LHASH *lh, const void *data)
d248 1
a248 1
void *lh_retrieve(_LHASH *lh, const void *data)
d270 1
a270 1
static void doall_util_fn(_LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,
a275 3
	if (lh == NULL)
		return;

a284 2
			/* 22/05/08 - ben - eh? since a is not passed,
			 * this should not be needed */
d295 1
a295 1
void lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func)
d300 1
a300 1
void lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)
d305 1
a305 1
static void expand(_LHASH *lh)
d361 1
a361 1
static void contract(_LHASH *lh)
d400 1
a400 1
static LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash)
d467 1
a467 1
unsigned long lh_num_items(const _LHASH *lh)
@


