head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12;
locks; strict;
comment	@ * @;


1.12
date	2016.12.26.21.30.10;	author jca;	state Exp;
branches;
next	1.11;
commitid	4EK5zByufjOPkoKe;

1.11
date	2014.06.12.15.49.28;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	mJUVYpkFBZ0Zv2bG;

1.10
date	2014.04.18.21.57.17;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.15.17.46.16;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.06.12.17.50;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.05.22.12.11;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.03.21.53.39;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.12;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.36;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.09.56;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.28.19.58.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.43;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.43;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.12;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.42;	author djm;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Typo, "more then" -> "more than"
@
text
@/* $OpenBSD: fcrypt.c,v 1.11 2014/06/12 15:49:28 deraadt Exp $ */

#include <stdio.h>

/* This version of crypt has been developed from my MIT compatible
 * DES library.
 * Eric Young (eay@@cryptsoft.com)
 */

/* Modification by Jens Kupferschmidt (Cu)
 * I have included directive PARA for shared memory computers.
 * I have included a directive LONGCRYPT to using this routine to cipher
 * passwords with more than 8 bytes like HP-UX 10.x it used. The MAXPLEN
 * definition is the maximum of length of password and can changed. I have
 * defined 24.
 */

#include "des_locl.h"

/* Added more values to handle illegal salt values the way normal
 * crypt() implementations do.  The patch was sent by 
 * Bjorn Gronvall <bg@@sics.se>
 */
static unsigned const char con_salt[128]={
0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,
0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,0xE0,0xE1,
0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,
0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,
0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,
0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,0x00,0x01,
0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,
0x0A,0x0B,0x05,0x06,0x07,0x08,0x09,0x0A,
0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11,0x12,
0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,
0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,
0x23,0x24,0x25,0x20,0x21,0x22,0x23,0x24,
0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,
0x2D,0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,
0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,
0x3D,0x3E,0x3F,0x40,0x41,0x42,0x43,0x44,
};

static unsigned const char cov_2char[64]={
0x2E,0x2F,0x30,0x31,0x32,0x33,0x34,0x35,
0x36,0x37,0x38,0x39,0x41,0x42,0x43,0x44,
0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,
0x4D,0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,
0x55,0x56,0x57,0x58,0x59,0x5A,0x61,0x62,
0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,
0x6B,0x6C,0x6D,0x6E,0x6F,0x70,0x71,0x72,
0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A
};

char *DES_crypt(const char *buf, const char *salt)
	{
	static char buff[14];

	return(DES_fcrypt(buf,salt,buff));
	}


char *DES_fcrypt(const char *buf, const char *salt, char *ret)
	{
	unsigned int i,j,x,y;
	DES_LONG Eswap0,Eswap1;
	DES_LONG out[2],ll;
	DES_cblock key;
	DES_key_schedule ks;
	unsigned char bb[9];
	unsigned char *b=bb;
	unsigned char c,u;

	/* eay 25/08/92
	 * If you call crypt("pwd","*") as often happens when you
	 * have * as the pwd field in /etc/passwd, the function
	 * returns *\0xxxxxxxxx
	 * The \0 makes the string look like * so the pwd "*" would
	 * crypt to "*".  This was found when replacing the crypt in
	 * our shared libraries.  People found that the disabled
	 * accounts effectively had no passwd :-(. */
	x=ret[0]=((salt[0] == '\0')?'A':salt[0]);
	Eswap0=con_salt[x]<<2;
	x=ret[1]=((salt[1] == '\0')?'A':salt[1]);
	Eswap1=con_salt[x]<<6;
/* EAY
r=strlen(buf);
r=(r+7)/8;
*/
	for (i=0; i<8; i++)
		{
		c= *(buf++);
		if (!c) break;
		key[i]=(c<<1);
		}
	for (; i<8; i++)
		key[i]=0;

	DES_set_key_unchecked(&key,&ks);
	fcrypt_body(&(out[0]),&ks,Eswap0,Eswap1);

	ll=out[0]; l2c(ll,b);
	ll=out[1]; l2c(ll,b);
	y=0;
	u=0x80;
	bb[8]=0;
	for (i=2; i<13; i++)
		{
		c=0;
		for (j=0; j<6; j++)
			{
			c<<=1;
			if (bb[y] & u) c|=1;
			u>>=1;
			if (!u)
				{
				y++;
				u=0x80;
				}
			}
		ret[i]=cov_2char[c];
		}
	ret[13]='\0';
	return(ret);
	}

@


1.11
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d13 1
a13 1
 * passwords with more then 8 bytes like HP-UX 10.x it used. The MAXPLEN
@


1.10
log
@tone down some XXXXX to not appear in grep
@
text
@d1 2
a2 1
/* NOCW */
@


1.9
log
@Send the rotIBM stream cipher (ebcdic) to Valhalla to party for eternity
with the bearded ones...
some API's that nobody should be using will dissapear with this commit.
@
text
@d75 1
a75 1
	 * returns *\0XXXXXXXXX
@


1.8
log
@resolve conflicts
@
text
@a2 8
#ifdef _OSD_POSIX
#ifndef CHARSET_EBCDIC
#define CHARSET_EBCDIC 1
#endif
#endif
#ifdef CHARSET_EBCDIC
#include <openssl/ebcdic.h>
#endif
a56 1
#ifndef CHARSET_EBCDIC
a57 29
#else
	char e_salt[2+1];
	char e_buf[32+1];	/* replace 32 by 8 ? */
	char *ret;

	/* Copy at most 2 chars of salt */
	if ((e_salt[0] = salt[0]) != '\0')
	    e_salt[1] = salt[1];

	/* Copy at most 32 chars of password */
	strncpy (e_buf, buf, sizeof(e_buf));

	/* Make sure we have a delimiter */
	e_salt[sizeof(e_salt)-1] = e_buf[sizeof(e_buf)-1] = '\0';

	/* Convert the e_salt to ASCII, as that's what DES_fcrypt works on */
	ebcdic2ascii(e_salt, e_salt, sizeof e_salt);

	/* Convert the cleartext password to ASCII */
	ebcdic2ascii(e_buf, e_buf, sizeof e_buf);

	/* Encrypt it (from/to ASCII) */
	ret = DES_fcrypt(e_buf,e_salt,buff);

	/* Convert the result back to EBCDIC */
	ascii2ebcdic(ret, ret, strlen(ret));
	
	return ret;
#endif
a79 1
#ifndef CHARSET_EBCDIC
a83 7
#else
	x=ret[0]=((salt[0] == '\0')?os_toascii['A']:salt[0]);
	Eswap0=con_salt[x]<<2;
	x=ret[1]=((salt[1] == '\0')?os_toascii['A']:salt[1]);
	Eswap1=con_salt[x]<<6;
#endif

@


1.7
log
@merge with 0.9.7-beta1
@
text
@a60 3
void fcrypt_body(DES_LONG *out,DES_key_schedule *ks,
		 DES_LONG Eswap0, DES_LONG Eswap1);

@


1.6
log
@remove whitespace changes (keep diffs to 0.9.7-beta1 minimal)
@
text
@d3 8
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a93 1

d165 1
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d53 2
a54 3
#ifndef NOPROTO
void fcrypt_body(DES_LONG *out,des_key_schedule ks,
	DES_LONG Eswap0, DES_LONG Eswap1);
d56 6
a61 2
#if defined(PERL5) || defined(FreeBSD) || defined(__OpenBSD__)
char *des_crypt(const char *buf,const char *salt);
d63 22
a84 10
char *crypt(const char *buf,const char *salt);
#endif
#else
void fcrypt_body();
#ifdef PERL5
char *des_crypt();
#else
char *crypt();
#endif
#endif
d86 4
a89 4
#if defined(PERL5) || defined(FreeBSD) || defined(__OpenBSD__)
char *des_crypt(buf,salt)
#else
char *crypt(buf,salt)
d91 1
a91 4
const char *buf;
const char *salt;
	{
	static char buff[14];
a92 2
	return(des_fcrypt(buf,salt,buff));
	}
d95 1
a95 4
char *des_fcrypt(buf,salt,ret)
const char *buf;
const char *salt;
char *ret;
d100 2
a101 2
	des_cblock key;
	des_key_schedule ks;
d114 1
d119 6
d139 2
a140 2
	des_set_key_unchecked(&key,ks);
	fcrypt_body(&(out[0]),ks,Eswap0,Eswap1);
a165 1

@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@a5 1
 * The library is available at pub/Crypto/DES at ftp.psy.uq.oz.au
@


1.2
log
@do not put a bad crypt() in libcrypt, it is in libc
@
text
@d4 1
a4 1
/* This version of crypt has been developed from my MIT compatable
d14 1
a14 1
 * definition is the maximum of lenght of password and can changed. I have
d106 2
a107 2
	 * our shared libraries.  People found that the disbled
	 * accounts effectivly had no passwd :-(. */
d126 1
a126 1
	des_set_key((des_cblock *)(key),ks);
@


1.1
log
@Initial revision
@
text
@d58 1
a58 1
#if defined(PERL5) || defined(FreeBSD)
d72 1
a72 1
#if defined(PERL5) || defined(FreeBSD)
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a2 8
#ifdef _OSD_POSIX
#ifndef CHARSET_EBCDIC
#define CHARSET_EBCDIC 1
#endif
#endif
#ifdef CHARSET_EBCDIC
#include <openssl/ebcdic.h>
#endif
d4 1
a4 1
/* This version of crypt has been developed from my MIT compatible
d6 1
d14 1
a14 1
 * definition is the maximum of length of password and can changed. I have
d54 3
a56 2
void fcrypt_body(DES_LONG *out,DES_key_schedule *ks,
		 DES_LONG Eswap0, DES_LONG Eswap1);
d58 21
a78 1
char *DES_crypt(const char *buf, const char *salt)
d82 1
a82 31
#ifndef CHARSET_EBCDIC
	return(DES_fcrypt(buf,salt,buff));
#else
	char e_salt[2+1];
	char e_buf[32+1];	/* replace 32 by 8 ? */
	char *ret;

	/* Copy at most 2 chars of salt */
	if ((e_salt[0] = salt[0]) != '\0')
	    e_salt[1] = salt[1];

	/* Copy at most 32 chars of password */
	strncpy (e_buf, buf, sizeof(e_buf));

	/* Make sure we have a delimiter */
	e_salt[sizeof(e_salt)-1] = e_buf[sizeof(e_buf)-1] = '\0';

	/* Convert the e_salt to ASCII, as that's what DES_fcrypt works on */
	ebcdic2ascii(e_salt, e_salt, sizeof e_salt);

	/* Convert the cleartext password to ASCII */
	ebcdic2ascii(e_buf, e_buf, sizeof e_buf);

	/* Encrypt it (from/to ASCII) */
	ret = DES_fcrypt(e_buf,e_salt,buff);

	/* Convert the result back to EBCDIC */
	ascii2ebcdic(ret, ret, strlen(ret));
	
	return ret;
#endif
d86 4
a89 1
char *DES_fcrypt(const char *buf, const char *salt, char *ret)
d94 2
a95 2
	DES_cblock key;
	DES_key_schedule ks;
d106 2
a107 3
	 * our shared libraries.  People found that the disabled
	 * accounts effectively had no passwd :-(. */
#ifndef CHARSET_EBCDIC
a111 6
#else
	x=ret[0]=((salt[0] == '\0')?os_toascii['A']:salt[0]);
	Eswap0=con_salt[x]<<2;
	x=ret[1]=((salt[1] == '\0')?os_toascii['A']:salt[1]);
	Eswap1=con_salt[x]<<6;
#endif
d126 2
a127 2
	DES_set_key_unchecked(&key,&ks);
	fcrypt_body(&(out[0]),&ks,Eswap0,Eswap1);
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d61 3
@


