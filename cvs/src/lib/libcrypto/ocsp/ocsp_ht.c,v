head	1.24;
access;
symbols;
locks; strict;
comment	@ * @;


1.24
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.23;
commitid	kT0fLt3r4lroFJra;

1.23
date	2016.11.05.15.21.20;	author miod;	state Exp;
branches;
next	1.22;
commitid	IXDXC3oH4oN6UUOH;

1.22
date	2014.10.03.06.02.38;	author doug;	state Exp;
branches;
next	1.21;
commitid	q372AJEo5SAUk3Hj;

1.21
date	2014.07.25.06.05.32;	author doug;	state Exp;
branches;
next	1.20;
commitid	DnBLYuKKjvrWeH3R;

1.20
date	2014.07.12.14.58.32;	author miod;	state Exp;
branches;
next	1.19;
commitid	NZQVVrZ7otjs887q;

1.19
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	mJUVYpkFBZ0Zv2bG;

1.18
date	2014.05.30.02.52.11;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2014.05.23.17.52.46;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.05.18.16.18.13;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2014.05.18.11.28.41;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.05.17.19.58.49;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2014.05.17.19.56.35;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.18.14.37.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.18.38.53;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.17.17.30.22;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.03.02.34.32;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.20.03.40.06;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.15;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.41;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.35;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.13.57;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2011.11.03.02.32.12;	author djm;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: ocsp_ht.c,v 1.23 2016/11/05 15:21:20 miod Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2006.
 */
/* ====================================================================
 * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <openssl/asn1.h>
#include <openssl/ocsp.h>
#include <openssl/err.h>
#include <openssl/buffer.h>

/* Stateful OCSP request code, supporting non-blocking I/O */

/* Opaque OCSP request status structure */

struct ocsp_req_ctx_st {
	int state;		/* Current I/O state */
	unsigned char *iobuf;	/* Line buffer */
	int iobuflen;		/* Line buffer length */
	BIO *io;		/* BIO to perform I/O with */
	BIO *mem;		/* Memory BIO response is built into */
	unsigned long asn1_len;	/* ASN1 length of response */
};

#define OCSP_MAX_REQUEST_LENGTH	(100 * 1024)
#define OCSP_MAX_LINE_LEN	4096;

/* OCSP states */

/* If set no reading should be performed */
#define OHS_NOREAD		0x1000
/* Error condition */
#define OHS_ERROR		(0 | OHS_NOREAD)
/* First line being read */
#define OHS_FIRSTLINE		1
/* MIME headers being read */
#define OHS_HEADERS		2
/* OCSP initial header (tag + length) being read */
#define OHS_ASN1_HEADER		3
/* OCSP content octets being read */
#define OHS_ASN1_CONTENT	4
/* Request being sent */
#define OHS_ASN1_WRITE		(6 | OHS_NOREAD)
/* Request being flushed */
#define OHS_ASN1_FLUSH		(7 | OHS_NOREAD)
/* Completed */
#define OHS_DONE		(8 | OHS_NOREAD)


static int parse_http_line1(char *line);

void
OCSP_REQ_CTX_free(OCSP_REQ_CTX *rctx)
{
	if (rctx == NULL)
		return;

	BIO_free(rctx->mem);
	free(rctx->iobuf);
	free(rctx);
}

int
OCSP_REQ_CTX_set1_req(OCSP_REQ_CTX *rctx, OCSP_REQUEST *req)
{
	if (BIO_printf(rctx->mem, "Content-Type: application/ocsp-request\r\n"
	    "Content-Length: %d\r\n\r\n", i2d_OCSP_REQUEST(req, NULL)) <= 0)
		return 0;
	if (i2d_OCSP_REQUEST_bio(rctx->mem, req) <= 0)
		return 0;
	rctx->state = OHS_ASN1_WRITE;
	rctx->asn1_len = BIO_get_mem_data(rctx->mem, NULL);
	return 1;
}

int
OCSP_REQ_CTX_add1_header(OCSP_REQ_CTX *rctx, const char *name,
    const char *value)
{
	if (!name)
		return 0;
	if (BIO_puts(rctx->mem, name) <= 0)
		return 0;
	if (value) {
		if (BIO_write(rctx->mem, ": ", 2) != 2)
			return 0;
		if (BIO_puts(rctx->mem, value) <= 0)
			return 0;
	}
	if (BIO_write(rctx->mem, "\r\n", 2) != 2)
		return 0;
	return 1;
}

OCSP_REQ_CTX *
OCSP_sendreq_new(BIO *io, char *path, OCSP_REQUEST *req, int maxline)
{
	OCSP_REQ_CTX *rctx;

	rctx = malloc(sizeof(OCSP_REQ_CTX));
	if (rctx == NULL)
		return NULL;
	rctx->state = OHS_ERROR;
	if ((rctx->mem = BIO_new(BIO_s_mem())) == NULL) {
		free(rctx);
		return NULL;
	}
	rctx->io = io;
	rctx->asn1_len = 0;
	if (maxline > 0)
		rctx->iobuflen = maxline;
	else
		rctx->iobuflen = OCSP_MAX_LINE_LEN;
	rctx->iobuf = malloc(rctx->iobuflen);
	if (!rctx->iobuf) {
		BIO_free(rctx->mem);
		free(rctx);
		return NULL;
	}
	if (!path)
		path = "/";

	if (BIO_printf(rctx->mem, "POST %s HTTP/1.0\r\n", path) <= 0) {
		free(rctx->iobuf);
		BIO_free(rctx->mem);
		free(rctx);
		return NULL;
	}

	if (req && !OCSP_REQ_CTX_set1_req(rctx, req)) {
		free(rctx->iobuf);
		BIO_free(rctx->mem);
		free(rctx);
		return NULL;
	}

	return rctx;
}

/* Parse the HTTP response. This will look like this:
 * "HTTP/1.0 200 OK". We need to obtain the numeric code and
 * (optional) informational message.
 */
static int
parse_http_line1(char *line)
{
	int retcode;
	char *p, *q, *r;

	/* Skip to first white space (passed protocol info) */
	for (p = line; *p && !isspace((unsigned char)*p); p++)
		continue;
	if (!*p) {
		OCSPerror(OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		return 0;
	}

	/* Skip past white space to start of response code */
	while (*p && isspace((unsigned char)*p))
		p++;
	if (!*p) {
		OCSPerror(OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		return 0;
	}

	/* Find end of response code: first whitespace after start of code */
	for (q = p; *q && !isspace((unsigned char)*q); q++)
		continue;
	if (!*q) {
		OCSPerror(OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		return 0;
	}

	/* Set end of response code and start of message */
	*q++ = 0;

	/* Attempt to parse numeric code */
	retcode = strtoul(p, &r, 10);

	if (*r)
		return 0;

	/* Skip over any leading white space in message */
	while (*q && isspace((unsigned char)*q))
		q++;
	if (*q) {
		/* Finally zap any trailing white space in message (include
		 * CRLF) */

		/* We know q has a non white space character so this is OK */
		for (r = q + strlen(q) - 1; isspace((unsigned char)*r); r--)
			*r = 0;
	}
	if (retcode != 200) {
		OCSPerror(OCSP_R_SERVER_RESPONSE_ERROR);
		if (!*q)
			ERR_asprintf_error_data("Code=%s", p);
		else
			ERR_asprintf_error_data("Code=%s,Reason=%s", p, q);
		return 0;
	}

	return 1;
}

int
OCSP_sendreq_nbio(OCSP_RESPONSE **presp, OCSP_REQ_CTX *rctx)
{
	int i, n;
	const unsigned char *p;

next_io:
	if (!(rctx->state & OHS_NOREAD)) {
		n = BIO_read(rctx->io, rctx->iobuf, rctx->iobuflen);

		if (n <= 0) {
			if (BIO_should_retry(rctx->io))
				return -1;
			return 0;
		}

		/* Write data to memory BIO */
		if (BIO_write(rctx->mem, rctx->iobuf, n) != n)
			return 0;
	}

	switch (rctx->state) {
	case OHS_ASN1_WRITE:
		n = BIO_get_mem_data(rctx->mem, &p);
		i = BIO_write(rctx->io,
		    p + (n - rctx->asn1_len), rctx->asn1_len);
		if (i <= 0) {
			if (BIO_should_retry(rctx->io))
				return -1;
			rctx->state = OHS_ERROR;
			return 0;
		}

		rctx->asn1_len -= i;
		if (rctx->asn1_len > 0)
			goto next_io;

		rctx->state = OHS_ASN1_FLUSH;

		(void)BIO_reset(rctx->mem);
		/* FALLTHROUGH */

	case OHS_ASN1_FLUSH:
		i = BIO_flush(rctx->io);
		if (i > 0) {
			rctx->state = OHS_FIRSTLINE;
			goto next_io;
		}

		if (BIO_should_retry(rctx->io))
			return -1;

		rctx->state = OHS_ERROR;
		return 0;

	case OHS_ERROR:
		return 0;

	case OHS_FIRSTLINE:
	case OHS_HEADERS:
		/* Attempt to read a line in */
next_line:
		/* Due to &%^*$" memory BIO behaviour with BIO_gets we
		 * have to check there's a complete line in there before
		 * calling BIO_gets or we'll just get a partial read.
		 */
		n = BIO_get_mem_data(rctx->mem, &p);
		if ((n <= 0) || !memchr(p, '\n', n)) {
			if (n >= rctx->iobuflen) {
				rctx->state = OHS_ERROR;
				return 0;
			}
			goto next_io;
		}
		n = BIO_gets(rctx->mem, (char *)rctx->iobuf, rctx->iobuflen);
		if (n <= 0) {
			if (BIO_should_retry(rctx->mem))
				goto next_io;
			rctx->state = OHS_ERROR;
			return 0;
		}

		/* Don't allow excessive lines */
		if (n == rctx->iobuflen) {
			rctx->state = OHS_ERROR;
			return 0;
		}

		/* First line */
		if (rctx->state == OHS_FIRSTLINE) {
			if (parse_http_line1((char *)rctx->iobuf)) {
				rctx->state = OHS_HEADERS;
				goto next_line;
			} else {
				rctx->state = OHS_ERROR;
				return 0;
			}
		} else {
			/* Look for blank line: end of headers */
			for (p = rctx->iobuf; *p; p++) {
				if ((*p != '\r') && (*p != '\n'))
					break;
			}
			if (*p)
				goto next_line;

			rctx->state = OHS_ASN1_HEADER;
		}
		/* FALLTRHOUGH */

	case OHS_ASN1_HEADER:
		/* Now reading ASN1 header: can read at least 2 bytes which
		 * is enough for ASN1 SEQUENCE header and either length field
		 * or at least the length of the length field.
		 */
		n = BIO_get_mem_data(rctx->mem, &p);
		if (n < 2)
			goto next_io;

		/* Check it is an ASN1 SEQUENCE */
		if (*p++ != (V_ASN1_SEQUENCE|V_ASN1_CONSTRUCTED)) {
			rctx->state = OHS_ERROR;
			return 0;
		}

		/* Check out length field */
		if (*p & 0x80) {
			/* If MSB set on initial length octet we can now
			 * always read 6 octets: make sure we have them.
			 */
			if (n < 6)
				goto next_io;
			n = *p & 0x7F;
			/* Not NDEF or excessive length */
			if (!n || (n > 4)) {
				rctx->state = OHS_ERROR;
				return 0;
			}
			p++;
			rctx->asn1_len = 0;
			for (i = 0; i < n; i++) {
				rctx->asn1_len <<= 8;
				rctx->asn1_len |= *p++;
			}

			if (rctx->asn1_len > OCSP_MAX_REQUEST_LENGTH) {
				rctx->state = OHS_ERROR;
				return 0;
			}

			rctx->asn1_len += n + 2;
		} else
			rctx->asn1_len = *p + 2;

		rctx->state = OHS_ASN1_CONTENT;

		/* FALLTHROUGH */

	case OHS_ASN1_CONTENT:
		n = BIO_get_mem_data(rctx->mem, &p);
		if (n < (int)rctx->asn1_len)
			goto next_io;

		*presp = d2i_OCSP_RESPONSE(NULL, &p, rctx->asn1_len);
		if (*presp) {
			rctx->state = OHS_DONE;
			return 1;
		}

		rctx->state = OHS_ERROR;
		return 0;

	case OHS_DONE:
		return 1;
	}

	return 0;
}

/* Blocking OCSP request handler: now a special case of non-blocking I/O */
OCSP_RESPONSE *
OCSP_sendreq_bio(BIO *b, char *path, OCSP_REQUEST *req)
{
	OCSP_RESPONSE *resp = NULL;
	OCSP_REQ_CTX *ctx;
	int rv;

	ctx = OCSP_sendreq_new(b, path, req, -1);
	if (ctx == NULL)
		return NULL;

	do {
		rv = OCSP_sendreq_nbio(&resp, ctx);
	} while ((rv == -1) && BIO_should_retry(b));

	OCSP_REQ_CTX_free(ctx);

	if (rv)
		return resp;

	return NULL;
}
@


1.23
log
@Check BIO_new*() for failure.

ok beck@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp_ht.c,v 1.22 2014/10/03 06:02:38 doug Exp $ */
d210 1
a210 2
		OCSPerr(OCSP_F_PARSE_HTTP_LINE1,
		    OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
d218 1
a218 2
		OCSPerr(OCSP_F_PARSE_HTTP_LINE1,
		    OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
d226 1
a226 2
		OCSPerr(OCSP_F_PARSE_HTTP_LINE1,
		    OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
d251 1
a251 1
		OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_ERROR);
@


1.22
log
@Use string literals in printf style calls so gcc's -Wformat works.

ok tedu@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp_ht.c,v 1.21 2014/07/25 06:05:32 doug Exp $ */
d160 4
a163 1
	rctx->mem = BIO_new(BIO_s_mem());
@


1.21
log
@BIO_free() returns immediately when the sole input is NULL.
Remove unnecessary NULL check.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp_ht.c,v 1.20 2014/07/12 14:58:32 miod Exp $ */
d122 2
a123 5
	static const char req_hdr[] =
	    "Content-Type: application/ocsp-request\r\n"
	    "Content-Length: %d\r\n\r\n";

	if (BIO_printf(rctx->mem, req_hdr, i2d_OCSP_REQUEST(req, NULL)) <= 0)
a153 1
	static const char post_hdr[] = "POST %s HTTP/1.0\r\n";
d176 1
a176 1
	if (BIO_printf(rctx->mem, post_hdr, path) <= 0) {
@


1.20
log
@Principle of least surprise: make CMAC_CTX_free(), OCSP_REQ_CTX_free() and
X509_STORE_CTX_free() accept NULL pointers as input without dereferencing them,
like all the other well-behaved *_CTX_free() functions do.
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp_ht.c,v 1.19 2014/06/12 15:49:30 deraadt Exp $ */
d114 1
a114 2
	if (rctx->mem)
		BIO_free(rctx->mem);
@


1.19
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d111 3
@


1.18
log
@no need for null check before free. from Brendan MacDonell
@
text
@d1 1
a1 1
/* ocsp_ht.c */
@


1.17
log
@Not OPENSSL_SYS_SUNOS.
@
text
@d113 1
a113 2
	if (rctx->iobuf)
		free(rctx->iobuf);
@


1.16
log
@In OCSP_sendreq_bio(), cope with OCSP_sendreq_new() returning NULL.

ok jsing@@
@
text
@a66 3
#ifdef OPENSSL_SYS_SUNOS
#define strtoul (unsigned long)strtol
#endif /* OPENSSL_SYS_SUNOS */
@


1.15
log
@More KNF.
@
text
@d164 1
a164 1
		return 0;
d177 1
a177 1
		return 0;
d186 1
a186 1
		return 0;
d193 1
a193 1
		return 0;
d456 2
@


1.14
log
@unchecked malloc() return value in OCSP_sendreq_new().
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d236 1
a236 1
	/* Set end of response code and start of message */ 
d293 1
a293 1
			p + (n - rctx->asn1_len), rctx->asn1_len);
d425 1
a425 1
		
@


1.13
log
@KNF
@
text
@d163 2
@


1.12
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d82 1
a82 1
	};
d111 3
a113 2
void OCSP_REQ_CTX_free(OCSP_REQ_CTX *rctx)
	{
d119 1
a119 1
	}
d121 3
a123 2
int OCSP_REQ_CTX_set1_req(OCSP_REQ_CTX *rctx, OCSP_REQUEST *req)
	{
d125 4
a128 3
	"Content-Type: application/ocsp-request\r\n"
	"Content-Length: %d\r\n\r\n";
        if (BIO_printf(rctx->mem, req_hdr, i2d_OCSP_REQUEST(req, NULL)) <= 0)
d130 1
a130 1
        if (i2d_OCSP_REQUEST_bio(rctx->mem, req) <= 0)
d135 1
a135 1
	}
d137 4
a140 3
int OCSP_REQ_CTX_add1_header(OCSP_REQ_CTX *rctx,
		const char *name, const char *value)
	{
d145 1
a145 2
	if (value)
		{
d150 1
a150 1
		}
d154 1
a154 1
	}
d156 3
a158 3
OCSP_REQ_CTX *OCSP_sendreq_new(BIO *io, char *path, OCSP_REQUEST *req,
								int maxline)
	{
d160 1
a161 1
	OCSP_REQ_CTX *rctx;
d180 1
a180 1
        if (BIO_printf(rctx->mem, post_hdr, path) <= 0) {
d195 1
a195 1
	}
d201 3
a203 3

static int parse_http_line1(char *line)
	{
d206 1
d208 1
a208 2

	for(p = line; *p && !isspace((unsigned char)*p); p++)
d210 1
a210 2
	if(!*p)
		{
d212 1
a212 1
					OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
d214 1
a214 1
		}
d217 1
a217 1
	while(*p && isspace((unsigned char)*p))
d219 1
a219 3

	if(!*p)
		{
d221 1
a221 1
					OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
d223 1
a223 1
		}
d226 1
a226 1
	for(q = p; *q && !isspace((unsigned char)*q); q++)
d228 1
a228 3

	if(!*q)
		{
d230 1
a230 1
					OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
d232 1
a232 1
		}
d240 1
a240 1
	if(*r)
d244 1
a244 1
	while(*q && isspace((unsigned char)*q))
d246 1
a246 3

	if(*q)
		{
d251 1
a251 1
		for(r = q + strlen(q) - 1; isspace((unsigned char)*r); r--)
d253 2
a254 3
		}
	if(retcode != 200)
		{
d256 1
a256 1
		if(!*q)
d261 1
a261 2
		}

d264 1
d266 3
a268 4
	}

int OCSP_sendreq_nbio(OCSP_RESPONSE **presp, OCSP_REQ_CTX *rctx)
	{
d271 3
a273 3
	next_io:
	if (!(rctx->state & OHS_NOREAD))
		{
d276 1
a276 2
		if (n <= 0)
			{
d280 1
a280 1
			}
a282 1

d285 1
a285 1
		}
d287 2
a288 4
	switch(rctx->state)
		{

		case OHS_ASN1_WRITE:
a289 1

d292 1
a292 3

		if (i <= 0)
			{
d297 1
a297 1
			}
a299 1

d306 1
d308 1
a308 2
		case OHS_ASN1_FLUSH:

d310 1
a310 3

		if (i > 0)
			{
d313 1
a313 1
			}
d321 1
a321 1
		case OHS_ERROR:
d324 2
a325 3
		case OHS_FIRSTLINE:
		case OHS_HEADERS:

d327 1
a327 2

		next_line:
d333 2
a334 4
		if ((n <= 0) || !memchr(p, '\n', n))
			{
			if (n >= rctx->iobuflen)
				{
d337 1
a337 1
				}
d339 1
a339 1
			}
d341 1
a341 3

		if (n <= 0)
			{
d346 1
a346 1
			}
d349 1
a349 2
		if (n == rctx->iobuflen)
			{
d352 1
a352 1
			}
d355 2
a356 4
		if (rctx->state == OHS_FIRSTLINE)
			{
			if (parse_http_line1((char *)rctx->iobuf))
				{
d359 1
a359 3
				}
			else
				{
a361 1
				}
d363 1
a363 2
		else
			{
d365 1
a365 2
			for (p = rctx->iobuf; *p; p++)
				{
d368 1
a368 1
				}
d373 2
d376 1
a376 6
			}
 
		/* Fall thru */


		case OHS_ASN1_HEADER:
d386 1
a386 2
		if (*p++ != (V_ASN1_SEQUENCE|V_ASN1_CONSTRUCTED))
			{
d389 1
a389 1
			}
d392 1
a392 2
		if (*p & 0x80)
			{
d400 1
a400 2
			if (!n || (n > 4))
				{
d403 1
a403 1
				}
d406 1
a406 2
			for (i = 0; i < n; i++)
				{
d409 1
a409 1
				}
d411 1
a411 2
			if (rctx->asn1_len > OCSP_MAX_REQUEST_LENGTH)
				{
d414 1
a414 1
				}
d417 1
a417 2
			}
		else
d422 1
a422 1
		/* Fall thru */
d424 1
a424 1
		case OHS_ASN1_CONTENT:
a428 1

d430 1
a430 2
		if (*presp)
			{
d433 1
a433 1
			}
d438 1
a438 3
		break;

		case OHS_DONE:
d440 1
a440 4

		}


d443 1
a443 3


	}
d446 3
a448 3

OCSP_RESPONSE *OCSP_sendreq_bio(BIO *b, char *path, OCSP_REQUEST *req)
	{
d455 1
a455 2
	do
		{
d457 1
a457 1
		} while ((rv == -1) && BIO_should_retry(b));
d465 1
a465 1
	}
@


1.11
log
@Put the final pieces from e_os.h in the required places, and remove it.
"dance on it's grave" says beck
ok guenther beck
@
text
@d262 1
a262 1
			ERR_add_error_data(2, "Code=", p);
d264 1
a264 1
			ERR_add_error_data(4, "Code=", p, ",Reason=", q);
@


1.10
log
@fix some more leaks, mostly suggestions from miod
ok miod@@
@
text
@a62 1
#include "e_os.h"
@


1.9
log
@fix some of the leaks
ok miod@@ looks good deraadt@@
@
text
@d171 1
d180 1
d187 1
@


1.8
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d170 2
a171 1
	if (!rctx->iobuf)
d173 1
d177 3
a179 1
        if (BIO_printf(rctx->mem, post_hdr, path) <= 0)
d181 1
d183 3
a185 1
	if (req && !OCSP_REQ_CTX_set1_req(rctx, req))
d187 1
@


1.7
log
@openssl-1.0.0e: resolve conflicts
@
text
@d117 2
a118 2
		OPENSSL_free(rctx->iobuf);
	OPENSSL_free(rctx);
d160 1
a160 1
	rctx = OPENSSL_malloc(sizeof(OCSP_REQ_CTX));
d169 1
a169 1
	rctx->iobuf = OPENSSL_malloc(rctx->iobuflen);
@


1.6
log
@resolve conflicts, fix local changes
@
text
@d400 3
a402 2
		/* Now reading ASN1 header: can read at least 6 bytes which
		 * is more than enough for any valid ASN1 SEQUENCE header
d405 1
a405 1
		if (n < 6)
d418 5
@


1.5
log
@resolve conflicts
@
text
@d121 33
d157 1
a157 3
	static char post_hdr[] = "POST %s HTTP/1.0\r\n"
	"Content-Type: application/ocsp-request\r\n"
	"Content-Length: %d\r\n\r\n";
d161 1
a161 1
	rctx->state = OHS_FIRSTLINE;
d164 1
d170 2
d175 1
a175 4
        if (BIO_printf(rctx->mem, post_hdr, path,
				i2d_OCSP_REQUEST(req, NULL)) <= 0)
		{
		rctx->state = OHS_ERROR;
d177 2
a178 4
		}
        if (i2d_OCSP_REQUEST_bio(rctx->mem, req) <= 0)
		{
		rctx->state = OHS_ERROR;
a179 3
		}
	rctx->state = OHS_ASN1_WRITE;
	rctx->asn1_len = BIO_get_mem_data(rctx->mem, NULL);
@


1.4
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
a58 1
#include <openssl/asn1.h>
d63 2
@


1.3
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d3 1
a3 1
 * project 2000.
d6 1
a6 1
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
d71 39
a109 5
/* Quick and dirty HTTP OCSP request handler.
 * Could make this a bit cleverer by adding
 * support for non blocking BIOs and a few
 * other refinements.
 */
d111 7
a117 16
OCSP_RESPONSE *OCSP_sendreq_bio(BIO *b, char *path, OCSP_REQUEST *req)
{
	BIO *mem = NULL;
	char tmpbuf[1024];
	OCSP_RESPONSE *resp = NULL;
	char *p, *q, *r;
	int len, retcode;
	static char req_txt[] =
"POST %s HTTP/1.0\r\n\
Content-Type: application/ocsp-request\r\n\
Content-Length: %d\r\n\r\n";

	len = i2d_OCSP_REQUEST(req, NULL);
	if(BIO_printf(b, req_txt, path, len) < 0) {
		OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_WRITE_ERROR);
		goto err;
d119 31
a149 10
	if(i2d_OCSP_REQUEST_bio(b, req) <= 0) {
		OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_WRITE_ERROR);
		goto err;
	}
	if(!(mem = BIO_new(BIO_s_mem()))) goto err;
	/* Copy response to a memory BIO: socket bios can't do gets! */
	while ((len = BIO_read(b, tmpbuf, sizeof tmpbuf))) {
		if(len < 0) {
			OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_READ_ERROR);
			goto err;
d151 4
a154 1
		BIO_write(mem, tmpbuf, len);
a155 8
	if(BIO_gets(mem, tmpbuf, 512) <= 0) {
		OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		goto err;
	}
	/* Parse the HTTP response. This will look like this:
	 * "HTTP/1.0 200 OK". We need to obtain the numeric code and
         * (optional) informational message.
	 */
d157 9
d167 10
a176 5
	for(p = tmpbuf; *p && !isspace((unsigned char)*p); p++) continue;
	if(!*p) {
		OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		goto err;
	}
d178 10
a187 5
	while(isspace((unsigned char)*p)) p++;
	if(!*p) {
		OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		goto err;
	}
d189 10
a198 5
	for(q = p; *q && !isspace((unsigned char)*q); q++) continue;
	if(!*q) {
		OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		goto err;
	}
d201 1
d204 4
a207 1
	if(*r) goto err;
d209 16
a224 9
	while(isspace((unsigned char)*q))  q++;
	if(*q) {
	/* Finally zap any trailing white space in message (include CRLF) */
	/* We know q has a non white space character so this is OK */
		for(r = q + strlen(q) - 1; isspace((unsigned char)*r); r--) *r = 0;
	}
	if(retcode != 200) {
		OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_ERROR);
		if(!*q) { 
d226 1
a226 2
		}
		else {
d228 1
d230 4
a233 1
		goto err;
d235 2
a236 2
	/* Find blank line marking beginning of content */	
	while(BIO_gets(mem, tmpbuf, 512) > 0)
d238 210
a447 2
		for(p = tmpbuf; isspace((unsigned char)*p); p++) continue;
		if(!*p) break;
d449 22
a470 7
	if(*p) {
		OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_NO_CONTENT);
		goto err;
	}
	if(!(resp = d2i_OCSP_RESPONSE_bio(mem, NULL))) {
		OCSPerr(OCSP_F_OCSP_SENDREQ_BIO,ERR_R_NESTED_ASN1_ERROR);
		goto err;
a471 4
	err:
	BIO_free(mem);
	return resp;
}
@


1.2
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d123 1
a123 1
	while(*p && isspace((unsigned char)*p)) p++;
d140 1
a140 1
	while(*q && isspace((unsigned char)*q))  q++;
d159 1
a159 1
		for(p = tmpbuf; *p && isspace((unsigned char)*p); p++) continue;
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d67 3
d100 1
a100 1
	while ((len = BIO_read(b, tmpbuf, 1024))) {
d113 1
a113 1
         * informational message.
d141 1
a141 1
	if(!*q) goto err;
d144 2
a145 1
	for(r = q + strlen(q) - 1; isspace((unsigned char)*r); r--) *r = 0;
d148 6
a153 1
		ERR_add_error_data(4, "Code=", p, ",Reason=", q);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@a66 3
#ifdef OPENSSL_SYS_SUNOS
#define strtoul (unsigned long)strtol
#endif /* OPENSSL_SYS_SUNOS */
d97 1
a97 1
	while ((len = BIO_read(b, tmpbuf, sizeof tmpbuf))) {
d110 1
a110 1
         * (optional) informational message.
d138 1
a138 1
	if(*q) {
d141 1
a141 2
		for(r = q + strlen(q) - 1; isspace((unsigned char)*r); r--) *r = 0;
	}
d144 1
a144 6
		if(!*q) { 
			ERR_add_error_data(2, "Code=", p);
		}
		else {
			ERR_add_error_data(4, "Code=", p, ",Reason=", q);
		}
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d3 1
a3 1
 * project 2006.
d6 1
a6 1
 * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
d71 5
a75 1
/* Stateful OCSP request code, supporting non-blocking I/O */
d77 20
a96 45
/* Opaque OCSP request status structure */

struct ocsp_req_ctx_st {
	int state;		/* Current I/O state */
	unsigned char *iobuf;	/* Line buffer */
	int iobuflen;		/* Line buffer length */
	BIO *io;		/* BIO to perform I/O with */
	BIO *mem;		/* Memory BIO response is built into */
	unsigned long asn1_len;	/* ASN1 length of response */
	};

#define OCSP_MAX_REQUEST_LENGTH	(100 * 1024)
#define OCSP_MAX_LINE_LEN	4096;

/* OCSP states */

/* If set no reading should be performed */
#define OHS_NOREAD		0x1000
/* Error condition */
#define OHS_ERROR		(0 | OHS_NOREAD)
/* First line being read */
#define OHS_FIRSTLINE		1
/* MIME headers being read */
#define OHS_HEADERS		2
/* OCSP initial header (tag + length) being read */
#define OHS_ASN1_HEADER		3
/* OCSP content octets being read */
#define OHS_ASN1_CONTENT	4
/* Request being sent */
#define OHS_ASN1_WRITE		(6 | OHS_NOREAD)
/* Request being flushed */
#define OHS_ASN1_FLUSH		(7 | OHS_NOREAD)
/* Completed */
#define OHS_DONE		(8 | OHS_NOREAD)


static int parse_http_line1(char *line);

void OCSP_REQ_CTX_free(OCSP_REQ_CTX *rctx)
	{
	if (rctx->mem)
		BIO_free(rctx->mem);
	if (rctx->iobuf)
		OPENSSL_free(rctx->iobuf);
	OPENSSL_free(rctx);
d98 6
a103 26

OCSP_REQ_CTX *OCSP_sendreq_new(BIO *io, char *path, OCSP_REQUEST *req,
								int maxline)
	{
	static char post_hdr[] = "POST %s HTTP/1.0\r\n"
	"Content-Type: application/ocsp-request\r\n"
	"Content-Length: %d\r\n\r\n";

	OCSP_REQ_CTX *rctx;
	rctx = OPENSSL_malloc(sizeof(OCSP_REQ_CTX));
	rctx->state = OHS_FIRSTLINE;
	rctx->mem = BIO_new(BIO_s_mem());
	rctx->io = io;
	if (maxline > 0)
		rctx->iobuflen = maxline;
	else
		rctx->iobuflen = OCSP_MAX_LINE_LEN;
	rctx->iobuf = OPENSSL_malloc(rctx->iobuflen);
	if (!path)
		path = "/";

        if (BIO_printf(rctx->mem, post_hdr, path,
				i2d_OCSP_REQUEST(req, NULL)) <= 0)
		{
		rctx->state = OHS_ERROR;
		return 0;
d105 5
a109 9
        if (i2d_OCSP_REQUEST_bio(rctx->mem, req) <= 0)
		{
		rctx->state = OHS_ERROR;
		return 0;
		}
	rctx->state = OHS_ASN1_WRITE;
	rctx->asn1_len = BIO_get_mem_data(rctx->mem, NULL);

	return rctx;
d111 4
a115 9
/* Parse the HTTP response. This will look like this:
 * "HTTP/1.0 200 OK". We need to obtain the numeric code and
 * (optional) informational message.
 */

static int parse_http_line1(char *line)
	{
	int retcode;
	char *p, *q, *r;
d117 5
a121 10

	for(p = line; *p && !isspace((unsigned char)*p); p++)
		continue;
	if(!*p)
		{
		OCSPerr(OCSP_F_PARSE_HTTP_LINE1,
					OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		return 0;
		}

d123 5
a127 10
	while(*p && isspace((unsigned char)*p))
		p++;

	if(!*p)
		{
		OCSPerr(OCSP_F_PARSE_HTTP_LINE1,
					OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		return 0;
		}

d129 5
a133 10
	for(q = p; *q && !isspace((unsigned char)*q); q++)
		continue;

	if(!*q)
		{
		OCSPerr(OCSP_F_PARSE_HTTP_LINE1,
					OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
		return 0;
		}

a135 1

d138 1
a138 4

	if(*r)
		return 0;

d140 10
a149 11
	while(*q && isspace((unsigned char)*q))
		q++;

	if(*q)
		{
		/* Finally zap any trailing white space in message (include
		 * CRLF) */

		/* We know q has a non white space character so this is OK */
		for(r = q + strlen(q) - 1; isspace((unsigned char)*r); r--)
			*r = 0;
d151 1
a151 6
	if(retcode != 200)
		{
		OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_ERROR);
		if(!*q)
			ERR_add_error_data(2, "Code=", p);
		else
a152 1
		return 0;
d154 1
a154 4


	return 1;

d156 2
a157 2

int OCSP_sendreq_nbio(OCSP_RESPONSE **presp, OCSP_REQ_CTX *rctx)
d159 6
a164 210
	int i, n;
	const unsigned char *p;
	next_io:
	if (!(rctx->state & OHS_NOREAD))
		{
		n = BIO_read(rctx->io, rctx->iobuf, rctx->iobuflen);

		if (n <= 0)
			{
			if (BIO_should_retry(rctx->io))
				return -1;
			return 0;
			}

		/* Write data to memory BIO */

		if (BIO_write(rctx->mem, rctx->iobuf, n) != n)
			return 0;
		}

	switch(rctx->state)
		{

		case OHS_ASN1_WRITE:
		n = BIO_get_mem_data(rctx->mem, &p);

		i = BIO_write(rctx->io,
			p + (n - rctx->asn1_len), rctx->asn1_len);

		if (i <= 0)
			{
			if (BIO_should_retry(rctx->io))
				return -1;
			rctx->state = OHS_ERROR;
			return 0;
			}

		rctx->asn1_len -= i;

		if (rctx->asn1_len > 0)
			goto next_io;

		rctx->state = OHS_ASN1_FLUSH;

		(void)BIO_reset(rctx->mem);

		case OHS_ASN1_FLUSH:

		i = BIO_flush(rctx->io);

		if (i > 0)
			{
			rctx->state = OHS_FIRSTLINE;
			goto next_io;
			}

		if (BIO_should_retry(rctx->io))
			return -1;

		rctx->state = OHS_ERROR;
		return 0;

		case OHS_ERROR:
		return 0;

		case OHS_FIRSTLINE:
		case OHS_HEADERS:

		/* Attempt to read a line in */

		next_line:
		/* Due to &%^*$" memory BIO behaviour with BIO_gets we
		 * have to check there's a complete line in there before
		 * calling BIO_gets or we'll just get a partial read.
		 */
		n = BIO_get_mem_data(rctx->mem, &p);
		if ((n <= 0) || !memchr(p, '\n', n))
			{
			if (n >= rctx->iobuflen)
				{
				rctx->state = OHS_ERROR;
				return 0;
				}
			goto next_io;
			}
		n = BIO_gets(rctx->mem, (char *)rctx->iobuf, rctx->iobuflen);

		if (n <= 0)
			{
			if (BIO_should_retry(rctx->mem))
				goto next_io;
			rctx->state = OHS_ERROR;
			return 0;
			}

		/* Don't allow excessive lines */
		if (n == rctx->iobuflen)
			{
			rctx->state = OHS_ERROR;
			return 0;
			}

		/* First line */
		if (rctx->state == OHS_FIRSTLINE)
			{
			if (parse_http_line1((char *)rctx->iobuf))
				{
				rctx->state = OHS_HEADERS;
				goto next_line;
				}
			else
				{
				rctx->state = OHS_ERROR;
				return 0;
				}
			}
		else
			{
			/* Look for blank line: end of headers */
			for (p = rctx->iobuf; *p; p++)
				{
				if ((*p != '\r') && (*p != '\n'))
					break;
				}
			if (*p)
				goto next_line;

			rctx->state = OHS_ASN1_HEADER;

			}
 
		/* Fall thru */


		case OHS_ASN1_HEADER:
		/* Now reading ASN1 header: can read at least 6 bytes which
		 * is more than enough for any valid ASN1 SEQUENCE header
		 */
		n = BIO_get_mem_data(rctx->mem, &p);
		if (n < 6)
			goto next_io;

		/* Check it is an ASN1 SEQUENCE */
		if (*p++ != (V_ASN1_SEQUENCE|V_ASN1_CONSTRUCTED))
			{
			rctx->state = OHS_ERROR;
			return 0;
			}

		/* Check out length field */
		if (*p & 0x80)
			{
			n = *p & 0x7F;
			/* Not NDEF or excessive length */
			if (!n || (n > 4))
				{
				rctx->state = OHS_ERROR;
				return 0;
				}
			p++;
			rctx->asn1_len = 0;
			for (i = 0; i < n; i++)
				{
				rctx->asn1_len <<= 8;
				rctx->asn1_len |= *p++;
				}

			if (rctx->asn1_len > OCSP_MAX_REQUEST_LENGTH)
				{
				rctx->state = OHS_ERROR;
				return 0;
				}

			rctx->asn1_len += n + 2;
			}
		else
			rctx->asn1_len = *p + 2;

		rctx->state = OHS_ASN1_CONTENT;

		/* Fall thru */
		
		case OHS_ASN1_CONTENT:
		n = BIO_get_mem_data(rctx->mem, &p);
		if (n < (int)rctx->asn1_len)
			goto next_io;


		*presp = d2i_OCSP_RESPONSE(NULL, &p, rctx->asn1_len);
		if (*presp)
			{
			rctx->state = OHS_DONE;
			return 1;
			}

		rctx->state = OHS_ERROR;
		return 0;

		break;

		case OHS_DONE:
		return 1;

		}



	return 0;


d166 3
a168 22

/* Blocking OCSP request handler: now a special case of non-blocking I/O */

OCSP_RESPONSE *OCSP_sendreq_bio(BIO *b, char *path, OCSP_REQUEST *req)
	{
	OCSP_RESPONSE *resp = NULL;
	OCSP_REQ_CTX *ctx;
	int rv;

	ctx = OCSP_sendreq_new(b, path, req, -1);

	do
		{
		rv = OCSP_sendreq_nbio(&resp, ctx);
		} while ((rv == -1) && BIO_should_retry(b));

	OCSP_REQ_CTX_free(ctx);

	if (rv)
		return resp;

	return NULL;
d170 4
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
d59 1
a63 2
#include "e_os.h"
#include <openssl/asn1.h>
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@d121 2
a122 1
int OCSP_REQ_CTX_set1_req(OCSP_REQ_CTX *rctx, OCSP_REQUEST *req)
d124 1
a124 1
	static const char req_hdr[] =
a126 32
        if (BIO_printf(rctx->mem, req_hdr, i2d_OCSP_REQUEST(req, NULL)) <= 0)
		return 0;
        if (i2d_OCSP_REQUEST_bio(rctx->mem, req) <= 0)
		return 0;
	rctx->state = OHS_ASN1_WRITE;
	rctx->asn1_len = BIO_get_mem_data(rctx->mem, NULL);
	return 1;
	}

int OCSP_REQ_CTX_add1_header(OCSP_REQ_CTX *rctx,
		const char *name, const char *value)
	{
	if (!name)
		return 0;
	if (BIO_puts(rctx->mem, name) <= 0)
		return 0;
	if (value)
		{
		if (BIO_write(rctx->mem, ": ", 2) != 2)
			return 0;
		if (BIO_puts(rctx->mem, value) <= 0)
			return 0;
		}
	if (BIO_write(rctx->mem, "\r\n", 2) != 2)
		return 0;
	return 1;
	}

OCSP_REQ_CTX *OCSP_sendreq_new(BIO *io, char *path, OCSP_REQUEST *req,
								int maxline)
	{
	static const char post_hdr[] = "POST %s HTTP/1.0\r\n";
d130 1
a130 1
	rctx->state = OHS_ERROR;
a132 1
	rctx->asn1_len = 0;
a137 2
	if (!rctx->iobuf)
		return 0;
d141 4
a144 1
        if (BIO_printf(rctx->mem, post_hdr, path) <= 0)
d146 4
a149 2

	if (req && !OCSP_REQ_CTX_set1_req(rctx, req))
d151 3
@


1.1.1.6
log
@import OpenSSL 1.0.0e
@
text
@d400 2
a401 3
		/* Now reading ASN1 header: can read at least 2 bytes which
		 * is enough for ASN1 SEQUENCE header and either length field
		 * or at least the length of the length field.
d404 1
a404 1
		if (n < 2)
a416 5
			/* If MSB set on initial length octet we can now
			 * always read 6 octets: make sure we have them.
			 */
			if (n < 6)
				goto next_io;
@


