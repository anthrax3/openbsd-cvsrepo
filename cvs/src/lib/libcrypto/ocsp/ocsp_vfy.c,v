head	1.15;
access;
symbols
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15;
locks; strict;
comment	@ * @;


1.15
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.14;
commitid	kT0fLt3r4lroFJra;

1.14
date	2016.11.05.13.27.53;	author miod;	state Exp;
branches;
next	1.13;
commitid	2TH7jYHT8jUsP7nC;

1.13
date	2016.07.05.00.21.47;	author beck;	state Exp;
branches;
next	1.12;
commitid	jU7uyHFEixprtZo6;

1.12
date	2014.07.09.19.08.10;	author tedu;	state Exp;
branches;
next	1.11;
commitid	T6O0DHYt9fZJHiwB;

1.11
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	mJUVYpkFBZ0Zv2bG;

1.10
date	2014.05.18.11.28.41;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2014.05.17.19.56.35;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.13.15.25.33;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2013.02.14.15.11.43;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.01.22.58.56;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.2;

1.2
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.15;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.41;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.20.41.46;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.45;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.01.09.12.13.57;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.10.01.22.54.09;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: ocsp_vfy.c,v 1.14 2016/11/05 13:27:53 miod Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 2000.
 */
/* ====================================================================
 * Copyright (c) 2000-2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <openssl/ocsp.h>
#include <openssl/err.h>
#include <string.h>

static int ocsp_find_signer(X509 **psigner, OCSP_BASICRESP *bs,
    STACK_OF(X509) *certs, X509_STORE *st, unsigned long flags);
static X509 *ocsp_find_signer_sk(STACK_OF(X509) *certs, OCSP_RESPID *id);
static int ocsp_check_issuer(OCSP_BASICRESP *bs, STACK_OF(X509) *chain,
    unsigned long flags);
static int ocsp_check_ids(STACK_OF(OCSP_SINGLERESP) *sresp, OCSP_CERTID **ret);
static int ocsp_match_issuerid(X509 *cert, OCSP_CERTID *cid,
    STACK_OF(OCSP_SINGLERESP) *sresp);
static int ocsp_check_delegated(X509 *x, int flags);
static int ocsp_req_find_signer(X509 **psigner, OCSP_REQUEST *req,
    X509_NAME *nm, STACK_OF(X509) *certs, X509_STORE *st,
    unsigned long flags);

/* Verify a basic response message */
int
OCSP_basic_verify(OCSP_BASICRESP *bs, STACK_OF(X509) *certs, X509_STORE *st,
    unsigned long flags)
{
	X509 *signer, *x;
	STACK_OF(X509) *chain = NULL;
	STACK_OF(X509) *untrusted = NULL;
	X509_STORE_CTX ctx;
	int i, ret = 0;

	ret = ocsp_find_signer(&signer, bs, certs, st, flags);
	if (!ret) {
		OCSPerror(OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
		goto end;
	}
	if ((ret == 2) && (flags & OCSP_TRUSTOTHER))
		flags |= OCSP_NOVERIFY;
	if (!(flags & OCSP_NOSIGS)) {
		EVP_PKEY *skey;

		skey = X509_get_pubkey(signer);
		if (skey) {
			ret = OCSP_BASICRESP_verify(bs, skey, 0);
			EVP_PKEY_free(skey);
		}
		if (!skey || ret <= 0) {
			OCSPerror(OCSP_R_SIGNATURE_FAILURE);
			goto end;
		}
	}
	if (!(flags & OCSP_NOVERIFY)) {
		int init_res;

		if (flags & OCSP_NOCHAIN) {
			untrusted = NULL;
		} else if (bs->certs && certs) {
			untrusted = sk_X509_dup(bs->certs);
			for (i = 0; i < sk_X509_num(certs); i++) {
				if (!sk_X509_push(untrusted,
					sk_X509_value(certs, i))) {
					OCSPerror(ERR_R_MALLOC_FAILURE);
					goto end;
				}
			}
		} else
			untrusted = bs->certs;
		init_res = X509_STORE_CTX_init(&ctx, st, signer, untrusted);
		if (!init_res) {
			ret = -1;
			OCSPerror(ERR_R_X509_LIB);
			goto end;
		}

		if (X509_STORE_CTX_set_purpose(&ctx,
		    X509_PURPOSE_OCSP_HELPER) == 0) {
			X509_STORE_CTX_cleanup(&ctx);
			ret = -1;
			goto end;
		}
		ret = X509_verify_cert(&ctx);
		chain = X509_STORE_CTX_get1_chain(&ctx);
		X509_STORE_CTX_cleanup(&ctx);
		if (ret <= 0) {
			i = X509_STORE_CTX_get_error(&ctx);
			OCSPerror(OCSP_R_CERTIFICATE_VERIFY_ERROR);
			ERR_asprintf_error_data("Verify error:%s",
			    X509_verify_cert_error_string(i));
			goto end;
		}
		if (flags & OCSP_NOCHECKS) {
			ret = 1;
			goto end;
		}
		/* At this point we have a valid certificate chain
		 * need to verify it against the OCSP issuer criteria.
		 */
		ret = ocsp_check_issuer(bs, chain, flags);

		/* If fatal error or valid match then finish */
		if (ret != 0)
			goto end;

		/* Easy case: explicitly trusted. Get root CA and
		 * check for explicit trust
		 */
		if (flags & OCSP_NOEXPLICIT)
			goto end;

		x = sk_X509_value(chain, sk_X509_num(chain) - 1);
		if (X509_check_trust(x, NID_OCSP_sign, 0) !=
			X509_TRUST_TRUSTED) {
			OCSPerror(OCSP_R_ROOT_CA_NOT_TRUSTED);
			goto end;
		}
		ret = 1;
	}

end:
	if (chain)
		sk_X509_pop_free(chain, X509_free);
	if (bs->certs && certs)
		sk_X509_free(untrusted);
	return ret;
}

static int
ocsp_find_signer(X509 **psigner, OCSP_BASICRESP *bs, STACK_OF(X509) *certs,
    X509_STORE *st, unsigned long flags)
{
	X509 *signer;
	OCSP_RESPID *rid = bs->tbsResponseData->responderId;

	if ((signer = ocsp_find_signer_sk(certs, rid))) {
		*psigner = signer;
		return 2;
	}
	if (!(flags & OCSP_NOINTERN) &&
	    (signer = ocsp_find_signer_sk(bs->certs, rid))) {
		*psigner = signer;
		return 1;
	}
	/* Maybe lookup from store if by subject name */

	*psigner = NULL;
	return 0;
}

static X509 *
ocsp_find_signer_sk(STACK_OF(X509) *certs, OCSP_RESPID *id)
{
	int i;
	unsigned char tmphash[SHA_DIGEST_LENGTH], *keyhash;
	X509 *x;

	/* Easy if lookup by name */
	if (id->type == V_OCSP_RESPID_NAME)
		return X509_find_by_subject(certs, id->value.byName);

	/* Lookup by key hash */

	/* If key hash isn't SHA1 length then forget it */
	if (id->value.byKey->length != SHA_DIGEST_LENGTH)
		return NULL;
	keyhash = id->value.byKey->data;
	/* Calculate hash of each key and compare */
	for (i = 0; i < sk_X509_num(certs); i++) {
		x = sk_X509_value(certs, i);
		X509_pubkey_digest(x, EVP_sha1(), tmphash, NULL);
		if (!memcmp(keyhash, tmphash, SHA_DIGEST_LENGTH))
			return x;
	}
	return NULL;
}

static int
ocsp_check_issuer(OCSP_BASICRESP *bs, STACK_OF(X509) *chain,
    unsigned long flags)
{
	STACK_OF(OCSP_SINGLERESP) *sresp;
	X509 *signer, *sca;
	OCSP_CERTID *caid = NULL;
	int i;

	sresp = bs->tbsResponseData->responses;

	if (sk_X509_num(chain) <= 0) {
		OCSPerror(OCSP_R_NO_CERTIFICATES_IN_CHAIN);
		return -1;
	}

	/* See if the issuer IDs match. */
	i = ocsp_check_ids(sresp, &caid);

	/* If ID mismatch or other error then return */
	if (i <= 0)
		return i;

	signer = sk_X509_value(chain, 0);
	/* Check to see if OCSP responder CA matches request CA */
	if (sk_X509_num(chain) > 1) {
		sca = sk_X509_value(chain, 1);
		i = ocsp_match_issuerid(sca, caid, sresp);
		if (i < 0)
			return i;
		if (i) {
			/* We have a match, if extensions OK then success */
			if (ocsp_check_delegated(signer, flags))
				return 1;
			return 0;
		}
	}

	/* Otherwise check if OCSP request signed directly by request CA */
	return ocsp_match_issuerid(signer, caid, sresp);
}

/* Check the issuer certificate IDs for equality. If there is a mismatch with the same
 * algorithm then there's no point trying to match any certificates against the issuer.
 * If the issuer IDs all match then we just need to check equality against one of them.
 */
static int
ocsp_check_ids(STACK_OF(OCSP_SINGLERESP) *sresp, OCSP_CERTID **ret)
{
	OCSP_CERTID *tmpid, *cid;
	int i, idcount;

	idcount = sk_OCSP_SINGLERESP_num(sresp);
	if (idcount <= 0) {
		OCSPerror(OCSP_R_RESPONSE_CONTAINS_NO_REVOCATION_DATA);
		return -1;
	}

	cid = sk_OCSP_SINGLERESP_value(sresp, 0)->certId;

	*ret = NULL;

	for (i = 1; i < idcount; i++) {
		tmpid = sk_OCSP_SINGLERESP_value(sresp, i)->certId;
		/* Check to see if IDs match */
		if (OCSP_id_issuer_cmp(cid, tmpid)) {
			return 0;
		}
	}

	/* All IDs match: only need to check one ID */
	*ret = cid;
	return 1;
}

static int
ocsp_match_issuerid(X509 *cert, OCSP_CERTID *cid,
    STACK_OF(OCSP_SINGLERESP) *sresp)
{
	/* If only one ID to match then do it */
	if (cid) {
		const EVP_MD *dgst;
		X509_NAME *iname;
		int mdlen;
		unsigned char md[EVP_MAX_MD_SIZE];

		if (!(dgst =
		    EVP_get_digestbyobj(cid->hashAlgorithm->algorithm))) {
			OCSPerror(OCSP_R_UNKNOWN_MESSAGE_DIGEST);
			return -1;
		}

		mdlen = EVP_MD_size(dgst);
		if (mdlen < 0)
			return -1;
		if (cid->issuerNameHash->length != mdlen ||
		    cid->issuerKeyHash->length != mdlen)
			return 0;
		iname = X509_get_subject_name(cert);
		if (!X509_NAME_digest(iname, dgst, md, NULL))
			return -1;
		if (memcmp(md, cid->issuerNameHash->data, mdlen))
			return 0;
		X509_pubkey_digest(cert, dgst, md, NULL);
		if (memcmp(md, cid->issuerKeyHash->data, mdlen))
			return 0;

		return 1;
	} else {
		/* We have to match the whole lot */
		int i, ret;
		OCSP_CERTID *tmpid;

		for (i = 0; i < sk_OCSP_SINGLERESP_num(sresp); i++) {
			tmpid = sk_OCSP_SINGLERESP_value(sresp, i)->certId;
			ret = ocsp_match_issuerid(cert, tmpid, NULL);
			if (ret <= 0)
				return ret;
		}
		return 1;
	}
}

static int
ocsp_check_delegated(X509 *x, int flags)
{
	X509_check_purpose(x, -1, 0);
	if ((x->ex_flags & EXFLAG_XKUSAGE) && (x->ex_xkusage & XKU_OCSP_SIGN))
		return 1;
	OCSPerror(OCSP_R_MISSING_OCSPSIGNING_USAGE);
	return 0;
}

/* Verify an OCSP request. This is fortunately much easier than OCSP
 * response verify. Just find the signers certificate and verify it
 * against a given trust value.
 */
int
OCSP_request_verify(OCSP_REQUEST *req, STACK_OF(X509) *certs, X509_STORE *store,
    unsigned long flags)
{
	X509 *signer;
	X509_NAME *nm;
	GENERAL_NAME *gen;
	int ret;
	X509_STORE_CTX ctx;

	if (!req->optionalSignature) {
		OCSPerror(OCSP_R_REQUEST_NOT_SIGNED);
		return 0;
	}
	gen = req->tbsRequest->requestorName;
	if (!gen || gen->type != GEN_DIRNAME) {
		OCSPerror(OCSP_R_UNSUPPORTED_REQUESTORNAME_TYPE);
		return 0;
	}
	nm = gen->d.directoryName;
	ret = ocsp_req_find_signer(&signer, req, nm, certs, store, flags);
	if (ret <= 0) {
		OCSPerror(OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
		return 0;
	}
	if ((ret == 2) && (flags & OCSP_TRUSTOTHER))
		flags |= OCSP_NOVERIFY;
	if (!(flags & OCSP_NOSIGS)) {
		EVP_PKEY *skey;

		skey = X509_get_pubkey(signer);
		ret = OCSP_REQUEST_verify(req, skey);
		EVP_PKEY_free(skey);
		if (ret <= 0) {
			OCSPerror(OCSP_R_SIGNATURE_FAILURE);
			return 0;
		}
	}
	if (!(flags & OCSP_NOVERIFY)) {
		int init_res;

		if (flags & OCSP_NOCHAIN)
			init_res = X509_STORE_CTX_init(&ctx, store, signer,
			    NULL);
		else
			init_res = X509_STORE_CTX_init(&ctx, store, signer,
			    req->optionalSignature->certs);
		if (!init_res) {
			OCSPerror(ERR_R_X509_LIB);
			return 0;
		}

		if (X509_STORE_CTX_set_purpose(&ctx,
		      X509_PURPOSE_OCSP_HELPER) == 0 ||
		    X509_STORE_CTX_set_trust(&ctx,
		      X509_TRUST_OCSP_REQUEST) == 0) {
			X509_STORE_CTX_cleanup(&ctx);
			return 0;
		}
		ret = X509_verify_cert(&ctx);
		X509_STORE_CTX_cleanup(&ctx);
		if (ret <= 0) {
			ret = X509_STORE_CTX_get_error(&ctx);
			OCSPerror(OCSP_R_CERTIFICATE_VERIFY_ERROR);
			ERR_asprintf_error_data("Verify error:%s",
			    X509_verify_cert_error_string(ret));
			return 0;
		}
	}
	return 1;
}

static int
ocsp_req_find_signer(X509 **psigner, OCSP_REQUEST *req, X509_NAME *nm,
    STACK_OF(X509) *certs, X509_STORE *st, unsigned long flags)
{
	X509 *signer;

	if (!(flags & OCSP_NOINTERN)) {
		signer = X509_find_by_subject(req->optionalSignature->certs, nm);
		if (signer) {
			*psigner = signer;
			return 1;
		}
	}

	signer = X509_find_by_subject(certs, nm);
	if (signer) {
		*psigner = signer;
		return 2;
	}
	return 0;
}
@


1.14
log
@X509_STORE_CTX_set_*() may fail, so check for errors.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp_vfy.c,v 1.13 2016/07/05 00:21:47 beck Exp $ */
d89 1
a89 2
		OCSPerr(OCSP_F_OCSP_BASIC_VERIFY,
		    OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
d103 1
a103 2
			OCSPerr(OCSP_F_OCSP_BASIC_VERIFY,
			    OCSP_R_SIGNATURE_FAILURE);
d117 1
a117 2
					OCSPerr(OCSP_F_OCSP_BASIC_VERIFY,
					    ERR_R_MALLOC_FAILURE);
d126 1
a126 1
			OCSPerr(OCSP_F_OCSP_BASIC_VERIFY, ERR_R_X509_LIB);
d141 1
a141 2
			OCSPerr(OCSP_F_OCSP_BASIC_VERIFY,
			    OCSP_R_CERTIFICATE_VERIFY_ERROR);
d168 1
a168 2
			OCSPerr(OCSP_F_OCSP_BASIC_VERIFY,
			    OCSP_R_ROOT_CA_NOT_TRUSTED);
d243 1
a243 2
		OCSPerr(OCSP_F_OCSP_CHECK_ISSUER,
		    OCSP_R_NO_CERTIFICATES_IN_CHAIN);
d285 1
a285 2
		OCSPerr(OCSP_F_OCSP_CHECK_IDS,
		    OCSP_R_RESPONSE_CONTAINS_NO_REVOCATION_DATA);
d319 1
a319 2
			OCSPerr(OCSP_F_OCSP_MATCH_ISSUERID,
			    OCSP_R_UNKNOWN_MESSAGE_DIGEST);
d360 1
a360 1
	OCSPerr(OCSP_F_OCSP_CHECK_DELEGATED, OCSP_R_MISSING_OCSPSIGNING_USAGE);
d379 1
a379 1
		OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY, OCSP_R_REQUEST_NOT_SIGNED);
d384 1
a384 2
		OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY,
		    OCSP_R_UNSUPPORTED_REQUESTORNAME_TYPE);
d390 1
a390 2
		OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY,
		    OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
d402 1
a402 2
			OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY,
			    OCSP_R_SIGNATURE_FAILURE);
d416 1
a416 1
			OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY, ERR_R_X509_LIB);
d431 1
a431 2
			OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY,
			    OCSP_R_CERTIFICATE_VERIFY_ERROR);
@


1.13
log
@Add several fixes from OpenSSL to make OCSP work with intermediate
certificates provided in the response. - makes our newly added
ocsp regress test pass too..
ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp_vfy.c,v 1.12 2014/07/09 19:08:10 tedu Exp $ */
d133 6
a138 1
		X509_STORE_CTX_set_purpose(&ctx, X509_PURPOSE_OCSP_HELPER);
d431 7
a437 2
		X509_STORE_CTX_set_purpose(&ctx, X509_PURPOSE_OCSP_HELPER);
		X509_STORE_CTX_set_trust(&ctx, X509_TRUST_OCSP_REQUEST);
@


1.12
log
@ocsp_check_ids says "If algoritm mismatch let caller deal with it" before
returning 2. The one and only caller doesn't check for that, so...
Stop returning it.
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: ocsp_vfy.c,v 1.11 2014/06/12 15:49:30 deraadt Exp $ */
d83 1
d112 15
a126 5
		if (flags & OCSP_NOCHAIN)
			init_res = X509_STORE_CTX_init(&ctx, st, signer, NULL);
		else
			init_res = X509_STORE_CTX_init(&ctx, st, signer,
			    bs->certs);
d177 2
d449 5
a453 4
		signer =
		    X509_find_by_subject(req->optionalSignature->certs, nm);
		*psigner = signer;
		return 1;
@


1.11
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a285 5
			/* If algoritm mismatch let caller deal with it */
			if (OBJ_cmp(tmpid->hashAlgorithm->algorithm,
			    cid->hashAlgorithm->algorithm))
				return 2;
			/* Else mismatch */
@


1.10
log
@More KNF.
@
text
@d1 1
a1 1
/* ocsp_vfy.c */
@


1.9
log
@KNF
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d64 1
a64 1
	    STACK_OF(X509) *certs, X509_STORE *st, unsigned long flags);
d67 1
a67 1
	    unsigned long flags);
d70 1
a70 1
	    STACK_OF(OCSP_SINGLERESP) *sresp);
d73 2
a74 2
	    X509_NAME *nm, STACK_OF(X509) *certs, X509_STORE *st,
	    unsigned long flags);
d111 1
a111 1
		if(flags & OCSP_NOCHAIN)
d118 1
a118 1
			OCSPerr(OCSP_F_OCSP_BASIC_VERIFY,ERR_R_X509_LIB);
d134 1
a134 1
		if(flags & OCSP_NOCHECKS) {
d155 1
a155 1
		    X509_TRUST_TRUSTED) {
d414 1
a414 1
			OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY,ERR_R_X509_LIB);
d423 1
a423 1
			ret = X509_STORE_CTX_get_error(&ctx);	
@


1.8
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d63 2
a64 2
static int ocsp_find_signer(X509 **psigner, OCSP_BASICRESP *bs, STACK_OF(X509) *certs,
				X509_STORE *st, unsigned long flags);
d66 2
a67 1
static int ocsp_check_issuer(OCSP_BASICRESP *bs, STACK_OF(X509) *chain, unsigned long flags);
d69 2
a70 1
static int ocsp_match_issuerid(X509 *cert, OCSP_CERTID *cid, STACK_OF(OCSP_SINGLERESP) *sresp);
d72 3
a74 2
static int ocsp_req_find_signer(X509 **psigner, OCSP_REQUEST *req, X509_NAME *nm, STACK_OF(X509) *certs,
				X509_STORE *st, unsigned long flags);
d77 4
a80 4

int OCSP_basic_verify(OCSP_BASICRESP *bs, STACK_OF(X509) *certs,
				X509_STORE *st, unsigned long flags)
	{
d85 1
d87 3
a89 3
	if (!ret)
		{
		OCSPerr(OCSP_F_OCSP_BASIC_VERIFY, OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
d91 1
a91 1
		}
d94 1
a94 2
	if (!(flags & OCSP_NOSIGS))
		{
d96 1
d98 1
a98 2
		if (skey)
			{
d101 4
a104 4
			}
		if(!skey || ret <= 0)
			{
			OCSPerr(OCSP_F_OCSP_BASIC_VERIFY, OCSP_R_SIGNATURE_FAILURE);
a105 1
			}
d107 2
a108 2
	if (!(flags & OCSP_NOVERIFY))
		{
d110 1
d114 3
a116 3
			init_res = X509_STORE_CTX_init(&ctx, st, signer, bs->certs);
		if(!init_res)
			{
d120 1
a120 1
			}
d126 1
a126 2
                if (ret <= 0)
			{
d128 2
a129 1
			OCSPerr(OCSP_F_OCSP_BASIC_VERIFY,OCSP_R_CERTIFICATE_VERIFY_ERROR);
d131 4
a134 5
					X509_verify_cert_error_string(i));
                        goto end;
                	}
		if(flags & OCSP_NOCHECKS)
			{
d137 1
a137 1
			}
d144 2
a145 1
		if (ret != 0) goto end;
d150 2
a151 1
		if(flags & OCSP_NOEXPLICIT) goto end;
d154 4
a157 3
		if(X509_check_trust(x, NID_OCSP_sign, 0) != X509_TRUST_TRUSTED)
			{
			OCSPerr(OCSP_F_OCSP_BASIC_VERIFY,OCSP_R_ROOT_CA_NOT_TRUSTED);
d159 1
a159 1
			}
d161 1
a161 2
		}

d163 3
a165 3

	end:
	if(chain) sk_X509_pop_free(chain, X509_free);
d167 1
a167 2
	}

d169 4
a172 3
static int ocsp_find_signer(X509 **psigner, OCSP_BASICRESP *bs, STACK_OF(X509) *certs,
				X509_STORE *st, unsigned long flags)
	{
d175 2
a176 2
	if ((signer = ocsp_find_signer_sk(certs, rid)))
		{
d179 3
a181 4
		}
	if(!(flags & OCSP_NOINTERN) &&
	    (signer = ocsp_find_signer_sk(bs->certs, rid)))
		{
d184 1
a184 1
		}
d189 1
a189 2
	}

d191 3
a193 2
static X509 *ocsp_find_signer_sk(STACK_OF(X509) *certs, OCSP_RESPID *id)
	{
d205 2
a206 1
	if (id->value.byKey->length != SHA_DIGEST_LENGTH) return NULL;
d209 1
a209 2
	for (i = 0; i < sk_X509_num(certs); i++)
		{
d212 1
a212 1
		if(!memcmp(keyhash, tmphash, SHA_DIGEST_LENGTH))
d214 1
a214 1
		}
d216 1
a216 1
	}
d218 4
a221 3

static int ocsp_check_issuer(OCSP_BASICRESP *bs, STACK_OF(X509) *chain, unsigned long flags)
	{
d226 1
d229 3
a231 3
	if (sk_X509_num(chain) <= 0)
		{
		OCSPerr(OCSP_F_OCSP_CHECK_ISSUER, OCSP_R_NO_CERTIFICATES_IN_CHAIN);
d233 1
a233 1
		}
d239 2
a240 1
	if (i <= 0) return i;
d244 1
a244 2
	if (sk_X509_num(chain) > 1)
		{
d247 3
a249 3
		if (i < 0) return i;
		if (i)
			{
d251 2
a252 1
			if (ocsp_check_delegated(signer, flags)) return 1;
a253 1
			}
d255 1
d259 1
a259 2
	}

d265 3
a267 3
	
static int ocsp_check_ids(STACK_OF(OCSP_SINGLERESP) *sresp, OCSP_CERTID **ret)
	{
d272 3
a274 3
	if (idcount <= 0)
		{
		OCSPerr(OCSP_F_OCSP_CHECK_IDS, OCSP_R_RESPONSE_CONTAINS_NO_REVOCATION_DATA);
d276 1
a276 1
		}
d282 1
a282 2
	for (i = 1; i < idcount; i++)
		{
d285 1
a285 2
		if (OCSP_id_issuer_cmp(cid, tmpid))
			{
d288 2
a289 2
					cid->hashAlgorithm->algorithm))
					return 2;
a291 1
			}
d293 1
d298 1
a298 1
	}
d300 4
a303 4

static int ocsp_match_issuerid(X509 *cert, OCSP_CERTID *cid,
			STACK_OF(OCSP_SINGLERESP) *sresp)
	{
d305 1
a305 2
	if(cid)
		{
d310 5
a314 3
		if (!(dgst = EVP_get_digestbyobj(cid->hashAlgorithm->algorithm)))
			{
			OCSPerr(OCSP_F_OCSP_MATCH_ISSUERID, OCSP_R_UNKNOWN_MESSAGE_DIGEST);
d316 1
a316 1
			}
d320 3
a322 3
		    return -1;
		if ((cid->issuerNameHash->length != mdlen) ||
		   (cid->issuerKeyHash->length != mdlen))
d334 1
a334 4

		}
	else
		{
d338 2
a339 2
		for (i = 0; i < sk_OCSP_SINGLERESP_num(sresp); i++)
			{
d342 3
a344 2
			if (ret <= 0) return ret;
			}
a345 2
		}
			
d347 1
d349 3
a351 2
static int ocsp_check_delegated(X509 *x, int flags)
	{
d353 1
a353 2
	if ((x->ex_flags & EXFLAG_XKUSAGE) &&
	    (x->ex_xkusage & XKU_OCSP_SIGN))
d357 1
a357 1
	}
d363 4
a366 3

int OCSP_request_verify(OCSP_REQUEST *req, STACK_OF(X509) *certs, X509_STORE *store, unsigned long flags)
        {
d372 2
a373 2
	if (!req->optionalSignature) 
		{
d376 1
a376 1
		}
d378 3
a380 3
	if (!gen || gen->type != GEN_DIRNAME)
		{
		OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY, OCSP_R_UNSUPPORTED_REQUESTORNAME_TYPE);
d382 1
a382 1
		}
d385 3
a387 3
	if (ret <= 0)
		{
		OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY, OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
d389 1
a389 1
		}
d392 1
a392 2
	if (!(flags & OCSP_NOSIGS))
		{
d394 1
d398 3
a400 3
		if(ret <= 0)
			{
			OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY, OCSP_R_SIGNATURE_FAILURE);
a401 1
			}
d403 2
a404 2
	if (!(flags & OCSP_NOVERIFY))
		{
d406 4
a409 2
		if(flags & OCSP_NOCHAIN)
			init_res = X509_STORE_CTX_init(&ctx, store, signer, NULL);
d412 2
a413 3
					req->optionalSignature->certs);
		if(!init_res)
			{
d416 1
a416 1
			}
d422 1
a422 2
                if (ret <= 0)
			{
d424 2
a425 1
			OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY,OCSP_R_CERTIFICATE_VERIFY_ERROR);
d427 2
a428 3
					X509_verify_cert_error_string(ret));
                        return 0;
                	}
d430 1
d432 1
a432 1
        }
d434 4
a437 3
static int ocsp_req_find_signer(X509 **psigner, OCSP_REQUEST *req, X509_NAME *nm, STACK_OF(X509) *certs,
				X509_STORE *st, unsigned long flags)
	{
d439 4
a442 3
	if(!(flags & OCSP_NOINTERN))
		{
		signer = X509_find_by_subject(req->optionalSignature->certs, nm);
d445 1
a445 1
		}
d448 1
a448 2
	if (signer)
		{
d451 1
a451 1
		}
d453 1
a453 1
	}
@


1.7
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d125 1
a125 1
			i = X509_STORE_CTX_get_error(&ctx);	
d127 1
a127 1
			ERR_add_error_data(2, "Verify error:",
d424 1
a424 1
			ERR_add_error_data(2, "Verify error:",
@


1.6
log
@cherry pick bugfixes for http://www.openssl.org/news/secadv_20130205.txt
from the openssl git (changes between openssl 1.0.1c and 1.0.1d).
ok djm@@
@
text
@d114 1
@


1.5
log
@resolve conflicts, fix local changes
@
text
@d94 6
a99 3
		ret = OCSP_BASICRESP_verify(bs, skey, 0);
		EVP_PKEY_free(skey);
		if(ret <= 0)
@


1.4
log
@resolve conflicts
@
text
@d311 2
d321 1
a321 1
		X509_pubkey_digest(cert, EVP_sha1(), md, NULL);
@


1.3
log
@resolve conflicts
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (shenson@@bigfoot.com) for the OpenSSL
@


1.2
log
@merge 0.9.7d
@
text
@d370 1
a370 1
	if (gen->type != GEN_DIRNAME)
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d6 1
a6 1
 * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
d275 1
a275 1
		tmpid = sk_OCSP_SINGLERESP_value(sresp, 0)->certId;
d333 1
a333 1
			tmpid = sk_OCSP_SINGLERESP_value(sresp, 0)->certId;
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import openssl-0.9.7d
@
text
@d6 1
a6 1
 * Copyright (c) 2000-2004 The OpenSSL Project.  All rights reserved.
d275 1
a275 1
		tmpid = sk_OCSP_SINGLERESP_value(sresp, i)->certId;
d333 1
a333 1
			tmpid = sk_OCSP_SINGLERESP_value(sresp, i)->certId;
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d370 1
a370 1
	if (!gen || gen->type != GEN_DIRNAME)
@


1.1.1.4
log
@import openssl-0.9.8j
@
text
@d2 1
a2 1
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
@


1.1.1.5
log
@import OpenSSL-1.0.0a
@
text
@a310 2
		if (mdlen < 0)
		    return -1;
d319 1
a319 1
		X509_pubkey_digest(cert, dgst, md, NULL);
@


1.1.1.6
log
@Import OpenSSL 1.0.1g
@
text
@d94 3
a96 6
		if (skey)
			{
			ret = OCSP_BASICRESP_verify(bs, skey, 0);
			EVP_PKEY_free(skey);
			}
		if(!skey || ret <= 0)
a110 1
			ret = -1;
@


