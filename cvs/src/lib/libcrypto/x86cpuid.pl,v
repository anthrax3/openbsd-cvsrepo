head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.2
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8;
locks; strict;
comment	@# @;


1.8
date	2016.11.04.17.30.30;	author miod;	state Exp;
branches;
next	1.7;
commitid	uVQFi30uotTYOUA9;

1.7
date	2016.11.04.13.53.06;	author miod;	state Exp;
branches;
next	1.6;
commitid	tnTHlvVq4EeqfXS3;

1.6
date	2014.06.20.15.49.42;	author miod;	state Exp;
branches;
next	1.5;
commitid	ri8wo2omZ8MFCA8h;

1.5
date	2014.06.02.15.08.37;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	tWDKJg0nrCJLQhsu;

1.4
date	2014.04.22.21.52.21;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.17.18.49.35;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2014.04.17.18.16.45;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.06.12.15.39;	author djm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.10.01.22.54.02;	author djm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2012.10.13.21.23.33;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.04.13.15.16.32;	author miod;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Replace all uses of magic numbers when operating on OPENSSL_ia32_P[] by
meaningful constants in a private header file, so that reviewers can actually
get a chance to figure out what the code is attempting to do without knowing
all cpuid bits.

While there, turn it from an array of two 32-bit ints into a properly aligned
64-bit int.

Use of OPENSSL_ia32_P is now restricted to the assembler parts. C code will
now always use OPENSSL_cpu_caps() and check for the proper bits in the
whole 64-bit word it returns.

i386 tests and ok jsing@@
@
text
@#!/usr/bin/env perl

$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
push(@@INC, "${dir}perlasm", "perlasm");
require "x86asm.pl";

&asm_init($ARGV[0],"x86cpuid");

for (@@ARGV) { $sse2=1 if (/-DOPENSSL_IA32_SSE2/); }

&function_begin("OPENSSL_ia32_cpuid");
	&xor	("edx","edx");
	&pushf	();
	&pop	("eax");
	&mov	("ecx","eax");
	&xor	("eax",1<<21);
	&push	("eax");
	&popf	();
	&pushf	();
	&pop	("eax");
	&xor	("ecx","eax");
	&xor	("eax","eax");
	&bt	("ecx",21);
	&jnc	(&label("nocpuid"));
	&cpuid	();
	&mov	("edi","eax");		# max value for standard query level

	&xor	("eax","eax");
	&cmp	("ebx",0x756e6547);	# "Genu"
	&setne	(&LB("eax"));
	&mov	("ebp","eax");
	&cmp	("edx",0x49656e69);	# "ineI"
	&setne	(&LB("eax"));
	&or	("ebp","eax");
	&cmp	("ecx",0x6c65746e);	# "ntel"
	&setne	(&LB("eax"));
	&or	("ebp","eax");		# 0 indicates Intel CPU
	&jz	(&label("intel"));

	&cmp	("ebx",0x68747541);	# "Auth"
	&setne	(&LB("eax"));
	&mov	("esi","eax");
	&cmp	("edx",0x69746E65);	# "enti"
	&setne	(&LB("eax"));
	&or	("esi","eax");
	&cmp	("ecx",0x444D4163);	# "cAMD"
	&setne	(&LB("eax"));
	&or	("esi","eax");		# 0 indicates AMD CPU
	&jnz	(&label("intel"));

	# AMD specific
	&mov	("eax",0x80000000);
	&cpuid	();
	&cmp	("eax",0x80000001);
	&jb	(&label("intel"));
	&mov	("esi","eax");
	&mov	("eax",0x80000001);
	&cpuid	();
	&and	("ecx","\$IA32CAP_MASK1_AMD_XOP");	# isolate AMD XOP bit
	&or	("ecx",1);		# make sure ecx is not zero
	&mov	("ebp","ecx");

	&cmp	("esi",0x80000008);
	&jb	(&label("intel"));

	&mov	("eax",0x80000008);
	&cpuid	();
	&movz	("esi",&LB("ecx"));	# number of cores - 1
	&inc	("esi");		# number of cores

	&mov	("eax",1);
	&xor	("ecx","ecx");
	&cpuid	();
	&bt	("edx","\$IA32CAP_BIT0_HT");
	&jnc	(&label("generic"));
	&shr	("ebx",16);
	&and	("ebx",0xff);
	&cmp	("ebx","esi");
	&ja	(&label("generic"));
	&xor	("edx","\$IA32CAP_MASK0_HT");	# clear hyper-threading bit
	&jmp	(&label("generic"));
	
&set_label("intel");
	&cmp	("edi",4);
	&mov	("edi",-1);
	&jb	(&label("nocacheinfo"));

	&mov	("eax",4);
	&mov	("ecx",0);		# query L1D
	&cpuid	();
	&mov	("edi","eax");
	&shr	("edi",14);
	&and	("edi",0xfff);		# number of cores -1 per L1D

&set_label("nocacheinfo");
	&mov	("eax",1);
	&xor	("ecx","ecx");
	&cpuid	();
	# force reserved bits to 0.
	&and	("edx","\$~(IA32CAP_MASK0_INTELP4 | IA32CAP_MASK0_INTEL)");
	&cmp	("ebp",0);
	&jne	(&label("notintel"));
	# set reserved bit#30 on Intel CPUs
	&or	("edx","\$IA32CAP_MASK0_INTEL");
	&and	(&HB("eax"),15);	# family ID
	&cmp	(&HB("eax"),15);	# P4?
	&jne	(&label("notintel"));
	# set reserved bit#20 to engage RC4_CHAR
	&or	("edx","\$IA32CAP_MASK0_INTELP4");
&set_label("notintel");
	&bt	("edx","\$IA32CAP_BIT0_HT");	# test hyper-threading bit
	&jnc	(&label("generic"));
	&xor	("edx","\$IA32CAP_MASK0_HT");
	&cmp	("edi",0);
	&je	(&label("generic"));

	&or	("edx","\$IA32CAP_MASK0_HT");
	&shr	("ebx",16);
	&cmp	(&LB("ebx"),1);		# see if cache is shared
	&ja	(&label("generic"));
	&xor	("edx","\$IA32CAP_MASK0_HT"); # clear hyper-threading bit if not

&set_label("generic");
	&and	("ebp","\$IA32CAP_MASK1_AMD_XOP");	# isolate AMD XOP flag
	# force reserved bits to 0.
	&and	("ecx","\$~IA32CAP_MASK1_AMD_XOP");
	&mov	("esi","edx");
	&or	("ebp","ecx");		# merge AMD XOP flag

	&bt	("ecx","\$IA32CAP_BIT1_OSXSAVE");	# check OSXSAVE bit
	&jnc	(&label("clear_avx"));
	&xor	("ecx","ecx");
	&data_byte(0x0f,0x01,0xd0);	# xgetbv
	&and	("eax",6);
	&cmp	("eax",6);
	&je	(&label("done"));
	&cmp	("eax",2);
	&je	(&label("clear_avx"));
&set_label("clear_xmm");
	# clear AESNI and PCLMULQDQ bits.
	&and	("ebp","\$~(IA32CAP_MASK1_AESNI | IA32CAP_MASK1_PCLMUL)");
	# clear FXSR.
	&and	("esi","\$~IA32CAP_MASK0_FXSR");
&set_label("clear_avx");
	# clear AVX, FMA3 and AMD XOP bits.
	&and	("ebp","\$~(IA32CAP_MASK1_AVX | IA32CAP_MASK1_FMA3 | IA32CAP_MASK1_AMD_XOP)");
&set_label("done");
	&mov	("eax","esi");
	&mov	("edx","ebp");
&set_label("nocpuid");
&function_end("OPENSSL_ia32_cpuid");

&external_label("OPENSSL_ia32cap_P");

&function_begin_B("OPENSSL_wipe_cpu","");
	&xor	("eax","eax");
	&xor	("edx","edx");
	&picmeup("ecx","OPENSSL_ia32cap_P");
	&mov	("ecx",&DWP(0,"ecx"));
	&bt	(&DWP(0,"ecx"),"\$IA32CAP_BIT0_FPU");
	&jnc	(&label("no_x87"));
	if ($sse2) {
		# Check SSE2 and FXSR bits.
		&and	("ecx", "\$(IA32CAP_MASK0_FXSR | IA32CAP_MASK0_SSE2)");
		&cmp	("ecx", "\$(IA32CAP_MASK0_FXSR | IA32CAP_MASK0_SSE2)");
		&jne	(&label("no_sse2"));
		&pxor	("xmm0","xmm0");
		&pxor	("xmm1","xmm1");
		&pxor	("xmm2","xmm2");
		&pxor	("xmm3","xmm3");
		&pxor	("xmm4","xmm4");
		&pxor	("xmm5","xmm5");
		&pxor	("xmm6","xmm6");
		&pxor	("xmm7","xmm7");
	&set_label("no_sse2");
	}
	# just a bunch of fldz to zap the fp/mm bank followed by finit...
	&data_word(0xeed9eed9,0xeed9eed9,0xeed9eed9,0xeed9eed9,0x90e3db9b);
&set_label("no_x87");
	&lea	("eax",&DWP(4,"esp"));
	&ret	();
&function_end_B("OPENSSL_wipe_cpu");

&function_begin_B("OPENSSL_atomic_add");
	&mov	("edx",&DWP(4,"esp"));	# fetch the pointer, 1st arg
	&mov	("ecx",&DWP(8,"esp"));	# fetch the increment, 2nd arg
	&push	("ebx");
	&nop	();
	&mov	("eax",&DWP(0,"edx"));
&set_label("spin");
	&lea	("ebx",&DWP(0,"eax","ecx"));
	&nop	();
	&data_word(0x1ab10ff0);	# lock;	cmpxchg	%ebx,(%edx)	# %eax is envolved and is always reloaded
	&jne	(&label("spin"));
	&mov	("eax","ebx");	# OpenSSL expects the new value
	&pop	("ebx");
	&ret	();
&function_end_B("OPENSSL_atomic_add");

&initseg("OPENSSL_cpuid_setup");

&asm_finish();
@


1.7
log
@In OPENSSL_wipe_cpu() on i386, which noone uses anyway, check the proper
flag for the presence of a FPU before deciding to wipe the fpu registers.

ok jsing@@
@
text
@d59 4
a62 2
	&or	("ebp","ecx");
	&and	("ebp",1<<11|1);	# isolate XOP bit
d74 1
a74 1
	&bt	("edx",28);
d80 1
a80 1
	&and	("edx",0xefffffff);	# clear hyper-threading bit
d99 2
a100 1
	&and	("edx",0xbfefffff);	# force reserved bits #20, #30 to 0
d103 3
a105 2
	&or	("edx",1<<30);		# set reserved bit#30 on Intel CPUs
	&and	(&HB("eax"),15);	# familiy ID
d108 2
a109 1
	&or	("edx",1<<20);		# set reserved bit#20 to engage RC4_CHAR
d111 1
a111 1
	&bt	("edx",28);		# test hyper-threading bit
d113 1
a113 1
	&and	("edx",0xefffffff);
d117 1
a117 1
	&or	("edx",0x10000000);
d119 1
a119 1
	&cmp	(&LB("ebx"),1);
d121 1
a121 1
	&and	("edx",0xefffffff);	# clear hyper-threading bit if not
d124 3
a126 2
	&and	("ebp",1<<11);		# isolate AMD XOP flag
	&and	("ecx",0xfffff7ff);	# force 11th bit to 0
d130 1
a130 1
	&bt	("ecx",27);		# check OSXSAVE bit
d140 4
a143 2
	&and	("ebp",0xfdfffffd);	# clear AESNI and PCLMULQDQ bits
	&and	("esi",0xfeffffff);	# clear FXSR
d145 2
a146 1
	&and	("ebp",0xefffe7ff);	# clear AVX, FMA and AMD XOP bits
d155 1
a155 1
&function_begin_B("OPENSSL_wipe_cpu","EXTRN\t_OPENSSL_ia32cap_P:DWORD");
d160 1
a160 1
	&bt	(&DWP(0,"ecx"),0);
d163 3
a165 2
		&and	("ecx",1<<26|1<<24);	# check SSE2 and FXSR bits
		&cmp	("ecx",1<<26|1<<24);
@


1.6
log
@Remove OPENSSL_instrument_halt and OPENSSL_far_spin, which both might
have been used under DJGPP in the previous century (if at all).
@
text
@d151 1
a151 1
	&bt	(&DWP(0,"ecx"),1);
@


1.5
log
@A few months back there was a big community fuss regarding direct-use
of the intel RDRAND instruction.  Consensus was RDRAND should probably
only be used as an additional source of entropy in a mixer.

Guess which library bends over backwards to provide easy access to
RDRAND?  Yep.  Guess which applications are using this support?  Not
even one... but still, this is being placed as a trap for someone.

Send this support straight to the abyss.
ok kettenis
@
text
@a145 70
# This works in Ring 0 only [read DJGPP+MS-DOS+privileged DPMI host],
# but it's safe to call it on any [supported] 32-bit platform...
# Just check for [non-]zero return value...
&function_begin_B("OPENSSL_instrument_halt","EXTRN\t_OPENSSL_ia32cap_P:DWORD");
	&picmeup("ecx","OPENSSL_ia32cap_P");
	&bt	(&DWP(0,"ecx"),4);
	&jnc	(&label("nohalt"));	# no TSC

	&data_word(0x9058900e);		# push %cs; pop %eax
	&and	("eax",3);
	&jnz	(&label("nohalt"));	# not enough privileges

	&pushf	();
	&pop	("eax");
	&bt	("eax",9);
	&jnc	(&label("nohalt"));	# interrupts are disabled

	&rdtsc	();
	&push	("edx");
	&push	("eax");
	&halt	();
	&rdtsc	();

	&sub	("eax",&DWP(0,"esp"));
	&sbb	("edx",&DWP(4,"esp"));
	&add	("esp",8);
	&ret	();

&set_label("nohalt");
	&xor	("eax","eax");
	&xor	("edx","edx");
	&ret	();
&function_end_B("OPENSSL_instrument_halt");

# Essentially there is only one use for this function. Under DJGPP:
#
#	#include <go32.h>
#	...
#	i=OPENSSL_far_spin(_dos_ds,0x46c);
#	...
# to obtain the number of spins till closest timer interrupt.

&function_begin_B("OPENSSL_far_spin");
	&pushf	();
	&pop	("eax")
	&bt	("eax",9);
	&jnc	(&label("nospin"));	# interrupts are disabled

	&mov	("eax",&DWP(4,"esp"));
	&mov	("ecx",&DWP(8,"esp"));
	&data_word (0x90d88e1e);	# push %ds, mov %eax,%ds
	&xor	("eax","eax");
	&mov	("edx",&DWP(0,"ecx"));
	&jmp	(&label("spin"));

	&align	(16);
&set_label("spin");
	&inc	("eax");
	&cmp	("edx",&DWP(0,"ecx"));
	&je	(&label("spin"));

	&data_word (0x1f909090);	# pop	%ds
	&ret	();

&set_label("nospin");
	&xor	("eax","eax");
	&xor	("edx","edx");
	&ret	();
&function_end_B("OPENSSL_far_spin");

@


1.4
log
@So it turns out that libcrypto on i386 platforms, unconditionaly compiles this
little gem called OPENSSL_indirect_call(), supposedly to be ``handy under
Win32''.

In my view, this is a free-win ROP entry point. Why try and return to libc
when you can return to libcrypto with an easy to use interface?

Better not give that much attack surface, and remove this undocumented
entry point.

ok beck@@ tedu@@
@
text
@a259 12
&function_begin_B("OPENSSL_ia32_rdrand");
	&mov	("ecx",8);
&set_label("loop");
	&rdrand	("eax");
	&jc	(&label("break"));
	&loop	(&label("loop"));
&set_label("break");
	&cmp	("eax",0);
	&cmove	("eax","ecx");
	&ret	();
&function_end_B("OPENSSL_ia32_rdrand");

@


1.3
log
@Remove oh-so-important-from-a-security-pov OpenSSL_rtdsc() function.
@
text
@a259 39
# This function can become handy under Win32 in situations when
# we don't know which calling convention, __stdcall or __cdecl(*),
# indirect callee is using. In C it can be deployed as
#
#ifdef OPENSSL_CPUID_OBJ
#	type OPENSSL_indirect_call(void *f,...);
#	...
#	OPENSSL_indirect_call(func,[up to $max arguments]);
#endif
#
# (*)	it's designed to work even for __fastcall if number of
#	arguments is 1 or 2!
&function_begin_B("OPENSSL_indirect_call");
	{
	my ($max,$i)=(7,);	# $max has to be chosen as 4*n-1
				# in order to preserve eventual
				# stack alignment
	&push	("ebp");
	&mov	("ebp","esp");
	&sub	("esp",$max*4);
	&mov	("ecx",&DWP(12,"ebp"));
	&mov	(&DWP(0,"esp"),"ecx");
	&mov	("edx",&DWP(16,"ebp"));
	&mov	(&DWP(4,"esp"),"edx");
	for($i=2;$i<$max;$i++)
		{
		# Some copies will be redundant/bogus...
		&mov	("eax",&DWP(12+$i*4,"ebp"));
		&mov	(&DWP(0+$i*4,"esp"),"eax");
		}
	&call_ptr	(&DWP(8,"ebp"));# make the call...
	&mov	("esp","ebp");	# ... and just restore the stack pointer
				# without paying attention to what we called,
				# (__cdecl *func) or (__stdcall *one).
	&pop	("ebp");
	&ret	();
	}
&function_end_B("OPENSSL_indirect_call");

@


1.2
log
@Ok, there was a need for OPENSSL_cleanse() instead of bzero() to prevent
supposedly smart compilers from optimizing memory cleanups away. Understood.

Ok, in case of an hypothetically super smart compiler, OPENSSL_cleanse() had
to be convoluted enough for the compiler not to recognize that this was
actually bzero() in disguise. Understood.

But then why there had been optimized assembler versions of OPENSSL_cleanse()
is beyond me. Did someone not trust the C obfuscation?
@
text
@a145 11
&function_begin_B("OPENSSL_rdtsc","EXTRN\t_OPENSSL_ia32cap_P:DWORD");
	&xor	("eax","eax");
	&xor	("edx","edx");
	&picmeup("ecx","OPENSSL_ia32cap_P");
	&bt	(&DWP(0,"ecx"),4);
	&jnc	(&label("notsc"));
	&rdtsc	();
&set_label("notsc");
	&ret	();
&function_end_B("OPENSSL_rdtsc");

@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
push(@@INC,"perlasm");
d22 1
d24 1
a24 2
	&jnc	(&label("done"));
	&xor	("eax","eax");
d26 2
d30 1
a30 1
	&data_byte(0x0f,0x95,0xc0);	#&setne	(&LB("eax"));
d33 1
a33 1
	&data_byte(0x0f,0x95,0xc0);	#&setne	(&LB("eax"));
d36 58
a93 2
	&data_byte(0x0f,0x95,0xc0);	#&setne	(&LB("eax"));
	&or	("ebp","eax");
d95 1
d97 1
d99 7
a105 6
	&jne	(&label("notP4"));
	&and	("eax",15<<8);		# familiy ID
	&cmp	("eax",15<<8);		# P4?
	&jne	(&label("notP4"));
	&or	("edx",1<<20);		# use reserved bit to engage RC4_CHAR
&set_label("notP4");
d107 6
a112 1
	&jnc	(&label("done"));
d114 2
a115 3
	&and	("ebx",0xff);
	&cmp	("ebx",1);		# see if cache is shared(*)
	&ja	(&label("done"));
d117 21
d139 3
a141 2
	&mov	("eax","edx");
	&mov	("edx","ecx");
a142 2
# (*)	on Core2 this value is set to 2 denoting the fact that L2
#	cache is shared between cores.
d170 1
a170 1
	&pop	("eax")
d235 3
a237 2
		&bt	(&DWP(0,"ecx"),26);
		&jnc	(&label("no_sse2"));
d285 1
a285 1
	my $i,$max=7;		# $max has to be chosen as 4*n-1
d309 12
@


1.1.1.1
log
@import of OpenSSL 0.9.8h
@
text
@@


1.1.1.2
log
@import OpenSSL-1.0.0a
@
text
@d3 1
a3 2
$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
push(@@INC, "${dir}perlasm", "perlasm");
a24 2
	&mov	("edi","eax");		# max value for standard query level

d27 1
a27 1
	&setne	(&LB("eax"));
d30 1
a30 1
	&setne	(&LB("eax"));
d33 2
a34 50
	&setne	(&LB("eax"));
	&or	("ebp","eax");		# 0 indicates Intel CPU
	&jz	(&label("intel"));

	&cmp	("ebx",0x68747541);	# "Auth"
	&setne	(&LB("eax"));
	&mov	("esi","eax");
	&cmp	("edx",0x69746E65);	# "enti"
	&setne	(&LB("eax"));
	&or	("esi","eax");
	&cmp	("ecx",0x444D4163);	# "cAMD"
	&setne	(&LB("eax"));
	&or	("esi","eax");		# 0 indicates AMD CPU
	&jnz	(&label("intel"));

	# AMD specific
	&mov	("eax",0x80000000);
	&cpuid	();
	&cmp	("eax",0x80000008);
	&jb	(&label("intel"));

	&mov	("eax",0x80000008);
	&cpuid	();
	&movz	("esi",&LB("ecx"));	# number of cores - 1
	&inc	("esi");		# number of cores

	&mov	("eax",1);
	&cpuid	();
	&bt	("edx",28);
	&jnc	(&label("done"));
	&shr	("ebx",16);
	&and	("ebx",0xff);
	&cmp	("ebx","esi");
	&ja	(&label("done"));
	&and	("edx",0xefffffff);	# clear hyper-threading bit
	&jmp	(&label("done"));
	
&set_label("intel");
	&cmp	("edi",4);
	&mov	("edi",-1);
	&jb	(&label("nocacheinfo"));

	&mov	("eax",4);
	&mov	("ecx",0);		# query L1D
	&cpuid	();
	&mov	("edi","eax");
	&shr	("edi",14);
	&and	("edi",0xfff);		# number of cores -1 per L1D

&set_label("nocacheinfo");
d39 2
a40 2
	&and	(&HB("eax"),15);	# familiy ID
	&cmp	(&HB("eax"),15);	# P4?
a45 5
	&and	("edx",0xefffffff);
	&cmp	("edi",0);
	&je	(&label("done"));

	&or	("edx",0x10000000);
d47 2
a48 1
	&cmp	(&LB("ebx"),1);
d55 2
a221 34

&function_begin_B("OPENSSL_cleanse");
	&mov	("edx",&wparam(0));
	&mov	("ecx",&wparam(1));
	&xor	("eax","eax");
	&cmp	("ecx",7);
	&jae	(&label("lot"));
	&cmp	("ecx",0);
	&je	(&label("ret"));
&set_label("little");
	&mov	(&BP(0,"edx"),"al");
	&sub	("ecx",1);
	&lea	("edx",&DWP(1,"edx"));
	&jnz	(&label("little"));
&set_label("ret");
	&ret	();

&set_label("lot",16);
	&test	("edx",3);
	&jz	(&label("aligned"));
	&mov	(&BP(0,"edx"),"al");
	&lea	("ecx",&DWP(-1,"ecx"));
	&lea	("edx",&DWP(1,"edx"));
	&jmp	(&label("lot"));
&set_label("aligned");
	&mov	(&DWP(0,"edx"),"eax");
	&lea	("ecx",&DWP(-4,"ecx"));
	&test	("ecx",-4);
	&lea	("edx",&DWP(4,"edx"));
	&jnz	(&label("aligned"));
	&cmp	("ecx",0);
	&jne	(&label("little"));
	&ret	();
&function_end_B("OPENSSL_cleanse");
@


1.1.1.3
log
@import OpenSSL-1.0.1c
@
text
@d22 2
a24 2
	&bt	("ecx",21);
	&jnc	(&label("nocpuid"));
d54 1
a54 8
	&cmp	("eax",0x80000001);
	&jb	(&label("intel"));
	&mov	("esi","eax");
	&mov	("eax",0x80000001);
	&cpuid	();
	&or	("ebp","ecx");
	&and	("ebp",1<<11|1);	# isolate XOP bit
	&cmp	("esi",0x80000008);
d65 1
a65 1
	&jnc	(&label("generic"));
d69 1
a69 1
	&ja	(&label("generic"));
d71 1
a71 1
	&jmp	(&label("generic"));
a87 1
	&and	("edx",0xbfefffff);	# force reserved bits #20, #30 to 0
d89 1
a89 2
	&jne	(&label("notintel"));
	&or	("edx",1<<30);		# set reserved bit#30 on Intel CPUs
d92 3
a94 3
	&jne	(&label("notintel"));
	&or	("edx",1<<20);		# set reserved bit#20 to engage RC4_CHAR
&set_label("notintel");
d96 1
a96 1
	&jnc	(&label("generic"));
d99 1
a99 1
	&je	(&label("generic"));
d104 1
a104 1
	&ja	(&label("generic"));
a105 21

&set_label("generic");
	&and	("ebp",1<<11);		# isolate AMD XOP flag
	&and	("ecx",0xfffff7ff);	# force 11th bit to 0
	&mov	("esi","edx");
	&or	("ebp","ecx");		# merge AMD XOP flag

	&bt	("ecx",27);		# check OSXSAVE bit
	&jnc	(&label("clear_avx"));
	&xor	("ecx","ecx");
	&data_byte(0x0f,0x01,0xd0);	# xgetbv
	&and	("eax",6);
	&cmp	("eax",6);
	&je	(&label("done"));
	&cmp	("eax",2);
	&je	(&label("clear_avx"));
&set_label("clear_xmm");
	&and	("ebp",0xfdfffffd);	# clear AESNI and PCLMULQDQ bits
	&and	("esi",0xfeffffff);	# clear FXSR
&set_label("clear_avx");
	&and	("ebp",0xefffe7ff);	# clear AVX, FMA and AMD XOP bits
d107 2
a108 3
	&mov	("eax","esi");
	&mov	("edx","ebp");
&set_label("nocpuid");
d202 2
a203 3
		&and	("ecx",1<<26|1<<24);	# check SSE2 and FXSR bits
		&cmp	("ecx",1<<26|1<<24);
		&jne	(&label("no_sse2"));
a308 12

&function_begin_B("OPENSSL_ia32_rdrand");
	&mov	("ecx",8);
&set_label("loop");
	&rdrand	("eax");
	&jc	(&label("break"));
	&loop	(&label("loop"));
&set_label("break");
	&cmp	("eax",0);
	&cmove	("eax","ecx");
	&ret	();
&function_end_B("OPENSSL_ia32_rdrand");
@


1.1.1.4
log
@Import OpenSSL 1.0.1g
@
text
@a69 1
	&xor	("ecx","ecx");
a93 1
	&xor	("ecx","ecx");
d168 1
a168 1
	&pop	("eax");
d283 1
a283 1
	my ($max,$i)=(7,);	# $max has to be chosen as 4*n-1
@


