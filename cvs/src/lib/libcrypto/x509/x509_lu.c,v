head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.4
	OPENBSD_6_1_BASE:1.23;
locks; strict;
comment	@ * @;


1.23
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.22;
commitid	kT0fLt3r4lroFJra;

1.22
date	2016.11.13.08.47.54;	author miod;	state Exp;
branches;
next	1.21;
commitid	P2o6eOwzLRInI6sF;

1.21
date	2016.11.08.21.22.55;	author miod;	state Exp;
branches;
next	1.20;
commitid	dSLSnHCG3WlaQjB9;

1.20
date	2015.04.25.16.02.55;	author doug;	state Exp;
branches;
next	1.19;
commitid	CYjeDzNi6UZDH2My;

1.19
date	2015.02.10.11.22.21;	author jsing;	state Exp;
branches;
next	1.18;
commitid	LaAI4ax0sm4T2bQg;

1.18
date	2014.09.26.19.32.15;	author miod;	state Exp;
branches;
next	1.17;
commitid	sa8ejXIlHIJAxwiz;

1.17
date	2014.07.11.12.52.41;	author miod;	state Exp;
branches;
next	1.16;
commitid	h4chyoOInOG2Ra5G;

1.16
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.15;
commitid	yQEL1wOWIearrW15;

1.15
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	mJUVYpkFBZ0Zv2bG;

1.14
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	2nvnQBrv22dLtvTt;

1.13
date	2014.04.20.15.36.20;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.18.01.59.00;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.17.18.38.53;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.17.30.22;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.13;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.12.11;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.50;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.42;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.42;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.59;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2012.10.13.21.23.44;	author djm;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: x509_lu.c,v 1.22 2016/11/13 08:47:54 miod Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <stdio.h>

#include <openssl/err.h>
#include <openssl/lhash.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include "x509_lcl.h"

static void X509_OBJECT_dec_ref_count(X509_OBJECT *a);
/* static void X509_OBJECT_up_ref_count(X509_OBJECT *a); */

X509_LOOKUP *
X509_LOOKUP_new(X509_LOOKUP_METHOD *method)
{
	X509_LOOKUP *ret;

	ret = malloc(sizeof(X509_LOOKUP));
	if (ret == NULL)
		return NULL;

	ret->init = 0;
	ret->skip = 0;
	ret->method = method;
	ret->method_data = NULL;
	ret->store_ctx = NULL;
	if ((method->new_item != NULL) && !method->new_item(ret)) {
		free(ret);
		return NULL;
	}
	return ret;
}

void
X509_LOOKUP_free(X509_LOOKUP *ctx)
{
	if (ctx == NULL)
		return;
	if ((ctx->method != NULL) && (ctx->method->free != NULL))
		(*ctx->method->free)(ctx);
	free(ctx);
}

int
X509_LOOKUP_init(X509_LOOKUP *ctx)
{
	if (ctx->method == NULL)
		return 0;
	if (ctx->method->init != NULL)
		return ctx->method->init(ctx);
	else
		return 1;
}

int
X509_LOOKUP_shutdown(X509_LOOKUP *ctx)
{
	if (ctx->method == NULL)
		return 0;
	if (ctx->method->shutdown != NULL)
		return ctx->method->shutdown(ctx);
	else
		return 1;
}

int
X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,
    char **ret)
{
	if (ctx->method == NULL)
		return -1;
	if (ctx->method->ctrl != NULL)
		return ctx->method->ctrl(ctx, cmd, argc, argl, ret);
	else
		return 1;
}

int
X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
    X509_OBJECT *ret)
{
	if ((ctx->method == NULL) || (ctx->method->get_by_subject == NULL))
		return X509_LU_FAIL;
	if (ctx->skip)
		return 0;
	return ctx->method->get_by_subject(ctx, type, name, ret);
}

int
X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name,
    ASN1_INTEGER *serial, X509_OBJECT *ret)
{
	if ((ctx->method == NULL) ||
	    (ctx->method->get_by_issuer_serial == NULL))
		return X509_LU_FAIL;
	return ctx->method->get_by_issuer_serial(ctx, type, name, serial, ret);
}

int
X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type, unsigned char *bytes,
    int len, X509_OBJECT *ret)
{
	if ((ctx->method == NULL) || (ctx->method->get_by_fingerprint == NULL))
		return X509_LU_FAIL;
	return ctx->method->get_by_fingerprint(ctx, type, bytes, len, ret);
}

int
X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str, int len,
    X509_OBJECT *ret)
{
	if ((ctx->method == NULL) || (ctx->method->get_by_alias == NULL))
		return X509_LU_FAIL;
	return ctx->method->get_by_alias(ctx, type, str, len, ret);
}

static int
x509_object_cmp(const X509_OBJECT * const *a, const X509_OBJECT * const *b)
{
	int ret;

	ret = ((*a)->type - (*b)->type);
	if (ret)
		return ret;
	switch ((*a)->type) {
	case X509_LU_X509:
		ret = X509_subject_name_cmp((*a)->data.x509, (*b)->data.x509);
		break;
	case X509_LU_CRL:
		ret = X509_CRL_cmp((*a)->data.crl, (*b)->data.crl);
		break;
	default:
		/* abort(); */
		return 0;
	}
	return ret;
}

X509_STORE *
X509_STORE_new(void)
{
	X509_STORE *ret;

	if ((ret = malloc(sizeof(X509_STORE))) == NULL)
		return NULL;
	ret->objs = sk_X509_OBJECT_new(x509_object_cmp);
	ret->cache = 1;
	ret->get_cert_methods = sk_X509_LOOKUP_new_null();
	ret->verify = 0;
	ret->verify_cb = 0;

	if ((ret->param = X509_VERIFY_PARAM_new()) == NULL)
		goto err;

	ret->get_issuer = 0;
	ret->check_issued = 0;
	ret->check_revocation = 0;
	ret->get_crl = 0;
	ret->check_crl = 0;
	ret->cert_crl = 0;
	ret->lookup_certs = 0;
	ret->lookup_crls = 0;
	ret->cleanup = 0;

	if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data))
		goto err;

	ret->references = 1;
	return ret;

err:
	X509_VERIFY_PARAM_free(ret->param);
	sk_X509_LOOKUP_free(ret->get_cert_methods);
	sk_X509_OBJECT_free(ret->objs);
	free(ret);
	return NULL;
}

static void
X509_OBJECT_free(X509_OBJECT *a)
{
	X509_OBJECT_free_contents(a);
	free(a);
}

void
X509_STORE_free(X509_STORE *vfy)
{
	int i;
	STACK_OF(X509_LOOKUP) *sk;
	X509_LOOKUP *lu;

	if (vfy == NULL)
		return;

	i = CRYPTO_add(&vfy->references, -1, CRYPTO_LOCK_X509_STORE);
	if (i > 0)
		return;

	sk = vfy->get_cert_methods;
	for (i = 0; i < sk_X509_LOOKUP_num(sk); i++) {
		lu = sk_X509_LOOKUP_value(sk, i);
		X509_LOOKUP_shutdown(lu);
		X509_LOOKUP_free(lu);
	}
	sk_X509_LOOKUP_free(sk);
	sk_X509_OBJECT_pop_free(vfy->objs, X509_OBJECT_free);

	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE, vfy, &vfy->ex_data);
	X509_VERIFY_PARAM_free(vfy->param);
	free(vfy);
}

X509_LOOKUP *
X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)
{
	int i;
	STACK_OF(X509_LOOKUP) *sk;
	X509_LOOKUP *lu;

	sk = v->get_cert_methods;
	for (i = 0; i < sk_X509_LOOKUP_num(sk); i++) {
		lu = sk_X509_LOOKUP_value(sk, i);
		if (m == lu->method) {
			return lu;
		}
	}
	/* a new one */
	lu = X509_LOOKUP_new(m);
	if (lu == NULL)
		return NULL;
	else {
		lu->store_ctx = v;
		if (sk_X509_LOOKUP_push(v->get_cert_methods, lu))
			return lu;
		else {
			X509_LOOKUP_free(lu);
			return NULL;
		}
	}
}

int
X509_STORE_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,
    X509_OBJECT *ret)
{
	X509_STORE *ctx = vs->ctx;
	X509_LOOKUP *lu;
	X509_OBJECT stmp, *tmp;
	int i, j;

	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
	tmp = X509_OBJECT_retrieve_by_subject(ctx->objs, type, name);
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);

	if (tmp == NULL || type == X509_LU_CRL) {
		for (i = vs->current_method;
		    i < sk_X509_LOOKUP_num(ctx->get_cert_methods); i++) {
			lu = sk_X509_LOOKUP_value(ctx->get_cert_methods, i);
			j = X509_LOOKUP_by_subject(lu, type, name, &stmp);
			if (j < 0) {
				vs->current_method = j;
				return j;
			} else if (j) {
				tmp = &stmp;
				break;
			}
		}
		vs->current_method = 0;
		if (tmp == NULL)
			return 0;
	}

/*	if (ret->data.ptr != NULL)
		X509_OBJECT_free_contents(ret); */

	ret->type = tmp->type;
	ret->data.ptr = tmp->data.ptr;

	X509_OBJECT_up_ref_count(ret);

	return 1;
}

int
X509_STORE_add_cert(X509_STORE *ctx, X509 *x)
{
	X509_OBJECT *obj;
	int ret = 1;

	if (x == NULL)
		return 0;
	obj = malloc(sizeof(X509_OBJECT));
	if (obj == NULL) {
		X509error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	obj->type = X509_LU_X509;
	obj->data.x509 = x;

	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);

	X509_OBJECT_up_ref_count(obj);

	if (X509_OBJECT_retrieve_match(ctx->objs, obj)) {
		X509error(X509_R_CERT_ALREADY_IN_HASH_TABLE);
		ret = 0;
	} else {
		if (sk_X509_OBJECT_push(ctx->objs, obj) == 0) {
			X509error(ERR_R_MALLOC_FAILURE);
			ret = 0;
		}
	}

	if (ret == 0)
		X509_OBJECT_dec_ref_count(obj);

	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);

	if (ret == 0) {
		obj->data.x509 = NULL; /* owned by the caller */
		X509_OBJECT_free(obj);
	}

	return ret;
}

int
X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)
{
	X509_OBJECT *obj;
	int ret = 1;

	if (x == NULL)
		return 0;
	obj = malloc(sizeof(X509_OBJECT));
	if (obj == NULL) {
		X509error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	obj->type = X509_LU_CRL;
	obj->data.crl = x;

	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);

	X509_OBJECT_up_ref_count(obj);

	if (X509_OBJECT_retrieve_match(ctx->objs, obj)) {
		X509error(X509_R_CERT_ALREADY_IN_HASH_TABLE);
		ret = 0;
	} else {
		if (sk_X509_OBJECT_push(ctx->objs, obj) == 0) {
			X509error(ERR_R_MALLOC_FAILURE);
			ret = 0;
		}
	}

	if (ret == 0)
		X509_OBJECT_dec_ref_count(obj);

	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);

	if (ret == 0) {
		obj->data.crl = NULL; /* owned by the caller */
		X509_OBJECT_free(obj);
	}

	return ret;
}

static void
X509_OBJECT_dec_ref_count(X509_OBJECT *a)
{
	switch (a->type) {
	case X509_LU_X509:
		CRYPTO_add(&a->data.x509->references, -1, CRYPTO_LOCK_X509);
		break;
	case X509_LU_CRL:
		CRYPTO_add(&a->data.crl->references, -1, CRYPTO_LOCK_X509_CRL);
		break;
	}
}

/*static*/ void
X509_OBJECT_up_ref_count(X509_OBJECT *a)
{
	switch (a->type) {
	case X509_LU_X509:
		CRYPTO_add(&a->data.x509->references, 1, CRYPTO_LOCK_X509);
		break;
	case X509_LU_CRL:
		CRYPTO_add(&a->data.crl->references, 1, CRYPTO_LOCK_X509_CRL);
		break;
	}
}

void
X509_OBJECT_free_contents(X509_OBJECT *a)
{
	switch (a->type) {
	case X509_LU_X509:
		X509_free(a->data.x509);
		break;
	case X509_LU_CRL:
		X509_CRL_free(a->data.crl);
		break;
	}
}

static int
x509_object_idx_cnt(STACK_OF(X509_OBJECT) *h, int type, X509_NAME *name,
    int *pnmatch)
{
	X509_OBJECT stmp;
	X509 x509_s;
	X509_CINF cinf_s;
	X509_CRL crl_s;
	X509_CRL_INFO crl_info_s;
	int idx;

	stmp.type = type;
	switch (type) {
	case X509_LU_X509:
		stmp.data.x509 = &x509_s;
		x509_s.cert_info = &cinf_s;
		cinf_s.subject = name;
		break;
	case X509_LU_CRL:
		stmp.data.crl = &crl_s;
		crl_s.crl = &crl_info_s;
		crl_info_s.issuer = name;
		break;
	default:
		/* abort(); */
		return -1;
	}

	idx = sk_X509_OBJECT_find(h, &stmp);
	if (idx >= 0 && pnmatch) {
		int tidx;
		const X509_OBJECT *tobj, *pstmp;
		*pnmatch = 1;
		pstmp = &stmp;
		for (tidx = idx + 1; tidx < sk_X509_OBJECT_num(h); tidx++) {
			tobj = sk_X509_OBJECT_value(h, tidx);
			if (x509_object_cmp(&tobj, &pstmp))
				break;
			(*pnmatch)++;
		}
	}
	return idx;
}

int
X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, int type, X509_NAME *name)
{
	return x509_object_idx_cnt(h, type, name, NULL);
}

X509_OBJECT *
X509_OBJECT_retrieve_by_subject(STACK_OF(X509_OBJECT) *h, int type,
    X509_NAME *name)
{
	int idx;

	idx = X509_OBJECT_idx_by_subject(h, type, name);
	if (idx == -1)
		return NULL;
	return sk_X509_OBJECT_value(h, idx);
}

STACK_OF(X509) *
X509_STORE_get1_certs(X509_STORE_CTX *ctx, X509_NAME *nm)
{
	int i, idx, cnt;
	STACK_OF(X509) *sk;
	X509 *x;
	X509_OBJECT *obj;

	sk = sk_X509_new_null();
	if (sk == NULL)
		return NULL;
	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
	idx = x509_object_idx_cnt(ctx->ctx->objs, X509_LU_X509, nm, &cnt);
	if (idx < 0) {
		/* Nothing found in cache: do lookup to possibly add new
		 * objects to cache
		 */
		X509_OBJECT xobj;
		CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
		if (!X509_STORE_get_by_subject(ctx, X509_LU_X509, nm, &xobj)) {
			sk_X509_free(sk);
			return NULL;
		}
		X509_OBJECT_free_contents(&xobj);
		CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
		idx = x509_object_idx_cnt(ctx->ctx->objs,
		    X509_LU_X509, nm, &cnt);
		if (idx < 0) {
			CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
			sk_X509_free(sk);
			return NULL;
		}
	}
	for (i = 0; i < cnt; i++, idx++) {
		obj = sk_X509_OBJECT_value(ctx->ctx->objs, idx);
		x = obj->data.x509;
		CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
		if (!sk_X509_push(sk, x)) {
			CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
			X509_free(x);
			sk_X509_pop_free(sk, X509_free);
			return NULL;
		}
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
	return sk;

}

STACK_OF(X509_CRL) *
X509_STORE_get1_crls(X509_STORE_CTX *ctx, X509_NAME *nm)
{
	int i, idx, cnt;
	STACK_OF(X509_CRL) *sk;
	X509_CRL *x;
	X509_OBJECT *obj, xobj;

	sk = sk_X509_CRL_new_null();
	if (sk == NULL)
		return NULL;
	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
	/* Check cache first */
	idx = x509_object_idx_cnt(ctx->ctx->objs, X509_LU_CRL, nm, &cnt);

	/* Always do lookup to possibly add new CRLs to cache
	 */
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
	if (!X509_STORE_get_by_subject(ctx, X509_LU_CRL, nm, &xobj)) {
		sk_X509_CRL_free(sk);
		return NULL;
	}
	X509_OBJECT_free_contents(&xobj);
	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
	idx = x509_object_idx_cnt(ctx->ctx->objs, X509_LU_CRL, nm, &cnt);
	if (idx < 0) {
		CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
		sk_X509_CRL_free(sk);
		return NULL;
	}

	for (i = 0; i < cnt; i++, idx++) {
		obj = sk_X509_OBJECT_value(ctx->ctx->objs, idx);
		x = obj->data.crl;
		CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509_CRL);
		if (!sk_X509_CRL_push(sk, x)) {
			CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
			X509_CRL_free(x);
			sk_X509_CRL_pop_free(sk, X509_CRL_free);
			return NULL;
		}
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
	return sk;
}

X509_OBJECT *
X509_OBJECT_retrieve_match(STACK_OF(X509_OBJECT) *h, X509_OBJECT *x)
{
	int idx, i;
	X509_OBJECT *obj;

	idx = sk_X509_OBJECT_find(h, x);
	if (idx == -1)
		return NULL;
	if ((x->type != X509_LU_X509) && (x->type != X509_LU_CRL))
		return sk_X509_OBJECT_value(h, idx);
	for (i = idx; i < sk_X509_OBJECT_num(h); i++) {
		obj = sk_X509_OBJECT_value(h, i);
		if (x509_object_cmp((const X509_OBJECT **)&obj,
		    (const X509_OBJECT **)&x))
			return NULL;
		if (x->type == X509_LU_X509) {
			if (!X509_cmp(obj->data.x509, x->data.x509))
				return obj;
		} else if (x->type == X509_LU_CRL) {
			if (!X509_CRL_match(obj->data.crl, x->data.crl))
				return obj;
		} else
			return obj;
	}
	return NULL;
}


/* Try to get issuer certificate from store. Due to limitations
 * of the API this can only retrieve a single certificate matching
 * a given subject name. However it will fill the cache with all
 * matching certificates, so we can examine the cache for all
 * matches.
 *
 * Return values are:
 *  1 lookup successful.
 *  0 certificate not found.
 * -1 some other error.
 */
int
X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
{
	X509_NAME *xn;
	X509_OBJECT obj, *pobj;
	int i, ok, idx, ret;

	*issuer = NULL;
	xn = X509_get_issuer_name(x);
	ok = X509_STORE_get_by_subject(ctx, X509_LU_X509, xn, &obj);
	if (ok != X509_LU_X509) {
		if (ok == X509_LU_RETRY) {
			X509_OBJECT_free_contents(&obj);
			X509error(X509_R_SHOULD_RETRY);
			return -1;
		} else if (ok != X509_LU_FAIL) {
			X509_OBJECT_free_contents(&obj);
			/* not good :-(, break anyway */
			return -1;
		}
		return 0;
	}
	/* If certificate matches all OK */
	if (ctx->check_issued(ctx, x, obj.data.x509)) {
		if (x509_check_cert_time(ctx, obj.data.x509, 1)) {
			*issuer = obj.data.x509;
			return 1;
		}
	}
	X509_OBJECT_free_contents(&obj);

	/* Else find index of first cert accepted by 'check_issued' */
	ret = 0;
	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
	idx = X509_OBJECT_idx_by_subject(ctx->ctx->objs, X509_LU_X509, xn);
	if (idx != -1) /* should be true as we've had at least one match */ {
		/* Look through all matching certs for suitable issuer */
		for (i = idx; i < sk_X509_OBJECT_num(ctx->ctx->objs); i++) {
			pobj = sk_X509_OBJECT_value(ctx->ctx->objs, i);
			/* See if we've run past the matches */
			if (pobj->type != X509_LU_X509)
				break;
			if (X509_NAME_cmp(xn,
			    X509_get_subject_name(pobj->data.x509)))
				break;
			if (ctx->check_issued(ctx, x, pobj->data.x509)) {
				*issuer = pobj->data.x509;
				ret = 1;
				/*
				 * If times check, exit with match,
				 * otherwise keep looking. Leave last
				 * match in issuer so we return nearest
				 * match if no certificate time is OK.
				 */
				if (x509_check_cert_time(ctx, *issuer, 1))
					break;
			}
		}
	}
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
	if (*issuer)
		CRYPTO_add(&(*issuer)->references, 1, CRYPTO_LOCK_X509);
	return ret;
}

int
X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags)
{
	return X509_VERIFY_PARAM_set_flags(ctx->param, flags);
}

int
X509_STORE_set_depth(X509_STORE *ctx, int depth)
{
	X509_VERIFY_PARAM_set_depth(ctx->param, depth);
	return 1;
}

int
X509_STORE_set_purpose(X509_STORE *ctx, int purpose)
{
	return X509_VERIFY_PARAM_set_purpose(ctx->param, purpose);
}

int
X509_STORE_set_trust(X509_STORE *ctx, int trust)
{
	return X509_VERIFY_PARAM_set_trust(ctx->param, trust);
}

int
X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *param)
{
	return X509_VERIFY_PARAM_set1(ctx->param, param);
}

void
X509_STORE_set_verify_cb(X509_STORE *ctx,
    int (*verify_cb)(int, X509_STORE_CTX *))
{
	ctx->verify_cb = verify_cb;
}
@


1.22
log
@Fix previous change to X509_STORE_add_{cert,crl} to not free the input
object in the error path - we don't own it.
@
text
@d1 1
a1 1
/* $OpenBSD: x509_lu.c,v 1.21 2016/11/08 21:22:55 miod Exp $ */
d352 1
a352 1
		X509err(X509_F_X509_STORE_ADD_CERT, ERR_R_MALLOC_FAILURE);
d363 1
a363 2
		X509err(X509_F_X509_STORE_ADD_CERT,
		    X509_R_CERT_ALREADY_IN_HASH_TABLE);
d367 1
a367 2
			X509err(X509_F_X509_STORE_ADD_CERT,
			    ERR_R_MALLOC_FAILURE);
d395 1
a395 1
		X509err(X509_F_X509_STORE_ADD_CRL, ERR_R_MALLOC_FAILURE);
d406 1
a406 2
		X509err(X509_F_X509_STORE_ADD_CRL,
		    X509_R_CERT_ALREADY_IN_HASH_TABLE);
d410 1
a410 2
			X509err(X509_F_X509_STORE_ADD_CRL,
			    ERR_R_MALLOC_FAILURE);
d677 1
a677 2
			X509err(X509_F_X509_STORE_CTX_GET1_ISSUER,
			    X509_R_SHOULD_RETRY);
@


1.21
log
@Check for stack push failure, and correctly destroy the object we failed
to push in that case. While there replace an inline version of
X509_OBJECT_free_contents() by a call to said function.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_lu.c,v 1.20 2015/04/25 16:02:55 doug Exp $ */
d379 2
a380 1
	if (ret == 0)
d382 1
d424 2
a425 1
	if (ret == 0)
d427 1
@


1.20
log
@Don't ignore the reference count in X509_STORE_free.

Based on this upstream commit: bff9ce4db38b297c72a6d84617d71ae2934450f7
which didn't make it into a release until 1.0.2.

Thanks to william at 25thandclement dot com for reporting this!

ok deraadt@@ jsing@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_lu.c,v 1.19 2015/02/10 11:22:21 jsing Exp $ */
d67 3
d237 1
a237 1
cleanup(X509_OBJECT *a)
d239 1
a239 8
	if (a->type == X509_LU_X509) {
		X509_free(a->data.x509);
	} else if (a->type == X509_LU_CRL) {
		X509_CRL_free(a->data.crl);
	} else {
		/* abort(); */
	}

d264 1
a264 1
	sk_X509_OBJECT_pop_free(vfy->objs, cleanup);
a362 2
		X509_OBJECT_free_contents(obj);
		free(obj);
d366 10
a375 2
	} else
		sk_X509_OBJECT_push(ctx->objs, obj);
d379 3
a405 2
		X509_OBJECT_free_contents(obj);
		free(obj);
d409 10
a418 2
	} else
		sk_X509_OBJECT_push(ctx->objs, obj);
d422 3
d428 14
a441 1
void
@


1.19
log
@Remove more IMPLEMENT_STACK_OF noops that have been hiding for the last
15 years.
@
text
@d1 1
a1 1
/* $OpenBSD: x509_lu.c,v 1.18 2014/09/26 19:32:15 miod Exp $ */
d255 4
@


1.18
log
@X509_STORE_new(): do not leak memory upon error.
X509_STORE_get1_certs(), X509_STORE_get1_crls(): check the result of
allocations.

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_lu.c,v 1.17 2014/07/11 12:52:41 miod Exp $ */
a735 3

IMPLEMENT_STACK_OF(X509_LOOKUP)
IMPLEMENT_STACK_OF(X509_OBJECT)
@


1.17
log
@When looking for the issuer of a certificate, if the current candidate is
expired or not valid yet, continue looking; only return an expired certificate
if no valid certificates have been found.

OpenSSL PR #3359 via OpenSSL trunk.
@
text
@d1 1
a1 1
/* $OpenBSD: x509_lu.c,v 1.16 2014/07/11 08:44:49 jsing Exp $ */
d206 2
a207 5
	if ((ret->param = X509_VERIFY_PARAM_new()) == NULL) {
		sk_X509_OBJECT_free(ret->objs);
		free(ret);
		return NULL;
	}
d219 2
a220 6
	if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE,
	    ret, &ret->ex_data)) {
		sk_X509_OBJECT_free(ret->objs);
		free(ret);
		return NULL;
	}
d224 7
d267 1
a267 2
	if (vfy->param)
		X509_VERIFY_PARAM_free(vfy->param);
d507 2
d556 2
@


1.16
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_lu.c,v 1.15 2014/06/12 15:49:31 deraadt Exp $ */
d65 1
d636 2
d655 4
a658 2
		*issuer = obj.data.x509;
		return 1;
a677 1
				X509_OBJECT_up_ref_count(pobj);
d679 8
a686 1
				break;
d691 2
@


1.15
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d60 2
a61 1
#include "cryptlib.h"
@


1.14
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/x509/x509_lu.c */
@


1.13
log
@KNF.
@
text
@d70 1
a70 1
	ret = (X509_LOOKUP *)malloc(sizeof(X509_LOOKUP));
d196 1
a196 1
	if ((ret = (X509_STORE *)malloc(sizeof(X509_STORE))) == NULL)
d349 1
a349 1
	obj = (X509_OBJECT *)malloc(sizeof(X509_OBJECT));
d383 1
a383 1
	obj = (X509_OBJECT *)malloc(sizeof(X509_OBJECT));
@


1.12
log
@blunt force knf
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d65 2
a66 1
X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method)
d70 3
a72 2
	ret=(X509_LOOKUP *)malloc(sizeof(X509_LOOKUP));
	if (ret == NULL) return NULL;
d74 5
a78 5
	ret->init=0;
	ret->skip=0;
	ret->method=method;
	ret->method_data=NULL;
	ret->store_ctx=NULL;
d86 2
a87 1
void X509_LOOKUP_free(X509_LOOKUP *ctx)
d89 3
a91 3
	if (ctx == NULL) return;
	if (	(ctx->method != NULL) &&
		(ctx->method->free != NULL))
d96 2
a97 1
int X509_LOOKUP_init(X509_LOOKUP *ctx)
d99 2
a100 1
	if (ctx->method == NULL) return 0;
d107 2
a108 1
int X509_LOOKUP_shutdown(X509_LOOKUP *ctx)
d110 2
a111 1
	if (ctx->method == NULL) return 0;
d118 3
a120 2
int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,
	     char **ret)
d122 2
a123 1
	if (ctx->method == NULL) return -1;
d125 1
a125 1
		return ctx->method->ctrl(ctx,cmd,argc,argl,ret);
d130 4
a133 3
int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
	     X509_OBJECT *ret)
	{
d136 3
a138 2
	if (ctx->skip) return 0;
	return ctx->method->get_by_subject(ctx,type,name,ret);
d141 3
a143 2
int X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name,
	     ASN1_INTEGER *serial, X509_OBJECT *ret)
d146 1
a146 1
		(ctx->method->get_by_issuer_serial == NULL))
d148 1
a148 1
	return ctx->method->get_by_issuer_serial(ctx,type,name,serial,ret);
d151 3
a153 2
int X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type,
	     unsigned char *bytes, int len, X509_OBJECT *ret)
d157 1
a157 1
	return ctx->method->get_by_fingerprint(ctx,type,bytes,len,ret);
d160 3
a162 2
int X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str, int len,
	     X509_OBJECT *ret)
d166 1
a166 1
	return ctx->method->get_by_alias(ctx,type,str,len,ret);
d169 15
a183 14
  
static int x509_object_cmp(const X509_OBJECT * const *a, const X509_OBJECT * const *b)
  {
 	int ret;

 	ret=((*a)->type - (*b)->type);
 	if (ret) return ret;
 	switch ((*a)->type) {
 	case X509_LU_X509:
 		ret=X509_subject_name_cmp((*a)->data.x509,(*b)->data.x509);
 		break;
 	case X509_LU_CRL:
 		ret=X509_CRL_cmp((*a)->data.crl,(*b)->data.crl);
 		break;
d191 2
a192 1
X509_STORE *X509_STORE_new(void)
d196 1
a196 1
	if ((ret=(X509_STORE *)malloc(sizeof(X509_STORE))) == NULL)
d199 4
a202 4
	ret->cache=1;
	ret->get_cert_methods=sk_X509_LOOKUP_new_null();
	ret->verify=0;
	ret->verify_cb=0;
d208 1
a208 1
}
d220 2
a221 1
	if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data)) {
d227 1
a227 1
	ret->references=1;
d231 2
a232 1
static void cleanup(X509_OBJECT *a)
d245 2
a246 1
void X509_STORE_free(X509_STORE *vfy)
d253 1
a253 1
	    return;
d255 3
a257 3
	sk=vfy->get_cert_methods;
	for (i=0; i<sk_X509_LOOKUP_num(sk); i++) {
		lu=sk_X509_LOOKUP_value(sk,i);
d270 2
a271 1
X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)
d277 3
a279 3
	sk=v->get_cert_methods;
	for (i=0; i<sk_X509_LOOKUP_num(sk); i++) {
		lu=sk_X509_LOOKUP_value(sk,i);
d285 1
a285 1
	lu=X509_LOOKUP_new(m);
d289 2
a290 2
		lu->store_ctx=v;
		if (sk_X509_LOOKUP_push(v->get_cert_methods,lu))
d299 3
a301 2
int X509_STORE_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,
	     X509_OBJECT *ret)
d303 1
a303 1
	X509_STORE *ctx=vs->ctx;
d305 2
a306 2
	X509_OBJECT stmp,*tmp;
	int i,j;
d309 1
a309 1
	tmp=X509_OBJECT_retrieve_by_subject(ctx->objs,type,name);
d313 4
a316 3
		for (i=vs->current_method; i<sk_X509_LOOKUP_num(ctx->get_cert_methods); i++) {
			lu=sk_X509_LOOKUP_value(ctx->get_cert_methods,i);
			j=X509_LOOKUP_by_subject(lu,type,name,&stmp);
d318 1
a318 1
				vs->current_method=j;
d321 1
a321 1
				tmp= &stmp;
d325 1
a325 1
		vs->current_method=0;
d333 2
a334 2
	ret->type=tmp->type;
	ret->data.ptr=tmp->data.ptr;
d341 2
a342 1
int X509_STORE_add_cert(X509_STORE *ctx, X509 *x)
d345 1
a345 1
	int ret=1;
d347 3
a349 2
	if (x == NULL) return 0;
	obj=(X509_OBJECT *)malloc(sizeof(X509_OBJECT));
d351 1
a351 1
		X509err(X509_F_X509_STORE_ADD_CERT,ERR_R_MALLOC_FAILURE);
d354 2
a355 2
	obj->type=X509_LU_X509;
	obj->data.x509=x;
d364 5
a368 4
		X509err(X509_F_X509_STORE_ADD_CERT,X509_R_CERT_ALREADY_IN_HASH_TABLE);
		ret=0;
	} 
	else sk_X509_OBJECT_push(ctx->objs, obj);
d375 2
a376 1
int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)
d379 1
a379 1
	int ret=1;
d381 3
a383 2
	if (x == NULL) return 0;
	obj=(X509_OBJECT *)malloc(sizeof(X509_OBJECT));
d385 1
a385 1
		X509err(X509_F_X509_STORE_ADD_CRL,ERR_R_MALLOC_FAILURE);
d388 2
a389 2
	obj->type=X509_LU_CRL;
	obj->data.crl=x;
d398 3
a400 2
		X509err(X509_F_X509_STORE_ADD_CRL,X509_R_CERT_ALREADY_IN_HASH_TABLE);
		ret=0;
d409 2
a410 1
void X509_OBJECT_up_ref_count(X509_OBJECT *a)
d414 1
a414 1
		CRYPTO_add(&a->data.x509->references,1,CRYPTO_LOCK_X509);
d417 1
a417 1
		CRYPTO_add(&a->data.crl->references,1,CRYPTO_LOCK_X509_CRL);
d422 2
a423 1
void X509_OBJECT_free_contents(X509_OBJECT *a)
d435 3
a437 2
static int x509_object_idx_cnt(STACK_OF(X509_OBJECT) *h, int type,
	     X509_NAME *name, int *pnmatch)
d446 1
a446 1
	stmp.type=type;
d449 3
a451 3
		stmp.data.x509= &x509_s;
		x509_s.cert_info= &cinf_s;
		cinf_s.subject=name;
d454 3
a456 3
		stmp.data.crl= &crl_s;
		crl_s.crl= &crl_info_s;
		crl_info_s.issuer=name;
d463 1
a463 1
	idx = sk_X509_OBJECT_find(h,&stmp);
d479 2
a480 3

int X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, int type,
	     X509_NAME *name)
d485 3
a487 2
X509_OBJECT *X509_OBJECT_retrieve_by_subject(STACK_OF(X509_OBJECT) *h, int type,
	     X509_NAME *name)
d490 1
d492 2
a493 1
	if (idx==-1) return NULL;
d497 2
a498 1
STACK_OF(X509)* X509_STORE_get1_certs(X509_STORE_CTX *ctx, X509_NAME *nm)
d504 1
d520 2
a521 1
		idx = x509_object_idx_cnt(ctx->ctx->objs,X509_LU_X509,nm, &cnt);
d544 2
a545 1
STACK_OF(X509_CRL)* X509_STORE_get1_crls(X509_STORE_CTX *ctx, X509_NAME *nm)
d551 1
d566 1
a566 1
	idx = x509_object_idx_cnt(ctx->ctx->objs,X509_LU_CRL, nm, &cnt);
d588 2
a589 1
X509_OBJECT *X509_OBJECT_retrieve_match(STACK_OF(X509_OBJECT) *h, X509_OBJECT *x)
d593 1
d595 2
a596 1
	if (idx == -1) return NULL;
d601 2
a602 1
		if (x509_object_cmp((const X509_OBJECT **)&obj, (const X509_OBJECT **)&x))
d628 2
a629 1
int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
d634 2
a635 2
	xn=X509_get_issuer_name(x);
	ok=X509_STORE_get_by_subject(ctx,X509_LU_X509,xn,&obj);
d639 2
a640 1
			X509err(X509_F_X509_STORE_CTX_GET1_ISSUER,X509_R_SHOULD_RETRY);
d667 2
a668 1
			if (X509_NAME_cmp(xn, X509_get_subject_name(pobj->data.x509)))
d682 2
a683 1
int X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags)
d688 2
a689 1
int X509_STORE_set_depth(X509_STORE *ctx, int depth)
d695 2
a696 1
int X509_STORE_set_purpose(X509_STORE *ctx, int purpose)
d701 2
a702 1
int X509_STORE_set_trust(X509_STORE *ctx, int trust)
d707 2
a708 1
int X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *param)
d713 3
a715 2
void X509_STORE_set_verify_cb(X509_STORE *ctx,
				  int (*verify_cb)(int, X509_STORE_CTX *))
@


1.11
log
@fix some more leaks, mostly suggestions from miod
ok miod@@
@
text
@d66 1
a66 1
	{
d77 1
a77 2
	if ((method->new_item != NULL) && !method->new_item(ret))
		{
d80 1
a80 1
		}
d82 1
a82 1
	}
d85 1
a85 1
	{
d91 1
a91 1
	}
d94 1
a94 1
	{
d100 1
a100 1
	}
d103 1
a103 1
	{
d109 1
a109 1
	}
d113 1
a113 1
	{
d119 1
a119 1
	}
d128 1
a128 1
	}
d132 1
a132 1
	{
d137 1
a137 1
	}
d141 1
a141 1
	{
d145 1
a145 1
	}
d149 1
a149 1
	{
d153 1
a153 1
	}
d157 1
a157 1
  	{
d162 1
a162 2
 	switch ((*a)->type)
 		{
d172 1
a172 1
		}
d174 1
a174 1
	}
d177 1
a177 1
	{
d192 1
a192 1
	}
d204 1
a204 2
	if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data))
		{
d208 1
a208 1
		}
d212 1
a212 1
	}
d215 2
a216 3
	{
	if (a->type == X509_LU_X509)
		{
d218 1
a218 3
		}
	else if (a->type == X509_LU_CRL)
		{
d220 1
a220 3
		}
	else
		{
d222 1
a222 1
		}
d225 1
a225 1
	}
d228 1
a228 1
	{
d237 1
a237 2
	for (i=0; i<sk_X509_LOOKUP_num(sk); i++)
		{
d241 1
a241 1
		}
d249 1
a249 1
	}
d252 1
a252 1
	{
d258 1
a258 2
	for (i=0; i<sk_X509_LOOKUP_num(sk); i++)
		{
d260 1
a260 2
		if (m == lu->method)
			{
a261 1
			}
d263 1
d268 1
a268 2
	else
		{
d272 1
a272 2
		else
			{
a274 1
			}
d277 1
d281 1
a281 1
	{
d291 2
a292 4
	if (tmp == NULL || type == X509_LU_CRL)
		{
		for (i=vs->current_method; i<sk_X509_LOOKUP_num(ctx->get_cert_methods); i++)
			{
d295 1
a295 2
			if (j < 0)
				{
d298 1
a298 3
				}
			else if (j)
				{
a300 1
				}
d302 1
d306 1
a306 1
		}
d317 1
a317 1
	}
d320 1
a320 1
	{
d326 1
a326 2
	if (obj == NULL)
		{
d329 1
a329 1
		}
d337 1
a337 2
	if (X509_OBJECT_retrieve_match(ctx->objs, obj))
		{
d342 1
a342 1
		} 
d348 1
a348 1
	}
d351 1
a351 1
	{
d357 1
a357 2
	if (obj == NULL)
		{
d360 1
a360 1
		}
d368 1
a368 2
	if (X509_OBJECT_retrieve_match(ctx->objs, obj))
		{
d373 2
a374 2
		}
	else sk_X509_OBJECT_push(ctx->objs, obj);
d379 1
a379 1
	}
d382 2
a383 3
	{
	switch (a->type)
		{
a389 1
		}
d391 1
d394 2
a395 3
	{
	switch (a->type)
		{
a401 1
		}
d403 1
d407 1
a407 1
	{
d416 1
a416 2
	switch (type)
		{
d430 1
a430 1
		}
d433 1
a433 2
	if (idx >= 0 && pnmatch)
		{
d438 1
a438 2
		for (tidx = idx + 1; tidx < sk_X509_OBJECT_num(h); tidx++)
			{
a442 1
			}
d444 1
d446 1
a446 1
	}
d451 1
a451 1
	{
d453 1
a453 1
	}
d457 1
a457 1
	{
d462 1
a462 1
	}
d465 1
a465 1
	{
d473 1
a473 2
	if (idx < 0)
		{
d479 1
a479 2
		if (!X509_STORE_get_by_subject(ctx, X509_LU_X509, nm, &xobj))
			{
d482 1
a482 1
			}
d486 1
a486 2
		if (idx < 0)
			{
a489 1
			}
d491 2
a492 2
	for (i = 0; i < cnt; i++, idx++)
		{
d496 1
a496 2
		if (!sk_X509_push(sk, x))
			{
a500 1
			}
d502 1
d506 1
a506 1
	}
d509 1
a509 1
	{
d522 1
a522 2
	if (!X509_STORE_get_by_subject(ctx, X509_LU_CRL, nm, &xobj))
		{
d525 1
a525 1
		}
d529 1
a529 2
	if (idx < 0)
		{
d533 1
a533 1
		}
d535 1
a535 2
	for (i = 0; i < cnt; i++, idx++)
		{
d539 1
a539 2
		if (!sk_X509_CRL_push(sk, x))
			{
a543 1
			}
d545 1
d548 1
a548 1
	}
d551 1
a551 1
	{
d558 1
a558 2
	for (i = idx; i < sk_X509_OBJECT_num(h); i++)
		{
d562 1
a562 2
		if (x->type == X509_LU_X509)
			{
d565 1
a565 3
			}
		else if (x->type == X509_LU_CRL)
			{
d568 1
a568 2
			}
		else
d570 1
a570 1
		}
d572 1
a572 1
	}
d587 1
a587 1
	{
d593 2
a594 4
	if (ok != X509_LU_X509)
		{
		if (ok == X509_LU_RETRY)
			{
d598 1
a598 3
			}
		else if (ok != X509_LU_FAIL)
			{
d602 1
a602 1
			}
d604 1
a604 1
		}
d606 1
a606 2
	if (ctx->check_issued(ctx, x, obj.data.x509))
		{
d609 1
a609 1
		}
d616 1
a616 2
	if (idx != -1) /* should be true as we've had at least one match */
		{
d618 1
a618 2
		for (i = idx; i < sk_X509_OBJECT_num(ctx->ctx->objs); i++)
			{
d625 1
a625 2
			if (ctx->check_issued(ctx, x, pobj->data.x509))
				{
a629 1
				}
d632 1
d635 1
a635 1
	}
d638 1
a638 1
	{
d640 1
a640 1
	}
d643 1
a643 1
	{
d646 1
a646 1
	}
d649 1
a649 1
	{
d651 1
a651 1
	}
d654 1
a654 1
	{
d656 1
a656 1
	}
d659 1
a659 1
	{
d661 1
a661 1
	}
d665 1
a665 1
	{
d667 1
a667 1
	}
@


1.10
log
@fix some of the leaks
ok miod@@ looks good deraadt@@
@
text
@d191 1
@


1.9
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d190 2
a191 1
	if ((ret->param = X509_VERIFY_PARAM_new()) == NULL)
d193 1
@


1.8
log
@resolve conflicts
@
text
@d69 1
a69 1
	ret=(X509_LOOKUP *)OPENSSL_malloc(sizeof(X509_LOOKUP));
d79 1
a79 1
		OPENSSL_free(ret);
d91 1
a91 1
	OPENSSL_free(ctx);
d182 1
a182 1
	if ((ret=(X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL)
d206 1
a206 1
		OPENSSL_free(ret);
d229 1
a229 1
	OPENSSL_free(a);
d254 1
a254 1
	OPENSSL_free(vfy);
d340 1
a340 1
	obj=(X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));
d356 1
a356 1
		OPENSSL_free(obj);
d373 1
a373 1
	obj=(X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));
d389 1
a389 1
		OPENSSL_free(obj);
@


1.7
log
@resolve conflicts, fix local changes
@
text
@d90 1
a90 1
		ctx->method->free(ctx);
@


1.6
log
@resolve conflicts
@
text
@d199 2
d203 7
a209 1
	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data);
d297 1
d299 1
d301 1
a301 1
	if (tmp == NULL)
a352 1

d426 2
a427 2
int X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, int type,
	     X509_NAME *name)
d434 1
d454 23
a476 1
	return sk_X509_OBJECT_find(h,&stmp);
d481 1
a481 1
{
d486 96
a581 1
}
d584 1
a584 1
{
d589 2
a590 1
	if (x->type != X509_LU_X509) return sk_X509_OBJECT_value(h, idx);
d596 11
a606 1
		if ((x->type != X509_LU_X509) || !X509_cmp(obj->data.x509, x->data.x509))
d610 1
a610 1
}
d616 1
a616 1
 * matching certificates, so we can examine the cache for all 
a623 2


d625 1
a625 1
{
d628 1
a628 1
	int i, ok, idx;
d654 4
a657 1
	/* Else find index of first matching cert */
d659 1
a659 5
	/* This shouldn't normally happen since we already have one match */
	if (idx == -1) return 0;

	/* Look through all matching certificates for a suitable issuer */
	for (i = idx; i < sk_X509_OBJECT_num(ctx->ctx->objs); i++)
d661 2
a662 5
		pobj = sk_X509_OBJECT_value(ctx->ctx->objs, i);
		/* See if we've ran out of matches */
		if (pobj->type != X509_LU_X509) return 0;
		if (X509_NAME_cmp(xn, X509_get_subject_name(pobj->data.x509))) return 0;
		if (ctx->check_issued(ctx, x, pobj->data.x509))
d664 13
a676 3
			*issuer = pobj->data.x509;
			X509_OBJECT_up_ref_count(pobj);
			return 1;
d679 3
a681 2
	return 0;
}
d707 6
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d190 2
a191 4
	ret->purpose = 0;
	ret->trust = 0;

	ret->flags = 0;
a202 1
	ret->depth=0;
d244 2
d500 1
a500 1
			X509err(X509_F_X509_VERIFY_CERT,X509_R_SHOULD_RETRY);
d540 1
a540 1
void X509_STORE_set_flags(X509_STORE *ctx, long flags)
d542 7
a548 1
	ctx->flags |= flags;
d553 1
a553 1
	return X509_PURPOSE_set(&ctx->purpose, purpose);
d558 6
a563 1
	return X509_TRUST_set(&ctx->trust, trust);
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d63 1
a63 2

static STACK_OF(CRYPTO_EX_DATA_FUNCS) *x509_store_meth=NULL;
d187 17
a203 3
	ret->verify=NULL;
	ret->verify_cb=NULL;
	memset(&ret->ex_data,0,sizeof(CRYPTO_EX_DATA));
d246 1
a246 1
	CRYPTO_free_ex_data(x509_store_meth,vfy,&vfy->ex_data);
d540 15
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@a64 1
static STACK_OF(CRYPTO_EX_DATA_FUNCS) *x509_store_ctx_meth=NULL;
d70 2
a71 2
	ret=(X509_LOOKUP *)Malloc(sizeof(X509_LOOKUP));
	if (ret == NULL) return(NULL);
d80 2
a81 2
		Free(ret);
		return(NULL);
d83 1
a83 1
	return(ret);
d92 1
a92 1
	Free(ctx);
d97 1
a97 1
	if (ctx->method == NULL) return(0);
d99 1
a99 1
		return(ctx->method->init(ctx));
d101 1
a101 1
		return(1);
d106 1
a106 1
	if (ctx->method == NULL) return(0);
d108 1
a108 1
		return(ctx->method->shutdown(ctx));
d110 1
a110 1
		return(1);
d116 1
a116 1
	if (ctx->method == NULL) return(-1);
d118 1
a118 1
		return(ctx->method->ctrl(ctx,cmd,argc,argl,ret));
d120 1
a120 1
		return(1);
d127 3
a129 3
		return(X509_LU_FAIL);
	if (ctx->skip) return(0);
	return(ctx->method->get_by_subject(ctx,type,name,ret));
d137 2
a138 2
		return(X509_LU_FAIL);
	return(ctx->method->get_by_issuer_serial(ctx,type,name,serial,ret));
d145 2
a146 2
		return(X509_LU_FAIL);
	return(ctx->method->get_by_fingerprint(ctx,type,bytes,len,ret));
d153 2
a154 2
		return(X509_LU_FAIL);
	return(ctx->method->get_by_alias(ctx,type,str,len,ret));
d157 15
a171 32
static unsigned long x509_object_hash(X509_OBJECT *a)
	{
	unsigned long h;

	switch (a->type)
		{
	case X509_LU_X509:
		h=X509_NAME_hash(a->data.x509->cert_info->subject);
		break;
	case X509_LU_CRL:
		h=X509_NAME_hash(a->data.crl->crl->issuer);
		break;
	default:
		abort();
		}
	return(h);
	}

static int x509_object_cmp(X509_OBJECT *a, X509_OBJECT *b)
	{
	int ret;

	ret=(a->type - b->type);
	if (ret) return(ret);
	switch (a->type)
		{
	case X509_LU_X509:
		ret=X509_subject_name_cmp(a->data.x509,b->data.x509);
		break;
	case X509_LU_CRL:
		ret=X509_CRL_cmp(a->data.crl,b->data.crl);
		break;
d173 2
a174 1
		abort();
d176 1
a176 1
	return(ret);
d183 3
a185 3
	if ((ret=(X509_STORE *)Malloc(sizeof(X509_STORE))) == NULL)
		return(NULL);
	ret->certs=lh_new(x509_object_hash,x509_object_cmp);
d193 1
a193 1
	return(ret);
d207 3
a209 1
		abort();
d211 1
a211 1
	Free(a);
d220 1
a220 1
	if(vfy == NULL)
d231 1
d234 1
a234 3
	lh_doall(vfy->certs,cleanup);
	lh_free(vfy->certs);
	Free(vfy);
d249 1
a249 1
			return(lu);
d255 1
a255 1
		return(NULL);
d260 1
a260 1
			return(lu);
d264 1
a264 1
			return(NULL);
d277 1
a277 1
	tmp=X509_OBJECT_retrieve_by_subject(ctx->certs,type,name);
d288 1
a288 1
				return(j);
d298 1
a298 1
			return(0);
d309 68
a376 1
	return(1);
d405 1
a405 1
X509_OBJECT *X509_OBJECT_retrieve_by_subject(LHASH *h, int type,
d408 1
a408 1
	X509_OBJECT stmp,*tmp;
d428 2
a429 1
		abort();
d432 1
a432 2
	tmp=(X509_OBJECT *)lh_retrieve(h,&stmp);
	return(tmp);
d435 2
a436 1
X509_STORE_CTX *X509_STORE_CTX_new(void)
d438 4
a441 4
	X509_STORE_CTX *ctx;
	ctx = (X509_STORE_CTX *)Malloc(sizeof(X509_STORE_CTX));
	if(ctx) memset(ctx, 0, sizeof(X509_STORE_CTX));
	return ctx;
d444 1
a444 1
void X509_STORE_CTX_free(X509_STORE_CTX *ctx)
d446 14
a459 2
	X509_STORE_CTX_cleanup(ctx);
	Free(ctx);
d462 39
a500 21
void X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
	     STACK_OF(X509) *chain)
	{
	ctx->ctx=store;
	ctx->current_method=0;
	ctx->cert=x509;
	ctx->untrusted=chain;
	ctx->last_untrusted=0;
	ctx->purpose=0;
	ctx->trust=0;
	ctx->valid=0;
	ctx->chain=NULL;
	ctx->depth=9;
	ctx->error=0;
	ctx->current_cert=NULL;
	memset(&(ctx->ex_data),0,sizeof(CRYPTO_EX_DATA));
	}

void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->chain != NULL)
d502 22
a523 2
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
d525 2
a526 3
	CRYPTO_free_ex_data(x509_store_ctx_meth,ctx,&(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}
d529 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d64 2
a65 2
static STACK *x509_store_meth=NULL;
static STACK *x509_store_ctx_meth=NULL;
d247 1
a247 1
	CRYPTO_free_ex_data(x509_store_meth,(char *)vfy,&vfy->ex_data);
d380 1
a380 1
	tmp=(X509_OBJECT *)lh_retrieve(h,(char *)&stmp);
d384 14
d406 2
d423 1
a423 1
	CRYPTO_free_ex_data(x509_store_ctx_meth,(char *)ctx,&(ctx->ex_data));
@


1.1
log
@Initial revision
@
text
@d61 2
a62 2
#include "lhash.h"
#include "x509.h"
d67 1
a67 2
X509_LOOKUP *X509_LOOKUP_new(method)
X509_LOOKUP_METHOD *method;
d87 1
a87 2
void X509_LOOKUP_free(ctx)
X509_LOOKUP *ctx;
d96 1
a96 2
int X509_LOOKUP_init(ctx)
X509_LOOKUP *ctx;
d105 1
a105 2
int X509_LOOKUP_shutdown(ctx)
X509_LOOKUP *ctx;
d108 1
a108 1
	if (ctx->method->init != NULL)
d114 2
a115 6
int X509_LOOKUP_ctrl(ctx,cmd,argc,argl,ret)
X509_LOOKUP *ctx;
int cmd;
char *argc;
long argl;
char **ret;
d124 2
a125 5
int X509_LOOKUP_by_subject(ctx,type,name,ret)
X509_LOOKUP *ctx;
int type;
X509_NAME *name;
X509_OBJECT *ret;
d133 2
a134 6
int X509_LOOKUP_by_issuer_serial(ctx,type,name,serial,ret)
X509_LOOKUP *ctx;
int type;
X509_NAME *name;
ASN1_INTEGER *serial;
X509_OBJECT *ret;
d142 2
a143 6
int X509_LOOKUP_by_fingerprint(ctx,type,bytes,len,ret)
X509_LOOKUP *ctx;
int type;
unsigned char *bytes;
int len;
X509_OBJECT *ret;
d150 2
a151 6
int X509_LOOKUP_by_alias(ctx,type,str,len,ret)
X509_LOOKUP *ctx;
int type;
char *str;
int len;
X509_OBJECT *ret;
d155 1
a155 1
	return(ctx->method->get_by_alias(ctx,str,len,ret));
d158 1
a158 2
static unsigned long x509_object_hash(a)
X509_OBJECT *a;
d176 1
a176 2
static int x509_object_cmp(a,b)
X509_OBJECT *a,*b;
d196 1
a196 1
X509_STORE *X509_STORE_new()
d204 1
a204 1
	ret->get_cert_methods=sk_new_null();
d209 1
d213 1
a213 2
static void cleanup(a)
X509_OBJECT *a;
d229 1
a229 2
void X509_STORE_free(vfy)
X509_STORE *vfy;
d232 1
a232 1
	STACK *sk;
d235 3
d239 1
a239 1
	for (i=0; i<sk_num(sk); i++)
d241 1
a241 1
		lu=(X509_LOOKUP *)sk_value(sk,i);
d245 1
a245 1
	sk_free(sk);
d253 1
a253 3
X509_LOOKUP *X509_STORE_add_lookup(v,m)
X509_STORE *v;
X509_LOOKUP_METHOD *m;
d256 1
a256 1
	STACK *sk;
d260 1
a260 1
	for (i=0; i<sk_num(sk); i++)
d262 1
a262 1
		lu=(X509_LOOKUP *)sk_value(sk,i);
d275 1
a275 1
		if (sk_push(v->get_cert_methods,(char *)lu))
d285 2
a286 5
int X509_STORE_get_by_subject(vs,type,name,ret)
X509_STORE_CTX *vs;
int type;
X509_NAME *name;
X509_OBJECT *ret;
d293 1
a293 1
	tmp=X509_OBJECT_retrive_by_subject(ctx->certs,type,name);
d297 1
a297 1
		for (i=vs->current_method; i<sk_num(ctx->get_cert_methods); i++)
d299 1
a299 1
			lu=(X509_LOOKUP *)sk_value(ctx->get_cert_methods,i);
d328 1
a328 2
void X509_OBJECT_up_ref_count(a)
X509_OBJECT *a;
d341 1
a341 2
void X509_OBJECT_free_contents(a)
X509_OBJECT *a;
d354 2
a355 4
X509_OBJECT *X509_OBJECT_retrive_by_subject(h,type,name)
LHASH *h;
int type;
X509_NAME *name;
d384 2
a385 5
void X509_STORE_CTX_init(ctx,store,x509,chain)
X509_STORE_CTX *ctx;
X509_STORE *store;
X509 *x509;
STACK *chain;
d394 1
a394 1
	ctx->depth=10;
d400 1
a400 2
void X509_STORE_CTX_cleanup(ctx)
X509_STORE_CTX *ctx;
d404 1
a404 1
		sk_pop_free(ctx->chain,X509_free);
d411 1
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d61 2
a62 3
#include <openssl/lhash.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
d64 5
a68 1
X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method)
d72 2
a73 2
	ret=(X509_LOOKUP *)OPENSSL_malloc(sizeof(X509_LOOKUP));
	if (ret == NULL) return NULL;
d82 2
a83 2
		OPENSSL_free(ret);
		return NULL;
d85 1
a85 1
	return ret;
d88 2
a89 1
void X509_LOOKUP_free(X509_LOOKUP *ctx)
d95 1
a95 1
	OPENSSL_free(ctx);
d98 2
a99 1
int X509_LOOKUP_init(X509_LOOKUP *ctx)
d101 1
a101 1
	if (ctx->method == NULL) return 0;
d103 1
a103 1
		return ctx->method->init(ctx);
d105 1
a105 1
		return 1;
d108 2
a109 1
int X509_LOOKUP_shutdown(X509_LOOKUP *ctx)
d111 3
a113 3
	if (ctx->method == NULL) return 0;
	if (ctx->method->shutdown != NULL)
		return ctx->method->shutdown(ctx);
d115 1
a115 1
		return 1;
d118 6
a123 2
int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,
	     char **ret)
d125 1
a125 1
	if (ctx->method == NULL) return -1;
d127 1
a127 1
		return ctx->method->ctrl(ctx,cmd,argc,argl,ret);
d129 1
a129 1
		return 1;
d132 5
a136 2
int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,
	     X509_OBJECT *ret)
d139 3
a141 3
		return X509_LU_FAIL;
	if (ctx->skip) return 0;
	return ctx->method->get_by_subject(ctx,type,name,ret);
d144 6
a149 2
int X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name,
	     ASN1_INTEGER *serial, X509_OBJECT *ret)
d153 2
a154 2
		return X509_LU_FAIL;
	return ctx->method->get_by_issuer_serial(ctx,type,name,serial,ret);
d157 6
a162 2
int X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type,
	     unsigned char *bytes, int len, X509_OBJECT *ret)
d165 2
a166 2
		return X509_LU_FAIL;
	return ctx->method->get_by_fingerprint(ctx,type,bytes,len,ret);
d169 6
a174 2
int X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str, int len,
	     X509_OBJECT *ret)
d177 2
a178 2
		return X509_LU_FAIL;
	return ctx->method->get_by_alias(ctx,type,str,len,ret);
d181 13
a193 15
  
static int x509_object_cmp(const X509_OBJECT * const *a, const X509_OBJECT * const *b)
  	{
 	int ret;

 	ret=((*a)->type - (*b)->type);
 	if (ret) return ret;
 	switch ((*a)->type)
 		{
 	case X509_LU_X509:
 		ret=X509_subject_name_cmp((*a)->data.x509,(*b)->data.x509);
 		break;
 	case X509_LU_CRL:
 		ret=X509_CRL_cmp((*a)->data.crl,(*b)->data.crl);
 		break;
d195 1
a195 2
		/* abort(); */
		return 0;
d197 1
a197 1
	return ret;
d200 22
a221 1
X509_STORE *X509_STORE_new(void)
d225 3
a227 3
	if ((ret=(X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL)
		return NULL;
	ret->objs = sk_X509_OBJECT_new(x509_object_cmp);
d229 4
a232 18
	ret->get_cert_methods=sk_X509_LOOKUP_new_null();
	ret->verify=0;
	ret->verify_cb=0;

	ret->purpose = 0;
	ret->trust = 0;

	ret->flags = 0;

	ret->get_issuer = 0;
	ret->check_issued = 0;
	ret->check_revocation = 0;
	ret->get_crl = 0;
	ret->check_crl = 0;
	ret->cert_crl = 0;
	ret->cleanup = 0;

	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data);
d234 1
a234 2
	ret->depth=0;
	return ret;
d237 2
a238 1
static void cleanup(X509_OBJECT *a)
d249 1
a249 3
		{
		/* abort(); */
		}
d251 1
a251 1
	OPENSSL_free(a);
d254 2
a255 1
void X509_STORE_free(X509_STORE *vfy)
d258 1
a258 1
	STACK_OF(X509_LOOKUP) *sk;
a260 3
	if (vfy == NULL)
	    return;

d262 1
a262 1
	for (i=0; i<sk_X509_LOOKUP_num(sk); i++)
d264 1
a264 1
		lu=sk_X509_LOOKUP_value(sk,i);
d268 1
a268 2
	sk_X509_LOOKUP_free(sk);
	sk_X509_OBJECT_pop_free(vfy->objs, cleanup);
d270 4
a273 2
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE, vfy, &vfy->ex_data);
	OPENSSL_free(vfy);
d276 3
a278 1
X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)
d281 1
a281 1
	STACK_OF(X509_LOOKUP) *sk;
d285 1
a285 1
	for (i=0; i<sk_X509_LOOKUP_num(sk); i++)
d287 1
a287 1
		lu=sk_X509_LOOKUP_value(sk,i);
d290 1
a290 1
			return lu;
d296 1
a296 1
		return NULL;
d300 2
a301 2
		if (sk_X509_LOOKUP_push(v->get_cert_methods,lu))
			return lu;
d305 1
a305 1
			return NULL;
d310 5
a314 2
int X509_STORE_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,
	     X509_OBJECT *ret)
d321 1
a321 1
	tmp=X509_OBJECT_retrieve_by_subject(ctx->objs,type,name);
d325 1
a325 1
		for (i=vs->current_method; i<sk_X509_LOOKUP_num(ctx->get_cert_methods); i++)
d327 1
a327 1
			lu=sk_X509_LOOKUP_value(ctx->get_cert_methods,i);
d332 1
a332 1
				return j;
d342 1
a342 1
			return 0;
d353 1
a353 68
	return 1;
	}

int X509_STORE_add_cert(X509_STORE *ctx, X509 *x)
	{
	X509_OBJECT *obj;
	int ret=1;

	if (x == NULL) return 0;
	obj=(X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));
	if (obj == NULL)
		{
		X509err(X509_F_X509_STORE_ADD_CERT,ERR_R_MALLOC_FAILURE);
		return 0;
		}
	obj->type=X509_LU_X509;
	obj->data.x509=x;

	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);

	X509_OBJECT_up_ref_count(obj);


	if (X509_OBJECT_retrieve_match(ctx->objs, obj))
		{
		X509_OBJECT_free_contents(obj);
		OPENSSL_free(obj);
		X509err(X509_F_X509_STORE_ADD_CERT,X509_R_CERT_ALREADY_IN_HASH_TABLE);
		ret=0;
		} 
	else sk_X509_OBJECT_push(ctx->objs, obj);

	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);

	return ret;
	}

int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)
	{
	X509_OBJECT *obj;
	int ret=1;

	if (x == NULL) return 0;
	obj=(X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));
	if (obj == NULL)
		{
		X509err(X509_F_X509_STORE_ADD_CRL,ERR_R_MALLOC_FAILURE);
		return 0;
		}
	obj->type=X509_LU_CRL;
	obj->data.crl=x;

	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);

	X509_OBJECT_up_ref_count(obj);

	if (X509_OBJECT_retrieve_match(ctx->objs, obj))
		{
		X509_OBJECT_free_contents(obj);
		OPENSSL_free(obj);
		X509err(X509_F_X509_STORE_ADD_CRL,X509_R_CERT_ALREADY_IN_HASH_TABLE);
		ret=0;
		}
	else sk_X509_OBJECT_push(ctx->objs, obj);

	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);

	return ret;
d356 2
a357 1
void X509_OBJECT_up_ref_count(X509_OBJECT *a)
d370 2
a371 1
void X509_OBJECT_free_contents(X509_OBJECT *a)
d384 4
a387 2
int X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, int type,
	     X509_NAME *name)
d389 1
a389 1
	X509_OBJECT stmp;
d409 1
a409 2
		/* abort(); */
		return -1;
d412 2
a413 1
	return sk_X509_OBJECT_find(h,&stmp);
d416 5
a420 94
X509_OBJECT *X509_OBJECT_retrieve_by_subject(STACK_OF(X509_OBJECT) *h, int type,
	     X509_NAME *name)
{
	int idx;
	idx = X509_OBJECT_idx_by_subject(h, type, name);
	if (idx==-1) return NULL;
	return sk_X509_OBJECT_value(h, idx);
}

X509_OBJECT *X509_OBJECT_retrieve_match(STACK_OF(X509_OBJECT) *h, X509_OBJECT *x)
{
	int idx, i;
	X509_OBJECT *obj;
	idx = sk_X509_OBJECT_find(h, x);
	if (idx == -1) return NULL;
	if (x->type != X509_LU_X509) return sk_X509_OBJECT_value(h, idx);
	for (i = idx; i < sk_X509_OBJECT_num(h); i++)
		{
		obj = sk_X509_OBJECT_value(h, i);
		if (x509_object_cmp((const X509_OBJECT **)&obj, (const X509_OBJECT **)&x))
			return NULL;
		if ((x->type != X509_LU_X509) || !X509_cmp(obj->data.x509, x->data.x509))
			return obj;
		}
	return NULL;
}


/* Try to get issuer certificate from store. Due to limitations
 * of the API this can only retrieve a single certificate matching
 * a given subject name. However it will fill the cache with all
 * matching certificates, so we can examine the cache for all 
 * matches.
 *
 * Return values are:
 *  1 lookup successful.
 *  0 certificate not found.
 * -1 some other error.
 */


int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
{
	X509_NAME *xn;
	X509_OBJECT obj, *pobj;
	int i, ok, idx;
	xn=X509_get_issuer_name(x);
	ok=X509_STORE_get_by_subject(ctx,X509_LU_X509,xn,&obj);
	if (ok != X509_LU_X509)
		{
		if (ok == X509_LU_RETRY)
			{
			X509_OBJECT_free_contents(&obj);
			X509err(X509_F_X509_VERIFY_CERT,X509_R_SHOULD_RETRY);
			return -1;
			}
		else if (ok != X509_LU_FAIL)
			{
			X509_OBJECT_free_contents(&obj);
			/* not good :-(, break anyway */
			return -1;
			}
		return 0;
		}
	/* If certificate matches all OK */
	if (ctx->check_issued(ctx, x, obj.data.x509))
		{
		*issuer = obj.data.x509;
		return 1;
		}
	X509_OBJECT_free_contents(&obj);
	/* Else find index of first matching cert */
	idx = X509_OBJECT_idx_by_subject(ctx->ctx->objs, X509_LU_X509, xn);
	/* This shouldn't normally happen since we already have one match */
	if (idx == -1) return 0;

	/* Look through all matching certificates for a suitable issuer */
	for (i = idx; i < sk_X509_OBJECT_num(ctx->ctx->objs); i++)
		{
		pobj = sk_X509_OBJECT_value(ctx->ctx->objs, i);
		/* See if we've ran out of matches */
		if (pobj->type != X509_LU_X509) return 0;
		if (X509_NAME_cmp(xn, X509_get_subject_name(pobj->data.x509))) return 0;
		if (ctx->check_issued(ctx, x, pobj->data.x509))
			{
			*issuer = pobj->data.x509;
			X509_OBJECT_up_ref_count(pobj);
			return 1;
			}
		}
	return 0;
}

void X509_STORE_set_flags(X509_STORE *ctx, long flags)
d422 11
a432 1
	ctx->flags |= flags;
d435 2
a436 1
int X509_STORE_set_purpose(X509_STORE *ctx, int purpose)
d438 7
a444 6
	return X509_PURPOSE_set(&ctx->purpose, purpose);
	}

int X509_STORE_set_trust(X509_STORE *ctx, int trust)
	{
	return X509_TRUST_set(&ctx->trust, trust);
a446 2
IMPLEMENT_STACK_OF(X509_LOOKUP)
IMPLEMENT_STACK_OF(X509_OBJECT)
@


1.1.1.3
log
@import of OpenSSL 0.9.8h
@
text
@d190 4
a193 2
	if ((ret->param = X509_VERIFY_PARAM_new()) == NULL)
		return NULL;
d205 1
a246 2
	if (vfy->param)
		X509_VERIFY_PARAM_free(vfy->param);
d501 1
a501 1
			X509err(X509_F_X509_STORE_CTX_GET1_ISSUER,X509_R_SHOULD_RETRY);
d541 1
a541 1
int X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags)
d543 1
a543 7
	return X509_VERIFY_PARAM_set_flags(ctx->param, flags);
	}

int X509_STORE_set_depth(X509_STORE *ctx, int depth)
	{
	X509_VERIFY_PARAM_set_depth(ctx->param, depth);
	return 1;
d548 1
a548 1
	return X509_VERIFY_PARAM_set_purpose(ctx->param, purpose);
d553 1
a553 6
	return X509_VERIFY_PARAM_set_trust(ctx->param, trust);
	}

int X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *param)
	{
	return X509_VERIFY_PARAM_set1(ctx->param, param);
@


1.1.1.4
log
@import OpenSSL-1.0.0a
@
text
@a198 2
	ret->lookup_certs = 0;
	ret->lookup_crls = 0;
d201 1
a201 7
	if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data))
		{
		sk_X509_OBJECT_free(ret->objs);
		OPENSSL_free(ret);
		return NULL;
		}

a288 1
	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
a289 1
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
d291 1
a291 1
	if (tmp == NULL || type == X509_LU_CRL)
d343 1
d417 2
a418 2
static int x509_object_idx_cnt(STACK_OF(X509_OBJECT) *h, int type,
	     X509_NAME *name, int *pnmatch)
a424 1
	int idx;
d444 1
a444 23
	idx = sk_X509_OBJECT_find(h,&stmp);
	if (idx >= 0 && pnmatch)
		{
		int tidx;
		const X509_OBJECT *tobj, *pstmp;
		*pnmatch = 1;
		pstmp = &stmp;
		for (tidx = idx + 1; tidx < sk_X509_OBJECT_num(h); tidx++)
			{
			tobj = sk_X509_OBJECT_value(h, tidx);
			if (x509_object_cmp(&tobj, &pstmp))
				break;
			(*pnmatch)++;
			}
		}
	return idx;
	}


int X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, int type,
	     X509_NAME *name)
	{
	return x509_object_idx_cnt(h, type, name, NULL);
d449 1
a449 1
	{
d454 1
a454 96
	}

STACK_OF(X509)* X509_STORE_get1_certs(X509_STORE_CTX *ctx, X509_NAME *nm)
	{
	int i, idx, cnt;
	STACK_OF(X509) *sk;
	X509 *x;
	X509_OBJECT *obj;
	sk = sk_X509_new_null();
	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
	idx = x509_object_idx_cnt(ctx->ctx->objs, X509_LU_X509, nm, &cnt);
	if (idx < 0)
		{
		/* Nothing found in cache: do lookup to possibly add new
		 * objects to cache
		 */
		X509_OBJECT xobj;
		CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
		if (!X509_STORE_get_by_subject(ctx, X509_LU_X509, nm, &xobj))
			{
			sk_X509_free(sk);
			return NULL;
			}
		X509_OBJECT_free_contents(&xobj);
		CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
		idx = x509_object_idx_cnt(ctx->ctx->objs,X509_LU_X509,nm, &cnt);
		if (idx < 0)
			{
			CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
			sk_X509_free(sk);
			return NULL;
			}
		}
	for (i = 0; i < cnt; i++, idx++)
		{
		obj = sk_X509_OBJECT_value(ctx->ctx->objs, idx);
		x = obj->data.x509;
		CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
		if (!sk_X509_push(sk, x))
			{
			CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
			X509_free(x);
			sk_X509_pop_free(sk, X509_free);
			return NULL;
			}
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
	return sk;

	}

STACK_OF(X509_CRL)* X509_STORE_get1_crls(X509_STORE_CTX *ctx, X509_NAME *nm)
	{
	int i, idx, cnt;
	STACK_OF(X509_CRL) *sk;
	X509_CRL *x;
	X509_OBJECT *obj, xobj;
	sk = sk_X509_CRL_new_null();
	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
	/* Check cache first */
	idx = x509_object_idx_cnt(ctx->ctx->objs, X509_LU_CRL, nm, &cnt);

	/* Always do lookup to possibly add new CRLs to cache
	 */
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
	if (!X509_STORE_get_by_subject(ctx, X509_LU_CRL, nm, &xobj))
		{
		sk_X509_CRL_free(sk);
		return NULL;
		}
	X509_OBJECT_free_contents(&xobj);
	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
	idx = x509_object_idx_cnt(ctx->ctx->objs,X509_LU_CRL, nm, &cnt);
	if (idx < 0)
		{
		CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
		sk_X509_CRL_free(sk);
		return NULL;
		}

	for (i = 0; i < cnt; i++, idx++)
		{
		obj = sk_X509_OBJECT_value(ctx->ctx->objs, idx);
		x = obj->data.crl;
		CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509_CRL);
		if (!sk_X509_CRL_push(sk, x))
			{
			CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
			X509_CRL_free(x);
			sk_X509_CRL_pop_free(sk, X509_CRL_free);
			return NULL;
			}
		}
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
	return sk;
	}
d457 1
a457 1
	{
d462 1
a462 2
	if ((x->type != X509_LU_X509) && (x->type != X509_LU_CRL))
		return sk_X509_OBJECT_value(h, idx);
d468 1
a468 11
		if (x->type == X509_LU_X509)
			{
			if (!X509_cmp(obj->data.x509, x->data.x509))
				return obj;
			}
		else if (x->type == X509_LU_CRL)
			{
			if (!X509_CRL_match(obj->data.crl, x->data.crl))
				return obj;
			}
		else
d472 1
a472 1
	}
d478 1
a478 1
 * matching certificates, so we can examine the cache for all
d486 2
d489 1
a489 1
	{
d492 1
a492 1
	int i, ok, idx, ret;
d518 4
d523 2
a524 5
	/* Else find index of first cert accepted by 'check_issued' */
	ret = 0;
	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
	idx = X509_OBJECT_idx_by_subject(ctx->ctx->objs, X509_LU_X509, xn);
	if (idx != -1) /* should be true as we've had at least one match */
d526 5
a530 2
		/* Look through all matching certs for suitable issuer */
		for (i = idx; i < sk_X509_OBJECT_num(ctx->ctx->objs); i++)
d532 3
a534 13
			pobj = sk_X509_OBJECT_value(ctx->ctx->objs, i);
			/* See if we've run past the matches */
			if (pobj->type != X509_LU_X509)
				break;
			if (X509_NAME_cmp(xn, X509_get_subject_name(pobj->data.x509)))
				break;
			if (ctx->check_issued(ctx, x, pobj->data.x509))
				{
				*issuer = pobj->data.x509;
				X509_OBJECT_up_ref_count(pobj);
				ret = 1;
				break;
				}
d537 2
a538 3
	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
	return ret;
	}
a563 6
	}

void X509_STORE_set_verify_cb(X509_STORE *ctx,
				  int (*verify_cb)(int, X509_STORE_CTX *))
	{
	ctx->verify_cb = verify_cb;
@


1.1.1.5
log
@import OpenSSL-1.0.1c
@
text
@d90 1
a90 1
		(*ctx->method->free)(ctx);
@


