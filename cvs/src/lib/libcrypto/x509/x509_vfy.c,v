head	1.61;
access;
symbols
	OPENBSD_6_1:1.61.0.4
	OPENBSD_6_1_BASE:1.61;
locks; strict;
comment	@ * @;


1.61
date	2017.02.05.02.33.21;	author beck;	state Exp;
branches;
next	1.60;
commitid	9wgKk17Jx147jx4C;

1.60
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.59;
commitid	kT0fLt3r4lroFJra;

1.59
date	2017.01.21.01.09.54;	author beck;	state Exp;
branches;
next	1.58;
commitid	pGUUSZUBeO40ecSY;

1.58
date	2017.01.21.01.07.25;	author beck;	state Exp;
branches;
next	1.57;
commitid	Uk0z8uaLagyJ11cv;

1.57
date	2017.01.20.00.37.40;	author beck;	state Exp;
branches;
next	1.56;
commitid	EthnYOj9ToaY8dPk;

1.56
date	2017.01.07.13.49.07;	author jsing;	state Exp;
branches;
next	1.55;
commitid	Fylxk4exMLx9WHH6;

1.55
date	2017.01.07.06.45.24;	author jsing;	state Exp;
branches;
next	1.54;
commitid	jAz5Hkg5IiF62Xql;

1.54
date	2017.01.03.05.52.28;	author beck;	state Exp;
branches;
next	1.53;
commitid	61v5hzlsuZb81lCq;

1.53
date	2017.01.03.05.34.48;	author beck;	state Exp;
branches;
next	1.52;
commitid	fCVUAnSEpSgHP8KE;

1.52
date	2016.11.06.10.37.38;	author beck;	state Exp;
branches;
next	1.51;
commitid	iXIbMQChGcQqFsjc;

1.51
date	2016.11.04.18.07.23;	author beck;	state Exp;
branches;
next	1.50;
commitid	pAy02smoQCuRvYaT;

1.50
date	2016.10.02.20.45.04;	author guenther;	state Exp;
branches;
next	1.49;
commitid	86ucgO8UIZJrXUvz;

1.49
date	2016.03.11.07.08.45;	author mmcc;	state Exp;
branches;
next	1.48;
commitid	MTdM7aVFdRMAzAYE;

1.48
date	2015.12.14.03.38.13;	author beck;	state Exp;
branches;
next	1.47;
commitid	5MBXd7S1vHw2oRVf;

1.47
date	2015.10.19.16.32.37;	author beck;	state Exp;
branches;
next	1.46;
commitid	gN6dUlgzg63Qhn8s;

1.46
date	2015.10.02.15.04.45;	author beck;	state Exp;
branches;
next	1.45;
commitid	qCopm45l75mxQGLg;

1.45
date	2015.09.14.16.13.39;	author jsing;	state Exp;
branches;
next	1.44;
commitid	VWU4nt2NNcsil9Tb;

1.44
date	2015.07.19.05.42.55;	author miod;	state Exp;
branches;
next	1.43;
commitid	EpLO0eUSciwiSZcQ;

1.43
date	2015.07.19.01.44.16;	author doug;	state Exp;
branches;
next	1.42;
commitid	vTTBCv8oE1tdrwjk;

1.42
date	2015.06.11.15.58.53;	author jsing;	state Exp;
branches;
next	1.41;
commitid	FXqD4TAHvTNzmJaB;

1.41
date	2015.04.11.16.03.21;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	WnYuC1gPCzN02uAn;

1.40
date	2015.02.11.02.17.59;	author jsing;	state Exp;
branches
	1.40.4.1;
next	1.39;
commitid	VMvTzbeLoIQW8LSk;

1.39
date	2015.02.10.08.33.10;	author jsing;	state Exp;
branches;
next	1.38;
commitid	v5VD2cgZRaYX8ah1;

1.38
date	2014.09.29.04.20.14;	author miod;	state Exp;
branches;
next	1.37;
commitid	iimxK6TJCAnAxWKl;

1.37
date	2014.07.17.07.13.02;	author logan;	state Exp;
branches
	1.37.4.1;
next	1.36;
commitid	ciiB77aUVTuObZMj;

1.36
date	2014.07.12.17.35.23;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	1AG6gnutKEqeuP9z;

1.35
date	2014.07.12.14.58.32;	author miod;	state Exp;
branches;
next	1.34;
commitid	NZQVVrZ7otjs887q;

1.34
date	2014.07.11.12.52.41;	author miod;	state Exp;
branches;
next	1.33;
commitid	h4chyoOInOG2Ra5G;

1.33
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.32;
commitid	yQEL1wOWIearrW15;

1.32
date	2014.07.10.22.45.58;	author jsing;	state Exp;
branches;
next	1.31;
commitid	nzndm3zqPmFurSaK;

1.31
date	2014.07.10.13.58.23;	author jsing;	state Exp;
branches;
next	1.30;
commitid	id8dTrTMtnTn4fqt;

1.30
date	2014.07.09.11.10.51;	author bcook;	state Exp;
branches;
next	1.29;
commitid	lHJTcoC4c5BhEOGj;

1.29
date	2014.06.20.20.59.49;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	sNbZj1qTcgrykfGE;

1.28
date	2014.06.19.21.24.35;	author tedu;	state Exp;
branches;
next	1.27;
commitid	vvIvqfjNsQBKZTFF;

1.27
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	mJUVYpkFBZ0Zv2bG;

1.26
date	2014.05.25.20.28.50;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.20.16.10.10;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.18.01.59.00;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.15.11.50.18;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.29.05.39.27;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.25.18.57.51;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.08.08.13.24;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.30.15.19.38;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.39;	author markus;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches
	1.6.2.1
	1.6.4.1;
next	1.5;

1.5
date	2000.12.15.02.58.14;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.46;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.12.12;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.51;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.42;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.42;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.01;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.53;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.11.21.18.01;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.20.41.53;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.18;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.06.27.05.05.36;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.14.00;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2011.11.03.02.32.15;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2012.01.05.22.59.03;	author djm;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2012.10.13.21.23.44;	author djm;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.04.13.15.16.35;	author miod;	state Exp;
branches;
next	;

1.6.2.1
date	2003.10.01.22.46.19;	author brad;	state Exp;
branches;
next	;

1.6.4.1
date	2003.10.01.15.58.04;	author margarida;	state Exp;
branches;
next	;

1.7.2.1
date	2003.10.31.00.13.15;	author brad;	state Exp;
branches;
next	;

1.37.4.1
date	2015.06.11.16.11.00;	author jsing;	state Exp;
branches;
next	;
commitid	jrR1mmYpHDQoSJAs;

1.40.4.1
date	2015.06.11.16.09.20;	author jsing;	state Exp;
branches;
next	;
commitid	B0KrBXUvDclRlbxZ;


desc
@@


1.61
log
@Kill leak introduced with refactor
ok jsing@@
@
text
@/* $OpenBSD: x509_vfy.c,v 1.60 2017/01/29 17:49:23 beck Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include <openssl/opensslconf.h>

#include <openssl/asn1.h>
#include <openssl/buffer.h>
#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/lhash.h>
#include <openssl/objects.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include "x509_lcl.h"
#include "vpm_int.h"

/* CRL score values */

/* No unhandled critical extensions */

#define CRL_SCORE_NOCRITICAL	0x100

/* certificate is within CRL scope */

#define CRL_SCORE_SCOPE		0x080

/* CRL times valid */

#define CRL_SCORE_TIME		0x040

/* Issuer name matches certificate */

#define CRL_SCORE_ISSUER_NAME	0x020

/* If this score or above CRL is probably valid */

#define CRL_SCORE_VALID (CRL_SCORE_NOCRITICAL|CRL_SCORE_TIME|CRL_SCORE_SCOPE)

/* CRL issuer is certificate issuer */

#define CRL_SCORE_ISSUER_CERT	0x018

/* CRL issuer is on certificate path */

#define CRL_SCORE_SAME_PATH	0x008

/* CRL issuer matches CRL AKID */

#define CRL_SCORE_AKID		0x004

/* Have a delta CRL with valid times */

#define CRL_SCORE_TIME_DELTA	0x002

static int null_callback(int ok, X509_STORE_CTX *e);
static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer);
static X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x);
static int check_chain_extensions(X509_STORE_CTX *ctx);
static int check_name_constraints(X509_STORE_CTX *ctx);
static int check_trust(X509_STORE_CTX *ctx);
static int check_revocation(X509_STORE_CTX *ctx);
static int check_cert(X509_STORE_CTX *ctx);
static int check_policy(X509_STORE_CTX *ctx);

static int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,
    unsigned int *preasons, X509_CRL *crl, X509 *x);
static int get_crl_delta(X509_STORE_CTX *ctx,
    X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x);
static void get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pcrl_score,
    X509_CRL *base, STACK_OF(X509_CRL) *crls);
static void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl, X509 **pissuer,
    int *pcrl_score);
static int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,
    unsigned int *preasons);
static int check_crl_path(X509_STORE_CTX *ctx, X509 *x);
static int check_crl_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *cert_path,
    STACK_OF(X509) *crl_path);

static int internal_verify(X509_STORE_CTX *ctx);

static int
null_callback(int ok, X509_STORE_CTX *e)
{
	return ok;
}

#if 0
static int
x509_subject_cmp(X509 **a, X509 **b)
{
	return X509_subject_name_cmp(*a, *b);
}
#endif

/* Return 1 is a certificate is self signed */
static int
cert_self_signed(X509 *x)
{
	X509_check_purpose(x, -1, 0);
	if (x->ex_flags & EXFLAG_SS)
		return 1;
	else
		return 0;
}

static int
check_id_error(X509_STORE_CTX *ctx, int errcode)
{
	ctx->error = errcode;
	ctx->current_cert = ctx->cert;
	ctx->error_depth = 0;
	return ctx->verify_cb(0, ctx);
}

static int
check_hosts(X509 *x, X509_VERIFY_PARAM_ID *id)
{
	size_t i;
	size_t n = sk_OPENSSL_STRING_num(id->hosts);
	char *name;

	free(id->peername);
	id->peername = NULL;

	for (i = 0; i < n; ++i) {
		name = sk_OPENSSL_STRING_value(id->hosts, i);
		if (X509_check_host(x, name, strlen(name), id->hostflags,
		    &id->peername) > 0)
			return 1;
	}
	return n == 0;
}

static int
check_id(X509_STORE_CTX *ctx)
{
	X509_VERIFY_PARAM *vpm = ctx->param;
	X509_VERIFY_PARAM_ID *id = vpm->id;
	X509 *x = ctx->cert;

	if (id->hosts && check_hosts(x, id) <= 0) {
		if (!check_id_error(ctx, X509_V_ERR_HOSTNAME_MISMATCH))
			return 0;
	}
	if (id->email != NULL && X509_check_email(x, id->email, id->emaillen, 0)
	    <= 0) {
		if (!check_id_error(ctx, X509_V_ERR_EMAIL_MISMATCH))
			return 0;
	}
	if (id->ip != NULL && X509_check_ip(x, id->ip, id->iplen, 0) <= 0) {
		if (!check_id_error(ctx, X509_V_ERR_IP_ADDRESS_MISMATCH))
			return 0;
	}
	return 1;
}

int
X509_verify_cert(X509_STORE_CTX *ctx)
{
	X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
	int bad_chain = 0;
	X509_VERIFY_PARAM *param = ctx->param;
	int depth, i, ok = 0;
	int num, j, retry, trust;
	int (*cb) (int xok, X509_STORE_CTX *xctx);
	STACK_OF(X509) *sktmp = NULL;

	if (ctx->cert == NULL) {
		X509error(X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
		ctx->error = X509_V_ERR_INVALID_CALL;
		return -1;
	}
	if (ctx->chain != NULL) {
		/*
		 * This X509_STORE_CTX has already been used to verify
		 * a cert. We cannot do another one.
		 */
		X509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		ctx->error = X509_V_ERR_INVALID_CALL;
		return -1;
	}
	if (ctx->error != X509_V_ERR_INVALID_CALL) {
		/*
		 * This X509_STORE_CTX has not been properly initialized.
		 */
		X509error(ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
		ctx->error = X509_V_ERR_INVALID_CALL;
		return -1;
	}
	ctx->error = X509_V_OK; /* Initialize to OK */

	cb = ctx->verify_cb;

	/*
	 * First we make sure the chain we are going to build is
	 * present and that the first entry is in place.
	 */
	ctx->chain = sk_X509_new_null();
	if (ctx->chain == NULL || !sk_X509_push(ctx->chain, ctx->cert)) {
		X509error(ERR_R_MALLOC_FAILURE);
		ctx->error = X509_V_ERR_OUT_OF_MEM;
		goto end;
	}
	X509_up_ref(ctx->cert);
	ctx->last_untrusted = 1;

	/* We use a temporary STACK so we can chop and hack at it */
	if (ctx->untrusted != NULL &&
	    (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
		X509error(ERR_R_MALLOC_FAILURE);
		ctx->error = X509_V_ERR_OUT_OF_MEM;
		goto end;
	}

	num = sk_X509_num(ctx->chain);
	x = sk_X509_value(ctx->chain, num - 1);
	depth = param->depth;

	for (;;) {
		/* If we have enough, we break */
		/* FIXME: If this happens, we should take
		 * note of it and, if appropriate, use the
		 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
		 * later.
		 */
		if (depth < num)
			break;
		/* If we are self signed, we break */
		if (cert_self_signed(x))
			break;
		/*
		 * If asked see if we can find issuer in trusted store first
		 */
		if (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {
			ok = ctx->get_issuer(&xtmp, ctx, x);
			if (ok < 0) {
				ctx->error = X509_V_ERR_STORE_LOOKUP;
				goto end;
			}
			/*
			 * If successful for now free up cert so it
			 * will be picked up again later.
			 */
			if (ok > 0) {
				X509_free(xtmp);
				break;
			}
		}
		/* If we were passed a cert chain, use it first */
		if (ctx->untrusted != NULL) {
			xtmp = find_issuer(ctx, sktmp, x);
			if (xtmp != NULL) {
				if (!sk_X509_push(ctx->chain, xtmp)) {
					X509error(ERR_R_MALLOC_FAILURE);
					ctx->error = X509_V_ERR_OUT_OF_MEM;
					ok = 0;
					goto end;
				}
				X509_up_ref(xtmp);
				(void)sk_X509_delete_ptr(sktmp, xtmp);
				ctx->last_untrusted++;
				x = xtmp;
				num++;
				/*
				 * reparse the full chain for the next one
				 */
				continue;
			}
		}
		break;
	}
	/* Remember how many untrusted certs we have */
	j = num;

	/*
	 * At this point, chain should contain a list of untrusted
	 * certificates.  We now need to add at least one trusted one,
	 * if possible, otherwise we complain.
	 */

	do {
		/*
		 * Examine last certificate in chain and see if it is
		 * self signed.
		 */
		i = sk_X509_num(ctx->chain);
		x = sk_X509_value(ctx->chain, i - 1);
		if (cert_self_signed(x)) {
			/* we have a self signed certificate */
			if (i == 1) {
				/*
				 * We have a single self signed
				 * certificate: see if we can find it
				 * in the store. We must have an exact
				 * match to avoid possible
				 * impersonation.
				 */
				ok = ctx->get_issuer(&xtmp, ctx, x);
				if ((ok <= 0) || X509_cmp(x, xtmp)) {
					ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
					ctx->current_cert = x;
					ctx->error_depth = i - 1;
					if (ok == 1)
						X509_free(xtmp);
					bad_chain = 1;
					ok = cb(0, ctx);
					if (!ok)
						goto end;
				} else {
					/*
					 * We have a match: replace
					 * certificate with store
					 * version so we get any trust
					 * settings.
					 */
					X509_free(x);
					x = xtmp;
					(void)sk_X509_set(ctx->chain, i - 1, x);
					ctx->last_untrusted = 0;
				}
			} else {
				/*
				 * extract and save self signed
				 * certificate for later use
				 */
				chain_ss = sk_X509_pop(ctx->chain);
				ctx->last_untrusted--;
				num--;
				j--;
				x = sk_X509_value(ctx->chain, num - 1);
			}
		}
		/* We now lookup certs from the certificate store */
		for (;;) {
			/* If we have enough, we break */
			if (depth < num)
				break;
			/* If we are self signed, we break */
			if (cert_self_signed(x))
				break;
			ok = ctx->get_issuer(&xtmp, ctx, x);

			if (ok < 0) {
				ctx->error = X509_V_ERR_STORE_LOOKUP;
				goto end;
			}
			if (ok == 0)
				break;
			x = xtmp;
			if (!sk_X509_push(ctx->chain, x)) {
				X509_free(xtmp);
				X509error(ERR_R_MALLOC_FAILURE);
				ctx->error = X509_V_ERR_OUT_OF_MEM;
				ok = 0;
				goto end;
			}
			num++;
		}

		/* we now have our chain, lets check it... */
		trust = check_trust(ctx);

		/* If explicitly rejected error */
		if (trust == X509_TRUST_REJECTED) {
			ok = 0;
			goto end;
		}
		/*
		 * If it's not explicitly trusted then check if there
		 * is an alternative chain that could be used. We only
		 * do this if we haven't already checked via
		 * TRUSTED_FIRST and the user hasn't switched off
		 * alternate chain checking
		 */
		retry = 0;
		if (trust != X509_TRUST_TRUSTED &&
		    !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) &&
		    !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
			while (j-- > 1) {
				xtmp2 = sk_X509_value(ctx->chain, j - 1);
				ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
				if (ok < 0)
					goto end;
				/* Check if we found an alternate chain */
				if (ok > 0) {
					/*
					 * Free up the found cert
					 * we'll add it again later
					 */
					X509_free(xtmp);
					/*
					 * Dump all the certs above
					 * this point - we've found an
					 * alternate chain
					 */
					while (num > j) {
						xtmp = sk_X509_pop(ctx->chain);
						X509_free(xtmp);
						num--;
					}
					ctx->last_untrusted = sk_X509_num(ctx->chain);
					retry = 1;
					break;
				}
			}
		}
	} while (retry);

	/*
	 * If not explicitly trusted then indicate error unless it's a single
	 * self signed certificate in which case we've indicated an error already
	 * and set bad_chain == 1
	 */
	if (trust != X509_TRUST_TRUSTED && !bad_chain) {
		if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
			if (ctx->last_untrusted >= num)
				ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
			else
				ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
			ctx->current_cert = x;
		} else {
			if (!sk_X509_push(ctx->chain, chain_ss)) {
				X509_free(chain_ss);
				X509error(ERR_R_MALLOC_FAILURE);
				return 0;
			}
			num++;
			ctx->last_untrusted = num;
			ctx->current_cert = chain_ss;
			ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
			chain_ss = NULL;
		}

		ctx->error_depth = num - 1;
		bad_chain = 1;
		ok = cb(0, ctx);
		if (!ok)
			goto end;
	}

	/* We have the chain complete: now we need to check its purpose */
	ok = check_chain_extensions(ctx);
	if (!ok)
		goto end;

	/* Check name constraints */
	ok = check_name_constraints(ctx);
	if (!ok)
		goto end;

	ok = check_id(ctx);
	if (!ok)
		goto end;
	/*
	 * Check revocation status: we do this after copying parameters because
	 * they may be needed for CRL signature verification.
	 */
	ok = ctx->check_revocation(ctx);
	if (!ok)
		goto end;

	/* At this point, we have a chain and need to verify it */
	if (ctx->verify != NULL)
		ok = ctx->verify(ctx);
	else
		ok = internal_verify(ctx);
	if (!ok)
		goto end;

	/* If we get this far evaluate policies */
	if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
		ok = ctx->check_policy(ctx);

 end:
	if (sktmp != NULL)
		sk_X509_free(sktmp);
	X509_free(chain_ss);

	/* Safety net, error returns must set ctx->error */
	if (ok <= 0 && ctx->error == X509_V_OK)
		ctx->error = X509_V_ERR_UNSPECIFIED;

	/*
	 * Safety net, if user provided verify callback indicates sucess
	 * make sure they have set error to X509_V_OK
	 */
	if (ctx->verify_cb != null_callback && ok == 1)
		ctx->error = X509_V_OK;

	return(ctx->error == X509_V_OK);
}

/* Given a STACK_OF(X509) find the issuer of cert (if any)
 */

static X509 *
find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x)
{
	int i;
	X509 *issuer, *rv = NULL;

	for (i = 0; i < sk_X509_num(sk); i++) {
		issuer = sk_X509_value(sk, i);
		if (ctx->check_issued(ctx, x, issuer)) {
			rv = issuer;
			if (x509_check_cert_time(ctx, rv, -1))
				break;
		}
	}
	return rv;
}

/* Given a possible certificate and issuer check them */

static int
check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)
{
	int ret;

	ret = X509_check_issued(issuer, x);
	if (ret == X509_V_OK)
		return 1;
	/* If we haven't asked for issuer errors don't set ctx */
	if (!(ctx->param->flags & X509_V_FLAG_CB_ISSUER_CHECK))
		return 0;

	ctx->error = ret;
	ctx->current_cert = x;
	ctx->current_issuer = issuer;
	return ctx->verify_cb(0, ctx);
}

/* Alternative lookup method: look from a STACK stored in other_ctx */

static int
get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
{
	*issuer = find_issuer(ctx, ctx->other_ctx, x);
	if (*issuer) {
		CRYPTO_add(&(*issuer)->references, 1, CRYPTO_LOCK_X509);
		return 1;
	} else
		return 0;
}

/* Check a certificate chains extensions for consistency
 * with the supplied purpose
 */

static int
check_chain_extensions(X509_STORE_CTX *ctx)
{
#ifdef OPENSSL_NO_CHAIN_VERIFY
	return 1;
#else
	int i, ok = 0, must_be_ca, plen = 0;
	X509 *x;
	int (*cb)(int xok, X509_STORE_CTX *xctx);
	int proxy_path_length = 0;
	int purpose;
	int allow_proxy_certs;

	cb = ctx->verify_cb;

	/* must_be_ca can have 1 of 3 values:
	   -1: we accept both CA and non-CA certificates, to allow direct
	       use of self-signed certificates (which are marked as CA).
	   0:  we only accept non-CA certificates.  This is currently not
	       used, but the possibility is present for future extensions.
	   1:  we only accept CA certificates.  This is currently used for
	       all certificates in the chain except the leaf certificate.
	*/
	must_be_ca = -1;

	/* CRL path validation */
	if (ctx->parent) {
		allow_proxy_certs = 0;
		purpose = X509_PURPOSE_CRL_SIGN;
	} else {
		allow_proxy_certs =
		    !!(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);
		purpose = ctx->param->purpose;
	}

	/* Check all untrusted certificates */
	for (i = 0; i < ctx->last_untrusted; i++) {
		int ret;
		x = sk_X509_value(ctx->chain, i);
		if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) &&
		    (x->ex_flags & EXFLAG_CRITICAL)) {
			ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;
			ctx->error_depth = i;
			ctx->current_cert = x;
			ok = cb(0, ctx);
			if (!ok)
				goto end;
		}
		if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {
			ctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;
			ctx->error_depth = i;
			ctx->current_cert = x;
			ok = cb(0, ctx);
			if (!ok)
				goto end;
		}
		ret = X509_check_ca(x);
		switch (must_be_ca) {
		case -1:
			if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&
			    (ret != 1) && (ret != 0)) {
				ret = 0;
				ctx->error = X509_V_ERR_INVALID_CA;
			} else
				ret = 1;
			break;
		case 0:
			if (ret != 0) {
				ret = 0;
				ctx->error = X509_V_ERR_INVALID_NON_CA;
			} else
				ret = 1;
			break;
		default:
			if ((ret == 0) ||
			    ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&
			    (ret != 1))) {
				ret = 0;
				ctx->error = X509_V_ERR_INVALID_CA;
			} else
				ret = 1;
			break;
		}
		if (ret == 0) {
			ctx->error_depth = i;
			ctx->current_cert = x;
			ok = cb(0, ctx);
			if (!ok)
				goto end;
		}
		if (ctx->param->purpose > 0) {
			ret = X509_check_purpose(x, purpose, must_be_ca > 0);
			if ((ret == 0) ||
			    ((ctx->param->flags & X509_V_FLAG_X509_STRICT) &&
			    (ret != 1))) {
				ctx->error = X509_V_ERR_INVALID_PURPOSE;
				ctx->error_depth = i;
				ctx->current_cert = x;
				ok = cb(0, ctx);
				if (!ok)
					goto end;
			}
		}
		/* Check pathlen if not self issued */
		if ((i > 1) && !(x->ex_flags & EXFLAG_SI) &&
		    (x->ex_pathlen != -1) &&
		    (plen > (x->ex_pathlen + proxy_path_length + 1))) {
			ctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;
			ctx->error_depth = i;
			ctx->current_cert = x;
			ok = cb(0, ctx);
			if (!ok)
				goto end;
		}
		/* Increment path length if not self issued */
		if (!(x->ex_flags & EXFLAG_SI))
			plen++;
		/* If this certificate is a proxy certificate, the next
		   certificate must be another proxy certificate or a EE
		   certificate.  If not, the next certificate must be a
		   CA certificate.  */
		if (x->ex_flags & EXFLAG_PROXY) {
			if (x->ex_pcpathlen != -1 && i > x->ex_pcpathlen) {
				ctx->error =
				    X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;
				ctx->error_depth = i;
				ctx->current_cert = x;
				ok = cb(0, ctx);
				if (!ok)
					goto end;
			}
			proxy_path_length++;
			must_be_ca = 0;
		} else
			must_be_ca = 1;
	}
	ok = 1;

end:
	return ok;
#endif
}

static int
check_name_constraints(X509_STORE_CTX *ctx)
{
	X509 *x;
	int i, j, rv;

	/* Check name constraints for all certificates */
	for (i = sk_X509_num(ctx->chain) - 1; i >= 0; i--) {
		x = sk_X509_value(ctx->chain, i);
		/* Ignore self issued certs unless last in chain */
		if (i && (x->ex_flags & EXFLAG_SI))
			continue;
		/* Check against constraints for all certificates higher in
		 * chain including trust anchor. Trust anchor not strictly
		 * speaking needed but if it includes constraints it is to be
		 * assumed it expects them to be obeyed.
		 */
		for (j = sk_X509_num(ctx->chain) - 1; j > i; j--) {
			NAME_CONSTRAINTS *nc = sk_X509_value(ctx->chain, j)->nc;
			if (nc) {
				rv = NAME_CONSTRAINTS_check(x, nc);
				if (rv != X509_V_OK) {
					ctx->error = rv;
					ctx->error_depth = i;
					ctx->current_cert = x;
					if (!ctx->verify_cb(0, ctx))
						return 0;
				}
			}
		}
	}
	return 1;
}

/* Given a certificate try and find an exact match in the store */

static X509 *lookup_cert_match(X509_STORE_CTX *ctx, X509 *x)
{
	STACK_OF(X509) *certs;
	X509 *xtmp = NULL;
	size_t i;

	/* Lookup all certs with matching subject name */
	certs = ctx->lookup_certs(ctx, X509_get_subject_name(x));
	if (certs == NULL)
		return NULL;

	/* Look for exact match */
	for (i = 0; i < sk_X509_num(certs); i++) {
		xtmp = sk_X509_value(certs, i);
		if (!X509_cmp(xtmp, x))
			break;
	}

	if (i < sk_X509_num(certs))
		X509_up_ref(xtmp);
	else
		xtmp = NULL;

	sk_X509_pop_free(certs, X509_free);
	return xtmp;
}

static int check_trust(X509_STORE_CTX *ctx)
{
	size_t i;
	int ok;
	X509 *x = NULL;
	int (*cb) (int xok, X509_STORE_CTX *xctx);

	cb = ctx->verify_cb;
	/* Check all trusted certificates in chain */
	for (i = ctx->last_untrusted; i < sk_X509_num(ctx->chain); i++) {
		x = sk_X509_value(ctx->chain, i);
		ok = X509_check_trust(x, ctx->param->trust, 0);

		/* If explicitly trusted return trusted */
		if (ok == X509_TRUST_TRUSTED)
			return X509_TRUST_TRUSTED;
		/*
		 * If explicitly rejected notify callback and reject if not
		 * overridden.
		 */
		if (ok == X509_TRUST_REJECTED) {
			ctx->error_depth = i;
			ctx->current_cert = x;
			ctx->error = X509_V_ERR_CERT_REJECTED;
			ok = cb(0, ctx);
			if (!ok)
				return X509_TRUST_REJECTED;
		}
	}
	/*
	 * If we accept partial chains and have at least one trusted certificate
	 * return success.
	 */
	if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {
		X509 *mx;
		if (ctx->last_untrusted < (int)sk_X509_num(ctx->chain))
			return X509_TRUST_TRUSTED;
		x = sk_X509_value(ctx->chain, 0);
		mx = lookup_cert_match(ctx, x);
		if (mx) {
			(void)sk_X509_set(ctx->chain, 0, mx);
			X509_free(x);
			ctx->last_untrusted = 0;
			return X509_TRUST_TRUSTED;
		}
	}

	/*
	 * If no trusted certs in chain at all return untrusted and allow
	 * standard (no issuer cert) etc errors to be indicated.
	 */
	return X509_TRUST_UNTRUSTED;
}

static int
check_revocation(X509_STORE_CTX *ctx)
{
	int i, last, ok;

	if (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK))
		return 1;
	if (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL)
		last = sk_X509_num(ctx->chain) - 1;
	else {
		/* If checking CRL paths this isn't the EE certificate */
		if (ctx->parent)
			return 1;
		last = 0;
	}
	for (i = 0; i <= last; i++) {
		ctx->error_depth = i;
		ok = check_cert(ctx);
		if (!ok)
			return ok;
	}
	return 1;
}

static int
check_cert(X509_STORE_CTX *ctx)
{
	X509_CRL *crl = NULL, *dcrl = NULL;
	X509 *x;
	int ok = 0, cnum;
	unsigned int last_reasons;

	cnum = ctx->error_depth;
	x = sk_X509_value(ctx->chain, cnum);
	ctx->current_cert = x;
	ctx->current_issuer = NULL;
	ctx->current_crl_score = 0;
	ctx->current_reasons = 0;
	while (ctx->current_reasons != CRLDP_ALL_REASONS) {
		last_reasons = ctx->current_reasons;
		/* Try to retrieve relevant CRL */
		if (ctx->get_crl)
			ok = ctx->get_crl(ctx, &crl, x);
		else
			ok = get_crl_delta(ctx, &crl, &dcrl, x);
		/* If error looking up CRL, nothing we can do except
		 * notify callback
		 */
		if (!ok) {
			ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
			ok = ctx->verify_cb(0, ctx);
			goto err;
		}
		ctx->current_crl = crl;
		ok = ctx->check_crl(ctx, crl);
		if (!ok)
			goto err;

		if (dcrl) {
			ok = ctx->check_crl(ctx, dcrl);
			if (!ok)
				goto err;
			ok = ctx->cert_crl(ctx, dcrl, x);
			if (!ok)
				goto err;
		} else
			ok = 1;

		/* Don't look in full CRL if delta reason is removefromCRL */
		if (ok != 2) {
			ok = ctx->cert_crl(ctx, crl, x);
			if (!ok)
				goto err;
		}

		ctx->current_crl = NULL;
		X509_CRL_free(crl);
		X509_CRL_free(dcrl);
		crl = NULL;
		dcrl = NULL;
		/* If reasons not updated we wont get anywhere by
		 * another iteration, so exit loop.
		 */
		if (last_reasons == ctx->current_reasons) {
			ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
			ok = ctx->verify_cb(0, ctx);
			goto err;
		}
	}

err:
	ctx->current_crl = NULL;
	X509_CRL_free(crl);
	X509_CRL_free(dcrl);
	return ok;
}

/* Check CRL times against values in X509_STORE_CTX */

static int
check_crl_time(X509_STORE_CTX *ctx, X509_CRL *crl, int notify)
{
	time_t *ptime = NULL;
	int i;

	if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)
		return (1);

	if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
		ptime = &ctx->param->check_time;

	if (notify)
		ctx->current_crl = crl;

	i = X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);
	if (i == 0) {
		if (!notify)
			return 0;
		ctx->error = X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;
		if (!ctx->verify_cb(0, ctx))
			return 0;
	}

	if (i > 0) {
		if (!notify)
			return 0;
		ctx->error = X509_V_ERR_CRL_NOT_YET_VALID;
		if (!ctx->verify_cb(0, ctx))
			return 0;
	}

	if (X509_CRL_get_nextUpdate(crl)) {
		i = X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);

		if (i == 0) {
			if (!notify)
				return 0;
			ctx->error = X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;
			if (!ctx->verify_cb(0, ctx))
				return 0;
		}
		/* Ignore expiry of base CRL is delta is valid */
		if ((i < 0) &&
		    !(ctx->current_crl_score & CRL_SCORE_TIME_DELTA)) {
			if (!notify)
				return 0;
			ctx->error = X509_V_ERR_CRL_HAS_EXPIRED;
			if (!ctx->verify_cb(0, ctx))
				return 0;
		}
	}

	if (notify)
		ctx->current_crl = NULL;

	return 1;
}

static int
get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
    X509 **pissuer, int *pscore, unsigned int *preasons,
    STACK_OF(X509_CRL) *crls)
{
	int i, crl_score, best_score = *pscore;
	unsigned int reasons, best_reasons = 0;
	X509 *x = ctx->current_cert;
	X509_CRL *crl, *best_crl = NULL;
	X509 *crl_issuer = NULL, *best_crl_issuer = NULL;

	for (i = 0; i < sk_X509_CRL_num(crls); i++) {
		crl = sk_X509_CRL_value(crls, i);
		reasons = *preasons;
		crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);

		if (crl_score > best_score) {
			best_crl = crl;
			best_crl_issuer = crl_issuer;
			best_score = crl_score;
			best_reasons = reasons;
		}
	}

	if (best_crl) {
		if (*pcrl)
			X509_CRL_free(*pcrl);
		*pcrl = best_crl;
		*pissuer = best_crl_issuer;
		*pscore = best_score;
		*preasons = best_reasons;
		CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);
		if (*pdcrl) {
			X509_CRL_free(*pdcrl);
			*pdcrl = NULL;
		}
		get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);
	}

	if (best_score >= CRL_SCORE_VALID)
		return 1;

	return 0;
}

/* Compare two CRL extensions for delta checking purposes. They should be
 * both present or both absent. If both present all fields must be identical.
 */

static int
crl_extension_match(X509_CRL *a, X509_CRL *b, int nid)
{
	ASN1_OCTET_STRING *exta, *extb;
	int i;

	i = X509_CRL_get_ext_by_NID(a, nid, -1);
	if (i >= 0) {
		/* Can't have multiple occurrences */
		if (X509_CRL_get_ext_by_NID(a, nid, i) != -1)
			return 0;
		exta = X509_EXTENSION_get_data(X509_CRL_get_ext(a, i));
	} else
		exta = NULL;

	i = X509_CRL_get_ext_by_NID(b, nid, -1);

	if (i >= 0) {
		if (X509_CRL_get_ext_by_NID(b, nid, i) != -1)
			return 0;
		extb = X509_EXTENSION_get_data(X509_CRL_get_ext(b, i));
	} else
		extb = NULL;

	if (!exta && !extb)
		return 1;

	if (!exta || !extb)
		return 0;

	if (ASN1_OCTET_STRING_cmp(exta, extb))
		return 0;

	return 1;
}

/* See if a base and delta are compatible */

static int
check_delta_base(X509_CRL *delta, X509_CRL *base)
{
	/* Delta CRL must be a delta */
	if (!delta->base_crl_number)
		return 0;
	/* Base must have a CRL number */
	if (!base->crl_number)
		return 0;
	/* Issuer names must match */
	if (X509_NAME_cmp(X509_CRL_get_issuer(base),
	    X509_CRL_get_issuer(delta)))
		return 0;
	/* AKID and IDP must match */
	if (!crl_extension_match(delta, base, NID_authority_key_identifier))
		return 0;
	if (!crl_extension_match(delta, base, NID_issuing_distribution_point))
		return 0;
	/* Delta CRL base number must not exceed Full CRL number. */
	if (ASN1_INTEGER_cmp(delta->base_crl_number, base->crl_number) > 0)
		return 0;
	/* Delta CRL number must exceed full CRL number */
	if (ASN1_INTEGER_cmp(delta->crl_number, base->crl_number) > 0)
		return 1;
	return 0;
}

/* For a given base CRL find a delta... maybe extend to delta scoring
 * or retrieve a chain of deltas...
 */

static void
get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pscore, X509_CRL *base,
    STACK_OF(X509_CRL) *crls)
{
	X509_CRL *delta;
	int i;

	if (!(ctx->param->flags & X509_V_FLAG_USE_DELTAS))
		return;
	if (!((ctx->current_cert->ex_flags | base->flags) & EXFLAG_FRESHEST))
		return;
	for (i = 0; i < sk_X509_CRL_num(crls); i++) {
		delta = sk_X509_CRL_value(crls, i);
		if (check_delta_base(delta, base)) {
			if (check_crl_time(ctx, delta, 0))
				*pscore |= CRL_SCORE_TIME_DELTA;
			CRYPTO_add(&delta->references, 1, CRYPTO_LOCK_X509_CRL);
			*dcrl = delta;
			return;
		}
	}
	*dcrl = NULL;
}

/* For a given CRL return how suitable it is for the supplied certificate 'x'.
 * The return value is a mask of several criteria.
 * If the issuer is not the certificate issuer this is returned in *pissuer.
 * The reasons mask is also used to determine if the CRL is suitable: if
 * no new reasons the CRL is rejected, otherwise reasons is updated.
 */

static int
get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer, unsigned int *preasons,
    X509_CRL *crl, X509 *x)
{
	int crl_score = 0;
	unsigned int tmp_reasons = *preasons, crl_reasons;

	/* First see if we can reject CRL straight away */

	/* Invalid IDP cannot be processed */
	if (crl->idp_flags & IDP_INVALID)
		return 0;
	/* Reason codes or indirect CRLs need extended CRL support */
	if (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT)) {
		if (crl->idp_flags & (IDP_INDIRECT | IDP_REASONS))
			return 0;
	} else if (crl->idp_flags & IDP_REASONS) {
		/* If no new reasons reject */
		if (!(crl->idp_reasons & ~tmp_reasons))
			return 0;
	}
	/* Don't process deltas at this stage */
	else if (crl->base_crl_number)
		return 0;
	/* If issuer name doesn't match certificate need indirect CRL */
	if (X509_NAME_cmp(X509_get_issuer_name(x), X509_CRL_get_issuer(crl))) {
		if (!(crl->idp_flags & IDP_INDIRECT))
			return 0;
	} else
		crl_score |= CRL_SCORE_ISSUER_NAME;

	if (!(crl->flags & EXFLAG_CRITICAL))
		crl_score |= CRL_SCORE_NOCRITICAL;

	/* Check expiry */
	if (check_crl_time(ctx, crl, 0))
		crl_score |= CRL_SCORE_TIME;

	/* Check authority key ID and locate certificate issuer */
	crl_akid_check(ctx, crl, pissuer, &crl_score);

	/* If we can't locate certificate issuer at this point forget it */

	if (!(crl_score & CRL_SCORE_AKID))
		return 0;

	/* Check cert for matching CRL distribution points */

	if (crl_crldp_check(x, crl, crl_score, &crl_reasons)) {
		/* If no new reasons reject */
		if (!(crl_reasons & ~tmp_reasons))
			return 0;
		tmp_reasons |= crl_reasons;
		crl_score |= CRL_SCORE_SCOPE;
	}

	*preasons = tmp_reasons;

	return crl_score;
}

static void
crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl, X509 **pissuer,
    int *pcrl_score)
{
	X509 *crl_issuer = NULL;
	X509_NAME *cnm = X509_CRL_get_issuer(crl);
	int cidx = ctx->error_depth;
	int i;

	if (cidx != sk_X509_num(ctx->chain) - 1)
		cidx++;

	crl_issuer = sk_X509_value(ctx->chain, cidx);

	if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {
		if (*pcrl_score & CRL_SCORE_ISSUER_NAME) {
			*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_ISSUER_CERT;
			*pissuer = crl_issuer;
			return;
		}
	}

	for (cidx++; cidx < sk_X509_num(ctx->chain); cidx++) {
		crl_issuer = sk_X509_value(ctx->chain, cidx);
		if (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))
			continue;
		if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {
			*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_SAME_PATH;
			*pissuer = crl_issuer;
			return;
		}
	}

	/* Anything else needs extended CRL support */

	if (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT))
		return;

	/* Otherwise the CRL issuer is not on the path. Look for it in the
	 * set of untrusted certificates.
	 */
	for (i = 0; i < sk_X509_num(ctx->untrusted); i++) {
		crl_issuer = sk_X509_value(ctx->untrusted, i);
		if (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))
			continue;
		if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {
			*pissuer = crl_issuer;
			*pcrl_score |= CRL_SCORE_AKID;
			return;
		}
	}
}

/* Check the path of a CRL issuer certificate. This creates a new
 * X509_STORE_CTX and populates it with most of the parameters from the
 * parent. This could be optimised somewhat since a lot of path checking
 * will be duplicated by the parent, but this will rarely be used in
 * practice.
 */

static int
check_crl_path(X509_STORE_CTX *ctx, X509 *x)
{
	X509_STORE_CTX crl_ctx;
	int ret;

	/* Don't allow recursive CRL path validation */
	if (ctx->parent)
		return 0;
	if (!X509_STORE_CTX_init(&crl_ctx, ctx->ctx, x, ctx->untrusted)) {
		ret = -1;
		goto err;
	}

	crl_ctx.crls = ctx->crls;
	/* Copy verify params across */
	X509_STORE_CTX_set0_param(&crl_ctx, ctx->param);

	crl_ctx.parent = ctx;
	crl_ctx.verify_cb = ctx->verify_cb;

	/* Verify CRL issuer */
	ret = X509_verify_cert(&crl_ctx);

	if (ret <= 0)
		goto err;

	/* Check chain is acceptable */
	ret = check_crl_chain(ctx, ctx->chain, crl_ctx.chain);

err:
	X509_STORE_CTX_cleanup(&crl_ctx);
	return ret;
}

/* RFC3280 says nothing about the relationship between CRL path
 * and certificate path, which could lead to situations where a
 * certificate could be revoked or validated by a CA not authorised
 * to do so. RFC5280 is more strict and states that the two paths must
 * end in the same trust anchor, though some discussions remain...
 * until this is resolved we use the RFC5280 version
 */

static int
check_crl_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *cert_path,
    STACK_OF(X509) *crl_path)
{
	X509 *cert_ta, *crl_ta;

	cert_ta = sk_X509_value(cert_path, sk_X509_num(cert_path) - 1);
	crl_ta = sk_X509_value(crl_path, sk_X509_num(crl_path) - 1);
	if (!X509_cmp(cert_ta, crl_ta))
		return 1;
	return 0;
}

/* Check for match between two dist point names: three separate cases.
 * 1. Both are relative names and compare X509_NAME types.
 * 2. One full, one relative. Compare X509_NAME to GENERAL_NAMES.
 * 3. Both are full names and compare two GENERAL_NAMES.
 * 4. One is NULL: automatic match.
 */

static int
idp_check_dp(DIST_POINT_NAME *a, DIST_POINT_NAME *b)
{
	X509_NAME *nm = NULL;
	GENERAL_NAMES *gens = NULL;
	GENERAL_NAME *gena, *genb;
	int i, j;

	if (!a || !b)
		return 1;
	if (a->type == 1) {
		if (!a->dpname)
			return 0;
		/* Case 1: two X509_NAME */
		if (b->type == 1) {
			if (!b->dpname)
				return 0;
			if (!X509_NAME_cmp(a->dpname, b->dpname))
				return 1;
			else
				return 0;
		}
		/* Case 2: set name and GENERAL_NAMES appropriately */
		nm = a->dpname;
		gens = b->name.fullname;
	} else if (b->type == 1) {
		if (!b->dpname)
			return 0;
		/* Case 2: set name and GENERAL_NAMES appropriately */
		gens = a->name.fullname;
		nm = b->dpname;
	}

	/* Handle case 2 with one GENERAL_NAMES and one X509_NAME */
	if (nm) {
		for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
			gena = sk_GENERAL_NAME_value(gens, i);
			if (gena->type != GEN_DIRNAME)
				continue;
			if (!X509_NAME_cmp(nm, gena->d.directoryName))
				return 1;
		}
		return 0;
	}

	/* Else case 3: two GENERAL_NAMES */

	for (i = 0; i < sk_GENERAL_NAME_num(a->name.fullname); i++) {
		gena = sk_GENERAL_NAME_value(a->name.fullname, i);
		for (j = 0; j < sk_GENERAL_NAME_num(b->name.fullname); j++) {
			genb = sk_GENERAL_NAME_value(b->name.fullname, j);
			if (!GENERAL_NAME_cmp(gena, genb))
				return 1;
		}
	}

	return 0;
}

static int
crldp_check_crlissuer(DIST_POINT *dp, X509_CRL *crl, int crl_score)
{
	int i;
	X509_NAME *nm = X509_CRL_get_issuer(crl);

	/* If no CRLissuer return is successful iff don't need a match */
	if (!dp->CRLissuer)
		return !!(crl_score & CRL_SCORE_ISSUER_NAME);
	for (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++) {
		GENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);
		if (gen->type != GEN_DIRNAME)
			continue;
		if (!X509_NAME_cmp(gen->d.directoryName, nm))
			return 1;
	}
	return 0;
}

/* Check CRLDP and IDP */

static int
crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score, unsigned int *preasons)
{
	int i;

	if (crl->idp_flags & IDP_ONLYATTR)
		return 0;
	if (x->ex_flags & EXFLAG_CA) {
		if (crl->idp_flags & IDP_ONLYUSER)
			return 0;
	} else {
		if (crl->idp_flags & IDP_ONLYCA)
			return 0;
	}
	*preasons = crl->idp_reasons;
	for (i = 0; i < sk_DIST_POINT_num(x->crldp); i++) {
		DIST_POINT *dp = sk_DIST_POINT_value(x->crldp, i);
		if (crldp_check_crlissuer(dp, crl, crl_score)) {
			if (!crl->idp ||
			    idp_check_dp(dp->distpoint, crl->idp->distpoint)) {
				*preasons &= dp->dp_reasons;
				return 1;
			}
		}
	}
	if ((!crl->idp || !crl->idp->distpoint) &&
	    (crl_score & CRL_SCORE_ISSUER_NAME))
		return 1;
	return 0;
}

/* Retrieve CRL corresponding to current certificate.
 * If deltas enabled try to find a delta CRL too
 */

static int
get_crl_delta(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x)
{
	int ok;
	X509 *issuer = NULL;
	int crl_score = 0;
	unsigned int reasons;
	X509_CRL *crl = NULL, *dcrl = NULL;
	STACK_OF(X509_CRL) *skcrl;
	X509_NAME *nm = X509_get_issuer_name(x);

	reasons = ctx->current_reasons;
	ok = get_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons,
	    ctx->crls);
	if (ok)
		goto done;

	/* Lookup CRLs from store */
	skcrl = ctx->lookup_crls(ctx, nm);

	/* If no CRLs found and a near match from get_crl_sk use that */
	if (!skcrl && crl)
		goto done;

	get_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons, skcrl);

	sk_X509_CRL_pop_free(skcrl, X509_CRL_free);

done:

	/* If we got any kind of CRL use it and return success */
	if (crl) {
		ctx->current_issuer = issuer;
		ctx->current_crl_score = crl_score;
		ctx->current_reasons = reasons;
		*pcrl = crl;
		*pdcrl = dcrl;
		return 1;
	}

	return 0;
}

/* Check CRL validity */
static int
check_crl(X509_STORE_CTX *ctx, X509_CRL *crl)
{
	X509 *issuer = NULL;
	EVP_PKEY *ikey = NULL;
	int ok = 0, chnum, cnum;

	cnum = ctx->error_depth;
	chnum = sk_X509_num(ctx->chain) - 1;
	/* if we have an alternative CRL issuer cert use that */
	if (ctx->current_issuer) {
		issuer = ctx->current_issuer;
	} else if (cnum < chnum) {
		/* Else find CRL issuer: if not last certificate then issuer
	 	* is next certificate in chain.
	 	*/
		issuer = sk_X509_value(ctx->chain, cnum + 1);
	} else {
		issuer = sk_X509_value(ctx->chain, chnum);
		/* If not self signed, can't check signature */
		if (!ctx->check_issued(ctx, issuer, issuer)) {
			ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;
			ok = ctx->verify_cb(0, ctx);
			if (!ok)
				goto err;
		}
	}

	if (issuer) {
		/* Skip most tests for deltas because they have already
		 * been done
		 */
		if (!crl->base_crl_number) {
			/* Check for cRLSign bit if keyUsage present */
			if ((issuer->ex_flags & EXFLAG_KUSAGE) &&
			    !(issuer->ex_kusage & KU_CRL_SIGN)) {
				ctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;
				ok = ctx->verify_cb(0, ctx);
				if (!ok)
					goto err;
			}

			if (!(ctx->current_crl_score & CRL_SCORE_SCOPE)) {
				ctx->error = X509_V_ERR_DIFFERENT_CRL_SCOPE;
				ok = ctx->verify_cb(0, ctx);
				if (!ok)
					goto err;
			}

			if (!(ctx->current_crl_score & CRL_SCORE_SAME_PATH)) {
				if (check_crl_path(ctx,
				    ctx->current_issuer) <= 0) {
					ctx->error = X509_V_ERR_CRL_PATH_VALIDATION_ERROR;
					ok = ctx->verify_cb(0, ctx);
					if (!ok)
						goto err;
				}
			}

			if (crl->idp_flags & IDP_INVALID) {
				ctx->error = X509_V_ERR_INVALID_EXTENSION;
				ok = ctx->verify_cb(0, ctx);
				if (!ok)
					goto err;
			}


		}

		if (!(ctx->current_crl_score & CRL_SCORE_TIME)) {
			ok = check_crl_time(ctx, crl, 1);
			if (!ok)
				goto err;
		}

		/* Attempt to get issuer certificate public key */
		ikey = X509_get_pubkey(issuer);

		if (!ikey) {
			ctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
			ok = ctx->verify_cb(0, ctx);
			if (!ok)
				goto err;
		} else {
			/* Verify CRL signature */
			if (X509_CRL_verify(crl, ikey) <= 0) {
				ctx->error = X509_V_ERR_CRL_SIGNATURE_FAILURE;
				ok = ctx->verify_cb(0, ctx);
				if (!ok)
					goto err;
			}
		}
	}

	ok = 1;

err:
	EVP_PKEY_free(ikey);
	return ok;
}

/* Check certificate against CRL */
static int
cert_crl(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x)
{
	int ok;
	X509_REVOKED *rev;

	/* The rules changed for this... previously if a CRL contained
	 * unhandled critical extensions it could still be used to indicate
	 * a certificate was revoked. This has since been changed since
	 * critical extension can change the meaning of CRL entries.
	 */
	if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) &&
	    (crl->flags & EXFLAG_CRITICAL)) {
		ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;
		ok = ctx->verify_cb(0, ctx);
		if (!ok)
			return 0;
	}
	/* Look for serial number of certificate in CRL
	 * If found make sure reason is not removeFromCRL.
	 */
	if (X509_CRL_get0_by_cert(crl, &rev, x)) {
		if (rev->reason == CRL_REASON_REMOVE_FROM_CRL)
			return 2;
		ctx->error = X509_V_ERR_CERT_REVOKED;
		ok = ctx->verify_cb(0, ctx);
		if (!ok)
			return 0;
	}

	return 1;
}

static int
check_policy(X509_STORE_CTX *ctx)
{
	int ret;

	if (ctx->parent)
		return 1;
	ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
	    ctx->param->policies, ctx->param->flags);
	if (ret == 0) {
		X509error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	/* Invalid or inconsistent extensions */
	if (ret == -1) {
		/* Locate certificates with bad extensions and notify
		 * callback.
		 */
		X509 *x;
		int i;
		for (i = 1; i < sk_X509_num(ctx->chain); i++) {
			x = sk_X509_value(ctx->chain, i);
			if (!(x->ex_flags & EXFLAG_INVALID_POLICY))
				continue;
			ctx->current_cert = x;
			ctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;
			if (!ctx->verify_cb(0, ctx))
				return 0;
		}
		return 1;
	}
	if (ret == -2) {
		ctx->current_cert = NULL;
		ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
		return ctx->verify_cb(0, ctx);
	}

	if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {
		ctx->current_cert = NULL;
		ctx->error = X509_V_OK;
		if (!ctx->verify_cb(2, ctx))
			return 0;
	}

	return 1;
}

/*
 * Inform the verify callback of an error.
 *
 * If x is not NULL it is the error cert, otherwise use the chain cert
 * at depth.
 *
 * If err is not X509_V_OK, that's the error value, otherwise leave
 * unchanged (presumably set by the caller).
 *
 * Returns 0 to abort verification with an error, non-zero to continue.
 */
static int
verify_cb_cert(X509_STORE_CTX *ctx, X509 *x, int depth, int err)
{
	ctx->error_depth = depth;
	ctx->current_cert = (x != NULL) ? x : sk_X509_value(ctx->chain, depth);
	if (err != X509_V_OK)
		ctx->error = err;
	return ctx->verify_cb(0, ctx);
}

/*
 * Check certificate validity times.
 *
 * If depth >= 0, invoke verification callbacks on error, otherwise just return
 * the validation status.
 *
 * Return 1 on success, 0 otherwise.
 */
int
x509_check_cert_time(X509_STORE_CTX *ctx, X509 *x, int depth)
{
	time_t *ptime;
	int i;

	if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
		ptime = &ctx->param->check_time;
	else if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)
		return 1;
	else
		ptime = NULL;

	i = X509_cmp_time(X509_get_notBefore(x), ptime);
	if (i >= 0 && depth < 0)
		return 0;
	if (i == 0 && !verify_cb_cert(ctx, x, depth,
	    X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD))
		return 0;
	if (i > 0 && !verify_cb_cert(ctx, x, depth,
		X509_V_ERR_CERT_NOT_YET_VALID))
		return 0;

	i = X509_cmp_time(X509_get_notAfter(x), ptime);
	if (i <= 0 && depth < 0)
		return 0;
	if (i == 0 && !verify_cb_cert(ctx, x, depth,
	    X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD))
		return 0;
	if (i < 0 && !verify_cb_cert(ctx, x, depth,
	    X509_V_ERR_CERT_HAS_EXPIRED))
		return 0;
	return 1;
}

static int
internal_verify(X509_STORE_CTX *ctx)
{
	int n = sk_X509_num(ctx->chain) - 1;
	X509 *xi = sk_X509_value(ctx->chain, n);
	X509 *xs;

	if (ctx->check_issued(ctx, xi, xi))
		xs = xi;
	else {
		if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {
			xs = xi;
			goto check_cert;
		}
		if (n <= 0)
			return verify_cb_cert(ctx, xi, 0,
			    X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE);
		n--;
		ctx->error_depth = n;
		xs = sk_X509_value(ctx->chain, n);
	}

	/*
	 * Do not clear ctx->error=0, it must be "sticky", only the
	 * user's callback is allowed to reset errors (at its own
	 * peril).
	 */
	while (n >= 0) {

		/*
		 * Skip signature check for self signed certificates
		 * unless explicitly asked for.  It doesn't add any
		 * security and just wastes time.  If the issuer's
		 * public key is unusable, report the issuer
		 * certificate and its depth (rather than the depth of
		 * the subject).
		 */
		if (xs != xi || (ctx->param->flags &
			X509_V_FLAG_CHECK_SS_SIGNATURE)) {
			EVP_PKEY *pkey;
			if ((pkey = X509_get_pubkey(xi)) == NULL) {
				if (!verify_cb_cert(ctx, xi, xi != xs ? n+1 : n,
					X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY))
					return 0;
			} else if (X509_verify(xs, pkey) <= 0) {
				if (!verify_cb_cert(ctx, xs, n,
					X509_V_ERR_CERT_SIGNATURE_FAILURE)) {
					EVP_PKEY_free(pkey);
					return 0;
				}
			}
			EVP_PKEY_free(pkey);
		}
check_cert:
		/* Calls verify callback as needed */
		if (!x509_check_cert_time(ctx, xs, n))
			return 0;

		/*
		 * Signal success at this depth.  However, the
		 * previous error (if any) is retained.
		 */
		ctx->current_issuer = xi;
		ctx->current_cert = xs;
		ctx->error_depth = n;
		if (!ctx->verify_cb(1, ctx))
			return 0;

		if (--n >= 0) {
			xi = xs;
			xs = sk_X509_value(ctx->chain, n);
		}
	}
	return 1;
}

int
X509_cmp_current_time(const ASN1_TIME *ctm)
{
	return X509_cmp_time(ctm, NULL);
}

/*
 * Compare a possibly unvalidated ASN1_TIME string against a time_t
 * using RFC 5280 rules for the time string. If *cmp_time is NULL
 * the current system time is used.
 *
 * XXX NOTE that unlike what you expect a "cmp" function to do in C,
 * XXX this one is "special", and returns 0 for error.
 *
 * Returns:
 * -1 if the ASN1_time is earlier than OR the same as *cmp_time.
 * 1 if the ASN1_time is later than *cmp_time.
 * 0 on error.
 */
int
X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)
{
	time_t time1, time2;
	struct tm tm1, tm2;
	int ret = 0;
	int type;

	if (cmp_time == NULL)
		time2 = time(NULL);
	else
		time2 = *cmp_time;

	memset(&tm1, 0, sizeof(tm1));

	type = ASN1_time_parse(ctm->data, ctm->length, &tm1, ctm->type);
	if (type == -1)
		goto out; /* invalid time */

	/* RFC 5280 section 4.1.2.5 */
	if (tm1.tm_year < 150 && type != V_ASN1_UTCTIME)
		goto out;
	if (tm1.tm_year >= 150 && type != V_ASN1_GENERALIZEDTIME)
		goto out;

	/*
	 * Defensively fail if the time string is not representable as
	 * a time_t. A time_t must be sane if you care about times after
	 * Jan 19 2038.
	 */
	if ((time1 = timegm(&tm1)) == -1)
		goto out;

	if (gmtime_r(&time2, &tm2) == NULL)
		goto out;

	ret = ASN1_time_tm_cmp(&tm1, &tm2);
	if (ret == 0)
		ret = -1; /* 0 is used for error, so map same to less than */
 out:
	return (ret);
}

ASN1_TIME *
X509_gmtime_adj(ASN1_TIME *s, long adj)
{
	return X509_time_adj(s, adj, NULL);
}

ASN1_TIME *
X509_time_adj(ASN1_TIME *s, long offset_sec, time_t *in_time)
{
	return X509_time_adj_ex(s, 0, offset_sec, in_time);
}

ASN1_TIME *
X509_time_adj_ex(ASN1_TIME *s, int offset_day, long offset_sec, time_t *in_time)
{
	time_t t;
	if (in_time == NULL)
		t = time(NULL);
	else
		t = *in_time;

	return ASN1_TIME_adj(s, t, offset_day, offset_sec);
}

int
X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)
{
	EVP_PKEY *ktmp = NULL, *ktmp2;
	int i, j;

	if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey))
		return 1;

	for (i = 0; i < sk_X509_num(chain); i++) {
		ktmp = X509_get_pubkey(sk_X509_value(chain, i));
		if (ktmp == NULL) {
			X509error(X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
			return 0;
		}
		if (!EVP_PKEY_missing_parameters(ktmp))
			break;
		else {
			EVP_PKEY_free(ktmp);
			ktmp = NULL;
		}
	}
	if (ktmp == NULL) {
		X509error(X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);
		return 0;
	}

	/* first, populate the other certs */
	for (j = i - 1; j >= 0; j--) {
		ktmp2 = X509_get_pubkey(sk_X509_value(chain, j));
		EVP_PKEY_copy_parameters(ktmp2, ktmp);
		EVP_PKEY_free(ktmp2);
	}

	if (pkey != NULL)
		EVP_PKEY_copy_parameters(pkey, ktmp);
	EVP_PKEY_free(ktmp);
	return 1;
}

int
X509_STORE_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
	/* This function is (usually) called only once, by
	 * SSL_get_ex_data_X509_STORE_CTX_idx (ssl/ssl_cert.c). */
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX,
	    argl, argp, new_func, dup_func, free_func);
}

int
X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)
{
	return CRYPTO_set_ex_data(&ctx->ex_data, idx, data);
}

void *
X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)
{
	return CRYPTO_get_ex_data(&ctx->ex_data, idx);
}

int
X509_STORE_CTX_get_error(X509_STORE_CTX *ctx)
{
	return ctx->error;
}

void
X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)
{
	ctx->error = err;
}

int
X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)
{
	return ctx->error_depth;
}

X509 *
X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)
{
	return ctx->current_cert;
}

STACK_OF(X509) *X509_STORE_CTX_get_chain(X509_STORE_CTX *ctx)
{
	return ctx->chain;
}

STACK_OF(X509) *X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx)
{
	int i;
	X509 *x;
	STACK_OF(X509) *chain;

	if (!ctx->chain || !(chain = sk_X509_dup(ctx->chain)))
		return NULL;
	for (i = 0; i < sk_X509_num(chain); i++) {
		x = sk_X509_value(chain, i);
		CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
	}
	return chain;
}

X509 *
X509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx)
{
	return ctx->current_issuer;
}

X509_CRL *
X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx)
{
	return ctx->current_crl;
}

X509_STORE_CTX *
X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx)
{
	return ctx->parent;
}

void
X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)
{
	ctx->cert = x;
}

void
X509_STORE_CTX_set_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
{
	ctx->untrusted = sk;
}

void
X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk)
{
	ctx->crls = sk;
}

int
X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)
{
	return X509_STORE_CTX_purpose_inherit(ctx, 0, purpose, 0);
}

int
X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)
{
	return X509_STORE_CTX_purpose_inherit(ctx, 0, 0, trust);
}

/* This function is used to set the X509_STORE_CTX purpose and trust
 * values. This is intended to be used when another structure has its
 * own trust and purpose values which (if set) will be inherited by
 * the ctx. If they aren't set then we will usually have a default
 * purpose in mind which should then be used to set the trust value.
 * An example of this is SSL use: an SSL structure will have its own
 * purpose and trust settings which the application can set: if they
 * aren't set then we use the default of SSL client/server.
 */

int
X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
    int purpose, int trust)
{
	int idx;

	/* If purpose not set use default */
	if (!purpose)
		purpose = def_purpose;
	/* If we have a purpose then check it is valid */
	if (purpose) {
		X509_PURPOSE *ptmp;
		idx = X509_PURPOSE_get_by_id(purpose);
		if (idx == -1) {
			X509error(X509_R_UNKNOWN_PURPOSE_ID);
			return 0;
		}
		ptmp = X509_PURPOSE_get0(idx);
		if (ptmp->trust == X509_TRUST_DEFAULT) {
			idx = X509_PURPOSE_get_by_id(def_purpose);
			if (idx == -1) {
				X509error(X509_R_UNKNOWN_PURPOSE_ID);
				return 0;
			}
			ptmp = X509_PURPOSE_get0(idx);
		}
		/* If trust not set then get from purpose default */
		if (!trust)
			trust = ptmp->trust;
	}
	if (trust) {
		idx = X509_TRUST_get_by_id(trust);
		if (idx == -1) {
			X509error(X509_R_UNKNOWN_TRUST_ID);
			return 0;
		}
	}

	if (purpose && !ctx->param->purpose)
		ctx->param->purpose = purpose;
	if (trust && !ctx->param->trust)
		ctx->param->trust = trust;
	return 1;
}

X509_STORE_CTX *
X509_STORE_CTX_new(void)
{
	X509_STORE_CTX *ctx;

	ctx = calloc(1, sizeof(X509_STORE_CTX));
	if (!ctx) {
		X509error(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	return ctx;
}

void
X509_STORE_CTX_free(X509_STORE_CTX *ctx)
{
	if (ctx == NULL)
		return;

	X509_STORE_CTX_cleanup(ctx);
	free(ctx);
}

int
X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
    STACK_OF(X509) *chain)
{
	int param_ret = 1;

	/*
	 * Make sure everything is initialized properly even in case of an
	 * early return due to an error.
	 *
	 * While this 'ctx' can be reused, X509_STORE_CTX_cleanup() will have
	 * freed everything and memset ex_data anyway.  This also allows us
	 * to safely use X509_STORE_CTX variables from the stack which will
	 * have uninitialized data.
	 */
	memset(ctx, 0, sizeof(*ctx));

	/*
	 * Start with this set to not valid - it will be set to valid
	 * in X509_verify_cert.
	 */
	ctx->error = X509_V_ERR_INVALID_CALL;

	/*
	 * Set values other than 0.  Keep this in the same order as
	 * X509_STORE_CTX except for values that may fail.  All fields that
	 * may fail should go last to make sure 'ctx' is as consistent as
	 * possible even on early exits.
	 */
	ctx->ctx = store;
	ctx->cert = x509;
	ctx->untrusted = chain;

	if (store && store->verify)
		ctx->verify = store->verify;
	else
		ctx->verify = internal_verify;

	if (store && store->verify_cb)
		ctx->verify_cb = store->verify_cb;
	else
		ctx->verify_cb = null_callback;

	if (store && store->get_issuer)
		ctx->get_issuer = store->get_issuer;
	else
		ctx->get_issuer = X509_STORE_CTX_get1_issuer;

	if (store && store->check_issued)
		ctx->check_issued = store->check_issued;
	else
		ctx->check_issued = check_issued;

	if (store && store->check_revocation)
		ctx->check_revocation = store->check_revocation;
	else
		ctx->check_revocation = check_revocation;

	if (store && store->get_crl)
		ctx->get_crl = store->get_crl;
	else
		ctx->get_crl = NULL;

	if (store && store->check_crl)
		ctx->check_crl = store->check_crl;
	else
		ctx->check_crl = check_crl;

	if (store && store->cert_crl)
		ctx->cert_crl = store->cert_crl;
	else
		ctx->cert_crl = cert_crl;

	ctx->check_policy = check_policy;

	if (store && store->lookup_certs)
		ctx->lookup_certs = store->lookup_certs;
	else
		ctx->lookup_certs = X509_STORE_get1_certs;

	if (store && store->lookup_crls)
		ctx->lookup_crls = store->lookup_crls;
	else
		ctx->lookup_crls = X509_STORE_get1_crls;

	if (store && store->cleanup)
		ctx->cleanup = store->cleanup;
	else
		ctx->cleanup = NULL;

	ctx->param = X509_VERIFY_PARAM_new();
	if (!ctx->param) {
		X509error(ERR_R_MALLOC_FAILURE);
		return 0;
	}

	/* Inherit callbacks and flags from X509_STORE if not set
	 * use defaults.
	 */
	if (store)
		param_ret = X509_VERIFY_PARAM_inherit(ctx->param, store->param);
	else
		ctx->param->inh_flags |= X509_VP_FLAG_DEFAULT|X509_VP_FLAG_ONCE;

	if (param_ret)
		param_ret = X509_VERIFY_PARAM_inherit(ctx->param,
		    X509_VERIFY_PARAM_lookup("default"));

	if (param_ret == 0) {
		X509error(ERR_R_MALLOC_FAILURE);
		return 0;
	}

	if (CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,
	    &(ctx->ex_data)) == 0) {
		X509error(ERR_R_MALLOC_FAILURE);
		return 0;
	}
	return 1;
}

/* Set alternative lookup method: just a STACK of trusted certificates.
 * This avoids X509_STORE nastiness where it isn't needed.
 */

void
X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
{
	ctx->other_ctx = sk;
	ctx->get_issuer = get_issuer_sk;
}

void
X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
{
	if (ctx->cleanup)
		ctx->cleanup(ctx);
	if (ctx->param != NULL) {
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param = NULL;
	}
	if (ctx->tree != NULL) {
		X509_policy_tree_free(ctx->tree);
		ctx->tree = NULL;
	}
	if (ctx->chain != NULL) {
		sk_X509_pop_free(ctx->chain, X509_free);
		ctx->chain = NULL;
	}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX,
	    ctx, &(ctx->ex_data));
	memset(&ctx->ex_data, 0, sizeof(CRYPTO_EX_DATA));
}

void
X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)
{
	X509_VERIFY_PARAM_set_depth(ctx->param, depth);
}

void
X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)
{
	X509_VERIFY_PARAM_set_flags(ctx->param, flags);
}

void
X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags, time_t t)
{
	X509_VERIFY_PARAM_set_time(ctx->param, t);
}

void
X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,
    int (*verify_cb)(int, X509_STORE_CTX *))
{
	ctx->verify_cb = verify_cb;
}

X509_POLICY_TREE *
X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx)
{
	return ctx->tree;
}

int
X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx)
{
	return ctx->explicit_policy;
}

int
X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)
{
	const X509_VERIFY_PARAM *param;
	param = X509_VERIFY_PARAM_lookup(name);
	if (!param)
		return 0;
	return X509_VERIFY_PARAM_inherit(ctx->param, param);
}

X509_VERIFY_PARAM *
X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)
{
	return ctx->param;
}

void
X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)
{
	if (ctx->param)
		X509_VERIFY_PARAM_free(ctx->param);
	ctx->param = param;
}
@


1.60
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.59 2017/01/21 01:09:54 beck Exp $ */
a1795 1
		EVP_PKEY *pkey;
d1807 1
d1814 2
a1815 1
					X509_V_ERR_CERT_SIGNATURE_FAILURE))
d1817 1
d1819 1
@


1.59
log
@fix bogus comment
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.58 2017/01/21 01:07:25 beck Exp $ */
d231 1
a231 2
		X509err(X509_F_X509_VERIFY_CERT,
		    X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
d240 1
a240 2
		X509err(X509_F_X509_VERIFY_CERT,
		    ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d248 1
a248 2
		X509err(X509_F_X509_VERIFY_CERT,
		    ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
d262 1
a262 1
		X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
d272 1
a272 1
		X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
d316 1
a316 2
					X509err(X509_F_X509_VERIFY_CERT,
					    ERR_R_MALLOC_FAILURE);
d414 1
a414 2
				X509err(X509_F_X509_VERIFY_CERT,
				    ERR_R_MALLOC_FAILURE);
d486 1
a486 1
				X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
d1667 1
a1667 1
		X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);
d1939 1
a1939 2
			X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,
			    X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
d1950 1
a1950 2
		X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,
		    X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);
d2105 1
a2105 2
			X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
			    X509_R_UNKNOWN_PURPOSE_ID);
d2112 1
a2112 2
				X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
				    X509_R_UNKNOWN_PURPOSE_ID);
d2124 1
a2124 2
			X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
			    X509_R_UNKNOWN_TRUST_ID);
d2143 1
a2143 1
		X509err(X509_F_X509_STORE_CTX_NEW, ERR_R_MALLOC_FAILURE);
d2251 1
a2251 1
		X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
d2268 1
a2268 1
		X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
d2274 1
a2274 1
		X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
@


1.58
log
@Make return value of X509_verify_cert be consistent with the error code,
with the caveat that we force V_OK when a user provided callback has
us returning success.
ok inoguchi@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.57 2017/01/20 00:37:40 beck Exp $ */
d2188 1
a2188 1
	 * in X509_verify_cert, or before the callback is called.
@


1.57
log
@Rework internal_verify, mostly from OpenSSL. so we can progress
towards cleaning up the V_OK stuff.
ok kinichiro@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.56 2017/01/07 13:49:07 jsing Exp $ */
d549 9
a557 1
	return ok;
@


1.56
log
@Add and remove some blank lines, in order to make X509_verify_cert()
(slightly) more readable.
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.55 2017/01/07 06:45:24 jsing Exp $ */
d246 1
a246 1
	if (ctx->error != X509_V_ERR_UNSPECIFIED) {
d565 1
a565 1
			if (x509_check_cert_time(ctx, rv, 1))
d1701 29
d1731 1
a1731 1
x509_check_cert_time(X509_STORE_CTX *ctx, X509 *x, int quiet)
d1733 1
a1733 1
	time_t *ptime = NULL;
a1735 3
	if (ctx->param->flags & X509_V_FLAG_NO_CHECK_TIME)
		return (1);

d1738 4
d1744 8
a1751 17
	if (i == 0) {
		if (quiet)
			return 0;
		ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;
		ctx->current_cert = x;
		if (!ctx->verify_cb(0, ctx))
			return 0;
	}

	if (i > 0) {
		if (quiet)
			return 0;
		ctx->error = X509_V_ERR_CERT_NOT_YET_VALID;
		ctx->current_cert = x;
		if (!ctx->verify_cb(0, ctx))
			return 0;
	}
d1754 8
a1761 18
	if (i == 0) {
		if (quiet)
			return 0;
		ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;
		ctx->current_cert = x;
		if (!ctx->verify_cb(0, ctx))
			return 0;
	}

	if (i < 0) {
		if (quiet)
			return 0;
		ctx->error = X509_V_ERR_CERT_HAS_EXPIRED;
		ctx->current_cert = x;
		if (!ctx->verify_cb(0, ctx))
			return 0;
	}

d1768 3
a1770 11
	int ok = 0, n;
	X509 *xs, *xi;
	EVP_PKEY *pkey = NULL;
	int (*cb)(int xok, X509_STORE_CTX *xctx);

	cb = ctx->verify_cb;

	n = sk_X509_num(ctx->chain);
	ctx->error_depth = n - 1;
	n--;
	xi = sk_X509_value(ctx->chain, n);
d1775 10
a1784 10
		if (n <= 0) {
			ctx->error = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;
			ctx->current_cert = xi;
			ok = cb(0, ctx);
			goto end;
		} else {
			n--;
			ctx->error_depth = n;
			xs = sk_X509_value(ctx->chain, n);
		}
d1787 5
a1791 1
/*	ctx->error=0;  not needed */
d1793 1
a1793 1
		ctx->error_depth = n;
d1795 7
a1801 3
		/* Skip signature check for self signed certificates unless
		 * explicitly asked for. It doesn't add any security and
		 * just wastes time.
d1803 2
a1804 2
		if (!xs->valid && (xs != xi ||
		    (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {
d1806 3
a1808 5
				ctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
				ctx->current_cert = xi;
				ok = (*cb)(0, ctx);
				if (!ok)
					goto end;
d1810 3
a1812 7
				ctx->error = X509_V_ERR_CERT_SIGNATURE_FAILURE;
				ctx->current_cert = xs;
				ok = (*cb)(0, ctx);
				if (!ok) {
					EVP_PKEY_free(pkey);
					goto end;
				}
a1813 2
			EVP_PKEY_free(pkey);
			pkey = NULL;
d1815 4
d1820 4
a1823 7
		xs->valid = 1;

		ok = x509_check_cert_time(ctx, xs, 0);
		if (!ok)
			goto end;

		/* The last error (if any) is still in the error value */
d1826 3
a1828 3
		ok = (*cb)(1, ctx);
		if (!ok)
			goto end;
d1830 1
a1830 2
		n--;
		if (n >= 0) {
d1835 1
a1835 4
	ok = 1;

end:
	return ok;
d2180 1
a2180 1
	 * in X509_verify_cert.
d2182 1
a2182 1
	ctx->error = X509_V_ERR_UNSPECIFIED;
@


1.55
log
@Revert part of r1.54 as there are at least two situations where we are still
returning ok == 1, with ctx->error not being X509_V_OK. Hopefully we can
restore this behaviour once these are ironed out.

Discussed with beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.54 2017/01/03 05:52:28 beck Exp $ */
d229 1
a509 1

a513 1

a514 1

a518 1

a524 1

d536 1
d540 1
@


1.54
log
@Add a small bit of belt and suspenders around ERR_V_OK with X509_STORE_ctx
and X509_verify_cert - We at least make it so an an init'ed ctx is not
"valid" until X509_verify_cert has actually been called, And we make it
impossible to return success without having the error set to ERR_V_OK.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.53 2017/01/03 05:34:48 beck Exp $ */
d551 1
a551 3

	/* Ensure we only return success with ctx->error of X509_V_OK */
	return (ctx->error == X509_V_OK);
@


1.53
log
@bring in boring's internal check_trust function to fix a bug introduced
when we went to alternate cert chains. this correctly does not clobber
the ctx->error when using an alt chain.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.52 2016/11/06 10:37:38 beck Exp $ */
d245 10
d551 3
a553 1
	return ok;
d2181 6
@


1.52
log
@Rework X509_verify_cert to support alt chains on certificate verification,
via boringssl.
ok jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.51 2016/11/04 18:07:23 beck Exp $ */
d778 30
a807 2
static int
check_trust(X509_STORE_CTX *ctx)
d809 4
a812 6
#ifdef OPENSSL_NO_CHAIN_VERIFY
	return 1;
#else
	int i, ok;
	X509 *x;
	int (*cb)(int xok, X509_STORE_CTX *xctx);
d815 44
a858 15
	/* For now just check the last certificate in the chain */
	i = sk_X509_num(ctx->chain) - 1;
	x = sk_X509_value(ctx->chain, i);
	ok = X509_check_trust(x, ctx->param->trust, 0);
	if (ok == X509_TRUST_TRUSTED)
		return 1;
	ctx->error_depth = i;
	ctx->current_cert = x;
	if (ok == X509_TRUST_REJECTED)
		ctx->error = X509_V_ERR_CERT_REJECTED;
	else
		ctx->error = X509_V_ERR_CERT_UNTRUSTED;
	ok = cb(0, ctx);
	return ok;
#endif
@


1.51
log
@make public ASN1_time_parse and ASN1_time_tm_cmp to replace former hidden
functions.. document with a man page.
bump majors on libtls, libssl, libcrypto
ok jsing@@ guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.50 2016/10/02 20:45:04 guenther Exp $ */
d77 1
d157 62
d222 1
a222 1
	X509 *x, *xtmp, *chain_ss = NULL;
d226 2
a227 2
	int num;
	int (*cb)(int xok, X509_STORE_CTX *xctx);
a228 1

d232 11
d248 9
a256 10
	/* first we make sure the chain we are going to build is
	 * present and that the first entry is in place */
	if (ctx->chain == NULL) {
		if (((ctx->chain = sk_X509_new_null()) == NULL) ||
		    (!sk_X509_push(ctx->chain, ctx->cert))) {
			X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
			goto end;
		}
		CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
		ctx->last_untrusted = 1;
d258 2
d265 1
d275 5
d281 1
a281 6
			break;	/* FIXME: If this happens, we should take
				 * note of it and, if appropriate, use the
				 * X509_V_ERR_CERT_CHAIN_TOO_LONG error
				 * code later.
				 */

d283 1
a283 1
		if (ctx->check_issued(ctx, x, x))
d285 18
a302 1

d310 2
d314 1
a314 2
				CRYPTO_add(&xtmp->references, 1,
				    CRYPTO_LOCK_X509);
d319 3
a321 2
				/* reparse the full chain for
				 * the next one */
d327 5
a331 4
	sk_X509_free(sktmp);
	sktmp = NULL;
	
	/* at this point, chain should contain a list of untrusted
d333 2
a334 1
	 * if possible, otherwise we complain. */
d336 40
a375 25
	/* Examine last certificate in chain and see if it
 	 * is self signed.
 	 */

	i = sk_X509_num(ctx->chain);
	x = sk_X509_value(ctx->chain, i - 1);
	if (ctx->check_issued(ctx, x, x)) {
		/* we have a self signed certificate */
		if (sk_X509_num(ctx->chain) == 1) {
			/* We have a single self signed certificate: see if
			 * we can find it in the store. We must have an exact
			 * match to avoid possible impersonation.
			 */
			ok = ctx->get_issuer(&xtmp, ctx, x);
			if ((ok <= 0) || X509_cmp(x, xtmp)) {
				ctx->error =
				    X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
				ctx->current_cert = x;
				ctx->error_depth = i - 1;
				if (ok == 1)
					X509_free(xtmp);
				bad_chain = 1;
				ok = cb(0, ctx);
				if (!ok)
					goto end;
d377 3
a379 2
				/* We have a match: replace certificate with store version
				 * so we get any trust settings.
d381 5
a385 4
				X509_free(x);
				x = xtmp;
				(void)sk_X509_set(ctx->chain, i - 1, x);
				ctx->last_untrusted = 0;
a386 6
		} else {
			/* extract and save self signed certificate for later use */
			chain_ss = sk_X509_pop(ctx->chain);
			ctx->last_untrusted--;
			num--;
			x = sk_X509_value(ctx->chain, num - 1);
d388 9
a396 1
	}
d398 17
a414 9
	/* We now lookup certs from the certificate store */
	for (;;) {
		/* If we have enough, we break */
		if (depth < num)
			break;

		/* If we are self signed, we break */
		if (ctx->check_issued(ctx, x, x))
			break;
d416 2
a417 5
		ok = ctx->get_issuer(&xtmp, ctx, x);
		if (ok < 0)
			return ok;
		if (ok == 0)
			break;
d419 43
a461 5
		x = xtmp;
		if (!sk_X509_push(ctx->chain, x)) {
			X509_free(xtmp);
			X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
			return 0;
d463 1
a463 2
		num++;
	}
d465 7
a471 6
	/* we now have our chain, lets check it... */

	/* Is last certificate looked up self signed? */
	if (!ctx->check_issued(ctx, x, x)) {
		if ((chain_ss == NULL) ||
		    !ctx->check_issued(ctx, x, chain_ss)) {
a477 1

d510 1
a510 4
	/* The chain extensions are OK: check trust */

	if (param->trust > 0)
		ok = check_trust(ctx);
d514 3
a516 6

	/* We may as well copy down any DSA parameters that are required */
	X509_get_pubkey_parameters(NULL, ctx->chain);

	/* Check revocation status: we do this after copying parameters
	 * because they may be needed for CRL signature verification.
a529 1

d533 1
a533 6
	if (!ok)
		goto end;
	if (0) {
end:
		X509_get_pubkey_parameters(NULL, ctx->chain);
	}
d537 4
a542 1

@


1.50
log
@In X509_cmp_time(), pass asn1_time_parse() the tag of the field being
parsed so that a malformed GeneralizedTime field is recognized as an error
instead of potentially being interpreted as if it was a valid UTCTime.

Reported by Theofilos Petsios (theofilos (at) cs.columbia.edu)

ok beck@@ tedu@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.49 2016/03/11 07:08:45 mmcc Exp $ */
d1661 1
a1661 1
	type = asn1_time_parse(ctm->data, ctm->length, &tm1, ctm->type);
d1682 1
a1682 1
	ret = asn1_tm_cmp(&tm1, &tm2);
@


1.49
log
@X509_free(3) is NULL-safe, so remove NULL checks before its calls.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.48 2015/12/14 03:38:13 beck Exp $ */
d1661 2
a1662 1
	if ((type = asn1_time_parse(ctm->data, ctm->length, &tm1, 0)) == -1)
@


1.48
log
@initialize ok to 0
ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.47 2015/10/19 16:32:37 beck Exp $ */
d391 1
a391 2
	if (chain_ss != NULL)
		X509_free(chain_ss);
@


1.47
log
@Stop supporing "legcay" time formats that OpenSSL supports. Rewrite the
utctime and gentime wrappers accordingly. Along with some other cleanup.
this also removes the need for timegm.
ok bcook@@ sthen@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.46 2015/10/02 15:04:45 beck Exp $ */
d688 1
a688 1
	int ok, cnum;
@


1.46
log
@Flense the greasy black guts of unreadble string parsing code out of three areas
in asn1 and x509 code, all dealing with an ASN1_TIME. This brings the parsing
together in one function that converts into a struct tm. While we are at it this
also brings us into conformance with RFC 5280 for times allowed in an X509 cert,
as OpenSSL is very liberal with what it allows.
input and fixes from deraadt@@ jsing@@ guethther@@ and others.
ok krw@@, guenther@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.45 2015/09/14 16:13:39 jsing Exp $ */
d1651 1
a1651 1
	struct tm tm1;
d1653 1
d1662 1
a1662 1
	if (asn1_time_parse(ctm->data, ctm->length, &tm1, 0) == -1)
d1665 6
d1679 6
a1684 4
	if (time1 <= time2)
		ret = -1;
	else
		ret = 1;
d1696 1
a1696 1
X509_time_adj(ASN1_TIME *s, long offset_sec, time_t *in_tm)
d1698 1
a1698 1
	return X509_time_adj_ex(s, 0, offset_sec, in_tm);
d1702 1
a1702 1
X509_time_adj_ex(ASN1_TIME *s, int offset_day, long offset_sec, time_t *in_tm)
d1705 2
a1706 3

	if (in_tm)
		t = *in_tm;
d1708 1
a1708 1
		time(&t);
a1709 7
	if (s && !(s->flags & ASN1_STRING_FLAG_MSTRING)) {
		if (s->type == V_ASN1_UTCTIME)
			return ASN1_UTCTIME_adj(s, t, offset_day, offset_sec);
		if (s->type == V_ASN1_GENERALIZEDTIME)
			return ASN1_GENERALIZEDTIME_adj(s, t, offset_day,
			    offset_sec);
	}
@


1.45
log
@Add support for disabling certificate and CRL validity checking.

Loosely based on changes in OpenSSL.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.44 2015/07/19 05:42:55 miod Exp $ */
d1634 13
d1650 3
a1652 5
	char *str;
	ASN1_TIME atm;
	long offset;
	char buff1[24], buff2[24], *p;
	int i, j;
d1654 4
a1657 18
	p = buff1;
	i = ctm->length;
	str = (char *)ctm->data;
	if (ctm->type == V_ASN1_UTCTIME) {
		if ((i < 11) || (i > 17))
			return 0;
		memcpy(p, str, 10);
		p += 10;
		str += 10;
		i -= 10;
	} else {
		if (i < 13)
			return 0;
		memcpy(p, str, 12);
		p += 12;
		str += 12;
		i -= 12;
	}
d1659 1
a1659 25
	if (i < 1)
		return 0;
	if ((*str == 'Z') || (*str == '-') || (*str == '+')) {
		*(p++) = '0';
		*(p++) = '0';
	} else {
		if (i < 2)
			return 0;
		*(p++) = *(str++);
		*(p++) = *(str++);
		i -= 2;
		if (i < 1)
			return 0;
		/* Skip any fractional seconds... */
		if (*str == '.') {
			str++;
			i--;
			while (i > 1 && (*str >= '0') && (*str <= '9')) {
				str++;
				i--;
			}
		}
	}
	*(p++) = 'Z';
	*(p++) = '\0';
d1661 2
a1662 25
	if (i < 1)
		return 0;
	if (*str == 'Z') {
		if (i != 1)
			return 0;
		offset = 0;
	} else {
		if (i != 5)
			return 0;
		if ((*str != '+') && (*str != '-'))
			return 0;
		if (str[1] < '0' || str[1] > '9' ||
		    str[2] < '0' || str[2] > '9' ||
		    str[3] < '0' || str[3] > '9' ||
		    str[4] < '0' || str[4] > '9')
			return 0;
		offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;
		offset += (str[3] - '0') * 10 + (str[4] - '0');
		if (*str == '-')
			offset = -offset;
	}
	atm.type = ctm->type;
	atm.flags = 0;
	atm.length = sizeof(buff2);
	atm.data = (unsigned char *)buff2;
d1664 7
a1670 2
	if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)
		return 0;
d1672 2
a1673 15
	if (ctm->type == V_ASN1_UTCTIME) {
		i = (buff1[0] - '0') * 10 + (buff1[1] - '0');
		if (i < 50)
			i += 100; /* cf. RFC 2459 */
		j = (buff2[0] - '0') * 10 + (buff2[1] - '0');
		if (j < 50)
			j += 100;
		if (i < j)
			return -1;
		if (i > j)
			return 1;
	}
	i = strcmp(buff1, buff2);
	if (i == 0) /* wait a second then return younger :-) */
		return -1;
d1675 3
a1677 1
		return i;
@


1.44
log
@Now that it is safe to invoke X509_STORE_CTX_cleanup() if X509_STORE_CTX_init()
fails, check its return value and correctly mop up after ourselves.
ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.43 2015/07/19 01:44:16 doug Exp $ */
d761 1
a761 1
	time_t *ptime;
d764 6
a771 4
	if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
		ptime = &ctx->param->check_time;
	else
		ptime = NULL;
d1494 1
a1494 1
	time_t *ptime;
d1497 3
a1501 2
	else
		ptime = NULL;
@


1.43
log
@Simplify X509_STORE_CTX_init and make it safe with stack variables.

The current version is not safe with stack variables because it may
return prematurely with a partially constructed object on error.

ok miod@@ a while back
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.42 2015/06/11 15:58:53 jsing Exp $ */
d1094 4
a1097 2
	if (!X509_STORE_CTX_init(&crl_ctx, ctx->ctx, x, ctx->untrusted))
		return -1;
@


1.42
log
@Avoid a potential out-of-bounds read in X509_cmp_time(), due to missing
length checks.

Diff based on changes in OpenSSL.

Fixes CVE-2015-1789.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.41 2015/04/11 16:03:21 deraadt Exp $ */
d2004 1
a2004 1
	int ret = 1;
d2006 17
a2023 1
	ctx->current_method = 0;
a2025 15
	ctx->crls = NULL;
	ctx->last_untrusted = 0;
	ctx->other_ctx = NULL;
	ctx->valid = 0;
	ctx->chain = NULL;
	ctx->error = 0;
	ctx->explicit_policy = 0;
	ctx->error_depth = 0;
	ctx->current_cert = NULL;
	ctx->current_issuer = NULL;
	ctx->current_crl = NULL;
	ctx->current_crl_score = 0;
	ctx->current_reasons = 0;
	ctx->tree = NULL;
	ctx->parent = NULL;
d2027 2
a2028 13
	ctx->param = X509_VERIFY_PARAM_new();

	if (!ctx->param) {
		X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
		return 0;
	}

	/* Inherit callbacks and flags from X509_STORE if not set
	 * use defaults.
	 */

	if (store)
		ret = X509_VERIFY_PARAM_inherit(ctx->param, store->param);
d2030 1
a2030 1
		ctx->param->inh_flags |= X509_VP_FLAG_DEFAULT|X509_VP_FLAG_ONCE;
d2032 1
a2032 1
	if (store) {
a2033 15
		ctx->cleanup = store->cleanup;
	} else
		ctx->cleanup = 0;

	if (ret)
		ret = X509_VERIFY_PARAM_inherit(ctx->param,
		    X509_VERIFY_PARAM_lookup("default"));

	if (ret == 0) {
		X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
		return 0;
	}

	if (store && store->check_issued)
		ctx->check_issued = store->check_issued;
d2035 1
a2035 1
		ctx->check_issued = check_issued;
d2042 2
a2043 2
	if (store && store->verify_cb)
		ctx->verify_cb = store->verify_cb;
d2045 1
a2045 6
		ctx->verify_cb = null_callback;

	if (store && store->verify)
		ctx->verify = store->verify;
	else
		ctx->verify = internal_verify;
d2067 2
d2079 22
a2100 1
	ctx->check_policy = check_policy;
d2102 4
@


1.41
log
@Remove all getenv() calls, especially those wrapped by issetugid().
getenv()'s wrapped by issetugid() are safe, but issetugid() is correct
difficult to impliment on many operating systems.  By accident, a grand
experiment was run over the last year, where issetugid() returned 1 (the
safe value) on a few operating systems.  Noone noticed & complained that
certain environment variables were not working.......
ok doug beck jsing, discussion with others
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.40 2015/02/11 02:17:59 jsing Exp $ */
d1647 1
d1654 1
d1657 2
d1663 2
d1667 3
d1673 2
a1674 1
			while ((*str >= '0') && (*str <= '9'))
d1676 2
d1683 5
a1687 1
	if (*str == 'Z')
d1689 3
a1691 1
	else {
d1693 5
@


1.40
log
@More unifdef OPENSSL_NO_RFC3779 that got missed last time around.

Spotted by beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.39 2015/02/10 08:33:10 jsing Exp $ */
a485 6
#if 0
		/* A hack to keep people who don't want to modify their
		   software happy */
		if (issetugid() == 0 && getenv("OPENSSL_ALLOW_PROXY_CERTS"))
			allow_proxy_certs = 1;
#endif
@


1.40.4.1
log
@MFC: Fix several defects from OpenSSL.

These include:

CVE-2015-1788 - Malformed ECParameters causes infinite loop
CVE-2015-1789 - Exploitable out-of-bounds read in X509_cmp_time
CVE-2015-1792 - CMS verify infinite loop with unknown hash function
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.40 2015/02/11 02:17:59 jsing Exp $ */
a1652 1
		i -= 10;
a1658 1
		i -= 12;
a1660 2
	if (i < 1)
		return 0;
a1664 2
		if (i < 2)
			return 0;
a1666 3
		i -= 2;
		if (i < 1)
			return 0;
d1670 1
a1670 2
			i--;
			while (i > 1 && (*str >= '0') && (*str <= '9')) {
a1671 2
				i--;
			}
d1677 1
a1677 5
	if (i < 1)
		return 0;
	if (*str == 'Z') {
		if (i != 1)
			return 0;
d1679 1
a1679 3
	} else {
		if (i != 5)
			return 0;
a1680 5
			return 0;
		if (str[1] < '0' || str[1] > '9' ||
		    str[2] < '0' || str[2] > '9' ||
		    str[3] < '0' || str[3] > '9' ||
		    str[4] < '0' || str[4] > '9')
@


1.39
log
@The IMPLEMENT_STACK_OF and IMPLEMENT_ASN1_SET_OF macros were turned into
noops around 15 years ago. Remove multiple occurances of both that still
exist in the code today.
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.38 2014/09/29 04:20:14 miod Exp $ */
a378 10

#ifndef OPENSSL_NO_RFC3779
	/* RFC 3779 path validation, now that CRL check has been done */
	ok = v3_asid_validate_path(ctx);
	if (!ok)
		goto end;
	ok = v3_addr_validate_path(ctx);
	if (!ok)
		goto end;
#endif
@


1.38
log
@check_cert(): be sure to reset ctx->current_crl to NULL before freeing it.

X509_STORE_CTX_init(): do not free the X509_STORE_CTX * parameter upon
failure, for we did not allocate it and it might not come from the heap,
such as in check_crl_path() in this very same file where X509_STORE_CTX_init()
gets invoked with a stack address.

ok bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.37 2014/07/17 07:13:02 logan Exp $ */
a2204 8

IMPLEMENT_STACK_OF(X509)
IMPLEMENT_ASN1_SET_OF(X509)

IMPLEMENT_STACK_OF(X509_NAME)

IMPLEMENT_STACK_OF(X509_ATTRIBUTE)
IMPLEMENT_ASN1_SET_OF(X509_ATTRIBUTE)
@


1.37
log
@Free sktmp when it's no longer needed. By doing so, we fix a bunch of memory leaks.

From miod@@

OK from miod@@ and guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.36 2014/07/12 17:35:23 deraadt Exp $ */
d750 1
d766 1
a768 2

	ctx->current_crl = NULL;
d2103 2
a2104 7
	/* This memset() can't make any sense anyway, so it's removed. As
	 * X509_STORE_CTX_cleanup does a proper "free" on the ex_data, we put a
	 * corresponding "new" here and remove this bogus initialisation. */
	/* memset(&(ctx->ex_data),0,sizeof(CRYPTO_EX_DATA)); */
	if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,
	    &(ctx->ex_data))) {
		free(ctx);
@


1.37.4.1
log
@MFC: Fix several defects from OpenSSL.

These include:

CVE-2015-1788 - Malformed ECParameters causes infinite loop
CVE-2015-1789 - Exploitable out-of-bounds read in X509_cmp_time
CVE-2015-1792 - CMS verify infinite loop with unknown hash function
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.37 2014/07/17 07:13:02 logan Exp $ */
a1662 1
		i -= 10;
a1668 1
		i -= 12;
a1670 2
	if (i < 1)
		return 0;
a1674 2
		if (i < 2)
			return 0;
a1676 3
		i -= 2;
		if (i < 1)
			return 0;
d1680 1
a1680 2
			i--;
			while (i > 1 && (*str >= '0') && (*str <= '9')) {
a1681 2
				i--;
			}
d1687 1
a1687 5
	if (i < 1)
		return 0;
	if (*str == 'Z') {
		if (i != 1)
			return 0;
d1689 1
a1689 3
	} else {
		if (i != 5)
			return 0;
a1690 5
			return 0;
		if (str[1] < '0' || str[1] > '9' ||
		    str[2] < '0' || str[2] > '9' ||
		    str[3] < '0' || str[3] > '9' ||
		    str[4] < '0' || str[4] > '9')
@


1.36
log
@jsing and I are investigating removal of all? most? 'getenv from library'
instances.  This one for OPENSSL_ALLOW_PROXY_CERTS gets turned off first,
especially since it had this special comment:
/* A hack to keep people who don't want to modify their software happy */
ok beck jsing
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.35 2014/07/12 14:58:32 miod Exp $ */
d233 3
a235 1

@


1.35
log
@Principle of least surprise: make CMAC_CTX_free(), OCSP_REQ_CTX_free() and
X509_STORE_CTX_free() accept NULL pointers as input without dereferencing them,
like all the other well-behaved *_CTX_free() functions do.
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.34 2014/07/11 12:52:41 miod Exp $ */
d494 1
d499 1
@


1.34
log
@When looking for the issuer of a certificate, if the current candidate is
expired or not valid yet, continue looking; only return an expired certificate
if no valid certificates have been found.

OpenSSL PR #3359 via OpenSSL trunk.
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.33 2014/07/11 08:44:49 jsing Exp $ */
d1982 3
@


1.33
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.32 2014/07/10 22:45:58 jsing Exp $ */
d76 1
d412 1
a412 1
	X509 *issuer;
d416 5
a420 2
		if (ctx->check_issued(ctx, x, issuer))
			return issuer;
d422 1
a422 1
	return NULL;
d1499 2
a1500 2
static int
check_cert_time(X509_STORE_CTX *ctx, X509 *x)
d1512 2
d1521 2
d1531 2
d1540 2
d1612 1
a1612 1
		ok = check_cert_time(ctx, xs);
@


1.32
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.31 2014/07/10 13:58:23 jsing Exp $ */
d67 2
a68 1
#include "cryptlib.h"
d70 2
d73 1
a73 3
#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <openssl/asn1.h>
a75 1
#include <openssl/objects.h>
@


1.31
log
@Stop including standard headers via cryptlib.h - pull in the headers that
are needed in the source files that actually require them.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.30 2014/07/09 11:10:51 bcook Exp $ */
d64 2
@


1.30
log
@remove unused, private version strings except SSL_version_str

Also remove unused des_ver.h, which exports some of these strings, but is not installed.

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.29 2014/06/20 20:59:49 deraadt Exp $ */
d59 1
d61 1
d63 1
a63 1
#include <errno.h>
@


1.29
log
@wrap getenv OPENSSL_ALLOW_PROXY_CERTS in an issetugid check, to protect
setuid applications from being fooled.
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.28 2014/06/19 21:24:35 tedu Exp $ */
a135 2
const char X509_version[]="X.509" OPENSSL_VERSION_PTEXT;

@


1.28
log
@check stack push return and make some effort to clean up. ok beck miod
@
text
@d1 1
a1 1
/* $OpenBSD: x509_vfy.c,v 1.27 2014/06/12 15:49:31 deraadt Exp $ */
d490 1
a490 1
		if (getenv("OPENSSL_ALLOW_PROXY_CERTS"))
@


1.27
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d316 5
a320 1
			sk_X509_push(ctx->chain, chain_ss);
@


1.26
log
@calloc instead of malloc/memset. from Benjamin Baier
@
text
@d1 1
a1 1
/* crypto/x509/x509_vfy.c */
@


1.25
log
@KNF.
@
text
@d1953 1
a1953 1
	ctx = (X509_STORE_CTX *)malloc(sizeof(X509_STORE_CTX));
a1957 1
	memset(ctx, 0, sizeof(X509_STORE_CTX));
@


1.24
log
@blunt force knf
@
text
@d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d111 1
a111 1
static int null_callback(int ok,X509_STORE_CTX *e);
d122 1
a122 2
			unsigned int *preasons,
			X509_CRL *crl, X509 *x);
d124 1
a124 1
				X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x);
d126 3
a128 3
			X509_CRL *base, STACK_OF(X509_CRL) *crls);
static void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl,
				X509 **pissuer, int *pcrl_score);
d130 1
a130 1
				unsigned int *preasons);
d132 2
a133 3
static int check_crl_chain(X509_STORE_CTX *ctx,
			STACK_OF(X509) *cert_path,
			STACK_OF(X509) *crl_path);
d139 2
a140 1
static int null_callback(int ok, X509_STORE_CTX *e)
d146 2
a147 1
static int x509_subject_cmp(X509 **a, X509 **b)
d149 1
a149 1
	return X509_subject_name_cmp(*a,*b);
d153 2
a154 1
int X509_verify_cert(X509_STORE_CTX *ctx)
d156 1
a156 1
	X509 *x,*xtmp,*chain_ss=NULL;
d159 1
a159 1
	int depth,i,ok=0;
d161 3
a163 2
	int (*cb)(int xok,X509_STORE_CTX *xctx);
	STACK_OF(X509) *sktmp=NULL;
d165 2
a166 1
		X509err(X509_F_X509_VERIFY_CERT,X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
d170 1
a170 1
	cb=ctx->verify_cb;
d175 3
a177 3
		if (	((ctx->chain=sk_X509_new_null()) == NULL) ||
			(!sk_X509_push(ctx->chain,ctx->cert))) {
			X509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);
d180 2
a181 2
		CRYPTO_add(&ctx->cert->references,1,CRYPTO_LOCK_X509);
		ctx->last_untrusted=1;
d185 3
a187 3
	if (ctx->untrusted != NULL
	    && (sktmp=sk_X509_dup(ctx->untrusted)) == NULL) {
		X509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);
d191 3
a193 4
	num=sk_X509_num(ctx->chain);
	x=sk_X509_value(ctx->chain,num-1);
	depth=param->depth;

d197 6
a202 5
		if (depth < num) break; /* FIXME: If this happens, we should take
		                         * note of it and, if appropriate, use the
		                         * X509_V_ERR_CERT_CHAIN_TOO_LONG error
		                         * code later.
		                         */
d205 2
a206 1
		if (ctx->check_issued(ctx, x,x)) break;
d210 1
a210 1
			xtmp=find_issuer(ctx, sktmp,x);
d212 3
a214 2
				if (!sk_X509_push(ctx->chain,xtmp)) {
					X509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);
d217 3
a219 2
				CRYPTO_add(&xtmp->references,1,CRYPTO_LOCK_X509);
				(void)sk_X509_delete_ptr(sktmp,xtmp);
d221 1
a221 1
				x=xtmp;
d239 2
a240 2
	i=sk_X509_num(ctx->chain);
	x=sk_X509_value(ctx->chain,i-1);
d250 6
a255 4
				ctx->error=X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
				ctx->current_cert=x;
				ctx->error_depth=i-1;
				if (ok == 1) X509_free(xtmp);
d257 3
a259 2
				ok=cb(0,ctx);
				if (!ok) goto end;
d267 1
a267 1
				ctx->last_untrusted=0;
d271 1
a271 1
			chain_ss=sk_X509_pop(ctx->chain);
d274 1
a274 1
			x=sk_X509_value(ctx->chain,num-1);
d281 2
a282 1
		if (depth < num) break;
d285 2
a286 1
		if (ctx->check_issued(ctx,x,x)) break;
d289 4
a292 3

		if (ok < 0) return ok;
		if (ok == 0) break;
d295 1
a295 1
		if (!sk_X509_push(ctx->chain,x)) {
d297 1
a297 1
			X509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);
d306 3
a308 2
	if (!ctx->check_issued(ctx,x,x)) {
		if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
d310 1
a310 1
				ctx->error=X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
d312 2
a313 2
				ctx->error=X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
			ctx->current_cert=x;
d316 1
a316 1
			sk_X509_push(ctx->chain,chain_ss);
d318 4
a321 4
			ctx->last_untrusted=num;
			ctx->current_cert=chain_ss;
			ctx->error=X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
			chain_ss=NULL;
d324 1
a324 1
		ctx->error_depth=num-1;
d326 3
a328 2
		ok=cb(0,ctx);
		if (!ok) goto end;
d334 2
a335 1
	if (!ok) goto end;
d340 3
a342 2
	
	if (!ok) goto end;
d346 2
a347 1
	if (param->trust > 0) ok = check_trust(ctx);
d349 2
a350 1
	if (!ok) goto end;
d353 1
a353 1
	X509_get_pubkey_parameters(NULL,ctx->chain);
d360 2
a361 1
	if(!ok) goto end;
d365 1
a365 1
		ok=ctx->verify(ctx);
d367 3
a369 2
		ok=internal_verify(ctx);
	if(!ok) goto end;
d374 2
a375 1
	if (!ok) goto end;
d377 2
a378 1
	if (!ok) goto end;
d384 2
a385 1
	if(!ok) goto end;
d388 1
a388 1
		X509_get_pubkey_parameters(NULL,ctx->chain);
d390 4
a393 2
	if (sktmp != NULL) sk_X509_free(sktmp);
	if (chain_ss != NULL) X509_free(chain_ss);
d401 2
a402 1
static X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x)
d406 1
d417 2
a418 1
static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)
d421 1
d437 2
a438 1
static int get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
d442 1
a442 1
		CRYPTO_add(&(*issuer)->references,1,CRYPTO_LOCK_X509);
a446 1
	
d452 2
a453 1
static int check_chain_extensions(X509_STORE_CTX *ctx)
d458 1
a458 1
	int i, ok=0, must_be_ca, plen = 0;
d460 1
a460 1
	int (*cb)(int xok,X509_STORE_CTX *xctx);
d464 2
a465 1
	cb=ctx->verify_cb;
d483 1
a483 1
			!!(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);
d495 2
a496 2
		if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
			&& (x->ex_flags & EXFLAG_CRITICAL)) {
d500 3
a502 2
			ok=cb(0,ctx);
			if (!ok) goto end;
d508 3
a510 2
			ok=cb(0,ctx);
			if (!ok) goto end;
d513 1
a513 1
		switch(must_be_ca) {
d515 2
a516 2
			if ((ctx->param->flags & X509_V_FLAG_X509_STRICT)
				&& (ret != 1) && (ret != 0)) {
d530 3
a532 3
			if ((ret == 0)
				|| ((ctx->param->flags & X509_V_FLAG_X509_STRICT)
					&& (ret != 1))) {
d542 3
a544 2
			ok=cb(0,ctx);
			if (!ok) goto end;
d548 3
a550 3
			if ((ret == 0)
				|| ((ctx->param->flags & X509_V_FLAG_X509_STRICT)
					&& (ret != 1))) {
d554 3
a556 2
				ok=cb(0,ctx);
				if (!ok) goto end;
d560 3
a562 3
		if ((i > 1) && !(x->ex_flags & EXFLAG_SI)
			   && (x->ex_pathlen != -1)
			   && (plen > (x->ex_pathlen + proxy_path_length + 1))) {
d566 3
a568 2
			ok=cb(0,ctx);
			if (!ok) goto end;
d580 1
a580 1
					X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;
d583 3
a585 2
				ok=cb(0,ctx);
				if (!ok) goto end;
d593 2
a594 1
 end:
d599 2
a600 1
static int check_name_constraints(X509_STORE_CTX *ctx)
d604 1
d624 1
a624 1
					if (!ctx->verify_cb(0,ctx))
d633 2
a634 1
static int check_trust(X509_STORE_CTX *ctx)
d641 4
a644 3
	int (*cb)(int xok,X509_STORE_CTX *xctx);
	cb=ctx->verify_cb;
/* For now just check the last certificate in the chain */
d661 2
a662 1
static int check_revocation(X509_STORE_CTX *ctx)
d665 1
d676 1
a676 1
	for(i = 0; i <= last; i++) {
d679 2
a680 1
		if (!ok) return ok;
d685 3
a687 1
static int check_cert(X509_STORE_CTX *ctx) {
d692 1
d709 1
a709 1
		if(!ok) {
d749 1
a755 1

d760 2
a761 1
static int check_crl_time(X509_STORE_CTX *ctx, X509_CRL *crl, int notify)
d765 1
d773 1
a773 1
	i=X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);
d777 1
a777 1
		ctx->error=X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;
d785 1
a785 1
		ctx->error=X509_V_ERR_CRL_NOT_YET_VALID;
d790 2
a791 2
	if(X509_CRL_get_nextUpdate(crl)) {
		i=X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);
d796 1
a796 1
			ctx->error=X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;
d801 2
a802 1
		if ((i < 0) && !(ctx->current_crl_score & CRL_SCORE_TIME_DELTA)) {
d805 1
a805 1
			ctx->error=X509_V_ERR_CRL_HAS_EXPIRED;
d817 4
a820 3
static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
			X509 **pissuer, int *pscore, unsigned int *preasons,
			STACK_OF(X509_CRL) *crls)
d866 2
a867 1
static int crl_extension_match(X509_CRL *a, X509_CRL *b, int nid)
d871 1
a883 1

a895 1

d904 2
a905 1
static int check_delta_base(X509_CRL *delta, X509_CRL *base)
d909 1
a909 1
			return 0;
d912 1
a912 1
			return 0;
d915 1
a915 1
				X509_CRL_get_issuer(delta)))
d919 1
a919 1
			return 0;
d921 1
a921 1
			return 0;
d924 1
a924 1
			return 0;
d927 1
a927 1
			return 1;
d935 3
a937 2
static void get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pscore,
			X509_CRL *base, STACK_OF(X509_CRL) *crls)
d941 1
d966 3
a968 3
static int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,
			unsigned int *preasons,
			X509_CRL *crl, X509 *x)
a969 1

a1024 1

d1027 3
a1029 2
static void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl,
				X509 **pissuer, int *pcrl_score)
d1083 1
a1083 1
 * will be duplicated by the parent, but this will rarely be used in 
d1087 2
a1088 1
static int check_crl_path(X509_STORE_CTX *ctx, X509 *x)
d1092 1
d1113 1
d1115 1
a1115 2
	ret = check_crl_chain(ctx, ctx->chain, crl_ctx.chain);
	err:
d1128 3
a1130 3
static int check_crl_chain(X509_STORE_CTX *ctx,
			STACK_OF(X509) *cert_path,
			STACK_OF(X509) *crl_path)
d1133 1
d1148 2
a1149 2

static int idp_check_dp(DIST_POINT_NAME *a, DIST_POINT_NAME *b)
d1155 1
d1184 1
a1184 1
			gena = sk_GENERAL_NAME_value(gens, i);	
a1204 1

d1207 2
a1208 1
static int crldp_check_crlissuer(DIST_POINT *dp, X509_CRL *crl, int crl_score)
d1212 1
d1228 2
a1229 2
static int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,
				unsigned int *preasons)
d1232 1
d1247 1
a1247 1
			     idp_check_dp(dp->distpoint, crl->idp->distpoint)) {
d1253 2
a1254 1
	if ((!crl->idp || !crl->idp->distpoint) && (crl_score & CRL_SCORE_ISSUER_NAME))
d1262 3
a1264 3
	
static int get_crl_delta(X509_STORE_CTX *ctx,
				X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x)
d1273 1
d1275 2
a1276 3
	ok = get_crl_sk(ctx, &crl, &dcrl, 
				&issuer, &crl_score, &reasons, ctx->crls);

a1280 1

d1291 1
a1291 1
	done:
d1307 2
a1308 1
static int check_crl(X509_STORE_CTX *ctx, X509_CRL *crl)
d1313 1
d1327 1
a1327 1
		if(!ctx->check_issued(ctx, issuer, issuer)) {
d1330 2
a1331 1
			if(!ok) goto err;
d1335 1
a1335 1
	if(issuer) {
d1342 1
a1342 1
				!(issuer->ex_kusage & KU_CRL_SIGN)) {
d1345 2
a1346 1
				if(!ok) goto err;
d1352 2
a1353 1
				if(!ok) goto err;
d1357 2
a1358 1
				if (check_crl_path(ctx, ctx->current_issuer) <= 0) {
d1361 2
a1362 1
					if(!ok) goto err;
d1369 2
a1370 1
				if(!ok) goto err;
d1385 2
a1386 2
		if(!ikey) {
			ctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
d1388 2
a1389 1
			if (!ok) goto err;
d1392 2
a1393 2
			if(X509_CRL_verify(crl, ikey) <= 0) {
				ctx->error=X509_V_ERR_CRL_SIGNATURE_FAILURE;
d1395 2
a1396 1
				if (!ok) goto err;
d1409 2
a1410 1
static int cert_crl(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x)
d1414 1
d1417 1
a1417 1
	 * a certificate was revoked. This has since been changed since 
d1420 2
a1421 2
	if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
		&& (crl->flags & EXFLAG_CRITICAL)) {
d1424 1
a1424 1
		if(!ok)
d1442 2
a1443 1
static int check_policy(X509_STORE_CTX *ctx)
d1446 1
d1450 1
a1450 1
				ctx->param->policies, ctx->param->flags);
d1452 1
a1452 1
		X509err(X509_F_CHECK_POLICY,ERR_R_MALLOC_FAILURE);
d1468 1
a1468 1
			if(!ctx->verify_cb(0, ctx))
d1489 2
a1490 1
static int check_cert_time(X509_STORE_CTX *ctx, X509 *x)
d1500 1
a1500 1
	i=X509_cmp_time(X509_get_notBefore(x), ptime);
d1502 2
a1503 2
		ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;
		ctx->current_cert=x;
d1509 2
a1510 2
		ctx->error=X509_V_ERR_CERT_NOT_YET_VALID;
		ctx->current_cert=x;
d1515 1
a1515 1
	i=X509_cmp_time(X509_get_notAfter(x), ptime);
d1517 2
a1518 2
		ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;
		ctx->current_cert=x;
d1524 2
a1525 2
		ctx->error=X509_V_ERR_CERT_HAS_EXPIRED;
		ctx->current_cert=x;
d1533 2
a1534 1
static int internal_verify(X509_STORE_CTX *ctx)
d1536 4
a1539 4
	int ok=0,n;
	X509 *xs,*xi;
	EVP_PKEY *pkey=NULL;
	int (*cb)(int xok,X509_STORE_CTX *xctx);
d1541 1
a1541 1
	cb=ctx->verify_cb;
d1543 2
a1544 2
	n=sk_X509_num(ctx->chain);
	ctx->error_depth=n-1;
d1546 1
a1546 1
	xi=sk_X509_value(ctx->chain,n);
d1549 1
a1549 1
		xs=xi;
d1552 3
a1554 3
			ctx->error=X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;
			ctx->current_cert=xi;
			ok=cb(0,ctx);
d1558 2
a1559 2
			ctx->error_depth=n;
			xs=sk_X509_value(ctx->chain,n);
d1565 1
a1565 1
		ctx->error_depth=n;
d1571 12
a1582 10
		if (!xs->valid && (xs != xi || (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {
			if ((pkey=X509_get_pubkey(xi)) == NULL) {
				ctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
				ctx->current_cert=xi;
				ok=(*cb)(0,ctx);
				if (!ok) goto end;
			} else if (X509_verify(xs,pkey) <= 0) {
				ctx->error=X509_V_ERR_CERT_SIGNATURE_FAILURE;
				ctx->current_cert=xs;
				ok=(*cb)(0,ctx);
d1589 1
a1589 1
			pkey=NULL;
d1599 5
a1603 4
		ctx->current_issuer=xi;
		ctx->current_cert=xs;
		ok=(*cb)(1,ctx);
		if (!ok) goto end;
d1607 2
a1608 2
			xi=xs;
			xs=sk_X509_value(ctx->chain,n);
d1611 2
a1612 1
	ok=1;
d1617 2
a1618 1
int X509_cmp_current_time(const ASN1_TIME *ctm)
d1623 2
a1624 1
int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)
d1629 2
a1630 2
	char buff1[24],buff2[24],*p;
	int i,j;
d1632 3
a1634 3
	p=buff1;
	i=ctm->length;
	str=(char *)ctm->data;
d1636 5
a1640 4
		if ((i < 11) || (i > 17)) return 0;
		memcpy(p,str,10);
		p+=10;
		str+=10;
d1642 5
a1646 4
		if (i < 13) return 0;
		memcpy(p,str,12);
		p+=12;
		str+=12;
d1650 5
a1654 5
		*(p++)='0';
		*(p++)='0';
	} else { 
		*(p++)= *(str++);
		*(p++)= *(str++);
d1658 2
a1659 1
			while ((*str >= '0') && (*str <= '9')) str++;
a1660 1
		
d1662 2
a1663 2
	*(p++)='Z';
	*(p++)='\0';
d1666 1
a1666 1
		offset=0;
d1670 2
a1671 2
		offset=((str[1]-'0')*10+(str[2]-'0'))*60;
		offset+=(str[3]-'0')*10+(str[4]-'0');
d1673 1
a1673 1
			offset= -offset;
d1675 1
a1675 1
	atm.type=ctm->type;
d1677 2
a1678 2
	atm.length=sizeof(buff2);
	atm.data=(unsigned char *)buff2;
d1680 1
a1680 1
	if (X509_time_adj(&atm, offset*60, cmp_time) == NULL)
d1684 10
a1693 7
		i=(buff1[0]-'0')*10+(buff1[1]-'0');
		if (i < 50) i+=100; /* cf. RFC 2459 */
		j=(buff2[0]-'0')*10+(buff2[1]-'0');
		if (j < 50) j+=100;

		if (i < j) return -1;
		if (i > j) return 1;
d1695 1
a1695 1
	i=strcmp(buff1,buff2);
d1702 2
a1703 1
ASN1_TIME *X509_gmtime_adj(ASN1_TIME *s, long adj)
d1708 2
a1709 1
ASN1_TIME *X509_time_adj(ASN1_TIME *s, long offset_sec, time_t *in_tm)
d1714 2
a1715 2
ASN1_TIME *X509_time_adj_ex(ASN1_TIME *s,
				int offset_day, long offset_sec, time_t *in_tm)
d1719 4
a1722 2
	if (in_tm) t = *in_tm;
	else time(&t);
d1726 1
a1726 1
			return ASN1_UTCTIME_adj(s,t, offset_day, offset_sec);
d1729 1
a1729 1
								offset_sec);
d1734 2
a1735 1
int X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)
d1737 2
a1738 2
	EVP_PKEY *ktmp=NULL,*ktmp2;
	int i,j;
d1740 2
a1741 1
	if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey)) return 1;
d1743 2
a1744 2
	for (i=0; i<sk_X509_num(chain); i++) {
		ktmp=X509_get_pubkey(sk_X509_value(chain,i));
d1746 2
a1747 1
			X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
d1754 1
a1754 1
			ktmp=NULL;
d1758 2
a1759 1
		X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);
d1764 3
a1766 3
	for (j=i-1; j >= 0; j--) {
		ktmp2=X509_get_pubkey(sk_X509_value(chain,j));
		EVP_PKEY_copy_parameters(ktmp2,ktmp);
d1769 3
a1771 2
	
	if (pkey != NULL) EVP_PKEY_copy_parameters(pkey,ktmp);
d1776 3
a1778 2
int X509_STORE_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
d1782 2
a1783 2
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, argl, argp,
			new_func, dup_func, free_func);
d1786 2
a1787 1
int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)
d1789 1
a1789 1
	return CRYPTO_set_ex_data(&ctx->ex_data,idx,data);
d1792 2
a1793 1
void *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)
d1795 1
a1795 1
	return CRYPTO_get_ex_data(&ctx->ex_data,idx);
d1798 2
a1799 1
int X509_STORE_CTX_get_error(X509_STORE_CTX *ctx)
d1804 2
a1805 1
void X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)
d1807 1
a1807 1
	ctx->error=err;
d1810 2
a1811 1
int X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)
d1816 2
a1817 1
X509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)
d1832 3
a1834 1
	if (!ctx->chain || !(chain = sk_X509_dup(ctx->chain))) return NULL;
d1842 2
a1843 1
X509 *X509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx)
d1848 2
a1849 1
X509_CRL *X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx)
d1854 2
a1855 1
X509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx)
d1860 2
a1861 1
void X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)
d1863 1
a1863 1
	ctx->cert=x;
d1866 2
a1867 1
void X509_STORE_CTX_set_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
d1869 1
a1869 1
	ctx->untrusted=sk;
d1872 2
a1873 1
void X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk)
d1875 1
a1875 1
	ctx->crls=sk;
d1878 2
a1879 1
int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)
d1884 2
a1885 1
int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)
d1900 3
a1902 2
int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
				int purpose, int trust)
d1905 1
d1907 2
a1908 1
	if (!purpose) purpose = def_purpose;
d1915 1
a1915 1
						X509_R_UNKNOWN_PURPOSE_ID);
d1923 1
a1923 1
						X509_R_UNKNOWN_PURPOSE_ID);
d1929 2
a1930 1
		if (!trust) trust = ptmp->trust;
d1936 1
a1936 1
						X509_R_UNKNOWN_TRUST_ID);
d1941 4
a1944 2
	if (purpose && !ctx->param->purpose) ctx->param->purpose = purpose;
	if (trust && !ctx->param->trust) ctx->param->trust = trust;
d1948 2
a1949 1
X509_STORE_CTX *X509_STORE_CTX_new(void)
d1952 1
d1955 1
a1955 1
		X509err(X509_F_X509_STORE_CTX_NEW,ERR_R_MALLOC_FAILURE);
d1962 2
a1963 1
void X509_STORE_CTX_free(X509_STORE_CTX *ctx)
d1969 3
a1971 2
int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
	     STACK_OF(X509) *chain)
d1974 5
a1978 4
	ctx->ctx=store;
	ctx->current_method=0;
	ctx->cert=x509;
	ctx->untrusted=chain;
d1980 12
a1991 12
	ctx->last_untrusted=0;
	ctx->other_ctx=NULL;
	ctx->valid=0;
	ctx->chain=NULL;
	ctx->error=0;
	ctx->explicit_policy=0;
	ctx->error_depth=0;
	ctx->current_cert=NULL;
	ctx->current_issuer=NULL;
	ctx->current_crl=NULL;
	ctx->current_crl_score=0;
	ctx->current_reasons=0;
d1998 1
a1998 1
		X509err(X509_F_X509_STORE_CTX_INIT,ERR_R_MALLOC_FAILURE);
a2005 1

d2019 1
a2019 1
					X509_VERIFY_PARAM_lookup("default"));
d2022 1
a2022 1
		X509err(X509_F_X509_STORE_CTX_INIT,ERR_R_MALLOC_FAILURE);
d2083 2
a2084 2
	if(!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,
				&(ctx->ex_data))) {
d2086 1
a2086 1
		X509err(X509_F_X509_STORE_CTX_INIT,ERR_R_MALLOC_FAILURE);
d2096 2
a2097 1
void X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
d2103 2
a2104 1
void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
d2106 2
a2107 1
	if (ctx->cleanup) ctx->cleanup(ctx);
d2111 1
a2111 1
		ctx->param=NULL;
d2115 1
a2115 1
		ctx->tree=NULL;
d2118 2
a2119 2
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
d2121 3
a2123 2
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
d2126 2
a2127 1
void X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)
d2132 2
a2133 1
void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)
d2138 2
a2139 1
void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags, time_t t)
d2144 3
a2146 2
void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,
				  int (*verify_cb)(int, X509_STORE_CTX *))
d2148 1
a2148 1
	ctx->verify_cb=verify_cb;
d2151 2
a2152 1
X509_POLICY_TREE *X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx)
d2157 2
a2158 1
int X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx)
d2163 2
a2164 1
int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)
d2173 2
a2174 1
X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)
d2179 2
a2180 1
void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)
@


1.23
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d142 1
a142 1
	{
d144 1
a144 1
	}
d148 1
a148 1
	{
d150 1
a150 1
	}
d154 1
a154 1
	{
d162 1
a162 2
	if (ctx->cert == NULL)
		{
d165 1
a165 1
		}
d171 1
a171 2
	if (ctx->chain == NULL)
		{
d173 1
a173 2
			(!sk_X509_push(ctx->chain,ctx->cert)))
			{
d176 1
a176 1
			}
d179 1
a179 1
		}
d183 1
a183 2
	    && (sktmp=sk_X509_dup(ctx->untrusted)) == NULL)
		{
d186 1
a186 1
		}
d193 1
a193 2
	for (;;)
		{
d205 1
a205 2
		if (ctx->untrusted != NULL)
			{
d207 2
a208 4
			if (xtmp != NULL)
				{
				if (!sk_X509_push(ctx->chain,xtmp))
					{
d211 1
a211 1
					}
a219 1
				}
d221 1
d223 1
a223 1
		}
d235 1
a235 2
	if (ctx->check_issued(ctx, x, x))
		{
d237 1
a237 2
		if (sk_X509_num(ctx->chain) == 1)
			{
d243 1
a243 2
			if ((ok <= 0) || X509_cmp(x, xtmp)) 
				{
d251 1
a251 3
				}
			else 
				{
a258 1
				}
d260 1
a260 2
		else
			{
a265 1
			}
d267 1
d270 1
a270 2
	for (;;)
		{
d283 1
a283 2
		if (!sk_X509_push(ctx->chain,x))
			{
d287 1
a287 1
			}
d289 1
a289 1
		}
d294 2
a295 4
	if (!ctx->check_issued(ctx,x,x))
		{
		if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss))
			{
d301 1
a301 3
			}
		else
			{
d309 1
a309 1
			}
d315 1
a315 1
		}
d363 1
a363 2
	if (0)
		{
d366 1
a366 1
		}
d370 1
a370 1
	}
d380 1
a380 2
	for (i = 0; i < sk_X509_num(sk); i++)
		{
d384 1
a384 1
		}
d411 1
a411 2
	if (*issuer)
		{
d414 1
a414 2
		}
	else
d447 1
a447 2
	if (ctx->parent)
		{
d450 1
a450 3
		}
	else
		{
d458 1
a458 1
		}
d461 1
a461 2
	for (i = 0; i < ctx->last_untrusted; i++)
		{
d465 1
a465 2
			&& (x->ex_flags & EXFLAG_CRITICAL))
			{
d471 2
a472 3
			}
		if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY))
			{
d478 1
a478 1
			}
d480 1
a480 2
		switch(must_be_ca)
			{
d483 1
a483 2
				&& (ret != 1) && (ret != 0))
				{
d486 1
a486 2
				}
			else
d490 1
a490 2
			if (ret != 0)
				{
d493 1
a493 2
				}
			else
d499 1
a499 2
					&& (ret != 1)))
				{
d502 1
a502 2
				}
			else
d505 2
a506 3
			}
		if (ret == 0)
			{
d511 2
a512 3
			}
		if (ctx->param->purpose > 0)
			{
d516 1
a516 2
					&& (ret != 1)))
				{
a521 1
				}
d523 1
d527 1
a527 2
			   && (plen > (x->ex_pathlen + proxy_path_length + 1)))
			{
d533 1
a533 1
			}
d541 2
a542 4
		if (x->ex_flags & EXFLAG_PROXY)
			{
			if (x->ex_pcpathlen != -1 && i > x->ex_pcpathlen)
				{
d549 1
a549 1
				}
d552 1
a552 2
			}
		else
d554 1
a554 1
		}
d562 1
a562 1
	{
d566 1
a566 2
	for (i = sk_X509_num(ctx->chain) - 1; i >= 0; i--)
		{
d576 1
a576 2
		for (j = sk_X509_num(ctx->chain) - 1; j > i; j--)
			{
d578 1
a578 2
			if (nc)
				{
d580 1
a580 2
				if (rv != X509_V_OK)
					{
a585 1
					}
d589 1
d591 1
a591 1
	}
d620 1
a620 1
	{
d626 1
a626 2
	else
		{
d631 2
a632 3
		}
	for(i = 0; i <= last; i++)
		{
d636 1
a636 1
		}
d638 1
a638 1
	}
d640 1
a640 2
static int check_cert(X509_STORE_CTX *ctx)
	{
d651 1
a651 2
	while (ctx->current_reasons != CRLDP_ALL_REASONS)
		{
d661 1
a661 2
		if(!ok)
			{
d665 1
a665 1
			}
d671 1
a671 2
		if (dcrl)
			{
d678 1
a678 2
			}
		else
d682 1
a682 2
		if (ok != 2)
			{
d686 1
a686 1
			}
d695 1
a695 2
		if (last_reasons == ctx->current_reasons)
			{
a698 1
			}
d700 2
a701 1
	err:
d708 1
a708 1
	}
d713 1
a713 1
	{
d724 1
a724 2
	if (i == 0)
		{
d730 1
a730 1
		}
d732 1
a732 2
	if (i > 0)
		{
d738 1
a738 1
		}
d740 1
a740 2
	if(X509_CRL_get_nextUpdate(crl))
		{
d743 1
a743 2
		if (i == 0)
			{
d749 1
a749 1
			}
d751 1
a751 2
		if ((i < 0) && !(ctx->current_crl_score & CRL_SCORE_TIME_DELTA))
			{
a756 1
			}
d758 1
d764 1
a764 1
	}
d769 1
a769 1
	{
d776 1
a776 2
	for (i = 0; i < sk_X509_CRL_num(crls); i++)
		{
d781 1
a781 2
		if (crl_score > best_score)
			{
a785 1
			}
d787 1
d789 1
a789 2
	if (best_crl)
		{
d797 1
a797 2
		if (*pdcrl)
			{
d800 1
a800 1
			}
d802 1
a802 1
		}
d808 1
a808 1
	}
d815 1
a815 1
	{
d819 1
a819 2
	if (i >= 0)
		{
d824 1
a824 2
		}
	else
d829 1
a829 2
	if (i >= 0)
		{
d834 1
a834 2
		}
	else
d848 1
a848 1
	}
d853 1
a853 1
	{
d876 1
a876 1
	}
d884 1
a884 1
	{
d891 1
a891 2
	for (i = 0; i < sk_X509_CRL_num(crls); i++)
		{
d893 1
a893 2
		if (check_delta_base(delta, base))
			{
a898 1
			}
d900 1
d902 1
a902 1
	}
d914 1
a914 1
	{
d925 1
a925 2
	if (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT))
		{
d928 1
a928 3
		}
	else if (crl->idp_flags & IDP_REASONS)
		{
d932 1
a932 1
		}
d937 1
a937 2
	if (X509_NAME_cmp(X509_get_issuer_name(x), X509_CRL_get_issuer(crl)))
		{
d940 1
a940 2
		}
	else
d960 1
a960 2
	if (crl_crldp_check(x, crl, crl_score, &crl_reasons))
		{
d966 1
a966 1
		}
d972 1
a972 1
	}
d976 1
a976 1
	{
d987 2
a988 4
	if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK)
		{
		if (*pcrl_score & CRL_SCORE_ISSUER_NAME)
			{
a991 1
			}
d993 1
d995 1
a995 2
	for (cidx++; cidx < sk_X509_num(ctx->chain); cidx++)
		{
d999 1
a999 2
		if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK)
			{
a1002 1
			}
d1004 1
d1014 1
a1014 2
	for (i = 0; i < sk_X509_num(ctx->untrusted); i++)
		{
d1018 1
a1018 2
		if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK)
			{
a1021 1
			}
d1024 1
d1034 1
a1034 1
	{
d1062 1
a1062 1
	}
d1075 1
a1075 1
	{
d1082 1
a1082 1
	}
d1093 1
a1093 1
	{
d1100 1
a1100 2
	if (a->type == 1)
		{
d1104 1
a1104 2
		if (b->type == 1)
			{
d1111 1
a1111 1
			}
d1115 1
a1115 3
		}
	else if (b->type == 1)
		{
d1121 1
a1121 1
		}
d1124 2
a1125 4
	if (nm)
		{
		for (i = 0; i < sk_GENERAL_NAME_num(gens); i++)
			{
d1131 1
a1131 1
			}
d1133 1
a1133 1
		}
d1137 1
a1137 2
	for (i = 0; i < sk_GENERAL_NAME_num(a->name.fullname); i++)
		{
d1139 1
a1139 2
		for (j = 0; j < sk_GENERAL_NAME_num(b->name.fullname); j++)
			{
a1142 1
			}
d1144 1
d1148 1
a1148 1
	}
d1151 1
a1151 1
	{
d1157 1
a1157 2
	for (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++)
		{
d1163 1
a1163 1
		}
d1165 1
a1165 1
	}
d1171 1
a1171 1
	{
d1175 1
a1175 2
	if (x->ex_flags & EXFLAG_CA)
		{
d1178 1
a1178 3
		}
	else
		{
d1181 1
a1181 1
		}
d1183 1
a1183 2
	for (i = 0; i < sk_DIST_POINT_num(x->crldp); i++)
		{
d1185 1
a1185 2
		if (crldp_check_crlissuer(dp, crl, crl_score))
			{
d1187 1
a1187 2
			     idp_check_dp(dp->distpoint, crl->idp->distpoint))
				{
a1189 1
				}
d1192 1
d1196 1
a1196 1
	}
d1204 1
a1204 1
	{
d1234 1
a1234 2
	if (crl)
		{
d1241 1
a1241 1
		}
d1244 1
a1244 1
	}
d1248 1
a1248 1
	{
d1255 1
a1255 1
	if (ctx->current_issuer)
d1257 4
a1260 5

	/* Else find CRL issuer: if not last certificate then issuer
	 * is next certificate in chain.
	 */
	else if (cnum < chnum)
d1262 1
a1262 2
	else
		{
d1265 1
a1265 2
		if(!ctx->check_issued(ctx, issuer, issuer))
			{
a1268 1
			}
d1270 1
d1272 1
a1272 2
	if(issuer)
		{
d1276 1
a1276 2
		if (!crl->base_crl_number)
			{
d1279 1
a1279 2
				!(issuer->ex_kusage & KU_CRL_SIGN))
				{
d1283 1
a1283 1
				}
d1285 1
a1285 2
			if (!(ctx->current_crl_score & CRL_SCORE_SCOPE))
				{
d1289 1
a1289 1
				}
d1291 2
a1292 4
			if (!(ctx->current_crl_score & CRL_SCORE_SAME_PATH))
				{
				if (check_crl_path(ctx, ctx->current_issuer) <= 0)
					{
a1295 1
					}
d1297 1
d1299 1
a1299 2
			if (crl->idp_flags & IDP_INVALID)
				{
d1303 1
a1303 1
				}
d1306 1
a1306 1
			}
d1308 1
a1308 2
		if (!(ctx->current_crl_score & CRL_SCORE_TIME))
			{
d1312 1
a1312 1
			}
d1317 1
a1317 2
		if(!ikey)
			{
d1321 1
a1321 3
			}
		else
			{
d1323 1
a1323 2
			if(X509_CRL_verify(crl, ikey) <= 0)
				{
a1326 1
				}
d1329 1
d1333 1
a1333 1
	err:
d1336 1
a1336 1
	}
d1340 1
a1340 1
	{
d1349 1
a1349 2
		&& (crl->flags & EXFLAG_CRITICAL))
		{
d1354 1
a1354 1
		}
d1358 1
a1358 2
	if (X509_CRL_get0_by_cert(crl, &rev, x))
		{
d1365 1
a1365 1
		}
d1368 1
a1368 1
	}
d1371 1
a1371 1
	{
d1377 1
a1377 2
	if (ret == 0)
		{
d1380 1
a1380 1
		}
d1382 1
a1382 2
	if (ret == -1)
		{
d1388 1
a1388 2
		for (i = 1; i < sk_X509_num(ctx->chain); i++)
			{
d1396 1
a1396 1
			}
d1398 2
a1399 3
		}
	if (ret == -2)
		{
d1403 1
a1403 1
		}
d1405 1
a1405 2
	if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY)
		{
d1410 1
a1410 1
		}
d1413 1
a1413 1
	}
d1416 1
a1416 1
	{
d1426 1
a1426 2
	if (i == 0)
		{
d1431 1
a1431 1
		}
d1433 1
a1433 2
	if (i > 0)
		{
d1438 1
a1438 1
		}
d1441 1
a1441 2
	if (i == 0)
		{
d1446 1
a1446 1
		}
d1448 1
a1448 2
	if (i < 0)
		{
d1453 1
a1453 1
		}
d1456 1
a1456 1
	}
d1459 1
a1459 1
	{
d1474 2
a1475 4
	else
		{
		if (n <= 0)
			{
d1480 1
a1480 3
			}
		else
			{
a1483 1
			}
d1485 1
d1488 1
a1488 2
	while (n >= 0)
		{
d1495 2
a1496 4
		if (!xs->valid && (xs != xi || (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE)))
			{
			if ((pkey=X509_get_pubkey(xi)) == NULL)
				{
d1501 1
a1501 3
				}
			else if (X509_verify(xs,pkey) <= 0)
				{
d1505 1
a1505 2
				if (!ok)
					{
a1507 1
					}
d1509 1
d1512 1
a1512 1
			}
d1527 1
a1527 2
		if (n >= 0)
			{
a1529 1
			}
d1531 1
d1535 1
a1535 1
	}
d1543 1
a1543 1
	{
d1553 1
a1553 2
	if (ctm->type == V_ASN1_UTCTIME)
		{
d1558 1
a1558 3
		}
	else
		{
d1563 1
a1563 1
		}
d1565 4
a1568 4
	if ((*str == 'Z') || (*str == '-') || (*str == '+'))
		{ *(p++)='0'; *(p++)='0'; }
	else
		{ 
d1572 1
a1572 2
		if (*str == '.')
			{
d1575 1
a1575 1
			}
d1577 1
a1577 1
		}
d1583 1
a1583 2
	else
		{
d1590 1
a1590 1
		}
d1599 1
a1599 2
	if (ctm->type == V_ASN1_UTCTIME)
		{
d1607 1
a1607 1
		}
d1613 1
a1613 1
	}
d1621 1
a1621 1
	{
d1623 1
a1623 1
	}
d1627 1
a1627 1
	{
d1633 1
a1633 2
	if (s && !(s->flags & ASN1_STRING_FLAG_MSTRING))
		{
d1639 1
a1639 1
		}
d1641 1
a1641 1
	}
d1644 1
a1644 1
	{
d1650 1
a1650 2
	for (i=0; i<sk_X509_num(chain); i++)
		{
d1652 1
a1652 2
		if (ktmp == NULL)
			{
d1655 1
a1655 1
			}
d1658 1
a1658 2
		else
			{
a1660 1
			}
d1662 2
a1663 2
	if (ktmp == NULL)
		{
d1666 1
a1666 1
		}
d1669 1
a1669 2
	for (j=i-1; j >= 0; j--)
		{
d1673 1
a1673 1
		}
d1678 1
a1678 1
	}
d1682 1
a1682 1
	{
d1687 1
a1687 1
	}
d1690 1
a1690 1
	{
d1692 1
a1692 1
	}
d1695 1
a1695 1
	{
d1697 1
a1697 1
	}
d1700 1
a1700 1
	{
d1702 1
a1702 1
	}
d1705 1
a1705 1
	{
d1707 1
a1707 1
	}
d1710 1
a1710 1
	{
d1712 1
a1712 1
	}
d1715 1
a1715 1
	{
d1717 1
a1717 1
	}
d1720 1
a1720 1
	{
d1722 1
a1722 1
	}
d1725 1
a1725 1
	{
d1730 1
a1730 2
	for (i = 0; i < sk_X509_num(chain); i++)
		{
d1733 1
a1733 1
		}
d1735 1
a1735 1
	}
d1738 1
a1738 1
	{
d1740 1
a1740 1
	}
d1743 1
a1743 1
	{
d1745 1
a1745 1
	}
d1748 1
a1748 1
	{
d1750 1
a1750 1
	}
d1753 1
a1753 1
	{
d1755 1
a1755 1
	}
d1758 1
a1758 1
	{
d1760 1
a1760 1
	}
d1763 1
a1763 1
	{
d1765 1
a1765 1
	}
d1768 1
a1768 1
	{
d1770 1
a1770 1
	}
d1773 1
a1773 1
	{
d1775 1
a1775 1
	}
d1794 1
a1794 2
	if (purpose)
		{
d1797 1
a1797 2
		if (idx == -1)
			{
d1801 1
a1801 1
			}
d1803 1
a1803 2
		if (ptmp->trust == X509_TRUST_DEFAULT)
			{
d1805 1
a1805 2
			if (idx == -1)
				{
d1809 1
a1809 1
				}
d1811 1
a1811 1
			}
d1814 2
a1815 3
		}
	if (trust)
		{
d1817 1
a1817 2
		if (idx == -1)
			{
a1820 1
			}
d1822 1
d1833 1
a1833 2
	if (!ctx)
		{
d1836 1
a1836 1
		}
d1849 1
a1849 1
	{
d1873 1
a1873 2
	if (!ctx->param)
		{
d1876 1
a1876 1
		}
d1888 1
a1888 2
	if (store)
		{
d1891 1
a1891 2
		}
	else
d1898 1
a1898 2
	if (ret == 0)
		{
d1901 1
a1901 1
		}
d1961 1
a1961 2
				&(ctx->ex_data)))
		{
d1965 1
a1965 1
		}
d1967 1
a1967 1
	}
d1980 1
a1980 1
	{
d1982 1
a1982 2
	if (ctx->param != NULL)
		{
d1986 2
a1987 3
		}
	if (ctx->tree != NULL)
		{
d1990 2
a1991 3
		}
	if (ctx->chain != NULL)
		{
d1994 1
a1994 1
		}
d1997 1
a1997 1
	}
d2000 1
a2000 1
	{
d2002 1
a2002 1
	}
d2005 1
a2005 1
	{
d2007 1
a2007 1
	}
d2010 1
a2010 1
	{
d2012 1
a2012 1
	}
d2016 1
a2016 1
	{
d2018 1
a2018 1
	}
d2021 1
a2021 1
	{
d2023 1
a2023 1
	}
d2026 1
a2026 1
	{
d2028 1
a2028 1
	}
d2031 1
a2031 1
	{
d2037 1
a2037 1
	}
d2040 1
a2040 1
	{
d2042 1
a2042 1
	}
d2045 1
a2045 1
	{
d2049 1
a2049 1
	}
@


1.22
log
@correct cases of code occuring directly after goto/break/return
ok miod@@ guenther@@
@
text
@d1989 1
a1989 1
	ctx = (X509_STORE_CTX *)OPENSSL_malloc(sizeof(X509_STORE_CTX));
d2002 1
a2002 1
	OPENSSL_free(ctx);
d2125 1
a2125 1
		OPENSSL_free(ctx);
@


1.21
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a426 1
	return 0;
@


1.20
log
@resolve conflicts
@
text
@d697 1
d706 1
d750 9
d886 1
a886 1
	i = X509_CRL_get_ext_by_NID(a, nid, 0);
d897 1
a897 1
	i = X509_CRL_get_ext_by_NID(b, nid, 0);
d1465 2
a1466 1
	if (crl->flags & EXFLAG_CRITICAL)
a1467 2
		if (ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
			return 1;
@


1.19
log
@OpenSSL 1.0.0f: merge
@
text
@a155 1
	X509_NAME *xn;
a206 1
		xn=X509_get_issuer_name(x);
a242 1
	xn = X509_get_subject_name(x);
a290 1
		xn=X509_get_issuer_name(x);
a308 1
	xn=X509_get_issuer_name(x);
@


1.18
log
@openssl-1.0.0e: resolve conflicts
@
text
@d1735 1
a1735 1
	if (X509_time_adj(&atm,-offset*60, cmp_time) == NULL)
@


1.17
log
@resolve conflicts, fix local changes
@
text
@d706 1
d2019 3
d2041 1
a2041 1
		ctx->param->flags |= X509_VP_FLAG_DEFAULT|X509_VP_FLAG_ONCE;
@


1.16
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d73 38
d115 1
d120 17
d348 6
d463 2
a464 2
	int allow_proxy_certs =
		!!(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);
d477 16
a492 4
	/* A hack to keep people who don't want to modify their software
	   happy */
	if (getenv("OPENSSL_ALLOW_PROXY_CERTS"))
		allow_proxy_certs = 1;
d559 1
a559 2
			ret = X509_check_purpose(x, ctx->param->purpose,
				must_be_ca > 0);
d612 36
d682 4
d687 1
d699 1
a699 1
	X509_CRL *crl = NULL;
d705 47
a751 10
	/* Try to retrieve relevant CRL */
	ok = ctx->get_crl(ctx, &crl, x);
	/* If error looking up CRL, nothing we can do except
	 * notify callback
	 */
	if(!ok)
		{
		ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
		ok = ctx->verify_cb(0, ctx);
		goto err;
a752 4
	ctx->current_crl = crl;
	ok = ctx->check_crl(ctx, crl);
	if (!ok) goto err;
	ok = ctx->cert_crl(ctx, crl, x);
d754 3
a757 1
	X509_CRL_free(crl);
d768 2
a769 1
	ctx->current_crl = crl;
d778 2
d781 1
a781 1
		if (!notify || !ctx->verify_cb(0, ctx))
d787 2
d790 1
a790 1
		if (!notify || !ctx->verify_cb(0, ctx))
d800 2
d803 1
a803 1
			if (!notify || !ctx->verify_cb(0, ctx))
d806 2
a807 2

		if (i < 0)
d809 2
d812 1
a812 1
			if (!notify || !ctx->verify_cb(0, ctx))
d817 94
a910 1
	ctx->current_crl = NULL;
d915 30
a944 5
/* Lookup CRLs from the supplied list. Look for matching isser name
 * and validity. If we can't find a valid CRL return the last one
 * with matching name. This gives more meaningful error codes. Otherwise
 * we'd get a CRL not found error if a CRL existed with matching name but
 * was invalid.
d947 2
a948 2
static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl,
			X509_NAME *nm, STACK_OF(X509_CRL) *crls)
d950 1
d952 4
a955 1
	X509_CRL *crl, *best_crl = NULL;
d958 116
a1073 2
		crl = sk_X509_CRL_value(crls, i);
		if (X509_NAME_cmp(nm, X509_CRL_get_issuer(crl)))
d1075 1
a1075 1
		if (check_crl_time(ctx, crl, 0))
d1077 3
a1079 3
			*pcrl = crl;
			CRYPTO_add(&crl->references, 1, CRYPTO_LOCK_X509);
			return 1;
a1080 1
		best_crl = crl;
d1082 10
a1091 1
	if (best_crl)
d1093 9
a1101 2
		*pcrl = best_crl;
		CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509);
d1103 57
a1159 1
		
d1163 5
a1167 2
/* Retrieve CRL corresponding to certificate: currently just a
 * subject lookup: maybe use AKID later...
d1169 3
a1171 1
static int get_crl(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509 *x)
d1173 35
a1207 7
	int ok;
	X509_CRL *crl = NULL;
	X509_OBJECT xobj;
	X509_NAME *nm;
	nm = X509_get_issuer_name(x);
	ok = get_crl_sk(ctx, &crl, nm, ctx->crls);
	if (ok)
d1209 9
a1217 2
		*pcrl = crl;
		return 1;
d1220 1
a1220 1
	ok = X509_STORE_get_by_subject(ctx, X509_LU_CRL, nm, &xobj);
d1222 1
a1222 1
	if (!ok)
d1224 2
a1225 2
		/* If we got a near match from get_crl_sk use that */
		if (crl)
d1227 23
a1249 1
			*pcrl = crl;
d1251 34
a1285 1
		return 0;
d1287 33
d1321 7
a1327 1
	*pcrl = xobj.data.crl;
d1329 10
a1338 2
		X509_CRL_free(crl);
	return 1;
d1349 5
a1353 1
	/* Find CRL issuer: if not last certificate then issuer
d1356 1
a1356 1
	if(cnum < chnum)
d1372 42
a1413 3
		/* Check for cRLSign bit if keyUsage present */
		if ((issuer->ex_flags & EXFLAG_KUSAGE) &&
			!(issuer->ex_kusage & KU_CRL_SIGN))
d1415 3
a1417 3
			ctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;
			ok = ctx->verify_cb(0, ctx);
			if(!ok) goto err;
a1440 4
	ok = check_crl_time(ctx, crl, 1);
	if (!ok)
		goto err;

d1451 8
a1458 10
	int idx, ok;
	X509_REVOKED rtmp;
	STACK_OF(X509_EXTENSION) *exts;
	X509_EXTENSION *ext;
	/* Look for serial number of certificate in CRL */
	rtmp.serialNumber = X509_get_serialNumber(x);
	/* Sort revoked into serial number order if not already sorted.
	 * Do this under a lock to avoid race condition.
 	 */
	if (!sk_X509_REVOKED_is_sorted(crl->crl->revoked))
d1460 9
a1468 7
		CRYPTO_w_lock(CRYPTO_LOCK_X509_CRL);
		sk_X509_REVOKED_sort(crl->crl->revoked);
		CRYPTO_w_unlock(CRYPTO_LOCK_X509_CRL);
		}
	idx = sk_X509_REVOKED_find(crl->crl->revoked, &rtmp);
	/* If found assume revoked: want something cleverer than
	 * this to handle entry extensions in V2 CRLs.
d1470 1
a1470 1
	if(idx >= 0)
d1472 2
d1476 2
a1477 1
		if (!ok) return 0;
a1479 24
	if (ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
		return 1;

	/* See if we have any critical CRL extensions: since we
	 * currently don't handle any CRL extensions the CRL must be
	 * rejected. 
	 * This code accesses the X509_CRL structure directly: applications
	 * shouldn't do this.
	 */

	exts = crl->crl->extensions;

	for (idx = 0; idx < sk_X509_EXTENSION_num(exts); idx++)
		{
		ext = sk_X509_EXTENSION_value(exts, idx);
		if (ext->critical > 0)
			{
			ctx->error =
				X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;
			ok = ctx->verify_cb(0, ctx);
			if(!ok) return 0;
			break;
			}
		}
d1486 2
d1510 2
a1511 1
			ret = ctx->verify_cb(0, ctx);
d1617 6
a1622 1
		if (!xs->valid)
a1631 7
				/* XXX  For the final trusted self-signed cert,
				 * this is a waste of time.  That check should
				 * optional so that e.g. 'openssl x509' can be
				 * used to detect invalid self-signatures, but
				 * we don't verify again and again in SSL
				 * handshakes and the like once the cert has
				 * been declared trusted. */
d1670 1
a1670 1
int X509_cmp_current_time(ASN1_TIME *ctm)
d1675 1
a1675 1
int X509_cmp_time(ASN1_TIME *ctm, time_t *cmp_time)
d1730 1
d1759 7
a1765 1
ASN1_TIME *X509_time_adj(ASN1_TIME *s, long adj, time_t *in_tm)
a1767 1
	int type = -1;
d1772 9
a1780 5
	t+=adj;
	if (s) type = s->type;
	if (type == V_ASN1_UTCTIME) return ASN1_UTCTIME_set(s,t);
	if (type == V_ASN1_GENERALIZEDTIME) return ASN1_GENERALIZEDTIME_set(s, t);
	return ASN1_TIME_set(s, t);
d1883 15
d2019 1
d2085 1
a2085 1
		ctx->get_crl = get_crl;
d2097 10
d2139 2
a2140 1
		X509_VERIFY_PARAM_free(ctx->param);
@


1.15
log
@resolve conflicts
@
text
@d397 1
a397 1
	int i, ok=0, must_be_ca;
d498 4
a501 3
		/* Check pathlen */
		if ((i > 1) && (x->ex_pathlen != -1)
			   && (i > (x->ex_pathlen + proxy_path_length + 1)))
d509 3
@


1.14
log
@resolve conflicts
@
text
@d80 1
d82 1
a82 1
const char *X509_version="X.509" OPENSSL_VERSION_PTEXT;
d101 2
d105 1
a105 1
	int (*cb)();
a106 1

d139 1
a139 1
	depth=ctx->depth;
d167 1
a167 1
				sk_X509_delete_ptr(sktmp,xtmp);
d206 1
d217 1
a217 1
				sk_X509_set(ctx->chain, i - 1, x);
d282 1
d294 1
a294 1
	if (ctx->trust > 0) ok = check_trust(ctx);
d308 1
a308 1
	/* At this point, we have a chain and just need to verify it */
d313 14
d363 1
a363 1
	if (!(ctx->flags & X509_V_FLAG_CB_ISSUER_CHECK))
d386 1
a386 1

d399 1
a399 1
	int (*cb)();
d401 2
a402 1
	int allow_proxy_certs = !!(ctx->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);
d425 1
a425 1
		if (!(ctx->flags & X509_V_FLAG_IGNORE_CRITICAL)
d446 1
a446 1
			if ((ctx->flags & X509_V_FLAG_X509_STRICT)
d466 1
a466 1
				|| ((ctx->flags & X509_V_FLAG_X509_STRICT)
d483 1
a483 1
		if (ctx->purpose > 0)
d485 1
a485 1
			ret = X509_check_purpose(x, ctx->purpose,
d488 1
a488 1
				|| ((ctx->flags & X509_V_FLAG_X509_STRICT)
d514 1
a514 6
			PROXY_CERT_INFO_EXTENSION *pci =
				X509_get_ext_d2i(x, NID_proxyCertInfo,
					NULL, NULL);
			if (pci->pcPathLengthConstraint &&
				ASN1_INTEGER_get(pci->pcPathLengthConstraint)
				< i)
d516 2
a517 2
				PROXY_CERT_INFO_EXTENSION_free(pci);
				ctx->error = X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;
a522 1
			PROXY_CERT_INFO_EXTENSION_free(pci);
d542 1
a542 1
	int (*cb)();
d547 1
a547 1
	ok = X509_check_trust(x, ctx->trust, 0);
d564 1
a564 1
	if (!(ctx->flags & X509_V_FLAG_CRL_CHECK))
d566 1
a566 1
	if (ctx->flags & X509_V_FLAG_CRL_CHECK_ALL)
d609 85
a695 1
 * Also might look up any included CRLs too (e.g PKCS#7 signedData).
d697 1
a697 1
static int get_crl(X509_STORE_CTX *ctx, X509_CRL **crl, X509 *x)
d700 1
d702 25
a726 3
	ok = X509_STORE_get_by_subject(ctx, X509_LU_CRL, X509_get_issuer_name(x), &xobj);
	if (!ok) return 0;
	*crl = xobj.data.crl;
d735 1
a735 2
	int ok = 0, chnum, cnum, i;
	time_t *ptime;
d787 3
a789 39
	/* OK, CRL signature valid check times */
	if (ctx->flags & X509_V_FLAG_USE_CHECK_TIME)
		ptime = &ctx->check_time;
	else
		ptime = NULL;

	i=X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);
	if (i == 0)
		{
		ctx->error=X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;
		ok = ctx->verify_cb(0, ctx);
		if (!ok) goto err;
		}

	if (i > 0)
		{
		ctx->error=X509_V_ERR_CRL_NOT_YET_VALID;
		ok = ctx->verify_cb(0, ctx);
		if (!ok) goto err;
		}

	if(X509_CRL_get_nextUpdate(crl))
		{
		i=X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);

		if (i == 0)
			{
			ctx->error=X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;
			ok = ctx->verify_cb(0, ctx);
			if (!ok) goto err;
			}

		if (i < 0)
			{
			ctx->error=X509_V_ERR_CRL_HAS_EXPIRED;
			ok = ctx->verify_cb(0, ctx);
			if (!ok) goto err;
			}
		}
d827 1
a827 1
	if (ctx->flags & X509_V_FLAG_IGNORE_CRITICAL)
d854 94
d950 1
a950 1
	int i,ok=0,n;
d953 1
a953 2
	time_t *ptime;
	int (*cb)();
d961 1
a961 4
	if (ctx->flags & X509_V_FLAG_USE_CHECK_TIME)
		ptime = &ctx->check_time;
	else
		ptime = NULL;
a1013 17

			i=X509_cmp_time(X509_get_notBefore(xs), ptime);
			if (i == 0)
				{
				ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;
				ctx->current_cert=xs;
				ok=(*cb)(0,ctx);
				if (!ok) goto end;
				}
			if (i > 0)
				{
				ctx->error=X509_V_ERR_CERT_NOT_YET_VALID;
				ctx->current_cert=xs;
				ok=(*cb)(0,ctx);
				if (!ok) goto end;
				}
			xs->valid=1;
d1016 1
a1016 8
		i=X509_cmp_time(X509_get_notAfter(xs), ptime);
		if (i == 0)
			{
			ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;
			ctx->current_cert=xs;
			ok=(*cb)(0,ctx);
			if (!ok) goto end;
			}
d1018 3
a1020 7
		if (i < 0)
			{
			ctx->error=X509_V_ERR_CERT_HAS_EXPIRED;
			ctx->current_cert=xs;
			ok=(*cb)(0,ctx);
			if (!ok) goto end;
			}
d1253 5
d1321 2
a1322 2
	if (purpose && !ctx->purpose) ctx->purpose = purpose;
	if (trust && !ctx->trust) ctx->trust = trust;
d1348 1
d1353 1
a1354 1
	ctx->check_time=0;
a1357 1
	ctx->depth=9;
d1359 1
d1363 9
d1379 5
d1385 1
a1385 3
		ctx->purpose=store->purpose;
		ctx->trust=store->trust;
		ctx->flags = store->flags;
d1389 7
d1397 2
a1398 4
		ctx->purpose = 0;
		ctx->trust = 0;
		ctx->flags = 0;
		ctx->cleanup = 0;
d1441 2
d1471 10
d1490 1
a1490 1
void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, long flags)
d1492 1
a1492 1
	ctx->flags |= flags;
d1495 1
a1495 1
void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, long flags, time_t t)
d1497 6
a1502 2
	ctx->check_time = t;
	ctx->flags |= X509_V_FLAG_USE_CHECK_TIME;
d1509 31
@


1.13
log
@resolve conflicts
@
text
@d947 1
a947 1
		if ((*str != '+') && (str[5] != '-'))
@


1.12
log
@update missing pieces from 0.9.7d; ok henning
crank minor for API extensions
@
text
@d76 1
a76 1
static int check_chain_purpose(X509_STORE_CTX *ctx);
d284 1
a284 1
	if (ctx->purpose > 0) ok = check_chain_purpose(ctx);
d368 1
a368 1
	
d374 1
a374 1
static int check_chain_purpose(X509_STORE_CTX *ctx)
d379 1
a379 1
	int i, ok=0;
d382 2
d385 16
d415 1
a415 4
		ret = X509_check_purpose(x, ctx->purpose, i);
		if ((ret == 0)
			 || ((ctx->flags & X509_V_FLAG_X509_STRICT)
				&& (ret != 1)))
d417 14
a430 1
			if (i)
d432 1
d434 25
a458 1
				ctx->error = X509_V_ERR_INVALID_PURPOSE;
d464 15
d481 1
a481 1
			   && (i > (x->ex_pathlen + 1)))
d489 26
d724 9
d878 1
d958 2
a959 1
	X509_time_adj(&atm,-offset*60, cmp_time);
@


1.11
log
@backout for now
@
text
@d386 1
d397 4
a400 1
		if (!X509_check_purpose(x, ctx->purpose, i))
d544 8
d626 2
d631 1
a631 3
	/* Not found: OK */
	if(idx == -1) return 1;
	/* Otherwise revoked: want something cleverer than
d634 32
a665 3
	ctx->error = X509_V_ERR_CERT_REVOKED;
	ok = ctx->verify_cb(0, ctx);
	return ok;
@


1.10
log
@merge 0.9.7d
@
text
@a385 1
		int ret;
d396 1
a396 4
		ret = X509_check_purpose(x, ctx->purpose, i);
		if ((ret == 0)
			 || ((ctx->flags & X509_V_FLAG_X509_STRICT)
				&& (ret != 1)))
a539 8
		/* Check for cRLSign bit if keyUsage present */
		if ((issuer->ex_flags & EXFLAG_KUSAGE) &&
			!(issuer->ex_kusage & KU_CRL_SIGN))
			{
			ctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;
			ok = ctx->verify_cb(0, ctx);
			if(!ok) goto err;
			}
a613 2
	STACK_OF(X509_EXTENSION) *exts;
	X509_EXTENSION *ext;
d617 3
a619 1
	/* If found assume revoked: want something cleverer than
d622 3
a624 32
	if(idx >= 0)
		{
		ctx->error = X509_V_ERR_CERT_REVOKED;
		ok = ctx->verify_cb(0, ctx);
		if (!ok) return 0;
		}

	if (ctx->flags & X509_V_FLAG_IGNORE_CRITICAL)
		return 1;

	/* See if we have any critical CRL extensions: since we
	 * currently don't handle any CRL extensions the CRL must be
	 * rejected. 
	 * This code accesses the X509_CRL structure directly: applications
	 * shouldn't do this.
	 */

	exts = crl->crl->extensions;

	for (idx = 0; idx < sk_X509_EXTENSION_num(exts); idx++)
		{
		ext = sk_X509_EXTENSION_value(exts, idx);
		if (ext->critical > 0)
			{
			ctx->error =
				X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;
			ok = ctx->verify_cb(0, ctx);
			if(!ok) return 0;
			break;
			}
		}
	return 1;
@


1.9
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d386 1
d397 4
a400 1
		if (!X509_check_purpose(x, ctx->purpose, i))
d544 8
d626 2
d631 1
a631 3
	/* Not found: OK */
	if(idx == -1) return 1;
	/* Otherwise revoked: want something cleverer than
d634 32
a665 3
	ctx->error = X509_V_ERR_CERT_REVOKED;
	ok = ctx->verify_cb(0, ctx);
	return ok;
@


1.8
log
@security fix from http://www.openssl.org/news/secadv_20030930.txt
see also http://cvs.openssl.org/chngview?cn=11471
@
text
@d456 2
a458 2
	else
		last = sk_X509_num(ctx->chain) - 1;
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d677 1
a677 1
			if (X509_verify(xs,pkey) <= 0)
@


1.7.2.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@d677 1
a677 1
			else if (X509_verify(xs,pkey) <= 0)
@


1.6
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d759 1
a759 1
	time_t offset;
@


1.6.2.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@d677 1
a677 1
			else if (X509_verify(xs,pkey) <= 0)
@


1.6.4.1
log
@Pull patch from -current:
SECURITY FIX
Fixed by markus@@
security fix from http://www.openssl.org/news/secadv_20030930.txt

ok markus@@ deraadt@@
@
text
@d677 1
a677 1
			else if (X509_verify(xs,pkey) <= 0)
@


1.5
log
@openssl-engine-0.9.6 merge
@
text
@d78 2
a82 6
static STACK_OF(CRYPTO_EX_DATA_FUNCS) *x509_store_ctx_method=NULL;
static int x509_store_ctx_num=0;
#if 0
static int x509_store_num=1;
static STACK *x509_store_method=NULL;
#endif
a111 1
	if (cb == NULL) cb=null_callback;
d297 7
d351 1
a351 2
	if (ctx->verify_cb)
		return ctx->verify_cb(0, ctx);
d376 1
a376 1
#ifdef NO_CHAIN_VERIFY
a382 1
	if (cb == NULL) cb=null_callback;
d387 9
d426 1
a426 1
#ifdef NO_CHAIN_VERIFY
a432 1
	if (cb == NULL) cb=null_callback;
d439 1
a439 1
	ctx->error_depth = sk_X509_num(ctx->chain) - 1;
d450 177
a635 1
	if (cb == NULL) cb=null_callback;
d678 7
a732 2
		/* CRL CHECK */

d840 1
d846 4
a849 3
	if (!s) return ASN1_TIME_set(s, t);
	if (s->type == V_ASN1_UTCTIME) return ASN1_UTCTIME_set(s,t);
	return ASN1_GENERALIZEDTIME_set(s, t);
d896 6
a901 6
        {
        x509_store_ctx_num++;
        return CRYPTO_get_ex_new_index(x509_store_ctx_num-1,
		&x509_store_ctx_method,
                argl,argp,new_func,dup_func,free_func);
        }
d1025 2
a1026 2
	if (purpose) ctx->purpose = purpose;
	if (trust) ctx->trust = trust;
d1034 6
a1039 1
	if (ctx) memset(ctx, 0, sizeof(X509_STORE_CTX));
d1049 1
a1049 1
void X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
a1056 2
	ctx->purpose=0;
	ctx->trust=0;
a1057 1
	ctx->flags=0;
d1066 74
a1139 6
	ctx->check_issued = check_issued;
	ctx->get_issuer = X509_STORE_CTX_get1_issuer;
	ctx->verify_cb = store->verify_cb;
	ctx->verify = store->verify;
	ctx->cleanup = 0;
	memset(&(ctx->ex_data),0,sizeof(CRYPTO_EX_DATA));
d1160 1
a1160 1
	CRYPTO_free_ex_data(x509_store_ctx_method,ctx,&(ctx->ex_data));
d1173 6
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d74 2
d90 1
a90 1
	return(ok);
d96 1
a96 1
	return(X509_subject_name_cmp(*a,*b));
a103 1
	X509_OBJECT obj;
d112 1
a112 1
		return(-1);
d115 1
a115 1
	cb=ctx->ctx->verify_cb;
d156 1
a156 2
		if (X509_NAME_cmp(X509_get_subject_name(x),xn) == 0)
			break;
d161 1
a161 1
			xtmp=X509_find_by_subject(sktmp,xn);
d186 4
d193 1
a193 2
	if (X509_NAME_cmp(xn,X509_get_issuer_name(x))
		== 0)
d202 2
a203 2
			ok=X509_STORE_get_by_subject(ctx,X509_LU_X509,xn,&obj);
			if ((ok != X509_LU_X509) || X509_cmp(x, obj.data.x509)) 
d208 1
a208 1
				if(ok == X509_LU_X509) X509_OBJECT_free_contents(&obj);
d218 1
a218 1
				x = obj.data.x509;
d225 1
a225 1
			/* worry more about this one elsewhere */
d241 6
a246 2
		if (X509_NAME_cmp(X509_get_subject_name(x),xn) == 0)
			break;
d248 2
a249 19
		ok=X509_STORE_get_by_subject(ctx,X509_LU_X509,xn,&obj);
		if (ok != X509_LU_X509)
			{
			if (ok == X509_LU_RETRY)
				{
				X509_OBJECT_free_contents(&obj);
				X509err(X509_F_X509_VERIFY_CERT,X509_R_SHOULD_RETRY);
				return(ok);
				}
			else if (ok != X509_LU_FAIL)
				{
				X509_OBJECT_free_contents(&obj);
				/* not good :-(, break anyway */
				return(ok);
				}
			break;
			}
		x=obj.data.x509;
		if (!sk_X509_push(ctx->chain,obj.data.x509))
d251 1
a251 1
			X509_OBJECT_free_contents(&obj);
d253 1
a253 1
			return(0);
d260 3
a262 1
	if (X509_NAME_cmp(X509_get_subject_name(x),xn) != 0)
d264 1
a264 1
		if ((chain_ss == NULL) || (X509_NAME_cmp(X509_get_subject_name(chain_ss),xn) != 0))
d289 1
a289 1
	if(ctx->purpose > 0) ok = check_chain_purpose(ctx);
d291 1
a291 1
	if(!ok) goto end;
d295 1
a295 1
	if(ctx->trust > 0) ok = check_trust(ctx);
d297 1
a297 1
	if(!ok) goto end;
d303 2
a304 2
	if (ctx->ctx->verify != NULL)
		ok=ctx->ctx->verify(ctx);
d314 1
a314 1
	return(ok);
d317 52
d381 1
a381 1
	cb=ctx->ctx->verify_cb;
d384 2
a385 1
	for(i = 0; i < ctx->last_untrusted; i++) {
d387 6
a392 3
		if(!X509_check_purpose(x, ctx->purpose, i)) {
			if(i) ctx->error = X509_V_ERR_INVALID_CA;
			else ctx->error = X509_V_ERR_INVALID_PURPOSE;
d396 2
a397 2
			if(!ok) goto end;
		}
d399 3
a401 2
		if((i > 1) && (x->ex_pathlen != -1)
					&& (i > (x->ex_pathlen + 1))) {
d406 2
a407 1
			if(!ok) goto end;
a408 1
	}
d410 2
a411 2
	end:
	return(ok);
d423 1
a423 1
	cb=ctx->ctx->verify_cb;
d429 2
a430 1
	if(ok == X509_TRUST_TRUSTED) return 1;
d433 4
a436 2
	if(ok == X509_TRUST_REJECTED) ctx->error = X509_V_ERR_CERT_REJECTED;
	else ctx->error = X509_V_ERR_CERT_UNTRUSTED;
d438 1
a438 1
	return(ok);
d447 1
d450 1
a450 1
	cb=ctx->ctx->verify_cb;
d457 5
a461 2
	if (X509_NAME_cmp(X509_get_subject_name(xi),
		X509_get_issuer_name(xi)) == 0)
d507 1
a507 1
			i=X509_cmp_current_time(X509_get_notBefore(xs));
d525 1
a525 1
		i=X509_cmp_current_time(X509_get_notAfter(xs));
d558 1
a558 1
	return(ok);
d561 6
a566 1
int X509_cmp_current_time(ASN1_UTCTIME *ctm)
d569 1
a569 1
	ASN1_UTCTIME atm;
d577 14
a590 4
	if ((i < 11) || (i > 17)) return(0);
	memcpy(p,str,10);
	p+=10;
	str+=10;
d594 12
a605 1
	else	{ *(p++)= *(str++); *(p++)= *(str++); }
d614 1
a614 1
			return(0);
d620 1
a620 1
	atm.type=V_ASN1_UTCTIME;
d624 1
a624 1
	X509_gmtime_adj(&atm,-offset*60);
d626 6
a631 4
	i=(buff1[0]-'0')*10+(buff1[1]-'0');
	if (i < 50) i+=100; /* cf. RFC 2459 */
	j=(buff2[0]-'0')*10+(buff2[1]-'0');
	if (j < 50) j+=100;
d633 3
a635 2
	if (i < j) return (-1);
	if (i > j) return (1);
d638 1
a638 1
		return(-1);
d640 1
a640 1
		return(i);
d643 6
a648 1
ASN1_UTCTIME *X509_gmtime_adj(ASN1_UTCTIME *s, long adj)
d652 3
a654 1
	time(&t);
d656 3
a658 1
	return(ASN1_UTCTIME_set(s,t));
d666 1
a666 1
	if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey)) return(1);
d674 1
a674 1
			return(0);
d687 1
a687 1
		return(0);
d700 1
a700 71
	return(1);
	}

int X509_STORE_add_cert(X509_STORE *ctx, X509 *x)
	{
	X509_OBJECT *obj,*r;
	int ret=1;

	if (x == NULL) return(0);
	obj=(X509_OBJECT *)Malloc(sizeof(X509_OBJECT));
	if (obj == NULL)
		{
		X509err(X509_F_X509_STORE_ADD_CERT,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	obj->type=X509_LU_X509;
	obj->data.x509=x;

	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);

	X509_OBJECT_up_ref_count(obj);

	r=(X509_OBJECT *)lh_insert(ctx->certs,obj);
	if (r != NULL)
		{ /* oops, put it back */
		lh_delete(ctx->certs,obj);
		X509_OBJECT_free_contents(obj);
		Free(obj);
		lh_insert(ctx->certs,r);
		X509err(X509_F_X509_STORE_ADD_CERT,X509_R_CERT_ALREADY_IN_HASH_TABLE);
		ret=0;
		}

	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);

	return(ret);	
	}

int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)
	{
	X509_OBJECT *obj,*r;
	int ret=1;

	if (x == NULL) return(0);
	obj=(X509_OBJECT *)Malloc(sizeof(X509_OBJECT));
	if (obj == NULL)
		{
		X509err(X509_F_X509_STORE_ADD_CRL,ERR_R_MALLOC_FAILURE);
		return(0);
		}
	obj->type=X509_LU_CRL;
	obj->data.crl=x;

	CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);

	X509_OBJECT_up_ref_count(obj);

	r=(X509_OBJECT *)lh_insert(ctx->certs,obj);
	if (r != NULL)
		{ /* oops, put it back */
		lh_delete(ctx->certs,obj);
		X509_OBJECT_free_contents(obj);
		Free(obj);
		lh_insert(ctx->certs,r);
		X509err(X509_F_X509_STORE_ADD_CRL,X509_R_CERT_ALREADY_IN_HASH_TABLE);
		ret=0;
		}

	CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);

	return(ret);	
d707 1
a707 1
        return(CRYPTO_get_ex_new_index(x509_store_ctx_num-1,
d709 1
a709 1
                argl,argp,new_func,dup_func,free_func));
d714 1
a714 1
	return(CRYPTO_set_ex_data(&ctx->ex_data,idx,data));
d719 1
a719 1
	return(CRYPTO_get_ex_data(&ctx->ex_data,idx));
d724 1
a724 1
	return(ctx->error);
d734 1
a734 1
	return(ctx->error_depth);
d739 1
a739 1
	return(ctx->current_cert);
d744 1
a744 1
	return(ctx->chain);
d752 3
a754 2
	if(!ctx->chain || !(chain = sk_X509_dup(ctx->chain))) return NULL;
	for(i = 0; i < sk_X509_num(chain); i++) {
d757 2
a758 2
	}
	return(chain);
d796 1
a796 1
	if(!purpose) purpose = def_purpose;
d798 2
a799 1
	if(purpose) {
d802 2
a803 1
		if(idx == -1) {
d807 1
a807 1
		}
d809 2
a810 1
		if(ptmp->trust == X509_TRUST_DEFAULT) {
d812 2
a813 1
			if(idx == -1) {
d817 2
d820 2
a821 1
			ptmp = X509_PURPOSE_get0(idx);
d823 2
a824 4
		/* If trust not set then get from purpose default */
		if(!trust) trust = ptmp->trust;
	}
	if(trust) {
d826 2
a827 1
		if(idx == -1) {
d831 1
d833 46
d881 8
a888 3
	if(purpose) ctx->purpose = purpose;
	if(trust) ctx->trust = trust;
	return 1;
d891 22
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@a438 1
				EVP_PKEY_free(pkey);
d442 5
a446 1
				if (!ok) goto end;
d774 1
d781 8
a788 3
		/* If trust not set then get from purpose default */
		if(!trust) {
			X509_PURPOSE *ptmp;
a789 1
			trust = ptmp->trust;
d791 2
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@a61 2
#include <sys/types.h>
#include <sys/stat.h>
d63 1
a64 1
#include "cryptlib.h"
d70 1
d74 2
d79 1
a79 1
static STACK *x509_store_ctx_method=NULL;
d131 1
a131 1
	/* We use a temporary so we can chop and hack at it */
d188 2
a189 1
	if (X509_NAME_cmp(X509_get_subject_name(x),X509_get_issuer_name(x))
d195 24
a218 5
			ctx->error=X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
			ctx->current_cert=x;
			ctx->error_depth=i-1;
			ok=cb(0,ctx);
			if (!ok) goto end;
d296 11
d325 65
d539 1
a539 1
	X509_gmtime_adj(&atm,-offset);
d625 1
a625 1
	r=(X509_OBJECT *)lh_insert(ctx->certs,(char *)obj);
d628 1
a628 1
		lh_delete(ctx->certs,(char *)obj);
d631 1
a631 1
		lh_insert(ctx->certs,(char *)r);
d660 1
a660 1
	r=(X509_OBJECT *)lh_insert(ctx->certs,(char *)obj);
d663 1
a663 1
		lh_delete(ctx->certs,(char *)obj);
d666 1
a666 1
		lh_insert(ctx->certs,(char *)r);
d676 2
a677 2
int X509_STORE_CTX_get_ex_new_index(long argl, char *argp, int (*new_func)(),
	     int (*dup_func)(), void (*free_func)())
d720 13
d742 56
@


1.1
log
@Initial revision
@
text
@d65 1
a65 1
#include "crypto.h"
d67 6
a72 7
#include "lhash.h"
#include "buffer.h"
#include "evp.h"
#include "asn1.h"
#include "x509.h"
#include "objects.h"
#include "pem.h"
a73 1
#ifndef NOPROTO
d76 1
a76 4
#else
static int null_callback();
static int internal_verify();
#endif
a77 1
char *X509_version="X509 part of SSLeay 0.9.0b 29-Jun-1998";
d85 1
a85 3
static int null_callback(ok,e)
int ok;
X509_STORE_CTX *e;
d91 1
a91 2
static int x509_subject_cmp(a,b)
X509 **a,**b;
d97 1
a97 2
int X509_verify_cert(ctx)
X509_STORE_CTX *ctx;
d105 1
a105 1
	STACK *sktmp=NULL;
d120 2
a121 2
		if (	((ctx->chain=sk_new_null()) == NULL) ||
			(!sk_push(ctx->chain,(char *)ctx->cert)))
d131 2
a132 1
	if ((ctx->untrusted != NULL) && (sktmp=sk_dup(ctx->untrusted)) == NULL)
d138 2
a139 2
	num=sk_num(ctx->chain);
	x=(X509 *)sk_value(ctx->chain,num-1);
d146 5
a150 1
		if (depth <= num) break;
d163 1
a163 1
				if (!sk_push(ctx->chain,(char *)xtmp))
d169 1
a169 1
				sk_delete_ptr(sktmp,(char *)xtmp);
d185 2
a186 2
	i=sk_num(ctx->chain);
	x=(X509 *)sk_value(ctx->chain,i-1);
d191 1
a191 1
		if (sk_num(ctx->chain) == 1)
d202 1
a202 1
			chain_ss=(X509 *)sk_pop(ctx->chain);
d205 1
a205 1
			x=(X509 *)sk_value(ctx->chain,num-1);
d213 1
a213 1
		if (depth <= num) break;
d238 1
a238 1
		if (!sk_push(ctx->chain,(char *)obj.data.x509))
d262 1
a262 1
			sk_push(ctx->chain,(char *)chain_ss);
d283 2
d286 3
a288 1
	if (sktmp != NULL) sk_free(sktmp);
d293 1
a293 2
static int internal_verify(ctx)
X509_STORE_CTX *ctx;
d303 1
a303 1
	n=sk_num(ctx->chain);
d306 1
a306 1
	xi=(X509 *)sk_value(ctx->chain,n);
d323 1
a323 1
			xs=(X509 *)sk_value(ctx->chain,n);
d342 1
d348 1
d397 1
a397 1
			xs=(X509 *)sk_value(ctx->chain,n);
d405 1
a405 2
int X509_cmp_current_time(ctm)
ASN1_UTCTIME *ctm;
d436 1
a436 1
			offset=-offset;
d445 1
a445 1
	if (i < 70) i+=100;
d447 1
a447 1
	if (j < 70) j+=100;
d458 1
a458 3
ASN1_UTCTIME *X509_gmtime_adj(s, adj)
ASN1_UTCTIME *s;
long adj;
d467 1
a467 3
int X509_get_pubkey_parameters(pkey,chain)
EVP_PKEY *pkey;
STACK *chain;
d474 1
a474 1
	for (i=0; i<sk_num(chain); i++)
d476 1
a476 1
		ktmp=X509_get_pubkey((X509 *)sk_value(chain,i));
d486 1
d499 1
a499 1
		ktmp2=X509_get_pubkey((X509 *)sk_value(chain,j));
d501 1
d504 2
a505 2
	if (pkey != NULL)
		EVP_PKEY_copy_parameters(pkey,ktmp);
d509 1
a509 48
EVP_PKEY *X509_get_pubkey(x)
X509 *x;
	{
	if ((x == NULL) || (x->cert_info == NULL))
		return(NULL);
	return(X509_PUBKEY_get(x->cert_info->key));
	}

int X509_check_private_key(x,k)
X509 *x;
EVP_PKEY *k;
	{
	EVP_PKEY *xk=NULL;
	int ok=0;

	xk=X509_get_pubkey(x);
	if (xk->type != k->type) goto err;
	switch (k->type)
		{
#ifndef NO_RSA
	case EVP_PKEY_RSA:
		if (BN_cmp(xk->pkey.rsa->n,k->pkey.rsa->n) != 0) goto err;
		if (BN_cmp(xk->pkey.rsa->e,k->pkey.rsa->e) != 0) goto err;
		break;
#endif
#ifndef NO_DSA
	case EVP_PKEY_DSA:
		if (BN_cmp(xk->pkey.dsa->pub_key,k->pkey.dsa->pub_key) != 0)
			goto err;
		break;
#endif
#ifndef NO_DH
	case EVP_PKEY_DH:
		/* No idea */
		goto err;
#endif
	default:
		goto err;
		}

	ok=1;
err:
	return(ok);
	}

int X509_STORE_add_cert(ctx,x)
X509_STORE *ctx;
X509 *x;
d544 1
a544 3
int X509_STORE_add_crl(ctx,x)
X509_STORE *ctx;
X509_CRL *x;
d579 2
a580 6
int X509_STORE_CTX_get_ex_new_index(argl,argp,new_func,dup_func,free_func)
long argl;
char *argp;
int (*new_func)();
int (*dup_func)();
void (*free_func)();
d588 1
a588 4
int X509_STORE_CTX_set_ex_data(ctx,idx,data)
X509_STORE_CTX *ctx;
int idx;
char *data;
d593 1
a593 3
char *X509_STORE_CTX_get_ex_data(ctx,idx)
X509_STORE_CTX *ctx;
int idx;
d598 1
a598 2
int X509_STORE_CTX_get_error(ctx)
X509_STORE_CTX *ctx;
d603 1
a603 3
void X509_STORE_CTX_set_error(ctx,err)
X509_STORE_CTX *ctx;
int err;
d608 1
a608 2
int X509_STORE_CTX_get_error_depth(ctx)
X509_STORE_CTX *ctx;
d613 1
a613 2
X509 *X509_STORE_CTX_get_current_cert(ctx)
X509_STORE_CTX *ctx;
d618 1
a618 2
STACK *X509_STORE_CTX_get_chain(ctx)
X509_STORE_CTX *ctx;
d623 1
a623 3
void X509_STORE_CTX_set_cert(ctx,x)
X509_STORE_CTX *ctx;
X509 *x;
d628 1
a628 3
void X509_STORE_CTX_set_chain(ctx,sk)
X509_STORE_CTX *ctx;
STACK *sk;
d633 4
d638 2
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d62 2
d65 1
d67 7
a73 8
#include <openssl/crypto.h>
#include <openssl/lhash.h>
#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <openssl/asn1.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/objects.h>
d75 1
a76 6
static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer);
static X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x);
static int check_chain_purpose(X509_STORE_CTX *ctx);
static int check_trust(X509_STORE_CTX *ctx);
static int check_revocation(X509_STORE_CTX *ctx);
static int check_cert(X509_STORE_CTX *ctx);
d78 4
a81 1
const char *X509_version="X.509" OPENSSL_VERSION_PTEXT;
d83 7
d91 3
a93 1
static int null_callback(int ok, X509_STORE_CTX *e)
d95 1
a95 1
	return ok;
d99 2
a100 1
static int x509_subject_cmp(X509 **a, X509 **b)
d102 1
a102 1
	return X509_subject_name_cmp(*a,*b);
d106 2
a107 1
int X509_verify_cert(X509_STORE_CTX *ctx)
d111 1
d115 1
a115 1
	STACK_OF(X509) *sktmp=NULL;
d120 1
a120 1
		return -1;
d123 2
a124 1
	cb=ctx->verify_cb;
d130 2
a131 2
		if (	((ctx->chain=sk_X509_new_null()) == NULL) ||
			(!sk_X509_push(ctx->chain,ctx->cert)))
d140 2
a141 3
	/* We use a temporary STACK so we can chop and hack at it */
	if (ctx->untrusted != NULL
	    && (sktmp=sk_X509_dup(ctx->untrusted)) == NULL)
d147 2
a148 2
	num=sk_X509_num(ctx->chain);
	x=sk_X509_value(ctx->chain,num-1);
d155 1
a155 5
		if (depth < num) break; /* FIXME: If this happens, we should take
		                         * note of it and, if appropriate, use the
		                         * X509_V_ERR_CERT_CHAIN_TOO_LONG error
		                         * code later.
		                         */
d159 2
a160 1
		if (ctx->check_issued(ctx, x,x)) break;
d165 1
a165 1
			xtmp=find_issuer(ctx, sktmp,x);
d168 1
a168 1
				if (!sk_X509_push(ctx->chain,xtmp))
d174 1
a174 1
				sk_X509_delete_ptr(sktmp,xtmp);
d190 4
a193 8
	/* Examine last certificate in chain and see if it
 	 * is self signed.
 	 */

	i=sk_X509_num(ctx->chain);
	x=sk_X509_value(ctx->chain,i-1);
	xn = X509_get_subject_name(x);
	if (ctx->check_issued(ctx, x, x))
d196 1
a196 1
		if (sk_X509_num(ctx->chain) == 1)
d198 5
a202 24
			/* We have a single self signed certificate: see if
			 * we can find it in the store. We must have an exact
			 * match to avoid possible impersonation.
			 */
			ok = ctx->get_issuer(&xtmp, ctx, x);
			if ((ok <= 0) || X509_cmp(x, xtmp)) 
				{
				ctx->error=X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
				ctx->current_cert=x;
				ctx->error_depth=i-1;
				if (ok == 1) X509_free(xtmp);
				ok=cb(0,ctx);
				if (!ok) goto end;
				}
			else 
				{
				/* We have a match: replace certificate with store version
				 * so we get any trust settings.
				 */
				X509_free(x);
				x = xtmp;
				sk_X509_set(ctx->chain, i - 1, x);
				ctx->last_untrusted=0;
				}
d206 2
a207 2
			/* extract and save self signed certificate for later use */
			chain_ss=sk_X509_pop(ctx->chain);
d210 1
a210 1
			x=sk_X509_value(ctx->chain,num-1);
d218 1
a218 1
		if (depth < num) break;
d222 2
a223 1
		if (ctx->check_issued(ctx,x,x)) break;
d225 19
a243 7
		ok = ctx->get_issuer(&xtmp, ctx, x);

		if (ok < 0) return ok;
		if (ok == 0) break;

		x = xtmp;
		if (!sk_X509_push(ctx->chain,x))
d245 1
a245 1
			X509_free(xtmp);
d247 1
a247 1
			return 0;
d254 1
a254 3

	/* Is last certificate looked up self signed? */
	if (!ctx->check_issued(ctx,x,x))
d256 1
a256 1
		if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss))
d267 1
a267 1
			sk_X509_push(ctx->chain,chain_ss);
a279 11
	/* We have the chain complete: now we need to check its purpose */
	if (ctx->purpose > 0) ok = check_chain_purpose(ctx);

	if (!ok) goto end;

	/* The chain extensions are OK: check trust */

	if (ctx->trust > 0) ok = check_trust(ctx);

	if (!ok) goto end;

a282 7
	/* Check revocation status: we do this after copying parameters
	 * because they may be needed for CRL signature verification.
	 */

	ok = ctx->check_revocation(ctx);
	if(!ok) goto end;

d284 2
a285 2
	if (ctx->verify != NULL)
		ok=ctx->verify(ctx);
a287 2
	if (0)
		{
d289 1
a289 3
		X509_get_pubkey_parameters(NULL,ctx->chain);
		}
	if (sktmp != NULL) sk_X509_free(sktmp);
d291 1
a291 194
	return ok;
	}


/* Given a STACK_OF(X509) find the issuer of cert (if any)
 */

static X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x)
{
	int i;
	X509 *issuer;
	for (i = 0; i < sk_X509_num(sk); i++)
		{
		issuer = sk_X509_value(sk, i);
		if (ctx->check_issued(ctx, x, issuer))
			return issuer;
		}
	return NULL;
}

/* Given a possible certificate and issuer check them */

static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)
{
	int ret;
	ret = X509_check_issued(issuer, x);
	if (ret == X509_V_OK)
		return 1;
	/* If we haven't asked for issuer errors don't set ctx */
	if (!(ctx->flags & X509_V_FLAG_CB_ISSUER_CHECK))
		return 0;

	ctx->error = ret;
	ctx->current_cert = x;
	ctx->current_issuer = issuer;
	return ctx->verify_cb(0, ctx);
	return 0;
}

/* Alternative lookup method: look from a STACK stored in other_ctx */

static int get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
{
	*issuer = find_issuer(ctx, ctx->other_ctx, x);
	if (*issuer)
		{
		CRYPTO_add(&(*issuer)->references,1,CRYPTO_LOCK_X509);
		return 1;
		}
	else
		return 0;
}
	

/* Check a certificate chains extensions for consistency
 * with the supplied purpose
 */

static int check_chain_purpose(X509_STORE_CTX *ctx)
{
#ifdef OPENSSL_NO_CHAIN_VERIFY
	return 1;
#else
	int i, ok=0;
	X509 *x;
	int (*cb)();
	cb=ctx->verify_cb;
	/* Check all untrusted certificates */
	for (i = 0; i < ctx->last_untrusted; i++)
		{
		x = sk_X509_value(ctx->chain, i);
		if (!(ctx->flags & X509_V_FLAG_IGNORE_CRITICAL)
			&& (x->ex_flags & EXFLAG_CRITICAL))
			{
			ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;
			ctx->error_depth = i;
			ctx->current_cert = x;
			ok=cb(0,ctx);
			if (!ok) goto end;
			}
		if (!X509_check_purpose(x, ctx->purpose, i))
			{
			if (i)
				ctx->error = X509_V_ERR_INVALID_CA;
			else
				ctx->error = X509_V_ERR_INVALID_PURPOSE;
			ctx->error_depth = i;
			ctx->current_cert = x;
			ok=cb(0,ctx);
			if (!ok) goto end;
			}
		/* Check pathlen */
		if ((i > 1) && (x->ex_pathlen != -1)
			   && (i > (x->ex_pathlen + 1)))
			{
			ctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;
			ctx->error_depth = i;
			ctx->current_cert = x;
			ok=cb(0,ctx);
			if (!ok) goto end;
			}
		}
	ok = 1;
 end:
	return ok;
#endif
}

static int check_trust(X509_STORE_CTX *ctx)
{
#ifdef OPENSSL_NO_CHAIN_VERIFY
	return 1;
#else
	int i, ok;
	X509 *x;
	int (*cb)();
	cb=ctx->verify_cb;
/* For now just check the last certificate in the chain */
	i = sk_X509_num(ctx->chain) - 1;
	x = sk_X509_value(ctx->chain, i);
	ok = X509_check_trust(x, ctx->trust, 0);
	if (ok == X509_TRUST_TRUSTED)
		return 1;
	ctx->error_depth = i;
	ctx->current_cert = x;
	if (ok == X509_TRUST_REJECTED)
		ctx->error = X509_V_ERR_CERT_REJECTED;
	else
		ctx->error = X509_V_ERR_CERT_UNTRUSTED;
	ok = cb(0, ctx);
	return ok;
#endif
}

static int check_revocation(X509_STORE_CTX *ctx)
	{
	int i, last, ok;
	if (!(ctx->flags & X509_V_FLAG_CRL_CHECK))
		return 1;
	if (ctx->flags & X509_V_FLAG_CRL_CHECK_ALL)
		last = 0;
	else
		last = sk_X509_num(ctx->chain) - 1;
	for(i = 0; i <= last; i++)
		{
		ctx->error_depth = i;
		ok = check_cert(ctx);
		if (!ok) return ok;
		}
	return 1;
	}

static int check_cert(X509_STORE_CTX *ctx)
	{
	X509_CRL *crl = NULL;
	X509 *x;
	int ok, cnum;
	cnum = ctx->error_depth;
	x = sk_X509_value(ctx->chain, cnum);
	ctx->current_cert = x;
	/* Try to retrieve relevant CRL */
	ok = ctx->get_crl(ctx, &crl, x);
	/* If error looking up CRL, nothing we can do except
	 * notify callback
	 */
	if(!ok)
		{
		ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
		ok = ctx->verify_cb(0, ctx);
		goto err;
		}
	ctx->current_crl = crl;
	ok = ctx->check_crl(ctx, crl);
	if (!ok) goto err;
	ok = ctx->cert_crl(ctx, crl, x);
	err:
	ctx->current_crl = NULL;
	X509_CRL_free(crl);
	return ok;

	}

/* Retrieve CRL corresponding to certificate: currently just a
 * subject lookup: maybe use AKID later...
 * Also might look up any included CRLs too (e.g PKCS#7 signedData).
 */
static int get_crl(X509_STORE_CTX *ctx, X509_CRL **crl, X509 *x)
	{
	int ok;
	X509_OBJECT xobj;
	ok = X509_STORE_get_by_subject(ctx, X509_LU_CRL, X509_get_issuer_name(x), &xobj);
	if (!ok) return 0;
	*crl = xobj.data.crl;
	return 1;
d294 2
a295 116
/* Check CRL validity */
static int check_crl(X509_STORE_CTX *ctx, X509_CRL *crl)
	{
	X509 *issuer = NULL;
	EVP_PKEY *ikey = NULL;
	int ok = 0, chnum, cnum, i;
	time_t *ptime;
	cnum = ctx->error_depth;
	chnum = sk_X509_num(ctx->chain) - 1;
	/* Find CRL issuer: if not last certificate then issuer
	 * is next certificate in chain.
	 */
	if(cnum < chnum)
		issuer = sk_X509_value(ctx->chain, cnum + 1);
	else
		{
		issuer = sk_X509_value(ctx->chain, chnum);
		/* If not self signed, can't check signature */
		if(!ctx->check_issued(ctx, issuer, issuer))
			{
			ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;
			ok = ctx->verify_cb(0, ctx);
			if(!ok) goto err;
			}
		}

	if(issuer)
		{

		/* Attempt to get issuer certificate public key */
		ikey = X509_get_pubkey(issuer);

		if(!ikey)
			{
			ctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
			ok = ctx->verify_cb(0, ctx);
			if (!ok) goto err;
			}
		else
			{
			/* Verify CRL signature */
			if(X509_CRL_verify(crl, ikey) <= 0)
				{
				ctx->error=X509_V_ERR_CRL_SIGNATURE_FAILURE;
				ok = ctx->verify_cb(0, ctx);
				if (!ok) goto err;
				}
			}
		}

	/* OK, CRL signature valid check times */
	if (ctx->flags & X509_V_FLAG_USE_CHECK_TIME)
		ptime = &ctx->check_time;
	else
		ptime = NULL;

	i=X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);
	if (i == 0)
		{
		ctx->error=X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;
		ok = ctx->verify_cb(0, ctx);
		if (!ok) goto err;
		}

	if (i > 0)
		{
		ctx->error=X509_V_ERR_CRL_NOT_YET_VALID;
		ok = ctx->verify_cb(0, ctx);
		if (!ok) goto err;
		}

	if(X509_CRL_get_nextUpdate(crl))
		{
		i=X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);

		if (i == 0)
			{
			ctx->error=X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;
			ok = ctx->verify_cb(0, ctx);
			if (!ok) goto err;
			}

		if (i < 0)
			{
			ctx->error=X509_V_ERR_CRL_HAS_EXPIRED;
			ok = ctx->verify_cb(0, ctx);
			if (!ok) goto err;
			}
		}

	ok = 1;

	err:
	EVP_PKEY_free(ikey);
	return ok;
	}

/* Check certificate against CRL */
static int cert_crl(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x)
	{
	int idx, ok;
	X509_REVOKED rtmp;
	/* Look for serial number of certificate in CRL */
	rtmp.serialNumber = X509_get_serialNumber(x);
	idx = sk_X509_REVOKED_find(crl->crl->revoked, &rtmp);
	/* Not found: OK */
	if(idx == -1) return 1;
	/* Otherwise revoked: want something cleverer than
	 * this to handle entry extensions in V2 CRLs.
	 */
	ctx->error = X509_V_ERR_CERT_REVOKED;
	ok = ctx->verify_cb(0, ctx);
	return ok;
	}

static int internal_verify(X509_STORE_CTX *ctx)
a299 1
	time_t *ptime;
d302 2
a303 1
	cb=ctx->verify_cb;
d305 1
a305 1
	n=sk_X509_num(ctx->chain);
d308 3
a310 6
	xi=sk_X509_value(ctx->chain,n);
	if (ctx->flags & X509_V_FLAG_USE_CHECK_TIME)
		ptime = &ctx->check_time;
	else
		ptime = NULL;
	if (ctx->check_issued(ctx, xi, xi))
d325 1
a325 1
			xs=sk_X509_value(ctx->chain,n);
a342 7
				/* XXX  For the final trusted self-signed cert,
				 * this is a waste of time.  That check should
				 * optional so that e.g. 'openssl x509' can be
				 * used to detect invalid self-signatures, but
				 * we don't verify again and again in SSL
				 * handshakes and the like once the cert has
				 * been declared trusted. */
d347 1
a347 5
				if (!ok)
					{
					EVP_PKEY_free(pkey);
					goto end;
					}
a348 1
			EVP_PKEY_free(pkey);
d351 1
a351 1
			i=X509_cmp_time(X509_get_notBefore(xs), ptime);
d369 1
a369 1
		i=X509_cmp_time(X509_get_notAfter(xs), ptime);
d386 2
d397 1
a397 1
			xs=sk_X509_value(ctx->chain,n);
d402 1
a402 1
	return ok;
d405 2
a406 6
int X509_cmp_current_time(ASN1_TIME *ctm)
{
	return X509_cmp_time(ctm, NULL);
}

int X509_cmp_time(ASN1_TIME *ctm, time_t *cmp_time)
d409 1
a409 1
	ASN1_TIME atm;
d417 4
a420 14
	if (ctm->type == V_ASN1_UTCTIME)
		{
		if ((i < 11) || (i > 17)) return 0;
		memcpy(p,str,10);
		p+=10;
		str+=10;
		}
	else
		{
		if (i < 13) return 0;
		memcpy(p,str,12);
		p+=12;
		str+=12;
		}
d424 1
a424 12
	else
		{ 
		*(p++)= *(str++);
		*(p++)= *(str++);
		/* Skip any fractional seconds... */
		if (*str == '.')
			{
			str++;
			while ((*str >= '0') && (*str <= '9')) str++;
			}
		
		}
d433 1
a433 1
			return 0;
d437 1
a437 1
			offset= -offset;
d439 1
a439 1
	atm.type=ctm->type;
d443 1
a443 1
	X509_time_adj(&atm,-offset*60, cmp_time);
d445 4
a448 6
	if (ctm->type == V_ASN1_UTCTIME)
		{
		i=(buff1[0]-'0')*10+(buff1[1]-'0');
		if (i < 50) i+=100; /* cf. RFC 2459 */
		j=(buff2[0]-'0')*10+(buff2[1]-'0');
		if (j < 50) j+=100;
d450 2
a451 3
		if (i < j) return -1;
		if (i > j) return 1;
		}
d454 1
a454 1
		return -1;
d456 1
a456 1
		return i;
d459 3
a461 6
ASN1_TIME *X509_gmtime_adj(ASN1_TIME *s, long adj)
{
	return X509_time_adj(s, adj, NULL);
}

ASN1_TIME *X509_time_adj(ASN1_TIME *s, long adj, time_t *in_tm)
a463 4
	int type = -1;

	if (in_tm) t = *in_tm;
	else time(&t);
d465 1
d467 1
a467 4
	if (s) type = s->type;
	if (type == V_ASN1_UTCTIME) return ASN1_UTCTIME_set(s,t);
	if (type == V_ASN1_GENERALIZEDTIME) return ASN1_GENERALIZEDTIME_set(s, t);
	return ASN1_TIME_set(s, t);
d470 3
a472 1
int X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)
d477 1
a477 1
	if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey)) return 1;
d479 1
a479 1
	for (i=0; i<sk_X509_num(chain); i++)
d481 1
a481 1
		ktmp=X509_get_pubkey(sk_X509_value(chain,i));
d485 1
a485 1
			return 0;
a490 1
			EVP_PKEY_free(ktmp);
d497 1
a497 1
		return 0;
d503 1
a503 1
		ktmp2=X509_get_pubkey(sk_X509_value(chain,j));
a504 1
		EVP_PKEY_free(ktmp2);
d507 3
a509 3
	if (pkey != NULL) EVP_PKEY_copy_parameters(pkey,ktmp);
	EVP_PKEY_free(ktmp);
	return 1;
d512 2
a513 2
int X509_STORE_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
d515 3
a517 4
	/* This function is (usually) called only once, by
	 * SSL_get_ex_data_X509_STORE_CTX_idx (ssl/ssl_cert.c). */
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, argl, argp,
			new_func, dup_func, free_func);
d520 3
a522 1
int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)
d524 2
a525 2
	return CRYPTO_set_ex_data(&ctx->ex_data,idx,data);
	}
d527 24
a550 4
void *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)
	{
	return CRYPTO_get_ex_data(&ctx->ex_data,idx);
	}
d552 3
a554 3
int X509_STORE_CTX_get_error(X509_STORE_CTX *ctx)
	{
	return ctx->error;
d557 3
a559 1
void X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)
d561 2
a562 2
	ctx->error=err;
	}
d564 9
a572 4
int X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)
	{
	return ctx->error_depth;
	}
d574 1
a574 4
X509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)
	{
	return ctx->current_cert;
	}
d576 1
a576 4
STACK_OF(X509) *X509_STORE_CTX_get_chain(X509_STORE_CTX *ctx)
	{
	return ctx->chain;
	}
d578 9
a586 10
STACK_OF(X509) *X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx)
	{
	int i;
	X509 *x;
	STACK_OF(X509) *chain;
	if (!ctx->chain || !(chain = sk_X509_dup(ctx->chain))) return NULL;
	for (i = 0; i < sk_X509_num(chain); i++)
		{
		x = sk_X509_value(chain, i);
		CRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);
a587 2
	return chain;
	}
d589 1
a589 4
void X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)
	{
	ctx->cert=x;
	}
d591 1
a591 3
void X509_STORE_CTX_set_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
	{
	ctx->untrusted=sk;
d594 3
a596 1
int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)
d598 2
a599 2
	return X509_STORE_CTX_purpose_inherit(ctx, 0, purpose, 0);
	}
d601 3
a603 23
int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)
	{
	return X509_STORE_CTX_purpose_inherit(ctx, 0, 0, trust);
	}

/* This function is used to set the X509_STORE_CTX purpose and trust
 * values. This is intended to be used when another structure has its
 * own trust and purpose values which (if set) will be inherited by
 * the ctx. If they aren't set then we will usually have a default
 * purpose in mind which should then be used to set the trust value.
 * An example of this is SSL use: an SSL structure will have its own
 * purpose and trust settings which the application can set: if they
 * aren't set then we use the default of SSL client/server.
 */

int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
				int purpose, int trust)
{
	int idx;
	/* If purpose not set use default */
	if (!purpose) purpose = def_purpose;
	/* If we have a purpose then check it is valid */
	if (purpose)
d605 2
a606 47
		X509_PURPOSE *ptmp;
		idx = X509_PURPOSE_get_by_id(purpose);
		if (idx == -1)
			{
			X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
						X509_R_UNKNOWN_PURPOSE_ID);
			return 0;
			}
		ptmp = X509_PURPOSE_get0(idx);
		if (ptmp->trust == X509_TRUST_DEFAULT)
			{
			idx = X509_PURPOSE_get_by_id(def_purpose);
			if (idx == -1)
				{
				X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
						X509_R_UNKNOWN_PURPOSE_ID);
				return 0;
				}
			ptmp = X509_PURPOSE_get0(idx);
			}
		/* If trust not set then get from purpose default */
		if (!trust) trust = ptmp->trust;
		}
	if (trust)
		{
		idx = X509_TRUST_get_by_id(trust);
		if (idx == -1)
			{
			X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
						X509_R_UNKNOWN_TRUST_ID);
			return 0;
			}
		}

	if (purpose && !ctx->purpose) ctx->purpose = purpose;
	if (trust && !ctx->trust) ctx->trust = trust;
	return 1;
}

X509_STORE_CTX *X509_STORE_CTX_new(void)
{
	X509_STORE_CTX *ctx;
	ctx = (X509_STORE_CTX *)OPENSSL_malloc(sizeof(X509_STORE_CTX));
	if (!ctx)
		{
		X509err(X509_F_X509_STORE_CTX_NEW,ERR_R_MALLOC_FAILURE);
		return NULL;
d608 2
a609 9
	memset(ctx, 0, sizeof(X509_STORE_CTX));
	return ctx;
}

void X509_STORE_CTX_free(X509_STORE_CTX *ctx)
{
	X509_STORE_CTX_cleanup(ctx);
	OPENSSL_free(ctx);
}
d611 1
a611 21
int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
	     STACK_OF(X509) *chain)
	{
	ctx->ctx=store;
	ctx->current_method=0;
	ctx->cert=x509;
	ctx->untrusted=chain;
	ctx->last_untrusted=0;
	ctx->check_time=0;
	ctx->other_ctx=NULL;
	ctx->valid=0;
	ctx->chain=NULL;
	ctx->depth=9;
	ctx->error=0;
	ctx->error_depth=0;
	ctx->current_cert=NULL;
	ctx->current_issuer=NULL;

	/* Inherit callbacks and flags from X509_STORE if not set
	 * use defaults.
	 */
d613 1
d615 9
a623 13
	if (store)
		{
		ctx->purpose=store->purpose;
		ctx->trust=store->trust;
		ctx->flags = store->flags;
		ctx->cleanup = store->cleanup;
		}
	else
		{
		ctx->purpose = 0;
		ctx->trust = 0;
		ctx->flags = 0;
		ctx->cleanup = 0;
d626 1
a626 4
	if (store && store->check_issued)
		ctx->check_issued = store->check_issued;
	else
		ctx->check_issued = check_issued;
d628 2
a629 4
	if (store && store->get_issuer)
		ctx->get_issuer = store->get_issuer;
	else
		ctx->get_issuer = X509_STORE_CTX_get1_issuer;
d631 12
a642 4
	if (store && store->verify_cb)
		ctx->verify_cb = store->verify_cb;
	else
		ctx->verify_cb = null_callback;
d644 7
a650 4
	if (store && store->verify)
		ctx->verify = store->verify;
	else
		ctx->verify = internal_verify;
d652 6
a657 4
	if (store && store->check_revocation)
		ctx->check_revocation = store->check_revocation;
	else
		ctx->check_revocation = check_revocation;
d659 5
a663 4
	if (store && store->get_crl)
		ctx->get_crl = store->get_crl;
	else
		ctx->get_crl = get_crl;
d665 6
a670 4
	if (store && store->check_crl)
		ctx->check_crl = store->check_crl;
	else
		ctx->check_crl = check_crl;
d672 4
a675 18
	if (store && store->cert_crl)
		ctx->cert_crl = store->cert_crl;
	else
		ctx->cert_crl = cert_crl;


	/* This memset() can't make any sense anyway, so it's removed. As
	 * X509_STORE_CTX_cleanup does a proper "free" on the ex_data, we put a
	 * corresponding "new" here and remove this bogus initialisation. */
	/* memset(&(ctx->ex_data),0,sizeof(CRYPTO_EX_DATA)); */
	if(!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,
				&(ctx->ex_data)))
		{
		OPENSSL_free(ctx);
		X509err(X509_F_X509_STORE_CTX_INIT,ERR_R_MALLOC_FAILURE);
		return 0;
		}
	return 1;
d678 2
a679 11
/* Set alternative lookup method: just a STACK of trusted certificates.
 * This avoids X509_STORE nastiness where it isn't needed.
 */

void X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
{
	ctx->other_ctx = sk;
	ctx->get_issuer = get_issuer_sk;
}

void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
d681 1
a681 8
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
d684 2
a685 1
void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, long flags)
d687 1
a687 1
	ctx->flags |= flags;
d690 3
a692 1
void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, long flags, time_t t)
d694 1
a694 2
	ctx->check_time = t;
	ctx->flags |= X509_V_FLAG_USE_CHECK_TIME;
d697 3
a699 2
void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,
				  int (*verify_cb)(int, X509_STORE_CTX *))
d701 1
a701 1
	ctx->verify_cb=verify_cb;
a703 4
IMPLEMENT_STACK_OF(X509)
IMPLEMENT_ASN1_SET_OF(X509)

IMPLEMENT_STACK_OF(X509_NAME)
a704 2
IMPLEMENT_STACK_OF(X509_ATTRIBUTE)
IMPLEMENT_ASN1_SET_OF(X509_ATTRIBUTE)
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d759 1
a759 1
	long offset;
@


1.1.1.4
log
@import 0.9.7c
@
text
@d456 2
a458 2
	else
		last = 0;
d677 1
a677 1
			else if (X509_verify(xs,pkey) <= 0)
@


1.1.1.5
log
@import openssl-0.9.7d
@
text
@a385 1
		int ret;
d396 1
a396 4
		ret = X509_check_purpose(x, ctx->purpose, i);
		if ((ret == 0)
			 || ((ctx->flags & X509_V_FLAG_X509_STRICT)
				&& (ret != 1)))
a539 8
		/* Check for cRLSign bit if keyUsage present */
		if ((issuer->ex_flags & EXFLAG_KUSAGE) &&
			!(issuer->ex_kusage & KU_CRL_SIGN))
			{
			ctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;
			ok = ctx->verify_cb(0, ctx);
			if(!ok) goto err;
			}
a613 2
	STACK_OF(X509_EXTENSION) *exts;
	X509_EXTENSION *ext;
d617 3
a619 1
	/* If found assume revoked: want something cleverer than
d622 3
a624 32
	if(idx >= 0)
		{
		ctx->error = X509_V_ERR_CERT_REVOKED;
		ok = ctx->verify_cb(0, ctx);
		if (!ok) return 0;
		}

	if (ctx->flags & X509_V_FLAG_IGNORE_CRITICAL)
		return 1;

	/* See if we have any critical CRL extensions: since we
	 * currently don't handle any CRL extensions the CRL must be
	 * rejected. 
	 * This code accesses the X509_CRL structure directly: applications
	 * shouldn't do this.
	 */

	exts = crl->crl->extensions;

	for (idx = 0; idx < sk_X509_EXTENSION_num(exts); idx++)
		{
		ext = sk_X509_EXTENSION_value(exts, idx);
		if (ext->critical > 0)
			{
			ctx->error =
				X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;
			ok = ctx->verify_cb(0, ctx);
			if(!ok) return 0;
			break;
			}
		}
	return 1;
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d76 1
a76 1
static int check_chain_extensions(X509_STORE_CTX *ctx);
d284 1
a284 1
	ok = check_chain_extensions(ctx);
d368 1
a368 1

d374 1
a374 1
static int check_chain_extensions(X509_STORE_CTX *ctx)
d379 1
a379 1
	int i, ok=0, must_be_ca;
a381 2
	int proxy_path_length = 0;
	int allow_proxy_certs = !!(ctx->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);
a382 16

	/* must_be_ca can have 1 of 3 values:
	   -1: we accept both CA and non-CA certificates, to allow direct
	       use of self-signed certificates (which are marked as CA).
	   0:  we only accept non-CA certificates.  This is currently not
	       used, but the possibility is present for future extensions.
	   1:  we only accept CA certificates.  This is currently used for
	       all certificates in the chain except the leaf certificate.
	*/
	must_be_ca = -1;

	/* A hack to keep people who don't want to modify their software
	   happy */
	if (getenv("OPENSSL_ALLOW_PROXY_CERTS"))
		allow_proxy_certs = 1;

d397 4
a400 1
		if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY))
d402 1
a402 14
			ctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;
			ctx->error_depth = i;
			ctx->current_cert = x;
			ok=cb(0,ctx);
			if (!ok) goto end;
			}
		ret = X509_check_ca(x);
		switch(must_be_ca)
			{
		case -1:
			if ((ctx->flags & X509_V_FLAG_X509_STRICT)
				&& (ret != 1) && (ret != 0))
				{
				ret = 0;
a403 1
				}
d405 1
a405 25
				ret = 1;
			break;
		case 0:
			if (ret != 0)
				{
				ret = 0;
				ctx->error = X509_V_ERR_INVALID_NON_CA;
				}
			else
				ret = 1;
			break;
		default:
			if ((ret == 0)
				|| ((ctx->flags & X509_V_FLAG_X509_STRICT)
					&& (ret != 1)))
				{
				ret = 0;
				ctx->error = X509_V_ERR_INVALID_CA;
				}
			else
				ret = 1;
			break;
			}
		if (ret == 0)
			{
a410 15
		if (ctx->purpose > 0)
			{
			ret = X509_check_purpose(x, ctx->purpose,
				must_be_ca > 0);
			if ((ret == 0)
				|| ((ctx->flags & X509_V_FLAG_X509_STRICT)
					&& (ret != 1)))
				{
				ctx->error = X509_V_ERR_INVALID_PURPOSE;
				ctx->error_depth = i;
				ctx->current_cert = x;
				ok=cb(0,ctx);
				if (!ok) goto end;
				}
			}
d413 1
a413 1
			   && (i > (x->ex_pathlen + proxy_path_length + 1)))
a420 26
		/* If this certificate is a proxy certificate, the next
		   certificate must be another proxy certificate or a EE
		   certificate.  If not, the next certificate must be a
		   CA certificate.  */
		if (x->ex_flags & EXFLAG_PROXY)
			{
			PROXY_CERT_INFO_EXTENSION *pci =
				X509_get_ext_d2i(x, NID_proxyCertInfo,
					NULL, NULL);
			if (pci->pcPathLengthConstraint &&
				ASN1_INTEGER_get(pci->pcPathLengthConstraint)
				< i)
				{
				PROXY_CERT_INFO_EXTENSION_free(pci);
				ctx->error = X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;
				ctx->error_depth = i;
				ctx->current_cert = x;
				ok=cb(0,ctx);
				if (!ok) goto end;
				}
			PROXY_CERT_INFO_EXTENSION_free(pci);
			proxy_path_length++;
			must_be_ca = 0;
			}
		else
			must_be_ca = 1;
a629 9
	/* Sort revoked into serial number order if not already sorted.
	 * Do this under a lock to avoid race condition.
 	 */
	if (!sk_X509_REVOKED_is_sorted(crl->crl->revoked))
		{
		CRYPTO_w_lock(CRYPTO_LOCK_X509_CRL);
		sk_X509_REVOKED_sort(crl->crl->revoked);
		CRYPTO_w_unlock(CRYPTO_LOCK_X509_CRL);
		}
a774 1
		ctx->current_issuer=xi;
d854 1
a854 2
	if (X509_time_adj(&atm,-offset*60, cmp_time) == NULL)
		return 0;
@


1.1.1.7
log
@import of openssl-0.9.7j
@
text
@d947 1
a947 1
		if ((*str != '+') && (*str != '-'))
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@a79 1
static int check_policy(X509_STORE_CTX *ctx);
d81 1
a81 1
const char X509_version[]="X.509" OPENSSL_VERSION_PTEXT;
a99 2
	int bad_chain = 0;
	X509_VERIFY_PARAM *param = ctx->param;
d102 1
a102 1
	int (*cb)(int xok,X509_STORE_CTX *xctx);
d104 1
d137 1
a137 1
	depth=param->depth;
d165 1
a165 1
				(void)sk_X509_delete_ptr(sktmp,xtmp);
a203 1
				bad_chain = 1;
d214 1
a214 1
				(void)sk_X509_set(ctx->chain, i - 1, x);
a278 1
		bad_chain = 1;
d290 1
a290 1
	if (param->trust > 0) ok = check_trust(ctx);
d304 1
a304 1
	/* At this point, we have a chain and need to verify it */
a308 14
	if(!ok) goto end;

#ifndef OPENSSL_NO_RFC3779
	/* RFC 3779 path validation, now that CRL check has been done */
	ok = v3_asid_validate_path(ctx);
	if (!ok) goto end;
	ok = v3_addr_validate_path(ctx);
	if (!ok) goto end;
#endif

	/* If we get this far evaluate policies */
	if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
		ok = ctx->check_policy(ctx);
	if(!ok) goto end;
d345 1
a345 1
	if (!(ctx->param->flags & X509_V_FLAG_CB_ISSUER_CHECK))
d368 1
a368 1
	
d381 1
a381 1
	int (*cb)(int xok,X509_STORE_CTX *xctx);
d383 1
a383 2
	int allow_proxy_certs =
		!!(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);
d406 1
a406 1
		if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
d427 1
a427 1
			if ((ctx->param->flags & X509_V_FLAG_X509_STRICT)
d447 1
a447 1
				|| ((ctx->param->flags & X509_V_FLAG_X509_STRICT)
d464 1
a464 1
		if (ctx->param->purpose > 0)
d466 1
a466 1
			ret = X509_check_purpose(x, ctx->param->purpose,
d469 1
a469 1
				|| ((ctx->param->flags & X509_V_FLAG_X509_STRICT)
d495 6
a500 1
			if (x->ex_pcpathlen != -1 && i > x->ex_pcpathlen)
d502 2
a503 2
				ctx->error =
					X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;
d509 1
d529 1
a529 1
	int (*cb)(int xok,X509_STORE_CTX *xctx);
d534 1
a534 1
	ok = X509_check_trust(x, ctx->param->trust, 0);
d551 1
a551 1
	if (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK))
d553 1
a553 1
	if (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL)
a595 85
/* Check CRL times against values in X509_STORE_CTX */

static int check_crl_time(X509_STORE_CTX *ctx, X509_CRL *crl, int notify)
	{
	time_t *ptime;
	int i;
	ctx->current_crl = crl;
	if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
		ptime = &ctx->param->check_time;
	else
		ptime = NULL;

	i=X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);
	if (i == 0)
		{
		ctx->error=X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;
		if (!notify || !ctx->verify_cb(0, ctx))
			return 0;
		}

	if (i > 0)
		{
		ctx->error=X509_V_ERR_CRL_NOT_YET_VALID;
		if (!notify || !ctx->verify_cb(0, ctx))
			return 0;
		}

	if(X509_CRL_get_nextUpdate(crl))
		{
		i=X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);

		if (i == 0)
			{
			ctx->error=X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;
			if (!notify || !ctx->verify_cb(0, ctx))
				return 0;
			}

		if (i < 0)
			{
			ctx->error=X509_V_ERR_CRL_HAS_EXPIRED;
			if (!notify || !ctx->verify_cb(0, ctx))
				return 0;
			}
		}

	ctx->current_crl = NULL;

	return 1;
	}

/* Lookup CRLs from the supplied list. Look for matching isser name
 * and validity. If we can't find a valid CRL return the last one
 * with matching name. This gives more meaningful error codes. Otherwise
 * we'd get a CRL not found error if a CRL existed with matching name but
 * was invalid.
 */

static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl,
			X509_NAME *nm, STACK_OF(X509_CRL) *crls)
	{
	int i;
	X509_CRL *crl, *best_crl = NULL;
	for (i = 0; i < sk_X509_CRL_num(crls); i++)
		{
		crl = sk_X509_CRL_value(crls, i);
		if (X509_NAME_cmp(nm, X509_CRL_get_issuer(crl)))
			continue;
		if (check_crl_time(ctx, crl, 0))
			{
			*pcrl = crl;
			CRYPTO_add(&crl->references, 1, CRYPTO_LOCK_X509);
			return 1;
			}
		best_crl = crl;
		}
	if (best_crl)
		{
		*pcrl = best_crl;
		CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509);
		}
		
	return 0;
	}

d598 1
d600 1
a600 1
static int get_crl(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509 *x)
a602 1
	X509_CRL *crl = NULL;
d604 3
a606 25
	X509_NAME *nm;
	nm = X509_get_issuer_name(x);
	ok = get_crl_sk(ctx, &crl, nm, ctx->crls);
	if (ok)
		{
		*pcrl = crl;
		return 1;
		}

	ok = X509_STORE_get_by_subject(ctx, X509_LU_CRL, nm, &xobj);

	if (!ok)
		{
		/* If we got a near match from get_crl_sk use that */
		if (crl)
			{
			*pcrl = crl;
			return 1;
			}
		return 0;
		}

	*pcrl = xobj.data.crl;
	if (crl)
		X509_CRL_free(crl);
d615 2
a616 1
	int ok = 0, chnum, cnum;
d668 39
a706 3
	ok = check_crl_time(ctx, crl, 1);
	if (!ok)
		goto err;
d744 1
a744 1
	if (ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
a770 94
static int check_policy(X509_STORE_CTX *ctx)
	{
	int ret;
	ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
				ctx->param->policies, ctx->param->flags);
	if (ret == 0)
		{
		X509err(X509_F_CHECK_POLICY,ERR_R_MALLOC_FAILURE);
		return 0;
		}
	/* Invalid or inconsistent extensions */
	if (ret == -1)
		{
		/* Locate certificates with bad extensions and notify
		 * callback.
		 */
		X509 *x;
		int i;
		for (i = 1; i < sk_X509_num(ctx->chain); i++)
			{
			x = sk_X509_value(ctx->chain, i);
			if (!(x->ex_flags & EXFLAG_INVALID_POLICY))
				continue;
			ctx->current_cert = x;
			ctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;
			ret = ctx->verify_cb(0, ctx);
			}
		return 1;
		}
	if (ret == -2)
		{
		ctx->current_cert = NULL;
		ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
		return ctx->verify_cb(0, ctx);
		}

	if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY)
		{
		ctx->current_cert = NULL;
		ctx->error = X509_V_OK;
		if (!ctx->verify_cb(2, ctx))
			return 0;
		}

	return 1;
	}

static int check_cert_time(X509_STORE_CTX *ctx, X509 *x)
	{
	time_t *ptime;
	int i;

	if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
		ptime = &ctx->param->check_time;
	else
		ptime = NULL;

	i=X509_cmp_time(X509_get_notBefore(x), ptime);
	if (i == 0)
		{
		ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;
		ctx->current_cert=x;
		if (!ctx->verify_cb(0, ctx))
			return 0;
		}

	if (i > 0)
		{
		ctx->error=X509_V_ERR_CERT_NOT_YET_VALID;
		ctx->current_cert=x;
		if (!ctx->verify_cb(0, ctx))
			return 0;
		}

	i=X509_cmp_time(X509_get_notAfter(x), ptime);
	if (i == 0)
		{
		ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;
		ctx->current_cert=x;
		if (!ctx->verify_cb(0, ctx))
			return 0;
		}

	if (i < 0)
		{
		ctx->error=X509_V_ERR_CERT_HAS_EXPIRED;
		ctx->current_cert=x;
		if (!ctx->verify_cb(0, ctx))
			return 0;
		}

	return 1;
	}

d773 1
a773 1
	int ok=0,n;
d776 2
a777 1
	int (*cb)(int xok,X509_STORE_CTX *xctx);
d785 4
a788 1

d841 17
d860 8
a867 1
		xs->valid = 1;
d869 7
a875 3
		ok = check_cert_time(ctx, xs);
		if (!ok)
			goto end;
a1107 5
void X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk)
	{
	ctx->crls=sk;
	}

d1171 2
a1172 2
	if (purpose && !ctx->param->purpose) ctx->param->purpose = purpose;
	if (trust && !ctx->param->trust) ctx->param->trust = trust;
a1197 1
	int ret = 1;
a1201 1
	ctx->crls = NULL;
d1203 1
d1207 1
a1208 1
	ctx->explicit_policy=0;
a1211 9
	ctx->tree = NULL;

	ctx->param = X509_VERIFY_PARAM_new();

	if (!ctx->param)
		{
		X509err(X509_F_X509_STORE_CTX_INIT,ERR_R_MALLOC_FAILURE);
		return 0;
		}
a1218 5
		ret = X509_VERIFY_PARAM_inherit(ctx->param, store->param);
	else
		ctx->param->flags |= X509_VP_FLAG_DEFAULT|X509_VP_FLAG_ONCE;

	if (store)
d1220 3
a1222 1
		ctx->verify_cb = store->verify_cb;
d1226 4
a1230 9

	if (ret)
		ret = X509_VERIFY_PARAM_inherit(ctx->param,
					X509_VERIFY_PARAM_lookup("default"));

	if (ret == 0)
		{
		X509err(X509_F_X509_STORE_CTX_INIT,ERR_R_MALLOC_FAILURE);
		return 0;
a1272 2
	ctx->check_policy = check_policy;

a1300 10
	if (ctx->param != NULL)
		{
		X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
d1310 1
a1310 1
void X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)
d1312 1
a1312 1
	X509_VERIFY_PARAM_set_depth(ctx->param, depth);
d1315 1
a1315 1
void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)
d1317 2
a1318 6
	X509_VERIFY_PARAM_set_flags(ctx->param, flags);
	}

void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags, time_t t)
	{
	X509_VERIFY_PARAM_set_time(ctx->param, t);
a1324 31
	}

X509_POLICY_TREE *X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx)
	{
	return ctx->tree;
	}

int X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx)
	{
	return ctx->explicit_policy;
	}

int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)
	{
	const X509_VERIFY_PARAM *param;
	param = X509_VERIFY_PARAM_lookup(name);
	if (!param)
		return 0;
	return X509_VERIFY_PARAM_inherit(ctx->param, param);
	}

X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)
	{
	return ctx->param;
	}

void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)
	{
	if (ctx->param)
		X509_VERIFY_PARAM_free(ctx->param);
	ctx->param = param;
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@d397 1
a397 1
	int i, ok=0, must_be_ca, plen = 0;
d498 3
a500 4
		/* Check pathlen if not self issued */
		if ((i > 1) && !(x->ex_flags & EXFLAG_SI)
			   && (x->ex_pathlen != -1)
			   && (plen > (x->ex_pathlen + proxy_path_length + 1)))
a507 3
		/* Increment path length if not self issued */
		if (!(x->ex_flags & EXFLAG_SI))
			plen++;
@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@a72 38
/* CRL score values */

/* No unhandled critical extensions */

#define CRL_SCORE_NOCRITICAL	0x100

/* certificate is within CRL scope */

#define CRL_SCORE_SCOPE		0x080

/* CRL times valid */

#define CRL_SCORE_TIME		0x040

/* Issuer name matches certificate */

#define CRL_SCORE_ISSUER_NAME	0x020

/* If this score or above CRL is probably valid */

#define CRL_SCORE_VALID (CRL_SCORE_NOCRITICAL|CRL_SCORE_TIME|CRL_SCORE_SCOPE)

/* CRL issuer is certificate issuer */

#define CRL_SCORE_ISSUER_CERT	0x018

/* CRL issuer is on certificate path */

#define CRL_SCORE_SAME_PATH	0x008

/* CRL issuer matches CRL AKID */

#define CRL_SCORE_AKID		0x004

/* Have a delta CRL with valid times */

#define CRL_SCORE_TIME_DELTA	0x002

a76 1
static int check_name_constraints(X509_STORE_CTX *ctx);
a80 17

static int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,
			unsigned int *preasons,
			X509_CRL *crl, X509 *x);
static int get_crl_delta(X509_STORE_CTX *ctx,
				X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x);
static void get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pcrl_score,
			X509_CRL *base, STACK_OF(X509_CRL) *crls);
static void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl,
				X509 **pissuer, int *pcrl_score);
static int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,
				unsigned int *preasons);
static int check_crl_path(X509_STORE_CTX *ctx, X509 *x);
static int check_crl_chain(X509_STORE_CTX *ctx,
			STACK_OF(X509) *cert_path,
			STACK_OF(X509) *crl_path);

a291 6
	/* Check name constraints */

	ok = check_name_constraints(ctx);
	
	if (!ok) goto end;

d401 2
a402 2
	int purpose;
	int allow_proxy_certs;
d415 4
a418 16
	/* CRL path validation */
	if (ctx->parent)
		{
		allow_proxy_certs = 0;
		purpose = X509_PURPOSE_CRL_SIGN;
		}
	else
		{
		allow_proxy_certs =
			!!(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);
		/* A hack to keep people who don't want to modify their
		   software happy */
		if (getenv("OPENSSL_ALLOW_PROXY_CERTS"))
			allow_proxy_certs = 1;
		purpose = ctx->param->purpose;
		}
d485 2
a486 1
			ret = X509_check_purpose(x, purpose, must_be_ca > 0);
a538 36
static int check_name_constraints(X509_STORE_CTX *ctx)
	{
	X509 *x;
	int i, j, rv;
	/* Check name constraints for all certificates */
	for (i = sk_X509_num(ctx->chain) - 1; i >= 0; i--)
		{
		x = sk_X509_value(ctx->chain, i);
		/* Ignore self issued certs unless last in chain */
		if (i && (x->ex_flags & EXFLAG_SI))
			continue;
		/* Check against constraints for all certificates higher in
		 * chain including trust anchor. Trust anchor not strictly
		 * speaking needed but if it includes constraints it is to be
		 * assumed it expects them to be obeyed.
		 */
		for (j = sk_X509_num(ctx->chain) - 1; j > i; j--)
			{
			NAME_CONSTRAINTS *nc = sk_X509_value(ctx->chain, j)->nc;
			if (nc)
				{
				rv = NAME_CONSTRAINTS_check(x, nc);
				if (rv != X509_V_OK)
					{
					ctx->error = rv;
					ctx->error_depth = i;
					ctx->current_cert = x;
					if (!ctx->verify_cb(0,ctx))
						return 0;
					}
				}
			}
		}
	return 1;
	}

a572 4
		{
		/* If checking CRL paths this isn't the EE certificate */
		if (ctx->parent)
			return 1;
a573 1
		}
d585 1
a585 1
	X509_CRL *crl = NULL, *dcrl = NULL;
d591 10
a600 47
	ctx->current_issuer = NULL;
	ctx->current_reasons = 0;
	while (ctx->current_reasons != CRLDP_ALL_REASONS)
		{
		/* Try to retrieve relevant CRL */
		if (ctx->get_crl)
			ok = ctx->get_crl(ctx, &crl, x);
		else
			ok = get_crl_delta(ctx, &crl, &dcrl, x);
		/* If error looking up CRL, nothing we can do except
		 * notify callback
		 */
		if(!ok)
			{
			ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
			ok = ctx->verify_cb(0, ctx);
			goto err;
			}
		ctx->current_crl = crl;
		ok = ctx->check_crl(ctx, crl);
		if (!ok)
			goto err;

		if (dcrl)
			{
			ok = ctx->check_crl(ctx, dcrl);
			if (!ok)
				goto err;
			ok = ctx->cert_crl(ctx, dcrl, x);
			if (!ok)
				goto err;
			}
		else
			ok = 1;

		/* Don't look in full CRL if delta reason is removefromCRL */
		if (ok != 2)
			{
			ok = ctx->cert_crl(ctx, crl, x);
			if (!ok)
				goto err;
			}

		X509_CRL_free(crl);
		X509_CRL_free(dcrl);
		crl = NULL;
		dcrl = NULL;
d602 4
d607 1
a608 3
	X509_CRL_free(dcrl);

	ctx->current_crl = NULL;
d619 1
a619 2
	if (notify)
		ctx->current_crl = crl;
a627 2
		if (!notify)
			return 0;
d629 1
a629 1
		if (!ctx->verify_cb(0, ctx))
a634 2
		if (!notify)
			return 0;
d636 1
a636 1
		if (!ctx->verify_cb(0, ctx))
a645 2
			if (!notify)
				return 0;
d647 1
a647 1
			if (!ctx->verify_cb(0, ctx))
d650 2
a651 2
		/* Ignore expiry of base CRL is delta is valid */
		if ((i < 0) && !(ctx->current_crl_score & CRL_SCORE_TIME_DELTA))
a652 2
			if (!notify)
				return 0;
d654 1
a654 1
			if (!ctx->verify_cb(0, ctx))
d659 1
a659 2
	if (notify)
		ctx->current_crl = NULL;
d664 11
a674 7
static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
			X509 **pissuer, int *pscore, unsigned int *preasons,
			STACK_OF(X509_CRL) *crls)
	{
	int i, crl_score, best_score = *pscore;
	unsigned int reasons, best_reasons = 0;
	X509 *x = ctx->current_cert;
a675 2
	X509 *crl_issuer = NULL, *best_crl_issuer = NULL;

d679 3
a681 4
		reasons = *preasons;
		crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);

		if (crl_score > best_score)
d683 3
a685 4
			best_crl = crl;
			best_crl_issuer = crl_issuer;
			best_score = crl_score;
			best_reasons = reasons;
d687 1
a688 1

a690 2
		if (*pcrl)
			X509_CRL_free(*pcrl);
d692 1
a692 10
		*pissuer = best_crl_issuer;
		*pscore = best_score;
		*preasons = best_reasons;
		CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);
		if (*pdcrl)
			{
			X509_CRL_free(*pdcrl);
			*pdcrl = NULL;
			}
		get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);
d694 1
a694 4

	if (best_score >= CRL_SCORE_VALID)
		return 1;

d698 2
a699 2
/* Compare two CRL extensions for delta checking purposes. They should be
 * both present or both absent. If both present all fields must be identical.
d701 1
a701 2

static int crl_extension_match(X509_CRL *a, X509_CRL *b, int nid)
d703 7
a709 4
	ASN1_OCTET_STRING *exta, *extb;
	int i;
	i = X509_CRL_get_ext_by_NID(a, nid, 0);
	if (i >= 0)
d711 1
a711 21
		/* Can't have multiple occurrences */
		if (X509_CRL_get_ext_by_NID(a, nid, i) != -1)
			return 0;
		exta = X509_EXTENSION_get_data(X509_CRL_get_ext(a, i));
		}
	else
		exta = NULL;

	i = X509_CRL_get_ext_by_NID(b, nid, 0);

	if (i >= 0)
		{

		if (X509_CRL_get_ext_by_NID(b, nid, i) != -1)
			return 0;
		extb = X509_EXTENSION_get_data(X509_CRL_get_ext(b, i));
		}
	else
		extb = NULL;

	if (!exta && !extb)
a712 63

	if (!exta || !extb)
		return 0;


	if (ASN1_OCTET_STRING_cmp(exta, extb))
		return 0;

	return 1;
	}

/* See if a base and delta are compatible */

static int check_delta_base(X509_CRL *delta, X509_CRL *base)
	{
	/* Delta CRL must be a delta */
	if (!delta->base_crl_number)
			return 0;
	/* Base must have a CRL number */
	if (!base->crl_number)
			return 0;
	/* Issuer names must match */
	if (X509_NAME_cmp(X509_CRL_get_issuer(base),
				X509_CRL_get_issuer(delta)))
		return 0;
	/* AKID and IDP must match */
	if (!crl_extension_match(delta, base, NID_authority_key_identifier))
			return 0;
	if (!crl_extension_match(delta, base, NID_issuing_distribution_point))
			return 0;
	/* Delta CRL base number must not exceed Full CRL number. */
	if (ASN1_INTEGER_cmp(delta->base_crl_number, base->crl_number) > 0)
			return 0;
	/* Delta CRL number must exceed full CRL number */
	if (ASN1_INTEGER_cmp(delta->crl_number, base->crl_number) > 0)
			return 1;
	return 0;
	}

/* For a given base CRL find a delta... maybe extend to delta scoring
 * or retrieve a chain of deltas...
 */

static void get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pscore,
			X509_CRL *base, STACK_OF(X509_CRL) *crls)
	{
	X509_CRL *delta;
	int i;
	if (!(ctx->param->flags & X509_V_FLAG_USE_DELTAS))
		return;
	if (!((ctx->current_cert->ex_flags | base->flags) & EXFLAG_FRESHEST))
		return;
	for (i = 0; i < sk_X509_CRL_num(crls); i++)
		{
		delta = sk_X509_CRL_value(crls, i);
		if (check_delta_base(delta, base))
			{
			if (check_crl_time(ctx, delta, 0))
				*pscore |= CRL_SCORE_TIME_DELTA;
			CRYPTO_add(&delta->references, 1, CRYPTO_LOCK_X509_CRL);
			*dcrl = delta;
			return;
			}
a713 2
	*dcrl = NULL;
	}
d715 1
a715 60
/* For a given CRL return how suitable it is for the supplied certificate 'x'.
 * The return value is a mask of several criteria.
 * If the issuer is not the certificate issuer this is returned in *pissuer.
 * The reasons mask is also used to determine if the CRL is suitable: if
 * no new reasons the CRL is rejected, otherwise reasons is updated.
 */

static int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,
			unsigned int *preasons,
			X509_CRL *crl, X509 *x)
	{

	int crl_score = 0;
	unsigned int tmp_reasons = *preasons, crl_reasons;

	/* First see if we can reject CRL straight away */

	/* Invalid IDP cannot be processed */
	if (crl->idp_flags & IDP_INVALID)
		return 0;
	/* Reason codes or indirect CRLs need extended CRL support */
	if (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT))
		{
		if (crl->idp_flags & (IDP_INDIRECT | IDP_REASONS))
			return 0;
		}
	else if (crl->idp_flags & IDP_REASONS)
		{
		/* If no new reasons reject */
		if (!(crl->idp_reasons & ~tmp_reasons))
			return 0;
		}
	/* Don't process deltas at this stage */
	else if (crl->base_crl_number)
		return 0;
	/* If issuer name doesn't match certificate need indirect CRL */
	if (X509_NAME_cmp(X509_get_issuer_name(x), X509_CRL_get_issuer(crl)))
		{
		if (!(crl->idp_flags & IDP_INDIRECT))
			return 0;
		}
	else
		crl_score |= CRL_SCORE_ISSUER_NAME;

	if (!(crl->flags & EXFLAG_CRITICAL))
		crl_score |= CRL_SCORE_NOCRITICAL;

	/* Check expiry */
	if (check_crl_time(ctx, crl, 0))
		crl_score |= CRL_SCORE_TIME;

	/* Check authority key ID and locate certificate issuer */
	crl_akid_check(ctx, crl, pissuer, &crl_score);

	/* If we can't locate certificate issuer at this point forget it */

	if (!(crl_score & CRL_SCORE_AKID))
		return 0;

	/* Check cert for matching CRL distribution points */
d717 1
a717 1
	if (crl_crldp_check(x, crl, crl_score, &crl_reasons))
d719 2
a720 29
		/* If no new reasons reject */
		if (!(crl_reasons & ~tmp_reasons))
			return 0;
		tmp_reasons |= crl_reasons;
		crl_score |= CRL_SCORE_SCOPE;
		}

	*preasons = tmp_reasons;

	return crl_score;

	}

static void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl,
				X509 **pissuer, int *pcrl_score)
	{
	X509 *crl_issuer = NULL;
	X509_NAME *cnm = X509_CRL_get_issuer(crl);
	int cidx = ctx->error_depth;
	int i;

	if (cidx != sk_X509_num(ctx->chain) - 1)
		cidx++;

	crl_issuer = sk_X509_value(ctx->chain, cidx);

	if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK)
		{
		if (*pcrl_score & CRL_SCORE_ISSUER_NAME)
d722 2
a723 3
			*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_ISSUER_CERT;
			*pissuer = crl_issuer;
			return;
a724 50
		}

	for (cidx++; cidx < sk_X509_num(ctx->chain); cidx++)
		{
		crl_issuer = sk_X509_value(ctx->chain, cidx);
		if (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))
			continue;
		if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK)
			{
			*pcrl_score |= CRL_SCORE_AKID|CRL_SCORE_SAME_PATH;
			*pissuer = crl_issuer;
			return;
			}
		}

	/* Anything else needs extended CRL support */

	if (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT))
		return;

	/* Otherwise the CRL issuer is not on the path. Look for it in the
	 * set of untrusted certificates.
	 */
	for (i = 0; i < sk_X509_num(ctx->untrusted); i++)
		{
		crl_issuer = sk_X509_value(ctx->untrusted, i);
		if (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))
			continue;
		if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK)
			{
			*pissuer = crl_issuer;
			*pcrl_score |= CRL_SCORE_AKID;
			return;
			}
		}
	}

/* Check the path of a CRL issuer certificate. This creates a new
 * X509_STORE_CTX and populates it with most of the parameters from the
 * parent. This could be optimised somewhat since a lot of path checking
 * will be duplicated by the parent, but this will rarely be used in 
 * practice.
 */

static int check_crl_path(X509_STORE_CTX *ctx, X509 *x)
	{
	X509_STORE_CTX crl_ctx;
	int ret;
	/* Don't allow recursive CRL path validation */
	if (ctx->parent)
a725 85
	if (!X509_STORE_CTX_init(&crl_ctx, ctx->ctx, x, ctx->untrusted))
		return -1;

	crl_ctx.crls = ctx->crls;
	/* Copy verify params across */
	X509_STORE_CTX_set0_param(&crl_ctx, ctx->param);

	crl_ctx.parent = ctx;
	crl_ctx.verify_cb = ctx->verify_cb;

	/* Verify CRL issuer */
	ret = X509_verify_cert(&crl_ctx);

	if (ret <= 0)
		goto err;

	/* Check chain is acceptable */

	ret = check_crl_chain(ctx, ctx->chain, crl_ctx.chain);
	err:
	X509_STORE_CTX_cleanup(&crl_ctx);
	return ret;
	}

/* RFC3280 says nothing about the relationship between CRL path
 * and certificate path, which could lead to situations where a
 * certificate could be revoked or validated by a CA not authorised
 * to do so. RFC5280 is more strict and states that the two paths must
 * end in the same trust anchor, though some discussions remain...
 * until this is resolved we use the RFC5280 version
 */

static int check_crl_chain(X509_STORE_CTX *ctx,
			STACK_OF(X509) *cert_path,
			STACK_OF(X509) *crl_path)
	{
	X509 *cert_ta, *crl_ta;
	cert_ta = sk_X509_value(cert_path, sk_X509_num(cert_path) - 1);
	crl_ta = sk_X509_value(crl_path, sk_X509_num(crl_path) - 1);
	if (!X509_cmp(cert_ta, crl_ta))
		return 1;
	return 0;
	}

/* Check for match between two dist point names: three separate cases.
 * 1. Both are relative names and compare X509_NAME types.
 * 2. One full, one relative. Compare X509_NAME to GENERAL_NAMES.
 * 3. Both are full names and compare two GENERAL_NAMES.
 * 4. One is NULL: automatic match.
 */


static int idp_check_dp(DIST_POINT_NAME *a, DIST_POINT_NAME *b)
	{
	X509_NAME *nm = NULL;
	GENERAL_NAMES *gens = NULL;
	GENERAL_NAME *gena, *genb;
	int i, j;
	if (!a || !b)
		return 1;
	if (a->type == 1)
		{
		if (!a->dpname)
			return 0;
		/* Case 1: two X509_NAME */
		if (b->type == 1)
			{
			if (!b->dpname)
				return 0;
			if (!X509_NAME_cmp(a->dpname, b->dpname))
				return 1;
			else
				return 0;
			}
		/* Case 2: set name and GENERAL_NAMES appropriately */
		nm = a->dpname;
		gens = b->name.fullname;
		}
	else if (b->type == 1)
		{
		if (!b->dpname)
			return 0;
		/* Case 2: set name and GENERAL_NAMES appropriately */
		gens = a->name.fullname;
		nm = b->dpname;
d728 1
a728 122
	/* Handle case 2 with one GENERAL_NAMES and one X509_NAME */
	if (nm)
		{
		for (i = 0; i < sk_GENERAL_NAME_num(gens); i++)
			{
			gena = sk_GENERAL_NAME_value(gens, i);	
			if (gena->type != GEN_DIRNAME)
				continue;
			if (!X509_NAME_cmp(nm, gena->d.directoryName))
				return 1;
			}
		return 0;
		}

	/* Else case 3: two GENERAL_NAMES */

	for (i = 0; i < sk_GENERAL_NAME_num(a->name.fullname); i++)
		{
		gena = sk_GENERAL_NAME_value(a->name.fullname, i);
		for (j = 0; j < sk_GENERAL_NAME_num(b->name.fullname); j++)
			{
			genb = sk_GENERAL_NAME_value(b->name.fullname, j);
			if (!GENERAL_NAME_cmp(gena, genb))
				return 1;
			}
		}

	return 0;

	}

static int crldp_check_crlissuer(DIST_POINT *dp, X509_CRL *crl, int crl_score)
	{
	int i;
	X509_NAME *nm = X509_CRL_get_issuer(crl);
	/* If no CRLissuer return is successful iff don't need a match */
	if (!dp->CRLissuer)
		return !!(crl_score & CRL_SCORE_ISSUER_NAME);
	for (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++)
		{
		GENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);
		if (gen->type != GEN_DIRNAME)
			continue;
		if (!X509_NAME_cmp(gen->d.directoryName, nm))
			return 1;
		}
	return 0;
	}

/* Check CRLDP and IDP */

static int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,
				unsigned int *preasons)
	{
	int i;
	if (crl->idp_flags & IDP_ONLYATTR)
		return 0;
	if (x->ex_flags & EXFLAG_CA)
		{
		if (crl->idp_flags & IDP_ONLYUSER)
			return 0;
		}
	else
		{
		if (crl->idp_flags & IDP_ONLYCA)
			return 0;
		}
	*preasons = crl->idp_reasons;
	for (i = 0; i < sk_DIST_POINT_num(x->crldp); i++)
		{
		DIST_POINT *dp = sk_DIST_POINT_value(x->crldp, i);
		if (crldp_check_crlissuer(dp, crl, crl_score))
			{
			if (!crl->idp ||
			     idp_check_dp(dp->distpoint, crl->idp->distpoint))
				{
				*preasons &= dp->dp_reasons;
				return 1;
				}
			}
		}
	if ((!crl->idp || !crl->idp->distpoint) && (crl_score & CRL_SCORE_ISSUER_NAME))
		return 1;
	return 0;
	}

/* Retrieve CRL corresponding to current certificate.
 * If deltas enabled try to find a delta CRL too
 */
	
static int get_crl_delta(X509_STORE_CTX *ctx,
				X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x)
	{
	int ok;
	X509 *issuer = NULL;
	int crl_score = 0;
	unsigned int reasons;
	X509_CRL *crl = NULL, *dcrl = NULL;
	STACK_OF(X509_CRL) *skcrl;
	X509_NAME *nm = X509_get_issuer_name(x);
	reasons = ctx->current_reasons;
	ok = get_crl_sk(ctx, &crl, &dcrl, 
				&issuer, &crl_score, &reasons, ctx->crls);

	if (ok)
		goto done;

	/* Lookup CRLs from store */

	skcrl = ctx->lookup_crls(ctx, nm);

	/* If no CRLs found and a near match from get_crl_sk use that */
	if (!skcrl && crl)
		goto done;

	get_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons, skcrl);

	sk_X509_CRL_pop_free(skcrl, X509_CRL_free);

	done:

	/* If we got any kind of CRL use it and return success */
d730 2
a731 10
		{
		ctx->current_issuer = issuer;
		ctx->current_crl_score = crl_score;
		ctx->current_reasons = reasons;
		*pcrl = crl;
		*pdcrl = dcrl;
		return 1;
		}

	return 0;
d742 1
a742 5
	/* if we have an alternative CRL issuer cert use that */
	if (ctx->current_issuer)
		issuer = ctx->current_issuer;

	/* Else find CRL issuer: if not last certificate then issuer
d745 1
a745 1
	else if (cnum < chnum)
d761 3
a763 4
		/* Skip most tests for deltas because they have already
		 * been done
		 */
		if (!crl->base_crl_number)
d765 3
a767 41
			/* Check for cRLSign bit if keyUsage present */
			if ((issuer->ex_flags & EXFLAG_KUSAGE) &&
				!(issuer->ex_kusage & KU_CRL_SIGN))
				{
				ctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;
				ok = ctx->verify_cb(0, ctx);
				if(!ok) goto err;
				}

			if (!(ctx->current_crl_score & CRL_SCORE_SCOPE))
				{
				ctx->error = X509_V_ERR_DIFFERENT_CRL_SCOPE;
				ok = ctx->verify_cb(0, ctx);
				if(!ok) goto err;
				}

			if (!(ctx->current_crl_score & CRL_SCORE_SAME_PATH))
				{
				if (check_crl_path(ctx, ctx->current_issuer) <= 0)
					{
					ctx->error = X509_V_ERR_CRL_PATH_VALIDATION_ERROR;
					ok = ctx->verify_cb(0, ctx);
					if(!ok) goto err;
					}
				}

			if (crl->idp_flags & IDP_INVALID)
				{
				ctx->error = X509_V_ERR_INVALID_EXTENSION;
				ok = ctx->verify_cb(0, ctx);
				if(!ok) goto err;
				}


			}

		if (!(ctx->current_crl_score & CRL_SCORE_TIME))
			{
			ok = check_crl_time(ctx, crl, 1);
			if (!ok)
				goto err;
d791 4
d805 18
a822 6
	int ok;
	X509_REVOKED *rev;
	/* The rules changed for this... previously if a CRL contained
	 * unhandled critical extensions it could still be used to indicate
	 * a certificate was revoked. This has since been changed since 
	 * critical extension can change the meaning of CRL entries.
d824 1
a824 1
	if (crl->flags & EXFLAG_CRITICAL)
d826 1
a826 3
		if (ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
			return 1;
		ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;
d828 1
a828 2
		if(!ok)
			return 0;
d830 9
a838 2
	/* Look for serial number of certificate in CRL
	 * If found make sure reason is not removeFromCRL.
d840 4
a843 1
	if (X509_CRL_get0_by_cert(crl, &rev, x))
d845 9
a853 6
		if (rev->reason == CRL_REASON_REMOVE_FROM_CRL)
			return 2;
		ctx->error = X509_V_ERR_CERT_REVOKED;
		ok = ctx->verify_cb(0, ctx);
		if (!ok)
			return 0;
a854 1

a860 2
	if (ctx->parent)
		return 1;
d883 1
a883 2
			if(!ctx->verify_cb(0, ctx))
				return 0;
d989 1
a989 6

		/* Skip signature check for self signed certificates unless
		 * explicitly asked for. It doesn't add any security and
		 * just wastes time.
		 */
		if (!xs->valid && (xs != xi || (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE)))
d999 7
d1044 1
a1044 1
int X509_cmp_current_time(const ASN1_TIME *ctm)
d1049 1
a1049 1
int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)
a1103 1
	atm.flags = 0;
d1132 1
a1132 7
ASN1_TIME *X509_time_adj(ASN1_TIME *s, long offset_sec, time_t *in_tm)
	{
	return X509_time_adj_ex(s, 0, offset_sec, in_tm);
	}

ASN1_TIME *X509_time_adj_ex(ASN1_TIME *s,
				int offset_day, long offset_sec, time_t *in_tm)
d1135 1
d1140 5
a1144 9
	if (s && !(s->flags & ASN1_STRING_FLAG_MSTRING))
		{
		if (s->type == V_ASN1_UTCTIME)
			return ASN1_UTCTIME_adj(s,t, offset_day, offset_sec);
		if (s->type == V_ASN1_GENERALIZEDTIME)
			return ASN1_GENERALIZEDTIME_adj(s, t, offset_day,
								offset_sec);
		}
	return ASN1_TIME_adj(s, t, offset_day, offset_sec);
a1246 15
X509 *X509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx)
	{
	return ctx->current_issuer;
	}

X509_CRL *X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx)
	{
	return ctx->current_crl;
	}

X509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx)
	{
	return ctx->parent;
	}

a1367 1
	ctx->parent = NULL;
d1433 1
a1433 1
		ctx->get_crl = NULL;
a1444 10
	if (store && store->lookup_certs)
		ctx->lookup_certs = store->lookup_certs;
	else
		ctx->lookup_certs = X509_STORE_get1_certs;

	if (store && store->lookup_crls)
		ctx->lookup_crls = store->lookup_crls;
	else
		ctx->lookup_crls = X509_STORE_get1_crls;

d1477 1
a1477 2
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
@


1.1.1.11
log
@import OpenSSL 1.0.0e
@
text
@a705 1
	ctx->current_crl_score = 0;
a2017 3
	ctx->current_crl=NULL;
	ctx->current_crl_score=0;
	ctx->current_reasons=0;
d2037 1
a2037 1
		ctx->param->inh_flags |= X509_VP_FLAG_DEFAULT|X509_VP_FLAG_ONCE;
@


1.1.1.12
log
@OpenSSL 1.0.0f: import upstream source
@
text
@d1735 1
a1735 1
	if (X509_time_adj(&atm, offset*60, cmp_time) == NULL)
@


1.1.1.13
log
@import OpenSSL-1.0.1c
@
text
@d156 1
d208 1
d245 1
d294 1
d313 1
@


1.1.1.14
log
@Import OpenSSL 1.0.1g
@
text
@a696 1
	unsigned int last_reasons;
a704 1
		last_reasons = ctx->current_reasons;
a747 9
		/* If reasons not updated we wont get anywhere by
		 * another iteration, so exit loop.
		 */
		if (last_reasons == ctx->current_reasons)
			{
			ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
			ok = ctx->verify_cb(0, ctx);
			goto err;
			}
d875 1
a875 1
	i = X509_CRL_get_ext_by_NID(a, nid, -1);
d886 1
a886 1
	i = X509_CRL_get_ext_by_NID(b, nid, -1);
d1454 1
a1454 2
	if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
		&& (crl->flags & EXFLAG_CRITICAL))
d1456 2
@


