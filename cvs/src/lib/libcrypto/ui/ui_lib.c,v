head	1.32;
access;
symbols
	OPENBSD_6_1_BASE:1.32;
locks; strict;
comment	@ * @;


1.32
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.31;
commitid	kT0fLt3r4lroFJra;

1.31
date	2016.04.28.16.42.28;	author tedu;	state Exp;
branches;
next	1.30;
commitid	CCwjJO5lGOjodR0Z;

1.30
date	2015.02.10.11.22.21;	author jsing;	state Exp;
branches;
next	1.29;
commitid	LaAI4ax0sm4T2bQg;

1.29
date	2014.10.03.06.02.38;	author doug;	state Exp;
branches;
next	1.28;
commitid	q372AJEo5SAUk3Hj;

1.28
date	2014.07.22.02.21.20;	author beck;	state Exp;
branches;
next	1.27;
commitid	iBnKYMaAFvJMFyL2;

1.27
date	2014.07.13.16.03.10;	author beck;	state Exp;
branches;
next	1.26;
commitid	6xdvCwSqBadTW6X3;

1.26
date	2014.07.11.16.22.29;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	iLoTXGt04l4jSRR2;

1.25
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.24;
commitid	yQEL1wOWIearrW15;

1.24
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	mJUVYpkFBZ0Zv2bG;

1.23
date	2014.06.11.01.53.02;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	4evB2EbwDYaBfe0g;

1.22
date	2014.06.07.14.41.57;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	2nvnQBrv22dLtvTt;

1.21
date	2014.05.25.20.28.50;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2014.05.24.09.16.08;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.05.22.21.12.16;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.25.04.02.04;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2014.04.24.15.12.20;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.24.13.12.18;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.20.19.56.25;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.19.11.43.07;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2014.04.19.00.41.38;	author beck;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.18.05.37.44;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2014.04.17.22.37.59;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.15.16.21.04;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.06.06.33.20;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.06.12.17.52;	author djm;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.08.08.03.14;	author markus;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.12.02.18.39;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.16.12.18.21;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.15.02.29.17;	author beck;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.09.05.12.50.57;	author markus;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.05.11.21.35.50;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.20.41.52;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.06.12.15.47;	author djm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.04.06.06.30.04;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.10.01.22.54.11;	author djm;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@/* $OpenBSD: ui_lib.c,v 1.31 2016/04/28 16:42:28 tedu Exp $ */
/* Written by Richard Levitte (richard@@levitte.org) for the OpenSSL
 * project 2001.
 */
/* ====================================================================
 * Copyright (c) 2001 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/buffer.h>
#include <openssl/err.h>
#include <openssl/ui.h>

#include "ui_locl.h"

static const UI_METHOD *default_UI_meth = NULL;

UI *
UI_new(void)
{
	return (UI_new_method(NULL));
}

UI *
UI_new_method(const UI_METHOD *method)
{
	UI *ret;

	ret = malloc(sizeof(UI));
	if (ret == NULL) {
		UIerror(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	if (method == NULL)
		ret->meth = UI_get_default_method();
	else
		ret->meth = method;

	ret->strings = NULL;
	ret->user_data = NULL;
	ret->flags = 0;
	CRYPTO_new_ex_data(CRYPTO_EX_INDEX_UI, ret, &ret->ex_data);
	return ret;
}

static void
free_string(UI_STRING *uis)
{
	if (uis->flags & OUT_STRING_FREEABLE) {
		free((char *) uis->out_string);
		switch (uis->type) {
		case UIT_BOOLEAN:
			free((char *)uis->_.boolean_data.action_desc);
			free((char *)uis->_.boolean_data.ok_chars);
			free((char *)uis->_.boolean_data.cancel_chars);
			break;
		default:
			break;
		}
	}
	free(uis);
}

void
UI_free(UI *ui)
{
	if (ui == NULL)
		return;
	sk_UI_STRING_pop_free(ui->strings, free_string);
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_UI, ui, &ui->ex_data);
	free(ui);
}

static int
allocate_string_stack(UI *ui)
{
	if (ui->strings == NULL) {
		ui->strings = sk_UI_STRING_new_null();
		if (ui->strings == NULL) {
			return -1;
		}
	}
	return 0;
}

static UI_STRING *
general_allocate_prompt(UI *ui, const char *prompt, int prompt_freeable,
    enum UI_string_types type, int input_flags, char *result_buf)
{
	UI_STRING *ret = NULL;

	if (prompt == NULL) {
		UIerror(ERR_R_PASSED_NULL_PARAMETER);
	} else if ((type == UIT_PROMPT || type == UIT_VERIFY ||
	    type == UIT_BOOLEAN) && result_buf == NULL) {
		UIerror(UI_R_NO_RESULT_BUFFER);
	} else if ((ret = malloc(sizeof(UI_STRING)))) {
		ret->out_string = prompt;
		ret->flags = prompt_freeable ? OUT_STRING_FREEABLE : 0;
		ret->input_flags = input_flags;
		ret->type = type;
		ret->result_buf = result_buf;
	}
	return ret;
}

static int
general_allocate_string(UI *ui, const char *prompt, int prompt_freeable,
    enum UI_string_types type, int input_flags, char *result_buf, int minsize,
    int maxsize, const char *test_buf)
{
	int ret = -1;
	UI_STRING *s = general_allocate_prompt(ui, prompt, prompt_freeable,
	    type, input_flags, result_buf);

	if (s) {
		if (allocate_string_stack(ui) >= 0) {
			s->_.string_data.result_minsize = minsize;
			s->_.string_data.result_maxsize = maxsize;
			s->_.string_data.test_buf = test_buf;
			ret = sk_UI_STRING_push(ui->strings, s);
			/* sk_push() returns 0 on error.  Let's adapt that */
			if (ret <= 0)
				ret--;
		} else
			free_string(s);
	}
	return ret;
}

static int
general_allocate_boolean(UI *ui, const char *prompt, const char *action_desc,
    const char *ok_chars, const char *cancel_chars, int prompt_freeable,
    enum UI_string_types type, int input_flags, char *result_buf)
{
	int ret = -1;
	UI_STRING *s;
	const char *p;

	if (ok_chars == NULL) {
		UIerror(ERR_R_PASSED_NULL_PARAMETER);
	} else if (cancel_chars == NULL) {
		UIerror(ERR_R_PASSED_NULL_PARAMETER);
	} else {
		for (p = ok_chars; *p; p++) {
			if (strchr(cancel_chars, *p)) {
				UIerror(UI_R_COMMON_OK_AND_CANCEL_CHARACTERS);
			}
		}

		s = general_allocate_prompt(ui, prompt, prompt_freeable,
		    type, input_flags, result_buf);

		if (s) {
			if (allocate_string_stack(ui) >= 0) {
				s->_.boolean_data.action_desc = action_desc;
				s->_.boolean_data.ok_chars = ok_chars;
				s->_.boolean_data.cancel_chars = cancel_chars;
				ret = sk_UI_STRING_push(ui->strings, s);
				/*
				 * sk_push() returns 0 on error. Let's adapt
				 * that
				 */
				if (ret <= 0)
					ret--;
			} else
				free_string(s);
		}
	}
	return ret;
}

/* Returns the index to the place in the stack or -1 for error.  Uses a
   direct reference to the prompt.  */
int
UI_add_input_string(UI *ui, const char *prompt, int flags, char *result_buf,
    int minsize, int maxsize)
{
	return general_allocate_string(ui, prompt, 0, UIT_PROMPT, flags,
	    result_buf, minsize, maxsize, NULL);
}

/* Same as UI_add_input_string(), excepts it takes a copy of the prompt */
int
UI_dup_input_string(UI *ui, const char *prompt, int flags, char *result_buf,
    int minsize, int maxsize)
{
	char *prompt_copy = NULL;

	if (prompt) {
		prompt_copy = strdup(prompt);
		if (prompt_copy == NULL) {
			UIerror(ERR_R_MALLOC_FAILURE);
			return 0;
		}
	}
	return general_allocate_string(ui, prompt_copy, 1, UIT_PROMPT, flags,
	    result_buf, minsize, maxsize, NULL);
}

int
UI_add_verify_string(UI *ui, const char *prompt, int flags, char *result_buf,
    int minsize, int maxsize, const char *test_buf)
{
	return general_allocate_string(ui, prompt, 0, UIT_VERIFY, flags,
	    result_buf, minsize, maxsize, test_buf);
}

int
UI_dup_verify_string(UI *ui, const char *prompt, int flags,
    char *result_buf, int minsize, int maxsize, const char *test_buf)
{
	char *prompt_copy = NULL;

	if (prompt) {
		prompt_copy = strdup(prompt);
		if (prompt_copy == NULL) {
			UIerror(ERR_R_MALLOC_FAILURE);
			return -1;
		}
	}
	return general_allocate_string(ui, prompt_copy, 1, UIT_VERIFY, flags,
	    result_buf, minsize, maxsize, test_buf);
}

int
UI_add_input_boolean(UI *ui, const char *prompt, const char *action_desc,
    const char *ok_chars, const char *cancel_chars, int flags, char *result_buf)
{
	return general_allocate_boolean(ui, prompt, action_desc, ok_chars,
	    cancel_chars, 0, UIT_BOOLEAN, flags, result_buf);
}

int
UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,
    const char *ok_chars, const char *cancel_chars, int flags, char *result_buf)
{
	char *prompt_copy = NULL;
	char *action_desc_copy = NULL;
	char *ok_chars_copy = NULL;
	char *cancel_chars_copy = NULL;

	if (prompt) {
		prompt_copy = strdup(prompt);
		if (prompt_copy == NULL) {
			UIerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}
	if (action_desc) {
		action_desc_copy = strdup(action_desc);
		if (action_desc_copy == NULL) {
			UIerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}
	if (ok_chars) {
		ok_chars_copy = strdup(ok_chars);
		if (ok_chars_copy == NULL) {
			UIerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}
	if (cancel_chars) {
		cancel_chars_copy = strdup(cancel_chars);
		if (cancel_chars_copy == NULL) {
			UIerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
	}
	return general_allocate_boolean(ui, prompt_copy, action_desc_copy,
	    ok_chars_copy, cancel_chars_copy, 1, UIT_BOOLEAN, flags,
	    result_buf);

err:
	free(prompt_copy);
	free(action_desc_copy);
	free(ok_chars_copy);
	free(cancel_chars_copy);
	return -1;
}

int
UI_add_info_string(UI *ui, const char *text)
{
	return general_allocate_string(ui, text, 0, UIT_INFO, 0, NULL, 0, 0,
	    NULL);
}

int
UI_dup_info_string(UI *ui, const char *text)
{
	char *text_copy = NULL;

	if (text) {
		text_copy = strdup(text);
		if (text_copy == NULL) {
			UIerror(ERR_R_MALLOC_FAILURE);
			return -1;
		}
	}
	return general_allocate_string(ui, text_copy, 1, UIT_INFO, 0, NULL,
	    0, 0, NULL);
}

int
UI_add_error_string(UI *ui, const char *text)
{
	return general_allocate_string(ui, text, 0, UIT_ERROR, 0, NULL, 0, 0,
	    NULL);
}

int
UI_dup_error_string(UI *ui, const char *text)
{
	char *text_copy = NULL;

	if (text) {
		text_copy = strdup(text);
		if (text_copy == NULL) {
			UIerror(ERR_R_MALLOC_FAILURE);
			return -1;
		}
	}
	return general_allocate_string(ui, text_copy, 1, UIT_ERROR, 0, NULL,
	    0, 0, NULL);
}

char *
UI_construct_prompt(UI *ui, const char *object_desc, const char *object_name)
{
	char *prompt;

	if (ui->meth->ui_construct_prompt)
		return ui->meth->ui_construct_prompt(ui, object_desc,
		    object_name);

	if (object_desc == NULL)
		return NULL;

	if (object_name == NULL) {
		if (asprintf(&prompt, "Enter %s:", object_desc) == -1)
			return (NULL);
	} else {
		if (asprintf(&prompt, "Enter %s for %s:", object_desc,
		    object_name) == -1)
			return (NULL);
	}

	return prompt;
}

void *
UI_add_user_data(UI *ui, void *user_data)
{
	void *old_data = ui->user_data;

	ui->user_data = user_data;
	return old_data;
}

void *
UI_get0_user_data(UI *ui)
{
	return ui->user_data;
}

const char *
UI_get0_result(UI *ui, int i)
{
	if (i < 0) {
		UIerror(UI_R_INDEX_TOO_SMALL);
		return NULL;
	}
	if (i >= sk_UI_STRING_num(ui->strings)) {
		UIerror(UI_R_INDEX_TOO_LARGE);
		return NULL;
	}
	return UI_get0_result_string(sk_UI_STRING_value(ui->strings, i));
}

static int
print_error(const char *str, size_t len, UI *ui)
{
	UI_STRING uis;

	memset(&uis, 0, sizeof(uis));
	uis.type = UIT_ERROR;
	uis.out_string = str;

	if (ui->meth->ui_write_string &&
	    !ui->meth->ui_write_string(ui, &uis))
		return -1;
	return 0;
}

int
UI_process(UI *ui)
{
	int i, ok = 0;

	if (ui->meth->ui_open_session && !ui->meth->ui_open_session(ui))
		return -1;

	if (ui->flags & UI_FLAG_PRINT_ERRORS)
		ERR_print_errors_cb(
		    (int (*)(const char *, size_t, void *)) print_error,
		    (void *)ui);

	for (i = 0; i < sk_UI_STRING_num(ui->strings); i++) {
		if (ui->meth->ui_write_string &&
		    !ui->meth->ui_write_string(ui,
			sk_UI_STRING_value(ui->strings, i))) {
			ok = -1;
			goto err;
		}
	}

	if (ui->meth->ui_flush)
		switch (ui->meth->ui_flush(ui)) {
		case -1:	/* Interrupt/Cancel/something... */
			ok = -2;
			goto err;
		case 0:		/* Errors */
			ok = -1;
			goto err;
		default:	/* Success */
			ok = 0;
			break;
		}

	for (i = 0; i < sk_UI_STRING_num(ui->strings); i++) {
		if (ui->meth->ui_read_string) {
			switch (ui->meth->ui_read_string(ui,
			    sk_UI_STRING_value(ui->strings, i))) {
			case -1:	/* Interrupt/Cancel/something... */
				ui->flags &= ~UI_FLAG_REDOABLE;
				ok = -2;
				goto err;
			case 0:		/* Errors */
				ok = -1;
				goto err;
			default:	/* Success */
				ok = 0;
				break;
			}
		}
	}

err:
	if (ui->meth->ui_close_session && !ui->meth->ui_close_session(ui))
		return -1;
	return ok;
}

int
UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f) (void))
{
	if (ui == NULL) {
		UIerror(ERR_R_PASSED_NULL_PARAMETER);
		return -1;
	}
	switch (cmd) {
	case UI_CTRL_PRINT_ERRORS:
		{
			int save_flag = !!(ui->flags & UI_FLAG_PRINT_ERRORS);
			if (i)
				ui->flags |= UI_FLAG_PRINT_ERRORS;
			else
				ui->flags &= ~UI_FLAG_PRINT_ERRORS;
			return save_flag;
		}
	case UI_CTRL_IS_REDOABLE:
		return !!(ui->flags & UI_FLAG_REDOABLE);
	default:
		break;
	}
	UIerror(UI_R_UNKNOWN_CONTROL_COMMAND);
	return -1;
}

int
UI_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_UI, argl, argp,
	    new_func, dup_func, free_func);
}

int
UI_set_ex_data(UI *r, int idx, void *arg)
{
	return (CRYPTO_set_ex_data(&r->ex_data, idx, arg));
}

void *
UI_get_ex_data(UI *r, int idx)
{
	return (CRYPTO_get_ex_data(&r->ex_data, idx));
}

void
UI_set_default_method(const UI_METHOD *meth)
{
	default_UI_meth = meth;
}

const UI_METHOD *
UI_get_default_method(void)
{
	if (default_UI_meth == NULL) {
		default_UI_meth = UI_OpenSSL();
	}
	return default_UI_meth;
}

const UI_METHOD *
UI_get_method(UI *ui)
{
	return ui->meth;
}

const UI_METHOD *
UI_set_method(UI *ui, const UI_METHOD *meth)
{
	ui->meth = meth;
	return ui->meth;
}


UI_METHOD *
UI_create_method(char *name)
{
	UI_METHOD *ui_method = calloc(1, sizeof(UI_METHOD));

	if (ui_method && name)
		ui_method->name = strdup(name);

	return ui_method;
}

/* BIG FSCKING WARNING!!!!  If you use this on a statically allocated method
   (that is, it hasn't been allocated using UI_create_method(), you deserve
   anything Murphy can throw at you and more!  You have been warned. */
void
UI_destroy_method(UI_METHOD *ui_method)
{
	free(ui_method->name);
	ui_method->name = NULL;
	free(ui_method);
}

int
UI_method_set_opener(UI_METHOD *method, int (*opener)(UI *ui))
{
	if (method) {
		method->ui_open_session = opener;
		return 0;
	} else
		return -1;
}

int
UI_method_set_writer(UI_METHOD *method, int (*writer)(UI *ui, UI_STRING *uis))
{
	if (method) {
		method->ui_write_string = writer;
		return 0;
	} else
		return -1;
}

int
UI_method_set_flusher(UI_METHOD *method, int (*flusher)(UI *ui))
{
	if (method) {
		method->ui_flush = flusher;
		return 0;
	} else
		return -1;
}

int
UI_method_set_reader(UI_METHOD *method, int (*reader)(UI *ui, UI_STRING *uis))
{
	if (method) {
		method->ui_read_string = reader;
		return 0;
	} else
		return -1;
}

int
UI_method_set_closer(UI_METHOD *method, int (*closer)(UI *ui))
{
	if (method) {
		method->ui_close_session = closer;
		return 0;
	} else
		return -1;
}

int
UI_method_set_prompt_constructor(UI_METHOD *method,
    char *(*prompt_constructor)(UI *ui, const char *object_desc,
    const char *object_name))
{
	if (method) {
		method->ui_construct_prompt = prompt_constructor;
		return 0;
	} else
		return -1;
}

int
(*UI_method_get_opener(UI_METHOD * method))(UI *)
{
	if (method)
		return method->ui_open_session;
	else
		return NULL;
}

int
(*UI_method_get_writer(UI_METHOD *method))(UI *, UI_STRING *)
{
	if (method)
		return method->ui_write_string;
	else
		return NULL;
}

int
(*UI_method_get_flusher(UI_METHOD *method)) (UI *)
{
	if (method)
		return method->ui_flush;
	else
		return NULL;
}

int
(*UI_method_get_reader(UI_METHOD *method))(UI *, UI_STRING *)
{
	if (method)
		return method->ui_read_string;
	else
		return NULL;
}

int
(*UI_method_get_closer(UI_METHOD *method))(UI *)
{
	if (method)
		return method->ui_close_session;
	else
		return NULL;
}

char *
(*UI_method_get_prompt_constructor(UI_METHOD *method))(UI *, const char *,
    const char *)
{
	if (method)
		return method->ui_construct_prompt;
	else
		return NULL;
}

enum UI_string_types
UI_get_string_type(UI_STRING *uis)
{
	if (!uis)
		return UIT_NONE;
	return uis->type;
}

int
UI_get_input_flags(UI_STRING *uis)
{
	if (!uis)
		return 0;
	return uis->input_flags;
}

const char *
UI_get0_output_string(UI_STRING *uis)
{
	if (!uis)
		return NULL;
	return uis->out_string;
}

const char *
UI_get0_action_string(UI_STRING *uis)
{
	if (!uis)
		return NULL;
	switch (uis->type) {
	case UIT_PROMPT:
	case UIT_BOOLEAN:
		return uis->_.boolean_data.action_desc;
	default:
		return NULL;
	}
}

const char *
UI_get0_result_string(UI_STRING *uis)
{
	if (!uis)
		return NULL;
	switch (uis->type) {
	case UIT_PROMPT:
	case UIT_VERIFY:
		return uis->result_buf;
	default:
		return NULL;
	}
}

const char *
UI_get0_test_string(UI_STRING *uis)
{
	if (!uis)
		return NULL;
	switch (uis->type) {
	case UIT_VERIFY:
		return uis->_.string_data.test_buf;
	default:
		return NULL;
	}
}

int
UI_get_result_minsize(UI_STRING *uis)
{
	if (!uis)
		return -1;
	switch (uis->type) {
	case UIT_PROMPT:
	case UIT_VERIFY:
		return uis->_.string_data.result_minsize;
	default:
		return -1;
	}
}

int
UI_get_result_maxsize(UI_STRING *uis)
{
	if (!uis)
		return -1;
	switch (uis->type) {
	case UIT_PROMPT:
	case UIT_VERIFY:
		return uis->_.string_data.result_maxsize;
	default:
		return -1;
	}
}

int
UI_set_result(UI *ui, UI_STRING *uis, const char *result)
{
	int l = strlen(result);

	ui->flags &= ~UI_FLAG_REDOABLE;

	if (!uis)
		return -1;
	switch (uis->type) {
	case UIT_PROMPT:
	case UIT_VERIFY:
		if (l < uis->_.string_data.result_minsize) {
			ui->flags |= UI_FLAG_REDOABLE;
			UIerror(UI_R_RESULT_TOO_SMALL);
			ERR_asprintf_error_data
			    ("You must type in %d to %d characters",
				uis->_.string_data.result_minsize,
				uis->_.string_data.result_maxsize);
			return -1;
		}
		if (l > uis->_.string_data.result_maxsize) {
			ui->flags |= UI_FLAG_REDOABLE;
			UIerror(UI_R_RESULT_TOO_LARGE);
			ERR_asprintf_error_data
			    ("You must type in %d to %d characters",
				uis->_.string_data.result_minsize,
				uis->_.string_data.result_maxsize);
			return -1;
		}
		if (!uis->result_buf) {
			UIerror(UI_R_NO_RESULT_BUFFER);
			return -1;
		}
		strlcpy(uis->result_buf, result,
		    uis->_.string_data.result_maxsize + 1);
		break;
	case UIT_BOOLEAN:
		{
			const char *p;

			if (!uis->result_buf) {
				UIerror(UI_R_NO_RESULT_BUFFER);
				return -1;
			}
			uis->result_buf[0] = '\0';
			for (p = result; *p; p++) {
				if (strchr(uis->_.boolean_data.ok_chars, *p)) {
					uis->result_buf[0] =
					    uis->_.boolean_data.ok_chars[0];
					break;
				}
				if (strchr(uis->_.boolean_data.cancel_chars, *p)) {
					uis->result_buf[0] =
					    uis->_.boolean_data.cancel_chars[0];
					break;
				}
			}
		default:
			break;
		}
	}
	return 0;
}
@


1.31
log
@don't go into an unbreakable infinite loop during operations such
as reading passwords. allow ^C to break.
the pain was mine, the fix is miod's.
@
text
@d1 1
a1 1
/* $OpenBSD: ui_lib.c,v 1.30 2015/02/10 11:22:21 jsing Exp $ */
d84 1
a84 1
		UIerr(UI_F_UI_NEW_METHOD, ERR_R_MALLOC_FAILURE);
d146 1
a146 2
		UIerr(UI_F_GENERAL_ALLOCATE_PROMPT,
		    ERR_R_PASSED_NULL_PARAMETER);
d149 1
a149 1
		UIerr(UI_F_GENERAL_ALLOCATE_PROMPT, UI_R_NO_RESULT_BUFFER);
d194 1
a194 2
		UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,
		    ERR_R_PASSED_NULL_PARAMETER);
d196 1
a196 2
		UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,
		    ERR_R_PASSED_NULL_PARAMETER);
d200 1
a200 2
				UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,
				    UI_R_COMMON_OK_AND_CANCEL_CHARACTERS);
d246 1
a246 1
			UIerr(UI_F_UI_DUP_INPUT_STRING, ERR_R_MALLOC_FAILURE);
d271 1
a271 1
			UIerr(UI_F_UI_DUP_VERIFY_STRING, ERR_R_MALLOC_FAILURE);
d299 1
a299 1
			UIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);
d306 1
a306 1
			UIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);
d313 1
a313 1
			UIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);
d320 1
a320 1
			UIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);
d351 1
a351 1
			UIerr(UI_F_UI_DUP_INFO_STRING, ERR_R_MALLOC_FAILURE);
d374 1
a374 1
			UIerr(UI_F_UI_DUP_ERROR_STRING, ERR_R_MALLOC_FAILURE);
d425 1
a425 1
		UIerr(UI_F_UI_GET0_RESULT, UI_R_INDEX_TOO_SMALL);
d429 1
a429 1
		UIerr(UI_F_UI_GET0_RESULT, UI_R_INDEX_TOO_LARGE);
d513 1
a513 1
		UIerr(UI_F_UI_CTRL, ERR_R_PASSED_NULL_PARAMETER);
d531 1
a531 1
	UIerr(UI_F_UI_CTRL, UI_R_UNKNOWN_CONTROL_COMMAND);
d830 1
a830 2
			UIerr(UI_F_UI_SET_RESULT,
			    UI_R_RESULT_TOO_SMALL);
d839 1
a839 2
			UIerr(UI_F_UI_SET_RESULT,
			    UI_R_RESULT_TOO_LARGE);
d847 1
a847 1
			UIerr(UI_F_UI_SET_RESULT, UI_R_NO_RESULT_BUFFER);
d858 1
a858 1
				UIerr(UI_F_UI_SET_RESULT, UI_R_NO_RESULT_BUFFER);
@


1.30
log
@Remove more IMPLEMENT_STACK_OF noops that have been hiding for the last
15 years.
@
text
@d1 1
a1 1
/* $OpenBSD: ui_lib.c,v 1.29 2014/10/03 06:02:38 doug Exp $ */
d494 1
@


1.29
log
@Use string literals in printf style calls so gcc's -Wformat works.

ok tedu@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui_lib.c,v 1.28 2014/07/22 02:21:20 beck Exp $ */
d69 1
a69 1
IMPLEMENT_STACK_OF(UI_STRING_ST) static const UI_METHOD *default_UI_meth = NULL;
@


1.28
log
@Kill a bunch more BUF_strdup's - these are converted to have a check for
NULL before an intrinsic strdup.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui_lib.c,v 1.27 2014/07/13 16:03:10 beck Exp $ */
a388 1
	const char *format = "Enter %s for %s:";
d397 9
a405 4
	if (object_name == NULL)
		format = "Enter %s:";
	if (asprintf(&prompt, format, object_desc, object_name) == -1)
		return NULL;
@


1.27
log
@The bell tolls for BUF_strdup - Start the migration to using
intrinsics. This is the easy ones, a few left to check one at
a time.
ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui_lib.c,v 1.26 2014/07/11 16:22:29 deraadt Exp $ */
d588 2
a589 2
	if (ui_method)
		ui_method->name = BUF_strdup(name);
@


1.26
log
@adapt addapt spelling to adapt; request from miod
@
text
@d1 1
a1 1
/* $OpenBSD: ui_lib.c,v 1.25 2014/07/11 08:44:49 jsing Exp $ */
d248 1
a248 1
		prompt_copy = BUF_strdup(prompt);
d273 1
a273 1
		prompt_copy = BUF_strdup(prompt);
d301 1
a301 1
		prompt_copy = BUF_strdup(prompt);
d308 1
a308 1
		action_desc_copy = BUF_strdup(action_desc);
d315 1
a315 1
		ok_chars_copy = BUF_strdup(ok_chars);
d322 1
a322 1
		cancel_chars_copy = BUF_strdup(cancel_chars);
d353 1
a353 1
		text_copy = BUF_strdup(text);
d376 1
a376 1
		text_copy = BUF_strdup(text);
@


1.25
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ui_lib.c,v 1.24 2014/06/12 15:49:31 deraadt Exp $ */
d176 1
a176 1
			/* sk_push() returns 0 on error.  Let's addapt that */
d218 1
a218 1
				 * sk_push() returns 0 on error. Let's addapt
@


1.24
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a62 2
#include "cryptlib.h"

d64 1
d66 1
a66 1
#include <openssl/err.h>
@


1.23
log
@c-file-style hints, begone; ok beck
@
text
@d1 1
a1 1
/* crypto/ui/ui_lib.c */
@


1.22
log
@malloc() result does not need a cast.
ok miod
@
text
@d1 1
a1 1
/* crypto/ui/ui_lib.c -*- mode:C; c-file-style: "eay" -*- */
@


1.21
log
@calloc instead of malloc/memset. from Benjamin Baier
@
text
@d83 1
a83 1
	ret = (UI *) malloc(sizeof(UI));
d152 1
a152 1
	} else if ((ret = (UI_STRING *) malloc(sizeof(UI_STRING)))) {
@


1.20
log
@Almost nothing actually needs to include <openssl/e_os2.h>, however by
including it they get <openssl/opensslconf.h>. So instead of pulling in
<openssl/e_os2.h>, just pull in <openssl/opensslconf.h>.

"go ahead" miod@@
@
text
@d587 1
a587 1
	UI_METHOD *ui_method = (UI_METHOD *)malloc(sizeof(UI_METHOD));
d589 1
a589 2
	if (ui_method) {
		memset(ui_method, 0, sizeof(*ui_method));
d591 1
a591 1
	}
@


1.19
log
@if (x) free(x) -> free(x); semantic patch generated with coccinelle, carefully
eyeballed before applying. Contributed by Cyril Roelandt on tech@@
@
text
@d60 3
d64 1
a64 1
#include <openssl/e_os2.h>
@


1.18
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@d331 4
a334 8
	if (prompt_copy)
		free(prompt_copy);
	if (action_desc_copy)
		free(action_desc_copy);
	if (ok_chars_copy)
		free(ok_chars_copy);
	if (cancel_chars_copy)
		free(cancel_chars_copy);
@


1.17
log
@Use const char *.

Suggested by miod@@
@
text
@d830 19
a848 23
		{
			char number1[DECIMAL_SIZE(uis->_.string_data.result_minsize) + 1];
			char number2[DECIMAL_SIZE(uis->_.string_data.result_maxsize) + 1];

			(void) snprintf(number1, sizeof(number1), "%d",
			    uis->_.string_data.result_minsize);
			(void) snprintf(number2, sizeof(number2), "%d",
			    uis->_.string_data.result_maxsize);

			if (l < uis->_.string_data.result_minsize) {
				ui->flags |= UI_FLAG_REDOABLE;
				UIerr(UI_F_UI_SET_RESULT, UI_R_RESULT_TOO_SMALL);
				ERR_add_error_data(5, "You must type in ",
				    number1, " to ", number2, " characters");
				return -1;
			}
			if (l > uis->_.string_data.result_maxsize) {
				ui->flags |= UI_FLAG_REDOABLE;
				UIerr(UI_F_UI_SET_RESULT, UI_R_RESULT_TOO_LARGE);
				ERR_add_error_data(5, "You must type in ",
				    number1, " to ", number2, " characters");
				return -1;
			}
a849 1

@


1.16
log
@Remove some malloc/strlcpy/strlcat horror. Just use asprintf and avoid an
unchecked malloc at the same time.

ok beck@@
@
text
@d391 1
a391 1
	char *format = "Enter %s for %s:";
@


1.15
log
@More KNF.
@
text
@d391 2
a392 1
	char *prompt = NULL;
d395 2
a396 7
		prompt = ui->meth->ui_construct_prompt(ui,
		    object_desc, object_name);
	else {
		char prompt1[] = "Enter ";
		char prompt2[] = " for ";
		char prompt3[] = ":";
		int len = 0;
d398 6
a403 6
		if (object_desc == NULL)
			return NULL;
		len = sizeof(prompt1) - 1 + strlen(object_desc);
		if (object_name)
			len += sizeof(prompt2) - 1 + strlen(object_name);
		len += sizeof(prompt3) - 1;
a404 9
		prompt = (char *)malloc(len + 1);
		strlcpy(prompt, prompt1, len + 1);
		strlcat(prompt, object_desc, len + 1);
		if (object_name) {
			strlcat(prompt, prompt2, len + 1);
			strlcat(prompt, object_name, len + 1);
		}
		strlcat(prompt, prompt3, len + 1);
	}
@


1.14
log
@Restore beck's rev 1.8: snprintf() was reviewed.
@
text
@d138 2
a139 3
general_allocate_prompt(UI *ui, const char *prompt,
    int prompt_freeable, enum UI_string_types type, int input_flags,
    char *result_buf)
d144 2
a145 1
		UIerr(UI_F_GENERAL_ALLOCATE_PROMPT, ERR_R_PASSED_NULL_PARAMETER);
d160 3
a162 3
general_allocate_string(UI *ui, const char *prompt,
    int prompt_freeable, enum UI_string_types type, int input_flags,
    char *result_buf, int minsize, int maxsize, const char *test_buf)
d184 3
a186 5
general_allocate_boolean(UI *ui,
    const char *prompt, const char *action_desc,
    const char *ok_chars, const char *cancel_chars,
    int prompt_freeable, enum UI_string_types type, int input_flags,
    char *result_buf)
d193 2
a194 1
		UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN, ERR_R_PASSED_NULL_PARAMETER);
d196 2
a197 1
		UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN, ERR_R_PASSED_NULL_PARAMETER);
d231 2
a232 2
UI_add_input_string(UI *ui, const char *prompt, int flags,
    char *result_buf, int minsize, int maxsize)
d234 2
a235 2
	return general_allocate_string(ui, prompt, 0,
	    UIT_PROMPT, flags, result_buf, minsize, maxsize, NULL);
d240 2
a241 2
UI_dup_input_string(UI *ui, const char *prompt, int flags,
    char *result_buf, int minsize, int maxsize)
d252 2
a253 2
	return general_allocate_string(ui, prompt_copy, 1,
	    UIT_PROMPT, flags, result_buf, minsize, maxsize, NULL);
d257 2
a258 2
UI_add_verify_string(UI *ui, const char *prompt, int flags,
    char *result_buf, int minsize, int maxsize, const char *test_buf)
d260 2
a261 2
	return general_allocate_string(ui, prompt, 0,
	    UIT_VERIFY, flags, result_buf, minsize, maxsize, test_buf);
d277 2
a278 2
	return general_allocate_string(ui, prompt_copy, 1,
	    UIT_VERIFY, flags, result_buf, minsize, maxsize, test_buf);
d283 1
a283 2
    const char *ok_chars, const char *cancel_chars,
    int flags, char *result_buf)
d285 2
a286 2
	return general_allocate_boolean(ui, prompt, action_desc,
	    ok_chars, cancel_chars, 0, UIT_BOOLEAN, flags, result_buf);
d291 1
a291 2
    const char *ok_chars, const char *cancel_chars,
    int flags, char *result_buf)
d425 1
d516 1
d601 1
a601 1
	UI_METHOD *ui_method = (UI_METHOD *) malloc(sizeof(UI_METHOD));
@


1.13
log
@We'll interpret a (void) cast on snprintf() to mean it's been verified that
truncation is either desirable, not an issue, or is detected and handled later

ok deraadt@@
@
text
@d847 1
a847 1
			snprintf(number1, sizeof(number1), "%d",
d849 1
a849 1
			snprintf(number2, sizeof(number2), "%d",
@


1.12
log
@use intrinsic strlcpy and strlcat everywhere so we only have one set of
funcitons to check for incorrect use. keep BUF_strlcpy and BUF_strlcat
for API comptibility only.
ok tedu@@
@
text
@d847 1
a847 1
			(void) snprintf(number1, sizeof(number1), "%d",
d849 1
a849 1
			(void) snprintf(number2, sizeof(number2), "%d",
@


1.11
log
@More KNF.
@
text
@d412 2
a413 2
		BUF_strlcpy(prompt, prompt1, len + 1);
		BUF_strlcat(prompt, object_desc, len + 1);
d415 2
a416 2
			BUF_strlcat(prompt, prompt2, len + 1);
			BUF_strlcat(prompt, object_name, len + 1);
d418 1
a418 1
		BUF_strlcat(prompt, prompt3, len + 1);
d872 1
a872 1
		BUF_strlcpy(uis->result_buf, result,
@


1.10
log
@stab at indentation
@
text
@d67 1
a67 2
IMPLEMENT_STACK_OF(UI_STRING_ST)
	static const UI_METHOD *default_UI_meth = NULL;
d69 2
a70 1
	UI *UI_new(void)
d76 1
a76 1
UI_new_method(const UI_METHOD * method)
d97 2
a98 2
static void 
free_string(UI_STRING * uis)
d104 3
a106 3
			free((char *) uis->_.boolean_data.action_desc);
			free((char *) uis->_.boolean_data.ok_chars);
			free((char *) uis->_.boolean_data.cancel_chars);
d115 2
a116 2
void 
UI_free(UI * ui)
d125 2
a126 2
static int 
allocate_string_stack(UI * ui)
d138 1
a138 1
general_allocate_prompt(UI * ui, const char *prompt,
d146 2
a147 2
	} else if ((type == UIT_PROMPT || type == UIT_VERIFY
		|| type == UIT_BOOLEAN) && result_buf == NULL) {
d159 2
a160 2
static int 
general_allocate_string(UI * ui, const char *prompt,
d183 2
a184 2
static int 
general_allocate_boolean(UI * ui,
d230 2
a231 2
int 
UI_add_input_string(UI * ui, const char *prompt, int flags,
d239 2
a240 2
int 
UI_dup_input_string(UI * ui, const char *prompt, int flags,
d256 2
a257 2
int 
UI_add_verify_string(UI * ui, const char *prompt, int flags,
d264 2
a265 2
int 
UI_dup_verify_string(UI * ui, const char *prompt, int flags,
d281 2
a282 2
int 
UI_add_input_boolean(UI * ui, const char *prompt, const char *action_desc,
d290 2
a291 2
int 
UI_dup_input_boolean(UI * ui, const char *prompt, const char *action_desc,
d331 1
d344 2
a345 2
int 
UI_add_info_string(UI * ui, const char *text)
d351 2
a352 2
int 
UI_dup_info_string(UI * ui, const char *text)
d367 2
a368 2
int 
UI_add_error_string(UI * ui, const char *text)
d374 2
a375 2
int 
UI_dup_error_string(UI * ui, const char *text)
d391 1
a391 2
UI_construct_prompt(UI * ui, const char *object_desc,
    const char *object_name)
d411 1
a411 1
		prompt = (char *) malloc(len + 1);
d424 1
a424 1
UI_add_user_data(UI * ui, void *user_data)
d432 1
a432 1
UI_get0_user_data(UI * ui)
d438 1
a438 1
UI_get0_result(UI * ui, int i)
d451 2
a452 2
static int 
print_error(const char *str, size_t len, UI * ui)
d460 2
a461 2
	if (ui->meth->ui_write_string
	    && !ui->meth->ui_write_string(ui, &uis))
d466 2
a467 2
int 
UI_process(UI * ui)
d476 2
a477 2
		    (int (*) (const char *, size_t, void *)) print_error,
		    (void *) ui);
d480 2
a481 2
		if (ui->meth->ui_write_string
		    && !ui->meth->ui_write_string(ui,
d493 1
a493 1
		case 0:	/* Errors */
d504 1
a504 1
				sk_UI_STRING_value(ui->strings, i))) {
d508 1
a508 1
			case 0:/* Errors */
d523 2
a524 2
int 
UI_ctrl(UI * ui, int cmd, long i, void *p, void (*f) (void))
d549 3
a551 3
int 
UI_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new * new_func,
    CRYPTO_EX_dup * dup_func, CRYPTO_EX_free * free_func)
d557 2
a558 2
int 
UI_set_ex_data(UI * r, int idx, void *arg)
d564 1
a564 1
UI_get_ex_data(UI * r, int idx)
d569 2
a570 2
void 
UI_set_default_method(const UI_METHOD * meth)
d585 1
a585 1
UI_get_method(UI * ui)
d591 1
a591 1
UI_set_method(UI * ui, const UI_METHOD * meth)
d613 2
a614 2
void 
UI_destroy_method(UI_METHOD * ui_method)
d621 2
a622 2
int 
UI_method_set_opener(UI_METHOD * method, int (*opener) (UI * ui))
d631 2
a632 2
int 
UI_method_set_writer(UI_METHOD * method, int (*writer) (UI * ui, UI_STRING * uis))
d641 2
a642 2
int 
UI_method_set_flusher(UI_METHOD * method, int (*flusher) (UI * ui))
d651 2
a652 2
int 
UI_method_set_reader(UI_METHOD * method, int (*reader) (UI * ui, UI_STRING * uis))
d661 2
a662 2
int 
UI_method_set_closer(UI_METHOD * method, int (*closer) (UI * ui))
d671 4
a674 2
int 
UI_method_set_prompt_constructor(UI_METHOD * method, char *(*prompt_constructor) (UI * ui, const char *object_desc, const char *object_name))
d683 2
a684 2
int (*
    UI_method_get_opener(UI_METHOD * method)) (UI *)
d692 2
a693 2
int (*
    UI_method_get_writer(UI_METHOD * method)) (UI *, UI_STRING *)
d701 2
a702 2
int (*
    UI_method_get_flusher(UI_METHOD * method)) (UI *)
d710 2
a711 2
int (*
    UI_method_get_reader(UI_METHOD * method)) (UI *, UI_STRING *)
d719 2
a720 2
int (*
    UI_method_get_closer(UI_METHOD * method)) (UI *)
d728 3
a730 2
char *(*
    UI_method_get_prompt_constructor(UI_METHOD * method)) (UI *, const char *, const char *)
d738 2
a739 2
enum UI_string_types 
UI_get_string_type(UI_STRING * uis)
d746 2
a747 2
int 
UI_get_input_flags(UI_STRING * uis)
d755 1
a755 1
UI_get0_output_string(UI_STRING * uis)
d763 1
a763 1
UI_get0_action_string(UI_STRING * uis)
d777 1
a777 1
UI_get0_result_string(UI_STRING * uis)
d791 1
a791 1
UI_get0_test_string(UI_STRING * uis)
d803 2
a804 2
int 
UI_get_result_minsize(UI_STRING * uis)
d817 2
a818 2
int 
UI_get_result_maxsize(UI_STRING * uis)
d831 2
a832 2
int 
UI_set_result(UI * ui, UI_STRING * uis, const char *result)
d896 1
a896 1
	default:
@


1.9
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d13 1
a13 1
 *    notice, this list of conditions and the following disclaimer. 
d68 1
d70 8
a77 9
static const UI_METHOD *default_UI_meth=NULL;

UI *UI_new(void)
	{
	return(UI_new_method(NULL));
	}

UI *UI_new_method(const UI_METHOD *method)
	{
d80 3
a82 4
	ret=(UI *)malloc(sizeof(UI));
	if (ret == NULL)
		{
		UIerr(UI_F_UI_NEW_METHOD,ERR_R_MALLOC_FAILURE);
d84 1
a84 1
		}
d86 1
a86 1
		ret->meth=UI_get_default_method();
d88 1
a88 1
		ret->meth=method;
d90 3
a92 3
	ret->strings=NULL;
	ret->user_data=NULL;
	ret->flags=0;
d95 1
a95 1
	}
d97 6
a102 7
static void free_string(UI_STRING *uis)
	{
	if (uis->flags & OUT_STRING_FREEABLE)
		{
		free((char *)uis->out_string);
		switch(uis->type)
			{
d104 3
a106 3
			free((char *)uis->_.boolean_data.action_desc);
			free((char *)uis->_.boolean_data.ok_chars);
			free((char *)uis->_.boolean_data.cancel_chars);
a109 1
			}
d111 1
d113 1
a113 1
	}
d115 3
a117 2
void UI_free(UI *ui)
	{
d120 1
a120 1
	sk_UI_STRING_pop_free(ui->strings,free_string);
d123 1
a123 1
	}
d125 6
a130 7
static int allocate_string_stack(UI *ui)
	{
	if (ui->strings == NULL)
		{
		ui->strings=sk_UI_STRING_new_null();
		if (ui->strings == NULL)
			{
a131 1
			}
d133 1
d135 1
a135 1
	}
d137 5
a141 4
static UI_STRING *general_allocate_prompt(UI *ui, const char *prompt,
	int prompt_freeable, enum UI_string_types type, int input_flags,
	char *result_buf)
	{
d144 12
a155 17
	if (prompt == NULL)
		{
		UIerr(UI_F_GENERAL_ALLOCATE_PROMPT,ERR_R_PASSED_NULL_PARAMETER);
		}
	else if ((type == UIT_PROMPT || type == UIT_VERIFY
			 || type == UIT_BOOLEAN) && result_buf == NULL)
		{
		UIerr(UI_F_GENERAL_ALLOCATE_PROMPT,UI_R_NO_RESULT_BUFFER);
		}
	else if ((ret = (UI_STRING *)malloc(sizeof(UI_STRING))))
		{
		ret->out_string=prompt;
		ret->flags=prompt_freeable ? OUT_STRING_FREEABLE : 0;
		ret->input_flags=input_flags;
		ret->type=type;
		ret->result_buf=result_buf;
		}
d157 1
a157 1
	}
d159 5
a163 4
static int general_allocate_string(UI *ui, const char *prompt,
	int prompt_freeable, enum UI_string_types type, int input_flags,
	char *result_buf, int minsize, int maxsize, const char *test_buf)
	{
d166 1
a166 1
		type, input_flags, result_buf);
d168 6
a173 8
	if (s)
		{
		if (allocate_string_stack(ui) >= 0)
			{
			s->_.string_data.result_minsize=minsize;
			s->_.string_data.result_maxsize=maxsize;
			s->_.string_data.test_buf=test_buf;
			ret=sk_UI_STRING_push(ui->strings, s);
d175 3
a177 3
			if (ret <= 0) ret--;
			}
		else
d179 1
a179 1
		}
d181 1
a181 1
	}
d183 7
a189 6
static int general_allocate_boolean(UI *ui,
	const char *prompt, const char *action_desc,
	const char *ok_chars, const char *cancel_chars,
	int prompt_freeable, enum UI_string_types type, int input_flags,
	char *result_buf)
	{
d194 7
a200 14
	if (ok_chars == NULL)
		{
		UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,ERR_R_PASSED_NULL_PARAMETER);
		}
	else if (cancel_chars == NULL)
		{
		UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,ERR_R_PASSED_NULL_PARAMETER);
		}
	else
		{
		for(p = ok_chars; *p; p++)
			{
			if (strchr(cancel_chars, *p))
				{
d202 1
a202 2
					UI_R_COMMON_OK_AND_CANCEL_CHARACTERS);
				}
d204 1
d207 1
a207 1
			type, input_flags, result_buf);
d209 2
a210 4
		if (s)
			{
			if (allocate_string_stack(ui) >= 0)
				{
d214 8
a221 6
				ret=sk_UI_STRING_push(ui->strings, s);
				/* sk_push() returns 0 on error.
				   Let's addapt that */
				if (ret <= 0) ret--;
				}
			else
a222 1
			}
d224 1
d226 1
a226 1
	}
d230 4
a233 3
int UI_add_input_string(UI *ui, const char *prompt, int flags,
	char *result_buf, int minsize, int maxsize)
	{
d235 2
a236 2
		UIT_PROMPT, flags, result_buf, minsize, maxsize, NULL);
	}
d239 5
a243 4
int UI_dup_input_string(UI *ui, const char *prompt, int flags,
	char *result_buf, int minsize, int maxsize)
	{
	char *prompt_copy=NULL;
d245 4
a248 6
	if (prompt)
		{
		prompt_copy=BUF_strdup(prompt);
		if (prompt_copy == NULL)
			{
			UIerr(UI_F_UI_DUP_INPUT_STRING,ERR_R_MALLOC_FAILURE);
a249 1
			}
d251 1
a251 1
	
d253 2
a254 2
		UIT_PROMPT, flags, result_buf, minsize, maxsize, NULL);
	}
d256 4
a259 3
int UI_add_verify_string(UI *ui, const char *prompt, int flags,
	char *result_buf, int minsize, int maxsize, const char *test_buf)
	{
d261 2
a262 2
		UIT_VERIFY, flags, result_buf, minsize, maxsize, test_buf);
	}
d264 5
a268 4
int UI_dup_verify_string(UI *ui, const char *prompt, int flags,
	char *result_buf, int minsize, int maxsize, const char *test_buf)
	{
	char *prompt_copy=NULL;
d270 4
a273 6
	if (prompt)
		{
		prompt_copy=BUF_strdup(prompt);
		if (prompt_copy == NULL)
			{
			UIerr(UI_F_UI_DUP_VERIFY_STRING,ERR_R_MALLOC_FAILURE);
a274 1
			}
d276 1
a276 1
	
d278 2
a279 2
		UIT_VERIFY, flags, result_buf, minsize, maxsize, test_buf);
	}
d281 5
a285 4
int UI_add_input_boolean(UI *ui, const char *prompt, const char *action_desc,
	const char *ok_chars, const char *cancel_chars,
	int flags, char *result_buf)
	{
d287 2
a288 2
		ok_chars, cancel_chars, 0, UIT_BOOLEAN, flags, result_buf);
	}
d290 5
a294 4
int UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,
	const char *ok_chars, const char *cancel_chars,
	int flags, char *result_buf)
	{
d300 4
a303 6
	if (prompt)
		{
		prompt_copy=BUF_strdup(prompt);
		if (prompt_copy == NULL)
			{
			UIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);
a304 1
			}
d306 5
a310 7
	
	if (action_desc)
		{
		action_desc_copy=BUF_strdup(action_desc);
		if (action_desc_copy == NULL)
			{
			UIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);
a311 1
			}
d313 5
a317 7
	
	if (ok_chars)
		{
		ok_chars_copy=BUF_strdup(ok_chars);
		if (ok_chars_copy == NULL)
			{
			UIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);
a318 1
			}
d320 5
a324 7
	
	if (cancel_chars)
		{
		cancel_chars_copy=BUF_strdup(cancel_chars);
		if (cancel_chars_copy == NULL)
			{
			UIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);
a325 1
			}
d327 1
a327 1
	
d329 11
a339 7
		ok_chars_copy, cancel_chars_copy, 1, UIT_BOOLEAN, flags,
		result_buf);
 err:
	if (prompt_copy) free(prompt_copy);
	if (action_desc_copy) free(action_desc_copy);
	if (ok_chars_copy) free(ok_chars_copy);
	if (cancel_chars_copy) free(cancel_chars_copy);
d341 1
a341 1
	}
d343 3
a345 2
int UI_add_info_string(UI *ui, const char *text)
	{
d347 2
a348 2
		NULL);
	}
d350 9
a358 10
int UI_dup_info_string(UI *ui, const char *text)
	{
	char *text_copy=NULL;

	if (text)
		{
		text_copy=BUF_strdup(text);
		if (text_copy == NULL)
			{
			UIerr(UI_F_UI_DUP_INFO_STRING,ERR_R_MALLOC_FAILURE);
a359 1
			}
d361 1
a361 1

d363 2
a364 2
		0, 0, NULL);
	}
d366 3
a368 2
int UI_add_error_string(UI *ui, const char *text)
	{
d370 2
a371 6
		NULL);
	}

int UI_dup_error_string(UI *ui, const char *text)
	{
	char *text_copy=NULL;
d373 9
a381 6
	if (text)
		{
		text_copy=BUF_strdup(text);
		if (text_copy == NULL)
			{
			UIerr(UI_F_UI_DUP_ERROR_STRING,ERR_R_MALLOC_FAILURE);
a382 1
			}
d384 1
d386 2
a387 2
		0, 0, NULL);
	}
d389 4
a392 3
char *UI_construct_prompt(UI *ui, const char *object_desc,
	const char *object_name)
	{
d397 2
a398 3
			object_desc, object_name);
	else
		{
d411 1
a411 1
		prompt = (char *)malloc(len + 1);
d414 1
a414 2
		if (object_name)
			{
d417 1
a417 1
			}
d419 1
a419 1
		}
d421 1
a421 1
	}
d423 3
a425 2
void *UI_add_user_data(UI *ui, void *user_data)
	{
d429 1
a429 1
	}
d431 3
a433 2
void *UI_get0_user_data(UI *ui)
	{
d435 1
a435 1
	}
d437 5
a441 5
const char *UI_get0_result(UI *ui, int i)
	{
	if (i < 0)
		{
		UIerr(UI_F_UI_GET0_RESULT,UI_R_INDEX_TOO_SMALL);
d443 3
a445 4
		}
	if (i >= sk_UI_STRING_num(ui->strings))
		{
		UIerr(UI_F_UI_GET0_RESULT,UI_R_INDEX_TOO_LARGE);
d447 1
a447 1
		}
d449 1
a449 1
	}
d451 3
a453 2
static int print_error(const char *str, size_t len, UI *ui)
	{
d461 1
a461 1
		&& !ui->meth->ui_write_string(ui, &uis))
d464 1
a464 1
	}
d466 4
a469 3
int UI_process(UI *ui)
	{
	int i, ok=0;
d476 2
a477 2
			(int (*)(const char *, size_t, void *))print_error,
			(void *)ui);
d479 1
a479 2
	for(i=0; i<sk_UI_STRING_num(ui->strings); i++)
		{
d481 3
a483 4
			&& !ui->meth->ui_write_string(ui,
				sk_UI_STRING_value(ui->strings, i)))
			{
			ok=-1;
a484 1
			}
d486 1
d489 2
a490 3
		switch(ui->meth->ui_flush(ui))
			{
		case -1: /* Interrupt/Cancel/something... */
d493 1
a493 1
		case 0: /* Errors */
d496 1
a496 1
		default: /* Success */
d499 1
a499 1
			}
d501 5
a505 8
	for(i=0; i<sk_UI_STRING_num(ui->strings); i++)
		{
		if (ui->meth->ui_read_string)
			{
			switch(ui->meth->ui_read_string(ui,
				sk_UI_STRING_value(ui->strings, i)))
				{
			case -1: /* Interrupt/Cancel/something... */
d508 1
a508 1
			case 0: /* Errors */
d511 1
a511 1
			default: /* Success */
a513 1
				}
d516 2
a517 1
 err:
d521 1
a521 1
	}
d523 5
a527 5
int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)(void))
	{
	if (ui == NULL)
		{
		UIerr(UI_F_UI_CTRL,ERR_R_PASSED_NULL_PARAMETER);
d529 2
a530 3
		}
	switch(cmd)
		{
d533 6
a538 6
		int save_flag = !!(ui->flags & UI_FLAG_PRINT_ERRORS);
		if (i)
			ui->flags |= UI_FLAG_PRINT_ERRORS;
		else
			ui->flags &= ~UI_FLAG_PRINT_ERRORS;
		return save_flag;
d544 2
a545 2
		}
	UIerr(UI_F_UI_CTRL,UI_R_UNKNOWN_CONTROL_COMMAND);
d547 1
a547 1
	}
d549 4
a552 3
int UI_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
        {
d554 2
a555 12
				new_func, dup_func, free_func);
        }

int UI_set_ex_data(UI *r, int idx, void *arg)
	{
	return(CRYPTO_set_ex_data(&r->ex_data,idx,arg));
	}

void *UI_get_ex_data(UI *r, int idx)
	{
	return(CRYPTO_get_ex_data(&r->ex_data,idx));
	}
d557 23
a579 3
void UI_set_default_method(const UI_METHOD *meth)
	{
	default_UI_meth=meth;
a580 7

const UI_METHOD *UI_get_default_method(void)
	{
	if (default_UI_meth == NULL)
		{
		default_UI_meth=UI_OpenSSL();
		}
d582 1
a582 1
	}
d584 3
a586 2
const UI_METHOD *UI_get_method(UI *ui)
	{
d588 1
a588 1
	}
d590 4
a593 3
const UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth)
	{
	ui->meth=meth;
d595 1
a595 1
	}
d598 4
a601 3
UI_METHOD *UI_create_method(char *name)
	{
	UI_METHOD *ui_method = (UI_METHOD *)malloc(sizeof(UI_METHOD));
d603 1
a603 2
	if (ui_method)
		{
d606 1
a606 1
		}
d608 1
a608 1
	}
d613 3
a615 2
void UI_destroy_method(UI_METHOD *ui_method)
	{
d619 1
a619 1
	}
d621 4
a624 4
int UI_method_set_opener(UI_METHOD *method, int (*opener)(UI *ui))
	{
	if (method)
		{
d627 1
a627 2
		}
	else
d629 1
a629 1
	}
d631 4
a634 4
int UI_method_set_writer(UI_METHOD *method, int (*writer)(UI *ui, UI_STRING *uis))
	{
	if (method)
		{
d637 1
a637 2
		}
	else
d639 1
a639 1
	}
d641 4
a644 4
int UI_method_set_flusher(UI_METHOD *method, int (*flusher)(UI *ui))
	{
	if (method)
		{
d647 1
a647 2
		}
	else
d649 1
a649 1
	}
d651 4
a654 4
int UI_method_set_reader(UI_METHOD *method, int (*reader)(UI *ui, UI_STRING *uis))
	{
	if (method)
		{
d657 1
a657 2
		}
	else
d659 1
a659 1
	}
d661 4
a664 4
int UI_method_set_closer(UI_METHOD *method, int (*closer)(UI *ui))
	{
	if (method)
		{
d667 1
a667 2
		}
	else
d669 1
a669 1
	}
d671 4
a674 4
int UI_method_set_prompt_constructor(UI_METHOD *method, char *(*prompt_constructor)(UI* ui, const char* object_desc, const char* object_name))
	{
	if (method)
		{
d677 1
a677 2
		}
	else
d679 1
a679 1
	}
d681 3
a683 2
int (*UI_method_get_opener(UI_METHOD *method))(UI*)
	{
d688 1
a688 1
	}
d690 3
a692 2
int (*UI_method_get_writer(UI_METHOD *method))(UI*,UI_STRING*)
	{
d697 1
a697 1
	}
d699 3
a701 2
int (*UI_method_get_flusher(UI_METHOD *method))(UI*)
	{
d706 1
a706 1
	}
d708 3
a710 2
int (*UI_method_get_reader(UI_METHOD *method))(UI*,UI_STRING*)
	{
d715 1
a715 1
	}
d717 3
a719 2
int (*UI_method_get_closer(UI_METHOD *method))(UI*)
	{
d724 1
a724 1
	}
d726 3
a728 2
char* (*UI_method_get_prompt_constructor(UI_METHOD *method))(UI*, const char*, const char*)
	{
d733 1
a733 1
	}
d735 3
a737 2
enum UI_string_types UI_get_string_type(UI_STRING *uis)
	{
d741 1
a741 1
	}
d743 3
a745 2
int UI_get_input_flags(UI_STRING *uis)
	{
d749 1
a749 1
	}
d751 3
a753 2
const char *UI_get0_output_string(UI_STRING *uis)
	{
d757 1
a757 1
	}
d759 3
a761 2
const char *UI_get0_action_string(UI_STRING *uis)
	{
d764 1
a764 2
	switch(uis->type)
		{
a769 1
		}
d771 1
d773 3
a775 2
const char *UI_get0_result_string(UI_STRING *uis)
	{
d778 1
a778 2
	switch(uis->type)
		{
a783 1
		}
d785 1
d787 3
a789 2
const char *UI_get0_test_string(UI_STRING *uis)
	{
d792 1
a792 2
	switch(uis->type)
		{
a796 1
		}
d798 1
d800 3
a802 2
int UI_get_result_minsize(UI_STRING *uis)
	{
d805 1
a805 2
	switch(uis->type)
		{
a810 1
		}
d812 1
d814 3
a816 2
int UI_get_result_maxsize(UI_STRING *uis)
	{
d819 1
a819 2
	switch(uis->type)
		{
a824 1
		}
d826 1
d828 3
a830 2
int UI_set_result(UI *ui, UI_STRING *uis, const char *result)
	{
d837 1
a837 2
	switch (uis->type)
		{
d841 2
a842 2
		char number1[DECIMAL_SIZE(uis->_.string_data.result_minsize)+1];
		char number2[DECIMAL_SIZE(uis->_.string_data.result_maxsize)+1];
d844 18
a861 20
		(void) snprintf(number1, sizeof(number1), "%d",
			uis->_.string_data.result_minsize);
		(void) snprintf(number2, sizeof(number2), "%d",
			uis->_.string_data.result_maxsize);

		if (l < uis->_.string_data.result_minsize)
			{
			ui->flags |= UI_FLAG_REDOABLE;
			UIerr(UI_F_UI_SET_RESULT,UI_R_RESULT_TOO_SMALL);
			ERR_add_error_data(5,"You must type in ",
				number1," to ",number2," characters");
			return -1;
			}
		if (l > uis->_.string_data.result_maxsize)
			{
			ui->flags |= UI_FLAG_REDOABLE;
			UIerr(UI_F_UI_SET_RESULT,UI_R_RESULT_TOO_LARGE);
			ERR_add_error_data(5,"You must type in ",
				number1," to ",number2," characters");
			return -1;
d865 2
a866 3
		if (!uis->result_buf)
			{
			UIerr(UI_F_UI_SET_RESULT,UI_R_NO_RESULT_BUFFER);
d868 1
a868 2
			}

d870 1
a870 1
			    uis->_.string_data.result_maxsize + 1);
d874 1
a874 7
		const char *p;

		if (!uis->result_buf)
			{
			UIerr(UI_F_UI_SET_RESULT,UI_R_NO_RESULT_BUFFER);
			return -1;
			}
d876 10
a885 8
		uis->result_buf[0] = '\0';
		for(p = result; *p; p++)
			{
			if (strchr(uis->_.boolean_data.ok_chars, *p))
				{
				uis->result_buf[0] =
					uis->_.boolean_data.ok_chars[0];
				break;
d887 4
a890 5
			if (strchr(uis->_.boolean_data.cancel_chars, *p))
				{
				uis->result_buf[0] =
					uis->_.boolean_data.cancel_chars[0];
				break;
d894 1
a894 2
		break;
		}
d896 1
d898 1
a898 1
	}
@


1.8
log
@Part 1 of eliminating BIO_snprintf(). This fixes mechanical conversions
where the return value is ignored changing to (void) snprintf.
ok deraadt@@
@
text
@d80 1
a80 1
	ret=(UI *)OPENSSL_malloc(sizeof(UI));
d102 1
a102 1
		OPENSSL_free((char *)uis->out_string);
d106 3
a108 3
			OPENSSL_free((char *)uis->_.boolean_data.action_desc);
			OPENSSL_free((char *)uis->_.boolean_data.ok_chars);
			OPENSSL_free((char *)uis->_.boolean_data.cancel_chars);
d114 1
a114 1
	OPENSSL_free(uis);
d123 1
a123 1
	OPENSSL_free(ui);
d154 1
a154 1
	else if ((ret = (UI_STRING *)OPENSSL_malloc(sizeof(UI_STRING))))
d357 4
a360 4
	if (prompt_copy) OPENSSL_free(prompt_copy);
	if (action_desc_copy) OPENSSL_free(action_desc_copy);
	if (ok_chars_copy) OPENSSL_free(ok_chars_copy);
	if (cancel_chars_copy) OPENSSL_free(cancel_chars_copy);
d433 1
a433 1
		prompt = (char *)OPENSSL_malloc(len + 1);
d621 1
a621 1
	UI_METHOD *ui_method = (UI_METHOD *)OPENSSL_malloc(sizeof(UI_METHOD));
d636 1
a636 1
	OPENSSL_free(ui_method->name);
d638 1
a638 1
	OPENSSL_free(ui_method);
@


1.7
log
@resolve conflicts, fix local changes
@
text
@d861 1
a861 1
		BIO_snprintf(number1, sizeof(number1), "%d",
d863 1
a863 1
		BIO_snprintf(number2, sizeof(number2), "%d",
@


1.6
log
@resolve conflicts
@
text
@d696 11
d743 8
@


1.5
log
@resolve conflicts
@
text
@d93 1
@


1.4
log
@merge 0.9.7d
@
text
@d60 1
a65 1
#include "cryptlib.h"
d548 1
a548 1
int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)())
d623 1
d625 2
a626 1
	ui_method->name = BUF_strdup(name);
@


1.3
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d433 2
a434 2
		strlcpy(prompt, prompt1, len + 1);
		strlcat(prompt, object_desc, len + 1);
d437 2
a438 2
			strlcat(prompt, prompt2, len + 1);
			strlcat(prompt, object_name, len + 1);
d440 1
a440 1
		strlcat(prompt, prompt3, len + 1);
d868 2
a869 2
		strlcpy(uis->result_buf, result,
			uis->_.string_data.result_maxsize + 1);
@


1.2
log
@Less strcpy/strcat/sprintf. tdeval@@ ok.
@
text
@d65 1
d148 2
a149 1
	else if (result_buf == NULL)
d240 1
a240 1
/* Returns the index to the place in the stack or 0 for error.  Uses a
d836 2
a837 2
		char number1[20];
		char number2[20];
@


1.1
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d431 2
a432 2
		strcpy(prompt, prompt1);
		strcat(prompt, object_desc);
d435 2
a436 2
			strcat(prompt, prompt2);
			strcat(prompt, object_name);
d438 1
a438 1
		strcat(prompt, prompt3);
d866 2
a867 1
		strcpy(uis->result_buf, result);
@


1.1.1.1
log
@import openssl-0.9.7-beta1
@
text
@@


1.1.1.2
log
@import 0.9.7b (without idea and rc5)
@
text
@a64 1
#include "cryptlib.h"
d147 1
a147 2
	else if ((type == UIT_PROMPT || type == UIT_VERIFY
			 || type == UIT_BOOLEAN) && result_buf == NULL)
d238 1
a238 1
/* Returns the index to the place in the stack or -1 for error.  Uses a
d834 2
a835 2
		char number1[DECIMAL_SIZE(uis->_.string_data.result_minsize)+1];
		char number2[DECIMAL_SIZE(uis->_.string_data.result_maxsize)+1];
@


1.1.1.3
log
@import openssl-0.9.7d
@
text
@d433 2
a434 2
		BUF_strlcpy(prompt, prompt1, len + 1);
		BUF_strlcat(prompt, object_desc, len + 1);
d437 2
a438 2
			BUF_strlcat(prompt, prompt2, len + 1);
			BUF_strlcat(prompt, object_name, len + 1);
d440 1
a440 1
		BUF_strlcat(prompt, prompt3, len + 1);
d868 1
a868 2
		BUF_strlcpy(uis->result_buf, result,
			    uis->_.string_data.result_maxsize + 1);
@


1.1.1.4
log
@import of OpenSSL 0.9.8h
@
text
@a59 1
#include "cryptlib.h"
d65 1
d548 1
a548 1
int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)(void))
a622 1
		{
d624 1
a624 2
		ui_method->name = BUF_strdup(name);
		}
@


1.1.1.5
log
@import of OpenSSL 0.9.8k
@
text
@a92 1
	ret->flags=0;
@


1.1.1.6
log
@import OpenSSL-1.0.0a
@
text
@a695 11
int UI_method_set_prompt_constructor(UI_METHOD *method, char *(*prompt_constructor)(UI* ui, const char* object_desc, const char* object_name))
	{
	if (method)
		{
		method->ui_construct_prompt = prompt_constructor;
		return 0;
		}
	else
		return -1;
	}

a731 8
	else
		return NULL;
	}

char* (*UI_method_get_prompt_constructor(UI_METHOD *method))(UI*, const char*, const char*)
	{
	if (method)
		return method->ui_construct_prompt;
@


