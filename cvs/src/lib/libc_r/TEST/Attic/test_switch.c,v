head	1.8;
access;
symbols
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2001.08.15.14.43.15;	author fgsch;	state dead;
branches;
next	1.7;

1.7
date	2000.10.04.05.50.58;	author d;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.06.06.58.35;	author d;	state Exp;
branches;
next	1.5;

1.5
date	99.11.30.00.55.13;	author d;	state Exp;
branches;
next	1.4;

1.4
date	99.03.10.09.23.55;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.10.22.57.11;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.12.10.00.31.39;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.09.03.11.04.47;	author d;	state Exp;
branches;
next	;


desc
@@


1.8
log
@TEST has moved to regress/lib/libc_r.
@
text
@/*	$OpenBSD: test_switch.c,v 1.7 2000/10/04 05:50:58 d Exp $	*/
/* ==== test_switch.c ========================================================
 * Copyright (c) 1993 by Chris Provenzano, proven@@athena.mit.edu
 *
 * Description : Test context switch functionality.
 *
 *  1.00 93/08/04 proven
 *      -Started coding this file.
 */

#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include "test.h"

const char buf[] = "abcdefghijklmnopqrstuvwxyz";
char x[sizeof(buf)];
int fd = 1;

volatile int ending = 0;

/* ==========================================================================
 * usage();
 */
void usage(void)
{
    printf("test_switch [-d?] [-c count]\n");
	printf("count must be between 2 and 26\n");
    errno = 0;
}

void *
new_thread(arg)
	void *arg;
{
	SET_NAME("writer");
	while (!ending) {
		CHECKe(write (fd, (char *) arg, 1));
		x[(char *)arg - buf] = 1;
	}
	return NULL;
}

int
main(argc, argv)
	int argc;
	char **argv;
{
	pthread_t thread;
	int count = 4;
	int debug = 0;
	int eof = 0;
	long i;

	/* Getopt variables. */
	extern int optind, opterr;
	extern char *optarg;

	while (!eof)
	  switch (getopt (argc, argv, "c:d?"))
	    {
	    case EOF:
	      eof = 1;
	      break;
	    case 'd':
	      debug++;
	      break;
	    case 'c':
	      count = atoi(optarg);
	      if ((count > 26) || (count < 2)) {
			  count = 2;
	      }
	      break;
	    case '?':
	      usage();
	      return(OK);
	    default:
	      usage();
	      return(NOTOK);
	    }

	/* create the threads */
	for (i = 0; i < count; i++)
		CHECKr(pthread_create(&thread, NULL, new_thread, 
		    (void*)(buf+i)));

	/* give all threads a chance to run */
	sleep (4);

	ending = 1;
	for (i = 0; i < count; i++)
		ASSERT(x[i]);	/* make sure each thread ran */

	SUCCEED;
}
@


1.7
log
@bit of a cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: test_switch.c,v 1.6 2000/01/06 06:58:35 d Exp $	*/
@


1.6
log
@ident, clean
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d22 2
d39 1
a39 1
	while(1) {
d43 1
a43 1
	PANIC("while");
d92 1
@


1.5
log
@make test a little bit more stressful
@
text
@d1 1
@


1.4
log
@define and use a SET_NAME macro so that these tests work under other thread implementations
@
text
@d49 1
a49 1
	int count = 2;
d87 1
a87 1
	sleep (6);
@


1.3
log
@nice-ify
@
text
@d35 1
d87 1
a87 1
	sleep (2);
@


1.2
log
@tests are now useful
@
text
@d1 1
a1 1
/* ==== test_switch.c ============================================================
d31 3
a33 1
void* new_thread(void* arg)
d36 1
a36 1
		write (fd, (char *) arg, 1);
d39 1
a39 2
	fprintf(stderr, "Compiler error\n");
	exit(1);
d43 3
a45 1
main(int argc, char **argv)
d80 6
a85 6
	for (i = 0; i < count; i++) {
		if (pthread_create(&thread, NULL, new_thread, (void*)(buf+i))) {
			fprintf (stderr, "error creating new thread %ld\n", i);
			exit (1);
		}
	}
d87 1
d89 3
a91 6
		if (x[i] == 0) {
			fprintf (stderr, "thread %ld never ran\n", i);
			return 1;
		}
	printf ("\n%s PASSED\n", argv[0]);
	return 0;
@


1.1
log
@libpthread tests modified for uthreads
@
text
@d83 1
a83 7
#if 0 /* This would cause the program to loop forever, and "make
		 check" would never complete.  */
	pthread_exit (NULL);
	fprintf(stderr, "pthread_exit returned\n");
	exit(1);
#else
	sleep (3);
a90 1
#endif
@

