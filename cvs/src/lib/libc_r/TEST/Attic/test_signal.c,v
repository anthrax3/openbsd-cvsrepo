head	1.5;
access;
symbols
	OPENBSD_2_9:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2001.08.15.14.43.15;	author fgsch;	state dead;
branches;
next	1.4;

1.4
date	2001.08.12.12.05.45;	author d;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.04.05.50.58;	author d;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.07.02.00.04;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2000.01.04.00.17.46;	author d;	state Exp;
branches;
next	;


desc
@@


1.5
log
@TEST has moved to regress/lib/libc_r.
@
text
@/* $OpenBSD: test_signal.c,v 1.4 2001/08/12 12:05:45 d Exp $ */
/* David Leonard <d@@openbsd.org>, 2001. Public Domain. */

/*
 * This program tests signal handler re-entrancy.
 */

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include "test.h"

void *
sleeper(arg)
	void *arg;
{
	sigset_t mask;

	/* Ignore all signals in this thread */
	sigfillset(&mask);
	CHECKe(sigprocmask(SIG_SETMASK, &mask, NULL));

	ASSERT(sleep(2) == 0);
	SUCCEED;
}

void
handler(sig)
	int sig;
{
	printf("signal handler %d\n", sig);
	alarm(1);
	signal(SIGALRM, handler);
}

int
main()
{
	pthread_t slpr;

	ASSERT(signal(SIGALRM, handler) != SIG_ERR);
	CHECKe(alarm(1));
	CHECKr(pthread_create(&slpr, NULL, sleeper, NULL));
	/* ASSERT(sleep(1) == 0); */
	for (;;)
		CHECKe(write(STDOUT_FILENO, ".", 1));
}
@


1.4
log
@public domain
@
text
@d1 1
a1 1
/* $OpenBSD: test_signal.c,v 1.3 2000/10/04 05:50:58 d Exp $ */
@


1.3
log
@bit of a cleanup
@
text
@d1 2
a2 1
/* $OpenBSD: test_signal.c,v 1.2 2000/08/07 02:00:04 brad Exp $ */
@


1.2
log
@quiet warning
@
text
@d1 1
a1 1
/* $OpenBSD: test_signal.c,v 1.1 2000/01/04 00:17:46 d Exp $ */
d24 1
a24 1
	ASSERT(sleep(10) == 0);
d40 1
a40 1
	/* pthread_t slpr; */
d44 1
a44 1
	/* CHECKr(pthread_create(&slpr, NULL, sleeper, NULL)); */
@


1.1
log
@Test some signal handling
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d40 1
a40 1
	pthread_t slpr;
@

