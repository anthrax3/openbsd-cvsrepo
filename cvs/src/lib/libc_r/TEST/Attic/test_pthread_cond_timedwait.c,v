head	1.4;
access;
symbols
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2001.08.15.14.43.15;	author fgsch;	state dead;
branches;
next	1.3;

1.3
date	2000.01.06.06.58.34;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.10.22.57.08;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.09.03.11.04.46;	author d;	state Exp;
branches;
next	;


desc
@@


1.4
log
@TEST has moved to regress/lib/libc_r.
@
text
@/*	$OpenBSD: test_pthread_cond_timedwait.c,v 1.3 2000/01/06 06:58:34 d Exp $	*/
/* ==== test_pthread_cond.c =========================================
 * Copyright (c) 1993 by Chris Provenzano, proven@@athena.mit.edu
 *
 * Description : Test pthread_cond(). Run this after test_create()
 *
 *  1.23 94/05/04 proven
 *      -Started coding this file.
 */

#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include "test.h"

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

void* thread_1(void * new_buf)
{
	CHECKr(pthread_mutex_lock(&mutex));
	CHECKr(pthread_cond_signal(&cond));
	CHECKr(pthread_mutex_unlock(&mutex));
	pthread_exit(NULL);
}

void* thread_2(void * new_buf)
{
	sleep(1);
	CHECKr(pthread_mutex_lock(&mutex));
	CHECKr(pthread_cond_signal(&cond));
	CHECKr(pthread_mutex_unlock(&mutex));
	pthread_exit(NULL);
}

int
main()
{
	struct timespec abstime = { 0, 0 };
	struct timeval curtime;
	pthread_t thread;
	int ret;

	printf("pthread_cond_timedwait START\n");

	CHECKr(pthread_mutex_lock(&mutex));
	CHECKe(gettimeofday(&curtime, NULL));
	abstime.tv_sec = curtime.tv_sec + 5; 

	/* Test a condition timeout */
	switch((ret = pthread_cond_timedwait(&cond, &mutex, &abstime))) {
	case 0:
		PANIC("pthread_cond_timedwait #0 failed to timeout");
		/* NOTREACHED */
	case ETIMEDOUT:
		/* expected behaviour */
		printf("Got first timeout ok\n");	/* Added by monty */
		break;
	default:
		DIE(ret, "pthread_cond_timedwait");
		/* NOTREACHED */
	}

	/* Test a normal condition signal */
	CHECKr(pthread_create(&thread, NULL, thread_1, NULL));

	abstime.tv_sec = curtime.tv_sec + 10; 
	CHECKr(pthread_cond_timedwait(&cond, &mutex, &abstime));

	/* Test a normal condition signal after a sleep */
	CHECKr(pthread_create(&thread, NULL, thread_2, NULL));

	pthread_yield();

	abstime.tv_sec = curtime.tv_sec + 10; 
	CHECKr(pthread_cond_timedwait(&cond, &mutex, &abstime));

	SUCCEED;
}
@


1.3
log
@ident, clean
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@nice-ify
@
text
@d1 1
@


1.1
log
@libpthread tests modified for uthreads
@
text
@d14 1
a14 4

#ifndef ETIME
#define ETIME ETIMEDOUT  
#endif
d21 3
a23 3
	pthread_mutex_lock(&mutex);
	pthread_cond_signal(&cond);
	pthread_mutex_unlock(&mutex);
d30 3
a32 3
	pthread_mutex_lock(&mutex);
	pthread_cond_signal(&cond);
	pthread_mutex_unlock(&mutex);
d42 1
d46 2
a47 2
	pthread_mutex_lock(&mutex);
	gettimeofday(&curtime, NULL);
d51 11
a61 5
	if (pthread_cond_timedwait(&cond, &mutex, &abstime) != ETIME) {
		printf("pthread_cond_timedwait failed to timeout\n");
		printf("pthread_cond_timedwait FAILED\n");
		pthread_mutex_unlock(&mutex);
		exit(1);
d63 1
a63 1
	printf("Got first timeout ok\n");	/* Added by monty */
d65 1
a65 4
	if (pthread_create(&thread, NULL, thread_1, NULL)) {
		printf("pthread_create failed\n");
		exit(2);
	}
d68 1
a68 6
	if (pthread_cond_timedwait(&cond, &mutex, &abstime)) {
		printf("pthread_cond_timedwait #1 timedout\n");
		printf("pthread_cond_timedwait FAILED\n");
		pthread_mutex_unlock(&mutex);
		exit(1);
	}
d71 1
a71 4
	if (pthread_create(&thread, NULL, thread_2, NULL)) {
		printf("pthread_create failed\n");
		exit(2);
	}
d76 1
a76 6
	if (pthread_cond_timedwait(&cond, &mutex, &abstime)) {
		printf("pthread_cond_timedwait #2 timedout\n");
		printf("pthread_cond_timedwait FAILED\n");
		pthread_mutex_unlock(&mutex);
		exit(1);
	}
d78 1
a78 3
	printf("pthread_cond_timedwait PASSED\n");
	pthread_mutex_unlock(&mutex);
	exit(0);
@

