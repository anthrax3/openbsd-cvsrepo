head	1.8;
access;
symbols
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2001.08.15.14.43.15;	author fgsch;	state dead;
branches;
next	1.7;

1.7
date	2001.03.13.00.04.38;	author d;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.06.06.58.34;	author d;	state Exp;
branches;
next	1.5;

1.5
date	99.05.26.00.09.50;	author d;	state Exp;
branches;
next	1.4;

1.4
date	99.03.10.09.23.55;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.10.22.57.08;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.12.10.00.31.38;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.09.03.11.04.46;	author d;	state Exp;
branches;
next	;


desc
@@


1.8
log
@TEST has moved to regress/lib/libc_r.
@
text
@/*	$OpenBSD: test_pthread_mutex.c,v 1.7 2001/03/13 00:04:38 d Exp $	*/
/* ==== test_pthread_cond.c =========================================
 * Copyright (c) 1993 by Chris Provenzano, proven@@athena.mit.edu
 *
 * Description : Test pthread_mutex(). Run this after test_create()
 *
 *  1.23 94/05/04 proven
 *      -Started coding this file.
 */

#include <pthread.h>
#include <pthread_np.h>
#include <stdio.h>
#include "test.h"

int contention_variable;

void * 
thread_contention(arg)
	void *arg;
{
	pthread_mutex_t *mutex = arg;

	SET_NAME("cntntn");

	CHECKr(pthread_mutex_lock(mutex));
	ASSERT(contention_variable == 1);
	contention_variable = 2;
	CHECKr(pthread_mutex_unlock(mutex));
	pthread_exit(NULL);
}

void
test_contention_lock(mutex)
	pthread_mutex_t *mutex;
{
	pthread_t thread;

	printf("  test_contention_lock()\n");
	CHECKr(pthread_mutex_lock(mutex));
	contention_variable = 0;
	CHECKr(pthread_create(&thread, NULL, thread_contention, mutex));
	pthread_yield();
	contention_variable = 1;
	CHECKr(pthread_mutex_unlock(mutex));
	CHECKr(pthread_mutex_lock(mutex));
	ASSERT(contention_variable == 2);
	CHECKr(pthread_mutex_unlock(mutex));
}

void
test_nocontention_lock(mutex)
	pthread_mutex_t *mutex;
{
	printf("  test_nocontention_lock()\n");
	CHECKr(pthread_mutex_lock(mutex));
	CHECKr(pthread_mutex_unlock(mutex));
}

void
test_debug_double_lock(mutex)
	pthread_mutex_t *mutex;
{
	printf("  test_debug_double_lock()\n");
	CHECKr(pthread_mutex_lock(mutex));
	ASSERTe(pthread_mutex_lock(mutex), == EDEADLK);
	CHECKr(pthread_mutex_unlock(mutex));
}

void
test_debug_double_unlock(mutex)
	pthread_mutex_t *mutex;
{
	printf("  test_debug_double_unlock()\n");
	CHECKr(pthread_mutex_lock(mutex));
	CHECKr(pthread_mutex_unlock(mutex));
	/* Posix D10 says undefined behaviour? */
	ASSERTe(pthread_mutex_unlock(mutex), == EPERM);
}

void
test_nocontention_trylock(mutex)
	pthread_mutex_t *mutex;
{
	printf("  test_nocontention_trylock()\n");
	CHECKr(pthread_mutex_trylock(mutex));
	CHECKr(pthread_mutex_unlock(mutex));
}

void
test_mutex_static()
{
	pthread_mutex_t mutex_static = PTHREAD_MUTEX_INITIALIZER;

	printf("test_mutex_static()\n");
	test_nocontention_lock(&mutex_static);
	test_contention_lock(&mutex_static);
}

void
test_mutex_fast(void)
{
	pthread_mutex_t mutex_fast; 

	printf("test_mutex_fast()\n");
	CHECKr(pthread_mutex_init(&mutex_fast, NULL));
	test_nocontention_lock(&mutex_fast);
	test_contention_lock(&mutex_fast);
	CHECKr(pthread_mutex_destroy(&mutex_fast));
}

void
test_mutex_debug()
{
	pthread_mutexattr_t mutex_debug_attr; 
	pthread_mutex_t mutex_debug; 

	printf("test_mutex_debug()\n");
	CHECKr(pthread_mutexattr_init(&mutex_debug_attr));
	CHECKr(pthread_mutexattr_settype(&mutex_debug_attr, 
	    PTHREAD_MUTEX_ERRORCHECK));
	CHECKr(pthread_mutex_init(&mutex_debug, &mutex_debug_attr));
	test_nocontention_lock(&mutex_debug);
	test_contention_lock(&mutex_debug);
	test_debug_double_lock(&mutex_debug);
	test_debug_double_unlock(&mutex_debug);
	CHECKr(pthread_mutex_destroy(&mutex_debug));
}

void
test_mutex_recursive()
{
	pthread_mutexattr_t mutex_recursive_attr; 
	pthread_mutex_t mutex_recursive; 
	int i;

	printf("test_mutex_recursive()\n");
	CHECKr(pthread_mutexattr_init(&mutex_recursive_attr));
	CHECKr(pthread_mutexattr_settype(&mutex_recursive_attr, 
	    PTHREAD_MUTEX_RECURSIVE));
	CHECKr(pthread_mutex_init(&mutex_recursive, &mutex_recursive_attr));

	CHECKr(pthread_mutex_lock(&mutex_recursive));
	for (i = 0; i < 9; i++)
		CHECKr(pthread_mutex_lock(&mutex_recursive));
	for (i = 0; i < 9; i++)
		CHECKr(pthread_mutex_unlock(&mutex_recursive));
	CHECKr(pthread_mutex_unlock(&mutex_recursive));
	/* Posix D10 says undefined behaviour? */
	ASSERTe(pthread_mutex_unlock(&mutex_recursive), != 0);
}

int
main()
{
	test_mutex_static();
	test_mutex_fast();
	test_mutex_debug();
	test_mutex_recursive();
	SUCCEED;
}
@


1.7
log
@recursive mutex test
@
text
@d1 1
a1 1
/*	$OpenBSD: test_pthread_mutex.c,v 1.6 2000/01/06 06:58:34 d Exp $	*/
@


1.6
log
@ident, clean
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 23
d159 1
@


1.5
log
@document double-unlock check and how it relates to the std. (POSIX says in one paragraph that the behaviour is undefined, then in another says that EPERM should be returned
@
text
@d1 1
d5 1
a5 1
 * Description : Test pthread_cond(). Run this after test_create()
@


1.4
log
@define and use a SET_NAME macro so that these tests work under other thread implementations
@
text
@d76 1
@


1.3
log
@nice-ify
@
text
@d23 2
a41 1
	pthread_set_name_np(thread, "cntntn");
@


1.2
log
@tests are now useful
@
text
@a9 1
#include <errno.h>
d11 1
a14 1

d17 3
a19 1
void * thread_contention(void * arg)
d21 1
a21 1
	pthread_mutex_t * mutex = arg;
d23 2
a24 9
	if (pthread_mutex_lock(mutex)) {
		printf("pthread_mutex_lock() ERROR\n");
		pthread_exit(NULL);
	}

	if (contention_variable != 1) {
		printf("contention_variable != 1 ERROR\n");
		pthread_exit(NULL);
	}
d26 1
a26 5
	
	if (pthread_mutex_unlock(mutex)) {
		printf("pthread_mutex_unlock() ERROR\n");
		pthread_exit(NULL);
	}
d30 3
a32 1
int test_contention_lock(pthread_mutex_t * mutex)
d36 2
a37 6
	printf("test_contention_lock()\n");

	if (pthread_mutex_lock(mutex)) {
		printf("pthread_mutex_lock() ERROR\n");
		return(NOTOK);
	}
d39 9
d49 8
a56 4
	if (pthread_create(&thread, NULL, thread_contention, mutex)) {
		printf("pthread_create() FAILED\n");
		exit(2);
	}
d58 9
a66 1
	pthread_yield();
d68 9
a76 1
	contention_variable = 1;
d78 7
a84 91
	if (pthread_mutex_unlock(mutex)) {
		printf("pthread_mutex_unlock() ERROR\n");
		return(NOTOK);
	}

	if (pthread_mutex_lock(mutex)) {
		printf("pthread_mutex_lock() ERROR\n");
		return(NOTOK);
	}

	if (contention_variable != 2) {
		printf("contention_variable != 2 ERROR\n");
		return(NOTOK);
	}

	if (pthread_mutex_unlock(mutex)) {
		printf("pthread_mutex_unlock() ERROR\n");
		return(NOTOK);
	}

	return(OK);
}

int test_nocontention_lock(pthread_mutex_t * mutex)
{
	printf("test_nocontention_lock()\n");
	if (pthread_mutex_lock(mutex)) {
		printf("pthread_mutex_lock() ERROR\n");
		return(NOTOK);
	}
	if (pthread_mutex_unlock(mutex)) {
		printf("pthread_mutex_unlock() ERROR\n");
		return(NOTOK);
	}
	return(OK);
}

int test_debug_double_lock(pthread_mutex_t * mutex)
{
	int ret;

	printf("test_debug_double_lock()\n");
	if (pthread_mutex_lock(mutex)) {
		printf("pthread_mutex_lock() ERROR\n");
		return(NOTOK);
	}
	if ((ret = pthread_mutex_lock(mutex)) != EDEADLK) {
		DIE(ret, "test_debug_double_lock: pthread_mutex_lock");
		printf("double lock error not detected ERROR\n");
		return(NOTOK);
	}
	if (pthread_mutex_unlock(mutex)) {
		printf("pthread_mutex_unlock() ERROR\n");
		return(NOTOK);
	}
	return(OK);
}

int test_debug_double_unlock(pthread_mutex_t * mutex)
{
	int ret;

	printf("test_debug_double_unlock()\n");
	if (pthread_mutex_lock(mutex)) {
		printf("pthread_mutex_lock() ERROR\n");
		return(NOTOK);
	}
	if (pthread_mutex_unlock(mutex)) {
		printf("pthread_mutex_unlock() ERROR\n");
		return(NOTOK);
	}
	if ((ret = pthread_mutex_unlock(mutex)) != EPERM) {
		DIE(ret, "test_debug_double_unlock: mutex_unlock2");
		printf("double unlock error not detected ERROR\n");
		return(NOTOK);
	}
	return(OK);
}

int test_nocontention_trylock(pthread_mutex_t * mutex)
{
	printf("test_nocontention_trylock()\n");
	if (pthread_mutex_trylock(mutex)) {
		printf("pthread_mutex_trylock() ERROR\n");
		return(NOTOK);
	}
	if (pthread_mutex_unlock(mutex)) {
		printf("pthread_mutex_unlock() ERROR\n");
		return(NOTOK);
	}
	return(OK);
d87 2
a88 1
int test_mutex_static(void)
d93 2
a94 5
	if (test_nocontention_lock(&mutex_static) ||
	  test_contention_lock(&mutex_static)) {
		return(NOTOK);
	}
	return(OK);
d97 2
a98 1
int test_mutex_fast(void)
d103 4
a106 13
	if (pthread_mutex_init(&mutex_fast, NULL)) {
		printf("pthread_mutex_init() ERROR\n");
		return(NOTOK);
	}
	if (test_nocontention_lock(&mutex_fast) ||
	  test_contention_lock(&mutex_fast)) {
		return(NOTOK);
	}
	if (pthread_mutex_destroy(&mutex_fast)) {
		printf("pthread_mutex_destroy() ERROR\n");
		return(NOTOK);
	}
	return(OK);
d109 2
a110 1
int test_mutex_debug()
d116 9
a124 17
	pthread_mutexattr_init(&mutex_debug_attr);
	pthread_mutexattr_settype(&mutex_debug_attr, PTHREAD_MUTEX_ERRORCHECK);
	if (pthread_mutex_init(&mutex_debug, &mutex_debug_attr)) {
		printf("pthread_mutex_init() ERROR\n");
		return(NOTOK);
	}
	if (test_nocontention_lock(&mutex_debug) ||
	  test_contention_lock(&mutex_debug) ||
	  test_debug_double_lock(&mutex_debug) ||
	  test_debug_double_unlock(&mutex_debug)) {
		return(NOTOK);
	}
	if (pthread_mutex_destroy(&mutex_debug)) {
		printf("pthread_mutex_destroy() ERROR\n");
		return(NOTOK);
	}
	return(OK);
d130 4
a133 10

	printf("test_pthread_mutex START\n");

	if (test_mutex_static() || test_mutex_fast() || test_mutex_debug()) { 
		printf("test_pthread_mutex FAILED\n");
		exit(1);
	}

	printf("test_pthread_mutex PASSED\n");
	exit(0);
a134 1

@


1.1
log
@libpthread tests modified for uthreads
@
text
@d100 2
d107 2
a108 1
	if (pthread_mutex_lock(mutex) != EDEADLK) {
d121 2
d132 2
a133 1
	if (pthread_mutex_unlock(mutex) != EPERM) {
d193 1
a193 3
#if 0
	pthread_mutexattr_settype(&mutex_debug_attr, PTHREAD_MUTEXTYPE_DEBUG);
#endif
@

