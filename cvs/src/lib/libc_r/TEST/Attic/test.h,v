head	1.13;
access;
symbols
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2001.08.15.14.43.15;	author fgsch;	state dead;
branches;
next	1.12;

1.12
date	2001.08.12.12.03.01;	author heko;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.06.17.18.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.04.05.50.58;	author d;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.10.11.44.17;	author d;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.10.11.42.46;	author d;	state Exp;
branches;
next	1.7;

1.7
date	99.11.28.11.27.20;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.05.26.00.06.49;	author d;	state Exp;
branches;
next	1.5;

1.5
date	99.03.10.09.23.55;	author d;	state Exp;
branches;
next	1.4;

1.4
date	99.01.17.23.45.00;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.10.22.57.04;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.12.10.00.31.38;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.09.03.11.04.45;	author d;	state Exp;
branches;
next	;


desc
@@


1.13
log
@TEST has moved to regress/lib/libc_r.
@
text
@
#ifndef _h_test_
#define _h_test_

#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <string.h>
#include <stdarg.h>

int	_thread_sys_write __P((int, const char*, size_t));
__dead void _thread_sys__exit __P((int)) __attribute__((__noreturn__));

static __dead void __vpanic __P((const char *, const char *, const char *, 
	int, const char *, va_list)) __attribute__((__noreturn__));
static __dead void __panic __P((const char *, const char *, const char *,
	int, const char *, ...)) __attribute__((__noreturn__));

#if defined(__OpenBSD__) || defined(__FreeBSD__)
#include <pthread.h>
#include <pthread_np.h>
void	_thread_dump_info __P((void));
#define SET_NAME(x)	pthread_set_name_np(pthread_self(), x)
#define DUMP_INFO()	_thread_dump_info()
#else
#define SET_NAME(x)	/* nada */
#define DUMP_INFO()	/* nada */
#endif

static void
__vpanic(type, errstr, filenm, lineno, fmt, ap)
	const char *type; 
	const char *errstr;
	const char *filenm;
	int lineno; 
	const char *fmt; 
	va_list ap;
{
	char buf[1024];

	/* "<type> at <filenm>:<lineno>: <fmt ap...>:<errstr>" */
	snprintf(buf, sizeof buf, "%s at %s:%d\n", type, filenm, lineno);
	_thread_sys_write(2, buf, strlen(buf));
	vsnprintf(buf, sizeof buf, fmt, ap);
	if (errstr != NULL) {
		strlcat(buf, ": ", sizeof buf);
		strlcat(buf, errstr, sizeof buf);
	}
	strlcat(buf, "\n", sizeof buf);
	_thread_sys_write(2, buf, strlen(buf));

	DUMP_INFO();
	_thread_sys__exit(1);

	_thread_sys_write(2, "[locking]\n", 10);
	while(1);
}

static void
__panic(type, errstr, filenm, lineno, fmt)
	const char *type;
	const char *errstr;
	const char *filenm;
	int lineno; 
	const char *fmt;
{
	va_list ap;

	va_start(ap, fmt);
	__vpanic(type, errstr, filenm, lineno, fmt, ap);
	va_end(ap);
}

#define DIE(e, m, args...) \
	__panic("died", strerror(e), __FILE__, __LINE__, m , ## args)

#define PANIC(m, args...)  \
	__panic("panic", NULL, __FILE__, __LINE__, m, ## args)

#define ASSERT(x) do { \
	if (!(x)) \
		__panic("assert failed", NULL, __FILE__, __LINE__, "%s", #x); \
} while(0)

#define ASSERTe(x,rhs) do { \
	int _x; \
	_x = (x); \
	if (!(_x rhs)) { \
	    if (_x > 0) \
		__panic("assert failed", strerror(_x), __FILE__, __LINE__,  \
		    "%s %s", #x, #rhs); \
	    else \
		__panic("assert failed", NULL, __FILE__, __LINE__, \
		    "%s [=%d] %s", #x, _x, #rhs); \
	} \
} while(0)

#define _T(x) __builtin_classify_type(x)

#define _CHECK(x, rhs, efn) do { \
	typeof(x) _x; \
	_x = (x); \
	if (!(_x rhs)) \
		__panic("check failed", efn, __FILE__, __LINE__, \
		   ((_T(0) == _T(_x)   )? "failed check %s (=%d) %s " : \
		    (_T("") == _T(_x)  )? "failed check %s (=%s) %s " : \
		    (_T('x') == _T(_x) )? "failed check %s (=%c) %s " : \
		    (_T(0L) == _T(_x)  )? "failed check %s (=%ld) %s " : "?") \
		    , #x, _x, #rhs); \
} while(0)

#define CHECKr(x) _CHECK(x, == 0, strerror(_x))
#define CHECKe(x) _CHECK(x, != -1, strerror(errno))
#define CHECKn(x) _CHECK(x, != 0, strerror(errno))
#define CHECKhn(x) _CHECK(x, != 0, hstrerror(h_errno))

#define SUCCEED 	exit(0)

#define OK		(0)
#define NOTOK		(-1)

#endif /* _h_test_ */
@


1.12
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@@


1.11
log
@use __x__ formats for __attribute__ arguments; guenther@@gac.edu
@
text
@d122 1
a122 1
#endif _h_test_
@


1.10
log
@bit of a cleanup
@
text
@d12 1
a12 1
__dead void _thread_sys__exit __P((int)) __attribute__((noreturn));
d15 1
a15 1
	int, const char *, va_list)) __attribute__((noreturn));
d17 1
a17 1
	int, const char *, ...)) __attribute__((noreturn));
@


1.9
log
@oops
@
text
@d98 2
d101 2
a102 2
	int _x; \
	_x = (int)(x); \
d105 5
a109 1
		    "failed check %s (=%d) %s ", #x, _x, #rhs); \
@


1.8
log
@add DUMP_INFO helper macro
@
text
@d89 1
a89 1
	    if (_x == -1) \
@


1.7
log
@remove redundant macro
@
text
@a12 1
void	_thread_dump_info __P((void));
d22 1
d24 1
d27 1
d52 1
a52 1
	_thread_dump_info();
d88 2
a89 1
	if (!(_x rhs)) \
d91 5
a95 1
		"%s %s", #x, #rhs); \
@


1.6
log
@show a bit more information when checks fail
@
text
@a102 1
#define CHECKen(x) _CHECK(x, != 0, strerror(errno))
@


1.5
log
@define and use a SET_NAME macro so that these tests work under other thread implementations
@
text
@d96 1
a96 1
		    "failed check %s %s", #x, #rhs); \
@


1.4
log
@say something when a test locks up
@
text
@d20 8
@


1.3
log
@nice-ify
@
text
@d44 2
@


1.2
log
@tests are now useful
@
text
@d5 1
d7 3
d11 18
a28 10
extern int _thread_sys_write __P((int, const char*, size_t));

static __dead void __panic __P((const char *, int, const char*))
	__attribute__((noreturn));

static void __panic(const char *filenm, int lineno, const char*panicstr) {
	extern __dead void _thread_sys__exit __P((int)) 
		__attribute__((noreturn));
	extern size_t strlen __P((const char*));
	extern int sprintf __P((char *, const char *, ...));
d31 9
a39 2
	_thread_sys_write(2, panicstr, strlen(panicstr));
	sprintf(buf, "%s:%d\n", filenm, lineno);
d41 2
a42 1
	kill(0, SIGINFO);
d47 7
a53 6
#include <stdarg.h>
#include <string.h>

static __dead void __die __P((int err, const char *, int, const char *, ...));
static void __die(int err, const char *file, int line, const char *fmt, ...)

a54 1
	char buf[1024];
d56 1
d58 1
a58 1
	vsnprintf(buf, sizeof buf, fmt, ap);
a59 5
	strlcat(buf, ": ", sizeof buf);
	strlcat(buf, strerror(err), sizeof buf);
	_thread_sys_write(2, buf, strlen(buf));
	__panic(file, line, "\ndied at: ");
	__die(0,0,0,0);
d62 32
a93 1
#define DIE(e, m, args...)	__die(e, __FILE__, __LINE__, m , ## args)
d95 1
a95 1
#define PANIC()  __panic(__FILE__, __LINE__, "\npanic at ")
d97 2
a98 2
#define OK (0)
#define NOTOK (-1)
@


1.1
log
@libpthread tests modified for uthreads
@
text
@d5 5
a9 1
static __dead void __panic __P((char *filenm, int lineno))
d12 1
a12 2
static void __panic(char *filenm, int lineno) {
	extern int _thread_sys_write __P((int, char*, size_t));
a17 1
	char *panicstr = "\npanic at ";
d19 1
a19 1
	_thread_sys_write(2, panicstr, sizeof panicstr - 1);
d22 1
d24 1
a24 1
	__panic(NULL, 0);
d27 22
a48 1
#define PANIC()  __panic(__FILE__, __LINE__)
@

