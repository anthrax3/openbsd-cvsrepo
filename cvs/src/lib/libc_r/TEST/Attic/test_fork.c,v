head	1.10;
access;
symbols
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2001.08.15.14.43.15;	author fgsch;	state dead;
branches;
next	1.9;

1.9
date	2001.03.13.00.09.10;	author d;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.04.05.50.58;	author d;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.06.06.54.28;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.11.26.05.17.06;	author d;	state Exp;
branches;
next	1.5;

1.5
date	99.06.15.00.07.39;	author d;	state Exp;
branches;
next	1.4;

1.4
date	99.01.17.23.46.25;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.10.22.57.06;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.12.10.00.31.38;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.09.03.11.04.45;	author d;	state Exp;
branches;
next	;


desc
@@


1.10
log
@TEST has moved to regress/lib/libc_r.
@
text
@/*	$OpenBSD: test_fork.c,v 1.9 2001/03/13 00:09:10 d Exp $	*/
/*
 * Copyright (c) 1994 by Chris Provenzano, proven@@athena.mit.edu
 *
 * Test the fork system call.
 */

#include <pthread.h>
#include <pthread_np.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include "test.h"


void *
empty(void *arg)
{

	return (void *)0x12345678;
}

void *
sleeper(void *arg)
{

	pthread_set_name_np(pthread_self(), "slpr");
	sleep(10);
	PANIC("sleeper timed out");
}


int
main()
{
	int flags;
	pthread_t sleeper_thread;
	void *result;
	int status;
	pid_t parent_pid;
	pid_t child_pid;

	parent_pid = getpid();

	CHECKe(flags = fcntl(STDOUT_FILENO, F_GETFL));
	if ((flags & (O_NONBLOCK | O_NDELAY))) {
		/* This fails when stdout is /dev/null!? */
		/*CHECKe*/(fcntl(STDOUT_FILENO, F_SETFL, 
		    flags & ~(O_NONBLOCK | O_NDELAY)));
	}

	CHECKr(pthread_create(&sleeper_thread, NULL, sleeper, NULL));
	sleep(1);

	printf("forking from pid %d\n", getpid());

	CHECKe(child_pid = fork());
	if (child_pid == 0) {
		/* child: */
		printf("child = pid %d\n", getpid());
		/* Our pid should change */
		ASSERT(getpid() != parent_pid);
		/* Our sleeper thread should have disappeared */
		printf("sleeper should have disappeared\n");
		ASSERT(ESRCH == pthread_join(sleeper_thread, &result));
		printf("sleeper disappeared correctly\n");
		/* Test starting another thread */
		CHECKr(pthread_create(&sleeper_thread, NULL, empty, NULL));
		sleep(1);
		CHECKr(pthread_join(sleeper_thread, &result));
		ASSERT(result == (void *)0x12345678);
		printf("child ok\n");
		_exit(0);
		PANIC("child _exit");
	}

	/* parent: */
	printf("parent = pid %d\n", getpid());
	/* Our pid should stay the same */
	ASSERT(getpid() == parent_pid);
	/* wait for the child */
	ASSERTe(wait(&status), == child_pid);
	/* the child should have called exit(0) */
	ASSERT(WIFEXITED(status));
	ASSERT(WEXITSTATUS(status) == 0);
	/* Our sleeper thread should still be around */
	CHECKr(pthread_detach(sleeper_thread));
	printf("parent ok\n");
	SUCCEED;
}
@


1.9
log
@stronger test
@
text
@d1 1
a1 1
/*	$OpenBSD: test_fork.c,v 1.8 2000/10/04 05:50:58 d Exp $	*/
@


1.8
log
@bit of a cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: test_fork.c,v 1.7 2000/01/06 06:54:28 d Exp $	*/
d20 7
d31 1
a31 1
	sleep(4);
d67 1
d69 6
@


1.7
log
@longer sleep, doc,  get rid of bad signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 2
a44 1
		CHECKe(fcntl(STDOUT_FILENO, F_SETFL, 
@


1.6
log
@use pthread_join instead of pthread_cancel to test for a thread's existence after forking
@
text
@d1 2
a2 1
/* ==== test_fork.c ============================================================
d5 1
a5 4
 * Description : Test fork() and dup2() calls.
 *
 *  1.00 94/04/29 proven
 *      -Started coding this file.
d18 1
d24 1
a24 1
	sleep(2);
a27 20
static pid_t parent_pid;

static void
sigchld(sig)
	int sig;
{
	int status;

	/* we should have got a SIGCHLD */
	ASSERT(sig == SIGCHLD);
	/* We should be the parent */
	ASSERT(getpid() == parent_pid);
	/* wait for any child */
	CHECKe(wait(&status));
	/* the child should have called exit(0) */
	ASSERT(WIFEXITED(status));
	ASSERT(WEXITSTATUS(status) == 0);
	printf("parent ok\n");
	SUCCEED;
}
a32 1
	pid_t pid;
d35 3
a49 2
	CHECKe(signal(SIGCHLD, sigchld));

d52 2
a53 3
	CHECKe(pid = fork());
	switch(pid) {
	case 0:
a62 10
	default:
		/* parent: */
		printf("parent = pid %d\n", getpid());
		/* Our pid should stay the same */
		ASSERT(getpid() == parent_pid);
		/* Our sleeper thread should still be around */
		CHECKr(pthread_join(sleeper_thread, &result));
		/* wait for the SIGCHLD from the child */
		CHECKe(pause());
		PANIC("pause");
d64 14
@


1.5
log
@Remove pthread_atfork(). It was only part of draft 10 for a little while and was removed before stddization.
@
text
@d25 1
a25 1
	sleep(10);
d56 1
d81 1
a81 1
		ASSERT(ESRCH == pthread_cancel(sleeper_thread));
d91 1
a91 1
		CHECKr(pthread_cancel(sleeper_thread));
@


1.4
log
@pthread_atfork()
@
text
@a49 45
static int atfork_state = 0;

void
atfork_child2()
{
	ASSERT(atfork_state++ == 3);
	ASSERT(getpid() != parent_pid);
}

void
atfork_parent2()
{
	ASSERT(atfork_state++ == 3);
	ASSERT(getpid() == parent_pid);
}

void
atfork_prepare2()
{
	ASSERT(atfork_state++ == 0);
	ASSERT(getpid() == parent_pid);
}


void
atfork_child1()
{
	ASSERT(atfork_state++ == 2);
	ASSERT(getpid() != parent_pid);
}

void
atfork_parent1()
{
	ASSERT(atfork_state++ == 2);
	ASSERT(getpid() == parent_pid);
}

void
atfork_prepare1()
{
	ASSERT(atfork_state++ == 1);
	ASSERT(getpid() == parent_pid);
}

d70 1
a70 8
	/* Install some atfork handlers */

	CHECKr(pthread_atfork(&atfork_prepare1, &atfork_parent1, 
		&atfork_child1));
	CHECKr(pthread_atfork(&atfork_prepare2, &atfork_parent2, 
		&atfork_child2));

	printf("forking\n");
d76 1
a80 2
		/* The atfork handler should have run */
		ASSERT(atfork_state++ == 4);
d86 1
a90 2
		/* The atfork handler should have run */
		ASSERT(atfork_state++ == 4);
@


1.3
log
@nice-ify
@
text
@d23 1
a24 1
	printf("sleeper\n");
d29 2
d37 1
d39 3
d43 1
d46 1
d50 45
d102 2
d115 7
d127 8
a134 4
		sleep(1);
		printf("child process %d\n", getpid());
		_thread_dump_info();
		printf("\n");
d136 1
a136 1
		PANIC("_exit");
d138 8
a145 3
		printf("parent process %d [child %d]\n", getpid(), pid);
		_thread_dump_info();
		printf("\n");
@


1.2
log
@tests are now useful
@
text
@d11 1
d16 2
d20 22
d47 1
a47 1
	extern int _thread_sys_fcntl __P((int, int, ...));
d49 4
a52 3
	if (((flags = _thread_sys_fcntl(1, F_GETFL, NULL)) >= OK) && 
	  (flags & (O_NONBLOCK | O_NDELAY))) {
		_thread_sys_fcntl(1, F_SETFL, flags & ~(O_NONBLOCK | O_NDELAY));
a53 1
	printf("parent process %d\n", getpid());
d55 16
a70 6
	switch(pid = fork()) {
	case OK:
		exit(OK);
	case NOTOK:
		printf("fork() FAILED\n");
		exit(2);
d72 5
a76 2
		printf("child process %d\n", pid);
		break;
a77 4

	printf("test_fork PASSED\n");

	return 0;
@


1.1
log
@libpthread tests modified for uthreads
@
text
@d42 2
a43 1
	pthread_exit(NULL);
@

