head	1.4;
access;
symbols
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2001.08.15.14.43.15;	author fgsch;	state dead;
branches;
next	1.3;

1.3
date	2000.01.06.06.58.34;	author d;	state Exp;
branches;
next	1.2;

1.2
date	99.01.10.22.57.07;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.09.03.11.04.46;	author d;	state Exp;
branches;
next	;


desc
@@


1.4
log
@TEST has moved to regress/lib/libc_r.
@
text
@/*	$OpenBSD: test_preemption_float.c,v 1.3 2000/01/06 06:58:34 d Exp $	*/
/* Test to see if floating point state is being properly maintained
   for each thread.  Different threads doing floating point operations
   simultaneously should not interfere with one another.  This
   includes operations that might change some FPU flags, such as
   rounding modes, at least implicitly.  */

#include <pthread.h>
#include <math.h>
#include <stdio.h>
#include "test.h"

int limit = 2;
int float_passed = 0;
int float_failed = 1;

void *log_loop (void *x) {
  int i;
  double d, d1, d2;
  /* sleep (1); */
  for (i = 0; i < limit; i++) {
    d = 42.0;
    d = log (exp (d));
    d = (d + 39.0) / d;
    if (i == 0)
      d1 = d;
    else {
		d2 = d;
		d = sin(d);
		/* if (d2 != d1) { */
		if (memcmp (&d2, &d1, 8)) {
			pthread_exit(&float_failed);
		}
	}
  }
  pthread_exit(&float_passed);
}

void *trig_loop (void *x) {
  int i;
  double d, d1, d2;
  /* sleep (1);  */
  for (i = 0; i < limit; i++) {
    d = 35.0;
    d *= M_PI;
    d /= M_LN2;
    d = sin (d);
    d = cos (1 / d);
    if (i == 0)
      d1 = d;
    else {
		d2 = d;
		d = sin(d);
		/* if (d2 != d1) { */
		if (memcmp (&d2, &d1, 8)) {
  			pthread_exit(&float_failed);
		}
	}
  }
  pthread_exit(&float_passed);
}

int
floatloop(pthread_attr_t *attrp)
{
	pthread_t thread[2];
	int *x, *y;

	CHECKr(pthread_create (&thread[0], attrp, trig_loop, 0));
	CHECKr(pthread_create (&thread[1], attrp, log_loop, 0));
	CHECKr(pthread_join(thread[0], (void **) &x));	
	CHECKr(pthread_join(thread[1], (void **) &y));	

	/* Return 0 for success */
	return ((*y == float_failed)?2:0) | 
	       ((*x == float_failed)?1:0);
}

#define N 10
int
main()
{
	pthread_attr_t attr;
	int i;

	/* Try with float point state not preserved */

	CHECKr(pthread_attr_init(&attr));
	CHECKr(pthread_attr_setfloatstate(&attr, PTHREAD_NOFLOAT));

	for(limit = 2; limit < 100000; limit *=4)
		if (floatloop(&attr) != 0)
			break;

	if (limit >= 100000) {
		printf("results are INDETERMINATE\n");
		SUCCEED; /* XXX */
	}

	limit *= 4;  /* just to make sure */

	printf("using limit = %d\n", limit);

	for (i = 0; i < 32; i++) {
		/* Try the failure mode one more time. */
		if (floatloop(&attr) == 0) {
			printf("%d ", i);
			fflush(stdout);
		}
		/* Now see if saving float state will get rid of failure. */
		ASSERT(floatloop(NULL) == 0);
	}

	SUCCEED;
}
@


1.3
log
@ident, clean
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@nice-ify
@
text
@d1 1
@


1.1
log
@libpthread tests modified for uthreads
@
text
@d10 1
d62 16
d79 18
a96 16
int main () {
  pthread_t thread[2];
  pthread_attr_t attr;
  int *x, *y;

  pthread_attr_init(&attr);
  /* pthread_attr_setfloatstate(&attr, PTHREAD_NOFLOAT); */

  while(limit < 100000) {
    pthread_create (&thread[0], &attr, trig_loop, 0);
    pthread_create (&thread[1], &attr, log_loop, 0);
  	pthread_join(thread[0], (void **) &x);	
  	pthread_join(thread[1], (void **) &y);	
  	if ((*x == float_failed) || (*y == float_failed)) {
		limit *= 4;
		break;
d98 16
a113 17
	limit *= 4;
  }
  if ((*x == float_passed) && (*y == float_passed)) {
	printf("test_preemption_float INDETERMINATE\n");
    return(0);
  }
  pthread_create (&thread[0], NULL, trig_loop, 0);
  pthread_create (&thread[1], NULL, log_loop, 0);
  pthread_join(thread[0], (void **) &x);	
  pthread_join(thread[1], (void **) &y);	

  if ((*x == float_failed) || (*y == float_failed)) {
	printf("test_preemption_float FAILED\n");
	return(1);
  }
  printf("test_preemption_float PASSED\n");
  return(0);
@

