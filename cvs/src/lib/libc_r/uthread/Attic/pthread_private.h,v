head	1.41;
access;
symbols
	OPENBSD_3_2:1.35.0.4
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.35.0.2
	OPENBSD_3_1_BASE:1.35
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.41
date	2003.01.20.18.14.06;	author marc;	state dead;
branches;
next	1.40;

1.40
date	2002.12.11.23.21.19;	author marc;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.08.04.06.01;	author marc;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.12.20.12.45;	author marc;	state Exp;
branches;
next	1.37;

1.37
date	2002.10.30.20.05.11;	author marc;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.30.19.11.56;	author marc;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.21.20.57.41;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.19.23.49.32;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.31.18.23.15;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.19.02.02.52;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.11.00.19.47;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.08.14.51.36;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.04.23.28.31;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.04.22.17.45;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.30.17.47.57;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.30.07.40.47;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.29.18.33.54;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.26.00.49.03;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.21.19.24.53;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.15.23.50.34;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.06.17.18.47;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.04.05.55.35;	author d;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.06.07.13.56;	author d;	state Exp;
branches;
next	1.18;

1.18
date	99.11.25.07.01.30;	author d;	state Exp;
branches;
next	1.17;

1.17
date	99.09.08.08.21.47;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.06.15.00.07.39;	author d;	state Exp;
branches;
next	1.15;

1.15
date	99.06.09.07.06.54;	author d;	state Exp;
branches;
next	1.14;

1.14
date	99.05.26.00.18.21;	author d;	state Exp;
branches;
next	1.13;

1.13
date	99.02.16.16.44.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.01.18.00.03.35;	author d;	state Exp;
branches;
next	1.11;

1.11
date	99.01.18.00.00.32;	author d;	state Exp;
branches;
next	1.10;

1.10
date	99.01.10.22.32.23;	author d;	state Exp;
branches;
next	1.9;

1.9
date	99.01.08.05.44.53;	author d;	state Exp;
branches;
next	1.8;

1.8
date	99.01.08.05.42.18;	author d;	state Exp;
branches;
next	1.7;

1.7
date	99.01.08.04.59.50;	author d;	state Exp;
branches;
next	1.6;

1.6
date	98.12.23.22.49.46;	author d;	state Exp;
branches;
next	1.5;

1.5
date	98.12.21.07.41.31;	author d;	state Exp;
branches;
next	1.4;

1.4
date	98.11.20.12.13.32;	author d;	state Exp;
branches;
next	1.3;

1.3
date	98.11.20.11.04.00;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.11.09.03.13.18;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.08.27.09.00.50;	author d;	state Exp;
branches;
next	;


desc
@@


1.41
log
@
bye-bye libc_r sources.
the sources have been moved (with history) to /usr/src/lib/libpthread
@
text
@/*	$OpenBSD: pthread_private.h,v 1.40 2002/12/11 23:21:19 marc Exp $	*/
/*
 * Copyright (c) 1995-1998 John Birrell <jb@@cimlogic.com.au>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John Birrell.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Private thread definitions for the uthread kernel.
 *
 * $FreeBSD: pthread_private.h,v 1.27 1999/09/29 15:18:38 marcel Exp $
 */

#ifndef _PTHREAD_PRIVATE_H
#define _PTHREAD_PRIVATE_H

/*
 * Evaluate the storage class specifier.
 */
#ifdef GLOBAL_PTHREAD_PRIVATE
#define SCLASS
#else
#define SCLASS extern
#endif

/*
 * Include files.
 */
#include <signal.h>
#include <stdio.h>
#include <sys/queue.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sched.h>
#include <spinlock.h>
#include <pthread_np.h>
#include "thread_private.h"
#include "uthread_machdep.h"

/*
 * Workaround until we have ENOTSUP in errno.h
 */
#define ENOTSUP			EOPNOTSUPP

/*
 * Kernel fatal error handler macro.
 */
#define PANIC(string)   _thread_exit(__FILE__,__LINE__,string)

/* Output debug messages like this: */
#define	stdout_debug(_x)	_thread_sys_write(1,_x,strlen(_x));
#define	stderr_debug(_x)	_thread_sys_write(2,_x,strlen(_x));


/*
 * Priority queue manipulation macros (using pqe link):
 */
#define PTHREAD_PRIOQ_INSERT_HEAD(thrd)	_pq_insert_head(&_readyq,thrd)
#define PTHREAD_PRIOQ_INSERT_TAIL(thrd)	_pq_insert_tail(&_readyq,thrd)
#define PTHREAD_PRIOQ_REMOVE(thrd)	_pq_remove(&_readyq,thrd)
#define PTHREAD_PRIOQ_FIRST()		_pq_first(&_readyq)

/*
 * Waiting queue manipulation macros (using pqe link):
 */
#define PTHREAD_WAITQ_REMOVE(thrd)	_waitq_remove(thrd)
#define PTHREAD_WAITQ_INSERT(thrd)	_waitq_insert(thrd)

#if defined(_PTHREADS_INVARIANTS)
#define PTHREAD_WAITQ_CLEARACTIVE()	_waitq_clearactive()
#define PTHREAD_WAITQ_SETACTIVE()	_waitq_setactive()
#else
#define PTHREAD_WAITQ_CLEARACTIVE()
#define PTHREAD_WAITQ_SETACTIVE()
#endif

/*
 * Work queue manipulation macros (using qe link):
 */
#define PTHREAD_WORKQ_INSERT(thrd) do {					\
	TAILQ_INSERT_TAIL(&_workq,thrd,qe);				\
	(thrd)->flags |= PTHREAD_FLAGS_IN_WORKQ;			\
} while (0)
#define PTHREAD_WORKQ_REMOVE(thrd) do {					\
	TAILQ_REMOVE(&_workq,thrd,qe);					\
	(thrd)->flags &= ~PTHREAD_FLAGS_IN_WORKQ;			\
} while (0)


/*
 * State change macro without scheduling queue change:
 */
#define PTHREAD_SET_STATE(thrd, newstate) do {				\
	(thrd)->state = newstate;					\
	(thrd)->fname = __FILE__;					\
	(thrd)->lineno = __LINE__;					\
} while (0)

/*
 * State change macro with scheduling queue change - This must be
 * called with preemption deferred (see thread_kern_sched_[un]defer).
 */
#if defined(_PTHREADS_INVARIANTS)
#include <assert.h>
#define PTHREAD_ASSERT(cond, msg) do {	\
	if (!(cond))			\
		PANIC(msg);		\
} while (0)
#define PTHREAD_ASSERT_NOT_IN_SYNCQ(thrd) \
	PTHREAD_ASSERT((((thrd)->flags & PTHREAD_FLAGS_IN_SYNCQ) == 0),	\
	    "Illegal call from signal handler");
#define PTHREAD_NEW_STATE(thrd, newstate) do {				\
	if (_thread_kern_new_state != 0)				\
		PANIC("Recursive PTHREAD_NEW_STATE");			\
	_thread_kern_new_state = 1;					\
	if ((thrd)->state != newstate) {				\
		if ((thrd)->state == PS_RUNNING) {			\
			PTHREAD_PRIOQ_REMOVE(thrd);			\
			PTHREAD_WAITQ_INSERT(thrd);			\
		} else if (newstate == PS_RUNNING) { 			\
			PTHREAD_WAITQ_REMOVE(thrd);			\
			PTHREAD_PRIOQ_INSERT_TAIL(thrd);		\
		}							\
	}								\
	_thread_kern_new_state = 0;					\
	PTHREAD_SET_STATE(thrd, newstate);				\
} while (0)
#else
#define PTHREAD_ASSERT(cond, msg)
#define PTHREAD_ASSERT_NOT_IN_SYNCQ(thrd)
#define PTHREAD_NEW_STATE(thrd, newstate) do {				\
	if ((thrd)->state != newstate) {				\
		if ((thrd)->state == PS_RUNNING) {			\
			PTHREAD_PRIOQ_REMOVE(thrd);			\
			PTHREAD_WAITQ_INSERT(thrd);			\
		} else if (newstate == PS_RUNNING) { 			\
			PTHREAD_WAITQ_REMOVE(thrd);			\
			PTHREAD_PRIOQ_INSERT_TAIL(thrd);		\
		}							\
	}								\
	PTHREAD_SET_STATE(thrd, newstate);				\
} while (0)
#endif

/*
 * Define the signals to be used for scheduling.
 */
#if defined(_PTHREADS_COMPAT_SCHED)
#define _ITIMER_SCHED_TIMER	ITIMER_VIRTUAL
#define _SCHED_SIGNAL		SIGVTALRM
#else
#define _ITIMER_SCHED_TIMER	ITIMER_PROF
#define _SCHED_SIGNAL		SIGPROF
#endif

/* Lists with volatile elements */
#define V_TAILQ_HEAD(name, type)				\
volatile struct name {						\
	struct type * tqh_first;				\
	struct type * volatile * tqh_last; 			\
}

#define V_TAILQ_ENTRY(type)					\
volatile struct {						\
	struct type * tqe_next;					\
	struct type * volatile * tqe_prev; 			\
}

/* List of all threads: */
typedef V_TAILQ_HEAD(, pthread)	_thread_list_t;

/*
 * Priority queues.
 *
 * XXX It'd be nice if these were contained in uthread_priority_queue.[ch].
 */
typedef struct pq_list {
	_thread_list_t		pl_head; /* list of threads at this priority */
	TAILQ_ENTRY(pq_list)	pl_link; /* link for queue of priority lists */
	int			pl_prio; /* the priority of this list */
	int			pl_queued; /* is this in the priority queue */
} pq_list_t;

typedef struct pq_queue {
	TAILQ_HEAD(, pq_list)	 pq_queue; /* queue of priority lists */
	pq_list_t		*pq_lists; /* array of all priority lists */
	int			 pq_size;  /* number of priority lists */
} pq_queue_t;


/*
 * TailQ initialization values.
 */
#define TAILQ_INITIALIZER	{ NULL, NULL }

/* 
 * Mutex definitions.
 */
union pthread_mutex_data {
	void	*m_ptr;
	int	m_count;
};

struct pthread_mutex {
	enum pthread_mutextype		m_type;
	int				m_protocol;
	V_TAILQ_HEAD(mutex_head, pthread)	m_queue;
	struct pthread			*m_owner;
	union pthread_mutex_data	m_data;
	long				m_flags;
	int				m_refcount;

	/*
	 * Used for priority inheritence and protection.
	 *
	 *   m_prio       - For priority inheritence, the highest active
	 *                  priority (threads locking the mutex inherit
	 *                  this priority).  For priority protection, the
	 *                  ceiling priority of this mutex.
	 *   m_saved_prio - mutex owners inherited priority before
	 *                  taking the mutex, restored when the owner
	 *                  unlocks the mutex.
	 */
	int				m_prio;
	int				m_saved_prio;

	/*
	 * Link for list of all mutexes a thread currently owns.
	 */
	V_TAILQ_ENTRY(pthread_mutex volatile)	m_qe;

	/*
	 * Lock for accesses to this structure.
	 */
	spinlock_t			lock;
};

/*
 * Flags for mutexes.
 */
#define MUTEX_FLAGS_PRIVATE	0x01
#define MUTEX_FLAGS_INITED	0x02
#define MUTEX_FLAGS_BUSY	0x04

/*
 * Static mutex initialization values.
 */
#define PTHREAD_MUTEX_STATIC_INITIALIZER   \
	{ PTHREAD_MUTEX_DEFAULT, PTHREAD_PRIO_NONE, TAILQ_INITIALIZER, \
	NULL, { NULL }, MUTEX_FLAGS_PRIVATE, 0, 0, 0, TAILQ_INITIALIZER, \
	_SPINLOCK_INITIALIZER }

struct pthread_mutex_attr {
	enum pthread_mutextype	m_type;
	int			m_protocol;
	int			m_ceiling;
	long			m_flags;
};

#define PTHREAD_MUTEXATTR_STATIC_INITIALIZER \
	{ PTHREAD_MUTEX_DEFAULT, PTHREAD_PRIO_NONE, 0, MUTEX_FLAGS_PRIVATE }

/* 
 * Condition variable definitions.
 */
enum pthread_cond_type {
	COND_TYPE_FAST,
	COND_TYPE_MAX
};

struct pthread_cond {
	enum pthread_cond_type		c_type;
	V_TAILQ_HEAD(cond_head, pthread) c_queue;
	pthread_mutex_t			c_mutex;
	long				c_flags;
	int				c_seqno;

	/*
	 * Lock for accesses to this structure.
	 */
	spinlock_t			lock;
};

struct pthread_cond_attr {
	enum pthread_cond_type	c_type;
	long			c_flags;
};

/*
 * Flags for condition variables.
 */
#define COND_FLAGS_PRIVATE	0x01
#define COND_FLAGS_INITED	0x02
#define COND_FLAGS_BUSY		0x04

/*
 * Static cond initialization values.
 */
#define PTHREAD_COND_STATIC_INITIALIZER    \
	{ COND_TYPE_FAST, TAILQ_INITIALIZER, NULL, NULL, \
	0, 0, _SPINLOCK_INITIALIZER }

/*
 * Semaphore definitions.
 */
struct sem {
#define	SEM_MAGIC	((u_int32_t) 0x09fa4012)
	u_int32_t	magic;
	pthread_mutex_t	lock;
	pthread_cond_t	gtzero;
	u_int32_t	count;
	u_int32_t	nwaiters;
};

/*
 * Cleanup definitions.
 */
struct pthread_cleanup {
	struct pthread_cleanup	*next;
	void			(*routine) ();
	void			*routine_arg;
};

struct pthread_attr {
	int	sched_policy;
	int	sched_inherit;
	int	sched_interval;
	int	prio;
	int	suspend;
	int	flags;
	void	*arg_attr;
	void	(*cleanup_attr) ();
	void	*stackaddr_attr;
	size_t	stacksize_attr;
	size_t	guardsize_attr;
};

/*
 * Thread creation state attributes.
 */
#define PTHREAD_CREATE_RUNNING			0
#define PTHREAD_CREATE_SUSPENDED		1

/*
 * Additional state for a thread suspended with pthread_suspend_np().
 */
enum pthread_susp {
	SUSP_NO,	/* Not suspended. */
	SUSP_YES,	/* Suspended. */
	SUSP_JOIN,	/* Suspended, joining. */
	SUSP_NOWAIT,	/* Suspended, was in a mutex or condition queue. */
	SUSP_MUTEX_WAIT,/* Suspended, still in a mutex queue. */
	SUSP_COND_WAIT	/* Suspended, still in a condition queue. */
};

/*
 * Miscellaneous definitions.
 */
#define PTHREAD_STACK_DEFAULT			65536
/*
 * Maximum size of initial thread's stack.  This perhaps deserves to be larger
 * than the stacks of other threads, since many applications are likely to run
 * almost entirely on this stack.
 */
#define PTHREAD_STACK_INITIAL			0x100000

/* Address immediately beyond the beginning of the initial thread stack. */
#define _POSIX_THREAD_ATTR_STACKSIZE

/*
 * Define the different priority ranges.  All applications have thread
 * priorities constrained within 0-31.  The threads library raises the
 * priority when delivering signals in order to ensure that signal
 * delivery happens (from the POSIX spec) "as soon as possible".
 * In the future, the threads library will also be able to map specific
 * threads into real-time (cooperating) processes or kernel threads.
 * The RT and SIGNAL priorities will be used internally and added to
 * thread base priorities so that the scheduling queue can handle both
 * normal and RT priority threads with and without signal handling.
 *
 * The approach taken is that, within each class, signal delivery
 * always has priority over thread execution.
 */
#define PTHREAD_DEFAULT_PRIORITY		15
#define PTHREAD_MIN_PRIORITY			0
#define PTHREAD_MAX_PRIORITY			31	/* 0x1F */
#define PTHREAD_SIGNAL_PRIORITY			32	/* 0x20 */
#define PTHREAD_RT_PRIORITY			64	/* 0x40 */
#define PTHREAD_FIRST_PRIORITY			PTHREAD_MIN_PRIORITY
#define PTHREAD_LAST_PRIORITY	\
	(PTHREAD_MAX_PRIORITY + PTHREAD_SIGNAL_PRIORITY + PTHREAD_RT_PRIORITY)
#define PTHREAD_BASE_PRIORITY(prio)	((prio) & PTHREAD_MAX_PRIORITY)

/*
 * Clock resolution in microseconds.
 */
#define CLOCK_RES_USEC				10000
#define CLOCK_RES_USEC_MIN			1000

/*
 * Time slice period in microseconds.
 */
#define TIMESLICE_USEC				20000

/*
 * Define a thread-safe macro to get the current time of day
 * which is updated at regular intervals by the scheduling signal
 * handler.
 */
#define	GET_CURRENT_TOD(tv)				\
	do {						\
		tv.tv_sec = _sched_tod.tv_sec;		\
		tv.tv_usec = _sched_tod.tv_usec;	\
	} while (tv.tv_sec != _sched_tod.tv_sec)


struct pthread_key {
	spinlock_t	lock;
	volatile int	allocated;
	volatile int	count;
	void            (*destructor) ();
};

struct pthread_rwlockattr {
	int		pshared;
};

struct pthread_rwlock {
	pthread_mutex_t	lock;	/* monitor lock */
	int		state;	/* 0 = idle  >0 = # of readers  -1 = writer */
	pthread_cond_t	read_signal;
	pthread_cond_t	write_signal;
	int		blocked_writers;
};

/*
 * Thread states.
 */
enum pthread_state {
	PS_RUNNING,
	PS_SIGTHREAD,
	PS_MUTEX_WAIT,
	PS_COND_WAIT,
	PS_FDLR_WAIT,
	PS_FDLW_WAIT,
	PS_FDR_WAIT,
	PS_FDW_WAIT,
	PS_FILE_WAIT,
	PS_POLL_WAIT,
	PS_SELECT_WAIT,
	PS_SLEEP_WAIT,
	PS_WAIT_WAIT,
	PS_SIGSUSPEND,
	PS_SIGWAIT,
	PS_SPINBLOCK,
	PS_JOIN,
	PS_SUSPENDED,
	PS_DEAD,
	PS_DEADLOCK,
	PS_STATE_MAX
};


/*
 * File descriptor locking definitions are defined in "thread_private.h"
 */

/*
 * File descriptor table structure.
 */
struct fd_table_entry {
	/*
	 * Lock for accesses to this file descriptor table
	 * entry. This is passed to _spinlock() to provide atomic
	 * access to this structure. It does *not* represent the
	 * state of the lock on the file descriptor.
	 */
	spinlock_t		lock;
	_thread_list_t		r_queue;	/* Read queue.                        */
	_thread_list_t		w_queue;	/* Write queue.                       */
	struct pthread		*r_owner;	/* Ptr to thread owning read lock.    */
	struct pthread		*w_owner;	/* Ptr to thread owning write lock.   */
	const char		*r_fname;	/* Ptr to read lock source file name  */
	int			r_lineno;	/* Read lock source line number.      */
	const char		*w_fname;	/* Ptr to write lock source file name */
	int			w_lineno;	/* Write lock source line number.     */
	int			r_lockcount;	/* Count for FILE read locks.         */
	int			w_lockcount;	/* Count for FILE write locks.        */
	int			flags;		/* Flags used in open.                */
};

struct pthread_poll_data {
	int	nfds;
	struct pollfd *fds;
};

union pthread_wait_data {
	pthread_mutex_t	mutex;
	pthread_cond_t	cond;
	const sigset_t	*sigwait;	/* Waiting on a signal in sigwait */
	struct {
		short	fd;		/* Used when thread waiting on fd */
		short	branch;		/* Line number, for debugging.    */
		char	*fname;		/* Source file name for debugging.*/
	} fd;
	FILE		*fp;
	struct pthread_poll_data *poll_data;
	spinlock_t	*spinlock;
	struct pthread	*thread;
};

/* Spare thread stack. */
struct stack {
	SLIST_ENTRY(stack)	qe; /* Queue entry for this stack. */
	void 			*base;		/* Bottom of useful stack */
	size_t			size;		/* Size of useful stack */
	void			*redzone;	/* Red zone location */
	void 			*storage;	/* allocated storage */
};

/*
 * Define a continuation routine that can be used to perform a
 * transfer of control:
 */
typedef void	(*thread_continuation_t) (void *);

typedef V_TAILQ_ENTRY(pthread) pthread_entry_t;

struct join_status {
	struct pthread	*thread;
	void		*ret;
	int		error;
};

/*
 * Thread structure.
 */
struct pthread {
	/*
	 * Magic value to help recognize a valid thread structure
	 * from an invalid one:
	 */
#define	PTHREAD_MAGIC		((u_int32_t) 0xd09ba115)
	u_int32_t		magic;
	char			*name;

	/*
	 * Lock for accesses to this thread structure.
	 */
	spinlock_t		lock;

	/* Queue entry for list of all threads: */
	pthread_entry_t		tle;

	/* Queue entry for list of dead threads: */
	pthread_entry_t		dle;

	/*
	 * Thread start routine, argument, stack pointer and thread
	 * attributes.
	 */
	void			*(*start_routine)(void *);
	void			*arg;
	struct stack		*stack;
	struct pthread_attr	attr;

	/*
	 * Saved signal context used in call to sigreturn by
	 * _thread_kern_sched if sig_saved is TRUE.
	 */
	struct  sigcontext saved_sigcontext;

	/*
	 * Machine-dependent context, valid if sig_saved is FALSE.
	 */
	struct _machdep_state	_machdep;

	/*
	 * TRUE if the last state saved was a signal context. FALSE if the
	 * last state saved was a jump buffer.
	 */
	int	sig_saved;

	/*
	 * Cancelability flags - the lower 2 bits are used by cancel
	 * definitions in pthread.h
	 */
#define PTHREAD_AT_CANCEL_POINT		0x0004
#define PTHREAD_CANCELLING		0x0008
#define PTHREAD_CANCEL_NEEDED		0x0010
	int	cancelflags;

	enum pthread_susp	suspended;

	thread_continuation_t	continuation;

	/*
	 * Current signal mask and pending signals.
	 */
	sigset_t	sigmask;
	sigset_t	sigpend;
	int		sigmask_seqno;
	int		check_pending;

	/* Thread state: */
	enum pthread_state	state;

	/* Scheduling clock when this thread was last made active. */
	long	last_active;

	/* Scheduling clock when this thread was last made inactive. */
	long	last_inactive;

	/*
	 * Number of microseconds accumulated by this thread when
	 * time slicing is active.
	 */
	long	slice_usec;

	/*
	 * Time to wake up thread. This is used for sleeping threads and
	 * for any operation which may time out (such as select).
	 */
	struct timespec	wakeup_time;

	/* TRUE if operation has timed out. */
	int	timeout;

	/*
	 * Error variable used instead of errno. The function __error()
	 * returns a pointer to this.
	 */
	int	error;

	/*
	 * The joiner is the thread that is joining to this thread.  The
	 * join status keeps track of a join operation to another thread.
	 */
	struct pthread		*joiner;
	struct join_status	join_status;

	/*
	 * The current thread can belong to only one scheduling queue at
	 * a time (ready or waiting queue).  It can also belong to:
	 *
	 *   o A queue of threads waiting for a mutex
	 *   o A queue of threads waiting for a condition variable
	 *   o A queue of threads waiting for a file descriptor lock
	 *   o A queue of threads needing work done by the kernel thread
	 *     (waiting for a spinlock or file I/O)
	 *
	 * A thread can also be joining a thread (the joiner field above).
	 *
	 * It must not be possible for a thread to belong to any of the
	 * above queues while it is handling a signal.  Signal handlers
	 * may longjmp back to previous stack frames circumventing normal
	 * control flow.  This could corrupt queue integrity if the thread
	 * retains membership in the queue.  Therefore, if a thread is a
	 * member of one of these queues when a signal handler is invoked,
	 * it must remove itself from the queue before calling the signal
	 * handler and reinsert itself after normal return of the handler.
	 *
	 * Use pqe for the scheduling queue link (both ready and waiting),
	 * sqe for synchronization (mutex and condition variable) queue
	 * links, and qe for all other links.
	 */

	pthread_entry_t		pqe;	/* priority queue link */
	pthread_entry_t		sqe;	/* synchronization queue link */
	pthread_entry_t		qe;	/* all other queues link */

	/* Wait data. */
	union pthread_wait_data data;

	/*
	 * Allocated for converting select into poll.
	 */
	struct pthread_poll_data poll_data;

	/*
	 * Set to TRUE if a blocking operation was
	 * interrupted by a signal:
	 */
	int		interrupted;

	/* Signal number when in state PS_SIGWAIT: */
	int		signo;

	/*
	 * Set to non-zero when this thread has deferred signals.
	 * We allow for recursive deferral.
	 */
	int		sig_defer_count;

	/*
	 * Set to TRUE if this thread should yield after undeferring
	 * signals.
	 */
	int		yield_on_sig_undefer;

	/* Miscellaneous flags; only set with signals deferred. */
	int		flags;
#define PTHREAD_FLAGS_PRIVATE	0x0001
#define PTHREAD_EXITING		0x0002
#define PTHREAD_FLAGS_IN_WAITQ	0x0004	/* in waiting queue using pqe link */
#define PTHREAD_FLAGS_IN_PRIOQ	0x0008	/* in priority queue using pqe link */
#define PTHREAD_FLAGS_IN_WORKQ	0x0010	/* in work queue using qe link */
#define PTHREAD_FLAGS_IN_FILEQ	0x0020	/* in file lock queue using qe link */
#define PTHREAD_FLAGS_IN_FDQ	0x0040	/* in fd lock queue using qe link */
#define PTHREAD_FLAGS_IN_CONDQ	0x0080	/* in condition queue using sqe link */
#define PTHREAD_FLAGS_IN_MUTEXQ	0x0100	/* in mutex queue using sqe link */
#define PTHREAD_FLAGS_TRACE	0x0200	/* for debugging purposes */
#define PTHREAD_FLAGS_IN_SYNCQ	\
    (PTHREAD_FLAGS_IN_CONDQ | PTHREAD_FLAGS_IN_MUTEXQ)

	/*
	 * Base priority is the user setable and retrievable priority
	 * of the thread.  It is only affected by explicit calls to
	 * set thread priority and upon thread creation via a thread
	 * attribute or default priority.
	 */
	char		base_priority;

	/*
	 * Inherited priority is the priority a thread inherits by
	 * taking a priority inheritence or protection mutex.  It
	 * is not affected by base priority changes.  Inherited
	 * priority defaults to and remains 0 until a mutex is taken
	 * that is being waited on by any other thread whose priority
	 * is non-zero.
	 */
	char		inherited_priority;

	/*
	 * Active priority is always the maximum of the threads base
	 * priority and inherited priority.  When there is a change
	 * in either the base or inherited priority, the active
	 * priority must be recalculated.
	 */
	char		active_priority;

	/* Number of priority ceiling or protection mutexes owned. */
	int		priority_mutex_count;

	/*
	 * Queue of currently owned mutexes.
	 */
	V_TAILQ_HEAD(, pthread_mutex volatile)	mutexq;

	void		*ret;
	const void	**specific_data;
	int		specific_data_count;

	/* Cleanup handlers Link List */
	struct pthread_cleanup *cleanup;
	char			*fname;	/* Ptr to source file name  */
	int			lineno;	/* Source line number.      */
};

/*
 * Flags and prototypes for the machine dependent layer
 */
void _thread_machdep_switch(struct _machdep_state *newstate, 
        struct _machdep_state *savestate);
void _thread_machdep_init(struct _machdep_state *state, void *stackbase, 
        int stacksize, void (*entry)(void));
void _thread_machdep_save_float_state(struct _machdep_state* statep);
void _thread_machdep_restore_float_state(struct _machdep_state* statep);

/*
 * Global variables for the uthread kernel.
 */

/* Kernel thread structure used when there are no running threads: */
SCLASS struct pthread	_thread_kern_thread;

/* Ptr to the thread structure for the running thread: */
SCLASS struct pthread	* volatile _thread_run
#ifdef GLOBAL_PTHREAD_PRIVATE
= &_thread_kern_thread;
#else
;
#endif

/* Ptr to the thread structure for the last user thread to run: */
SCLASS struct pthread	* volatile _last_user_thread
#ifdef GLOBAL_PTHREAD_PRIVATE
= &_thread_kern_thread;
#else
;
#endif

/*
 * Ptr to the thread running in single-threaded mode or NULL if
 * running multi-threaded (default POSIX behaviour).
 */
SCLASS struct pthread	* volatile _thread_single
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL;
#else
;
#endif

SCLASS _thread_list_t		_thread_list
#ifdef GLOBAL_PTHREAD_PRIVATE
= TAILQ_HEAD_INITIALIZER(_thread_list);
#else
;
#endif

/*
 * Array of kernel pipe file descriptors that are used to ensure that
 * no signals are missed in calls to _select.
 */
SCLASS int		_thread_kern_pipe[2]
#ifdef GLOBAL_PTHREAD_PRIVATE
= {
	-1,
	-1
};
#else
;
#endif
SCLASS int		volatile _queue_signals
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif
SCLASS int		volatile _thread_kern_in_sched
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

SCLASS int		_sig_in_handler
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

/* Time of day at last scheduling timer signal: */
SCLASS struct timeval volatile	_sched_tod
#ifdef GLOBAL_PTHREAD_PRIVATE
= { 0, 0 };
#else
;
#endif

/*
 * Current scheduling timer ticks; used as resource usage.
 */
SCLASS unsigned int volatile	_sched_ticks
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

/* Dead threads: */
SCLASS _thread_list_t		_dead_list
#ifdef GLOBAL_PTHREAD_PRIVATE
= TAILQ_HEAD_INITIALIZER(_dead_list);
#else
;
#endif

/* Initial thread: */
SCLASS struct pthread *_thread_initial
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL;
#else
;
#endif

/* Default thread attributes: */
SCLASS struct pthread_attr pthread_attr_default
#ifdef GLOBAL_PTHREAD_PRIVATE
= { SCHED_RR, 0, TIMESLICE_USEC, PTHREAD_DEFAULT_PRIORITY,
	PTHREAD_CREATE_RUNNING, PTHREAD_CREATE_JOINABLE, NULL, NULL, NULL,
	PTHREAD_STACK_DEFAULT };
#else
;
#endif

/* Default mutex attributes: */
SCLASS struct pthread_mutex_attr pthread_mutexattr_default
#ifdef GLOBAL_PTHREAD_PRIVATE
= { PTHREAD_MUTEX_DEFAULT, PTHREAD_PRIO_NONE, 0, 0 };
#else
;
#endif

/* Default condition variable attributes: */
SCLASS struct pthread_cond_attr pthread_condattr_default
#ifdef GLOBAL_PTHREAD_PRIVATE
= { COND_TYPE_FAST, 0 };
#else
;
#endif

/* File table information: */
SCLASS struct fd_table_entry **_thread_fd_table
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL;
#else
;
#endif

/* Table for polling file descriptors: */
SCLASS struct pollfd *_thread_pfd_table
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL;
#else
;
#endif

SCLASS const int dtablecount
#ifdef GLOBAL_PTHREAD_PRIVATE
= 4096/sizeof(struct fd_table_entry);
#else
;
#endif
SCLASS int    _thread_dtablesize	/* Descriptor table size.	*/
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

SCLASS int    _clock_res_usec		/* Clock resolution in usec.	*/
#ifdef GLOBAL_PTHREAD_PRIVATE
= CLOCK_RES_USEC;
#else
;
#endif

/* Garbage collector mutex and condition variable. */
SCLASS	pthread_mutex_t _gc_mutex
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL
#endif
;
SCLASS	pthread_cond_t  _gc_cond
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL
#endif
;

/*
 * Array of signal actions for this process.
 */
SCLASS struct  sigaction _thread_sigact[NSIG];

/*
 * Array of counts of dummy handlers for SIG_DFL signals.  This is used to
 * assure that there is always a dummy signal handler installed while there is a
 * thread sigwait()ing on the corresponding signal.
 */
SCLASS int	_thread_dfl_count[NSIG];

/*
 * Pending signals and mask for this process:
 */
SCLASS sigset_t		_process_sigpending;
SCLASS sigset_t		_process_sigmask
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0
#endif
;

/*
 * Scheduling queues:
 */
SCLASS pq_queue_t		_readyq;
SCLASS _thread_list_t		_waitingq;

/*
 * Work queue:
 */
SCLASS _thread_list_t		_workq;

/* Tracks the number of threads blocked while waiting for a spinlock. */
SCLASS volatile int	_spinblock_count
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0
#endif
;

/* Used to maintain pending and active signals: */
struct sigstatus {
	int		pending;	/* Is this a pending signal? */
	int		blocked;	/*
					 * A handler is currently active for
					 * this signal; ignore subsequent
					 * signals until the handler is done.
					 */
	int		signo;		/* arg 1 to signal handler */
	siginfo_t	siginfo;	/* arg 2 to signal handler */
	struct sigcontext uc;		/* arg 3 to signal handler */
};

SCLASS struct sigstatus	_thread_sigq[NSIG];

/* Indicates that the signal queue needs to be checked. */
SCLASS volatile int	_sigq_check_reqd
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0
#endif
;

/* The signal stack. */
SCLASS struct sigaltstack _thread_sigstack;

/* Thread switch hook. */
SCLASS pthread_switch_routine_t _sched_switch_hook
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL
#endif
;

/*
 * Spare stack queue.  Stacks of default size are cached in order to reduce
 * thread creation time.  Spare stacks are used in LIFO order to increase cache
 * locality.
 */
typedef SLIST_HEAD(, stack)	_stack_list_t;
extern _stack_list_t		_stackq;

/* Used for _PTHREADS_INVARIANTS checking. */
SCLASS int	_thread_kern_new_state
#ifdef GLOBAL_PTHREAD_PRIVATE 
= 0;
#else
;
#endif

/* Undefine the storage class specifier: */
#undef SCLASS

/*
 * Function prototype definitions.
 */
__BEGIN_DECLS
int     _find_thread(pthread_t);
struct pthread *_get_curthread(void);
void	_set_curthread(struct pthread *);
int     _thread_create(pthread_t *, const pthread_attr_t *,
		       void *(*start_routine)(void *), void *,pthread_t);
void    _dispatch_signals(pthread_t, struct sigcontext *);
void    _thread_signal(pthread_t, int);
int	_mutex_cv_lock(pthread_mutex_t *);
int	_mutex_cv_unlock(pthread_mutex_t *);
int	_mutex_reinit(pthread_mutex_t *);
void	_mutex_notify_priochange(struct pthread *);
int	_cond_reinit(pthread_cond_t *);
int	_pq_alloc(struct pq_queue *, int, int);
int	_pq_init(struct pq_queue *);
void	_pq_remove(struct pq_queue *pq, struct pthread *);
void	_pq_insert_head(struct pq_queue *pq, struct pthread *);
void	_pq_insert_tail(struct pq_queue *pq, struct pthread *);
struct pthread *_pq_first(struct pq_queue *pq);
void	_waitq_insert(pthread_t pthread);
void	_waitq_remove(pthread_t pthread);
#if defined(_PTHREADS_INVARIANTS)
void	_waitq_setactive(void);
void	_waitq_clearactive(void);
#endif
__dead void _thread_exit(const char *, int, const char *) __attribute__((__noreturn__));
void    *_thread_cleanup(pthread_t);
void    _thread_cleanupspecific(void);
void	_thread_dump_data(const void *, int);
void    _thread_dump_info(void);
void    _thread_init(void);
void    _thread_kern_sched(struct sigcontext *);
void    _thread_kern_sched_sig(void);
void    _thread_kern_sched_state(enum pthread_state,char *fname,int lineno);
void	_thread_kern_sched_state_unlock(enum pthread_state state,
	    spinlock_t *lock, char *fname, int lineno);
void    _thread_kern_set_timeout(const struct timespec *);
void    _thread_kern_sig_defer(void);
void    _thread_kern_sig_undefer(void);
void    _thread_sig_handler(int, siginfo_t *, struct sigcontext *);
void    _thread_sig_handle(int, struct sigcontext *);
void	_thread_sig_init(void);
void	_thread_sig_process(int, struct sigcontext *);
void    _thread_start(void);
void    _thread_start_sig_handler(void);
void	_thread_seterrno(pthread_t,int);
int     _thread_fd_table_init(int fd);
pthread_addr_t _thread_gc(pthread_addr_t);
void	_thread_enter_cancellation_point(void);
void	_thread_leave_cancellation_point(void);
void	_thread_cancellation_point(void);
int	_thread_slow_atomic_lock(volatile _spinlock_lock_t *);
int	_thread_slow_atomic_is_locked(volatile _spinlock_lock_t *);
struct stack * _thread_stack_alloc(void *, size_t);
void	_thread_stack_free(struct stack *);


/* #include <signal.h> */
#ifdef _USER_SIGNAL_H
int	_thread_sys_kill(pid_t, int);
int     _thread_sys_sigaction(int, const struct sigaction *, struct sigaction *);
int     _thread_sys_sigpending(sigset_t *);
int     _thread_sys_sigprocmask(int, const sigset_t *, sigset_t *);
int     _thread_sys_sigsuspend(const sigset_t *);
int     _thread_sys_siginterrupt(int, int);
int     _thread_sys_sigpause(int);
int     _thread_sys_sigreturn(struct sigcontext *);
int     _thread_sys_sigaltstack(const struct sigaltstack *, struct sigaltstack *);
int     _thread_sys_sigvec(int, struct sigvec *, struct sigvec *);
void    _thread_sys_psignal(unsigned int, const char *);
void    (*_thread_sys_signal(int, void (*)(int)))(int);
#endif

/* #include <sys/stat.h> */
#ifdef  _SYS_STAT_H_
int     _thread_sys_fchmod(int, mode_t);
int     _thread_sys_fstat(int, struct stat *);
int     _thread_sys_fchflags(int, unsigned int);
#endif

/* #include <sys/mount.h> */
#ifdef  _SYS_MOUNT_H_
int     _thread_sys_fstatfs(int, struct statfs *);
#endif
int     _thread_sys_pipe(int *);

/* #include <sys/socket.h> */
#ifdef  _SYS_SOCKET_H_
int     _thread_sys_accept(int, struct sockaddr *, socklen_t *);
int     _thread_sys_bind(int, const struct sockaddr *, socklen_t);
int     _thread_sys_connect(int, const struct sockaddr *, socklen_t);
int     _thread_sys_getpeername(int, struct sockaddr *, socklen_t *);
int     _thread_sys_getsockname(int, struct sockaddr *, socklen_t *);
int     _thread_sys_getsockopt(int, int, int, void *, socklen_t *);
int     _thread_sys_listen(int, int);
int     _thread_sys_setsockopt(int, int, int, const void *, socklen_t);
int     _thread_sys_shutdown(int, int);
int     _thread_sys_socket(int, int, int);
int     _thread_sys_socketpair(int, int, int, int *);
ssize_t _thread_sys_recv(int, void *, size_t, int);
ssize_t _thread_sys_recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *);
ssize_t _thread_sys_recvmsg(int, struct msghdr *, int);
ssize_t _thread_sys_send(int, const void *, size_t, int);
ssize_t _thread_sys_sendmsg(int, const struct msghdr *, int);
ssize_t _thread_sys_sendto(int, const void *,size_t, int, const struct sockaddr *, socklen_t);
#endif

/* #include <stdio.h> */
#ifdef  _STDIO_H_
FILE    *_thread_sys_fdopen(int, const char *);
FILE    *_thread_sys_fopen(const char *, const char *);
FILE    *_thread_sys_freopen(const char *, const char *, FILE *);
FILE    *_thread_sys_popen(const char *, const char *);
FILE    *_thread_sys_tmpfile(void);
char    *_thread_sys_ctermid(char *);
char    *_thread_sys_cuserid(char *);
char    *_thread_sys_fgetln(FILE *, size_t *);
char    *_thread_sys_fgets(char *, int, FILE *);
char    *_thread_sys_gets(char *);
char    *_thread_sys_tempnam(const char *, const char *);
char    *_thread_sys_tmpnam(char *);
int     _thread_sys_fclose(FILE *);
int     _thread_sys_feof(FILE *);
int     _thread_sys_ferror(FILE *);
int     _thread_sys_fflush(FILE *);
int     _thread_sys_fgetc(FILE *);
int     _thread_sys_fgetpos(FILE *, fpos_t *);
int     _thread_sys_fileno(FILE *);
int     _thread_sys_fprintf(FILE *, const char *, ...);
int     _thread_sys_fpurge(FILE *);
int     _thread_sys_fputc(int, FILE *);
int     _thread_sys_fputs(const char *, FILE *);
int     _thread_sys_fscanf(FILE *, const char *, ...);
int     _thread_sys_fseek(FILE *, long, int);
int     _thread_sys_fsetpos(FILE *, const fpos_t *);
int     _thread_sys_getc(FILE *);
int     _thread_sys_getchar(void);
int     _thread_sys_getw(FILE *);
int     _thread_sys_pclose(FILE *);
int     _thread_sys_printf(const char *, ...);
int     _thread_sys_putc(int, FILE *);
int     _thread_sys_putchar(int);
int     _thread_sys_puts(const char *);
int     _thread_sys_putw(int, FILE *);
int     _thread_sys_remove(const char *);
int     _thread_sys_rename (const char *, const char *);
int     _thread_sys_scanf(const char *, ...);
int     _thread_sys_setlinebuf(FILE *);
int     _thread_sys_setvbuf(FILE *, char *, int, size_t);
int     _thread_sys_snprintf(char *, size_t, const char *, ...);
int     _thread_sys_sprintf(char *, const char *, ...);
int     _thread_sys_sscanf(const char *, const char *, ...);
int     _thread_sys_ungetc(int, FILE *);
int     _thread_sys_vfprintf(FILE *, const char *, _BSD_VA_LIST_);
int     _thread_sys_vprintf(const char *, _BSD_VA_LIST_);
int     _thread_sys_vscanf(const char *, _BSD_VA_LIST_);
int     _thread_sys_vsnprintf(char *, size_t, const char *, _BSD_VA_LIST_);
int     _thread_sys_vsprintf(char *, const char *, _BSD_VA_LIST_);
int     _thread_sys_vsscanf(const char *, const char *, _BSD_VA_LIST_);
long    _thread_sys_ftell(FILE *);
size_t  _thread_sys_fread(void *, size_t, size_t, FILE *);
size_t  _thread_sys_fwrite(const void *, size_t, size_t, FILE *);
void    _thread_sys_clearerr(FILE *);
void    _thread_sys_perror(const char *);
void    _thread_sys_rewind(FILE *);
void    _thread_sys_setbuf(FILE *, char *);
void    _thread_sys_setbuffer(FILE *, char *, int);
#endif

/* #include <unistd.h> */
#ifdef  _UNISTD_H_
char    *_thread_sys_ttyname(int);
int     _thread_sys_close(int);
int     _thread_sys_dup(int);
int     _thread_sys_dup2(int, int);
int     _thread_sys_exect(const char *, char * const *, char * const *);
int     _thread_sys_execve(const char *, char * const *, char * const *);
int     _thread_sys_fchdir(int);
int     _thread_sys_fchown(int, uid_t, gid_t);
int     _thread_sys_fsync(int);
int     _thread_sys_ftruncate(int, off_t);
long	_thread_sys_fpathconf(int, int);
pid_t	_thread_sys_getpid(void);
int     _thread_sys_pause(void);
int     _thread_sys_pipe(int *);
int     _thread_sys_select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
off_t   _thread_sys_lseek(int, off_t, int);
pid_t   _thread_sys_fork(void);
pid_t   _thread_sys_tcgetpgrp(int);
ssize_t _thread_sys_read(int, void *, size_t);
ssize_t _thread_sys_write(int, const void *, size_t);
__dead void	_thread_sys__exit(int) __attribute__((__noreturn__));
#endif

/* #include <fcntl.h> */
#ifdef  _SYS_FCNTL_H_
int     _thread_sys_creat(const char *, mode_t);
int     _thread_sys_fcntl(int, int, ...);
int     _thread_sys_flock(int, int);
int     _thread_sys_open(const char *, int, ...);
#endif

/* #include <sys/ioctl.h> */
#ifdef  _SYS_IOCTL_H_
int     _thread_sys_ioctl(int, unsigned long, ...);
#endif

/* #include <dirent.h> */
#ifdef  _DIRENT_H_
DIR     *___thread_sys_opendir2(const char *, int);
DIR     *_thread_sys_opendir(const char *);
int     _thread_sys_alphasort(const void *, const void *);
int     _thread_sys_scandir(const char *, struct dirent ***,
	int (*)(struct dirent *), int (*)(const void *, const void *));
int     _thread_sys_closedir(DIR *);
int     _thread_sys_getdirentries(int, char *, int, long *);
long    _thread_sys_telldir(const DIR *);
struct  dirent *_thread_sys_readdir(DIR *);
void    _thread_sys_rewinddir(DIR *);
void    _thread_sys_seekdir(DIR *, long);
#endif

/* #include <sys/uio.h> */
#ifdef  _SYS_UIO_H_
ssize_t _thread_sys_readv(int, const struct iovec *, int);
ssize_t _thread_sys_writev(int, const struct iovec *, int);
#endif

/* #include <sys/wait.h> */
#ifdef  _SYS_WAIT_H_
pid_t   _thread_sys_wait(int *);
pid_t   _thread_sys_waitpid(pid_t, int *, int);
pid_t   _thread_sys_wait3(int *, int, struct rusage *);
pid_t   _thread_sys_wait4(pid_t, int *, int, struct rusage *);
#endif

/* #include <poll.h> */
#ifdef _SYS_POLL_H_
int 	_thread_sys_poll(struct pollfd *, unsigned, int);
#endif

/* #include <sys/event.h> */
#ifdef _SYS_EVENT_H_
int     _thread_sys_kevent(int, const struct kevent *, int, struct kevent *,
	int, const struct timespec *);
#endif

/* #include <sys/mman.h> */
int	_thread_sys_msync(void *, size_t, int);

__END_DECLS

#endif  /* !_PTHREAD_PRIVATE_H */
@


1.40
log
@add a debugging function not normally called
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.39 2002/12/08 04:06:01 marc Exp $	*/
@


1.39
log
@remove unused data member from pthread_cond.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.38 2002/11/12 20:12:45 marc Exp $	*/
d1098 1
@


1.38
log
@get rid of compiler warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.37 2002/10/30 20:05:11 marc Exp $	*/
a298 1
	void				*c_data;
@


1.37
log
@
removes duplicate functions and factor out common code so the needed (but
missing) _thread_fd_unlock_owned function can be added with minimal pain.
The incorrect special handling of the stdio fds was also removed.

Tested with the libc_r regression tests and the mysql regression tests.
No complaints from any developers
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.36 2002/10/30 19:11:56 marc Exp $	*/
a1089 1
#if defined(_PTHREADS_INVARIANTS)
d1092 1
@


1.36
log
@signal handling changes.   This corrects several signal
handling errors in the threads library.   Most of the libc_r regression
tests are now ok.   thread specific kill semantics are still not correct.
No negative comments after posting to tech@@ a week or so ago.
siginfo test fails on sparc64 due to sparc64 oddity.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.35 2002/02/21 20:57:41 fgsch Exp $	*/
d490 1
a490 1
 * File descriptor locking definitions.
a491 3
#define FD_READ             0x1
#define FD_WRITE            0x2
#define FD_RDWR             (FD_READ | FD_WRITE)
a927 7

/*
 * Standard I/O file descriptors need special flag treatment since
 * setting one to non-blocking does all on *BSD. Sigh. This array
 * is used to store the initial flag settings.
 */
SCLASS int	_pthread_stdio_flags[3];
@


1.35
log
@account for the process signal mask when dealing with signals; tested
a while ago by marc@@ and brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.34 2002/01/19 23:49:32 fgsch Exp $	*/
d1085 3
a1087 2
int     _thread_create(pthread_t *,const pthread_attr_t *,void *(*start_routine)(void *),void *,pthread_t);
void    _dispatch_signals(void);
d1119 1
a1119 1
void    _thread_sig_handler(int, int, struct sigcontext *);
d1122 1
@


1.34
log
@Instead of ifdef around ENOTSUP, move it to pthread_private.h and make
it EOPNOTSUPP.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.33 2001/12/31 18:23:15 fgsch Exp $	*/
d1000 10
d1111 1
@


1.33
log
@More changes from FreeBSD, including:

o Only poll file descriptors when needed.
o Change the way timing is achieved, counting scheduling ticks
  instead of calculating the elapsed time via gettimeofday().
o Prevent an overflow when polling.
o Use curthread instead of _thread_run.
o Remove extra spaces; indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.32 2001/12/19 02:02:52 fgsch Exp $	*/
d63 5
@


1.32
log
@More sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.31 2001/12/11 00:19:47 fgsch Exp $	*/
d258 1
a258 1
 * Flags for mutexes. 
d265 1
a265 1
 * Static mutex initialization values. 
d317 1
a317 1
 * Static cond initialization values. 
d415 1
a415 1
 * Clock resolution in nanoseconds.
d417 2
a418 1
#define CLOCK_RES_NSEC				10000000
d423 1
a423 1
#define TIMESLICE_USEC				100000
d631 2
a632 2
	/* Time that this thread was last made active. */
	struct  timeval		last_active;
d634 2
a635 2
	/* Time that this thread was last made inactive. */
	struct  timeval		last_inactive;
d654 1
a654 1
	 * returns a pointer to this. 
d963 1
a963 1
SCLASS int    _clock_res_nsec		/* Clock resolution in nsec.	*/
d965 1
a965 1
= CLOCK_RES_NSEC;
@


1.31
log
@More sync with freebsd code; join related code this time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.30 2001/12/08 14:51:36 fgsch Exp $	*/
d123 8
d148 2
d658 1
a658 1
	 * The joiner is the thread that is joining this thraed. The
d666 1
a666 2
	 * a time (ready or waiting queue).  It can also belong to (only)
	 * one of:
d674 11
d686 2
a687 1
	 * and qe for other links.
d690 3
a692 8
	/* Priority queue entry for this thread: */
	pthread_entry_t		pqe;

	/* Priority queue entry for this thread: */
	pthread_entry_t		sqe;

	/* Queue entry for this thread: */
	pthread_entry_t		qe;
d723 1
a723 1
	/* Miscellaneous data. */
d727 2
a728 2
#define PTHREAD_FLAGS_IN_WAITQ	0x0004	/* in waiting queue using pqe link*/
#define PTHREAD_FLAGS_IN_PRIOQ	0x0008	/* in priority queue using pqe link*/
d732 2
a733 2
#define PTHREAD_FLAGS_IN_CONDQ	0x0080	/* in condition queue using sqe link*/
#define PTHREAD_FLAGS_IN_MUTEXQ	0x0100	/* in mutex queue using sqe link*/
d735 1
a735 1
#define PTHREAD_FLAGS_IN_SYNQ	\
d1011 15
d1032 3
@


1.30
log
@Partially sync with FreeBSD; mostly pthread_cancel(3) related changes.
make includes is needed in case you want to play.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.29 2001/09/04 23:28:31 fgsch Exp $	*/
d541 6
d647 6
a652 2
	/* Join queue head and link for waiting threads: */
	V_TAILQ_HEAD(join_head, pthread)	join_queue;
a660 2
	 *   o A queue of threads waiting for another thread to terminate
	 *     (the join queue above)
d672 3
a1031 1
int     _find_dead_thread(pthread_t);
@


1.29
log
@Use _waitq_remove() and _waitq_insert() always; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.28 2001/09/04 22:17:45 fgsch Exp $	*/
a590 6
	 * Cancelability state.
	 */
	int	cancelstate;
	int	canceltype;

	/*
d700 10
a709 7
#define PTHREAD_FLAGS_IN_CONDQ	0x0004	/* in condition queue using qe link*/
#define PTHREAD_FLAGS_IN_WORKQ	0x0008	/* in work queue using qe link */
#define PTHREAD_FLAGS_IN_WAITQ	0x0010	/* in waiting queue using pqe link*/
#define PTHREAD_FLAGS_IN_PRIOQ	0x0020	/* in priority queue using pqe link*/
#define PTHREAD_FLAGS_TRACE	0x0040	/* for debugging purposes */
#define PTHREAD_FLAGS_CANCELED	0x1000	/* thread has been cancelled */
#define PTHREAD_FLAGS_CANCELPT	0x2000	/* thread at cancel point */
@


1.28
log
@put changes back, this time ALL the files.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.26 2001/08/30 07:40:47 fgsch Exp $	*/
a84 1
#if defined(_PTHREADS_INVARIANTS)
d87 2
a91 17
#define PTHREAD_WAITQ_REMOVE(thrd)	TAILQ_REMOVE(&_waitingq,thrd,pqe)
#define PTHREAD_WAITQ_INSERT(thrd) do {					\
	if ((thrd)->wakeup_time.tv_sec == -1)				\
		TAILQ_INSERT_TAIL(&_waitingq,thrd,pqe);			\
	else {								\
		pthread_t tid = TAILQ_FIRST(&_waitingq);		\
		while ((tid != NULL) && (tid->wakeup_time.tv_sec != -1) && \
		    ((tid->wakeup_time.tv_sec < (thrd)->wakeup_time.tv_sec) ||	\
		    ((tid->wakeup_time.tv_sec == (thrd)->wakeup_time.tv_sec) &&	\
		    (tid->wakeup_time.tv_nsec <= (thrd)->wakeup_time.tv_nsec)))) \
			tid = TAILQ_NEXT(tid, pqe);			\
		if (tid == NULL)					\
			TAILQ_INSERT_TAIL(&_waitingq,thrd,pqe);		\
		else							\
			TAILQ_INSERT_BEFORE(tid,thrd,pqe);		\
	}								\
} while (0)
@


1.27
log
@Back out fgsch@@'s tree breaking commits.
Test next time, ok?
@
text
@a648 6
	 * Incremental priority accumulated by thread while it is ready to
	 * run but is denied being run.
	 */
	int	inc_prio;

	/*
a875 3
/* Last time that an incremental priority update was performed: */
extern struct timeval   kern_inc_prio_time;

d979 7
d1070 1
a1070 1
void    _thread_kern_sched_state(enum pthread_state,const char *fname,int lineno);
@


1.26
log
@fix some const warnings.
more sync with freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.25 2001/08/29 18:33:54 fgsch Exp $	*/
d649 6
d882 3
a987 7
 * Array of counts of dummy handlers for SIG_DFL signals.  This is used to
 * assure that there is always a dummy signal handler installed while there is a
 * thread sigwait()ing on the corresponding signal.
 */
SCLASS int	_thread_dfl_count[NSIG];

/*
d1072 1
a1072 1
void    _thread_kern_sched_state(enum pthread_state,char *fname,int lineno);
@


1.25
log
@More sync with FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.24 2001/08/26 00:49:03 fgsch Exp $	*/
a648 6
	 * Incremental priority accumulated by thread while it is ready to
	 * run but is denied being run.
	 */
	int	inc_prio;

	/*
a875 3
/* Last time that an incremental priority update was performed: */
extern struct timeval   kern_inc_prio_time;

d979 7
d1070 1
a1070 1
void    _thread_kern_sched_state(enum pthread_state,const char *fname,int lineno);
@


1.24
log
@More syncing with FreeBSD, preparing for a commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.23 2001/08/21 19:24:53 fgsch Exp $	*/
d42 9
d795 1
a795 1
extern struct pthread   _thread_kern_thread;
d798 6
a803 1
extern struct pthread   * volatile _thread_run;
d806 6
a811 1
extern struct pthread   * volatile _last_user_thread;
d817 6
a822 1
extern struct pthread   * volatile _thread_single;
d824 6
a829 1
extern _thread_list_t		_thread_list;
d835 46
a880 3
extern int		_thread_kern_pipe[2];
extern volatile int	_queue_signals;
extern volatile int	_thread_kern_in_sched;
d886 6
a891 1
extern _thread_list_t		_dead_list;
d894 6
a899 1
extern struct pthread *_thread_initial;
d902 8
a909 1
extern struct pthread_attr pthread_attr_default;
d912 6
a917 1
extern struct pthread_mutex_attr pthread_mutexattr_default;
d920 6
a925 1
extern struct pthread_cond_attr pthread_condattr_default;
d932 1
a932 1
extern int	_pthread_stdio_flags[3];
d935 6
a940 1
extern struct fd_table_entry **_thread_fd_table;
d943 6
a948 1
extern struct pollfd *_thread_pfd_table;
d950 12
a961 2
extern const int dtablecount;
extern int    _thread_dtablesize;       /* Descriptor table size.           */
d963 6
a968 1
extern int    _clock_res_nsec;		/* Clock resolution in nsec.	*/
d971 10
a980 2
extern	pthread_mutex_t _gc_mutex;
extern	pthread_cond_t  _gc_cond;
d985 1
a985 1
extern struct  sigaction _thread_sigact[NSIG];
d990 2
a991 2
extern pq_queue_t		_readyq;
extern _thread_list_t		_waitingq;
d996 1
a996 1
extern _thread_list_t		_workq;
d999 5
a1003 1
extern	volatile int	_spinblock_count;
d1006 5
a1010 1
extern	volatile int	_sigq_check_reqd;
d1013 5
a1017 1
extern	pthread_switch_routine_t _sched_switch_hook;
d1028 9
a1036 1
extern int	_thread_kern_new_state;
@


1.23
log
@Start syncing with FreeBSD:

o Implement _get_curthread() and _set_curthread(). Use it where possible.
o Add missing _thread_[enter|leave]_cancellation_point().
o Add a couple of not yet used vars to pthread_private.h.
o Remove return's from void functions.

This is by no means complete, but instead of doing a big commit, i'll
split it in small ones, minimizing diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.22 2001/08/15 23:50:34 fgsch Exp $	*/
d45 1
a219 1

d266 1
a266 1
	NULL, { NULL }, 0, 0, 0, 0, TAILQ_INITIALIZER, \
d276 3
d318 13
a330 1
	0, _SPINLOCK_INITIALIZER }
d362 12
d383 1
d385 17
a401 2
#define PTHREAD_DEFAULT_PRIORITY		64
#define PTHREAD_MAX_PRIORITY			126
d403 7
a409 1
#define _POSIX_THREAD_ATTR_STACKSIZE
d421 12
d523 1
a523 1
		const char *fname;	/* Source file name for debugging.*/
d525 2
a526 1
	struct pthread_poll_data * poll_data;
d528 1
d540 6
d604 13
d621 2
d767 1
a767 1
	const char		*fname;	/* Ptr to source file name  */
@


1.22
log
@* kevent(2) support; from FreeBSD.
* change _thread_kern_set_timeout() parm to const.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.21 2000/12/06 17:18:47 deraadt Exp $	*/
d281 1
a281 1
#define COND_TYPE_MAX	((int)COND_TYPE_FAST + 1)
d290 1
d337 1
d414 2
a415 2
	PS_DEADLOCK
#define PS_STATE_MAX	((int)PS_DEADLOCK + 1)
d808 2
@


1.21
log
@use __x__ formats for __attribute__ arguments; guenther@@gac.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.20 2000/10/04 05:55:35 d Exp $	*/
d835 1
a835 1
void    _thread_kern_set_timeout(struct timespec *);
d1037 6
@


1.20
log
@switch to _machdep_switch() instead of setjmp/longjmp. For some reason this fixes sparc threads.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.19 2000/01/06 07:13:56 d Exp $	*/
d826 1
a826 1
__dead void _thread_exit(const char *, int, const char *) __attribute__((noreturn));
d989 1
a989 1
__dead void	_thread_sys__exit(int) __attribute__((noreturn));
@


1.19
log
@volatile; thread_private.h; locking defines moved out; kill(), getpid()
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.18 1999/11/25 07:01:30 d Exp $	*/
a43 1
#include <setjmp.h>
a514 6
	/* 
	 * Saved jump buffer used in call to longjmp by _thread_kern_sched
	 * if sig_saved is FALSE.
	 */
	_machdep_jmp_buf	saved_jmp_buf;

d516 1
a516 1
	 * Further machine-dependent context, valid if sig_saved is FALSE.
d518 1
a518 1
	struct _machdep_struct	_machdep;
d686 10
d853 1
@


1.18
log
@sync with FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
d172 16
d194 1
a194 1
	TAILQ_HEAD(, pthread)	pl_head; /* list of threads at this priority */
d220 1
d224 1
a224 1
	TAILQ_HEAD(mutex_head, pthread)	m_queue;
d247 1
a247 1
	TAILQ_ENTRY(pthread_mutex)	m_qe;
d287 1
a287 1
	TAILQ_HEAD(cond_head, pthread)	c_queue;
d436 2
a437 2
	TAILQ_HEAD(, pthread)	r_queue;	/* Read queue.                        */
	TAILQ_HEAD(, pthread)	w_queue;	/* Write queue.                       */
d476 1
a476 1
typedef TAILQ_ENTRY(pthread) pthread_entry_t;
d582 1
a582 1
	TAILQ_HEAD(join_head, pthread)	join_queue;
d680 1
a680 1
	TAILQ_HEAD(, pthread_mutex)	mutexq;
a710 2
/* List of all threads: */
typedef TAILQ_HEAD(, pthread)	_thread_list_t;
d718 2
a719 2
extern int		volatile _queue_signals;
extern int              _thread_kern_in_sched;
d784 1
a784 1
extern pthread_switch_routine_t _sched_switch_hook;
a796 12
#ifdef	_LOCK_DEBUG
#define	_FD_LOCK(_fd,_type,_ts)		_thread_fd_lock_debug(_fd, _type, \
						_ts, __FILE__, __LINE__)
#define _FD_UNLOCK(_fd,_type)		_thread_fd_unlock_debug(_fd, _type, \
						__FILE__, __LINE__)
#else
#define	_FD_LOCK(_fd,_type,_ts)		_thread_fd_lock(_fd, _type, _ts)
#define _FD_UNLOCK(_fd,_type)		_thread_fd_unlock(_fd, _type)
#endif

extern int __isthreaded;

a803 2
int     _thread_fd_lock(int, int, struct timespec *);
int     _thread_fd_lock_debug(int, int, struct timespec *,const char *fname,int lineno);
a823 2
void    _thread_fd_unlock(int, int);
void    _thread_fd_unlock_debug(int, int, const char *, int);
d853 1
d976 1
@


1.17
log
@TAILQ_FOREACH now is in queue.h
@
text
@d1 1
d24 1
a24 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d35 1
a35 2
 * $OpenBSD: pthread_private.h,v 1.16 1999/06/15 00:07:39 d Exp $
 *
a40 2
#include <paths.h>

a51 1
#ifndef _NO_UTHREAD_MACHDEP
a52 1
#endif
d65 1
a65 1
 * Priority queue manipulation macros:
d70 1
a70 1
#define PTHREAD_PRIOQ_FIRST		_pq_first(&_readyq)
d73 1
a73 1
 * Waiting queue manipulation macros:
d75 6
a80 1
#define PTHREAD_WAITQ_INSERT(thrd)	TAILQ_INSERT_TAIL(&_waitingq,thrd,pqe)
d82 32
d118 1
a118 1
#define PTHREAD_SET_STATE(thrd, newstate) {				\
d122 1
a122 1
}
d128 19
a146 1
#define PTHREAD_NEW_STATE(thrd, newstate) {				\
d157 2
a158 1
}
a171 9
 * Queue definitions.
 */
struct pthread_queue {
	struct pthread	*q_next;
	struct pthread	*q_last;
	void		*q_data;
};

/*
a190 5
 * Static queue initialization values. 
 */
#define PTHREAD_QUEUE_INITIALIZER { NULL, NULL, NULL }

/*
d193 1
a193 1
#define TAILQ_INITIALIZER { NULL, NULL }
d264 1
a264 1
	COND_TYPE_MAX
d296 2
a297 2
 	{ COND_TYPE_FAST, PTHREAD_QUEUE_INITIALIZER, NULL, NULL, \
 	0, _SPINLOCK_INITIALIZER }
d331 7
a348 6
 * Number of microseconds between incremental priority updates for
 * threads that are ready to run, but denied being run.
 */
#define INC_PRIO_USEC				500000

/*
d385 1
d395 2
a396 2
	PS_DEADLOCK,
	PS_STATE_MAX
d418 2
a419 2
	struct pthread_queue	r_queue;	/* Read queue.                        */
	struct pthread_queue	w_queue;	/* Write queue.                       */
d431 1
a431 1
struct pthread_select_data {
d433 1
a433 3
	fd_set	readfds;
	fd_set	writefds;
	fd_set	exceptfds;
d445 1
a445 1
	struct pthread_select_data * select_data;
d449 11
d477 2
a478 4
	/*
	 * Pointer to the next thread in the thread linked list.
	 */
	struct pthread	*nxt;
d480 2
a481 4
	/*
	 * Pointer to the next thread in the dead thread linked list.
	 */
	struct pthread	*nxt_dead;
d489 1
a489 1
	void			*stack;
d498 11
a542 6
	 * Cumulative times spent in thread
	 */
	struct	timeval		ru_utime;
	struct	timeval		ru_stime;

	/*
d563 2
a564 2
	/* Join queue for waiting threads: */
	struct pthread_queue	join_queue;
d567 3
a569 5
	 * The current thread can belong to only one scheduling queue
	 * at a time (ready or waiting queue).  It can also belong to
	 * a queue of threads waiting on mutexes or condition variables.
	 * Use pqe for the scheduling queue link (both ready and waiting),
	 * and qe for other links (mutexes and condition variables).
d571 7
a577 1
	 * Pointer to queue (if any) on which the current thread is waiting.
d579 2
a580 2
	 * XXX The queuing should be changed to use the TAILQ entry below.
	 * XXX For the time being, it's hybrid.
a581 4
	struct pthread_queue	*queue;

	/* Pointer to next element in queue. */
	struct pthread	*qnxt;
d584 1
a584 1
	TAILQ_ENTRY(pthread)	pqe;
d587 1
a587 1
	TAILQ_ENTRY(pthread)	qe;
d593 5
d607 2
a608 2
	 * Set to non-zero when this thread has deferred thread
	 * scheduling.  We allow for recursive deferral.
d610 1
a610 1
	int		sched_defer_count;
d614 1
a614 1
	 * thread scheduling.
d616 1
a616 1
	int		yield_on_sched_undefer;
d622 7
a628 4
#define PTHREAD_FLAGS_QUEUED	0x0004	/* in queue (qe is used) */
#define PTHREAD_FLAGS_TRACE	0x0008
#define PTHREAD_CANCELLING	0x0010	/* thread has been cancelled */
#define PTHREAD_AT_CANCEL_POINT	0x0020	/* thread at cancel point */
d651 1
a651 1
	 * in either the real or inherited priority, the active
a671 11

	/* 
	 * Saved jump buffer used in call to longjmp by _thread_kern_sched
	 * if sig_saved is FALSE.
	 */
	_machdep_jmp_buf	saved_jmp_buf;

#ifndef _UTHREAD_MACHDEP
	/* Machine dependent information */
	struct _machdep_struct	_machdep;
#endif
d679 1
a679 2
extern struct pthread   volatile _thread_kern_thread;
extern struct pthread   * volatile _thread_kern_threadp;
d685 1
a685 1
extern struct pthread	* volatile _last_user_thread;
d693 3
a695 2
/* Ptr to the first thread in the thread linked list: */
extern struct pthread   * volatile _thread_link_list;
d701 2
a702 2
extern int              _thread_kern_pipe[2];
extern int              _thread_kern_in_select;
d709 1
a709 1
extern struct pthread * volatile _thread_dead;
d732 4
d737 3
a739 1
extern int    _thread_dtablesize;
d742 2
a743 2
extern pthread_mutex_t _gc_mutex;
extern pthread_cond_t _gc_cond;
d754 6
a759 2
typedef TAILQ_HEAD(, pthread)	_waitingq_t;
extern _waitingq_t		_waitingq;
d761 5
a765 2
/* Indicates that the waitingq now has threads ready to run. */
extern volatile int	_waitingq_check_reqd;
d771 3
a773 1
 * Where SIGINFO writes thread states when /dev/tty cannot be opened
d775 5
a779 1
#define INFO_DUMP_FILE  "/tmp/uthread.dump"
d791 2
a803 4
void    _lock_thread(void);
void    _lock_thread_list(void);
void    _unlock_thread(void);
void    _unlock_thread_list(void);
d806 1
d808 3
a810 1
int	_pq_init(struct pq_queue *pq, int, int);
d815 7
a821 2
void    _thread_exit(const char *, int, const char *)
		__attribute__((noreturn));
d823 1
a823 1
void    _thread_fd_unlock_debug(int, int, char *, int);
d829 1
a829 1
void    _thread_kern_sched_state(enum pthread_state, const char *, int);
d833 2
a834 2
void    _thread_kern_sched_defer(void);
void    _thread_kern_sched_undefer(void);
d836 2
a840 3
void    _thread_queue_init(struct pthread_queue *);
void    _thread_queue_enq(struct pthread_queue *, struct pthread *);
int     _thread_queue_remove(struct pthread_queue *, struct pthread *);
a841 2
struct pthread *_thread_queue_get(struct pthread_queue *);
struct pthread *_thread_queue_deq(struct pthread_queue *);
d848 2
d974 1
a974 1
long    _thread_sys_fpathconf(int, int);
d983 1
a983 2
void	_thread_sys__exit(int)
		__attribute__((noreturn));
d1021 1
a1021 1
#ifdef _SYS_WAIT_H_
d1028 1
a1028 1
/* #include <sys/poll.h> */
d1030 1
a1030 1
int	_thread_sys_poll(struct pollfd[], int, int);
@


1.16
log
@Remove pthread_atfork(). It was only part of draft 10 for a little while and was removed before stddization.
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.15 1999/06/09 07:06:54 d Exp $
a55 6
#endif

#ifdef __OpenBSD__
/* Steal TAILQ_FOREACH from FreeBSD's <sys/queue.h> */
#define TAILQ_FOREACH(var, head, field)                                 \
        for (var = TAILQ_FIRST(head); var; var = TAILQ_NEXT(var, field))
@


1.15
log
@sync with freebsd
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.14 1999/05/26 00:18:21 d Exp $
a303 4
#define PTHREAD_ATFORK_PREPARE			0
#define PTHREAD_ATFORK_PARENT			1
#define PTHREAD_ATFORK_CHILD			2

a782 1
void	_thread_atfork(int);
@


1.14
log
@sync with FreeBSD
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.13 1999/02/16 16:44:07 millert Exp $
d217 2
a218 1
	NULL, { NULL }, MUTEX_FLAGS_INITED, 0, 0, 0, TAILQ_INITIALIZER }
d264 2
a265 2
	{ COND_TYPE_FAST, PTHREAD_QUEUE_INITIALIZER, NULL, NULL, \
	COND_FLAGS_INITED }
@


1.13
log
@update prototypes now that socket functions take socklen_t as a length parameter
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.12 1999/01/18 00:03:35 d Exp $
d53 1
d58 6
d73 15
d89 1
a89 1
 * State change macro:
d91 1
a91 1
#define PTHREAD_NEW_STATE(thrd, newstate) {				\
d98 28
d135 19
d158 5
d173 2
a174 1
	struct pthread_queue		m_queue;
d178 20
d216 2
a217 2
	{ MUTEX_TYPE_FAST, PTHREAD_QUEUE_INITIALIZER, \
	NULL, { NULL }, MUTEX_FLAGS_INITED }
d221 2
d235 5
a239 4
	enum pthread_cond_type	c_type;
	struct pthread_queue	c_queue;
	void			*c_data;
	long			c_flags;
d244 1
a244 1
	spinlock_t		lock;
d263 2
a264 1
	{ COND_TYPE_FAST, PTHREAD_QUEUE_INITIALIZER, NULL, COND_FLAGS_INITED }
d276 3
a278 1
	int	schedparam_policy;
d360 1
d364 1
d408 2
a409 2
	pthread_mutex_t	*mutex;
	pthread_cond_t	*cond;
d417 1
d526 5
a530 1
	 * The current thread can belong to only one queue at a time.
d542 3
d546 1
a546 1
	TAILQ_ENTRY(pthread) qe;
d560 12
d574 41
a614 4
#define PTHREAD_EXITING		(0x0100)
#define PTHREAD_CANCELLING	(0x0200)	/* thread has been cancelled */
#define PTHREAD_AT_CANCEL_POINT	(0x0400)	/* thread at cancel point */
	char		pthread_priority;
d647 3
d694 1
d707 13
d749 8
d764 1
a764 1
void    _thread_init(void) /* __attribute__((constructor)) */;
d770 2
d913 1
a913 1
long	_thread_sys_fpathconf(int, int);
@


1.12
log
@move private spinlock protos out
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.11 1999/01/18 00:00:32 d Exp $
d633 6
a638 6
int     _thread_sys_accept(int, struct sockaddr *, int *);
int     _thread_sys_bind(int, const struct sockaddr *, int);
int     _thread_sys_connect(int, const struct sockaddr *, int);
int     _thread_sys_getpeername(int, struct sockaddr *, int *);
int     _thread_sys_getsockname(int, struct sockaddr *, int *);
int     _thread_sys_getsockopt(int, int, int, void *, int *);
d640 1
a640 1
int     _thread_sys_setsockopt(int, int, int, const void *, int);
d645 1
a645 1
ssize_t _thread_sys_recvfrom(int, void *, size_t, int, struct sockaddr *, int *);
d649 1
a649 1
ssize_t _thread_sys_sendto(int, const void *,size_t, int, const struct sockaddr *, int);
@


1.11
log
@sync with previous changes
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.10 1999/01/10 22:32:23 d Exp $
d600 2
@


1.10
log
@fix proto
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.9 1999/01/08 05:44:53 d Exp $
d53 1
d55 1
d202 4
a357 6
	/* 
	 * Saved jump buffer used in call to longjmp by _thread_kern_sched
	 * if sig_saved is FALSE.
	 */
	jmp_buf	saved_jmp_buf;

d365 6
d450 4
a453 2
	char		flags;
#define PTHREAD_EXITING		0x0100
d464 7
d473 1
d596 4
d783 3
@


1.9
log
@slight structure rearrange for gdb thread support
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.8 1999/01/08 05:42:18 d Exp $
d465 2
a466 1
extern struct pthread   * volatile _thread_kern_thread;
@


1.8
log
@add fchflags and fpathconf as well.
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.7 1999/01/08 04:59:50 d Exp $
a345 2
	struct _machdep_struct	_machdep;

d455 3
@


1.7
log
@add poll(2). This might help get X threaded.
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.6 1998/12/23 22:49:46 d Exp $
d598 1
a598 1
int     _thread_sys_fchflags(int, u_long);
d702 1
@


1.6
log
@preserve FreeBSD idents
@
text
@d34 1
a34 1
 * $OpenBSD$
d464 1
a464 1
extern struct pthread   _thread_kern_thread;
d754 5
@


1.5
log
@resource accounting
@
text
@d34 2
@


1.4
log
@sync with freebsd
@
text
@d386 6
@


1.3
log
@fix strcat usage; deraadt
@
text
@d555 3
a557 1
void    _thread_kern_sched_state(enum pthread_state,const char *fname,int lineno);
d569 1
a569 2
pthread_addr_t	_thread_gc(pthread_addr_t);

@


1.2
log
@sync with FreeBSD (rwlock, gc thread, man pages)
add (broken) mips md stuff
fix some const warnings
add sigaltstack() stub
another hash at getting shlib auto-init to work (mips/elf and i386/a.out)
@
text
@d546 1
a546 1
void    _thread_exit(char *, int, char *)
@


1.1
log
@experimental threaded libc - kernel only
@
text
@d59 2
a60 2
#define	stdout_debug(_x)	_write(1,_x,strlen(_x));
#define	stderr_debug(_x)	_write(2,_x,strlen(_x));
d221 12
d249 1
d280 1
a280 1
	char			*r_fname;	/* Ptr to read lock source file name  */
d282 1
a282 1
	char			*w_fname;	/* Ptr to write lock source file name */
d303 1
a303 1
		char	*fname;		/* Source file name for debugging.*/
d331 5
d447 1
a447 1
	char			*fname;	/* Ptr to source file name  */
d507 4
d539 1
a539 1
int     _thread_fd_lock_debug(int, int, struct timespec *,char *fname,int lineno);
a541 1
void    _lock_dead_thread_list(void);
a543 1
void    _unlock_dead_thread_list(void);
d546 2
a547 1
void    _thread_exit(char *, int, char *);
d553 1
a553 1
void    _thread_init(void) __attribute__((constructor));
d555 1
a555 1
void    _thread_kern_sched_state(enum pthread_state,char *fname,int lineno);
d567 2
d579 1
a579 1
int     _thread_sys_sigstack(const struct sigstack *, struct sigstack *);
d701 2
a702 1
void	_thread_sys__exit(int);
@

