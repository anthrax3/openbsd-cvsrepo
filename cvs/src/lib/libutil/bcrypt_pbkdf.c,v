head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.10
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.13
date	2015.01.12.03.20.04;	author tedu;	state Exp;
branches;
next	1.12;
commitid	hRrkKecgVFC5qxn4;

1.12
date	2015.01.08.00.30.07;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	ZpeT1iVK9wwZcY83;

1.11
date	2015.01.07.21.34.23;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	1FCdc9APJKcOku5F;

1.10
date	2014.12.30.01.41.43;	author djm;	state Exp;
branches;
next	1.9;
commitid	A1zfauBlqSjIQlfk;

1.9
date	2014.07.13.21.21.25;	author tedu;	state Exp;
branches;
next	1.8;
commitid	fVIax9H7o9A7ccfQ;

1.8
date	2014.06.30.00.26.22;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	73bnyBlMld7YtdVw;

1.7
date	2014.04.08.14.20.01;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.31.16.56.32;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2013.12.22.03.29.07;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2013.07.29.00.55.53;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.04.15.55.50;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2013.06.04.15.54.32;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2013.06.03.21.07.02;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@rename blocks to words. bcrypt "blocks" are unrelated to blowfish blocks,
nor are they the same size.
@
text
@/* $OpenBSD: bcrypt_pbkdf.c,v 1.12 2015/01/08 00:30:07 deraadt Exp $ */
/*
 * Copyright (c) 2013 Ted Unangst <tedu@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <stdint.h>
#include <stdlib.h>
#include <blf.h>
#include <sha2.h>
#include <string.h>
#include <util.h>

#define	MINIMUM(a,b) (((a) < (b)) ? (a) : (b))

/*
 * pkcs #5 pbkdf2 implementation using the "bcrypt" hash
 *
 * The bcrypt hash function is derived from the bcrypt password hashing
 * function with the following modifications:
 * 1. The input password and salt are preprocessed with SHA512.
 * 2. The output length is expanded to 256 bits.
 * 3. Subsequently the magic string to be encrypted is lengthened and modifed
 *    to "OxychromaticBlowfishSwatDynamite"
 * 4. The hash function is defined to perform 64 rounds of initial state
 *    expansion. (More rounds are performed by iterating the hash.)
 *
 * Note that this implementation pulls the SHA512 operations into the caller
 * as a performance optimization.
 *
 * One modification from official pbkdf2. Instead of outputting key material
 * linearly, we mix it. pbkdf2 has a known weakness where if one uses it to
 * generate (e.g.) 512 bits of key material for use as two 256 bit keys, an
 * attacker can merely run once through the outer loop, but the user
 * always runs it twice. Shuffling output bytes requires computing the
 * entirety of the key material to assemble any subkey. This is something a
 * wise caller could do; we just do it for you.
 */

#define BCRYPT_WORDS 8
#define BCRYPT_HASHSIZE (BCRYPT_WORDS * 4)

static void
bcrypt_hash(uint8_t *sha2pass, uint8_t *sha2salt, uint8_t *out)
{
	blf_ctx state;
	uint8_t ciphertext[BCRYPT_HASHSIZE] =
	    "OxychromaticBlowfishSwatDynamite";
	uint32_t cdata[BCRYPT_WORDS];
	int i;
	uint16_t j;
	size_t shalen = SHA512_DIGEST_LENGTH;

	/* key expansion */
	Blowfish_initstate(&state);
	Blowfish_expandstate(&state, sha2salt, shalen, sha2pass, shalen);
	for (i = 0; i < 64; i++) {
		Blowfish_expand0state(&state, sha2salt, shalen);
		Blowfish_expand0state(&state, sha2pass, shalen);
	}

	/* encryption */
	j = 0;
	for (i = 0; i < BCRYPT_WORDS; i++)
		cdata[i] = Blowfish_stream2word(ciphertext, sizeof(ciphertext),
		    &j);
	for (i = 0; i < 64; i++)
		blf_enc(&state, cdata, sizeof(cdata) / sizeof(uint64_t));

	/* copy out */
	for (i = 0; i < BCRYPT_WORDS; i++) {
		out[4 * i + 3] = (cdata[i] >> 24) & 0xff;
		out[4 * i + 2] = (cdata[i] >> 16) & 0xff;
		out[4 * i + 1] = (cdata[i] >> 8) & 0xff;
		out[4 * i + 0] = cdata[i] & 0xff;
	}

	/* zap */
	explicit_bzero(ciphertext, sizeof(ciphertext));
	explicit_bzero(cdata, sizeof(cdata));
	explicit_bzero(&state, sizeof(state));
}

int
bcrypt_pbkdf(const char *pass, size_t passlen, const uint8_t *salt, size_t saltlen,
    uint8_t *key, size_t keylen, unsigned int rounds)
{
	SHA2_CTX ctx;
	uint8_t sha2pass[SHA512_DIGEST_LENGTH];
	uint8_t sha2salt[SHA512_DIGEST_LENGTH];
	uint8_t out[BCRYPT_HASHSIZE];
	uint8_t tmpout[BCRYPT_HASHSIZE];
	uint8_t countsalt[4];
	size_t i, j, amt, stride;
	uint32_t count;
	size_t origkeylen = keylen;

	/* nothing crazy */
	if (rounds < 1)
		return -1;
	if (passlen == 0 || saltlen == 0 || keylen == 0 ||
	    keylen > sizeof(out) * sizeof(out))
		return -1;
	stride = (keylen + sizeof(out) - 1) / sizeof(out);
	amt = (keylen + stride - 1) / stride;

	/* collapse password */
	SHA512Init(&ctx);
	SHA512Update(&ctx, pass, passlen);
	SHA512Final(sha2pass, &ctx);


	/* generate key, sizeof(out) at a time */
	for (count = 1; keylen > 0; count++) {
		countsalt[0] = (count >> 24) & 0xff;
		countsalt[1] = (count >> 16) & 0xff;
		countsalt[2] = (count >> 8) & 0xff;
		countsalt[3] = count & 0xff;

		/* first round, salt is salt */
		SHA512Init(&ctx);
		SHA512Update(&ctx, salt, saltlen);
		SHA512Update(&ctx, countsalt, sizeof(countsalt));
		SHA512Final(sha2salt, &ctx);
		bcrypt_hash(sha2pass, sha2salt, tmpout);
		memcpy(out, tmpout, sizeof(out));

		for (i = 1; i < rounds; i++) {
			/* subsequent rounds, salt is previous output */
			SHA512Init(&ctx);
			SHA512Update(&ctx, tmpout, sizeof(tmpout));
			SHA512Final(sha2salt, &ctx);
			bcrypt_hash(sha2pass, sha2salt, tmpout);
			for (j = 0; j < sizeof(out); j++)
				out[j] ^= tmpout[j];
		}

		/*
		 * pbkdf2 deviation: output the key material non-linearly.
		 */
		amt = MINIMUM(amt, keylen);
		for (i = 0; i < amt; i++) {
			size_t dest = i * stride + (count - 1);
			if (dest >= origkeylen)
				break;
			key[dest] = out[i];
		}
		keylen -= i;
	}

	/* zap */
	explicit_bzero(&ctx, sizeof(ctx));
	explicit_bzero(out, sizeof(out));

	return 0;
}
@


1.12
log
@declare a local version of MIN(), call it MINIMUM()
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.11 2015/01/07 21:34:23 deraadt Exp $ */
d53 2
a54 2
#define BCRYPT_BLOCKS 8
#define BCRYPT_HASHSIZE (BCRYPT_BLOCKS * 4)
d62 1
a62 1
	uint32_t cdata[BCRYPT_BLOCKS];
d77 1
a77 1
	for (i = 0; i < BCRYPT_BLOCKS; i++)
d84 1
a84 1
	for (i = 0; i < BCRYPT_BLOCKS; i++) {
@


1.11
log
@Do not need sys/param.h
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.10 2014/12/30 01:41:43 djm Exp $ */
d27 2
d154 1
a154 1
		amt = MIN(amt, keylen);
@


1.10
log
@typo in comment: ouput => output
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.9 2014/07/13 21:21:25 tedu Exp $ */
d18 1
a18 1
#include <sys/param.h>
@


1.9
log
@include stdint.h for standard ints. from Jean-Philippe Ouellet
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.8 2014/06/30 00:26:22 deraadt Exp $ */
d150 1
a150 1
		 * pbkdf2 deviation: ouput the key material non-linearly.
@


1.8
log
@sys/types.h rather than sys/param.h, where applicable.  avoid overreach.
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.7 2014/04/08 14:20:01 tedu Exp $ */
d20 1
@


1.7
log
@fix an error in the stride calculations. the math only works for multiples
of the stride. don't overwrite past the end of the buffer, and also save
that amount for later so the array is completely filled. ok deraadt djm

reported by Dmitry Chestnykh (dchest)
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.6 2014/01/31 16:56:32 tedu Exp $ */
a17 1
#include <sys/types.h>
@


1.6
log
@explicit_bzero where useful
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.5 2013/12/22 03:29:07 tedu Exp $ */
d107 1
d153 7
a159 3
		for (i = 0; i < amt; i++)
			key[i * stride + (count - 1)] = out[i];
		keylen -= amt;
@


1.5
log
@tweak comment
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.4 2013/07/29 00:55:53 tedu Exp $ */
d90 3
a92 3
	memset(ciphertext, 0, sizeof(ciphertext));
	memset(cdata, 0, sizeof(cdata));
	memset(&state, 0, sizeof(state));
d158 2
a159 2
	memset(&ctx, 0, sizeof(ctx));
	memset(out, 0, sizeof(out));
@


1.4
log
@fix a colossal cockup due to pointer/array confusion.
code isn't used yet, thankfully.
first observed by djm running regress. ok deraadt djm
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.3 2013/06/04 15:55:50 tedu Exp $ */
d44 2
a45 2
 * generate (i.e.) 512 bits of key material for use as two 256 bit keys, an
 * attacker can merely run once through the outer loop below, but the user
@


1.3
log
@revert. check is < 1, not < 0.
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.2 2013/06/04 15:54:32 tedu Exp $ */
d55 1
a55 2
bcrypt_hash(uint8_t sha2pass[SHA512_DIGEST_LENGTH],
    uint8_t sha2salt[SHA512_DIGEST_LENGTH], uint8_t out[BCRYPT_HASHSIZE])
d63 1
d67 1
a67 2
	Blowfish_expandstate(&state, sha2salt, sizeof(sha2salt), sha2pass,
	    sizeof(sha2pass));
d69 2
a70 2
		Blowfish_expand0state(&state, sha2salt, sizeof(sha2salt));
		Blowfish_expand0state(&state, sha2pass, sizeof(sha2pass));
@


1.2
log
@oops, rounds is unsigned now
@
text
@d1 1
a1 1
/* $OpenBSD: bcrypt_pbkdf.c,v 1.1 2013/06/03 21:07:02 tedu Exp $ */
d110 2
@


1.1
log
@Add bcrypt_pbkdf, a password based key derivation function using bcrypt.
Technically, it's a slight variant of bcrypt better suited for use as a
pluggable hash with PKCS #5 PBKDF2.
ok djm
(also tweak pkcs5_pbkdf2() prototype to have consistent types.)
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a109 2
	if (rounds < 1)
		return -1;
@

