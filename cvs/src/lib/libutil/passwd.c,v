head	1.54;
access;
symbols
	OPENBSD_6_0:1.54.0.6
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.54.0.4
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.53.0.2
	OPENBSD_5_7_BASE:1.53
	OPENBSD_5_6:1.52.0.6
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.49.0.26
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.24
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.22
	OPENBSD_5_0:1.49.0.20
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.18
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.16
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.12
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.14
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.10
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.8
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.49.0.6
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.49.0.4
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.49.0.2
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.46.0.4
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.45.0.2
	OPENBSD_3_7_BASE:1.45
	OPENBSD_3_6:1.44.0.2
	OPENBSD_3_6_BASE:1.44
	OPENBSD_3_5:1.42.0.4
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	OPENBSD_3_3:1.36.0.4
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.20.0.6
	OPENBSD_2_7_BASE:1.20
	OPENBSD_2_6:1.20.0.4
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.19.0.2
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.54
date	2015.04.24.21.13.56;	author millert;	state Exp;
branches;
next	1.53;
commitid	6RguIl2efEAzYTqO;

1.53
date	2014.08.15.03.51.40;	author guenther;	state Exp;
branches;
next	1.52;
commitid	ILfd29dGeQRUYnTr;

1.52
date	2013.08.17.06.54.21;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2013.08.06.22.47.43;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.20.23.07.36;	author ray;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.17.20.50.51;	author ray;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.02.02.10.35;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.02.21.46.23;	author espie;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.04.18.44.59;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2004.07.13.21.09.48;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.20.23.20.07;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.26.16.34.42;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.02.20.18.42;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.04.02.00.08.28;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.01.16.28.03;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.30.21.10.27;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.30.20.57.59;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.31.21.53.34;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.27.22.21.50;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.09.22.18.43;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.24.21.27.38;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.10.10.11.03;	author mpech;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.16.21.27.29;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.16.01.28.54;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.14.19.50.23;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.26.03.28.30;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.16.18.24.32;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.11.16.11.10;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.09.07.04.40;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.02.18.22.32;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.26.01.25.33;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.01.22.10.16;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.30.16.00.07;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	98.11.16.07.10.32;	author deraadt;	state Exp;
branches
	1.20.6.1;
next	1.19;

1.19
date	98.08.03.17.16.32;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.06.22.14.41.47;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	98.03.23.22.40.52;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.11.18.19.57.28;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.11.17.22.46.03;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.11.17.21.12.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.11.17.20.56.57;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.09.29.19.18.21;	author deraadt;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	97.06.22.23.57.23;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.06.17.10.10.42;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.04.10.20.05.49;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	97.02.16.19.59.21;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.02.15.09.47.54;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.02.13.05.41.38;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.12.06.01.55.33;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.19.12.36.01;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.17.07.46.04;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.06.06.12.10.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.22.11.35.10;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	97.11.17.21.15.14;	author millert;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	97.11.17.22.52.03;	author millert;	state Exp;
branches;
next	;

1.20.6.1
date	2000.10.04.00.44.22;	author jason;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Use strtonum() instead of strtoul() when parsing uid/gid so we get
consistent handling of negative ids on 32bit/64bit systems.
The only negative uid/gid allowed is -1 which is special-cased
so it can be preserved when writing the new master.passwd file
instead of being written as an unsigned number.  OK deraadt@@
@
text
@/*	$OpenBSD: passwd.c,v 1.53 2014/08/15 03:51:40 guenther Exp $	*/

/*
 * Copyright (c) 1987, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>

#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <pwd.h>
#include <err.h>
#include <errno.h>
#include <paths.h>
#include <signal.h>
#include <limits.h>

#include "util.h"

static char pw_defdir[] = "/etc";
static char *pw_dir = pw_defdir;
static char *pw_lck;

char *
pw_file(const char *nm)
{
	const char *p = strrchr(nm, '/');
	char *new_nm;

	if (p)
		p++;
	else
		p = nm;

	if (asprintf(&new_nm, "%s/%s", pw_dir, p) == -1)
		return NULL;
	return new_nm;
}

void
pw_setdir(const char *dir)
{
	char *p;

	if (strcmp (dir, pw_dir) == 0)
		return;
	if (pw_dir != pw_defdir)
		free(pw_dir);
	pw_dir = strdup(dir);
	if (pw_lck) {
		p = pw_file(pw_lck);
		free(pw_lck);
		pw_lck = p;
	}
}


int
pw_lock(int retries)
{
	int i, fd;
	mode_t old_mode;

	if (!pw_lck) {
		errno = EINVAL;
		return (-1);
	}
	/* Acquire the lock file.  */
	old_mode = umask(0);
	fd = open(pw_lck, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 0600);
	for (i = 0; i < retries && fd < 0 && errno == EEXIST; i++) {
		sleep(1);
		fd = open(pw_lck, O_WRONLY|O_CREAT|O_EXCL|O_CLOEXEC, 0600);
	}
	(void) umask(old_mode);
	return (fd);
}

int
pw_mkdb(char *username, int flags)
{
	int pstat, ac;
	pid_t pid;
	char *av[8];
	struct stat sb;

	if (pw_lck == NULL)
		return(-1);

	/* A zero length passwd file is never ok */
	if (stat(pw_lck, &sb) == 0 && sb.st_size == 0) {
		warnx("%s is zero length", pw_lck);
		return (-1);
	}

	ac = 0;
	av[ac++] = "pwd_mkdb";
	av[ac++] = "-d";
	av[ac++] = pw_dir;
	if (flags & _PASSWORD_SECUREONLY)
		av[ac++] = "-s";
	else if (!(flags & _PASSWORD_OMITV7))
		av[ac++] = "-p";
	if (username) {
		av[ac++] = "-u";
		av[ac++] = username;
	}
	av[ac++] = pw_lck;
	av[ac] = NULL;

	pid = vfork();
	if (pid == -1)
		return (-1);
	if (pid == 0) {
		if (pw_lck)
			execv(_PATH_PWD_MKDB, av);
		_exit(1);
	}
	pid = waitpid(pid, &pstat, 0);
	if (pid == -1 || !WIFEXITED(pstat) || WEXITSTATUS(pstat) != 0)
		return (-1);
	return (0);
}

int
pw_abort(void)
{
	return (pw_lck ? unlink(pw_lck) : -1);
}

/* Everything below this point is intended for the convenience of programs
 * which allow a user to interactively edit the passwd file.  Errors in the
 * routines below will cause the process to abort. */

static pid_t editpid = -1;

static void
pw_cont(int signo)
{
	int save_errno = errno;

	if (editpid != -1)
		kill(editpid, signo);
	errno = save_errno;
}

void
pw_init(void)
{
	struct rlimit rlim;

	/* Unlimited resource limits. */
	rlim.rlim_cur = rlim.rlim_max = RLIM_INFINITY;
	(void)setrlimit(RLIMIT_CPU, &rlim);
	(void)setrlimit(RLIMIT_FSIZE, &rlim);
	(void)setrlimit(RLIMIT_STACK, &rlim);
	(void)setrlimit(RLIMIT_DATA, &rlim);
	(void)setrlimit(RLIMIT_RSS, &rlim);

	/* Don't drop core (not really necessary, but GP's). */
	rlim.rlim_cur = rlim.rlim_max = 0;
	(void)setrlimit(RLIMIT_CORE, &rlim);

	/* Turn off signals. */
	(void)signal(SIGALRM, SIG_IGN);
	(void)signal(SIGHUP, SIG_IGN);
	(void)signal(SIGINT, SIG_IGN);
	(void)signal(SIGPIPE, SIG_IGN);
	(void)signal(SIGQUIT, SIG_IGN);
	(void)signal(SIGTERM, SIG_IGN);
	(void)signal(SIGCONT, pw_cont);

	if (!pw_lck)
		pw_lck = pw_file(_PATH_MASTERPASSWD_LOCK);
}

void
pw_edit(int notsetuid, const char *filename)
{
	int pstat;
	char *p;
	char * volatile editor;
	char *argp[] = {"sh", "-c", NULL, NULL};

	if (!filename) {
		filename = pw_lck;
		if (!filename)
			return;
	}

	if ((editor = getenv("EDITOR")) == NULL)
		editor = _PATH_VI;

	if (asprintf(&p, "%s %s", editor, filename) == -1)
		return;
	argp[2] = p;

	switch (editpid = vfork()) {
	case -1:			/* error */
		free(p);
		return;
	case 0:				/* child */
		if (notsetuid) {
			setgid(getgid());
			setuid(getuid());
		}
		execv(_PATH_BSHELL, argp);
		_exit(127);
	}

	free(p);
	for (;;) {
		editpid = waitpid(editpid, (int *)&pstat, WUNTRACED);
		if (editpid == -1)
			pw_error(editor, 1, 1);
		else if (WIFSTOPPED(pstat))
			raise(WSTOPSIG(pstat));
		else if (WIFEXITED(pstat) && WEXITSTATUS(pstat) == 0)
			break;
		else
			pw_error(editor, 1, 1);
	}
	editpid = -1;
}

void
pw_prompt(void)
{
	int first, c;

	(void)printf("re-edit the password file? [y]: ");
	(void)fflush(stdout);
	first = c = getchar();
	while (c != '\n' && c != EOF)
		c = getchar();
	switch (first) {
	case EOF:
		putchar('\n');
		/* FALLTHROUGH */
	case 'n':
	case 'N':
		pw_error(NULL, 0, 0);
		break;
	}
}

static int
pw_equal(const struct passwd *pw1, const struct passwd *pw2)
{
	return (strcmp(pw1->pw_name, pw2->pw_name) == 0 &&
	    pw1->pw_uid == pw2->pw_uid &&
	    pw1->pw_gid == pw2->pw_gid &&
	    strcmp(pw1->pw_class, pw2->pw_class) == 0 &&
	    pw1->pw_change == pw2->pw_change &&
	    pw1->pw_expire == pw2->pw_expire &&
	    strcmp(pw1->pw_gecos, pw2->pw_gecos) == 0 &&
	    strcmp(pw1->pw_dir, pw2->pw_dir) == 0 &&
	    strcmp(pw1->pw_shell, pw2->pw_shell) == 0);
}

static int
pw_write_entry(FILE *to, const struct passwd *pw)
{
	char	gidstr[16], uidstr[16];

	/* Preserve gid/uid -1 */
	if (pw->pw_gid == (gid_t)-1)
		strlcpy(gidstr, "-1", sizeof(gidstr));
	else
		snprintf(gidstr, sizeof(gidstr), "%u", (u_int)pw->pw_gid);

	if (pw->pw_uid == (uid_t)-1)
		strlcpy(uidstr, "-1", sizeof(uidstr));
	else
		snprintf(uidstr, sizeof(uidstr), "%u", (u_int)pw->pw_uid);

	return fprintf(to, "%s:%s:%s:%s:%s:%lld:%lld:%s:%s:%s\n",
	    pw->pw_name, pw->pw_passwd, uidstr, gidstr, pw->pw_class,
	    (long long)pw->pw_change, (long long)pw->pw_expire,
	    pw->pw_gecos, pw->pw_dir, pw->pw_shell);
}

void
pw_copy(int ffd, int tfd, const struct passwd *pw, const struct passwd *opw)
{
	struct passwd tpw;
	FILE   *from, *to;
	int	done;
	char   *p, *ep, buf[8192];
	char   *master = pw_file(_PATH_MASTERPASSWD);

	if (!master)
		pw_error(NULL, 0, 1);
	if (!(from = fdopen(ffd, "r")))
		pw_error(master, 1, 1);
	if (!(to = fdopen(tfd, "w")))
		pw_error(pw_lck ? pw_lck : NULL, pw_lck ? 1 : 0, 1);

	for (done = 0; fgets(buf, (int)sizeof(buf), from);) {
		if ((ep = strchr(buf, '\n')) == NULL) {
			warnx("%s: line too long", master);
			pw_error(NULL, 0, 1);
		}
		if (done) {
			if (fputs(buf, to))
				goto fail;
			continue;
		}
		if (!(p = strchr(buf, ':'))) {
			warnx("%s: corrupted entry", master);
			pw_error(NULL, 0, 1);
		}
		*p = '\0';
		if (strcmp(buf, opw ? opw->pw_name : pw->pw_name)) {
			*p = ':';
			if (fputs(buf, to))
				goto fail;
			continue;
		}
		if (opw != NULL) {
			*p = ':';
			*ep = '\0';
			if (!pw_scan(buf, &tpw, NULL))
				pw_error(NULL, 0, 1);
			if (!pw_equal(&tpw, opw)) {
				warnx("%s: inconsistent entry", master);
				pw_error(NULL, 0, 1);
			}
		}
		if (pw_write_entry(to, pw) == -1)
			goto fail;
		done = 1;
	}
	if (!done && pw_write_entry(to, pw) == -1)
		goto fail;

	if (ferror(to) || fflush(to))
fail:
		pw_error(NULL, 0, 1);
	free(master);
	(void)fclose(to);
}

int
pw_scan(char *bp, struct passwd *pw, int *flags)
{
	int root;
	char *p, *sh;
	const char *errstr;

	if (flags != NULL)
		*flags = 0;

	if (!(p = strsep(&bp, ":")) || *p == '\0')	/* login */
		goto fmt;
	pw->pw_name = p;
	root = !strcmp(pw->pw_name, "root");

	if (!(pw->pw_passwd = strsep(&bp, ":")))	/* passwd */
		goto fmt;

	if (!(p = strsep(&bp, ":")))			/* uid */
		goto fmt;
	pw->pw_uid = strtonum(p, -1, UID_MAX, &errstr);
	if (errstr != NULL) {
		if (*p != '\0') {
			warnx("uid is %s", errstr);
			return (0);
		}
		if (flags != NULL)
			*flags |= _PASSWORD_NOUID;
	}
	if (root && pw->pw_uid) {
		warnx("root uid should be 0");
		return (0);
	}

	if (!(p = strsep(&bp, ":")))			/* gid */
		goto fmt;
	pw->pw_gid = strtonum(p, -1, GID_MAX, &errstr);
	if (errstr != NULL) {
		if (*p != '\0') {
			warnx("gid is %s", errstr);
			return (0);
		}
		if (flags != NULL)
			*flags |= _PASSWORD_NOGID;
	}

	pw->pw_class = strsep(&bp, ":");		/* class */
	if (!(p = strsep(&bp, ":")))			/* change */
		goto fmt;
	pw->pw_change = atoll(p);
	if ((*p == '\0') && (flags != (int *)NULL))
		*flags |= _PASSWORD_NOCHG;
	if (!(p = strsep(&bp, ":")))			/* expire */
		goto fmt;
	pw->pw_expire = atoll(p);
	if ((*p == '\0') && (flags != (int *)NULL))
		*flags |= _PASSWORD_NOEXP;
	pw->pw_gecos = strsep(&bp, ":");		/* gecos */
	pw->pw_dir = strsep(&bp, ":");			/* directory */
	if (!(pw->pw_shell = strsep(&bp, ":")))		/* shell */
		goto fmt;

	p = pw->pw_shell;
	if (root && *p) {				/* empty == /bin/sh */
		for (setusershell();;) {
			if (!(sh = getusershell())) {
				warnx("warning, unknown root shell");
				break;
			}
			if (!strcmp(p, sh))
				break;
		}
		endusershell();
	}

	if ((p = strsep(&bp, ":"))) {			/* too many */
fmt:		warnx("corrupted entry");
		return (0);
	}

	return (1);
}

__dead void
pw_error(const char *name, int error, int eval)
{
	char   *master = pw_file(_PATH_MASTERPASSWD);

	if (error) {
		if (name)
			warn("%s", name);
		else
			warn(NULL);
	}
	if (master) {
		warnx("%s: unchanged", master);
		free(master);
	}

	pw_abort();
	exit(eval);
}
@


1.53
log
@Use O_CLOEXEC wherever we open a file and then call fcntl(F_SETFD, FD_CLOEXEC)
on it, simplifying error checking, reducing system calls, and improving
thread-safety for libraries.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.52 2013/08/17 06:54:21 guenther Exp $	*/
d294 22
d338 1
a338 2
			(void)fprintf(to, "%s", buf);
			if (ferror(to))
d349 1
a349 2
			(void)fprintf(to, "%s", buf);
			if (ferror(to))
d363 2
a364 5
		(void)fprintf(to, "%s:%s:%u:%u:%s:%lld:%lld:%s:%s:%s\n",
		    pw->pw_name, pw->pw_passwd, (u_int)pw->pw_uid,
		    (u_int)pw->pw_gid, pw->pw_class, (long long)pw->pw_change,
		    (long long)pw->pw_expire, pw->pw_gecos, pw->pw_dir,
		    pw->pw_shell);
a365 2
		if (ferror(to))
			goto fail;
d367 2
a368 6
	if (!done)
		(void)fprintf(to, "%s:%s:%u:%u:%s:%lld:%lld:%s:%s:%s\n",
		    pw->pw_name, pw->pw_passwd, (u_int)pw->pw_uid,
		    (u_int)pw->pw_gid, pw->pw_class, (long long)pw->pw_change,
		    (long long)pw->pw_expire, pw->pw_gecos,
		    pw->pw_dir, pw->pw_shell);
d370 1
a370 1
	if (ferror(to))
a379 1
	u_long id;
d381 2
a382 1
	char *p, *sh, *p2;
d384 1
a384 1
	if (flags != (int *)NULL)
d397 10
a406 2
	id = strtoul(p, &p2, 10);
	if (root && id) {
a409 12
	if (*p2 != '\0') {
		warnx("illegal uid field");
		return (0);
	}
	if (id > UID_MAX) {
		/* errno is set to ERANGE by strtoul(3) */
		warnx("uid greater than %u", UID_MAX-1);
		return (0);
	}
	pw->pw_uid = (uid_t)id;
	if ((*p == '\0') && (flags != (int *)NULL))
		*flags |= _PASSWORD_NOUID;
d413 8
a420 9
	id = strtoul(p, &p2, 10);
	if (*p2 != '\0') {
		warnx("illegal gid field");
		return (0);
	}
	if (id > UID_MAX) {
		/* errno is set to ERANGE by strtoul(3) */
		warnx("gid greater than %u", UID_MAX-1);
		return (0);
a421 3
	pw->pw_gid = (gid_t)id;
	if ((*p == '\0') && (flags != (int *)NULL))
		*flags |= _PASSWORD_NOGID;
@


1.52
log
@Use %lld and cast to (long long) when printing time_t values and atoll()
when parsing them.
Add a couple [ug]id_t --> u_int casts for consistency with rest of code.

Based on a diff from Nathanael Rensen (nathanael (at) polymorpheus.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.51 2013/08/06 22:47:43 millert Exp $	*/
a95 1
	int save_errno;
d103 1
a103 1
	fd = open(pw_lck, O_WRONLY|O_CREAT|O_EXCL, 0600);
d106 1
a106 6
		fd = open(pw_lck, O_WRONLY|O_CREAT|O_EXCL, 0600);
	}
	save_errno = errno;
	if (fd != -1 && fcntl(fd, F_SETFD, FD_CLOEXEC) == -1) {
		close(fd);
		fd = -1;
a108 1
	errno = save_errno;
@


1.51
log
@When writing a new record in pw_copy() print the uid and gid as
unsigned, just like we do the existing records.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.50 2013/04/29 00:28:23 okan Exp $	*/
d350 1
a350 1
		(void)fprintf(to, "%s:%s:%u:%u:%s:%d:%d:%s:%s:%s\n",
d352 2
a353 2
		    (u_int)pw->pw_gid, pw->pw_class, pw->pw_change,
		    pw->pw_expire, pw->pw_gecos, pw->pw_dir,
d360 4
a363 3
		(void)fprintf(to, "%s:%s:%u:%u:%s:%d:%d:%s:%s:%s\n",
		    pw->pw_name, pw->pw_passwd, pw->pw_uid, pw->pw_gid,
		    pw->pw_class, pw->pw_change, pw->pw_expire, pw->pw_gecos,
d430 1
a430 1
	pw->pw_change = atol(p);
d435 1
a435 1
	pw->pw_expire = atol(p);
@


1.50
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.49 2006/12/20 23:07:36 ray Exp $	*/
d360 1
a360 1
		(void)fprintf(to, "%s:%s:%d:%d:%s:%d:%d:%s:%s:%s\n",
@


1.49
log
@Don't use err as labels or variables, especially since we include
err.h.

OK moritz@@ and jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.47 2006/04/02 02:10:35 deraadt Exp $	*/
d110 1
a110 1
	if (fd != -1 && fcntl(fd, F_SETFD, 1) == -1) {
@


1.48
log
@Always write errno on pw_lock failure so it can be relied on.
Mention errno, pw_file, and pw_init in pw_lock man page.

OK jmc@@, otto@@, millert@@, and deraadt@@.
@
text
@d325 1
a325 1
				goto err;
d337 1
a337 1
				goto err;
d357 1
a357 1
			goto err;
d366 1
a366 1
err:
d464 1
a464 1
pw_error(const char *name, int err, int eval)
d468 1
a468 1
	if (err) {
@


1.47
log
@getting to the bottom of the issues.  sprinkle a few casts that will
actually help us find bugs later (with lint, not cc), if they get
introduced
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.46 2005/08/02 21:46:23 espie Exp $	*/
d98 2
a99 1
	if (!pw_lck)
d101 1
@


1.46
log
@scrape $Id$ tags.
okay deraadt@@, millert@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.45 2004/11/04 18:44:59 millert Exp $	*/
d315 1
a315 1
	for (done = 0; fgets(buf, sizeof(buf), from);) {
@


1.45
log
@Treat EOF at prompt the same as 'n' instead of looping forever.
Noticed by mepch@@.  OK pedro@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.44 2004/07/13 21:09:48 millert Exp $	*/
a30 4

#if defined(LIBC_SCCS) && !defined(lint)
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.44 2004/07/13 21:09:48 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.44
log
@passwd.conf has been deprecated since login.conf was imported.
Today it finally dies.  Based on a diff from Gabriel Kihlman.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.43 2004/04/20 23:20:07 millert Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.43 2004/04/20 23:20:07 millert Exp $";
d278 6
a283 1
	if (first == 'n')
d285 2
@


1.43
log
@Change pw_copy(3) to take a 3rd arguement, the existing passwd entry.
This allows an application to only update a password entry if it is
in the state it expects.  Additionally, if the old passwd struct
is specified the new one may have a different pw_name field since
matching is done on the original.  Adapted from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.42 2003/06/26 16:34:42 deraadt Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.42 2003/06/26 16:34:42 deraadt Exp $";
a56 9
#define NUM_OPTIONS	2	/* Number of hardcoded defaults */

static void	pw_cont(int sig);

static const char options[NUM_OPTIONS][2][80] = {
	{"localcipher", "blowfish,4"},
	{"ypcipher", "old"}
};

a60 59
static void trim_whitespace(char *);
static int read_line(FILE *, char *, int);
static const char *pw_default(const char *);

/* Removes head and/or tail spaces. */
static void
trim_whitespace(char *line)
{
	char   *p;

	/* Remove leading spaces */
	p = line;
	while (isspace(*p))
		p++;
	(void) memmove(line, p, strlen(p) + 1);

	/* Remove trailing spaces */
	p = line + strlen(line) - 1;
	while (isspace(*p))
		p--;
	*(p + 1) = '\0';
}


/* Get one line, remove spaces from front and tail */
static int
read_line(FILE *fp, char *line, int max)
{
	char   *p;

	/* Read one line of config */
	if (fgets(line, max, fp) == 0)
		return 0;
	if (!(p = strchr(line, '\n'))) {
		warnx("line too long");
		return 0;
	}
	*p = '\0';

	/* Remove comments */
	if ((p = strchr(line, '#')))
		*p = '\0';

	trim_whitespace(line);
	return 1;
}


static const char *
pw_default(const char *option)
{
	int	i;

	for (i = 0; i < NUM_OPTIONS; i++)
		if (!strcmp(options[i][0], option))
			return options[i][1];
	return NULL;
}

a75 75


/*
 * Retrieve password information from the /etc/passwd.conf file,
 * at the moment this is only for choosing the cipher to use.
 * It could easily be used for other authentication methods as
 * well.
 */
void
pw_getconf(char *data, size_t max, const char *key, const char *option)
{
	FILE   *fp;
	char    line[LINE_MAX];
	static char result[LINE_MAX];
	char   *p;
	int	got = 0;
	int	found = 0;

	result[0] = '\0';

	p = pw_file(_PATH_PASSWDCONF);
	if (!p || (fp = fopen(p, "r")) == NULL) {
		if (p)
			free(p);
		if ((p = (char *)pw_default(option))) {
			strncpy(data, p, max - 1);
			data[max - 1] = '\0';
		} else
			data[0] = '\0';
		return;
	}
	free(p);

	while (!found && (got || read_line(fp, line, LINE_MAX))) {
		got = 0;
		if (strncmp(key, line, strlen(key)) ||
		    line[strlen(key)] != ':')
			continue;

		/* Now we found our specified key */
		while (read_line(fp, line, LINE_MAX)) {
			char   *p2;

			/* Leaving key field */
			if (strchr(line, ':')) {
				got = 1;
				break;
			}
			p2 = line;
			if (!(p = strsep(&p2, "=")) || p2 == NULL)
				continue;
			trim_whitespace(p);
			if (!strncmp(p, option, strlen(option))) {
				trim_whitespace(p2);
				strlcpy(result, p2, sizeof result);
				found = 1;
				break;
			}
		}
	}
	fclose(fp);

	/*
	 * If we got no result and were looking for a default
	 * value, try hard coded defaults.
	 */

	if (!strlen(result) && !strcmp(key,"default") &&
	    (p = (char *)pw_default(option)))
		strncpy(data, p, max - 1);
	else
		strncpy(data, result, max - 1);
	data[max - 1] = '\0';
}

@


1.42
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.41 2003/06/02 20:18:42 millert Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.41 2003/06/02 20:18:42 millert Exp $";
d425 14
d440 1
a440 1
pw_copy(int ffd, int tfd, struct passwd *pw)
d442 1
d445 1
a445 1
	char   *p, buf[8192];
d456 1
a456 1
		if (!strchr(buf, '\n')) {
d471 1
a471 1
		if (strcmp(buf, pw->pw_name)) {
d477 10
@


1.41
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.40 2003/04/02 00:08:28 deraadt Exp $	*/
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.40 2003/04/02 00:08:28 deraadt Exp $";
d61 1
a61 2
static const char options[NUM_OPTIONS][2][80] =
{
d70 4
d76 1
a76 2
trim_whitespace(line)
	char   *line;
d96 1
a96 4
read_line(fp, line, max)
	FILE   *fp;
	char   *line;
	int	max;
d119 1
a119 2
pw_default(option)
	char   *option;
d130 1
a130 2
pw_file(nm)
	const char *nm;
d153 1
a153 5
pw_getconf(data, max, key, option)
	char	*data;
	size_t	max;
	const char *key;
	const char *option;
d221 1
a221 2
pw_setdir(dir)
	const char *dir;
d239 1
a239 2
pw_lock(retries)
	int retries;
d265 1
a265 3
pw_mkdb(username, flags)
	char *username;
	int flags;
d311 1
a311 1
pw_abort()
d323 1
a323 2
pw_cont(sig)
	int sig;
d328 1
a328 1
		kill(editpid, sig);
d333 1
a333 1
pw_init()
d363 1
a363 3
pw_edit(notsetuid, filename)
	int notsetuid;
	const char *filename;
d412 1
a412 1
pw_prompt()
d426 1
a426 3
pw_copy(ffd, tfd, pw)
	int ffd, tfd;
	struct passwd *pw;
d486 1
a486 4
pw_scan(bp, pw, flags)
	char *bp;
	struct passwd *pw;
	int *flags;
d577 1
a577 3
pw_error(name, err, eval)
	const char *name;
	int err, eval;
@


1.40
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.39 2003/04/01 16:28:03 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d33 1
a33 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.39 2003/04/01 16:28:03 millert Exp $";
@


1.39
log
@Throw an error if the username field is empty; noticed by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.38 2003/03/30 21:10:27 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.38 2003/03/30 21:10:27 deraadt Exp $";
d500 1
a500 1
	pw_error(NULL, 0, 1);
@


1.38
log
@more asprintf; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.37 2003/03/30 20:57:59 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.37 2003/03/30 20:57:59 deraadt Exp $";
d518 1
a518 1
	if (!(pw->pw_name = strsep(&bp, ":")))		/* login */
d520 1
@


1.37
log
@asprintf; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.36 2002/07/31 21:53:34 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.36 2002/07/31 21:53:34 millert Exp $";
d397 1
a397 2
	p = malloc(strlen(editor) + 1 + strlen(filename) + 1);
	if (p == NULL)
a398 1
	sprintf(p, "%s %s", editor, filename);
@


1.36
log
@mark pw_error() __dead since it exits
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.35 2002/06/27 22:21:50 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.35 2002/06/27 22:21:50 deraadt Exp $";
d146 2
a147 2
	new_nm = malloc(strlen(pw_dir) + strlen(p) + 2);
	if (!new_nm)
a148 1
	sprintf(new_nm, "%s/%s", pw_dir, p);
@


1.35
log
@%u for uid/gid; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.34 2002/06/09 22:18:43 fgsch Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.34 2002/06/09 22:18:43 fgsch Exp $";
d601 1
a601 1
void
@


1.34
log
@some -Wall and spaces cleanup, scsi.c left.
some brave soul should look at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.33 2002/05/24 21:27:38 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: passwd.c,v 1.33 2002/05/24 21:27:38 deraadt Exp $";
d486 5
a490 4
		(void)fprintf(to, "%s:%s:%d:%d:%s:%d:%d:%s:%s:%s\n",
		    pw->pw_name, pw->pw_passwd, pw->pw_uid, pw->pw_gid,
		    pw->pw_class, pw->pw_change, pw->pw_expire, pw->pw_gecos,
		    pw->pw_dir, pw->pw_shell);
@


1.33
log
@strlcpy and KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.32 2002/04/10 10:11:03 mpech Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.32 2002/04/10 10:11:03 mpech Exp $";
@


1.32
log
@Clean up after pw_file().

millert@@ ok
deraadt@@ ok to commit
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.31 2002/02/16 21:27:29 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.31 2002/02/16 21:27:29 millert Exp $";
d61 1
a61 1
#define NUM_OPTIONS     2       /* Number of hardcoded defaults */
d101 1
a101 1
	int     max;
d104 1
d127 2
a128 1
	int     i;
d158 1
a158 1
 * well. 
d171 2
a172 2
	int     got = 0;
	int     found = 0;
d180 1
a180 1
		if((p = (char *)pw_default(option))) {
d197 17
a213 16
		     char   *p2;
		     /* Leaving key field */
		     if (strchr(line, ':')) {
			  got = 1;
			  break;
		     }
		     p2 = line;
		     if (!(p = strsep(&p2, "=")) || p2 == NULL)
			  continue;
		     trim_whitespace(p);
		     if (!strncmp(p, option, strlen(option))) {
			  trim_whitespace(p2);
			  strcpy(result, p2);
			  found = 1;
			  break;
		     }
d218 1
a218 1
	/* 
d224 1
a224 1
	    (p=(char *)pw_default(option)))
d226 1
a226 1
	else 
d587 1
a587 1
				break;	
@


1.31
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.30 2002/01/16 01:28:54 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.30 2002/01/16 01:28:54 millert Exp $";
d610 1
a610 1
	if (master)
d612 3
@


1.30
log
@Use the volatile specifier to fix warnings about variables being
clobbered by longjmp / vfork instead of the gcc "(void)&foo;" hack.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.29 2001/11/14 19:50:23 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.29 2001/11/14 19:50:23 deraadt Exp $";
d63 1
a63 1
static void	pw_cont __P((int sig));
@


1.29
log
@save errno in signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.28 2001/08/26 03:28:30 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.28 2001/08/26 03:28:30 millert Exp $";
d382 2
a383 1
	char *p, *editor;
a385 3
#ifdef __GNUC__
	(void)&editor;
#endif
@


1.28
log
@Change the second arg to pw_mkdb() from a boolean flag to a set of
bit flags ORed together.  Currently the only flags defined are
_PASSWORD_SECUREONLY and _PASSWORD_OMITV7 but this is enough to
cause pw_mkdb() to run pwd_mkdb with the options we want.

With this change we no longer generate the old V7 passwd file when
only the extra fields in master.passwd (or the encrypted password)
have changed.  There are other programs that could probably use
the _PASSWORD_OMITV7 flag; they will be converted at a future date.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.27 2001/08/16 18:24:32 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.27 2001/08/16 18:24:32 millert Exp $";
d339 1
d343 1
@


1.27
log
@Add new 'secureonly' arg to pw_mkdb() to correspond to pwd_mkdb's new -s
flag and crank the library major due to the interface change.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.26 2001/07/11 16:11:10 aaron Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.26 2001/07/11 16:11:10 aaron Exp $";
d276 1
a276 1
pw_mkdb(username, secureonly)
d278 1
a278 1
	int secureonly;
d298 1
a298 1
	if (secureonly)
d300 1
a300 1
	else
@


1.26
log
@Plug memory leak in pw_copy(); millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.25 2001/07/09 07:04:40 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.25 2001/07/09 07:04:40 deraadt Exp $";
d276 1
a276 1
pw_mkdb(username)
d278 1
d280 1
a280 1
	int pstat;
d282 1
d285 3
d289 16
a304 5
	if (pw_lck && stat(pw_lck, &sb) == 0) {
		if (sb.st_size == 0) {
			warnx("%s is zero length", pw_lck);
			return (-1);
		}
d306 2
d313 2
a314 8
		if (pw_lck) {
			if (username)
				execl(_PATH_PWD_MKDB, "pwd_mkdb", "-p", "-d",
				    pw_dir, "-u", username, pw_lck, (char *)NULL);
			else
				execl(_PATH_PWD_MKDB, "pwd_mkdb", "-p", "-d",
				    pw_dir, pw_lck, (char *)NULL);
		}
@


1.25
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.24 2001/01/02 18:22:32 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.24 2001/01/02 18:22:32 millert Exp $";
d488 1
@


1.24
log
@Fix a problem introduced by the printf format sweep.  Passing a NULL
pw_error() is prefectly legal but now we have to check for it explicity
(it was handled implicitly before since warn(name) would become warn(NULL)).
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.23 2000/11/26 01:25:33 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.23 2000/11/26 01:25:33 millert Exp $";
d298 1
a298 1
				    pw_dir, "-u", username, pw_lck, NULL);
d301 1
a301 1
				    pw_dir, pw_lck, NULL);
@


1.23
log
@Add a username argument to pw_mkdb to match 'pwd_mkdb -u username'.
Crank the shlib major number due to the interface change.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.22 2000/08/01 22:10:16 provos Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.22 2000/08/01 22:10:16 provos Exp $";
d591 6
a596 2
	if (err)
		warn("%s", name);
@


1.22
log
@close fd for pw_lck on exec, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.21 2000/06/30 16:00:07 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.21 2000/06/30 16:00:07 millert Exp $";
d276 2
a277 1
pw_mkdb()
d295 8
a302 3
		if (pw_lck)
			execl(_PATH_PWD_MKDB, "pwd_mkdb", "-p", "-d", pw_dir,
			    pw_lck, NULL);
@


1.21
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.20 1998/11/16 07:10:32 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.20 1998/11/16 07:10:32 deraadt Exp $";
d266 4
@


1.20
log
@preserve errno; christos
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.19 1998/08/03 17:16:32 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.19 1998/08/03 17:16:32 millert Exp $";
d582 1
a582 1
		warn(name);
@


1.20.6.1
log
@Pull in patch from current:
Errata:
A format string vulnerability exists in the pw_error(3) function. This
manifests itself as a security hole in the chpass utility.
Fix:
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.20 1998/11/16 07:10:32 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.20 1998/11/16 07:10:32 deraadt Exp $";
d582 1
a582 1
		warn("%s", name);
@


1.19
log
@Use UID_MAX, not UINT_MAX.  Rename remove_trailing_space() to trim_whitespace() since it trims from both ends, not just the rear.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.18 1998/06/22 14:41:47 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.18 1998/06/22 14:41:47 millert Exp $";
d254 1
d265 3
a267 1
	umask(old_mode);
@


1.18
log
@add missing endusershell()
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.17 1998/03/23 22:40:52 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.17 1998/03/23 22:40:52 deraadt Exp $";
d75 1
a75 1
/* Removes trailers. */
d77 1
a77 1
remove_trailing_space(line)
d81 2
a82 1
	/* Remove trailing spaces */
d86 1
a86 1
	memcpy(line, p, strlen(p) + 1);
d88 1
d96 1
a96 1
/* Get one line, remove trailers */
d117 1
a117 1
	remove_trailing_space(line);
d204 1
a204 1
		     remove_trailing_space(p);
d206 1
a206 1
			  remove_trailing_space(p2);
d367 1
a367 1
	if (!(editor = getenv("EDITOR")))
d376 1
a376 1
	switch(editpid = vfork()) {
d509 1
a509 1
	if (id >= UINT_MAX) {
d511 1
a511 1
		warnx("uid greater than %u", UINT_MAX-1);
d525 1
a525 1
	if (id > UINT_MAX) {
d527 1
a527 1
		warnx("gid greater than %u", UINT_MAX-1);
@


1.17
log
@do not wait if vfork() fails
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.16 1997/11/18 19:57:28 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.16 1997/11/18 19:57:28 millert Exp $";
d549 1
a549 1
	if (root && *p)					/* empty == /bin/sh */
d558 2
@


1.16
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.15 1997/11/17 22:46:03 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.15 1997/11/17 22:46:03 millert Exp $";
d282 2
@


1.15
log
@Go back to old file locking method, O_EXLOCK method has too many problems
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.14 1997/11/17 21:12:12 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.14 1997/11/17 21:12:12 millert Exp $";
d51 1
d53 1
d101 1
a101 1
	char   *p, *c;
a270 1
	char *lock;
d354 3
d454 1
a454 1
		(void)fprintf(to, "%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n",
d463 1
a463 1
		(void)fprintf(to, "%s:%s:%d:%d:%s:%ld:%ld:%s:%s:%s\n",
d557 1
a557 1
	if (p = strsep(&bp, ":")) {			/* too many */
@


1.14
log
@pw_mkdb() now returns -1 if ptmp is size 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.13 1997/11/17 20:56:57 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.13 1997/11/17 20:56:57 millert Exp $";
d253 1
a253 1
	/* Acquire the lock file. */
d255 2
a256 2
	fd = open(pw_lck, O_WRONLY|O_CREAT|O_NONBLOCK|O_EXLOCK, 0600);
	for (i = 0; i < retries && fd < 0 && errno == EAGAIN; i++) {
d258 1
a258 1
		fd = open(pw_lck, O_WRONLY|O_CREAT|O_NONBLOCK|O_EXLOCK, 0600);
a259 3
	/* Really want to use O_TRUNC above but there is a bug in open(2) */
	if (fd != -1)
		ftruncate(fd, 0);
@


1.13
log
@Work around bug in open(2) wrt O_TRUNC and O_SHLOCK|O_EXLOCK.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.12 1997/09/29 19:18:21 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.12 1997/09/29 19:18:21 deraadt Exp $";
d273 9
@


1.12
log
@fix yes/no prompt code for EOF case; wosch@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.11 1997/06/22 23:57:23 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.11 1997/06/22 23:57:23 millert Exp $";
d255 1
a255 1
	fd = open(pw_lck, O_WRONLY|O_CREAT|O_TRUNC|O_NONBLOCK|O_EXLOCK, 0600);
d258 1
a258 1
		fd = open(pw_lck, O_WRONLY|O_CREAT|O_TRUNC|O_NONBLOCK|O_EXLOCK, 0600);
d260 3
@


1.12.2.1
log
@Merge in 1.12 to 1.14 from the trunk;
    Work around bug in open(2) wrt O_TRUNC and O_SHLOCK|O_EXLOCK.
    pw_mkdb() now returns -1 if ptmp is size 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.14 1997/11/17 21:12:12 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.14 1997/11/17 21:12:12 millert Exp $";
d255 1
a255 1
	fd = open(pw_lck, O_WRONLY|O_CREAT|O_NONBLOCK|O_EXLOCK, 0600);
d258 1
a258 1
		fd = open(pw_lck, O_WRONLY|O_CREAT|O_NONBLOCK|O_EXLOCK, 0600);
a259 3
	/* Really want to use O_TRUNC above but there is a bug in open(2) */
	if (fd != -1)
		ftruncate(fd, 0);
a269 9
	struct stat sb;

	/* A zero length passwd file is never ok */
	if (pw_lck && stat(pw_lck, &sb) == 0) {
		if (sb.st_size == 0) {
			warnx("%s is zero length", pw_lck);
			return (-1);
		}
	}
@


1.12.2.2
log
@Merge in 1.14 to 1.15 from the trunk;
Go back to old file locking method, O_EXLOCK method has too many problems
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.12.2.1 1997/11/17 21:15:14 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.12.2.1 1997/11/17 21:15:14 millert Exp $";
d253 1
a253 1
	/* Acquire the lock file.  */
d255 2
a256 2
	fd = open(pw_lck, O_WRONLY|O_CREAT|O_EXCL, 0600);
	for (i = 0; i < retries && fd < 0 && errno == EEXIST; i++) {
d258 1
a258 1
		fd = open(pw_lck, O_WRONLY|O_CREAT|O_EXCL, 0600);
d260 3
@


1.11
log
@Use O_EXLOCK option of open(2) to open /etc/ptmp with an exclusive
lock.  This fixes a DOS bug where a user could run passwd(1) and
send it a SIGKILL, thus leaving /etc/ptmp in place.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.10 1997/06/17 10:10:42 niklas Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.10 1997/06/17 10:10:42 niklas Exp $";
d390 1
a390 1
	int c;
d394 4
a397 4
	c = getchar();
	if (c != EOF && c != '\n')
		while (getchar() != '\n');
	if (c == 'n')
@


1.10
log
@Add support to handle password files in directories other than /etc
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.9 1997/04/10 20:05:49 provos Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: passwd.c,v 1.1.4.1 1996/06/02 19:48:31 ghudson Exp $";
d255 2
a256 2
	fd = open(pw_lck, O_WRONLY|O_CREAT|O_EXCL, 0600);
	for (i = 0; i < retries && fd < 0 && errno == EEXIST; i++) {
d258 1
a258 1
		fd = open(pw_lck, O_WRONLY|O_CREAT|O_EXCL, 0600);
@


1.9
log
@give only default values when asked for.
@
text
@d1 2
a2 1
/*	$OpenBSD: passwd.c,v 1.8 1997/02/16 19:59:21 provos Exp $	*/
d37 1
a37 1
static char rcsid[] = "$NetBSD: passwd.c,v 1.1.4.1 1996/06/02 19:48:31 ghudson Exp $";
d69 4
d129 21
a149 1
/* Retrieve password information from the /etc/passwd.conf file,
a153 1

d170 5
a174 2
	if ((fp = fopen(_PATH_PASSWDCONF, "r")) == NULL) {
		if((p=(char *)pw_default(option))) {
d181 1
d224 20
d251 2
d255 1
a255 1
	fd = open(_PATH_MASTERPASSWD_LOCK, O_WRONLY|O_CREAT|O_EXCL, 0600);
d258 1
a258 2
		fd = open(_PATH_MASTERPASSWD_LOCK, O_WRONLY|O_CREAT|O_EXCL,
			  0600);
d261 1
a261 1
	return(fd);
d269 1
d273 3
a275 2
		execl(_PATH_PWD_MKDB, "pwd_mkdb", "-p",
		      _PATH_MASTERPASSWD_LOCK, NULL);
d280 2
a281 2
		return(-1);
	return(0);
d287 1
a287 1
	return(unlink(_PATH_MASTERPASSWD_LOCK));
d330 3
d344 6
a349 2
	if (!filename)
		filename = _PATH_MASTERPASSWD_LOCK;
d406 4
a409 3
	FILE *from, *to;
	int done;
	char *p, buf[8192];
d411 2
d414 1
a414 1
		pw_error(_PATH_MASTERPASSWD, 1, 1);
d416 1
a416 1
		pw_error(_PATH_MASTERPASSWD_LOCK, 1, 1);
d420 1
a420 1
			warnx("%s: line too long", _PATH_MASTERPASSWD);
d430 1
a430 1
			warnx("%s: corrupted entry", _PATH_MASTERPASSWD);
d456 2
a457 1
err:		pw_error(NULL, 1, 1);
d557 2
d561 2
a562 2

	warnx("%s: unchanged", _PATH_MASTERPASSWD);
@


1.8
log
@added password configuration access function, used to determine
password cipher type at the moment
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.7 1997/02/15 09:47:54 provos Exp $	*/
d141 2
a142 3
	int     defaultw;
	int     keyw;
	int     got;
d154 2
a155 4
	defaultw = 0;
	keyw = 0;
	got = 0;
	while (!keyw && (got || read_line(fp, line, LINE_MAX))) {
d157 22
a178 29
		if (!strcmp("default:", line))
			defaultw = 1;
		if (!strncmp(key, line, strlen(key)) &&
		    line[strlen(key)] == ':')
			keyw = 1;

		/* Now we found default or specified key */
		if (defaultw || keyw) {
			while (read_line(fp, line, LINE_MAX)) {
				char   *p2;
				/* Leaving key field */
				if (strchr(line, ':')) {
					got = 1;
					keyw = 0;
					break;
				}
				p2 = line;
				if (!(p = strsep(&p2, "=")) || p2 == NULL)
					continue;
				remove_trailing_space(p);
				if (!strncmp(p, option, strlen(option))) {
					remove_trailing_space(p2);
					strcpy(result, p2);
					break;
				}
			}
			if (keyw)
				break;
			defaultw = 0;
d183 4
a186 1
	/* If we got no result and have a default use that */
d188 2
a189 1
	if (!strlen(result) && (p=(char *)pw_default(option)))
@


1.7
log
@when using strsep you should be aware that the delimiter will be replaced
by a nifty '0', so you cant check for a colon instead and dump some
I am sorry, Dave. I can't do that.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.6 1997/02/13 05:41:38 deraadt Exp $	*/
d58 2
d61 140
@


1.6
log
@permit 32-bit uid/gid, help from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.5 1996/12/06 01:55:33 deraadt Exp $	*/
d290 1
a290 1
	if (*p2 != ':') {
d306 1
a306 1
	if (*p2 != ':') {
@


1.5
log
@vfork w/ exit botch
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.4 1996/06/19 12:36:01 deraadt Exp $	*/
d269 1
a269 1
	long id;
d271 1
a271 1
	char *p, *sh;
d285 1
a285 1
	id = atol(p);
d290 2
a291 2
	if (id > USHRT_MAX) {
		warnx("%s > max uid value (%d)", p, USHRT_MAX);
d294 6
a299 1
	pw->pw_uid = id;
d305 8
a312 3
	id = atol(p);
	if (id > USHRT_MAX) {
		warnx("%s > max gid value (%d)", p, USHRT_MAX);
d315 1
a315 1
	pw->pw_gid = id;
@


1.4
log
@do not unexpectedly unlink the ptmp file; also support SIG*STOP cleanly
with our changes which permit "EDITOR=emacs -nw" to work.
@
text
@d1 1
a1 1
/*	$OpenBSD: passwd.c,v 1.3 1996/06/17 07:46:04 downsj Exp $	*/
d89 1
a89 1
		exit(1);
@


1.3
log
@util.h: new resting place
opendev.h: ok, so I merged it with util.h
opendev.h: use util.h
everything else: use "util.h"
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 1
static char rcsid[] = "$NetBSD: passwd.c,v 1.1 1996/05/15 21:42:31 jtc Exp $";
d92 1
a92 2
	if (pid == -1 || !WIFEXITED(pstat) || WEXITSTATUS(pstat) != 0) {
		unlink(_PATH_MASTERPASSWD_LOCK);
a93 1
	}
d152 1
d163 1
d165 5
a169 1
	if (!(editpid = vfork())) {
d174 2
a175 2
		system(p);
		_exit(1);
d177 1
a355 1

@


1.2
log
@system() $EDITOR safely
@
text
@d1 1
d55 2
a56 1
#include <util.h>
@


1.1
log
@libutil
@
text
@d157 5
a161 4
	if (p = strrchr(editor, '/'))
		++p;
	else 
		p = editor;
d168 1
a168 1
		execlp(editor, p, filename, NULL);
d171 1
@
