head	1.18;
access;
symbols
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2;
locks; strict;
comment	@.\" @;


1.18
date	2017.03.24.09.34.12;	author nicm;	state Exp;
branches;
next	1.17;
commitid	QszrwQgFVH5kVMEZ;

1.17
date	2016.10.15.12.33.22;	author jmc;	state Exp;
branches;
next	1.16;
commitid	TAXootsGnjCwVrWR;

1.16
date	2016.10.10.17.15.30;	author reyk;	state Exp;
branches;
next	1.15;
commitid	AJc9DjiTFHA9oTHW;

1.15
date	2015.12.29.18.05.23;	author benno;	state Exp;
branches;
next	1.14;
commitid	yppSgprLuiIhfzge;

1.14
date	2015.12.05.13.06.52;	author claudio;	state Exp;
branches;
next	1.13;
commitid	bO7nv9h60CrvWdTu;

1.13
date	2015.07.11.16.23.59;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	VfcIDpmFrGPTlEL3;

1.12
date	2015.06.11.19.25.53;	author reyk;	state Exp;
branches;
next	1.11;
commitid	AhlxY9CEyPGAUGpD;

1.11
date	2013.12.26.17.32.33;	author eric;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.13.21.04.46;	author benno;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.05.03.40.26;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.15.15.31.36;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2012.10.22.07.15.56;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.15.23.44.43;	author jmatthew;	state Exp;
branches;
next	1.5;

1.5
date	2011.06.23.22.07.14;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2011.03.05.15.05.39;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.31.17.33.33;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.28.01.04.14;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.26.16.44.32;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Use C99 types (uint32_t) instead of BSD (u_int32_t) - the former are
more portable. Add stdint.h to the headers in imsg_init(3).

No objections from millert@@.
@
text
@.\" $OpenBSD: imsg_init.3,v 1.17 2016/10/15 12:33:22 jmc Exp $
.\"
.\" Copyright (c) 2010 Nicholas Marriott <nicm@@openbsd.org>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
.\" IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
.\" OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: October 15 2016 $
.Dt IMSG_INIT 3
.Os
.Sh NAME
.Nm imsg_init ,
.Nm imsg_read ,
.Nm imsg_get ,
.Nm imsg_compose ,
.Nm imsg_composev ,
.Nm imsg_create ,
.Nm imsg_add ,
.Nm imsg_close ,
.Nm imsg_free ,
.Nm imsg_flush ,
.Nm imsg_clear ,
.Nm ibuf_open ,
.Nm ibuf_dynamic ,
.Nm ibuf_add ,
.Nm ibuf_reserve ,
.Nm ibuf_seek ,
.Nm ibuf_size ,
.Nm ibuf_left ,
.Nm ibuf_close ,
.Nm ibuf_write ,
.Nm ibuf_free ,
.Nm msgbuf_init ,
.Nm msgbuf_clear ,
.Nm msgbuf_write ,
.Nm msgbuf_drain
.Nd IPC messaging functions
.Sh SYNOPSIS
.In sys/types.h
.In sys/queue.h
.In sys/uio.h
.In stdint.h
.In imsg.h
.Ft void
.Fn imsg_init "struct imsgbuf *ibuf" "int fd"
.Ft ssize_t
.Fn imsg_read "struct imsgbuf *ibuf"
.Ft ssize_t
.Fn imsg_get "struct imsgbuf *ibuf" "struct imsg *imsg"
.Ft int
.Fn imsg_compose "struct imsgbuf *ibuf" "uint32_t type" "uint32_t peerid" \
    "pid_t pid" "int fd" "const void *data" "uint16_t datalen"
.Ft int
.Fn imsg_composev "struct imsgbuf *ibuf" "uint32_t type" "uint32_t peerid" \
    "pid_t pid" "int fd" "const struct iovec *iov" "int iovcnt"
.Ft "struct ibuf *"
.Fn imsg_create "struct imsgbuf *ibuf" "uint32_t type" "uint32_t peerid" \
    "pid_t pid" "uint16_t datalen"
.Ft int
.Fn imsg_add "struct ibuf *buf" "const void *data" "uint16_t datalen"
.Ft void
.Fn imsg_close "struct imsgbuf *ibuf" "struct ibuf *msg"
.Ft void
.Fn imsg_free "struct imsg *imsg"
.Ft int
.Fn imsg_flush "struct imsgbuf *ibuf"
.Ft void
.Fn imsg_clear "struct imsgbuf *ibuf"
.Ft "struct ibuf *"
.Fn ibuf_open "size_t len"
.Ft "struct ibuf *"
.Fn ibuf_dynamic "size_t len" "size_t max"
.Ft int
.Fn ibuf_add "struct ibuf *buf" "const void *data" "size_t len"
.Ft "void *"
.Fn ibuf_reserve "struct ibuf *buf" "size_t len"
.Ft "void *"
.Fn ibuf_seek "struct ibuf *buf" "size_t pos" "size_t len"
.Ft size_t
.Fn ibuf_size "struct ibuf *buf"
.Ft size_t
.Fn ibuf_left "struct ibuf *buf"
.Ft void
.Fn ibuf_close "struct msgbuf *msgbuf" "struct ibuf *buf"
.Ft int
.Fn ibuf_write "struct msgbuf *msgbuf"
.Ft void
.Fn ibuf_free "struct ibuf *buf"
.Ft void
.Fn msgbuf_init "struct msgbuf *msgbuf"
.Ft void
.Fn msgbuf_clear "struct msgbuf *msgbuf"
.Ft int
.Fn msgbuf_write "struct msgbuf *msgbuf"
.Ft void
.Fn msgbuf_drain "struct msgbuf *msgbuf" "size_t n"
.Sh DESCRIPTION
The
.Nm imsg
functions provide a simple mechanism for communication between processes
using sockets.
Each transmitted message is guaranteed to be presented to the receiving program
whole.
They are commonly used in privilege separated processes, where processes with
different rights are required to cooperate.
.Pp
A program using these functions should be linked with
.Em -lutil .
.Pp
The basic
.Nm
structure is the
.Em imsgbuf ,
which wraps a file descriptor and represents one side of a channel on which
messages are sent and received:
.Bd -literal -offset indent
struct imsgbuf {
	TAILQ_HEAD(, imsg_fd)	fds;
	struct ibuf_read	r;
	struct msgbuf		w;
	int			fd;
	pid_t			pid;
};
.Ed
.Pp
.Fn imsg_init
is a routine which initializes
.Fa ibuf
as one side of a channel associated with
.Fa fd .
The file descriptor is used to send and receive messages,
but is not closed by any of the imsg functions.
An imsgbuf is initialized with the
.Em w
member as the output buffer queue,
.Em fd
with the file descriptor passed to
.Fn imsg_init
and the other members for internal use only.
.Pp
The
.Fn imsg_clear
function frees any data allocated as part of an imsgbuf.
.Pp
.Fn imsg_create ,
.Fn imsg_add
and
.Fn imsg_close
are generic construction routines for messages that are to be sent using an
imsgbuf.
.Pp
.Fn imsg_create
creates a new message with header specified by
.Fa type ,
.Fa peerid
and
.Fa pid .
A
.Fa pid
of zero uses the process ID returned by
.Xr getpid 2
when
.Fa ibuf
was initialized.
In addition to this common imsg header,
.Fa datalen
bytes of space may be reserved for attaching to this imsg.
This space is populated using
.Fn imsg_add .
Additionally, the file descriptor
.Fa fd
may be passed over the socket to the other process.
If
.Fa fd
is given, it is closed in the sending program after the message is sent.
A value of \-1 indicates no file descriptor should be passed.
.Fn imsg_create
returns a pointer to a new message if it succeeds, NULL otherwise.
.Pp
.Fn imsg_add
appends to
.Fa imsg
.Fa len
bytes of ancillary data pointed to by
.Fa buf .
It returns
.Fa len
if it succeeds, \-1 otherwise.
.Pp
.Fn imsg_close
completes creation of
.Fa imsg
by adding it to
.Fa imsgbuf
output buffer.
.Pp
.Fn imsg_compose
is a routine which is used to quickly create and queue an imsg.
It takes the same parameters as the
.Fn imsg_create ,
.Fn imsg_add
and
.Fn imsg_close
routines,
except that only one ancillary data buffer can be provided.
This routine returns 1 if it succeeds, \-1 otherwise.
.Pp
.Fn imsg_composev
is similar to
.Fn imsg_compose .
It takes the same parameters, except that the ancillary data buffer is specified
by
.Fa iovec .
.Pp
.Fn imsg_flush
is a function which calls
.Fn msgbuf_write
in a loop until all imsgs in the output buffer are sent.
It returns 0 if it succeeds, \-1 otherwise.
.Pp
The
.Fn imsg_read
routine reads pending data with
.Xr recvmsg 2
and queues it as individual messages on
.Fa imsgbuf .
It returns the number of bytes read on success, or \-1 on error.
A return value of \-1 from
.Fn imsg_read
invalidates
.Fa imsgbuf ,
and renders it suitable only for passing to
.Fn imsg_clear .
.Pp
.Fn imsg_get
fills in an individual imsg pending on
.Fa imsgbuf
into the structure pointed to by
.Fa imsg .
It returns the total size of the message, 0 if no messages are ready, or \-1
for an error.
Received messages are returned as a
.Em struct imsg ,
which must be freed by
.Fn imsg_free
when no longer required.
.Em struct imsg
has this form:
.Bd -literal -offset indent
struct imsg {
	struct imsg_hdr	 hdr;
	int		 fd;
	void		*data;
};

struct imsg_hdr {
	uint32_t	 type;
	uint16_t	 len;
	uint16_t	 flags;
	uint32_t	 peerid;
	uint32_t	 pid;
};
.Ed
.Pp
The header members are:
.Bl -tag -width Ds -offset indent
.It type
A integer identifier, typically used to express the meaning of the message.
.It len
The total length of the imsg, including the header and any ancillary data
transmitted with the message (pointed to by the
.Em data
member of the message itself).
.It flags
Flags used internally by the imsg functions: should not be used by application
programs.
.It peerid, pid
32-bit values specified on message creation and free for any use by the
caller, normally used to identify the message sender.
.El
.Pp
In addition,
.Em struct imsg
has the following:
.Bl -tag -width Ds -offset indent
.It fd
The file descriptor specified when the message was created and passed using the
socket control message API, or \-1 if no file descriptor was sent.
.It data
A pointer to the ancillary data transmitted with the imsg.
.El
.Pp
The IMSG_HEADER_SIZE define is the size of the imsg message header, which
may be subtracted from the
.Fa len
member of
.Em struct imsg_hdr
to obtain the length of any additional data passed with the message.
.Pp
MAX_IMSGSIZE is defined as the maximum size of a single imsg, currently
16384 bytes.
.Sh BUFFERS
The imsg API defines functions to manipulate buffers, used internally and during
construction of imsgs with
.Fn imsg_create .
A
.Em struct ibuf
is a single buffer and a
.Em struct msgbuf
a queue of output buffers for transmission:
.Bd -literal -offset indent
struct ibuf {
	TAILQ_ENTRY(ibuf)	 entry;
	u_char			*buf;
	size_t			 size;
	size_t			 max;
	size_t			 wpos;
	size_t			 rpos;
	int			 fd;
};

struct msgbuf {
	TAILQ_HEAD(, ibuf)	 bufs;
	uint32_t		 queued;
	int			 fd;
};
.Ed
.Pp
The
.Fn ibuf_open
function allocates a fixed-length buffer.
The buffer may not be resized and may contain a maximum of
.Fa len
bytes.
On success
.Fn ibuf_open
returns a pointer to the buffer; on failure it returns NULL.
.Pp
.Fn ibuf_dynamic
allocates a resizeable buffer of initial length
.Fa len
and maximum size
.Fa max .
Buffers allocated with
.Fn ibuf_dynamic
are automatically grown if necessary when data is added.
.Pp
.Fn ibuf_add
is a routine which appends a block of data to
.Fa buf .
0 is returned on success and \-1 on failure.
.Pp
.Fn ibuf_reserve
is used to reserve
.Fa len
bytes in
.Fa buf .
A pointer to the start of the reserved space is returned, or NULL on error.
.Pp
.Fn ibuf_seek
is a function which returns a pointer to the part of the buffer at offset
.Fa pos
and of extent
.Fa len .
NULL is returned if the requested range is outside the part of the buffer
in use.
.Pp
.Fn ibuf_size
and
.Fn ibuf_left
are functions which return the total bytes used and available in
.Fa buf
respectively.
.Pp
.Fn ibuf_close
appends
.Fa buf
to
.Fa msgbuf
ready to be sent.
.Pp
The
.Fn ibuf_write
routine transmits as many pending buffers as possible from
.Fn msgbuf
using
.Xr writev 2 .
It returns 1 if it succeeds, \-1 on error and 0 when no buffers were
pending or an EOF condition on the socket is detected.
Temporary resource shortages are returned with errno
.Er EAGAIN
and require the application to retry again in the future.
.Pp
.Fn ibuf_free
frees
.Fa buf
and any associated storage.
If
.Fa buf
is a NULL pointer, no action occurs.
.Pp
The
.Fn msgbuf_init
function initializes
.Fa msgbuf
so that buffers may be appended to it.
The
.Em fd
member should also be set directly before
.Fn msgbuf_write
is used.
.Pp
.Fn msgbuf_clear
empties a msgbuf, removing and discarding any queued buffers.
.Pp
The
.Fn msgbuf_write
routine calls
.Xr sendmsg 2
to transmit buffers queued in
.Fa msgbuf .
It returns 1 if it succeeds, \-1 on error, and 0 when the queue was empty
or an EOF condition on the socket is detected.
Temporary resource shortages are returned with errno
.Er EAGAIN
and require the application to retry again in the future.
.Pp
.Fn msgbuf_drain
discards data from buffers queued in
.Fa msgbuf
until
.Fa n
bytes have been removed or
.Fa msgbuf
is empty.
.Sh EXAMPLES
In a typical program, a channel between two processes is created with
.Xr socketpair 2 ,
and an
.Em imsgbuf
created around one file descriptor in each process:
.Bd -literal -offset indent
struct imsgbuf	parent_ibuf, child_ibuf;
int		imsg_fds[2];

if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, imsg_fds) == -1)
	err(1, "socketpair");

switch (fork()) {
case -1:
	err(1, "fork");
case 0:
	/* child */
	close(imsg_fds[0]);
	imsg_init(&child_ibuf, imsg_fds[1]);
	exit(child_main(&child_ibuf));
}

/* parent */
close(imsg_fds[1]);
imsg_init(&parent_ibuf, imsg_fds[0]);
exit(parent_main(&parent_ibuf));
.Ed
.Pp
Messages may then be composed and queued on the
.Em imsgbuf ,
for example using the
.Fn imsg_compose
function:
.Bd -literal -offset indent
enum imsg_type {
	IMSG_A_MESSAGE,
	IMSG_MESSAGE2
};

int
child_main(struct imsgbuf *ibuf)
{
	int	idata;
	...
	idata = 42;
	imsg_compose(ibuf, IMSG_A_MESSAGE,
		0, 0, -1, &idata, sizeof idata);
	...
}
.Ed
.Pp
A mechanism such as
.Xr poll 2
or the
.Xr event 3
library is used to monitor the socket file descriptor.
When the socket is ready for writing, queued messages are transmitted with
.Fn msgbuf_write :
.Bd -literal -offset indent
	if ((n = msgbuf_write(&ibuf-\*(Gtw)) == -1 && errno != EAGAIN) {
		/* handle write failure */
	}
	if (n == 0) {
		/* handle closed connection */
	}
.Ed
.Pp
And when ready for reading, messages are first received using
.Fn imsg_read
and then extracted with
.Fn imsg_get :
.Bd -literal -offset indent
void
dispatch_imsg(struct imsgbuf *ibuf)
{
	struct imsg	imsg;
	ssize_t         n, datalen;
	int		idata;

	if ((n = imsg_read(ibuf)) == -1 && errno != EAGAIN) {
		/* handle read error */
	}
	if (n == 0) {
		/* handle closed connection */
	}

	for (;;) {
		if ((n = imsg_get(ibuf, &imsg)) == -1) {
			/* handle read error */
		}
		if (n == 0)	/* no more messages */
			return;
		datalen = imsg.hdr.len - IMSG_HEADER_SIZE;

		switch (imsg.hdr.type) {
		case IMSG_A_MESSAGE:
			if (datalen \*(Lt sizeof idata) {
				/* handle corrupt message */
			}
			memcpy(&idata, imsg.data, sizeof idata);
			/* handle message received */
			break;
		...
		}

		imsg_free(&imsg);
	}
}
.Ed
.Sh SEE ALSO
.Xr socketpair 2 ,
.Xr unix 4
@


1.17
log
@zap trailing whitespace;
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.16 2016/10/10 17:15:30 reyk Exp $
d17 1
a17 1
.Dd $Mdocdate: October 10 2016 $
d51 1
d60 2
a61 2
.Fn imsg_compose "struct imsgbuf *ibuf" "u_int32_t type" "uint32_t peerid" \
    "pid_t pid" "int fd" "const void *data" "u_int16_t datalen"
d63 1
a63 1
.Fn imsg_composev "struct imsgbuf *ibuf" "u_int32_t type" "u_int32_t peerid" \
d66 2
a67 2
.Fn imsg_create "struct imsgbuf *ibuf" "u_int32_t type" "u_int32_t peerid" \
    "pid_t pid" "u_int16_t datalen"
d69 1
a69 1
.Fn imsg_add "struct ibuf *buf" "const void *data" "u_int16_t datalen"
d266 5
a270 5
	u_int32_t	 type;
	u_int16_t	 len;
	u_int16_t	 flags;
	u_int32_t	 peerid;
	u_int32_t	 pid;
d333 1
a333 1
	u_int32_t		 queued;
@


1.16
log
@Fixup the example for msgbuf_write() and imsg_read() to check the
error cases for -1 and 0 explicitly (it initially only checked for -1,
I updated it to also check for 0, and rzalamena@@ figured out that 0
has to be checked in a differently).

OK millert@@ rzalamena@@
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.15 2015/12/29 18:05:23 benno Exp $
d17 1
a17 1
.Dd $Mdocdate: December 29 2015 $
d509 1
a509 1
	}	
@


1.15
log
@mention that ibuf_free() does not need a NULL check.
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.14 2015/12/05 13:06:52 claudio Exp $
d17 1
a17 1
.Dd $Mdocdate: December 5 2015 $
d504 1
a504 1
	if (msgbuf_write(&ibuf-\*(Gtw) \*(Lt= 0 && errno != EAGAIN) {
d507 3
d524 5
a528 2
	if (((n = imsg_read(ibuf)) == -1 && errno != EAGAIN) || n == 0) {
		/* handle socket error */
@


1.14
log
@Do not loop on EAGAIN in imsg_read(). Better to return the error to the
caller and let him do another poll loop. This fixes spinning relayd
processes seen on busy TLS relays. OK benno@@ henning@@
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.13 2015/07/11 16:23:59 deraadt Exp $
d17 1
a17 1
.Dd $Mdocdate: July 11 2015 $
d406 3
@


1.13
log
@typo in embedded code block; from Ben Cornett
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.12 2015/06/11 19:25:53 reyk Exp $
d17 1
a17 1
.Dd $Mdocdate: June 11 2015 $
d518 1
a518 1
	if ((n = imsg_read(ibuf)) == -1 || n == 0) {
@


1.12
log
@The correct semantic is to check msgbuf_write() for <= 0, not just < 0.
Fix one occurence in imsg_flush() and clarify it the man page.

Discussed with at least blambert@@ jsg@@ yasuoka@@.

OK gilles@@
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.11 2013/12/26 17:32:33 eric Exp $
d17 1
a17 1
.Dd $Mdocdate: December 26 2013 $
d479 1
a479 1
}
@


1.11
log
@constify data parameter in imsg_add() and imsg_compose()

ok deraadt@@
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.10 2013/11/13 21:04:46 benno Exp $
d17 1
a17 1
.Dd $Mdocdate: November 13 2013 $
d396 2
a397 2
It returns 1 if it succeeds, \-1 on error and 0 when an EOF condition on the
socket is detected.
d427 2
a428 2
It returns 1 if it succeeds, \-1 on error, and 0 when an EOF condition on the
socket is detected.
d501 1
a501 1
	if (msgbuf_write(&ibuf-\*(Gtw) \*(Lt 0 && errno != EAGAIN) {
@


1.10
log
@document that ibuf_write() and msgbuf_write() can now return EAGAIN
from and with deraadt@@
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.9 2013/06/05 03:40:26 tedu Exp $
d17 1
a17 1
.Dd $Mdocdate: June 5 2013 $
d60 1
a60 1
    "pid_t pid" "int fd" "void *data" "u_int16_t datalen"
d68 1
a68 1
.Fn imsg_add "struct ibuf *buf" "void *data" "u_int16_t datalen"
@


1.9
log
@use fancy .In macro for includes. from Jan Klemkow. ok jmc schwarze
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.8 2012/11/15 15:31:36 krw Exp $
d17 1
a17 1
.Dd $Mdocdate: November 15 2012 $
d398 3
d429 3
d501 1
a501 1
	if (msgbuf_write(&ibuf-\*(Gtw) \*(Lt 0) {
@


1.8
log
@imsg_get() returns ssize_t, not size_t.
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.7 2012/10/22 07:15:56 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: October 22 2012 $
d48 4
a51 4
.Fd #include <sys/types.h>
.Fd #include <sys/queue.h>
.Fd #include <sys/uio.h>
.Fd #include <imsg.h>
@


1.7
log
@struct buf -> ibuf; from Sunil Nimmagadda
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.6 2012/06/15 23:44:43 jmatthew Exp $
d17 1
a17 1
.Dd $Mdocdate: June 15 2012 $
d56 1
a56 1
.Ft size_t
@


1.6
log
@update return values for ibuf_write and msgbuf_write

ok gilles@@
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.5 2011/06/23 22:07:14 sthen Exp $
d17 1
a17 1
.Dd $Mdocdate: June 23 2011 $
d321 1
a321 1
	TAILQ_ENTRY(buf)	 entry;
d331 1
a331 1
	TAILQ_HEAD(, buf)	 bufs;
@


1.5
log
@s/ands/and/, from Tobias Ulmer
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.4 2011/03/05 15:05:39 claudio Exp $
d17 1
a17 1
.Dd $Mdocdate: March 5 2011 $
d396 1
a396 1
It returns 0 if it succeeds, \-1 on error and \-2 when an EOF condition on the
d424 1
a424 1
It returns 0 if it succeeds, \-1 on error, or \-2 when an EOF condition on the
@


1.4
log
@Correct msgbuf_write() example. OK jmc@@ and nicm@@
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.3 2010/10/31 17:33:33 nicm Exp $
d17 1
a17 1
.Dd $Mdocdate: October 31 2010 $
d164 1
a164 1
ands
@


1.3
log
@imsg.h requires sys/uio.h, ok deraadt
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.2 2010/05/28 01:04:14 sthen Exp $
d17 1
a17 1
.Dd $Mdocdate: May 28 2010 $
d495 1
a495 1
	if (msgbuf_write(ibuf-\*(Gtw) \*(Lt 0) {
@


1.2
log
@typo; Ian McWilliam
@
text
@d1 1
a1 1
.\" $OpenBSD: imsg_init.3,v 1.1 2010/05/26 16:44:32 nicm Exp $
d17 1
a17 1
.Dd $Mdocdate: May 26 2010 $
d50 1
@


1.1
log
@Move imsg into libutil and add a man page.

Minor bump for libutil.

Previous versions of this diff and man page looked at by various people.

"you should just commit" deraadt
@
text
@d1 1
a1 1
.\" $OpenBSD$
d17 1
a17 1
.Dd $Mdocdate$
d251 1
a251 1
which much be freed by
@

