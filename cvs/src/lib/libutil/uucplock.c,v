head	1.19;
access;
symbols
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.26
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.18
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2016.08.30.14.52.09;	author guenther;	state Exp;
branches;
next	1.18;
commitid	c05U0HQb47xiQtQe;

1.18
date	2016.08.30.14.44.45;	author guenther;	state Exp;
branches;
next	1.17;
commitid	mK1myQm2bRfAlqwG;

1.17
date	2015.11.11.01.12.09;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	nVtGolYSsQ6VkRrW;

1.16
date	2009.10.27.23.59.30;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.30.20.56.54;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.28.21.54.06;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.03.00.14.17;	author cloder;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.28.07.03.48;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.20.18.42;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.22.18.43;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.26.09.29.02;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.29;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.09.21.04.52.46;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	99.08.17.09.13.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.03.16.01.26.02;	author brian;	state Exp;
branches;
next	1.4;

1.4
date	98.06.10.00.16.19;	author brian;	state Exp;
branches;
next	1.3;

1.3
date	98.06.08.20.28.30;	author brian;	state Exp;
branches;
next	1.2;

1.2
date	97.11.09.04.05.33;	author bri;	state Exp;
branches;
next	1.1;

1.1
date	97.11.09.00.29.15;	author bri;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Use a constant format string and output the variable part with %s

ok krw@@ millert@@
@
text
@/*	$OpenBSD: uucplock.c,v 1.18 2016/08/30 14:44:45 guenther Exp $	*/
/*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *
 */

#include <sys/types.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <paths.h>
#include <string.h>
#include "util.h"

#define MAXTRIES 5

#define LOCKTMP "LCKTMP..%ld"
#define LOCKFMT "LCK..%s"

#define GORET(level, val) { err = errno; uuerr = (val); \
			    goto __CONCAT(ret, level); }

/* Forward declarations */
static int put_pid(int fd, pid_t pid);
static pid_t get_pid(int fd,int *err);

/*
 * uucp style locking routines
 */
int
uu_lock(const char *ttyname)
{
	char lckname[sizeof(_PATH_UUCPLOCK) + MAXNAMLEN],
	     lcktmpname[sizeof(_PATH_UUCPLOCK) + MAXNAMLEN];
	int fd, tmpfd, i, err, uuerr;
	pid_t pid, pid_old;

	pid = getpid();
	(void)snprintf(lcktmpname, sizeof(lcktmpname), _PATH_UUCPLOCK LOCKTMP,
	    (long)pid);
	(void)snprintf(lckname, sizeof(lckname), _PATH_UUCPLOCK LOCKFMT,
	    ttyname);
	tmpfd = open(lcktmpname, O_CREAT|O_TRUNC|O_WRONLY|O_CLOEXEC, 0664);
	if (tmpfd < 0)
		GORET(0, UU_LOCK_CREAT_ERR);

	for (i = 0; i < MAXTRIES; i++) {
		if (link(lcktmpname, lckname) < 0) {
			if (errno != EEXIST)
				GORET(1, UU_LOCK_LINK_ERR);
			/*
			 * file is already locked
			 * check to see if the process holding the lock
			 * still exists
			 */
			if ((fd = open(lckname, O_RDONLY | O_CLOEXEC)) < 0)
				GORET(1, UU_LOCK_OPEN_ERR);

			if ((pid_old = get_pid(fd, &err)) == -1)
				GORET(2, UU_LOCK_READ_ERR);

			close(fd);

			if (kill(pid_old, 0) == 0 || errno != ESRCH)
				GORET(1, UU_LOCK_INUSE);
			/*
			 * The process that locked the file isn't running, so
			 * we'll lock it ourselves
			 */
			(void)unlink(lckname);
		} else {
			if (!put_pid(tmpfd, pid))
				GORET(3, UU_LOCK_WRITE_ERR);
			break;
		}
	}
	GORET(1, (i >= MAXTRIES) ? UU_LOCK_TRY_ERR : UU_LOCK_OK);

ret3:
	(void)unlink(lckname);
	goto ret1;
ret2:
	(void)close(fd);
ret1:
	(void)close(tmpfd);
	(void)unlink(lcktmpname);
ret0:
	errno = err;
	return uuerr;
}

int
uu_lock_txfr(const char *ttyname, pid_t pid)
{
	char lckname[sizeof(_PATH_UUCPLOCK) + MAXNAMLEN];
	int fd, err, ret;

	snprintf(lckname, sizeof(lckname), _PATH_UUCPLOCK LOCKFMT, ttyname);

	if ((fd = open(lckname, O_RDWR | O_CLOEXEC)) < 0)
		return UU_LOCK_OWNER_ERR;
	if (get_pid(fd, &err) != getpid())
		ret = UU_LOCK_OWNER_ERR;
	else {
		lseek(fd, 0, SEEK_SET);
		ret = put_pid(fd, pid) ? UU_LOCK_OK : UU_LOCK_WRITE_ERR;
	}

	close(fd);
	return ret;
}

int
uu_unlock(const char *ttyname)
{
	char tbuf[sizeof(_PATH_UUCPLOCK) + MAXNAMLEN];

	(void)snprintf(tbuf, sizeof(tbuf), _PATH_UUCPLOCK LOCKFMT, ttyname);
	return unlink(tbuf);
}

const char *
uu_lockerr(int uu_lockresult)
{
	static char errbuf[128];
	const char *err;

	switch (uu_lockresult) {
	case UU_LOCK_INUSE:
		return "device in use";
	case UU_LOCK_OK:
		return "";
	case UU_LOCK_OPEN_ERR:
		err = "open error";
		break;
	case UU_LOCK_READ_ERR:
		err = "read error";
		break;
	case UU_LOCK_CREAT_ERR:
		err = "creat error";
		break;
	case UU_LOCK_WRITE_ERR:
		err = "write error";
		break;
	case UU_LOCK_LINK_ERR:
		err = "link error";
		break;
	case UU_LOCK_TRY_ERR:
		err = "too many tries";
		break;
	case UU_LOCK_OWNER_ERR:
		err = "not locking process";
		break;
	default:
		err = "undefined error";
		break;
	}

	(void)snprintf(errbuf, sizeof(errbuf), "%s: %s", err, strerror(errno));
	return errbuf;
}

static int
put_pid(int fd, pid_t pid)
{
	char buf[32];
	int len;

	len = snprintf(buf, sizeof buf, "%10ld\n", (long)pid);

	if (len < sizeof buf && len != -1 && write(fd, buf, (size_t)len) == len) {
		/* We don't mind too much if ftruncate() fails - see get_pid */
		ftruncate(fd, (off_t)len);
		return 1;
	}
	return 0;
}

static pid_t
get_pid(int fd, int *err)
{
	ssize_t bytes_read;
	char buf[32];
	pid_t pid;

	bytes_read = read(fd, buf, sizeof (buf) - 1);
	if (bytes_read > 0) {
		buf[bytes_read] = '\0';
		pid = (pid_t)strtoul(buf, (char **) NULL, 10);
	} else {
		pid = -1;
		*err = bytes_read ? errno : EINVAL;
	}
	return pid;
}
@


1.18
log
@Use O_CLOEXEC when opening fds local to a function

ok jca@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uucplock.c,v 1.17 2015/11/11 01:12:09 deraadt Exp $	*/
d156 1
a156 1
	char *fmt;
d164 1
a164 1
		fmt = "open error: %s";
d167 1
a167 1
		fmt = "read error: %s";
d170 1
a170 1
		fmt = "creat error: %s";
d173 1
a173 1
		fmt = "write error: %s";
d176 1
a176 1
		fmt = "link error: %s";
d179 1
a179 1
		fmt = "too many tries: %s";
d182 1
a182 1
		fmt = "not locking process: %s";
d185 1
a185 1
		fmt = "undefined error: %s";
d189 1
a189 1
	(void)snprintf(errbuf, sizeof(errbuf), fmt, strerror(errno));
@


1.17
log
@creat() -> open equiv; from Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: uucplock.c,v 1.16 2009/10/27 23:59:30 deraadt Exp $	*/
d73 2
a74 1
	if ((tmpfd = open(lcktmpname, O_CREAT | O_TRUNC | O_WRONLY, 0664)) < 0)
d86 1
a86 1
			if ((fd = open(lckname, O_RDONLY)) < 0)
d130 1
a130 1
	if ((fd = open(lckname, O_RDWR)) < 0)
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: uucplock.c,v 1.15 2006/03/30 20:56:54 deraadt Exp $	*/
d73 1
a73 1
	if ((tmpfd = creat(lcktmpname, 0664)) < 0)
@


1.15
log
@casts that cannot cause breakage in the future
@
text
@d1 1
a1 1
/*	$OpenBSD: uucplock.c,v 1.14 2005/11/28 21:54:06 deraadt Exp $	*/
a31 4

#ifndef lint
static const char sccsid[] = "@@(#)uucplock.c	8.1 (Berkeley) 6/6/93";
#endif /* not lint */
@


1.14
log
@spaces, and a off_t typecast to please lint
@
text
@d1 1
a1 1
/*	$OpenBSD: uucplock.c,v 1.13 2005/03/03 00:14:17 cloder Exp $	*/
d204 1
a204 1
	if (len < sizeof buf && len != -1 && write (fd, buf, len) == len) {
d215 1
a215 1
	int bytes_read;
d222 1
a222 1
		pid = strtoul(buf, (char **) NULL, 10);
@


1.13
log
@Make sure we check snprintf return value for failure or truncation before
using it.  Make uu_lock_txfr work by properly checking return value from
put_pid().  Fix an FD leak on the lockfile in an error path (from FreeBSD
with modifications).  OK millert@@, input from otto@@ and Bruno Rohee.
@
text
@d1 1
a1 1
/*	$OpenBSD: uucplock.c,v 1.12 2004/05/28 07:03:48 deraadt Exp $	*/
d81 1
a81 1
		if (link (lcktmpname, lckname) < 0) {
d92 1
a92 1
			if ((pid_old = get_pid (fd, &err)) == -1)
d105 1
a105 1
			if (!put_pid (tmpfd, pid))
d206 1
a206 1
		ftruncate(fd, len);
d219 1
a219 1
	bytes_read = read (fd, buf, sizeof (buf) - 1);
d222 1
a222 1
		pid = strtoul (buf, (char **) NULL, 10);
@


1.12
log
@knf; otto ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uucplock.c,v 1.11 2003/06/02 20:18:42 millert Exp $	*/
d129 1
a129 1
	int fd, err;
d136 6
a141 4
		return UU_LOCK_OWNER_ERR;
        lseek(fd, 0, SEEK_SET);
	if (put_pid(fd, pid))
		return UU_LOCK_WRITE_ERR;
d143 1
a143 2

	return UU_LOCK_OK;
d204 1
a204 1
	if (write (fd, buf, len) == len) {
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uucplock.c,v 1.10 2002/06/09 22:18:43 fgsch Exp $	*/
a63 1

d65 1
a65 2
uu_lock(ttyname)
	const char *ttyname;
a66 2
	int fd, tmpfd, i;
	pid_t pid, pid_old;
d69 2
a70 1
	int err, uuerr;
d74 1
a74 1
			(long)pid);
d76 1
a76 1
			ttyname);
d126 1
a126 3
uu_lock_txfr(ttyname, pid)
	const char *ttyname;
	pid_t pid;
d128 1
a129 1
	char lckname[sizeof(_PATH_UUCPLOCK) + MAXNAMLEN];
d146 1
a146 2
uu_unlock(ttyname)
	const char *ttyname;
d155 1
a155 2
uu_lockerr(uu_lockresult)
	int uu_lockresult;
d196 1
a196 3
put_pid(fd, pid)
	int fd;
	pid_t pid;
d212 1
a212 3
get_pid(fd, err)
	int fd;
	int *err;
@


1.10
log
@some -Wall and spaces cleanup, scsi.c left.
some brave soul should look at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uucplock.c,v 1.9 2002/05/26 09:29:02 deraadt Exp $	*/
d14 1
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@pid_t cleanup
@
text
@d1 1
a1 1
/* * $OpenBSD: uucplock.c,v 1.8 2002/02/16 21:27:29 millert Exp $*/
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* * $OpenBSD: uucplock.c,v 1.7 1999/09/21 04:52:46 csapuntz Exp $*/
d55 1
a55 1
#define LOCKTMP "LCKTMP..%d"
d81 1
a81 1
			pid);
d214 1
a214 1
	len = sprintf (buf, "%10d\n", (int)pid);
@


1.7
log
@

Add opendisk from NetBSD.

Add OpenBSD tags to files
@
text
@d1 1
a1 1
/* * $OpenBSD: uucplock.c,v 1.6 1999/08/17 09:13:13 millert Exp $*/
d62 2
a63 2
static int put_pid __P((int fd, pid_t pid));
static pid_t get_pid __P((int fd,int *err));
@


1.6
log
@More <sys/file.h> vs. <fcntl.h> and open() flags fixes.
@
text
@d1 1
a33 1
 * $Id: uucplock.c,v 1.5 1999/03/16 01:26:02 brian Exp $
@


1.5
log
@Get the pid right if a stale lock file exists.
Submitted by: Lawrence D. Lopez <lopez@@cisco.com>
@
text
@d33 1
a33 1
 * $Id: uucplock.c,v 1.4 1998/06/10 00:16:19 brian Exp $
a41 1
#include <sys/file.h>
d44 1
@


1.4
log
@Cast pid_t to int for sprintf.
Pointed out by: Charlie Sorsby <crs@@hgo.net>
@
text
@d33 1
a33 1
 * $Id: uucplock.c,v 1.3 1998/06/08 20:28:30 brian Exp $
d74 1
a74 1
	pid_t pid;
d99 1
a99 1
			if ((pid = get_pid (fd, &err)) == -1)
d104 1
a104 1
			if (kill(pid, 0) == 0 || errno != ESRCH)
@


1.3
log
@Add uu_lock_txfr() for donating locks to another process.
Reviewed by: Theo
@
text
@d33 1
a33 1
 * $Id: uucplock.c,v 1.2 1997/11/09 04:05:33 bri Exp $
d214 1
a214 1
	len = sprintf (buf, "%10d\n", pid);
@


1.2
log
@Correct the ftruncate() call.
@
text
@d33 1
a33 1
 * $Id: uucplock.c,v 1.1 1997/11/09 00:29:15 bri Exp $
d133 22
d193 3
@


1.1
log
@Introduce uu_lock(), uu_unlock() and uu_lockerr()
into libutil.
Obtained from: FreeBSD
Reviewed by: Theo
@
text
@d33 1
a33 1
 * $Id: uucplock.c,v 1.8 1997/08/10 18:42:39 ache Exp $
d190 7
a196 1
	return write (fd, buf, len) == len && ftruncate(fd, len);
@
