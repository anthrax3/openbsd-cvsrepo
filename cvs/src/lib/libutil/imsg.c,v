head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.4
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.4
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.8
	OPENBSD_5_0:1.1.0.6
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.4
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.2
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.04.11.09.57.19;	author reyk;	state Exp;
branches;
next	1.14;
commitid	cBFGQ7B7gtFkufw1;

1.14
date	2017.03.24.09.34.12;	author nicm;	state Exp;
branches;
next	1.13;
commitid	QszrwQgFVH5kVMEZ;

1.13
date	2015.12.09.11.54.12;	author tb;	state Exp;
branches;
next	1.12;
commitid	qgLygfL4HntB1G86;

1.12
date	2015.12.05.13.06.52;	author claudio;	state Exp;
branches;
next	1.11;
commitid	bO7nv9h60CrvWdTu;

1.11
date	2015.11.27.01.57.59;	author mmcc;	state Exp;
branches;
next	1.10;
commitid	J3iMlBAQfZQZG24h;

1.10
date	2015.07.19.07.18.59;	author nicm;	state Exp;
branches;
next	1.9;
commitid	Cc8nEFJJa5vTygh7;

1.9
date	2015.07.12.18.40.49;	author nicm;	state Exp;
branches;
next	1.8;
commitid	NQOgLhravifnlyCi;

1.8
date	2015.07.03.14.50.14;	author brynet;	state Exp;
branches;
next	1.7;
commitid	eYjsXukviE7UIadw;

1.7
date	2015.06.11.19.25.53;	author reyk;	state Exp;
branches;
next	1.6;
commitid	AhlxY9CEyPGAUGpD;

1.6
date	2014.06.30.00.26.22;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	73bnyBlMld7YtdVw;

1.5
date	2013.12.26.17.32.33;	author eric;	state Exp;
branches;
next	1.4;

1.4
date	2013.02.01.15.22.18;	author gilles;	state Exp;
branches;
next	1.3;

1.3
date	2012.12.19.13.37.12;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.02.21.46.53;	author gilles;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.26.16.44.32;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Use freezero(3) for the imsg framework in imsg_free(3) and ibuf_free(3).

In our privsep model, imsg is often used to transport sensitive
information between processes.  But a process might free an imsg, and
reuse the memory for a different thing.  iked uses some
explicit_bzero() to clean imsg-buffer but doing it in the library with
the freezero() is less error-prone and also benefits other daemons.

OK deraadt@@ jsing@@ claudio@@
@
text
@/*	$OpenBSD: imsg.c,v 1.14 2017/03/24 09:34:12 nicm Exp $	*/

/*
 * Copyright (c) 2003, 2004 Henning Brauer <henning@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/uio.h>

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "imsg.h"

int	 imsg_fd_overhead = 0;

int	 imsg_get_fd(struct imsgbuf *);

void
imsg_init(struct imsgbuf *ibuf, int fd)
{
	msgbuf_init(&ibuf->w);
	memset(&ibuf->r, 0, sizeof(ibuf->r));
	ibuf->fd = fd;
	ibuf->w.fd = fd;
	ibuf->pid = getpid();
	TAILQ_INIT(&ibuf->fds);
}

ssize_t
imsg_read(struct imsgbuf *ibuf)
{
	struct msghdr		 msg;
	struct cmsghdr		*cmsg;
	union {
		struct cmsghdr hdr;
		char	buf[CMSG_SPACE(sizeof(int) * 1)];
	} cmsgbuf;
	struct iovec		 iov;
	ssize_t			 n = -1;
	int			 fd;
	struct imsg_fd		*ifd;

	memset(&msg, 0, sizeof(msg));
	memset(&cmsgbuf, 0, sizeof(cmsgbuf));

	iov.iov_base = ibuf->r.buf + ibuf->r.wpos;
	iov.iov_len = sizeof(ibuf->r.buf) - ibuf->r.wpos;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = &cmsgbuf.buf;
	msg.msg_controllen = sizeof(cmsgbuf.buf);

	if ((ifd = calloc(1, sizeof(struct imsg_fd))) == NULL)
		return (-1);

again:
	if (getdtablecount() + imsg_fd_overhead +
	    (int)((CMSG_SPACE(sizeof(int))-CMSG_SPACE(0))/sizeof(int))
	    >= getdtablesize()) {
		errno = EAGAIN;
		free(ifd);
		return (-1);
	}

	if ((n = recvmsg(ibuf->fd, &msg, 0)) == -1) {
		if (errno == EINTR)
			goto again;
		goto fail;
	}

	ibuf->r.wpos += n;

	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
	    cmsg = CMSG_NXTHDR(&msg, cmsg)) {
		if (cmsg->cmsg_level == SOL_SOCKET &&
		    cmsg->cmsg_type == SCM_RIGHTS) {
			int i;
			int j;

			/*
			 * We only accept one file descriptor.  Due to C
			 * padding rules, our control buffer might contain
			 * more than one fd, and we must close them.
			 */
			j = ((char *)cmsg + cmsg->cmsg_len -
			    (char *)CMSG_DATA(cmsg)) / sizeof(int);
			for (i = 0; i < j; i++) {
				fd = ((int *)CMSG_DATA(cmsg))[i];
				if (ifd != NULL) {
					ifd->fd = fd;
					TAILQ_INSERT_TAIL(&ibuf->fds, ifd,
					    entry);
					ifd = NULL;
				} else
					close(fd);
			}
		}
		/* we do not handle other ctl data level */
	}

fail:
	free(ifd);
	return (n);
}

ssize_t
imsg_get(struct imsgbuf *ibuf, struct imsg *imsg)
{
	size_t			 av, left, datalen;

	av = ibuf->r.wpos;

	if (IMSG_HEADER_SIZE > av)
		return (0);

	memcpy(&imsg->hdr, ibuf->r.buf, sizeof(imsg->hdr));
	if (imsg->hdr.len < IMSG_HEADER_SIZE ||
	    imsg->hdr.len > MAX_IMSGSIZE) {
		errno = ERANGE;
		return (-1);
	}
	if (imsg->hdr.len > av)
		return (0);
	datalen = imsg->hdr.len - IMSG_HEADER_SIZE;
	ibuf->r.rptr = ibuf->r.buf + IMSG_HEADER_SIZE;
	if (datalen == 0)
		imsg->data = NULL;
	else if ((imsg->data = malloc(datalen)) == NULL)
		return (-1);

	if (imsg->hdr.flags & IMSGF_HASFD)
		imsg->fd = imsg_get_fd(ibuf);
	else
		imsg->fd = -1;

	memcpy(imsg->data, ibuf->r.rptr, datalen);

	if (imsg->hdr.len < av) {
		left = av - imsg->hdr.len;
		memmove(&ibuf->r.buf, ibuf->r.buf + imsg->hdr.len, left);
		ibuf->r.wpos = left;
	} else
		ibuf->r.wpos = 0;

	return (datalen + IMSG_HEADER_SIZE);
}

int
imsg_compose(struct imsgbuf *ibuf, uint32_t type, uint32_t peerid, pid_t pid,
    int fd, const void *data, uint16_t datalen)
{
	struct ibuf	*wbuf;

	if ((wbuf = imsg_create(ibuf, type, peerid, pid, datalen)) == NULL)
		return (-1);

	if (imsg_add(wbuf, data, datalen) == -1)
		return (-1);

	wbuf->fd = fd;

	imsg_close(ibuf, wbuf);

	return (1);
}

int
imsg_composev(struct imsgbuf *ibuf, uint32_t type, uint32_t peerid, pid_t pid,
    int fd, const struct iovec *iov, int iovcnt)
{
	struct ibuf	*wbuf;
	int		 i, datalen = 0;

	for (i = 0; i < iovcnt; i++)
		datalen += iov[i].iov_len;

	if ((wbuf = imsg_create(ibuf, type, peerid, pid, datalen)) == NULL)
		return (-1);

	for (i = 0; i < iovcnt; i++)
		if (imsg_add(wbuf, iov[i].iov_base, iov[i].iov_len) == -1)
			return (-1);

	wbuf->fd = fd;

	imsg_close(ibuf, wbuf);

	return (1);
}

/* ARGSUSED */
struct ibuf *
imsg_create(struct imsgbuf *ibuf, uint32_t type, uint32_t peerid, pid_t pid,
    uint16_t datalen)
{
	struct ibuf	*wbuf;
	struct imsg_hdr	 hdr;

	datalen += IMSG_HEADER_SIZE;
	if (datalen > MAX_IMSGSIZE) {
		errno = ERANGE;
		return (NULL);
	}

	hdr.type = type;
	hdr.flags = 0;
	hdr.peerid = peerid;
	if ((hdr.pid = pid) == 0)
		hdr.pid = ibuf->pid;
	if ((wbuf = ibuf_dynamic(datalen, MAX_IMSGSIZE)) == NULL) {
		return (NULL);
	}
	if (imsg_add(wbuf, &hdr, sizeof(hdr)) == -1)
		return (NULL);

	return (wbuf);
}

int
imsg_add(struct ibuf *msg, const void *data, uint16_t datalen)
{
	if (datalen)
		if (ibuf_add(msg, data, datalen) == -1) {
			ibuf_free(msg);
			return (-1);
		}
	return (datalen);
}

void
imsg_close(struct imsgbuf *ibuf, struct ibuf *msg)
{
	struct imsg_hdr	*hdr;

	hdr = (struct imsg_hdr *)msg->buf;

	hdr->flags &= ~IMSGF_HASFD;
	if (msg->fd != -1)
		hdr->flags |= IMSGF_HASFD;

	hdr->len = (uint16_t)msg->wpos;

	ibuf_close(&ibuf->w, msg);
}

void
imsg_free(struct imsg *imsg)
{
	freezero(imsg->data, imsg->hdr.len - IMSG_HEADER_SIZE);
}

int
imsg_get_fd(struct imsgbuf *ibuf)
{
	int		 fd;
	struct imsg_fd	*ifd;

	if ((ifd = TAILQ_FIRST(&ibuf->fds)) == NULL)
		return (-1);

	fd = ifd->fd;
	TAILQ_REMOVE(&ibuf->fds, ifd, entry);
	free(ifd);

	return (fd);
}

int
imsg_flush(struct imsgbuf *ibuf)
{
	while (ibuf->w.queued)
		if (msgbuf_write(&ibuf->w) <= 0)
			return (-1);
	return (0);
}

void
imsg_clear(struct imsgbuf *ibuf)
{
	int	fd;

	msgbuf_clear(&ibuf->w);
	while ((fd = imsg_get_fd(ibuf)) != -1)
		close(fd);
}
@


1.14
log
@Use C99 types (uint32_t) instead of BSD (u_int32_t) - the former are
more portable. Add stdint.h to the headers in imsg_init(3).

No objections from millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.13 2015/12/09 11:54:12 tb Exp $	*/
d266 1
a266 1
	free(imsg->data);
@


1.13
log
@Add a cast to silence a compiler warning by clang on FreeBSD.
From Craig Rodrigues.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.12 2015/12/05 13:06:52 claudio Exp $	*/
d166 2
a167 2
imsg_compose(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,
    pid_t pid, int fd, const void *data, u_int16_t datalen)
d185 2
a186 2
imsg_composev(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,
    pid_t pid, int fd, const struct iovec *iov, int iovcnt)
d210 2
a211 2
imsg_create(struct imsgbuf *ibuf, u_int32_t type, u_int32_t peerid,
    pid_t pid, u_int16_t datalen)
d237 1
a237 1
imsg_add(struct ibuf *msg, const void *data, u_int16_t datalen)
d258 1
a258 1
	hdr->len = (u_int16_t)msg->wpos;
@


1.12
log
@Do not loop on EAGAIN in imsg_read(). Better to return the error to the
caller and let him do another poll loop. This fixes spinning relayd
processes seen on busy TLS relays. OK benno@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.11 2015/11/27 01:57:59 mmcc Exp $	*/
d75 1
a75 1
	    (CMSG_SPACE(sizeof(int))-CMSG_SPACE(0))/sizeof(int)
@


1.11
log
@Remove three NULL-checks before free().   ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.10 2015/07/19 07:18:59 nicm Exp $	*/
d83 3
a85 5
		if (errno == EMSGSIZE)
			goto fail;
		if (errno != EINTR && errno != EAGAIN)
			goto fail;
		goto again;
@


1.10
log
@Handle malloc(0) returning NULL (which can happen on some other
platforms) by explicitly making imsg->data = NULL when there is no
data. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.9 2015/07/12 18:40:49 nicm Exp $	*/
d121 1
a121 2
	if (ifd)
		free(ifd);
@


1.9
log
@Use memset instead of bzero for better portability.

ok gilles claudio doug
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.8 2015/07/03 14:50:14 brynet Exp $	*/
d146 3
a148 1
	if ((imsg->data = malloc(datalen)) == NULL)
@


1.8
log
@bzero cmsgbuf before using it, silences valgrind warnings.

henning@@ "sure"
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.7 2015/06/11 19:25:53 reyk Exp $	*/
d39 1
a39 1
	bzero(&ibuf->r, sizeof(ibuf->r));
d60 2
a61 2
	bzero(&msg, sizeof(msg));
	bzero(&cmsgbuf, sizeof(cmsgbuf));
d81 1
a81 1
	
@


1.7
log
@The correct semantic is to check msgbuf_write() for <= 0, not just < 0.
Fix one occurence in imsg_flush() and clarify it the man page.

Discussed with at least blambert@@ jsg@@ yasuoka@@.

OK gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.6 2014/06/30 00:26:22 deraadt Exp $	*/
d61 1
@


1.6
log
@sys/types.h rather than sys/param.h, where applicable.  avoid overreach.
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.5 2013/12/26 17:32:33 eric Exp $	*/
d289 1
a289 1
		if (msgbuf_write(&ibuf->w) < 0)
@


1.5
log
@constify data parameter in imsg_add() and imsg_compose()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.4 2013/02/01 15:22:18 gilles Exp $	*/
d19 1
a19 1
#include <sys/param.h>
@


1.4
log
@fix memleak in imsg_read() when hitting the fd reserve check

ok millert@@, mikeb@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.3 2012/12/19 13:37:12 reyk Exp $	*/
d167 1
a167 1
    pid_t pid, int fd, void *data, u_int16_t datalen)
d237 1
a237 1
imsg_add(struct ibuf *msg, void *data, u_int16_t datalen)
@


1.3
log
@Fix a purely theoretical NULL-pointer dereference in the case that we
would be able to receive multiple SCM_RIGHTS messages.

ok claudio@@ gilles@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.2 2012/06/02 21:46:53 gilles Exp $	*/
d77 1
@


1.2
log
@in imsg_read() avoid calling recvmsg() if we detect that we will be short
on descriptors, this can be achieved thanks to the new getdtablecount()
system call. application may provide a reserve count to ensure that the
recvmsg() call is not called when they don't have enough descriptors to
work properly.

change the API so that transient errors that can be retried immediately
are retried within the function right away, whereas transient errors for
which the application may want to take action will set errno to EAGAIN.

ok deraadt@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.1 2010/05/26 16:44:32 nicm Exp $	*/
d106 1
a106 1
				if (i == 0) {
@


1.1
log
@Move imsg into libutil and add a man page.

Minor bump for libutil.

Previous versions of this diff and man page looked at by various people.

"you should just commit" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: imsg.c,v 1.3 2010/05/26 13:56:07 nicm Exp $	*/
d31 2
d53 1
a53 1
		char	buf[CMSG_SPACE(sizeof(int) * 16)];
d56 1
a56 1
	ssize_t			 n;
d69 11
d81 5
a85 4
		if (errno != EINTR && errno != EAGAIN) {
			return (-1);
		}
		return (-2);
d94 19
a112 4
			fd = (*(int *)CMSG_DATA(cmsg));
			if ((ifd = calloc(1, sizeof(struct imsg_fd))) == NULL) {
				close(fd);
				return (-1);
a113 2
			ifd->fd = fd;
			TAILQ_INSERT_TAIL(&ibuf->fds, ifd, entry);
d118 3
@

