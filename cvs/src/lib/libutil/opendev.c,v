head	1.15;
access;
symbols
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.22
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.18
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.20
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.12
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.16
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.14
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.10
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.8.0.22
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.24
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.20
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.18
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.16
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.10
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.8
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.14
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.15
date	2011.06.30.15.04.58;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.22.17.24.32;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2010.12.21.15.47.52;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.17.19.35.34;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2010.11.15.15.07.40;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.28.19.12.29;	author chl;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.18.17.03.06;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.28.07.03.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.09.22.18.43;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.30.17.37.46;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.16.02.40.51;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.07.02.07.57.54;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.20.10.46.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.17.07.46.03;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.06.17.06.35.34;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Do not mask errno if we fail to open /dev/diskmap. Also, fall through
rather than returning so that realname still gets assigned.

ok millert@@ deraadt@@ thib@@
@
text
@/*	$OpenBSD: opendev.c,v 1.13 2010/12/21 15:47:52 millert Exp $	*/

/*
 * Copyright (c) 2000, Todd C. Miller.  All rights reserved.
 * Copyright (c) 1996, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <paths.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <sys/ioctl.h>
#include <sys/limits.h>
#include <sys/disk.h>
#include <sys/dkio.h>

#include "util.h"

/*
 * This routine is a generic rewrite of the original code found in
 * disklabel(8).
 */
int
opendev(const char *path, int oflags, int dflags, char **realpath)
{
	static char namebuf[PATH_MAX];
	struct dk_diskmap dm;
	char *slash, *prefix;
	int fd;

	/* Initial state */
	fd = -1;
	errno = ENOENT;

	if (dflags & OPENDEV_BLCK)
		prefix = "";			/* block device */
	else
		prefix = "r";			/* character device */

	if ((slash = strchr(path, '/'))) {
		strlcpy(namebuf, path, sizeof(namebuf));
		fd = open(namebuf, oflags);
	} else if (isduid(path, dflags)) {
		strlcpy(namebuf, path, sizeof(namebuf));
		if ((fd = open("/dev/diskmap", oflags)) != -1) {
			bzero(&dm, sizeof(struct dk_diskmap));
			dm.device = namebuf;
			dm.fd = fd;
			if (dflags & OPENDEV_PART)
				dm.flags |= DM_OPENPART;
			if (dflags & OPENDEV_BLCK)
				dm.flags |= DM_OPENBLCK;

			if (ioctl(fd, DIOCMAP, &dm) == -1) {
				close(fd);
				fd = -1;
				errno = ENOENT;
			}
		}
	}
	if (!slash && fd == -1 && errno == ENOENT) {
		if (dflags & OPENDEV_PART) {
			/*
			 * First try raw partition (for removable drives)
			 */
			if (snprintf(namebuf, sizeof(namebuf), "%s%s%s%c",
			    _PATH_DEV, prefix, path, 'a' + getrawpartition())
			    < sizeof(namebuf)) {
				fd = open(namebuf, oflags);
			} else
				errno = ENAMETOOLONG;
		}
		if (fd == -1 && errno == ENOENT) {
			if (snprintf(namebuf, sizeof(namebuf), "%s%s%s",
			    _PATH_DEV, prefix, path) < sizeof(namebuf)) {
				fd = open(namebuf, oflags);
			} else
				errno = ENAMETOOLONG;
		}
	}
	if (realpath)
		*realpath = namebuf;

	return (fd);
}
@


1.14
log
@Do not attempt to prepend /dev/ to path if it already contains a slash.
OK jsing@@
@
text
@a83 3
		} else if (errno != ENOENT) {
			errno = ENXIO;
			return -1;
@


1.13
log
@Always return a pointer to the static buffer in realpath, even if
path and realpath are the same.  This matches the manual and avoids
a bogus cast to non-const.  OK jsing@@, previous version OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.12 2010/12/17 19:35:34 millert Exp $	*/
a88 11
	if (fd == -1 && errno == ENOENT && (dflags & OPENDEV_PART)) {
		/*
		 * First try raw partition (for removable drives)
		 */
		if (snprintf(namebuf, sizeof(namebuf), "%s%s%s%c",
		    _PATH_DEV, prefix, path, 'a' + getrawpartition())
		    < sizeof(namebuf)) {
			fd = open(namebuf, oflags);
		} else
			errno = ENAMETOOLONG;
	}
d90 18
a107 5
		if (snprintf(namebuf, sizeof(namebuf), "%s%s%s",
		    _PATH_DEV, prefix, path) < sizeof(namebuf)) {
			fd = open(namebuf, oflags);
		} else
			errno = ENAMETOOLONG;
@


1.12
log
@opendev() path argument should be const.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.11 2010/11/15 15:07:40 jsing Exp $	*/
a56 2
	if (realpath)
		*realpath = (char *)path;
d65 5
a69 3
	if ((slash = strchr(path, '/')))
		fd = open(path, oflags);
	else if (isduid(path, dflags)) {
a71 1
			strlcpy(namebuf, path, sizeof(namebuf));
d83 1
a83 2
			} else if (realpath)
				*realpath = namebuf;
a96 2
			if (realpath)
				*realpath = namebuf;
a103 2
			if (realpath)
				*realpath = namebuf;
d107 3
@


1.11
log
@Factor out DUID identification code so that it can easily be reused.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.10 2010/06/28 19:12:29 chl Exp $	*/
d49 1
a49 1
opendev(char *path, int oflags, int dflags, char **realpath)
d58 1
a58 1
		*realpath = path;
@


1.10
log
@add missing headers needed for close() and ioctl().

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.9 2010/06/18 17:03:06 jsing Exp $	*/
a43 22
/* Returns 1 if a valid disklabel UID.  */
static int
valid_diskuid(const char *duid, int dflags)
{
	char c;
	int i;

	/* Basic format check. */
	if (!((strlen(duid) == 16 && (dflags & OPENDEV_PART)) ||
	    (strlen(duid) == 18 && duid[16] == '.')))
		return 0;

	/* Check UID. */
	for (i = 0; i < 16; i++) {
		c = duid[i];
		if ((c < '0' || c > '9') && (c < 'a' || c > 'f'))
			return 0;
	}

	return 1;
}

d69 1
a69 1
	else if (valid_diskuid(path, dflags)) {
@


1.9
log
@If a request to opendev(3) is given in the form of a disklabel UID,
open /dev/diskmap and perform a DIOCMAP ioctl in order to open the actual
device. As a result, all programs which make use of opendev(3) can now
operate with disklabel UIDs.

Feedback from millert@@

ok millert@@ krw@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.7 2002/06/09 22:18:43 fgsch Exp $	*/
d35 1
d37 1
@


1.8
log
@knf; otto ok
@
text
@d36 4
d42 22
a67 1

d72 1
d89 23
a111 1
	else if (dflags & OPENDEV_PART) {
@


1.7
log
@some -Wall and spaces cleanup, scsi.c left.
some brave soul should look at it.
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.6 2000/04/30 17:37:46 millert Exp $	*/
d44 1
a44 5
opendev(path, oflags, dflags, realpath)
	char *path;
	int oflags;
	int dflags;
	char **realpath;
d46 2
a48 2
	char *slash, *prefix;
	static char namebuf[PATH_MAX];
@


1.6
log
@Add OPENDEV_BLCK flag for opening the block devices (the character
device is opened by default).

Don't open the file w/o adding a /dev/ prefix unless the file has
a '/' in it.  This prevents problems where someone says "disklabel
sd0" with a file called "sd0" in the cwd.

The OPENDEV_DRCT flag has been deprecated as it is the the default
behavior and always has been.

Add checks for >= MAXPATHLEN and return ENAMETOOLONG in that case.
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.5 1996/09/16 02:40:51 tholo Exp $ */
@


1.5
log
@Bring prototypes into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.4 1996/07/02 07:57:54 downsj Exp $ */
d4 1
a28 2
#include <stdio.h>
#include <string.h>
d31 1
d33 2
d51 2
a52 1
	static char namebuf[256];
d54 1
d57 2
d60 15
a74 21
	fd = open(path, oflags);
	if ((fd < 0) && (errno == ENOENT)) {
		if (path[0] != '/') {
			if (dflags & OPENDEV_PART) {
				/*
				 * First try raw partition (for removable
				 * drives)
				 */
				(void)snprintf(namebuf, sizeof(namebuf),
				    "%sr%s%c", _PATH_DEV, path,
				    'a' + getrawpartition());
				fd = open(namebuf, oflags);
			}

			if ((dflags & OPENDEV_DRCT) && (fd < 0) &&
			    (errno == ENOENT)) {
				/* ..and now no partition (for tapes) */
				namebuf[strlen(namebuf) - 1] = '\0';
				fd = open(namebuf, oflags);
			}

d77 2
a78 1
		}
d80 8
a87 7
	if ((fd < 0) && (errno == ENOENT) && (path[0] != '/')) {
		(void)snprintf(namebuf, sizeof(namebuf), "%sr%s",
		    _PATH_DEV, path);
		fd = open(namebuf, oflags);

		if (realpath)
			*realpath = namebuf;
a88 1

@


1.4
log
@Use getrawpartition().
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.3 1996/06/20 10:46:02 deraadt Exp $ */
d29 1
@


1.3
log
@only write to realpath if non-NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.2 1996/06/17 07:46:03 downsj Exp $ */
a30 1
#include <sys/disklabel.h>
d62 2
a63 1
				    "%sr%s%c", _PATH_DEV, path, 'a' + RAW_PART);
@


1.2
log
@util.h: new resting place
opendev.h: ok, so I merged it with util.h
opendev.h: use util.h
everything else: use "util.h"
@
text
@d1 1
a1 1
/*	$OpenBSD: opendev.c,v 1.1 1996/06/17 06:35:34 downsj Exp $ */
d51 2
a52 1
	*realpath = path;
d74 2
a75 1
			*realpath = namebuf;
d83 2
a84 1
		*realpath = namebuf;
@


1.1
log
@Add opendev(3) to libutil.  Used by mt(1), soon by disklabel(8), maybe
others.  This is a generic version of the code used by mt(1).
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d34 1
a34 1
#include "opendev.h"
d42 1
a42 1
opendev(path, oflags, dflags, mode, realpath)
a45 1
	mode_t mode;
d53 1
a53 1
	fd = open(path, oflags, mode);
d63 1
a63 1
				fd = open(namebuf, oflags, mode);
d70 1
a70 1
				fd = open(namebuf, oflags, mode);
d79 1
a79 1
		fd = open(namebuf, oflags, mode);
@
