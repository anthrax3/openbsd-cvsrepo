head	1.46;
access;
symbols
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.33.0.4
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18;
locks; strict;
comment	@.\" @;


1.46
date	2017.01.03.20.29.28;	author natano;	state Exp;
branches;
next	1.45;
commitid	rbiqQPblNsLO0niw;

1.45
date	2016.02.11.16.30.35;	author tim;	state Exp;
branches;
next	1.44;
commitid	yaDwNazrscz5Ut6k;

1.44
date	2016.01.07.07.41.01;	author ratchov;	state Exp;
branches;
next	1.43;
commitid	pYtvupOMgjtQxXte;

1.43
date	2015.09.14.15.14.55;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	TPchOLbdlEugnrt2;

1.42
date	2014.12.02.11.09.28;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	dVXZcWYgeWuAMmLB;

1.41
date	2014.03.05.20.01.59;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2014.01.22.10.13.20;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2013.12.23.14.14.31;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2013.12.22.01.13.31;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2013.07.04.21.49.10;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2013.07.04.21.43.25;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.05.03.44.50;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2013.04.06.11.38.41;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2012.05.23.19.25.11;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2011.12.24.08.46.48;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.09.14.38.09;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2011.10.17.21.09.11;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2011.10.04.20.58.27;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.16.10.52.22;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2010.11.06.22.17.26;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2010.11.06.20.25.42;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.26.07.11.10;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.30.08.27.12;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.25.11.15.56;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.15.11.07.41;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.04.21.39.09;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.04.18.47.42;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.21.22.36.50;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.21.22.18.31;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.12.20.47.34;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.08.18.55.40;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.08.14.01.03;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.17.10.00.50;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.17.09.04.06;	author jmc;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.17.07.19.27;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.17.07.49.48;	author jmc;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.16.21.52.58;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.11.21.45.03;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.11.19.39.35;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.09.19.49.10;	author naddy;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.07.21.01.15;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.10.29.02.47.47;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.27.00.26.33;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Tweak RETURN VALUES section. Move description of sio_pollfd() and
sio_nfds() return values there and add a paragraph about sio_eof().

ok jmc ratchov
@
text
@.\" $OpenBSD: sio_open.3,v 1.45 2016/02/11 16:30:35 tim Exp $
.\"
.\" Copyright (c) 2007 Alexandre Ratchov <alex@@caoua.org>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd $Mdocdate: February 11 2016 $
.Dt SIO_OPEN 3
.Os
.Sh NAME
.Nm sio_open ,
.Nm sio_close ,
.Nm sio_setpar ,
.Nm sio_getpar ,
.Nm sio_getcap ,
.Nm sio_start ,
.Nm sio_stop ,
.Nm sio_read ,
.Nm sio_write ,
.Nm sio_onmove ,
.Nm sio_nfds ,
.Nm sio_pollfd ,
.Nm sio_revents ,
.Nm sio_eof ,
.Nm sio_setvol ,
.Nm sio_onvol ,
.Nm sio_initpar
.Nd sndio interface to audio devices
.Sh SYNOPSIS
.In sndio.h
.Ft "struct sio_hdl *"
.Fn sio_open "const char *name" "unsigned int mode" "int nbio_flag"
.Ft "void"
.Fn sio_close "struct sio_hdl *hdl"
.Ft "int"
.Fn sio_setpar "struct sio_hdl *hdl" "struct sio_par *par"
.Ft "int"
.Fn sio_getpar "struct sio_hdl *hdl" "struct sio_par *par"
.Ft "int"
.Fn sio_getcap "struct sio_hdl *hdl" "struct sio_cap *cap"
.Ft "int"
.Fn sio_start "struct sio_hdl *hdl"
.Ft "int"
.Fn sio_stop "struct sio_hdl *hdl"
.Ft "size_t"
.Fn sio_read "struct sio_hdl *hdl" "void *addr" "size_t nbytes"
.Ft "size_t"
.Fn sio_write "struct sio_hdl *hdl" "const void *addr" "size_t nbytes"
.Ft "void"
.Fn sio_onmove "struct sio_hdl *hdl" "void (*cb)(void *arg, int delta)" "void *arg"
.Ft "int"
.Fn sio_nfds "struct sio_hdl *hdl"
.Ft "int"
.Fn sio_pollfd "struct sio_hdl *hdl" "struct pollfd *pfd" "int events"
.Ft "int"
.Fn sio_revents "struct sio_hdl *hdl" "struct pollfd *pfd"
.Ft "int"
.Fn sio_eof "struct sio_hdl *hdl"
.Ft "int"
.Fn sio_setvol "struct sio_hdl *hdl" "unsigned int vol"
.Ft "int"
.Fn sio_onvol "struct sio_hdl *hdl" "void (*cb)(void *arg, unsigned int vol)" "void *arg"
.Ft "void"
.Fn sio_initpar "struct sio_par *par"
.\"Fd #define SIO_BPS(bits)
.\"Fd #define SIO_LE_NATIVE
.Sh DESCRIPTION
The
.Nm sndio
library allows user processes to access
.Xr audio 4
hardware and the
.Xr sndiod 8
audio server in a uniform way.
.Ss Opening and closing an audio device
First the application must call the
.Fn sio_open
function to obtain a handle to the device;
later it will be passed as the
.Fa hdl
argument of most other functions.
The
.Fa name
parameter gives the device string discussed in
.Xr sndio 7 .
In most cases it should be set to
.Dv SIO_DEVANY
to allow the user to select it using the
.Ev AUDIODEVICE
environment variable.
.Pp
The following values of the
.Fa mode
parameter are supported:
.Bl -tag -width "SIO_PLAY | SIO_REC"
.It Dv SIO_PLAY
Play-only mode: data written will be played by the device.
.It Dv SIO_REC
Record-only mode: samples are recorded by the device and must be read.
.It Dv SIO_PLAY | SIO_REC
The device plays and records synchronously; this means that
the n-th recorded sample was physically sampled exactly when
the n-th played sample was actually played.
.El
.Pp
If the
.Fa nbio_flag
argument is true (i.e. non-zero), then the
.Fn sio_read
and
.Fn sio_write
functions (see below) will be non-blocking.
.Pp
The
.Fn sio_close
function stops the device as if
.Fn sio_stop
is called and frees the handle.
Thus, no samples submitted with
.Fn sio_write
are discarded.
.Ss Negotiating audio parameters
Audio samples are interleaved.
A frame consists of one sample for each channel.
For example, a 16-bit stereo encoding has two samples per frame
and, two bytes per sample (thus 4 bytes per frame).
.Pp
The set of parameters of the device that can be controlled
is given by the following structure:
.Bd -literal
struct sio_par {
	unsigned int bits;	/* bits per sample */
	unsigned int bps;	/* bytes per sample */
	unsigned int sig;	/* 1 = signed, 0 = unsigned int */
	unsigned int le;	/* 1 = LE, 0 = BE byte order */
	unsigned int msb;	/* 1 = MSB, 0 = LSB aligned */
	unsigned int rchan;	/* number channels for recording */
	unsigned int pchan;	/* number channels for playback */
	unsigned int rate;	/* frames per second */
	unsigned int appbufsz;	/* minimum buffer size without xruns */
	unsigned int bufsz;	/* end-to-end buffer size (read-only) */
	unsigned int round;	/* optimal buffer size divisor */
#define SIO_IGNORE	0	/* pause during xrun */
#define SIO_SYNC	1	/* resync after xrun */
#define SIO_ERROR	2	/* terminate on xrun */
	unsigned int xrun;	/* what to do on overrun/underrun */
};
.Ed
.Pp
The parameters are as follows:
.Bl -tag -width "appbufsz"
.It Va bits
Number of bits per sample: must be between 1 and 32.
.It Va bps
Bytes per samples; if specified, it must be large enough to hold all bits.
By default it's set to the smallest power of two large enough to hold
.Va bits .
.It Va sig
If set (i.e. non-zero) then the samples are signed, else unsigned.
.It Va le
If set, then the byte order is little endian, else big endian;
it's meaningful only if
.Va bps
\*(Gt 1.
.It Va msb
If set, then the
.Va bits
are aligned in the packet to the most significant bit
(i.e. lower bits are padded),
else to the least significant bit
(i.e. higher bits are padded);
it's meaningful only if
.Va bits
\*(Lt
.Va bps
* 8.
.It Va rchan
The number of recorded channels; meaningful only if
.Dv SIO_REC
mode was selected.
.It Va pchan
The number of played channels; meaningful only if
.Dv SIO_PLAY
mode was selected.
.It Va rate
The sampling frequency in Hz.
.It Va bufsz
The maximum number of frames that may be buffered.
This parameter takes into account any buffers, and
can be used for latency calculations.
It is read-only.
.It Va appbufsz
Size of the buffer in frames the application must maintain non-empty
(on the play end) or non-full (on the record end) by calling
.Fn sio_write
or
.Fn sio_read
fast enough to avoid overrun or underrun conditions.
The audio subsystem may use additional buffering, thus this
parameter cannot be used for latency calculations.
.It Va round
Optimal number of frames that the application buffers
should be a multiple of, to get best performance.
Applications can use this parameter to round their block size.
.It Va xrun
The action when the client doesn't accept
recorded data or doesn't provide data to play fast enough;
it can be set to one of the
.Dv SIO_IGNORE ,
.Dv SIO_SYNC ,
or
.Dv SIO_ERROR
constants.
.El
.Pp
The following approach is recommended to negotiate device parameters:
.Bl -bullet
.It
Initialize a
.Vt sio_par
structure using
.Fn sio_initpar
and fill it with
the desired parameters.
Then call
.Fn sio_setpar
to request the device to use them.
Parameters left unset in the
.Vt sio_par
structure will be set to device-specific defaults.
.It
Call
.Fn sio_getpar
to retrieve the actual parameters of the device
and check that they are usable.
If they are not, then fail or set up a conversion layer.
Sometimes the rate set can be slightly different to what was requested.
A difference of about 0.5% is not audible and should be ignored.
.El
.Pp
Parameters cannot be changed after
.Fn sio_start
has been called,
.Fn sio_stop
must be called before parameters can be changed.
.Pp
If the device is exposed by the
.Xr sndiod 8
server, which is the default configuration,
a transparent emulation layer will
automatically be set up, and in this case any combination of
rate, encoding and numbers of channels is supported.
.Pp
To ease filling the
.Vt sio_par
structure, the
following macros can be used:
.Bl -tag -width "SIO_BPS(bits)"
.It Dv SIO_BPS Ns Pq Fa bits
Return the smallest value for
.Va bps
that is a power of two and that is large enough to
hold
.Fa bits .
.It Dv SIO_LE_NATIVE
Can be used to set the
.Va le
parameter when native byte order is required.
.El
.Ss Getting device capabilities
There's no way to get an exhaustive list of all parameter
combinations the device supports.
Applications that need to have a set of working
parameter combinations in advance can use the
.Fn sio_getcap
function.
.Pp
The
.Vt sio_cap
structure contains the list of parameter configurations.
Each configuration contains multiple parameter sets.
The application must examine all configurations, and
choose its parameter set from
.Em one
of the configurations.
Parameters of different configurations
.Em are not
usable together.
.Bd -literal
struct sio_cap {
	struct sio_enc {		/* allowed encodings */
		unsigned int bits;
		unsigned int bps;
		unsigned int sig;
		unsigned int le;
		unsigned int msb;
	} enc[SIO_NENC];
	unsigned int rchan[SIO_NCHAN];	/* allowed rchans */
	unsigned int pchan[SIO_NCHAN];	/* allowed pchans */
	unsigned int rate[SIO_NRATE];	/* allowed rates */
	unsigned int nconf;		/* num. of confs[] */
	struct sio_conf {
		unsigned int enc;	/* bitmask of enc[] indexes */
		unsigned int rchan;	/* bitmask of rchan[] indexes */
		unsigned int pchan;	/* bitmask of pchan[] indexes */
		unsigned int rate;	/* bitmask of rate[] indexes */
	} confs[SIO_NCONF];
};
.Ed
.Pp
The parameters are as follows:
.Bl -tag -width "rchan[SIO_NCHAN]"
.It Va enc Ns Bq Dv SIO_NENC
Array of supported encodings.
The tuple of
.Va bits ,
.Va bps ,
.Va sig ,
.Va le ,
and
.Va msb
parameters are usable in the corresponding parameters
of the
.Vt sio_par
structure.
.It Va rchan Ns Bq Dv SIO_NCHAN
Array of supported channel numbers for recording usable
in the
.Vt sio_par
structure.
.It Va pchan Ns Bq Dv SIO_NCHAN
Array of supported channel numbers for playback usable
in the
.Vt sio_par
structure.
.It Va rate Ns Bq Dv SIO_NRATE
Array of supported sample rates usable
in the
.Vt sio_par
structure.
.It Va nconf
Number of different configurations available, i.e. number
of filled elements of the
.Va confs[]
array.
.It Va confs Ns Bq Dv SIO_NCONF
Array of available configurations.
Each configuration contains bitmasks indicating which
elements of the above parameter arrays are valid for the
given configuration.
For instance, if the second bit of
.Va rate
is set, in the
.Vt sio_conf
structure, then the second element of the
.Va rate Ns Bq Dv SIO_NRATE
array of the
.Vt sio_cap
structure is valid for this configuration.
.El
.Ss Starting and stopping the device
The
.Fn sio_start
function puts the device in a waiting state:
the device will wait for playback data to be provided
(using the
.Fn sio_write
function).
Once enough data is queued to ensure that play buffers
will not underrun, actual playback is started automatically.
If record mode only is selected, then recording starts
immediately.
In full-duplex mode, playback and recording will start
synchronously as soon as enough data to play is available.
.Pp
The
.Fn sio_stop
function puts the audio subsystem
in the same state as before
.Fn sio_start
is called.
It stops recording, drains the play buffer and then stops playback.
If samples to play are queued but playback hasn't started yet
then playback is forced immediately; playback will actually stop
once the buffer is drained.
In no case are samples in the play buffer discarded.
.Ss Playing and recording
When record mode is selected, the
.Fn sio_read
function must be called to retrieve recorded data; it must be called
often enough to ensure that internal buffers will not overrun.
It will store at most
.Fa nbytes
bytes at the
.Fa addr
location and return the number of bytes stored.
Unless the
.Fa nbio_flag
flag is set, it will block until data becomes available and
will return zero only on error.
.Pp
Similarly, when play mode is selected, the
.Fn sio_write
function must be called to provide data to play.
Unless the
.Fa nbio_flag
is set,
.Fn sio_write
will block until the requested amount of data is written.
.Ss Non-blocking mode operation
If the
.Fa nbio_flag
is set on
.Fn sio_open ,
then the
.Fn sio_read
and
.Fn sio_write
functions will never block; if no data is available, they will
return zero immediately.
.Pp
The
.Xr poll 2
system call can be used to check if data can be
read from or written to the device.
The
.Fn sio_pollfd
function fills the array
.Fa pfd
of
.Vt pollfd
structures, used by
.Xr poll 2 ,
with
.Fa events ;
the latter is a bit-mask of
.Dv POLLIN
and
.Dv POLLOUT
constants; refer to
.Xr poll 2
for more details.
The
.Fn sio_revents
function returns the bit-mask set by
.Xr poll 2
in the
.Fa pfd
array of
.Vt pollfd
structures.
If
.Dv POLLIN
is set, recorded samples are available in the device buffer
and can be read with
.Fn sio_read .
If
.Dv POLLOUT
is set, space is available in the device buffer and new samples
to play can be submitted with
.Fn sio_write .
.Dv POLLHUP
may be set if an error occurs, even if
it is not selected with
.Fn sio_pollfd .
.Pp
The size of the
.Ar pfd
array, which the caller must pre-allocate, is provided by the
.Fn sio_nfds
function.
.Ss Synchronizing non-audio events to the audio stream in real-time
In order to perform actions at precise positions of the audio stream,
such as displaying video in sync with the audio stream,
the application must be notified in real-time of the exact
position in the stream the hardware is processing.
.Pp
The
.Fn sio_onmove
function can be used to register the
.Fn cb
callback function called at regular time intervals.
The
.Fa delta
argument contains the number of frames the hardware played and/or recorded
since the last call of
.Fn cb .
It is called by
.Fn sio_read ,
.Fn sio_write ,
and
.Fn sio_revents .
When the first sample is played and/or recorded, right after the device starts,
the callback is invoked with a zero
.Fa delta
argument.
The value of the
.Fa arg
pointer is passed to the callback and can contain anything.
.Pp
If desired, the application can maintain the current position by
starting from zero (when
.Fn sio_start
is called) and adding to the current position
.Fa delta
every time
.Fn cb
is called.
.Ss Measuring the latency and buffers usage
The playback latency is the delay it will take for the
frame just written to become audible, expressed in number of frames.
The exact playback
latency can be obtained by subtracting the current position
from the number of frames written.
Once playback is actually started (first sample audible)
the latency will never exceed the
.Va bufsz
parameter (see the sections above).
There's a phase during which
.Fn sio_write
only queues data;
once there's enough data, actual playback starts.
During this phase talking about latency is meaningless.
.Pp
In any cases, at most
.Va bufsz
frames are buffered.
This value takes into account all buffers.
The number of frames stored is equal to the number of frames
written minus the current position.
.Pp
The recording latency is obtained similarly, by subtracting
the number of frames read from the current position.
.Pp
Note that
.Fn sio_write
might block even if there is buffer space left;
using the buffer usage to guess if
.Fn sio_write
would block is false and leads to unreliable programs \(en consider using
.Xr poll 2
for this.
.Ss Handling buffer overruns and underruns
When the application cannot accept recorded data fast enough,
the record buffer (of size
.Va appbufsz )
might overrun; in this case recorded data is lost.
Similarly if the application cannot provide data to play
fast enough, the play buffer underruns and silence is played
instead.
Depending on the
.Va xrun
parameter of the
.Vt sio_par
structure, the audio subsystem will behave as follows:
.Bl -tag -width "SIO_IGNORE"
.It Dv SIO_IGNORE
The devices pauses during overruns and underruns,
thus the current position (obtained through
.Fn sio_onmove )
stops being incremented.
Once the overrun and/or underrun condition is gone, the device resumes;
play and record are always kept in sync.
With this mode, the application cannot notice
underruns and/or overruns and shouldn't care about them.
.Pp
This mode is the default.
It's suitable for applications,
like audio players and telephony, where time
is not important and overruns or underruns are not short.
.It Dv SIO_SYNC
If the play buffer underruns, then silence is played,
but in order to reach the right position in time,
the same amount of written samples will be
discarded once the application is unblocked.
Similarly, if the record buffer overruns, then
samples are discarded, but the same amount of silence will be
returned later.
The current position (obtained through
.Fn sio_onmove )
is still incremented.
When the play buffer underruns the play latency might become negative;
when the record buffer overruns, the record latency might become
larger than
.Va bufsz .
.Pp
This mode is suitable for applications, like music production,
where time is important and where underruns or overruns are
short and rare.
.It Dv SIO_ERROR
With this mode, on the first play buffer underrun or
record buffer overrun, playback and/or recording is terminated and
no other function than
.Fn sio_close
will succeed.
.Pp
This mode is mostly useful for testing.
.El
.Ss Controlling the volume
The
.Fn sio_setvol
function can be used to set playback attenuation.
The
.Fa vol
parameter takes a value between 0 (maximum attenuation)
and
.Dv SIO_MAXVOL
(no attenuation).
It specifies the weight the audio subsystem will
give to this stream.
It is not meant to control hardware parameters like
speaker gain; the
.Xr mixerctl 1
interface should be used for that purpose instead.
.Pp
An application can use the
.Fn sio_onvol
function to register a callback function that
will be called each time the volume is changed,
including when
.Fn sio_setvol
is used.
The callback is always invoked when
.Fn sio_onvol
is called in order to provide the initial volume.
An application can safely assume that once
.Fn sio_onvol
has returned a non-zero value,
the callback has been invoked and thus
the current volume is available.
If there's no volume setting available,
.Fn sio_onvol
returns 0 and the callback is never invoked and calls to
.Fn sio_setvol
are ignored.
.Pp
The
.Fn sio_onvol
function can be called with a NULL argument to check whether
a volume knob is available.
.Ss Error handling
Errors related to the audio subsystem
(like hardware errors, dropped connections) and
programming errors (e.g. call to
.Fn sio_read
on a play-only stream) are considered fatal.
Once an error occurs, all functions taking a
.Fa sio_hdl
argument, except
.Fn sio_close
and
.Fn sio_eof ,
stop working (i.e. always return 0).
The
.Fn sio_eof
function can be used at any stage.
.Ss Use with Xr pledge 2
If the
.Nm sndio
library is used in combination with
.Xr pledge 2 ,
then the
.Fn sio_open
function needs the
.Va stdio ,
.Va rpath ,
.Va wpath ,
.Va cpath ,
.Va inet ,
.Va unix ,
.Va dns ,
and
.Va audio
.Xr pledge 2
promises.
.Bl -bullet
.It
.Va rpath ,
.Va wpath ,
and
.Va cpath
are needed to read, write or create the authentication cookie
.Pa ~/.aucat_cookie .
.It
.Va rpath ,
.Va wpath ,
and
.Va audio
are needed when the device is a local raw device.
.It
.Va unix
is needed when the device is a local
.Xr sndiod 8
sub-device.
.It
.Va inet
and
.Va dns
are needed when the device is a remote
.Xr sndiod 8
sub-device.
.El
.Pp
Once no further calls to
.Fn sio_open
will be made, all these
.Xr pledge 2
promises may be dropped, except for the
.Va audio
promise.
.Sh RETURN VALUES
The
.Fn sio_open
function returns the newly created handle on success or NULL
on failure.
.Pp
The
.Fn sio_setpar ,
.Fn sio_getpar ,
.Fn sio_getcap ,
.Fn sio_start ,
.Fn sio_stop ,
and
.Fn sio_setvol
functions return 1 on success and 0 on failure.
.Pp
The
.Fn sio_pollfd
function returns the number of
.Va pollfd
structures filled.
The
.Fn sio_nfds
function returns the number of
.Va pollfd
structures the caller must preallocate in order to be sure
that
.Fn sio_pollfd
will never overrun.
.Pp
The
.Fn sio_read
and
.Fn sio_write
functions return the number of bytes transferred.
.Pp
The
.Fn sio_eof
function returns 0 if there's no pending error, and a non-zero
value if there's an error.
.Sh ENVIRONMENT
.Bl -tag -width "SNDIO_DEBUGXXX" -compact
.It Ev AUDIODEVICE
Device to use if
.Fn sio_open
is called with
.Dv SIO_DEVANY
as the
.Fa name
argument.
.It Ev SNDIO_DEBUG
The debug level:
may be a value between 0 and 2.
.El
.Sh SEE ALSO
.Xr pledge 2 ,
.Xr audio 4 ,
.Xr sndio 7 ,
.Xr sndiod 8 ,
.Xr audio 9
.Sh BUGS
The
.Xr audio 4
driver doesn't drain playback buffers, thus if sndio
is used to directly access an
.Xr audio 4
device,
the
.Fn sio_stop
function will stop playback immediately.
.Pp
If the application doesn't consume recorded data fast enough then
.Dq "control messages"
from the
.Xr sndiod 8
server are delayed and consequently
.Fn sio_onmove
callback or volume changes may be delayed.
.Pp
The
.Fn sio_open ,
.Fn sio_setpar ,
.Fn sio_getpar ,
.Fn sio_getcap ,
.Fn sio_start ,
and
.Fn sio_stop
functions may block for a very short period of time, thus they should
be avoided in code sections where blocking is not desirable.
@


1.45
log
@Document how to use sndio in pledged programs.

Input and OK jmc@@ ratchov@@ semarie@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.44 2016/01/07 07:41:01 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: January 7 2016 $
a452 4
.Fn sio_pollfd
returns the number of
.Vt pollfd
structures filled.
d477 3
a479 1
The
d481 1
a481 6
function returns the number of
.Vt pollfd
structures the caller must preallocate in order to be sure
that
.Fn sio_pollfd
will never overrun.
a663 1
.Pp
d666 1
a666 3
function can be used at any stage;
it returns 0 if there's no pending error, and a non-zero
value if there's an error.
d726 1
a732 1
.Fn sio_pollfd ,
d736 15
d756 5
@


1.44
log
@Move sndiod man page to section 8.

suggested by deraadt, fixes from jmc, ok millert
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.42 2014/12/02 11:09:28 schwarze Exp $
d17 1
a17 1
.Dd $Mdocdate: December 2 2014 $
d677 54
d766 1
@


1.43
log
@Remove useless quoting from .Fo and .Fn function names, to prevent
development of a cargo cult in case people look at existing files
for examples.  This achieves a consistent .Fo and .Fn quoting style
across the whole tree.
@
text
@d83 1
a83 1
.Xr sndiod 1
d258 1
a258 1
.Xr sndiod 1
a711 1
.Xr sndiod 1 ,
d714 1
d730 1
a730 1
.Xr sndiod 1
@


1.42
log
@Kill the only instance of .Lb in our tree.  It is better to not use
it at all, not even occasionally, because there is no sustainable
way (and even less any portable way) to maintain the list of library
names.  Besides, without such a list, even the formatting looks bad.
OK jmc@@ bentley@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.41 2014/03/05 20:01:59 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: March 5 2014 $
d42 1
a42 1
.Fn "sio_open" "const char *name" "unsigned int mode" "int nbio_flag"
d44 1
a44 1
.Fn "sio_close" "struct sio_hdl *hdl"
d46 1
a46 1
.Fn "sio_setpar" "struct sio_hdl *hdl" "struct sio_par *par"
d48 1
a48 1
.Fn "sio_getpar" "struct sio_hdl *hdl" "struct sio_par *par"
d50 1
a50 1
.Fn "sio_getcap" "struct sio_hdl *hdl" "struct sio_cap *cap"
d52 1
a52 1
.Fn "sio_start" "struct sio_hdl *hdl"
d54 1
a54 1
.Fn "sio_stop" "struct sio_hdl *hdl"
d56 1
a56 1
.Fn "sio_read" "struct sio_hdl *hdl" "void *addr" "size_t nbytes"
d58 1
a58 1
.Fn "sio_write" "struct sio_hdl *hdl" "const void *addr" "size_t nbytes"
d60 1
a60 1
.Fn "sio_onmove" "struct sio_hdl *hdl" "void (*cb)(void *arg, int delta)" "void *arg"
d62 1
a62 1
.Fn "sio_nfds" "struct sio_hdl *hdl"
d64 1
a64 1
.Fn "sio_pollfd" "struct sio_hdl *hdl" "struct pollfd *pfd" "int events"
d66 1
a66 1
.Fn "sio_revents" "struct sio_hdl *hdl" "struct pollfd *pfd"
d68 1
a68 1
.Fn "sio_eof" "struct sio_hdl *hdl"
d70 1
a70 1
.Fn "sio_setvol" "struct sio_hdl *hdl" "unsigned int vol"
d72 1
a72 1
.Fn "sio_onvol" "struct sio_hdl *hdl" "void (*cb)(void *arg, unsigned int vol)" "void *arg"
d74 1
a74 1
.Fn "sio_initpar" "struct sio_par *par"
@


1.41
log
@say this is the "sndio" api, as we have other audio/midi apis,
makes "man -k" happier.

ok jmc, schwarze
@
text
@d1 1
a1 1
.\" $OpenBSD$
d17 1
a17 1
.Dd $Mdocdate$
d719 1
a719 2
driver doesn't drain playback buffers, thus if
.Lb libsndio
@


1.40
log
@clean up macro usage;
tweak and ok ratchov@@, ok jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.39 2013/12/23 14:14:31 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: December 23 2013 $
d38 1
a38 1
.Nd interface to audio devices
@


1.39
log
@- clarify that sio_close() stops the device first, then
  frees the handle and not the opposite
- clarify that sio_close() and sio_stop() dont discard
  samples in the play buffer.

suggested by Reimar Doeffinger <Reimar.Doeffinger at gmx.de>

ok jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD$
d17 1
a17 1
.Dd $Mdocdate$
d90 1
a90 1
.Ar hdl
d93 1
a93 1
.Ar name
d96 3
a98 2
In most cases it should be set to SIO_DEVANY to allow
the user to select it using the
d103 1
a103 1
.Ar mode
d106 1
a106 1
.It SIO_PLAY
d108 1
a108 1
.It SIO_REC
d110 1
a110 1
.It SIO_PLAY | SIO_REC
d117 1
a117 1
.Ar nbio_flag
d189 1
a189 1
.Va SIO_REC
d193 1
a193 1
.Va SIO_PLAY
d219 2
a220 2
.Va SIO_IGNORE ,
.Va SIO_SYNC
d222 1
a222 1
.Va SIO_ERROR
d230 1
a230 1
.Va sio_par
d239 1
a239 1
.Va sio_par
d265 1
a265 1
.Va sio_par
d269 1
a269 1
.It "SIO_BPS(bits)"
d274 2
a275 2
.Va bits .
.It "SIO_LE_NATIVE"
d289 1
a289 1
.Va sio_cap
d323 1
a323 1
.It Va enc[SIO_NENC]
d329 1
a329 1
.Va le
d334 1
a334 1
.Va sio_par
d336 1
a336 1
.It Va rchan[SIO_NCHAN]
d339 1
a339 1
.Va sio_par
d341 1
a341 1
.It Va pchan[SIO_NCHAN]
d344 1
a344 1
.Va sio_par
d346 1
a346 1
.It Va rate[SIO_NRATE]
d349 1
a349 1
.Va sio_par
d356 1
a356 1
.It Va confs[SIO_NCONF]
d364 1
a364 1
.Va sio_conf
d366 1
a366 1
.Va rate[SIO_NRATE]
d368 1
a368 1
.Va sio_cap
d403 1
a403 1
.Ar nbytes
d405 1
a405 1
.Ar addr
d408 1
a408 1
.Ar nbio_flag
d416 1
a416 1
.Ar nbio_flag
d422 1
a422 1
.Ar nbio_flag
d439 1
a439 1
.Ar pfd
d441 1
a441 1
.Va pollfd
d445 1
a445 1
.Ar events ;
d447 1
a447 1
.Va POLLIN
d449 1
a449 1
.Va POLLOUT
d455 1
a455 1
.Va pollfd
d462 1
a462 1
.Va pfd
d464 1
a464 1
.Va pollfd
d467 1
a467 1
.Va POLLIN
d472 1
a472 1
.Va POLLOUT
d476 2
a477 1
POLLHUP may be set if an error occurs, even if
d484 1
a484 1
.Va pollfd
d498 1
a498 1
.Va cb
d501 1
a501 1
.Va delta
d504 1
a504 1
.Va cb .
d506 2
a507 1
.Fn sio_read , sio_write ,
d512 1
a512 1
.Va delta
d515 1
a515 1
.Va arg
d522 1
a522 1
.Va delta
d571 1
a571 1
.Va sio_par
d574 1
a574 1
.It SIO_IGNORE
d577 1
a577 1
.Va sio_onmove )
d588 1
a588 1
.It SIO_SYNC
d597 1
a597 1
.Va sio_onmove )
d607 1
a607 1
.It SIO_ERROR
d621 1
a621 1
.Va vol
d665 1
a665 1
.Va sio_hdl
d688 1
a688 1
.Fn sio_pollfd
d702 4
a705 2
is called with SIO_DEVANY
.Va name
d720 1
a720 1
.Nm libsndio
d733 1
a733 1
.Va sio_onmove
d741 1
a741 1
.Fn sio_start
@


1.38
log
@- replaces "audio stream" by "audio device", as sndio is a device
  abstraction
- remove useless statements.

ok jmc@@
@
text
@a84 5
It supports full-duplex operation, and when
used with the
.Xr sndiod 1
server it supports resampling and format
conversions on the fly.
d125 1
a125 2
function closes the device and frees the handle.
If the device is not stopped it will be stopped first as if
d127 4
a130 1
is called.
a233 2
If the application supports any value for a given parameter,
then the corresponding parameter should be left unset.
d237 3
d256 1
a256 3
If
.Nm libsndio
is used to connect to the
d258 4
a261 3
server, a transparent emulation layer will
automatically be set up, and in this case any
parameters are supported.
d387 3
a389 3
function stops playback and recording and puts the audio subsystem
in the same state as after
.Fn sio_open
d391 1
a391 4
Samples in the play buffers are not discarded, and will continue to
be played after
.Fn sio_stop
returns.
d393 1
a393 1
then playback is forced immediately; the device will actually stop
d395 1
@


1.37
log
@remove FILES sections because it's incomplete, wrong and doesn't give
any useful information
@
text
@d38 1
a38 1
.Nd interface to bidirectional audio streams
d90 1
a90 1
.Ss Opening and closing an audio stream
d93 1
a93 1
function to obtain a handle representing the newly created stream;
d106 1
a106 1
The
d108 1
a108 2
parameter gives the direction of the stream.
The following are supported:
d111 1
a111 2
The stream is play-only; data written to the stream will be played
by the hardware.
d113 1
a113 2
The stream is record-only; recorded samples by the hardware
must be read from the stream.
d115 1
a115 1
The stream plays and records synchronously; this means that
d130 2
a131 5
function closes the stream and frees all allocated resources
associated with the
.Nm libsndio
handle.
If the stream is not stopped it will be stopped first as if
d135 4
a138 4
Audio streams always use linear interleaved encoding.
A frame consists of one sample for each channel in the stream.
For example, a 16-bit stereo stream has two samples per frame
and, typically, two bytes per sample (thus 4 bytes per frame).
d140 1
a140 1
The set of parameters of the stream that can be controlled
d228 1
a228 1
The following approach is recommended to negotiate parameters of the stream:
d241 1
a241 1
to request the stream to use them.
d245 1
a245 1
to retrieve the actual parameters of the stream
d252 1
a252 2
Parameters cannot be changed while the stream is in a waiting state;
if
d282 1
a282 1
.Ss Getting stream capabilities
d284 1
a284 1
combinations the stream supports.
d373 1
a373 1
.Ss Starting and stopping the stream
d376 2
a377 2
function puts the stream in a waiting state:
the stream will wait for playback data to be provided
d399 1
a399 1
then playback is forced immediately; the stream will actually stop
d436 1
a436 8
Note that non-blocking mode must be used on bidirectional streams.
For instance, if recording is blocked in
.Fn sio_read
then, even if samples can be played,
.Fn sio_write
cannot be called and the play buffers may underrun.
.Pp
To avoid busy loops when non-blocking mode is used, the
d439 1
a439 1
read from or written to the stream.
d472 3
a474 3
is set,
.Fn sio_read
can be called without blocking.
d477 3
a479 3
is set,
.Fn sio_write
can be called without blocking.
d492 2
a493 2
.Ss Synchronizing non-audio events to the stream in real-time
In order to perform actions at precise positions of the stream,
d502 1
a502 4
callback function that will be called by the
.Nm sndio
library at regular time intervals to notify the application
the position in the stream changed.
d505 1
a505 1
argument contains the number of frames the hardware moved in the stream
d508 6
a513 1
When the stream starts, the callback is invoked with a zero
d547 1
a547 2
This value takes into account all buffers,
including device, kernel and socket buffers.
d554 1
a554 3
It is strongly discouraged to use the latency and/or the buffer
usage for anything but monitoring.
Especially, note that
d577 1
a577 1
The stream is paused during overruns and underruns,
d581 1
a581 1
Once the overrun and/or underrun condition is gone, the stream is unpaused;
d611 1
a611 1
record buffer overrun, the stream is terminated and
d616 1
a616 3
This mode is mostly useful for testing; portable
applications shouldn't depend on it, since it's not available
on other systems.
d719 1
a719 1
driver cannot drain playback buffers in the background, thus if
a727 3
The
.Xr sndiod 1
server doesn't implement flow control (for performance reasons).
d730 3
a732 1
are delayed and consequently
@


1.36
log
@shorten lines in literal blocks to avoid word wraping
@
text
@a727 14
.Sh FILES
.Bl -tag -width "/tmp/aucat-<uid>/aucat0" -compact
.It Pa /tmp/aucat-<uid>/aucat0
Default path to
.Xr sndiod 1
socket to connect to.
.It Pa /dev/audio
Default
.Xr audio 4
device to use.
.El
.\".Sh EXAMPLES
.\".Bd -literal -offset indent
.\".Ed
@


1.35
log
@use fancy .In macro for includes. from Jan Klemkow. ok jmc schwarze
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.34 2013/04/06 11:38:41 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: April 6 2013 $
d150 8
a157 8
	unsigned int bits;		/* bits per sample */
	unsigned int bps;		/* bytes per sample */
	unsigned int sig;		/* 1 = signed, 0 = unsigned int */
	unsigned int le;		/* 1 = LE, 0 = BE byte order */
	unsigned int msb;		/* 1 = MSB, 0 = LSB aligned */
	unsigned int rchan;		/* number channels for recording */
	unsigned int pchan;		/* number channels for playback */
	unsigned int rate;		/* frames per second */
d159 2
a160 2
	unsigned int bufsz;		/* end-to-end buffer size (read-only) */
	unsigned int round;		/* optimal buffer size divisor */
d164 1
a164 1
	unsigned int xrun;		/* what to do on overrun/underrun */
d310 1
a310 1
	struct sio_enc {			/* allowed encodings */
d322 4
a325 4
		unsigned int enc;		/* bitmask of enc[] indexes */
		unsigned int rchan;		/* bitmask of rchan[] indexes */
		unsigned int pchan;		/* bitmask of pchan[] indexes */
		unsigned int rate;		/* bitmask of rate[] indexes */
@


1.34
log
@explain what "default" means in sndio.7 rather than {sio,mio}_open.3,
with tweaks from jmc
@
text
@d1 1
a1 1
.\" $OpenBSD$
d17 1
a17 1
.Dd $Mdocdate$
d40 1
a40 1
.Fd #include <sndio.h>
@


1.33
log
@Make the "default" string a valid device name that has the same effect
as NULL has. This will (hopefully) simplify ports where the user
passes the device string.
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.32 2012/04/11 06:05:43 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: April 11 2012 $
a96 8
The
.Fn sio_open
function first tries to connect to the
.Xr sndiod 1
audio server.
If that fails, it then tries to use the
.Xr audio 4
hardware device.
@


1.32
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.31 2011/12/24 08:46:48 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: December 24 2011 $
d109 1
a109 1
In most cases it should be set to NULL to allow
d729 1
a729 1
is called with a NULL
@


1.31
log
@formatting errors, found using freebsd's "igor";
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.30 2011/12/09 14:38:09 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: December 9 2011 $
d42 1
a42 1
.Fn "sio_open" "const char *name" "unsigned mode" "int nbio_flag"
d70 1
a70 1
.Fn "sio_setvol" "struct sio_hdl *hdl" "unsigned vol"
d72 1
a72 1
.Fn "sio_onvol" "struct sio_hdl *hdl" "void (*cb)(void *arg, unsigned vol)" "void *arg"
d158 11
a168 11
	unsigned bits;		/* bits per sample */
	unsigned bps;		/* bytes per sample */
	unsigned sig;		/* 1 = signed, 0 = unsigned */
	unsigned le;		/* 1 = LE, 0 = BE byte order */
	unsigned msb;		/* 1 = MSB, 0 = LSB aligned */
	unsigned rchan;		/* number channels for recording */
	unsigned pchan;		/* number channels for playback */
	unsigned rate;		/* frames per second */
	unsigned appbufsz;	/* minimum buffer size without xruns */
	unsigned bufsz;		/* end-to-end buffer size (read-only) */
	unsigned round;		/* optimal buffer size divisor */
d172 1
a172 1
	unsigned xrun;		/* what to do on overrun/underrun */
d319 5
a323 5
		unsigned bits;
		unsigned bps;
		unsigned sig;
		unsigned le;
		unsigned msb;
d325 4
a328 4
	unsigned rchan[SIO_NCHAN];	/* allowed rchans */
	unsigned pchan[SIO_NCHAN];	/* allowed pchans */
	unsigned rate[SIO_NRATE];	/* allowed rates */
	unsigned nconf;			/* num. of confs[] */
d330 4
a333 4
		unsigned enc;		/* bitmask of enc[] indexes */
		unsigned rchan;		/* bitmask of rchan[] indexes */
		unsigned pchan;		/* bitmask of pchan[] indexes */
		unsigned rate;		/* bitmask of rate[] indexes */
@


1.30
log
@mention sndiod rather than aucat when talking about the server
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.29 2011/10/17 21:09:11 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: October 17 2011 $
d194 1
a194 1
bits are aligned in the packet to the most significant bit
@


1.29
log
@Remove midicat since aucat can now be used instead of midicat
with almost the same syntax (roughly an extra -M option).
Thru boxes are created with aucat, and corresponding MIDI port
names have the "aucat" prefix instead of "midithru". The old
device name will still work some time for backward compatibility.

ok deraadt
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.28 2011/10/04 20:58:27 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: October 4 2011 $
d83 1
a83 1
.Xr aucat 1
d87 1
a87 1
.Xr aucat 1
d100 1
a100 1
.Xr aucat 1
d276 1
a276 1
.Xr aucat 1
d740 1
a740 1
.Xr aucat 1
d751 1
a751 1
.Xr aucat 1 ,
d768 1
a768 1
.Xr aucat 1
@


1.28
log
@some tweaks, from Tim van der Molen
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.27 2011/04/16 10:52:22 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: April 16 2011 $
d725 1
a725 1
.Bl -tag -width "AUDIODEVICEXXX" -compact
d737 2
a738 2
.Bl -tag -width "/tmp/aucat-<uid>/softaudio0" -compact
.It Pa /tmp/aucat-<uid>/softaudio0
@


1.27
log
@Make aucat audio and midi backends share the same code to communicate
with the server. As we're at it use the same protocol for midi and
audio. Now, both audio and midi code use the same SNDIO_DEBUG environment
variable to turn on/off DPRINTF's.
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.26 2010/11/06 22:17:26 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: November 6 2010 $
d219 2
a220 2
Size of the buffer in frames the application must maintain non empty
(on the play end) or non full (on the record end) by calling
d226 1
a226 1
parameter cannot be used for latency calculations
@


1.26
log
@tweak previous;
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.25 2010/11/06 20:25:42 ratchov Exp $
d732 1
a732 1
.It Ev SIO_DEBUG
@


1.25
log
@make sio_onvol(3) return a integer exposing whether a volume knob
is available for the stream. As we're at it, remove macros and
functions that are neither used nor documented.
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.24 2010/04/26 07:11:10 jakemsr Exp $
d17 1
a17 1
.Dd $Mdocdate: April 26 2010 $
d672 2
a673 1
returns non-zero value, the callback has already been invoked and thus
@


1.24
log
@once sio_start() has been called, stream parameters cannot be
changed until after sio_stop() is called

ok ratchov@@, jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.23 2010/04/06 20:07:01 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: April 6 2010 $
d71 1
a71 1
.Ft "void"
d672 1
a672 1
returns, the callback has already been invoked and thus
d674 10
@


1.23
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.22 2009/12/30 08:27:12 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: December 30 2009 $
d265 7
@


1.22
log
@explain what sio_close() drains play buffers as if sio_close() was
called. Since sio_onmove() callback doesn't return negative deltas
anymore, slightly simplify related paragraphs.

siggested by espie@@, ok jakemsr@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.21 2009/07/25 11:15:56 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: July 25 2009 $
d242 1
a242 1
There are two approaches to negotiate parameters of the stream:
d245 3
a247 8
Advanced applications may use native parameters of
the audio subsystem.
This is the best approach from a performance point of view
since it involves no extra format conversions.
The
.Fn sio_getcap ,
described below,
can be used to get the list of native parameter sets and then
d249 5
a253 1
and
d255 1
a255 1
can be used to select a working set.
d257 1
a257 11
Simpler applications that do not have performance constraints may set up
the audio subsystem to use their own parameters.
The
.Va sio_par
structure must be initialized using the
.Fn sio_initpar
function, filled with the desired parameters and
the
.Fn sio_setpar
function must be called.
Finally, the
d259 3
a261 2
function should be used to ensure that parameters were actually
accepted.
d290 7
a297 16
Note that (once initialized with the
.Fn sio_initpar
function), not all fields of the
.Va sio_par
structure must be filled; it is recommended to fill only
the required parameters, as other ones will default to
reasonable values.
This approach also ensures that if, in the future, newer parameters
are added, then older unaware applications will continue to
behave correctly.
.Ss Getting stream capabilities
Advanced applications can fetch the native
parameters of the audio subsystem and then choose parameters
optimal for both the application and the audio subsystem.
In this case applications must be able to do
the necessary format conversions.
d300 1
a300 3
structure, filled by the
.Fn sio_getcap
function, contains the list of parameter configurations.
@


1.21
log
@use const qualifier in libsndio, making it slightly more consistent
with open(2) and write(2) syscalls.
from Thomas Pfaff, jakemsr is fine with it
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.20 2009/07/25 08:44:27 ratchov Exp $
d145 3
d427 3
d547 3
a561 3
Note that at the beginning the current position might be
negative indicating that the stream is being buffered,
but has not reached the hardware yet.
d576 1
a576 3
During this phase the current position is negative and
the latency might be longer than
.Va bufsz .
d583 1
a583 3
During the buffering phase, the number of frames stored
is equal to the number of frames written.
Once playback is started, it is equal to the number of frames
d775 3
a777 5
are delayed (or lost) and consequently
overruns and underruns stay unnoticed by the application in the
.Va SIO_SYNC
mode (overruns and underruns are handled on the server side, so
synchronization is never lost).
@


1.20
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.19 2009/05/15 11:07:41 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: May 15 2009 $
d42 1
a42 1
.Fn "sio_open" "char *name" "unsigned mode" "int nbio_flag"
d58 1
a58 1
.Fn "sio_write" "struct sio_hdl *hdl" "void *addr" "size_t nbytes"
@


1.19
log
@describe sio_getcap(), sio_pollfd() and sio_setvol() retrurn values
spotted by Philipp Schafft
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.18 2009/02/04 21:39:09 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: February 4 2009 $
d107 2
a108 5
parameter gives the name of the
.Xr aucat 1
socket or the path of the
.Xr audio 4
device.
d728 5
a732 5
Name of the
.Xr aucat 1
socket to connect to, or path to the
.Xr audio 4
device to use.
d738 2
a739 2
.Bl -tag -width "/tmp/aucat-<uid>/default" -compact
.It Pa /tmp/aucat-<uid>/default
d754 1
@


1.18
log
@update the default socket paths, to reflect recent aucat changes
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.17 2009/02/04 18:47:42 ratchov Exp $
d716 1
d718 2
d721 1
a721 1
.Fn sio_stop ,
d785 1
@


1.17
log
@explain that it's ok if we get a slightly different rate than
the one we asked for, from Thomas Pfaff <tpfaff(at)tp76.info>
with tweaks from jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.16 2009/01/21 22:36:50 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: January 21 2009 $
d107 1
a107 1
parameter gives the path of the
d109 1
a109 1
socket or the
d728 1
a728 1
Path to the
d730 1
a730 1
socket to connect to, or the
d738 2
a739 2
.Bl -tag -width "/tmp/aucat.sockXXX" -compact
.It Pa /tmp/aucat.sock
@


1.16
log
@fix bugs section: clarify that sio_start() and sio_stop() should
not be used if blocking is not desirable.
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.15 2009/01/21 22:18:31 ratchov Exp $
d270 1
a270 1
function can be used to ensure that parameters were actually
d272 2
@


1.15
log
@explain what ``frame'' does mean
from Thomas Pfaff <tpfaff(at)tp76.info>, thanks!
ok jmc
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.14 2009/01/12 20:47:34 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: January 12 2009 $
d784 1
a784 1
not be abused during performance.
@


1.14
log
@replace s/routine/function/, as other manuals do
from Thomas Pfaff <tpfaff(at)tp76.info>, thanks!
ok jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.13 2009/01/08 18:55:40 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: January 8 2009 $
d112 1
a112 1
In most cases it should be left to NULL to allow
d150 4
@


1.13
log
@oops, i messed up tim's patch; correction from Tim van der Molen
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.12 2009/01/08 14:01:03 jmc Exp $
d93 1
a93 1
routine to obtain a handle representing the newly created stream;
d99 1
a99 1
routine first tries to connect to the
d140 1
a140 1
routines (see below) will be non-blocking.
d144 1
a144 1
routine closes the stream and frees all allocated resources
d260 1
a260 1
routine, filled with the desired parameters and
d263 1
a263 1
routine must be called.
d266 1
a266 1
routine can be used to ensure that parameters were actually
d297 1
a297 1
routine), not all fields of the
d315 1
a315 1
routine, contains the list of parameter configurations.
d399 1
a399 1
routine puts the stream in a waiting state:
d403 1
a403 1
routine).
d413 1
a413 1
routine stops playback and recording and puts the audio subsystem
d424 1
a424 1
routine must be called to retrieve recorded data; it must be called
d438 1
a438 1
routine must be called to provide data to play.
d453 1
a453 1
routines will never block; if no data is available, they will
d469 1
a469 1
routine fills the array
d490 1
a490 1
routine returns the bit-mask set by
d513 1
a513 1
routine returns the number of
d527 1
a527 1
routine can be used to register the
d699 1
a699 1
routine can be used at any stage;
d759 1
a759 1
routine will stop playback immediately.
d779 1
a779 1
routines may block for a very short period of time, thus they should
@


1.12
log
@a little macro cleanup; from Tim van der Molen
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.11 2008/12/17 10:00:50 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: December 17 2008 $
d186 1
a186 1
\*(Gt 1 .
d198 1
a198 1
* 8 .
@


1.11
log
@stop using stderr in the library, wrap all diagnostic fprintfs
so they are visible only when the DEBUG macro is #defined
and SIO_DEBUG env. variable is set.
requested by many, discussed with jakemsr
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.10 2008/12/17 09:04:06 jmc Exp $
d185 2
a186 1
.Va bps \*(Gt 1 .
d195 4
a198 1
.Va bits \*(Lt bps * 8 .
@


1.10
log
@tweak previous;
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.9 2008/12/17 07:19:27 ratchov Exp $
d723 1
a723 1
.It Ev LIBSIO_DEBUG
@


1.9
log
@add a writable ``appbufsz'' field to the sa_par structure, containing
the program-part of the buffer size, ie the part that is subject to
underruns. Useful for apps like cdio(1) that don't have their own
rings, or to apps that have a minimum ring size constraint. Setting
the ``bufsz'' parameter becomes deprecated.
ok jakemsr
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.8 2008/11/17 07:49:48 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: November 17 2008 $
d207 1
a207 1
This parameter takes into accout any buffers, and
d209 1
a209 1
This parameter is read-only.
d217 1
a217 1
The audio subsystem may use additionnal buffering, thus this
@


1.8
log
@occures -> occurs;
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.7 2008/11/16 21:52:58 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: November 16 2008 $
d152 1
a152 1
.Bd -literal -offset -indent
d154 11
a164 10
	unsigned bits;	/* bits per sample */
	unsigned bps;	/* bytes per sample */
	unsigned sig;	/* 1 = signed, 0 = unsigned */
	unsigned le;	/* 1 = LE, 0 = BE byte order */
	unsigned msb;	/* 1 = MSB, 0 = LSB aligned */
	unsigned rchan;	/* number channels for recording */
	unsigned pchan;	/* number channels for playback */
	unsigned rate;	/* frames per second */
	unsigned bufsz;	/* frames in the stream buffer */
	unsigned round;	/* optimal buffer size divisor */
d166 1
a166 1
#define SIO_SYNC		1	/* resync after xrun */
d168 1
a168 1
	unsigned xrun;	/* what to do on overrun/underrun */
d173 1
a173 1
.Bl -tag -width "round"
d206 13
a218 2
The number of frames that will be buffered for both
play and record directions.
d593 1
a593 1
.Va bufsz )
@


1.7
log
@document that sio_revents() can return POLLHUP
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.6 2008/11/11 21:45:03 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: November 11 2008 $
d491 1
a491 1
POLLHUP may be set if an error occures, even if
@


1.6
log
@tweak previous;
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.5 2008/11/11 19:39:35 ratchov Exp $
d491 3
@


1.5
log
@expose a volume knob in the sndio API: add sio_setvol(3) and
sio_onvol(3) functions. The audio(4) backend tries to use the
inputs.dac, outputs.dac, outputs.output and outputs.master
controls (in this order). Add a sample file in
regress/lib/libsndio/vol/vol.c
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.4 2008/11/09 19:49:10 naddy Exp $
d17 1
a17 1
.Dd $Mdocdate: November 9 2008 $
d510 1
a510 1
call-back function that will be called by the
d521 1
a521 1
pointer is passed to the call-back and can contain anything.
d636 1
a636 1
function can be used to set the playback attenuation.
d641 1
a641 1
.Va SIO_MAXVOL
d643 1
a643 1
This parameter gives the weight the audio subsystem will
d645 3
a647 3
It is not meant to control hardware parameters like the
speakers gain, the
.Xr mixer
d652 3
a654 3
function to register a call-back function that
will be called each time the volume is changed, including
when
d657 1
a657 1
The call-back is always invoked when
d659 2
a660 2
function is called in order to provide the initial volume.
The application can safely assume that once
d662 1
a662 1
returns, the call-back was already invoked and thus
@


1.4
log
@typos; ok ratchov@@ jmc@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.3 2008/11/07 21:01:15 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: November 7 2008 $
d35 2
d69 4
d633 31
@


1.3
log
@expose the block size in the sndio API by making par->round writable
and thus remove the ugly rate <-> block-size table from
sio_setpar(3). Handle the block size negociation in aucat(1), since
it has few constrains the code is overally simpler.
ok jakemsr@@, major crank suggested by deraadt@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.2 2008/10/29 02:47:47 todd Exp $
d17 1
a17 1
.Dd $Mdocdate: October 29 2008 $
d41 1
a41 1
.Ft "int"
d73 1
a73 1
.Nm libsndio
d339 1
a339 1
.It Va rchan[SIO_NENC]
d344 1
a344 1
.It Va pchan[SIO_NENC]
d505 1
a505 1
.Nm libsndio
d662 1
a662 1
functions return the number of bytes transfered.
@


1.2
log
@document LIBSIO_DEBUG
ok ratchov@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.1 2008/10/27 00:26:33 ratchov Exp $
d17 1
a17 1
.Dd $Mdocdate: October 27 2008 $
d203 2
a204 2
should be a multiple of, to get best performance;
it is read-only.
@


1.1
log
@rename libsa to libsndio
requested by many, "just go for it" deraadt@@
@
text
@d1 1
a1 1
.\" $OpenBSD: sio_open.3,v 1.2 2008/10/26 15:07:25 jmc Exp $
d17 1
a17 1
.Dd $Mdocdate: October 26 2008 $
d671 3
@

