head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.4
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.6
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.7.0.4
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.2
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.26
date	2016.04.07.06.30.13;	author ratchov;	state Exp;
branches;
next	1.25;
commitid	kTDuStnlQIgCeaJX;

1.25
date	2016.01.09.08.27.24;	author ratchov;	state Exp;
branches;
next	1.24;
commitid	ScnbaRlQejqjUMct;

1.24
date	2015.12.20.11.29.29;	author ratchov;	state Exp;
branches;
next	1.23;
commitid	6m1XWJevm3uKBS61;

1.23
date	2015.11.22.12.10.26;	author ratchov;	state Exp;
branches;
next	1.22;
commitid	xcy13zrBm4VlKDb1;

1.22
date	2015.11.22.12.01.23;	author ratchov;	state Exp;
branches;
next	1.21;
commitid	qJB6f577aQuApYmn;

1.21
date	2015.11.18.09.35.59;	author ratchov;	state Exp;
branches;
next	1.20;
commitid	z0pLDGWmCpf68g6W;

1.20
date	2015.11.17.16.07.42;	author ratchov;	state Exp;
branches;
next	1.19;
commitid	yoKdGmbpkZrMLgCX;

1.19
date	2015.10.02.09.48.22;	author ratchov;	state Exp;
branches;
next	1.18;
commitid	wlyu2QA4h4oEsjiW;

1.18
date	2015.10.02.09.45.26;	author ratchov;	state Exp;
branches;
next	1.17;
commitid	qXiOnGsosyCwq3DG;

1.17
date	2015.10.02.09.40.57;	author ratchov;	state Exp;
branches;
next	1.16;
commitid	Jw5ZHptXjh7DRpJ1;

1.16
date	2015.07.28.20.48.49;	author ratchov;	state Exp;
branches;
next	1.15;
commitid	NAp3ei2r4W0GKcSs;

1.15
date	2015.07.24.08.50.29;	author ratchov;	state Exp;
branches;
next	1.14;
commitid	iFZe2WluSi82otDI;

1.14
date	2015.02.16.06.04.06;	author ratchov;	state Exp;
branches;
next	1.13;
commitid	JOc78hQeMsKUAR4B;

1.13
date	2014.11.21.09.07.17;	author ratchov;	state Exp;
branches;
next	1.12;
commitid	bCxDZtTFUNpO6JSx;

1.12
date	2014.08.15.03.51.40;	author guenther;	state Exp;
branches;
next	1.11;
commitid	ILfd29dGeQRUYnTr;

1.11
date	2014.03.05.20.40.49;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2013.12.20.08.51.28;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.13.22.38.22;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.24.12.32.35;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.14.22.50.26;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.15.08.05.22;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.03.20.15.23;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.16.10.52.22;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.08.11.18.07;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Use the "new" audio(4) api and delete all the useless code to deal
with artificial complications caused by the old api. No behaviour
change.

ok armani, semarie
@
text
@/*	$OpenBSD: sio_sun.c,v 1.23 2015/11/22 12:10:26 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "debug.h"
#include "sio_priv.h"

#define DEVPATH_PREFIX	"/dev/audio"
#define DEVPATH_MAX 	(1 +		\
	sizeof(DEVPATH_PREFIX) - 1 +	\
	sizeof(int) * 3)

struct sio_sun_hdl {
	struct sio_hdl sio;
	int fd;
	int filling;
	unsigned int ibpf, obpf;	/* bytes per frame */
	unsigned int ibytes, obytes;	/* bytes the hw transferred */
	unsigned int ierr, oerr;	/* frames the hw dropped */
	int idelta, odelta;		/* position reported to client */
};

static void sio_sun_close(struct sio_hdl *);
static int sio_sun_start(struct sio_hdl *);
static int sio_sun_stop(struct sio_hdl *);
static int sio_sun_setpar(struct sio_hdl *, struct sio_par *);
static int sio_sun_getpar(struct sio_hdl *, struct sio_par *);
static int sio_sun_getcap(struct sio_hdl *, struct sio_cap *);
static size_t sio_sun_read(struct sio_hdl *, void *, size_t);
static size_t sio_sun_write(struct sio_hdl *, const void *, size_t);
static int sio_sun_nfds(struct sio_hdl *);
static int sio_sun_pollfd(struct sio_hdl *, struct pollfd *, int);
static int sio_sun_revents(struct sio_hdl *, struct pollfd *);

static struct sio_ops sio_sun_ops = {
	sio_sun_close,
	sio_sun_setpar,
	sio_sun_getpar,
	sio_sun_getcap,
	sio_sun_write,
	sio_sun_read,
	sio_sun_start,
	sio_sun_stop,
	sio_sun_nfds,
	sio_sun_pollfd,
	sio_sun_revents,
	NULL, /* setvol */
	NULL, /* getvol */
};

static int
sio_sun_adjpar(struct sio_sun_hdl *hdl, struct audio_swpar *ap)
{
	if (hdl->sio.eof)
		return 0;
	if (ioctl(hdl->fd, AUDIO_SETPAR, ap)) {
		DPERROR("AUDIO_SETPAR");
		hdl->sio.eof = 1;
		return 0;
	}
	if (ioctl(hdl->fd, AUDIO_GETPAR, ap)) {
		DPERROR("AUDIO_GETPAR");
		hdl->sio.eof = 1;
		return 0;
	}
	return 1;
}

/*
 * try to set the device to the given parameters and check that the
 * device can use them; return 1 on success, 0 on failure or error
 */
static int
sio_sun_testpar(struct sio_sun_hdl *hdl, struct sio_enc *enc,
    unsigned int pchan, unsigned int rchan, unsigned int rate)
{
	struct audio_swpar ap;

	AUDIO_INITPAR(&ap);
	if (enc != NULL) {
		ap.sig = enc->sig;
		ap.bits = enc->bits;
		ap.bps = enc->bps;
		if (ap.bps > 1)
			ap.le = enc->le;
		if (ap.bps * 8 > ap.bits)
			ap.msb = enc->msb;
	}
	if (rate)
		ap.rate = rate;
	if (pchan && (hdl->sio.mode & SIO_PLAY))
		ap.pchan = pchan;
	if (rchan && (hdl->sio.mode & SIO_REC))
		ap.rchan = rchan;
	if (!sio_sun_adjpar(hdl, &ap))
		return 0;
	if (pchan && ap.pchan != pchan)
		return 0;
	if (rchan && ap.rchan != rchan)
		return 0;
	if (rate && ap.rate != rate)
		return 0;
	if (enc) {
		if (ap.sig != enc->sig)
			return 0;
		if (ap.bits != enc->bits)
			return 0;
		if (ap.bps != enc->bps)
			return 0;
		if (ap.bps > 1 && ap.le != enc->le)
			return 0;
		if (ap.bits < ap.bps * 8 && ap.msb != enc->msb)
			return 0;
	}
	return 1;
}

/*
 * guess device capabilities
 */
static int
sio_sun_getcap(struct sio_hdl *sh, struct sio_cap *cap)
{
	static unsigned int chans[] = {
		1, 2, 4, 6, 8, 10, 12
	};
	static unsigned int rates[] = {
		8000, 11025, 12000, 16000, 22050, 24000,
		32000, 44100, 48000, 64000, 88200, 96000
	};
	static unsigned int encs[] = {
		8, 16, 24, 32
	};
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;
	struct audio_swpar savepar, ap;
	unsigned int nconf = 0;
	unsigned int enc_map = 0, rchan_map = 0, pchan_map = 0, rate_map;
	unsigned int i, j, conf;

	if (ioctl(hdl->fd, AUDIO_GETPAR, &savepar)) {
		DPERROR("AUDIO_GETPAR");
		hdl->sio.eof = 1;
		return 0;
	}

	/*
	 * get a subset of supported encodings
	 */
	for (i = 0; i < sizeof(encs) / sizeof(encs[0]); i++) {
		AUDIO_INITPAR(&ap);
		ap.bits = encs[i];
		ap.sig = (ap.bits > 8) ? 1 : 0;
		if (!sio_sun_adjpar(hdl, &ap))
			return 0;
		if (ap.bits == encs[i]) {
			cap->enc[i].sig = ap.sig;
			cap->enc[i].bits = ap.bits;
			cap->enc[i].le = ap.le;
			cap->enc[i].bps = ap.bps;
			cap->enc[i].msb = ap.msb;
			enc_map |= 1 << i;
		}
	}

	/*
	 * fill channels
	 *
	 * for now we're lucky: all kernel devices assume that the
	 * number of channels and the encoding are independent so we can
	 * use the current encoding and try various channels.
	 */
	if (hdl->sio.mode & SIO_PLAY) {
		for (i = 0; i < sizeof(chans) / sizeof(chans[0]); i++) {
			AUDIO_INITPAR(&ap);
			ap.pchan = chans[i];
			if (!sio_sun_adjpar(hdl, &ap))
				return 0;
			if (ap.pchan == chans[i]) {
				cap->pchan[i] = chans[i];
				pchan_map |= (1 << i);
			}
		}
	}
	if (hdl->sio.mode & SIO_REC) {
		for (i = 0; i < sizeof(chans) / sizeof(chans[0]); i++) {
			AUDIO_INITPAR(&ap);
			ap.pchan = chans[i];
			if (!sio_sun_adjpar(hdl, &ap))
				return 0;
			if (ap.rchan == chans[i]) {
				cap->rchan[i] = chans[i];
				rchan_map |= (1 << i);
			}
		}
	}

	/*
	 * fill rates
	 *
	 * rates are not independent from other parameters (eg. on
	 * uaudio devices), so certain rates may not be allowed with
	 * certain encodings. We have to check rates for all encodings
	 */
	for (j = 0; j < sizeof(encs) / sizeof(encs[0]); j++) {
		rate_map = 0;
		if ((enc_map & (1 << j)) == 0)
			continue;
		for (i = 0; i < sizeof(rates) / sizeof(rates[0]); i++) {
			if (sio_sun_testpar(hdl,
				&cap->enc[j], 0, 0, rates[i])) {
				cap->rate[i] = rates[i];
				rate_map |= (1 << i);
			}
		}
		for (conf = 0; conf < nconf; conf++) {
			if (cap->confs[conf].rate == rate_map) {
				cap->confs[conf].enc |= (1 << j);
				break;
			}
		}
		if (conf == nconf) {
			if (nconf == SIO_NCONF)
				break;
			cap->confs[nconf].enc = (1 << j);
			cap->confs[nconf].pchan = pchan_map;
			cap->confs[nconf].rchan = rchan_map;
			cap->confs[nconf].rate = rate_map;
			nconf++;
		}
	}
	cap->nconf = nconf;

	if (ioctl(hdl->fd, AUDIO_SETPAR, &savepar)) {
		DPERROR("AUDIO_SETPAR");
		hdl->sio.eof = 1;
		return 0;
	}
	return 1;
}

int
sio_sun_getfd(const char *str, unsigned int mode, int nbio)
{
	const char *p;
	char path[DEVPATH_MAX];
	unsigned int devnum;
	int fd, flags;

#ifdef DEBUG
	_sndio_debug_init();
#endif
	p = _sndio_parsetype(str, "rsnd");
	if (p == NULL) {
		DPRINTF("sio_sun_getfd: %s: \"rsnd\" expected\n", str);
		return -1;
	}
	switch (*p) {
	case '/':
		p++;
		break;
	default:
		DPRINTF("sio_sun_getfd: %s: '/' expected\n", str);
		return -1;
	}
	p = _sndio_parsenum(p, &devnum, 255);
	if (p == NULL || *p != '\0') {
		DPRINTF("sio_sun_getfd: %s: number expected after '/'\n", str);
		return -1;
	}
	snprintf(path, sizeof(path), DEVPATH_PREFIX "%u", devnum);
	if (mode == (SIO_PLAY | SIO_REC))
		flags = O_RDWR;
	else
		flags = (mode & SIO_PLAY) ? O_WRONLY : O_RDONLY;
	while ((fd = open(path, flags | O_NONBLOCK | O_CLOEXEC)) < 0) {
		if (errno == EINTR)
			continue;
		DPERROR(path);
		return -1;
	}
	return fd;
}

struct sio_hdl *
sio_sun_fdopen(int fd, unsigned int mode, int nbio)
{
	struct sio_sun_hdl *hdl;

#ifdef DEBUG
	_sndio_debug_init();
#endif
	hdl = malloc(sizeof(struct sio_sun_hdl));
	if (hdl == NULL)
		return NULL;
	_sio_create(&hdl->sio, &sio_sun_ops, mode, nbio);

	/*
	 * pause the device
	 */
	if (ioctl(fd, AUDIO_STOP) < 0) {
		DPERROR("AUDIO_STOP");
		free(hdl);
		return NULL;
	}
	hdl->fd = fd;
	hdl->filling = 0;
	return (struct sio_hdl *)hdl;
}

struct sio_hdl *
_sio_sun_open(const char *str, unsigned int mode, int nbio)
{
	struct sio_hdl *hdl;
	int fd;

	fd = sio_sun_getfd(str, mode, nbio);
	if (fd < 0)
		return NULL;
	hdl = sio_sun_fdopen(fd, mode, nbio);
	if (hdl != NULL)
		return hdl;
	while (close(fd) < 0 && errno == EINTR)
		; /* retry */
	return NULL;
}

static void
sio_sun_close(struct sio_hdl *sh)
{
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;

	while (close(hdl->fd) < 0 && errno == EINTR)
		; /* retry */
	free(hdl);
}

static int
sio_sun_start(struct sio_hdl *sh)
{
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;

	hdl->obpf = hdl->sio.par.pchan * hdl->sio.par.bps;
	hdl->ibpf = hdl->sio.par.rchan * hdl->sio.par.bps;
	hdl->ibytes = 0;
	hdl->obytes = 0;
	hdl->ierr = 0;
	hdl->oerr = 0;
	hdl->idelta = 0;
	hdl->odelta = 0;

	if (hdl->sio.mode & SIO_PLAY) {
		/*
		 * keep the device paused and let sio_sun_pollfd() trigger the
		 * start later, to avoid buffer underruns
		 */
		hdl->filling = 1;
	} else {
		/*
		 * no play buffers to fill, start now!
		 */
		if (ioctl(hdl->fd, AUDIO_START) < 0) {
			DPERROR("AUDIO_START");
			hdl->sio.eof = 1;
			return 0;
		}
		_sio_onmove_cb(&hdl->sio, 0);
	}
	return 1;
}

static int
sio_sun_stop(struct sio_hdl *sh)
{
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;

	if (hdl->filling) {
		hdl->filling = 0;
		return 1;
	}
	if (ioctl(hdl->fd, AUDIO_STOP) < 0) {
		DPERROR("AUDIO_STOP");
		hdl->sio.eof = 1;
		return 0;
	}
	return 1;
}

static int
sio_sun_setpar(struct sio_hdl *sh, struct sio_par *par)
{
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;
	struct audio_swpar ap;

	AUDIO_INITPAR(&ap);
	ap.sig = par->sig;
	ap.le = par->le;
	ap.bits = par->bits;
	ap.bps = par->bps;
	ap.msb = par->msb;
	ap.rate = par->rate;
	if (hdl->sio.mode & SIO_PLAY)
		ap.pchan = par->pchan;
	if (hdl->sio.mode & SIO_REC)
		ap.rchan = par->rchan;
	if (par->round != ~0U && par->appbufsz != ~0U) {
		ap.round = par->round;
		ap.nblks = par->appbufsz / par->round;
	} else if (par->round != ~0U) {
		ap.round = par->round;
		ap.nblks = 2;
	} else if (par->appbufsz != ~0U) {
		ap.round = par->appbufsz / 2;
		ap.nblks = 2;
	}
	if (ioctl(hdl->fd, AUDIO_SETPAR, &ap) < 0) {
		DPERROR("AUDIO_SETPAR");
		hdl->sio.eof = 1;
		return 0;
	}
	return 1;
}

static int
sio_sun_getpar(struct sio_hdl *sh, struct sio_par *par)
{
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;
	struct audio_swpar ap;

	if (ioctl(hdl->fd, AUDIO_GETPAR, &ap) < 0) {
		DPERROR("AUDIO_GETPAR");
		hdl->sio.eof = 1;
		return 0;
	}
	par->sig = ap.sig;
	par->le = ap.le;
	par->bits = ap.bits;
	par->bps = ap.bps;
	par->msb = ap.msb;
	par->rate = ap.rate;
	par->pchan = ap.pchan;
	par->rchan = ap.rchan;
	par->round = ap.round;
	par->appbufsz = par->bufsz = ap.nblks * ap.round;
	par->xrun = SIO_IGNORE;
	return 1;
}

static size_t
sio_sun_read(struct sio_hdl *sh, void *buf, size_t len)
{
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;
	ssize_t n;

	while ((n = read(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			DPERROR("sio_sun_read: read");
			hdl->sio.eof = 1;
		}
		return 0;
	}
	if (n == 0) {
		DPRINTF("sio_sun_read: eof\n");
		hdl->sio.eof = 1;
		return 0;
	}
	return n;
}

static size_t
sio_sun_write(struct sio_hdl *sh, const void *buf, size_t len)
{
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;
	const unsigned char *data = buf;
	ssize_t n, todo;

	todo = len;
	while ((n = write(hdl->fd, data, todo)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			DPERROR("sio_sun_write: write");
			hdl->sio.eof = 1;
		}
		return 0;
	}
	return n;
}

static int
sio_sun_nfds(struct sio_hdl *hdl)
{
	return 1;
}

static int
sio_sun_pollfd(struct sio_hdl *sh, struct pollfd *pfd, int events)
{
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;

	pfd->fd = hdl->fd;
	pfd->events = events;
	if (hdl->filling && hdl->sio.wused == hdl->sio.par.bufsz *
		hdl->sio.par.pchan * hdl->sio.par.bps) {
		hdl->filling = 0;
		if (ioctl(hdl->fd, AUDIO_START) < 0) {
			DPERROR("AUDIO_START");
			hdl->sio.eof = 1;
			return 0;
		}
		_sio_onmove_cb(&hdl->sio, 0);
	}
	return 1;
}

int
sio_sun_revents(struct sio_hdl *sh, struct pollfd *pfd)
{
	struct sio_sun_hdl *hdl = (struct sio_sun_hdl *)sh;
	struct audio_pos ap;
	int dierr = 0, doerr = 0, offset, delta;
	int revents = pfd->revents;

	if ((pfd->revents & POLLHUP) ||
	    (pfd->revents & (POLLIN | POLLOUT)) == 0)
		return pfd->revents;
	if (ioctl(hdl->fd, AUDIO_GETPOS, &ap) < 0) {
		DPERROR("sio_sun_revents: GETPOS");
		hdl->sio.eof = 1;
		return POLLHUP;
	}
	if (hdl->sio.mode & SIO_PLAY) {
		delta = (ap.play_pos - hdl->obytes) / hdl->obpf;
		doerr = (ap.play_xrun - hdl->oerr) / hdl->obpf;
		hdl->obytes = ap.play_pos;
		hdl->oerr = ap.play_xrun;
		hdl->odelta += delta;
		if (!(hdl->sio.mode & SIO_REC)) {
			hdl->idelta += delta;
			dierr = doerr;
		}
		if (doerr > 0)
			DPRINTFN(2, "play xrun %d\n", doerr);
	}
	if (hdl->sio.mode & SIO_REC) {
		delta = (ap.rec_pos - hdl->ibytes) / hdl->ibpf;
		dierr = (ap.rec_xrun - hdl->ierr) / hdl->ibpf;
		hdl->ibytes = ap.rec_pos;
		hdl->ierr = ap.rec_xrun;
		hdl->idelta += delta;
		if (!(hdl->sio.mode & SIO_PLAY)) {
			hdl->odelta += delta;
			doerr = dierr;
		}
		if (dierr > 0)
			DPRINTFN(2, "rec xrun %d\n", dierr);
	}

	/*
	 * GETPOS reports positions including xruns,
	 * so we have to substract to get the real position
	 */
	hdl->idelta -= dierr;
	hdl->odelta -= doerr;

	offset = doerr - dierr;
	if (offset > 0) {
		hdl->sio.rdrop += offset * hdl->ibpf;
		hdl->idelta -= offset;
		DPRINTFN(2, "will drop %d and pause %d\n", offset, doerr);
	} else if (offset < 0) {
		hdl->sio.wsil += -offset * hdl->obpf;
		hdl->odelta -= -offset;
		DPRINTFN(2, "will insert %d and pause %d\n", -offset, dierr);
	}

	delta = (hdl->idelta > hdl->odelta) ? hdl->idelta : hdl->odelta;
	if (delta > 0) {
		_sio_onmove_cb(&hdl->sio, delta);
		hdl->idelta -= delta;
		hdl->odelta -= delta;
	}
	return revents;
}
@


1.25
log
@Make code fit in 80 columns, remove trailing spaces & tabs.
@
text
@a77 3
/*
 * convert sun encoding to sio_par encoding
 */
d79 1
a79 2
sio_sun_infotoenc(struct sio_sun_hdl *hdl, struct audio_prinfo *ai,
    struct sio_par *par)
d81 9
a89 30
	par->msb = ai->msb;
	par->bits = ai->precision;
	par->bps = ai->bps;
	switch (ai->encoding) {
	case AUDIO_ENCODING_SLINEAR_LE:
		par->le = 1;
		par->sig = 1;
		break;
	case AUDIO_ENCODING_SLINEAR_BE:
		par->le = 0;
		par->sig = 1;
		break;
	case AUDIO_ENCODING_ULINEAR_LE:
		par->le = 1;
		par->sig = 0;
		break;
	case AUDIO_ENCODING_ULINEAR_BE:
		par->le = 0;
		par->sig = 0;
		break;
	case AUDIO_ENCODING_SLINEAR:
		par->le = SIO_LE_NATIVE;
		par->sig = 1;
		break;
	case AUDIO_ENCODING_ULINEAR:
		par->le = SIO_LE_NATIVE;
		par->sig = 0;
		break;
	default:
		DPRINTF("sio_sun_infotoenc: unsupported encoding\n");
a96 22
 * convert sio_par encoding to sun encoding
 */
static void
sio_sun_enctoinfo(struct sio_sun_hdl *hdl,
    unsigned int *renc, struct sio_par *par)
{
	if (par->le == ~0U && par->sig == ~0U) {
		*renc = ~0U;
	} else if (par->le == ~0U || par->sig == ~0U) {
		*renc = AUDIO_ENCODING_SLINEAR;
	} else if (par->le && par->sig) {
		*renc = AUDIO_ENCODING_SLINEAR_LE;
	} else if (!par->le && par->sig) {
		*renc = AUDIO_ENCODING_SLINEAR_BE;
	} else if (par->le && !par->sig) {
		*renc = AUDIO_ENCODING_ULINEAR_LE;
	} else {
		*renc = AUDIO_ENCODING_ULINEAR_BE;
	}
}

/*
d101 1
a101 1
sio_sun_tryinfo(struct sio_sun_hdl *hdl, struct sio_enc *enc,
d104 1
a104 2
	struct audio_info aui;
	struct audio_prinfo *pr;
d106 9
a114 14
	pr = (hdl->sio.mode & SIO_PLAY) ? &aui.play : &aui.record;

	AUDIO_INITINFO(&aui);
	if (enc) {
		if (enc->le && enc->sig) {
			pr->encoding = AUDIO_ENCODING_SLINEAR_LE;
		} else if (!enc->le && enc->sig) {
			pr->encoding = AUDIO_ENCODING_SLINEAR_BE;
		} else if (enc->le && !enc->sig) {
			pr->encoding = AUDIO_ENCODING_ULINEAR_LE;
		} else {
			pr->encoding = AUDIO_ENCODING_ULINEAR_BE;
		}
		pr->precision = enc->bits;
d117 1
a117 3
		pr->sample_rate = rate;
	if ((hdl->sio.mode & (SIO_PLAY | SIO_REC)) == (SIO_PLAY | SIO_REC))
		aui.record = aui.play;
d119 1
a119 1
		aui.play.channels = pchan;
d121 2
a122 6
		aui.record.channels = rchan;
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
		if (errno == EINVAL)
			return 0;
		DPERROR("sio_sun_tryinfo: setinfo");
		hdl->sio.eof = 1;
d124 1
a124 4
	}
	if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
		DPERROR("sio_sun_tryinfo: getinfo");
		hdl->sio.eof = 1;
d126 1
a126 2
	}
	if (pchan && aui.play.channels != pchan)
d128 1
a128 1
	if (rchan && aui.record.channels != rchan)
d130 6
a135 3
	if (rate) {
		if ((hdl->sio.mode & SIO_PLAY) &&
		    (aui.play.sample_rate != rate))
d137 3
a139 2
		if ((hdl->sio.mode & SIO_REC) &&
		    (aui.record.sample_rate != rate))
a150 2
#define NCHANS (sizeof(chans) / sizeof(chans[0]))
#define NRATES (sizeof(rates) / sizeof(rates[0]))
d158 3
d162 2
a163 3
	struct sio_par savepar;
	struct audio_encoding ae;
	unsigned int nenc = 0, nconf = 0;
d167 3
a169 1
	if (!sio_sun_getpar(&hdl->sio, &savepar))
d171 1
d174 1
a174 1
	 * fill encoding list
d176 5
a180 6
	for (ae.index = 0; nenc < SIO_NENC; ae.index++) {
		if (ioctl(hdl->fd, AUDIO_GETENC, &ae) < 0) {
			if (errno == EINVAL)
				break;
			DPERROR("sio_sun_getcap: getenc");
			hdl->sio.eof = 1;
d182 7
a189 29
		if (ae.flags & AUDIO_ENCODINGFLAG_EMULATED)
			continue;
		if (ae.encoding == AUDIO_ENCODING_SLINEAR_LE) {
			cap->enc[nenc].le = 1;
			cap->enc[nenc].sig = 1;
		} else if (ae.encoding == AUDIO_ENCODING_SLINEAR_BE) {
			cap->enc[nenc].le = 0;
			cap->enc[nenc].sig = 1;
		} else if (ae.encoding == AUDIO_ENCODING_ULINEAR_LE) {
			cap->enc[nenc].le = 1;
			cap->enc[nenc].sig = 0;
		} else if (ae.encoding == AUDIO_ENCODING_ULINEAR_BE) {
			cap->enc[nenc].le = 0;
			cap->enc[nenc].sig = 0;
		} else if (ae.encoding == AUDIO_ENCODING_SLINEAR) {
			cap->enc[nenc].le = SIO_LE_NATIVE;
			cap->enc[nenc].sig = 1;
		} else if (ae.encoding == AUDIO_ENCODING_ULINEAR) {
			cap->enc[nenc].le = SIO_LE_NATIVE;
			cap->enc[nenc].sig = 0;
		} else {
			/* unsipported encoding */
			continue;
		}
		cap->enc[nenc].bits = ae.precision;
		cap->enc[nenc].bps = ae.bps;
		cap->enc[nenc].msb = ae.msb;
		enc_map |= (1 << nenc);
		nenc++;
d200 7
a206 3
		memcpy(&cap->pchan, chans, NCHANS * sizeof(unsigned int));
		for (i = 0; i < NCHANS; i++) {
			if (sio_sun_tryinfo(hdl, NULL, chans[i], 0, 0))
d208 1
d212 7
a218 3
		memcpy(&cap->rchan, chans, NCHANS * sizeof(unsigned int));
		for (i = 0; i < NCHANS; i++) {
			if (sio_sun_tryinfo(hdl, NULL, 0, chans[i], 0))
d220 1
d231 1
a231 2
	memcpy(&cap->rate, rates, NRATES * sizeof(unsigned int));
	for (j = 0; j < nenc; j++) {
d233 6
a238 2
		for (i = 0; i < NRATES; i++) {
			if (sio_sun_tryinfo(hdl, &cap->enc[j], 0, 0, rates[i]))
d240 1
d259 4
a262 1
	if (!sio_sun_setpar(&hdl->sio, &savepar))
d264 1
a265 2
#undef NCHANS
#undef NRATES
a313 1
	struct audio_info aui;
a314 1
	struct sio_par par;
d327 4
a330 8
	AUDIO_INITINFO(&aui);
	if (mode & SIO_PLAY)
		aui.play.pause = 1;
	if (mode & SIO_REC)
		aui.record.pause = 1;
	if (ioctl(fd, AUDIO_SETINFO, &aui) < 0) {
		DPERROR("sio_open_sun: setinfo");
		goto bad_free;
d333 1
a333 16

	/*
	 * Default parameters may not be compatible with libsndio (eg. mulaw
	 * encodings, different playback and recording parameters, etc...), so
	 * set parameters to a random value. If the requested parameters are
	 * not supported by the device, then sio_setpar() will pick supported
	 * ones.
	 */
	sio_initpar(&par);
	par.rate = 48000;
	par.le = SIO_LE_NATIVE;
	par.sig = 1;
	par.bits = 16;
	par.appbufsz = 1200;
	if (!sio_setpar(&hdl->sio, &par))
		goto bad_free;
a334 3
 bad_free:
	free(hdl);
	return NULL;
a367 1
	struct audio_info aui;
d380 1
a380 1
		 * keep the device paused and let sio_sun_write() trigger the
d388 2
a389 5
		AUDIO_INITINFO(&aui);
		if (hdl->sio.mode & SIO_REC)
			aui.record.pause = 0;
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
			DPERROR("sio_sun_start: setinfo");
a392 1
		hdl->filling = 0;
a401 2
	struct audio_info aui;
	int mode;
d403 3
a405 21
	if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
		DPERROR("sio_sun_stop: getinfo");
		hdl->sio.eof = 1;
		return 0;
	}
	mode = aui.mode;

	/*
	 * there's no way to drain the device without blocking, so just
	 * stop it until the kernel driver get fixed
	 */
	AUDIO_INITINFO(&aui);
	aui.mode = 0;
	if (hdl->sio.mode & SIO_PLAY)
		aui.play.pause = 1;
	if (hdl->sio.mode & SIO_REC)
		aui.record.pause = 1;
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
		DPERROR("sio_sun_stop: setinfo1");
		hdl->sio.eof = 1;
		return 0;
d407 2
a408 4
	AUDIO_INITINFO(&aui);
	aui.mode = mode;
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
		DPERROR("sio_sun_stop: setinfo2");
a417 1
#define NRETRIES 8
d419 1
a419 4
	struct audio_info aui;
	unsigned int i, infr, ibpf, onfr, obpf;
	unsigned int bufsz, round;
	unsigned int rate, req_rate, prec, enc;
d421 20
a440 69
	/*
	 * try to set parameters until the device accepts
	 * a common encoding and rate for play and record
	 */
	rate = par->rate;
	prec = par->bits;
	sio_sun_enctoinfo(hdl, &enc, par);
	for (i = 0;; i++) {
		if (i == NRETRIES) {
			DPRINTF("sio_sun_setpar: couldn't set parameters\n");
			hdl->sio.eof = 1;
			return 0;
		}
		AUDIO_INITINFO(&aui);
		if (hdl->sio.mode & SIO_PLAY) {
			aui.play.sample_rate = rate;
			aui.play.precision = prec;
			aui.play.encoding = enc;
			aui.play.channels = par->pchan;
		}
		if (hdl->sio.mode & SIO_REC) {
			aui.record.sample_rate = rate;
			aui.record.precision = prec;
			aui.record.encoding = enc;
			aui.record.channels = par->rchan;
		}
		DPRINTFN(2, "sio_sun_setpar: %i: trying pars = %u/%u/%u\n",
		    i, rate, prec, enc);
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0 &&
		    errno != EINVAL) {
			DPERROR("sio_sun_setpar: setinfo(pars)");
			hdl->sio.eof = 1;
			return 0;
		}
		if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
			DPERROR("sio_sun_setpar: getinfo(pars)");
			hdl->sio.eof = 1;
			return 0;
		}
		enc = (hdl->sio.mode & SIO_REC) ?
		    aui.record.encoding : aui.play.encoding;
		switch (enc) {
		case AUDIO_ENCODING_SLINEAR_LE:
		case AUDIO_ENCODING_SLINEAR_BE:
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
		case AUDIO_ENCODING_SLINEAR:
		case AUDIO_ENCODING_ULINEAR:
			break;
		default:
			DPRINTF("sio_sun_setpar: couldn't find encoding\n");
			hdl->sio.eof = 1;
			return 0;
		}
		if (hdl->sio.mode != (SIO_REC | SIO_PLAY))
			break;
		if (aui.play.sample_rate == aui.record.sample_rate &&
		    aui.play.precision == aui.record.precision &&
		    aui.play.encoding == aui.record.encoding)
			break;
		if (i < NRETRIES / 2) {
			rate = aui.play.sample_rate;
			prec = aui.play.precision;
			enc = aui.play.encoding;
		} else {
			rate = aui.record.sample_rate;
			prec = aui.record.precision;
			enc = aui.record.encoding;
		}
d442 2
a443 37

	/*
	 * If the rate that the hardware is using is different than
	 * the requested rate, scale buffer sizes so they will be the
	 * same time duration as what was requested.  This just gets
	 * the rates to use for scaling, that actual scaling is done
	 * later.
	 */
	rate = (hdl->sio.mode & SIO_REC) ? aui.record.sample_rate :
	    aui.play.sample_rate;
	req_rate = rate;
	if (par->rate && par->rate != ~0U)
		req_rate = par->rate;

	/*
	 * if block size and buffer size are not both set then
	 * set the blocksize to half the buffer size
	 */
	bufsz = par->appbufsz;
	round = par->round;
	if (bufsz != ~0U) {
		bufsz = bufsz * rate / req_rate;
		if (round == ~0U)
			round = (bufsz + 1) / 2;
		else
			round = round * rate / req_rate;
	} else if (round != ~0U) {
		round = round * rate / req_rate;
		bufsz = round * 2;
	} else
		return 1;

	/*
	 * get the play/record frame size in bytes
	 */
	if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
		DPERROR("sio_sun_setpar: GETINFO");
d447 1
a447 55
	ibpf = (hdl->sio.mode & SIO_REC) ?
	    aui.record.channels * aui.record.bps : 1;
	obpf = (hdl->sio.mode & SIO_PLAY) ?
	    aui.play.channels * aui.play.bps : 1;

	DPRINTFN(2, "sio_sun_setpar: bpf = (%u, %u)\n", ibpf, obpf);

	/*
	 * try to set parameters until the device accepts
	 * a common block size for play and record
	 */
	for (i = 0; i < NRETRIES; i++) {
		AUDIO_INITINFO(&aui);
		aui.hiwat = (bufsz + round - 1) / round;
		aui.lowat = aui.hiwat;
		if (hdl->sio.mode & SIO_REC)
			aui.record.block_size = round * ibpf;
		if (hdl->sio.mode & SIO_PLAY)
			aui.play.block_size = round * obpf;
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
			DPERROR("sio_sun_setpar2: SETINFO");
			hdl->sio.eof = 1;
			return 0;
		}
		if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
			DPERROR("sio_sun_setpar2: GETINFO");
			hdl->sio.eof = 1;
			return 0;
		}
		infr = aui.record.block_size / ibpf;
		onfr = aui.play.block_size / obpf;
		DPRINTFN(2, "sio_sun_setpar: %i: round = %u -> (%u, %u)\n",
		    i, round, infr, onfr);

		/*
		 * if half-duplex or both block sizes match, we're done
		 */
		if (hdl->sio.mode != (SIO_REC | SIO_PLAY) || infr == onfr) {
			DPRINTFN(2, "sio_sun_setpar: blocksize ok\n");
			return 1;
		}

		/*
		 * half of the retries, retry with the smaller value,
		 * then with the larger returned value
		 */
		if (i < NRETRIES / 2)
			round = infr < onfr ? infr : onfr;
		else
			round = infr < onfr ? onfr : infr;
	}
	DPRINTFN(2, "sio_sun_setpar: couldn't find a working blocksize\n");
	hdl->sio.eof = 1;
	return 0;
#undef NRETRIES
d454 1
a454 1
	struct audio_info aui;
d456 2
a457 2
	if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
		DPERROR("sio_sun_getpar: getinfo");
d461 10
a470 19
	if (hdl->sio.mode & SIO_PLAY) {
		par->rate = aui.play.sample_rate;
		if (!sio_sun_infotoenc(hdl, &aui.play, par))
			return 0;
	} else if (hdl->sio.mode & SIO_REC) {
		par->rate = aui.record.sample_rate;
		if (!sio_sun_infotoenc(hdl, &aui.record, par))
			return 0;
	} else
		return 0;
	par->pchan = (hdl->sio.mode & SIO_PLAY) ?
	    aui.play.channels : 0;
	par->rchan = (hdl->sio.mode & SIO_REC) ?
	    aui.record.channels : 0;
	par->round = (hdl->sio.mode & SIO_REC) ?
	    aui.record.block_size / (par->bps * par->rchan) :
	    aui.play.block_size / (par->bps * par->pchan);
	par->appbufsz = aui.hiwat * par->round;
	par->bufsz = par->appbufsz;
a498 32
sio_sun_autostart(struct sio_sun_hdl *hdl)
{
	struct audio_info aui;
	struct pollfd pfd;

	pfd.fd = hdl->fd;
	pfd.events = POLLOUT;
	while (poll(&pfd, 1, 0) < 0) {
		if (errno == EINTR)
			continue;
		DPERROR("sio_sun_autostart: poll");
		hdl->sio.eof = 1;
		return 0;
	}
	if (!(pfd.revents & POLLOUT)) {
		hdl->filling = 0;
		AUDIO_INITINFO(&aui);
		if (hdl->sio.mode & SIO_PLAY)
			aui.play.pause = 0;
		if (hdl->sio.mode & SIO_REC)
			aui.record.pause = 0;
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
			DPERROR("sio_sun_autostart: setinfo");
			hdl->sio.eof = 1;
			return 0;
		}
		_sio_onmove_cb(&hdl->sio, 0);
	}
	return 1;
}

static size_t
a514 4
	if (hdl->filling) {
		if (!sio_sun_autostart(hdl))
			return 0;
	}
d531 10
d552 2
a553 1
	if (!hdl->sio.started)
a610 3

	if (hdl->filling)
		revents |= POLLOUT; /* XXX: is this necessary ? */
@


1.24
log
@Expose internal functions necessary to open audio devices and midi
ports using existing file descriptors.
@
text
@d567 2
a568 1
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0 && errno != EINVAL) {
d589 1
a589 1
			DPRINTF("sio_sun_setpar: couldn't set linear encoding\n");
d680 1
a680 1
		DPRINTFN(2, "sio_sun_setpar: %i: trying round = %u -> (%u, %u)\n",
d810 1
a810 1
 		return 0;
d855 1
a855 1
		hdl->odelta += delta;	
@


1.23
log
@remove unneeded prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.22 2015/11/22 12:01:23 ratchov Exp $	*/
d331 1
a331 1
static int
d339 3
d374 1
a374 1
static struct sio_hdl *
d381 3
@


1.22
log
@Don't remove the type component from the device string before passing
it to the *_open() functions. It's more flexible this way. No behaviour
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.21 2015/11/18 09:35:59 ratchov Exp $	*/
a60 2
static int sio_sun_getfd(const char *, unsigned int, int);
static struct sio_hdl *sio_sun_fdopen(int, unsigned int, int);
@


1.21
log
@Split function to initialize the raw device in two parts, one to open
the device node, the other to do the initialization. This will allow
with minimal changes, work to be done in two process sharing the fd.
No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.19 2015/10/02 09:48:22 ratchov Exp $	*/
d336 1
d341 6
a346 1
	switch (*str) {
d348 1
a348 1
		str++;
d351 1
a351 1
		DPRINTF("sio_sun_getfd: %s: '/<devnum>' expected\n", str);
d354 3
a356 3
	str = _sndio_parsenum(str, &devnum, 255);
	if (str == NULL || *str != '\0') {
		DPRINTF("sio_sun_getfd: can't determine device number\n");
@


1.20
log
@don't call AUDIO_SETFD ioctl as it's a no-op
@
text
@d61 2
d333 2
a334 2
struct sio_hdl *
_sio_sun_open(const char *str, unsigned int mode, int nbio)
a335 4
	int fd, flags;
	struct audio_info aui;
	struct sio_sun_hdl *hdl;
	struct sio_par par;
d338 1
d345 2
a346 2
		DPRINTF("_sio_sun_open: %s: '/<devnum>' expected\n", str);
		return NULL;
d350 2
a351 2
		DPRINTF("_sio_sun_open: can't determine device number\n");
		return NULL;
a352 5
	hdl = malloc(sizeof(struct sio_sun_hdl));
	if (hdl == NULL)
		return NULL;
	_sio_create(&hdl->sio, &sio_sun_ops, mode, nbio);

a357 1

d362 1
a362 1
		goto bad_free;
d364 14
d389 1
a389 1
		goto bad_close;
d407 1
a407 1
		goto bad_close;
d409 17
a425 1
 bad_close:
a427 2
 bad_free:
	free(hdl);
@


1.19
log
@Validate that midi and audio device numbers are integers.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.18 2015/10/02 09:45:26 ratchov Exp $	*/
d334 1
a334 1
	int fd, flags, fullduplex;
a382 11
	}
	/*
	 * If both play and record are requested then
	 * set full duplex mode.
	 */
	if (mode == (SIO_PLAY | SIO_REC)) {
		fullduplex = 1;
		if (ioctl(fd, AUDIO_SETFD, &fullduplex) < 0) {
			DPRINTF("sio_open_sun: %s: can't set full-duplex\n", path);
			goto bad_close;
		}
@


1.18
log
@As device path is known, use its size instead of PATH_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.17 2015/10/02 09:40:57 ratchov Exp $	*/
d339 1
d349 5
d359 1
a359 1
	snprintf(path, sizeof(path), DEVPATH_PREFIX "%s", str);
@


1.17
log
@Use macros for audio and midi device paths rather than hardcoded
strings. No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.16 2015/07/28 20:48:49 ratchov Exp $	*/
d36 4
d338 1
a338 1
	char path[PATH_MAX];
@


1.16
log
@Use new AUDIO_GETPOS ioctl instead of AUDIO_GETxOFFS and
AUDIO_xERROR. It returns a snapshot of the counters we need
and avoids inconsistencies.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.15 2015/07/24 08:50:29 ratchov Exp $	*/
d35 1
d349 1
a349 1
	snprintf(path, sizeof(path), "/dev/audio%s", str);
@


1.15
log
@Fix arithmetic mistake causing errors when there are more xruns on the
record side than on the play side. This almost never happens are record
buffer are much larger than play buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.14 2015/02/16 06:04:06 ratchov Exp $	*/
d807 2
a808 2
	struct audio_offset ao;
	int xrun, dierr = 0, doerr = 0, offset, delta;
d813 5
d819 6
a824 9
		if (ioctl(hdl->fd, AUDIO_GETOOFFS, &ao) < 0) {
			DPERROR("sio_sun_revents: GETOOFFS");
			hdl->sio.eof = 1;
			return POLLHUP;
		}
		delta = (ao.samples - hdl->obytes) / hdl->obpf;
		hdl->obytes = ao.samples;
		hdl->odelta += delta;
		if (!(hdl->sio.mode & SIO_REC))
d826 1
a826 18
	}
	if (hdl->sio.mode & SIO_REC) {
		if (ioctl(hdl->fd, AUDIO_GETIOFFS, &ao) < 0) {
			DPERROR("sio_sun_revents: GETIOFFS");
			hdl->sio.eof = 1;
			return POLLHUP;
		}
		delta = (ao.samples - hdl->ibytes) / hdl->ibpf;
		hdl->ibytes = ao.samples;
		hdl->idelta += delta;
		if (!(hdl->sio.mode & SIO_PLAY))
			hdl->odelta += delta;
	}
	if (hdl->sio.mode & SIO_PLAY) {
		if (ioctl(hdl->fd, AUDIO_PERROR, &xrun) < 0) {
			DPERROR("sio_sun_revents: PERROR");
			hdl->sio.eof = 1;
			return POLLHUP;
a827 4
		doerr = xrun - hdl->oerr;
		hdl->oerr = xrun;
		if (!(hdl->sio.mode & SIO_REC))
			dierr = doerr;
d832 8
a839 4
		if (ioctl(hdl->fd, AUDIO_RERROR, &xrun) < 0) {
			DPERROR("sio_sun_revents: RERROR");
			hdl->sio.eof = 1;
			return POLLHUP;
a840 4
		dierr = xrun - hdl->ierr;
		hdl->ierr = xrun;
		if (!(hdl->sio.mode & SIO_PLAY))
			doerr = dierr;
d846 1
a846 1
	 * GET{I,O}OFFS report positions including xruns,
@


1.14
log
@Remove backward compat bits to support for ':' character in sndio
device names. Remove wrong comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.13 2014/11/21 09:07:17 ratchov Exp $	*/
d878 1
a878 1
		hdl->odelta -= offset;
@


1.13
log
@Initialize the xrun attribute to SIO_IGNORE in sio_sun_getpar(). Found
by stu@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.12 2014/08/15 03:51:40 guenther Exp $	*/
a16 11
/*
 * TODO:
 *
 * remove filling code from sio_sun_write() and create sio_sun_fill()
 *
 * allow block size to be set
 *
 * call hdl->cb_pos() from sio_sun_read() and sio_sun_write(), or better:
 * implement generic blocking sio_read() and sio_write() with poll(2)
 * and use non-blocking sio_ops only
 */
a336 1
	case ':': /* XXX: for backward compat */
@


1.12
log
@Use O_CLOEXEC wherever we open a file and then call fcntl(F_SETFD, FD_CLOEXEC)
on it, simplifying error checking, reducing system calls, and improving
thread-safety for libraries.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.11 2014/03/05 20:40:49 ratchov Exp $	*/
d716 1
@


1.11
log
@- use relative read/write positions to keep track of buffer
  usage as seen by the caller
- refresh current position before reading/writing data, to keep the
  current position always consistent with read & write pointers
- fix confusion between processed samples by the hardware (as reported
  by GET{I,O}OFFS) and samples played as reported by GETINFO(). Fixes
  incorrect delta propagated after xruns in play-only and rec-only
  modes
- don't wait for POLLIN or POLLOUT to be set to refresh ring pointers,
  as they may not be set in certain cases. Fixes sndiod crash after
  few days of continuous playback.
- save current parameters instead of calling getpar() too often
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d366 1
a366 1
	while ((fd = open(path, flags | O_NONBLOCK)) < 0) {
a370 4
	}
	if (fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {
		DPERROR("FD_CLOEXEC");
		goto bad_close;
@


1.10
log
@Be less verbose when SNDIO_DEBUG=1 is set.
@
text
@a438 1
	struct sio_par par;
d442 2
a443 4
	if (!sio_getpar(&hdl->sio, &par))
		return 0;
	hdl->obpf = par.pchan * par.bps;
	hdl->ibpf = par.rchan * par.bps;
d828 1
a828 1
	if ((revents & POLLOUT) && (hdl->sio.mode & SIO_PLAY)) {
d840 1
a840 1
	if ((revents & POLLIN) && (hdl->sio.mode & SIO_REC)) {
d878 8
d889 1
a889 2
		hdl->idelta -= doerr;
		hdl->odelta -= doerr;
d893 1
a893 2
		hdl->idelta -= dierr;
		hdl->odelta -= dierr;
@


1.9
log
@Prefix by '_' symbols that are not part of the API.

ok deraadt, guenther
@
text
@d553 1
a553 1
		DPRINTF("sio_sun_setpar: %i: trying pars = %u/%u/%u\n",
d641 1
a641 1
	DPRINTF("sio_sun_setpar: bpf = (%u, %u)\n", ibpf, obpf);
d667 1
a667 1
		DPRINTF("sio_sun_setpar: %i: trying round = %u -> (%u, %u)\n",
d674 1
a674 1
			DPRINTF("sio_sun_setpar: blocksize ok\n");
d687 1
a687 1
	DPRINTF("sio_sun_setpar: couldn't find a working blocksize\n");
d866 1
a866 1
			DPRINTF("play xrun %d\n", doerr);
d879 1
a879 1
			DPRINTF("rec xrun %d\n", dierr);
d886 1
a886 1
		DPRINTF("will drop %d and pause %d\n", offset, doerr);
d891 1
a891 1
		DPRINTF("will insert %d and pause %d\n", -offset, dierr);
@


1.8
log
@Move underrun/overrun recovery code from the sun-api back-end to
the the generic code, so it can be used by other back-ends as well.
No behavior change (hopefully).
@
text
@d338 1
a338 1
sio_sun_open(const char *str, unsigned int mode, int nbio)
d352 1
a352 1
		DPRINTF("sio_sun_open: %s: '/<devnum>' expected\n", str);
d358 1
a358 1
	sio_create(&hdl->sio, &sio_sun_ops, mode, nbio);
d473 1
a473 1
		sio_onmove_cb(&hdl->sio, 0);
d776 1
a776 1
		sio_onmove_cb(&hdl->sio, 0);
d896 1
a896 1
		sio_onmove_cb(&hdl->sio, delta);
@


1.7
log
@Don't read the xrun counter before the offset in the audio ring,
otherwise we'd open a tiny time window during which a xrun may occur
in turn making the sio_onmove() clock wrong during one tick.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.6 2012/04/11 06:05:43 ratchov Exp $	*/
a52 1
	int offset;			/* frames play is ahead of record */
a53 1
	int mix_fd, mix_index;		/* /dev/mixerN stuff */
a450 1
	hdl->offset = 0;
a725 34
/*
 * drop recorded samples to compensate xruns
 */
static int
sio_sun_rdrop(struct sio_sun_hdl *hdl)
{
#define DROP_NMAX 0x1000
	static char dropbuf[DROP_NMAX];
	ssize_t n, todo;

	while (hdl->offset > 0) {
		todo = hdl->offset * hdl->ibpf;
		if (todo > DROP_NMAX)
			todo = DROP_NMAX - DROP_NMAX % hdl->ibpf;
		while ((n = read(hdl->fd, dropbuf, todo)) < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				DPERROR("sio_sun_rdrop: read");
				hdl->sio.eof = 1;
			}
			return 0;
		}
		if (n == 0) {
			DPRINTF("sio_sun_rdrop: eof\n");
			hdl->sio.eof = 1;
			return 0;
		}
		hdl->offset -= (int)n / (int)hdl->ibpf;
		DPRINTF("sio_sun_rdrop: dropped %ld/%ld bytes\n", n, todo);
	}
	return 1;
}

a731 2
	if (!sio_sun_rdrop(hdl))
		return 0;
a780 31
/*
 * insert silence to play to compensate xruns
 */
static int
sio_sun_wsil(struct sio_sun_hdl *hdl)
{
#define ZERO_NMAX 0x1000
	static char zero[ZERO_NMAX];
	ssize_t n, todo;

	while (hdl->offset < 0) {
		todo = (int)-hdl->offset * (int)hdl->obpf;
		if (todo > ZERO_NMAX)
			todo = ZERO_NMAX - ZERO_NMAX % hdl->obpf;
		while ((n = write(hdl->fd, zero, todo)) < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				DPERROR("sio_sun_wsil: write");
				hdl->sio.eof = 1;
				return 0;
			}
			return 0;
		}
		hdl->offset += (int)n / (int)hdl->obpf;
		DPRINTF("sio_sun_wsil: inserted %ld/%ld bytes\n", n, todo);
	}
	return 1;
}


a787 2
	if (!sio_sun_wsil(hdl))
		return 0;
d826 1
a826 1
	int xrun, dmove, dierr = 0, doerr = 0, delta;
d865 2
d878 14
a892 4
	hdl->offset += doerr - dierr;
	dmove = dierr > doerr ? dierr : doerr;
	hdl->idelta -= dmove;
	hdl->odelta -= dmove;
a900 5
	/*
	 * drop recorded samples or insert silence to play
	 * right now to adjust revents, and avoid busy loops
	 * programs
	 */
d902 1
a902 5
		revents |= POLLOUT;
	if ((hdl->sio.mode & SIO_PLAY) && !sio_sun_wsil(hdl))
		revents &= ~POLLOUT;
	if ((hdl->sio.mode & SIO_REC) && !sio_sun_rdrop(hdl))
		revents &= ~POLLIN;
@


1.6
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.5 2012/02/24 06:19:00 guenther Exp $	*/
d903 24
a953 24
	if ((revents & POLLOUT) && (hdl->sio.mode & SIO_PLAY)) {
		if (ioctl(hdl->fd, AUDIO_GETOOFFS, &ao) < 0) {
			DPERROR("sio_sun_revents: GETOOFFS");
			hdl->sio.eof = 1;
			return POLLHUP;
		}
		delta = (ao.samples - hdl->obytes) / hdl->obpf;
		hdl->obytes = ao.samples;
		hdl->odelta += delta;
		if (!(hdl->sio.mode & SIO_REC))
			hdl->idelta += delta;
	}
	if ((revents & POLLIN) && (hdl->sio.mode & SIO_REC)) {
		if (ioctl(hdl->fd, AUDIO_GETIOFFS, &ao) < 0) {
			DPERROR("sio_sun_revents: GETIOFFS");
			hdl->sio.eof = 1;
			return POLLHUP;
		}
		delta = (ao.samples - hdl->ibytes) / hdl->ibpf;
		hdl->ibytes = ao.samples;
		hdl->idelta += delta;
		if (!(hdl->sio.mode & SIO_PLAY))
			hdl->odelta += delta;
	}
@


1.5
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.4 2011/11/15 08:05:22 ratchov Exp $	*/
d50 3
a52 3
	unsigned ibpf, obpf;		/* bytes per frame */
	unsigned ibytes, obytes;	/* bytes the hw transferred */
	unsigned ierr, oerr;		/* frames the hw dropped */
d90 2
a91 1
sio_sun_infotoenc(struct sio_sun_hdl *hdl, struct audio_prinfo *ai, struct sio_par *par)
d133 2
a134 1
sio_sun_enctoinfo(struct sio_sun_hdl *hdl, unsigned *renc, struct sio_par *par)
d157 1
a157 1
    unsigned pchan, unsigned rchan, unsigned rate)
d220 1
a220 1
	static unsigned chans[] = {
d223 1
a223 1
	static unsigned rates[] = {
d230 3
a232 3
	unsigned nenc = 0, nconf = 0;
	unsigned enc_map = 0, rchan_map = 0, pchan_map = 0, rate_map;
	unsigned i, j, conf;
d287 1
a287 1
		memcpy(&cap->pchan, chans, NCHANS * sizeof(unsigned));
d294 1
a294 1
		memcpy(&cap->rchan, chans, NCHANS * sizeof(unsigned));
d308 1
a308 1
	memcpy(&cap->rate, rates, NRATES * sizeof(unsigned));
d340 1
a340 1
sio_sun_open(const char *str, unsigned mode, int nbio)
d526 3
a528 3
	unsigned i, infr, ibpf, onfr, obpf;
	unsigned bufsz, round;
	unsigned rate, req_rate, prec, enc;
@


1.4
log
@Add a "device number" component in sndio(7) device names, allowing a
single aucat instance to handle all audio and MIDI services. Since
this partially breaks compatibility, this is a opportunitiy to fix few
other design mistakes (eg ':' being used by inet6, type name vs api
name confusion, etc..). This leads to the following names:

        type[@@hostname][,unit]/devnum[.option]

The device number is the minor device number for direct hardware
access (ie the 'N' in /dev/audioN). For aucat, this is the occurence
number of the -f (or -M) option.

There's a compatibility hook to keep old names working if only one
aucat server is running.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.3 2011/05/03 20:15:23 ratchov Exp $	*/
d51 1
a51 1
	unsigned ibytes, obytes;	/* bytes the hw transfered */
@


1.3
log
@determine the default device in backend code instead of the common
code. This is simpler as long as not all backends use the same
default.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.2 2011/04/16 10:52:22 ratchov Exp $	*/
d346 9
a354 2
	if (str == NULL) 
		str = "";
@


1.2
log
@Make aucat audio and midi backends share the same code to communicate
with the server. As we're at it use the same protocol for midi and
audio. Now, both audio and midi code use the same SNDIO_DEBUG environment
variable to turn on/off DPRINTF's.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_sun.c,v 1.1 2011/04/08 11:18:07 ratchov Exp $	*/
d346 2
@


1.1
log
@Clean up function naming: use sio_<backend>_ prefix for private
audio-related functions and put them in files named sio_<backend>.c
No behaviour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
@

