head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.8
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.20
date	2016.01.09.08.27.24;	author ratchov;	state Exp;
branches;
next	1.19;
commitid	ScnbaRlQejqjUMct;

1.19
date	2015.11.22.12.01.23;	author ratchov;	state Exp;
branches;
next	1.18;
commitid	qJB6f577aQuApYmn;

1.18
date	2014.03.07.10.17.18;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.05.20.40.49;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2013.12.20.08.51.28;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.13.22.38.22;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.23.06.40.26;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2012.11.02.10.24.58;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2012.10.27.11.56.04;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.02.15.57.06;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.15.08.05.22;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2011.10.17.21.09.11;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.03.18.09.25;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.02.22.32.29;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.18.23.57.35;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.16.11.51.47;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.16.11.24.18;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.16.10.52.22;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.08.11.18.07;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Make code fit in 80 columns, remove trailing spaces & tabs.
@
text
@/*	$OpenBSD: sio_aucat.c,v 1.18 2014/03/07 10:17:18 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>

#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "aucat.h"
#include "debug.h"
#include "sio_priv.h"

struct sio_aucat_hdl {
	struct sio_hdl sio;
	struct aucat aucat;
	unsigned int rbpf, wbpf;	/* read and write bytes-per-frame */
	int events;			/* events the user requested */
	unsigned int curvol, reqvol;	/* current and requested volume */
	int delta;			/* some of received deltas */
#define PSTATE_INIT	0
#define PSTATE_RUN	1
	int pstate;
	size_t round;	       		/* write block size */
	size_t walign;			/* align write packets size to this */
};

static void sio_aucat_close(struct sio_hdl *);
static int sio_aucat_start(struct sio_hdl *);
static int sio_aucat_stop(struct sio_hdl *);
static int sio_aucat_setpar(struct sio_hdl *, struct sio_par *);
static int sio_aucat_getpar(struct sio_hdl *, struct sio_par *);
static int sio_aucat_getcap(struct sio_hdl *, struct sio_cap *);
static size_t sio_aucat_read(struct sio_hdl *, void *, size_t);
static size_t sio_aucat_write(struct sio_hdl *, const void *, size_t);
static int sio_aucat_nfds(struct sio_hdl *);
static int sio_aucat_pollfd(struct sio_hdl *, struct pollfd *, int);
static int sio_aucat_revents(struct sio_hdl *, struct pollfd *);
static int sio_aucat_setvol(struct sio_hdl *, unsigned int);
static void sio_aucat_getvol(struct sio_hdl *);

static struct sio_ops sio_aucat_ops = {
	sio_aucat_close,
	sio_aucat_setpar,
	sio_aucat_getpar,
	sio_aucat_getcap,
	sio_aucat_write,
	sio_aucat_read,
	sio_aucat_start,
	sio_aucat_stop,
	sio_aucat_nfds,
	sio_aucat_pollfd,
	sio_aucat_revents,
	sio_aucat_setvol,
	sio_aucat_getvol
};

/*
 * execute the next message, return 0 if blocked
 */
static int
sio_aucat_runmsg(struct sio_aucat_hdl *hdl)
{
	int delta;
	unsigned int size, ctl;

	if (!_aucat_rmsg(&hdl->aucat, &hdl->sio.eof))
		return 0;
	switch (ntohl(hdl->aucat.rmsg.cmd)) {
	case AMSG_DATA:
		size = ntohl(hdl->aucat.rmsg.u.data.size);
		if (size == 0 || size % hdl->rbpf) {
			DPRINTF("sio_aucat_runmsg: bad data message\n");
			hdl->sio.eof = 1;
			return 0;
		}
		DPRINTFN(3, "aucat: data(%d)\n", size);
		return 1;
	case AMSG_FLOWCTL:
		delta = ntohl(hdl->aucat.rmsg.u.ts.delta);
		hdl->aucat.maxwrite += delta * (int)hdl->wbpf;
		DPRINTFN(3, "aucat: flowctl(%d), maxwrite = %d\n",
		    delta, hdl->aucat.maxwrite);
		break;
	case AMSG_MOVE:
		delta = ntohl(hdl->aucat.rmsg.u.ts.delta);
		hdl->delta += delta;
		DPRINTFN(3, "aucat: move(%d), delta = %d, maxwrite = %d\n",
		    delta, hdl->delta, hdl->aucat.maxwrite);
		if (hdl->delta >= 0) {
			_sio_onmove_cb(&hdl->sio, hdl->delta);
			hdl->delta = 0;
		}
		break;
	case AMSG_SETVOL:
		ctl = ntohl(hdl->aucat.rmsg.u.vol.ctl);
		hdl->curvol = hdl->reqvol = ctl;
		DPRINTFN(3, "aucat: setvol(%d)\n", ctl);
		_sio_onvol_cb(&hdl->sio, ctl);
		break;
	case AMSG_STOP:
		DPRINTFN(3, "aucat: stop()\n");
		hdl->pstate = PSTATE_INIT;
		break;
	default:
		DPRINTF("sio_aucat_runmsg: unhandled message %u\n",
		    hdl->aucat.rmsg.cmd);
		hdl->sio.eof = 1;
		return 0;
	}
	hdl->aucat.rstate = RSTATE_MSG;
	hdl->aucat.rtodo = sizeof(struct amsg);
	return 1;
}

static int
sio_aucat_buildmsg(struct sio_aucat_hdl *hdl)
{
	if (hdl->curvol != hdl->reqvol) {
		hdl->aucat.wstate = WSTATE_MSG;
		hdl->aucat.wtodo = sizeof(struct amsg);
		hdl->aucat.wmsg.cmd = htonl(AMSG_SETVOL);
		hdl->aucat.wmsg.u.vol.ctl = htonl(hdl->reqvol);
		hdl->curvol = hdl->reqvol;
		return _aucat_wmsg(&hdl->aucat, &hdl->sio.eof);
	}
	return 0;
}

struct sio_hdl *
_sio_aucat_open(const char *str, unsigned int mode, int nbio)
{
	struct sio_aucat_hdl *hdl;

	hdl = malloc(sizeof(struct sio_aucat_hdl));
	if (hdl == NULL)
		return NULL;
	if (!_aucat_open(&hdl->aucat, str, mode)) {
		free(hdl);
		return NULL;
	}
	_sio_create(&hdl->sio, &sio_aucat_ops, mode, nbio);
	hdl->curvol = SIO_MAXVOL;
	hdl->reqvol = SIO_MAXVOL;
	hdl->pstate = PSTATE_INIT;
	hdl->round = 0xdeadbeef;
	hdl->walign = 0xdeadbeef;
	return (struct sio_hdl *)hdl;
}

static void
sio_aucat_close(struct sio_hdl *sh)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;

	if (!hdl->sio.eof && hdl->sio.started)
		(void)sio_aucat_stop(&hdl->sio);
	_aucat_close(&hdl->aucat, hdl->sio.eof);
	free(hdl);
}

static int
sio_aucat_start(struct sio_hdl *sh)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;

	hdl->wbpf = hdl->sio.par.bps * hdl->sio.par.pchan;
	hdl->rbpf = hdl->sio.par.bps * hdl->sio.par.rchan;
	hdl->aucat.maxwrite = 0;
	hdl->round = hdl->sio.par.round;
	hdl->delta = 0;
	DPRINTFN(2, "aucat: start, maxwrite = %d\n", hdl->aucat.maxwrite);

	AMSG_INIT(&hdl->aucat.wmsg);
	hdl->aucat.wmsg.cmd = htonl(AMSG_START);
	hdl->aucat.wtodo = sizeof(struct amsg);
	if (!_aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
		return 0;
	hdl->aucat.rstate = RSTATE_MSG;
	hdl->aucat.rtodo = sizeof(struct amsg);
	if (!_aucat_setfl(&hdl->aucat, 1, &hdl->sio.eof))
		return 0;
	hdl->walign = hdl->round * hdl->wbpf;
	hdl->pstate = PSTATE_RUN;
	return 1;
}

static int
sio_aucat_stop(struct sio_hdl *sh)
{
#define ZERO_MAX 0x400
	static unsigned char zero[ZERO_MAX];
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;
	unsigned int n, count;

	if (!_aucat_setfl(&hdl->aucat, 0, &hdl->sio.eof))
		return 0;
	/*
	 * complete message or data block in progress
	 */
	if (hdl->aucat.wstate == WSTATE_MSG) {
		if (!_aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
			return 0;
	}
	if (hdl->aucat.wstate == WSTATE_DATA) {
		hdl->aucat.maxwrite = hdl->aucat.wtodo;
		while (hdl->aucat.wstate != WSTATE_IDLE) {
			count = hdl->aucat.wtodo;
			if (count > ZERO_MAX)
				count = ZERO_MAX;
			n = sio_aucat_write(&hdl->sio, zero, count);
			if (n == 0)
				return 0;
		}
	}

	/*
	 * send stop message
	 */
	AMSG_INIT(&hdl->aucat.wmsg);
	hdl->aucat.wmsg.cmd = htonl(AMSG_STOP);
	hdl->aucat.wtodo = sizeof(struct amsg);
	if (!_aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
		return 0;

	/*
	 * wait for the STOP ACK
	 */
	while (hdl->pstate != PSTATE_INIT) {
		switch (hdl->aucat.rstate) {
		case RSTATE_MSG:
			if (!sio_aucat_runmsg(hdl))
				return 0;
			break;
		case RSTATE_DATA:
			if (!sio_aucat_read(&hdl->sio, zero, ZERO_MAX))
				return 0;
			break;
		}
	}
	return 1;
}

static int
sio_aucat_setpar(struct sio_hdl *sh, struct sio_par *par)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;

	AMSG_INIT(&hdl->aucat.wmsg);
	hdl->aucat.wmsg.cmd = htonl(AMSG_SETPAR);
	hdl->aucat.wmsg.u.par.bits = par->bits;
	hdl->aucat.wmsg.u.par.bps = par->bps;
	hdl->aucat.wmsg.u.par.sig = par->sig;
	hdl->aucat.wmsg.u.par.le = par->le;
	hdl->aucat.wmsg.u.par.msb = par->msb;
	hdl->aucat.wmsg.u.par.rate = htonl(par->rate);
	hdl->aucat.wmsg.u.par.appbufsz = htonl(par->appbufsz);
	hdl->aucat.wmsg.u.par.xrun = par->xrun;
	if (hdl->sio.mode & SIO_REC)
		hdl->aucat.wmsg.u.par.rchan = htons(par->rchan);
	if (hdl->sio.mode & SIO_PLAY)
		hdl->aucat.wmsg.u.par.pchan = htons(par->pchan);
	hdl->aucat.wtodo = sizeof(struct amsg);
	if (!_aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
		return 0;
	return 1;
}

static int
sio_aucat_getpar(struct sio_hdl *sh, struct sio_par *par)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;

	AMSG_INIT(&hdl->aucat.wmsg);
	hdl->aucat.wmsg.cmd = htonl(AMSG_GETPAR);
	hdl->aucat.wtodo = sizeof(struct amsg);
	if (!_aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
		return 0;
	hdl->aucat.rtodo = sizeof(struct amsg);
	if (!_aucat_rmsg(&hdl->aucat, &hdl->sio.eof))
		return 0;
	if (ntohl(hdl->aucat.rmsg.cmd) != AMSG_GETPAR) {
		DPRINTF("sio_aucat_getpar: protocol err\n");
		hdl->sio.eof = 1;
		return 0;
	}
	par->bits = hdl->aucat.rmsg.u.par.bits;
	par->bps = hdl->aucat.rmsg.u.par.bps;
	par->sig = hdl->aucat.rmsg.u.par.sig;
	par->le = hdl->aucat.rmsg.u.par.le;
	par->msb = hdl->aucat.rmsg.u.par.msb;
	par->rate = ntohl(hdl->aucat.rmsg.u.par.rate);
	par->bufsz = ntohl(hdl->aucat.rmsg.u.par.bufsz);
	par->appbufsz = ntohl(hdl->aucat.rmsg.u.par.appbufsz);
	par->xrun = hdl->aucat.rmsg.u.par.xrun;
	par->round = ntohl(hdl->aucat.rmsg.u.par.round);
	if (hdl->sio.mode & SIO_PLAY)
		par->pchan = ntohs(hdl->aucat.rmsg.u.par.pchan);
	if (hdl->sio.mode & SIO_REC)
		par->rchan = ntohs(hdl->aucat.rmsg.u.par.rchan);
	return 1;
}

static int
sio_aucat_getcap(struct sio_hdl *sh, struct sio_cap *cap)
{
	unsigned int i, bps, le, sig, chan, rindex, rmult;
	static unsigned int rates[] = { 8000, 11025, 12000 };

	bps = 1;
	sig = le = 0;
	cap->confs[0].enc = 0;
	for (i = 0; i < SIO_NENC; i++) {
		if (bps > 4)
			break;
		cap->confs[0].enc |= 1 << i;
		cap->enc[i].bits = bps == 4 ? 24 : bps * 8;
		cap->enc[i].bps = bps;
		cap->enc[i].sig = sig ^ 1;
		cap->enc[i].le = bps > 1 ? le : SIO_LE_NATIVE;
		cap->enc[i].msb = 1;
		le++;
		if (le > 1 || bps == 1) {
			le = 0;
			sig++;
		}
		if (sig > 1 || (le == 0 && bps > 1)) {
			sig = 0;
			bps++;
		}
	}
	chan = 1;
	cap->confs[0].rchan = 0;
	for (i = 0; i < SIO_NCHAN; i++) {
		if (chan > 16)
			break;
		cap->confs[0].rchan |= 1 << i;
		cap->rchan[i] = chan;
		if (chan >= 12) {
			chan += 4;
		} else if (chan >= 2) {
			chan += 2;
		} else
			chan++;
	}
	chan = 1;
	cap->confs[0].pchan = 0;
	for (i = 0; i < SIO_NCHAN; i++) {
		if (chan > 16)
			break;
		cap->confs[0].pchan |= 1 << i;
		cap->pchan[i] = chan;
		if (chan >= 12) {
			chan += 4;
		} else if (chan >= 2) {
			chan += 2;
		} else
			chan++;
	}
	rindex = 0;
	rmult = 1;
	cap->confs[0].rate = 0;
	for (i = 0; i < SIO_NRATE; i++) {
		if (rmult >= 32)
			break;
		cap->rate[i] = rates[rindex] * rmult;
		cap->confs[0].rate |= 1 << i;
		rindex++;
		if (rindex == sizeof(rates) / sizeof(unsigned int)) {
			rindex = 0;
			rmult *= 2;
		}
	}
	cap->nconf = 1;
	return 1;
}

static size_t
sio_aucat_read(struct sio_hdl *sh, void *buf, size_t len)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;

	while (hdl->aucat.rstate == RSTATE_MSG) {
		if (!sio_aucat_runmsg(hdl))
			return 0;
	}
	return _aucat_rdata(&hdl->aucat, buf, len, &hdl->sio.eof);
}

static size_t
sio_aucat_write(struct sio_hdl *sh, const void *buf, size_t len)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;
	size_t n;

	while (hdl->aucat.wstate == WSTATE_IDLE) {
		if (!sio_aucat_buildmsg(hdl))
			break;
	}
	if (len <= 0 || hdl->aucat.maxwrite <= 0)
		return 0;
	if (len > hdl->aucat.maxwrite)
		len = hdl->aucat.maxwrite;
	if (len > hdl->walign)
		len = hdl->walign;
	n = _aucat_wdata(&hdl->aucat, buf, len, hdl->wbpf, &hdl->sio.eof);
	hdl->aucat.maxwrite -= n;
	hdl->walign -= n;
	if (hdl->walign == 0)
		hdl->walign = hdl->round * hdl->wbpf;
	return n;
}

static int
sio_aucat_nfds(struct sio_hdl *hdl)
{
	return 1;
 }

static int
sio_aucat_pollfd(struct sio_hdl *sh, struct pollfd *pfd, int events)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;

	hdl->events = events;
	if (hdl->aucat.maxwrite <= 0)
		events &= ~POLLOUT;
	return _aucat_pollfd(&hdl->aucat, pfd, events);
}

static int
sio_aucat_revents(struct sio_hdl *sh, struct pollfd *pfd)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;
	int revents = pfd->revents;

	if (revents & POLLIN) {
		while (hdl->aucat.rstate == RSTATE_MSG) {
			if (!sio_aucat_runmsg(hdl))
				break;
		}
		if (hdl->aucat.rstate != RSTATE_DATA)
			revents &= ~POLLIN;
	}
	if (revents & POLLOUT) {
		if (hdl->aucat.maxwrite <= 0)
			revents &= ~POLLOUT;
	}
	if (hdl->sio.eof)
		return POLLHUP;
	DPRINTFN(3, "sio_aucat_revents: %x\n", revents & hdl->events);
	return revents & (hdl->events | POLLHUP);
}

static int
sio_aucat_setvol(struct sio_hdl *sh, unsigned int vol)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;

	hdl->reqvol = vol;
	return 1;
}

static void
sio_aucat_getvol(struct sio_hdl *sh)
{
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;

	_sio_onvol_cb(&hdl->sio, hdl->reqvol);
	return;
}
@


1.19
log
@Don't remove the type component from the device string before passing
it to the *_open() functions. It's more flexible this way. No behaviour
change.
@
text
@d127 2
a128 1
		DPRINTF("sio_aucat_runmsg: unhandled message %u\n", hdl->aucat.rmsg.cmd);
@


1.18
log
@slightly "nicer" debug printfs
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 1
a158 1
	if (!_aucat_open(&hdl->aucat, str, mode, 0)) {
@


1.17
log
@- use relative read/write positions to keep track of buffer
  usage as seen by the caller
- refresh current position before reading/writing data, to keep the
  current position always consistent with read & write pointers
- fix confusion between processed samples by the hardware (as reported
  by GET{I,O}OFFS) and samples played as reported by GETINFO(). Fixes
  incorrect delta propagated after xruns in play-only and rec-only
  modes
- don't wait for POLLIN or POLLOUT to be set to refresh ring pointers,
  as they may not be set in certain cases. Fixes sndiod crash after
  few days of continuous playback.
- save current parameters instead of calling getpar() too often
@
text
@d98 1
d103 1
a103 1
		DPRINTFN(3, "aucat: flowctl = %d, maxwrite = %d\n",
d109 1
a109 1
		DPRINTFN(3, "aucat: move = %d, delta = %d, maxwrite = %d\n",
d119 1
d123 1
@


1.16
log
@Be less verbose when SNDIO_DEBUG=1 is set.
@
text
@a182 1
	struct sio_par par;
d184 2
a185 7
	/*
	 * save bpf
	 */
	if (!sio_getpar(&hdl->sio, &par))
		return 0;
	hdl->wbpf = par.bps * par.pchan;
	hdl->rbpf = par.bps * par.rchan;
d187 1
a187 1
	hdl->round = par.round;
@


1.15
log
@Prefix by '_' symbols that are not part of the API.

ok deraadt, guenther
@
text
@d102 1
a102 1
		DPRINTF("aucat: flowctl = %d, maxwrite = %d\n",
d108 1
a108 1
		DPRINTFN(2, "aucat: move = %d, delta = %d, maxwrite = %d\n",
d195 1
a195 1
	DPRINTF("aucat: start, maxwrite = %d\n", hdl->aucat.maxwrite);
d474 1
a474 1
	DPRINTFN(2, "sio_aucat_revents: %x\n", revents & hdl->events);
@


1.14
log
@Make the client wait for the first flow control message rather than
assuming it can send a full initial data buffer. This requires protocol
version bump (but no library version bump).
@
text
@d88 1
a88 1
	if (!aucat_rmsg(&hdl->aucat, &hdl->sio.eof))
d111 1
a111 1
			sio_onmove_cb(&hdl->sio, hdl->delta);
d118 1
a118 1
		sio_onvol_cb(&hdl->sio, ctl);
d142 1
a142 1
		return aucat_wmsg(&hdl->aucat, &hdl->sio.eof);
d148 1
a148 1
sio_aucat_open(const char *str, unsigned int mode, int nbio)
d155 1
a155 1
	if (!aucat_open(&hdl->aucat, str, mode, 0)) {
d159 1
a159 1
	sio_create(&hdl->sio, &sio_aucat_ops, mode, nbio);
d175 1
a175 1
	aucat_close(&hdl->aucat, hdl->sio.eof);
d200 1
a200 1
	if (!aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
d204 1
a204 1
	if (!aucat_setfl(&hdl->aucat, 1, &hdl->sio.eof))
d219 1
a219 1
	if (!aucat_setfl(&hdl->aucat, 0, &hdl->sio.eof))
d225 1
a225 1
		if (!aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
d246 1
a246 1
	if (!aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
d287 1
a287 1
	if (!aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
d300 1
a300 1
	if (!aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
d303 1
a303 1
	if (!aucat_rmsg(&hdl->aucat, &hdl->sio.eof))
d410 1
a410 1
	return aucat_rdata(&hdl->aucat, buf, len, &hdl->sio.eof);
d429 1
a429 1
	n = aucat_wdata(&hdl->aucat, buf, len, hdl->wbpf, &hdl->sio.eof);
d451 1
a451 1
	return aucat_pollfd(&hdl->aucat, pfd, events);
d492 1
a492 1
	sio_onvol_cb(&hdl->sio, hdl->reqvol);
@


1.13
log
@Use dedicated messages for flow control instead of abusing clock tick
messages and enable flow control for MIDI. Since this requires protocol
version bump, both sndiod and libsndio must be kept up to date to work
together.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.12 2012/10/27 11:56:04 ratchov Exp $	*/
d192 1
a192 1
	hdl->aucat.maxwrite = hdl->wbpf * par.bufsz;
@


1.12
log
@include netinet/in.h to get htons & friends prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.11 2012/09/02 15:57:06 ratchov Exp $	*/
d38 1
a38 2
	unsigned int rbpf, wbpf;		/* read and write bytes-per-frame */
	int maxwrite;			/* latency constraint */
d99 1
a99 1
	case AMSG_POS:
d101 3
a103 8
		hdl->maxwrite += delta * (int)hdl->wbpf;
		DPRINTF("aucat: pos = %d, maxwrite = %d\n",
		    delta, hdl->maxwrite);
		hdl->delta = delta;
		if (hdl->delta >= 0) {
			sio_onmove_cb(&hdl->sio, hdl->delta);
			hdl->delta = 0;
		}
a106 1
		hdl->maxwrite += delta * hdl->wbpf;
d109 1
a109 1
		    delta, hdl->delta, hdl->maxwrite);
d192 1
a192 1
	hdl->maxwrite = hdl->wbpf * par.bufsz;
d195 1
a195 1
	DPRINTF("aucat: start, maxwrite = %d\n", hdl->maxwrite);
d229 1
a229 1
		hdl->maxwrite = hdl->aucat.wtodo;
d423 1
a423 1
	if (len <= 0 || hdl->maxwrite <= 0)
d425 2
a426 2
	if (len > hdl->maxwrite)
		len = hdl->maxwrite;
d430 1
a430 1
	hdl->maxwrite -= n;
d449 1
a449 1
	if (hdl->maxwrite <= 0)
d469 1
a469 1
		if (hdl->maxwrite <= 0)
@


1.11
log
@Be nice with the server and align data packets to audio block boundary
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.10 2012/04/11 06:05:43 ratchov Exp $	*/
d21 1
@


1.10
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.9 2011/11/15 08:05:22 ratchov Exp $	*/
d45 2
d169 2
d199 1
d212 1
d433 2
d437 3
@


1.9
log
@Add a "device number" component in sndio(7) device names, allowing a
single aucat instance to handle all audio and MIDI services. Since
this partially breaks compatibility, this is a opportunitiy to fix few
other design mistakes (eg ':' being used by inet6, type name vs api
name confusion, etc..). This leads to the following names:

        type[@@hostname][,unit]/devnum[.option]

The device number is the minor device number for direct hardware
access (ie the 'N' in /dev/audioN). For aucat, this is the occurence
number of the -f (or -M) option.

There's a compatibility hook to keep old names working if only one
aucat server is running.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.8 2011/10/17 21:09:11 ratchov Exp $	*/
d37 1
a37 1
	unsigned rbpf, wbpf;		/* read and write bytes-per-frame */
d40 1
a40 1
	unsigned curvol, reqvol;	/* current and requested volume */
d58 1
a58 1
static int sio_aucat_setvol(struct sio_hdl *, unsigned);
d84 1
a84 1
	unsigned size, ctl;
d152 1
a152 1
sio_aucat_open(const char *str, unsigned mode, int nbio)
d217 1
a217 1
	unsigned n, count;
d330 2
a331 2
	unsigned i, bps, le, sig, chan, rindex, rmult;
	static unsigned rates[] = { 8000, 11025, 12000 };
d392 1
a392 1
		if (rindex == sizeof(rates) / sizeof(unsigned)) {
d474 1
a474 1
sio_aucat_setvol(struct sio_hdl *sh, unsigned vol)
@


1.8
log
@Remove midicat since aucat can now be used instead of midicat
with almost the same syntax (roughly an extra -M option).
Thru boxes are created with aucat, and corresponding MIDI port
names have the "aucat" prefix instead of "midithru". The old
device name will still work some time for backward compatibility.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.7 2011/06/03 18:09:25 ratchov Exp $	*/
d112 1
a112 1
		DPRINTF("aucat: move = %d, delta = %d, maxwrite = %d\n",
d159 1
a159 1
	if (!aucat_open(&hdl->aucat, str, mode)) {
d469 1
a469 1
	DPRINTF("sio_aucat_revents: %x\n", revents & hdl->events);
@


1.7
log
@don't forget to send the initial clock tick
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.6 2011/05/02 22:32:29 ratchov Exp $	*/
d159 1
a159 1
	if (!aucat_open(&hdl->aucat, str, mode, 1)) {
@


1.6
log
@Add missing byter order conversions in message headers. Fixes the case
when the server and the client are not of the same endianness.
Found by naddy.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.5 2011/04/18 23:57:35 ratchov Exp $	*/
d103 4
@


1.5
log
@slightly cleanup by separating socket-specific code from
protocol specific code. No behaviour change
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.4 2011/04/16 11:51:47 ratchov Exp $	*/
d83 3
d88 1
a88 1
	switch (hdl->aucat.rmsg.cmd) {
d90 2
a91 2
		if (hdl->aucat.rmsg.u.data.size == 0 ||
		    hdl->aucat.rmsg.u.data.size % hdl->rbpf) {
d98 2
a99 1
		hdl->maxwrite += hdl->aucat.rmsg.u.ts.delta * (int)hdl->wbpf;
d101 2
a102 2
		    hdl->aucat.rmsg.u.ts.delta, hdl->maxwrite);
		hdl->delta = hdl->aucat.rmsg.u.ts.delta;
d105 3
a107 2
		hdl->maxwrite += hdl->aucat.rmsg.u.ts.delta * hdl->wbpf;
		hdl->delta += hdl->aucat.rmsg.u.ts.delta;
d109 1
a109 1
		    hdl->aucat.rmsg.u.ts.delta, hdl->delta, hdl->maxwrite);
d116 3
a118 2
		hdl->curvol = hdl->reqvol = hdl->aucat.rmsg.u.vol.ctl;
		sio_onvol_cb(&hdl->sio, hdl->curvol);
d139 2
a140 2
		hdl->aucat.wmsg.cmd = AMSG_SETVOL;
		hdl->aucat.wmsg.u.vol.ctl = hdl->reqvol;
d195 1
a195 1
	hdl->aucat.wmsg.cmd = AMSG_START;
d240 1
a240 1
	hdl->aucat.wmsg.cmd = AMSG_STOP;
d269 1
a269 1
	hdl->aucat.wmsg.cmd = AMSG_SETPAR;
d275 2
a276 2
	hdl->aucat.wmsg.u.par.rate = par->rate;
	hdl->aucat.wmsg.u.par.appbufsz = par->appbufsz;
d279 1
a279 1
		hdl->aucat.wmsg.u.par.rchan = par->rchan;
d281 1
a281 1
		hdl->aucat.wmsg.u.par.pchan = par->pchan;
d294 1
a294 1
	hdl->aucat.wmsg.cmd = AMSG_GETPAR;
d301 1
a301 1
	if (hdl->aucat.rmsg.cmd != AMSG_GETPAR) {
d311 3
a313 3
	par->rate = hdl->aucat.rmsg.u.par.rate;
	par->bufsz = hdl->aucat.rmsg.u.par.bufsz;
	par->appbufsz = hdl->aucat.rmsg.u.par.appbufsz;
d315 1
a315 1
	par->round = hdl->aucat.rmsg.u.par.round;
d317 1
a317 1
		par->pchan = hdl->aucat.rmsg.u.par.pchan;
d319 1
a319 1
		par->rchan = hdl->aucat.rmsg.u.par.rchan;
@


1.4
log
@for unix domain socket addresses use AUCAT_PATH and MIDICAT_PATH
macros instead of hardcoded strings. No object change
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.3 2011/04/16 11:24:18 ratchov Exp $	*/
d149 1
a149 1
	if (!aucat_open(&hdl->aucat, str, AUCAT_PATH, mode, nbio)) {
@


1.3
log
@Since aucat supports any parameter combination sio_getcap() doesn't
need to query the server for supported parameters. So stop using the
AMSG_GETCAP message, and remove it completely from the aucat protocol.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.2 2011/04/16 10:52:22 ratchov Exp $	*/
d149 1
a149 1
	if (!aucat_open(&hdl->aucat, str, "softaudio", mode, nbio)) {
@


1.2
log
@Make aucat audio and midi backends share the same code to communicate
with the server. As we're at it use the same protocol for midi and
audio. Now, both audio and midi code use the same SNDIO_DEBUG environment
variable to turn on/off DPRINTF's.
@
text
@d1 1
a1 1
/*	$OpenBSD: sio_aucat.c,v 1.1 2011/04/08 11:18:07 ratchov Exp $	*/
a319 1
	struct sio_aucat_hdl *hdl = (struct sio_aucat_hdl *)sh;
a322 13
	AMSG_INIT(&hdl->aucat.wmsg);
	hdl->aucat.wmsg.cmd = AMSG_GETCAP;
	hdl->aucat.wtodo = sizeof(struct amsg);
	if (!aucat_wmsg(&hdl->aucat, &hdl->sio.eof))
		return 0;
	hdl->aucat.rtodo = sizeof(struct amsg);
	if (!aucat_rmsg(&hdl->aucat, &hdl->sio.eof))
		return 0;
	if (hdl->aucat.rmsg.cmd != AMSG_GETCAP) {
		DPRINTF("sio_aucat_getcap: protocol err\n");
		hdl->sio.eof = 1;
		return 0;
	}
@


1.1
log
@Clean up function naming: use sio_<backend>_ prefix for private
audio-related functions and put them in files named sio_<backend>.c
No behaviour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 2
a31 1
#include "amsg.h"
d36 1
a36 7
	int fd;				/* socket */
	struct amsg rmsg, wmsg;		/* temporary messages */
	size_t wtodo, rtodo;		/* bytes to complete the packet */
#define STATE_IDLE	0		/* nothing to do */
#define STATE_MSG	1		/* message being transferred */
#define STATE_DATA	2		/* data being transferred */
	unsigned rstate, wstate;	/* one of above */
d42 3
a77 57
 * read a message, return 0 if blocked
 */
static int
sio_aucat_rmsg(struct sio_aucat_hdl *hdl)
{
	ssize_t n;
	unsigned char *data;

	while (hdl->rtodo > 0) {
		data = (unsigned char *)&hdl->rmsg;
		data += sizeof(struct amsg) - hdl->rtodo;
		while ((n = read(hdl->fd, data, hdl->rtodo)) < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				hdl->sio.eof = 1;
				DPERROR("sio_aucat_rmsg: read");
			}
			return 0;
		}
		if (n == 0) {
			DPRINTF("sio_aucat_rmsg: eof\n");
			hdl->sio.eof = 1;
			return 0;
		}
		hdl->rtodo -= n;
	}
	return 1;
}

/*
 * write a message, return 0 if blocked
 */
static int
sio_aucat_wmsg(struct sio_aucat_hdl *hdl)
{
	ssize_t n;
	unsigned char *data;

	while (hdl->wtodo > 0) {
		data = (unsigned char *)&hdl->wmsg;
		data += sizeof(struct amsg) - hdl->wtodo;
		while ((n = write(hdl->fd, data, hdl->wtodo)) < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				hdl->sio.eof = 1;
				DPERROR("sio_aucat_wmsg: write");
			}
			return 0;
		}
		hdl->wtodo -= n;
	}
	return 1;
}

/*
d83 1
a83 1
	if (!sio_aucat_rmsg(hdl))
d85 1
a85 1
	switch (hdl->rmsg.cmd) {
d87 2
a88 2
		if (hdl->rmsg.u.data.size == 0 ||
		    hdl->rmsg.u.data.size % hdl->rbpf) {
d93 1
a93 3
		hdl->rstate = STATE_DATA;
		hdl->rtodo = hdl->rmsg.u.data.size;
		break;
d95 1
a95 1
		hdl->maxwrite += hdl->rmsg.u.ts.delta * (int)hdl->wbpf;
d97 2
a98 4
		    hdl->rmsg.u.ts.delta, hdl->maxwrite);
		hdl->delta = hdl->rmsg.u.ts.delta;
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
d101 2
a102 2
		hdl->maxwrite += hdl->rmsg.u.ts.delta * hdl->wbpf;
		hdl->delta += hdl->rmsg.u.ts.delta;
d104 1
a104 1
		    hdl->rmsg.u.ts.delta, hdl->delta, hdl->maxwrite);
a108 2
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
d111 1
a111 1
		hdl->curvol = hdl->reqvol = hdl->rmsg.u.vol.ctl;
a112 2
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
d114 2
a115 4
	case AMSG_GETPAR:
	case AMSG_ACK:
		hdl->rstate = STATE_IDLE;
		hdl->rtodo = 0xdeadbeef;
d118 1
a118 1
		DPRINTF("sio_aucat_runmsg: unknown message\n");
d122 2
d127 14
a143 3
	extern char *__progname;
	int s;
	char unit[4], *sep, *opt;
a144 23
	struct sockaddr_un ca;
	socklen_t len = sizeof(struct sockaddr_un);
	uid_t uid;

	sep = strchr(str, '.');
	if (sep == NULL) {
		opt = "default";
		strlcpy(unit, str, sizeof(unit));
	} else {
		opt = sep + 1;
		if (sep - str >= sizeof(unit)) {
			DPRINTF("sio_open_aucat: %s: too long\n", str);
			return NULL;
		}
		strlcpy(unit, str, opt - str);
	}
	DPRINTF("sio_open_aucat: trying %s -> %s.%s\n", str, unit, opt);
	uid = geteuid();
	if (strchr(str, '/') != NULL)
		return NULL;
	snprintf(ca.sun_path, sizeof(ca.sun_path),
	    "/tmp/aucat-%u/softaudio%s", uid, unit);
	ca.sun_family = AF_UNIX;
d149 4
a153 28

	s = socket(AF_UNIX, SOCK_STREAM, 0);
	if (s < 0)
		goto bad_free;
	while (connect(s, (struct sockaddr *)&ca, len) < 0) {
		if (errno == EINTR)
			continue;
		DPERROR("sio_open_aucat: connect");
		/* try shared server */
		snprintf(ca.sun_path, sizeof(ca.sun_path),
		    "/tmp/aucat/softaudio%s", unit);
		while (connect(s, (struct sockaddr *)&ca, len) < 0) {
			if (errno == EINTR)
				continue;
			DPERROR("sio_open_aucat: connect");
			goto bad_connect;
		}
		break;
	}
	if (fcntl(s, F_SETFD, FD_CLOEXEC) < 0) {
		DPERROR("FD_CLOEXEC");
		goto bad_connect;
	}
	hdl->fd = s;
	hdl->rstate = STATE_IDLE;
	hdl->rtodo = 0xdeadbeef;
	hdl->wstate = STATE_IDLE;
	hdl->wtodo = 0xdeadbeef;
d156 1
a156 24

	/*
	 * say hello to server
	 */
	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_HELLO;
	hdl->wmsg.u.hello.version = AMSG_VERSION;
	hdl->wmsg.u.hello.mode = mode;
	strlcpy(hdl->wmsg.u.hello.who, __progname,
	    sizeof(hdl->wmsg.u.hello.who));
	strlcpy(hdl->wmsg.u.hello.opt, opt,
	    sizeof(hdl->wmsg.u.hello.opt));
	hdl->wtodo = sizeof(struct amsg);
	if (!sio_aucat_wmsg(hdl))
		goto bad_connect;
	hdl->rtodo = sizeof(struct amsg);
	if (!sio_aucat_rmsg(hdl)) {
		DPRINTF("sio_open_aucat: mode refused\n");
		goto bad_connect;
	}
	if (hdl->rmsg.cmd != AMSG_ACK) {
		DPRINTF("sio_open_aucat: protocol err\n");
		goto bad_connect;
	}
a157 6
 bad_connect:
	while (close(s) < 0 && errno == EINTR)
		; /* retry */
 bad_free:
	free(hdl);
	return NULL;
a163 1
	char dummy[1];
d167 1
a167 12
	if (!hdl->sio.eof) {
		AMSG_INIT(&hdl->wmsg);
		hdl->wmsg.cmd = AMSG_BYE;
		hdl->wtodo = sizeof(struct amsg);
		if (!sio_aucat_wmsg(hdl))
			goto bad_close;
		while (read(hdl->fd, dummy, 1) < 0 && errno == EINTR)
			; /* nothing */
	}
 bad_close:
	while (close(hdl->fd) < 0 && errno == EINTR)
		; /* nothing */
d188 8
a195 10
	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_START;
	hdl->wtodo = sizeof(struct amsg);
	if (!sio_aucat_wmsg(hdl))
		return 0;
	hdl->rstate = STATE_MSG;
	hdl->rtodo = sizeof(struct amsg);
	if (fcntl(hdl->fd, F_SETFL, O_NONBLOCK) < 0) {
		DPERROR("sio_aucat_start: fcntl(0)");
		hdl->sio.eof = 1;
d197 1
a197 1
	}
d209 1
a209 3
	if (fcntl(hdl->fd, F_SETFL, 0) < 0) {
		DPERROR("sio_aucat_stop: fcntl(0)");
		hdl->sio.eof = 1;
a210 2
	}

d214 2
a215 2
	if (hdl->wstate == STATE_MSG) {
		if (!sio_aucat_wmsg(hdl))
a216 5
		if (hdl->wmsg.cmd == AMSG_DATA) {
			hdl->wstate = STATE_DATA;
			hdl->wtodo = hdl->wmsg.u.data.size;
		} else
			hdl->wstate = STATE_IDLE;
d218 4
a221 4
	if (hdl->wstate == STATE_DATA) {
		hdl->maxwrite = hdl->wtodo;
		while (hdl->wstate != STATE_IDLE) {
			count = hdl->wtodo;
d233 5
a237 9
	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_STOP;
	hdl->wtodo = sizeof(struct amsg);
	if (!sio_aucat_wmsg(hdl))
		return 0;
	if (hdl->rstate == STATE_IDLE) {
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
	}
d242 3
a244 3
	while (hdl->rstate != STATE_IDLE) {
		switch (hdl->rstate) {
		case STATE_MSG:
d248 1
a248 1
		case STATE_DATA:
d262 10
a271 10
	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_SETPAR;
	hdl->wmsg.u.par.bits = par->bits;
	hdl->wmsg.u.par.bps = par->bps;
	hdl->wmsg.u.par.sig = par->sig;
	hdl->wmsg.u.par.le = par->le;
	hdl->wmsg.u.par.msb = par->msb;
	hdl->wmsg.u.par.rate = par->rate;
	hdl->wmsg.u.par.appbufsz = par->appbufsz;
	hdl->wmsg.u.par.xrun = par->xrun;
d273 1
a273 1
		hdl->wmsg.u.par.rchan = par->rchan;
d275 3
a277 3
		hdl->wmsg.u.par.pchan = par->pchan;
	hdl->wtodo = sizeof(struct amsg);
	if (!sio_aucat_wmsg(hdl))
d287 4
a290 4
	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_GETPAR;
	hdl->wtodo = sizeof(struct amsg);
	if (!sio_aucat_wmsg(hdl))
d292 2
a293 2
	hdl->rtodo = sizeof(struct amsg);
	if (!sio_aucat_rmsg(hdl))
d295 1
a295 1
	if (hdl->rmsg.cmd != AMSG_GETPAR) {
d300 10
a309 10
	par->bits = hdl->rmsg.u.par.bits;
	par->bps = hdl->rmsg.u.par.bps;
	par->sig = hdl->rmsg.u.par.sig;
	par->le = hdl->rmsg.u.par.le;
	par->msb = hdl->rmsg.u.par.msb;
	par->rate = hdl->rmsg.u.par.rate;
	par->bufsz = hdl->rmsg.u.par.bufsz;
	par->appbufsz = hdl->rmsg.u.par.appbufsz;
	par->xrun = hdl->rmsg.u.par.xrun;
	par->round = hdl->rmsg.u.par.round;
d311 1
a311 1
		par->pchan = hdl->rmsg.u.par.pchan;
d313 1
a313 1
		par->rchan = hdl->rmsg.u.par.rchan;
d324 4
a327 4
	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_GETCAP;
	hdl->wtodo = sizeof(struct amsg);
	if (!sio_aucat_wmsg(hdl))
d329 2
a330 2
	hdl->rtodo = sizeof(struct amsg);
	if (!sio_aucat_rmsg(hdl))
d332 1
a332 1
	if (hdl->rmsg.cmd != AMSG_GETCAP) {
a408 1
	ssize_t n;
d410 2
a411 9
	while (hdl->rstate != STATE_DATA) {
		switch (hdl->rstate) {
		case STATE_MSG:
			if (!sio_aucat_runmsg(hdl))
				return 0;
			break;
		case STATE_IDLE:
			DPRINTF("sio_aucat_read: unexpected idle state\n");
			hdl->sio.eof = 1;
a412 22
		}
	}
	if (len > hdl->rtodo)
		len = hdl->rtodo;
	while ((n = read(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			hdl->sio.eof = 1;
			DPERROR("sio_aucat_read: read");
		}
		return 0;
	}
	if (n == 0) {
		DPRINTF("sio_aucat_read: eof\n");
		hdl->sio.eof = 1;
		return 0;
	}
	hdl->rtodo -= n;
	if (hdl->rtodo == 0) {
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
d414 1
a414 32
	DPRINTF("aucat: read: n = %zd\n", n);
	return n;
}

static int
sio_aucat_buildmsg(struct sio_aucat_hdl *hdl, size_t len)
{
	unsigned sz;

	if (hdl->curvol != hdl->reqvol) {
		hdl->wstate = STATE_MSG;
		hdl->wtodo = sizeof(struct amsg);
		hdl->wmsg.cmd = AMSG_SETVOL;
		hdl->wmsg.u.vol.ctl = hdl->reqvol;
		hdl->curvol = hdl->reqvol;
		return 1;
	} else if (len > 0 && hdl->maxwrite > 0) {
		sz = len;
		if (sz > AMSG_DATAMAX)
			sz = AMSG_DATAMAX;
		if (sz > hdl->maxwrite)
			sz = hdl->maxwrite;
		sz -= sz % hdl->wbpf;
		if (sz == 0)
			sz = hdl->wbpf;
		hdl->wstate = STATE_MSG;
		hdl->wtodo = sizeof(struct amsg);
		hdl->wmsg.cmd = AMSG_DATA;
		hdl->wmsg.u.data.size = sz;
		return 1;
	}
	return 0;
d421 1
a421 1
	ssize_t n;
d423 2
a424 14
	while (hdl->wstate != STATE_DATA) {
		switch (hdl->wstate) {
		case STATE_IDLE:
			if (!sio_aucat_buildmsg(hdl, len))
				return 0;
			/* PASSTHROUGH */
		case STATE_MSG:
			if (!sio_aucat_wmsg(hdl))
				return 0;
			if (hdl->wmsg.cmd == AMSG_DATA) {
				hdl->wstate = STATE_DATA;
				hdl->wtodo = hdl->wmsg.u.data.size;
			} else
				hdl->wstate = STATE_IDLE;
a425 4
		default:
			DPRINTF("sio_aucat_write: bad state\n");
			abort();
		}
d427 1
a427 1
	if (hdl->maxwrite <= 0)
d431 1
a431 15
	if (len > hdl->wtodo)
		len = hdl->wtodo;
	if (len == 0) {
		DPRINTF("sio_aucat_write: len == 0\n");
		abort();
	}
	while ((n = write(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			hdl->sio.eof = 1;
			DPERROR("sio_aucat_write: write");
		}
		return 0;
	}
a432 6
	DPRINTF("aucat: write: n = %zd, maxwrite = %d\n", n, hdl->maxwrite);
	hdl->wtodo -= n;
	if (hdl->wtodo == 0) {
		hdl->wstate = STATE_IDLE;
		hdl->wtodo = 0xdeadbeef;
	}
d450 1
a450 6
	if (hdl->rstate == STATE_MSG)
		events |= POLLIN;
	pfd->fd = hdl->fd;
	pfd->events = events;
	DPRINTF("aucat: pollfd: %x -> %x\n", hdl->events, pfd->events);
	return 1;
d460 2
a461 3
		while (hdl->rstate == STATE_MSG) {
			if (!sio_aucat_runmsg(hdl)) {
				revents &= ~POLLIN;
a462 1
			}
d464 2
d473 1
a473 1
	DPRINTF("aucat: revents: %x\n", revents & hdl->events);
@

