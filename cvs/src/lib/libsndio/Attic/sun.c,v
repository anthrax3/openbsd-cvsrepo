head	1.43;
access;
symbols
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14;
locks; strict;
comment	@ * @;


1.43
date	2011.04.08.11.18.07;	author ratchov;	state dead;
branches;
next	1.42;

1.42
date	2010.11.06.20.25.42;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.17.08.08.23;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2010.08.06.06.52.17;	author ratchov;	state Exp;
branches;
next	1.39;

1.39
date	2010.07.21.23.00.16;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2010.05.25.06.49.13;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.09.18.24.24;	author jakemsr;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.29.21.09.50;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.25.18.51.05;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.25.18.29.48;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.25.18.25.07;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.24.14.13.34;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.24.06.15.54;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.11.16.53.55;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2010.02.10.23.03.53;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.02.08.19.11;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.03.06.41.19;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.10.11.27.39;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.10.11.19.55;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.10.08.34.12;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.26.15.50.04;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.26.12.38.20;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.25.11.15.56;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.15.13.16.58;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.15.13.10.39;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.15.13.04.52;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.26.22.14.18;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.04.07.54.00;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.10.20.34.44;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.21.16.15.24;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.21.10.03.25;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.17.10.00.50;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.17.07.19.27;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.20.16.31.26;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.20.08.32.03;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.11.19.39.35;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.07.21.01.15;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.30.18.25.43;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.10.28.23.02.54;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.27.00.26.33;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Clean up function naming: use sio_<backend>_ prefix for private
audio-related functions and put them in files named sio_<backend>.c
No behaviour changes.
@
text
@/*	$OpenBSD: sun.c,v 1.42 2010/11/06 20:25:42 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * TODO:
 *
 * remove filling code from sun_write() and create sun_fill()
 *
 * allow block size to be set
 *
 * call hdl->cb_pos() from sun_read() and sun_write(), or better:
 * implement generic blocking sio_read() and sio_write() with poll(2)
 * and use non-blocking sio_ops only
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sndio_priv.h"

struct sun_hdl {
	struct sio_hdl sio;
	int fd;
	int filling;
	unsigned ibpf, obpf;		/* bytes per frame */
	unsigned ibytes, obytes;	/* bytes the hw transfered */
	unsigned ierr, oerr;		/* frames the hw dropped */
	int offset;			/* frames play is ahead of record */
	int idelta, odelta;		/* position reported to client */
	int mix_fd, mix_index;		/* /dev/mixerN stuff */
};

static void sun_close(struct sio_hdl *);
static int sun_start(struct sio_hdl *);
static int sun_stop(struct sio_hdl *);
static int sun_setpar(struct sio_hdl *, struct sio_par *);
static int sun_getpar(struct sio_hdl *, struct sio_par *);
static int sun_getcap(struct sio_hdl *, struct sio_cap *);
static size_t sun_read(struct sio_hdl *, void *, size_t);
static size_t sun_write(struct sio_hdl *, const void *, size_t);
static int sun_pollfd(struct sio_hdl *, struct pollfd *, int);
static int sun_revents(struct sio_hdl *, struct pollfd *);

static struct sio_ops sun_ops = {
	sun_close,
	sun_setpar,
	sun_getpar,
	sun_getcap,
	sun_write,
	sun_read,
	sun_start,
	sun_stop,
	sun_pollfd,
	sun_revents,
	NULL, /* setvol */
	NULL, /* getvol */
};

/*
 * convert sun encoding to sio_par encoding
 */
static int
sun_infotoenc(struct sun_hdl *hdl, struct audio_prinfo *ai, struct sio_par *par)
{
	par->msb = ai->msb;
	par->bits = ai->precision;
	par->bps = ai->bps;
	switch (ai->encoding) {
	case AUDIO_ENCODING_SLINEAR_LE:
		par->le = 1;
		par->sig = 1;
		break;
	case AUDIO_ENCODING_SLINEAR_BE:
		par->le = 0;
		par->sig = 1;
		break;
	case AUDIO_ENCODING_ULINEAR_LE:
		par->le = 1;
		par->sig = 0;
		break;
	case AUDIO_ENCODING_ULINEAR_BE:
		par->le = 0;
		par->sig = 0;
		break;
	case AUDIO_ENCODING_SLINEAR:
		par->le = SIO_LE_NATIVE;
		par->sig = 1;
		break;
	case AUDIO_ENCODING_ULINEAR:
		par->le = SIO_LE_NATIVE;
		par->sig = 0;
		break;
	default:
		DPRINTF("sun_infotoenc: unsupported encoding\n");
		hdl->sio.eof = 1;
		return 0;
	}
	return 1;
}

/*
 * convert sio_par encoding to sun encoding
 */
static void
sun_enctoinfo(struct sun_hdl *hdl, unsigned *renc, struct sio_par *par)
{
	if (par->le == ~0U && par->sig == ~0U) {
		*renc = ~0U;
	} else if (par->le == ~0U || par->sig == ~0U) {
		*renc = AUDIO_ENCODING_SLINEAR;
	} else if (par->le && par->sig) {
		*renc = AUDIO_ENCODING_SLINEAR_LE;
	} else if (!par->le && par->sig) {
		*renc = AUDIO_ENCODING_SLINEAR_BE;
	} else if (par->le && !par->sig) {
		*renc = AUDIO_ENCODING_ULINEAR_LE;
	} else {
		*renc = AUDIO_ENCODING_ULINEAR_BE;
	}
}

/*
 * try to set the device to the given parameters and check that the
 * device can use them; return 1 on success, 0 on failure or error
 */
static int
sun_tryinfo(struct sun_hdl *hdl, struct sio_enc *enc,
    unsigned pchan, unsigned rchan, unsigned rate)
{
	struct audio_info aui;
	struct audio_prinfo *pr;

	pr = (hdl->sio.mode & SIO_PLAY) ? &aui.play : &aui.record;

	AUDIO_INITINFO(&aui);
	if (enc) {
		if (enc->le && enc->sig) {
			pr->encoding = AUDIO_ENCODING_SLINEAR_LE;
		} else if (!enc->le && enc->sig) {
			pr->encoding = AUDIO_ENCODING_SLINEAR_BE;
		} else if (enc->le && !enc->sig) {
			pr->encoding = AUDIO_ENCODING_ULINEAR_LE;
		} else {
			pr->encoding = AUDIO_ENCODING_ULINEAR_BE;
		}
		pr->precision = enc->bits;
	}
	if (rate)
		pr->sample_rate = rate;
	if ((hdl->sio.mode & (SIO_PLAY | SIO_REC)) == (SIO_PLAY | SIO_REC))
		aui.record = aui.play;
	if (pchan && (hdl->sio.mode & SIO_PLAY))
		aui.play.channels = pchan;
	if (rchan && (hdl->sio.mode & SIO_REC))
		aui.record.channels = rchan;
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
		if (errno == EINVAL)
			return 0;
		DPERROR("sun_tryinfo: setinfo");
		hdl->sio.eof = 1;
		return 0;
	}
	if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
		DPERROR("sun_tryinfo: getinfo");
		hdl->sio.eof = 1;
		return 0;
	}
	if (pchan && aui.play.channels != pchan)
		return 0;
	if (rchan && aui.record.channels != rchan)
		return 0;
	if (rate) {
		if ((hdl->sio.mode & SIO_PLAY) &&
		    (aui.play.sample_rate != rate))
			return 0;
		if ((hdl->sio.mode & SIO_REC) &&
		    (aui.record.sample_rate != rate))
			return 0;
	}
	return 1;
}

/*
 * guess device capabilities
 */
static int
sun_getcap(struct sio_hdl *sh, struct sio_cap *cap)
{
#define NCHANS (sizeof(chans) / sizeof(chans[0]))
#define NRATES (sizeof(rates) / sizeof(rates[0]))
	static unsigned chans[] = {
		1, 2, 4, 6, 8, 10, 12
	};
	static unsigned rates[] = {
		8000, 11025, 12000, 16000, 22050, 24000,
		32000, 44100, 48000, 64000, 88200, 96000
	};
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	struct sio_par savepar;
	struct audio_encoding ae;
	unsigned nenc = 0, nconf = 0;
	unsigned enc_map = 0, rchan_map = 0, pchan_map = 0, rate_map;
	unsigned i, j, conf;

	if (!sun_getpar(&hdl->sio, &savepar))
		return 0;

	/*
	 * fill encoding list
	 */
	for (ae.index = 0; nenc < SIO_NENC; ae.index++) {
		if (ioctl(hdl->fd, AUDIO_GETENC, &ae) < 0) {
			if (errno == EINVAL)
				break;
			DPERROR("sun_getcap: getenc");
			hdl->sio.eof = 1;
			return 0;
		}
		if (ae.flags & AUDIO_ENCODINGFLAG_EMULATED)
			continue;
		if (ae.encoding == AUDIO_ENCODING_SLINEAR_LE) {
			cap->enc[nenc].le = 1;
			cap->enc[nenc].sig = 1;
		} else if (ae.encoding == AUDIO_ENCODING_SLINEAR_BE) {
			cap->enc[nenc].le = 0;
			cap->enc[nenc].sig = 1;
		} else if (ae.encoding == AUDIO_ENCODING_ULINEAR_LE) {
			cap->enc[nenc].le = 1;
			cap->enc[nenc].sig = 0;
		} else if (ae.encoding == AUDIO_ENCODING_ULINEAR_BE) {
			cap->enc[nenc].le = 0;
			cap->enc[nenc].sig = 0;
		} else if (ae.encoding == AUDIO_ENCODING_SLINEAR) {
			cap->enc[nenc].le = SIO_LE_NATIVE;
			cap->enc[nenc].sig = 1;
		} else if (ae.encoding == AUDIO_ENCODING_ULINEAR) {
			cap->enc[nenc].le = SIO_LE_NATIVE;
			cap->enc[nenc].sig = 0;
		} else {
			/* unsipported encoding */
			continue;
		}
		cap->enc[nenc].bits = ae.precision;
		cap->enc[nenc].bps = ae.bps;
		cap->enc[nenc].msb = ae.msb;
		enc_map |= (1 << nenc);
		nenc++;
	}

	/*
	 * fill channels
	 *
	 * for now we're lucky: all kernel devices assume that the
	 * number of channels and the encoding are independent so we can
	 * use the current encoding and try various channels.
	 */
	if (hdl->sio.mode & SIO_PLAY) {
		memcpy(&cap->pchan, chans, NCHANS * sizeof(unsigned));
		for (i = 0; i < NCHANS; i++) {
			if (sun_tryinfo(hdl, NULL, chans[i], 0, 0))
				pchan_map |= (1 << i);
		}
	}
	if (hdl->sio.mode & SIO_REC) {
		memcpy(&cap->rchan, chans, NCHANS * sizeof(unsigned));
		for (i = 0; i < NCHANS; i++) {
			if (sun_tryinfo(hdl, NULL, 0, chans[i], 0))
				rchan_map |= (1 << i);
		}
	}

	/*
	 * fill rates
	 *
	 * rates are not independent from other parameters (eg. on
	 * uaudio devices), so certain rates may not be allowed with
	 * certain encodings. We have to check rates for all encodings
	 */
	memcpy(&cap->rate, rates, NRATES * sizeof(unsigned));
	for (j = 0; j < nenc; j++) {
		rate_map = 0;
		for (i = 0; i < NRATES; i++) {
			if (sun_tryinfo(hdl, &cap->enc[j], 0, 0, rates[i]))
				rate_map |= (1 << i);
		}
		for (conf = 0; conf < nconf; conf++) {
			if (cap->confs[conf].rate == rate_map) {
				cap->confs[conf].enc |= (1 << j);
				break;
			}
		}
		if (conf == nconf) {
			if (nconf == SIO_NCONF)
				break;
			cap->confs[nconf].enc = (1 << j);
			cap->confs[nconf].pchan = pchan_map;
			cap->confs[nconf].rchan = rchan_map;
			cap->confs[nconf].rate = rate_map;
			nconf++;
		}
	}
	cap->nconf = nconf;
	if (!sun_setpar(&hdl->sio, &savepar))
		return 0;
	return 1;
#undef NCHANS
#undef NRATES
}

struct sio_hdl *
sio_open_sun(const char *str, unsigned mode, int nbio)
{
	int fd, flags, fullduplex;
	struct audio_info aui;
	struct sun_hdl *hdl;
	struct sio_par par;
	char path[PATH_MAX];

	hdl = malloc(sizeof(struct sun_hdl));
	if (hdl == NULL)
		return NULL;
	sio_create(&hdl->sio, &sun_ops, mode, nbio);

	snprintf(path, sizeof(path), "/dev/audio%s", str);
	if (mode == (SIO_PLAY | SIO_REC))
		flags = O_RDWR;
	else
		flags = (mode & SIO_PLAY) ? O_WRONLY : O_RDONLY;

	while ((fd = open(path, flags | O_NONBLOCK)) < 0) {
		if (errno == EINTR)
			continue;
		DPERROR(path);
		goto bad_free;
	}
	if (fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {
		DPERROR("FD_CLOEXEC");
		goto bad_close;
	}

	/*
	 * pause the device
	 */
	AUDIO_INITINFO(&aui);
	if (mode & SIO_PLAY)
		aui.play.pause = 1;
	if (mode & SIO_REC)
		aui.record.pause = 1;
	if (ioctl(fd, AUDIO_SETINFO, &aui) < 0) {
		DPERROR("sio_open_sun: setinfo");
		goto bad_close;
	}
	/*
	 * If both play and record are requested then
	 * set full duplex mode.
	 */
	if (mode == (SIO_PLAY | SIO_REC)) {
		fullduplex = 1;
		if (ioctl(fd, AUDIO_SETFD, &fullduplex) < 0) {
			DPRINTF("sio_open_sun: %s: can't set full-duplex\n", path);
			goto bad_close;
		}
	}
	hdl->fd = fd;

	/*
	 * Default parameters may not be compatible with libsndio (eg. mulaw
	 * encodings, different playback and recording parameters, etc...), so
	 * set parameters to a random value. If the requested parameters are
	 * not supported by the device, then sio_setpar() will pick supported
	 * ones.
	 */
	sio_initpar(&par);
	par.rate = 48000;
	par.le = SIO_LE_NATIVE;
	par.sig = 1;
	par.bits = 16;
	par.appbufsz = 1200;
	if (!sio_setpar(&hdl->sio, &par))
		goto bad_close;
	return (struct sio_hdl *)hdl;
 bad_close:
	while (close(fd) < 0 && errno == EINTR)
		; /* retry */
 bad_free:
	free(hdl);
	return NULL;
}

static void
sun_close(struct sio_hdl *sh)
{
	struct sun_hdl *hdl = (struct sun_hdl *)sh;

	while (close(hdl->fd) < 0 && errno == EINTR)
		; /* retry */
	free(hdl);
}

static int
sun_start(struct sio_hdl *sh)
{
	struct sio_par par;
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	struct audio_info aui;

	if (!sio_getpar(&hdl->sio, &par))
		return 0;
	hdl->obpf = par.pchan * par.bps;
	hdl->ibpf = par.rchan * par.bps;
	hdl->ibytes = 0;
	hdl->obytes = 0;
	hdl->ierr = 0;
	hdl->oerr = 0;
	hdl->offset = 0;
	hdl->idelta = 0;
	hdl->odelta = 0;

	if (hdl->sio.mode & SIO_PLAY) {
		/*
		 * keep the device paused and let sun_write() trigger the
		 * start later, to avoid buffer underruns
		 */
		hdl->filling = 1;
	} else {
		/*
		 * no play buffers to fill, start now!
		 */
		AUDIO_INITINFO(&aui);
		if (hdl->sio.mode & SIO_REC)
			aui.record.pause = 0;
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
			DPERROR("sun_start: setinfo");
			hdl->sio.eof = 1;
			return 0;
		}
		hdl->filling = 0;
		sio_onmove_cb(&hdl->sio, 0);
	}
	return 1;
}

static int
sun_stop(struct sio_hdl *sh)
{
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	struct audio_info aui;
	int mode;

	if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
		DPERROR("sun_stop: getinfo");
		hdl->sio.eof = 1;
		return 0;
	}
	mode = aui.mode;

	/*
	 * there's no way to drain the device without blocking, so just
	 * stop it until the kernel driver get fixed
	 */
	AUDIO_INITINFO(&aui);
	aui.mode = 0;
	if (hdl->sio.mode & SIO_PLAY)
		aui.play.pause = 1;
	if (hdl->sio.mode & SIO_REC)
		aui.record.pause = 1;
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
		DPERROR("sun_stop: setinfo1");
		hdl->sio.eof = 1;
		return 0;
	}
	AUDIO_INITINFO(&aui);
	aui.mode = mode;
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
		DPERROR("sun_stop: setinfo2");
		hdl->sio.eof = 1;
		return 0;
	}
	return 1;
}

static int
sun_setpar(struct sio_hdl *sh, struct sio_par *par)
{
#define NRETRIES 8
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	struct audio_info aui;
	unsigned i, infr, ibpf, onfr, obpf;
	unsigned bufsz, round;
	unsigned rate, req_rate, prec, enc;

	/*
	 * try to set parameters until the device accepts
	 * a common encoding and rate for play and record
	 */
	rate = par->rate;
	prec = par->bits;
	sun_enctoinfo(hdl, &enc, par);
	for (i = 0;; i++) {
		if (i == NRETRIES) {
			DPRINTF("sun_setpar: couldn't set parameters\n");
			hdl->sio.eof = 1;
			return 0;
		}
		AUDIO_INITINFO(&aui);
		if (hdl->sio.mode & SIO_PLAY) {
			aui.play.sample_rate = rate;
			aui.play.precision = prec;
			aui.play.encoding = enc;
			aui.play.channels = par->pchan;
		}
		if (hdl->sio.mode & SIO_REC) {
			aui.record.sample_rate = rate;
			aui.record.precision = prec;
			aui.record.encoding = enc;
			aui.record.channels = par->rchan;
		}
		DPRINTF("sun_setpar: %i: trying pars = %u/%u/%u\n",
		    i, rate, prec, enc);
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0 && errno != EINVAL) {
			DPERROR("sun_setpar: setinfo(pars)");
			hdl->sio.eof = 1;
			return 0;
		}
		if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
			DPERROR("sun_setpar: getinfo(pars)");
			hdl->sio.eof = 1;
			return 0;
		}
		enc = (hdl->sio.mode & SIO_REC) ?
		    aui.record.encoding : aui.play.encoding;
		switch (enc) {
		case AUDIO_ENCODING_SLINEAR_LE:
		case AUDIO_ENCODING_SLINEAR_BE:
		case AUDIO_ENCODING_ULINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_BE:
		case AUDIO_ENCODING_SLINEAR:
		case AUDIO_ENCODING_ULINEAR:
			break;
		default:
			DPRINTF("sun_setpar: couldn't set linear encoding\n");
			hdl->sio.eof = 1;
			return 0;
		}
		if (hdl->sio.mode != (SIO_REC | SIO_PLAY))
			break;
		if (aui.play.sample_rate == aui.record.sample_rate &&
		    aui.play.precision == aui.record.precision &&
		    aui.play.encoding == aui.record.encoding)
			break;
		if (i < NRETRIES / 2) {
			rate = aui.play.sample_rate;
			prec = aui.play.precision;
			enc = aui.play.encoding;
		} else {
			rate = aui.record.sample_rate;
			prec = aui.record.precision;
			enc = aui.record.encoding;
		}
	}

	/*
	 * If the rate that the hardware is using is different than
	 * the requested rate, scale buffer sizes so they will be the
	 * same time duration as what was requested.  This just gets
	 * the rates to use for scaling, that actual scaling is done
	 * later.
	 */
	rate = (hdl->sio.mode & SIO_REC) ? aui.record.sample_rate :
	    aui.play.sample_rate;
	req_rate = rate;
	if (par->rate && par->rate != ~0U)
		req_rate = par->rate;

	/*
	 * if block size and buffer size are not both set then
	 * set the blocksize to half the buffer size
	 */
	bufsz = par->appbufsz;
	round = par->round;
	if (bufsz != ~0U) {
		bufsz = bufsz * rate / req_rate;
		if (round == ~0U)
			round = (bufsz + 1) / 2;
		else
			round = round * rate / req_rate;
	} else if (round != ~0U) {
		round = round * rate / req_rate;
		bufsz = round * 2;
	} else
		return 1;

	/*
	 * get the play/record frame size in bytes
	 */
	if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
		DPERROR("sun_setpar: GETINFO");
		hdl->sio.eof = 1;
		return 0;
	}
	ibpf = (hdl->sio.mode & SIO_REC) ?
	    aui.record.channels * aui.record.bps : 1;
	obpf = (hdl->sio.mode & SIO_PLAY) ?
	    aui.play.channels * aui.play.bps : 1;

	DPRINTF("sun_setpar: bpf = (%u, %u)\n", ibpf, obpf);

	/*
	 * try to set parameters until the device accepts
	 * a common block size for play and record
	 */
	for (i = 0; i < NRETRIES; i++) {
		AUDIO_INITINFO(&aui);
		aui.hiwat = (bufsz + round - 1) / round;
		aui.lowat = aui.hiwat;
		if (hdl->sio.mode & SIO_REC)
			aui.record.block_size = round * ibpf;
		if (hdl->sio.mode & SIO_PLAY)
			aui.play.block_size = round * obpf;
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
			DPERROR("sun_setpar2: SETINFO");
			hdl->sio.eof = 1;
			return 0;
		}
		if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
			DPERROR("sun_setpar2: GETINFO");
			hdl->sio.eof = 1;
			return 0;
		}
		infr = aui.record.block_size / ibpf;
		onfr = aui.play.block_size / obpf;
		DPRINTF("sun_setpar: %i: trying round = %u -> (%u, %u)\n",
		    i, round, infr, onfr);

		/*
		 * if half-duplex or both block sizes match, we're done
		 */
		if (hdl->sio.mode != (SIO_REC | SIO_PLAY) || infr == onfr) {
			DPRINTF("sun_setpar: blocksize ok\n");
			return 1;
		}

		/*
		 * half of the retries, retry with the smaller value,
		 * then with the larger returned value
		 */
		if (i < NRETRIES / 2)
			round = infr < onfr ? infr : onfr;
		else
			round = infr < onfr ? onfr : infr;
	}
	DPRINTF("sun_setpar: couldn't find a working blocksize\n");
	hdl->sio.eof = 1;
	return 0;
#undef NRETRIES
}

static int
sun_getpar(struct sio_hdl *sh, struct sio_par *par)
{
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	struct audio_info aui;

	if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
		DPERROR("sun_getpar: getinfo");
		hdl->sio.eof = 1;
		return 0;
	}
	if (hdl->sio.mode & SIO_PLAY) {
		par->rate = aui.play.sample_rate;
		if (!sun_infotoenc(hdl, &aui.play, par))
			return 0;
	} else if (hdl->sio.mode & SIO_REC) {
		par->rate = aui.record.sample_rate;
		if (!sun_infotoenc(hdl, &aui.record, par))
			return 0;
	} else
		return 0;
	par->pchan = (hdl->sio.mode & SIO_PLAY) ?
	    aui.play.channels : 0;
	par->rchan = (hdl->sio.mode & SIO_REC) ?
	    aui.record.channels : 0;
	par->round = (hdl->sio.mode & SIO_REC) ?
	    aui.record.block_size / (par->bps * par->rchan) :
	    aui.play.block_size / (par->bps * par->pchan);
	par->appbufsz = aui.hiwat * par->round;
	par->bufsz = par->appbufsz;
	return 1;
}

/*
 * drop recorded samples to compensate xruns
 */
static int
sun_rdrop(struct sun_hdl *hdl)
{
#define DROP_NMAX 0x1000
	static char dropbuf[DROP_NMAX];
	ssize_t n, todo;

	while (hdl->offset > 0) {
		todo = hdl->offset * hdl->ibpf;
		if (todo > DROP_NMAX)
			todo = DROP_NMAX - DROP_NMAX % hdl->ibpf;
		while ((n = read(hdl->fd, dropbuf, todo)) < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				DPERROR("sun_rdrop: read");
				hdl->sio.eof = 1;
			}
			return 0;
		}
		if (n == 0) {
			DPRINTF("sun_rdrop: eof\n");
			hdl->sio.eof = 1;
			return 0;
		}
		hdl->offset -= (int)n / (int)hdl->ibpf;
		DPRINTF("sun_rdrop: dropped %ld/%ld bytes\n", n, todo);
	}
	return 1;
}

static size_t
sun_read(struct sio_hdl *sh, void *buf, size_t len)
{
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	ssize_t n;

	if (!sun_rdrop(hdl))
		return 0;
	while ((n = read(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			DPERROR("sun_read: read");
			hdl->sio.eof = 1;
		}
		return 0;
	}
	if (n == 0) {
		DPRINTF("sun_read: eof\n");
		hdl->sio.eof = 1;
		return 0;
	}
	return n;
}

static size_t
sun_autostart(struct sun_hdl *hdl)
{
	struct audio_info aui;
	struct pollfd pfd;

	pfd.fd = hdl->fd;
	pfd.events = POLLOUT;
	while (poll(&pfd, 1, 0) < 0) {
		if (errno == EINTR)
			continue;
		DPERROR("sun_autostart: poll");
		hdl->sio.eof = 1;
		return 0;
	}
	if (!(pfd.revents & POLLOUT)) {
		hdl->filling = 0;
		AUDIO_INITINFO(&aui);
		if (hdl->sio.mode & SIO_PLAY)
			aui.play.pause = 0;
		if (hdl->sio.mode & SIO_REC)
			aui.record.pause = 0;
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
			DPERROR("sun_autostart: setinfo");
			hdl->sio.eof = 1;
			return 0;
		}
		sio_onmove_cb(&hdl->sio, 0);
	}
	return 1;
}

/*
 * insert silence to play to compensate xruns
 */
static int
sun_wsil(struct sun_hdl *hdl)
{
#define ZERO_NMAX 0x1000
	static char zero[ZERO_NMAX];
	ssize_t n, todo;

	while (hdl->offset < 0) {
		todo = (int)-hdl->offset * (int)hdl->obpf;
		if (todo > ZERO_NMAX)
			todo = ZERO_NMAX - ZERO_NMAX % hdl->obpf;
		while ((n = write(hdl->fd, zero, todo)) < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				DPERROR("sun_wsil: write");
				hdl->sio.eof = 1;
				return 0;
			}
			return 0;
		}
		hdl->offset += (int)n / (int)hdl->obpf;
		DPRINTF("sun_wsil: inserted %ld/%ld bytes\n", n, todo);
	}
	return 1;
}


static size_t
sun_write(struct sio_hdl *sh, const void *buf, size_t len)
{
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	const unsigned char *data = buf;
	ssize_t n, todo;

	if (!sun_wsil(hdl))
		return 0;
	todo = len;
	while ((n = write(hdl->fd, data, todo)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			DPERROR("sun_write: write");
			hdl->sio.eof = 1;
		}
 		return 0;
	}
	if (hdl->filling) {
		if (!sun_autostart(hdl))
			return 0;
	}
	return n;
}

static int
sun_pollfd(struct sio_hdl *sh, struct pollfd *pfd, int events)
{
	struct sun_hdl *hdl = (struct sun_hdl *)sh;

	pfd->fd = hdl->fd;
	pfd->events = events;
	return 1;
}

int
sun_revents(struct sio_hdl *sh, struct pollfd *pfd)
{
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	struct audio_offset ao;
	int xrun, dmove, dierr = 0, doerr = 0, delta;
	int revents = pfd->revents;

	if (!hdl->sio.started)
		return pfd->revents;
	if (hdl->sio.mode & SIO_PLAY) {
		if (ioctl(hdl->fd, AUDIO_PERROR, &xrun) < 0) {
			DPERROR("sun_revents: PERROR");
			hdl->sio.eof = 1;
			return POLLHUP;
		}
		doerr = xrun - hdl->oerr;
		hdl->oerr = xrun;
		if (!(hdl->sio.mode & SIO_REC))
			dierr = doerr;
	}
	if (hdl->sio.mode & SIO_REC) {
		if (ioctl(hdl->fd, AUDIO_RERROR, &xrun) < 0) {
			DPERROR("sun_revents: RERROR");
			hdl->sio.eof = 1;
			return POLLHUP;
		}
		dierr = xrun - hdl->ierr;
		hdl->ierr = xrun;
		if (!(hdl->sio.mode & SIO_PLAY))
			doerr = dierr;
	}
	hdl->offset += doerr - dierr;
	dmove = dierr > doerr ? dierr : doerr;
	hdl->idelta -= dmove;
	hdl->odelta -= dmove;

	if ((revents & POLLOUT) && (hdl->sio.mode & SIO_PLAY)) {
		if (ioctl(hdl->fd, AUDIO_GETOOFFS, &ao) < 0) {
			DPERROR("sun_revents: GETOOFFS");
			hdl->sio.eof = 1;
			return POLLHUP;
		}
		delta = (ao.samples - hdl->obytes) / hdl->obpf;
		hdl->obytes = ao.samples;
		hdl->odelta += delta;
		if (!(hdl->sio.mode & SIO_REC))
			hdl->idelta += delta;
	}
	if ((revents & POLLIN) && (hdl->sio.mode & SIO_REC)) {
		if (ioctl(hdl->fd, AUDIO_GETIOFFS, &ao) < 0) {
			DPERROR("sun_revents: GETIOFFS");
			hdl->sio.eof = 1;
			return POLLHUP;
		}
		delta = (ao.samples - hdl->ibytes) / hdl->ibpf;
		hdl->ibytes = ao.samples;
		hdl->idelta += delta;
		if (!(hdl->sio.mode & SIO_PLAY))
			hdl->odelta += delta;
	}
	delta = (hdl->idelta > hdl->odelta) ? hdl->idelta : hdl->odelta;
	if (delta > 0) {
		sio_onmove_cb(&hdl->sio, delta);
		hdl->idelta -= delta;
		hdl->odelta -= delta;
	}

	/*
	 * drop recorded samples or insert silence to play
	 * right now to adjust revents, and avoid busy loops
	 * programs
	 */
	if (hdl->filling)
		revents |= POLLOUT;
	if ((hdl->sio.mode & SIO_PLAY) && !sun_wsil(hdl))
		revents &= ~POLLOUT;
	if ((hdl->sio.mode & SIO_REC) && !sun_rdrop(hdl))
		revents &= ~POLLIN;
	return revents;
}
@


1.42
log
@make sio_onvol(3) return a integer exposing whether a volume knob
is available for the stream. As we're at it, remove macros and
functions that are neither used nor documented.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.41 2010/09/17 08:08:23 ratchov Exp $	*/
@


1.41
log
@don't try to get the current stream postion when the device is stopped,
and don't generate clock ticks (ie don't invoke the sio_onmove(3)
call-back).
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.40 2010/08/06 06:52:17 ratchov Exp $	*/
a66 2
static int sun_setvol(struct sio_hdl *, unsigned);
static void sun_getvol(struct sio_hdl *);
d79 2
a80 2
	sun_setvol,
	sun_getvol
a331 14
}

static void
sun_getvol(struct sio_hdl *sh)
{
	struct sun_hdl *hdl = (struct sun_hdl *)sh;

	sio_onvol_cb(&hdl->sio, SIO_MAXVOL);
}

int
sun_setvol(struct sio_hdl *sh, unsigned vol)
{
	return 1;
@


1.40
log
@If audio interrupts are missed (as this happens on some MP systems
now), play and record directons may be out of sync, and since the play
direction is used as clock source, we may end up with data ariving
_before_ the time it was recorded. This breaks the sndio ``device
model'' and most full-duplex apps relying on it, starting with aucat
in its default mode.

Workaround this by using the direction that's ahead as clock source,
ensuring that recorded data never arrives before the clock tick it was
recorded. This prevents apps from crashing but won't fix stuttering
caused by missed interrupts.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.39 2010/07/21 23:00:16 ratchov Exp $	*/
d897 2
d962 6
a967 8
	if (hdl->sio.started) {
		if (hdl->filling)
			revents |= POLLOUT;
		if ((hdl->sio.mode & SIO_PLAY) && !sun_wsil(hdl))
			revents &= ~POLLOUT;
		if ((hdl->sio.mode & SIO_REC) && !sun_rdrop(hdl))
			revents &= ~POLLIN;
	}
@


1.39
log
@remove unnecessary ``return 0'' statements,
from Remco <remco at d-compu.dyndns.org>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.38 2010/07/15 03:43:11 jakemsr Exp $	*/
d894 1
a894 1
	int xrun, dmove, dierr = 0, doerr = 0, doffset = 0;
d905 2
a906 2
		if (hdl->sio.mode & SIO_REC)
			doffset += doerr;
d916 2
a917 2
		if (hdl->sio.mode & SIO_PLAY)
			doffset -= dierr;
d919 1
a919 1
	hdl->offset += doffset;
d930 1
a930 1
		hdl->odelta += (ao.samples - hdl->obytes) / hdl->obpf;
d932 3
a934 4
		if (hdl->odelta > 0) {
			sio_onmove_cb(&hdl->sio, hdl->odelta);
			hdl->odelta = 0;
		}
d936 1
a936 1
	if ((revents & POLLIN) && !(hdl->sio.mode & SIO_PLAY)) {
d942 1
a942 1
		hdl->idelta += (ao.samples - hdl->ibytes) / hdl->ibpf;
d944 9
a952 4
		if (hdl->idelta > 0) {
			sio_onmove_cb(&hdl->sio, hdl->idelta);
			hdl->idelta = 0;
		}
@


1.38
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.37 2010/05/25 06:49:13 ratchov Exp $	*/
a868 1
			return 0;
@


1.37
log
@drop samples or insert silence in sun_revents(). Otherwise, in
full-duplex, we may detect a xrun in the play direction and discard
the clock tick, this would cause sio_revents() to return POLLIN
without the clock being advanced, causing apps relying on the clock
for flow control to enter a busy loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.36 2010/05/09 18:24:24 jakemsr Exp $	*/
d91 1
a91 1
	par->msb = 1;
d93 1
a93 1
	par->bps = SIO_BPS(par->bits);
d270 2
a271 2
		cap->enc[nenc].bps = SIO_BPS(ae.precision);
		cap->enc[nenc].msb = 1;
d642 1
a642 1
	    aui.record.channels * SIO_BPS(aui.record.precision) : 1;
d644 1
a644 1
	    aui.play.channels * SIO_BPS(aui.play.precision) : 1;
@


1.36
log
@if the sample rate the hardware will use is different than the
requested sample rate, scale the block/buffer sizes so the block/
buffer sizes the hardware will use are the same amount of *time*
as the requested block/buffer sizes.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.35 2010/04/29 21:09:50 ratchov Exp $	*/
d461 1
a461 1
		 * pause the device and let sun_write() trigger the
d731 5
a735 2
static size_t
sun_read(struct sio_hdl *sh, void *buf, size_t len)
a738 1
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
d749 1
a749 1
				DPERROR("sun_read: read");
d755 1
a755 1
			DPRINTF("sun_read: eof\n");
d760 1
a760 2
		DPRINTF("sun_read: dropped %ld/%ld bytes "
		    "to resync\n", n, todo);
d762 8
d771 2
d822 5
a826 2
static size_t
sun_write(struct sio_hdl *sh, const void *buf, size_t len)
a829 2
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	const unsigned char *data = buf;
d840 1
a840 1
				DPERROR("sun_write: sil");
d847 1
a847 2
		DPRINTF("sun_write: inserted %ld/%ld bytes "
		    "of silence to resync\n", n, todo);
d849 2
d852 10
d911 1
d951 14
a964 2
	if (hdl->filling)
		revents |= POLLOUT;
@


1.35
log
@in sun_start(), don't pause the device in play mode, since it's
already paused (by either sio_open or sio_stop)
from Alexandr Shadchin, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.34 2010/04/25 18:51:05 ratchov Exp $	*/
d530 1
a530 1
	unsigned rate, prec, enc;
d603 13
d622 1
d625 2
d628 2
a629 2
		if (bufsz == ~0U)
			bufsz = round * 2;
@


1.34
log
@If setting close-on-exec flag fails (can this happen?), the wrong
descriptor is closed. Fix from Alexandr Shadchin, together with
various simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.33 2010/04/25 18:29:48 ratchov Exp $	*/
a463 10
		AUDIO_INITINFO(&aui);
		if (hdl->sio.mode & SIO_PLAY)
			aui.play.pause = 1;
		if (hdl->sio.mode & SIO_REC)
			aui.record.pause = 1;
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
			DPERROR("sun_start: setinfo2");
			hdl->sio.eof = 1;
			return 0;
		}
@


1.33
log
@Fix the way sio_getcap() probes rates of audio(4) devices.
From Alexandr Shadchin <alexandr.shadchin at gmail.com>
Good catch!
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.32 2010/04/25 18:25:07 ratchov Exp $	*/
a379 1
	hdl->fd = fd;
d385 1
a385 1
	if (hdl->sio.mode & SIO_PLAY)
d387 1
a387 1
	if (hdl->sio.mode & SIO_REC)
d389 1
a389 1
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
d423 1
a423 1
	while (close(hdl->fd) < 0 && errno == EINTR)
d434 3
a436 4
	int rc;
	do {
		rc = close(hdl->fd);
	} while (rc < 0 && errno == EINTR);
a479 2
		if (hdl->sio.mode & SIO_PLAY)
			aui.play.pause = 0;
@


1.32
log
@when probing for a encoding/channels/rate combination, ensure that
play parameters are set only if playback is enabled, and record
parameters are set only if recording is enabled. Fixes
sun_getcap() on devices whose play and record parameters are not
independent.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.31 2010/04/24 14:13:34 ratchov Exp $	*/
d228 2
a229 2
	unsigned enc_map = 0, rchan_map = 0, pchan_map = 0, rate_map = 0;
	unsigned i, j, map;
d307 1
a307 3
		if (nconf == SIO_NCONF)
			break;
		map = 0;
d309 2
a310 2
			if (sun_tryinfo(hdl, NULL, 0, 0, rates[i]))
				map |= (1 << i);
d312 10
a321 3
		if (map != rate_map) {
			rate_map = map;
			cap->confs[nconf].enc = enc_map;
@


1.31
log
@when probing an encoding of a audio(4) device, don't forget to
set record precision.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.30 2010/04/24 06:15:54 ratchov Exp $	*/
d157 3
d164 1
a164 2
			aui.play.encoding = AUDIO_ENCODING_SLINEAR_LE;
			aui.record.encoding = AUDIO_ENCODING_SLINEAR_LE;
d166 1
a166 2
			aui.play.encoding = AUDIO_ENCODING_SLINEAR_BE;
			aui.record.encoding = AUDIO_ENCODING_SLINEAR_BE;
d168 1
a168 2
			aui.play.encoding = AUDIO_ENCODING_ULINEAR_LE;
			aui.record.encoding = AUDIO_ENCODING_ULINEAR_LE;
d170 1
a170 2
			aui.play.encoding = AUDIO_ENCODING_ULINEAR_BE;
			aui.record.encoding = AUDIO_ENCODING_ULINEAR_BE;
d172 1
a172 2
		aui.play.precision = enc->bits;
		aui.record.precision = enc->bits;
d174 5
a178 1
	if (pchan)
d180 1
a180 1
	if (rchan)
a181 6
	if (rate) {
		if (hdl->sio.mode & SIO_PLAY)
			aui.play.sample_rate = rate;
		if (hdl->sio.mode & SIO_REC)
			aui.record.sample_rate = rate;
	}
@


1.30
log
@remove trailing spaces, from Alexandr Shadchin, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.29 2010/04/11 16:53:55 ratchov Exp $	*/
d174 1
@


1.29
log
@audio(4) doesn't require to be started explicitely, so the device is
started immediately after it's opened in record only mode.
Pause it in sio_open() and sio_stop(), since libsndio requires
an explicit call to sio_start().

discussed with jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.28 2010/04/06 20:07:01 ratchov Exp $	*/
d153 1
a153 1
sun_tryinfo(struct sun_hdl *hdl, struct sio_enc *enc, 
d156 2
a157 2
	struct audio_info aui;	
	
d220 1
a220 1
	static unsigned chans[] = { 
d223 1
a223 1
	static unsigned rates[] = { 
d300 1
a300 1
	
d352 1
a352 1
	struct audio_info aui;	
d365 1
a365 1
	else 
d445 1
a445 1
	struct audio_info aui;	
d460 1
a460 1
		/* 
d499 1
a499 1
	struct audio_info aui;	
d617 1
a617 1
	 */ 
d698 1
a698 1
	struct audio_info aui;	
d778 1
a778 1
	struct audio_info aui;	
d780 1
a780 1
	
d859 1
a859 1
	pfd->events = events;	
@


1.28
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.27 2010/02/10 23:03:53 ratchov Exp $	*/
d352 1
d381 12
d515 4
@


1.27
log
@Fix sio_getcap() for audio(4) devices exposing encodings
with precision other than 8, 16 or 32 bits.
Found by Jan Stary <hans at stare.cz>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.26 2009/12/02 08:19:11 ratchov Exp $	*/
d880 1
a880 1
	if ((revents & POLLOUT) && !(hdl->sio.mode & SIO_REC)) {
d893 1
a893 1
	if ((revents & POLLIN) && (hdl->sio.mode & SIO_REC)) {
@


1.26
log
@we don't expose overruns/underruns as negative positions anymore,
don't call the sio_onmove() call-back with negative argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.25 2009/11/03 06:41:19 ratchov Exp $	*/
d273 2
a274 2
		cap->enc[nenc].bps = ae.precision / 8;
		cap->enc[nenc].msb = 0;
@


1.25
log
@in block size calculations, use SIO_BPS(precision) instead of
precision / 8. Fixes sio_setpar() requesting smaller block sizes
on 24-bit devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.24 2009/10/10 11:27:39 ratchov Exp $	*/
d888 1
a888 1
		if (hdl->odelta != 0) {
d901 1
a901 1
		if (hdl->idelta != 0) {
@


1.24
log
@when setting parameters of sun devices, check that selected encoding
is actually linear
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.23 2009/10/10 11:19:55 ratchov Exp $	*/
d621 1
a621 1
	    aui.record.channels * aui.record.precision / 8 : 1;
d623 1
a623 1
	    aui.play.channels * aui.play.precision / 8 : 1;
@


1.23
log
@at initialization of sun devices, use sio_setpar(3) instead of
AUDIO_SETINFO() to set the initial parameters, since AUDIO_SETINFO()
can fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.22 2009/10/10 08:34:12 ratchov Exp $	*/
d133 5
a137 1
	if (par->le && par->sig) {
a559 2
		if (hdl->sio.mode != (SIO_REC | SIO_PLAY))
			break;
d565 17
@


1.22
log
@since AUDIO_INITINFO() may set parameters to whatever is supported
by the device, we may end up with different recording and playback
parameters, which will break almost all full duplex apps on such
devices. For instance, this should fix full-duplex apps not working
on devices that can record at any sample rate but can play
 at 48kHz only.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.21 2009/07/26 15:50:04 ratchov Exp $	*/
a348 1
	struct audio_info aui;
d387 8
a394 9
	AUDIO_INITINFO(&aui);
	if (hdl->sio.mode & SIO_PLAY)
		aui.play.encoding = AUDIO_ENCODING_SLINEAR;
	if (hdl->sio.mode & SIO_REC)
		aui.record.encoding = AUDIO_ENCODING_SLINEAR;
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
		DPERROR("sio_open_sun: setinfo");
		goto bad_close;
	}
d397 1
@


1.21
log
@more style improvemets, from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.20 2009/07/26 12:38:20 ratchov Exp $	*/
d131 1
a131 1
sun_enctoinfo(struct sun_hdl *hdl, struct audio_prinfo *ai, struct sio_par *par)
d134 1
a134 1
		ai->encoding = AUDIO_ENCODING_SLINEAR_LE;
d136 1
a136 1
		ai->encoding = AUDIO_ENCODING_SLINEAR_BE;
d138 1
a138 1
		ai->encoding = AUDIO_ENCODING_ULINEAR_LE;
d140 1
a140 1
		ai->encoding = AUDIO_ENCODING_ULINEAR_BE;
a141 1
	ai->precision = par->bits;
d522 1
d525 2
a526 1
	 * first, set encoding, rate and channels
d528 49
a576 15
	AUDIO_INITINFO(&aui);
	if (hdl->sio.mode & SIO_PLAY) {
		aui.play.sample_rate = par->rate;
		aui.play.channels = par->pchan;
		sun_enctoinfo(hdl, &aui.play, par);
	}
	if (hdl->sio.mode & SIO_REC) {
		aui.record.sample_rate = par->rate;
		aui.record.channels = par->rchan;
		sun_enctoinfo(hdl, &aui.record, par);
	}
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0 && errno != EINVAL) {
		DPERROR("sun_setpar: setinfo");
		hdl->sio.eof = 1;
		return 0;
d633 1
a633 1
		DPRINTF("sun_setpar: %i: trying rond = %u -> (%u, %u)\n",
@


1.20
log
@sort and space headers as per style(9)
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.19 2009/07/25 11:15:56 ratchov Exp $	*/
d550 2
a551 2
	if (bufsz != (unsigned)~0) {
		if (round == (unsigned)~0)
d553 2
a554 2
	} else if (round != (unsigned)~0) {
		if (bufsz == (unsigned)~0)
@


1.19
log
@use const qualifier in libsndio, making it slightly more consistent
with open(2) and write(2) syscalls.
from Thomas Pfaff, jakemsr is fine with it
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.18 2009/07/25 08:44:27 ratchov Exp $	*/
d33 1
a33 1
#include <limits.h>
d36 1
@


1.18
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.17 2009/05/15 13:16:58 ratchov Exp $	*/
d63 1
a63 1
static size_t sun_write(struct sio_hdl *, void *, size_t);
d345 1
a345 1
sio_open_sun(char *str, unsigned mode, int nbio)
d737 1
a737 1
sun_write(struct sio_hdl *sh, void *buf, size_t len)
d742 1
a742 1
	unsigned char *data = buf;
@


1.17
log
@cleanup forgotten calls to exit(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.16 2009/05/15 13:10:39 ratchov Exp $	*/
d345 1
a345 1
sio_open_sun(char *path, unsigned mode, int nbio)
d351 1
d358 1
a358 2
	if (path == NULL)
		path = SIO_SUN_PATH;
@


1.16
log
@replace s/sa/sio/, left from when libsa was renamed to libsndio
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.15 2009/05/15 13:04:52 ratchov Exp $	*/
d87 1
a87 1
static void
d120 2
a121 1
		exit(1);
d123 1
d636 2
a637 1
		sun_infotoenc(hdl, &aui.play, par);
d640 2
a641 1
		sun_infotoenc(hdl, &aui.record, par);
d803 2
a804 1
			exit(1);
d813 2
a814 2
			DPERROR("sun_revents: RERROR");
			exit(1);
d829 2
a830 1
			exit(1);
d842 2
a843 1
			exit(1);
@


1.15
log
@if DEBUG is defined, use a global debug level rather
than a per-stream debug level. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.14 2009/02/26 22:14:18 ratchov Exp $	*/
d45 1
a45 1
	struct sio_hdl sa;
d174 1
a174 1
		if (hdl->sa.mode & SIO_PLAY)
d176 1
a176 1
		if (hdl->sa.mode & SIO_REC)
d183 1
a183 1
		hdl->sa.eof = 1;
d188 1
a188 1
		hdl->sa.eof = 1;
d196 1
a196 1
		if ((hdl->sa.mode & SIO_PLAY) &&
d199 1
a199 1
		if ((hdl->sa.mode & SIO_REC) &&
d228 1
a228 1
	if (!sun_getpar(&hdl->sa, &savepar))
d239 1
a239 1
			hdl->sa.eof = 1;
d280 1
a280 1
	if (hdl->sa.mode & SIO_PLAY) {
d287 1
a287 1
	if (hdl->sa.mode & SIO_REC) {
d321 1
a321 1
	if (!sun_setpar(&hdl->sa, &savepar))
d333 1
a333 1
	sio_onvol_cb(&hdl->sa, SIO_MAXVOL);
d353 1
a353 1
	sio_create(&hdl->sa, &sun_ops, mode, nbio);
d387 1
a387 1
	if (hdl->sa.mode & SIO_PLAY)
d389 1
a389 1
	if (hdl->sa.mode & SIO_REC)
d400 1
a400 1
	if (!sio_setpar(&hdl->sa, &par))
d429 1
a429 1
	if (!sio_getpar(&hdl->sa, &par))
d441 1
a441 1
	if (hdl->sa.mode & SIO_PLAY) {
d447 1
a447 1
		if (hdl->sa.mode & SIO_PLAY)
d449 1
a449 1
		if (hdl->sa.mode & SIO_REC)
d453 1
a453 1
			hdl->sa.eof = 1;
d462 1
a462 1
		if (hdl->sa.mode & SIO_PLAY)
d464 1
a464 1
		if (hdl->sa.mode & SIO_REC)
d468 1
a468 1
			hdl->sa.eof = 1;
d472 1
a472 1
		sio_onmove_cb(&hdl->sa, 0);
d486 1
a486 1
		hdl->sa.eof = 1;
d499 1
a499 1
		hdl->sa.eof = 1;
d506 1
a506 1
		hdl->sa.eof = 1;
d525 1
a525 1
	if (hdl->sa.mode & SIO_PLAY) {
d530 1
a530 1
	if (hdl->sa.mode & SIO_REC) {
d537 1
a537 1
		hdl->sa.eof = 1;
d561 1
a561 1
		hdl->sa.eof = 1;
d564 1
a564 1
	ibpf = (hdl->sa.mode & SIO_REC) ?
d566 1
a566 1
	obpf = (hdl->sa.mode & SIO_PLAY) ?
d579 1
a579 1
		if (hdl->sa.mode & SIO_REC)
d581 1
a581 1
		if (hdl->sa.mode & SIO_PLAY)
d585 1
a585 1
			hdl->sa.eof = 1;
d590 1
a590 1
			hdl->sa.eof = 1;
d601 1
a601 1
		if (hdl->sa.mode != (SIO_REC | SIO_PLAY) || infr == onfr) {
d616 1
a616 1
	hdl->sa.eof = 1;
d629 1
a629 1
		hdl->sa.eof = 1;
d632 1
a632 1
	if (hdl->sa.mode & SIO_PLAY) {
d635 1
a635 1
	} else if (hdl->sa.mode & SIO_REC) {
d640 1
a640 1
	par->pchan = (hdl->sa.mode & SIO_PLAY) ?
d642 1
a642 1
	par->rchan = (hdl->sa.mode & SIO_REC) ?
d644 1
a644 1
	par->round = (hdl->sa.mode & SIO_REC) ?
d669 1
a669 1
				hdl->sa.eof = 1;
d675 1
a675 1
			hdl->sa.eof = 1;
d688 1
a688 1
			hdl->sa.eof = 1;
d694 1
a694 1
		hdl->sa.eof = 1;
d712 1
a712 1
		hdl->sa.eof = 1;
d718 1
a718 1
		if (hdl->sa.mode & SIO_PLAY)
d720 1
a720 1
		if (hdl->sa.mode & SIO_REC)
d724 1
a724 1
			hdl->sa.eof = 1;
d727 1
a727 1
		sio_onmove_cb(&hdl->sa, 0);
d750 1
a750 1
				hdl->sa.eof = 1;
d766 1
a766 1
			hdl->sa.eof = 1;
d796 1
a796 1
	if (hdl->sa.mode & SIO_PLAY) {
d803 1
a803 1
		if (hdl->sa.mode & SIO_REC)
d806 1
a806 1
	if (hdl->sa.mode & SIO_REC) {
d813 1
a813 1
		if (hdl->sa.mode & SIO_PLAY)
d821 1
a821 1
	if ((revents & POLLOUT) && !(hdl->sa.mode & SIO_REC)) {
d829 1
a829 1
			sio_onmove_cb(&hdl->sa, hdl->odelta);
d833 1
a833 1
	if ((revents & POLLIN) && (hdl->sa.mode & SIO_REC)) {
d841 1
a841 1
			sio_onmove_cb(&hdl->sa, hdl->idelta);
@


1.14
log
@don't use ``hdl->filling'' flag uninitialized
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.13 2009/02/04 07:54:00 ratchov Exp $	*/
d119 1
a119 1
		DPRINTF(&hdl->sa, "sun_infotoenc: unsupported encoding\n");
d182 1
a182 1
		DPERROR(&hdl->sa, "sun_tryinfo: setinfo");
d187 1
a187 1
		DPERROR(&hdl->sa, "sun_tryinfo: getinfo");
d238 1
a238 1
			DPERROR(&hdl->sa, "sun_getcap: getenc");
d365 1
a365 1
		DPERROR(&hdl->sa, path);
d369 1
a369 1
		DPERROR(&hdl->sa, "FD_CLOEXEC");
d381 1
a381 2
			DPRINTF(&hdl->sa,
			    "sio_open_sun: %s: can't set full-duplex\n", path);
d392 1
a392 1
		DPERROR(&hdl->sa, "sio_open_sun: setinfo");
d452 1
a452 1
			DPERROR(&hdl->sa, "sun_start: setinfo2");
d467 1
a467 1
			DPERROR(&hdl->sa, "sun_start: setinfo");
d485 1
a485 1
		DPERROR(&hdl->sa, "sun_stop: getinfo");
d498 1
a498 1
		DPERROR(&hdl->sa, "sun_stop: setinfo1");
d505 1
a505 1
		DPERROR(&hdl->sa, "sun_stop: setinfo2");
d536 1
a536 1
		DPERROR(&hdl->sa, "sun_setpar: setinfo");
d560 1
a560 1
		DPERROR(&hdl->sa, "sun_setpar: GETINFO");
d569 2
a570 4
#ifdef DEBUG
	if (hdl->sa.debug)
		DPRINTF(&hdl->sa, "sun_setpar: bpf = (%u, %u)\n", ibpf, obpf);
#endif
d584 1
a584 1
			DPERROR(&hdl->sa, "sun_setpar2: SETINFO");
d589 1
a589 1
			DPERROR(&hdl->sa, "sun_setpar2: GETINFO");
d595 2
a596 7
#ifdef DEBUG
		if (hdl->sa.debug) {
			DPRINTF(&hdl->sa,
			    "sun_setpar: %i: trying rond = %u -> (%u, %u)\n",
			    i, round, infr, onfr);
		}
#endif
d602 1
a602 4
#ifdef DEBUG
			if (hdl->sa.debug)
				DPRINTF(&hdl->sa, "sun_setpar: blocksize ok\n");
#endif
d615 1
a615 1
	DPRINTF(&hdl->sa, "sun_setpar: couldn't find a working blocksize\n");
d628 1
a628 1
		DPERROR(&hdl->sa, "sun_getpar: getinfo");
d668 1
a668 1
				DPERROR(&hdl->sa, "sun_read: read");
d674 1
a674 1
			DPRINTF(&hdl->sa, "sun_read: eof\n");
d679 2
a680 5
#ifdef DEBUG
		if (hdl->sa.debug)
			DPRINTF(&hdl->sa, "sun_read: dropped %ld/%ld bytes "
			    "to resync\n", n, todo);
#endif
d687 1
a687 1
			DPERROR(&hdl->sa, "sun_read: read");
d693 1
a693 1
		DPRINTF(&hdl->sa, "sun_read: eof\n");
d711 1
a711 1
		DPERROR(&hdl->sa, "sun_autostart: poll");
d723 1
a723 1
			DPERROR(&hdl->sa, "sun_autostart: setinfo");
d749 1
a749 1
				DPERROR(&hdl->sa, "sun_write: sil");
d756 2
a757 5
#ifdef DEBUG
		if (hdl->sa.debug)
			DPRINTF(&hdl->sa, "sun_write: inserted %ld/%ld bytes "
			    "of silence to resync\n", n, todo);
#endif
d765 1
a765 1
			DPERROR(&hdl->sa, "sun_write: write");
d798 1
a798 1
			DPERROR(&hdl->sa, "sun_revents: PERROR");
d808 1
a808 1
			DPERROR(&hdl->sa, "sun_revents: RERROR");
d823 1
a823 1
			DPERROR(&hdl->sa, "sun_revents: GETOOFFS");
d835 1
a835 1
			DPERROR(&hdl->sa, "sun_revents: GETIOFFS");
@


1.13
log
@Programs have no direct access do the device file descriptor. So, if
the programs calls execvp(2), the new image can't use the device, which
stays open, so other programs get EBUSY. Set the close-on-exec flag to
avoid this.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.12 2009/01/10 20:34:44 ratchov Exp $	*/
d472 1
@


1.12
log
@make all private functions static
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.11 2008/12/21 16:15:24 ratchov Exp $	*/
d367 4
@


1.11
log
@remove mixer bits from the audio(4) backend of libsndio, it's not
possible to get them right in the current state of the mixer.
discussed with jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.10 2008/12/21 10:03:25 ratchov Exp $	*/
d56 12
a67 12
void sun_close(struct sio_hdl *);
int sun_start(struct sio_hdl *);
int sun_stop(struct sio_hdl *);
int sun_setpar(struct sio_hdl *, struct sio_par *);
int sun_getpar(struct sio_hdl *, struct sio_par *);
int sun_getcap(struct sio_hdl *, struct sio_cap *);
size_t sun_read(struct sio_hdl *, void *, size_t);
size_t sun_write(struct sio_hdl *, void *, size_t);
int sun_pollfd(struct sio_hdl *, struct pollfd *, int);
int sun_revents(struct sio_hdl *, struct pollfd *);
int sun_setvol(struct sio_hdl *, unsigned);
void sun_getvol(struct sio_hdl *);
d69 1
a69 1
struct sio_ops sun_ops = {
d87 1
a87 1
void
d127 1
a127 1
void
d146 1
a146 1
int
d209 1
a209 1
int
d328 1
a328 1
void
d408 1
a408 1
void
d419 1
a419 1
int
d473 1
a473 1
int
d508 1
a508 1
int
d627 1
a627 1
int
d658 1
a658 1
size_t
d709 1
a709 1
size_t
d741 1
a741 1
size_t
d790 1
a790 1
int
@


1.10
log
@fix more spelling errors and typos,
from Thomas Pfaff <tpfaff(at)@@tp76.info>, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.9 2008/12/17 10:00:50 ratchov Exp $	*/
a53 2
	int voltodo;			/* 1 if vol initialization pending */
	unsigned curvol;
a84 13
 * prefered controls for the volume knob, in reverse order of preference
 */
struct sun_pref {
	char *cls, *dev;
} sun_vols[] = {
	{ AudioCoutputs, AudioNmaster },
	{ AudioCoutputs, AudioNoutput },
	{ AudioCoutputs, AudioNdac },
	{ AudioCinputs, AudioNdac },
	{ NULL, NULL}
};

/*
a327 65
/*
 * initialize volume knob
 */
void
sun_initvol(struct sun_hdl *hdl)
{
	int i, fd, index = -1, last_pref = -1;
	struct sun_pref *p;
	struct stat sb;
	struct mixer_devinfo mi, cl;
	struct mixer_ctrl m;
	char path[PATH_MAX];

	if (fstat(hdl->fd, &sb) < 0)
		return;
	if (!S_ISCHR(sb.st_mode))
		return;
	snprintf(path, PATH_MAX, "/dev/mixer%d", sb.st_rdev & 0xf);
	fd = open(path, O_RDWR);	
	if (fd < 0) {
		DPRINTF(&hdl->sa, "sun_initvol: %s: couldn't open mixer\n",
			path);
		return;
	}

	for (mi.index = 0; ; mi.index++) {
		if (ioctl(fd, AUDIO_MIXER_DEVINFO, &mi) < 0)
			break;
		if (mi.type == AUDIO_MIXER_CLASS || mi.prev != -1)
			continue;
		cl.index = mi.mixer_class;
		if (ioctl(fd, AUDIO_MIXER_DEVINFO, &cl) < 0)
			continue;
		/*
		 * find preferred input gain and output gain
		 */
		for (i = 0, p = sun_vols; p->cls != NULL; i++, p++) {
			if (strcmp(p->cls, cl.label.name) != 0 ||
			    strcmp(p->dev, mi.label.name) != 0)
				continue;
			if (last_pref < i) {
				index = mi.index;
				last_pref = i;
			}
			break;
		}
	}
	hdl->mix_fd = fd;
	hdl->mix_index = index;
	if (index >= 0) {
		m.dev = index;
		m.type = AUDIO_MIXER_VALUE;
		m.un.value.num_channels = 1;
		if (ioctl(hdl->mix_fd, AUDIO_MIXER_READ, &m) < 0) {
			DPRINTF(&hdl->sa,
			    "sun_initvol: %d: failed to get volume\n", m.dev);
			hdl->sa.eof = 1;
			return;
		}
		hdl->curvol = m.un.value.level[0] / 2;
	} else 
		hdl->curvol = SIO_MAXVOL;
	return;
}

d333 1
a333 5
	if (hdl->voltodo) {
		sun_initvol(hdl);
		hdl->voltodo = 0;
	}
	sio_onvol_cb(&hdl->sa, hdl->curvol);
a338 19
	struct sun_hdl *hdl = (struct sun_hdl *)sh;
	struct mixer_ctrl m;
	
	if (hdl->voltodo) {
		sun_initvol(hdl);
		hdl->voltodo = 0;
	}
	if (hdl->mix_fd == -1 || hdl->mix_index == -1)
		return 0;
	m.dev = hdl->mix_index;
	m.type = AUDIO_MIXER_VALUE;
	m.un.value.num_channels = 1;
	m.un.value.level[0] = 2 * vol;
	if (ioctl(hdl->mix_fd, AUDIO_MIXER_WRITE, &m) < 0) {
		DPRINTF(&hdl->sa, "sun_setvol: failed to set volume\n");
		hdl->sa.eof = 1;
		return 0;
	}
	hdl->curvol = vol;
a368 1
	hdl->voltodo = 1;
@


1.9
log
@stop using stderr in the library, wrap all diagnostic fprintfs
so they are visible only when the DEBUG macro is #defined
and SIO_DEBUG env. variable is set.
requested by many, discussed with jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.8 2008/12/17 07:19:27 ratchov Exp $	*/
d159 1
a159 1
 * device can use them; retrun 1 on success, 0 on failure or error
d315 1
a315 1
	 * certain encordings. We have to check rates for all encodings
d363 2
a364 1
		DPRINTF(&hdl->sa, "%s: couldn't open mixer\n", path);
d377 1
a377 1
		 * find prefered input gain and output gain
d397 2
a398 1
			DPRINTF(&hdl->sa, "sun_getvol: %d: failed to get volume\n", m.dev);
d481 2
a482 1
			DPRINTF(&hdl->sa, "%s: can't set full-duplex\n", path);
d585 1
a585 1
		DPERROR(&hdl->sa, "sun_start: setinfo1");
d738 1
a738 1
		DPERROR(&hdl->sa, "sun_getpar: setinfo");
d824 1
a824 1
		DPERROR(&hdl->sa, "sun_fill: poll");
d836 1
a836 1
			DPERROR(&hdl->sa, "sun_start: setinfo");
a964 1

@


1.8
log
@add a writable ``appbufsz'' field to the sa_par structure, containing
the program-part of the buffer size, ie the part that is subject to
underruns. Useful for apps like cdio(1) that don't have their own
rings, or to apps that have a minimum ring size constraint. Setting
the ``bufsz'' parameter becomes deprecated.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.7 2008/11/20 16:31:26 ratchov Exp $	*/
d103 1
a103 1
sun_infotoenc(struct audio_prinfo *ai, struct sio_par *par)
d134 1
a134 1
		fprintf(stderr, "sun_infotoenc: unsupported encoding\n");
d143 1
a143 1
sun_enctoinfo(struct audio_prinfo *ai, struct sio_par *par)
d197 1
a197 1
		perror("sun_tryinfo: setinfo");
d202 1
a202 1
		perror("sun_tryinfo: getinfo");
d253 1
a253 1
			perror("sun_getcap: getenc");
d363 1
a363 1
		fprintf(stderr, "%s: couldn't open mixer\n", path);
d396 1
a396 1
			fprintf(stderr, "sun_getvol: %d: failed to get volume\n", m.dev);
d435 1
a435 1
		fprintf(stderr, "sun_setvol: failed to set volume\n");
d466 1
a466 1
		perror(path);
d479 1
a479 1
			fprintf(stderr, "%s: can't set full-duplex\n", path);
d490 1
a490 1
		perror("sio_open_sun: setinfo");
d550 1
a550 1
			perror("sun_start: setinfo2");
d565 1
a565 1
			perror("sun_start: setinfo");
d582 1
a582 1
		perror("sun_start: setinfo1");
d595 1
a595 1
		perror("sun_stop: setinfo1");
d602 1
a602 1
		perror("sun_stop: setinfo2");
d625 1
a625 1
		sun_enctoinfo(&aui.play, par);
d630 1
a630 1
		sun_enctoinfo(&aui.record, par);
d633 1
a633 1
		perror("sun_setpar: setinfo");
d657 1
a657 1
		perror("sun_setpar: GETINFO");
d668 1
a668 1
		fprintf(stderr, "sun_setpar: bpf = (%u, %u)\n", ibpf, obpf);
d683 1
a683 1
			perror("sun_setpar2: SETINFO");
d688 1
a688 1
			perror("sun_setpar2: GETINFO");
d696 1
a696 1
			fprintf(stderr,
d708 1
a708 1
				fprintf(stderr, "sun_setpar: blocksize ok\n");
d722 1
a722 1
	fprintf(stderr, "sun_setpar: couldn't find a working blocksize\n");
d735 1
a735 1
		perror("sun_getpar: setinfo");
d741 1
a741 1
		sun_infotoenc(&aui.play, par);
d744 1
a744 1
		sun_infotoenc(&aui.record, par);
d775 1
a775 1
				perror("sun_read: read");
d781 1
a781 1
			fprintf(stderr, "sun_read: eof\n");
d788 1
a788 1
			fprintf(stderr, "sun_read: dropped %ld/%ld bytes "
d797 1
a797 1
			perror("sun_read: read");
d803 1
a803 1
		fprintf(stderr, "sun_read: eof\n");
d821 1
a821 1
		perror("sun_fill: poll");
d833 1
a833 1
			perror("sun_start: setinfo");
d859 1
a859 1
				perror("sun_write: sil");
d868 1
a868 1
			fprintf(stderr, "sun_write: inserted %ld/%ld bytes "
d878 1
a878 1
			perror("sun_write: write");
d911 1
a911 1
			perror("sun_revents: PERROR");
d921 1
a921 1
			perror("sun_revents: RERROR");
d936 1
a936 1
			perror("sun_revents: GETOOFFS");
d948 1
a948 1
			perror("sun_revents: GETIOFFS");
@


1.7
log
@make both aucat(1) and audio(4) backends use the AUDIODEVICE env
variable to determine the socket or the device to use. Allow
choosing the when aucat(1) is used too. Noticed and
tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.6 2008/11/20 08:32:03 ratchov Exp $	*/
d497 1
a497 1
	par.bufsz = 1200;
d642 1
a642 1
	bufsz = par->bufsz;
d754 2
a755 1
	par->bufsz = aui.hiwat * par->round;
@


1.6
log
@while setting the block size, try smaller blocks half of the retries and
larger blocks the other half. That's because shrinking the block size may
not be the right direction to go to find a common block size for play and
record.
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.5 2008/11/11 19:39:35 ratchov Exp $	*/
d456 2
a457 5
	if (path == NULL) {
		path = getenv("AUDIODEVICE");
		if (path == NULL)
			path = SIO_SUN_PATH;
	}
@


1.5
log
@expose a volume knob in the sndio API: add sio_setvol(3) and
sio_onvol(3) functions. The audio(4) backend tries to use the
inputs.dac, outputs.dac, outputs.output and outputs.master
controls (in this order). Add a sample file in
regress/lib/libsndio/vol/vol.c
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.4 2008/11/07 21:01:15 ratchov Exp $	*/
d615 1
d669 4
d677 1
a677 1
	for (i = 0; i < 5; i++) {
d697 7
d708 5
a712 1
		if (hdl->sa.mode != (SIO_REC | SIO_PLAY) || infr == onfr)
d714 1
d717 2
a718 1
		 * retry with the smaller returned value
d720 4
a723 1
		round = infr < onfr ? infr : onfr;
d728 1
@


1.4
log
@expose the block size in the sndio API by making par->round writable
and thus remove the ugly rate <-> block-size table from
sio_setpar(3). Handle the block size negociation in aucat(1), since
it has few constrains the code is overally simpler.
ok jakemsr@@, major crank suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.2 2008/10/28 23:02:54 ratchov Exp $	*/
d32 2
d53 3
d68 2
d81 16
a96 1
	sun_revents
d343 100
d473 1
d942 1
@


1.3
log
@only few (frequency, blocksize) pairs are compatible with both resampling
and block based audio i/o (arithmetic constraints). For now round the
frequency to a supported one, (ie 8kHz, 11.025kHz, 12kHz multiple), and get
the the block size from a table.

fixes problem reported by Robert <robert _at_ openbsd.pap.st>
ok jakemsr
@
text
@a76 191
struct sun_rate {
	unsigned rate;
	unsigned *blksz;
};

unsigned sun_blksz_8000Hz[] = {
	40, 48, 56, 64, 72, 80, 88, 96,
	104, 112, 120, 125, 128, 136, 144, 152,
	160, 168, 176, 184, 192, 200, 208, 216,
	224, 232, 240, 248, 250, 256, 264, 272,
	280, 288, 296, 304, 312, 320, 328, 336,
	344, 352, 360, 368, 375, 376, 384, 392,
	400, 408, 416, 424, 432, 440, 448, 456,
	464, 472, 480, 488, 496, 500, 504, 512,
	520, 528, 536, 544, 552, 560, 568, 576,
	584, 592, 600, 608, 616, 624, 625, 632,
	640, 648, 656, 664, 672, 680, 688, 696,
	704, 712, 720, 728, 736, 744, 750, 752,
	760, 768, 776, 784, 792, 800, 0
};
unsigned sun_blksz_11025Hz[] = {
	105, 210, 225, 245, 315, 420, 441, 450,
	490, 525, 630, 675, 735, 840, 882, 900,
	945, 980, 1050, 0
};
unsigned sun_blksz_12000Hz[] = {
	60, 72, 84, 96, 108, 120, 132, 144,
	156, 168, 180, 192, 200, 204, 216, 228,
	240, 250, 252, 264, 276, 288, 300, 312,
	324, 336, 348, 360, 372, 375, 384, 396,
	400, 408, 420, 432, 444, 456, 468, 480,
	492, 500, 504, 516, 528, 540, 552, 564,
	576, 588, 600, 612, 624, 636, 648, 660,
	672, 684, 696, 708, 720, 732, 744, 750,
	756, 768, 780, 792, 800, 804, 816, 828,
	840, 852, 864, 876, 888, 900, 912, 924,
	936, 948, 960, 972, 984, 996, 1000, 1008,
	1020, 1032, 1044, 1056, 1068, 1080, 1092, 1104,
	1116, 1125, 1128, 1140, 1152, 1164, 1176, 1188,
	1200, 0
};
unsigned sun_blksz_16000Hz[] = {
	80, 96, 112, 128, 144, 160, 176, 192,
	208, 224, 240, 250, 256, 272, 288, 304,
	320, 336, 352, 368, 384, 400, 416, 432,
	448, 464, 480, 496, 500, 512, 528, 544,
	560, 576, 592, 608, 624, 640, 656, 672,
	688, 704, 720, 736, 750, 752, 768, 784,
	800, 816, 832, 848, 864, 880, 896, 912,
	928, 944, 960, 976, 992, 1000, 1008, 1024,
	1040, 1056, 1072, 1088, 1104, 1120, 1136, 1152,
	1168, 1184, 1200, 1216, 1232, 1248, 1250, 1264,
	1280, 1296, 1312, 1328, 1344, 1360, 1376, 1392,
	1408, 1424, 1440, 1456, 1472, 1488, 1500, 1504,
	1520, 1536, 1552, 1568, 1584, 1600, 0
};
unsigned sun_blksz_22050Hz[] = {
	210, 315, 420, 441, 450, 490, 525, 630,
	735, 840, 882, 900, 945, 980, 1050, 1225,
	1260, 1323, 1350, 1470, 1575, 1680, 1764, 1800,
	1890, 1960, 2100, 2205, 0
};
unsigned sun_blksz_24000Hz[] = {
	120, 144, 168, 192, 216, 240, 264, 288,
	312, 336, 360, 375, 384, 400, 408, 432,
	456, 480, 500, 504, 528, 552, 576, 600,
	624, 648, 672, 696, 720, 744, 750, 768,
	792, 800, 816, 840, 864, 888, 912, 936,
	960, 984, 1000, 1008, 1032, 1056, 1080, 1104,
	1125, 1128, 1152, 1176, 1200, 1224, 1248, 1272,
	1296, 1320, 1344, 1368, 1392, 1416, 1440, 1464,
	1488, 1500, 1512, 1536, 1560, 1584, 1600, 1608,
	1632, 1656, 1680, 1704, 1728, 1752, 1776, 1800,
	1824, 1848, 1872, 1875, 1896, 1920, 1944, 1968,
	1992, 2000, 2016, 2040, 2064, 2088, 2112, 2136,
	2160, 2184, 2208, 2232, 2250, 2256, 2280, 2304,
	2328, 2352, 2376, 2400, 0
};
unsigned sun_blksz_32000Hz[] = {
	160, 192, 224, 256, 288, 320, 352, 384,
	416, 448, 480, 500, 512, 544, 576, 608,
	640, 672, 704, 736, 768, 800, 832, 864,
	896, 928, 960, 992, 1000, 1024, 1056, 1088,
	1120, 1152, 1184, 1216, 1248, 1280, 1312, 1344,
	1376, 1408, 1440, 1472, 1500, 1504, 1536, 1568,
	1600, 1632, 1664, 1696, 1728, 1760, 1792, 1824,
	1856, 1888, 1920, 1952, 1984, 2000, 2016, 2048,
	2080, 2112, 2144, 2176, 2208, 2240, 2272, 2304,
	2336, 2368, 2400, 2432, 2464, 2496, 2500, 2528,
	2560, 2592, 2624, 2656, 2688, 2720, 2752, 2784,
	2816, 2848, 2880, 2912, 2944, 2976, 3000, 3008,
	3040, 3072, 3104, 3136, 3168, 3200, 0
};
unsigned sun_blksz_44100Hz[] = {
	420, 441, 630, 735, 840, 882, 900, 980,
	1050, 1225, 1260, 1323, 1470, 1575, 1680, 1764,
	1800, 1890, 1960, 2100, 2205, 2450, 2520, 2646,
	2700, 2940, 3087, 3150, 3360, 3528, 3600, 3675,
	3780, 3920, 3969, 4200, 4410, 0
};
unsigned sun_blksz_48000Hz[] = {
	240, 288, 336, 384, 432, 480, 528, 576,
	624, 672, 720, 750, 768, 800, 816, 864,
	912, 960, 1000, 1008, 1056, 1104, 1152, 1200,
	1248, 1296, 1344, 1392, 1440, 1488, 1500, 1536,
	1584, 1600, 1632, 1680, 1728, 1776, 1824, 1872,
	1920, 1968, 2000, 2016, 2064, 2112, 2160, 2208,
	2250, 2256, 2304, 2352, 2400, 2448, 2496, 2544,
	2592, 2640, 2688, 2736, 2784, 2832, 2880, 2928,
	2976, 3000, 3024, 3072, 3120, 3168, 3200, 3216,
	3264, 3312, 3360, 3408, 3456, 3504, 3552, 3600,
	3648, 3696, 3744, 3750, 3792, 3840, 3888, 3936,
	3984, 4000, 4032, 4080, 4128, 4176, 4224, 4272,
	4320, 4368, 4416, 4464, 4500, 4512, 4560, 4608,
	4656, 4704, 4752, 4800, 0
};
unsigned sun_blksz_64000Hz[] = {
	320, 384, 448, 512, 576, 640, 704, 768,
	832, 896, 960, 1000, 1024, 1088, 1152, 1216,
	1280, 1344, 1408, 1472, 1536, 1600, 1664, 1728,
	1792, 1856, 1920, 1984, 2000, 2048, 2112, 2176,
	2240, 2304, 2368, 2432, 2496, 2560, 2624, 2688,
	2752, 2816, 2880, 2944, 3000, 3008, 3072, 3136,
	3200, 3264, 3328, 3392, 3456, 3520, 3584, 3648,
	3712, 3776, 3840, 3904, 3968, 4000, 4032, 4096,
	4160, 4224, 4288, 4352, 4416, 4480, 4544, 4608,
	4672, 4736, 4800, 4864, 4928, 4992, 5000, 5056,
	5120, 5184, 5248, 5312, 5376, 5440, 5504, 5568,
	5632, 5696, 5760, 5824, 5888, 5952, 6000, 6016,
	6080, 6144, 6208, 6272, 6336, 6400, 0
};
unsigned sun_blksz_88200Hz[] = {
	441, 840, 882, 1225, 1260, 1323, 1470, 1680,
	1764, 1800, 1960, 2100, 2205, 2450, 2520, 2646,
	2940, 3087, 3150, 3360, 3528, 3600, 3675, 3780,
	3920, 3969, 4200, 4410, 4851, 4900, 5040, 5292,
	5400, 5733, 5880, 6125, 6174, 6300, 6615, 6720,
	7056, 7200, 7350, 7497, 7560, 7840, 7938, 8379,
	8400, 8575, 8820, 0
};
unsigned sun_blksz_96000Hz[] = {
	480, 576, 672, 768, 864, 960, 1056, 1152,
	1248, 1344, 1440, 1500, 1536, 1600, 1632, 1728,
	1824, 1920, 2000, 2016, 2112, 2208, 2304, 2400,
	2496, 2592, 2688, 2784, 2880, 2976, 3000, 3072,
	3168, 3200, 3264, 3360, 3456, 3552, 3648, 3744,
	3840, 3936, 4000, 4032, 4128, 4224, 4320, 4416,
	4500, 4512, 4608, 4704, 4800, 4896, 4992, 5088,
	5184, 5280, 5376, 5472, 5568, 5664, 5760, 5856,
	5952, 6000, 6048, 6144, 6240, 6336, 6400, 6432,
	6528, 6624, 6720, 6816, 6912, 7008, 7104, 7200,
	7296, 7392, 7488, 7500, 7584, 7680, 7776, 7872,
	7968, 8000, 8064, 8160, 8256, 8352, 8448, 8544,
	8640, 8736, 8832, 8928, 9000, 9024, 9120, 9216,
	9312, 9408, 9504, 9600, 0
};
struct sun_rate sun_rates[] = {
	{ 8000, sun_blksz_8000Hz },
	{ 11025, sun_blksz_11025Hz },
	{ 12000, sun_blksz_12000Hz },
	{ 16000, sun_blksz_16000Hz },
	{ 22050, sun_blksz_22050Hz },
	{ 24000, sun_blksz_24000Hz },
	{ 32000, sun_blksz_32000Hz },
	{ 44100, sun_blksz_44100Hz },
	{ 48000, sun_blksz_48000Hz },
	{ 64000, sun_blksz_64000Hz },
	{ 88200, sun_blksz_88200Hz },
	{ 96000, sun_blksz_96000Hz }
};

#define SUN_MAXNRATES (sizeof(sun_rates) / sizeof(struct sun_rate))

/*
 * return the closest supported rate
 */
struct sun_rate *
sun_findrate(unsigned rate)
{
	unsigned i;

	if (rate <= sun_rates[0].rate)
		return &sun_rates[0];

	for (i = 0; i < SUN_MAXNRATES - 1; i++) {
		if (rate < (sun_rates[i].rate + sun_rates[i + 1].rate) / 2)
			return &sun_rates[i];
	}
	return &sun_rates[SUN_MAXNRATES];
}

a135 80
 * calculate and set the largest possible block size, such that
 * play and record blocks have the same frames number
 */
int
sun_setnfr(struct sun_hdl *hdl, unsigned bufsz)
{
	struct audio_info aui;	
	struct sio_par np;
	struct sun_rate *nr;
	unsigned nfr, infr = 0, onfr = 0, ibpf, obpf;
	int i;

	if (!sio_getpar(&hdl->sa, &np))
		return 0;
	nr = sun_findrate(np.rate);
	if (nr->rate != np.rate) {
		fprintf(stderr, "sun_setnfr: warning, unknown rate\n");
	}
	ibpf = (hdl->sa.mode & SIO_REC) ? np.rchan * np.bps : 1;
	obpf = (hdl->sa.mode & SIO_PLAY) ? np.pchan * np.bps : 1;

	/*
	 * if no bufsz is given, use 200ms which is ok in most cases
	 */
	if (bufsz == 0)
		bufsz = (np.rate * 200 + 999) / 1000;
	if (bufsz < 32)
		bufsz = 32;

	for (i = 0; nr->blksz[i] != 0; i++) {
		nfr = nr->blksz[i];
		AUDIO_INITINFO(&aui);
		aui.hiwat = (bufsz + nfr - 1) / nfr;
		aui.lowat = aui.hiwat;
		if (hdl->sa.mode & SIO_REC)
			aui.record.block_size = nfr * ibpf;
		if (hdl->sa.mode & SIO_PLAY)
			aui.play.block_size = nfr * obpf;
		if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
			perror("sun_setnfr: SETINFO");
			hdl->sa.eof = 1;
			return 0;
		}
		if (ioctl(hdl->fd, AUDIO_GETINFO, &aui) < 0) {
			perror("sun_setnfr: GETINFO");
			hdl->sa.eof = 1;
			return 0;
		}
		infr = aui.record.block_size / ibpf;
		onfr = aui.play.block_size / obpf;
		if (hdl->sa.debug) {
			fprintf(stderr, "sun_setnfr: %u -> (%u, %u)\n",
			    nfr, infr, onfr);
		}

		/*
		 * accept only block sizes of the table
		 */
		if ((hdl->sa.mode & SIO_REC) && infr != nfr)
			continue;
		if ((hdl->sa.mode & SIO_PLAY) && onfr != nfr)
			continue;
		return (hdl->sa.mode & SIO_REC) ? infr : onfr;
	}

	/*
	 * failed to find ``optimal'' block size, try using the one the
	 * hardware returned. We require both block sizes match, unless
	 * we're not in full-duplex
	 */
	if (hdl->sa.mode != (SIO_REC | SIO_PLAY) || infr == onfr) {
		fprintf(stderr, "sun_setnfr: using sub optimal block size\n");
		return (hdl->sa.mode & SIO_REC) ? infr : onfr;
	}
	fprintf(stderr, "sun_setnfr: couldn't find a working blocksize\n");
	hdl->sa.eof = 1;
	return 0;
}

/*
d326 1
d364 9
a372 6

	/*
	 * this is required to set the block size, choose a sample rate
	 * such that the block size is in the ``optimal'' blocksize
	 * range.
	 */
d374 1
a374 1
	par.le = 1;
d377 1
a377 3
	par.pchan = 2;
	par.rchan = 2;
	par.rate = 48000;	
d493 3
a495 2
	struct audio_info aui;	
	struct sun_rate *r;
d498 1
a498 1
	 * the only ones supported by Sun API
a499 8
	par->bps = SIO_BPS(par->bits);
	par->msb = 1;
	par->xrun = SIO_IGNORE;
	if (par->rate != (unsigned)~0) {
		r = sun_findrate(par->rate);
		par->rate = r->rate;
	}

d510 1
a510 2
	}	
	aui.lowat = 1;
d516 49
a564 2
	if (par->bufsz != (unsigned)~0) {
		if (!sun_setnfr(hdl, par->bufsz))
d566 14
d581 3
a583 1
	return 1;
@


1.2
log
@fix missing n in error message
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.1 2008/10/27 00:26:33 ratchov Exp $	*/
d77 191
a326 26
 * deal with audio(4) driver block size rounding weiredness.  Calculate
 * the smallest number of frames such that both play and record blocks
 * are multiples of it. That's because, the audio(4) driver uses the same
 * rounding routine for both play and record buffers, hopefully that
 * will be changed in the future...
 */
unsigned
sun_round(unsigned ibpf, unsigned obpf)
{
	unsigned i, round, p;
	static unsigned primes[] = {2, 3, 5, 7, 11, 13, 17};
#define NPRIMES (sizeof(primes) / sizeof(primes[0]))

	round = ibpf * obpf;
	for (i = 0; i < NPRIMES; i++) {
		p = primes[i];
		while ((ibpf % p) == 0 && (obpf % p) == 0) {
			ibpf /= p;
			obpf /= p;
			round /= p;
		}		
	}
	return round;
}

/*
d335 1
a336 1
	unsigned round;
d341 4
a346 1
	round = sun_round(ibpf, obpf);
d356 2
a357 14
	/*
	 * use 12ms block size, unless 12ms is larger than bufsz / 2 
	 */
	nfr = (np.rate * 12 + 999) / 1000;
	if (2 * nfr > bufsz)
		nfr = bufsz / 2;
	nfr += round - 1;
	nfr -= nfr % round;

	/*
	 * try to set parameters until the device accepts
	 * a common block size for play and record
	 */
	for (i = 0; i < 5; i++) {
d362 1
a362 1
			aui.record.block_size = (nfr - nfr % round) * ibpf;
d364 1
a364 1
			aui.play.block_size = (nfr - nfr % round) * obpf;
d377 4
d383 1
a383 1
		 * if half-duplex or both block sizes match, it's ok
d385 6
a390 2
		if (hdl->sa.mode != (SIO_REC | SIO_PLAY) || infr == onfr)
			return (hdl->sa.mode & SIO_REC) ? infr : onfr;
d392 8
a399 7
		/*
		 * retry with the smaller returned value
		 */
		if ((hdl->sa.mode & SIO_REC) && nfr > infr)
			nfr = infr;
		if ((hdl->sa.mode & SIO_PLAY) && nfr > onfr)
			nfr = onfr;
d597 1
a597 1
	struct audio_info aui;
d634 14
a647 10
	AUDIO_INITINFO(&aui);
	if (hdl->sa.mode & SIO_PLAY)
		aui.play.encoding = AUDIO_ENCODING_SLINEAR;
	if (hdl->sa.mode & SIO_REC)
		aui.record.encoding = AUDIO_ENCODING_SLINEAR;
	if (ioctl(hdl->fd, AUDIO_SETINFO, &aui) < 0) {
		perror("sio_open_sun: setinfo");
		goto bad_close;
	}
	if (!sun_setnfr(hdl, 0))
d763 1
d771 4
@


1.1
log
@rename libsa to libsndio
requested by many, "just go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sun.c,v 1.1 2008/10/26 08:49:44 ratchov Exp $	*/
d464 1
a464 1
			fprintf(stderr, "%s: can't set full-duplex", path);
@

