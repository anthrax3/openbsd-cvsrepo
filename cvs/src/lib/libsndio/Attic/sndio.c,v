head	1.28;
access;
symbols
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14;
locks; strict;
comment	@ * @;


1.28
date	2011.04.08.11.18.07;	author ratchov;	state dead;
branches;
next	1.27;

1.27
date	2010.11.06.20.25.42;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.20.06.56.53;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.24.06.15.54;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.28.10.52.14;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.28.06.37.06;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.27.06.30.34;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.26.15.50.04;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.26.13.33.30;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.26.12.38.20;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.25.11.15.56;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.25.08.44.27;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.15.13.04.52;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.09.07.00.27;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.10.20.34.44;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.27.11.35.50;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.21.10.03.25;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.17.10.00.50;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.17.07.31.38;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.17.07.19.27;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.20.16.31.26;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.11.19.39.35;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.09.15.32.50;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.09.12.22.27;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.07.21.01.15;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.10.28.23.00.08;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.27.00.26.33;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Clean up function naming: use sio_<backend>_ prefix for private
audio-related functions and put them in files named sio_<backend>.c
No behaviour changes.
@
text
@/*	$OpenBSD: sndio.c,v 1.27 2010/11/06 20:25:42 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>

#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "sndio_priv.h"

#define SIO_PAR_MAGIC	0x83b905a4

#ifdef DEBUG
/*
 * debug level, -1 means uninitialized
 */
int sio_debug = -1;
#endif

void
sio_initpar(struct sio_par *par)
{
	memset(par, 0xff, sizeof(struct sio_par));
	par->__magic = SIO_PAR_MAGIC;
}

struct sio_hdl *
sio_open(const char *str, unsigned mode, int nbio)
{
	static char prefix_aucat[] = "aucat";
	static char prefix_sun[] = "sun";
	struct sio_hdl *hdl;
	struct stat sb;
	char *sep, buf[NAME_MAX];
	int len;
#ifdef DEBUG
	char *dbg;

	if (sio_debug < 0) {
		dbg = issetugid() ? NULL : getenv("SIO_DEBUG");
		if (!dbg || sscanf(dbg, "%u", &sio_debug) != 1)
			sio_debug = 0;
	}
#endif
	if ((mode & (SIO_PLAY | SIO_REC)) == 0)
		return NULL;
	if (str == NULL && !issetugid())
		str = getenv("AUDIODEVICE");
	if (str == NULL) {
		hdl = sio_open_aucat("0", mode, nbio);
		if (hdl != NULL)
			return hdl;
		if (stat("/dev/audio", &sb) == 0 && S_ISCHR(sb.st_mode)) {
			snprintf(buf, sizeof(buf), "%u",
			    minor(sb.st_rdev) & 0xf);
		} else
			strlcpy(buf, "0", sizeof(buf));
		hdl = sio_open_sun(buf, mode, nbio);
		if (hdl != NULL)
			return hdl;
		return NULL;
	}
	sep = strchr(str, ':');
	if (sep == NULL) {
		/*
		 * try legacy "/dev/audioxxx" or ``socket'' device name
		 */
		if (stat(str, &sb) < 0 || !S_ISCHR(sb.st_mode)) {
			snprintf(buf, sizeof(buf), "0.%s", str);
			return sio_open_aucat(buf, mode, nbio);
		}
		snprintf(buf, sizeof(buf), "%u", minor(sb.st_rdev) & 0xf);
		return sio_open_sun(buf, mode, nbio);
	}
	len = sep - str;
	if (len == (sizeof(prefix_aucat) - 1) &&
	    memcmp(str, prefix_aucat, len) == 0)
		return sio_open_aucat(sep + 1, mode, nbio);
	if (len == (sizeof(prefix_sun) - 1) &&
	    memcmp(str, prefix_sun, len) == 0)
		return sio_open_sun(sep + 1, mode, nbio);
	DPRINTF("sio_open: %s: unknown device type\n", str);
	return NULL;
}

void
sio_create(struct sio_hdl *hdl, struct sio_ops *ops, unsigned mode, int nbio)
{
	hdl->ops = ops;
	hdl->mode = mode;
	hdl->nbio = nbio;
	hdl->started = 0;
	hdl->eof = 0;
	hdl->move_cb = NULL;
	hdl->vol_cb = NULL;
}

void
sio_close(struct sio_hdl *hdl)
{
	hdl->ops->close(hdl);
}

int
sio_start(struct sio_hdl *hdl)
{
	if (hdl->eof) {
		DPRINTF("sio_start: eof\n");
		return 0;
	}
	if (hdl->started) {
		DPRINTF("sio_start: already started\n");
		hdl->eof = 1;
		return 0;
	}
#ifdef DEBUG
	if (!sio_getpar(hdl, &hdl->par))
		return 0;
	hdl->pollcnt = hdl->wcnt = hdl->rcnt = hdl->realpos = 0;
	gettimeofday(&hdl->tv, NULL);
#endif
	if (!hdl->ops->start(hdl))
		return 0;
	hdl->started = 1;
	return 1;
}

int
sio_stop(struct sio_hdl *hdl)
{
	if (hdl->eof) {
		DPRINTF("sio_stop: eof\n");
		return 0;
	}
	if (!hdl->started) {
		DPRINTF("sio_stop: not started\n");
		hdl->eof = 1;
		return 0;
	}
	if (!hdl->ops->stop(hdl))
		return 0;
#ifdef DEBUG
	DPRINTF("libsndio: polls: %llu, written = %llu, read: %llu\n",
	    hdl->pollcnt, hdl->wcnt, hdl->rcnt);
#endif
	hdl->started = 0;
	return 1;
}

int
sio_setpar(struct sio_hdl *hdl, struct sio_par *par)
{
	if (hdl->eof) {
		DPRINTF("sio_setpar: eof\n");
		return 0;
	}
	if (par->__magic != SIO_PAR_MAGIC) {
		DPRINTF("sio_setpar: use of uninitialized sio_par structure\n");
		hdl->eof = 1;
		return 0;
	}
	if (hdl->started) {
		DPRINTF("sio_setpar: already started\n");
		hdl->eof = 1;
		return 0;
	}
	if (par->bufsz != ~0U) {
		DPRINTF("sio_setpar: setting bufsz is deprecated\n");
		par->appbufsz = par->bufsz;
	}
	if (par->rate != ~0U && par->appbufsz == ~0U)
		par->appbufsz = par->rate * 200 / 1000;
	return hdl->ops->setpar(hdl, par);
}

int
sio_getpar(struct sio_hdl *hdl, struct sio_par *par)
{
	if (hdl->eof) {
		DPRINTF("sio_getpar: eof\n");
		return 0;
	}
	if (hdl->started) {
		DPRINTF("sio_getpar: already started\n");
		hdl->eof = 1;
		return 0;
	}
	if (!hdl->ops->getpar(hdl, par)) {
		par->__magic = 0;
		return 0;
	}
	par->__magic = 0;
	return 1;
}

int
sio_getcap(struct sio_hdl *hdl, struct sio_cap *cap)
{
	if (hdl->eof) {
		DPRINTF("sio_getcap: eof\n");
		return 0;
	}
	if (hdl->started) {
		DPRINTF("sio_getcap: already started\n");
		hdl->eof = 1;
		return 0;
	}
	return hdl->ops->getcap(hdl, cap);
}

static int
sio_psleep(struct sio_hdl *hdl, int event)
{
	struct pollfd pfd;
	int revents;

	for (;;) {
		sio_pollfd(hdl, &pfd, event);
		while (poll(&pfd, 1, -1) < 0) {
			if (errno == EINTR)
				continue;
			DPERROR("sio_psleep: poll");
			hdl->eof = 1;
			return 0;
		}
		revents = sio_revents(hdl, &pfd);
		if (revents & POLLHUP) {
			DPRINTF("sio_psleep: hang-up\n");
			return 0;
		}
		if (revents & event)
			break;
	}
	return 1;
}

size_t
sio_read(struct sio_hdl *hdl, void *buf, size_t len)
{
	unsigned n;
	char *data = buf;
	size_t todo = len;

	if (hdl->eof) {
		DPRINTF("sio_read: eof\n");
		return 0;
	}
	if (!hdl->started || !(hdl->mode & SIO_REC)) {
		DPRINTF("sio_read: recording not started\n");
		hdl->eof = 1;
		return 0;
	}
	if (todo == 0) {
		DPRINTF("sio_read: zero length read ignored\n");
		return 0;
	}
	while (todo > 0) {
		n = hdl->ops->read(hdl, data, todo);
		if (n == 0) {
			if (hdl->nbio || hdl->eof || todo < len)
				break;
			if (!sio_psleep(hdl, POLLIN))
				break;
			continue;
		}
		data += n;
		todo -= n;
#ifdef DEBUG
		hdl->rcnt += n;
#endif
	}
	return len - todo;
}

size_t
sio_write(struct sio_hdl *hdl, const void *buf, size_t len)
{
	unsigned n;
	const unsigned char *data = buf;
	size_t todo = len;
#ifdef DEBUG
	struct timeval tv0, tv1, dtv;
	unsigned us;

	if (sio_debug >= 2)
		gettimeofday(&tv0, NULL);
#endif

	if (hdl->eof) {
		DPRINTF("sio_write: eof\n");
		return 0;
	}
	if (!hdl->started || !(hdl->mode & SIO_PLAY)) {
		DPRINTF("sio_write: playback not started\n");
		hdl->eof = 1;
		return 0;
	}
	if (todo == 0) {
		DPRINTF("sio_write: zero length write ignored\n");
		return 0;
	}
	while (todo > 0) {
		n = hdl->ops->write(hdl, data, todo);
		if (n == 0) {
			if (hdl->nbio || hdl->eof)
				break;
			if (!sio_psleep(hdl, POLLOUT))
				break;
			continue;
		}
		data += n;
		todo -= n;
#ifdef DEBUG
		hdl->wcnt += n;
#endif
	}
#ifdef DEBUG
	if (sio_debug >= 2) {
		gettimeofday(&tv1, NULL);
		timersub(&tv0, &hdl->tv, &dtv);
		DPRINTF("%ld.%06ld: ", dtv.tv_sec, dtv.tv_usec);

		timersub(&tv1, &tv0, &dtv);
		us = dtv.tv_sec * 1000000 + dtv.tv_usec;
		DPRINTF(
		    "sio_write: wrote %d bytes of %d in %uus\n",
		    (int)(len - todo), (int)len, us);
	}
#endif
	return len - todo;
}

int
sio_nfds(struct sio_hdl *hdl)
{
	/*
	 * In the future we might use larger values
	 */
	return 1;
}

int
sio_pollfd(struct sio_hdl *hdl, struct pollfd *pfd, int events)
{
	if (hdl->eof)
		return 0;
	if (!hdl->started)
		events = 0;
	return hdl->ops->pollfd(hdl, pfd, events);
}

int
sio_revents(struct sio_hdl *hdl, struct pollfd *pfd)
{
	int revents;
#ifdef DEBUG
	struct timeval tv0, tv1, dtv;
	unsigned us;

	if (sio_debug >= 2)
		gettimeofday(&tv0, NULL);
#endif
	if (hdl->eof)
		return POLLHUP;
#ifdef DEBUG
	hdl->pollcnt++;
#endif
	revents = hdl->ops->revents(hdl, pfd);
	if (!hdl->started)
		return revents & POLLHUP;
#ifdef DEBUG
	if (sio_debug >= 2) {
		gettimeofday(&tv1, NULL);
		timersub(&tv0, &hdl->tv, &dtv);
		DPRINTF("%ld.%06ld: ", dtv.tv_sec, dtv.tv_usec);

		timersub(&tv1, &tv0, &dtv);
		us = dtv.tv_sec * 1000000 + dtv.tv_usec;
		DPRINTF("sio_revents: revents = 0x%x, complete in %uus\n",
		    revents, us);
	}
#endif
	return revents;
}

int
sio_eof(struct sio_hdl *hdl)
{
	return hdl->eof;
}

void
sio_onmove(struct sio_hdl *hdl, void (*cb)(void *, int), void *addr)
{
	if (hdl->started) {
		DPRINTF("sio_onmove: already started\n");
		hdl->eof = 1;
		return;
	}
	hdl->move_cb = cb;
	hdl->move_addr = addr;
}

void
sio_onmove_cb(struct sio_hdl *hdl, int delta)
{
#ifdef DEBUG
	struct timeval tv0, dtv;
	long long playpos;

	if (sio_debug >= 3 && (hdl->mode & SIO_PLAY)) {
		gettimeofday(&tv0, NULL);
		timersub(&tv0, &hdl->tv, &dtv);
		DPRINTF("%ld.%06ld: ", dtv.tv_sec, dtv.tv_usec);
		hdl->realpos += delta;
		playpos = hdl->wcnt / (hdl->par.bps * hdl->par.pchan);
		DPRINTF("sio_onmove_cb: delta = %+7d, "
		    "plat = %+7lld, "
		    "realpos = %+7lld, "
		    "bufused = %+7lld\n",
		    delta,
		    playpos - hdl->realpos,
		    hdl->realpos,
		    hdl->realpos < 0 ? playpos : playpos - hdl->realpos);
	}
#endif
	if (hdl->move_cb)
		hdl->move_cb(hdl->move_addr, delta);
}

int
sio_setvol(struct sio_hdl *hdl, unsigned ctl)
{
	if (hdl->eof)
		return 0;
	if (!hdl->ops->setvol)
		return 1;
	if (!hdl->ops->setvol(hdl, ctl))
		return 0;
	hdl->ops->getvol(hdl);
	return 1;
}

int
sio_onvol(struct sio_hdl *hdl, void (*cb)(void *, unsigned), void *addr)
{
	if (hdl->started) {
		DPRINTF("sio_onvol: already started\n");
		hdl->eof = 1;
		return 0;
	}
	if (!hdl->ops->setvol)
		return 0;
	hdl->vol_cb = cb;
	hdl->vol_addr = addr;
	hdl->ops->getvol(hdl);
	return 1;
}

void
sio_onvol_cb(struct sio_hdl *hdl, unsigned ctl)
{
	if (hdl->vol_cb)
		hdl->vol_cb(hdl->vol_addr, ctl);
}
@


1.27
log
@make sio_onvol(3) return a integer exposing whether a volume knob
is available for the stream. As we're at it, remove macros and
functions that are neither used nor documented.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.26 2010/08/20 06:56:53 ratchov Exp $	*/
@


1.26
log
@polish the code: remove few unused #includes, add missing ones,
fix NULL vs 0, etc. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.25 2010/04/24 06:15:54 ratchov Exp $	*/
a48 120
/*
 * Generate a string corresponding to the encoding in par,
 * return the length of the resulting string
 */
int
sio_enctostr(struct sio_par *par, char *ostr)
{
	char *p = ostr;

	*p++ = par->sig ? 's' : 'u';
	if (par->bits > 9)
		*p++ = '0' + par->bits / 10;
	*p++ = '0' + par->bits % 10;
	if (par->bps > 1) {
		*p++ = par->le ? 'l' : 'b';
		*p++ = 'e';
		if (par->bps != SIO_BPS(par->bits) ||
		    par->bits < par->bps * 8) {
			*p++ = par->bps + '0';
			if (par->bits < par->bps * 8) {
				*p++ = par->msb ? 'm' : 'l';
				*p++ = 's';
				*p++ = 'b';
			}
		}
	}
	*p++ = '\0';
	return p - ostr - 1;
}

/*
 * Parse an encoding string, examples: s8, u8, s16, s16le, s24be ...
 * Return the number of bytes consumed
 */
int
sio_strtoenc(struct sio_par *par, char *istr)
{
	char *p = istr;
	int i, sig, bits, le, bps, msb;

#define IS_SEP(c)			\
	(((c) < 'a' || (c) > 'z') &&	\
	 ((c) < 'A' || (c) > 'Z') &&	\
	 ((c) < '0' || (c) > '9'))

	/*
	 * get signedness
	 */
	if (*p == 's') {
		sig = 1;
	} else if (*p == 'u') {
		sig = 0;
	} else
		return 0;
	p++;

	/*
	 * get number of bits per sample
	 */
	bits = 0;
	for (i = 0; i < 2; i++) {
		if (*p < '0' || *p > '9')
			break;
		bits = (bits * 10) + *p - '0';
		p++;
	}
	if (bits < 1 || bits > 32)
		return 0;
	bps = SIO_BPS(bits);
	le = SIO_LE_NATIVE;
	msb = 1;

	/*
	 * get (optional) endianness
	 */
	if (p[0] == 'l' && p[1] == 'e') {
		le = 1;
		p += 2;
	} else if (p[0] == 'b' && p[1] == 'e') {
		le = 0;
		p += 2;
	} else if (IS_SEP(*p)) {
		goto done;
	} else
		return 0;

	/*
	 * get (optional) number of bytes
	 */
	if (*p >= '1' && *p <= '4') {
		bps = *p - '0';
		if (bps * 8  < bits)
			return 0;
		p++;

		/*
		 * get (optional) alignment
		 */
		if (p[0] == 'm' && p[1] == 's' && p[2] == 'b') {
			msb = 1;
			p += 3;
		} else if (p[0] == 'l' && p[1] == 's' && p[2] == 'b') {
			msb = 0;
			p += 3;
		} else if (IS_SEP(*p)) {
			goto done;
		} else
			return 0;
	} else if (!IS_SEP(*p))
		return 0;

done:
       	par->msb = msb;
	par->sig = sig;
	par->bits = bits;
	par->bps = bps;
	par->le = le;
	return p - istr;
}

d458 2
d466 1
a466 1
void
d472 1
a472 1
		return;
d474 2
d479 1
@


1.25
log
@remove trailing spaces, from Alexandr Shadchin, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.24 2010/04/06 20:07:01 ratchov Exp $	*/
d200 4
a203 1
		return sio_open_sun(buf, mode, nbio);
@


1.24
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.23 2009/08/28 10:52:14 ratchov Exp $	*/
d46 1
a46 1
	par->__magic = SIO_PAR_MAGIC;	   
d88 1
a88 1
	
d104 1
a104 1
	
d186 1
a186 1
#endif	
d463 1
a463 1
		us = dtv.tv_sec * 1000000 + dtv.tv_usec; 
d493 1
a493 1
{	
d517 1
a517 1
		us = dtv.tv_sec * 1000000 + dtv.tv_usec; 
d598 1
a598 1
		hdl->vol_cb(hdl->vol_addr, ctl);	
@


1.23
log
@don't consider calling sio_close() without calling sio_stop() first
as a programming error. At any stage the program should be alble to
cleanly free resources and close the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.22 2009/08/28 06:37:06 ratchov Exp $	*/
d550 1
a550 1
	if (sio_debug >= 2 && (hdl->mode & SIO_PLAY)) {
@


1.22
log
@add a new AMSG_BYE, sent by the client to requst the server to
free resources and drop the connection. This allows the client
to ensuire that at any time it's using only one connection, thus
only one MIDI control channel.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.21 2009/07/27 06:30:34 ratchov Exp $	*/
a239 4
	if (!hdl->eof && hdl->started) {
		DPRINTF("sio_close: not stopped\n");
		hdl->eof = 1;
	}
@


1.21
log
@don't use ``return'' in sio_close() and mio_close()
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.20 2009/07/26 15:50:04 ratchov Exp $	*/
d240 4
@


1.20
log
@more style improvemets, from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.19 2009/07/26 13:33:30 ratchov Exp $	*/
d240 1
a240 1
	return hdl->ops->close(hdl);
@


1.19
log
@use ``sizeof(string) - 1'' rather than ``strlen(string)'' on static
strings. suggested by Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.18 2009/07/26 12:38:20 ratchov Exp $	*/
d306 1
a306 1
	if (par->bufsz != (unsigned)~0) {
d310 1
a310 1
	if (par->rate != (unsigned)~0 && par->appbufsz == (unsigned)~0)
@


1.18
log
@sort and space headers as per style(9)
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.17 2009/07/25 11:15:56 ratchov Exp $	*/
d215 1
a215 1
	if (len == strlen(prefix_aucat) &&
d218 1
a218 1
	if (len == strlen(prefix_sun) &&
@


1.17
log
@use const qualifier in libsndio, making it slightly more consistent
with open(2) and write(2) syscalls.
from Thomas Pfaff, jakemsr is fine with it
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.16 2009/07/25 08:44:27 ratchov Exp $	*/
d17 1
d22 1
d27 1
a28 1
#include <stdlib.h>
@


1.16
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.15 2009/05/15 13:04:52 ratchov Exp $	*/
d168 1
a168 1
sio_open(char *str, unsigned mode, int nbio)
d413 1
a413 1
sio_write(struct sio_hdl *hdl, void *buf, size_t len)
d416 1
a416 1
	unsigned char *data = buf;
@


1.15
log
@if DEBUG is defined, use a global debug level rather
than a per-stream debug level. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.14 2009/02/09 07:00:27 ratchov Exp $	*/
d20 1
a166 1

d170 2
d173 3
d189 31
a219 6
	hdl = sio_open_aucat(str, mode, nbio);
	if (hdl != NULL)
		return hdl;
	hdl = sio_open_sun(str, mode, nbio);
	if (hdl != NULL)
		return hdl;
@


1.14
log
@ignore evironment variables if the program is setuid or setgid
explained by deraadt, ok miod, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.13 2009/01/10 20:34:44 ratchov Exp $	*/
d32 6
a37 1
int sio_debug_level = 0;
d171 2
d174 6
a195 7
#ifdef DEBUG
	char *dbg;

	dbg = issetugid() ? NULL : getenv("SIO_DEBUG");
	if (!dbg || sscanf(dbg, "%u", &hdl->debug) != 1)
		hdl->debug = 0;
#endif	
d215 1
a215 1
		DPRINTF(hdl, "sio_start: eof\n");
d219 1
a219 1
		DPRINTF(hdl, "sio_start: already started\n");
d239 1
a239 1
		DPRINTF(hdl, "sio_stop: eof\n");
d243 1
a243 1
		DPRINTF(hdl, "sio_stop: not started\n");
d250 1
a250 2
	DPRINTF(hdl,
	    "libsndio: polls: %llu, written = %llu, read: %llu\n",
d261 1
a261 1
		DPRINTF(hdl, "sio_setpar: eof\n");
d265 1
a265 2
		DPRINTF(hdl,
		    "sio_setpar: use of uninitialized sio_par structure\n");
d270 1
a270 1
		DPRINTF(hdl, "sio_setpar: already started\n");
d275 1
a275 1
		DPRINTF(hdl, "sio_setpar: setting bufsz is deprecated\n");
d287 1
a287 1
		DPRINTF(hdl, "sio_getpar: eof\n");
d291 1
a291 1
		DPRINTF(hdl, "sio_getpar: already started\n");
d307 1
a307 1
		DPRINTF(hdl, "sio_getcap: eof\n");
d311 1
a311 1
		DPRINTF(hdl, "sio_getcap: already started\n");
d329 1
a329 1
			DPERROR(hdl, "sio_psleep: poll");
d335 1
a335 1
			DPRINTF(hdl, "sio_psleep: hang-up\n");
d352 1
a352 1
		DPRINTF(hdl, "sio_read: eof\n");
d356 1
a356 1
		DPRINTF(hdl, "sio_read: recording not started\n");
d361 1
a361 1
		DPRINTF(hdl, "sio_read: zero length read ignored\n");
d392 1
a392 1
	if (hdl->debug >= 2)
d397 1
a397 1
		DPRINTF(hdl, "sio_write: eof\n");
d401 1
a401 1
		DPRINTF(hdl, "sio_write: playback not started\n");
d406 1
a406 1
		DPRINTF(hdl, "sio_write: zero length write ignored\n");
d425 1
a425 1
	if (hdl->debug >= 2) {
d428 1
a428 1
		DPRINTF(hdl, "%ld.%06ld: ", dtv.tv_sec, dtv.tv_usec);
d432 1
a432 1
		DPRINTF(hdl, 
d467 1
a467 1
	if (hdl->debug >= 2)
d479 1
a479 1
	if (hdl->debug >= 2) {
d482 1
a482 1
		DPRINTF(hdl, "%ld.%06ld: ", dtv.tv_sec, dtv.tv_usec);
d486 1
a486 2
		DPRINTF(hdl, 
		    "sio_revents: revents = 0x%x, complete in %uus\n",
d503 1
a503 1
		DPRINTF(hdl, "sio_onmove: already started\n");
d518 1
a518 1
	if (hdl->debug >= 2 && (hdl->mode & SIO_PLAY)) {
d521 1
a521 1
		DPRINTF(hdl, "%ld.%06ld: ", dtv.tv_sec, dtv.tv_usec);
d524 1
a524 2
		DPRINTF(hdl,
		    "sio_onmove_cb: delta = %+7d, "
d553 1
a553 1
		DPRINTF(hdl, "sio_onvol: already started\n");
@


1.13
log
@make all private functions static
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.12 2008/12/27 11:35:50 ratchov Exp $	*/
d169 1
a169 1
	if (str == NULL)
d186 1
a186 1
	dbg = getenv("SIO_DEBUG");
@


1.12
log
@when using the aucat(1) backend, don't mask the POLLHUP bit
even if the device is not started yet. This way, if the server
is killed programs can notice it.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.11 2008/12/21 10:03:25 ratchov Exp $	*/
d314 1
a314 1
int
@


1.11
log
@fix more spelling errors and typos,
from Thomas Pfaff <tpfaff(at)@@tp76.info>, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.10 2008/12/17 10:00:50 ratchov Exp $	*/
a467 2
	if (!hdl->started)
		return 0;
d472 2
@


1.10
log
@stop using stderr in the library, wrap all diagnostic fprintfs
so they are visible only when the DEBUG macro is #defined
and SIO_DEBUG env. variable is set.
requested by many, discussed with jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.9 2008/12/17 07:31:38 ratchov Exp $	*/
d245 1
a245 1
	    "libsio: polls: %llu, written = %llu, read: %llu\n",
@


1.9
log
@fix spell errors, from Thomas Pfaff <tpfaff(at)tp76.info>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.8 2008/12/17 07:19:27 ratchov Exp $	*/
d32 2
d186 1
a186 1
	dbg = getenv("LIBSIO_DEBUG");
d209 1
a209 1
		fprintf(stderr, "sio_start: eof\n");
d213 1
a213 1
		fprintf(stderr, "sio_start: already started\n");
d233 1
a233 1
		fprintf(stderr, "sio_stop: eof\n");
d237 1
a237 1
		fprintf(stderr, "sio_stop: not started\n");
d244 3
a246 4
	if (hdl->debug)
		fprintf(stderr,
		    "libsio: polls: %llu, written = %llu, read: %llu\n",
		    hdl->pollcnt, hdl->wcnt, hdl->rcnt);
d256 1
a256 1
		fprintf(stderr, "sio_setpar: eof\n");
d260 1
a260 1
		fprintf(stderr, 
d266 1
a266 1
		fprintf(stderr, "sio_setpar: already started\n");
d271 1
a271 1
		fprintf(stderr, "sio_setpar: setting bufsz is deprecated\n");
d283 1
a283 1
		fprintf(stderr, "sio_getpar: eof\n");
d287 1
a287 1
		fprintf(stderr, "sio_getpar: already started\n");
d303 1
a303 1
		fprintf(stderr, "sio_getcap: eof\n");
d307 1
a307 1
		fprintf(stderr, "sio_getcap: already started\n");
d325 1
a325 1
			perror("sio_psleep: poll");
d331 1
a331 1
			fprintf(stderr, "sio_psleep: hang-up\n");
d348 1
a348 1
		fprintf(stderr, "sio_read: eof\n");
d352 1
a352 1
		fprintf(stderr, "sio_read: recording not started\n");
d357 1
a357 1
		fprintf(stderr, "sio_read: zero length read ignored\n");
d371 1
d373 1
d393 1
a393 1
		fprintf(stderr, "sio_write: eof\n");
d397 1
a397 1
		fprintf(stderr, "sio_write: playback not started\n");
d402 1
a402 1
		fprintf(stderr, "sio_write: zero length write ignored\n");
d416 1
d418 1
d424 1
a424 1
		fprintf(stderr, "%ld.%06ld: ", dtv.tv_sec, dtv.tv_usec);
d428 1
a428 1
		fprintf(stderr, 
d470 1
d472 1
d478 1
a478 1
		fprintf(stderr, "%ld.%06ld: ", dtv.tv_sec, dtv.tv_usec);
d482 1
a482 1
		fprintf(stderr, 
d500 1
a500 1
		fprintf(stderr, "sio_onmove: already started\n");
d518 1
a518 1
		fprintf(stderr, "%ld.%06ld: ", dtv.tv_sec, dtv.tv_usec);
d521 1
a521 1
		fprintf(stderr,
d551 1
a551 1
		fprintf(stderr, "sio_onvol: already started\n");
@


1.8
log
@add a writable ``appbufsz'' field to the sa_par structure, containing
the program-part of the buffer size, ie the part that is subject to
underruns. Useful for apps like cdio(1) that don't have their own
rings, or to apps that have a minimum ring size constraint. Setting
the ``bufsz'' parameter becomes deprecated.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.7 2008/11/20 16:31:26 ratchov Exp $	*/
d71 1
a71 1
 * Retrun the number of bytes consumed
d112 1
a112 1
	 * get (optionnal) endianness
d126 1
a126 1
	 * get (optionnal) number of bytes
d135 1
a135 1
		 * get (optionnal) alignement
d351 1
a351 1
		fprintf(stderr, "sio_read: recording not stared\n");
d435 1
a435 1
	 * in the futur we might use larger values
d544 1
a544 1
		fprintf(stderr, "sio_onmove: already started\n");
@


1.7
log
@make both aucat(1) and audio(4) backends use the AUDIODEVICE env
variable to determine the socket or the device to use. Allow
choosing the when aucat(1) is used too. Noticed and
tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.6 2008/11/11 19:39:35 ratchov Exp $	*/
d269 6
a274 2
	if (par->rate != (unsigned)~0 && par->bufsz == (unsigned)~0)
		par->bufsz = par->rate * 200 / 1000;
@


1.6
log
@expose a volume knob in the sndio API: add sio_setvol(3) and
sio_onvol(3) functions. The audio(4) backend tries to use the
inputs.dac, outputs.dac, outputs.output and outputs.master
controls (in this order). Add a sample file in
regress/lib/libsndio/vol/vol.c
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.5 2008/11/09 15:32:50 ratchov Exp $	*/
d167 2
@


1.5
log
@if the device is not started, make sio_pollfd() pass 0 events bitmap
to the backend to avoid reporing the device as writable when it's
stopped. Solves 100% CPU usage of apps poll()ing a stopped device.
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.4 2008/11/09 12:22:27 ratchov Exp $	*/
d191 2
a192 1
	hdl->cb_pos = 0;
d491 2
a492 2
	hdl->cb_pos = cb;
	hdl->cb_addr = addr;
d519 33
a551 2
	if (hdl->cb_pos)
		hdl->cb_pos(hdl->cb_addr, delta);
@


1.4
log
@sio_revents() should return 0 poll events if the device isn't started
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.3 2008/11/07 21:01:15 ratchov Exp $	*/
d438 2
@


1.3
log
@expose the block size in the sndio API by making par->round writable
and thus remove the ugly rate <-> block-size table from
sio_setpar(3). Handle the block size negociation in aucat(1), since
it has few constrains the code is overally simpler.
ok jakemsr@@, major crank suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.2 2008/10/28 23:00:08 jsg Exp $	*/
d454 2
@


1.2
log
@sio_initpar() is supposed to return void like the documentation
says according to ratchov@@.  Make it so, and crank major.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sndio.c,v 1.1 2008/10/27 00:26:33 ratchov Exp $	*/
d497 1
a497 1
	if (hdl->debug >= 2) {
@


1.1
log
@rename libsa to libsndio
requested by many, "just go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: libsio.c,v 1.1 2008/10/26 08:49:44 ratchov Exp $	*/
d32 1
a32 1
int
a36 1
	return 1;
@

