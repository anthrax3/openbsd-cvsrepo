head	1.71;
access;
symbols
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.71.0.4
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.62.0.2
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.61.0.6
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.56.0.2
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.54.0.2
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.49.0.2
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15;
locks; strict;
comment	@ * @;


1.71
date	2016.01.09.08.27.24;	author ratchov;	state Exp;
branches;
next	1.70;
commitid	ScnbaRlQejqjUMct;

1.70
date	2015.12.23.20.29.57;	author mmcc;	state Exp;
branches;
next	1.69;
commitid	wARah3DFBNeE6Jms;

1.69
date	2015.11.22.12.01.23;	author ratchov;	state Exp;
branches;
next	1.68;
commitid	qJB6f577aQuApYmn;

1.68
date	2015.10.05.07.18.03;	author ratchov;	state Exp;
branches;
next	1.67;
commitid	8KpPh99fICKoWRu0;

1.67
date	2015.10.02.09.51.54;	author ratchov;	state Exp;
branches;
next	1.66;
commitid	54XC7skSoO3wbej2;

1.66
date	2015.10.02.09.36.24;	author ratchov;	state Exp;
branches;
next	1.65;
commitid	pbuL5fcKBZxeBbqF;

1.65
date	2015.10.02.09.21.46;	author ratchov;	state Exp;
branches;
next	1.64;
commitid	CyAOR3wqXN7z8qK9;

1.64
date	2015.10.01.06.38.19;	author ratchov;	state Exp;
branches;
next	1.63;
commitid	X1PQciHrTFX5240y;

1.63
date	2015.05.05.13.36.22;	author jsg;	state Exp;
branches;
next	1.62;
commitid	TrMgjKJo2AP1VFKu;

1.62
date	2014.09.07.10.12.17;	author guenther;	state Exp;
branches;
next	1.61;
commitid	I8IF6B3jsqlUAcFy;

1.61
date	2013.12.20.08.51.28;	author ratchov;	state Exp;
branches;
next	1.60;

1.60
date	2013.11.18.17.37.45;	author ratchov;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.13.22.38.22;	author ratchov;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.12.06.56.00;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2013.03.13.08.51.18;	author ratchov;	state Exp;
branches;
next	1.56;

1.56
date	2012.11.23.07.03.28;	author ratchov;	state Exp;
branches;
next	1.55;

1.55
date	2012.11.02.10.24.58;	author ratchov;	state Exp;
branches;
next	1.54;

1.54
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.53;

1.53
date	2011.11.15.08.05.22;	author ratchov;	state Exp;
branches;
next	1.52;

1.52
date	2011.10.22.10.23.44;	author ratchov;	state Exp;
branches;
next	1.51;

1.51
date	2011.10.17.21.09.11;	author ratchov;	state Exp;
branches;
next	1.50;

1.50
date	2011.10.05.16.15.43;	author ratchov;	state Exp;
branches;
next	1.49;

1.49
date	2011.05.03.20.15.23;	author ratchov;	state Exp;
branches;
next	1.48;

1.48
date	2011.05.02.22.32.29;	author ratchov;	state Exp;
branches;
next	1.47;

1.47
date	2011.05.02.22.24.23;	author ratchov;	state Exp;
branches;
next	1.46;

1.46
date	2011.04.28.06.19.57;	author ratchov;	state Exp;
branches;
next	1.45;

1.45
date	2011.04.18.23.57.35;	author ratchov;	state Exp;
branches;
next	1.44;

1.44
date	2011.04.16.10.52.22;	author ratchov;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.08.11.18.07;	author ratchov;	state dead;
branches;
next	1.42;

1.42
date	2010.10.21.18.57.42;	author ratchov;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.05.16.00.52;	author ratchov;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.05.13.40.47;	author ratchov;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.05.12.45.48;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2010.05.25.06.51.28;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.24.06.15.54;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.22.17.43.30;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2010.04.06.20.07.01;	author ratchov;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.20.13.17.22;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.15.22.28.23;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.26.19.06.28;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.24.09.35.16;	author ratchov;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.22.21.41.30;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.17.10.55.43;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2009.08.28.10.52.14;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.28.10.03.36;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2009.08.28.06.37.06;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2009.08.26.05.33.01;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.26.12.38.20;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.25.11.15.56;	author ratchov;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.25.08.44.26;	author ratchov;	state Exp;
branches;
next	1.21;

1.21
date	2009.05.16.12.10.52;	author ratchov;	state Exp;
branches;
next	1.20;

1.20
date	2009.05.16.11.15.26;	author ratchov;	state Exp;
branches;
next	1.19;

1.19
date	2009.05.16.09.04.45;	author ratchov;	state Exp;
branches;
next	1.18;

1.18
date	2009.05.16.09.01.56;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.15.13.10.39;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.15.13.04.52;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.25.23.31.59;	author ratchov;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.18.07.32.27;	author ratchov;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.04.07.54.00;	author ratchov;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.03.19.44.58;	author ratchov;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.10.20.34.44;	author ratchov;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.27.12.10.42;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.27.11.35.50;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.21.10.03.25;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.17.10.00.50;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.17.07.31.38;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.17.07.19.27;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.17.07.04.13;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.16.21.18.30;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.11.19.39.35;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.27.00.26.33;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Make code fit in 80 columns, remove trailing spaces & tabs.
@
text
@/*	$OpenBSD: aucat.c,v 1.69 2015/11/22 12:01:23 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>

#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netdb.h>

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "aucat.h"
#include "debug.h"


/*
 * read a message, return 0 if not completed
 */
int
_aucat_rmsg(struct aucat *hdl, int *eof)
{
	ssize_t n;
	unsigned char *data;

	if (hdl->rstate != RSTATE_MSG) {
		DPRINTF("_aucat_rmsg: bad state\n");
		abort();
	}
	while (hdl->rtodo > 0) {
		data = (unsigned char *)&hdl->rmsg;
		data += sizeof(struct amsg) - hdl->rtodo;
		while ((n = read(hdl->fd, data, hdl->rtodo)) < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				*eof = 1;
				DPERROR("_aucat_rmsg: read");
			}
			return 0;
		}
		if (n == 0) {
			DPRINTF("_aucat_rmsg: eof\n");
			*eof = 1;
			return 0;
		}
		hdl->rtodo -= n;
	}
	if (ntohl(hdl->rmsg.cmd) == AMSG_DATA) {
		hdl->rtodo = ntohl(hdl->rmsg.u.data.size);
		hdl->rstate = RSTATE_DATA;
	} else {
		hdl->rtodo = sizeof(struct amsg);
		hdl->rstate = RSTATE_MSG;
	}
	return 1;
}

/*
 * write a message, return 0 if not completed
 */
int
_aucat_wmsg(struct aucat *hdl, int *eof)
{
	ssize_t n;
	unsigned char *data;

	if (hdl->wstate == WSTATE_IDLE) {
		hdl->wstate = WSTATE_MSG;
		hdl->wtodo = sizeof(struct amsg);
	}
	if (hdl->wstate != WSTATE_MSG) {
		DPRINTF("_aucat_wmsg: bad state\n");
		abort();
	}
	while (hdl->wtodo > 0) {
		data = (unsigned char *)&hdl->wmsg;
		data += sizeof(struct amsg) - hdl->wtodo;
		while ((n = write(hdl->fd, data, hdl->wtodo)) < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				*eof = 1;
				DPERROR("_aucat_wmsg: write");
			}
			return 0;
		}
		hdl->wtodo -= n;
	}
	if (ntohl(hdl->wmsg.cmd) == AMSG_DATA) {
		hdl->wtodo = ntohl(hdl->wmsg.u.data.size);
		hdl->wstate = WSTATE_DATA;
	} else {
		hdl->wtodo = 0xdeadbeef;
		hdl->wstate = WSTATE_IDLE;
	}
	return 1;
}

size_t
_aucat_rdata(struct aucat *hdl, void *buf, size_t len, int *eof)
{
	ssize_t n;

	if (hdl->rstate != RSTATE_DATA) {
		DPRINTF("_aucat_rdata: bad state\n");
		abort();
	}
	if (len > hdl->rtodo)
		len = hdl->rtodo;
	while ((n = read(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			*eof = 1;
			DPERROR("_aucat_rdata: read");
		}
		return 0;
	}
	if (n == 0) {
		DPRINTF("_aucat_rdata: eof\n");
		*eof = 1;
		return 0;
	}
	hdl->rtodo -= n;
	if (hdl->rtodo == 0) {
		hdl->rstate = RSTATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
	}
	DPRINTFN(2, "_aucat_rdata: read: n = %zd\n", n);
	return n;
}

size_t
_aucat_wdata(struct aucat *hdl, const void *buf, size_t len,
   unsigned int wbpf, int *eof)
{
	ssize_t n;
	size_t datasize;

	switch (hdl->wstate) {
	case WSTATE_IDLE:
		datasize = len;
		if (datasize > AMSG_DATAMAX)
			datasize = AMSG_DATAMAX;
		datasize -= datasize % wbpf;
		if (datasize == 0)
			datasize = wbpf;
		hdl->wmsg.cmd = htonl(AMSG_DATA);
		hdl->wmsg.u.data.size = htonl(datasize);
		hdl->wtodo = sizeof(struct amsg);
		hdl->wstate = WSTATE_MSG;
		/* FALLTHROUGH */
	case WSTATE_MSG:
		if (!_aucat_wmsg(hdl, eof))
			return 0;
	}
	if (len > hdl->wtodo)
		len = hdl->wtodo;
	if (len == 0) {
		DPRINTF("_aucat_wdata: len == 0\n");
		abort();
	}
	while ((n = write(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			*eof = 1;
			DPERROR("_aucat_wdata: write");
		}
		return 0;
	}
	DPRINTFN(2, "_aucat_wdata: write: n = %zd\n", n);
	hdl->wtodo -= n;
	if (hdl->wtodo == 0) {
		hdl->wstate = WSTATE_IDLE;
		hdl->wtodo = 0xdeadbeef;
	}
	return n;
}

static int
aucat_mkcookie(unsigned char *cookie)
{
#define COOKIE_SUFFIX	"/.aucat_cookie"
#define TEMPL_SUFFIX	".XXXXXXXX"
	struct stat sb;
	char *home, *path = NULL, *tmp = NULL;
	size_t home_len, path_len;
	int fd, len;

	/* please gcc */
	path_len = 0xdeadbeef;

	/*
	 * try to load the cookie
	 */
	home = issetugid() ? NULL : getenv("HOME");
	if (home == NULL)
		goto bad_gen;
	home_len = strlen(home);
	path = malloc(home_len + sizeof(COOKIE_SUFFIX));
	if (path == NULL)
		goto bad_gen;
	memcpy(path, home, home_len);
	memcpy(path + home_len, COOKIE_SUFFIX, sizeof(COOKIE_SUFFIX));
	path_len = home_len + sizeof(COOKIE_SUFFIX) - 1;
	fd = open(path, O_RDONLY);
	if (fd < 0) {
		if (errno != ENOENT)
			DPERROR(path);
		goto bad_gen;
	}
	if (fstat(fd, &sb) < 0) {
		DPERROR(path);
		goto bad_close;
	}
	if (sb.st_mode & 0077) {
		DPRINTF("%s has wrong permissions\n", path);
		goto bad_close;
	}
	len = read(fd, cookie, AMSG_COOKIELEN);
	if (len < 0) {
		DPERROR(path);
		goto bad_close;
	}
	if (len != AMSG_COOKIELEN) {
		DPRINTF("%s: short read\n", path);
		goto bad_close;
	}
	close(fd);
	goto done;
bad_close:
	close(fd);
bad_gen:
	/*
	 * generate a new cookie
	 */
	arc4random_buf(cookie, AMSG_COOKIELEN);

	/*
	 * try to save the cookie
	 */
	if (home == NULL)
		goto done;
	tmp = malloc(path_len + sizeof(TEMPL_SUFFIX));
	if (tmp == NULL)
		goto done;
	memcpy(tmp, path, path_len);
	memcpy(tmp + path_len, TEMPL_SUFFIX, sizeof(TEMPL_SUFFIX));
	fd = mkstemp(tmp);
	if (fd < 0) {
		DPERROR(tmp);
		goto done;
	}
	if (write(fd, cookie, AMSG_COOKIELEN) < 0) {
		DPERROR(tmp);
		unlink(tmp);
		close(fd);
		goto done;
	}
	close(fd);
	if (rename(tmp, path) < 0) {
		DPERROR(tmp);
		unlink(tmp);
	}
done:
	free(tmp);
	free(path);
	return 1;
}

static int
aucat_connect_tcp(struct aucat *hdl, char *host, unsigned int unit)
{
	int s, error, opt;
	struct addrinfo *ailist, *ai, aihints;
	char serv[NI_MAXSERV];

	snprintf(serv, sizeof(serv), "%u", unit + AUCAT_PORT);
	memset(&aihints, 0, sizeof(struct addrinfo));
	aihints.ai_socktype = SOCK_STREAM;
	aihints.ai_protocol = IPPROTO_TCP;
	error = getaddrinfo(host, serv, &aihints, &ailist);
	if (error) {
		DPRINTF("%s: %s\n", host, gai_strerror(error));
		return 0;
	}
	s = -1;
	for (ai = ailist; ai != NULL; ai = ai->ai_next) {
		s = socket(ai->ai_family, ai->ai_socktype | SOCK_CLOEXEC,
		    ai->ai_protocol);
		if (s < 0) {
			DPERROR("socket");
			continue;
		}
	restart:
		if (connect(s, ai->ai_addr, ai->ai_addrlen) < 0) {
			if (errno == EINTR)
				goto restart;
			DPERROR("connect");
			close(s);
			s = -1;
			continue;
		}
		break;
	}
	freeaddrinfo(ailist);
	if (s < 0)
		return 0;
	opt = 1;
	if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(int)) < 0) {
		DPERROR("setsockopt");
		close(s);
		return 0;
	}
	hdl->fd = s;
	return 1;
}

static int
aucat_connect_un(struct aucat *hdl, unsigned int unit)
{
	struct sockaddr_un ca;
	socklen_t len = sizeof(struct sockaddr_un);
	uid_t uid;
	int s;

	uid = geteuid();
	snprintf(ca.sun_path, sizeof(ca.sun_path),
	    SOCKPATH_DIR "-%u/" SOCKPATH_FILE "%u", uid, unit);
	ca.sun_family = AF_UNIX;
	s = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0);
	if (s < 0)
		return 0;
	while (connect(s, (struct sockaddr *)&ca, len) < 0) {
		if (errno == EINTR)
			continue;
		DPERROR(ca.sun_path);
		/* try shared server */
		snprintf(ca.sun_path, sizeof(ca.sun_path),
		    SOCKPATH_DIR "/" SOCKPATH_FILE "%u", unit);
		while (connect(s, (struct sockaddr *)&ca, len) < 0) {
			if (errno == EINTR)
				continue;
			DPERROR(ca.sun_path);
			close(s);
			return 0;
		}
		break;
	}
	hdl->fd = s;
	DPRINTFN(2, "%s: connected\n", ca.sun_path);
	return 1;
}

static const char *
parsedev(const char *str, unsigned int *rval)
{
	const char *p = str;
	unsigned int val;

	for (val = 0; *p >= '0' && *p <= '9'; p++) {
		val = 10 * val + (*p - '0');
		if (val >= 16) {
			DPRINTF("%s: number too large\n", str);
			return NULL;
		}
	}
	if (p == str) {
		DPRINTF("%s: number expected\n", str);
		return NULL;
	}
	*rval = val;
	return p;
}

static const char *
parsestr(const char *str, char *rstr, unsigned int max)
{
	const char *p = str;

	while (*p != '\0' && *p != ',' && *p != '/') {
		if (--max == 0) {
			DPRINTF("%s: string too long\n", str);
			return NULL;
		}
		*rstr++ = *p++;
	}
	if (str == p) {
		DPRINTF("%s: string expected\n", str);
		return NULL;
	}
	*rstr = '\0';
	return p;
}

int
_aucat_open(struct aucat *hdl, const char *str, unsigned int mode)
{
	extern char *__progname;
	int eof;
	char host[NI_MAXHOST], opt[AMSG_OPTMAX];
	const char *p;
	unsigned int unit, devnum, type;

	if ((p = _sndio_parsetype(str, "snd")) != NULL)
		type = 0;
	else if ((p = _sndio_parsetype(str, "midithru")) != NULL)
		type = 1;
	else if ((p = _sndio_parsetype(str, "midi")) != NULL)
		type = 2;
	else {
		DPRINTF("%s: unsupported device type\n", str);
		return -1;
	}
	if (*p == '@@') {
		p = parsestr(++p, host, NI_MAXHOST);
		if (p == NULL)
			return 0;
	} else
		*host = '\0';
	if (*p == ',') {
		p = parsedev(++p, &unit);
		if (p == NULL)
			return 0;
	} else
		unit = 0;
	if (*p != '/') {
		DPRINTF("%s: '/' expected\n", str);
		return 0;
	}
	p = parsedev(++p, &devnum);
	if (p == NULL)
		return 0;
	if (*p == '.') {
		p = parsestr(++p, opt, AMSG_OPTMAX);
		if (p == NULL)
			return 0;
	} else
		strlcpy(opt, "default", AMSG_OPTMAX);
	if (*p != '\0') {
		DPRINTF("%s: junk at end of dev name\n", p);
		return 0;
	}
	devnum += type * 16; /* XXX */
	DPRINTFN(2, "_aucat_open: host=%s unit=%u devnum=%u opt=%s\n",
	    host, unit, devnum, opt);
	if (host[0] != '\0') {
		if (!aucat_connect_tcp(hdl, host, unit))
			return 0;
	} else {
		if (!aucat_connect_un(hdl, unit))
			return 0;
	}
	hdl->rstate = RSTATE_MSG;
	hdl->rtodo = sizeof(struct amsg);
	hdl->wstate = WSTATE_IDLE;
	hdl->wtodo = 0xdeadbeef;
	hdl->maxwrite = 0;

	/*
	 * say hello to server
	 */
	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = htonl(AMSG_AUTH);
	if (!aucat_mkcookie(hdl->wmsg.u.auth.cookie))
		goto bad_connect;
	hdl->wtodo = sizeof(struct amsg);
	if (!_aucat_wmsg(hdl, &eof))
		goto bad_connect;
	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = htonl(AMSG_HELLO);
	hdl->wmsg.u.hello.version = AMSG_VERSION;
	hdl->wmsg.u.hello.mode = htons(mode);
	hdl->wmsg.u.hello.devnum = devnum;
	strlcpy(hdl->wmsg.u.hello.who, __progname,
	    sizeof(hdl->wmsg.u.hello.who));
	strlcpy(hdl->wmsg.u.hello.opt, opt,
	    sizeof(hdl->wmsg.u.hello.opt));
	hdl->wtodo = sizeof(struct amsg);
	if (!_aucat_wmsg(hdl, &eof))
		goto bad_connect;
	hdl->rtodo = sizeof(struct amsg);
	if (!_aucat_rmsg(hdl, &eof)) {
		DPRINTF("aucat_init: mode refused\n");
		goto bad_connect;
	}
	if (ntohl(hdl->rmsg.cmd) != AMSG_ACK) {
		DPRINTF("aucat_init: protocol err\n");
		goto bad_connect;
	}
	return 1;
 bad_connect:
	while (close(hdl->fd) < 0 && errno == EINTR)
		; /* retry */
	return 0;
}

void
_aucat_close(struct aucat *hdl, int eof)
{
	char dummy[1];

	if (!eof) {
		AMSG_INIT(&hdl->wmsg);
		hdl->wmsg.cmd = htonl(AMSG_BYE);
		hdl->wtodo = sizeof(struct amsg);
		if (!_aucat_wmsg(hdl, &eof))
			goto bad_close;
		while (read(hdl->fd, dummy, 1) < 0 && errno == EINTR)
			; /* nothing */
	}
 bad_close:
	while (close(hdl->fd) < 0 && errno == EINTR)
		; /* nothing */
}

int
_aucat_setfl(struct aucat *hdl, int nbio, int *eof)
{
	if (fcntl(hdl->fd, F_SETFL, nbio ? O_NONBLOCK : 0) < 0) {
		DPERROR("_aucat_setfl: fcntl");
		*eof = 1;
		return 0;
	}
	return 1;
}

int
_aucat_pollfd(struct aucat *hdl, struct pollfd *pfd, int events)
{
	if (hdl->rstate == RSTATE_MSG)
		events |= POLLIN;
	pfd->fd = hdl->fd;
	pfd->events = events;
	return 1;
}

int
_aucat_revents(struct aucat *hdl, struct pollfd *pfd)
{
	int revents = pfd->revents;

	DPRINTFN(2, "_aucat_revents: revents: %x\n", revents);
	return revents;
}
@


1.70
log
@remove NULL-checks before free()
@
text
@d432 1
a432 1
 	else if ((p = _sndio_parsetype(str, "midithru")) != NULL)
d434 1
a434 1
 	else if ((p = _sndio_parsetype(str, "midi")) != NULL)
@


1.69
log
@Don't remove the type component from the device string before passing
it to the *_open() functions. It's more flexible this way. No behaviour
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.68 2015/10/05 07:18:03 ratchov Exp $	*/
d291 2
a292 4
	if (tmp)
		free(tmp);
	if (path)
		free(path);
@


1.68
log
@Fix missing checks for truncation of long file names. Rather than
checking for truncation every time we touch the string, simply allocate
a memory chunk large enough to store the full path.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.67 2015/10/02 09:51:54 ratchov Exp $	*/
d424 1
a424 2
_aucat_open(struct aucat *hdl, const char *str, unsigned int mode,
    unsigned int type)
d429 2
a430 2
	const char *p = str;
	unsigned int unit, devnum;
d432 10
d454 1
a454 1
	if (*p != '/' && *p != ':') {
@


1.67
log
@use macros for cookie path and temp file template instead
of hardcoded strings. no object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.66 2015/10/02 09:36:24 ratchov Exp $	*/
d211 6
a216 3
	char *home, path[PATH_MAX], tmp[PATH_MAX];
	ssize_t len;
	int fd;
d224 7
a230 1
	snprintf(path, PATH_MAX, "%s" COOKIE_SUFFIX, home);
d255 1
a255 1
	return 1;
d268 6
a273 6
		return 1;
	if (strlcpy(tmp, path, PATH_MAX) >= PATH_MAX ||
	    strlcat(tmp, TEMPL_SUFFIX, PATH_MAX) >= PATH_MAX) {
		DPRINTF("%s: too long\n", path);
		return 1;
	}
d277 1
a277 1
		return 1;
d283 1
a283 1
		return 1;
d290 5
@


1.66
log
@As the socket path is known, use its size rather that PATH_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.65 2015/10/02 09:21:46 ratchov Exp $	*/
d208 2
d221 1
a221 1
	snprintf(path, PATH_MAX, "%s/.aucat_cookie", home);
d261 1
a261 1
	    strlcat(tmp, ".XXXXXXXX", PATH_MAX) >= PATH_MAX) {
@


1.65
log
@use macros instead of hard-coded strings for unix sockets paths
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.64 2015/10/01 06:38:19 ratchov Exp $	*/
d340 1
a340 1
	    SOCKPATH_DIR "-%u/%s%u", uid, SOCKPATH_FILE, unit);
d351 1
a351 1
		    SOCKPATH_DIR "/%s%u", SOCKPATH_FILE, unit);
@


1.64
log
@Remove support for the AUCAT_COOKIE environment variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.63 2015/05/05 13:36:22 jsg Exp $	*/
d340 1
a340 1
	    "/tmp/aucat-%u/%s%u", uid, AUCAT_PATH, unit);
d351 1
a351 1
		    "/tmp/aucat/%s%u", AUCAT_PATH, unit);
@


1.63
log
@add missing braces in _aucat_wmsg()

As ratchov@@ notes:
"all _aucat_wmsg() callers set hdl->wtodo, so your diff can't break
things that used to work by accident."

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.62 2014/09/07 10:12:17 guenther Exp $	*/
d209 1
a209 1
	char buf[PATH_MAX], tmp[PATH_MAX], *path;
d216 4
a219 8
	path = issetugid() ? NULL : getenv("AUCAT_COOKIE");
	if (path == NULL) {
		path = issetugid() ? NULL : getenv("HOME");
		if (path == NULL)
			goto bad_gen;
		snprintf(buf, PATH_MAX, "%s/.aucat_cookie", path);
		path = buf;
	}
d256 1
a256 1
	if (path == NULL)
@


1.62
log
@Use SOCK_CLOEXEC (instead of later using fcntl(F_SETFD)) when creating sockets
for talking to aucat/sndiod

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.61 2013/12/20 08:51:28 ratchov Exp $	*/
d91 1
a91 1
	if (hdl->wstate == WSTATE_IDLE)
d94 1
@


1.61
log
@Be less verbose when SNDIO_DEBUG=1 is set.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d303 2
a304 1
		s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
d345 1
a345 1
	s = socket(AF_UNIX, SOCK_STREAM, 0);
a457 4
	}
	if (fcntl(hdl->fd, F_SETFD, FD_CLOEXEC) < 0) {
		DPERROR("FD_CLOEXEC");
		goto bad_connect;
@


1.60
log
@add missing prototypes
@
text
@d364 1
a364 1
	DPRINTF("%s: connected\n", ca.sun_path);
d449 1
a449 1
	DPRINTF("_aucat_open: host=%s unit=%u devnum=%u opt=%s\n",
@


1.59
log
@Prefix by '_' symbols that are not part of the API.

ok deraadt, guenther
@
text
@d39 1
@


1.58
log
@internalize some functions so that they do not need prototypes
ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.57 2013/03/13 08:51:18 ratchov Exp $	*/
a38 1

d43 1
a43 1
aucat_rmsg(struct aucat *hdl, int *eof)
d49 1
a49 1
		DPRINTF("aucat_rmsg: bad state\n");
d60 1
a60 1
				DPERROR("aucat_rmsg: read");
d65 1
a65 1
			DPRINTF("aucat_rmsg: eof\n");
d85 1
a85 1
aucat_wmsg(struct aucat *hdl, int *eof)
d94 1
a94 1
		DPRINTF("aucat_wmsg: bad state\n");
d105 1
a105 1
				DPERROR("aucat_wmsg: write");
d122 1
a122 1
aucat_rdata(struct aucat *hdl, void *buf, size_t len, int *eof)
d127 1
a127 1
		DPRINTF("aucat_rdata: bad state\n");
d137 1
a137 1
			DPERROR("aucat_rdata: read");
d142 1
a142 1
		DPRINTF("aucat_rdata: eof\n");
d151 1
a151 1
	DPRINTFN(2, "aucat_rdata: read: n = %zd\n", n);
d156 1
a156 1
aucat_wdata(struct aucat *hdl, const void *buf, size_t len,
d176 1
a176 1
		if (!aucat_wmsg(hdl, eof))
d182 1
a182 1
		DPRINTF("aucat_wdata: len == 0\n");
d190 1
a190 1
			DPERROR("aucat_wdata: write");
d194 1
a194 1
	DPRINTFN(2, "aucat_wdata: write: n = %zd\n", n);
d409 1
a409 1
aucat_open(struct aucat *hdl, const char *str, unsigned int mode,
d448 1
a448 1
	DPRINTF("aucat_open: host=%s unit=%u devnum=%u opt=%s\n",
d475 1
a475 1
	if (!aucat_wmsg(hdl, &eof))
d487 1
a487 1
	if (!aucat_wmsg(hdl, &eof))
d490 1
a490 1
	if (!aucat_rmsg(hdl, &eof)) {
d506 1
a506 1
aucat_close(struct aucat *hdl, int eof)
d514 1
a514 1
		if (!aucat_wmsg(hdl, &eof))
d525 1
a525 1
aucat_setfl(struct aucat *hdl, int nbio, int *eof)
d528 1
a528 1
		DPERROR("aucat_setfl: fcntl");
d536 1
a536 1
aucat_pollfd(struct aucat *hdl, struct pollfd *pfd, int events)
d546 1
a546 1
aucat_revents(struct aucat *hdl, struct pollfd *pfd)
d550 1
a550 1
	DPRINTFN(2, "aucat_revents: revents: %x\n", revents);
@


1.57
log
@in debug mode, log successful connections, from Jan Stary
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d204 1
a204 1
int
d285 1
a285 1
int
d332 1
a332 1
int
@


1.56
log
@Remplace aucat server by a new sndiod daemon aimed to be simpler
smaller and faster than aucat. It's a drop in replacement with the
following exceptions that don't affect the default setup:
  - The sample rate and the encoding are a per-device parameters
    thus -r and -e options must precede the corresponding -f option
  - MIDI thru boxes are dynamically created and no -M option
    is required anymore, so -M was removed.
  - MIDI ports are exposed with a new ``midi/N'' name, rather
    than abusing MIDI thru boxes.
with help from armani@@, ok deraadt@@
@
text
@d364 1
@


1.55
log
@Use dedicated messages for flow control instead of abusing clock tick
messages and enable flow control for MIDI. Since this requires protocol
version bump, both sndiod and libsndio must be kept up to date to work
together.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.54 2012/04/11 06:05:43 ratchov Exp $	*/
d447 1
a447 2
	if (type)
		devnum += 16; /* XXX */
@


1.54
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.53 2011/11/15 08:05:22 ratchov Exp $	*/
d466 1
@


1.53
log
@Add a "device number" component in sndio(7) device names, allowing a
single aucat instance to handle all audio and MIDI services. Since
this partially breaks compatibility, this is a opportunitiy to fix few
other design mistakes (eg ':' being used by inet6, type name vs api
name confusion, etc..). This leads to the following names:

        type[@@hostname][,unit]/devnum[.option]

The device number is the minor device number for direct hardware
access (ie the 'N' in /dev/audioN). For aucat, this is the occurence
number of the -f (or -M) option.

There's a compatibility hook to keep old names working if only one
aucat server is running.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.52 2011/10/22 10:23:44 ratchov Exp $	*/
d157 2
a158 1
aucat_wdata(struct aucat *hdl, const void *buf, size_t len, unsigned wbpf, int *eof)
d286 1
a286 1
aucat_connect_tcp(struct aucat *hdl, char *host, unsigned unit)
d333 1
a333 1
aucat_connect_un(struct aucat *hdl, unsigned unit)
d368 1
a368 1
parsedev(const char *str, unsigned *rval)
d371 1
a371 1
	unsigned val;
d389 1
a389 1
parsestr(const char *str, char *rstr, unsigned max)
d409 2
a410 1
aucat_open(struct aucat *hdl, const char *str, unsigned mode, unsigned type)
d416 1
a416 1
	unsigned unit, devnum;
@


1.52
log
@Don't attempt to send data not available for sending yet. Analysed
and fixed by Remco <remco at d-compu.dyndns.org>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.51 2011/10/17 21:09:11 ratchov Exp $	*/
d152 1
a152 1
	DPRINTF("aucat_rdata: read: n = %zd\n", n);
d194 1
a194 1
	DPRINTF("aucat_wdata: write: n = %zd\n", n);
d285 1
a285 1
aucat_connect_tcp(struct aucat *hdl, char *host, char *unit)
a288 1
	unsigned port;
d291 1
a291 5
	if (sscanf(unit, "%u", &port) != 1) {
		DPRINTF("%s: bad unit number\n", unit);
		return 0;
	}
	snprintf(serv, sizeof(serv), "%u", port + AUCAT_PORT);
d332 1
a332 1
aucat_connect_un(struct aucat *hdl, char *unit)
d341 1
a341 1
	    "/tmp/aucat-%u/%s%s", uid, AUCAT_PATH, unit);
d352 1
a352 1
		    "/tmp/aucat/%s%s", AUCAT_PATH, unit);
d366 41
d408 1
a408 1
aucat_open(struct aucat *hdl, const char *str, unsigned mode)
d411 14
a424 12
	int eof, hashost;
	char unit[4], *sep, *opt;
	char host[NI_MAXHOST];

	if (str == NULL)
		str = "0";
	sep = strchr(str, '/');
	if (sep == NULL) {
		hashost = 0;
	} else {
		if (sep - str >= sizeof(host)) {
			DPRINTF("aucat_open: %s: host too long\n", str);
d426 12
a437 14
		}
		memcpy(host, str, sep - str);
		host[sep - str] = '\0';
		hashost = 1;
		str = sep + 1;
	}
	sep = strchr(str, '.');
	if (sep == NULL) {
		opt = "default";
		strlcpy(unit, str, sizeof(unit));
	} else {
		opt = sep + 1;
		if (sep - str >= sizeof(unit)) {
			DPRINTF("aucat_init: %s: too long\n", str);
d439 5
a443 2
		}
		strlcpy(unit, str, opt - str);
d445 5
a449 2
	DPRINTF("aucat_init: trying %s -> %s.%s\n", str, unit, opt);
	if (hashost) {
d479 1
d548 1
a548 1
	DPRINTF("aucat_revents: revents: %x\n", revents);
@


1.51
log
@Remove midicat since aucat can now be used instead of midicat
with almost the same syntax (roughly an extra -M option).
Thru boxes are created with aucat, and corresponding MIDI port
names have the "aucat" prefix instead of "midithru". The old
device name will still work some time for backward compatibility.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.50 2011/10/05 16:15:43 ratchov Exp $	*/
d160 1
d164 6
a169 5
		if (len > AMSG_DATAMAX)
			len = AMSG_DATAMAX;
		len -= len % wbpf;
		if (len == 0)
			len = wbpf;
d171 1
a171 1
		hdl->wmsg.u.data.size = htonl(len);
@


1.50
log
@restart connect(2) if it returns EINTR
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.49 2011/05/03 20:15:23 ratchov Exp $	*/
d283 1
a283 1
aucat_connect_tcp(struct aucat *hdl, char *host, char *unit, int isaudio)
d294 1
a294 5
	if (isaudio)
		port += AUCAT_PORT;
	else
		port += MIDICAT_PORT;
	snprintf(serv, sizeof(serv), "%u", port);
d335 1
a335 1
aucat_connect_un(struct aucat *hdl, char *unit, int isaudio)
a338 1
	char *sock;
a342 1
	sock = isaudio ? AUCAT_PATH : MIDICAT_PATH;
d344 1
a344 1
	    "/tmp/aucat-%u/%s%s", uid, sock, unit);
d355 1
a355 1
		    "/tmp/aucat/%s%s", sock, unit);
d370 1
a370 1
aucat_open(struct aucat *hdl, const char *str, unsigned mode, int isaudio)
d406 1
a406 1
		if (!aucat_connect_tcp(hdl, host, unit, isaudio))
d409 1
a409 1
		if (!aucat_connect_un(hdl, unit, isaudio))
@


1.49
log
@determine the default device in backend code instead of the common
code. This is simpler as long as not all backends use the same
default.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.48 2011/05/02 22:32:29 ratchov Exp $	*/
d314 1
d316 2
@


1.48
log
@Add missing byter order conversions in message headers. Fixes the case
when the server and the client are not of the same endianness.
Found by naddy.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.47 2011/05/02 22:24:23 ratchov Exp $	*/
d380 2
@


1.47
log
@set the TCP_NODELAY option for TCP connections
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.46 2011/04/28 06:19:57 ratchov Exp $	*/
d72 2
a73 2
	if (hdl->rmsg.cmd == AMSG_DATA) {
		hdl->rtodo = hdl->rmsg.u.data.size;
d112 2
a113 2
	if (hdl->wmsg.cmd == AMSG_DATA) {
		hdl->wtodo = hdl->wmsg.u.data.size;
d168 2
a169 2
		hdl->wmsg.cmd = AMSG_DATA;
		hdl->wmsg.u.data.size = len;
d426 1
a426 1
	hdl->wmsg.cmd = AMSG_AUTH;
d433 1
a433 1
	hdl->wmsg.cmd = AMSG_HELLO;
d435 1
a435 1
	hdl->wmsg.u.hello.mode = mode;
d448 1
a448 1
	if (hdl->rmsg.cmd != AMSG_ACK) {
d466 1
a466 1
		hdl->wmsg.cmd = AMSG_BYE;
@


1.46
log
@Implement a new authentication method allowing aucat and midicat to
work over TCP, for instance, to expose the sound card of one machine
with other machines of the network.

The first client generates a 128-bit random number (aka the
session cookie), saves it in $HOME/.aucat_cookie and sends it to the
server. Successive clients load the cookie from $HOME/.aucat_cookie
and send it to the server but the server accepts only clients whose
cookie matches the session cookie. When all clients are gone, the
session is over, and another cookie could start a new session, and so
on.

TCP is enabled on the server with the new -L option, and on the client
side hostnames are specified with a new optional component in the
device name.

hints from damien, dlg and deraadt, tweaks from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.45 2011/04/18 23:57:35 ratchov Exp $	*/
d24 1
d285 1
a285 1
	int s, error;
d325 6
@


1.45
log
@slightly cleanup by separating socket-specific code from
protocol specific code. No behaviour change
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.44 2011/04/16 10:52:22 ratchov Exp $	*/
d20 1
d23 3
d28 1
d38 1
d201 128
d369 1
a369 1
	int eof;
d371 1
d373 13
d399 7
a405 2
	if (!aucat_connect_un(hdl, unit, isaudio))
		return 0;
d418 7
@


1.44
log
@Make aucat audio and midi backends share the same code to communicate
with the server. As we're at it use the same protocol for midi and
audio. Now, both audio and midi code use the same SNDIO_DEBUG environment
variable to turn on/off DPRINTF's.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d195 1
a195 1
aucat_open(struct aucat *hdl, const char *str, char *sock, unsigned mode, int nbio)
a196 3
	extern char *__progname;
	int s, eof;
	char unit[4], *sep, *opt;
d199 1
d201 1
a202 13
	sep = strchr(str, '.');
	if (sep == NULL) {
		opt = "default";
		strlcpy(unit, str, sizeof(unit));
	} else {
		opt = sep + 1;
		if (sep - str >= sizeof(unit)) {
			DPRINTF("aucat_init: %s: too long\n", str);
			return 0;
		}
		strlcpy(unit, str, opt - str);
	}
	DPRINTF("aucat_init: trying %s -> %s.%s\n", str, unit, opt);
d204 1
a204 2
	if (strchr(str, '/') != NULL)
		return 0;
a207 1

d210 1
a210 1
		goto bad_free;
d214 1
a214 1
		DPERROR("aucat_init: connect");
d221 3
a223 2
			DPERROR("aucat_init: connect");
			goto bad_connect;
d227 27
a253 1
	if (fcntl(s, F_SETFD, FD_CLOEXEC) < 0) {
a256 1
	hdl->fd = s;
d287 1
a287 1
	while (close(s) < 0 && errno == EINTR)
a288 1
 bad_free:
@


1.43
log
@Clean up function naming: use sio_<backend>_ prefix for private
audio-related functions and put them in files named sio_<backend>.c
No behaviour changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.42 2010/10/21 18:57:42 ratchov Exp $	*/
d30 2
a31 46
#include "amsg.h"
#include "sndio_priv.h"

struct aucat_hdl {
	struct sio_hdl sio;
	int fd;				/* socket */
	struct amsg rmsg, wmsg;		/* temporary messages */
	size_t wtodo, rtodo;		/* bytes to complete the packet */
#define STATE_IDLE	0		/* nothing to do */
#define STATE_MSG	1		/* message being transferred */
#define STATE_DATA	2		/* data being transferred */
	unsigned rstate, wstate;	/* one of above */
	unsigned rbpf, wbpf;		/* read and write bytes-per-frame */
	int maxwrite;			/* latency constraint */
	int events;			/* events the user requested */
	unsigned curvol, reqvol;	/* current and requested volume */
	int delta;			/* some of received deltas */
};

static void aucat_close(struct sio_hdl *);
static int aucat_start(struct sio_hdl *);
static int aucat_stop(struct sio_hdl *);
static int aucat_setpar(struct sio_hdl *, struct sio_par *);
static int aucat_getpar(struct sio_hdl *, struct sio_par *);
static int aucat_getcap(struct sio_hdl *, struct sio_cap *);
static size_t aucat_read(struct sio_hdl *, void *, size_t);
static size_t aucat_write(struct sio_hdl *, const void *, size_t);
static int aucat_pollfd(struct sio_hdl *, struct pollfd *, int);
static int aucat_revents(struct sio_hdl *, struct pollfd *);
static int aucat_setvol(struct sio_hdl *, unsigned);
static void aucat_getvol(struct sio_hdl *);

static struct sio_ops aucat_ops = {
	aucat_close,
	aucat_setpar,
	aucat_getpar,
	aucat_getcap,
	aucat_write,
	aucat_read,
	aucat_start,
	aucat_stop,
	aucat_pollfd,
	aucat_revents,
	aucat_setvol,
	aucat_getvol
};
d34 1
a34 1
 * read a message, return 0 if blocked
d36 2
a37 2
static int
aucat_rmsg(struct aucat_hdl *hdl)
d42 4
d53 1
a53 1
				hdl->sio.eof = 1;
d60 1
a60 1
			hdl->sio.eof = 1;
d65 7
d76 1
a76 1
 * write a message, return 0 if blocked
d78 2
a79 2
static int
aucat_wmsg(struct aucat_hdl *hdl)
d84 7
d98 1
a98 1
				hdl->sio.eof = 1;
d105 7
d115 2
a116 5
/*
 * execute the next message, return 0 if blocked
 */
static int
aucat_runmsg(struct aucat_hdl *hdl)
d118 15
a132 1
	if (!aucat_rmsg(hdl))
d134 34
a167 6
	switch (hdl->rmsg.cmd) {
	case AMSG_DATA:
		if (hdl->rmsg.u.data.size == 0 ||
		    hdl->rmsg.u.data.size % hdl->rbpf) {
			DPRINTF("aucat_runmsg: bad data message\n");
			hdl->sio.eof = 1;
d169 13
a182 37
		hdl->rstate = STATE_DATA;
		hdl->rtodo = hdl->rmsg.u.data.size;
		break;
	case AMSG_POS:
		hdl->maxwrite += hdl->rmsg.u.ts.delta * (int)hdl->wbpf;
		DPRINTF("aucat: pos = %d, maxwrite = %d\n",
		    hdl->rmsg.u.ts.delta, hdl->maxwrite);
		hdl->delta = hdl->rmsg.u.ts.delta;
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
		break;
	case AMSG_MOVE:
		hdl->maxwrite += hdl->rmsg.u.ts.delta * hdl->wbpf;
		hdl->delta += hdl->rmsg.u.ts.delta;
		DPRINTF("aucat: move = %d, delta = %d, maxwrite = %d\n",
		    hdl->rmsg.u.ts.delta, hdl->delta, hdl->maxwrite);
		if (hdl->delta >= 0) {
			sio_onmove_cb(&hdl->sio, hdl->delta);
			hdl->delta = 0;
		}
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
		break;
	case AMSG_SETVOL:
		hdl->curvol = hdl->reqvol = hdl->rmsg.u.vol.ctl;
		sio_onvol_cb(&hdl->sio, hdl->curvol);
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
		break;
	case AMSG_GETPAR:
	case AMSG_ACK:
		hdl->rstate = STATE_IDLE;
		hdl->rtodo = 0xdeadbeef;
		break;
	default:
		DPRINTF("aucat_runmsg: unknown message\n");
		hdl->sio.eof = 1;
d185 7
a191 1
	return 1;
d194 2
a195 2
struct sio_hdl *
sio_open_aucat(const char *str, unsigned mode, int nbio)
d198 1
a198 1
	int s;
a199 1
	struct aucat_hdl *hdl;
d211 2
a212 2
			DPRINTF("sio_open_aucat: %s: too long\n", str);
			return NULL;
d216 1
a216 1
	DPRINTF("sio_open_aucat: trying %s -> %s.%s\n", str, unit, opt);
d219 1
a219 1
		return NULL;
d221 1
a221 1
	    "/tmp/aucat-%u/softaudio%s", uid, unit);
a223 5
	hdl = malloc(sizeof(struct aucat_hdl));
	if (hdl == NULL)
		return NULL;
	sio_create(&hdl->sio, &aucat_ops, mode, nbio);

d230 1
a230 1
		DPERROR("sio_open_aucat: connect");
d233 1
a233 1
		    "/tmp/aucat/softaudio%s", unit);
d237 1
a237 1
			DPERROR("sio_open_aucat: connect");
d247 3
a249 3
	hdl->rstate = STATE_IDLE;
	hdl->rtodo = 0xdeadbeef;
	hdl->wstate = STATE_IDLE;
a250 2
	hdl->curvol = SIO_MAXVOL;
	hdl->reqvol = SIO_MAXVOL;
d264 1
a264 1
	if (!aucat_wmsg(hdl))
d267 2
a268 2
	if (!aucat_rmsg(hdl)) {
		DPRINTF("sio_open_aucat: mode refused\n");
d272 1
a272 1
		DPRINTF("sio_open_aucat: protocol err\n");
d275 1
a275 1
	return (struct sio_hdl *)hdl;
d280 1
a280 2
	free(hdl);
	return NULL;
d283 2
a284 2
static void
aucat_close(struct sio_hdl *sh)
a285 1
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;
d288 1
a288 3
	if (!hdl->sio.eof && hdl->sio.started)
		(void)aucat_stop(&hdl->sio);
	if (!hdl->sio.eof) {
d292 1
a292 1
		if (!aucat_wmsg(hdl))
a299 33
	free(hdl);
}

static int
aucat_start(struct sio_hdl *sh)
{
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;
	struct sio_par par;

	/*
	 * save bpf
	 */
	if (!sio_getpar(&hdl->sio, &par))
		return 0;
	hdl->wbpf = par.bps * par.pchan;
	hdl->rbpf = par.bps * par.rchan;
	hdl->maxwrite = hdl->wbpf * par.bufsz;
	hdl->delta = 0;
	DPRINTF("aucat: start, maxwrite = %d\n", hdl->maxwrite);

	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_START;
	hdl->wtodo = sizeof(struct amsg);
	if (!aucat_wmsg(hdl))
		return 0;
	hdl->rstate = STATE_MSG;
	hdl->rtodo = sizeof(struct amsg);
	if (fcntl(hdl->fd, F_SETFL, O_NONBLOCK) < 0) {
		DPERROR("aucat_start: fcntl(0)");
		hdl->sio.eof = 1;
		return 0;
	}
	return 1;
d302 2
a303 2
static int
aucat_stop(struct sio_hdl *sh)
d305 3
a307 8
#define ZERO_MAX 0x400
	static unsigned char zero[ZERO_MAX];
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;
	unsigned n, count;

	if (fcntl(hdl->fd, F_SETFL, 0) < 0) {
		DPERROR("aucat_stop: fcntl(0)");
		hdl->sio.eof = 1;
a309 53

	/*
	 * complete message or data block in progress
	 */
	if (hdl->wstate == STATE_MSG) {
		if (!aucat_wmsg(hdl))
			return 0;
		if (hdl->wmsg.cmd == AMSG_DATA) {
			hdl->wstate = STATE_DATA;
			hdl->wtodo = hdl->wmsg.u.data.size;
		} else
			hdl->wstate = STATE_IDLE;
	}
	if (hdl->wstate == STATE_DATA) {
		hdl->maxwrite = hdl->wtodo;
		while (hdl->wstate != STATE_IDLE) {
			count = hdl->wtodo;
			if (count > ZERO_MAX)
				count = ZERO_MAX;
			n = aucat_write(&hdl->sio, zero, count);
			if (n == 0)
				return 0;
		}
	}

	/*
	 * send stop message
	 */
	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_STOP;
	hdl->wtodo = sizeof(struct amsg);
	if (!aucat_wmsg(hdl))
		return 0;
	if (hdl->rstate == STATE_IDLE) {
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
	}

	/*
	 * wait for the STOP ACK
	 */
	while (hdl->rstate != STATE_IDLE) {
		switch (hdl->rstate) {
		case STATE_MSG:
			if (!aucat_runmsg(hdl))
				return 0;
			break;
		case STATE_DATA:
			if (!aucat_read(&hdl->sio, zero, ZERO_MAX))
				return 0;
			break;
		}
	}
d313 2
a314 2
static int
aucat_setpar(struct sio_hdl *sh, struct sio_par *par)
d316 1
a316 282
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;

	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_SETPAR;
	hdl->wmsg.u.par.bits = par->bits;
	hdl->wmsg.u.par.bps = par->bps;
	hdl->wmsg.u.par.sig = par->sig;
	hdl->wmsg.u.par.le = par->le;
	hdl->wmsg.u.par.msb = par->msb;
	hdl->wmsg.u.par.rate = par->rate;
	hdl->wmsg.u.par.appbufsz = par->appbufsz;
	hdl->wmsg.u.par.xrun = par->xrun;
	if (hdl->sio.mode & SIO_REC)
		hdl->wmsg.u.par.rchan = par->rchan;
	if (hdl->sio.mode & SIO_PLAY)
		hdl->wmsg.u.par.pchan = par->pchan;
	hdl->wtodo = sizeof(struct amsg);
	if (!aucat_wmsg(hdl))
		return 0;
	return 1;
}

static int
aucat_getpar(struct sio_hdl *sh, struct sio_par *par)
{
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;

	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_GETPAR;
	hdl->wtodo = sizeof(struct amsg);
	if (!aucat_wmsg(hdl))
		return 0;
	hdl->rtodo = sizeof(struct amsg);
	if (!aucat_rmsg(hdl))
		return 0;
	if (hdl->rmsg.cmd != AMSG_GETPAR) {
		DPRINTF("aucat_getpar: protocol err\n");
		hdl->sio.eof = 1;
		return 0;
	}
	par->bits = hdl->rmsg.u.par.bits;
	par->bps = hdl->rmsg.u.par.bps;
	par->sig = hdl->rmsg.u.par.sig;
	par->le = hdl->rmsg.u.par.le;
	par->msb = hdl->rmsg.u.par.msb;
	par->rate = hdl->rmsg.u.par.rate;
	par->bufsz = hdl->rmsg.u.par.bufsz;
	par->appbufsz = hdl->rmsg.u.par.appbufsz;
	par->xrun = hdl->rmsg.u.par.xrun;
	par->round = hdl->rmsg.u.par.round;
	if (hdl->sio.mode & SIO_PLAY)
		par->pchan = hdl->rmsg.u.par.pchan;
	if (hdl->sio.mode & SIO_REC)
		par->rchan = hdl->rmsg.u.par.rchan;
	return 1;
}

static int
aucat_getcap(struct sio_hdl *sh, struct sio_cap *cap)
{
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;
	unsigned i, bps, le, sig, chan, rindex, rmult;
	static unsigned rates[] = { 8000, 11025, 12000 };

	AMSG_INIT(&hdl->wmsg);
	hdl->wmsg.cmd = AMSG_GETCAP;
	hdl->wtodo = sizeof(struct amsg);
	if (!aucat_wmsg(hdl))
		return 0;
	hdl->rtodo = sizeof(struct amsg);
	if (!aucat_rmsg(hdl))
		return 0;
	if (hdl->rmsg.cmd != AMSG_GETCAP) {
		DPRINTF("aucat_getcap: protocol err\n");
		hdl->sio.eof = 1;
		return 0;
	}
	bps = 1;
	sig = le = 0;
	cap->confs[0].enc = 0;
	for (i = 0; i < SIO_NENC; i++) {
		if (bps > 4)
			break;
		cap->confs[0].enc |= 1 << i;
		cap->enc[i].bits = bps == 4 ? 24 : bps * 8;
		cap->enc[i].bps = bps;
		cap->enc[i].sig = sig ^ 1;
		cap->enc[i].le = bps > 1 ? le : SIO_LE_NATIVE;
		cap->enc[i].msb = 1;
		le++;
		if (le > 1 || bps == 1) {
			le = 0;
			sig++;
		}
		if (sig > 1 || (le == 0 && bps > 1)) {
			sig = 0;
			bps++;
		}
	}
	chan = 1;
	cap->confs[0].rchan = 0;
	for (i = 0; i < SIO_NCHAN; i++) {
		if (chan > 16)
			break;
		cap->confs[0].rchan |= 1 << i;
		cap->rchan[i] = chan;
		if (chan >= 12) {
			chan += 4;
		} else if (chan >= 2) {
			chan += 2;
		} else
			chan++;
	}
	chan = 1;
	cap->confs[0].pchan = 0;
	for (i = 0; i < SIO_NCHAN; i++) {
		if (chan > 16)
			break;
		cap->confs[0].pchan |= 1 << i;
		cap->pchan[i] = chan;
		if (chan >= 12) {
			chan += 4;
		} else if (chan >= 2) {
			chan += 2;
		} else
			chan++;
	}
	rindex = 0;
	rmult = 1;
	cap->confs[0].rate = 0;
	for (i = 0; i < SIO_NRATE; i++) {
		if (rmult >= 32)
			break;
		cap->rate[i] = rates[rindex] * rmult;
		cap->confs[0].rate |= 1 << i;
		rindex++;
		if (rindex == sizeof(rates) / sizeof(unsigned)) {
			rindex = 0;
			rmult *= 2;
		}
	}
	cap->nconf = 1;
	return 1;
}

static size_t
aucat_read(struct sio_hdl *sh, void *buf, size_t len)
{
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;
	ssize_t n;

	while (hdl->rstate != STATE_DATA) {
		switch (hdl->rstate) {
		case STATE_MSG:
			if (!aucat_runmsg(hdl))
				return 0;
			break;
		case STATE_IDLE:
			DPRINTF("aucat_read: unexpected idle state\n");
			hdl->sio.eof = 1;
			return 0;
		}
	}
	if (len > hdl->rtodo)
		len = hdl->rtodo;
	while ((n = read(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			hdl->sio.eof = 1;
			DPERROR("aucat_read: read");
		}
		return 0;
	}
	if (n == 0) {
		DPRINTF("aucat_read: eof\n");
		hdl->sio.eof = 1;
		return 0;
	}
	hdl->rtodo -= n;
	if (hdl->rtodo == 0) {
		hdl->rstate = STATE_MSG;
		hdl->rtodo = sizeof(struct amsg);
	}
	DPRINTF("aucat: read: n = %zd\n", n);
	return n;
}

static int
aucat_buildmsg(struct aucat_hdl *hdl, size_t len)
{
	unsigned sz;

	if (hdl->curvol != hdl->reqvol) {
		hdl->wstate = STATE_MSG;
		hdl->wtodo = sizeof(struct amsg);
		hdl->wmsg.cmd = AMSG_SETVOL;
		hdl->wmsg.u.vol.ctl = hdl->reqvol;
		hdl->curvol = hdl->reqvol;
		return 1;
	} else if (len > 0 && hdl->maxwrite > 0) {
		sz = len;
		if (sz > AMSG_DATAMAX)
			sz = AMSG_DATAMAX;
		if (sz > hdl->maxwrite)
			sz = hdl->maxwrite;
		sz -= sz % hdl->wbpf;
		if (sz == 0)
			sz = hdl->wbpf;
		hdl->wstate = STATE_MSG;
		hdl->wtodo = sizeof(struct amsg);
		hdl->wmsg.cmd = AMSG_DATA;
		hdl->wmsg.u.data.size = sz;
		return 1;
	}
	return 0;
}

static size_t
aucat_write(struct sio_hdl *sh, const void *buf, size_t len)
{
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;
	ssize_t n;

	while (hdl->wstate != STATE_DATA) {
		switch (hdl->wstate) {
		case STATE_IDLE:
			if (!aucat_buildmsg(hdl, len))
				return 0;
			/* PASSTHROUGH */
		case STATE_MSG:
			if (!aucat_wmsg(hdl))
				return 0;
			if (hdl->wmsg.cmd == AMSG_DATA) {
				hdl->wstate = STATE_DATA;
				hdl->wtodo = hdl->wmsg.u.data.size;
			} else
				hdl->wstate = STATE_IDLE;
			break;
		default:
			DPRINTF("aucat_write: bad state\n");
			abort();
		}
	}
	if (hdl->maxwrite <= 0)
		return 0;
	if (len > hdl->maxwrite)
		len = hdl->maxwrite;
	if (len > hdl->wtodo)
		len = hdl->wtodo;
	if (len == 0) {
		DPRINTF("aucat_write: len == 0\n");
		abort();
	}
	while ((n = write(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			hdl->sio.eof = 1;
			DPERROR("aucat_write: write");
		}
		return 0;
	}
	hdl->maxwrite -= n;
	DPRINTF("aucat: write: n = %zd, maxwrite = %d\n", n, hdl->maxwrite);
	hdl->wtodo -= n;
	if (hdl->wtodo == 0) {
		hdl->wstate = STATE_IDLE;
		hdl->wtodo = 0xdeadbeef;
	}
	return n;
}

static int
aucat_pollfd(struct sio_hdl *sh, struct pollfd *pfd, int events)
{
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;

	hdl->events = events;
	if (hdl->maxwrite <= 0)
		events &= ~POLLOUT;
	if (hdl->rstate == STATE_MSG)
a319 1
	DPRINTF("aucat: pollfd: %x -> %x\n", hdl->events, pfd->events);
d323 2
a324 2
static int
aucat_revents(struct sio_hdl *sh, struct pollfd *pfd)
a325 1
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;
d328 2
a329 34
	if (revents & POLLIN) {
		while (hdl->rstate == STATE_MSG) {
			if (!aucat_runmsg(hdl)) {
				revents &= ~POLLIN;
				break;
			}
		}
	}
	if (revents & POLLOUT) {
		if (hdl->maxwrite <= 0)
			revents &= ~POLLOUT;
	}
	if (hdl->sio.eof)
		return POLLHUP;
	DPRINTF("aucat: revents: %x\n", revents & hdl->events);
	return revents & (hdl->events | POLLHUP);
}

static int
aucat_setvol(struct sio_hdl *sh, unsigned vol)
{
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;

	hdl->reqvol = vol;
	return 1;
}

static void
aucat_getvol(struct sio_hdl *sh)
{
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;

	sio_onvol_cb(&hdl->sio, hdl->reqvol);
	return;
@


1.42
log
@use MODE_xxx and XRUN_xxx macros everywhere, and zap corresponding
AMSG_xxx macros, which in turns simplifies the code
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.41 2010/06/05 16:00:52 ratchov Exp $	*/
@


1.41
log
@don't prime server buffers, because it's ugly and conceptually
complicated. Instead, request clients to provide enough samples
and start with buffers full.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.40 2010/06/05 13:40:47 ratchov Exp $	*/
d264 1
a264 5
	hdl->wmsg.u.hello.proto = 0;
	if (mode & SIO_PLAY)
		hdl->wmsg.u.hello.proto |= AMSG_PLAY;
	if (mode & SIO_REC)
		hdl->wmsg.u.hello.proto |= AMSG_REC;
@


1.40
log
@don't send clock ticks while buffers are being primed
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.39 2010/06/05 12:45:48 ratchov Exp $	*/
d154 2
a155 1
		DPRINTF("aucat: pos = %d, maxwrite = %u\n",
d164 1
a164 1
		DPRINTF("aucat: move = %d, delta = %d, maxwrite = %u\n",
d330 1
a330 1
	hdl->maxwrite = hdl->wbpf * par.appbufsz;
d332 1
@


1.39
log
@Don't send the initial position as a clock tick with a negative delta.
Add a new ``initial position'' message which is simpler. No bahaviour
change, except effects of the protocol version crank.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.38 2010/05/25 06:51:28 ratchov Exp $	*/
d156 1
d163 6
a168 4
		DPRINTF("aucat: tick = %d, maxwrite = %u\n",
		    hdl->rmsg.u.ts.delta, hdl->maxwrite);
		sio_onmove_cb(&hdl->sio, hdl->delta);
		hdl->delta = 0;
@


1.38
log
@complete any pending message when the device is stopped
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.37 2010/04/24 06:15:54 ratchov Exp $	*/
d153 6
d160 1
a160 3
		DPRINTF("aucat: tick, delta = %d\n", hdl->rmsg.u.ts.delta);
		if (hdl->rmsg.u.ts.delta > 0)
			hdl->maxwrite += hdl->rmsg.u.ts.delta * hdl->wbpf;
d162 4
a165 5
		if (hdl->delta >= 0) {
			DPRINTF("aucat: move: maxwrite = %d\n", hdl->maxwrite);
			sio_onmove_cb(&hdl->sio, hdl->delta);
			hdl->delta = 0;
		}
@


1.37
log
@remove trailing spaces, from Alexandr Shadchin, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.36 2010/04/22 17:43:30 ratchov Exp $	*/
d347 1
a347 1
	unsigned n, count, todo;
d356 1
a356 1
	 * complete data block in progress
d358 13
a370 7
	if (hdl->wstate != STATE_IDLE) {
		todo = (hdl->wstate == STATE_MSG) ?
		    hdl->wmsg.u.data.size : hdl->wtodo;
		hdl->maxwrite = todo;
		memset(zero, 0, ZERO_MAX);
		while (todo > 0) {
			count = todo;
a375 1
			todo -= n;
@


1.36
log
@Allow multiple users to share the same aucat server. If aucat is
run by root, it binds a shared address to the socket, cranks the
process priority and drops privileges. sio_open(3) will try to
connect to the private socket first (if any), then to the shared
socket. Only one user may have connections to aucat at a given
time.

based on discussions with henning, pyr and others
ok jacek, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.35 2010/04/06 20:07:01 ratchov Exp $	*/
d192 1
a192 1
	struct sockaddr_un ca;	
d219 1
a219 1
	sio_create(&hdl->sio, &aucat_ops, mode, nbio);	
d359 1
a359 1
		todo = (hdl->wstate == STATE_MSG) ? 
d692 1
a692 1
	pfd->events = events;		
@


1.35
log
@aucat (server):

  - make the ``-m mode'' option per subdevice, allowing
    subdevices to be play-only or rec-only even if the
    server is full-duplex

  - add ``monitoring'' mode (with ``-m mon''). This is a
    record-only stream from which played streams can be
    recorded (kind of ``record what you hear'').

  - allow MIDI devices to be subscribed to the controlling
    MIDI port of the server, ie what midicat does (with -f
    option), but using the -q option.

  - add flow control to the protocol, and serialize clock
    ticks (sio_onmove() calls) and data chunks.  This should
    fix certain full-duplex programs, broken with ``magic''
    block/buffer size combinations.

  - enable 3 block latency which is the minimum theoretical.
    Make -z and -b options correspond to device parameters.

  - make sio_getcap(3) the same for aucat and sun backends,
    ie return whatever is supported (``everything'' in the
    aucat case, since everything is actulally supported).

aucat (player):

  - enable ``-m mode'' option  to select between monitoring
    and recording when ``-o file'' is used.

  - plug MIDI code to non-server codepath. The MIDI control
    device is specified with the ``-q device'' option, as in
    server mode.

  - impliment lseek()'ing within files (controlled
    through MIDI). Necessary to use aucat with a MIDI
    sequencer.

midicat (thrubox):

  - rename ``-f'' flag to ``-q'', so it has the
    same name as in aucat (-f is still working)

ok jakemsr@@, tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.34 2010/01/20 13:17:22 jakemsr Exp $	*/
d228 10
a237 1
		goto bad_connect;
@


1.34
log
@back out last commit.  breaks half-duplex playback with poll().
ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.33 2010/01/15 22:28:23 ratchov Exp $	*/
a45 2
	unsigned devbufsz;		/* server side buffer size (in frames) */
	unsigned attached;		/* stream attached to device */
d154 3
a156 5
		if (!hdl->attached) {
			DPRINTF("aucat_runmsg: attached\n");
			hdl->maxwrite += hdl->devbufsz * hdl->wbpf;
			hdl->attached = 1;
		}
d159 1
a159 1
			hdl->maxwrite += hdl->delta * hdl->wbpf;
a314 2
	hdl->devbufsz = par.bufsz - par.appbufsz;
	hdl->attached = 0;
d460 2
d476 64
a539 12
	cap->enc[0].bits = hdl->rmsg.u.cap.bits;
	cap->enc[0].bps = SIO_BPS(hdl->rmsg.u.cap.bits);
	cap->enc[0].sig = 1;
	cap->enc[0].le = SIO_LE_NATIVE;
	cap->enc[0].msb = 1;
	cap->rchan[0] = hdl->rmsg.u.cap.rchan;
	cap->pchan[0] = hdl->rmsg.u.cap.pchan;
	cap->rate[0] = hdl->rmsg.u.cap.rate;
	cap->confs[0].enc = 1;
	cap->confs[0].rchan = (hdl->rmsg.u.cap.rchan > 0) ? 1 : 0;
	cap->confs[0].pchan = (hdl->rmsg.u.cap.pchan > 0) ? 1 : 0;
	cap->confs[0].rate = 1;
d583 1
d663 1
d684 1
d708 1
@


1.33
log
@Keep in memory whether the socket is writable. This way sio_revents()
can return POLLOUT (if requested), even the handle was not writable when
sio_pollfd() was called but become writable somewhere in the code path
of sio_revents().

This should improve stability of programs using very small buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.32 2009/10/26 19:06:28 ratchov Exp $	*/
a43 1
	int canwrite;			/* got POLLOUT event */
a128 1
			hdl->canwrite = 0;
a334 1
	hdl->canwrite = 0;
a610 1
		hdl->canwrite = 0;
d628 1
a628 1
	if (hdl->canwrite)
a629 2
	else
		events |= POLLOUT;
d633 1
a633 1
	pfd->events = events;
a642 2
	if (revents & POLLOUT)
		hdl->canwrite = 1;
d651 4
a654 3
	revents &= ~POLLOUT;
	if (hdl->canwrite && hdl->maxwrite > 0)
		revents |= POLLOUT;
@


1.32
log
@reader state cannot be IDLE, terminate the stream if so rather
entering a busy loop
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.31 2009/10/24 09:35:16 ratchov Exp $	*/
d44 1
d130 1
d337 1
d614 1
d632 1
a632 1
	if (hdl->maxwrite <= 0)
d634 2
d639 1
a639 1
	pfd->events = events;		
d649 2
d659 3
a661 4
	if (revents & POLLOUT) {
		if (hdl->maxwrite <= 0)
			revents &= ~POLLOUT;
	}
@


1.31
log
@Flow control blocks the client in sio_write(3). Split the data
stream in a way that the pause never occurs in the middle of data
chunks. Beside being more natural, this allows the client to send
non-data messages during the pause (set the volume, stop playback...),
rather than delaying them until the end of the pause. It's about
few milliseconds only.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.30 2009/10/22 21:41:30 ratchov Exp $	*/
d509 3
a511 2
			DPRINTF("aucat_read: unexpected idle\n");
			break;
@


1.30
log
@When starting playback, the client tries to write ``bufsz'' frames
instead of ``appbufsz'', which violates the flow control mechanism.
Fix this longstanding bug by enabling negative values in AMSG_MOVE
messages, this way the client is notified when its stream is
attached to the mixer, and can update its max transfer limit.

Since this fix changes the AMSG_MOVE message format, we crank the
protocol version, and thus remove code specific to the old protocol.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.29 2009/10/17 10:55:43 ratchov Exp $	*/
d549 6
a554 2
	} else if (len > 0) {
		sz = (len < AMSG_DATAMAX) ? len : AMSG_DATAMAX;
@


1.29
log
@Add version number to aucat protocol. It's not used yet,
but later, it will permit aucat to reject connections from
clients statically linked to a unsupported version of libsndio.

idea from kittenis, otto and sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.28 2009/08/28 10:52:14 ratchov Exp $	*/
d46 3
d156 11
a166 2
		hdl->maxwrite += hdl->rmsg.u.ts.delta * (int)hdl->wbpf;
		sio_onmove_cb(&hdl->sio, hdl->rmsg.u.ts.delta);
d318 4
a321 1
	hdl->maxwrite = hdl->wbpf * par.bufsz;
@


1.28
log
@don't consider calling sio_close() without calling sio_stop() first
as a programming error. At any stage the program should be alble to
cleanly free resources and close the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.27 2009/08/28 10:03:36 ratchov Exp $	*/
d239 1
@


1.27
log
@when using aucat backend, wait for the server to drop the connection
on sio_close()
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.26 2009/08/28 06:37:06 ratchov Exp $	*/
d275 2
@


1.26
log
@add a new AMSG_BYE, sent by the client to requst the server to
free resources and drop the connection. This allows the client
to ensuire that at any time it's using only one connection, thus
only one MIDI control channel.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.25 2009/08/26 05:33:01 ratchov Exp $	*/
d273 1
d279 4
a282 1
		(void)aucat_wmsg(hdl);
d284 1
@


1.25
log
@handle incoming AMSG_SETVOL messages, allows the client to be notified
of volume changes
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.24 2009/07/26 12:38:20 ratchov Exp $	*/
d274 6
@


1.24
log
@sort and space headers as per style(9)
from Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.23 2009/07/25 11:15:56 ratchov Exp $	*/
d155 6
@


1.23
log
@use const qualifier in libsndio, making it slightly more consistent
with open(2) and write(2) syscalls.
from Thomas Pfaff, jakemsr is fine with it
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.22 2009/07/25 08:44:26 ratchov Exp $	*/
d17 1
d21 1
d26 1
a27 1
#include <stdlib.h>
@


1.22
log
@Currently midi capable programs can control midi hardware, but
cannot cooperate with other programs.  The aim of this change is
to allow any program to send midi data to other programs as they
were midi hardware. For instance, this change should solve the
longstanding problem of using a midi sequencer with software
synthesizers. More precisely:

 - new midicat(1) utility (actually hardlink to aucat(1)).
   it creates software midi thru boxes, allowing programs
   to send midi messages to other programs as they were
   midi(4) hardware.

 - new midi api in libsndio (see mio_open(3)), to access
   midi(4) devices and midicat(1) sockets in a uniform way.

 - new device naming scheme <service>:<unit>[.<option>],
   common to audio and midi.

 - new sndio(7) manual describing concepts and naming

The current audio device naming still works, but people having
scripts or configuration files containing device names could read
the sndio(7) man page and slowly start updating device names.

discussed with jakemsr@@ and deraadt@@, help form jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.21 2009/05/16 12:10:52 ratchov Exp $	*/
d53 1
a53 1
static size_t aucat_write(struct sio_hdl *, void *, size_t);
d170 1
a170 1
sio_open_aucat(char *str, unsigned mode, int nbio)
d527 1
a527 1
aucat_write(struct sio_hdl *sh, void *buf, size_t len)
@


1.21
log
@don't set mode in sio_setpar(), already done at initialization
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.20 2009/05/16 11:15:26 ratchov Exp $	*/
d170 1
a170 1
sio_open_aucat(char *path, unsigned mode, int nbio)
d174 1
d180 13
a192 2
	if (path == NULL)
		path = SIO_AUCAT_PATH;
d194 1
a194 1
	if (strchr(path, '/') != NULL)
d197 1
a197 1
	    "/tmp/aucat-%u/%s", uid, path);
d211 1
d238 2
@


1.20
log
@add a new ``hello'' message to aucat protocol useful to work on
future aucat extentions. No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.19 2009/05/16 09:04:45 ratchov Exp $	*/
a364 1
	hdl->wmsg.u.par.mode = hdl->sio.mode;
@


1.19
log
@fix style to make future diffs contain functional changes only
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.18 2009/05/16 09:01:56 ratchov Exp $	*/
d172 1
a173 1
	struct sio_cap cap;
d212 19
a230 1
	if (!sio_getcap(&hdl->sio, &cap))
d232 3
a234 2
	if (((mode & SIO_PLAY) && cap.confs[0].pchan == 0) ||
	    ((mode & SIO_REC)  && cap.confs[0].rchan == 0))
d236 1
@


1.18
log
@in aucat_getpar() and aucat_getcap(), initialize the message to send
with AMSG_INIT(), rather than the reply we expect.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.17 2009/05/15 13:10:39 ratchov Exp $	*/
a73 57
struct sio_hdl *
sio_open_aucat(char *path, unsigned mode, int nbio)
{
	int s;
	struct sio_cap cap;
	struct aucat_hdl *hdl;
	struct sockaddr_un ca;	
	socklen_t len = sizeof(struct sockaddr_un);
	uid_t uid;

	if (path == NULL)
		path = SIO_AUCAT_PATH;
	uid = geteuid();
	if (strchr(path, '/') != NULL)
		return NULL;
	snprintf(ca.sun_path, sizeof(ca.sun_path),
	    "/tmp/aucat-%u/%s", uid, path);
	ca.sun_family = AF_UNIX;

	hdl = malloc(sizeof(struct aucat_hdl));
	if (hdl == NULL)
		return NULL;
	sio_create(&hdl->sio, &aucat_ops, mode, nbio);	

	s = socket(AF_UNIX, SOCK_STREAM, 0);
	if (s < 0)
		goto bad_free;
	while (connect(s, (struct sockaddr *)&ca, len) < 0) {
		if (errno == EINTR)
			continue;
		goto bad_connect;
	}
	if (fcntl(s, F_SETFD, FD_CLOEXEC) < 0) {
		DPERROR("FD_CLOEXEC");
		goto bad_connect;
	}
	hdl->fd = s;
	hdl->rstate = STATE_IDLE;
	hdl->rtodo = 0xdeadbeef;
	hdl->wstate = STATE_IDLE;
	hdl->wtodo = 0xdeadbeef;
	hdl->curvol = SIO_MAXVOL;
	hdl->reqvol = SIO_MAXVOL;
	if (!sio_getcap(&hdl->sio, &cap))
		goto bad_connect;
	if (((mode & SIO_PLAY) && cap.confs[0].pchan == 0) ||
	    ((mode & SIO_REC)  && cap.confs[0].rchan == 0))
		goto bad_connect;
	return (struct sio_hdl *)hdl;
 bad_connect:
	while (close(s) < 0 && errno == EINTR)
		; /* retry */
 bad_free:
	free(hdl);
	return NULL;
}

d167 57
@


1.17
log
@replace s/sa/sio/, left from when libsa was renamed to libsndio
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.16 2009/05/15 13:04:52 ratchov Exp $	*/
d361 1
a361 1
	AMSG_INIT(&hdl->rmsg);
d396 1
a396 1
	AMSG_INIT(&hdl->rmsg);
@


1.16
log
@if DEBUG is defined, use a global debug level rather
than a per-stream debug level. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.15 2009/02/25 23:31:59 ratchov Exp $	*/
d32 1
a32 1
	struct sio_hdl sa;
d96 1
a96 1
	sio_create(&hdl->sa, &aucat_ops, mode, nbio);	
d117 1
a117 1
	if (!sio_getcap(&hdl->sa, &cap))
d147 1
a147 1
				hdl->sa.eof = 1;
d154 1
a154 1
			hdl->sa.eof = 1;
d178 1
a178 1
				hdl->sa.eof = 1;
d201 1
a201 1
			hdl->sa.eof = 1;
d209 1
a209 1
		sio_onmove_cb(&hdl->sa, hdl->rmsg.u.ts.delta);
d220 1
a220 1
		hdl->sa.eof = 1;
d245 1
a245 1
	if (!sio_getpar(&hdl->sa, &par))
d260 1
a260 1
		hdl->sa.eof = 1;
d276 1
a276 1
		hdl->sa.eof = 1;
d292 1
a292 1
			n = aucat_write(&hdl->sa, zero, count);
d322 1
a322 1
			if (!aucat_read(&hdl->sa, zero, ZERO_MAX))
d345 2
a346 2
	hdl->wmsg.u.par.mode = hdl->sa.mode;
	if (hdl->sa.mode & SIO_REC)
d348 1
a348 1
	if (hdl->sa.mode & SIO_PLAY)
d371 1
a371 1
		hdl->sa.eof = 1;
d384 1
a384 1
	if (hdl->sa.mode & SIO_PLAY)
d386 1
a386 1
	if (hdl->sa.mode & SIO_REC)
d406 1
a406 1
		hdl->sa.eof = 1;
d448 1
a448 1
			hdl->sa.eof = 1;
d455 1
a455 1
		hdl->sa.eof = 1;
d532 1
a532 1
			hdl->sa.eof = 1;
d579 1
a579 1
	if (hdl->sa.eof)
d598 1
a598 1
	sio_onvol_cb(&hdl->sa, hdl->reqvol);
@


1.15
log
@after the STOP message is sent, move the receiver to the RMSG state
only if it's in the IDLE state, otherwise in some rare cases a data
chunk may be interpreted as a message, causing the connection to be
dropped.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.14 2009/02/18 07:32:27 ratchov Exp $	*/
d107 1
a107 1
		DPERROR(&hdl->sa, "FD_CLOEXEC");
d148 1
a148 1
				DPERROR(&hdl->sa, "aucat_rmsg: read");
d153 1
a153 1
			DPRINTF(&hdl->sa, "aucat_rmsg: eof\n");
d179 1
a179 1
				DPERROR(&hdl->sa, "aucat_wmsg: write");
d200 1
a200 1
			DPRINTF(&hdl->sa, "aucat_runmsg: bad data message\n");
d219 1
a219 1
		DPRINTF(&hdl->sa, "aucat_runmsg: unknown message\n");
d259 1
a259 1
		DPERROR(&hdl->sa, "aucat_start: fcntl(0)");
d275 1
a275 1
		DPERROR(&hdl->sa, "aucat_stop: fcntl(0)");
d370 1
a370 1
		DPRINTF(&hdl->sa, "aucat_getpar: protocol err\n");
d405 1
a405 1
		DPRINTF(&hdl->sa, "aucat_getcap: protocol err\n");
d438 1
a438 1
			DPRINTF(&hdl->sa, "aucat_read: unexpected idle\n");
d449 1
a449 1
			DPERROR(&hdl->sa, "aucat_read: read");
d454 1
a454 1
		DPRINTF(&hdl->sa, "aucat_read: eof\n");
d514 1
a514 1
			DPRINTF(&hdl->sa, "aucat_write: bad state\n");
d525 1
a525 1
		DPRINTF(&hdl->sa, "aucat_write: len == 0\n");
d533 1
a533 1
			DPERROR(&hdl->sa, "aucat_write: write");
@


1.14
log
@in aucat_stop(), after the STOP message was send, put the receiver
in ``waiting state'', otherwise the ACK message will be skipped,
and the other functions not expecting ACKs might be confused by
the ACK.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.13 2009/02/04 07:54:00 ratchov Exp $	*/
d307 4
a310 2
	hdl->rstate = STATE_MSG;
	hdl->rtodo = sizeof(struct amsg);
@


1.13
log
@Programs have no direct access do the device file descriptor. So, if
the programs calls execvp(2), the new image can't use the device, which
stays open, so other programs get EBUSY. Set the close-on-exec flag to
avoid this.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.12 2009/02/03 19:44:58 ratchov Exp $	*/
d307 2
@


1.12
log
@in server mode, create /tmp/aucat-userid/ directory with
permissions 0700, and create sockets in it. This prevents
one local user to eavesdrop or disturb audio programs of
other users.

if you're using the ``-s socket'' option with an absolute
path as argument, please update it to use a socket name.

requested by many, bits from jakemsr and otto
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.11 2009/01/10 20:34:44 ratchov Exp $	*/
d104 4
@


1.11
log
@make all private functions static
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.10 2008/12/27 12:10:42 ratchov Exp $	*/
d82 1
d86 7
a100 2
	ca.sun_family = AF_UNIX;
	memcpy(ca.sun_path, path, strlen(path) + 1);
@


1.10
log
@when polling aucat(1) socket, don't set the POLLIN bit if we
don't expect messages. Avoids busy loops in programs calling
poll(2) on a stopped device.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.9 2008/12/27 11:35:50 ratchov Exp $	*/
d46 12
a57 12
void aucat_close(struct sio_hdl *);
int aucat_start(struct sio_hdl *);
int aucat_stop(struct sio_hdl *);
int aucat_setpar(struct sio_hdl *, struct sio_par *);
int aucat_getpar(struct sio_hdl *, struct sio_par *);
int aucat_getcap(struct sio_hdl *, struct sio_cap *);
size_t aucat_read(struct sio_hdl *, void *, size_t);
size_t aucat_write(struct sio_hdl *, void *, size_t);
int aucat_pollfd(struct sio_hdl *, struct pollfd *, int);
int aucat_revents(struct sio_hdl *, struct pollfd *);
int aucat_setvol(struct sio_hdl *, unsigned);
void aucat_getvol(struct sio_hdl *);
d59 1
a59 1
struct sio_ops aucat_ops = {
d124 1
a124 1
int
d155 1
a155 1
int
d181 1
a181 1
int
d216 1
a216 1
void
d226 1
a226 1
int
d256 1
a256 1
int
d316 1
a316 1
int
d342 1
a342 1
int
d377 1
a377 1
int
d411 1
a411 1
size_t
d452 1
a452 1
int
d478 1
a478 1
size_t
d532 1
a532 1
int
d547 1
a547 1
int
d570 1
a570 1
int
d579 1
a579 1
void
@


1.9
log
@when using the aucat(1) backend, don't mask the POLLHUP bit
even if the device is not started yet. This way, if the server
is killed programs can notice it.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.8 2008/12/21 10:03:25 ratchov Exp $	*/
d540 1
a540 1
	if (hdl->rstate != STATE_DATA)
@


1.8
log
@fix more spelling errors and typos,
from Thomas Pfaff <tpfaff(at)@@tp76.info>, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.7 2008/12/17 10:00:50 ratchov Exp $	*/
d567 1
a567 1
	return revents & hdl->events;
@


1.7
log
@stop using stderr in the library, wrap all diagnostic fprintfs
so they are visible only when the DEBUG macro is #defined
and SIO_DEBUG env. variable is set.
requested by many, discussed with jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.6 2008/12/17 07:31:38 ratchov Exp $	*/
d38 1
a38 1
#define STATE_DATA	2		/* data being transfered */
d190 1
a190 1
			DPRINTF(&hdl->sa, "aucat_read: bad data message\n");
d209 1
a209 1
		DPRINTF(&hdl->sa, "aucat_read: unknown mesg\n");
@


1.6
log
@fix spell errors, from Thomas Pfaff <tpfaff(at)tp76.info>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.5 2008/12/17 07:19:27 ratchov Exp $	*/
d138 1
a138 1
				perror("aucat_rmsg: read");
d143 1
a143 1
			fprintf(stderr, "aucat_rmsg: eof\n");
d169 1
a169 1
				perror("aucat_wmsg: write");
d190 1
a190 1
			fprintf(stderr, "aucat_read: bad data message\n");
d209 1
a209 1
		fprintf(stderr, "aucat_read: unknown mesg\n");
d249 1
a249 1
		perror("aucat_start: fcntl(0)");
d265 1
a265 1
		perror("aucat_stop: fcntl(0)");
d356 1
a356 1
		fprintf(stderr, "aucat_getpar: protocol err\n");
d391 1
a391 1
		fprintf(stderr, "aucat_getcap: protocol err\n");
d424 1
a424 1
			fprintf(stderr, "aucat_read: unexpected idle\n");
d435 1
a435 1
			perror("aucat_read: read");
d440 1
a440 1
		fprintf(stderr, "aucat_read: eof\n");
d500 1
a500 1
			fprintf(stderr, "aucat_write: bad state\n");
d511 1
a511 1
		fprintf(stderr, "aucat_write: len == 0\n");
d519 1
a519 1
			perror("aucat_write: write");
@


1.5
log
@add a writable ``appbufsz'' field to the sa_par structure, containing
the program-part of the buffer size, ie the part that is subject to
underruns. Useful for apps like cdio(1) that don't have their own
rings, or to apps that have a minimum ring size constraint. Setting
the ``bufsz'' parameter becomes deprecated.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.4 2008/11/17 07:04:13 ratchov Exp $	*/
d500 1
a500 1
			fprintf(stderr, "aucat_read: bad state\n");
d519 1
a519 1
			perror("aucat_read: read");
@


1.4
log
@allow aucat to run as server in play-only and record-only mode, so
it can be used on play-only, record-only and half-duplex devices.
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.3 2008/11/16 21:18:30 ratchov Exp $	*/
d329 1
a329 1
	hdl->wmsg.u.par.bufsz = par->bufsz;
d367 1
@


1.3
log
@when the aucat backend is used, sio_revents(3) should return POLLHUP
if the connection to the server is lost.
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.2 2008/11/11 19:39:35 ratchov Exp $	*/
d78 1
d91 2
a92 4
	if (s < 0) {
		free(hdl);
		return NULL;
	}	
d98 1
a98 4
		while (close(s) < 0 && errno == EINTR)
			; /* retry */
		free(hdl);
		return NULL;
d107 5
d113 6
d403 2
a404 2
	cap->confs[0].pchan = (hdl->sa.mode & SIO_PLAY) ? 1 : 0;
	cap->confs[0].rchan = (hdl->sa.mode & SIO_REC) ? 1 : 0;
@


1.2
log
@expose a volume knob in the sndio API: add sio_setvol(3) and
sio_onvol(3) functions. The audio(4) backend tries to use the
inputs.dac, outputs.dac, outputs.output and outputs.master
controls (in this order). Add a sample file in
regress/lib/libsndio/vol/vol.c
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.1 2008/10/27 00:26:33 ratchov Exp $	*/
d557 2
@


1.1
log
@rename libsa to libsndio
requested by many, "just go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aucat.c,v 1.1 2008/10/26 08:49:44 ratchov Exp $	*/
d43 1
d56 2
d69 3
a71 1
	aucat_revents
d109 2
d444 2
a445 2
size_t
aucat_write(struct sio_hdl *sh, void *buf, size_t len)
a446 1
	struct aucat_hdl *hdl = (struct aucat_hdl *)sh;
a447 1
	ssize_t n;
d449 8
a456 2
	switch (hdl->wstate) {
	case STATE_IDLE:
d465 28
a492 16
		/* PASSTHROUGH */
	case STATE_MSG:
		if (!aucat_wmsg(hdl))
			return 0;
		hdl->wstate = STATE_DATA;
		hdl->wtodo = hdl->wmsg.u.data.size;
		/* PASSTHROUGH */
	case STATE_DATA:
		if (hdl->maxwrite <= 0)
			return 0;
		if (len > hdl->maxwrite)
			len = hdl->maxwrite;
		if (len > hdl->wtodo)
			len = hdl->wtodo;
		if (len == 0) {
			fprintf(stderr, "aucat_write: len == 0\n");
d495 17
a511 8
		while ((n = write(hdl->fd, buf, len)) < 0) {
			if (errno == EINTR)
				continue;
			if (errno != EAGAIN) {
				hdl->sa.eof = 1;
				perror("aucat_read: read");
			}
			return 0;
d513 7
a519 10
		hdl->maxwrite -= n;
		hdl->wtodo -= n;
		if (hdl->wtodo == 0) {
			hdl->wstate = STATE_IDLE;
			hdl->wtodo = 0xdeadbeef;
		}
		return n;
	default:
		fprintf(stderr, "aucat_read: bad state\n");
		abort();
d521 1
d558 18
@

