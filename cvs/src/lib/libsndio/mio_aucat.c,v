head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.8
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.10.0.10
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.12
date	2016.01.09.08.27.24;	author ratchov;	state Exp;
branches;
next	1.11;
commitid	ScnbaRlQejqjUMct;

1.11
date	2015.11.22.12.01.23;	author ratchov;	state Exp;
branches;
next	1.10;
commitid	qJB6f577aQuApYmn;

1.10
date	2013.11.13.22.38.22;	author ratchov;	state Exp;
branches;
next	1.9;

1.9
date	2012.11.02.10.24.58;	author ratchov;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.27.12.08.25;	author ratchov;	state Exp;
branches;
next	1.7;

1.7
date	2012.04.11.06.05.43;	author ratchov;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.15.08.05.22;	author ratchov;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.17.21.09.11;	author ratchov;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.18.23.57.35;	author ratchov;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.16.11.51.47;	author ratchov;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.16.10.52.22;	author ratchov;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.12.21.40.22;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Make code fit in 80 columns, remove trailing spaces & tabs.
@
text
@/*	$OpenBSD: mio_aucat.c,v 1.10 2013/11/13 22:38:22 ratchov Exp $	*/
/*
 * Copyright (c) 2008 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>

#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "aucat.h"
#include "debug.h"
#include "mio_priv.h"

struct mio_aucat_hdl {
	struct mio_hdl mio;
	struct aucat aucat;
	int events;
};

static void mio_aucat_close(struct mio_hdl *);
static size_t mio_aucat_read(struct mio_hdl *, void *, size_t);
static size_t mio_aucat_write(struct mio_hdl *, const void *, size_t);
static int mio_aucat_nfds(struct mio_hdl *);
static int mio_aucat_pollfd(struct mio_hdl *, struct pollfd *, int);
static int mio_aucat_revents(struct mio_hdl *, struct pollfd *);

static struct mio_ops mio_aucat_ops = {
	mio_aucat_close,
	mio_aucat_write,
	mio_aucat_read,
	mio_aucat_nfds,
	mio_aucat_pollfd,
	mio_aucat_revents
};

/*
 * execute the next message, return 0 if blocked
 */
static int
mio_aucat_runmsg(struct mio_aucat_hdl *hdl)
{
	int delta;

	if (!_aucat_rmsg(&hdl->aucat, &hdl->mio.eof))
		return 0;
	switch (ntohl(hdl->aucat.rmsg.cmd)) {
	case AMSG_DATA:
		return 1;
	case AMSG_FLOWCTL:
		delta = ntohl(hdl->aucat.rmsg.u.ts.delta);
		hdl->aucat.maxwrite += delta;
		DPRINTF("aucat: flowctl = %d, maxwrite = %d\n",
		    delta, hdl->aucat.maxwrite);
		break;
	default:
		DPRINTF("mio_aucat_runmsg: unhandled message %u\n",
		    hdl->aucat.rmsg.cmd);
		hdl->mio.eof = 1;
		return 0;
	}
	hdl->aucat.rstate = RSTATE_MSG;
	hdl->aucat.rtodo = sizeof(struct amsg);
	return 1;
}

struct mio_hdl *
_mio_aucat_open(const char *str, unsigned int mode, int nbio)
{
	struct mio_aucat_hdl *hdl;

	hdl = malloc(sizeof(struct mio_aucat_hdl));
	if (hdl == NULL)
		return NULL;
	if (!_aucat_open(&hdl->aucat, str, mode))
		goto bad;
	_mio_create(&hdl->mio, &mio_aucat_ops, mode, nbio);
	if (!_aucat_setfl(&hdl->aucat, 1, &hdl->mio.eof))
		goto bad;
	return (struct mio_hdl *)hdl;
bad:
	free(hdl);
	return NULL;
}

static void
mio_aucat_close(struct mio_hdl *sh)
{
	struct mio_aucat_hdl *hdl = (struct mio_aucat_hdl *)sh;

	if (!hdl->mio.eof)
		_aucat_setfl(&hdl->aucat, 0, &hdl->mio.eof);
	_aucat_close(&hdl->aucat, hdl->mio.eof);
	free(hdl);
}

static size_t
mio_aucat_read(struct mio_hdl *sh, void *buf, size_t len)
{
	struct mio_aucat_hdl *hdl = (struct mio_aucat_hdl *)sh;

	while (hdl->aucat.rstate == RSTATE_MSG) {
		if (!mio_aucat_runmsg(hdl))
			return 0;
	}
	return _aucat_rdata(&hdl->aucat, buf, len, &hdl->mio.eof);
}

static size_t
mio_aucat_write(struct mio_hdl *sh, const void *buf, size_t len)
{
	struct mio_aucat_hdl *hdl = (struct mio_aucat_hdl *)sh;
	size_t n;

	if (len <= 0 || hdl->aucat.maxwrite <= 0)
		return 0;
	if (len > hdl->aucat.maxwrite)
		len = hdl->aucat.maxwrite;
	n = _aucat_wdata(&hdl->aucat, buf, len, 1, &hdl->mio.eof);
	hdl->aucat.maxwrite -= n;
	return n;
}

static int
mio_aucat_nfds(struct mio_hdl *sh)
{
	return 1;
}

static int
mio_aucat_pollfd(struct mio_hdl *sh, struct pollfd *pfd, int events)
{
	struct mio_aucat_hdl *hdl = (struct mio_aucat_hdl *)sh;

	hdl->events = events;
	if (hdl->aucat.maxwrite <= 0)
		events &= ~POLLOUT;
	return _aucat_pollfd(&hdl->aucat, pfd, events);
}

static int
mio_aucat_revents(struct mio_hdl *sh, struct pollfd *pfd)
{
	struct mio_aucat_hdl *hdl = (struct mio_aucat_hdl *)sh;
	int revents = pfd->revents;

	if (revents & POLLIN) {
		while (hdl->aucat.rstate == RSTATE_MSG) {
			if (!mio_aucat_runmsg(hdl))
				break;
		}
		if (hdl->aucat.rstate != RSTATE_DATA)
			revents &= ~POLLIN;
	}
	if (revents & POLLOUT) {
		if (hdl->aucat.maxwrite <= 0)
			revents &= ~POLLOUT;
	}
	if (hdl->mio.eof)
		return POLLHUP;
	return revents & (hdl->events | POLLHUP);
}
@


1.11
log
@Don't remove the type component from the device string before passing
it to the *_open() functions. It's more flexible this way. No behaviour
change.
@
text
@d77 2
a78 1
		DPRINTF("mio_aucat_runmsg: unhandled message %u\n", hdl->aucat.rmsg.cmd);
@


1.10
log
@Prefix by '_' symbols that are not part of the API.

ok deraadt, guenther
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 1
a87 2
_mio_aucat_open(const char *str, unsigned int mode,
    int nbio, unsigned int type)
d94 1
a94 1
	if (!_aucat_open(&hdl->aucat, str, mode, type))
@


1.9
log
@Use dedicated messages for flow control instead of abusing clock tick
messages and enable flow control for MIDI. Since this requires protocol
version bump, both sndiod and libsndio must be kept up to date to work
together.
@
text
@d1 1
a1 1
/*	$OpenBSD: mio_aucat.c,v 1.8 2012/10/27 12:08:25 ratchov Exp $	*/
d65 1
a65 1
	if (!aucat_rmsg(&hdl->aucat, &hdl->mio.eof))
d87 1
a87 1
mio_aucat_open(const char *str, unsigned int mode,
d95 1
a95 1
	if (!aucat_open(&hdl->aucat, str, mode, type))
d97 2
a98 2
	mio_create(&hdl->mio, &mio_aucat_ops, mode, nbio);
	if (!aucat_setfl(&hdl->aucat, 1, &hdl->mio.eof))
d112 2
a113 2
		aucat_setfl(&hdl->aucat, 0, &hdl->mio.eof);
	aucat_close(&hdl->aucat, hdl->mio.eof);
d126 1
a126 1
	return aucat_rdata(&hdl->aucat, buf, len, &hdl->mio.eof);
d139 1
a139 1
	n = aucat_wdata(&hdl->aucat, buf, len, 1, &hdl->mio.eof);
d158 1
a158 1
	return aucat_pollfd(&hdl->aucat, pfd, events);
@


1.8
log
@make midi code use non-blocking i/o as does audio code, in order
to make both look similar
@
text
@d1 1
a1 1
/*	$OpenBSD: mio_aucat.c,v 1.7 2012/04/11 06:05:43 ratchov Exp $	*/
d57 29
d123 1
a123 1
		if (!aucat_rmsg(&hdl->aucat, &hdl->mio.eof))
d133 1
d135 7
a141 1
	return aucat_wdata(&hdl->aucat, buf, len, 1, &hdl->mio.eof);
d156 2
d169 1
a169 1
			if (!aucat_rmsg(&hdl->aucat, &hdl->mio.eof))
d174 4
@


1.7
log
@Use "unsigned int" rather than "unsigned". No object change.
suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mio_aucat.c,v 1.6 2011/11/15 08:05:22 ratchov Exp $	*/
d21 1
d44 1
d52 1
d54 1
a54 1
	mio_aucat_revents,
d69 1
a69 1
	if (!aucat_setfl(&hdl->aucat, nbio, &hdl->mio.eof))
d106 6
@


1.6
log
@Add a "device number" component in sndio(7) device names, allowing a
single aucat instance to handle all audio and MIDI services. Since
this partially breaks compatibility, this is a opportunitiy to fix few
other design mistakes (eg ':' being used by inet6, type name vs api
name confusion, etc..). This leads to the following names:

        type[@@hostname][,unit]/devnum[.option]

The device number is the minor device number for direct hardware
access (ie the 'N' in /dev/audioN). For aucat, this is the occurence
number of the -f (or -M) option.

There's a compatibility hook to keep old names working if only one
aucat server is running.
@
text
@d1 1
a1 1
/*	$OpenBSD: mio_aucat.c,v 1.5 2011/10/17 21:09:11 ratchov Exp $	*/
d55 2
a56 1
mio_aucat_open(const char *str, unsigned mode, int nbio, unsigned type)
@


1.5
log
@Remove midicat since aucat can now be used instead of midicat
with almost the same syntax (roughly an extra -M option).
Thru boxes are created with aucat, and corresponding MIDI port
names have the "aucat" prefix instead of "midithru". The old
device name will still work some time for backward compatibility.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mio_aucat.c,v 1.4 2011/04/18 23:57:35 ratchov Exp $	*/
d55 1
a55 1
mio_aucat_open(const char *str, unsigned mode, int nbio)
d62 1
a62 1
	if (!aucat_open(&hdl->aucat, str, mode))
@


1.4
log
@slightly cleanup by separating socket-specific code from
protocol specific code. No behaviour change
@
text
@d1 1
a1 1
/*	$OpenBSD: mio_aucat.c,v 1.3 2011/04/16 11:51:47 ratchov Exp $	*/
d54 2
a55 2
static struct mio_hdl *
mio_xxx_open(const char *str, unsigned mode, int nbio, int isaudio)
d62 1
a62 1
	if (!aucat_open(&hdl->aucat, str, mode, isaudio))
a70 12
}

struct mio_hdl *
mio_midithru_open(const char *str, unsigned mode, int nbio)
{
	return mio_xxx_open(str, mode, nbio, 0);
}

struct mio_hdl *
mio_aucat_open(const char *str, unsigned mode, int nbio)
{
	return mio_xxx_open(str, mode, nbio, 1);
@


1.3
log
@for unix domain socket addresses use AUCAT_PATH and MIDICAT_PATH
macros instead of hardcoded strings. No object change
@
text
@d1 1
a1 1
/*	$OpenBSD: mio_aucat.c,v 1.2 2011/04/16 10:52:22 ratchov Exp $	*/
d55 1
a55 1
mio_xxx_open(const char *str, char *sock, unsigned mode, int nbio)
d62 1
a62 1
	if (!aucat_open(&hdl->aucat, str, sock, mode, nbio))
d76 1
a76 1
	return mio_xxx_open(str, MIDICAT_PATH, mode, nbio);
d82 1
a82 1
	return mio_xxx_open(str, AUCAT_PATH, mode, nbio);
@


1.2
log
@Make aucat audio and midi backends share the same code to communicate
with the server. As we're at it use the same protocol for midi and
audio. Now, both audio and midi code use the same SNDIO_DEBUG environment
variable to turn on/off DPRINTF's.
@
text
@d1 1
a1 1
/*	$OpenBSD: mio_aucat.c,v 1.1 2011/04/12 21:40:22 ratchov Exp $	*/
d76 1
a76 1
	return mio_xxx_open(str, "midithru", mode, nbio);
d82 1
a82 1
	return mio_xxx_open(str, "softaudio", mode, nbio);
@


1.1
log
@Use mio_<backend>_ prefix for private midi-related functions and put
them in files named mio_<backend>.c
No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 2
a31 1
#include "amsg.h"
d36 2
a37 1
	int fd;
a56 5
	extern char *__progname;
	char unit[4], *sep, *opt;
	struct amsg msg;
	int s, n, todo;
	unsigned char *data;
a57 23
	struct sockaddr_un ca;
	socklen_t len = sizeof(struct sockaddr_un);
	uid_t uid;

	sep = strchr(str, '.');
	if (sep == NULL) {
		opt = "default";
		strlcpy(unit, str, sizeof(unit));
	} else {
		opt = sep + 1;
		if (sep - str >= sizeof(unit)) {
			DPRINTF("mio_aucat_open: %s: too long\n", str);
			return NULL;
		}
		strlcpy(unit, str, opt - str);
	}
	DPRINTF("mio_aucat_open: trying %s -> %s.%s\n", str, unit, opt);
	uid = geteuid();
	if (strchr(str, '/') != NULL)
		return NULL;
	snprintf(ca.sun_path, sizeof(ca.sun_path),
	    "/tmp/aucat-%u/%s%s", uid, sock, unit);
	ca.sun_family = AF_UNIX;
d62 2
d65 2
a66 66

	s = socket(AF_UNIX, SOCK_STREAM, 0);
	if (s < 0)
		goto bad_free;
	while (connect(s, (struct sockaddr *)&ca, len) < 0) {
		if (errno == EINTR)
			continue;
		DPERROR("mio_aucat_open: connect");
		/* try shared server */
		snprintf(ca.sun_path, sizeof(ca.sun_path),
		    "/tmp/aucat/%s%s", sock, unit);
		while (connect(s, (struct sockaddr *)&ca, len) < 0) {
			if (errno == EINTR)
				continue;
			DPERROR("mio_aucat_open: connect");
			goto bad_connect;
		}
		break;
 	}
	if (fcntl(s, F_SETFD, FD_CLOEXEC) < 0) {
		DPERROR("FD_CLOEXEC");
		goto bad_connect;
	}
	hdl->fd = s;

	/*
	 * say hello to server
	 */
	AMSG_INIT(&msg);
	msg.cmd = AMSG_HELLO;
	msg.u.hello.version = AMSG_VERSION;
	msg.u.hello.mode = mode;
	strlcpy(msg.u.hello.opt, opt, sizeof(msg.u.hello.opt));
	strlcpy(msg.u.hello.who, __progname, sizeof(msg.u.hello.who));
	n = write(s, &msg, sizeof(struct amsg));
	if (n < 0) {
		DPERROR("mio_aucat_open");
		goto bad_connect;
	}
	if (n != sizeof(struct amsg)) {
		DPRINTF("mio_aucat_open: short write\n");
		goto bad_connect;
	}
	todo = sizeof(struct amsg);
	data = (unsigned char *)&msg;
	while (todo > 0) {
		n = read(s, data, todo);
		if (n < 0) {
			DPERROR("mio_aucat_open");
			goto bad_connect;
		}
		if (n == 0) {
			DPRINTF("mio_aucat_open: eof\n");
			goto bad_connect;
		}
		todo -= n;
		data += n;
	}
	if (msg.cmd != AMSG_ACK) {
		DPRINTF("mio_aucat_open: proto error\n");
		goto bad_connect;
	}
	if (nbio && fcntl(hdl->fd, F_SETFL, O_NONBLOCK) < 0) {
		DPERROR("mio_aucat_open: fcntl(NONBLOCK)");
		goto bad_connect;
	}
d68 1
a68 4
 bad_connect:
	while (close(s) < 0 && errno == EINTR)
		; /* retry */
 bad_free:
a88 1
	int rc;
d90 3
a92 3
	do {
		rc = close(hdl->fd);
	} while (rc < 0 && errno == EINTR);
a99 1
	ssize_t n;
d101 3
a103 8
	while ((n = read(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			DPERROR("mio_aucat_read: read");
			hdl->mio.eof = 1;
		}
		return 0;
d105 1
a105 6
	if (n == 0) {
		DPRINTF("mio_aucat_read: eof\n");
		hdl->mio.eof = 1;
		return 0;
	}
	return n;
a111 1
	ssize_t n;
d113 1
a113 10
	while ((n = write(hdl->fd, buf, len)) < 0) {
		if (errno == EINTR)
			continue;
		if (errno != EAGAIN) {
			DPERROR("mio_aucat_write: write");
			hdl->mio.eof = 1;
		}
 		return 0;
	}
	return n;
d121 2
a122 3
	pfd->fd = hdl->fd;
	pfd->events = events;
	return 1;
d128 14
a141 1
	return pfd->revents;
@

