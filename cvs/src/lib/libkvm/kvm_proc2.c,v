head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.26;
commitid	W7ztnDZwvjCaeQTS;

1.26
date	2015.09.08.15.40.32;	author dlg;	state Exp;
branches;
next	1.25;
commitid	isQJqv6zi2SMXzXF;

1.25
date	2014.10.15.02.03.05;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	zOqt4CiDlaWcaRCM;

1.24
date	2014.07.08.23.31.22;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	3An6VhB3KqpFYVig;

1.23
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.22;
commitid	vhXZZxMGVTWiFaF3;

1.22
date	2014.05.25.20.28.28;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2014.03.30.21.54.49;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2014.03.22.11.18.05;	author florian;	state Exp;
branches;
next	1.19;

1.19
date	2014.02.05.03.49.00;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2013.11.12.14.49.41;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.20.14.46.45;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.20.03.43.08;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2012.11.12.00.29.09;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2012.04.17.23.17.53;	author pirofti;	state Exp;
branches;
next	1.12;

1.12
date	2012.04.14.12.15.21;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2012.04.12.14.59.19;	author pirofti;	state Exp;
branches;
next	1.10;

1.10
date	2012.03.23.15.51.25;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2012.01.07.05.38.12;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.05.04.48.01;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.18.21.44.55;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.15.17.58.25;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2011.03.12.04.54.28;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.29.16.39.23;	author guenther;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.10.03.37.50;	author guenther;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@/*	$OpenBSD: kvm_proc2.c,v 1.26 2015/09/08 15:40:32 dlg Exp $	*/
/*	$NetBSD: kvm_proc.c,v 1.30 1999/03/24 05:50:50 mrg Exp $	*/
/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software developed by the Computer Systems
 * Engineering group at Lawrence Berkeley Laboratory under DARPA contract
 * BG 91-66 and contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Proc traversal interface for kvm.  ps and w are (probably) the exclusive
 * users of this code, so we've factored it out into a separate module.
 * Thus, we keep this grunge out of the other kvm applications (i.e.,
 * most other applications are interested only in open/close/read/nlist).
 */

#define __need_process
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/exec.h>
#include <sys/stat.h>
#include <sys/ucred.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <nlist.h>
#include <kvm.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_amap.h>
#include <machine/vmparam.h>
#include <machine/pmap.h>

#include <sys/sysctl.h>

#include <limits.h>
#include <errno.h>
#include <db.h>
#include <paths.h>

#include "kvm_private.h"

/*
 * Read proc's from memory file into buffer bp, which has space to hold
 * at most maxcnt procs.
 */
static int
kvm_proclist(kvm_t *kd, int op, int arg, struct process *pr,
    char *bp, int maxcnt, size_t esize)
{
	struct kinfo_proc kp;
	struct session sess;
	struct ucred ucred;
	struct proc proc, *p;
	struct process process, process2;
	struct pgrp pgrp;
	struct tty tty;
	struct sigacts sa, *sap;
	struct vmspace vm, *vmp;
	struct plimit limits, *limp;
	pid_t parent_pid, leader_pid;
	int cnt = 0;
	int dothreads = 0;

	dothreads = op & KERN_PROC_SHOW_THREADS;
	op &= ~KERN_PROC_SHOW_THREADS;

	/*
	 * Modelled on sysctl_doproc() in sys/kern/kern_sysctl.c
	 */
	for (; cnt < maxcnt && pr != NULL; pr = LIST_NEXT(&process, ps_list)) {
		if (KREAD(kd, (u_long)pr, &process)) {
			_kvm_err(kd, kd->program, "can't read process at %lx",
			    (u_long)pr);
			return (-1);
		}
		if (process.ps_pgrp == NULL)
			continue;
		if (process.ps_flags & PS_EMBRYO)
			continue;
		if (KREAD(kd, (u_long)process.ps_ucred, &ucred)) {
			_kvm_err(kd, kd->program, "can't read ucred at %lx",
			    (u_long)process.ps_ucred);
			return (-1);
		}
		if (KREAD(kd, (u_long)process.ps_pgrp, &pgrp)) {
			_kvm_err(kd, kd->program, "can't read pgrp at %lx",
			    (u_long)process.ps_pgrp);
			return (-1);
		}
		if (KREAD(kd, (u_long)pgrp.pg_session, &sess)) {
			_kvm_err(kd, kd->program, "can't read session at %lx",
			    (u_long)pgrp.pg_session);
			return (-1);
		}
		if ((process.ps_flags & PS_CONTROLT) && sess.s_ttyp != NULL &&
		    KREAD(kd, (u_long)sess.s_ttyp, &tty)) {
			_kvm_err(kd, kd->program, "can't read tty at %lx",
			    (u_long)sess.s_ttyp);
			return (-1);
		}
		if (process.ps_pptr) {
			if (KREAD(kd, (u_long)process.ps_pptr, &process2)) {
				_kvm_err(kd, kd->program,
				    "can't read process at %lx",
				    (u_long)process.ps_pptr);
				return (-1);
			}
			parent_pid = process2.ps_pid;
		}
		else
			parent_pid = 0;
		if (sess.s_leader) {
			if (KREAD(kd, (u_long)sess.s_leader, &process2)) {
				_kvm_err(kd, kd->program,
				    "can't read proc at %lx",
				    (u_long)sess.s_leader);
				return (-1);
			}
			leader_pid = process2.ps_pid;
		}
		else
			leader_pid = 0;
		if (process.ps_sigacts) {
			if (KREAD(kd, (u_long)process.ps_sigacts, &sa)) {
				_kvm_err(kd, kd->program,
				    "can't read sigacts at %lx",
				    (u_long)process.ps_sigacts);
				return (-1);
			}
			sap = &sa;
		}
		else
			sap = NULL;

		switch (op) {
		case KERN_PROC_PID:
			if (parent_pid != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_PGRP:
			if (pgrp.pg_id != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_SESSION:
			if (sess.s_leader == NULL ||
			    leader_pid != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_TTY:
			if ((process.ps_flags & PS_CONTROLT) == 0 ||
			    sess.s_ttyp == NULL ||
			    tty.t_dev != (dev_t)arg)
				continue;
			break;

		case KERN_PROC_UID:
			if (ucred.cr_uid != (uid_t)arg)
				continue;
			break;

		case KERN_PROC_RUID:
			if (ucred.cr_ruid != (uid_t)arg)
				continue;
			break;

		case KERN_PROC_ALL:
			if (process.ps_flags & PS_SYSTEM)
				continue;
			break;

		case KERN_PROC_KTHREAD:
			/* no filtering */
			break;

		default:
			_kvm_err(kd, kd->program, "invalid filter");
			return (-1);
		}

		/*
		 * We're going to add another proc to the set.  If this
		 * will overflow the buffer, assume the reason is because
		 * nthreads (or the proc list) is corrupt and declare an error.
		 */
		if (cnt >= maxcnt) {
			_kvm_err(kd, kd->program, "nthreads corrupt");
			return (-1);
		}

		/* set up stuff that might not always be there */
		limp = &limits;
		if (!process.ps_limit ||
		    KREAD(kd, (u_long)process.ps_limit, &limits))
			limp = NULL;

		vmp = NULL;

		if ((process.ps_flags & PS_ZOMBIE) == 0 &&
		    !KREAD(kd, (u_long)process.ps_vmspace, &vm))
			vmp = &vm;

#define do_copy_str(_d, _s, _l)	kvm_read(kd, (u_long)(_s), (_d), (_l)-1)
		FILL_KPROC(&kp, do_copy_str, &proc, &process,
		    &ucred, &pgrp, process.ps_mainproc, pr, &sess,
		    vmp, limp, sap, 0, 1);

		/* stuff that's too painful to generalize */
		kp.p_ppid = parent_pid;
		kp.p_sid = leader_pid;
		if ((process.ps_flags & PS_CONTROLT) && sess.s_ttyp != NULL) {
			kp.p_tdev = tty.t_dev;
			if (tty.t_pgrp != NULL &&
			    tty.t_pgrp != process.ps_pgrp &&
			    KREAD(kd, (u_long)tty.t_pgrp, &pgrp)) {
				_kvm_err(kd, kd->program,
				    "can't read tpgrp at %lx",
				    (u_long)tty.t_pgrp);
				return (-1);
			}
			kp.p_tpgid = tty.t_pgrp ? pgrp.pg_id : -1;
			kp.p_tsess = PTRTOINT64(tty.t_session);
		} else {
			kp.p_tpgid = -1;
			kp.p_tdev = NODEV;
		}

		/* update %cpu for all threads */
		if (dothreads) {
			if (KREAD(kd, (u_long)process.ps_mainproc, &proc)) {
				_kvm_err(kd, kd->program,
				    "can't read proc at %lx",
				    (u_long)process.ps_mainproc);
				return (-1);
			}
			kp.p_pctcpu = proc.p_pctcpu;
			kp.p_stat   = proc.p_stat;
		} else {
			kp.p_pctcpu = 0;
			kp.p_stat = (process.ps_flags & PS_ZOMBIE) ? SDEAD :
			    SIDL;
			for (p = TAILQ_FIRST(&process.ps_threads); p != NULL; 
			    p = TAILQ_NEXT(&proc, p_thr_link)) {
				if (KREAD(kd, (u_long)p, &proc)) {
					_kvm_err(kd, kd->program,
					    "can't read proc at %lx",
					    (u_long)p);
					return (-1);
				}
				kp.p_pctcpu += proc.p_pctcpu;
				/*
				 * find best state:
				 * ONPROC > RUN > STOP > SLEEP > ...
				 */
				if (proc.p_stat == SONPROC ||
				    kp.p_stat == SONPROC)
					kp.p_stat = SONPROC;
				else if (proc.p_stat == SRUN ||
				    kp.p_stat == SRUN)
					kp.p_stat = SRUN;
				else if (proc.p_stat == SSTOP ||
				    kp.p_stat == SSTOP)
					kp.p_stat = SSTOP;
				else if (proc.p_stat == SSLEEP)
					kp.p_stat = SSLEEP;
			}
                }

		memcpy(bp, &kp, esize);
		bp += esize;
		++cnt;

		/* Skip per-thread entries if not required by op */
		if (!dothreads)
			continue;

		for (p = TAILQ_FIRST(&process.ps_threads); p != NULL; 
		    p = TAILQ_NEXT(&proc, p_thr_link)) {
			if (KREAD(kd, (u_long)p, &proc)) {
				_kvm_err(kd, kd->program,
				    "can't read proc at %lx",
				    (u_long)p);
				return (-1);
			}
			FILL_KPROC(&kp, do_copy_str, &proc, &process,
			    &ucred, &pgrp, p, pr, &sess, vmp, limp, sap,
			    1, 1);

			/* see above */
			kp.p_ppid = parent_pid;
			kp.p_sid = leader_pid;
			if ((process.ps_flags & PS_CONTROLT) &&
			    sess.s_ttyp != NULL) {
				kp.p_tdev = tty.t_dev;
				if (tty.t_pgrp != NULL &&
				    tty.t_pgrp != process.ps_pgrp &&
				    KREAD(kd, (u_long)tty.t_pgrp, &pgrp)) {
					_kvm_err(kd, kd->program,
					    "can't read tpgrp at %lx",
					    (u_long)tty.t_pgrp);
					return (-1);
				}
				kp.p_tpgid = tty.t_pgrp ? pgrp.pg_id : -1;
				kp.p_tsess = PTRTOINT64(tty.t_session);
			} else {
				kp.p_tpgid = -1;
				kp.p_tdev = NODEV;
			}
		}

		memcpy(bp, &kp, esize);
		bp += esize;
		++cnt;
#undef do_copy_str
	}
	return (cnt);
}

struct kinfo_proc *
kvm_getprocs(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
{
	int mib[6], st, nthreads;
	void *procbase;
	size_t size;

	if ((ssize_t)esize < 0)
		return (NULL);

	if (ISALIVE(kd)) {
		size = 0;
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC;
		mib[2] = op;
		mib[3] = arg;
		mib[4] = esize;

		do {
			mib[5] = 0;
			st = sysctl(mib, 6, NULL, &size, NULL, 0);
			if (st == -1) {
				_kvm_syserr(kd, kd->program, "kvm_getprocs");
				return (NULL);
			}

			size += size / 8; /* add ~10% */

			procbase = _kvm_realloc(kd, kd->procbase, size);
			if (procbase == NULL)
				return (NULL);

			kd->procbase = procbase;

			mib[5] = size / esize;
			st = sysctl(mib, 6, kd->procbase, &size, NULL, 0);
			if (st == -1 && errno != ENOMEM) {
				_kvm_syserr(kd, kd->program, "kvm_getprocs");
				return (NULL);
			}
		} while (st == -1);

		nthreads = size / esize;
	} else {
		struct nlist nl[5];
		int i, maxthread, maxprocess;
		struct process *pr;
		char *bp;

		if (esize > sizeof(struct kinfo_proc)) {
			_kvm_syserr(kd, kd->program,
			    "kvm_getprocs: unknown fields requested: libkvm out of date?");
			return (NULL);
		}

		memset(nl, 0, sizeof(nl));
		nl[0].n_name = "_nthreads";
		nl[1].n_name = "_nprocesses";
		nl[2].n_name = "_allprocess";
		nl[3].n_name = "_zombprocess";
		nl[4].n_name = NULL;

		if (kvm_nlist(kd, nl) != 0) {
			for (i = 0; nl[i].n_type != 0; ++i)
				;
			_kvm_err(kd, kd->program,
			    "%s: no such symbol", nl[i].n_name);
			return (NULL);
		}
		if (KREAD(kd, nl[0].n_value, &maxthread)) {
			_kvm_err(kd, kd->program, "can't read nthreads");
			return (NULL);
		}
		if (KREAD(kd, nl[1].n_value, &maxprocess)) {
			_kvm_err(kd, kd->program, "can't read nprocesses");
			return (NULL);
		}
		maxthread += maxprocess;

		kd->procbase = _kvm_reallocarray(kd, NULL, maxthread, esize);
		if (kd->procbase == 0)
			return (NULL);
		bp = (char *)kd->procbase;

		/* allprocess */
		if (KREAD(kd, nl[2].n_value, &pr)) {
			_kvm_err(kd, kd->program, "cannot read allprocess");
			return (NULL);
		}
		nthreads = kvm_proclist(kd, op, arg, pr, bp, maxthread, esize);
		if (nthreads < 0)
			return (NULL);

		/* zombprocess */
		if (KREAD(kd, nl[3].n_value, &pr)) {
			_kvm_err(kd, kd->program, "cannot read zombprocess");
			return (NULL);
		}
		i = kvm_proclist(kd, op, arg, pr, bp + (esize * nthreads),
		    maxthread - nthreads, esize);
		if (i > 0)
			nthreads += i;
	}
	if (kd->procbase != NULL)
		*cnt = nthreads;
	return (kd->procbase);
}
@


1.26
log
@port the changes just made to kvm_getfiles in kvm_file2.c r1.47 to
kvm_getprocs.

basically cope with the number of procs growing between when we get
the size and when we get the list.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.25 2014/10/15 02:03:05 deraadt Exp $	*/
d115 1
a115 1
	struct proc proc, proc2, *p;
d122 1
a122 1
	pid_t process_pid, parent_pid, leader_pid;
a141 6
		if (KREAD(kd, (u_long)process.ps_mainproc, &proc)) {
			_kvm_err(kd, kd->program, "can't read proc at %lx",
			    (u_long)process.ps_mainproc);
			return (-1);
		}
		process_pid = proc.p_pid;
d170 1
a170 7
			if (KREAD(kd, (u_long)process2.ps_mainproc, &proc2)) {
				_kvm_err(kd, kd->program,
				    "can't read proc at %lx",
				    (u_long)process2.ps_mainproc);
				return (-1);
			}
			parent_pid = proc2.p_pid;
d181 1
a181 7
			if (KREAD(kd, (u_long)process2.ps_mainproc, &proc2)) {
				_kvm_err(kd, kd->program,
				    "can't read proc at %lx",
				    (u_long)process2.ps_mainproc);
				return (-1);
			}
			leader_pid = proc2.p_pid;
d232 1
a232 1
			if (proc.p_flag & P_SYSTEM)
d269 1
a269 1
		    &ucred, &pgrp, process.ps_mainproc, proc.p_p, &sess,
a272 1
		kp.p_pid = process_pid;
d294 6
d350 1
a350 1
			    &ucred, &pgrp, p, proc.p_p, &sess, vmp, limp, sap,
a353 1
			kp.p_pid = process_pid;
@


1.25
log
@Apply reallocarray() idiom.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.24 2014/07/08 23:31:22 deraadt Exp $	*/
d98 1
d401 1
a406 9
	if (kd->procbase != NULL) {
		free(kd->procbase);
		/*
		 * Clear this pointer in case this call fails.  Otherwise,
		 * kvm_close() will free it again.
		 */
		kd->procbase = 0;
	}

a413 6
		mib[5] = 0;
		st = sysctl(mib, 6, NULL, &size, NULL, 0);
		if (st == -1) {
			_kvm_syserr(kd, kd->program, "kvm_getprocs");
			return (NULL);
		}
d415 24
a438 9
		mib[5] = size / esize;
		kd->procbase = _kvm_malloc(kd, size);
		if (kd->procbase == 0)
			return (NULL);
		st = sysctl(mib, 6, kd->procbase, &size, NULL, 0);
		if (st == -1) {
			_kvm_syserr(kd, kd->program, "kvm_getprocs");
			return (NULL);
		}
@


1.24
log
@sys/user.h can now be substantially gutted.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.23 2014/07/04 05:58:31 guenther Exp $	*/
d474 1
a474 1
		kd->procbase = _kvm_malloc(kd, maxthread * esize);
@


1.23
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.22 2014/05/25 20:28:28 guenther Exp $	*/
a73 1
#include <sys/user.h>
d77 1
d80 2
@


1.22
log
@Get the vmspace pointer from the process, not the thread
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.21 2014/03/30 21:54:49 guenther Exp $	*/
d137 2
a143 2
		if (proc.p_stat == SIDL)
			continue;
d278 1
a278 1
		if (proc.p_stat != SIDL && !P_ZOMBIE(&proc) &&
d309 7
a315 1
		if (!dothreads) {
a323 2
				if (p == process.ps_mainproc)
					continue;
d325 15
d341 1
a341 1
		}
@


1.21
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.20 2014/03/22 11:18:05 florian Exp $	*/
d279 1
a279 1
		    !KREAD(kd, (u_long)proc.p_vmspace, &vm))
@


1.20
log
@Unbreak tree; p_sigacts moved from struct proc to struct process
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.19 2014/02/05 03:49:00 guenther Exp $	*/
a110 1
	struct pcred pcred;
a143 5
		if (KREAD(kd, (u_long)process.ps_cred, &pcred)) {
			_kvm_err(kd, kd->program, "can't read pcred at %lx",
			    (u_long)process.ps_cred);
			return (-1);
		}
d145 1
a145 1
		if (KREAD(kd, (u_long)pcred.pc_ucred, &ucred)) {
d147 1
a147 1
			    (u_long)pcred.pc_ucred);
d242 1
a242 1
			if (pcred.p_ruid != (uid_t)arg)
d283 1
a283 1
		FILL_KPROC(&kp, do_copy_str, &proc, &process, &pcred,
d340 1
a340 1
			FILL_KPROC(&kp, do_copy_str, &proc, &process, &pcred,
@


1.19
log
@More crash dump parsing fixes: correct paddr in process info and pids
in file info.  Drop some unnecessary casts and unused variables too.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.18 2014/01/20 21:19:28 guenther Exp $	*/
d206 2
a207 2
		if (proc.p_sigacts) {
			if (KREAD(kd, (u_long)proc.p_sigacts, &sa)) {
d210 1
a210 1
				    (u_long)proc.p_sigacts);
@


1.18
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.17 2013/11/12 14:49:41 guenther Exp $	*/
d290 2
a291 2
		    &ucred, &pgrp, p, proc.p_p, &sess, vmp, limp, sap,
		    0, 1);
@


1.17
log
@Apply format __attribute__ to _kvm_err() and fix the errors that it detects.
Treat failure to KREAD teh pcredd or ucreds to be errors insteading of
continuing with bogus data.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.16 2013/03/20 14:46:45 deraadt Exp $	*/
d106 1
a106 1
kvm_proclist(kvm_t *kd, int op, int arg, struct proc *p,
d113 1
a113 1
	struct proc proc, proc2;
d127 7
a133 4
	for (; cnt < maxcnt && p != NULL; p = LIST_NEXT(&proc, p_list)) {
		if (KREAD(kd, (u_long)p, &proc)) {
			_kvm_err(kd, kd->program, "can't read proc at %lx",
			    (u_long)p);
d136 5
a140 3
		if (KREAD(kd, (u_long)proc.p_p, &process)) {
			_kvm_err(kd, kd->program, "can't read process at %lx",
			    (u_long)proc.p_p);
d143 2
d150 1
a150 11
		if ((proc.p_flag & P_THREAD) == 0)
			process_pid = proc.p_pid;
		else {
			if (KREAD(kd, (u_long)process.ps_mainproc, &proc2)) {
				_kvm_err(kd, kd->program,
				    "can't read proc at %lx",
				    (u_long)process.ps_mainproc);
				return (-1);
			}
			process_pid = proc2.p_pid;
		}
a276 6
		vmp = &vm;
		if (proc.p_stat == SIDL ||
		    P_ZOMBIE(&proc) ||
		    KREAD(kd, (u_long)proc.p_vmspace, &vm))
			vmp = NULL;

d282 6
d289 57
a345 1
		if ((proc.p_flag & P_THREAD) == 0) {
d348 1
a348 1
			    0, 1);
d350 1
a350 1
			/* stuff that's too painful to generalize */
a370 31

			memcpy(bp, &kp, esize);
			bp += esize;
			++cnt;
		}

		if (!dothreads)
			continue;

		FILL_KPROC(&kp, do_copy_str, &proc, &process, &pcred, &ucred,
		    &pgrp, p, proc.p_p, &sess, vmp, limp, sap, 1, 1);

		/* stuff that's too painful to generalize into the macros */
		kp.p_pid = process_pid;
		kp.p_ppid = parent_pid;
		kp.p_sid = leader_pid;
		if ((process.ps_flags & PS_CONTROLT) && sess.s_ttyp != NULL) {
			kp.p_tdev = tty.t_dev;
			if (tty.t_pgrp != NULL &&
			    tty.t_pgrp != process.ps_pgrp &&
			    KREAD(kd, (u_long)tty.t_pgrp, &pgrp)) {
				_kvm_err(kd, kd->program,
				    "can't read tpgrp at %lx",
				    (u_long)tty.t_pgrp);
				return (-1);
			}
			kp.p_tpgid = tty.t_pgrp ? pgrp.pg_id : -1;
			kp.p_tsess = PTRTOINT64(tty.t_session);
		} else {
			kp.p_tpgid = -1;
			kp.p_tdev = NODEV;
d424 3
a426 3
		struct nlist nl[4];
		int i, maxthread;
		struct proc *p;
d437 4
a440 3
		nl[1].n_name = "_allproc";
		nl[2].n_name = "_zombproc";
		nl[3].n_name = NULL;
d453 5
d464 3
a466 3
		/* allproc */
		if (KREAD(kd, nl[1].n_value, &p)) {
			_kvm_err(kd, kd->program, "cannot read allproc");
d469 1
a469 1
		nthreads = kvm_proclist(kd, op, arg, p, bp, maxthread, esize);
d473 3
a475 3
		/* zombproc */
		if (KREAD(kd, nl[2].n_value, &p)) {
			_kvm_err(kd, kd->program, "cannot read zombproc");
d478 1
a478 1
		i = kvm_proclist(kd, op, arg, p, bp + (esize * nthreads),
@


1.16
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.15 2013/03/20 03:43:08 deraadt Exp $	*/
d129 2
a130 1
			_kvm_err(kd, kd->program, "can't read proc at %x", p);
d134 2
a135 2
			_kvm_err(kd, kd->program, "can't read process at %x",
			    proc.p_p);
d139 2
a140 2
			_kvm_err(kd, kd->program, "can't read pcred at %x",
			    process.ps_cred);
d148 2
a149 2
				    "can't read proc at %x",
				    process.ps_mainproc);
d155 2
a156 2
			_kvm_err(kd, kd->program, "can't read ucred at %x",
			    pcred.pc_ucred);
d160 2
a161 2
			_kvm_err(kd, kd->program, "can't read pgrp at %x",
			    process.ps_pgrp);
d165 2
a166 2
			_kvm_err(kd, kd->program, "can't read session at %x",
			    pgrp.pg_session);
d171 2
a172 2
			_kvm_err(kd, kd->program,
			    "can't read tty at %x", sess.s_ttyp);
d178 2
a179 2
				    "can't read process at %x",
				    process.ps_pptr);
d184 2
a185 2
				    "can't read proc at %x",
				    process2.ps_mainproc);
d195 2
a196 1
				    "can't read proc at %x", sess.s_leader);
d201 2
a202 2
				    "can't read proc at %x",
				    process2.ps_mainproc);
d211 3
a213 2
				_kvm_err(kd, kd->program, "can't read sigacts at %x",
				    proc.p_sigacts);
d308 2
a309 2
					    "can't read tpgrp at &x",
					    tty.t_pgrp);
d340 2
a341 1
				    "can't read tpgrp at &x", tty.t_pgrp);
@


1.15
log
@When non-root asks sysctl for kinfo proc or file requests, do not fill in
any kernel addresses information.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.14 2012/11/12 00:29:09 guenther Exp $	*/
d298 1
a298 1
			if ((process.ps_flags & PS_CONTROLT) && 
@


1.14
log
@Fix pid matching on kernel crashdumps in kvm_getprocs(KERN_PROC_PID)
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.13 2012/04/17 23:17:53 pirofti Exp $	*/
d292 1
a292 1
			    0);
d325 1
a325 1
		    &pgrp, p, proc.p_p, &sess, vmp, limp, sap, 1);
@


1.13
log
@Make it optional for kvm_getprocs() (and related sysctl) to return
thread information.

Add a KERN_PROC_SHOW_THREADS flag that has to be set in order to get the
thread info and make it off by default. This creates backwards compatibility
for applications that relied on a given size/number of items to be returned.

Modify ps(1) and top(1) accordingly.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.12 2012/04/14 12:15:21 guenther Exp $	*/
d220 1
a220 1
			if (proc.p_pid != (pid_t)arg)
@


1.12
log
@Update to match nprocs-->nprocess/nthreads changes
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.11 2012/04/12 14:59:19 pirofti Exp $	*/
d122 4
d320 4
@


1.11
log
@Add per thread accounting, mainly for usage & friends.

This expands the already bloated FILL_KPROC macro to take an extra
parameter that indicates if the callee is a thread or a process.

The userland bits are adjusted accordingly and ps(1) and top(1) now
display per thread usage times when -H is used.

Also pkill(1) had to be adjusted so that duplicates don't pop up.

libkvm does basically the same thing as the kernel bits.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.10 2012/03/23 15:51:25 guenther Exp $	*/
d265 1
a265 1
		 * nprocs (or the proc list) is corrupt and declare an error.
d268 1
a268 1
			_kvm_err(kd, kd->program, "nprocs corrupt");
d350 1
a350 1
	int mib[6], st, nprocs;
d388 1
a388 1
		nprocs = size / esize;
d391 1
a391 1
		int i, maxprocs;
d402 1
a402 1
		nl[0].n_name = "_nprocs";
d414 2
a415 2
		if (KREAD(kd, nl[0].n_value, &maxprocs)) {
			_kvm_err(kd, kd->program, "can't read nprocs");
d419 1
a419 1
		kd->procbase = _kvm_malloc(kd, maxprocs * esize);
d429 2
a430 2
		nprocs = kvm_proclist(kd, op, arg, p, bp, maxprocs, esize);
		if (nprocs < 0)
d438 2
a439 2
		i = kvm_proclist(kd, op, arg, p, bp + (esize * nprocs),
		    maxprocs - nprocs, esize);
d441 1
a441 1
			nprocs += i;
d443 2
a444 1
	*cnt = nprocs;
@


1.10
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.9 2012/01/07 05:38:12 guenther Exp $	*/
d285 31
d317 1
a317 2
		    &pgrp, p, proc.p_p, &sess, vmp, limp, sap);
#undef do_copy_str
d342 1
@


1.9
log
@Add rtable id and thread id to struct kinfo_proc (and fix process id)
and add an 'rtableid' keyword to ps.

Add rtable id, thread id, and socket splice info to struct kinfo_file2
and make fstat display socket splice information.

Remove old KVM_PROC2 and kinfo_proc2 interfaces; bump libkvm major

Socket splice info and corrections from bluhm@@  "Lovely" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.8 2011/07/05 04:48:01 guenther Exp $	*/
a119 1
	struct pstats pstats, *ps;
a283 5
		ps = &pstats;
		if (P_ZOMBIE(&proc) ||
		    KREAD(kd, (u_long)proc.p_stats, &pstats))
			ps = NULL;

d286 1
a286 1
		    &pgrp, p, proc.p_p, &sess, vmp, limp, ps, sap);
@


1.8
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.7 2011/04/18 21:44:55 guenther Exp $	*/
d121 1
a121 1
	pid_t parent_pid, leader_pid;
d139 11
d296 1
a420 7

struct kinfo_proc *
kvm_getproc2(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
{
	return (kvm_getprocs(kd, op, arg, esize, cnt));
}

@


1.7
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.4 2011/03/12 04:54:28 guenther Exp $	*/
d80 1
d117 1
d193 10
d281 1
a281 1
		    &pgrp, p, proc.p_p, &sess, vmp, limp, ps);
@


1.6
log
@p_sigacts is NULL for zombies, so FILL_KPROC() and  kvm_proclist() have
to handle that with the sigacts change.

problem observed and diagnosed by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.5 2011/04/15 04:52:40 guenther Exp $	*/
a79 1
#include <sys/signalvar.h>
a115 1
	struct sigacts sa, *sap;
a190 10
		if (proc.p_sigacts) {
			if (KREAD(kd, (u_long)proc.p_sigacts, &sa)) {
				_kvm_err(kd, kd->program, "can't read sigacts at %x",
				    proc.p_sigacts);
				return (-1);
			}
			sap = &sa;
		}
		else
			sap = NULL;
d269 1
a269 1
		    &pgrp, p, proc.p_p, &sess, vmp, limp, ps, sap);
@


1.5
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.4 2011/03/12 04:54:28 guenther Exp $	*/
d117 1
a117 1
	struct sigacts sa;
d193 7
a199 4
		if (KREAD(kd, (u_long)proc.p_sigacts, &sa)) {
			_kvm_err(kd, kd->program, "can't read sigacts at %x",
			    proc.p_sigacts);
			return (-1);
d201 2
d281 1
a281 1
		    &pgrp, p, proc.p_p, &sess, vmp, limp, ps, &sa);
@


1.4
log
@Replace the old, broken KERN_PROC ABI and its matching functions
in libkvm with the stable-ABI versions that are currently named
KERN_PROC2, kvm_get{proc,argv,envv}2().  The latter names and symbols
will continue to be supported for a few releases.

Committing now that they ports people have had a couple releases
to update pkgs that usd the old functions
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.3 2010/07/26 01:56:27 guenther Exp $	*/
d80 1
d117 1
d193 5
d276 1
a276 1
		    &pgrp, p, proc.p_p, &sess, vmp, limp, ps);
@


1.3
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.2 2010/06/29 16:39:23 guenther Exp $	*/
d108 1
a108 1
	struct kinfo_proc2 kp;
d268 1
a268 1
		FILL_KPROC2(&kp, do_copy_str, &proc, &process, &pcred, &ucred,
d298 2
a299 2
struct kinfo_proc2 *
kvm_getproc2(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
d307 2
a308 2
	if (kd->procbase2 != NULL) {
		free(kd->procbase2);
d313 1
a313 1
		kd->procbase2 = 0;
d319 1
a319 1
		mib[1] = KERN_PROC2;
d326 1
a326 1
			_kvm_syserr(kd, kd->program, "kvm_getproc2");
d331 2
a332 2
		kd->procbase2 = _kvm_malloc(kd, size);
		if (kd->procbase2 == 0)
d334 1
a334 1
		st = sysctl(mib, 6, kd->procbase2, &size, NULL, 0);
d336 1
a336 1
			_kvm_syserr(kd, kd->program, "kvm_getproc2");
d346 1
a346 1
		if (esize > sizeof(struct kinfo_proc2)) {
d348 1
a348 1
			    "kvm_getproc2: unknown fields requested: libkvm out of date?");
d370 2
a371 2
		kd->procbase2 = _kvm_malloc(kd, maxprocs * esize);
		if (kd->procbase2 == 0)
d373 1
a373 1
		bp = (char *)kd->procbase2;
d395 7
a401 1
	return (kd->procbase2);
@


1.2
log
@Fail instead of lying if a process asks sysctl()'s KERN_PROC2 or
KERN_FILE2 (or their libkvm wrappers) for more information than the
running implementation knows how to provide.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc2.c,v 1.1 2010/01/10 03:37:50 guenther Exp $	*/
d113 1
a113 1
	struct process process;
d142 1
a142 1
		if (KREAD(kd, (u_long)proc.p_pgrp, &pgrp)) {
d144 1
a144 1
			    proc.p_pgrp);
d152 1
a152 1
		if ((proc.p_flag & P_CONTROLT) && sess.s_ttyp != NULL &&
d158 2
a159 2
		if (proc.p_pptr) {
			if (KREAD(kd, (u_long)proc.p_pptr, &proc2)) {
d161 8
a168 1
				    "can't read proc at %x", proc.p_pptr);
d176 1
a176 1
			if (KREAD(kd, (u_long)sess.s_leader, &proc2)) {
d181 6
d205 1
a205 1
			    leader_pid == (pid_t)arg)
d210 1
a210 1
			if ((proc.p_flag & P_CONTROLT) == 0 ||
d269 1
a269 1
		    &pgrp, p, &sess, vmp, limp, ps);
d275 1
a275 1
		if ((proc.p_flag & P_CONTROLT) && sess.s_ttyp != NULL) {
d278 1
a278 1
			    tty.t_pgrp != proc.p_pgrp &&
@


1.1
log
@Reimplement kvm_getproc2()'s support for reading crash dumps and
/dev/mem to be direct instead of going through kvm_getprocs(), as
that function is going to get more an more broken as we move stuff
from struct proc to struct process for rthreads.  To minimize the
code copying, put the common logic of filling in a kinfo_proc2
structure into a macro FILL_KPROC2() in <sys/sysctl.h> for use from
both the kernel and user-space.  This also hides the KERN_PROC
#define behind "#if defined(_KERNEL)||defined(_LIBKVM)", as it's
deprecated.

Positive feedback from millert and blambert; so committing to unblock
further rthreads work.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.39 2009/10/27 23:59:28 deraadt Exp $	*/
d332 6
@

