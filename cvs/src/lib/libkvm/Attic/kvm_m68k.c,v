head	1.24;
access;
symbols
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.20.0.4
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.12
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.10
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.5.0.18
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.16
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.14
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2014.03.18.22.36.30;	author miod;	state dead;
branches;
next	1.23;

1.23
date	2013.11.01.15.57.56;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.17.08.02.21;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.28.16.27.31;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2012.07.09.08.43.10;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.20.20.20.43;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.12.18.00.08;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.20.15.11.48;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.15.19.31.31;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.03.19.57.37;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.15.03.52.59;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.05.02.23.11;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.19.17.36;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.05.23.04.35;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.21.19.30.47;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.19.05.03.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.18.09.08.37;	author art;	state Exp;
branches;
next	1.5;

1.5
date	97.02.26.16.46.31;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.58.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.05.14.57.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.19.23.15.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.44;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@/*	$OpenBSD: kvm_m68k.c,v 1.23 2013/11/01 15:57:56 deraadt Exp $ */
/*	$NetBSD: kvm_m68k.c,v 1.9 1996/05/07 06:09:11 leo Exp $	*/

/*-
 * Copyright (c) 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software developed by the Computer Systems
 * Engineering group at Lawrence Berkeley Laboratory under DARPA contract
 * BG 91-66 and contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * m68k machine dependent routines for kvm.  Hopefully, the forthcoming
 * vm code will one day obsolete this module.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/stat.h>

#include <sys/core.h>
#include <sys/exec.h>
#include <sys/kcore.h>

#include <unistd.h>
#include <stdlib.h>
#include <limits.h>
#include <nlist.h>
#include <kvm.h>

#include <uvm/uvm_extern.h>
#include <machine/vmparam.h>
#include <machine/pmap.h>

#include <db.h>

#include "kvm_private.h"

#include <machine/cpu.h>
#include <machine/pte.h>
#include <machine/kcore.h>

#ifndef btop
#define	btop(x)		(((unsigned)(x)) / kd->nbpg)	/* XXX */
#define	ptob(x)		((caddr_t)((x) * kd->nbpg))	/* XXX */
#endif

void
_kvm_freevtop(kvm_t *kd)
{
	if (kd->vmst != NULL) {
		free(kd->vmst);
		kd->vmst = NULL;
	}
}

int
_kvm_initvtop(kvm_t *kd)
{
	return (0);
}

static int
_kvm_vatop(kvm_t *kd, st_entry_t *sta, u_long va, u_long *pa)
{
	cpu_kcore_hdr_t *cpu_kh;
	int p, ste, pte, offset;
	u_long addr;

	if (ISALIVE(kd)) {
		_kvm_err(kd, 0, "vatop called in live kernel!");
		return (0);
	}
	offset = va & (kd->nbpg - 1);
	cpu_kh = kd->cpu_data;
	/*
	 * If we are initializing (kernel segment table pointer not yet set)
	 * then return pa == va to avoid infinite recursion.
	 */
	if (cpu_kh->sysseg_pa == 0) {
		*pa = va + cpu_kh->kernel_pa;
		return (kd->nbpg - offset);
	}
	if (cpu_kh->mmutype == MMU_68040 || cpu_kh->mmutype == MMU_68060) {
		st_entry_t *sta2;

		addr = (u_long)&sta[va >> SG4_SHIFT1];
		/*
		 * Can't use KREAD to read kernel segment table entries.
		 * Fortunately it is 1-to-1 mapped so we don't have to.
		 */
		if (sta == cpu_kh->sysseg_pa) {
			if (_kvm_pread(kd, kd->pmfd, (char *)&ste, sizeof(ste),
			    (off_t)_kvm_pa2off(kd, addr)) < 0)
				goto invalid;
		} else if (KREAD(kd, addr, &ste))
			goto invalid;
		if ((ste & SG_V) == 0) {
			_kvm_err(kd, 0, "invalid level 1 descriptor (%x)",
			    ste);
			return (0);
		}
		sta2 = (st_entry_t *)(ste & SG4_ADDR1);
		addr = (u_long)&sta2[(va & SG4_MASK2) >> SG4_SHIFT2];
		/*
		 * Address from level 1 STE is a physical address,
		 * so don't use kvm_read.
		 */
		if (_kvm_pread(kd, kd->pmfd, (char *)&ste, sizeof(ste),
		    (off_t)_kvm_pa2off(kd, addr)) < 0)
			goto invalid;
		if ((ste & SG_V) == 0) {
			_kvm_err(kd, 0, "invalid level 2 descriptor (%x)",
			    ste);
			return (0);
		}
		sta2 = (st_entry_t *)(ste & SG4_ADDR2);
		addr = (u_long)&sta2[(va & SG4_MASK3) >> SG4_SHIFT3];
	} else {
		addr = (u_long)&sta[va >> SEGSHIFT020];
		/*
		 * Can't use KREAD to read kernel segment table entries.
		 * Fortunately it is 1-to-1 mapped so we don't have to.
		 */
		if (sta == cpu_kh->sysseg_pa) {
			if (_kvm_pread(kd, kd->pmfd, (char *)&ste,
			    sizeof(ste), (off_t)_kvm_pa2off(kd, addr)) < 0)
				goto invalid;
		} else if (KREAD(kd, addr, &ste))
			goto invalid;
		if ((ste & SG_V) == 0) {
			_kvm_err(kd, 0, "invalid segment (%x)", ste);
			return (0);
		}
		p = btop(va & SG_PMASK);
		addr = (ste & SG_FRAME) + (p * sizeof(pt_entry_t));
	}
	/*
	 * Address from STE is a physical address so don't use kvm_read.
	 */
	if (_kvm_pread(kd, kd->pmfd, (char *)&pte, sizeof(pte),
	    (off_t)_kvm_pa2off(kd, addr)) < 0)
		goto invalid;
	addr = pte & PG_FRAME;
	if (pte == PG_NV) {
		_kvm_err(kd, 0, "page not valid");
		return (0);
	}
	*pa = addr + offset;

	return (kd->nbpg - offset);
invalid:
	_kvm_err(kd, 0, "invalid address (%lx)", va);
	return (0);
}

int
_kvm_kvatop(kvm_t *kd, u_long va, paddr_t *pa)
{
	cpu_kcore_hdr_t *cpu_kh;

	cpu_kh = kd->cpu_data;
	return (_kvm_vatop(kd, cpu_kh->sysseg_pa, va, pa));
}

/*
 * Translate a physical address to a file-offset in the crash-dump.
 */
off_t
_kvm_pa2off(kvm_t *kd, paddr_t pa)
{
	cpu_kcore_hdr_t *cpu_kh;
	phys_ram_seg_t	*rsp;
	off_t off;

	cpu_kh = kd->cpu_data;
	off = 0;
	for (rsp = cpu_kh->ram_segs; rsp->size; rsp++) {
		if (pa >= rsp->start && pa < rsp->start + rsp->size) {
			pa -= rsp->start;
			break;
		}
		off += rsp->size;
	}
	return (kd->dump_off + off + pa);
}
@


1.23
log
@reduce use of <sys/user.h>
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.22 2013/10/17 08:02:21 deraadt Exp $ */
@


1.22
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.21 2013/03/28 16:27:31 deraadt Exp $ */
a42 1
#include <sys/user.h>
@


1.21
log
@Avoid using PAGE_SHIFT, PAGE_SIZE, and PAGE_MASK defines, since we already
know it from the machine.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.20 2012/07/09 08:43:10 deraadt Exp $ */
d48 1
a48 1
#include <sys/exec_aout.h>
@


1.20
log
@Use the PAGE_* forms (instead of the ancient BSD forms) in param.h,
because param.h will get a kick in the head sometime in the future.
One day, maybe both can become invisible, but we boot one of them
first.
ok guenter
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.19 2009/10/27 23:59:28 deraadt Exp $ */
d70 2
a71 2
#define	btop(x)		(((unsigned)(x)) >> PAGE_SHIFT)	/* XXX */
#define	ptob(x)		((caddr_t)((x) << PAGE_SHIFT))	/* XXX */
d100 1
a100 1
	offset = va & PAGE_MASK;
d108 1
a108 1
		return (PAGE_SIZE - offset);
d177 1
a177 1
	return (PAGE_SIZE - offset);
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.18 2009/06/20 20:20:43 millert Exp $ */
d70 2
a71 2
#define	btop(x)		(((unsigned)(x)) >> PGSHIFT)	/* XXX */
#define	ptob(x)		((caddr_t)((x) << PGSHIFT))	/* XXX */
d100 1
a100 1
	offset = va & PGOFSET;
d108 1
a108 1
		return (NBPG - offset);
d177 1
a177 1
	return (NBPG - offset);
@


1.18
log
@Move KREAD define to kvm_private.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.17 2006/06/12 18:00:08 miod Exp $ */
a35 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)kvm_hp300.c	8.1 (Berkeley) 6/4/93";
#else
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.17 2006/06/12 18:00:08 miod Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.17
log
@Use the non-generic SEGSHIFT value in the 020/030 specific codepath.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.16 2006/03/20 15:11:48 mickey Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.16 2006/03/20 15:11:48 mickey Exp $";
a80 3

#define KREAD(kd, addr, p)\
	(kvm_read(kd, addr, (char *)(p), sizeof(*(p))) != sizeof(*(p)))
@


1.16
log
@for some of internal functions use paddr_t where phys addr is intended insteadd of u_long; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.15 2004/09/15 19:31:31 miod Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.15 2004/09/15 19:31:31 miod Exp $";
d157 1
a157 1
		addr = (u_long)&sta[va >> SEGSHIFT];
@


1.15
log
@Kill (almost all) warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.14 2004/07/03 19:57:37 miod Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.14 2004/07/03 19:57:37 miod Exp $";
d195 1
a195 1
_kvm_kvatop(kvm_t *kd, u_long va, u_long *pa)
d207 1
a207 1
_kvm_pa2off(kvm_t *kd, u_long pa)
@


1.14
log
@This was supposed to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.13 2004/06/15 03:52:59 deraadt Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.13 2004/06/15 03:52:59 deraadt Exp $";
d60 1
d200 1
a200 1
	return (_kvm_vatop(kd, (u_long)cpu_kh->sysseg_pa, va, pa));
@


1.13
log
@knf; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.12 2003/06/02 20:18:40 millert Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.12 2003/06/02 20:18:40 millert Exp $";
d91 1
d192 1
a192 1
n
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.11 2001/12/05 02:23:11 art Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.11 2001/12/05 02:23:11 art Exp $";
d46 1
a46 1
 * m68k machine dependent routines for kvm.  Hopefully, the forthcoming 
d85 1
a85 2
_kvm_freevtop(kd)
	kvm_t *kd;
d87 1
a87 1
	if (kd->vmst != 0)
d89 2
a90 1
}
d93 1
a93 2
_kvm_initvtop(kd)
	kvm_t *kd;
d99 1
a99 5
_kvm_vatop(kd, sta, va, pa)
	kvm_t *kd;
	st_entry_t *sta;
	u_long va;
	u_long *pa;
d101 3
a103 4
	register cpu_kcore_hdr_t *cpu_kh;
	register u_long addr;
	int p, ste, pte;
	int offset;
d107 1
a107 1
		return((off_t)0);
d125 1
a125 1
		 * Fortunately it is 1-to-1 mapped so we don't have to. 
d128 2
a129 1
			if (_kvm_pread(kd, kd->pmfd, (char *)&ste, sizeof(ste), (off_t)_kvm_pa2off(kd, addr)) < 0)
d135 2
a136 2
				 ste);
			return((off_t)0);
d144 2
a145 1
		if (_kvm_pread(kd, kd->pmfd, (char *)&ste, sizeof(ste), (off_t)_kvm_pa2off(kd, addr)) < 0)
d149 2
a150 2
				 ste);
			return((off_t)0);
d158 1
a158 1
		 * Fortunately it is 1-to-1 mapped so we don't have to. 
d161 2
a162 1
			if (_kvm_pread(kd, kd->pmfd, (char *)&ste, sizeof(ste), (off_t)_kvm_pa2off(kd, addr)) < 0)
d168 1
a168 1
			return((off_t)0);
d176 2
a177 1
	if (_kvm_pread(kd, kd->pmfd, (char *)&pte, sizeof(pte), (off_t)_kvm_pa2off(kd, addr)) < 0)
d185 1
a185 1
	
d191 1
a191 1

d193 1
a193 4
_kvm_kvatop(kd, va, pa)
	kvm_t *kd;
	u_long va;
	u_long *pa;
d195 1
a195 1
	register cpu_kcore_hdr_t *cpu_kh;
d205 1
a205 3
_kvm_pa2off(kd, pa)
	kvm_t	*kd;
	u_long	pa;
d207 1
a207 1
	off_t		off;
d209 1
a209 1
	register cpu_kcore_hdr_t *cpu_kh;
d220 1
a220 1
	return(kd->dump_off + off + pa);
@


1.11
log
@Include more machdep headers. (paranoia)
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.10 2001/11/06 19:17:36 art Exp $ */
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.10 2001/11/06 19:17:36 art Exp $";
@


1.10
log
@Adapt to new uvm/ includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.9 2001/11/05 23:04:35 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.9 2001/11/05 23:04:35 art Exp $";
d69 2
@


1.9
log
@No need to pull in vm/vm_param.h in any of these files.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.8 2001/06/21 19:30:47 miod Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.8 2001/06/21 19:30:47 miod Exp $";
d68 1
a68 1
#include <vm/vm.h>
@


1.8
log
@Use symbolic names for MMU flavours, and correctly handle 68060
in _kvm_kvatop().
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.7 2001/05/19 05:03:59 millert Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.7 2001/05/19 05:03:59 millert Exp $";
a68 1
#include <vm/vm_param.h>
@


1.7
log
@Make this actually compile
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.6 2001/05/18 09:08:37 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.6 2001/05/18 09:08:37 art Exp $";
d75 1
d128 1
a128 1
	if (cpu_kh->mmutype == -2) {
@


1.6
log
@Convert lseek/{read,write} pairs into pread and pwrite.
from my todo list, work by Jonathon Fletcher <jonathon.fletcher@@pobox.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.5 1997/02/26 16:46:31 niklas Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.5 1997/02/26 16:46:31 niklas Exp $";
d136 1
a136 1
			if (_kvm_pread(kd, (kd->pmfd, (char *)&ste, sizeof(ste), (off_t)_kvm_pa2off(kd, addr)) < 0)
@


1.5
log
@Switch alpha from libkvm.old to libkvm with code from NetBSD.
%x -> %lx format fixes from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_m68k.c,v 1.4 1996/05/10 12:58:31 deraadt Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_m68k.c,v 1.4 1996/05/10 12:58:31 deraadt Exp $";
d136 1
a136 2
			if (lseek(kd->pmfd, _kvm_pa2off(kd, addr), 0) == -1 ||
			    read(kd->pmfd, (char *)&ste, sizeof(ste)) < 0)
d151 1
a151 2
		if (lseek(kd->pmfd, _kvm_pa2off(kd, addr), 0) == -1 || 
		    read(kd->pmfd, (char *)&ste, sizeof(ste)) < 0)
d167 1
a167 2
			if (lseek(kd->pmfd, _kvm_pa2off(kd, addr), 0) == -1 ||
			    read(kd->pmfd, (char *)&ste, sizeof(ste)) < 0)
d181 1
a181 2
	if (lseek(kd->pmfd, _kvm_pa2off(kd, addr), 0) == -1 || 
	    read(kd->pmfd, (char *)&pte, sizeof(pte)) < 0)
@


1.4
log
@sync with netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 1
a45 1
static char *rcsid = "$OpenBSD$";
d196 1
a196 1
	_kvm_err(kd, 0, "invalid address (%x)", va);
@


1.3
log
@sync with 0430
@
text
@d2 1
a2 1
/*	$NetBSD: kvm_m68k.c,v 1.7 1996/03/18 22:33:41 thorpej Exp $	*/
d118 1
a118 1
	cpu_kh = kd->cpu_hdr;
d206 28
a233 1
	return (_kvm_vatop(kd, (u_long)kd->cpu_hdr->sysseg_pa, va, pa));
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d42 3
a44 1
/* from: static char sccsid[] = "@@(#)kvm_hp300.c	8.1 (Berkeley) 6/4/93"; */
d46 1
@


1.1
log
@Initial revision
@
text
@d1 2
d42 1
a42 1
static char *rcsid = "$Id: kvm_m68k.c,v 1.5 1995/07/01 19:26:03 briggs Exp $";
d54 5
d60 1
a66 1
#include <limits.h>
d72 1
a78 6
struct vmstate {
	u_long lowram;
	int mmutype;
	st_entry_t *Sysseg;
};

a93 30
	struct vmstate *vm;
	struct nlist nlist[4];

	vm = (struct vmstate *)_kvm_malloc(kd, sizeof(*vm));
	if (vm == 0)
		return (-1);
	kd->vmst = vm;

	nlist[0].n_name = "_lowram";
	nlist[1].n_name = "_mmutype";
	nlist[2].n_name = "_Sysseg";
	nlist[3].n_name = 0;

	if (kvm_nlist(kd, nlist) != 0) {
		_kvm_err(kd, kd->program, "bad namelist");
		return (-1);
	}
	vm->Sysseg = 0;
	if (KREAD(kd, (u_long)nlist[0].n_value, &vm->lowram)) {
		_kvm_err(kd, kd->program, "cannot read lowram");
		return (-1);
	}
	if (KREAD(kd, (u_long)nlist[1].n_value, &vm->mmutype)) {
		_kvm_err(kd, kd->program, "cannot read mmutype");
		return (-1);
	}
	if (KREAD(kd, (u_long)nlist[2].n_value, &vm->Sysseg)) {
		_kvm_err(kd, kd->program, "cannot read segment table");
		return (-1);
	}
d104 1
a104 2
	register struct vmstate *vm;
	register u_long lowram;
a112 1
	vm = kd->vmst;
d114 1
d119 2
a120 2
	if (vm->Sysseg == 0) {
		*pa = va;
d123 1
a123 2
	lowram = vm->lowram;
	if (vm->mmutype == -2) {
d131 2
a132 2
		if (sta == vm->Sysseg) {
			if (lseek(kd->pmfd, (off_t)addr, 0) == -1 ||
d148 1
a148 1
		if (lseek(kd->pmfd, (off_t)(addr - lowram), 0) == -1 || 
d164 2
a165 2
		if (sta == vm->Sysseg) {
			if (lseek(kd->pmfd, (off_t)addr, 0) == -1 ||
d180 1
a180 1
	if (lseek(kd->pmfd, (off_t)(addr - lowram), 0) == -1 || 
d188 1
a188 1
	*pa = addr - lowram + offset;
d202 1
a202 1
	return (_kvm_vatop(kd, (u_long)kd->vmst->Sysseg, va, pa));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
