head	1.16;
access;
symbols
	OPENBSD_6_0:1.15.0.6
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.16
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.16
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.12
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.09.01.10.08.03;	author tedu;	state dead;
branches;
next	1.15;
commitid	8LqCEzqjppzk7u86;

1.15
date	2015.03.30.04.38.56;	author miod;	state Exp;
branches;
next	1.14;
commitid	kFcXPSFlBriSbIgH;

1.14
date	2015.03.18.20.56.38;	author miod;	state Exp;
branches;
next	1.13;
commitid	1t8JWNihm6Vc4kyS;

1.13
date	2013.11.01.15.57.56;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.20.15.11.48;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.15.03.52.59;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.20.18.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.05.02.23.11;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.17.36;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.05.23.04.35;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.18.09.08.38;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.06.11.10.32.16;	author grr;	state Exp;
branches;
next	1.3;

1.3
date	97.02.26.16.46.34;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.05.05.14.57.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.44;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@remove references to sparc
@
text
@/*	$OpenBSD: kvm_sparc.c,v 1.15 2015/03/30 04:38:56 miod Exp $ */
/*	$NetBSD: kvm_sparc.c,v 1.9 1996/04/01 19:23:03 cgd Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software developed by the Computer Systems
 * Engineering group at Lawrence Berkeley Laboratory under DARPA contract
 * BG 91-66 and contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Sparc machine dependent routines for kvm.  Hopefully, the forthcoming
 * vm code will one day obsolete this module.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/stat.h>
#include <sys/core.h>
#include <sys/kcore.h>
#include <unistd.h>
#include <nlist.h>
#include <kvm.h>

#include <uvm/uvm_extern.h>
#include <machine/vmparam.h>
#include <machine/pmap.h>
#include <machine/kcore.h>

#include <limits.h>
#include <db.h>

#include "kvm_private.h"


static int cputyp = -1;
static int pgshift;
static int nptesg;	/* [sun4/sun4c] only */

#define VA_VPG(va)	((cputyp == CPU_SUN4C || cputyp == CPU_SUN4M) \
				? VA_SUN4C_VPG(va) \
				: VA_SUN4_VPG(va))

#define VA_OFF(va) (va & (kd->nbpg - 1))

int	_kvm_kvatop44c(kvm_t *, u_long, u_long *);
int	_kvm_kvatop4m(kvm_t *, u_long, u_long *);

void
_kvm_freevtop(kvm_t *kd)
{
	if (kd->vmst != NULL) {
		_kvm_err(kd, kd->program, "_kvm_freevtop: internal error");
		kd->vmst = NULL;
	}
}

/*
 * Prepare for translation of kernel virtual addresses into offsets
 * into crash dump files. We use the MMU specific goop written at the
 * front of the crash dump by pmap_dumpmmu().
 */
int
_kvm_initvtop(kvm_t *kd)
{
	cpu_kcore_hdr_t *cpup = kd->cpu_data;

	switch (cputyp = cpup->cputype) {
	case CPU_SUN4:
		kd->nbpg = 8196;
		pgshift = 13;
		break;
	case CPU_SUN4C:
	case CPU_SUN4M:
		kd->nbpg = 4096;
		pgshift = 12;
		break;
	default:
		_kvm_err(kd, kd->program, "Unsupported CPU type");
		return (-1);
	}
	nptesg = NBPSG / kd->nbpg;
	return (0);
}

/*
 * Translate a kernel virtual address to a physical address using the
 * mapping information in kd->vm.  Returns the result in pa, and returns
 * the number of bytes that are contiguously available from this
 * physical address.  This routine is used only for crashdumps.
 */
int
_kvm_kvatop(kvm_t *kd, u_long va, paddr_t *pa)
{
	if (cputyp == -1)
		if (_kvm_initvtop(kd) != 0)
			return (-1);

	return ((cputyp == CPU_SUN4M) ? _kvm_kvatop4m(kd, va, pa) :
	    _kvm_kvatop44c(kd, va, pa));
}

/*
 * (note: sun4 3-level MMU not yet supported)
 */
int
_kvm_kvatop44c(kvm_t *kd, u_long va, u_long *pa)
{
	cpu_kcore_hdr_t *cpup = kd->cpu_data;
	int vr, vs, pte, *ptes;
	struct segmap *sp;

	if (va < VM_MIN_KERNEL_ADDRESS_OLD)
		goto err;

	/*
	 * Layout of CPU segment:
	 *	cpu_kcore_hdr_t;
	 *	[alignment]
	 *	phys_ram_seg_t[cpup->nmemseg];
	 *	ptes[cpup->npmegs];
	 */
	ptes = (int *)((int)kd->cpu_data + cpup->pmegoffset);

	vr = VA_VREG(va);
	vs = VA_VSEG(va);

	sp = &cpup->segmap_store[(vr-NUREG_4C)*NSEGRG + vs];
	if (sp->sg_npte == 0)
		goto err;
	if (sp->sg_pmeg == cpup->npmeg - 1) /* =seginval */
		goto err;
	pte = ptes[sp->sg_pmeg * nptesg + VA_VPG(va)];
	if ((pte & PG_V) != 0) {
		long p, off = VA_OFF(va);

		p = (pte & PG_PFNUM) << pgshift;
		*pa = p + off;
		return (kd->nbpg - off);
	}
err:
	_kvm_err(kd, 0, "invalid address (%lx)", va);
	return (0);
}

int
_kvm_kvatop4m(kvm_t *kd, u_long va, u_long *pa)
{
	cpu_kcore_hdr_t *cpup = kd->cpu_data;
	struct segmap *sp;
	int vr, vs, pte;
	off_t foff;

	if (va < VM_MIN_KERNEL_ADDRESS_SRMMU)
		goto err;

	/*
	 * Layout of CPU segment:
	 *	cpu_kcore_hdr_t;
	 *	[alignment]
	 *	phys_ram_seg_t[cpup->nmemseg];
	 */
	vr = VA_VREG(va);
	vs = VA_VSEG(va);

	sp = &cpup->segmap_store[(vr-NUREG_4M)*NSEGRG + vs];
	if (sp->sg_npte == 0)
		goto err;

	/* XXX - assume page tables in initial kernel DATA or BSS. */
	foff = _kvm_pa2off(kd, (u_long)&sp->sg_pte[VA_VPG(va)] - KERNBASE);
	if (foff == (off_t)-1)
		return (0);

	if (_kvm_pread(kd, kd->pmfd, (void *)&pte, sizeof(pte), foff) < 0) {
		_kvm_err(kd, kd->program, "cannot read pte for %lx", va);
		return (0);
	}

	if ((pte & SRMMU_TETYPE) == SRMMU_TEPTE) {
		long p, off = VA_OFF(va);

		p = (pte & SRMMU_PPNMASK) << SRMMU_PPNPASHIFT;
		*pa = p + off;
		return (kd->nbpg - off);
	}
err:
	_kvm_err(kd, 0, "invalid address (%lx)", va);
	return (0);
}

/*
 * Translate a physical address to a file-offset in the crash-dump.
 */
off_t
_kvm_pa2off(kvm_t *kd, paddr_t pa)
{
	cpu_kcore_hdr_t *cpup = kd->cpu_data;
	phys_ram_seg_t *mp;
	off_t off;
	int nmem;

	/*
	 * Layout of CPU segment:
	 *	cpu_kcore_hdr_t;
	 *	[alignment]
	 *	phys_ram_seg_t[cpup->nmemseg];
	 */
	mp = (phys_ram_seg_t *)((int)kd->cpu_data + cpup->memsegoffset);
	off = 0;

	/* Translate (sparse) pfnum to (packed) dump offset */
	for (nmem = cpup->nmemseg; --nmem >= 0; mp++) {
		if (mp->start <= pa && pa < mp->start + mp->size)
			break;
		off += mp->size;
	}
	if (nmem < 0) {
		_kvm_err(kd, 0, "invalid address (%lx)", pa);
		return (-1);
	}

	return (kd->dump_off + off + pa - mp->start);
}
@


1.15
log
@Do not include <machine/autoconf.h>, for it is a kernel-only header and libkvm
doesn't need anything from it.
While there, fix format strings and remove unused local variable declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.14 2015/03/18 20:56:38 miod Exp $ */
@


1.14
log
@Rework the virtual memory layout on SRMMU systems (sun4d/sun4m) to use a much
lower VM_MIN_KERNEL_ADDRESS, since these systems are not crippled by the
Sun-4 MMU hole and have the real 4GB of address space.

Kernels running on Sun-4 MMU are not affected and will still be restricted
to the existing 128MB of kernel space, with 1GB - 128MB of user space.

Kernels running on SRMMU will now provide the low 3GB of address space to
userland, and use the top 1GB for the kernel, except when compiled with
option SMALL_KERNEL, in which case they will keep Sun-4 style the layout
(this is temporary to allow for people to boot bsd.rd to upgrade even when
not running 2.10 boot blocks, and will be removed eventually)

A consequence of this is that the top of the userland stack is no longer at
0xf0000000. But since nothing in userland uses USRSTACK anymore, this should
not be an issue.

Tested on sun4c and various sun4m, with physical memory sizes ranging from 32
to 448MB.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.13 2013/11/01 15:57:56 deraadt Exp $ */
a53 1
#include <machine/autoconf.h>
d72 2
a136 1
	struct regmap *rp;
d168 1
a168 1
	_kvm_err(kd, 0, "invalid address (%x)", va);
a175 1
	struct regmap *rp;
d202 1
a202 1
		_kvm_err(kd, kd->program, "cannot read pte for %x", va);
d214 1
a214 1
	_kvm_err(kd, 0, "invalid address (%x)", va);
d245 1
a245 1
		_kvm_err(kd, 0, "invalid address (%x)", pa);
@


1.13
log
@reduce use of <sys/user.h>
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.12 2009/10/27 23:59:28 deraadt Exp $ */
d139 1
a139 1
	if (va < KERNBASE)
d154 1
a154 1
	sp = &cpup->segmap_store[(vr-NUREG)*NSEGRG + vs];
d181 1
a181 1
	if (va < KERNBASE)
d193 1
a193 1
	sp = &cpup->segmap_store[(vr-NUREG)*NSEGRG + vs];
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.11 2006/03/20 15:11:48 mickey Exp $ */
a42 1
#include <sys/user.h>
@


1.11
log
@for some of internal functions use paddr_t where phys addr is intended insteadd of u_long; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.10 2004/06/15 03:52:59 deraadt Exp $ */
a35 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)kvm_sparc.c	8.1 (Berkeley) 6/4/93";
#else
static char *rcsid = "$OpenBSD: kvm_sparc.c,v 1.10 2004/06/15 03:52:59 deraadt Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.10
log
@knf; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.9 2003/06/02 20:18:41 millert Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_sparc.c,v 1.9 2003/06/02 20:18:41 millert Exp $";
d127 1
a127 1
_kvm_kvatop(kvm_t *kd, u_long va, u_long *pa)
d232 1
a232 1
_kvm_pa2off(kvm_t *kd, u_long pa)
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.8 2001/12/05 02:23:11 art Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_sparc.c,v 1.8 2001/12/05 02:23:11 art Exp $";
d46 1
a46 1
 * Sparc machine dependent routines for kvm.  Hopefully, the forthcoming 
d84 1
a84 2
_kvm_freevtop(kd)
	kvm_t *kd;
d86 1
a86 1
	if (kd->vmst != 0) {
d88 1
a88 1
		kd->vmst = 0;
d98 1
a98 2
_kvm_initvtop(kd)
	kvm_t *kd;
d123 1
a123 1
 * the number of bytes that are contiguously available from this 
d127 1
a127 4
_kvm_kvatop(kd, va, pa)
	kvm_t *kd;
	u_long va;
	u_long *pa;
d131 1
a131 1
		return (-1);
d133 2
a134 3
	return ((cputyp == CPU_SUN4M)
		? _kvm_kvatop4m(kd, va, pa)
		: _kvm_kvatop44c(kd, va, pa));
d141 1
a141 4
_kvm_kvatop44c(kd, va, pa)
	kvm_t *kd;
	u_long va;
	u_long *pa;
a142 1
	register int vr, vs, pte;
d144 1
a146 1
	int *ptes;
d170 1
a170 1
		register long p, off = VA_OFF(va);
d182 1
a182 4
_kvm_kvatop4m(kd, va, pa)
	kvm_t *kd;
	u_long va;
	u_long *pa;
a184 3
	register int vr, vs;
	int pte;
	off_t foff;
d187 2
a198 1

d217 1
a217 1
		register long p, off = VA_OFF(va);
d228 1
a228 1
/*       
d230 1
a230 1
 */     
d232 1
a232 3
_kvm_pa2off(kd, pa)
	kvm_t   *kd;
	u_long  pa;
@


1.8
log
@Include more machdep headers. (paranoia)
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.7 2001/11/06 19:17:36 art Exp $ */
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_sparc.c,v 1.7 2001/11/06 19:17:36 art Exp $";
@


1.7
log
@Adapt to new uvm/ includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.6 2001/11/05 23:04:35 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_sparc.c,v 1.6 2001/11/05 23:04:35 art Exp $";
d65 2
@


1.6
log
@No need to pull in vm/vm_param.h in any of these files.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.5 2001/05/18 09:08:38 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_sparc.c,v 1.5 2001/05/18 09:08:38 art Exp $";
d64 1
a64 1
#include <vm/vm.h>
@


1.5
log
@Convert lseek/{read,write} pairs into pread and pwrite.
from my todo list, work by Jonathon Fletcher <jonathon.fletcher@@pobox.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.4 1997/06/11 10:32:16 grr Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_sparc.c,v 1.4 1997/06/11 10:32:16 grr Exp $";
a64 1
#include <vm/vm_param.h>
@


1.4
log
@import some cleanup for libkvm/kvm.c from netbsd, udpate libkvm so that sparc can use libkvm vs. libkvm.old and update sparc pmap.c and machdep.c to make dumps compatible with the new libkvm's notions.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_sparc.c,v 1.3 1997/02/26 16:46:34 niklas Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_sparc.c,v 1.3 1997/02/26 16:46:34 niklas Exp $";
d229 1
a229 2
	if (lseek(kd->pmfd, foff, 0) == -1 || 
	    read(kd->pmfd, (void *)&pte, sizeof(pte)) < 0) {
@


1.3
log
@Switch alpha from libkvm.old to libkvm with code from NetBSD.
%x -> %lx format fixes from me.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 1
a45 1
static char *rcsid = "$OpenBSD$";
d58 2
a59 2
#include <sys/sysctl.h>
#include <sys/device.h>
d67 1
a73 15
#define MA_SIZE 32 /* XXX */
struct vmstate {
	struct {
		int x_seginval;		/* [sun4/sun4c] only */
		int x_npmemarr;
		struct memarr x_pmemarr[MA_SIZE];
		struct segmap x_segmap_store[NKREG*NSEGRG];
	} x;
#define seginval x.x_seginval
#define npmemarr x.x_npmemarr
#define pmemarr x.x_pmemarr
#define segmap_store x.x_segmap_store
	int *pte;			/* [sun4/sun4c] only */
};
#define NPMEG(vm) ((vm)->seginval+1)
d76 2
a77 2

static int pgshift, nptesg;
d83 2
a84 1
static int	_kvm_mustinit __P((kvm_t *));
d86 3
a88 3
#if 0
static int
getcputyp()
d90 4
a93 8
	int mib[2];
	size_t size;

	mib[0] = CTL_HW;
	mib[1] = HW_CLASS;
	size = sizeof cputyp;
	if (sysctl(mib, 2, &cputyp, &size, NULL, 0) == -1)
		return (-1);
a94 1
#endif
d96 7
a102 2
static int
_kvm_mustinit(kd)
d105 1
a105 6
static	struct nlist nlist[2] = {
#		define X_CPUTYP	0
		{ "_cputyp" },
		{ NULL },
	};
	off_t foff;
d107 12
a118 9
	if (cputyp != -1)
		return 0;

	for (pgshift = 12; (1 << pgshift) != kd->nbpg; pgshift++)
		;
	nptesg = NBPSG / kd->nbpg;

	if (kvm_nlist(kd, nlist) != 0) {
		_kvm_err(kd, kd->program, "cannot find `cputyp' symbol");
d121 1
a121 12
	/* Assume kernel mappings are all within first memory bank. */
	foff = nlist[X_CPUTYP].n_value - KERNBASE;
	if (lseek(kd->pmfd, foff, 0) == -1 || 
	    read(kd->pmfd, &cputyp, sizeof(cputyp)) < 0) {
		_kvm_err(kd, kd->program, "cannot read `cputyp");
		return (-1);
	}
	if (cputyp != CPU_SUN4 &&
	    cputyp != CPU_SUN4C &&
	    cputyp != CPU_SUN4M)
		return (-1);

a124 12
void
_kvm_freevtop(kd)
	kvm_t *kd;
{
	if (kd->vmst != 0) {
		if (kd->vmst->pte != 0)
			free(kd->vmst->pte);
		free(kd->vmst);
		kd->vmst  = 0;
	}
}

d137 2
a138 1
	if (_kvm_mustinit(kd) != 0)
a146 23
 * Prepare for translation of kernel virtual addresses into offsets
 * into crash dump files. We use the MMU specific goop written at the
 * and of crash dump by pmap_dumpmmu().
 * (note: sun4/sun4c 2-level MMU specific)
 */
int
_kvm_initvtop(kd)
	kvm_t *kd;
{
	if (_kvm_mustinit(kd) != 0)
		return (-1);

	return ((cputyp == CPU_SUN4M)
		? _kvm_initvtop4m(kd)
		: _kvm_initvtop44c(kd));
}

#define VA_OFF(va) (va & (kd->nbpg - 1))


/*
 * We use the MMU specific goop written at the end of crash dump
 * by pmap_dumpmmu().
a149 52
_kvm_initvtop44c(kd)
	kvm_t *kd;
{
	register struct vmstate *vm;
	register int i;
	off_t foff;
	struct stat st;

	if ((vm = kd->vmst) == 0) {
		kd->vmst = vm = (struct vmstate *)_kvm_malloc(kd, sizeof(*vm));
		if (vm == 0)
			return (-1);
	}

	if (fstat(kd->pmfd, &st) < 0)
		return (-1);
	/*
	 * Read segment table.
	 */

	foff = st.st_size - roundup(sizeof(vm->x), kd->nbpg);
	errno = 0;
	if (lseek(kd->pmfd, (off_t)foff, 0) == -1 && errno != 0 || 
	    read(kd->pmfd, (char *)&vm->x, sizeof(vm->x)) < 0) {
		_kvm_err(kd, kd->program, "cannot read segment map");
		return (-1);
	}

	vm->pte = (int *)_kvm_malloc(kd, NPMEG(vm) * nptesg * sizeof(int));
	if (vm->pte == 0) {
		free(kd->vmst);
		kd->vmst = 0;
		return (-1);
	}

	/*
	 * Read PMEGs.
	 */
	foff = st.st_size - roundup(sizeof(vm->x), kd->nbpg) -
	      roundup(NPMEG(vm) * nptesg * sizeof(int), kd->nbpg);

	errno = 0;
	if (lseek(kd->pmfd, foff, 0) == -1 && errno != 0 || 
	    read(kd->pmfd, (char *)vm->pte, NPMEG(vm) * nptesg * sizeof(int)) < 0) {
		_kvm_err(kd, kd->program, "cannot read PMEG table");
		return (-1);
	}

	return (0);
}

int
d155 2
a156 2
	register int vr, vs, pte, off, nmem;
	register struct vmstate *vm = kd->vmst;
d159 1
a159 1
	struct memarr *mp;
d164 9
d176 1
a176 1
	sp = &vm->segmap_store[(vr-NUREG)*NSEGRG + vs];
d179 1
a179 1
	if (sp->sg_pmeg == vm->seginval)
d181 1
a181 1
	pte = vm->pte[sp->sg_pmeg * nptesg + VA_VPG(va)];
d183 1
a183 1
		register long p, dumpoff = 0;
a184 1
		off = VA_OFF(va);
d186 1
a186 9
		/* Translate (sparse) pfnum to (packed) dump offset */
		for (mp = vm->pmemarr, nmem = vm->npmemarr; --nmem >= 0; mp++) {
			if (mp->addr <= p && p < mp->addr + mp->len)
				break;
			dumpoff += mp->len;
		}
		if (nmem < 0)
			goto err;
		*pa = (dumpoff + p - mp->addr) | off;
d190 1
a190 61
	_kvm_err(kd, 0, "invalid address (%lx)", va);
	return (0);
}

/*
 * Prepare for translation of kernel virtual addresses into offsets
 * into crash dump files. Since the sun4m pagetables are all in memory,
 * we use nlist to bootstrap the translation tables. This assumes that
 * the kernel mappings all reside in the first physical memory bank.
 */
int
_kvm_initvtop4m(kd)
	kvm_t *kd;
{
	register int i;
	register off_t foff;
	register struct vmstate *vm;
	struct stat st;
static	struct nlist nlist[4] = {
#		define X_KSEGSTORE	0
		{ "_kernel_segmap_store" },
#		define X_PMEMARR	1
		{ "_pmemarr" },
#		define X_NPMEMARR	2
		{ "_npmemarr" },
		{ NULL },
	};

	if ((vm = kd->vmst) == 0) {
		kd->vmst = vm = (struct vmstate *)_kvm_malloc(kd, sizeof(*vm));
		if (vm == 0)
			return (-1);
	}

	if (kvm_nlist(kd, nlist) != 0) {
		_kvm_err(kd, kd->program, "cannot read symbols");
		return (-1);
	}

	/* Assume kernel mappings are all within first memory bank. */
	foff = nlist[X_KSEGSTORE].n_value - KERNBASE;
	if (lseek(kd->pmfd, foff, 0) == -1 || 
	    read(kd->pmfd, vm->segmap_store, sizeof(vm->segmap_store)) < 0) {
		_kvm_err(kd, kd->program, "cannot read segment map");
		return (-1);
	}

	foff = nlist[X_PMEMARR].n_value - KERNBASE;
	if (lseek(kd->pmfd, foff, 0) == -1 || 
	    read(kd->pmfd, vm->pmemarr, sizeof(vm->pmemarr)) < 0) {
		_kvm_err(kd, kd->program, "cannot read pmemarr");
		return (-1);
	}

	foff = nlist[X_NPMEMARR].n_value - KERNBASE;
	if (lseek(kd->pmfd, foff, 0) == -1 || 
	    read(kd->pmfd, &vm->npmemarr, sizeof(vm->npmemarr)) < 0) {
		_kvm_err(kd, kd->program, "cannot read npmemarr");
		return (-1);
	}

d200 2
a201 2
	register struct vmstate *vm = kd->vmst;
	register int vr, vs, nmem, off;
a205 1
	struct memarr *mp;
d210 7
d220 1
a220 1
	sp = &vm->segmap_store[(vr-NUREG)*NSEGRG + vs];
d224 5
a228 2
	/* Assume kernel mappings are all within first memory bank. */
	foff = (long)&sp->sg_pte[VA_VPG(va)] - KERNBASE;
d231 2
a232 2
		_kvm_err(kd, kd->program, "cannot read pte");
		goto err;
d236 1
a236 1
		register long p, dumpoff = 0;
a237 1
		off = VA_OFF(va);
d239 1
a239 9
		/* Translate (sparse) pfnum to (packed) dump offset */
		for (mp = vm->pmemarr, nmem = vm->npmemarr; --nmem >= 0; mp++) {
			if (mp->addr <= p && p < mp->addr + mp->len)
				break;
			dumpoff += mp->len;
		}
		if (nmem < 0)
			goto err;
		*pa = (dumpoff + p - mp->addr) | off;
d243 1
a243 1
	_kvm_err(kd, 0, "invalid address (%lx)", va);
d245 36
@


1.2
log
@sync with 0430
@
text
@d302 1
a302 1
	_kvm_err(kd, 0, "invalid address (%x)", va);
d415 1
a415 1
	_kvm_err(kd, 0, "invalid address (%x)", va);
@


1.1
log
@Initial revision
@
text
@d1 3
d42 1
d44 3
d76 1
a76 1
		int x_seginval;
d85 1
a85 1
	int *pte;
d93 20
a112 1
#define VA_VPG(va)	(cputyp==CPU_SUN4C ? VA_SUN4C_VPG(va) : VA_SUN4_VPG(va))
d114 1
a114 1
static void
d118 7
d126 2
a127 1
		return;
d132 10
a141 6
#if 1
	if (cputyp == -1) {
		if (kd->nbpg == 8192)
			cputyp = CPU_SUN4;
		else
			cputyp = CPU_SUN4C;
d143 6
a148 1
#endif
d164 20
d193 21
d215 1
a215 2
	register int off;
	register struct vmstate *vm;
a216 3
	struct nlist nlist[5];

	_kvm_mustinit(kd);
d230 1
a230 1
	off = st.st_size - roundup(sizeof(vm->x), kd->nbpg);
d232 1
a232 1
	if (lseek(kd->pmfd, (off_t)off, 0) == -1 && errno != 0 || 
d248 1
a248 1
	off = st.st_size - roundup(sizeof(vm->x), kd->nbpg) -
d252 1
a252 1
	if (lseek(kd->pmfd, (off_t)off, 0) == -1 && errno != 0 || 
a260 8
#define VA_OFF(va) (va & (kd->nbpg - 1))

/*
 * Translate a kernel virtual address to a physical address using the
 * mapping information in kd->vm.  Returns the result in pa, and returns
 * the number of bytes that are contiguously available from this 
 * physical address.  This routine is used only for crashdumps.
 */
d262 1
a262 1
_kvm_kvatop(kd, va, pa)
a272 2
	_kvm_mustinit(kd);

d306 9
a314 3
#if 0
static int
getcputyp()
d316 39
a354 2
	int mib[2];
	size_t size;
d356 4
a359 4
	mib[0] = CTL_HW;
	mib[1] = HW_CLASS;
	size = sizeof cputyp;
	if (sysctl(mib, 2, &cputyp, &size, NULL, 0) == -1)
d361 56
a417 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
