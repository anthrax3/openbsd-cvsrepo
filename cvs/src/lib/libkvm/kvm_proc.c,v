head	1.58;
access;
symbols
	OPENBSD_6_0:1.56.0.2
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.52.0.4
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.52.0.6
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.50.0.4
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.48.0.4
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.2
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.47.0.2
	OPENBSD_5_2_BASE:1.47
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.2
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.41.0.4
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.6
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.58
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.57;
commitid	W7ztnDZwvjCaeQTS;

1.57
date	2016.09.16.04.03.27;	author dlg;	state Exp;
branches;
next	1.56;
commitid	xDq2mu8rzsOQxxSv;

1.56
date	2016.05.26.13.37.26;	author stefan;	state Exp;
branches;
next	1.55;
commitid	eiMXKHK3UupAUyDE;

1.55
date	2016.05.22.22.52.01;	author guenther;	state Exp;
branches;
next	1.54;
commitid	KhyebnIkY686CCxA;

1.54
date	2016.05.22.16.18.26;	author stefan;	state Exp;
branches;
next	1.53;
commitid	biGCNWraZJf92vP1;

1.53
date	2016.05.11.17.46.44;	author tedu;	state Exp;
branches;
next	1.52;
commitid	FUrBardrA5KQav0a;

1.52
date	2014.10.22.04.13.35;	author guenther;	state Exp;
branches;
next	1.51;
commitid	9gHvHZzFxRbYqGfH;

1.51
date	2014.10.15.02.03.05;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	zOqt4CiDlaWcaRCM;

1.50
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.49;
commitid	vhXZZxMGVTWiFaF3;

1.49
date	2013.11.01.15.57.56;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2013.01.14.06.32.37;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2012.04.14.12.11.47;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2012.03.09.13.02.45;	author ariane;	state Exp;
branches;
next	1.45;

1.45
date	2012.01.07.05.38.12;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2011.06.06.17.18.26;	author ariane;	state Exp;
branches;
next	1.43;

1.43
date	2011.05.24.15.27.36;	author ariane;	state Exp;
branches;
next	1.42;

1.42
date	2011.03.12.04.54.28;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.10.03.37.50;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.20.20.20.43;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.21.22.18.00;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.26.05.42.05;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.10.15.53.51;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.18.21.51.15;	author pedro;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.14.11.06.43;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.12.22.14.15;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.29.12.32.57;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.07.13.22.51.24;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.21.16.20.05;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.31.03.59.40;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.12.07.24.28;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.24.21.06.47;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.24.18.19.25;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.15.03.52.59;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.14.03.46.46;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.13.23.01.09;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.07.03.47.46;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.07.02.16.33;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.17.20.25.18;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.06.21.08.05;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.20.18.41;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.20.17.16.56;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.08.22.32.36;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.17.19.42.25;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.26;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.13.08.16.00;	author hugh;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.05.01.01.58;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.19.17.36;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.05.23.04.35;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.27.06.16.45;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.18.09.08.38;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.18.17.59.54;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.06.22.12.54.45;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.02.26.16.46.33;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.23.16.43.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.05.14.57.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.44;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@/*	$OpenBSD: kvm_proc.c,v 1.57 2016/09/16 04:03:27 dlg Exp $	*/
/*	$NetBSD: kvm_proc.c,v 1.30 1999/03/24 05:50:50 mrg Exp $	*/
/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software developed by the Computer Systems
 * Engineering group at Lawrence Berkeley Laboratory under DARPA contract
 * BG 91-66 and contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Proc traversal interface for kvm.  ps and w are (probably) the exclusive
 * users of this code, so we've factored it out into a separate module.
 * Thus, we keep this grunge out of the other kvm applications (i.e.,
 * most other applications are interested only in open/close/read/nlist).
 */

#define __need_process
#include <sys/param.h>
#include <sys/proc.h>
#include <sys/exec.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <nlist.h>
#include <kvm.h>
#include <errno.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm_amap.h>
#include <machine/vmparam.h>
#include <machine/pmap.h>

#include <sys/sysctl.h>

#include <limits.h>
#include <db.h>
#include <paths.h>

#include "kvm_private.h"


static char	*_kvm_ureadm(kvm_t *, const struct kinfo_proc *, u_long, u_long *);
static ssize_t	kvm_ureadm(kvm_t *, const struct kinfo_proc *, u_long, char *, size_t);

static char	**kvm_argv(kvm_t *, const struct kinfo_proc *, u_long, int, int);

static char	**kvm_doargv(kvm_t *, const struct kinfo_proc *, int,
		    void (*)(struct ps_strings *, u_long *, int *));
static int	proc_verify(kvm_t *, const struct kinfo_proc *);
static void	ps_str_a(struct ps_strings *, u_long *, int *);
static void	ps_str_e(struct ps_strings *, u_long *, int *);

static struct vm_anon *
_kvm_findanon(kvm_t *kd, struct vm_amap *amapp, int slot)
{
	u_long addr;
	int bucket;
	struct vm_amap amap;
	struct vm_amap_chunk chunk, *chunkp;
	struct vm_anon *anonp;

	addr = (u_long)amapp;
	if (KREAD(kd, addr, &amap))
		return (NULL);

	/* sanity-check slot number */
	if (slot > amap.am_nslot)
		return (NULL);

	if (UVM_AMAP_SMALL(&amap))
		chunkp = &amapp->am_small;
	else {
		bucket = UVM_AMAP_BUCKET(&amap, slot);
		addr = (u_long)(amap.am_buckets + bucket);
		if (KREAD(kd, addr, &chunkp))
			return (NULL);

		while (chunkp != NULL) {
			addr = (u_long)chunkp;
			if (KREAD(kd, addr, &chunk))
				return (NULL);

			if (UVM_AMAP_BUCKET(&amap, chunk.ac_baseslot) !=
			    bucket)
				return (NULL);
			if (slot >= chunk.ac_baseslot &&
			    slot < chunk.ac_baseslot + chunk.ac_nslot)
				break;

			chunkp = TAILQ_NEXT(&chunk, ac_list);
		}
		if (chunkp == NULL)
			return (NULL);
	}

	addr = (u_long)&chunkp->ac_anon[UVM_AMAP_SLOTIDX(slot)];
	if (KREAD(kd, addr, &anonp))
		return (NULL);

	return (anonp);
}

static char *
_kvm_ureadm(kvm_t *kd, const struct kinfo_proc *p, u_long va, u_long *cnt)
{
	u_long addr, offset, slot;
	struct vmspace vm;
	struct vm_anon *anonp, anon;
	struct vm_map_entry vme;
	struct vm_page pg;
	unsigned long rboff;

	if (kd->swapspc == 0) {
		kd->swapspc = _kvm_malloc(kd, kd->nbpg);
		if (kd->swapspc == 0)
			return (NULL);
	}

	rboff = (unsigned long)&vme.daddrs.addr_entry - (unsigned long)&vme;

	/*
	 * Look through the address map for the memory object
	 * that corresponds to the given virtual address.
	 */
	if (KREAD(kd, (u_long)p->p_vmspace, &vm))
		return (NULL);
	addr = (u_long)&vm.vm_map.addr.rbh_root.rbt_root;
	while (1) {
		if (addr == 0)
			return (NULL);
		addr -= rboff;
		if (KREAD(kd, addr, &vme))
			return (NULL);

		if (va < vme.start)
			addr = (u_long)vme.daddrs.addr_entry.rbt_left;
		else if (va >= vme.end + vme.guard + vme.fspace)
			addr = (u_long)vme.daddrs.addr_entry.rbt_right;
		else if (va >= vme.end)
			return (NULL);
		else
			break;
	}

	/*
	 * we found the map entry, now to find the object...
	 */
	if (vme.aref.ar_amap == NULL)
		return (NULL);

	offset = va - vme.start;
	slot = offset / kd->nbpg + vme.aref.ar_pageoff;

	anonp = _kvm_findanon(kd, vme.aref.ar_amap, slot);
	if (anonp == NULL)
		return (NULL);

	addr = (u_long)anonp;
	if (KREAD(kd, addr, &anon))
		return (NULL);

	addr = (u_long)anon.an_page;
	if (addr) {
		if (KREAD(kd, addr, &pg))
			return (NULL);

		if (_kvm_pread(kd, kd->pmfd, (void *)kd->swapspc,
		    (size_t)kd->nbpg, (off_t)pg.phys_addr) != kd->nbpg)
			return (NULL);
	} else {
		if (kd->swfd == -1 ||
		    _kvm_pread(kd, kd->swfd, (void *)kd->swapspc,
		    (size_t)kd->nbpg,
		    (off_t)(anon.an_swslot * kd->nbpg)) != kd->nbpg)
			return (NULL);
	}

	/* Found the page. */
	offset %= kd->nbpg;
	*cnt = kd->nbpg - offset;
	return (&kd->swapspc[offset]);
}

void *
_kvm_reallocarray(kvm_t *kd, void *p, size_t i, size_t n)
{
	void *np = reallocarray(p, i, n);

	if (np == 0)
		_kvm_err(kd, kd->program, "out of memory");
	return (np);
}

/*
 * Read in an argument vector from the user address space of process p.
 * addr if the user-space base address of narg null-terminated contiguous
 * strings.  This is used to read in both the command arguments and
 * environment strings.  Read at most maxcnt characters of strings.
 */
static char **
kvm_argv(kvm_t *kd, const struct kinfo_proc *p, u_long addr, int narg,
    int maxcnt)
{
	char *np, *cp, *ep, *ap, **argv;
	u_long oaddr = -1;
	int len, cc;

	/*
	 * Check that there aren't an unreasonable number of arguments,
	 * and that the address is in user space.
	 */
	if (narg > ARG_MAX || addr < VM_MIN_ADDRESS || addr >= VM_MAXUSER_ADDRESS)
		return (0);

	if (kd->argv == 0) {
		/*
		 * Try to avoid reallocs.
		 */
		kd->argc = MAX(narg + 1, 32);
		kd->argv = _kvm_reallocarray(kd, NULL, kd->argc,
		    sizeof(*kd->argv));
		if (kd->argv == 0)
			return (0);
	} else if (narg + 1 > kd->argc) {
		kd->argc = MAX(2 * kd->argc, narg + 1);
		kd->argv = (char **)_kvm_reallocarray(kd, kd->argv, kd->argc,
		    sizeof(*kd->argv));
		if (kd->argv == 0)
			return (0);
	}
	if (kd->argspc == 0) {
		kd->argspc = _kvm_malloc(kd, kd->nbpg);
		if (kd->argspc == 0)
			return (0);
		kd->arglen = kd->nbpg;
	}
	if (kd->argbuf == 0) {
		kd->argbuf = _kvm_malloc(kd, kd->nbpg);
		if (kd->argbuf == 0)
			return (0);
	}
	cc = sizeof(char *) * narg;
	if (kvm_ureadm(kd, p, addr, (char *)kd->argv, cc) != cc)
		return (0);
	ap = np = kd->argspc;
	argv = kd->argv;
	len = 0;

	/*
	 * Loop over pages, filling in the argument vector.
	 */
	while (argv < kd->argv + narg && *argv != 0) {
		addr = (u_long)*argv & ~(kd->nbpg - 1);
		if (addr != oaddr) {
			if (kvm_ureadm(kd, p, addr, kd->argbuf, kd->nbpg) !=
			    kd->nbpg)
				return (0);
			oaddr = addr;
		}
		addr = (u_long)*argv & (kd->nbpg - 1);
		cp = kd->argbuf + addr;
		cc = kd->nbpg - addr;
		if (maxcnt > 0 && cc > maxcnt - len)
			cc = maxcnt - len;
		ep = memchr(cp, '\0', cc);
		if (ep != 0)
			cc = ep - cp + 1;
		if (len + cc > kd->arglen) {
			int off;
			char **pp;
			char *op = kd->argspc;
			char *newp;

			newp = _kvm_reallocarray(kd, kd->argspc,
			    kd->arglen, 2);
			if (newp == 0)
				return (0);
			kd->argspc = newp;
			kd->arglen *= 2;
			/*
			 * Adjust argv pointers in case realloc moved
			 * the string space.
			 */
			off = kd->argspc - op;
			for (pp = kd->argv; pp < argv; pp++)
				*pp += off;
			ap += off;
			np += off;
		}
		memcpy(np, cp, cc);
		np += cc;
		len += cc;
		if (ep != 0) {
			*argv++ = ap;
			ap = np;
		} else
			*argv += cc;
		if (maxcnt > 0 && len >= maxcnt) {
			/*
			 * We're stopping prematurely.  Terminate the
			 * current string.
			 */
			if (ep == 0) {
				*np = '\0';
				*argv++ = ap;
			}
			break;
		}
	}
	/* Make sure argv is terminated. */
	*argv = 0;
	return (kd->argv);
}

static void
ps_str_a(struct ps_strings *p, u_long *addr, int *n)
{
	*addr = (u_long)p->ps_argvstr;
	*n = p->ps_nargvstr;
}

static void
ps_str_e(struct ps_strings *p, u_long *addr, int *n)
{
	*addr = (u_long)p->ps_envstr;
	*n = p->ps_nenvstr;
}

/*
 * Determine if the proc indicated by p is still active.
 * This test is not 100% foolproof in theory, but chances of
 * being wrong are very low.
 */
static int
proc_verify(kvm_t *kd, const struct kinfo_proc *p)
{
	struct proc kernproc;
	struct process kernprocess;

	if (p->p_psflags & (PS_EMBRYO | PS_ZOMBIE))
		return (0);

	/*
	 * Just read in the whole proc.  It's not that big relative
	 * to the cost of the read system call.
	 */
	if (KREAD(kd, (u_long)p->p_paddr, &kernproc))
		return (0);
	if (KREAD(kd, (u_long)kernproc.p_p, &kernprocess))
		return (0);
	if (p->p_pid != kernprocess.ps_pid)
		return (0);
	return ((kernprocess.ps_flags & (PS_EMBRYO | PS_ZOMBIE)) == 0);
}

static char **
kvm_doargv(kvm_t *kd, const struct kinfo_proc *p, int nchr,
    void (*info)(struct ps_strings *, u_long *, int *))
{
	static struct ps_strings *ps;
	struct ps_strings arginfo;
	u_long addr;
	char **ap;
	int cnt;

	if (ps == NULL) {
		struct _ps_strings _ps;
		int mib[2];
		size_t len;

		mib[0] = CTL_VM;
		mib[1] = VM_PSSTRINGS;
		len = sizeof(_ps);
		sysctl(mib, 2, &_ps, &len, NULL, 0);
		ps = (struct ps_strings *)_ps.val;
	}

	/*
	 * Pointers are stored at the top of the user stack.
	 */
	if (p->p_psflags & (PS_EMBRYO | PS_ZOMBIE) ||
	    kvm_ureadm(kd, p, (u_long)ps, (char *)&arginfo,
	    sizeof(arginfo)) != sizeof(arginfo))
		return (0);

	(*info)(&arginfo, &addr, &cnt);
	if (cnt == 0)
		return (0);
	ap = kvm_argv(kd, p, addr, cnt, nchr);
	/*
	 * For live kernels, make sure this process didn't go away.
	 */
	if (ap != 0 && ISALIVE(kd) && !proc_verify(kd, p))
		ap = 0;
	return (ap);
}

static char **
kvm_arg_sysctl(kvm_t *kd, pid_t pid, int nchr, int env)
{
	size_t len, orglen;
	int mib[4], ret;
	char *buf;

	orglen = env ? kd->nbpg : 8 * kd->nbpg;	/* XXX - should be ARG_MAX */
	if (kd->argbuf == NULL &&
	    (kd->argbuf = _kvm_malloc(kd, orglen)) == NULL)
		return (NULL);

again:
	mib[0] = CTL_KERN;
	mib[1] = KERN_PROC_ARGS;
	mib[2] = (int)pid;
	mib[3] = env ? KERN_PROC_ENV : KERN_PROC_ARGV;

	len = orglen;
	ret = (sysctl(mib, 4, kd->argbuf, &len, NULL, 0) < 0);
	if (ret && errno == ENOMEM) {
		buf = _kvm_reallocarray(kd, kd->argbuf, orglen, 2);
		if (buf == NULL)
			return (NULL);
		orglen *= 2;
		kd->argbuf = buf;
		goto again;
	}

	if (ret) {
		free(kd->argbuf);
		kd->argbuf = NULL;
		_kvm_syserr(kd, kd->program, "kvm_arg_sysctl");
		return (NULL);
	}
#if 0
	for (argv = (char **)kd->argbuf; *argv != NULL; argv++)
		if (strlen(*argv) > nchr)
			*argv[nchr] = '\0';
#endif

	return (char **)(kd->argbuf);
}

/*
 * Get the command args.  This code is now machine independent.
 */
char **
kvm_getargv(kvm_t *kd, const struct kinfo_proc *kp, int nchr)
{
	if (ISALIVE(kd))
		return (kvm_arg_sysctl(kd, kp->p_pid, nchr, 0));
	return (kvm_doargv(kd, kp, nchr, ps_str_a));
}

char **
kvm_getenvv(kvm_t *kd, const struct kinfo_proc *kp, int nchr)
{
	if (ISALIVE(kd))
		return (kvm_arg_sysctl(kd, kp->p_pid, nchr, 1));
	return (kvm_doargv(kd, kp, nchr, ps_str_e));
}

/*
 * Read from user space.  The user context is given by p.
 */
static ssize_t
kvm_ureadm(kvm_t *kd, const struct kinfo_proc *p, u_long uva, char *buf,
    size_t len)
{
	char *cp = buf;

	while (len > 0) {
		u_long cnt;
		size_t cc;
		char *dp;

		dp = _kvm_ureadm(kd, p, uva, &cnt);
		if (dp == 0) {
			_kvm_err(kd, 0, "invalid address (%lx)", uva);
			return (0);
		}
		cc = (size_t)MIN(cnt, len);
		memcpy(cp, dp, cc);
		cp += cc;
		uva += cc;
		len -= cc;
	}
	return (ssize_t)(cp - buf);
}
@


1.57
log
@handle fallout of moving the address maps to RBT code.

because userland doesnt have subr_tree, and the tree traversal in
this file is simple, this inlines the logic that the functions in
the kernel do.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.56 2016/05/26 13:37:26 stefan Exp $	*/
d407 1
a407 1
	if (p->p_pid != kernproc.p_pid)
d409 1
a409 1
	if (KREAD(kd, (u_long)kernproc.p_p, &kernprocess))
@


1.56
log
@Make amaps use less kernel memory (2nd try)

The original diff would crash at least i386 and powerpc, as spotted by
guenther@@ The reason was an incorrect use of sizeof in amap_lookups().

Confirmation that powerpc works by mpi@@ and mglocker@@

"throw it in" deraadt@@

Original commit message:

This is achieved by grouping amap slots into chunks that are allocated
on-demand by pool(9). Endless "fltamapcopy" loops because of kmem
shortage should be solved now. The kmem savings are also important to later
enable vmm(4) to use larged shared memory mappings for guest VM RAM.

This adapts libkvm also because the amap structure layout has changed.

Testing and fix of libkvm glitch in initial diff by tb@@
Feedback and "time to get this in" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.55 2016/05/22 22:52:01 guenther Exp $	*/
d169 1
d177 2
d185 1
a185 1
	addr = (u_long)RB_ROOT(&vm.vm_map.addr);
d189 1
d194 1
a194 1
			addr = (u_long)RB_LEFT(&vme, daddrs.addr_entry);
d196 1
a196 1
			addr = (u_long)RB_RIGHT(&vme, daddrs.addr_entry);
@


1.55
log
@Revert previous: breaks i386 and powerpc, probably all non-PMAP_DIRECT archs
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.53 2016/05/11 17:46:44 tedu Exp $	*/
d111 50
a167 1
	struct vm_amap amap;
a204 4
	addr = (u_long)vme.aref.ar_amap;
	if (KREAD(kd, addr, &amap))
		return (NULL);

a206 3
	/* sanity-check slot number */
	if (slot > amap.am_nslot)
		return (NULL);
d208 2
a209 2
	addr = (u_long)amap.am_anon + (offset / kd->nbpg) * sizeof(anonp);
	if (KREAD(kd, addr, &anonp))
@


1.54
log
@Make amaps use less kernel memory

This is achieved by grouping amap slots into chunks that are allocated
on-demand by pool(9). Endless "fltamapcopy" loops because of kmem
shortage should be solved now. The kmem savings are also important to later
enable vmm(4) to use larged shared memory mappings for guest VM RAM.

This adapts libkvm also because the amap structure layout has changed.

Testing and fix of libkvm glitch in initial diff by tb@@
Feedback and "time to get this in" kettenis@@
@
text
@a110 50
static struct vm_anon *
_kvm_findanon(kvm_t *kd, struct vm_amap *amapp, int slot)
{
	u_long addr;
	int bucket;
	struct vm_amap amap;
	struct vm_amap_chunk chunk, *chunkp;
	struct vm_anon *anonp;

	addr = (u_long)amapp;
	if (KREAD(kd, addr, &amap))
		return (NULL);

	/* sanity-check slot number */
	if (slot > amap.am_nslot)
		return (NULL);

	if (UVM_AMAP_SMALL(&amap))
		chunkp = &amapp->am_small;
	else {
		bucket = UVM_AMAP_BUCKET(&amap, slot);
		addr = (u_long)(amap.am_buckets + bucket);
		if (KREAD(kd, addr, &chunkp))
			return (NULL);

		while (chunkp != NULL) {
			addr = (u_long)chunkp;
			if (KREAD(kd, addr, &chunk))
				return (NULL);

			if (UVM_AMAP_BUCKET(&amap, chunk.ac_baseslot) !=
			    bucket)
				return (NULL);
			if (slot >= chunk.ac_baseslot &&
			    slot < chunk.ac_baseslot + chunk.ac_nslot)
				break;

			chunkp = TAILQ_NEXT(&chunk, ac_list);
		}
		if (chunkp == NULL)
			return (NULL);
	}

	addr = (u_long)&chunkp->ac_anon[UVM_AMAP_SLOTIDX(slot)];
	if (KREAD(kd, addr, &anonp))
		return (NULL);

	return (anonp);
}

d118 1
d156 4
d162 3
d166 2
a167 2
	anonp = _kvm_findanon(kd, vme.aref.ar_amap, slot);
	if (anonp == NULL)
@


1.53
log
@convert bcopy to memcpy. ok dlg millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.52 2014/10/22 04:13:35 guenther Exp $	*/
d111 50
a167 1
	struct vm_amap amap;
a204 4
	addr = (u_long)vme.aref.ar_amap;
	if (KREAD(kd, addr, &amap))
		return (NULL);

a206 3
	/* sanity-check slot number */
	if (slot > amap.am_nslot)
		return (NULL);
d208 2
a209 2
	addr = (u_long)amap.am_anon + (offset / kd->nbpg) * sizeof(anonp);
	if (KREAD(kd, addr, &anonp))
@


1.52
log
@Don't leak the old data if _kvm_reallocarray() fails

ok millert@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.51 2014/10/15 02:03:05 deraadt Exp $	*/
d493 1
a493 1
		bcopy(dp, cp, cc);
@


1.51
log
@Apply reallocarray() idiom.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.50 2014/07/04 05:58:31 guenther Exp $	*/
d284 1
d286 1
a286 1
			kd->argspc = _kvm_reallocarray(kd, kd->argspc,
d288 1
a288 1
			if (kd->argspc == 0)
d290 1
@


1.50
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.49 2013/11/01 15:57:56 deraadt Exp $	*/
d197 1
a197 1
_kvm_realloc(kvm_t *kd, void *p, size_t n)
d199 1
a199 1
	void *np = (void *)realloc(p, n);
d232 1
a232 1
		kd->argv = _kvm_malloc(kd, kd->argc *
d238 1
a238 1
		kd->argv = (char **)_kvm_realloc(kd, kd->argv, kd->argc *
d285 2
a286 3
			kd->arglen *= 2;
			kd->argspc = (char *)_kvm_realloc(kd, kd->argspc,
			    kd->arglen);
d289 1
d429 1
a429 2
		orglen *= 2;
		buf = _kvm_realloc(kd, kd->argbuf, orglen);
d432 1
@


1.49
log
@reduce use of <sys/user.h>
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.48 2013/01/14 06:32:37 guenther Exp $	*/
d72 1
d348 4
d357 5
a361 2
	if (kvm_read(kd, (u_long)p->p_paddr, &kernproc, sizeof(kernproc)) !=
	    sizeof(kernproc))
d363 1
a363 2
	return (p->p_pid == kernproc.p_pid &&
	    (kernproc.p_stat != SZOMB || p->p_stat == SZOMB));
d391 1
a391 1
	if (p->p_stat == SZOMB ||
@


1.48
log
@No longer need the "miniproc" glue, as we only have kinfo_proc now.

ok deraadt@@ pirofti@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.47 2012/04/14 12:11:47 guenther Exp $	*/
a72 1
#include <sys/user.h>
d83 1
@


1.47
log
@Need to read in the vmspace to dig out the root of the rb-tree
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.46 2012/03/09 13:02:45 ariane Exp $	*/
a97 21
/*
 * Common info from kinfo_proc used by helper routines.
 */
struct miniproc {
	struct	vmspace *p_vmspace;
	char	p_stat;
	struct	proc *p_paddr;
	pid_t	p_pid;
};

/*
 * Convert from struct kinfo_proc to miniproc.
 */
#define KPTOMINI(kp, p) \
	do { \
		(p)->p_stat = (kp)->p_stat; \
		(p)->p_pid = (kp)->p_pid; \
		(p)->p_paddr = (void *)(long)(kp)->p_paddr; \
		(p)->p_vmspace = (void *)(long)(kp)->p_vmspace; \
	} while (/*CONSTCOND*/0);

d99 2
a100 2
static char	*_kvm_ureadm(kvm_t *, const struct miniproc *, u_long, u_long *);
static ssize_t	kvm_ureadm(kvm_t *, const struct miniproc *, u_long, char *, size_t);
d102 1
a102 1
static char	**kvm_argv(kvm_t *, const struct miniproc *, u_long, int, int);
d104 1
a104 1
static char	**kvm_doargv(kvm_t *, const struct miniproc *, int,
d106 1
a106 1
static int	proc_verify(kvm_t *, const struct miniproc *);
d111 1
a111 1
_kvm_ureadm(kvm_t *kd, const struct miniproc *p, u_long va, u_long *cnt)
d212 1
a212 1
kvm_argv(kvm_t *kd, const struct miniproc *p, u_long addr, int narg,
d344 1
a344 1
proc_verify(kvm_t *kd, const struct miniproc *p)
d360 1
a360 1
kvm_doargv(kvm_t *kd, const struct miniproc *p, int nchr,
a450 2
	struct miniproc p;

d453 1
a453 2
	KPTOMINI(kp, &p);
	return (kvm_doargv(kd, &p, nchr, ps_str_a));
a458 2
	struct miniproc p;

d461 1
a461 2
	KPTOMINI(kp, &p);
	return (kvm_doargv(kd, &p, nchr, ps_str_e));
d468 1
a468 1
kvm_ureadm(kvm_t *kd, const struct miniproc *p, u_long uva, char *buf,
@


1.46
log
@Userspace counterpart of new vmmap.

Allows memory walks to function.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.45 2012/01/07 05:38:12 guenther Exp $	*/
d135 1
d151 3
a153 1
	addr = (u_long)RB_ROOT(&p->p_vmspace->vm_map.addr);
@


1.45
log
@Add rtable id and thread id to struct kinfo_proc (and fix process id)
and add an 'rtableid' keyword to ps.

Add rtable id, thread id, and socket splice info to struct kinfo_file2
and make fstat display socket splice information.

Remove old KVM_PROC2 and kinfo_proc2 interfaces; bump libkvm major

Socket splice info and corrections from bluhm@@  "Lovely" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.44 2011/06/06 17:18:26 ariane Exp $	*/
d134 1
a134 1
	u_long addr, head, offset, slot;
d143 1
a143 1
			return (0);
a148 1
	 * The header just has the entire valid range.
d150 1
a150 2
	head = (u_long)&p->p_vmspace->vm_map.header;
	addr = head;
d152 2
d155 1
a155 1
			return (0);
d157 7
a163 2
		if (va >= vme.start && va < vme.end &&
		    vme.aref.ar_amap != NULL)
a164 4

		addr = (u_long)vme.next;
		if (addr == head)
			return (0);
@


1.44
log
@Userland counterpart of the vmmap backout; cranks major version of libkvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.43 2011/05/24 15:27:36 ariane Exp $	*/
a476 6
kvm_getargv2(kvm_t *kd, const struct kinfo_proc *kp, int nchr)
{
	return (kvm_getargv(kd, kp, nchr));
}

char **
a484 6
}

char **
kvm_getenvv2(kvm_t *kd, const struct kinfo_proc *kp, int nchr)
{
	return (kvm_getenvv(kd, kp, nchr));
@


1.43
log
@Reimplement uvm/uvm_map.

vmmap is designed to perform address space randomized allocations,
without letting fragmentation of the address space go through the roof.

Some highlights:
- kernel address space randomization
- proper implementation of guardpages
- roughly 10% system time reduction during kernel build

Tested by alot of people on tech@@ and developers.
Theo's machines are still happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.42 2011/03/12 04:54:28 guenther Exp $	*/
d134 1
a134 1
	u_long addr, offset, slot;
d143 1
a143 1
			return (NULL);
d149 1
d151 2
a152 1
	addr = (u_long)RB_ROOT(&p->p_vmspace->vm_map.addr);
a153 2
		if (addr == 0)
			return (NULL);
d155 1
a155 1
			return (NULL);
d157 2
a158 7
		if (va < vme.start)
			addr = (u_long)RB_LEFT(&vme, daddrs.addr_entry);
		else if (va >= vme.end + vme.guard + vme.fspace)
			addr = (u_long)RB_RIGHT(&vme, daddrs.addr_entry);
		else if (va >= vme.end)
			return (NULL);
		else
d160 4
@


1.42
log
@Replace the old, broken KERN_PROC ABI and its matching functions
in libkvm with the stable-ABI versions that are currently named
KERN_PROC2, kvm_get{proc,argv,envv}2().  The latter names and symbols
will continue to be supported for a few releases.

Committing now that they ports people have had a couple releases
to update pkgs that usd the old functions
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.41 2010/07/26 01:56:27 guenther Exp $	*/
d134 1
a134 1
	u_long addr, head, offset, slot;
d143 1
a143 1
			return (0);
a148 1
	 * The header just has the entire valid range.
d150 1
a150 2
	head = (u_long)&p->p_vmspace->vm_map.header;
	addr = head;
d152 2
d155 1
a155 1
			return (0);
d157 7
a163 2
		if (va >= vme.start && va < vme.end &&
		    vme.aref.ar_amap != NULL)
a164 4

		addr = (u_long)vme.next;
		if (addr == head)
			return (0);
@


1.41
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.40 2010/01/10 03:37:50 guenther Exp $	*/
a71 1
#define __need_process
d99 1
a99 1
 * Common info from kinfo_proc and kinfo_proc2 used by helper routines.
d109 1
a109 1
 * Convert from struct proc and kinfo_proc{,2} to miniproc.
a110 8
#define PTOMINI(kp, p) \
	do { \
		(p)->p_stat = (kp)->p_stat; \
		(p)->p_pid = (kp)->p_pid; \
		(p)->p_paddr = NULL; \
		(p)->p_vmspace = (kp)->p_vmspace; \
	} while (/*CONSTCOND*/0);

a112 8
		(p)->p_stat = (kp)->kp_proc.p_stat; \
		(p)->p_pid = (kp)->kp_proc.p_pid; \
		(p)->p_paddr = (kp)->kp_eproc.e_paddr; \
		(p)->p_vmspace = (kp)->kp_proc.p_vmspace; \
	} while (/*CONSTCOND*/0);

#define KP2TOMINI(kp, p) \
	do { \
a119 2
ssize_t		kvm_uread(kvm_t *, const struct proc *, u_long, char *, size_t);

a124 1
static int	kvm_deadprocs(kvm_t *, int, int, u_long, u_long, int);
a126 2
static int	kvm_proclist(kvm_t *, int, int, struct proc *,
		    struct kinfo_proc *, int);
a211 255
char *
_kvm_uread(kvm_t *kd, const struct proc *p, u_long va, u_long *cnt)
{
	struct miniproc mp;

	PTOMINI(p, &mp);
	return (_kvm_ureadm(kd, &mp, va, cnt));
}

/*
 * Read proc's from memory file into buffer bp, which has space to hold
 * at most maxcnt procs.
 */
static int
kvm_proclist(kvm_t *kd, int what, int arg, struct proc *p,
    struct kinfo_proc *bp, int maxcnt)
{
	struct session sess;
	struct eproc eproc;
	struct proc proc;
	struct process process;
	struct pgrp pgrp;
	struct tty tty;
	int cnt = 0;

	for (; cnt < maxcnt && p != NULL; p = LIST_NEXT(&proc, p_list)) {
		if (KREAD(kd, (u_long)p, &proc)) {
			_kvm_err(kd, kd->program, "can't read proc at %x", p);
			return (-1);
		}
		if (KREAD(kd, (u_long)proc.p_p, &process)) {
			_kvm_err(kd, kd->program, "can't read process at %x", proc.p_p);
			return (-1);
		}
		if (KREAD(kd, (u_long)process.ps_cred, &eproc.e_pcred) == 0)
			KREAD(kd, (u_long)eproc.e_pcred.pc_ucred,
			    &eproc.e_ucred);

		switch (what) {
		case KERN_PROC_PID:
			if (proc.p_pid != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_UID:
			if (eproc.e_ucred.cr_uid != (uid_t)arg)
				continue;
			break;

		case KERN_PROC_RUID:
			if (eproc.e_pcred.p_ruid != (uid_t)arg)
				continue;
			break;

		case KERN_PROC_ALL:
			if (proc.p_flag & P_SYSTEM)
				continue;
			break;
		}
		/*
		 * We're going to add another proc to the set.  If this
		 * will overflow the buffer, assume the reason is because
		 * nprocs (or the proc list) is corrupt and declare an error.
		 */
		if (cnt >= maxcnt) {
			_kvm_err(kd, kd->program, "nprocs corrupt");
			return (-1);
		}
		/*
		 * gather eproc
		 */
		eproc.e_paddr = p;
		if (KREAD(kd, (u_long)process.ps_pgrp, &pgrp)) {
			_kvm_err(kd, kd->program, "can't read pgrp at %x",
			    process.ps_pgrp);
			return (-1);
		}
		eproc.e_sess = pgrp.pg_session;
		eproc.e_pgid = pgrp.pg_id;
		eproc.e_jobc = pgrp.pg_jobc;
		if (KREAD(kd, (u_long)pgrp.pg_session, &sess)) {
			_kvm_err(kd, kd->program, "can't read session at %x",
			    pgrp.pg_session);
			return (-1);
		}
		if ((process.ps_flags & PS_CONTROLT) && sess.s_ttyp != NULL) {
			if (KREAD(kd, (u_long)sess.s_ttyp, &tty)) {
				_kvm_err(kd, kd->program,
				    "can't read tty at %x", sess.s_ttyp);
				return (-1);
			}
			eproc.e_tdev = tty.t_dev;
			eproc.e_tsess = tty.t_session;
			if (tty.t_pgrp != NULL) {
				if (KREAD(kd, (u_long)tty.t_pgrp, &pgrp)) {
					_kvm_err(kd, kd->program,
					    "can't read tpgrp at &x",
					    tty.t_pgrp);
					return (-1);
				}
				eproc.e_tpgid = pgrp.pg_id;
			} else
				eproc.e_tpgid = -1;
		} else
			eproc.e_tdev = NODEV;
		eproc.e_flag = sess.s_ttyvp ? EPROC_CTTY : 0;
		if (sess.s_leader == proc.p_p)
			eproc.e_flag |= EPROC_SLEADER;
		if (proc.p_wmesg)
			(void)kvm_read(kd, (u_long)proc.p_wmesg,
			    eproc.e_wmesg, WMESGLEN);

		(void)kvm_read(kd, (u_long)proc.p_vmspace,
		    &eproc.e_vm, sizeof(eproc.e_vm));

		eproc.e_xsize = eproc.e_xrssize = 0;
		eproc.e_xccount = eproc.e_xswrss = 0;

		switch (what) {
		case KERN_PROC_PGRP:
			if (eproc.e_pgid != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_TTY:
			if ((process.ps_flags & PS_CONTROLT) == 0 ||
			    eproc.e_tdev != (dev_t)arg)
				continue;
			break;
		}
		proc.p_flag |= process.ps_flags;
		bcopy(&proc, &bp->kp_proc, sizeof(proc));
		bcopy(&eproc, &bp->kp_eproc, sizeof(eproc));
		++bp;
		++cnt;
	}
	return (cnt);
}

/*
 * Build proc info array by reading in proc list from a crash dump.
 * Return number of procs read.  maxcnt is the max we will read.
 */
static int
kvm_deadprocs(kvm_t *kd, int what, int arg, u_long a_allproc,
    u_long a_zombproc, int maxcnt)
{
	struct kinfo_proc *bp = kd->procbase;
	struct proc *p;
	int acnt, zcnt;

	if (KREAD(kd, a_allproc, &p)) {
		_kvm_err(kd, kd->program, "cannot read allproc");
		return (-1);
	}
	acnt = kvm_proclist(kd, what, arg, p, bp, maxcnt);
	if (acnt < 0)
		return (acnt);

	if (KREAD(kd, a_zombproc, &p)) {
		_kvm_err(kd, kd->program, "cannot read zombproc");
		return (-1);
	}
	zcnt = kvm_proclist(kd, what, arg, p, bp + acnt, maxcnt - acnt);
	if (zcnt < 0)
		zcnt = 0;

	return (acnt + zcnt);
}

struct kinfo_proc *
kvm_getprocs(kvm_t *kd, int op, int arg, int *cnt)
{
	int mib[4], st, nprocs;
	size_t size;

	if (kd->procbase != 0) {
		free((void *)kd->procbase);
		/*
		 * Clear this pointer in case this call fails.  Otherwise,
		 * kvm_close() will free it again.
		 */
		kd->procbase = 0;
	}
	if (ISALIVE(kd)) {
		size = 0;
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC;
		mib[2] = op;
		mib[3] = arg;
		st = sysctl(mib, 4, NULL, &size, NULL, 0);
		if (st == -1) {
			_kvm_syserr(kd, kd->program, "kvm_getprocs");
			return (0);
		}
		kd->procbase = _kvm_malloc(kd, size);
		if (kd->procbase == 0)
			return (0);
		st = sysctl(mib, 4, kd->procbase, &size, NULL, 0);
		if (st == -1) {
			_kvm_syserr(kd, kd->program, "kvm_getprocs");
			return (0);
		}
		if (size % sizeof(struct kinfo_proc) != 0) {
			_kvm_err(kd, kd->program,
			    "proc size mismatch (%d total, %d chunks)",
			    size, sizeof(struct kinfo_proc));
			return (0);
		}
		nprocs = size / sizeof(struct kinfo_proc);
	} else {
		struct nlist nl[4], *p;

		memset(nl, 0, sizeof(nl));
		nl[0].n_name = "_nprocs";
		nl[1].n_name = "_allproc";
		nl[2].n_name = "_zombproc";
		nl[3].n_name = NULL;

		if (kvm_nlist(kd, nl) != 0) {
			for (p = nl; p->n_type != 0; ++p)
				;
			_kvm_err(kd, kd->program,
			    "%s: no such symbol", p->n_name);
			return (0);
		}
		if (KREAD(kd, nl[0].n_value, &nprocs)) {
			_kvm_err(kd, kd->program, "can't read nprocs");
			return (0);
		}
		size = nprocs * sizeof(struct kinfo_proc);
		kd->procbase = _kvm_malloc(kd, size);
		if (kd->procbase == 0)
			return (0);

		nprocs = kvm_deadprocs(kd, op, arg, nl[1].n_value,
		    nl[2].n_value, nprocs);
#ifdef notdef
		size = nprocs * sizeof(struct kinfo_proc);
		(void)realloc(kd->procbase, size);
#endif
	}
	*cnt = nprocs;
	return (kd->procbase);
}

void
_kvm_freeprocs(kvm_t *kd)
{
	if (kd->procbase) {
		free(kd->procbase);
		kd->procbase = 0;
	}
}

d237 1
a237 1
	 * Check that there aren't an unreasonable number of agruments,
d471 1
a471 1
		return (kvm_arg_sysctl(kd, kp->kp_proc.p_pid, nchr, 0));
d477 1
a477 1
kvm_getenvv(kvm_t *kd, const struct kinfo_proc *kp, int nchr)
d479 1
a479 6
	struct miniproc p;

	if (ISALIVE(kd))
		return (kvm_arg_sysctl(kd, kp->kp_proc.p_pid, nchr, 1));
	KPTOMINI(kp, &p);
	return (kvm_doargv(kd, &p, nchr, ps_str_e));
d483 1
a483 1
kvm_getargv2(kvm_t *kd, const struct kinfo_proc2 *kp, int nchr)
d488 3
a490 3
		return (kvm_arg_sysctl(kd, kp->p_pid, nchr, 0));
	KP2TOMINI(kp, &p);
	return (kvm_doargv(kd, &p, nchr, ps_str_a));
d494 1
a494 1
kvm_getenvv2(kvm_t *kd, const struct kinfo_proc2 *kp, int nchr)
d496 1
a496 6
	struct miniproc p;

	if (ISALIVE(kd))
		return (kvm_arg_sysctl(kd, kp->p_pid, nchr, 1));
	KP2TOMINI(kp, &p);
	return (kvm_doargv(kd, &p, nchr, ps_str_e));
a524 10
}

ssize_t
kvm_uread(kvm_t *kd, const struct proc *p, u_long uva, char *buf,
    size_t len)
{
	struct miniproc mp;

	PTOMINI(p, &mp);
	return (kvm_ureadm(kd, &mp, uva, buf, len));
@


1.40
log
@Reimplement kvm_getproc2()'s support for reading crash dumps and
/dev/mem to be direct instead of going through kvm_getprocs(), as
that function is going to get more an more broken as we move stuff
from struct proc to struct process for rthreads.  To minimize the
code copying, put the common logic of filling in a kinfo_proc2
structure into a macro FILL_KPROC2() in <sys/sysctl.h> for use from
both the kernel and user-space.  This also hides the KERN_PROC
#define behind "#if defined(_KERNEL)||defined(_LIBKVM)", as it's
deprecated.

Positive feedback from millert and blambert; so committing to unblock
further rthreads work.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.39 2009/10/27 23:59:28 deraadt Exp $	*/
d306 1
a306 1
		if (KREAD(kd, (u_long)proc.p_pgrp, &pgrp)) {
d308 1
a308 1
			    proc.p_pgrp);
d319 1
a319 1
		if ((proc.p_flag & P_CONTROLT) && sess.s_ttyp != NULL) {
d340 1
a340 1
		if (sess.s_leader == p)
d359 1
a359 1
			if ((proc.p_flag & P_CONTROLT) == 0 ||
d364 1
@


1.39
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.38 2009/06/20 20:20:43 millert Exp $	*/
a136 2
#define	PTRTOINT64(foo)	((u_int64_t)(u_long)(foo))

a400 196
}

struct kinfo_proc2 *
kvm_getproc2(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
{
	int mib[6], st, nprocs;
	struct user user;
	size_t size;

	if ((ssize_t)esize < 0)
		return (NULL);

	if (kd->procbase2 != NULL) {
		free(kd->procbase2);
		/*
		 * Clear this pointer in case this call fails.  Otherwise,
		 * kvm_close() will free it again.
		 */
		kd->procbase2 = 0;
	}

	if (ISALIVE(kd)) {
		size = 0;
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC2;
		mib[2] = op;
		mib[3] = arg;
		mib[4] = esize;
		mib[5] = 0;
		st = sysctl(mib, 6, NULL, &size, NULL, 0);
		if (st == -1) {
			_kvm_syserr(kd, kd->program, "kvm_getproc2");
			return (NULL);
		}

		mib[5] = size / esize;
		kd->procbase2 = _kvm_malloc(kd, size);
		if (kd->procbase2 == 0)
			return (NULL);
		st = sysctl(mib, 6, kd->procbase2, &size, NULL, 0);
		if (st == -1) {
			_kvm_syserr(kd, kd->program, "kvm_getproc2");
			return (NULL);
		}
		nprocs = size / esize;
	} else {
		struct kinfo_proc2 kp2, *kp2p;
		struct kinfo_proc *kp;
		char *kp2c;
		int i;

		kp = kvm_getprocs(kd, op, arg, &nprocs);
		if (kp == NULL)
			return (NULL);

		kd->procbase2 = _kvm_malloc(kd, nprocs * esize);
		kp2c = (char *)kd->procbase2;
		kp2p = &kp2;
		for (i = 0; i < nprocs; i++, kp++) {
			memset(kp2p, 0, sizeof(kp2));
			kp2p->p_paddr = PTRTOINT64(kp->kp_eproc.e_paddr);

			kp2p->p_addr = PTRTOINT64(kp->kp_proc.p_addr);
			kp2p->p_fd = PTRTOINT64(kp->kp_proc.p_fd);
			kp2p->p_stats = PTRTOINT64(kp->kp_proc.p_stats);
			kp2p->p_limit = PTRTOINT64(kp->kp_eproc.e_limit);
			kp2p->p_vmspace = PTRTOINT64(kp->kp_proc.p_vmspace);
			kp2p->p_sigacts = PTRTOINT64(kp->kp_proc.p_sigacts);
			kp2p->p_sess = PTRTOINT64(kp->kp_eproc.e_sess);
			kp2p->p_tsess = 0;
			kp2p->p_ru = PTRTOINT64(kp->kp_proc.p_ru);

			kp2p->p_eflag = 0;
			kp2p->p_exitsig = kp->kp_proc.p_exitsig;
			kp2p->p_flag = kp->kp_proc.p_flag;

			kp2p->p_pid = kp->kp_proc.p_pid;

			kp2p->p_ppid = kp->kp_eproc.e_ppid;
#if 0
			kp2p->p_sid = kp->kp_eproc.e_sid;
#else
			kp2p->p_sid = -1; /* XXX */
#endif
			kp2p->p__pgid = kp->kp_eproc.e_pgid;

			kp2p->p_tpgid = -1;

			kp2p->p_uid = kp->kp_eproc.e_ucred.cr_uid;
			kp2p->p_ruid = kp->kp_eproc.e_pcred.p_ruid;
			kp2p->p_gid = kp->kp_eproc.e_ucred.cr_gid;
			kp2p->p_rgid = kp->kp_eproc.e_pcred.p_rgid;

			memcpy(kp2p->p_groups, kp->kp_eproc.e_ucred.cr_groups,
			    MIN(sizeof(kp2p->p_groups),
			    sizeof(kp->kp_eproc.e_ucred.cr_groups)));
			kp2p->p_ngroups = kp->kp_eproc.e_ucred.cr_ngroups;

			kp2p->p_jobc = kp->kp_eproc.e_jobc;
			kp2p->p_tdev = kp->kp_eproc.e_tdev;
			kp2p->p_tpgid = kp->kp_eproc.e_tpgid;
			kp2p->p_tsess = PTRTOINT64(kp->kp_eproc.e_tsess);

			kp2p->p_estcpu = kp->kp_proc.p_estcpu;
			kp2p->p_rtime_sec = kp->kp_proc.p_estcpu;
			kp2p->p_rtime_usec = kp->kp_proc.p_estcpu;
			kp2p->p_cpticks = kp->kp_proc.p_cpticks;
			kp2p->p_pctcpu = kp->kp_proc.p_pctcpu;
			kp2p->p_swtime = kp->kp_proc.p_swtime;
			kp2p->p_slptime = kp->kp_proc.p_slptime;
			kp2p->p_schedflags = 0;

			kp2p->p_uticks = kp->kp_proc.p_uticks;
			kp2p->p_sticks = kp->kp_proc.p_sticks;
			kp2p->p_iticks = kp->kp_proc.p_iticks;

			kp2p->p_tracep = PTRTOINT64(kp->kp_proc.p_tracep);
			kp2p->p_traceflag = kp->kp_proc.p_traceflag;

			kp2p->p_holdcnt = 1;

			kp2p->p_siglist = kp->kp_proc.p_siglist;
			kp2p->p_sigmask = kp->kp_proc.p_sigmask;
			kp2p->p_sigignore = kp->kp_proc.p_sigignore;
			kp2p->p_sigcatch = kp->kp_proc.p_sigcatch;

			kp2p->p_stat = kp->kp_proc.p_stat;
			kp2p->p_priority = kp->kp_proc.p_priority;
			kp2p->p_usrpri = kp->kp_proc.p_usrpri;
			kp2p->p_nice = kp->kp_proc.p_nice;

			kp2p->p_xstat = kp->kp_proc.p_xstat;
			kp2p->p_acflag = kp->kp_proc.p_acflag;

			strncpy(kp2p->p_comm, kp->kp_proc.p_comm,
			    MIN(sizeof(kp2p->p_comm), sizeof(kp->kp_proc.p_comm)));

			strncpy(kp2p->p_wmesg, kp->kp_eproc.e_wmesg,
			    sizeof(kp2p->p_wmesg));
			kp2p->p_wchan = PTRTOINT64(kp->kp_proc.p_wchan);

			strncpy(kp2p->p_login, kp->kp_eproc.e_login,
			    sizeof(kp2p->p_login));

			kp2p->p_vm_rssize = kp->kp_eproc.e_xrssize;
			kp2p->p_vm_tsize = kp->kp_eproc.e_vm.vm_tsize;
			kp2p->p_vm_dsize = kp->kp_eproc.e_vm.vm_dsize;
			kp2p->p_vm_ssize = kp->kp_eproc.e_vm.vm_ssize;

			kp2p->p_eflag = kp->kp_eproc.e_flag;

			if (P_ZOMBIE(&kp->kp_proc) || kp->kp_proc.p_addr == NULL ||
			    KREAD(kd, (u_long)kp->kp_proc.p_addr, &user)) {
				kp2p->p_uvalid = 0;
			} else {
				kp2p->p_uvalid = 1;

				kp2p->p_ustart_sec = user.u_stats.p_start.tv_sec;
				kp2p->p_ustart_usec = user.u_stats.p_start.tv_usec;

				kp2p->p_uutime_sec = user.u_stats.p_ru.ru_utime.tv_sec;
				kp2p->p_uutime_usec = user.u_stats.p_ru.ru_utime.tv_usec;
				kp2p->p_ustime_sec = user.u_stats.p_ru.ru_stime.tv_sec;
				kp2p->p_ustime_usec = user.u_stats.p_ru.ru_stime.tv_usec;

				kp2p->p_uru_maxrss = user.u_stats.p_ru.ru_maxrss;
				kp2p->p_uru_ixrss = user.u_stats.p_ru.ru_ixrss;
				kp2p->p_uru_idrss = user.u_stats.p_ru.ru_idrss;
				kp2p->p_uru_isrss = user.u_stats.p_ru.ru_isrss;
				kp2p->p_uru_minflt = user.u_stats.p_ru.ru_minflt;
				kp2p->p_uru_majflt = user.u_stats.p_ru.ru_majflt;
				kp2p->p_uru_nswap = user.u_stats.p_ru.ru_nswap;
				kp2p->p_uru_inblock = user.u_stats.p_ru.ru_inblock;
				kp2p->p_uru_oublock = user.u_stats.p_ru.ru_oublock;
				kp2p->p_uru_msgsnd = user.u_stats.p_ru.ru_msgsnd;
				kp2p->p_uru_msgrcv = user.u_stats.p_ru.ru_msgrcv;
				kp2p->p_uru_nsignals = user.u_stats.p_ru.ru_nsignals;
				kp2p->p_uru_nvcsw = user.u_stats.p_ru.ru_nvcsw;
				kp2p->p_uru_nivcsw = user.u_stats.p_ru.ru_nivcsw;

				kp2p->p_uctime_sec =
				    user.u_stats.p_cru.ru_utime.tv_sec +
				    user.u_stats.p_cru.ru_stime.tv_sec;
				kp2p->p_uctime_usec =
				    user.u_stats.p_cru.ru_utime.tv_usec +
				    user.u_stats.p_cru.ru_stime.tv_usec;
			}

			memcpy(kp2c, &kp2, esize);
			kp2c += esize;
		}

		free(kd->procbase);
	}
	*cnt = nprocs;
	return (kd->procbase2);
@


1.38
log
@Move KREAD define to kvm_private.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.37 2009/01/21 22:18:00 miod Exp $	*/
a63 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)kvm_proc.c	8.3 (Berkeley) 9/23/93";
#else
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.37 2009/01/21 22:18:00 miod Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.37
log
@All operation on live kernels uses sysctl interface, there is no reason to
access the swap area. Change kvm_open() to no longer require a swap area,
and to not consider failure to open() it as fatal. Post-mortem analysis
would need an image of the swap area at the time of the crash, anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.36 2008/06/26 05:42:05 ray Exp $	*/
d69 1
a69 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.36 2008/06/26 05:42:05 ray Exp $";
a145 3

#define KREAD(kd, addr, obj) \
	(kvm_read(kd, addr, (void *)(obj), sizeof(*obj)) != sizeof(*obj))
@


1.36
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.35 2007/10/10 15:53:51 art Exp $	*/
d69 1
a69 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.35 2007/10/10 15:53:51 art Exp $";
d234 2
a235 1
		if (_kvm_pread(kd, kd->swfd, (void *)kd->swapspc,
@


1.35
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.34 2007/06/18 21:51:15 pedro Exp $	*/
a17 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d69 1
a69 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.34 2007/06/18 21:51:15 pedro Exp $";
@


1.34
log
@Bring back Mickey's UVM anon change. Testing by thib@@, beck@@ and
ckuethe@@ for a while. Okay beck@@, "it is good timing" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.33 2007/04/14 11:06:43 espie Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.33 2007/04/14 11:06:43 espie Exp $";
a479 2
			kp2p->p_forw = PTRTOINT64(kp->kp_proc.p_forw);
			kp2p->p_back = PTRTOINT64(kp->kp_proc.p_back);
@


1.33
log
@hide struct process from userland, allow kvm_proc to see it.
okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.32 2007/04/12 22:14:15 tedu Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.32 2007/04/12 22:14:15 tedu Exp $";
d232 1
a232 1
	addr = (u_long)anon.u.an_page;
@


1.32
log
@move p_limit and p_cred into struct process
leave macros behind for now to keep the commit small
ok art beck miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.31 2006/11/29 12:32:57 miod Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.31 2006/11/29 12:32:57 miod Exp $";
d87 1
@


1.31
log
@Sync with struct proc change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.30 2006/07/13 22:51:24 deraadt Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.30 2006/07/13 22:51:24 deraadt Exp $";
d272 1
d282 5
a286 1
		if (KREAD(kd, (u_long)proc.p_cred, &eproc.e_pcred) == 0)
d486 1
a486 1
			kp2p->p_limit = PTRTOINT64(kp->kp_proc.p_limit);
@


1.30
log
@Back out the anon change.  Apparently it was tested by a few, but most of
us did not see it or get a chance to test it before it was commited. It
broke cvs, in the ami driver, making it not succeed at seeing it's devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.28 2006/03/31 03:59:40 deraadt Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.28 2006/03/31 03:59:40 deraadt Exp $";
d535 1
a535 1
			kp2p->p_holdcnt = kp->kp_proc.p_holdcnt;
@


1.29
log
@from netbsd: make anons dynamically allocated from pool.
this results in lesse kva waste due to static preallocation of those
for every phys page and also every swap page.
tested by beck krw miod
@
text
@d231 1
a231 1
	addr = (u_long)anon.an_page;
@


1.28
log
@careful cleanup following advice from lint.  be very very very careful
with sprinkling in size_t!
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.27 2005/10/12 07:24:28 otto Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.27 2005/10/12 07:24:28 otto Exp $";
d231 1
a231 1
	addr = (u_long)anon.u.an_page;
@


1.27
log
@Use queue macros instead of directly accessing fields. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.26 2004/06/24 21:06:47 millert Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.26 2004/06/24 21:06:47 millert Exp $";
d182 1
a182 1
		kd->swapspc = (char *)_kvm_malloc(kd, kd->nbpg);
d423 1
a423 1
	if (esize < 0)
d450 1
a450 1
		kd->procbase2 = (struct kinfo_proc2 *)_kvm_malloc(kd, size);
d639 1
a639 1
		kd->procbase = (struct kinfo_proc *)_kvm_malloc(kd, size);
d675 1
a675 1
		kd->procbase = (struct kinfo_proc *)_kvm_malloc(kd, size);
d735 1
a735 1
		kd->argv = (char **)_kvm_malloc(kd, kd->argc *
d747 1
a747 1
		kd->argspc = (char *)_kvm_malloc(kd, kd->nbpg);
d753 1
a753 1
		kd->argbuf = (char *)_kvm_malloc(kd, kd->nbpg);
@


1.26
log
@Back out part of last commit; we want to realloc + loop for argv too.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.25 2004/06/24 18:19:25 millert Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.25 2004/06/24 18:19:25 millert Exp $";
d276 1
a276 1
	for (; cnt < maxcnt && p != NULL; p = proc.p_list.le_next) {
@


1.25
log
@Allocate 8 pages for process argv, not one.  This should really be ARG_MAX
but sysctl_proc_args() needs changes to support that.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.24 2004/06/15 03:52:59 deraadt Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.24 2004/06/15 03:52:59 deraadt Exp $";
d925 1
a925 1
	if (ret && errno == ENOMEM && env) {
@


1.24
log
@knf; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.23 2004/06/14 03:46:46 millert Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.23 2004/06/14 03:46:46 millert Exp $";
d912 1
a912 1
	orglen = kd->nbpg;
d925 2
a926 2
	if (ret && errno == ENOMEM) {
		orglen += kd->nbpg;
@


1.23
log
@Zero p_schedflags in struct struct kinfo_proc2 for the non-sysctl case.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.22 2004/06/13 23:01:09 deraadt Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.22 2004/06/13 23:01:09 deraadt Exp $";
d173 1
a173 5
_kvm_ureadm(kd, p, va, cnt)
	kvm_t *kd;
	const struct miniproc *p;
	u_long va;
	u_long *cnt;
d175 2
a176 2
	u_long addr, head;
	u_long offset;
a178 1
	struct vm_anon *anonp, anon;
a179 1
	u_long slot;
d198 1
a198 1
		if (va >= vme.start && va < vme.end && 
d211 1
a211 1
		return NULL;
d215 1
a215 1
		return NULL;
d221 1
a221 1
		return NULL;
d225 1
a225 1
		return NULL;
d229 1
a229 1
		return NULL;
d234 1
a234 1
			return NULL;
d236 3
a238 3
		if (_kvm_pread(kd, kd->pmfd, (void *)kd->swapspc, (size_t)kd->nbpg, (off_t)pg.phys_addr) != kd->nbpg) {
			return NULL;
		}
d240 4
a243 3
		if (_kvm_pread(kd, kd->swfd, (void *)kd->swapspc, (size_t)kd->nbpg, (off_t)(anon.an_swslot * kd->nbpg)) != kd->nbpg) {
			return NULL;
		}
d253 1
a253 5
_kvm_uread(kd, p, va, cnt)
	kvm_t *kd;
	const struct proc *p;
	u_long va;
	u_long *cnt;
d266 2
a267 6
kvm_proclist(kd, what, arg, p, bp, maxcnt)
	kvm_t *kd;
	int what, arg;
	struct proc *p;
	struct kinfo_proc *bp;
	int maxcnt;
d269 1
a269 1
	int cnt = 0;
d271 1
a272 1
	struct session sess;
d274 1
a274 1
	struct proc proc;
d283 1
a283 1
			      &eproc.e_ucred);
d285 1
a285 2
		switch(what) {
			
d321 1
a321 1
				 proc.p_pgrp);
d328 2
a329 2
			_kvm_err(kd, kd->program, "can't read session at %x", 
				pgrp.pg_session);
d335 1
a335 1
					 "can't read tty at %x", sess.s_ttyp);
d343 2
a344 2
						 "can't read tpgrp at &x", 
						tty.t_pgrp);
d356 1
a356 1
			(void)kvm_read(kd, (u_long)proc.p_wmesg, 
a365 1

d372 2
a373 2
			if ((proc.p_flag & P_CONTROLT) == 0 || 
			     eproc.e_tdev != (dev_t)arg)
d390 2
a391 6
kvm_deadprocs(kd, what, arg, a_allproc, a_zombproc, maxcnt)
	kvm_t *kd;
	int what, arg;
	u_long a_allproc;
	u_long a_zombproc;
	int maxcnt;
d394 1
a395 1
	struct proc *p;
d417 1
a417 5
kvm_getproc2(kd, op, arg, esize, cnt)
	kvm_t *kd;
	int op, arg;
	size_t esize;
	int *cnt;
a418 1
	size_t size;
d421 1
d424 1
a424 1
		return NULL;
d446 1
a446 1
			return NULL;
d452 1
a452 1
			return NULL;
d456 1
a456 1
			return NULL;
d460 2
a462 2
		struct kinfo_proc *kp;
		struct kinfo_proc2 kp2, *kp2p;
d467 1
a467 1
			return NULL;
d510 2
a511 1
			    MIN(sizeof(kp2p->p_groups), sizeof(kp->kp_eproc.e_ucred.cr_groups)));
d553 2
a554 1
			strncpy(kp2p->p_wmesg, kp->kp_eproc.e_wmesg, sizeof(kp2p->p_wmesg));
d557 2
a558 1
			strncpy(kp2p->p_login, kp->kp_eproc.e_login, sizeof(kp2p->p_login));
d596 2
a597 1
				kp2p->p_uctime_sec = user.u_stats.p_cru.ru_utime.tv_sec +
d599 2
a600 1
				kp2p->p_uctime_usec = user.u_stats.p_cru.ru_utime.tv_usec +
d615 1
a615 4
kvm_getprocs(kd, op, arg, cnt)
	kvm_t *kd;
	int op, arg;
	int *cnt;
d617 1
a618 1
	int mib[4], st, nprocs;
d622 1
a622 1
		/* 
d649 2
a650 2
				"proc size mismatch (%d total, %d chunks)",
				size, sizeof(struct kinfo_proc));
d667 1
a667 1
				 "%s: no such symbol", p->n_name);
d680 1
a680 1
				      nl[2].n_value, nprocs);
d691 1
a691 2
_kvm_freeprocs(kd)
	kvm_t *kd;
d700 1
a700 4
_kvm_realloc(kd, p, n)
	kvm_t *kd;
	void *p;
	size_t n;
d711 1
a711 1
 * addr if the user-space base address of narg null-terminated contiguous 
d716 2
a717 6
kvm_argv(kd, p, addr, narg, maxcnt)
	kvm_t *kd;
	const struct miniproc *p;
	u_long addr;
	int narg;
	int maxcnt;
d719 1
a719 1
	char *np, *cp, *ep, *ap;
a721 1
	char **argv;
d735 2
a736 2
		kd->argv = (char **)_kvm_malloc(kd, kd->argc * 
						sizeof(*kd->argv));
d741 2
a742 2
		kd->argv = (char **)_kvm_realloc(kd, kd->argv, kd->argc * 
						sizeof(*kd->argv));
d763 1
d790 1
a790 1
							  kd->arglen);
d829 1
a829 4
ps_str_a(p, addr, n)
	struct ps_strings *p;
	u_long *addr;
	int *n;
d836 1
a836 4
ps_str_e(p, addr, n)
	struct ps_strings *p;
	u_long *addr;
	int *n;
d848 1
a848 3
proc_verify(kd, p)
	kvm_t *kd;
	const struct miniproc *p;
d856 1
a856 1
	if (kvm_read(kd, (u_long)p->p_paddr, &kernproc, sizeof(kernproc)) != 
d860 1
a860 1
		(kernproc.p_stat != SZOMB || p->p_stat == SZOMB));
d864 2
a865 5
kvm_doargv(kd, p, nchr, info)
	kvm_t *kd;
	const struct miniproc *p;
	int nchr;
	void (*info)(struct ps_strings *, u_long *, int *);
d867 3
a870 1
	u_long addr;
a871 2
	struct ps_strings arginfo;
	static struct ps_strings *ps;
d888 1
a888 1
	if (p->p_stat == SZOMB || 
d890 1
a890 1
		      sizeof(arginfo)) != sizeof(arginfo))
a907 1
	int mib[4];
d909 1
a909 1
	int ret;
d953 1
a953 4
kvm_getargv(kd, kp, nchr)
	kvm_t *kd;
	const struct kinfo_proc *kp;
	int nchr;
d964 1
a964 4
kvm_getenvv(kd, kp, nchr)
	kvm_t *kd;
	const struct kinfo_proc *kp;
	int nchr;
d975 1
a975 4
kvm_getargv2(kd, kp, nchr)  
	kvm_t *kd;
	const struct kinfo_proc2 *kp;
	int nchr;
d986 1
a986 4
kvm_getenvv2(kd, kp, nchr)  
	kvm_t *kd;
	const struct kinfo_proc2 *kp;
	int nchr;
d1000 2
a1001 6
kvm_ureadm(kd, p, uva, buf, len)
	kvm_t *kd;
	const struct miniproc *p;
	u_long uva;
	char *buf;
	size_t len;
d1003 1
a1003 1
	char *cp;
a1004 1
	cp = buf;
d1006 1
a1008 1
		u_long cnt;
d1025 2
a1026 6
kvm_uread(kd, p, uva, buf, len)
	kvm_t *kd;
	const struct proc *p;
	u_long uva; 
	char *buf;
	size_t len;
@


1.22
log
@temporary tree building workaround until millert shows  up
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.21 2004/01/07 03:47:46 millert Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.21 2004/01/07 03:47:46 millert Exp $";
d548 1
a548 3
#if 0
			kp2p->p_schedflags = kp->kp_proc.p_schedflags;
#endif
@


1.21
log
@Sync PTRTOINT64 w/ kernel version and remove some unused vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.20 2004/01/07 02:16:33 millert Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.20 2004/01/07 02:16:33 millert Exp $";
d548 1
d550 1
@


1.20
log
@Implement kvm_getproc2(), kvm_getargv2() and kvm_getenvv2() that use
the KERN_PROC2 sysctl.  Based on changes from NetBSD but uses our
own kvm_arg_sysctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.19 2003/11/17 20:25:18 millert Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.19 2003/11/17 20:25:18 millert Exp $";
d151 1
a151 1
#define	PTRTOINT64(foo)	((u_int64_t)(const register_t)(const void *)(foo))
a165 1
static char	**kvm_doargv2(kvm_t *, pid_t, int, int);
a950 1
	char **argv, *arg;
@


1.19
log
@Zero nlist array before using; fixes a bug in the error condition
when the corefile is not a valid executable.  otto@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.18 2003/08/06 21:08:05 millert Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.18 2003/08/06 21:08:05 millert Exp $";
d113 40
d158 5
a162 1
static char	**kvm_argv(kvm_t *, const struct proc *, u_long, int, int);
d164 1
a164 1
static char	**kvm_doargv(kvm_t *, const struct kinfo_proc *, int,
d166 1
d169 1
a169 1
static int	proc_verify(kvm_t *, u_long, const struct proc *);
d173 2
a174 2
char *
_kvm_uread(kd, p, va, cnt)
d176 1
a176 1
	const struct proc *p;
d258 13
d436 197
a734 4
#ifndef MAX
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#endif

d744 1
a744 1
	const struct proc *p;
d789 1
a789 1
	if (kvm_uread(kd, p, addr, (char *)kd->argv, cc) != cc)
d800 1
a800 1
			if (kvm_uread(kd, p, addr, kd->argbuf, kd->nbpg) !=
d884 1
a884 1
proc_verify(kd, kernp, p)
d886 1
a886 2
	u_long kernp;
	const struct proc *p;
d894 1
a894 1
	if (kvm_read(kd, kernp, &kernproc, sizeof(kernproc)) != 
d902 1
a902 1
kvm_doargv(kd, kp, nchr, info)
d904 1
a904 1
	const struct kinfo_proc *kp;
a907 1
	const struct proc *p = &kp->kp_proc;
d930 1
a930 1
	    kvm_uread(kd, p, (u_long)ps, (char *)&arginfo,
d941 1
a941 2
	if (ap != 0 && ISALIVE(kd) &&
	    !proc_verify(kd, (u_long)kp->kp_eproc.e_paddr, p))
d947 1
a947 1
kvm_arg_sysctl(kvm_t *kd, const struct kinfo_proc *kp, int nchr, int env)
d963 1
a963 1
	mib[2] = (int)kp->kp_proc.p_pid;
d1001 2
d1004 3
a1006 2
		return (kvm_arg_sysctl(kd, kp, nchr, 0));
	return (kvm_doargv(kd, kp, nchr, ps_str_a));
d1015 2
d1018 31
a1048 2
		return (kvm_arg_sysctl(kd, kp, nchr, 1));
	return (kvm_doargv(kd, kp, nchr, ps_str_e));
d1054 2
a1055 2
ssize_t
kvm_uread(kd, p, uva, buf, len)
d1057 1
a1057 1
	const struct proc *p;
d1066 1
a1066 1
		int cc;
d1070 1
a1070 1
		dp = _kvm_uread(kd, p, uva, &cnt);
d1075 1
a1075 1
		cc = MIN(cnt, len);
a1076 1

d1082 14
@


1.18
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.17 2003/06/02 20:18:41 millert Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.17 2003/06/02 20:18:41 millert Exp $";
d424 1
d428 1
a428 1
		nl[3].n_name = 0;
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.16 2002/06/20 17:16:56 art Exp $	*/
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.16 2002/06/20 17:16:56 art Exp $";
d557 1
a557 1
			cc = maxcnt - len;;
@


1.16
log
@Redo the logic in kvm_arg_sysctl for resizing the buffer.
 - actually use the value we've just reallocated.
 - Don't return success just because the error wasn't ENOMEM (doh!).
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.15 2002/06/08 22:32:36 art Exp $	*/
d55 1
a55 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d76 1
a76 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.15 2002/06/08 22:32:36 art Exp $";
@


1.15
log
@If possible get arg and env information with sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.14 2002/02/17 19:42:25 millert Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.14 2002/02/17 19:42:25 millert Exp $";
d715 12
a726 21
	for (;;) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC_ARGS;
		mib[2] = (int)kp->kp_proc.p_pid;
		mib[3] = env ? KERN_PROC_ENV : KERN_PROC_ARGV;

		len = orglen;
		ret = (sysctl(mib, 4, kd->argbuf, &len, NULL, 0) < 0);
		if (ret && errno == ENOMEM) {
			orglen += kd->nbpg;
			buf = _kvm_realloc(kd, kd->argbuf, orglen);
			if (buf == NULL)
				return (NULL);
			ret = 0;
		} else
			break;

		if (ret) {
			free(kd->argbuf);
			kd->argbuf = NULL;
			_kvm_syserr(kd, kd->program, "kvm_arg_sysctl");
d728 2
a729 1
		}
d732 6
@


1.14
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.13 2002/02/16 21:27:26 millert Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.13 2002/02/16 21:27:26 millert Exp $";
d701 48
d758 2
d769 2
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.12 2001/12/13 08:16:00 hugh Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.12 2001/12/13 08:16:00 hugh Exp $";
d120 1
a120 2
ssize_t		kvm_uread __P((kvm_t *, const struct proc *, u_long, char *,
		    size_t));
d122 1
a122 2
static char	**kvm_argv __P((kvm_t *, const struct proc *, u_long, int,
		    int));
d124 4
a127 4
static char	**kvm_doargv __P((kvm_t *, const struct kinfo_proc *, int,
		    void (*)(struct ps_strings *, u_long *, int *)));
static int	kvm_proclist __P((kvm_t *, int, int, struct proc *,
		    struct kinfo_proc *, int));
@


1.12
log
@Reorder new includes. art@@ says ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.11 2001/12/05 01:01:58 art Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.11 2001/12/05 01:01:58 art Exp $";
d125 1
a125 1
static int	kvm_deadprocs __P((kvm_t *, int, int, u_long, u_long, int));
d130 3
a132 3
static int	proc_verify __P((kvm_t *, u_long, const struct proc *));
static void	ps_str_a __P((struct ps_strings *, u_long *, int *));
static void	ps_str_e __P((struct ps_strings *, u_long *, int *));
@


1.11
log
@Must include machine/pmap.h and machine/vmparam.h here now
that uvm headers won't do that for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.10 2001/11/06 19:17:36 art Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.10 2001/11/06 19:17:36 art Exp $";
d106 1
a107 1
#include <machine/vmparam.h>
@


1.10
log
@Adapt to new uvm/ includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.9 2001/11/05 23:04:35 art Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.9 2001/11/05 23:04:35 art Exp $";
d106 2
@


1.9
log
@No need to pull in vm/vm_param.h in any of these files.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.8 2001/06/27 06:16:45 art Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.8 2001/06/27 06:16:45 art Exp $";
a102 2

#include <vm/vm.h>
@


1.8
log
@UVM is no longer an option
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.7 2001/05/18 09:08:38 art Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.7 2001/05/18 09:08:38 art Exp $";
a104 1
#include <vm/vm_param.h>
@


1.7
log
@Convert lseek/{read,write} pairs into pread and pwrite.
from my todo list, work by Jonathon Fletcher <jonathon.fletcher@@pobox.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.6 2000/06/18 17:59:54 niklas Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.6 2000/06/18 17:59:54 niklas Exp $";
a106 1
#ifdef UVM
a108 3
#else
#include <vm/swap_pager.h>
#endif
a120 4
#ifndef UVM
int		_kvm_readfromcore __P((kvm_t *, u_long, u_long));
int		_kvm_readfrompager __P((kvm_t *, struct vm_object *, u_long));
#endif
a144 1
#ifdef UVM
a148 4
#else
	struct vm_object vmo;
	int rv;
#endif
a166 1
#ifdef UVM
a169 5
#else
		if (va >= vme.start && va < vme.end && 
		    vme.object.vm_object != 0)
			break;
#endif
a175 1
#ifdef UVM
a212 31
 
#else
	/*
	 * We found the right object -- follow shadow links.
	 */
	offset = va - vme.start + vme.offset;
	addr = (u_long)vme.object.vm_object;

	while (1) {
		/* Try reading the page from core first. */
		if ((rv = _kvm_readfromcore(kd, addr, offset)))
			break;

		if (KREAD(kd, addr, &vmo))
			return (0);

		/* If there is a pager here, see if it has the page. */
		if (vmo.pager != 0 &&
		    (rv = _kvm_readfrompager(kd, &vmo, offset)))
			break;

		/* Move down the shadow chain. */
		addr = (u_long)vmo.shadow;
		if (addr == 0)
			return (0);
		offset += vmo.shadow_offset;
	}

	if (rv == -1)
		return (0);
#endif
a218 146

#ifndef UVM

#define	vm_page_hash(kd, object, offset) \
	(((u_long)object + (u_long)(offset / kd->nbpg)) & kd->vm_page_hash_mask)

int
_kvm_coreinit(kd)
	kvm_t *kd;
{
	struct nlist nlist[3];

	nlist[0].n_name = "_vm_page_buckets";
	nlist[1].n_name = "_vm_page_hash_mask";
	nlist[2].n_name = 0;
	if (kvm_nlist(kd, nlist) != 0)
		return (-1);

	if (KREAD(kd, nlist[0].n_value, &kd->vm_page_buckets) ||
	    KREAD(kd, nlist[1].n_value, &kd->vm_page_hash_mask))
		return (-1);

	return (0);
}

int
_kvm_readfromcore(kd, object, offset)
	kvm_t *kd;
	u_long object, offset;
{
	u_long addr;
	struct pglist bucket;
	struct vm_page mem;
	off_t seekpoint;

	if (kd->vm_page_buckets == 0 &&
	    _kvm_coreinit(kd))
		return (-1);

	addr = (u_long)&kd->vm_page_buckets[vm_page_hash(kd, object, offset)];
	if (KREAD(kd, addr, &bucket))
		return (-1);

	addr = (u_long)bucket.tqh_first;
	offset &= ~(kd->nbpg -1);
	while (1) {
		if (addr == 0)
			return (0);

		if (KREAD(kd, addr, &mem))
			return (-1);

		if ((u_long)mem.object == object &&
		    (u_long)mem.offset == offset)
			break;

		addr = (u_long)mem.hashq.tqe_next;
	}

	seekpoint = mem.phys_addr;

	if (_kvm_pread(kd, kd->pmfd, kd->swapspc, kd->nbpg, (off_t)seekpoint) != kd->nbpg) {
		return (-1);
	}

	return (1);
}

int
_kvm_readfrompager(kd, vmop, offset)
	kvm_t *kd;
	struct vm_object *vmop;
	u_long offset;
{
	u_long addr;
	struct pager_struct pager;
	struct swpager swap;
	int ix;
	struct swblock swb;
	off_t seekpoint;

	/* Read in the pager info and make sure it's a swap device. */
	addr = (u_long)vmop->pager;
	if (KREAD(kd, addr, &pager) || pager.pg_type != PG_SWAP)
		return (-1);

	/* Read in the swap_pager private data. */
	addr = (u_long)pager.pg_data;
	if (KREAD(kd, addr, &swap))
		return (-1);

	/*
	 * Calculate the paging offset, and make sure it's within the
	 * bounds of the pager.
	 */
	offset += vmop->paging_offset;
	ix = offset / dbtob(swap.sw_bsize);
#if 0
	if (swap.sw_blocks == 0 || ix >= swap.sw_nblocks)
		return (-1);
#else
	if (swap.sw_blocks == 0 || ix >= swap.sw_nblocks) {
		int i;
		printf("BUG BUG BUG BUG:\n");
		printf("object %x offset %x pgoffset %x pager %x swpager %x\n",
		    vmop, offset - vmop->paging_offset, vmop->paging_offset,
		    vmop->pager, pager.pg_data);
		printf("osize %x bsize %x blocks %x nblocks %x\n",
		    swap.sw_osize, swap.sw_bsize, swap.sw_blocks,
		    swap.sw_nblocks);
		for (ix = 0; ix < swap.sw_nblocks; ix++) {
			addr = (u_long)&swap.sw_blocks[ix];
			if (KREAD(kd, addr, &swb))
				return (0);
			printf("sw_blocks[%d]: block %x mask %x\n", ix,
			    swb.swb_block, swb.swb_mask);
		}
		return (-1);
	}
#endif

	/* Read in the swap records. */
	addr = (u_long)&swap.sw_blocks[ix];
	if (KREAD(kd, addr, &swb))
		return (-1);

	/* Calculate offset within pager. */
	offset %= dbtob(swap.sw_bsize);

	/* Check that the page is actually present. */
	if ((swb.swb_mask & (1 << (offset / kd->nbpg))) == 0)
		return (0);

	if (!ISALIVE(kd))
		return (-1);

	/* Calculate the physical address and read the page. */
	seekpoint = dbtob(swb.swb_block) + (offset & ~(kd->nbpg -1));

	if (_kvm_pread(kd, kd->swfd, kd->swapspc, kd->nbpg, (off_t)seekpoint) != kd->nbpg) {
		return (-1);
	}

	return (1);
}
#endif /* UVM */
@


1.6
log
@Mark kernel threads as system processes.  Make ps hide them by default,
show them with -k.  Do not try to show RSS based values for them as they
mess up column alignment.  vmstat -f now shows kernel threads separately
from rforks too.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.5 1999/06/22 12:54:45 art Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.5 1999/06/22 12:54:45 art Exp $";
d225 1
a225 5
		if (lseek(kd->pmfd, pg.phys_addr, SEEK_SET) < 0)
			return NULL;

		if (read(kd->pmfd, (void *)kd->swapspc, (size_t)kd->nbpg)
		    != kd->nbpg)
d227 1
d229 1
a229 5
		if (lseek(kd->swfd, (off_t)(anon.an_swslot * kd->nbpg),
			  SEEK_SET) < 0)
			return NULL;
		if (read(kd->swfd, (void *)kd->swapspc, (size_t)kd->nbpg)
		    != kd->nbpg)
d231 1
d331 1
a331 3
	if (lseek(kd->pmfd, seekpoint, 0) == -1)
		return (-1);
	if (read(kd->pmfd, kd->swapspc, kd->nbpg) != kd->nbpg)
d333 1
d409 1
a409 3
	if (lseek(kd->swfd, seekpoint, 0) == -1)
		return (-1);
	if (read(kd->swfd, kd->swapspc, kd->nbpg) != kd->nbpg)
d411 1
@


1.5
log
@UVM support + some cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_proc.c,v 1.4 1997/02/26 16:46:33 niklas Exp $	*/
d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.4 1997/02/26 16:46:33 niklas Exp $";
d467 5
@


1.4
log
@Switch alpha from libkvm.old to libkvm with code from NetBSD.
%x -> %lx format fixes from me.
@
text
@d1 37
a37 3
/*	$OpenBSD: kvm_proc.c,v 1.3 1996/10/23 16:43:08 deraadt Exp $ */
/*	$NetBSD: kvm_proc.c,v 1.16 1996/03/18 22:33:57 thorpej Exp $	*/

d80 1
a80 1
static char *rcsid = "$OpenBSD: kvm_proc.c,v 1.3 1996/10/23 16:43:08 deraadt Exp $";
d106 5
d112 1
d123 1
a123 1
	(kvm_read(kd, addr, (char *)(obj), sizeof(*obj)) != sizeof(*obj))
d125 1
d128 1
d150 2
a151 2
	register u_long addr, head;
	register u_long offset;
d153 6
d161 1
d180 5
d188 1
d195 46
d269 1
d277 2
d423 1
d437 1
a437 1
	register int cnt = 0;
d524 1
a524 1
		    (char *)&eproc.e_vm, sizeof(eproc.e_vm));
d562 2
a563 2
	register struct kinfo_proc *bp = kd->procbase;
	register int acnt, zcnt;
d700 8
a707 8
	register u_long addr;
	register int narg;
	register int maxcnt;
{
	register char *np, *cp, *ep, *ap;
	register u_long oaddr = -1;
	register int len, cc;
	register char **argv;
d769 3
a771 3
			register int off;
			register char **pp;
			register char *op = kd->argspc;
d850 1
a850 1
	if (kvm_read(kd, kernp, (char *)&kernproc, sizeof(kernproc)) != 
d864 2
a865 2
	register const struct proc *p = &kp->kp_proc;
	register char **ap;
d931 4
a934 4
	register const struct proc *p;
	register u_long uva;
	register char *buf;
	register size_t len;
d936 1
a936 1
	register char *cp;
d940 2
a941 2
		register int cc;
		register char *dp;
@


1.3
log
@use psstrings sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d46 1
a46 1
static char *rcsid = "$OpenBSD$";
d782 1
a782 1
	    kvm_uread(kd, p, ps, (char *)&arginfo,
d841 1
a841 1
			_kvm_err(kd, 0, "invalid address (%x)", uva);
@


1.2
log
@sync with 0430
@
text
@d764 13
d782 1
a782 1
	    kvm_uread(kd, p, USRSTACK - sizeof(arginfo), (char *)&arginfo,
@


1.1
log
@Initial revision
@
text
@d1 3
d43 1
d45 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
