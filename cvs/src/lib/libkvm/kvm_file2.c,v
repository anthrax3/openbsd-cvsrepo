head	1.52;
access;
symbols
	OPENBSD_6_1:1.52.0.4
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.49.0.2
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9;
locks; strict;
comment	@ * @;


1.52
date	2017.01.21.05.42.04;	author guenther;	state Exp;
branches;
next	1.51;
commitid	CHRb0fCqa8XxUAMH;

1.51
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.50;
commitid	W7ztnDZwvjCaeQTS;

1.50
date	2016.10.02.23.11.55;	author guenther;	state Exp;
branches;
next	1.49;
commitid	F8mRaOmEFbuy0fNX;

1.49
date	2016.05.04.01.28.42;	author zhuk;	state Exp;
branches;
next	1.48;
commitid	BjLmO3uaQB8dONLL;

1.48
date	2016.04.25.20.42.55;	author tedu;	state Exp;
branches;
next	1.47;
commitid	TB0dzL0QliW2ylCr;

1.47
date	2015.09.04.02.58.14;	author dlg;	state Exp;
branches;
next	1.46;
commitid	uyt9IruJmfmzApFD;

1.46
date	2015.08.28.04.38.47;	author guenther;	state Exp;
branches;
next	1.45;
commitid	plAZIJHa0HKzn8y4;

1.45
date	2015.03.28.23.50.55;	author bluhm;	state Exp;
branches;
next	1.44;
commitid	kVBWJiCghZrzYhp3;

1.44
date	2015.02.11.05.11.04;	author claudio;	state Exp;
branches;
next	1.43;
commitid	lpbpNPt95IjbOkKT;

1.43
date	2015.02.11.04.00.05;	author guenther;	state Exp;
branches;
next	1.42;
commitid	UMhfO4HVJxVHZvPj;

1.42
date	2015.02.11.03.03.08;	author guenther;	state Exp;
branches;
next	1.41;
commitid	F0jSFhaff58X5UIB;

1.41
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	0DYulI8hhujBHMcR;

1.40
date	2014.11.19.13.35.36;	author krw;	state Exp;
branches;
next	1.39;
commitid	mAzZN8w74KfuFeKi;

1.39
date	2014.11.03.17.20.46;	author bluhm;	state Exp;
branches;
next	1.38;
commitid	Jo3b0hfgHpuqTRST;

1.38
date	2014.10.25.03.18.58;	author lteo;	state Exp;
branches;
next	1.37;
commitid	A0rFNarRQqxSt93q;

1.37
date	2014.10.15.02.03.05;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	zOqt4CiDlaWcaRCM;

1.36
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.35;
commitid	vhXZZxMGVTWiFaF3;

1.35
date	2014.03.30.21.54.49;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2014.02.05.03.49.00;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.20.04.27.32;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2013.11.16.00.37.11;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2013.11.12.14.49.41;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.12.05.04.29;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.22.16.40.26;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.20.14.46.45;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2012.08.23.06.21.21;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2012.06.02.05.44.27;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2012.05.01.03.43.23;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2012.04.20.15.59.52;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.14.12.19.27;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2012.03.28.16.01.30;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2012.03.13.17.28.51;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2012.01.07.05.38.12;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.14.17.33.46;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.17.19.27.07;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.29.16.39.23;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.10.03.37.50;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.21.14.37.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.21.14.10.15;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.07.08.18.59.11;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.24.13.04.24;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.20.20.20.43;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.20.19.50.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.20.13.10.21;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.19.19.07.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.11.17.00.31;	author chl;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.07.21.35.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.07.10.44.00;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.07.03.09.34;	author millert;	state Exp;
branches;
next	;


desc
@@


1.52
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: kvm_file2.c,v 1.51 2016/11/07 00:26:33 guenther Exp $	*/

/*
 * Copyright (c) 2009 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Copyright (c) 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Extended file list interface for kvm.  pstat, fstat and netstat are
 * users of this code, so we've factored it out into a separate module.
 * Thus, we keep this grunge out of the other kvm applications (i.e.,
 * most other applications are interested only in open/close/read/nlist).
 */

#define __need_process

#include <sys/param.h>
#include <sys/uio.h>
#include <sys/ucred.h>
#include <sys/proc.h>
#define _KERNEL
#include <sys/file.h>
#include <sys/mount.h>
#undef _KERNEL
#include <sys/vnode.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/event.h>
#include <sys/eventvar.h>
#include <sys/un.h>
#include <sys/unpcb.h>
#include <sys/filedesc.h>
#include <sys/mbuf.h>
#include <sys/pipe.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/specdev.h>

#define _KERNEL
#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#undef _KERNEL

#include <nfs/nfsproto.h>
#include <nfs/rpcv2.h>
#include <nfs/nfs.h>
#include <nfs/nfsnode.h>

#include <msdosfs/bpb.h>
#include <msdosfs/denode.h>
#include <msdosfs/msdosfsmount.h>

#include <net/route.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/tcp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>

#ifdef INET6
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif

#include <nlist.h>
#include <kvm.h>
#include <db.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>

#include "kvm_private.h"
#include "kvm_file.h"

static struct kinfo_file *kvm_deadfile_byfile(kvm_t *, int, int,
    size_t, int *);
static struct kinfo_file *kvm_deadfile_byid(kvm_t *, int, int,
    size_t, int *);
static int fill_file(kvm_t *, struct kinfo_file *, struct file *, u_long,
    struct vnode *, struct process *, int, pid_t);
static int filestat(kvm_t *, struct kinfo_file *, struct vnode *);

LIST_HEAD(processlist, process);

struct kinfo_file *
kvm_getfiles(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
{
	int mib[6], rv;
	void *filebase;
	size_t size;

	if (ISALIVE(kd)) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_FILE;
		mib[2] = op;
		mib[3] = arg;
		mib[4] = esize;

		do {
			mib[5] = 0;

			/* find size and alloc buffer */
			rv = sysctl(mib, 6, NULL, &size, NULL, 0);
			if (rv == -1) {
				if (errno != ESRCH && kd->vmfd != -1)
					goto deadway;
				_kvm_syserr(kd, kd->program, "kvm_getfiles");
				return (NULL);
			}

			size += size / 8; /* add ~10% */

			filebase = _kvm_realloc(kd, kd->filebase, size);
			if (filebase == NULL)
				return (NULL);

			kd->filebase = filebase;

			/* get actual data */
			mib[5] = size / esize;
			rv = sysctl(mib, 6, kd->filebase, &size, NULL, 0);
			if (rv == -1 && errno != ENOMEM) {
				_kvm_syserr(kd, kd->program,
				    "kvm_getfiles");
				return (NULL);
			}
		} while (rv == -1);

		*cnt = size / esize;
		return (kd->filebase);
	} else {
		if (esize > sizeof(struct kinfo_file)) {
			_kvm_syserr(kd, kd->program,
			    "kvm_getfiles: unknown fields requested: libkvm out of date?");
			return (NULL);
		}
	    deadway:
		switch (op) {
		case KERN_FILE_BYFILE:
			return (kvm_deadfile_byfile(kd, op, arg, esize, cnt));
			break;
		case KERN_FILE_BYPID:
		case KERN_FILE_BYUID:
			return (kvm_deadfile_byid(kd, op, arg, esize, cnt));
			break;
		default:
			return (NULL);
		}
	}
}

static struct kinfo_file *
kvm_deadfile_byfile(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
{
	struct nlist nl[3], *p;
	size_t buflen;
	int n = 0;
	char *where;
	struct kinfo_file kf;
	struct file *fp, file;
	struct filelist filehead;
	int nfiles;

	nl[0].n_name = "_filehead";
	nl[1].n_name = "_nfiles";
	nl[2].n_name = 0;

	if (kvm_nlist(kd, nl) != 0) {
		for (p = nl; p->n_type != 0; ++p)
			;
		_kvm_err(kd, kd->program,
			 "%s: no such symbol", p->n_name);
		return (NULL);
	}
	if (KREAD(kd, nl[0].n_value, &filehead)) {
		_kvm_err(kd, kd->program, "can't read filehead");
		return (NULL);
	}
	if (KREAD(kd, nl[1].n_value, &nfiles)) {
		_kvm_err(kd, kd->program, "can't read nfiles");
		return (NULL);
	}
	where = _kvm_reallocarray(kd, kd->filebase, nfiles, esize);
	if (where == NULL)
		return (NULL);

	kd->filebase = (void *)where;
	buflen = nfiles * esize;

	for (fp = LIST_FIRST(&filehead);
	    fp != NULL && esize <= buflen;
	    fp = LIST_NEXT(&file, f_list)) {
		if (KREAD(kd, (u_long)fp, &file)) {
			_kvm_err(kd, kd->program, "can't read kfp");
			return (NULL);
		}
		if (file.f_count == 0)
			continue;
		if (arg != 0 && file.f_type != arg)
			continue;
		if (fill_file(kd, &kf, &file, (u_long)fp, NULL, NULL, 0, 0)
		    == -1)
			return (NULL);
		memcpy(where, &kf, esize);
		where += esize;
		buflen -= esize;
		n++;
	}
	if (n != nfiles) {
		_kvm_err(kd, kd->program, "inconsistent nfiles");
		return (NULL);
	}
	*cnt = n;
	return (kd->filebase);
}

static struct kinfo_file *
kvm_deadfile_byid(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
{
	size_t buflen;
	struct nlist nl[4], *np;
	int n = 0, matched = 0;
	char *where;
	struct kinfo_file kf;
	struct file *fp, file;
	struct filelist filehead;
	struct filedesc0 filed0;
#define filed	filed0.fd_fd
	struct processlist allprocess;
	struct process *pr, process;
	struct ucred ucred;
	char *filebuf = NULL;
	int i, nfiles;

	nl[0].n_name = "_filehead";
	nl[1].n_name = "_nfiles";
	nl[2].n_name = "_allprocess";
	nl[3].n_name = 0;

	if (kvm_nlist(kd, nl) != 0) {
		for (np = nl; np->n_type != 0; ++np)
			;
		_kvm_err(kd, kd->program,
			 "%s: no such symbol", np->n_name);
		return (NULL);
	}
	if (KREAD(kd, nl[0].n_value, &filehead)) {
		_kvm_err(kd, kd->program, "can't read filehead");
		return (NULL);
	}
	if (KREAD(kd, nl[1].n_value, &nfiles)) {
		_kvm_err(kd, kd->program, "can't read nfiles");
		return (NULL);
	}
	if (KREAD(kd, nl[2].n_value, &allprocess)) {
		_kvm_err(kd, kd->program, "can't read allprocess");
		return (NULL);
	}
	/* this may be more room than we need but counting is expensive */
	where = _kvm_reallocarray(kd, kd->filebase, nfiles + 10, esize);
	if (where == NULL)
		return (NULL);

	kd->filebase = (void *)where;
	buflen = (nfiles + 10) * esize;

	if (op != KERN_FILE_BYPID || arg <= 0)
		matched = 1;

	for (pr = LIST_FIRST(&allprocess);
	    pr != NULL;
	    pr = LIST_NEXT(&process, ps_list)) {
		if (KREAD(kd, (u_long)pr, &process)) {
			_kvm_err(kd, kd->program, "can't read process at %lx",
			    (u_long)pr);
			goto cleanup;
		}

		/* skip system, exiting, embryonic and undead processes */
		if (process.ps_flags & (PS_SYSTEM | PS_EMBRYO | PS_EXITING))
			continue;

		if (op == KERN_FILE_BYPID) {
			/* check if this is the pid we are looking for */
			if (arg > 0 && process.ps_pid != (pid_t)arg)
				continue;
			matched = 1;
		}

		if (KREAD(kd, (u_long)process.ps_ucred, &ucred)) {
			_kvm_err(kd, kd->program, "can't read ucred at %lx",
			    (u_long)process.ps_ucred);
			goto cleanup;
		}
		process.ps_ucred = &ucred;

		if (op == KERN_FILE_BYUID && arg >= 0 &&
		    process.ps_ucred->cr_uid != (uid_t)arg) {
			/* not the uid we are looking for */
			continue;
		}

		if (KREAD(kd, (u_long)process.ps_fd, &filed0)) {
			_kvm_err(kd, kd->program, "can't read filedesc at %lx",
			    (u_long)process.ps_fd);
			goto cleanup;
		}
		if ((char *)process.ps_fd + offsetof(struct filedesc0,fd_dfiles)
		    == (char *)filed.fd_ofiles) {
			filed.fd_ofiles = filed0.fd_dfiles;
			filed.fd_ofileflags = filed0.fd_dfileflags;
		} else {
			size_t fsize;
			char *tmp = reallocarray(filebuf,
			    filed.fd_nfiles, OFILESIZE);

			fsize = filed.fd_nfiles * OFILESIZE;
			if (tmp == NULL) {
				_kvm_syserr(kd, kd->program, "realloc ofiles");
				goto cleanup;
			}
			filebuf = tmp;
			if (kvm_read(kd, (u_long)filed.fd_ofiles, filebuf,
			    fsize) != fsize) {
				_kvm_err(kd, kd->program,
				    "can't read fd_ofiles");
				goto cleanup;
			}
			filed.fd_ofiles = (void *)filebuf;
			filed.fd_ofileflags = filebuf +
			    (filed.fd_nfiles * sizeof(struct file *));
		}
		process.ps_fd = &filed;

		if (process.ps_textvp) {
			if (buflen < esize)
				goto done;
			if (fill_file(kd, &kf, NULL, 0, process.ps_textvp,
			    &process, KERN_FILE_TEXT, process.ps_pid) == -1)
				goto cleanup;
			memcpy(where, &kf, esize);
			where += esize;
			buflen -= esize;
			n++;
		}
		if (filed.fd_cdir) {
			if (buflen < esize)
				goto done;
			if (fill_file(kd, &kf, NULL, 0, filed.fd_cdir,
			    &process, KERN_FILE_CDIR, process.ps_pid) == -1)
				goto cleanup;
			memcpy(where, &kf, esize);
			where += esize;
			buflen -= esize;
			n++;
		}
		if (filed.fd_rdir) {
			if (buflen < esize)
				goto done;
			if (fill_file(kd, &kf, NULL, 0, filed.fd_rdir,
			    &process, KERN_FILE_RDIR, process.ps_pid) == -1)
				goto cleanup;
			memcpy(where, &kf, esize);
			where += esize;
			buflen -= esize;
			n++;
		}
		if (process.ps_tracevp) {
			if (buflen < esize)
				goto done;
			if (fill_file(kd, &kf, NULL, 0, process.ps_tracevp,
			    &process, KERN_FILE_TRACE, process.ps_pid) == -1)
				goto cleanup;
			memcpy(where, &kf, esize);
			where += esize;
			buflen -= esize;
			n++;
		}

		if (filed.fd_nfiles < 0 ||
		    filed.fd_lastfile >= filed.fd_nfiles ||
		    filed.fd_freefile > filed.fd_lastfile + 1) {
			_kvm_err(kd, kd->program,
			    "filedesc corrupted at %lx for pid %d",
			    (u_long)process.ps_fd, process.ps_pid);
			goto cleanup;
		}

		for (i = 0; i < filed.fd_nfiles; i++) {
			if (buflen < esize)
				goto done;
			if ((fp = filed.fd_ofiles[i]) == NULL)
				continue;
			if (KREAD(kd, (u_long)fp, &file)) {
				_kvm_err(kd, kd->program, "can't read file");
				goto cleanup;
			}
			if (fill_file(kd, &kf, &file, (u_long)fp, NULL,
			    &process, i, process.ps_pid) == -1)
				goto cleanup;
			memcpy(where, &kf, esize);
			where += esize;
			buflen -= esize;
			n++;
		}
	}
	if (!matched) {
		errno = ESRCH;
		goto cleanup;
	}
done:
	*cnt = n;
	free(filebuf);
	return (kd->filebase);
cleanup:
	free(filebuf);
	return (NULL);
}

static int
fill_file(kvm_t *kd, struct kinfo_file *kf, struct file *fp, u_long fpaddr,
    struct vnode *vp, struct process *pr, int fd, pid_t pid)
{
	struct ucred f_cred;

	memset(kf, 0, sizeof(*kf));

	kf->fd_fd = fd;		/* might not really be an fd */

	if (fp != NULL) {
		/* Fill in f_cred */
		if (KREAD(kd, (u_long)fp->f_cred, &f_cred)) {
			_kvm_err(kd, kd->program, "can't read f_cred");
			return (-1);
		}

		kf->f_fileaddr = PTRTOINT64(fpaddr);
		kf->f_flag = fp->f_flag;
		kf->f_iflags = fp->f_iflags;
		kf->f_type = fp->f_type;
		kf->f_count = fp->f_count;
		kf->f_ucred = PTRTOINT64(fp->f_cred);
		kf->f_uid = f_cred.cr_uid;
		kf->f_gid = f_cred.cr_gid;
		kf->f_ops = PTRTOINT64(fp->f_ops);
		kf->f_offset = fp->f_offset;
		kf->f_data = PTRTOINT64(fp->f_data);
		kf->f_usecount = 0;

		kf->f_rxfer = fp->f_rxfer;
		kf->f_rwfer = fp->f_wxfer;
		kf->f_seek = fp->f_seek;
		kf->f_rbytes = fp->f_rbytes;
		kf->f_wbytes = fp->f_wbytes;
	} else if (vp != NULL) {
		/* fake it */
		kf->f_type = DTYPE_VNODE;
		kf->f_flag = FREAD;
		if (fd == KERN_FILE_TRACE)
			kf->f_flag |= FWRITE;
		kf->f_data = PTRTOINT64(vp);
	}

	/* information about the object associated with this file */
	switch (kf->f_type) {
	case DTYPE_VNODE: {
		struct vnode vbuf;

		if (KREAD(kd, (u_long)(fp ? fp->f_data : vp), &vbuf)) {
			_kvm_err(kd, kd->program, "can't read vnode");
			return (-1);
		}
		vp = &vbuf;

		kf->v_un = PTRTOINT64(vp->v_un.vu_socket);
		kf->v_type = vp->v_type;
		kf->v_tag = vp->v_tag;
		kf->v_flag = vp->v_flag;
		kf->v_data = PTRTOINT64(vp->v_data);
		kf->v_mount = PTRTOINT64(vp->v_mount);

		if (vp->v_mount != NULL) {
			struct mount mount;

			if (KREAD(kd, (u_long)vp->v_mount, &mount)) {
				_kvm_err(kd, kd->program, "can't read v_mount");
				return (-1);
			}

			strlcpy(kf->f_mntonname, mount.mnt_stat.f_mntonname,
			    sizeof(kf->f_mntonname));
		}

		/* Fill in va_fsid, va_fileid, va_mode, va_size, va_rdev */
		filestat(kd, kf, vp);
		break;
	    }

	case DTYPE_SOCKET: {
		struct socket sock;
		struct sosplice ssp;
		struct protosw protosw;
		struct domain domain;

		if (KREAD(kd, (u_long)fp->f_data, &sock)) {
			_kvm_err(kd, kd->program, "can't read socket");
			return (-1);
		}

		kf->so_type = sock.so_type;
		kf->so_state = sock.so_state;
		kf->so_pcb = PTRTOINT64(sock.so_pcb);
		if (KREAD(kd, (u_long)sock.so_proto, &protosw)) {
			_kvm_err(kd, kd->program, "can't read protosw");
			return (-1);
		}
		kf->so_protocol = protosw.pr_protocol;
		if (KREAD(kd, (u_long)protosw.pr_domain, &domain)) {
			_kvm_err(kd, kd->program, "can't read domain");
			return (-1);
		}
		kf->so_family = domain.dom_family;
		kf->so_rcv_cc = sock.so_rcv.sb_cc;
		kf->so_snd_cc = sock.so_snd.sb_cc;
		if (sock.so_sp) {
			if (KREAD(kd, (u_long)sock.so_sp, &ssp)) {
				_kvm_err(kd, kd->program, "can't read splice");
				return (-1);
			}
			if (ssp.ssp_socket) {
				kf->so_splice = PTRTOINT64(ssp.ssp_socket);
				kf->so_splicelen = ssp.ssp_len;
			} else if (ssp.ssp_soback) {
				kf->so_splicelen = -1;
			}
		}
		if (!sock.so_pcb)
			break;
		switch (kf->so_family) {
		case AF_INET: {
			struct inpcb inpcb;

			if (KREAD(kd, (u_long)sock.so_pcb, &inpcb)) {
				_kvm_err(kd, kd->program, "can't read inpcb");
				return (-1);
			}
			kf->inp_ppcb = PTRTOINT64(inpcb.inp_ppcb);
			kf->inp_lport = inpcb.inp_lport;
			kf->inp_laddru[0] = inpcb.inp_laddr.s_addr;
			kf->inp_fport = inpcb.inp_fport;
			kf->inp_faddru[0] = inpcb.inp_faddr.s_addr;
			kf->inp_rtableid = inpcb.inp_rtableid;
			if (sock.so_type == SOCK_RAW)
				kf->inp_proto = inpcb.inp_ip.ip_p;
			if (protosw.pr_protocol == IPPROTO_TCP) {
				struct tcpcb tcpcb;
				if (KREAD(kd, (u_long)inpcb.inp_ppcb, &tcpcb)) {
					_kvm_err(kd, kd->program,
					    "can't read tcpcb");
					return (-1);
				}
				kf->t_rcv_wnd = tcpcb.rcv_wnd;
				kf->t_snd_wnd = tcpcb.snd_wnd;
				kf->t_snd_cwnd = tcpcb.snd_cwnd;
				kf->t_state = tcpcb.t_state;
			}
			break;
		    }
		case AF_INET6: {
			struct inpcb inpcb;
#define s6_addr32 __u6_addr.__u6_addr32

			if (KREAD(kd, (u_long)sock.so_pcb, &inpcb)) {
				_kvm_err(kd, kd->program, "can't read inpcb");
				return (-1);
			}
			kf->inp_ppcb = PTRTOINT64(inpcb.inp_ppcb);
			kf->inp_lport = inpcb.inp_lport;
			kf->inp_laddru[0] = inpcb.inp_laddr6.s6_addr32[0];
			kf->inp_laddru[1] = inpcb.inp_laddr6.s6_addr32[1];
			kf->inp_laddru[2] = inpcb.inp_laddr6.s6_addr32[2];
			kf->inp_laddru[3] = inpcb.inp_laddr6.s6_addr32[3];
			kf->inp_fport = inpcb.inp_fport;
			kf->inp_faddru[0] = inpcb.inp_laddr6.s6_addr32[0];
			kf->inp_faddru[1] = inpcb.inp_faddr6.s6_addr32[1];
			kf->inp_faddru[2] = inpcb.inp_faddr6.s6_addr32[2];
			kf->inp_faddru[3] = inpcb.inp_faddr6.s6_addr32[3];
			kf->inp_rtableid = inpcb.inp_rtableid;
			if (sock.so_type == SOCK_RAW)
				kf->inp_proto = inpcb.inp_ipv6.ip6_nxt;
			if (protosw.pr_protocol == IPPROTO_TCP) {
				struct tcpcb tcpcb;
				if (KREAD(kd, (u_long)inpcb.inp_ppcb, &tcpcb)) {
					_kvm_err(kd, kd->program,
					    "can't read tcpcb");
					return (-1);
				}
				kf->t_rcv_wnd = tcpcb.rcv_wnd;
				kf->t_snd_wnd = tcpcb.snd_wnd;
				kf->t_snd_cwnd = tcpcb.snd_cwnd;
				kf->t_state = tcpcb.t_state;
			}
			break;
		    }
		case AF_UNIX: {
			struct unpcb unpcb;

			if (KREAD(kd, (u_long)sock.so_pcb, &unpcb)) {
				_kvm_err(kd, kd->program, "can't read unpcb");
				return (-1);
			}
			kf->f_msgcount	= unpcb.unp_msgcount;
			kf->unp_conn	= PTRTOINT64(unpcb.unp_conn);
			kf->unp_refs	= PTRTOINT64(
			    SLIST_FIRST(&unpcb.unp_refs));
			kf->unp_nextref	= PTRTOINT64(
			    SLIST_NEXT(&unpcb, unp_nextref));
			kf->v_un	= PTRTOINT64(unpcb.unp_vnode);
			if (unpcb.unp_addr != NULL) {
				struct mbuf mb;
				struct sockaddr_un un;

				if (KREAD(kd, (u_long)unpcb.unp_addr, &mb)) {
					_kvm_err(kd, kd->program,
					    "can't read sockaddr_un mbuf");
					return (-1);
				}
				if (KREAD(kd, (u_long)mb.m_data, &un)) {
					_kvm_err(kd, kd->program,
					    "can't read sockaddr_un");
					return (-1);
				}

				kf->unp_addr = PTRTOINT64(unpcb.unp_addr);
				memcpy(kf->unp_path, un.sun_path, un.sun_len
				    - offsetof(struct sockaddr_un,sun_path));
			}
 
			break;
		    }
		}
		break;
	    }

	case DTYPE_PIPE: {
		struct pipe pipe;

		if (KREAD(kd, (u_long)fp->f_data, &pipe)) {
			_kvm_err(kd, kd->program, "can't read pipe");
			return (-1);
		}
		kf->pipe_peer = PTRTOINT64(pipe.pipe_peer);
		kf->pipe_state = pipe.pipe_state;
		break;
	    }

	case DTYPE_KQUEUE: {
		struct kqueue kqi;

		if (KREAD(kd, (u_long)fp->f_data, &kqi)) {
			_kvm_err(kd, kd->program, "can't read kqi");
			return (-1);
		}
		kf->kq_count = kqi.kq_count;
		kf->kq_state = kqi.kq_state;
		break;
	    }
	}

	/* per-process information for KERN_FILE_BY[PU]ID */
	if (pr != NULL) {
		kf->p_pid = pid;
		kf->p_uid = pr->ps_ucred->cr_uid;
		kf->p_gid = pr->ps_ucred->cr_gid;
		kf->p_tid = -1;
		strlcpy(kf->p_comm, pr->ps_comm, sizeof(kf->p_comm));
		if (pr->ps_fd != NULL)
			kf->fd_ofileflags = pr->ps_fd->fd_ofileflags[fd];
	}

	return (0);
}

mode_t
_kvm_getftype(enum vtype v_type)
{
	mode_t ftype = 0;

	switch (v_type) {
	case VREG:
		ftype = S_IFREG;
		break;
	case VDIR:
		ftype = S_IFDIR;
		break;
	case VBLK:
		ftype = S_IFBLK;
		break;
	case VCHR:
		ftype = S_IFCHR;
		break;
	case VLNK:
		ftype = S_IFLNK;
		break;
	case VSOCK:
		ftype = S_IFSOCK;
		break;
	case VFIFO:
		ftype = S_IFIFO;
		break;
	case VNON:
	case VBAD:
		break;
	}

	return (ftype);
}

static int
ufs_filestat(kvm_t *kd, struct kinfo_file *kf, struct vnode *vp)
{
	struct inode inode;
	struct ufs1_dinode di1;

	if (KREAD(kd, (u_long)VTOI(vp), &inode)) {
		_kvm_err(kd, kd->program, "can't read inode at %p", VTOI(vp));
		return (-1);
	}

	if (KREAD(kd, (u_long)inode.i_din1, &di1)) {
		_kvm_err(kd, kd->program, "can't read dinode at %p",
		    inode.i_din1);
		return (-1);
	}

	inode.i_din1 = &di1;

	kf->va_fsid = inode.i_dev & 0xffff;
	kf->va_fileid = (long)inode.i_number;
	kf->va_mode = inode.i_ffs1_mode;
	kf->va_size = inode.i_ffs1_size;
	kf->va_rdev = inode.i_ffs1_rdev;
	kf->va_nlink = inode.i_ffs1_nlink;

	return (0);
}

static int
ext2fs_filestat(kvm_t *kd, struct kinfo_file *kf, struct vnode *vp)
{
	struct inode inode;
	struct ext2fs_dinode e2di;

	if (KREAD(kd, (u_long)VTOI(vp), &inode)) {
		_kvm_err(kd, kd->program, "can't read inode at %p", VTOI(vp));
		return (-1);
	}

	if (KREAD(kd, (u_long)inode.i_e2din, &e2di)) {
		_kvm_err(kd, kd->program, "can't read dinode at %p",
		    inode.i_e2din);
		return (-1);
	}

	inode.i_e2din = &e2di;

	kf->va_fsid = inode.i_dev & 0xffff;
	kf->va_fileid = (long)inode.i_number;
	kf->va_mode = inode.i_e2fs_mode;
	kf->va_size = inode.i_e2fs_size;
	kf->va_rdev = 0;	/* XXX */
	kf->va_nlink = inode.i_e2fs_nlink;

	return (0);
}

static int
msdos_filestat(kvm_t *kd, struct kinfo_file *kf, struct vnode *vp)
{
	struct denode de;
	struct msdosfsmount mp;

	if (KREAD(kd, (u_long)VTODE(vp), &de)) {
		_kvm_err(kd, kd->program, "can't read denode at %p", VTODE(vp));
		return (-1);
	}
	if (KREAD(kd, (u_long)de.de_pmp, &mp)) {
		_kvm_err(kd, kd->program, "can't read mount struct at %p",
		    de.de_pmp);
		return (-1);
	}

	kf->va_fsid = de.de_dev & 0xffff;
	kf->va_fileid = 0; /* XXX see msdosfs_vptofh() for more info */
	kf->va_mode = (mp.pm_mask & 0777) | _kvm_getftype(vp->v_type);
	kf->va_size = de.de_FileSize;
	kf->va_rdev = 0;  /* msdosfs doesn't support device files */
	kf->va_nlink = 1;

	return (0);
}

static int
nfs_filestat(kvm_t *kd, struct kinfo_file *kf, struct vnode *vp)
{
	struct nfsnode nfsnode;

	if (KREAD(kd, (u_long)VTONFS(vp), &nfsnode)) {
		_kvm_err(kd, kd->program, "can't read nfsnode at %p",
		    VTONFS(vp));
		return (-1);
	}
	kf->va_fsid = nfsnode.n_vattr.va_fsid;
	kf->va_fileid = nfsnode.n_vattr.va_fileid;
	kf->va_size = nfsnode.n_size;
	kf->va_rdev = nfsnode.n_vattr.va_rdev;
	kf->va_mode = (mode_t)nfsnode.n_vattr.va_mode | _kvm_getftype(vp->v_type);
	kf->va_nlink = nfsnode.n_vattr.va_nlink;

	return (0);
}

static int
spec_filestat(kvm_t *kd, struct kinfo_file *kf, struct vnode *vp)
{
	struct specinfo		specinfo;
	struct vnode		parent;

	if (KREAD(kd, (u_long)vp->v_specinfo, &specinfo)) {
		_kvm_err(kd, kd->program, "can't read specinfo at %p",
		     vp->v_specinfo);
		return (-1);
	}

	vp->v_specinfo = &specinfo;

	if (KREAD(kd, (u_long)vp->v_specparent, &parent)) {
		_kvm_err(kd, kd->program, "can't read parent vnode at %p",
		     vp->v_specparent);
		return (-1);
	}

	if (ufs_filestat(kd, kf, vp))
		return (-1);

	return (0);
}

static int
filestat(kvm_t *kd, struct kinfo_file *kf, struct vnode *vp)
{
	int ret = 0;

	if (vp->v_type != VNON && vp->v_type != VBAD) {
		switch (vp->v_tag) {
		case VT_UFS:
		case VT_MFS:
			ret = ufs_filestat(kd, kf, vp);
			break;
		case VT_NFS:
			ret = nfs_filestat(kd, kf, vp);
			break;
		case VT_EXT2FS:
			ret = ext2fs_filestat(kd, kf, vp);
			break;
		case VT_ISOFS:
			ret = _kvm_stat_cd9660(kd, kf, vp);
			break;
		case VT_MSDOSFS:
			ret = msdos_filestat(kd, kf, vp);
			break;
		case VT_UDF:
			ret = _kvm_stat_udf(kd, kf, vp);
			break;
		case VT_NTFS:
			ret = _kvm_stat_ntfs(kd, kf, vp);
			break;
		case VT_NON:
			if (vp->v_flag & VCLONE)
				ret = spec_filestat(kd, kf, vp);
			break;
		default:
			ret = -1;
			break;
		}
	}
	return (ret);
}
@


1.51
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.50 2016/10/02 23:11:55 guenther Exp $	*/
a275 1
	struct proc proc;
a328 9
		if (process.ps_mainproc == NULL)
			continue;
		/* XXX only needed for p_comm now */
		if (KREAD(kd, (u_long)process.ps_mainproc, &proc)) {
			_kvm_err(kd, kd->program, "can't read proc at %lx",
			    (u_long)process.ps_mainproc);
			goto cleanup;
		}

a340 2
		process.ps_mainproc = &proc;
		proc.p_p = &process;
d722 1
a722 2
		strlcpy(kf->p_comm, pr->ps_mainproc->p_comm,
		    sizeof(kf->p_comm));
@


1.50
log
@Add va_nlink information to struct kinfo_file (so bump the shlib minor)

from Sebastien Marie
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.49 2016/05/04 01:28:42 zhuk Exp $	*/
d332 1
d341 1
a341 1
			if (arg > 0 && proc.p_pid != (pid_t)arg)
d397 1
a397 1
			    &process, KERN_FILE_TEXT, proc.p_pid) == -1)
d408 1
a408 1
			    &process, KERN_FILE_CDIR, proc.p_pid) == -1)
d419 1
a419 1
			    &process, KERN_FILE_RDIR, proc.p_pid) == -1)
d430 1
a430 1
			    &process, KERN_FILE_TRACE, proc.p_pid) == -1)
d443 1
a443 1
			    (u_long)process.ps_fd, proc.p_pid);
d457 1
a457 1
			    &process, i, proc.p_pid) == -1)
@


1.49
log
@Make KERN_FILE_BYPID return ESRCH when PID not found, both in sysctl and
offline paths. More polishing to come.

Input and okay bluhm@@ & kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.48 2016/04/25 20:42:55 tedu Exp $	*/
d801 1
d830 1
d856 1
d876 1
@


1.48
log
@no more systrace
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.47 2015/09/04 02:58:14 dlg Exp $	*/
d151 1
a151 1
				if (kd->vmfd != -1)
d268 1
a268 1
	int n = 0;
d314 3
d338 3
a340 3
		if (op == KERN_FILE_BYPID && arg > 0 &&
		    proc.p_pid != (pid_t)arg) {
				/* not the pid we are looking for */
d342 1
d463 4
@


1.47
log
@fix a race when fetching files from the kernel. the number of files
might have increased between when we got the number of files and
when we requested that number of files.

now we allocate another 10ish percent on top of what the kernel
says we need, and retry if that still isnt enough.

while here use realloc instead of constantly going through free/malloc
sequences.

with input from claudio@@ deraadt@@
ok millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.46 2015/08/28 04:38:47 guenther Exp $	*/
a63 1
#include <dev/systrace.h>
a714 10
		break;
	    }
	case DTYPE_SYSTRACE: {
		struct fsystrace f;

		if (KREAD(kd, (u_long)fp->f_data, &f)) {
			_kvm_err(kd, kd->program, "can't read fsystrace");
			return (-1);
		}
		kf->str_npolicies = f.npolicies;
@


1.46
log
@Rework the UNIX domain socket garbage collector, including ideas from
{Free,Net}BSD
 - when a socket is closed with fds in its input, defer closing them to
   a task to avoid recursing.  This eliminates the complicated extra
   reference taking which had a 37 line(!) comment explanation
 - move flags, counts, and links only needed for this from struct file to
   struct unpcb
 - document the flow of the mark/sweep collector

much help from claudio@@ who made me explain the GC to him until we trusted it
ok claudio@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.45 2015/03/28 23:50:55 bluhm Exp $	*/
d117 1
d136 1
a138 9
	if (kd->filebase != NULL) {
		free(kd->filebase);
		/*
		 * Clear this pointer in case this call fails.  Otherwise,
		 * kvm_close() will free it again.
		 */
		kd->filebase = 0;
	}

a144 1
		mib[5] = 0;
d146 29
a174 11
		/* find size and alloc buffer */
		rv = sysctl(mib, 6, NULL, &size, NULL, 0);
		if (rv == -1) {
			if (kd->vmfd != -1)
				goto deadway;
			_kvm_syserr(kd, kd->program, "kvm_getfiles");
			return (NULL);
		}
		kd->filebase = _kvm_malloc(kd, size);
		if (kd->filebase == NULL)
			return (NULL);
a175 7
		/* get actual data */
		mib[5] = size / esize;
		rv = sysctl(mib, 6, kd->filebase, &size, NULL, 0);
		if (rv == -1) {
			_kvm_syserr(kd, kd->program, "kvm_getfiles");
			return (NULL);
		}
d230 4
a233 1
	where = _kvm_reallocarray(kd, NULL, nfiles, esize);
a234 2
	if (kd->filebase == NULL)
		return (NULL);
d308 4
a311 1
	where = _kvm_reallocarray(kd, NULL, nfiles + 10, esize);
a312 2
	if (kd->filebase == NULL)
		return (NULL);
@


1.45
log
@Replace the hand-crafted list of datagram unix domain sockets with
a SLIST.
OK mpi@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.44 2015/02/11 05:11:04 claudio Exp $	*/
a486 1
		kf->f_msgcount = fp->f_msgcount;
d657 1
@


1.44
log
@Extend struct kinfo_file a bit for netstat (sync with the kernel).
Bump minor number because of this.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.43 2015/02/11 04:00:05 guenther Exp $	*/
d659 4
a662 2
			kf->unp_refs	= PTRTOINT64(unpcb.unp_refs);
			kf->unp_nextref	= PTRTOINT64(unpcb.unp_nextref);
@


1.43
log
@Prefer arg != 0 over arg for non-boolean.  nitted kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.42 2015/02/11 03:03:08 guenther Exp $	*/
d100 3
d599 14
d635 14
@


1.42
log
@sysctl({CTL_KERN, KERN_FILE, KERN_FILE_BYFILE}) previously required
the extra argument to be zero; instead, make it filter on the file
type (DTYPE_*) when non-zero to make claudio's netstat work easier.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.41 2015/01/16 16:48:51 deraadt Exp $	*/
d239 1
a239 1
		if (arg && file.f_type != arg)
@


1.41
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.40 2014/11/19 13:35:36 krw Exp $	*/
a180 5
			if (arg != 0) {
				_kvm_err(kd, kd->program,
				    "%d: invalid argument", arg);
				return (NULL);
			}
d237 4
@


1.40
log
@Nuke yet more obvious #include duplications.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.39 2014/11/03 17:20:46 bluhm Exp $	*/
d113 1
@


1.39
log
@Put the socket splicing fields into a seperate struct sosplice that
gets only allocated when needed.  This way struct socket shrinks
from 472 to 392 bytes on amd64.  When splicing gets active, another
88 bytes are allocated for struct sosplice.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.38 2014/10/25 03:18:58 lteo Exp $	*/
a110 1
#include <stddef.h>
@


1.38
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.37 2014/10/15 02:03:05 deraadt Exp $	*/
d545 1
d569 12
a580 5
		if (sock.so_splice) {
			kf->so_splice = PTRTOINT64(sock.so_splice);
			kf->so_splicelen = sock.so_splicelen;
		} else if (sock.so_spliceback)
			kf->so_splicelen = -1;
@


1.37
log
@Apply reallocarray() idiom.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.36 2014/07/04 05:58:31 guenther Exp $	*/
a97 1
#include <netinet/in_systm.h>
@


1.36
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.35 2014/03/30 21:54:49 guenther Exp $	*/
d230 1
a230 2
	buflen = nfiles * esize;
	where = _kvm_malloc(kd, buflen);
d234 1
d303 1
a303 2
	buflen = (nfiles + 10) * esize;
	where = _kvm_malloc(kd, buflen);
d307 1
d361 3
a363 2
			size_t fsize = filed.fd_nfiles * OFILESIZE;
			char *tmp = realloc(filebuf, fsize);
d365 1
@


1.35
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.34 2014/02/05 03:49:00 guenther Exp $	*/
d124 1
a124 1
    struct vnode *, struct proc *, int, pid_t);
d318 4
a329 5
		/* skip system, exiting, embryonic and undead processes */
		if (proc.p_flag & P_SYSTEM || process.ps_flags & PS_EXITING ||
		    proc.p_stat == SIDL || proc.p_stat == SZOMB)
			continue;

d346 1
a346 1
		    proc.p_ucred->cr_uid != (uid_t)arg) {
d351 1
a351 1
		if (KREAD(kd, (u_long)proc.p_fd, &filed0)) {
d353 1
a353 1
			    (u_long)proc.p_fd);
d356 1
a356 1
		if ((char *)proc.p_fd + offsetof(struct filedesc0, fd_dfiles)
d379 1
a379 1
		proc.p_fd = &filed;
d385 1
a385 1
			    &proc, KERN_FILE_TEXT, proc.p_pid) == -1)
d395 2
a396 2
			if (fill_file(kd, &kf, NULL, 0, filed.fd_cdir, &proc,
			    KERN_FILE_CDIR, proc.p_pid) == -1)
d406 2
a407 2
			if (fill_file(kd, &kf, NULL, 0, filed.fd_rdir, &proc,
			    KERN_FILE_RDIR, proc.p_pid) == -1)
d418 1
a418 1
			    &proc, KERN_FILE_TRACE, proc.p_pid) == -1)
d431 1
a431 1
			    (u_long)proc.p_fd, proc.p_pid);
d445 1
a445 1
			    &proc, i, proc.p_pid) == -1)
d463 2
a464 2
fill_file(kvm_t *kd, struct kinfo_file *kf, struct file *fp, u_long fpaddr, struct vnode *vp,
    struct proc *p, int fd, pid_t pid)
d685 1
a685 1
	if (p != NULL) {
d687 7
a693 6
		kf->p_uid = p->p_ucred->cr_uid;
		kf->p_gid = p->p_ucred->cr_gid;
		kf->p_tid = p->p_pid + THREAD_PID_OFFSET;
		strlcpy(kf->p_comm, p->p_comm, sizeof(kf->p_comm));
		if (p->p_fd != NULL)
			kf->fd_ofileflags = p->p_fd->fd_ofileflags[fd];
@


1.34
log
@More crash dump parsing fixes: correct paddr in process info and pids
in file info.  Drop some unnecessary casts and unused variables too.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.33 2014/01/20 21:19:28 guenther Exp $	*/
a273 1
	struct pcred pcred;
d337 1
a337 6
		if (KREAD(kd, (u_long)process.ps_cred, &pcred)) {
			_kvm_err(kd, kd->program, "can't read pcred at %lx",
			    (u_long)process.ps_cred);
			goto cleanup;
		}
		if (KREAD(kd, (u_long)pcred.pc_ucred, &ucred)) {
d339 1
a339 1
			    (u_long)pcred.pc_ucred);
d344 1
a344 2
		process.ps_cred = &pcred;
		pcred.pc_ucred = &ucred;
@


1.33
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.32 2014/01/20 04:27:32 guenther Exp $	*/
d172 1
a172 1
		return ((struct kinfo_file *)kd->filebase);
d256 1
a256 1
	return ((struct kinfo_file *)kd->filebase);
d272 1
a272 1
	struct proc proc, proc2;
a277 1
	pid_t pid;
d393 1
a393 1
			    &proc, KERN_FILE_TEXT, pid) == -1)
d404 1
a404 1
			    KERN_FILE_CDIR, pid) == -1)
d415 1
a415 1
			    KERN_FILE_RDIR, pid) == -1)
d426 1
a426 1
			    &proc, KERN_FILE_TRACE, pid) == -1)
d453 1
a453 1
			    &proc, i, pid) == -1)
d464 1
a464 1
	return ((struct kinfo_file *)kd->filebase);
@


1.32
log
@p_textvp moved from struct proc to struct process
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.31 2013/11/16 00:37:11 guenther Exp $	*/
d127 1
a127 1
LIST_HEAD(proclist, proc);
d271 3
a273 3
	struct proclist allproc;
	struct proc *p, proc, proc2;
	struct process process;
d282 1
a282 1
	nl[2].n_name = "_allproc";
d300 2
a301 2
	if (KREAD(kd, nl[2].n_value, &allproc)) {
		_kvm_err(kd, kd->program, "can't read allproc");
d311 12
a322 4
	for (p = LIST_FIRST(&allproc);
	    p != NULL;
	    p = LIST_NEXT(&proc, p_list)) {
		if (KREAD(kd, (u_long)p, &proc)) {
d324 1
a324 1
			    (u_long)p);
d328 2
a329 2
		/* skip system, embryonic and undead processes */
		if ((proc.p_flag & P_SYSTEM) || (proc.p_flag & P_THREAD) ||
d332 3
a334 2
		if (op == KERN_FILE_BYPID) {
			if (arg > 0 && proc.p_pid != (pid_t)arg) {
a336 29
			}
		} else /* if (op == KERN_FILE_BYUID) */ {
			if (arg >= 0 && proc.p_ucred->cr_uid != (uid_t)arg) {
				/* not the uid we are looking for */
				continue;
			}
		}

		if (proc.p_fd == NULL || proc.p_p == NULL)
			continue;

		if (KREAD(kd, (u_long)proc.p_p, &process)) {
			_kvm_err(kd, kd->program, "can't read process at %lx",
			    (u_long)proc.p_p);
			goto cleanup;
		}
		if (process.ps_flags & PS_EXITING)
			continue;
		proc.p_p = &process;
		if ((proc.p_flag & P_THREAD) == 0)
			pid = proc.p_pid;
		else {
			if (KREAD(kd, (u_long)process.ps_mainproc, &proc2)) {
				_kvm_err(kd, kd->program,
				    "can't read proc at %lx",
				    (u_long)process.ps_mainproc);
				goto cleanup;
			}
			pid = proc2.p_pid;
d349 2
d353 6
@


1.31
log
@Prep for hidden visibility: move the vnode/file related function
declarations, including _kvm_getftype(), into a new header, kvm_file.h,
so that we don't have to pull <sys/vnode.h> into all the .c files.  No
more extern function declaration in .c files.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.30 2013/11/12 14:49:41 guenther Exp $	*/
d402 1
a402 1
		if (proc.p_textvp) {
d405 2
a406 2
			if (fill_file(kd, &kf, NULL, 0, proc.p_textvp, &proc,
			    KERN_FILE_TEXT, pid) == -1)
@


1.30
log
@Apply format __attribute__ to _kvm_err() and fix the errors that it detects.
Treat failure to KREAD teh pcredd or ucreds to be errors insteading of
continuing with bogus data.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.29 2013/11/12 05:04:29 deraadt Exp $	*/
d117 1
a125 2

mode_t	_kvm_getftype(enum vtype v_type);
@


1.29
log
@a missing prototypes
and don't act like an unknown vnode type is "ok"
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.28 2013/10/22 16:40:26 guenther Exp $	*/
d185 1
a185 1
				    "%s: invalid argument");
d316 2
a317 1
			_kvm_err(kd, kd->program, "can't read proc at %x", p);
d341 2
a342 2
			_kvm_err(kd, kd->program, "can't read process at %x",
			    proc.p_p);
d353 2
a354 2
				    "can't read proc at %x",
				    process.ps_mainproc);
d360 10
a369 2
		if (KREAD(kd, (u_long)process.ps_cred, &pcred) == 0)
			KREAD(kd, (u_long)pcred.pc_ucred, &ucred);
d374 2
a375 2
			_kvm_err(kd, kd->program, "can't read filedesc at %x",
			    proc.p_fd);
d452 2
a453 2
			    "filedesc corrupted at %x for pid %d",
			    proc.p_fd, proc.p_pid);
@


1.28
log
@- add UNIX-domain socket info to struct kinfo_file2
- convert netstat from kvm_getfiles() to kvm_getfile2() using that
- delete kvm_getfiles() and KERN_FILE as no longer used (bump libkvm's major)
- rename kvm_getfile2() to kvm_getfiles(), kinfo_file2 to kinfo_file
  and KERN_FILE2 to KERN_FILE.

ok deraadt@@, millert@@
ports scan sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.27 2013/03/20 14:46:45 deraadt Exp $	*/
d126 2
d904 3
@


1.27
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.26 2012/08/23 06:21:21 deraadt Exp $	*/
d73 1
d76 1
d110 1
d118 1
a118 1
static struct kinfo_file2 *kvm_deadfile2_byfile(kvm_t *, int, int,
d120 1
a120 1
static struct kinfo_file2 *kvm_deadfile2_byid(kvm_t *, int, int,
d122 1
a122 1
static int fill_file2(kvm_t *, struct kinfo_file2 *, struct file *, u_long,
d124 1
a124 1
static int filestat(kvm_t *, struct kinfo_file2 *, struct vnode *);
d128 2
a129 2
struct kinfo_file2 *
kvm_getfile2(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
d145 1
a145 1
		mib[1] = KERN_FILE2;
d156 1
a156 1
			_kvm_syserr(kd, kd->program, "kvm_getfile2");
d167 1
a167 1
			_kvm_syserr(kd, kd->program, "kvm_getfile2");
d171 1
a171 1
		return ((struct kinfo_file2 *)kd->filebase);
d173 1
a173 1
		if (esize > sizeof(struct kinfo_file2)) {
d175 1
a175 1
			    "kvm_getfile2: unknown fields requested: libkvm out of date?");
d186 1
a186 1
			return (kvm_deadfile2_byfile(kd, op, arg, esize, cnt));
d190 1
a190 1
			return (kvm_deadfile2_byid(kd, op, arg, esize, cnt));
d198 2
a199 2
static struct kinfo_file2 *
kvm_deadfile2_byfile(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
d205 1
a205 1
	struct kinfo_file2 kf;
d242 1
a242 1
		if (fill_file2(kd, &kf, &file, (u_long)fp, NULL, NULL, 0, 0)
d255 1
a255 1
	return ((struct kinfo_file2 *)kd->filebase);
d258 2
a259 2
static struct kinfo_file2 *
kvm_deadfile2_byid(kvm_t *kd, int op, int arg, size_t esize, int *cnt)
d265 1
a265 1
	struct kinfo_file2 kf;
d395 1
a395 1
			if (fill_file2(kd, &kf, NULL, 0, proc.p_textvp, &proc,
d406 1
a406 1
			if (fill_file2(kd, &kf, NULL, 0, filed.fd_cdir, &proc,
d417 1
a417 1
			if (fill_file2(kd, &kf, NULL, 0, filed.fd_rdir, &proc,
d428 1
a428 1
			if (fill_file2(kd, &kf, NULL, 0, process.ps_tracevp,
d455 1
a455 1
			if (fill_file2(kd, &kf, &file, (u_long)fp, NULL,
d467 1
a467 1
	return ((struct kinfo_file2 *)kd->filebase);
d474 1
a474 1
fill_file2(kvm_t *kd, struct kinfo_file2 *kf, struct file *fp, u_long fpaddr, struct vnode *vp,
d576 2
d630 24
a653 1
			kf->unp_conn = PTRTOINT64(unpcb.unp_conn);
d745 1
a745 1
ufs_filestat(kvm_t *kd, struct kinfo_file2 *kf, struct vnode *vp)
d773 1
a773 1
ext2fs_filestat(kvm_t *kd, struct kinfo_file2 *kf, struct vnode *vp)
d801 1
a801 1
msdos_filestat(kvm_t *kd, struct kinfo_file2 *kf, struct vnode *vp)
d826 1
a826 1
nfs_filestat(kvm_t *kd, struct kinfo_file2 *kf, struct vnode *vp)
d845 1
a845 1
spec_filestat(kvm_t *kd, struct kinfo_file2 *kf, struct vnode *vp)
d871 1
a871 1
filestat(kvm_t *kd, struct kinfo_file2 *kf, struct vnode *vp)
@


1.26
log
@knowledge of nnpfs can be removed
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.25 2012/06/02 05:44:27 guenther Exp $	*/
d712 1
a712 1
	
@


1.25
log
@Committed the wrong version (an earlier try) of the KERN_FILE2 vs
rthreads fix.  Update to the correct one.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.24 2012/05/01 03:43:23 guenther Exp $	*/
a89 3
#include <nnpfs/nnpfs_config.h>
#include <nnpfs/nnpfs_node.h>

a816 19
nnpfs_filestat(kvm_t *kd, struct kinfo_file2 *kf, struct vnode *vp)
{
	struct nnpfs_node nnpfs_node;

	if (KREAD(kd, (u_long)VNODE_TO_XNODE(vp), &nnpfs_node)) {
		_kvm_err(kd, kd->program, "can't read nnpfs_node at %p",
		    VTOI(vp));
		return (-1);
	}
	kf->va_fsid = nnpfs_node.attr.va_fsid;
	kf->va_fileid = (long)nnpfs_node.attr.va_fileid;
	kf->va_mode = nnpfs_node.attr.va_mode;
	kf->va_size = nnpfs_node.attr.va_size;
	kf->va_rdev = nnpfs_node.attr.va_rdev;

	return (0);
}

static int
a863 3
			break;
		case VT_NNPFS:
			ret = nnpfs_filestat(kd, kf, vp);
@


1.24
log
@Eliminate the f_usecount ref count in struct file; instead of sleeping
at the top of closef() until all in-progress calls finish, just do the
advisory locking bits required of close() by POSIX and let whichever
thread has the last reference do the call to the file's fo_close()
method and the final cleanup.

lots of discussion with deraadt@@ and others; worked out with and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.23 2012/04/20 15:59:52 guenther Exp $	*/
d319 1
a319 1
		if ((proc.p_flag & P_SYSTEM) ||
d342 2
@


1.23
log
@Fix kvm_deadfile2_byid()'s handling of kernel vs user addresses for
fd_ofiles and fd_ofileflags, reading in the separate allocation
when necessary.  Lets fstat -p and fstat -u work on kernel crash
dumps again.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.22 2012/04/14 12:19:27 guenther Exp $	*/
d500 1
a500 1
		kf->f_usecount = fp->f_usecount;
@


1.22
log
@Make kvm_getfile2() have a fighting change to work correctly on crash
dumps
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.21 2012/03/28 16:01:30 guenther Exp $	*/
d112 1
d262 1
a262 1
	struct nlist nl[5], *np;
d275 1
d299 1
a299 1
	if (KREAD(kd, nl[3].n_value, &allproc)) {
d315 1
a315 1
			return (NULL);
d340 1
a340 1
			return (NULL);
d350 1
a350 1
				return (NULL);
d363 24
a386 1
			return (NULL);
d395 1
a395 1
				return (NULL);
d406 1
a406 1
				return (NULL);
d417 1
a417 1
				return (NULL);
d428 1
a428 1
				return (NULL);
d441 1
a441 1
			return (NULL);
d451 1
a451 1
				return (NULL);
d455 1
a455 1
				return (NULL);
d464 1
d466 3
@


1.21
log
@The kinfo_file2 structure's f_wbytes member was being filled with the
read byte count instead of the written byte count.

pointed out by paulm at tetrardus.net, ok dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.20 2012/03/13 17:28:51 tedu Exp $	*/
d121 1
a121 1
static int fill_file2(kvm_t *, struct kinfo_file2 *, struct file *,
a199 1
	size_t size;
d201 4
a204 3
	int buflen = kd->arglen, n = 0;
	char *where = kd->argspc;
	struct kinfo_file2 *kf = NULL;
d228 3
a230 2
	size = (nfiles + 10) * sizeof(struct kinfo_file2);
	kd->filebase = _kvm_malloc(kd, size);
d234 4
a237 5
	LIST_FOREACH(fp, &filehead, f_list) {
		if (buflen < sizeof(struct kinfo_file2))
			break;

		if (KREAD(kd, (long)fp, &file)) {
d241 6
a246 3
		kf = (struct kinfo_file2 *)where;
		where += sizeof(struct kinfo_file2);
		buflen -= sizeof(struct kinfo_file2);
a247 2
		if (fill_file2(kd, kf, fp, NULL, NULL, 0, 0) == -1)
			return (NULL);
d254 1
a254 1
	return (kf);
d260 1
a260 1
	size_t size;
d262 3
a264 3
	int buflen = kd->arglen, n = 0;
	char *where = kd->argspc;
	struct kinfo_file2 *kf = NULL;
d274 1
a274 1
	int i, nfiles, nprocs;
d279 2
a280 3
	nl[2].n_name = "_nprocs";
	nl[3].n_name = "_allproc";
	nl[4].n_name = 0;
a296 4
	if (KREAD(kd, nl[2].n_value, &nprocs)) {
		_kvm_err(kd, kd->program, "can't read nprocs");
		return (NULL);
	}
d302 3
a304 2
	size = (nfiles + 10) * sizeof(struct kinfo_file2);
	kd->filebase = _kvm_malloc(kd, size);
d308 3
a310 4
	LIST_FOREACH(p, &allproc, p_list) {
		if (buflen < sizeof(struct kinfo_file2))
			break;

d366 1
a366 1
			if (buflen < sizeof(struct kinfo_file2))
d368 1
a368 5
			kf = (struct kinfo_file2 *)where;
			where += sizeof(struct kinfo_file2);
			buflen -= sizeof(struct kinfo_file2);
			n++;
			if (fill_file2(kd, kf, NULL, proc.p_textvp, &proc,
d371 4
d377 1
a377 1
			if (buflen < sizeof(struct kinfo_file2))
d379 1
a379 5
			kf = (struct kinfo_file2 *)where;
			where += sizeof(struct kinfo_file2);
			buflen -= sizeof(struct kinfo_file2);
			n++;
			if (fill_file2(kd, kf, NULL, filed.fd_cdir, &proc,
d382 4
d388 1
a388 1
			if (buflen < sizeof(struct kinfo_file2))
d390 1
a390 5
			kf = (struct kinfo_file2 *)where;
			where += sizeof(struct kinfo_file2);
			buflen -= sizeof(struct kinfo_file2);
			n++;
			if (fill_file2(kd, kf, NULL, filed.fd_rdir, &proc,
d393 4
d399 1
a399 1
			if (buflen < sizeof(struct kinfo_file2))
d401 6
a406 3
			kf = (struct kinfo_file2 *)where;
			where += sizeof(struct kinfo_file2);
			buflen -= sizeof(struct kinfo_file2);
a407 3
			if (fill_file2(kd, kf, NULL, process.ps_tracevp, &proc,
			    KERN_FILE_TRACE, pid) == -1)
				return (NULL);
d420 1
a420 1
			if (buflen < sizeof(struct kinfo_file2))
d428 6
a433 3
			kf = (struct kinfo_file2 *)where;
			where += sizeof(struct kinfo_file2);
			buflen -= sizeof(struct kinfo_file2);
a434 3
			if (fill_file2(kd, kf, &file, NULL, &proc, i, pid)
			    == -1)
				return (NULL);
d439 1
a439 1
	return (kf);
d443 1
a443 1
fill_file2(kvm_t *kd, struct kinfo_file2 *kf, struct file *fp, struct vnode *vp,
a457 1
		fp->f_cred = &f_cred;
d459 1
a459 1
		kf->f_fileaddr = PTRTOINT64(fp);
d466 2
a467 2
		kf->f_uid = fp->f_cred->cr_uid;
		kf->f_gid = fp->f_cred->cr_gid;
d473 5
a477 7
		if (getuid() == 0 || p->p_ucred->cr_uid == fp->f_cred->cr_uid) {
			kf->f_rxfer = fp->f_rxfer;
			kf->f_rwfer = fp->f_wxfer;
			kf->f_seek = fp->f_seek;
			kf->f_rbytes = fp->f_rbytes;
			kf->f_wbytes = fp->f_wbytes;
		}
d484 1
a490 1
		struct mount mount;
a497 6
		if (KREAD(kd, (u_long)vp->v_mount, &mount)) {
			_kvm_err(kd, kd->program, "can't read v_mount");
			return (-1);
		}
		vp->v_mount = &mount;

d504 12
a515 2
		strlcpy(kf->f_mntonname, vp->v_mount->mnt_stat.f_mntonname,
		    sizeof(kf->f_mntonname));
@


1.20
log
@0 is a valid uid for files sysctl, don't skip it.  reminded by guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.19 2012/01/07 05:38:12 guenther Exp $	*/
d483 1
a483 1
			kf->f_wbytes = fp->f_rbytes;
@


1.19
log
@Add rtable id and thread id to struct kinfo_proc (and fix process id)
and add an 'rtableid' keyword to ps.

Add rtable id, thread id, and socket splice info to struct kinfo_file2
and make fstat display socket splice information.

Remove old KVM_PROC2 and kinfo_proc2 interfaces; bump libkvm major

Socket splice info and corrections from bluhm@@  "Lovely" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.18 2011/12/14 17:33:46 guenther Exp $	*/
d330 1
a330 1
			if (arg > 0 && proc.p_ucred->cr_uid != (uid_t)arg) {
@


1.18
log
@The ktrace vnode has moved to struct process and changed name.
Missed commit pointed out by mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.17 2011/07/04 20:35:35 deraadt Exp $	*/
d122 1
a122 1
    struct vnode *, struct proc *, int);
d245 1
a245 1
		if (fill_file2(kd, kf, fp, NULL, NULL, 0) == -1)
d269 1
a269 1
	struct proc *p, proc;
d274 1
d345 11
d377 1
a377 1
			    KERN_FILE_TEXT) == -1)
d388 1
a388 1
			    KERN_FILE_CDIR) == -1)
d399 1
a399 1
			    KERN_FILE_RDIR) == -1)
d410 1
a410 1
			    KERN_FILE_TRACE) == -1)
d436 2
a437 1
			if (fill_file2(kd, kf, &file, NULL, &proc, i) == -1)
d448 1
a448 1
    struct proc *p, int fd)
d548 5
d568 1
d590 1
d644 1
a644 1
		kf->p_pid = p->p_pid;
d647 1
@


1.17
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.16 2010/07/17 19:27:07 guenther Exp $	*/
d390 1
a390 1
		if (proc.p_tracep) {
d397 1
a397 1
			if (fill_file2(kd, kf, NULL, proc.p_tracep, &proc,
@


1.16
log
@Move some macros in <msdosfs/denode.h> to outside the #ifdef _KERNEL
so that libkvm doesn't need to define that, thereby avoiding some warnings.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.15 2010/06/29 16:39:23 guenther Exp $	*/
d78 1
a95 2

#include <miscfs/specfs/specdev.h>
@


1.15
log
@Fail instead of lying if a process asks sysctl()'s KERN_PROC2 or
KERN_FILE2 (or their libkvm wrappers) for more information than the
running implementation knows how to provide.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.14 2010/01/10 03:37:50 guenther Exp $	*/
a92 1
#define _KERNEL
a93 1
#undef _KERNEL
@


1.14
log
@Reimplement kvm_getproc2()'s support for reading crash dumps and
/dev/mem to be direct instead of going through kvm_getprocs(), as
that function is going to get more an more broken as we move stuff
from struct proc to struct process for rthreads.  To minimize the
code copying, put the common logic of filling in a kinfo_proc2
structure into a macro FILL_KPROC2() in <sys/sysctl.h> for use from
both the kernel and user-space.  This also hides the KERN_PROC
#define behind "#if defined(_KERNEL)||defined(_LIBKVM)", as it's
deprecated.

Positive feedback from millert and blambert; so committing to unblock
further rthreads work.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.13 2009/10/27 23:59:28 deraadt Exp $	*/
d175 5
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.12 2009/07/21 14:37:00 millert Exp $	*/
a429 2

#define PTRTOINT64(_x)	((u_int64_t)(u_long)(_x))
@


1.12
log
@Support KERN_FILE_TEXT here too
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.11 2009/07/21 14:10:15 millert Exp $	*/
a46 4

#if defined(LIBC_SCCS) && !defined(lint)
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.11 2009/07/21 14:10:15 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.11
log
@Handle the case where so_pcb is NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.10 2009/07/08 18:59:11 millert Exp $	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.10 2009/07/08 18:59:11 millert Exp $";
d359 11
@


1.10
log
@correct kvm_getfile2 error string
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.9 2009/06/24 13:04:24 millert Exp $	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.9 2009/06/24 13:04:24 millert Exp $";
d528 2
@


1.9
log
@Install ntfs includes and add libkvm (fstat) support.  ntfs bits
adapted from NetBSD fstat.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.8 2009/06/20 20:20:43 millert Exp $	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.8 2009/06/20 20:20:43 millert Exp $";
d162 1
a162 1
			_kvm_syserr(kd, kd->program, "kvm_getfiles");
d173 1
a173 1
			_kvm_syserr(kd, kd->program, "kvm_getfiles");
@


1.8
log
@Move KREAD define to kvm_private.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.7 2009/06/20 19:50:05 millert Exp $	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.7 2009/06/20 19:50:05 millert Exp $";
d626 2
a627 2
static mode_t
getftype(enum vtype v_type)
d735 1
a735 1
	kf->va_mode = (mp.pm_mask & 0777) | getftype(vp->v_type);
d756 1
a756 1
	kf->va_mode = (mode_t)nfsnode.n_vattr.va_mode | getftype(vp->v_type);
d834 3
@


1.7
log
@Split out cd9660 bits into their own .c file to avoid #define collisions
with ufs and add also udf support.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.6 2009/06/20 13:10:21 millert Exp $	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.6 2009/06/20 13:10:21 millert Exp $";
a122 3

#define KREAD(kd, addr, obj) \
	(kvm_read(kd, addr, obj, sizeof(*obj)) != sizeof(*obj))
@


1.6
log
@Add msdosfs support now that we have the headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.5 2009/06/19 19:07:27 millert Exp $	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.5 2009/06/19 19:07:27 millert Exp $";
a82 4
#include <isofs/cd9660/iso.h>
#include <isofs/cd9660/cd9660_extern.h>
#include <isofs/cd9660/cd9660_node.h>

a809 18
isofs_filestat(kvm_t *kd, struct kinfo_file2 *kf, struct vnode *vp)
{
	struct iso_node inode;

	if (KREAD(kd, (u_long)VTOI(vp), &inode)) {
		_kvm_err(kd, kd->program, "can't read inode at %p", VTOI(vp));
		return (-1);
	}
	kf->va_fsid = inode.i_dev & 0xffff;
	kf->va_fileid = (long)inode.i_number;
	kf->va_mode = inode.inode.iso_mode;
	kf->va_size = inode.i_size;
	kf->va_rdev = inode.i_dev;

	return (0);
}

static int
d827 1
a827 1
			ret = isofs_filestat(kd, kf, vp);
d834 3
@


1.5
log
@Quiet a gcc warning
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.4 2009/06/11 17:00:31 chl Exp $	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.4 2009/06/11 17:00:31 chl Exp $";
d100 6
d633 35
d727 2
a728 2
#if 0 /* XXX */
	struct inode inode;
d730 7
a736 2
	if (KREAD(kd, (u_long)VTOI(vp), &inode)) {
		_kvm_err(kd, kd->program, "can't read inode at %p", VTOI(vp));
d739 6
a744 6
	kf->va_fsid = inode.i_dev & 0xffff;
	kf->va_fileid = (long)inode.i_number;
	kf->va_mode = inode.i_e2fs_mode;
	kf->va_size = inode.i_e2fs_size;
	kf->va_rdev = 0;	/* XXX */
#endif
a752 1
	mode_t mode;
d763 1
a763 27
	mode = (mode_t)nfsnode.n_vattr.va_mode;
	switch (vp->v_type) {
	case VREG:
		mode |= S_IFREG;
		break;
	case VDIR:
		mode |= S_IFDIR;
		break;
	case VBLK:
		mode |= S_IFBLK;
		break;
	case VCHR:
		mode |= S_IFCHR;
		break;
	case VLNK:
		mode |= S_IFLNK;
		break;
	case VSOCK:
		mode |= S_IFSOCK;
		break;
	case VFIFO:
		mode |= S_IFIFO;
		break;
	default:
		break;
	}
	kf->va_mode = mode;
@


1.4
log
@add missing headers needed by free(), memset(), getuid() and strlcpy().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.3 2009/06/07 21:35:11 millert Exp $	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.3 2009/06/07 21:35:11 millert Exp $";
d207 1
a207 1
	struct kinfo_file2 *kf;
d266 1
a266 1
	struct kinfo_file2 *kf;
@


1.3
log
@Define _KERNEL for the bare minimum.  We can include sys/proc.h
normally as long as we define __need_process and use a local
definition of struct proclist.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_file2.c,v 1.1 2009/06/07 03:09:34 millert Exp $	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD: kvm_file2.c,v 1.1 2009/06/07 03:09:34 millert Exp $";
d116 3
@


1.2
log
@Avoid including machine/cpu.h
@
text
@d59 2
d62 3
a65 1
#include <sys/ucred.h>
a67 3
#include <sys/uio.h>
#include <sys/selinfo.h>
#include <sys/proc.h>
d129 2
@


1.1
log
@Add kvm_getfile2 which uses KERN_FILE2 when possible, falling
back on kmem grovelling for non-live kernels.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
static char *rcsid = "$OpenBSD$";
a60 1
#include <machine/cpu.h>
a61 1
#include <sys/proc.h>
d65 2
@

