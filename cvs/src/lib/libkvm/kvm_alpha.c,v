head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.4
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.10
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.14.0.30
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.28
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.26
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.24
	OPENBSD_5_0:1.14.0.22
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.20
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.18
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.14
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.16
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.12
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.10.0.10
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.8
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.12.19.18.40.30;	author mmcc;	state Exp;
branches;
next	1.15;
commitid	VyFkUl2aDcMyfbMJ;

1.15
date	2013.11.01.15.57.56;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.20.15.11.48;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.15.19.31.31;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.01.02.04.10;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.15.03.52.59;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.05.02.23.11;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.17.36;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.05.23.04.35;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.18.09.08.37;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.22.14.01.28;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.08.18.40.48;	author ericj;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.09.04.01.50;	author ericj;	state Exp;
branches;
next	1.3;

1.3
date	97.02.26.16.46.29;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.05.05.14.56.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/*	$OpenBSD: kvm_alpha.c,v 1.15 2013/11/01 15:57:56 deraadt Exp $	*/
/*	$NetBSD: kvm_alpha.c,v 1.5 1996/10/01 21:12:05 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#define __KVM_ALPHA_PRIVATE	     /* see <machine/pte.h> */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/stat.h>
#include <sys/kcore.h>
#include <machine/kcore.h>
#include <unistd.h>
#include <stdlib.h>
#include <nlist.h>
#include <kvm.h>

#include <uvm/uvm_extern.h>
#include <machine/vmparam.h>
#include <machine/pmap.h>

#include <limits.h>
#include <db.h>

#include "kvm_private.h"

struct vmstate {
	vsize_t	page_shift;
};

void
_kvm_freevtop(kvm_t *kd)
{

	/* Not actually used for anything right now, but safe. */
	free(kd->vmst);
	kd->vmst = NULL;
}

int
_kvm_initvtop(kvm_t *kd)
{
	cpu_kcore_hdr_t *cpu_kh;
	struct vmstate *vm;

	vm = (struct vmstate *)_kvm_malloc(kd, sizeof(*vm));
	if (vm == NULL)
		return (-1);

	cpu_kh = kd->cpu_data;

	/* Compute page_shift. */
	for (vm->page_shift = 0; (1L << vm->page_shift) < cpu_kh->page_size;
	    vm->page_shift++)
		/* nothing */ ;
	if ((1L << vm->page_shift) != cpu_kh->page_size) {
		free(vm);
		return (-1);
	}

	kd->vmst = vm;
	return (0);
}

int
_kvm_kvatop(kvm_t *kd, u_long va, paddr_t *pa)
{
	cpu_kcore_hdr_t *cpu_kh;
	struct vmstate *vm;
	int rv, page_off;
	alpha_pt_entry_t pte;
	off_t pteoff;

	if (!kd->vmst) {
		_kvm_err(kd, 0, "vatop called before initvtop");
		return (0);
	}

	if (ISALIVE(kd)) {
		_kvm_err(kd, 0, "vatop called in live kernel!");
		return (0);
	}

	cpu_kh = kd->cpu_data;
	vm = kd->vmst;
	page_off = va & (cpu_kh->page_size - 1);

#ifndef PAGE_SHIFT
#define	PAGE_SHIFT      vm->page_shift
#endif

	if (va >= ALPHA_K0SEG_BASE && va <= ALPHA_K0SEG_END) {
		/*
		 * Direct-mapped address: just convert it.
		 */

		*pa = ALPHA_K0SEG_TO_PHYS(va);
		rv = cpu_kh->page_size - page_off;
	} else if (va >= ALPHA_K1SEG_BASE && va <= ALPHA_K1SEG_END) {
		/*
		 * Real kernel virtual address: do the translation.
		 */

		/* Find and read the L1 PTE. */
		pteoff = cpu_kh->lev1map_pa +
		    l1pte_index(va) * sizeof(alpha_pt_entry_t);
		if (_kvm_pread(kd, kd->pmfd, (char *)&pte, sizeof(pte),
		    (off_t)_kvm_pa2off(kd, pteoff)) != sizeof(pte)) {
			_kvm_syserr(kd, 0, "could not read L1 PTE");
			goto lose;
		}

		/* Find and read the L2 PTE. */
		if ((pte & ALPHA_PTE_VALID) == 0) {
			_kvm_err(kd, 0, "invalid translation (invalid L1 PTE)");
			goto lose;
		}
		pteoff = ALPHA_PTE_TO_PFN(pte) * cpu_kh->page_size +
		    l2pte_index(va) * sizeof(alpha_pt_entry_t);
		if (_kvm_pread(kd, kd->pmfd, (char *)&pte, sizeof(pte),
		    (off_t)_kvm_pa2off(kd, pteoff)) != sizeof(pte)) {
			_kvm_syserr(kd, 0, "could not read L2 PTE");
			goto lose;
		}

		/* Find and read the L3 PTE. */
		if ((pte & ALPHA_PTE_VALID) == 0) {
			_kvm_err(kd, 0, "invalid translation (invalid L2 PTE)");
			goto lose;
		}
		pteoff = ALPHA_PTE_TO_PFN(pte) * cpu_kh->page_size +
		    l3pte_index(va) * sizeof(alpha_pt_entry_t);
		if (_kvm_pread(kd, kd->pmfd, (char *)&pte, sizeof(pte),
		    (off_t)_kvm_pa2off(kd, pteoff)) != sizeof(pte)) {
			_kvm_syserr(kd, 0, "could not read L3 PTE");
			goto lose;
		}

		/* Fill in the PA. */
		if ((pte & ALPHA_PTE_VALID) == 0) {
			_kvm_err(kd, 0, "invalid translation (invalid L3 PTE)");
			goto lose;
		}
		*pa = ALPHA_PTE_TO_PFN(pte) * cpu_kh->page_size + page_off;
		rv = cpu_kh->page_size - page_off;
	} else {
		/*
		 * Bogus address (not in KV space): punt.
		 */

		_kvm_err(kd, 0, "invalid kernel virtual address");
lose:
		*pa = -1;
		rv = 0;
	}

	return (rv);
}

/*
 * Translate a physical address to a file-offset in the crash-dump.
 */
off_t
_kvm_pa2off(kvm_t *kd, paddr_t pa)
{
	cpu_kcore_hdr_t *cpu_kh;
	phys_ram_seg_t *ramsegs;
	off_t off;
	int i;

	cpu_kh = kd->cpu_data;
	ramsegs = (phys_ram_seg_t *)((char *)cpu_kh + ALIGN(sizeof *cpu_kh));

	off = 0;
	for (i = 0; i < cpu_kh->nmemsegs; i++) {
		if (pa >= ramsegs[i].start &&
		   (pa - ramsegs[i].start) < ramsegs[i].size) {
			off += (pa - ramsegs[i].start);
			break;
		}
		off += ramsegs[i].size;
	}
	return (kd->dump_off + off);
}
@


1.15
log
@reduce use of <sys/user.h>
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.14 2006/03/20 15:11:48 mickey Exp $	*/
d61 2
a62 4
	if (kd->vmst != NULL) {
		free(kd->vmst);
		kd->vmst = NULL;
	}
@


1.14
log
@for some of internal functions use paddr_t where phys addr is intended insteadd of u_long; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.13 2004/09/15 19:31:31 miod Exp $	*/
a33 1
#include <sys/user.h>
@


1.13
log
@Kill (almost all) warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.12 2004/07/01 02:04:10 mickey Exp $	*/
d94 1
a94 1
_kvm_kvatop(kvm_t *kd, u_long va, u_long *pa)
d192 1
a192 1
_kvm_pa2off(kvm_t *kd, u_long pa)
@


1.12
log
@if sym has null value -- report as not found; check that kd->vmst is set before use; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.11 2004/06/15 03:52:59 deraadt Exp $	*/
d40 1
@


1.11
log
@knf; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.10 2001/12/05 02:23:11 art Exp $	*/
d100 5
@


1.10
log
@Include more machdep headers. (paranoia)
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.9 2001/11/06 19:17:36 art Exp $	*/
d9 1
a9 1
 * 
d15 3
a17 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d19 1
a19 1
 * 
d31 1
a31 1
#define __KVM_ALPHA_PRIVATE             /* see <machine/pte.h> */
d57 1
a57 2
_kvm_freevtop(kd)
	kvm_t *kd;
d61 1
a61 1
	if (kd->vmst != 0)
d63 2
d68 1
a68 2
_kvm_initvtop(kd)
	kvm_t *kd;
d70 2
a71 2
        cpu_kcore_hdr_t *cpu_kh;
        struct vmstate *vm;
d73 3
a75 14
        vm = (struct vmstate *)_kvm_malloc(kd, sizeof(*vm));
        if (vm == NULL)
                return (-1);

        cpu_kh = kd->cpu_data;

        /* Compute page_shift. */
        for (vm->page_shift = 0; (1L << vm->page_shift) < cpu_kh->page_size;
             vm->page_shift++)
                /* nothing */ ;
        if ((1L << vm->page_shift) != cpu_kh->page_size) {
                free(vm);
                return (-1);
        }
d77 12
a88 1
        kd->vmst = vm;
d93 1
a93 4
_kvm_kvatop(kd, va, pa)
	kvm_t *kd;
	u_long va;
	u_long *pa;
d101 4
a104 4
        if (ISALIVE(kd)) {
                _kvm_err(kd, 0, "vatop called in live kernel!");
                return(0);
        }
d111 1
a111 1
#define        PAGE_SHIFT      vm->page_shift
d129 2
a130 1
		if (_kvm_pread(kd, kd->pmfd, (char *)&pte, sizeof(pte), (off_t)_kvm_pa2off(kd, pteoff)) != sizeof(pte)) {
d142 2
a143 1
		if (_kvm_pread(kd, kd->pmfd, (char *)&pte, sizeof(pte), (off_t)_kvm_pa2off(kd, pteoff)) != sizeof(pte)) {
d155 2
a156 1
		if (_kvm_pread(kd, kd->pmfd, (char *)&pte, sizeof(pte), (off_t)_kvm_pa2off(kd, pteoff)) != sizeof(pte)) {
d185 2
a186 4
off_t   
_kvm_pa2off(kd, pa)
	kvm_t *kd;
	u_long pa;
@


1.9
log
@Adapt to new uvm/ includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.8 2001/11/05 23:04:35 art Exp $	*/
d44 2
@


1.8
log
@No need to pull in vm/vm_param.h in any of these files.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.7 2001/05/18 09:08:37 art Exp $	*/
d43 1
a43 1
#include <vm/vm.h>
@


1.7
log
@Convert lseek/{read,write} pairs into pread and pwrite.
from my todo list, work by Jonathon Fletcher <jonathon.fletcher@@pobox.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.6 2001/01/22 14:01:28 art Exp $	*/
a43 1
#include <vm/vm_param.h>
@


1.6
log
@PAGE_SHIFT can be a define, avoid double-define.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.5 2000/11/08 18:40:48 ericj Exp $	*/
d131 1
a131 2
		if (lseek(kd->pmfd, _kvm_pa2off(kd, pteoff), 0) == -1 ||
		    read(kd->pmfd, (char *)&pte, sizeof(pte)) != sizeof(pte)) {
d143 1
a143 2
		if (lseek(kd->pmfd, _kvm_pa2off(kd, pteoff), 0) == -1 ||
		    read(kd->pmfd, (char *)&pte, sizeof(pte)) != sizeof(pte)) {
d155 1
a155 2
		if (lseek(kd->pmfd, _kvm_pa2off(kd, pteoff), 0) == -1 ||
		    read(kd->pmfd, (char *)&pte, sizeof(pte)) != sizeof(pte)) {
@


1.5
log
@
adjust for changes to kcore, and dynamically compute page shift.
from NetBSD.
art@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.4 2000/06/09 04:01:50 ericj Exp $	*/
d112 1
d114 1
@


1.4
log
@remove unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.3 1997/02/26 16:46:29 niklas Exp $	*/
d31 2
d51 4
d69 2
d72 16
d98 1
d109 1
d112 2
d128 1
a128 1
		    kvtol1pte(va) * sizeof(alpha_pt_entry_t);
d141 1
a141 1
		    vatoste(va) * sizeof(alpha_pt_entry_t);
d154 1
a154 1
		    vatopte(va) * sizeof(alpha_pt_entry_t);
d190 2
d193 1
a193 1
	cpu_kcore_hdr_t *cpu_kh;
d196 1
d199 9
a207 3
	pa -= cpu_kh->core_seg.start;

	return (kd->dump_off + off + pa);
@


1.3
log
@Switch alpha from libkvm.old to libkvm with code from NetBSD.
%x -> %lx format fixes from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_alpha.c,v 1.5 1996/10/01 21:12:05 cgd Exp $	*/
a138 1
		    vatopte(va) * sizeof(alpha_pt_entry_t);
@


1.2
log
@sync with 0430
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: kvm_alpha.c,v 1.2 1995/09/29 03:57:48 cgd Exp $	*/
d35 2
d54 3
d73 78
d152 2
a153 1
	/* don't forget k0seg translations! */
d155 17
a171 1
	return (0);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
