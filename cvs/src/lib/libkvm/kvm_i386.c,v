head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.22.0.4
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.10
	OPENBSD_5_0:1.21.0.8
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.6
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.14
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.10
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.8
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.6
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.12.19.18.40.30;	author mmcc;	state Exp;
branches;
next	1.26;
commitid	VyFkUl2aDcMyfbMJ;

1.26
date	2015.04.07.05.50.40;	author guenther;	state Exp;
branches;
next	1.25;
commitid	X6t2A5JgXMogyQvE;

1.25
date	2015.01.09.03.43.52;	author mlarkin;	state Exp;
branches;
next	1.24;
commitid	TzpVlzYKb3Vx3GSZ;

1.24
date	2013.11.01.15.57.56;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.28.16.27.31;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.07.09.08.43.10;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.20.21.15.00;	author tom;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.09.09.46.04;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.07.12.57.21;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.27.15.44.05;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.31.03.58.21;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.20.15.11.48;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.14.19.23.52;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.01.02.04.10;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.15.03.52.59;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.05.02.23.11;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.17.36;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.05.23.04.35;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.18.09.08.37;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.16.21.02.04;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	98.08.24.05.46.12;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.26.16.46.30;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.05.05.14.57.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.19.23.15.23;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.44;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/*	$OpenBSD: kvm_i386.c,v 1.26 2015/04/07 05:50:40 guenther Exp $ */
/*	$NetBSD: kvm_i386.c,v 1.9 1996/03/18 22:33:38 thorpej Exp $	*/

/*-
 * Copyright (c) 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software developed by the Computer Systems
 * Engineering group at Lawrence Berkeley Laboratory under DARPA contract
 * BG 91-66 and contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * i386 machine dependent routines for kvm.  Hopefully, the forthcoming
 * vm code will one day obsolete this module.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>
#include <nlist.h>
#include <kvm.h>

#include <uvm/uvm_extern.h>
#include <machine/vmparam.h>
#include <machine/pmap.h>

#include <limits.h>
#include <db.h>

#include "kvm_private.h"

#include <machine/pte.h>

/*
 * We access both normal and PAE entries in 32bit chunks.
 * Use a local name to avoid conflicting with the kernel's maybe-public,
 * maybe-not p[td]_entry_t typedefs.
 */
typedef u_long ptd_entry_t;

/*
 * These must match the values in pmap.c/pmapae.c
 * First the non-PAE versions
 */
#define PD_MASK		0xffc00000	/* page directory address bits */
#define PT_MASK		0x003ff000	/* page table address bits */

/*
 * PAE versions
 *
 * paddr_t is still 32bits, so the top 32bits of PDEs and PTEs only
 * matters for the NX bit...which libkvm doesn't care about
 */
#define PAE_PDSHIFT	21
#define PAE_PD_MASK	0xffe00000	/* page directory address bits */
#define PAE_PT_MASK	0x001ff000	/* page table address bits */

#define PG_FRAME	0xfffff000

static int cpu_pae;

struct vmstate {
	ptd_entry_t *PTD;
	ptd_entry_t PD_mask;
	ptd_entry_t PT_mask;
	int PD_shift;
	int PG_shift;
};

#define pdei(vm,VA)	(((VA) & (vm)->PD_mask) >> (vm)->PD_shift)
#define ptei(vm,VA)	(((VA) & (vm)->PT_mask) >> PAGE_SHIFT)

void
_kvm_freevtop(kvm_t *kd)
{
	if (kd->vmst != NULL) {
		free(kd->vmst->PTD);

		free(kd->vmst);
		kd->vmst = NULL;
	}
}

int
_kvm_initvtop(kvm_t *kd)
{
	struct nlist nl[4];
	struct vmstate *vm;
	u_long pa, PTDsize;

	vm = _kvm_malloc(kd, sizeof(*vm));
	if (vm == NULL)
		return (-1);
	kd->vmst = vm;

	vm->PTD = NULL;

	nl[0].n_name = "_PTDpaddr";
	nl[1].n_name = "_PTDsize";
	nl[2].n_name = "_cpu_pae";
	nl[3].n_name = NULL;

	if (kvm_nlist(kd, nl) != 0) {
		_kvm_err(kd, kd->program, "bad namelist");
		return (-1);
	}

	if (_kvm_pread(kd, kd->pmfd, &cpu_pae, sizeof cpu_pae,
	    _kvm_pa2off(kd, nl[2].n_value - KERNBASE)) != sizeof cpu_pae)
		goto invalid;

	if (_kvm_pread(kd, kd->pmfd, &PTDsize, sizeof PTDsize,
	    _kvm_pa2off(kd, nl[1].n_value - KERNBASE)) != sizeof PTDsize)
		goto invalid;

	if (_kvm_pread(kd, kd->pmfd, &pa, sizeof pa,
	    _kvm_pa2off(kd, nl[0].n_value - KERNBASE)) != sizeof pa)
		goto invalid;

	vm->PTD = _kvm_malloc(kd, PTDsize);

	if (_kvm_pread(kd, kd->pmfd, vm->PTD, PTDsize,
	    _kvm_pa2off(kd, pa)) != PTDsize)
		goto invalid;

	if (cpu_pae) {
		vm->PD_mask = PAE_PD_MASK;
		vm->PT_mask = PAE_PT_MASK;
		/* -1 here because entries are twice as large */
		vm->PD_shift = PAE_PDSHIFT - 1;
		vm->PG_shift = PAGE_SHIFT - 1;
	} else {
		vm->PD_mask = PD_MASK;
		vm->PT_mask = PT_MASK;
		vm->PD_shift = PDSHIFT;
		vm->PG_shift = PAGE_SHIFT;
	}

	return (0);

invalid:
	free(vm->PTD);
	vm->PTD = NULL;
	return (-1);
}

/*
 * Translate a kernel virtual address to a physical address.
 */
int
_kvm_kvatop(kvm_t *kd, u_long va, paddr_t *pa)
{
	u_long offset, pte_pa;
	struct vmstate *vm;
	ptd_entry_t pte;

	if (!kd->vmst) {
		_kvm_err(kd, 0, "vatop called before initvtop");
		return (0);
	}

	if (ISALIVE(kd)) {
		_kvm_err(kd, 0, "vatop called in live kernel!");
		return (0);
	}

	vm = kd->vmst;
	offset = va & (kd->nbpg - 1);

	/*
	 * If we are initializing (kernel page table descriptor pointer
	 * not yet set) * then return pa == va to avoid infinite recursion.
	 */
	if (vm->PTD == NULL) {
		*pa = va;
		return (kd->nbpg - (int)offset);
	}
	if ((vm->PTD[pdei(vm,va)] & PG_V) == 0)
		goto invalid;

	pte_pa = (vm->PTD[pdei(vm,va)] & PG_FRAME) +
	    (ptei(vm,va) * sizeof(ptd_entry_t));

	/* XXX READ PHYSICAL XXX */
	if (_kvm_pread(kd, kd->pmfd, &pte, sizeof pte,
	    _kvm_pa2off(kd, pte_pa)) != sizeof pte)
		goto invalid;

	if ((pte & PG_V) == 0)
		goto invalid;
	*pa = (pte & PG_FRAME) + offset;
	return (kd->nbpg - (int)offset);

invalid:
	_kvm_err(kd, 0, "invalid address (%lx)", va);
	return (0);
}

/*
 * Translate a physical address to a file-offset in the crash-dump.
 */
off_t
_kvm_pa2off(kvm_t *kd, paddr_t pa)
{
	return ((off_t)(kd->dump_off + pa));
}
@


1.26
log
@Teach libkvm a bit about PAE, making it independent of the kernel defines
and doing runtime detection of what the target kernel is using.  Getting
this is now to avoid breakage when kernel bits come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.25 2015/01/09 03:43:52 mlarkin Exp $ */
d104 1
a104 2
		if (kd->vmst->PTD != NULL)
			free(kd->vmst->PTD);
d169 2
a170 4
	if (vm->PTD != NULL) {
		free(vm->PTD);
		vm->PTD = NULL;
	}
@


1.25
log
@
Cleanup some macros and #defines in i386 pmap. Previously committed and
backed out because of libkvm breakage, recommitting now with libkvm fix.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.24 2013/11/01 15:57:56 deraadt Exp $ */
d62 7
d70 1
a73 2
#define pdei(VA)	(((VA) & PD_MASK) >> PDSHIFT)
#define ptei(VA)	(((VA) & PT_MASK) >> PAGE_SHIFT)
d75 13
d90 5
a94 1
	pd_entry_t *PTD;
d97 3
d115 1
a115 1
	struct nlist nl[2];
d117 1
a117 1
	u_long pa;
d119 1
a119 1
	vm = (struct vmstate *)_kvm_malloc(kd, sizeof(*vm));
d127 3
a129 1
	nl[1].n_name = NULL;
d136 8
d145 1
a145 1
	    (off_t)_kvm_pa2off(kd, nl[0].n_value - KERNBASE)) != sizeof pa)
d148 1
a148 1
	vm->PTD = (pd_entry_t *)_kvm_malloc(kd, kd->nbpg);
d150 2
a151 2
	if (_kvm_pread(kd, kd->pmfd, vm->PTD, kd->nbpg,
	    (off_t)_kvm_pa2off(kd, pa)) != kd->nbpg)
d154 13
d185 1
a185 1
	pt_entry_t pte;
d208 1
a208 1
	if ((vm->PTD[pdei(va)] & PG_V) == 0)
d211 2
a212 2
	pte_pa = (vm->PTD[pdei(va)] & PG_FRAME) +
	    (ptei(va) * sizeof(pt_entry_t));
d216 1
a216 1
	    (off_t)_kvm_pa2off(kd, pte_pa)) != sizeof pte)
d219 2
@


1.24
log
@reduce use of <sys/user.h>
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.23 2013/03/28 16:27:31 deraadt Exp $ */
d60 9
@


1.23
log
@Avoid using PAGE_SHIFT, PAGE_SIZE, and PAGE_MASK defines, since we already
know it from the machine.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.22 2012/07/09 08:43:10 deraadt Exp $ */
a42 1
#include <sys/user.h>
@


1.22
log
@Use the PAGE_* forms (instead of the ancient BSD forms) in param.h,
because param.h will get a kick in the head sometime in the future.
One day, maybe both can become invisible, but we boot one of them
first.
ok guenter
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.21 2009/10/27 23:59:28 deraadt Exp $ */
d104 1
a104 1
	vm->PTD = (pd_entry_t *)_kvm_malloc(kd, PAGE_SIZE);
d106 2
a107 2
	if (_kvm_pread(kd, kd->pmfd, vm->PTD, PAGE_SIZE,
	    (off_t)_kvm_pa2off(kd, pa)) != PAGE_SIZE)
d141 1
a141 1
	offset = va & PAGE_MASK;
d149 1
a149 1
		return (PAGE_SIZE - (int)offset);
d163 1
a163 1
	return (PAGE_SIZE - (int)offset);
@


1.21
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.20 2007/02/20 21:15:00 tom Exp $ */
d104 1
a104 1
	vm->PTD = (pd_entry_t *)_kvm_malloc(kd, NBPG);
d106 2
a107 2
	if (_kvm_pread(kd, kd->pmfd, vm->PTD, NBPG,
	    (off_t)_kvm_pa2off(kd, pa)) != NBPG)
d141 1
a141 1
	offset = va & PGOFSET;
d149 1
a149 1
		return (NBPG - (int)offset);
d163 1
a163 1
	return (NBPG - (int)offset);
@


1.20
log
@Revert PAE pmap for now, until the strange bug is found.  This stops
the freezes many of us are seeing (especially on amd64 machines running
OpenBSD/i386).

Much testing by nick@@ (as always - thanks!), hugh@@, ian@@, kettenis@@
and Sam Smith (s (at) msmith (dot) net).

Requested by, input from, and ok deraadt@@  ok art@@, kettenis@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.16 2006/03/31 03:58:21 deraadt Exp $ */
a35 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)kvm_hp300.c	8.1 (Berkeley) 6/4/93";
#else
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.16 2006/03/31 03:58:21 deraadt Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.19
log
@proper type and ptdsize checks; had it for three weeks now... sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.18 2006/05/07 12:57:21 kettenis Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.18 2006/05/07 12:57:21 kettenis Exp $";
d71 1
a71 5
	void *PTD;
	paddr_t pg_frame;
	paddr_t pt_mask;
	int size;
	int pte_size;
a73 8
#define	pdei(vm,v)	((v) >> ((vm)->size == NBPG ? 22 : 21))
#define	ptei(vm,v)	(((v) & (vm)->pt_mask) >> PGSHIFT)
#define	PDE(vm,v)	\
    ((vm)->size == NBPG ? ((u_int32_t *)(vm)->PTD)[pdei(vm,v)] : \
    ((u_int64_t *)(vm)->PTD)[pdei(vm,v)])
#define	PG_FRAME(vm)	((vm)->pg_frame)
#define	pte_size(vm)	((vm)->pte_size)

d89 1
a89 1
	struct nlist nl[3];
d91 1
a91 2
	paddr_t pa;
	int ps;
d101 1
a101 2
	nl[1].n_name = "_PTDsize";
	nl[2].n_name = NULL;
d108 3
a110 3
	if (_kvm_pread(kd, kd->pmfd, &ps, sizeof ps,
	    _kvm_pa2off(kd, nl[1].n_value - KERNBASE)) != sizeof ps)
		return (-1);
d112 1
a112 13
	pa = 0;
	if (ps == NBPG) {
		vm->pg_frame = 0xfffff000;
		vm->pt_mask = 0x003ff000;
		vm->pte_size = 4;
	} else if (ps == NBPG * 4) {
		vm->pg_frame = 0xffffff000ULL;
		vm->pt_mask = 0x001ff000;
		vm->pte_size = 8;
	} else {
		_kvm_err(kd, 0, "PTDsize is invalid");
		return (-1);
	}
d114 3
a116 3
	if (_kvm_pread(kd, kd->pmfd, &pa, vm->pte_size,
	    _kvm_pa2off(kd, nl[0].n_value - KERNBASE)) != vm->pte_size)
		return (-1);
d118 1
a118 3
	vm->PTD = _kvm_malloc(kd, ps);
	if (vm->PTD == NULL)
		return (-1);
d120 2
a121 1
	if (_kvm_pread(kd, kd->pmfd, vm->PTD, ps, _kvm_pa2off(kd, pa)) != ps) {
a123 1
		return (-1);
d125 1
a125 3

	vm->size = ps;
	return (0);
d134 1
a134 1
	u_long offset;
d136 1
a136 1
	paddr_t pte, pte_pa;
d159 1
a159 1
	if ((PDE(vm, va) & PG_V) == 0)
d162 2
a163 2
	pte_pa = (PDE(vm, va) & PG_FRAME(vm)) +
	    (ptei(vm, va) * pte_size(vm));
d166 2
a167 3
	pte = 0;
	if (_kvm_pread(kd, kd->pmfd, &pte, pte_size(vm),
	    _kvm_pa2off(kd, pte_pa)) != pte_size(vm))
d170 1
a170 1
	*pa = (pte & PG_FRAME(vm)) + offset;
@


1.18
log
@Unbreak.  Fix some of the lint warnings that mickey reintroduced.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.17 2006/04/27 15:44:05 mickey Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.17 2006/04/27 15:44:05 mickey Exp $";
d131 1
a131 1
	} else {
d135 3
d164 1
a164 1
	u_long offset, pte_pa;
d166 1
a166 1
	paddr_t pte;
d198 1
a198 1
	    (off_t)_kvm_pa2off(kd, pte_pa)) != pte_size(vm))
@


1.17
log
@detect page table dir size difference for normal and pae modes
(4k vs 16k) and use proper physical address types and page table
indexing.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.16 2006/03/31 03:58:21 deraadt Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.16 2006/03/31 03:58:21 deraadt Exp $";
d73 1
d78 2
a79 4
#undef pdei
#define	pdei(vm,v)	((v) >> ((vm)->size == NBPG? 22 : 21))
#undef ptei
#define	ptei(vm,v)	((v) >> ((vm)->size == NBPG? 22 : 21))
d81 1
a81 1
    ((vm)->size == NBPG? ((u_int32_t *)(vm)->PTD)[pdei(vm,v)] : \
a82 1
#undef PG_FRAME
d101 1
a101 1
	struct nlist nlist[3];
d113 3
a115 3
	nlist[0].n_name = "_PTDpaddr";
	nlist[1].n_name = "_PTDsize";
	nlist[2].n_name = NULL;
d117 1
a117 1
	if (kvm_nlist(kd, nlist) != 0) {
d123 1
a123 1
	    _kvm_pa2off(kd, nlist[1].n_value - KERNBASE)) != sizeof ps)
d129 1
d133 1
d138 1
a138 1
	    _kvm_pa2off(kd, nlist[0].n_value - KERNBASE)) != sizeof pa)
d151 1
a163 1
	int i;
d193 1
@


1.16
log
@lint happiness, mostly avoiding variable aliasing
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.15 2006/03/20 15:11:48 mickey Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.15 2006/03/20 15:11:48 mickey Exp $";
d71 4
a74 1
	pd_entry_t *PTD;
d77 11
d103 1
a103 1
	struct nlist nl[2];
d105 2
a106 1
	u_long pa;
d115 3
a117 2
	nl[0].n_name = "_PTDpaddr";
	nl[1].n_name = NULL;
d119 1
a119 1
	if (kvm_nlist(kd, nl) != 0) {
d124 3
a126 3
	if (_kvm_pread(kd, kd->pmfd, &pa, sizeof pa,
	    (off_t)_kvm_pa2off(kd, nl[0].n_value - KERNBASE)) != sizeof pa)
		goto invalid;
d128 8
a135 1
	vm->PTD = (pd_entry_t *)_kvm_malloc(kd, NBPG);
d137 3
a139 3
	if (_kvm_pread(kd, kd->pmfd, vm->PTD, NBPG,
	    (off_t)_kvm_pa2off(kd, pa)) != NBPG)
		goto invalid;
d141 3
a143 1
	return (0);
d145 1
a145 2
invalid:
	if (vm->PTD != NULL) {
d148 1
d150 2
a151 1
	return (-1);
d162 2
a163 1
	pt_entry_t pte;
d186 1
a186 1
	if ((vm->PTD[pdei(va)] & PG_V) == 0)
d189 2
a190 2
	pte_pa = (vm->PTD[pdei(va)] & PG_FRAME) +
	    (ptei(va) * sizeof(pt_entry_t));
d193 2
a194 2
	if (_kvm_pread(kd, kd->pmfd, &pte, sizeof pte,
	    (off_t)_kvm_pa2off(kd, pte_pa)) != sizeof pte)
d197 1
a197 1
	*pa = (pte & PG_FRAME) + offset;
@


1.15
log
@for some of internal functions use paddr_t where phys addr is intended insteadd of u_long; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.14 2006/03/14 19:23:52 kettenis Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.14 2006/03/14 19:23:52 kettenis Exp $";
d89 1
a89 1
	struct nlist nlist[2];
d100 2
a101 2
	nlist[0].n_name = "_PTDpaddr";
	nlist[1].n_name = NULL;
d103 1
a103 1
	if (kvm_nlist(kd, nlist) != 0) {
d109 1
a109 1
	    (off_t)_kvm_pa2off(kd, nlist[0].n_value - KERNBASE)) != sizeof pa)
d157 1
a157 1
		return (NBPG - offset);
d171 1
a171 1
	return (NBPG - offset);
@


1.14
log
@Prevent double-free.
ok mickey@@, todd@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.13 2004/07/01 02:04:10 mickey Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.13 2004/07/01 02:04:10 mickey Exp $";
d132 1
a132 1
_kvm_kvatop(kvm_t *kd, u_long va, u_long *pa)
d182 1
a182 1
_kvm_pa2off(kvm_t *kd, u_long pa)
@


1.13
log
@if sym has null value -- report as not found; check that kd->vmst is set before use; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.12 2004/06/15 03:52:59 deraadt Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.12 2004/06/15 03:52:59 deraadt Exp $";
d94 1
a94 1
	if (vm == 0)
d98 2
d101 1
a101 1
	nlist[1].n_name = 0;
a107 2
	vm->PTD = 0;

d121 1
a121 1
	if (vm->PTD != 0)
d123 2
d155 1
a155 1
	if (vm->PTD == 0) {
@


1.12
log
@knf; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.11 2003/06/02 20:18:40 millert Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.11 2003/06/02 20:18:40 millert Exp $";
d135 5
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.10 2001/12/05 02:23:11 art Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.10 2001/12/05 02:23:11 art Exp $";
d75 1
a75 2
_kvm_freevtop(kd)
	kvm_t *kd;
d77 2
a78 2
	if (kd->vmst != 0) {
		if (kd->vmst->PTD != 0)
d82 1
d87 1
a87 2
_kvm_initvtop(kd)
	kvm_t *kd;
d89 1
a90 1
	struct nlist nlist[2];
d108 2
a109 1
	if (_kvm_pread(kd, kd->pmfd, &pa, sizeof pa, (off_t)_kvm_pa2off(kd, nlist[0].n_value - KERNBASE)) != sizeof pa) {
a110 1
	}
d114 2
a115 1
	if (_kvm_pread(kd, kd->pmfd, vm->PTD, NBPG, (off_t)_kvm_pa2off(kd, pa)) != NBPG) {
a116 1
	}
d130 1
a130 4
_kvm_kvatop(kd, va, pa)
	kvm_t *kd;
	u_long va;
	u_long *pa;
d132 1
a133 2
	u_long offset;
	u_long pte_pa;
d138 1
a138 1
		return(0);
d144 2
a145 2
        /*
         * If we are initializing (kernel page table descriptor pointer
d147 5
a151 5
         */
        if (vm->PTD == 0) {
                *pa = va;
                return (NBPG - offset);
        }
d157 1
d159 3
a161 5
	{
		if (_kvm_pread(kd, kd->pmfd, &pte, sizeof pte, (off_t)_kvm_pa2off(kd, pte_pa)) != sizeof pte) {
			goto invalid;
		}
	}
d175 1
a175 3
_kvm_pa2off(kd, pa)
	kvm_t *kd;
	u_long pa;
d177 1
a177 1
	return((off_t)(kd->dump_off + pa));
@


1.10
log
@Include more machdep headers. (paranoia)
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.9 2001/11/06 19:17:36 art Exp $ */
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.9 2001/11/06 19:17:36 art Exp $";
@


1.9
log
@Adapt to new uvm/ includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.8 2001/11/05 23:04:35 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.8 2001/11/05 23:04:35 art Exp $";
d64 2
@


1.8
log
@No need to pull in vm/vm_param.h in any of these files.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.7 2001/05/18 09:08:37 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.7 2001/05/18 09:08:37 art Exp $";
d63 1
a63 1
#include <vm/vm.h>
@


1.7
log
@Convert lseek/{read,write} pairs into pread and pwrite.
from my todo list, work by Jonathon Fletcher <jonathon.fletcher@@pobox.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.6 2000/04/16 21:02:04 mickey Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.6 2000/04/16 21:02:04 mickey Exp $";
a63 1
#include <vm/vm_param.h>
@


1.6
log
@from: gluk@@ptci.ru
make it grok current core dumps.
seem to work now.
also millert@@ took a look.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.5 1998/08/24 05:46:12 millert Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.5 1998/08/24 05:46:12 millert Exp $";
d112 1
a112 7
	if (lseek(kd->pmfd, _kvm_pa2off(kd, nlist[0].n_value - KERNBASE),
				SEEK_SET) == -1 && errno != 0) {
		_kvm_syserr(kd, kd->program, "kvm_lseek");
		goto invalid;
	}
	if (read(kd->pmfd, &pa, sizeof pa) != sizeof pa) {
		_kvm_syserr(kd, kd->program, "kvm_read");
d118 1
a118 6
	if (lseek(kd->pmfd, _kvm_pa2off(kd, pa), SEEK_SET) == -1 && errno != 0) {
		_kvm_syserr(kd, kd->program, "kvm_lseek");
		goto invalid;
	}
	if (read(kd->pmfd, vm->PTD, NBPG) != NBPG) {
		_kvm_syserr(kd, kd->program, "kvm_read");
d167 1
a167 7
		if (lseek(kd->pmfd, _kvm_pa2off(kd, pte_pa), SEEK_SET) == -1 &&
		    errno != 0) {
			_kvm_syserr(kd, kd->program, "kvm_lseek");
			goto invalid;
		}
		if (read(kd->pmfd, &pte, sizeof pte) != sizeof pte) {
			_kvm_syserr(kd, kd->program, "kvm_read");
@


1.5
log
@minor fixup to make this work.  i386 still uses libkvm.old but it probably doesn't need to.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm_i386.c,v 1.4 1997/02/26 16:46:30 niklas Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm_i386.c,v 1.4 1997/02/26 16:46:30 niklas Exp $";
d50 1
a50 1
 * i386 machine dependent routines for kvm.  Hopefully, the forthcoming 
a72 5
#ifndef btop
#define	btop(x)		(((unsigned)(x)) >> PGSHIFT)	/* XXX */
#define	ptob(x)		((caddr_t)((x) << PGSHIFT))	/* XXX */
#endif

d112 2
a113 2
	if (lseek(kd->pmfd, (off_t)(nlist[0].n_value - KERNBASE), SEEK_SET)
	    == -1 && errno != 0) {
d124 4
a127 2
	if (lseek(kd->pmfd, (off_t)pa, SEEK_SET) == -1 && errno != 0) { _kvm_syserr(kd, kd->program, "kvm_lseek");
		goto invalid; }
d178 1
a178 1
		if (lseek(kd->pmfd, (off_t)pte_pa, SEEK_SET) == -1 &&
d198 1
a198 2
 * Translate a physical address to a file-offset in the crash dump.
 * XXX - just a stub for now.
d205 1
a205 1
	return((off_t)pa);
@


1.4
log
@Switch alpha from libkvm.old to libkvm with code from NetBSD.
%x -> %lx format fixes from me.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 1
a45 1
static char *rcsid = "$OpenBSD$";
d117 2
a118 2
	if (lseek(kd->pmfd, (off_t)(nlist[0].n_value - KERNBASE), 0) == -1 &&
	    errno != 0) {
d129 2
a130 4
	if (lseek(kd->pmfd, (off_t)pa, 0) == -1 && errno != 0) {
		_kvm_syserr(kd, kd->program, "kvm_lseek");
		goto invalid;
	}
d181 2
a182 1
		if (lseek(kd->pmfd, (off_t)pte_pa, 0) == -1 && errno != 0) {
d198 12
@


1.3
log
@sync with 0430
@
text
@d197 1
a197 1
	_kvm_err(kd, 0, "invalid address (%x)", va);
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d42 3
a44 1
/* from: static char sccsid[] = "@@(#)kvm_hp300.c	8.1 (Berkeley) 6/4/93"; */
d46 1
@


1.1
log
@Initial revision
@
text
@d1 2
d42 1
a42 1
static char *rcsid = "$Id: kvm_i386.c,v 1.7 1995/06/29 11:41:45 cgd Exp $";
a74 1
	pd_entry_t **PTDpaddr;
a77 3
#define KREAD(kd, addr, p)\
	(kvm_read(kd, addr, (char *)(p), sizeof(*(p))) != sizeof(*(p)))

d96 1
a96 1
	pt_entry_t *tmpPTD;
a110 1
	vm->PTDpaddr = 0;
d112 9
a120 3
	if (KREAD(kd, (u_long)nlist[0].n_value - KERNBASE, &vm->PTDpaddr)) {
		_kvm_err(kd, kd->program, "cannot read PTDpaddr");
		return (-1);
d123 9
a131 5
	tmpPTD = (pd_entry_t *)_kvm_malloc(kd, NBPG);
	if ((kvm_read(kd, (u_long)vm->PTDpaddr, tmpPTD, NBPG)) != NBPG) {
		free(tmpPTD);
		_kvm_err(kd, kd->program, "cannot read PTD");
		return (-1);
d133 1
a133 1
	vm->PTD = tmpPTD;
d135 5
d180 1
a180 1
			_kvm_syserr(kd, 0, "kvm_lseek");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
