head	1.62;
access;
symbols
	OPENBSD_6_1:1.62.0.4
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.62.0.2
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.55.0.4
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.52.0.6
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.49.0.10
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.49.0.8
	OPENBSD_5_3_BASE:1.49
	OPENBSD_5_2:1.49.0.6
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.4
	OPENBSD_5_0:1.49.0.2
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.48.0.6
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.4
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.47.0.4
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.45.0.10
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.8
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.6
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.45.0.4
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.45.0.2
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.42.0.6
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.42.0.4
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.40.0.2
	OPENBSD_3_6_BASE:1.40
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	OPENBSD_3_3:1.33.0.4
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.17.0.6
	OPENBSD_2_7_BASE:1.17
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.62
date	2016.07.10.23.06.48;	author tedu;	state Exp;
branches;
next	1.61;
commitid	RTm48EZsUMCj83GF;

1.61
date	2016.05.14.14.24.54;	author kettenis;	state Exp;
branches;
next	1.60;
commitid	LoPTF4hQHolrVlC5;

1.60
date	2016.05.11.17.46.44;	author tedu;	state Exp;
branches;
next	1.59;
commitid	FUrBardrA5KQav0a;

1.59
date	2015.12.19.18.40.30;	author mmcc;	state Exp;
branches;
next	1.58;
commitid	VyFkUl2aDcMyfbMJ;

1.58
date	2015.09.08.15.40.32;	author dlg;	state Exp;
branches;
next	1.57;
commitid	isQJqv6zi2SMXzXF;

1.57
date	2015.09.04.02.58.14;	author dlg;	state Exp;
branches;
next	1.56;
commitid	uyt9IruJmfmzApFD;

1.56
date	2015.09.04.02.55.09;	author dlg;	state Exp;
branches;
next	1.55;
commitid	TVczXXlIm5Uhxfi0;

1.55
date	2015.05.11.00.42.54;	author guenther;	state Exp;
branches;
next	1.54;
commitid	ERk0TOjsvusMAegY;

1.54
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	0DYulI8hhujBHMcR;

1.53
date	2014.08.15.03.51.40;	author guenther;	state Exp;
branches;
next	1.52;
commitid	ILfd29dGeQRUYnTr;

1.52
date	2013.11.16.00.41.44;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2013.11.01.15.57.56;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2013.10.17.08.02.21;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2011.03.12.04.54.28;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.07.03.09.34;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.21.22.18.00;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.31.03.59.40;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.31.03.09.17;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.20.15.11.48;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2004.09.15.19.31.31;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.09.14.22.39.56;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.11.18.45.58;	author jaredy;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.01.02.04.10;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.15.03.52.58;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2004.02.23.23.19.09;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2004.02.18.03.23.00;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.09.16.51.07;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.09.17.21.21.08;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.17.20.01.22;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.08.22.31.24;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.05.00.15.08;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.19.19.39.37;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.17.19.42.25;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.16.21.27.26;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.21.20.16.16;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.06.19.17.36;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.05.23.04.35;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.27.09.11.51;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.18.09.08.36;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.17.21.03.55;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.04.21.51.04;	author todd;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.25.23.37.38;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.23.06.59.42;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	98.10.28.19.47.00;	author marc;	state Exp;
branches;
next	1.16;

1.16
date	98.08.24.05.32.39;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.08.19.18.51.09;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.07.11.05.57.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.06.29.23.23.29;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	98.06.29.22.39.12;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	98.06.29.22.27.05;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	97.07.25.20.30.17;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.06.18.05.10.16;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.11.10.32.15;	author grr;	state Exp;
branches;
next	1.7;

1.7
date	97.06.02.17.06.53;	author dm;	state Exp;
branches;
next	1.6;

1.6
date	97.02.26.16.46.28;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.01.17.07.11.59;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.58.30;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.05.14.56.42;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.19.23.15.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.62
log
@use offsetof to create an offset instead of illegal unaligned pointers
ok guenther
@
text
@/*	$OpenBSD: kvm.c,v 1.61 2016/05/14 14:24:54 kettenis Exp $ */
/*	$NetBSD: kvm.c,v 1.43 1996/05/05 04:31:59 gwr Exp $	*/

/*-
 * Copyright (c) 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software developed by the Computer Systems
 * Engineering group at Lawrence Berkeley Laboratory under DARPA contract
 * BG 91-66 and contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXCOMLEN MID_MACHINE */
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/sysctl.h>

#include <sys/core.h>
#include <sys/exec.h>
#include <sys/kcore.h>

#include <stddef.h>
#include <errno.h>
#include <ctype.h>
#include <db.h>
#include <fcntl.h>
#include <libgen.h>
#include <limits.h>
#include <nlist.h>
#include <paths.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <kvm.h>
#include <stdarg.h>

#include "kvm_private.h"

extern int __fdnlist(int, struct nlist *);

static int	kvm_dbopen(kvm_t *, const char *);
static int	kvm_opennamelist(kvm_t *, const char *);
static int	_kvm_get_header(kvm_t *);
static kvm_t	*_kvm_open(kvm_t *, const char *, const char *, const char *,
		     int, char *);
static int	clear_gap(kvm_t *, FILE *, int);

char *
kvm_geterr(kvm_t *kd)
{
	return (kd->errbuf);
}

/*
 * Wrapper around pread.
 */
ssize_t
_kvm_pread(kvm_t *kd, int fd, void *buf, size_t nbytes, off_t offset)
{
	ssize_t rval;

	errno = 0;
	rval = pread(fd, buf, nbytes, offset);
	if (rval == -1 || errno != 0) {
		_kvm_syserr(kd, kd->program, "pread");
	}
	return (rval);
}

/*
 * Wrapper around pwrite.
 */
ssize_t
_kvm_pwrite(kvm_t *kd, int fd, const void *buf, size_t nbytes, off_t offset)
{
	ssize_t rval;

	errno = 0;
	rval = pwrite(fd, buf, nbytes, offset);
	if (rval == -1 || errno != 0) {
		_kvm_syserr(kd, kd->program, "pwrite");
	}
	return (rval);
}

/*
 * Report an error using printf style arguments.  "program" is kd->program
 * on hard errors, and 0 on soft errors, so that under sun error emulation,
 * only hard errors are printed out (otherwise, programs like gdb will
 * generate tons of error messages when trying to access bogus pointers).
 */
void
_kvm_err(kvm_t *kd, const char *program, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	if (program != NULL) {
		(void)fprintf(stderr, "%s: ", program);
		(void)vfprintf(stderr, fmt, ap);
		(void)fputc('\n', stderr);
	} else
		(void)vsnprintf(kd->errbuf,
		    sizeof(kd->errbuf), fmt, ap);

	va_end(ap);
}

void
_kvm_syserr(kvm_t *kd, const char *program, const char *fmt, ...)
{
	va_list ap;
	size_t n;

	va_start(ap, fmt);
	if (program != NULL) {
		(void)fprintf(stderr, "%s: ", program);
		(void)vfprintf(stderr, fmt, ap);
		(void)fprintf(stderr, ": %s\n", strerror(errno));
	} else {
		char *cp = kd->errbuf;

		(void)vsnprintf(cp, sizeof(kd->errbuf), fmt, ap);
		n = strlen(cp);
		(void)snprintf(&cp[n], sizeof(kd->errbuf) - n, ": %s",
		    strerror(errno));
	}
	va_end(ap);
}

void *
_kvm_malloc(kvm_t *kd, size_t n)
{
	void *p;

	if ((p = malloc(n)) == NULL)
		_kvm_err(kd, kd->program, "%s", strerror(errno));
	return (p);
}

void *
_kvm_realloc(kvm_t *kd, void *p, size_t n)
{
	if ((p = realloc(p, n)) == NULL)
		_kvm_err(kd, kd->program, "%s", strerror(errno));
	return (p);
}

static kvm_t *
_kvm_open(kvm_t *kd, const char *uf, const char *mf, const char *sf,
    int flag, char *errout)
{
	struct stat st;

	kd->db = 0;
	kd->pmfd = -1;
	kd->vmfd = -1;
	kd->swfd = -1;
	kd->nlfd = -1;
	kd->alive = 0;
	kd->filebase = NULL;
	kd->procbase = NULL;
	kd->nbpg = getpagesize();
	kd->swapspc = 0;
	kd->argspc = 0;
	kd->argbuf = 0;
	kd->argv = 0;
	kd->vmst = NULL;
	kd->vm_page_buckets = 0;
	kd->kcore_hdr = 0;
	kd->cpu_dsize = 0;
	kd->cpu_data = 0;
	kd->dump_off = 0;

	if (flag & KVM_NO_FILES) {
		kd->alive = 1;
		return (kd);
	}

	if (uf && strlen(uf) >= PATH_MAX) {
		_kvm_err(kd, kd->program, "exec file name too long");
		goto failed;
	}
	if (flag != O_RDONLY && flag != O_WRONLY && flag != O_RDWR) {
		_kvm_err(kd, kd->program, "bad flags arg");
		goto failed;
	}
	flag |= O_CLOEXEC;

	if (mf == 0)
		mf = _PATH_MEM;

	if ((kd->pmfd = open(mf, flag)) < 0) {
		_kvm_syserr(kd, kd->program, "%s", mf);
		goto failed;
	}
	if (fstat(kd->pmfd, &st) < 0) {
		_kvm_syserr(kd, kd->program, "%s", mf);
		goto failed;
	}
	if (S_ISCHR(st.st_mode)) {
		/*
		 * If this is a character special device, then check that
		 * it's /dev/mem.  If so, open kmem too.  (Maybe we should
		 * make it work for either /dev/mem or /dev/kmem -- in either
		 * case you're working with a live kernel.)
		 */
		if (strcmp(mf, _PATH_MEM) != 0) {	/* XXX */
			_kvm_err(kd, kd->program,
				 "%s: not physical memory device", mf);
			goto failed;
		}
		if ((kd->vmfd = open(_PATH_KMEM, flag)) < 0) {
			_kvm_syserr(kd, kd->program, "%s", _PATH_KMEM);
			goto failed;
		}
		kd->alive = 1;
		if (sf != NULL && (kd->swfd = open(sf, flag)) < 0) {
			_kvm_syserr(kd, kd->program, "%s", sf);
			goto failed;
		}
		/*
		 * Open kvm nlist database.  We only try to use
		 * the pre-built database if the namelist file name
		 * pointer is NULL.  If the database cannot or should
		 * not be opened, open the namelist argument so we
		 * revert to slow nlist() calls.
		 * If no file is specified, try opening _PATH_KSYMS and
		 * fall back to _PATH_UNIX.
		 */
		if (kvm_dbopen(kd, uf ? uf : _PATH_UNIX) == -1 &&
		    kvm_opennamelist(kd, uf))
			goto failed;
	} else {
		/*
		 * This is a crash dump.
		 * Initialize the virtual address translation machinery,
		 * but first setup the namelist fd.
		 * If no file is specified, try opening _PATH_KSYMS and
		 * fall back to _PATH_UNIX.
		 */
		if (kvm_opennamelist(kd, uf))
			goto failed;

		/*
		 * If there is no valid core header, fail silently here.
		 * The address translations however will fail without
		 * header. Things can be made to run by calling
		 * kvm_dump_mkheader() before doing any translation.
		 */
		if (_kvm_get_header(kd) == 0) {
			if (_kvm_initvtop(kd) < 0)
				goto failed;
		}
	}
	return (kd);
failed:
	/*
	 * Copy out the error if doing sane error semantics.
	 */
	if (errout != 0)
		(void)strlcpy(errout, kd->errbuf, _POSIX2_LINE_MAX);
	(void)kvm_close(kd);
	return (0);
}

static int
kvm_opennamelist(kvm_t *kd, const char *uf)
{
	int fd;

	if (uf != NULL)
		fd = open(uf, O_RDONLY | O_CLOEXEC);
	else {
		fd = open(_PATH_KSYMS, O_RDONLY | O_CLOEXEC);
		uf = _PATH_UNIX;
		if (fd == -1)
			fd = open(uf, O_RDONLY | O_CLOEXEC);
	}
	if (fd == -1) {
		_kvm_syserr(kd, kd->program, "%s", uf);
		return (-1);
	}

	kd->nlfd = fd;
	return (0);
}

/*
 * The kernel dump file (from savecore) contains:
 *    kcore_hdr_t kcore_hdr;
 *    kcore_seg_t cpu_hdr;
 *    (opaque)    cpu_data; (size is cpu_hdr.c_size)
 *    kcore_seg_t mem_hdr;
 *    (memory)    mem_data; (size is mem_hdr.c_size)
 *
 * Note: khdr is padded to khdr.c_hdrsize;
 * cpu_hdr and mem_hdr are padded to khdr.c_seghdrsize
 */
static int
_kvm_get_header(kvm_t *kd)
{
	kcore_hdr_t	kcore_hdr;
	kcore_seg_t	cpu_hdr;
	kcore_seg_t	mem_hdr;
	size_t		offset;
	ssize_t		sz;

	/*
	 * Read the kcore_hdr_t
	 */
	sz = _kvm_pread(kd, kd->pmfd, &kcore_hdr, sizeof(kcore_hdr), (off_t)0);
	if (sz != sizeof(kcore_hdr)) {
		return (-1);
	}

	/*
	 * Currently, we only support dump-files made by the current
	 * architecture...
	 */
	if ((CORE_GETMAGIC(kcore_hdr) != KCORE_MAGIC) ||
	    (CORE_GETMID(kcore_hdr) != MID_MACHINE))
		return (-1);

	/*
	 * Currently, we only support exactly 2 segments: cpu-segment
	 * and data-segment in exactly that order.
	 */
	if (kcore_hdr.c_nseg != 2)
		return (-1);

	/*
	 * Save away the kcore_hdr.  All errors after this
	 * should do a to "goto fail" to deallocate things.
	 */
	kd->kcore_hdr = _kvm_malloc(kd, sizeof(kcore_hdr));
	if (kd->kcore_hdr == NULL)
		goto fail;
	memcpy(kd->kcore_hdr, &kcore_hdr, sizeof(kcore_hdr));
	offset = kcore_hdr.c_hdrsize;

	/*
	 * Read the CPU segment header
	 */
	sz = _kvm_pread(kd, kd->pmfd, &cpu_hdr, sizeof(cpu_hdr), (off_t)offset);
	if (sz != sizeof(cpu_hdr)) {
		goto fail;
	}

	if ((CORE_GETMAGIC(cpu_hdr) != KCORESEG_MAGIC) ||
	    (CORE_GETFLAG(cpu_hdr) != CORE_CPU))
		goto fail;
	offset += kcore_hdr.c_seghdrsize;

	/*
	 * Read the CPU segment DATA.
	 */
	kd->cpu_dsize = cpu_hdr.c_size;
	kd->cpu_data = _kvm_malloc(kd, (size_t)cpu_hdr.c_size);
	if (kd->cpu_data == NULL)
		goto fail;

	sz = _kvm_pread(kd, kd->pmfd, kd->cpu_data, (size_t)cpu_hdr.c_size,
	    (off_t)offset);
	if (sz != (size_t)cpu_hdr.c_size) {
		goto fail;
	}

	offset += cpu_hdr.c_size;

	/*
	 * Read the next segment header: data segment
	 */
	sz = _kvm_pread(kd, kd->pmfd, &mem_hdr, sizeof(mem_hdr), (off_t)offset);
	if (sz != sizeof(mem_hdr)) {
		goto fail;
	}

	offset += kcore_hdr.c_seghdrsize;

	if ((CORE_GETMAGIC(mem_hdr) != KCORESEG_MAGIC) ||
	    (CORE_GETFLAG(mem_hdr) != CORE_DATA))
		goto fail;

	kd->dump_off = offset;
	return (0);

fail:
	free(kd->kcore_hdr);
	kd->kcore_hdr = NULL;
	if (kd->cpu_data != NULL) {
		free(kd->cpu_data);
		kd->cpu_data = NULL;
		kd->cpu_dsize = 0;
	}

	return (-1);
}

/*
 * The format while on the dump device is: (new format)
 *    kcore_seg_t cpu_hdr;
 *    (opaque)    cpu_data; (size is cpu_hdr.c_size)
 *    kcore_seg_t mem_hdr;
 *    (memory)    mem_data; (size is mem_hdr.c_size)
 */
int
kvm_dump_mkheader(kvm_t *kd, off_t dump_off)
{
	kcore_seg_t	cpu_hdr;
	int	hdr_size;
	ssize_t sz;

	if (kd->kcore_hdr != NULL) {
	    _kvm_err(kd, kd->program, "already has a dump header");
	    return (-1);
	}
	if (ISALIVE(kd)) {
		_kvm_err(kd, kd->program, "don't use on live kernel");
		return (-1);
	}

	/*
	 * Validate new format crash dump
	 */
	sz = _kvm_pread(kd, kd->pmfd, &cpu_hdr, sizeof(cpu_hdr), (off_t)dump_off);
	if (sz != sizeof(cpu_hdr)) {
		return (-1);
	}
	if ((CORE_GETMAGIC(cpu_hdr) != KCORE_MAGIC)
		|| (CORE_GETMID(cpu_hdr) != MID_MACHINE)) {
		_kvm_err(kd, 0, "invalid magic in cpu_hdr");
		return (-1);
	}
	hdr_size = ALIGN(sizeof(cpu_hdr));

	/*
	 * Read the CPU segment.
	 */
	kd->cpu_dsize = cpu_hdr.c_size;
	kd->cpu_data = _kvm_malloc(kd, kd->cpu_dsize);
	if (kd->cpu_data == NULL)
		goto fail;

	sz = _kvm_pread(kd, kd->pmfd, kd->cpu_data, (size_t)cpu_hdr.c_size,
	    (off_t)dump_off+hdr_size);
	if (sz != (ssize_t)cpu_hdr.c_size) {
		_kvm_err(kd, 0, "invalid size in cpu_hdr");
		goto fail;
	}
	hdr_size += kd->cpu_dsize;

	/*
	 * Leave phys mem pointer at beginning of memory data
	 */
	kd->dump_off = dump_off + hdr_size;
	errno = 0;
	if (lseek(kd->pmfd, kd->dump_off, SEEK_SET) != kd->dump_off && errno != 0) {
		_kvm_err(kd, 0, "invalid dump offset - lseek");
		goto fail;
	}

	/*
	 * Create a kcore_hdr.
	 */
	kd->kcore_hdr = _kvm_malloc(kd, sizeof(kcore_hdr_t));
	if (kd->kcore_hdr == NULL)
		goto fail;

	kd->kcore_hdr->c_hdrsize    = ALIGN(sizeof(kcore_hdr_t));
	kd->kcore_hdr->c_seghdrsize = ALIGN(sizeof(kcore_seg_t));
	kd->kcore_hdr->c_nseg       = 2;
	CORE_SETMAGIC(*(kd->kcore_hdr), KCORE_MAGIC, MID_MACHINE,0);

	/*
	 * Now that we have a valid header, enable translations.
	 */
	if (_kvm_initvtop(kd) == 0)
		/* Success */
		return (hdr_size);

fail:
	free(kd->kcore_hdr);
	kd->kcore_hdr = NULL;
	if (kd->cpu_data != NULL) {
		free(kd->cpu_data);
		kd->cpu_data = NULL;
		kd->cpu_dsize = 0;
	}
	return (-1);
}

static int
clear_gap(kvm_t *kd, FILE *fp, int size)
{
	if (size <= 0) /* XXX - < 0 should never happen */
		return (0);
	while (size-- > 0) {
		if (fputc(0, fp) == EOF) {
			_kvm_syserr(kd, kd->program, "clear_gap");
			return (-1);
		}
	}
	return (0);
}

/*
 * Write the dump header info to 'fp'. Note that we can't use fseek(3) here
 * because 'fp' might be a file pointer obtained by zopen().
 */
int
kvm_dump_wrtheader(kvm_t *kd, FILE *fp, int dumpsize)
{
	kcore_seg_t	seghdr;
	long		offset;
	int		gap;

	if (kd->kcore_hdr == NULL || kd->cpu_data == NULL) {
		_kvm_err(kd, kd->program, "no valid dump header(s)");
		return (-1);
	}

	/*
	 * Write the generic header
	 */
	offset = 0;
	if (fwrite(kd->kcore_hdr, sizeof(kcore_hdr_t), 1, fp) < 1) {
		_kvm_syserr(kd, kd->program, "kvm_dump_wrtheader");
		return (-1);
	}
	offset += kd->kcore_hdr->c_hdrsize;
	gap     = kd->kcore_hdr->c_hdrsize - sizeof(kcore_hdr_t);
	if (clear_gap(kd, fp, gap) == -1)
		return (-1);

	/*
	 * Write the cpu header
	 */
	CORE_SETMAGIC(seghdr, KCORESEG_MAGIC, 0, CORE_CPU);
	seghdr.c_size = (u_long)ALIGN(kd->cpu_dsize);
	if (fwrite(&seghdr, sizeof(seghdr), 1, fp) < 1) {
		_kvm_syserr(kd, kd->program, "kvm_dump_wrtheader");
		return (-1);
	}
	offset += kd->kcore_hdr->c_seghdrsize;
	gap     = kd->kcore_hdr->c_seghdrsize - sizeof(seghdr);
	if (clear_gap(kd, fp, gap) == -1)
		return (-1);

	if (fwrite(kd->cpu_data, kd->cpu_dsize, 1, fp) < 1) {
		_kvm_syserr(kd, kd->program, "kvm_dump_wrtheader");
		return (-1);
	}
	offset += seghdr.c_size;
	gap     = seghdr.c_size - kd->cpu_dsize;
	if (clear_gap(kd, fp, gap) == -1)
		return (-1);

	/*
	 * Write the actual dump data segment header
	 */
	CORE_SETMAGIC(seghdr, KCORESEG_MAGIC, 0, CORE_DATA);
	seghdr.c_size = dumpsize;
	if (fwrite(&seghdr, sizeof(seghdr), 1, fp) < 1) {
		_kvm_syserr(kd, kd->program, "kvm_dump_wrtheader");
		return (-1);
	}
	offset += kd->kcore_hdr->c_seghdrsize;
	gap     = kd->kcore_hdr->c_seghdrsize - sizeof(seghdr);
	if (clear_gap(kd, fp, gap) == -1)
		return (-1);

	return (offset);
}

kvm_t *
kvm_openfiles(const char *uf, const char *mf, const char *sf,
    int flag, char *errout)
{
	kvm_t *kd;

	if ((kd = malloc(sizeof(*kd))) == NULL) {
		(void)strlcpy(errout, strerror(errno), _POSIX2_LINE_MAX);
		return (0);
	}
	kd->program = 0;
	return (_kvm_open(kd, uf, mf, sf, flag, errout));
}

kvm_t *
kvm_open(const char *uf, const char *mf, const char *sf, int flag,
    const char *program)
{
	kvm_t *kd;

	if ((kd = malloc(sizeof(*kd))) == NULL && program != NULL) {
		(void)fprintf(stderr, "%s: %s\n", program, strerror(errno));
		return (0);
	}
	kd->program = program;
	return (_kvm_open(kd, uf, mf, sf, flag, NULL));
}

int
kvm_close(kvm_t *kd)
{
	int error = 0;

	if (kd->pmfd >= 0)
		error |= close(kd->pmfd);
	if (kd->vmfd >= 0)
		error |= close(kd->vmfd);
	kd->alive = 0;
	if (kd->nlfd >= 0)
		error |= close(kd->nlfd);
	if (kd->swfd >= 0)
		error |= close(kd->swfd);
	if (kd->db != 0)
		error |= (kd->db->close)(kd->db);
	if (kd->vmst)
		_kvm_freevtop(kd);
	kd->cpu_dsize = 0;
	if (kd->cpu_data != NULL)
		free((void *)kd->cpu_data);
	if (kd->kcore_hdr != NULL)
		free((void *)kd->kcore_hdr);
	free(kd->filebase);
	free(kd->procbase);
	if (kd->swapspc != 0)
		free((void *)kd->swapspc);
	if (kd->argspc != 0)
		free((void *)kd->argspc);
	if (kd->argbuf != 0)
		free((void *)kd->argbuf);
	if (kd->argv != 0)
		free((void *)kd->argv);
	free((void *)kd);

	return (error);
}

/*
 * Set up state necessary to do queries on the kernel namelist
 * data base.  If the data base is out-of-data/incompatible with
 * given executable, set up things so we revert to standard nlist call.
 * Only called for live kernels.  Return 0 on success, -1 on failure.
 */
static int
kvm_dbopen(kvm_t *kd, const char *uf)
{
	char dbversion[_POSIX2_LINE_MAX], kversion[_POSIX2_LINE_MAX];
	char dbname[PATH_MAX];
	struct nlist nitem;
	size_t dbversionlen;
	DBT rec;

	uf = basename(uf);

	(void)snprintf(dbname, sizeof(dbname), "%skvm_%s.db", _PATH_VARDB, uf);
	kd->db = dbopen(dbname, O_RDONLY, 0, DB_HASH, NULL);
	if (kd->db == NULL) {
		switch (errno) {
		case ENOENT:
			/* No kvm_bsd.db, fall back to /bsd silently */
			break;
		case EFTYPE:
			_kvm_err(kd, kd->program,
			    "file %s is incorrectly formatted", dbname);
			break;
		case EINVAL:
			_kvm_err(kd, kd->program,
			    "invalid argument to dbopen()");
			break;
		default:
			_kvm_err(kd, kd->program, "unknown dbopen() error");
			break;
		}
		return (-1);
	}

	/*
	 * read version out of database
	 */
	rec.data = VRS_KEY;
	rec.size = sizeof(VRS_KEY) - 1;
	if ((kd->db->get)(kd->db, (DBT *)&rec, (DBT *)&rec, 0))
		goto close;
	if (rec.data == 0 || rec.size > sizeof(dbversion))
		goto close;

	bcopy(rec.data, dbversion, rec.size);
	dbversionlen = rec.size;

	/*
	 * Read version string from kernel memory.
	 * Since we are dealing with a live kernel, we can call kvm_read()
	 * at this point.
	 */
	rec.data = VRS_SYM;
	rec.size = sizeof(VRS_SYM) - 1;
	if ((kd->db->get)(kd->db, (DBT *)&rec, (DBT *)&rec, 0))
		goto close;
	if (rec.data == 0 || rec.size != sizeof(struct nlist))
		goto close;
	bcopy(rec.data, &nitem, sizeof(nitem));
	if (kvm_read(kd, (u_long)nitem.n_value, kversion, dbversionlen) !=
	    dbversionlen)
		goto close;
	/*
	 * If they match, we win - otherwise clear out kd->db so
	 * we revert to slow nlist().
	 */
	if (bcmp(dbversion, kversion, dbversionlen) == 0)
		return (0);
close:
	(void)(kd->db->close)(kd->db);
	kd->db = 0;

	return (-1);
}

int
kvm_nlist(kvm_t *kd, struct nlist *nl)
{
	struct nlist *p;
	int nvalid, rv;

	/*
	 * If we can't use the data base, revert to the
	 * slow library call.
	 */
	if (kd->db == 0) {
		rv = __fdnlist(kd->nlfd, nl);
		if (rv == -1)
			_kvm_err(kd, 0, "bad namelist");
		return (rv);
	}

	/*
	 * We can use the kvm data base.  Go through each nlist entry
	 * and look it up with a db query.
	 */
	nvalid = 0;
	for (p = nl; p->n_name && p->n_name[0]; ++p) {
		size_t len;
		DBT rec;

		if ((len = strlen(p->n_name)) > 4096) {
			/* sanity */
			_kvm_err(kd, kd->program, "symbol too large");
			return (-1);
		}
		rec.data = p->n_name;
		rec.size = len;

		/*
		 * Make sure that n_value = 0 when the symbol isn't found
		 */
		p->n_value = 0;

		if ((kd->db->get)(kd->db, (DBT *)&rec, (DBT *)&rec, 0))
			continue;
		if (rec.data == 0 || rec.size != sizeof(struct nlist))
			continue;
		++nvalid;
		/*
		 * Avoid alignment issues.
		 */
		bcopy((char *)rec.data + offsetof(struct nlist, n_type),
		    &p->n_type, sizeof(p->n_type));
		bcopy((char *)rec.data + offsetof(struct nlist, n_value),
		    &p->n_value, sizeof(p->n_value));
	}
	/*
	 * Return the number of entries that weren't found.
	 */
	return ((p - nl) - nvalid);
}

int
kvm_dump_inval(kvm_t *kd)
{
	struct nlist	nl[2];
	u_long		x;
	paddr_t		pa;

	if (ISALIVE(kd)) {
		_kvm_err(kd, kd->program, "clearing dump on live kernel");
		return (-1);
	}
	nl[0].n_name = "_dumpmag";
	nl[1].n_name = NULL;

	if (kvm_nlist(kd, nl) == -1) {
		_kvm_err(kd, 0, "bad namelist");
		return (-1);
	}

	if (nl[0].n_value == 0) {
		_kvm_err(kd, nl[0].n_name, "not in name list");
		return (-1);
	}

	if (_kvm_kvatop(kd, (u_long)nl[0].n_value, &pa) == 0)
		return (-1);

	x = 0;
	if (_kvm_pwrite(kd, kd->pmfd, &x, sizeof(x),
	    (off_t)_kvm_pa2off(kd, pa)) != sizeof(x)) {
		_kvm_err(kd, 0, "cannot invalidate dump");
		return (-1);
	}
	return (0);
}

ssize_t
kvm_read(kvm_t *kd, u_long kva, void *buf, size_t len)
{
	ssize_t cc;
	void *cp;

	if (ISALIVE(kd)) {
		/*
		 * We're using /dev/kmem.  Just read straight from the
		 * device and let the active kernel do the address translation.
		 */
		cc = _kvm_pread(kd, kd->vmfd, buf, len, (off_t)kva);
		if (cc == -1) {
			_kvm_err(kd, 0, "invalid address (%lx)", kva);
			return (-1);
		} else if (cc < len)
			_kvm_err(kd, kd->program, "short read");
		return (cc);
	} else {
		if ((kd->kcore_hdr == NULL) || (kd->cpu_data == NULL)) {
			_kvm_err(kd, kd->program, "no valid dump header");
			return (-1);
		}
		cp = buf;
		while (len > 0) {
			paddr_t	pa;

			/* In case of error, _kvm_kvatop sets the err string */
			cc = _kvm_kvatop(kd, kva, &pa);
			if (cc == 0)
				return (-1);
			if (cc > len)
				cc = len;
			cc = _kvm_pread(kd, kd->pmfd, cp, (size_t)cc,
			    (off_t)_kvm_pa2off(kd, pa));
			if (cc == -1) {
				_kvm_syserr(kd, 0, _PATH_MEM);
				break;
			}
			/*
			 * If kvm_kvatop returns a bogus value or our core
			 * file is truncated, we might wind up seeking beyond
			 * the end of the core file in which case the read will
			 * return 0 (EOF).
			 */
			if (cc == 0)
				break;
			cp = (char *)cp + cc;
			kva += cc;
			len -= cc;
		}
		return ((char *)cp - (char *)buf);
	}
	/* NOTREACHED */
}

ssize_t
kvm_write(kvm_t *kd, u_long kva, const void *buf, size_t len)
{
	int cc;

	if (ISALIVE(kd)) {
		/*
		 * Just like kvm_read, only we write.
		 */
		cc = _kvm_pwrite(kd, kd->vmfd, buf, len, (off_t)kva);
		if (cc == -1) {
			_kvm_err(kd, 0, "invalid address (%lx)", kva);
			return (-1);
		} else if (cc < len)
			_kvm_err(kd, kd->program, "short write");
		return (cc);
	} else {
		_kvm_err(kd, kd->program,
		    "kvm_write not implemented for dead kernels");
		return (-1);
	}
	/* NOTREACHED */
}
@


1.61
log
@Revert previous commit.  Converting bcopy into memcpy is never safe when
there is a big fat comment saying "Avoid alignment issues" immediately
above them.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.60 2016/05/11 17:46:44 tedu Exp $ */
d47 1
d795 1
a795 1
		bcopy(&((struct nlist *)rec.data)->n_type,
d797 1
a797 1
		bcopy(&((struct nlist *)rec.data)->n_value,
@


1.60
log
@convert bcopy to memcpy. ok dlg millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.59 2015/12/19 18:40:30 mmcc Exp $ */
d716 1
a716 1
	memcpy(dbversion, rec.data, rec.size);
d730 1
a730 1
	memcpy(&nitem, rec.data, sizeof(nitem));
d794 4
a797 4
		memcpy(&p->n_type, &((struct nlist *)rec.data)->n_type,
		    sizeof(p->n_type));
		memcpy(&p->n_value, &((struct nlist *)rec.data)->n_value,
		    sizeof(p->n_value));
@


1.59
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.58 2015/09/08 15:40:32 dlg Exp $ */
d716 1
a716 1
	bcopy(rec.data, dbversion, rec.size);
d730 1
a730 1
	bcopy(rec.data, &nitem, sizeof(nitem));
d794 4
a797 4
		bcopy(&((struct nlist *)rec.data)->n_type,
		    &p->n_type, sizeof(p->n_type));
		bcopy(&((struct nlist *)rec.data)->n_value,
		    &p->n_value, sizeof(p->n_value));
@


1.58
log
@port the changes just made to kvm_getfiles in kvm_file2.c r1.47 to
kvm_getprocs.

basically cope with the number of procs growing between when we get
the size and when we get the list.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.57 2015/09/04 02:58:14 dlg Exp $ */
d414 2
a415 4
	if (kd->kcore_hdr != NULL) {
		free(kd->kcore_hdr);
		kd->kcore_hdr = NULL;
	}
d508 2
a509 4
	if (kd->kcore_hdr != NULL) {
		free(kd->kcore_hdr);
		kd->kcore_hdr = NULL;
	}
@


1.57
log
@fix a race when fetching files from the kernel. the number of files
might have increased between when we got the number of files and
when we requested that number of files.

now we allocate another 10ish percent on top of what the kernel
says we need, and retry if that still isnt enough.

while here use realloc instead of constantly going through free/malloc
sequences.

with input from claudio@@ deraadt@@
ok millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.56 2015/09/04 02:55:09 dlg Exp $ */
d187 1
a187 1
	kd->procbase = 0;
d657 1
a657 2
	if (kd->procbase != 0)
		free((void *)kd->procbase);
@


1.56
log
@add kvm_realloc() as a private function.

part of a larger diff
ok millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.55 2015/05/11 00:42:54 guenther Exp $ */
d186 1
a186 1
	kd->filebase = 0;
d656 1
a656 2
	if (kd->filebase != 0)
		free((void *)kd->filebase);
@


1.55
log
@When checking flags that will be passed to open(), test the O_ACCMODE portion
separately to avoid false negatives.

ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.54 2015/01/16 16:48:51 deraadt Exp $ */
d162 8
@


1.54
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.53 2014/08/15 03:51:40 guenther Exp $ */
d201 1
a201 1
	if (flag & ~O_ACCMODE) {
@


1.53
log
@Use O_CLOEXEC wherever we open a file and then call fcntl(F_SETFD, FD_CLOEXEC)
on it, simplifying error checking, reducing system calls, and improving
thread-safety for libraries.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.52 2013/11/16 00:41:44 guenther Exp $ */
d37 1
a37 1
#include <sys/param.h>
d197 1
a197 1
	if (uf && strlen(uf) >= MAXPATHLEN) {
d675 1
a675 1
	char dbname[MAXPATHLEN];
@


1.52
log
@ANSIfy a declaration
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.51 2013/11/01 15:57:56 deraadt Exp $ */
d67 1
a71 1
static int	kvm_setfd(kvm_t *);
d205 2
d210 1
a210 1
	if ((kd->pmfd = open(mf, flag, 0)) < 0) {
d230 1
a230 1
		if ((kd->vmfd = open(_PATH_KMEM, flag, 0)) < 0) {
d235 1
a235 1
		if (sf != NULL && (kd->swfd = open(sf, flag, 0)) < 0) {
d249 1
a249 4
		    ((uf && (kd->nlfd = open(uf, O_RDONLY, 0)) == -1) || (!uf &&
		    (kd->nlfd = open((uf = _PATH_KSYMS), O_RDONLY, 0)) == -1 &&
		    (kd->nlfd = open((uf = _PATH_UNIX), O_RDONLY, 0)) == -1))) {
			_kvm_syserr(kd, kd->program, "%s", uf);
a250 1
		}
d259 1
a259 4
		if ((uf && (kd->nlfd = open(uf, O_RDONLY, 0)) == -1) || (!uf &&
		    (kd->nlfd = open((uf = _PATH_KSYMS), O_RDONLY, 0)) == -1 &&
		    (kd->nlfd = open((uf = _PATH_UNIX), O_RDONLY, 0)) == -1)) {
			_kvm_syserr(kd, kd->program, "%s", uf);
a260 1
		}
d273 1
a273 4
	if (kvm_setfd(kd) == 0)
		return (kd);
	else
		_kvm_syserr(kd, kd->program, "can't set close on exec flag");
d284 22
a916 15
}

static int
kvm_setfd(kvm_t *kd)
{
	if (kd->pmfd >= 0 && fcntl(kd->pmfd, F_SETFD, FD_CLOEXEC) < 0)
		return (-1);
	if (kd->vmfd >= 0 && fcntl(kd->vmfd, F_SETFD, FD_CLOEXEC) < 0)
		return (-1);
	if (kd->nlfd >= 0 && fcntl(kd->nlfd, F_SETFD, FD_CLOEXEC) < 0)
		return (-1);
	if (kd->swfd >= 0 && fcntl(kd->swfd, F_SETFD, FD_CLOEXEC) < 0)
		return (-1);

	return (0);
@


1.51
log
@reduce use of <sys/user.h>
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.50 2013/10/17 08:02:21 deraadt Exp $ */
d74 1
a74 2
kvm_geterr(kd)
	kvm_t *kd;
@


1.50
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.49 2011/03/12 04:54:28 guenther Exp $ */
a37 1
#include <sys/user.h>
d47 1
@


1.49
log
@Replace the old, broken KERN_PROC ABI and its matching functions
in libkvm with the stable-ABI versions that are currently named
KERN_PROC2, kvm_get{proc,argv,envv}2().  The latter names and symbols
will continue to be supported for a few releases.

Committing now that they ports people have had a couple releases
to update pkgs that usd the old functions
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.48 2009/10/27 23:59:28 deraadt Exp $ */
d45 1
a45 1
#include <sys/exec_aout.h>
@


1.48
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.47 2009/06/07 03:09:34 millert Exp $ */
a180 1
	kd->procbase2 = 0;
a639 2
	if (kd->procbase2 != 0)
		free(kd->procbase2);
@


1.47
log
@Add kvm_getfile2 which uses KERN_FILE2 when possible, falling
back on kmem grovelling for non-live kernels.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.46 2009/01/21 22:18:00 miod Exp $ */
a35 8

#if defined(LIBC_SCCS) && !defined(lint)
#if 0
static char sccsid[] = "@@(#)kvm.c	8.2 (Berkeley) 2/13/94";
#else
static char *rcsid = "$OpenBSD: kvm.c,v 1.46 2009/01/21 22:18:00 miod Exp $";
#endif
#endif /* LIBC_SCCS and not lint */
@


1.46
log
@All operation on live kernels uses sysctl interface, there is no reason to
access the swap area. Change kvm_open() to no longer require a swap area,
and to not consider failure to open() it as fatal. Post-mortem analysis
would need an image of the swap area at the time of the crash, anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.45 2006/03/31 03:59:40 deraadt Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.45 2006/03/31 03:59:40 deraadt Exp $";
d187 1
d645 2
@


1.45
log
@careful cleanup following advice from lint.  be very very very careful
with sprinkling in size_t!
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.44 2006/03/31 03:09:17 deraadt Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.44 2006/03/31 03:09:17 deraadt Exp $";
a215 2
	if (sf == 0)
		sf = _PATH_DRUM;
d242 1
a242 1
		if ((kd->swfd = open(sf, flag, 0)) < 0) {
@


1.44
log
@kvm_openfiles() should take int flag, not unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.43 2006/03/20 15:11:48 mickey Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.43 2006/03/20 15:11:48 mickey Exp $";
d77 1
a77 1
		    int, char *);
d108 1
a108 1
_kvm_pwrite(kvm_t *kd, int fd, void *buf, size_t nbytes, off_t offset)
d138 1
a138 1
		    sizeof(kd->errbuf), (char *)fmt, ap);
d147 1
a147 1
	int n;
d157 1
a157 1
		(void)vsnprintf(cp, sizeof(kd->errbuf), (char *)fmt, ap);
d374 1
a374 1
	kd->cpu_data = _kvm_malloc(kd, cpu_hdr.c_size);
d378 3
a380 2
	sz = _kvm_pread(kd, kd->pmfd, kd->cpu_data, cpu_hdr.c_size, (off_t)offset);
	if (sz != cpu_hdr.c_size) {
d428 2
a429 1
	int	hdr_size, sz;
d462 1
a462 1
	sz = _kvm_pread(kd, kd->pmfd, kd->cpu_data, cpu_hdr.c_size,
d464 1
a464 1
	if (sz != cpu_hdr.c_size) {
d546 1
a546 1
	if (fwrite((void*)kd->kcore_hdr, sizeof(kcore_hdr_t), 1, fp) <= 0) {
d559 2
a560 2
	seghdr.c_size = ALIGN(kd->cpu_dsize);
	if (fwrite((void*)&seghdr, sizeof(seghdr), 1, fp) <= 0) {
d569 1
a569 1
	if (fwrite((void*)kd->cpu_data, kd->cpu_dsize, 1, fp) <= 0) {
d583 1
a583 1
	if (fwrite((void*)&seghdr, sizeof(seghdr), 1, fp) <= 0) {
d675 1
a675 1
	int dbversionlen;
d678 1
a678 1
	uf = basename((char *)uf);
d714 1
d726 1
a726 1
	bcopy((char *)rec.data, (char *)&nitem, sizeof(nitem));
d766 1
a766 1
		int len;
d790 4
a793 4
		bcopy((char *)&((struct nlist *)rec.data)->n_type,
		    (char *)&p->n_type, sizeof(p->n_type));
		bcopy((char *)&((struct nlist *)rec.data)->n_value,
		    (char *)&p->n_value, sizeof(p->n_value));
d804 1
a804 1
	struct nlist	nlist[2];
d812 2
a813 2
	nlist[0].n_name = "_dumpmag";
	nlist[1].n_name = NULL;
d815 1
a815 1
	if (kvm_nlist(kd, nlist) == -1) {
d820 2
a821 2
	if (nlist[0].n_value == 0) {
		_kvm_err(kd, nlist[0].n_name, "not in name list");
d825 1
a825 1
	if (_kvm_kvatop(kd, (u_long)nlist[0].n_value, &pa) == 0)
d840 1
a840 1
	int cc;
d870 1
a870 1
			cc = _kvm_pread(kd, kd->pmfd, cp, cc,
d902 1
a902 1
		cc = _kvm_pwrite(kd, kd->vmfd, (void*)buf, (size_t)len, (off_t)kva);
@


1.43
log
@for some of internal functions use paddr_t where phys addr is intended insteadd of u_long; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.42 2004/09/15 19:31:31 miod Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.42 2004/09/15 19:31:31 miod Exp $";
d595 1
a595 1
    unsigned int flag, char *errout)
@


1.42
log
@Kill (almost all) warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.41 2004/09/14 22:39:56 deraadt Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.41 2004/09/14 22:39:56 deraadt Exp $";
d802 2
a803 1
	u_long		pa, x;
d859 1
a859 1
			u_long	pa;
@


1.41
log
@KVM_NO_FILES is 0x80000000, so arg 4 of kvm_openfiles() must be unsigned
int instead of int; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.40 2004/08/11 18:45:58 jaredy Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.40 2004/08/11 18:45:58 jaredy Exp $";
d71 2
@


1.40
log
@free memory allocated by kvm_getproc2() in kvm_close()

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.39 2004/07/01 02:04:10 mickey Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.39 2004/07/01 02:04:10 mickey Exp $";
d593 1
a593 1
    int flag, char *errout)
@


1.39
log
@if sym has null value -- report as not found; check that kd->vmst is set before use; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.38 2004/06/15 03:52:58 deraadt Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.38 2004/06/15 03:52:58 deraadt Exp $";
d644 2
@


1.38
log
@knf; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.37 2004/02/23 23:19:09 deraadt Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.37 2004/02/23 23:19:09 deraadt Exp $";
d811 6
@


1.37
log
@more explicitly check against -1 for pread/pwrite error returns; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.36 2004/02/18 03:23:00 tedu Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.36 2004/02/18 03:23:00 tedu Exp $";
d99 1
a99 1
	return(rval);
d115 1
a115 1
	return(rval);
d145 1
a145 1
	register int n;
d153 1
a153 1
		register char *cp = kd->errbuf;
d164 1
a164 3
_kvm_malloc(kd, n)
	register kvm_t *kd;
	register size_t n;
d174 2
a175 7
_kvm_open(kd, uf, mf, sf, flag, errout)
	register kvm_t *kd;
	const char *uf;
	const char *mf;
	const char *sf;
	int flag;
	char *errout;
d192 1
a192 1
	kd->vmst = 0;
d202 1
a202 1
	}	
d279 1
a279 1
		 * The address translations however will fail without 
d309 1
a309 1
 *    
d314 1
a314 2
_kvm_get_header(kd)
	kvm_t	*kd;
d362 1
a362 1
	
d422 1
a422 3
kvm_dump_mkheader(kd, dump_off)
kvm_t	*kd;
off_t	dump_off;
d509 1
a509 4
clear_gap(kd, fp, size)
kvm_t	*kd;
FILE	*fp;
int	size;
d527 1
a527 4
kvm_dump_wrtheader(kd, fp, dumpsize)
kvm_t	*kd;
FILE	*fp;
int	dumpsize;
d592 2
a593 6
kvm_openfiles(uf, mf, sf, flag, errout)
	const char *uf;
	const char *mf;
	const char *sf;
	int flag;
	char *errout;
d595 1
a595 1
	register kvm_t *kd;
d606 2
a607 6
kvm_open(uf, mf, sf, flag, program)
	const char *uf;
	const char *mf;
	const char *sf;
	int flag;
	const char *program;
d609 1
a609 1
	register kvm_t *kd;
d620 1
a620 2
kvm_close(kd)
	kvm_t *kd;
d622 1
a622 1
	register int error = 0;
d659 1
a659 1
 * data base.  If the data base is out-of-data/incompatible with 
d664 1
a664 3
kvm_dbopen(kd, uf)
	kvm_t *kd;
	const char *uf;
d666 4
a670 5
	int dbversionlen;
	struct nlist nitem;
	char dbversion[_POSIX2_LINE_MAX];
	char kversion[_POSIX2_LINE_MAX];
	char dbname[MAXPATHLEN];
d720 1
a720 1
	if (kvm_read(kd, (u_long)nitem.n_value, kversion, dbversionlen) != 
d737 1
a737 3
kvm_nlist(kd, nl)
	kvm_t *kd;
	struct nlist *nl;
d739 2
a740 2
	register struct nlist *p;
	register int nvalid, rv;
d743 1
a743 1
	 * If we can't use the data base, revert to the 
d759 1
a759 1
		register int len;
d784 1
a784 2
		      (char *)&p->n_type, 
		      sizeof(p->n_type));
d786 1
a786 2
		      (char *)&p->n_value, 
		      sizeof(p->n_value));
d794 2
a795 2
int kvm_dump_inval(kd)
kvm_t	*kd;
d824 1
a824 5
kvm_read(kd, kva, buf, len)
	kvm_t *kd;
	register u_long kva;
	register void *buf;
	register size_t len;
d826 2
a827 2
	register int cc;
	register void *cp;
d849 1
a849 1
		
d880 1
a880 5
kvm_write(kd, kva, buf, len)
	kvm_t *kd;
	register u_long kva;
	register const void *buf;
	register size_t len;
d882 1
a882 1
	register int cc;
d904 1
a904 2
kvm_setfd(kd)
	kvm_t *kd;
@


1.36
log
@strlcpy is nicer.  ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.35 2004/01/09 16:51:07 millert Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.35 2004/01/09 16:51:07 millert Exp $";
d871 1
a871 1
		if (cc < 0) {
d894 1
a894 1
			if (cc < 0) {
d929 1
a929 1
		if (cc < 0) {
@


1.35
log
@Initialize procbase2 to 0 in _kvm_open(); Dan Harnett
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.34 2003/06/02 20:18:40 millert Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.34 2003/06/02 20:18:40 millert Exp $";
d304 1
a304 1
		(void)strncpy(errout, kd->errbuf, _POSIX2_LINE_MAX - 1);
d618 1
a618 1
		(void)strncpy(errout, strerror(errno), _POSIX2_LINE_MAX - 1);
@


1.34
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.33 2002/09/17 21:21:08 deraadt Exp $ */
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.33 2002/09/17 21:21:08 deraadt Exp $";
d193 1
@


1.33
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.32 2002/09/17 20:01:22 millert Exp $ */
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.32 2002/09/17 20:01:22 millert Exp $";
@


1.32
log
@Set close on exec flag for file descriptors opened by kvm_open().
Inspired by NetBSD.  deraadt@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.31 2002/06/08 22:31:24 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.31 2002/06/08 22:31:24 art Exp $";
d471 2
a472 1
	sz = _kvm_pread(kd, kd->pmfd, kd->cpu_data, cpu_hdr.c_size, (off_t)dump_off+hdr_size);
d850 2
a851 1
	if (_kvm_pwrite(kd, kd->pmfd, &x, sizeof(x), (off_t)_kvm_pa2off(kd, pa)) != sizeof(x)) {
d895 2
a896 1
			cc = _kvm_pread(kd, kd->pmfd, cp, cc, (off_t)_kvm_pa2off(kd, pa));
@


1.31
log
@Add a flag - KVM_NO_FILES which tells kvm_openfiles to not
open any files, just return an kvm handle that we can use to some
of the functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.30 2002/03/05 00:15:08 deraadt Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.30 2002/03/05 00:15:08 deraadt Exp $";
d81 1
d298 4
a301 1
	return (kd);
d941 16
@


1.30
log
@call open() with 3 args, for the heck of it
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.29 2002/02/19 19:39:37 millert Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.29 2002/02/19 19:39:37 millert Exp $";
d194 1
d208 5
d250 1
d651 1
@


1.29
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.28 2002/02/17 19:42:25 millert Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.28 2002/02/17 19:42:25 millert Exp $";
d240 1
a240 1
		if ((kd->vmfd = open(_PATH_KMEM, flag)) < 0) {
d258 3
a260 3
		    ((uf && (kd->nlfd = open(uf, O_RDONLY)) == -1) || (!uf &&
		    (kd->nlfd = open((uf = _PATH_KSYMS), O_RDONLY)) == -1 &&
		    (kd->nlfd = open((uf = _PATH_UNIX), O_RDONLY)) == -1))) {
d272 3
a274 3
		if ((uf && (kd->nlfd = open(uf, O_RDONLY)) == -1) || (!uf &&
		    (kd->nlfd = open((uf = _PATH_KSYMS), O_RDONLY)) == -1 &&
		    (kd->nlfd = open((uf = _PATH_UNIX), O_RDONLY)) == -1)) {
@


1.28
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.27 2002/02/16 21:27:26 millert Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.27 2002/02/16 21:27:26 millert Exp $";
d72 1
a88 6
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

a92 1
#ifdef	__STDC__
a93 8
#else
_kvm_pread(kd, fd, buf, nbytes, offset)
	kvm_t *kd;
	int fd;
	void *buf;
	size_t nbytes;
	off_t offset;
#endif
d95 1
a95 1
ssize_t rval;
a108 1
#ifdef	__STDC__
a109 8
#else
_kvm_pwrite(kd, fd, buf, nbytes, offset)
	kvm_t *kd;
	int fd;
	void *buf;
	size_t nbytes;
	off_t offset;
#endif
d111 1
a111 1
ssize_t rval;
a127 1
#ifdef __STDC__
a128 6
#else
_kvm_err(kd, program, fmt, va_alist)
	kvm_t *kd;
	char *program, *fmt;
	va_dcl
#endif
a131 1
#ifdef __STDC__
a132 3
#else
	va_start(ap);
#endif
a144 1
#ifdef __STDC__
a145 6
#else
_kvm_syserr(kd, program, fmt, va_alist)
	kvm_t *kd;
	char *program, *fmt;
	va_dcl
#endif
a149 1
#ifdef __STDC__
a150 3
#else
	va_start(ap);
#endif
@


1.27
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.26 2001/11/21 20:16:16 drahn Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.26 2001/11/21 20:16:16 drahn Exp $";
d77 2
a78 2
static kvm_t	*_kvm_open __P((kvm_t *, const char *, const char *,
		    const char *, int, char *));
@


1.26
log
@Use the address of the symbol, do not overwrite the address with 0, before
calling pwrite. Fix from dlucq. ok millert.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.25 2001/11/06 19:17:36 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.25 2001/11/06 19:17:36 art Exp $";
d75 2
a76 2
static int	kvm_dbopen __P((kvm_t *, const char *));
static int	_kvm_get_header __P((kvm_t *));
d79 1
a79 1
static int	clear_gap __P((kvm_t *, FILE *, int));
@


1.25
log
@Adapt to new uvm/ includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.24 2001/11/05 23:04:35 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.24 2001/11/05 23:04:35 art Exp $";
d865 1
a865 1
	u_long		pa;
d881 2
a882 2
	pa = 0;
	if (_kvm_pwrite(kd, kd->pmfd, &pa, sizeof(pa), (off_t)_kvm_pa2off(kd, pa)) != sizeof(pa)) {
@


1.24
log
@No need to pull in vm/vm_param.h in any of these files.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.23 2001/06/27 09:11:51 deraadt Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.23 2001/06/27 09:11:51 deraadt Exp $";
a58 2

#include <vm/vm.h>
@


1.23
log
@no more vm/swap_pager.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.22 2001/05/18 09:08:36 art Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.22 2001/05/18 09:08:36 art Exp $";
a60 1
#include <vm/vm_param.h>
@


1.22
log
@Convert lseek/{read,write} pairs into pread and pwrite.
from my todo list, work by Jonathon Fletcher <jonathon.fletcher@@pobox.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.21 2001/05/17 21:03:55 miod Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.21 2001/05/17 21:03:55 miod Exp $";
a61 1
#include <vm/swap_pager.h>
@


1.21
log
@Repair a fprintf message lacking one parameter.
Found by having a look at the recent TPE patches, which fixes libkvm
but not libkvm.old...
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.20 2001/01/04 21:51:04 todd Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.20 2001/01/04 21:51:04 todd Exp $";
a83 2
static off_t	Lseek __P((kvm_t *, int, off_t, int));
static ssize_t	Read __P(( kvm_t *, int, void *, size_t));
d99 50
a226 36
/*
 * Wrappers for Lseek/Read system calls.  They check for errors and
 * call _kvm_syserr() if appropriate.
 */
static off_t
Lseek(kd, fd, offset, whence)
	kvm_t	*kd;
	int	fd, whence;
	off_t	offset;
{
	off_t	off;

	errno = 0;
	if ((off = lseek(fd, offset, whence)) == -1 && errno != 0) {
		_kvm_syserr(kd, kd->program, "Lseek");
		return (-1);
	}
	return (off);
}

static ssize_t
Read(kd, fd, buf, nbytes)
	kvm_t	*kd;
	int	fd;
	void	*buf;
	size_t	nbytes;
{
	ssize_t	rv;

	errno = 0;

	if ((rv = read(fd, buf, nbytes)) != nbytes && errno != 0)
		_kvm_syserr(kd, kd->program, "Read");
	return (rv);
}

d374 2
a375 4
	if (Lseek(kd, kd->pmfd, (off_t)0, SEEK_SET) == -1)
		return (-1);
	sz = Read(kd, kd->pmfd, &kcore_hdr, sizeof(kcore_hdr));
	if (sz != sizeof(kcore_hdr))
d377 1
d407 2
a408 4
	if (Lseek(kd, kd->pmfd, (off_t)offset, SEEK_SET) == -1)
		goto fail;
	sz = Read(kd, kd->pmfd, &cpu_hdr, sizeof(cpu_hdr));
	if (sz != sizeof(cpu_hdr))
d410 2
d424 3
a426 4
	if (Lseek(kd, kd->pmfd, (off_t)offset, SEEK_SET) == -1)
		goto fail;
	sz = Read(kd, kd->pmfd, kd->cpu_data, cpu_hdr.c_size);
	if (sz != cpu_hdr.c_size)
d428 2
d435 2
a436 4
	if (Lseek(kd, kd->pmfd, (off_t)offset, SEEK_SET) == -1)
		goto fail;
	sz = Read(kd, kd->pmfd, &mem_hdr, sizeof(mem_hdr));
	if (sz != sizeof(mem_hdr))
d438 2
d490 2
a491 4
	if (Lseek(kd, kd->pmfd, dump_off, SEEK_SET) == -1)
		return (-1);
	sz = Read(kd, kd->pmfd, &cpu_hdr, sizeof(cpu_hdr));
	if (sz != sizeof(cpu_hdr))
d493 1
d508 2
a509 3
	if (Lseek(kd, kd->pmfd, dump_off+hdr_size, SEEK_SET) == -1)
		goto fail;
	sz = Read(kd, kd->pmfd, kd->cpu_data, cpu_hdr.c_size);
d520 3
a522 2
	if (Lseek(kd, kd->pmfd, kd->dump_off, SEEK_SET) == -1) {
		_kvm_err(kd, 0, "invalid dump offset");
a884 6
	errno = 0;
	if (lseek(kd->pmfd, _kvm_pa2off(kd, pa), SEEK_SET) == -1
		&& errno != 0) {
		_kvm_err(kd, 0, "cannot invalidate dump - lseek");
		return (-1);
	}
d886 2
a887 2
	if (write(kd->pmfd, &pa, sizeof(pa)) != sizeof(pa)) {
		_kvm_err(kd, 0, "cannot invalidate dump - write");
d908 2
a909 3
		errno = 0;
		if (lseek(kd->vmfd, (off_t)kva, SEEK_SET) == -1
			&& errno != 0) {
a911 5
		}
		cc = read(kd->vmfd, buf, len);
		if (cc < 0) {
			_kvm_syserr(kd, 0, "kvm_read");
			return (-1);
a922 1
			off_t	foff;
d930 2
a931 4
			foff = _kvm_pa2off(kd, pa);
			errno = 0;
			if (lseek(kd->pmfd, foff, SEEK_SET) == -1
				&& errno != 0) {
a934 5
			cc = read(kd->pmfd, cp, cc);
			if (cc < 0) {
				_kvm_syserr(kd, kd->program, "kvm_read");
				break;
			}
d965 2
a966 3
		errno = 0;
		if (lseek(kd->vmfd, (off_t)kva, SEEK_SET) == -1
			&& errno != 0) {
a967 5
			return (-1);
		}
		cc = write(kd->vmfd, buf, len);
		if (cc < 0) {
			_kvm_syserr(kd, 0, "kvm_write");
@


1.20
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.19 2000/10/25 23:37:38 deraadt Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.19 2000/10/25 23:37:38 deraadt Exp $";
d665 1
a665 1
		(void)fprintf(stderr, "%s: %s\n", strerror(errno));
@


1.19
log
@various savecore/kvm fixes; gluk@@ptci.ru, PR#1461
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.18 2000/10/23 06:59:42 aaron Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.18 2000/10/23 06:59:42 aaron Exp $";
d304 1
a304 1
		 * Initalize the virtual address translation machinery,
@


1.18
log
@Format string paranoia; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.17 1998/10/28 19:47:00 marc Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.17 1998/10/28 19:47:00 marc Exp $";
d343 1
a343 1
 *	  kcore_seg_t mem_hdr;
d388 2
d448 1
d455 1
a455 1
 *	  kcore_seg_t mem_hdr;
d486 1
a486 1
		return (0);
d519 1
a519 2
	if (kd->kcore_hdr == NULL) {
		_kvm_err(kd, 0, "missing header");
a520 1
	}
d707 1
a707 1
	return (0);
@


1.17
log
@Don't return error trying to make a dump header when no
crash dump exists
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.16 1998/08/24 05:32:39 millert Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.16 1998/08/24 05:32:39 millert Exp $";
d175 1
a175 1
		_kvm_err(kd, kd->program, strerror(errno));
@


1.16
log
@In kvm_open, if no file is specified, try /dev/ksyms and fall back to /bsd.  Also, if a file is specified, try the .db version of that file if it exists.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.15 1998/08/19 18:51:09 millert Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.15 1998/08/19 18:51:09 millert Exp $";
d483 1
a483 1
		return (-1);
@


1.15
log
@don't print 'unknown dbopen() error' when kvm_bsd.db doesn't exist
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.14 1998/07/11 05:57:16 deraadt Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.14 1998/07/11 05:57:16 deraadt Exp $";
d67 1
d79 1
a79 1
static int	kvm_dbopen __P((kvm_t *));
a224 1
	int ufgiven;
d244 1
a244 4
	ufgiven = (uf != NULL);
	if (!ufgiven)
		uf = _PATH_UNIX;
	else if (strlen(uf) >= MAXPATHLEN) {
d291 2
d294 4
a297 2
		if ((ufgiven || kvm_dbopen(kd) < 0) && 
		    (kd->nlfd = open(uf, O_RDONLY, 0)) < 0) {
d306 2
d309 3
a311 1
		if ((kd->nlfd = open(uf, O_RDONLY, 0)) < 0) {
d716 1
a716 1
kvm_dbopen(kd)
d718 1
d725 3
d729 2
a730 1
	kd->db = dbopen(_PATH_KVMDB, O_RDONLY, 0, DB_HASH, NULL);
d738 1
a738 1
			    "file %s is incorrectly formatted", _PATH_KVMDB);
@


1.14
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.13 1998/06/29 23:23:29 angelos Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.13 1998/06/29 23:23:29 angelos Exp $";
d723 3
@


1.13
log
@Fix a couple of error return values that I shouldn't have changed,
add some more verbose error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.12 1998/06/29 22:39:12 angelos Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.12 1998/06/29 22:39:12 angelos Exp $";
d721 16
a736 22
	if (kd->db == 0)
        {
                switch (errno)
                {
                        case EFTYPE:
                                _kvm_err(kd, kd->program,
					 "file %s is incorrectly formatted",
					 _PATH_KVMDB);
                                break;
                        case EINVAL:
                                _kvm_err(kd, kd->program,
					 "invalid argument to dbopen()");
                                break;
 
                        default:
                                _kvm_err(kd, kd->program,
					 "unknown dbopen() error");
                                break;
                }
   
                return (-1);
        }
d912 1
a912 1
                        /* In case of error, _kvm_kvatop sets the err string */
@


1.12
log
@Missed one; The problem was reported by msaitoh@@spa.is.uec.ac.jp, whom
I forgot to credit in my other commits.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.11 1998/06/29 22:27:05 angelos Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.11 1998/06/29 22:27:05 angelos Exp $";
d642 1
a642 1
		return (-1);
d660 1
a660 1
		return (-1);
d722 22
a743 1
		return (-1);
d918 1
@


1.11
log
@Do the right thing with error return values.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.10 1997/07/25 20:30:17 mickey Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.10 1997/07/25 20:30:17 mickey Exp $";
d899 1
a899 1
				return (0);
@


1.10
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.9 1997/06/18 05:10:16 kstailey Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.9 1997/06/18 05:10:16 kstailey Exp $";
d478 1
a478 1
		return (0);
d642 1
a642 1
		return (0);
d660 1
a660 1
		return (0);
d878 1
a878 1
			return (0);
d883 1
a883 1
			return (0);
d890 1
a890 1
			return (0);
d948 1
a948 1
			return (0);
d953 1
a953 1
			return (0);
d960 1
a960 1
		return (0);
@


1.9
log
@more error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.8 1997/06/11 10:32:15 grr Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.8 1997/06/11 10:32:15 grr Exp $";
d93 1
a93 1
#if __STDC__
d106 1
a106 1
#if __STDC__
d134 1
a134 1
#if __STDC__
d146 1
a146 1
#if __STDC__
@


1.8
log
@import some cleanup for libkvm/kvm.c from netbsd, udpate libkvm so that sparc can use libkvm vs. libkvm.old and update sparc pmap.c and machdep.c to make dumps compatible with the new libkvm's notions.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.7 1997/06/02 17:06:53 dm Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.7 1997/06/02 17:06:53 dm Exp $";
d492 2
a493 1
	if (sz != cpu_hdr.c_size)
d495 1
d502 2
a503 1
	if (Lseek(kd, kd->pmfd, kd->dump_off, SEEK_SET) == -1)
d505 1
d511 2
a512 1
	if (kd->kcore_hdr == NULL)
d514 1
@


1.7
log
@Man page claims O_WRONLY is allowed.  Why not?
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.6 1997/02/26 16:46:28 niklas Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.6 1997/02/26 16:46:28 niklas Exp $";
d78 1
a78 1
static int	kvm_dbopen __P((kvm_t *, const char *));
d224 1
d244 2
a245 1
	if (uf == 0)
d289 5
a293 6
		 * Open kvm nlist database.  We go ahead and do this
		 * here so that we don't have to hold on to the vmunix
		 * path name.  Since a kvm application will surely do
		 * a kvm_nlist(), this probably won't be a wasted effort.
		 * If the database cannot be opened, open the namelist
		 * argument so we revert to slow nlist() calls.
d295 1
a295 1
		if (kvm_dbopen(kd, uf) < 0 && 
d328 1
a328 1
		strcpy(errout, kd->errbuf);
d475 5
a479 4
	if (CORE_GETMAGIC(cpu_hdr) != KCORE_MAGIC)
		return (-1);
	if (CORE_GETMID(cpu_hdr) != MID_MACHINE)
		return (-1);
d518 3
a520 3
	_kvm_initvtop(kd);

	return(hdr_size);
d635 1
a635 1
		(void)strcpy(errout, strerror(errno));
d705 1
a705 1
kvm_dbopen(kd, uf)
a706 1
	const char *uf;
a707 1
	char *cp;
a712 4
	char dbname[MAXPATHLEN];

	if ((cp = strrchr(uf, '/')) != 0)
		uf = cp + 1;
d714 1
a714 2
	(void)snprintf(dbname, sizeof(dbname), "%skvm_%s.db", _PATH_VARDB, uf);
	kd->db = dbopen(dbname, O_RDONLY, 0, DB_HASH, NULL);
d763 1
a763 1
	register int nvalid;
d769 6
a774 2
	if (kd->db == 0)
		return (__fdnlist(kd->nlfd, nl));
@


1.6
log
@Switch alpha from libkvm.old to libkvm with code from NetBSD.
%x -> %lx format fixes from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.5 1997/01/17 07:11:59 millert Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.5 1997/01/17 07:11:59 millert Exp $";
d249 1
a249 1
	if (flag & ~O_RDWR) {
@


1.5
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: kvm.c,v 1.4 1996/05/10 12:58:30 deraadt Exp $ */
d45 1
a45 1
static char *rcsid = "$OpenBSD: kvm.c,v 1.4 1996/05/10 12:58:30 deraadt Exp $";
d872 1
a872 1
			_kvm_err(kd, 0, "invalid address (%x)", kva);
d942 1
a942 1
			_kvm_err(kd, 0, "invalid address (%x)", kva);
@


1.4
log
@sync with netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 1
a45 1
static char *rcsid = "$OpenBSD$";
d715 1
a715 1
	if ((cp = rindex(uf, '/')) != 0)
@


1.3
log
@sync with 0430
@
text
@d2 1
a2 1
/*	$NetBSD: kvm.c,v 1.42 1996/03/18 22:33:13 thorpej Exp $	*/
a63 3
#include <machine/vmparam.h>
#include <machine/kcore.h>

d239 2
a240 1
	kd->cpu_hdr = 0;
d332 11
d345 1
a345 1
kvm_t	*kd;
d347 5
a351 4
	cpu_kcore_hdr_t	ckhdr;
	kcore_hdr_t	khdr;
	kcore_seg_t	seghdr;
	off_t		offset;
d353 3
d358 2
a359 2

	if (Read(kd, kd->pmfd, &khdr, sizeof(khdr)) != sizeof(khdr))
a360 1
	offset = khdr.c_hdrsize;
d366 3
a368 3
	if ((CORE_GETMAGIC(khdr) != KCORE_MAGIC)
	     || ((CORE_GETMID(khdr) != MID_MACHINE)))
			return (-1);
d374 1
a374 1
	if (khdr.c_nseg != 2)
d378 9
a386 1
	 * Read the next segment header: cpu segment
d389 16
a404 7
		return (-1);
	if (Read(kd, kd->pmfd, &seghdr, sizeof(seghdr)) != sizeof(seghdr))
		return (-1);
	if (CORE_GETMAGIC(seghdr) != KCORESEG_MAGIC
		|| CORE_GETFLAG(seghdr) != CORE_CPU)
		return (-1);
	offset += khdr.c_seghdrsize;
d406 5
a410 4
		return (-1);
	if (Read(kd, kd->pmfd, &ckhdr, sizeof(ckhdr)) != sizeof(ckhdr))
		return (-1);
	offset += seghdr.c_size;
d416 9
a424 4
		return (-1);
	if (Read(kd, kd->pmfd, &seghdr, sizeof(seghdr)) != sizeof(seghdr))
		return (-1);
	offset += khdr.c_seghdrsize;
d426 2
a427 3
	if (CORE_GETMAGIC(seghdr) != KCORESEG_MAGIC
		|| CORE_GETFLAG(seghdr) != CORE_DATA)
		return (-1);
d429 3
a431 6
	kd->kcore_hdr = (kcore_hdr_t *)_kvm_malloc(kd, sizeof(*kd->kcore_hdr));
	if (kd->kcore_hdr == NULL)
		return (-1);
	kd->cpu_hdr = (cpu_kcore_hdr_t *)_kvm_malloc(kd, sizeof(*kd->cpu_hdr));
	if (kd->cpu_hdr == NULL) {
		free((void *)kd->kcore_hdr);
d433 5
a437 1
		return (-1);
a439 4
	*kd->kcore_hdr = khdr;
	*kd->cpu_hdr   = ckhdr;
	kd->dump_off   = offset;
	return (0);
d443 5
a447 1
 * Translate a physical address to a file-offset in the crash-dump.
a448 19
off_t
_kvm_pa2off(kd, pa)
	kvm_t	*kd;
	u_long	pa;
{
	off_t		off;
	phys_ram_seg_t	*rsp;

	off = 0;
	for (rsp = kd->cpu_hdr->ram_segs; rsp->size; rsp++) {
		if (pa >= rsp->start && pa < rsp->start + rsp->size) {
			pa -= rsp->start;
			break;
		}
		off += rsp->size;
	}
	return(pa + off + kd->dump_off);
}

d454 2
a455 4
	kcore_hdr_t	kch;
	kcore_seg_t	kseg;
	cpu_kcore_hdr_t	ckhdr;
	int		hdr_size;
a456 1
	hdr_size = 0;
d467 1
a467 1
	 * Check for new format crash dump
d471 4
a474 1
	if (Read(kd, kd->pmfd, &kseg, sizeof(kseg)) != sizeof(kseg))
d476 24
a499 14
	if ((CORE_GETMAGIC(kseg) == KCORE_MAGIC)
	     && ((CORE_GETMID(kseg) == MID_MACHINE))) {
		hdr_size += ALIGN(sizeof(kcore_seg_t));
		if (Lseek(kd, kd->pmfd, dump_off+hdr_size, SEEK_SET) == -1)
			return (-1);
		if (Read(kd, kd->pmfd, &ckhdr, sizeof(ckhdr)) != sizeof(ckhdr))
			return (-1);
		hdr_size += kseg.c_size;
		if (Lseek(kd, kd->pmfd, dump_off+hdr_size, SEEK_SET) == -1)
			return (-1);
		kd->cpu_hdr = (cpu_kcore_hdr_t *)
				_kvm_malloc(kd, sizeof(cpu_kcore_hdr_t));
		*kd->cpu_hdr = ckhdr;
	}
d504 3
a506 8
	kd->kcore_hdr = (kcore_hdr_t *) _kvm_malloc(kd, sizeof(kcore_hdr_t));
	if (kd->kcore_hdr == NULL) {
		if (kd->cpu_hdr != NULL) {
			free((void *)kd->cpu_hdr);
			kd->cpu_hdr = NULL;
		}
		return (-1);
	}
a513 12
	 * If there is no cpu_hdr at this point, we probably have an
	 * old format crash dump.....bail out
	 */
	if (kd->cpu_hdr == NULL) {
		free((void *)kd->kcore_hdr);
		kd->kcore_hdr = NULL;
		_kvm_err(kd, kd->program, "invalid dump");
	}

	kd->dump_off  = dump_off + hdr_size;

	/*
d519 12
d564 1
a564 1
	if (kd->kcore_hdr == NULL || kd->cpu_hdr == NULL) {
d586 1
a586 1
	seghdr.c_size = ALIGN(sizeof(cpu_kcore_hdr_t));
d596 1
a596 1
	if (fwrite((void*)kd->cpu_hdr, sizeof(cpu_kcore_hdr_t), 1, fp) <= 0) {
d601 1
a601 1
	gap     = seghdr.c_size - sizeof(cpu_kcore_hdr_t);
d676 3
a678 2
	if (kd->cpu_hdr != NULL)
		free((void *)kd->cpu_hdr);
d883 1
a883 1
		if ((kd->kcore_hdr == NULL) || (kd->cpu_hdr == NULL)) {
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d42 1
d44 3
a69 1
#include <kvm.h>
d77 1
d434 2
a435 2
kvm_dump_mkheader(kd_live, kd_dump, dump_off)
kvm_t	*kd_live, *kd_dump;
d444 2
a445 2
	if (kd_dump->kcore_hdr != NULL) {
	    _kvm_err(kd_dump, kd_dump->program, "already has a dump header");
d448 2
a449 2
	if (!ISALIVE(kd_live) || ISALIVE(kd_dump)) {
		_kvm_err(kd_live, kd_live->program, "wrong arguments");
d456 1
a456 1
	if (Lseek(kd_dump, kd_dump->pmfd, dump_off, SEEK_SET) == -1)
d458 1
a458 1
	if (Read(kd_dump, kd_dump->pmfd, &kseg, sizeof(kseg)) != sizeof(kseg))
d463 1
a463 2
		if (Lseek(kd_dump, kd_dump->pmfd, dump_off+hdr_size, SEEK_SET)
									== -1)
d465 1
a465 2
		if (Read(kd_dump, kd_dump->pmfd, &ckhdr, sizeof(ckhdr))
							!= sizeof(ckhdr))
d468 1
a468 2
		if (Lseek(kd_dump, kd_dump->pmfd, dump_off+hdr_size, SEEK_SET)
									== -1)
d470 3
a472 3
		kd_dump->cpu_hdr = (cpu_kcore_hdr_t *)
				_kvm_malloc(kd_dump, sizeof(cpu_kcore_hdr_t));
		*kd_dump->cpu_hdr = ckhdr;
d478 5
a482 6
	kd_dump->kcore_hdr = (kcore_hdr_t *)
				_kvm_malloc(kd_dump, sizeof(kcore_hdr_t));
	if (kd_dump->kcore_hdr == NULL) {
		if (kd_dump->cpu_hdr != NULL) {
			free((void *)kd_dump->cpu_hdr);
			kd_dump->cpu_hdr = NULL;
d487 4
a490 4
	kd_dump->kcore_hdr->c_hdrsize    = ALIGN(sizeof(kcore_hdr_t));
	kd_dump->kcore_hdr->c_seghdrsize = ALIGN(sizeof(kcore_seg_t));
	kd_dump->kcore_hdr->c_nseg       = 2;
	CORE_SETMAGIC(*(kd_dump->kcore_hdr), KCORE_MAGIC, MID_MACHINE,0);
d496 4
a499 4
	if (kd_dump->cpu_hdr == NULL) {
		free((void *)kd_dump->kcore_hdr);
		kd_dump->kcore_hdr = NULL;
		_kvm_err(kd_dump, kd_dump->program, "invalid dump");
d502 1
a502 1
	kd_dump->dump_off  = dump_off + hdr_size;
d507 1
a507 1
	_kvm_initvtop(kd_dump);
@


1.1
log
@Initial revision
@
text
@d1 2
d51 4
d60 1
d77 1
d80 3
d176 36
d236 3
d306 11
a316 2
		if (_kvm_initvtop(kd) < 0)
			goto failed;
d329 271
d654 4
d770 6
d797 34
d847 2
a848 1
		if (lseek(kd->vmfd, (off_t)kva, 0) == -1 && errno != 0) {
d860 4
d866 2
a867 1
			u_long pa;
d874 1
d876 2
a877 1
			if (lseek(kd->pmfd, (off_t)pa, 0) == -1 && errno != 0) {
d917 2
a918 1
		if (lseek(kd->vmfd, (off_t)kva, 0) == -1 && errno != 0) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
