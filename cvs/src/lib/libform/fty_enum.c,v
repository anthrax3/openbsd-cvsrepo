head	1.11;
access;
symbols
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.12
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.22
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.20
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.16
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.38
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.34
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.32
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.30
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.28
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.26
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.24
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.22
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.20
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.18
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.16
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.14
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.12
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.9.0.10
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	ncurses:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.01.23.22.48.51;	author krw;	state Exp;
branches;
next	1.10;
commitid	KTSX89RmrGrZOaBg;

1.10
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.22.18.02.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.22.18.27.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.08.22.47.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.25.16.39.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.05.17.03.04.18;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.07.24.02.37.43;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.40.17;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.24;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.21.37.52;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.02.21.37.52;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.11
log
@More missing $OpenBSD$.

ok nicm@@
@
text
@/*	$OpenBSD$	*/
/****************************************************************************
 * Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/***************************************************************************
*                                                                          *
*  Author : Juergen Pfeifer                                                *
*                                                                          *
***************************************************************************/

#include "form.priv.h"

MODULE_ID("$Id: fty_enum.c,v 1.10 2010/01/12 23:22:07 nicm Exp $")

typedef struct
  {
    char **kwds;
    int count;
    bool checkcase;
    bool checkunique;
  }
enumARG;

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static void *Make_Enum_Type( va_list * ap )
|   
|   Description   :  Allocate structure for enumeration type argument.
|
|   Return Values :  Pointer to argument structure or NULL on error
+--------------------------------------------------------------------------*/
static void *
Make_Enum_Type(va_list *ap)
{
  enumARG *argp = typeMalloc(enumARG, 1);

  if (argp)
    {
      int cnt = 0;
      char **kp = (char **)0;
      int ccase, cunique;

      T((T_CREATE("enumARG %p"), argp));
      argp->kwds = va_arg(*ap, char **);
      ccase = va_arg(*ap, int);
      cunique = va_arg(*ap, int);

      argp->checkcase = ccase ? TRUE : FALSE;
      argp->checkunique = cunique ? TRUE : FALSE;

      kp = argp->kwds;
      while (kp && (*kp++))
	cnt++;
      argp->count = cnt;
    }
  return (void *)argp;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static void *Copy_Enum_Type( const void * argp )
|   
|   Description   :  Copy structure for enumeration type argument.  
|
|   Return Values :  Pointer to argument structure or NULL on error.
+--------------------------------------------------------------------------*/
static void *
Copy_Enum_Type(const void *argp)
{
  enumARG *result = (enumARG *)0;

  if (argp)
    {
      const enumARG *ap = (const enumARG *)argp;

      result = typeMalloc(enumARG, 1);

      if (result)
	{
	  T((T_CREATE("enumARG %p"), result));
	  *result = *ap;
	}
    }
  return (void *)result;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static void Free_Enum_Type( void * argp )
|   
|   Description   :  Free structure for enumeration type argument.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
static void
Free_Enum_Type(void *argp)
{
  if (argp)
    free(argp);
}

#define SKIP_SPACE(x) while(((*(x))!='\0') && (is_blank(*(x)))) (x)++
#define NOMATCH 0
#define PARTIAL 1
#define EXACT   2

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static int Compare(const unsigned char * s,  
|                                       const unsigned char * buf,
|                                       bool  ccase )
|   
|   Description   :  Check whether or not the text in 'buf' matches the
|                    text in 's', at least partial.
|
|   Return Values :  NOMATCH   - buffer doesn't match
|                    PARTIAL   - buffer matches partially
|                    EXACT     - buffer matches exactly
+--------------------------------------------------------------------------*/
static int
Compare(const unsigned char *s, const unsigned char *buf,
	bool ccase)
{
  SKIP_SPACE(buf);		/* Skip leading spaces in both texts */
  SKIP_SPACE(s);

  if (*buf == '\0')
    {
      return (((*s) != '\0') ? NOMATCH : EXACT);
    }
  else
    {
      if (ccase)
	{
	  while (*s++ == *buf)
	    {
	      if (*buf++ == '\0')
		return EXACT;
	    }
	}
      else
	{
	  while (toupper(*s++) == toupper(*buf))
	    {
	      if (*buf++ == '\0')
		return EXACT;
	    }
	}
    }
  /* At this location buf points to the first character where it no longer
     matches with s. So if only blanks are following, we have a partial
     match otherwise there is no match */
  SKIP_SPACE(buf);
  if (*buf)
    return NOMATCH;

  /* If it happens that the reference buffer is at its end, the partial
     match is actually an exact match. */
  return ((s[-1] != '\0') ? PARTIAL : EXACT);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static bool Check_Enum_Field(
|                                      FIELD * field,
|                                      const void  * argp)
|   
|   Description   :  Validate buffer content to be a valid enumeration value
|
|   Return Values :  TRUE  - field is valid
|                    FALSE - field is invalid
+--------------------------------------------------------------------------*/
static bool
Check_Enum_Field(FIELD *field, const void *argp)
{
  char **kwds = ((const enumARG *)argp)->kwds;
  bool ccase = ((const enumARG *)argp)->checkcase;
  bool unique = ((const enumARG *)argp)->checkunique;
  unsigned char *bp = (unsigned char *)field_buffer(field, 0);
  char *s, *t, *p;
  int res;

  while (kwds && (s = (*kwds++)))
    {
      if ((res = Compare((unsigned char *)s, bp, ccase)) != NOMATCH)
	{
	  p = t = s;		/* t is at least a partial match */
	  if ((unique && res != EXACT))
	    {
	      while (kwds && (p = *kwds++))
		{
		  if ((res = Compare((unsigned char *)p, bp, ccase)) != NOMATCH)
		    {
		      if (res == EXACT)
			{
			  t = p;
			  break;
			}
		      else
			t = (char *)0;
		    }
		}
	    }
	  if (t)
	    {
	      set_field_buffer(field, 0, t);
	      return TRUE;
	    }
	  if (!p)
	    break;
	}
    }
  return FALSE;
}

static const char *dummy[] =
{(char *)0};

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static bool Next_Enum(FIELD * field,
|                                          const void * argp)
|   
|   Description   :  Check for the next enumeration value
|
|   Return Values :  TRUE  - next value found and loaded
|                    FALSE - no next value loaded
+--------------------------------------------------------------------------*/
static bool
Next_Enum(FIELD *field, const void *argp)
{
  const enumARG *args = (const enumARG *)argp;
  char **kwds = args->kwds;
  bool ccase = args->checkcase;
  int cnt = args->count;
  unsigned char *bp = (unsigned char *)field_buffer(field, 0);

  if (kwds)
    {
      while (cnt--)
	{
	  if (Compare((unsigned char *)(*kwds++), bp, ccase) == EXACT)
	    break;
	}
      if (cnt <= 0)
	kwds = args->kwds;
      if ((cnt >= 0) || (Compare((const unsigned char *)dummy, bp, ccase) == EXACT))
	{
	  set_field_buffer(field, 0, *kwds);
	  return TRUE;
	}
    }
  return FALSE;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static bool Previous_Enum(
|                                          FIELD * field,
|                                          const void * argp)
|   
|   Description   :  Check for the previous enumeration value
|
|   Return Values :  TRUE  - previous value found and loaded
|                    FALSE - no previous value loaded
+--------------------------------------------------------------------------*/
static bool
Previous_Enum(FIELD *field, const void *argp)
{
  const enumARG *args = (const enumARG *)argp;
  int cnt = args->count;
  char **kwds = &args->kwds[cnt - 1];
  bool ccase = args->checkcase;
  unsigned char *bp = (unsigned char *)field_buffer(field, 0);

  if (kwds)
    {
      while (cnt--)
	{
	  if (Compare((unsigned char *)(*kwds--), bp, ccase) == EXACT)
	    break;
	}

      if (cnt <= 0)
	kwds = &args->kwds[args->count - 1];

      if ((cnt >= 0) || (Compare((const unsigned char *)dummy, bp, ccase) == EXACT))
	{
	  set_field_buffer(field, 0, *kwds);
	  return TRUE;
	}
    }
  return FALSE;
}

static FIELDTYPE typeENUM =
{
  _HAS_ARGS | _HAS_CHOICE | _RESIDENT,
  1,				/* this is mutable, so we can't be const */
  (FIELDTYPE *)0,
  (FIELDTYPE *)0,
  Make_Enum_Type,
  Copy_Enum_Type,
  Free_Enum_Type,
  Check_Enum_Field,
  NULL,
  Next_Enum,
  Previous_Enum
};

NCURSES_EXPORT_VAR(FIELDTYPE *)
TYPE_ENUM = &typeENUM;

/* fty_enum.c ends here */
@


1.10
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d1 1
d38 1
a38 1
MODULE_ID("$Id: fty_enum.c,v 1.22 2007/10/13 19:32:26 tom Exp $")
@


1.9
log
@Update to ncurses-5.2-20010114
@
text
@d1 27
a27 1
/*	$OpenBSD: fty_enum.c,v 1.8 2000/10/22 18:27:24 millert Exp $	*/
a28 7

/*
 * THIS CODE IS SPECIFICALLY EXEMPTED FROM THE NCURSES PACKAGE COPYRIGHT.
 * You may freely copy it for use as a template for your own field types.
 * If you develop a field type that might be of general use, please send
 * it back to the ncurses maintainers for inclusion in the next version.
 */
d31 1
a31 1
*  Author : Juergen Pfeifer, juergen.pfeifer@@gmx.net                       *
d37 1
a37 1
MODULE_ID("$From: fty_enum.c,v 1.15 2000/12/09 23:46:12 tom Exp $")
d39 8
a46 6
typedef struct {
  char **kwds;
  int  count;
  bool checkcase;
  bool checkunique;
} enumARG;
d56 2
a57 1
static void *Make_Enum_Type(va_list * ap)
d59 1
a59 1
  enumARG *argp = (enumARG *)malloc(sizeof(enumARG));
d67 6
a72 4
      argp->kwds        = va_arg(*ap,char **);
      ccase             = va_arg(*ap,int);
      cunique           = va_arg(*ap,int);
      argp->checkcase   = ccase   ? TRUE : FALSE;
d76 2
a77 1
      while( kp && (*kp++) ) cnt++;
d91 2
a92 1
static void *Copy_Enum_Type(const void * argp)
d100 2
a101 1
      result = (enumARG *)malloc(sizeof(enumARG));
d103 4
a106 1
	*result = *ap;
d119 2
a120 1
static void Free_Enum_Type(void * argp)
d122 1
a122 1
  if (argp) 
d137 1
a137 1
|   Description   :  Check wether or not the text in 'buf' matches the
d144 3
a146 2
static int Compare(const unsigned char *s, const unsigned char *buf, 
		   bool ccase)
d148 1
a148 1
  SKIP_SPACE(buf); /* Skip leading spaces in both texts */
d151 1
a151 1
  if (*buf=='\0')
d153 3
a155 3
      return (((*s)!='\0') ? NOMATCH : EXACT);
    } 
  else 
d159 1
a159 1
	  while(*s++ == *buf)
d161 5
a165 4
	      if (*buf++=='\0') return EXACT;
	    } 
	} 
      else 
d167 1
a167 1
	  while(toupper(*s++)==toupper(*buf))
d169 2
a170 1
	      if (*buf++=='\0') return EXACT;
d178 1
a178 1
  if (*buf) 
d183 1
a183 1
  return ((s[-1]!='\0') ? PARTIAL : EXACT);
d197 2
a198 1
static bool Check_Enum_Field(FIELD * field, const void  * argp)
d200 4
a203 4
  char **kwds       = ((const enumARG *)argp)->kwds;
  bool ccase        = ((const enumARG *)argp)->checkcase;
  bool unique       = ((const enumARG *)argp)->checkunique;
  unsigned char *bp = (unsigned char *)field_buffer(field,0);
d206 2
a207 2
  
  while( kwds && (s=(*kwds++)) )
d209 1
a209 1
      if ((res=Compare((unsigned char *)s,bp,ccase))!=NOMATCH)
d211 2
a212 2
	  p=t=s; /* t is at least a partial match */
	  if ((unique && res!=EXACT)) 
d214 1
a214 1
	      while( kwds && (p = *kwds++) )
d216 1
a216 1
		  if ((res=Compare((unsigned char *)p,bp,ccase))!=NOMATCH)
d218 1
a218 1
		      if (res==EXACT)
d227 1
a227 1
	    }	  
d230 1
a230 1
	      set_field_buffer(field,0,t);
d240 2
a241 1
static const char *dummy[] = { (char *)0 };
d253 2
a254 1
static bool Next_Enum(FIELD * field, const void * argp)
d257 20
a276 19
  char **kwds       = args->kwds;
  bool ccase        = args->checkcase;
  int cnt           = args->count;
  unsigned char *bp = (unsigned char *)field_buffer(field,0);

  if (kwds) {
    while(cnt--)
      {
	if (Compare((unsigned char *)(*kwds++),bp,ccase)==EXACT) 
	  break;
      }
    if (cnt<=0)
      kwds = args->kwds;
    if ((cnt>=0) || (Compare((const unsigned char *)dummy,bp,ccase)==EXACT))
      {
	set_field_buffer(field,0,*kwds);
	return TRUE;
      }
  }
d291 2
a292 1
static bool Previous_Enum(FIELD * field, const void * argp)
d295 22
a316 21
  int cnt       = args->count;
  char **kwds   = &args->kwds[cnt-1];
  bool ccase    = args->checkcase;
  unsigned char *bp = (unsigned char *)field_buffer(field,0);

  if (kwds) {
    while(cnt--)
      {
	if (Compare((unsigned char *)(*kwds--),bp,ccase)==EXACT) 
	  break;
      }
    
    if (cnt<=0)
      kwds  = &args->kwds[args->count-1];
    
    if ((cnt>=0) || (Compare((const unsigned char *)dummy,bp,ccase)==EXACT))
      {
	set_field_buffer(field,0,*kwds);
	return TRUE;
      }
  }
d320 2
a321 2

static FIELDTYPE typeENUM = {
d323 1
a323 1
  1,                           /* this is mutable, so we can't be const */
d335 2
a336 1
NCURSES_EXPORT_VAR(FIELDTYPE*) TYPE_ENUM = &typeENUM;
@


1.8
log
@update to ncurses 5.2
@
text
@d1 1
a1 1
/*	$OpenBSD: fty_enum.c,v 1.7 2000/10/08 22:47:09 millert Exp $	*/
d18 1
a18 1
MODULE_ID("$From: fty_enum.c,v 1.14 2000/10/18 09:28:19 juergen Exp $")
d295 1
a295 1
FIELDTYPE* TYPE_ENUM = &typeENUM;
@


1.7
log
@update to ncurses-5.1-20001007
@
text
@d1 1
a1 1
/*	$OpenBSD: fty_enum.c,v 1.6 2000/04/25 16:39:05 millert Exp $	*/
d18 1
a18 1
MODULE_ID("$From: fty_enum.c,v 1.13 2000/09/10 00:55:26 juergen Exp $")
d52 1
a52 1
      while( (kp && *kp++) ) cnt++;
@


1.6
log
@Missed this in last ncurses sync
@
text
@d1 1
a1 1
/*	$OpenBSD: fty_enum.c,v 1.5 1999/05/17 03:04:18 millert Exp $	*/
d18 1
a18 1
MODULE_ID("$From: fty_enum.c,v 1.11 2000/03/19 01:09:56 Bruno.Haible Exp $")
a37 2
  char **kp;
  int cnt=0;
d41 2
d44 1
d50 1
a50 1
    
d52 1
a52 1
      while( (*kp++) ) cnt++;
a67 1
  const enumARG *ap = (const enumARG *)argp;
d72 2
d172 1
a172 1
  while( (s=(*kwds++)) )
d179 1
a179 1
	      while( (p = *kwds++) )
d225 14
a238 12
  while(cnt--)
    {
      if (Compare((unsigned char *)(*kwds++),bp,ccase)==EXACT) 
	break;
    }
  if (cnt<=0)
    kwds = args->kwds;
  if ((cnt>=0) || (Compare((const unsigned char *)dummy,bp,ccase)==EXACT))
    {
      set_field_buffer(field,0,*kwds);
      return TRUE;
    }
d261 16
a276 14
  while(cnt--)
    {
      if (Compare((unsigned char *)(*kwds--),bp,ccase)==EXACT) 
	break;
    }

  if (cnt<=0)
    kwds  = &args->kwds[args->count-1];

  if ((cnt>=0) || (Compare((const unsigned char *)dummy,bp,ccase)==EXACT))
    {
      set_field_buffer(field,0,*kwds);
      return TRUE;
    }
@


1.5
log
@ncurses-4.2-990516; no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fty_enum.c,v 1.4 1998/07/24 02:37:43 millert Exp $	*/
d18 1
a18 1
MODULE_ID("$From: fty_enum.c,v 1.10 1999/05/16 17:23:14 juergen Exp $")
d230 1
a230 1
  if ((cnt>=0) || (Compare((unsigned char *)dummy,bp,ccase)==EXACT))
d266 1
a266 1
  if ((cnt>=0) || (Compare((unsigned char *)dummy,bp,ccase)==EXACT))
@


1.4
log
@libform from ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
*  Author : Juergen Pfeifer, Juergen.Pfeifer@@T-Online.de                   *
d18 1
a18 1
MODULE_ID("$From: fty_enum.c,v 1.8 1997/10/18 19:33:20 tom Exp $")
@


1.3
log
@Merge of ncurses-4.1-971129
@
text
@d18 1
a18 1
MODULE_ID("Id: fty_enum.c,v 1.8 1997/10/18 19:33:20 tom Exp $")
@


1.2
log
@libform from ncurses 4.1.  Post 4.1 patches to be applied in a separate commit.
@
text
@d1 2
d18 1
a18 1
MODULE_ID("Id: fty_enum.c,v 1.5 1997/02/15 17:33:59 tom Exp $")
d68 1
a68 1
  enumARG *new = (enumARG *)0;
d72 3
a74 3
      new = (enumARG *)malloc(sizeof(enumARG));
      if (new)
	*new = *ap;
d76 1
a76 1
  return (void *)new;
d132 1
a132 1
	  while(toupper(*s)==toupper(*buf))
a133 1
	      s++;
d174 1
a174 1
	  t=s;
d185 3
a187 2
			}	
		      t = (char *)0;
d190 1
a190 1
	    }
d196 2
@


1.1
log
@Initial revision
@
text
@d8 5
d16 2
d65 1
a65 1
  enumARG *ap  = (enumARG *)argp;
d162 3
a164 3
  char **kwds       = ((enumARG *)argp)->kwds;
  bool ccase        = ((enumARG *)argp)->checkcase;
  bool unique       = ((enumARG *)argp)->checkunique;
d213 1
a213 1
  enumARG *args     = (enumARG *)argp;
d247 1
a247 1
  enumARG *args = (enumARG *)argp;
@


1.1.1.1
log
@SYSV-style form library; from ncurses
@
text
@@
