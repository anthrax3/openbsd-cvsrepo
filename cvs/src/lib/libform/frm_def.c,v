head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.14
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.12
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.22
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.20
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.16
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.14
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.12
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.10
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.6
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.38
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.34
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.32
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.30
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.28
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.26
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.24
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.22
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.20
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.18
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.16
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.14
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.12
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.10
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.8
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	ncurses:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.01.23.22.48.51;	author krw;	state Exp;
branches;
next	1.7;
commitid	KTSX89RmrGrZOaBg;

1.7
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.22.18.02.14;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.05.17.03.04.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.07.24.02.37.28;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.40.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.14;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.21.37.53;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.02.21.37.53;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@More missing $OpenBSD$.

ok nicm@@
@
text
@/*	$OpenBSD$	*/
/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *   Author:  Juergen Pfeifer, 1995,1997                                    *
 ****************************************************************************/

#include "form.priv.h"

MODULE_ID("$Id: frm_def.c,v 1.7 2010/01/12 23:22:07 nicm Exp $")

/* this can't be readonly */
static FORM default_form =
{
  0,				/* status     */
  0,				/* rows       */
  0,				/* cols       */
  0,				/* currow     */
  0,				/* curcol     */
  0,				/* toprow     */
  0,				/* begincol   */
  -1,				/* maxfield   */
  -1,				/* maxpage    */
  -1,				/* curpage    */
  ALL_FORM_OPTS,		/* opts       */
  (WINDOW *)0,			/* win        */
  (WINDOW *)0,			/* sub        */
  (WINDOW *)0,			/* w          */
  (FIELD **)0,			/* field      */
  (FIELD *)0,			/* current    */
  (_PAGE *) 0,			/* page       */
  (char *)0,			/* usrptr     */
  NULL,				/* forminit   */
  NULL,				/* formterm   */
  NULL,				/* fieldinit  */
  NULL				/* fieldterm  */
};

NCURSES_EXPORT_VAR(FORM *) _nc_Default_Form = &default_form;

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static FIELD *Insert_Field_By_Position(
|                                     FIELD *new_field, 
|                                     FIELD *head )
|   
|   Description   :  Insert new_field into sorted fieldlist with head "head"
|                    and return new head of sorted fieldlist. Sorting
|                    criteria is (row,column). This is a circular list.
|
|   Return Values :  New head of sorted fieldlist
+--------------------------------------------------------------------------*/
static FIELD *
Insert_Field_By_Position(FIELD *newfield, FIELD *head)
{
  FIELD *current, *newhead;

  assert(newfield);

  if (!head)
    {				/* empty list is trivial */
      newhead = newfield->snext = newfield->sprev = newfield;
    }
  else
    {
      newhead = current = head;
      while ((current->frow < newfield->frow) ||
	     ((current->frow == newfield->frow) &&
	      (current->fcol < newfield->fcol)))
	{
	  current = current->snext;
	  if (current == head)
	    {			/* We cycled through. Reset head to indicate that */
	      head = (FIELD *)0;
	      break;
	    }
	}
      /* we leave the loop with current pointing to the field after newfield */
      newfield->snext = current;
      newfield->sprev = current->sprev;
      newfield->snext->sprev = newfield;
      newfield->sprev->snext = newfield;
      if (current == head)
	newhead = newfield;
    }
  return (newhead);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static void Disconnect_Fields(FORM *form)
|   
|   Description   :  Break association between form and array of fields.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
static void
Disconnect_Fields(FORM *form)
{
  if (form->field)
    {
      FIELD **fields;

      for (fields = form->field; *fields; fields++)
	{
	  if (form == (*fields)->form)
	    (*fields)->form = (FORM *)0;
	}

      form->rows = form->cols = 0;
      form->maxfield = form->maxpage = -1;
      form->field = (FIELD **)0;
      if (form->page)
	free(form->page);
      form->page = (_PAGE *) 0;
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static int Connect_Fields(FORM *form, FIELD **fields)
|   
|   Description   :  Set association between form and array of fields.
|
|   Return Values :  E_OK            - no error
|                    E_CONNECTED     - a field is already connected
|                    E_BAD_ARGUMENT  - Invalid form pointer or field array
|                    E_SYSTEM_ERROR  - not enough memory
+--------------------------------------------------------------------------*/
static int
Connect_Fields(FORM *form, FIELD **fields)
{
  int field_cnt, j;
  int page_nr;
  int maximum_row_in_field, maximum_col_in_field;
  _PAGE *pg;

  T((T_CALLED("Connect_Fields(%p,%p)"), form, fields));

  assert(form);

  form->field = fields;
  form->maxfield = 0;
  form->maxpage = 0;

  if (!fields)
    RETURN(E_OK);

  page_nr = 0;
  /* store formpointer in fields and count pages */
  for (field_cnt = 0; fields[field_cnt]; field_cnt++)
    {
      if (fields[field_cnt]->form)
	RETURN(E_CONNECTED);
      if (field_cnt == 0 ||
	  (fields[field_cnt]->status & _NEWPAGE))
	page_nr++;
      fields[field_cnt]->form = form;
    }
  if (field_cnt == 0 || (short)field_cnt < 0)
    RETURN(E_BAD_ARGUMENT);

  /* allocate page structures */
  if ((pg = typeMalloc(_PAGE, page_nr)) != (_PAGE *) 0)
    {
      T((T_CREATE("_PAGE %p"), pg));
      form->page = pg;
    }
  else
    RETURN(E_SYSTEM_ERROR);

  /* Cycle through fields and calculate page boundaries as well as
     size of the form */
  for (j = 0; j < field_cnt; j++)
    {
      if (j == 0)
	pg->pmin = j;
      else
	{
	  if (fields[j]->status & _NEWPAGE)
	    {
	      pg->pmax = j - 1;
	      pg++;
	      pg->pmin = j;
	    }
	}

      maximum_row_in_field = fields[j]->frow + fields[j]->rows;
      maximum_col_in_field = fields[j]->fcol + fields[j]->cols;

      if (form->rows < maximum_row_in_field)
	form->rows = maximum_row_in_field;
      if (form->cols < maximum_col_in_field)
	form->cols = maximum_col_in_field;
    }

  pg->pmax = field_cnt - 1;
  form->maxfield = field_cnt;
  form->maxpage = page_nr;

  /* Sort fields on form pages */
  for (page_nr = 0; page_nr < form->maxpage; page_nr++)
    {
      FIELD *fld = (FIELD *)0;

      for (j = form->page[page_nr].pmin; j <= form->page[page_nr].pmax; j++)
	{
	  fields[j]->index = j;
	  fields[j]->page = page_nr;
	  fld = Insert_Field_By_Position(fields[j], fld);
	}
      if (fld)
	{
	  form->page[page_nr].smin = fld->index;
	  form->page[page_nr].smax = fld->sprev->index;
	}
      else
	{
	  form->page[page_nr].smin = 0;
	  form->page[page_nr].smax = 0;
	}
    }
  RETURN(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  static int Associate_Fields(FORM *form, FIELD **fields)
|   
|   Description   :  Set association between form and array of fields. 
|                    If there are fields, position to first active field.
|
|   Return Values :  E_OK            - success
|                    E_BAD_ARGUMENT  - Invalid form pointer or field array
|                    E_CONNECTED     - a field is already connected
|                    E_SYSTEM_ERROR  - not enough memory
+--------------------------------------------------------------------------*/
NCURSES_INLINE static int
Associate_Fields(FORM *form, FIELD **fields)
{
  int res = Connect_Fields(form, fields);

  if (res == E_OK)
    {
      if (form->maxpage > 0)
	{
	  form->curpage = 0;
	  form_driver(form, FIRST_ACTIVE_MAGIC);
	}
      else
	{
	  form->curpage = -1;
	  form->current = (FIELD *)0;
	}
    }
  return (res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  FORM *new_form( FIELD **fields )
|   
|   Description   :  Create new form with given array of fields.
|
|   Return Values :  Pointer to form. NULL if error occurred.
!                    Set errno:
|                    E_OK            - success
|                    E_BAD_ARGUMENT  - Invalid form pointer or field array
|                    E_CONNECTED     - a field is already connected
|                    E_SYSTEM_ERROR  - not enough memory
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(FORM *)
new_form(FIELD **fields)
{
  int err = E_SYSTEM_ERROR;

  FORM *form = typeMalloc(FORM, 1);

  T((T_CALLED("new_form(%p)"), fields));
  if (form)
    {
      T((T_CREATE("form %p"), form));
      *form = *_nc_Default_Form;
      if ((err = Associate_Fields(form, fields)) != E_OK)
	{
	  free_form(form);
	  form = (FORM *)0;
	}
    }

  if (!form)
    SET_ERROR(err);

  returnForm(form);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int free_form( FORM *form )
|   
|   Description   :  Release internal memory associated with form.
|
|   Return Values :  E_OK           - no error
|                    E_BAD_ARGUMENT - invalid form pointer
|                    E_POSTED       - form is posted
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
free_form(FORM *form)
{
  T((T_CALLED("free_form(%p)"), form));

  if (!form)
    RETURN(E_BAD_ARGUMENT);

  if (form->status & _POSTED)
    RETURN(E_POSTED);

  Disconnect_Fields(form);
  if (form->page)
    free(form->page);
  free(form);

  RETURN(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int set_form_fields( FORM *form, FIELD **fields )
|   
|   Description   :  Set a new association of an array of fields to a form
|
|   Return Values :  E_OK            - no error
|                    E_BAD_ARGUMENT  - Invalid form pointer or field array
|                    E_CONNECTED     - a field is already connected
|                    E_POSTED        - form is posted
|                    E_SYSTEM_ERROR  - not enough memory
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
set_form_fields(FORM *form, FIELD **fields)
{
  FIELD **old;
  int res;

  T((T_CALLED("set_form_fields(%p,%p)"), form, fields));

  if (!form)
    RETURN(E_BAD_ARGUMENT);

  if (form->status & _POSTED)
    RETURN(E_POSTED);

  old = form->field;
  Disconnect_Fields(form);

  if ((res = Associate_Fields(form, fields)) != E_OK)
    Connect_Fields(form, old);

  RETURN(res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  FIELD **form_fields( const FORM *form )
|   
|   Description   :  Retrieve array of fields
|
|   Return Values :  Pointer to field array
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(FIELD **)
form_fields(const FORM *form)
{
  T((T_CALLED("form_field(%p)"), form));
  returnFieldPtr(Normalize_Form(form)->field);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int field_count( const FORM *form )
|   
|   Description   :  Retrieve number of fields
|
|   Return Values :  Number of fields, -1 if none are defined
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
field_count(const FORM *form)
{
  T((T_CALLED("field_count(%p)"), form));

  returnCode(Normalize_Form(form)->maxfield);
}

/* frm_def.c ends here */
@


1.7
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d1 1
d36 1
a36 1
MODULE_ID("$Id: frm_def.c,v 1.23 2008/08/04 00:07:55 tom Exp $")
@


1.6
log
@Update to ncurses-5.2-20010114
@
text
@a0 2
/*	$OpenBSD: frm_def.c,v 1.5 1999/05/17 03:04:16 millert Exp $	*/

d2 1
a2 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d30 1
a30 1
 *   Author: Juergen Pfeifer <juergen.pfeifer@@gmx.net> 1995,1997            *
d35 1
a35 1
MODULE_ID("$From: frm_def.c,v 1.10 2000/12/10 02:09:38 tom Exp $")
d38 24
a61 23
static FORM default_form = {
  0,                                    /* status     */
  0,                                    /* rows       */
  0,                                    /* cols       */
  0,                                    /* currow     */
  0,                                    /* curcol     */
  0,                                    /* toprow     */
  0,                                    /* begincol   */
  -1,                                   /* maxfield   */
  -1,                                   /* maxpage    */
  -1,                                   /* curpage    */
  ALL_FORM_OPTS,                        /* opts       */
  (WINDOW *)0,                          /* win        */
  (WINDOW *)0,                          /* sub        */
  (WINDOW *)0,                          /* w          */
  (FIELD **)0,                          /* field      */
  (FIELD *)0,                           /* current    */
  (_PAGE *)0,                           /* page       */
  (char *)0,                            /* usrptr     */
  NULL,			                /* forminit   */
  NULL,                                 /* formterm   */
  NULL,                                 /* fieldinit  */
  NULL                                  /* fieldterm  */
d78 2
a79 1
static FIELD *Insert_Field_By_Position(FIELD *newfield, FIELD *head)
d82 1
a82 1
  
d86 1
a86 1
    { /* empty list is trivial */
d92 3
a94 3
      while((current->frow < newfield->frow) || 
	    ((current->frow==newfield->frow) && 
	     (current->fcol < newfield->fcol)) )
d97 2
a98 2
	  if (current==head)
	    { /* We cycled through. Reset head to indicate that */
d103 3
a105 3
      /* we leave the loop with current pointing to the field after newfield*/
      newfield->snext	 = current;
      newfield->sprev	 = current->sprev;
d108 1
a108 1
      if (current==head) 
d111 1
a111 1
  return(newhead);
d122 2
a123 1
static void Disconnect_Fields( FORM * form )
d129 1
a129 1
      for(fields=form->field;*fields;fields++)
d131 1
a131 1
	  if (form == (*fields)->form) 
d134 1
a134 1
      
d138 1
a138 1
      if (form->page) 
d140 2
a141 2
      form->page = (_PAGE *)0;
    }	
d155 2
a156 1
static int Connect_Fields(FORM  * form, FIELD ** fields)
d162 3
a164 1
  
d167 1
a167 1
  form->field    = fields;
d169 1
a169 1
  form->maxpage  = 0;
d173 1
a173 1
  
d176 1
a176 1
  for(field_cnt=0;fields[field_cnt];field_cnt++)
d178 1
a178 1
      if (fields[field_cnt]->form) 
d180 2
a181 2
      if ( field_cnt==0 || 
	  (fields[field_cnt]->status & _NEWPAGE)) 
d184 2
a185 2
    }	
  if (field_cnt==0)
d187 1
a187 1
  
d189 1
a189 1
  if ( (pg = (_PAGE *)malloc(page_nr * sizeof(_PAGE))) != (_PAGE *)0 )
d191 1
d196 1
a196 1
  
d199 1
a199 1
  for(j=0;j<field_cnt;j++)
d201 1
a201 1
      if (j==0) 
d207 1
a207 1
	      pg->pmax = j-1;
d212 1
a212 1
      
d215 2
a216 2
      
      if (form->rows < maximum_row_in_field) 
d218 1
a218 1
      if (form->cols < maximum_col_in_field) 
d221 2
a222 2
  
  pg->pmax       = field_cnt-1;
d224 2
a225 2
  form->maxpage  = page_nr; 
  
d227 1
a227 1
  for(page_nr = 0;page_nr < form->maxpage; page_nr++)
d230 2
a231 1
      for(j = form->page[page_nr].pmin;j <= form->page[page_nr].pmax;j++)
d234 12
a245 2
	  fields[j]->page  = page_nr;
	  fld = Insert_Field_By_Position(fields[j],fld);
a246 2
      form->page[page_nr].smin = fld->index;
      form->page[page_nr].smax = fld->sprev->index;
d259 3
a261 1
|                    any other       - error occured
d263 2
a264 1
INLINE static int Associate_Fields(FORM  *form, FIELD **fields)
d266 2
a267 1
  int res = Connect_Fields(form,fields);
d270 1
a270 1
      if (form->maxpage>0)
d273 1
a273 1
	  form_driver(form,FIRST_ACTIVE_MAGIC);
d279 1
a279 1
	} 
d281 1
a281 1
  return(res);
d283 1
a283 1
			    
d290 6
a295 1
|   Return Values :  Pointer to form. NULL if error occured.
d298 2
a299 2
new_form (FIELD ** fields)
{	
d302 3
a304 2
  FORM *form = (FORM *)malloc(sizeof(FORM));
  
d307 1
d309 1
a309 1
      if ((err=Associate_Fields(form,fields))!=E_OK)
d318 2
a319 2
  
  return(form);
d333 1
a333 1
free_form (FORM * form)
d335 3
a337 1
  if ( !form )	
d340 1
a340 1
  if ( form->status & _POSTED)  
d342 3
a344 3
  
  Disconnect_Fields( form );
  if (form->page) 
d347 1
a347 1
  
d357 5
a361 3
|   Return Values :  E_OK              - no error
|                    E_BAD_ARGUMENT    - invalid form pointer
|                    E_POSTED          - form is posted
d364 1
a364 1
set_form_fields (FORM  * form, FIELD ** fields)
d368 4
a371 2
  
  if ( !form )	
d374 1
a374 1
  if ( form->status & _POSTED )	
d376 1
a376 1
  
d378 5
a382 5
  Disconnect_Fields( form );
  
  if( (res = Associate_Fields( form, fields )) != E_OK )
    Connect_Fields( form, old );
  
d385 1
a385 1
	
d395 1
a395 1
form_fields (const FORM * form)
d397 2
a398 1
  return (Normalize_Form( form )->field);
d410 1
a410 1
field_count (const FORM * form)
d412 3
a414 1
  return (Normalize_Form( form )->maxfield);
@


1.5
log
@ncurses-4.2-990516; no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: frm_def.c,v 1.4 1998/07/24 02:37:28 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d37 1
a37 1
MODULE_ID("$From: frm_def.c,v 1.9 1999/05/16 17:20:43 juergen Exp $")
d65 1
a65 1
FORM *_nc_Default_Form = &default_form;
d274 2
a275 1
FORM *new_form(FIELD ** fields)
d307 2
a308 1
int free_form(FORM * form)
d334 2
a335 1
int set_form_fields(FORM  * form, FIELD ** fields)
d363 2
a364 1
FIELD **form_fields(const FORM * form)
d377 2
a378 1
int field_count(const FORM * form)
@


1.4
log
@libform from ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
 *   Author: Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de> 1995,1997        *
d37 1
a37 1
MODULE_ID("$From: frm_def.c,v 1.7 1998/02/11 12:13:42 tom Exp $")
@


1.3
log
@Merge of ncurses-4.1-971129
@
text
@d3 31
a33 21
/*-----------------------------------------------------------------------------+
|           The ncurses form library is  Copyright (C) 1995-1997               |
|             by Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de>                 |
|                          All Rights Reserved.                                |
|                                                                              |
| Permission to use, copy, modify, and distribute this software and its        |
| documentation for any purpose and without fee is hereby granted, provided    |
| that the above copyright notice appear in all copies and that both that      |
| copyright notice and this permission notice appear in supporting             |
| documentation, and that the name of the above listed copyright holder(s) not |
| be used in advertising or publicity pertaining to distribution of the        |
| software without specific, written prior permission.                         | 
|                                                                              |
| THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD TO  |
| THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FIT-  |
| NESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR   |
| ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RE- |
| SULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, |
| NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH    |
| THE USE OR PERFORMANCE OF THIS SOFTWARE.                                     |
+-----------------------------------------------------------------------------*/
d37 1
a37 1
MODULE_ID("Id: frm_def.c,v 1.6 1997/10/21 13:24:19 juergen Exp $")
@


1.2
log
@libform from ncurses 4.1.  Post 4.1 patches to be applied in a separate commit.
@
text
@d1 2
d27 1
a27 1
MODULE_ID("Id: frm_def.c,v 1.4 1997/05/01 16:47:54 juergen Exp $")
d114 3
a116 3
  FIELD **fields;
  
  assert(form && form->field);
d118 14
a131 13
  for(fields=form->field;*fields;fields++)
    {
      if (form == (*fields)->form) 
	(*fields)->form = (FORM *)0;
    }
  
  form->rows = form->cols = 0;
  form->maxfield = form->maxpage = -1;
  form->field = (FIELD **)0;
  if (form->page) 
    free(form->page);
  form->page = (_PAGE *)0;
}	
a365 26
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int scale_form( const FORM *form, int *rows, int *cols )
|   
|   Description   :  Retrieve size of form
|
|   Return Values :  E_OK              - no error
|                    E_BAD_ARGUMENT    - invalid form pointer
|                    E_NOT_CONNECTED   - no fields connected to form
+--------------------------------------------------------------------------*/
int scale_form(const FORM * form, int * rows, int * cols)
{
  if ( !form )
    RETURN(E_BAD_ARGUMENT);

  if ( !(form->field) )
    RETURN(E_NOT_CONNECTED);
  
  if (rows) 
    *rows = form->rows;
  if (cols) 
    *cols = form->cols;
  
  RETURN(E_OK);
@


1.1
log
@Initial revision
@
text
@d1 21
d23 1
a23 19
/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d25 1
a25 1
#include "form.priv.h"
@


1.1.1.1
log
@SYSV-style form library; from ncurses
@
text
@@
