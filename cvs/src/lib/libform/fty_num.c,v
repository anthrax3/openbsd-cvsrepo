head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.14
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.12
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.28
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.24
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.22
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.20
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.18
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.10
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.8
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	ncurses:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.01.23.22.48.51;	author krw;	state Exp;
branches;
next	1.8;
commitid	KTSX89RmrGrZOaBg;

1.8
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.05.13.41.43;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.22.18.02.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.05.17.03.04.18;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.07.24.02.37.47;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.40.19;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.21.37.52;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.02.21.37.52;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.9
log
@More missing $OpenBSD$.

ok nicm@@
@
text
@/*	$OpenBSD$	*/
/****************************************************************************
 * Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/***************************************************************************
*                                                                          *
*  Author : Juergen Pfeifer                                                *
*                                                                          *
***************************************************************************/

#include "form.priv.h"

MODULE_ID("$Id: fty_num.c,v 1.8 2010/01/12 23:22:07 nicm Exp $")

#if HAVE_LOCALE_H
#include <locale.h>
#endif

#if HAVE_LOCALE_H
#define isDecimalPoint(c) ((c) == ((L && L->decimal_point) ? *(L->decimal_point) : '.'))
#else
#define isDecimalPoint(c) ((c) == '.')
#endif

#if USE_WIDEC_SUPPORT
#define isDigit(c) (iswdigit((wint_t)(c)) || isdigit(UChar(c)))
#else
#define isDigit(c) isdigit(UChar(c))
#endif

#define thisARG numericARG

typedef struct
  {
    int precision;
    double low;
    double high;
    struct lconv *L;
  }
thisARG;

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void *Make_This_Type(va_list * ap)
|
|   Description   :  Allocate structure for numeric type argument.
|
|   Return Values :  Pointer to argument structure or NULL on error
+--------------------------------------------------------------------------*/
static void *
Make_This_Type(va_list *ap)
{
  thisARG *argn = typeMalloc(thisARG, 1);

  if (argn)
    {
      T((T_CREATE("thisARG %p"), argn));
      argn->precision = va_arg(*ap, int);
      argn->low = va_arg(*ap, double);
      argn->high = va_arg(*ap, double);

#if HAVE_LOCALE_H
      argn->L = localeconv();
#else
      argn->L = NULL;
#endif
    }
  return (void *)argn;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void *Copy_This_Type(const void * argp)
|
|   Description   :  Copy structure for numeric type argument.
|
|   Return Values :  Pointer to argument structure or NULL on error.
+--------------------------------------------------------------------------*/
static void *
Copy_This_Type(const void *argp)
{
  const thisARG *ap = (const thisARG *)argp;
  thisARG *result = (thisARG *) 0;

  if (argp)
    {
      result = typeMalloc(thisARG, 1);
      if (result)
	{
	  T((T_CREATE("thisARG %p"), result));
	  *result = *ap;
	}
    }
  return (void *)result;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void Free_This_Type(void * argp)
|
|   Description   :  Free structure for numeric type argument.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
static void
Free_This_Type(void *argp)
{
  if (argp)
    free(argp);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Check_This_Field(FIELD * field,
|                                                 const void * argp)
|
|   Description   :  Validate buffer content to be a valid numeric value
|
|   Return Values :  TRUE  - field is valid
|                    FALSE - field is invalid
+--------------------------------------------------------------------------*/
static bool
Check_This_Field(FIELD *field, const void *argp)
{
  const thisARG *argn = (const thisARG *)argp;
  double low = argn->low;
  double high = argn->high;
  int prec = argn->precision;
  unsigned char *bp = (unsigned char *)field_buffer(field, 0);
  char *s = (char *)bp;
  double val = 0.0;
  struct lconv *L = argn->L;
  char buf[64];
  bool result = FALSE;

  while (*bp && *bp == ' ')
    bp++;
  if (*bp)
    {
      if (*bp == '-' || *bp == '+')
	bp++;
#if USE_WIDEC_SUPPORT
      if (*bp)
	{
	  bool blank = FALSE;
	  int state = 0;
	  int len;
	  int n;
	  wchar_t *list = _nc_Widen_String((char *)bp, &len);

	  if (list != 0)
	    {
	      result = TRUE;
	      for (n = 0; n < len; ++n)
		{
		  if (blank)
		    {
		      if (list[n] != ' ')
			{
			  result = FALSE;
			  break;
			}
		    }
		  else if (list[n] == ' ')
		    {
		      blank = TRUE;
		    }
		  else if (isDecimalPoint(list[n]))
		    {
		      if (++state > 1)
			{
			  result = FALSE;
			  break;
			}
		    }
		  else if (!isDigit(list[n]))
		    {
		      result = FALSE;
		      break;
		    }
		}
	      free(list);
	    }
	}
#else
      while (*bp)
	{
	  if (!isdigit(UChar(*bp)))
	    break;
	  bp++;
	}
      if (isDecimalPoint(*bp))
	{
	  bp++;
	  while (*bp)
	    {
	      if (!isdigit(UChar(*bp)))
		break;
	      bp++;
	    }
	}
      while (*bp && *bp == ' ')
	bp++;
      result = (*bp == '\0');
#endif
      if (result)
	{
	  val = atof(s);
	  if (low < high)
	    {
	      if (val < low || val > high)
		result = FALSE;
	    }
	  if (result)
	    {
	      snprintf(buf, sizeof(buf), "%.*f", (prec > 0 ? prec : 0), val);
	      set_field_buffer(field, 0, buf);
	    }
	}
    }
  return (result);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Check_This_Character(
|                                      int c,
|                                      const void * argp)
|
|   Description   :  Check a character for the numeric type.
|
|   Return Values :  TRUE  - character is valid
|                    FALSE - character is invalid
+--------------------------------------------------------------------------*/
static bool
Check_This_Character(int c, const void *argp)
{
  const thisARG *argn = (const thisARG *)argp;
  struct lconv *L = argn->L;

  return ((isDigit(c) ||
	   c == '+' ||
	   c == '-' ||
	   isDecimalPoint(c))
	  ? TRUE
	  : FALSE);
}

static FIELDTYPE typeTHIS =
{
  _HAS_ARGS | _RESIDENT,
  1,				/* this is mutable, so we can't be const */
  (FIELDTYPE *)0,
  (FIELDTYPE *)0,
  Make_This_Type,
  Copy_This_Type,
  Free_This_Type,
  Check_This_Field,
  Check_This_Character,
  NULL,
  NULL
};

NCURSES_EXPORT_VAR(FIELDTYPE*) TYPE_NUMERIC = &typeTHIS;

/* fty_num.c ends here */
@


1.8
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d1 1
d38 1
a38 1
MODULE_ID("$Id: fty_num.c,v 1.25 2007/10/13 19:32:54 tom Exp $")
@


1.7
log
@sprintf->snprintf
@
text
@d1 27
a27 1
/*	$OpenBSD: fty_num.c,v 1.6 2001/01/22 18:02:17 millert Exp $	*/
a28 7

/*
 * THIS CODE IS SPECIFICALLY EXEMPTED FROM THE NCURSES PACKAGE COPYRIGHT.
 * You may freely copy it for use as a template for your own field types.
 * If you develop a field type that might be of general use, please send
 * it back to the ncurses maintainers for inclusion in the next version.
 */
d31 1
a31 1
*  Author : Juergen Pfeifer, juergen.pfeifer@@gmx.net                       *
d37 1
a37 1
MODULE_ID("$From: fty_num.c,v 1.14 2000/12/09 23:46:12 tom Exp $")
d43 22
a64 6
typedef struct {
  int    precision;
  double low;
  double high;
  struct lconv* L;
} numericARG;
d67 3
a69 3
|   Facility      :  libnform  
|   Function      :  static void *Make_Numeric_Type(va_list * ap)
|   
d74 2
a75 1
static void *Make_Numeric_Type(va_list * ap)
d77 1
a77 1
  numericARG *argn = (numericARG *)malloc(sizeof(numericARG));
d81 5
a85 3
      argn->precision = va_arg(*ap,int);
      argn->low       = va_arg(*ap,double);
      argn->high      = va_arg(*ap,double);
d87 1
a87 1
      argn->L         = localeconv();
d89 1
a89 1
      argn->L         = NULL;
d96 4
a99 4
|   Facility      :  libnform  
|   Function      :  static void *Copy_Numeric_Type(const void * argp)
|   
|   Description   :  Copy structure for numeric type argument.  
d103 2
a104 1
static void *Copy_Numeric_Type(const void * argp)
d106 2
a107 2
  const numericARG *ap = (const numericARG *)argp;
  numericARG *result = (numericARG *)0;
d111 1
a111 1
      result = (numericARG *)malloc(sizeof(numericARG));
d113 4
a116 1
	*result  = *ap;
d122 3
a124 3
|   Facility      :  libnform  
|   Function      :  static void Free_Numeric_Type(void * argp)
|   
d129 2
a130 1
static void Free_Numeric_Type(void * argp)
d132 1
a132 1
  if (argp) 
d137 4
a140 4
|   Facility      :  libnform  
|   Function      :  static bool Check_Numeric_Field(FIELD * field,
|                                                    const void * argp)
|   
d146 2
a147 1
static bool Check_Numeric_Field(FIELD * field, const void * argp)
d149 8
a156 8
  const numericARG *argn = (const numericARG *)argp;
  double low          = argn->low;
  double high         = argn->high;
  int prec            = argn->precision;
  unsigned char *bp   = (unsigned char *)field_buffer(field,0);
  char *s             = (char *)bp;
  double val          = 0.0;
  struct lconv* L     = argn->L;
d158 1
d160 2
a161 1
  while(*bp && *bp==' ') bp++;
d164 1
a164 1
      if (*bp=='-' || *bp=='+')
d166 2
a167 1
      while(*bp)
d169 45
a213 1
	  if (!isdigit(*bp)) break;
d216 1
a216 5
      if (*bp==(
#if HAVE_LOCALE_H
		(L && L->decimal_point) ? *(L->decimal_point) :
#endif
		'.'))
d219 1
a219 1
	  while(*bp)
d221 2
a222 1
	      if (!isdigit(*bp)) break;
d226 5
a230 2
      while(*bp && *bp==' ') bp++;
      if (*bp=='\0')
d233 6
a238 1
	  if (low<high)
d240 2
a241 1
	      if (val<low || val>high) return FALSE;
a242 3
	  snprintf(buf, sizeof(buf), "%.*f",(prec>0?prec:0),val);
	  set_field_buffer(field,0,buf);
	  return TRUE;
d245 1
a245 1
  return FALSE;
d249 2
a250 2
|   Facility      :  libnform  
|   Function      :  static bool Check_Numeric_Character(
d253 1
a253 1
|   
d259 2
a260 1
static bool Check_Numeric_Character(int c, const void * argp)
d262 2
a263 2
  const numericARG *argn = (const numericARG *)argp;
  struct lconv* L  = argn->L;  
d265 6
a270 9
  return (isdigit(c)  || 
	  c == '+'    || 
	  c == '-'    || 
	  c == (
#if HAVE_LOCALE_H
		(L && L->decimal_point) ? *(L->decimal_point) :
#endif
		'.')
	  ) ? TRUE : FALSE;
d273 2
a274 1
static FIELDTYPE typeNUMERIC = {
d276 1
a276 1
  1,                           /* this is mutable, so we can't be const */
d279 5
a283 5
  Make_Numeric_Type,
  Copy_Numeric_Type,
  Free_Numeric_Type,
  Check_Numeric_Field,
  Check_Numeric_Character,
d288 1
a288 1
NCURSES_EXPORT_VAR(FIELDTYPE*) TYPE_NUMERIC = &typeNUMERIC;
@


1.6
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: fty_num.c,v 1.5 1999/05/17 03:04:18 millert Exp $	*/
d146 1
a146 1
	  sprintf(buf,"%.*f",(prec>0?prec:0),val);
@


1.5
log
@ncurses-4.2-990516; no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fty_num.c,v 1.4 1998/07/24 02:37:47 millert Exp $	*/
d18 1
a18 1
MODULE_ID("$From: fty_num.c,v 1.13 1999/05/16 17:23:30 juergen Exp $")
d195 1
a195 1
FIELDTYPE* TYPE_NUMERIC = &typeNUMERIC;
@


1.4
log
@libform from ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d12 1
a12 1
*  Author : Juergen Pfeifer, Juergen.Pfeifer@@T-Online.de                   *
d18 1
a18 1
MODULE_ID("$From: fty_num.c,v 1.11 1997/10/18 19:32:58 tom Exp $")
@


1.3
log
@Merge of ncurses-4.1-971129
@
text
@d18 1
a18 1
MODULE_ID("Id: fty_num.c,v 1.11 1997/10/18 19:32:58 tom Exp $")
@


1.2
log
@libform from ncurses 4.1.  Post 4.1 patches to be applied in a separate commit.
@
text
@d1 2
d18 1
a18 1
MODULE_ID("Id: fty_num.c,v 1.9 1997/04/19 17:26:38 juergen Exp $")
d68 1
a68 1
  numericARG *new = (numericARG *)0;
d72 3
a74 3
      new = (numericARG *)malloc(sizeof(numericARG));
      if (new)
	*new  = *ap;
d76 1
a76 1
  return (void *)new;
d174 1
a174 1
#ifdef HAVE_LOCALE_H
@


1.1
log
@Initial revision
@
text
@d8 5
d15 4
d20 1
d46 1
d48 3
d65 1
a65 1
  numericARG *ap  = (numericARG *)argp;
d103 1
a103 1
  numericARG *argn    = (numericARG *)argp;
d123 5
a127 1
      if (*bp==((L && L->decimal_point) ? *(L->decimal_point) : '.'))
d144 1
a144 1
	  sprintf(buf,"%.*f",prec,val);
d165 1
a165 1
  numericARG *argn = (numericARG *)argp;
d171 6
a176 2
	  c == ((L && L->decimal_point) ? *(L->decimal_point) : '.')
	 ) ? TRUE : FALSE;
@


1.1.1.1
log
@SYSV-style form library; from ncurses
@
text
@@
