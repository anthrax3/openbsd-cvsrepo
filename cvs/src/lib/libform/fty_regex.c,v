head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.38
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.34
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.32
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.30
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.28
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.26
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.24
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.22
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.20
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.18
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.16
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.14
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.12
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	ncurses:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.01.23.22.48.51;	author krw;	state Exp;
branches;
next	1.8;
commitid	KTSX89RmrGrZOaBg;

1.8
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.22.18.02.17;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.05.17.03.04.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.01.24.19.29.38;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.07.24.02.37.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.40.19;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.04.01.27;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.21.37.52;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.02.21.37.52;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.9
log
@More missing $OpenBSD$.

ok nicm@@
@
text
@/*	$OpenBSD$	*/
/****************************************************************************
 * Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/***************************************************************************
*                                                                          *
*  Author : Juergen Pfeifer                                                *
*                                                                          *
***************************************************************************/

#include "form.priv.h"

MODULE_ID("$Id: fty_regex.c,v 1.8 2010/01/12 23:22:07 nicm Exp $")

#if HAVE_REGEX_H_FUNCS		/* We prefer POSIX regex */
#include <regex.h>

typedef struct
  {
    regex_t *pRegExp;
    unsigned long *refCount;
  }
RegExp_Arg;

#elif HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS
#undef RETURN
static int reg_errno;

static char *
RegEx_Init(char *instring)
{
  reg_errno = 0;
  return instring;
}

static char *
RegEx_Error(int code)
{
  reg_errno = code;
  return 0;
}

#define INIT 		register char *sp = RegEx_Init(instring);
#define GETC()		(*sp++)
#define PEEKC()		(*sp)
#define UNGETC(c)	(--sp)
#define RETURN(c)	return(c)
#define ERROR(c)	return RegEx_Error(c)

#if HAVE_REGEXP_H_FUNCS
#include <regexp.h>
#else
#include <regexpr.h>
#endif

typedef struct
{
  char *compiled_expression;
  unsigned long *refCount;
}
RegExp_Arg;

/* Maximum Length we allow for a compiled regular expression */
#define MAX_RX_LEN   (2048)
#define RX_INCREMENT (256)

#endif

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void *Make_RegularExpression_Type(va_list * ap)
|
|   Description   :  Allocate structure for regex type argument.
|
|   Return Values :  Pointer to argument structure or NULL on error
+--------------------------------------------------------------------------*/
static void *
Make_RegularExpression_Type(va_list *ap)
{
#if HAVE_REGEX_H_FUNCS
  char *rx = va_arg(*ap, char *);
  RegExp_Arg *preg;

  preg = typeMalloc(RegExp_Arg, 1);

  if (preg)
    {
      T((T_CREATE("RegExp_Arg %p"), preg));
      if (((preg->pRegExp = typeMalloc(regex_t, 1)) != 0)
	  && !regcomp(preg->pRegExp, rx,
		      (REG_EXTENDED | REG_NOSUB | REG_NEWLINE)))
	{
	  T((T_CREATE("regex_t %p"), preg->pRegExp));
	  preg->refCount = typeMalloc(unsigned long, 1);

	  *(preg->refCount) = 1;
	}
      else
	{
	  if (preg->pRegExp)
	    free(preg->pRegExp);
	  free(preg);
	  preg = (RegExp_Arg *)0;
	}
    }
  return ((void *)preg);
#elif HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS
  char *rx = va_arg(*ap, char *);
  RegExp_Arg *pArg;

  pArg = typeMalloc(RegExp_Arg, 1);

  if (pArg)
    {
      int blen = RX_INCREMENT;

      T((T_CREATE("RegExp_Arg %p"), pArg));
      pArg->compiled_expression = NULL;
      pArg->refCount = typeMalloc(unsigned long, 1);

      *(pArg->refCount) = 1;

      do
	{
	  char *buf = typeMalloc(char, blen);

	  if (buf)
	    {
#if HAVE_REGEXP_H_FUNCS
	      char *last_pos = compile(rx, buf, &buf[blen], '\0');

#else /* HAVE_REGEXPR_H_FUNCS */
	      char *last_pos = compile(rx, buf, &buf[blen]);
#endif
	      if (reg_errno)
		{
		  free(buf);
		  if (reg_errno == 50)
		    blen += RX_INCREMENT;
		  else
		    {
		      free(pArg);
		      pArg = NULL;
		      break;
		    }
		}
	      else
		{
		  pArg->compiled_expression = buf;
		  break;
		}
	    }
	}
      while (blen <= MAX_RX_LEN);
    }
  if (pArg && !pArg->compiled_expression)
    {
      free(pArg);
      pArg = NULL;
    }
  return (void *)pArg;
#else
  return 0;
#endif
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void *Copy_RegularExpression_Type(
|                                      const void * argp)
|
|   Description   :  Copy structure for regex type argument.
|
|   Return Values :  Pointer to argument structure or NULL on error.
+--------------------------------------------------------------------------*/
static void *
Copy_RegularExpression_Type(const void *argp)
{
#if (HAVE_REGEX_H_FUNCS | HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS)
  const RegExp_Arg *ap = (const RegExp_Arg *)argp;
  const RegExp_Arg *result = (const RegExp_Arg *)0;

  if (ap)
    {
      *(ap->refCount) += 1;
      result = ap;
    }
  return (void *)result;
#else
  return 0;
#endif
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void Free_RegularExpression_Type(void * argp)
|
|   Description   :  Free structure for regex type argument.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
static void
Free_RegularExpression_Type(void *argp)
{
#if HAVE_REGEX_H_FUNCS | HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS
  RegExp_Arg *ap = (RegExp_Arg *)argp;

  if (ap)
    {
      if (--(*(ap->refCount)) == 0)
	{
#if HAVE_REGEX_H_FUNCS
	  if (ap->pRegExp)
	    {
	      free(ap->refCount);
	      regfree(ap->pRegExp);
	    }
#elif HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS
	  if (ap->compiled_expression)
	    {
	      free(ap->refCount);
	      free(ap->compiled_expression);
	    }
#endif
	  free(ap);
	}
    }
#endif
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Check_RegularExpression_Field(
|                                      FIELD * field,
|                                      const void  * argp)
|
|   Description   :  Validate buffer content to be a valid regular expression
|
|   Return Values :  TRUE  - field is valid
|                    FALSE - field is invalid
+--------------------------------------------------------------------------*/
static bool
Check_RegularExpression_Field(FIELD *field, const void *argp)
{
  bool match = FALSE;

#if HAVE_REGEX_H_FUNCS
  const RegExp_Arg *ap = (const RegExp_Arg *)argp;

  if (ap && ap->pRegExp)
    match = (regexec(ap->pRegExp, field_buffer(field, 0), 0, NULL, 0)
	     ? FALSE
	     : TRUE);
#elif HAVE_REGEXP_H_FUNCS | HAVE_REGEXPR_H_FUNCS
  RegExp_Arg *ap = (RegExp_Arg *)argp;

  if (ap && ap->compiled_expression)
    match = (step(field_buffer(field, 0), ap->compiled_expression)
	     ? TRUE
	     : FALSE);
#endif
  return match;
}

static FIELDTYPE typeREGEXP =
{
  _HAS_ARGS | _RESIDENT,
  1,				/* this is mutable, so we can't be const */
  (FIELDTYPE *)0,
  (FIELDTYPE *)0,
  Make_RegularExpression_Type,
  Copy_RegularExpression_Type,
  Free_RegularExpression_Type,
  Check_RegularExpression_Field,
  NULL,
  NULL,
  NULL
};

NCURSES_EXPORT_VAR(FIELDTYPE*) TYPE_REGEXP = &typeREGEXP;

/* fty_regex.c ends here */
@


1.8
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d1 1
d38 1
a38 1
MODULE_ID("$Id: fty_regex.c,v 1.21 2007/10/13 19:33:50 tom Exp $")
@


1.7
log
@Update to ncurses-5.2-20010114
@
text
@d1 27
a27 1
/*	$OpenBSD: fty_regex.c,v 1.6 1999/05/17 03:04:18 millert Exp $	*/
a28 7

/*
 * THIS CODE IS SPECIFICALLY EXEMPTED FROM THE NCURSES PACKAGE COPYRIGHT.
 * You may freely copy it for use as a template for your own field types.
 * If you develop a field type that might be of general use, please send
 * it back to the ncurses maintainers for inclusion in the next version.
 */
d31 1
a31 1
*  Author : Juergen Pfeifer, juergen.pfeifer@@gmx.net                       *
d37 1
a37 1
MODULE_ID("$From: fty_regex.c,v 1.15 2000/12/09 23:46:12 tom Exp $")
d39 1
a39 1
#if HAVE_REGEX_H_FUNCS	/* We prefer POSIX regex */
d43 5
a47 4
{
  regex_t *pRegExp;
  unsigned long *refCount;
} RegExp_Arg;
d53 2
a54 1
static char *RegEx_Init(char *instring)
d56 2
a57 2
	reg_errno = 0;
	return instring;
d60 2
a61 1
static char *RegEx_Error(int code)
d63 2
a64 2
	reg_errno = code;
	return 0;
d84 2
a85 1
} RegExp_Arg;
d101 2
a102 1
static void *Make_RegularExpression_Type(va_list * ap)
d105 1
a105 1
  char *rx = va_arg(*ap,char *);
d108 2
a109 1
  preg = (RegExp_Arg*)malloc(sizeof(RegExp_Arg));
d112 4
a115 3
      if (((preg->pRegExp = (regex_t*)malloc(sizeof(regex_t))) != (regex_t*)0)
       && !regcomp(preg->pRegExp,rx,
		   (REG_EXTENDED | REG_NOSUB | REG_NEWLINE) ))
d117 3
a119 1
	  preg->refCount = (unsigned long *)malloc(sizeof(unsigned long));
d127 1
a127 1
	  preg = (RegExp_Arg*)0;
d130 1
a130 1
  return((void *)preg);
d132 1
a132 1
  char *rx = va_arg(*ap,char *);
d135 1
a135 1
  pArg = (RegExp_Arg *)malloc(sizeof(RegExp_Arg));
d140 2
d143 2
a144 1
      pArg->refCount = (unsigned long *)malloc(sizeof(unsigned long));
d147 6
a152 4
      do {
	char *buf = (char *)malloc(blen);
	if (buf)
	  {
d154 2
a155 1
	    char *last_pos = compile (rx, buf, &buf[blen], '\0');
d157 1
a157 1
	    char *last_pos = compile (rx, buf, &buf[blen]);
d159 20
a178 19
	    if (reg_errno)
	      {
		free(buf);
		if (reg_errno==50)
		  blen += RX_INCREMENT;
		else
		  {
		    free(pArg);
		    pArg = NULL;
		    break;
		  }
	      }
	    else
	      {
		pArg->compiled_expression = buf;
		break;
	      }
	  }
      } while( blen <= MAX_RX_LEN );
d200 2
a201 1
static void *Copy_RegularExpression_Type(const void * argp)
d226 2
a227 1
static void Free_RegularExpression_Type(void * argp)
d231 1
d266 2
a267 1
static bool Check_RegularExpression_Field(FIELD * field, const void  * argp)
d270 1
d272 2
a273 1
  const RegExp_Arg *ap = (const RegExp_Arg*)argp;
d275 3
a277 1
    match = (regexec(ap->pRegExp,field_buffer(field,0),0,NULL,0) ? FALSE:TRUE);
d280 1
d282 3
a284 1
    match = (step(field_buffer(field,0),ap->compiled_expression) ? TRUE:FALSE);
d289 2
a290 1
static FIELDTYPE typeREGEXP = {
d292 1
a292 1
  1,                           /* this is mutable, so we can't be const */
@


1.6
log
@ncurses-4.2-990516; no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fty_regex.c,v 1.5 1999/01/24 19:29:38 millert Exp $	*/
d18 1
a18 1
MODULE_ID("$From: fty_regex.c,v 1.14 1999/05/16 17:23:38 juergen Exp $")
d257 1
a257 1
FIELDTYPE* TYPE_REGEXP = &typeREGEXP;
@


1.5
log
@updates from ncurses-4.2-990123
@
text
@d1 1
a1 1
/*	$OpenBSD: fty_regex.c,v 1.4 1998/07/24 02:37:48 millert Exp $	*/
d12 1
a12 1
*  Author : Juergen Pfeifer, Juergen.Pfeifer@@T-Online.de                   *
d18 1
a18 1
MODULE_ID("$From: fty_regex.c,v 1.12 1999/01/24 03:24:42 Kimio.Ishii Exp $")
@


1.4
log
@libform from ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d18 1
a18 1
MODULE_ID("$From: fty_regex.c,v 1.11 1997/10/18 19:32:35 tom Exp $")
d71 1
a71 1
|   Facility      :  libnform  
d73 1
a73 1
|   
d108 1
a108 1
  
d122 2
a123 2
#else
	    char *last_pos = compile (rx, buf, &buf[blen], '\0');
d131 1
a131 1
		  {		   
d157 1
a157 1
|   Facility      :  libnform  
d160 2
a161 2
|   
|   Description   :  Copy structure for regex type argument.  
d169 2
a170 2
  const RegExp_Arg *result = (const RegExp_Arg *)0; 
  
d183 1
a183 1
|   Facility      :  libnform  
d185 1
a185 1
|   
d218 1
a218 1
|   Facility      :  libnform  
d222 1
a222 1
|   
@


1.3
log
@Merge of ncurses-4.1-971129
@
text
@d18 1
a18 1
MODULE_ID("Id: fty_regex.c,v 1.11 1997/10/18 19:32:35 tom Exp $")
@


1.2
log
@libform from ncurses 4.1.  Post 4.1 patches to be applied in a separate commit.
@
text
@d1 2
d18 1
a18 1
MODULE_ID("Id: fty_regex.c,v 1.9 1997/05/01 16:03:17 tom Exp $")
d20 1
a20 1
#if HAVE_REGEX_H	/* We prefer POSIX regex */
d29 1
a29 1
#elif HAVE_REGEXP_H | HAVE_REGEXPR_H
d52 1
a52 1
#if HAVE_REGEXP_H
d80 1
a80 1
#if HAVE_REGEX_H
d103 1
a103 1
#elif HAVE_REGEXP_H | HAVE_REGEXPR_H
d120 1
a120 1
#if HAVE_REGEXP_H
d167 1
a167 1
#if (HAVE_REGEX_H | HAVE_REGEXP_H | HAVE_REGEXPR_H)
d169 1
a169 1
  const RegExp_Arg *new = (const RegExp_Arg *)0; 
d174 1
a174 1
      new = ap;
d176 1
a176 1
  return (void *)new;
d192 1
a192 1
#if HAVE_REGEX_H | HAVE_REGEXP_H | HAVE_REGEXPR_H
d198 1
a198 1
#if HAVE_REGEX_H
d204 1
a204 1
#elif HAVE_REGEXP_H | HAVE_REGEXPR_H
d231 1
a231 1
#if HAVE_REGEX_H
d235 1
a235 1
#elif HAVE_REGEXP_H | HAVE_REGEXPR_H
@


1.1
log
@Initial revision
@
text
@d8 5
d16 2
d24 1
a24 1
  unsigned long refCount;
d27 1
a27 1
#elif HAVE_REGEXP_H
d50 1
d52 3
d59 1
a59 1
  unsigned long refCount;
d85 2
a86 2
      if ((preg->pRegExp = (regex_t*)malloc(sizeof(regex_t))) &&
	  !regcomp(preg->pRegExp,rx,
d89 2
a90 1
	  preg->refCount = 1;
d101 1
a101 1
#elif HAVE_REGEXP_H
d111 2
a112 1
      pArg->refCount = 1;
d118 1
d120 3
d165 3
a167 3
#if (HAVE_REGEX_H | HAVE_REGEXP_H)
  RegExp_Arg *ap  = (RegExp_Arg *)argp;
  RegExp_Arg *new = (RegExp_Arg *)0; 
d171 1
a171 1
      (ap->refCount)++;
d190 1
a190 1
#if HAVE_REGEX_H | HAVE_REGEXP_H
d194 1
a194 1
      if (--(ap->refCount) == 0)
d198 5
a202 2
	    regfree(ap->pRegExp);
#elif HAVE_REGEXP_H
d204 4
a207 1
	    free(ap->compiled_expression);
d230 1
a230 1
  RegExp_Arg *ap = (RegExp_Arg*)argp;
d233 1
a233 1
#elif HAVE_REGEXP_H
@


1.1.1.1
log
@SYSV-style form library; from ncurses
@
text
@@
