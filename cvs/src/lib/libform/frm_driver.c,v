head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.8
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.18
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.16
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.12
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.30
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.26
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.24
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.22
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.20
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.18
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.16
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.14
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.12
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.10
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.8
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	ncurses:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.01.23.22.48.51;	author krw;	state Exp;
branches;
next	1.10;
commitid	KTSX89RmrGrZOaBg;

1.10
date	2011.01.18.18.57.51;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.05.22.41.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.22.18.02.15;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.05.17.03.04.16;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.07.24.02.37.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.12.03.05.40.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.26.04.01.15;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.09.23.00.19.19;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.21.37.53;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.02.21.37.53;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.11
log
@More missing $OpenBSD$.

ok nicm@@
@
text
@/*	$OpenBSD$	*/
/****************************************************************************
 * Copyright (c) 1998-2007,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *   Author:  Juergen Pfeifer, 1995,1997                                    *
 ****************************************************************************/

#include "form.priv.h"

MODULE_ID("$Id: frm_driver.c,v 1.10 2011/01/18 18:57:51 nicm Exp $")

/*----------------------------------------------------------------------------
  This is the core module of the form library. It contains the majority
  of the driver routines as well as the form_driver function.

  Essentially this module is nearly the whole library. This is because
  all the functions in this module depends on some others in the module,
  so it makes no sense to split them into separate files because they
  will always be linked together. The only acceptable concern is turnaround
  time for this module, but now we have all Pentiums or RISCs, so what!

  The driver routines are grouped into nine generic categories:

   a)   Page Navigation            ( all functions prefixed by PN_ )
        The current page of the form is left and some new page is
        entered.
   b)   Inter-Field Navigation     ( all functions prefixed by FN_ )
        The current field of the form is left and some new field is
        entered.
   c)   Intra-Field Navigation     ( all functions prefixed by IFN_ )
        The current position in the current field is changed.
   d)   Vertical Scrolling         ( all functions prefixed by VSC_ )
        Essentially this is a specialization of Intra-Field navigation.
        It has to check for a multi-line field.
   e)   Horizontal Scrolling       ( all functions prefixed by HSC_ )
        Essentially this is a specialization of Intra-Field navigation.
        It has to check for a single-line field.
   f)   Field Editing              ( all functions prefixed by FE_ )
        The content of the current field is changed
   g)   Edit Mode requests         ( all functions prefixed by EM_ )
        Switching between insert and overlay mode
   h)   Field-Validation requests  ( all functions prefixed by FV_ )
        Perform verifications of the field.
   i)   Choice requests            ( all functions prefixed by CR_ )
        Requests to enumerate possible field values
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Some remarks on the placements of assert() macros :
  I use them only on "strategic" places, i.e. top level entries where
  I want to make sure that things are set correctly. Throughout subordinate
  routines I omit them mostly.
  --------------------------------------------------------------------------*/

/*
Some options that may effect compatibility in behavior to SVr4 forms,
but they are here to allow a more intuitive and user friendly behavior of
our form implementation. This doesn't affect the API, so we feel it is
uncritical.

The initial implementation tries to stay very close with the behavior
of the original SVr4 implementation, although in some areas it is quite
clear that this isn't the most appropriate way. As far as possible this
sources will allow you to build a forms lib that behaves quite similar
to SVr4, but now and in the future we will give you better options.
Perhaps at some time we will make this configurable at runtime.
*/

/* Implement a more user-friendly previous/next word behavior */
#define FRIENDLY_PREV_NEXT_WORD (1)
/* Fix the wrong behavior for forms with all fields inactive */
#define FIX_FORM_INACTIVE_BUG (1)
/* Allow dynamic field growth also when navigating past the end */
#define GROW_IF_NAVIGATE (1)

#if USE_WIDEC_SUPPORT
#define myADDNSTR(w, s, n) wadd_wchnstr(w, s, n)
#define myINSNSTR(w, s, n) wins_wchnstr(w, s, n)
#define myINNSTR(w, s, n)  fix_wchnstr(w, s, n)
#define myWCWIDTH(w, y, x) cell_width(w, y, x)
#else
#define myADDNSTR(w, s, n) waddnstr(w, s, n)
#define myINSNSTR(w, s, n) winsnstr(w, s, n)
#define myINNSTR(w, s, n)  winnstr(w, s, n)
#define myWCWIDTH(w, y, x) 1
#endif

/*----------------------------------------------------------------------------
  Forward references to some internally used static functions
  --------------------------------------------------------------------------*/
static int Inter_Field_Navigation(int (*const fct) (FORM *), FORM *form);
static int FN_Next_Field(FORM *form);
static int FN_Previous_Field(FORM *form);
static int FE_New_Line(FORM *);
static int FE_Delete_Previous(FORM *);

/*----------------------------------------------------------------------------
  Macro Definitions.

  Some Remarks on that: I use the convention to use UPPERCASE for constants
  defined by Macros. If I provide a macro as a kind of inline routine to
  provide some logic, I use my Upper_Lower case style.
  --------------------------------------------------------------------------*/

/* Calculate the position of a single row in a field buffer */
#define Position_Of_Row_In_Buffer(field,row) ((row)*(field)->dcols)

/* Calculate start address for the fields buffer# N */
#define Address_Of_Nth_Buffer(field,N) \
  ((field)->buf + (N)*(1+Buffer_Length(field)))

/* Calculate the start address of the row in the fields specified buffer# N */
#define Address_Of_Row_In_Nth_Buffer(field,N,row) \
  (Address_Of_Nth_Buffer(field,N) + Position_Of_Row_In_Buffer(field,row))

/* Calculate the start address of the row in the fields primary buffer */
#define Address_Of_Row_In_Buffer(field,row) \
  Address_Of_Row_In_Nth_Buffer(field,0,row)

/* Calculate the start address of the row in the forms current field
   buffer# N */
#define Address_Of_Current_Row_In_Nth_Buffer(form,N) \
   Address_Of_Row_In_Nth_Buffer((form)->current,N,(form)->currow)

/* Calculate the start address of the row in the forms current field
   primary buffer */
#define Address_Of_Current_Row_In_Buffer(form) \
   Address_Of_Current_Row_In_Nth_Buffer(form,0)

/* Calculate the address of the cursor in the forms current field
   primary buffer */
#define Address_Of_Current_Position_In_Nth_Buffer(form,N) \
   (Address_Of_Current_Row_In_Nth_Buffer(form,N) + (form)->curcol)

/* Calculate the address of the cursor in the forms current field
   buffer# N */
#define Address_Of_Current_Position_In_Buffer(form) \
  Address_Of_Current_Position_In_Nth_Buffer(form,0)

/* Logic to decide whether or not a field is actually a field with
   vertical or horizontal scrolling */
#define Is_Scroll_Field(field)          \
   (((field)->drows > (field)->rows) || \
    ((field)->dcols > (field)->cols))

/* Logic to decide whether or not a field needs to have an individual window
   instead of a derived window because it contains invisible parts.
   This is true for non-public fields and for scrollable fields. */
#define Has_Invisible_Parts(field)     \
  (!((field)->opts & O_PUBLIC)      || \
   Is_Scroll_Field(field))

/* Logic to decide whether or not a field needs justification */
#define Justification_Allowed(field)        \
   (((field)->just != NO_JUSTIFICATION)  && \
    (Single_Line_Field(field))           && \
    (((field)->dcols == (field)->cols)   && \
    ((field)->opts & O_STATIC))             )

/* Logic to determine whether or not a dynamic field may still grow */
#define Growable(field) ((field)->status & _MAY_GROW)

/* Macro to set the attributes for a fields window */
#define Set_Field_Window_Attributes(field,win) \
(  wbkgdset((win),(chtype)((field)->pad | (field)->back)), \
   wattrset((win),(field)->fore) )

/* Logic to decide whether or not a field really appears on the form */
#define Field_Really_Appears(field)         \
  ((field->form)                          &&\
   (field->form->status & _POSTED)        &&\
   (field->opts & O_VISIBLE)              &&\
   (field->page == field->form->curpage))

/* Logic to determine whether or not we are on the first position in the
   current field */
#define First_Position_In_Current_Field(form) \
  (((form)->currow==0) && ((form)->curcol==0))

#define Minimum(a,b) (((a)<=(b)) ? (a) : (b))
#define Maximum(a,b) (((a)>=(b)) ? (a) : (b))

/*----------------------------------------------------------------------------
  Useful constants
  --------------------------------------------------------------------------*/
static FIELD_CELL myBLANK = BLANK;
static FIELD_CELL myZEROS;

#ifdef TRACE
static void
check_pos(FORM *form, int lineno)
{
  int y, x;

  if (form && form->w)
    {
      getyx(form->w, y, x);
      if (y != form->currow || x != form->curcol)
	{
	  T(("CHECKPOS %s@@%d have position %d,%d vs want %d,%d",
	     __FILE__, lineno,
	     y, x,
	     form->currow, form->curcol));
	}
    }
}
#define CHECKPOS(form) check_pos(form, __LINE__)
#else
#define CHECKPOS(form)		/* nothing */
#endif

/*----------------------------------------------------------------------------
  Wide-character special functions
  --------------------------------------------------------------------------*/
#if USE_WIDEC_SUPPORT
/* like winsnstr */
static int
wins_wchnstr(WINDOW *w, cchar_t *s, int n)
{
  int code = ERR;
  int y, x;

  while (n-- > 0)
    {
      getyx(w, y, x);
      if ((code = wins_wch(w, s++)) != OK)
	break;
      if ((code = wmove(w, y, x + 1)) != OK)
	break;
    }
  return code;
}

/* win_wchnstr is inconsistent with winnstr, since it returns OK rather than
 * the number of items transferred.
 */
static int
fix_wchnstr(WINDOW *w, cchar_t *s, int n)
{
  int x;

  win_wchnstr(w, s, n);
  /*
   * This function is used to extract the text only from the window.
   * Strip attributes and color from the string so they will not be added
   * back when copying the string to the window.
   */
  for (x = 0; x < n; ++x)
    {
      RemAttr(s[x], A_ATTRIBUTES);
      SetPair(s[x], 0);
    }
  return n;
}

/*
 * Returns the column of the base of the given cell.
 */
static int
cell_base(WINDOW *win, int y, int x)
{
  int result = x;

  while (LEGALYX(win, y, x))
    {
      cchar_t *data = &(win->_line[y].text[x]);

      if (isWidecBase(CHDEREF(data)) || !isWidecExt(CHDEREF(data)))
	{
	  result = x;
	  break;
	}
      --x;
    }
  return result;
}

/*
 * Returns the number of columns needed for the given cell in a window.
 */
static int
cell_width(WINDOW *win, int y, int x)
{
  int result = 1;

  if (LEGALYX(win, y, x))
    {
      cchar_t *data = &(win->_line[y].text[x]);

      if (isWidecExt(CHDEREF(data)))
	{
	  /* recur, providing the number of columns to the next character */
	  result = cell_width(win, y, x - 1);
	}
      else
	{
	  result = wcwidth(CharOf(CHDEREF(data)));
	}
    }
  return result;
}

/*
 * There is no wide-character function such as wdel_wch(), so we must find
 * all of the cells that comprise a multi-column character and delete them
 * one-by-one.
 */
static void
delete_char(FORM *form)
{
  int cells = cell_width(form->w, form->currow, form->curcol);

  form->curcol = cell_base(form->w, form->currow, form->curcol);
  wmove(form->w, form->currow, form->curcol);
  while (cells-- > 0)
    {
      wdelch(form->w);
    }
}
#define DeleteChar(form) delete_char(form)
#else
#define DeleteChar(form) \
	  wmove((form)->w, (form)->currow, (form)->curcol), \
	  wdelch((form)->w)
#endif

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static char *Get_Start_Of_Data(char * buf, int blen)
|
|   Description   :  Return pointer to first non-blank position in buffer.
|                    If buffer is empty return pointer to buffer itself.
|
|   Return Values :  Pointer to first non-blank position in buffer
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD_CELL *
Get_Start_Of_Data(FIELD_CELL *buf, int blen)
{
  FIELD_CELL *p = buf;
  FIELD_CELL *end = &buf[blen];

  assert(buf && blen >= 0);
  while ((p < end) && ISBLANK(*p))
    p++;
  return ((p == end) ? buf : p);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static char *After_End_Of_Data(char * buf, int blen)
|
|   Description   :  Return pointer after last non-blank position in buffer.
|                    If buffer is empty, return pointer to buffer itself.
|
|   Return Values :  Pointer to position after last non-blank position in
|                    buffer.
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD_CELL *
After_End_Of_Data(FIELD_CELL *buf, int blen)
{
  FIELD_CELL *p = &buf[blen];

  assert(buf && blen >= 0);
  while ((p > buf) && ISBLANK(p[-1]))
    p--;
  return (p);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static char *Get_First_Whitespace_Character(
|                                     char * buf, int   blen)
|
|   Description   :  Position to the first whitespace character.
|
|   Return Values :  Pointer to first whitespace character in buffer.
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD_CELL *
Get_First_Whitespace_Character(FIELD_CELL *buf, int blen)
{
  FIELD_CELL *p = buf;
  FIELD_CELL *end = &p[blen];

  assert(buf && blen >= 0);
  while ((p < end) && !ISBLANK(*p))
    p++;
  return ((p == end) ? buf : p);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static char *After_Last_Whitespace_Character(
|                                     char * buf, int blen)
|
|   Description   :  Get the position after the last whitespace character.
|
|   Return Values :  Pointer to position after last whitespace character in
|                    buffer.
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD_CELL *
After_Last_Whitespace_Character(FIELD_CELL *buf, int blen)
{
  FIELD_CELL *p = &buf[blen];

  assert(buf && blen >= 0);
  while ((p > buf) && !ISBLANK(p[-1]))
    p--;
  return (p);
}

/* Set this to 1 to use the div_t version. This is a good idea if your
   compiler has an intrinsic div() support. Unfortunately GNU-C has it
   not yet.
   N.B.: This only works if form->curcol follows immediately form->currow
         and both are of type int.
*/
#define USE_DIV_T (0)

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void Adjust_Cursor_Position(
|                                       FORM * form, const char * pos)
|
|   Description   :  Set current row and column of the form to values
|                    corresponding to the buffer position.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_INLINE static void
Adjust_Cursor_Position(FORM *form, const FIELD_CELL *pos)
{
  FIELD *field;
  int idx;

  field = form->current;
  assert(pos >= field->buf && field->dcols > 0);
  idx = (int)(pos - field->buf);
#if USE_DIV_T
  *((div_t *) & (form->currow)) = div(idx, field->dcols);
#else
  form->currow = idx / field->dcols;
  form->curcol = idx - field->cols * form->currow;
#endif
  if (field->drows < form->currow)
    form->currow = 0;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void Buffer_To_Window(
|                                      const FIELD  * field,
|                                      WINDOW * win)
|
|   Description   :  Copy the buffer to the window. If it is a multi-line
|                    field, the buffer is split to the lines of the
|                    window without any editing.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
static void
Buffer_To_Window(const FIELD *field, WINDOW *win)
{
  int width, height;
  int y, x;
  int len;
  int row;
  FIELD_CELL *pBuffer;

  assert(win && field);

  getyx(win, y, x);
  width = getmaxx(win);
  height = getmaxy(win);

  for (row = 0, pBuffer = field->buf;
       row < height;
       row++, pBuffer += width)
    {
      if ((len = (int)(After_End_Of_Data(pBuffer, width) - pBuffer)) > 0)
	{
	  wmove(win, row, 0);
	  myADDNSTR(win, pBuffer, len);
	}
    }
  wmove(win, y, x);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void Window_To_Buffer(
|                                          WINDOW * win,
|                                          FIELD  * field)
|
|   Description   :  Copy the content of the window into the buffer.
|                    The multiple lines of a window are simply
|                    concatenated into the buffer. Pad characters in
|                    the window will be replaced by blanks in the buffer.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
static void
Window_To_Buffer(WINDOW *win, FIELD *field)
{
  int pad;
  int len = 0;
  FIELD_CELL *p;
  int row, height;

  assert(win && field && field->buf);

  pad = field->pad;
  p = field->buf;
  height = getmaxy(win);

  for (row = 0; (row < height) && (row < field->drows); row++)
    {
      wmove(win, row, 0);
      len += myINNSTR(win, p + len, field->dcols);
    }
  p[len] = myZEROS;

  /* replace visual padding character by blanks in buffer */
  if (pad != C_BLANK)
    {
      int i;

      for (i = 0; i < len; i++, p++)
	{
	  if ((unsigned long)CharOf(*p) == ChCharOf(pad)
#if USE_WIDEC_SUPPORT
	      && p->chars[1] == 0
#endif
	    )
	    *p = myBLANK;
	}
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void Synchronize_Buffer(FORM * form)
|
|   Description   :  If there was a change, copy the content of the
|                    window into the buffer, so the buffer is synchronized
|                    with the windows content. We have to indicate that the
|                    buffer needs validation due to the change.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_INLINE static void
Synchronize_Buffer(FORM *form)
{
  if (form->status & _WINDOW_MODIFIED)
    {
      form->status &= ~_WINDOW_MODIFIED;
      form->status |= _FCHECK_REQUIRED;
      Window_To_Buffer(form->w, form->current);
      wmove(form->w, form->currow, form->curcol);
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Field_Grown( FIELD *field, int amount)
|
|   Description   :  This function is called for growable dynamic fields
|                    only. It has to increase the buffers and to allocate
|                    a new window for this field.
|                    This function has the side effect to set a new
|                    field-buffer pointer, the dcols and drows values
|                    as well as a new current Window for the field.
|
|   Return Values :  TRUE     - field successfully increased
|                    FALSE    - there was some error
+--------------------------------------------------------------------------*/
static bool
Field_Grown(FIELD *field, int amount)
{
  bool result = FALSE;

  if (field && Growable(field))
    {
      bool single_line_field = Single_Line_Field(field);
      int old_buflen = Buffer_Length(field);
      int new_buflen;
      int old_dcols = field->dcols;
      int old_drows = field->drows;
      FIELD_CELL *oldbuf = field->buf;
      FIELD_CELL *newbuf;

      int growth;
      FORM *form = field->form;
      bool need_visual_update = ((form != (FORM *)0) &&
				 (form->status & _POSTED) &&
				 (form->current == field));

      if (need_visual_update)
	Synchronize_Buffer(form);

      if (single_line_field)
	{
	  growth = field->cols * amount;
	  if (field->maxgrow)
	    growth = Minimum(field->maxgrow - field->dcols, growth);
	  field->dcols += growth;
	  if (field->dcols == field->maxgrow)
	    field->status &= ~_MAY_GROW;
	}
      else
	{
	  growth = (field->rows + field->nrow) * amount;
	  if (field->maxgrow)
	    growth = Minimum(field->maxgrow - field->drows, growth);
	  field->drows += growth;
	  if (field->drows == field->maxgrow)
	    field->status &= ~_MAY_GROW;
	}
      /* drows, dcols changed, so we get really the new buffer length */
      new_buflen = Buffer_Length(field);
      newbuf = (FIELD_CELL *)malloc(Total_Buffer_Size(field));
      if (!newbuf)
	{
	  /* restore to previous state */
	  field->dcols = old_dcols;
	  field->drows = old_drows;
	  if ((single_line_field && (field->dcols != field->maxgrow)) ||
	      (!single_line_field && (field->drows != field->maxgrow)))
	    field->status |= _MAY_GROW;
	}
      else
	{
	  /* Copy all the buffers.  This is the reason why we can't just use
	   * realloc().
	   */
	  int i, j;
	  FIELD_CELL *old_bp;
	  FIELD_CELL *new_bp;

	  result = TRUE;	/* allow sharing of recovery on failure */

	  T((T_CREATE("fieldcell %p"), newbuf));
	  field->buf = newbuf;
	  for (i = 0; i <= field->nbuf; i++)
	    {
	      new_bp = Address_Of_Nth_Buffer(field, i);
	      old_bp = oldbuf + i * (1 + old_buflen);
	      for (j = 0; j < old_buflen; ++j)
		new_bp[j] = old_bp[j];
	      while (j < new_buflen)
		new_bp[j++] = myBLANK;
	      new_bp[new_buflen] = myZEROS;
	    }

#if USE_WIDEC_SUPPORT && NCURSES_EXT_FUNCS
	  if (wresize(field->working, 1, Buffer_Length(field) + 1) == ERR)
	    result = FALSE;
#endif

	  if (need_visual_update && result)
	    {
	      WINDOW *new_window = newpad(field->drows, field->dcols);

	      if (new_window != 0)
		{
		  assert(form != (FORM *)0);
		  if (form->w)
		    delwin(form->w);
		  form->w = new_window;
		  Set_Field_Window_Attributes(field, form->w);
		  werase(form->w);
		  Buffer_To_Window(field, form->w);
		  untouchwin(form->w);
		  wmove(form->w, form->currow, form->curcol);
		}
	      else
		result = FALSE;
	    }

	  if (result)
	    {
	      free(oldbuf);
	      /* reflect changes in linked fields */
	      if (field != field->link)
		{
		  FIELD *linked_field;

		  for (linked_field = field->link;
		       linked_field != field;
		       linked_field = linked_field->link)
		    {
		      linked_field->buf = field->buf;
		      linked_field->drows = field->drows;
		      linked_field->dcols = field->dcols;
		    }
		}
	    }
	  else
	    {
	      /* restore old state */
	      field->dcols = old_dcols;
	      field->drows = old_drows;
	      field->buf = oldbuf;
	      if ((single_line_field &&
		   (field->dcols != field->maxgrow)) ||
		  (!single_line_field &&
		   (field->drows != field->maxgrow)))
		field->status |= _MAY_GROW;
	      free(newbuf);
	    }
	}
    }
  return (result);
}

#ifdef NCURSES_MOUSE_VERSION
/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  int Field_encloses(FIELD *field, int ry, int rx)
|
|   Description   :  Check if the given coordinates lie within the given field.
|
|   Return Values :  E_OK              - success
|                    E_BAD_ARGUMENT    - invalid form pointer
|                    E_SYSTEM_ERROR    - form has no current field or
|                                        field-window
+--------------------------------------------------------------------------*/
static int
Field_encloses(FIELD *field, int ry, int rx)
{
  T((T_CALLED("Field_encloses(%p)"), field));
  if (field != 0
      && field->frow <= ry
      && (field->frow + field->rows) > ry
      && field->fcol <= rx
      && (field->fcol + field->cols) > rx)
    {
      RETURN(E_OK);
    }
  RETURN(E_INVALID_FIELD);
}
#endif

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  int _nc_Position_Form_Cursor(FORM * form)
|
|   Description   :  Position the cursor in the window for the current
|                    field to be in sync. with the currow and curcol
|                    values.
|
|   Return Values :  E_OK              - success
|                    E_BAD_ARGUMENT    - invalid form pointer
|                    E_SYSTEM_ERROR    - form has no current field or
|                                        field-window
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
_nc_Position_Form_Cursor(FORM *form)
{
  FIELD *field;
  WINDOW *formwin;

  if (!form)
    return (E_BAD_ARGUMENT);

  if (!form->w || !form->current)
    return (E_SYSTEM_ERROR);

  field = form->current;
  formwin = Get_Form_Window(form);

  wmove(form->w, form->currow, form->curcol);
  if (Has_Invisible_Parts(field))
    {
      /* in this case fieldwin isn't derived from formwin, so we have
         to move the cursor in formwin by hand... */
      wmove(formwin,
	    field->frow + form->currow - form->toprow,
	    field->fcol + form->curcol - form->begincol);
      wcursyncup(formwin);
    }
  else
    wcursyncup(form->w);
  return (E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  int _nc_Refresh_Current_Field(FORM * form)
|
|   Description   :  Propagate the changes in the fields window to the
|                    window of the form.
|
|   Return Values :  E_OK              - on success
|                    E_BAD_ARGUMENT    - invalid form pointer
|                    E_SYSTEM_ERROR    - general error
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
_nc_Refresh_Current_Field(FORM *form)
{
  WINDOW *formwin;
  FIELD *field;

  T((T_CALLED("_nc_Refresh_Current_Field(%p)"), form));

  if (!form)
    RETURN(E_BAD_ARGUMENT);

  if (!form->w || !form->current)
    RETURN(E_SYSTEM_ERROR);

  field = form->current;
  formwin = Get_Form_Window(form);

  if (field->opts & O_PUBLIC)
    {
      if (Is_Scroll_Field(field))
	{
	  /* Again, in this case the fieldwin isn't derived from formwin,
	     so we have to perform a copy operation. */
	  if (Single_Line_Field(field))
	    {
	      /* horizontal scrolling */
	      if (form->curcol < form->begincol)
		form->begincol = form->curcol;
	      else
		{
		  if (form->curcol >= (form->begincol + field->cols))
		    form->begincol = form->curcol - field->cols + 1;
		}
	      copywin(form->w,
		      formwin,
		      0,
		      form->begincol,
		      field->frow,
		      field->fcol,
		      field->frow,
		      field->cols + field->fcol - 1,
		      0);
	    }
	  else
	    {
	      /* A multi-line, i.e. vertical scrolling field */
	      int row_after_bottom, first_modified_row, first_unmodified_row;

	      if (field->drows > field->rows)
		{
		  row_after_bottom = form->toprow + field->rows;
		  if (form->currow < form->toprow)
		    {
		      form->toprow = form->currow;
		      field->status |= _NEWTOP;
		    }
		  if (form->currow >= row_after_bottom)
		    {
		      form->toprow = form->currow - field->rows + 1;
		      field->status |= _NEWTOP;
		    }
		  if (field->status & _NEWTOP)
		    {
		      /* means we have to copy whole range */
		      first_modified_row = form->toprow;
		      first_unmodified_row = first_modified_row + field->rows;
		      field->status &= ~_NEWTOP;
		    }
		  else
		    {
		      /* we try to optimize : finding the range of touched
		         lines */
		      first_modified_row = form->toprow;
		      while (first_modified_row < row_after_bottom)
			{
			  if (is_linetouched(form->w, first_modified_row))
			    break;
			  first_modified_row++;
			}
		      first_unmodified_row = first_modified_row;
		      while (first_unmodified_row < row_after_bottom)
			{
			  if (!is_linetouched(form->w, first_unmodified_row))
			    break;
			  first_unmodified_row++;
			}
		    }
		}
	      else
		{
		  first_modified_row = form->toprow;
		  first_unmodified_row = first_modified_row + field->rows;
		}
	      if (first_unmodified_row != first_modified_row)
		copywin(form->w,
			formwin,
			first_modified_row,
			0,
			field->frow + first_modified_row - form->toprow,
			field->fcol,
			field->frow + first_unmodified_row - form->toprow - 1,
			field->cols + field->fcol - 1,
			0);
	    }
	  wsyncup(formwin);
	}
      else
	{
	  /* if the field-window is simply a derived window, i.e. contains no
	   * invisible parts, the whole thing is trivial
	   */
	  wsyncup(form->w);
	}
    }
  untouchwin(form->w);
  returnCode(_nc_Position_Form_Cursor(form));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void Perform_Justification(
|                                        FIELD  * field,
|                                        WINDOW * win)
|
|   Description   :  Output field with requested justification
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
static void
Perform_Justification(FIELD *field, WINDOW *win)
{
  FIELD_CELL *bp;
  int len;
  int col = 0;

  bp = Get_Start_Of_Data(field->buf, Buffer_Length(field));
  len = (int)(After_End_Of_Data(field->buf, Buffer_Length(field)) - bp);

  if (len > 0)
    {
      assert(win && (field->drows == 1) && (field->dcols == field->cols));

      switch (field->just)
	{
	case JUSTIFY_LEFT:
	  break;
	case JUSTIFY_CENTER:
	  col = (field->cols - len) / 2;
	  break;
	case JUSTIFY_RIGHT:
	  col = field->cols - len;
	  break;
	default:
	  break;
	}

      wmove(win, 0, col);
      myADDNSTR(win, bp, len);
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static void Undo_Justification(
|                                     FIELD  * field,
|                                     WINDOW * win)
|
|   Description   :  Display field without any justification, i.e.
|                    left justified
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
static void
Undo_Justification(FIELD *field, WINDOW *win)
{
  FIELD_CELL *bp;
  int len;

  bp = Get_Start_Of_Data(field->buf, Buffer_Length(field));
  len = (int)(After_End_Of_Data(field->buf, Buffer_Length(field)) - bp);

  if (len > 0)
    {
      assert(win);
      wmove(win, 0, 0);
      myADDNSTR(win, bp, len);
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Check_Char(
|                                           FIELDTYPE * typ,
|                                           int ch,
|                                           TypeArgument *argp)
|
|   Description   :  Perform a single character check for character ch
|                    according to the fieldtype instance.
|
|   Return Values :  TRUE             - Character is valid
|                    FALSE            - Character is invalid
+--------------------------------------------------------------------------*/
static bool
Check_Char(FIELDTYPE *typ, int ch, TypeArgument *argp)
{
  if (typ)
    {
      if (typ->status & _LINKED_TYPE)
	{
	  assert(argp);
	  return (
		   Check_Char(typ->left, ch, argp->left) ||
		   Check_Char(typ->right, ch, argp->right));
	}
      else
	{
	  if (typ->ccheck)
	    return typ->ccheck(ch, (void *)argp);
	}
    }
  return (!iscntrl(UChar(ch)) ? TRUE : FALSE);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Display_Or_Erase_Field(
|                                           FIELD * field,
|                                           bool bEraseFlag)
|
|   Description   :  Create a subwindow for the field and display the
|                    buffer contents (apply justification if required)
|                    or simply erase the field.
|
|   Return Values :  E_OK           - on success
|                    E_SYSTEM_ERROR - some error (typical no memory)
+--------------------------------------------------------------------------*/
static int
Display_Or_Erase_Field(FIELD *field, bool bEraseFlag)
{
  WINDOW *win;
  WINDOW *fwin;

  if (!field)
    return E_SYSTEM_ERROR;

  fwin = Get_Form_Window(field->form);
  win = derwin(fwin,
	       field->rows, field->cols, field->frow, field->fcol);

  if (!win)
    return E_SYSTEM_ERROR;
  else
    {
      if (field->opts & O_VISIBLE)
	Set_Field_Window_Attributes(field, win);
      else
	wattrset(win, WINDOW_ATTRS(fwin));
      werase(win);
    }

  if (!bEraseFlag)
    {
      if (field->opts & O_PUBLIC)
	{
	  if (Justification_Allowed(field))
	    Perform_Justification(field, win);
	  else
	    Buffer_To_Window(field, win);
	}
      field->status &= ~_NEWTOP;
    }
  wsyncup(win);
  delwin(win);
  return E_OK;
}

/* Macros to preset the bEraseFlag */
#define Display_Field(field) Display_Or_Erase_Field(field,FALSE)
#define Erase_Field(field)   Display_Or_Erase_Field(field,TRUE)

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Synchronize_Field(FIELD * field)
|
|   Description   :  Synchronize the windows content with the value in
|                    the buffer.
|
|   Return Values :  E_OK                - success
|                    E_BAD_ARGUMENT      - invalid field pointer
|                    E_SYSTEM_ERROR      - some severe basic error
+--------------------------------------------------------------------------*/
static int
Synchronize_Field(FIELD *field)
{
  FORM *form;
  int res = E_OK;

  if (!field)
    return (E_BAD_ARGUMENT);

  if (((form = field->form) != (FORM *)0)
      && Field_Really_Appears(field))
    {
      if (field == form->current)
	{
	  form->currow = form->curcol = form->toprow = form->begincol = 0;
	  werase(form->w);

	  if ((field->opts & O_PUBLIC) && Justification_Allowed(field))
	    Undo_Justification(field, form->w);
	  else
	    Buffer_To_Window(field, form->w);

	  field->status |= _NEWTOP;
	  res = _nc_Refresh_Current_Field(form);
	}
      else
	res = Display_Field(field);
    }
  field->status |= _CHANGED;
  return (res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Synchronize_Linked_Fields(FIELD * field)
|
|   Description   :  Propagate the Synchronize_Field function to all linked
|                    fields. The first error that occurs in the sequence
|                    of updates is the return value.
|
|   Return Values :  E_OK                - success
|                    E_BAD_ARGUMENT      - invalid field pointer
|                    E_SYSTEM_ERROR      - some severe basic error
+--------------------------------------------------------------------------*/
static int
Synchronize_Linked_Fields(FIELD *field)
{
  FIELD *linked_field;
  int res = E_OK;
  int syncres;

  if (!field)
    return (E_BAD_ARGUMENT);

  if (!field->link)
    return (E_SYSTEM_ERROR);

  for (linked_field = field->link;
       linked_field != field;
       linked_field = linked_field->link)
    {
      if (((syncres = Synchronize_Field(linked_field)) != E_OK) &&
	  (res == E_OK))
	res = syncres;
    }
  return (res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  int _nc_Synchronize_Attributes(FIELD * field)
|
|   Description   :  If a fields visual attributes have changed, this
|                    routine is called to propagate those changes to the
|                    screen.
|
|   Return Values :  E_OK             - success
|                    E_BAD_ARGUMENT   - invalid field pointer
|                    E_SYSTEM_ERROR   - some severe basic error
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
_nc_Synchronize_Attributes(FIELD *field)
{
  FORM *form;
  int res = E_OK;
  WINDOW *formwin;

  T((T_CALLED("_nc_Synchronize_Attributes(%p)"), field));

  if (!field)
    returnCode(E_BAD_ARGUMENT);

  CHECKPOS(field->form);
  if (((form = field->form) != (FORM *)0)
      && Field_Really_Appears(field))
    {
      if (form->current == field)
	{
	  Synchronize_Buffer(form);
	  Set_Field_Window_Attributes(field, form->w);
	  werase(form->w);
	  wmove(form->w, form->currow, form->curcol);

	  if (field->opts & O_PUBLIC)
	    {
	      if (Justification_Allowed(field))
		Undo_Justification(field, form->w);
	      else
		Buffer_To_Window(field, form->w);
	    }
	  else
	    {
	      formwin = Get_Form_Window(form);
	      copywin(form->w, formwin,
		      0, 0,
		      field->frow, field->fcol,
		      field->rows - 1, field->cols - 1, 0);
	      wsyncup(formwin);
	      Buffer_To_Window(field, form->w);
	      field->status |= _NEWTOP;		/* fake refresh to paint all */
	      _nc_Refresh_Current_Field(form);
	    }
	}
      else
	{
	  res = Display_Field(field);
	}
    }
  CHECKPOS(form);
  returnCode(res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  int _nc_Synchronize_Options(FIELD * field,
|                                                Field_Options newopts)
|
|   Description   :  If a fields options have changed, this routine is
|                    called to propagate these changes to the screen and
|                    to really change the behavior of the field.
|
|   Return Values :  E_OK                - success
|                    E_BAD_ARGUMENT      - invalid field pointer
|                    E_CURRENT           - field is the current one
|                    E_SYSTEM_ERROR      - some severe basic error
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
_nc_Synchronize_Options(FIELD *field, Field_Options newopts)
{
  Field_Options oldopts;
  Field_Options changed_opts;
  FORM *form;
  int res = E_OK;

  T((T_CALLED("_nc_Synchronize_Options(%p,%#x)"), field, newopts));

  if (!field)
    returnCode(E_BAD_ARGUMENT);

  oldopts = field->opts;
  changed_opts = oldopts ^ newopts;
  field->opts = newopts;
  form = field->form;

  if (form)
    {
      if (form->current == field)
	{
	  field->opts = oldopts;
	  returnCode(E_CURRENT);
	}

      if (form->status & _POSTED)
	{
	  if ((form->curpage == field->page))
	    {
	      if (changed_opts & O_VISIBLE)
		{
		  if (newopts & O_VISIBLE)
		    res = Display_Field(field);
		  else
		    res = Erase_Field(field);
		}
	      else
		{
		  if ((changed_opts & O_PUBLIC) &&
		      (newopts & O_VISIBLE))
		    res = Display_Field(field);
		}
	    }
	}
    }

  if (changed_opts & O_STATIC)
    {
      bool single_line_field = Single_Line_Field(field);
      int res2 = E_OK;

      if (newopts & O_STATIC)
	{
	  /* the field becomes now static */
	  field->status &= ~_MAY_GROW;
	  /* if actually we have no hidden columns, justification may
	     occur again */
	  if (single_line_field &&
	      (field->cols == field->dcols) &&
	      (field->just != NO_JUSTIFICATION) &&
	      Field_Really_Appears(field))
	    {
	      res2 = Display_Field(field);
	    }
	}
      else
	{
	  /* field is no longer static */
	  if ((field->maxgrow == 0) ||
	      (single_line_field && (field->dcols < field->maxgrow)) ||
	      (!single_line_field && (field->drows < field->maxgrow)))
	    {
	      field->status |= _MAY_GROW;
	      /* a field with justification now changes its behavior,
	         so we must redisplay it */
	      if (single_line_field &&
		  (field->just != NO_JUSTIFICATION) &&
		  Field_Really_Appears(field))
		{
		  res2 = Display_Field(field);
		}
	    }
	}
      if (res2 != E_OK)
	res = res2;
    }

  returnCode(res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  int _nc_Set_Current_Field(FORM  * form,
|                                              FIELD * newfield)
|
|   Description   :  Make the newfield the new current field.
|
|   Return Values :  E_OK              - success
|                    E_BAD_ARGUMENT    - invalid form or field pointer
|                    E_SYSTEM_ERROR    - some severe basic error
|                    E_NOT_CONNECTED   - no fields are connected to the form
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
_nc_Set_Current_Field(FORM *form, FIELD *newfield)
{
  FIELD *field;
  WINDOW *new_window;

  T((T_CALLED("_nc_Set_Current_Field(%p,%p)"), form, newfield));

  if (!form || !newfield || !form->current || (newfield->form != form))
    returnCode(E_BAD_ARGUMENT);

  if ((form->status & _IN_DRIVER))
    returnCode(E_BAD_STATE);

  if (!(form->field))
    returnCode(E_NOT_CONNECTED);

  field = form->current;

  if ((field != newfield) ||
      !(form->status & _POSTED))
    {
      if ((form->w) &&
	  (field->opts & O_VISIBLE) &&
	  (field->form->curpage == field->page))
	{
	  _nc_Refresh_Current_Field(form);
	  if (field->opts & O_PUBLIC)
	    {
	      if (field->drows > field->rows)
		{
		  if (form->toprow == 0)
		    field->status &= ~_NEWTOP;
		  else
		    field->status |= _NEWTOP;
		}
	      else
		{
		  if (Justification_Allowed(field))
		    {
		      Window_To_Buffer(form->w, field);
		      werase(form->w);
		      Perform_Justification(field, form->w);
		      wsyncup(form->w);
		    }
		}
	    }
	  delwin(form->w);
	  form->w = (WINDOW *)0;
	}

      field = newfield;

      if (Has_Invisible_Parts(field))
	new_window = newpad(field->drows, field->dcols);
      else
	new_window = derwin(Get_Form_Window(form),
			    field->rows, field->cols, field->frow, field->fcol);

      if (!new_window)
	returnCode(E_SYSTEM_ERROR);

      form->current = field;

      if (form->w)
	delwin(form->w);
      form->w = new_window;

      form->status &= ~_WINDOW_MODIFIED;
      Set_Field_Window_Attributes(field, form->w);

      if (Has_Invisible_Parts(field))
	{
	  werase(form->w);
	  Buffer_To_Window(field, form->w);
	}
      else
	{
	  if (Justification_Allowed(field))
	    {
	      werase(form->w);
	      Undo_Justification(field, form->w);
	      wsyncup(form->w);
	    }
	}

      untouchwin(form->w);
    }

  form->currow = form->curcol = form->toprow = form->begincol = 0;
  returnCode(E_OK);
}

/*----------------------------------------------------------------------------
  Intra-Field Navigation routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Next_Character(FORM * form)
|
|   Description   :  Move to the next character in the field. In a multi-line
|                    field this wraps at the end of the line.
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - at the rightmost position
+--------------------------------------------------------------------------*/
static int
IFN_Next_Character(FORM *form)
{
  FIELD *field = form->current;
  int step = myWCWIDTH(form->w, form->currow, form->curcol);

  T((T_CALLED("IFN_Next_Character(%p)"), form));
  if ((form->curcol += step) == field->dcols)
    {
      if ((++(form->currow)) == field->drows)
	{
#if GROW_IF_NAVIGATE
	  if (!Single_Line_Field(field) && Field_Grown(field, 1))
	    {
	      form->curcol = 0;
	      returnCode(E_OK);
	    }
#endif
	  form->currow--;
#if GROW_IF_NAVIGATE
	  if (Single_Line_Field(field) && Field_Grown(field, 1))
	    returnCode(E_OK);
#endif
	  form->curcol -= step;
	  returnCode(E_REQUEST_DENIED);
	}
      form->curcol = 0;
    }
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Previous_Character(FORM * form)
|
|   Description   :  Move to the previous character in the field. In a
|                    multi-line field this wraps and the beginning of the
|                    line.
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - at the leftmost position
+--------------------------------------------------------------------------*/
static int
IFN_Previous_Character(FORM *form)
{
  int amount = myWCWIDTH(form->w, form->currow, form->curcol - 1);
  int oldcol = form->curcol;

  T((T_CALLED("IFN_Previous_Character(%p)"), form));
  if ((form->curcol -= amount) < 0)
    {
      if ((--(form->currow)) < 0)
	{
	  form->currow++;
	  form->curcol = oldcol;
	  returnCode(E_REQUEST_DENIED);
	}
      form->curcol = form->current->dcols - 1;
    }
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Next_Line(FORM * form)
|
|   Description   :  Move to the beginning of the next line in the field
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - at the last line
+--------------------------------------------------------------------------*/
static int
IFN_Next_Line(FORM *form)
{
  FIELD *field = form->current;

  T((T_CALLED("IFN_Next_Line(%p)"), form));
  if ((++(form->currow)) == field->drows)
    {
#if GROW_IF_NAVIGATE
      if (!Single_Line_Field(field) && Field_Grown(field, 1))
	returnCode(E_OK);
#endif
      form->currow--;
      returnCode(E_REQUEST_DENIED);
    }
  form->curcol = 0;
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Previous_Line(FORM * form)
|
|   Description   :  Move to the beginning of the previous line in the field
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - at the first line
+--------------------------------------------------------------------------*/
static int
IFN_Previous_Line(FORM *form)
{
  T((T_CALLED("IFN_Previous_Line(%p)"), form));
  if ((--(form->currow)) < 0)
    {
      form->currow++;
      returnCode(E_REQUEST_DENIED);
    }
  form->curcol = 0;
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Next_Word(FORM * form)
|
|   Description   :  Move to the beginning of the next word in the field.
|
|   Return Values :  E_OK             - success
|                    E_REQUEST_DENIED - there is no next word
+--------------------------------------------------------------------------*/
static int
IFN_Next_Word(FORM *form)
{
  FIELD *field = form->current;
  FIELD_CELL *bp = Address_Of_Current_Position_In_Buffer(form);
  FIELD_CELL *s;
  FIELD_CELL *t;

  T((T_CALLED("IFN_Next_Word(%p)"), form));

  /* We really need access to the data, so we have to synchronize */
  Synchronize_Buffer(form);

  /* Go to the first whitespace after the current position (including
     current position). This is then the starting point to look for the
     next non-blank data */
  s = Get_First_Whitespace_Character(bp, Buffer_Length(field) -
				     (int)(bp - field->buf));

  /* Find the start of the next word */
  t = Get_Start_Of_Data(s, Buffer_Length(field) -
			(int)(s - field->buf));
#if !FRIENDLY_PREV_NEXT_WORD
  if (s == t)
    returnCode(E_REQUEST_DENIED);
  else
#endif
    {
      Adjust_Cursor_Position(form, t);
      returnCode(E_OK);
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Previous_Word(FORM * form)
|
|   Description   :  Move to the beginning of the previous word in the field.
|
|   Return Values :  E_OK             - success
|                    E_REQUEST_DENIED - there is no previous word
+--------------------------------------------------------------------------*/
static int
IFN_Previous_Word(FORM *form)
{
  FIELD *field = form->current;
  FIELD_CELL *bp = Address_Of_Current_Position_In_Buffer(form);
  FIELD_CELL *s;
  FIELD_CELL *t;
  bool again = FALSE;

  T((T_CALLED("IFN_Previous_Word(%p)"), form));

  /* We really need access to the data, so we have to synchronize */
  Synchronize_Buffer(form);

  s = After_End_Of_Data(field->buf, (int)(bp - field->buf));
  /* s points now right after the last non-blank in the buffer before bp.
     If bp was in a word, s equals bp. In this case we must find the last
     whitespace in the buffer before bp and repeat the game to really find
     the previous word! */
  if (s == bp)
    again = TRUE;

  /* And next call now goes backward to look for the last whitespace
     before that, pointing right after this, so it points to the begin
     of the previous word.
   */
  t = After_Last_Whitespace_Character(field->buf, (int)(s - field->buf));
#if !FRIENDLY_PREV_NEXT_WORD
  if (s == t)
    returnCode(E_REQUEST_DENIED);
#endif
  if (again)
    {
      /* and do it again, replacing bp by t */
      s = After_End_Of_Data(field->buf, (int)(t - field->buf));
      t = After_Last_Whitespace_Character(field->buf, (int)(s - field->buf));
#if !FRIENDLY_PREV_NEXT_WORD
      if (s == t)
	returnCode(E_REQUEST_DENIED);
#endif
    }
  Adjust_Cursor_Position(form, t);
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Beginning_Of_Field(FORM * form)
|
|   Description   :  Place the cursor at the first non-pad character in
|                    the field.
|
|   Return Values :  E_OK             - success
+--------------------------------------------------------------------------*/
static int
IFN_Beginning_Of_Field(FORM *form)
{
  FIELD *field = form->current;

  T((T_CALLED("IFN_Beginning_Of_Field(%p)"), form));
  Synchronize_Buffer(form);
  Adjust_Cursor_Position(form,
			 Get_Start_Of_Data(field->buf, Buffer_Length(field)));
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_End_Of_Field(FORM * form)
|
|   Description   :  Place the cursor after the last non-pad character in
|                    the field. If the field occupies the last position in
|                    the buffer, the cursor is positioned on the last
|                    character.
|
|   Return Values :  E_OK              - success
+--------------------------------------------------------------------------*/
static int
IFN_End_Of_Field(FORM *form)
{
  FIELD *field = form->current;
  FIELD_CELL *pos;

  T((T_CALLED("IFN_End_Of_Field(%p)"), form));
  Synchronize_Buffer(form);
  pos = After_End_Of_Data(field->buf, Buffer_Length(field));
  if (pos == (field->buf + Buffer_Length(field)))
    pos--;
  Adjust_Cursor_Position(form, pos);
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Beginning_Of_Line(FORM * form)
|
|   Description   :  Place the cursor on the first non-pad character in
|                    the current line of the field.
|
|   Return Values :  E_OK         - success
+--------------------------------------------------------------------------*/
static int
IFN_Beginning_Of_Line(FORM *form)
{
  FIELD *field = form->current;

  T((T_CALLED("IFN_Beginning_Of_Line(%p)"), form));
  Synchronize_Buffer(form);
  Adjust_Cursor_Position(form,
			 Get_Start_Of_Data(Address_Of_Current_Row_In_Buffer(form),
					   field->dcols));
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_End_Of_Line(FORM * form)
|
|   Description   :  Place the cursor after the last non-pad character in the
|                    current line of the field. If the field occupies the
|                    last column in the line, the cursor is positioned on the
|                    last character of the line.
|
|   Return Values :  E_OK        - success
+--------------------------------------------------------------------------*/
static int
IFN_End_Of_Line(FORM *form)
{
  FIELD *field = form->current;
  FIELD_CELL *pos;
  FIELD_CELL *bp;

  T((T_CALLED("IFN_End_Of_Line(%p)"), form));
  Synchronize_Buffer(form);
  bp = Address_Of_Current_Row_In_Buffer(form);
  pos = After_End_Of_Data(bp, field->dcols);
  if (pos == (bp + field->dcols))
    pos--;
  Adjust_Cursor_Position(form, pos);
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Left_Character(FORM * form)
|
|   Description   :  Move one character to the left in the current line.
|                    This doesn't cycle.
|
|   Return Values :  E_OK             - success
|                    E_REQUEST_DENIED - already in first column
+--------------------------------------------------------------------------*/
static int
IFN_Left_Character(FORM *form)
{
  int amount = myWCWIDTH(form->w, form->currow, form->curcol - 1);
  int oldcol = form->curcol;

  T((T_CALLED("IFN_Left_Character(%p)"), form));
  if ((form->curcol -= amount) < 0)
    {
      form->curcol = oldcol;
      returnCode(E_REQUEST_DENIED);
    }
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Right_Character(FORM * form)
|
|   Description   :  Move one character to the right in the current line.
|                    This doesn't cycle.
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - already in last column
+--------------------------------------------------------------------------*/
static int
IFN_Right_Character(FORM *form)
{
  int amount = myWCWIDTH(form->w, form->currow, form->curcol);
  int oldcol = form->curcol;

  T((T_CALLED("IFN_Right_Character(%p)"), form));
  if ((form->curcol += amount) >= form->current->dcols)
    {
#if GROW_IF_NAVIGATE
      FIELD *field = form->current;

      if (Single_Line_Field(field) && Field_Grown(field, 1))
	returnCode(E_OK);
#endif
      form->curcol = oldcol;
      returnCode(E_REQUEST_DENIED);
    }
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Up_Character(FORM * form)
|
|   Description   :  Move one line up. This doesn't cycle through the lines
|                    of the field.
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - already in last column
+--------------------------------------------------------------------------*/
static int
IFN_Up_Character(FORM *form)
{
  T((T_CALLED("IFN_Up_Character(%p)"), form));
  if ((--(form->currow)) < 0)
    {
      form->currow++;
      returnCode(E_REQUEST_DENIED);
    }
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int IFN_Down_Character(FORM * form)
|
|   Description   :  Move one line down. This doesn't cycle through the
|                    lines of the field.
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - already in last column
+--------------------------------------------------------------------------*/
static int
IFN_Down_Character(FORM *form)
{
  FIELD *field = form->current;

  T((T_CALLED("IFN_Down_Character(%p)"), form));
  if ((++(form->currow)) == field->drows)
    {
#if GROW_IF_NAVIGATE
      if (!Single_Line_Field(field) && Field_Grown(field, 1))
	returnCode(E_OK);
#endif
      --(form->currow);
      returnCode(E_REQUEST_DENIED);
    }
  returnCode(E_OK);
}
/*----------------------------------------------------------------------------
  END of Intra-Field Navigation routines
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Vertical scrolling helper routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int VSC_Generic(FORM *form, int nlines)
|
|   Description   :  Scroll multi-line field forward (nlines>0) or
|                    backward (nlines<0) this many lines.
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - can't scroll
+--------------------------------------------------------------------------*/
static int
VSC_Generic(FORM *form, int nlines)
{
  FIELD *field = form->current;
  int res = E_REQUEST_DENIED;
  int rows_to_go = (nlines > 0 ? nlines : -nlines);

  if (nlines > 0)
    {
      if ((rows_to_go + form->toprow) > (field->drows - field->rows))
	rows_to_go = (field->drows - field->rows - form->toprow);

      if (rows_to_go > 0)
	{
	  form->currow += rows_to_go;
	  form->toprow += rows_to_go;
	  res = E_OK;
	}
    }
  else
    {
      if (rows_to_go > form->toprow)
	rows_to_go = form->toprow;

      if (rows_to_go > 0)
	{
	  form->currow -= rows_to_go;
	  form->toprow -= rows_to_go;
	  res = E_OK;
	}
    }
  return (res);
}
/*----------------------------------------------------------------------------
  End of Vertical scrolling helper routines
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Vertical scrolling routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Vertical_Scrolling(
|                                           int (* const fct) (FORM *),
|                                           FORM * form)
|
|   Description   :  Performs the generic vertical scrolling routines.
|                    This has to check for a multi-line field and to set
|                    the _NEWTOP flag if scrolling really occurred.
|
|   Return Values :  Propagated error code from low-level driver calls
+--------------------------------------------------------------------------*/
static int
Vertical_Scrolling(int (*const fct) (FORM *), FORM *form)
{
  int res = E_REQUEST_DENIED;

  if (!Single_Line_Field(form->current))
    {
      res = fct(form);
      if (res == E_OK)
	form->current->status |= _NEWTOP;
    }
  return (res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int VSC_Scroll_Line_Forward(FORM * form)
|
|   Description   :  Scroll multi-line field forward a line
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - no data ahead
+--------------------------------------------------------------------------*/
static int
VSC_Scroll_Line_Forward(FORM *form)
{
  T((T_CALLED("VSC_Scroll_Line_Forward(%p)"), form));
  returnCode(VSC_Generic(form, 1));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int VSC_Scroll_Line_Backward(FORM * form)
|
|   Description   :  Scroll multi-line field backward a line
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - no data behind
+--------------------------------------------------------------------------*/
static int
VSC_Scroll_Line_Backward(FORM *form)
{
  T((T_CALLED("VSC_Scroll_Line_Backward(%p)"), form));
  returnCode(VSC_Generic(form, -1));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int VSC_Scroll_Page_Forward(FORM * form)
|
|   Description   :  Scroll a multi-line field forward a page
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - no data ahead
+--------------------------------------------------------------------------*/
static int
VSC_Scroll_Page_Forward(FORM *form)
{
  T((T_CALLED("VSC_Scroll_Page_Forward(%p)"), form));
  returnCode(VSC_Generic(form, form->current->rows));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int VSC_Scroll_Half_Page_Forward(FORM * form)
|
|   Description   :  Scroll a multi-line field forward half a page
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - no data ahead
+--------------------------------------------------------------------------*/
static int
VSC_Scroll_Half_Page_Forward(FORM *form)
{
  T((T_CALLED("VSC_Scroll_Half_Page_Forward(%p)"), form));
  returnCode(VSC_Generic(form, (form->current->rows + 1) / 2));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int VSC_Scroll_Page_Backward(FORM * form)
|
|   Description   :  Scroll a multi-line field backward a page
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - no data behind
+--------------------------------------------------------------------------*/
static int
VSC_Scroll_Page_Backward(FORM *form)
{
  T((T_CALLED("VSC_Scroll_Page_Backward(%p)"), form));
  returnCode(VSC_Generic(form, -(form->current->rows)));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int VSC_Scroll_Half_Page_Backward(FORM * form)
|
|   Description   :  Scroll a multi-line field backward half a page
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - no data behind
+--------------------------------------------------------------------------*/
static int
VSC_Scroll_Half_Page_Backward(FORM *form)
{
  T((T_CALLED("VSC_Scroll_Half_Page_Backward(%p)"), form));
  returnCode(VSC_Generic(form, -((form->current->rows + 1) / 2)));
}
/*----------------------------------------------------------------------------
  End of Vertical scrolling routines
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Horizontal scrolling helper routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int HSC_Generic(FORM *form, int ncolumns)
|
|   Description   :  Scroll single-line field forward (ncolumns>0) or
|                    backward (ncolumns<0) this many columns.
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - can't scroll
+--------------------------------------------------------------------------*/
static int
HSC_Generic(FORM *form, int ncolumns)
{
  FIELD *field = form->current;
  int res = E_REQUEST_DENIED;
  int cols_to_go = (ncolumns > 0 ? ncolumns : -ncolumns);

  if (ncolumns > 0)
    {
      if ((cols_to_go + form->begincol) > (field->dcols - field->cols))
	cols_to_go = field->dcols - field->cols - form->begincol;

      if (cols_to_go > 0)
	{
	  form->curcol += cols_to_go;
	  form->begincol += cols_to_go;
	  res = E_OK;
	}
    }
  else
    {
      if (cols_to_go > form->begincol)
	cols_to_go = form->begincol;

      if (cols_to_go > 0)
	{
	  form->curcol -= cols_to_go;
	  form->begincol -= cols_to_go;
	  res = E_OK;
	}
    }
  return (res);
}
/*----------------------------------------------------------------------------
  End of Horizontal scrolling helper routines
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Horizontal scrolling routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Horizontal_Scrolling(
|                                          int (* const fct) (FORM *),
|                                          FORM * form)
|
|   Description   :  Performs the generic horizontal scrolling routines.
|                    This has to check for a single-line field.
|
|   Return Values :  Propagated error code from low-level driver calls
+--------------------------------------------------------------------------*/
static int
Horizontal_Scrolling(int (*const fct) (FORM *), FORM *form)
{
  if (Single_Line_Field(form->current))
    return fct(form);
  else
    return (E_REQUEST_DENIED);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int HSC_Scroll_Char_Forward(FORM * form)
|
|   Description   :  Scroll single-line field forward a character
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - no data ahead
+--------------------------------------------------------------------------*/
static int
HSC_Scroll_Char_Forward(FORM *form)
{
  T((T_CALLED("HSC_Scroll_Char_Forward(%p)"), form));
  returnCode(HSC_Generic(form, 1));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int HSC_Scroll_Char_Backward(FORM * form)
|
|   Description   :  Scroll single-line field backward a character
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - no data behind
+--------------------------------------------------------------------------*/
static int
HSC_Scroll_Char_Backward(FORM *form)
{
  T((T_CALLED("HSC_Scroll_Char_Backward(%p)"), form));
  returnCode(HSC_Generic(form, -1));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int HSC_Horizontal_Line_Forward(FORM* form)
|
|   Description   :  Scroll single-line field forward a line
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - no data ahead
+--------------------------------------------------------------------------*/
static int
HSC_Horizontal_Line_Forward(FORM *form)
{
  T((T_CALLED("HSC_Horizontal_Line_Forward(%p)"), form));
  returnCode(HSC_Generic(form, form->current->cols));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int HSC_Horizontal_Half_Line_Forward(FORM* form)
|
|   Description   :  Scroll single-line field forward half a line
|
|   Return Values :  E_OK               - success
|                    E_REQUEST_DENIED   - no data ahead
+--------------------------------------------------------------------------*/
static int
HSC_Horizontal_Half_Line_Forward(FORM *form)
{
  T((T_CALLED("HSC_Horizontal_Half_Line_Forward(%p)"), form));
  returnCode(HSC_Generic(form, (form->current->cols + 1) / 2));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int HSC_Horizontal_Line_Backward(FORM* form)
|
|   Description   :  Scroll single-line field backward a line
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - no data behind
+--------------------------------------------------------------------------*/
static int
HSC_Horizontal_Line_Backward(FORM *form)
{
  T((T_CALLED("HSC_Horizontal_Line_Backward(%p)"), form));
  returnCode(HSC_Generic(form, -(form->current->cols)));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int HSC_Horizontal_Half_Line_Backward(FORM* form)
|
|   Description   :  Scroll single-line field backward half a line
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - no data behind
+--------------------------------------------------------------------------*/
static int
HSC_Horizontal_Half_Line_Backward(FORM *form)
{
  T((T_CALLED("HSC_Horizontal_Half_Line_Backward(%p)"), form));
  returnCode(HSC_Generic(form, -((form->current->cols + 1) / 2)));
}

/*----------------------------------------------------------------------------
  End of Horizontal scrolling routines
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Helper routines for Field Editing
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Is_There_Room_For_A_Line(FORM * form)
|
|   Description   :  Check whether or not there is enough room in the
|                    buffer to enter a whole line.
|
|   Return Values :  TRUE   - there is enough space
|                    FALSE  - there is not enough space
+--------------------------------------------------------------------------*/
NCURSES_INLINE static bool
Is_There_Room_For_A_Line(FORM *form)
{
  FIELD *field = form->current;
  FIELD_CELL *begin_of_last_line, *s;

  Synchronize_Buffer(form);
  begin_of_last_line = Address_Of_Row_In_Buffer(field, (field->drows - 1));
  s = After_End_Of_Data(begin_of_last_line, field->dcols);
  return ((s == begin_of_last_line) ? TRUE : FALSE);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Is_There_Room_For_A_Char_In_Line(FORM * form)
|
|   Description   :  Checks whether or not there is room for a new character
|                    in the current line.
|
|   Return Values :  TRUE    - there is room
|                    FALSE   - there is not enough room (line full)
+--------------------------------------------------------------------------*/
NCURSES_INLINE static bool
Is_There_Room_For_A_Char_In_Line(FORM *form)
{
  int last_char_in_line;

  wmove(form->w, form->currow, form->current->dcols - 1);
  last_char_in_line = (int)(winch(form->w) & A_CHARTEXT);
  wmove(form->w, form->currow, form->curcol);
  return (((last_char_in_line == form->current->pad) ||
	   is_blank(last_char_in_line)) ? TRUE : FALSE);
}

#define There_Is_No_Room_For_A_Char_In_Line(f) \
  !Is_There_Room_For_A_Char_In_Line(f)

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Insert_String(
|                                             FORM * form,
|                                             int row,
|                                             char *txt,
|                                             int  len )
|
|   Description   :  Insert the 'len' characters beginning at pointer 'txt'
|                    into the 'row' of the 'form'. The insertion occurs
|                    on the beginning of the row, all other characters are
|                    moved to the right. After the text a pad character will
|                    be inserted to separate the text from the rest. If
|                    necessary the insertion moves characters on the next
|                    line to make place for the requested insertion string.
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  -
|                    E_SYSTEM_ERROR    - system error
+--------------------------------------------------------------------------*/
static int
Insert_String(FORM *form, int row, FIELD_CELL *txt, int len)
{
  FIELD *field = form->current;
  FIELD_CELL *bp = Address_Of_Row_In_Buffer(field, row);
  int datalen = (int)(After_End_Of_Data(bp, field->dcols) - bp);
  int freelen = field->dcols - datalen;
  int requiredlen = len + 1;
  FIELD_CELL *split;
  int result = E_REQUEST_DENIED;

  if (freelen >= requiredlen)
    {
      wmove(form->w, row, 0);
      myINSNSTR(form->w, txt, len);
      wmove(form->w, row, len);
      myINSNSTR(form->w, &myBLANK, 1);
      return E_OK;
    }
  else
    {
      /* we have to move characters on the next line. If we are on the
         last line this may work, if the field is growable */
      if ((row == (field->drows - 1)) && Growable(field))
	{
	  if (!Field_Grown(field, 1))
	    return (E_SYSTEM_ERROR);
	  /* !!!Side-Effect : might be changed due to growth!!! */
	  bp = Address_Of_Row_In_Buffer(field, row);
	}

      if (row < (field->drows - 1))
	{
	  split =
	    After_Last_Whitespace_Character(bp,
					    (int)(Get_Start_Of_Data(bp
								    + field->dcols
								    - requiredlen,
								    requiredlen)
						  - bp));
	  /* split points now to the first character of the portion of the
	     line that must be moved to the next line */
	  datalen = (int)(split - bp);	/* + freelen has to stay on this line   */
	  freelen = field->dcols - (datalen + freelen);		/* for the next line */

	  if ((result = Insert_String(form, row + 1, split, freelen)) == E_OK)
	    {
	      wmove(form->w, row, datalen);
	      wclrtoeol(form->w);
	      wmove(form->w, row, 0);
	      myINSNSTR(form->w, txt, len);
	      wmove(form->w, row, len);
	      myINSNSTR(form->w, &myBLANK, 1);
	      return E_OK;
	    }
	}
      return (result);
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Wrapping_Not_Necessary_Or_Wrapping_Ok(
|                                             FORM * form)
|
|   Description   :  If a character has been entered into a field, it may
|                    be that wrapping has to occur. This routine checks
|                    whether or not wrapping is required and if so, performs
|                    the wrapping.
|
|   Return Values :  E_OK              - no wrapping required or wrapping
|                                        was successful
|                    E_REQUEST_DENIED  -
|                    E_SYSTEM_ERROR    - some system error
+--------------------------------------------------------------------------*/
static int
Wrapping_Not_Necessary_Or_Wrapping_Ok(FORM *form)
{
  FIELD *field = form->current;
  int result = E_REQUEST_DENIED;
  bool Last_Row = ((field->drows - 1) == form->currow);

  if ((field->opts & O_WRAP) &&	/* wrapping wanted     */
      (!Single_Line_Field(field)) &&	/* must be multi-line  */
      (There_Is_No_Room_For_A_Char_In_Line(form)) &&	/* line is full        */
      (!Last_Row || Growable(field)))	/* there are more lines */
    {
      FIELD_CELL *bp;
      FIELD_CELL *split;
      int chars_to_be_wrapped;
      int chars_to_remain_on_line;

      if (Last_Row)
	{
	  /* the above logic already ensures, that in this case the field
	     is growable */
	  if (!Field_Grown(field, 1))
	    return E_SYSTEM_ERROR;
	}
      bp = Address_Of_Current_Row_In_Buffer(form);
      Window_To_Buffer(form->w, field);
      split = After_Last_Whitespace_Character(bp, field->dcols);
      /* split points to the first character of the sequence to be brought
         on the next line */
      chars_to_remain_on_line = (int)(split - bp);
      chars_to_be_wrapped = field->dcols - chars_to_remain_on_line;
      if (chars_to_remain_on_line > 0)
	{
	  if ((result = Insert_String(form, form->currow + 1, split,
				      chars_to_be_wrapped)) == E_OK)
	    {
	      wmove(form->w, form->currow, chars_to_remain_on_line);
	      wclrtoeol(form->w);
	      if (form->curcol >= chars_to_remain_on_line)
		{
		  form->currow++;
		  form->curcol -= chars_to_remain_on_line;
		}
	      return E_OK;
	    }
	}
      else
	return E_OK;
      if (result != E_OK)
	{
	  DeleteChar(form);
	  Window_To_Buffer(form->w, field);
	  result = E_REQUEST_DENIED;
	}
    }
  else
    result = E_OK;		/* wrapping was not necessary */
  return (result);
}

/*----------------------------------------------------------------------------
  Field Editing routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Field_Editing(
|                                    int (* const fct) (FORM *),
|                                    FORM * form)
|
|   Description   :  Generic routine for field editing requests. The driver
|                    routines are only called for editable fields, the
|                    _WINDOW_MODIFIED flag is set if editing occurred.
|                    This is somewhat special due to the overload semantics
|                    of the NEW_LINE and DEL_PREV requests.
|
|   Return Values :  Error code from low level drivers.
+--------------------------------------------------------------------------*/
static int
Field_Editing(int (*const fct) (FORM *), FORM *form)
{
  int res = E_REQUEST_DENIED;

  /* We have to deal here with the specific case of the overloaded
     behavior of New_Line and Delete_Previous requests.
     They may end up in navigational requests if we are on the first
     character in a field. But navigation is also allowed on non-
     editable fields.
   */
  if ((fct == FE_Delete_Previous) &&
      (form->opts & O_BS_OVERLOAD) &&
      First_Position_In_Current_Field(form))
    {
      res = Inter_Field_Navigation(FN_Previous_Field, form);
    }
  else
    {
      if (fct == FE_New_Line)
	{
	  if ((form->opts & O_NL_OVERLOAD) &&
	      First_Position_In_Current_Field(form))
	    {
	      res = Inter_Field_Navigation(FN_Next_Field, form);
	    }
	  else
	    /* FE_New_Line deals itself with the _WINDOW_MODIFIED flag */
	    res = fct(form);
	}
      else
	{
	  /* From now on, everything must be editable */
	  if (form->current->opts & O_EDIT)
	    {
	      res = fct(form);
	      if (res == E_OK)
		form->status |= _WINDOW_MODIFIED;
	    }
	}
    }
  return res;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_New_Line(FORM * form)
|
|   Description   :  Perform a new line request. This is rather complex
|                    compared to other routines in this code due to the
|                    rather difficult to understand description in the
|                    manuals.
|
|   Return Values :  E_OK               - success
|                    E_REQUEST_DENIED   - new line not allowed
|                    E_SYSTEM_ERROR     - system error
+--------------------------------------------------------------------------*/
static int
FE_New_Line(FORM *form)
{
  FIELD *field = form->current;
  FIELD_CELL *bp, *t;
  bool Last_Row = ((field->drows - 1) == form->currow);

  T((T_CALLED("FE_New_Line(%p)"), form));
  if (form->status & _OVLMODE)
    {
      if (Last_Row &&
	  (!(Growable(field) && !Single_Line_Field(field))))
	{
	  if (!(form->opts & O_NL_OVERLOAD))
	    returnCode(E_REQUEST_DENIED);
	  wmove(form->w, form->currow, form->curcol);
	  wclrtoeol(form->w);
	  /* we have to set this here, although it is also
	     handled in the generic routine. The reason is,
	     that FN_Next_Field may fail, but the form is
	     definitively changed */
	  form->status |= _WINDOW_MODIFIED;
	  returnCode(Inter_Field_Navigation(FN_Next_Field, form));
	}
      else
	{
	  if (Last_Row && !Field_Grown(field, 1))
	    {
	      /* N.B.: due to the logic in the 'if', LastRow==TRUE
	         means here that the field is growable and not
	         a single-line field */
	      returnCode(E_SYSTEM_ERROR);
	    }
	  wmove(form->w, form->currow, form->curcol);
	  wclrtoeol(form->w);
	  form->currow++;
	  form->curcol = 0;
	  form->status |= _WINDOW_MODIFIED;
	  returnCode(E_OK);
	}
    }
  else
    {
      /* Insert Mode */
      if (Last_Row &&
	  !(Growable(field) && !Single_Line_Field(field)))
	{
	  if (!(form->opts & O_NL_OVERLOAD))
	    returnCode(E_REQUEST_DENIED);
	  returnCode(Inter_Field_Navigation(FN_Next_Field, form));
	}
      else
	{
	  bool May_Do_It = !Last_Row && Is_There_Room_For_A_Line(form);

	  if (!(May_Do_It || Growable(field)))
	    returnCode(E_REQUEST_DENIED);
	  if (!May_Do_It && !Field_Grown(field, 1))
	    returnCode(E_SYSTEM_ERROR);

	  bp = Address_Of_Current_Position_In_Buffer(form);
	  t = After_End_Of_Data(bp, field->dcols - form->curcol);
	  wmove(form->w, form->currow, form->curcol);
	  wclrtoeol(form->w);
	  form->currow++;
	  form->curcol = 0;
	  wmove(form->w, form->currow, form->curcol);
	  winsertln(form->w);
	  myADDNSTR(form->w, bp, (int)(t - bp));
	  form->status |= _WINDOW_MODIFIED;
	  returnCode(E_OK);
	}
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_Insert_Character(FORM * form)
|
|   Description   :  Insert blank character at the cursor position
|
|   Return Values :  E_OK
|                    E_REQUEST_DENIED
+--------------------------------------------------------------------------*/
static int
FE_Insert_Character(FORM *form)
{
  FIELD *field = form->current;
  int result = E_REQUEST_DENIED;

  T((T_CALLED("FE_Insert_Character(%p)"), form));
  if (Check_Char(field->type, (int)C_BLANK, (TypeArgument *)(field->arg)))
    {
      bool There_Is_Room = Is_There_Room_For_A_Char_In_Line(form);

      if (There_Is_Room ||
	  ((Single_Line_Field(field) && Growable(field))))
	{
	  if (!There_Is_Room && !Field_Grown(field, 1))
	    result = E_SYSTEM_ERROR;
	  else
	    {
	      winsch(form->w, (chtype)C_BLANK);
	      result = Wrapping_Not_Necessary_Or_Wrapping_Ok(form);
	    }
	}
    }
  returnCode(result);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_Insert_Line(FORM * form)
|
|   Description   :  Insert a blank line at the cursor position
|
|   Return Values :  E_OK               - success
|                    E_REQUEST_DENIED   - line can not be inserted
+--------------------------------------------------------------------------*/
static int
FE_Insert_Line(FORM *form)
{
  FIELD *field = form->current;
  int result = E_REQUEST_DENIED;

  T((T_CALLED("FE_Insert_Line(%p)"), form));
  if (Check_Char(field->type, (int)C_BLANK, (TypeArgument *)(field->arg)))
    {
      bool Maybe_Done = (form->currow != (field->drows - 1)) &&
      Is_There_Room_For_A_Line(form);

      if (!Single_Line_Field(field) &&
	  (Maybe_Done || Growable(field)))
	{
	  if (!Maybe_Done && !Field_Grown(field, 1))
	    result = E_SYSTEM_ERROR;
	  else
	    {
	      form->curcol = 0;
	      winsertln(form->w);
	      result = E_OK;
	    }
	}
    }
  returnCode(result);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_Delete_Character(FORM * form)
|
|   Description   :  Delete character at the cursor position
|
|   Return Values :  E_OK    - success
+--------------------------------------------------------------------------*/
static int
FE_Delete_Character(FORM *form)
{
  T((T_CALLED("FE_Delete_Character(%p)"), form));
  DeleteChar(form);
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_Delete_Previous(FORM * form)
|
|   Description   :  Delete character before cursor. Again this is a rather
|                    difficult piece compared to others due to the overloading
|                    semantics of backspace.
|                    N.B.: The case of overloaded BS on first field position
|                          is already handled in the generic routine.
|
|   Return Values :  E_OK                - success
|                    E_REQUEST_DENIED    - Character can't be deleted
+--------------------------------------------------------------------------*/
static int
FE_Delete_Previous(FORM *form)
{
  FIELD *field = form->current;

  T((T_CALLED("FE_Delete_Previous(%p)"), form));
  if (First_Position_In_Current_Field(form))
    returnCode(E_REQUEST_DENIED);

  if ((--(form->curcol)) < 0)
    {
      FIELD_CELL *this_line, *prev_line, *prev_end, *this_end;
      int this_row = form->currow;

      form->curcol++;
      if (form->status & _OVLMODE)
	returnCode(E_REQUEST_DENIED);

      prev_line = Address_Of_Row_In_Buffer(field, (form->currow - 1));
      this_line = Address_Of_Row_In_Buffer(field, (form->currow));
      Synchronize_Buffer(form);
      prev_end = After_End_Of_Data(prev_line, field->dcols);
      this_end = After_End_Of_Data(this_line, field->dcols);
      if ((int)(this_end - this_line) >
	  (field->cols - (int)(prev_end - prev_line)))
	returnCode(E_REQUEST_DENIED);
      wmove(form->w, form->currow, form->curcol);
      wdeleteln(form->w);
      Adjust_Cursor_Position(form, prev_end);
      /*
       * If we did not really move to the previous line, help the user a
       * little.  It is however a little inconsistent.  Normally, when
       * backspacing around the point where text wraps to a new line in a
       * multi-line form, we absorb one keystroke for the wrapping point.  That
       * is consistent with SVr4 forms.  However, SVr4 does not allow typing
       * into the last column of the field, and requires the user to enter a
       * newline to move to the next line.  Therefore it can consistently eat
       * that keystroke.  Since ncurses allows the last column, it wraps
       * automatically (given the proper options).  But we cannot eat the
       * keystroke to back over the wrapping point, since that would put the
       * cursor past the end of the form field.  In this case, just delete the
       * character at the end of the field.
       */
      if (form->currow == this_row && this_row > 0)
	{
	  form->currow -= 1;
	  form->curcol = field->dcols - 1;
	  DeleteChar(form);
	}
      else
	{
	  wmove(form->w, form->currow, form->curcol);
	  myADDNSTR(form->w, this_line, (int)(this_end - this_line));
	}
    }
  else
    {
      DeleteChar(form);
    }
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_Delete_Line(FORM * form)
|
|   Description   :  Delete line at cursor position.
|
|   Return Values :  E_OK  - success
+--------------------------------------------------------------------------*/
static int
FE_Delete_Line(FORM *form)
{
  T((T_CALLED("FE_Delete_Line(%p)"), form));
  form->curcol = 0;
  wdeleteln(form->w);
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_Delete_Word(FORM * form)
|
|   Description   :  Delete word at cursor position
|
|   Return Values :  E_OK               - success
|                    E_REQUEST_DENIED   - failure
+--------------------------------------------------------------------------*/
static int
FE_Delete_Word(FORM *form)
{
  FIELD *field = form->current;
  FIELD_CELL *bp = Address_Of_Current_Row_In_Buffer(form);
  FIELD_CELL *ep = bp + field->dcols;
  FIELD_CELL *cp = bp + form->curcol;
  FIELD_CELL *s;

  T((T_CALLED("FE_Delete_Word(%p)"), form));
  Synchronize_Buffer(form);
  if (ISBLANK(*cp))
    returnCode(E_REQUEST_DENIED);	/* not in word */

  /* move cursor to begin of word and erase to end of screen-line */
  Adjust_Cursor_Position(form,
			 After_Last_Whitespace_Character(bp, form->curcol));
  wmove(form->w, form->currow, form->curcol);
  wclrtoeol(form->w);

  /* skip over word in buffer */
  s = Get_First_Whitespace_Character(cp, (int)(ep - cp));
  /* to begin of next word    */
  s = Get_Start_Of_Data(s, (int)(ep - s));
  if ((s != cp) && !ISBLANK(*s))
    {
      /* copy remaining line to window */
      myADDNSTR(form->w, s, (int)(s - After_End_Of_Data(s, (int)(ep - s))));
    }
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_Clear_To_End_Of_Line(FORM * form)
|
|   Description   :  Clear to end of current line.
|
|   Return Values :  E_OK   - success
+--------------------------------------------------------------------------*/
static int
FE_Clear_To_End_Of_Line(FORM *form)
{
  T((T_CALLED("FE_Clear_To_End_Of_Line(%p)"), form));
  wmove(form->w, form->currow, form->curcol);
  wclrtoeol(form->w);
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_Clear_To_End_Of_Field(FORM * form)
|
|   Description   :  Clear to end of field.
|
|   Return Values :  E_OK   - success
+--------------------------------------------------------------------------*/
static int
FE_Clear_To_End_Of_Field(FORM *form)
{
  T((T_CALLED("FE_Clear_To_End_Of_Field(%p)"), form));
  wmove(form->w, form->currow, form->curcol);
  wclrtobot(form->w);
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FE_Clear_Field(FORM * form)
|
|   Description   :  Clear entire field.
|
|   Return Values :  E_OK   - success
+--------------------------------------------------------------------------*/
static int
FE_Clear_Field(FORM *form)
{
  T((T_CALLED("FE_Clear_Field(%p)"), form));
  form->currow = form->curcol = 0;
  werase(form->w);
  returnCode(E_OK);
}
/*----------------------------------------------------------------------------
  END of Field Editing routines
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Edit Mode routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int EM_Overlay_Mode(FORM * form)
|
|   Description   :  Switch to overlay mode.
|
|   Return Values :  E_OK   - success
+--------------------------------------------------------------------------*/
static int
EM_Overlay_Mode(FORM *form)
{
  T((T_CALLED("EM_Overlay_Mode(%p)"), form));
  form->status |= _OVLMODE;
  returnCode(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int EM_Insert_Mode(FORM * form)
|
|   Description   :  Switch to insert mode
|
|   Return Values :  E_OK   - success
+--------------------------------------------------------------------------*/
static int
EM_Insert_Mode(FORM *form)
{
  T((T_CALLED("EM_Insert_Mode(%p)"), form));
  form->status &= ~_OVLMODE;
  returnCode(E_OK);
}

/*----------------------------------------------------------------------------
  END of Edit Mode routines
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Helper routines for Choice Requests
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Next_Choice(
|                                            FIELDTYPE * typ,
|                                            FIELD * field,
|                                            TypeArgument *argp)
|
|   Description   :  Get the next field choice. For linked types this is
|                    done recursively.
|
|   Return Values :  TRUE    - next choice successfully retrieved
|                    FALSE   - couldn't retrieve next choice
+--------------------------------------------------------------------------*/
static bool
Next_Choice(FIELDTYPE *typ, FIELD *field, TypeArgument *argp)
{
  if (!typ || !(typ->status & _HAS_CHOICE))
    return FALSE;

  if (typ->status & _LINKED_TYPE)
    {
      assert(argp);
      return (
	       Next_Choice(typ->left, field, argp->left) ||
	       Next_Choice(typ->right, field, argp->right));
    }
  else
    {
      assert(typ->next);
      return typ->next(field, (void *)argp);
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Previous_Choice(
|                                                FIELDTYPE * typ,
|                                                FIELD * field,
|                                                TypeArgument *argp)
|
|   Description   :  Get the previous field choice. For linked types this
|                    is done recursively.
|
|   Return Values :  TRUE    - previous choice successfully retrieved
|                    FALSE   - couldn't retrieve previous choice
+--------------------------------------------------------------------------*/
static bool
Previous_Choice(FIELDTYPE *typ, FIELD *field, TypeArgument *argp)
{
  if (!typ || !(typ->status & _HAS_CHOICE))
    return FALSE;

  if (typ->status & _LINKED_TYPE)
    {
      assert(argp);
      return (
	       Previous_Choice(typ->left, field, argp->left) ||
	       Previous_Choice(typ->right, field, argp->right));
    }
  else
    {
      assert(typ->prev);
      return typ->prev(field, (void *)argp);
    }
}
/*----------------------------------------------------------------------------
  End of Helper routines for Choice Requests
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Routines for Choice Requests
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int CR_Next_Choice(FORM * form)
|
|   Description   :  Get the next field choice.
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - next choice couldn't be retrieved
+--------------------------------------------------------------------------*/
static int
CR_Next_Choice(FORM *form)
{
  FIELD *field = form->current;

  T((T_CALLED("CR_Next_Choice(%p)"), form));
  Synchronize_Buffer(form);
  returnCode((Next_Choice(field->type, field, (TypeArgument *)(field->arg)))
	     ? E_OK
	     : E_REQUEST_DENIED);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int CR_Previous_Choice(FORM * form)
|
|   Description   :  Get the previous field choice.
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - prev. choice couldn't be retrieved
+--------------------------------------------------------------------------*/
static int
CR_Previous_Choice(FORM *form)
{
  FIELD *field = form->current;

  T((T_CALLED("CR_Previous_Choice(%p)"), form));
  Synchronize_Buffer(form);
  returnCode((Previous_Choice(field->type, field, (TypeArgument *)(field->arg)))
	     ? E_OK
	     : E_REQUEST_DENIED);
}
/*----------------------------------------------------------------------------
  End of Routines for Choice Requests
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Helper routines for Field Validations.
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static bool Check_Field(
|                                            FIELDTYPE * typ,
|                                            FIELD * field,
|                                            TypeArgument * argp)
|
|   Description   :  Check the field according to its fieldtype and its
|                    actual arguments. For linked fieldtypes this is done
|                    recursively.
|
|   Return Values :  TRUE       - field is valid
|                    FALSE      - field is invalid.
+--------------------------------------------------------------------------*/
static bool
Check_Field(FIELDTYPE *typ, FIELD *field, TypeArgument *argp)
{
  if (typ)
    {
      if (field->opts & O_NULLOK)
	{
	  FIELD_CELL *bp = field->buf;

	  assert(bp);
	  while (ISBLANK(*bp))
	    {
	      bp++;
	    }
	  if (CharOf(*bp) == 0)
	    return TRUE;
	}

      if (typ->status & _LINKED_TYPE)
	{
	  assert(argp);
	  return (
		   Check_Field(typ->left, field, argp->left) ||
		   Check_Field(typ->right, field, argp->right));
	}
      else
	{
	  if (typ->fcheck)
	    return typ->fcheck(field, (void *)argp);
	}
    }
  return TRUE;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  bool _nc_Internal_Validation(FORM * form )
|
|   Description   :  Validate the current field of the form.
|
|   Return Values :  TRUE  - field is valid
|                    FALSE - field is invalid
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(bool)
_nc_Internal_Validation(FORM *form)
{
  FIELD *field;

  field = form->current;

  Synchronize_Buffer(form);
  if ((form->status & _FCHECK_REQUIRED) ||
      (!(field->opts & O_PASSOK)))
    {
      if (!Check_Field(field->type, field, (TypeArgument *)(field->arg)))
	return FALSE;
      form->status &= ~_FCHECK_REQUIRED;
      field->status |= _CHANGED;
      Synchronize_Linked_Fields(field);
    }
  return TRUE;
}
/*----------------------------------------------------------------------------
  End of Helper routines for Field Validations.
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Routines for Field Validation.
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FV_Validation(FORM * form)
|
|   Description   :  Validate the current field of the form.
|
|   Return Values :  E_OK             - field valid
|                    E_INVALID_FIELD  - field not valid
+--------------------------------------------------------------------------*/
static int
FV_Validation(FORM *form)
{
  T((T_CALLED("FV_Validation(%p)"), form));
  if (_nc_Internal_Validation(form))
    returnCode(E_OK);
  else
    returnCode(E_INVALID_FIELD);
}
/*----------------------------------------------------------------------------
  End of routines for Field Validation.
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Helper routines for Inter-Field Navigation
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static FIELD *Next_Field_On_Page(FIELD * field)
|
|   Description   :  Get the next field after the given field on the current
|                    page. The order of fields is the one defined by the
|                    fields array. Only visible and active fields are
|                    counted.
|
|   Return Values :  Pointer to the next field.
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD *
Next_Field_On_Page(FIELD *field)
{
  FORM *form = field->form;
  FIELD **field_on_page = &form->field[field->index];
  FIELD **first_on_page = &form->field[form->page[form->curpage].pmin];
  FIELD **last_on_page = &form->field[form->page[form->curpage].pmax];

  do
    {
      field_on_page =
	(field_on_page == last_on_page) ? first_on_page : field_on_page + 1;
      if (Field_Is_Selectable(*field_on_page))
	break;
    }
  while (field != (*field_on_page));
  return (*field_on_page);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  FIELD* _nc_First_Active_Field(FORM * form)
|
|   Description   :  Get the first active field on the current page,
|                    if there are such. If there are none, get the first
|                    visible field on the page. If there are also none,
|                    we return the first field on page and hope the best.
|
|   Return Values :  Pointer to calculated field.
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(FIELD *)
_nc_First_Active_Field(FORM *form)
{
  FIELD **last_on_page = &form->field[form->page[form->curpage].pmax];
  FIELD *proposed = Next_Field_On_Page(*last_on_page);

  if (proposed == *last_on_page)
    {
      /* there might be the special situation, where there is no
         active and visible field on the current page. We then select
         the first visible field on this readonly page
       */
      if (Field_Is_Not_Selectable(proposed))
	{
	  FIELD **field = &form->field[proposed->index];
	  FIELD **first = &form->field[form->page[form->curpage].pmin];

	  do
	    {
	      field = (field == last_on_page) ? first : field + 1;
	      if (((*field)->opts & O_VISIBLE))
		break;
	    }
	  while (proposed != (*field));

	  proposed = *field;

	  if ((proposed == *last_on_page) && !(proposed->opts & O_VISIBLE))
	    {
	      /* This means, there is also no visible field on the page.
	         So we propose the first one and hope the very best...
	         Some very clever user has designed a readonly and invisible
	         page on this form.
	       */
	      proposed = *first;
	    }
	}
    }
  return (proposed);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static FIELD *Previous_Field_On_Page(FIELD * field)
|
|   Description   :  Get the previous field before the given field on the
|                    current page. The order of fields is the one defined by
|                    the fields array. Only visible and active fields are
|                    counted.
|
|   Return Values :  Pointer to the previous field.
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD *
Previous_Field_On_Page(FIELD *field)
{
  FORM *form = field->form;
  FIELD **field_on_page = &form->field[field->index];
  FIELD **first_on_page = &form->field[form->page[form->curpage].pmin];
  FIELD **last_on_page = &form->field[form->page[form->curpage].pmax];

  do
    {
      field_on_page =
	(field_on_page == first_on_page) ? last_on_page : field_on_page - 1;
      if (Field_Is_Selectable(*field_on_page))
	break;
    }
  while (field != (*field_on_page));

  return (*field_on_page);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static FIELD *Sorted_Next_Field(FIELD * field)
|
|   Description   :  Get the next field after the given field on the current
|                    page. The order of fields is the one defined by the
|                    (row,column) geometry, rows are major.
|
|   Return Values :  Pointer to the next field.
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD *
Sorted_Next_Field(FIELD *field)
{
  FIELD *field_on_page = field;

  do
    {
      field_on_page = field_on_page->snext;
      if (Field_Is_Selectable(field_on_page))
	break;
    }
  while (field_on_page != field);

  return (field_on_page);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static FIELD *Sorted_Previous_Field(FIELD * field)
|
|   Description   :  Get the previous field before the given field on the
|                    current page. The order of fields is the one defined
|                    by the (row,column) geometry, rows are major.
|
|   Return Values :  Pointer to the previous field.
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD *
Sorted_Previous_Field(FIELD *field)
{
  FIELD *field_on_page = field;

  do
    {
      field_on_page = field_on_page->sprev;
      if (Field_Is_Selectable(field_on_page))
	break;
    }
  while (field_on_page != field);

  return (field_on_page);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static FIELD *Left_Neighbor_Field(FIELD * field)
|
|   Description   :  Get the left neighbor of the field on the same line
|                    and the same page. Cycles through the line.
|
|   Return Values :  Pointer to left neighbor field.
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD *
Left_Neighbor_Field(FIELD *field)
{
  FIELD *field_on_page = field;

  /* For a field that has really a left neighbor, the while clause
     immediately fails and the loop is left, positioned at the right
     neighbor. Otherwise we cycle backwards through the sorted field list
     until we enter the same line (from the right end).
   */
  do
    {
      field_on_page = Sorted_Previous_Field(field_on_page);
    }
  while (field_on_page->frow != field->frow);

  return (field_on_page);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static FIELD *Right_Neighbor_Field(FIELD * field)
|
|   Description   :  Get the right neighbor of the field on the same line
|                    and the same page.
|
|   Return Values :  Pointer to right neighbor field.
+--------------------------------------------------------------------------*/
NCURSES_INLINE static FIELD *
Right_Neighbor_Field(FIELD *field)
{
  FIELD *field_on_page = field;

  /* See the comments on Left_Neighbor_Field to understand how it works */
  do
    {
      field_on_page = Sorted_Next_Field(field_on_page);
    }
  while (field_on_page->frow != field->frow);

  return (field_on_page);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static FIELD *Upper_Neighbor_Field(FIELD * field)
|
|   Description   :  Because of the row-major nature of sorting the fields,
|                    it is more difficult to define whats the upper neighbor
|                    field really means. We define that it must be on a
|                    'previous' line (cyclic order!) and is the rightmost
|                    field laying on the left side of the given field. If
|                    this set is empty, we take the first field on the line.
|
|   Return Values :  Pointer to the upper neighbor field.
+--------------------------------------------------------------------------*/
static FIELD *
Upper_Neighbor_Field(FIELD *field)
{
  FIELD *field_on_page = field;
  int frow = field->frow;
  int fcol = field->fcol;

  /* Walk back to the 'previous' line. The second term in the while clause
     just guarantees that we stop if we cycled through the line because
     there might be no 'previous' line if the page has just one line.
   */
  do
    {
      field_on_page = Sorted_Previous_Field(field_on_page);
    }
  while (field_on_page->frow == frow && field_on_page->fcol != fcol);

  if (field_on_page->frow != frow)
    {
      /* We really found a 'previous' line. We are positioned at the
         rightmost field on this line */
      frow = field_on_page->frow;

      /* We walk to the left as long as we are really right of the
         field. */
      while (field_on_page->frow == frow && field_on_page->fcol > fcol)
	field_on_page = Sorted_Previous_Field(field_on_page);

      /* If we wrapped, just go to the right which is the first field on
         the row */
      if (field_on_page->frow != frow)
	field_on_page = Sorted_Next_Field(field_on_page);
    }

  return (field_on_page);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static FIELD *Down_Neighbor_Field(FIELD * field)
|
|   Description   :  Because of the row-major nature of sorting the fields,
|                    its more difficult to define whats the down neighbor
|                    field really means. We define that it must be on a
|                    'next' line (cyclic order!) and is the leftmost
|                    field laying on the right side of the given field. If
|                    this set is empty, we take the last field on the line.
|
|   Return Values :  Pointer to the upper neighbor field.
+--------------------------------------------------------------------------*/
static FIELD *
Down_Neighbor_Field(FIELD *field)
{
  FIELD *field_on_page = field;
  int frow = field->frow;
  int fcol = field->fcol;

  /* Walk forward to the 'next' line. The second term in the while clause
     just guarantees that we stop if we cycled through the line because
     there might be no 'next' line if the page has just one line.
   */
  do
    {
      field_on_page = Sorted_Next_Field(field_on_page);
    }
  while (field_on_page->frow == frow && field_on_page->fcol != fcol);

  if (field_on_page->frow != frow)
    {
      /* We really found a 'next' line. We are positioned at the rightmost
         field on this line */
      frow = field_on_page->frow;

      /* We walk to the right as long as we are really left of the
         field. */
      while (field_on_page->frow == frow && field_on_page->fcol < fcol)
	field_on_page = Sorted_Next_Field(field_on_page);

      /* If we wrapped, just go to the left which is the last field on
         the row */
      if (field_on_page->frow != frow)
	field_on_page = Sorted_Previous_Field(field_on_page);
    }

  return (field_on_page);
}

/*----------------------------------------------------------------------------
  Inter-Field Navigation routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Inter_Field_Navigation(
|                                           int (* const fct) (FORM *),
|                                           FORM * form)
|
|   Description   :  Generic behavior for changing the current field, the
|                    field is left and a new field is entered. So the field
|                    must be validated and the field init/term hooks must
|                    be called.
|
|   Return Values :  E_OK                - success
|                    E_INVALID_FIELD     - field is invalid
|                    some other          - error from subordinate call
+--------------------------------------------------------------------------*/
static int
Inter_Field_Navigation(int (*const fct) (FORM *), FORM *form)
{
  int res;

  if (!_nc_Internal_Validation(form))
    res = E_INVALID_FIELD;
  else
    {
      Call_Hook(form, fieldterm);
      res = fct(form);
      Call_Hook(form, fieldinit);
    }
  return res;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Next_Field(FORM * form)
|
|   Description   :  Move to the next field on the current page of the form
|
|   Return Values :  E_OK                 - success
|                    != E_OK              - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Next_Field(FORM *form)
{
  T((T_CALLED("FN_Next_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Next_Field_On_Page(form->current)));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Previous_Field(FORM * form)
|
|   Description   :  Move to the previous field on the current page of the
|                    form
|
|   Return Values :  E_OK                 - success
|                    != E_OK              - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Previous_Field(FORM *form)
{
  T((T_CALLED("FN_Previous_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Previous_Field_On_Page(form->current)));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_First_Field(FORM * form)
|
|   Description   :  Move to the first field on the current page of the form
|
|   Return Values :  E_OK                 - success
|                    != E_OK              - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_First_Field(FORM *form)
{
  T((T_CALLED("FN_First_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Next_Field_On_Page(form->field[form->page[form->curpage].pmax])));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Last_Field(FORM * form)
|
|   Description   :  Move to the last field on the current page of the form
|
|   Return Values :  E_OK                 - success
|                    != E_OK              - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Last_Field(FORM *form)
{
  T((T_CALLED("FN_Last_Field(%p)"), form));
  returnCode(
	      _nc_Set_Current_Field(form,
				    Previous_Field_On_Page(form->field[form->page[form->curpage].pmin])));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Sorted_Next_Field(FORM * form)
|
|   Description   :  Move to the sorted next field on the current page
|                    of the form.
|
|   Return Values :  E_OK            - success
|                    != E_OK         - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Sorted_Next_Field(FORM *form)
{
  T((T_CALLED("FN_Sorted_Next_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Sorted_Next_Field(form->current)));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Sorted_Previous_Field(FORM * form)
|
|   Description   :  Move to the sorted previous field on the current page
|                    of the form.
|
|   Return Values :  E_OK            - success
|                    != E_OK         - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Sorted_Previous_Field(FORM *form)
{
  T((T_CALLED("FN_Sorted_Previous_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Sorted_Previous_Field(form->current)));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Sorted_First_Field(FORM * form)
|
|   Description   :  Move to the sorted first field on the current page
|                    of the form.
|
|   Return Values :  E_OK            - success
|                    != E_OK         - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Sorted_First_Field(FORM *form)
{
  T((T_CALLED("FN_Sorted_First_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Sorted_Next_Field(form->field[form->page[form->curpage].smax])));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Sorted_Last_Field(FORM * form)
|
|   Description   :  Move to the sorted last field on the current page
|                    of the form.
|
|   Return Values :  E_OK            - success
|                    != E_OK         - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Sorted_Last_Field(FORM *form)
{
  T((T_CALLED("FN_Sorted_Last_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Sorted_Previous_Field(form->field[form->page[form->curpage].smin])));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Left_Field(FORM * form)
|
|   Description   :  Get the field on the left of the current field on the
|                    same line and the same page. Cycles through the line.
|
|   Return Values :  E_OK            - success
|                    != E_OK         - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Left_Field(FORM *form)
{
  T((T_CALLED("FN_Left_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Left_Neighbor_Field(form->current)));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Right_Field(FORM * form)
|
|   Description   :  Get the field on the right of the current field on the
|                    same line and the same page. Cycles through the line.
|
|   Return Values :  E_OK            - success
|                    != E_OK         - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Right_Field(FORM *form)
{
  T((T_CALLED("FN_Right_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Right_Neighbor_Field(form->current)));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Up_Field(FORM * form)
|
|   Description   :  Get the upper neighbor of the current field. This
|                    cycles through the page. See the comments of the
|                    Upper_Neighbor_Field function to understand how
|                    'upper' is defined.
|
|   Return Values :  E_OK            - success
|                    != E_OK         - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Up_Field(FORM *form)
{
  T((T_CALLED("FN_Up_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Upper_Neighbor_Field(form->current)));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int FN_Down_Field(FORM * form)
|
|   Description   :  Get the down neighbor of the current field. This
|                    cycles through the page. See the comments of the
|                    Down_Neighbor_Field function to understand how
|                    'down' is defined.
|
|   Return Values :  E_OK            - success
|                    != E_OK         - error from subordinate call
+--------------------------------------------------------------------------*/
static int
FN_Down_Field(FORM *form)
{
  T((T_CALLED("FN_Down_Field(%p)"), form));
  returnCode(_nc_Set_Current_Field(form,
				   Down_Neighbor_Field(form->current)));
}
/*----------------------------------------------------------------------------
  END of Field Navigation routines
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Helper routines for Page Navigation
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  int _nc_Set_Form_Page(FORM * form,
|                                          int page,
|                                          FIELD * field)
|
|   Description   :  Make the given page number the current page and make
|                    the given field the current field on the page. If
|                    for the field NULL is given, make the first field on
|                    the page the current field. The routine acts only
|                    if the requested page is not the current page.
|
|   Return Values :  E_OK                - success
|                    != E_OK             - error from subordinate call
|                    E_BAD_ARGUMENT      - invalid field pointer
|                    E_SYSTEM_ERROR      - some severe basic error
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
_nc_Set_Form_Page(FORM *form, int page, FIELD *field)
{
  int res = E_OK;

  if ((form->curpage != page))
    {
      FIELD *last_field, *field_on_page;

      werase(Get_Form_Window(form));
      form->curpage = page;
      last_field = field_on_page = form->field[form->page[page].smin];
      do
	{
	  if (field_on_page->opts & O_VISIBLE)
	    if ((res = Display_Field(field_on_page)) != E_OK)
	      return (res);
	  field_on_page = field_on_page->snext;
	}
      while (field_on_page != last_field);

      if (field)
	res = _nc_Set_Current_Field(form, field);
      else
	/* N.B.: we don't encapsulate this by Inter_Field_Navigation(),
	   because this is already executed in a page navigation
	   context that contains field navigation
	 */
	res = FN_First_Field(form);
    }
  return (res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Next_Page_Number(const FORM * form)
|
|   Description   :  Calculate the page number following the current page
|                    number. This cycles if the highest page number is
|                    reached.
|
|   Return Values :  The next page number
+--------------------------------------------------------------------------*/
NCURSES_INLINE static int
Next_Page_Number(const FORM *form)
{
  return (form->curpage + 1) % form->maxpage;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Previous_Page_Number(const FORM * form)
|
|   Description   :  Calculate the page number before the current page
|                    number. This cycles if the first page number is
|                    reached.
|
|   Return Values :  The previous page number
+--------------------------------------------------------------------------*/
NCURSES_INLINE static int
Previous_Page_Number(const FORM *form)
{
  return (form->curpage != 0 ? form->curpage - 1 : form->maxpage - 1);
}

/*----------------------------------------------------------------------------
  Page Navigation routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Page_Navigation(
|                                               int (* const fct) (FORM *),
|                                               FORM * form)
|
|   Description   :  Generic behavior for changing a page. This means
|                    that the field is left and a new field is entered.
|                    So the field must be validated and the field init/term
|                    hooks must be called. Because also the page is changed,
|                    the forms init/term hooks must be called also.
|
|   Return Values :  E_OK                - success
|                    E_INVALID_FIELD     - field is invalid
|                    some other          - error from subordinate call
+--------------------------------------------------------------------------*/
static int
Page_Navigation(int (*const fct) (FORM *), FORM *form)
{
  int res;

  if (!_nc_Internal_Validation(form))
    res = E_INVALID_FIELD;
  else
    {
      Call_Hook(form, fieldterm);
      Call_Hook(form, formterm);
      res = fct(form);
      Call_Hook(form, forminit);
      Call_Hook(form, fieldinit);
    }
  return res;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int PN_Next_Page(FORM * form)
|
|   Description   :  Move to the next page of the form
|
|   Return Values :  E_OK                - success
|                    != E_OK             - error from subordinate call
+--------------------------------------------------------------------------*/
static int
PN_Next_Page(FORM *form)
{
  T((T_CALLED("PN_Next_Page(%p)"), form));
  returnCode(_nc_Set_Form_Page(form, Next_Page_Number(form), (FIELD *)0));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int PN_Previous_Page(FORM * form)
|
|   Description   :  Move to the previous page of the form
|
|   Return Values :  E_OK              - success
|                    != E_OK           - error from subordinate call
+--------------------------------------------------------------------------*/
static int
PN_Previous_Page(FORM *form)
{
  T((T_CALLED("PN_Previous_Page(%p)"), form));
  returnCode(_nc_Set_Form_Page(form, Previous_Page_Number(form), (FIELD *)0));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int PN_First_Page(FORM * form)
|
|   Description   :  Move to the first page of the form
|
|   Return Values :  E_OK              - success
|                    != E_OK           - error from subordinate call
+--------------------------------------------------------------------------*/
static int
PN_First_Page(FORM *form)
{
  T((T_CALLED("PN_First_Page(%p)"), form));
  returnCode(_nc_Set_Form_Page(form, 0, (FIELD *)0));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int PN_Last_Page(FORM * form)
|
|   Description   :  Move to the last page of the form
|
|   Return Values :  E_OK              - success
|                    != E_OK           - error from subordinate call
+--------------------------------------------------------------------------*/
static int
PN_Last_Page(FORM *form)
{
  T((T_CALLED("PN_Last_Page(%p)"), form));
  returnCode(_nc_Set_Form_Page(form, form->maxpage - 1, (FIELD *)0));
}

/*----------------------------------------------------------------------------
  END of Field Navigation routines
  --------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------
  Helper routines for the core form driver.
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  static int Data_Entry(FORM * form,int c)
|
|   Description   :  Enter character c into at the current position of the
|                    current field of the form.
|
|   Return Values :  E_OK              - success
|                    E_REQUEST_DENIED  - driver could not process the request
|                    E_SYSTEM_ERROR    -
+--------------------------------------------------------------------------*/
static int
Data_Entry(FORM *form, int c)
{
  FIELD *field = form->current;
  int result = E_REQUEST_DENIED;

  T((T_CALLED("Data_Entry(%p,%s)"), form, _tracechtype((chtype)c)));
  if ((field->opts & O_EDIT)
#if FIX_FORM_INACTIVE_BUG
      && (field->opts & O_ACTIVE)
#endif
    )
    {
      if ((field->opts & O_BLANK) &&
	  First_Position_In_Current_Field(form) &&
	  !(form->status & _FCHECK_REQUIRED) &&
	  !(form->status & _WINDOW_MODIFIED))
	werase(form->w);

      if (form->status & _OVLMODE)
	{
	  waddch(form->w, (chtype)c);
	}
      else
	/* no _OVLMODE */
	{
	  bool There_Is_Room = Is_There_Room_For_A_Char_In_Line(form);

	  if (!(There_Is_Room ||
		((Single_Line_Field(field) && Growable(field)))))
	    RETURN(E_REQUEST_DENIED);

	  if (!There_Is_Room && !Field_Grown(field, 1))
	    RETURN(E_SYSTEM_ERROR);

	  winsch(form->w, (chtype)c);
	}

      if ((result = Wrapping_Not_Necessary_Or_Wrapping_Ok(form)) == E_OK)
	{
	  bool End_Of_Field = (((field->drows - 1) == form->currow) &&
			       ((field->dcols - 1) == form->curcol));

	  form->status |= _WINDOW_MODIFIED;
	  if (End_Of_Field && !Growable(field) && (field->opts & O_AUTOSKIP))
	    result = Inter_Field_Navigation(FN_Next_Field, form);
	  else
	    {
	      if (End_Of_Field && Growable(field) && !Field_Grown(field, 1))
		result = E_SYSTEM_ERROR;
	      else
		{
#if USE_WIDEC_SUPPORT
		  /*
		   * We have just added a byte to the form field.  It may have
		   * been part of a multibyte character.  If it was, the
		   * addch_used field is nonzero and we should not try to move
		   * to a new column.
		   */
		  if (WINDOW_EXT(form->w, addch_used) == 0)
		    IFN_Next_Character(form);
#else
		  IFN_Next_Character(form);
#endif
		  result = E_OK;
		}
	    }
	}
    }
  RETURN(result);
}

/* Structure to describe the binding of a request code to a function.
   The member keycode codes the request value as well as the generic
   routine to use for the request. The code for the generic routine
   is coded in the upper 16 Bits while the request code is coded in
   the lower 16 bits.

   In terms of C++ you might think of a request as a class with a
   virtual method "perform". The different types of request are
   derived from this base class and overload (or not) the base class
   implementation of perform.
*/
typedef struct
{
  int keycode;			/* must be at least 32 bit: hi:mode, lo: key */
  int (*cmd) (FORM *);		/* low level driver routine for this key     */
}
Binding_Info;

/* You may see this is the class-id of the request type class */
#define ID_PN    (0x00000000)	/* Page navigation           */
#define ID_FN    (0x00010000)	/* Inter-Field navigation    */
#define ID_IFN   (0x00020000)	/* Intra-Field navigation    */
#define ID_VSC   (0x00030000)	/* Vertical Scrolling        */
#define ID_HSC   (0x00040000)	/* Horizontal Scrolling      */
#define ID_FE    (0x00050000)	/* Field Editing             */
#define ID_EM    (0x00060000)	/* Edit Mode                 */
#define ID_FV    (0x00070000)	/* Field Validation          */
#define ID_CH    (0x00080000)	/* Choice                    */
#define ID_Mask  (0xffff0000)
#define Key_Mask (0x0000ffff)
#define ID_Shft  (16)

/* This array holds all the Binding Infos */
/* *INDENT-OFF* */
static const Binding_Info bindings[MAX_FORM_COMMAND - MIN_FORM_COMMAND + 1] =
{
  { REQ_NEXT_PAGE    |ID_PN  ,PN_Next_Page},
  { REQ_PREV_PAGE    |ID_PN  ,PN_Previous_Page},
  { REQ_FIRST_PAGE   |ID_PN  ,PN_First_Page},
  { REQ_LAST_PAGE    |ID_PN  ,PN_Last_Page},

  { REQ_NEXT_FIELD   |ID_FN  ,FN_Next_Field},
  { REQ_PREV_FIELD   |ID_FN  ,FN_Previous_Field},
  { REQ_FIRST_FIELD  |ID_FN  ,FN_First_Field},
  { REQ_LAST_FIELD   |ID_FN  ,FN_Last_Field},
  { REQ_SNEXT_FIELD  |ID_FN  ,FN_Sorted_Next_Field},
  { REQ_SPREV_FIELD  |ID_FN  ,FN_Sorted_Previous_Field},
  { REQ_SFIRST_FIELD |ID_FN  ,FN_Sorted_First_Field},
  { REQ_SLAST_FIELD  |ID_FN  ,FN_Sorted_Last_Field},
  { REQ_LEFT_FIELD   |ID_FN  ,FN_Left_Field},
  { REQ_RIGHT_FIELD  |ID_FN  ,FN_Right_Field},
  { REQ_UP_FIELD     |ID_FN  ,FN_Up_Field},
  { REQ_DOWN_FIELD   |ID_FN  ,FN_Down_Field},

  { REQ_NEXT_CHAR    |ID_IFN ,IFN_Next_Character},
  { REQ_PREV_CHAR    |ID_IFN ,IFN_Previous_Character},
  { REQ_NEXT_LINE    |ID_IFN ,IFN_Next_Line},
  { REQ_PREV_LINE    |ID_IFN ,IFN_Previous_Line},
  { REQ_NEXT_WORD    |ID_IFN ,IFN_Next_Word},
  { REQ_PREV_WORD    |ID_IFN ,IFN_Previous_Word},
  { REQ_BEG_FIELD    |ID_IFN ,IFN_Beginning_Of_Field},
  { REQ_END_FIELD    |ID_IFN ,IFN_End_Of_Field},
  { REQ_BEG_LINE     |ID_IFN ,IFN_Beginning_Of_Line},
  { REQ_END_LINE     |ID_IFN ,IFN_End_Of_Line},
  { REQ_LEFT_CHAR    |ID_IFN ,IFN_Left_Character},
  { REQ_RIGHT_CHAR   |ID_IFN ,IFN_Right_Character},
  { REQ_UP_CHAR      |ID_IFN ,IFN_Up_Character},
  { REQ_DOWN_CHAR    |ID_IFN ,IFN_Down_Character},

  { REQ_NEW_LINE     |ID_FE  ,FE_New_Line},
  { REQ_INS_CHAR     |ID_FE  ,FE_Insert_Character},
  { REQ_INS_LINE     |ID_FE  ,FE_Insert_Line},
  { REQ_DEL_CHAR     |ID_FE  ,FE_Delete_Character},
  { REQ_DEL_PREV     |ID_FE  ,FE_Delete_Previous},
  { REQ_DEL_LINE     |ID_FE  ,FE_Delete_Line},
  { REQ_DEL_WORD     |ID_FE  ,FE_Delete_Word},
  { REQ_CLR_EOL      |ID_FE  ,FE_Clear_To_End_Of_Line},
  { REQ_CLR_EOF      |ID_FE  ,FE_Clear_To_End_Of_Field},
  { REQ_CLR_FIELD    |ID_FE  ,FE_Clear_Field},

  { REQ_OVL_MODE     |ID_EM  ,EM_Overlay_Mode},
  { REQ_INS_MODE     |ID_EM  ,EM_Insert_Mode},

  { REQ_SCR_FLINE    |ID_VSC ,VSC_Scroll_Line_Forward},
  { REQ_SCR_BLINE    |ID_VSC ,VSC_Scroll_Line_Backward},
  { REQ_SCR_FPAGE    |ID_VSC ,VSC_Scroll_Page_Forward},
  { REQ_SCR_BPAGE    |ID_VSC ,VSC_Scroll_Page_Backward},
  { REQ_SCR_FHPAGE   |ID_VSC ,VSC_Scroll_Half_Page_Forward},
  { REQ_SCR_BHPAGE   |ID_VSC ,VSC_Scroll_Half_Page_Backward},

  { REQ_SCR_FCHAR    |ID_HSC ,HSC_Scroll_Char_Forward},
  { REQ_SCR_BCHAR    |ID_HSC ,HSC_Scroll_Char_Backward},
  { REQ_SCR_HFLINE   |ID_HSC ,HSC_Horizontal_Line_Forward},
  { REQ_SCR_HBLINE   |ID_HSC ,HSC_Horizontal_Line_Backward},
  { REQ_SCR_HFHALF   |ID_HSC ,HSC_Horizontal_Half_Line_Forward},
  { REQ_SCR_HBHALF   |ID_HSC ,HSC_Horizontal_Half_Line_Backward},

  { REQ_VALIDATION   |ID_FV  ,FV_Validation},

  { REQ_NEXT_CHOICE  |ID_CH  ,CR_Next_Choice},
  { REQ_PREV_CHOICE  |ID_CH  ,CR_Previous_Choice}
};
/* *INDENT-ON* */

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  int form_driver(FORM * form,int  c)
|
|   Description   :  This is the workhorse of the forms system. It checks
|                    to determine whether the character c is a request or
|                    data. If it is a request, the form driver executes
|                    the request and returns the result. If it is data
|                    (printable character), it enters the data into the
|                    current position in the current field. If it is not
|                    recognized, the form driver assumes it is an application
|                    defined command and returns E_UNKNOWN_COMMAND.
|                    Application defined command should be defined relative
|                    to MAX_FORM_COMMAND, the maximum value of a request.
|
|   Return Values :  E_OK              - success
|                    E_SYSTEM_ERROR    - system error
|                    E_BAD_ARGUMENT    - an argument is incorrect
|                    E_NOT_POSTED      - form is not posted
|                    E_INVALID_FIELD   - field contents are invalid
|                    E_BAD_STATE       - called from inside a hook routine
|                    E_REQUEST_DENIED  - request failed
|                    E_NOT_CONNECTED   - no fields are connected to the form
|                    E_UNKNOWN_COMMAND - command not known
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
form_driver(FORM *form, int c)
{
  const Binding_Info *BI = (Binding_Info *) 0;
  int res = E_UNKNOWN_COMMAND;

  T((T_CALLED("form_driver(%p,%d)"), form, c));

  if (!form)
    RETURN(E_BAD_ARGUMENT);

  if (!(form->field))
    RETURN(E_NOT_CONNECTED);

  assert(form->page);

  if (c == FIRST_ACTIVE_MAGIC)
    {
      form->current = _nc_First_Active_Field(form);
      RETURN(E_OK);
    }

  assert(form->current &&
	 form->current->buf &&
	 (form->current->form == form)
    );

  if (form->status & _IN_DRIVER)
    RETURN(E_BAD_STATE);

  if (!(form->status & _POSTED))
    RETURN(E_NOT_POSTED);

  if ((c >= MIN_FORM_COMMAND && c <= MAX_FORM_COMMAND) &&
      ((bindings[c - MIN_FORM_COMMAND].keycode & Key_Mask) == c))
    BI = &(bindings[c - MIN_FORM_COMMAND]);

  if (BI)
    {
      typedef int (*Generic_Method) (int (*const) (FORM *), FORM *);
      static const Generic_Method Generic_Methods[] =
      {
	Page_Navigation,	/* overloaded to call field&form hooks */
	Inter_Field_Navigation,	/* overloaded to call field hooks      */
	NULL,			/* Intra-Field is generic              */
	Vertical_Scrolling,	/* Overloaded to check multi-line      */
	Horizontal_Scrolling,	/* Overloaded to check single-line     */
	Field_Editing,		/* Overloaded to mark modification     */
	NULL,			/* Edit Mode is generic                */
	NULL,			/* Field Validation is generic         */
	NULL			/* Choice Request is generic           */
      };
      size_t nMethods = (sizeof(Generic_Methods) / sizeof(Generic_Methods[0]));
      size_t method = (BI->keycode >> ID_Shft) & 0xffff;	/* see ID_Mask */

      if ((method >= nMethods) || !(BI->cmd))
	res = E_SYSTEM_ERROR;
      else
	{
	  Generic_Method fct = Generic_Methods[method];

	  if (fct)
	    res = fct(BI->cmd, form);
	  else
	    res = (BI->cmd) (form);
	}
    }
#ifdef NCURSES_MOUSE_VERSION
  else if (KEY_MOUSE == c)
    {
      MEVENT event;
      WINDOW *win = form->win ? form->win : stdscr;
      WINDOW *sub = form->sub ? form->sub : win;

      getmouse(&event);
      if ((event.bstate & (BUTTON1_CLICKED |
			   BUTTON1_DOUBLE_CLICKED |
			   BUTTON1_TRIPLE_CLICKED))
	  && wenclose(win, event.y, event.x))
	{			/* we react only if the click was in the userwin, that means
				 * inside the form display area or at the decoration window.
				 */
	  int ry = event.y, rx = event.x;	/* screen coordinates */

	  res = E_REQUEST_DENIED;
	  if (mouse_trafo(&ry, &rx, FALSE))
	    {			/* rx, ry are now "curses" coordinates */
	      if (ry < sub->_begy)
		{		/* we clicked above the display region; this is
				 * interpreted as "scroll up" request
				 */
		  if (event.bstate & BUTTON1_CLICKED)
		    res = form_driver(form, REQ_PREV_FIELD);
		  else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
		    res = form_driver(form, REQ_PREV_PAGE);
		  else if (event.bstate & BUTTON1_TRIPLE_CLICKED)
		    res = form_driver(form, REQ_FIRST_FIELD);
		}
	      else if (ry > sub->_begy + sub->_maxy)
		{		/* we clicked below the display region; this is
				 * interpreted as "scroll down" request
				 */
		  if (event.bstate & BUTTON1_CLICKED)
		    res = form_driver(form, REQ_NEXT_FIELD);
		  else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
		    res = form_driver(form, REQ_NEXT_PAGE);
		  else if (event.bstate & BUTTON1_TRIPLE_CLICKED)
		    res = form_driver(form, REQ_LAST_FIELD);
		}
	      else if (wenclose(sub, event.y, event.x))
		{		/* Inside the area we try to find the hit item */
		  int i;

		  ry = event.y;
		  rx = event.x;
		  if (wmouse_trafo(sub, &ry, &rx, FALSE))
		    {
		      int min_field = form->page[form->curpage].pmin;
		      int max_field = form->page[form->curpage].pmax;

		      for (i = min_field; i <= max_field; ++i)
			{
			  FIELD *field = form->field[i];

			  if (Field_Is_Selectable(field)
			      && Field_encloses(field, ry, rx) == E_OK)
			    {
			      res = _nc_Set_Current_Field(form, field);
			      if (res == E_OK)
				res = _nc_Position_Form_Cursor(form);
			      if (res == E_OK
				  && (event.bstate & BUTTON1_DOUBLE_CLICKED))
				res = E_UNKNOWN_COMMAND;
			      break;
			    }
			}
		    }
		}
	    }
	}
      else
	res = E_REQUEST_DENIED;
    }
#endif /* NCURSES_MOUSE_VERSION */
  else if (!(c & (~(int)MAX_REGULAR_CHARACTER)))
    {
      /*
       * If we're using 8-bit characters, iscntrl+isprint cover the whole set.
       * But with multibyte characters, there is a third possibility, i.e.,
       * parts of characters that build up into printable characters which are
       * not considered printable.
       *
       * FIXME: the wide-character branch should also use Check_Char().
       */
#if USE_WIDEC_SUPPORT
      if (!iscntrl(UChar(c)))
#else
      if (isprint(UChar(c)) &&
	  Check_Char(form->current->type, c,
		     (TypeArgument *)(form->current->arg)))
#endif
	res = Data_Entry(form, c);
    }
  _nc_Refresh_Current_Field(form);
  RETURN(res);
}

/*----------------------------------------------------------------------------
  Field-Buffer manipulation routines.
  The effects of setting a buffer are tightly coupled to the core of the form
  driver logic. This is especially true in the case of growable fields.
  So I don't separate this into a separate module.
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  int set_field_buffer(FIELD *field,
|                                         int buffer, char *value)
|
|   Description   :  Set the given buffer of the field to the given value.
|                    Buffer 0 stores the displayed content of the field.
|                    For dynamic fields this may grow the fieldbuffers if
|                    the length of the value exceeds the current buffer
|                    length. For buffer 0 only printable values are allowed.
|                    For static fields, the value needs not to be zero ter-
|                    minated. It is copied up to the length of the buffer.
|
|   Return Values :  E_OK            - success
|                    E_BAD_ARGUMENT  - invalid argument
|                    E_SYSTEM_ERROR  - system error
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
set_field_buffer(FIELD *field, int buffer, const char *value)
{
  FIELD_CELL *p;
  int res = E_OK;
  unsigned int i;
  unsigned int len;

#if USE_WIDEC_SUPPORT
  FIELD_CELL *widevalue = 0;
#endif

  T((T_CALLED("set_field_buffer(%p,%d,%s)"), field, buffer, _nc_visbuf(value)));

  if (!field || !value || ((buffer < 0) || (buffer > field->nbuf)))
    RETURN(E_BAD_ARGUMENT);

  len = Buffer_Length(field);

  if (Growable(field))
    {
      /* for a growable field we must assume zero terminated strings, because
         somehow we have to detect the length of what should be copied.
       */
      unsigned int vlen = strlen(value);

      if (vlen > len)
	{
	  if (!Field_Grown(field,
			   (int)(1 + (vlen - len) / ((field->rows + field->nrow)
						     * field->cols))))
	    RETURN(E_SYSTEM_ERROR);

#if !USE_WIDEC_SUPPORT
	  len = vlen;
#endif
	}
    }

  p = Address_Of_Nth_Buffer(field, buffer);

#if USE_WIDEC_SUPPORT
  /*
   * Use addstr's logic for converting a string to an array of cchar_t's.
   * There should be a better way, but this handles nonspacing characters
   * and other special cases that we really do not want to handle here.
   */
#if NCURSES_EXT_FUNCS
  if (wresize(field->working, field->drows, field->dcols) == ERR)
#endif
    {
      delwin(field->working);
      field->working = newpad(field->drows, field->dcols);
    }
  len = Buffer_Length(field);
  wclear(field->working);
  mvwaddstr(field->working, 0, 0, value);

  if ((widevalue = typeCalloc(FIELD_CELL, len + 1)) == 0)
    {
      RETURN(E_SYSTEM_ERROR);
    }
  else
    {
      for (i = 0; i < (unsigned)field->drows; ++i)
	{
	  mvwin_wchnstr(field->working, i, 0,
			widevalue + (i * field->dcols),
			field->dcols);
	}
      for (i = 0; i < len; ++i)
	{
	  if (CharEq(myZEROS, widevalue[i]))
	    {
	      while (i < len)
		p[i++] = myBLANK;
	      break;
	    }
	  p[i] = widevalue[i];
	}
      free(widevalue);
    }
#else
  for (i = 0; i < len; ++i)
    {
      if (value[i] == '\0')
	{
	  while (i < len)
	    p[i++] = myBLANK;
	  break;
	}
      p[i] = value[i];
    }
#endif

  if (buffer == 0)
    {
      int syncres;

      if (((syncres = Synchronize_Field(field)) != E_OK) &&
	  (res == E_OK))
	res = syncres;
      if (((syncres = Synchronize_Linked_Fields(field)) != E_OK) &&
	  (res == E_OK))
	res = syncres;
    }
  RETURN(res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  char *field_buffer(const FIELD *field,int buffer)
|
|   Description   :  Return the address of the buffer for the field.
|
|   Return Values :  Pointer to buffer or NULL if arguments were invalid.
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(char *)
field_buffer(const FIELD *field, int buffer)
{
  char *result = 0;

  T((T_CALLED("field_buffer(%p,%d)"), field, buffer));

  if (field && (buffer >= 0) && (buffer <= field->nbuf))
    {
#if USE_WIDEC_SUPPORT
      FIELD_CELL *data = Address_Of_Nth_Buffer(field, buffer);
      unsigned need = 0;
      int size = Buffer_Length(field);
      int n;

      /* determine the number of bytes needed to store the expanded string */
      for (n = 0; n < size; ++n)
	{
	  if (!isWidecExt(data[n]))
	    {
	      mbstate_t state;
	      size_t next;

	      init_mb(state);
	      next = _nc_wcrtomb(0, data[n].chars[0], &state);
	      if (!isEILSEQ(next))
		need += next;
	    }
	}

      /* allocate a place to store the expanded string */
      if (field->expanded[buffer] != 0)
	free(field->expanded[buffer]);
      field->expanded[buffer] = typeMalloc(char, need + 1);

      /* expand the multibyte data */
      if ((result = field->expanded[buffer]) != 0)
	{
	  wclear(field->working);
	  mvwadd_wchnstr(field->working, 0, 0, data, size);
	  mvwinnstr(field->working, 0, 0, result, (int)need);
	}
#else
      result = Address_Of_Nth_Buffer(field, buffer);
#endif
    }
  returnPtr(result);
}

#if USE_WIDEC_SUPPORT

/* FIXME: see lib_get_wch.c */
#if HAVE_MBTOWC && HAVE_MBLEN
#define reset_mbytes(state) mblen(NULL, 0), mbtowc(NULL, NULL, 0)
#define count_mbytes(buffer,length,state) mblen(buffer,length)
#define trans_mbytes(wch,buffer,length,state) \
	(int) mbtowc(&wch, buffer, length)
#elif HAVE_MBRTOWC && HAVE_MBRLEN
#define NEED_STATE
#define reset_mbytes(state) init_mb(state)
#define count_mbytes(buffer,length,state) mbrlen(buffer,length,&state)
#define trans_mbytes(wch,buffer,length,state) \
	(int) mbrtowc(&wch, buffer, length, &state)
#else
make an error
#endif

/*---------------------------------------------------------------------------
| Convert a multibyte string to a wide-character string.  The result must be
| freed by the caller.
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(wchar_t *)
_nc_Widen_String(char *source, int *lengthp)
{
  wchar_t *result = 0;
  wchar_t wch;
  size_t given = strlen(source);
  size_t tries;
  int pass;
  int status;

#ifdef NEED_STATE
  mbstate_t state;
#endif

  for (pass = 0; pass < 2; ++pass)
    {
      unsigned need = 0;
      size_t passed = 0;

      while (passed < given)
	{
	  bool found = FALSE;

	  for (tries = 1, status = 0; tries <= (given - passed); ++tries)
	    {
	      int save = source[passed + tries];

	      source[passed + tries] = 0;
	      reset_mbytes(state);
	      status = trans_mbytes(wch, source + passed, tries, state);
	      source[passed + tries] = save;

	      if (status > 0)
		{
		  found = TRUE;
		  break;
		}
	    }
	  if (found)
	    {
	      if (pass)
		{
		  result[need] = wch;
		}
	      passed += status;
	      ++need;
	    }
	  else
	    {
	      if (pass)
		{
		  result[need] = source[passed];
		}
	      ++need;
	      ++passed;
	    }
	}

      if (!pass)
	{
	  if (!need)
	    break;
	  result = typeCalloc(wchar_t, need);

	  *lengthp = need;
	  if (result == 0)
	    break;
	}
    }

  return result;
}
#endif

/* frm_driver.c ends here */
@


1.10
log
@Merge a change from ncurses upstream to correctly recalculate a form
field size on set. Fixes an issue found by canacar@@ who provided a
similar fix.

ok canacar
@
text
@d1 1
d36 1
a36 1
MODULE_ID("$Id: frm_driver.c,v 1.9 2010/01/12 23:22:07 nicm Exp $")
@


1.9
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@d35 1
a35 1
MODULE_ID("$Id: frm_driver.c,v 1.88 2008/10/18 16:25:00 tom Exp $")
d4350 1
d4352 1
d4371 1
@


1.8
log
@spelling
@
text
@a0 2
/*	$OpenBSD: frm_driver.c,v 1.7 2001/01/22 18:02:15 millert Exp $	*/

d2 1
a2 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d30 1
a30 1
 *   Author: Juergen Pfeifer <juergen.pfeifer@@gmx.net> 1995,1997            *
d32 1
d35 1
a35 1
MODULE_ID("$From: frm_driver.c,v 1.37 2000/12/10 02:09:38 tom Exp $")
d39 1
a39 1
  of the driver routines as well as the form_driver function. 
d45 1
a45 1
  time for this module, but now we have all Pentiums or Riscs, so what!
d56 1
a56 1
        The current position in the current field is changed. 
d58 1
a58 1
        Esseantially this is a specialization of Intra-Field navigation.
d61 1
a61 1
        Esseantially this is a specialization of Intra-Field navigation.
d82 1
a82 1
but they are here to allow a more intuitive and user friendly behaviour of
d86 1
a86 1
The initial implementation tries to stay very close with the behaviour
d90 1
a90 1
to SVr4, but now and in the future we will give you better options. 
d94 1
a94 1
/* Implement a more user-friendly previous/next word behaviour */
d96 1
a96 1
/* Fix the wrong behaviour for forms with all fields inactive */
d101 12
d116 3
a118 3
static int Inter_Field_Navigation ( int (* const fct) (FORM *), FORM * form );
static int FN_Next_Field (FORM * form);
static int FN_Previous_Field (FORM * form);
d121 1
a121 1

d165 1
a165 1
/* Logic to decide wether or not a field is actually a field with
a204 1

d207 145
a351 1

d353 1
a353 1
|   Facility      :  libnform  
d355 1
a355 1
|   
d361 2
a362 1
INLINE static char *Get_Start_Of_Data(char * buf, int blen)
d364 2
a365 2
  char *p   = buf;
  char *end = &buf[blen];
d367 2
a368 2
  assert(buf && blen>=0);
  while( (p < end) && is_blank(*p) ) 
d370 1
a370 1
  return( (p==end) ? buf : p );
d374 1
a374 1
|   Facility      :  libnform  
d376 1
a376 1
|   
d380 1
a380 1
|   Return Values :  Pointer to position after last non-blank position in 
d383 2
a384 1
INLINE static char *After_End_Of_Data(char * buf,int blen)
d386 4
a389 4
  char *p   = &buf[blen];
  
  assert(buf && blen>=0);
  while( (p>buf) && is_blank(p[-1]) ) 
d391 1
a391 1
  return( p );
d395 1
a395 1
|   Facility      :  libnform  
d398 1
a398 1
|   
d403 2
a404 1
INLINE static char *Get_First_Whitespace_Character(char * buf, int blen)
d406 5
a410 5
  char *p   = buf;
  char *end = &p[blen];
  
  assert(buf && blen>=0);
  while( (p < end) && !is_blank(*p)) 
d412 1
a412 1
  return( (p==end) ? buf : p );
d416 1
a416 1
|   Facility      :  libnform  
d419 1
a419 1
|   
d422 1
a422 1
|   Return Values :  Pointer to position after last whitespace character in 
d425 2
a426 1
INLINE static char *After_Last_Whitespace_Character(char * buf, int blen)
d428 4
a431 4
  char *p   = &buf[blen];
  
  assert(buf && blen>=0);
  while( (p>buf) && !is_blank(p[-1]) ) 
d433 1
a433 1
  return( p );
d438 1
a438 1
   not yet. 
d440 1
a440 1
         and both are of type int. 
d445 1
a445 1
|   Facility      :  libnform  
d448 2
a449 2
|   
|   Description   :  Set current row and column of the form to values 
d454 2
a455 1
INLINE static void Adjust_Cursor_Position(FORM * form, const char * pos)
d461 2
a462 2
  assert( pos >= field->buf && field->dcols > 0);
  idx = (int)( pos - field->buf );
d464 1
a464 1
  *((div_t *)&(form->currow)) = div(idx,field->dcols);
d468 2
a469 2
#endif  
  if ( field->drows < form->currow )
d474 1
a474 1
|   Facility      :  libnform  
d478 2
a479 2
|   
|   Description   :  Copy the buffer to the window. If its a multiline
d485 2
a486 1
static void Buffer_To_Window(const FIELD  * field, WINDOW * win)
d489 1
d492 1
a492 1
  char *pBuffer;
d496 2
a497 1
  width  = getmaxx(win);
d500 3
a502 3
  for(row=0, pBuffer=field->buf; 
      row < height; 
      row++, pBuffer += width )
d504 1
a504 1
      if ((len = (int)( After_End_Of_Data( pBuffer, width ) - pBuffer )) > 0)
d506 2
a507 2
	  wmove( win, row, 0 );
	  waddnstr( win, pBuffer, len );
d509 2
a510 1
    }	
d514 1
a514 1
|   Facility      :  libnform  
d518 1
a518 1
|   
d526 2
a527 1
static void Window_To_Buffer(WINDOW * win, FIELD  * field)
d531 1
a531 1
  char *p;
d533 2
a534 2
  
  assert(win && field && field->buf );
d540 1
a540 1
  for(row=0; (row < height) && (row < field->drows); row++ )
d542 2
a543 2
      wmove( win, row, 0 );
      len += winnstr( win, p+len, field->dcols );
d545 1
a545 1
  p[len] = '\0';
d551 2
a552 1
      for(i=0; i<len; i++, p++)
d554 6
a559 2
	  if (*p==pad) 
	    *p = C_BLANK;
d565 1
a565 1
|   Facility      :  libnform  
d567 1
a567 1
|   
d575 2
a576 1
INLINE static void Synchronize_Buffer(FORM * form)
d581 3
a583 3
      form->status |=  _FCHECK_REQUIRED;
      Window_To_Buffer(form->w,form->current);
      wmove(form->w,form->currow,form->curcol);
d588 1
a588 1
|   Facility      :  libnform  
d590 1
a590 1
|   
d601 2
a602 1
static bool Field_Grown(FIELD * field, int amount)
d613 2
a614 2
      char *oldbuf  = field->buf;
      char *newbuf;
d618 1
a618 1
      bool need_visual_update = ((form != (FORM *)0)      &&
d620 2
a621 2
				 (form->current==field));
      
d624 1
a624 1
      
d629 1
a629 1
	    growth = Minimum(field->maxgrow - field->dcols,growth);
d638 1
a638 1
	    growth = Minimum(field->maxgrow - field->drows,growth);
d645 1
a645 1
      newbuf=(char *)malloc((size_t)Total_Buffer_Size(field));
d647 2
a648 1
	{ /* restore to previous state */
d651 2
a652 2
	  if (( single_line_field && (field->dcols!=field->maxgrow)) ||
	      (!single_line_field && (field->drows!=field->maxgrow)))
a653 1
	  return FALSE;
d656 11
a666 7
	{ /* Copy all the buffers. This is the reason why we can't
	     just use realloc().
	     */
	  int i;
	  char *old_bp;
	  char *new_bp;
	  
d668 17
a684 1
	  for(i=0;i<=field->nbuf;i++)
d686 13
a698 24
	      new_bp = Address_Of_Nth_Buffer(field,i);
	      old_bp = oldbuf + i*(1+old_buflen);
	      memcpy(new_bp,old_bp,(size_t)old_buflen);
	      if (new_buflen > old_buflen)
		memset(new_bp + old_buflen,C_BLANK,
		       (size_t)(new_buflen - old_buflen));
	      *(new_bp + new_buflen) = '\0';
	    }

	  if (need_visual_update)
	    { 	      
	      WINDOW *new_window = newpad(field->drows,field->dcols);
	      if (!new_window)
		{ /* restore old state */
		  field->dcols = old_dcols;
		  field->drows = old_drows;
		  field->buf   = oldbuf;
		  if (( single_line_field              && 
			(field->dcols!=field->maxgrow)) ||
		      (!single_line_field              && 
		       (field->drows!=field->maxgrow)))
		    field->status |= _MAY_GROW;
		  free( newbuf );
		  return FALSE;
d700 2
a701 8
	      assert(form!=(FORM *)0);
	      delwin(form->w);
	      form->w = new_window;
	      Set_Field_Window_Attributes(field,form->w);
	      werase(form->w);
	      Buffer_To_Window(field,form->w);
	      untouchwin(form->w);
	      wmove(form->w,form->currow,form->curcol);
d704 5
a708 8
	  free(oldbuf);
	  /* reflect changes in linked fields */
	  if (field != field->link)
	    {
	      FIELD *linked_field;
	      for(linked_field = field->link;
		  linked_field!= field;
		  linked_field = linked_field->link)
d710 10
a719 3
		  linked_field->buf   = field->buf;
		  linked_field->drows = field->drows;
		  linked_field->dcols = field->dcols;
d722 41
a762 2
	  result = TRUE;
	}	
d764 1
a764 1
  return(result);
d766 1
d769 1
a769 1
|   Facility      :  libnform  
d771 1
a771 1
|   
d773 1
a773 1
|                    field to be in sync. with the currow and curcol 
d782 1
a782 1
_nc_Position_Form_Cursor (FORM * form)
d784 1
a784 1
  FIELD  *field;
d786 1
a786 1
  
d788 1
a788 1
    return(E_BAD_ARGUMENT);
d790 2
a791 2
  if (!form->w || !form->current) 
    return(E_SYSTEM_ERROR);
d793 2
a794 2
  field    = form->current;
  formwin  = Get_Form_Window(form);
d796 2
a797 2
  wmove( form->w, form->currow, form->curcol );
  if ( Has_Invisible_Parts(field) )
d800 1
a800 1
	 to move the cursor in formwin by hand... */
d806 1
a806 1
  else 
d808 1
a808 1
  return(E_OK);
d812 1
a812 1
|   Facility      :  libnform  
d814 1
a814 1
|   
d823 1
a823 1
_nc_Refresh_Current_Field (FORM * form)
d826 3
a828 1
  FIELD  *field;
d833 1
a833 1
  if (!form->w || !form->current) 
d836 2
a837 2
  field    = form->current;
  formwin  = Get_Form_Window(form);
d846 2
a847 1
	    { /* horizontal scrolling */
d849 1
a849 1
		  form->begincol = form->curcol;
d853 1
a853 1
		      form->begincol = form->curcol - field->cols + 1;
d866 3
a868 2
	    { /* A multiline, i.e. vertical scrolling field */
	      int row_after_bottom,first_modified_row,first_unmodified_row;
d884 2
a885 1
		    { /* means we have to copy whole range */
d890 4
a893 3
		  else 
		    { /* we try to optimize : finding the range of touched
                         lines */
d895 1
a895 1
		      while(first_modified_row < row_after_bottom)
d897 1
a897 1
			  if (is_linetouched(form->w,first_modified_row)) 
d902 1
a902 1
		      while(first_unmodified_row < row_after_bottom)
d904 1
a904 1
			  if (!is_linetouched(form->w,first_unmodified_row)) 
d912 1
a912 1
		  first_modified_row   = form->toprow;
d929 4
a932 3
	{ /* if the field-window is simply a derived window, i.e. contains
	     no invisible parts, the whole thing is trivial 
	  */
d937 1
a937 1
  return _nc_Position_Form_Cursor(form);
d939 1
a939 1
	
d941 1
a941 1
|   Facility      :  libnform  
d945 2
a946 2
|   
|   Description   :  Output field with requested justification 
d950 2
a951 1
static void Perform_Justification(FIELD  * field, WINDOW * win)
d953 1
a953 1
  char *bp;
d955 1
a955 1
  int col  = 0;
d957 2
a958 2
  bp  = Get_Start_Of_Data(field->buf,Buffer_Length(field));
  len = (int)(After_End_Of_Data(field->buf,Buffer_Length(field)) - bp);
d960 1
a960 1
  if (len>0)
d964 1
a964 1
      switch(field->just)
d969 1
a969 1
	  col = (field->cols - len)/2;
d978 2
a979 2
      wmove(win,0,col);
      waddnstr(win,bp,len);
d984 1
a984 1
|   Facility      :  libnform  
d988 1
a988 1
|   
d994 2
a995 1
static void Undo_Justification(FIELD  * field, WINDOW * win)
d997 1
a997 1
  char *bp;
d1000 2
a1001 2
  bp  = Get_Start_Of_Data(field->buf,Buffer_Length(field));
  len = (int)(After_End_Of_Data(field->buf,Buffer_Length(field))-bp);
d1003 1
a1003 1
  if (len>0)
d1006 2
a1007 2
      wmove(win,0,0);
      waddnstr(win,bp,len);
d1012 1
a1012 1
|   Facility      :  libnform  
d1017 1
a1017 1
|   
d1019 1
a1019 1
|                    according to the fieldtype instance.  
d1024 2
a1025 1
static bool Check_Char(FIELDTYPE * typ, int ch, TypeArgument *argp)
d1027 1
a1027 1
  if (typ) 
d1032 5
a1036 5
	  return(
	    Check_Char(typ->left ,ch,argp->left ) ||
	    Check_Char(typ->right,ch,argp->right) );
	} 
      else 
d1039 1
a1039 1
	    return typ->ccheck(ch,(void *)argp);
d1042 1
a1042 1
  return (isprint((unsigned char)ch) ? TRUE : FALSE);
d1046 1
a1046 1
|   Facility      :  libnform  
d1050 1
a1050 1
|   
d1058 2
a1059 1
static int Display_Or_Erase_Field(FIELD * field, bool bEraseFlag)
d1068 2
a1069 2
  win  = derwin(fwin,
		field->rows,field->cols,field->frow,field->fcol);
d1071 1
a1071 1
  if (!win) 
d1076 1
a1076 1
	Set_Field_Window_Attributes(field,win);
d1078 1
a1078 1
	wattrset(win,getattrs(fwin));
d1087 1
a1087 1
	    Perform_Justification(field,win);
d1089 1
a1089 1
	    Buffer_To_Window(field,win);
d1103 1
a1103 1
|   Facility      :  libnform  
d1105 1
a1105 1
|   
d1110 1
a1110 1
|                    E_BAD_ARGUMENT      - invalid field pointer 
d1113 2
a1114 1
static int Synchronize_Field(FIELD * field)
d1120 1
a1120 1
    return(E_BAD_ARGUMENT);
d1122 1
a1122 1
  if (((form=field->form) != (FORM *)0)
d1126 2
a1127 2
	{ 
	  form->currow  = form->curcol = form->toprow = form->begincol = 0;
d1129 3
a1131 3
      
	  if ( (field->opts & O_PUBLIC) && Justification_Allowed(field) )
	    Undo_Justification( field, form->w );
d1133 2
a1134 2
	    Buffer_To_Window( field, form->w );
	  
d1136 1
a1136 1
	  res = _nc_Refresh_Current_Field( form );
d1139 1
a1139 1
	res = Display_Field( field );
d1142 1
a1142 1
  return(res);
d1146 1
a1146 1
|   Facility      :  libnform  
d1148 1
a1148 1
|   
d1151 1
a1151 1
|                    of updates is the returnvalue.
d1154 1
a1154 1
|                    E_BAD_ARGUMENT      - invalid field pointer 
d1157 2
a1158 1
static int Synchronize_Linked_Fields(FIELD * field)
d1165 1
a1165 1
    return(E_BAD_ARGUMENT);
d1168 1
a1168 1
    return(E_SYSTEM_ERROR);
d1170 3
a1172 3
  for(linked_field = field->link; 
      linked_field!= field;
      linked_field = linked_field->link )
d1174 2
a1175 2
      if (((syncres=Synchronize_Field(linked_field)) != E_OK) &&
	  (res==E_OK))
d1178 1
a1178 1
  return(res);
d1182 1
a1182 1
|   Facility      :  libnform  
d1184 1
a1184 1
|   
d1187 1
a1187 1
|                    screen.  
d1194 1
a1194 1
_nc_Synchronize_Attributes (FIELD * field)
d1200 2
d1203 1
a1203 1
    return(E_BAD_ARGUMENT);
d1205 2
a1206 1
  if (((form=field->form) != (FORM *)0)
d1208 2
a1209 2
    {    
      if (form->current==field)
d1212 1
a1212 1
	  Set_Field_Window_Attributes(field,form->w);
d1214 2
d1219 11
a1229 11
		Undo_Justification(field,form->w);
	      else 
		Buffer_To_Window(field,form->w);
	    }
	  else 
	    {
	      formwin = Get_Form_Window(form); 
	      copywin(form->w,formwin,
		      0,0,
		      field->frow,field->fcol,
		      field->rows-1,field->cols-1,0);
d1231 2
a1232 2
	      Buffer_To_Window(field,form->w);
	      field->status |= _NEWTOP; /* fake refresh to paint all */
d1236 1
a1236 1
      else 
d1241 2
a1242 1
  return(res);
d1246 1
a1246 1
|   Facility      :  libnform  
d1249 1
a1249 1
|   
d1252 1
a1252 1
|                    to really change the behaviour of the field.
d1255 2
a1256 1
|                    E_BAD_ARGUMENT      - invalid field pointer 
d1260 1
a1260 2
_nc_Synchronize_Options
(FIELD *field, Field_Options newopts)
d1267 2
d1270 1
a1270 1
    return(E_BAD_ARGUMENT);
d1272 1
a1272 1
  oldopts      = field->opts;
d1274 2
a1275 2
  field->opts  = newopts;
  form         = field->form;
d1282 1
a1282 1
	  return(E_CURRENT);
d1312 2
a1313 1
	{ /* the field becomes now static */
d1317 2
a1318 2
	  if (single_line_field                 &&
	      (field->cols == field->dcols)     &&
d1326 4
a1329 3
	{ /* field is no longer static */
	  if ((field->maxgrow==0) ||
	      ( single_line_field && (field->dcols < field->maxgrow)) ||
d1333 3
a1335 3
	      /* a field with justification now changes its behaviour,
		 so we must redisplay it */
	      if (single_line_field                 &&
d1340 2
a1341 2
		}	 
	    }     
d1347 1
a1347 1
  return(res);
d1351 1
a1351 1
|   Facility      :  libnform  
d1354 1
a1354 1
|   
d1357 4
a1360 3
|   Return Values :  E_OK                - success
|                    E_BAD_ARGUMENT      - invalid form or field pointer 
|                    E_SYSTEM_ERROR      - some severe basic error
d1363 1
a1363 2
_nc_Set_Current_Field
(FORM  *form, FIELD *newfield)
d1365 1
a1365 1
  FIELD  *field;
d1368 1
a1368 2
  if (!form || !newfield || !form->current || (newfield->form!=form))
    return(E_BAD_ARGUMENT);
d1370 5
a1374 2
  if ( (form->status & _IN_DRIVER) )
    return(E_BAD_STATE);
d1377 1
a1377 1
    return(E_NOT_CONNECTED);
d1380 2
a1381 2
 
  if ((field!=newfield) || 
d1384 1
a1384 1
      if ((form->w) && 
d1393 1
a1393 1
		  if (form->toprow==0)
d1395 1
a1395 1
		  else 
d1397 2
a1398 2
		} 
	      else 
d1402 1
a1402 1
		      Window_To_Buffer(form->w,field);
d1404 1
a1404 1
		      Perform_Justification(field,form->w);
d1410 1
d1412 1
a1412 1
      
d1416 2
a1417 2
	new_window = newpad(field->drows,field->dcols);
      else 
d1419 1
a1419 1
			    field->rows,field->cols,field->frow,field->fcol);
d1421 2
a1422 2
      if (!new_window) 
	return(E_SYSTEM_ERROR);
d1425 5
a1429 1
      form->w       = new_window;
d1431 1
a1431 1
      Set_Field_Window_Attributes(field,form->w);
d1436 3
a1438 3
	  Buffer_To_Window(field,form->w);
	} 
      else 
d1443 1
a1443 1
	      Undo_Justification(field,form->w);
d1452 1
a1452 1
  return(E_OK);
d1454 1
a1454 1

d1460 1
a1460 1
|   Facility      :  libnform  
d1462 2
a1463 2
|   
|   Description   :  Move to the next character in the field. In a multiline
d1469 2
a1470 1
static int IFN_Next_Character(FORM * form)
d1473 4
a1476 2
  
  if ((++(form->curcol))==field->dcols)
d1478 1
a1478 1
      if ((++(form->currow))==field->drows)
d1481 5
a1485 4
	  if (!Single_Line_Field(field) && Field_Grown(field,1)) {
	    form->curcol = 0;
	    return(E_OK);
	  }
d1489 2
a1490 2
	  if (Single_Line_Field(field) && Field_Grown(field,1))
	    return(E_OK);
d1492 2
a1493 2
	  form->curcol--;
	  return(E_REQUEST_DENIED);
d1497 1
a1497 1
  return(E_OK);
d1501 1
a1501 1
|   Facility      :  libnform  
d1503 3
a1505 3
|   
|   Description   :  Move to the previous character in the field. In a 
|                    multiline field this wraps and the beginning of the 
d1511 2
a1512 1
static int IFN_Previous_Character(FORM * form)
d1514 5
a1518 1
  if ((--(form->curcol))<0)
d1520 1
a1520 1
      if ((--(form->currow))<0)
d1523 2
a1524 2
	  form->curcol++;
	  return(E_REQUEST_DENIED);
d1528 1
a1528 1
  return(E_OK);
d1532 1
a1532 1
|   Facility      :  libnform  
d1534 1
a1534 1
|   
d1540 2
a1541 1
static int IFN_Next_Line(FORM * form)
d1545 2
a1546 1
  if ((++(form->currow))==field->drows)
d1549 2
a1550 2
      if (!Single_Line_Field(field) && Field_Grown(field,1))
	return(E_OK);
d1553 1
a1553 1
      return(E_REQUEST_DENIED);
d1556 1
a1556 1
  return(E_OK);
d1560 1
a1560 1
|   Facility      :  libnform  
d1562 1
a1562 1
|   
d1568 2
a1569 1
static int IFN_Previous_Line(FORM * form)
d1571 2
a1572 1
  if ( (--(form->currow)) < 0 )
d1575 1
a1575 1
      return(E_REQUEST_DENIED);
d1578 1
a1578 1
  return(E_OK);
d1582 1
a1582 1
|   Facility      :  libnform  
d1584 1
a1584 1
|   
d1590 2
a1591 1
static int IFN_Next_Word(FORM * form)
d1594 5
a1598 3
  char  *bp    = Address_Of_Current_Position_In_Buffer(form);
  char  *s;
  char  *t;
d1604 3
a1606 3
     current position). This is then the startpoint to look for the
    next non-blank data */
  s = Get_First_Whitespace_Character(bp,Buffer_Length(field) -
d1610 1
a1610 1
  t = Get_Start_Of_Data(s,Buffer_Length(field) -
d1613 2
a1614 2
  if (s==t) 
    return(E_REQUEST_DENIED);
d1618 2
a1619 2
      Adjust_Cursor_Position(form,t);
      return(E_OK);
d1624 1
a1624 1
|   Facility      :  libnform  
d1626 1
a1626 1
|   
d1632 2
a1633 1
static int IFN_Previous_Word(FORM * form)
d1636 6
a1641 4
  char  *bp    = Address_Of_Current_Position_In_Buffer(form);
  char  *s;
  char  *t;
  bool  again = FALSE;
d1646 1
a1646 1
  s = After_End_Of_Data(field->buf,(int)(bp-field->buf));
d1651 1
a1651 1
  if (s==bp)
d1653 1
a1653 1
  
d1656 3
a1658 3
     of the previous word. 
  */
  t = After_Last_Whitespace_Character(field->buf,(int)(s - field->buf));
d1660 2
a1661 2
  if (s==t) 
    return(E_REQUEST_DENIED);
d1664 4
a1667 3
    { /* and do it again, replacing bp by t */
      s = After_End_Of_Data(field->buf,(int)(t - field->buf));
      t = After_Last_Whitespace_Character(field->buf,(int)(s - field->buf));
d1669 2
a1670 2
      if (s==t) 
	return(E_REQUEST_DENIED);
d1673 2
a1674 2
  Adjust_Cursor_Position(form,t);
  return(E_OK);
d1678 1
a1678 1
|   Facility      :  libnform  
d1680 1
a1680 1
|   
d1682 1
a1682 1
|                    the field. 
d1684 1
a1684 1
|   Return Values :  E_OK             - success            
d1686 2
a1687 1
static int IFN_Beginning_Of_Field(FORM * form)
d1691 1
d1694 2
a1695 2
		 Get_Start_Of_Data(field->buf,Buffer_Length(field)));
  return(E_OK);
d1699 1
a1699 1
|   Facility      :  libnform  
d1701 1
a1701 1
|   
d1704 1
a1704 1
|                    the buffer, the cursos is positioned on the last 
d1709 2
a1710 1
static int IFN_End_Of_Field(FORM * form)
d1713 1
a1713 1
  char *pos;
d1715 1
d1717 2
a1718 2
  pos = After_End_Of_Data(field->buf,Buffer_Length(field));
  if (pos==(field->buf + Buffer_Length(field)))
d1720 2
a1721 2
  Adjust_Cursor_Position(form,pos);
  return(E_OK);
d1725 1
a1725 1
|   Facility      :  libnform  
d1727 1
a1727 1
|   
d1733 2
a1734 1
static int IFN_Beginning_Of_Line(FORM * form)
d1738 1
d1741 3
a1743 3
		 Get_Start_Of_Data(Address_Of_Current_Row_In_Buffer(form),
				   field->dcols));
  return(E_OK);
d1747 1
a1747 1
|   Facility      :  libnform  
d1749 1
a1749 1
|   
d1751 1
a1751 1
|                    current line of the field. If the field occupies the 
d1757 2
a1758 1
static int IFN_End_Of_Line(FORM * form)
d1761 2
a1762 2
  char *pos;
  char *bp;
d1764 1
d1766 2
a1767 2
  bp  = Address_Of_Current_Row_In_Buffer(form); 
  pos = After_End_Of_Data(bp,field->dcols);
d1770 2
a1771 2
  Adjust_Cursor_Position(form,pos);
  return(E_OK);
d1775 1
a1775 1
|   Facility      :  libnform  
d1777 1
a1777 1
|   
d1779 1
a1779 1
|                    This doesn't cycle.  
d1784 2
a1785 1
static int IFN_Left_Character(FORM * form)
d1787 5
a1791 1
  if ( (--(form->curcol)) < 0 )
d1793 2
a1794 2
      form->curcol++;
      return(E_REQUEST_DENIED);
d1796 1
a1796 1
  return(E_OK);
d1800 1
a1800 1
|   Facility      :  libnform  
d1802 1
a1802 1
|   
d1809 2
a1810 1
static int IFN_Right_Character(FORM * form)
d1812 5
a1816 1
  if ( (++(form->curcol)) == form->current->dcols )
d1820 3
a1822 2
      if (Single_Line_Field(field) && Field_Grown(field,1))
	return(E_OK);
d1824 2
a1825 2
      --(form->curcol);
      return(E_REQUEST_DENIED);
d1827 1
a1827 1
  return(E_OK);
d1831 1
a1831 1
|   Facility      :  libnform  
d1833 1
a1833 1
|   
d1840 2
a1841 1
static int IFN_Up_Character(FORM * form)
d1843 2
a1844 1
  if ( (--(form->currow)) < 0 )
d1847 1
a1847 1
      return(E_REQUEST_DENIED);
d1849 1
a1849 1
  return(E_OK);
d1853 1
a1853 1
|   Facility      :  libnform  
d1855 1
a1855 1
|   
d1862 2
a1863 1
static int IFN_Down_Character(FORM * form)
d1867 2
a1868 1
  if ( (++(form->currow)) == field->drows )
d1871 2
a1872 2
      if (!Single_Line_Field(field) && Field_Grown(field,1))
	return(E_OK);
d1875 1
a1875 1
      return(E_REQUEST_DENIED);
d1877 1
a1877 1
  return(E_OK);
d1880 1
a1880 1
  END of Intra-Field Navigation routines 
d1882 1
a1882 1

d1888 2
a1889 2
|   Facility      :  libnform  
|   Function      :  static int VSC_Generic(FORM *form, int lines)
d1891 2
a1892 2
|   Description   :  Scroll multi-line field forward (lines>0) or
|                    backward (lines<0) this many lines.
d1894 1
a1894 1
|   Return Values :  E_OK              - success 
d1897 2
a1898 1
static int VSC_Generic(FORM *form, int lines)
d1902 1
a1902 1
  int rows_to_go = (lines > 0 ? lines : -lines);
d1904 1
a1904 1
  if (lines > 0)
d1906 1
a1906 1
      if ( (rows_to_go + form->toprow) > (field->drows - field->rows) )
d1920 1
a1920 1
      
d1928 1
a1928 1
  return(res);
d1933 1
a1933 1

d1939 1
a1939 1
|   Facility      :  libnform  
d1943 2
a1944 2
|   
|   Description   :  Performs the generic vertical scrolling routines. 
d1946 1
a1946 1
|                    the _NEWTOP flag if scrolling really occured.
d1950 2
a1951 1
static int Vertical_Scrolling(int (* const fct) (FORM *), FORM * form)
d1961 1
a1961 1
  return(res);
d1965 1
a1965 1
|   Facility      :  libnform  
d1967 1
a1967 1
|   
d1973 2
a1974 1
static int VSC_Scroll_Line_Forward(FORM * form)
d1976 2
a1977 1
  return VSC_Generic(form,1);
d1981 1
a1981 1
|   Facility      :  libnform  
d1983 1
a1983 1
|   
d1989 2
a1990 1
static int VSC_Scroll_Line_Backward(FORM * form)
d1992 2
a1993 1
  return VSC_Generic(form,-1);
d1997 1
a1997 1
|   Facility      :  libnform  
d1999 1
a1999 1
|   
d2005 2
a2006 1
static int VSC_Scroll_Page_Forward(FORM * form)
d2008 2
a2009 1
  return VSC_Generic(form,form->current->rows);
d2013 1
a2013 1
|   Facility      :  libnform  
d2015 1
a2015 1
|   
d2021 2
a2022 1
static int VSC_Scroll_Half_Page_Forward(FORM * form)
d2024 2
a2025 1
  return VSC_Generic(form,(form->current->rows + 1)/2);
d2029 1
a2029 1
|   Facility      :  libnform  
d2031 1
a2031 1
|   
d2037 2
a2038 1
static int VSC_Scroll_Page_Backward(FORM * form)
d2040 2
a2041 1
  return VSC_Generic(form, -(form->current->rows));
d2045 1
a2045 1
|   Facility      :  libnform  
d2047 1
a2047 1
|   
d2053 2
a2054 1
static int VSC_Scroll_Half_Page_Backward(FORM * form)
d2056 2
a2057 1
  return VSC_Generic(form, -((form->current->rows + 1)/2));
d2062 1
a2062 1

d2068 2
a2069 2
|   Facility      :  libnform  
|   Function      :  static int HSC_Generic(FORM *form, int columns)
d2071 2
a2072 2
|   Description   :  Scroll single-line field forward (columns>0) or
|                    backward (columns<0) this many columns.
d2074 1
a2074 1
|   Return Values :  E_OK              - success 
d2077 2
a2078 1
static int HSC_Generic(FORM *form, int columns)
d2082 1
a2082 1
  int cols_to_go = (columns > 0 ? columns : -columns);
d2084 1
a2084 1
  if (columns > 0)
d2088 1
a2088 1
      
d2091 1
a2091 1
	  form->curcol   += cols_to_go;
d2098 1
a2098 1
      if ( cols_to_go > form->begincol )
d2103 1
a2103 1
	  form->curcol   -= cols_to_go;
d2108 1
a2108 1
  return(res);
d2113 1
a2113 1

d2119 1
a2119 1
|   Facility      :  libnform  
d2123 2
a2124 2
|   
|   Description   :  Performs the generic horizontal scrolling routines. 
d2129 2
a2130 1
static int Horizontal_Scrolling(int (* const fct) (FORM *), FORM * form)
d2135 1
a2135 1
    return(E_REQUEST_DENIED);
d2139 1
a2139 1
|   Facility      :  libnform  
d2141 1
a2141 1
|   
d2147 2
a2148 1
static int HSC_Scroll_Char_Forward(FORM *form)
d2150 2
a2151 1
  return HSC_Generic(form,1);
d2155 1
a2155 1
|   Facility      :  libnform  
d2157 1
a2157 1
|   
d2163 2
a2164 1
static int HSC_Scroll_Char_Backward(FORM *form)
d2166 2
a2167 1
  return HSC_Generic(form,-1);
d2171 1
a2171 1
|   Facility      :  libnform  
d2173 1
a2173 1
|   
d2179 2
a2180 1
static int HSC_Horizontal_Line_Forward(FORM * form)
d2182 2
a2183 1
  return HSC_Generic(form,form->current->cols);
d2187 1
a2187 1
|   Facility      :  libnform  
d2189 1
a2189 1
|   
d2195 2
a2196 1
static int HSC_Horizontal_Half_Line_Forward(FORM * form)
d2198 2
a2199 1
  return HSC_Generic(form,(form->current->cols + 1)/2);
d2203 1
a2203 1
|   Facility      :  libnform  
d2205 1
a2205 1
|   
d2211 2
a2212 1
static int HSC_Horizontal_Line_Backward(FORM * form)
d2214 2
a2215 1
  return HSC_Generic(form,-(form->current->cols));
d2219 1
a2219 1
|   Facility      :  libnform  
d2221 1
a2221 1
|   
d2227 2
a2228 1
static int HSC_Horizontal_Half_Line_Backward(FORM * form)
d2230 2
a2231 1
  return HSC_Generic(form,-((form->current->cols + 1)/2));
d2237 1
a2237 1

d2243 1
a2243 1
|   Facility      :  libnform  
d2245 1
a2245 1
|   
d2252 2
a2253 1
INLINE static bool Is_There_Room_For_A_Line(FORM * form)
d2256 2
a2257 2
  char *begin_of_last_line, *s;
  
d2259 3
a2261 3
  begin_of_last_line = Address_Of_Row_In_Buffer(field,(field->drows-1));
  s  = After_End_Of_Data(begin_of_last_line,field->dcols);
  return ((s==begin_of_last_line) ? TRUE : FALSE);
d2265 1
a2265 1
|   Facility      :  libnform  
d2267 1
a2267 1
|   
d2274 2
a2275 1
INLINE static bool Is_There_Room_For_A_Char_In_Line(FORM * form)
d2279 3
a2281 3
  wmove(form->w,form->currow,form->current->dcols-1);
  last_char_in_line  = (int)(winch(form->w) & A_CHARTEXT);
  wmove(form->w,form->currow,form->curcol);
d2290 1
a2290 1
|   Facility      :  libnform  
d2296 1
a2296 1
|   
d2300 1
a2300 1
|                    moved to the right. After the text a pad character will 
d2305 1
a2305 1
|   Return Values :  E_OK              - success 
d2309 9
a2317 8
static int Insert_String(FORM *form, int row, char *txt, int len)
{ 
  FIELD  *field    = form->current;
  char *bp         = Address_Of_Row_In_Buffer(field,row);
  int datalen      = (int)(After_End_Of_Data(bp,field->dcols) - bp);
  int freelen      = field->dcols - datalen;
  int requiredlen  = len+1;
  char *split;
a2318 1
  const char *Space = " ";
d2322 4
a2325 4
      wmove(form->w,row,0);
      winsnstr(form->w,txt,len);
      wmove(form->w,row,len);
      winsnstr(form->w,Space,1);
d2329 3
a2331 2
    { /* we have to move characters on the next line. If we are on the
	 last line this may work, if the field is growable */
d2334 2
a2335 2
	  if (!Field_Grown(field,1))
	    return(E_SYSTEM_ERROR);
d2337 1
a2337 1
	  bp = Address_Of_Row_In_Buffer(field,row); 
d2340 9
a2348 5
      if (row < (field->drows - 1)) 
	{ 
	  split = After_Last_Whitespace_Character(bp,
		    (int)(Get_Start_Of_Data(bp + field->dcols - requiredlen ,
					    requiredlen) - bp));
d2351 2
a2352 2
	  datalen = (int)(split-bp); /* + freelen has to stay on this line   */
	  freelen = field->dcols - (datalen + freelen); /* for the next line */
d2354 1
a2354 1
	  if ((result=Insert_String(form,row+1,split,freelen))==E_OK) 
d2356 1
a2356 1
	      wmove(form->w,row,datalen);
d2358 4
a2361 4
	      wmove(form->w,row,0);
	      winsnstr(form->w,txt,len);
	      wmove(form->w,row,len);
	      winsnstr(form->w,Space,1);
d2365 1
a2365 1
      return(result);
d2370 1
a2370 1
|   Facility      :  libnform  
d2373 1
a2373 1
|   
d2384 2
a2385 1
static int Wrapping_Not_Necessary_Or_Wrapping_Ok(FORM * form)
d2387 1
a2387 1
  FIELD  *field = form->current;
d2391 4
a2394 4
  if ( (field->opts & O_WRAP)                     &&  /* wrapping wanted     */
      (!Single_Line_Field(field))                 &&  /* must be multi-line  */
      (There_Is_No_Room_For_A_Char_In_Line(form)) &&  /* line is full        */
      (!Last_Row || Growable(field))               )  /* there are more lines*/
d2396 2
a2397 2
      char *bp;
      char *split;
d2400 1
d2402 2
a2403 1
	{ /* the above logic already ensures, that in this case the field
d2405 1
a2405 1
	  if (!Field_Grown(field,1))
d2409 2
a2410 2
      Window_To_Buffer(form->w,field);
      split = After_Last_Whitespace_Character(bp,field->dcols);
d2414 1
a2414 1
      chars_to_be_wrapped     = field->dcols - chars_to_remain_on_line;
d2417 2
a2418 2
	  if ((result=Insert_String(form,form->currow+1,split,
				    chars_to_be_wrapped)) == E_OK)
d2420 1
a2420 1
	      wmove(form->w,form->currow,chars_to_remain_on_line);
d2432 1
a2432 1
      if (result!=E_OK)
d2434 2
a2435 3
	  wmove(form->w,form->currow,form->curcol);
	  wdelch(form->w);
	  Window_To_Buffer(form->w,field);
d2440 2
a2441 2
    result = E_OK; /* wrapping was not necessary */
  return(result);
d2443 1
a2443 1

d2449 1
a2449 1
|   Facility      :  libnform  
d2453 1
a2453 1
|   
d2456 1
a2456 1
|                    _WINDOW_MODIFIED flag is set if editing occured.
d2462 2
a2463 1
static int Field_Editing(int (* const fct) (FORM *), FORM * form)
d2467 2
a2468 2
  /* We have to deal here with the specific case of the overloaded 
     behaviour of New_Line and Delete_Previous requests.
d2472 4
a2475 4
  */ 
  if ((fct==FE_Delete_Previous)            && 
      (form->opts & O_BS_OVERLOAD)         &&
      First_Position_In_Current_Field(form) )
d2477 1
a2477 1
      res = Inter_Field_Navigation(FN_Previous_Field,form);
d2481 1
a2481 1
      if (fct==FE_New_Line)
d2483 1
a2483 1
	  if ((form->opts & O_NL_OVERLOAD)         &&
d2486 1
a2486 1
	      res = Inter_Field_Navigation(FN_Next_Field,form);
d2498 1
a2498 1
	      if (res==E_OK)
d2507 1
a2507 1
|   Facility      :  libnform  
d2509 1
a2509 1
|   
d2511 1
a2511 1
|                    compared to other routines in this code due to the 
d2519 2
a2520 1
static int FE_New_Line(FORM * form)
d2522 6
a2527 5
  FIELD  *field = form->current;
  char *bp, *t;
  bool Last_Row = ((field->drows - 1)==form->currow);
  
  if (form->status & _OVLMODE) 
d2529 1
a2529 1
      if (Last_Row && 
d2533 2
a2534 1
	    return(E_REQUEST_DENIED);
d2541 1
a2541 1
	  return Inter_Field_Navigation(FN_Next_Field,form);
d2543 1
a2543 1
      else 
d2545 6
a2550 5
	  if (Last_Row && !Field_Grown(field,1))
	    { /* N.B.: due to the logic in the 'if', LastRow==TRUE
		 means here that the field is growable and not
		 a single-line field */
	      return(E_SYSTEM_ERROR);
d2552 1
d2557 1
a2557 1
	  return(E_OK);
d2560 3
a2562 2
  else 
    { /* Insert Mode */
d2567 2
a2568 2
	    return(E_REQUEST_DENIED);
	  return Inter_Field_Navigation(FN_Next_Field,form);
d2570 1
a2570 1
      else 
d2573 1
a2573 1
	  
d2575 7
a2581 6
	    return(E_REQUEST_DENIED);
	  if (!May_Do_It && !Field_Grown(field,1))
	    return(E_SYSTEM_ERROR);
	  
	  bp= Address_Of_Current_Position_In_Buffer(form);
	  t = After_End_Of_Data(bp,field->dcols - form->curcol);
d2584 2
a2585 2
	  form->curcol=0;
	  wmove(form->w,form->currow,form->curcol);
d2587 1
a2587 1
	  waddnstr(form->w,bp,(int)(t-bp));
d2589 1
a2589 1
	  return E_OK;
d2595 1
a2595 1
|   Facility      :  libnform  
d2597 1
a2597 1
|   
d2603 2
a2604 1
static int FE_Insert_Character(FORM * form)
d2609 2
a2610 1
  if (Check_Char(field->type,(int)C_BLANK,(TypeArgument *)(field->arg)))
d2617 2
a2618 2
	  if (!There_Is_Room && !Field_Grown(field,1))
	    result =  E_SYSTEM_ERROR;
d2621 1
a2621 1
	      winsch(form->w,(chtype)C_BLANK);
d2626 1
a2626 1
  return result;
d2630 1
a2630 1
|   Facility      :  libnform  
d2632 1
a2632 1
|   
d2638 2
a2639 1
static int FE_Insert_Line(FORM * form)
d2644 2
a2645 1
  if (Check_Char(field->type,(int)C_BLANK,(TypeArgument *)(field->arg)))
d2647 2
a2648 2
      bool Maybe_Done = (form->currow!=(field->drows-1)) && 
	                Is_There_Room_For_A_Line(form);
d2653 1
a2653 1
	  if (!Maybe_Done && !Field_Grown(field,1))
d2663 1
a2663 1
  return result;
d2667 1
a2667 1
|   Facility      :  libnform  
d2669 1
a2669 1
|   
d2674 2
a2675 1
static int FE_Delete_Character(FORM * form)
d2677 3
a2679 2
  wdelch(form->w);
  return E_OK;
d2683 1
a2683 1
|   Facility      :  libnform  
d2685 1
a2685 1
|   
d2695 2
a2696 1
static int FE_Delete_Previous(FORM * form)
d2698 3
a2700 2
  FIELD  *field = form->current;
  
d2702 1
a2702 1
    return E_REQUEST_DENIED;
d2704 1
a2704 1
  if ( (--(form->curcol))<0 )
d2706 3
a2708 2
      char *this_line, *prev_line, *prev_end, *this_end;
      
d2710 5
a2714 5
      if (form->status & _OVLMODE) 
	return E_REQUEST_DENIED;
      
      prev_line = Address_Of_Row_In_Buffer(field,(form->currow-1));
      this_line = Address_Of_Row_In_Buffer(field,(form->currow));
d2716 6
a2721 5
      prev_end = After_End_Of_Data(prev_line,field->dcols);
      this_end = After_End_Of_Data(this_line,field->dcols);
      if ((int)(this_end-this_line) > 
	  (field->cols-(int)(prev_end-prev_line))) 
	return E_REQUEST_DENIED;
d2723 28
a2750 5
      Adjust_Cursor_Position(form,prev_end);
      wmove(form->w,form->currow,form->curcol);
      waddnstr(form->w,this_line,(int)(this_end-this_line));
    } 
  else 
d2752 1
a2752 2
      wmove(form->w,form->currow,form->curcol);
      wdelch(form->w);
d2754 1
a2754 1
  return E_OK;
d2758 1
a2758 1
|   Facility      :  libnform  
d2760 1
a2760 1
|   
d2765 2
a2766 1
static int FE_Delete_Line(FORM * form)
d2768 1
d2771 1
a2771 1
  return E_OK;
d2775 1
a2775 1
|   Facility      :  libnform  
d2777 1
a2777 1
|   
d2783 2
a2784 1
static int FE_Delete_Word(FORM * form)
d2786 7
a2792 6
  FIELD  *field = form->current;
  char   *bp = Address_Of_Current_Row_In_Buffer(form);
  char   *ep = bp + field->dcols;
  char   *cp = bp + form->curcol;
  char *s;
  
d2794 2
a2795 2
  if (is_blank(*cp)) 
    return E_REQUEST_DENIED; /* not in word */
d2799 2
a2800 2
			 After_Last_Whitespace_Character(bp,form->curcol)); 
  wmove(form->w,form->currow,form->curcol);
d2804 1
a2804 1
  s = Get_First_Whitespace_Character(cp,(int)(ep-cp)); 
d2806 2
a2807 2
  s = Get_Start_Of_Data(s,(int)(ep - s));
  if ( (s!=cp) && !is_blank(*s))
d2810 1
a2810 1
      waddnstr(form->w,s,(int)(s - After_End_Of_Data(s,(int)(ep - s))));
d2812 1
a2812 1
  return E_OK;
d2816 1
a2816 1
|   Facility      :  libnform  
d2818 1
a2818 1
|   
d2823 2
a2824 1
static int FE_Clear_To_End_Of_Line(FORM * form)
d2826 2
d2829 1
a2829 1
  return E_OK;
d2833 4
a2836 4
|   Facility      :  libnform  
|   Function      :  static int FE_Clear_To_End_Of_Form(FORM * form)
|   
|   Description   :  Clear to end of form.
d2840 2
a2841 1
static int FE_Clear_To_End_Of_Form(FORM * form)
d2843 2
d2846 1
a2846 1
  return E_OK;
d2850 1
a2850 1
|   Facility      :  libnform  
d2852 1
a2852 1
|   
d2857 2
a2858 1
static int FE_Clear_Field(FORM * form)
d2860 1
d2863 1
a2863 1
  return E_OK;
d2866 1
a2866 1
  END of Field Editing routines 
d2868 1
a2868 1

d2874 1
a2874 1
|   Facility      :  libnform  
d2876 1
a2876 1
|   
d2881 2
a2882 1
static int EM_Overlay_Mode(FORM * form)
d2884 1
d2886 1
a2886 1
  return E_OK;
d2890 1
a2890 1
|   Facility      :  libnform  
d2892 1
a2892 1
|   
d2897 2
a2898 1
static int EM_Insert_Mode(FORM * form)
d2900 1
d2902 1
a2902 1
  return E_OK;
d2906 1
a2906 1
  END of Edit Mode routines 
d2908 1
a2908 1

d2914 1
a2914 1
|   Facility      :  libnform  
d2919 1
a2919 1
|   
d2926 2
a2927 1
static bool Next_Choice(FIELDTYPE * typ, FIELD *field, TypeArgument *argp)
d2929 1
a2929 1
  if (!typ || !(typ->status & _HAS_CHOICE)) 
d2935 4
a2938 4
      return(
	     Next_Choice(typ->left ,field,argp->left) ||
	     Next_Choice(typ->right,field,argp->right) );
    } 
d2942 1
a2942 1
      return typ->next(field,(void *)argp);
d2947 1
a2947 1
|   Facility      :  libnform  
d2952 1
a2952 1
|   
d2959 2
a2960 1
static bool Previous_Choice(FIELDTYPE *typ, FIELD *field, TypeArgument *argp)
d2962 1
a2962 1
  if (!typ || !(typ->status & _HAS_CHOICE)) 
d2968 5
a2972 5
      return(
	     Previous_Choice(typ->left ,field,argp->left) ||
	     Previous_Choice(typ->right,field,argp->right));
    } 
  else 
d2975 1
a2975 1
      return typ->prev(field,(void *)argp);
d2981 1
a2981 1

d2987 1
a2987 1
|   Facility      :  libnform  
d2989 1
a2989 1
|   
d2995 2
a2996 1
static int CR_Next_Choice(FORM * form)
d2999 2
d3002 3
a3004 2
  return ((Next_Choice(field->type,field,(TypeArgument *)(field->arg))) ? 
	  E_OK : E_REQUEST_DENIED);
d3008 1
a3008 1
|   Facility      :  libnform  
d3010 1
a3010 1
|   
d3016 2
a3017 1
static int CR_Previous_Choice(FORM * form)
d3020 2
d3023 3
a3025 2
  return ((Previous_Choice(field->type,field,(TypeArgument *)(field->arg))) ? 
	  E_OK : E_REQUEST_DENIED);
d3030 1
a3030 1

d3036 1
a3036 1
|   Facility      :  libnform  
d3041 1
a3041 1
|   
d3049 2
a3050 1
static bool Check_Field(FIELDTYPE *typ, FIELD *field, TypeArgument *argp)
d3056 2
a3057 1
	  char *bp = field->buf;
d3059 5
a3063 3
	  while(is_blank(*bp))
	    { bp++; }
	  if (*bp == '\0') 
d3070 3
a3072 3
	  return( 
		 Check_Field(typ->left ,field,argp->left ) ||
		 Check_Field(typ->right,field,argp->right) );
d3074 1
a3074 1
      else 
d3077 1
a3077 1
	    return typ->fcheck(field,(void *)argp);
d3084 1
a3084 1
|   Facility      :  libnform  
d3086 2
a3087 2
|   
|   Description   :  Validate the current field of the form.  
d3093 1
a3093 1
_nc_Internal_Validation (FORM *form)
d3097 2
a3098 2
  field = form->current; 
  
d3103 1
a3103 1
      if (!Check_Field(field->type,field,(TypeArgument *)(field->arg)))
d3105 1
a3105 1
      form->status  &= ~_FCHECK_REQUIRED;
d3114 1
a3114 1

d3120 1
a3120 1
|   Facility      :  libnform  
d3122 1
a3122 1
|   
d3128 2
a3129 1
static int FV_Validation(FORM * form)
d3131 1
d3133 1
a3133 1
    return E_OK;
d3135 1
a3135 1
    return E_INVALID_FIELD;
d3140 1
a3140 1

d3146 1
a3146 1
|   Facility      :  libnform  
d3148 2
a3149 2
|   
|   Description   :  Get the next field after the given field on the current 
d3156 2
a3157 1
INLINE static FIELD *Next_Field_On_Page(FIELD * field)
d3159 1
a3159 1
  FORM  *form = field->form;
d3162 1
a3162 1
  FIELD **last_on_page  = &form->field[form->page[form->curpage].pmax];
d3166 2
a3167 2
      field_on_page = 
	(field_on_page==last_on_page) ? first_on_page : field_on_page + 1;
d3170 3
a3172 2
    } while(field!=(*field_on_page));  
  return(*field_on_page);
d3176 1
a3176 1
|   Facility      :  libnform  
d3178 1
a3178 1
|   
d3186 2
a3187 2
NCURSES_EXPORT(FIELD*)
_nc_First_Active_Field (FORM * form)
d3193 5
a3197 4
    { /* there might be the special situation, where there is no 
	 active and visible field on the current page. We then select
	 the first visible field on this readonly page
      */
d3205 1
a3205 1
	      field = (field==last_on_page) ? first : field + 1;
d3208 3
a3210 2
	    } while(proposed!=(*field));
	  
d3213 6
a3218 5
	  if ((proposed == *last_on_page) && !(proposed->opts&O_VISIBLE))
	    { /* This means, there is also no visible field on the page.
		 So we propose the first one and hope the very best... 
		 Some very clever user has designed a readonly and invisible
		 page on this form.
d3224 1
a3224 1
  return(proposed);
d3228 1
a3228 1
|   Facility      :  libnform  
d3230 3
a3232 3
|   
|   Description   :  Get the previous field before the given field on the 
|                    current page. The order of fields is the one defined by 
d3238 2
a3239 1
INLINE static FIELD *Previous_Field_On_Page(FIELD * field)
d3241 1
a3241 1
  FORM  *form   = field->form;
d3244 2
a3245 2
  FIELD **last_on_page  = &form->field[form->page[form->curpage].pmax];
  
d3248 2
a3249 2
      field_on_page = 
	(field_on_page==first_on_page) ? last_on_page : field_on_page - 1;
d3252 3
a3254 2
    } while(field!=(*field_on_page));
  
d3259 1
a3259 1
|   Facility      :  libnform  
d3261 2
a3262 2
|   
|   Description   :  Get the next field after the given field on the current 
d3268 2
a3269 1
INLINE static FIELD *Sorted_Next_Field(FIELD * field)
d3278 3
a3280 2
    } while(field_on_page!=field);
  
d3285 1
a3285 1
|   Facility      :  libnform  
d3287 3
a3289 3
|   
|   Description   :  Get the previous field before the given field on the 
|                    current page. The order of fields is the one defined 
d3294 2
a3295 1
INLINE static FIELD *Sorted_Previous_Field(FIELD * field)
d3304 3
a3306 2
    } while(field_on_page!=field);
  
d3311 4
a3314 4
|   Facility      :  libnform  
|   Function      :  static FIELD *Left_Neighbour_Field(FIELD * field)
|   
|   Description   :  Get the left neighbour of the field on the same line
d3317 1
a3317 1
|   Return Values :  Pointer to left neighbour field.
d3319 2
a3320 1
INLINE static FIELD *Left_Neighbour_Field(FIELD * field)
d3324 1
a3324 1
  /* For a field that has really a left neighbour, the while clause
d3326 1
a3326 1
     neighbour. Otherwise we cycle backwards through the sorted fieldlist
d3328 1
a3328 1
  */
d3332 3
a3334 2
    } while(field_on_page->frow != field->frow);
  
d3339 4
a3342 4
|   Facility      :  libnform  
|   Function      :  static FIELD *Right_Neighbour_Field(FIELD * field)
|   
|   Description   :  Get the right neighbour of the field on the same line
d3345 1
a3345 1
|   Return Values :  Pointer to right neighbour field.
d3347 2
a3348 1
INLINE static FIELD *Right_Neighbour_Field(FIELD * field)
d3352 1
a3352 1
  /* See the comments on Left_Neighbour_Field to understand how it works */
d3356 3
a3358 2
    } while(field_on_page->frow != field->frow);
  
d3363 3
a3365 3
|   Facility      :  libnform  
|   Function      :  static FIELD *Upper_Neighbour_Field(FIELD * field)
|   
d3367 1
a3367 1
|                    its more difficult to define whats the upper neighbour
d3373 1
a3373 1
|   Return Values :  Pointer to the upper neighbour field.
d3375 2
a3376 1
static FIELD *Upper_Neighbour_Field(FIELD * field)
d3385 1
a3385 1
  */
d3389 6
a3394 4
    } while(field_on_page->frow==frow && field_on_page->fcol!=fcol);
  
  if (field_on_page->frow!=frow)
    { /* We really found a 'previous' line. We are positioned at the
d3396 1
a3396 1
      frow = field_on_page->frow; 
d3398 3
a3400 3
      /* We walk to the left as long as we are really right of the 
	 field. */
      while(field_on_page->frow==frow && field_on_page->fcol>fcol)
d3403 3
a3405 3
      /* If we wrapped, just go to the right which is the first field on 
	 the row */
      if (field_on_page->frow!=frow)
d3408 1
a3408 1
  
d3413 3
a3415 3
|   Facility      :  libnform  
|   Function      :  static FIELD *Down_Neighbour_Field(FIELD * field)
|   
d3417 1
a3417 1
|                    its more difficult to define whats the down neighbour
d3423 1
a3423 1
|   Return Values :  Pointer to the upper neighbour field.
d3425 2
a3426 1
static FIELD *Down_Neighbour_Field(FIELD * field)
d3435 1
a3435 1
  */
d3439 2
a3440 1
    } while(field_on_page->frow==frow && field_on_page->fcol!=fcol);
d3442 3
a3444 2
  if (field_on_page->frow!=frow)
    { /* We really found a 'next' line. We are positioned at the rightmost
d3448 3
a3450 3
      /* We walk to the right as long as we are really left of the 
	 field. */
      while(field_on_page->frow==frow && field_on_page->fcol<fcol)
d3453 3
a3455 3
      /* If we wrapped, just go to the left which is the last field on 
	 the row */
      if (field_on_page->frow!=frow)
d3458 2
a3459 2
  
  return(field_on_page);
d3461 1
a3461 1

d3467 1
a3467 1
|   Facility      :  libnform  
d3471 2
a3472 2
|   
|   Description   :  Generic behaviour for changing the current field, the
d3481 2
a3482 1
static int Inter_Field_Navigation(int (* const fct) (FORM *),FORM *form)
d3486 1
a3486 1
  if (!_nc_Internal_Validation(form)) 
d3490 1
a3490 1
      Call_Hook(form,fieldterm);
d3492 1
a3492 1
      Call_Hook(form,fieldinit);
d3498 1
a3498 1
|   Facility      :  libnform  
d3500 1
a3500 1
|   
d3506 2
a3507 1
static int FN_Next_Field(FORM * form)
d3509 3
a3511 2
  return _nc_Set_Current_Field(form,
			       Next_Field_On_Page(form->current));
d3515 1
a3515 1
|   Facility      :  libnform  
d3517 2
a3518 2
|   
|   Description   :  Move to the previous field on the current page of the 
d3524 2
a3525 1
static int FN_Previous_Field(FORM * form)
d3527 3
a3529 2
  return _nc_Set_Current_Field(form,
			       Previous_Field_On_Page(form->current));
d3533 1
a3533 1
|   Facility      :  libnform  
d3535 1
a3535 1
|   
d3541 2
a3542 1
static int FN_First_Field(FORM * form)
d3544 3
a3546 2
  return _nc_Set_Current_Field(form,
      Next_Field_On_Page(form->field[form->page[form->curpage].pmax]));
d3550 1
a3550 1
|   Facility      :  libnform  
d3552 1
a3552 1
|   
d3558 2
a3559 1
static int FN_Last_Field(FORM * form)
d3561 4
a3564 3
  return 
    _nc_Set_Current_Field(form,
       Previous_Field_On_Page(form->field[form->page[form->curpage].pmin]));
d3568 1
a3568 1
|   Facility      :  libnform  
d3570 1
a3570 1
|   
d3577 2
a3578 1
static int FN_Sorted_Next_Field(FORM * form)
d3580 3
a3582 2
  return _nc_Set_Current_Field(form,
			       Sorted_Next_Field(form->current));
d3586 1
a3586 1
|   Facility      :  libnform  
d3588 1
a3588 1
|   
d3595 2
a3596 1
static int FN_Sorted_Previous_Field(FORM * form)
d3598 3
a3600 2
  return _nc_Set_Current_Field(form,
			       Sorted_Previous_Field(form->current));
d3604 1
a3604 1
|   Facility      :  libnform  
d3606 1
a3606 1
|   
d3613 2
a3614 1
static int FN_Sorted_First_Field(FORM * form)
d3616 3
a3618 2
  return _nc_Set_Current_Field(form,
	      Sorted_Next_Field(form->field[form->page[form->curpage].smax]));
d3622 1
a3622 1
|   Facility      :  libnform  
d3624 1
a3624 1
|   
d3631 2
a3632 1
static int FN_Sorted_Last_Field(FORM * form)
d3634 3
a3636 2
  return _nc_Set_Current_Field(form,
	   Sorted_Previous_Field(form->field[form->page[form->curpage].smin]));
d3640 1
a3640 1
|   Facility      :  libnform  
d3642 1
a3642 1
|   
d3649 2
a3650 1
static int FN_Left_Field(FORM * form)
d3652 3
a3654 2
  return _nc_Set_Current_Field(form,
			       Left_Neighbour_Field(form->current));
d3658 1
a3658 1
|   Facility      :  libnform  
d3660 1
a3660 1
|   
d3667 2
a3668 1
static int FN_Right_Field(FORM * form)
d3670 3
a3672 2
  return _nc_Set_Current_Field(form,
			       Right_Neighbour_Field(form->current));
d3676 1
a3676 1
|   Facility      :  libnform  
d3678 2
a3679 2
|   
|   Description   :  Get the upper neighbour of the current field. This
d3681 2
a3682 2
|                    Upper_Neighbour_Field function to understand how
|                    'upper' is defined. 
d3687 2
a3688 1
static int FN_Up_Field(FORM * form)
d3690 3
a3692 2
  return _nc_Set_Current_Field(form,
			       Upper_Neighbour_Field(form->current));
d3696 1
a3696 1
|   Facility      :  libnform  
d3698 2
a3699 2
|   
|   Description   :  Get the down neighbour of the current field. This
d3701 2
a3702 2
|                    Down_Neighbour_Field function to understand how
|                    'down' is defined. 
d3707 2
a3708 1
static int FN_Down_Field(FORM * form)
d3710 3
a3712 2
  return _nc_Set_Current_Field(form,
			       Down_Neighbour_Field(form->current));
d3715 1
a3715 1
  END of Field Navigation routines 
d3717 1
a3717 1

d3723 1
a3723 1
|   Facility      :  libnform  
d3727 2
a3728 2
|   
|   Description   :  Make the given page nr. the current page and make
d3736 2
d3740 1
a3740 2
_nc_Set_Form_Page
(FORM * form, int page, FIELD * field)
d3744 1
a3744 1
  if ((form->curpage!=page))
d3754 2
a3755 2
	    if ((res=Display_Field(field_on_page))!=E_OK) 
	      return(res);
d3757 2
a3758 1
	} while(field_on_page != last_field);
d3761 1
a3761 1
	res = _nc_Set_Current_Field(form,field);
d3765 1
a3765 1
	   context that contains field navigation 
d3769 1
a3769 1
  return(res);
d3773 1
a3773 1
|   Facility      :  libnform  
d3775 1
a3775 1
|   
d3778 1
a3778 1
|                    reached.  
d3782 2
a3783 1
INLINE static int Next_Page_Number(const FORM * form)
d3789 1
a3789 1
|   Facility      :  libnform  
d3791 1
a3791 1
|   
d3794 1
a3794 1
|                    reached.  
d3798 2
a3799 1
INLINE static int Previous_Page_Number(const FORM * form)
d3801 1
a3801 1
  return (form->curpage!=0 ? form->curpage - 1 : form->maxpage - 1);
d3803 1
a3803 1

d3805 1
a3805 1
  Page Navigation routines 
d3809 1
a3809 1
|   Facility      :  libnform  
d3813 2
a3814 2
|   
|   Description   :  Generic behaviour for changing a page. This means
d3824 2
a3825 1
static int Page_Navigation(int (* const fct) (FORM *), FORM * form)
d3829 1
a3829 1
  if (!_nc_Internal_Validation(form)) 
d3833 2
a3834 2
      Call_Hook(form,fieldterm);
      Call_Hook(form,formterm);
d3836 2
a3837 2
      Call_Hook(form,forminit);
      Call_Hook(form,fieldinit);
d3843 1
a3843 1
|   Facility      :  libnform  
d3845 1
a3845 1
|   
d3851 5
a3855 3
static int PN_Next_Page(FORM * form)
{ 
  return _nc_Set_Form_Page(form,Next_Page_Number(form),(FIELD *)0);
d3859 1
a3859 1
|   Facility      :  libnform  
d3861 1
a3861 1
|   
d3867 2
a3868 1
static int PN_Previous_Page(FORM * form)
d3870 2
a3871 1
  return _nc_Set_Form_Page(form,Previous_Page_Number(form),(FIELD *)0);
d3875 1
a3875 1
|   Facility      :  libnform  
d3877 1
a3877 1
|   
d3883 2
a3884 1
static int PN_First_Page(FORM * form)
d3886 2
a3887 1
  return _nc_Set_Form_Page(form,0,(FIELD *)0);
d3891 1
a3891 1
|   Facility      :  libnform  
d3893 1
a3893 1
|   
d3899 2
a3900 1
static int PN_Last_Page(FORM * form)
d3902 2
a3903 1
  return _nc_Set_Form_Page(form,form->maxpage-1,(FIELD *)0);
d3905 1
d3907 1
a3907 1
  END of Field Navigation routines 
d3909 1
a3909 1

d3915 1
a3915 1
|   Facility      :  libnform  
d3917 1
a3917 1
|   
d3921 2
a3922 2
|   Return Values :  E_OK              -
|                    E_REQUEST_DENIED  -
d3925 2
a3926 1
static int Data_Entry(FORM * form, int c)
d3928 1
a3928 1
  FIELD  *field = form->current;
d3931 2
a3932 1
  if ( (field->opts & O_EDIT) 
d3934 1
a3934 1
       && (field->opts & O_ACTIVE) 
d3936 1
a3936 1
       )
d3938 4
a3941 4
      if ( (field->opts & O_BLANK) &&
	   First_Position_In_Current_Field(form) &&
	   !(form->status & _FCHECK_REQUIRED) && 
	   !(form->status & _WINDOW_MODIFIED) )
d3946 4
a3949 3
	  waddch(form->w,(chtype)c);
	} 
      else /* no _OVLMODE */ 
d3955 1
a3955 1
	      return E_REQUEST_DENIED;
d3957 2
a3958 2
	  if (!There_Is_Room && !Field_Grown(field,1))
	    return E_SYSTEM_ERROR;
d3960 1
a3960 1
	  winsch(form->w,(chtype)c);
d3963 1
a3963 1
      if ((result=Wrapping_Not_Necessary_Or_Wrapping_Ok(form))==E_OK)
d3965 3
a3967 2
	  bool End_Of_Field= (((field->drows-1)==form->currow) &&
			      ((field->dcols-1)==form->curcol));
d3970 1
a3970 1
	    result = Inter_Field_Navigation(FN_Next_Field,form);
d3973 1
a3973 1
	      if (End_Of_Field && Growable(field) && !Field_Grown(field,1))
d3977 10
d3988 1
d3994 1
a3994 1
  return result;
d3996 1
a3996 1

d4001 1
a4001 1
   the lower 16 bits. 
d4008 6
a4013 4
typedef struct {
  int keycode;           /* must be at least 32 bit: hi:mode, lo: key */
  int (*cmd)(FORM *);    /* low level driver routine for this key     */
} Binding_Info;
d4016 9
a4024 9
#define ID_PN    (0x00000000)    /* Page navigation           */
#define ID_FN    (0x00010000)    /* Inter-Field navigation    */
#define ID_IFN   (0x00020000)    /* Intra-Field navigation    */
#define ID_VSC   (0x00030000)    /* Vertical Scrolling        */
#define ID_HSC   (0x00040000)    /* Horizontal Scrolling      */
#define ID_FE    (0x00050000)    /* Field Editing             */
#define ID_EM    (0x00060000)    /* Edit Mode                 */
#define ID_FV    (0x00070000)    /* Field Validation          */
#define ID_CH    (0x00080000)    /* Choice                    */
d4030 2
a4031 1
static const Binding_Info bindings[MAX_FORM_COMMAND - MIN_FORM_COMMAND + 1] = 
d4037 1
a4037 1
  
d4050 1
a4050 1
  
d4065 1
a4065 1
  
d4074 1
a4074 1
  { REQ_CLR_EOF      |ID_FE  ,FE_Clear_To_End_Of_Form},
d4076 1
a4076 1
  
d4079 1
a4079 1
  
d4086 1
a4086 1
  
d4093 1
a4093 1
  
d4099 1
d4102 1
a4102 1
|   Facility      :  libnform  
d4104 1
a4104 1
|   
d4123 1
d4127 1
a4127 1
form_driver (FORM * form, int  c)
d4129 1
a4129 1
  const Binding_Info* BI = (Binding_Info *)0;
d4132 2
d4139 1
a4139 1
  
d4141 2
a4142 2
  
  if (c==FIRST_ACTIVE_MAGIC)
d4145 1
a4145 1
      return E_OK;
d4147 3
a4149 3
  
  assert(form->current && 
	 form->current->buf && 
d4151 3
a4153 3
	);
  
  if ( form->status & _IN_DRIVER )
d4156 1
a4156 1
  if ( !( form->status & _POSTED ) ) 
d4158 5
a4162 5
  
  if ((c>=MIN_FORM_COMMAND && c<=MAX_FORM_COMMAND) &&
      ((bindings[c-MIN_FORM_COMMAND].keycode & Key_Mask) == c))
    BI = &(bindings[c-MIN_FORM_COMMAND]);
  
d4165 17
a4181 17
      typedef int (*Generic_Method)(int (* const)(FORM *),FORM *);
      static const Generic_Method Generic_Methods[] = 
	{
	  Page_Navigation,         /* overloaded to call field&form hooks */
	  Inter_Field_Navigation,  /* overloaded to call field hooks      */
	  NULL,                    /* Intra-Field is generic              */
	  Vertical_Scrolling,      /* Overloaded to check multi-line      */
	  Horizontal_Scrolling,    /* Overloaded to check single-line     */
	  Field_Editing,           /* Overloaded to mark modification     */
	  NULL,                    /* Edit Mode is generic                */
	  NULL,                    /* Field Validation is generic         */
	  NULL                     /* Choice Request is generic           */
	};
      size_t nMethods = (sizeof(Generic_Methods)/sizeof(Generic_Methods[0]));
      size_t method   = ((BI->keycode & ID_Mask) >> ID_Shft) & 0xffff;
      
      if ( (method >= nMethods) || !(BI->cmd) )
d4186 1
d4188 1
a4188 1
	    res = fct(BI->cmd,form);
d4190 1
a4190 1
	    res = (BI->cmd)(form);
d4192 3
a4194 2
    } 
  else 
d4196 89
a4284 3
      if (!(c & (~(int)MAX_REGULAR_CHARACTER)) &&
	  isprint((unsigned char)c) &&                      
	  Check_Char(form->current->type,c,
d4286 2
a4287 1
	res = Data_Entry(form,c);
d4292 1
a4292 1

d4295 1
a4295 1
  The effects of setting a buffer is tightly coupled to the core of the form
d4297 1
a4297 1
  So I don't separate this into an own module. 
d4301 1
a4301 1
|   Facility      :  libnform  
d4304 1
a4304 1
|   
d4311 1
a4311 1
|                    minated. It is copied up to the length of the buffer.   
d4318 1
a4318 2
set_field_buffer
(FIELD * field, int buffer, const char * value)
d4320 1
a4320 1
  char *s, *p;
d4322 1
d4325 3
a4327 2
  if ( !field || !value || ((buffer < 0)||(buffer > field->nbuf)) )
    RETURN(E_BAD_ARGUMENT);
d4329 1
a4329 1
  len  = Buffer_Length(field);
d4331 2
a4332 4
  if (buffer==0)
    {
      const char *v;
      unsigned int i = 0;
d4334 1
a4334 6
      for(v=value; *v && (i<len); v++,i++)
	{
	  if (!isprint((unsigned char)*v))
	    RETURN(E_BAD_ARGUMENT);
	}
    }
d4339 2
a4340 2
	 somehow we have to detect the length of what should be copied.
      */
d4342 1
d4346 2
a4347 1
			   (int)(1 + (vlen-len)/((field->rows+field->nrow)*field->cols))))
a4349 10
	  /* in this case we also have to check, wether or not the remaining
	     characters in value are also printable for buffer 0. */
	  if (buffer==0)
	    {
	      unsigned int i;
	  
	      for(i=len; i<vlen; i++)
		if (!isprint((unsigned char)value[i]))
		  RETURN(E_BAD_ARGUMENT);
	    }
a4352 2
  
  p   = Address_Of_Nth_Buffer(field,buffer);
d4354 42
a4395 2
#if HAVE_MEMCCPY
  s = memccpy(p,value,0,len);
d4397 1
a4397 3
  for(s=(char *)value; *s && (s < (value+len)); s++)
    p[s-value] = *s;
  if (s < (value+len))
d4399 7
a4405 2
      p[s-value] = *s++;
      s = p + (s-value);
a4406 2
  else 
    s=(char *)0;
d4409 1
a4409 11
  if (s) 
    { /* this means, value was null terminated and not greater than the
	 buffer. We have to pad with blanks. Please note that due to memccpy
	 logic s points after the terminating null. */
      s--; /* now we point to the terminator. */
      assert(len >= (unsigned int)(s-p));
      if (len > (unsigned int)(s-p))
	memset(s,C_BLANK,len-(unsigned int)(s-p));
    }

  if (buffer==0)
d4412 3
a4414 2
      if (((syncres=Synchronize_Field( field ))!=E_OK) && 
	  (res==E_OK))
d4416 2
a4417 2
      if (((syncres=Synchronize_Linked_Fields(field ))!=E_OK) &&
	  (res==E_OK))
d4421 1
a4421 1
}		
d4424 1
a4424 1
|   Facility      :  libnform  
d4426 1
a4426 1
|   
d4432 1
a4432 1
field_buffer (const FIELD * field, int  buffer)
d4434 4
d4439 134
a4572 3
    return Address_Of_Nth_Buffer(field,buffer);
  else
    return (char *)0;
d4574 1
@


1.7
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: frm_driver.c,v 1.6 1999/05/17 03:04:16 millert Exp $	*/
d2054 1
a2054 1
|                                        was successfull
@


1.6
log
@ncurses-4.2-990516; no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: frm_driver.c,v 1.5 1998/07/24 02:37:29 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d36 1
a36 1
MODULE_ID("$From: frm_driver.c,v 1.35 1999/05/16 17:20:52 juergen Exp $")
d563 2
a564 2
int
_nc_Position_Form_Cursor(FORM * form)
d604 2
a605 2
int
_nc_Refresh_Current_Field(FORM * form)
d962 2
a963 1
int _nc_Synchronize_Attributes(FIELD * field)
d1021 3
a1023 2
int
_nc_Synchronize_Options(FIELD *field, Field_Options newopts)
d1120 3
a1122 2
int
_nc_Set_Current_Field(FORM  *form, FIELD *newfield)
d2694 2
a2695 2
bool
_nc_Internal_Validation(FORM *form)
d2784 2
a2785 2
FIELD*
_nc_First_Active_Field(FORM * form)
d3291 3
a3293 2
int
_nc_Set_Form_Page(FORM * form, int page, FIELD * field)
d3646 2
a3647 1
int form_driver(FORM * form, int  c)
d3746 3
a3748 1
int set_field_buffer(FIELD * field, int buffer, const char * value)
d3790 1
a3790 1
		if (!isprint(value[i]))
d3844 2
a3845 1
char *field_buffer(const FIELD * field, int  buffer)
@


1.5
log
@libform from ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
 *   Author: Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de> 1995,1997        *
d36 1
a36 1
MODULE_ID("$From: frm_driver.c,v 1.33 1998/05/10 00:16:18 tom Exp $")
@


1.4
log
@Merge of ncurses-4.1-971129
@
text
@d3 31
a33 21
/*-----------------------------------------------------------------------------+
|           The ncurses form library is  Copyright (C) 1995-1997               |
|             by Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de>                 |
|                          All Rights Reserved.                                |
|                                                                              |
| Permission to use, copy, modify, and distribute this software and its        |
| documentation for any purpose and without fee is hereby granted, provided    |
| that the above copyright notice appear in all copies and that both that      |
| copyright notice and this permission notice appear in supporting             |
| documentation, and that the name of the above listed copyright holder(s) not |
| be used in advertising or publicity pertaining to distribution of the        |
| software without specific, written prior permission.                         | 
|                                                                              |
| THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD TO  |
| THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FIT-  |
| NESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR   |
| ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RE- |
| SULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, |
| NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH    |
| THE USE OR PERFORMANCE OF THIS SOFTWARE.                                     |
+-----------------------------------------------------------------------------*/
d36 1
a36 1
MODULE_ID("Id: frm_driver.c,v 1.28 1997/10/21 13:24:19 juergen Exp $")
d179 2
a180 4
{\
   wbkgdset((win),(chtype)((field)->pad | (field)->back)); \
   wattrset((win),(field)->fore); \
}
d833 1
d838 2
a839 1
  win =  derwin(Get_Form_Window(field->form),
d846 4
a849 1
      Set_Field_Window_Attributes(field,win);
@


1.3
log
@libform from ncurses 4.1.  Post 4.1 patches to be applied in a separate commit.
@
text
@d1 2
d24 3
a70 4
#include "form.priv.h"

MODULE_ID("Id: frm_driver.c,v 1.20 1997/05/01 16:47:54 juergen Exp $")

d89 2
a185 7
/* This are the field options required to be a selectable field in field
   navigation requests */
#define O_SELECTABLE (O_ACTIVE | O_VISIBLE)

/* Logic to determine whether or not a field is selectable */
#define Field_Is_Selectable(f)     (((f)->opts & O_SELECTABLE)==O_SELECTABLE)
#define Field_Is_Not_Selectable(f) (((f)->opts & O_SELECTABLE)!=O_SELECTABLE)
d544 1
a544 1
|   Function      :  static int Position_Form_Cursor(FORM * form)
d546 1
a546 1
|   Description   :  Position the currsor in the window for the current
d555 2
a556 1
static int Position_Form_Cursor(FORM * form)
d587 1
a587 1
|   Function      :  static int Refresh_Current_Field(FORM * form)
d596 2
a597 1
static int Refresh_Current_Field(FORM * form)
d704 1
a704 1
  return Position_Form_Cursor(form);
d806 1
a806 1
  return isprint((unsigned char)ch);
d893 1
a893 1
	  res = Refresh_Current_Field( form );
d939 1
a939 1
|   Function      :  static int Synchronize_Attributes(FIELD * field)
d949 1
a949 1
static int Synchronize_Attributes(FIELD * field)
d983 1
a983 1
	      Refresh_Current_Field(form);
d996 2
a997 2
|   Function      :  static int Synchronize_Options(FIELD * field,
|                                                   Field_Options newopts)
d1007 2
a1008 1
static int Synchronize_Options(FIELD *field, Field_Options newopts)
d1038 2
a1040 2
		  else
		    res = Display_Field(field);
d1096 2
a1097 3
|   Function      :  static int Set_Current_Field(
|                                                 FORM  * form,
|                                                 FIELD * newfield)
d1105 2
a1106 1
static int Set_Current_Field(FORM  *form, FIELD *newfield)
d1129 1
a1129 1
	  Refresh_Current_Field(form);
d1200 1
a1200 1
|                    field this wraps and the end of the line.
d1213 6
d1220 4
d1273 4
d1516 5
d1563 4
d2050 1
a2050 1
      (There_Is_No_Room_For_A_Char_In_Line(form)) &&  /* line id full        */
d2085 2
d2671 1
a2671 1
|   Function      :  static bool Internal_Validation(FORM * form )
d2678 2
a2679 1
static bool Internal_Validation(FORM *form)
d2716 1
a2716 1
  if (Internal_Validation(form))
d2759 1
a2759 1
|   Function      :  static FIELD * First_Active_Field(FORM * form)
d2768 2
a2769 1
static FIELD * First_Active_Field(FORM * form)
d3048 1
a3048 1
  if (!Internal_Validation(form)) 
d3070 2
a3071 2
  return Set_Current_Field(form,
			   Next_Field_On_Page(form->current));
d3086 2
a3087 2
  return Set_Current_Field(form,
			   Previous_Field_On_Page(form->current));
d3101 2
a3102 3
  return 
    Set_Current_Field(form,
       Next_Field_On_Page(form->field[form->page[form->curpage].pmax]));
d3117 1
a3117 1
    Set_Current_Field(form,
d3133 2
a3134 2
  return Set_Current_Field(form,
			   Sorted_Next_Field(form->current));
d3149 2
a3150 2
  return Set_Current_Field(form,
			   Sorted_Previous_Field(form->current));
d3165 2
a3166 2
  return Set_Current_Field(form,
	    Sorted_Next_Field(form->field[form->page[form->curpage].smax]));
d3181 1
a3181 1
  return Set_Current_Field(form,
d3197 2
a3198 2
  return Set_Current_Field(form,
			   Left_Neighbour_Field(form->current));
d3213 2
a3214 2
  return Set_Current_Field(form,
			   Right_Neighbour_Field(form->current));
d3231 2
a3232 2
  return Set_Current_Field(form,
			   Upper_Neighbour_Field(form->current));
d3249 2
a3250 2
  return Set_Current_Field(form,
			   Down_Neighbour_Field(form->current));
d3262 3
a3264 3
|   Function      :  static int Set_Form_Page(FORM * form,
|                                             int page,
|                                             FIELD * field)
d3275 2
a3276 1
static int Set_Form_Page(FORM * form, int page, FIELD * field)
d3296 1
a3296 1
	res = Set_Current_Field(form,field);
d3361 1
a3361 1
  if (!Internal_Validation(form)) 
d3385 1
a3385 1
  return Set_Form_Page(form,Next_Page_Number(form),(FIELD *)0);
d3399 1
a3399 1
  return Set_Form_Page(form,Previous_Page_Number(form),(FIELD *)0);
d3413 1
a3413 1
  return Set_Form_Page(form,0,(FIELD *)0);
d3427 1
a3427 1
  return Set_Form_Page(form,form->maxpage-1,(FIELD *)0);
a3451 1
  bool End_Of_Field;
d3485 2
a3487 2
	  End_Of_Field= (((field->drows-1)==form->currow) &&
			 ((field->dcols-1)==form->curcol));
d3644 1
a3644 1
      form->current = First_Active_Field(form);
d3678 2
a3679 2
      int nMethods = (sizeof(Generic_Methods)/sizeof(Generic_Methods[0]));
      int method   = ((BI->keycode & ID_Mask) >> ID_Shft) & 0xffff;
d3681 1
a3681 1
      if ( (method < 0) || (method >= nMethods) || !(BI->cmd) )
d3700 1
a3700 1
  Refresh_Current_Field(form);
a3703 262
/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int post_form(FORM * form)
|   
|   Description   :  Writes the form into its associated subwindow.
|
|   Return Values :  E_OK              - success
|                    E_BAD_ARGUMENT    - invalid form pointer
|                    E_POSTED          - form already posted
|                    E_NOT_CONNECTED   - no fields connected to form
|                    E_NO_ROOM         - form doesn't fit into subwindow
|                    E_SYSTEM_ERROR    - system error
+--------------------------------------------------------------------------*/
int post_form(FORM * form)
{
  WINDOW *formwin;
  int err;
  int page;

  if (!form)
    RETURN(E_BAD_ARGUMENT);

  if (form->status & _POSTED)   
    RETURN(E_POSTED);

  if (!(form->field))
    RETURN(E_NOT_CONNECTED);
  
  formwin = Get_Form_Window(form);
  if ((form->cols > getmaxx(formwin)) || (form->rows > getmaxy(formwin))) 
    RETURN(E_NO_ROOM);

  /* reset form->curpage to an invald value. This forces Set_Form_Page
     to do the page initialization which is required by post_form.
  */
  page = form->curpage;
  form->curpage = -1;
  if ((err = Set_Form_Page(form,page,form->current))!=E_OK)
    RETURN(err);

  form->status |= _POSTED;

  Call_Hook(form,forminit);
  Call_Hook(form,fieldinit);

  Refresh_Current_Field(form);
  RETURN(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int unpost_form(FORM * form)
|   
|   Description   :  Erase form from its associated subwindow.
|
|   Return Values :  E_OK            - success
|                    E_BAD_ARGUMENT  - invalid form pointer
|                    E_NOT_POSTED    - form isn't posted
|                    E_BAD_STATE     - called from a hook routine
+--------------------------------------------------------------------------*/
int unpost_form(FORM * form)
{
  if (!form)
    RETURN(E_BAD_ARGUMENT);

  if (!(form->status & _POSTED)) 
    RETURN(E_NOT_POSTED);

  if (form->status & _IN_DRIVER) 
    RETURN(E_BAD_STATE);

  Call_Hook(form,fieldterm);
  Call_Hook(form,formterm);

  werase(Get_Form_Window(form));
  delwin(form->w);
  form->w = (WINDOW *)0;
  form->status &= ~_POSTED;
  RETURN(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int pos_form_cursor(FORM * form)
|   
|   Description   :  Moves the form window cursor to the location required
|                    by the form driver to resume form processing. This may
|                    be needed after the application calls a curses library
|                    I/O routine that modifies the cursor position.
|
|   Return Values :  E_OK                      - Success
|                    E_SYSTEM_ERROR            - System error.
|                    E_BAD_ARGUMENT            - Invalid form pointer
|                    E_NOT_POSTED              - Form is not posted
+--------------------------------------------------------------------------*/
int pos_form_cursor(FORM * form)
{
  int res;

  if (!form)
   res = E_BAD_ARGUMENT;
  else
    {
      if (!(form->status & _POSTED))
        res = E_NOT_POSTED;
      else
	res = Position_Form_Cursor(form);
    }
  RETURN(res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int set_current_field(FORM  * form,FIELD * field)
|   
|   Description   :  Set the current field of the form to the specified one.
|
|   Return Values :  E_OK              - success
|                    E_BAD_ARGUMENT    - invalid form or field pointer
|                    E_REQUEST_DENIED  - field not selectable
|                    E_BAD_STATE       - called from a hook routine
|                    E_INVALID_FIELD   - current field can't be left
|                    E_SYSTEM_ERROR    - system error
+--------------------------------------------------------------------------*/
int set_current_field(FORM  * form, FIELD * field)
{
  int err = E_OK;

  if ( !form || !field )
    RETURN(E_BAD_ARGUMENT);

  if ( (form != field->form) || Field_Is_Not_Selectable(field) )
    RETURN(E_REQUEST_DENIED);

  if (!(form->status & _POSTED))
    {
      form->current = field;
      form->curpage = field->page;
  }
  else
    {
      if (form->status & _IN_DRIVER) 
	err = E_BAD_STATE;
      else
	{
	  if (form->current != field)
	    {
	      if (!Internal_Validation(form)) 
	       err = E_INVALID_FIELD;
	      else
		{
		  Call_Hook(form,fieldterm);
		  if (field->page != form->curpage)
		    {
		      Call_Hook(form,formterm);
		      err = Set_Form_Page(form,field->page,field);
		      Call_Hook(form,forminit);
		    } 
		  else 
		    {
		      err = Set_Current_Field(form,field);
		    }
		  Call_Hook(form,fieldinit);
		  Refresh_Current_Field(form);
		}
	    }
	}
    }
  RETURN(err);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  FIELD *current_field(const FORM * form)
|   
|   Description   :  Return the current field.
|
|   Return Values :  Pointer to the current field.
+--------------------------------------------------------------------------*/
FIELD *current_field(const FORM * form)
{
  return Normalize_Form(form)->current;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int field_index(const FIELD * field)
|   
|   Description   :  Return the index of the field in the field-array of
|                    the form.
|
|   Return Values :  >= 0   : field index
|                    -1     : fieldpointer invalid or field not connected
+--------------------------------------------------------------------------*/
int field_index(const FIELD * field)
{
  return ( (field && field->form) ? field->index : -1 );
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int set_form_page(FORM * form,int  page)
|   
|   Description   :  Set the page number of the form.
|
|   Return Values :  E_OK              - success
|                    E_BAD_ARGUMENT    - invalid form pointer or page number
|                    E_BAD_STATE       - called from a hook routine
|                    E_INVALID_FIELD   - current field can't be left
|                    E_SYSTEM_ERROR    - system error
+--------------------------------------------------------------------------*/
int set_form_page(FORM * form, int page)
{
  int err = E_OK;

  if ( !form || (page<0) || (page>=form->maxpage) )
    RETURN(E_BAD_ARGUMENT);

  if (!(form->status & _POSTED))
    {
      form->curpage = page;
      form->current = First_Active_Field(form);
  }
  else
    {
      if (form->status & _IN_DRIVER) 
	err = E_BAD_STATE;
      else
	{
	  if (form->curpage != page)
	    {
	      if (!Internal_Validation(form)) 
		err = E_INVALID_FIELD;
	      else
		{
		  Call_Hook(form,fieldterm);
		  Call_Hook(form,formterm);
		  err = Set_Form_Page(form,page,(FIELD *)0);
		  Call_Hook(form,forminit);
		  Call_Hook(form,fieldinit);
		  Refresh_Current_Field(form);
		}
	    }
	}
    }
  RETURN(err);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int form_page(const FORM * form)
|   
|   Description   :  Return the current page of the form.
|
|   Return Values :  >= 0  : current page number
|                    -1    : invalid form pointer
+--------------------------------------------------------------------------*/
int form_page(const FORM * form)
{
  return Normalize_Form(form)->curpage;
}

d3705 4
a3708 1
  Field-Buffer manipulation routines
d3785 4
a3788 1
    p[s-value] = *s++; 
d3795 3
a3797 1
	 buffer. We have to pad with blanks */
a3829 246
}

/*----------------------------------------------------------------------------
  Field-Options manipulation routines
  --------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int set_field_opts(FIELD *field, Field_Options opts)
|   
|   Description   :  Turns on the named options for this field and turns
|                    off all the remaining options.
|
|   Return Values :  E_OK            - success
|                    E_CURRENT       - the field is the current field
|                    E_BAD_ARGUMENT  - invalid options
|                    E_SYSTEM_ERROR  - system error
+--------------------------------------------------------------------------*/
int set_field_opts(FIELD * field, Field_Options opts)
{
  int res = E_BAD_ARGUMENT;
  if (!(opts & ~ALL_FIELD_OPTS))
    res = Synchronize_Options( Normalize_Field(field), opts );
  RETURN(res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  Field_Options field_opts(const FIELD *field)
|   
|   Description   :  Retrieve the fields options.
|
|   Return Values :  The options.
+--------------------------------------------------------------------------*/
Field_Options field_opts(const FIELD * field)
{
  return ALL_FIELD_OPTS & Normalize_Field( field )->opts;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int field_opts_on(FIELD *field, Field_Options opts)
|   
|   Description   :  Turns on the named options for this field and all the 
|                    remaining options are unchanged.
|
|   Return Values :  E_OK            - success
|                    E_CURRENT       - the field is the current field
|                    E_BAD_ARGUMENT  - invalid options
|                    E_SYSTEM_ERROR  - system error
+--------------------------------------------------------------------------*/
int field_opts_on(FIELD * field, Field_Options opts)
{
  int res = E_BAD_ARGUMENT;

  if (!(opts & ~ALL_FIELD_OPTS))
    {
      Normalize_Field( field );
      res = Synchronize_Options( field, field->opts | opts );
    }
  RETURN(res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int field_opts_off(FIELD *field, Field_Options opts)
|   
|   Description   :  Turns off the named options for this field and all the 
|                    remaining options are unchanged.
|
|   Return Values :  E_OK            - success
|                    E_CURRENT       - the field is the current field
|                    E_BAD_ARGUMENT  - invalid options
|                    E_SYSTEM_ERROR  - system error
+--------------------------------------------------------------------------*/
int field_opts_off(FIELD  * field, Field_Options opts)
{
  int res = E_BAD_ARGUMENT;

  if (!(opts & ~ALL_FIELD_OPTS))
    {
      Normalize_Field( field );
      res = Synchronize_Options( field, field->opts & ~opts );
    }
  RETURN(res);
}	

/*----------------------------------------------------------------------------
  Field-Attribute manipulation routines
  --------------------------------------------------------------------------*/
/* "Template" macro to generate a function to set a fields attribute */
#define GEN_FIELD_ATTR_SET_FCT( name ) \
int set_field_ ## name (FIELD * field, chtype attr)\
{\
   int res = E_BAD_ARGUMENT;\
   if ( attr==A_NORMAL || ((attr & A_ATTRIBUTES)==attr) )\
     {\
       Normalize_Field( field );\
       if ((field -> name) != attr)\
         {\
           field -> name = attr;\
           res = Synchronize_Attributes( field );\
         }\
       else\
	 res = E_OK;\
     }\
   RETURN(res);\
}

/* "Template" macro to generate a function to get a fields attribute */
#define GEN_FIELD_ATTR_GET_FCT( name ) \
chtype field_ ## name (const FIELD * field)\
{\
   return ( A_ATTRIBUTES & (Normalize_Field( field ) -> name) );\
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int set_field_fore(FIELD *field, chtype attr)
|   
|   Description   :  Sets the foreground of the field used to display the
|                    field contents.
|
|   Return Values :  E_OK             - success
|                    E_BAD_ARGUMENT   - invalid attributes
|                    E_SYSTEM_ERROR   - system error
+--------------------------------------------------------------------------*/
GEN_FIELD_ATTR_SET_FCT( fore )

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  chtype field_fore(const FIELD *)
|   
|   Description   :  Retrieve fields foreground attribute
|
|   Return Values :  The foreground attribute
+--------------------------------------------------------------------------*/
GEN_FIELD_ATTR_GET_FCT( fore )

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int set_field_back(FIELD *field, chtype attr)
|   
|   Description   :  Sets the background of the field used to display the
|                    fields extend.
|
|   Return Values :  E_OK             - success
|                    E_BAD_ARGUMENT   - invalid attributes
|                    E_SYSTEM_ERROR   - system error
+--------------------------------------------------------------------------*/
GEN_FIELD_ATTR_SET_FCT( back )

/*---------------------------------------------------------------------------
|   Facility      :  libnform
|   Function      :  chtype field_back(const 
|   
|   Description   :  Retrieve fields background attribute
|
|   Return Values :  The background attribute
+--------------------------------------------------------------------------*/
GEN_FIELD_ATTR_GET_FCT( back )

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int set_field_pad(FIELD *field, int ch)
|   
|   Description   :  Set the pad character used to fill the field. This must
|                    be a printable character.
|
|   Return Values :  E_OK           - success
|                    E_BAD_ARGUMENT - invalid field pointer or pad character
|                    E_SYSTEM_ERROR - system error
+--------------------------------------------------------------------------*/
int set_field_pad(FIELD  * field, int ch)
{
  int res = E_BAD_ARGUMENT;

  Normalize_Field( field );
  if (isprint((unsigned char)ch))
    {
      if (field->pad != ch)
	{
	  field->pad = ch;
	  res = Synchronize_Attributes( field );
	}
      else
	res = E_OK;
    }
  RETURN(res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int field_pad(const FIELD *field)
|   
|   Description   :  Retrieve the fields pad character.
|
|   Return Values :  The pad character.
+--------------------------------------------------------------------------*/
int field_pad(const FIELD * field)
{
  return Normalize_Field( field )->pad;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int set_field_just(FIELD *field, int just)
|   
|   Description   :  Set the fields type of justification.
|
|   Return Values :  E_OK            - success
|                    E_BAD_ARGUMENT  - one of the arguments was incorrect
|                    E_SYSTEM_ERROR  - system error
+--------------------------------------------------------------------------*/
int set_field_just(FIELD * field, int just)
{
  int res = E_BAD_ARGUMENT;

  if ((just==NO_JUSTIFICATION)  ||
      (just==JUSTIFY_LEFT)	||
      (just==JUSTIFY_CENTER)	||
      (just==JUSTIFY_RIGHT)	)
    {
      Normalize_Field( field );
      if (field->just != just)
	{
	  field->just = just;
	  res = Synchronize_Attributes( field );
	}
      else
	res = E_OK;
    }
  RETURN(res);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnform  
|   Function      :  int field_just( const FIELD *field )
|   
|   Description   :  Retrieve the fields type of justification
|
|   Return Values :  The justification type.
+--------------------------------------------------------------------------*/
int field_just(const FIELD * field)
{
  return Normalize_Field( field )->just;
@


1.2
log
@Hack for a display bug in libform.
@
text
@d1 21
a21 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d68 2
d86 2
a432 1
      FORM *form;
d441 19
a459 1
      if ( (form = field->form) )
d461 26
a486 6
	  bool need_visual_update = (form->status & _POSTED) &&
	                            (form->current==field);
	  int growth;

	  if (need_visual_update)
	    Synchronize_Buffer(form);
d488 2
a489 1
	  if (single_line_field)
d491 7
a497 6
	      growth = field->cols * amount;
	      if (field->maxgrow)
		growth = Minimum(field->maxgrow - field->dcols,growth);
	      field->dcols += growth;
	      if (field->dcols == field->maxgrow)
		field->status &= ~_MAY_GROW;
d499 25
a523 20
	  else
	    {
	      growth = (field->rows + field->nrow) * amount;
	      if (field->maxgrow)
		growth = Minimum(field->maxgrow - field->drows,growth);
	      field->drows += growth;
	      if (field->drows == field->maxgrow)
		field->status &= ~_MAY_GROW;
	    }
	  /* drows, dcols changed, so we get really the new buffer length */
	  new_buflen = Buffer_Length(field);
	  newbuf=(char *)malloc((size_t)Total_Buffer_Size(field));
	  if (!newbuf)
	    { /* restore to previous state */
	      field->dcols = old_dcols;
	      field->drows = old_drows;
	      if (( single_line_field && (field->dcols!=field->maxgrow)) ||
		  (!single_line_field && (field->drows!=field->maxgrow)))
		field->status |= _MAY_GROW;
	      return FALSE;
a524 7
	  else
	    { /* Copy all the buffers. This is the reason why we can't
	         just use realloc().
	       */
	      int i;
	      char *old_bp;
	      char *new_bp;
d526 8
a533 38
	      field->buf = newbuf;
	      for(i=0;i<=field->nbuf;i++)
		{
		  new_bp = Address_Of_Nth_Buffer(field,i);
		  old_bp = oldbuf + i*(1+old_buflen);
		  memcpy(new_bp,old_bp,(size_t)old_buflen);
		  if (new_buflen > old_buflen)
		    memset(new_bp + old_buflen,C_BLANK,
			   (size_t)(new_buflen - old_buflen));
		  *(new_bp + new_buflen + 1) = '\0';
		}
	      if (need_visual_update)
		{ 
		  WINDOW *new_window = newpad(field->drows,field->dcols);
		  if (!new_window)
		    { /* restore old state */
		      field->dcols = old_dcols;
		      field->drows = old_drows;
		      field->buf   = oldbuf;
		      if (( single_line_field              && 
			   (field->dcols!=field->maxgrow)) ||
			  (!single_line_field              && 
			   (field->drows!=field->maxgrow)))
			field->status |= _MAY_GROW;
		      free( newbuf );
		      return FALSE;
		    }
		  delwin(form->w);
		  form->w = new_window;
		  Set_Field_Window_Attributes(field,form->w);
		  werase(form->w);
		  Buffer_To_Window(field,form->w);
		  untouchwin(form->w);
		  wmove(form->w,form->currow,form->curcol);
		}
	      free(oldbuf);
	      /* reflect changes in linked fields */
	      if (field != field->link)
d535 3
a537 9
		  FIELD *linked_field;
		  for(linked_field = field->link;
		      linked_field!= field;
		      linked_field = linked_field->link)
		    {
		      linked_field->buf   = field->buf;
		      linked_field->drows = field->drows;
		      linked_field->dcols = field->dcols;
		    }
a538 1
	      result = TRUE;
d540 2
a541 1
	}
a704 1
  wrefresh(form->w);	/* Will this catch them all? --Toby. */
d881 2
a882 2
  if ((form=field->form) &&
      Field_Really_Appears(field))
d960 2
a961 2
  if ((form=field->form) &&
      Field_Really_Appears(field))
d1167 1
d2112 1
a2112 3
      if ((fct==FE_New_Line)                   && 
	  (form->opts & O_NL_OVERLOAD)         &&
	  First_Position_In_Current_Field(form) )
d2114 8
a2121 1
	  res = Inter_Field_Navigation(FN_Next_Field,form);
d2182 1
d2212 1
d3428 5
a3432 1
  if (field->opts & O_EDIT)
d3434 4
a3437 5
      if ( (form->currow==0) && 
	   (form->curcol==0) && 
	   (field->opts & O_BLANK) &&
	  !(form->status & _FCHECK_REQUIRED) && 
	  !(form->status & _WINDOW_MODIFIED) )
d3955 2
a3966 1
  unsigned int vlen;
d3971 2
d3976 1
d3978 1
a3978 1
      for(v=value;*v;v++)
d3985 1
a3985 3
  len  = Buffer_Length(field);
  vlen = strlen(value);
  if ((vlen>len) && Growable(field))
d3987 22
a4008 3
      if (!Field_Grown(field,
	      (int)(1 + (vlen-len)/((field->rows+field->nrow)*field->cols))))
	RETURN(E_SYSTEM_ERROR);
d4010 1
a4010 1

d4016 6
a4021 2
  for(s=(char *)value;*s && (s<value+len);s++) p[s-value]=*s;
  if (s<value+len) p[s-value]=*s++; else s=0;
d4025 2
a4026 1
    {
d4028 2
a4029 1
      memset(s,C_BLANK,len-(unsigned int)(s-p));
@


1.1
log
@Initial revision
@
text
@d699 1
@


1.1.1.1
log
@SYSV-style form library; from ncurses
@
text
@@
