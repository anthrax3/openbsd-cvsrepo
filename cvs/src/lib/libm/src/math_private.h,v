head	1.18;
access;
symbols
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.10
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.6
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.8
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.10
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.11.0.10
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.22
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.20
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.18
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.16
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.14
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.12
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.10
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.8
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.09.12.19.47.02;	author guenther;	state Exp;
branches;
next	1.17;
commitid	Lp8bnB2xK76nGFvJ;

1.17
date	2014.06.02.19.31.17;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	ffsv4DTUV3egJk01;

1.16
date	2013.11.12.20.35.09;	author martynas;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.26.11.43.01;	author martynas;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.26.09.24.52;	author martynas;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.06.00.02.42;	author martynas;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.04.15.00.56;	author martynas;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.09.20.00.35;	author martynas;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.07.20.36.09;	author martynas;	state Exp;
branches;
next	1.9;

1.9
date	2008.07.24.09.40.16;	author martynas;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.11.20.53.27;	author martynas;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.01.05.50.56;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.02.00.29.50;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	96.11.14.14.21.51;	author etheisen;	state Exp;
branches;
next	1.3;

1.3
date	96.05.24.10.57.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.28.00.57.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.56;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Reduce libm's exports and make internal calls go direct.
All dependencies on libc are now via reserved/standardized names.

ok kettenis@@ millert@@ deraadt@@
@
text
@/*	$OpenBSD: math_private.h,v 1.17 2014/06/02 19:31:17 kettenis Exp $	*/
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/*
 * from: @@(#)fdlibm.h 5.1 93/09/24
 */

#ifndef _MATH_PRIVATE_H_
#define _MATH_PRIVATE_H_

#include <sys/types.h>

/* The original fdlibm code used statements like:
	n0 = ((*(int*)&one)>>29)^1;		* index of high word *
	ix0 = *(n0+(int*)&x);			* high word of x *
	ix1 = *((1-n0)+(int*)&x);		* low word of x *
   to dig two 32 bit words out of the 64 bit IEEE floating point
   value.  That is non-ANSI, and, moreover, the gcc instruction
   scheduler gets it wrong.  We instead use the following macros.
   Unlike the original code, we determine the endianness at compile
   time, not at run time; I don't see much benefit to selecting
   endianness at run time.  */

/* A union which permits us to convert between a long double and
   four 32 bit ints.  */

#if BYTE_ORDER == BIG_ENDIAN

typedef union
{
  long double value;
  struct {
    u_int32_t mswhi;
    u_int32_t mswlo;
    u_int32_t lswhi;
    u_int32_t lswlo;
  } parts32;
  struct {
    u_int64_t msw;
    u_int64_t lsw;
  } parts64;
} ieee_quad_shape_type;

#endif

#if BYTE_ORDER == LITTLE_ENDIAN

typedef union
{
  long double value;
  struct {
    u_int32_t lswlo;
    u_int32_t lswhi;
    u_int32_t mswlo;
    u_int32_t mswhi;
  } parts32;
  struct {
    u_int64_t lsw;
    u_int64_t msw;
  } parts64;
} ieee_quad_shape_type;

#endif

/* Get two 64 bit ints from a long double.  */

#define GET_LDOUBLE_WORDS64(ix0,ix1,d)				\
do {								\
  ieee_quad_shape_type qw_u;					\
  qw_u.value = (d);						\
  (ix0) = qw_u.parts64.msw;					\
  (ix1) = qw_u.parts64.lsw;					\
} while (0)

/* Set a long double from two 64 bit ints.  */

#define SET_LDOUBLE_WORDS64(d,ix0,ix1)				\
do {								\
  ieee_quad_shape_type qw_u;					\
  qw_u.parts64.msw = (ix0);					\
  qw_u.parts64.lsw = (ix1);					\
  (d) = qw_u.value;						\
} while (0)

/* Get the more significant 64 bits of a long double mantissa.  */

#define GET_LDOUBLE_MSW64(v,d)					\
do {								\
  ieee_quad_shape_type sh_u;					\
  sh_u.value = (d);						\
  (v) = sh_u.parts64.msw;					\
} while (0)

/* Set the more significant 64 bits of a long double mantissa from an int.  */

#define SET_LDOUBLE_MSW64(d,v)					\
do {								\
  ieee_quad_shape_type sh_u;					\
  sh_u.value = (d);						\
  sh_u.parts64.msw = (v);					\
  (d) = sh_u.value;						\
} while (0)

/* Get the least significant 64 bits of a long double mantissa.  */

#define GET_LDOUBLE_LSW64(v,d)					\
do {								\
  ieee_quad_shape_type sh_u;					\
  sh_u.value = (d);						\
  (v) = sh_u.parts64.lsw;					\
} while (0)

/* A union which permits us to convert between a long double and
   three 32 bit ints.  */

#if BYTE_ORDER == BIG_ENDIAN

typedef union
{
  long double value;
  struct {
#ifdef __LP64__
    int padh:32;
#endif
    int exp:16;
    int padl:16;
    u_int32_t msw;
    u_int32_t lsw;
  } parts;
} ieee_extended_shape_type;

#endif

#if BYTE_ORDER == LITTLE_ENDIAN

typedef union
{
  long double value;
  struct {
    u_int32_t lsw;
    u_int32_t msw;
    int exp:16;
    int padl:16;
#ifdef __LP64__
    int padh:32;
#endif
  } parts;
} ieee_extended_shape_type;

#endif

/* Get three 32 bit ints from a double.  */

#define GET_LDOUBLE_WORDS(se,ix0,ix1,d)				\
do {								\
  ieee_extended_shape_type ew_u;				\
  ew_u.value = (d);						\
  (se) = ew_u.parts.exp;					\
  (ix0) = ew_u.parts.msw;					\
  (ix1) = ew_u.parts.lsw;					\
} while (0)

/* Set a double from two 32 bit ints.  */

#define SET_LDOUBLE_WORDS(d,se,ix0,ix1)				\
do {								\
  ieee_extended_shape_type iw_u;				\
  iw_u.parts.exp = (se);					\
  iw_u.parts.msw = (ix0);					\
  iw_u.parts.lsw = (ix1);					\
  (d) = iw_u.value;						\
} while (0)

/* Get the more significant 32 bits of a long double mantissa.  */

#define GET_LDOUBLE_MSW(v,d)					\
do {								\
  ieee_extended_shape_type sh_u;				\
  sh_u.value = (d);						\
  (v) = sh_u.parts.msw;						\
} while (0)

/* Set the more significant 32 bits of a long double mantissa from an int.  */

#define SET_LDOUBLE_MSW(d,v)					\
do {								\
  ieee_extended_shape_type sh_u;				\
  sh_u.value = (d);						\
  sh_u.parts.msw = (v);						\
  (d) = sh_u.value;						\
} while (0)

/* Get int from the exponent of a long double.  */

#define GET_LDOUBLE_EXP(se,d)					\
do {								\
  ieee_extended_shape_type ge_u;				\
  ge_u.value = (d);						\
  (se) = ge_u.parts.exp;					\
} while (0)

/* Set exponent of a long double from an int.  */

#define SET_LDOUBLE_EXP(d,se)					\
do {								\
  ieee_extended_shape_type se_u;				\
  se_u.value = (d);						\
  se_u.parts.exp = (se);					\
  (d) = se_u.value;						\
} while (0)

/* A union which permits us to convert between a double and two 32 bit
   ints.  */

/*
 * The arm port is little endian except for the FP word order which is
 * big endian.
 */

#if (BYTE_ORDER == BIG_ENDIAN) || (defined(__arm__) && !defined(__VFP_FP__))

typedef union
{
  double value;
  struct
  {
    u_int32_t msw;
    u_int32_t lsw;
  } parts;
} ieee_double_shape_type;

#endif

#if (BYTE_ORDER == LITTLE_ENDIAN) && !(defined(__arm__) && !defined(__VFP_FP__))

typedef union
{
  double value;
  struct
  {
    u_int32_t lsw;
    u_int32_t msw;
  } parts;
} ieee_double_shape_type;

#endif

/* Get two 32 bit ints from a double.  */

#define EXTRACT_WORDS(ix0,ix1,d)				\
do {								\
  ieee_double_shape_type ew_u;					\
  ew_u.value = (d);						\
  (ix0) = ew_u.parts.msw;					\
  (ix1) = ew_u.parts.lsw;					\
} while (0)

/* Get the more significant 32 bit int from a double.  */

#define GET_HIGH_WORD(i,d)					\
do {								\
  ieee_double_shape_type gh_u;					\
  gh_u.value = (d);						\
  (i) = gh_u.parts.msw;						\
} while (0)

/* Get the less significant 32 bit int from a double.  */

#define GET_LOW_WORD(i,d)					\
do {								\
  ieee_double_shape_type gl_u;					\
  gl_u.value = (d);						\
  (i) = gl_u.parts.lsw;						\
} while (0)

/* Set a double from two 32 bit ints.  */

#define INSERT_WORDS(d,ix0,ix1)					\
do {								\
  ieee_double_shape_type iw_u;					\
  iw_u.parts.msw = (ix0);					\
  iw_u.parts.lsw = (ix1);					\
  (d) = iw_u.value;						\
} while (0)

/* Set the more significant 32 bits of a double from an int.  */

#define SET_HIGH_WORD(d,v)					\
do {								\
  ieee_double_shape_type sh_u;					\
  sh_u.value = (d);						\
  sh_u.parts.msw = (v);						\
  (d) = sh_u.value;						\
} while (0)

/* Set the less significant 32 bits of a double from an int.  */

#define SET_LOW_WORD(d,v)					\
do {								\
  ieee_double_shape_type sl_u;					\
  sl_u.value = (d);						\
  sl_u.parts.lsw = (v);						\
  (d) = sl_u.value;						\
} while (0)

/* A union which permits us to convert between a float and a 32 bit
   int.  */

typedef union
{
  float value;
  u_int32_t word;
} ieee_float_shape_type;

/* Get a 32 bit int from a float.  */

#define GET_FLOAT_WORD(i,d)					\
do {								\
  ieee_float_shape_type gf_u;					\
  gf_u.value = (d);						\
  (i) = gf_u.word;						\
} while (0)

/* Set a float from a 32 bit int.  */

#define SET_FLOAT_WORD(d,i)					\
do {								\
  ieee_float_shape_type sf_u;					\
  sf_u.word = (i);						\
  (d) = sf_u.value;						\
} while (0)

#ifdef FLT_EVAL_METHOD
/*
 * Attempt to get strict C99 semantics for assignment with non-C99 compilers.
 */
#if FLT_EVAL_METHOD == 0 || __GNUC__ == 0
#define	STRICT_ASSIGN(type, lval, rval)	((lval) = (rval))
#else /* FLT_EVAL_METHOD == 0 || __GNUC__ == 0 */
#define	STRICT_ASSIGN(type, lval, rval) do {	\
	volatile type __lval;			\
						\
	if (sizeof(type) >= sizeof(long double))	\
		(lval) = (rval);		\
	else {					\
		__lval = (rval);		\
		(lval) = __lval;		\
	}					\
} while (0)
#endif /* FLT_EVAL_METHOD == 0 || __GNUC__ == 0 */
#endif /* FLT_EVAL_METHOD */

__BEGIN_HIDDEN_DECLS
/* fdlibm kernel function */
extern int    __ieee754_rem_pio2(double,double*);
extern double __kernel_sin(double,double,int);
extern double __kernel_cos(double,double);
extern double __kernel_tan(double,double,int);
extern int    __kernel_rem_pio2(double*,double*,int,int,int);

/* float versions of fdlibm kernel functions */
extern int   __ieee754_rem_pio2f(float,float*);
extern float __kernel_sinf(float,float,int);
extern float __kernel_cosf(float,float);
extern float __kernel_tanf(float,float,int);
extern int   __kernel_rem_pio2f(float*,float*,int,int,int,const int*);

/* long double precision kernel functions */
long double __kernel_sinl(long double, long double, int);
long double __kernel_cosl(long double, long double);
long double __kernel_tanl(long double, long double, int);

/*
 * Common routine to process the arguments to nan(), nanf(), and nanl().
 */
void _scan_nan(uint32_t *__words, int __num_words, const char *__s);
__END_HIDDEN_DECLS

/*
 * TRUNC() is a macro that sets the trailing 27 bits in the mantissa
 * of an IEEE double variable to zero.  It must be expression-like
 * for syntactic reasons, and we implement this expression using
 * an inline function instead of a pure macro to avoid depending
 * on the gcc feature of statement-expressions.
 */
#define TRUNC(d)	(_b_trunc(&(d)))

static __inline void
_b_trunc(volatile double *_dp)
{
	uint32_t _lw;

	GET_LOW_WORD(_lw, *_dp);
	SET_LOW_WORD(*_dp, _lw & 0xf8000000);
}

struct Double {
	double	a;
	double	b;
};

/*
 * Functions internal to the math package, yet not static.
 */
__BEGIN_HIDDEN_DECLS
double __exp__D(double, double);
struct Double __log__D(double);
long double __p1evll(long double, void *, int);
long double __polevll(long double, void *, int);
__END_HIDDEN_DECLS

#endif /* _MATH_PRIVATE_H_ */
@


1.17
log
@Make sure STRICT_ASSIGN handles double as well.  From FreeBSD, where the
commit messages that fixes this says:

"it was intentionally left broken as an optimization".

right!

ok martynas@@, daniel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.16 2013/11/12 20:35:09 martynas Exp $	*/
d362 1
d386 1
d414 1
d419 1
@


1.16
log
@Declare __p1evll and __polevll protos in math_private.h instead of
redeclaring each time in ld{80,128}.  Pointed out by theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.15 2011/07/26 11:43:01 martynas Exp $	*/
d352 1
a352 1
	if (sizeof(type) >= sizeof(double))	\
@


1.15
log
@At some point we've switched to the VFP floating-point--unlike FPA
it actually stores floats in natural-endian--therefore the existing
checks became wrong.

Take into account __VFP_FP__, effectively bringing back the old
behavior.  This way it will work now, and in the future when some
of our platforms are switched to FPA, where it's much faster.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.14 2011/07/26 09:24:52 martynas Exp $	*/
d414 2
@


1.14
log
@__arm32__ -> __arm__, since our new compiler isn't defining the
former anymore.  OK miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.13 2011/07/06 00:02:42 martynas Exp $	*/
d229 1
a229 1
#if (BYTE_ORDER == BIG_ENDIAN) || defined(__arm__)
d243 1
a243 1
#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(__arm__)
@


1.13
log
@Finalize work on the math library.  It's time to do this monster
commit, and deal with problems (if any) in tree.

Note that this adds the following functions.  Ports with hacks might
need adjustments.

nexttoward(3), fma(3), nexttowardf(3), fmaf(3), acoshl(3), asinhl(3),
atanhl(3), coshl(3), sinhl(3), tanhl(3), expl(3), expm1l(3), logl(3),
log10l(3), log1pl(3), log2l(3), modfl(3), cbrtl(3), hypotl(3),
powl(3), erfl(3), erfcl(3), lgammal(3), tgammal(3), ceill(3),
floorl(3), lrintl(3), llrintl(3), roundl(3), lroundl(3), llroundl(3),
truncl(3), fmodl(3), remainderl(3), remquol(3), nextafterl(3),
nexttowardl(3), fmal(3).

With this commit, our library implements all functionality required
by C99.  Documentation bits will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.12 2011/07/04 15:00:56 martynas Exp $	*/
d225 1
a225 1
 * The arm32 port is little endian except for the FP word order which is
d229 1
a229 1
#if (BYTE_ORDER == BIG_ENDIAN) || defined(arm32)
d243 1
a243 1
#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(arm32)
@


1.12
log
@- Take into account padding for the IEEE extended shape types.  It
should be 96-bits on 32-bit architectures, and 128-bits on 64-bit
architectures.

- Add abstract macros to operate on long doubles by words.  To be
used soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.11 2008/12/09 20:00:35 martynas Exp $	*/
d163 1
a163 1
#define GET_LDOUBLE_WORDS(exp,ix0,ix1,d)			\
d167 1
a167 1
  (exp) = ew_u.parts.exp;					\
d174 1
a174 1
#define SET_LDOUBLE_WORDS(d,exp,ix0,ix1)			\
d177 1
a177 1
  iw_u.parts.exp = (exp);					\
d204 1
a204 1
#define GET_LDOUBLE_EXP(exp,d)					\
d208 1
a208 1
  (exp) = ge_u.parts.exp;					\
d213 1
a213 1
#define SET_LDOUBLE_EXP(d,exp)					\
d217 1
a217 1
  se_u.parts.exp = (exp);					\
@


1.11
log
@- 80-bit and quad precision trigonometric and other most
important functions: acosl, asinl, atanl, atan2l, cosl,
sinl, tanl, exp2l, frexpl, ilogbl, ldexpl, logbl, scalbnl,
fabsl, hypotl, powl, sqrtl, rintl, copysignl, nanl, fdiml,
fmaxl, fminl.  mostly taken from freebsd, needed alot of
changes to adapt.  note, these are all c versions;  and are
quite slow when architectures have, e.g. sqrt.  assembly
versions will be added afterwards
- make them .weak/__weak_alias to the double precision
versions on other archs
- no need to have two finites.  finite() and finitef() are
non-standard 3BSD obsolete versions of isfinite.  remove
from libm.  make them weak_alias in libc to __isfinite and
__isfinitef instead.  similarly make 3BSD obsolete versions
of isinf, isinff, isnan, isnanf weak_aliases to C99's
__isinf, __isinff, __isnan, __isnanf
- remove unused infinity.c.  the c library has infinities
for each supported platform
- use STRICT_ASSIGN cast hack for _kernel_rem_pio2, so that
the double version has a chance of working on i386 with
extra precision
- avoid storing multiple copies of the pi/2 array, since
it won't vary
- bump major due to removed finite/finitef.  although they
will be in libc, which anything is linked to, minor bump
might be enough
ok millert@@.   tested by sthen@@, jsg@@, ajacoutot@@, kili@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.10 2008/09/07 20:36:09 martynas Exp $	*/
d33 19
a51 2
/* A union which permits us to convert between a double and two 32 bit
   ints.  */
d53 1
a53 4
/*
 * The arm32 port is little endian except for the FP word order which is
 * big endian.
 */
d55 1
a55 1
#if (BYTE_ORDER == BIG_ENDIAN) || defined(arm32)
d59 67
a125 7
  double value;
  struct
  {
    u_int32_t msw;
    u_int32_t lsw;
  } parts;
} ieee_double_shape_type;
d131 5
a136 1
    u_int32_t nsw;
d141 4
d149 7
a155 4
    u_int32_t mswhi;
    u_int32_t mswlo;
    u_int32_t lswhi;
    u_int32_t lswlo;
d157 1
a157 1
} ieee_quad_shape_type;
d161 69
a229 1
#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(arm32)
d236 1
a237 1
    u_int32_t msw;
d241 3
a243 10
typedef union
{
  long double value;
  struct {
    u_int32_t lswlo;
    u_int32_t lswhi;
    u_int32_t mswlo;
    u_int32_t mswhi;
  } parts;
} ieee_quad_shape_type;
d247 3
a249 2
  long double value;
  struct {
a250 1
    u_int32_t nsw;
d253 1
a253 1
} ieee_extended_shape_type;
@


1.10
log
@- replace dtoa w/ David's gdtoa, version 2008-03-15
- provide proper dtoa locks
- use the real strtof implementation
- add strtold, __hdtoa, __hldtoa
- add %a/%A support
- don't lose precision in printf, don't round to double anymore
- implement extended-precision versions of libc functions: fpclassify,
isnan, isinf, signbit, isnormal, isfinite, now that the ieee.h is
fixed
- separate vax versions of strtof, and __hdtoa
- add complex math support.  added functions: cacos, casin, catan,
ccos, csin, ctan, cacosh, casinh, catanh, ccosh, csinh, ctanh, cexp,
clog, cabs, cpow, csqrt, carg, cimag, conj, cproj, creal, cacosf,
casinf, catanf, ccosf, csinf, ctanf, cacoshf, casinhf, catanhf,
ccoshf, csinhf, ctanhf, cexpf, clogf, cabsf, cpowf, csqrtf, cargf,
cimagf, conjf, cprojf, crealf
- add fdim, fmax, fmin
- add log2. (adapted implementation e_log.c.  could be more acruate
& faster, but it's good enough for now)
- remove wrappers & cruft in libm, supposed to work-around mistakes
in SVID, etc.;  use ieee versions.  fixes issues in python 2.6 for
djm@@
- make _digittoint static
- proper definitions for i386, and amd64 in ieee.h
- sh, powerpc don't really have extended-precision
- add missing definitions for mips64 (quad), m{6,8}k (96-bit) float.h
for LDBL_*
- merge lead to frac for m{6,8}k, for gdtoa to work properly
- add FRAC*BITS & EXT_TO_ARRAY32 definitions in ieee.h, for hdtoa&ldtoa
to use
- add EXT_IMPLICIT_NBIT definition, which indicates implicit
normalization bit
- add regression tests for libc: fpclassify and printf
- arith.h & gd_qnan.h definitions
- update ieee.h: hppa doesn't have quad-precision, hppa64 does
- add missing prototypes to gdtoaimp
- on 64-bit platforms make sure gdtoa doesn't use a long when it
really wants an int
- etc., what i may have forgotten...
- bump libm major, due to removed&changed symbols
- no libc bump, since this is riding on djm's libc major crank from
a day ago

discussed with / requested by / testing theo, sthen@@, djm@@, jsg@@,
merdely@@, jsing@@, tedu@@, brad@@, jakemsr@@, and others.
looks good to millert@@
parts of the diff ok kettenis@@

this commit does not include:
- man page changes
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.9 2008/07/24 09:40:16 martynas Exp $	*/
d202 1
a202 1
#else
d213 2
a214 2
#endif
#endif
d221 1
a221 1
extern int    __kernel_rem_pio2(double*,double*,int,int,int,const int*);
d229 10
@


1.9
log
@- remove isinff, isnanf.  this has been moved to libc
- remove never-enabled signbit.  libc has is now
- add C99 implementations, from freebsd, for nan(), nanf() (needed
to write _digittoint for it), exp2(), exp2f(), remquo(), remquof(),
needed STRICT_ASSIGN macro for math_private.h
- bump major
man pages will follow
exp2{,f} has been requested by chl@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.8 2008/06/11 20:53:27 martynas Exp $	*/
d216 1
a216 26
/* ieee style elementary functions */
extern double __ieee754_sqrt(double);
extern double __ieee754_acos(double);
extern double __ieee754_acosh(double);
extern double __ieee754_log(double);
extern double __ieee754_atanh(double);
extern double __ieee754_asin(double);
extern double __ieee754_atan2(double,double);
extern double __ieee754_exp(double);
extern double __ieee754_cosh(double);
extern double __ieee754_fmod(double,double);
extern double __ieee754_pow(double,double);
extern double __ieee754_lgamma_r(double,int *);
extern double __ieee754_gamma_r(double,int *);
extern double __ieee754_lgamma(double);
extern double __ieee754_gamma(double);
extern double __ieee754_log10(double);
extern double __ieee754_sinh(double);
extern double __ieee754_hypot(double,double);
extern double __ieee754_j0(double);
extern double __ieee754_j1(double);
extern double __ieee754_y0(double);
extern double __ieee754_y1(double);
extern double __ieee754_jn(int,double);
extern double __ieee754_yn(int,double);
extern double __ieee754_remainder(double,double);
a217 4
extern double __ieee754_scalb(double,double);

/* fdlibm kernel function */
extern double __kernel_standard(double,double,int);
d223 1
a223 27

/* ieee style elementary float functions */
extern float __ieee754_sqrtf(float);
extern float __ieee754_acosf(float);
extern float __ieee754_acoshf(float);
extern float __ieee754_logf(float);
extern float __ieee754_atanhf(float);
extern float __ieee754_asinf(float);
extern float __ieee754_atan2f(float,float);
extern float __ieee754_expf(float);
extern float __ieee754_coshf(float);
extern float __ieee754_fmodf(float,float);
extern float __ieee754_powf(float,float);
extern float __ieee754_lgammaf_r(float,int *);
extern float __ieee754_gammaf_r(float,int *);
extern float __ieee754_lgammaf(float);
extern float __ieee754_gammaf(float);
extern float __ieee754_log10f(float);
extern float __ieee754_sinhf(float);
extern float __ieee754_hypotf(float,float);
extern float __ieee754_j0f(float);
extern float __ieee754_j1f(float);
extern float __ieee754_y0f(float);
extern float __ieee754_y1f(float);
extern float __ieee754_jnf(int,float);
extern float __ieee754_ynf(int,float);
extern float __ieee754_remainderf(float,float);
a224 3
extern float __ieee754_scalbf(float,float);

/* float versions of fdlibm kernel functions */
@


1.8
log
@- on non-ieee, rename gamma to tgamma, the 'true' gamma
- make gamma an alias of lgamma
- on ieee, add tgamma, based on gamma from non-ieee
- fixes for tgamma/lgamma/exp/log, esp. special cases (some from
freebsd);  properly raise invalid fp operations on vax
- also some general cleanup, ansification, man page (which was ok
jmc@@)
- bump minor
this makes some ports using tgamma possible;  also consistifies
behavior across openbsd/ieee and openbsd/non-ieee, and other operating
systems
much thanks sthen@@, johan@@, steven@@, Simon Kuhnle, Wiktor Izdebski
for testing
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.7 2007/06/01 05:50:56 jason Exp $	*/
d195 20
@


1.7
log
@add little endian and big endian shapes for extended and quad float
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.6 2002/02/16 21:27:27 millert Exp $	*/
d43 1
a43 1
typedef union 
d46 1
a46 1
  struct 
d78 1
a78 1
typedef union 
d81 1
a81 1
  struct 
d197 7
a203 7
extern double __ieee754_sqrt(double);			
extern double __ieee754_acos(double);			
extern double __ieee754_acosh(double);			
extern double __ieee754_log(double);			
extern double __ieee754_atanh(double);			
extern double __ieee754_asin(double);			
extern double __ieee754_atan2(double,double);			
d226 1
a226 1
extern double __kernel_standard(double,double,int);	
d234 7
a240 7
extern float __ieee754_sqrtf(float);			
extern float __ieee754_acosf(float);			
extern float __ieee754_acoshf(float);			
extern float __ieee754_logf(float);			
extern float __ieee754_atanhf(float);			
extern float __ieee754_asinf(float);			
extern float __ieee754_atan2f(float,float);			
d267 29
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.5 2000/03/02 00:29:50 todd Exp $	*/
d53 21
d87 21
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: math_private.h,v 1.4 1996/11/14 14:21:51 etheisen Exp $	*/
d155 27
a181 27
extern double __ieee754_sqrt __P((double));			
extern double __ieee754_acos __P((double));			
extern double __ieee754_acosh __P((double));			
extern double __ieee754_log __P((double));			
extern double __ieee754_atanh __P((double));			
extern double __ieee754_asin __P((double));			
extern double __ieee754_atan2 __P((double,double));			
extern double __ieee754_exp __P((double));
extern double __ieee754_cosh __P((double));
extern double __ieee754_fmod __P((double,double));
extern double __ieee754_pow __P((double,double));
extern double __ieee754_lgamma_r __P((double,int *));
extern double __ieee754_gamma_r __P((double,int *));
extern double __ieee754_lgamma __P((double));
extern double __ieee754_gamma __P((double));
extern double __ieee754_log10 __P((double));
extern double __ieee754_sinh __P((double));
extern double __ieee754_hypot __P((double,double));
extern double __ieee754_j0 __P((double));
extern double __ieee754_j1 __P((double));
extern double __ieee754_y0 __P((double));
extern double __ieee754_y1 __P((double));
extern double __ieee754_jn __P((int,double));
extern double __ieee754_yn __P((int,double));
extern double __ieee754_remainder __P((double,double));
extern int    __ieee754_rem_pio2 __P((double,double*));
extern double __ieee754_scalb __P((double,double));
d184 5
a188 5
extern double __kernel_standard __P((double,double,int));	
extern double __kernel_sin __P((double,double,int));
extern double __kernel_cos __P((double,double));
extern double __kernel_tan __P((double,double,int));
extern int    __kernel_rem_pio2 __P((double*,double*,int,int,int,const int*));
d192 27
a218 27
extern float __ieee754_sqrtf __P((float));			
extern float __ieee754_acosf __P((float));			
extern float __ieee754_acoshf __P((float));			
extern float __ieee754_logf __P((float));			
extern float __ieee754_atanhf __P((float));			
extern float __ieee754_asinf __P((float));			
extern float __ieee754_atan2f __P((float,float));			
extern float __ieee754_expf __P((float));
extern float __ieee754_coshf __P((float));
extern float __ieee754_fmodf __P((float,float));
extern float __ieee754_powf __P((float,float));
extern float __ieee754_lgammaf_r __P((float,int *));
extern float __ieee754_gammaf_r __P((float,int *));
extern float __ieee754_lgammaf __P((float));
extern float __ieee754_gammaf __P((float));
extern float __ieee754_log10f __P((float));
extern float __ieee754_sinhf __P((float));
extern float __ieee754_hypotf __P((float,float));
extern float __ieee754_j0f __P((float));
extern float __ieee754_j1f __P((float));
extern float __ieee754_y0f __P((float));
extern float __ieee754_y1f __P((float));
extern float __ieee754_jnf __P((int,float));
extern float __ieee754_ynf __P((int,float));
extern float __ieee754_remainderf __P((float,float));
extern int   __ieee754_rem_pio2f __P((float,float*));
extern float __ieee754_scalbf __P((float,float));
d221 4
a224 4
extern float __kernel_sinf __P((float,float,int));
extern float __kernel_cosf __P((float,float));
extern float __kernel_tanf __P((float,float,int));
extern int   __kernel_rem_pio2f __P((float*,float*,int,int,int,const int*));
@


1.4
log
@machine/endian.h not needed.
@
text
@d1 1
a14 1
 * $Id: math_private.h,v 1.3 1996/05/24 10:57:43 deraadt Exp $
@


1.3
log
@darn good reason not use a primarily big-endian cpu in little-endian mode:
the ARM port runs little-endian, but it's fp is still big-endian!
@
text
@d14 1
a14 1
 * $Id: math_private.h,v 1.2 1995/10/28 00:57:20 deraadt Exp $
a19 1
#include <machine/endian.h>
@


1.2
log
@update from NetBSD
@
text
@d14 1
a14 1
 * $Id: math_private.h,v 1.3 1995/03/25 01:48:53 jtc Exp $
d37 6
a42 1
#if BYTE_ORDER == BIG_ENDIAN
d56 1
a56 1
#if BYTE_ORDER == LITTLE_ENDIAN
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
