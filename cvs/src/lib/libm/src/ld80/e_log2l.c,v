head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.12
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.8
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.10
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.10
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.8
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.6
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2017.01.21.08.29.13;	author krw;	state Exp;
branches;
next	1.2;
commitid	F2YefviqXngZtOa0;

1.2
date	2013.11.12.20.35.19;	author martynas;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.06.00.02.42;	author martynas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: e_log2l.c,v 1.2 2013/11/12 20:35:19 martynas Exp $	*/

/*
 * Copyright (c) 2008 Stephen L. Moshier <steve@@moshier.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*							log2l.c
 *
 *	Base 2 logarithm, long double precision
 *
 *
 *
 * SYNOPSIS:
 *
 * long double x, y, log2l();
 *
 * y = log2l( x );
 *
 *
 *
 * DESCRIPTION:
 *
 * Returns the base 2 logarithm of x.
 *
 * The argument is separated into its exponent and fractional
 * parts.  If the exponent is between -1 and +1, the (natural)
 * logarithm of the fraction is approximated by
 *
 *     log(1+x) = x - 0.5 x**2 + x**3 P(x)/Q(x).
 *
 * Otherwise, setting  z = 2(x-1)/x+1),
 *
 *     log(x) = z + z**3 P(z)/Q(z).
 *
 *
 *
 * ACCURACY:
 *
 *                      Relative error:
 * arithmetic   domain     # trials      peak         rms
 *    IEEE      0.5, 2.0     30000      9.8e-20     2.7e-20
 *    IEEE     exp(+-10000)  70000      5.4e-20     2.3e-20
 *
 * In the tests over the interval exp(+-10000), the logarithms
 * of the random arguments were uniformly distributed over
 * [-10000, +10000].
 *
 * ERROR MESSAGES:
 *
 * log singularity:  x = 0; returns -INFINITY
 * log domain:       x < 0; returns NAN
 */

#include <math.h>

#include "math_private.h"

/* Coefficients for ln(1+x) = x - x**2/2 + x**3 P(x)/Q(x)
 * 1/sqrt(2) <= x < sqrt(2)
 * Theoretical peak relative error = 6.2e-22
 */
static long double P[] = {
 4.9962495940332550844739E-1L,
 1.0767376367209449010438E1L,
 7.7671073698359539859595E1L,
 2.5620629828144409632571E2L,
 4.2401812743503691187826E2L,
 3.4258224542413922935104E2L,
 1.0747524399916215149070E2L,
};
static long double Q[] = {
/* 1.0000000000000000000000E0,*/
 2.3479774160285863271658E1L,
 1.9444210022760132894510E2L,
 7.7952888181207260646090E2L,
 1.6911722418503949084863E3L,
 2.0307734695595183428202E3L,
 1.2695660352705325274404E3L,
 3.2242573199748645407652E2L,
};

/* Coefficients for log(x) = z + z^3 P(z^2)/Q(z^2),
 * where z = 2(x-1)/(x+1)
 * 1/sqrt(2) <= x < sqrt(2)
 * Theoretical peak relative error = 6.16e-22
 */
static long double R[4] = {
 1.9757429581415468984296E-3L,
-7.1990767473014147232598E-1L,
 1.0777257190312272158094E1L,
-3.5717684488096787370998E1L,
};
static long double S[4] = {
/* 1.00000000000000000000E0L,*/
-2.6201045551331104417768E1L,
 1.9361891836232102174846E2L,
-4.2861221385716144629696E2L,
};
/* log2(e) - 1 */
#define LOG2EA 4.4269504088896340735992e-1L

#define SQRTH 0.70710678118654752440L

long double
log2l(long double x)
{
volatile long double z;
long double y;
int e;

if( isnan(x) )
	return(x);
if( x == INFINITY )
	return(x);
/* Test for domain */
if( x <= 0.0L )
	{
	if( x == 0.0L )
		return( -INFINITY );
	else
		return( NAN );
	}

/* separate mantissa from exponent */

/* Note, frexp is used so that denormal numbers
 * will be handled properly.
 */
x = frexpl( x, &e );


/* logarithm using log(x) = z + z**3 P(z)/Q(z),
 * where z = 2(x-1)/x+1)
 */
if( (e > 2) || (e < -2) )
{
if( x < SQRTH )
	{ /* 2( 2x-1 )/( 2x+1 ) */
	e -= 1;
	z = x - 0.5L;
	y = 0.5L * z + 0.5L;
	}
else
	{ /*  2 (x-1)/(x+1)   */
	z = x - 0.5L;
	z -= 0.5L;
	y = 0.5L * x  + 0.5L;
	}
x = z / y;
z = x*x;
y = x * ( z * __polevll( z, R, 3 ) / __p1evll( z, S, 3 ) );
goto done;
}


/* logarithm using log(1+x) = x - .5x**2 + x**3 P(x)/Q(x) */

if( x < SQRTH )
	{
	e -= 1;
	x = ldexpl( x, 1 ) - 1.0L; /*  2x - 1  */
	}
else
	{
	x = x - 1.0L;
	}
z = x*x;
y = x * ( z * __polevll( x, P, 6 ) / __p1evll( x, Q, 7 ) );
y = y - ldexpl( z, -1 );   /* -0.5x^2 + ... */

done:

/* Multiply log of fraction by log2(e)
 * and base 2 exponent by 1
 *
 * ***CAUTION***
 *
 * This sequence of operations is critical and it may
 * be horribly defeated by some compiler optimizers.
 */
z = y * LOG2EA;
z += x * LOG2EA;
z += y;
z += x;
z += e;
return( z );
}
@


1.2
log
@Declare __p1evll and __polevll protos in math_private.h instead of
redeclaring each time in ld{80,128}.  Pointed out by theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: e_log2l.c,v 1.1 2011/07/06 00:02:42 martynas Exp $	*/
d154 1
a154 1
	}	
d174 1
a174 1
	}	
@


1.1
log
@Finalize work on the math library.  It's time to do this monster
commit, and deal with problems (if any) in tree.

Note that this adds the following functions.  Ports with hacks might
need adjustments.

nexttoward(3), fma(3), nexttowardf(3), fmaf(3), acoshl(3), asinhl(3),
atanhl(3), coshl(3), sinhl(3), tanhl(3), expl(3), expm1l(3), logl(3),
log10l(3), log1pl(3), log2l(3), modfl(3), cbrtl(3), hypotl(3),
powl(3), erfl(3), erfcl(3), lgammal(3), tgammal(3), ceill(3),
floorl(3), lrintl(3), llrintl(3), roundl(3), lroundl(3), llroundl(3),
truncl(3), fmodl(3), remainderl(3), remquol(3), nextafterl(3),
nexttowardl(3), fmal(3).

With this commit, our library implements all functionality required
by C99.  Documentation bits will follow.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 2
a114 2
extern long double __polevll(long double, void *, int);
extern long double __p1evll(long double, void *, int);
@

