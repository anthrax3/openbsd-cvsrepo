head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.16
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.12
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.14
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.6
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.10
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.6
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.4
	OPENBSD_5_0:1.1.0.2
	OPENBSD_5_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2017.01.21.08.29.13;	author krw;	state Exp;
branches;
next	1.2;
commitid	F2YefviqXngZtOa0;

1.2
date	2012.12.05.23.20.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.06.00.02.42;	author martynas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/* @@(#)e_fmod.c 1.3 95/01/18 */
/*-
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#include <sys/types.h>
#include <machine/ieee.h>

#include <float.h>
#include <math.h>
#include <stdint.h>

#include "math_private.h"

#define	BIAS (LDBL_MAX_EXP - 1)

/*
 * These macros add and remove an explicit integer bit in front of the
 * fractional mantissa, if the architecture doesn't have such a bit by
 * default already.
 */
#ifdef LDBL_IMPLICIT_NBIT
#define	LDBL_NBIT	0
#define	SET_NBIT(hx)	((hx) | (1ULL << LDBL_MANH_SIZE))
#define	HFRAC_BITS	EXT_FRACHBITS
#else
#define	LDBL_NBIT	0x80000000
#define	SET_NBIT(hx)	(hx)
#define	HFRAC_BITS	(EXT_FRACHBITS - 1)
#endif

#define	MANL_SHIFT	(EXT_FRACLBITS - 1)

static const long double one = 1.0, Zero[] = {0.0, -0.0,};

/*
 * fmodl(x,y)
 * Return x mod y in exact arithmetic
 * Method: shift and subtract
 *
 * Assumptions:
 * - The low part of the mantissa fits in a manl_t exactly.
 * - The high part of the mantissa fits in an int64_t with enough room
 *   for an explicit integer bit in front of the fractional bits.
 */
long double
fmodl(long double x, long double y)
{
	union {
		long double e;
		struct ieee_ext bits;
	} ux, uy;
	int64_t hx,hz;	/* We need a carry bit even if LDBL_MANH_SIZE is 32. */
	uint32_t hy;
	uint32_t lx,ly,lz;
	int ix,iy,n,sx;

	ux.e = x;
	uy.e = y;
	sx = ux.bits.ext_sign;

    /* purge off exception values */
	if((uy.bits.ext_exp|uy.bits.ext_frach|uy.bits.ext_fracl)==0 || /* y=0 */
	   (ux.bits.ext_exp == BIAS + LDBL_MAX_EXP) ||	 /* or x not finite */
	   (uy.bits.ext_exp == BIAS + LDBL_MAX_EXP &&
	    ((uy.bits.ext_frach&~LDBL_NBIT)|uy.bits.ext_fracl)!=0)) /* or y is NaN */
	    return (x*y)/(x*y);
	if(ux.bits.ext_exp<=uy.bits.ext_exp) {
	    if((ux.bits.ext_exp<uy.bits.ext_exp) ||
	       (ux.bits.ext_frach<=uy.bits.ext_frach &&
		(ux.bits.ext_frach<uy.bits.ext_frach ||
		 ux.bits.ext_fracl<uy.bits.ext_fracl))) {
		return x;		/* |x|<|y| return x or x-y */
	    }
	    if(ux.bits.ext_frach==uy.bits.ext_frach &&
		ux.bits.ext_fracl==uy.bits.ext_fracl) {
		return Zero[sx];	/* |x|=|y| return x*0*/
	    }
	}

    /* determine ix = ilogb(x) */
	if(ux.bits.ext_exp == 0) {	/* subnormal x */
	    ux.e *= 0x1.0p512;
	    ix = ux.bits.ext_exp - (BIAS + 512);
	} else {
	    ix = ux.bits.ext_exp - BIAS;
	}

    /* determine iy = ilogb(y) */
	if(uy.bits.ext_exp == 0) {	/* subnormal y */
	    uy.e *= 0x1.0p512;
	    iy = uy.bits.ext_exp - (BIAS + 512);
	} else {
	    iy = uy.bits.ext_exp - BIAS;
	}

    /* set up {hx,lx}, {hy,ly} and align y to x */
	hx = SET_NBIT(ux.bits.ext_frach);
	hy = SET_NBIT(uy.bits.ext_frach);
	lx = ux.bits.ext_fracl;
	ly = uy.bits.ext_fracl;

    /* fix point fmod */
	n = ix - iy;

	while(n--) {
	    hz=hx-hy;lz=lx-ly; if(lx<ly) hz -= 1;
	    if(hz<0){hx = hx+hx+(lx>>MANL_SHIFT); lx = lx+lx;}
	    else {
		if ((hz|lz)==0)		/* return sign(x)*0 */
		    return Zero[sx];
		hx = hz+hz+(lz>>MANL_SHIFT); lx = lz+lz;
	    }
	}
	hz=hx-hy;lz=lx-ly; if(lx<ly) hz -= 1;
	if(hz>=0) {hx=hz;lx=lz;}

    /* convert back to floating value and restore the sign */
	if((hx|lx)==0)			/* return sign(x)*0 */
	    return Zero[sx];
	while(hx<(1ULL<<HFRAC_BITS)) {	/* normalize x */
	    hx = hx+hx+(lx>>MANL_SHIFT); lx = lx+lx;
	    iy -= 1;
	}
	ux.bits.ext_frach = hx; /* The mantissa is truncated here if needed. */
	ux.bits.ext_fracl = lx;
	if (iy < LDBL_MIN_EXP) {
	    ux.bits.ext_exp = iy + (BIAS + 512);
	    ux.e *= 0x1p-512;
	} else {
	    ux.bits.ext_exp = iy + BIAS;
	}
	x = ux.e * one;		/* create necessary signal */
	return x;		/* exact output */
}
@


1.2
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d8 1
a8 1
 * software is freely granted, provided that this notice 
@


1.1
log
@Finalize work on the math library.  It's time to do this monster
commit, and deal with problems (if any) in tree.

Note that this adds the following functions.  Ports with hacks might
need adjustments.

nexttoward(3), fma(3), nexttowardf(3), fmaf(3), acoshl(3), asinhl(3),
atanhl(3), coshl(3), sinhl(3), tanhl(3), expl(3), expm1l(3), logl(3),
log10l(3), log1pl(3), log2l(3), modfl(3), cbrtl(3), hypotl(3),
powl(3), erfl(3), erfcl(3), lgammal(3), tgammal(3), ceill(3),
floorl(3), lrintl(3), llrintl(3), roundl(3), lroundl(3), llroundl(3),
truncl(3), fmodl(3), remainderl(3), remquol(3), nextafterl(3),
nexttowardl(3), fmal(3).

With this commit, our library implements all functionality required
by C99.  Documentation bits will follow.
@
text
@a12 5
#include <sys/cdefs.h>
#if 0
__FBSDID("$FreeBSD: src/lib/msun/src/e_fmodl.c,v 1.2 2008/07/31 20:09:47 das Exp $");
#endif

@

