head	1.6;
access;
symbols
	OPENBSD_6_0:1.4.0.14
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.10
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.12
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.8
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.14
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.12
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.10
	OPENBSD_5_0:1.3.0.8
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.6
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2016.09.12.19.47.02;	author guenther;	state Exp;
branches;
next	1.5;
commitid	Lp8bnB2xK76nGFvJ;

1.5
date	2016.09.12.04.39.47;	author guenther;	state Exp;
branches;
next	1.4;
commitid	yu8HfTXRTrrv8b2W;

1.4
date	2013.07.15.04.08.26;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.27.23.59.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.11.20.03.21;	author martynas;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.07.22.25.53;	author martynas;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Reduce libm's exports and make internal calls go direct.
All dependencies on libc are now via reserved/standardized names.

ok kettenis@@ millert@@ deraadt@@
@
text
@/*	$OpenBSD: n_hypot.c,v 1.5 2016/09/12 04:39:47 guenther Exp $	*/
/*	$NetBSD: n_cabs.c,v 1.1 1995/10/10 23:36:39 ragge Exp $	*/
/*
 * Copyright (c) 1985, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* HYPOT(X,Y)
 * RETURN THE SQUARE ROOT OF X^2 + Y^2  WHERE Z=X+iY
 * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)
 * CODED IN C BY K.C. NG, 11/28/84;
 * REVISED BY K.C. NG, 7/12/85.
 *
 * Required system supported functions :
 *	copysign(x,y)
 *	isfinite(x)
 *	scalbn(x,N)
 *	sqrt(x)
 *
 * Method :
 *	1. replace x by |x| and y by |y|, and swap x and
 *	   y if y > x (hence x is never smaller than y).
 *	2. Hypot(x,y) is computed by:
 *	   Case I, x/y > 2
 *
 *				       y
 *		hypot = x + -----------------------------
 *			 		    2
 *			    sqrt ( 1 + [x/y]  )  +  x/y
 *
 *	   Case II, x/y <= 2
 *				                   y
 *		hypot = x + --------------------------------------------------
 *				          		     2
 *				     			[x/y]   -  2
 *			   (sqrt(2)+1) + (x-y)/y + -----------------------------
 *			 		    			  2
 *			    			  sqrt ( 1 + [x/y]  )  + sqrt(2)
 *
 *
 *
 * Special cases:
 *	hypot(x,y) is INF if x or y is +INF or -INF; else
 *	hypot(x,y) is NAN if x or y is NAN.
 *
 * Accuracy:
 * 	hypot(x,y) returns the sqrt(x^2+y^2) with error less than 1 ulps (units
 *	in the last place). See Kahan's "Interval Arithmetic Options in the
 *	Proposed IEEE Floating Point Arithmetic Standard", Interval Mathematics
 *      1980, Edited by Karl L.E. Nickel, pp 99-128. (A faster but less accurate
 *	code follows in	comments.) In a test run with 500,000 random arguments
 *	on a VAX, the maximum observed error was .959 ulps.
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following constants.
 * The decimal values may be used, provided that the compiler will convert
 * from decimal to binary accurately enough to produce the hexadecimal values
 * shown.
 */

#include "math.h"
#include "mathimpl.h"

static const double r2p1hi = 2.4142135623730950345E0;
static const double r2p1lo = 1.4349369327986523769E-17;
static const double sqrt2 = 1.4142135623730950622E0;

float
hypotf(float x, float y)
{
	return (float)hypot((double) x, (double) y);
}

double
hypot(double x, double y)
{
	static const double zero=0, one=1,
		      small=1.0E-18;	/* fl(1+small)==1 */
	static const ibig=30;	/* fl(1+2**(2*ibig))==1 */
	double t,r;
	int exp;

	if(isfinite(x))
	    if(isfinite(y))
	    {
		x=copysign(x,one);
		y=copysign(y,one);
		if(y > x)
		    { t=x; x=y; y=t; }
		if(x == zero) return(zero);
		if(y == zero) return(x);
		exp= logb(x);
		if (exp - (int)logb(y) > ibig) {
			if (one + small >= 1.0)	/* raise inexact flag */
				return(x);	/* return |x| */
		}

	    /* start computing sqrt(x^2 + y^2) */
		r=x-y;
		if(r>y) { 	/* x/y > 2 */
		    r=x/y;
		    r=r+sqrt(one+r*r); }
		else {		/* 1 <= x/y <= 2 */
		    r/=y; t=r*(r+2.0);
		    r+=t/(sqrt2+sqrt(2.0+t));
		    r+=r2p1lo; r+=r2p1hi; }

		r=y/r;
		return(x+r);

	    }

	    else if(isinf(y))		/* y is +-INF */
		     return(copysign(y,one));
	    else
		     return(y);		/* y is NaN and x is finite */

	else if(isinf(x))		/* x is +-INF */
	         return (copysign(x,one));
	else if(isfinite(y))
	         return(x);		/* x is NaN, y is finite */
	else if (isnan(y))
		return (y);
	else return(copysign(y,one));	/* y is INF */
}
DEF_STD(hypot);
LDBL_CLONE(hypot);

/* A faster but less accurate version of cabs(x,y) */
#if 0
double
hypot(double x, double y)
{
	static const double zero=0, one=1;
		      small=1.0E-18;	/* fl(1+small)==1 */
	static const ibig=30;	/* fl(1+2**(2*ibig))==1 */
	double temp;
	int exp;

	if(isfinite(x))
	    if(isfinite(y))
	    {
		x=copysign(x,one);
		y=copysign(y,one);
		if(y > x)
		    { temp=x; x=y; y=temp; }
		if(x == zero) return(zero);
		if(y == zero) return(x);
		exp= logb(x);
		x=scalbn(x,-exp);
		if (exp - (int)logb(y) > ibig) {
			if (one + small >= 1.0)		/* raise inexact flag */
				return(scalbn(x,exp));	/* return |x| */
		}
		else y=scalbn(y,-exp);
		return(scalbn(sqrt(x*x+y*y),exp));
	    }

	    else if(isinf(y))		/* y is +-INF */
		     return(copysign(y,one));
	    else
		     return(y);		/* y is NaN and x is finite */

	else if(isinf(x))		/* x is +-INF */
	         return (copysign(x,one));
	else if(isfinite(y))
	         return(x);		/* x is NaN, y is finite */
	else if(isnan(y)) return(y);	/* x and y is NaN */
	else return(copysign(y,one));	/* y is INF */
}
#endif
@


1.5
log
@Per fpclassify(3): isinff(), isnanf(), finite(), and finitef() are deprecated
in favor of isinf(), isnan(), and isfinite().

ok tb@@ martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_hypot.c,v 1.4 2013/07/15 04:08:26 espie Exp $	*/
d150 2
a151 2

__strong_alias(hypotl, hypot);
@


1.4
log
@bring reference C code that's not compiled in synch with asm code
okay martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_hypot.c,v 1.3 2009/10/27 23:59:29 deraadt Exp $	*/
d40 1
a40 1
 *	finite(x)
d107 2
a108 2
	if(finite(x))
	    if(finite(y))
d144 1
a144 1
	else if(finite(y))
d164 2
a165 2
	if(finite(x))
	    if(finite(y))
d190 1
a190 1
	else if(finite(y))
@


1.3
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: n_hypot.c,v 1.2 2009/04/11 20:03:21 martynas Exp $	*/
d92 6
d150 2
@


1.2
log
@in the old days compiler could not convert decimal constants
accurately, hence the tricks in libm, using machine representation
of constants.  remove kludges and switch to use decimal constants,
much simplifying the code.  since, the compiler converts them
accurately.  generated values match on vaxfp
discussed with millert@@, and miod@@
testing todd@@, and myself
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_hypot.c,v 1.1 2008/10/07 22:25:53 martynas Exp $	*/
a30 4

#ifndef lint
static char sccsid[] = "@@(#)cabs.c	8.1 (Berkeley) 6/4/93";
#endif /* not lint */
@


1.1
log
@- noieee_src: adapt complex versions of the functions it already
supports (which is all, except the float ones)
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_cabs.c,v 1.11 2008/09/13 21:25:40 martynas Exp $	*/
d92 3
a94 13
vc(r2p1hi, 2.4142135623730950345E0   ,8279,411a,ef32,99fc,   2, .9A827999FCEF32)
vc(r2p1lo, 1.4349369327986523769E-17 ,597d,2484,754b,89b3, -55, .84597D89B3754B)
vc(sqrt2,  1.4142135623730950622E0   ,04f3,40b5,de65,33f9,   1, .B504F333F9DE65)

ic(r2p1hi, 2.4142135623730949234E0   ,   1, 1.3504F333F9DE6)
ic(r2p1lo, 1.2537167179050217666E-16 , -53, 1.21165F626CDD5)
ic(sqrt2,  1.4142135623730951455E0   ,   0, 1.6A09E667F3BCD)

#ifdef vccast
#define	r2p1hi	vccast(r2p1hi)
#define	r2p1lo	vccast(r2p1lo)
#define	sqrt2	vccast(sqrt2)
#endif
@

