head	1.13;
access;
symbols
	OPENBSD_5_3:1.12.0.18
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.16
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.14
	OPENBSD_5_0:1.12.0.12
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.10
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.10
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2013.07.03.04.48.16;	author espie;	state dead;
branches;
next	1.12;

1.12
date	2008.10.07.22.25.53;	author martynas;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.13.21.25.40;	author martynas;	state Exp;
branches;
next	1.10;

1.10
date	2008.07.17.15.36.28;	author martynas;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.25.17.49.31;	author martynas;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.21.08.26.19;	author martynas;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.12.22.43.36;	author martynas;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.12.22.20.56;	author martynas;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.12.15.57.59;	author martynas;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.20.18.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.11.12.41.13;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.10.12.17.44;	author hugh;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@with DBL vs LDBL fixed, tedu some source in noieee which is actually the
same as code in generic src.
introduce PURE_SRCS for completely MI math code.
okau martynas@@
@
text
@/*	$OpenBSD: n_cabs.c,v 1.12 2008/10/07 22:25:53 martynas Exp $	*/
/*
 * Copyright (c) 2008 Martynas Venckus <martynas@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <complex.h>
#include <math.h>

double
cabs(double complex z)
{
	return hypot(__real__ z, __imag__ z);
}
@


1.12
log
@- noieee_src: adapt complex versions of the functions it already
supports (which is all, except the float ones)
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: s_cabs.c,v 1.1 2008/09/07 20:36:09 martynas Exp $	*/
@


1.11
log
@remove z_abs.  ok millert@@
@
text
@d1 1
a1 2
/*	$OpenBSD: n_cabs.c,v 1.10 2008/07/17 15:36:28 martynas Exp $	*/
/*	$NetBSD: n_cabs.c,v 1.1 1995/10/10 23:36:39 ragge Exp $	*/
d3 1
a3 2
 * Copyright (c) 1985, 1993
 *	The Regents of the University of California.  All rights reserved.
d5 11
a15 163
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef lint
static char sccsid[] = "@@(#)cabs.c	8.1 (Berkeley) 6/4/93";
#endif /* not lint */

/* HYPOT(X,Y)
 * RETURN THE SQUARE ROOT OF X^2 + Y^2  WHERE Z=X+iY
 * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)
 * CODED IN C BY K.C. NG, 11/28/84;
 * REVISED BY K.C. NG, 7/12/85.
 *
 * Required system supported functions :
 *	copysign(x,y)
 *	finite(x)
 *	scalbn(x,N)
 *	sqrt(x)
 *
 * Method :
 *	1. replace x by |x| and y by |y|, and swap x and
 *	   y if y > x (hence x is never smaller than y).
 *	2. Hypot(x,y) is computed by:
 *	   Case I, x/y > 2
 *
 *				       y
 *		hypot = x + -----------------------------
 *			 		    2
 *			    sqrt ( 1 + [x/y]  )  +  x/y
 *
 *	   Case II, x/y <= 2
 *				                   y
 *		hypot = x + --------------------------------------------------
 *				          		     2
 *				     			[x/y]   -  2
 *			   (sqrt(2)+1) + (x-y)/y + -----------------------------
 *			 		    			  2
 *			    			  sqrt ( 1 + [x/y]  )  + sqrt(2)
 *
 *
 *
 * Special cases:
 *	hypot(x,y) is INF if x or y is +INF or -INF; else
 *	hypot(x,y) is NAN if x or y is NAN.
 *
 * Accuracy:
 * 	hypot(x,y) returns the sqrt(x^2+y^2) with error less than 1 ulps (units
 *	in the last place). See Kahan's "Interval Arithmetic Options in the
 *	Proposed IEEE Floating Point Arithmetic Standard", Interval Mathematics
 *      1980, Edited by Karl L.E. Nickel, pp 99-128. (A faster but less accurate
 *	code follows in	comments.) In a test run with 500,000 random arguments
 *	on a VAX, the maximum observed error was .959 ulps.
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following constants.
 * The decimal values may be used, provided that the compiler will convert
 * from decimal to binary accurately enough to produce the hexadecimal values
 * shown.
 */

#include "math.h"
#include "mathimpl.h"

vc(r2p1hi, 2.4142135623730950345E0   ,8279,411a,ef32,99fc,   2, .9A827999FCEF32)
vc(r2p1lo, 1.4349369327986523769E-17 ,597d,2484,754b,89b3, -55, .84597D89B3754B)
vc(sqrt2,  1.4142135623730950622E0   ,04f3,40b5,de65,33f9,   1, .B504F333F9DE65)

ic(r2p1hi, 2.4142135623730949234E0   ,   1, 1.3504F333F9DE6)
ic(r2p1lo, 1.2537167179050217666E-16 , -53, 1.21165F626CDD5)
ic(sqrt2,  1.4142135623730951455E0   ,   0, 1.6A09E667F3BCD)

#ifdef vccast
#define	r2p1hi	vccast(r2p1hi)
#define	r2p1lo	vccast(r2p1lo)
#define	sqrt2	vccast(sqrt2)
#endif

double
hypot(double x, double y)
{
	static const double zero=0, one=1,
		      small=1.0E-18;	/* fl(1+small)==1 */
	static const ibig=30;	/* fl(1+2**(2*ibig))==1 */
	double t,r;
	int exp;

	if(finite(x))
	    if(finite(y))
	    {
		x=copysign(x,one);
		y=copysign(y,one);
		if(y > x)
		    { t=x; x=y; y=t; }
		if(x == zero) return(zero);
		if(y == zero) return(x);
		exp= logb(x);
		if (exp - (int)logb(y) > ibig) {
			if (one + small >= 1.0)	/* raise inexact flag */
				return(x);	/* return |x| */
		}

	    /* start computing sqrt(x^2 + y^2) */
		r=x-y;
		if(r>y) { 	/* x/y > 2 */
		    r=x/y;
		    r=r+sqrt(one+r*r); }
		else {		/* 1 <= x/y <= 2 */
		    r/=y; t=r*(r+2.0);
		    r+=t/(sqrt2+sqrt(2.0+t));
		    r+=r2p1lo; r+=r2p1hi; }

		r=y/r;
		return(x+r);

	    }

	    else if(isinf(y))		/* y is +-INF */
		     return(copysign(y,one));
	    else
		     return(y);		/* y is NaN and x is finite */

	else if(isinf(x))		/* x is +-INF */
	         return (copysign(x,one));
	else if(finite(y))
	         return(x);		/* x is NaN, y is finite */
	else if (isnan(y))
		return (y);
	else return(copysign(y,one));	/* y is INF */
}

/* CABS(Z)
 * RETURN THE ABSOLUTE VALUE OF THE COMPLEX NUMBER  Z = X + iY
 * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)
 * CODED IN C BY K.C. NG, 11/28/84.
 * REVISED BY K.C. NG, 7/12/85.
 *
 * Required kernel function :
 *	hypot(x,y)
 *
 * Method :
 *	cabs(z) = hypot(x,y) .
d18 2
a19 1
struct complex { double x, y; };
d22 1
a22 1
cabs(struct complex z)
d24 1
a24 44
	return hypot(z.x,z.y);
}

/* A faster but less accurate version of cabs(x,y) */
#if 0
double
hypot(double x, double y)
{
	static const double zero=0, one=1;
		      small=1.0E-18;	/* fl(1+small)==1 */
	static const ibig=30;	/* fl(1+2**(2*ibig))==1 */
	double temp;
	int exp;

	if(finite(x))
	    if(finite(y))
	    {
		x=copysign(x,one);
		y=copysign(y,one);
		if(y > x)
		    { temp=x; x=y; y=temp; }
		if(x == zero) return(zero);
		if(y == zero) return(x);
		exp= logb(x);
		x=scalbn(x,-exp);
		if (exp - (int)logb(y) > ibig) {
			if (one + small >= 1.0)		/* raise inexact flag */
				return(scalbn(x,exp));	/* return |x| */
		}
		else y=scalbn(y,-exp);
		return(scalbn(sqrt(x*x+y*y),exp));
	    }

	    else if(isinf(y))		/* y is +-INF */
		     return(copysign(y,one));
	    else
		     return(y);		/* y is NaN and x is finite */

	else if(isinf(x))		/* x is +-INF */
	         return (copysign(x,one));
	else if(finite(y))
	         return(x);		/* x is NaN, y is finite */
	else if(isnan(y)) return(y);	/* x and y is NaN */
	else return(copysign(y,one));	/* y is INF */
a25 1
#endif
@


1.10
log
@properly raise inexact;  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_cabs.c,v 1.9 2008/06/25 17:49:31 martynas Exp $	*/
a177 6
}

double
z_abs(struct complex *z)
{
	return hypot(z->x,z->y);
@


1.9
log
@- expressions such as x != x and x == x are prone to errors and
ugly, when we have isnan and isinf
- no need to check for _IEEE, when checking for not-a-number
- remove some impossible checks
- while here, drem->remainder, as drem is just an obsolete alias
now
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_cabs.c,v 1.8 2008/06/21 08:26:19 martynas Exp $	*/
d125 4
a128 3
		if(exp-(int)logb(y) > ibig )
			/* raise inexact flag and return |x| */
		   { one+small; return(x); }
d208 4
a211 3
		if(exp-(int)logb(y) > ibig )
			/* raise inexact flag and return |x| */
		   { one+small; return(scalbn(x,exp)); }
@


1.8
log
@cleaning up, no functional changes
- no support for National 32000, removing ns32000/national ifdefs maze
- remove tahoe defs
- ansify
looks fine to millert@@;  who also noticed rint removal
@
text
@d1 1
a1 1
/*	$OpenBSD: n_cabs.c,v 1.7 2008/06/12 22:43:36 martynas Exp $	*/
d144 1
a144 1
	    else if(y==y)   	   /* y is +-INF */
d147 1
a147 1
		     return(y);	   /* y is NaN and x is finite */
d149 1
a149 1
	else if(x==x) 		   /* x is +-INF */
d152 1
a152 1
	         return(x);		   /* x is NaN, y is finite */
d155 1
a155 1
	else return(copysign(y,one));   /* y is INF */
d214 1
a214 1
	    else if(y==y)   	   /* y is +-INF */
d217 1
a217 1
		     return(y);	   /* y is NaN and x is finite */
d219 1
a219 1
	else if(x==x) 		   /* x is +-INF */
d222 3
a224 3
	         return(x);		   /* x is NaN, y is finite */
	else if(y!=y) return(y);  	/* x and y is NaN */
	else return(copysign(y,one));   /* y is INF */
@


1.7
log
@spacing, add rcs ids, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 1
a107 2
hypot(x,y)
double x, y;
d174 1
a174 2
cabs(z)
struct complex z;
d180 1
a180 2
z_abs(z)
struct complex *z;
d187 2
a188 2
double hypot(x,y)
double x, y;
@


1.6
log
@some cleanup for noieee_src, as asked by millert@@: remove fictional
includes, include math.h where needed and remove redundant declarations
ok millert@@
@
text
@d1 2
a2 1
/*      $NetBSD: n_cabs.c,v 1.1 1995/10/10 23:36:39 ragge Exp $ */
d39 1
a39 1
 * CODED IN C BY K.C. NG, 11/28/84; 
d53 1
a53 1
 *		
d59 1
a59 1
 *	   Case II, x/y <= 2 
d62 1
a62 1
 *				          		     2 
d110 1
a110 1
	static const double zero=0, one=1, 
d118 1
a118 1
	    {	
d121 1
a121 1
		if(y > x) 
d126 1
a126 1
		if(exp-(int)logb(y) > ibig ) 	
d147 1
a147 1
	    else 
d201 1
a201 1
	    {	
d204 1
a204 1
		if(y > x) 
d210 1
a210 1
		if(exp-(int)logb(y) > ibig ) 
d219 1
a219 1
	    else 
@


1.5
log
@- no need for ifdef dance (21), we have isnan, finite for vax
- TEST_FMOD doesn't belong here, remove
- remove ifdef _ANSI_SOURCE and assume it's default
ok millert@@
@
text
@d87 2
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d151 2
a152 3
#if !defined(__vax__)&&!defined(tahoe)
	else if(y!=y) return(y);  /* x and y is NaN */
#endif	/* !defined(__vax__)&&!defined(tahoe) */
@


1.3
log
@scalb() in vax libm is in fact scalbn(), so change the symbol name.
Only affects vax, which has no shared libraries, so no version change
needed for libm.
Someone with enough math skills ought to code a real scalb() on a rainy day...
@
text
@d14 1
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@^vax^__vax__
@
text
@d48 1
a48 1
 *	scalb(x,N)
d211 1
a211 1
		x=scalb(x,-exp);
d214 3
a216 3
		   { one+small; return(scalb(x,exp)); }
		else y=scalb(y,-exp);
		return(scalb(sqrt(x*x+y*y),exp));
@


1.1
log
@Initial revision
@
text
@d155 1
a155 1
#if !defined(vax)&&!defined(tahoe)
d157 1
a157 1
#endif	/* !defined(vax)&&!defined(tahoe) */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
