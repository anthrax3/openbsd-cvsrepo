head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.23.0.14
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.10
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.12
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.4
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.8
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.6
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.5.0.4
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.10
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.09.12.19.47.02;	author guenther;	state Exp;
branches;
next	1.24;
commitid	Lp8bnB2xK76nGFvJ;

1.24
date	2016.09.12.04.39.47;	author guenther;	state Exp;
branches;
next	1.23;
commitid	yu8HfTXRTrrv8b2W;

1.23
date	2013.07.15.04.08.26;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.28.18.09.38;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2013.01.13.03.44.59;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2012.12.05.23.20.03;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.30.18.34.38;	author martynas;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.29;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.10.01.08.24;	author martynas;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.09.20.00.35;	author martynas;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.24.09.40.16;	author martynas;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.18.13.08.58;	author martynas;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.17.15.36.28;	author martynas;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.16.15.25.51;	author martynas;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.25.17.49.31;	author martynas;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.21.08.26.19;	author martynas;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.16.21.10.30;	author martynas;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.12.22.43.36;	author martynas;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.12.22.20.56;	author martynas;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.11.14.50.06;	author martynas;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.31.22.16.18;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.20.18.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.11.12.41.13;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2000.10.10.12.17.47;	author hugh;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Reduce libm's exports and make internal calls go direct.
All dependencies on libc are now via reserved/standardized names.

ok kettenis@@ millert@@ deraadt@@
@
text
@/*	$OpenBSD: n_support.c,v 1.24 2016/09/12 04:39:47 guenther Exp $	*/
/*	$NetBSD: n_support.c,v 1.1 1995/10/10 23:37:06 ragge Exp $	*/
/*
 * Copyright (c) 1985, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Some IEEE standard 754 recommended functions and remainder and sqrt for
 * supporting the C elementary functions.
 ******************************************************************************
 * WARNING:
 *      These codes are developed (in double) to support the C elementary
 * functions temporarily. They are not universal, and some of them are very
 * slow (in particular, remainder and sqrt is extremely inefficient). Each
 * computer system should have its implementation of these functions using
 * its own assembler.
 ******************************************************************************
 *
 * IEEE 754 required operations:
 *     remainder(x,p)
 *              returns  x REM y  =  x - [x/y]*y , where [x/y] is the integer
 *              nearest x/y; in half way case, choose the even one.
 *     sqrt(x)
 *              returns the square root of x correctly rounded according to
 *		the rounding mod.
 *
 * IEEE 754 recommended functions:
 * (a) copysign(x,y)
 *              returns x with the sign of y.
 * (b) scalbn(x,N)
 *              returns  x * (2**N), for integer values N.
 * (c) logb(x)
 *              returns the unbiased exponent of x, a signed integer in
 *              double precision, except that logb(0) is -INF, logb(INF)
 *              is +INF, and logb(NAN) is that NAN.
 *
 *
 * CODED IN C BY K.C. NG, 11/25/84;
 * REVISED BY K.C. NG on 1/22/85, 2/13/85, 3/24/85.
 */

#include <math.h>

#include "mathimpl.h"

#if defined(__vax__)      /* VAX D format */
#include <errno.h>
    static const unsigned short msign=0x7fff, mexp =0x7f80 ;
    static const short  prep1=57, gap=7, bias=129           ;
    static const double novf=1.7E38, nunf=3.0E-39;
#else	/* defined(__vax__) */
    static const unsigned short msign=0x7fff, mexp =0x7ff0  ;
    static const short prep1=54, gap=4, bias=1023           ;
    static const double novf=1.7E308, nunf=3.0E-308;
#endif	/* defined(__vax__) */

static const double zero = 0.0;

double
scalbn(double x, int N)
{
        int k;
        unsigned short *px=(unsigned short *) &x;

        if( x == zero )  return(x);

#if defined(__vax__)
        if( (k= *px & mexp ) != ~msign ) {
            if (N < -260)
		return(nunf*nunf);
	    else if (N > 260) {
		return(copysign(infnan(ERANGE),x));
	    }
#else	/* defined(__vax__) */
        if( (k= *px & mexp ) != mexp ) {
            if( N<-2100) return(nunf*nunf); else if(N>2100) return(novf+novf);
            if( k == 0 ) {
                 x *= scalbn(1.0,(int)prep1);  N -= prep1; return(scalbn(x,N));}
#endif	/* defined(__vax__) */

            if((k = (k>>gap)+ N) > 0 )
                if( k < (mexp>>gap) ) *px = (*px&~mexp) | (k<<gap);
                else x=novf+novf;               /* overflow */
            else
                if( k > -prep1 )
                                        /* gradual underflow */
                    {*px=(*px&~mexp)|(short)(1<<gap); x *= scalbn(1.0,k-1);}
                else
                return(nunf*nunf);
            }
        return(x);
}
DEF_STD(scalbn);
LDBL_CLONE(scalbn);

double
copysign(double x, double y)
{
        unsigned short  *px=(unsigned short *) &x,
                        *py=(unsigned short *) &y;

#if defined(__vax__)
        if ( (*px & mexp) == 0 ) return(x);
#endif	/* defined(__vax__) */

        *px = ( *px & msign ) | ( *py & ~msign );
        return(x);
}
DEF_STD(copysign);
LDBL_CLONE(copysign);

double
logb(double x)
{

        short *px=(short *) &x, k;

#if defined(__vax__)
        return (int)(((*px&mexp)>>gap)-bias);
#else	/* defined(__vax__) */
        if( (k= *px & mexp ) != mexp )
            if ( k != 0 )
                return ( (k>>gap) - bias );
            else if( x != zero)
                return ( -1022.0 );
            else
                return(-(1.0/zero));
        else if(isnan(x))
            return(x);
        else
            {*px &= msign; return(x);}
#endif	/* defined(__vax__) */
}
DEF_STD(logb);
LDBL_UNUSED_CLONE(logb);

double
remainder(double x, double p)
{
        short sign;
        double hp, dp, tmp;
        unsigned short k;
        unsigned short
              *px=(unsigned short *) &x  ,
              *pp=(unsigned short *) &p  ,
              *pd=(unsigned short *) &dp ,
              *pt=(unsigned short *) &tmp;

        *pp &= msign ;

#if defined(__vax__)
        if( ( *px & mexp ) == ~msign )	/* is x a reserved operand? */
#else	/* defined(__vax__) */
        if( ( *px & mexp ) == mexp )
#endif	/* defined(__vax__) */
		return  (x-p)-(x-p);	/* create nan if x is inf */
	if (p == zero) {
#if defined(__vax__)
		return(infnan(EDOM));
#else	/* defined(__vax__) */
		return zero/zero;
#endif	/* defined(__vax__) */
	}

#if defined(__vax__)
        if( ( *pp & mexp ) == ~msign )	/* is p a reserved operand? */
#else	/* defined(__vax__) */
        if( ( *pp & mexp ) == mexp )
#endif	/* defined(__vax__) */
		{ if (p != p) return p; else return x;}

        else  if ( ((*pp & mexp)>>gap) <= 1 )
                /* subnormal p, or almost subnormal p */
            { double b; b=scalbn(1.0,(int)prep1);
              p *= b; x = remainder(x,p); x *= b; return(remainder(x,p)/b);}
        else  if ( p >= novf/2)
            { p /= 2 ; x /= 2; return(remainder(x,p)*2);}
        else
            {
                dp=p+p; hp=p/2;
                sign= *px & ~msign ;
                *px &= msign       ;
                while ( x > dp )
                    {
                        k=(*px & mexp) - (*pd & mexp) ;
                        tmp = dp ;
                        *pt += k ;

#if defined(__vax__)
                        if( x < tmp ) *pt -= 128 ;
#else	/* defined(__vax__) */
                        if( x < tmp ) *pt -= 16 ;
#endif	/* defined(__vax__) */

                        x -= tmp ;
                    }
                if ( x > hp )
                    { x -= p ;  if ( x >= hp ) x -= p ; }

#if defined(__vax__)
		if (x)
#endif	/* defined(__vax__) */
			*px ^= sign;
                return( x);

            }
}
DEF_STD(remainder);

/* The drem() function is a deprecated alias for remainder(). */

double
drem(double x, double p)
{
	return remainder(x, p);
}

float
sqrtf(float x)
{
	return (float)sqrt((double) x);
}
DEF_STD(sqrtf);

double
sqrt(double x)
{
        double q, s, b, r;
        double t;
        int m, n, i;
#if defined(__vax__)
        int k=54;
#else	/* defined(__vax__) */
        int k=51;
#endif	/* defined(__vax__) */

    /* sqrt(NaN) is NaN, sqrt(+-0) = +-0 */
        if(isnan(x) || x == zero) return(x);

    /* sqrt(negative) is invalid */
        if(x<zero) {
#if defined(__vax__)
		return (infnan(EDOM));	/* NaN */
#else	/* defined(__vax__) */
		return(zero/zero);
#endif	/* defined(__vax__) */
	}

    /* sqrt(INF) is INF */
        if(!isfinite(x)) return(x);

    /* scale x to [1,4) */
        n=logb(x);
        x=scalbn(x,-n);
        if((m=logb(x))!=0) x=scalbn(x,-m);       /* subnormal number */
        m += n;
        n = m/2;
        if((n+n)!=m) {x *= 2; m -=1; n=m/2;}

    /* generate sqrt(x) bit by bit (accumulating in q) */
            q=1.0; s=4.0; x -= 1.0; r=1;
            for(i=1;i<=k;i++) {
                t=s+1; x *= 4; r /= 2;
                if(t<=x) {
                    s = t+t+2;
                    x -= t;
                    q += r;
                }
                else
                    s *= 2;
                }

    /* generate the last bit and determine the final rounding */
            r/=2; x *= 4;
            if(x==zero) goto end;
	    if (100+r >= 100) {			/* trigger inexact flag */
            if(s<x) {
                q+=r; x -=s; s += 2; s *= 2; x *= 4;
                t = (x-s)-5;
                b=1.0+3*r/4; if(b==1.0) goto end; /* b==1 : Round-to-zero */
                b=1.0+r/4;   if(b>1.0) t=1;	/* b>1 : Round-to-(+INF) */
                if(t>=0) q+=r; }	      /* else: Round-to-nearest */
            else {
                s *= 2; x *= 4;
                t = (x-s)-1;
                b=1.0+3*r/4; if(b==1.0) goto end;
                b=1.0+r/4;   if(b>1.0) t=1;
                if(t>=0) q+=r; }
	    }

end:        return(scalbn(q,n));
}
DEF_STD(sqrt);
LDBL_CLONE(sqrt);

#if 0
/* REMAINDER(X,Y)
 * RETURN X REM Y =X-N*Y, N=[X/Y] ROUNDED (ROUNDED TO EVEN IN THE HALF WAY CASE)
 * DOUBLE PRECISION (VAX D format 56 bits, IEEE DOUBLE 53 BITS)
 * INTENDED FOR ASSEMBLY LANGUAGE
 * CODED IN C BY K.C. NG, 3/23/85, 4/8/85.
 *
 * Warning: this code should not get compiled in unless ALL of
 * the following machine-dependent routines are supplied.
 *
 * Required machine dependent functions (not on a VAX):
 *     swapINX(i): save inexact flag and reset it to "i"
 *     swapENI(e): save inexact enable and reset it to "e"
 */

double
remainder(double x, double y)
{
	static const n0=0, n1=1, n2=2, n3=3;
    	static const unsigned short mexp =0x7ff0, m25 =0x0190, m57 =0x0390;
	double hy, y1, t, t1;
	short k;
	long n;
	int i, e;
	unsigned short xexp,yexp, *px  =(unsigned short *) &x  ,
	      		nx,nf,	  *py  =(unsigned short *) &y  ,
	      		sign,	  *pt  =(unsigned short *) &t  ,
	      			  *pt1 =(unsigned short *) &t1 ;

	xexp = px[n0] & mexp ;	/* exponent of x */
	yexp = py[n0] & mexp ;	/* exponent of y */
	sign = px[n0] &0x8000;	/* sign of x     */

/* return NaN if x is NaN, or y is NaN, or x is INF, or y is zero */
	if(isnan(x)) return(x); if(isnan(y)) return(y);	/* x or y is NaN */
	if( xexp == mexp )   return(zero/zero);		/* x is INF */
	if(y==zero) return(y/y);

/* save the inexact flag and inexact enable in i and e respectively
 * and reset them to zero
 */
	i=swapINX(0);	e=swapENI(0);

/* subnormal number */
	nx=0;
	if (yexp == 0) {
		t = 1.0;
		pt[n0] += m57;
		y *= t;
		nx = m57;
	}

/* if y is tiny (biased exponent <= 57), scale up y to y*2**57 */
	if( yexp <= m57 ) {py[n0]+=m57; nx+=m57; yexp+=m57;}

	nf=nx;
	py[n0] &= 0x7fff;
	px[n0] &= 0x7fff;

/* mask off the least significant 27 bits of y */
	t=y; pt[n3]=0; pt[n2]&=0xf800; y1=t;

/* LOOP: argument reduction on x whenever x > y */
loop:
	while ( x > y )
	{
	    t=y;
	    t1=y1;
	    xexp=px[n0]&mexp;	  /* exponent of x */
	    k=xexp-yexp-m25;
	    if(k>0) 	/* if x/y >= 2**26, scale up y so that x/y < 2**26 */
		{pt[n0]+=k;pt1[n0]+=k;}
	    n=x/t; x=(x-n*t1)-n*(t-t1);
	}
    /* end while (x > y) */

	if(nx!=0) {t=1.0; pt[n0]+=nx; x*=t; nx=0; goto loop;}

/* final adjustment */

	hy=y/2.0;
	if(x>hy||((x==hy)&&n%2==1)) x-=y;
	px[n0] ^= sign;
	if(nf!=0) { t=1.0; pt[n0]-=nf; x*=t;}

/* restore inexact flag and inexact enable */
	swapINX(i); swapENI(e);

	return(x);
}
DEF_STD(remainder);
#endif

#if 0
/* SQRT
 * RETURN CORRECTLY ROUNDED (ACCORDING TO THE ROUNDING MODE) SQRT
 * FOR IEEE DOUBLE PRECISION ONLY, INTENDED FOR ASSEMBLY LANGUAGE
 * CODED IN C BY K.C. NG, 3/22/85.
 *
 * Warning: this code should not get compiled in unless ALL of
 * the following machine-dependent routines are supplied.
 *
 * Required machine dependent functions:
 *     swapINX(i)  ...return the status of INEXACT flag and reset it to "i"
 *     swapRM(r)   ...return the current Rounding Mode and reset it to "r"
 *     swapENI(e)  ...return the status of inexact enable and reset it to "e"
 *     addc(t)     ...perform t=t+1 regarding t as a 64 bit unsigned integer
 *     subc(t)     ...perform t=t-1 regarding t as a 64 bit unsigned integer
 */

static const unsigned long table[] = {
0, 1204, 3062, 5746, 9193, 13348, 18162, 23592, 29598, 36145, 43202, 50740,
58733, 67158, 75992, 85215, 83599, 71378, 60428, 50647, 41945, 34246, 27478,
21581, 16499, 12183, 8588, 5674, 3403, 1742, 661, 130, };

double
newsqrt(double x)
{
        double y, z, t, addc(), subc();
	double const b54=134217728.*134217728.; /* b54=2**54 */
        long mx, scalx;
	long const mexp=0x7ff00000;
        int i, j, r, e, swapINX(), swapRM(), swapENI();
        unsigned long *py=(unsigned long *) &y   ,
                      *pt=(unsigned long *) &t   ,
                      *px=(unsigned long *) &x   ;
        const int n0=0, n1=1;
/* Rounding Mode:  RN ...round-to-nearest
 *                 RZ ...round-towards 0
 *                 RP ...round-towards +INF
 *		   RM ...round-towards -INF
 */
        const int RN=0, RZ=1, RP=2, RM=3;
				/* machine dependent: work on a Zilog Z8070
                                 * and a National 32081 & 16081
                                 */

/* exceptions */
	if(isnan(x) || x == 0.0) return(x);	/* sqrt(NaN) is NaN,
						   sqrt(+-0) = +-0 */
	if(x<0) return((x-x)/(x-x)); /* sqrt(negative) is invalid */
        if((mx=px[n0]&mexp)==mexp) return(x);  /* sqrt(+INF) is +INF */

/* save, reset, initialize */
        e=swapENI(0);   /* ...save and reset the inexact enable */
        i=swapINX(0);   /* ...save INEXACT flag */
        r=swapRM(RN);   /* ...save and reset the Rounding Mode to RN */
        scalx=0;

/* subnormal number, scale up x to x*2**54 */
        if(mx==0) {x *= b54 ; scalx-=0x01b00000;}

/* scale x to avoid intermediate over/underflow:
 * if (x > 2**512) x=x/2**512; if (x < 2**-512) x=x*2**512 */
        if(mx>0x5ff00000) {px[n0] -= 0x20000000; scalx+= 0x10000000;}
        if(mx<0x1ff00000) {px[n0] += 0x20000000; scalx-= 0x10000000;}

/* magic initial approximation to almost 8 sig. bits */
        py[n0]=(px[n0]>>1)+0x1ff80000;
        py[n0]=py[n0]-table[(py[n0]>>15)&31];

/* Heron's rule once with correction to improve y to almost 18 sig. bits */
        t=x/y; y=y+t; py[n0]=py[n0]-0x00100006; py[n1]=0;

/* triple to almost 56 sig. bits; now y approx. sqrt(x) to within 1 ulp */
        t=y*y; z=t;  pt[n0]+=0x00100000; t+=z; z=(x-z)*y;
        t=z/(t+x) ;  pt[n0]+=0x00100000; y+=t;

/* twiddle last bit to force y correctly rounded */
        swapRM(RZ);     /* ...set Rounding Mode to round-toward-zero */
        swapINX(0);     /* ...clear INEXACT flag */
        swapENI(e);     /* ...restore inexact enable status */
        t=x/y;          /* ...chopped quotient, possibly inexact */
        j=swapINX(i);   /* ...read and restore inexact flag */
        if(j==0) { if(t==y) goto end; else t=subc(t); }  /* ...t=t-ulp */
        x=b54+0.1;      /* ..trigger inexact flag, sqrt(x) is inexact */
        if(r==RN) t=addc(t);            /* ...t=t+ulp */
        else if(r==RP) { t=addc(t);y=addc(y);}/* ...t=t+ulp;y=y+ulp; */
        y=y+t;                          /* ...chopped sum */
        py[n0]=py[n0]-0x00100000;       /* ...correctly rounded sqrt(x) */
end:    py[n0]=py[n0]+scalx;            /* ...scale back y */
        swapRM(r);                      /* ...restore Rounding Mode */
        return(y);
}
#endif
@


1.24
log
@Per fpclassify(3): isinff(), isnanf(), finite(), and finitef() are deprecated
in favor of isinf(), isnan(), and isfinite().

ok tb@@ martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.23 2013/07/15 04:08:26 espie Exp $	*/
d118 2
a119 2

__strong_alias(scalbnl, scalbn);
d134 2
a135 2

__strong_alias(copysignl, copysign);
d159 2
a160 2

__strong_alias(logbl, logb);
d233 1
d248 1
d318 2
a319 2

__strong_alias(sqrtl, sqrt);
d411 1
@


1.23
log
@bring reference C code that's not compiled in synch with asm code
okay martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.22 2013/03/28 18:09:38 martynas Exp $	*/
d273 1
a273 1
        if(!finite(x)) return(x);
@


1.22
log
@Switch libc and libm to use strong aliases rather than weak aliases
where appropriate.  Among other things makes the symbols consistent
across all architectures (notably where ldbl mantissa is 53 bits).

While at it, kill unused LINTLIBRARY/PROTOLIB1 cruft which was there
to trick lint into recording the right prototypes for aliased
functions.  Most of the work done at the awesome n2k13 hackathon.

Agreed by kettenis@@, guenther@@, matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.21 2013/01/13 03:44:59 martynas Exp $	*/
d240 6
@


1.21
log
@Get rid of the very ugly lint workarounds: LINTLIBRARY, PROTOLIB,
and a few empty files for lint to chew on.
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.20 2012/12/05 23:20:03 deraadt Exp $	*/
d119 1
a119 1
__weak_alias(scalbnl, scalbn);
d135 1
a135 1
__weak_alias(copysignl, copysign);
d160 1
a160 1
__weak_alias(logbl, logb);
d311 1
a311 1
__weak_alias(sqrtl, sqrt);
@


1.20
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.19 2011/05/30 18:34:38 martynas Exp $	*/
a66 2
/* LINTLIBRARY */

a118 5
#ifdef	lint
/* PROTOLIB1 */
long double scalbnl(long double, int);
/* PROTOLIB0 */
#else	/* lint */
a119 1
#endif	/* lint */
a134 5
#ifdef	lint
/* PROTOLIB1 */
long double copysignl(long double, long double);
/* PROTOLIB0 */
#else	/* lint */
a135 1
#endif	/* lint */
a159 5
#ifdef	lint
/* PROTOLIB1 */
long double logbl(long double);
/* PROTOLIB0 */
#else	/* lint */
a160 1
#endif	/* lint */
a310 5
#ifdef	lint
/* PROTOLIB1 */
long double sqrtl(long double);
/* PROTOLIB0 */
#else	/* lint */
a311 1
#endif	/* lint */
@


1.19
log
@Trick lint into recording the right prototypes in the llib-lm.ln
database on platforms without extended-precision floating-point
support.

Seems like a reasonable approach to millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.18 2009/10/27 23:59:29 deraadt Exp $	*/
a68 1
#include <sys/cdefs.h>
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.17 2008/12/10 01:08:24 martynas Exp $	*/
d67 2
d122 5
a126 1
#ifdef __weak_alias    
d128 1
a128 1
#endif /* __weak_alias */
d144 5
a148 1
#ifdef __weak_alias    
d150 1
a150 1
#endif /* __weak_alias */
d175 5
a179 1
#ifdef __weak_alias    
d181 1
a181 1
#endif /* __weak_alias */
d332 5
a336 1
#ifdef __weak_alias    
d338 1
a338 1
#endif /* __weak_alias */
@


1.17
log
@use sys/cdefs.h;  pointed out by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.16 2008/12/09 20:00:35 martynas Exp $	*/
a30 4

#ifndef lint
static char sccsid[] = "@@(#)support.c	8.1 (Berkeley) 6/4/93";
#endif /* not lint */
@


1.16
log
@- 80-bit and quad precision trigonometric and other most
important functions: acosl, asinl, atanl, atan2l, cosl,
sinl, tanl, exp2l, frexpl, ilogbl, ldexpl, logbl, scalbnl,
fabsl, hypotl, powl, sqrtl, rintl, copysignl, nanl, fdiml,
fmaxl, fminl.  mostly taken from freebsd, needed alot of
changes to adapt.  note, these are all c versions;  and are
quite slow when architectures have, e.g. sqrt.  assembly
versions will be added afterwards
- make them .weak/__weak_alias to the double precision
versions on other archs
- no need to have two finites.  finite() and finitef() are
non-standard 3BSD obsolete versions of isfinite.  remove
from libm.  make them weak_alias in libc to __isfinite and
__isfinitef instead.  similarly make 3BSD obsolete versions
of isinf, isinff, isnan, isnanf weak_aliases to C99's
__isinf, __isinff, __isnan, __isnanf
- remove unused infinity.c.  the c library has infinities
for each supported platform
- use STRICT_ASSIGN cast hack for _kernel_rem_pio2, so that
the double version has a chance of working on i386 with
extra precision
- avoid storing multiple copies of the pi/2 array, since
it won't vary
- bump major due to removed finite/finitef.  although they
will be in libc, which anything is linked to, minor bump
might be enough
ok millert@@.   tested by sthen@@, jsg@@, ajacoutot@@, kili@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.15 2008/07/24 09:40:16 martynas Exp $	*/
d71 1
a71 1
#include <machine/cdefs.h>
@


1.15
log
@- remove isinff, isnanf.  this has been moved to libc
- remove never-enabled signbit.  libc has is now
- add C99 implementations, from freebsd, for nan(), nanf() (needed
to write _digittoint for it), exp2(), exp2f(), remquo(), remquof(),
needed STRICT_ASSIGN macro for math_private.h
- bump major
man pages will follow
exp2{,f} has been requested by chl@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.14 2008/07/18 13:08:58 martynas Exp $	*/
a64 3
 * (d) finite(x)
 *              returns the value TRUE if -INF < x < +INF and returns
 *              FALSE otherwise.
d71 3
a73 1
#include "math.h"
d124 3
d142 4
d169 3
a171 9
int
finite(double x)
{
#if defined(__vax__)
        return(1);
#else	/* defined(__vax__) */
        return( (*((short *) &x ) & mexp ) != mexp );
#endif	/* defined(__vax__) */
}
d321 4
@


1.14
log
@fix cases, found by lint:
- actually raise inexacts for expm1, and support
- __exp__E always returns, because inexact check always succeeds.
add NOTREACHED
- some cases in lgamma FALLTHROUGH, as intended
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.13 2008/07/17 15:36:28 martynas Exp $	*/
a137 24
}

int
__signbitf(float x)
{
	unsigned short *px = (unsigned short *)&x;

	return (*px & ~msign);
}

int
__signbit(double x)
{
	unsigned short *px = (unsigned short *)&x;

	return (*px & ~msign);
}

int
__signbitl(long double x)
{
	unsigned short *px = (unsigned short *)&x;

	return (*px & ~msign);
@


1.13
log
@properly raise inexact;  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.12 2008/07/16 15:25:51 martynas Exp $	*/
d327 2
a328 1
            if(x==zero) goto end; 100+r; /* trigger inexact flag */
d341 1
@


1.12
log
@some archaic 'n = a(b), c(d)' use that confused lint
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.11 2008/06/25 17:49:31 martynas Exp $	*/
d518 1
a518 1
        b54+0.1;        /* ..trigger inexact flag, sqrt(x) is inexact */
@


1.11
log
@- expressions such as x != x and x == x are prone to errors and
ugly, when we have isnan and isinf
- no need to check for _IEEE, when checking for not-a-number
- remove some impossible checks
- while here, drem->remainder, as drem is just an obsolete alias
now
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.10 2008/06/21 08:26:19 martynas Exp $	*/
d317 4
a320 1
                    s=t+t+2, x -= t; q += r;}
d389 6
a394 1
	if(yexp==0) {t=1.0,pt[n0]+=m57; y*=t; nx=m57;}
@


1.10
log
@cleaning up, no functional changes
- no support for National 32000, removing ns32000/national ifdefs maze
- remove tahoe defs
- ansify
looks fine to millert@@;  who also noticed rint removal
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.9 2008/06/16 21:10:30 martynas Exp $	*/
d180 1
a180 1
        else if(x != x)
d290 1
a290 1
        if(x!=x||x==zero) return(x);
d375 2
a376 2
	if(x!=x) return(x); if(y!=y) return(y);	     /* x or y is NaN */
	if( xexp == mexp )   return(zero/zero);      /* x is INF */
d473 2
a474 1
	if(x!=x||x==0.0) return(x);  /* sqrt(NaN) is NaN, sqrt(+-0) = +-0 */
@


1.9
log
@fix some errors found by lint, e.g. declaration w/o types, make
zero const.  also do the same fix as was found for ieee's trunc by
lint;  ok millert@@.  tested on VAX
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.c,v 1.8 2008/06/12 22:43:36 martynas Exp $	*/
d77 1
a77 1
#if defined(__vax__)||defined(tahoe)      /* VAX D format */
d82 1
a82 1
#else	/* defined(__vax__)||defined(tahoe) */
d86 1
a86 1
#endif	/* defined(__vax__)||defined(tahoe) */
a93 4

#ifdef national
        unsigned short *px=(unsigned short *) &x + 3;
#else	/* national */
a94 1
#endif	/* national */
d98 1
a98 1
#if defined(__vax__)||defined(tahoe)
d105 1
a105 1
#else	/* defined(__vax__)||defined(tahoe) */
d110 1
a110 1
#endif	/* defined(__vax__)||defined(tahoe) */
a128 4
#ifdef national
        unsigned short  *px=(unsigned short *) &x+3,
                        *py=(unsigned short *) &y+3;
#else	/* national */
a130 1
#endif	/* national */
d132 1
a132 1
#if defined(__vax__)||defined(tahoe)
d134 1
a134 1
#endif	/* defined(__vax__)||defined(tahoe) */
a167 3
#ifdef national
        short *px=(short *) &x+3, k;
#else	/* national */
a168 1
#endif	/* national */
d170 1
a170 1
#if defined(__vax__)||defined(tahoe)
d172 1
a172 1
#else	/* defined(__vax__)||defined(tahoe) */
d184 1
a184 1
#endif	/* defined(__vax__)||defined(tahoe) */
d190 1
a190 1
#if defined(__vax__)||defined(tahoe)
d192 1
a192 4
#else	/* defined(__vax__)||defined(tahoe) */
#ifdef national
        return( (*((short *) &x+3 ) & mexp ) != mexp );
#else	/* national */
d194 1
a194 2
#endif	/* national */
#endif	/* defined(__vax__)||defined(tahoe) */
a202 7
#ifdef national
        unsigned short
              *px=(unsigned short *) &x  +3,
              *pp=(unsigned short *) &p  +3,
              *pd=(unsigned short *) &dp +3,
              *pt=(unsigned short *) &tmp+3;
#else	/* national */
a207 1
#endif	/* national */
d211 1
a211 1
#if defined(__vax__)||defined(tahoe)
d213 1
a213 1
#else	/* defined(__vax__)||defined(tahoe) */
d215 1
a215 1
#endif	/* defined(__vax__)||defined(tahoe) */
d218 1
a218 1
#if defined(__vax__)||defined(tahoe)
d220 1
a220 1
#else	/* defined(__vax__)||defined(tahoe) */
d222 1
a222 1
#endif	/* defined(__vax__)||defined(tahoe) */
d225 1
a225 1
#if defined(__vax__)||defined(tahoe)
d227 1
a227 1
#else	/* defined(__vax__)||defined(tahoe) */
d229 1
a229 1
#endif	/* defined(__vax__)||defined(tahoe) */
d249 1
a249 1
#if defined(__vax__)||defined(tahoe)
d251 1
a251 1
#else	/* defined(__vax__)||defined(tahoe) */
d253 1
a253 1
#endif	/* defined(__vax__)||defined(tahoe) */
d260 1
a260 1
#if defined(__vax__)||defined(tahoe)
d262 1
a262 1
#endif	/* defined(__vax__)||defined(tahoe) */
d283 1
a283 1
#if defined(__vax__)||defined(tahoe)
d285 1
a285 1
#else	/* defined(__vax__)||defined(tahoe) */
d287 1
a287 1
#endif	/* defined(__vax__)||defined(tahoe) */
d294 1
a294 1
#if defined(__vax__)||defined(tahoe)
d296 1
a296 1
#else	/* defined(__vax__)||defined(tahoe) */
d298 1
a298 1
#endif	/* defined(__vax__)||defined(tahoe) */
a358 4

#ifdef national		/* order of words in floating point number */
	static const n0=3, n1=2, n2=1, n3=0;
#else /* VAX, SUN, ZILOG, TAHOE */
a359 2
#endif

a460 3
#ifdef national         /* ordering of word in a floating point number */
        const int n0=1, n1=0;
#else
a461 1
#endif
@


1.8
log
@spacing, add rcs ids, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 1
a81 1
    static const double novf=1.7E38, nunf=3.0E-39, zero=0.0 ;
d85 1
a85 1
    static const double novf=1.7E308, nunf=3.0E-308,zero=0.0;
d88 2
a307 1
	double const zero=0.0;
a392 1
	static const double zero=0.0;
@


1.7
log
@some cleanup for noieee_src, as asked by millert@@: remove fictional
includes, include math.h where needed and remove redundant declarations
ok millert@@
@
text
@d1 2
a2 1
/*      $NetBSD: n_support.c,v 1.1 1995/10/10 23:37:06 ragge Exp $ */
@


1.6
log
@drem{,f} are aliases for remainder{,f}, so:
- document and mlink drem{,f}
- drem->remainder on noieee, and make drem an alias
- finite returns integer, n_support.c
- general n_support.c ansification and cleanup
- drem is now an ALTENTRY for remainder, in n_support.S
help with man page from jmc@@ and millert@@
ok millert@@
@
text
@d73 1
@


1.5
log
@add __signbit/__signbitf/__signbitl; nothing uses this file, it's just
for completeness.
@
text
@d35 2
a36 2
/* 
 * Some IEEE standard 754 recommended functions and remainder and sqrt for 
d42 2
a43 2
 * slow (in particular, drem and sqrt is extremely inefficient). Each 
 * computer system should have its implementation of these functions using 
d48 1
a48 1
 *     drem(x,p) 
d51 2
a52 2
 *     sqrt(x) 
 *              returns the square root of x correctly rounded according to 
d56 3
a58 3
 * (a) copysign(x,y) 
 *              returns x with the sign of y. 
 * (b) scalbn(x,N) 
d60 3
a62 3
 * (c) logb(x) 
 *              returns the unbiased exponent of x, a signed integer in 
 *              double precision, except that logb(0) is -INF, logb(INF) 
d64 2
a65 2
 * (d) finite(x) 
 *              returns the value TRUE if -INF < x < +INF and returns 
d77 2
a78 2
    static const unsigned short msign=0x7fff , mexp =0x7f80 ;
    static const short  prep1=57, gap=7, bias=129           ;   
d86 2
a87 2
double scalbn(x,N)
double x; int N;
d97 1
a97 1
        if( x == zero )  return(x); 
d117 1
a117 1
                if( k > -prep1 ) 
d127 2
a128 2
double copysign(x,y)
double x,y;
d170 2
a171 2
double logb(x)
double x; 
d188 2
a189 2
            else        
                return(-(1.0/zero));    
d197 2
a198 2
finite(x)
double x;    
d211 2
a212 2
double drem(x,p)
double x,p;
d215 2
a216 2
        double hp,dp,tmp;
        unsigned short  k; 
d219 1
a219 1
              *px=(unsigned short *) &x  +3, 
d225 1
a225 1
              *px=(unsigned short *) &x  , 
d254 1
a254 1
        else  if ( ((*pp & mexp)>>gap) <= 1 ) 
d257 1
a257 1
              p *= b; x = drem(x,p); x *= b; return(drem(x,p)/b);}
d259 2
a260 2
            { p /= 2 ; x /= 2; return(drem(x,p)*2);}
        else 
d291 7
d299 2
a300 2
double sqrt(x)
double x;
d302 1
a302 1
        double q,s,b,r;
d305 1
a305 1
        int m,n,i;
d325 1
a325 1
        if(!finite(x)) return(x);               
d331 1
a331 1
        m += n; 
d344 1
a344 1
            
d346 1
a346 1
            r/=2; x *= 4; 
d350 1
a350 1
                t = (x-s)-5; 
d354 3
a356 3
            else { 
                s *= 2; x *= 4; 
                t = (x-s)-1; 
d360 1
a360 1
            
d365 1
a365 1
/* DREM(X,Y)
d373 1
a373 1
 * 
d379 2
a380 2
double drem(x,y)	
double x,y;
d384 1
a384 1
	static const n0=3,n1=2,n2=1,n3=0;
d386 1
a386 1
	static const n0=0,n1=1,n2=2,n3=3;
d391 1
a391 1
	double hy,y1,t,t1;
d394 2
a395 2
	int i,e; 
	unsigned short xexp,yexp, *px  =(unsigned short *) &x  , 
d412 1
a412 1
	i=swapINX(0);	e=swapENI(0);	
d422 1
a422 1
	py[n0] &= 0x7fff;	
d439 1
a439 1
	}	
d447 1
a447 1
	if(x>hy||((x==hy)&&n%2==1)) x-=y; 
d452 1
a452 1
	swapINX(i); swapENI(e);	
d454 1
a454 1
	return(x);	
d466 1
a466 1
 * 
d480 2
a481 2
double newsqrt(x)
double x;
d483 1
a483 1
        double y,z,t,addc(),subc()
d485 1
a485 1
        long mx,scalx;
d487 1
a487 1
        int i,j,r,e,swapINX(),swapRM(),swapENI();       
d492 1
a492 1
        const int n0=1, n1=0; 
d494 1
a494 1
        const int n0=0, n1=1; 
d496 1
a496 1
/* Rounding Mode:  RN ...round-to-nearest 
d501 1
a501 1
        const int RN=0,RZ=1,RP=2,RM=3;
d533 1
a533 1
        t=y*y; z=t;  pt[n0]+=0x00100000; t+=z; z=(x-z)*y; 
d536 1
a536 1
/* twiddle last bit to force y correctly rounded */ 
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d146 24
@


1.3
log
@scalb() in vax libm is in fact scalbn(), so change the symbol name.
Only affects vax, which has no shared libraries, so no version change
needed for libm.
Someone with enough math skills ought to code a real scalb() on a rainy day...
@
text
@d14 1
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@^vax^__vax__
@
text
@d62 1
a62 1
 * (b) scalb(x,N) 
d90 1
a90 1
double scalb(x,N)
d114 1
a114 1
                 x *= scalb(1.0,(int)prep1);  N -= prep1; return(scalb(x,N));}
d123 1
a123 1
                    {*px=(*px&~mexp)|(short)(1<<gap); x *= scalb(1.0,k-1);}
d236 1
a236 1
            { double b; b=scalb(1.0,(int)prep1);
d302 2
a303 2
        x=scalb(x,-n);
        if((m=logb(x))!=0) x=scalb(x,-m);       /* subnormal number */
d334 1
a334 1
end:        return(scalb(q,n));
@


1.1
log
@Initial revision
@
text
@d79 1
a79 1
#if defined(vax)||defined(tahoe)      /* VAX D format */
d84 1
a84 1
#else	/* defined(vax)||defined(tahoe) */
d88 1
a88 1
#endif	/* defined(vax)||defined(tahoe) */
d103 1
a103 1
#if defined(vax)||defined(tahoe)
d110 1
a110 1
#else	/* defined(vax)||defined(tahoe) */
d115 1
a115 1
#endif	/* defined(vax)||defined(tahoe) */
d142 1
a142 1
#if defined(vax)||defined(tahoe)
d144 1
a144 1
#endif	/* defined(vax)||defined(tahoe) */
d160 1
a160 1
#if defined(vax)||defined(tahoe)
d162 1
a162 1
#else	/* defined(vax)||defined(tahoe) */
d174 1
a174 1
#endif	/* defined(vax)||defined(tahoe) */
d180 1
a180 1
#if defined(vax)||defined(tahoe)
d182 1
a182 1
#else	/* defined(vax)||defined(tahoe) */
d188 1
a188 1
#endif	/* defined(vax)||defined(tahoe) */
d213 1
a213 1
#if defined(vax)||defined(tahoe)
d215 1
a215 1
#else	/* defined(vax)||defined(tahoe) */
d217 1
a217 1
#endif	/* defined(vax)||defined(tahoe) */
d220 1
a220 1
#if defined(vax)||defined(tahoe)
d222 1
a222 1
#else	/* defined(vax)||defined(tahoe) */
d224 1
a224 1
#endif	/* defined(vax)||defined(tahoe) */
d227 1
a227 1
#if defined(vax)||defined(tahoe)
d229 1
a229 1
#else	/* defined(vax)||defined(tahoe) */
d231 1
a231 1
#endif	/* defined(vax)||defined(tahoe) */
d251 1
a251 1
#if defined(vax)||defined(tahoe)
d253 1
a253 1
#else	/* defined(vax)||defined(tahoe) */
d255 1
a255 1
#endif	/* defined(vax)||defined(tahoe) */
d262 1
a262 1
#if defined(vax)||defined(tahoe)
d264 1
a264 1
#endif	/* defined(vax)||defined(tahoe) */
d279 1
a279 1
#if defined(vax)||defined(tahoe)
d281 1
a281 1
#else	/* defined(vax)||defined(tahoe) */
d283 1
a283 1
#endif	/* defined(vax)||defined(tahoe) */
d290 1
a290 1
#if defined(vax)||defined(tahoe)
d292 1
a292 1
#else	/* defined(vax)||defined(tahoe) */
d294 1
a294 1
#endif	/* defined(vax)||defined(tahoe) */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
