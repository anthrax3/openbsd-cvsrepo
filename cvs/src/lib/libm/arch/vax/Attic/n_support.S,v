head	1.20;
access;
symbols
	OPENBSD_5_9:1.19.0.8
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.10
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.16.0.18
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.16
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.14
	OPENBSD_5_0:1.16.0.12
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.10
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.8
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.6.0.4
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.6
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.4
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.2
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.1.1.1.0.26
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.24
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.22
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.20
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.20
date	2016.03.10.05.21.05;	author deraadt;	state dead;
branches;
next	1.19;
commitid	K03oHi07npnVMEbw;

1.19
date	2013.08.06.19.02.14;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2013.07.05.21.10.50;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.28.18.09.38;	author martynas;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.12.19.30.17;	author martynas;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.09.20.21.07;	author martynas;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.09.20.00.35;	author martynas;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.20.23.21.37;	author martynas;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.24.09.40.16;	author martynas;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.21.08.26.19;	author martynas;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.12.18.06.10;	author martynas;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.12.16.11.36;	author martynas;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.11.14.50.06;	author martynas;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.21.20.37.10;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.31.22.10.52;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.23.23.48.41;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.01.22.19.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.02.20.18.41;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.11.12.41.09;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.49;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@more pieces of vax
@
text
@/*	$OpenBSD: n_support.S,v 1.19 2013/08/06 19:02:14 espie Exp $	*/
/*	$NetBSD: n_support.S,v 1.1 1995/10/10 23:40:30 ragge Exp $	*/
/*
 * Copyright (c) 1985, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)support.s	8.1 (Berkeley) 6/4/93
 */

#include <machine/asm.h>
#include <sys/errno.h>

/*
 * copysign(x,y),
 * copysignf(x,y),
 * logb(x),
 * logbf(x),
 * scalbn(x,N),
 * remainder(x,y),
 * Coded in vax assembly language by K.C. Ng,  3/14/85.
 * Revised by K.C. Ng on 4/9/85.
 * Float versions by M.V. on 11/19/08.
 */

/*
 * double
 * copysign(double x, double y)
 */

STRONG_ALIAS(copysignl,copysign)
ENTRY(copysign, R2)
	movq	4(%ap),%r0		# load x into r0
	bicw3	$0x807f,%r0,%r2		# mask off the exponent of x
	beql	Lz			# if zero or reserved op then return x
	bicw3	$0x7fff,12(%ap),%r2	# copy the sign bit of y into r2
	bicw2	$0x8000,%r0		# replace x by |x|
	bisw2	%r2,%r0			# copy the sign bit of y to x
Lz:	ret

/*
 * float
 * copysignf(float x, float y)
 */

ENTRY(copysignf, R2)
	movl	4(%ap),%r0		# load x into r0
	bicw3	$0x807f,%r0,%r2		# mask off the exponent of x
	beql	Fz			# if zero or reserved op then return x
	bicw3	$0x7fff,8(%ap),%r2	# copy the sign bit of y into r2
	bicw2	$0x8000,%r0		# replace x by |x|
	bisw2	%r2,%r0			# copy the sign bit of y to x
Fz:	ret

/*
 * double
 * logb(double x)
 */

STRONG_ALIAS(logbl,logb)
ENTRY(logb, 0)
	bicl3	$0xffff807f,4(%ap),%r0	# mask off the exponent of x
	beql    Ln
	ashl	$-7,%r0,%r0		# get the bias exponent
	subl2	$129,%r0		# get the unbias exponent
	cvtld	%r0,%r0			# return the answer in double
	ret
Ln:	movq	4(%ap),%r0		# r0:1 = x (zero or reserved op)
	bneq	1f			# simply return if reserved op
	movq 	$0x0000fe00ffffcfff,%r0	# -2147483647.0
1:	ret

/*
 * float
 * logbf(float x)
 */

ENTRY(logbf, 0)
	bicl3	$0xffff807f,4(%ap),%r0	# mask off the exponent of x
	beql    Fn
	ashl	$-7,%r0,%r0		# get the bias exponent
	subl2	$129,%r0		# get the unbias exponent
	cvtlf	%r0,%r0			# return the answer in float
	ret
Fn:	movl	4(%ap),%r0		# r0:1 = x (zero or reserved op)
	bneq	1f			# simply return if reserved op
	movl 	$0x0000d000,%r0		# -2147483647.0
1:	ret

/*
 * double
 * scalbn(double x, int N)
 */

ENTRY(scalbnf, 0)
	movl	8(%ap),-(%sp)
	cvtfd	4(%ap),-(%sp)
	calls	$3, _C_LABEL(scalbn)
	cvtdf	%r0,%r0
	ret

STRONG_ALIAS(scalbnl,scalbn)
ENTRY(scalbn, R2|R3)
	movq	4(%ap),%r0
	bicl3	$0xffff807f,%r0,%r3
	beql	ret1			# 0 or reserved operand
	movl	12(%ap),%r2
	cmpl	%r2,$0x12c
	bgeq	ovfl
	cmpl	%r2,$-0x12c
	bleq	unfl
	ashl	$7,%r2,%r2
	addl2	%r2,%r3
	bleq	unfl
	cmpl	%r3,$0x8000
	bgeq	ovfl
	addl2	%r2,%r0
	ret
ovfl:	pushl	$ERANGE
	calls	$1,_C_LABEL(infnan)	# if it returns
	bicw3	$0x7fff,4(%ap),%r2	# get the sign of input arg
	bisw2	%r2,%r0			# re-attach the sign to r0/1
	ret
unfl:	movq	$0,%r0
ret1:	ret

/*
 * REMAINDER(X,Y)
 * RETURN X REM Y =X-N*Y, N=[X/Y] ROUNDED (ROUNDED TO EVEN IN THE HALF WAY CASE)
 * DOUBLE PRECISION (VAX D format 56 bits)
 * CODED IN VAX ASSEMBLY LANGUAGE BY K.C. NG, 4/8/85.
 */

ALTENTRY(drem)
ENTRY(remainder, R2|R3|R4|R5|R6|R7|R8|R9|R10|R11)
	subl2	$12,%sp	
	movq	4(%ap),%r0		#r0=x
	movq	12(%ap),%r2		#r2=y
	jeql	Rop			#if y=0 then generate reserved op fault
	bicw3	$0x007f,%r0,%r4		#check if x is Rop
	cmpw	%r4,$0x8000
	jeql	Ret			#if x is Rop then return Rop
	bicl3	$0x007f,%r2,%r4		#check if y is Rop
	cmpw	%r4,$0x8000
	jeql	Ret			#if y is Rop then return Rop
	bicw2	$0x8000,%r2		#y  := |y|
	movw	$0,-4(%fp)		#-4(fp) = nx := 0
	cmpw	%r2,$0x1c80		#yexp ? 57 
	bgtr	C1			#if yexp > 57 goto C1
	addw2	$0x1c80,%r2		#scale up y by 2**57
	movw	$0x1c80,-4(%fp)		#nx := 57 (exponent field)
C1:
	movw	-4(%fp),-8(%fp)		#-8(fp) = nf := nx
	bicw3	$0x7fff,%r0,-12(%fp)	#-12(fp) = sign of x
	bicw2	$0x8000,%r0		#x  := |x|
	movq	%r2,%r10		#y1 := y
	bicl2	$0xffff07ff,%r11	#clear the last 27 bits of y1
loop:
	cmpd	%r0,%r2			#x ? y
	bleq	E1			#if x <= y goto E1
 /* begin argument reduction */
	movq	%r2,%r4			#t =y
	movq	%r10,%r6		#t1=y1
	bicw3	$0x807f,%r0,%r8		#xexp= exponent of x
	bicw3	$0x807f,%r2,%r9		#yexp= exponent fo y
	subw2	%r9,%r8			#xexp-yexp
	subw2	$0x0c80,%r8		#k=xexp-yexp-25(exponent bit field)
	blss	C2			#if k<0 goto C2
	addw2	%r8,%r4			#t +=k	
	addw2	%r8,%r6			#t1+=k, scale up t and t1
C2:
	divd3	%r4,%r0,%r8		#x/t
	cvtdl	%r8,%r8			#n=[x/t] truncated
	cvtld	%r8,%r8			#float(n)
	subd2	%r6,%r4			#t:=t-t1
	muld2	%r8,%r4			#n*(t-t1)
	muld2	%r8,%r6			#n*t1
	subd2	%r6,%r0			#x-n*t1
	subd2	%r4,%r0			#(x-n*t1)-n*(t-t1)
	brb	loop
E1:
	movw	-4(%fp),%r6		#r6=nx
	beql	C3			#if nx=0 goto C3
	addw2	%r6,%r0			#x:=x*2**57 scale up x by nx
	movw	$0,-4(%fp)		#clear nx
	brb	loop
C3:
	movq	%r2,%r4			#r4 = y
	subw2	$0x80,%r4		#r4 = y/2
	cmpd	%r0,%r4			#x:y/2
	blss	E2			#if x < y/2 goto E2
	bgtr	C4			#if x > y/2 goto C4
	cvtdl	%r8,%r8			#ifix(float(n))
	blbc	%r8,E2			#if the last bit is zero, goto E2
C4:
	subd2	%r2,%r0			#x-y
E2:
	xorw2	-12(%fp),%r0		#x^sign (exclusive or)
	movw	-8(%fp),%r6		#r6=nf
	bicw3	$0x807f,%r0,%r8		#r8=exponent of x
	bicw2	$0x7f80,%r0		#clear the exponent of x
	subw2	%r6,%r8			#r8=xexp-nf
	bgtr	C5			#if xexp-nf is positive goto C5
	movw	$0,%r8			#clear r8
	movq	$0,%r0			#x underflow to zero
C5:
	bisw2	%r8,%r0			#put r8 into exponent field of x
	ret
Rop:					#Reserved operand
	pushl	$EDOM
	calls	$1,_C_LABEL(infnan)	#generate reserved op fault
	ret
Ret:
	movq	$0x8000,%r0		#propagate reserved op
	ret
@


1.19
log
@scalbnf on vax, okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.18 2013/07/05 21:10:50 miod Exp $	*/
@


1.18
log
@VAX ELF userland bits. Consists mostly of register prefix additions.
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.17 2013/03/28 18:09:38 martynas Exp $	*/
d117 7
@


1.17
log
@Switch libc and libm to use strong aliases rather than weak aliases
where appropriate.  Among other things makes the symbols consistent
across all architectures (notably where ldbl mantissa is 53 bits).

While at it, kill unused LINTLIBRARY/PROTOLIB1 cruft which was there
to trick lint into recording the right prototypes for aliased
functions.  Most of the work done at the awesome n2k13 hackathon.

Agreed by kettenis@@, guenther@@, matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.16 2008/12/12 19:30:17 martynas Exp $	*/
d56 2
a57 2
	movq	4(ap),r0		# load x into r0
	bicw3	$0x807f,r0,r2		# mask off the exponent of x
d59 3
a61 3
	bicw3	$0x7fff,12(ap),r2	# copy the sign bit of y into r2
	bicw2	$0x8000,r0		# replace x by |x|
	bisw2	r2,r0			# copy the sign bit of y to x
d70 2
a71 2
	movl	4(ap),r0		# load x into r0
	bicw3	$0x807f,r0,r2		# mask off the exponent of x
d73 3
a75 3
	bicw3	$0x7fff,8(ap),r2	# copy the sign bit of y into r2
	bicw2	$0x8000,r0		# replace x by |x|
	bisw2	r2,r0			# copy the sign bit of y to x
d85 1
a85 1
	bicl3	$0xffff807f,4(ap),r0	# mask off the exponent of x
d87 3
a89 3
	ashl	$-7,r0,r0		# get the bias exponent
	subl2	$129,r0			# get the unbias exponent
	cvtld	r0,r0			# return the answer in double
d91 1
a91 1
Ln:	movq	4(ap),r0		# r0:1 = x (zero or reserved op)
d93 1
a93 1
	movq 	$0x0000fe00ffffcfff,r0  # -2147483647.0
d102 1
a102 1
	bicl3	$0xffff807f,4(ap),r0	# mask off the exponent of x
d104 3
a106 3
	ashl	$-7,r0,r0		# get the bias exponent
	subl2	$129,r0			# get the unbias exponent
	cvtlf	r0,r0			# return the answer in float
d108 1
a108 1
Fn:	movl	4(ap),r0		# r0:1 = x (zero or reserved op)
d110 1
a110 1
	movl 	$0x0000d000,r0		# -2147483647.0
d120 2
a121 2
	movq	4(ap),r0
	bicl3	$0xffff807f,r0,r3
d123 2
a124 2
	movl	12(ap),r2
	cmpl	r2,$0x12c
d126 1
a126 1
	cmpl	r2,$-0x12c
d128 2
a129 2
	ashl	$7,r2,r2
	addl2	r2,r3
d131 1
a131 1
	cmpl	r3,$0x8000
d133 1
a133 1
	addl2	r2,r0
d137 2
a138 2
	bicw3	$0x7fff,4(ap),r2	# get the sign of input arg
	bisw2	r2,r0			# re-attach the sign to r0/1
d140 1
a140 1
unfl:	movq	$0,r0
d152 3
a154 3
	subl2	$12,sp	
	movq	4(ap),r0		#r0=x
	movq	12(ap),r2		#r2=y
d156 2
a157 2
	bicw3	$0x007f,r0,r4		#check if x is Rop
	cmpw	r4,$0x8000
d159 2
a160 2
	bicl3	$0x007f,r2,r4		#check if y is Rop
	cmpw	r4,$0x8000
d162 3
a164 3
	bicw2	$0x8000,r2		#y  := |y|
	movw	$0,-4(fp)		#-4(fp) = nx := 0
	cmpw	r2,$0x1c80		#yexp ? 57 
d166 2
a167 2
	addw2	$0x1c80,r2		#scale up y by 2**57
	movw	$0x1c80,-4(fp)		#nx := 57 (exponent field)
d169 5
a173 5
	movw	-4(fp),-8(fp)		#-8(fp) = nf := nx
	bicw3	$0x7fff,r0,-12(fp)	#-12(fp) = sign of x
	bicw2	$0x8000,r0		#x  := |x|
	movq	r2,r10			#y1 := y
	bicl2	$0xffff07ff,r11		#clear the last 27 bits of y1
d175 1
a175 1
	cmpd	r0,r2			#x ? y
d178 6
a183 6
	movq	r2,r4			#t =y
	movq	r10,r6			#t1=y1
	bicw3	$0x807f,r0,r8		#xexp= exponent of x
	bicw3	$0x807f,r2,r9		#yexp= exponent fo y
	subw2	r9,r8			#xexp-yexp
	subw2	$0x0c80,r8		#k=xexp-yexp-25(exponent bit field)
d185 2
a186 2
	addw2	r8,r4			#t +=k	
	addw2	r8,r6			#t1+=k, scale up t and t1
d188 8
a195 8
	divd3	r4,r0,r8		#x/t
	cvtdl	r8,r8			#n=[x/t] truncated
	cvtld	r8,r8			#float(n)
	subd2	r6,r4			#t:=t-t1
	muld2	r8,r4			#n*(t-t1)
	muld2	r8,r6			#n*t1
	subd2	r6,r0			#x-n*t1
	subd2	r4,r0			#(x-n*t1)-n*(t-t1)
d198 1
a198 1
	movw	-4(fp),r6		#r6=nx
d200 2
a201 2
	addw2	r6,r0			#x:=x*2**57 scale up x by nx
	movw	$0,-4(fp)		#clear nx
d204 3
a206 3
	movq	r2,r4			#r4 = y
	subw2	$0x80,r4		#r4 = y/2
	cmpd	r0,r4			#x:y/2
d209 2
a210 2
	cvtdl	r8,r8			#ifix(float(n))
	blbc	r8,E2			#if the last bit is zero, goto E2
d212 1
a212 1
	subd2	r2,r0			#x-y
d214 5
a218 5
	xorw2	-12(fp),r0		#x^sign (exclusive or)
	movw	-8(fp),r6		#r6=nf
	bicw3	$0x807f,r0,r8		#r8=exponent of x
	bicw2	$0x7f80,r0		#clear the exponent of x
	subw2	r6,r8			#r8=xexp-nf
d220 2
a221 2
	movw	$0,r8			#clear r8
	movq	$0,r0			#x underflow to zero
d223 1
a223 1
	bisw2	r8,r0			#put r8 into exponent field of x
d230 1
a230 1
	movq	$0x8000,r0		#propagate reserved op
@


1.16
log
@space
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.15 2008/12/09 20:21:07 martynas Exp $	*/
d54 1
a54 1
WEAK_ALIAS(copysignl,copysign)
d83 1
a83 1
WEAK_ALIAS(logbl,logb)
d118 1
a118 1
WEAK_ALIAS(scalbnl,scalbn)
@


1.15
log
@alias fabsl to fabs on these archs
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.14 2008/12/09 20:00:35 martynas Exp $	*/
d54 1
a54 1
WEAK_ALIAS(copysignl, copysign)
d83 1
a83 1
WEAK_ALIAS(logbl, logb)
d118 1
a118 1
WEAK_ALIAS(scalbnl, scalbn)
@


1.14
log
@- 80-bit and quad precision trigonometric and other most
important functions: acosl, asinl, atanl, atan2l, cosl,
sinl, tanl, exp2l, frexpl, ilogbl, ldexpl, logbl, scalbnl,
fabsl, hypotl, powl, sqrtl, rintl, copysignl, nanl, fdiml,
fmaxl, fminl.  mostly taken from freebsd, needed alot of
changes to adapt.  note, these are all c versions;  and are
quite slow when architectures have, e.g. sqrt.  assembly
versions will be added afterwards
- make them .weak/__weak_alias to the double precision
versions on other archs
- no need to have two finites.  finite() and finitef() are
non-standard 3BSD obsolete versions of isfinite.  remove
from libm.  make them weak_alias in libc to __isfinite and
__isfinitef instead.  similarly make 3BSD obsolete versions
of isinf, isinff, isnan, isnanf weak_aliases to C99's
__isinf, __isinff, __isnan, __isnanf
- remove unused infinity.c.  the c library has infinities
for each supported platform
- use STRICT_ASSIGN cast hack for _kernel_rem_pio2, so that
the double version has a chance of working on i386 with
extra precision
- avoid storing multiple copies of the pi/2 array, since
it won't vary
- bump major due to removed finite/finitef.  although they
will be in libc, which anything is linked to, minor bump
might be enough
ok millert@@.   tested by sthen@@, jsg@@, ajacoutot@@, kili@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.13 2008/11/20 23:21:37 martynas Exp $	*/
d54 1
a54 3
.weak copysignl
	copysignl = copysign

d83 1
a83 3
.weak logbl
	logbl = logb

d118 1
a118 3
.weak scalbnl
	scalbnl = scalbn

@


1.13
log
@float math functions:  copysignf and logbf.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.12 2008/07/24 09:40:16 martynas Exp $	*/
a42 1
 * finite(x),
d54 3
d85 3
a117 14
 * long
 * finite(double x)
 */

ENTRY(finite, 0)
	bicw3	$0x7f,4(ap),r0		# mask off the mantissa
	cmpw	r0,$0x8000		# to see if x is the reserved op
	beql	1f			# if so, return FALSE (0)
	movl	$1,r0			# else return TRUE (1)
	ret
1:	clrl	r0
	ret

/*
d121 3
@


1.12
log
@- remove isinff, isnanf.  this has been moved to libc
- remove never-enabled signbit.  libc has is now
- add C99 implementations, from freebsd, for nan(), nanf() (needed
to write _digittoint for it), exp2(), exp2f(), remquo(), remquof(),
needed STRICT_ASSIGN macro for math_private.h
- bump major
man pages will follow
exp2{,f} has been requested by chl@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.11 2008/06/21 08:26:19 martynas Exp $	*/
d39 1
d41 1
d47 1
d65 14
d93 17
@


1.11
log
@cleaning up, no functional changes
- no support for National 32000, removing ns32000/national ifdefs maze
- remove tahoe defs
- ansify
looks fine to millert@@;  who also noticed rint removal
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.10 2008/06/12 18:06:10 martynas Exp $	*/
a42 2
 * isinff(x),
 * isnanf(x),
a209 31

/*
 * int
 * isinff(float x)
 */

ENTRY(isinff, 0)
	clrl	r0
	ret

/*
 * int
 * isnanf(float x)
 */
        
ENTRY(isnanf, 0)
	clrl	r0
	ret

/*
 * signbit(x), signbitl(x), signbitf(x) -- returns zero if x is
 *    non-negative.
 */
	_ALIGN_TEXT
ALTENTRY(__signbitf)
ALTENTRY(__signbitl)
ENTRY(__signbit, 0)
        movw 4(ap), r0
        bicl2 $-32769,r0
        ret

@


1.10
log
@add isinff and isnanf.  no objection millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.9 2008/06/12 16:11:36 martynas Exp $	*/
d50 2
a51 2
 * double copysign(x,y)
 * double x,y;
d64 2
a65 2
 * double logb(x)
 * double x;
d81 2
a82 2
 * long finite(x)
 * double x;
d95 2
a96 2
 * double scalbn(x,N)
 * double x; int N;
d214 2
a215 2
 * int isinff(x)
 * float x;
d223 2
a224 2
 * int isnanf(x)
 * float x;
@


1.9
log
@use ALTENTRY;  was ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.8 2008/06/11 14:50:06 martynas Exp $	*/
d43 2
d211 18
@


1.8
log
@drem{,f} are aliases for remainder{,f}, so:
- document and mlink drem{,f}
- drem->remainder on noieee, and make drem an alias
- finite returns integer, n_support.c
- general n_support.c ansification and cleanup
- drem is now an ALTENTRY for remainder, in n_support.S
help with man page from jmc@@ and millert@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: n_support.S,v 1.7 2008/05/21 20:37:10 miod Exp $	*/
d128 1
a128 3
	.globl drem
	drem = remainder

@


1.7
log
@Use proper *ENTRY macros with symbolic register save masks, sprinkle
_C_LABEL and _ASM_LABEL, and add $OpenBSD$ RCS Ids.

Include <sys/errno.h> and use its values directly, instead of using .set
directives (which grow the individual .o files even)

Also, replace `$' in internal (but non static) symbols with `_', and prefix
those with `__'.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
 * drem(x,y),
d122 1
a122 1
 * DREM(X,Y)
d128 4
a131 1
ENTRY(drem, R2|R3|R4|R5|R6|R7|R8|R9|R10|R11)
@


1.6
log
@add __signbit/__signbitf/__signbitl (all the same) for vax (not used yet,
but coming soon to a <math.h> near you).
@
text
@d1 1
d33 3
a35 4
	.data
	.align	2
_sccsid:
.asciz	"@@(#)support.s	1.3 (Berkeley) 8/21/85; 8.1 (ucb.elefunt) 6/4/93"
d51 2
a52 5
	.globl	_copysign
	.text
	.align	1
_copysign:
	.word	0x4
d65 2
a66 5
	.globl	_logb
	.text
	.align	1
_logb:
	.word	0x0
d82 2
a83 5
	.globl	_finite
	.text
	.align	1
_finite:
	.word	0x0000
d96 2
a97 6
	.globl	_scalbn
	.set	ERANGE,34
	.text
	.align	1
_scalbn:
	.word	0xc
d114 1
a114 1
	calls	$1,_infnan		# if it returns
d127 2
a128 6
	.globl	_drem
	.set	EDOM,33
	.text
	.align	1
_drem:
	.word	0xffc
d204 1
a204 1
	calls	$1,_infnan		#generate reserved op fault
d214 4
a217 10
        .globl ___signbitf
        .type ___signbitf, @@function
        .globl ___signbit
        .type ___signbit, @@function
        .globl ___signbitl
        .type ___signbitl, @@function
___signbitf:
___signbit:
___signbitl:
        .word 0x0
@


1.5
log
@avoid ' which confuses make depend
@
text
@d226 19
@


1.4
log
@Historically, scalb() in 4BSD had the actual semantics of scalbn().  We changed
scalb() to scalbn() some time ago in the tree to fix this.  However, it turns
out the vax scalb() had already been fixed to support standard scalb()
semantics.  This commit undoes that change, making the vax scalbn() the same
as the 4BSD scalb() (but with the correct name) and fixes the comment.

We still could use wrappers for scalb(), scalbf() and scalbnf().
Fixes exp() and a number of perl tests; OK hugh@@
@
text
@d217 1
a217 1
	bisw2	r8,r0			#put r8 into x's exponent field
@


1.3
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d103 1
a103 1
 * double x; double N;
d110 1
a110 1
	.word	0x3c
d114 1
a114 2
	movq	12(ap),r4
	cvtdl	r4, r2
d217 1
a217 1
	bisw2	r8,r0			/* put r8 into x's exponent field */
@


1.2
log
@scalb() in vax libm is in fact scalbn(), so change the symbol name.
Only affects vax, which has no shared libraries, so no version change
needed for libm.
Someone with enough math skills ought to code a real scalb() on a rainy day...
@
text
@d14 1
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.1
log
@Initial revision
@
text
@d44 1
a44 1
 * scalb(x,N),
d106 1
a106 1
 * double scalb(x,N)
d109 1
a109 1
	.globl	_scalb
d113 1
a113 1
_scalb:
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
