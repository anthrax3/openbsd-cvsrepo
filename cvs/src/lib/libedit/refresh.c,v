head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.2
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.24
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.16
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.20
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.18
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.14
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.12
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.26
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.22
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.20
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.18
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.16
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.20
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.18
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.16
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.14
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2017.07.26.12.10.56;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	3TSOU5TUaycHwlXA;

1.20
date	2016.05.06.18.01.40;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	nTHl2s1BPdZ5hPZf;

1.19
date	2016.04.11.21.17.29;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	I3AtNAFb4FywnTMT;

1.18
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	OUneMOe0l7HombT5;

1.17
date	2016.04.11.19.54.54;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	xizUpRlYj2C4Hcj6;

1.16
date	2016.04.09.20.15.26;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	0bnhGLXZIvXlnMLp;

1.15
date	2016.03.22.11.32.18;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	IqABuRl0Ys8M4ewM;

1.14
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	tRHhB2RN3ZD1GvoI;

1.13
date	2016.03.20.20.35.38;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	b06qlwkNEbVitvG0;

1.12
date	2016.01.30.00.06.39;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	tGf8IdK8wCurneJ7;

1.11
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.01.21.11.21;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.17.19.42.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.04.09.02.28.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.03.14.05.12.59;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.16.05.18.42;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Initialize "old" screen buffer lines before use; otherwise, they would
never get NUL-terminated and cause read buffer overruns.
This fixes for example segfaults in sftp(1) that could be triggered
by typing in an extremely long string (more than one line - the longer,
the likelier to crash), then hitting backspace once.
Problem reported and patch OK'ed by sthen@@.
@
text
@/*	$OpenBSD: refresh.c,v 1.20 2016/05/06 18:01:40 schwarze Exp $	*/
/*	$NetBSD: refresh.c,v 1.50 2016/05/02 16:35:17 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * refresh.c: Lower level screen refreshing functions
 */
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "el.h"

static void	re_nextline(EditLine *);
static void	re_addc(EditLine *, wint_t);
static void	re_update_line(EditLine *, wchar_t *, wchar_t *, int);
static void	re_insert (EditLine *, wchar_t *, int, int, wchar_t *, int);
static void	re_delete(EditLine *, wchar_t *, int, int, int);
static void	re_fastputc(EditLine *, wint_t);
static void	re_clear_eol(EditLine *, int, int, int);
static void	re__strncopy(wchar_t *, wchar_t *, size_t);
static void	re__copy_and_pad(wchar_t *, const wchar_t *, size_t);

#ifdef DEBUG_REFRESH
static void	re_printstr(EditLine *, const char *, wchar_t *, wchar_t *);
#define	__F el->el_errfile
#define	ELRE_ASSERT(a, b, c)	do				\
				    if (/*CONSTCOND*/ a) {	\
					(void) fprintf b;	\
					c;			\
				    }				\
				while (/*CONSTCOND*/0)
#define	ELRE_DEBUG(a, b)	ELRE_ASSERT(a,b,;)

/* re_printstr():
 *	Print a string on the debugging pty
 */
static void
re_printstr(EditLine *el, const char *str, wchar_t *f, wchar_t *t)
{

	ELRE_DEBUG(1, (__F, "%s:\"", str));
	while (f < t)
		ELRE_DEBUG(1, (__F, "%c", *f++ & 0177));
	ELRE_DEBUG(1, (__F, "\"\r\n"));
}
#else
#define	ELRE_ASSERT(a, b, c)
#define	ELRE_DEBUG(a, b)
#endif

/* re_nextline():
 *	Move to the next line or scroll
 */
static void
re_nextline(EditLine *el)
{
	el->el_refresh.r_cursor.h = 0;	/* reset it. */

	/*
	 * If we would overflow (input is longer than terminal size),
	 * emulate scroll by dropping first line and shuffling the rest.
	 * We do this via pointer shuffling - it's safe in this case
	 * and we avoid memcpy().
	 */
	if (el->el_refresh.r_cursor.v + 1 >= el->el_terminal.t_size.v) {
		int i, lins = el->el_terminal.t_size.v;
		wchar_t *firstline = el->el_vdisplay[0];

		for(i = 1; i < lins; i++)
			el->el_vdisplay[i - 1] = el->el_vdisplay[i];

		firstline[0] = '\0';		/* empty the string */
		el->el_vdisplay[i - 1] = firstline;
	} else
		el->el_refresh.r_cursor.v++;

	ELRE_ASSERT(el->el_refresh.r_cursor.v >= el->el_terminal.t_size.v,
	    (__F, "\r\nre_putc: overflow! r_cursor.v == %d > %d\r\n",
	    el->el_refresh.r_cursor.v, el->el_terminal.t_size.v),
	    abort());
}

/* re_addc():
 *	Draw c, expanding tabs, control chars etc.
 */
static void
re_addc(EditLine *el, wint_t c)
{
	switch (ct_chr_class(c)) {
	case CHTYPE_TAB:        /* expand the tab */
		for (;;) {
			re_putc(el, ' ', 1);
			if ((el->el_refresh.r_cursor.h & 07) == 0)
				break;			/* go until tab stop */
		}
		break;
	case CHTYPE_NL: {
		int oldv = el->el_refresh.r_cursor.v;
		re_putc(el, '\0', 0);			/* assure end of line */
		if (oldv == el->el_refresh.r_cursor.v)	/* XXX */
			re_nextline(el);
		break;
	}
	case CHTYPE_PRINT:
		re_putc(el, c, 1);
		break;
	default: {
		wchar_t visbuf[VISUAL_WIDTH_MAX];
		ssize_t i, n =
		    ct_visual_char(visbuf, VISUAL_WIDTH_MAX, c);
		for (i = 0; n-- > 0; ++i)
		    re_putc(el, visbuf[i], 1);
		break;
	}
	}
}


/* re_putc():
 *	Draw the character given
 */
protected void
re_putc(EditLine *el, wint_t c, int shift)
{
	int i, w = wcwidth(c);
	ELRE_DEBUG(1, (__F, "printing %5x '%lc'\r\n", c, c));
	if (w == -1)
		w = 0;

	while (shift && (el->el_refresh.r_cursor.h + w > el->el_terminal.t_size.h))
	    re_putc(el, ' ', 1);

	el->el_vdisplay[el->el_refresh.r_cursor.v]
	    [el->el_refresh.r_cursor.h] = c;
	/* assumes !shift is only used for single-column chars */
	i = w;
	while (--i > 0)
		el->el_vdisplay[el->el_refresh.r_cursor.v]
		    [el->el_refresh.r_cursor.h + i] = MB_FILL_CHAR;

	if (!shift)
		return;

	el->el_refresh.r_cursor.h += w;	/* advance to next place */
	if (el->el_refresh.r_cursor.h >= el->el_terminal.t_size.h) {
		/* assure end of line */
		el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_terminal.t_size.h]
		    = '\0';
		re_nextline(el);
	}
}


/* re_refresh():
 *	draws the new virtual screen image from the current input
 *	line, then goes line-by-line changing the real image to the new
 *	virtual image. The routine to re-draw a line can be replaced
 *	easily in hopes of a smarter one being placed there.
 */
protected void
re_refresh(EditLine *el)
{
	int i, rhdiff;
	wchar_t *cp, *st;
	coord_t cur;
#ifdef notyet
	size_t termsz;
#endif

	ELRE_DEBUG(1, (__F, "el->el_line.buffer = :%ls:\r\n",
	    el->el_line.buffer));

	/* reset the Drawing cursor */
	el->el_refresh.r_cursor.h = 0;
	el->el_refresh.r_cursor.v = 0;

	/* temporarily draw rprompt to calculate its size */
	prompt_print(el, EL_RPROMPT);

	/* reset the Drawing cursor */
	el->el_refresh.r_cursor.h = 0;
	el->el_refresh.r_cursor.v = 0;

	if (el->el_line.cursor >= el->el_line.lastchar) {
		if (el->el_map.current == el->el_map.alt
		    && el->el_line.lastchar != el->el_line.buffer)
			el->el_line.cursor = el->el_line.lastchar - 1;
		else
			el->el_line.cursor = el->el_line.lastchar;
	}

	cur.h = -1;		/* set flag in case I'm not set */
	cur.v = 0;

	prompt_print(el, EL_PROMPT);

	/* draw the current input buffer */
#if notyet
	termsz = el->el_terminal.t_size.h * el->el_terminal.t_size.v;
	if (el->el_line.lastchar - el->el_line.buffer > termsz) {
		/*
		 * If line is longer than terminal, process only part
		 * of line which would influence display.
		 */
		size_t rem = (el->el_line.lastchar-el->el_line.buffer)%termsz;

		st = el->el_line.lastchar - rem
			- (termsz - (((rem / el->el_terminal.t_size.v) - 1)
					* el->el_terminal.t_size.v));
	} else
#endif
		st = el->el_line.buffer;

	for (cp = st; cp < el->el_line.lastchar; cp++) {
		if (cp == el->el_line.cursor) {
                        int w = wcwidth(*cp);
			/* save for later */
			cur.h = el->el_refresh.r_cursor.h;
			cur.v = el->el_refresh.r_cursor.v;
                        /* handle being at a linebroken doublewidth char */
                        if (w > 1 && el->el_refresh.r_cursor.h + w >
			    el->el_terminal.t_size.h) {
				cur.h = 0;
				cur.v++;
                        }
		}
		re_addc(el, *cp);
	}

	if (cur.h == -1) {	/* if I haven't been set yet, I'm at the end */
		cur.h = el->el_refresh.r_cursor.h;
		cur.v = el->el_refresh.r_cursor.v;
	}
	rhdiff = el->el_terminal.t_size.h - el->el_refresh.r_cursor.h -
	    el->el_rprompt.p_pos.h;
	if (el->el_rprompt.p_pos.h && !el->el_rprompt.p_pos.v &&
	    !el->el_refresh.r_cursor.v && rhdiff > 1) {
		/*
		 * have a right-hand side prompt that will fit
		 * on the end of the first line with at least
		 * one character gap to the input buffer.
		 */
		while (--rhdiff > 0)	/* pad out with spaces */
			re_putc(el, ' ', 1);
		prompt_print(el, EL_RPROMPT);
	} else {
		el->el_rprompt.p_pos.h = 0;	/* flag "not using rprompt" */
		el->el_rprompt.p_pos.v = 0;
	}

	re_putc(el, '\0', 0);	/* make line ended with NUL, no cursor shift */

	el->el_refresh.r_newcv = el->el_refresh.r_cursor.v;

	ELRE_DEBUG(1, (__F,
		"term.h=%d vcur.h=%d vcur.v=%d vdisplay[0]=\r\n:%80.80s:\r\n",
		el->el_terminal.t_size.h, el->el_refresh.r_cursor.h,
		el->el_refresh.r_cursor.v, ct_encode_string(el->el_vdisplay[0],
		&el->el_scratch)));

	ELRE_DEBUG(1, (__F, "updating %d lines.\r\n", el->el_refresh.r_newcv));
	for (i = 0; i <= el->el_refresh.r_newcv; i++) {
		/* NOTE THAT re_update_line MAY CHANGE el_display[i] */
		re_update_line(el, el->el_display[i], el->el_vdisplay[i], i);

		/*
		 * Copy the new line to be the current one, and pad out with
		 * spaces to the full width of the terminal so that if we try
		 * moving the cursor by writing the character that is at the
		 * end of the screen line, it won't be a NUL or some old
		 * leftover stuff.
		 */
		re__copy_and_pad(el->el_display[i], el->el_vdisplay[i],
		    (size_t) el->el_terminal.t_size.h);
	}
	ELRE_DEBUG(1, (__F,
	"\r\nel->el_refresh.r_cursor.v=%d,el->el_refresh.r_oldcv=%d i=%d\r\n",
	    el->el_refresh.r_cursor.v, el->el_refresh.r_oldcv, i));

	if (el->el_refresh.r_oldcv > el->el_refresh.r_newcv)
		for (; i <= el->el_refresh.r_oldcv; i++) {
			terminal_move_to_line(el, i);
			terminal_move_to_char(el, 0);
                        /* This wcslen should be safe even with MB_FILL_CHARs */
			terminal_clear_EOL(el, (int) wcslen(el->el_display[i]));
#ifdef DEBUG_REFRESH
			terminal_overwrite(el, L"C\b", 2);
#endif /* DEBUG_REFRESH */
			el->el_display[i][0] = '\0';
		}

	el->el_refresh.r_oldcv = el->el_refresh.r_newcv; /* set for next time */
	ELRE_DEBUG(1, (__F,
	    "\r\ncursor.h = %d, cursor.v = %d, cur.h = %d, cur.v = %d\r\n",
	    el->el_refresh.r_cursor.h, el->el_refresh.r_cursor.v,
	    cur.h, cur.v));
	terminal_move_to_line(el, cur.v);	/* go to where the cursor is */
	terminal_move_to_char(el, cur.h);
}


/* re_goto_bottom():
 *	 used to go to last used screen line
 */
protected void
re_goto_bottom(EditLine *el)
{

	terminal_move_to_line(el, el->el_refresh.r_oldcv);
	terminal__putc(el, '\n');
	re_clear_display(el);
	terminal__flush(el);
}


/* re_insert():
 *	insert num characters of s into d (in front of the character)
 *	at dat, maximum length of d is dlen
 */
static void
/*ARGSUSED*/
re_insert(EditLine *el __attribute__((__unused__)),
    wchar_t *d, int dat, int dlen, wchar_t *s, int num)
{
	wchar_t *a, *b;

	if (num <= 0)
		return;
	if (num > dlen - dat)
		num = dlen - dat;

	ELRE_DEBUG(1,
	    (__F, "re_insert() starting: %d at %d max %d, d == \"%s\"\n",
	    num, dat, dlen, ct_encode_string(d, &el->el_scratch)));
	ELRE_DEBUG(1, (__F, "s == \"%s\"\n", ct_encode_string(s,
	    &el->el_scratch)));

	/* open up the space for num chars */
	if (num > 0) {
		b = d + dlen - 1;
		a = b - num;
		while (a >= &d[dat])
			*b-- = *a--;
		d[dlen] = '\0';	/* just in case */
	}

	ELRE_DEBUG(1, (__F,
		"re_insert() after insert: %d at %d max %d, d == \"%s\"\n",
		num, dat, dlen, ct_encode_string(d, &el->el_scratch)));
	ELRE_DEBUG(1, (__F, "s == \"%s\"\n", ct_encode_string(s,
		&el->el_scratch)));

	/* copy the characters */
	for (a = d + dat; (a < d + dlen) && (num > 0); num--)
		*a++ = *s++;

#ifdef notyet
        /* ct_encode_string() uses a static buffer, so we can't conveniently
         * encode both d & s here */
	ELRE_DEBUG(1,
	    (__F, "re_insert() after copy: %d at %d max %d, %s == \"%s\"\n",
	    num, dat, dlen, d, s));
	ELRE_DEBUG(1, (__F, "s == \"%s\"\n", s));
#endif
}


/* re_delete():
 *	delete num characters d at dat, maximum length of d is dlen
 */
static void
/*ARGSUSED*/
re_delete(EditLine *el __attribute__((__unused__)),
    wchar_t *d, int dat, int dlen, int num)
{
	wchar_t *a, *b;

	if (num <= 0)
		return;
	if (dat + num >= dlen) {
		d[dat] = '\0';
		return;
	}
	ELRE_DEBUG(1,
	    (__F, "re_delete() starting: %d at %d max %d, d == \"%s\"\n",
	    num, dat, dlen, ct_encode_string(d, &el->el_scratch)));

	/* open up the space for num chars */
	if (num > 0) {
		b = d + dat;
		a = b + num;
		while (a < &d[dlen])
			*b++ = *a++;
		d[dlen] = '\0';	/* just in case */
	}
	ELRE_DEBUG(1,
	    (__F, "re_delete() after delete: %d at %d max %d, d == \"%s\"\n",
	    num, dat, dlen, ct_encode_string(d, &el->el_scratch)));
}


/* re__strncopy():
 *	Like strncpy without padding.
 */
static void
re__strncopy(wchar_t *a, wchar_t *b, size_t n)
{

	while (n-- && *b)
		*a++ = *b++;
}

/* re_clear_eol():
 *	Find the number of characters we need to clear till the end of line
 *	in order to make sure that we have cleared the previous contents of
 *	the line. fx and sx is the number of characters inserted or deleted
 *	in the first or second diff, diff is the difference between the
 *	number of characters between the new and old line.
 */
static void
re_clear_eol(EditLine *el, int fx, int sx, int diff)
{

	ELRE_DEBUG(1, (__F, "re_clear_eol sx %d, fx %d, diff %d\n",
	    sx, fx, diff));

	if (fx < 0)
		fx = -fx;
	if (sx < 0)
		sx = -sx;
	if (fx > diff)
		diff = fx;
	if (sx > diff)
		diff = sx;

	ELRE_DEBUG(1, (__F, "re_clear_eol %d\n", diff));
	terminal_clear_EOL(el, diff);
}

/*****************************************************************
    re_update_line() is based on finding the middle difference of each line
    on the screen; vis:

			     /old first difference
	/beginning of line   |              /old last same       /old EOL
	v		     v              v                    v
old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as
new:	eddie> Oh, my little buggy says to me, as lurgid as
	^		     ^        ^			   ^
	\beginning of line   |        \new last same	   \new end of line
			     \new first difference

    all are character pointers for the sake of speed.  Special cases for
    no differences, as well as for end of line additions must be handled.
**************************************************************** */

/* Minimum at which doing an insert it "worth it".  This should be about
 * half the "cost" of going into insert mode, inserting a character, and
 * going back out.  This should really be calculated from the termcap
 * data...  For the moment, a good number for ANSI terminals.
 */
#define	MIN_END_KEEP	4

static void
re_update_line(EditLine *el, wchar_t *old, wchar_t *new, int i)
{
	wchar_t *o, *n, *p, c;
	wchar_t *ofd, *ols, *oe, *nfd, *nls, *ne;
	wchar_t *osb, *ose, *nsb, *nse;
	int fx, sx;
	size_t len;

	/*
         * find first diff
         */
	for (o = old, n = new; *o && (*o == *n); o++, n++)
		continue;
	ofd = o;
	nfd = n;

	/*
         * Find the end of both old and new
         */
	while (*o)
		o++;
	/*
         * Remove any trailing blanks off of the end, being careful not to
         * back up past the beginning.
         */
	while (ofd < o) {
		if (o[-1] != ' ')
			break;
		o--;
	}
	oe = o;
	*oe = '\0';

	while (*n)
		n++;

	/* remove blanks from end of new */
	while (nfd < n) {
		if (n[-1] != ' ')
			break;
		n--;
	}
	ne = n;
	*ne = '\0';

	/*
         * if no diff, continue to next line of redraw
         */
	if (*ofd == '\0' && *nfd == '\0') {
		ELRE_DEBUG(1, (__F, "no difference.\r\n"));
		return;
	}
	/*
         * find last same pointer
         */
	while ((o > ofd) && (n > nfd) && (*--o == *--n))
		continue;
	ols = ++o;
	nls = ++n;

	/*
         * find same beginning and same end
         */
	osb = ols;
	nsb = nls;
	ose = ols;
	nse = nls;

	/*
         * case 1: insert: scan from nfd to nls looking for *ofd
         */
	if (*ofd) {
		for (c = *ofd, n = nfd; n < nls; n++) {
			if (c == *n) {
				for (o = ofd, p = n;
				    p < nls && o < ols && *o == *p;
				    o++, p++)
					continue;
				/*
				 * if the new match is longer and it's worth
				 * keeping, then we take it
				 */
				if (((nse - nsb) < (p - n)) &&
				    (2 * (p - n) > n - nfd)) {
					nsb = n;
					nse = p;
					osb = ofd;
					ose = o;
				}
			}
		}
	}
	/*
         * case 2: delete: scan from ofd to ols looking for *nfd
         */
	if (*nfd) {
		for (c = *nfd, o = ofd; o < ols; o++) {
			if (c == *o) {
				for (n = nfd, p = o;
				    p < ols && n < nls && *p == *n;
				    p++, n++)
					continue;
				/*
				 * if the new match is longer and it's worth
				 * keeping, then we take it
				 */
				if (((ose - osb) < (p - o)) &&
				    (2 * (p - o) > o - ofd)) {
					nsb = nfd;
					nse = n;
					osb = o;
					ose = p;
				}
			}
		}
	}
	/*
         * Pragmatics I: If old trailing whitespace or not enough characters to
         * save to be worth it, then don't save the last same info.
         */
	if ((oe - ols) < MIN_END_KEEP) {
		ols = oe;
		nls = ne;
	}
	/*
         * Pragmatics II: if the terminal isn't smart enough, make the data
         * dumber so the smart update doesn't try anything fancy
         */

	/*
         * fx is the number of characters we need to insert/delete: in the
         * beginning to bring the two same begins together
         */
	fx = (int)((nsb - nfd) - (osb - ofd));
	/*
         * sx is the number of characters we need to insert/delete: in the
         * end to bring the two same last parts together
         */
	sx = (int)((nls - nse) - (ols - ose));

	if (!EL_CAN_INSERT) {
		if (fx > 0) {
			osb = ols;
			ose = ols;
			nsb = nls;
			nse = nls;
		}
		if (sx > 0) {
			ols = oe;
			nls = ne;
		}
		if ((ols - ofd) < (nls - nfd)) {
			ols = oe;
			nls = ne;
		}
	}
	if (!EL_CAN_DELETE) {
		if (fx < 0) {
			osb = ols;
			ose = ols;
			nsb = nls;
			nse = nls;
		}
		if (sx < 0) {
			ols = oe;
			nls = ne;
		}
		if ((ols - ofd) > (nls - nfd)) {
			ols = oe;
			nls = ne;
		}
	}
	/*
         * Pragmatics III: make sure the middle shifted pointers are correct if
         * they don't point to anything (we may have moved ols or nls).
         */
	/* if the change isn't worth it, don't bother */
	/* was: if (osb == ose) */
	if ((ose - osb) < MIN_END_KEEP) {
		osb = ols;
		ose = ols;
		nsb = nls;
		nse = nls;
	}
	/*
         * Now that we are done with pragmatics we recompute fx, sx
         */
	fx = (int)((nsb - nfd) - (osb - ofd));
	sx = (int)((nls - nse) - (ols - ose));

	ELRE_DEBUG(1, (__F, "fx %d, sx %d\n", fx, sx));
	ELRE_DEBUG(1, (__F, "ofd %td, osb %td, ose %td, ols %td, oe %td\n",
		ofd - old, osb - old, ose - old, ols - old, oe - old));
	ELRE_DEBUG(1, (__F, "nfd %td, nsb %td, nse %td, nls %td, ne %td\n",
		nfd - new, nsb - new, nse - new, nls - new, ne - new));
	ELRE_DEBUG(1, (__F,
		"xxx-xxx:\"00000000001111111111222222222233333333334\"\r\n"));
	ELRE_DEBUG(1, (__F,
		"xxx-xxx:\"01234567890123456789012345678901234567890\"\r\n"));
#ifdef DEBUG_REFRESH
	re_printstr(el, "old- oe", old, oe);
	re_printstr(el, "new- ne", new, ne);
	re_printstr(el, "old-ofd", old, ofd);
	re_printstr(el, "new-nfd", new, nfd);
	re_printstr(el, "ofd-osb", ofd, osb);
	re_printstr(el, "nfd-nsb", nfd, nsb);
	re_printstr(el, "osb-ose", osb, ose);
	re_printstr(el, "nsb-nse", nsb, nse);
	re_printstr(el, "ose-ols", ose, ols);
	re_printstr(el, "nse-nls", nse, nls);
	re_printstr(el, "ols- oe", ols, oe);
	re_printstr(el, "nls- ne", nls, ne);
#endif /* DEBUG_REFRESH */

	/*
         * el_cursor.v to this line i MUST be in this routine so that if we
         * don't have to change the line, we don't move to it. el_cursor.h to
         * first diff char
         */
	terminal_move_to_line(el, i);

	/*
         * at this point we have something like this:
         *
         * /old                  /ofd    /osb               /ose    /ols     /oe
         * v.....................v       v..................v       v........v
         * eddie> Oh, my fredded gruntle-buggy is to me, as foo var lurgid as
         * eddie> Oh, my fredded quiux buggy is to me, as gruntle-lurgid as
         * ^.....................^     ^..................^       ^........^
         * \new                  \nfd  \nsb               \nse     \nls    \ne
         *
         * fx is the difference in length between the chars between nfd and
         * nsb, and the chars between ofd and osb, and is thus the number of
         * characters to delete if < 0 (new is shorter than old, as above),
         * or insert (new is longer than short).
         *
         * sx is the same for the second differences.
         */

	/*
         * if we have a net insert on the first difference, AND inserting the
         * net amount ((nsb-nfd) - (osb-ofd)) won't push the last useful
         * character (which is ne if nls != ne, otherwise is nse) off the edge
	 * of the screen (el->el_terminal.t_size.h) else we do the deletes first
	 * so that we keep everything we need to.
         */

	/*
         * if the last same is the same like the end, there is no last same
         * part, otherwise we want to keep the last same part set p to the
         * last useful old character
         */
	p = (ols != oe) ? oe : ose;

	/*
         * if (There is a diffence in the beginning) && (we need to insert
         *   characters) && (the number of characters to insert is less than
         *   the term width)
	 *	We need to do an insert!
	 * else if (we need to delete characters)
	 *	We need to delete characters!
	 * else
	 *	No insert or delete
         */
	if ((nsb != nfd) && fx > 0 &&
	    ((p - old) + fx <= el->el_terminal.t_size.h)) {
		ELRE_DEBUG(1,
		    (__F, "first diff insert at %td...\r\n", nfd - new));
		/*
		 * Move to the first char to insert, where the first diff is.
		 */
		terminal_move_to_char(el, (int)(nfd - new));
		/*
		 * Check if we have stuff to keep at end
		 */
		if (nsb != ne) {
			ELRE_DEBUG(1, (__F, "with stuff to keep at end\r\n"));
			/*
		         * insert fx chars of new starting at nfd
		         */
			if (fx > 0) {
				ELRE_DEBUG(!EL_CAN_INSERT, (__F,
				"ERROR: cannot insert in early first diff\n"));
				terminal_insertwrite(el, nfd, fx);
				re_insert(el, old, (int)(ofd - old),
				    el->el_terminal.t_size.h, nfd, fx);
			}
			/*
		         * write (nsb-nfd) - fx chars of new starting at
		         * (nfd + fx)
			 */
			len = (size_t) ((nsb - nfd) - fx);
			terminal_overwrite(el, (nfd + fx), len);
			re__strncopy(ofd + fx, nfd + fx, len);
		} else {
			ELRE_DEBUG(1, (__F, "without anything to save\r\n"));
			len = (size_t)(nsb - nfd);
			terminal_overwrite(el, nfd, len);
			re__strncopy(ofd, nfd, len);
			/*
		         * Done
		         */
			return;
		}
	} else if (fx < 0) {
		ELRE_DEBUG(1,
		    (__F, "first diff delete at %td...\r\n", ofd - old));
		/*
		 * move to the first char to delete where the first diff is
		 */
		terminal_move_to_char(el, (int)(ofd - old));
		/*
		 * Check if we have stuff to save
		 */
		if (osb != oe) {
			ELRE_DEBUG(1, (__F, "with stuff to save at end\r\n"));
			/*
		         * fx is less than zero *always* here but we check
		         * for code symmetry
		         */
			if (fx < 0) {
				ELRE_DEBUG(!EL_CAN_DELETE, (__F,
				    "ERROR: cannot delete in first diff\n"));
				terminal_deletechars(el, -fx);
				re_delete(el, old, (int)(ofd - old),
				    el->el_terminal.t_size.h, -fx);
			}
			/*
		         * write (nsb-nfd) chars of new starting at nfd
		         */
			len = (size_t) (nsb - nfd);
			terminal_overwrite(el, nfd, len);
			re__strncopy(ofd, nfd, len);

		} else {
			ELRE_DEBUG(1, (__F,
			    "but with nothing left to save\r\n"));
			/*
		         * write (nsb-nfd) chars of new starting at nfd
		         */
			terminal_overwrite(el, nfd, (size_t)(nsb - nfd));
			re_clear_eol(el, fx, sx,
			    (int)((oe - old) - (ne - new)));
			/*
		         * Done
		         */
			return;
		}
	} else
		fx = 0;

	if (sx < 0 && (ose - old) + fx < el->el_terminal.t_size.h) {
		ELRE_DEBUG(1, (__F,
		    "second diff delete at %td...\r\n", (ose - old) + fx));
		/*
		 * Check if we have stuff to delete
		 */
		/*
		 * fx is the number of characters inserted (+) or deleted (-)
		 */

		terminal_move_to_char(el, (int)((ose - old) + fx));
		/*
		 * Check if we have stuff to save
		 */
		if (ols != oe) {
			ELRE_DEBUG(1, (__F, "with stuff to save at end\r\n"));
			/*
		         * Again a duplicate test.
		         */
			if (sx < 0) {
				ELRE_DEBUG(!EL_CAN_DELETE, (__F,
				    "ERROR: cannot delete in second diff\n"));
				terminal_deletechars(el, -sx);
			}
			/*
		         * write (nls-nse) chars of new starting at nse
		         */
			terminal_overwrite(el, nse, (size_t)(nls - nse));
		} else {
			ELRE_DEBUG(1, (__F,
			    "but with nothing left to save\r\n"));
			terminal_overwrite(el, nse, (size_t)(nls - nse));
			re_clear_eol(el, fx, sx,
			    (int)((oe - old) - (ne - new)));
		}
	}
	/*
         * if we have a first insert AND WE HAVEN'T ALREADY DONE IT...
         */
	if ((nsb != nfd) && (osb - ofd) <= (nsb - nfd) && (fx == 0)) {
		ELRE_DEBUG(1, (__F, "late first diff insert at %td...\r\n",
		    nfd - new));

		terminal_move_to_char(el, (int)(nfd - new));
		/*
		 * Check if we have stuff to keep at the end
		 */
		if (nsb != ne) {
			ELRE_DEBUG(1, (__F, "with stuff to keep at end\r\n"));
			/*
		         * We have to recalculate fx here because we set it
		         * to zero above as a flag saying that we hadn't done
		         * an early first insert.
		         */
			fx = (int)((nsb - nfd) - (osb - ofd));
			if (fx > 0) {
				/*
				 * insert fx chars of new starting at nfd
				 */
				ELRE_DEBUG(!EL_CAN_INSERT, (__F,
				 "ERROR: cannot insert in late first diff\n"));
				terminal_insertwrite(el, nfd, fx);
				re_insert(el, old, (int)(ofd - old),
				    el->el_terminal.t_size.h, nfd, fx);
			}
			/*
		         * write (nsb-nfd) - fx chars of new starting at
		         * (nfd + fx)
			 */
			len = (size_t) ((nsb - nfd) - fx);
			terminal_overwrite(el, (nfd + fx), len);
			re__strncopy(ofd + fx, nfd + fx, len);
		} else {
			ELRE_DEBUG(1, (__F, "without anything to save\r\n"));
			len = (size_t) (nsb - nfd);
			terminal_overwrite(el, nfd, len);
			re__strncopy(ofd, nfd, len);
		}
	}
	/*
         * line is now NEW up to nse
         */
	if (sx >= 0) {
		ELRE_DEBUG(1, (__F,
		    "second diff insert at %d...\r\n", (int)(nse - new)));
		terminal_move_to_char(el, (int)(nse - new));
		if (ols != oe) {
			ELRE_DEBUG(1, (__F, "with stuff to keep at end\r\n"));
			if (sx > 0) {
				/* insert sx chars of new starting at nse */
				ELRE_DEBUG(!EL_CAN_INSERT, (__F,
				    "ERROR: cannot insert in second diff\n"));
				terminal_insertwrite(el, nse, sx);
			}
			/*
		         * write (nls-nse) - sx chars of new starting at
			 * (nse + sx)
		         */
			terminal_overwrite(el, (nse + sx),
			    (size_t)((nls - nse) - sx));
		} else {
			ELRE_DEBUG(1, (__F, "without anything to save\r\n"));
			terminal_overwrite(el, nse, (size_t)(nls - nse));

			/*
	                 * No need to do a clear-to-end here because we were
	                 * doing a second insert, so we will have over
	                 * written all of the old string.
		         */
		}
	}
	ELRE_DEBUG(1, (__F, "done.\r\n"));
}


/* re__copy_and_pad():
 *	Copy string and pad with spaces
 */
static void
re__copy_and_pad(wchar_t *dst, const wchar_t *src, size_t width)
{
	size_t i;

	for (i = 0; i < width; i++) {
		if (*src == '\0')
			break;
		*dst++ = *src++;
	}

	for (; i < width; i++)
		*dst++ = ' ';

	*dst = '\0';
}


/* re_refresh_cursor():
 *	Move to the new cursor position
 */
protected void
re_refresh_cursor(EditLine *el)
{
	wchar_t *cp;
	int h, v, th, w;

	if (el->el_line.cursor >= el->el_line.lastchar) {
		if (el->el_map.current == el->el_map.alt
		    && el->el_line.lastchar != el->el_line.buffer)
			el->el_line.cursor = el->el_line.lastchar - 1;
		else
			el->el_line.cursor = el->el_line.lastchar;
	}

	/* first we must find where the cursor is... */
	h = el->el_prompt.p_pos.h;
	v = el->el_prompt.p_pos.v;
	th = el->el_terminal.t_size.h;	/* optimize for speed */

	/* do input buffer to el->el_line.cursor */
	for (cp = el->el_line.buffer; cp < el->el_line.cursor; cp++) {
                switch (ct_chr_class(*cp)) {
		case CHTYPE_NL:  /* handle newline in data part too */
			h = 0;
			v++;
			break;
		case CHTYPE_TAB: /* if a tab, to next tab stop */
			while (++h & 07)
				continue;
			break;
		default:
			w = wcwidth(*cp);
			if (w > 1 && h + w > th) { /* won't fit on line */
				h = 0;
				v++;
			}
			h += ct_visual_width(*cp);
			break;
                }

		if (h >= th) {	/* check, extra long tabs picked up here also */
			h -= th;
			v++;
		}
	}
        /* if we have a next character, and it's a doublewidth one, we need to
         * check whether we need to linebreak for it to fit */
        if (cp < el->el_line.lastchar && (w = wcwidth(*cp)) > 1)
                if (h + w > th) {
                    h = 0;
                    v++;
                }

	/* now go there */
	terminal_move_to_line(el, v);
	terminal_move_to_char(el, h);
	terminal__flush(el);
}


/* re_fastputc():
 *	Add a character fast.
 */
static void
re_fastputc(EditLine *el, wint_t c)
{
	wchar_t *lastline;
	int w;

	w = wcwidth(c);
	while (w > 1 && el->el_cursor.h + w > el->el_terminal.t_size.h)
	    re_fastputc(el, ' ');

	terminal__putc(el, c);
	el->el_display[el->el_cursor.v][el->el_cursor.h++] = c;
	while (--w > 0)
		el->el_display[el->el_cursor.v][el->el_cursor.h++]
			= MB_FILL_CHAR;

	if (el->el_cursor.h >= el->el_terminal.t_size.h) {
		/* if we must overflow */
		el->el_cursor.h = 0;

		/*
		 * If we would overflow (input is longer than terminal size),
		 * emulate scroll by dropping first line and shuffling the rest.
		 * We do this via pointer shuffling - it's safe in this case
		 * and we avoid memcpy().
		 */
		if (el->el_cursor.v + 1 >= el->el_terminal.t_size.v) {
			int i, lins = el->el_terminal.t_size.v;
			lastline = el->el_display[0];
			for(i = 1; i < lins; i++)
				el->el_display[i - 1] = el->el_display[i];
			el->el_display[i - 1] = lastline;
		} else {
			el->el_cursor.v++;
			lastline = el->el_display[el->el_refresh.r_oldcv++];
		}
		re__copy_and_pad(lastline, L"", el->el_terminal.t_size.h);

		if (EL_HAS_AUTO_MARGINS) {
			if (EL_HAS_MAGIC_MARGINS) {
				terminal__putc(el, ' ');
				terminal__putc(el, '\b');
			}
		} else {
			terminal__putc(el, '\r');
			terminal__putc(el, '\n');
		}
	}
}


/* re_fastaddc():
 *	we added just one char, handle it fast.
 *	Assumes that screen cursor == real cursor
 */
protected void
re_fastaddc(EditLine *el)
{
	wchar_t c;
	int rhdiff;

	c = el->el_line.cursor[-1];

	if (c == '\t' || el->el_line.cursor != el->el_line.lastchar) {
		re_refresh(el);	/* too hard to handle */
		return;
	}
	rhdiff = el->el_terminal.t_size.h - el->el_cursor.h -
	    el->el_rprompt.p_pos.h;
	if (el->el_rprompt.p_pos.h && rhdiff < 3) {
		re_refresh(el);	/* clear out rprompt if less than 1 char gap */
		return;
	}			/* else (only do at end of line, no TAB) */
	switch (ct_chr_class(c)) {
	case CHTYPE_TAB: /* already handled, should never happen here */
		break;
	case CHTYPE_NL:
	case CHTYPE_PRINT:
		re_fastputc(el, c);
		break;
	case CHTYPE_ASCIICTL:
	case CHTYPE_NONPRINT: {
		wchar_t visbuf[VISUAL_WIDTH_MAX];
		ssize_t i, n =
		    ct_visual_char(visbuf, VISUAL_WIDTH_MAX, c);
		for (i = 0; n-- > 0; ++i)
			re_fastputc(el, visbuf[i]);
		break;
	}
	}
	terminal__flush(el);
}


/* re_clear_display():
 *	clear the screen buffers so that new new prompt starts fresh.
 */
protected void
re_clear_display(EditLine *el)
{
	int i;

	el->el_cursor.v = 0;
	el->el_cursor.h = 0;
	for (i = 0; i < el->el_terminal.t_size.v; i++)
		el->el_display[i][0] = '\0';
	el->el_refresh.r_oldcv = 0;
}


/* re_clear_lines():
 *	Make sure all lines are *really* blank
 */
protected void
re_clear_lines(EditLine *el)
{

	if (EL_CAN_CEOL) {
		int i;
		for (i = el->el_refresh.r_oldcv; i >= 0; i--) {
			/* for each line on the screen */
			terminal_move_to_line(el, i);
			terminal_move_to_char(el, 0);
			terminal_clear_EOL(el, el->el_terminal.t_size.h);
		}
	} else {
		terminal_move_to_line(el, el->el_refresh.r_oldcv);
					/* go to last line */
		terminal__putc(el, '\r');	/* go to BOL */
		terminal__putc(el, '\n');	/* go to new line */
	}
}
@


1.20
log
@typos in comments; from Pedro Giffuni (FreeBSD) via Christos Zoulas (NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: refresh.c,v 1.19 2016/04/11 21:17:29 schwarze Exp $	*/
d1055 4
a1058 1
	int w = wcwidth(c);
d1080 1
a1080 2
			wchar_t *firstline = el->el_display[0];

d1083 1
a1083 3

			re__copy_and_pad(firstline, L"", 0);
			el->el_display[i - 1] = firstline;
d1086 1
a1086 1
			el->el_refresh.r_oldcv++;
d1088 2
@


1.19
log
@delete the "private" and "public" preprocessor macros, just use standard C;
OK martijn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: refresh.c,v 1.18 2016/04/11 20:43:33 schwarze Exp $	*/
/*	$NetBSD: refresh.c,v 1.49 2016/04/11 18:56:31 christos Exp $	*/
d560 1
a560 1
         * find same begining and same end
@


1.18
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: refresh.c,v 1.17 2016/04/11 19:54:54 schwarze Exp $	*/
/*	$NetBSD: refresh.c,v 1.48 2016/04/11 00:50:13 christos Exp $	*/
d47 9
a55 9
private void	re_nextline(EditLine *);
private void	re_addc(EditLine *, wint_t);
private void	re_update_line(EditLine *, wchar_t *, wchar_t *, int);
private void	re_insert (EditLine *, wchar_t *, int, int, wchar_t *, int);
private void	re_delete(EditLine *, wchar_t *, int, int, int);
private void	re_fastputc(EditLine *, wint_t);
private void	re_clear_eol(EditLine *, int, int, int);
private void	re__strncopy(wchar_t *, wchar_t *, size_t);
private void	re__copy_and_pad(wchar_t *, const wchar_t *, size_t);
d58 1
a58 1
private void	re_printstr(EditLine *, const char *, wchar_t *, wchar_t *);
d71 1
a71 1
private void
d88 1
a88 1
private void
d120 1
a120 1
private void
d354 1
a354 1
private void
d405 1
a405 1
private void
d439 1
a439 1
private void
d454 1
a454 1
private void
d498 1
a498 1
private void
d968 1
a968 1
private void
d1052 1
a1052 1
private void
@


1.17
log
@Move wrapper macros to the two files actually needing them:
FUNW, Strlen, Strdup, Strcmp, Strncmp, Strncpy, Strncat -> history.c
Strchr, tok_strdup -> tokenizer.c
FUN, TYPE, STR -> both of these files

OK martijn@@

Also proofread by Christian Heckendorf <mbie at ulmus dot me>
who reported some whitespace issues in parse.c.
@
text
@d1 2
a2 2
/*	$OpenBSD: refresh.c,v 1.16 2016/04/09 20:15:26 schwarze Exp $	*/
/*	$NetBSD: refresh.c,v 1.46 2016/04/09 18:43:17 christos Exp $	*/
d49 3
a51 3
private void	re_update_line(EditLine *, Char *, Char *, int);
private void	re_insert (EditLine *, Char *, int, int, Char *, int);
private void	re_delete(EditLine *, Char *, int, int, int);
d54 2
a55 2
private void	re__strncopy(Char *, Char *, size_t);
private void	re__copy_and_pad(Char *, const Char *, size_t);
d58 1
a58 1
private void	re_printstr(EditLine *, const char *, Char *, Char *);
d72 1
a72 1
re_printstr(EditLine *el, const char *str, Char *f, Char *t)
d101 1
a101 1
		Char *firstline = el->el_vdisplay[0];
d123 1
a123 1
	switch (ct_chr_class((Char)c)) {
d142 1
a142 1
		Char visbuf[VISUAL_WIDTH_MAX];
d144 1
a144 1
		    ct_visual_char(visbuf, VISUAL_WIDTH_MAX, (Char)c);
d198 1
a198 1
	Char *cp, *st;
d357 1
a357 1
    Char *d, int dat, int dlen, Char *s, int num)
d359 1
a359 1
	Char *a, *b;
d408 1
a408 1
    Char *d, int dat, int dlen, int num)
d410 1
a410 1
	Char *a, *b;
d440 1
a440 1
re__strncopy(Char *a, Char *b, size_t n)
d499 1
a499 1
re_update_line(EditLine *el, Char *old, Char *new, int i)
d501 3
a503 3
	Char *o, *n, *p, c;
	Char *ofd, *ols, *oe, *nfd, *nls, *ne;
	Char *osb, *ose, *nsb, *nse;
d969 1
a969 1
re__copy_and_pad(Char *dst, const Char *src, size_t width)
d992 1
a992 1
	Char *cp;
d1055 1
a1055 1
	int w = wcwidth((Char)c);
d1077 1
a1077 1
			Char *firstline = el->el_display[0];
d1108 1
a1108 1
	Char c;
d1132 1
a1132 1
		Char visbuf[VISUAL_WIDTH_MAX];
d1134 1
a1134 1
		    ct_visual_char(visbuf, VISUAL_WIDTH_MAX, (Char)c);
@


1.16
log
@Delete 26 wrapper macros and two wrapper functions that are no
longer needed now that we always compile with wide character support,
reducing code obfuscation.

OK czarkoff@@ martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: refresh.c,v 1.15 2016/03/22 11:32:18 schwarze Exp $	*/
d318 2
a319 2
                        /* This Strlen should be safe even with MB_FILL_CHARs */
			terminal_clear_EOL(el, (int) Strlen(el->el_display[i]));
d321 1
a321 1
			terminal_overwrite(el, STR("C\b"), 2);
d1082 1
a1082 1
			re__copy_and_pad(firstline, STR(""), 0);
@


1.15
log
@format string fixes in debug code;
committing right away because this code is not even compiled by default
@
text
@d1 2
a2 2
/*	$OpenBSD: refresh.c,v 1.14 2016/03/20 23:48:27 schwarze Exp $	*/
/*	$NetBSD: refresh.c,v 1.45 2016/03/02 19:24:20 christos Exp $	*/
d159 1
a159 1
	int i, w = Width(c);
d161 2
d204 1
a204 1
	ELRE_DEBUG(1, (__F, "el->el_line.buffer = :" FSTR ":\r\n",
d250 1
a250 1
                        int w = Width(*cp);
d1020 1
a1020 1
			w = Width(*cp);
d1036 1
a1036 1
        if (cp < el->el_line.lastchar && (w = Width(*cp)) > 1)
d1055 1
a1055 1
	int w = Width((Char)c);
@


1.14
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: refresh.c,v 1.13 2016/03/20 20:35:38 schwarze Exp $	*/
/*	$NetBSD: refresh.c,v 1.44 2016/02/17 19:47:49 christos Exp $	*/
d58 1
a58 1
private void	re_printstr(EditLine *, const char *, char *, char *);
d72 1
a72 1
re_printstr(EditLine *el, const char *str, char *f, char *t)
d202 1
a202 1
	ELRE_DEBUG(1, (__F, "el->el_line.buffer = :%s:\r\n",
d290 2
a291 1
		el->el_refresh.r_cursor.v, ct_encode_string(el->el_vdisplay[0])));
d319 1
a319 1
			terminal_overwrite(el, "C\b", (size_t)2);
d366 3
a368 2
	    num, dat, dlen, ct_encode_string(d)));
	ELRE_DEBUG(1, (__F, "s == \"%s\"\n", ct_encode_string(s)));
d381 3
a383 2
		num, dat, dlen, ct_encode_string(d)));
	ELRE_DEBUG(1, (__F, "s == \"%s\"\n", ct_encode_string(s)));
d418 1
a418 1
	    num, dat, dlen, ct_encode_string(d)));
d430 1
a430 1
	    num, dat, dlen, ct_encode_string(d)));
d688 1
a688 1
	ELRE_DEBUG(1, (__F, "ofd %d, osb %d, ose %d, ols %d, oe %d\n",
d690 1
a690 1
	ELRE_DEBUG(1, (__F, "nfd %d, nsb %d, nse %d, nls %d, ne %d\n",
d764 1
a764 1
		    (__F, "first diff insert at %d...\r\n", nfd - new));
d803 1
a803 1
		    (__F, "first diff delete at %d...\r\n", ofd - old));
d850 1
a850 1
		    "second diff delete at %d...\r\n", (ose - old) + fx));
d888 1
a888 1
		ELRE_DEBUG(1, (__F, "late first diff insert at %d...\r\n",
@


1.13
log
@Delete the useless Int datatype and always use the standard wint_t
directly.  This is not a problem because <wchar_t> is required all
over the place anyway, even when WIDECHAR is not defined.
No functional change except that it fixes a few printf(3)
format string issues, %c vs. %lc.
OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: refresh.c,v 1.12 2016/01/30 00:06:39 schwarze Exp $	*/
/*	$NetBSD: refresh.c,v 1.37 2011/07/29 23:44:45 christos Exp $	*/
d42 1
a42 1
#include <ctype.h>
a43 1
#include <string.h>
d60 1
a60 1
#define	ELRE_ASSERT(a, b, c)	do 				\
d106 1
a106 1
		firstline[0] = '\0';		/* empty the string */	
d188 1
a188 1
 *  	line, then goes line-by-line changing the real image to the new
d447 1
a447 1
 * 	number of characters between the new and old line.
d1073 1
a1073 1
	
@


1.12
log
@Third step in synching with NetBSD:
* rename fkey_t to funckey_t and el_term_t to el_terminal_t
* rename struct editline member el_term to el_terminal
* rename many functions in terminal.c from term_*() to terminal_*(),
for consistency with the file name and to not look related to <term.h>
No functional change.
This makes refresh.c and sig.c almost identical to the NetBSD versions.
It reduces the remaining diff from +2446 -1805 to +2053 -1420.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: refresh.c,v 1.11 2010/06/30 00:05:35 nicm Exp $	*/
d49 1
a49 1
private void	re_addc(EditLine *, Int);
d53 1
a53 1
private void	re_fastputc(EditLine *, Int);
d122 1
a122 1
re_addc(EditLine *el, Int c)
d158 1
a158 1
re_putc(EditLine *el, Int c, int shift)
d161 1
a161 1
	ELRE_DEBUG(1, (__F, "printing %5x '%c'\r\n", c, c));
d1049 1
a1049 1
re_fastputc(EditLine *el, Int c)
@


1.11
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: refresh.c,v 1.35 2009/12/30 22:37:40 christos Exp $	*/
d100 2
a101 2
	if (el->el_refresh.r_cursor.v + 1 >= el->el_term.t_size.v) {
		int i, lins = el->el_term.t_size.v;
d112 1
a112 1
	ELRE_ASSERT(el->el_refresh.r_cursor.v >= el->el_term.t_size.v,
d114 1
a114 1
	    el->el_refresh.r_cursor.v, el->el_term.t_size.v),
d163 1
a163 1
	while (shift && (el->el_refresh.r_cursor.h + w > el->el_term.t_size.h))
d178 1
a178 1
	if (el->el_refresh.r_cursor.h >= el->el_term.t_size.h) {
d180 1
a180 1
		el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_term.t_size.h]
d232 1
a232 1
	termsz = el->el_term.t_size.h * el->el_term.t_size.v;
d241 2
a242 2
			- (termsz - (((rem / el->el_term.t_size.v) - 1)
					* el->el_term.t_size.v));
d255 1
a255 1
			    el->el_term.t_size.h) {
d267 1
a267 1
	rhdiff = el->el_term.t_size.h - el->el_refresh.r_cursor.h -
d290 1
a290 1
		el->el_term.t_size.h, el->el_refresh.r_cursor.h,
d306 1
a306 1
		    (size_t) el->el_term.t_size.h);
d314 2
a315 2
			term_move_to_line(el, i);
			term_move_to_char(el, 0);
d317 1
a317 1
			term_clear_EOL(el, (int) Strlen(el->el_display[i]));
d319 1
a319 1
			term_overwrite(el, "C\b", (size_t)2);
d329 2
a330 2
	term_move_to_line(el, cur.v);	/* go to where the cursor is */
	term_move_to_char(el, cur.h);
d341 2
a342 2
	term_move_to_line(el, el->el_refresh.r_oldcv);
	term__putc(el, '\n');
d344 1
a344 1
	term__flush(el);
d467 1
a467 1
	term_clear_EOL(el, diff);
d714 1
a714 1
	term_move_to_line(el, i);
d738 1
a738 1
	 * of the screen (el->el_term.t_size.h) else we do the deletes first
d760 1
a760 1
	    ((p - old) + fx <= el->el_term.t_size.h)) {
d766 1
a766 1
		term_move_to_char(el, (int)(nfd - new));
d778 1
a778 1
				term_insertwrite(el, nfd, fx);
d780 1
a780 1
				    el->el_term.t_size.h, nfd, fx);
d787 1
a787 1
			term_overwrite(el, (nfd + fx), len);
d792 1
a792 1
			term_overwrite(el, nfd, len);
d805 1
a805 1
		term_move_to_char(el, (int)(ofd - old));
d818 1
a818 1
				term_deletechars(el, -fx);
d820 1
a820 1
				    el->el_term.t_size.h, -fx);
d826 1
a826 1
			term_overwrite(el, nfd, len);
d835 1
a835 1
			term_overwrite(el, nfd, (size_t)(nsb - nfd));
d846 1
a846 1
	if (sx < 0 && (ose - old) + fx < el->el_term.t_size.h) {
d856 1
a856 1
		term_move_to_char(el, (int)((ose - old) + fx));
d868 1
a868 1
				term_deletechars(el, -sx);
d873 1
a873 1
			term_overwrite(el, nse, (size_t)(nls - nse));
d877 1
a877 1
			term_overwrite(el, nse, (size_t)(nls - nse));
d889 1
a889 1
		term_move_to_char(el, (int)(nfd - new));
d907 1
a907 1
				term_insertwrite(el, nfd, fx);
d909 1
a909 1
				    el->el_term.t_size.h, nfd, fx);
d916 1
a916 1
			term_overwrite(el, (nfd + fx), len);
d921 1
a921 1
			term_overwrite(el, nfd, len);
d931 1
a931 1
		term_move_to_char(el, (int)(nse - new));
d938 1
a938 1
				term_insertwrite(el, nse, sx);
d944 1
a944 1
			term_overwrite(el, (nse + sx),
d948 1
a948 1
			term_overwrite(el, nse, (size_t)(nls - nse));
d1002 1
a1002 1
	th = el->el_term.t_size.h;	/* optimize for speed */
d1039 3
a1041 3
	term_move_to_line(el, v);
	term_move_to_char(el, h);
	term__flush(el);
d1052 1
a1052 1
	while (w > 1 && el->el_cursor.h + w > el->el_term.t_size.h)
d1055 1
a1055 1
	term__putc(el, c);
d1061 1
a1061 1
	if (el->el_cursor.h >= el->el_term.t_size.h) {
d1071 2
a1072 2
		if (el->el_cursor.v + 1 >= el->el_term.t_size.v) {
			int i, lins = el->el_term.t_size.v;
d1086 2
a1087 2
				term__putc(el, ' ');
				term__putc(el, '\b');
d1090 2
a1091 2
			term__putc(el, '\r');
			term__putc(el, '\n');
d1113 1
a1113 1
	rhdiff = el->el_term.t_size.h - el->el_cursor.h -
d1136 1
a1136 1
	term__flush(el);
d1150 1
a1150 1
	for (i = 0; i < el->el_term.t_size.v; i++)
d1167 3
a1169 3
			term_move_to_line(el, i);
			term_move_to_char(el, 0);
			term_clear_EOL(el, el->el_term.t_size.h);
d1172 1
a1172 1
		term_move_to_line(el, el->el_refresh.r_oldcv);
d1174 2
a1175 2
		term__putc(el, '\r');	/* go to BOL */
		term__putc(el, '\n');	/* go to new line */
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
a2 2
/*	$OpenBSD: refresh.c,v 1.9 2003/10/31 08:42:24 otto Exp $	*/
/*	$NetBSD: refresh.c,v 1.26 2003/08/07 16:44:33 agc Exp $	*/
d48 9
a56 7
private void	re_addc(EditLine *, int);
private void	re_update_line(EditLine *, char *, char *, int);
private void	re_insert (EditLine *, char *, int, int, char *, int);
private void	re_delete(EditLine *, char *, int, int, int);
private void	re_fastputc(EditLine *, int);
private void	re__strncopy(char *, char *, size_t);
private void	re__copy_and_pad(char *, const char *, size_t);
d86 31
d122 1
a122 1
re_addc(EditLine *el, int c)
d124 2
a125 15

	if (isprint(c)) {
		re_putc(el, c, 1);
		return;
	}
	if (c == '\n') {				/* expand the newline */
		int oldv = el->el_refresh.r_cursor.v;
		re_putc(el, '\0', 0);			/* assure end of line */
		if (oldv == el->el_refresh.r_cursor.v) { /* XXX */
			el->el_refresh.r_cursor.h = 0;	/* reset cursor pos */
			el->el_refresh.r_cursor.v++;
		}
		return;
	}
	if (c == '\t') {				/* expand the tab */
d131 19
a149 12
	} else if (iscntrl(c)) {
		re_putc(el, '^', 1);
		if (c == '\177')
			re_putc(el, '?', 1);
		else
		    /* uncontrolify it; works only for iso8859-1 like sets */
			re_putc(el, (c | 0100), 1);
	} else {
		re_putc(el, '\\', 1);
		re_putc(el, (int) ((((unsigned int) c >> 6) & 07) + '0'), 1);
		re_putc(el, (int) ((((unsigned int) c >> 3) & 07) + '0'), 1);
		re_putc(el, (c & 07) + '0', 1);
d158 1
a158 1
re_putc(EditLine *el, int c, int shift)
d160 2
d163 10
a172 1
	ELRE_DEBUG(1, (__F, "printing %3.3o '%c'\r\n", c, c));
a173 1
	el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_refresh.r_cursor.h] = c;
d177 1
a177 1
	el->el_refresh.r_cursor.h++;	/* advance to next place */
a178 1
		el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_term.t_size.h] = '\0';
d180 3
a182 24
		el->el_refresh.r_cursor.h = 0;	/* reset it. */

		/*
		 * If we would overflow (input is longer than terminal size),
		 * emulate scroll by dropping first line and shuffling the rest.
		 * We do this via pointer shuffling - it's safe in this case
		 * and we avoid memcpy().
		 */
		if (el->el_refresh.r_cursor.v + 1 >= el->el_term.t_size.v) {
			int i, lins = el->el_term.t_size.v;
			char *firstline = el->el_vdisplay[0];

			for(i=1; i < lins; i++)
				el->el_vdisplay[i-1] = el->el_vdisplay[i];

			firstline[0] = '\0';		/* empty the string */	
			el->el_vdisplay[i-1] = firstline;
		} else
			el->el_refresh.r_cursor.v++;

		ELRE_ASSERT(el->el_refresh.r_cursor.v >= el->el_term.t_size.v,
		    (__F, "\r\nre_putc: overflow! r_cursor.v == %d > %d\r\n",
		    el->el_refresh.r_cursor.v, el->el_term.t_size.v),
		    abort());
d197 1
a197 1
	char *cp, *st;
d249 1
d253 6
d260 1
a260 1
		re_addc(el, (unsigned char) *cp);
d291 1
a291 1
		el->el_refresh.r_cursor.v, el->el_vdisplay[0]));
d316 2
a317 1
			term_clear_EOL(el, (int) strlen(el->el_display[i]));
d319 1
a319 1
			term_overwrite(el, "C\b", 2);
d342 1
a342 1
	term__putc('\n');
d344 1
a344 1
	term__flush();
d355 1
a355 1
    char *d, int dat, int dlen, char *s, int num)
d357 1
a357 1
	char *a, *b;
d366 2
a367 2
	    num, dat, dlen, d));
	ELRE_DEBUG(1, (__F, "s == \"%s\"n", s));
d377 1
d380 2
a381 2
		num, dat, dlen, d));
	ELRE_DEBUG(1, (__F, "s == \"%s\"n", s));
d387 3
d393 2
a394 1
	ELRE_DEBUG(1, (__F, "s == \"%s\"n", s));
d404 1
a404 1
    char *d, int dat, int dlen, int num)
d406 1
a406 1
	char *a, *b;
d416 1
a416 1
	    num, dat, dlen, d));
d428 1
a428 1
	    num, dat, dlen, d));
d436 1
a436 1
re__strncopy(char *a, char *b, size_t n)
d443 26
d495 1
a495 1
re_update_line(EditLine *el, char *old, char *new, int i)
d497 3
a499 3
	char *o, *n, *p, c;
	char *ofd, *ols, *oe, *nfd, *nls, *ne;
	char *osb, *ose, *nsb, *nse;
d501 1
d628 1
a628 1
	fx = (nsb - nfd) - (osb - ofd);
d633 1
a633 1
	sx = (nls - nse) - (ols - ose);
d682 2
a683 2
	fx = (nsb - nfd) - (osb - ofd);
	sx = (nls - nse) - (ols - ose);
d685 1
a685 1
	ELRE_DEBUG(1, (__F, "\n"));
d766 1
a766 1
		term_move_to_char(el, nfd - new);
d779 1
a779 1
				re_insert(el, old, ofd - old,
d786 3
a788 3
			term_overwrite(el, nfd + fx, (nsb - nfd) - fx);
			re__strncopy(ofd + fx, nfd + fx,
			    (size_t) ((nsb - nfd) - fx));
d791 3
a793 2
			term_overwrite(el, nfd, (nsb - nfd));
			re__strncopy(ofd, nfd, (size_t) (nsb - nfd));
d805 1
a805 1
		term_move_to_char(el, ofd - old);
d819 1
a819 1
				re_delete(el, old, ofd - old,
d825 3
a827 2
			term_overwrite(el, nfd, (nsb - nfd));
			re__strncopy(ofd, nfd, (size_t) (nsb - nfd));
d835 3
a837 4
			term_overwrite(el, nfd, (nsb - nfd));
			ELRE_DEBUG(1, (__F,
			    "cleareol %d\n", (oe - old) - (ne - new)));
			term_clear_EOL(el, (oe - old) - (ne - new));
d856 1
a856 1
		term_move_to_char(el, (ose - old) + fx);
d873 1
a873 1
			term_overwrite(el, nse, (nls - nse));
d877 3
a879 5
			term_overwrite(el, nse, (nls - nse));
			ELRE_DEBUG(1, (__F,
			    "cleareol %d\n", (oe - old) - (ne - new)));
			if ((oe - old) - (ne - new) != 0)
				term_clear_EOL(el, (oe - old) - (ne - new));
d889 1
a889 1
		term_move_to_char(el, nfd - new);
d900 1
a900 1
			fx = (nsb - nfd) - (osb - ofd);
d908 1
a908 1
				re_insert(el, old, ofd - old,
d915 3
a917 3
			term_overwrite(el, nfd + fx, (nsb - nfd) - fx);
			re__strncopy(ofd + fx, nfd + fx,
			    (size_t) ((nsb - nfd) - fx));
d920 3
a922 2
			term_overwrite(el, nfd, (nsb - nfd));
			re__strncopy(ofd, nfd, (size_t) (nsb - nfd));
d930 2
a931 2
		    "second diff insert at %d...\r\n", nse - new));
		term_move_to_char(el, nse - new);
d944 2
a945 1
			term_overwrite(el, nse + sx, (nls - nse) - sx);
d948 1
a948 1
			term_overwrite(el, nse, (nls - nse));
d965 1
a965 1
re__copy_and_pad(char *dst, const char *src, size_t width)
d988 2
a989 2
	char *cp, c;
	int h, v, th;
d1006 2
a1007 4
		c = *cp;
		h++;		/* all chars at least this long */

		if (c == '\n') {/* handle newline in data part too */
d1010 10
a1019 18
		} else {
			if (c == '\t') {	/* if a tab, to next tab stop */
				while (h & 07) {
					h++;
				}
			} else if (iscntrl((unsigned char) c)) {
						/* if control char */
				h++;
				if (h > th) {	/* if overflow, compensate */
					h = 1;
					v++;
				}
			} else if (!isprint((unsigned char) c)) {
				h += 3;
				if (h > th) {	/* if overflow, compensate */
					h = h - th;
					v++;
				}
d1021 3
a1023 1
		}
d1026 1
a1026 1
			h = 0;
d1030 7
d1041 1
a1041 1
	term__flush();
d1049 1
a1049 1
re_fastputc(EditLine *el, int c)
d1051 3
d1055 1
a1055 1
	term__putc(c);
d1057 4
d1073 1
a1073 1
			char *firstline = el->el_display[0];
d1075 2
a1076 2
			for(i=1; i < lins; i++)
				el->el_display[i-1] = el->el_display[i];
d1078 2
a1079 2
			re__copy_and_pad(firstline, "", 0);
			el->el_display[i-1] = firstline;
d1086 2
a1087 2
				term__putc(' ');
				term__putc('\b');
d1090 2
a1091 2
			term__putc('\r');
			term__putc('\n');
d1104 1
a1104 1
	char c;
d1119 5
a1123 5
	if (iscntrl((unsigned char) c)) {	/* if control char, do caret */
		char mc = (c == '\177') ? '?' : (c | 0100);
		re_fastputc(el, '^');
		re_fastputc(el, mc);
	} else if (isprint((unsigned char) c)) {	/* normal char */
d1125 10
a1134 5
	} else {
		re_fastputc(el, '\\');
		re_fastputc(el, (int)(((((unsigned int)c) >> 6) & 3) + '0'));
		re_fastputc(el, (int)(((((unsigned int)c) >> 3) & 7) + '0'));
		re_fastputc(el, (c & 7) + '0');
d1136 1
a1136 1
	term__flush();
d1165 1
a1165 2
		term_move_to_char(el, 0);
		for (i = 0; i <= el->el_refresh.r_oldcv; i++) {
d1168 1
a1170 1
		term_move_to_line(el, 0);
d1174 2
a1175 2
		term__putc('\r');	/* go to BOL */
		term__putc('\n');	/* go to new line */
@


1.9
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 7
#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)refresh.c	8.1 (Berkeley) 6/4/93";
#else
static const char rcsid[] = "$OpenBSD$";
#endif
#endif /* not lint && not SCCSID */
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: refresh.c,v 1.7 2003/05/01 21:11:21 avsm Exp $	*/
/*	$NetBSD: refresh.c,v 1.2 1997/01/11 06:48:07 lukem Exp $	*/
d36 1
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: refresh.c,v 1.7 2003/05/01 21:11:21 avsm Exp $";
a47 1
#include "sys.h"
d55 7
a61 8
private	void	re_addc(EditLine *, int);
private	void	re_update_line(EditLine *, char *, char *, int);
private	void	re_insert(EditLine *, char *, int, int, char *, int);
private	void	re_delete(EditLine *, char *, int, int, int);
private	void	re_fastputc(EditLine *, int);

private	void	re__strncopy(char *, char *, size_t);
private	void	re__copy_and_pad(char *, char *, size_t);
d64 5
a68 5
private	void	re_printstr(EditLine *, char *, char *, char *);
# define __F el->el_errfile
# define RE_DEBUG(a, b, c)	do 				\
				    if (a) {			\
					(void)fprintf b;	\
d71 3
a73 1
				while (0)
d78 8
a85 10
re_printstr(el, str, f, t)
    EditLine *el;
    char *str;
    char *f, *t;
{
    RE_DEBUG(1,(__F, "%s:\"", str),);
    while (f < t)
	RE_DEBUG(1,(__F, "%c", *f++ & 0177),);
    RE_DEBUG(1,(__F, "\"\r\n"),);
} 
d87 2
a88 1
# define RE_DEBUG(a, b, c)
d96 36
a131 36
re_addc(el, c)
    EditLine *el;
    int c;
{
    if (isprint(c)) {
	re_putc(el, c);
	return;
    }
    if (c == '\n') {			/* expand the newline	 */
	re_putc(el, '\0');		/* assure end of line	 */
	el->el_refresh.r_cursor.h = 0;	/* reset cursor pos	 */
	el->el_refresh.r_cursor.v++;
	return;
    }
    if (c == '\t') {		/* expand the tab 	 */
	for (;;) {
	    re_putc(el, ' ');
	    if ((el->el_refresh.r_cursor.h & 07) == 0)
		break;		/* go until tab stop	 */
	}
    }
    else if (iscntrl(c)) {
	re_putc(el, '^');
	if (c == '\177') 
	    re_putc(el, '?');
	else 
	    /* uncontrolify it; works only for iso8859-1 like sets */
	    re_putc(el, (c | 0100));
    }
    else {
	re_putc(el, '\\');
	re_putc(el, ((c >> 6) & 07) + '0');
	re_putc(el, ((c >> 3) & 07) + '0');
	re_putc(el, (c & 07) + '0');
    }
} /* end re_addc */
d138 39
a176 18
re_putc(el, c)
    EditLine *el;
    int c;
{
    RE_DEBUG(1,(__F, "printing %3.3o '%c'\r\n", c, c),);

    el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_refresh.r_cursor.h] = c;
    el->el_refresh.r_cursor.h++;				/* advance to next place */
    if (el->el_refresh.r_cursor.h >= el->el_term.t_size.h) {
	el->el_vdisplay[el->el_refresh.r_cursor.v][el->el_term.t_size.h] = '\0';	
						/* assure end of line */
	el->el_refresh.r_cursor.h = 0;				/* reset it. */
	el->el_refresh.r_cursor.v++;
	RE_DEBUG(el->el_refresh.r_cursor.v >= el->el_term.t_size.v, 
		 (__F, "\r\nre_putc: overflow! r_cursor.v == %d > %d\r\n",
		  el->el_refresh.r_cursor.v, el->el_term.t_size.v), abort());
    }
} /* end re_putc */
d186 1
a186 2
re_refresh(el)
    EditLine *el;
d188 114
a301 60
    int i;
    char *cp;
    coord_t     cur;

    RE_DEBUG(1,(__F, "el->el_line.buffer = :%s:\r\n", el->el_line.buffer),);

    /* reset the Drawing cursor */
    el->el_refresh.r_cursor.h = 0;
    el->el_refresh.r_cursor.v = 0;

    cur.h = -1;			/* set flag in case I'm not set */
    cur.v = 0;

    prompt_print(el);

    /* draw the current input buffer */
    for (cp = el->el_line.buffer; cp < el->el_line.lastchar; cp++) {
	if (cp == el->el_line.cursor) {
	    cur.h = el->el_refresh.r_cursor.h;	/* save for later */
	    cur.v = el->el_refresh.r_cursor.v;
	}
	re_addc(el, *cp);
    }

    if (cur.h == -1) {		/* if I haven't been set yet, I'm at the end */
	cur.h = el->el_refresh.r_cursor.h;
	cur.v = el->el_refresh.r_cursor.v;
    }
    /* must be done BEFORE the NUL is written */
    el->el_refresh.r_newcv = el->el_refresh.r_cursor.v;	
    re_putc(el, '\0');		/* put NUL on end */

    RE_DEBUG(1,(__F, 
	     "term.h=%d vcur.h=%d vcur.v=%d vdisplay[0]=\r\n:%80.80s:\r\n",
	     el->el_term.t_size.h, el->el_refresh.r_cursor.h, 
	     el->el_refresh.r_cursor.v, el->el_vdisplay[0]),);

    RE_DEBUG(1,(__F, "updating %d lines.\r\n", el->el_refresh.r_newcv),);
    for (i = 0; i <= el->el_refresh.r_newcv; i++) {
	/* NOTE THAT re_update_line MAY CHANGE el_display[i] */
	re_update_line(el, el->el_display[i], el->el_vdisplay[i], i);

	/*
	 * Copy the new line to be the current one, and pad out with spaces
	 * to the full width of the terminal so that if we try moving the
	 * cursor by writing the character that is at the end of the
	 * screen line, it won't be a NUL or some old leftover stuff.
	 */
	re__copy_and_pad(el->el_display[i], el->el_vdisplay[i], 
			el->el_term.t_size.h);
    }
    RE_DEBUG(1,(__F,
	 "\r\nel->el_refresh.r_cursor.v=%d,el->el_refresh.r_oldcv=%d i=%d\r\n",
	 el->el_refresh.r_cursor.v, el->el_refresh.r_oldcv, i),);

    if (el->el_refresh.r_oldcv > el->el_refresh.r_newcv) 
	for (; i <= el->el_refresh.r_oldcv; i++) {
	    term_move_to_line(el, i);
	    term_move_to_char(el, 0);
	    term_clear_EOL(el, strlen(el->el_display[i]));
d303 1
a303 1
	    term_overwrite(el, "C\b", 2);
d305 11
a315 11
	    *el->el_display[i] = '\0';
	}
    
    el->el_refresh.r_oldcv = el->el_refresh.r_newcv;	/* set for next time */
    RE_DEBUG(1,(__F, 
		"\r\ncursor.h = %d, cursor.v = %d, cur.h = %d, cur.v = %d\r\n",
		el->el_refresh.r_cursor.h, el->el_refresh.r_cursor.v, 
		cur.h, cur.v),);
    term_move_to_line(el, cur.v);		/* go to where the cursor is */
    term_move_to_char(el, cur.h);
} /* end re_refresh */
d319 1
a319 1
 *	 used to go to last used screen line 
d322 1
a322 2
re_goto_bottom(el)
    EditLine *el;
d324 6
a329 6
    term_move_to_line(el, el->el_refresh.r_oldcv);
    term__putc('\r');
    term__putc('\n');
    re_clear_display(el);
    term__flush();
} /* end re_goto_bottom */
d334 1
a334 1
 *	at dat, maximum length of d is dlen 
d338 24
a361 27
re_insert(el, d, dat, dlen, s, num)
    EditLine *el;
    char *d;
    int dat, dlen;
    char *s;
    int num;
{
    char *a, *b;

    if (num <= 0)
	return;
    if (num > dlen - dat)
	num = dlen - dat;

    RE_DEBUG(1,(__F, "re_insert() starting: %d at %d max %d, d == \"%s\"\n",
	    num, dat, dlen, d),);
    RE_DEBUG(1,(__F, "s == \"%s\"n", s),);

    /* open up the space for num chars */
    if (num > 0) {
	b = d + dlen - 1;
	a = b - num;
	while (a >= &d[dat])
	    *b-- = *a--;
	d[dlen] = '\0';		/* just in case */
    }
    RE_DEBUG(1,(__F, 
d363 2
a364 2
		num, dat, dlen, d),);
    RE_DEBUG(1,(__F, "s == \"%s\"n", s),);
d366 9
a374 8
    /* copy the characters */
    for (a = d + dat; (a < d + dlen) && (num > 0); num--)
	*a++ = *s++;

    RE_DEBUG(1,(__F, "re_insert() after copy: %d at %d max %d, %s == \"%s\"\n",
	     num, dat, dlen, d, s),);
    RE_DEBUG(1,(__F, "s == \"%s\"n", s),);
} /* end re_insert */
d378 1
a378 1
 *	delete num characters d at dat, maximum length of d is dlen 
d382 27
a408 28
re_delete(el, d, dat, dlen, num)
    EditLine *el;
    char *d;
    int dat, dlen, num;
{
    char *a, *b;

    if (num <= 0)
	return;
    if (dat + num >= dlen) {
	d[dat] = '\0';
	return;
    }

    RE_DEBUG(1,(__F, "re_delete() starting: %d at %d max %d, d == \"%s\"\n",
	    num, dat, dlen, d),);

    /* open up the space for num chars */
    if (num > 0) {
	b = d + dat;
	a = b + num;
	while (a < &d[dlen])
	    *b++ = *a++;
	d[dlen] = '\0';		/* just in case */
    }
    RE_DEBUG(1,(__F, "re_delete() after delete: %d at %d max %d, d == \"%s\"\n",
	    num, dat, dlen, d),);
} /* end re_delete */
d415 1
a415 3
re__strncopy(a, b, n)
    char *a, *b;
    size_t n;
a416 3
    while (n-- && *b)
	*a++ = *b++;
} /* end re__strncopy */
d418 3
d422 2
a423 1
/* ****************************************************************
d445 1
a445 1
#define MIN_END_KEEP	4
d448 62
a509 180
re_update_line(el, old, new, i)
    EditLine *el;
    char *old, *new;
    int     i;
{
    char *o, *n, *p, c;
    char   *ofd, *ols, *oe, *nfd, *nls, *ne;
    char   *osb, *ose, *nsb, *nse;
    int     fx, sx;

    /*
     * find first diff
     */
    for (o = old, n = new; *o && (*o == *n); o++, n++)
	continue;
    ofd = o;
    nfd = n;

    /*
     * Find the end of both old and new
     */
    while (*o)
	o++;
    /* 
     * Remove any trailing blanks off of the end, being careful not to
     * back up past the beginning.
     */
    while (ofd < o) {
	if (o[-1] != ' ')
	    break;
	o--;
    }
    oe = o;
    *oe = '\0';
  
    while (*n)
	n++;

    /* remove blanks from end of new */
    while (nfd < n) {
	if (n[-1] != ' ')
	    break;
	n--;
    }
    ne = n;
    *ne = '\0';
  
    /*
     * if no diff, continue to next line of redraw
     */
    if (*ofd == '\0' && *nfd == '\0') {
	RE_DEBUG(1,(__F, "no difference.\r\n"),);
	return;
    }

    /*
     * find last same pointer
     */
    while ((o > ofd) && (n > nfd) && (*--o == *--n))
	continue;
    ols = ++o;
    nls = ++n;

    /*
     * find same begining and same end
     */
    osb = ols;
    nsb = nls;
    ose = ols;
    nse = nls;

    /*
     * case 1: insert: scan from nfd to nls looking for *ofd
     */
    if (*ofd) {
	for (c = *ofd, n = nfd; n < nls; n++) {
	    if (c == *n) {
		for (o = ofd, p = n; p < nls && o < ols && *o == *p; o++, p++)
		    continue;
		/*
		 * if the new match is longer and it's worth keeping, then we
		 * take it
		 */
		if (((nse - nsb) < (p - n)) && (2 * (p - n) > n - nfd)) {
		    nsb = n;
		    nse = p;
		    osb = ofd;
		    ose = o;
		}
	    }
	}
    }

    /*
     * case 2: delete: scan from ofd to ols looking for *nfd
     */
    if (*nfd) {
	for (c = *nfd, o = ofd; o < ols; o++) {
	    if (c == *o) {
		for (n = nfd, p = o; p < ols && n < nls && *p == *n; p++, n++)
		    continue;
		/*
		 * if the new match is longer and it's worth keeping, then we
		 * take it
		 */
		if (((ose - osb) < (p - o)) && (2 * (p - o) > o - ofd)) {
		    nsb = nfd;
		    nse = n;
		    osb = o;
		    ose = p;
		}
	    }
	}
    }

    /*
     * Pragmatics I: If old trailing whitespace or not enough characters to
     * save to be worth it, then don't save the last same info.
     */
    if ((oe - ols) < MIN_END_KEEP) {
	ols = oe;
	nls = ne;
    }

    /*
     * Pragmatics II: if the terminal isn't smart enough, make the data dumber
     * so the smart update doesn't try anything fancy
     */

    /*
     * fx is the number of characters we need to insert/delete: in the
     * beginning to bring the two same begins together
     */
    fx = (nsb - nfd) - (osb - ofd);
    /*
     * sx is the number of characters we need to insert/delete: in the end to
     * bring the two same last parts together
     */
    sx = (nls - nse) - (ols - ose);

    if (!EL_CAN_INSERT) {
	if (fx > 0) {
	    osb = ols;
	    ose = ols;
	    nsb = nls;
	    nse = nls;
	}
	if (sx > 0) {
	    ols = oe;
	    nls = ne;
	}
	if ((ols - ofd) < (nls - nfd)) {
	    ols = oe;
	    nls = ne;
	}
    }
    if (!EL_CAN_DELETE) {
	if (fx < 0) {
	    osb = ols;
	    ose = ols;
	    nsb = nls;
	    nse = nls;
	}
	if (sx < 0) {
	    ols = oe;
	    nls = ne;
	}
	if ((ols - ofd) > (nls - nfd)) {
	    ols = oe;
	    nls = ne;
	}
    }

    /*
     * Pragmatics III: make sure the middle shifted pointers are correct if
     * they don't point to anything (we may have moved ols or nls).
     */
    /* if the change isn't worth it, don't bother */
    /* was: if (osb == ose) */
    if ((ose - osb) < MIN_END_KEEP) {
d511 1
a512 1
	nsb = nls;
a513 1
    }
d515 131
a645 15
    /*
     * Now that we are done with pragmatics we recompute fx, sx
     */
    fx = (nsb - nfd) - (osb - ofd);
    sx = (nls - nse) - (ols - ose);

    RE_DEBUG(1,(__F, "\n"),);
    RE_DEBUG(1,(__F, "ofd %d, osb %d, ose %d, ols %d, oe %d\n",
	    ofd - old, osb - old, ose - old, ols - old, oe - old),);
    RE_DEBUG(1,(__F, "nfd %d, nsb %d, nse %d, nls %d, ne %d\n",
	    nfd - new, nsb - new, nse - new, nls - new, ne - new),);
    RE_DEBUG(1,(__F, 
		"xxx-xxx:\"00000000001111111111222222222233333333334\"\r\n"),);
    RE_DEBUG(1,(__F,
		"xxx-xxx:\"01234567890123456789012345678901234567890\"\r\n"),);
d647 12
a658 12
    re_printstr(el, "old- oe", old, oe);
    re_printstr(el, "new- ne", new, ne);
    re_printstr(el, "old-ofd", old, ofd);
    re_printstr(el, "new-nfd", new, nfd);
    re_printstr(el, "ofd-osb", ofd, osb);
    re_printstr(el, "nfd-nsb", nfd, nsb);
    re_printstr(el, "osb-ose", osb, ose);
    re_printstr(el, "nsb-nse", nsb, nse);
    re_printstr(el, "ose-ols", ose, ols);
    re_printstr(el, "nse-nls", nse, nls);
    re_printstr(el, "ols- oe", ols, oe);
    re_printstr(el, "nls- ne", nls, ne);
d661 249
a909 238
    /*
     * el_cursor.v to this line i MUST be in this routine so that if we
     * don't have to change the line, we don't move to it. el_cursor.h to first
     * diff char
     */
    term_move_to_line(el, i);

    /*
     * at this point we have something like this:
     * 
     * /old                  /ofd    /osb               /ose    /ols     /oe
     * v.....................v       v..................v       v........v
     * eddie> Oh, my fredded gruntle-buggy is to me, as foo var lurgid as
     * eddie> Oh, my fredded quiux buggy is to me, as gruntle-lurgid as
     * ^.....................^     ^..................^       ^........^ 
     * \new                  \nfd  \nsb               \nse     \nls    \ne
     * 
     * fx is the difference in length between the chars between nfd and
     * nsb, and the chars between ofd and osb, and is thus the number of
     * characters to delete if < 0 (new is shorter than old, as above),
     * or insert (new is longer than short).
     *
     * sx is the same for the second differences.
     */

    /*
     * if we have a net insert on the first difference, AND inserting the net
     * amount ((nsb-nfd) - (osb-ofd)) won't push the last useful character
     * (which is ne if nls != ne, otherwise is nse) off the edge of the screen
     * (el->el_term.t_size.h) else we do the deletes first so that we keep everything we need
     * to.
     */

    /*
     * if the last same is the same like the end, there is no last same part,
     * otherwise we want to keep the last same part set p to the last useful
     * old character
     */
    p = (ols != oe) ? oe : ose;

    /*
     * if (There is a diffence in the beginning) && (we need to insert
     * characters) && (the number of characters to insert is less than the term
     * width) We need to do an insert! else if (we need to delete characters)
     * We need to delete characters! else No insert or delete
     */
    if ((nsb != nfd) && fx > 0 && ((p - old) + fx <= el->el_term.t_size.h)) {
	RE_DEBUG(1,(__F, "first diff insert at %d...\r\n", nfd - new),);
	/*
	 * Move to the first char to insert, where the first diff is.
	 */
	term_move_to_char(el, nfd - new);
	/*
	 * Check if we have stuff to keep at end
	 */
	if (nsb != ne) {
	    RE_DEBUG(1,(__F, "with stuff to keep at end\r\n"),);
	    /*
	     * insert fx chars of new starting at nfd
	     */
	    if (fx > 0) {
		RE_DEBUG(!EL_CAN_INSERT,
			 (__F, "ERROR: cannot insert in early first diff\n"),);
		term_insertwrite(el, nfd, fx);
		re_insert(el, old, ofd - old, el->el_term.t_size.h, nfd, fx);
	    }
	    /*
	     * write (nsb-nfd) - fx chars of new starting at (nfd + fx)
	     */
	    term_overwrite(el, nfd + fx, (nsb - nfd) - fx);
	    re__strncopy(ofd + fx, nfd + fx, (nsb - nfd) - fx);
	}
	else {
	    RE_DEBUG(1,(__F, "without anything to save\r\n"),);
	    term_overwrite(el, nfd, (nsb - nfd));
	    re__strncopy(ofd, nfd, (nsb - nfd));
	    /*
	     * Done
	     */
	    return;
	}
    }
    else if (fx < 0) {
	RE_DEBUG(1,(__F, "first diff delete at %d...\r\n", ofd - old),);
	/*
	 * move to the first char to delete where the first diff is
	 */
	term_move_to_char(el, ofd - old);
	/*
	 * Check if we have stuff to save
	 */
	if (osb != oe) {
	    RE_DEBUG(1,(__F, "with stuff to save at end\r\n"),);
	    /*
	     * fx is less than zero *always* here but we check for code
	     * symmetry
	     */
	    if (fx < 0) {
		RE_DEBUG(!EL_CAN_DELETE,
			 (__F, "ERROR: cannot delete in first diff\n"),);
		term_deletechars(el, -fx);
		re_delete(el, old, ofd - old, el->el_term.t_size.h, -fx);
	    }
	    /*
	     * write (nsb-nfd) chars of new starting at nfd
	     */
	    term_overwrite(el, nfd, (nsb - nfd));
	    re__strncopy(ofd, nfd, (nsb - nfd));

	}
	else {
	    RE_DEBUG(1,(__F, "but with nothing left to save\r\n"),);
	    /*
	     * write (nsb-nfd) chars of new starting at nfd
	     */
	    term_overwrite(el, nfd, (nsb - nfd));
	    RE_DEBUG(1,(__F, "cleareol %d\n", (oe - old) - (ne - new)),);
	    term_clear_EOL(el, (oe - old) - (ne - new));
	    /*
	     * Done
	     */
	    return;
	}
    }
    else
	fx = 0;

    if (sx < 0) {
	RE_DEBUG(1,(__F, "second diff delete at %d...\r\n", (ose - old) + fx),);
	/*
	 * Check if we have stuff to delete
	 */
	/*
	 * fx is the number of characters inserted (+) or deleted (-)
	 */

	term_move_to_char(el, (ose - old) + fx);
	/*
	 * Check if we have stuff to save
	 */
	if (ols != oe) {
	    RE_DEBUG(1,(__F, "with stuff to save at end\r\n"),);
	    /*
	     * Again a duplicate test.
	     */
	    if (sx < 0) {
		RE_DEBUG(!EL_CAN_DELETE, 
			 (__F, "ERROR: cannot delete in second diff\n"),);
		term_deletechars(el, -sx);
	    }

	    /*
	     * write (nls-nse) chars of new starting at nse
	     */
	    term_overwrite(el, nse, (nls - nse));
	}
	else {
	    RE_DEBUG(1,(__F, "but with nothing left to save\r\n"),);
	    term_overwrite(el, nse, (nls - nse));
	    RE_DEBUG(1,(__F, "cleareol %d\n", (oe - old) - (ne - new)),);
	    term_clear_EOL(el, (oe - old) - (ne - new));
	}
    }

    /*
     * if we have a first insert AND WE HAVEN'T ALREADY DONE IT...
     */
    if ((nsb != nfd) && (osb - ofd) <= (nsb - nfd) && (fx == 0)) {
	RE_DEBUG(1,(__F, "late first diff insert at %d...\r\n", nfd - new),);

	term_move_to_char(el, nfd - new);
	/*
	 * Check if we have stuff to keep at the end
	 */
	if (nsb != ne) {
	    RE_DEBUG(1,(__F, "with stuff to keep at end\r\n"),);
	    /* 
	     * We have to recalculate fx here because we set it
	     * to zero above as a flag saying that we hadn't done
	     * an early first insert.
	     */
	    fx = (nsb - nfd) - (osb - ofd);
	    if (fx > 0) {
		/*
		 * insert fx chars of new starting at nfd
		 */
		RE_DEBUG(!EL_CAN_INSERT,
			 (__F, "ERROR: cannot insert in late first diff\n"),);
		term_insertwrite(el, nfd, fx);
		re_insert(el, old, ofd - old, el->el_term.t_size.h, nfd, fx);
	    }

	    /*
	     * write (nsb-nfd) - fx chars of new starting at (nfd + fx)
	     */
	    term_overwrite(el, nfd + fx, (nsb - nfd) - fx);
	    re__strncopy(ofd + fx, nfd + fx, (nsb - nfd) - fx);
	}
	else {
	    RE_DEBUG(1,(__F, "without anything to save\r\n"),);
	    term_overwrite(el, nfd, (nsb - nfd));
	    re__strncopy(ofd, nfd, (nsb - nfd));
	}
    }

    /*
     * line is now NEW up to nse
     */
    if (sx >= 0) {
	RE_DEBUG(1,(__F, "second diff insert at %d...\r\n", nse - new),);
	term_move_to_char(el, nse - new);
	if (ols != oe) {
	    RE_DEBUG(1,(__F, "with stuff to keep at end\r\n"),);
	    if (sx > 0) {
		/* insert sx chars of new starting at nse */
		RE_DEBUG(!EL_CAN_INSERT,
		         (__F, "ERROR: cannot insert in second diff\n"),);
		term_insertwrite(el, nse, sx);
	    }

	    /*
	     * write (nls-nse) - sx chars of new starting at (nse + sx)
	     */
	    term_overwrite(el, nse + sx, (nls - nse) - sx);
	}
	else {
	    RE_DEBUG(1,(__F, "without anything to save\r\n"),);
	    term_overwrite(el, nse, (nls - nse));

	    /*
             * No need to do a clear-to-end here because we were doing
	     * a second insert, so we will have over written all of the
	     * old string.
	     */
	}
    }
    RE_DEBUG(1,(__F, "done.\r\n"),);
} /* re_update_line */
d916 15
a930 18
re__copy_and_pad(dst, src, width)
    char *dst, *src;
    size_t width;
{
    int i;

    for (i = 0; i < width; i++) {
	if (*src == '\0')
	    break;
	*dst++ = *src++;
    }

    while (i < width) {
	*dst++ = ' ';
	i++;
    }
    *dst = '\0';
} /* end re__copy_and_pad */
d937 1
a937 2
re_refresh_cursor(el)
    EditLine *el;
d939 2
a940 2
    char *cp, c;
    int h, v, th;
d942 53
a994 47
    /* first we must find where the cursor is... */
    h  = el->el_prompt.p_pos.h;
    v  = el->el_prompt.p_pos.v;
    th = el->el_term.t_size.h;		/* optimize for speed 		*/

    /* do input buffer to el->el_line.cursor */
    for (cp = el->el_line.buffer; cp < el->el_line.cursor; cp++) {	
	c = *cp;
	h++;			/* all chars at least this long */

	if (c == '\n') {	/* handle newline in data part too */
	    h = 0;
	    v++;
	}
	else {
	    if (c == '\t') {	/* if a tab, to next tab stop */
		while (h & 07) {
		    h++;
		}
	    }
	    else if (iscntrl(c)) {	/* if control char */
		h++;
		if (h > th) {	/* if overflow, compensate */
		    h = 1;
		    v++;
		}
	    }
	    else if (!isprint(c)) {
		h += 3;
		if (h > th) {	/* if overflow, compensate */
		    h = h - th;
		    v++;
		}
	    }
	}

	if (h >= th) {		/* check, extra long tabs picked up here also */
	    h = 0;
	    v++;
	}
    }

    /* now go there */
    term_move_to_line(el, v);
    term_move_to_char(el, h);
    term__flush();
} /* re_refresh_cursor */
d1001 39
a1039 15
re_fastputc(el, c)
    EditLine *el;
    int    c;
{
    term__putc(c);
    el->el_display[el->el_cursor.v][el->el_cursor.h++] = c;
    if (el->el_cursor.h >= el->el_term.t_size.h) {	
	/* if we must overflow */
	el->el_cursor.h = 0;
	el->el_cursor.v++;
	el->el_refresh.r_oldcv++;
	term__putc('\r');
	term__putc('\n');
    }
} /* end re_fastputc */
d1044 1
a1044 1
 *	Assumes that screen cursor == real cursor 
d1047 1
a1047 2
re_fastaddc(el)
    EditLine *el;
d1049 2
a1050 1
    char c;
d1052 1
a1052 1
    c = el->el_line.cursor[-1];
d1054 24
a1077 21
    if (c == '\t' || el->el_line.cursor != el->el_line.lastchar) {
	re_refresh(el);		/* too hard to handle */
	return;
    }				/* else (only do at end of line, no TAB) */

    if (iscntrl(c)) {		/* if control char, do caret */
	char mc = (c == '\177') ? '?' : (c | 0100);
	re_fastputc(el, '^');
	re_fastputc(el, mc);
    }
    else if (isprint(c)) {	/* normal char */
	re_fastputc(el, c);
    }
    else {
	re_fastputc(el, '\\');
	re_fastputc(el, ((c >> 6) & 7) + '0');
	re_fastputc(el, ((c >> 3) & 7) + '0');
	re_fastputc(el, (c & 7) + '0');
    }
    term__flush();
} /* end re_fastaddc */
d1081 1
a1081 1
 *	clear the screen buffers so that new new prompt starts fresh. 
d1084 1
a1084 2
re_clear_display(el)
    EditLine *el;
d1086 1
a1086 1
    int i;
d1088 6
a1093 6
    el->el_cursor.v = 0;
    el->el_cursor.h = 0;
    for (i = 0; i < el->el_term.t_size.v; i++)
	el->el_display[i][0] = '\0';
    el->el_refresh.r_oldcv = 0;
} /* end re_clear_display */
d1097 1
a1097 1
 *	Make sure all lines are *really* blank 
d1100 1
a1100 2
re_clear_lines(el)
    EditLine *el;
d1102 17
a1118 16
    if (EL_CAN_CEOL) {
	int i;
	term_move_to_char(el, 0);
	for (i = 0; i <= el->el_refresh.r_oldcv; i++) {
	    /* for each line on the screen */
	    term_move_to_line(el, i);
	    term_clear_EOL(el, el->el_term.t_size.h);
	}
	term_move_to_line(el, 0);
    }
    else {
	term_move_to_line(el, el->el_refresh.r_oldcv);	/* go to last line */
	term__putc('\r');				/* go to BOL */
	term__putc('\n');				/* go to new line */
    }
} /* end re_clear_lines */
@


1.7
log
@is -Wall clean by making rcsid const
@
text
@d1 1
a1 1
/*	$OpenBSD: refresh.c,v 1.6 2002/02/17 19:42:25 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: refresh.c,v 1.6 2002/02/17 19:42:25 millert Exp $";
@


1.6
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: refresh.c,v 1.5 2002/02/16 21:27:26 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: refresh.c,v 1.5 2002/02/16 21:27:26 millert Exp $";
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: refresh.c,v 1.4 1997/04/09 02:28:31 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: refresh.c,v 1.4 1997/04/09 02:28:31 deraadt Exp $";
d61 2
a62 4
private	void	re_insert		__P((EditLine *, char *, int, int, 
					     char *, int));
private	void	re_delete		__P((EditLine *, char *, int, int, 
					     int));
d69 1
a69 2
private	void	re_printstr		__P((EditLine *, char *, char *, 
					     char *));
@


1.4
log
@the the
@
text
@d1 1
a1 1
/*	$OpenBSD: refresh.c,v 1.3 1997/03/14 05:12:59 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: refresh.c,v 1.3 1997/03/14 05:12:59 millert Exp $";
d59 2
a60 2
private	void	re_addc 		__P((EditLine *, int));
private	void	re_update_line 		__P((EditLine *, char *, char *, int));
d65 1
a65 1
private	void	re_fastputc		__P((EditLine *, int));
d67 2
a68 2
private	void	re__strncopy		__P((char *, char *, size_t));
private	void	re__copy_and_pad	__P((char *, char *, size_t));
@


1.3
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: refresh.c,v 1.2 1997/01/16 05:18:42 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: refresh.c,v 1.2 1997/01/16 05:18:42 millert Exp $";
d619 1
a619 1
     * fx is the difference in length between the the chars between nfd and
@


1.2
log
@Merge in NetBSD libedit changes and new man pages.  Also fix some
strncpy() usage in their code.  NetBSD change log was:
    * add a man page for the editline routines
    * add a man page describing editrc
    * fix bugs in el_parse():
      * didn't execute command when program name matched (test reversed)
      * was checking against empty string instead of program name
      * after checks, command to run also pointed to empty string
    * document ^char and \ escape sequences
    * when parsing ^char control chars, check the correct char when determining
      validity (previously, ^char was a NOP interpreted as the literal string
      because of this bug)
    * Implement CC_REDISPLAY, which (unlike CC_REFRESH) redraws the entire input
    * line (a la ^R). This is useful if the binding outputs information and
    * mucks up the input line. To be used in ``list-choices'' bindings (refer
    * to the ^D binding in csh when filec is set)
@
text
@d1 2
a2 1
/*	$OpenBSD: $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: $";
d76 1
a76 1
					(void) fprintf b;	\
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
d42 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
