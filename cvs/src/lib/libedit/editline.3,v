head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.4
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.6
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.2
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.8
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.4
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.24.0.6
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.22.0.6
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.10.0.14
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.12
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.10
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.8
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9:1.10.0.6
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@# @;


1.46
date	2016.05.22.22.08.42;	author schwarze;	state Exp;
branches;
next	1.45;
commitid	RIGPTmtyM7lavULa;

1.45
date	2016.05.21.16.34.30;	author schwarze;	state Exp;
branches;
next	1.44;
commitid	p3wKKuaqI0LtcHHT;

1.44
date	2016.05.21.16.17.09;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	seVWhjY1ki97mxfd;

1.43
date	2016.05.10.11.07.53;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	20CL26jlwTb5NoXa;

1.42
date	2016.04.20.01.11.45;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	9Q7mJBZuvE7cKSq3;

1.41
date	2016.03.21.18.04.40;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	I1dlEm44IPhRWGcj;

1.40
date	2016.03.21.17.53.07;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	EcF6E90RSH7QJhk9;

1.39
date	2015.09.14.13.45.25;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	RGDWQDsiOavVx5N6;

1.38
date	2015.09.10.13.44.19;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	Gvn6hpU1kYhFb5zx;

1.37
date	2015.03.13.19.58.40;	author jmc;	state Exp;
branches;
next	1.36;
commitid	OcwhWBKGs3Yn7EeA;

1.36
date	2014.12.15.22.35.41;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	atnntjLH3XoYmSdU;

1.35
date	2014.12.12.17.04.22;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	lltzzUjDoooSpY1T;

1.34
date	2014.05.19.08.58.34;	author nicm;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.10.14.21.47;	author jmc;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.07.16.15.47;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2011.03.02.07.46.15;	author jmc;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.10.18.38.20;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.30.07.32.06;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.27;

1.27
date	2010.05.14.21.12.36;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2010.05.09.19.12.05;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.09.15.16.30;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.26.05.42.05;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.31.19.19.34;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.11.18.37.36;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.09.15.07.35;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2004.04.14.22.00.35;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.25.20.12.38;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.03.05.23.49;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.01.11.23.19;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.01.08.24.09;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.31.10.23.22;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.31.08.57.10;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.08.07.46.30;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.23.12.41.13;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.15.02.15.27;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	99.07.09.13.35.25;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	99.07.07.14.22.25;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.07.07.10.50.05;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.05.16.19.55.51;	author alex;	state Exp;
branches;
next	1.5;

1.5
date	99.05.12.21.58.33;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	99.02.27.21.57.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.01.05.11.04.18;	author d;	state Exp;
branches;
next	1.2;

1.2
date	97.03.14.05.12.44;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.01.16.05.20.28;	author millert;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Document el_wpush(3) and fix the description of el_push(3).
Improve precision in the description of the "bind" builtin command.
Tweak terminology to better match editline(7).
@
text
@.\"	$OpenBSD: editline.3,v 1.45 2016/05/21 16:34:30 schwarze Exp $
.\"	$NetBSD: editline.3,v 1.88 2016/02/25 14:59:22 wiz Exp $
.\"
.\" Copyright (c) 1997-2003 The NetBSD Foundation, Inc.
.\" All rights reserved.
.\"
.\" This file was contributed to The NetBSD Foundation by Luke Mewburn.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
.\" BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd $Mdocdate: May 21 2016 $
.Dt EDITLINE 3
.Os
.Sh NAME
.Nm editline ,
.Nm el_init ,
.Nm el_end ,
.Nm el_reset ,
.Nm el_gets ,
.Nm el_wgets ,
.Nm el_getc ,
.Nm el_wgetc ,
.Nm el_push ,
.Nm el_wpush ,
.Nm el_parse ,
.Nm el_wparse ,
.Nm el_set ,
.Nm el_wset ,
.Nm el_get ,
.Nm el_wget ,
.Nm el_source ,
.Nm el_resize ,
.Nm el_line ,
.Nm el_wline ,
.Nm el_insertstr ,
.Nm el_winsertstr ,
.Nm el_deletestr ,
.Nm el_wdeletestr ,
.Nm history_init ,
.Nm history_winit ,
.Nm history_end ,
.Nm history_wend ,
.Nm history ,
.Nm history_w ,
.Nm tok_init ,
.Nm tok_winit ,
.Nm tok_end ,
.Nm tok_wend ,
.Nm tok_reset ,
.Nm tok_wreset ,
.Nm tok_line ,
.Nm tok_wline ,
.Nm tok_str ,
.Nm tok_wstr
.Nd line editor, history and tokenization functions
.Sh SYNOPSIS
.In histedit.h
.Ft EditLine *
.Fn el_init "const char *prog" "FILE *fin" "FILE *fout" "FILE *ferr"
.Ft void
.Fn el_end "EditLine *e"
.Ft void
.Fn el_reset "EditLine *e"
.Ft const char *
.Fn el_gets "EditLine *e" "int *count"
.Ft const wchar_t *
.Fn el_wgets "EditLine *e" "int *count"
.Ft int
.Fn el_getc "EditLine *e" "char *ch"
.Ft int
.Fn el_wgetc "EditLine *e" "wchar_t *wc"
.Ft void
.Fn el_push "EditLine *e" "const char *mbs"
.Ft void
.Fn el_wpush "EditLine *e" "const wchar_t *wcs"
.Ft int
.Fn el_parse "EditLine *e" "int argc" "const char *argv[]"
.Ft int
.Fn el_wparse "EditLine *e" "int argc" "const wchar_t *argv[]"
.Ft int
.Fn el_set "EditLine *e" "int op" "..."
.Ft int
.Fn el_wset "EditLine *e" "int op" "..."
.Ft int
.Fn el_get "EditLine *e" "int op" "..."
.Ft int
.Fn el_wget "EditLine *e" "int op" "..."
.Ft int
.Fn el_source "EditLine *e" "const char *file"
.Ft void
.Fn el_resize "EditLine *e"
.Ft const LineInfo *
.Fn el_line "EditLine *e"
.Ft const LineInfoW *
.Fn el_wline "EditLine *e"
.Ft int
.Fn el_insertstr "EditLine *e" "const char *str"
.Ft int
.Fn el_winsertstr "EditLine *e" "const wchar_t *str"
.Ft void
.Fn el_deletestr "EditLine *e" "int count"
.Ft void
.Fn el_wdeletestr "EditLine *e" "int count"
.Ft History *
.Fn history_init void
.Ft HistoryW *
.Fn history_winit void
.Ft void
.Fn history_end "History *h"
.Ft void
.Fn history_wend "HistoryW *h"
.Ft int
.Fn history "History *h" "HistEvent *ev" "int op" "..."
.Ft int
.Fn history_w "HistoryW *h" "HistEventW *ev" "int op" "..."
.Ft Tokenizer *
.Fn tok_init "const char *IFS"
.Ft TokenizerW *
.Fn tok_winit "const wchar_t *IFS"
.Ft void
.Fn tok_end "Tokenizer *t"
.Ft void
.Fn tok_wend "TokenizerW *t"
.Ft void
.Fn tok_reset "Tokenizer *t"
.Ft void
.Fn tok_wreset "TokenizerW *t"
.Ft int
.Fn tok_line "Tokenizer *t" "const LineInfo *li" "int *argc" "const char **argv[]" "int *cursorc" "int *cursoro"
.Ft int
.Fn tok_wline "TokenizerW *t" "const LineInfoW *li" "int *argc" "const wchar_t **argv[]" "int *cursorc" "int *cursoro"
.Ft int
.Fn tok_str "Tokenizer *t" "const char *str" "int *argc" "const char **argv[]"
.Ft int
.Fn tok_wstr "TokenizerW *t" "const wchar_t *str" "int *argc" "const wchar_t **argv[]"
.Sh DESCRIPTION
The
.Nm
library provides generic line editing, history and tokenization functions,
similar to those found in
.Xr sh 1 .
.Pp
These functions are available in the
.Nm libedit
library (which needs the
.Nm libcurses
library).
Programs should be linked with
.Fl ledit lcurses .
.Pp
The
.Nm
library respects the
.Ev LC_CTYPE
locale set by the application program and never uses
.Xr setlocale 3
to change the locale.
The only locales supported are UTF-8 and the default C or POSIX locale.
If any other locale is set, behaviour is undefined.
.Sh LINE EDITING FUNCTIONS
The line editing functions use a common data structure,
.Fa EditLine ,
which is created by
.Fn el_init
and freed by
.Fn el_end .
.Pp
The wide-character functions behave the same way as their narrow
counterparts.
.Pp
The following functions are available:
.Bl -tag -width 4n
.It Fn el_init
Initialize the line editor, and return a data structure
to be used by all other line editing functions, or
.Dv NULL
on failure.
.Fa prog
is the name of the invoking program, used when reading the
.Xr editrc 5
file to determine which settings to use.
.Fa fin ,
.Fa fout
and
.Fa ferr
are the input, output, and error streams (respectively) to use.
In this documentation, references to
.Dq the tty
are actually to this input/output stream combination.
.It Fn el_end
Clean up and finish with
.Fa e ,
assumed to have been created with
.Fn el_init .
.It Fn el_reset
Reset the tty and the parser.
This should be called after an error which may have upset the tty's
state.
.It Fn el_gets
Read a line from the tty.
.Fa count
is modified to contain the number of characters read.
Returns the line read if successful, or
.Dv NULL
if no characters were read or if an error occurred.
If an error occurred,
.Fa count
is set to \-1 and
.Dv errno
contains the error code that caused it.
The return value may not remain valid across calls to
.Fn el_gets
and must be copied if the data is to be retained.
.It Fn el_wgetc
Read a wide character from the tty, respecting the current locale,
or from the input queue described in
.Xr editline 7
if that is not empty, and store it in
.Fa wc .
If an invalid or incomplete character is found, it is discarded,
.Va errno
is set to
.Er EILSEQ ,
and the next character is read and stored in
.Fa wc .
Returns 1 if a valid character was read, 0 on end of file, or \-1 on
.Xr read 2
failure.
In the latter case,
.Va errno
is set to indicate the error.
.It Fn el_getc
Read a wide character as described for
.Fn el_wgetc
and return 0 on end of file or \-1 on failure.
If the wide character can be represented as a single-byte character,
convert it with
.Xr wctob 3 ,
store the result in
.Fa ch ,
and return 1; otherwise, set
.Va errno
to
.Er ERANGE
and return \-1.
In the C or POSIX locale, this simply reads a byte, but for any other
locale, including UTF-8, this is rarely useful.
.It Fn el_wpush
Push the wide character string
.Fa wcs
back onto the input queue described in
.Xr editline 7 .
If the queue overflows, for example due to a recursive macro,
or if an error occurs, for example because
.Fa wcs
is
.Dv NULL
or memory allocation fails, the function beeps at the user,
but does not report the problem to the caller.
.It Fn el_push
Use the current locale to convert the multibyte string
.Fa mbs
to a wide character string, and pass the result to
.Fn el_wpush .
.It Fn el_parse
Parses the
.Fa argv
array (which is
.Fa argc
elements in size)
to execute builtin
.Nm
commands.
If the command is prefixed with
.Dq prog :
then
.Fn el_parse
will only execute the command if
.Dq prog
matches the
.Fa prog
argument supplied to
.Fn el_init .
The return value is
\-1 if the command is unknown,
0 if there was no error or
.Dq prog
didn't match, or
1 if the command returned an error.
Refer to
.Xr editrc 5
for more information.
.It Fn el_set
Set
.Nm
parameters.
.Fa op
determines which parameter to set, and each operation has its
own parameter list.
Returns 0 on success, \-1 on failure.
.Pp
The following values for
.Fa op
are supported, along with the required argument list:
.Bl -tag -width 4n
.It Dv EL_PROMPT , Fa "char *(*f)(EditLine *)"
Define prompt printing function as
.Fa f ,
which is to return a string that contains the prompt.
.It Dv EL_PROMPT_ESC , Fa "char *(*f)(EditLine *)" , Fa "char c"
Same as
.Dv EL_PROMPT ,
but the
.Fa c
argument indicates the start/stop literal prompt character.
.Pp
If a start/stop literal character is found in the prompt, the
character itself
is not printed, but characters after it are printed directly to the
terminal without affecting the state of the current line.
A subsequent second start/stop literal character ends this behavior.
This is typically used to embed literal escape sequences that change the
color/style of the terminal in the prompt.
.Dv 0
unsets it.
.It Dv EL_REFRESH
Re-display the current line on the next terminal line.
.It Dv EL_RPROMPT , Fa "char *(*f)(EditLine *)"
Define right side prompt printing function as
.Fa f ,
which is to return a string that contains the prompt.
.It Dv EL_RPROMPT_ESC , Fa "char *(*f)(EditLine *)" , Fa "char c"
Define the right prompt printing function but with a literal escape character.
.It Dv EL_TERMINAL , Fa "const char *type"
Define terminal type of the tty to be
.Fa type ,
or to
.Ev TERM
if
.Fa type
is
.Dv NULL .
.It Dv EL_EDITOR , Fa "const char *mode"
Set editing mode to
.Fa mode ,
which must be one of
.Dq emacs
or
.Dq vi .
.It Dv EL_SIGNAL , Fa "int flag"
If
.Fa flag
is non-zero,
.Nm
will install its own signal handler for the following signals when
reading command input:
.Dv SIGCONT ,
.Dv SIGHUP ,
.Dv SIGINT ,
.Dv SIGQUIT ,
.Dv SIGSTOP ,
.Dv SIGTERM ,
.Dv SIGTSTP ,
and
.Dv SIGWINCH .
Otherwise, the current signal handlers will be used.
.It Dv EL_BIND , Fa "const char *" , Fa "..." , Dv NULL
Perform the
.Ic bind
builtin command.
Refer to
.Xr editrc 5
for more information.
.It Dv EL_ECHOTC , Fa "const char *" , Fa "..." , Dv NULL
Perform the
.Ic echotc
builtin command.
Refer to
.Xr editrc 5
for more information.
.It Dv EL_SETTC , Fa "const char *" , Fa "..." , Dv NULL
Perform the
.Ic settc
builtin command.
Refer to
.Xr editrc 5
for more information.
.It Dv EL_SETTY , Fa "const char *" , Fa "..." , Dv NULL
Perform the
.Ic setty
builtin command.
Refer to
.Xr editrc 5
for more information.
.It Dv EL_TELLTC , Fa "const char *" , Fa "..." , Dv NULL
Perform the
.Ic telltc
builtin command.
Refer to
.Xr editrc 5
for more information.
.It Dv EL_ADDFN , Fa "const char *name" , Fa "const char *help" , \
Fa "unsigned char (*func)(EditLine *e, int ch)"
Add a user defined function,
.Fn func ,
referred to as
.Fa name
which is invoked when a key which is bound to
.Fa name
is entered.
.Fa help
is a description of
.Fa name .
At invocation time,
.Fa ch
is the key which caused the invocation.
The return value of
.Fn func
should be one of:
.Bl -tag -width "CC_REDISPLAY"
.It Dv CC_NORM
Add a normal character.
.It Dv CC_NEWLINE
End of line was entered.
.It Dv CC_EOF
EOF was entered.
.It Dv CC_ARGHACK
Expecting further command input as arguments, do nothing visually.
.It Dv CC_REFRESH
Refresh display.
.It Dv CC_REFRESH_BEEP
Refresh display, and beep.
.It Dv CC_CURSOR
Cursor moved, so update and perform
.Dv CC_REFRESH .
.It Dv CC_REDISPLAY
Redisplay entire input line.
This is useful if a key binding outputs extra information.
.It Dv CC_ERROR
An error occurred.
Beep, and flush tty.
.It Dv CC_FATAL
Fatal error, reset tty to known state.
.El
.It Dv EL_HIST , Fa "History *(*func)(History *, int op, ...)" , \
Fa "const char *ptr"
Defines which history function to use, which is usually
.Fn history .
.Fa ptr
should be the value returned by
.Fn history_init .
.It Dv EL_EDITMODE , Fa "int flag"
If
.Fa flag
is non-zero,
editing is enabled (the default).
Note that this is only an indication, and does not
affect the operation of
.Nm .
At this time, it is the caller's responsibility to
check this
(using
.Fn el_get )
to determine if editing should be enabled or not.
.It Dv EL_UNBUFFERED , Fa "int flag"
If
.Fa flag
is zero,
unbuffered mode is disabled (the default).
In unbuffered mode,
.Fn el_gets
will return immediately after processing a single character.
.It Dv EL_GETCFN , Fa "el_rfunc_t f"
Whenever reading a character, use the function
.Bd -ragged -offset indent -compact
.Ft int
.Fo f
.Fa "EditLine *e"
.Fa "wchar_t *wc"
.Fc
.Ed
which stores the character in
.Fa wc
and returns 1 on success, 0 on end of file, or \-1 on I/O or encoding
errors.
Functions internally using it include
.Fn el_wgets ,
.Fn el_wgetc ,
.Fn el_gets ,
and
.Fn el_getc .
Initially, a builtin function is installed, and replacing it
is discouraged because writing such a function is very error prone.
The builtin function can be restored at any time by passing the
special value
.Dv EL_BUILTIN_GETCFN
instead of a function pointer.
.It Dv EL_CLIENTDATA , Fa "void *data"
Register
.Fa data
to be associated with this EditLine structure.
It can be retrieved with the corresponding
.Fn el_get
call.
.It Dv EL_SETFP , Fa "int fd" , Fa "FILE *fp"
Set the current
.Nm editline
file pointer for
.Dq input
.Fa fd
=
.Dv 0 ,
.Dq output
.Fa fd
=
.Dv 1 ,
or
.Dq error
.Fa fd
=
.Dv 2
from
.Fa fp .
.El
.It Fn el_get
Get
.Nm
parameters.
.Fa op
determines which parameter to retrieve into
.Fa result .
Returns 0 if successful, \-1 otherwise.
.Pp
The following values for
.Fa op
are supported, along with actual type of
.Fa result :
.Bl -tag -width 4n
.It Dv EL_PROMPT , Fa "char *(*f)(EditLine *)" , Fa "char *c"
Set
.Fa f
to a pointer to the function that displays the prompt.
If
.Fa c
is not
.Dv NULL ,
set it to the start/stop literal prompt character.
.It Dv EL_RPROMPT , Fa "char *(*f)(EditLine *)" , Fa "char *c"
Set
.Fa f
to a pointer to the function that displays the prompt.
If
.Fa c
is not
.Dv NULL ,
set it to the start/stop literal prompt character.
.It Dv EL_EDITOR , Fa "const char **n"
Set the name of the editor in
.Fa n ,
which will be one of
.Dq emacs
or
.Dq vi .
.It Dv EL_GETTC , Fa "const char *name" , Fa "void *value"
If
.Fa name
is a valid
.Xr termcap 5
capability set
.Fa value
to the current value of that capability.
.It Dv EL_SIGNAL , Fa "int *s"
Set
.Fa s
to non-zero if
.Nm
has installed private signal handlers (see
.Fn el_get
above).
.It Dv EL_EDITMODE , Fa "int *c"
Set
.Fa c
to non-zero if editing is enabled.
.It Dv EL_GETCFN , Fa "el_rfunc_t *f"
Set
.Fa f
to a pointer to the function that reads characters, or to
.Dv EL_BUILTIN_GETCFN
if the builtin function is in use.
.It Dv EL_CLIENTDATA , Fa "void **data"
Set
.Fa data
to the previously registered client data set by an
.Fn el_set
call.
.It Dv EL_UNBUFFERED , Fa "int *c"
Set
.Fa c
to non-zero if unbuffered mode is enabled.
.It Dv EL_PREP_TERM , Fa "int"
Sets or clears terminal editing mode.
.It Dv EL_GETFP , Fa "int fd", Fa "FILE **fp"
Set
.Fa fp
to the current
.Nm editline
file pointer for
.Dq input
.Fa fd
=
.Dv 0 ,
.Dq output
.Fa fd
=
.Dv 1 ,
or
.Dq error
.Fa fd
=
.Dv 2 .
.El
.It Fn el_source
Initialize
.Nm
by reading the contents of
.Fa file .
.Fn el_parse
is called for each line in
.Fa file .
If
.Fa file
is
.Dv NULL ,
try
.Pa $HOME/.editrc .
Refer to
.Xr editrc 5
for details on the format of
.Fa file .
.Fn el_source
returns 0 on success and \-1 on error.
.It Fn el_resize
Must be called if the terminal size changes.
If
.Dv EL_SIGNAL
has been set with
.Fn el_set ,
then this is done automatically.
Otherwise, it's the responsibility of the application to call
.Fn el_resize
on the appropriate occasions.
.It Fn el_line
Return the editing information for the current line in a
.Fa LineInfo
structure, which is defined as follows:
.Bd -literal
typedef struct lineinfo {
    const char *buffer;    /* address of buffer */
    const char *cursor;    /* address of cursor */
    const char *lastchar;  /* address of last character */
} LineInfo;
.Ed
.Pp
.Fa buffer
is not NUL terminated.
This function may be called after
.Fn el_gets
to obtain the
.Fa LineInfo
structure pertaining to line returned by that function,
and from within user defined functions added with
.Dv EL_ADDFN .
.It Fn el_insertstr
Insert
.Fa str
into the line at the cursor.
Returns \-1 if
.Fa str
is empty or won't fit, and 0 otherwise.
.It Fn el_deletestr
Delete
.Fa count
characters before the cursor.
.El
.Sh HISTORY LIST FUNCTIONS
The history functions use a common data structure,
.Fa History ,
which is created by
.Fn history_init
and freed by
.Fn history_end .
.Pp
The following functions are available:
.Bl -tag -width 4n
.It Fn history_init
Initialize the history list, and return a data structure
to be used by all other history list functions, or
.Dv NULL
on failure.
.It Fn history_end
Clean up and finish with
.Fa h ,
assumed to have been created with
.Fn history_init .
.It Fn history
Perform operation
.Fa op
on the history list, with optional arguments as needed by the
operation.
.Fa ev
is changed accordingly to operation.
The following values for
.Fa op
are supported, along with the required argument list:
.Bl -tag -width 4n
.It Dv H_SETSIZE , Fa "int size"
Set size of history to
.Fa size
elements.
.It Dv H_GETSIZE
Get number of events currently in history.
.It Dv H_END
Cleans up and finishes with
.Fa h ,
assumed to be created with
.Fn history_init .
.It Dv H_CLEAR
Clear the history.
.It Dv H_FUNC , Fa "void *ptr" , Fa "history_gfun_t first" , \
Fa "history_gfun_t next" , Fa "history_gfun_t last" , \
Fa "history_gfun_t prev" , Fa "history_gfun_t curr" , \
Fa "history_sfun_t set" , Fa "history_vfun_t clear" , \
Fa "history_efun_t enter" , Fa "history_efun_t add"
Define functions to perform various history operations.
.Fa ptr
is the argument given to a function when it's invoked.
.It Dv H_FIRST
Return the first element in the history.
.It Dv H_LAST
Return the last element in the history.
.It Dv H_PREV
Return the previous element in the history.
It is newer than the current one.
.It Dv H_NEXT
Return the next element in the history.
It is older than the current one.
.It Dv H_CURR
Return the current element in the history.
.It Dv H_SET
Set the cursor to point to the requested element.
.It Dv H_ADD , Fa "const char *str"
Append
.Fa str
to the current element of the history, or perform the
.Dv H_ENTER
operation with argument
.Fa str
if there is no current element.
.It Dv H_APPEND , Fa "const char *str"
Append
.Fa str
to the last new element of the history.
.It Dv H_ENTER , Fa "const char *str"
Add
.Fa str
as a new element to the history and, if necessary,
removing the oldest entry to keep the list to the created size.
If
.Dv H_SETUNIQUE
has been called with a non-zero argument, the element
will not be entered into the history if its contents match
the ones of the current history element.
If the element is entered
.Fn history
returns 1; if it is ignored as a duplicate returns 0.
Finally
.Fn history
returns \-1 if an error occurred.
.It Dv H_PREV_STR , Fa "const char *str"
Return the closest previous event that starts with
.Fa str .
.It Dv H_NEXT_STR , Fa "const char *str"
Return the closest next event that starts with
.Fa str .
.It Dv H_PREV_EVENT , Fa "int e"
Return the previous event numbered
.Fa e .
.It Dv H_NEXT_EVENT , Fa "int e"
Return the next event numbered
.Fa e .
.It Dv H_LOAD , Fa "const char *file"
Load the history list stored in
.Fa file .
.It Dv H_SAVE , Fa "const char *file"
Save the history list to
.Fa file .
.It Dv H_SAVE_FP , Fa "FILE *fp"
Save the history list to the opened
.Ft FILE
pointer
.Fa fp .
.It Dv H_SETUNIQUE , Fa "int unique"
Set flag that adjacent identical event strings should not be entered
into the history.
.It Dv H_GETUNIQUE
Retrieve the current setting if adjacent identical elements should
be entered into the history.
.It Dv H_DEL , Fa "int e"
Delete the event numbered
.Fa e .
This function is only provided for
.Xr readline 3
compatibility.
The caller is responsible for free'ing the string in the returned
.Fa HistEvent .
.El
.Pp
.Fn history
returns \*[Gt]= 0 if the operation
.Fa op
succeeds.
Otherwise, \-1 is returned and
.Fa ev
is updated to contain more details about the error.
.El
.Sh TOKENIZATION FUNCTIONS
The tokenization functions use a common data structure,
.Fa Tokenizer ,
which is created by
.Fn tok_init
and freed by
.Fn tok_end .
.Pp
The following functions are available:
.Bl -tag -width 4n
.It Fn tok_init
Initialize the tokenizer, and return a data structure
to be used by all other tokenizer functions.
.Fa IFS
contains the Input Field Separators, which defaults to
.Aq space ,
.Aq tab ,
and
.Aq newline
if
.Dv NULL .
.It Fn tok_end
Clean up and finish with
.Fa t ,
assumed to have been created with
.Fn tok_init .
.It Fn tok_reset
Reset the tokenizer state.
Use after a line has been successfully tokenized
by
.Fn tok_line
or
.Fn tok_str
and before a new line is to be tokenized.
.It Fn tok_line
Tokenize
.Fa li ,
If successful, modify:
.Fa argv
to contain the words,
.Fa argc
to contain the number of words,
.Fa cursorc
(if not
.Dv NULL )
to contain the index of the word containing the cursor,
and
.Fa cursoro
(if not
.Dv NULL )
to contain the offset within
.Fa argv[cursorc]
of the cursor.
.Pp
Returns
0 if successful,
\-1 for an internal error,
1 for an unmatched single quote,
2 for an unmatched double quote,
and
3 for a backslash quoted
.Aq newline .
A positive exit code indicates that another line should be read
and tokenization attempted again.
.
.It Fn tok_str
A simpler form of
.Fn tok_line ;
.Fa str
is a NUL terminated string to tokenize.
.El
.
.\"XXX.Sh EXAMPLES
.\"XXX: provide some examples
.Sh SEE ALSO
.Xr sh 1 ,
.Xr curses 3 ,
.Xr signal 3 ,
.Xr editrc 5 ,
.Xr termcap 5 ,
.Xr editline 7
.Sh HISTORY
The
.Nm
library first appeared in
.Bx 4.4 .
.Dv CC_REDISPLAY
appeared in
.Nx 1.3 .
.Dv CC_REFRESH_BEEP ,
.Dv EL_EDITMODE
and the readline emulation appeared in
.Nx 1.4 .
.Dv EL_RPROMPT
appeared in
.Nx 1.5 .
.Sh AUTHORS
.An -nosplit
The
.Nm
library was written by
.An Christos Zoulas .
.An Luke Mewburn
wrote this manual and implemented
.Dv CC_REDISPLAY ,
.Dv CC_REFRESH_BEEP ,
.Dv EL_EDITMODE ,
and
.Dv EL_RPROMPT .
.An Jaromir Dolecek
implemented the readline emulation.
.An Johny Mattsson
implemented wide-character support.
.Sh BUGS
At this time, it is the responsibility of the caller to
check the result of the
.Dv EL_EDITMODE
operation of
.Fn el_get
(after an
.Fn el_source
or
.Fn el_parse )
to determine if
.Nm
should be used for further input.
I.e.,
.Dv EL_EDITMODE
is purely an indication of the result of the most recent
.Xr editrc 5
.Ic edit
command.
@


1.45
log
@Simple sync with NetBSD, mostly to avoid confusion of arguments and
return values.
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.44 2016/05/21 16:17:09 schwarze Exp $
d92 1
a92 1
.Fn el_push "EditLine *e" "const char *str"
d94 1
a94 1
.Fn el_wpush "EditLine *e" "const wchar_t *str"
d235 2
a236 4
or from the input stream written by
.Fn el_wpush
and
.Fn el_push
d267 12
d280 4
a283 10
Pushes
.Fa str
back onto the input stream.
This is used by the macro expansion mechanism.
Refer to the description of
.Ic bind
.Fl s
in
.Xr editrc 5
for more information.
@


1.44
log
@Fix the prototype used by EL_GETCFN, mention the associated typedef name,
document the return values, expand the list of affected functions, warn
against using EL_GETCFN, and clarify some wording and notation.
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.43 2016/05/10 11:07:53 schwarze Exp $
d30 1
a30 1
.Dd $Mdocdate: May 10 2016 $
d193 1
a193 1
Initialise the line editor, and return a data structure
d490 1
a490 1
.Bd -offset indent -compact
d555 3
a557 2
Return a pointer to the function that displays the prompt in
.Fa f .
d562 1
a562 1
return the start/stop literal prompt character in it.
d564 3
a566 2
Return a pointer to the function that displays the prompt in
.Fa f .
d571 5
a575 3
return the start/stop literal prompt character in it.
.It Dv EL_EDITOR , Fa "const char **"
Return the name of the editor, which will be one of
d580 1
a580 1
Return non-zero if
d584 1
a584 2
capability
and set
d587 4
a590 2
.It Dv EL_SIGNAL , Fa "int *"
Return non-zero if
d595 4
a598 2
.It Dv EL_EDITMODE , Fa "int *"
Return non-zero if editing is enabled.
d606 1
a606 1
Retrieve
d608 1
a608 1
previously registered with the corresponding
d611 4
a614 2
.It Dv EL_UNBUFFERED , Fa "int"
Return non-zero if unbuffered mode is enabled.
d618 1
a618 1
Return in
d620 1
a620 1
the current
d638 1
a638 1
Initialise
d711 1
a711 1
Initialise the history list, and return a data structure
d852 1
a852 1
Initialise the tokenizer, and return a data structure
@


1.43
log
@Fix next_history() and previous_history():
* The meaning of "next" and "previous" is exchanged in readline(3) with
respect to editline(3); this part of the patch from Bastian Maerkisch.
* next_history() can move beyond the newest entry; issue pointed out
by Bastian Maerkisch, fix by me.

While here, make the documentation of ed-next-history, ed-prev-history,
H_NEXT, and H_PREV more precise.

OK czarkoff@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.42 2016/04/20 01:11:45 schwarze Exp $
d30 1
a30 1
.Dd $Mdocdate: April 20 2016 $
d90 1
a90 1
.Fn el_wgetc "EditLine *e" "wchar_t *ch"
d240 1
a240 1
.Fa ch .
d246 1
a246 1
.Fa ch .
d488 17
a504 7
.It Dv EL_GETCFN , Fa "int (*f)(EditLine *, char *c)"
Define the character reading function as
.Fa f ,
which is to return the number of characters read and store them in
.Fa c .
This function is called internally by
.Fn el_gets
d507 6
a512 3
The builtin function can be set or restored with the special function
name
.Dq Dv EL_BUILTIN_GETCFN .
d592 6
a597 4
.It Dv EL_GETCFN , Fa "int (**f)(EditLine *, char *)"
Return a pointer to the function that read characters, which is equal to
.Dq Dv EL_BUILTIN_GETCFN
in the case of the default builtin function.
@


1.42
log
@New editline(7) manual, explaining to end-users how line editing works
in programs like ftp(1), sftp(1), bc(1), and cdio(1) that use libedit.
The existing editrc(5) manual only explains customization, and the
existing editline(3) manual only explains the C language interface.
Already listing all editor functions and all default key bindings, but
in other respects, not 100% complete yet, and due to the sheer size,
some bugs may have slipped, but all that can be fixed in the tree.

OK and tweaks jmc@@.
Also seems reasonable to Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.41 2016/03/21 18:04:40 schwarze Exp $
d30 1
a30 1
.Dd $Mdocdate: March 21 2016 $
d734 1
d737 1
@


1.41
log
@Markup fixes: use .Ev and .Er where appropriate.
While here, also use \-1 rather than -1; not sure that's really
better, but Thomas is right it should at least be consistent
within a page.
From Thomas Klausner <wiz @@ NetBSD>.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d894 2
a895 1
.Xr termcap 5
@


1.40
log
@fix el_{w,}getc documentation;
OK czarkoff@@
@
text
@d2 1
a2 1
.\"	$NetBSD: editline.3,v 1.87 2016/02/24 19:45:48 christos Exp $
d30 1
a30 1
.Dd $Mdocdate: September 14 2015 $
d173 1
a173 1
.Dv LC_CTYPE
d244 1
a244 1
.Dv EILSEQ ,
d247 1
a247 1
Returns 1 if a valid character was read, 0 on end of file, or -1 on
d256 1
a256 1
and return 0 on end of file or -1 on failure.
d265 2
a266 2
.Dv ERANGE
and return -1.
@


1.39
log
@in the SYNOPSIS, make void function arguments explicit
@
text
@d1 2
a2 2
.\"	$OpenBSD: editline.3,v 1.38 2015/09/10 13:44:19 schwarze Exp $
.\"	$NetBSD: editline.3,v 1.82 2014/05/11 09:01:42 wiz Exp $
d30 1
a30 1
.Dd $Mdocdate: September 10 2015 $
d169 10
d233 20
d254 15
a268 7
Read a character from the tty.
.Fa ch
is modified to contain the character read.
Returns the number of characters read if successful, \-1 otherwise,
in which case
.Dv errno
can be inspected for the cause.
@


1.38
log
@missing commas at the end of .Nm lines in the NAME section
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.37 2015/03/13 19:58:40 jmc Exp $
d30 1
a30 1
.Dd $Mdocdate: March 13 2015 $
d124 1
a124 1
.Fn history_init
d126 1
a126 1
.Fn history_winit
@


1.37
log
@remove the first comma from constructs like ", and," and ", or,": you can use
"and" and "or" to join sentence clauses, and you can use commas, but both hinders
reading;
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.36 2014/12/15 22:35:41 schwarze Exp $
d30 1
a30 1
.Dd $Mdocdate: December 15 2014 $
d72 1
a72 1
.Nm tok_str
@


1.36
log
@merge improvements from NetBSD; ok jmc@@ nicm@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.35 2014/12/12 17:04:22 schwarze Exp $
d30 1
a30 1
.Dd $Mdocdate: December 12 2014 $
d717 1
a717 1
as a new element to the history, and, if necessary,
@


1.35
log
@markup fixes from Kaspars at Bankovskis dot net;
some of this is already contained upstream in NetBSD,
the rest will be sent there
@
text
@d1 2
a2 2
.\"	$OpenBSD: editline.3,v 1.34 2014/05/19 08:58:34 nicm Exp $
.\"	$NetBSD: editline.3,v 1.73 2010/01/03 19:05:26 wiz Exp $
d30 1
a30 1
.Dd $Mdocdate: May 19 2014 $
d113 2
d227 4
a230 1
Returns the number of characters read if successful, \-1 otherwise.
d442 8
d552 1
a552 4
Sets or clears unbuffered mode.
In this mode,
.Fn el_gets
will return immediately after processing a single character.
a749 1
.Fa fp
d751 2
a752 1
pointer .
@


1.34
log
@Add a H_SAVE_FP operation to history() which lets the history be saved
to an open file pointer. From NetBSD via Eitan Adler.

ok millert
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.33 2013/01/10 14:21:47 jmc Exp $
d30 1
a30 1
.Dd $Mdocdate: January 10 2013 $
d76 1
a76 1
.Fd #include <histedit.h>
d863 1
d866 4
a869 2
library was written by Christos Zoulas.
Luke Mewburn wrote this manual and implemented
d875 4
a878 2
Jaromir Dolecek implemented the readline emulation.
Johny Mattsson implemented wide-character support.
@


1.33
log
@editline.3: editrc only read from $HOME; from LEVAI Daniel
editrc.5: add FILES for ~/.editrc

patches passed onto net/free
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.32 2011/07/07 16:15:47 nicm Exp $
d30 1
a30 1
.Dd $Mdocdate: July 7 2011 $
d738 5
@


1.32
log
@Enable wide character functions in libedit (not the other libe*t).

ok stsp deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.31 2011/03/02 07:46:15 jmc Exp $
d30 1
a30 1
.Dd $Mdocdate: March 2 2011 $
a577 2
.Pa $PWD/.editrc
then
@


1.31
log
@netbsd -r1.75: Fix argument for EL_EDITOR; from Jess Thrysoee
ok nicm
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.30 2010/09/10 18:38:20 jmc Exp $
d30 1
a30 1
.Dd $Mdocdate: September 10 2010 $
d39 1
d41 1
d43 1
d45 1
d47 1
d49 1
d53 1
d55 1
d57 1
d59 1
d61 1
d63 1
d65 1
d67 1
d69 1
d71 1
d73 1
d85 2
d89 2
d93 2
d98 2
d102 2
d106 2
d115 2
d119 2
d123 2
d127 2
d131 2
d135 2
d140 2
d143 2
d148 2
d151 2
d174 3
@


1.30
log
@observe the following spelling:
- wide character (noun)
- wide-character (adjective)

this is the "fix of least resistance", and appears to be in line with
posix style; a tiny fix still needed for curses, but i'll mail that
upstream;
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.29 2010/06/30 07:32:06 jmc Exp $
d30 1
a30 1
.Dd $Mdocdate: June 30 2010 $
d454 1
a454 1
.It Dv EL_EDITOR , Fa "const char *"
@


1.29
log
@tweak previous;
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.28 2010/06/30 00:05:35 nicm Exp $
d818 1
a818 1
Johny Mattsson implemented wide character support.
@


1.28
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.16 2003/11/01 08:24:09 otto Exp $
d30 1
a30 1
.Dd $Mdocdate: May 14 2010 $
a57 2
.Sh LIBRARY
.Lb libedit
d788 1
a788 1
.Xr curses 3
@


1.27
log
@Document return values, based on a diff from Ross Richardson.

ok jmc
@
text
@d1 2
a2 2
.\"	$OpenBSD: editline.3,v 1.26 2010/05/09 19:12:05 jmc Exp $
.\"	$NetBSD: editline.3,v 1.42 2003/11/04 13:22:19 christos Exp $
d4 1
a4 1
.\" Copyright (c) 1997-1999 The NetBSD Foundation, Inc.
d30 1
a30 1
.Dd $Mdocdate: May 9 2010 $
d51 9
a59 2
.Nm history
.Nd line editor and history functions
d79 1
a79 1
.Fn el_get "EditLine *e" "int op" "void *result"
d96 10
d109 1
a109 1
library provides generic line editing and history functions,
d163 8
d232 18
d254 2
d289 1
a289 5
.It Dv EL_BIND , Xo
.Fa "const char *" ,
.Fa "..." ,
.Dv NULL
.Xc
d296 1
a296 5
.It Dv EL_ECHOTC , Xo
.Fa "const char *" ,
.Fa "..." ,
.Dv NULL
.Xc
d303 1
a303 5
.It Dv EL_SETTC , Xo
.Fa "const char *" ,
.Fa "..." ,
.Dv NULL
.Xc
d310 1
a310 5
.It Dv EL_SETTY , Xo
.Fa "const char *" ,
.Fa "..." ,
.Dv NULL
.Xc
d317 1
a317 5
.It Dv EL_TELLTC , Xo
.Fa "const char *" ,
.Fa "..." ,
.Dv NULL
.Xc
d324 2
a325 5
.It Dv EL_ADDFN , Xo
.Fa "const char *name" ,
.Fa "const char *help" ,
.Fa "unsigned char (*func)(EditLine *e, int ch)"
.Xc
d367 2
a368 4
.It Dv EL_HIST , Xo
.Fa "History *(*func)(History *, int op, ...)" ,
.Fa "const char *ptr"
.Xc
d397 2
a398 1
name ``EL_BUILTIN_GETCFN''.
d406 19
d440 16
a455 4
.It Dv EL_PROMPT , Fa "char *(*f)(EditLine *)"
Return a pointer to the function that displays the prompt.
.It Dv EL_RPROMPT , Fa "char *(*f)(EditLine *)"
Return a pointer to the function that displays the rightside prompt.
d461 9
d476 1
a476 1
.It Dv EL_EDITMODE, Fa "int *"
d478 1
a478 1
.It Dv EL_GETCFN, Fa "int (**f)(EditLine *, char *)"
d480 2
a481 1
``EL_BUILTIN_GETCFN'' in the case of the default builtin function.
d488 1
a488 1
.It Dv EL_UNBUFFERED, Fa "int"
d493 1
a493 1
.It Dv EL_PREP_TERM, Fa "int"
d495 19
d558 10
d577 1
a577 1
.Fa num
d624 5
a628 12
.It Dv H_FUNC , Xo
.Fa "void *ptr" ,
.Fa "history_gfun_t first" ,
.Fa "history_gfun_t next" ,
.Fa "history_gfun_t last" ,
.Fa "history_gfun_t prev" ,
.Fa "history_gfun_t curr" ,
.Fa "history_sfun_t set" ,
.Fa "history_vfun_t clear" ,
.Fa "history_efun_t enter" ,
.Fa "history_efun_t add"
.Xc
d691 2
a692 2
Set if the adjacent identical event strings should not be entered into
the history.
d694 10
a703 2
Retrieve the current setting if adjacent elements should be entered into
the history.
d707 1
a707 1
returns \*(Ge 0 if the operation
d714 72
d790 1
a790 1
.Xr curses 3 ,
d792 2
a793 2
.Xr termcap 3 ,
.Xr editrc 5
d820 1
a821 3
The tokenization functions are not publicly defined in
.Aq Pa histedit.h .
.Pp
@


1.26
log
@another Os out of order;
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.25 2010/05/09 15:16:30 nicm Exp $
d197 1
d454 2
d501 3
a503 1
to be used by all other history list functions.
@


1.25
log
@Document that el_init can return NULL on failure, PR 6374 from rueda at
devio.us.

ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.24 2008/06/26 05:42:05 ray Exp $
d30 2
a31 1
.Dd $Mdocdate: June 26 2008 $
a32 1
.Dt EDITLINE 3
@


1.24
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.23 2007/05/31 19:19:34 jmc Exp $
d30 1
a30 1
.Dd $Mdocdate: May 31 2007 $
d115 3
a117 1
to be used by all other line editing functions.
@


1.23
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.22 2005/10/11 18:37:36 jmc Exp $
a16 7
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"        This product includes software developed by the NetBSD
.\"        Foundation, Inc. and its contributors.
.\" 4. Neither the name of The NetBSD Foundation nor the names of its
.\"    contributors may be used to endorse or promote products derived
.\"    from this software without specific prior written permission.
d30 1
a30 1
.Dd $Mdocdate$
@


1.22
log
@add el_get() to the Nm list;
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.21 2005/09/09 15:07:35 jmc Exp $
d37 1
a37 1
.Dd October 17, 2003
@


1.21
log
@double word typos;
from alexey e. suslikov;
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.20 2004/04/14 22:00:35 jfb Exp $
d50 1
@


1.20
log
@remove an extra occurence of the word `succeeds'

ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.19 2003/11/25 20:12:38 otto Exp $
d609 1
a609 1
Retrieve the current setting if if adjacent elements should be entered into
@


1.19
log
@Sync libedit to NetBSD libedit as of Nov 8, 2003.
Tested by jmc@@ djm@@ and myself
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.18 2003/11/03 05:23:49 jmc Exp $
d614 1
a614 1
returns \*(Ge 0 if the operation succeeds
@


1.18
log
@encourage people to link with -lcurses rather than -ltermcap;
.Xr curses in SEE ALSO, suggested by otto@@;

ok otto@@
@
text
@d1 2
a2 2
.\"	$OpenBSD: editline.3,v 1.17 2003/11/01 11:23:19 otto Exp $
.\"	$NetBSD: editline.3,v 1.38 2003/09/26 21:09:13 wiz Exp $
d37 1
a37 1
.Dd September 26, 2003
d434 2
d614 1
a614 1
returns >= 0 if the operation succeeds
@


1.17
log
@Fix typo, which was already spotted by jmc@@, but missing in the previous
commit.
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.16 2003/11/01 08:24:09 otto Exp $
d105 1
a105 1
.Nm libtermcap
d108 1
a108 1
.Fl ledit ltermcap .
d623 1
@


1.16
log
@Complete incomplete H_ADD description.

Spotted and ok by jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.15 2003/10/31 10:23:22 otto Exp $
d562 1
a562 1
operation wth argument
@


1.15
log
@Typo fix from Dries Schellekens <gwyllion at ace dot ulyssis dot org>.
10x
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.14 2003/10/31 08:57:10 otto Exp $
d560 5
a564 1
to the current element of the history, or create an element with
@


1.14
log
@Man pages fixes from jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d572 1
a572 1
has been called with a non-zero arguments, the element
@


1.13
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 1
a58 2
.Sh LIBRARY
.Lb libedit
d60 1
a60 1
.In histedit.h
d572 1
a572 1
was has been called with a non-zero arguments, the element
d577 1
a577 1
returns 1, if it is ignored as a duplicate returns 0.
@


1.12
log
@functions should link with -lcurses, not -ltermcap;
pointed out by millert@@
@
text
@d1 1
a1 2
.\"	$OpenBSD: editline.3,v 1.11 2003/05/23 12:41:13 jmc Exp $
.\"	$NetBSD: editline.3,v 1.4 1997/01/14 04:17:23 lukem Exp $
d3 1
a3 1
.\" Copyright (c) 1997 The NetBSD Foundation, Inc.
d27 2
a28 2
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
.\" LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d36 2
a37 1
.Dd January 11, 1997
a38 1
.Os
d58 2
d61 1
a61 1
.Fd #include <histedit.h>
d63 1
a63 1
.Fn el_init "const char *prog" "FILE *fin" "FILE *fout"
d75 1
a75 1
.Fn el_parse "EditLine *e" "int argc" "char *argv[]"
d79 2
d87 1
a87 1
.Fn el_insertstr "EditLine *e" "char *str"
d94 2
a95 2
.Ft HistEvent *
.Fn history "History *h" "int op" "..."
d106 1
a106 1
.Nm libcurses
d109 1
a109 1
.Fl ledit lcurses .
d112 1
a112 1
.Fa editline ,
d127 2
a128 1
.Fa fin
d130 2
a131 2
.Fa fout
are the input and output streams (respectively) to use.
d173 1
a173 1
to execute built-in
d177 1
a177 1
.Dq prog:
a194 13
.Pp
.Em NOTE :
.Va argv[0]
may be modified by
.Fn el_parse .
The colon between
.Dq prog
and the command,
.Ar command ,
will be replaced with a NUL
.Po
.Dq \e0
.Pc .
d211 4
d255 1
a255 1
built-in command.
d266 1
a266 1
built-in command.
d277 1
a277 1
built-in command.
d288 1
a288 1
built-in command.
d299 1
a299 1
built-in command.
d335 2
d358 77
d468 1
a468 1
.Fa lineinfo
d491 1
a491 1
.Fa history ,
d512 2
d518 1
a518 1
.It Dv H_EVENT , Fa "int size"
d522 2
d538 1
d556 2
d562 4
a565 2
.Dv H_ENTER
if there isn't one.
d571 11
d600 6
d607 8
d628 10
d641 8
a648 2
library was written by Christos Zoulas,
and this manual was written by Luke Mewburn.
d650 2
a651 1
This documentation is probably incomplete.
d653 18
a670 6
.Fn el_parse
should not modify the supplied
.Va argv[0] .
.Pp
The tokenization functions are not publically defined in
.Aq Pa histedit.h .
@


1.11
log
@- typos
- whitespace at EOL
- new sentence, new line
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.10 2000/04/15 02:15:27 aaron Exp $
d103 1
a103 1
.Nm libtermcap
d106 1
a106 1
.Fl ledit ltermcap .
@


1.10
log
@Mostly punctuation fixes.
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.9 1999/07/09 13:35:25 aaron Exp $
d192 1
a192 1
.Em NOTE:
d311 1
a311 1
.Fa "unsigned char (*func)(EditLine *e, int ch)
d533 1
a533 1
.Fd <histedit.h>
@


1.9
log
@- remove all trailing whitespace
     * except when it is escaped with a `\' at the end of the line
- fix remaining .Nm usage as well
- this is from a patch I received from kwesterback@@home.com, who has been
  working on some scripts for fixing formatting errors in mdoc'd man pages

Ok, so there could be a cost/benefit debate with this commit, but since I have
the patch we might as well commit it...
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.8 1999/07/07 14:22:25 aaron Exp $
d342 1
a342 1
.Dv CC_REFRESH.
@


1.8
log
@when using `-' as a negative sign, escape it with a backslash so troff knows
it's not supposed to be a hyphen/dash
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.7 1999/07/07 10:50:05 aaron Exp $
d198 1
a198 1
and the command, 
d261 1
a261 1
Refer to 
d272 1
a272 1
Refer to 
d283 1
a283 1
Refer to 
d294 1
a294 1
Refer to 
d305 1
a305 1
Refer to 
d365 1
a365 1
by reading the contents of 
d486 1
a486 1
as a new element to the history, and, if necessary, 
@


1.7
log
@The proper order of the ``introductory'' macros in a man page is .Dd/.Dt/.Os.
Out of the approximately 1450 man pages, only about 90 of them were wrong.
Thanks to kwesterback@@home.com for coming up with a script and patch to repair
this. The patch also inserted a .Os macro in the few man pages that were
missing one.
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.6 1999/05/16 19:55:51 alex Exp $
d151 1
a151 1
Returns the number of characters read if successful, -1 otherwise.
d183 1
a183 1
-1 if the command is unknown,
d407 1
a407 1
Returns -1 if
@


1.6
log
@Cleanup xrefs under SEE ALSO.  Specifically:

  - Sort xrefs by section, and then alphabetically.
  - Add missing commas between xref items.
  - Remove commas from the last xref entry.
  - Remove duplicate entries.
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.5 1999/05/12 21:58:33 aaron Exp $
a37 1
.Os BSD 4.4
d39 1
@


1.5
log
@builtin -> built-in
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.4 1999/02/27 21:57:22 deraadt Exp $
a510 1
.Xr editrc 5 ,
d513 2
a514 1
.Xr termcap 3
@


1.4
log
@make function names the correct case
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.3 1999/01/05 11:04:18 d Exp $
d169 1
a169 1
to execute builtin
d260 1
a260 1
builtin command.
d271 1
a271 1
builtin command.
d282 1
a282 1
builtin command.
d293 1
a293 1
builtin command.
d304 1
a304 1
builtin command.
@


1.3
log
@fix misleading proto
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.2 1997/03/14 05:12:44 millert Exp $
d109 1
a109 1
.Fa EditLine ,
d394 1
a394 1
.Fa LineInfo
d417 1
a417 1
.Fa History ,
@


1.2
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 1
a1 1
.\"	$OpenBSD: editline.3,v 1.1 1997/01/16 05:20:28 millert Exp $
d92 1
a92 1
.Fn history "History h" "int op" "..."
@


1.1
log
@Man pages for libedit, from NetBSD.
@
text
@d1 2
a2 1
.\"	$OpenBSD: $
@
