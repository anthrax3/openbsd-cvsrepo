head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.4
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.25.0.6
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.16
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.14
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.10
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.8
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.6
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.26
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.22
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.05.06.13.12.52;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	HmIy04UbyUS0d1Sd;

1.24
date	2016.04.11.21.17.29;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	I3AtNAFb4FywnTMT;

1.23
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	OUneMOe0l7HombT5;

1.22
date	2016.04.11.19.54.54;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	xizUpRlYj2C4Hcj6;

1.21
date	2016.04.09.20.28.27;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	nRwJYvh17UAhrvEe;

1.20
date	2016.04.09.20.15.26;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	0bnhGLXZIvXlnMLp;

1.19
date	2016.03.22.11.32.18;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	IqABuRl0Ys8M4ewM;

1.18
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	tRHhB2RN3ZD1GvoI;

1.17
date	2016.03.20.22.57.59;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	VBVmrUoZFnMc0hts;

1.16
date	2016.03.20.20.35.38;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	b06qlwkNEbVitvG0;

1.15
date	2016.01.30.17.32.52;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	wAt9MiELkmlnoi4U;

1.14
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	dCN84ovvbfYwqrqX;

1.13
date	2016.01.30.00.06.39;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	tGf8IdK8wCurneJ7;

1.12
date	2014.10.17.06.07.50;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	bdUOvGFxUQgqZg7x;

1.11
date	2011.07.07.05.40.42;	author okan;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.23.18.53.10;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.01.21.11.21;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.03.14.05.13.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.16.05.18.52;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Replace the generated file "fcns.c" by a simpler header "func.h"
included only in the one file needing it, "map.c".
That allows to define el_action_t directly in "map.h",
which in turn allows to stop including "fcns.h" from "el.h"
and include it only in the modules needing it.
Now we no longer autogenerate any C files.

Feedback and OK martijn@@.
First version also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@/*	$OpenBSD: vi.c,v 1.24 2016/04/11 21:17:29 schwarze Exp $	*/
/*	$NetBSD: vi.c,v 1.33 2011/02/17 16:44:48 joerg Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * vi.c: Vi mode commands.
 */
#include <sys/wait.h>
#include <ctype.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "el.h"
#include "common.h"
#include "emacs.h"
#include "fcns.h"
#include "vi.h"

static el_action_t	cv_action(EditLine *, wint_t);
static el_action_t	cv_paste(EditLine *, wint_t);

/* cv_action():
 *	Handle vi actions.
 */
static el_action_t
cv_action(EditLine *el, wint_t c)
{

	if (el->el_chared.c_vcmd.action != NOP) {
		/* 'cc', 'dd' and (possibly) friends */
		if (c != (wint_t)el->el_chared.c_vcmd.action)
			return CC_ERROR;

		if (!(c & YANK))
			cv_undo(el);
		cv_yank(el, el->el_line.buffer,
		    (int)(el->el_line.lastchar - el->el_line.buffer));
		el->el_chared.c_vcmd.action = NOP;
		el->el_chared.c_vcmd.pos = 0;
		if (!(c & YANK)) {
			el->el_line.lastchar = el->el_line.buffer;
			el->el_line.cursor = el->el_line.buffer;
		}
		if (c & INSERT)
			el->el_map.current = el->el_map.key;

		return CC_REFRESH;
	}
	el->el_chared.c_vcmd.pos = el->el_line.cursor;
	el->el_chared.c_vcmd.action = c;
	return CC_ARGHACK;
}

/* cv_paste():
 *	Paste previous deletion before or after the cursor
 */
static el_action_t
cv_paste(EditLine *el, wint_t c)
{
	c_kill_t *k = &el->el_chared.c_kill;
	size_t len = (size_t)(k->last - k->buf);

	if (k->buf == NULL || len == 0)
		return CC_ERROR;
#ifdef DEBUG_PASTE
	(void) fprintf(el->el_errfile, "Paste: \"%.*ls\"\n", (int)len,
	    k->buf);
#endif

	cv_undo(el);

	if (!c && el->el_line.cursor < el->el_line.lastchar)
		el->el_line.cursor++;

	c_insert(el, (int)len);
	if (el->el_line.cursor + len > el->el_line.lastchar)
		return CC_ERROR;
	(void) memcpy(el->el_line.cursor, k->buf, len *
	    sizeof(*el->el_line.cursor));

	return CC_REFRESH;
}


/* vi_paste_next():
 *	Vi paste previous deletion to the right of the cursor
 *	[p]
 */
protected el_action_t
/*ARGSUSED*/
vi_paste_next(EditLine *el, wint_t c __attribute__((__unused__)))
{

	return cv_paste(el, 0);
}


/* vi_paste_prev():
 *	Vi paste previous deletion to the left of the cursor
 *	[P]
 */
protected el_action_t
/*ARGSUSED*/
vi_paste_prev(EditLine *el, wint_t c __attribute__((__unused__)))
{

	return cv_paste(el, 1);
}


/* vi_prev_big_word():
 *	Vi move to the previous space delimited word
 *	[B]
 */
protected el_action_t
/*ARGSUSED*/
vi_prev_big_word(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor == el->el_line.buffer)
		return CC_ERROR;

	el->el_line.cursor = cv_prev_word(el->el_line.cursor,
	    el->el_line.buffer,
	    el->el_state.argument,
	    cv__isWord);

	if (el->el_chared.c_vcmd.action != NOP) {
		cv_delfini(el);
		return CC_REFRESH;
	}
	return CC_CURSOR;
}


/* vi_prev_word():
 *	Vi move to the previous word
 *	[b]
 */
protected el_action_t
/*ARGSUSED*/
vi_prev_word(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor == el->el_line.buffer)
		return CC_ERROR;

	el->el_line.cursor = cv_prev_word(el->el_line.cursor,
	    el->el_line.buffer,
	    el->el_state.argument,
	    cv__isword);

	if (el->el_chared.c_vcmd.action != NOP) {
		cv_delfini(el);
		return CC_REFRESH;
	}
	return CC_CURSOR;
}


/* vi_next_big_word():
 *	Vi move to the next space delimited word
 *	[W]
 */
protected el_action_t
/*ARGSUSED*/
vi_next_big_word(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor >= el->el_line.lastchar - 1)
		return CC_ERROR;

	el->el_line.cursor = cv_next_word(el, el->el_line.cursor,
	    el->el_line.lastchar, el->el_state.argument, cv__isWord);

	if (el->el_map.type == MAP_VI)
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return CC_REFRESH;
		}
	return CC_CURSOR;
}


/* vi_next_word():
 *	Vi move to the next word
 *	[w]
 */
protected el_action_t
/*ARGSUSED*/
vi_next_word(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor >= el->el_line.lastchar - 1)
		return CC_ERROR;

	el->el_line.cursor = cv_next_word(el, el->el_line.cursor,
	    el->el_line.lastchar, el->el_state.argument, cv__isword);

	if (el->el_map.type == MAP_VI)
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return CC_REFRESH;
		}
	return CC_CURSOR;
}


/* vi_change_case():
 *	Vi change case of character under the cursor and advance one character
 *	[~]
 */
protected el_action_t
vi_change_case(EditLine *el, wint_t c)
{
	int i;

	if (el->el_line.cursor >= el->el_line.lastchar)
		return CC_ERROR;
	cv_undo(el);
	for (i = 0; i < el->el_state.argument; i++) {

		c = *el->el_line.cursor;
		if (iswupper(c))
			*el->el_line.cursor = towlower(c);
		else if (iswlower(c))
			*el->el_line.cursor = towupper(c);

		if (++el->el_line.cursor >= el->el_line.lastchar) {
			el->el_line.cursor--;
			re_fastaddc(el);
			break;
		}
		re_fastaddc(el);
	}
	return CC_NORM;
}


/* vi_change_meta():
 *	Vi change prefix command
 *	[c]
 */
protected el_action_t
/*ARGSUSED*/
vi_change_meta(EditLine *el, wint_t c __attribute__((__unused__)))
{

	/*
         * Delete with insert == change: first we delete and then we leave in
         * insert mode.
         */
	return cv_action(el, DELETE | INSERT);
}


/* vi_insert_at_bol():
 *	Vi enter insert mode at the beginning of line
 *	[I]
 */
protected el_action_t
/*ARGSUSED*/
vi_insert_at_bol(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_line.cursor = el->el_line.buffer;
	cv_undo(el);
	el->el_map.current = el->el_map.key;
	return CC_CURSOR;
}


/* vi_replace_char():
 *	Vi replace character under the cursor with the next character typed
 *	[r]
 */
protected el_action_t
/*ARGSUSED*/
vi_replace_char(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor >= el->el_line.lastchar)
		return CC_ERROR;

	el->el_map.current = el->el_map.key;
	el->el_state.inputmode = MODE_REPLACE_1;
	cv_undo(el);
	return CC_ARGHACK;
}


/* vi_replace_mode():
 *	Vi enter replace mode
 *	[R]
 */
protected el_action_t
/*ARGSUSED*/
vi_replace_mode(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_map.current = el->el_map.key;
	el->el_state.inputmode = MODE_REPLACE;
	cv_undo(el);
	return CC_NORM;
}


/* vi_substitute_char():
 *	Vi replace character under the cursor and enter insert mode
 *	[s]
 */
protected el_action_t
/*ARGSUSED*/
vi_substitute_char(EditLine *el, wint_t c __attribute__((__unused__)))
{

	c_delafter(el, el->el_state.argument);
	el->el_map.current = el->el_map.key;
	return CC_REFRESH;
}


/* vi_substitute_line():
 *	Vi substitute entire line
 *	[S]
 */
protected el_action_t
/*ARGSUSED*/
vi_substitute_line(EditLine *el, wint_t c __attribute__((__unused__)))
{

	cv_undo(el);
	cv_yank(el, el->el_line.buffer,
	    (int)(el->el_line.lastchar - el->el_line.buffer));
	(void) em_kill_line(el, 0);
	el->el_map.current = el->el_map.key;
	return CC_REFRESH;
}


/* vi_change_to_eol():
 *	Vi change to end of line
 *	[C]
 */
protected el_action_t
/*ARGSUSED*/
vi_change_to_eol(EditLine *el, wint_t c __attribute__((__unused__)))
{

	cv_undo(el);
	cv_yank(el, el->el_line.cursor,
	    (int)(el->el_line.lastchar - el->el_line.cursor));
	(void) ed_kill_line(el, 0);
	el->el_map.current = el->el_map.key;
	return CC_REFRESH;
}


/* vi_insert():
 *	Vi enter insert mode
 *	[i]
 */
protected el_action_t
/*ARGSUSED*/
vi_insert(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_map.current = el->el_map.key;
	cv_undo(el);
	return CC_NORM;
}


/* vi_add():
 *	Vi enter insert mode after the cursor
 *	[a]
 */
protected el_action_t
/*ARGSUSED*/
vi_add(EditLine *el, wint_t c __attribute__((__unused__)))
{
	int ret;

	el->el_map.current = el->el_map.key;
	if (el->el_line.cursor < el->el_line.lastchar) {
		el->el_line.cursor++;
		if (el->el_line.cursor > el->el_line.lastchar)
			el->el_line.cursor = el->el_line.lastchar;
		ret = CC_CURSOR;
	} else
		ret = CC_NORM;

	cv_undo(el);

	return ret;
}


/* vi_add_at_eol():
 *	Vi enter insert mode at end of line
 *	[A]
 */
protected el_action_t
/*ARGSUSED*/
vi_add_at_eol(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_map.current = el->el_map.key;
	el->el_line.cursor = el->el_line.lastchar;
	cv_undo(el);
	return CC_CURSOR;
}


/* vi_delete_meta():
 *	Vi delete prefix command
 *	[d]
 */
protected el_action_t
/*ARGSUSED*/
vi_delete_meta(EditLine *el, wint_t c __attribute__((__unused__)))
{

	return cv_action(el, DELETE);
}


/* vi_end_big_word():
 *	Vi move to the end of the current space delimited word
 *	[E]
 */
protected el_action_t
/*ARGSUSED*/
vi_end_big_word(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor == el->el_line.lastchar)
		return CC_ERROR;

	el->el_line.cursor = cv__endword(el->el_line.cursor,
	    el->el_line.lastchar, el->el_state.argument, cv__isWord);

	if (el->el_chared.c_vcmd.action != NOP) {
		el->el_line.cursor++;
		cv_delfini(el);
		return CC_REFRESH;
	}
	return CC_CURSOR;
}


/* vi_end_word():
 *	Vi move to the end of the current word
 *	[e]
 */
protected el_action_t
/*ARGSUSED*/
vi_end_word(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor == el->el_line.lastchar)
		return CC_ERROR;

	el->el_line.cursor = cv__endword(el->el_line.cursor,
	    el->el_line.lastchar, el->el_state.argument, cv__isword);

	if (el->el_chared.c_vcmd.action != NOP) {
		el->el_line.cursor++;
		cv_delfini(el);
		return CC_REFRESH;
	}
	return CC_CURSOR;
}


/* vi_undo():
 *	Vi undo last change
 *	[u]
 */
protected el_action_t
/*ARGSUSED*/
vi_undo(EditLine *el, wint_t c __attribute__((__unused__)))
{
	c_undo_t un = el->el_chared.c_undo;

	if (un.len == -1)
		return CC_ERROR;

	/* switch line buffer and undo buffer */
	el->el_chared.c_undo.buf = el->el_line.buffer;
	el->el_chared.c_undo.len = el->el_line.lastchar - el->el_line.buffer;
	el->el_chared.c_undo.cursor =
	    (int)(el->el_line.cursor - el->el_line.buffer);
	el->el_line.limit = un.buf + (el->el_line.limit - el->el_line.buffer);
	el->el_line.buffer = un.buf;
	el->el_line.cursor = un.buf + un.cursor;
	el->el_line.lastchar = un.buf + un.len;

	return CC_REFRESH;
}


/* vi_command_mode():
 *	Vi enter command mode (use alternative key bindings)
 *	[<ESC>]
 */
protected el_action_t
/*ARGSUSED*/
vi_command_mode(EditLine *el, wint_t c __attribute__((__unused__)))
{

	/* [Esc] cancels pending action */
	el->el_chared.c_vcmd.action = NOP;
	el->el_chared.c_vcmd.pos = 0;

	el->el_state.doingarg = 0;

	el->el_state.inputmode = MODE_INSERT;
	el->el_map.current = el->el_map.alt;
#ifdef VI_MOVE
	if (el->el_line.cursor > el->el_line.buffer)
		el->el_line.cursor--;
#endif
	return CC_CURSOR;
}


/* vi_zero():
 *	Vi move to the beginning of line
 *	[0]
 */
protected el_action_t
vi_zero(EditLine *el, wint_t c)
{

	if (el->el_state.doingarg)
		return ed_argument_digit(el, c);

	el->el_line.cursor = el->el_line.buffer;
	if (el->el_chared.c_vcmd.action != NOP) {
		cv_delfini(el);
		return CC_REFRESH;
	}
	return CC_CURSOR;
}


/* vi_delete_prev_char():
 *	Vi move to previous character (backspace)
 *	[^H] in insert mode only
 */
protected el_action_t
/*ARGSUSED*/
vi_delete_prev_char(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor <= el->el_line.buffer)
		return CC_ERROR;

	c_delbefore1(el);
	el->el_line.cursor--;
	return CC_REFRESH;
}


/* vi_list_or_eof():
 *	Vi list choices for completion or indicate end of file if empty line
 *	[^D]
 */
protected el_action_t
/*ARGSUSED*/
vi_list_or_eof(EditLine *el, wint_t c)
{

	if (el->el_line.cursor == el->el_line.lastchar) {
		if (el->el_line.cursor == el->el_line.buffer) {
			terminal_writec(el, c);	/* then do a EOF */
			return CC_EOF;
		} else {
			/*
			 * Here we could list completions, but it is an
			 * error right now
			 */
			terminal_beep(el);
			return CC_ERROR;
		}
	} else {
#ifdef notyet
		re_goto_bottom(el);
		*el->el_line.lastchar = '\0';	/* just in case */
		return CC_LIST_CHOICES;
#else
		/*
		 * Just complain for now.
		 */
		terminal_beep(el);
		return CC_ERROR;
#endif
	}
}


/* vi_kill_line_prev():
 *	Vi cut from beginning of line to cursor
 *	[^U]
 */
protected el_action_t
/*ARGSUSED*/
vi_kill_line_prev(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *kp, *cp;

	cp = el->el_line.buffer;
	kp = el->el_chared.c_kill.buf;
	while (cp < el->el_line.cursor)
		*kp++ = *cp++;	/* copy it */
	el->el_chared.c_kill.last = kp;
	c_delbefore(el, (int)(el->el_line.cursor - el->el_line.buffer));
	el->el_line.cursor = el->el_line.buffer;	/* zap! */
	return CC_REFRESH;
}


/* vi_search_prev():
 *	Vi search history previous
 *	[?]
 */
protected el_action_t
/*ARGSUSED*/
vi_search_prev(EditLine *el, wint_t c __attribute__((__unused__)))
{

	return cv_search(el, ED_SEARCH_PREV_HISTORY);
}


/* vi_search_next():
 *	Vi search history next
 *	[/]
 */
protected el_action_t
/*ARGSUSED*/
vi_search_next(EditLine *el, wint_t c __attribute__((__unused__)))
{

	return cv_search(el, ED_SEARCH_NEXT_HISTORY);
}


/* vi_repeat_search_next():
 *	Vi repeat current search in the same search direction
 *	[n]
 */
protected el_action_t
/*ARGSUSED*/
vi_repeat_search_next(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_search.patlen == 0)
		return CC_ERROR;
	else
		return cv_repeat_srch(el, el->el_search.patdir);
}


/* vi_repeat_search_prev():
 *	Vi repeat current search in the opposite search direction
 *	[N]
 */
/*ARGSUSED*/
protected el_action_t
vi_repeat_search_prev(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_search.patlen == 0)
		return CC_ERROR;
	else
		return (cv_repeat_srch(el,
		    el->el_search.patdir == ED_SEARCH_PREV_HISTORY ?
		    ED_SEARCH_NEXT_HISTORY : ED_SEARCH_PREV_HISTORY));
}


/* vi_next_char():
 *	Vi move to the character specified next
 *	[f]
 */
protected el_action_t
/*ARGSUSED*/
vi_next_char(EditLine *el, wint_t c __attribute__((__unused__)))
{
	return cv_csearch(el, CHAR_FWD, -1, el->el_state.argument, 0);
}


/* vi_prev_char():
 *	Vi move to the character specified previous
 *	[F]
 */
protected el_action_t
/*ARGSUSED*/
vi_prev_char(EditLine *el, wint_t c __attribute__((__unused__)))
{
	return cv_csearch(el, CHAR_BACK, -1, el->el_state.argument, 0);
}


/* vi_to_next_char():
 *	Vi move up to the character specified next
 *	[t]
 */
protected el_action_t
/*ARGSUSED*/
vi_to_next_char(EditLine *el, wint_t c __attribute__((__unused__)))
{
	return cv_csearch(el, CHAR_FWD, -1, el->el_state.argument, 1);
}


/* vi_to_prev_char():
 *	Vi move up to the character specified previous
 *	[T]
 */
protected el_action_t
/*ARGSUSED*/
vi_to_prev_char(EditLine *el, wint_t c __attribute__((__unused__)))
{
	return cv_csearch(el, CHAR_BACK, -1, el->el_state.argument, 1);
}


/* vi_repeat_next_char():
 *	Vi repeat current character search in the same search direction
 *	[;]
 */
protected el_action_t
/*ARGSUSED*/
vi_repeat_next_char(EditLine *el, wint_t c __attribute__((__unused__)))
{

	return cv_csearch(el, el->el_search.chadir, el->el_search.chacha,
		el->el_state.argument, el->el_search.chatflg);
}


/* vi_repeat_prev_char():
 *	Vi repeat current character search in the opposite search direction
 *	[,]
 */
protected el_action_t
/*ARGSUSED*/
vi_repeat_prev_char(EditLine *el, wint_t c __attribute__((__unused__)))
{
	el_action_t r;
	int dir = el->el_search.chadir;

	r = cv_csearch(el, -dir, el->el_search.chacha,
		el->el_state.argument, el->el_search.chatflg);
	el->el_search.chadir = dir;
	return r;
}


/* vi_match():
 *	Vi go to matching () {} or []
 *	[%]
 */
protected el_action_t
/*ARGSUSED*/
vi_match(EditLine *el, wint_t c __attribute__((__unused__)))
{
	const wchar_t match_chars[] = L"()[]{}";
	wchar_t *cp;
	size_t delta, i, count;
	wchar_t o_ch, c_ch;

	*el->el_line.lastchar = '\0';		/* just in case */

	i = wcscspn(el->el_line.cursor, match_chars);
	o_ch = el->el_line.cursor[i];
	if (o_ch == 0)
		return CC_ERROR;
	delta = wcschr(match_chars, o_ch) - match_chars;
	c_ch = match_chars[delta ^ 1];
	count = 1;
	delta = 1 - (delta & 1) * 2;

	for (cp = &el->el_line.cursor[i]; count; ) {
		cp += delta;
		if (cp < el->el_line.buffer || cp >= el->el_line.lastchar)
			return CC_ERROR;
		if (*cp == o_ch)
			count++;
		else if (*cp == c_ch)
			count--;
	}

	el->el_line.cursor = cp;

	if (el->el_chared.c_vcmd.action != NOP) {
		/* NB posix says char under cursor should NOT be deleted
		   for -ve delta - this is different to netbsd vi. */
		if (delta > 0)
			el->el_line.cursor++;
		cv_delfini(el);
		return CC_REFRESH;
	}
	return CC_CURSOR;
}

/* vi_undo_line():
 *	Vi undo all changes to line
 *	[U]
 */
protected el_action_t
/*ARGSUSED*/
vi_undo_line(EditLine *el, wint_t c __attribute__((__unused__)))
{

	cv_undo(el);
	return hist_get(el);
}

/* vi_to_column():
 *	Vi go to specified column
 *	[|]
 * NB netbsd vi goes to screen column 'n', posix says nth character
 */
protected el_action_t
/*ARGSUSED*/
vi_to_column(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_line.cursor = el->el_line.buffer;
	el->el_state.argument--;
	return ed_next_char(el, 0);
}

/* vi_yank_end():
 *	Vi yank to end of line
 *	[Y]
 */
protected el_action_t
/*ARGSUSED*/
vi_yank_end(EditLine *el, wint_t c __attribute__((__unused__)))
{

	cv_yank(el, el->el_line.cursor,
	    (int)(el->el_line.lastchar - el->el_line.cursor));
	return CC_REFRESH;
}

/* vi_yank():
 *	Vi yank
 *	[y]
 */
protected el_action_t
/*ARGSUSED*/
vi_yank(EditLine *el, wint_t c __attribute__((__unused__)))
{

	return cv_action(el, YANK);
}

/* vi_comment_out():
 *	Vi comment out current command
 *	[#]
 */
protected el_action_t
/*ARGSUSED*/
vi_comment_out(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_line.cursor = el->el_line.buffer;
	c_insert(el, 1);
	*el->el_line.cursor = '#';
	re_refresh(el);
	return ed_newline(el, 0);
}

/* vi_alias():
 *	Vi include shell alias
 *	[@@]
 * NB: posix implies that we should enter insert mode, however
 * this is against historical precedent...
 */
#ifdef __weak_reference
__weakref_visible char *my_get_alias_text(const char *)
    __weak_reference(get_alias_text);
#endif
protected el_action_t
/*ARGSUSED*/
vi_alias(EditLine *el, wint_t c __attribute__((__unused__)))
{
#ifdef __weak_reference
	char alias_name[3];
	char *alias_text;

	if (my_get_alias_text == 0) {
		return CC_ERROR;
	}

	alias_name[0] = '_';
	alias_name[2] = 0;
	if (el_getc(el, &alias_name[1]) != 1)
		return CC_ERROR;

	alias_text = my_get_alias_text(alias_name);
	if (alias_text != NULL)
		el_wpush(el, ct_decode_string(alias_text, &el->el_scratch));
	return CC_NORM;
#else
	return CC_ERROR;
#endif
}

/* vi_to_history_line():
 *	Vi go to specified history file line.
 *	[G]
 */
protected el_action_t
/*ARGSUSED*/
vi_to_history_line(EditLine *el, wint_t c __attribute__((__unused__)))
{
	int sv_event_no = el->el_history.eventno;
	el_action_t rval;


	if (el->el_history.eventno == 0) {
		 (void) wcsncpy(el->el_history.buf, el->el_line.buffer,
		     EL_BUFSIZ);
		 el->el_history.last = el->el_history.buf +
			 (el->el_line.lastchar - el->el_line.buffer);
	}

	/* Lack of a 'count' means oldest, not 1 */
	if (!el->el_state.doingarg) {
		el->el_history.eventno = 0x7fffffff;
		hist_get(el);
	} else {
		/* This is brain dead, all the rest of this code counts
		 * upwards going into the past.  Here we need count in the
		 * other direction (to match the output of fc -l).
		 * I could change the world, but this seems to suffice.
		 */
		el->el_history.eventno = 1;
		if (hist_get(el) == CC_ERROR)
			return CC_ERROR;
		el->el_history.eventno = 1 + el->el_history.ev.num
					- el->el_state.argument;
		if (el->el_history.eventno < 0) {
			el->el_history.eventno = sv_event_no;
			return CC_ERROR;
		}
	}
	rval = hist_get(el);
	if (rval == CC_ERROR)
		el->el_history.eventno = sv_event_no;
	return rval;
}

/* vi_histedit():
 *	Vi edit history line with vi
 *	[v]
 */
protected el_action_t
/*ARGSUSED*/
vi_histedit(EditLine *el, wint_t c __attribute__((__unused__)))
{
	int fd;
	pid_t pid;
	ssize_t st;
	int status;
	char tempfile[] = "/tmp/histedit.XXXXXXXXXX";
	char *cp;
	size_t len;
	wchar_t *line;

	if (el->el_state.doingarg) {
		if (vi_to_history_line(el, 0) == CC_ERROR)
			return CC_ERROR;
	}

	fd = mkstemp(tempfile);
	if (fd < 0)
		return CC_ERROR;
	len = (size_t)(el->el_line.lastchar - el->el_line.buffer);
#define TMP_BUFSIZ (EL_BUFSIZ * MB_LEN_MAX)
	cp = malloc(TMP_BUFSIZ);
	if (cp == NULL) {
		close(fd);
		unlink(tempfile);
		return CC_ERROR;
	}
	line = reallocarray(NULL, len, sizeof(*line));
	if (line == NULL) {
		close(fd);
		unlink(tempfile);
		free(cp);
		return CC_ERROR;
	}
	wcsncpy(line, el->el_line.buffer, len);
	line[len] = '\0';
	wcstombs(cp, line, TMP_BUFSIZ - 1);
	cp[TMP_BUFSIZ - 1] = '\0';
	len = strlen(cp);
	write(fd, cp, len);
	write(fd, "\n", 1);
	pid = fork();
	switch (pid) {
	case -1:
		close(fd);
		unlink(tempfile);
		free(cp);
                free(line);
		return CC_ERROR;
	case 0:
		close(fd);
		execlp("vi", "vi", tempfile, (char *)NULL);
		exit(0);
		/*NOTREACHED*/
	default:
		while (waitpid(pid, &status, 0) != pid)
			continue;
		lseek(fd, (off_t)0, SEEK_SET);
		st = read(fd, cp, TMP_BUFSIZ);
		if (st > 0) {
			len = (size_t)(el->el_line.lastchar -
			    el->el_line.buffer);
			len = mbstowcs(el->el_line.buffer, cp, len);
			if (len > 0 && el->el_line.buffer[len -1] == '\n')
				--len;
		}
		else
			len = 0;
                el->el_line.cursor = el->el_line.buffer;
                el->el_line.lastchar = el->el_line.buffer + len;
		free(cp);
                free(line);
		break;
	}

	close(fd);
	unlink(tempfile);
	/* return CC_REFRESH; */
	return ed_newline(el, 0);
}

/* vi_history_word():
 *	Vi append word from previous input line
 *	[_]
 * Who knows where this one came from!
 * '_' in vi means 'entire current line', so 'cc' is a synonym for 'c_'
 */
protected el_action_t
/*ARGSUSED*/
vi_history_word(EditLine *el, wint_t c __attribute__((__unused__)))
{
	const wchar_t *wp = HIST_FIRST(el);
	const wchar_t *wep, *wsp;
	int len;
	wchar_t *cp;
	const wchar_t *lim;

	if (wp == NULL)
		return CC_ERROR;

	wep = wsp = NULL;
	do {
		while (iswspace(*wp))
			wp++;
		if (*wp == 0)
			break;
		wsp = wp;
		while (*wp && !iswspace(*wp))
			wp++;
		wep = wp;
	} while ((!el->el_state.doingarg || --el->el_state.argument > 0)
	    && *wp != 0);

	if (wsp == NULL || (el->el_state.doingarg && el->el_state.argument != 0))
		return CC_ERROR;

	cv_undo(el);
	len = (int)(wep - wsp);
	if (el->el_line.cursor < el->el_line.lastchar)
		el->el_line.cursor++;
	c_insert(el, len + 1);
	cp = el->el_line.cursor;
	lim = el->el_line.limit;
	if (cp < lim)
		*cp++ = ' ';
	while (wsp < wep && cp < lim)
		*cp++ = *wsp++;
	el->el_line.cursor = cp;

	el->el_map.current = el->el_map.key;
	return CC_REFRESH;
}

/* vi_redo():
 *	Vi redo last non-motion command
 *	[.]
 */
protected el_action_t
/*ARGSUSED*/
vi_redo(EditLine *el, wint_t c __attribute__((__unused__)))
{
	c_redo_t *r = &el->el_chared.c_redo;

	if (!el->el_state.doingarg && r->count) {
		el->el_state.doingarg = 1;
		el->el_state.argument = r->count;
	}

	el->el_chared.c_vcmd.pos = el->el_line.cursor;
	el->el_chared.c_vcmd.action = r->action;
	if (r->pos != r->buf) {
		if (r->pos + 1 > r->lim)
			/* sanity */
			r->pos = r->lim - 1;
		r->pos[0] = 0;
		el_wpush(el, r->buf);
	}

	el->el_state.thiscmd = r->cmd;
	el->el_state.thisch = r->ch;
	return (*el->el_map.func[r->cmd])(el, r->ch);
}
@


1.24
log
@delete the "private" and "public" preprocessor macros, just use standard C;
OK martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.23 2016/04/11 20:43:33 schwarze Exp $	*/
d51 1
@


1.23
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.22 2016/04/11 19:54:54 schwarze Exp $	*/
d53 2
a54 2
private el_action_t	cv_action(EditLine *, wint_t);
private el_action_t	cv_paste(EditLine *, wint_t);
d59 1
a59 1
private el_action_t
d91 1
a91 1
private el_action_t
@


1.22
log
@Move wrapper macros to the two files actually needing them:
FUNW, Strlen, Strdup, Strcmp, Strncmp, Strncpy, Strncat -> history.c
Strchr, tok_strdup -> tokenizer.c
FUN, TYPE, STR -> both of these files

OK martijn@@

Also proofread by Christian Heckendorf <mbie at ulmus dot me>
who reported some whitespace issues in parse.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.21 2016/04/09 20:28:27 schwarze Exp $	*/
d645 1
a645 1
	Char *kp, *cp;
d806 2
a807 2
	const Char match_chars[] = L"()[]{}";
	Char *cp;
d809 1
a809 1
	Char o_ch, c_ch;
d1011 1
a1011 1
	Char *line;
d1093 2
a1094 2
	const Char *wp = HIST_FIRST(el);
	const Char *wep, *wsp;
d1096 2
a1097 2
	Char *cp;
	const Char *lim;
@


1.21
log
@For pointers, use NULL rather than 0; no functional change;
from Pedro Giffuni via Christos Zoulas.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.20 2016/04/09 20:15:26 schwarze Exp $	*/
d806 1
a806 1
	const Char match_chars[] = STR("()[]{}");
d817 1
a817 1
	delta = Strchr(match_chars, o_ch) - match_chars;
d944 1
a944 1
		FUN(el,push)(el, ct_decode_string(alias_text, &el->el_scratch));
d964 1
a964 1
		 (void) Strncpy(el->el_history.buf, el->el_line.buffer,
d1036 1
a1036 1
	Strncpy(line, el->el_line.buffer, len);
d1157 1
a1157 1
		FUN(el,push)(el, r->buf);
@


1.20
log
@Delete 26 wrapper macros and two wrapper functions that are no
longer needed now that we always compile with wide character support,
reducing code obfuscation.

OK czarkoff@@ martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.19 2016/03/22 11:32:18 schwarze Exp $	*/
d1102 1
a1102 1
	wep = wsp = 0;
d1115 1
a1115 1
	if (wsp == 0 || (el->el_state.doingarg && el->el_state.argument != 0))
@


1.19
log
@format string fixes in debug code;
committing right away because this code is not even compiled by default
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.18 2016/03/20 23:48:27 schwarze Exp $	*/
d100 1
a100 1
	(void) fprintf(el->el_errfile, "Paste: \"" FSTARSTR "\"\n", (int)len,
d258 4
a261 4
		if (Isupper(c))
			*el->el_line.cursor = Tolower(c);
		else if (Islower(c))
			*el->el_line.cursor = Toupper(c);
d813 1
a813 1
	i = Strcspn(el->el_line.cursor, match_chars);
d1038 1
a1038 1
	ct_wcstombs(cp, line, TMP_BUFSIZ - 1);
d1064 1
a1064 1
			len = ct_mbstowcs(el->el_line.buffer, cp, len);
d1104 1
a1104 1
		while (Isspace(*wp))
d1109 1
a1109 1
		while (*wp && !Isspace(*wp))
@


1.18
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.17 2016/03/20 22:57:59 schwarze Exp $	*/
d100 2
a101 1
	(void) fprintf(el->el_errfile, "Paste: \"%.*s\"\n", (int)len, k->buf);
@


1.17
log
@Cleanup of private header inclusion:

1. Do not include private headers from "chared.h", "hist.h", "prompt.h",
"refresh.h", "search.h", "sig.h", "terminal.h", "tty.h".
The only private header having to include other private headers is "el.h".
2. Do not include "common.h", "parse.h", "help.h" from "el.h",
and do not include "emacs.h" and "vi.h" from "chared.h",
include them directly where needed.
3. Do include "fcns.h" from "el.h" because el_func_t is needed for "map.h".
4. Do not include private headers again that are already included by "el.h".
5. Include private headers after standard headers.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.16 2016/03/20 20:35:38 schwarze Exp $	*/
a36 4
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <sys/wait.h>
d41 7
d582 1
a582 1
 * 	Vi move to previous character (backspace)
d982 1
a982 1
		el->el_history.eventno = 1 + el->el_history.ev.num 
@


1.16
log
@Delete the useless Int datatype and always use the standard wint_t
directly.  This is not a problem because <wchar_t> is required all
over the place anyway, even when WIDECHAR is not defined.
No functional change except that it fixes a few printf(3)
format string issues, %c vs. %lc.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.15 2016/01/30 17:32:52 schwarze Exp $	*/
d46 3
@


1.15
log
@Fifth step in synching with NetBSD:
Delete the silly ptr_t and ioctl_t typedefs
and delete some "#ifdef notdef" code from "sys.h".
No functional change.
This makes hist.h identical to the NetBSD version.
It reduces the remaining diff from +1526 -734 to +1430 -592.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.14 2016/01/30 12:22:20 schwarze Exp $	*/
d47 2
a48 2
private el_action_t	cv_action(EditLine *, Int);
private el_action_t	cv_paste(EditLine *, Int);
d54 1
a54 1
cv_action(EditLine *el, Int c)
d59 1
a59 1
		if (c != el->el_chared.c_vcmd.action)
d86 1
a86 1
cv_paste(EditLine *el, Int c)
d118 1
a118 1
vi_paste_next(EditLine *el, Int c __attribute__((__unused__)))
d131 1
a131 1
vi_paste_prev(EditLine *el, Int c __attribute__((__unused__)))
d144 1
a144 1
vi_prev_big_word(EditLine *el, Int c __attribute__((__unused__)))
d169 1
a169 1
vi_prev_word(EditLine *el, Int c __attribute__((__unused__)))
d194 1
a194 1
vi_next_big_word(EditLine *el, Int c __attribute__((__unused__)))
d218 1
a218 1
vi_next_word(EditLine *el, Int c __attribute__((__unused__)))
d241 1
a241 1
vi_change_case(EditLine *el, Int c)
d273 1
a273 1
vi_change_meta(EditLine *el, Int c __attribute__((__unused__)))
d290 1
a290 1
vi_insert_at_bol(EditLine *el, Int c __attribute__((__unused__)))
d306 1
a306 1
vi_replace_char(EditLine *el, Int c __attribute__((__unused__)))
d325 1
a325 1
vi_replace_mode(EditLine *el, Int c __attribute__((__unused__)))
d341 1
a341 1
vi_substitute_char(EditLine *el, Int c __attribute__((__unused__)))
d356 1
a356 1
vi_substitute_line(EditLine *el, Int c __attribute__((__unused__)))
d374 1
a374 1
vi_change_to_eol(EditLine *el, Int c __attribute__((__unused__)))
d392 1
a392 1
vi_insert(EditLine *el, Int c __attribute__((__unused__)))
d407 1
a407 1
vi_add(EditLine *el, Int c __attribute__((__unused__)))
d432 1
a432 1
vi_add_at_eol(EditLine *el, Int c __attribute__((__unused__)))
d448 1
a448 1
vi_delete_meta(EditLine *el, Int c __attribute__((__unused__)))
d461 1
a461 1
vi_end_big_word(EditLine *el, Int c)
d485 1
a485 1
vi_end_word(EditLine *el, Int c __attribute__((__unused__)))
d509 1
a509 1
vi_undo(EditLine *el, Int c __attribute__((__unused__)))
d536 1
a536 1
vi_command_mode(EditLine *el, Int c __attribute__((__unused__)))
d560 1
a560 1
vi_zero(EditLine *el, Int c)
d581 1
a581 1
vi_delete_prev_char(EditLine *el, Int c __attribute__((__unused__)))
d599 1
a599 1
vi_list_or_eof(EditLine *el, Int c)
d636 1
a636 1
vi_kill_line_prev(EditLine *el, Int c __attribute__((__unused__)))
d657 1
a657 1
vi_search_prev(EditLine *el, Int c __attribute__((__unused__)))
d670 1
a670 1
vi_search_next(EditLine *el, Int c __attribute__((__unused__)))
d683 1
a683 1
vi_repeat_search_next(EditLine *el, Int c __attribute__((__unused__)))
d699 1
a699 1
vi_repeat_search_prev(EditLine *el, Int c __attribute__((__unused__)))
d717 1
a717 1
vi_next_char(EditLine *el, Int c __attribute__((__unused__)))
d729 1
a729 1
vi_prev_char(EditLine *el, Int c __attribute__((__unused__)))
d741 1
a741 1
vi_to_next_char(EditLine *el, Int c __attribute__((__unused__)))
d753 1
a753 1
vi_to_prev_char(EditLine *el, Int c __attribute__((__unused__)))
d765 1
a765 1
vi_repeat_next_char(EditLine *el, Int c __attribute__((__unused__)))
d779 1
a779 1
vi_repeat_prev_char(EditLine *el, Int c __attribute__((__unused__)))
d797 1
a797 1
vi_match(EditLine *el, Int c)
d844 1
a844 1
vi_undo_line(EditLine *el, Int c)
d858 1
a858 1
vi_to_column(EditLine *el, Int c)
d872 1
a872 1
vi_yank_end(EditLine *el, Int c)
d886 1
a886 1
vi_yank(EditLine *el, Int c)
d898 1
a898 1
vi_comment_out(EditLine *el, Int c)
d920 1
a920 1
vi_alias(EditLine *el, Int c)
d950 1
a950 1
vi_to_history_line(EditLine *el, Int c)
d995 1
a995 1
vi_histedit(EditLine *el, Int c)
d1084 1
a1084 1
vi_history_word(EditLine *el, Int c)
d1134 1
a1134 1
vi_redo(EditLine *el, Int c)
@


1.14
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.13 2016/01/30 00:06:39 schwarze Exp $	*/
d1026 1
a1026 1
		free((ptr_t)cp);
@


1.13
log
@Third step in synching with NetBSD:
* rename fkey_t to funckey_t and el_term_t to el_terminal_t
* rename struct editline member el_term to el_terminal
* rename many functions in terminal.c from term_*() to terminal_*(),
for consistency with the file name and to not look related to <term.h>
No functional change.
This makes refresh.c and sig.c almost identical to the NetBSD versions.
It reduces the remaining diff from +2446 -1805 to +2053 -1420.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.12 2014/10/17 06:07:50 deraadt Exp $	*/
d75 1
a75 1
		return (CC_REFRESH);
d79 1
a79 1
	return (CC_ARGHACK);
d92 1
a92 1
		return (CC_ERROR);
d104 1
a104 1
		return (CC_ERROR);
d108 1
a108 1
	return (CC_REFRESH);
d121 1
a121 1
	return (cv_paste(el, 0));
d134 1
a134 1
	return (cv_paste(el, 1));
d148 1
a148 1
		return (CC_ERROR);
d157 1
a157 1
		return (CC_REFRESH);
d159 1
a159 1
	return (CC_CURSOR);
d173 1
a173 1
		return (CC_ERROR);
d182 1
a182 1
		return (CC_REFRESH);
d184 1
a184 1
	return (CC_CURSOR);
d198 1
a198 1
		return (CC_ERROR);
d206 1
a206 1
			return (CC_REFRESH);
d208 1
a208 1
	return (CC_CURSOR);
d222 1
a222 1
		return (CC_ERROR);
d230 1
a230 1
			return (CC_REFRESH);
d232 1
a232 1
	return (CC_CURSOR);
d246 1
a246 1
		return (CC_ERROR);
d280 1
a280 1
	return (cv_action(el, DELETE | INSERT));
d296 1
a296 1
	return (CC_CURSOR);
d315 1
a315 1
	return (CC_ARGHACK);
d331 1
a331 1
	return (CC_NORM);
d346 1
a346 1
	return (CC_REFRESH);
d364 1
a364 1
	return (CC_REFRESH);
d382 1
a382 1
	return (CC_REFRESH);
d397 1
a397 1
	return (CC_NORM);
d422 1
a422 1
	return (ret);
d438 1
a438 1
	return (CC_CURSOR);
d451 1
a451 1
	return (cv_action(el, DELETE));
d465 1
a465 1
		return (CC_ERROR);
d473 1
a473 1
		return (CC_REFRESH);
d475 1
a475 1
	return (CC_CURSOR);
d489 1
a489 1
		return (CC_ERROR);
d497 1
a497 1
		return (CC_REFRESH);
d499 1
a499 1
	return (CC_CURSOR);
d526 1
a526 1
	return (CC_REFRESH);
d551 1
a551 1
	return (CC_CURSOR);
d569 1
a569 1
		return (CC_REFRESH);
d571 1
a571 1
	return (CC_CURSOR);
d585 1
a585 1
		return (CC_ERROR);
d589 1
a589 1
	return (CC_REFRESH);
d605 1
a605 1
			return (CC_EOF);
d612 1
a612 1
			return (CC_ERROR);
d618 1
a618 1
		return (CC_LIST_CHOICES);
d624 1
a624 1
		return (CC_ERROR);
d647 1
a647 1
	return (CC_REFRESH);
d660 1
a660 1
	return (cv_search(el, ED_SEARCH_PREV_HISTORY));
d673 1
a673 1
	return (cv_search(el, ED_SEARCH_NEXT_HISTORY));
d687 1
a687 1
		return (CC_ERROR);
d689 1
a689 1
		return (cv_repeat_srch(el, el->el_search.patdir));
d703 1
a703 1
		return (CC_ERROR);
d833 1
a833 1
		return (CC_REFRESH);
d835 1
a835 1
	return (CC_CURSOR);
d1155 1
a1155 1
	return  (*el->el_map.func[r->cmd])(el, r->ch);
@


1.12
log
@Remove non-exposed malloc/realloc/free wrappers, and then substitute
reallocarray() where it helps.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.11 2011/07/07 05:40:42 okan Exp $	*/
d604 1
a604 1
			term_writec(el, c);	/* then do a EOF */
d611 1
a611 1
			term_beep(el);
d623 1
a623 1
		term_beep(el);
@


1.11
log
@sync with upstream, retaining local modifications.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.10 2010/10/23 18:53:10 nicm Exp $	*/
d1016 1
a1016 1
	cp = el_malloc(TMP_BUFSIZ);
d1022 1
a1022 1
	line = el_malloc(len * sizeof(*line));
d1026 1
a1026 1
		el_free((ptr_t)cp);
d1041 2
a1042 2
		el_free(cp);
                el_free(line);
d1065 2
a1066 2
		el_free(cp);
                el_free(line);
@


1.10
log
@Don't leak the fd returned by mkstemp in vi_histedit error paths.

From zinovik.
@
text
@d1 2
a2 2
/*	$OpenBSD: vi.c,v 1.9 2010/06/30 00:05:35 nicm Exp $	*/
/*	$NetBSD: vi.c,v 1.31 2009/12/30 22:37:40 christos Exp $	*/
d915 2
a916 1
extern char *get_alias_text(const char *) __weak_reference(get_alias_text);
d926 1
a926 1
	if (get_alias_text == 0) {
d935 1
a935 1
	alias_text = get_alias_text(alias_name);
@


1.9
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1016 3
a1018 1
	if (cp == NULL)
d1020 1
d1023 2
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
a2 2
/*	$OpenBSD: vi.c,v 1.7 2003/10/31 08:42:24 otto Exp $	*/
/*	$NetBSD: vi.c,v 1.19 2003/08/07 16:44:35 agc Exp $	*/
d39 1
d47 2
a48 2
private el_action_t	cv_action(EditLine *, int);
private el_action_t	cv_paste(EditLine *, int);
d54 1
a54 1
cv_action(EditLine *el, int c)
d65 1
a65 1
			    el->el_line.lastchar - el->el_line.buffer);
d68 4
a71 2
		el->el_line.lastchar = el->el_line.buffer;
		el->el_line.cursor = el->el_line.buffer;
d86 1
a86 1
cv_paste(EditLine *el, int c)
a87 1
	char *ptr;
d89 1
a89 1
	int len = k->last - k->buf;
d94 1
a94 1
	(void) fprintf(el->el_errfile, "Paste: \"%.*s\"\n", len, k->buf);
a100 1
	ptr = el->el_line.cursor;
d102 1
a102 1
	c_insert(el, len);
d105 3
a107 1
	(void) memcpy(ptr, k->buf, len +0u);
d118 1
a118 1
vi_paste_next(EditLine *el, int c __attribute__((__unused__)))
d131 1
a131 1
vi_paste_prev(EditLine *el, int c __attribute__((__unused__)))
d144 1
a144 1
vi_prev_big_word(EditLine *el, int c)
d169 1
a169 1
vi_prev_word(EditLine *el, int c __attribute__((__unused__)))
d194 1
a194 1
vi_next_big_word(EditLine *el, int c)
d218 1
a218 1
vi_next_word(EditLine *el, int c __attribute__((__unused__)))
d241 1
a241 1
vi_change_case(EditLine *el, int c)
d250 5
a254 5
		c = *(unsigned char *)el->el_line.cursor;
		if (isupper(c))
			*el->el_line.cursor = tolower(c);
		else if (islower(c))
			*el->el_line.cursor = toupper(c);
d273 1
a273 1
vi_change_meta(EditLine *el, int c __attribute__((__unused__)))
d290 1
a290 1
vi_insert_at_bol(EditLine *el, int c __attribute__((__unused__)))
d306 1
a306 1
vi_replace_char(EditLine *el, int c __attribute__((__unused__)))
d325 1
a325 1
vi_replace_mode(EditLine *el, int c __attribute__((__unused__)))
d341 1
a341 1
vi_substitute_char(EditLine *el, int c __attribute__((__unused__)))
d356 1
a356 1
vi_substitute_line(EditLine *el, int c __attribute__((__unused__)))
d361 1
a361 1
		    el->el_line.lastchar - el->el_line.buffer);
d374 1
a374 1
vi_change_to_eol(EditLine *el, int c __attribute__((__unused__)))
d379 1
a379 1
		    el->el_line.lastchar - el->el_line.cursor);
d392 1
a392 1
vi_insert(EditLine *el, int c __attribute__((__unused__)))
d407 1
a407 1
vi_add(EditLine *el, int c __attribute__((__unused__)))
d432 1
a432 1
vi_add_at_eol(EditLine *el, int c __attribute__((__unused__)))
d448 1
a448 1
vi_delete_meta(EditLine *el, int c __attribute__((__unused__)))
d461 1
a461 1
vi_end_big_word(EditLine *el, int c)
d485 1
a485 1
vi_end_word(EditLine *el, int c __attribute__((__unused__)))
d509 1
a509 1
vi_undo(EditLine *el, int c __attribute__((__unused__)))
d519 2
a520 1
	el->el_chared.c_undo.cursor = el->el_line.cursor - el->el_line.buffer;
d536 1
a536 1
vi_command_mode(EditLine *el, int c __attribute__((__unused__)))
d560 1
a560 1
vi_zero(EditLine *el, int c)
d581 1
a581 1
vi_delete_prev_char(EditLine *el, int c __attribute__((__unused__)))
a582 1
	char *cp;
d584 1
a584 2
	cp = el->el_line.cursor;
	if (cp <= el->el_line.buffer)
d587 2
a588 6
	/* do the delete here so we dont mess up the undo and paste buffers */
	el->el_line.cursor = --cp;
	for (; cp < el->el_line.lastchar; cp++)
		cp[0] = cp[1];
	el->el_line.lastchar = cp - 1;

d599 1
a599 1
vi_list_or_eof(EditLine *el, int c __attribute__((__unused__)))
d604 1
a604 2
			term_overwrite(el, STReof, 4);	/* then do a EOF */
			term__flush();
d636 1
a636 1
vi_kill_line_prev(EditLine *el, int c __attribute__((__unused__)))
d638 1
a638 1
	char *kp, *cp;
d645 1
a645 1
	c_delbefore(el, el->el_line.cursor - el->el_line.buffer);
d657 1
a657 1
vi_search_prev(EditLine *el, int c __attribute__((__unused__)))
d670 1
a670 1
vi_search_next(EditLine *el, int c __attribute__((__unused__)))
d683 1
a683 1
vi_repeat_search_next(EditLine *el, int c __attribute__((__unused__)))
d699 1
a699 1
vi_repeat_search_prev(EditLine *el, int c __attribute__((__unused__)))
d717 1
a717 1
vi_next_char(EditLine *el, int c __attribute__((__unused__)))
d729 1
a729 1
vi_prev_char(EditLine *el, int c __attribute__((__unused__)))
d741 1
a741 1
vi_to_next_char(EditLine *el, int c __attribute__((__unused__)))
d753 1
a753 1
vi_to_prev_char(EditLine *el, int c __attribute__((__unused__)))
d765 1
a765 1
vi_repeat_next_char(EditLine *el, int c __attribute__((__unused__)))
d779 1
a779 1
vi_repeat_prev_char(EditLine *el, int c __attribute__((__unused__)))
d797 1
a797 1
vi_match(EditLine *el, int c)
d799 4
a802 4
	const char match_chars[] = "()[]{}";
	char *cp;
	int delta, i, count;
	char o_ch, c_ch;
d806 1
a806 1
	i = strcspn(el->el_line.cursor, match_chars);
d810 1
a810 1
	delta = strchr(match_chars, o_ch) - match_chars;
d844 1
a844 1
vi_undo_line(EditLine *el, int c)
d858 1
a858 1
vi_to_column(EditLine *el, int c)
d872 1
a872 1
vi_yank_end(EditLine *el, int c)
d876 1
a876 1
		el->el_line.lastchar - el->el_line.cursor);
d886 1
a886 1
vi_yank(EditLine *el, int c)
d894 1
a894 1
 *	[c]
d898 1
a898 1
vi_comment_out(EditLine *el, int c)
d911 1
a911 1
 * NB: posix impiles that we should enter insert mode, however
d914 3
d919 1
a919 1
vi_alias(EditLine *el, int c)
d921 1
a921 1
#ifdef __weak_extern
a923 2
	extern char *get_alias_text(const char *);
	__weak_extern(get_alias_text);
d936 1
a936 1
		el_push(el, alias_text);
d949 1
a949 1
vi_to_history_line(EditLine *el, int c)
d956 1
a956 1
		 (void) strncpy(el->el_history.buf, el->el_line.buffer,
d994 1
a994 1
vi_histedit(EditLine *el, int c)
d998 2
a999 1
	int st;
d1002 2
d1013 16
a1028 2
	cp = el->el_line.buffer;
	write(fd, cp, el->el_line.lastchar - cp +0u);
d1035 2
d1040 1
a1040 1
		execlp("vi", "vi", tempfile, (char*)NULL);
d1044 1
a1044 1
		while (waitpid(pid, &st, 0) != pid)
d1046 15
a1060 6
		lseek(fd, 0ll, SEEK_SET);
		st = read(fd, cp, el->el_line.limit - cp +0u);
		if (st > 0 && cp[st - 1] == '\n')
			st--;
		el->el_line.cursor = cp;
		el->el_line.lastchar = cp + st;
d1078 1
a1078 1
vi_history_word(EditLine *el, int c)
d1080 2
a1081 2
	const char *wp = HIST_FIRST(el);
	const char *wep, *wsp;
d1083 2
a1084 2
	char *cp;
	const char *lim;
d1091 1
a1091 1
		while (isspace((unsigned char)*wp))
d1096 1
a1096 1
		while (*wp && !isspace((unsigned char)*wp))
d1099 2
a1100 1
	} while ((!el->el_state.doingarg || --el->el_state.argument > 0) && *wp != 0);
d1106 1
a1106 1
	len = wep - wsp;
d1128 1
a1128 1
vi_redo(EditLine *el, int c)
d1144 1
a1144 1
		el_push(el, r->buf);
@


1.7
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a39 8

#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)vi.c	8.1 (Berkeley) 6/4/93";
#else
static const char rcsid[] = "$OpenBSD$";
#endif
#endif /* not lint && not SCCSID */
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: vi.c,v 1.5 2003/05/01 21:11:21 avsm Exp $	*/
/*	$NetBSD: vi.c,v 1.2 1997/01/11 06:48:19 lukem Exp $	*/
d36 5
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: vi.c,v 1.5 2003/05/01 21:11:21 avsm Exp $";
a51 1
#include "sys.h"
d54 2
a55 1
private el_action_t cv_action(EditLine *, int);
d61 1
a61 3
cv_action(el, c)
    EditLine *el;
    int c;
a62 1
    register char *cp, *kp;
d64 15
a78 21
    if (el->el_chared.c_vcmd.action & DELETE) {
	el->el_chared.c_vcmd.action = NOP;
	el->el_chared.c_vcmd.pos = 0;
	
	el->el_chared.c_undo.isize = 0;
	el->el_chared.c_undo.dsize = 0;
	kp = el->el_chared.c_undo.buf;
	for (cp = el->el_line.buffer; cp < el->el_line.lastchar; cp++) {
	    *kp++ = *cp;
	    el->el_chared.c_undo.dsize++;
	}
		
	el->el_chared.c_undo.action = INSERT;
	el->el_chared.c_undo.ptr  = el->el_line.buffer;
	el->el_line.lastchar = el->el_line.buffer;
	el->el_line.cursor   = el->el_line.buffer;
	if (c & INSERT)
	    el->el_map.current = el->el_map.key;
	    
	return CC_REFRESH;
    }
d80 2
a81 9
    el->el_chared.c_vcmd.pos = el->el_line.cursor;
    el->el_chared.c_vcmd.action = c;
    return CC_ARGHACK;

#ifdef notdef
    /*
     * I don't think that this is needed. But we keep it for now
     */
    else if (el_chared.c_vcmd.action == NOP) {
d84 1
a84 8
	return CC_ARGHACK;
    }
    else {
	el->el_chared.c_vcmd.action = 0;
	el->el_chared.c_vcmd.pos = 0;
	return CC_ERROR;
    }
#endif
a86 1

d90 2
a91 4
protected el_action_t
cv_paste(el, c)
    EditLine *el;
    int c;
d93 6
a98 2
    char *ptr;
    c_undo_t *un = &el->el_chared.c_undo;
d100 1
a100 2
    (void)fprintf(el->el_errfile, "Paste: %x \"%s\" +%d -%d\n", 
		   un->action, un->buf, un->isize, un->dsize);
a101 2
    if (un->isize == 0)
	return CC_ERROR;
d103 11
a113 9
    if (!c && el->el_line.cursor < el->el_line.lastchar)
	el->el_line.cursor++;
    ptr = el->el_line.cursor;
	
    c_insert(el, un->isize);
    if (el->el_line.cursor + un->isize > el->el_line.lastchar)
	return CC_ERROR;
    (void)memcpy(ptr, un->buf, un->isize);
    return CC_REFRESH;
d117 1
a117 1
/* vi_paste_next(): 
d123 1
a123 3
vi_paste_next(el, c)
    EditLine *el;
    int c;
d125 2
a126 1
    return cv_paste(el, 0);
d130 1
a130 1
/* vi_paste_prev(): 
d136 1
a136 3
vi_paste_prev(el, c)
    EditLine *el;
    int c;
d138 2
a139 1
    return cv_paste(el, 1);
d143 1
a143 1
/* vi_prev_space_word(): 
d149 1
a149 3
vi_prev_space_word(el, c)
    EditLine *el;
    int c;
a150 2
    if (el->el_line.cursor == el->el_line.buffer)
	return CC_ERROR;
d152 2
a153 4
    el->el_line.cursor = cv_prev_word(el, el->el_line.cursor, 
				      el->el_line.buffer, 
			 	      el->el_state.argument, 
				      cv__isword); 
d155 4
a158 4
    if (el->el_chared.c_vcmd.action & DELETE) {
	cv_delfini(el);
	return CC_REFRESH;
    }
d160 5
a164 1
    return CC_CURSOR;
d168 1
a168 1
/* vi_prev_word(): 
d170 1
a170 1
 *	[B]
d174 1
a174 3
vi_prev_word(el, c)
    EditLine *el;
    int c;
a175 2
    if (el->el_line.cursor == el->el_line.buffer)
	return CC_ERROR;
d177 2
a178 4
    el->el_line.cursor = cv_prev_word(el, el->el_line.cursor, 
				      el->el_line.buffer, 
			 	      el->el_state.argument, 
				      ce__isword); 
d180 4
a183 4
    if (el->el_chared.c_vcmd.action & DELETE) {
	cv_delfini(el);
	return CC_REFRESH;
    }
d185 5
a189 1
    return CC_CURSOR;
d193 1
a193 1
/* vi_next_space_word(): 
d199 1
a199 3
vi_next_space_word(el, c)
    EditLine *el;
    int c;
a200 2
    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;
d202 2
a203 4
    el->el_line.cursor = cv_next_word(el, el->el_line.cursor, 
				      el->el_line.lastchar, 
				      el->el_state.argument, 
				      cv__isword);
d205 2
a206 5
    if (el->el_map.type == MAP_VI)
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}
d208 6
a213 1
    return CC_CURSOR;
d216 2
a217 1
/* vi_next_word(): 
d223 1
a223 3
vi_next_word(el, c)
    EditLine *el;
    int c;
a224 2
    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;
d226 2
a227 4
    el->el_line.cursor = cv_next_word(el, el->el_line.cursor, 
				      el->el_line.lastchar, 
				      el->el_state.argument,
				      ce__isword);
d229 2
a230 5
    if (el->el_map.type == MAP_VI)
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}
d232 6
a237 1
    return CC_CURSOR;
d241 1
a241 2

/* vi_change_case(): 
d246 22
a267 13
vi_change_case(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor < el->el_line.lastchar) {
	c = *el->el_line.cursor;
	if (isupper(c))
	    *el->el_line.cursor++ = tolower(c);
	else if (islower(c))
	    *el->el_line.cursor++ = toupper(c);
	else
	    el->el_line.cursor++;
	re_fastaddc(el);
a268 2
    }
    return CC_ERROR;
d272 1
a272 1
/* vi_change_meta(): 
d278 1
a278 3
vi_change_meta(el, c)
    EditLine *el;
    int c;
d280 6
a285 5
    /*
     * Delete with insert == change: first we delete and then we leave in
     * insert mode.
     */
    return cv_action(el, DELETE|INSERT);
d289 1
a289 1
/* vi_insert_at_bol(): 
d295 1
a295 3
vi_insert_at_bol(el, c)
    EditLine *el;
    int c;
a296 2
    el->el_line.cursor = el->el_line.buffer;
    el->el_chared.c_vcmd.ins = el->el_line.cursor;
d298 4
a301 5
    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.action = DELETE;

    el->el_map.current = el->el_map.key;
    return CC_CURSOR;
d305 1
a305 1
/* vi_replace_char(): 
d311 1
a311 3
vi_replace_char(el, c)
    EditLine *el;
    int c;
d313 8
a320 7
    el->el_map.current = el->el_map.key;
    el->el_state.inputmode = MODE_REPLACE_1;
    el->el_chared.c_undo.action = CHANGE;
    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.isize = 0;
    el->el_chared.c_undo.dsize = 0;
    return CC_NORM;
d324 1
a324 1
/* vi_replace_mode(): 
d330 1
a330 3
vi_replace_mode(el, c)
    EditLine *el;
    int c;
d332 5
a336 7
    el->el_map.current = el->el_map.key;
    el->el_state.inputmode = MODE_REPLACE;
    el->el_chared.c_undo.action = CHANGE;
    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.isize = 0;
    el->el_chared.c_undo.dsize = 0;
    return CC_NORM;
d340 1
a340 1
/* vi_substitute_char(): 
d342 1
a342 1
 *	[r]
d346 1
a346 3
vi_substitute_char(el, c)
    EditLine *el;
    int c;
d348 4
a351 3
    c_delafter(el, el->el_state.argument);
    el->el_map.current = el->el_map.key;
    return CC_REFRESH;
d355 1
a355 1
/* vi_substitute_line(): 
d361 1
a361 3
vi_substitute_line(el, c)
    EditLine *el;
    int c;
d363 7
a369 3
    (void)em_kill_line(el, 0);
    el->el_map.current = el->el_map.key;
    return CC_REFRESH;
d373 1
a373 1
/* vi_change_to_eol(): 
d379 9
a387 7
vi_change_to_eol(el, c)
    EditLine *el;
    int c;
{
    (void)ed_kill_line(el, 0);
    el->el_map.current = el->el_map.key;
    return CC_REFRESH;
d397 1
a397 3
vi_insert(el, c)
    EditLine *el;
    int c;
a398 5
    el->el_map.current = el->el_map.key;

    el->el_chared.c_vcmd.ins = el->el_line.cursor;
    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.action = DELETE;
d400 3
a402 1
    return CC_NORM;
d407 1
a407 1
 *	Vi enter insert mode after the cursor 
d412 14
a425 18
vi_add(el, c)
    EditLine *el;
    int c;
{
    int ret;
    el->el_map.current = el->el_map.key;
    if (el->el_line.cursor < el->el_line.lastchar) {
	el->el_line.cursor++;
	if (el->el_line.cursor > el->el_line.lastchar)
	    el->el_line.cursor = el->el_line.lastchar;
	ret = CC_CURSOR;
    }
    else
	ret = CC_NORM;

    el->el_chared.c_vcmd.ins = el->el_line.cursor;
    el->el_chared.c_undo.ptr = el->el_line.cursor;
    el->el_chared.c_undo.action = DELETE;
d427 1
a427 1
    return ret;
d437 7
a443 12
vi_add_at_eol(el, c)
    EditLine *el;
    int c;
{
    el->el_map.current = el->el_map.key;
    el->el_line.cursor = el->el_line.lastchar;

    /* Mark where insertion begins */
    el->el_chared.c_vcmd.ins = el->el_line.lastchar; 
    el->el_chared.c_undo.ptr = el->el_line.lastchar;
    el->el_chared.c_undo.action = DELETE;
    return CC_CURSOR;
d448 1
a448 1
 *	Vi delete prefix command 
d453 1
a453 3
vi_delete_meta(el, c)
    EditLine *el;
    int c;
d455 2
a456 1
    return cv_action(el, DELETE);
d460 3
a462 3
/* vi_end_word():
 *	Vi move to the end of the current space delimited word 
 *	[E] 
d466 1
a466 3
vi_end_word(el, c)
    EditLine *el;
    int c;
a467 2
    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;
d469 2
a470 2
    el->el_line.cursor = cv__endword(el->el_line.cursor, el->el_line.lastchar, 
				     el->el_state.argument);
d472 2
a473 5
    if (el->el_chared.c_vcmd.action & DELETE) {
	el->el_line.cursor++;
	cv_delfini(el);
	return CC_REFRESH;
    }
d475 6
a480 1
    return CC_CURSOR;
d484 1
a484 1
/* vi_to_end_word():
d490 1
a490 3
vi_to_end_word(el, c)
    EditLine *el;
    int c;
a491 2
    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;
d493 2
a494 2
    el->el_line.cursor = cv__endword(el->el_line.cursor, el->el_line.lastchar, 
				     el->el_state.argument);
d496 2
a497 5
    if (el->el_chared.c_vcmd.action & DELETE) {
	el->el_line.cursor++;
	cv_delfini(el);
	return CC_REFRESH;
    }
d499 6
a504 1
    return CC_CURSOR;
d514 6
a519 95
vi_undo(el, c)
    EditLine *el;
    int c;
{
    char *cp, *kp;
    char temp;
    int	 i, size;
    c_undo_t *un = &el->el_chared.c_undo;

#ifdef DEBUG_UNDO
    (void)fprintf(el->el_errfile, "Undo: %x \"%s\" +%d -%d\n", 
		   un->action, un->buf, un->isize, un->dsize);
#endif
    switch (un->action) {
    case DELETE:
	if (un->dsize == 0) 
	    return CC_NORM;

	(void)memcpy(un->buf, un->ptr, un->dsize);
	for (cp = un->ptr; cp <= el->el_line.lastchar; cp++)
	    *cp = cp[un->dsize];

	el->el_line.lastchar -= un->dsize;
	el->el_line.cursor   =  un->ptr;
	
	un->action = INSERT;
	un->isize = un->dsize;
	un->dsize = 0;
	break;

    case DELETE|INSERT:
	size = un->isize - un->dsize;
	if (size > 0) 
	    i = un->dsize;
	else 
	    i = un->isize;
	cp = un->ptr;
	kp = un->buf;
	while (i-- > 0) {
	    temp = *kp;
	    *kp++ = *cp;
	    *cp++ = temp;
	}
	if (size > 0) {
	    el->el_line.cursor = cp;
	    c_insert(el, size);
	    while (size-- > 0 && cp < el->el_line.lastchar) {
		temp = *kp;
		*kp++ = *cp;
		*cp++ = temp;
	    }
	}
	else if (size < 0) {
	    size = -size;
	    for (; cp <= el->el_line.lastchar; cp++) {
		*kp++ = *cp;
		*cp = cp[size];
	    }
	    el->el_line.lastchar -= size;
	}
	el->el_line.cursor = un->ptr;
	i = un->dsize;
	un->dsize = un->isize;
	un->isize = i;
	break;

    case INSERT:
	if (un->isize == 0) 
	    return CC_NORM;

	el->el_line.cursor = un->ptr;
	c_insert(el, un->isize);
	memcpy(un->ptr, un->buf, un->isize);
	un->action = DELETE;
	un->dsize = un->isize;
	un->isize = 0;
	break;

    case CHANGE:
	if (un->isize == 0) 
	    return CC_NORM;

	el->el_line.cursor = un->ptr;
	size = (int) (el->el_line.cursor - el->el_line.lastchar); 
	if (size < un->isize)
	    size = un->isize;
	cp = un->ptr;
	kp = un->buf;
	for(i = 0; i < size; i++) {
	    temp = *kp;
	    *kp++ = *cp;
	    *cp++ = temp;
	}
	un->dsize = 0;
	break;
d521 8
a528 3
    default:
	return CC_ERROR;
    }
d530 1
a530 1
    return CC_REFRESH;
d540 2
a541 19
vi_command_mode(el, c)
    EditLine *el;
    int c;
{
    int size;
    /* [Esc] cancels pending action */
    el->el_chared.c_vcmd.ins = 0;
    el->el_chared.c_vcmd.action = NOP;	
    el->el_chared.c_vcmd.pos = 0;

    el->el_state.doingarg = 0;
    size = el->el_chared.c_undo.ptr - el->el_line.cursor;
    if (size < 0)
	size = -size;
    if (el->el_chared.c_undo.action == (INSERT|DELETE) ||
        el->el_chared.c_undo.action == DELETE)
	el->el_chared.c_undo.dsize = size;
    else
	el->el_chared.c_undo.isize = size;
d543 8
a550 2
    el->el_state.inputmode = MODE_INSERT;
    el->el_map.current = el->el_map.alt;
d552 2
a553 2
    if (el->el_line.cursor > el->el_line.buffer)
	el->el_line.cursor--;
d555 1
a555 1
    return CC_CURSOR;
d558 1
d560 1
a560 1
 *	Vi move to the beginning of line 
d564 6
a569 12
vi_zero(el, c)
    EditLine *el;
    int c;
{
    if (el->el_state.doingarg) {
	if (el->el_state.argument > 1000000)
	    return CC_ERROR;
	el->el_state.argument = 
		(el->el_state.argument * 10) + (c - '0');
	return CC_ARGHACK;
    }
    else {
d571 5
a575 6
	if (el->el_chared.c_vcmd.action & DELETE) {
	   cv_delfini(el);
	   return CC_REFRESH;
        }
	return CC_CURSOR;
    }
d580 3
a582 3
 * 	Vi move to previous character (backspace) 
 *	[^H]
 */ 
d585 1
a585 3
vi_delete_prev_char(el, c)
    EditLine *el;
    int c;
d587 1
a587 2
    if (el->el_chared.c_vcmd.ins == 0) 
	return CC_ERROR;
d589 3
a591 3
    if (el->el_chared.c_vcmd.ins > 
	el->el_line.cursor - el->el_state.argument)
	return CC_ERROR;
d593 5
a597 2
    c_delbefore(el, el->el_state.argument);	
    el->el_line.cursor -= el->el_state.argument;
d599 2
a600 2
    return CC_REFRESH;
} /* end v_del_char_prev  */
d609 1
a609 3
vi_list_or_eof(el, c)
    EditLine *el;
    int c;
d611 15
d627 9
a635 13
    if (el->el_line.cursor == el->el_line.lastchar && 
	el->el_line.cursor == el->el_line.buffer) {
#endif
	term_overwrite(el, STReof, 4);	/* then do a EOF */
	term__flush();
	return CC_EOF;
#ifdef notyet
    }
    else {
	re_goto_bottom(el);
	*el->el_line.lastchar = '\0';	/* just in case */
	return CC_LIST_CHOICES;
    }
d637 1
d642 1
a642 1
 *	Vi cut from beginning of line to cursor 
d647 12
a658 14
vi_kill_line_prev(el, c)
    EditLine *el;
    int c;
{
    char *kp, *cp;

    cp = el->el_line.buffer;
    kp = el->el_chared.c_kill.buf;
    while (cp < el->el_line.cursor)
	*kp++ = *cp++;		/* copy it */
    el->el_chared.c_kill.last = kp;
    c_delbefore(el, el->el_line.cursor - el->el_line.buffer);
    el->el_line.cursor = el->el_line.buffer;		/* zap! */
    return CC_REFRESH;
d668 1
a668 3
vi_search_prev(el, c)
    EditLine *el;
    int c;
d670 2
a671 1
    return cv_search(el, ED_SEARCH_PREV_HISTORY);
d681 1
a681 3
vi_search_next(el, c)
    EditLine *el;
    int c;
d683 2
a684 1
    return cv_search(el, ED_SEARCH_NEXT_HISTORY);
d694 1
a694 3
vi_repeat_search_next(el, c)
    EditLine *el;
    int c;
d696 5
a700 4
    if (el->el_search.patlen == 0) 
	return CC_ERROR;
    else
	return cv_repeat_srch(el, el->el_search.patdir);
d710 1
a710 3
vi_repeat_search_prev(el, c)
    EditLine *el;
    int c;
d712 7
a718 6
    if (el->el_search.patlen == 0) 
	return CC_ERROR;
    else
	return cv_repeat_srch(el, 
			      el->el_search.patdir == ED_SEARCH_PREV_HISTORY ?
			      ED_SEARCH_NEXT_HISTORY : ED_SEARCH_PREV_HISTORY);
d728 1
a728 3
vi_next_char(el, c)
    EditLine *el;
    int c;
d730 1
a730 10
    char ch;

    if (el_getc(el, &ch) != 1)
	return ed_end_of_file(el, 0);

    el->el_search.chadir = CHAR_FWD;
    el->el_search.chacha = ch;

    return cv_csearch_fwd(el, ch, el->el_state.argument, 0);

d740 1
a740 3
vi_prev_char(el, c)
    EditLine *el;
    int c;
d742 1
a742 9
    char ch;

    if (el_getc(el, &ch) != 1)
	return ed_end_of_file(el, 0);

    el->el_search.chadir = CHAR_BACK;
    el->el_search.chacha = ch;

    return cv_csearch_back(el, ch, el->el_state.argument, 0);
d752 1
a752 3
vi_to_next_char(el, c)
    EditLine *el;
    int c;
d754 1
a754 7
    char ch;

    if (el_getc(el, &ch) != 1)
	return ed_end_of_file(el, 0);

    return cv_csearch_fwd(el, ch, el->el_state.argument, 1);

d764 3
a766 9
vi_to_prev_char(el, c)
    EditLine *el;
    int c;
{
    char ch;
    if (el_getc(el, &ch) != 1)
	return ed_end_of_file(el, 0);

    return cv_csearch_back(el, ch, el->el_state.argument, 1);
d776 1
a776 3
vi_repeat_next_char(el, c)
    EditLine *el;
    int c;
a777 2
    if (el->el_search.chacha == 0)
	return CC_ERROR;
d779 2
a780 3
    return el->el_search.chadir == CHAR_FWD ? 
	cv_csearch_fwd(el, el->el_search.chacha, el->el_state.argument, 0) : 
        cv_csearch_back(el, el->el_search.chacha, el->el_state.argument, 0);
d790 138
a927 3
vi_repeat_prev_char(el, c)
    EditLine *el;
    int c;
d929 20
a948 1
    if (el->el_search.chacha == 0)
d950 177
d1128 3
a1130 3
    return el->el_search.chadir == CHAR_BACK ? 
	cv_csearch_fwd(el, el->el_search.chacha, el->el_state.argument, 0) : 
        cv_csearch_back(el, el->el_search.chacha, el->el_state.argument, 0);
@


1.5
log
@is -Wall clean by making rcsid const
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.4 2002/02/16 21:27:26 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: vi.c,v 1.4 2002/02/16 21:27:26 millert Exp $";
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.3 1997/03/14 05:13:11 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: vi.c,v 1.3 1997/03/14 05:13:11 millert Exp $";
@


1.3
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: vi.c,v 1.2 1997/01/16 05:18:52 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: vi.c,v 1.2 1997/01/16 05:18:52 millert Exp $";
d54 1
a54 1
private el_action_t cv_action __P((EditLine *, int));
@


1.2
log
@Merge in NetBSD libedit changes and new man pages.  Also fix some
strncpy() usage in their code.  NetBSD change log was:
    * add a man page for the editline routines
    * add a man page describing editrc
    * fix bugs in el_parse():
      * didn't execute command when program name matched (test reversed)
      * was checking against empty string instead of program name
      * after checks, command to run also pointed to empty string
    * document ^char and \ escape sequences
    * when parsing ^char control chars, check the correct char when determining
      validity (previously, ^char was a NOP interpreted as the literal string
      because of this bug)
    * Implement CC_REDISPLAY, which (unlike CC_REFRESH) redraws the entire input
    * line (a la ^R). This is useful if the binding outputs information and
    * mucks up the input line. To be used in ``list-choices'' bindings (refer
    * to the ^D binding in csh when filec is set)
@
text
@d1 2
a2 1
/*	$OpenBSD: $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: $";
d121 1
a121 1
    (void) fprintf(el->el_errfile, "Paste: %x \"%s\" +%d -%d\n", 
d134 1
a134 1
    (void) memcpy(ptr, un->buf, un->isize);
d406 1
a406 1
    (void) em_kill_line(el, 0);
d422 1
a422 1
    (void) ed_kill_line(el, 0);
d580 1
a580 1
    (void) fprintf(el->el_errfile, "Undo: %x \"%s\" +%d -%d\n", 
d588 1
a588 1
	(void) memcpy(un->buf, un->ptr, un->dsize);
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
d42 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
