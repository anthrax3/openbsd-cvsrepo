head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.10
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.24
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.20
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.18
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.16
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.18
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2016.04.11.21.17.29;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	I3AtNAFb4FywnTMT;

1.27
date	2016.04.11.20.54.05;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	VmmFUm6qYbPE8jjH;

1.26
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	OUneMOe0l7HombT5;

1.25
date	2016.04.11.19.54.54;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	xizUpRlYj2C4Hcj6;

1.24
date	2016.04.09.19.31.55;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	t22PDRfkb5DJX3rc;

1.23
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	tRHhB2RN3ZD1GvoI;

1.22
date	2016.03.20.22.09.24;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	NaWUbSqizJslSEdn;

1.21
date	2016.01.30.17.32.52;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	wAt9MiELkmlnoi4U;

1.20
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	dCN84ovvbfYwqrqX;

1.19
date	2014.10.17.06.07.50;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	bdUOvGFxUQgqZg7x;

1.18
date	2014.05.19.08.58.34;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.19.11.48.54;	author tobias;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.07.05.40.42;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.23.18.31.25;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.25.20.12.38;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.01.21.11.21;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.05.00.43.20;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.19.19.39.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.06.29.23.40.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.03.14.05.12.51;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.16.05.18.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.02.27.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@delete the "private" and "public" preprocessor macros, just use standard C;
OK martijn@@
@
text
@/*	$OpenBSD: history.c,v 1.27 2016/04/11 20:54:05 schwarze Exp $	*/
/*	$NetBSD: history.c,v 1.37 2010/01/03 18:27:10 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * hist.c: TYPE(History) access functions
 */
#include <sys/stat.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_VIS_H
#include <vis.h>
#else
#include "np/vis.h"
#endif

static const char hist_cookie[] = "_HiStOrY_V2_\n";

#include "histedit.h"


#ifdef NARROWCHAR

#define	Char			char
#define	FUN(prefix, rest)	prefix ## _ ## rest
#define	FUNW(type)		type
#define	TYPE(type)		type
#define	STR(x)			x

#define	Strlen(s)		strlen(s)
#define	Strdup(s)		strdup(s)
#define	Strcmp(d, s)		strcmp(d, s)
#define	Strncmp(d, s, n)	strncmp(d, s, n)
#define	Strncpy(d, s, n)	strncpy(d, s, n)
#define	Strncat(d, s, n)	strncat(d, s, n)
#define	ct_decode_string(s, b)	(s)
#define	ct_encode_string(s, b)	(s)

#else
#include "chartype.h"

#define	Char			wchar_t
#define	FUN(prefix, rest)	prefix ## _w ## rest
#define	FUNW(type)		type ## _w
#define	TYPE(type)		type ## W
#define	STR(x)			L ## x

#define	Strlen(s)		wcslen(s)
#define	Strdup(s)		wcsdup(s)
#define	Strcmp(d, s)		wcscmp(d, s)
#define	Strncmp(d, s, n)	wcsncmp(d, s, n)
#define	Strncpy(d, s, n)	wcsncpy(d, s, n)
#define	Strncat(d, s, n)	wcsncat(d, s, n)

#endif


typedef int (*history_gfun_t)(void *, TYPE(HistEvent) *);
typedef int (*history_efun_t)(void *, TYPE(HistEvent) *, const Char *);
typedef void (*history_vfun_t)(void *, TYPE(HistEvent) *);
typedef int (*history_sfun_t)(void *, TYPE(HistEvent) *, const int);

struct TYPE(history) {
	void *h_ref;		/* Argument for history fcns	 */
	int h_ent;		/* Last entry point for history	 */
	history_gfun_t h_first;	/* Get the first element	 */
	history_gfun_t h_next;	/* Get the next element		 */
	history_gfun_t h_last;	/* Get the last element		 */
	history_gfun_t h_prev;	/* Get the previous element	 */
	history_gfun_t h_curr;	/* Get the current element	 */
	history_sfun_t h_set;	/* Set the current element	 */
	history_sfun_t h_del;	/* Set the given element	 */
	history_vfun_t h_clear;	/* Clear the history list	 */
	history_efun_t h_enter;	/* Add an element		 */
	history_efun_t h_add;	/* Append to an element		 */
};

#define	HNEXT(h, ev)		(*(h)->h_next)((h)->h_ref, ev)
#define	HFIRST(h, ev)		(*(h)->h_first)((h)->h_ref, ev)
#define	HPREV(h, ev)		(*(h)->h_prev)((h)->h_ref, ev)
#define	HLAST(h, ev)		(*(h)->h_last)((h)->h_ref, ev)
#define	HCURR(h, ev)		(*(h)->h_curr)((h)->h_ref, ev)
#define	HSET(h, ev, n)		(*(h)->h_set)((h)->h_ref, ev, n)
#define	HCLEAR(h, ev)		(*(h)->h_clear)((h)->h_ref, ev)
#define	HENTER(h, ev, str)	(*(h)->h_enter)((h)->h_ref, ev, str)
#define	HADD(h, ev, str)	(*(h)->h_add)((h)->h_ref, ev, str)
#define	HDEL(h, ev, n)		(*(h)->h_del)((h)->h_ref, ev, n)

#define	h_strdup(a)	Strdup(a)

typedef struct {
    int		num;
    Char	*str;
} HistEventPrivate;


static int history_setsize(TYPE(History) *, TYPE(HistEvent) *, int);
static int history_getsize(TYPE(History) *, TYPE(HistEvent) *);
static int history_setunique(TYPE(History) *, TYPE(HistEvent) *, int);
static int history_getunique(TYPE(History) *, TYPE(HistEvent) *);
static int history_set_fun(TYPE(History) *, TYPE(History) *);
static int history_load(TYPE(History) *, const char *);
static int history_save(TYPE(History) *, const char *);
static int history_save_fp(TYPE(History) *, FILE *);
static int history_prev_event(TYPE(History) *, TYPE(HistEvent) *, int);
static int history_next_event(TYPE(History) *, TYPE(HistEvent) *, int);
static int history_next_string(TYPE(History) *, TYPE(HistEvent) *,
    const Char *);
static int history_prev_string(TYPE(History) *, TYPE(HistEvent) *,
    const Char *);


/***********************************************************************/

/*
 * Builtin- history implementation
 */
typedef struct hentry_t {
	TYPE(HistEvent) ev;		/* What we return		 */
	void *data;		/* data				 */
	struct hentry_t *next;	/* Next entry			 */
	struct hentry_t *prev;	/* Previous entry		 */
} hentry_t;

typedef struct history_t {
	hentry_t list;		/* Fake list header element	*/
	hentry_t *cursor;	/* Current element in the list	*/
	int max;		/* Maximum number of events	*/
	int cur;		/* Current number of events	*/
	int eventid;		/* For generation of unique event id	 */
	int flags;		/* TYPE(History) flags		*/
#define H_UNIQUE	1	/* Store only unique elements	*/
} history_t;

static int history_def_next(void *, TYPE(HistEvent) *);
static int history_def_first(void *, TYPE(HistEvent) *);
static int history_def_prev(void *, TYPE(HistEvent) *);
static int history_def_last(void *, TYPE(HistEvent) *);
static int history_def_curr(void *, TYPE(HistEvent) *);
static int history_def_set(void *, TYPE(HistEvent) *, const int);
static void history_def_clear(void *, TYPE(HistEvent) *);
static int history_def_enter(void *, TYPE(HistEvent) *, const Char *);
static int history_def_add(void *, TYPE(HistEvent) *, const Char *);
static int history_def_del(void *, TYPE(HistEvent) *, const int);

static int history_def_init(void **, TYPE(HistEvent) *, int);
static int history_def_insert(history_t *, TYPE(HistEvent) *, const Char *);
static void history_def_delete(history_t *, TYPE(HistEvent) *, hentry_t *);

static int history_deldata_nth(history_t *, TYPE(HistEvent) *, int, void **);
static int history_set_nth(void *, TYPE(HistEvent) *, int);

#define	history_def_setsize(p, num)(void) (((history_t *)p)->max = (num))
#define	history_def_getsize(p)  (((history_t *)p)->cur)
#define	history_def_getunique(p) (((((history_t *)p)->flags) & H_UNIQUE) != 0)
#define	history_def_setunique(p, uni) \
    if (uni) \
	(((history_t *)p)->flags) |= H_UNIQUE; \
    else \
	(((history_t *)p)->flags) &= ~H_UNIQUE

#define	he_strerror(code)	he_errlist[code]
#define	he_seterrev(evp, code)	{\
				    evp->num = code;\
				    evp->str = he_strerror(code);\
				}

/* error messages */
static const Char *const he_errlist[] = {
	STR("OK"),
	STR("unknown error"),
	STR("malloc() failed"),
	STR("first event not found"),
	STR("last event not found"),
	STR("empty list"),
	STR("no next event"),
	STR("no previous event"),
	STR("current event is invalid"),
	STR("event not found"),
	STR("can't read history from file"),
	STR("can't write history"),
	STR("required parameter(s) not supplied"),
	STR("history size negative"),
	STR("function not allowed with other history-functions-set the default"),
	STR("bad parameters")
};
/* error codes */
#define	_HE_OK                   0
#define	_HE_UNKNOWN		 1
#define	_HE_MALLOC_FAILED        2
#define	_HE_FIRST_NOTFOUND       3
#define	_HE_LAST_NOTFOUND        4
#define	_HE_EMPTY_LIST           5
#define	_HE_END_REACHED          6
#define	_HE_START_REACHED	 7
#define	_HE_CURR_INVALID	 8
#define	_HE_NOT_FOUND		 9
#define	_HE_HIST_READ		10
#define	_HE_HIST_WRITE		11
#define	_HE_PARAM_MISSING	12
#define	_HE_SIZE_NEGATIVE	13
#define	_HE_NOT_ALLOWED		14
#define	_HE_BAD_PARAM		15

/* history_def_first():
 *	Default function to return the first event in the history.
 */
static int
history_def_first(void *p, TYPE(HistEvent) *ev)
{
	history_t *h = (history_t *) p;

	h->cursor = h->list.next;
	if (h->cursor != &h->list)
		*ev = h->cursor->ev;
	else {
		he_seterrev(ev, _HE_FIRST_NOTFOUND);
		return -1;
	}

	return 0;
}


/* history_def_last():
 *	Default function to return the last event in the history.
 */
static int
history_def_last(void *p, TYPE(HistEvent) *ev)
{
	history_t *h = (history_t *) p;

	h->cursor = h->list.prev;
	if (h->cursor != &h->list)
		*ev = h->cursor->ev;
	else {
		he_seterrev(ev, _HE_LAST_NOTFOUND);
		return -1;
	}

	return 0;
}


/* history_def_next():
 *	Default function to return the next event in the history.
 */
static int
history_def_next(void *p, TYPE(HistEvent) *ev)
{
	history_t *h = (history_t *) p;

	if (h->cursor == &h->list) {
		he_seterrev(ev, _HE_EMPTY_LIST);
		return -1;
	}

	if (h->cursor->next == &h->list) {
		he_seterrev(ev, _HE_END_REACHED);
		return -1;
	}

        h->cursor = h->cursor->next;
        *ev = h->cursor->ev;

	return 0;
}


/* history_def_prev():
 *	Default function to return the previous event in the history.
 */
static int
history_def_prev(void *p, TYPE(HistEvent) *ev)
{
	history_t *h = (history_t *) p;

	if (h->cursor == &h->list) {
		he_seterrev(ev,
		    (h->cur > 0) ? _HE_END_REACHED : _HE_EMPTY_LIST);
		return -1;
	}

	if (h->cursor->prev == &h->list) {
		he_seterrev(ev, _HE_START_REACHED);
		return -1;
	}

        h->cursor = h->cursor->prev;
        *ev = h->cursor->ev;

	return 0;
}


/* history_def_curr():
 *	Default function to return the current event in the history.
 */
static int
history_def_curr(void *p, TYPE(HistEvent) *ev)
{
	history_t *h = (history_t *) p;

	if (h->cursor != &h->list)
		*ev = h->cursor->ev;
	else {
		he_seterrev(ev,
		    (h->cur > 0) ? _HE_CURR_INVALID : _HE_EMPTY_LIST);
		return -1;
	}

	return 0;
}


/* history_def_set():
 *	Default function to set the current event in the history to the
 *	given one.
 */
static int
history_def_set(void *p, TYPE(HistEvent) *ev, const int n)
{
	history_t *h = (history_t *) p;

	if (h->cur == 0) {
		he_seterrev(ev, _HE_EMPTY_LIST);
		return -1;
	}
	if (h->cursor == &h->list || h->cursor->ev.num != n) {
		for (h->cursor = h->list.next; h->cursor != &h->list;
		    h->cursor = h->cursor->next)
			if (h->cursor->ev.num == n)
				break;
	}
	if (h->cursor == &h->list) {
		he_seterrev(ev, _HE_NOT_FOUND);
		return -1;
	}
	return 0;
}


/* history_set_nth():
 *	Default function to set the current event in the history to the
 *	n-th one.
 */
static int
history_set_nth(void *p, TYPE(HistEvent) *ev, int n)
{
	history_t *h = (history_t *) p;

	if (h->cur == 0) {
		he_seterrev(ev, _HE_EMPTY_LIST);
		return -1;
	}
	for (h->cursor = h->list.prev; h->cursor != &h->list;
	    h->cursor = h->cursor->prev)
		if (n-- <= 0)
			break;
	if (h->cursor == &h->list) {
		he_seterrev(ev, _HE_NOT_FOUND);
		return -1;
	}
	return 0;
}


/* history_def_add():
 *	Append string to element
 */
static int
history_def_add(void *p, TYPE(HistEvent) *ev, const Char *str)
{
	history_t *h = (history_t *) p;
	size_t len;
	Char *s;
	HistEventPrivate *evp = (void *)&h->cursor->ev;

	if (h->cursor == &h->list)
		return history_def_enter(p, ev, str);
	len = Strlen(evp->str) + Strlen(str) + 1;
	s = reallocarray(NULL, len, sizeof(*s));
	if (s == NULL) {
		he_seterrev(ev, _HE_MALLOC_FAILED);
		return -1;
	}
	(void) Strncpy(s, h->cursor->ev.str, len);
        s[len - 1] = '\0';
	(void) Strncat(s, str, len - Strlen(s) - 1);
	free(evp->str);
	evp->str = s;
	*ev = h->cursor->ev;
	return 0;
}


static int
history_deldata_nth(history_t *h, TYPE(HistEvent) *ev,
    int num, void **data)
{
	if (history_set_nth(h, ev, num) != 0)
		return -1;
	/* magic value to skip delete (just set to n-th history) */
	if (data == (void **)-1)
		return 0;
	ev->str = Strdup(h->cursor->ev.str);
	ev->num = h->cursor->ev.num;
	if (data)
		*data = h->cursor->data;
	history_def_delete(h, ev, h->cursor);
	return 0;
}


/* history_def_del():
 *	Delete element hp of the h list
 */
/* ARGSUSED */
static int
history_def_del(void *p, TYPE(HistEvent) *ev __attribute__((__unused__)),
    const int num)
{
	history_t *h = (history_t *) p;
	if (history_def_set(h, ev, num) != 0)
		return -1;
	ev->str = Strdup(h->cursor->ev.str);
	ev->num = h->cursor->ev.num;
	history_def_delete(h, ev, h->cursor);
	return 0;
}


/* history_def_delete():
 *	Delete element hp of the h list
 */
/* ARGSUSED */
static void
history_def_delete(history_t *h,
		   TYPE(HistEvent) *ev __attribute__((__unused__)), hentry_t *hp)
{
	HistEventPrivate *evp = (void *)&hp->ev;
	if (hp == &h->list)
		abort();
	if (h->cursor == hp) {
		h->cursor = hp->prev;
		if (h->cursor == &h->list)
			h->cursor = hp->next;
	}
	hp->prev->next = hp->next;
	hp->next->prev = hp->prev;
	free(evp->str);
	free(hp);
	h->cur--;
}


/* history_def_insert():
 *	Insert element with string str in the h list
 */
static int
history_def_insert(history_t *h, TYPE(HistEvent) *ev, const Char *str)
{

	h->cursor = (hentry_t *) malloc(sizeof(hentry_t));
	if (h->cursor == NULL)
		goto oomem;
	if ((h->cursor->ev.str = h_strdup(str)) == NULL) {
		free(h->cursor);
		goto oomem;
	}
	h->cursor->data = NULL;
	h->cursor->ev.num = ++h->eventid;
	h->cursor->next = h->list.next;
	h->cursor->prev = &h->list;
	h->list.next->prev = h->cursor;
	h->list.next = h->cursor;
	h->cur++;

	*ev = h->cursor->ev;
	return 0;
oomem:
	he_seterrev(ev, _HE_MALLOC_FAILED);
	return -1;
}


/* history_def_enter():
 *	Default function to enter an item in the history
 */
static int
history_def_enter(void *p, TYPE(HistEvent) *ev, const Char *str)
{
	history_t *h = (history_t *) p;

	if ((h->flags & H_UNIQUE) != 0 && h->list.next != &h->list &&
	    Strcmp(h->list.next->ev.str, str) == 0)
	    return 0;

	if (history_def_insert(h, ev, str) == -1)
		return -1;	/* error, keep error message */

	/*
         * Always keep at least one entry.
         * This way we don't have to check for the empty list.
         */
	while (h->cur > h->max && h->cur > 0)
		history_def_delete(h, ev, h->list.prev);

	return 1;
}


/* history_def_init():
 *	Default history initialization function
 */
/* ARGSUSED */
static int
history_def_init(void **p, TYPE(HistEvent) *ev __attribute__((__unused__)), int n)
{
	history_t *h = (history_t *) malloc(sizeof(history_t));
	if (h == NULL)
		return -1;

	if (n <= 0)
		n = 0;
	h->eventid = 0;
	h->cur = 0;
	h->max = n;
	h->list.next = h->list.prev = &h->list;
	h->list.ev.str = NULL;
	h->list.ev.num = 0;
	h->cursor = &h->list;
	h->flags = 0;
	*p = h;
	return 0;
}


/* history_def_clear():
 *	Default history cleanup function
 */
static void
history_def_clear(void *p, TYPE(HistEvent) *ev)
{
	history_t *h = (history_t *) p;

	while (h->list.prev != &h->list)
		history_def_delete(h, ev, h->list.prev);
	h->eventid = 0;
	h->cur = 0;
}




/************************************************************************/

/* history_init():
 *	Initialization function.
 */
TYPE(History) *
FUN(history,init)(void)
{
	TYPE(HistEvent) ev;
	TYPE(History) *h = (TYPE(History) *) malloc(sizeof(TYPE(History)));
	if (h == NULL)
		return NULL;

	if (history_def_init(&h->h_ref, &ev, 0) == -1) {
		free(h);
		return NULL;
	}
	h->h_ent = -1;
	h->h_next = history_def_next;
	h->h_first = history_def_first;
	h->h_last = history_def_last;
	h->h_prev = history_def_prev;
	h->h_curr = history_def_curr;
	h->h_set = history_def_set;
	h->h_clear = history_def_clear;
	h->h_enter = history_def_enter;
	h->h_add = history_def_add;
	h->h_del = history_def_del;

	return h;
}


/* history_end():
 *	clean up history;
 */
void
FUN(history,end)(TYPE(History) *h)
{
	TYPE(HistEvent) ev;

	if (h->h_next == history_def_next)
		history_def_clear(h->h_ref, &ev);
	free(h->h_ref);
	free(h);
}



/* history_setsize():
 *	Set history number of events
 */
static int
history_setsize(TYPE(History) *h, TYPE(HistEvent) *ev, int num)
{

	if (h->h_next != history_def_next) {
		he_seterrev(ev, _HE_NOT_ALLOWED);
		return -1;
	}
	if (num < 0) {
		he_seterrev(ev, _HE_BAD_PARAM);
		return -1;
	}
	history_def_setsize(h->h_ref, num);
	return 0;
}


/* history_getsize():
 *      Get number of events currently in history
 */
static int
history_getsize(TYPE(History) *h, TYPE(HistEvent) *ev)
{
	if (h->h_next != history_def_next) {
		he_seterrev(ev, _HE_NOT_ALLOWED);
		return -1;
	}
	ev->num = history_def_getsize(h->h_ref);
	if (ev->num < -1) {
		he_seterrev(ev, _HE_SIZE_NEGATIVE);
		return -1;
	}
	return 0;
}


/* history_setunique():
 *	Set if adjacent equal events should not be entered in history.
 */
static int
history_setunique(TYPE(History) *h, TYPE(HistEvent) *ev, int uni)
{

	if (h->h_next != history_def_next) {
		he_seterrev(ev, _HE_NOT_ALLOWED);
		return -1;
	}
	history_def_setunique(h->h_ref, uni);
	return 0;
}


/* history_getunique():
 *	Get if adjacent equal events should not be entered in history.
 */
static int
history_getunique(TYPE(History) *h, TYPE(HistEvent) *ev)
{
	if (h->h_next != history_def_next) {
		he_seterrev(ev, _HE_NOT_ALLOWED);
		return -1;
	}
	ev->num = history_def_getunique(h->h_ref);
	return 0;
}


/* history_set_fun():
 *	Set history functions
 */
static int
history_set_fun(TYPE(History) *h, TYPE(History) *nh)
{
	TYPE(HistEvent) ev;

	if (nh->h_first == NULL || nh->h_next == NULL || nh->h_last == NULL ||
	    nh->h_prev == NULL || nh->h_curr == NULL || nh->h_set == NULL ||
	    nh->h_enter == NULL || nh->h_add == NULL || nh->h_clear == NULL ||
	    nh->h_del == NULL || nh->h_ref == NULL) {
		if (h->h_next != history_def_next) {
			history_def_init(&h->h_ref, &ev, 0);
			h->h_first = history_def_first;
			h->h_next = history_def_next;
			h->h_last = history_def_last;
			h->h_prev = history_def_prev;
			h->h_curr = history_def_curr;
			h->h_set = history_def_set;
			h->h_clear = history_def_clear;
			h->h_enter = history_def_enter;
			h->h_add = history_def_add;
			h->h_del = history_def_del;
		}
		return -1;
	}
	if (h->h_next == history_def_next)
		history_def_clear(h->h_ref, &ev);

	h->h_ent = -1;
	h->h_first = nh->h_first;
	h->h_next = nh->h_next;
	h->h_last = nh->h_last;
	h->h_prev = nh->h_prev;
	h->h_curr = nh->h_curr;
	h->h_set = nh->h_set;
	h->h_clear = nh->h_clear;
	h->h_enter = nh->h_enter;
	h->h_add = nh->h_add;
	h->h_del = nh->h_del;

	return 0;
}


/* history_load():
 *	TYPE(History) load function
 */
static int
history_load(TYPE(History) *h, const char *fname)
{
	FILE *fp;
	char *line;
	size_t llen;
	ssize_t sz;
	size_t max_size;
	char *ptr;
	int i = -1;
	TYPE(HistEvent) ev;
#ifndef NARROWCHAR
	static ct_buffer_t conv;
#endif

	if ((fp = fopen(fname, "r")) == NULL)
		return i;

	line = NULL;
	llen = 0;
	if ((sz = getline(&line, &llen, fp)) == -1)
		goto done;

	if (strncmp(line, hist_cookie, sz) != 0)
		goto done;

	ptr = malloc(max_size = 1024);
	if (ptr == NULL)
		goto done;
	for (i = 0; (sz = getline(&line, &llen, fp)) != -1; i++) {
		if (sz > 0 && line[sz - 1] == '\n')
			line[--sz] = '\0';
		if (max_size < sz) {
			char *nptr;
			max_size = (sz + 1024) & ~1023;
			nptr = realloc(ptr, max_size);
			if (nptr == NULL) {
				i = -1;
				goto oomem;
			}
			ptr = nptr;
		}
		(void) strunvis(ptr, line);
		if (HENTER(h, &ev, ct_decode_string(ptr, &conv)) == -1) {
			i = -1;
			goto oomem;
		}
	}
oomem:
	free(ptr);
done:
	free(line);
	(void) fclose(fp);
	return i;
}


/* history_save_fp():
 *	TYPE(History) save function
 */
static int
history_save_fp(TYPE(History) *h, FILE *fp)
{
	TYPE(HistEvent) ev;
	int i = -1, retval;
	size_t len, max_size;
	char *ptr;
#ifndef NARROWCHAR
	static ct_buffer_t conv;
#endif

	if (fchmod(fileno(fp), S_IRUSR|S_IWUSR) == -1)
		goto done;
	if (fputs(hist_cookie, fp) == EOF)
		goto done;
	ptr = malloc(max_size = 1024);
	if (ptr == NULL)
		goto done;
	for (i = 0, retval = HLAST(h, &ev);
	    retval != -1;
	    retval = HPREV(h, &ev), i++) {
		len = Strlen(ev.str) * 4 + 1;
		if (len > max_size) {
			char *nptr;
			max_size = (len + 1024) & ~1023;
			nptr = realloc(ptr, max_size);
			if (nptr == NULL) {
				i = -1;
				goto oomem;
			}
			ptr = nptr;
		}
		(void) strnvis(ptr, ct_encode_string(ev.str, &conv), max_size,
		    VIS_WHITE);
		(void) fprintf(fp, "%s\n", ptr);
	}
oomem:
	free(ptr);
done:
	return i;
}


/* history_save():
 *    History save function
 */
static int
history_save(TYPE(History) *h, const char *fname)
{
	FILE *fp;
	int i;

	if ((fp = fopen(fname, "w")) == NULL)
		return -1;

	i = history_save_fp(h, fp);

	(void) fclose(fp);
	return i;
}


/* history_prev_event():
 *	Find the previous event, with number given
 */
static int
history_prev_event(TYPE(History) *h, TYPE(HistEvent) *ev, int num)
{
	int retval;

	for (retval = HCURR(h, ev); retval != -1; retval = HPREV(h, ev))
		if (ev->num == num)
			return 0;

	he_seterrev(ev, _HE_NOT_FOUND);
	return -1;
}


static int
history_next_evdata(TYPE(History) *h, TYPE(HistEvent) *ev, int num, void **d)
{
	int retval;

	for (retval = HCURR(h, ev); retval != -1; retval = HPREV(h, ev))
		if (ev->num == num) {
			if (d)
				*d = ((history_t *)h->h_ref)->cursor->data;
			return 0;
		}

	he_seterrev(ev, _HE_NOT_FOUND);
	return -1;
}


/* history_next_event():
 *	Find the next event, with number given
 */
static int
history_next_event(TYPE(History) *h, TYPE(HistEvent) *ev, int num)
{
	int retval;

	for (retval = HCURR(h, ev); retval != -1; retval = HNEXT(h, ev))
		if (ev->num == num)
			return 0;

	he_seterrev(ev, _HE_NOT_FOUND);
	return -1;
}


/* history_prev_string():
 *	Find the previous event beginning with string
 */
static int
history_prev_string(TYPE(History) *h, TYPE(HistEvent) *ev, const Char *str)
{
	size_t len = Strlen(str);
	int retval;

	for (retval = HCURR(h, ev); retval != -1; retval = HNEXT(h, ev))
		if (Strncmp(str, ev->str, len) == 0)
			return 0;

	he_seterrev(ev, _HE_NOT_FOUND);
	return -1;
}


/* history_next_string():
 *	Find the next event beginning with string
 */
static int
history_next_string(TYPE(History) *h, TYPE(HistEvent) *ev, const Char *str)
{
	size_t len = Strlen(str);
	int retval;

	for (retval = HCURR(h, ev); retval != -1; retval = HPREV(h, ev))
		if (Strncmp(str, ev->str, len) == 0)
			return 0;

	he_seterrev(ev, _HE_NOT_FOUND);
	return -1;
}


/* history():
 *	User interface to history functions.
 */
int
FUNW(history)(TYPE(History) *h, TYPE(HistEvent) *ev, int fun, ...)
{
	va_list va;
	const Char *str;
	int retval;

	va_start(va, fun);

	he_seterrev(ev, _HE_OK);

	switch (fun) {
	case H_GETSIZE:
		retval = history_getsize(h, ev);
		break;

	case H_SETSIZE:
		retval = history_setsize(h, ev, va_arg(va, int));
		break;

	case H_GETUNIQUE:
		retval = history_getunique(h, ev);
		break;

	case H_SETUNIQUE:
		retval = history_setunique(h, ev, va_arg(va, int));
		break;

	case H_ADD:
		str = va_arg(va, const Char *);
		retval = HADD(h, ev, str);
		break;

	case H_DEL:
		retval = HDEL(h, ev, va_arg(va, const int));
		break;

	case H_ENTER:
		str = va_arg(va, const Char *);
		if ((retval = HENTER(h, ev, str)) != -1)
			h->h_ent = ev->num;
		break;

	case H_APPEND:
		str = va_arg(va, const Char *);
		if ((retval = HSET(h, ev, h->h_ent)) != -1)
			retval = HADD(h, ev, str);
		break;

	case H_FIRST:
		retval = HFIRST(h, ev);
		break;

	case H_NEXT:
		retval = HNEXT(h, ev);
		break;

	case H_LAST:
		retval = HLAST(h, ev);
		break;

	case H_PREV:
		retval = HPREV(h, ev);
		break;

	case H_CURR:
		retval = HCURR(h, ev);
		break;

	case H_SET:
		retval = HSET(h, ev, va_arg(va, const int));
		break;

	case H_CLEAR:
		HCLEAR(h, ev);
		retval = 0;
		break;

	case H_LOAD:
		retval = history_load(h, va_arg(va, const char *));
		if (retval == -1)
			he_seterrev(ev, _HE_HIST_READ);
		break;

	case H_SAVE:
		retval = history_save(h, va_arg(va, const char *));
		if (retval == -1)
			he_seterrev(ev, _HE_HIST_WRITE);
		break;

	case H_SAVE_FP:
		retval = history_save_fp(h, va_arg(va, FILE *));
		if (retval == -1)
		    he_seterrev(ev, _HE_HIST_WRITE);
		break;

	case H_PREV_EVENT:
		retval = history_prev_event(h, ev, va_arg(va, int));
		break;

	case H_NEXT_EVENT:
		retval = history_next_event(h, ev, va_arg(va, int));
		break;

	case H_PREV_STR:
		retval = history_prev_string(h, ev, va_arg(va, const Char *));
		break;

	case H_NEXT_STR:
		retval = history_next_string(h, ev, va_arg(va, const Char *));
		break;

	case H_FUNC:
	{
		TYPE(History) hf;

		hf.h_ref = va_arg(va, void *);
		h->h_ent = -1;
		hf.h_first = va_arg(va, history_gfun_t);
		hf.h_next = va_arg(va, history_gfun_t);
		hf.h_last = va_arg(va, history_gfun_t);
		hf.h_prev = va_arg(va, history_gfun_t);
		hf.h_curr = va_arg(va, history_gfun_t);
		hf.h_set = va_arg(va, history_sfun_t);
		hf.h_clear = va_arg(va, history_vfun_t);
		hf.h_enter = va_arg(va, history_efun_t);
		hf.h_add = va_arg(va, history_efun_t);
		hf.h_del = va_arg(va, history_sfun_t);

		if ((retval = history_set_fun(h, &hf)) == -1)
			he_seterrev(ev, _HE_PARAM_MISSING);
		break;
	}

	case H_END:
		FUN(history,end)(h);
		retval = 0;
		break;

	case H_NEXT_EVDATA:
	{
		int num = va_arg(va, int);
		void **d = va_arg(va, void **);
		retval = history_next_evdata(h, ev, num, d);
		break;
	}

	case H_DELDATA:
	{
		int num = va_arg(va, int);
		void **d = va_arg(va, void **);
		retval = history_deldata_nth((history_t *)h->h_ref, ev, num, d);
		break;
	}

	case H_REPLACE: /* only use after H_NEXT_EVDATA */
	{
		const Char *line = va_arg(va, const Char *);
		void *d = va_arg(va, void *);
		const Char *s;
		if(!line || !(s = Strdup(line))) {
			retval = -1;
			break;
		}
		((history_t *)h->h_ref)->cursor->ev.str = s;
		((history_t *)h->h_ref)->cursor->data = d;
		retval = 0;
		break;
	}

	default:
		retval = -1;
		he_seterrev(ev, _HE_UNKNOWN);
		break;
	}
	va_end(va);
	return retval;
}
@


1.27
log
@Clean up chartype.h:

* not used in tokenizer.c
* only use it for !NARROWCHAR
* no need for underscores before ct_{de,en}code_string()
* make the conversion buffer resize function private

OK martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.26 2016/04/11 20:43:33 schwarze Exp $	*/
d131 14
a144 13

private int history_setsize(TYPE(History) *, TYPE(HistEvent) *, int);
private int history_getsize(TYPE(History) *, TYPE(HistEvent) *);
private int history_setunique(TYPE(History) *, TYPE(HistEvent) *, int);
private int history_getunique(TYPE(History) *, TYPE(HistEvent) *);
private int history_set_fun(TYPE(History) *, TYPE(History) *);
private int history_load(TYPE(History) *, const char *);
private int history_save(TYPE(History) *, const char *);
private int history_save_fp(TYPE(History) *, FILE *);
private int history_prev_event(TYPE(History) *, TYPE(HistEvent) *, int);
private int history_next_event(TYPE(History) *, TYPE(HistEvent) *, int);
private int history_next_string(TYPE(History) *, TYPE(HistEvent) *, const Char *);
private int history_prev_string(TYPE(History) *, TYPE(HistEvent) *, const Char *);
d169 14
a182 14
private int history_def_next(void *, TYPE(HistEvent) *);
private int history_def_first(void *, TYPE(HistEvent) *);
private int history_def_prev(void *, TYPE(HistEvent) *);
private int history_def_last(void *, TYPE(HistEvent) *);
private int history_def_curr(void *, TYPE(HistEvent) *);
private int history_def_set(void *, TYPE(HistEvent) *, const int);
private void history_def_clear(void *, TYPE(HistEvent) *);
private int history_def_enter(void *, TYPE(HistEvent) *, const Char *);
private int history_def_add(void *, TYPE(HistEvent) *, const Char *);
private int history_def_del(void *, TYPE(HistEvent) *, const int);

private int history_def_init(void **, TYPE(HistEvent) *, int);
private int history_def_insert(history_t *, TYPE(HistEvent) *, const Char *);
private void history_def_delete(history_t *, TYPE(HistEvent) *, hentry_t *);
d184 2
a185 2
private int history_deldata_nth(history_t *, TYPE(HistEvent) *, int, void **);
private int history_set_nth(void *, TYPE(HistEvent) *, int);
d242 1
a242 1
private int
d262 1
a262 1
private int
d282 1
a282 1
private int
d307 1
a307 1
private int
d333 1
a333 1
private int
d354 1
a354 1
private int
d381 1
a381 1
private int
d405 1
a405 1
private int
d431 1
a431 1
private int
d453 1
a453 1
private int
d471 1
a471 1
private void
d494 1
a494 1
private int
d524 1
a524 1
private int
d551 1
a551 1
private int
d576 1
a576 1
private void
d595 1
a595 1
public TYPE(History) *
d626 1
a626 1
public void
d642 1
a642 1
private int
d662 1
a662 1
private int
d681 1
a681 1
private int
d697 1
a697 1
private int
d712 1
a712 1
private int
d758 1
a758 1
private int
d818 1
a818 1
private int
d864 1
a864 1
private int
d883 1
a883 1
private int
d897 1
a897 1
private int
d917 1
a917 1
private int
d934 1
a934 1
private int
d952 1
a952 1
private int
@


1.26
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.25 2016/04/11 19:54:54 schwarze Exp $	*/
a53 1
#include "chartype.h"
d70 2
d74 1
@


1.25
log
@Move wrapper macros to the two files actually needing them:
FUNW, Strlen, Strdup, Strcmp, Strncmp, Strncpy, Strncat -> history.c
Strchr, tok_strdup -> tokenizer.c
FUN, TYPE, STR -> both of these files

OK martijn@@

Also proofread by Christian Heckendorf <mbie at ulmus dot me>
who reported some whitespace issues in parse.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.24 2016/04/09 19:31:55 schwarze Exp $	*/
d59 1
d74 1
@


1.24
log
@Always compile with WIDECHAR on and delete that preprocessor switch.
OK martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.23 2016/03/20 23:48:27 schwarze Exp $	*/
d55 32
@


1.23
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.22 2016/03/20 22:09:24 schwarze Exp $	*/
d732 1
a732 1
#ifdef WIDECHAR
d788 1
a788 1
#ifdef WIDECHAR
@


1.22
log
@Use getline(3) rather than fgetln(3) because it is standardized
and simpler and safer to use.  Implemented by Christos Zoulas
following my suggestion, with a bug fix by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.21 2016/01/30 17:32:52 schwarze Exp $	*/
d41 3
a44 2
#include <stdlib.h>
#include <stdarg.h>
a49 1
#include <sys/stat.h>
d435 1
a435 1
history_def_delete(history_t *h, 
@


1.21
log
@Fifth step in synching with NetBSD:
Delete the silly ptr_t and ioctl_t typedefs
and delete some "#ifdef notdef" code from "sys.h".
No functional change.
This makes hist.h identical to the NetBSD version.
It reduces the remaining diff from +1526 -734 to +1430 -592.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.20 2016/01/30 12:22:20 schwarze Exp $	*/
d725 4
a728 2
	char *line, *lbuf;
	size_t sz, max_size;
a735 1
	lbuf = NULL;
d739 3
a741 1
	if ((line = fgetln(fp, &sz)) == NULL)
d750 4
a753 14
	for (i = 0; (line = fgetln(fp, &sz)) != NULL; i++) {
		if (line[sz - 1] == '\n')
			line[sz - 1] = '\0';
		else {
			lbuf = malloc(sz + 1);
			if (lbuf == NULL) {
				i = -1;
				goto oomem;
			}
			memcpy(lbuf, line, sz);
			lbuf[sz++] = '\0';
			line = lbuf;
		}
		if (sz > max_size) {
d772 1
a772 1
	free(lbuf);
@


1.20
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.19 2014/10/17 06:07:50 deraadt Exp $	*/
d56 4
a59 4
typedef int (*history_gfun_t)(ptr_t, TYPE(HistEvent) *);
typedef int (*history_efun_t)(ptr_t, TYPE(HistEvent) *, const Char *);
typedef void (*history_vfun_t)(ptr_t, TYPE(HistEvent) *);
typedef int (*history_sfun_t)(ptr_t, TYPE(HistEvent) *, const int);
d62 1
a62 1
	ptr_t h_ref;		/* Argument for history fcns	 */
d132 10
a141 10
private int history_def_next(ptr_t, TYPE(HistEvent) *);
private int history_def_first(ptr_t, TYPE(HistEvent) *);
private int history_def_prev(ptr_t, TYPE(HistEvent) *);
private int history_def_last(ptr_t, TYPE(HistEvent) *);
private int history_def_curr(ptr_t, TYPE(HistEvent) *);
private int history_def_set(ptr_t, TYPE(HistEvent) *, const int);
private void history_def_clear(ptr_t, TYPE(HistEvent) *);
private int history_def_enter(ptr_t, TYPE(HistEvent) *, const Char *);
private int history_def_add(ptr_t, TYPE(HistEvent) *, const Char *);
private int history_def_del(ptr_t, TYPE(HistEvent) *, const int);
d143 1
a143 1
private int history_def_init(ptr_t *, TYPE(HistEvent) *, int);
d148 1
a148 1
private int history_set_nth(ptr_t, TYPE(HistEvent) *, int);
d206 1
a206 1
history_def_first(ptr_t p, TYPE(HistEvent) *ev)
d226 1
a226 1
history_def_last(ptr_t p, TYPE(HistEvent) *ev)
d246 1
a246 1
history_def_next(ptr_t p, TYPE(HistEvent) *ev)
d271 1
a271 1
history_def_prev(ptr_t p, TYPE(HistEvent) *ev)
d297 1
a297 1
history_def_curr(ptr_t p, TYPE(HistEvent) *ev)
d318 1
a318 1
history_def_set(ptr_t p, TYPE(HistEvent) *ev, const int n)
d345 1
a345 1
history_set_nth(ptr_t p, TYPE(HistEvent) *ev, int n)
d369 1
a369 1
history_def_add(ptr_t p, TYPE(HistEvent) *ev, const Char *str)
d387 1
a387 1
	free((ptr_t)evp->str);
d417 1
a417 1
history_def_del(ptr_t p, TYPE(HistEvent) *ev __attribute__((__unused__)),
d448 1
a448 1
	free((ptr_t) evp->str);
d465 1
a465 1
		free((ptr_t)h->cursor);
d488 1
a488 1
history_def_enter(ptr_t p, TYPE(HistEvent) *ev, const Char *str)
d515 1
a515 1
history_def_init(ptr_t *p, TYPE(HistEvent) *ev __attribute__((__unused__)), int n)
d531 1
a531 1
	*p = (ptr_t) h;
d540 1
a540 1
history_def_clear(ptr_t p, TYPE(HistEvent) *ev)
d567 1
a567 1
		free((ptr_t)h);
d777 1
a777 1
	free((ptr_t)ptr);
d825 1
a825 1
	free((ptr_t)ptr);
d1056 1
a1056 1
		hf.h_ref = va_arg(va, ptr_t);
@


1.19
log
@Remove non-exposed malloc/realloc/free wrappers, and then substitute
reallocarray() where it helps.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.18 2014/05/19 08:58:34 nicm Exp $	*/
d215 1
a215 1
		return (-1);
d218 1
a218 1
	return (0);
d235 1
a235 1
		return (-1);
d238 1
a238 1
	return (0);
d252 1
a252 1
		return (-1);
d257 1
a257 1
		return (-1);
d263 1
a263 1
	return (0);
d278 1
a278 1
		return (-1);
d283 1
a283 1
		return (-1);
d289 1
a289 1
	return (0);
d306 1
a306 1
		return (-1);
d309 1
a309 1
	return (0);
d324 1
a324 1
		return (-1);
d334 1
a334 1
		return (-1);
d336 1
a336 1
	return (0);
d351 1
a351 1
		return (-1);
d359 1
a359 1
		return (-1);
d361 1
a361 1
	return (0);
d377 1
a377 1
		return (history_def_enter(p, ev, str));
d382 1
a382 1
		return (-1);
d390 1
a390 1
	return (0);
d399 1
a399 1
		return (-1);
d402 1
a402 1
		return (0);
d408 1
a408 1
	return (0);
d422 1
a422 1
		return (-1);
d426 1
a426 1
	return (0);
d477 1
a477 1
	return (0);
d480 1
a480 1
	return (-1);
d494 1
a494 1
	    return (0); 
d497 1
a497 1
		return (-1);	/* error, keep error message */
d506 1
a506 1
	return (1);
d582 1
a582 1
	return (h);
d611 1
a611 1
		return (-1);
d615 1
a615 1
		return (-1);
d618 1
a618 1
	return (0);
d630 1
a630 1
		return (-1);
d635 1
a635 1
		return (-1);
d637 1
a637 1
	return (0);
d650 1
a650 1
		return (-1);
d653 1
a653 1
	return (0);
d665 1
a665 1
		return (-1);
d668 1
a668 1
	return (0);
d697 1
a697 1
		return (-1);
d714 1
a714 1
	return (0);
d736 1
a736 1
		return (i);
d781 1
a781 1
	return (i);
d827 1
a827 1
	return (i);
d860 1
a860 1
			return (0);
d863 1
a863 1
	return (-1);
d876 1
a876 1
			return (0);
d880 1
a880 1
	return (-1);
d894 1
a894 1
			return (0);
d897 1
a897 1
	return (-1);
d912 1
a912 1
			return (0);
d915 1
a915 1
	return (-1);
d930 1
a930 1
			return (0);
d933 1
a933 1
	return (-1);
@


1.18
log
@Add a H_SAVE_FP operation to history() which lets the history be saved
to an open file pointer. From NetBSD via Eitan Adler.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.17 2014/01/19 11:48:54 tobias Exp $	*/
a87 3
#define	h_malloc(a)	malloc(a)
#define	h_realloc(a, b)	realloc((a), (b))
#define	h_free(a)	free(a)
d379 1
a379 1
	s = h_malloc(len * sizeof(*s));
d387 1
a387 1
	h_free((ptr_t)evp->str);
d448 2
a449 2
	h_free((ptr_t) evp->str);
	h_free(hp);
d461 1
a461 1
	h->cursor = (hentry_t *) h_malloc(sizeof(hentry_t));
d465 1
a465 1
		h_free((ptr_t)h->cursor);
d517 1
a517 1
	history_t *h = (history_t *) h_malloc(sizeof(history_t));
d562 1
a562 1
	TYPE(History) *h = (TYPE(History) *) h_malloc(sizeof(TYPE(History)));
d567 1
a567 1
		h_free((ptr_t)h);
d596 2
a597 2
	h_free(h->h_ref);
	h_free(h);
d744 1
a744 1
	ptr = h_malloc(max_size = 1024);
d763 1
a763 1
			nptr = h_realloc(ptr, max_size);
d777 1
a777 1
	h_free((ptr_t)ptr);
d779 1
a779 1
	h_free(lbuf);
d803 1
a803 1
	ptr = h_malloc(max_size = 1024);
d813 1
a813 1
			nptr = h_realloc(ptr, max_size);
d825 1
a825 1
	h_free((ptr_t)ptr);
@


1.17
log
@Retain local changes from rev 1.13.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.16 2011/07/07 05:40:42 okan Exp $	*/
d106 1
d788 1
a788 1
/* history_save():
d792 1
a792 1
history_save(TYPE(History) *h, const char *fname)
a793 1
	FILE *fp;
a801 3
	if ((fp = fopen(fname, "w")) == NULL)
		return (-1);

d830 18
d849 1
a849 1
	return (i);
d1031 6
@


1.16
log
@sync with upstream, retaining local modifications.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.15 2010/06/30 00:05:35 nicm Exp $	*/
d727 1
a727 1
	char *line;
d736 1
d750 13
a762 8
		char c = line[sz];

		if (sz != 0 && line[sz - 1] == '\n')
			line[--sz] = '\0';
		else
			line[sz] = '\0';

		if (max_size < sz) {
a772 1
		line[sz] = c;
d781 1
d815 2
a816 2
		len = Strlen(ev.str) * 4;
		if (len >= max_size) {
@


1.15
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d727 1
a727 1
	char *line, *lbuf;
a735 1
	lbuf = NULL;
d749 8
a756 13
		if (line[sz - 1] == '\n')
			line[sz - 1] = '\0';
		else {
			lbuf = malloc(sz + 1);
			if (lbuf == NULL) {
				i = -1;
				goto oomem;
			}
			memcpy(lbuf, line, sz);
			lbuf[sz++] = '\0';
			line = lbuf;
		}
		if (sz > max_size) {
d767 1
a775 1
	h_free(lbuf);
d809 2
a810 2
		len = Strlen(ev.str) * 4 + 1;
		if (len > max_size) {
d855 1
a855 1
		if (num-- <= 0) {
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
a2 2
/*	$OpenBSD: history.c,v 1.13 2004/08/23 18:31:25 otto Exp $	*/
/*	$NetBSD: history.c,v 1.25 2003/10/18 23:48:42 christos Exp $	*/
d39 1
a39 1
 * hist.c: History access functions
d54 1
d56 4
a59 4
typedef int (*history_gfun_t)(ptr_t, HistEvent *);
typedef int (*history_efun_t)(ptr_t, HistEvent *, const char *);
typedef void (*history_vfun_t)(ptr_t, HistEvent *);
typedef int (*history_sfun_t)(ptr_t, HistEvent *, const int);
d61 1
a61 1
struct history {
d70 1
d85 1
d87 1
a87 1
#define	h_strdup(a)	strdup(a)
d94 1
a94 1
    char	*str;
d99 11
a109 11
private int history_setsize(History *, HistEvent *, int);
private int history_getsize(History *, HistEvent *);
private int history_setunique(History *, HistEvent *, int);
private int history_getunique(History *, HistEvent *);
private int history_set_fun(History *, History *);
private int history_load(History *, const char *);
private int history_save(History *, const char *);
private int history_prev_event(History *, HistEvent *, int);
private int history_next_event(History *, HistEvent *, int);
private int history_next_string(History *, HistEvent *, const char *);
private int history_prev_string(History *, HistEvent *, const char *);
d118 2
a119 1
	HistEvent ev;		/* What we return		 */
d130 1
a130 1
	int flags;		/* History flags		*/
d134 17
a150 12
private int history_def_first(ptr_t, HistEvent *);
private int history_def_last(ptr_t, HistEvent *);
private int history_def_next(ptr_t, HistEvent *);
private int history_def_prev(ptr_t, HistEvent *);
private int history_def_curr(ptr_t, HistEvent *);
private int history_def_set(ptr_t, HistEvent *, const int n);
private int history_def_enter(ptr_t, HistEvent *, const char *);
private int history_def_add(ptr_t, HistEvent *, const char *);
private int history_def_init(ptr_t *, HistEvent *, int);
private void history_def_clear(ptr_t, HistEvent *);
private int history_def_insert(history_t *, HistEvent *, const char *);
private void history_def_delete(history_t *, HistEvent *, hentry_t *);
d168 17
a184 17
static const char *const he_errlist[] = {
	"OK",
	"unknown error",
	"malloc() failed",
	"first event not found",
	"last event not found",
	"empty list",
	"no next event",
	"no previous event",
	"current event is invalid",
	"event not found",
	"can't read history from file",
	"can't write history",
	"required parameter(s) not supplied",
	"history size negative",
	"function not allowed with other history-functions-set the default",
	"bad parameters"
d208 1
a208 1
history_def_first(ptr_t p, HistEvent *ev)
d228 1
a228 1
history_def_last(ptr_t p, HistEvent *ev)
d248 1
a248 1
history_def_next(ptr_t p, HistEvent *ev)
d252 1
a252 3
	if (h->cursor != &h->list)
		h->cursor = h->cursor->next;
	else {
d257 1
a257 3
	if (h->cursor != &h->list)
		*ev = h->cursor->ev;
	else {
d262 3
d273 1
a273 1
history_def_prev(ptr_t p, HistEvent *ev)
d277 1
a277 3
	if (h->cursor != &h->list)
		h->cursor = h->cursor->prev;
	else {
d283 1
a283 3
	if (h->cursor != &h->list)
		*ev = h->cursor->ev;
	else {
d288 3
d299 1
a299 1
history_def_curr(ptr_t p, HistEvent *ev)
d320 1
a320 1
history_def_set(ptr_t p, HistEvent *ev, const int n)
d342 25
d371 1
a371 1
history_def_add(ptr_t p, HistEvent *ev, const char *str)
d375 1
a375 1
	char *s;
d380 2
a381 2
	len = strlen(evp->str) + strlen(str) + 1;
	s = (char *) h_malloc(len);
d386 3
a388 2
	(void) strlcpy(s, h->cursor->ev.str, len);
	(void) strlcat(s, str, len);
d396 36
d438 1
a438 1
		   HistEvent *ev __attribute__((__unused__)), hentry_t *hp)
d443 5
d460 1
a460 1
history_def_insert(history_t *h, HistEvent *ev, const char *str)
d470 1
d490 1
a490 1
history_def_enter(ptr_t p, HistEvent *ev, const char *str)
d495 1
a495 1
	    strcmp(h->list.next->ev.str, str) == 0)
d517 1
a517 1
history_def_init(ptr_t *p, HistEvent *ev __attribute__((__unused__)), int n)
d542 1
a542 1
history_def_clear(ptr_t p, HistEvent *ev)
d560 2
a561 2
public History *
history_init(void)
d563 2
a564 2
	HistEvent ev;
	History *h = (History *) h_malloc(sizeof(History));
d582 1
d592 1
a592 1
history_end(History *h)
d594 1
a594 1
	HistEvent ev;
d598 2
d608 1
a608 1
history_setsize(History *h, HistEvent *ev, int num)
d628 1
a628 1
history_getsize(History *h, HistEvent *ev)
d647 1
a647 1
history_setunique(History *h, HistEvent *ev, int uni)
d663 1
a663 1
history_getunique(History *h, HistEvent *ev)
d678 1
a678 1
history_set_fun(History *h, History *nh)
d680 1
a680 1
	HistEvent ev;
d685 1
a685 1
	    nh->h_ref == NULL) {
d697 1
d714 1
d721 1
a721 1
 *	History load function
d724 1
a724 1
history_load(History *h, const char *fname)
d731 4
a734 1
	HistEvent ev;
d764 1
a764 1
			max_size = (sz + 1023) & ~1023;
d773 3
a775 3
		if (HENTER(h, &ev, ptr) == -1) {
			h_free((ptr_t)ptr);
			return -1;
d788 1
a788 1
 *	History save function
d791 1
a791 1
history_save(History *h, const char *fname)
d794 1
a794 1
	HistEvent ev;
d798 3
d815 1
a815 1
		len = strlen(ev.str) * 4 + 1;
d818 1
a818 1
			max_size = (len + 1023) & ~1023;
d826 2
a827 1
		(void) strnvis(ptr, ev.str, max_size, VIS_WHITE);
d842 1
a842 1
history_prev_event(History *h, HistEvent *ev, int num)
d855 17
d876 1
a876 1
history_next_event(History *h, HistEvent *ev, int num)
d893 1
a893 1
history_prev_string(History *h, HistEvent *ev, const char *str)
d895 1
a895 1
	size_t len = strlen(str);
d899 1
a899 1
		if (strncmp(str, ev->str, len) == 0)
d911 1
a911 1
history_next_string(History *h, HistEvent *ev, const char *str)
d913 1
a913 1
	size_t len = strlen(str);
d917 1
a917 1
		if (strncmp(str, ev->str, len) == 0)
d929 1
a929 1
history(History *h, HistEvent *ev, int fun, ...)
d932 1
a932 1
	const char *str;
d957 1
a957 1
		str = va_arg(va, const char *);
d961 4
d966 1
a966 1
		str = va_arg(va, const char *);
d972 1
a972 1
		str = va_arg(va, const char *);
d1027 1
a1027 1
		retval = history_prev_string(h, ev, va_arg(va, const char *));
d1031 1
a1031 1
		retval = history_next_string(h, ev, va_arg(va, const char *));
d1036 1
a1036 1
		History hf;
d1049 1
d1057 31
a1087 1
		history_end(h);
d1090 1
d1098 1
a1098 1
	return (retval);
@


1.13
log
@Fix fgetln handling and always increment the size if we need to realloc,
Based on a diff by kjell@@; latter hunk from a diff by Sergey S.  Kostyliov.
ok kjell@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.12 2003/11/25 20:12:38 otto Exp $	*/
a36 7
#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)history.c	8.1 (Berkeley) 6/4/93";
#else
static const char rcsid[] = "$OpenBSD: history.c,v 1.12 2003/11/25 20:12:38 otto Exp $";
#endif
#endif /* not lint && not SCCSID */
@


1.12
log
@Sync libedit to NetBSD libedit as of Nov 8, 2003.
Tested by jmc@@ djm@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.11 2003/10/31 08:42:24 otto Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: history.c,v 1.11 2003/10/31 08:42:24 otto Exp $";
d654 1
a654 1
	char *line;
d660 1
d674 13
a686 8
		char c = line[sz];

		if (sz != 0 && line[sz - 1] == '\n')
			line[--sz] = '\0';
		else
			line[sz] = '\0';

		if (max_size < sz) {
a696 1
		line[sz] = c;
d705 1
d736 2
a737 2
		len = strlen(ev.str) * 4;
		if (len >= max_size) {
d739 1
a739 1
			max_size = (len + 1023) & 1023;
d747 1
a747 1
		(void) strvis(ptr, ev.str, VIS_WHITE);
@


1.11
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: history.c,v 1.24 2003/08/07 16:44:31 agc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD$";
d91 1
d399 1
a399 1
	if ((h->cursor->ev.str = strdup(str)) == NULL) {
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: history.c,v 1.9 2003/05/01 21:11:21 avsm Exp $	*/
/*	$NetBSD: history.c,v 1.5 1997/04/11 17:52:46 christos Exp $	*/
d36 1
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: history.c,v 1.9 2003/05/01 21:11:21 avsm Exp $";
a47 2
#include "sys.h"

d51 6
d58 1
a58 1
static const char hist_cookie[] = "_HiStOrY_V1_\n";
d62 4
a65 3
typedef const HistEvent *	(*history_gfun_t)(ptr_t);
typedef const HistEvent *	(*history_efun_t)(ptr_t, const char *);
typedef void 			(*history_vfun_t)(ptr_t);
d68 11
a78 9
    ptr_t	   h_ref;		/* Argument for history fcns	*/
    history_gfun_t h_first;		/* Get the first element	*/
    history_gfun_t h_next;		/* Get the next element		*/
    history_gfun_t h_last;		/* Get the last element		*/
    history_gfun_t h_prev;		/* Get the previous element	*/
    history_gfun_t h_curr;		/* Get the current element	*/
    history_vfun_t h_clear;		/* Clear the history list	*/ 
    history_efun_t h_enter;		/* Add an element		*/
    history_efun_t h_add;		/* Append to an element		*/
d81 32
a112 21
#define	HNEXT(h)  	(*(h)->h_next)((h)->h_ref)
#define	HFIRST(h) 	(*(h)->h_first)((h)->h_ref)
#define	HPREV(h)  	(*(h)->h_prev)((h)->h_ref)
#define	HLAST(h) 	(*(h)->h_last)((h)->h_ref)
#define	HCURR(h) 	(*(h)->h_curr)((h)->h_ref)
#define	HCLEAR(h) 	(*(h)->h_clear)((h)->h_ref)
#define	HENTER(h, str)	(*(h)->h_enter)((h)->h_ref, str)
#define	HADD(h, str)	(*(h)->h_add)((h)->h_ref, str)

#define h_malloc(a)	malloc(a)
#define h_free(a)	free(a)


private int		 history_set_num(History *, int);
private int		 history_set_fun(History *, History *);
private int 		 history_load(History *, const char *);
private int 		 history_save(History *, const char *);
private const HistEvent *history_prev_event(History *, int);
private const HistEvent *history_next_event(History *, int);
private const HistEvent *history_next_string(History *, const char *);
private const HistEvent *history_prev_string(History *, const char *);
d121 3
a123 3
    HistEvent ev;		/* What we return		*/
    struct hentry_t *next;	/* Next entry			*/
    struct hentry_t *prev;	/* Previous entry		*/
d127 7
a133 5
    hentry_t  list;		/* Fake list header element	*/
    hentry_t *cursor;		/* Current element in the list	*/
    int	max;			/* Maximum number of events	*/
    int cur;			/* Current number of events	*/
    int	eventno;		/* Current event number		*/
d136 64
a199 14
private const HistEvent *history_def_first(ptr_t);
private const HistEvent *history_def_last(ptr_t);
private const HistEvent *history_def_next(ptr_t);
private const HistEvent *history_def_prev(ptr_t);
private const HistEvent *history_def_curr(ptr_t);
private const HistEvent *history_def_enter(ptr_t, const char *);
private const HistEvent *history_def_add(ptr_t, const char *);
private void             history_def_init(ptr_t *, int);
private void             history_def_clear(ptr_t);
private const HistEvent *history_def_insert(history_t *, const char *);
private void             history_def_delete(history_t *, hentry_t *);

#define history_def_set(p, num)	(void)(((history_t *) p)->max = (num))

d204 14
a217 10
private const HistEvent * 
history_def_first(p)
    ptr_t p;
{
    history_t *h = (history_t *) p;
    h->cursor = h->list.next;
    if (h->cursor != &h->list)
	return &h->cursor->ev;
    else
	return NULL;
d220 1
d224 14
a237 10
private const HistEvent * 
history_def_last(p)
    ptr_t p;
{
    history_t *h = (history_t *) p;
    h->cursor = h->list.prev;
    if (h->cursor != &h->list)
	return &h->cursor->ev;
    else
	return NULL;
d240 1
d244 20
a263 15
private const HistEvent * 
history_def_next(p)
    ptr_t p;
{
    history_t *h = (history_t *) p;

    if (h->cursor != &h->list)
	h->cursor = h->cursor->next;
    else
	return NULL;

    if (h->cursor != &h->list)
	return &h->cursor->ev;
    else
	return NULL;
d270 21
a290 15
private const HistEvent * 
history_def_prev(p)
    ptr_t p;
{
    history_t *h = (history_t *) p;

    if (h->cursor != &h->list)
	h->cursor = h->cursor->prev;
    else
	return NULL;

    if (h->cursor != &h->list)
	return &h->cursor->ev;
    else
	return NULL;
d297 14
a310 10
private const HistEvent * 
history_def_curr(p)
    ptr_t p;
{
    history_t *h = (history_t *) p;

    if (h->cursor != &h->list)
	return &h->cursor->ev;
    else
	return NULL;
d313 28
d344 22
a365 18
private const HistEvent *
history_def_add(p, str)
    ptr_t p;
    const char *str;
{
    history_t *h = (history_t *) p;
    size_t len;
    char *s;

    if (h->cursor == &h->list)
	return (history_def_enter(p, str));
    len = strlen(h->cursor->ev.str) + strlen(str) + 1;
    s = (char *) h_malloc(len);
    (void)strlcpy(s, h->cursor->ev.str, len);
    (void)strlcat(s, str, len);
    h_free((ptr_t) h->cursor->ev.str);
    h->cursor->ev.str = s;
    return &h->cursor->ev;
d372 1
d374 11
a384 11
history_def_delete(h, hp)
    history_t *h;
    hentry_t *hp;
{
    if (hp == &h->list)
	abort();
    hp->prev->next = hp->next;
    hp->next->prev = hp->prev;
    h_free((ptr_t) hp->ev.str);
    h_free(hp);
    h->cur--;
d391 3
a393 12
private const HistEvent *
history_def_insert(h, str)
    history_t *h;
    const char *str;
{
    h->cursor = (hentry_t *) h_malloc(sizeof(hentry_t));
    h->cursor->ev.str = strdup(str);
    h->cursor->next = h->list.next;
    h->cursor->prev = &h->list;
    h->list.next->prev = h->cursor;
    h->list.next = h->cursor;
    h->cur++;
d395 19
a413 1
    return &h->cursor->ev;
d420 20
a439 19
private const HistEvent *
history_def_enter(p, str)
    ptr_t p;
    const char *str;
{
    history_t *h = (history_t *) p;
    const HistEvent *ev;


    ev = history_def_insert(h, str);
    ((HistEvent*) ev)->num = ++h->eventno;

    /*
     * Always keep at least one entry.
     * This way we don't have to check for the empty list.
     */
    while (h->cur > h->max + 1) 
	history_def_delete(h, h->list.prev);
    return ev;
d446 20
a465 16
private void
history_def_init(p, n)
    ptr_t *p;
    int n;
{
    history_t *h = (history_t *) h_malloc(sizeof(history_t));
    if (n <= 0)
	n = 0;
    h->eventno = 0;
    h->cur = 0;
    h->max = n;
    h->list.next = h->list.prev = &h->list;
    h->list.ev.str = NULL;
    h->list.ev.num = 0;
    h->cursor = &h->list;
    *p = (ptr_t) h;
d473 1
a473 2
history_def_clear(p)
    ptr_t p;
d475 1
a475 1
    history_t *h = (history_t *) p;
d477 4
a480 4
    while (h->list.prev != &h->list)
	history_def_delete(h, h->list.prev);
    h->eventno = 0;
    h->cur = 0;
d492 1
a492 1
history_init()
d494 19
a512 12
    History *h = (History *) h_malloc(sizeof(History));

    history_def_init(&h->h_ref, 0);

    h->h_next  = history_def_next;
    h->h_first = history_def_first;
    h->h_last  = history_def_last;
    h->h_prev  = history_def_prev;
    h->h_curr  = history_def_curr;
    h->h_clear = history_def_clear;
    h->h_enter = history_def_enter;
    h->h_add   = history_def_add;
d514 1
a514 1
    return h;
d522 1
a522 2
history_end(h)
    History *h;
d524 4
a527 2
    if (h->h_next == history_def_next)
	history_def_clear(h->h_ref);
d532 1
a532 1
/* history_set_num():
d536 63
a598 8
history_set_num(h, num)
    History *h;
    int num;
{
    if (h->h_next != history_def_next || num < 0)
	return -1;
    history_def_set(h->h_ref, num);
    return 0;
d606 1
a606 2
history_set_fun(h, nh)
    History *h, *nh;
d608 33
a640 29
    if (nh->h_first == NULL || nh->h_next == NULL ||
        nh->h_last == NULL  || nh->h_prev == NULL || nh->h_curr == NULL ||
	nh->h_enter == NULL || nh->h_add == NULL || nh->h_clear == NULL ||
	nh->h_ref == NULL) {
	if (h->h_next != history_def_next) {
	    history_def_init(&h->h_ref, 0);
	    h->h_first = history_def_first;
	    h->h_next  = history_def_next;
	    h->h_last  = history_def_last;
	    h->h_prev  = history_def_prev;
	    h->h_curr  = history_def_curr;
	    h->h_clear = history_def_clear;
	    h->h_enter = history_def_enter;
	    h->h_add   = history_def_add;
	}
	return -1;
    }

    if (h->h_next == history_def_next)
	history_def_clear(h->h_ref);

    h->h_first = nh->h_first;
    h->h_next  = nh->h_next;
    h->h_last  = nh->h_last;
    h->h_prev  = nh->h_prev;
    h->h_curr  = nh->h_curr;
    h->h_clear = nh->h_clear;
    h->h_enter = nh->h_enter;
    h->h_add   = nh->h_add;
d642 1
a642 1
    return 0;
d650 48
a697 25
history_load(h, fname)
    History *h;
    const char *fname;
{
    FILE *fp;
    char *line;
    size_t sz;
    int i = -1;

    if ((fp = fopen(fname, "r")) == NULL)
	return i;

    if ((line = fgetln(fp, &sz)) == NULL)
	goto done;

    if (strncmp(line, hist_cookie, sz) != 0)
	goto done;
	
    for (i = 0; (line = fgetln(fp, &sz)) != NULL; i++) {
	char c = line[sz];
	line[sz] = '\0';
	HENTER(h, line);
	line[sz] = c;
    }

d699 2
a700 2
    (void)fclose(fp);
    return i;
d708 40
a747 16
history_save(h, fname)
    History *h;
    const char *fname;
{
    FILE *fp;
    const HistEvent *ev;
    int i = 0;

    if ((fp = fopen(fname, "w")) == NULL)
	return -1;

    (void)fputs(hist_cookie, fp);
    for (ev = HLAST(h); ev != NULL; ev = HPREV(h), i++)
	(void)fprintf(fp, "%s", ev->str);
    (void)fclose(fp);
    return i;
d754 11
a764 10
private const HistEvent *
history_prev_event(h, num)
    History *h;
    int num;
{
    const HistEvent *ev;
    for (ev = HCURR(h); ev != NULL; ev = HPREV(h))
	if (ev->num == num)
	    return ev;
    return NULL;
d771 11
a781 10
private const HistEvent *
history_next_event(h, num)
    History *h;
    int num;
{
    const HistEvent *ev;
    for (ev = HCURR(h); ev != NULL; ev = HNEXT(h))
	if (ev->num == num)
	    return ev;
    return NULL;
d788 5
a792 13
private const HistEvent *
history_prev_string(h, str)
    History *h;
    const char* str;
{
    const HistEvent *ev;
    size_t len = strlen(str);

    for (ev = HCURR(h); ev != NULL; ev = HNEXT(h))
	if (strncmp(str, ev->str, len) == 0)
	    return ev;
    return NULL;
}
d794 3
d798 3
d806 12
a817 12
private const HistEvent *
history_next_string(h, str)
    History *h;
    const char* str;
{
    const HistEvent *ev;
    size_t len = strlen(str);

    for (ev = HCURR(h); ev != NULL; ev = HPREV(h))
	if (strncmp(str, ev->str, len) == 0)
	    return ev;
    return NULL;
d824 2
a825 2
const HistEvent *
history(History *h, int fun, ...)
d827 118
a944 72
    va_list va;
    const HistEvent *ev = NULL;
    const char *str;
    static HistEvent sev = { 0, "" };

    va_start(va, fun);

    switch (fun) {
    case H_ADD:
	str = va_arg(va, const char *);
	ev = HADD(h, str);
	break;

    case H_ENTER:
	str = va_arg(va, const char *);
	ev = HENTER(h, str);
	break;

    case H_FIRST:
	ev = HFIRST(h);
	break;

    case H_NEXT:
	ev = HNEXT(h);
	break;

    case H_LAST:
	ev = HLAST(h);
	break;

    case H_PREV:
	ev = HPREV(h);
	break;

    case H_CURR:
	ev = HCURR(h);
	break;

    case H_CLEAR:
	HCLEAR(h);
	break;

    case H_LOAD:
	sev.num = history_load(h, va_arg(va, const char *));
	ev = &sev;
	break;

    case H_SAVE:
	sev.num = history_save(h, va_arg(va, const char *));
	ev = &sev;
	break;

    case H_PREV_EVENT:
	ev = history_prev_event(h, va_arg(va, int));
	break;

    case H_NEXT_EVENT:
	ev = history_next_event(h, va_arg(va, int));
	break;

    case H_PREV_STR:
	ev = history_prev_string(h, va_arg(va, const char*));
	break;

    case H_NEXT_STR:
	ev = history_next_string(h, va_arg(va, const char*));
	break;

    case H_EVENT:
	if (history_set_num(h, va_arg(va, int)) == 0) {
	    sev.num = -1;
	    ev = &sev;
a945 1
	break;
d947 12
a958 29
    case H_FUNC:
	{
	    History hf;
	    hf.h_ref   = va_arg(va, ptr_t);
	    hf.h_first = va_arg(va, history_gfun_t);
	    hf.h_next  = va_arg(va, history_gfun_t);
	    hf.h_last  = va_arg(va, history_gfun_t);
	    hf.h_prev  = va_arg(va, history_gfun_t);
	    hf.h_curr  = va_arg(va, history_gfun_t);
	    hf.h_clear = va_arg(va, history_vfun_t);
	    hf.h_enter = va_arg(va, history_efun_t);
	    hf.h_add   = va_arg(va, history_efun_t);

	    if (history_set_fun(h, &hf) == 0) {
		sev.num = -1;
		ev = &sev;
	    }
	}
	break;

    case H_END:
	history_end(h);
	break;

    default:
	break;
    }
    va_end(va);
    return ev;
@


1.9
log
@is -Wall clean by making rcsid const
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.8 2003/04/05 00:43:20 tdeval Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: history.c,v 1.8 2003/04/05 00:43:20 tdeval Exp $";
@


1.8
log
@strcpy/strcat -> strlcpy/strlcat
ok tedu@@, hints by deraadt@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.7 2002/02/19 19:39:37 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: history.c,v 1.7 2002/02/19 19:39:37 millert Exp $";
@


1.7
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.6 2002/02/16 21:27:26 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: history.c,v 1.6 2002/02/16 21:27:26 millert Exp $";
d237 2
a238 2
    (void)strcpy(s, h->cursor->ev.str);
    (void)strcat(s, str);
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.5 1997/06/29 23:40:49 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: history.c,v 1.5 1997/06/29 23:40:49 millert Exp $";
a54 1
#ifdef __STDC__
a55 3
#else
#include <varargs.h>
#endif
a573 1
#ifdef __STDC__
a574 4
#else
history(va_alist)
    va_dcl
#endif
a580 1
#ifdef __STDC__
a581 7
#else
    History *h; 
    int fun;
    va_start(va);
    h = va_arg(va, History *);
    fun = va_arg(va, int);
#endif
@


1.5
log
@Updates from NetBSD (christos@@netbsd.org)
  * Portability fixes:
	__const         -> const
	BADSIG          -> SIG_ERR
	int flags       -> u_int flags
	#if __STDC__    -> #ifdef __STDC__
  * Don't allow CSWTCH to interfere with CSUSP on __SVR4 systems.
  * Return -1 if the terminal set operation resulted in dumb terminal settings.
  * Handle properly the case where the last line in the sourced file does
    not have a trailing '\n'. From Jeffrey C Honig.
  * editrc -> editline in editline(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: history.c,v 1.4 1997/03/14 05:12:51 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: history.c,v 1.4 1997/03/14 05:12:51 millert Exp $";
d65 3
a67 3
typedef const HistEvent *	(*history_gfun_t) __P((ptr_t));
typedef const HistEvent *	(*history_efun_t) __P((ptr_t, const char *));
typedef void 			(*history_vfun_t) __P((ptr_t));
d94 8
a101 8
private int		 history_set_num	__P((History *, int));
private int		 history_set_fun	__P((History *, History *));
private int 		 history_load		__P((History *, const char *));
private int 		 history_save		__P((History *, const char *));
private const HistEvent *history_prev_event	__P((History *, int));
private const HistEvent *history_next_event	__P((History *, int));
private const HistEvent *history_next_string	__P((History *, const char *));
private const HistEvent *history_prev_string	__P((History *, const char *));
d123 11
a133 11
private const HistEvent *history_def_first  __P((ptr_t));
private const HistEvent *history_def_last   __P((ptr_t));
private const HistEvent *history_def_next   __P((ptr_t));
private const HistEvent *history_def_prev   __P((ptr_t));
private const HistEvent *history_def_curr   __P((ptr_t));
private const HistEvent *history_def_enter  __P((ptr_t, const char *));
private const HistEvent *history_def_add    __P((ptr_t, const char *));
private void             history_def_init   __P((ptr_t *, int));
private void             history_def_clear  __P((ptr_t));
private const HistEvent *history_def_insert __P((history_t *, const char *));
private void             history_def_delete __P((history_t *, hentry_t *));
@


1.4
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 2
a2 2
/*	$OpenBSD: history.c,v 1.3 1997/01/16 05:18:35 millert Exp $	*/
/*	$NetBSD: history.c,v 1.4 1997/01/23 14:02:45 mrg Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: history.c,v 1.3 1997/01/16 05:18:35 millert Exp $";
d55 1
a55 1
#if __STDC__
d578 1
a578 1
#if __STDC__
d590 1
a590 1
#if __STDC__
@


1.3
log
@Merge in NetBSD libedit changes and new man pages.  Also fix some
strncpy() usage in their code.  NetBSD change log was:
    * add a man page for the editline routines
    * add a man page describing editrc
    * fix bugs in el_parse():
      * didn't execute command when program name matched (test reversed)
      * was checking against empty string instead of program name
      * after checks, command to run also pointed to empty string
    * document ^char and \ escape sequences
    * when parsing ^char control chars, check the correct char when determining
      validity (previously, ^char was a NOP interpreted as the literal string
      because of this bug)
    * Implement CC_REDISPLAY, which (unlike CC_REFRESH) redraws the entire input
    * line (a la ^R). This is useful if the binding outputs information and
    * mucks up the input line. To be used in ``list-choices'' bindings (refer
    * to the ^D binding in csh when filec is set)
@
text
@d1 2
a2 1
/*	$OpenBSD: $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: $";
d135 1
a135 1
#define history_def_set(p, num)	(void) (((history_t *) p)->max = (num))
d241 2
a242 2
    (void) strcpy(s, h->cursor->ev.str);
    (void) strcat(s, str);
d476 1
a476 1
    (void) fclose(fp);
d496 1
a496 1
    (void) fputs(hist_cookie, fp);
d498 2
a499 2
	(void) fprintf(fp, "%s", ev->str);
    (void) fclose(fp);
@


1.2
log
@update from netbsd
@
text
@d1 2
d40 1
d42 3
@


1.1
log
@Initial revision
@
text
@d54 2
d60 1
d69 1
d79 1
d88 3
a90 7
private int		 history_set_fun	__P((History *, history_gfun_t,
						     history_gfun_t,
						     history_gfun_t,
						     history_gfun_t,
						     history_gfun_t,
						     history_efun_t,
						     history_efun_t, ptr_t));
d124 1
a124 1
private void             history_def_end    __P((ptr_t));
a217 1

d327 1
a327 1
/* history_def_end():
d331 1
a331 1
history_def_end(p)
d338 2
d342 3
d362 1
d378 1
a378 1
	history_def_end(h->h_ref);
d402 7
a408 10
history_set_fun(h, first, next, last, prev, curr, enter, add, ptr)
    History *h;
    history_gfun_t first, next, last, prev, curr;
    history_efun_t enter, add;
    ptr_t ptr;
{
    if (first == NULL || next == NULL || 
        last == NULL  || prev == NULL || curr == NULL ||
	enter == NULL || add == NULL || 
	ptr == NULL ) {
d416 1
d424 10
a433 1
	history_def_end(h->h_ref);
a434 4
    h->h_next  = next;
    h->h_first = first;
    h->h_enter = enter;
    h->h_add   = add;
d439 58
d547 2
d581 1
a581 1
    static const HistEvent sev = { 0, "" };
d624 14
d655 2
a656 1
	if (history_set_num(h, va_arg(va, int)) == 0)
d658 1
d663 10
a672 8
	    history_gfun_t	first = va_arg(va, history_gfun_t);
	    history_gfun_t	next  = va_arg(va, history_gfun_t);
	    history_gfun_t	last  = va_arg(va, history_gfun_t);
	    history_gfun_t	prev  = va_arg(va, history_gfun_t);
	    history_gfun_t	curr  = va_arg(va, history_gfun_t);
	    history_efun_t	enter = va_arg(va, history_efun_t);
	    history_efun_t	add   = va_arg(va, history_efun_t);
	    ptr_t		ptr   = va_arg(va, ptr_t);
d674 2
a675 2
	    if (history_set_fun(h, first, next, last, prev, 
				   curr, enter, add, ptr) == 0)
d677 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
