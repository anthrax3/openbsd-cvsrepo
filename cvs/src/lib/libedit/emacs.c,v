head	1.17;
access;
symbols
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.6
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.24
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.16
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.20
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.18
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.14
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.12
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.10
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.8
	OPENBSD_5_0:1.9.0.6
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.4
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.2
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.26
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.22
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.3.0.26
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.24
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.22
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.05.06.13.12.52;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	HmIy04UbyUS0d1Sd;

1.16
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	OUneMOe0l7HombT5;

1.15
date	2016.04.09.20.15.26;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	0bnhGLXZIvXlnMLp;

1.14
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	tRHhB2RN3ZD1GvoI;

1.13
date	2016.03.20.22.57.59;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	VBVmrUoZFnMc0hts;

1.12
date	2016.03.20.20.35.38;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	b06qlwkNEbVitvG0;

1.11
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	dCN84ovvbfYwqrqX;

1.10
date	2016.01.30.00.06.39;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	tGf8IdK8wCurneJ7;

1.9
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.25.20.12.38;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.21.11.21;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	97.03.14.05.12.47;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.16.05.18.32;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.40;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Replace the generated file "fcns.c" by a simpler header "func.h"
included only in the one file needing it, "map.c".
That allows to define el_action_t directly in "map.h",
which in turn allows to stop including "fcns.h" from "el.h"
and include it only in the modules needing it.
Now we no longer autogenerate any C files.

Feedback and OK martijn@@.
First version also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@/*	$OpenBSD: emacs.c,v 1.16 2016/04/11 20:43:33 schwarze Exp $	*/
/*	$NetBSD: emacs.c,v 1.35 2016/04/18 17:01:19 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * emacs.c: Emacs functions
 */
#include <ctype.h>

#include "el.h"
#include "emacs.h"
#include "fcns.h"

/* em_delete_or_list():
 *	Delete character under cursor or list completions if at end of line
 *	[^D]
 */
protected el_action_t
/*ARGSUSED*/
em_delete_or_list(EditLine *el, wint_t c)
{

	if (el->el_line.cursor == el->el_line.lastchar) {
					/* if I'm at the end */
		if (el->el_line.cursor == el->el_line.buffer) {
					/* and the beginning */
			terminal_writec(el, c);	/* then do an EOF */
			return CC_EOF;
		} else {
			/*
			 * Here we could list completions, but it is an
			 * error right now
			 */
			terminal_beep(el);
			return CC_ERROR;
		}
	} else {
		if (el->el_state.doingarg)
			c_delafter(el, el->el_state.argument);
		else
			c_delafter1(el);
		if (el->el_line.cursor > el->el_line.lastchar)
			el->el_line.cursor = el->el_line.lastchar;
				/* bounds check */
		return CC_REFRESH;
	}
}


/* em_delete_next_word():
 *	Cut from cursor to end of current word
 *	[M-d]
 */
protected el_action_t
/*ARGSUSED*/
em_delete_next_word(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *cp, *p, *kp;

	if (el->el_line.cursor == el->el_line.lastchar)
		return CC_ERROR;

	cp = c__next_word(el->el_line.cursor, el->el_line.lastchar,
	    el->el_state.argument, ce__isword);

	for (p = el->el_line.cursor, kp = el->el_chared.c_kill.buf; p < cp; p++)
				/* save the text */
		*kp++ = *p;
	el->el_chared.c_kill.last = kp;

	c_delafter(el, (int)(cp - el->el_line.cursor));	/* delete after dot */
	if (el->el_line.cursor > el->el_line.lastchar)
		el->el_line.cursor = el->el_line.lastchar;
				/* bounds check */
	return CC_REFRESH;
}


/* em_yank():
 *	Paste cut buffer at cursor position
 *	[^Y]
 */
protected el_action_t
/*ARGSUSED*/
em_yank(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *kp, *cp;

	if (el->el_chared.c_kill.last == el->el_chared.c_kill.buf)
		return CC_NORM;

	if (el->el_line.lastchar +
	    (el->el_chared.c_kill.last - el->el_chared.c_kill.buf) >=
	    el->el_line.limit)
		return CC_ERROR;

	el->el_chared.c_kill.mark = el->el_line.cursor;
	cp = el->el_line.cursor;

	/* open the space, */
	c_insert(el,
	    (int)(el->el_chared.c_kill.last - el->el_chared.c_kill.buf));
	/* copy the chars */
	for (kp = el->el_chared.c_kill.buf; kp < el->el_chared.c_kill.last; kp++)
		*cp++ = *kp;

	/* if an arg, cursor at beginning else cursor at end */
	if (el->el_state.argument == 1)
		el->el_line.cursor = cp;

	return CC_REFRESH;
}


/* em_kill_line():
 *	Cut the entire line and save in cut buffer
 *	[^U]
 */
protected el_action_t
/*ARGSUSED*/
em_kill_line(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *kp, *cp;

	cp = el->el_line.buffer;
	kp = el->el_chared.c_kill.buf;
	while (cp < el->el_line.lastchar)
		*kp++ = *cp++;	/* copy it */
	el->el_chared.c_kill.last = kp;
				/* zap! -- delete all of it */
	el->el_line.lastchar = el->el_line.buffer;
	el->el_line.cursor = el->el_line.buffer;
	return CC_REFRESH;
}


/* em_kill_region():
 *	Cut area between mark and cursor and save in cut buffer
 *	[^W]
 */
protected el_action_t
/*ARGSUSED*/
em_kill_region(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *kp, *cp;

	if (!el->el_chared.c_kill.mark)
		return CC_ERROR;

	if (el->el_chared.c_kill.mark > el->el_line.cursor) {
		cp = el->el_line.cursor;
		kp = el->el_chared.c_kill.buf;
		while (cp < el->el_chared.c_kill.mark)
			*kp++ = *cp++;	/* copy it */
		el->el_chared.c_kill.last = kp;
		c_delafter(el, (int)(cp - el->el_line.cursor));
	} else {		/* mark is before cursor */
		cp = el->el_chared.c_kill.mark;
		kp = el->el_chared.c_kill.buf;
		while (cp < el->el_line.cursor)
			*kp++ = *cp++;	/* copy it */
		el->el_chared.c_kill.last = kp;
		c_delbefore(el, (int)(cp - el->el_chared.c_kill.mark));
		el->el_line.cursor = el->el_chared.c_kill.mark;
	}
	return CC_REFRESH;
}


/* em_copy_region():
 *	Copy area between mark and cursor to cut buffer
 *	[M-W]
 */
protected el_action_t
/*ARGSUSED*/
em_copy_region(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *kp, *cp;

	if (!el->el_chared.c_kill.mark)
		return CC_ERROR;

	if (el->el_chared.c_kill.mark > el->el_line.cursor) {
		cp = el->el_line.cursor;
		kp = el->el_chared.c_kill.buf;
		while (cp < el->el_chared.c_kill.mark)
			*kp++ = *cp++;	/* copy it */
		el->el_chared.c_kill.last = kp;
	} else {
		cp = el->el_chared.c_kill.mark;
		kp = el->el_chared.c_kill.buf;
		while (cp < el->el_line.cursor)
			*kp++ = *cp++;	/* copy it */
		el->el_chared.c_kill.last = kp;
	}
	return CC_NORM;
}


/* em_gosmacs_transpose():
 *	Exchange the two characters before the cursor
 *	Gosling emacs transpose chars [^T]
 */
protected el_action_t
em_gosmacs_transpose(EditLine *el, wint_t c)
{

	if (el->el_line.cursor > &el->el_line.buffer[1]) {
		/* must have at least two chars entered */
		c = el->el_line.cursor[-2];
		el->el_line.cursor[-2] = el->el_line.cursor[-1];
		el->el_line.cursor[-1] = c;
		return CC_REFRESH;
	} else
		return CC_ERROR;
}


/* em_next_word():
 *	Move next to end of current word
 *	[M-f]
 */
protected el_action_t
/*ARGSUSED*/
em_next_word(EditLine *el, wint_t c __attribute__((__unused__)))
{
	if (el->el_line.cursor == el->el_line.lastchar)
		return CC_ERROR;

	el->el_line.cursor = c__next_word(el->el_line.cursor,
	    el->el_line.lastchar,
	    el->el_state.argument,
	    ce__isword);

	if (el->el_map.type == MAP_VI)
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return CC_REFRESH;
		}
	return CC_CURSOR;
}


/* em_upper_case():
 *	Uppercase the characters from cursor to end of current word
 *	[M-u]
 */
protected el_action_t
/*ARGSUSED*/
em_upper_case(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *cp, *ep;

	ep = c__next_word(el->el_line.cursor, el->el_line.lastchar,
	    el->el_state.argument, ce__isword);

	for (cp = el->el_line.cursor; cp < ep; cp++)
		if (iswlower(*cp))
			*cp = towupper(*cp);

	el->el_line.cursor = ep;
	if (el->el_line.cursor > el->el_line.lastchar)
		el->el_line.cursor = el->el_line.lastchar;
	return CC_REFRESH;
}


/* em_capitol_case():
 *	Capitalize the characters from cursor to end of current word
 *	[M-c]
 */
protected el_action_t
/*ARGSUSED*/
em_capitol_case(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *cp, *ep;

	ep = c__next_word(el->el_line.cursor, el->el_line.lastchar,
	    el->el_state.argument, ce__isword);

	for (cp = el->el_line.cursor; cp < ep; cp++) {
		if (iswalpha(*cp)) {
			if (iswlower(*cp))
				*cp = towupper(*cp);
			cp++;
			break;
		}
	}
	for (; cp < ep; cp++)
		if (iswupper(*cp))
			*cp = towlower(*cp);

	el->el_line.cursor = ep;
	if (el->el_line.cursor > el->el_line.lastchar)
		el->el_line.cursor = el->el_line.lastchar;
	return CC_REFRESH;
}


/* em_lower_case():
 *	Lowercase the characters from cursor to end of current word
 *	[M-l]
 */
protected el_action_t
/*ARGSUSED*/
em_lower_case(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *cp, *ep;

	ep = c__next_word(el->el_line.cursor, el->el_line.lastchar,
	    el->el_state.argument, ce__isword);

	for (cp = el->el_line.cursor; cp < ep; cp++)
		if (iswupper(*cp))
			*cp = towlower(*cp);

	el->el_line.cursor = ep;
	if (el->el_line.cursor > el->el_line.lastchar)
		el->el_line.cursor = el->el_line.lastchar;
	return CC_REFRESH;
}


/* em_set_mark():
 *	Set the mark at cursor
 *	[^@@]
 */
protected el_action_t
/*ARGSUSED*/
em_set_mark(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_chared.c_kill.mark = el->el_line.cursor;
	return CC_NORM;
}


/* em_exchange_mark():
 *	Exchange the cursor and mark
 *	[^X^X]
 */
protected el_action_t
/*ARGSUSED*/
em_exchange_mark(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *cp;

	cp = el->el_line.cursor;
	el->el_line.cursor = el->el_chared.c_kill.mark;
	el->el_chared.c_kill.mark = cp;
	return CC_CURSOR;
}


/* em_universal_argument():
 *	Universal argument (argument times 4)
 *	[^U]
 */
protected el_action_t
/*ARGSUSED*/
em_universal_argument(EditLine *el, wint_t c __attribute__((__unused__)))
{				/* multiply current argument by 4 */

	if (el->el_state.argument > 1000000)
		return CC_ERROR;
	el->el_state.doingarg = 1;
	el->el_state.argument *= 4;
	return CC_ARGHACK;
}


/* em_meta_next():
 *	Add 8th bit to next character typed
 *	[<ESC>]
 */
protected el_action_t
/*ARGSUSED*/
em_meta_next(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_state.metanext = 1;
	return CC_ARGHACK;
}


/* em_toggle_overwrite():
 *	Switch from insert to overwrite mode or vice versa
 */
protected el_action_t
/*ARGSUSED*/
em_toggle_overwrite(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_state.inputmode = (el->el_state.inputmode == MODE_INSERT) ?
	    MODE_REPLACE : MODE_INSERT;
	return CC_NORM;
}


/* em_copy_prev_word():
 *	Copy current word to cursor
 */
protected el_action_t
/*ARGSUSED*/
em_copy_prev_word(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *cp, *oldc, *dp;

	if (el->el_line.cursor == el->el_line.buffer)
		return CC_ERROR;

	oldc = el->el_line.cursor;
	/* does a bounds check */
	cp = c__prev_word(el->el_line.cursor, el->el_line.buffer,
	    el->el_state.argument, ce__isword);

	c_insert(el, (int)(oldc - cp));
	for (dp = oldc; cp < oldc && dp < el->el_line.lastchar; cp++)
		*dp++ = *cp;

	el->el_line.cursor = dp;/* put cursor at end */

	return CC_REFRESH;
}


/* em_inc_search_next():
 *	Emacs incremental next search
 */
protected el_action_t
/*ARGSUSED*/
em_inc_search_next(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_search.patlen = 0;
	return ce_inc_search(el, ED_SEARCH_NEXT_HISTORY);
}


/* em_inc_search_prev():
 *	Emacs incremental reverse search
 */
protected el_action_t
/*ARGSUSED*/
em_inc_search_prev(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_search.patlen = 0;
	return ce_inc_search(el, ED_SEARCH_PREV_HISTORY);
}


/* em_delete_prev_char():
 *	Delete the character to the left of the cursor
 *	[^?]
 */
protected el_action_t
/*ARGSUSED*/
em_delete_prev_char(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor <= el->el_line.buffer)
		return CC_ERROR;

	if (el->el_state.doingarg)
		c_delbefore(el, el->el_state.argument);
	else
		c_delbefore1(el);
	el->el_line.cursor -= el->el_state.argument;
	if (el->el_line.cursor < el->el_line.buffer)
		el->el_line.cursor = el->el_line.buffer;
	return CC_REFRESH;
}
@


1.16
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: emacs.c,v 1.15 2016/04/09 20:15:26 schwarze Exp $	*/
/*	$NetBSD: emacs.c,v 1.34 2016/04/11 00:50:13 christos Exp $	*/
d45 1
@


1.15
log
@Delete 26 wrapper macros and two wrapper functions that are no
longer needed now that we always compile with wide character support,
reducing code obfuscation.

OK czarkoff@@ martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 2
a2 2
/*	$OpenBSD: emacs.c,v 1.14 2016/03/20 23:48:27 schwarze Exp $	*/
/*	$NetBSD: emacs.c,v 1.33 2016/04/09 18:43:17 christos Exp $	*/
d90 1
a90 1
	Char *cp, *p, *kp;
d119 1
a119 1
	Char *kp, *cp;
d155 1
a155 1
	Char *kp, *cp;
d177 1
a177 1
	Char *kp, *cp;
d210 1
a210 1
	Char *kp, *cp;
d284 1
a284 1
	Char *cp, *ep;
d308 1
a308 1
	Char *cp, *ep;
d340 1
a340 1
	Char *cp, *ep;
d378 1
a378 1
	Char *cp;
d439 1
a439 1
	Char *cp, *oldc, *dp;
@


1.14
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: emacs.c,v 1.13 2016/03/20 22:57:59 schwarze Exp $	*/
/*	$NetBSD: emacs.c,v 1.32 2016/02/16 22:53:14 christos Exp $	*/
d290 2
a291 2
		if (Islower(*cp))
			*cp = Toupper(*cp);
d314 3
a316 3
		if (Isalpha(*cp)) {
			if (Islower(*cp))
				*cp = Toupper(*cp);
d322 2
a323 2
		if (Isupper(*cp))
			*cp = Tolower(*cp);
d346 2
a347 2
		if (Isupper(*cp))
			*cp = Tolower(*cp);
@


1.13
log
@Cleanup of private header inclusion:

1. Do not include private headers from "chared.h", "hist.h", "prompt.h",
"refresh.h", "search.h", "sig.h", "terminal.h", "tty.h".
The only private header having to include other private headers is "el.h".
2. Do not include "common.h", "parse.h", "help.h" from "el.h",
and do not include "emacs.h" and "vi.h" from "chared.h",
include them directly where needed.
3. Do include "fcns.h" from "el.h" because el_func_t is needed for "map.h".
4. Do not include private headers again that are already included by "el.h".
5. Include private headers after standard headers.

OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: emacs.c,v 1.12 2016/03/20 20:35:38 schwarze Exp $	*/
/*	$NetBSD: emacs.c,v 1.31 2016/02/16 19:08:41 christos Exp $	*/
d41 2
@


1.12
log
@Delete the useless Int datatype and always use the standard wint_t
directly.  This is not a problem because <wchar_t> is required all
over the place anyway, even when WIDECHAR is not defined.
No functional change except that it fixes a few printf(3)
format string issues, %c vs. %lc.
OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: emacs.c,v 1.11 2016/01/30 12:22:20 schwarze Exp $	*/
/*	$NetBSD: emacs.c,v 1.25 2011/07/29 15:16:33 christos Exp $	*/
d42 1
@


1.11
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.10 2016/01/30 00:06:39 schwarze Exp $	*/
d49 1
a49 1
em_delete_or_list(EditLine *el, Int c)
d85 1
a85 1
em_delete_next_word(EditLine *el, Int c __attribute__((__unused__)))
d114 1
a114 1
em_yank(EditLine *el, Int c __attribute__((__unused__)))
d150 1
a150 1
em_kill_line(EditLine *el, Int c __attribute__((__unused__)))
d172 1
a172 1
em_kill_region(EditLine *el, Int c __attribute__((__unused__)))
d205 1
a205 1
em_copy_region(EditLine *el, Int c __attribute__((__unused__)))
d234 1
a234 1
em_gosmacs_transpose(EditLine *el, Int c)
d254 1
a254 1
em_next_word(EditLine *el, Int c __attribute__((__unused__)))
d279 1
a279 1
em_upper_case(EditLine *el, Int c __attribute__((__unused__)))
d303 1
a303 1
em_capitol_case(EditLine *el, Int c __attribute__((__unused__)))
d335 1
a335 1
em_lower_case(EditLine *el, Int c __attribute__((__unused__)))
d359 1
a359 1
em_set_mark(EditLine *el, Int c __attribute__((__unused__)))
d373 1
a373 1
em_exchange_mark(EditLine *el, Int c __attribute__((__unused__)))
d390 1
a390 1
em_universal_argument(EditLine *el, Int c __attribute__((__unused__)))
d407 1
a407 1
em_meta_next(EditLine *el, Int c __attribute__((__unused__)))
d420 1
a420 1
em_toggle_overwrite(EditLine *el, Int c __attribute__((__unused__)))
d434 1
a434 1
em_copy_prev_word(EditLine *el, Int c __attribute__((__unused__)))
d461 1
a461 1
em_inc_search_next(EditLine *el, Int c __attribute__((__unused__)))
d474 1
a474 1
em_inc_search_prev(EditLine *el, Int c __attribute__((__unused__)))
d488 1
a488 1
em_delete_prev_char(EditLine *el, Int c __attribute__((__unused__)))
@


1.10
log
@Third step in synching with NetBSD:
* rename fkey_t to funckey_t and el_term_t to el_terminal_t
* rename struct editline member el_term to el_terminal
* rename many functions in terminal.c from term_*() to terminal_*(),
for consistency with the file name and to not look related to <term.h>
No functional change.
This makes refresh.c and sig.c almost identical to the NetBSD versions.
It reduces the remaining diff from +2446 -1805 to +2053 -1420.
OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: emacs.c,v 1.9 2010/06/30 00:05:35 nicm Exp $	*/
/*	$NetBSD: emacs.c,v 1.23 2009/12/30 22:37:40 christos Exp $	*/
d57 1
a57 1
			return (CC_EOF);
d64 1
a64 1
			return (CC_ERROR);
d74 1
a74 1
		return (CC_REFRESH);
d90 1
a90 1
		return (CC_ERROR);
d104 1
a104 1
	return (CC_REFRESH);
d119 1
a119 1
		return (CC_NORM);
d124 1
a124 1
		return (CC_ERROR);
d140 1
a140 1
	return (CC_REFRESH);
d162 1
a162 1
	return (CC_REFRESH);
d177 1
a177 1
		return (CC_ERROR);
d195 1
a195 1
	return (CC_REFRESH);
d210 1
a210 1
		return (CC_ERROR);
d225 1
a225 1
	return (CC_NORM);
d242 1
a242 1
		return (CC_REFRESH);
d244 1
a244 1
		return (CC_ERROR);
d257 1
a257 1
		return (CC_ERROR);
d267 1
a267 1
			return (CC_REFRESH);
d269 1
a269 1
	return (CC_CURSOR);
d293 1
a293 1
	return (CC_REFRESH);
d325 1
a325 1
	return (CC_REFRESH);
d349 1
a349 1
	return (CC_REFRESH);
d363 1
a363 1
	return (CC_NORM);
d380 1
a380 1
	return (CC_CURSOR);
d394 1
a394 1
		return (CC_ERROR);
d397 1
a397 1
	return (CC_ARGHACK);
d411 1
a411 1
	return (CC_ARGHACK);
d425 1
a425 1
	return (CC_NORM);
d439 1
a439 1
		return (CC_ERROR);
d452 1
a452 1
	return (CC_REFRESH);
d465 1
a465 1
	return (ce_inc_search(el, ED_SEARCH_NEXT_HISTORY));
d478 1
a478 1
	return (ce_inc_search(el, ED_SEARCH_PREV_HISTORY));
d492 1
a492 1
		return (CC_ERROR);
d501 1
a501 1
	return (CC_REFRESH);
@


1.9
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
			term_writec(el, c);	/* then do an EOF */
d63 1
a63 1
			term_beep(el);
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
a2 2
/*	$OpenBSD: emacs.c,v 1.7 2003/11/25 20:12:38 otto Exp $	*/
/*	$NetBSD: emacs.c,v 1.16 2003/11/02 20:07:58 christos Exp $	*/
d49 1
a49 1
em_delete_or_list(EditLine *el, int c __attribute__((__unused__)))
d56 1
a56 2
			term_overwrite(el, STReof, 4);	/* then do a EOF */
			term__flush();
d67 4
a70 1
		c_delafter(el, el->el_state.argument);	/* delete after dot */
d85 1
a85 1
em_delete_next_word(EditLine *el, int c __attribute__((__unused__)))
d87 1
a87 1
	char *cp, *p, *kp;
d100 1
a100 1
	c_delafter(el, cp - el->el_line.cursor);	/* delete after dot */
d114 1
a114 1
em_yank(EditLine *el, int c __attribute__((__unused__)))
d116 1
a116 1
	char *kp, *cp;
d130 2
a131 1
	c_insert(el, el->el_chared.c_kill.last - el->el_chared.c_kill.buf);
d150 1
a150 1
em_kill_line(EditLine *el, int c __attribute__((__unused__)))
d152 1
a152 1
	char *kp, *cp;
d172 1
a172 1
em_kill_region(EditLine *el, int c __attribute__((__unused__)))
d174 1
a174 1
	char *kp, *cp;
d185 1
a185 1
		c_delafter(el, cp - el->el_line.cursor);
d192 1
a192 1
		c_delbefore(el, cp - el->el_chared.c_kill.mark);
d205 1
a205 1
em_copy_region(EditLine *el, int c __attribute__((__unused__)))
d207 1
a207 1
	char *kp, *cp;
d234 1
a234 1
em_gosmacs_transpose(EditLine *el, int c)
d254 1
a254 1
em_next_word(EditLine *el, int c __attribute__((__unused__)))
d279 1
a279 1
em_upper_case(EditLine *el, int c __attribute__((__unused__)))
d281 1
a281 1
	char *cp, *ep;
d287 2
a288 2
		if (islower((unsigned char) *cp))
			*cp = toupper(*cp);
d303 1
a303 1
em_capitol_case(EditLine *el, int c __attribute__((__unused__)))
d305 1
a305 1
	char *cp, *ep;
d311 3
a313 3
		if (isalpha((unsigned char) *cp)) {
			if (islower((unsigned char) *cp))
				*cp = toupper(*cp);
d319 2
a320 2
		if (isupper((unsigned char) *cp))
			*cp = tolower(*cp);
d335 1
a335 1
em_lower_case(EditLine *el, int c __attribute__((__unused__)))
d337 1
a337 1
	char *cp, *ep;
d343 2
a344 2
		if (isupper((unsigned char) *cp))
			*cp = tolower(*cp);
d359 1
a359 1
em_set_mark(EditLine *el, int c __attribute__((__unused__)))
d373 1
a373 1
em_exchange_mark(EditLine *el, int c __attribute__((__unused__)))
d375 1
a375 1
	char *cp;
d390 1
a390 1
em_universal_argument(EditLine *el, int c __attribute__((__unused__)))
d407 1
a407 1
em_meta_next(EditLine *el, int c __attribute__((__unused__)))
d420 1
a420 1
em_toggle_overwrite(EditLine *el, int c __attribute__((__unused__)))
d434 1
a434 1
em_copy_prev_word(EditLine *el, int c __attribute__((__unused__)))
d436 1
a436 1
	char *cp, *oldc, *dp;
d446 1
a446 1
	c_insert(el, oldc - cp);
d461 1
a461 1
em_inc_search_next(EditLine *el, int c __attribute__((__unused__)))
d474 1
a474 1
em_inc_search_prev(EditLine *el, int c __attribute__((__unused__)))
d479 23
@


1.7
log
@Sync libedit to NetBSD libedit as of Nov 8, 2003.
Tested by jmc@@ djm@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.6 2003/10/31 08:42:24 otto Exp $	*/
a36 7
#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)emacs.c	8.1 (Berkeley) 6/4/93";
#else
static const char rcsid[] = "$OpenBSD: emacs.c,v 1.6 2003/10/31 08:42:24 otto Exp $";
#endif
#endif /* not lint && not SCCSID */
@


1.6
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: emacs.c,v 1.15 2003/08/07 16:44:31 agc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD$";
d123 2
a124 4
	if (el->el_chared.c_kill.last == el->el_chared.c_kill.buf) {
		if (!ch_enlargebufs(el, 1))
			return (CC_ERROR);
	}
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: emacs.c,v 1.4 2003/05/01 21:11:21 avsm Exp $	*/
/*	$NetBSD: emacs.c,v 1.3 1997/01/11 06:47:54 lukem Exp $	*/
d36 1
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: emacs.c,v 1.4 2003/05/01 21:11:21 avsm Exp $";
d45 1
a45 1
/* 
a47 1
#include "sys.h"
d56 24
a79 14
em_delete_or_list(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor == el->el_line.lastchar) {	/* if I'm at the end */
	if (el->el_line.cursor == el->el_line.buffer) {	/* and the beginning */
	    term_overwrite(el, STReof, 4);/* then do a EOF */
	    term__flush();
	    return CC_EOF;
	}
	else {
	    /* Here we could list completions, but it is an error right now */
	    term_beep(el);
	    return CC_ERROR;
a80 7
    }
    else {
	c_delafter(el, el->el_state.argument);	/* delete after dot */
	if (el->el_line.cursor > el->el_line.lastchar)
	    el->el_line.cursor = el->el_line.lastchar;	/* bounds check */
	return CC_REFRESH;
    }
d90 20
a109 21
em_delete_next_word(el, c)
    EditLine *el;
    int c;
{
    char *cp, *p, *kp;

    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;

    cp = c__next_word(el->el_line.cursor, el->el_line.lastchar, 
		      el->el_state.argument, ce__isword);

    for (p = el->el_line.cursor, kp = el->el_chared.c_kill.buf; p < cp; p++)
	/* save the text */
	*kp++ = *p;
    el->el_chared.c_kill.last = kp;

    c_delafter(el, cp - el->el_line.cursor);		/* delete after dot */
    if (el->el_line.cursor > el->el_line.lastchar)
	el->el_line.cursor = el->el_line.lastchar;	/* bounds check */
    return CC_REFRESH;
d119 16
a134 26
em_yank(el, c)
    EditLine *el;
    int c;
{
    char *kp, *cp;

    if (el->el_chared.c_kill.last == el->el_chared.c_kill.buf)
	return CC_ERROR;

    if (el->el_line.lastchar + 
	(el->el_chared.c_kill.last - el->el_chared.c_kill.buf) >= 
	el->el_line.limit)
	return CC_ERROR;

    el->el_chared.c_kill.mark = el->el_line.cursor;
    cp = el->el_line.cursor;

    /* open the space, */
    c_insert(el, el->el_chared.c_kill.last - el->el_chared.c_kill.buf);	
    /* copy the chars */
    for (kp = el->el_chared.c_kill.buf; kp < el->el_chared.c_kill.last; kp++)	
	*cp++ = *kp;

    /* if an arg, cursor at beginning else cursor at end */
    if (el->el_state.argument == 1)		
	el->el_line.cursor = cp;
d136 11
a146 1
    return CC_REFRESH;
d156 13
a168 14
em_kill_line(el, c)
    EditLine *el;
    int c;
{
    char *kp, *cp;

    cp = el->el_line.buffer;
    kp = el->el_chared.c_kill.buf;
    while (cp < el->el_line.lastchar)
	*kp++ = *cp++;		/* copy it */
    el->el_chared.c_kill.last = kp;
    el->el_line.lastchar = el->el_line.buffer;	/* zap! -- delete all of it */
    el->el_line.cursor = el->el_line.buffer;
    return CC_REFRESH;
d178 1
a178 3
em_kill_region(el, c)
    EditLine *el;
    int c;
d180 1
a180 1
    char *kp, *cp;
d182 2
a183 2
    if (!el->el_chared.c_kill.mark)
	return CC_ERROR;
d185 17
a201 18
    if (el->el_chared.c_kill.mark > el->el_line.cursor) {
	cp = el->el_line.cursor;
	kp = el->el_chared.c_kill.buf;
	while (cp < el->el_chared.c_kill.mark)
	    *kp++ = *cp++;	/* copy it */
	el->el_chared.c_kill.last = kp;
	c_delafter(el, cp - el->el_line.cursor);
    }
    else {			/* mark is before cursor */
	cp = el->el_chared.c_kill.mark;
	kp = el->el_chared.c_kill.buf;
	while (cp < el->el_line.cursor)
	    *kp++ = *cp++;	/* copy it */
	el->el_chared.c_kill.last = kp;
	c_delbefore(el, cp - el->el_chared.c_kill.mark);
	el->el_line.cursor = el->el_chared.c_kill.mark;
    }
    return CC_REFRESH;
d211 1
a211 3
em_copy_region(el, c)
    EditLine *el;
    int c;
d213 1
a213 1
    char *kp, *cp;
d215 2
a216 2
    if (el->el_chared.c_kill.mark)
	return CC_ERROR;
d218 14
a231 15
    if (el->el_chared.c_kill.mark > el->el_line.cursor) {
	cp = el->el_line.cursor;
	kp = el->el_chared.c_kill.buf;
	while (cp < el->el_chared.c_kill.mark)
	    *kp++ = *cp++;	/* copy it */
	el->el_chared.c_kill.last = kp;
    }
    else {
	cp = el->el_chared.c_kill.mark;
	kp = el->el_chared.c_kill.buf;
	while (cp < el->el_line.cursor)
	    *kp++ = *cp++;	/* copy it */
	el->el_chared.c_kill.last = kp;
    }
    return CC_NORM;
d235 1
a235 1
/* em_gosmacs_traspose():
d240 1
a240 3
em_gosmacs_traspose(el, c)
    EditLine *el;
    int c;
d243 8
a250 9
    if (el->el_line.cursor > &el->el_line.buffer[1]) {
   	/* must have at least two chars entered */
	c = el->el_line.cursor[-2];
	el->el_line.cursor[-2] = el->el_line.cursor[-1];
	el->el_line.cursor[-1] = c;
	return CC_REFRESH;
    }
    else 
	return CC_ERROR;
d260 4
a263 16
em_next_word(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor == el->el_line.lastchar)
	return CC_ERROR;

    el->el_line.cursor = c__next_word(el->el_line.cursor, el->el_line.lastchar, 
				      el->el_state.argument,
				      ce__isword);

    if (el->el_map.type == MAP_VI) 
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}
d265 11
a275 1
    return CC_CURSOR;
d278 1
d285 15
a299 17
em_upper_case(el, c)
    EditLine *el;
    int c;
{
    char   *cp, *ep;

    ep = c__next_word(el->el_line.cursor, el->el_line.lastchar, 
		      el->el_state.argument, ce__isword);

    for (cp = el->el_line.cursor; cp < ep; cp++)
	if (islower(*cp))
	    *cp = toupper(*cp);

    el->el_line.cursor = ep;
    if (el->el_line.cursor > el->el_line.lastchar)
	el->el_line.cursor = el->el_line.lastchar;
    return CC_REFRESH;
d309 14
a322 15
em_capitol_case(el, c)
    EditLine *el;
    int c;
{
    char   *cp, *ep;

    ep = c__next_word(el->el_line.cursor, el->el_line.lastchar, 
		      el->el_state.argument, ce__isword);

    for (cp = el->el_line.cursor; cp < ep; cp++) {
	if (isalpha(*cp)) {
	    if (islower(*cp))
		*cp = toupper(*cp);
	    cp++;
	    break;
d324 8
a331 9
    }
    for (; cp < ep; cp++)
	if (isupper(*cp))
	    *cp = tolower(*cp);

    el->el_line.cursor = ep;
    if (el->el_line.cursor > el->el_line.lastchar)
	el->el_line.cursor = el->el_line.lastchar;
    return CC_REFRESH;
d334 1
d341 15
a355 17
em_lower_case(el, c)
    EditLine *el;
    int c;
{
    char   *cp, *ep;

    ep = c__next_word(el->el_line.cursor, el->el_line.lastchar, 
		      el->el_state.argument, ce__isword);

    for (cp = el->el_line.cursor; cp < ep; cp++)
	if (isupper(*cp))
	    *cp = tolower(*cp);

    el->el_line.cursor = ep;
    if (el->el_line.cursor > el->el_line.lastchar)
	el->el_line.cursor = el->el_line.lastchar;
    return CC_REFRESH;
d365 1
a365 3
em_set_mark(el, c)
    EditLine *el;
    int c;
d367 3
a369 2
    el->el_chared.c_kill.mark = el->el_line.cursor;
    return CC_NORM;
d374 1
a374 1
 *	Exchange the cursor and mark 
d379 8
a386 10
em_exchange_mark(el, c)
    EditLine *el;
    int c;
{
    register char *cp;

    cp = el->el_line.cursor;
    el->el_line.cursor = el->el_chared.c_kill.mark;
    el->el_chared.c_kill.mark = cp;
    return CC_CURSOR;
d389 1
d396 1
a396 3
em_universal_argument(el, c)
    EditLine *el;
    int c;
d398 6
a403 5
    if (el->el_state.argument > 1000000)
	return CC_ERROR;
    el->el_state.doingarg = 1;
    el->el_state.argument *= 4;
    return CC_ARGHACK;
d406 1
d413 1
a413 3
em_meta_next(el, c)
    EditLine *el;
    int c;
d415 3
a417 2
    el->el_state.metanext = 1; 
    return CC_ARGHACK;
d426 6
a431 7
em_toggle_overwrite(el, c)
    EditLine *el;
    int c;
{
    el->el_state.inputmode = 
	(el->el_state.inputmode == MODE_INSERT) ? MODE_REPLACE : MODE_INSERT;
    return CC_NORM;
d440 1
a440 3
em_copy_prev_word(el, c)
    EditLine *el;
    int c;
d442 1
a442 1
    char *cp, *oldc, *dp;
d444 2
a445 2
    if (el->el_line.cursor == el->el_line.buffer)
	return CC_ERROR;
d447 4
a450 4
    oldc = el->el_line.cursor;
    /* does a bounds check */
    cp = c__prev_word(el->el_line.cursor, el->el_line.buffer, 
		      el->el_state.argument, ce__isword);	
d452 3
a454 3
    c_insert(el, oldc - cp);
    for (dp = oldc; cp < oldc && dp < el->el_line.lastchar; cp++)
	*dp++ = *cp;
d456 1
a456 1
    el->el_line.cursor = dp;		/* put cursor at end */
d458 1
a458 1
    return CC_REFRESH;
d467 1
a467 3
em_inc_search_next(el, c)
    EditLine *el;
    int c;
d469 3
a471 2
    el->el_search.patlen = 0;
    return ce_inc_search(el, ED_SEARCH_NEXT_HISTORY);
d480 1
a480 3
em_inc_search_prev(el, c)
    EditLine *el;
    int c;
d482 3
a484 2
    el->el_search.patlen = 0;
    return ce_inc_search(el, ED_SEARCH_PREV_HISTORY);
@


1.4
log
@is -Wall clean by making rcsid const
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.3 1997/03/14 05:12:47 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: emacs.c,v 1.3 1997/03/14 05:12:47 millert Exp $";
@


1.3
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: emacs.c,v 1.2 1997/01/16 05:18:32 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: emacs.c,v 1.2 1997/01/16 05:18:32 millert Exp $";
@


1.2
log
@Merge in NetBSD libedit changes and new man pages.  Also fix some
strncpy() usage in their code.  NetBSD change log was:
    * add a man page for the editline routines
    * add a man page describing editrc
    * fix bugs in el_parse():
      * didn't execute command when program name matched (test reversed)
      * was checking against empty string instead of program name
      * after checks, command to run also pointed to empty string
    * document ^char and \ escape sequences
    * when parsing ^char control chars, check the correct char when determining
      validity (previously, ^char was a NOP interpreted as the literal string
      because of this bug)
    * Implement CC_REDISPLAY, which (unlike CC_REFRESH) redraws the entire input
    * line (a la ^R). This is useful if the binding outputs information and
    * mucks up the input line. To be used in ``list-choices'' bindings (refer
    * to the ^D binding in csh when filec is set)
@
text
@d1 2
a2 1
/*	$OpenBSD: $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: $";
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
d42 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
