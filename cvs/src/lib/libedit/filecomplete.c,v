head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.2.0.16
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.14
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.10
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.8
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.6
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.4
	OPENBSD_5_0:1.2.0.2
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.1.0.4
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.2
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	OUneMOe0l7HombT5;

1.11
date	2016.04.11.19.54.54;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	xizUpRlYj2C4Hcj6;

1.10
date	2016.04.09.20.28.27;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	nRwJYvh17UAhrvEe;

1.9
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	tRHhB2RN3ZD1GvoI;

1.8
date	2016.03.20.22.57.59;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	VBVmrUoZFnMc0hts;

1.7
date	2016.01.31.15.34.53;	author schwarze;	state Exp;
branches;
next	1.6;
commitid	xJB4Lz6hQd7hiemB;

1.6
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.5;
commitid	dCN84ovvbfYwqrqX;

1.5
date	2016.01.30.00.06.39;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	tGf8IdK8wCurneJ7;

1.4
date	2014.10.17.06.07.50;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	bdUOvGFxUQgqZg7x;

1.3
date	2014.10.11.03.10.06;	author doug;	state Exp;
branches;
next	1.2;
commitid	xYKDBRQCycn0FjEW;

1.2
date	2011.07.07.05.40.42;	author okan;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.12
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@/*	$OpenBSD: filecomplete.c,v 1.11 2016/04/11 19:54:54 schwarze Exp $ */
/*	$NetBSD: filecomplete.c,v 1.22 2010/12/02 04:42:46 dholland Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jaromir Dolecek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "el.h"
#include "filecomplete.h"

static const wchar_t break_chars[] = L" \t\n\"\\'`@@$><=;|&{(";

/********************************/
/* completion functions */

/*
 * does tilde expansion of strings of type ``~user/foo''
 * if ``user'' isn't valid user name or ``txt'' doesn't start
 * w/ '~', returns pointer to strdup()ed copy of ``txt''
 *
 * it's the caller's responsibility to free() the returned string
 */
char *
fn_tilde_expand(const char *txt)
{
	struct passwd pwres, *pass;
	char *temp;
	size_t tempsz, len = 0;
	char pwbuf[1024];

	if (txt[0] != '~')
		return strdup(txt);

	temp = strchr(txt + 1, '/');
	if (temp == NULL) {
		temp = strdup(txt + 1);
		if (temp == NULL)
			return NULL;
	} else {
		len = temp - txt + 1;	/* text until string after slash */
		temp = malloc(len);
		if (temp == NULL)
			return NULL;
		(void)strncpy(temp, txt + 1, len - 2);
		temp[len - 2] = '\0';
	}
	if (temp[0] == 0) {
		if (getpwuid_r(getuid(), &pwres, pwbuf, sizeof(pwbuf), &pass) != 0)
			pass = NULL;
	} else {
		if (getpwnam_r(temp, &pwres, pwbuf, sizeof(pwbuf), &pass) != 0)
			pass = NULL;
	}
	free(temp);		/* value no more needed */
	if (pass == NULL)
		return strdup(txt);

	/* update pointer txt to point at string immedially following */
	/* first slash */
	txt += len;

	tempsz = strlen(pass->pw_dir) + 1 + strlen(txt) + 1;
	temp = malloc(tempsz);
	if (temp == NULL)
		return NULL;
	(void)snprintf(temp, tempsz, "%s/%s", pass->pw_dir, txt);

	return temp;
}


/*
 * return first found file name starting by the ``text'' or NULL if no
 * such file can be found
 * value of ``state'' is ignored
 *
 * it's the caller's responsibility to free the returned string
 */
char *
fn_filename_completion_function(const char *text, int state)
{
	static DIR *dir = NULL;
	static char *filename = NULL, *dirname = NULL, *dirpath = NULL;
	static size_t filename_len = 0;
	struct dirent *entry;
	char *temp;
	size_t tempsz, len;

	if (state == 0 || dir == NULL) {
		temp = strrchr(text, '/');
		if (temp) {
			size_t sz = strlen(temp + 1) + 1;
			char *nptr;
			temp++;
			nptr = realloc(filename, sz);
			if (nptr == NULL) {
				free(filename);
				filename = NULL;
				return NULL;
			}
			filename = nptr;
			(void)strlcpy(filename, temp, sz);
			len = temp - text;	/* including last slash */

			nptr = realloc(dirname, len + 1);
			if (nptr == NULL) {
				free(dirname);
				dirname = NULL;
				return NULL;
			}
			dirname = nptr;
			(void)strncpy(dirname, text, len);
			dirname[len] = '\0';
		} else {
			free(filename);
			if (*text == 0)
				filename = NULL;
			else {
				filename = strdup(text);
				if (filename == NULL)
					return NULL;
			}
			free(dirname);
			dirname = NULL;
		}

		if (dir != NULL) {
			(void)closedir(dir);
			dir = NULL;
		}

		/* support for ``~user'' syntax */

		free(dirpath);
		dirpath = NULL;
		if (dirname == NULL) {
			if ((dirname = strdup("")) == NULL)
				return NULL;
			dirpath = strdup("./");
		} else if (*dirname == '~')
			dirpath = fn_tilde_expand(dirname);
		else
			dirpath = strdup(dirname);

		if (dirpath == NULL)
			return NULL;

		dir = opendir(dirpath);
		if (!dir)
			return NULL;	/* cannot open the directory */

		/* will be used in cycle */
		filename_len = filename ? strlen(filename) : 0;
	}

	/* find the match */
	while ((entry = readdir(dir)) != NULL) {
		/* skip . and .. */
		if (entry->d_name[0] == '.' && (!entry->d_name[1]
		    || (entry->d_name[1] == '.' && !entry->d_name[2])))
			continue;
		if (filename_len == 0)
			break;
		/* otherwise, get first entry where first */
		/* filename_len characters are equal	  */
		if (entry->d_name[0] == filename[0]
#if HAVE_STRUCT_DIRENT_D_NAMLEN
		    && entry->d_namlen >= filename_len
#else
		    && strlen(entry->d_name) >= filename_len
#endif
		    && strncmp(entry->d_name, filename,
			filename_len) == 0)
			break;
	}

	if (entry) {		/* match found */

#if HAVE_STRUCT_DIRENT_D_NAMLEN
		len = entry->d_namlen;
#else
		len = strlen(entry->d_name);
#endif

		tempsz = strlen(dirname) + len + 1;
		temp = malloc(tempsz);
		if (temp == NULL)
			return NULL;
		(void)snprintf(temp, tempsz, "%s%s", dirname, entry->d_name);
	} else {
		(void)closedir(dir);
		dir = NULL;
		temp = NULL;
	}

	return temp;
}


static const char *
append_char_function(const char *name)
{
	struct stat stbuf;
	char *expname = *name == '~' ? fn_tilde_expand(name) : NULL;
	const char *rs = " ";

	if (stat(expname ? expname : name, &stbuf) == -1)
		goto out;
	if (S_ISDIR(stbuf.st_mode))
		rs = "/";
out:
	if (expname)
		free(expname);
	return rs;
}
/*
 * returns list of completions for text given
 * non-static for readline.
 */
char ** completion_matches(const char *, char *(*)(const char *, int));
char **
completion_matches(const char *text, char *(*genfunc)(const char *, int))
{
	char **match_list = NULL, *retstr, *prevstr;
	size_t match_list_len, max_equal, which, i;
	size_t matches;

	matches = 0;
	match_list_len = 1;
	while ((retstr = (*genfunc) (text, (int)matches)) != NULL) {
		/* allow for list terminator here */
		if (matches + 3 >= match_list_len) {
			char **nmatch_list;
			while (matches + 3 >= match_list_len)
				match_list_len <<= 1;
			nmatch_list = reallocarray(match_list,
			    match_list_len, sizeof(char *));
			if (nmatch_list == NULL) {
				free(match_list);
				return NULL;
			}
			match_list = nmatch_list;

		}
		match_list[++matches] = retstr;
	}

	if (!match_list)
		return NULL;	/* nothing found */

	/* find least denominator and insert it to match_list[0] */
	which = 2;
	prevstr = match_list[1];
	max_equal = strlen(prevstr);
	for (; which <= matches; which++) {
		for (i = 0; i < max_equal &&
		    prevstr[i] == match_list[which][i]; i++)
			continue;
		max_equal = i;
	}

	retstr = malloc(max_equal + 1);
	if (retstr == NULL) {
		free(match_list);
		return NULL;
	}
	(void)strncpy(retstr, match_list[1], max_equal);
	retstr[max_equal] = '\0';
	match_list[0] = retstr;

	/* add NULL as last pointer to the array */
	match_list[matches + 1] = NULL;

	return match_list;
}

/*
 * Sort function for qsort(). Just wrapper around strcasecmp().
 */
static int
_fn_qsort_string_compare(const void *i1, const void *i2)
{
	const char *s1 = ((const char * const *)i1)[0];
	const char *s2 = ((const char * const *)i2)[0];

	return strcasecmp(s1, s2);
}

/*
 * Display list of strings in columnar format on readline's output stream.
 * 'matches' is list of strings, 'num' is number of strings in 'matches',
 * 'width' is maximum length of string in 'matches'.
 *
 * matches[0] is not one of the match strings, but it is counted in
 * num, so the strings are matches[1] *through* matches[num-1].
 */
void
fn_display_match_list (EditLine *el, char **matches, size_t num, size_t width)
{
	size_t line, lines, col, cols, thisguy;
	int screenwidth = el->el_terminal.t_size.h;

	/* Ignore matches[0]. Avoid 1-based array logic below. */
	matches++;
	num--;

	/*
	 * Find out how many entries can be put on one line; count
	 * with one space between strings the same way it's printed.
	 */
	cols = screenwidth / (width + 1);
	if (cols == 0)
		cols = 1;

	/* how many lines of output, rounded up */
	lines = (num + cols - 1) / cols;

	/* Sort the items. */
	qsort(matches, num, sizeof(char *), _fn_qsort_string_compare);

	/*
	 * On the ith line print elements i, i+lines, i+lines*2, etc.
	 */
	for (line = 0; line < lines; line++) {
		for (col = 0; col < cols; col++) {
			thisguy = line + col * lines;
			if (thisguy >= num)
				break;
			(void)fprintf(el->el_outfile, "%s%-*s",
			    col == 0 ? "" : " ", (int)width, matches[thisguy]);
		}
		(void)fprintf(el->el_outfile, "\n");
	}
}

/*
 * Complete the word at or before point,
 * 'what_to_do' says what to do with the completion.
 * \t   means do standard completion.
 * `?' means list the possible completions.
 * `*' means insert all of the possible completions.
 * `!' means to do standard completion, and list all possible completions if
 * there is more than one.
 *
 * Note: '*' support is not implemented
 *       '!' could never be invoked
 */
int
fn_complete(EditLine *el,
	char *(*complet_func)(const char *, int),
	char **(*attempted_completion_function)(const char *, int, int),
	const wchar_t *word_break, const wchar_t *special_prefixes,
	const char *(*app_func)(const char *), size_t query_items,
	int *completion_type, int *over, int *point, int *end)
{
	const LineInfoW *li;
	wchar_t *temp;
        char **matches;
	const wchar_t *ctemp;
	size_t len;
	int what_to_do = '\t';
	int retval = CC_NORM;

	if (el->el_state.lastcmd == el->el_state.thiscmd)
		what_to_do = '?';

	/* readline's rl_complete() has to be told what we did... */
	if (completion_type != NULL)
		*completion_type = what_to_do;

	if (!complet_func)
		complet_func = fn_filename_completion_function;
	if (!app_func)
		app_func = append_char_function;

	/* We now look backwards for the start of a filename/variable word */
	li = el_wline(el);
	ctemp = li->cursor;
	while (ctemp > li->buffer
	    && !wcschr(word_break, ctemp[-1])
	    && (!special_prefixes || !wcschr(special_prefixes, ctemp[-1]) ) )
		ctemp--;

	len = li->cursor - ctemp;
	temp = reallocarray(NULL, len + 1, sizeof(*temp));
	(void)wcsncpy(temp, ctemp, len);
	temp[len] = '\0';

	/* these can be used by function called in completion_matches() */
	/* or (*attempted_completion_function)() */
	if (point != NULL)
		*point = (int)(li->cursor - li->buffer);
	if (end != NULL)
		*end = (int)(li->lastchar - li->buffer);

	if (attempted_completion_function) {
		int cur_off = (int)(li->cursor - li->buffer);
		matches = (*attempted_completion_function) (
		    ct_encode_string(temp, &el->el_scratch),
		    (int)(cur_off - len), cur_off);
	} else
		matches = NULL;
	if (!attempted_completion_function ||
	    (over != NULL && !*over && !matches))
		matches = completion_matches(
		    ct_encode_string(temp, &el->el_scratch), complet_func);

	if (over != NULL)
		*over = 0;

	if (matches) {
		int i;
		size_t matches_num, maxlen, match_len, match_display=1;

		retval = CC_REFRESH;
		/*
		 * Only replace the completed string with common part of
		 * possible matches if there is possible completion.
		 */
		if (matches[0][0] != '\0') {
			el_deletestr(el, (int) len);
			el_winsertstr(el,
			    ct_decode_string(matches[0], &el->el_scratch));
		}

		if (what_to_do == '?')
			goto display_matches;

		if (matches[2] == NULL && strcmp(matches[0], matches[1]) == 0) {
			/*
			 * We found exact match. Add a space after
			 * it, unless we do filename completion and the
			 * object is a directory.
			 */
			el_winsertstr(el,
			    ct_decode_string((*app_func)(matches[0]),
			    &el->el_scratch));
		} else if (what_to_do == '!') {
    display_matches:
			/*
			 * More than one match and requested to list possible
			 * matches.
			 */

			for(i = 1, maxlen = 0; matches[i]; i++) {
				match_len = strlen(matches[i]);
				if (match_len > maxlen)
					maxlen = match_len;
			}
			/* matches[1] through matches[i-1] are available */
			matches_num = i - 1;

			/* newline to get on next line from command line */
			(void)fprintf(el->el_outfile, "\n");

			/*
			 * If there are too many items, ask user for display
			 * confirmation.
			 */
			if (matches_num > query_items) {
				(void)fprintf(el->el_outfile,
				    "Display all %zu possibilities? (y or n) ",
				    matches_num);
				(void)fflush(el->el_outfile);
				if (getc(stdin) != 'y')
					match_display = 0;
				(void)fprintf(el->el_outfile, "\n");
			}

			if (match_display) {
				/*
				 * Interface of this function requires the
				 * strings be matches[1..num-1] for compat.
				 * We have matches_num strings not counting
				 * the prefix in matches[0], so we need to
				 * add 1 to matches_num for the call.
				 */
				fn_display_match_list(el, matches,
				    matches_num+1, maxlen);
			}
			retval = CC_REDISPLAY;
		} else if (matches[0][0]) {
			/*
			 * There was some common match, but the name was
			 * not complete enough. Next tab will print possible
			 * completions.
			 */
			el_beep(el);
		} else {
			/* lcd is not a valid object - further specification */
			/* is needed */
			el_beep(el);
			retval = CC_NORM;
		}

		/* free elements of array and the array itself */
		for (i = 0; matches[i]; i++)
			free(matches[i]);
		free(matches);
		matches = NULL;
	}
	free(temp);
	return retval;
}

/*
 * el-compatible wrapper around rl_complete; needed for key binding
 */
/* ARGSUSED */
unsigned char
_el_fn_complete(EditLine *el, int ch __attribute__((__unused__)))
{
	return (unsigned char)fn_complete(el, NULL, NULL,
	    break_chars, NULL, NULL, 100,
	    NULL, NULL, NULL, NULL);
}
@


1.11
log
@Move wrapper macros to the two files actually needing them:
FUNW, Strlen, Strdup, Strcmp, Strncmp, Strncpy, Strncat -> history.c
Strchr, tok_strdup -> tokenizer.c
FUN, TYPE, STR -> both of these files

OK martijn@@

Also proofread by Christian Heckendorf <mbie at ulmus dot me>
who reported some whitespace issues in parse.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.10 2016/04/09 20:28:27 schwarze Exp $ */
d50 1
a50 3
static const Char break_chars[] = { ' ', '\t', '\n', '"', '\\', '\'', '`', '@@',
    '$', '>', '<', '=', ';', '|', '&', '{', '(', '\0' };

d391 1
a391 1
	const Char *word_break, const Char *special_prefixes,
d396 1
a396 1
	Char *temp;
d398 1
a398 1
	const Char *ctemp;
@


1.10
log
@For pointers, use NULL rather than 0; no functional change;
from Pedro Giffuni via Christos Zoulas.
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.9 2016/03/20 23:48:27 schwarze Exp $ */
d397 1
a397 1
	const TYPE(LineInfo) *li;
d418 1
a418 1
	li = FUN(el,line)(el);
d421 2
a422 2
	    && !Strchr(word_break, ctemp[-1])
	    && (!special_prefixes || !Strchr(special_prefixes, ctemp[-1]) ) )
d427 1
a427 1
	(void)Strncpy(temp, ctemp, len);
d463 1
a463 1
			FUN(el,insertstr)(el,
d476 1
a476 1
			FUN(el,insertstr)(el,
@


1.9
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.8 2016/03/20 22:57:59 schwarze Exp $ */
d432 1
a432 1
	if (point != 0)
d443 1
a443 1
		matches = 0;
@


1.8
log
@Cleanup of private header inclusion:

1. Do not include private headers from "chared.h", "hist.h", "prompt.h",
"refresh.h", "search.h", "sig.h", "terminal.h", "tty.h".
The only private header having to include other private headers is "el.h".
2. Do not include "common.h", "parse.h", "help.h" from "el.h",
and do not include "emacs.h" and "vi.h" from "chared.h",
include them directly where needed.
3. Do include "fcns.h" from "el.h" because el_func_t is needed for "map.h".
4. Do not include private headers again that are already included by "el.h".
5. Include private headers after standard headers.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.7 2016/01/31 15:34:53 schwarze Exp $ */
a36 1
#include <stdio.h>
d38 3
a40 1
#include <string.h>
d42 1
a42 1
#include <ctype.h>
d44 1
a45 3
#include <limits.h>
#include <errno.h>
#include <fcntl.h>
d444 1
a444 1
	if (!attempted_completion_function || 
d493 1
a493 1
				
@


1.7
log
@trivial partial sync to NetBSD, no functional change:
* remove unused ifdef'ed header junk
* remove pointless cast of NULL
* wrap two excessively long lines
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.6 2016/01/30 12:22:20 schwarze Exp $ */
a48 2
#include "fcns.h"		/* for EL_NUM_FCNS */
#include "histedit.h"
@


1.6
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.5 2016/01/30 00:06:39 schwarze Exp $	*/
d47 1
a47 8
#ifdef HAVE_VIS_H
#include <vis.h>
#else
#include "np/vis.h"
#endif
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#endif
d316 1
a316 1
	match_list[matches + 1] = (char *) NULL;
d442 2
a443 1
		matches = (*attempted_completion_function) (ct_encode_string(temp, &el->el_scratch),
d449 2
a450 1
		matches = completion_matches(ct_encode_string(temp, &el->el_scratch), complet_func);
@


1.5
log
@Third step in synching with NetBSD:
* rename fkey_t to funckey_t and el_term_t to el_terminal_t
* rename struct editline member el_term to el_terminal
* rename many functions in terminal.c from term_*() to terminal_*(),
for consistency with the file name and to not look related to <term.h>
No functional change.
This makes refresh.c and sig.c almost identical to the NetBSD versions.
It reduces the remaining diff from +2446 -1805 to +2053 -1420.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.4 2014/10/17 06:07:50 deraadt Exp $	*/
d72 1
a72 1
 * it's callers's responsibility to free() returned string
d83 1
a83 1
		return (strdup(txt));
d107 1
a107 1
		return (strdup(txt));
d119 1
a119 1
	return (temp);
d128 1
a128 1
 * it's caller's responsibility to free returned string
d201 1
a201 1
			return (NULL);	/* cannot open the directory */
d247 1
a247 1
	return (temp);
d325 1
a325 1
	return (match_list);
@


1.4
log
@Remove non-exposed malloc/realloc/free wrappers, and then substitute
reallocarray() where it helps.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.3 2014/10/11 03:10:06 doug Exp $	*/
d352 1
a352 1
	int screenwidth = el->el_term.t_size.h;
@


1.3
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.2 2011/07/07 05:40:42 okan Exp $	*/
d436 1
a436 5
#if defined(__SSP__) || defined(__SSP_ALL__)
	temp = malloc(sizeof(*temp) * (len + 1));
#else
	temp = alloca(sizeof(*temp) * (len + 1));
#endif
a550 1
#if defined(__SSP__) || defined(__SSP_ALL__)
a551 1
#endif
@


1.2
log
@sync with upstream, retaining local modifications.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filecomplete.c,v 1.1 2010/06/30 00:05:35 nicm Exp $	*/
d287 2
a288 2
			nmatch_list = realloc(match_list,
			    match_list_len * sizeof(char *));
@


1.1
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: filecomplete.c,v 1.18 2010/01/18 19:17:42 christos Exp $	*/
d60 1
a60 1
static Char break_chars[] = { ' ', '\t', '\n', '"', '\\', '\'', '`', '@@',
d149 1
d155 1
d158 2
a159 1
				free(filename);
d166 1
d174 1
d184 1
d186 6
a191 5

		if (dirname == NULL && (dirname = strdup("./")) == NULL)
			return NULL;

		if (*dirname == '~')
d342 5
a346 2
 * 'matches' is list of strings, 'len' is number of strings in 'matches',
 * 'max' is maximum length of string in 'matches'.
d349 1
a349 1
fn_display_match_list (EditLine *el, char **matches, size_t len, size_t max)
d351 1
a351 1
	size_t i, idx, limit, count;
d354 18
d373 1
a373 2
	 * Find out how many entries can be put on one line, count
	 * with two spaces between strings.
d375 7
a381 20
	limit = screenwidth / (max + 2);
	if (limit == 0)
		limit = 1;

	/* how many lines of output */
	count = len / limit;
	if (count * limit < len)
		count++;

	/* Sort the items if they are not already sorted. */
	qsort(&matches[1], (size_t)(len - 1), sizeof(char *),
	    _fn_qsort_string_compare);

	idx = 1;
	for(; count > 0; count--) {
		int more = limit > 0 && matches[0];
		for(i = 0; more; i++, idx++) {
			more = ++i < limit && matches[idx + 1];
			(void)fprintf(el->el_outfile, "%-*s%s", (int)max,
			    matches[idx], more ? " " : "");
d503 1
d523 11
a533 3
			if (match_display)
				fn_display_match_list(el, matches, matches_num,
				    maxlen);
@

