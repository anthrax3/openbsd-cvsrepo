head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6;
locks; strict;
comment	@ * @;


1.17
date	2016.05.06.13.12.52;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	HmIy04UbyUS0d1Sd;

1.16
date	2016.04.11.21.17.29;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	I3AtNAFb4FywnTMT;

1.15
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	OUneMOe0l7HombT5;

1.14
date	2016.04.11.19.54.54;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	xizUpRlYj2C4Hcj6;

1.13
date	2016.04.09.20.15.26;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	0bnhGLXZIvXlnMLp;

1.12
date	2016.04.09.19.31.55;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	t22PDRfkb5DJX3rc;

1.11
date	2016.03.22.11.32.18;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	IqABuRl0Ys8M4ewM;

1.10
date	2016.03.22.11.10.57;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	OOl5ulc2ZFzZrUgO;

1.9
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	tRHhB2RN3ZD1GvoI;

1.8
date	2016.03.20.21.25.27;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	MXwDFI6noAnjy3an;

1.7
date	2016.03.20.20.35.38;	author schwarze;	state Exp;
branches;
next	1.6;
commitid	b06qlwkNEbVitvG0;

1.6
date	2016.01.30.17.32.52;	author schwarze;	state Exp;
branches;
next	1.5;
commitid	wAt9MiELkmlnoi4U;

1.5
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	dCN84ovvbfYwqrqX;

1.4
date	2016.01.30.02.52.41;	author schwarze;	state Exp;
branches;
next	1.3;
commitid	GXbmevFye1xXIR4O;

1.3
date	2016.01.30.00.06.39;	author schwarze;	state Exp;
branches;
next	1.2;
commitid	tGf8IdK8wCurneJ7;

1.2
date	2016.01.29.19.32.33;	author schwarze;	state Exp;
branches;
next	1.1;
commitid	Ue1IcMCqgxm4S8jQ;

1.1
date	2016.01.29.17.23.21;	author schwarze;	state Exp;
branches;
next	;
commitid	MOfHvqt1MJvqXmCY;


desc
@@


1.17
log
@Replace the generated file "fcns.c" by a simpler header "func.h"
included only in the one file needing it, "map.c".
That allows to define el_action_t directly in "map.h",
which in turn allows to stop including "fcns.h" from "el.h"
and include it only in the modules needing it.
Now we no longer autogenerate any C files.

Feedback and OK martijn@@.
First version also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@/*	$OpenBSD: terminal.c,v 1.16 2016/04/11 21:17:29 schwarze Exp $	*/
/*	$NetBSD: terminal.c,v 1.17 2016/02/15 15:35:03 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * terminal.c: Editor/termcap-curses interface
 *	       We have to declare a static variable here, since the
 *	       termcap putchar routine does not take an argument!
 */
#include <sys/types.h>
#include <sys/ioctl.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#ifdef HAVE_TERMCAP_H
#include <termcap.h>
#endif
#ifdef HAVE_CURSES_H
#include <curses.h>
#elif HAVE_NCURSES_H
#include <ncurses.h>
#endif
/* Solaris's term.h does horrid things. */

#if defined(HAVE_TERM_H) && !defined(__sun)
#include <term.h>
#endif

#ifdef _REENTRANT
#include <pthread.h>
#endif

#include "el.h"
#include "fcns.h"

/*
 * IMPORTANT NOTE: these routines are allowed to look at the current screen
 * and the current position assuming that it is correct.  If this is not
 * true, then the update will be WRONG!  This is (should be) a valid
 * assumption...
 */

#define	TC_BUFSIZE	2048

#define	GoodStr(a)	(el->el_terminal.t_str[a] != NULL && \
			    el->el_terminal.t_str[a][0] != '\0')
#define	Str(a)		el->el_terminal.t_str[a]
#define	Val(a)		el->el_terminal.t_val[a]

static const struct termcapstr {
	const char *name;
	const char *long_name;
} tstr[] = {
#define	T_al	0
	{ "al", "add new blank line" },
#define	T_bl	1
	{ "bl", "audible bell" },
#define	T_cd	2
	{ "cd", "clear to bottom" },
#define	T_ce	3
	{ "ce", "clear to end of line" },
#define	T_ch	4
	{ "ch", "cursor to horiz pos" },
#define	T_cl	5
	{ "cl", "clear screen" },
#define	T_dc	6
	{ "dc", "delete a character" },
#define	T_dl	7
	{ "dl", "delete a line" },
#define	T_dm	8
	{ "dm", "start delete mode" },
#define	T_ed	9
	{ "ed", "end delete mode" },
#define	T_ei	10
	{ "ei", "end insert mode" },
#define	T_fs	11
	{ "fs", "cursor from status line" },
#define	T_ho	12
	{ "ho", "home cursor" },
#define	T_ic	13
	{ "ic", "insert character" },
#define	T_im	14
	{ "im", "start insert mode" },
#define	T_ip	15
	{ "ip", "insert padding" },
#define	T_kd	16
	{ "kd", "sends cursor down" },
#define	T_kl	17
	{ "kl", "sends cursor left" },
#define	T_kr	18
	{ "kr", "sends cursor right" },
#define	T_ku	19
	{ "ku", "sends cursor up" },
#define	T_md	20
	{ "md", "begin bold" },
#define	T_me	21
	{ "me", "end attributes" },
#define	T_nd	22
	{ "nd", "non destructive space" },
#define	T_se	23
	{ "se", "end standout" },
#define	T_so	24
	{ "so", "begin standout" },
#define	T_ts	25
	{ "ts", "cursor to status line" },
#define	T_up	26
	{ "up", "cursor up one" },
#define	T_us	27
	{ "us", "begin underline" },
#define	T_ue	28
	{ "ue", "end underline" },
#define	T_vb	29
	{ "vb", "visible bell" },
#define	T_DC	30
	{ "DC", "delete multiple chars" },
#define	T_DO	31
	{ "DO", "cursor down multiple" },
#define	T_IC	32
	{ "IC", "insert multiple chars" },
#define	T_LE	33
	{ "LE", "cursor left multiple" },
#define	T_RI	34
	{ "RI", "cursor right multiple" },
#define	T_UP	35
	{ "UP", "cursor up multiple" },
#define	T_kh	36
	{ "kh", "send cursor home" },
#define	T_at7	37
	{ "@@7", "send cursor end" },
#define	T_str	38
	{ NULL, NULL }
};

static const struct termcapval {
	const char *name;
	const char *long_name;
} tval[] = {
#define	T_am	0
	{ "am", "has automatic margins" },
#define	T_pt	1
	{ "pt", "has physical tabs" },
#define	T_li	2
	{ "li", "Number of lines" },
#define	T_co	3
	{ "co", "Number of columns" },
#define	T_km	4
	{ "km", "Has meta key" },
#define	T_xt	5
	{ "xt", "Tab chars destructive" },
#define	T_xn	6
	{ "xn", "newline ignored at right margin" },
#define	T_MT	7
	{ "MT", "Has meta key" },			/* XXX? */
#define	T_val	8
	{ NULL, NULL, }
};
/* do two or more of the attributes use me */

static void	terminal_setflags(EditLine *);
static int	terminal_rebuffer_display(EditLine *);
static void	terminal_free_display(EditLine *);
static int	terminal_alloc_display(EditLine *);
static void	terminal_alloc(EditLine *, const struct termcapstr *,
    const char *);
static void	terminal_init_arrow(EditLine *);
static void	terminal_reset_arrow(EditLine *);
static int	terminal_putc(int);
static void	terminal_tputs(EditLine *, const char *, int);

#ifdef _REENTRANT
static pthread_mutex_t terminal_mutex = PTHREAD_MUTEX_INITIALIZER;
#endif
static FILE *terminal_outfile = NULL;


/* terminal_setflags():
 *	Set the terminal capability flags
 */
static void
terminal_setflags(EditLine *el)
{
	EL_FLAGS = 0;
	if (el->el_tty.t_tabs)
		EL_FLAGS |= (Val(T_pt) && !Val(T_xt)) ? TERM_CAN_TAB : 0;

	EL_FLAGS |= (Val(T_km) || Val(T_MT)) ? TERM_HAS_META : 0;
	EL_FLAGS |= GoodStr(T_ce) ? TERM_CAN_CEOL : 0;
	EL_FLAGS |= (GoodStr(T_dc) || GoodStr(T_DC)) ? TERM_CAN_DELETE : 0;
	EL_FLAGS |= (GoodStr(T_im) || GoodStr(T_ic) || GoodStr(T_IC)) ?
	    TERM_CAN_INSERT : 0;
	EL_FLAGS |= (GoodStr(T_up) || GoodStr(T_UP)) ? TERM_CAN_UP : 0;
	EL_FLAGS |= Val(T_am) ? TERM_HAS_AUTO_MARGINS : 0;
	EL_FLAGS |= Val(T_xn) ? TERM_HAS_MAGIC_MARGINS : 0;

	if (GoodStr(T_me) && GoodStr(T_ue))
		EL_FLAGS |= (strcmp(Str(T_me), Str(T_ue)) == 0) ?
		    TERM_CAN_ME : 0;
	else
		EL_FLAGS &= ~TERM_CAN_ME;
	if (GoodStr(T_me) && GoodStr(T_se))
		EL_FLAGS |= (strcmp(Str(T_me), Str(T_se)) == 0) ?
		    TERM_CAN_ME : 0;


#ifdef DEBUG_SCREEN
	if (!EL_CAN_UP) {
		(void) fprintf(el->el_errfile,
		    "WARNING: Your terminal cannot move up.\n");
		(void) fprintf(el->el_errfile,
		    "Editing may be odd for long lines.\n");
	}
	if (!EL_CAN_CEOL)
		(void) fprintf(el->el_errfile, "no clear EOL capability.\n");
	if (!EL_CAN_DELETE)
		(void) fprintf(el->el_errfile, "no delete char capability.\n");
	if (!EL_CAN_INSERT)
		(void) fprintf(el->el_errfile, "no insert char capability.\n");
#endif /* DEBUG_SCREEN */
}

/* terminal_init():
 *	Initialize the terminal stuff
 */
protected int
terminal_init(EditLine *el)
{

	el->el_terminal.t_buf = (char *)malloc(TC_BUFSIZE);
	if (el->el_terminal.t_buf == NULL)
		goto fail1;
	el->el_terminal.t_cap = (char *)malloc(TC_BUFSIZE);
	if (el->el_terminal.t_cap == NULL)
		goto fail2;
	el->el_terminal.t_fkey = reallocarray(NULL, A_K_NKEYS,
	    sizeof(*el->el_terminal.t_fkey));
	if (el->el_terminal.t_fkey == NULL)
		goto fail3;
	el->el_terminal.t_loc = 0;
	el->el_terminal.t_str = reallocarray(NULL, T_str, sizeof(char *));
	if (el->el_terminal.t_str == NULL)
		goto fail4;
	(void) memset(el->el_terminal.t_str, 0, T_str * sizeof(char *));
	el->el_terminal.t_val = reallocarray(NULL, T_val, sizeof(int));
	if (el->el_terminal.t_val == NULL)
		goto fail5;
	(void) memset(el->el_terminal.t_val, 0, T_val * sizeof(int));
	(void) terminal_set(el, NULL);
	terminal_init_arrow(el);
	return 0;
fail5:
	free(el->el_terminal.t_str);
	el->el_terminal.t_str = NULL;
fail4:
	free(el->el_terminal.t_fkey);
	el->el_terminal.t_fkey = NULL;
fail3:
	free(el->el_terminal.t_cap);
	el->el_terminal.t_cap = NULL;
fail2:
	free(el->el_terminal.t_buf);
	el->el_terminal.t_buf = NULL;
fail1:
	return -1;
}

/* terminal_end():
 *	Clean up the terminal stuff
 */
protected void
terminal_end(EditLine *el)
{

	free(el->el_terminal.t_buf);
	el->el_terminal.t_buf = NULL;
	free(el->el_terminal.t_cap);
	el->el_terminal.t_cap = NULL;
	el->el_terminal.t_loc = 0;
	free(el->el_terminal.t_str);
	el->el_terminal.t_str = NULL;
	free(el->el_terminal.t_val);
	el->el_terminal.t_val = NULL;
	free(el->el_terminal.t_fkey);
	el->el_terminal.t_fkey = NULL;
	terminal_free_display(el);
}


/* terminal_alloc():
 *	Maintain a string pool for termcap strings
 */
static void
terminal_alloc(EditLine *el, const struct termcapstr *t, const char *cap)
{
	char termbuf[TC_BUFSIZE];
	size_t tlen, clen;
	char **tlist = el->el_terminal.t_str;
	char **tmp, **str = &tlist[t - tstr];

	if (cap == NULL || *cap == '\0') {
		*str = NULL;
		return;
	} else
		clen = strlen(cap);

	tlen = *str == NULL ? 0 : strlen(*str);

	/*
         * New string is shorter; no need to allocate space
         */
	if (clen <= tlen) {
		if (*str)
			(void) strlcpy(*str, cap, tlen + 1);
		return;
	}
	/*
         * New string is longer; see if we have enough space to append
         */
	if (el->el_terminal.t_loc + 3 < TC_BUFSIZE) {
		tlen = TC_BUFSIZE - el->el_terminal.t_loc;
		(void) strlcpy(*str = &el->el_terminal.t_buf[
		    el->el_terminal.t_loc], cap, tlen);
		el->el_terminal.t_loc += (int)clen + 1;	/* one for \0 */
		return;
	}
	/*
         * Compact our buffer; no need to check compaction, cause we know it
         * fits...
         */
	tlen = 0;
	for (tmp = tlist; tmp < &tlist[T_str]; tmp++)
		if (*tmp != NULL && **tmp != '\0' && *tmp != *str) {
			char *ptr;

			for (ptr = *tmp; *ptr != '\0'; termbuf[tlen++] = *ptr++)
				continue;
			termbuf[tlen++] = '\0';
		}
	memcpy(el->el_terminal.t_buf, termbuf, TC_BUFSIZE);
	el->el_terminal.t_loc = (int)tlen;
	if (el->el_terminal.t_loc + 3 >= TC_BUFSIZE) {
		(void) fprintf(el->el_errfile,
		    "Out of termcap string space.\n");
		return;
	}
	tlen = TC_BUFSIZE - el->el_terminal.t_loc;
	(void) strlcpy(*str = &el->el_terminal.t_buf[el->el_terminal.t_loc],
	    cap, tlen);
	el->el_terminal.t_loc += (int)clen + 1;	/* one for \0 */
	return;
}


/* terminal_rebuffer_display():
 *	Rebuffer the display after the screen changed size
 */
static int
terminal_rebuffer_display(EditLine *el)
{
	coord_t *c = &el->el_terminal.t_size;

	terminal_free_display(el);

	c->h = Val(T_co);
	c->v = Val(T_li);

	if (terminal_alloc_display(el) == -1)
		return -1;
	return 0;
}


/* terminal_alloc_display():
 *	Allocate a new display.
 */
static int
terminal_alloc_display(EditLine *el)
{
	int i;
	wchar_t **b;
	coord_t *c = &el->el_terminal.t_size;

	b = reallocarray(NULL, c->v + 1, sizeof(*b));
	if (b == NULL)
		goto done;
	for (i = 0; i < c->v; i++) {
		b[i] = reallocarray(NULL, c->h + 1, sizeof(**b));
		if (b[i] == NULL) {
			while (--i >= 0)
				free(b[i]);
			free(b);
			goto done;
		}
	}
	b[c->v] = NULL;
	el->el_display = b;

	b = reallocarray(NULL, c->v + 1, sizeof(*b));
	if (b == NULL)
		goto done;
	for (i = 0; i < c->v; i++) {
		b[i] = reallocarray(NULL, c->h + 1, sizeof(**b));
		if (b[i] == NULL) {
			while (--i >= 0)
				free(b[i]);
			free(b);
			goto done;
		}
	}
	b[c->v] = NULL;
	el->el_vdisplay = b;
	return 0;
done:
	terminal_free_display(el);
	return -1;
}


/* terminal_free_display():
 *	Free the display buffers
 */
static void
terminal_free_display(EditLine *el)
{
	wchar_t **b;
	wchar_t **bufp;

	b = el->el_display;
	el->el_display = NULL;
	if (b != NULL) {
		for (bufp = b; *bufp != NULL; bufp++)
			free(*bufp);
		free(b);
	}
	b = el->el_vdisplay;
	el->el_vdisplay = NULL;
	if (b != NULL) {
		for (bufp = b; *bufp != NULL; bufp++)
			free(*bufp);
		free(b);
	}
}


/* terminal_move_to_line():
 *	move to line <where> (first line == 0)
 *	as efficiently as possible
 */
protected void
terminal_move_to_line(EditLine *el, int where)
{
	int del;

	if (where == el->el_cursor.v)
		return;

	if (where > el->el_terminal.t_size.v) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "terminal_move_to_line: where is ridiculous: %d\r\n",
		    where);
#endif /* DEBUG_SCREEN */
		return;
	}
	if ((del = where - el->el_cursor.v) > 0) {
		while (del > 0) {
			if (EL_HAS_AUTO_MARGINS &&
			    el->el_display[el->el_cursor.v][0] != '\0') {
                                size_t h = el->el_terminal.t_size.h - 1;
                                for (; h > 0 &&
                                         el->el_display[el->el_cursor.v][h] ==
                                                 MB_FILL_CHAR;
                                         h--)
                                                continue;
				/* move without newline */
				terminal_move_to_char(el, (int)h);
				terminal_overwrite(el, &el->el_display
				    [el->el_cursor.v][el->el_cursor.h],
				    (size_t)(el->el_terminal.t_size.h -
				    el->el_cursor.h));
				/* updates Cursor */
				del--;
			} else {
				if ((del > 1) && GoodStr(T_DO)) {
					terminal_tputs(el, tgoto(Str(T_DO), del,
					    del), del);
					del = 0;
				} else {
					for (; del > 0; del--)
						terminal__putc(el, '\n');
					/* because the \n will become \r\n */
					el->el_cursor.h = 0;
				}
			}
		}
	} else {		/* del < 0 */
		if (GoodStr(T_UP) && (-del > 1 || !GoodStr(T_up)))
			terminal_tputs(el, tgoto(Str(T_UP), -del, -del), -del);
		else {
			if (GoodStr(T_up))
				for (; del < 0; del++)
					terminal_tputs(el, Str(T_up), 1);
		}
	}
	el->el_cursor.v = where;/* now where is here */
}


/* terminal_move_to_char():
 *	Move to the character position specified
 */
protected void
terminal_move_to_char(EditLine *el, int where)
{
	int del, i;

mc_again:
	if (where == el->el_cursor.h)
		return;

	if (where > el->el_terminal.t_size.h) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "terminal_move_to_char: where is riduculous: %d\r\n",
		    where);
#endif /* DEBUG_SCREEN */
		return;
	}
	if (!where) {		/* if where is first column */
		terminal__putc(el, '\r');	/* do a CR */
		el->el_cursor.h = 0;
		return;
	}
	del = where - el->el_cursor.h;

	if ((del < -4 || del > 4) && GoodStr(T_ch))
		/* go there directly */
		terminal_tputs(el, tgoto(Str(T_ch), where, where), where);
	else {
		if (del > 0) {	/* moving forward */
			if ((del > 4) && GoodStr(T_RI))
				terminal_tputs(el, tgoto(Str(T_RI), del, del),
				    del);
			else {
					/* if I can do tabs, use them */
				if (EL_CAN_TAB) {
					if ((el->el_cursor.h & 0370) !=
					    (where & ~0x7)
					    && (el->el_display[
					    el->el_cursor.v][where & 0370] !=
					    MB_FILL_CHAR)
					    ) {
						/* if not within tab stop */
						for (i =
						    (el->el_cursor.h & 0370);
						    i < (where & ~0x7);
						    i += 8)
							terminal__putc(el,
							    '\t');
							/* then tab over */
						el->el_cursor.h = where & ~0x7;
					}
				}
				/*
				 * it's usually cheaper to just write the
				 * chars, so we do.
				 */
				/*
				 * NOTE THAT terminal_overwrite() WILL CHANGE
				 * el->el_cursor.h!!!
				 */
				terminal_overwrite(el, &el->el_display[
				    el->el_cursor.v][el->el_cursor.h],
				    (size_t)(where - el->el_cursor.h));

			}
		} else {	/* del < 0 := moving backward */
			if ((-del > 4) && GoodStr(T_LE))
				terminal_tputs(el, tgoto(Str(T_LE), -del, -del),
				    -del);
			else {	/* can't go directly there */
				/*
				 * if the "cost" is greater than the "cost"
				 * from col 0
				 */
				if (EL_CAN_TAB ?
				    ((unsigned int)-del >
				    (((unsigned int) where >> 3) +
				     (where & 07)))
				    : (-del > where)) {
					terminal__putc(el, '\r');/* do a CR */
					el->el_cursor.h = 0;
					goto mc_again;	/* and try again */
				}
				for (i = 0; i < -del; i++)
					terminal__putc(el, '\b');
			}
		}
	}
	el->el_cursor.h = where;		/* now where is here */
}


/* terminal_overwrite():
 *	Overstrike num characters
 *	Assumes MB_FILL_CHARs are present to keep the column count correct
 */
protected void
terminal_overwrite(EditLine *el, const wchar_t *cp, size_t n)
{
	if (n == 0)
		return;

	if (n > (size_t)el->el_terminal.t_size.h) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "terminal_overwrite: n is riduculous: %zu\r\n", n);
#endif /* DEBUG_SCREEN */
		return;
	}

        do {
                /* terminal__putc() ignores any MB_FILL_CHARs */
                terminal__putc(el, *cp++);
                el->el_cursor.h++;
        } while (--n);

	if (el->el_cursor.h >= el->el_terminal.t_size.h) {	/* wrap? */
		if (EL_HAS_AUTO_MARGINS) {	/* yes */
			el->el_cursor.h = 0;
			el->el_cursor.v++;
			if (EL_HAS_MAGIC_MARGINS) {
				/* force the wrap to avoid the "magic"
				 * situation */
				wchar_t c;
				if ((c = el->el_display[el->el_cursor.v]
				    [el->el_cursor.h]) != '\0') {
					terminal_overwrite(el, &c, 1);
					while (el->el_display[el->el_cursor.v]
					    [el->el_cursor.h] == MB_FILL_CHAR)
						el->el_cursor.h++;
				} else {
					terminal__putc(el, ' ');
					el->el_cursor.h = 1;
				}
			}
		} else		/* no wrap, but cursor stays on screen */
			el->el_cursor.h = el->el_terminal.t_size.h - 1;
	}
}


/* terminal_deletechars():
 *	Delete num characters
 */
protected void
terminal_deletechars(EditLine *el, int num)
{
	if (num <= 0)
		return;

	if (!EL_CAN_DELETE) {
#ifdef DEBUG_EDIT
		(void) fprintf(el->el_errfile, "   ERROR: cannot delete   \n");
#endif /* DEBUG_EDIT */
		return;
	}
	if (num > el->el_terminal.t_size.h) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "terminal_deletechars: num is riduculous: %d\r\n", num);
#endif /* DEBUG_SCREEN */
		return;
	}
	if (GoodStr(T_DC))	/* if I have multiple delete */
		if ((num > 1) || !GoodStr(T_dc)) {	/* if dc would be more
							 * expen. */
			terminal_tputs(el, tgoto(Str(T_DC), num, num), num);
			return;
		}
	if (GoodStr(T_dm))	/* if I have delete mode */
		terminal_tputs(el, Str(T_dm), 1);

	if (GoodStr(T_dc))	/* else do one at a time */
		while (num--)
			terminal_tputs(el, Str(T_dc), 1);

	if (GoodStr(T_ed))	/* if I have delete mode */
		terminal_tputs(el, Str(T_ed), 1);
}


/* terminal_insertwrite():
 *	Puts terminal in insert character mode or inserts num
 *	characters in the line
 *      Assumes MB_FILL_CHARs are present to keep column count correct
 */
protected void
terminal_insertwrite(EditLine *el, wchar_t *cp, int num)
{
	if (num <= 0)
		return;
	if (!EL_CAN_INSERT) {
#ifdef DEBUG_EDIT
		(void) fprintf(el->el_errfile, "   ERROR: cannot insert   \n");
#endif /* DEBUG_EDIT */
		return;
	}
	if (num > el->el_terminal.t_size.h) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "StartInsert: num is riduculous: %d\r\n", num);
#endif /* DEBUG_SCREEN */
		return;
	}
	if (GoodStr(T_IC))	/* if I have multiple insert */
		if ((num > 1) || !GoodStr(T_ic)) {
				/* if ic would be more expensive */
			terminal_tputs(el, tgoto(Str(T_IC), num, num), num);
			terminal_overwrite(el, cp, (size_t)num);
				/* this updates el_cursor.h */
			return;
		}
	if (GoodStr(T_im) && GoodStr(T_ei)) {	/* if I have insert mode */
		terminal_tputs(el, Str(T_im), 1);

		el->el_cursor.h += num;
		do
			terminal__putc(el, *cp++);
		while (--num);

		if (GoodStr(T_ip))	/* have to make num chars insert */
			terminal_tputs(el, Str(T_ip), 1);

		terminal_tputs(el, Str(T_ei), 1);
		return;
	}
	do {
		if (GoodStr(T_ic))	/* have to make num chars insert */
			terminal_tputs(el, Str(T_ic), 1);

		terminal__putc(el, *cp++);

		el->el_cursor.h++;

		if (GoodStr(T_ip))	/* have to make num chars insert */
			terminal_tputs(el, Str(T_ip), 1);
					/* pad the inserted char */

	} while (--num);
}


/* terminal_clear_EOL():
 *	clear to end of line.  There are num characters to clear
 */
protected void
terminal_clear_EOL(EditLine *el, int num)
{
	int i;

	if (EL_CAN_CEOL && GoodStr(T_ce))
		terminal_tputs(el, Str(T_ce), 1);
	else {
		for (i = 0; i < num; i++)
			terminal__putc(el, ' ');
		el->el_cursor.h += num;	/* have written num spaces */
	}
}


/* terminal_clear_screen():
 *	Clear the screen
 */
protected void
terminal_clear_screen(EditLine *el)
{				/* clear the whole screen and home */

	if (GoodStr(T_cl))
		/* send the clear screen code */
		terminal_tputs(el, Str(T_cl), Val(T_li));
	else if (GoodStr(T_ho) && GoodStr(T_cd)) {
		terminal_tputs(el, Str(T_ho), Val(T_li));	/* home */
		/* clear to bottom of screen */
		terminal_tputs(el, Str(T_cd), Val(T_li));
	} else {
		terminal__putc(el, '\r');
		terminal__putc(el, '\n');
	}
}


/* terminal_beep():
 *	Beep the way the terminal wants us
 */
protected void
terminal_beep(EditLine *el)
{
	if (GoodStr(T_bl))
		/* what termcap says we should use */
		terminal_tputs(el, Str(T_bl), 1);
	else
		terminal__putc(el, '\007');	/* an ASCII bell; ^G */
}


protected void
terminal_get(EditLine *el, const char **term)
{
	*term = el->el_terminal.t_name;
}


/* terminal_set():
 *	Read in the terminal capabilities from the requested terminal
 */
protected int
terminal_set(EditLine *el, const char *term)
{
	int i;
	char buf[TC_BUFSIZE];
	char *area;
	const struct termcapstr *t;
	sigset_t oset, nset;
	int lins, cols;

	(void) sigemptyset(&nset);
	(void) sigaddset(&nset, SIGWINCH);
	(void) sigprocmask(SIG_BLOCK, &nset, &oset);

	area = buf;


	if (term == NULL)
		term = getenv("TERM");

	if (!term || !term[0])
		term = "dumb";

	if (strcmp(term, "emacs") == 0)
		el->el_flags |= EDIT_DISABLED;

	(void) memset(el->el_terminal.t_cap, 0, TC_BUFSIZE);

	i = tgetent(el->el_terminal.t_cap, term);

	if (i <= 0) {
		if (i == -1)
			(void) fprintf(el->el_errfile,
			    "Cannot read termcap database;\n");
		else if (i == 0)
			(void) fprintf(el->el_errfile,
			    "No entry for terminal type \"%s\";\n", term);
		(void) fprintf(el->el_errfile,
		    "using dumb terminal settings.\n");
		Val(T_co) = 80;	/* do a dumb terminal */
		Val(T_pt) = Val(T_km) = Val(T_li) = 0;
		Val(T_xt) = Val(T_MT);
		for (t = tstr; t->name != NULL; t++)
			terminal_alloc(el, t, NULL);
	} else {
		/* auto/magic margins */
		Val(T_am) = tgetflag("am");
		Val(T_xn) = tgetflag("xn");
		/* Can we tab */
		Val(T_pt) = tgetflag("pt");
		Val(T_xt) = tgetflag("xt");
		/* do we have a meta? */
		Val(T_km) = tgetflag("km");
		Val(T_MT) = tgetflag("MT");
		/* Get the size */
		Val(T_co) = tgetnum("co");
		Val(T_li) = tgetnum("li");
		for (t = tstr; t->name != NULL; t++) {
			/* XXX: some systems' tgetstr needs non const */
			terminal_alloc(el, t, tgetstr(strchr(t->name, *t->name),
			    &area));
		}
	}

	if (Val(T_co) < 2)
		Val(T_co) = 80;	/* just in case */
	if (Val(T_li) < 1)
		Val(T_li) = 24;

	el->el_terminal.t_size.v = Val(T_co);
	el->el_terminal.t_size.h = Val(T_li);

	terminal_setflags(el);

				/* get the correct window size */
	(void) terminal_get_size(el, &lins, &cols);
	if (terminal_change_size(el, lins, cols) == -1)
		return -1;
	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
	terminal_bind_arrow(el);
	el->el_terminal.t_name = term;
	return i <= 0 ? -1 : 0;
}


/* terminal_get_size():
 *	Return the new window size in lines and cols, and
 *	true if the size was changed.
 */
protected int
terminal_get_size(EditLine *el, int *lins, int *cols)
{

	*cols = Val(T_co);
	*lins = Val(T_li);

#ifdef TIOCGWINSZ
	{
		struct winsize ws;
		if (ioctl(el->el_infd, TIOCGWINSZ, &ws) != -1) {
			if (ws.ws_col)
				*cols = ws.ws_col;
			if (ws.ws_row)
				*lins = ws.ws_row;
		}
	}
#endif
#ifdef TIOCGSIZE
	{
		struct ttysize ts;
		if (ioctl(el->el_infd, TIOCGSIZE, &ts) != -1) {
			if (ts.ts_cols)
				*cols = ts.ts_cols;
			if (ts.ts_lines)
				*lins = ts.ts_lines;
		}
	}
#endif
	return Val(T_co) != *cols || Val(T_li) != *lins;
}


/* terminal_change_size():
 *	Change the size of the terminal
 */
protected int
terminal_change_size(EditLine *el, int lins, int cols)
{
	/*
         * Just in case
         */
	Val(T_co) = (cols < 2) ? 80 : cols;
	Val(T_li) = (lins < 1) ? 24 : lins;

	/* re-make display buffers */
	if (terminal_rebuffer_display(el) == -1)
		return -1;
	re_clear_display(el);
	return 0;
}


/* terminal_init_arrow():
 *	Initialize the arrow key bindings from termcap
 */
static void
terminal_init_arrow(EditLine *el)
{
	funckey_t *arrow = el->el_terminal.t_fkey;

	arrow[A_K_DN].name = L"down";
	arrow[A_K_DN].key = T_kd;
	arrow[A_K_DN].fun.cmd = ED_NEXT_HISTORY;
	arrow[A_K_DN].type = XK_CMD;

	arrow[A_K_UP].name = L"up";
	arrow[A_K_UP].key = T_ku;
	arrow[A_K_UP].fun.cmd = ED_PREV_HISTORY;
	arrow[A_K_UP].type = XK_CMD;

	arrow[A_K_LT].name = L"left";
	arrow[A_K_LT].key = T_kl;
	arrow[A_K_LT].fun.cmd = ED_PREV_CHAR;
	arrow[A_K_LT].type = XK_CMD;

	arrow[A_K_RT].name = L"right";
	arrow[A_K_RT].key = T_kr;
	arrow[A_K_RT].fun.cmd = ED_NEXT_CHAR;
	arrow[A_K_RT].type = XK_CMD;

	arrow[A_K_HO].name = L"home";
	arrow[A_K_HO].key = T_kh;
	arrow[A_K_HO].fun.cmd = ED_MOVE_TO_BEG;
	arrow[A_K_HO].type = XK_CMD;

	arrow[A_K_EN].name = L"end";
	arrow[A_K_EN].key = T_at7;
	arrow[A_K_EN].fun.cmd = ED_MOVE_TO_END;
	arrow[A_K_EN].type = XK_CMD;
}


/* terminal_reset_arrow():
 *	Reset arrow key bindings
 */
static void
terminal_reset_arrow(EditLine *el)
{
	funckey_t *arrow = el->el_terminal.t_fkey;
	static const wchar_t strA[] = L"\033[A";
	static const wchar_t strB[] = L"\033[B";
	static const wchar_t strC[] = L"\033[C";
	static const wchar_t strD[] = L"\033[D";
	static const wchar_t strH[] = L"\033[H";
	static const wchar_t strF[] = L"\033[F";
	static const wchar_t stOA[] = L"\033OA";
	static const wchar_t stOB[] = L"\033OB";
	static const wchar_t stOC[] = L"\033OC";
	static const wchar_t stOD[] = L"\033OD";
	static const wchar_t stOH[] = L"\033OH";
	static const wchar_t stOF[] = L"\033OF";

	keymacro_add(el, strA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	keymacro_add(el, strB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	keymacro_add(el, strC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	keymacro_add(el, strD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
	keymacro_add(el, strH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
	keymacro_add(el, strF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);
	keymacro_add(el, stOA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	keymacro_add(el, stOB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	keymacro_add(el, stOC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	keymacro_add(el, stOD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
	keymacro_add(el, stOH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
	keymacro_add(el, stOF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);

	if (el->el_map.type != MAP_VI)
		return;
	keymacro_add(el, &strA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	keymacro_add(el, &strB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	keymacro_add(el, &strC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	keymacro_add(el, &strD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
	keymacro_add(el, &strH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
	keymacro_add(el, &strF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
	keymacro_add(el, &stOA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	keymacro_add(el, &stOB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	keymacro_add(el, &stOC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	keymacro_add(el, &stOD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
	keymacro_add(el, &stOH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
	keymacro_add(el, &stOF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
}


/* terminal_set_arrow():
 *	Set an arrow key binding
 */
protected int
terminal_set_arrow(EditLine *el, const wchar_t *name, keymacro_value_t *fun,
    int type)
{
	funckey_t *arrow = el->el_terminal.t_fkey;
	int i;

	for (i = 0; i < A_K_NKEYS; i++)
		if (wcscmp(name, arrow[i].name) == 0) {
			arrow[i].fun = *fun;
			arrow[i].type = type;
			return 0;
		}
	return -1;
}


/* terminal_clear_arrow():
 *	Clear an arrow key binding
 */
protected int
terminal_clear_arrow(EditLine *el, const wchar_t *name)
{
	funckey_t *arrow = el->el_terminal.t_fkey;
	int i;

	for (i = 0; i < A_K_NKEYS; i++)
		if (wcscmp(name, arrow[i].name) == 0) {
			arrow[i].type = XK_NOD;
			return 0;
		}
	return -1;
}


/* terminal_print_arrow():
 *	Print the arrow key bindings
 */
protected void
terminal_print_arrow(EditLine *el, const wchar_t *name)
{
	int i;
	funckey_t *arrow = el->el_terminal.t_fkey;

	for (i = 0; i < A_K_NKEYS; i++)
		if (*name == '\0' || wcscmp(name, arrow[i].name) == 0)
			if (arrow[i].type != XK_NOD)
				keymacro_kprint(el, arrow[i].name,
				    &arrow[i].fun, arrow[i].type);
}


/* terminal_bind_arrow():
 *	Bind the arrow keys
 */
protected void
terminal_bind_arrow(EditLine *el)
{
	el_action_t *map;
	const el_action_t *dmap;
	int i, j;
	char *p;
	funckey_t *arrow = el->el_terminal.t_fkey;

	/* Check if the components needed are initialized */
	if (el->el_terminal.t_buf == NULL || el->el_map.key == NULL)
		return;

	map = el->el_map.type == MAP_VI ? el->el_map.alt : el->el_map.key;
	dmap = el->el_map.type == MAP_VI ? el->el_map.vic : el->el_map.emacs;

	terminal_reset_arrow(el);

	for (i = 0; i < A_K_NKEYS; i++) {
		wchar_t wt_str[VISUAL_WIDTH_MAX];
		wchar_t *px;
		size_t n;

		p = el->el_terminal.t_str[arrow[i].key];
		if (!p || !*p)
			continue;
		for (n = 0; n < VISUAL_WIDTH_MAX && p[n]; ++n)
			wt_str[n] = p[n];
		while (n < VISUAL_WIDTH_MAX)
			wt_str[n++] = '\0';
		px = wt_str;
		j = (unsigned char) *p;
		/*
		 * Assign the arrow keys only if:
		 *
		 * 1. They are multi-character arrow keys and the user
		 *    has not re-assigned the leading character, or
		 *    has re-assigned the leading character to be
		 *	  ED_SEQUENCE_LEAD_IN
		 * 2. They are single arrow keys pointing to an
		 *    unassigned key.
		 */
		if (arrow[i].type == XK_NOD)
			keymacro_clear(el, map, px);
		else {
			if (p[1] && (dmap[j] == map[j] ||
				map[j] == ED_SEQUENCE_LEAD_IN)) {
				keymacro_add(el, px, &arrow[i].fun,
				    arrow[i].type);
				map[j] = ED_SEQUENCE_LEAD_IN;
			} else if (map[j] == ED_UNASSIGNED) {
				keymacro_clear(el, map, px);
				if (arrow[i].type == XK_CMD)
					map[j] = arrow[i].fun.cmd;
				else
					keymacro_add(el, px, &arrow[i].fun,
					    arrow[i].type);
			}
		}
	}
}

/* terminal_putc():
 *	Add a character
 */
static int
terminal_putc(int c)
{
	if (terminal_outfile == NULL)
		return -1;
	return fputc(c, terminal_outfile);
}

static void
terminal_tputs(EditLine *el, const char *cap, int affcnt)
{
#ifdef _REENTRANT
	pthread_mutex_lock(&terminal_mutex);
#endif
	terminal_outfile = el->el_outfile;
	(void)tputs(cap, affcnt, terminal_putc);
#ifdef _REENTRANT
	pthread_mutex_unlock(&terminal_mutex);
#endif
}

/* terminal__putc():
 *	Add a character
 */
protected int
terminal__putc(EditLine *el, wint_t c)
{
	char buf[MB_LEN_MAX +1];
	ssize_t i;
	if (c == (wint_t)MB_FILL_CHAR)
		return 0;
	i = ct_encode_char(buf, MB_LEN_MAX, c);
	if (i <= 0)
		return (int)i;
	buf[i] = '\0';
	return fputs(buf, el->el_outfile);
}

/* terminal__flush():
 *	Flush output
 */
protected void
terminal__flush(EditLine *el)
{

	(void) fflush(el->el_outfile);
}

/* terminal_writec():
 *	Write the given character out, in a human readable form
 */
protected void
terminal_writec(EditLine *el, wint_t c)
{
	wchar_t visbuf[VISUAL_WIDTH_MAX +1];
	ssize_t vcnt = ct_visual_char(visbuf, VISUAL_WIDTH_MAX, c);
	visbuf[vcnt] = '\0';
	terminal_overwrite(el, visbuf, (size_t)vcnt);
	terminal__flush(el);
}


/* terminal_telltc():
 *	Print the current termcap characteristics
 */
protected int
/*ARGSUSED*/
terminal_telltc(EditLine *el, int argc __attribute__((__unused__)),
    const wchar_t **argv __attribute__((__unused__)))
{
	const struct termcapstr *t;
	char **ts;

	(void) fprintf(el->el_outfile, "\n\tYour terminal has the\n");
	(void) fprintf(el->el_outfile, "\tfollowing characteristics:\n\n");
	(void) fprintf(el->el_outfile, "\tIt has %d columns and %d lines\n",
	    Val(T_co), Val(T_li));
	(void) fprintf(el->el_outfile,
	    "\tIt has %s meta key\n", EL_HAS_META ? "a" : "no");
	(void) fprintf(el->el_outfile,
	    "\tIt can%suse tabs\n", EL_CAN_TAB ? " " : "not ");
	(void) fprintf(el->el_outfile, "\tIt %s automatic margins\n",
	    EL_HAS_AUTO_MARGINS ? "has" : "does not have");
	if (EL_HAS_AUTO_MARGINS)
		(void) fprintf(el->el_outfile, "\tIt %s magic margins\n",
		    EL_HAS_MAGIC_MARGINS ? "has" : "does not have");

	for (t = tstr, ts = el->el_terminal.t_str; t->name != NULL; t++, ts++) {
		const char *ub;
		if (*ts && **ts) {
			ub = ct_encode_string(ct_visual_string(
			    ct_decode_string(*ts, &el->el_scratch)),
			    &el->el_scratch);
		} else {
			ub = "(empty)";
		}
		(void) fprintf(el->el_outfile, "\t%25s (%s) == %s\n",
		    t->long_name, t->name, ub);
	}
	(void) fputc('\n', el->el_outfile);
	return 0;
}


/* terminal_settc():
 *	Change the current terminal characteristics
 */
protected int
/*ARGSUSED*/
terminal_settc(EditLine *el, int argc __attribute__((__unused__)),
    const wchar_t **argv)
{
	const struct termcapstr *ts;
	const struct termcapval *tv;
	char what[8], how[8];

	if (argv == NULL || argv[1] == NULL || argv[2] == NULL)
		return -1;

	strncpy(what, ct_encode_string(argv[1], &el->el_scratch), sizeof(what));
	what[sizeof(what) - 1] = '\0';
	strncpy(how,  ct_encode_string(argv[2], &el->el_scratch), sizeof(how));
	how[sizeof(how) - 1] = '\0';

	/*
         * Do the strings first
         */
	for (ts = tstr; ts->name != NULL; ts++)
		if (strcmp(ts->name, what) == 0)
			break;

	if (ts->name != NULL) {
		terminal_alloc(el, ts, how);
		terminal_setflags(el);
		return 0;
	}
	/*
         * Do the numeric ones second
         */
	for (tv = tval; tv->name != NULL; tv++)
		if (strcmp(tv->name, what) == 0)
			break;

	if (tv->name != NULL)
		return -1;

	if (tv == &tval[T_pt] || tv == &tval[T_km] ||
	    tv == &tval[T_am] || tv == &tval[T_xn]) {
		if (strcmp(how, "yes") == 0)
			el->el_terminal.t_val[tv - tval] = 1;
		else if (strcmp(how, "no") == 0)
			el->el_terminal.t_val[tv - tval] = 0;
		else {
			(void) fprintf(el->el_errfile,
			    "%ls: Bad value `%s'.\n", argv[0], how);
			return -1;
		}
		terminal_setflags(el);
		if (terminal_change_size(el, Val(T_li), Val(T_co)) == -1)
			return -1;
		return 0;
	} else {
		long i;
		char *ep;

		i = strtol(how, &ep, 10);
		if (*ep != '\0') {
			(void) fprintf(el->el_errfile,
			    "%ls: Bad value `%s'.\n", argv[0], how);
			return -1;
		}
		el->el_terminal.t_val[tv - tval] = (int) i;
		el->el_terminal.t_size.v = Val(T_co);
		el->el_terminal.t_size.h = Val(T_li);
		if (tv == &tval[T_co] || tv == &tval[T_li])
			if (terminal_change_size(el, Val(T_li), Val(T_co))
			    == -1)
				return -1;
		return 0;
	}
}


/* terminal_gettc():
 *	Get the current terminal characteristics
 */
protected int
/*ARGSUSED*/
terminal_gettc(EditLine *el, int argc __attribute__((__unused__)), char **argv)
{
	const struct termcapstr *ts;
	const struct termcapval *tv;
	char *what;
	void *how;

	if (argv == NULL || argv[1] == NULL || argv[2] == NULL)
		return -1;

	what = argv[1];
	how = argv[2];

	/*
         * Do the strings first
         */
	for (ts = tstr; ts->name != NULL; ts++)
		if (strcmp(ts->name, what) == 0)
			break;

	if (ts->name != NULL) {
		*(char **)how = el->el_terminal.t_str[ts - tstr];
		return 0;
	}
	/*
         * Do the numeric ones second
         */
	for (tv = tval; tv->name != NULL; tv++)
		if (strcmp(tv->name, what) == 0)
			break;

	if (tv->name == NULL)
		return -1;

	if (tv == &tval[T_pt] || tv == &tval[T_km] ||
	    tv == &tval[T_am] || tv == &tval[T_xn]) {
		static char yes[] = "yes";
		static char no[] = "no";
		if (el->el_terminal.t_val[tv - tval])
			*(char **)how = yes;
		else
			*(char **)how = no;
		return 0;
	} else {
		*(int *)how = el->el_terminal.t_val[tv - tval];
		return 0;
	}
}

/* terminal_echotc():
 *	Print the termcap string out with variable substitution
 */
protected int
/*ARGSUSED*/
terminal_echotc(EditLine *el, int argc __attribute__((__unused__)),
    const wchar_t **argv)
{
	char *cap, *scap;
	wchar_t *ep;
	int arg_need, arg_cols, arg_rows;
	int verbose = 0, silent = 0;
	char *area;
	static const char fmts[] = "%s\n", fmtd[] = "%d\n";
	const struct termcapstr *t;
	char buf[TC_BUFSIZE];
	long i;

	area = buf;

	if (argv == NULL || argv[1] == NULL)
		return -1;
	argv++;

	if (argv[0][0] == '-') {
		switch (argv[0][1]) {
		case 'v':
			verbose = 1;
			break;
		case 's':
			silent = 1;
			break;
		default:
			/* stderror(ERR_NAME | ERR_TCUSAGE); */
			break;
		}
		argv++;
	}
	if (!*argv || *argv[0] == '\0')
		return 0;
	if (wcscmp(*argv, L"tabs") == 0) {
		(void) fprintf(el->el_outfile, fmts, EL_CAN_TAB ? "yes" : "no");
		return 0;
	} else if (wcscmp(*argv, L"meta") == 0) {
		(void) fprintf(el->el_outfile, fmts, Val(T_km) ? "yes" : "no");
		return 0;
	} else if (wcscmp(*argv, L"xn") == 0) {
		(void) fprintf(el->el_outfile, fmts, EL_HAS_MAGIC_MARGINS ?
		    "yes" : "no");
		return 0;
	} else if (wcscmp(*argv, L"am") == 0) {
		(void) fprintf(el->el_outfile, fmts, EL_HAS_AUTO_MARGINS ?
		    "yes" : "no");
		return 0;
	} else if (wcscmp(*argv, L"baud") == 0) {
		(void) fprintf(el->el_outfile, fmtd, (int)el->el_tty.t_speed);
		return 0;
	} else if (wcscmp(*argv, L"rows") == 0 ||
                   wcscmp(*argv, L"lines") == 0) {
		(void) fprintf(el->el_outfile, fmtd, Val(T_li));
		return 0;
	} else if (wcscmp(*argv, L"cols") == 0) {
		(void) fprintf(el->el_outfile, fmtd, Val(T_co));
		return 0;
	}
	/*
         * Try to use our local definition first
         */
	scap = NULL;
	for (t = tstr; t->name != NULL; t++)
		if (strcmp(t->name,
		    ct_encode_string(*argv, &el->el_scratch)) == 0) {
			scap = el->el_terminal.t_str[t - tstr];
			break;
		}
	if (t->name == NULL) {
		/* XXX: some systems' tgetstr needs non const */
                scap = tgetstr(ct_encode_string(*argv, &el->el_scratch), &area);
	}
	if (!scap || scap[0] == '\0') {
		if (!silent)
			(void) fprintf(el->el_errfile,
			    "echotc: Termcap parameter `%ls' not found.\n",
			    *argv);
		return -1;
	}
	/*
         * Count home many values we need for this capability.
         */
	for (cap = scap, arg_need = 0; *cap; cap++)
		if (*cap == '%')
			switch (*++cap) {
			case 'd':
			case '2':
			case '3':
			case '.':
			case '+':
				arg_need++;
				break;
			case '%':
			case '>':
			case 'i':
			case 'r':
			case 'n':
			case 'B':
			case 'D':
				break;
			default:
				/*
				 * hpux has lot's of them...
				 */
				if (verbose)
					(void) fprintf(el->el_errfile,
				"echotc: Warning: unknown termcap %% `%c'.\n",
					    *cap);
				/* This is bad, but I won't complain */
				break;
			}

	switch (arg_need) {
	case 0:
		argv++;
		if (*argv && *argv[0]) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Extra argument `%ls'.\n",
				    *argv);
			return -1;
		}
		terminal_tputs(el, scap, 1);
		break;
	case 1:
		argv++;
		if (!*argv || *argv[0] == '\0') {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Missing argument.\n");
			return -1;
		}
		arg_cols = 0;
		i = wcstol(*argv, &ep, 10);
		if (*ep != '\0' || i < 0) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Bad value `%ls' for rows.\n",
				    *argv);
			return -1;
		}
		arg_rows = (int) i;
		argv++;
		if (*argv && *argv[0]) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Extra argument `%ls"
				    "'.\n", *argv);
			return -1;
		}
		terminal_tputs(el, tgoto(scap, arg_cols, arg_rows), 1);
		break;
	default:
		/* This is wrong, but I will ignore it... */
		if (verbose)
			(void) fprintf(el->el_errfile,
			 "echotc: Warning: Too many required arguments (%d).\n",
			    arg_need);
		/* FALLTHROUGH */
	case 2:
		argv++;
		if (!*argv || *argv[0] == '\0') {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Missing argument.\n");
			return -1;
		}
		i = wcstol(*argv, &ep, 10);
		if (*ep != '\0' || i < 0) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Bad value `%ls' for cols.\n",
				    *argv);
			return -1;
		}
		arg_cols = (int) i;
		argv++;
		if (!*argv || *argv[0] == '\0') {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Missing argument.\n");
			return -1;
		}
		i = wcstol(*argv, &ep, 10);
		if (*ep != '\0' || i < 0) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Bad value `%ls' for rows.\n",
				    *argv);
			return -1;
		}
		arg_rows = (int) i;
		if (*ep != '\0') {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Bad value `%ls'.\n", *argv);
			return -1;
		}
		argv++;
		if (*argv && *argv[0]) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Extra argument `%ls"
				    "'.\n", *argv);
			return -1;
		}
		terminal_tputs(el, tgoto(scap, arg_cols, arg_rows), arg_rows);
		break;
	}
	return 0;
}
@


1.16
log
@delete the "private" and "public" preprocessor macros, just use standard C;
OK martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.15 2016/04/11 20:43:33 schwarze Exp $	*/
d70 1
@


1.15
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.14 2016/04/11 19:54:54 schwarze Exp $	*/
d85 1
a85 1
private const struct termcapstr {
d169 1
a169 1
private const struct termcapval {
d194 5
a198 5
private void	terminal_setflags(EditLine *);
private int	terminal_rebuffer_display(EditLine *);
private void	terminal_free_display(EditLine *);
private int	terminal_alloc_display(EditLine *);
private void	terminal_alloc(EditLine *, const struct termcapstr *,
d200 4
a203 4
private void	terminal_init_arrow(EditLine *);
private void	terminal_reset_arrow(EditLine *);
private int	terminal_putc(int);
private void	terminal_tputs(EditLine *, const char *, int);
d206 1
a206 1
private pthread_mutex_t terminal_mutex = PTHREAD_MUTEX_INITIALIZER;
d208 1
a208 1
private FILE *terminal_outfile = NULL;
d214 1
a214 1
private void
d326 1
a326 1
private void
d391 1
a391 1
private int
d410 1
a410 1
private int
d456 1
a456 1
private void
d996 1
a996 1
private void
d1036 1
a1036 1
private void
d1206 1
a1206 1
private int
d1214 1
a1214 1
private void
@


1.14
log
@Move wrapper macros to the two files actually needing them:
FUNW, Strlen, Strdup, Strcmp, Strncmp, Strncpy, Strncat -> history.c
Strchr, tok_strdup -> tokenizer.c
FUN, TYPE, STR -> both of these files

OK martijn@@

Also proofread by Christian Heckendorf <mbie at ulmus dot me>
who reported some whitespace issues in parse.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.13 2016/04/09 20:15:26 schwarze Exp $	*/
d414 1
a414 1
	Char **b;
d459 2
a460 2
	Char **b;
	Char **bufp;
d643 1
a643 1
terminal_overwrite(EditLine *el, const Char *cp, size_t n)
d669 1
a669 1
				Char c;
d733 1
a733 1
terminal_insertwrite(EditLine *el, Char *cp, int num)
d1040 12
a1051 12
	static const Char strA[] = {033, '[', 'A', '\0'};
	static const Char strB[] = {033, '[', 'B', '\0'};
	static const Char strC[] = {033, '[', 'C', '\0'};
	static const Char strD[] = {033, '[', 'D', '\0'};
	static const Char strH[] = {033, '[', 'H', '\0'};
	static const Char strF[] = {033, '[', 'F', '\0'};
	static const Char stOA[] = {033, 'O', 'A', '\0'};
	static const Char stOB[] = {033, 'O', 'B', '\0'};
	static const Char stOC[] = {033, 'O', 'C', '\0'};
	static const Char stOD[] = {033, 'O', 'D', '\0'};
	static const Char stOH[] = {033, 'O', 'H', '\0'};
	static const Char stOF[] = {033, 'O', 'F', '\0'};
d1087 1
a1087 1
terminal_set_arrow(EditLine *el, const Char *name, keymacro_value_t *fun,
d1107 1
a1107 1
terminal_clear_arrow(EditLine *el, const Char *name)
d1125 1
a1125 1
terminal_print_arrow(EditLine *el, const Char *name)
d1160 2
a1161 2
		Char wt_str[VISUAL_WIDTH_MAX];
		Char *px;
d1260 1
a1260 1
	Char visbuf[VISUAL_WIDTH_MAX +1];
d1274 1
a1274 1
    const Char **argv __attribute__((__unused__)))
d1316 1
a1316 1
    const Char **argv)
d1449 1
a1449 1
    const Char **argv)
d1452 1
a1452 1
	Char *ep;
@


1.13
log
@Delete 26 wrapper macros and two wrapper functions that are no
longer needed now that we always compile with wide character support,
reducing code obfuscation.

OK czarkoff@@ martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.12 2016/04/09 19:31:55 schwarze Exp $	*/
d1001 1
a1001 1
	arrow[A_K_DN].name = STR("down");
d1006 1
a1006 1
	arrow[A_K_UP].name = STR("up");
d1011 1
a1011 1
	arrow[A_K_LT].name = STR("left");
d1016 1
a1016 1
	arrow[A_K_RT].name = STR("right");
d1021 1
a1021 1
	arrow[A_K_HO].name = STR("home");
d1026 1
a1026 1
	arrow[A_K_EN].name = STR("end");
d1094 1
a1094 1
		if (Strcmp(name, arrow[i].name) == 0) {
d1113 1
a1113 1
		if (Strcmp(name, arrow[i].name) == 0) {
d1131 1
a1131 1
		if (*name == '\0' || Strcmp(name, arrow[i].name) == 0)
d1483 1
a1483 1
	if (Strcmp(*argv, STR("tabs")) == 0) {
d1486 1
a1486 1
	} else if (Strcmp(*argv, STR("meta")) == 0) {
d1489 1
a1489 1
	} else if (Strcmp(*argv, STR("xn")) == 0) {
d1493 1
a1493 1
	} else if (Strcmp(*argv, STR("am")) == 0) {
d1497 1
a1497 1
	} else if (Strcmp(*argv, STR("baud")) == 0) {
d1500 2
a1501 2
	} else if (Strcmp(*argv, STR("rows")) == 0 ||
                   Strcmp(*argv, STR("lines")) == 0) {
d1504 1
a1504 1
	} else if (Strcmp(*argv, STR("cols")) == 0) {
@


1.12
log
@Always compile with WIDECHAR on and delete that preprocessor switch.
OK martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.11 2016/03/22 11:32:18 schwarze Exp $	*/
d1360 1
a1360 1
			    "" FSTR ": Bad value `%s'.\n", argv[0], how);
d1374 1
a1374 1
			    "" FSTR ": Bad value `%s'.\n", argv[0], how);
d1525 1
a1525 1
			    "echotc: Termcap parameter `" FSTR "' not found.\n",
d1568 1
a1568 1
				    "echotc: Warning: Extra argument `" FSTR "'.\n",
d1583 1
a1583 1
		i = Strtol(*argv, &ep, 10);
d1587 1
a1587 1
				    "echotc: Bad value `" FSTR "' for rows.\n",
d1596 2
a1597 2
				    "echotc: Warning: Extra argument `" FSTR "'.\n",
				    *argv);
d1617 1
a1617 1
		i = Strtol(*argv, &ep, 10);
d1621 1
a1621 1
				    "echotc: Bad value `" FSTR "' for cols.\n",
d1633 1
a1633 1
		i = Strtol(*argv, &ep, 10);
d1637 1
a1637 1
				    "echotc: Bad value `" FSTR "' for rows.\n",
d1645 1
a1645 1
				    "echotc: Bad value `" FSTR "'.\n", *argv);
d1652 2
a1653 2
				    "echotc: Warning: Extra argument `" FSTR "'.\n",
				    *argv);
@


1.11
log
@format string fixes in debug code;
committing right away because this code is not even compiled by default
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.10 2016/03/22 11:10:57 schwarze Exp $	*/
a503 1
#ifdef WIDECHAR
a508 1
#endif
a582 1
#ifdef WIDECHAR
a585 1
#endif
a672 1
#ifdef WIDECHAR
a675 1
#endif
@


1.10
log
@Fix an obvious typo in a NUL check;
bug reported by David Binderman
http://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50880
fix suggested by me, NetBSD rev. 1.23 and rev. 1.24.
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.9 2016/03/20 23:48:27 schwarze Exp $	*/
d655 1
a655 1
		    "terminal_overwrite: n is riduculous: %d\r\n", n);
@


1.9
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.8 2016/03/20 21:25:27 schwarze Exp $	*/
d366 1
a366 1
		if (*tmp != NULL && *tmp != '\0' && *tmp != *str) {
@


1.8
log
@minor simplifactions, style fixes, and trivial syncs from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.7 2016/03/20 20:35:38 schwarze Exp $	*/
d43 4
d48 1
a48 1
#include <signal.h>
a49 1
#include <stdlib.h>
a50 1
#include <limits.h>
a63 2
#include <sys/types.h>
#include <sys/ioctl.h>
d481 1
a481 1
 * 	as efficiently as possible
d597 1
a597 1
							    '\t');	
d1279 1
a1279 1
terminal_telltc(EditLine *el, int argc __attribute__((__unused__)), 
@


1.7
log
@Delete the useless Int datatype and always use the standard wint_t
directly.  This is not a problem because <wchar_t> is required all
over the place anyway, even when WIDECHAR is not defined.
No functional change except that it fixes a few printf(3)
format string issues, %c vs. %lc.
OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: terminal.c,v 1.6 2016/01/30 17:32:52 schwarze Exp $	*/
/*	$NetBSD: term.c,v 1.57 2009/12/30 22:37:40 christos Exp $	*/
d265 1
a265 1
		goto fail;
d297 1
a297 1
fail:
d413 1
a413 1
	int i, rv = -1;
d446 1
a446 2

	rv = 0;
d448 2
a449 3
	if (rv)
		terminal_free_display(el);
	return rv;
@


1.6
log
@Fifth step in synching with NetBSD:
Delete the silly ptr_t and ioctl_t typedefs
and delete some "#ifdef notdef" code from "sys.h".
No functional change.
This makes hist.h identical to the NetBSD version.
It reduces the remaining diff from +1526 -734 to +1430 -592.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.5 2016/01/30 12:22:20 schwarze Exp $	*/
d1239 1
a1239 1
terminal__putc(EditLine *el, Int c)
d1243 1
a1243 1
	if (c == MB_FILL_CHAR)
d1266 1
a1266 1
terminal_writec(EditLine *el, Int c)
@


1.5
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.4 2016/01/30 02:52:41 schwarze Exp $	*/
d424 2
a425 2
				free((ptr_t) b[i]);
			free((ptr_t) b);
d439 2
a440 2
				free((ptr_t) b[i]);
			free((ptr_t) b);
d468 2
a469 2
			free((ptr_t) *bufp);
		free((ptr_t) b);
d475 2
a476 2
			free((ptr_t) *bufp);
		free((ptr_t) b);
d958 1
a958 1
		if (ioctl(el->el_infd, TIOCGWINSZ, (ioctl_t) & ws) != -1) {
d969 1
a969 1
		if (ioctl(el->el_infd, TIOCGSIZE, (ioctl_t) & ts) != -1) {
@


1.4
log
@delete "#ifdef notdef" code that is no longer present in NetBSD;
no change in the generated source files
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.3 2016/01/30 00:06:39 schwarze Exp $	*/
d284 1
a284 1
	return (0);
d298 1
a298 1
	return (-1);
d402 2
a403 2
		return (-1);
	return (0);
d451 1
a451 1
	return (rv);
d936 1
a936 1
		return (-1);
d940 1
a940 1
	return (i <= 0 ? -1 : 0);
d977 1
a977 1
	return (Val(T_co) != *cols || Val(T_li) != *lins);
d995 1
a995 1
		return (-1);
d997 1
a997 1
	return (0);
d1105 1
a1105 1
			return (0);
d1107 1
a1107 1
	return (-1);
d1123 1
a1123 1
			return (0);
d1125 1
a1125 1
	return (-1);
d1314 1
a1314 1
	return (0);
d1410 1
a1410 1
		return (-1);
d1472 1
a1472 1
		return (-1);
d1490 1
a1490 1
		return (0);
d1493 1
a1493 1
		return (0);
d1496 1
a1496 1
		return (0);
d1500 1
a1500 1
		return (0);
d1504 1
a1504 1
		return (0);
d1507 1
a1507 1
		return (0);
d1511 1
a1511 1
		return (0);
d1514 1
a1514 1
		return (0);
d1535 1
a1535 1
		return (-1);
d1578 1
a1578 1
			return (-1);
d1588 1
a1588 1
			return (-1);
d1597 1
a1597 1
			return (-1);
d1606 1
a1606 1
			return (-1);
d1623 1
a1623 1
			return (-1);
d1631 1
a1631 1
			return (-1);
d1639 1
a1639 1
			return (-1);
d1647 1
a1647 1
			return (-1);
d1654 1
a1654 1
			return (-1);
d1662 1
a1662 1
			return (-1);
d1667 1
a1667 1
	return (0);
@


1.3
log
@Third step in synching with NetBSD:
* rename fkey_t to funckey_t and el_term_t to el_terminal_t
* rename struct editline member el_term to el_terminal
* rename many functions in terminal.c from term_*() to terminal_*(),
for consistency with the file name and to not look related to <term.h>
No functional change.
This makes refresh.c and sig.c almost identical to the NetBSD versions.
It reduces the remaining diff from +2446 -1805 to +2053 -1420.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.2 2016/01/29 19:32:33 schwarze Exp $	*/
a84 72
#ifdef notdef
private const struct {
	const char *b_name;
	int b_rate;
} baud_rate[] = {
#ifdef B0
	{ "0", B0 },
#endif
#ifdef B50
	{ "50", B50 },
#endif
#ifdef B75
	{ "75", B75 },
#endif
#ifdef B110
	{ "110", B110 },
#endif
#ifdef B134
	{ "134", B134 },
#endif
#ifdef B150
	{ "150", B150 },
#endif
#ifdef B200
	{ "200", B200 },
#endif
#ifdef B300
	{ "300", B300 },
#endif
#ifdef B600
	{ "600", B600 },
#endif
#ifdef B900
	{ "900", B900 },
#endif
#ifdef B1200
	{ "1200", B1200 },
#endif
#ifdef B1800
	{ "1800", B1800 },
#endif
#ifdef B2400
	{ "2400", B2400 },
#endif
#ifdef B3600
	{ "3600", B3600 },
#endif
#ifdef B4800
	{ "4800", B4800 },
#endif
#ifdef B7200
	{ "7200", B7200 },
#endif
#ifdef B9600
	{ "9600", B9600 },
#endif
#ifdef EXTA
	{ "19200", EXTA },
#endif
#ifdef B19200
	{ "19200", B19200 },
#endif
#ifdef EXTB
	{ "38400", EXTB },
#endif
#ifdef B38400
	{ "38400", B38400 },
#endif
	{ NULL, 0 }
};
#endif

a848 14
#ifdef notdef
/* term_clear_to_bottom():
 *	Clear to the bottom of the screen
 */
protected void
term_clear_to_bottom(EditLine *el)
{
	if (GoodStr(T_cd))
		terminal_tputs(el, Str(T_cd), Val(T_li));
	else if (GoodStr(T_ce))
		terminal_tputs(el, Str(T_ce), Val(T_li));
}
#endif

a1505 11
#ifdef notdef
		int i;

		for (i = 0; baud_rate[i].b_name != NULL; i++)
			if (el->el_tty.t_speed == baud_rate[i].b_rate) {
				(void) fprintf(el->el_outfile, fmts,
				    baud_rate[i].b_name);
				return (0);
			}
		(void) fprintf(el->el_outfile, fmtd, 0);
#else
a1506 1
#endif
@


1.2
log
@Second step in synching with NetBSD:
* Rename some types from *key*_t to *keymacro*_t.
* Rename struct editline member el_key to el_keymacro.
* Rename some functions in keymacro.c from key*() to keymacro*().
This removes the conflict of key_clear(), key_end(), and key_print()
with macros in <term.h>.  No functional change.
This makes keymacro.h identical to the NetBSD version.
It reduces the remaining diff from +2640 -1998 to +2446 -1805.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: terminal.c,v 1.1 2016/01/29 17:23:21 schwarze Exp $	*/
d39 3
a41 3
 * term.c: Editor/termcap-curses interface
 *	   We have to declare a static variable here, since the
 *	   termcap putchar routine does not take an argument!
d80 4
a83 4
#define	GoodStr(a)	(el->el_term.t_str[a] != NULL && \
			    el->el_term.t_str[a][0] != '\0')
#define	Str(a)		el->el_term.t_str[a]
#define	Val(a)		el->el_term.t_val[a]
d266 10
a275 9
private void	term_setflags(EditLine *);
private int	term_rebuffer_display(EditLine *);
private void	term_free_display(EditLine *);
private int	term_alloc_display(EditLine *);
private void	term_alloc(EditLine *, const struct termcapstr *, const char *);
private void	term_init_arrow(EditLine *);
private void	term_reset_arrow(EditLine *);
private int	term_putc(int);
private void	term_tputs(EditLine *, const char *, int);
d278 1
a278 1
private pthread_mutex_t term_mutex = PTHREAD_MUTEX_INITIALIZER;
d280 1
a280 1
private FILE *term_outfile = NULL;
d283 1
a283 1
/* term_setflags():
d287 1
a287 1
term_setflags(EditLine *el)
d328 1
a328 1
/* term_init():
d332 1
a332 1
term_init(EditLine *el)
d335 2
a336 2
	el->el_term.t_buf = (char *)malloc(TC_BUFSIZE);
	if (el->el_term.t_buf == NULL)
d338 2
a339 2
	el->el_term.t_cap = (char *)malloc(TC_BUFSIZE);
	if (el->el_term.t_cap == NULL)
d341 3
a343 2
	el->el_term.t_fkey = reallocarray(NULL, A_K_NKEYS, sizeof(fkey_t));
	if (el->el_term.t_fkey == NULL)
d345 3
a347 3
	el->el_term.t_loc = 0;
	el->el_term.t_str = reallocarray(NULL, T_str, sizeof(char *));
	if (el->el_term.t_str == NULL)
d349 3
a351 3
	(void) memset(el->el_term.t_str, 0, T_str * sizeof(char *));
	el->el_term.t_val = reallocarray(NULL, T_val, sizeof(int));
	if (el->el_term.t_val == NULL)
d353 3
a355 3
	(void) memset(el->el_term.t_val, 0, T_val * sizeof(int));
	(void) term_set(el, NULL);
	term_init_arrow(el);
d358 2
a359 2
	free(el->el_term.t_str);
	el->el_term.t_str = NULL;
d361 2
a362 2
	free(el->el_term.t_fkey);
	el->el_term.t_fkey = NULL;
d364 2
a365 2
	free(el->el_term.t_cap);
	el->el_term.t_cap = NULL;
d367 2
a368 2
	free(el->el_term.t_buf);
	el->el_term.t_buf = NULL;
d373 1
a373 1
/* term_end():
d377 1
a377 1
term_end(EditLine *el)
d380 12
a391 12
	free((ptr_t) el->el_term.t_buf);
	el->el_term.t_buf = NULL;
	free((ptr_t) el->el_term.t_cap);
	el->el_term.t_cap = NULL;
	el->el_term.t_loc = 0;
	free((ptr_t) el->el_term.t_str);
	el->el_term.t_str = NULL;
	free((ptr_t) el->el_term.t_val);
	el->el_term.t_val = NULL;
	free((ptr_t) el->el_term.t_fkey);
	el->el_term.t_fkey = NULL;
	term_free_display(el);
d395 1
a395 1
/* term_alloc():
d399 1
a399 1
term_alloc(EditLine *el, const struct termcapstr *t, const char *cap)
d403 1
a403 1
	char **tlist = el->el_term.t_str;
d425 5
a429 5
	if (el->el_term.t_loc + 3 < TC_BUFSIZE) {
		tlen = TC_BUFSIZE - el->el_term.t_loc;
		(void) strlcpy(*str = &el->el_term.t_buf[el->el_term.t_loc],
		    cap, tlen);
		el->el_term.t_loc += (int)clen + 1;	/* one for \0 */
d445 3
a447 3
	memcpy(el->el_term.t_buf, termbuf, TC_BUFSIZE);
	el->el_term.t_loc = (int)tlen;
	if (el->el_term.t_loc + 3 >= TC_BUFSIZE) {
d452 4
a455 3
	tlen = TC_BUFSIZE - el->el_term.t_loc;
	(void) strlcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap, tlen);
	el->el_term.t_loc += (int)clen + 1;	/* one for \0 */
d460 1
a460 1
/* term_rebuffer_display():
d464 1
a464 1
term_rebuffer_display(EditLine *el)
d466 1
a466 1
	coord_t *c = &el->el_term.t_size;
d468 1
a468 1
	term_free_display(el);
d473 1
a473 1
	if (term_alloc_display(el) == -1)
d479 1
a479 1
/* term_alloc_display():
d483 1
a483 1
term_alloc_display(EditLine *el)
d487 1
a487 1
	coord_t *c = &el->el_term.t_size;
d522 1
a522 1
		term_free_display(el);
d527 1
a527 1
/* term_free_display():
d531 1
a531 1
term_free_display(EditLine *el)
d553 1
a553 1
/* term_move_to_line():
d558 1
a558 1
term_move_to_line(EditLine *el, int where)
d565 1
a565 1
	if (where > el->el_term.t_size.v) {
d568 2
a569 1
		    "term_move_to_line: where is ridiculous: %d\r\n", where);
d577 1
a577 1
                                size_t h = el->el_term.t_size.h - 1;
d586 2
a587 2
				term_move_to_char(el, (int)h);
				term_overwrite(el, &el->el_display
d589 1
a589 1
				    (size_t)(el->el_term.t_size.h -
d595 1
a595 1
					term_tputs(el, tgoto(Str(T_DO), del,
d600 1
a600 1
						term__putc(el, '\n');
d608 1
a608 1
			term_tputs(el, tgoto(Str(T_UP), -del, -del), -del);
d612 1
a612 1
					term_tputs(el, Str(T_up), 1);
d619 1
a619 1
/* term_move_to_char():
d623 1
a623 1
term_move_to_char(EditLine *el, int where)
d631 1
a631 1
	if (where > el->el_term.t_size.h) {
d634 2
a635 1
		    "term_move_to_char: where is riduculous: %d\r\n", where);
d640 1
a640 1
		term__putc(el, '\r');	/* do a CR */
d648 1
a648 1
		term_tputs(el, tgoto(Str(T_ch), where, where), where);
d652 2
a653 1
				term_tputs(el, tgoto(Str(T_RI), del, del), del);
d670 2
a671 1
							term__putc(el, '\t');	
d681 1
a681 1
				 * NOTE THAT term_overwrite() WILL CHANGE
d684 1
a684 1
				term_overwrite(el, &el->el_display[
d691 1
a691 1
				term_tputs(el, tgoto(Str(T_LE), -del, -del),
d703 1
a703 1
					term__putc(el, '\r');	/* do a CR */
d708 1
a708 1
					term__putc(el, '\b');
d716 1
a716 1
/* term_overwrite():
d721 1
a721 1
term_overwrite(EditLine *el, const Char *cp, size_t n)
d726 1
a726 1
	if (n > (size_t)el->el_term.t_size.h) {
d729 1
a729 1
		    "term_overwrite: n is riduculous: %d\r\n", n);
d735 2
a736 2
                /* term__putc() ignores any MB_FILL_CHARs */
                term__putc(el, *cp++);
d740 1
a740 1
	if (el->el_cursor.h >= el->el_term.t_size.h) {	/* wrap? */
d750 1
a750 1
					term_overwrite(el, &c, 1);
d757 1
a757 1
					term__putc(el, ' ');
d762 1
a762 1
			el->el_cursor.h = el->el_term.t_size.h - 1;
d767 1
a767 1
/* term_deletechars():
d771 1
a771 1
term_deletechars(EditLine *el, int num)
d782 1
a782 1
	if (num > el->el_term.t_size.h) {
d785 1
a785 1
		    "term_deletechars: num is riduculous: %d\r\n", num);
d792 1
a792 1
			term_tputs(el, tgoto(Str(T_DC), num, num), num);
d796 1
a796 1
		term_tputs(el, Str(T_dm), 1);
d800 1
a800 1
			term_tputs(el, Str(T_dc), 1);
d803 1
a803 1
		term_tputs(el, Str(T_ed), 1);
d807 1
a807 1
/* term_insertwrite():
d813 1
a813 1
term_insertwrite(EditLine *el, Char *cp, int num)
d823 1
a823 1
	if (num > el->el_term.t_size.h) {
d833 2
a834 2
			term_tputs(el, tgoto(Str(T_IC), num, num), num);
			term_overwrite(el, cp, (size_t)num);
d839 1
a839 1
		term_tputs(el, Str(T_im), 1);
d843 1
a843 1
			term__putc(el, *cp++);
d847 1
a847 1
			term_tputs(el, Str(T_ip), 1);
d849 1
a849 1
		term_tputs(el, Str(T_ei), 1);
d854 1
a854 1
			term_tputs(el, Str(T_ic), 1);
d856 1
a856 1
		term__putc(el, *cp++);
d861 1
a861 1
			term_tputs(el, Str(T_ip), 1);
d868 1
a868 1
/* term_clear_EOL():
d872 1
a872 1
term_clear_EOL(EditLine *el, int num)
d877 1
a877 1
		term_tputs(el, Str(T_ce), 1);
d880 1
a880 1
			term__putc(el, ' ');
d886 1
a886 1
/* term_clear_screen():
d890 1
a890 1
term_clear_screen(EditLine *el)
d895 1
a895 1
		term_tputs(el, Str(T_cl), Val(T_li));
d897 1
a897 1
		term_tputs(el, Str(T_ho), Val(T_li));	/* home */
d899 1
a899 1
		term_tputs(el, Str(T_cd), Val(T_li));
d901 2
a902 2
		term__putc(el, '\r');
		term__putc(el, '\n');
d907 1
a907 1
/* term_beep():
d911 1
a911 1
term_beep(EditLine *el)
d915 1
a915 1
		term_tputs(el, Str(T_bl), 1);
d917 1
a917 1
		term__putc(el, '\007');	/* an ASCII bell; ^G */
d929 1
a929 1
		term_tputs(el, Str(T_cd), Val(T_li));
d931 1
a931 1
		term_tputs(el, Str(T_ce), Val(T_li));
d936 1
a936 1
term_get(EditLine *el, const char **term)
d938 1
a938 1
	*term = el->el_term.t_name;
d942 1
a942 1
/* term_set():
d946 1
a946 1
term_set(EditLine *el, const char *term)
d971 1
a971 1
	memset(el->el_term.t_cap, 0, TC_BUFSIZE);
d973 1
a973 1
	i = tgetent(el->el_term.t_cap, term);
d988 1
a988 1
			term_alloc(el, t, NULL);
d1004 1
a1004 1
			term_alloc(el, t, tgetstr(strchr(t->name, *t->name),
d1014 2
a1015 2
	el->el_term.t_size.v = Val(T_co);
	el->el_term.t_size.h = Val(T_li);
d1017 1
a1017 1
	term_setflags(el);
d1020 2
a1021 2
	(void) term_get_size(el, &lins, &cols);
	if (term_change_size(el, lins, cols) == -1)
d1024 2
a1025 2
	term_bind_arrow(el);
	el->el_term.t_name = term;
d1030 1
a1030 1
/* term_get_size():
d1035 1
a1035 1
term_get_size(EditLine *el, int *lins, int *cols)
d1067 1
a1067 1
/* term_change_size():
d1071 1
a1071 1
term_change_size(EditLine *el, int lins, int cols)
d1080 1
a1080 1
	if (term_rebuffer_display(el) == -1)
d1087 1
a1087 1
/* term_init_arrow():
d1091 1
a1091 1
term_init_arrow(EditLine *el)
d1093 1
a1093 1
	fkey_t *arrow = el->el_term.t_fkey;
d1127 1
a1127 1
/* term_reset_arrow():
d1131 1
a1131 1
term_reset_arrow(EditLine *el)
d1133 1
a1133 1
	fkey_t *arrow = el->el_term.t_fkey;
d1177 1
a1177 1
/* term_set_arrow():
d1181 2
a1182 1
term_set_arrow(EditLine *el, const Char *name, keymacro_value_t *fun, int type)
d1184 1
a1184 1
	fkey_t *arrow = el->el_term.t_fkey;
d1197 1
a1197 1
/* term_clear_arrow():
d1201 1
a1201 1
term_clear_arrow(EditLine *el, const Char *name)
d1203 1
a1203 1
	fkey_t *arrow = el->el_term.t_fkey;
d1215 1
a1215 1
/* term_print_arrow():
d1219 1
a1219 1
term_print_arrow(EditLine *el, const Char *name)
d1222 1
a1222 1
	fkey_t *arrow = el->el_term.t_fkey;
d1232 1
a1232 1
/* term_bind_arrow():
d1236 1
a1236 1
term_bind_arrow(EditLine *el)
d1242 1
a1242 1
	fkey_t *arrow = el->el_term.t_fkey;
d1245 1
a1245 1
	if (el->el_term.t_buf == NULL || el->el_map.key == NULL)
d1251 1
a1251 1
	term_reset_arrow(el);
d1258 1
a1258 1
		p = el->el_term.t_str[arrow[i].key];
d1297 1
a1297 1
/* term_putc():
d1301 1
a1301 1
term_putc(int c)
d1303 1
a1303 1
	if (term_outfile == NULL)
d1305 1
a1305 1
	return fputc(c, term_outfile);
d1309 1
a1309 1
term_tputs(EditLine *el, const char *cap, int affcnt)
d1312 1
a1312 1
	pthread_mutex_lock(&term_mutex);
d1314 2
a1315 2
	term_outfile = el->el_outfile;
	(void)tputs(cap, affcnt, term_putc);
d1317 1
a1317 1
	pthread_mutex_unlock(&term_mutex);
d1321 1
a1321 1
/* term__putc():
d1325 1
a1325 1
term__putc(EditLine *el, Int c)
d1338 1
a1338 1
/* term__flush():
d1342 1
a1342 1
term__flush(EditLine *el)
d1348 1
a1348 1
/* term_writec():
d1352 1
a1352 1
term_writec(EditLine *el, Int c)
d1357 2
a1358 2
	term_overwrite(el, visbuf, (size_t)vcnt);
	term__flush(el);
d1362 1
a1362 1
/* term_telltc():
d1367 1
a1367 1
term_telltc(EditLine *el, int argc __attribute__((__unused__)), 
d1387 1
a1387 1
	for (t = tstr, ts = el->el_term.t_str; t->name != NULL; t++, ts++) {
d1404 1
a1404 1
/* term_settc():
d1409 1
a1409 1
term_settc(EditLine *el, int argc __attribute__((__unused__)),
d1432 2
a1433 2
		term_alloc(el, ts, how);
		term_setflags(el);
d1449 1
a1449 1
			el->el_term.t_val[tv - tval] = 1;
d1451 1
a1451 1
			el->el_term.t_val[tv - tval] = 0;
d1457 2
a1458 2
		term_setflags(el);
		if (term_change_size(el, Val(T_li), Val(T_co)) == -1)
d1471 3
a1473 3
		el->el_term.t_val[tv - tval] = (int) i;
		el->el_term.t_size.v = Val(T_co);
		el->el_term.t_size.h = Val(T_li);
d1475 1
a1475 1
			if (term_change_size(el, Val(T_li), Val(T_co))
d1483 1
a1483 1
/* term_gettc():
d1488 1
a1488 1
term_gettc(EditLine *el, int argc __attribute__((__unused__)), char **argv)
d1509 1
a1509 1
		*(char **)how = el->el_term.t_str[ts - tstr];
d1526 1
a1526 1
		if (el->el_term.t_val[tv - tval])
d1532 1
a1532 1
		*(int *)how = el->el_term.t_val[tv - tval];
d1537 1
a1537 1
/* term_echotc():
d1542 1
a1542 1
term_echotc(EditLine *el, int argc __attribute__((__unused__)),
d1621 1
a1621 1
			scap = el->el_term.t_str[t - tstr];
d1678 1
a1678 1
		term_tputs(el, scap, 1);
d1706 1
a1706 1
		term_tputs(el, tgoto(scap, arg_cols, arg_rows), 1);
d1762 1
a1762 1
		term_tputs(el, tgoto(scap, arg_cols, arg_rows), arg_rows);
@


1.1
log
@Start synching with NetBSD:
Rename the files key.[hc] to keymacro.[hc] and term.[hc] to terminal.[hc].
The change makes sense because "term.h" conflicts with <term.h>
and the functions key_clear(), key_end(), and key_print() in "key.h"
conflict with macros in <term.h>.
No content change yet, no binary change in *.o after "strip -d".
This reduces the remaining diff from +4634 -3992 to +2640 -1998.
OK czarkoff@@, and mmcc@@ agrees with the direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.17 2014/10/17 06:07:50 deraadt Exp $	*/
d1140 27
a1166 27
	key_add(el, strA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	key_add(el, strB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	key_add(el, strC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	key_add(el, strD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
	key_add(el, strH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
	key_add(el, strF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);
	key_add(el, stOA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	key_add(el, stOB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	key_add(el, stOC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	key_add(el, stOD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
	key_add(el, stOH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
	key_add(el, stOF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);

	if (el->el_map.type == MAP_VI) {
		key_add(el, &strA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
		key_add(el, &strB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
		key_add(el, &strC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
		key_add(el, &strD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
		key_add(el, &strH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
		key_add(el, &strF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
		key_add(el, &stOA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
		key_add(el, &stOB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
		key_add(el, &stOC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
		key_add(el, &stOD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
		key_add(el, &stOH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
		key_add(el, &stOF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
	}
d1174 1
a1174 1
term_set_arrow(EditLine *el, const Char *name, key_value_t *fun, int type)
d1219 2
a1220 2
				key_kprint(el, arrow[i].name, &arrow[i].fun,
				    arrow[i].type);
d1270 1
a1270 1
			key_clear(el, map, px);
d1274 1
a1274 1
				key_add(el, px, &arrow[i].fun,
d1278 1
a1278 1
				key_clear(el, map, px);
d1282 1
a1282 1
					key_add(el, px, &arrow[i].fun,
@

