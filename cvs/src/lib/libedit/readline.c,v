head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.10.0.16
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.14
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.10
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.8
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.6
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.2.0.8
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.27
date	2016.05.31.16.12.00;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	ivoO0GHKOJZawu3U;

1.26
date	2016.05.10.11.07.53;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	20CL26jlwTb5NoXa;

1.25
date	2016.05.10.10.49.37;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	lY2WBT6JmURHxEE4;

1.24
date	2016.05.09.12.31.55;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	xpwnEq9Mpoz5gZat;

1.23
date	2016.05.08.13.52.33;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	mQ7al9wEObcAYZMH;

1.22
date	2016.05.08.13.34.35;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	IqIzBDYdi799nNVi;

1.21
date	2016.05.06.13.12.52;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	HmIy04UbyUS0d1Sd;

1.20
date	2016.04.09.19.31.55;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	t22PDRfkb5DJX3rc;

1.19
date	2016.03.21.17.28.10;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	bxfYrS2VROPyQgXw;

1.18
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	tRHhB2RN3ZD1GvoI;

1.17
date	2016.03.20.22.57.59;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	VBVmrUoZFnMc0hts;

1.16
date	2016.03.20.00.01.21;	author krw;	state Exp;
branches;
next	1.15;
commitid	vrVXbedfAlzCTHmf;

1.15
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	dCN84ovvbfYwqrqX;

1.14
date	2015.02.06.23.21.58;	author millert;	state Exp;
branches;
next	1.13;
commitid	STdsVrA5MGLlnbLm;

1.13
date	2015.01.13.08.33.12;	author reyk;	state Exp;
branches;
next	1.12;
commitid	IiXmbQdUiTgz5HPa;

1.12
date	2014.10.15.10.55.11;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	kxkjUoOA7eEouJXf;

1.11
date	2014.10.11.04.24.06;	author doug;	state Exp;
branches;
next	1.10;
commitid	PCoPlmr5UScOQHbi;

1.10
date	2011.07.08.05.41.11;	author nicm;	state Exp;
branches;
next	1.9;

1.9
date	2011.07.07.05.40.42;	author okan;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.21.00.38.22;	author martynas;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.09.12.34.46;	author tobias;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.26.05.42.05;	author ray;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.14.13.36.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.25.20.12.38;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Fix a crash in stifle_history() that occurred when the history
contained more than twice as many entries as the new limit:  The
argument of remove_history() only counts existing elements, not
those previously deleted.

Crash found by bentley@@ when exiting sqlite3(1).
@
text
@/*	$OpenBSD: readline.c,v 1.26 2016/05/10 11:07:53 schwarze Exp $	*/
/*	$NetBSD: readline.c,v 1.91 2010/08/28 15:44:59 christos Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jaromir Dolecek.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pwd.h>
#include <setjmp.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#ifdef HAVE_VIS_H
#include <vis.h>
#else
#include "np/vis.h"
#endif
#include "readline/readline.h"
#include "el.h"
#include "fcns.h"
#include "filecomplete.h"

void rl_prep_terminal(int);
void rl_deprep_terminal(void);

/* for rl_complete() */
#define TAB		'\r'

/* see comment at the #ifdef for sense of this */
/* #define GDB_411_HACK */

/* readline compatibility stuff - look at readline sources/documentation */
/* to see what these variables mean */
const char *rl_library_version = "EditLine wrapper";
int rl_readline_version = RL_READLINE_VERSION;
static char empty[] = { '\0' };
static char expand_chars[] = { ' ', '\t', '\n', '=', '(', '\0' };
static char break_chars[] = { ' ', '\t', '\n', '"', '\\', '\'', '`', '@@', '$',
    '>', '<', '=', ';', '|', '&', '{', '(', '\0' };
char *rl_readline_name = empty;
FILE *rl_instream = NULL;
FILE *rl_outstream = NULL;
int rl_point = 0;
int rl_end = 0;
char *rl_line_buffer = NULL;
VCPFunction *rl_linefunc = NULL;
int rl_done = 0;
VFunction *rl_event_hook = NULL;
KEYMAP_ENTRY_ARRAY emacs_standard_keymap,
    emacs_meta_keymap,
    emacs_ctlx_keymap;

int history_base = 1;		/* probably never subject to change */
int history_length = 0;
int max_input_history = 0;
char history_expansion_char = '!';
char history_subst_char = '^';
char *history_no_expand_chars = expand_chars;
Function *history_inhibit_expansion_function = NULL;
char *history_arg_extract(int start, int end, const char *str);

int rl_inhibit_completion = 0;
int rl_attempted_completion_over = 0;
char *rl_basic_word_break_characters = break_chars;
char *rl_completer_word_break_characters = NULL;
char *rl_completer_quote_characters = NULL;
Function *rl_completion_entry_function = NULL;
CPPFunction *rl_attempted_completion_function = NULL;
Function *rl_pre_input_hook = NULL;
Function *rl_startup1_hook = NULL;
int (*rl_getc_function)(FILE *) = NULL;
char *rl_terminal_name = NULL;
int rl_already_prompted = 0;
int rl_filename_completion_desired = 0;
int rl_ignore_completion_duplicates = 0;
int rl_catch_signals = 1;
int readline_echoing_p = 1;
int _rl_print_completions_horizontally = 0;
VFunction *rl_redisplay_function = NULL;
Function *rl_startup_hook = NULL;
VFunction *rl_completion_display_matches_hook = NULL;
VFunction *rl_prep_term_function = (VFunction *)rl_prep_terminal;
VFunction *rl_deprep_term_function = (VFunction *)rl_deprep_terminal;
KEYMAP_ENTRY_ARRAY emacs_meta_keymap;

/*
 * The current prompt string.
 */
char *rl_prompt = NULL;
/*
 * This is set to character indicating type of completion being done by
 * rl_complete_internal(); this is available for application completion
 * functions.
 */
int rl_completion_type = 0;

/*
 * If more than this number of items results from query for possible
 * completions, we ask user if they are sure to really display the list.
 */
int rl_completion_query_items = 100;

/*
 * List of characters which are word break characters, but should be left
 * in the parsed text when it is passed to the completion function.
 * Shell uses this to help determine what kind of completing to do.
 */
char *rl_special_prefixes = NULL;

/*
 * This is the character appended to the completed words if at the end of
 * the line. Default is ' ' (a space).
 */
int rl_completion_append_character = ' ';

/*
 * When the history cursor is on the newest element and next_history()
 * is called, GNU readline moves the cursor beyond the newest element.
 * The editline library does not provide data structures to express
 * that state, so we need a local flag.
 */
static int current_history_valid = 1;

/* stuff below is used internally by libedit for readline emulation */

static History *h = NULL;
static EditLine *e = NULL;
static Function *map[256];
static jmp_buf topbuf;

/* internal functions */
static unsigned char	 _el_rl_complete(EditLine *, int);
static unsigned char	 _el_rl_tstp(EditLine *, int);
static char		*_get_prompt(EditLine *);
static int		 _getc_function(EditLine *, wchar_t *);
static HIST_ENTRY	*_move_history(int);
static int		 _history_expand_command(const char *, size_t, size_t,
    char **);
static char		*_rl_compat_sub(const char *, const char *,
    const char *, int);
static int		 _rl_event_read_char(EditLine *, wchar_t *);
static void		 _rl_update_pos(void);


/* ARGSUSED */
static char *
_get_prompt(EditLine *el __attribute__((__unused__)))
{
	rl_already_prompted = 1;
	return rl_prompt;
}


/*
 * generic function for moving around history
 */
static HIST_ENTRY *
_move_history(int op)
{
	HistEvent ev;
	static HIST_ENTRY rl_he;

	if (history(h, &ev, op) != 0)
		return NULL;

	rl_he.line = ev.str;
	rl_he.data = NULL;

	return &rl_he;
}


/*
 * read one key from user defined input function
 */
static int
/*ARGSUSED*/
_getc_function(EditLine *el __attribute__((__unused__)), wchar_t *c)
{
	int i;

	i = (*rl_getc_function)(NULL);
	if (i == -1)
		return 0;
	*c = (wchar_t)i;
	return 1;
}

static void
_resize_fun(EditLine *el, void *a)
{
	const LineInfo *li;
	char **ap = a;

	li = el_line(el);
	/* a cheesy way to get rid of const cast. */
	*ap = memchr(li->buffer, *li->buffer, 1);
}

static const char _dothistory[] = "/.history";

static const char *
_default_history_file(void)
{
	struct passwd *p;
	static char path[PATH_MAX];

	if (*path)
		return path;
	if ((p = getpwuid(getuid())) == NULL)
		return NULL;
	strlcpy(path, p->pw_dir, PATH_MAX);
	strlcat(path, _dothistory, PATH_MAX);
	return path;
}

/*
 * READLINE compatibility stuff
 */

/*
 * Set the prompt
 */
int
rl_set_prompt(const char *prompt)
{
	char *p;

	if (!prompt)
		prompt = "";
	if (rl_prompt != NULL && strcmp(rl_prompt, prompt) == 0)
		return 0;
	if (rl_prompt)
		free(rl_prompt);
	rl_prompt = strdup(prompt);
	if (rl_prompt == NULL)
		return -1;

	while ((p = strchr(rl_prompt, RL_PROMPT_END_IGNORE)) != NULL)
		*p = RL_PROMPT_START_IGNORE;

	return 0;
}

/*
 * initialize rl compat stuff
 */
int
rl_initialize(void)
{
	HistEvent ev;
	int editmode = 1;
	struct termios t;

	current_history_valid = 1;

	if (e != NULL)
		el_end(e);
	if (h != NULL)
		history_end(h);

	if (!rl_instream)
		rl_instream = stdin;
	if (!rl_outstream)
		rl_outstream = stdout;

	/*
	 * See if we don't really want to run the editor
	 */
	if (tcgetattr(fileno(rl_instream), &t) != -1 && (t.c_lflag & ECHO) == 0)
		editmode = 0;

	e = el_init(rl_readline_name, rl_instream, rl_outstream, stderr);

	if (!editmode)
		el_set(e, EL_EDITMODE, 0);

	h = history_init();
	if (!e || !h)
		return -1;

	history(h, &ev, H_SETSIZE, INT_MAX);	/* unlimited */
	history_length = 0;
	max_input_history = INT_MAX;
	el_set(e, EL_HIST, history, h);

	/* Setup resize function */
	el_set(e, EL_RESIZE, _resize_fun, &rl_line_buffer);

	/* setup getc function if valid */
	if (rl_getc_function)
		el_set(e, EL_GETCFN, _getc_function);

	/* for proper prompt printing in readline() */
	if (rl_set_prompt("") == -1) {
		history_end(h);
		el_end(e);
		return -1;
	}
	el_set(e, EL_PROMPT, _get_prompt, RL_PROMPT_START_IGNORE);
	el_set(e, EL_SIGNAL, rl_catch_signals);

	/* set default mode to "emacs"-style and read setting afterwards */
	/* so this can be overriden */
	el_set(e, EL_EDITOR, "emacs");
	if (rl_terminal_name != NULL)
		el_set(e, EL_TERMINAL, rl_terminal_name);
	else
		el_get(e, EL_TERMINAL, &rl_terminal_name);

	/*
	 * Word completion - this has to go AFTER rebinding keys
	 * to emacs-style.
	 */
	el_set(e, EL_ADDFN, "rl_complete",
	    "ReadLine compatible completion function",
	    _el_rl_complete);
	el_set(e, EL_BIND, "^I", "rl_complete", NULL);

	/*
	 * Send TSTP when ^Z is pressed.
	 */
	el_set(e, EL_ADDFN, "rl_tstp",
	    "ReadLine compatible suspend function",
	    _el_rl_tstp);
	el_set(e, EL_BIND, "^Z", "rl_tstp", NULL);

	/* read settings from configuration file */
	el_source(e, NULL);

	/*
	 * Unfortunately, some applications really do use rl_point
	 * and rl_line_buffer directly.
	 */
	_resize_fun(e, &rl_line_buffer);
	_rl_update_pos();

	if (rl_startup_hook)
		(*rl_startup_hook)(NULL, 0);

	return 0;
}


/*
 * read one line from input stream and return it, chomping
 * trailing newline (if there is any)
 */
char *
readline(const char *p)
{
	HistEvent ev;
	const char * volatile prompt = p;
	int count;
	const char *ret;
	char *buf;
	static int used_event_hook;

	if (e == NULL || h == NULL)
		rl_initialize();

	rl_done = 0;

	(void)setjmp(topbuf);

	/* update prompt accordingly to what has been passed */
	if (rl_set_prompt(prompt) == -1)
		return NULL;

	if (rl_pre_input_hook)
		(*rl_pre_input_hook)(NULL, 0);

	if (rl_event_hook && !(e->el_flags&NO_TTY)) {
		el_set(e, EL_GETCFN, _rl_event_read_char);
		used_event_hook = 1;
	}

	if (!rl_event_hook && used_event_hook) {
		el_set(e, EL_GETCFN, EL_BUILTIN_GETCFN);
		used_event_hook = 0;
	}

	rl_already_prompted = 0;

	/* get one line from input stream */
	ret = el_gets(e, &count);

	if (ret && count > 0) {
		int lastidx;

		buf = strdup(ret);
		if (buf == NULL)
			return NULL;
		lastidx = count - 1;
		if (buf[lastidx] == '\n')
			buf[lastidx] = '\0';
	} else
		buf = NULL;

	history(h, &ev, H_GETSIZE);
	history_length = ev.num;

	return buf;
}

/*
 * history functions
 */

/*
 * is normally called before application starts to use
 * history expansion functions
 */
void
using_history(void)
{
	if (h == NULL || e == NULL)
		rl_initialize();
}


/*
 * substitute ``what'' with ``with'', returning resulting string; if
 * globally == 1, substitutes all occurrences of what, otherwise only the
 * first one
 */
static char *
_rl_compat_sub(const char *str, const char *what, const char *with,
    int globally)
{
	const	char	*s;
	char	*r, *result;
	size_t	len, with_len, what_len;

	len = strlen(str);
	with_len = strlen(with);
	what_len = strlen(what);

	/* calculate length we need for result */
	s = str;
	while (*s) {
		if (*s == *what && !strncmp(s, what, what_len)) {
			len += with_len - what_len;
			if (!globally)
				break;
			s += what_len;
		} else
			s++;
	}
	r = result = malloc(len + 1);
	if (result == NULL)
		return NULL;
	s = str;
	while (*s) {
		if (*s == *what && !strncmp(s, what, what_len)) {
			(void)strncpy(r, with, with_len);
			r += with_len;
			s += what_len;
			if (!globally) {
				(void)strlcpy(r, s, len);
				return result;
			}
		} else
			*r++ = *s++;
	}
	*r = '\0';
	return result;
}

static	char	*last_search_pat;	/* last !?pat[?] search pattern */
static	char	*last_search_match;	/* last !?pat[?] that matched */

const char *
get_history_event(const char *cmd, int *cindex, int qchar)
{
	int idx, sign, sub, num, begin, ret;
	size_t len;
	char	*pat;
	const char *rptr;
	HistEvent ev;

	idx = *cindex;
	if (cmd[idx++] != history_expansion_char)
		return NULL;

	/* find out which event to take */
	if (cmd[idx] == history_expansion_char || cmd[idx] == '\0') {
		if (history(h, &ev, H_FIRST) != 0)
			return NULL;
		*cindex = cmd[idx]? (idx + 1):idx;
		return ev.str;
	}
	sign = 0;
	if (cmd[idx] == '-') {
		sign = 1;
		idx++;
	}

	if ('0' <= cmd[idx] && cmd[idx] <= '9') {
		HIST_ENTRY *rl_he;

		num = 0;
		while (cmd[idx] && '0' <= cmd[idx] && cmd[idx] <= '9') {
			num = num * 10 + cmd[idx] - '0';
			idx++;
		}
		if (sign)
			num = history_length - num + 1;

		if (!(rl_he = history_get(num)))
			return NULL;

		*cindex = idx;
		return rl_he->line;
	}
	sub = 0;
	if (cmd[idx] == '?') {
		sub = 1;
		idx++;
	}
	begin = idx;
	while (cmd[idx]) {
		if (cmd[idx] == '\n')
			break;
		if (sub && cmd[idx] == '?')
			break;
		if (!sub && (cmd[idx] == ':' || cmd[idx] == ' '
				    || cmd[idx] == '\t' || cmd[idx] == qchar))
			break;
		idx++;
	}
	len = idx - begin;
	if (sub && cmd[idx] == '?')
		idx++;
	if (sub && len == 0 && last_search_pat && *last_search_pat)
		pat = last_search_pat;
	else if (len == 0)
		return NULL;
	else {
		if ((pat = malloc(len + 1)) == NULL)
			return NULL;
		(void)strncpy(pat, cmd + begin, len);
		pat[len] = '\0';
	}

	if (history(h, &ev, H_CURR) != 0) {
		if (pat != last_search_pat)
			free(pat);
		return NULL;
	}
	num = ev.num;

	if (sub) {
		if (pat != last_search_pat) {
			if (last_search_pat)
				free(last_search_pat);
			last_search_pat = pat;
		}
		ret = history_search(pat, -1);
	} else
		ret = history_search_prefix(pat, -1);

	if (ret == -1) {
		/* restore to end of list on failed search */
		history(h, &ev, H_FIRST);
		(void)fprintf(rl_outstream, "%s: Event not found\n", pat);
		if (pat != last_search_pat)
			free(pat);
		return NULL;
	}

	if (sub && len) {
		if (last_search_match && last_search_match != pat)
			free(last_search_match);
		last_search_match = pat;
	}

	if (pat != last_search_pat)
		free(pat);

	if (history(h, &ev, H_CURR) != 0)
		return NULL;
	*cindex = idx;
	rptr = ev.str;

	/* roll back to original position */
	(void)history(h, &ev, H_SET, num);

	return rptr;
}

/*
 * the real function doing history expansion - takes as argument command
 * to do and data upon which the command should be executed
 * does expansion the way I've understood readline documentation
 *
 * returns 0 if data was not modified, 1 if it was and 2 if the string
 * should be only printed and not executed; in case of error,
 * returns -1 and *result points to NULL
 * it's the caller's responsibility to free() the string returned in *result
 */
static int
_history_expand_command(const char *command, size_t offs, size_t cmdlen,
    char **result)
{
	char *tmp, *search = NULL, *aptr;
	const char *ptr, *cmd;
	static char *from = NULL, *to = NULL;
	int start, end, idx, has_mods = 0;
	int p_on = 0, g_on = 0;

	*result = NULL;
	aptr = NULL;
	ptr = NULL;

	/* First get event specifier */
	idx = 0;

	if (strchr(":^*$", command[offs + 1])) {
		char str[4];
		/*
		* "!:" is shorthand for "!!:".
		* "!^", "!*" and "!$" are shorthand for
		* "!!:^", "!!:*" and "!!:$" respectively.
		*/
		str[0] = str[1] = '!';
		str[2] = '0';
		ptr = get_history_event(str, &idx, 0);
		idx = (command[offs + 1] == ':')? 1:0;
		has_mods = 1;
	} else {
		if (command[offs + 1] == '#') {
			/* use command so far */
			if ((aptr = malloc(offs + 1)) == NULL)
				return -1;
			(void)strncpy(aptr, command, offs);
			aptr[offs] = '\0';
			idx = 1;
		} else {
			int	qchar;

			qchar = (offs > 0 && command[offs - 1] == '"')? '"':0;
			ptr = get_history_event(command + offs, &idx, qchar);
		}
		has_mods = command[offs + idx] == ':';
	}

	if (ptr == NULL && aptr == NULL)
		return -1;

	if (!has_mods) {
		*result = strdup(aptr ? aptr : ptr);
		if (aptr)
			free(aptr);
		if (*result == NULL)
			return -1;
		return 1;
	}

	cmd = command + offs + idx + 1;

	/* Now parse any word designators */

	if (*cmd == '%')	/* last word matched by ?pat? */
		tmp = strdup(last_search_match? last_search_match:"");
	else if (strchr("^*$-0123456789", *cmd)) {
		start = end = -1;
		if (*cmd == '^')
			start = end = 1, cmd++;
		else if (*cmd == '$')
			start = -1, cmd++;
		else if (*cmd == '*')
			start = 1, cmd++;
	       else if (*cmd == '-' || isdigit((unsigned char) *cmd)) {
			start = 0;
			while (*cmd && '0' <= *cmd && *cmd <= '9')
				start = start * 10 + *cmd++ - '0';

			if (*cmd == '-') {
				if (isdigit((unsigned char) cmd[1])) {
					cmd++;
					end = 0;
					while (*cmd && '0' <= *cmd && *cmd <= '9')
						end = end * 10 + *cmd++ - '0';
				} else if (cmd[1] == '$') {
					cmd += 2;
					end = -1;
				} else {
					cmd++;
					end = -2;
				}
			} else if (*cmd == '*')
				end = -1, cmd++;
			else
				end = start;
		}
		tmp = history_arg_extract(start, end, aptr? aptr:ptr);
		if (tmp == NULL) {
			(void)fprintf(rl_outstream, "%s: Bad word specifier",
			    command + offs + idx);
			if (aptr)
				free(aptr);
			return -1;
		}
	} else
		tmp = strdup(aptr? aptr:ptr);

	if (aptr)
		free(aptr);

	if (*cmd == '\0' || ((size_t)(cmd - (command + offs)) >= cmdlen)) {
		*result = tmp;
		return 1;
	}

	for (; *cmd; cmd++) {
		if (*cmd == ':')
			continue;
		else if (*cmd == 'h') {		/* remove trailing path */
			if ((aptr = strrchr(tmp, '/')) != NULL)
				*aptr = '\0';
		} else if (*cmd == 't') {	/* remove leading path */
			if ((aptr = strrchr(tmp, '/')) != NULL) {
				aptr = strdup(aptr + 1);
				free(tmp);
				tmp = aptr;
			}
		} else if (*cmd == 'r') {	/* remove trailing suffix */
			if ((aptr = strrchr(tmp, '.')) != NULL)
				*aptr = '\0';
		} else if (*cmd == 'e') {	/* remove all but suffix */
			if ((aptr = strrchr(tmp, '.')) != NULL) {
				aptr = strdup(aptr);
				free(tmp);
				tmp = aptr;
			}
		} else if (*cmd == 'p')		/* print only */
			p_on = 1;
		else if (*cmd == 'g')
			g_on = 2;
		else if (*cmd == 's' || *cmd == '&') {
			char *what, *with, delim;
			size_t len, from_len;
			size_t size;

			if (*cmd == '&' && (from == NULL || to == NULL))
				continue;
			else if (*cmd == 's') {
				delim = *(++cmd), cmd++;
				size = 16;
				what = realloc(from, size);
				if (what == NULL) {
					free(from);
					free(tmp);
					return 0;
				}
				len = 0;
				for (; *cmd && *cmd != delim; cmd++) {
					if (*cmd == '\\' && cmd[1] == delim)
						cmd++;
					if (len >= size) {
						char *nwhat;
						nwhat = reallocarray(what,
						    size, 2);
						if (nwhat == NULL) {
							free(what);
							free(tmp);
							return 0;
						}
						size *= 2;
						what = nwhat;
					}
					what[len++] = *cmd;
				}
				what[len] = '\0';
				from = what;
				if (*what == '\0') {
					free(what);
					if (search) {
						from = strdup(search);
						if (from == NULL) {
							free(tmp);
							return 0;
						}
					} else {
						from = NULL;
						free(tmp);
						return -1;
					}
				}
				cmd++;	/* shift after delim */
				if (!*cmd)
					continue;

				size = 16;
				with = realloc(to, size);
				if (with == NULL) {
					free(to);
					free(tmp);
					return -1;
				}
				len = 0;
				from_len = strlen(from);
				for (; *cmd && *cmd != delim; cmd++) {
					if (len + from_len + 1 >= size) {
						char *nwith;
						size += from_len + 1;
						nwith = realloc(with, size);
						if (nwith == NULL) {
							free(with);
							free(tmp);
							return -1;
						}
						with = nwith;
					}
					if (*cmd == '&') {
						/* safe */
						(void)strlcpy(&with[len], from,
						    size - len);
						len += from_len;
						continue;
					}
					if (*cmd == '\\'
					    && (*(cmd + 1) == delim
						|| *(cmd + 1) == '&'))
						cmd++;
					with[len++] = *cmd;
				}
				with[len] = '\0';
				to = with;
			}

			aptr = _rl_compat_sub(tmp, from, to, g_on);
			if (aptr) {
				free(tmp);
				tmp = aptr;
			}
			g_on = 0;
		}
	}
	*result = tmp;
	return p_on? 2:1;
}


/*
 * csh-style history expansion
 */
int
history_expand(char *str, char **output)
{
	int ret = 0;
	size_t idx, i, size;
	char *tmp, *result;

	if (h == NULL || e == NULL)
		rl_initialize();

	if (history_expansion_char == 0) {
		*output = strdup(str);
		return 0;
	}

	*output = NULL;
	if (str[0] == history_subst_char) {
		/* ^foo^foo2^ is equivalent to !!:s^foo^foo2^ */
		size_t sz = 4 + strlen(str) + 1;
		*output = malloc(sz);
		if (*output == NULL)
			return 0;
		(*output)[0] = (*output)[1] = history_expansion_char;
		(*output)[2] = ':';
		(*output)[3] = 's';
		(void)strlcpy((*output) + 4, str, sz - 4);
		str = *output;
	} else {
		*output = strdup(str);
		if (*output == NULL)
			return 0;
	}

#define ADD_STRING(what, len, fr)					\
	{								\
		if (idx + len + 1 > size) {				\
			char *nresult = realloc(result, (size += len + 1));\
			if (nresult == NULL) {				\
				free(*output);				\
				if (/*CONSTCOND*/fr)			\
					free(tmp);			\
				return 0;				\
			}						\
			result = nresult;				\
		}							\
		(void)strncpy(&result[idx], what, len);			\
		idx += len;						\
		result[idx] = '\0';					\
	}

	result = NULL;
	size = idx = 0;
	tmp = NULL;
	for (i = 0; str[i];) {
		int qchar, loop_again;
		size_t len, start, j;

		qchar = 0;
		loop_again = 1;
		start = j = i;
loop:
		for (; str[j]; j++) {
			if (str[j] == '\\' &&
			    str[j + 1] == history_expansion_char) {
				size_t sz = strlen(&str[j]) + 1;
				(void)strlcpy(&str[j], &str[j + 1], sz);
				continue;
			}
			if (!loop_again) {
				if (isspace((unsigned char) str[j])
				    || str[j] == qchar)
					break;
			}
			if (str[j] == history_expansion_char
			    && !strchr(history_no_expand_chars, str[j + 1])
			    && (!history_inhibit_expansion_function ||
			    (*history_inhibit_expansion_function)(str,
			    (int)j) == 0))
				break;
		}

		if (str[j] && loop_again) {
			i = j;
			qchar = (j > 0 && str[j - 1] == '"' )? '"':0;
			j++;
			if (str[j] == history_expansion_char)
				j++;
			loop_again = 0;
			goto loop;
		}
		len = i - start;
		ADD_STRING(&str[start], len, 0);

		if (str[i] == '\0' || str[i] != history_expansion_char) {
			len = j - i;
			ADD_STRING(&str[i], len, 0);
			if (start == 0)
				ret = 0;
			else
				ret = 1;
			break;
		}
		ret = _history_expand_command (str, i, (j - i), &tmp);
		if (ret > 0 && tmp) {
			len = strlen(tmp);
			ADD_STRING(tmp, len, 1);
		}
		if (tmp) {
			free(tmp);
			tmp = NULL;
		}
		i = j;
	}

	/* ret is 2 for "print only" option */
	if (ret == 2) {
		add_history(result);
#ifdef GDB_411_HACK
		/* gdb 4.11 has been shipped with readline, where */
		/* history_expand() returned -1 when the line	  */
		/* should not be executed; in readline 2.1+	  */
		/* it should return 2 in such a case		  */
		ret = -1;
#endif
	}
	free(*output);
	*output = result;

	return ret;
}

/*
* Return a string consisting of arguments of "str" from "start" to "end".
*/
char *
history_arg_extract(int start, int end, const char *str)
{
	size_t  i, len, max;
	char	**arr, *result = NULL;

	arr = history_tokenize(str);
	if (!arr)
		return NULL;
	if (arr && *arr == NULL)
		goto out;

	for (max = 0; arr[max]; max++)
		continue;
	max--;

	if (start == '$')
		start = (int)max;
	if (end == '$')
		end = (int)max;
	if (end < 0)
		end = (int)max + end + 1;
	if (start < 0)
		start = end;

	if (start < 0 || end < 0 || (size_t)start > max ||
	    (size_t)end > max || start > end)
		goto out;

	for (i = start, len = 0; i <= (size_t)end; i++)
		len += strlen(arr[i]) + 1;
	len++;
	max = len;
	result = malloc(len);
	if (result == NULL)
		goto out;

	for (i = start, len = 0; i <= (size_t)end; i++) {
		(void)strlcpy(result + len, arr[i], max - len);
		len += strlen(arr[i]);
		if (i < (size_t)end)
			result[len++] = ' ';
	}
	result[len] = '\0';

out:
	for (i = 0; arr[i]; i++)
		free(arr[i]);
	free(arr);

	return result;
}

/*
 * Parse the string into individual tokens,
 * similar to how shell would do it.
 */
char **
history_tokenize(const char *str)
{
	int size = 1, idx = 0, i, start;
	size_t len;
	char **result = NULL, *temp, delim = '\0';

	for (i = 0; str[i];) {
		while (isspace((unsigned char) str[i]))
			i++;
		start = i;
		for (; str[i];) {
			if (str[i] == '\\') {
				if (str[i+1] != '\0')
					i++;
			} else if (str[i] == delim)
				delim = '\0';
			else if (!delim &&
				    (isspace((unsigned char) str[i]) ||
				strchr("()<>;&|$", str[i])))
				break;
			else if (!delim && strchr("'`\"", str[i]))
				delim = str[i];
			if (str[i])
				i++;
		}

		if (idx + 2 >= size) {
			char **nresult;
			nresult = reallocarray(result, size,
			    2 * sizeof(char *));
			if (nresult == NULL) {
				free(result);
				return NULL;
			}
			size *= 2;
			result = nresult;
		}
		len = i - start;
		temp = malloc(len + 1);
		if (temp == NULL) {
			for (i = 0; i < idx; i++)
				free(result[i]);
			free(result);
			return NULL;
		}
		(void)strncpy(temp, &str[start], len);
		temp[len] = '\0';
		result[idx++] = temp;
		result[idx] = NULL;
		if (str[i])
			i++;
	}
	return result;
}


/*
 * limit size of history record to ``max'' events
 */
void
stifle_history(int max)
{
	HistEvent ev;
	HIST_ENTRY *he;
	int i, len;

	if (h == NULL || e == NULL)
		rl_initialize();

	len = history_length;
	if (history(h, &ev, H_SETSIZE, max) == 0) {
		max_input_history = max;
		if (max < len)
			history_base += len - max;
		for (i = 0; i < len - max; i++) {
			he = remove_history(0);
			free(he->data);
			free((void *)he->line);
			free(he);
		}
	}
}


/*
 * "unlimit" size of history - set the limit to maximum allowed int value
 */
int
unstifle_history(void)
{
	HistEvent ev;
	int omax;

	history(h, &ev, H_SETSIZE, INT_MAX);
	omax = max_input_history;
	max_input_history = INT_MAX;
	return omax;		/* some value _must_ be returned */
}


int
history_is_stifled(void)
{

	/* cannot return true answer */
	return max_input_history != INT_MAX;
}

static const char _history_tmp_template[] = "/tmp/.historyXXXXXX";

int
history_truncate_file (const char *filename, int nlines)
{
	int ret = 0;
	FILE *fp, *tp;
	char template[sizeof(_history_tmp_template)];
	char buf[4096];
	int fd;
	char *cp;
	off_t off;
	int count = 0;
	ssize_t left = 0;

	if (filename == NULL && (filename = _default_history_file()) == NULL)
		return errno;
	if ((fp = fopen(filename, "r+")) == NULL)
		return errno;
	strlcpy(template, _history_tmp_template, sizeof(template));
	if ((fd = mkstemp(template)) == -1) {
		ret = errno;
		goto out1;
	}

	if ((tp = fdopen(fd, "r+")) == NULL) {
		close(fd);
		ret = errno;
		goto out2;
	}

	for(;;) {
		if (fread(buf, sizeof(buf), 1, fp) != 1) {
			if (ferror(fp)) {
				ret = errno;
				break;
			}
			if (fseeko(fp, (off_t)sizeof(buf) * count, SEEK_SET) ==
			    (off_t)-1) {
				ret = errno;
				break;
			}
			left = fread(buf, 1, sizeof(buf), fp);
			if (ferror(fp)) {
				ret = errno;
				break;
			}
			if (left == 0) {
				count--;
				left = sizeof(buf);
			} else if (fwrite(buf, (size_t)left, 1, tp) != 1) {
				ret = errno;
				break;
			}
			fflush(tp);
			break;
		}
		if (fwrite(buf, sizeof(buf), 1, tp) != 1) {
			ret = errno;
			break;
		}
		count++;
	}
	if (ret)
		goto out3;
	cp = buf + left - 1;
	if(*cp != '\n')
		cp++;
	for(;;) {
		while (--cp >= buf) {
			if (*cp == '\n') {
				if (--nlines == 0) {
					if (++cp >= buf + sizeof(buf)) {
						count++;
						cp = buf;
					}
					break;
				}
			}
		}
		if (nlines <= 0 || count == 0)
			break;
		count--;
		if (fseeko(tp, (off_t)sizeof(buf) * count, SEEK_SET) < 0) {
			ret = errno;
			break;
		}
		if (fread(buf, sizeof(buf), 1, tp) != 1) {
			if (ferror(tp)) {
				ret = errno;
				break;
			}
			ret = EAGAIN;
			break;
		}
		cp = buf + sizeof(buf);
	}

	if (ret || nlines > 0)
		goto out3;

	if (fseeko(fp, 0, SEEK_SET) == (off_t)-1) {
		ret = errno;
		goto out3;
	}

	if (fseeko(tp, (off_t)sizeof(buf) * count + (cp - buf), SEEK_SET) ==
	    (off_t)-1) {
		ret = errno;
		goto out3;
	}

	for(;;) {
		if ((left = fread(buf, 1, sizeof(buf), tp)) == 0) {
			if (ferror(fp))
				ret = errno;
			break;
		}
		if (fwrite(buf, (size_t)left, 1, fp) != 1) {
			ret = errno;
			break;
		}
	}
	fflush(fp);
	if((off = ftello(fp)) > 0)
		(void)ftruncate(fileno(fp), off);
out3:
	fclose(tp);
out2:
	unlink(template);
out1:
	fclose(fp);

	return ret;
}


/*
 * read history from a file given
 */
int
read_history(const char *filename)
{
	HistEvent ev;

	if (h == NULL || e == NULL)
		rl_initialize();
	if (filename == NULL && (filename = _default_history_file()) == NULL)
		return errno;
	return history(h, &ev, H_LOAD, filename) == -1 ?
	    (errno ? errno : EINVAL) : 0;
}


/*
 * write history to a file given
 */
int
write_history(const char *filename)
{
	HistEvent ev;

	if (h == NULL || e == NULL)
		rl_initialize();
	if (filename == NULL && (filename = _default_history_file()) == NULL)
		return errno;
	return history(h, &ev, H_SAVE, filename) == -1 ?
	    (errno ? errno : EINVAL) : 0;
}


/*
 * returns history ``num''th event
 *
 * returned pointer points to static variable
 */
HIST_ENTRY *
history_get(int num)
{
	static HIST_ENTRY she;
	HistEvent ev;
	int curr_num;

	if (h == NULL || e == NULL)
		rl_initialize();

	if (num < history_base)
		return NULL;

	/* save current position */
	if (history(h, &ev, H_CURR) != 0)
		return NULL;
	curr_num = ev.num;

	/*
	 * use H_DELDATA to set to nth history (without delete) by passing
	 * (void **)-1  -- as in history_set_pos
	 */
	if (history(h, &ev, H_DELDATA, num - history_base, (void **)-1) != 0)
		goto out;

	/* get current entry */
	if (history(h, &ev, H_CURR) != 0)
		goto out;
	if (history(h, &ev, H_NEXT_EVDATA, ev.num, &she.data) != 0)
		goto out;
	she.line = ev.str;

	/* restore pointer to where it was */
	(void)history(h, &ev, H_SET, curr_num);

	return &she;

out:
	/* restore pointer to where it was */
	(void)history(h, &ev, H_SET, curr_num);
	return NULL;
}


/*
 * add the line to history table
 */
int
add_history(const char *line)
{
	HistEvent ev;

	if (h == NULL || e == NULL)
		rl_initialize();

	(void)history(h, &ev, H_ENTER, line);
	if (history(h, &ev, H_GETSIZE) == 0)
		history_length = ev.num;
	current_history_valid = 1;

	return !(history_length > 0); /* return 0 if all is okay */
}


/*
 * remove the specified entry from the history list and return it.
 */
HIST_ENTRY *
remove_history(int num)
{
	HIST_ENTRY *he;
	HistEvent ev;

	if (h == NULL || e == NULL)
		rl_initialize();

	if ((he = malloc(sizeof(*he))) == NULL)
		return NULL;

	if (history(h, &ev, H_DELDATA, num, &he->data) != 0) {
		free(he);
		return NULL;
	}

	he->line = ev.str;
	if (history(h, &ev, H_GETSIZE) == 0)
		history_length = ev.num;

	return he;
}


/*
 * replace the line and data of the num-th entry
 */
HIST_ENTRY *
replace_history_entry(int num, const char *line, histdata_t data)
{
	HIST_ENTRY *he;
	HistEvent ev;
	int curr_num;

	if (h == NULL || e == NULL)
		rl_initialize();

	/* save current position */
	if (history(h, &ev, H_CURR) != 0)
		return NULL;
	curr_num = ev.num;

	/* start from the oldest */
	if (history(h, &ev, H_LAST) != 0)
		return NULL;	/* error */

	if ((he = malloc(sizeof(*he))) == NULL)
		return NULL;

	/* look forwards for event matching specified offset */
	if (history(h, &ev, H_NEXT_EVDATA, num, &he->data))
		goto out;

	he->line = strdup(ev.str);
	if (he->line == NULL)
		goto out;

	if (history(h, &ev, H_REPLACE, line, data))
		goto out;

	/* restore pointer to where it was */
	if (history(h, &ev, H_SET, curr_num))
		goto out;

	return he;
out:
	free(he);
	return NULL;
}

/*
 * clear the history list - delete all entries
 */
void
clear_history(void)
{
	HistEvent ev;

	(void)history(h, &ev, H_CLEAR);
	history_length = 0;
	current_history_valid = 1;
}


/*
 * returns offset of the current history event
 */
int
where_history(void)
{
	HistEvent ev;
	int curr_num, off;

	if (history(h, &ev, H_CURR) != 0)
		return 0;
	curr_num = ev.num;

	/* start from the oldest */
	(void)history(h, &ev, H_LAST);

	/* position is zero-based */
	off = 0;
	while (ev.num != curr_num && history(h, &ev, H_PREV) == 0)
		off++;

	return off;
}


/*
 * returns current history event or NULL if there is no such event
 */
HIST_ENTRY *
current_history(void)
{

	return current_history_valid ? _move_history(H_CURR) : NULL;
}


/*
 * returns total number of bytes history events' data are using
 */
int
history_total_bytes(void)
{
	HistEvent ev;
	int curr_num;
	size_t size;

	if (history(h, &ev, H_CURR) != 0)
		return -1;
	curr_num = ev.num;

	(void)history(h, &ev, H_FIRST);
	size = 0;
	do
		size += strlen(ev.str) * sizeof(*ev.str);
	while (history(h, &ev, H_NEXT) == 0);

	/* get to the same position as before */
	history(h, &ev, H_PREV_EVENT, curr_num);

	return (int)size;
}


/*
 * sets the position in the history list to ``pos''
 */
int
history_set_pos(int pos)
{
	HistEvent ev;
	int curr_num;

	if (pos >= history_length || pos < 0)
		return 0;

	(void)history(h, &ev, H_CURR);
	curr_num = ev.num;
	current_history_valid = 1;

	/*
	 * use H_DELDATA to set to nth history (without delete) by passing
	 * (void **)-1
	 */
	if (history(h, &ev, H_DELDATA, pos, (void **)-1)) {
		(void)history(h, &ev, H_SET, curr_num);
		return 0;
	}
	return 1;
}


/*
 * returns previous event in history and shifts pointer accordingly
 * Note that readline and editline define directions in opposite ways.
 */
HIST_ENTRY *
previous_history(void)
{

	if (current_history_valid == 0) {
		current_history_valid = 1;
		return _move_history(H_CURR);
	}
	return _move_history(H_NEXT);
}


/*
 * returns next event in history and shifts pointer accordingly
 */
HIST_ENTRY *
next_history(void)
{
	HIST_ENTRY *he;

	he = _move_history(H_PREV);
	if (he == NULL)
		current_history_valid = 0;
	return he;
}


/*
 * searches for first history event containing the str
 */
int
history_search(const char *str, int direction)
{
	HistEvent ev;
	const char *strp;
	int curr_num;

	if (history(h, &ev, H_CURR) != 0)
		return -1;
	curr_num = ev.num;

	for (;;) {
		if ((strp = strstr(ev.str, str)) != NULL)
			return (int)(strp - ev.str);
		if (history(h, &ev, direction < 0 ? H_NEXT:H_PREV) != 0)
			break;
	}
	(void)history(h, &ev, H_SET, curr_num);
	return -1;
}


/*
 * searches for first history event beginning with str
 */
int
history_search_prefix(const char *str, int direction)
{
	HistEvent ev;

	return (history(h, &ev, direction < 0 ?
	    H_PREV_STR : H_NEXT_STR, str));
}


/*
 * search for event in history containing str, starting at offset
 * abs(pos); continue backward, if pos<0, forward otherwise
 */
/* ARGSUSED */
int
history_search_pos(const char *str,
		   int direction __attribute__((__unused__)), int pos)
{
	HistEvent ev;
	int curr_num, off;

	off = (pos > 0) ? pos : -pos;
	pos = (pos > 0) ? 1 : -1;

	if (history(h, &ev, H_CURR) != 0)
		return -1;
	curr_num = ev.num;

	if (!history_set_pos(off) || history(h, &ev, H_CURR) != 0)
		return -1;

	for (;;) {
		if (strstr(ev.str, str))
			return off;
		if (history(h, &ev, (pos < 0) ? H_PREV : H_NEXT) != 0)
			break;
	}

	/* set "current" pointer back to previous state */
	(void)history(h, &ev,
	    pos < 0 ? H_NEXT_EVENT : H_PREV_EVENT, curr_num);

	return -1;
}


/********************************/
/* completion functions */

char *
tilde_expand(char *name)
{
	return fn_tilde_expand(name);
}

char *
filename_completion_function(const char *name, int state)
{
	return fn_filename_completion_function(name, state);
}

/*
 * a completion generator for usernames; returns _first_ username
 * which starts with supplied text
 * text contains a partial username preceded by random character
 * (usually '~'); state is ignored
 * it's the caller's responsibility to free the returned value
 */
char *
username_completion_function(const char *text, int state)
{
	struct passwd *pwd;

	if (text[0] == '\0')
		return NULL;

	if (*text == '~')
		text++;

	if (state == 0)
		setpwent();

	while ((pwd = getpwent()) != NULL && text[0] == pwd->pw_name[0]
	    && strcmp(text, pwd->pw_name) == 0);

	if (pwd == NULL) {
		endpwent();
		return NULL;
	}
	return strdup(pwd->pw_name);
}


/*
 * el-compatible wrapper to send TSTP on ^Z
 */
/* ARGSUSED */
static unsigned char
_el_rl_tstp(EditLine *el __attribute__((__unused__)), int ch __attribute__((__unused__)))
{
	(void)kill(0, SIGTSTP);
	return CC_NORM;
}

/*
 * Display list of strings in columnar format on readline's output stream.
 * 'matches' is list of strings, 'len' is number of strings in 'matches',
 * 'max' is maximum length of string in 'matches'.
 */
void
rl_display_match_list(char **matches, int len, int max)
{

	fn_display_match_list(e, matches, (size_t)len, (size_t)max);
}

static const char *
/*ARGSUSED*/
_rl_completion_append_character_function(const char *dummy
    __attribute__((__unused__)))
{
	static char buf[2];
	buf[0] = rl_completion_append_character;
	buf[1] = '\0';
	return buf;
}


/*
 * complete word at current point
 */
/* ARGSUSED */
int
rl_complete(int ignore __attribute__((__unused__)), int invoking_key)
{
	static ct_buffer_t wbreak_conv, sprefix_conv;

	if (h == NULL || e == NULL)
		rl_initialize();

	if (rl_inhibit_completion) {
		char arr[2];
		arr[0] = (char)invoking_key;
		arr[1] = '\0';
		el_insertstr(e, arr);
		return CC_REFRESH;
	}

	/* Just look at how many global variables modify this operation! */
	return fn_complete(e,
	    (CPFunction *)rl_completion_entry_function,
	    rl_attempted_completion_function,
	    ct_decode_string(rl_basic_word_break_characters, &wbreak_conv),
	    ct_decode_string(rl_special_prefixes, &sprefix_conv),
	    _rl_completion_append_character_function,
	    (size_t)rl_completion_query_items,
	    &rl_completion_type, &rl_attempted_completion_over,
	    &rl_point, &rl_end);


}


/* ARGSUSED */
static unsigned char
_el_rl_complete(EditLine *el __attribute__((__unused__)), int ch)
{
	return (unsigned char)rl_complete(0, ch);
}

/*
 * misc other functions
 */

/*
 * bind key c to readline-type function func
 */
int
rl_bind_key(int c, rl_command_func_t *func)
{
	int retval = -1;

	if (h == NULL || e == NULL)
		rl_initialize();

	if (func == rl_insert) {
		/* XXX notice there is no range checking of ``c'' */
		e->el_map.key[c] = ED_INSERT;
		retval = 0;
	}
	return retval;
}


/*
 * read one key from input - handles chars pushed back
 * to input stream also
 */
int
rl_read_key(void)
{
	char fooarr[2 * sizeof(int)];

	if (e == NULL || h == NULL)
		rl_initialize();

	return el_getc(e, fooarr);
}


/*
 * reset the terminal
 */
/* ARGSUSED */
void
rl_reset_terminal(const char *p __attribute__((__unused__)))
{

	if (h == NULL || e == NULL)
		rl_initialize();
	el_reset(e);
}


/*
 * insert character ``c'' back into input stream, ``count'' times
 */
int
rl_insert(int count, int c)
{
	char arr[2];

	if (h == NULL || e == NULL)
		rl_initialize();

	/* XXX - int -> char conversion can lose on multichars */
	arr[0] = c;
	arr[1] = '\0';

	for (; count > 0; count--)
		el_push(e, arr);

	return 0;
}

int
rl_insert_text(const char *text)
{
	if (!text || *text == 0)
		return 0;

	if (h == NULL || e == NULL)
		rl_initialize();

	if (el_insertstr(e, text) < 0)
		return 0;
	return (int)strlen(text);
}

/*ARGSUSED*/
int
rl_newline(int count, int c)
{
	/*
	 * Readline-4.0 appears to ignore the args.
	 */
	return rl_insert(1, '\n');
}

/*ARGSUSED*/
static unsigned char
rl_bind_wrapper(EditLine *el, unsigned char c)
{
	if (map[c] == NULL)
	    return CC_ERROR;

	_rl_update_pos();

	(*map[c])(NULL, c);

	/* If rl_done was set by the above call, deal with it here */
	if (rl_done)
		return CC_EOF;

	return CC_NORM;
}

int
rl_add_defun(const char *name, Function *fun, int c)
{
	char dest[8];
	if ((size_t)c >= sizeof(map) / sizeof(map[0]) || c < 0)
		return -1;
	map[(unsigned char)c] = fun;
	el_set(e, EL_ADDFN, name, name, rl_bind_wrapper);
	vis(dest, c, VIS_WHITE|VIS_NOSLASH, 0);
	el_set(e, EL_BIND, dest, name, NULL);
	return 0;
}

void
rl_callback_read_char()
{
	int count = 0, done = 0;
	const char *buf = el_gets(e, &count);
	char *wbuf;

	if (buf == NULL || count-- <= 0)
		return;
	if (count == 0 && buf[0] == e->el_tty.t_c[TS_IO][C_EOF])
		done = 1;
	if (buf[count] == '\n' || buf[count] == '\r')
		done = 2;

	if (done && rl_linefunc != NULL) {
		el_set(e, EL_UNBUFFERED, 0);
		if (done == 2) {
		    if ((wbuf = strdup(buf)) != NULL)
			wbuf[count] = '\0';
		} else
			wbuf = NULL;
		(*(void (*)(const char *))rl_linefunc)(wbuf);
		//el_set(e, EL_UNBUFFERED, 1);
	}
}

void
rl_callback_handler_install(const char *prompt, VCPFunction *linefunc)
{
	if (e == NULL) {
		rl_initialize();
	}
	(void)rl_set_prompt(prompt);
	rl_linefunc = linefunc;
	el_set(e, EL_UNBUFFERED, 1);
}

void
rl_callback_handler_remove(void)
{
	el_set(e, EL_UNBUFFERED, 0);
	rl_linefunc = NULL;
}

void
rl_redisplay(void)
{
	char a[2];
	a[0] = e->el_tty.t_c[TS_IO][C_REPRINT];
	a[1] = '\0';
	el_push(e, a);
}

int
rl_get_previous_history(int count, int key)
{
	char a[2];
	a[0] = key;
	a[1] = '\0';
	while (count--)
		el_push(e, a);
	return 0;
}

void
/*ARGSUSED*/
rl_prep_terminal(int meta_flag)
{
	el_set(e, EL_PREP_TERM, 1);
}

void
rl_deprep_terminal(void)
{
	el_set(e, EL_PREP_TERM, 0);
}

int
rl_read_init_file(const char *s)
{
	return el_source(e, s);
}

int
rl_parse_and_bind(const char *line)
{
	const char **argv;
	int argc;
	Tokenizer *tok;

	tok = tok_init(NULL);
	tok_str(tok, line, &argc, &argv);
	argc = el_parse(e, argc, argv);
	tok_end(tok);
	return argc ? 1 : 0;
}

int
rl_variable_bind(const char *var, const char *value)
{
	/*
	 * The proper return value is undocument, but this is what the
	 * readline source seems to do.
	 */
	return el_set(e, EL_BIND, "", var, value, NULL) == -1 ? 1 : 0;
}

void
rl_stuff_char(int c)
{
	char buf[2];

	buf[0] = c;
	buf[1] = '\0';
	el_insertstr(e, buf);
}

static int
_rl_event_read_char(EditLine *el, wchar_t *wc)
{
	char	ch;
	int	n;
	ssize_t num_read = 0;

	ch = '\0';
	*wc = L'\0';
	while (rl_event_hook) {

		(*rl_event_hook)();

#if defined(FIONREAD)
		if (ioctl(el->el_infd, FIONREAD, &n) < 0)
			return -1;
		if (n)
			num_read = read(el->el_infd, &ch, 1);
		else
			num_read = 0;
#elif defined(F_SETFL) && defined(O_NDELAY)
		if ((n = fcntl(el->el_infd, F_GETFL)) < 0)
			return -1;
		if (fcntl(el->el_infd, F_SETFL, n|O_NDELAY) < 0)
			return -1;
		num_read = read(el->el_infd, &ch, 1);
		if (fcntl(el->el_infd, F_SETFL, n))
			return -1;
#else
		/* not non-blocking, but what you gonna do? */
		num_read = read(el->el_infd, &ch, 1);
		return -1;
#endif

		if (num_read < 0 && errno == EAGAIN)
			continue;
		if (num_read == 0)
			continue;
		break;
	}
	if (!rl_event_hook)
		el_set(el, EL_GETCFN, EL_BUILTIN_GETCFN);
	*wc = (wchar_t)ch;
	return (int)num_read;
}

static void
_rl_update_pos(void)
{
	const LineInfo *li = el_line(e);

	rl_point = (int)(li->cursor - li->buffer);
	rl_end = (int)(li->lastchar - li->buffer);
}

void
rl_get_screen_size(int *rows, int *cols)
{
	if (rows)
		el_get(e, EL_GETTC, "li", rows);
	if (cols)
		el_get(e, EL_GETTC, "co", cols);
}

void
rl_set_screen_size(int rows, int cols)
{
	char buf[64];
	(void)snprintf(buf, sizeof(buf), "%d", rows);
	el_set(e, EL_SETTC, "li", buf, NULL);
	(void)snprintf(buf, sizeof(buf), "%d", cols);
	el_set(e, EL_SETTC, "co", buf, NULL);
}

char **
rl_completion_matches(const char *str, rl_compentry_func_t *fun)
{
	size_t len, max, i, j, min;
	char **list, *match, *a, *b;

	len = 1;
	max = 10;
	if ((list = reallocarray(NULL, max, sizeof(*list))) == NULL)
		return NULL;

	while ((match = (*fun)(str, (int)(len - 1))) != NULL) {
		list[len++] = match;
		if (len == max) {
			char **nl;
			max += 10;
			if ((nl = reallocarray(list, max, sizeof(*nl))) == NULL)
				goto out;
			list = nl;
		}
	}
	if (len == 1)
		goto out;
	list[len] = NULL;
	if (len == 2) {
		if ((list[0] = strdup(list[1])) == NULL)
			goto out;
		return list;
	}
	qsort(&list[1], len - 1, sizeof(*list),
	    (int (*)(const void *, const void *)) strcmp);
	min = SIZE_MAX;
	for (i = 1, a = list[i]; i < len - 1; i++, a = b) {
		b = list[i + 1];
		for (j = 0; a[j] && a[j] == b[j]; j++)
			continue;
		if (min > j)
			min = j;
	}
	if (min == 0 && *str) {
		if ((list[0] = strdup(str)) == NULL)
			goto out;
	} else {
		if ((list[0] = malloc(min + 1)) == NULL)
			goto out;
		(void)memcpy(list[0], list[1], min);
		list[0][min] = '\0';
	}
	return list;

out:
	free(list);
	return NULL;
}

char *
rl_filename_completion_function (const char *text, int state)
{
	return fn_filename_completion_function(text, state);
}

void
rl_forced_update_display(void)
{
	el_set(e, EL_REFRESH);
}

int
_rl_abort_internal(void)
{
	el_beep(e);
	longjmp(topbuf, 1);
	/*NOTREACHED*/
}

int
_rl_qsort_string_compare(char **s1, char **s2)
{
	return strcoll(*s1, *s2);
}

HISTORY_STATE *
history_get_history_state(void)
{
	HISTORY_STATE *hs;

	if ((hs = malloc(sizeof(HISTORY_STATE))) == NULL)
		return NULL;
	hs->length = history_length;
	return hs;
}

int
/*ARGSUSED*/
rl_kill_text(int from, int to)
{
	return 0;
}

Keymap
rl_make_bare_keymap(void)
{
	return NULL;
}

Keymap
rl_get_keymap(void)
{
	return NULL;
}

void
/*ARGSUSED*/
rl_set_keymap(Keymap k)
{
}

int
/*ARGSUSED*/
rl_generic_bind(int type, const char * keyseq, const char * data, Keymap k)
{
	return 0;
}

int
/*ARGSUSED*/
rl_bind_key_in_map(int key, rl_command_func_t *fun, Keymap k)
{
	return 0;
}

/* unsupported, but needed by python */
void
rl_cleanup_after_signal(void)
{
}

int
rl_on_new_line(void)
{
	return 0;
}

int
/*ARGSUSED*/
rl_set_keyboard_input_timeout(int u __attribute__((__unused__)))
{
	return 0;
}
@


1.26
log
@Fix next_history() and previous_history():
* The meaning of "next" and "previous" is exchanged in readline(3) with
respect to editline(3); this part of the patch from Bastian Maerkisch.
* next_history() can move beyond the newest entry; issue pointed out
by Bastian Maerkisch, fix by me.

While here, make the documentation of ed-next-history, ed-prev-history,
H_NEXT, and H_PREV more precise.

OK czarkoff@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.25 2016/05/10 10:49:37 schwarze Exp $	*/
d1152 1
a1152 1
			he = remove_history(i);
@


1.25
log
@Fix history_get():
* Respect history_base.
* Bail out early for arguments that are too small.
* Select entry by readline offset, not by editline event number.
* Restore history cursor in case of failure.
This fixes the test_remove() regression test.

Based on a patch from Bastian Maerkisch <bmaerkisch at web dot de>.
Dmitrij Czarkoff pointed out a flaw in it that i fixed.
OK czarkoff@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.24 2016/05/09 12:31:55 schwarze Exp $	*/
d152 8
d291 2
d1419 1
d1509 1
d1545 1
a1545 1
	return _move_history(H_CURR);
d1590 1
d1606 1
d1612 5
a1616 1
	return _move_history(H_PREV);
d1626 1
d1628 4
a1631 1
	return _move_history(H_NEXT);
@


1.24
log
@Fix stifle_history(): Remove excessive entries, if any.
Based on a patch from Bastian Maerkisch <bmaerkisch at web dot de>,
with an additional fix for a memory leak by me.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.23 2016/05/08 13:52:33 schwarze Exp $	*/
d1361 3
d1369 6
a1374 7
	/* start from the oldest */
	if (history(h, &ev, H_LAST) != 0)
		return NULL;	/* error */

	/* look forwards for event matching specified offset */
	if (history(h, &ev, H_NEXT_EVDATA, num, &she.data))
		return NULL;
d1376 5
d1387 5
@


1.23
log
@Change where_history() to agree with the GNU implementation:
Return 0 for the oldest entry and increment by 1 for each newer,
non-deleted entry.
This fixes the test_where() regression test.

Patch from Bastian Maerkisch <bmaerkisch at web dot de>.
OK czarkoff@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.22 2016/05/08 13:34:35 schwarze Exp $	*/
d1130 2
d1136 2
a1137 1
	if (history(h, &ev, H_SETSIZE, max) == 0)
d1139 9
@


1.22
log
@Make the history_set_pos() return values agree with the GNU implementation.
Patch from Bastian Maerkisch <bmaerkisch at web dot de>
with a minor tweak from Christos Zoulas.
Fixes the test_set_pos_return_values() regression test.

OK czarkoff@@,
also proofread by zhuk@@ and by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.21 2016/05/06 13:12:52 schwarze Exp $	*/
d1490 6
a1495 3
	(void)history(h, &ev, H_FIRST);
	off = 1;
	while (ev.num != curr_num && history(h, &ev, H_NEXT) == 0)
@


1.21
log
@Replace the generated file "fcns.c" by a simpler header "func.h"
included only in the one file needing it, "map.c".
That allows to define el_action_t directly in "map.h",
which in turn allows to stop including "fcns.h" from "el.h"
and include it only in the modules needing it.
Now we no longer autogenerate any C files.

Feedback and OK martijn@@.
First version also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.20 2016/04/09 19:31:55 schwarze Exp $	*/
d1547 1
a1547 1
		return -1;
d1558 1
a1558 1
		return -1;
d1560 1
a1560 1
	return 0;
d1643 1
a1643 1
	if (history_set_pos(off) != 0 || history(h, &ev, H_CURR) != 0)
@


1.20
log
@Always compile with WIDECHAR on and delete that preprocessor switch.
OK martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.19 2016/03/21 17:28:10 schwarze Exp $	*/
d56 1
@


1.19
log
@Make the read_char() function always take a wchar_t * argument.

On first sight, it might look as if this required a bump because
it seems to change the public type el_rfunc_t.  But we only compile
with WIDECHAR, and in that case, there is no change in the interface.

This also simplifies some logic by getting rid of the NARROW_READ flag
which was broken anyway.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.18 2016/03/20 23:48:27 schwarze Exp $	*/
a1748 1
#ifdef WIDECHAR
a1749 1
#endif
@


1.18
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.17 2016/03/20 22:57:59 schwarze Exp $	*/
d162 1
a162 1
static int		 _getc_function(EditLine *, char *);
d168 1
a168 1
static int		 _rl_event_read_char(EditLine *, char *);
d205 1
a205 1
_getc_function(EditLine *el, char *c)
d212 1
a212 1
	*c = i;
d2034 1
a2034 1
_rl_event_read_char(EditLine *el, char *cp)
d2036 1
d2040 2
a2041 1
	*cp = '\0';
d2050 1
a2050 1
			num_read = read(el->el_infd, cp, 1);
d2058 1
a2058 1
		num_read = read(el->el_infd, cp, 1);
d2063 1
a2063 1
		num_read = read(el->el_infd, cp, 1);
d2075 1
@


1.17
log
@Cleanup of private header inclusion:

1. Do not include private headers from "chared.h", "hist.h", "prompt.h",
"refresh.h", "search.h", "sig.h", "terminal.h", "tty.h".
The only private header having to include other private headers is "el.h".
2. Do not include "common.h", "parse.h", "help.h" from "el.h",
and do not include "emacs.h" and "vi.h" from "chared.h",
include them directly where needed.
3. Do include "fcns.h" from "el.h" because el_func_t is needed for "map.h".
4. Do not include private headers again that are already included by "el.h".
5. Include private headers after standard headers.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.16 2016/03/20 00:01:21 krw Exp $	*/
d37 7
d46 1
a46 1
#include <dirent.h>
a47 3
#include <pwd.h>
#include <ctype.h>
#include <stdlib.h>
a48 4
#include <limits.h>
#include <errno.h>
#include <fcntl.h>
#include <setjmp.h>
d258 1
a258 1
	if (rl_prompt != NULL && strcmp(rl_prompt, prompt) == 0) 
d352 1
a352 1
		
d1942 1
a1942 1
void 
d1951 1
a1951 1
}   
d1953 1
a1953 1
void 
d2153 1
a2153 1
		
@


1.16
log
@Currently we have about a 50/50 split over fcntl(n, F_GETFL [,0])
idioms.

Adopt the more concise fcntl(n, F_GETFL) over fcntl(n, F_GETFL, 0)
where it is obvious further investigation will not yield and
even better way.

Obviousness evaluation and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.15 2016/01/30 12:22:20 schwarze Exp $	*/
a55 2
#include "fcns.h"		/* for EL_NUM_FCNS */
#include "histedit.h"
d2249 1
a2249 1
rl_set_keyboard_input_timeout(int u)
@


1.15
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.14 2015/02/06 23:21:58 millert Exp $	*/
d2054 1
a2054 1
		if ((n = fcntl(el->el_infd, F_GETFL, 0)) < 0)
@


1.14
log
@SIZE_MAX is standard, we should be using it in preference to the
obsolete SIZE_T_MAX.  OK miod@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.13 2015/01/13 08:33:12 reyk Exp $	*/
d179 1
a179 1
	return (rl_prompt);
d193 1
a193 1
		return (HIST_ENTRY *) NULL;
d198 1
a198 1
	return (&rl_he);
d307 1
a307 1
		return (-1);
d368 1
a368 1
	return (0);
d488 1
a488 1
				return(result);
d494 1
a494 1
	return(result);
d511 1
a511 1
		return(NULL);
d516 1
a516 1
			return(NULL);
d538 1
a538 1
			return(NULL);
d541 1
a541 1
		return(rl_he->line);
d565 1
a565 1
		return(NULL);
d576 1
a576 1
		return (NULL);
d596 1
a596 1
		return(NULL);
d609 1
a609 1
		return(NULL);
d627 1
a627 1
 * it's callers responsibility to free() string returned in *result
d676 1
a676 1
		return(-1);
d684 1
a684 1
		return(1);
d730 1
a730 1
			return(-1);
d740 1
a740 1
		return(1);
d815 1
a815 1
						return (-1);
d869 1
a869 1
	return (p_on? 2:1);
d888 1
a888 1
		return(0);
d1004 1
a1004 1
	return (ret);
d1120 1
a1120 1
	return (result);
d1152 1
a1152 1
	return (omax);		/* some value _must_ be returned */
d1161 1
a1161 1
	return (max_input_history != INT_MAX);
d1313 2
a1314 2
	return (history(h, &ev, H_LOAD, filename) == -1 ?
	    (errno ? errno : EINVAL) : 0);
d1330 2
a1331 2
	return (history(h, &ev, H_SAVE, filename) == -1 ?
	    (errno ? errno : EINVAL) : 0);
d1352 1
a1352 1
		return (NULL);
d1357 1
a1357 1
		return (NULL);	/* error */
d1361 1
a1361 1
		return (NULL);
d1368 1
a1368 1
	return (&she);
d1387 1
a1387 1
	return (!(history_length > 0)); /* return 0 if all is okay */
d1488 1
a1488 1
		return (0);
d1496 1
a1496 1
	return (off);
d1507 1
a1507 1
	return (_move_history(H_CURR));
d1522 1
a1522 1
		return (-1);
d1534 1
a1534 1
	return (int)(size);
d1548 1
a1548 1
		return (-1);
d1559 1
a1559 1
		return(-1);
d1561 1
a1561 1
	return (0);
d1572 1
a1572 1
	return (_move_history(H_PREV));
d1583 1
a1583 1
	return (_move_history(H_NEXT));
d1598 1
a1598 1
		return (-1);
d1603 1
a1603 1
			return (int) (strp - ev.str);
d1608 1
a1608 1
	return (-1);
d1641 1
a1641 1
		return (-1);
d1645 1
a1645 1
		return (-1);
d1649 1
a1649 1
			return (off);
d1658 1
a1658 1
	return (-1);
d1682 1
a1682 1
 * it's callers responsibility to free returned value
d1690 1
a1690 1
		return (NULL);
d1763 1
a1763 1
		return (CC_REFRESH);
d1808 1
a1808 1
	return (retval);
d1824 1
a1824 1
	return (el_getc(e, fooarr));
d1860 1
a1860 1
	return (0);
d1867 1
a1867 1
		return (0);
d1873 1
a1873 1
		return (0);
d1998 1
a1998 1
	return(el_source(e, s));
d2012 1
a2012 1
	return (argc ? 1 : 0);
d2022 1
a2022 1
	return ((el_set(e, EL_BIND, "", var, value, NULL) == -1) ? 1 : 0);
d2048 1
a2048 1
			return(-1);
d2055 1
a2055 1
			return(-1);
d2057 1
a2057 1
			return(-1);
d2060 1
a2060 1
			return(-1);
d2064 1
a2064 1
		return(-1);
d2193 1
a2193 1
		return (NULL);
d2195 1
a2195 1
	return (hs);
@


1.13
log
@libedit claims compatibility with readline 4.2, so provide a stub for
rl_set_keyboard_input_timeout() that was added in this version.
Also crank the minor version.

OK krw@@ yasuoka@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.12 2014/10/15 10:55:11 deraadt Exp $	*/
d37 1
d2137 1
a2137 1
	min = SIZE_T_MAX;
@


1.12
log
@use reallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.11 2014/10/11 04:24:06 doug Exp $	*/
d2244 7
@


1.11
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.10 2011/07/08 05:41:11 nicm Exp $	*/
d789 2
a790 2
						nwhat = realloc(what,
								(size <<= 1));
d796 1
d2113 1
a2113 1
	if ((list = malloc(max * sizeof(*list))) == NULL)
d2121 1
a2121 1
			if ((nl = realloc(list, max * sizeof(*nl))) == NULL)
@


1.10
log
@el_set EL_BIND or EL_SETTC must have argument lists ending with NULL.

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.9 2011/07/07 05:40:42 okan Exp $	*/
d1094 2
a1095 2
			size <<= 1;
			nresult = realloc(result, size * sizeof(char *));
d1100 1
@


1.9
log
@sync with upstream, retaining local modifications.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.8 2010/06/30 00:05:35 nicm Exp $	*/
d1911 1
a1911 1
	el_set(e, EL_BIND, dest, name);
d2019 1
a2019 1
	return ((el_set(e, EL_BIND, "", var, value) == -1) ? 1 : 0);
d2098 1
a2098 1
	el_set(e, EL_SETTC, "li", buf);
d2100 1
a2100 1
	el_set(e, EL_SETTC, "co", buf);
@


1.8
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: readline.c,v 1.89 2010/04/15 00:57:33 christos Exp $	*/
a121 4
#ifdef WIDECHAR
static ct_buffer_t conv;
#endif

d154 1
a154 1
static TYPE(History) *h = NULL;
d188 1
a188 1
	TYPE(HistEvent) ev;
d191 1
a191 1
	if (FUNW(history)(h, &ev, op) != 0)
d194 1
a194 1
	rl_he.line = ct_encode_string(ev.str, &conv);
d217 11
d279 1
a279 2
	TYPE(HistEvent) ev;
	const LineInfo *li;
d286 1
a286 1
		FUN(history,end)(h);
d302 1
a302 1
		FUN(el,set)(e, EL_EDITMODE, 0);
d304 1
a304 1
	h = FUN(history,init)();
d308 1
a308 1
	FUNW(history)(h, &ev, H_SETSIZE, INT_MAX);	/* unlimited */
d313 3
d322 1
a322 1
		FUN(history,end)(h);
d361 1
a361 3
	li = el_line(e);
	/* a cheesy way to get rid of const cast. */
	rl_line_buffer = memchr(li->buffer, *li->buffer, 1);
d378 1
a378 1
	TYPE(HistEvent) ev;
d426 1
a426 1
	FUNW(history)(h, &ev, H_GETSIZE);
d506 1
a506 1
	TYPE(HistEvent) ev;
d514 1
a514 1
		if (FUNW(history)(h, &ev, H_FIRST) != 0)
d517 1
a517 1
		return ct_encode_string(ev.str, &conv);
d572 1
a572 1
	if (FUNW(history)(h, &ev, H_CURR) != 0) {
d591 1
a591 1
		FUNW(history)(h, &ev, H_FIRST);
d607 1
a607 1
	if (FUNW(history)(h, &ev, H_CURR) != 0)
d610 1
a610 1
	rptr = ct_encode_string(ev.str, &conv);
d613 1
a613 1
	(void)FUNW(history)(h, &ev, H_SET, num);
d1127 1
a1127 1
	TYPE(HistEvent) ev;
d1132 1
a1132 1
	if (FUNW(history)(h, &ev, H_SETSIZE, max) == 0)
d1143 1
a1143 1
	TYPE(HistEvent) ev;
d1146 1
a1146 1
	FUNW(history)(h, &ev, H_SETSIZE, INT_MAX);
d1304 1
a1304 1
	TYPE(HistEvent) ev;
d1310 1
a1310 1
	return (FUNW(history)(h, &ev, H_LOAD, filename) == -1 ?
d1321 1
a1321 1
	TYPE(HistEvent) ev;
d1327 1
a1327 1
	return (FUNW(history)(h, &ev, H_SAVE, filename) == -1 ?
d1341 1
a1341 1
	TYPE(HistEvent) ev;
d1348 1
a1348 1
	if (FUNW(history)(h, &ev, H_CURR) != 0)
d1353 1
a1353 1
	if (FUNW(history)(h, &ev, H_LAST) != 0)
d1357 1
a1357 1
	if (FUNW(history)(h, &ev, H_NEXT_EVDATA, num, &she.data))
d1360 1
a1360 1
	she.line = ct_encode_string(ev.str, &conv);
d1363 1
a1363 1
	(void)FUNW(history)(h, &ev, H_SET, curr_num);
d1375 1
a1375 2
	TYPE(HistEvent) ev;
	const Char *wline;
d1380 2
a1381 4
	wline = ct_decode_string(line, &conv);

	(void)FUNW(history)(h, &ev, H_ENTER, wline);
	if (FUNW(history)(h, &ev, H_GETSIZE) == 0)
d1395 1
a1395 1
	TYPE(HistEvent) ev;
d1403 1
a1403 1
	if (FUNW(history)(h, &ev, H_DELDATA, num, &he->data) != 0) {
d1408 2
a1409 2
	he->line = ct_encode_string(ev.str, &conv);
	if (FUNW(history)(h, &ev, H_GETSIZE) == 0)
d1423 1
a1423 1
	TYPE(HistEvent) ev;
d1430 1
a1430 1
	if (FUNW(history)(h, &ev, H_CURR) != 0)
d1435 1
a1435 1
	if (FUNW(history)(h, &ev, H_LAST) != 0)
d1442 1
a1442 1
	if (FUNW(history)(h, &ev, H_NEXT_EVDATA, num, &he->data))
d1445 1
a1445 1
	he->line = strdup(ct_encode_string(ev.str, &e->el_scratch));
d1449 1
a1449 1
	if (FUNW(history)(h, &ev, H_REPLACE, line, data))
d1453 1
a1453 1
	if (FUNW(history)(h, &ev, H_SET, curr_num))
d1468 1
a1468 1
	TYPE(HistEvent) ev;
d1470 1
a1470 1
	(void)FUNW(history)(h, &ev, H_CLEAR);
d1481 1
a1481 1
	TYPE(HistEvent) ev;
d1484 1
a1484 1
	if (FUNW(history)(h, &ev, H_CURR) != 0)
d1488 1
a1488 1
	(void)FUNW(history)(h, &ev, H_FIRST);
d1490 1
a1490 1
	while (ev.num != curr_num && FUNW(history)(h, &ev, H_NEXT) == 0)
d1514 1
a1514 1
	TYPE(HistEvent) ev;
d1518 1
a1518 1
	if (FUNW(history)(h, &ev, H_CURR) != 0)
d1522 1
a1522 1
	(void)FUNW(history)(h, &ev, H_FIRST);
d1525 2
a1526 2
		size += Strlen(ev.str) * sizeof(*ev.str);
	while (FUNW(history)(h, &ev, H_NEXT) == 0);
d1529 1
a1529 1
	FUNW(history)(h, &ev, H_PREV_EVENT, curr_num);
d1541 1
a1541 1
	TYPE(HistEvent) ev;
d1547 1
a1547 1
	(void)FUNW(history)(h, &ev, H_CURR);
d1554 2
a1555 2
	if (FUNW(history)(h, &ev, H_DELDATA, pos, (void **)-1)) {
		(void)FUNW(history)(h, &ev, H_SET, curr_num);
d1590 2
a1591 3
	TYPE(HistEvent) ev;
	const Char *strp;
	const Char *wstr;
d1594 1
a1594 1
	if (FUNW(history)(h, &ev, H_CURR) != 0)
a1597 1
	wstr = ct_decode_string(str, &conv);
d1599 1
a1599 1
		if ((strp = Strstr(ev.str, wstr)) != NULL)
d1601 1
a1601 1
		if (FUNW(history)(h, &ev, direction < 0 ? H_NEXT:H_PREV) != 0)
d1604 1
a1604 1
	(void)FUNW(history)(h, &ev, H_SET, curr_num);
d1615 1
a1615 1
	TYPE(HistEvent) ev;
d1617 1
a1617 1
	return (FUNW(history)(h, &ev, direction < 0 ?
d1631 1
a1631 1
	TYPE(HistEvent) ev;
a1632 1
	const Char *wstr;
d1637 1
a1637 1
	if (FUNW(history)(h, &ev, H_CURR) != 0)
d1641 1
a1641 1
	if (history_set_pos(off) != 0 || FUNW(history)(h, &ev, H_CURR) != 0)
a1643 1
	wstr = ct_decode_string(str, &conv);
d1645 1
a1645 1
		if (Strstr(ev.str, wstr))
d1647 1
a1647 1
		if (FUNW(history)(h, &ev, (pos < 0) ? H_PREV : H_NEXT) != 0)
d1652 1
a1652 1
	(void)FUNW(history)(h, &ev,
d1773 2
d2238 6
@


1.7
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
a2 2
/*	$OpenBSD: readline.c,v 1.6 2009/06/21 00:38:22 martynas Exp $ */
/*	$NetBSD: readline.c,v 1.43 2003/11/03 03:22:55 christos Exp $	*/
d47 1
a52 4
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#endif
#include "histedit.h"
a54 1
#include "tokenizer.h"
d56 5
d71 1
d82 1
a82 1
VFunction *rl_linefunc = NULL;
d85 3
d107 1
a107 1
Function *rl_getc_function = NULL;
d113 2
d118 7
a124 2
VFunction *rl_prep_term_function = NULL;
VFunction *rl_deprep_term_function = NULL;
d148 1
a148 1
char *rl_special_prefixes = (char *)NULL;
d158 1
a158 4
/* if not zero, non-unique completions always show list of possible matches */
static int _rl_complete_show_all = 0;

static History *h = NULL;
d161 1
a161 1
static int el_rl_complete_cmdnum = 0;
d165 1
d167 1
a172 2
static int		 rl_complete_internal(int);
static int		 _rl_qsort_string_compare(const void *, const void *);
d174 1
d192 1
a192 1
	HistEvent ev;
d195 1
a195 1
	if (history(h, &ev, op) != 0)
d198 1
a198 1
	rl_he.line = ev.str;
d206 33
d243 24
d272 1
a272 1
	HistEvent ev;
a273 1
	int i;
d280 1
a280 1
		history_end(h);
d296 1
a296 1
		el_set(e, EL_EDITMODE, 0);
d298 1
a298 1
	h = history_init();
d302 1
a302 1
	history(h, &ev, H_SETSIZE, INT_MAX);	/* unlimited */
d307 4
d312 2
a313 3
	rl_prompt = strdup("");
	if (rl_prompt == NULL) {
		history_end(h);
d317 1
a317 1
	el_set(e, EL_PROMPT, _get_prompt);
d321 1
a321 1
	/* so this can be overridden */
d336 1
d338 1
a338 2
	 * Find out where the rl_complete function was added; this is
	 * used later to detect that lastcmd was also rl_complete.
d340 4
a343 6
	for(i=EL_NUM_FCNS; i < e->el_map.nfunc; i++) {
		if (e->el_map.func[i] == _el_rl_complete) {
			el_rl_complete_cmdnum = i;
			break;
		}
	}
d355 1
a355 1
	rl_point = rl_end = 0;
d369 1
a369 1
readline(const char *prompt)
d371 2
a372 1
	HistEvent ev;
d383 2
d386 2
a387 8
	if (!prompt)
		prompt = "";
	if (strcmp(rl_prompt, prompt) != 0) {
		free(rl_prompt);
		rl_prompt = strdup(prompt);
		if (rl_prompt == NULL)
			return NULL;
	}
d419 1
a419 1
	history(h, &ev, H_GETSIZE);
d469 1
a469 2
	len++;
	r = result = malloc(len);
a476 1
			len -= with_len;
d485 1
a485 1
	*r = 0;
d499 1
a499 1
	HistEvent ev;
d506 2
a507 2
	if (cmd[idx] == history_expansion_char || cmd[idx] == 0) {
		if (history(h, &ev, H_FIRST) != 0)
d510 1
a510 1
		return(ev.str);
d565 1
a565 1
	if (history(h, &ev, H_CURR) != 0) {
d584 1
a584 1
		history(h, &ev, H_FIRST);
d600 1
a600 1
	if (history(h, &ev, H_CURR) != 0)
d603 1
a603 1
	rptr = ev.str;
d606 1
a606 1
	(void)history(h, &ev, H_SET, num);
d671 1
a671 1
		*result = strdup(aptr? aptr : ptr);
d674 2
d730 1
a730 1
	if (*cmd == 0 || (cmd - (command + offs) >= cmdlen)) {
d740 1
a740 1
				*aptr = 0;
d749 1
a749 1
				*aptr = 0;
d773 1
d786 1
d799 2
a800 1
						if (from == NULL)
d802 1
d805 1
d817 1
d829 1
d835 1
d837 1
a837 1
							size - len);
d900 1
a900 1
#define ADD_STRING(what, len)						\
d906 2
d919 1
d958 1
a958 2
		tmp = &str[start];
		ADD_STRING(tmp, len);
d962 1
a962 2
			tmp = &str[i];
			ADD_STRING(tmp, len);
d972 3
a974 1
			ADD_STRING(tmp, len);
d976 1
d1005 1
a1005 1
	char	**arr, *result;
d1009 3
a1011 5
		return(NULL);
	if (arr && *arr == NULL) {
		free(arr);
		return(NULL);
	}
d1018 1
a1018 1
		start = max;
d1020 1
a1020 1
		end = max;
d1022 1
a1022 1
		end = max + end + 1;
d1026 3
a1028 2
	if (start < 0 || end < 0 || start > max || end > max || start > end)
		return(NULL);
d1030 1
a1030 1
	for (i = start, len = 0; i <= end; i++)
d1036 1
a1036 1
		return NULL;
d1038 1
a1038 1
	for (i = start, len = 0; i <= end; i++) {
d1041 1
a1041 1
		if (i < end)
d1044 1
a1044 1
	result[len] = 0;
d1046 1
d1051 1
a1051 1
	return(result);
d1120 1
a1120 1
	HistEvent ev;
d1125 1
a1125 1
	if (history(h, &ev, H_SETSIZE, max) == 0)
d1136 1
a1136 1
	HistEvent ev;
d1139 1
a1139 1
	history(h, &ev, H_SETSIZE, INT_MAX);
d1154 136
d1297 1
a1297 1
	HistEvent ev;
d1301 4
a1304 1
	return (history(h, &ev, H_LOAD, filename));
d1314 1
a1314 1
	HistEvent ev;
d1318 4
a1321 1
	return (history(h, &ev, H_SAVE, filename));
d1334 1
a1334 1
	HistEvent ev;
d1341 1
a1341 1
	if (history(h, &ev, H_CURR) != 0)
d1345 2
a1346 2
	/* start from most recent */
	if (history(h, &ev, H_FIRST) != 0)
d1349 2
a1350 2
	/* look backwards for event matching specified offset */
	if (history(h, &ev, H_NEXT_EVENT, num))
d1353 1
a1353 2
	she.line = ev.str;
	she.data = NULL;
d1356 1
a1356 1
	(void)history(h, &ev, H_SET, curr_num);
d1368 2
a1369 1
	HistEvent ev;
d1374 4
a1377 2
	(void)history(h, &ev, H_ENTER, line);
	if (history(h, &ev, H_GETSIZE) == 0)
d1385 74
d1464 1
a1464 1
	HistEvent ev;
d1466 2
a1467 1
	history(h, &ev, H_CLEAR);
d1477 1
a1477 1
	HistEvent ev;
d1480 1
a1480 1
	if (history(h, &ev, H_CURR) != 0)
d1484 1
a1484 1
	history(h, &ev, H_FIRST);
d1486 1
a1486 1
	while (ev.num != curr_num && history(h, &ev, H_NEXT) == 0)
d1510 3
a1512 2
	HistEvent ev;
	int curr_num, size;
d1514 1
a1514 1
	if (history(h, &ev, H_CURR) != 0)
d1518 1
a1518 1
	history(h, &ev, H_FIRST);
d1521 2
a1522 2
		size += strlen(ev.str);
	while (history(h, &ev, H_NEXT) == 0);
d1525 1
a1525 1
	history(h, &ev, H_PREV_EVENT, curr_num);
d1527 1
a1527 1
	return (size);
d1537 1
a1537 1
	HistEvent ev;
d1540 1
a1540 1
	if (pos > history_length || pos < 0)
d1543 1
a1543 1
	history(h, &ev, H_CURR);
d1546 6
a1551 2
	if (history(h, &ev, H_SET, pos)) {
		history(h, &ev, H_SET, curr_num);
d1586 3
a1588 2
	HistEvent ev;
	const char *strp;
d1591 1
a1591 1
	if (history(h, &ev, H_CURR) != 0)
d1595 1
d1597 1
a1597 1
		if ((strp = strstr(ev.str, str)) != NULL)
d1599 1
a1599 1
		if (history(h, &ev, direction < 0 ? H_NEXT:H_PREV) != 0)
d1602 1
a1602 1
	history(h, &ev, H_SET, curr_num);
d1613 1
a1613 1
	HistEvent ev;
d1615 2
a1616 1
	return (history(h, &ev, direction < 0? H_PREV_STR:H_NEXT_STR, str));
d1629 1
a1629 1
	HistEvent ev;
d1631 1
d1636 1
a1636 1
	if (history(h, &ev, H_CURR) != 0)
d1640 1
a1640 1
	if (history_set_pos(off) != 0 || history(h, &ev, H_CURR) != 0)
d1643 1
a1643 1

d1645 1
a1645 1
		if (strstr(ev.str, str))
d1647 1
a1647 1
		if (history(h, &ev, (pos < 0) ? H_PREV : H_NEXT) != 0)
d1652 2
a1653 1
	history(h, &ev, (pos < 0) ? H_NEXT_EVENT : H_PREV_EVENT, curr_num);
a1661 7
/*
 * does tilde expansion of strings of type ``~user/foo''
 * if ``user'' isn't valid user name or ``txt'' doesn't start
 * w/ '~', returns pointer to strdup()ed copy of ``txt''
 *
 * it's callers's responsibility to free() returned string
 */
d1663 1
a1663 1
tilde_expand(char *txt)
d1665 1
a1665 33
	struct passwd *pass;
	char *temp;
	size_t len = 0;

	if (txt[0] != '~')
		return (strdup(txt));

	temp = strchr(txt + 1, '/');
	if (temp == NULL) {
		temp = strdup(txt + 1);
		if (temp == NULL)
			return NULL;
	} else {
		len = temp - txt + 1;	/* text until string after slash */
		temp = malloc(len);
		if (temp == NULL)
			return NULL;
		(void)strncpy(temp, txt + 1, len - 2);
		temp[len - 2] = '\0';
	}
	pass = getpwnam(temp);
	free(temp);		/* value no more needed */
	if (pass == NULL)
		return (strdup(txt));

	/* update pointer txt to point at string immedially following */
	/* first slash */
	txt += len;

	if (asprintf(&temp, "%s/%s", pass->pw_dir, txt) == -1)
		return NULL;

	return (temp);
a1667 8

/*
 * return first found file name starting by the ``text'' or NULL if no
 * such file can be found
 * value of ``state'' is ignored
 *
 * it's caller's responsibility to free returned string
 */
d1669 1
a1669 1
filename_completion_function(const char *text, int state)
d1671 1
a1671 115
	static DIR *dir = NULL;
	static char *filename = NULL, *dirname = NULL;
	static size_t filename_len = 0;
	struct dirent *entry;
	char *temp;
	size_t len;

	if (state == 0 || dir == NULL) {
		temp = strrchr(text, '/');
		if (temp) {
			char *nptr;
			size_t sz;
			temp++;
			sz = strlen(temp) + 1;
			nptr = realloc(filename, sz);
			if (nptr == NULL) {
				free(filename);
				return NULL;
			}
			filename = nptr;
			(void)strlcpy(filename, temp, sz);
			len = temp - text;	/* including last slash */
			nptr = realloc(dirname, len + 1);
			if (nptr == NULL) {
				free(filename);
				return NULL;
			}
			dirname = nptr;
			(void)strncpy(dirname, text, len);
			dirname[len] = '\0';
		} else {
			if (*text == 0)
				filename = NULL;
			else {
				filename = strdup(text);
				if (filename == NULL)
					return NULL;
			}
			dirname = NULL;
		}

		/* support for ``~user'' syntax */
		if (dirname && *dirname == '~') {
			char *nptr;
			size_t sz;
			temp = tilde_expand(dirname);
			if (temp == NULL)
				return NULL;
			sz =  strlen(temp) + 1;
			nptr = realloc(dirname, sz);
			if (nptr == NULL) {
				free(dirname);
				return NULL;
			}
			dirname = nptr;
			(void)strlcpy(dirname, temp, sz);
			free(temp);	/* no longer needed */
		}
		/* will be used in cycle */
		filename_len = filename ? strlen(filename) : 0;

		if (dir != NULL) {
			(void)closedir(dir);
			dir = NULL;
		}
		dir = opendir(dirname ? dirname : ".");
		if (!dir)
			return (NULL);	/* cannot open the directory */
	}
	/* find the match */
	while ((entry = readdir(dir)) != NULL) {
		/* skip . and .. */
		if (entry->d_name[0] == '.' && (!entry->d_name[1]
		    || (entry->d_name[1] == '.' && !entry->d_name[2])))
			continue;
		if (filename_len == 0)
			break;
		/* otherwise, get first entry where first */
		/* filename_len characters are equal	  */
		if (entry->d_name[0] == filename[0]
#if defined(__SVR4) || defined(__linux__)
		    && strlen(entry->d_name) >= filename_len
#else
		    && entry->d_namlen >= filename_len
#endif
		    && strncmp(entry->d_name, filename,
			filename_len) == 0)
			break;
	}

	if (entry) {		/* match found */

		struct stat stbuf;
#if defined(__SVR4) || defined(__linux__)
		len = strlen(entry->d_name) +
#else
		len = entry->d_namlen +
#endif
		    ((dirname) ? strlen(dirname) : 0) + 1 + 1;
		temp = malloc(len);
		if (temp == NULL)
			return NULL;
		(void)snprintf(temp, len, "%s%s",
		    dirname ? dirname : "", entry->d_name);

		/* test, if it's directory */
		if (stat(temp, &stbuf) == 0 && S_ISDIR(stbuf.st_mode))
			strlcat(temp, "/", len);
	} else {
		(void)closedir(dir);
		dir = NULL;
		temp = NULL;
	}

	return (temp);
a1673 1

d1695 1
a1695 1
	while ((pwd = getpwent()) && text[0] == pwd->pw_name[0]
d1700 1
a1700 1
		return (NULL);
d1702 1
a1702 1
	return (strdup(pwd->pw_name));
d1707 1
a1707 1
 * el-compatible wrapper around rl_complete; needed for key binding
d1711 1
a1711 1
_el_rl_complete(EditLine *el __attribute__((__unused__)), int ch)
d1713 2
a1714 77
	return (unsigned char) rl_complete(0, ch);
}


/*
 * returns list of completions for text given
 */
char **
completion_matches(const char *text, CPFunction *genfunc)
{
	char **match_list = NULL, *retstr, *prevstr;
	size_t match_list_len, max_equal, which, i;
	size_t matches;

	if (h == NULL || e == NULL)
		rl_initialize();

	matches = 0;
	match_list_len = 1;
	while ((retstr = (*genfunc) (text, (int)matches)) != NULL) {
		/* allow for list terminator here */
		if (matches + 3 >= match_list_len) {
			char **nmatch_list;
			while (matches + 3 >= match_list_len)
				match_list_len <<= 1;
			nmatch_list = realloc(match_list,
			    match_list_len * sizeof(char *));
			if (nmatch_list == NULL) {
				free(match_list);
				return NULL;
			}
			match_list = nmatch_list;

		}
		match_list[++matches] = retstr;
	}

	if (!match_list)
		return NULL;	/* nothing found */

	/* find least denominator and insert it to match_list[0] */
	which = 2;
	prevstr = match_list[1];
	max_equal = strlen(prevstr);
	for (; which <= matches; which++) {
		for (i = 0; i < max_equal &&
		    prevstr[i] == match_list[which][i]; i++)
			continue;
		max_equal = i;
	}

	retstr = malloc(max_equal + 1);
	if (retstr == NULL) {
		free(match_list);
		return NULL;
	}
	(void)strncpy(retstr, match_list[1], max_equal);
	retstr[max_equal] = '\0';
	match_list[0] = retstr;

	/* add NULL as last pointer to the array */
	match_list[matches + 1] = (char *) NULL;

	return (match_list);
}

/*
 * Sort function for qsort(). Just wrapper around strcasecmp().
 */
static int
_rl_qsort_string_compare(i1, i2)
	const void *i1, *i2;
{
	const char *s1 = ((const char * const *)i1)[0];
	const char *s2 = ((const char * const *)i2)[0];

	return strcasecmp(s1, s2);
d1723 1
a1723 3
rl_display_match_list (matches, len, max)
     char **matches;
     int len, max;
a1724 2
	int i, idx, limit, count;
	int screenwidth = e->el_term.t_size.h;
d1726 1
a1726 24
	/*
	 * Find out how many entries can be put on one line, count
	 * with two spaces between strings.
	 */
	limit = screenwidth / (max + 2);
	if (limit == 0)
		limit = 1;

	/* how many lines of output */
	count = len / limit;
	if (count * limit < len)
		count++;

	/* Sort the items if they are not already sorted. */
	qsort(&matches[1], (size_t)(len - 1), sizeof(char *),
	    _rl_qsort_string_compare);

	idx = 1;
	for(; count > 0; count--) {
		for(i = 0; i < limit && matches[idx]; i++, idx++)
			(void)fprintf(e->el_outfile, "%-*s  ", max,
			    matches[idx]);
		(void)fprintf(e->el_outfile, "\n");
	}
d1729 4
a1732 13
/*
 * Complete the word at or before point, called by rl_complete()
 * 'what_to_do' says what to do with the completion.
 * `?' means list the possible completions.
 * TAB means do standard completion.
 * `*' means insert all of the possible completions.
 * `!' means to do standard completion, and list all possible completions if
 * there is more than one.
 *
 * Note: '*' support is not implemented
 */
static int
rl_complete_internal(int what_to_do)
d1734 4
a1737 132
	Function *complet_func;
	const LineInfo *li;
	char *temp, **matches;
	const char *ctemp;
	size_t len;

	rl_completion_type = what_to_do;

	if (h == NULL || e == NULL)
		rl_initialize();

	complet_func = rl_completion_entry_function;
	if (!complet_func)
		complet_func = (Function *)(void *)filename_completion_function;

	/* We now look backwards for the start of a filename/variable word */
	li = el_line(e);
	ctemp = (const char *) li->cursor;
	while (ctemp > li->buffer
	    && !strchr(rl_basic_word_break_characters, ctemp[-1])
	    && (!rl_special_prefixes
		|| !strchr(rl_special_prefixes, ctemp[-1]) ) )
		ctemp--;

	len = li->cursor - ctemp;
	temp = alloca(len + 1);
	(void)strncpy(temp, ctemp, len);
	temp[len] = '\0';

	/* these can be used by function called in completion_matches() */
	/* or (*rl_attempted_completion_function)() */
	rl_point = li->cursor - li->buffer;
	rl_end = li->lastchar - li->buffer;

	if (rl_attempted_completion_function) {
		int end = li->cursor - li->buffer;
		matches = (*rl_attempted_completion_function) (temp, (int)
		    (end - len), end);
	} else
		matches = 0;
	if (!rl_attempted_completion_function || !matches)
		matches = completion_matches(temp, (CPFunction *)complet_func);

	if (matches) {
		int i, retval = CC_REFRESH;
		int matches_num, maxlen, match_len, match_display=1;

		/*
		 * Only replace the completed string with common part of
		 * possible matches if there is possible completion.
		 */
		if (matches[0][0] != '\0') {
			el_deletestr(e, (int) len);
			el_insertstr(e, matches[0]);
		}

		if (what_to_do == '?')
			goto display_matches;

		if (matches[2] == NULL && strcmp(matches[0], matches[1]) == 0) {
			/*
			 * We found exact match. Add a space after
			 * it, unless we do filename completion and the
			 * object is a directory.
			 */
			size_t alen = strlen(matches[0]);
			if ((complet_func !=
			    (Function *)filename_completion_function
			      || (alen > 0 && (matches[0])[alen - 1] != '/'))
			    && rl_completion_append_character) {
				char buf[2];
				buf[0] = rl_completion_append_character;
				buf[1] = '\0';
				el_insertstr(e, buf);
			}
		} else if (what_to_do == '!') {
    display_matches:
			/*
			 * More than one match and requested to list possible
			 * matches.
			 */

			for(i=1, maxlen=0; matches[i]; i++) {
				match_len = strlen(matches[i]);
				if (match_len > maxlen)
					maxlen = match_len;
			}
			matches_num = i - 1;
				
			/* newline to get on next line from command line */
			(void)fprintf(e->el_outfile, "\n");

			/*
			 * If there are too many items, ask user for display
			 * confirmation.
			 */
			if (matches_num > rl_completion_query_items) {
				(void)fprintf(e->el_outfile,
				    "Display all %d possibilities? (y or n) ",
				    matches_num);
				(void)fflush(e->el_outfile);
				if (getc(stdin) != 'y')
					match_display = 0;
				(void)fprintf(e->el_outfile, "\n");
			}

			if (match_display)
				rl_display_match_list(matches, matches_num,
					maxlen);
			retval = CC_REDISPLAY;
		} else if (matches[0][0]) {
			/*
			 * There was some common match, but the name was
			 * not complete enough. Next tab will print possible
			 * completions.
			 */
			el_beep(e);
		} else {
			/* lcd is not a valid object - further specification */
			/* is needed */
			el_beep(e);
			retval = CC_NORM;
		}

		/* free elements of array and the array itself */
		for (i = 0; matches[i]; i++)
			free(matches[i]);
		free(matches), matches = NULL;

		return (retval);
	}
	return (CC_NORM);
d1744 1
d1746 1
a1746 1
rl_complete(int ignore, int invoking_key)
d1748 4
d1756 4
a1759 1
		rl_insert(ignore, invoking_key);
d1761 12
a1772 6
	} else if (e->el_state.lastcmd == el_rl_complete_cmdnum)
		return rl_complete_internal('?');
	else if (_rl_complete_show_all)
		return rl_complete_internal('!');
	else
		return (rl_complete_internal(TAB));
d1776 7
d1791 1
a1791 1
rl_bind_key(int c, int func(int, int))
d1858 14
d1888 3
d1904 1
a1904 1
	if (c >= sizeof(map) / sizeof(map[0]) || c < 0)
d1922 1
a1922 1
	if (count == 0 && buf[0] == CTRL('d'))
d1935 1
d1940 1
a1940 1
rl_callback_handler_install (const char *prompt, VFunction *linefunc)
d1945 1
a1945 3
	if (rl_prompt)
		free(rl_prompt);
	rl_prompt = prompt ? strdup(strchr(prompt, *prompt)) : NULL;
d1954 1
d1961 1
a1961 1
	a[0] = CTRL('r');
d1985 1
a1985 1
rl_deprep_terminal()
d2004 1
a2004 1
	tok_line(tok, line, &argc, &argv);
d2010 10
d2033 2
a2034 1
	int	n, num_read = 0;
d2036 1
a2036 1
	*cp = 0;
d2070 166
a2235 1
	return(num_read);
@


1.6
log
@fix rcs ids.  ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.5 2008/11/09 12:34:46 tobias Exp $ */
a33 3
#if !defined(lint) && !defined(SCCSID)
static const char rcsid[] = "$OpenBSD$";
#endif /* not lint && not SCCSID */
@


1.5
log
@typo fixed (overriden -> overridden)

ok espie, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.4 2008/06/26 05:42:05 ray Exp $ */
d35 1
a35 1
static const char rcsid[] = "$OpenBSD";
@


1.4
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.3 2005/11/14 13:36:37 deraadt Exp $ */
d255 1
a255 1
	/* so this can be overriden */
@


1.3
log
@use asprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: readline.c,v 1.2 2003/11/25 20:12:38 otto Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.2
log
@Sync libedit to NetBSD libedit as of Nov 8, 2003.
Tested by jmc@@ djm@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1406 1
a1406 3
	len = strlen(pass->pw_dir) + 1 + strlen(txt) + 1;
	temp = malloc(len);
	if (temp == NULL)
a1407 1
	(void)snprintf(temp, len, "%s/%s", pass->pw_dir, txt);
@


1.1
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: readline.c,v 1.35 2003/09/26 17:44:51 christos Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD$";
d55 3
d59 3
d68 1
d72 1
a72 1
#define	TAB		'\r'
d75 1
a75 1
#define	GDB_411_HACK
d91 2
d101 1
d117 1
d168 2
a169 2
static int		 _history_search_gen(const char *, int, int);
static int		 _history_expand_command(const char *, size_t, char **);
d171 1
a171 1
			    const char *, int);
d174 1
d199 1
a199 1
	rl_he.data = "";
d259 1
a259 1
	el_set(e, EL_SIGNAL, 1);
d318 1
d323 2
d338 10
d396 3
a398 4
	char *result;
	const char *temp, *new;
	size_t len, with_len, what_len, add;
	size_t size, i;
d400 17
a416 1
	result = malloc((size = 16));
d419 10
a428 18
	temp = str;
	with_len = strlen(with);
	what_len = strlen(what);
	len = 0;
	do {
		new = strstr(temp, what);
		if (new) {
			i = new - temp;
			add = i + with_len;
			if (i + add + 1 >= size) {
				char *nresult;
				size += add + 1;
				nresult = realloc(result, size);
				if (nresult == NULL) {
					free(result);
					return NULL;
				}
				result = nresult;
d430 95
a524 20
			(void) strncpy(&result[len], temp, i);
			len += i;
			(void) strlcpy(&result[len], with, size - len);
			len += with_len;
			temp = new + what_len;
		} else {
			add = strlen(temp);
			if (len + add + 1 >= size) {
				char *nresult;
				size += add + 1;
				nresult = realloc(result, size);
				if (nresult == NULL) {
					free(result);
					return NULL;
				}
				result = nresult;
			}
			(void) strlcpy(&result[len], temp, size - len);
			len += add;
			temp = NULL;
d526 3
a528 2
	} while (temp && globally);
	result[len] = '\0';
d530 27
a556 1
	return (result);
a558 1

a562 1
 * word designator ``%'' isn't supported (yet ?)
d570 2
a571 1
_history_expand_command(const char *command, size_t cmdlen, char **result)
d573 2
a574 2
	char **arr, *tempcmd, *line, *search = NULL, *cmd;
	const char *event_data = NULL;
d576 2
a577 4
	int start = -1, end = -1, max, i, idx;
	int h_on = 0, t_on = 0, r_on = 0, e_on = 0, p_on = 0, g_on = 0;
	int event_num = 0, retval;
	size_t cmdsize;
d580 2
d583 2
a584 3
	cmd = alloca(cmdlen + 1);
	(void) strncpy(cmd, command, cmdlen);
	cmd[cmdlen] = 0;
d586 12
a597 5
	idx = 1;
	/* find out which event to take */
	if (cmd[idx] == history_expansion_char) {
		event_num = history_length;
		idx++;
d599 7
a605 10
		int off, num;
		size_t len;
		off = idx;
		while (cmd[off] && !strchr(":^$*-%", cmd[off]))
			off++;
		num = atoi(&cmd[idx]);
		if (num != 0) {
			event_num = num;
			if (num < 0)
				event_num += history_length + 1;
d607 7
a613 2
			int prefix = 1, curr_num;
			HistEvent ev;
d615 2
a616 16
			len = off - idx;
			if (cmd[idx] == '?') {
				idx++, len--;
				if (cmd[off - 1] == '?')
					len--;
				else if (cmd[off] != '\n' && cmd[off] != '\0')
					return (-1);
				prefix = 0;
			}
			search = alloca(len + 1);
			(void) strncpy(search, &cmd[idx], len);
			search[len] = '\0';

			if (history(h, &ev, H_CURR) != 0)
				return (-1);
			curr_num = ev.num;
d618 41
a658 2
			if (prefix)
				retval = history_search_prefix(search, -1);
d660 12
a671 1
				retval = history_search(search, -1);
d673 2
a674 8
			if (retval == -1) {
				fprintf(rl_outstream, "%s: Event not found\n",
				    search);
				return (-1);
			}
			if (history(h, &ev, H_CURR) != 0)
				return (-1);
			event_data = ev.str;
d676 3
a678 4
			/* roll back to original position */
			history(h, &ev, H_NEXT_EVENT, curr_num);
		}
		idx = off;
a680 47
	if (!event_data && event_num >= 0) {
		HIST_ENTRY *rl_he;
		rl_he = history_get(event_num);
		if (!rl_he)
			return (0);
		event_data = rl_he->line;
	} else
		return (-1);

	if (cmd[idx] != ':')
		return (-1);
	cmd += idx + 1;

	/* recognize cmd */
	if (*cmd == '^')
		start = end = 1, cmd++;
	else if (*cmd == '$')
		start = end = -1, cmd++;
	else if (*cmd == '*')
		start = 1, end = -1, cmd++;
	else if (isdigit((unsigned char) *cmd)) {
		const char *temp;
		int shifted = 0;

		start = atoi(cmd);
		temp = cmd;
		for (; isdigit((unsigned char) *cmd); cmd++);
		if (temp != cmd)
			shifted = 1;
		if (shifted && *cmd == '-') {
			if (!isdigit((unsigned char) *(cmd + 1)))
				end = -2;
			else {
				end = atoi(cmd + 1);
				for (; isdigit((unsigned char) *cmd); cmd++);
			}
		} else if (shifted && *cmd == '*')
			end = -1, cmd++;
		else if (shifted)
			end = start;
	}
	if (*cmd == ':')
		cmd++;

	line = strdup(event_data);
	if (line == NULL)
		return 0;
d684 20
a703 10
		else if (*cmd == 'h')
			h_on = 1 | g_on, g_on = 0;
		else if (*cmd == 't')
			t_on = 1 | g_on, g_on = 0;
		else if (*cmd == 'r')
			r_on = 1 | g_on, g_on = 0;
		else if (*cmd == 'e')
			e_on = 1 | g_on, g_on = 0;
		else if (*cmd == 'p')
			p_on = 1 | g_on, g_on = 0;
d723 1
a723 2
					if (*cmd == '\\'
					    && *(cmd + 1) == delim)
d728 1
a728 1
						    (size <<= 1));
d774 2
a775 3
						/* safe */
						(void) strlcpy(&with[len],
						    from, size - len);
a786 8

				tempcmd = _rl_compat_sub(line, from, to,
				    (g_on) ? 1 : 0);
				if (tempcmd) {
					free(line);
					line = tempcmd;
				}
				g_on = 0;
a787 2
		}
	}
d789 4
a792 53
	arr = history_tokenize(line);
	free(line);		/* no more needed */
	if (arr && *arr == NULL)
		free(arr), arr = NULL;
	if (!arr)
		return (-1);

	/* find out max valid idx to array of array */
	max = 0;
	for (i = 0; arr[i]; i++)
		max++;
	max--;

	/* set boundaries to something relevant */
	if (start < 0)
		start = 1;
	if (end < 0)
		end = max - ((end < -1) ? 1 : 0);

	/* check boundaries ... */
	if (start > max || end > max || start > end)
		return (-1);

	for (i = 0; i <= max; i++) {
		char *temp;
		if (h_on && (i == 1 || h_on > 1) &&
		    (temp = strrchr(arr[i], '/')))
			*(temp + 1) = '\0';
		if (t_on && (i == 1 || t_on > 1) &&
		    (temp = strrchr(arr[i], '/')))
			(void) strlcpy(arr[i], temp + 1, strlen(arr[i]) + 1);
		if (r_on && (i == 1 || r_on > 1) &&
		    (temp = strrchr(arr[i], '.')))
			*temp = '\0';
		if (e_on && (i == 1 || e_on > 1) &&
		    (temp = strrchr(arr[i], '.')))
			(void) strlcpy(arr[i], temp, strlen(arr[i]) + 1);
	}

	cmdsize = 1, cmdlen = 0;
	if ((tempcmd = malloc(cmdsize)) == NULL)
		return 0;
	for (i = start; start <= i && i <= end; i++) {
		int arr_len;

		arr_len = strlen(arr[i]);
		if (cmdlen + arr_len + 1 >= cmdsize) {
			char *ntempcmd;
			cmdsize += arr_len + 1;
			ntempcmd = realloc(tempcmd, cmdsize);
			if (ntempcmd == NULL) {
				free(tempcmd);
				return 0;
d794 1
a794 1
			tempcmd = ntempcmd;
a795 3
		(void) strlcpy(&tempcmd[cmdlen], arr[i], cmdsize);
		cmdlen += arr_len;
		tempcmd[cmdlen++] = ' ';	/* add a space */
d797 2
a798 10
	while (cmdlen > 0 && isspace((unsigned char) tempcmd[cmdlen - 1]))
		cmdlen--;
	tempcmd[cmdlen] = '\0';

	*result = tempcmd;

	for (i = 0; i <= max; i++)
		free(arr[i]);
	free(arr), arr = (char **) NULL;
	return (p_on) ? 2 : 1;
d808 3
a810 3
	int i, retval = 0, idx;
	size_t size;
	char *temp, *result;
d815 4
a818 3
	*output = strdup(str);	/* do it early */
	if (*output == NULL)
		return 0;
d820 1
d824 12
a835 6
		temp = alloca(sz);
		temp[0] = temp[1] = history_expansion_char;
		temp[2] = ':';
		temp[3] = 's';
		(void) strlcpy(temp + 4, str, sz - 4);
		str = temp;
d837 2
a838 1
#define	ADD_STRING(what, len) 						\
d856 2
a857 2
		int start, j, loop_again;
		size_t len;
d859 1
d867 1
a867 1
				(void) strlcpy(&str[j], &str[j + 1], sz);
d871 2
a872 5
				if (str[j] == '?') {
					while (str[j] && str[++j] != '?');
					if (str[j] == '?')
						j++;
				} else if (isspace((unsigned char) str[j]))
d878 2
a879 1
			    (*history_inhibit_expansion_function)(str, j) == 0))
d883 1
a883 1
		if (str[j] && str[j + 1] != '#' && loop_again) {
d885 1
d893 2
a894 2
		temp = &str[start];
		ADD_STRING(temp, len);
d896 1
a896 2
		if (str[i] == '\0' || str[i] != history_expansion_char
		    || str[i + 1] == '#') {
d898 2
a899 2
			temp = &str[i];
			ADD_STRING(temp, len);
d901 1
a901 1
				retval = 0;
d903 1
a903 1
				retval = 1;
d906 5
a910 5
		retval = _history_expand_command(&str[i], (size_t) (j - i),
		    &temp);
		if (retval != -1) {
			len = strlen(temp);
			ADD_STRING(temp, len);
d913 1
a913 1
	}			/* for(i ...) */
d915 3
a917 2
	if (retval == 2) {
		add_history(temp);
d923 1
a923 1
		retval = -1;
d929 1
a929 1
	return (retval);
d932 55
d989 2
a990 1
 * Parse the string into individual tokens, similarily to how shell would do it.
d995 1
a995 1
	int size = 1, result_idx = 0, i, start;
d999 1
a999 1
	for (i = 0; str[i]; i++) {
d1003 1
a1003 1
		for (; str[i]; i++) {
d1015 2
d1019 1
a1019 1
		if (result_idx + 2 >= size) {
d1032 2
d1037 1
a1037 1
		(void) strncpy(temp, &str[start], len);
d1039 4
a1042 2
		result[result_idx++] = temp;
		result[result_idx] = NULL;
a1043 1

d1127 1
a1127 1
	int i = 1, curr_num;
d1132 1
a1132 1
	/* rewind to beginning */
d1136 3
a1138 1
	if (history(h, &ev, H_LAST) != 0)
d1140 4
a1143 4
	while (i < num && history(h, &ev, H_PREV) == 0)
		i++;
	if (i != num)
		return (NULL);	/* not so many entries */
d1148 2
a1149 3
	/* rewind history to the same event it was before */
	(void) history(h, &ev, H_FIRST);
	(void) history(h, &ev, H_NEXT_EVENT, curr_num);
d1166 1
a1166 1
	(void) history(h, &ev, H_ENTER, line);
d1170 1
a1170 1
	return (!(history_length > 0));	/* return 0 if all is okay */
d1252 1
a1252 1
	int off, curr_num;
a1258 4
	history(h, &ev, H_FIRST);
	off = 0;
	while (off < pos && history(h, &ev, H_NEXT) == 0)
		off++;
d1260 3
a1262 4
	if (off != pos) {	/* do a rollback in case of error */
		history(h, &ev, H_FIRST);
		history(h, &ev, H_NEXT_EVENT, curr_num);
		return (-1);
d1291 1
a1291 1
 * generic history search function
d1293 2
a1294 2
static int
_history_search_gen(const char *str, int direction, int pos)
d1305 1
a1305 2
		strp = strstr(ev.str, str);
		if (strp && (pos < 0 || &ev.str[pos] == strp))
d1307 1
a1307 1
		if (history(h, &ev, direction < 0 ? H_PREV : H_NEXT) != 0)
d1310 1
a1310 3

	history(h, &ev, direction < 0 ? H_NEXT_EVENT : H_PREV_EVENT, curr_num);

a1315 11
 * searches for first history event containing the str
 */
int
history_search(const char *str, int direction)
{

	return (_history_search_gen(str, direction, -1));
}


/*
d1321 1
d1323 1
a1323 1
	return (_history_search_gen(str, direction, 0));
d1333 1
a1333 1
history_search_pos(const char *str, 
d1365 1
a1365 1
/* completion functions	*/
d1394 1
a1394 1
		(void) strncpy(temp, txt + 1, len - 2);
d1410 1
a1410 1
	(void) snprintf(temp, len, "%s/%s", pass->pw_dir, txt);
d1446 1
a1446 1
			(void) strlcpy(filename, temp, sz);
d1454 1
a1454 1
			(void) strncpy(dirname, text, len);
d1457 7
a1463 3
			filename = strdup(text);
			if (filename == NULL)
				return NULL;
d1474 1
a1474 1
			sz = strlen(temp) + 1;
d1481 1
a1481 1
			(void) strlcpy(dirname, temp, sz);
d1485 1
a1485 3
		filename_len = strlen(filename);
		if (filename_len == 0)
			return (NULL);	/* no expansion possible */
d1497 6
d1528 1
a1528 1
		(void) snprintf(temp, len, "%s%s",
d1639 1
a1639 1
	(void) strncpy(retstr, match_list[1], max_equal);
d1694 4
a1697 3
		for(i=0; i < limit && matches[idx]; i++, idx++)
			fprintf(e->el_outfile, "%-*s  ", max, matches[idx]);
		fprintf(e->el_outfile, "\n");
d1736 1
a1736 1
			|| !strchr(rl_special_prefixes, ctemp[-1]) ) )
d1741 1
a1741 1
	(void) strncpy(temp, ctemp, len);
d1749 1
a1749 3
	if (!rl_attempted_completion_function)
		matches = completion_matches(temp, (CPFunction *)complet_func);
	else {
d1753 4
a1756 1
	}
d1805 1
a1805 1
			fprintf(e->el_outfile, "\n");
d1812 4
a1815 4
				fprintf(e->el_outfile,
				"Display all %d possibilities? (y or n) ",
					matches_num);
				fflush(e->el_outfile);
d1818 1
a1818 1
				fprintf(e->el_outfile, "\n");
d1963 5
d1979 2
a1980 1
	el_set(e, EL_BIND, vis(dest, c, VIS_WHITE, 0), name);
d1987 1
a1987 1
	int count = 0;
d1993 6
a1998 1
	if ((buf[count] == '\n' || buf[count] == '\r') && rl_linefunc != NULL) {
d2000 5
a2004 2
		if ((wbuf = strdup(buf)) != NULL)
		    wbuf[count] = '\0';
d2046 85
@

