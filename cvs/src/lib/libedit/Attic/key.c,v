head	1.13;
access;
symbols
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.20
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.18
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.14
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.12
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.26
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.22
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.20
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.18
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.16
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.01.29.17.23.21;	author schwarze;	state dead;
branches;
next	1.12;
commitid	MOfHvqt1MJvqXmCY;

1.12
date	2014.10.17.06.07.50;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	bdUOvGFxUQgqZg7x;

1.11
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.25.20.12.38;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.01.21.11.21;	author avsm;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.17.19.42.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.16.21.27.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.03.14.05.12.52;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.16.05.18.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Start synching with NetBSD:
Rename the files key.[hc] to keymacro.[hc] and term.[hc] to terminal.[hc].
The change makes sense because "term.h" conflicts with <term.h>
and the functions key_clear(), key_end(), and key_print() in "key.h"
conflict with macros in <term.h>.
No content change yet, no binary change in *.o after "strip -d".
This reduces the remaining diff from +4634 -3992 to +2640 -1998.
OK czarkoff@@, and mmcc@@ agrees with the direction.
@
text
@/*	$OpenBSD: key.c,v 1.12 2014/10/17 06:07:50 deraadt Exp $	*/
/*	$NetBSD: key.c,v 1.23 2009/12/30 22:37:40 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * key.c: This module contains the procedures for maintaining
 *	  the extended-key map.
 *
 *      An extended-key (key) is a sequence of keystrokes introduced
 *	with a sequence introducer and consisting of an arbitrary
 *	number of characters.  This module maintains a map (the el->el_key.map)
 *	to convert these extended-key sequences into input strs
 *	(XK_STR), editor functions (XK_CMD), or unix commands (XK_EXE).
 *
 *      Warning:
 *	  If key is a substr of some other keys, then the longer
 *	  keys are lost!!  That is, if the keys "abcd" and "abcef"
 *	  are in el->el_key.map, adding the key "abc" will cause the first two
 *	  definitions to be lost.
 *
 *      Restrictions:
 *      -------------
 *      1) It is not possible to have one key that is a
 *	   substr of another.
 */
#include <string.h>
#include <stdlib.h>

#include "el.h"

/*
 * The Nodes of the el->el_key.map.  The el->el_key.map is a linked list
 * of these node elements
 */
struct key_node_t {
	Char		ch;		/* single character of key 	 */
	int		type;		/* node type			 */
	key_value_t	val;		/* command code or pointer to str,  */
					/* if this is a leaf 		 */
	struct key_node_t *next;	/* ptr to next char of this key  */
	struct key_node_t *sibling;	/* ptr to another key with same prefix*/
};

private int		 node_trav(EditLine *, key_node_t *, Char *,
    key_value_t *);
private int		 node__try(EditLine *, key_node_t *, const Char *,
    key_value_t *, int);
private key_node_t	*node__get(Int);
private void		 node__free(key_node_t *);
private void		 node__put(EditLine *, key_node_t *);
private int		 node__delete(EditLine *, key_node_t **, const Char *);
private int		 node_lookup(EditLine *, const Char *, key_node_t *,
    size_t);
private int		 node_enum(EditLine *, key_node_t *, size_t);

#define	KEY_BUFSIZ	EL_BUFSIZ


/* key_init():
 *	Initialize the key maps
 */
protected int
key_init(EditLine *el)
{

	el->el_key.buf = reallocarray(NULL, KEY_BUFSIZ,
	    sizeof(*el->el_key.buf));
	if (el->el_key.buf == NULL)
		return (-1);
	el->el_key.map = NULL;
	key_reset(el);
	return (0);
}

/* key_end():
 *	Free the key maps
 */
protected void
key_end(EditLine *el)
{

	free((ptr_t) el->el_key.buf);
	el->el_key.buf = NULL;
	node__free(el->el_key.map);
}


/* key_map_cmd():
 *	Associate cmd with a key value
 */
protected key_value_t *
key_map_cmd(EditLine *el, int cmd)
{

	el->el_key.val.cmd = (el_action_t) cmd;
	return (&el->el_key.val);
}


/* key_map_str():
 *	Associate str with a key value
 */
protected key_value_t *
key_map_str(EditLine *el, Char *str)
{

	el->el_key.val.str = str;
	return (&el->el_key.val);
}


/* key_reset():
 *	Takes all nodes on el->el_key.map and puts them on free list.  Then
 *	initializes el->el_key.map with arrow keys
 *	[Always bind the ansi arrow keys?]
 */
protected void
key_reset(EditLine *el)
{

	node__put(el, el->el_key.map);
	el->el_key.map = NULL;
	return;
}


/* key_get():
 *	Calls the recursive function with entry point el->el_key.map
 *      Looks up *ch in map and then reads characters until a
 *      complete match is found or a mismatch occurs. Returns the
 *      type of the match found (XK_STR, XK_CMD, or XK_EXE).
 *      Returns NULL in val.str and XK_STR for no match.
 *      The last character read is returned in *ch.
 */
protected int
key_get(EditLine *el, Char *ch, key_value_t *val)
{

	return (node_trav(el, el->el_key.map, ch, val));
}


/* key_add():
 *      Adds key to the el->el_key.map and associates the value in val with it.
 *      If key is already is in el->el_key.map, the new code is applied to the
 *      existing key. Ntype specifies if code is a command, an
 *      out str or a unix command.
 */
protected void
key_add(EditLine *el, const Char *key, key_value_t *val, int ntype)
{

	if (key[0] == '\0') {
		(void) fprintf(el->el_errfile,
		    "key_add: Null extended-key not allowed.\n");
		return;
	}
	if (ntype == XK_CMD && val->cmd == ED_SEQUENCE_LEAD_IN) {
		(void) fprintf(el->el_errfile,
		    "key_add: sequence-lead-in command not allowed\n");
		return;
	}
	if (el->el_key.map == NULL)
		/* tree is initially empty.  Set up new node to match key[0] */
		el->el_key.map = node__get(key[0]);
			/* it is properly initialized */

	/* Now recurse through el->el_key.map */
	(void) node__try(el, el->el_key.map, key, val, ntype);
	return;
}


/* key_clear():
 *
 */
protected void
key_clear(EditLine *el, el_action_t *map, const Char *in)
{
#ifdef WIDECHAR
        if (*in > N_KEYS) /* can't be in the map */
                return;
#endif
	if ((map[(unsigned char)*in] == ED_SEQUENCE_LEAD_IN) &&
	    ((map == el->el_map.key &&
	    el->el_map.alt[(unsigned char)*in] != ED_SEQUENCE_LEAD_IN) ||
	    (map == el->el_map.alt &&
	    el->el_map.key[(unsigned char)*in] != ED_SEQUENCE_LEAD_IN)))
		(void) key_delete(el, in);
}


/* key_delete():
 *      Delete the key and all longer keys staring with key, if
 *      they exists.
 */
protected int
key_delete(EditLine *el, const Char *key)
{

	if (key[0] == '\0') {
		(void) fprintf(el->el_errfile,
		    "key_delete: Null extended-key not allowed.\n");
		return (-1);
	}
	if (el->el_key.map == NULL)
		return (0);

	(void) node__delete(el, &el->el_key.map, key);
	return (0);
}


/* key_print():
 *	Print the binding associated with key key.
 *	Print entire el->el_key.map if null
 */
protected void
key_print(EditLine *el, const Char *key)
{

	/* do nothing if el->el_key.map is empty and null key specified */
	if (el->el_key.map == NULL && *key == 0)
		return;

	el->el_key.buf[0] = '"';
	if (node_lookup(el, key, el->el_key.map, 1) <= -1)
		/* key is not bound */
		(void) fprintf(el->el_errfile, "Unbound extended key \"" FSTR "\"\n",
		    key);
	return;
}


/* node_trav():
 *	recursively traverses node in tree until match or mismatch is
 * 	found.  May read in more characters.
 */
private int
node_trav(EditLine *el, key_node_t *ptr, Char *ch, key_value_t *val)
{

	if (ptr->ch == *ch) {
		/* match found */
		if (ptr->next) {
			/* key not complete so get next char */
			if (FUN(el,getc)(el, ch) != 1) {/* if EOF or error */
				val->cmd = ED_END_OF_FILE;
				return (XK_CMD);
				/* PWP: Pretend we just read an end-of-file */
			}
			return (node_trav(el, ptr->next, ch, val));
		} else {
			*val = ptr->val;
			if (ptr->type != XK_CMD)
				*ch = '\0';
			return (ptr->type);
		}
	} else {
		/* no match found here */
		if (ptr->sibling) {
			/* try next sibling */
			return (node_trav(el, ptr->sibling, ch, val));
		} else {
			/* no next sibling -- mismatch */
			val->str = NULL;
			return (XK_STR);
		}
	}
}


/* node__try():
 * 	Find a node that matches *str or allocate a new one
 */
private int
node__try(EditLine *el, key_node_t *ptr, const Char *str, key_value_t *val, int ntype)
{

	if (ptr->ch != *str) {
		key_node_t *xm;

		for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
			if (xm->sibling->ch == *str)
				break;
		if (xm->sibling == NULL)
			xm->sibling = node__get(*str);	/* setup new node */
		ptr = xm->sibling;
	}
	if (*++str == '\0') {
		/* we're there */
		if (ptr->next != NULL) {
			node__put(el, ptr->next);
				/* lose longer keys with this prefix */
			ptr->next = NULL;
		}
		switch (ptr->type) {
		case XK_CMD:
		case XK_NOD:
			break;
		case XK_STR:
		case XK_EXE:
			if (ptr->val.str)
				free((ptr_t) ptr->val.str);
			break;
		default:
			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n",
			    ptr->type));
			break;
		}

		switch (ptr->type = ntype) {
		case XK_CMD:
			ptr->val = *val;
			break;
		case XK_STR:
		case XK_EXE:
			if ((ptr->val.str = Strdup(val->str)) == NULL)
				return -1;
			break;
		default:
			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ntype));
			break;
		}
	} else {
		/* still more chars to go */
		if (ptr->next == NULL)
			ptr->next = node__get(*str);	/* setup new node */
		(void) node__try(el, ptr->next, str, val, ntype);
	}
	return (0);
}


/* node__delete():
 *	Delete node that matches str
 */
private int
node__delete(EditLine *el, key_node_t **inptr, const Char *str)
{
	key_node_t *ptr;
	key_node_t *prev_ptr = NULL;

	ptr = *inptr;

	if (ptr->ch != *str) {
		key_node_t *xm;

		for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
			if (xm->sibling->ch == *str)
				break;
		if (xm->sibling == NULL)
			return (0);
		prev_ptr = xm;
		ptr = xm->sibling;
	}
	if (*++str == '\0') {
		/* we're there */
		if (prev_ptr == NULL)
			*inptr = ptr->sibling;
		else
			prev_ptr->sibling = ptr->sibling;
		ptr->sibling = NULL;
		node__put(el, ptr);
		return (1);
	} else if (ptr->next != NULL &&
	    node__delete(el, &ptr->next, str) == 1) {
		if (ptr->next != NULL)
			return (0);
		if (prev_ptr == NULL)
			*inptr = ptr->sibling;
		else
			prev_ptr->sibling = ptr->sibling;
		ptr->sibling = NULL;
		node__put(el, ptr);
		return (1);
	} else {
		return (0);
	}
}


/* node__put():
 *	Puts a tree of nodes onto free list using free(3).
 */
private void
node__put(EditLine *el, key_node_t *ptr)
{
	if (ptr == NULL)
		return;

	if (ptr->next != NULL) {
		node__put(el, ptr->next);
		ptr->next = NULL;
	}
	node__put(el, ptr->sibling);

	switch (ptr->type) {
	case XK_CMD:
	case XK_NOD:
		break;
	case XK_EXE:
	case XK_STR:
		if (ptr->val.str != NULL)
			free((ptr_t) ptr->val.str);
		break;
	default:
		EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ptr->type));
		break;
	}
	free((ptr_t) ptr);
}


/* node__get():
 *	Returns pointer to a key_node_t for ch.
 */
private key_node_t *
node__get(Int ch)
{
	key_node_t *ptr;

	ptr = malloc(sizeof(key_node_t));
	if (ptr == NULL)
		return NULL;
	ptr->ch = ch;
	ptr->type = XK_NOD;
	ptr->val.str = NULL;
	ptr->next = NULL;
	ptr->sibling = NULL;
	return (ptr);
}

private void
node__free(key_node_t *k)
{
	if (k == NULL)
		return;
	node__free(k->sibling);
	node__free(k->next);
	free((ptr_t) k);
}

/* node_lookup():
 *	look for the str starting at node ptr.
 *	Print if last node
 */
private int
node_lookup(EditLine *el, const Char *str, key_node_t *ptr, size_t cnt)
{
	ssize_t used;

	if (ptr == NULL)
		return (-1);	/* cannot have null ptr */

	if (!str || *str == 0) {
		/* no more chars in str.  node_enum from here. */
		(void) node_enum(el, ptr, cnt);
		return (0);
	} else {
		/* If match put this char into el->el_key.buf.  Recurse */
		if (ptr->ch == *str) {
			/* match found */
			used = ct_visual_char(el->el_key.buf + cnt,
			    KEY_BUFSIZ - cnt, ptr->ch);
			if (used == -1)
				return (-1); /* ran out of buffer space */
			if (ptr->next != NULL)
				/* not yet at leaf */
				return (node_lookup(el, str + 1, ptr->next,
				    used + cnt));
			else {
			    /* next node is null so key should be complete */
				if (str[1] == 0) {
					el->el_key.buf[cnt + used    ] = '"';
					el->el_key.buf[cnt + used + 1] = '\0';
					key_kprint(el, el->el_key.buf,
					    &ptr->val, ptr->type);
					return (0);
				} else
					return (-1);
					/* mismatch -- str still has chars */
			}
		} else {
			/* no match found try sibling */
			if (ptr->sibling)
				return (node_lookup(el, str, ptr->sibling,
				    cnt));
			else
				return (-1);
		}
	}
}


/* node_enum():
 *	Traverse the node printing the characters it is bound in buffer
 */
private int
node_enum(EditLine *el, key_node_t *ptr, size_t cnt)
{
        ssize_t used;

	if (cnt >= KEY_BUFSIZ - 5) {	/* buffer too small */
		el->el_key.buf[++cnt] = '"';
		el->el_key.buf[++cnt] = '\0';
		(void) fprintf(el->el_errfile,
		    "Some extended keys too long for internal print buffer");
		(void) fprintf(el->el_errfile, " \"" FSTR "...\"\n", el->el_key.buf);
		return (0);
	}
	if (ptr == NULL) {
#ifdef DEBUG_EDIT
		(void) fprintf(el->el_errfile,
		    "node_enum: BUG!! Null ptr passed\n!");
#endif
		return (-1);
	}
	/* put this char at end of str */
        used = ct_visual_char(el->el_key.buf + cnt, KEY_BUFSIZ - cnt, ptr->ch);
	if (ptr->next == NULL) {
		/* print this key and function */
		el->el_key.buf[cnt + used   ] = '"';
		el->el_key.buf[cnt + used + 1] = '\0';
		key_kprint(el, el->el_key.buf, &ptr->val, ptr->type);
	} else
		(void) node_enum(el, ptr->next, cnt + used);

	/* go to sibling if there is one */
	if (ptr->sibling)
		(void) node_enum(el, ptr->sibling, cnt);
	return (0);
}


/* key_kprint():
 *	Print the specified key and its associated
 *	function specified by val
 */
protected void
key_kprint(EditLine *el, const Char *key, key_value_t *val, int ntype)
{
	el_bindings_t *fp;
	char unparsbuf[EL_BUFSIZ];
	static const char fmt[] = "%-15s->  %s\n";

	if (val != NULL)
		switch (ntype) {
		case XK_STR:
		case XK_EXE:
			(void) key__decode_str(val->str, unparsbuf,
			    sizeof(unparsbuf), 
			    ntype == XK_STR ? "\"\"" : "[]");
			(void) fprintf(el->el_outfile, fmt,
			    ct_encode_string(key, &el->el_scratch), unparsbuf);
			break;
		case XK_CMD:
			for (fp = el->el_map.help; fp->name; fp++)
				if (val->cmd == fp->func) {
                    ct_wcstombs(unparsbuf, fp->name, sizeof(unparsbuf));
                    unparsbuf[sizeof(unparsbuf) -1] = '\0';
					(void) fprintf(el->el_outfile, fmt,
                        ct_encode_string(key, &el->el_scratch), unparsbuf);
					break;
				}
#ifdef DEBUG_KEY
			if (fp->name == NULL)
				(void) fprintf(el->el_outfile,
				    "BUG! Command not found.\n");
#endif

			break;
		default:
			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ntype));
			break;
		}
	else
		(void) fprintf(el->el_outfile, fmt, ct_encode_string(key,
		    &el->el_scratch), "no input");
}


#define ADDC(c) \
	if (b < eb) \
		*b++ = c; \
	else \
		b++
/* key__decode_str():
 *	Make a printable version of the ey
 */
protected size_t
key__decode_str(const Char *str, char *buf, size_t len, const char *sep)
{
	char *b = buf, *eb = b + len;
	const Char *p;

	b = buf;
	if (sep[0] != '\0') {
		ADDC(sep[0]);
	}
	if (*str == '\0') {
		ADDC('^');
		ADDC('@@');
		goto add_endsep;
	}
	for (p = str; *p != 0; p++) {
		Char dbuf[VISUAL_WIDTH_MAX];
		Char *p2 = dbuf;
		ssize_t l = ct_visual_char(dbuf, VISUAL_WIDTH_MAX, *p);
		while (l-- > 0) {
			ssize_t n = ct_encode_char(b, (size_t)(eb - b), *p2++);
			if (n == -1) /* ran out of space */
				goto add_endsep;
			else
				b += n;
		}
	}
add_endsep:
	if (sep[0] != '\0' && sep[1] != '\0') {
		ADDC(sep[1]);
	}
	ADDC('\0');
	if ((size_t)(b - buf) >= len)
	    buf[len - 1] = '\0';
	return (size_t)(b - buf);
}

@


1.12
log
@Remove non-exposed malloc/realloc/free wrappers, and then substitute
reallocarray() where it helps.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.11 2010/06/30 00:05:35 nicm Exp $	*/
@


1.11
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 2
a100 1
	el->el_key.buf = el_malloc(KEY_BUFSIZ * sizeof(*el->el_key.buf));
d115 1
a115 1
	el_free((ptr_t) el->el_key.buf);
d337 1
a337 1
				el_free((ptr_t) ptr->val.str);
d438 1
a438 1
			el_free((ptr_t) ptr->val.str);
d444 1
a444 1
	el_free((ptr_t) ptr);
d456 1
a456 1
	ptr = (key_node_t *) el_malloc((size_t) sizeof(key_node_t));
d474 1
a474 1
	el_free((ptr_t) k);
@


1.10
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
a2 2
/*	$OpenBSD: key.c,v 1.9 2003/11/25 20:12:38 otto Exp $	*/
/*	$NetBSD: key.c,v 1.15 2003/10/18 23:48:42 christos Exp $	*/
d43 1
a43 1
 *	with an sequence introducer and consisting of an arbitrary
d69 1
a69 1
	char		ch;		/* single character of key 	 */
d77 1
a77 1
private int		 node_trav(EditLine *, key_node_t *, char *,
d79 1
a79 1
private int		 node__try(EditLine *, key_node_t *, const char *,
d81 2
a82 1
private key_node_t	*node__get(int);
d84 4
a87 5
private int		 node__delete(EditLine *, key_node_t **, const char *);
private int		 node_lookup(EditLine *, const char *, key_node_t *,
    int);
private int		 node_enum(EditLine *, key_node_t *, int);
private int		 key__decode_char(char *, int, int);
d99 1
a99 1
	el->el_key.buf = (char *) el_malloc(KEY_BUFSIZ);
a106 1

d116 1
a116 2
	/* XXX: provide a function to clear the keys */
	el->el_key.map = NULL;
d136 1
a136 1
key_map_str(EditLine *el, char *str)
d168 1
a168 1
key_get(EditLine *el, char *ch, key_value_t *val)
d182 1
a182 1
key_add(EditLine *el, const char *key, key_value_t *val, int ntype)
d210 1
a210 1
key_clear(EditLine *el, el_action_t *map, const char *in)
d212 4
a215 1

d230 1
a230 1
key_delete(EditLine *el, const char *key)
d251 1
a251 1
key_print(EditLine *el, const char *key)
d261 1
a261 1
		(void) fprintf(el->el_errfile, "Unbound extended key \"%s\"\n",
d272 1
a272 1
node_trav(EditLine *el, key_node_t *ptr, char *ch, key_value_t *val)
d279 1
a279 1
			if (el_getc(el, ch) != 1) {	/* if EOF or error */
d309 1
a309 1
node__try(EditLine *el, key_node_t *ptr, const char *str, key_value_t *val, int ntype)
d350 1
a350 1
			if ((ptr->val.str = el_strdup(val->str)) == NULL)
d371 1
a371 1
node__delete(EditLine *el, key_node_t **inptr, const char *str)
d448 1
a448 1
 *	Returns pointer to an key_node_t for ch.
d451 1
a451 1
node__get(int ch)
d466 9
a474 1

d481 1
a481 1
node_lookup(EditLine *el, const char *str, key_node_t *ptr, int cnt)
d483 1
a483 1
	int ncnt;
d488 1
a488 1
	if (*str == 0) {
d496 4
a499 2
			ncnt = key__decode_char(el->el_key.buf, cnt,
			    (unsigned char) ptr->ch);
d503 1
a503 1
				    ncnt + 1));
d507 2
a508 2
					el->el_key.buf[ncnt + 1] = '"';
					el->el_key.buf[ncnt + 2] = '\0';
d532 1
a532 1
node_enum(EditLine *el, key_node_t *ptr, int cnt)
d534 1
a534 1
	int ncnt;
d541 1
a541 1
		(void) fprintf(el->el_errfile, " \"%s...\"\n", el->el_key.buf);
d552 1
a552 1
	ncnt = key__decode_char(el->el_key.buf, cnt, (unsigned char) ptr->ch);
d555 2
a556 2
		el->el_key.buf[ncnt + 1] = '"';
		el->el_key.buf[ncnt + 2] = '\0';
d559 1
a559 1
		(void) node_enum(el, ptr->next, ncnt + 1);
d573 1
a573 1
key_kprint(EditLine *el, const char *key, key_value_t *val, int ntype)
d583 5
a587 3
			(void) fprintf(el->el_outfile, fmt, key,
			    key__decode_str(val->str, unparsbuf,
				ntype == XK_STR ? "\"\"" : "[]"));
d592 2
d595 1
a595 1
					    key, fp->name);
d610 2
a611 36
		(void) fprintf(el->el_outfile, fmt, key, "no input");
}


/* key__decode_char():
 *	Put a printable form of char in buf.
 */
private int
key__decode_char(char *buf, int cnt, int ch)
{
	if (ch == 0) {
		buf[cnt++] = '^';
		buf[cnt] = '@@';
		return (cnt);
	}
	if (iscntrl(ch)) {
		buf[cnt++] = '^';
		if (ch == '\177')
			buf[cnt] = '?';
		else
			buf[cnt] = ch | 0100;
	} else if (ch == '^') {
		buf[cnt++] = '\\';
		buf[cnt] = '^';
	} else if (ch == '\\') {
		buf[cnt++] = '\\';
		buf[cnt] = '\\';
	} else if (ch == ' ' || (isprint(ch) && !isspace(ch))) {
		buf[cnt] = ch;
	} else {
		buf[cnt++] = '\\';
		buf[cnt++] = (((unsigned int) ch >> 6) & 7) + '0';
		buf[cnt++] = (((unsigned int) ch >> 3) & 7) + '0';
		buf[cnt] = (ch & 7) + '0';
	}
	return (cnt);
d615 5
d623 2
a624 2
protected char *
key__decode_str(const char *str, char *buf, const char *sep)
d626 2
a627 2
	char *b;
	const char *p;
d630 7
a636 9
	if (sep[0] != '\0')
		*b++ = sep[0];
	if (*str == 0) {
		*b++ = '^';
		*b++ = '@@';
		if (sep[0] != '\0' && sep[1] != '\0')
			*b++ = sep[1];
		*b++ = 0;
		return (buf);
d639 7
a645 4
		if (iscntrl((unsigned char) *p)) {
			*b++ = '^';
			if (*p == '\177')
				*b++ = '?';
d647 1
a647 12
				*b++ = *p | 0100;
		} else if (*p == '^' || *p == '\\') {
			*b++ = '\\';
			*b++ = *p;
		} else if (*p == ' ' || (isprint((unsigned char) *p) &&
			!isspace((unsigned char) *p))) {
			*b++ = *p;
		} else {
			*b++ = '\\';
			*b++ = (((unsigned int) *p >> 6) & 7) + '0';
			*b++ = (((unsigned int) *p >> 3) & 7) + '0';
			*b++ = (*p & 7) + '0';
d650 8
a657 4
	if (sep[0] != '\0' && sep[1] != '\0')
		*b++ = sep[1];
	*b++ = 0;
	return (buf);		/* should check for overflow */
d659 1
@


1.9
log
@Sync libedit to NetBSD libedit as of Nov 8, 2003.
Tested by jmc@@ djm@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.8 2003/10/31 08:42:24 otto Exp $	*/
a36 7
#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)key.c	8.1 (Berkeley) 6/4/93";
#else
static const char rcsid[] = "$OpenBSD: key.c,v 1.8 2003/10/31 08:42:24 otto Exp $";
#endif
#endif /* not lint && not SCCSID */
@


1.8
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: key.c,v 1.14 2003/08/07 16:44:31 agc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD$";
d356 2
a357 1
			ptr->val.str = strdup(val->str);
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: key.c,v 1.6 2003/05/01 21:11:21 avsm Exp $	*/
/*	$NetBSD: key.c,v 1.2 1997/01/11 06:47:58 lukem Exp $	*/
d36 1
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: key.c,v 1.6 2003/05/01 21:11:21 avsm Exp $";
d49 4
a52 4
 *      An extended-key (key) is a sequence of keystrokes introduced 
 *	with an sequence introducer and consisting of an arbitrary 
 *	number of characters.  This module maintains a map (the el->el_key.map) 
 *	to convert these extended-key sequences into input strs 
a65 1
#include "sys.h"
d71 2
a72 2
/* 
 * The Nodes of the el->el_key.map.  The el->el_key.map is a linked list 
d76 6
a81 6
    char        ch;		/* single character of key 		*/
    int         type;		/* node type				*/
    key_value_t val; 		/* command code or pointer to str, 	*/
				/* if this is a leaf 			*/
    struct key_node_t *next;	/* ptr to next char of this key 	*/
    struct key_node_t *sibling;	/* ptr to another key with same prefix 	*/
d84 11
a94 9
private	int            node_trav(EditLine *, key_node_t *, char *, 
			    key_value_t *);
private	int            node__try(key_node_t *, char *, key_value_t *, int);
private	key_node_t    *node__get(int);
private	void	       node__put(key_node_t *);
private	int	       node__delete(key_node_t **, char *);
private	int	       node_lookup (EditLine *, char *, key_node_t *, int);
private	int	       node_enum(EditLine *, key_node_t *, int);
private	int	       key__decode_char(char *, int, int);
d96 1
a96 1
#define KEY_BUFSIZ	EL_BUFSIZ
d103 1
a103 2
key_init(el)
    EditLine *el;
d105 8
a112 5
    el->el_key.buf = (char *) el_malloc(KEY_BUFSIZ);
    el->el_key.map = NULL;
    key_reset(el);
    return 0;
} 
d119 1
a119 2
key_end(el)
    EditLine *el;
d121 6
a126 5
    el_free((ptr_t) el->el_key.buf);
    el->el_key.buf = NULL;
    /* XXX: provide a function to clear the keys */
    el->el_key.map = NULL;
} 
d133 1
a133 3
key_map_cmd(el, cmd)
    EditLine *el;
    int cmd;
d135 3
a137 2
    el->el_key.val.cmd = (el_action_t) cmd;
    return &el->el_key.val;
d145 1
a145 3
key_map_str(el, str)
    EditLine *el;
    char  *str;
d147 3
a149 2
    el->el_key.val.str = str;
    return &el->el_key.val;
d159 1
a159 2
key_reset(el)
    EditLine *el;
d161 4
a164 3
    node__put(el->el_key.map);
    el->el_key.map = NULL;
    return;
d173 1
a173 1
 *      Returns NULL in val.str and XK_STR for no match.  
d177 1
a177 4
key_get(el, ch, val)
    EditLine    *el;
    char        *ch;
    key_value_t *val;
d179 2
a180 1
    return node_trav(el, el->el_key.map, ch, val);
a183 1

d191 17
a207 11
key_add(el, key, val, ntype)
    EditLine    *el;
    char        *key;
    key_value_t *val;
    int          ntype;
{
    if (key[0] == '\0') {
	(void)fprintf(el->el_errfile, 
		       "key_add: Null extended-key not allowed.\n");
	return;
    }
d209 2
a210 3
    if (ntype == XK_CMD && val->cmd == ED_SEQUENCE_LEAD_IN) {
	(void)fprintf(el->el_errfile,
		       "key_add: sequence-lead-in command not allowed\n");
a211 9
    }

    if (el->el_key.map == NULL)
	/* tree is initially empty.  Set up new node to match key[0] */
	el->el_key.map = node__get(key[0]);	/* it is properly initialized */

    /* Now recurse through el->el_key.map */
    (void)node__try(el->el_key.map, key, val, ntype);	
    return;
d219 9
a227 11
key_clear(el, map, in)
    EditLine *el;
    el_action_t *map;
    char   *in;
{
    if ((map[(unsigned char) *in] == ED_SEQUENCE_LEAD_IN) &&
	((map == el->el_map.key && 
	  el->el_map.alt[(unsigned char) *in] != ED_SEQUENCE_LEAD_IN) ||
	 (map == el->el_map.alt && 
	  el->el_map.key[(unsigned char) *in] != ED_SEQUENCE_LEAD_IN)))
	(void)key_delete(el, in);
d236 2
a237 9
key_delete(el, key)
    EditLine *el;
    char   *key;
{
    if (key[0] == '\0') {
	(void)fprintf(el->el_errfile, 
		       "key_delete: Null extended-key not allowed.\n");
	return -1;
    }
d239 7
a245 2
    if (el->el_key.map == NULL)
	return 0;
d247 2
a248 2
    (void)node__delete(&el->el_key.map, key);
    return 0;
d257 1
a257 3
key_print(el, key)
    EditLine *el;
    char   *key;
d259 10
a268 2
    /* do nothing if el->el_key.map is empty and null key specified */
    if (el->el_key.map == NULL && *key == 0)
a269 6

    el->el_key.buf[0] =  '"';
    if (node_lookup(el, key, el->el_key.map, 1) <= -1)
	/* key is not bound */
	(void)fprintf(el->el_errfile, "Unbound extended key \"%s\"\n", key);
    return;
d278 29
a306 33
node_trav(el, ptr, ch, val)
    EditLine     *el;
    key_node_t   *ptr;
    char         *ch;
    key_value_t  *val;
{
    if (ptr->ch == *ch) {
	/* match found */
	if (ptr->next) {
	    /* key not complete so get next char */
	    if (el_getc(el, ch) != 1) {	/* if EOF or error */
		val->cmd = ED_END_OF_FILE;
		return XK_CMD;/* PWP: Pretend we just read an end-of-file */
	    }
	    return node_trav(el, ptr->next, ch, val);
	}
	else {
	    *val = ptr->val;
	    if (ptr->type != XK_CMD)
		*ch = '\0';
	    return ptr->type;
	}
    }
    else {
	/* no match found here */
	if (ptr->sibling) {
	    /* try next sibling */
	    return node_trav(el, ptr->sibling, ch, val);
	}
	else {
	    /* no next sibling -- mismatch */
	    val->str = NULL;
	    return XK_STR;
a307 1
    }
d315 1
a315 5
node__try(ptr, str, val, ntype)
    key_node_t   *ptr;
    char         *str;
    key_value_t  *val;
    int           ntype;
a316 2
    if (ptr->ch != *str) {
	key_node_t *xm;
d318 2
a319 7
	for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
	    if (xm->sibling->ch == *str)
		break;
	if (xm->sibling == NULL)
	    xm->sibling = node__get(*str);	/* setup new node */
	ptr = xm->sibling;
    }
d321 28
a348 19
    if (*++str == '\0') {
	/* we're there */
	if (ptr->next != NULL) {
	    node__put(ptr->next);	/* lose longer keys with this prefix */
	    ptr->next = NULL;
	}
	switch (ptr->type) {
	case XK_CMD:
	case XK_NOD:
	    break;
	case XK_STR:
	case XK_EXE:
	    if (ptr->val.str)
		el_free((ptr_t) ptr->val.str);
	    break;
	default:
	    abort();
	    break;
	}
d350 17
a366 11
	switch (ptr->type = ntype) {
	case XK_CMD:
	    ptr->val = *val;
	    break;
	case XK_STR:
	case XK_EXE:
	    ptr->val.str = strdup(val->str);
	    break;
	default:
	    abort();
	    break;
d368 1
a368 8
    }
    else {
	/* still more chars to go */
	if (ptr->next == NULL)
	    ptr->next = node__get(*str);	/* setup new node */
	(void)node__try(ptr->next, str, val, ntype);
    }
    return 0;
d376 1
a376 3
node__delete(inptr, str)
    key_node_t **inptr;
    char   *str;
d378 2
a379 2
    key_node_t *ptr;
    key_node_t *prev_ptr = NULL;
d381 1
a381 1
    ptr = *inptr;
d383 35
a417 2
    if (ptr->ch != *str) {
	key_node_t *xm;
a418 34
	for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
	    if (xm->sibling->ch == *str)
		break;
	if (xm->sibling == NULL)
	    return 0;
	prev_ptr = xm;
	ptr = xm->sibling;
    }

    if (*++str == '\0') {
	/* we're there */
	if (prev_ptr == NULL)
	    *inptr = ptr->sibling;
	else
	    prev_ptr->sibling = ptr->sibling;
	ptr->sibling = NULL;
	node__put(ptr);
	return 1;
    }
    else if (ptr->next != NULL && node__delete(&ptr->next, str) == 1) {
	if (ptr->next != NULL)
	    return 0;
	if (prev_ptr == NULL)
	    *inptr = ptr->sibling;
	else
	    prev_ptr->sibling = ptr->sibling;
	ptr->sibling = NULL;
	node__put(ptr);
	return 1;
    }
    else {
	return 0;
    }
}
d424 1
a424 2
node__put(ptr)
    key_node_t *ptr;
d426 2
a427 2
    if (ptr == NULL)
	return;
d429 5
a433 4
    if (ptr->next != NULL) {
	node__put(ptr->next);
	ptr->next = NULL;
    }
d435 14
a448 16
    node__put(ptr->sibling);

    switch (ptr->type) {
    case XK_CMD:
    case XK_NOD:
	break;
    case XK_EXE:
    case XK_STR:
	if (ptr->val.str != NULL)
	    el_free((ptr_t) ptr->val.str);
	break;
    default:
	abort();
	break;
    }
    el_free((ptr_t) ptr);
d456 1
a456 2
node__get(ch)
    int    ch;
d458 1
a458 1
    key_node_t *ptr;
d460 9
a468 7
    ptr = (key_node_t *) el_malloc((size_t) sizeof(key_node_t));
    ptr->ch = ch;
    ptr->type = XK_NOD;
    ptr->val.str = NULL;
    ptr->next = NULL;
    ptr->sibling = NULL;
    return ptr;
d478 40
a517 32
node_lookup(el, str, ptr, cnt)
    EditLine   *el;
    char       *str;
    key_node_t *ptr;
    int         cnt;
{
    int     ncnt;

    if (ptr == NULL)
	return -1;		/* cannot have null ptr */

    if (*str == 0) {
	/* no more chars in str.  node_enum from here. */
	(void)node_enum(el, ptr, cnt);
	return 0;
    }
    else {
	/* If match put this char into el->el_key.buf.  Recurse */
	if (ptr->ch == *str) {
	    /* match found */
	    ncnt = key__decode_char(el->el_key.buf, cnt, 
				    (unsigned char) ptr->ch);
	    if (ptr->next != NULL)
		/* not yet at leaf */
		return node_lookup(el, str + 1, ptr->next, ncnt + 1);
	    else {
		/* next node is null so key should be complete */
		if (str[1] == 0) {
		    el->el_key.buf[ncnt + 1] = '"';
		    el->el_key.buf[ncnt + 2] = '\0';
		    key_kprint(el, el->el_key.buf, &ptr->val, ptr->type);
		    return 0;
a518 10
		else
		    return -1;/* mismatch -- str still has chars */
	    }
	}
	else {
	    /* no match found try sibling */
	    if (ptr->sibling)
		return node_lookup(el, str, ptr->sibling, cnt);
	    else
		return -1;
a519 1
    }
d527 8
a534 11
node_enum(el, ptr, cnt)
    EditLine *el;
    key_node_t *ptr;
    int     cnt;
{
    int     ncnt;

    if (cnt >= KEY_BUFSIZ - 5) {	/* buffer too small */
	el->el_key.buf[++cnt] = '"';
	el->el_key.buf[++cnt] = '\0';
	(void)fprintf(el->el_errfile, 
d536 4
a539 5
	(void)fprintf(el->el_errfile, " \"%s...\"\n", el->el_key.buf);
	return 0;
    }

    if (ptr == NULL) {
d541 2
a542 1
	(void)fprintf(el->el_errfile, "node_enum: BUG!! Null ptr passed\n!");
d544 16
a559 18
	return -1;
    }

    /* put this char at end of str */
    ncnt = key__decode_char(el->el_key.buf, cnt, (unsigned char) ptr->ch);
    if (ptr->next == NULL) {
	/* print this key and function */
	el->el_key.buf[ncnt + 1] = '"';
	el->el_key.buf[ncnt + 2] = '\0';
	key_kprint(el, el->el_key.buf, &ptr->val, ptr->type);
    }
    else
	(void)node_enum(el, ptr->next, ncnt + 1);

    /* go to sibling if there is one */
    if (ptr->sibling)
	(void)node_enum(el, ptr->sibling, cnt);
    return 0;
d568 21
a588 24
key_kprint(el, key, val, ntype)
    EditLine      *el;
    char          *key;
    key_value_t   *val;
    int            ntype;
{
    el_bindings_t *fp;
    char unparsbuf[EL_BUFSIZ];
    static char *fmt = "%-15s->  %s\n";

    if (val != NULL)
	switch (ntype) {
	case XK_STR:
	case XK_EXE:
	    (void)fprintf(el->el_errfile, fmt, key, 
			   key__decode_str(val->str, unparsbuf, 
					      ntype == XK_STR ? "\"\"" : "[]"));
	    break;
	case XK_CMD:
	    for (fp = el->el_map.help; fp->name; fp++) 
		if (val->cmd == fp->func) {
		    (void)fprintf(el->el_errfile, fmt, key, fp->name);
		    break;
		}
d590 3
a592 2
	    if (fp->name == NULL) 
		(void)fprintf(el->el_errfile, "BUG! Command not found.\n");
d595 7
a601 7
	    break;
	default:
	    abort();
	    break;
	}
    else
	(void)fprintf(el->el_errfile, fmt, key, "no input");
d609 28
a636 35
key__decode_char(buf, cnt, ch)
    char *buf;
    int   cnt, ch;
{
    if (ch == 0) {
	buf[cnt++] = '^';
	buf[cnt] = '@@';
	return cnt;
    }

    if (iscntrl(ch)) {
	buf[cnt++] = '^';
	if (ch == '\177')
	    buf[cnt] = '?';
	else
	    buf[cnt] = ch | 0100;
    }
    else if (ch == '^') {
	buf[cnt++] = '\\';
	buf[cnt] = '^';
    }
    else if (ch == '\\') {
	buf[cnt++] = '\\';
	buf[cnt] = '\\';
    }
    else if (ch == ' ' || (isprint(ch) && !isspace(ch))) {
	buf[cnt] = ch;
    }
    else {
	buf[cnt++] = '\\';
	buf[cnt++] = ((ch >> 6) & 7) + '0';
	buf[cnt++] = ((ch >> 3) & 7) + '0';
	buf[cnt] = (ch & 7) + '0';
    }
    return cnt;
d639 1
d644 36
a679 13
key__decode_str(str, buf, sep)
    char   *str;
    char   *buf;
    char   *sep;
{
    char *b, *p;

    b = buf;
    if (sep[0] != '\0')
	*b++ = sep[0];
    if (*str == 0) {
	*b++ = '^';
	*b++ = '@@';
d681 1
a681 1
	    *b++ = sep[1];
d683 1
a683 30
	return buf;
    }

    for (p = str; *p != 0; p++) {
	if (iscntrl((unsigned char) *p)) {
	    *b++ = '^';
	    if (*p == '\177')
		*b++ = '?';
	    else
		*b++ = *p | 0100;
	}
	else if (*p == '^' || *p == '\\') {
	    *b++ = '\\';
	    *b++ = *p;
	}
	else if (*p == ' ' || (isprint((unsigned char) *p) && 
			       !isspace((unsigned char) *p))) {
	    *b++ = *p;
	}
	else {
	    *b++ = '\\';
	    *b++ = ((*p >> 6) & 7) + '0';
	    *b++ = ((*p >> 3) & 7) + '0';
	    *b++ = (*p & 7) + '0';
	}
    }
    if (sep[0] != '\0' && sep[1] != '\0')
	*b++ = sep[1];
    *b++ = 0;
    return buf;			/* should check for overflow */
@


1.6
log
@is -Wall clean by making rcsid const
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.5 2002/02/17 19:42:25 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: key.c,v 1.5 2002/02/17 19:42:25 millert Exp $";
@


1.5
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.4 2002/02/16 21:27:26 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: key.c,v 1.4 2002/02/16 21:27:26 millert Exp $";
@


1.4
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.3 1997/03/14 05:12:52 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: key.c,v 1.3 1997/03/14 05:12:52 millert Exp $";
d88 3
a90 4
private	int            node_trav	__P((EditLine *, key_node_t *, char *, 
					     key_value_t *));
private	int            node__try	__P((key_node_t *, char *, 
					     key_value_t *, int));
d94 1
a94 2
private	int	       node_lookup 	__P((EditLine *, char *, key_node_t *,
					     int));
@


1.3
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.2 1997/01/16 05:18:36 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: key.c,v 1.2 1997/01/16 05:18:36 millert Exp $";
d92 3
a94 3
private	key_node_t    *node__get	__P((int));
private	void	       node__put	__P((key_node_t *));
private	int	       node__delete	__P((key_node_t **, char *));
d97 2
a98 2
private	int	       node_enum	__P((EditLine *, key_node_t *, int));
private	int	       key__decode_char	__P((char *, int, int));
@


1.2
log
@Merge in NetBSD libedit changes and new man pages.  Also fix some
strncpy() usage in their code.  NetBSD change log was:
    * add a man page for the editline routines
    * add a man page describing editrc
    * fix bugs in el_parse():
      * didn't execute command when program name matched (test reversed)
      * was checking against empty string instead of program name
      * after checks, command to run also pointed to empty string
    * document ^char and \ escape sequences
    * when parsing ^char control chars, check the correct char when determining
      validity (previously, ^char was a NOP interpreted as the literal string
      because of this bug)
    * Implement CC_REDISPLAY, which (unlike CC_REFRESH) redraws the entire input
    * line (a la ^R). This is useful if the binding outputs information and
    * mucks up the input line. To be used in ``list-choices'' bindings (refer
    * to the ^D binding in csh when filec is set)
@
text
@d1 2
a2 1
/*	$OpenBSD: $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: $";
d205 1
a205 1
	(void) fprintf(el->el_errfile, 
d211 1
a211 1
	(void) fprintf(el->el_errfile,
d221 1
a221 1
    (void) node__try(el->el_key.map, key, val, ntype);	
d240 1
a240 1
	(void) key_delete(el, in);
d254 1
a254 1
	(void) fprintf(el->el_errfile, 
d262 1
a262 1
    (void) node__delete(&el->el_key.map, key);
d283 1
a283 1
	(void) fprintf(el->el_errfile, "Unbound extended key \"%s\"\n", key);
d389 1
a389 1
	(void) node__try(ptr->next, str, val, ntype);
d518 1
a518 1
	(void) node_enum(el, ptr, cnt);
d567 1
a567 1
	(void) fprintf(el->el_errfile, 
d569 1
a569 1
	(void) fprintf(el->el_errfile, " \"%s...\"\n", el->el_key.buf);
d575 1
a575 1
	(void) fprintf(el->el_errfile, "node_enum: BUG!! Null ptr passed\n!");
d589 1
a589 1
	(void) node_enum(el, ptr->next, ncnt + 1);
d593 1
a593 1
	(void) node_enum(el, ptr->sibling, cnt);
d617 1
a617 1
	    (void) fprintf(el->el_errfile, fmt, key, 
d624 1
a624 1
		    (void) fprintf(el->el_errfile, fmt, key, fp->name);
d629 1
a629 1
		(void) fprintf(el->el_errfile, "BUG! Command not found.\n");
d638 1
a638 1
	(void) fprintf(el->el_errfile, fmt, key, "no input");
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
d42 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
