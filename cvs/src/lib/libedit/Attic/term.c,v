head	1.18;
access;
symbols
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.10
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.11.0.26
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.22
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.20
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.18
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.16
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.14
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.12
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.18
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.01.29.17.23.21;	author schwarze;	state dead;
branches;
next	1.17;
commitid	MOfHvqt1MJvqXmCY;

1.17
date	2014.10.17.06.07.50;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	bdUOvGFxUQgqZg7x;

1.16
date	2014.01.19.11.48.54;	author tobias;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.07.05.40.42;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.11.18.58.59;	author jacekm;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.01.21.11.21;	author avsm;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.05.00.43.20;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.29.20.13.39;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.17.19.42.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.03.14.25.29;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.03.14.05.13.05;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.16.05.18.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.42;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Start synching with NetBSD:
Rename the files key.[hc] to keymacro.[hc] and term.[hc] to terminal.[hc].
The change makes sense because "term.h" conflicts with <term.h>
and the functions key_clear(), key_end(), and key_print() in "key.h"
conflict with macros in <term.h>.
No content change yet, no binary change in *.o after "strip -d".
This reduces the remaining diff from +4634 -3992 to +2640 -1998.
OK czarkoff@@, and mmcc@@ agrees with the direction.
@
text
@/*	$OpenBSD: term.c,v 1.17 2014/10/17 06:07:50 deraadt Exp $	*/
/*	$NetBSD: term.c,v 1.57 2009/12/30 22:37:40 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * term.c: Editor/termcap-curses interface
 *	   We have to declare a static variable here, since the
 *	   termcap putchar routine does not take an argument!
 */
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#ifdef HAVE_TERMCAP_H
#include <termcap.h>
#endif
#ifdef HAVE_CURSES_H
#include <curses.h>
#elif HAVE_NCURSES_H
#include <ncurses.h>
#endif
/* Solaris's term.h does horrid things. */

#if defined(HAVE_TERM_H) && !defined(__sun)
#include <term.h>
#endif
#include <sys/types.h>
#include <sys/ioctl.h>

#ifdef _REENTRANT
#include <pthread.h>
#endif

#include "el.h"

/*
 * IMPORTANT NOTE: these routines are allowed to look at the current screen
 * and the current position assuming that it is correct.  If this is not
 * true, then the update will be WRONG!  This is (should be) a valid
 * assumption...
 */

#define	TC_BUFSIZE	2048

#define	GoodStr(a)	(el->el_term.t_str[a] != NULL && \
			    el->el_term.t_str[a][0] != '\0')
#define	Str(a)		el->el_term.t_str[a]
#define	Val(a)		el->el_term.t_val[a]

#ifdef notdef
private const struct {
	const char *b_name;
	int b_rate;
} baud_rate[] = {
#ifdef B0
	{ "0", B0 },
#endif
#ifdef B50
	{ "50", B50 },
#endif
#ifdef B75
	{ "75", B75 },
#endif
#ifdef B110
	{ "110", B110 },
#endif
#ifdef B134
	{ "134", B134 },
#endif
#ifdef B150
	{ "150", B150 },
#endif
#ifdef B200
	{ "200", B200 },
#endif
#ifdef B300
	{ "300", B300 },
#endif
#ifdef B600
	{ "600", B600 },
#endif
#ifdef B900
	{ "900", B900 },
#endif
#ifdef B1200
	{ "1200", B1200 },
#endif
#ifdef B1800
	{ "1800", B1800 },
#endif
#ifdef B2400
	{ "2400", B2400 },
#endif
#ifdef B3600
	{ "3600", B3600 },
#endif
#ifdef B4800
	{ "4800", B4800 },
#endif
#ifdef B7200
	{ "7200", B7200 },
#endif
#ifdef B9600
	{ "9600", B9600 },
#endif
#ifdef EXTA
	{ "19200", EXTA },
#endif
#ifdef B19200
	{ "19200", B19200 },
#endif
#ifdef EXTB
	{ "38400", EXTB },
#endif
#ifdef B38400
	{ "38400", B38400 },
#endif
	{ NULL, 0 }
};
#endif

private const struct termcapstr {
	const char *name;
	const char *long_name;
} tstr[] = {
#define	T_al	0
	{ "al", "add new blank line" },
#define	T_bl	1
	{ "bl", "audible bell" },
#define	T_cd	2
	{ "cd", "clear to bottom" },
#define	T_ce	3
	{ "ce", "clear to end of line" },
#define	T_ch	4
	{ "ch", "cursor to horiz pos" },
#define	T_cl	5
	{ "cl", "clear screen" },
#define	T_dc	6
	{ "dc", "delete a character" },
#define	T_dl	7
	{ "dl", "delete a line" },
#define	T_dm	8
	{ "dm", "start delete mode" },
#define	T_ed	9
	{ "ed", "end delete mode" },
#define	T_ei	10
	{ "ei", "end insert mode" },
#define	T_fs	11
	{ "fs", "cursor from status line" },
#define	T_ho	12
	{ "ho", "home cursor" },
#define	T_ic	13
	{ "ic", "insert character" },
#define	T_im	14
	{ "im", "start insert mode" },
#define	T_ip	15
	{ "ip", "insert padding" },
#define	T_kd	16
	{ "kd", "sends cursor down" },
#define	T_kl	17
	{ "kl", "sends cursor left" },
#define	T_kr	18
	{ "kr", "sends cursor right" },
#define	T_ku	19
	{ "ku", "sends cursor up" },
#define	T_md	20
	{ "md", "begin bold" },
#define	T_me	21
	{ "me", "end attributes" },
#define	T_nd	22
	{ "nd", "non destructive space" },
#define	T_se	23
	{ "se", "end standout" },
#define	T_so	24
	{ "so", "begin standout" },
#define	T_ts	25
	{ "ts", "cursor to status line" },
#define	T_up	26
	{ "up", "cursor up one" },
#define	T_us	27
	{ "us", "begin underline" },
#define	T_ue	28
	{ "ue", "end underline" },
#define	T_vb	29
	{ "vb", "visible bell" },
#define	T_DC	30
	{ "DC", "delete multiple chars" },
#define	T_DO	31
	{ "DO", "cursor down multiple" },
#define	T_IC	32
	{ "IC", "insert multiple chars" },
#define	T_LE	33
	{ "LE", "cursor left multiple" },
#define	T_RI	34
	{ "RI", "cursor right multiple" },
#define	T_UP	35
	{ "UP", "cursor up multiple" },
#define	T_kh	36
	{ "kh", "send cursor home" },
#define	T_at7	37
	{ "@@7", "send cursor end" },
#define	T_str	38
	{ NULL, NULL }
};

private const struct termcapval {
	const char *name;
	const char *long_name;
} tval[] = {
#define	T_am	0
	{ "am", "has automatic margins" },
#define	T_pt	1
	{ "pt", "has physical tabs" },
#define	T_li	2
	{ "li", "Number of lines" },
#define	T_co	3
	{ "co", "Number of columns" },
#define	T_km	4
	{ "km", "Has meta key" },
#define	T_xt	5
	{ "xt", "Tab chars destructive" },
#define	T_xn	6
	{ "xn", "newline ignored at right margin" },
#define	T_MT	7
	{ "MT", "Has meta key" },			/* XXX? */
#define	T_val	8
	{ NULL, NULL, }
};
/* do two or more of the attributes use me */

private void	term_setflags(EditLine *);
private int	term_rebuffer_display(EditLine *);
private void	term_free_display(EditLine *);
private int	term_alloc_display(EditLine *);
private void	term_alloc(EditLine *, const struct termcapstr *, const char *);
private void	term_init_arrow(EditLine *);
private void	term_reset_arrow(EditLine *);
private int	term_putc(int);
private void	term_tputs(EditLine *, const char *, int);

#ifdef _REENTRANT
private pthread_mutex_t term_mutex = PTHREAD_MUTEX_INITIALIZER;
#endif
private FILE *term_outfile = NULL;


/* term_setflags():
 *	Set the terminal capability flags
 */
private void
term_setflags(EditLine *el)
{
	EL_FLAGS = 0;
	if (el->el_tty.t_tabs)
		EL_FLAGS |= (Val(T_pt) && !Val(T_xt)) ? TERM_CAN_TAB : 0;

	EL_FLAGS |= (Val(T_km) || Val(T_MT)) ? TERM_HAS_META : 0;
	EL_FLAGS |= GoodStr(T_ce) ? TERM_CAN_CEOL : 0;
	EL_FLAGS |= (GoodStr(T_dc) || GoodStr(T_DC)) ? TERM_CAN_DELETE : 0;
	EL_FLAGS |= (GoodStr(T_im) || GoodStr(T_ic) || GoodStr(T_IC)) ?
	    TERM_CAN_INSERT : 0;
	EL_FLAGS |= (GoodStr(T_up) || GoodStr(T_UP)) ? TERM_CAN_UP : 0;
	EL_FLAGS |= Val(T_am) ? TERM_HAS_AUTO_MARGINS : 0;
	EL_FLAGS |= Val(T_xn) ? TERM_HAS_MAGIC_MARGINS : 0;

	if (GoodStr(T_me) && GoodStr(T_ue))
		EL_FLAGS |= (strcmp(Str(T_me), Str(T_ue)) == 0) ?
		    TERM_CAN_ME : 0;
	else
		EL_FLAGS &= ~TERM_CAN_ME;
	if (GoodStr(T_me) && GoodStr(T_se))
		EL_FLAGS |= (strcmp(Str(T_me), Str(T_se)) == 0) ?
		    TERM_CAN_ME : 0;


#ifdef DEBUG_SCREEN
	if (!EL_CAN_UP) {
		(void) fprintf(el->el_errfile,
		    "WARNING: Your terminal cannot move up.\n");
		(void) fprintf(el->el_errfile,
		    "Editing may be odd for long lines.\n");
	}
	if (!EL_CAN_CEOL)
		(void) fprintf(el->el_errfile, "no clear EOL capability.\n");
	if (!EL_CAN_DELETE)
		(void) fprintf(el->el_errfile, "no delete char capability.\n");
	if (!EL_CAN_INSERT)
		(void) fprintf(el->el_errfile, "no insert char capability.\n");
#endif /* DEBUG_SCREEN */
}

/* term_init():
 *	Initialize the terminal stuff
 */
protected int
term_init(EditLine *el)
{

	el->el_term.t_buf = (char *)malloc(TC_BUFSIZE);
	if (el->el_term.t_buf == NULL)
		goto fail;
	el->el_term.t_cap = (char *)malloc(TC_BUFSIZE);
	if (el->el_term.t_cap == NULL)
		goto fail2;
	el->el_term.t_fkey = reallocarray(NULL, A_K_NKEYS, sizeof(fkey_t));
	if (el->el_term.t_fkey == NULL)
		goto fail3;
	el->el_term.t_loc = 0;
	el->el_term.t_str = reallocarray(NULL, T_str, sizeof(char *));
	if (el->el_term.t_str == NULL)
		goto fail4;
	(void) memset(el->el_term.t_str, 0, T_str * sizeof(char *));
	el->el_term.t_val = reallocarray(NULL, T_val, sizeof(int));
	if (el->el_term.t_val == NULL)
		goto fail5;
	(void) memset(el->el_term.t_val, 0, T_val * sizeof(int));
	(void) term_set(el, NULL);
	term_init_arrow(el);
	return (0);
fail5:
	free(el->el_term.t_str);
	el->el_term.t_str = NULL;
fail4:
	free(el->el_term.t_fkey);
	el->el_term.t_fkey = NULL;
fail3:
	free(el->el_term.t_cap);
	el->el_term.t_cap = NULL;
fail2:
	free(el->el_term.t_buf);
	el->el_term.t_buf = NULL;
fail:
	return (-1);
}

/* term_end():
 *	Clean up the terminal stuff
 */
protected void
term_end(EditLine *el)
{

	free((ptr_t) el->el_term.t_buf);
	el->el_term.t_buf = NULL;
	free((ptr_t) el->el_term.t_cap);
	el->el_term.t_cap = NULL;
	el->el_term.t_loc = 0;
	free((ptr_t) el->el_term.t_str);
	el->el_term.t_str = NULL;
	free((ptr_t) el->el_term.t_val);
	el->el_term.t_val = NULL;
	free((ptr_t) el->el_term.t_fkey);
	el->el_term.t_fkey = NULL;
	term_free_display(el);
}


/* term_alloc():
 *	Maintain a string pool for termcap strings
 */
private void
term_alloc(EditLine *el, const struct termcapstr *t, const char *cap)
{
	char termbuf[TC_BUFSIZE];
	size_t tlen, clen;
	char **tlist = el->el_term.t_str;
	char **tmp, **str = &tlist[t - tstr];

	if (cap == NULL || *cap == '\0') {
		*str = NULL;
		return;
	} else
		clen = strlen(cap);

	tlen = *str == NULL ? 0 : strlen(*str);

	/*
         * New string is shorter; no need to allocate space
         */
	if (clen <= tlen) {
		if (*str)
			(void) strlcpy(*str, cap, tlen + 1);
		return;
	}
	/*
         * New string is longer; see if we have enough space to append
         */
	if (el->el_term.t_loc + 3 < TC_BUFSIZE) {
		tlen = TC_BUFSIZE - el->el_term.t_loc;
		(void) strlcpy(*str = &el->el_term.t_buf[el->el_term.t_loc],
		    cap, tlen);
		el->el_term.t_loc += (int)clen + 1;	/* one for \0 */
		return;
	}
	/*
         * Compact our buffer; no need to check compaction, cause we know it
         * fits...
         */
	tlen = 0;
	for (tmp = tlist; tmp < &tlist[T_str]; tmp++)
		if (*tmp != NULL && *tmp != '\0' && *tmp != *str) {
			char *ptr;

			for (ptr = *tmp; *ptr != '\0'; termbuf[tlen++] = *ptr++)
				continue;
			termbuf[tlen++] = '\0';
		}
	memcpy(el->el_term.t_buf, termbuf, TC_BUFSIZE);
	el->el_term.t_loc = (int)tlen;
	if (el->el_term.t_loc + 3 >= TC_BUFSIZE) {
		(void) fprintf(el->el_errfile,
		    "Out of termcap string space.\n");
		return;
	}
	tlen = TC_BUFSIZE - el->el_term.t_loc;
	(void) strlcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap, tlen);
	el->el_term.t_loc += (int)clen + 1;	/* one for \0 */
	return;
}


/* term_rebuffer_display():
 *	Rebuffer the display after the screen changed size
 */
private int
term_rebuffer_display(EditLine *el)
{
	coord_t *c = &el->el_term.t_size;

	term_free_display(el);

	c->h = Val(T_co);
	c->v = Val(T_li);

	if (term_alloc_display(el) == -1)
		return (-1);
	return (0);
}


/* term_alloc_display():
 *	Allocate a new display.
 */
private int
term_alloc_display(EditLine *el)
{
	int i, rv = -1;
	Char **b;
	coord_t *c = &el->el_term.t_size;

	b = reallocarray(NULL, c->v + 1, sizeof(*b));
	if (b == NULL)
		goto done;
	for (i = 0; i < c->v; i++) {
		b[i] = reallocarray(NULL, c->h + 1, sizeof(**b));
		if (b[i] == NULL) {
			while (--i >= 0)
				free((ptr_t) b[i]);
			free((ptr_t) b);
			goto done;
		}
	}
	b[c->v] = NULL;
	el->el_display = b;

	b = reallocarray(NULL, c->v + 1, sizeof(*b));
	if (b == NULL)
		goto done;
	for (i = 0; i < c->v; i++) {
		b[i] = reallocarray(NULL, c->h + 1, sizeof(**b));
		if (b[i] == NULL) {
			while (--i >= 0)
				free((ptr_t) b[i]);
			free((ptr_t) b);
			goto done;
		}
	}
	b[c->v] = NULL;
	el->el_vdisplay = b;

	rv = 0;
done:
	if (rv)
		term_free_display(el);
	return (rv);
}


/* term_free_display():
 *	Free the display buffers
 */
private void
term_free_display(EditLine *el)
{
	Char **b;
	Char **bufp;

	b = el->el_display;
	el->el_display = NULL;
	if (b != NULL) {
		for (bufp = b; *bufp != NULL; bufp++)
			free((ptr_t) *bufp);
		free((ptr_t) b);
	}
	b = el->el_vdisplay;
	el->el_vdisplay = NULL;
	if (b != NULL) {
		for (bufp = b; *bufp != NULL; bufp++)
			free((ptr_t) *bufp);
		free((ptr_t) b);
	}
}


/* term_move_to_line():
 *	move to line <where> (first line == 0)
 * 	as efficiently as possible
 */
protected void
term_move_to_line(EditLine *el, int where)
{
	int del;

	if (where == el->el_cursor.v)
		return;

	if (where > el->el_term.t_size.v) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "term_move_to_line: where is ridiculous: %d\r\n", where);
#endif /* DEBUG_SCREEN */
		return;
	}
	if ((del = where - el->el_cursor.v) > 0) {
		while (del > 0) {
			if (EL_HAS_AUTO_MARGINS &&
			    el->el_display[el->el_cursor.v][0] != '\0') {
                                size_t h = el->el_term.t_size.h - 1;
#ifdef WIDECHAR
                                for (; h > 0 &&
                                         el->el_display[el->el_cursor.v][h] ==
                                                 MB_FILL_CHAR;
                                         h--)
                                                continue;
#endif
				/* move without newline */
				term_move_to_char(el, (int)h);
				term_overwrite(el, &el->el_display
				    [el->el_cursor.v][el->el_cursor.h],
				    (size_t)(el->el_term.t_size.h -
				    el->el_cursor.h));
				/* updates Cursor */
				del--;
			} else {
				if ((del > 1) && GoodStr(T_DO)) {
					term_tputs(el, tgoto(Str(T_DO), del,
					    del), del);
					del = 0;
				} else {
					for (; del > 0; del--)
						term__putc(el, '\n');
					/* because the \n will become \r\n */
					el->el_cursor.h = 0;
				}
			}
		}
	} else {		/* del < 0 */
		if (GoodStr(T_UP) && (-del > 1 || !GoodStr(T_up)))
			term_tputs(el, tgoto(Str(T_UP), -del, -del), -del);
		else {
			if (GoodStr(T_up))
				for (; del < 0; del++)
					term_tputs(el, Str(T_up), 1);
		}
	}
	el->el_cursor.v = where;/* now where is here */
}


/* term_move_to_char():
 *	Move to the character position specified
 */
protected void
term_move_to_char(EditLine *el, int where)
{
	int del, i;

mc_again:
	if (where == el->el_cursor.h)
		return;

	if (where > el->el_term.t_size.h) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "term_move_to_char: where is riduculous: %d\r\n", where);
#endif /* DEBUG_SCREEN */
		return;
	}
	if (!where) {		/* if where is first column */
		term__putc(el, '\r');	/* do a CR */
		el->el_cursor.h = 0;
		return;
	}
	del = where - el->el_cursor.h;

	if ((del < -4 || del > 4) && GoodStr(T_ch))
		/* go there directly */
		term_tputs(el, tgoto(Str(T_ch), where, where), where);
	else {
		if (del > 0) {	/* moving forward */
			if ((del > 4) && GoodStr(T_RI))
				term_tputs(el, tgoto(Str(T_RI), del, del), del);
			else {
					/* if I can do tabs, use them */
				if (EL_CAN_TAB) {
					if ((el->el_cursor.h & 0370) !=
					    (where & ~0x7)
#ifdef WIDECHAR
					    && (el->el_display[
					    el->el_cursor.v][where & 0370] !=
					    MB_FILL_CHAR)
#endif
					    ) {
						/* if not within tab stop */
						for (i =
						    (el->el_cursor.h & 0370);
						    i < (where & ~0x7);
						    i += 8)
							term__putc(el, '\t');	
							/* then tab over */
						el->el_cursor.h = where & ~0x7;
					}
				}
				/*
				 * it's usually cheaper to just write the
				 * chars, so we do.
				 */
				/*
				 * NOTE THAT term_overwrite() WILL CHANGE
				 * el->el_cursor.h!!!
				 */
				term_overwrite(el, &el->el_display[
				    el->el_cursor.v][el->el_cursor.h],
				    (size_t)(where - el->el_cursor.h));

			}
		} else {	/* del < 0 := moving backward */
			if ((-del > 4) && GoodStr(T_LE))
				term_tputs(el, tgoto(Str(T_LE), -del, -del),
				    -del);
			else {	/* can't go directly there */
				/*
				 * if the "cost" is greater than the "cost"
				 * from col 0
				 */
				if (EL_CAN_TAB ?
				    ((unsigned int)-del >
				    (((unsigned int) where >> 3) +
				     (where & 07)))
				    : (-del > where)) {
					term__putc(el, '\r');	/* do a CR */
					el->el_cursor.h = 0;
					goto mc_again;	/* and try again */
				}
				for (i = 0; i < -del; i++)
					term__putc(el, '\b');
			}
		}
	}
	el->el_cursor.h = where;		/* now where is here */
}


/* term_overwrite():
 *	Overstrike num characters
 *	Assumes MB_FILL_CHARs are present to keep the column count correct
 */
protected void
term_overwrite(EditLine *el, const Char *cp, size_t n)
{
	if (n == 0)
		return;

	if (n > (size_t)el->el_term.t_size.h) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "term_overwrite: n is riduculous: %d\r\n", n);
#endif /* DEBUG_SCREEN */
		return;
	}

        do {
                /* term__putc() ignores any MB_FILL_CHARs */
                term__putc(el, *cp++);
                el->el_cursor.h++;
        } while (--n);

	if (el->el_cursor.h >= el->el_term.t_size.h) {	/* wrap? */
		if (EL_HAS_AUTO_MARGINS) {	/* yes */
			el->el_cursor.h = 0;
			el->el_cursor.v++;
			if (EL_HAS_MAGIC_MARGINS) {
				/* force the wrap to avoid the "magic"
				 * situation */
				Char c;
				if ((c = el->el_display[el->el_cursor.v]
				    [el->el_cursor.h]) != '\0') {
					term_overwrite(el, &c, 1);
#ifdef WIDECHAR
					while (el->el_display[el->el_cursor.v]
					    [el->el_cursor.h] == MB_FILL_CHAR)
						el->el_cursor.h++;
#endif
				} else {
					term__putc(el, ' ');
					el->el_cursor.h = 1;
				}
			}
		} else		/* no wrap, but cursor stays on screen */
			el->el_cursor.h = el->el_term.t_size.h - 1;
	}
}


/* term_deletechars():
 *	Delete num characters
 */
protected void
term_deletechars(EditLine *el, int num)
{
	if (num <= 0)
		return;

	if (!EL_CAN_DELETE) {
#ifdef DEBUG_EDIT
		(void) fprintf(el->el_errfile, "   ERROR: cannot delete   \n");
#endif /* DEBUG_EDIT */
		return;
	}
	if (num > el->el_term.t_size.h) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "term_deletechars: num is riduculous: %d\r\n", num);
#endif /* DEBUG_SCREEN */
		return;
	}
	if (GoodStr(T_DC))	/* if I have multiple delete */
		if ((num > 1) || !GoodStr(T_dc)) {	/* if dc would be more
							 * expen. */
			term_tputs(el, tgoto(Str(T_DC), num, num), num);
			return;
		}
	if (GoodStr(T_dm))	/* if I have delete mode */
		term_tputs(el, Str(T_dm), 1);

	if (GoodStr(T_dc))	/* else do one at a time */
		while (num--)
			term_tputs(el, Str(T_dc), 1);

	if (GoodStr(T_ed))	/* if I have delete mode */
		term_tputs(el, Str(T_ed), 1);
}


/* term_insertwrite():
 *	Puts terminal in insert character mode or inserts num
 *	characters in the line
 *      Assumes MB_FILL_CHARs are present to keep column count correct
 */
protected void
term_insertwrite(EditLine *el, Char *cp, int num)
{
	if (num <= 0)
		return;
	if (!EL_CAN_INSERT) {
#ifdef DEBUG_EDIT
		(void) fprintf(el->el_errfile, "   ERROR: cannot insert   \n");
#endif /* DEBUG_EDIT */
		return;
	}
	if (num > el->el_term.t_size.h) {
#ifdef DEBUG_SCREEN
		(void) fprintf(el->el_errfile,
		    "StartInsert: num is riduculous: %d\r\n", num);
#endif /* DEBUG_SCREEN */
		return;
	}
	if (GoodStr(T_IC))	/* if I have multiple insert */
		if ((num > 1) || !GoodStr(T_ic)) {
				/* if ic would be more expensive */
			term_tputs(el, tgoto(Str(T_IC), num, num), num);
			term_overwrite(el, cp, (size_t)num);
				/* this updates el_cursor.h */
			return;
		}
	if (GoodStr(T_im) && GoodStr(T_ei)) {	/* if I have insert mode */
		term_tputs(el, Str(T_im), 1);

		el->el_cursor.h += num;
		do
			term__putc(el, *cp++);
		while (--num);

		if (GoodStr(T_ip))	/* have to make num chars insert */
			term_tputs(el, Str(T_ip), 1);

		term_tputs(el, Str(T_ei), 1);
		return;
	}
	do {
		if (GoodStr(T_ic))	/* have to make num chars insert */
			term_tputs(el, Str(T_ic), 1);

		term__putc(el, *cp++);

		el->el_cursor.h++;

		if (GoodStr(T_ip))	/* have to make num chars insert */
			term_tputs(el, Str(T_ip), 1);
					/* pad the inserted char */

	} while (--num);
}


/* term_clear_EOL():
 *	clear to end of line.  There are num characters to clear
 */
protected void
term_clear_EOL(EditLine *el, int num)
{
	int i;

	if (EL_CAN_CEOL && GoodStr(T_ce))
		term_tputs(el, Str(T_ce), 1);
	else {
		for (i = 0; i < num; i++)
			term__putc(el, ' ');
		el->el_cursor.h += num;	/* have written num spaces */
	}
}


/* term_clear_screen():
 *	Clear the screen
 */
protected void
term_clear_screen(EditLine *el)
{				/* clear the whole screen and home */

	if (GoodStr(T_cl))
		/* send the clear screen code */
		term_tputs(el, Str(T_cl), Val(T_li));
	else if (GoodStr(T_ho) && GoodStr(T_cd)) {
		term_tputs(el, Str(T_ho), Val(T_li));	/* home */
		/* clear to bottom of screen */
		term_tputs(el, Str(T_cd), Val(T_li));
	} else {
		term__putc(el, '\r');
		term__putc(el, '\n');
	}
}


/* term_beep():
 *	Beep the way the terminal wants us
 */
protected void
term_beep(EditLine *el)
{
	if (GoodStr(T_bl))
		/* what termcap says we should use */
		term_tputs(el, Str(T_bl), 1);
	else
		term__putc(el, '\007');	/* an ASCII bell; ^G */
}


#ifdef notdef
/* term_clear_to_bottom():
 *	Clear to the bottom of the screen
 */
protected void
term_clear_to_bottom(EditLine *el)
{
	if (GoodStr(T_cd))
		term_tputs(el, Str(T_cd), Val(T_li));
	else if (GoodStr(T_ce))
		term_tputs(el, Str(T_ce), Val(T_li));
}
#endif

protected void
term_get(EditLine *el, const char **term)
{
	*term = el->el_term.t_name;
}


/* term_set():
 *	Read in the terminal capabilities from the requested terminal
 */
protected int
term_set(EditLine *el, const char *term)
{
	int i;
	char buf[TC_BUFSIZE];
	char *area;
	const struct termcapstr *t;
	sigset_t oset, nset;
	int lins, cols;

	(void) sigemptyset(&nset);
	(void) sigaddset(&nset, SIGWINCH);
	(void) sigprocmask(SIG_BLOCK, &nset, &oset);

	area = buf;


	if (term == NULL)
		term = getenv("TERM");

	if (!term || !term[0])
		term = "dumb";

	if (strcmp(term, "emacs") == 0)
		el->el_flags |= EDIT_DISABLED;

	memset(el->el_term.t_cap, 0, TC_BUFSIZE);

	i = tgetent(el->el_term.t_cap, term);

	if (i <= 0) {
		if (i == -1)
			(void) fprintf(el->el_errfile,
			    "Cannot read termcap database;\n");
		else if (i == 0)
			(void) fprintf(el->el_errfile,
			    "No entry for terminal type \"%s\";\n", term);
		(void) fprintf(el->el_errfile,
		    "using dumb terminal settings.\n");
		Val(T_co) = 80;	/* do a dumb terminal */
		Val(T_pt) = Val(T_km) = Val(T_li) = 0;
		Val(T_xt) = Val(T_MT);
		for (t = tstr; t->name != NULL; t++)
			term_alloc(el, t, NULL);
	} else {
		/* auto/magic margins */
		Val(T_am) = tgetflag("am");
		Val(T_xn) = tgetflag("xn");
		/* Can we tab */
		Val(T_pt) = tgetflag("pt");
		Val(T_xt) = tgetflag("xt");
		/* do we have a meta? */
		Val(T_km) = tgetflag("km");
		Val(T_MT) = tgetflag("MT");
		/* Get the size */
		Val(T_co) = tgetnum("co");
		Val(T_li) = tgetnum("li");
		for (t = tstr; t->name != NULL; t++) {
			/* XXX: some systems' tgetstr needs non const */
			term_alloc(el, t, tgetstr(strchr(t->name, *t->name),
			    &area));
		}
	}

	if (Val(T_co) < 2)
		Val(T_co) = 80;	/* just in case */
	if (Val(T_li) < 1)
		Val(T_li) = 24;

	el->el_term.t_size.v = Val(T_co);
	el->el_term.t_size.h = Val(T_li);

	term_setflags(el);

				/* get the correct window size */
	(void) term_get_size(el, &lins, &cols);
	if (term_change_size(el, lins, cols) == -1)
		return (-1);
	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
	term_bind_arrow(el);
	el->el_term.t_name = term;
	return (i <= 0 ? -1 : 0);
}


/* term_get_size():
 *	Return the new window size in lines and cols, and
 *	true if the size was changed.
 */
protected int
term_get_size(EditLine *el, int *lins, int *cols)
{

	*cols = Val(T_co);
	*lins = Val(T_li);

#ifdef TIOCGWINSZ
	{
		struct winsize ws;
		if (ioctl(el->el_infd, TIOCGWINSZ, (ioctl_t) & ws) != -1) {
			if (ws.ws_col)
				*cols = ws.ws_col;
			if (ws.ws_row)
				*lins = ws.ws_row;
		}
	}
#endif
#ifdef TIOCGSIZE
	{
		struct ttysize ts;
		if (ioctl(el->el_infd, TIOCGSIZE, (ioctl_t) & ts) != -1) {
			if (ts.ts_cols)
				*cols = ts.ts_cols;
			if (ts.ts_lines)
				*lins = ts.ts_lines;
		}
	}
#endif
	return (Val(T_co) != *cols || Val(T_li) != *lins);
}


/* term_change_size():
 *	Change the size of the terminal
 */
protected int
term_change_size(EditLine *el, int lins, int cols)
{
	/*
         * Just in case
         */
	Val(T_co) = (cols < 2) ? 80 : cols;
	Val(T_li) = (lins < 1) ? 24 : lins;

	/* re-make display buffers */
	if (term_rebuffer_display(el) == -1)
		return (-1);
	re_clear_display(el);
	return (0);
}


/* term_init_arrow():
 *	Initialize the arrow key bindings from termcap
 */
private void
term_init_arrow(EditLine *el)
{
	fkey_t *arrow = el->el_term.t_fkey;

	arrow[A_K_DN].name = STR("down");
	arrow[A_K_DN].key = T_kd;
	arrow[A_K_DN].fun.cmd = ED_NEXT_HISTORY;
	arrow[A_K_DN].type = XK_CMD;

	arrow[A_K_UP].name = STR("up");
	arrow[A_K_UP].key = T_ku;
	arrow[A_K_UP].fun.cmd = ED_PREV_HISTORY;
	arrow[A_K_UP].type = XK_CMD;

	arrow[A_K_LT].name = STR("left");
	arrow[A_K_LT].key = T_kl;
	arrow[A_K_LT].fun.cmd = ED_PREV_CHAR;
	arrow[A_K_LT].type = XK_CMD;

	arrow[A_K_RT].name = STR("right");
	arrow[A_K_RT].key = T_kr;
	arrow[A_K_RT].fun.cmd = ED_NEXT_CHAR;
	arrow[A_K_RT].type = XK_CMD;

	arrow[A_K_HO].name = STR("home");
	arrow[A_K_HO].key = T_kh;
	arrow[A_K_HO].fun.cmd = ED_MOVE_TO_BEG;
	arrow[A_K_HO].type = XK_CMD;

	arrow[A_K_EN].name = STR("end");
	arrow[A_K_EN].key = T_at7;
	arrow[A_K_EN].fun.cmd = ED_MOVE_TO_END;
	arrow[A_K_EN].type = XK_CMD;
}


/* term_reset_arrow():
 *	Reset arrow key bindings
 */
private void
term_reset_arrow(EditLine *el)
{
	fkey_t *arrow = el->el_term.t_fkey;
	static const Char strA[] = {033, '[', 'A', '\0'};
	static const Char strB[] = {033, '[', 'B', '\0'};
	static const Char strC[] = {033, '[', 'C', '\0'};
	static const Char strD[] = {033, '[', 'D', '\0'};
	static const Char strH[] = {033, '[', 'H', '\0'};
	static const Char strF[] = {033, '[', 'F', '\0'};
	static const Char stOA[] = {033, 'O', 'A', '\0'};
	static const Char stOB[] = {033, 'O', 'B', '\0'};
	static const Char stOC[] = {033, 'O', 'C', '\0'};
	static const Char stOD[] = {033, 'O', 'D', '\0'};
	static const Char stOH[] = {033, 'O', 'H', '\0'};
	static const Char stOF[] = {033, 'O', 'F', '\0'};

	key_add(el, strA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	key_add(el, strB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	key_add(el, strC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	key_add(el, strD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
	key_add(el, strH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
	key_add(el, strF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);
	key_add(el, stOA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	key_add(el, stOB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	key_add(el, stOC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	key_add(el, stOD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
	key_add(el, stOH, &arrow[A_K_HO].fun, arrow[A_K_HO].type);
	key_add(el, stOF, &arrow[A_K_EN].fun, arrow[A_K_EN].type);

	if (el->el_map.type == MAP_VI) {
		key_add(el, &strA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
		key_add(el, &strB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
		key_add(el, &strC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
		key_add(el, &strD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
		key_add(el, &strH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
		key_add(el, &strF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
		key_add(el, &stOA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
		key_add(el, &stOB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
		key_add(el, &stOC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
		key_add(el, &stOD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
		key_add(el, &stOH[1], &arrow[A_K_HO].fun, arrow[A_K_HO].type);
		key_add(el, &stOF[1], &arrow[A_K_EN].fun, arrow[A_K_EN].type);
	}
}


/* term_set_arrow():
 *	Set an arrow key binding
 */
protected int
term_set_arrow(EditLine *el, const Char *name, key_value_t *fun, int type)
{
	fkey_t *arrow = el->el_term.t_fkey;
	int i;

	for (i = 0; i < A_K_NKEYS; i++)
		if (Strcmp(name, arrow[i].name) == 0) {
			arrow[i].fun = *fun;
			arrow[i].type = type;
			return (0);
		}
	return (-1);
}


/* term_clear_arrow():
 *	Clear an arrow key binding
 */
protected int
term_clear_arrow(EditLine *el, const Char *name)
{
	fkey_t *arrow = el->el_term.t_fkey;
	int i;

	for (i = 0; i < A_K_NKEYS; i++)
		if (Strcmp(name, arrow[i].name) == 0) {
			arrow[i].type = XK_NOD;
			return (0);
		}
	return (-1);
}


/* term_print_arrow():
 *	Print the arrow key bindings
 */
protected void
term_print_arrow(EditLine *el, const Char *name)
{
	int i;
	fkey_t *arrow = el->el_term.t_fkey;

	for (i = 0; i < A_K_NKEYS; i++)
		if (*name == '\0' || Strcmp(name, arrow[i].name) == 0)
			if (arrow[i].type != XK_NOD)
				key_kprint(el, arrow[i].name, &arrow[i].fun,
				    arrow[i].type);
}


/* term_bind_arrow():
 *	Bind the arrow keys
 */
protected void
term_bind_arrow(EditLine *el)
{
	el_action_t *map;
	const el_action_t *dmap;
	int i, j;
	char *p;
	fkey_t *arrow = el->el_term.t_fkey;

	/* Check if the components needed are initialized */
	if (el->el_term.t_buf == NULL || el->el_map.key == NULL)
		return;

	map = el->el_map.type == MAP_VI ? el->el_map.alt : el->el_map.key;
	dmap = el->el_map.type == MAP_VI ? el->el_map.vic : el->el_map.emacs;

	term_reset_arrow(el);

	for (i = 0; i < A_K_NKEYS; i++) {
		Char wt_str[VISUAL_WIDTH_MAX];
		Char *px;
		size_t n;

		p = el->el_term.t_str[arrow[i].key];
		if (!p || !*p)
			continue;
		for (n = 0; n < VISUAL_WIDTH_MAX && p[n]; ++n)
			wt_str[n] = p[n];
		while (n < VISUAL_WIDTH_MAX)
			wt_str[n++] = '\0';
		px = wt_str;
		j = (unsigned char) *p;
		/*
		 * Assign the arrow keys only if:
		 *
		 * 1. They are multi-character arrow keys and the user
		 *    has not re-assigned the leading character, or
		 *    has re-assigned the leading character to be
		 *	  ED_SEQUENCE_LEAD_IN
		 * 2. They are single arrow keys pointing to an
		 *    unassigned key.
		 */
		if (arrow[i].type == XK_NOD)
			key_clear(el, map, px);
		else {
			if (p[1] && (dmap[j] == map[j] ||
				map[j] == ED_SEQUENCE_LEAD_IN)) {
				key_add(el, px, &arrow[i].fun,
				    arrow[i].type);
				map[j] = ED_SEQUENCE_LEAD_IN;
			} else if (map[j] == ED_UNASSIGNED) {
				key_clear(el, map, px);
				if (arrow[i].type == XK_CMD)
					map[j] = arrow[i].fun.cmd;
				else
					key_add(el, px, &arrow[i].fun,
					    arrow[i].type);
			}
		}
	}
}

/* term_putc():
 *	Add a character
 */
private int
term_putc(int c)
{
	if (term_outfile == NULL)
		return -1;
	return fputc(c, term_outfile);
}

private void
term_tputs(EditLine *el, const char *cap, int affcnt)
{
#ifdef _REENTRANT
	pthread_mutex_lock(&term_mutex);
#endif
	term_outfile = el->el_outfile;
	(void)tputs(cap, affcnt, term_putc);
#ifdef _REENTRANT
	pthread_mutex_unlock(&term_mutex);
#endif
}

/* term__putc():
 *	Add a character
 */
protected int
term__putc(EditLine *el, Int c)
{
	char buf[MB_LEN_MAX +1];
	ssize_t i;
	if (c == MB_FILL_CHAR)
		return 0;
	i = ct_encode_char(buf, MB_LEN_MAX, c);
	if (i <= 0)
		return (int)i;
	buf[i] = '\0';
	return fputs(buf, el->el_outfile);
}

/* term__flush():
 *	Flush output
 */
protected void
term__flush(EditLine *el)
{

	(void) fflush(el->el_outfile);
}

/* term_writec():
 *	Write the given character out, in a human readable form
 */
protected void
term_writec(EditLine *el, Int c)
{
	Char visbuf[VISUAL_WIDTH_MAX +1];
	ssize_t vcnt = ct_visual_char(visbuf, VISUAL_WIDTH_MAX, c);
	visbuf[vcnt] = '\0';
	term_overwrite(el, visbuf, (size_t)vcnt);
	term__flush(el);
}


/* term_telltc():
 *	Print the current termcap characteristics
 */
protected int
/*ARGSUSED*/
term_telltc(EditLine *el, int argc __attribute__((__unused__)), 
    const Char **argv __attribute__((__unused__)))
{
	const struct termcapstr *t;
	char **ts;

	(void) fprintf(el->el_outfile, "\n\tYour terminal has the\n");
	(void) fprintf(el->el_outfile, "\tfollowing characteristics:\n\n");
	(void) fprintf(el->el_outfile, "\tIt has %d columns and %d lines\n",
	    Val(T_co), Val(T_li));
	(void) fprintf(el->el_outfile,
	    "\tIt has %s meta key\n", EL_HAS_META ? "a" : "no");
	(void) fprintf(el->el_outfile,
	    "\tIt can%suse tabs\n", EL_CAN_TAB ? " " : "not ");
	(void) fprintf(el->el_outfile, "\tIt %s automatic margins\n",
	    EL_HAS_AUTO_MARGINS ? "has" : "does not have");
	if (EL_HAS_AUTO_MARGINS)
		(void) fprintf(el->el_outfile, "\tIt %s magic margins\n",
		    EL_HAS_MAGIC_MARGINS ? "has" : "does not have");

	for (t = tstr, ts = el->el_term.t_str; t->name != NULL; t++, ts++) {
		const char *ub;
		if (*ts && **ts) {
			ub = ct_encode_string(ct_visual_string(
			    ct_decode_string(*ts, &el->el_scratch)),
			    &el->el_scratch);
		} else {
			ub = "(empty)";
		}
		(void) fprintf(el->el_outfile, "\t%25s (%s) == %s\n",
		    t->long_name, t->name, ub);
	}
	(void) fputc('\n', el->el_outfile);
	return (0);
}


/* term_settc():
 *	Change the current terminal characteristics
 */
protected int
/*ARGSUSED*/
term_settc(EditLine *el, int argc __attribute__((__unused__)),
    const Char **argv)
{
	const struct termcapstr *ts;
	const struct termcapval *tv;
	char what[8], how[8];

	if (argv == NULL || argv[1] == NULL || argv[2] == NULL)
		return -1;

	strncpy(what, ct_encode_string(argv[1], &el->el_scratch), sizeof(what));
	what[sizeof(what) - 1] = '\0';
	strncpy(how,  ct_encode_string(argv[2], &el->el_scratch), sizeof(how));
	how[sizeof(how) - 1] = '\0';

	/*
         * Do the strings first
         */
	for (ts = tstr; ts->name != NULL; ts++)
		if (strcmp(ts->name, what) == 0)
			break;

	if (ts->name != NULL) {
		term_alloc(el, ts, how);
		term_setflags(el);
		return 0;
	}
	/*
         * Do the numeric ones second
         */
	for (tv = tval; tv->name != NULL; tv++)
		if (strcmp(tv->name, what) == 0)
			break;

	if (tv->name != NULL)
		return -1;

	if (tv == &tval[T_pt] || tv == &tval[T_km] ||
	    tv == &tval[T_am] || tv == &tval[T_xn]) {
		if (strcmp(how, "yes") == 0)
			el->el_term.t_val[tv - tval] = 1;
		else if (strcmp(how, "no") == 0)
			el->el_term.t_val[tv - tval] = 0;
		else {
			(void) fprintf(el->el_errfile,
			    "" FSTR ": Bad value `%s'.\n", argv[0], how);
			return -1;
		}
		term_setflags(el);
		if (term_change_size(el, Val(T_li), Val(T_co)) == -1)
			return -1;
		return 0;
	} else {
		long i;
		char *ep;

		i = strtol(how, &ep, 10);
		if (*ep != '\0') {
			(void) fprintf(el->el_errfile,
			    "" FSTR ": Bad value `%s'.\n", argv[0], how);
			return -1;
		}
		el->el_term.t_val[tv - tval] = (int) i;
		el->el_term.t_size.v = Val(T_co);
		el->el_term.t_size.h = Val(T_li);
		if (tv == &tval[T_co] || tv == &tval[T_li])
			if (term_change_size(el, Val(T_li), Val(T_co))
			    == -1)
				return -1;
		return 0;
	}
}


/* term_gettc():
 *	Get the current terminal characteristics
 */
protected int
/*ARGSUSED*/
term_gettc(EditLine *el, int argc __attribute__((__unused__)), char **argv)
{
	const struct termcapstr *ts;
	const struct termcapval *tv;
	char *what;
	void *how;

	if (argv == NULL || argv[1] == NULL || argv[2] == NULL)
		return (-1);

	what = argv[1];
	how = argv[2];

	/*
         * Do the strings first
         */
	for (ts = tstr; ts->name != NULL; ts++)
		if (strcmp(ts->name, what) == 0)
			break;

	if (ts->name != NULL) {
		*(char **)how = el->el_term.t_str[ts - tstr];
		return 0;
	}
	/*
         * Do the numeric ones second
         */
	for (tv = tval; tv->name != NULL; tv++)
		if (strcmp(tv->name, what) == 0)
			break;

	if (tv->name == NULL)
		return -1;

	if (tv == &tval[T_pt] || tv == &tval[T_km] ||
	    tv == &tval[T_am] || tv == &tval[T_xn]) {
		static char yes[] = "yes";
		static char no[] = "no";
		if (el->el_term.t_val[tv - tval])
			*(char **)how = yes;
		else
			*(char **)how = no;
		return 0;
	} else {
		*(int *)how = el->el_term.t_val[tv - tval];
		return 0;
	}
}

/* term_echotc():
 *	Print the termcap string out with variable substitution
 */
protected int
/*ARGSUSED*/
term_echotc(EditLine *el, int argc __attribute__((__unused__)),
    const Char **argv)
{
	char *cap, *scap;
	Char *ep;
	int arg_need, arg_cols, arg_rows;
	int verbose = 0, silent = 0;
	char *area;
	static const char fmts[] = "%s\n", fmtd[] = "%d\n";
	const struct termcapstr *t;
	char buf[TC_BUFSIZE];
	long i;

	area = buf;

	if (argv == NULL || argv[1] == NULL)
		return (-1);
	argv++;

	if (argv[0][0] == '-') {
		switch (argv[0][1]) {
		case 'v':
			verbose = 1;
			break;
		case 's':
			silent = 1;
			break;
		default:
			/* stderror(ERR_NAME | ERR_TCUSAGE); */
			break;
		}
		argv++;
	}
	if (!*argv || *argv[0] == '\0')
		return (0);
	if (Strcmp(*argv, STR("tabs")) == 0) {
		(void) fprintf(el->el_outfile, fmts, EL_CAN_TAB ? "yes" : "no");
		return (0);
	} else if (Strcmp(*argv, STR("meta")) == 0) {
		(void) fprintf(el->el_outfile, fmts, Val(T_km) ? "yes" : "no");
		return (0);
	} else if (Strcmp(*argv, STR("xn")) == 0) {
		(void) fprintf(el->el_outfile, fmts, EL_HAS_MAGIC_MARGINS ?
		    "yes" : "no");
		return (0);
	} else if (Strcmp(*argv, STR("am")) == 0) {
		(void) fprintf(el->el_outfile, fmts, EL_HAS_AUTO_MARGINS ?
		    "yes" : "no");
		return (0);
	} else if (Strcmp(*argv, STR("baud")) == 0) {
#ifdef notdef
		int i;

		for (i = 0; baud_rate[i].b_name != NULL; i++)
			if (el->el_tty.t_speed == baud_rate[i].b_rate) {
				(void) fprintf(el->el_outfile, fmts,
				    baud_rate[i].b_name);
				return (0);
			}
		(void) fprintf(el->el_outfile, fmtd, 0);
#else
		(void) fprintf(el->el_outfile, fmtd, (int)el->el_tty.t_speed);
#endif
		return (0);
	} else if (Strcmp(*argv, STR("rows")) == 0 ||
                   Strcmp(*argv, STR("lines")) == 0) {
		(void) fprintf(el->el_outfile, fmtd, Val(T_li));
		return (0);
	} else if (Strcmp(*argv, STR("cols")) == 0) {
		(void) fprintf(el->el_outfile, fmtd, Val(T_co));
		return (0);
	}
	/*
         * Try to use our local definition first
         */
	scap = NULL;
	for (t = tstr; t->name != NULL; t++)
		if (strcmp(t->name,
		    ct_encode_string(*argv, &el->el_scratch)) == 0) {
			scap = el->el_term.t_str[t - tstr];
			break;
		}
	if (t->name == NULL) {
		/* XXX: some systems' tgetstr needs non const */
                scap = tgetstr(ct_encode_string(*argv, &el->el_scratch), &area);
	}
	if (!scap || scap[0] == '\0') {
		if (!silent)
			(void) fprintf(el->el_errfile,
			    "echotc: Termcap parameter `" FSTR "' not found.\n",
			    *argv);
		return (-1);
	}
	/*
         * Count home many values we need for this capability.
         */
	for (cap = scap, arg_need = 0; *cap; cap++)
		if (*cap == '%')
			switch (*++cap) {
			case 'd':
			case '2':
			case '3':
			case '.':
			case '+':
				arg_need++;
				break;
			case '%':
			case '>':
			case 'i':
			case 'r':
			case 'n':
			case 'B':
			case 'D':
				break;
			default:
				/*
				 * hpux has lot's of them...
				 */
				if (verbose)
					(void) fprintf(el->el_errfile,
				"echotc: Warning: unknown termcap %% `%c'.\n",
					    *cap);
				/* This is bad, but I won't complain */
				break;
			}

	switch (arg_need) {
	case 0:
		argv++;
		if (*argv && *argv[0]) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Extra argument `" FSTR "'.\n",
				    *argv);
			return (-1);
		}
		term_tputs(el, scap, 1);
		break;
	case 1:
		argv++;
		if (!*argv || *argv[0] == '\0') {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Missing argument.\n");
			return (-1);
		}
		arg_cols = 0;
		i = Strtol(*argv, &ep, 10);
		if (*ep != '\0' || i < 0) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Bad value `" FSTR "' for rows.\n",
				    *argv);
			return (-1);
		}
		arg_rows = (int) i;
		argv++;
		if (*argv && *argv[0]) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Extra argument `" FSTR "'.\n",
				    *argv);
			return (-1);
		}
		term_tputs(el, tgoto(scap, arg_cols, arg_rows), 1);
		break;
	default:
		/* This is wrong, but I will ignore it... */
		if (verbose)
			(void) fprintf(el->el_errfile,
			 "echotc: Warning: Too many required arguments (%d).\n",
			    arg_need);
		/* FALLTHROUGH */
	case 2:
		argv++;
		if (!*argv || *argv[0] == '\0') {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Missing argument.\n");
			return (-1);
		}
		i = Strtol(*argv, &ep, 10);
		if (*ep != '\0' || i < 0) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Bad value `" FSTR "' for cols.\n",
				    *argv);
			return (-1);
		}
		arg_cols = (int) i;
		argv++;
		if (!*argv || *argv[0] == '\0') {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Missing argument.\n");
			return (-1);
		}
		i = Strtol(*argv, &ep, 10);
		if (*ep != '\0' || i < 0) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Bad value `" FSTR "' for rows.\n",
				    *argv);
			return (-1);
		}
		arg_rows = (int) i;
		if (*ep != '\0') {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Bad value `" FSTR "'.\n", *argv);
			return (-1);
		}
		argv++;
		if (*argv && *argv[0]) {
			if (!silent)
				(void) fprintf(el->el_errfile,
				    "echotc: Warning: Extra argument `" FSTR "'.\n",
				    *argv);
			return (-1);
		}
		term_tputs(el, tgoto(scap, arg_cols, arg_rows), arg_rows);
		break;
	}
	return (0);
}
@


1.17
log
@Remove non-exposed malloc/realloc/free wrappers, and then substitute
reallocarray() where it helps.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.16 2014/01/19 11:48:54 tobias Exp $	*/
@


1.16
log
@Retain local changes from rev 1.13.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.15 2011/07/07 05:40:42 okan Exp $	*/
d334 1
a334 1
	el->el_term.t_buf = (char *) el_malloc(TC_BUFSIZE);
d337 1
a337 1
	el->el_term.t_cap = (char *) el_malloc(TC_BUFSIZE);
d340 1
a340 1
	el->el_term.t_fkey = (fkey_t *) el_malloc(A_K_NKEYS * sizeof(fkey_t));
d344 1
a344 1
	el->el_term.t_str = (char **) el_malloc(T_str * sizeof(char *));
d348 1
a348 1
	el->el_term.t_val = (int *) el_malloc(T_val * sizeof(int));
d356 1
a356 1
	el_free(el->el_term.t_str);
d359 1
a359 1
	el_free(el->el_term.t_fkey);
d362 1
a362 1
	el_free(el->el_term.t_cap);
d365 1
a365 1
	el_free(el->el_term.t_buf);
d378 1
a378 1
	el_free((ptr_t) el->el_term.t_buf);
d380 1
a380 1
	el_free((ptr_t) el->el_term.t_cap);
d383 1
a383 1
	el_free((ptr_t) el->el_term.t_str);
d385 1
a385 1
	el_free((ptr_t) el->el_term.t_val);
d387 1
a387 1
	el_free((ptr_t) el->el_term.t_fkey);
d486 1
a486 1
	b =  el_malloc(sizeof(*b) * (c->v + 1));
d490 1
a490 1
		b[i] = el_malloc(sizeof(**b) * (c->h + 1));
d493 2
a494 2
				el_free((ptr_t) b[i]);
			el_free((ptr_t) b);
d501 1
a501 1
	b = el_malloc(sizeof(*b) * (c->v + 1));
d505 1
a505 1
		b[i] = el_malloc(sizeof(**b) * (c->h + 1));
d508 2
a509 2
				el_free((ptr_t) b[i]);
			el_free((ptr_t) b);
d537 2
a538 2
			el_free((ptr_t) *bufp);
		el_free((ptr_t) b);
d544 2
a545 2
			el_free((ptr_t) *bufp);
		el_free((ptr_t) b);
@


1.15
log
@sync with upstream, retaining local modifications.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.14 2010/06/30 00:05:35 nicm Exp $	*/
d336 1
a336 1
		return (-1);
d339 1
a339 1
		return (-1);
d342 1
a342 1
		return (-1);
d346 1
a346 1
		return (-1);
d350 1
a350 1
		return (-1);
d355 14
d482 1
a482 1
	int i;
d488 1
a488 1
		return (-1);
d495 1
a495 1
			return (-1);
d503 1
a503 1
		return (-1);
d510 1
a510 1
			return (-1);
d515 6
a520 1
	return (0);
@


1.14
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d336 1
a336 1
		goto fail;
d339 1
a339 1
		goto fail2;
d342 1
a342 1
		goto fail3;
d346 1
a346 1
		goto fail4;
d350 1
a350 1
		goto fail5;
a354 14
fail5:
	el_free(el->el_term.t_str);
	el->el_term.t_str = NULL;
fail4:
	el_free(el->el_term.t_fkey);
	el->el_term.t_fkey = NULL;
fail3:
	el_free(el->el_term.t_cap);
	el->el_term.t_cap = NULL;
fail2:
	el_free(el->el_term.t_buf);
	el->el_term.t_buf = NULL;
fail:
	return (-1);
@


1.13
log
@Fix two memory leaks, one found by parfait, one by myself.

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: term.c,v 1.12 2009/10/27 23:59:28 deraadt Exp $	*/
/*	$NetBSD: term.c,v 1.38 2003/09/14 21:48:55 christos Exp $	*/
d48 1
d54 1
a54 2
#endif
#ifdef HAVE_NCURSES_H
d58 2
a59 1
#if (defined(HAVE_TERM_H) && !defined(SUNOS))
d65 4
d73 1
a73 1
 * and the current possition assuming that it is correct.  If this is not
d273 2
d276 4
a279 2

private FILE *term_outfile = NULL;	/* XXX: How do we fix that? */
a326 1

a351 1
	term_outfile = el->el_outfile;
d387 2
d400 1
a400 1
	int tlen, clen;
d416 2
a417 1
		(void) strlcpy(*str, cap, tlen + 1);
d427 1
a427 1
		el->el_term.t_loc += clen + 1;	/* one for \0 */
d444 1
a444 1
	el->el_term.t_loc = tlen;
d452 1
a452 1
	el->el_term.t_loc += clen + 1;	/* one for \0 */
d482 2
a483 2
	int i, rv = -1;
	char **b;
d486 1
a486 1
	b = (char **) el_malloc((size_t) (sizeof(char *) * (c->v + 1)));
d488 1
a488 2
		goto done;
	b[0] = NULL;
d490 7
a496 4
		b[i] = (char *) el_malloc((size_t) (sizeof(char) * (c->h + 1)));
		if (b[i] == NULL)
			goto done;
		b[i + 1] = NULL;
d498 1
d501 1
a501 1
	b = (char **) el_malloc((size_t) (sizeof(char *) * (c->v + 1)));
d503 1
a503 2
		goto done;
	b[0] = NULL;
d505 7
a511 4
		b[i] = (char *) el_malloc((size_t) (sizeof(char) * (c->h + 1)));
		if (b[i] == NULL)
			goto done;
		b[i + 1] = NULL;
d513 1
d515 1
a515 6

	rv = 0;
done:
	if (rv)
		term_free_display(el);
	return (rv);
d525 2
a526 2
	char **b;
	char **bufp;
d532 1
a532 1
			el_free((ptr_t) * bufp);
d539 1
a539 1
			el_free((ptr_t) * bufp);
d568 8
d577 5
a581 4
				term_move_to_char(el, el->el_term.t_size.h - 1);
				term_overwrite(el,
				    &el->el_display[el->el_cursor.v][el->el_cursor.h],
				    1);
d586 2
a587 2
					(void) tputs(tgoto(Str(T_DO), del, del),
					    del, term__putc);
d591 1
a591 1
						term__putc('\n');
d599 1
a599 2
			(void) tputs(tgoto(Str(T_UP), -del, -del), -del,
			    term__putc);
d603 1
a603 1
					(void) tputs(Str(T_up), 1, term__putc);
d630 1
a630 1
		term__putc('\r');	/* do a CR */
d638 1
a638 1
		(void) tputs(tgoto(Str(T_ch), where, where), where, term__putc);
d642 1
a642 2
				(void) tputs(tgoto(Str(T_RI), del, del),
				    del, term__putc);
d647 7
a653 1
					    (where & 0370)) {
d657 1
a657 1
						    i < (where & 0370);
d659 1
a659 1
							term__putc('\t');	
d661 1
a661 1
						el->el_cursor.h = where & 0370;
d672 3
a674 3
				term_overwrite(el,
				    &el->el_display[el->el_cursor.v][el->el_cursor.h],
				    where - el->el_cursor.h);
d679 2
a680 2
				(void) tputs(tgoto(Str(T_LE), -del, -del),
				    -del, term__putc);
d691 1
a691 1
					term__putc('\r');	/* do a CR */
d696 1
a696 1
					term__putc('\b');
d706 1
d709 1
a709 1
term_overwrite(EditLine *el, const char *cp, int n)
d711 2
a712 2
	if (n <= 0)
		return;		/* catch bugs */
d714 1
a714 1
	if (n > el->el_term.t_size.h) {
d721 6
a726 4
	do {
		term__putc(*cp++);
		el->el_cursor.h++;
	} while (--n);
d735 3
a737 3
				char c;
				if ((c = el->el_display[el->el_cursor.v][el->el_cursor.h])
				    != '\0')
d739 9
a747 3
				else
					term__putc(' ');
				el->el_cursor.h = 1;
d750 1
a750 1
			el->el_cursor.h = el->el_term.t_size.h;
d780 1
a780 2
			(void) tputs(tgoto(Str(T_DC), num, num),
			    num, term__putc);
d784 1
a784 1
		(void) tputs(Str(T_dm), 1, term__putc);
d788 1
a788 1
			(void) tputs(Str(T_dc), 1, term__putc);
d791 1
a791 1
		(void) tputs(Str(T_ed), 1, term__putc);
d798 1
d801 1
a801 1
term_insertwrite(EditLine *el, char *cp, int num)
d821 2
a822 3
			(void) tputs(tgoto(Str(T_IC), num, num),
			    num, term__putc);
			term_overwrite(el, cp, num);
d827 1
a827 1
		(void) tputs(Str(T_im), 1, term__putc);
d831 1
a831 1
			term__putc(*cp++);
d835 1
a835 1
			(void) tputs(Str(T_ip), 1, term__putc);
d837 1
a837 1
		(void) tputs(Str(T_ei), 1, term__putc);
d842 1
a842 2
			(void) tputs(Str(T_ic), 1, term__putc);
					/* insert a char */
d844 1
a844 1
		term__putc(*cp++);
d849 1
a849 1
			(void) tputs(Str(T_ip), 1, term__putc);
d865 1
a865 1
		(void) tputs(Str(T_ce), 1, term__putc);
d868 1
a868 1
			term__putc(' ');
d883 1
a883 1
		(void) tputs(Str(T_cl), Val(T_li), term__putc);
d885 1
a885 1
		(void) tputs(Str(T_ho), Val(T_li), term__putc);	/* home */
d887 1
a887 1
		(void) tputs(Str(T_cd), Val(T_li), term__putc);
d889 2
a890 2
		term__putc('\r');
		term__putc('\n');
d903 1
a903 1
		(void) tputs(Str(T_bl), 1, term__putc);
d905 1
a905 1
		term__putc('\007');	/* an ASCII bell; ^G */
d917 1
a917 1
		(void) tputs(Str(T_cd), Val(T_li), term__putc);
d919 1
a919 1
		(void) tputs(Str(T_ce), Val(T_li), term__putc);
d990 5
a994 2
		for (t = tstr; t->name != NULL; t++)
			term_alloc(el, t, tgetstr((char *)t->name, &area));
d1083 1
a1083 1
	arrow[A_K_DN].name = "down";
d1088 1
a1088 1
	arrow[A_K_UP].name = "up";
d1093 1
a1093 1
	arrow[A_K_LT].name = "left";
d1098 1
a1098 1
	arrow[A_K_RT].name = "right";
d1103 1
a1103 1
	arrow[A_K_HO].name = "home";
d1108 1
a1108 1
	arrow[A_K_EN].name = "end";
d1122 12
a1133 12
	static const char strA[] = {033, '[', 'A', '\0'};
	static const char strB[] = {033, '[', 'B', '\0'};
	static const char strC[] = {033, '[', 'C', '\0'};
	static const char strD[] = {033, '[', 'D', '\0'};
	static const char strH[] = {033, '[', 'H', '\0'};
	static const char strF[] = {033, '[', 'F', '\0'};
	static const char stOA[] = {033, 'O', 'A', '\0'};
	static const char stOB[] = {033, 'O', 'B', '\0'};
	static const char stOC[] = {033, 'O', 'C', '\0'};
	static const char stOD[] = {033, 'O', 'D', '\0'};
	static const char stOH[] = {033, 'O', 'H', '\0'};
	static const char stOF[] = {033, 'O', 'F', '\0'};
d1169 1
a1169 1
term_set_arrow(EditLine *el, const char *name, key_value_t *fun, int type)
d1175 1
a1175 1
		if (strcmp(name, arrow[i].name) == 0) {
d1188 1
a1188 1
term_clear_arrow(EditLine *el, const char *name)
d1194 1
a1194 1
		if (strcmp(name, arrow[i].name) == 0) {
d1206 1
a1206 1
term_print_arrow(EditLine *el, const char *name)
d1212 1
a1212 1
		if (*name == '\0' || strcmp(name, arrow[i].name) == 0)
d1241 4
d1246 32
a1277 18
		if (p && *p) {
			j = (unsigned char) *p;
			/*
		         * Assign the arrow keys only if:
		         *
		         * 1. They are multi-character arrow keys and the user
		         *    has not re-assigned the leading character, or
		         *    has re-assigned the leading character to be
		         *	  ED_SEQUENCE_LEAD_IN
		         * 2. They are single arrow keys pointing to an
			 *    unassigned key.
		         */
			if (arrow[i].type == XK_NOD)
				key_clear(el, map, p);
			else {
				if (p[1] && (dmap[j] == map[j] ||
					map[j] == ED_SEQUENCE_LEAD_IN)) {
					key_add(el, p, &arrow[i].fun,
a1278 9
					map[j] = ED_SEQUENCE_LEAD_IN;
				} else if (map[j] == ED_UNASSIGNED) {
					key_clear(el, map, p);
					if (arrow[i].type == XK_CMD)
						map[j] = arrow[i].fun.cmd;
					else
						key_add(el, p, &arrow[i].fun,
						    arrow[i].type);
				}
d1284 23
d1312 1
a1312 1
term__putc(int c)
d1314 9
a1322 2

	return (fputc(c, term_outfile));
a1324 1

d1329 1
a1329 1
term__flush(void)
d1332 14
a1345 1
	(void) fflush(term_outfile);
d1355 1
a1355 1
    const char **argv __attribute__((__unused__)))
a1358 1
	char upbuf[EL_BUFSIZ];
d1374 9
a1382 1
	for (t = tstr, ts = el->el_term.t_str; t->name != NULL; t++, ts++)
d1384 2
a1385 3
		    t->long_name,
		    t->name, *ts && **ts ?
		    key__decode_str(*ts, upbuf, "") : "(empty)");
d1397 1
a1397 1
    const char **argv)
d1401 1
a1401 1
	const char *what, *how;
d1404 1
a1404 1
		return (-1);
d1406 4
a1409 2
	what = argv[1];
	how = argv[2];
d1421 1
a1421 1
		return (0);
d1430 21
a1450 19
	if (tv->name != NULL) {
		if (tv == &tval[T_pt] || tv == &tval[T_km] ||
		    tv == &tval[T_am] || tv == &tval[T_xn]) {
			if (strcmp(how, "yes") == 0)
				el->el_term.t_val[tv - tval] = 1;
			else if (strcmp(how, "no") == 0)
				el->el_term.t_val[tv - tval] = 0;
			else {
				(void) fprintf(el->el_errfile,
				    "settc: Bad value `%s'.\n", how);
				return (-1);
			}
			term_setflags(el);
			if (term_change_size(el, Val(T_li), Val(T_co)) == -1)
				return (-1);
			return (0);
		} else {
			long i;
			char *ep;
d1452 5
a1456 14
			i = strtol(how, &ep, 10);
			if (*ep != '\0') {
				(void) fprintf(el->el_errfile,
				    "settc: Bad value `%s'.\n", how);
				return (-1);
			}
			el->el_term.t_val[tv - tval] = (int) i;
			el->el_term.t_size.v = Val(T_co);
			el->el_term.t_size.h = Val(T_li);
			if (tv == &tval[T_co] || tv == &tval[T_li])
				if (term_change_size(el, Val(T_li), Val(T_co))
				    == -1)
					return (-1);
			return (0);
d1458 8
a1466 1
	return (-1);
d1470 54
d1530 1
a1530 1
    const char **argv)
d1532 2
a1533 1
	char *cap, *scap, *ep;
d1564 1
a1564 1
	if (strcmp(*argv, "tabs") == 0) {
d1567 1
a1567 1
	} else if (strcmp(*argv, "meta") == 0) {
d1570 1
a1570 1
	} else if (strcmp(*argv, "xn") == 0) {
d1574 1
a1574 1
	} else if (strcmp(*argv, "am") == 0) {
d1578 1
a1578 1
	} else if (strcmp(*argv, "baud") == 0) {
d1590 1
a1590 1
		(void) fprintf(el->el_outfile, fmtd, el->el_tty.t_speed);
d1593 2
a1594 1
	} else if (strcmp(*argv, "rows") == 0 || strcmp(*argv, "lines") == 0) {
d1597 1
a1597 1
	} else if (strcmp(*argv, "cols") == 0) {
d1606 2
a1607 1
		if (strcmp(t->name, *argv) == 0) {
d1611 4
a1614 2
	if (t->name == NULL)
		scap = tgetstr((char *)*argv, &area);
d1618 1
a1618 1
			    "echotc: Termcap parameter `%s' not found.\n",
d1661 1
a1661 1
				    "echotc: Warning: Extra argument `%s'.\n",
d1665 1
a1665 1
		(void) tputs(scap, 1, term__putc);
d1676 1
a1676 1
		i = strtol(*argv, &ep, 10);
d1680 1
a1680 1
				    "echotc: Bad value `%s' for rows.\n",
d1689 1
a1689 1
				    "echotc: Warning: Extra argument `%s'.\n",
d1693 1
a1693 1
		(void) tputs(tgoto(scap, arg_cols, arg_rows), 1, term__putc);
d1710 1
a1710 1
		i = strtol(*argv, &ep, 10);
d1714 1
a1714 1
				    "echotc: Bad value `%s' for cols.\n",
d1726 1
a1726 1
		i = strtol(*argv, &ep, 10);
d1730 1
a1730 1
				    "echotc: Bad value `%s' for rows.\n",
d1738 1
a1738 1
				    "echotc: Bad value `%s'.\n", *argv);
d1745 1
a1745 1
				    "echotc: Warning: Extra argument `%s'.\n",
d1749 1
a1749 2
		(void) tputs(tgoto(scap, arg_cols, arg_rows), arg_rows,
		    term__putc);
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.11 2003/10/31 08:42:24 otto Exp $	*/
d328 1
a328 1
		return (-1);
d331 1
a331 1
		return (-1);
d334 1
a334 1
		return (-1);
d338 1
a338 1
		return (-1);
d342 1
a342 1
		return (-1);
d348 14
d472 1
a472 1
	int i;
d478 2
a479 1
		return (-1);
d483 2
a484 1
			return (-1);
a485 1
	b[c->v] = NULL;
d490 2
a491 1
		return (-1);
d495 2
a496 1
			return (-1);
a497 1
	b[c->v] = NULL;
d499 6
a504 1
	return (0);
@


1.11
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 7
#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)term.c	8.2 (Berkeley) 4/30/95";
#else
static const char rcsid[] = "$OpenBSD$";
#endif
#endif /* not lint && not SCCSID */
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: term.c,v 1.9 2003/05/01 21:11:21 avsm Exp $	*/
/*	$NetBSD: term.c,v 1.8 1997/01/23 14:02:49 mrg Exp $	*/
d36 1
d39 1
a39 1
static char sccsid[] = "@@(#)term.c	8.1 (Berkeley) 6/4/93";
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: term.c,v 1.9 2003/05/01 21:11:21 avsm Exp $";
a49 1
#include "sys.h"
d55 14
a68 1
#include "termcap.h"	/* XXX: should be <termcap.h> */
a69 1
#include <sys/types.h>
d80 1
a80 1
#define TC_BUFSIZE 2048
d82 4
a85 4
#define GoodStr(a) (el->el_term.t_str[a] != NULL && \
		    el->el_term.t_str[a][0] != '\0')
#define Str(a) el->el_term.t_str[a]
#define Val(a) el->el_term.t_val[a]
d88 3
a90 3
private struct {
    char   *b_name;
    int     b_rate;
d93 1
a93 1
    { "0", B0 },
d96 1
a96 1
    { "50", B50 },
d99 1
a99 1
    { "75", B75 },
d102 1
a102 1
    { "110", B110 },
d105 1
a105 1
    { "134", B134 },
d108 1
a108 1
    { "150", B150 },
d111 1
a111 1
    { "200", B200 },
d114 1
a114 1
    { "300", B300 },
d117 1
a117 1
    { "600", B600 },
d120 1
a120 1
    { "900", B900 },
d123 1
a123 1
    { "1200", B1200 },
d126 1
a126 1
    { "1800", B1800 },
d129 1
a129 1
    { "2400", B2400 },
d132 1
a132 1
    { "3600", B3600 },
d135 1
a135 1
    { "4800", B4800 },
d138 1
a138 1
    { "7200", B7200 },
d141 1
a141 1
    { "9600", B9600 },
d144 1
a144 1
    { "19200", EXTA },
d147 1
a147 1
    { "19200", B19200 },
d150 1
a150 1
    { "38400", EXTB },
d153 1
a153 1
    { "38400", B38400 },
d155 1
a155 1
    { NULL, 0 }
d159 3
a161 3
private struct termcapstr {
    char   *name;
    char   *long_name;
d163 12
a174 13

#define T_al	0
    {	"al",	"add new blank line"		},
#define T_bl	1
    {	"bl",	"audible bell"			},
#define T_cd	2
    {	"cd",	"clear to bottom"		},
#define T_ce	3
    {	"ce",	"clear to end of line"		},
#define T_ch	4
    {	"ch",	"cursor to horiz pos"		},
#define T_cl	5
    {	"cl",	"clear screen"			},
d176 1
a176 1
    {	"dc",	"delete a character"		},
d178 1
a178 1
    {	"dl",	"delete a line"		 	},
d180 1
a180 1
    {	"dm",	"start delete mode"		},
d182 1
a182 1
    {	"ed",	"end delete mode"		},
d184 1
a184 1
    {	"ei",	"end insert mode"		},
d186 1
a186 1
    {	"fs",	"cursor from status line"	},
d188 1
a188 1
    {	"ho",	"home cursor"			},
d190 3
a192 3
    {	"ic",	"insert character"		},
#define	T_im	14 
    {	"im",	"start insert mode"		},
d194 1
a194 1
    {	"ip",	"insert padding"		},
d196 1
a196 1
    {	"kd",	"sends cursor down"		},
d198 43
a240 39
    {	"kl",	"sends cursor left"		},
#define T_kr	18
    {	"kr",	"sends cursor right"		},
#define T_ku	19
    {	"ku",	"sends cursor up"		},
#define T_md	20
    {	"md",	"begin bold"			},
#define T_me	21
    {	"me",	"end attributes"		},
#define T_nd	22
    {	"nd",	"non destructive space"	 	},
#define T_se	23
    {	"se",	"end standout"			},
#define T_so	24
    {	"so",	"begin standout"		},
#define T_ts	25
    {	"ts",	"cursor to status line"	 	},
#define T_up	26
    {	"up",	"cursor up one"		 	},
#define T_us	27
    {	"us",	"begin underline"		},
#define T_ue	28
    {	"ue",	"end underline"		 	},
#define T_vb	29
    {	"vb",	"visible bell"			},
#define T_DC	30
    {	"DC",	"delete multiple chars"	 	},
#define T_DO	31
    {	"DO",	"cursor down multiple"		},
#define T_IC	32
    {	"IC",	"insert multiple chars"	 	},
#define T_LE	33
    {	"LE",	"cursor left multiple"		},
#define T_RI	34
    {	"RI",	"cursor right multiple"	 	},
#define T_UP	35
    {	"UP",	"cursor up multiple"		},
#define T_str	36
    {	NULL,   NULL			 	}
d243 3
a245 3
private struct termcapval {
    char   *name;
    char   *long_name;
d247 18
a264 14
#define T_pt	0
    {	"pt",	"has physical tabs"	},
#define T_li	1
    {	"li",	"Number of lines"	},
#define T_co	2
    {	"co",	"Number of columns"	},
#define T_km	3
    {	"km",	"Has meta key"		},
#define T_xt	4
    {	"xt",	"Tab chars destructive" },
#define T_MT	5
    {	"MT",	"Has meta key"		},	/* XXX? */
#define T_val	6
    {	NULL, 	NULL,			}
a265 1

d268 5
a272 4
private	void	term_rebuffer_display(EditLine *);
private	void	term_free_display(EditLine *);
private	void	term_alloc_display(EditLine *);
private	void	term_alloc(EditLine *, struct termcapstr *, char *); 
d284 1
a284 2
term_setflags(el)
    EditLine *el;
d286 21
a306 17
    EL_FLAGS = 0;
    if (el->el_tty.t_tabs) 
	EL_FLAGS |= (Val(T_pt) && !Val(T_xt)) ? TERM_CAN_TAB : 0;

    EL_FLAGS |= (Val(T_km) || Val(T_MT)) ? TERM_HAS_META : 0;
    EL_FLAGS |= GoodStr(T_ce) ? TERM_CAN_CEOL : 0;
    EL_FLAGS |= (GoodStr(T_dc) || GoodStr(T_DC)) ? TERM_CAN_DELETE : 0;
    EL_FLAGS |= (GoodStr(T_im) || GoodStr(T_ic) || GoodStr(T_IC)) ?
		 TERM_CAN_INSERT : 0;
    EL_FLAGS |= (GoodStr(T_up) || GoodStr(T_UP))  ? TERM_CAN_UP : 0;

    if (GoodStr(T_me) && GoodStr(T_ue))
	EL_FLAGS |= (strcmp(Str(T_me), Str(T_ue)) == 0) ? TERM_CAN_ME : 0;
    else
	EL_FLAGS &= ~TERM_CAN_ME;
    if (GoodStr(T_me) && GoodStr(T_se))
	EL_FLAGS |= (strcmp(Str(T_me), Str(T_se)) == 0) ? TERM_CAN_ME : 0;
d310 12
a321 10
    if (!EL_CAN_UP) {
	(void)fprintf(el->el_errfile, "WARNING: Your terminal cannot move up.\n");
	(void)fprintf(el->el_errfile, "Editing may be odd for long lines.\n");
    }
    if (!EL_CAN_CEOL)
	(void)fprintf(el->el_errfile, "no clear EOL capability.\n");
    if (!EL_CAN_DELETE)
	(void)fprintf(el->el_errfile, "no delete char capability.\n");
    if (!EL_CAN_INSERT)
	(void)fprintf(el->el_errfile, "no insert char capability.\n");
d330 1
a330 2
term_init(el)
    EditLine *el;
d332 23
a354 12
    el->el_term.t_buf = (char *)  el_malloc(TC_BUFSIZE);
    el->el_term.t_cap = (char *)  el_malloc(TC_BUFSIZE);
    el->el_term.t_fkey = (fkey_t *) el_malloc(4 * sizeof(fkey_t));
    el->el_term.t_loc = 0;
    el->el_term.t_str = (char **) el_malloc(T_str * sizeof(char*));
    (void)memset(el->el_term.t_str, 0, T_str * sizeof(char*));
    el->el_term.t_val = (int *)   el_malloc(T_val * sizeof(int));
    (void)memset(el->el_term.t_val, 0, T_val * sizeof(int));
    term_outfile = el->el_outfile;
    (void)term_set(el, NULL);
    term_init_arrow(el);
    return 0;
d361 1
a361 2
term_end(el)
    EditLine *el;
d363 11
a373 10
    el_free((ptr_t) el->el_term.t_buf);
    el->el_term.t_buf = NULL;
    el_free((ptr_t) el->el_term.t_cap);
    el->el_term.t_cap = NULL;
    el->el_term.t_loc = 0;
    el_free((ptr_t) el->el_term.t_str);
    el->el_term.t_str = NULL;
    el_free((ptr_t) el->el_term.t_val);
    el->el_term.t_val = NULL;
    term_free_display(el);
d381 52
a432 31
term_alloc(el, t, cap)
    EditLine *el;
    struct termcapstr *t;
    char   *cap;
{
    char    termbuf[TC_BUFSIZE];
    int     tlen, clen;
    char    **tlist = el->el_term.t_str;
    char    **tmp, **str = &tlist[t - tstr];

    if (cap == NULL || *cap == '\0') {
	*str = NULL;
	return;
    }
    else
	clen = strlen(cap);

    tlen  = *str == NULL ? 0 : strlen(*str);

    /*
     * New string is shorter; no need to allocate space
     */
    if (clen <= tlen) {
	(void)strlcpy(*str, cap, tlen + 1);
	return;
    }

    /*
     * New string is longer; see if we have enough space to append
     */
    if (el->el_term.t_loc + 3 < TC_BUFSIZE) {
d434 1
a434 1
	(void)strlcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap, tlen);
d437 1
a437 26
    }

    /*
     * Compact our buffer; no need to check compaction, cause we know it
     * fits...
     */
    tlen = 0;
    for (tmp = tlist; tmp < &tlist[T_str]; tmp++)
	if (*tmp != NULL && *tmp != '\0' && *tmp != *str) {
	    char   *ptr;

	    for (ptr = *tmp; *ptr != '\0'; termbuf[tlen++] = *ptr++)
		continue;
	    termbuf[tlen++] = '\0';
	}
    memcpy(el->el_term.t_buf, termbuf, TC_BUFSIZE);
    el->el_term.t_loc = tlen;
    if (el->el_term.t_loc + 3 >= TC_BUFSIZE) {
	(void)fprintf(el->el_errfile, "Out of termcap string space.\n");
	return;
    }
    tlen = TC_BUFSIZE - el->el_term.t_loc;
    (void)strlcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap, tlen);
    el->el_term.t_loc += clen + 1;		/* one for \0 */
    return;
} /* end term_alloc */
d443 2
a444 3
private void
term_rebuffer_display(el)
    EditLine *el;
d446 1
a446 1
    coord_t *c = &el->el_term.t_size;
d448 1
a448 1
    term_free_display(el);
d450 2
a451 3
    /* make this public, -1 to avoid wraps */
    c->h = Val(T_co) - 1;
    c->v = (EL_BUFSIZ * 4) / c->h + 1;
d453 4
a456 2
    term_alloc_display(el);
} /* end term_rebuffer_display */
d462 2
a463 3
private void
term_alloc_display(el)
    EditLine *el;
d465 27
a491 17
    int i;
    char  **b;
    coord_t *c = &el->el_term.t_size;

    b = (char **) el_malloc((size_t) (sizeof(char *) * (c->v + 1)));
    for (i = 0; i < c->v; i++)
	b[i] = (char *) el_malloc((size_t) (sizeof(char) * (c->h + 1)));
    b[c->v] = NULL;
    el->el_display = b;

    b = (char **) el_malloc((size_t) (sizeof(char *) * (c->v + 1)));
    for (i = 0; i < c->v; i++)
	b[i] = (char *) el_malloc((size_t) (sizeof(char) * (c->h + 1)));
    b[c->v] = NULL;
    el->el_vdisplay = b;

} /* end term_alloc_display */
d498 1
a498 2
term_free_display(el)
    EditLine *el;
d500 2
a501 2
    char  **b;
    char  **bufp;
d503 15
a517 15
    b = el->el_display;
    el->el_display = NULL;
    if (b != NULL) {
	for (bufp = b; *bufp != NULL; bufp++)
	    el_free((ptr_t) *bufp);
	el_free((ptr_t) b);
    }
    b = el->el_vdisplay;
    el->el_vdisplay = NULL;
    if (b != NULL) {
	for (bufp = b; *bufp != NULL; bufp++)
	    el_free((ptr_t) * bufp);
	el_free((ptr_t) b);
    }
} /* end term_free_display */
d525 1
a525 3
term_move_to_line(el, where)
    EditLine *el;
    int     where;		
d527 1
a527 1
    int     del, i;
d529 2
a530 2
    if (where == el->el_cursor.v)
	return;
d532 1
a532 1
    if (where > el->el_term.t_size.v) {
d534 2
a535 2
	(void)fprintf(el->el_errfile, 
		"term_move_to_line: where is ridiculous: %d\r\n", where);
d537 35
a571 10
	return;
    }

    if ((del = where - el->el_cursor.v) > 0) {
	if ((del > 1) && GoodStr(T_DO))
	    (void)tputs(tgoto(Str(T_DO), del, del), del, term__putc);
	else {
	    for (i = 0; i < del; i++)
		term__putc('\n');
	    el->el_cursor.h = 0;	/* because the \n will become \r\n */
d573 2
a574 12
    }
    else {			/* del < 0 */
	if (GoodStr(T_UP) && (-del > 1 || !GoodStr(T_up)))
	    (void)tputs(tgoto(Str(T_UP), -del, -del), -del, term__putc);
	else {
	    if (GoodStr(T_up))
		for (i = 0; i < -del; i++)
		    (void)tputs(Str(T_up), 1, term__putc);
	}
    }
    el->el_cursor.v = where;		/* now where is here */
} /* end term_move_to_line */
d581 1
a581 3
term_move_to_char(el, where)
    EditLine *el;
    int     where;
d583 1
a583 1
    int     del, i;
d586 2
a587 2
    if (where == el->el_cursor.h)
	return;
d589 1
a589 1
    if (where > (el->el_term.t_size.h + 1)) {
d591 2
a592 2
	(void)fprintf(el->el_errfile, 
		"term_move_to_char: where is ridiculous: %d\r\n", where);
d594 70
a663 55
	return;
    }

    if (!where) {		/* if where is first column */
	term__putc('\r');	/* do a CR */
	el->el_cursor.h = 0;
	return;
    }

    del = where - el->el_cursor.h;

    if ((del < -4 || del > 4) && GoodStr(T_ch))
	/* go there directly */
	(void)tputs(tgoto(Str(T_ch), where, where), where, term__putc);
    else {
	if (del > 0) {		/* moving forward */
	    if ((del > 4) && GoodStr(T_RI))
		(void)tputs(tgoto(Str(T_RI), del, del), del, term__putc);
	    else {
		if (EL_CAN_TAB) {	/* if I can do tabs, use them */
		    if ((el->el_cursor.h & 0370) != (where & 0370)) {
			/* if not within tab stop */
			for (i = (el->el_cursor.h & 0370); 
			     i < (where & 0370); i += 8)
			    term__putc('\t');	/* then tab over */
			el->el_cursor.h = where & 0370;
		    }
		}
		/* it's usually cheaper to just write the chars, so we do. */

		/* NOTE THAT term_overwrite() WILL CHANGE el->el_cursor.h!!! */
		term_overwrite(el, 
			&el->el_display[el->el_cursor.v][el->el_cursor.h], 
		        where - el->el_cursor.h);

	    }
	}
	else {			/* del < 0 := moving backward */
	    if ((-del > 4) && GoodStr(T_LE))
		(void)tputs(tgoto(Str(T_LE), -del, -del), -del, term__putc);
	    else {		/* can't go directly there */
		/* if the "cost" is greater than the "cost" from col 0 */
		if (EL_CAN_TAB ? (-del > ((where >> 3) + (where & 07)))
		    : (-del > where)) {
		    term__putc('\r');	/* do a CR */
		    el->el_cursor.h = 0;
		    goto mc_again;	/* and try again */
		}
		for (i = 0; i < -del; i++)
		    term__putc('\b');
	    }
	}
    }
    el->el_cursor.h = where;		/* now where is here */
} /* end term_move_to_char */
d670 1
a670 4
term_overwrite(el, cp, n)
    EditLine *el;
    char *cp;
    int n;
d672 2
a673 2
    if (n <= 0)
	return;			/* catch bugs */
d675 1
a675 1
    if (n > (el->el_term.t_size.h + 1)) {
d677 2
a678 1
	(void)fprintf(el->el_errfile, "term_overwrite: n is ridiculous: %d\r\n", n);
d680 26
a705 8
	return;
    }

    do {
	term__putc(*cp++);
	el->el_cursor.h++;
    } while (--n);
} /* end term_overwrite */
d712 1
a712 3
term_deletechars(el, num)
    EditLine *el;
    int     num;
d714 2
a715 2
    if (num <= 0)
	return;
d717 1
a717 1
    if (!EL_CAN_DELETE) {
d719 1
a719 1
	(void)fprintf(el->el_errfile, "   ERROR: cannot delete   \n");
d721 3
a723 4
	return;
    }

    if (num > el->el_term.t_size.h) {
d725 2
a726 2
	(void)fprintf(el->el_errfile, 
		"term_deletechars: num is ridiculous: %d\r\n", num);
d728 1
a728 7
	return;
    }

    if (GoodStr(T_DC))		/* if I have multiple delete */
	if ((num > 1) || !GoodStr(T_dc)) {	/* if dc would be more expen. */
	    (void)tputs(tgoto(Str(T_DC), num, num), num, term__putc);
	    return;
d730 9
d740 3
a742 2
    if (GoodStr(T_dm))		/* if I have delete mode */
	(void)tputs(Str(T_dm), 1, term__putc);
d744 3
a746 7
    if (GoodStr(T_dc))		/* else do one at a time */
	while (num--)
	    (void)tputs(Str(T_dc), 1, term__putc);

    if (GoodStr(T_ed))		/* if I have delete mode */
	(void)tputs(Str(T_ed), 1, term__putc);
} /* end term_deletechars */
d750 2
a751 2
 *	Puts terminal in insert character mode or inserts num 
 *	characters in the line 
d754 1
a754 4
term_insertwrite(el, cp, num)	
    EditLine *el;
    char *cp;
    int num;
d756 3
a758 3
    if (num <= 0)
	return;
    if (!EL_CAN_INSERT) {
d760 1
a760 1
	(void)fprintf(el->el_errfile, "   ERROR: cannot insert   \n");
d762 3
a764 4
	return;
    }

    if (num > el->el_term.t_size.h) {
d766 2
a767 1
	(void)fprintf(el->el_errfile, "StartInsert: num is ridiculous: %d\r\n", num);
d769 1
a769 8
	return;
    }

    if (GoodStr(T_IC))		/* if I have multiple insert */
	if ((num > 1) || !GoodStr(T_ic)) {	/* if ic would be more expen. */
	    (void)tputs(tgoto(Str(T_IC), num, num), num, term__putc);
	    term_overwrite(el, cp, num);	/* this updates el_cursor.h */
	    return;
d771 11
d783 4
a786 2
    if (GoodStr(T_im) && GoodStr(T_ei)) { /* if I have insert mode */
	(void)tputs(Str(T_im), 1, term__putc);
d788 2
a789 4
	el->el_cursor.h += num;
	do 
	    term__putc(*cp++);
	while (--num);
d791 7
a797 2
	if (GoodStr(T_ip))	/* have to make num chars insert */
	    (void)tputs(Str(T_ip), 1, term__putc);
d799 1
a799 3
	(void)tputs(Str(T_ei), 1, term__putc);
	return;
    }
d801 1
a801 3
    do {
	if (GoodStr(T_ic))	/* have to make num chars insert */
	    (void)tputs(Str(T_ic), 1, term__putc);	/* insert a char */
d803 3
a805 1
	term__putc(*cp++);
d807 2
a808 7
	el->el_cursor.h++;

	if (GoodStr(T_ip))	/* have to make num chars insert */
	    (void)tputs(Str(T_ip), 1, term__putc);/* pad the inserted char */

    } while (--num);
} /* end term_insertwrite */
d812 1
a812 1
 *	clear to end of line.  There are num characters to clear 
d815 12
a826 14
term_clear_EOL(el, num)	
    EditLine *el;
    int     num;
{
    int i;

    if (EL_CAN_CEOL && GoodStr(T_ce))
	(void)tputs(Str(T_ce), 1, term__putc);
    else {
	for (i = 0; i < num; i++)
	    term__putc(' ');
	el->el_cursor.h += num;		/* have written num spaces */
    }
} /* end term_clear_EOL */
d830 1
a830 1
 *	Clear the screen 
d833 1
a833 2
term_clear_screen(el)
    EditLine *el;
d835 13
a847 13
    if (GoodStr(T_cl))
	/* send the clear screen code */
	(void)tputs(Str(T_cl), Val(T_li), term__putc);
    else if (GoodStr(T_ho) && GoodStr(T_cd)) {
	(void)tputs(Str(T_ho), Val(T_li), term__putc);	/* home */
	/* clear to bottom of screen */
	(void)tputs(Str(T_cd), Val(T_li), term__putc);
    }
    else {
	term__putc('\r');
	term__putc('\n');
    }
} /* end term_clear_screen */
d854 1
a854 2
term_beep(el)
    EditLine *el;
d856 6
a861 8
    if (GoodStr(T_vb))
	(void)tputs(Str(T_vb), 1, term__putc);	/* visible bell */
    else if (GoodStr(T_bl))
	/* what termcap says we should use */
	(void)tputs(Str(T_bl), 1, term__putc);
    else
	term__putc('\007');	/* an ASCII bell; ^G */
} /* end term_beep */
d869 1
a869 2
term_clear_to_bottom(el)
    EditLine *el;
d871 5
a875 5
    if (GoodStr(T_cd))
	(void)tputs(Str(T_cd), Val(T_li), term__putc);
    else if (GoodStr(T_ce))
	(void)tputs(Str(T_ce), Val(T_li), term__putc);
} /* end term_clear_to_bottom */
d878 6
d889 69
a957 54
term_set(el, term)
    EditLine *el;
    char *term;
{
    int i;
    char    buf[TC_BUFSIZE];
    char   *area;
    struct termcapstr *t;
    sigset_t oset, nset;
    int     lins, cols;

    (void)sigemptyset(&nset);
    (void)sigaddset(&nset, SIGWINCH);
    (void)sigprocmask(SIG_BLOCK, &nset, &oset);

    area = buf;


    if (term == NULL)
	term = getenv("TERM");

    if (!term || !term[0])
	term = "dumb";

    memset(el->el_term.t_cap, 0, TC_BUFSIZE);

    i = tgetent(el->el_term.t_cap, term);

    if (i <= 0) {
	if (i == -1) 
	    (void)fprintf(el->el_errfile, "Cannot read termcap database;\n");
	else if (i == 0) 
	    (void)fprintf(el->el_errfile, 
			   "No entry for terminal type \"%s\";\n", term);
	(void)fprintf(el->el_errfile, "using dumb terminal settings.\n");
	Val(T_co) = 80;		/* do a dumb terminal */
	Val(T_pt) = Val(T_km) = Val(T_li) = 0;
	Val(T_xt) = Val(T_MT);
	for (t = tstr; t->name != NULL; t++)
	    term_alloc(el, t, NULL);
    }
    else {
	/* Can we tab */
	Val(T_pt) = tgetflag("pt");
	Val(T_xt) = tgetflag("xt");
	/* do we have a meta? */
	Val(T_km) = tgetflag("km");
	Val(T_MT) = tgetflag("MT");
	/* Get the size */
	Val(T_co) = tgetnum("co");
	Val(T_li) = tgetnum("li");
	for (t = tstr; t->name != NULL; t++)
	    term_alloc(el, t, tgetstr(t->name, &area));
    }
d959 9
a967 16
    if (Val(T_co) < 2)
	Val(T_co) = 80;		/* just in case */
    if (Val(T_li) < 1)
	Val(T_li) = 24;

    el->el_term.t_size.v = Val(T_co);
    el->el_term.t_size.h = Val(T_li);

    term_setflags(el);

    (void)term_get_size(el, &lins, &cols);/* get the correct window size */
    term_change_size(el, lins, cols);
    (void)sigprocmask(SIG_SETMASK, &oset, NULL);
    term_bind_arrow(el);
    return 0;
} /* end term_set */
d972 1
a972 1
 *	true if the size was changed. 
d975 1
a975 3
term_get_size(el, lins, cols)
    EditLine *el;
    int    *lins, *cols;
d978 2
a979 2
    *cols = Val(T_co);
    *lins = Val(T_li);
d982 8
a989 7
    {
	struct winsize ws;
	if (ioctl(el->el_infd, TIOCGWINSZ, (ioctl_t) &ws) != -1) {
	    if (ws.ws_col)
		*cols = ws.ws_col;
	    if (ws.ws_row)
		*lins = ws.ws_row;
a990 1
    }
d993 8
a1000 7
    {
	struct ttysize ts;
	if (ioctl(el->el_infd, TIOCGSIZE, (ioctl_t) &ts) != -1) {
	    if (ts.ts_cols)
		*cols = ts.ts_cols;
	    if (ts.ts_lines)
		*lins = ts.ts_lines;
a1001 1
    }
d1003 2
a1004 2
    return (Val(T_co) != *cols || Val(T_li) != *lins);
} /* end term_get_size */
d1010 15
a1024 14
protected void
term_change_size(el, lins, cols)
    EditLine *el;
    int     lins, cols;
{
    /*
     * Just in case
     */
    Val(T_co) = (cols < 2) ? 80 : cols;
    Val(T_li) = (lins < 1) ? 24 : lins;

    term_rebuffer_display(el);		/* re-make display buffers */
    re_clear_display(el);
} /* end term_change_size */
d1031 1
a1031 2
term_init_arrow(el)
    EditLine *el;
d1033 1
a1033 21
    fkey_t *arrow = el->el_term.t_fkey;

    arrow[A_K_DN].name    = "down";
    arrow[A_K_DN].key	  = T_kd;
    arrow[A_K_DN].fun.cmd = ED_NEXT_HISTORY;
    arrow[A_K_DN].type    = XK_CMD;

    arrow[A_K_UP].name    = "up";
    arrow[A_K_UP].key	  = T_ku;
    arrow[A_K_UP].fun.cmd = ED_PREV_HISTORY;
    arrow[A_K_UP].type    = XK_CMD;

    arrow[A_K_LT].name    = "left";
    arrow[A_K_LT].key	  = T_kl;
    arrow[A_K_LT].fun.cmd = ED_PREV_CHAR;
    arrow[A_K_LT].type    = XK_CMD;

    arrow[A_K_RT].name    = "right";
    arrow[A_K_RT].key	  = T_kr;
    arrow[A_K_RT].fun.cmd = ED_NEXT_CHAR;
    arrow[A_K_RT].type    = XK_CMD;
d1035 29
d1071 1
a1071 2
term_reset_arrow(el) 
    EditLine *el;
d1073 41
a1113 29
    fkey_t *arrow = el->el_term.t_fkey;
    static char strA[] = {033, '[', 'A', '\0'};
    static char strB[] = {033, '[', 'B', '\0'};
    static char strC[] = {033, '[', 'C', '\0'};
    static char strD[] = {033, '[', 'D', '\0'};
    static char stOA[] = {033, 'O', 'A', '\0'};
    static char stOB[] = {033, 'O', 'B', '\0'};
    static char stOC[] = {033, 'O', 'C', '\0'};
    static char stOD[] = {033, 'O', 'D', '\0'};

    key_add(el, strA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
    key_add(el, strB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
    key_add(el, strC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
    key_add(el, strD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);
    key_add(el, stOA, &arrow[A_K_UP].fun, arrow[A_K_UP].type);
    key_add(el, stOB, &arrow[A_K_DN].fun, arrow[A_K_DN].type);
    key_add(el, stOC, &arrow[A_K_RT].fun, arrow[A_K_RT].type);
    key_add(el, stOD, &arrow[A_K_LT].fun, arrow[A_K_LT].type);

    if (el->el_map.type == MAP_VI) {
	key_add(el, &strA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	key_add(el, &strB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	key_add(el, &strC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	key_add(el, &strD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
	key_add(el, &stOA[1], &arrow[A_K_UP].fun, arrow[A_K_UP].type);
	key_add(el, &stOB[1], &arrow[A_K_DN].fun, arrow[A_K_DN].type);
	key_add(el, &stOC[1], &arrow[A_K_RT].fun, arrow[A_K_RT].type);
	key_add(el, &stOD[1], &arrow[A_K_LT].fun, arrow[A_K_LT].type);
    }
d1121 12
a1132 16
term_set_arrow(el, name, fun, type)
    EditLine *el;
    char *name;
    key_value_t *fun;
    int type;
{
    fkey_t *arrow = el->el_term.t_fkey;
    int i;

    for (i = 0; i < A_K_NKEYS; i++)
	if (strcmp(name, arrow[i].name) == 0) {
	    arrow[i].fun  = *fun;
	    arrow[i].type = type;
	    return 0;
	}
    return -1;
d1140 11
a1150 13
term_clear_arrow(el, name)
    EditLine *el;
    char *name;
{
    fkey_t *arrow = el->el_term.t_fkey;
    int i;

    for (i = 0; i < A_K_NKEYS; i++)
	if (strcmp(name, arrow[i].name) == 0) {
	    arrow[i].type = XK_NOD;
	    return 0;
	}
    return -1;
d1158 10
a1167 11
term_print_arrow(el, name)
    EditLine *el;
    char *name;
{
    int i;
    fkey_t *arrow = el->el_term.t_fkey;

    for (i = 0; i < A_K_NKEYS; i++)
	if (*name == '\0' || strcmp(name, arrow[i].name) == 0)
	    if (arrow[i].type != XK_NOD)
		key_kprint(el, arrow[i].name, &arrow[i].fun, arrow[i].type);
d1175 1
a1175 2
term_bind_arrow(el)
    EditLine *el;
d1177 46
a1222 41
    el_action_t *map, *dmap;
    int     i, j;
    char   *p;
    fkey_t *arrow = el->el_term.t_fkey;

    /* Check if the components needed are initialized */
    if (el->el_term.t_buf == NULL || el->el_map.key == NULL)
	return;

    map  = el->el_map.type == MAP_VI ? el->el_map.alt : el->el_map.key;
    dmap = el->el_map.type == MAP_VI ? el->el_map.vic : el->el_map.emacs;

    term_reset_arrow(el);

    for (i = 0; i < 4; i++) {
	p = el->el_term.t_str[arrow[i].key];
	if (p && *p) {
	    j = (unsigned char) *p;
	    /*
	     * Assign the arrow keys only if:
	     *
	     * 1. They are multi-character arrow keys and the user 
	     *    has not re-assigned the leading character, or 
	     *    has re-assigned the leading character to be
	     *	  ED_SEQUENCE_LEAD_IN
	     * 2. They are single arrow keys pointing to an unassigned key.
	     */
	    if (arrow[i].type == XK_NOD)
		key_clear(el, map, p);
	    else {
		if (p[1] && (dmap[j] == map[j] || 
			     map[j] == ED_SEQUENCE_LEAD_IN)) {
		    key_add(el, p, &arrow[i].fun, arrow[i].type);
		    map[j] = ED_SEQUENCE_LEAD_IN;
		}
		else if (map[j] == ED_UNASSIGNED) {
		    key_clear(el, map, p);
		    if (arrow[i].type == XK_CMD)
			map[j] = arrow[i].fun.cmd;
		    else
			key_add(el, p, &arrow[i].fun, arrow[i].type);
a1223 1
	    }
a1224 1
    }
d1231 2
a1232 3
protected void
term__putc(c)
    int c;
d1234 3
a1236 2
    (void)fputc(c, term_outfile);
} /* end term__putc */
d1243 1
a1243 1
term__flush()
d1245 3
a1247 2
    (void)fflush(term_outfile);
} /* end term__flush */
d1255 10
a1264 12
term_telltc(el, argc, argv)
    EditLine *el;
    int argc;
    char **argv;
{
    struct termcapstr *t;
    char **ts;
    char upbuf[EL_BUFSIZ];

    (void)fprintf(el->el_outfile, "\n\tYour terminal has the\n");
    (void)fprintf(el->el_outfile, "\tfollowing characteristics:\n\n");
    (void)fprintf(el->el_outfile, "\tIt has %d columns and %d lines\n",
d1266 17
a1282 18
    (void)fprintf(el->el_outfile, 
		   "\tIt has %s meta key\n", EL_HAS_META ? "a" : "no");
    (void)fprintf(el->el_outfile, 
		   "\tIt can%suse tabs\n", EL_CAN_TAB ? " " : "not ");
#ifdef notyet
    (void)fprintf(el->el_outfile, "\tIt %s automatic margins\n", 
		   (T_Margin&MARGIN_AUTO)? "has": "does not have");
    if (T_Margin & MARGIN_AUTO)
	(void)fprintf(el->el_outfile, "\tIt %s magic margins\n", 
			(T_Margin&MARGIN_MAGIC)?"has":"does not have");
#endif

    for (t = tstr, ts = el->el_term.t_str; t->name != NULL; t++, ts++)
	(void)fprintf(el->el_outfile, "\t%25s (%s) == %s\n", t->long_name, 
		       t->name, *ts && **ts ? 
			key__decode_str(*ts, upbuf, "") : "(empty)");
    (void)fputc('\n', el->el_outfile);
    return 0;
d1291 67
a1357 52
term_settc(el, argc, argv)
    EditLine *el;
    int argc;
    char **argv;
{
    struct termcapstr *ts;
    struct termcapval *tv;
    char   *what, *how;

    if (argv == NULL || argv[1] == NULL || argv[2] == NULL)
	return -1;

    what = argv[1];
    how = argv[2];

    /*
     * Do the strings first
     */
    for (ts = tstr; ts->name != NULL; ts++)
	if (strcmp(ts->name, what) == 0)
	    break;

    if (ts->name != NULL) {
	term_alloc(el, ts, how);
	term_setflags(el);
	return 0;
    }

    /*
     * Do the numeric ones second
     */
    for (tv = tval; tv->name != NULL; tv++)
	if (strcmp(tv->name, what) == 0)
	    break;

    if (tv->name != NULL) {
	if (tv == &tval[T_pt] || tv == &tval[T_km] 
#ifdef notyet
	    || tv == &tval[T_am] || tv == &tval[T_xn]
#endif
	    ) {
	    if (strcmp(how, "yes") == 0)
		el->el_term.t_val[tv - tval] = 1;
	    else if (strcmp(how, "no") == 0)
		el->el_term.t_val[tv - tval] = 0;
	    else {
		(void)fprintf(el->el_errfile, "settc: Bad value `%s'.\n", how);
		return -1;
	    }
	    term_setflags(el);
	    term_change_size(el, Val(T_li), Val(T_co));
	    return 0;
d1359 1
a1359 10
	else {
	    el->el_term.t_val[tv - tval] = atoi(how);
	    el->el_term.t_size.v = Val(T_co);
	    el->el_term.t_size.h = Val(T_li);
	    if (tv == &tval[T_co] || tv == &tval[T_li])
		term_change_size(el, Val(T_li), Val(T_co));
	    return 0;
	}
    }
    return -1;
d1368 31
a1398 30
term_echotc(el, argc, argv)
    EditLine *el;
    int argc;
    char **argv;
{
    char   *cap, *scap;
    int     arg_need, arg_cols, arg_rows;
    int     verbose = 0, silent = 0;
    char   *area;
    static char *fmts = "%s\n", *fmtd = "%d\n";
    struct termcapstr *t;
    char    buf[TC_BUFSIZE];

    area = buf;

    if (argv == NULL || argv[1] == NULL)
	return -1;
    argv++;

    if (argv[0][0] == '-') {
	switch (argv[0][1]) {
	case 'v':
	    verbose = 1;
	    break;
	case 's':
	    silent = 1;
	    break;
	default:
	    /* stderror(ERR_NAME | ERR_TCUSAGE); */
	    break;
d1400 17
a1416 25
	argv++;
    }
    if (!*argv || *argv[0] == '\0')
	return 0;
    if (strcmp(*argv, "tabs") == 0) {
	(void)fprintf(el->el_outfile, fmts, EL_CAN_TAB ? "yes" : "no");
	return 0;
    }
    else if (strcmp(*argv, "meta") == 0) {
	(void)fprintf(el->el_outfile, fmts, Val(T_km) ? "yes" : "no");
	return 0;
    }
#ifdef notyet
    else if (strcmp(*argv, "xn") == 0) {
	(void)fprintf(el->el_outfile, fmts, T_Margin & MARGIN_MAGIC ? 
			"yes" : "no");
	return 0;
    }
    else if (strcmp(*argv, "am") == 0) {
	(void)fprintf(el->el_outfile, fmts, T_Margin & MARGIN_AUTO ? 
			"yes" : "no");
	return 0;
    }
#endif
    else if (strcmp(*argv, "baud") == 0) {
d1418 1
a1418 1
	int     i;
d1420 7
a1426 6
	for (i = 0; baud_rate[i].b_name != NULL; i++)
	    if (el->el_tty.t_speed == baud_rate[i].b_rate) {
		(void)fprintf(el->el_outfile, fmts, baud_rate[i].b_name);
		return 0;
	    }
	(void)fprintf(el->el_outfile, fmtd, 0);
d1428 1
a1428 1
	(void)fprintf(el->el_outfile, fmtd, el->el_tty.t_speed);
d1430 70
a1499 41
	return 0;
    }
    else if (strcmp(*argv, "rows") == 0 || strcmp(*argv, "lines") == 0) {
	(void)fprintf(el->el_outfile, fmtd, Val(T_li));
	return 0;
    }
    else if (strcmp(*argv, "cols") == 0) {
	(void)fprintf(el->el_outfile, fmtd, Val(T_co));
	return 0;
    }

    /* 
     * Try to use our local definition first
     */
    scap = NULL;
    for (t = tstr; t->name != NULL; t++)
	if (strcmp(t->name, *argv) == 0) {
	    scap = el->el_term.t_str[t - tstr];
	    break;
	}
    if (t->name == NULL)
	scap = tgetstr(*argv, &area);
    if (!scap || scap[0] == '\0') {
	if (!silent)
	    (void)fprintf(el->el_errfile, 
		"echotc: Termcap parameter `%s' not found.\n", *argv);
	return -1;
    }

    /*
     * Count home many values we need for this capability.
     */
    for (cap = scap, arg_need = 0; *cap; cap++)
	if (*cap == '%')
	    switch (*++cap) {
	    case 'd':
	    case '2':
	    case '3':
	    case '.':
	    case '+':
		arg_need++;
d1501 27
a1527 7
	    case '%':
	    case '>':
	    case 'i':
	    case 'r':
	    case 'n':
	    case 'B':
	    case 'D':
d1529 2
a1530 4
	    default:
		/*
		 * hpux has lot's of them...
		 */
d1532 53
a1584 3
		    (void)fprintf(el->el_errfile, 
			"echotc: Warning: unknown termcap %% `%c'.\n", *cap);
		/* This is bad, but I won't complain */
a1585 46
	    }

    switch (arg_need) {
    case 0:
	argv++;
	if (*argv && *argv[0]) {
	    if (!silent)
		(void)fprintf(el->el_errfile, 
		    "echotc: Warning: Extra argument `%s'.\n", *argv);
	    return -1;
	}
	(void)tputs(scap, 1, term__putc);
	break;
    case 1:
	argv++;
	if (!*argv || *argv[0] == '\0') {
	    if (!silent)
		(void)fprintf(el->el_errfile, 
		    "echotc: Warning: Missing argument.\n");
	    return -1;
	}
	arg_cols = 0;
	arg_rows = atoi(*argv);
	argv++;
	if (*argv && *argv[0]) {
	    if (!silent)
		(void)fprintf(el->el_errfile, 
		    "echotc: Warning: Extra argument `%s'.\n", *argv);
	    return -1;
	}
	(void)tputs(tgoto(scap, arg_cols, arg_rows), 1, term__putc);
	break;
    default:
	/* This is wrong, but I will ignore it... */
	if (verbose)
	    (void)fprintf(el->el_errfile, 
		"echotc: Warning: Too many required arguments (%d).\n", 
		arg_need);
	/*FALLTHROUGH*/
    case 2:
	argv++;
	if (!*argv || *argv[0] == '\0') {
	    if (!silent)
		(void)fprintf(el->el_errfile, 
		    "echotc: Warning: Missing argument.\n");
	    return -1;
d1587 1
a1587 20
	arg_cols = atoi(*argv);
	argv++;
	if (!*argv || *argv[0] == '\0') {
	    if (!silent)
		(void)fprintf(el->el_errfile, 
		    "echotc: Warning: Missing argument.\n");
	    return -1;
	}
	arg_rows = atoi(*argv);
	argv++;
	if (*argv && *argv[0]) {
	    if (!silent)
		(void)fprintf(el->el_errfile, 
		    "echotc: Warning: Extra argument `%s'.\n", *argv);
	    return -1;
	}
	(void)tputs(tgoto(scap, arg_cols, arg_rows), arg_rows, term__putc);
	break;
    }
    return 0;
@


1.9
log
@is -Wall clean by making rcsid const
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.8 2003/04/05 00:43:20 tdeval Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: term.c,v 1.8 2003/04/05 00:43:20 tdeval Exp $";
@


1.8
log
@strcpy/strcat -> strlcpy/strlcat
ok tedu@@, hints by deraadt@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.7 2002/11/29 20:13:39 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: term.c,v 1.7 2002/11/29 20:13:39 deraadt Exp $";
@


1.7
log
@riduculous spelling; torh@@bogus.net
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.6 2002/02/17 19:42:25 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: term.c,v 1.6 2002/02/17 19:42:25 millert Exp $";
d374 1
a374 1
	(void)strcpy(*str, cap);
d382 2
a383 1
	(void)strcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap);
d407 2
a408 1
    (void)strcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap);
@


1.6
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.5 2002/02/16 21:27:26 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: term.c,v 1.5 2002/02/16 21:27:26 millert Exp $";
d545 1
a545 1
		"term_move_to_char: where is riduculous: %d\r\n", where);
d618 1
a618 1
	(void)fprintf(el->el_errfile, "term_overwrite: n is riduculous: %d\r\n", n);
d651 1
a651 1
		"term_deletechars: num is riduculous: %d\r\n", num);
d695 1
a695 1
	(void)fprintf(el->el_errfile, "StartInsert: num is riduculous: %d\r\n", num);
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.4 1997/07/03 14:25:29 niklas Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: term.c,v 1.4 1997/07/03 14:25:29 niklas Exp $";
d257 1
a257 2
private	void	term_alloc		__P((EditLine *,
					     struct termcapstr *, char *)); 
@


1.4
log
@buffer overflow on 64-bit archs fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.3 1997/03/14 05:13:05 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: term.c,v 1.3 1997/03/14 05:13:05 millert Exp $";
d254 3
a256 3
private	void	term_rebuffer_display	__P((EditLine *));
private	void	term_free_display	__P((EditLine *));
private	void	term_alloc_display	__P((EditLine *));
d259 2
a260 2
private void	term_init_arrow		__P((EditLine *));
private void	term_reset_arrow	__P((EditLine *));
@


1.3
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: term.c,v 1.2 1997/01/16 05:18:47 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: term.c,v 1.2 1997/01/16 05:18:47 millert Exp $";
d321 1
a321 1
    (void)memset(el->el_term.t_val, 0, T_val * sizeof(char*));
@


1.2
log
@Merge in NetBSD libedit changes and new man pages.  Also fix some
strncpy() usage in their code.  NetBSD change log was:
    * add a man page for the editline routines
    * add a man page describing editrc
    * fix bugs in el_parse():
      * didn't execute command when program name matched (test reversed)
      * was checking against empty string instead of program name
      * after checks, command to run also pointed to empty string
    * document ^char and \ escape sequences
    * when parsing ^char control chars, check the correct char when determining
      validity (previously, ^char was a NOP interpreted as the literal string
      because of this bug)
    * Implement CC_REDISPLAY, which (unlike CC_REFRESH) redraws the entire input
    * line (a la ^R). This is useful if the binding outputs information and
    * mucks up the input line. To be used in ``list-choices'' bindings (refer
    * to the ^D binding in csh when filec is set)
@
text
@d1 2
a2 1
/*	$OpenBSD: $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: $";
d294 2
a295 2
	(void) fprintf(el->el_errfile, "WARNING: Your terminal cannot move up.\n");
	(void) fprintf(el->el_errfile, "Editing may be odd for long lines.\n");
d298 1
a298 1
	(void) fprintf(el->el_errfile, "no clear EOL capability.\n");
d300 1
a300 1
	(void) fprintf(el->el_errfile, "no delete char capability.\n");
d302 1
a302 1
	(void) fprintf(el->el_errfile, "no insert char capability.\n");
d319 1
a319 1
    (void) memset(el->el_term.t_str, 0, T_str * sizeof(char*));
d321 1
a321 1
    (void) memset(el->el_term.t_val, 0, T_val * sizeof(char*));
d323 1
a323 1
    (void) term_set(el, NULL);
d375 1
a375 1
	(void) strcpy(*str, cap);
d383 1
a383 1
	(void) strcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap);
d404 1
a404 1
	(void) fprintf(el->el_errfile, "Out of termcap string space.\n");
d407 1
a407 1
    (void) strcpy(*str = &el->el_term.t_buf[el->el_term.t_loc], cap);
d501 1
a501 1
	(void) fprintf(el->el_errfile, 
d509 1
a509 1
	    (void) tputs(tgoto(Str(T_DO), del, del), del, term__putc);
d518 1
a518 1
	    (void) tputs(tgoto(Str(T_UP), -del, -del), -del, term__putc);
d522 1
a522 1
		    (void) tputs(Str(T_up), 1, term__putc);
d545 1
a545 1
	(void) fprintf(el->el_errfile, 
d561 1
a561 1
	(void) tputs(tgoto(Str(T_ch), where, where), where, term__putc);
d565 1
a565 1
		(void) tputs(tgoto(Str(T_RI), del, del), del, term__putc);
d587 1
a587 1
		(void) tputs(tgoto(Str(T_LE), -del, -del), -del, term__putc);
d619 1
a619 1
	(void) fprintf(el->el_errfile, "term_overwrite: n is riduculous: %d\r\n", n);
d644 1
a644 1
	(void) fprintf(el->el_errfile, "   ERROR: cannot delete   \n");
d651 1
a651 1
	(void) fprintf(el->el_errfile, 
d659 1
a659 1
	    (void) tputs(tgoto(Str(T_DC), num, num), num, term__putc);
d664 1
a664 1
	(void) tputs(Str(T_dm), 1, term__putc);
d668 1
a668 1
	    (void) tputs(Str(T_dc), 1, term__putc);
d671 1
a671 1
	(void) tputs(Str(T_ed), 1, term__putc);
d689 1
a689 1
	(void) fprintf(el->el_errfile, "   ERROR: cannot insert   \n");
d696 1
a696 1
	(void) fprintf(el->el_errfile, "StartInsert: num is riduculous: %d\r\n", num);
d703 1
a703 1
	    (void) tputs(tgoto(Str(T_IC), num, num), num, term__putc);
d709 1
a709 1
	(void) tputs(Str(T_im), 1, term__putc);
d717 1
a717 1
	    (void) tputs(Str(T_ip), 1, term__putc);
d719 1
a719 1
	(void) tputs(Str(T_ei), 1, term__putc);
d725 1
a725 1
	    (void) tputs(Str(T_ic), 1, term__putc);	/* insert a char */
d732 1
a732 1
	    (void) tputs(Str(T_ip), 1, term__putc);/* pad the inserted char */
d749 1
a749 1
	(void) tputs(Str(T_ce), 1, term__putc);
d767 1
a767 1
	(void) tputs(Str(T_cl), Val(T_li), term__putc);
d769 1
a769 1
	(void) tputs(Str(T_ho), Val(T_li), term__putc);	/* home */
d771 1
a771 1
	(void) tputs(Str(T_cd), Val(T_li), term__putc);
d788 1
a788 1
	(void) tputs(Str(T_vb), 1, term__putc);	/* visible bell */
d791 1
a791 1
	(void) tputs(Str(T_bl), 1, term__putc);
d806 1
a806 1
	(void) tputs(Str(T_cd), Val(T_li), term__putc);
d808 1
a808 1
	(void) tputs(Str(T_ce), Val(T_li), term__putc);
d828 3
a830 3
    (void) sigemptyset(&nset);
    (void) sigaddset(&nset, SIGWINCH);
    (void) sigprocmask(SIG_BLOCK, &nset, &oset);
d847 1
a847 1
	    (void) fprintf(el->el_errfile, "Cannot read termcap database;\n");
d849 1
a849 1
	    (void) fprintf(el->el_errfile, 
d851 1
a851 1
	(void) fprintf(el->el_errfile, "using dumb terminal settings.\n");
d882 1
a882 1
    (void) term_get_size(el, &lins, &cols);/* get the correct window size */
d884 1
a884 1
    (void) sigprocmask(SIG_SETMASK, &oset, NULL);
d1142 1
a1142 1
    (void) fputc(c, term_outfile);
d1152 1
a1152 1
    (void) fflush(term_outfile);
d1170 3
a1172 3
    (void) fprintf(el->el_outfile, "\n\tYour terminal has the\n");
    (void) fprintf(el->el_outfile, "\tfollowing characteristics:\n\n");
    (void) fprintf(el->el_outfile, "\tIt has %d columns and %d lines\n",
d1174 1
a1174 1
    (void) fprintf(el->el_outfile, 
d1176 1
a1176 1
    (void) fprintf(el->el_outfile, 
d1179 1
a1179 1
    (void) fprintf(el->el_outfile, "\tIt %s automatic margins\n", 
d1182 1
a1182 1
	(void) fprintf(el->el_outfile, "\tIt %s magic margins\n", 
d1187 1
a1187 1
	(void) fprintf(el->el_outfile, "\t%25s (%s) == %s\n", t->long_name, 
d1190 1
a1190 1
    (void) fputc('\n', el->el_outfile);
d1246 1
a1246 1
		(void) fprintf(el->el_errfile, "settc: Bad value `%s'.\n", how);
d1307 1
a1307 1
	(void) fprintf(el->el_outfile, fmts, EL_CAN_TAB ? "yes" : "no");
d1311 1
a1311 1
	(void) fprintf(el->el_outfile, fmts, Val(T_km) ? "yes" : "no");
d1316 1
a1316 1
	(void) fprintf(el->el_outfile, fmts, T_Margin & MARGIN_MAGIC ? 
d1321 1
a1321 1
	(void) fprintf(el->el_outfile, fmts, T_Margin & MARGIN_AUTO ? 
d1332 1
a1332 1
		(void) fprintf(el->el_outfile, fmts, baud_rate[i].b_name);
d1335 1
a1335 1
	(void) fprintf(el->el_outfile, fmtd, 0);
d1337 1
a1337 1
	(void) fprintf(el->el_outfile, fmtd, el->el_tty.t_speed);
d1342 1
a1342 1
	(void) fprintf(el->el_outfile, fmtd, Val(T_li));
d1346 1
a1346 1
	(void) fprintf(el->el_outfile, fmtd, Val(T_co));
d1363 1
a1363 1
	    (void) fprintf(el->el_errfile, 
d1394 1
a1394 1
		    (void) fprintf(el->el_errfile, 
d1405 1
a1405 1
		(void) fprintf(el->el_errfile, 
d1409 1
a1409 1
	(void) tputs(scap, 1, term__putc);
d1415 1
a1415 1
		(void) fprintf(el->el_errfile, 
d1424 1
a1424 1
		(void) fprintf(el->el_errfile, 
d1428 1
a1428 1
	(void) tputs(tgoto(scap, arg_cols, arg_rows), 1, term__putc);
d1433 1
a1433 1
	    (void) fprintf(el->el_errfile, 
d1441 1
a1441 1
		(void) fprintf(el->el_errfile, 
d1449 1
a1449 1
		(void) fprintf(el->el_errfile, 
d1457 1
a1457 1
		(void) fprintf(el->el_errfile, 
d1461 1
a1461 1
	(void) tputs(tgoto(scap, arg_cols, arg_rows), arg_rows, term__putc);
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
d42 3
d59 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
