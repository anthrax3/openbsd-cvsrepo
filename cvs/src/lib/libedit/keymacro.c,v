head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5;
locks; strict;
comment	@ * @;


1.16
date	2016.05.25.09.23.49;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	8uuGVizA1k3gmrdl;

1.15
date	2016.05.06.13.12.52;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	HmIy04UbyUS0d1Sd;

1.14
date	2016.04.12.09.04.02;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	0JsQE9vcJ83YRqdA;

1.13
date	2016.04.11.21.17.29;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	I3AtNAFb4FywnTMT;

1.12
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	OUneMOe0l7HombT5;

1.11
date	2016.04.11.19.54.54;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	xizUpRlYj2C4Hcj6;

1.10
date	2016.04.09.20.15.26;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	0bnhGLXZIvXlnMLp;

1.9
date	2016.04.09.19.31.55;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	t22PDRfkb5DJX3rc;

1.8
date	2016.03.21.15.25.39;	author schwarze;	state Exp;
branches;
next	1.7;
commitid	Qq3DwK1S3lWtyR8X;

1.7
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.6;
commitid	tRHhB2RN3ZD1GvoI;

1.6
date	2016.03.20.20.35.38;	author schwarze;	state Exp;
branches;
next	1.5;
commitid	b06qlwkNEbVitvG0;

1.5
date	2016.01.31.20.42.33;	author schwarze;	state Exp;
branches;
next	1.4;
commitid	gD9lqwRuptCvbXUE;

1.4
date	2016.01.30.17.32.52;	author schwarze;	state Exp;
branches;
next	1.3;
commitid	wAt9MiELkmlnoi4U;

1.3
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.2;
commitid	dCN84ovvbfYwqrqX;

1.2
date	2016.01.29.19.32.33;	author schwarze;	state Exp;
branches;
next	1.1;
commitid	Ue1IcMCqgxm4S8jQ;

1.1
date	2016.01.29.17.23.21;	author schwarze;	state Exp;
branches;
next	;
commitid	MOfHvqt1MJvqXmCY;


desc
@@


1.16
log
@Saving errno in el_errno is only needed for one purpose:
Restoring the original errno found in el_wgetc() after
el_wgets() did some cleanup that may have changed errno.

Improve clarity and robustness of the code by not setting and
inspecting el_errno where it isn't needed; in particular, let
keymacro_get() properly report read failure to read_getcmd().
Move el_errno to el_read_t because it's only used in read.c.
Never set errno back to zero.

Checked with a test program installing a USR1 signal handler
without SA_RESTART, for the cases read_getcmd(), ed_quoted_insert(),
keymacro_get(), ed_command(), and EL_EDITMODE=0.

OK czarkoff@@
@
text
@/*	$OpenBSD: keymacro.c,v 1.15 2016/05/06 13:12:52 schwarze Exp $	*/
/*	$NetBSD: keymacro.c,v 1.23 2016/05/24 15:00:45 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * keymacro.c: This module contains the procedures for maintaining
 *	       the extended-key map.
 *
 *      An extended-key (key) is a sequence of keystrokes introduced
 *	with a sequence introducer and consisting of an arbitrary
 *	number of characters.  This module maintains a map (the
 *	el->el_keymacro.map)
 *	to convert these extended-key sequences into input strs
 *	(XK_STR) or editor functions (XK_CMD).
 *
 *      Warning:
 *	  If key is a substr of some other keys, then the longer
 *	  keys are lost!!  That is, if the keys "abcd" and "abcef"
 *	  are in el->el_keymacro.map, adding the key "abc" will cause
 *	  the first two definitions to be lost.
 *
 *      Restrictions:
 *      -------------
 *      1) It is not possible to have one key that is a
 *	   substr of another.
 */
#include <stdlib.h>
#include <string.h>

#include "el.h"
#include "fcns.h"

/*
 * The Nodes of the el->el_keymacro.map.  The el->el_keymacro.map is a
 * linked list of these node elements
 */
struct keymacro_node_t {
	wchar_t		 ch;		/* single character of key	 */
	int		 type;		/* node type			 */
	keymacro_value_t val;		/* command code or pointer to str,  */
					/* if this is a leaf		 */
	struct keymacro_node_t *next;	/* ptr to next char of this key  */
	struct keymacro_node_t *sibling;/* ptr to another key with same prefix*/
};

static int		 node_trav(EditLine *, keymacro_node_t *, wchar_t *,
    keymacro_value_t *);
static int		 node__try(EditLine *, keymacro_node_t *,
    const wchar_t *, keymacro_value_t *, int);
static keymacro_node_t	*node__get(wint_t);
static void		 node__free(keymacro_node_t *);
static void		 node__put(EditLine *, keymacro_node_t *);
static int		 node__delete(EditLine *, keymacro_node_t **,
    const wchar_t *);
static int		 node_lookup(EditLine *, const wchar_t *,
    keymacro_node_t *, size_t);
static int		 node_enum(EditLine *, keymacro_node_t *, size_t);

#define	KEY_BUFSIZ	EL_BUFSIZ


/* keymacro_init():
 *	Initialize the key maps
 */
protected int
keymacro_init(EditLine *el)
{

	el->el_keymacro.buf = reallocarray(NULL, KEY_BUFSIZ,
	    sizeof(*el->el_keymacro.buf));
	if (el->el_keymacro.buf == NULL)
		return -1;
	el->el_keymacro.map = NULL;
	keymacro_reset(el);
	return 0;
}

/* keymacro_end():
 *	Free the key maps
 */
protected void
keymacro_end(EditLine *el)
{

	free(el->el_keymacro.buf);
	el->el_keymacro.buf = NULL;
	node__free(el->el_keymacro.map);
}


/* keymacro_map_cmd():
 *	Associate cmd with a key value
 */
protected keymacro_value_t *
keymacro_map_cmd(EditLine *el, int cmd)
{

	el->el_keymacro.val.cmd = (el_action_t) cmd;
	return &el->el_keymacro.val;
}


/* keymacro_map_str():
 *	Associate str with a key value
 */
protected keymacro_value_t *
keymacro_map_str(EditLine *el, wchar_t *str)
{

	el->el_keymacro.val.str = str;
	return &el->el_keymacro.val;
}


/* keymacro_reset():
 *	Takes all nodes on el->el_keymacro.map and puts them on free list.
 *	Then initializes el->el_keymacro.map with arrow keys
 *	[Always bind the ansi arrow keys?]
 */
protected void
keymacro_reset(EditLine *el)
{

	node__put(el, el->el_keymacro.map);
	el->el_keymacro.map = NULL;
	return;
}


/* keymacro_get():
 *	Calls the recursive function with entry point el->el_keymacro.map
 *      Looks up *ch in map and then reads characters until a
 *      complete match is found or a mismatch occurs. Returns the
 *      type of the match found (XK_STR or XK_CMD).
 *      Returns NULL in val.str and XK_STR for no match.
 *      Returns XK_NOD for end of file or read error.
 *      The last character read is returned in *ch.
 */
protected int
keymacro_get(EditLine *el, wchar_t *ch, keymacro_value_t *val)
{

	return node_trav(el, el->el_keymacro.map, ch, val);
}


/* keymacro_add():
 *      Adds key to the el->el_keymacro.map and associates the value in
 *	val with it. If key is already is in el->el_keymacro.map, the new
 *	code is applied to the existing key. Ntype specifies if code is a
 *	command, an out str or a unix command.
 */
protected void
keymacro_add(EditLine *el, const wchar_t *key, keymacro_value_t *val,
    int ntype)
{

	if (key[0] == '\0') {
		(void) fprintf(el->el_errfile,
		    "keymacro_add: Null extended-key not allowed.\n");
		return;
	}
	if (ntype == XK_CMD && val->cmd == ED_SEQUENCE_LEAD_IN) {
		(void) fprintf(el->el_errfile,
		    "keymacro_add: sequence-lead-in command not allowed\n");
		return;
	}
	if (el->el_keymacro.map == NULL)
		/* tree is initially empty.  Set up new node to match key[0] */
		el->el_keymacro.map = node__get(key[0]);
			/* it is properly initialized */

	/* Now recurse through el->el_keymacro.map */
	(void) node__try(el, el->el_keymacro.map, key, val, ntype);
	return;
}


/* keymacro_clear():
 *
 */
protected void
keymacro_clear(EditLine *el, el_action_t *map, const wchar_t *in)
{
        if (*in > N_KEYS) /* can't be in the map */
                return;
	if ((map[(unsigned char)*in] == ED_SEQUENCE_LEAD_IN) &&
	    ((map == el->el_map.key &&
	    el->el_map.alt[(unsigned char)*in] != ED_SEQUENCE_LEAD_IN) ||
	    (map == el->el_map.alt &&
	    el->el_map.key[(unsigned char)*in] != ED_SEQUENCE_LEAD_IN)))
		(void) keymacro_delete(el, in);
}


/* keymacro_delete():
 *      Delete the key and all longer keys staring with key, if
 *      they exists.
 */
protected int
keymacro_delete(EditLine *el, const wchar_t *key)
{

	if (key[0] == '\0') {
		(void) fprintf(el->el_errfile,
		    "keymacro_delete: Null extended-key not allowed.\n");
		return -1;
	}
	if (el->el_keymacro.map == NULL)
		return 0;

	(void) node__delete(el, &el->el_keymacro.map, key);
	return 0;
}


/* keymacro_print():
 *	Print the binding associated with key key.
 *	Print entire el->el_keymacro.map if null
 */
protected void
keymacro_print(EditLine *el, const wchar_t *key)
{

	/* do nothing if el->el_keymacro.map is empty and null key specified */
	if (el->el_keymacro.map == NULL && *key == 0)
		return;

	el->el_keymacro.buf[0] = '"';
	if (node_lookup(el, key, el->el_keymacro.map, 1) <= -1)
		/* key is not bound */
		(void) fprintf(el->el_errfile, "Unbound extended key \"%ls"
		    "\"\n", key);
	return;
}


/* node_trav():
 *	recursively traverses node in tree until match or mismatch is
 *	found.  May read in more characters.
 */
static int
node_trav(EditLine *el, keymacro_node_t *ptr, wchar_t *ch,
    keymacro_value_t *val)
{

	if (ptr->ch == *ch) {
		/* match found */
		if (ptr->next) {
			/* key not complete so get next char */
			if (el_wgetc(el, ch) != 1)
				return XK_NOD;
			return node_trav(el, ptr->next, ch, val);
		} else {
			*val = ptr->val;
			if (ptr->type != XK_CMD)
				*ch = '\0';
			return ptr->type;
		}
	} else {
		/* no match found here */
		if (ptr->sibling) {
			/* try next sibling */
			return node_trav(el, ptr->sibling, ch, val);
		} else {
			/* no next sibling -- mismatch */
			val->str = NULL;
			return XK_STR;
		}
	}
}


/* node__try():
 *	Find a node that matches *str or allocate a new one
 */
static int
node__try(EditLine *el, keymacro_node_t *ptr, const wchar_t *str,
    keymacro_value_t *val, int ntype)
{

	if (ptr->ch != *str) {
		keymacro_node_t *xm;

		for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
			if (xm->sibling->ch == *str)
				break;
		if (xm->sibling == NULL)
			xm->sibling = node__get(*str);	/* setup new node */
		ptr = xm->sibling;
	}
	if (*++str == '\0') {
		/* we're there */
		if (ptr->next != NULL) {
			node__put(el, ptr->next);
				/* lose longer keys with this prefix */
			ptr->next = NULL;
		}
		switch (ptr->type) {
		case XK_CMD:
		case XK_NOD:
			break;
		case XK_STR:
			if (ptr->val.str)
				free(ptr->val.str);
			break;
		default:
			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n",
			    ptr->type));
			break;
		}

		switch (ptr->type = ntype) {
		case XK_CMD:
			ptr->val = *val;
			break;
		case XK_STR:
			if ((ptr->val.str = wcsdup(val->str)) == NULL)
				return -1;
			break;
		default:
			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ntype));
			break;
		}
	} else {
		/* still more chars to go */
		if (ptr->next == NULL)
			ptr->next = node__get(*str);	/* setup new node */
		(void) node__try(el, ptr->next, str, val, ntype);
	}
	return 0;
}


/* node__delete():
 *	Delete node that matches str
 */
static int
node__delete(EditLine *el, keymacro_node_t **inptr, const wchar_t *str)
{
	keymacro_node_t *ptr;
	keymacro_node_t *prev_ptr = NULL;

	ptr = *inptr;

	if (ptr->ch != *str) {
		keymacro_node_t *xm;

		for (xm = ptr; xm->sibling != NULL; xm = xm->sibling)
			if (xm->sibling->ch == *str)
				break;
		if (xm->sibling == NULL)
			return 0;
		prev_ptr = xm;
		ptr = xm->sibling;
	}
	if (*++str == '\0') {
		/* we're there */
		if (prev_ptr == NULL)
			*inptr = ptr->sibling;
		else
			prev_ptr->sibling = ptr->sibling;
		ptr->sibling = NULL;
		node__put(el, ptr);
		return 1;
	} else if (ptr->next != NULL &&
	    node__delete(el, &ptr->next, str) == 1) {
		if (ptr->next != NULL)
			return 0;
		if (prev_ptr == NULL)
			*inptr = ptr->sibling;
		else
			prev_ptr->sibling = ptr->sibling;
		ptr->sibling = NULL;
		node__put(el, ptr);
		return 1;
	} else {
		return 0;
	}
}


/* node__put():
 *	Puts a tree of nodes onto free list using free(3).
 */
static void
node__put(EditLine *el, keymacro_node_t *ptr)
{
	if (ptr == NULL)
		return;

	if (ptr->next != NULL) {
		node__put(el, ptr->next);
		ptr->next = NULL;
	}
	node__put(el, ptr->sibling);

	switch (ptr->type) {
	case XK_CMD:
	case XK_NOD:
		break;
	case XK_STR:
		if (ptr->val.str != NULL)
			free(ptr->val.str);
		break;
	default:
		EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ptr->type));
		break;
	}
	free(ptr);
}


/* node__get():
 *	Returns pointer to a keymacro_node_t for ch.
 */
static keymacro_node_t *
node__get(wint_t ch)
{
	keymacro_node_t *ptr;

	ptr = malloc(sizeof(*ptr));
	if (ptr == NULL)
		return NULL;
	ptr->ch = ch;
	ptr->type = XK_NOD;
	ptr->val.str = NULL;
	ptr->next = NULL;
	ptr->sibling = NULL;
	return ptr;
}

static void
node__free(keymacro_node_t *k)
{
	if (k == NULL)
		return;
	node__free(k->sibling);
	node__free(k->next);
	free(k);
}

/* node_lookup():
 *	look for the str starting at node ptr.
 *	Print if last node
 */
static int
node_lookup(EditLine *el, const wchar_t *str, keymacro_node_t *ptr,
    size_t cnt)
{
	ssize_t used;

	if (ptr == NULL)
		return -1;	/* cannot have null ptr */

	if (!str || *str == 0) {
		/* no more chars in str.  node_enum from here. */
		(void) node_enum(el, ptr, cnt);
		return 0;
	} else {
		/* If match put this char into el->el_keymacro.buf.  Recurse */
		if (ptr->ch == *str) {
			/* match found */
			used = ct_visual_char(el->el_keymacro.buf + cnt,
			    KEY_BUFSIZ - cnt, ptr->ch);
			if (used == -1)
				return -1; /* ran out of buffer space */
			if (ptr->next != NULL)
				/* not yet at leaf */
				return (node_lookup(el, str + 1, ptr->next,
				    used + cnt));
			else {
			    /* next node is null so key should be complete */
				if (str[1] == 0) {
					el->el_keymacro.buf[cnt+used  ] = '"';
					el->el_keymacro.buf[cnt+used+1] = '\0';
					keymacro_kprint(el, el->el_keymacro.buf,
					    &ptr->val, ptr->type);
					return 0;
				} else
					return -1;
					/* mismatch -- str still has chars */
			}
		} else {
			/* no match found try sibling */
			if (ptr->sibling)
				return (node_lookup(el, str, ptr->sibling,
				    cnt));
			else
				return -1;
		}
	}
}


/* node_enum():
 *	Traverse the node printing the characters it is bound in buffer
 */
static int
node_enum(EditLine *el, keymacro_node_t *ptr, size_t cnt)
{
        ssize_t used;

	if (cnt >= KEY_BUFSIZ - 5) {	/* buffer too small */
		el->el_keymacro.buf[++cnt] = '"';
		el->el_keymacro.buf[++cnt] = '\0';
		(void) fprintf(el->el_errfile,
		    "Some extended keys too long for internal print buffer");
		(void) fprintf(el->el_errfile, " \"%ls...\"\n",
		    el->el_keymacro.buf);
		return 0;
	}
	if (ptr == NULL) {
#ifdef DEBUG_EDIT
		(void) fprintf(el->el_errfile,
		    "node_enum: BUG!! Null ptr passed\n!");
#endif
		return -1;
	}
	/* put this char at end of str */
        used = ct_visual_char(el->el_keymacro.buf + cnt, KEY_BUFSIZ - cnt,
	    ptr->ch);
	if (ptr->next == NULL) {
		/* print this key and function */
		el->el_keymacro.buf[cnt + used   ] = '"';
		el->el_keymacro.buf[cnt + used + 1] = '\0';
		keymacro_kprint(el, el->el_keymacro.buf, &ptr->val, ptr->type);
	} else
		(void) node_enum(el, ptr->next, cnt + used);

	/* go to sibling if there is one */
	if (ptr->sibling)
		(void) node_enum(el, ptr->sibling, cnt);
	return 0;
}


/* keymacro_kprint():
 *	Print the specified key and its associated
 *	function specified by val
 */
protected void
keymacro_kprint(EditLine *el, const wchar_t *key, keymacro_value_t *val,
    int ntype)
{
	el_bindings_t *fp;
	char unparsbuf[EL_BUFSIZ];
	static const char fmt[] = "%-15s->  %s\n";

	if (val != NULL)
		switch (ntype) {
		case XK_STR:
			(void) keymacro__decode_str(val->str, unparsbuf,
			    sizeof(unparsbuf),
			    ntype == XK_STR ? "\"\"" : "[]");
			(void) fprintf(el->el_outfile, fmt,
			    ct_encode_string(key, &el->el_scratch), unparsbuf);
			break;
		case XK_CMD:
			for (fp = el->el_map.help; fp->name; fp++)
				if (val->cmd == fp->func) {
                    wcstombs(unparsbuf, fp->name, sizeof(unparsbuf));
                    unparsbuf[sizeof(unparsbuf) -1] = '\0';
					(void) fprintf(el->el_outfile, fmt,
                        ct_encode_string(key, &el->el_scratch), unparsbuf);
					break;
				}
#ifdef DEBUG_KEY
			if (fp->name == NULL)
				(void) fprintf(el->el_outfile,
				    "BUG! Command not found.\n");
#endif

			break;
		default:
			EL_ABORT((el->el_errfile, "Bad XK_ type %d\n", ntype));
			break;
		}
	else
		(void) fprintf(el->el_outfile, fmt, ct_encode_string(key,
		    &el->el_scratch), "no input");
}


#define ADDC(c) \
	if (b < eb) \
		*b++ = c; \
	else \
		b++
/* keymacro__decode_str():
 *	Make a printable version of the ey
 */
protected size_t
keymacro__decode_str(const wchar_t *str, char *buf, size_t len,
    const char *sep)
{
	char *b = buf, *eb = b + len;
	const wchar_t *p;

	b = buf;
	if (sep[0] != '\0') {
		ADDC(sep[0]);
	}
	if (*str == '\0') {
		ADDC('^');
		ADDC('@@');
		goto add_endsep;
	}
	for (p = str; *p != 0; p++) {
		wchar_t dbuf[VISUAL_WIDTH_MAX];
		wchar_t *p2 = dbuf;
		ssize_t l = ct_visual_char(dbuf, VISUAL_WIDTH_MAX, *p);
		while (l-- > 0) {
			ssize_t n = ct_encode_char(b, (size_t)(eb - b), *p2++);
			if (n == -1) /* ran out of space */
				goto add_endsep;
			else
				b += n;
		}
	}
add_endsep:
	if (sep[0] != '\0' && sep[1] != '\0') {
		ADDC(sep[1]);
	}
	ADDC('\0');
	if ((size_t)(b - buf) >= len)
	    buf[len - 1] = '\0';
	return (size_t)(b - buf);
}
@


1.15
log
@Replace the generated file "fcns.c" by a simpler header "func.h"
included only in the one file needing it, "map.c".
That allows to define el_action_t directly in "map.h",
which in turn allows to stop including "fcns.h" from "el.h"
and include it only in the modules needing it.
Now we no longer autogenerate any C files.

Feedback and OK martijn@@.
First version also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 2
a2 2
/*	$OpenBSD: keymacro.c,v 1.14 2016/04/12 09:04:02 schwarze Exp $	*/
/*	$NetBSD: keymacro.c,v 1.21 2016/04/18 17:01:19 christos Exp $	*/
d169 1
d284 2
a285 5
			if (el_wgetc(el, ch) != 1) {/* if EOF or error */
				val->cmd = ED_END_OF_FILE;
				return XK_CMD;
				/* PWP: Pretend we just read an end-of-file */
			}
@


1.14
log
@* Delete the unimplemented feature XK_EXE.
* Delete the unused macro MIN().
No functional change.
OK czarkoff@@ martijn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: keymacro.c,v 1.13 2016/04/11 21:17:29 schwarze Exp $	*/
/*	$NetBSD: keymacro.c,v 1.20 2016/04/12 00:16:06 christos Exp $	*/
d64 1
@


1.13
log
@delete the "private" and "public" preprocessor macros, just use standard C;
OK martijn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: keymacro.c,v 1.12 2016/04/11 20:43:33 schwarze Exp $	*/
/*	$NetBSD: keymacro.c,v 1.19 2016/04/11 18:56:31 christos Exp $	*/
d47 1
a47 1
 *	(XK_STR), editor functions (XK_CMD), or unix commands (XK_EXE).
d166 1
a166 1
 *      type of the match found (XK_STR, XK_CMD, or XK_EXE).
a337 1
		case XK_EXE:
a351 1
		case XK_EXE:
a435 1
	case XK_EXE:
a586 1
		case XK_EXE:
@


1.12
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: keymacro.c,v 1.11 2016/04/11 19:54:54 schwarze Exp $	*/
/*	$NetBSD: keymacro.c,v 1.18 2016/04/11 00:50:13 christos Exp $	*/
d78 1
a78 1
private int		 node_trav(EditLine *, keymacro_node_t *, wchar_t *,
d80 1
a80 1
private int		 node__try(EditLine *, keymacro_node_t *,
d82 4
a85 4
private keymacro_node_t	*node__get(wint_t);
private void		 node__free(keymacro_node_t *);
private void		 node__put(EditLine *, keymacro_node_t *);
private int		 node__delete(EditLine *, keymacro_node_t **,
d87 1
a87 1
private int		 node_lookup(EditLine *, const wchar_t *,
d89 1
a89 1
private int		 node_enum(EditLine *, keymacro_node_t *, size_t);
d273 1
a273 1
private int
d311 1
a311 1
private int
d374 1
a374 1
private int
d422 1
a422 1
private void
d454 1
a454 1
private keymacro_node_t *
d470 1
a470 1
private void
d484 1
a484 1
private int
d536 1
a536 1
private int
@


1.11
log
@Move wrapper macros to the two files actually needing them:
FUNW, Strlen, Strdup, Strcmp, Strncmp, Strncpy, Strncat -> history.c
Strchr, tok_strdup -> tokenizer.c
FUN, TYPE, STR -> both of these files

OK martijn@@

Also proofread by Christian Heckendorf <mbie at ulmus dot me>
who reported some whitespace issues in parse.c.
@
text
@d1 2
a2 2
/*	$OpenBSD: keymacro.c,v 1.10 2016/04/09 20:15:26 schwarze Exp $	*/
/*	$NetBSD: keymacro.c,v 1.16 2016/04/09 18:43:17 christos Exp $	*/
d70 1
a70 1
	Char		 ch;		/* single character of key	 */
d78 1
a78 1
private int		 node_trav(EditLine *, keymacro_node_t *, Char *,
d80 2
a81 2
private int		 node__try(EditLine *, keymacro_node_t *, const Char *,
    keymacro_value_t *, int);
d86 2
a87 2
    const Char *);
private int		 node_lookup(EditLine *, const Char *,
d139 1
a139 1
keymacro_map_str(EditLine *el, Char *str)
d171 1
a171 1
keymacro_get(EditLine *el, Char *ch, keymacro_value_t *val)
d185 2
a186 1
keymacro_add(EditLine *el, const Char *key, keymacro_value_t *val, int ntype)
d214 1
a214 1
keymacro_clear(EditLine *el, el_action_t *map, const Char *in)
d232 1
a232 1
keymacro_delete(EditLine *el, const Char *key)
d253 1
a253 1
keymacro_print(EditLine *el, const Char *key)
d274 2
a275 1
node_trav(EditLine *el, keymacro_node_t *ptr, Char *ch, keymacro_value_t *val)
a276 1
	wchar_t wc;
d282 1
a282 1
			if (el_wgetc(el, &wc) != 1) {/* if EOF or error */
a286 1
			*ch = (Char)wc;
d312 1
a312 1
node__try(EditLine *el, keymacro_node_t *ptr, const Char *str,
d375 1
a375 1
node__delete(EditLine *el, keymacro_node_t **inptr, const Char *str)
d485 2
a486 1
node_lookup(EditLine *el, const Char *str, keymacro_node_t *ptr, size_t cnt)
d580 2
a581 1
keymacro_kprint(EditLine *el, const Char *key, keymacro_value_t *val, int ntype)
d632 2
a633 1
keymacro__decode_str(const Char *str, char *buf, size_t len, const char *sep)
d636 1
a636 1
	const Char *p;
d648 2
a649 2
		Char dbuf[VISUAL_WIDTH_MAX];
		Char *p2 = dbuf;
@


1.10
log
@Delete 26 wrapper macros and two wrapper functions that are no
longer needed now that we always compile with wide character support,
reducing code obfuscation.

OK czarkoff@@ martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: keymacro.c,v 1.9 2016/04/09 19:31:55 schwarze Exp $	*/
d354 1
a354 1
			if ((ptr->val.str = Strdup(val->str)) == NULL)
@


1.9
log
@Always compile with WIDECHAR on and delete that preprocessor switch.
OK martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 2
a2 2
/*	$OpenBSD: keymacro.c,v 1.8 2016/03/21 15:25:39 schwarze Exp $	*/
/*	$NetBSD: keymacro.c,v 1.15 2016/03/23 22:27:48 christos Exp $	*/
d262 1
a262 1
		(void) fprintf(el->el_errfile, "Unbound extended key \"" FSTR
d545 1
a545 1
		(void) fprintf(el->el_errfile, " \"" FSTR "...\"\n",
d598 1
a598 1
                    ct_wcstombs(unparsbuf, fp->name, sizeof(unparsbuf));
@


1.8
log
@Reduce the FUN() macro madness by no longer applying it to el_[w]getc(3).
Always use el_wgetc(3) internally.  In the !WIDECHAR case, casting
the result to (Char) is safe because the function returns a byte
rather than a character in that case.
No functional change except for fixing a printf(3) format string issue
when compiled with DEBUG_READ and WIDECHAR.
OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: keymacro.c,v 1.7 2016/03/20 23:48:27 schwarze Exp $	*/
/*	$NetBSD: keymacro.c,v 1.14 2016/02/24 14:25:38 christos Exp $	*/
a214 1
#ifdef WIDECHAR
a216 1
#endif
@


1.7
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: keymacro.c,v 1.6 2016/03/20 20:35:38 schwarze Exp $	*/
/*	$NetBSD: keymacro.c,v 1.13 2016/02/17 19:47:49 christos Exp $	*/
d277 1
d283 1
a283 1
			if (FUN(el,getc)(el, ch) != 1) {/* if EOF or error */
d288 1
@


1.6
log
@Delete the useless Int datatype and always use the standard wint_t
directly.  This is not a problem because <wchar_t> is required all
over the place anyway, even when WIDECHAR is not defined.
No functional change except that it fixes a few printf(3)
format string issues, %c vs. %lc.
OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: keymacro.c,v 1.5 2016/01/31 20:42:33 schwarze Exp $	*/
/*	$NetBSD: key.c,v 1.23 2009/12/30 22:37:40 christos Exp $	*/
d60 1
a61 1
#include <stdlib.h>
d70 1
a70 1
	Char		 ch;		/* single character of key 	 */
d73 1
a73 1
					/* if this is a leaf 		 */
d272 1
a272 1
 * 	found.  May read in more characters.
d309 1
a309 1
 * 	Find a node that matches *str or allocate a new one
d590 1
a590 1
			    sizeof(unparsbuf), 
@


1.5
log
@remove some whitespace differences with NetBSD; no change with diff -b
@
text
@d1 1
a1 1
/*	$OpenBSD: keymacro.c,v 1.4 2016/01/30 17:32:52 schwarze Exp $	*/
d82 1
a82 1
private keymacro_node_t	*node__get(Int);
d455 1
a455 1
node__get(Int ch)
@


1.4
log
@Fifth step in synching with NetBSD:
Delete the silly ptr_t and ioctl_t typedefs
and delete some "#ifdef notdef" code from "sys.h".
No functional change.
This makes hist.h identical to the NetBSD version.
It reduces the remaining diff from +1526 -734 to +1430 -592.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymacro.c,v 1.3 2016/01/30 12:22:20 schwarze Exp $	*/
d70 2
a71 2
	Char		ch;		/* single character of key 	 */
	int		type;		/* node type			 */
@


1.3
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymacro.c,v 1.2 2016/01/29 19:32:33 schwarze Exp $	*/
d39 2
a40 2
 * key.c: This module contains the procedures for maintaining
 *	  the extended-key map.
d340 1
a340 1
				free((ptr_t) ptr->val.str);
d441 1
a441 1
			free((ptr_t) ptr->val.str);
d447 1
a447 1
	free((ptr_t) ptr);
d477 1
a477 1
	free((ptr_t) k);
@


1.2
log
@Second step in synching with NetBSD:
* Rename some types from *key*_t to *keymacro*_t.
* Rename struct editline member el_key to el_keymacro.
* Rename some functions in keymacro.c from key*() to keymacro*().
This removes the conflict of key_clear(), key_end(), and key_print()
with macros in <term.h>.  No functional change.
This makes keymacro.h identical to the NetBSD version.
It reduces the remaining diff from +2640 -1998 to +2446 -1805.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: keymacro.c,v 1.1 2016/01/29 17:23:21 schwarze Exp $	*/
d104 1
a104 1
		return (-1);
d107 1
a107 1
	return (0);
d239 1
a239 1
		return (-1);
d242 1
a242 1
		return (0);
d245 1
a245 1
	return (0);
d284 1
a284 1
				return (XK_CMD);
d287 1
a287 1
			return (node_trav(el, ptr->next, ch, val));
d292 1
a292 1
			return (ptr->type);
d298 1
a298 1
			return (node_trav(el, ptr->sibling, ch, val));
d302 1
a302 1
			return (XK_STR);
d367 1
a367 1
	return (0);
d389 1
a389 1
			return (0);
d401 1
a401 1
		return (1);
d405 1
a405 1
			return (0);
d412 1
a412 1
		return (1);
d414 1
a414 1
		return (0);
d467 1
a467 1
	return (ptr);
d490 1
a490 1
		return (-1);	/* cannot have null ptr */
d495 1
a495 1
		return (0);
d503 1
a503 1
				return (-1); /* ran out of buffer space */
d515 1
a515 1
					return (0);
d517 1
a517 1
					return (-1);
d526 1
a526 1
				return (-1);
d547 1
a547 1
		return (0);
d554 1
a554 1
		return (-1);
d570 1
a570 1
	return (0);
@


1.1
log
@Start synching with NetBSD:
Rename the files key.[hc] to keymacro.[hc] and term.[hc] to terminal.[hc].
The change makes sense because "term.h" conflicts with <term.h>
and the functions key_clear(), key_end(), and key_print() in "key.h"
conflict with macros in <term.h>.
No content change yet, no binary change in *.o after "strip -d".
This reduces the remaining diff from +4634 -3992 to +2640 -1998.
OK czarkoff@@, and mmcc@@ agrees with the direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: key.c,v 1.12 2014/10/17 06:07:50 deraadt Exp $	*/
d44 2
a45 1
 *	number of characters.  This module maintains a map (the el->el_key.map)
d52 2
a53 2
 *	  are in el->el_key.map, adding the key "abc" will cause the first two
 *	  definitions to be lost.
d66 2
a67 2
 * The Nodes of the el->el_key.map.  The el->el_key.map is a linked list
 * of these node elements
d69 1
a69 1
struct key_node_t {
d72 1
a72 1
	key_value_t	val;		/* command code or pointer to str,  */
d74 2
a75 2
	struct key_node_t *next;	/* ptr to next char of this key  */
	struct key_node_t *sibling;	/* ptr to another key with same prefix*/
d78 12
a89 11
private int		 node_trav(EditLine *, key_node_t *, Char *,
    key_value_t *);
private int		 node__try(EditLine *, key_node_t *, const Char *,
    key_value_t *, int);
private key_node_t	*node__get(Int);
private void		 node__free(key_node_t *);
private void		 node__put(EditLine *, key_node_t *);
private int		 node__delete(EditLine *, key_node_t **, const Char *);
private int		 node_lookup(EditLine *, const Char *, key_node_t *,
    size_t);
private int		 node_enum(EditLine *, key_node_t *, size_t);
d94 1
a94 1
/* key_init():
d98 1
a98 1
key_init(EditLine *el)
d101 3
a103 3
	el->el_key.buf = reallocarray(NULL, KEY_BUFSIZ,
	    sizeof(*el->el_key.buf));
	if (el->el_key.buf == NULL)
d105 2
a106 2
	el->el_key.map = NULL;
	key_reset(el);
d110 1
a110 1
/* key_end():
d114 1
a114 1
key_end(EditLine *el)
d117 3
a119 3
	free((ptr_t) el->el_key.buf);
	el->el_key.buf = NULL;
	node__free(el->el_key.map);
d123 1
a123 1
/* key_map_cmd():
d126 2
a127 2
protected key_value_t *
key_map_cmd(EditLine *el, int cmd)
d130 2
a131 2
	el->el_key.val.cmd = (el_action_t) cmd;
	return (&el->el_key.val);
d135 1
a135 1
/* key_map_str():
d138 2
a139 2
protected key_value_t *
key_map_str(EditLine *el, Char *str)
d142 2
a143 2
	el->el_key.val.str = str;
	return (&el->el_key.val);
d147 3
a149 3
/* key_reset():
 *	Takes all nodes on el->el_key.map and puts them on free list.  Then
 *	initializes el->el_key.map with arrow keys
d153 1
a153 1
key_reset(EditLine *el)
d156 2
a157 2
	node__put(el, el->el_key.map);
	el->el_key.map = NULL;
d162 2
a163 2
/* key_get():
 *	Calls the recursive function with entry point el->el_key.map
d171 1
a171 1
key_get(EditLine *el, Char *ch, key_value_t *val)
d174 1
a174 1
	return (node_trav(el, el->el_key.map, ch, val));
d178 5
a182 5
/* key_add():
 *      Adds key to the el->el_key.map and associates the value in val with it.
 *      If key is already is in el->el_key.map, the new code is applied to the
 *      existing key. Ntype specifies if code is a command, an
 *      out str or a unix command.
d185 1
a185 1
key_add(EditLine *el, const Char *key, key_value_t *val, int ntype)
d190 1
a190 1
		    "key_add: Null extended-key not allowed.\n");
d195 1
a195 1
		    "key_add: sequence-lead-in command not allowed\n");
d198 1
a198 1
	if (el->el_key.map == NULL)
d200 1
a200 1
		el->el_key.map = node__get(key[0]);
d203 2
a204 2
	/* Now recurse through el->el_key.map */
	(void) node__try(el, el->el_key.map, key, val, ntype);
d209 1
a209 1
/* key_clear():
d213 1
a213 1
key_clear(EditLine *el, el_action_t *map, const Char *in)
d224 1
a224 1
		(void) key_delete(el, in);
d228 1
a228 1
/* key_delete():
d233 1
a233 1
key_delete(EditLine *el, const Char *key)
d238 1
a238 1
		    "key_delete: Null extended-key not allowed.\n");
d241 1
a241 1
	if (el->el_key.map == NULL)
d244 1
a244 1
	(void) node__delete(el, &el->el_key.map, key);
d249 1
a249 1
/* key_print():
d251 1
a251 1
 *	Print entire el->el_key.map if null
d254 1
a254 1
key_print(EditLine *el, const Char *key)
d257 2
a258 2
	/* do nothing if el->el_key.map is empty and null key specified */
	if (el->el_key.map == NULL && *key == 0)
d261 2
a262 2
	el->el_key.buf[0] = '"';
	if (node_lookup(el, key, el->el_key.map, 1) <= -1)
d264 2
a265 2
		(void) fprintf(el->el_errfile, "Unbound extended key \"" FSTR "\"\n",
		    key);
d275 1
a275 1
node_trav(EditLine *el, key_node_t *ptr, Char *ch, key_value_t *val)
d312 2
a313 1
node__try(EditLine *el, key_node_t *ptr, const Char *str, key_value_t *val, int ntype)
d317 1
a317 1
		key_node_t *xm;
d375 1
a375 1
node__delete(EditLine *el, key_node_t **inptr, const Char *str)
d377 2
a378 2
	key_node_t *ptr;
	key_node_t *prev_ptr = NULL;
d383 1
a383 1
		key_node_t *xm;
d423 1
a423 1
node__put(EditLine *el, key_node_t *ptr)
d452 1
a452 1
 *	Returns pointer to a key_node_t for ch.
d454 1
a454 1
private key_node_t *
d457 1
a457 1
	key_node_t *ptr;
d459 1
a459 1
	ptr = malloc(sizeof(key_node_t));
d471 1
a471 1
node__free(key_node_t *k)
d485 1
a485 1
node_lookup(EditLine *el, const Char *str, key_node_t *ptr, size_t cnt)
d497 1
a497 1
		/* If match put this char into el->el_key.buf.  Recurse */
d500 1
a500 1
			used = ct_visual_char(el->el_key.buf + cnt,
d511 3
a513 3
					el->el_key.buf[cnt + used    ] = '"';
					el->el_key.buf[cnt + used + 1] = '\0';
					key_kprint(el, el->el_key.buf,
d536 1
a536 1
node_enum(EditLine *el, key_node_t *ptr, size_t cnt)
d541 2
a542 2
		el->el_key.buf[++cnt] = '"';
		el->el_key.buf[++cnt] = '\0';
d545 2
a546 1
		(void) fprintf(el->el_errfile, " \"" FSTR "...\"\n", el->el_key.buf);
d557 2
a558 1
        used = ct_visual_char(el->el_key.buf + cnt, KEY_BUFSIZ - cnt, ptr->ch);
d561 3
a563 3
		el->el_key.buf[cnt + used   ] = '"';
		el->el_key.buf[cnt + used + 1] = '\0';
		key_kprint(el, el->el_key.buf, &ptr->val, ptr->type);
d574 1
a574 1
/* key_kprint():
d579 1
a579 1
key_kprint(EditLine *el, const Char *key, key_value_t *val, int ntype)
d589 1
a589 1
			(void) key__decode_str(val->str, unparsbuf,
d626 1
a626 1
/* key__decode_str():
d630 1
a630 1
key__decode_str(const Char *str, char *buf, size_t len, const char *sep)
a664 1

@

