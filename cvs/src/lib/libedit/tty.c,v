head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.2
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.14.0.8
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.14
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.26
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.22
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.20
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.18
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.16
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.14
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.05.06.13.12.52;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	HmIy04UbyUS0d1Sd;

1.26
date	2016.04.11.21.17.29;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	I3AtNAFb4FywnTMT;

1.25
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	OUneMOe0l7HombT5;

1.24
date	2016.04.11.19.54.54;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	xizUpRlYj2C4Hcj6;

1.23
date	2016.04.09.20.15.26;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	0bnhGLXZIvXlnMLp;

1.22
date	2016.04.09.18.42.49;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	YTgwv5D2LJuh85Ov;

1.21
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	tRHhB2RN3ZD1GvoI;

1.20
date	2016.03.20.22.57.59;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	VBVmrUoZFnMc0hts;

1.19
date	2016.03.20.20.35.38;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	b06qlwkNEbVitvG0;

1.18
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	dCN84ovvbfYwqrqX;

1.17
date	2016.01.30.02.52.41;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	GXbmevFye1xXIR4O;

1.16
date	2016.01.30.00.06.39;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	tGf8IdK8wCurneJ7;

1.15
date	2016.01.29.19.32.34;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	Ue1IcMCqgxm4S8jQ;

1.14
date	2014.05.20.22.28.07;	author yasuoka;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.07.05.40.42;	author okan;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.25.20.12.38;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.01.21.11.21;	author avsm;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.13.20.21.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.29.23.40.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.03.14.05.13.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.16.05.18.50;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.43;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Replace the generated file "fcns.c" by a simpler header "func.h"
included only in the one file needing it, "map.c".
That allows to define el_action_t directly in "map.h",
which in turn allows to stop including "fcns.h" from "el.h"
and include it only in the modules needing it.
Now we no longer autogenerate any C files.

Feedback and OK martijn@@.
First version also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@/*	$OpenBSD: tty.c,v 1.26 2016/04/11 21:17:29 schwarze Exp $	*/
/*	$NetBSD: tty.c,v 1.34 2011/01/27 23:11:40 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * tty.c: tty interface stuff
 */
#include <assert.h>
#include <errno.h>
#include <stdlib.h>	/* for abort */
#include <string.h>
#include <strings.h>	/* for ffs */
#include <unistd.h>	/* for isatty */

#include "el.h"
#include "fcns.h"
#include "parse.h"

typedef struct ttymodes_t {
	const char *m_name;
	unsigned int m_value;
	int m_type;
}          ttymodes_t;

typedef struct ttymap_t {
	wint_t nch, och;	/* Internal and termio rep of chars */
	el_action_t bind[3];	/* emacs, vi, and vi-cmd */
} ttymap_t;


static const ttyperm_t ttyperm = {
	{
		{"iflag:", ICRNL, (INLCR | IGNCR)},
		{"oflag:", (OPOST | ONLCR), ONLRET},
		{"cflag:", 0, 0},
		{"lflag:", (ISIG | ICANON | ECHO | ECHOE | ECHOCTL | IEXTEN),
		(NOFLSH | ECHONL | EXTPROC | FLUSHO)},
		{"chars:", 0, 0},
	},
	{
		{"iflag:", (INLCR | ICRNL), IGNCR},
		{"oflag:", (OPOST | ONLCR), ONLRET},
		{"cflag:", 0, 0},
		{"lflag:", ISIG,
		(NOFLSH | ICANON | ECHO | ECHOK | ECHONL | EXTPROC | IEXTEN | FLUSHO)},
		{"chars:", (C_SH(C_MIN) | C_SH(C_TIME) | C_SH(C_SWTCH) | C_SH(C_DSWTCH) |
			    C_SH(C_SUSP) | C_SH(C_DSUSP) | C_SH(C_EOL) | C_SH(C_DISCARD) |
		    C_SH(C_PGOFF) | C_SH(C_PAGE) | C_SH(C_STATUS)), 0}
	},
	{
		{"iflag:", 0, IXON | IXOFF | INLCR | ICRNL},
		{"oflag:", 0, 0},
		{"cflag:", 0, 0},
		{"lflag:", 0, ISIG | IEXTEN},
		{"chars:", 0, 0},
	}
};

static const ttychar_t ttychar = {
	{
		CINTR, CQUIT, CERASE, CKILL,
		CEOF, CEOL, CEOL2, CSWTCH,
		CDSWTCH, CERASE2, CSTART, CSTOP,
		CWERASE, CSUSP, CDSUSP, CREPRINT,
		CDISCARD, CLNEXT, CSTATUS, CPAGE,
		CPGOFF, CKILL2, CBRK, CMIN,
		CTIME
	},
	{
		CINTR, CQUIT, CERASE, CKILL,
		_POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE,
		_POSIX_VDISABLE, CERASE2, CSTART, CSTOP,
		_POSIX_VDISABLE, CSUSP, _POSIX_VDISABLE, _POSIX_VDISABLE,
		CDISCARD, _POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE,
		_POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, 1,
		0
	},
	{
		0, 0, 0, 0,
		0, 0, 0, 0,
		0, 0, 0, 0,
		0, 0, 0, 0,
		0, 0, 0, 0,
		0, 0, 0, 0,
		0
	}
};

static const ttymap_t tty_map[] = {
#ifdef VERASE
	{C_ERASE, VERASE,
	{EM_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR}},
#endif /* VERASE */
#ifdef VERASE2
	{C_ERASE2, VERASE2,
	{EM_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR}},
#endif /* VERASE2 */
#ifdef VKILL
	{C_KILL, VKILL,
	{EM_KILL_LINE, VI_KILL_LINE_PREV, ED_UNASSIGNED}},
#endif /* VKILL */
#ifdef VKILL2
	{C_KILL2, VKILL2,
	{EM_KILL_LINE, VI_KILL_LINE_PREV, ED_UNASSIGNED}},
#endif /* VKILL2 */
#ifdef VEOF
	{C_EOF, VEOF,
	{EM_DELETE_OR_LIST, VI_LIST_OR_EOF, ED_UNASSIGNED}},
#endif /* VEOF */
#ifdef VWERASE
	{C_WERASE, VWERASE,
	{ED_DELETE_PREV_WORD, ED_DELETE_PREV_WORD, ED_PREV_WORD}},
#endif /* VWERASE */
#ifdef VREPRINT
	{C_REPRINT, VREPRINT,
	{ED_REDISPLAY, ED_INSERT, ED_REDISPLAY}},
#endif /* VREPRINT */
#ifdef VLNEXT
	{C_LNEXT, VLNEXT,
	{ED_QUOTED_INSERT, ED_QUOTED_INSERT, ED_UNASSIGNED}},
#endif /* VLNEXT */
	{(wint_t)-1, (wint_t)-1,
	{ED_UNASSIGNED, ED_UNASSIGNED, ED_UNASSIGNED}}
};

static const ttymodes_t ttymodes[] = {
#ifdef	IGNBRK
	{"ignbrk", IGNBRK, MD_INP},
#endif /* IGNBRK */
#ifdef	BRKINT
	{"brkint", BRKINT, MD_INP},
#endif /* BRKINT */
#ifdef	IGNPAR
	{"ignpar", IGNPAR, MD_INP},
#endif /* IGNPAR */
#ifdef	PARMRK
	{"parmrk", PARMRK, MD_INP},
#endif /* PARMRK */
#ifdef	INPCK
	{"inpck", INPCK, MD_INP},
#endif /* INPCK */
#ifdef	ISTRIP
	{"istrip", ISTRIP, MD_INP},
#endif /* ISTRIP */
#ifdef	INLCR
	{"inlcr", INLCR, MD_INP},
#endif /* INLCR */
#ifdef	IGNCR
	{"igncr", IGNCR, MD_INP},
#endif /* IGNCR */
#ifdef	ICRNL
	{"icrnl", ICRNL, MD_INP},
#endif /* ICRNL */
#ifdef	IUCLC
	{"iuclc", IUCLC, MD_INP},
#endif /* IUCLC */
#ifdef	IXON
	{"ixon", IXON, MD_INP},
#endif /* IXON */
#ifdef	IXANY
	{"ixany", IXANY, MD_INP},
#endif /* IXANY */
#ifdef	IXOFF
	{"ixoff", IXOFF, MD_INP},
#endif /* IXOFF */
#ifdef  IMAXBEL
	{"imaxbel", IMAXBEL, MD_INP},
#endif /* IMAXBEL */

#ifdef	OPOST
	{"opost", OPOST, MD_OUT},
#endif /* OPOST */
#ifdef	OLCUC
	{"olcuc", OLCUC, MD_OUT},
#endif /* OLCUC */
#ifdef	ONLCR
	{"onlcr", ONLCR, MD_OUT},
#endif /* ONLCR */
#ifdef	OCRNL
	{"ocrnl", OCRNL, MD_OUT},
#endif /* OCRNL */
#ifdef	ONOCR
	{"onocr", ONOCR, MD_OUT},
#endif /* ONOCR */
#ifdef ONOEOT
	{"onoeot", ONOEOT, MD_OUT},
#endif /* ONOEOT */
#ifdef	ONLRET
	{"onlret", ONLRET, MD_OUT},
#endif /* ONLRET */
#ifdef	OFILL
	{"ofill", OFILL, MD_OUT},
#endif /* OFILL */
#ifdef	OFDEL
	{"ofdel", OFDEL, MD_OUT},
#endif /* OFDEL */
#ifdef	NLDLY
	{"nldly", NLDLY, MD_OUT},
#endif /* NLDLY */
#ifdef	CRDLY
	{"crdly", CRDLY, MD_OUT},
#endif /* CRDLY */
#ifdef	TABDLY
	{"tabdly", TABDLY, MD_OUT},
#endif /* TABDLY */
#ifdef	XTABS
	{"xtabs", XTABS, MD_OUT},
#endif /* XTABS */
#ifdef	BSDLY
	{"bsdly", BSDLY, MD_OUT},
#endif /* BSDLY */
#ifdef	VTDLY
	{"vtdly", VTDLY, MD_OUT},
#endif /* VTDLY */
#ifdef	FFDLY
	{"ffdly", FFDLY, MD_OUT},
#endif /* FFDLY */
#ifdef	PAGEOUT
	{"pageout", PAGEOUT, MD_OUT},
#endif /* PAGEOUT */
#ifdef	WRAP
	{"wrap", WRAP, MD_OUT},
#endif /* WRAP */

#ifdef	CIGNORE
	{"cignore", CIGNORE, MD_CTL},
#endif /* CBAUD */
#ifdef	CBAUD
	{"cbaud", CBAUD, MD_CTL},
#endif /* CBAUD */
#ifdef	CSTOPB
	{"cstopb", CSTOPB, MD_CTL},
#endif /* CSTOPB */
#ifdef	CREAD
	{"cread", CREAD, MD_CTL},
#endif /* CREAD */
#ifdef	PARENB
	{"parenb", PARENB, MD_CTL},
#endif /* PARENB */
#ifdef	PARODD
	{"parodd", PARODD, MD_CTL},
#endif /* PARODD */
#ifdef	HUPCL
	{"hupcl", HUPCL, MD_CTL},
#endif /* HUPCL */
#ifdef	CLOCAL
	{"clocal", CLOCAL, MD_CTL},
#endif /* CLOCAL */
#ifdef	LOBLK
	{"loblk", LOBLK, MD_CTL},
#endif /* LOBLK */
#ifdef	CIBAUD
	{"cibaud", CIBAUD, MD_CTL},
#endif /* CIBAUD */
#ifdef CRTSCTS
#ifdef CCTS_OFLOW
	{"ccts_oflow", CCTS_OFLOW, MD_CTL},
#else
	{"crtscts", CRTSCTS, MD_CTL},
#endif /* CCTS_OFLOW */
#endif /* CRTSCTS */
#ifdef CRTS_IFLOW
	{"crts_iflow", CRTS_IFLOW, MD_CTL},
#endif /* CRTS_IFLOW */
#ifdef CDTRCTS
	{"cdtrcts", CDTRCTS, MD_CTL},
#endif /* CDTRCTS */
#ifdef MDMBUF
	{"mdmbuf", MDMBUF, MD_CTL},
#endif /* MDMBUF */
#ifdef RCV1EN
	{"rcv1en", RCV1EN, MD_CTL},
#endif /* RCV1EN */
#ifdef XMT1EN
	{"xmt1en", XMT1EN, MD_CTL},
#endif /* XMT1EN */

#ifdef	ISIG
	{"isig", ISIG, MD_LIN},
#endif /* ISIG */
#ifdef	ICANON
	{"icanon", ICANON, MD_LIN},
#endif /* ICANON */
#ifdef	XCASE
	{"xcase", XCASE, MD_LIN},
#endif /* XCASE */
#ifdef	ECHO
	{"echo", ECHO, MD_LIN},
#endif /* ECHO */
#ifdef	ECHOE
	{"echoe", ECHOE, MD_LIN},
#endif /* ECHOE */
#ifdef	ECHOK
	{"echok", ECHOK, MD_LIN},
#endif /* ECHOK */
#ifdef	ECHONL
	{"echonl", ECHONL, MD_LIN},
#endif /* ECHONL */
#ifdef	NOFLSH
	{"noflsh", NOFLSH, MD_LIN},
#endif /* NOFLSH */
#ifdef	TOSTOP
	{"tostop", TOSTOP, MD_LIN},
#endif /* TOSTOP */
#ifdef	ECHOCTL
	{"echoctl", ECHOCTL, MD_LIN},
#endif /* ECHOCTL */
#ifdef	ECHOPRT
	{"echoprt", ECHOPRT, MD_LIN},
#endif /* ECHOPRT */
#ifdef	ECHOKE
	{"echoke", ECHOKE, MD_LIN},
#endif /* ECHOKE */
#ifdef	DEFECHO
	{"defecho", DEFECHO, MD_LIN},
#endif /* DEFECHO */
#ifdef	FLUSHO
	{"flusho", FLUSHO, MD_LIN},
#endif /* FLUSHO */
#ifdef	PENDIN
	{"pendin", PENDIN, MD_LIN},
#endif /* PENDIN */
#ifdef	IEXTEN
	{"iexten", IEXTEN, MD_LIN},
#endif /* IEXTEN */
#ifdef	NOKERNINFO
	{"nokerninfo", NOKERNINFO, MD_LIN},
#endif /* NOKERNINFO */
#ifdef	ALTWERASE
	{"altwerase", ALTWERASE, MD_LIN},
#endif /* ALTWERASE */
#ifdef	EXTPROC
	{"extproc", EXTPROC, MD_LIN},
#endif /* EXTPROC */

#if defined(VINTR)
	{"intr", C_SH(C_INTR), MD_CHAR},
#endif /* VINTR */
#if defined(VQUIT)
	{"quit", C_SH(C_QUIT), MD_CHAR},
#endif /* VQUIT */
#if defined(VERASE)
	{"erase", C_SH(C_ERASE), MD_CHAR},
#endif /* VERASE */
#if defined(VKILL)
	{"kill", C_SH(C_KILL), MD_CHAR},
#endif /* VKILL */
#if defined(VEOF)
	{"eof", C_SH(C_EOF), MD_CHAR},
#endif /* VEOF */
#if defined(VEOL)
	{"eol", C_SH(C_EOL), MD_CHAR},
#endif /* VEOL */
#if defined(VEOL2)
	{"eol2", C_SH(C_EOL2), MD_CHAR},
#endif /* VEOL2 */
#if defined(VSWTCH)
	{"swtch", C_SH(C_SWTCH), MD_CHAR},
#endif /* VSWTCH */
#if defined(VDSWTCH)
	{"dswtch", C_SH(C_DSWTCH), MD_CHAR},
#endif /* VDSWTCH */
#if defined(VERASE2)
	{"erase2", C_SH(C_ERASE2), MD_CHAR},
#endif /* VERASE2 */
#if defined(VSTART)
	{"start", C_SH(C_START), MD_CHAR},
#endif /* VSTART */
#if defined(VSTOP)
	{"stop", C_SH(C_STOP), MD_CHAR},
#endif /* VSTOP */
#if defined(VWERASE)
	{"werase", C_SH(C_WERASE), MD_CHAR},
#endif /* VWERASE */
#if defined(VSUSP)
	{"susp", C_SH(C_SUSP), MD_CHAR},
#endif /* VSUSP */
#if defined(VDSUSP)
	{"dsusp", C_SH(C_DSUSP), MD_CHAR},
#endif /* VDSUSP */
#if defined(VREPRINT)
	{"reprint", C_SH(C_REPRINT), MD_CHAR},
#endif /* VREPRINT */
#if defined(VDISCARD)
	{"discard", C_SH(C_DISCARD), MD_CHAR},
#endif /* VDISCARD */
#if defined(VLNEXT)
	{"lnext", C_SH(C_LNEXT), MD_CHAR},
#endif /* VLNEXT */
#if defined(VSTATUS)
	{"status", C_SH(C_STATUS), MD_CHAR},
#endif /* VSTATUS */
#if defined(VPAGE)
	{"page", C_SH(C_PAGE), MD_CHAR},
#endif /* VPAGE */
#if defined(VPGOFF)
	{"pgoff", C_SH(C_PGOFF), MD_CHAR},
#endif /* VPGOFF */
#if defined(VKILL2)
	{"kill2", C_SH(C_KILL2), MD_CHAR},
#endif /* VKILL2 */
#if defined(VBRK)
	{"brk", C_SH(C_BRK), MD_CHAR},
#endif /* VBRK */
#if defined(VMIN)
	{"min", C_SH(C_MIN), MD_CHAR},
#endif /* VMIN */
#if defined(VTIME)
	{"time", C_SH(C_TIME), MD_CHAR},
#endif /* VTIME */
	{NULL, 0, -1},
};



#define	tty__gettabs(td)	((((td)->c_oflag & TAB3) == TAB3) ? 0 : 1)
#define	tty__geteightbit(td)	(((td)->c_cflag & CSIZE) == CS8)
#define	tty__cooked_mode(td)	((td)->c_lflag & ICANON)

static int	tty_getty(EditLine *, struct termios *);
static int	tty_setty(EditLine *, int, const struct termios *);
static int	tty__getcharindex(int);
static void	tty__getchar(struct termios *, unsigned char *);
static void	tty__setchar(struct termios *, unsigned char *);
static speed_t	tty__getspeed(struct termios *);
static int	tty_setup(EditLine *);
static void	tty_setup_flags(EditLine *, struct termios *, int);

#define	t_qu	t_ts

/* tty_getty():
 *	Wrapper for tcgetattr to handle EINTR
 */
static int
tty_getty(EditLine *el, struct termios *t)
{
	int rv;
	while ((rv = tcgetattr(el->el_infd, t)) == -1 && errno == EINTR)
		continue;
	return rv;
}

/* tty_setty():
 *	Wrapper for tcsetattr to handle EINTR
 */
static int
tty_setty(EditLine *el, int action, const struct termios *t)
{
	int rv;
	while ((rv = tcsetattr(el->el_infd, action, t)) == -1 && errno == EINTR)
		continue;
	return rv;
}

/* tty_setup():
 *	Get the tty parameters and initialize the editing state
 */
static int
tty_setup(EditLine *el)
{
	int rst = 1;

	if (el->el_flags & EDIT_DISABLED)
		return 0;

	if (el->el_tty.t_initialized)
		return -1;

	if (!isatty(el->el_outfd)) {
#ifdef DEBUG_TTY
		(void) fprintf(el->el_errfile,
		    "tty_setup: isatty: %s\n", strerror(errno));
#endif /* DEBUG_TTY */
		return -1;
	}
	if (tty_getty(el, &el->el_tty.t_or) == -1) {
#ifdef DEBUG_TTY
		(void) fprintf(el->el_errfile,
		    "tty_setup: tty_getty: %s\n", strerror(errno));
#endif /* DEBUG_TTY */
		return -1;
	}
	el->el_tty.t_ts = el->el_tty.t_ex = el->el_tty.t_ed = el->el_tty.t_or;

	el->el_tty.t_speed = tty__getspeed(&el->el_tty.t_ex);
	el->el_tty.t_tabs = tty__gettabs(&el->el_tty.t_ex);
	el->el_tty.t_eight = tty__geteightbit(&el->el_tty.t_ex);

	tty_setup_flags(el, &el->el_tty.t_ex, EX_IO);

	/*
         * Reset the tty chars to reasonable defaults
         * If they are disabled, then enable them.
         */
	if (rst) {
		if (tty__cooked_mode(&el->el_tty.t_ts)) {
			tty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);
			/*
	                 * Don't affect CMIN and CTIME for the editor mode
	                 */
			for (rst = 0; rst < C_NCC - 2; rst++)
				if (el->el_tty.t_c[TS_IO][rst] !=
				      el->el_tty.t_vdisable
				    && el->el_tty.t_c[ED_IO][rst] !=
				      el->el_tty.t_vdisable)
					el->el_tty.t_c[ED_IO][rst] =
					    el->el_tty.t_c[TS_IO][rst];
			for (rst = 0; rst < C_NCC; rst++)
				if (el->el_tty.t_c[TS_IO][rst] !=
				    el->el_tty.t_vdisable)
					el->el_tty.t_c[EX_IO][rst] =
					    el->el_tty.t_c[TS_IO][rst];
		}
		tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
		if (tty_setty(el, TCSADRAIN, &el->el_tty.t_ex) == -1) {
#ifdef DEBUG_TTY
			(void) fprintf(el->el_errfile,
			    "tty_setup: tty_setty: %s\n",
			    strerror(errno));
#endif /* DEBUG_TTY */
			return -1;
		}
	}

	tty_setup_flags(el, &el->el_tty.t_ed, ED_IO);

	tty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);
	tty_bind_char(el, 1);
	el->el_tty.t_initialized = 1;
	return 0;
}

protected int
tty_init(EditLine *el)
{

	el->el_tty.t_mode = EX_IO;
	el->el_tty.t_vdisable = _POSIX_VDISABLE;
	el->el_tty.t_initialized = 0;
	(void) memcpy(el->el_tty.t_t, ttyperm, sizeof(ttyperm_t));
	(void) memcpy(el->el_tty.t_c, ttychar, sizeof(ttychar_t));
	return tty_setup(el);
}


/* tty_end():
 *	Restore the tty to its original settings
 */
protected void
/*ARGSUSED*/
tty_end(EditLine *el)
{
	if (el->el_flags & EDIT_DISABLED)
		return;

	if (!el->el_tty.t_initialized)
		return;

	if (tty_setty(el, TCSAFLUSH, &el->el_tty.t_or) == -1) {
#ifdef DEBUG_TTY
		(void) fprintf(el->el_errfile,
		    "%s: tty_setty: %s\n", __func__, strerror(errno));
#endif /* DEBUG_TTY */
	}
}


/* tty__getspeed():
 *	Get the tty speed
 */
static speed_t
tty__getspeed(struct termios *td)
{
	speed_t spd;

	if ((spd = cfgetispeed(td)) == 0)
		spd = cfgetospeed(td);
	return spd;
}

/* tty__getspeed():
 *	Return the index of the asked char in the c_cc array
 */
static int
tty__getcharindex(int i)
{
	switch (i) {
#ifdef VINTR
	case C_INTR:
		return VINTR;
#endif /* VINTR */
#ifdef VQUIT
	case C_QUIT:
		return VQUIT;
#endif /* VQUIT */
#ifdef VERASE
	case C_ERASE:
		return VERASE;
#endif /* VERASE */
#ifdef VKILL
	case C_KILL:
		return VKILL;
#endif /* VKILL */
#ifdef VEOF
	case C_EOF:
		return VEOF;
#endif /* VEOF */
#ifdef VEOL
	case C_EOL:
		return VEOL;
#endif /* VEOL */
#ifdef VEOL2
	case C_EOL2:
		return VEOL2;
#endif /* VEOL2 */
#ifdef VSWTCH
	case C_SWTCH:
		return VSWTCH;
#endif /* VSWTCH */
#ifdef VDSWTCH
	case C_DSWTCH:
		return VDSWTCH;
#endif /* VDSWTCH */
#ifdef VERASE2
	case C_ERASE2:
		return VERASE2;
#endif /* VERASE2 */
#ifdef VSTART
	case C_START:
		return VSTART;
#endif /* VSTART */
#ifdef VSTOP
	case C_STOP:
		return VSTOP;
#endif /* VSTOP */
#ifdef VWERASE
	case C_WERASE:
		return VWERASE;
#endif /* VWERASE */
#ifdef VSUSP
	case C_SUSP:
		return VSUSP;
#endif /* VSUSP */
#ifdef VDSUSP
	case C_DSUSP:
		return VDSUSP;
#endif /* VDSUSP */
#ifdef VREPRINT
	case C_REPRINT:
		return VREPRINT;
#endif /* VREPRINT */
#ifdef VDISCARD
	case C_DISCARD:
		return VDISCARD;
#endif /* VDISCARD */
#ifdef VLNEXT
	case C_LNEXT:
		return VLNEXT;
#endif /* VLNEXT */
#ifdef VSTATUS
	case C_STATUS:
		return VSTATUS;
#endif /* VSTATUS */
#ifdef VPAGE
	case C_PAGE:
		return VPAGE;
#endif /* VPAGE */
#ifdef VPGOFF
	case C_PGOFF:
		return VPGOFF;
#endif /* VPGOFF */
#ifdef VKILL2
	case C_KILL2:
		return VKILL2;
#endif /* KILL2 */
#ifdef VMIN
	case C_MIN:
		return VMIN;
#endif /* VMIN */
#ifdef VTIME
	case C_TIME:
		return VTIME;
#endif /* VTIME */
	default:
		return -1;
	}
}

/* tty__getchar():
 *	Get the tty characters
 */
static void
tty__getchar(struct termios *td, unsigned char *s)
{

#ifdef VINTR
	s[C_INTR] = td->c_cc[VINTR];
#endif /* VINTR */
#ifdef VQUIT
	s[C_QUIT] = td->c_cc[VQUIT];
#endif /* VQUIT */
#ifdef VERASE
	s[C_ERASE] = td->c_cc[VERASE];
#endif /* VERASE */
#ifdef VKILL
	s[C_KILL] = td->c_cc[VKILL];
#endif /* VKILL */
#ifdef VEOF
	s[C_EOF] = td->c_cc[VEOF];
#endif /* VEOF */
#ifdef VEOL
	s[C_EOL] = td->c_cc[VEOL];
#endif /* VEOL */
#ifdef VEOL2
	s[C_EOL2] = td->c_cc[VEOL2];
#endif /* VEOL2 */
#ifdef VSWTCH
	s[C_SWTCH] = td->c_cc[VSWTCH];
#endif /* VSWTCH */
#ifdef VDSWTCH
	s[C_DSWTCH] = td->c_cc[VDSWTCH];
#endif /* VDSWTCH */
#ifdef VERASE2
	s[C_ERASE2] = td->c_cc[VERASE2];
#endif /* VERASE2 */
#ifdef VSTART
	s[C_START] = td->c_cc[VSTART];
#endif /* VSTART */
#ifdef VSTOP
	s[C_STOP] = td->c_cc[VSTOP];
#endif /* VSTOP */
#ifdef VWERASE
	s[C_WERASE] = td->c_cc[VWERASE];
#endif /* VWERASE */
#ifdef VSUSP
	s[C_SUSP] = td->c_cc[VSUSP];
#endif /* VSUSP */
#ifdef VDSUSP
	s[C_DSUSP] = td->c_cc[VDSUSP];
#endif /* VDSUSP */
#ifdef VREPRINT
	s[C_REPRINT] = td->c_cc[VREPRINT];
#endif /* VREPRINT */
#ifdef VDISCARD
	s[C_DISCARD] = td->c_cc[VDISCARD];
#endif /* VDISCARD */
#ifdef VLNEXT
	s[C_LNEXT] = td->c_cc[VLNEXT];
#endif /* VLNEXT */
#ifdef VSTATUS
	s[C_STATUS] = td->c_cc[VSTATUS];
#endif /* VSTATUS */
#ifdef VPAGE
	s[C_PAGE] = td->c_cc[VPAGE];
#endif /* VPAGE */
#ifdef VPGOFF
	s[C_PGOFF] = td->c_cc[VPGOFF];
#endif /* VPGOFF */
#ifdef VKILL2
	s[C_KILL2] = td->c_cc[VKILL2];
#endif /* KILL2 */
#ifdef VMIN
	s[C_MIN] = td->c_cc[VMIN];
#endif /* VMIN */
#ifdef VTIME
	s[C_TIME] = td->c_cc[VTIME];
#endif /* VTIME */
}				/* tty__getchar */


/* tty__setchar():
 *	Set the tty characters
 */
static void
tty__setchar(struct termios *td, unsigned char *s)
{

#ifdef VINTR
	td->c_cc[VINTR] = s[C_INTR];
#endif /* VINTR */
#ifdef VQUIT
	td->c_cc[VQUIT] = s[C_QUIT];
#endif /* VQUIT */
#ifdef VERASE
	td->c_cc[VERASE] = s[C_ERASE];
#endif /* VERASE */
#ifdef VKILL
	td->c_cc[VKILL] = s[C_KILL];
#endif /* VKILL */
#ifdef VEOF
	td->c_cc[VEOF] = s[C_EOF];
#endif /* VEOF */
#ifdef VEOL
	td->c_cc[VEOL] = s[C_EOL];
#endif /* VEOL */
#ifdef VEOL2
	td->c_cc[VEOL2] = s[C_EOL2];
#endif /* VEOL2 */
#ifdef VSWTCH
	td->c_cc[VSWTCH] = s[C_SWTCH];
#endif /* VSWTCH */
#ifdef VDSWTCH
	td->c_cc[VDSWTCH] = s[C_DSWTCH];
#endif /* VDSWTCH */
#ifdef VERASE2
	td->c_cc[VERASE2] = s[C_ERASE2];
#endif /* VERASE2 */
#ifdef VSTART
	td->c_cc[VSTART] = s[C_START];
#endif /* VSTART */
#ifdef VSTOP
	td->c_cc[VSTOP] = s[C_STOP];
#endif /* VSTOP */
#ifdef VWERASE
	td->c_cc[VWERASE] = s[C_WERASE];
#endif /* VWERASE */
#ifdef VSUSP
	td->c_cc[VSUSP] = s[C_SUSP];
#endif /* VSUSP */
#ifdef VDSUSP
	td->c_cc[VDSUSP] = s[C_DSUSP];
#endif /* VDSUSP */
#ifdef VREPRINT
	td->c_cc[VREPRINT] = s[C_REPRINT];
#endif /* VREPRINT */
#ifdef VDISCARD
	td->c_cc[VDISCARD] = s[C_DISCARD];
#endif /* VDISCARD */
#ifdef VLNEXT
	td->c_cc[VLNEXT] = s[C_LNEXT];
#endif /* VLNEXT */
#ifdef VSTATUS
	td->c_cc[VSTATUS] = s[C_STATUS];
#endif /* VSTATUS */
#ifdef VPAGE
	td->c_cc[VPAGE] = s[C_PAGE];
#endif /* VPAGE */
#ifdef VPGOFF
	td->c_cc[VPGOFF] = s[C_PGOFF];
#endif /* VPGOFF */
#ifdef VKILL2
	td->c_cc[VKILL2] = s[C_KILL2];
#endif /* VKILL2 */
#ifdef VMIN
	td->c_cc[VMIN] = s[C_MIN];
#endif /* VMIN */
#ifdef VTIME
	td->c_cc[VTIME] = s[C_TIME];
#endif /* VTIME */
}				/* tty__setchar */


/* tty_bind_char():
 *	Rebind the editline functions
 */
protected void
tty_bind_char(EditLine *el, int force)
{

	unsigned char *t_n = el->el_tty.t_c[ED_IO];
	unsigned char *t_o = el->el_tty.t_ed.c_cc;
	wchar_t new[2], old[2];
	const ttymap_t *tp;
	el_action_t *map, *alt;
	const el_action_t *dmap, *dalt;
	new[1] = old[1] = '\0';

	map = el->el_map.key;
	alt = el->el_map.alt;
	if (el->el_map.type == MAP_VI) {
		dmap = el->el_map.vii;
		dalt = el->el_map.vic;
	} else {
		dmap = el->el_map.emacs;
		dalt = NULL;
	}

	for (tp = tty_map; tp->nch != (wint_t)-1; tp++) {
		new[0] = (wchar_t)t_n[tp->nch];
		old[0] = (wchar_t)t_o[tp->och];
		if (new[0] == old[0] && !force)
			continue;
		/* Put the old default binding back, and set the new binding */
		keymacro_clear(el, map, old);
		map[(unsigned char)old[0]] = dmap[(unsigned char)old[0]];
		keymacro_clear(el, map, new);
		/* MAP_VI == 1, MAP_EMACS == 0... */
		map[(unsigned char)new[0]] = tp->bind[el->el_map.type];
		if (dalt) {
			keymacro_clear(el, alt, old);
			alt[(unsigned char)old[0]] =
			    dalt[(unsigned char)old[0]];
			keymacro_clear(el, alt, new);
			alt[(unsigned char)new[0]] =
			    tp->bind[el->el_map.type + 1];
		}
	}
}


static tcflag_t *
tty__get_flag(struct termios *t, int kind) {
	switch (kind) {
	case MD_INP:
		return &t->c_iflag;
	case MD_OUT:
		return &t->c_oflag;
	case MD_CTL:
		return &t->c_cflag;
	case MD_LIN:
		return &t->c_lflag;
	default:
		abort();
		/*NOTREACHED*/
	}
}


static tcflag_t
tty_update_flag(EditLine *el, tcflag_t f, int mode, int kind)
{
	f &= ~el->el_tty.t_t[mode][kind].t_clrmask;
	f |= el->el_tty.t_t[mode][kind].t_setmask;
	return f;
}


static void
tty_update_flags(EditLine *el, int kind)
{
	tcflag_t *tt, *ed, *ex;
	tt = tty__get_flag(&el->el_tty.t_ts, kind);
	ed = tty__get_flag(&el->el_tty.t_ed, kind);
	ex = tty__get_flag(&el->el_tty.t_ex, kind);

	if (*tt != *ex && (kind != MD_CTL || *tt != *ed)) {
		*ed = tty_update_flag(el, *tt, ED_IO, kind);
		*ex = tty_update_flag(el, *tt, EX_IO, kind);
	}
}


static void
tty_update_char(EditLine *el, int mode, int c) {
	if (!((el->el_tty.t_t[mode][MD_CHAR].t_setmask & C_SH(c)))
	    && (el->el_tty.t_c[TS_IO][c] != el->el_tty.t_c[EX_IO][c]))
		el->el_tty.t_c[mode][c] = el->el_tty.t_c[TS_IO][c];
	if (el->el_tty.t_t[mode][MD_CHAR].t_clrmask & C_SH(c))
		el->el_tty.t_c[mode][c] = el->el_tty.t_vdisable;
}


/* tty_rawmode():
 *	Set terminal into 1 character at a time mode.
 */
protected int
tty_rawmode(EditLine *el)
{

	if (el->el_tty.t_mode == ED_IO || el->el_tty.t_mode == QU_IO)
		return 0;

	if (el->el_flags & EDIT_DISABLED)
		return 0;

	if (tty_getty(el, &el->el_tty.t_ts) == -1) {
#ifdef DEBUG_TTY
		(void) fprintf(el->el_errfile, "tty_rawmode: tty_getty: %s\n",
		    strerror(errno));
#endif /* DEBUG_TTY */
		return -1;
	}
	/*
         * We always keep up with the eight bit setting and the speed of the
         * tty. But we only believe changes that are made to cooked mode!
         */
	el->el_tty.t_eight = tty__geteightbit(&el->el_tty.t_ts);
	el->el_tty.t_speed = tty__getspeed(&el->el_tty.t_ts);

	if (tty__getspeed(&el->el_tty.t_ex) != el->el_tty.t_speed ||
	    tty__getspeed(&el->el_tty.t_ed) != el->el_tty.t_speed) {
		(void) cfsetispeed(&el->el_tty.t_ex, el->el_tty.t_speed);
		(void) cfsetospeed(&el->el_tty.t_ex, el->el_tty.t_speed);
		(void) cfsetispeed(&el->el_tty.t_ed, el->el_tty.t_speed);
		(void) cfsetospeed(&el->el_tty.t_ed, el->el_tty.t_speed);
	}
	if (tty__cooked_mode(&el->el_tty.t_ts)) {
		int i;

		for (i = MD_INP; i <= MD_LIN; i++)
			tty_update_flags(el, i);

		if (tty__gettabs(&el->el_tty.t_ex) == 0)
			el->el_tty.t_tabs = 0;
		else
			el->el_tty.t_tabs = EL_CAN_TAB ? 1 : 0;

		tty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);
		/*
		 * Check if the user made any changes.
		 * If he did, then propagate the changes to the
		 * edit and execute data structures.
		 */
		for (i = 0; i < C_NCC; i++)
			if (el->el_tty.t_c[TS_IO][i] !=
			    el->el_tty.t_c[EX_IO][i])
				break;

		if (i != C_NCC) {
			/*
			 * Propagate changes only to the unprotected
			 * chars that have been modified just now.
			 */
			for (i = 0; i < C_NCC; i++)
				tty_update_char(el, ED_IO, i);

			tty_bind_char(el, 0);
			tty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);

			for (i = 0; i < C_NCC; i++)
				tty_update_char(el, EX_IO, i);

			tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
		}
	}
	if (tty_setty(el, TCSADRAIN, &el->el_tty.t_ed) == -1) {
#ifdef DEBUG_TTY
		(void) fprintf(el->el_errfile, "tty_rawmode: tty_setty: %s\n",
		    strerror(errno));
#endif /* DEBUG_TTY */
		return -1;
	}
	el->el_tty.t_mode = ED_IO;
	return 0;
}


/* tty_cookedmode():
 *	Set the tty back to normal mode
 */
protected int
tty_cookedmode(EditLine *el)
{				/* set tty in normal setup */

	if (el->el_tty.t_mode == EX_IO)
		return 0;

	if (el->el_flags & EDIT_DISABLED)
		return 0;

	if (tty_setty(el, TCSADRAIN, &el->el_tty.t_ex) == -1) {
#ifdef DEBUG_TTY
		(void) fprintf(el->el_errfile,
		    "tty_cookedmode: tty_setty: %s\n",
		    strerror(errno));
#endif /* DEBUG_TTY */
		return -1;
	}
	el->el_tty.t_mode = EX_IO;
	return 0;
}


/* tty_quotemode():
 *	Turn on quote mode
 */
protected int
tty_quotemode(EditLine *el)
{
	if (el->el_tty.t_mode == QU_IO)
		return 0;

	el->el_tty.t_qu = el->el_tty.t_ed;

	tty_setup_flags(el, &el->el_tty.t_qu, QU_IO);

	if (tty_setty(el, TCSADRAIN, &el->el_tty.t_qu) == -1) {
#ifdef DEBUG_TTY
		(void) fprintf(el->el_errfile, "QuoteModeOn: tty_setty: %s\n",
		    strerror(errno));
#endif /* DEBUG_TTY */
		return -1;
	}
	el->el_tty.t_mode = QU_IO;
	return 0;
}


/* tty_noquotemode():
 *	Turn off quote mode
 */
protected int
tty_noquotemode(EditLine *el)
{

	if (el->el_tty.t_mode != QU_IO)
		return 0;
	if (tty_setty(el, TCSADRAIN, &el->el_tty.t_ed) == -1) {
#ifdef DEBUG_TTY
		(void) fprintf(el->el_errfile, "QuoteModeOff: tty_setty: %s\n",
		    strerror(errno));
#endif /* DEBUG_TTY */
		return -1;
	}
	el->el_tty.t_mode = ED_IO;
	return 0;
}


/* tty_stty():
 *	Stty builtin
 */
protected int
/*ARGSUSED*/
tty_stty(EditLine *el, int argc __attribute__((__unused__)),
    const wchar_t **argv)
{
	const ttymodes_t *m;
	char x;
	int aflag = 0;
	const wchar_t *s, *d;
        char name[EL_BUFSIZ];
	struct termios *tios = &el->el_tty.t_ex;
	int z = EX_IO;

	if (argv == NULL)
		return -1;
	strncpy(name, ct_encode_string(*argv++, &el->el_scratch), sizeof(name));
        name[sizeof(name) - 1] = '\0';

	while (argv && *argv && argv[0][0] == '-' && argv[0][2] == '\0')
		switch (argv[0][1]) {
		case 'a':
			aflag++;
			argv++;
			break;
		case 'd':
			argv++;
			tios = &el->el_tty.t_ed;
			z = ED_IO;
			break;
		case 'x':
			argv++;
			tios = &el->el_tty.t_ex;
			z = EX_IO;
			break;
		case 'q':
			argv++;
			tios = &el->el_tty.t_ts;
			z = QU_IO;
			break;
		default:
			(void) fprintf(el->el_errfile,
			    "%s: Unknown switch `%lc'.\n",
			    name, argv[0][1]);
			return -1;
		}

	if (!argv || !*argv) {
		int i = -1;
		size_t len = 0, st = 0, cu;
		for (m = ttymodes; m->m_name; m++) {
			if (m->m_type != i) {
				(void) fprintf(el->el_outfile, "%s%s",
				    i != -1 ? "\n" : "",
				    el->el_tty.t_t[z][m->m_type].t_name);
				i = m->m_type;
				st = len =
				    strlen(el->el_tty.t_t[z][m->m_type].t_name);
			}
			if (i != -1) {
			    x = (el->el_tty.t_t[z][i].t_setmask & m->m_value)
				?  '+' : '\0';
			    x = (el->el_tty.t_t[z][i].t_clrmask & m->m_value)
				? '-' : x;
			} else {
			    x = '\0';
			}

			if (x != '\0' || aflag) {

				cu = strlen(m->m_name) + (x != '\0') + 1;

				if (len + cu >=
				    (size_t)el->el_terminal.t_size.h) {
					(void) fprintf(el->el_outfile, "\n%*s",
					    (int)st, "");
					len = st + cu;
				} else
					len += cu;

				if (x != '\0')
					(void) fprintf(el->el_outfile, "%c%s ",
					    x, m->m_name);
				else
					(void) fprintf(el->el_outfile, "%s ",
					    m->m_name);
			}
		}
		(void) fprintf(el->el_outfile, "\n");
		return 0;
	}
	while (argv && (s = *argv++)) {
		const wchar_t *p;
		switch (*s) {
		case '+':
		case '-':
			x = *s++;
			break;
		default:
			x = '\0';
			break;
		}
		d = s;
		p = wcschr(s, L'=');
		for (m = ttymodes; m->m_name; m++)
			if ((p ? strncmp(m->m_name, ct_encode_string(d, &el->el_scratch), (size_t)(p - d)) :
			    strcmp(m->m_name, ct_encode_string(d, &el->el_scratch))) == 0 &&
			    (p == NULL || m->m_type == MD_CHAR))
				break;

		if (!m->m_name) {
			(void) fprintf(el->el_errfile,
			    "%s: Invalid argument `%ls'.\n", name, d);
			return -1;
		}
		if (p) {
			int c = ffs((int)m->m_value);
			int v = *++p ? parse__escape(&p) :
			    el->el_tty.t_vdisable;
			assert(c != 0);
			c--;
			c = tty__getcharindex(c);
			assert(c != -1);
			tios->c_cc[c] = v;
			continue;
		}
		switch (x) {
		case '+':
			el->el_tty.t_t[z][m->m_type].t_setmask |= m->m_value;
			el->el_tty.t_t[z][m->m_type].t_clrmask &= ~m->m_value;
			break;
		case '-':
			el->el_tty.t_t[z][m->m_type].t_setmask &= ~m->m_value;
			el->el_tty.t_t[z][m->m_type].t_clrmask |= m->m_value;
			break;
		default:
			el->el_tty.t_t[z][m->m_type].t_setmask &= ~m->m_value;
			el->el_tty.t_t[z][m->m_type].t_clrmask &= ~m->m_value;
			break;
		}
	}

	tty_setup_flags(el, tios, z);
	if (el->el_tty.t_mode == z) {
		if (tty_setty(el, TCSADRAIN, tios) == -1) {
#ifdef DEBUG_TTY
			(void) fprintf(el->el_errfile,
			    "tty_stty: tty_setty: %s\n", strerror(errno));
#endif /* DEBUG_TTY */
			return -1;
		}
	}

	return 0;
}


#ifdef notyet
/* tty_printchar():
 *	DEbugging routine to print the tty characters
 */
static void
tty_printchar(EditLine *el, unsigned char *s)
{
	ttyperm_t *m;
	int i;

	for (i = 0; i < C_NCC; i++) {
		for (m = el->el_tty.t_t; m->m_name; m++)
			if (m->m_type == MD_CHAR && C_SH(i) == m->m_value)
				break;
		if (m->m_name)
			(void) fprintf(el->el_errfile, "%s ^%c ",
			    m->m_name, s[i] + 'A' - 1);
		if (i % 5 == 0)
			(void) fprintf(el->el_errfile, "\n");
	}
	(void) fprintf(el->el_errfile, "\n");
}
#endif /* notyet */


static void
tty_setup_flags(EditLine *el, struct termios *tios, int mode)
{
	int kind;
	for (kind = MD_INP; kind <= MD_LIN; kind++) {
		tcflag_t *f = tty__get_flag(tios, kind);
		*f = tty_update_flag(el, *f, mode, kind);
	}
}
@


1.26
log
@delete the "private" and "public" preprocessor macros, just use standard C;
OK martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.25 2016/04/11 20:43:33 schwarze Exp $	*/
d49 1
@


1.25
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.24 2016/04/11 19:54:54 schwarze Exp $	*/
d63 1
a63 1
private const ttyperm_t ttyperm = {
d91 1
a91 1
private const ttychar_t ttychar = {
d121 1
a121 1
private const ttymap_t tty_map[] = {
d158 1
a158 1
private const ttymodes_t ttymodes[] = {
d452 8
a459 8
private int	tty_getty(EditLine *, struct termios *);
private int	tty_setty(EditLine *, int, const struct termios *);
private int	tty__getcharindex(int);
private void	tty__getchar(struct termios *, unsigned char *);
private void	tty__setchar(struct termios *, unsigned char *);
private speed_t	tty__getspeed(struct termios *);
private int	tty_setup(EditLine *);
private void	tty_setup_flags(EditLine *, struct termios *, int);
d466 1
a466 1
private int
d478 1
a478 1
private int
d490 1
a490 1
private int
d603 1
a603 1
private speed_t
d616 1
a616 1
private int
d724 1
a724 1
private void
d806 1
a806 1
private void
d933 1
a933 1
private tcflag_t *
d951 1
a951 1
private tcflag_t
d960 1
a960 1
private void
d975 1
a975 1
private void
d1305 1
a1305 1
private void
d1326 1
a1326 1
private void
@


1.24
log
@Move wrapper macros to the two files actually needing them:
FUNW, Strlen, Strdup, Strcmp, Strncmp, Strncpy, Strncat -> history.c
Strchr, tok_strdup -> tokenizer.c
FUN, TYPE, STR -> both of these files

OK martijn@@

Also proofread by Christian Heckendorf <mbie at ulmus dot me>
who reported some whitespace issues in parse.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.23 2016/04/09 20:15:26 schwarze Exp $	*/
d894 1
a894 1
	Char new[2], old[2];
d911 2
a912 2
		new[0] = t_n[tp->nch];
		old[0] = t_o[tp->och];
d1147 2
a1148 1
tty_stty(EditLine *el, int argc __attribute__((__unused__)), const Char **argv)
d1153 1
a1153 1
	const Char *s, *d;
d1236 1
a1236 1
		const Char *p;
@


1.23
log
@Delete 26 wrapper macros and two wrapper functions that are no
longer needed now that we always compile with wide character support,
reducing code obfuscation.

OK czarkoff@@ martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.22 2016/04/09 18:42:49 schwarze Exp $	*/
d1246 1
a1246 1
		p = Strchr(s, '=');
@


1.22
log
@Reset the terminal to its initial state before exiting a program
using libedit, using code from NetBSD tty.c rev. 1.42, 1.48, 1.49,
1.58, and 1.59.  Code mostly by Christos Zoulas, one bug report by
John Hein, one additional bugfix by me (rev. 1.59).
While here, switch t_mode to unsigned char, which is sufficient,
also from NetBSD.

OK martijn@@.
Also checked by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.21 2016/03/20 23:48:27 schwarze Exp $	*/
d917 1
a917 1
		map[UC(old[0])] = dmap[UC(old[0])];
d920 1
a920 1
		map[UC(new[0])] = tp->bind[el->el_map.type];
d923 2
a924 1
			alt[UC(old[0])] = dalt[UC(old[0])];
d926 2
a927 1
			alt[UC(new[0])] = tp->bind[el->el_map.type + 1];
d1255 1
a1255 1
			    "%s: Invalid argument `" FSTR "'.\n", name, d);
@


1.21
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.20 2016/03/20 22:57:59 schwarze Exp $	*/
d498 3
d508 1
a508 1
	if (tty_getty(el, &el->el_tty.t_ed) == -1) {
d515 1
a515 1
	el->el_tty.t_ts = el->el_tty.t_ex = el->el_tty.t_ed;
d561 1
d571 1
d583 1
a583 1
tty_end(EditLine *el __attribute__((__unused__)))
d585 5
d591 6
a596 1
	/* XXX: Maybe reset to an initial state? */
@


1.20
log
@Cleanup of private header inclusion:

1. Do not include private headers from "chared.h", "hist.h", "prompt.h",
"refresh.h", "search.h", "sig.h", "terminal.h", "tty.h".
The only private header having to include other private headers is "el.h".
2. Do not include "common.h", "parse.h", "help.h" from "el.h",
and do not include "emacs.h" and "vi.h" from "chared.h",
include them directly where needed.
3. Do include "fcns.h" from "el.h" because el_func_t is needed for "map.h".
4. Do not include private headers again that are already included by "el.h".
5. Include private headers after standard headers.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.19 2016/03/20 20:35:38 schwarze Exp $	*/
d43 3
a46 1
#include <strings.h>	/* for ffs */
d969 1
a969 1
 * 	Set terminal into 1 character at a time mode.
@


1.19
log
@Delete the useless Int datatype and always use the standard wint_t
directly.  This is not a problem because <wchar_t> is required all
over the place anyway, even when WIDECHAR is not defined.
No functional change except that it fixes a few printf(3)
format string issues, %c vs. %lc.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.18 2016/01/30 12:22:20 schwarze Exp $	*/
d45 1
d47 1
a47 1
#include "tty.h"
@


1.18
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.17 2016/01/30 02:52:41 schwarze Exp $	*/
d55 1
a55 1
	Int nch, och;		/* Internal and termio rep of chars */
d151 1
a151 1
	{-1, -1,
d892 1
a892 1
	for (tp = tty_map; tp->nch != -1; tp++) {
d1165 1
a1165 1
			    "%s: Unknown switch `%c'.\n",
@


1.17
log
@delete "#ifdef notdef" code that is no longer present in NetBSD;
no change in the generated source files
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.16 2016/01/30 00:06:39 schwarze Exp $	*/
d493 1
a493 1
		return (0);
d500 1
a500 1
		return (-1);
d507 1
a507 1
		return (-1);
d547 1
a547 1
			return (-1);
d555 1
a555 1
	return (0);
d566 1
a566 1
	return (tty_setup(el));
d592 1
a592 1
	return (spd);
d973 1
a973 1
		return (0);
d976 1
a976 1
		return (0);
d983 1
a983 1
		return (-1);
d1043 1
a1043 1
		return (-1);
d1046 1
a1046 1
	return (0);
d1058 1
a1058 1
		return (0);
d1061 1
a1061 1
		return (0);
d1069 1
a1069 1
		return (-1);
d1072 1
a1072 1
	return (0);
d1083 1
a1083 1
		return (0);
d1094 1
a1094 1
		return (-1);
d1097 1
a1097 1
	return (0);
d1109 1
a1109 1
		return (0);
d1115 1
a1115 1
		return (-1);
d1118 1
a1118 1
	return (0);
d1138 1
a1138 1
		return (-1);
d1167 1
a1167 1
			return (-1);
d1212 1
a1212 1
		return (0);
d1236 1
a1236 1
			return (-1);
d1272 1
a1272 1
			return (-1);
d1276 1
a1276 1
	return (0);
@


1.16
log
@Third step in synching with NetBSD:
* rename fkey_t to funckey_t and el_term_t to el_terminal_t
* rename struct editline member el_term to el_terminal
* rename many functions in terminal.c from term_*() to terminal_*(),
for consistency with the file name and to not look related to <term.h>
No functional change.
This makes refresh.c and sig.c almost identical to the NetBSD versions.
It reduces the remaining diff from +2446 -1805 to +2053 -1420.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.15 2016/01/29 19:32:34 schwarze Exp $	*/
a549 4
#ifdef notdef
	else
		tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
#endif
@


1.15
log
@Second step in synching with NetBSD:
* Rename some types from *key*_t to *keymacro*_t.
* Rename struct editline member el_key to el_keymacro.
* Rename some functions in keymacro.c from key*() to keymacro*().
This removes the conflict of key_clear(), key_end(), and key_print()
with macros in <term.h>.  No functional change.
This makes keymacro.h identical to the NetBSD version.
It reduces the remaining diff from +2640 -1998 to +2446 -1805.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.14 2014/05/20 22:28:07 yasuoka Exp $	*/
d1199 2
a1200 1
				if (len + cu >= (size_t)el->el_term.t_size.h) {
@


1.14
log
@Merge the fixes from the upstream.  Factor out some common code in
tty.c and fix EL_SETTY to work.

ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.13 2011/07/07 05:40:42 okan Exp $	*/
d902 1
a902 1
		key_clear(el, map, old);
d904 1
a904 1
		key_clear(el, map, new);
d908 1
a908 1
			key_clear(el, alt, old);
d910 1
a910 1
			key_clear(el, alt, new);
@


1.13
log
@sync with upstream, retaining local modifications.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.12 2010/06/30 00:05:35 nicm Exp $	*/
d456 1
d515 1
a515 11
	el->el_tty.t_ex.c_iflag &= ~el->el_tty.t_t[EX_IO][MD_INP].t_clrmask;
	el->el_tty.t_ex.c_iflag |= el->el_tty.t_t[EX_IO][MD_INP].t_setmask;

	el->el_tty.t_ex.c_oflag &= ~el->el_tty.t_t[EX_IO][MD_OUT].t_clrmask;
	el->el_tty.t_ex.c_oflag |= el->el_tty.t_t[EX_IO][MD_OUT].t_setmask;

	el->el_tty.t_ex.c_cflag &= ~el->el_tty.t_t[EX_IO][MD_CTL].t_clrmask;
	el->el_tty.t_ex.c_cflag |= el->el_tty.t_t[EX_IO][MD_CTL].t_setmask;

	el->el_tty.t_ex.c_lflag &= ~el->el_tty.t_t[EX_IO][MD_LIN].t_clrmask;
	el->el_tty.t_ex.c_lflag |= el->el_tty.t_t[EX_IO][MD_LIN].t_setmask;
d555 1
a555 11
	el->el_tty.t_ed.c_iflag &= ~el->el_tty.t_t[ED_IO][MD_INP].t_clrmask;
	el->el_tty.t_ed.c_iflag |= el->el_tty.t_t[ED_IO][MD_INP].t_setmask;

	el->el_tty.t_ed.c_oflag &= ~el->el_tty.t_t[ED_IO][MD_OUT].t_clrmask;
	el->el_tty.t_ed.c_oflag |= el->el_tty.t_t[ED_IO][MD_OUT].t_setmask;

	el->el_tty.t_ed.c_cflag &= ~el->el_tty.t_t[ED_IO][MD_CTL].t_clrmask;
	el->el_tty.t_ed.c_cflag |= el->el_tty.t_t[ED_IO][MD_CTL].t_setmask;

	el->el_tty.t_ed.c_lflag &= ~el->el_tty.t_t[ED_IO][MD_LIN].t_clrmask;
	el->el_tty.t_ed.c_lflag |= el->el_tty.t_t[ED_IO][MD_LIN].t_setmask;
d917 52
d1004 5
a1008 63
		if (el->el_tty.t_ts.c_cflag != el->el_tty.t_ex.c_cflag) {
			el->el_tty.t_ex.c_cflag =
			    el->el_tty.t_ts.c_cflag;
			el->el_tty.t_ex.c_cflag &=
			    ~el->el_tty.t_t[EX_IO][MD_CTL].t_clrmask;
			el->el_tty.t_ex.c_cflag |=
			    el->el_tty.t_t[EX_IO][MD_CTL].t_setmask;

			el->el_tty.t_ed.c_cflag =
			    el->el_tty.t_ts.c_cflag;
			el->el_tty.t_ed.c_cflag &=
			    ~el->el_tty.t_t[ED_IO][MD_CTL].t_clrmask;
			el->el_tty.t_ed.c_cflag |=
			    el->el_tty.t_t[ED_IO][MD_CTL].t_setmask;
		}
		if ((el->el_tty.t_ts.c_lflag != el->el_tty.t_ex.c_lflag) &&
		    (el->el_tty.t_ts.c_lflag != el->el_tty.t_ed.c_lflag)) {
			el->el_tty.t_ex.c_lflag =
			    el->el_tty.t_ts.c_lflag;
			el->el_tty.t_ex.c_lflag &=
			    ~el->el_tty.t_t[EX_IO][MD_LIN].t_clrmask;
			el->el_tty.t_ex.c_lflag |=
			    el->el_tty.t_t[EX_IO][MD_LIN].t_setmask;

			el->el_tty.t_ed.c_lflag =
			    el->el_tty.t_ts.c_lflag;
			el->el_tty.t_ed.c_lflag &=
			    ~el->el_tty.t_t[ED_IO][MD_LIN].t_clrmask;
			el->el_tty.t_ed.c_lflag |=
			    el->el_tty.t_t[ED_IO][MD_LIN].t_setmask;
		}
		if ((el->el_tty.t_ts.c_iflag != el->el_tty.t_ex.c_iflag) &&
		    (el->el_tty.t_ts.c_iflag != el->el_tty.t_ed.c_iflag)) {
			el->el_tty.t_ex.c_iflag =
			    el->el_tty.t_ts.c_iflag;
			el->el_tty.t_ex.c_iflag &=
			    ~el->el_tty.t_t[EX_IO][MD_INP].t_clrmask;
			el->el_tty.t_ex.c_iflag |=
			    el->el_tty.t_t[EX_IO][MD_INP].t_setmask;

			el->el_tty.t_ed.c_iflag =
			    el->el_tty.t_ts.c_iflag;
			el->el_tty.t_ed.c_iflag &=
			    ~el->el_tty.t_t[ED_IO][MD_INP].t_clrmask;
			el->el_tty.t_ed.c_iflag |=
			    el->el_tty.t_t[ED_IO][MD_INP].t_setmask;
		}
		if ((el->el_tty.t_ts.c_oflag != el->el_tty.t_ex.c_oflag) &&
		    (el->el_tty.t_ts.c_oflag != el->el_tty.t_ed.c_oflag)) {
			el->el_tty.t_ex.c_oflag =
			    el->el_tty.t_ts.c_oflag;
			el->el_tty.t_ex.c_oflag &=
			    ~el->el_tty.t_t[EX_IO][MD_OUT].t_clrmask;
			el->el_tty.t_ex.c_oflag |=
			    el->el_tty.t_t[EX_IO][MD_OUT].t_setmask;

			el->el_tty.t_ed.c_oflag =
			    el->el_tty.t_ts.c_oflag;
			el->el_tty.t_ed.c_oflag &=
			    ~el->el_tty.t_t[ED_IO][MD_OUT].t_clrmask;
			el->el_tty.t_ed.c_oflag |=
			    el->el_tty.t_t[ED_IO][MD_OUT].t_setmask;
		}
d1014 10
a1023 2
		{
			int i;
d1025 1
a1025 1
			tty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);
d1027 9
a1035 4
		         * Check if the user made any changes.
		         * If he did, then propagate the changes to the
		         * edit and execute data structures.
		         */
d1037 3
a1039 28
				if (el->el_tty.t_c[TS_IO][i] !=
				    el->el_tty.t_c[EX_IO][i])
					break;

			if (i != C_NCC) {
				/*
				 * Propagate changes only to the unprotected
				 * chars that have been modified just now.
				 */
				for (i = 0; i < C_NCC; i++) {
					if (!((el->el_tty.t_t[ED_IO][MD_CHAR].t_setmask & C_SH(i)))
					    && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))
						el->el_tty.t_c[ED_IO][i] = el->el_tty.t_c[TS_IO][i];
					if (el->el_tty.t_t[ED_IO][MD_CHAR].t_clrmask & C_SH(i))
						el->el_tty.t_c[ED_IO][i] = el->el_tty.t_vdisable;
				}
				tty_bind_char(el, 0);
				tty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);

				for (i = 0; i < C_NCC; i++) {
					if (!((el->el_tty.t_t[EX_IO][MD_CHAR].t_setmask & C_SH(i)))
					    && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))
						el->el_tty.t_c[EX_IO][i] = el->el_tty.t_c[TS_IO][i];
					if (el->el_tty.t_t[EX_IO][MD_CHAR].t_clrmask & C_SH(i))
						el->el_tty.t_c[EX_IO][i] = el->el_tty.t_vdisable;
				}
				tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
			}
d1091 1
a1091 11
	el->el_tty.t_qu.c_iflag &= ~el->el_tty.t_t[QU_IO][MD_INP].t_clrmask;
	el->el_tty.t_qu.c_iflag |= el->el_tty.t_t[QU_IO][MD_INP].t_setmask;

	el->el_tty.t_qu.c_oflag &= ~el->el_tty.t_t[QU_IO][MD_OUT].t_clrmask;
	el->el_tty.t_qu.c_oflag |= el->el_tty.t_t[QU_IO][MD_OUT].t_setmask;

	el->el_tty.t_qu.c_cflag &= ~el->el_tty.t_t[QU_IO][MD_CTL].t_clrmask;
	el->el_tty.t_qu.c_cflag |= el->el_tty.t_t[QU_IO][MD_CTL].t_setmask;

	el->el_tty.t_qu.c_lflag &= ~el->el_tty.t_t[QU_IO][MD_LIN].t_clrmask;
	el->el_tty.t_qu.c_lflag |= el->el_tty.t_t[QU_IO][MD_LIN].t_setmask;
d1268 1
d1306 11
@


1.12
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tty.c,v 1.33 2010/04/18 21:17:22 christos Exp $	*/
d43 1
d494 7
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
a2 2
/*	$OpenBSD: tty.c,v 1.10 2003/11/25 20:12:38 otto Exp $	*/
/*	$NetBSD: tty.c,v 1.20 2003/10/18 22:37:24 christos Exp $	*/
d41 4
a45 1
#include "el.h"
d49 1
a49 1
	u_int m_value;
d54 1
a54 1
	int nch, och;		/* Internal and termio rep of chars */
d120 1
a120 1
	{ED_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR}},
d124 1
a124 1
	{ED_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR}},
a443 3
#define	tty_getty(el, td)	tcgetattr((el)->el_infd, (td))
#define	tty_setty(el, td)	tcsetattr((el)->el_infd, TCSADRAIN, (td))

d448 2
d458 23
d542 1
a542 1
		if (tty_setty(el, &el->el_tty.t_ex) == -1) {
d550 3
a552 1
	} else
d554 1
d891 1
a891 1
	unsigned char new[2], old[2];
d913 3
a915 3
		key_clear(el, map, (char *)old);
		map[old[0]] = dmap[old[0]];
		key_clear(el, map, (char *)new);
d917 1
a917 1
		map[new[0]] = tp->bind[el->el_map.type];
d919 4
a922 4
			key_clear(el, alt, (char *)old);
			alt[old[0]] = dalt[old[0]];
			key_clear(el, alt, (char *)new);
			alt[new[0]] = tp->bind[el->el_map.type + 1];
d950 1
a950 1
         * tty. But only we only believe changes that are made to cooked mode!
d1071 1
a1071 1
	if (tty_setty(el, &el->el_tty.t_ed) == -1) {
d1096 1
a1096 1
	if (tty_setty(el, &el->el_tty.t_ex) == -1) {
d1132 1
a1132 1
	if (tty_setty(el, &el->el_tty.t_qu) == -1) {
d1153 1
a1153 1
	if (tty_setty(el, &el->el_tty.t_ed) == -1) {
d1170 1
a1170 1
tty_stty(EditLine *el, int argc __attribute__((__unused__)), const char **argv)
d1175 2
a1176 2
	const char *s, *d;
	const char *name;
d1182 2
a1183 1
	name = *argv++;
d1215 1
a1215 1
		int len = 0, st = 0, cu;
d1225 8
a1232 4
			x = (el->el_tty.t_t[z][i].t_setmask & m->m_value)
			    ?  '+' : '\0';
			x = (el->el_tty.t_t[z][i].t_clrmask & m->m_value)
			    ? '-' : x;
d1238 1
a1238 1
				if (len + cu >= el->el_term.t_size.h) {
d1240 1
a1240 1
					    st, "");
d1257 1
a1257 1
		char *p;
d1268 1
a1268 2
		if ((p = strchr(s, '=')) != NULL)
			*p++ = '\0';
d1270 2
a1271 1
			if (strcmp(m->m_name, d) == 0 &&
d1277 1
a1277 1
			    "%s: Invalid argument `%s'.\n", name, d);
d1282 1
a1282 1
			int v = *p ? parse__escape((const char **const) &p) :
d1284 1
d1287 1
d1306 11
@


1.10
log
@Sync libedit to NetBSD libedit as of Nov 8, 2003.
Tested by jmc@@ djm@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.9 2003/10/31 08:42:24 otto Exp $	*/
a36 7
#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)tty.c	8.1 (Berkeley) 6/4/93";
#else
static const char rcsid[] = "$OpenBSD: tty.c,v 1.9 2003/10/31 08:42:24 otto Exp $";
#endif
#endif /* not lint && not SCCSID */
@


1.9
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tty.c,v 1.18 2003/08/07 16:44:34 agc Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD$";
d455 1
d589 107
d1156 1
d1171 1
d1176 1
d1181 1
d1231 1
d1242 2
d1245 2
a1246 1
			if (strcmp(m->m_name, d) == 0)
d1253 9
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: tty.c,v 1.7 2003/05/01 21:11:21 avsm Exp $	*/
/*	$NetBSD: tty.c,v 1.3 1997/04/11 17:52:49 christos Exp $	*/
d36 1
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: tty.c,v 1.7 2003/05/01 21:11:21 avsm Exp $";
d45 1
a45 1
/* 
a47 1
#include "sys.h"
d52 4
a55 4
    char *m_name;
    u_int m_value;
    int   m_type;
} ttymodes_t;
d58 2
a59 2
    int nch, och;		 /* Internal and termio rep of chars */
    el_action_t bind[3]; 	/* emacs, vi, and vi-cmd */
d63 26
a88 26
private ttyperm_t ttyperm = {   
    {
	{ "iflag:", ICRNL, (INLCR|IGNCR) },
	{ "oflag:", (OPOST|ONLCR), ONLRET },
	{ "cflag:", 0, 0 },
	{ "lflag:", (ISIG|ICANON|ECHO|ECHOE|ECHOCTL|IEXTEN),
		    (NOFLSH|ECHONL|EXTPROC|FLUSHO) },
	{ "chars:", 	0, 0 },
    },
    {
	{ "iflag:", (INLCR|ICRNL), IGNCR },
	{ "oflag:", (OPOST|ONLCR), ONLRET },
	{ "cflag:", 0, 0 },
	{ "lflag:", ISIG,
		    (NOFLSH|ICANON|ECHO|ECHOK|ECHONL|EXTPROC|IEXTEN|FLUSHO) },
	{ "chars:", (C_SH(C_MIN)|C_SH(C_TIME)|C_SH(C_SWTCH)|C_SH(C_DSWTCH)|
		     C_SH(C_SUSP)|C_SH(C_DSUSP)|C_SH(C_EOL)|C_SH(C_DISCARD)|
		     C_SH(C_PGOFF)|C_SH(C_PAGE)|C_SH(C_STATUS)), 0 }
    },
    {
	{ "iflag:", 0, IXON | IXOFF },
	{ "oflag:", 0, 0 },
	{ "cflag:", 0, 0 },
	{ "lflag:", 0, ISIG | IEXTEN },
	{ "chars:", 0, 0 },
    }
d91 28
a118 28
private ttychar_t ttychar = {
    {
	CINTR,		 CQUIT, 	 CERASE, 	   CKILL,	
	CEOF, 		 CEOL, 		 CEOL2, 	   CSWTCH, 
	CDSWTCH,	 CERASE2,	 CSTART, 	   CSTOP,
	CWERASE, 	 CSUSP, 	 CDSUSP, 	   CREPRINT,
	CDISCARD, 	 CLNEXT,	 CSTATUS,	   CPAGE,
	CPGOFF,		 CKILL2, 	 CBRK, 		   CMIN,
	CTIME
    },
    {
	CINTR, 		 CQUIT, 	  CERASE, 	   CKILL, 
	_POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, 
	_POSIX_VDISABLE, CERASE2,	  CSTART, 	   CSTOP, 	   
	_POSIX_VDISABLE, CSUSP,           _POSIX_VDISABLE, _POSIX_VDISABLE, 
	CDISCARD, 	 _POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, 
	_POSIX_VDISABLE, _POSIX_VDISABLE, _POSIX_VDISABLE, 1,
	0
    },
    {	
	0,		 0,		  0,		   0,
	0,		 0,		  0,		   0,
	0,		 0,		  0,		   0,
	0,		 0,		  0,		   0,
	0,		 0,		  0,		   0,
	0,		 0,		  0,		   0,
	0
    }
d121 1
a121 1
private ttymap_t tty_map[] = {
d123 2
a124 2
	{ C_ERASE,   VERASE,	
	    { ED_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR } },
d127 2
a128 2
	{ C_ERASE2,  VERASE2,	
	    { ED_DELETE_PREV_CHAR, VI_DELETE_PREV_CHAR, ED_PREV_CHAR } },
d131 2
a132 2
    	{ C_KILL,    VKILL,	
	    { EM_KILL_LINE, VI_KILL_LINE_PREV, ED_UNASSIGNED } },
d135 2
a136 2
    	{ C_KILL2,   VKILL2,	
	    { EM_KILL_LINE, VI_KILL_LINE_PREV, ED_UNASSIGNED } },
d139 2
a140 2
    	{ C_EOF,     VEOF,	
	    { EM_DELETE_OR_LIST, VI_LIST_OR_EOF, ED_UNASSIGNED } },
d143 2
a144 2
    	{ C_WERASE,  VWERASE,	
	    { ED_DELETE_PREV_WORD, ED_DELETE_PREV_WORD, ED_PREV_WORD } },
d147 2
a148 2
   	{ C_REPRINT, VREPRINT,	
	    { ED_REDISPLAY, ED_INSERT, ED_REDISPLAY } },
d151 2
a152 2
    	{ C_LNEXT,   VLNEXT,	
	    { ED_QUOTED_INSERT, ED_QUOTED_INSERT, ED_UNASSIGNED } },
d154 2
a155 287
	{ -1,	     -1,	
	    { ED_UNASSIGNED, ED_UNASSIGNED, ED_UNASSIGNED } }
    };

private ttymodes_t ttymodes[] = {
# ifdef	IGNBRK
    { "ignbrk",	IGNBRK,	M_INP },
# endif /* IGNBRK */
# ifdef	BRKINT
    { "brkint",	BRKINT,	M_INP },
# endif /* BRKINT */
# ifdef	IGNPAR
    { "ignpar",	IGNPAR,	M_INP },
# endif /* IGNPAR */
# ifdef	PARMRK
    { "parmrk",	PARMRK,	M_INP },
# endif /* PARMRK */
# ifdef	INPCK
    { "inpck",	INPCK,	M_INP },
# endif /* INPCK */
# ifdef	ISTRIP
    { "istrip",	ISTRIP,	M_INP },
# endif /* ISTRIP */
# ifdef	INLCR
    { "inlcr",	INLCR,	M_INP },
# endif /* INLCR */
# ifdef	IGNCR
    { "igncr",	IGNCR,	M_INP },
# endif /* IGNCR */
# ifdef	ICRNL
    { "icrnl",	ICRNL,	M_INP },
# endif /* ICRNL */
# ifdef	IUCLC
    { "iuclc",	IUCLC,	M_INP },
# endif /* IUCLC */
# ifdef	IXON
    { "ixon",	IXON,	M_INP },
# endif /* IXON */
# ifdef	IXANY
    { "ixany",	IXANY,	M_INP },
# endif /* IXANY */
# ifdef	IXOFF
    { "ixoff",	IXOFF,	M_INP },
# endif /* IXOFF */
# ifdef  IMAXBEL
    { "imaxbel",IMAXBEL,M_INP },
# endif /* IMAXBEL */

# ifdef	OPOST
    { "opost",	OPOST,	M_OUT },
# endif /* OPOST */
# ifdef	OLCUC
    { "olcuc",	OLCUC,	M_OUT },
# endif /* OLCUC */
# ifdef	ONLCR
    { "onlcr",	ONLCR,	M_OUT },
# endif /* ONLCR */
# ifdef	OCRNL
    { "ocrnl",	OCRNL,	M_OUT },
# endif /* OCRNL */
# ifdef	ONOCR
    { "onocr",	ONOCR,	M_OUT },
# endif /* ONOCR */
# ifdef ONOEOT
    { "onoeot",	ONOEOT,	M_OUT },
# endif /* ONOEOT */
# ifdef	ONLRET
    { "onlret",	ONLRET,	M_OUT },
# endif /* ONLRET */
# ifdef	OFILL
    { "ofill",	OFILL,	M_OUT },
# endif /* OFILL */
# ifdef	OFDEL
    { "ofdel",	OFDEL,	M_OUT },
# endif /* OFDEL */
# ifdef	NLDLY
    { "nldly",	NLDLY,	M_OUT },
# endif /* NLDLY */
# ifdef	CRDLY
    { "crdly",	CRDLY,	M_OUT },
# endif /* CRDLY */
# ifdef	TABDLY
    { "tabdly",	TABDLY,	M_OUT },
# endif /* TABDLY */
# ifdef	XTABS
    { "xtabs",	XTABS,	M_OUT },
# endif /* XTABS */
# ifdef	BSDLY
    { "bsdly",	BSDLY,	M_OUT },
# endif /* BSDLY */
# ifdef	VTDLY
    { "vtdly",	VTDLY,	M_OUT },
# endif /* VTDLY */
# ifdef	FFDLY
    { "ffdly",	FFDLY,	M_OUT },
# endif /* FFDLY */
# ifdef	PAGEOUT
    { "pageout",PAGEOUT,M_OUT },
# endif /* PAGEOUT */
# ifdef	WRAP
    { "wrap",	WRAP,	M_OUT },
# endif /* WRAP */

# ifdef	CIGNORE
    { "cignore",CIGNORE,M_CTL },
# endif /* CBAUD */
# ifdef	CBAUD
    { "cbaud",	CBAUD,	M_CTL },
# endif /* CBAUD */
# ifdef	CSTOPB
    { "cstopb",	CSTOPB,	M_CTL },
# endif /* CSTOPB */
# ifdef	CREAD
    { "cread",	CREAD,	M_CTL },
# endif /* CREAD */
# ifdef	PARENB
    { "parenb",	PARENB,	M_CTL },
# endif /* PARENB */
# ifdef	PARODD
    { "parodd",	PARODD,	M_CTL },
# endif /* PARODD */
# ifdef	HUPCL
    { "hupcl",	HUPCL,	M_CTL },
# endif /* HUPCL */
# ifdef	CLOCAL
    { "clocal",	CLOCAL,	M_CTL },
# endif /* CLOCAL */
# ifdef	LOBLK
    { "loblk",	LOBLK,	M_CTL },
# endif /* LOBLK */
# ifdef	CIBAUD
    { "cibaud",	CIBAUD,	M_CTL },
# endif /* CIBAUD */
# ifdef CRTSCTS
#  ifdef CCTS_OFLOW
    { "ccts_oflow",CCTS_OFLOW,M_CTL },
#  else
    { "crtscts",CRTSCTS,M_CTL },
#  endif /* CCTS_OFLOW */
# endif /* CRTSCTS */
# ifdef CRTS_IFLOW
    { "crts_iflow",CRTS_IFLOW,M_CTL },
# endif /* CRTS_IFLOW */
# ifdef MDMBUF
    { "mdmbuf",	MDMBUF,	M_CTL },
# endif /* MDMBUF */
# ifdef RCV1EN
    { "rcv1en",	RCV1EN,	M_CTL },
# endif /* RCV1EN */
# ifdef XMT1EN
    { "xmt1en",	XMT1EN,	M_CTL },
# endif /* XMT1EN */

# ifdef	ISIG
    { "isig",	ISIG,	M_LIN },
# endif /* ISIG */
# ifdef	ICANON
    { "icanon",	ICANON,	M_LIN },
# endif /* ICANON */
# ifdef	XCASE
    { "xcase",	XCASE,	M_LIN },
# endif /* XCASE */
# ifdef	ECHO
    { "echo",	ECHO,	M_LIN },
# endif /* ECHO */
# ifdef	ECHOE
    { "echoe",	ECHOE,	M_LIN },
# endif /* ECHOE */
# ifdef	ECHOK
    { "echok",	ECHOK,	M_LIN },
# endif /* ECHOK */
# ifdef	ECHONL
    { "echonl",	ECHONL,	M_LIN },
# endif /* ECHONL */
# ifdef	NOFLSH
    { "noflsh",	NOFLSH,	M_LIN },
# endif /* NOFLSH */
# ifdef	TOSTOP
    { "tostop",	TOSTOP,	M_LIN },
# endif /* TOSTOP */
# ifdef	ECHOCTL
    { "echoctl",ECHOCTL,M_LIN },
# endif /* ECHOCTL */
# ifdef	ECHOPRT
    { "echoprt",ECHOPRT,M_LIN },
# endif /* ECHOPRT */
# ifdef	ECHOKE
    { "echoke",	ECHOKE,	M_LIN },
# endif /* ECHOKE */
# ifdef	DEFECHO
    { "defecho",DEFECHO,M_LIN },
# endif /* DEFECHO */
# ifdef	FLUSHO
    { "flusho",	FLUSHO,	M_LIN },
# endif /* FLUSHO */
# ifdef	PENDIN
    { "pendin",	PENDIN,	M_LIN },
# endif /* PENDIN */
# ifdef	IEXTEN
    { "iexten",	IEXTEN,	M_LIN },
# endif /* IEXTEN */
# ifdef	NOKERNINFO
    { "nokerninfo",NOKERNINFO,M_LIN },
# endif /* NOKERNINFO */
# ifdef	ALTWERASE
    { "altwerase",ALTWERASE,M_LIN },
# endif /* ALTWERASE */
# ifdef	EXTPROC
    { "extproc",EXTPROC, M_LIN },
# endif /* EXTPROC */

# if defined(VINTR) 
    { "intr",		C_SH(C_INTR), 	M_CHAR },
# endif /* VINTR */
# if defined(VQUIT)
    { "quit",		C_SH(C_QUIT), 	M_CHAR },
# endif /* VQUIT */
# if defined(VERASE)
    { "erase",		C_SH(C_ERASE), 	M_CHAR },
# endif /* VERASE */
# if defined(VKILL)
    { "kill",		C_SH(C_KILL), 	M_CHAR },
# endif /* VKILL */
# if defined(VEOF)
    { "eof",		C_SH(C_EOF), 	M_CHAR },
# endif /* VEOF */
# if defined(VEOL)
    { "eol",		C_SH(C_EOL), 	M_CHAR },
# endif /* VEOL */
# if defined(VEOL2)
    { "eol2",		C_SH(C_EOL2), 	M_CHAR },
# endif  /* VEOL2 */
# if defined(VSWTCH)
    { "swtch",		C_SH(C_SWTCH), 	M_CHAR },
# endif /* VSWTCH */
# if defined(VDSWTCH)
    { "dswtch",		C_SH(C_DSWTCH),	M_CHAR },
# endif /* VDSWTCH */
# if defined(VERASE2)
    { "erase2",		C_SH(C_ERASE2),	M_CHAR },
# endif /* VERASE2 */
# if defined(VSTART)
    { "start",		C_SH(C_START), 	M_CHAR },
# endif /* VSTART */
# if defined(VSTOP)
    { "stop",		C_SH(C_STOP), 	M_CHAR },
# endif /* VSTOP */
# if defined(VWERASE)
    { "werase",		C_SH(C_WERASE),	M_CHAR },
# endif /* VWERASE */
# if defined(VSUSP)
    { "susp",		C_SH(C_SUSP), 	M_CHAR },
# endif /* VSUSP */
# if defined(VDSUSP)
    { "dsusp",		C_SH(C_DSUSP), 	M_CHAR },
# endif /* VDSUSP */
# if defined(VREPRINT)
    { "reprint",	C_SH(C_REPRINT),M_CHAR },
# endif /* VREPRINT */
# if defined(VDISCARD)
    { "discard",	C_SH(C_DISCARD),M_CHAR },
# endif /* VDISCARD */
# if defined(VLNEXT)
    { "lnext",		C_SH(C_LNEXT), 	M_CHAR },
# endif /* VLNEXT */
# if defined(VSTATUS)
    { "status",		C_SH(C_STATUS),	M_CHAR },
# endif /* VSTATUS */
# if defined(VPAGE)
    { "page",		C_SH(C_PAGE), 	M_CHAR },
# endif /* VPAGE */
# if defined(VPGOFF)
    { "pgoff",		C_SH(C_PGOFF), 	M_CHAR },
# endif /* VPGOFF */
# if defined(VKILL2) 
    { "kill2",		C_SH(C_KILL2), 	M_CHAR },
# endif /* VKILL2 */
# if defined(VBRK)
    { "brk",		C_SH(C_BRK), 	M_CHAR },
# endif /* VBRK */
# if defined(VMIN)
    { "min",		C_SH(C_MIN), 	M_CHAR },
# endif /* VMIN */
# if defined(VTIME)
    { "time",		C_SH(C_TIME), 	M_CHAR },
# endif /* VTIME */
    { NULL, 0, -1 },
d158 287
a446 2
#define tty_getty(el, td) tcgetattr((el)->el_infd, (td))
#define tty_setty(el, td) tcsetattr((el)->el_infd, TCSADRAIN, (td)) 
d448 2
a449 8
#define tty__gettabs(td)     ((((td)->c_oflag & TAB3) == TAB3) ? 0 : 1)
#define tty__geteightbit(td) (((td)->c_cflag & CSIZE) == CS8)
#define tty__cooked_mode(td) ((td)->c_lflag & ICANON)

private void    tty__getchar(struct termios *, unsigned char *);
private void    tty__setchar(struct termios *, unsigned char *);
private speed_t tty__getspeed(struct termios *);
private int     tty_setup(EditLine *);
d451 10
a460 1
#define t_qu t_ts
d466 2
a467 3
private int 
tty_setup(el)
    EditLine *el;
d469 6
a474 2
    int rst = 1;
    if (tty_getty(el, &el->el_tty.t_ed) == -1) {
d476 2
a477 2
	(void)fprintf(el->el_errfile, 
		       "tty_setup: tty_getty: %s\n", strerror(errno));
d479 45
a523 41
	return(-1);
    }
    el->el_tty.t_ts    = el->el_tty.t_ex = el->el_tty.t_ed;

    el->el_tty.t_speed = tty__getspeed(&el->el_tty.t_ex);
    el->el_tty.t_tabs  = tty__gettabs(&el->el_tty.t_ex);
    el->el_tty.t_eight = tty__geteightbit(&el->el_tty.t_ex);

    el->el_tty.t_ex.c_iflag &= ~el->el_tty.t_t[EX_IO][M_INP].t_clrmask;
    el->el_tty.t_ex.c_iflag |=  el->el_tty.t_t[EX_IO][M_INP].t_setmask;

    el->el_tty.t_ex.c_oflag &= ~el->el_tty.t_t[EX_IO][M_OUT].t_clrmask;
    el->el_tty.t_ex.c_oflag |=  el->el_tty.t_t[EX_IO][M_OUT].t_setmask;

    el->el_tty.t_ex.c_cflag &= ~el->el_tty.t_t[EX_IO][M_CTL].t_clrmask;
    el->el_tty.t_ex.c_cflag |=  el->el_tty.t_t[EX_IO][M_CTL].t_setmask;

    el->el_tty.t_ex.c_lflag &= ~el->el_tty.t_t[EX_IO][M_LIN].t_clrmask;
    el->el_tty.t_ex.c_lflag |=  el->el_tty.t_t[EX_IO][M_LIN].t_setmask;

    /*
     * Reset the tty chars to reasonable defaults
     * If they are disabled, then enable them.
     */
    if (rst) {
        if (tty__cooked_mode(&el->el_tty.t_ts)) {
            tty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);
            /*
             * Don't affect CMIN and CTIME for the editor mode
             */
            for (rst = 0; rst < C_NCC - 2; rst++)
                if (el->el_tty.t_c[TS_IO][rst] != el->el_tty.t_vdisable &&
                    el->el_tty.t_c[ED_IO][rst] != el->el_tty.t_vdisable)
                    el->el_tty.t_c[ED_IO][rst]  = el->el_tty.t_c[TS_IO][rst];
            for (rst = 0; rst < C_NCC; rst++)
                if (el->el_tty.t_c[TS_IO][rst] != el->el_tty.t_vdisable &&
                    el->el_tty.t_c[EX_IO][rst] != el->el_tty.t_vdisable)
                    el->el_tty.t_c[EX_IO][rst]  = el->el_tty.t_c[TS_IO][rst];
        }
        tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
        if (tty_setty(el, &el->el_tty.t_ex) == -1) {
d525 3
a527 2
            (void)fprintf(el->el_errfile, "tty_setup: tty_setty: %s\n", 
			   strerror(errno));
d529 7
a535 11
            return(-1);
        }
    }
    else
        tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);

    el->el_tty.t_ed.c_iflag &= ~el->el_tty.t_t[ED_IO][M_INP].t_clrmask;
    el->el_tty.t_ed.c_iflag |=  el->el_tty.t_t[ED_IO][M_INP].t_setmask;

    el->el_tty.t_ed.c_oflag &= ~el->el_tty.t_t[ED_IO][M_OUT].t_clrmask;
    el->el_tty.t_ed.c_oflag |=  el->el_tty.t_t[ED_IO][M_OUT].t_setmask;
d537 2
a538 2
    el->el_tty.t_ed.c_cflag &= ~el->el_tty.t_t[ED_IO][M_CTL].t_clrmask;
    el->el_tty.t_ed.c_cflag |=  el->el_tty.t_t[ED_IO][M_CTL].t_setmask;
d540 2
a541 2
    el->el_tty.t_ed.c_lflag &= ~el->el_tty.t_t[ED_IO][M_LIN].t_clrmask;
    el->el_tty.t_ed.c_lflag |=  el->el_tty.t_t[ED_IO][M_LIN].t_setmask;
d543 6
a548 2
    tty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);
    return 0;
d552 1
a552 2
tty_init(el)
    EditLine *el;
d554 7
a560 6
    el->el_tty.t_mode     = EX_IO;
    el->el_tty.t_vdisable = _POSIX_VDISABLE;
    (void)memcpy(el->el_tty.t_t, ttyperm, sizeof(ttyperm_t));
    (void)memcpy(el->el_tty.t_c, ttychar, sizeof(ttychar_t));
    return tty_setup(el);
} /* end tty_init */
d568 1
a568 2
tty_end(el)
    EditLine *el;
d570 2
a571 1
    /* XXX: Maybe reset to an initial state? */
d579 1
a579 2
tty__getspeed(td)
    struct termios *td;
d581 1
a581 1
    speed_t spd;
d583 4
a586 4
    if ((spd = cfgetispeed(td)) == 0)
	spd = cfgetospeed(td);
    return spd;
} /* end tty__getspeed */
d593 76
a668 77
tty__getchar(td, s)
    struct termios *td;
    unsigned char *s;
{   
# ifdef VINTR
    s[C_INTR]	= td->c_cc[VINTR];
# endif /* VINTR */
# ifdef VQUIT
    s[C_QUIT]	= td->c_cc[VQUIT];
# endif /* VQUIT */
# ifdef VERASE
    s[C_ERASE]	= td->c_cc[VERASE];
# endif /* VERASE */
# ifdef VKILL
    s[C_KILL]	= td->c_cc[VKILL];
# endif /* VKILL */
# ifdef VEOF
    s[C_EOF]	= td->c_cc[VEOF];
# endif /* VEOF */
# ifdef VEOL
    s[C_EOL]	= td->c_cc[VEOL];
# endif /* VEOL */
# ifdef VEOL2
    s[C_EOL2]	= td->c_cc[VEOL2];
# endif  /* VEOL2 */
# ifdef VSWTCH
    s[C_SWTCH]	= td->c_cc[VSWTCH];
# endif /* VSWTCH */
# ifdef VDSWTCH
    s[C_DSWTCH]	= td->c_cc[VDSWTCH];
# endif /* VDSWTCH */
# ifdef VERASE2
    s[C_ERASE2]	= td->c_cc[VERASE2];
# endif /* VERASE2 */
# ifdef VSTART
    s[C_START]	= td->c_cc[VSTART];
# endif /* VSTART */
# ifdef VSTOP
    s[C_STOP]	= td->c_cc[VSTOP];
# endif /* VSTOP */
# ifdef VWERASE
    s[C_WERASE]	= td->c_cc[VWERASE];
# endif /* VWERASE */
# ifdef VSUSP
    s[C_SUSP]	= td->c_cc[VSUSP];
# endif /* VSUSP */
# ifdef VDSUSP
    s[C_DSUSP]	= td->c_cc[VDSUSP];
# endif /* VDSUSP */
# ifdef VREPRINT
    s[C_REPRINT]= td->c_cc[VREPRINT];
# endif /* VREPRINT */
# ifdef VDISCARD
    s[C_DISCARD]= td->c_cc[VDISCARD];
# endif /* VDISCARD */
# ifdef VLNEXT
    s[C_LNEXT]	= td->c_cc[VLNEXT];
# endif /* VLNEXT */
# ifdef VSTATUS
    s[C_STATUS]	= td->c_cc[VSTATUS];
# endif /* VSTATUS */
# ifdef VPAGE
    s[C_PAGE]	= td->c_cc[VPAGE];
# endif /* VPAGE */
# ifdef VPGOFF
    s[C_PGOFF]	= td->c_cc[VPGOFF];
# endif /* VPGOFF */
# ifdef VKILL2
    s[C_KILL2]	= td->c_cc[VKILL2];
# endif /* KILL2 */
# ifdef VMIN
    s[C_MIN]	= td->c_cc[VMIN];
# endif /* VMIN */
# ifdef VTIME
    s[C_TIME]	= td->c_cc[VTIME];
# endif /* VTIME */
} /* tty__getchar */
d675 76
a750 77
tty__setchar(td, s)
    struct termios *td;
    unsigned char *s;
{   
# ifdef VINTR
    td->c_cc[VINTR]	= s[C_INTR];
# endif /* VINTR */
# ifdef VQUIT
    td->c_cc[VQUIT]	= s[C_QUIT];
# endif /* VQUIT */
# ifdef VERASE
    td->c_cc[VERASE]	= s[C_ERASE];
# endif /* VERASE */
# ifdef VKILL
    td->c_cc[VKILL]	= s[C_KILL];
# endif /* VKILL */
# ifdef VEOF
    td->c_cc[VEOF]	= s[C_EOF];
# endif /* VEOF */
# ifdef VEOL
    td->c_cc[VEOL]	= s[C_EOL];
# endif /* VEOL */
# ifdef VEOL2
    td->c_cc[VEOL2]	= s[C_EOL2];
# endif  /* VEOL2 */
# ifdef VSWTCH
    td->c_cc[VSWTCH]	= s[C_SWTCH];
# endif /* VSWTCH */
# ifdef VDSWTCH
    td->c_cc[VDSWTCH]	= s[C_DSWTCH];
# endif /* VDSWTCH */
# ifdef VERASE2
    td->c_cc[VERASE2]	= s[C_ERASE2];
# endif /* VERASE2 */
# ifdef VSTART
    td->c_cc[VSTART]	= s[C_START];
# endif /* VSTART */
# ifdef VSTOP
    td->c_cc[VSTOP]	= s[C_STOP];
# endif /* VSTOP */
# ifdef VWERASE
    td->c_cc[VWERASE]	= s[C_WERASE];
# endif /* VWERASE */
# ifdef VSUSP
    td->c_cc[VSUSP]	= s[C_SUSP];
# endif /* VSUSP */
# ifdef VDSUSP
    td->c_cc[VDSUSP]	= s[C_DSUSP];
# endif /* VDSUSP */
# ifdef VREPRINT
    td->c_cc[VREPRINT]	= s[C_REPRINT];
# endif /* VREPRINT */
# ifdef VDISCARD
    td->c_cc[VDISCARD]	= s[C_DISCARD];
# endif /* VDISCARD */
# ifdef VLNEXT
    td->c_cc[VLNEXT]	= s[C_LNEXT];
# endif /* VLNEXT */
# ifdef VSTATUS
    td->c_cc[VSTATUS]	= s[C_STATUS];
# endif /* VSTATUS */
# ifdef VPAGE
    td->c_cc[VPAGE]	= s[C_PAGE];
# endif /* VPAGE */
# ifdef VPGOFF
    td->c_cc[VPGOFF]	= s[C_PGOFF];
# endif /* VPGOFF */
# ifdef VKILL2
    td->c_cc[VKILL2]	= s[C_KILL2];
# endif /* VKILL2 */
# ifdef VMIN
    td->c_cc[VMIN]	= s[C_MIN];
# endif /* VMIN */
# ifdef VTIME
    td->c_cc[VTIME]	= s[C_TIME];
# endif /* VTIME */
} /* tty__setchar */
d757 1
a757 3
tty_bind_char(el, force)
    EditLine *el;
    int force;
d759 36
a794 35
    unsigned char *t_n = el->el_tty.t_c[ED_IO];
    unsigned char *t_o = el->el_tty.t_ed.c_cc;
    unsigned char new[2], old[2];
    ttymap_t *tp;
    el_action_t  *dmap, *dalt, *map, *alt;
    new[1] = old[1] = '\0';


    map = el->el_map.key;
    alt = el->el_map.alt;
    if (el->el_map.type == MAP_VI) {
	dmap = el->el_map.vii;
	dalt = el->el_map.vic;
    }
    else {
	dmap = el->el_map.emacs;
	dalt = NULL;
    }

    for (tp = tty_map; tp->nch != -1; tp++) {
	new[0] = t_n[tp->nch];
	old[0] = t_o[tp->och];
	if (new[0] == old[0] && !force)
	    continue;
	/* Put the old default binding back, and set the new binding */
	key_clear(el, map, old);
	map[old[0]] = dmap[old[0]];
	key_clear(el, map, new);
	/* MAP_VI == 1, MAP_EMACS == 0... */
	map[new[0]] = tp->bind[el->el_map.type];
	if (dalt) {
	    key_clear(el, alt, old);
	    alt[old[0]] = dalt[old[0]];
	    key_clear(el, alt, new);
	    alt[new[0]] = tp->bind[el->el_map.type+1];
a795 1
    }
d798 1
d803 1
a803 2
tty_rawmode(el)
    EditLine *el;
a804 2
    if (el->el_tty.t_mode == ED_IO)
	return (0);
d806 7
a812 1
    if (tty_getty(el, &el->el_tty.t_ts) == -1) {
d814 2
a815 1
	(void)fprintf(el->el_errfile, "tty_rawmode: tty_getty: %s\n", strerror(errno));
d817 1
a817 27
	return(-1);
    }

    /*
     * We always keep up with the eight bit setting and the speed of the
     * tty. But only we only believe changes that are made to cooked mode!
     */
    el->el_tty.t_eight = tty__geteightbit(&el->el_tty.t_ts);
    el->el_tty.t_speed = tty__getspeed(&el->el_tty.t_ts);

    if (tty__getspeed(&el->el_tty.t_ex) != el->el_tty.t_speed || 
	tty__getspeed(&el->el_tty.t_ed) != el->el_tty.t_speed) {
	(void)cfsetispeed(&el->el_tty.t_ex, el->el_tty.t_speed);
	(void)cfsetospeed(&el->el_tty.t_ex, el->el_tty.t_speed);
	(void)cfsetispeed(&el->el_tty.t_ed, el->el_tty.t_speed);
	(void)cfsetospeed(&el->el_tty.t_ed, el->el_tty.t_speed);
    }

    if (tty__cooked_mode(&el->el_tty.t_ts)) {
	if (el->el_tty.t_ts.c_cflag != el->el_tty.t_ex.c_cflag) { 
	    el->el_tty.t_ex.c_cflag  = el->el_tty.t_ts.c_cflag;
	    el->el_tty.t_ex.c_cflag &= ~el->el_tty.t_t[EX_IO][M_CTL].t_clrmask;
	    el->el_tty.t_ex.c_cflag |=  el->el_tty.t_t[EX_IO][M_CTL].t_setmask;

	    el->el_tty.t_ed.c_cflag  = el->el_tty.t_ts.c_cflag;
	    el->el_tty.t_ed.c_cflag &= ~el->el_tty.t_t[ED_IO][M_CTL].t_clrmask;
	    el->el_tty.t_ed.c_cflag |=  el->el_tty.t_t[ED_IO][M_CTL].t_setmask;
d819 13
a831 10

	if ((el->el_tty.t_ts.c_lflag != el->el_tty.t_ex.c_lflag) &&
	    (el->el_tty.t_ts.c_lflag != el->el_tty.t_ed.c_lflag)) {
	    el->el_tty.t_ex.c_lflag = el->el_tty.t_ts.c_lflag;
	    el->el_tty.t_ex.c_lflag &= ~el->el_tty.t_t[EX_IO][M_LIN].t_clrmask;
	    el->el_tty.t_ex.c_lflag |=  el->el_tty.t_t[EX_IO][M_LIN].t_setmask;

	    el->el_tty.t_ed.c_lflag = el->el_tty.t_ts.c_lflag;
	    el->el_tty.t_ed.c_lflag &= ~el->el_tty.t_t[ED_IO][M_LIN].t_clrmask;
	    el->el_tty.t_ed.c_lflag |=  el->el_tty.t_t[ED_IO][M_LIN].t_setmask;
d833 68
d902 2
a903 10
	if ((el->el_tty.t_ts.c_iflag != el->el_tty.t_ex.c_iflag) &&
	    (el->el_tty.t_ts.c_iflag != el->el_tty.t_ed.c_iflag)) {
	    el->el_tty.t_ex.c_iflag = el->el_tty.t_ts.c_iflag;
	    el->el_tty.t_ex.c_iflag &= ~el->el_tty.t_t[EX_IO][M_INP].t_clrmask;
	    el->el_tty.t_ex.c_iflag |=  el->el_tty.t_t[EX_IO][M_INP].t_setmask;

	    el->el_tty.t_ed.c_iflag = el->el_tty.t_ts.c_iflag;
	    el->el_tty.t_ed.c_iflag &= ~el->el_tty.t_t[ED_IO][M_INP].t_clrmask;
	    el->el_tty.t_ed.c_iflag |=  el->el_tty.t_t[ED_IO][M_INP].t_setmask;
	}
d905 35
a939 40
	if ((el->el_tty.t_ts.c_oflag != el->el_tty.t_ex.c_oflag) &&
	    (el->el_tty.t_ts.c_oflag != el->el_tty.t_ed.c_oflag)) {
	    el->el_tty.t_ex.c_oflag = el->el_tty.t_ts.c_oflag;
	    el->el_tty.t_ex.c_oflag &= ~el->el_tty.t_t[EX_IO][M_OUT].t_clrmask;
	    el->el_tty.t_ex.c_oflag |=  el->el_tty.t_t[EX_IO][M_OUT].t_setmask;

	    el->el_tty.t_ed.c_oflag = el->el_tty.t_ts.c_oflag;
	    el->el_tty.t_ed.c_oflag &= ~el->el_tty.t_t[ED_IO][M_OUT].t_clrmask;
	    el->el_tty.t_ed.c_oflag |=  el->el_tty.t_t[ED_IO][M_OUT].t_setmask;
	}

	if (tty__gettabs(&el->el_tty.t_ex) == 0) 
	    el->el_tty.t_tabs = 0;
	else 
	    el->el_tty.t_tabs = EL_CAN_TAB ? 1 : 0;

	{
	    int i;

	    tty__getchar(&el->el_tty.t_ts, el->el_tty.t_c[TS_IO]);
	    /*
	     * Check if the user made any changes.
	     * If he did, then propagate the changes to the
	     * edit and execute data structures.
	     */
	    for (i = 0; i < C_NCC; i++)
		if (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i])
		    break;
		
	    if (i != C_NCC) {
		/*
		 * Propagate changes only to the unprotected chars
		 * that have been modified just now.
		 */
		for (i = 0; i < C_NCC; i++) {
		    if (!((el->el_tty.t_t[ED_IO][M_CHAR].t_setmask & C_SH(i)))
		      && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))
			el->el_tty.t_c[ED_IO][i] = el->el_tty.t_c[TS_IO][i];
		    if (el->el_tty.t_t[ED_IO][M_CHAR].t_clrmask & C_SH(i))
			el->el_tty.t_c[ED_IO][i] = el->el_tty.t_vdisable;
a940 13
		tty_bind_char(el, 0);
		tty__setchar(&el->el_tty.t_ed, el->el_tty.t_c[ED_IO]);

		for (i = 0; i < C_NCC; i++) {
		    if (!((el->el_tty.t_t[EX_IO][M_CHAR].t_setmask & C_SH(i)))
		      && (el->el_tty.t_c[TS_IO][i] != el->el_tty.t_c[EX_IO][i]))
			el->el_tty.t_c[EX_IO][i] = el->el_tty.t_c[TS_IO][i];
		    if (el->el_tty.t_t[EX_IO][M_CHAR].t_clrmask & C_SH(i))
			el->el_tty.t_c[EX_IO][i] = el->el_tty.t_vdisable;
		}
		tty__setchar(&el->el_tty.t_ex, el->el_tty.t_c[EX_IO]);
	    }

d942 1
a942 3
    }

    if (tty_setty(el, &el->el_tty.t_ed) == -1) {
d944 2
a945 2
	(void)fprintf(el->el_errfile, "tty_rawmode: tty_setty: %s\n", 
		       strerror(errno));
d947 5
a951 5
	return -1;
    }
    el->el_tty.t_mode = ED_IO;
    return (0);
} /* end tty_rawmode */
d958 1
a958 2
tty_cookedmode(el)
    EditLine *el;
a959 2
    if (el->el_tty.t_mode == EX_IO)
	return (0);
d961 7
a967 1
    if (tty_setty(el, &el->el_tty.t_ex) == -1) {
d969 3
a971 2
	(void)fprintf(el->el_errfile, "tty_cookedmode: tty_setty: %s\n", 
		       strerror(errno));
d973 5
a977 5
	return -1;
    }
    el->el_tty.t_mode = EX_IO;
    return (0);
} /* end tty_cookedmode */
d984 1
a984 2
tty_quotemode(el)
    EditLine *el;
d986 2
a987 2
    if (el->el_tty.t_mode == QU_IO)
	return 0;
d989 1
a989 1
    el->el_tty.t_qu = el->el_tty.t_ed;
d991 2
a992 2
    el->el_tty.t_qu.c_iflag &= ~el->el_tty.t_t[QU_IO][M_INP].t_clrmask;
    el->el_tty.t_qu.c_iflag |=  el->el_tty.t_t[QU_IO][M_INP].t_setmask;
d994 2
a995 2
    el->el_tty.t_qu.c_oflag &= ~el->el_tty.t_t[QU_IO][M_OUT].t_clrmask;
    el->el_tty.t_qu.c_oflag |=  el->el_tty.t_t[QU_IO][M_OUT].t_setmask;
d997 2
a998 2
    el->el_tty.t_qu.c_cflag &= ~el->el_tty.t_t[QU_IO][M_CTL].t_clrmask;
    el->el_tty.t_qu.c_cflag |=  el->el_tty.t_t[QU_IO][M_CTL].t_setmask;
d1000 2
a1001 2
    el->el_tty.t_qu.c_lflag &= ~el->el_tty.t_t[QU_IO][M_LIN].t_clrmask;
    el->el_tty.t_qu.c_lflag |=  el->el_tty.t_t[QU_IO][M_LIN].t_setmask;
d1003 1
a1003 1
    if (tty_setty(el, &el->el_tty.t_qu) == -1) {
d1005 2
a1006 2
	(void)fprintf(el->el_errfile, "QuoteModeOn: tty_setty: %s\n", 
		       strerror(errno));
d1008 5
a1012 5
	return -1;
    }
    el->el_tty.t_mode = QU_IO;
    return 0;
} /* end tty_quotemode */
d1019 1
a1019 2
tty_noquotemode(el)
    EditLine *el;
d1021 4
a1024 3
    if (el->el_tty.t_mode != QU_IO)
	return 0;
    if (tty_setty(el, &el->el_tty.t_ed) == -1) {
d1026 2
a1027 2
	(void)fprintf(el->el_errfile, "QuoteModeOff: tty_setty: %s\n", 
		       strerror(errno));
d1029 4
a1032 4
	return -1;
    }
    el->el_tty.t_mode = ED_IO;
    return 0;
d1035 1
d1041 1
a1041 4
tty_stty(el, argc, argv)
    EditLine *el;
    int argc;
    char **argv;
d1043 35
a1077 34
    ttymodes_t *m;
    char x, *d;
    int aflag = 0;
    char *s;
    char *name;
    int z = EX_IO;

    if (argv == NULL)
	return -1;
    name = *argv++;

    while (argv && *argv && argv[0][0] == '-' && argv[0][2] == '\0') 
	switch (argv[0][1]) {
	case 'a':
	    aflag++;
	    argv++;
	    break;
	case 'd':
	    argv++;
	    z = ED_IO;
	    break;
	case 'x':
	    argv++;
	    z = EX_IO;
	    break;
	case 'q':
	    argv++;
	    z = QU_IO;
	    break;
	default:
	    (void)fprintf(el->el_errfile, "%s: Unknown switch `%c'.\n",
			   name, argv[0][1]);
	    return -1;
	}
d1079 35
a1113 21
    if (!argv || !*argv) {
	int i = -1;
	int len = 0, st = 0, cu;
	for (m = ttymodes; m->m_name; m++) {
	    if (m->m_type != i) {
		(void)fprintf(el->el_outfile, "%s%s", i != -1 ? "\n" : "", 
			el->el_tty.t_t[z][m->m_type].t_name);
		i = m->m_type;
		st = len = strlen(el->el_tty.t_t[z][m->m_type].t_name);
	    }

	    x = (el->el_tty.t_t[z][i].t_setmask & m->m_value) ? '+' : '\0';
	    x = (el->el_tty.t_t[z][i].t_clrmask & m->m_value) ? '-' : x;

	    if (x != '\0' || aflag) {

		cu = strlen(m->m_name) + (x != '\0') + 1;

		if (len + cu >= el->el_term.t_size.h) {
		    (void)fprintf(el->el_outfile, "\n%*s", st, "");
		    len = st + cu;
d1115 2
a1116 8
		else 
		    len += cu;

		if (x != '\0')
		    (void)fprintf(el->el_outfile, "%c%s ", x, m->m_name);
		else
		    (void)fprintf(el->el_outfile, "%s ", m->m_name);
	    }
d1118 34
a1151 23
	(void)fprintf(el->el_outfile, "\n");
	return 0;
    }

    while (argv && (s = *argv++)) {
	switch (*s) {
	case '+':
	case '-':
	    x = *s++;
	    break;
	default:
	    x = '\0';
	    break;
	}
	d = s;
	for (m = ttymodes; m->m_name; m++)
	    if (strcmp(m->m_name, d) == 0)
		break;

	if (!m->m_name)  {
	    (void)fprintf(el->el_errfile, "%s: Invalid argument `%s'.\n",
			   name, d);
	    return -1;
d1153 2
a1154 18

	switch (x) {
	case '+':
	    el->el_tty.t_t[z][m->m_type].t_setmask |= m->m_value;
	    el->el_tty.t_t[z][m->m_type].t_clrmask &= ~m->m_value;
	    break;
	case '-':
	    el->el_tty.t_t[z][m->m_type].t_setmask &= ~m->m_value;
	    el->el_tty.t_t[z][m->m_type].t_clrmask |= m->m_value;
	    break;
	default:
	    el->el_tty.t_t[z][m->m_type].t_setmask &= ~m->m_value;
	    el->el_tty.t_t[z][m->m_type].t_clrmask &= ~m->m_value;
	    break;
	}
    }
    return 0;
} /* end tty_stty */
d1162 1
a1162 3
tty_printchar(el, s)
    EditLine *el;
    unsigned char *s;
d1164 2
a1165 2
    ttyperm_t *m;
    int i;
d1167 11
a1177 10
    for (i = 0; i < C_NCC; i++) {
	for (m = el->el_tty.t_t; m->m_name; m++) 
	    if (m->m_type == M_CHAR && C_SH(i) == m->m_value)
		break;
	if (m->m_name)
	    (void)fprintf(el->el_errfile, "%s ^%c ", m->m_name, s[i] + 'A'-1);
	if (i % 5 == 0)
	    (void)fprintf(el->el_errfile, "\n");
    }
    (void)fprintf(el->el_errfile, "\n"); 
@


1.7
log
@is -Wall clean by making rcsid const
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.6 2002/02/16 21:27:26 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: tty.c,v 1.6 2002/02/16 21:27:26 millert Exp $";
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.5 2001/04/13 20:21:19 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.5 2001/04/13 20:21:19 deraadt Exp $";
@


1.5
log
@signess bug; jwaterman@@yaleroad.com
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.4 1997/06/29 23:40:52 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.4 1997/06/29 23:40:52 millert Exp $";
d456 4
a459 4
private void    tty__getchar	__P((struct termios *, unsigned char *));
private void    tty__setchar	__P((struct termios *, unsigned char *));
private speed_t tty__getspeed	__P((struct termios *));
private int     tty_setup	__P((EditLine *));
@


1.4
log
@Updates from NetBSD (christos@@netbsd.org)
  * Portability fixes:
	__const         -> const
	BADSIG          -> SIG_ERR
	int flags       -> u_int flags
	#if __STDC__    -> #ifdef __STDC__
  * Don't allow CSWTCH to interfere with CSUSP on __SVR4 systems.
  * Return -1 if the terminal set operation resulted in dumb terminal settings.
  * Handle properly the case where the last line in the sourced file does
    not have a trailing '\n'. From Jeffrey C Honig.
  * editrc -> editline in editline(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.3 1997/03/14 05:13:09 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.3 1997/03/14 05:13:09 millert Exp $";
d759 1
a759 1
    char new[2], old[2];
@


1.3
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 2
a2 2
/*	$OpenBSD: tty.c,v 1.2 1997/01/16 05:18:50 millert Exp $	*/
/*	$NetBSD: tty.c,v 1.2 1997/01/11 06:48:17 lukem Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: tty.c,v 1.2 1997/01/16 05:18:50 millert Exp $";
d57 1
a57 1
    int   m_value;
@


1.2
log
@Merge in NetBSD libedit changes and new man pages.  Also fix some
strncpy() usage in their code.  NetBSD change log was:
    * add a man page for the editline routines
    * add a man page describing editrc
    * fix bugs in el_parse():
      * didn't execute command when program name matched (test reversed)
      * was checking against empty string instead of program name
      * after checks, command to run also pointed to empty string
    * document ^char and \ escape sequences
    * when parsing ^char control chars, check the correct char when determining
      validity (previously, ^char was a NOP interpreted as the literal string
      because of this bug)
    * Implement CC_REDISPLAY, which (unlike CC_REFRESH) redraws the entire input
    * line (a la ^R). This is useful if the binding outputs information and
    * mucks up the input line. To be used in ``list-choices'' bindings (refer
    * to the ^D binding in csh when filec is set)
@
text
@d1 2
a2 1
/*	$OpenBSD: $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: $";
d474 1
a474 1
	(void) fprintf(el->el_errfile, 
d519 1
a519 1
            (void) fprintf(el->el_errfile, "tty_setup: tty_setty: %s\n", 
d550 2
a551 2
    (void) memcpy(el->el_tty.t_t, ttyperm, sizeof(ttyperm_t));
    (void) memcpy(el->el_tty.t_c, ttychar, sizeof(ttychar_t));
d808 1
a808 1
	(void) fprintf(el->el_errfile, "tty_rawmode: tty_getty: %s\n", strerror(errno));
d822 4
a825 4
	(void) cfsetispeed(&el->el_tty.t_ex, el->el_tty.t_speed);
	(void) cfsetospeed(&el->el_tty.t_ex, el->el_tty.t_speed);
	(void) cfsetispeed(&el->el_tty.t_ed, el->el_tty.t_speed);
	(void) cfsetospeed(&el->el_tty.t_ed, el->el_tty.t_speed);
d920 1
a920 1
	(void) fprintf(el->el_errfile, "tty_rawmode: tty_setty: %s\n", 
d942 1
a942 1
	(void) fprintf(el->el_errfile, "tty_cookedmode: tty_setty: %s\n", 
d978 1
a978 1
	(void) fprintf(el->el_errfile, "QuoteModeOn: tty_setty: %s\n", 
d999 1
a999 1
	(void) fprintf(el->el_errfile, "QuoteModeOff: tty_setty: %s\n", 
d1048 1
a1048 1
	    (void) fprintf(el->el_errfile, "%s: Unknown switch `%c'.\n",
d1058 1
a1058 1
		(void) fprintf(el->el_outfile, "%s%s", i != -1 ? "\n" : "", 
d1072 1
a1072 1
		    (void) fprintf(el->el_outfile, "\n%*s", st, "");
d1079 1
a1079 1
		    (void) fprintf(el->el_outfile, "%c%s ", x, m->m_name);
d1081 1
a1081 1
		    (void) fprintf(el->el_outfile, "%s ", m->m_name);
d1084 1
a1084 1
	(void) fprintf(el->el_outfile, "\n");
d1104 1
a1104 1
	    (void) fprintf(el->el_errfile, "%s: Invalid argument `%s'.\n",
d1145 1
a1145 1
	    (void) fprintf(el->el_errfile, "%s ^%c ", m->m_name, s[i] + 'A'-1);
d1147 1
a1147 1
	    (void) fprintf(el->el_errfile, "\n");
d1149 1
a1149 1
    (void) fprintf(el->el_errfile, "\n"); 
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
d42 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
