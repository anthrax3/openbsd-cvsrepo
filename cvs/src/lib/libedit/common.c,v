head	1.22;
access;
symbols
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.24
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.16
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.20
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.18
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.14
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.12
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.10
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.8
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.26
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.22
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.3.0.26
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.24
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.22
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.20
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.18
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.16
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.14
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.05.22.23.09.56;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	JDRx6gbg98ixcAQq;

1.21
date	2016.05.06.13.12.52;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	HmIy04UbyUS0d1Sd;

1.20
date	2016.04.18.20.13.07;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	BCiQfkJB2pLlS49p;

1.19
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	OUneMOe0l7HombT5;

1.18
date	2016.04.11.19.54.54;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	xizUpRlYj2C4Hcj6;

1.17
date	2016.04.09.20.15.26;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	0bnhGLXZIvXlnMLp;

1.16
date	2016.03.22.11.32.18;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	IqABuRl0Ys8M4ewM;

1.15
date	2016.03.21.15.25.39;	author schwarze;	state Exp;
branches;
next	1.14;
commitid	Qq3DwK1S3lWtyR8X;

1.14
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.13;
commitid	tRHhB2RN3ZD1GvoI;

1.13
date	2016.03.20.23.24.18;	author schwarze;	state Exp;
branches;
next	1.12;
commitid	1kXRbplx2L28TTGX;

1.12
date	2016.03.20.22.57.59;	author schwarze;	state Exp;
branches;
next	1.11;
commitid	VBVmrUoZFnMc0hts;

1.11
date	2016.03.20.20.35.38;	author schwarze;	state Exp;
branches;
next	1.10;
commitid	b06qlwkNEbVitvG0;

1.10
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.9;
commitid	dCN84ovvbfYwqrqX;

1.9
date	2016.01.30.00.06.39;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	tGf8IdK8wCurneJ7;

1.8
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.01.21.11.21;	author avsm;	state Exp;
branches;
next	1.3;

1.3
date	97.03.14.05.12.43;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.16.05.18.30;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.40;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Improve modularization at the chared/read boundary, no functional change.

Stop the read.c module from poking the el_chared.c_macro data
structure that used to belong to the chared.c module.  Given that
no other module, not even chared itself, is using that data, move it
into the read modules's own opaque data structure, struct el_read_t.

That gets rid of one struct, one #define, one struct member, and one
function argument in the chared.h interface.

OK czarkoff@@
@
text
@/*	$OpenBSD: common.c,v 1.21 2016/05/06 13:12:52 schwarze Exp $	*/
/*	$NetBSD: common.c,v 1.24 2009/12/30 22:37:40 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * common.c: Common Editor functions
 */
#include <ctype.h>
#include <string.h>

#include "el.h"
#include "common.h"
#include "fcns.h"
#include "parse.h"
#include "vi.h"

/* ed_end_of_file():
 *	Indicate end of file
 *	[^D]
 */
protected el_action_t
/*ARGSUSED*/
ed_end_of_file(EditLine *el, wint_t c __attribute__((__unused__)))
{

	re_goto_bottom(el);
	*el->el_line.lastchar = '\0';
	return CC_EOF;
}


/* ed_insert():
 *	Add character to the line
 *	Insert a character [bound to all insert keys]
 */
protected el_action_t
ed_insert(EditLine *el, wint_t c)
{
	int count = el->el_state.argument;

	if (c == '\0')
		return CC_ERROR;

	if (el->el_line.lastchar + el->el_state.argument >=
	    el->el_line.limit) {
		/* end of buffer space, try to allocate more */
		if (!ch_enlargebufs(el, (size_t) count))
			return CC_ERROR;	/* error allocating more */
	}

	if (count == 1) {
		if (el->el_state.inputmode == MODE_INSERT
		    || el->el_line.cursor >= el->el_line.lastchar)
			c_insert(el, 1);

		*el->el_line.cursor++ = c;
		re_fastaddc(el);		/* fast refresh for one char. */
	} else {
		if (el->el_state.inputmode != MODE_REPLACE_1)
			c_insert(el, el->el_state.argument);

		while (count-- && el->el_line.cursor < el->el_line.lastchar)
			*el->el_line.cursor++ = c;
		re_refresh(el);
	}

	if (el->el_state.inputmode == MODE_REPLACE_1)
		return vi_command_mode(el, 0);

	return CC_NORM;
}


/* ed_delete_prev_word():
 *	Delete from beginning of current word to cursor
 *	[M-^?] [^W]
 */
protected el_action_t
/*ARGSUSED*/
ed_delete_prev_word(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *cp, *p, *kp;

	if (el->el_line.cursor == el->el_line.buffer)
		return CC_ERROR;

	cp = c__prev_word(el->el_line.cursor, el->el_line.buffer,
	    el->el_state.argument, ce__isword);

	for (p = cp, kp = el->el_chared.c_kill.buf; p < el->el_line.cursor; p++)
		*kp++ = *p;
	el->el_chared.c_kill.last = kp;

	c_delbefore(el, (int)(el->el_line.cursor - cp));/* delete before dot */
	el->el_line.cursor = cp;
	if (el->el_line.cursor < el->el_line.buffer)
		el->el_line.cursor = el->el_line.buffer; /* bounds check */
	return CC_REFRESH;
}


/* ed_delete_next_char():
 *	Delete character under cursor
 *	[^D] [x]
 */
protected el_action_t
/*ARGSUSED*/
ed_delete_next_char(EditLine *el, wint_t c)
{
#ifdef notdef			/* XXX */
#define	EL	el->el_line
	(void) fprintf(el->el_errfile,
	    "\nD(b: %p(%ls)  c: %p(%ls) last: %p(%ls) limit: %p(%ls)\n",
	    EL.buffer, EL.buffer, EL.cursor, EL.cursor, EL.lastchar,
	    EL.lastchar, EL.limit, EL.limit);
#endif
	if (el->el_line.cursor == el->el_line.lastchar) {
			/* if I'm at the end */
		if (el->el_map.type == MAP_VI) {
			if (el->el_line.cursor == el->el_line.buffer) {
				/* if I'm also at the beginning */
#ifdef KSHVI
				return CC_ERROR;
#else
				/* then do an EOF */
				terminal_writec(el, c);
				return CC_EOF;
#endif
			} else {
#ifdef KSHVI
				el->el_line.cursor--;
#else
				return CC_ERROR;
#endif
			}
		} else {
			if (el->el_line.cursor != el->el_line.buffer)
				el->el_line.cursor--;
			else
				return CC_ERROR;
		}
	}
	c_delafter(el, el->el_state.argument);	/* delete after dot */
	if (el->el_line.cursor >= el->el_line.lastchar &&
	    el->el_line.cursor > el->el_line.buffer)
			/* bounds check */
		el->el_line.cursor = el->el_line.lastchar - 1;
	return CC_REFRESH;
}


/* ed_kill_line():
 *	Cut to the end of line
 *	[^K] [^K]
 */
protected el_action_t
/*ARGSUSED*/
ed_kill_line(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *kp, *cp;

	cp = el->el_line.cursor;
	kp = el->el_chared.c_kill.buf;
	while (cp < el->el_line.lastchar)
		*kp++ = *cp++;	/* copy it */
	el->el_chared.c_kill.last = kp;
			/* zap! -- delete to end */
	el->el_line.lastchar = el->el_line.cursor;
	return CC_REFRESH;
}


/* ed_move_to_end():
 *	Move cursor to the end of line
 *	[^E] [^E]
 */
protected el_action_t
/*ARGSUSED*/
ed_move_to_end(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_line.cursor = el->el_line.lastchar;
	if (el->el_map.type == MAP_VI) {
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return CC_REFRESH;
		}
#ifdef VI_MOVE
		el->el_line.cursor--;
#endif
	}
	return CC_CURSOR;
}


/* ed_move_to_beg():
 *	Move cursor to the beginning of line
 *	[^A] [^A]
 */
protected el_action_t
/*ARGSUSED*/
ed_move_to_beg(EditLine *el, wint_t c __attribute__((__unused__)))
{

	el->el_line.cursor = el->el_line.buffer;

	if (el->el_map.type == MAP_VI) {
			/* We want FIRST non space character */
		while (iswspace(*el->el_line.cursor))
			el->el_line.cursor++;
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return CC_REFRESH;
		}
	}
	return CC_CURSOR;
}


/* ed_transpose_chars():
 *	Exchange the character to the left of the cursor with the one under it
 *	[^T] [^T]
 */
protected el_action_t
ed_transpose_chars(EditLine *el, wint_t c)
{

	if (el->el_line.cursor < el->el_line.lastchar) {
		if (el->el_line.lastchar <= &el->el_line.buffer[1])
			return CC_ERROR;
		else
			el->el_line.cursor++;
	}
	if (el->el_line.cursor > &el->el_line.buffer[1]) {
		/* must have at least two chars entered */
		c = el->el_line.cursor[-2];
		el->el_line.cursor[-2] = el->el_line.cursor[-1];
		el->el_line.cursor[-1] = c;
		return CC_REFRESH;
	} else
		return CC_ERROR;
}


/* ed_next_char():
 *	Move to the right one character
 *	[^F] [^F]
 */
protected el_action_t
/*ARGSUSED*/
ed_next_char(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *lim = el->el_line.lastchar;

	if (el->el_line.cursor >= lim ||
	    (el->el_line.cursor == lim - 1 &&
	    el->el_map.type == MAP_VI &&
	    el->el_chared.c_vcmd.action == NOP))
		return CC_ERROR;

	el->el_line.cursor += el->el_state.argument;
	if (el->el_line.cursor > lim)
		el->el_line.cursor = lim;

	if (el->el_map.type == MAP_VI)
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return CC_REFRESH;
		}
	return CC_CURSOR;
}


/* ed_prev_word():
 *	Move to the beginning of the current word
 *	[M-b] [b]
 */
protected el_action_t
/*ARGSUSED*/
ed_prev_word(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor == el->el_line.buffer)
		return CC_ERROR;

	el->el_line.cursor = c__prev_word(el->el_line.cursor,
	    el->el_line.buffer,
	    el->el_state.argument,
	    ce__isword);

	if (el->el_map.type == MAP_VI)
		if (el->el_chared.c_vcmd.action != NOP) {
			cv_delfini(el);
			return CC_REFRESH;
		}
	return CC_CURSOR;
}


/* ed_prev_char():
 *	Move to the left one character
 *	[^B] [^B]
 */
protected el_action_t
/*ARGSUSED*/
ed_prev_char(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor > el->el_line.buffer) {
		el->el_line.cursor -= el->el_state.argument;
		if (el->el_line.cursor < el->el_line.buffer)
			el->el_line.cursor = el->el_line.buffer;

		if (el->el_map.type == MAP_VI)
			if (el->el_chared.c_vcmd.action != NOP) {
				cv_delfini(el);
				return CC_REFRESH;
			}
		return CC_CURSOR;
	} else
		return CC_ERROR;
}


/* ed_quoted_insert():
 *	Add the next character typed verbatim
 *	[^V] [^V]
 */
protected el_action_t
ed_quoted_insert(EditLine *el, wint_t c)
{
	int num;

	tty_quotemode(el);
	num = el_wgetc(el, &c);
	tty_noquotemode(el);
	if (num == 1)
		return ed_insert(el, c);
	else
		return ed_end_of_file(el, 0);
}


/* ed_digit():
 *	Adds to argument or enters a digit
 */
protected el_action_t
ed_digit(EditLine *el, wint_t c)
{

	if (!iswdigit(c))
		return CC_ERROR;

	if (el->el_state.doingarg) {
			/* if doing an arg, add this in... */
		if (el->el_state.lastcmd == EM_UNIVERSAL_ARGUMENT)
			el->el_state.argument = c - '0';
		else {
			if (el->el_state.argument > 1000000)
				return CC_ERROR;
			el->el_state.argument =
			    (el->el_state.argument * 10) + (c - '0');
		}
		return CC_ARGHACK;
	}

	return ed_insert(el, c);
}


/* ed_argument_digit():
 *	Digit that starts argument
 *	For ESC-n
 */
protected el_action_t
ed_argument_digit(EditLine *el, wint_t c)
{

	if (!iswdigit(c))
		return CC_ERROR;

	if (el->el_state.doingarg) {
		if (el->el_state.argument > 1000000)
			return CC_ERROR;
		el->el_state.argument = (el->el_state.argument * 10) +
		    (c - '0');
	} else {		/* else starting an argument */
		el->el_state.argument = c - '0';
		el->el_state.doingarg = 1;
	}
	return CC_ARGHACK;
}


/* ed_unassigned():
 *	Indicates unbound character
 *	Bound to keys that are not assigned
 */
protected el_action_t
/*ARGSUSED*/
ed_unassigned(EditLine *el, wint_t c __attribute__((__unused__)))
{

	return CC_ERROR;
}


/* ed_ignore():
 *	Input characters that have no effect
 *	[^C ^O ^Q ^S ^Z ^\ ^]] [^C ^O ^Q ^S ^\]
 */
protected el_action_t
/*ARGSUSED*/
ed_ignore(EditLine *el __attribute__((__unused__)),
	      wint_t c __attribute__((__unused__)))
{

	return CC_NORM;
}


/* ed_newline():
 *	Execute command
 *	[^J]
 */
protected el_action_t
/*ARGSUSED*/
ed_newline(EditLine *el, wint_t c __attribute__((__unused__)))
{

	re_goto_bottom(el);
	*el->el_line.lastchar++ = '\n';
	*el->el_line.lastchar = '\0';
	return CC_NEWLINE;
}


/* ed_delete_prev_char():
 *	Delete the character to the left of the cursor
 *	[^?]
 */
protected el_action_t
/*ARGSUSED*/
ed_delete_prev_char(EditLine *el, wint_t c __attribute__((__unused__)))
{

	if (el->el_line.cursor <= el->el_line.buffer)
		return CC_ERROR;

	c_delbefore(el, el->el_state.argument);
	el->el_line.cursor -= el->el_state.argument;
	if (el->el_line.cursor < el->el_line.buffer)
		el->el_line.cursor = el->el_line.buffer;
	return CC_REFRESH;
}


/* ed_clear_screen():
 *	Clear screen leaving current line at the top
 *	[^L]
 */
protected el_action_t
/*ARGSUSED*/
ed_clear_screen(EditLine *el, wint_t c __attribute__((__unused__)))
{

	terminal_clear_screen(el);	/* clear the whole real screen */
	re_clear_display(el);	/* reset everything */
	return CC_REFRESH;
}


/* ed_redisplay():
 *	Redisplay everything
 *	^R
 */
protected el_action_t
/*ARGSUSED*/
ed_redisplay(EditLine *el __attribute__((__unused__)),
	     wint_t c __attribute__((__unused__)))
{

	return CC_REDISPLAY;
}


/* ed_start_over():
 *	Erase current line and start from scratch
 *	[^G]
 */
protected el_action_t
/*ARGSUSED*/
ed_start_over(EditLine *el, wint_t c __attribute__((__unused__)))
{

	ch_reset(el);
	return CC_REFRESH;
}


/* ed_sequence_lead_in():
 *	First character in a bound sequence
 *	Placeholder for external keys
 */
protected el_action_t
/*ARGSUSED*/
ed_sequence_lead_in(EditLine *el __attribute__((__unused__)),
		    wint_t c __attribute__((__unused__)))
{

	return CC_NORM;
}


/* ed_prev_history():
 *	Move to the previous history line
 *	[^P] [k]
 */
protected el_action_t
/*ARGSUSED*/
ed_prev_history(EditLine *el, wint_t c __attribute__((__unused__)))
{
	char beep = 0;
	int sv_event = el->el_history.eventno;

	el->el_chared.c_undo.len = -1;
	*el->el_line.lastchar = '\0';		/* just in case */

	if (el->el_history.eventno == 0) {	/* save the current buffer
						 * away */
		(void) wcsncpy(el->el_history.buf, el->el_line.buffer,
		    EL_BUFSIZ);
		el->el_history.last = el->el_history.buf +
		    (el->el_line.lastchar - el->el_line.buffer);
	}
	el->el_history.eventno += el->el_state.argument;

	if (hist_get(el) == CC_ERROR) {
		if (el->el_map.type == MAP_VI) {
			el->el_history.eventno = sv_event;
		}
		beep = 1;
		/* el->el_history.eventno was fixed by first call */
		(void) hist_get(el);
	}
	if (beep)
		return CC_REFRESH_BEEP;
	return CC_REFRESH;
}


/* ed_next_history():
 *	Move to the next history line
 *	[^N] [j]
 */
protected el_action_t
/*ARGSUSED*/
ed_next_history(EditLine *el, wint_t c __attribute__((__unused__)))
{
	el_action_t beep = CC_REFRESH, rval;

	el->el_chared.c_undo.len = -1;
	*el->el_line.lastchar = '\0';	/* just in case */

	el->el_history.eventno -= el->el_state.argument;

	if (el->el_history.eventno < 0) {
		el->el_history.eventno = 0;
		beep = CC_REFRESH_BEEP;
	}
	rval = hist_get(el);
	if (rval == CC_REFRESH)
		return beep;
	return rval;

}


/* ed_search_prev_history():
 *	Search previous in history for a line matching the current
 *	next search history [M-P] [K]
 */
protected el_action_t
/*ARGSUSED*/
ed_search_prev_history(EditLine *el, wint_t c __attribute__((__unused__)))
{
	const wchar_t *hp;
	int h;
	int found = 0;

	el->el_chared.c_vcmd.action = NOP;
	el->el_chared.c_undo.len = -1;
	*el->el_line.lastchar = '\0';	/* just in case */
	if (el->el_history.eventno < 0) {
#ifdef DEBUG_EDIT
		(void) fprintf(el->el_errfile,
		    "e_prev_search_hist(): eventno < 0;\n");
#endif
		el->el_history.eventno = 0;
		return CC_ERROR;
	}
	if (el->el_history.eventno == 0) {
		(void) wcsncpy(el->el_history.buf, el->el_line.buffer,
		    EL_BUFSIZ);
		el->el_history.last = el->el_history.buf +
		    (el->el_line.lastchar - el->el_line.buffer);
	}
	if (el->el_history.ref == NULL)
		return CC_ERROR;

	hp = HIST_FIRST(el);
	if (hp == NULL)
		return CC_ERROR;

	c_setpat(el);		/* Set search pattern !! */

	for (h = 1; h <= el->el_history.eventno; h++)
		hp = HIST_NEXT(el);

	while (hp != NULL) {
#ifdef SDEBUG
		(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
#endif
		if ((wcsncmp(hp, el->el_line.buffer, (size_t)
			    (el->el_line.lastchar - el->el_line.buffer)) ||
			hp[el->el_line.lastchar - el->el_line.buffer]) &&
		    c_hmatch(el, hp)) {
			found = 1;
			break;
		}
		h++;
		hp = HIST_NEXT(el);
	}

	if (!found) {
#ifdef SDEBUG
		(void) fprintf(el->el_errfile, "not found\n");
#endif
		return CC_ERROR;
	}
	el->el_history.eventno = h;

	return hist_get(el);
}


/* ed_search_next_history():
 *	Search next in history for a line matching the current
 *	[M-N] [J]
 */
protected el_action_t
/*ARGSUSED*/
ed_search_next_history(EditLine *el, wint_t c __attribute__((__unused__)))
{
	const wchar_t *hp;
	int h;
	int found = 0;

	el->el_chared.c_vcmd.action = NOP;
	el->el_chared.c_undo.len = -1;
	*el->el_line.lastchar = '\0';	/* just in case */

	if (el->el_history.eventno == 0)
		return CC_ERROR;

	if (el->el_history.ref == NULL)
		return CC_ERROR;

	hp = HIST_FIRST(el);
	if (hp == NULL)
		return CC_ERROR;

	c_setpat(el);		/* Set search pattern !! */

	for (h = 1; h < el->el_history.eventno && hp; h++) {
#ifdef SDEBUG
		(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
#endif
		if ((wcsncmp(hp, el->el_line.buffer, (size_t)
			    (el->el_line.lastchar - el->el_line.buffer)) ||
			hp[el->el_line.lastchar - el->el_line.buffer]) &&
		    c_hmatch(el, hp))
			found = h;
		hp = HIST_NEXT(el);
	}

	if (!found) {		/* is it the current history number? */
		if (!c_hmatch(el, el->el_history.buf)) {
#ifdef SDEBUG
			(void) fprintf(el->el_errfile, "not found\n");
#endif
			return CC_ERROR;
		}
	}
	el->el_history.eventno = found;

	return hist_get(el);
}


/* ed_prev_line():
 *	Move up one line
 *	Could be [k] [^p]
 */
protected el_action_t
/*ARGSUSED*/
ed_prev_line(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *ptr;
	int nchars = c_hpos(el);

	/*
         * Move to the line requested
         */
	if (*(ptr = el->el_line.cursor) == '\n')
		ptr--;

	for (; ptr >= el->el_line.buffer; ptr--)
		if (*ptr == '\n' && --el->el_state.argument <= 0)
			break;

	if (el->el_state.argument > 0)
		return CC_ERROR;

	/*
         * Move to the beginning of the line
         */
	for (ptr--; ptr >= el->el_line.buffer && *ptr != '\n'; ptr--)
		continue;

	/*
         * Move to the character requested
         */
	for (ptr++;
	    nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n';
	    ptr++)
		continue;

	el->el_line.cursor = ptr;
	return CC_CURSOR;
}


/* ed_next_line():
 *	Move down one line
 *	Could be [j] [^n]
 */
protected el_action_t
/*ARGSUSED*/
ed_next_line(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t *ptr;
	int nchars = c_hpos(el);

	/*
         * Move to the line requested
         */
	for (ptr = el->el_line.cursor; ptr < el->el_line.lastchar; ptr++)
		if (*ptr == '\n' && --el->el_state.argument <= 0)
			break;

	if (el->el_state.argument > 0)
		return CC_ERROR;

	/*
         * Move to the character requested
         */
	for (ptr++;
	    nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n';
	    ptr++)
		continue;

	el->el_line.cursor = ptr;
	return CC_CURSOR;
}


/* ed_command():
 *	Editline extended command
 *	[M-X] [:]
 */
protected el_action_t
/*ARGSUSED*/
ed_command(EditLine *el, wint_t c __attribute__((__unused__)))
{
	wchar_t tmpbuf[EL_BUFSIZ];
	int tmplen;

	tmplen = c_gets(el, tmpbuf, L"\n: ");
	terminal__putc(el, '\n');

	if (tmplen < 0 || (tmpbuf[tmplen] = 0, parse_line(el, tmpbuf)) == -1)
		terminal_beep(el);

	el->el_map.current = el->el_map.key;
	re_clear_display(el);
	return CC_REFRESH;
}
@


1.21
log
@Replace the generated file "fcns.c" by a simpler header "func.h"
included only in the one file needing it, "map.c".
That allows to define el_action_t directly in "map.h",
which in turn allows to stop including "fcns.h" from "el.h"
and include it only in the modules needing it.
Now we no longer autogenerate any C files.

Feedback and OK martijn@@.
First version also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.20 2016/04/18 20:13:07 schwarze Exp $	*/
d529 1
a529 1
	ch_reset(el, 0);
@


1.20
log
@Delete redundant, empty callbacks;
no functional change, minus hundred lines of code.
OK martijn@@;
also proof-read by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.19 2016/04/11 20:43:33 schwarze Exp $	*/
d46 1
@


1.19
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.18 2016/04/11 19:54:54 schwarze Exp $	*/
d440 3
a442 7
/**
 ** TTY key handling.
 **/

/* ed_tty_sigint():
 *	Tty interrupt character
 *	[^C]
d446 1
a446 1
ed_tty_sigint(EditLine *el __attribute__((__unused__)),
a447 84
{

	return CC_NORM;
}


/* ed_tty_dsusp():
 *	Tty delayed suspend character
 *	[^Y]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_dsusp(EditLine *el __attribute__((__unused__)),
	     wint_t c __attribute__((__unused__)))
{

	return CC_NORM;
}


/* ed_tty_flush_output():
 *	Tty flush output characters
 *	[^O]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_flush_output(EditLine *el __attribute__((__unused__)),
		    wint_t c __attribute__((__unused__)))
{

	return CC_NORM;
}


/* ed_tty_sigquit():
 *	Tty quit character
 *	[^\]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_sigquit(EditLine *el __attribute__((__unused__)),
	       wint_t c __attribute__((__unused__)))
{

	return CC_NORM;
}


/* ed_tty_sigtstp():
 *	Tty suspend character
 *	[^Z]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_sigtstp(EditLine *el __attribute__((__unused__)),
	       wint_t c __attribute__((__unused__)))
{

	return CC_NORM;
}


/* ed_tty_stop_output():
 *	Tty disallow output characters
 *	[^S]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_stop_output(EditLine *el __attribute__((__unused__)),
		   wint_t c __attribute__((__unused__)))
{

	return CC_NORM;
}


/* ed_tty_start_output():
 *	Tty allow output characters
 *	[^Q]
 */
protected el_action_t
/*ARGSUSED*/
ed_tty_start_output(EditLine *el __attribute__((__unused__)),
		    wint_t c __attribute__((__unused__)))
@


1.18
log
@Move wrapper macros to the two files actually needing them:
FUNW, Strlen, Strdup, Strcmp, Strncmp, Strncpy, Strncat -> history.c
Strchr, tok_strdup -> tokenizer.c
FUN, TYPE, STR -> both of these files

OK martijn@@

Also proofread by Christian Heckendorf <mbie at ulmus dot me>
who reported some whitespace issues in parse.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.17 2016/04/09 20:15:26 schwarze Exp $	*/
d114 1
a114 1
	Char *cp, *p, *kp;
d192 1
a192 1
	Char *kp, *cp;
d285 1
a285 1
	Char *lim = el->el_line.lastchar;
d707 1
a707 1
	const Char *hp;
d775 1
a775 1
	const Char *hp;
d829 1
a829 1
	Char *ptr;
d872 1
a872 1
	Char *ptr;
d906 1
a906 1
	Char tmpbuf[EL_BUFSIZ];
@


1.17
log
@Delete 26 wrapper macros and two wrapper functions that are no
longer needed now that we always compile with wide character support,
reducing code obfuscation.

OK czarkoff@@ martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.16 2016/03/22 11:32:18 schwarze Exp $	*/
d651 1
a651 1
		(void) Strncpy(el->el_history.buf, el->el_line.buffer,
d723 1
a723 1
		(void) Strncpy(el->el_history.buf, el->el_line.buffer,
d744 1
a744 1
		if ((Strncmp(hp, el->el_line.buffer, (size_t)
d799 1
a799 1
		if ((Strncmp(hp, el->el_line.buffer, (size_t)
d909 1
a909 1
	tmplen = c_gets(el, tmpbuf, STR("\n: "));
@


1.16
log
@format string fixes in debug code;
committing right away because this code is not even compiled by default
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.15 2016/03/21 15:25:39 schwarze Exp $	*/
d145 1
a145 2
	    "\nD(b: %p(" FSTR ")  c: %p(" FSTR ") last: %p(" FSTR
	    ") limit: %p(" FSTR ")\n",
d241 1
a241 1
		while (Isspace(*el->el_line.cursor))
d383 1
a383 1
	if (!Isdigit(c))
d411 1
a411 1
	if (!Isdigit(c))
@


1.15
log
@Reduce the FUN() macro madness by no longer applying it to el_[w]getc(3).
Always use el_wgetc(3) internally.  In the !WIDECHAR case, casting
the result to (Char) is safe because the function returns a byte
rather than a character in that case.
No functional change except for fixing a printf(3) format string issue
when compiled with DEBUG_READ and WIDECHAR.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.14 2016/03/20 23:48:27 schwarze Exp $	*/
d144 3
a146 2
	(void) fprintf(el->el_errlfile,
	    "\nD(b: %x(%s)  c: %x(%s) last: %x(%s) limit: %x(%s)\n",
@


1.14
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.13 2016/03/20 23:24:18 schwarze Exp $	*/
a364 1
	Char tc;
d367 1
a367 2
	num = FUN(el,getc)(el, &tc);
	c = tc;
@


1.13
log
@delete useless "typedef int bool_t", use int directly;
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.12 2016/03/20 22:57:59 schwarze Exp $	*/
d41 3
d452 1
a452 1
ed_tty_sigint(EditLine *el __attribute__((__unused__)), 
d466 1
a466 1
ed_tty_dsusp(EditLine *el __attribute__((__unused__)), 
d480 1
a480 1
ed_tty_flush_output(EditLine *el __attribute__((__unused__)), 
d494 1
a494 1
ed_tty_sigquit(EditLine *el __attribute__((__unused__)), 
d508 1
a508 1
ed_tty_sigtstp(EditLine *el __attribute__((__unused__)), 
d522 1
a522 1
ed_tty_stop_output(EditLine *el __attribute__((__unused__)), 
d536 1
a536 1
ed_tty_start_output(EditLine *el __attribute__((__unused__)), 
d601 1
a601 1
ed_redisplay(EditLine *el __attribute__((__unused__)), 
d629 1
a629 1
ed_sequence_lead_in(EditLine *el __attribute__((__unused__)), 
a662 1
			
@


1.12
log
@Cleanup of private header inclusion:

1. Do not include private headers from "chared.h", "hist.h", "prompt.h",
"refresh.h", "search.h", "sig.h", "terminal.h", "tty.h".
The only private header having to include other private headers is "el.h".
2. Do not include "common.h", "parse.h", "help.h" from "el.h",
and do not include "emacs.h" and "vi.h" from "chared.h",
include them directly where needed.
3. Do include "fcns.h" from "el.h" because el_func_t is needed for "map.h".
4. Do not include private headers again that are already included by "el.h".
5. Include private headers after standard headers.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.11 2016/03/20 20:35:38 schwarze Exp $	*/
d709 1
a709 1
	bool_t found = 0;
d748 1
a748 1
			found++;
d777 1
a777 1
	bool_t found = 0;
@


1.11
log
@Delete the useless Int datatype and always use the standard wint_t
directly.  This is not a problem because <wchar_t> is required all
over the place anyway, even when WIDECHAR is not defined.
No functional change except that it fixes a few printf(3)
format string issues, %c vs. %lc.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.10 2016/01/30 12:22:20 schwarze Exp $	*/
d42 3
@


1.10
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.9 2016/01/30 00:06:39 schwarze Exp $	*/
d49 1
a49 1
ed_end_of_file(EditLine *el, Int c __attribute__((__unused__)))
d63 1
a63 1
ed_insert(EditLine *el, Int c)
d106 1
a106 1
ed_delete_prev_word(EditLine *el, Int c __attribute__((__unused__)))
d134 1
a134 1
ed_delete_next_char(EditLine *el, Int c)
d184 1
a184 1
ed_kill_line(EditLine *el, Int c __attribute__((__unused__)))
d205 1
a205 1
ed_move_to_end(EditLine *el, Int c __attribute__((__unused__)))
d228 1
a228 1
ed_move_to_beg(EditLine *el, Int c __attribute__((__unused__)))
d251 1
a251 1
ed_transpose_chars(EditLine *el, Int c)
d277 1
a277 1
ed_next_char(EditLine *el, Int c __attribute__((__unused__)))
d306 1
a306 1
ed_prev_word(EditLine *el, Int c __attribute__((__unused__)))
d332 1
a332 1
ed_prev_char(EditLine *el, Int c __attribute__((__unused__)))
d356 1
a356 1
ed_quoted_insert(EditLine *el, Int c)
d376 1
a376 1
ed_digit(EditLine *el, Int c)
d404 1
a404 1
ed_argument_digit(EditLine *el, Int c)
d429 1
a429 1
ed_unassigned(EditLine *el, Int c __attribute__((__unused__)))
d447 1
a447 1
	      Int c __attribute__((__unused__)))
d461 1
a461 1
	     Int c __attribute__((__unused__)))
d475 1
a475 1
		    Int c __attribute__((__unused__)))
d489 1
a489 1
	       Int c __attribute__((__unused__)))
d503 1
a503 1
	       Int c __attribute__((__unused__)))
d517 1
a517 1
		   Int c __attribute__((__unused__)))
d531 1
a531 1
		    Int c __attribute__((__unused__)))
d544 1
a544 1
ed_newline(EditLine *el, Int c __attribute__((__unused__)))
d560 1
a560 1
ed_delete_prev_char(EditLine *el, Int c __attribute__((__unused__)))
d580 1
a580 1
ed_clear_screen(EditLine *el, Int c __attribute__((__unused__)))
d596 1
a596 1
	     Int c __attribute__((__unused__)))
d609 1
a609 1
ed_start_over(EditLine *el, Int c __attribute__((__unused__)))
d624 1
a624 1
		    Int c __attribute__((__unused__)))
d637 1
a637 1
ed_prev_history(EditLine *el, Int c __attribute__((__unused__)))
d675 1
a675 1
ed_next_history(EditLine *el, Int c __attribute__((__unused__)))
d702 1
a702 1
ed_search_prev_history(EditLine *el, Int c __attribute__((__unused__)))
d770 1
a770 1
ed_search_next_history(EditLine *el, Int c __attribute__((__unused__)))
d824 1
a824 1
ed_prev_line(EditLine *el, Int c __attribute__((__unused__)))
d867 1
a867 1
ed_next_line(EditLine *el, Int c __attribute__((__unused__)))
d901 1
a901 1
ed_command(EditLine *el, Int c __attribute__((__unused__)))
@


1.9
log
@Third step in synching with NetBSD:
* rename fkey_t to funckey_t and el_term_t to el_terminal_t
* rename struct editline member el_term to el_terminal
* rename many functions in terminal.c from term_*() to terminal_*(),
for consistency with the file name and to not look related to <term.h>
No functional change.
This makes refresh.c and sig.c almost identical to the NetBSD versions.
It reduces the remaining diff from +2446 -1805 to +2053 -1420.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.8 2010/06/30 00:05:35 nicm Exp $	*/
d54 1
a54 1
	return (CC_EOF);
d68 1
a68 1
		return (CC_ERROR);
d96 1
a96 1
	return (CC_NORM);
d111 1
a111 1
		return (CC_ERROR);
d124 1
a124 1
	return (CC_REFRESH);
d149 1
a149 1
				return (CC_ERROR);
d153 1
a153 1
				return (CC_EOF);
d159 1
a159 1
				return (CC_ERROR);
d166 1
a166 1
				return (CC_ERROR);
d174 1
a174 1
	return (CC_REFRESH);
d195 1
a195 1
	return (CC_REFRESH);
d212 1
a212 1
			return (CC_REFRESH);
d218 1
a218 1
	return (CC_CURSOR);
d239 1
a239 1
			return (CC_REFRESH);
d242 1
a242 1
	return (CC_CURSOR);
d256 1
a256 1
			return (CC_ERROR);
d265 1
a265 1
		return (CC_REFRESH);
d267 1
a267 1
		return (CC_ERROR);
d285 1
a285 1
		return (CC_ERROR);
d294 1
a294 1
			return (CC_REFRESH);
d296 1
a296 1
	return (CC_CURSOR);
d310 1
a310 1
		return (CC_ERROR);
d320 1
a320 1
			return (CC_REFRESH);
d322 1
a322 1
	return (CC_CURSOR);
d343 1
a343 1
				return (CC_REFRESH);
d345 1
a345 1
		return (CC_CURSOR);
d347 1
a347 1
		return (CC_ERROR);
d366 1
a366 1
		return (ed_insert(el, c));
d368 1
a368 1
		return (ed_end_of_file(el, 0));
d380 1
a380 1
		return (CC_ERROR);
d388 1
a388 1
				return (CC_ERROR);
d392 1
a392 1
		return (CC_ARGHACK);
d408 1
a408 1
		return (CC_ERROR);
d412 1
a412 1
			return (CC_ERROR);
d419 1
a419 1
	return (CC_ARGHACK);
d432 1
a432 1
	return (CC_ERROR);
d450 1
a450 1
	return (CC_NORM);
d464 1
a464 1
	return (CC_NORM);
d478 1
a478 1
	return (CC_NORM);
d492 1
a492 1
	return (CC_NORM);
d506 1
a506 1
	return (CC_NORM);
d520 1
a520 1
	return (CC_NORM);
d534 1
a534 1
	return (CC_NORM);
d550 1
a550 1
	return (CC_NEWLINE);
d564 1
a564 1
		return (CC_ERROR);
d570 1
a570 1
	return (CC_REFRESH);
d585 1
a585 1
	return (CC_REFRESH);
d599 1
a599 1
	return (CC_REDISPLAY);
d613 1
a613 1
	return (CC_REFRESH);
d627 1
a627 1
	return (CC_NORM);
d717 1
a717 1
		return (CC_ERROR);
d726 1
a726 1
		return (CC_ERROR);
d730 1
a730 1
		return (CC_ERROR);
d756 1
a756 1
		return (CC_ERROR);
d760 1
a760 1
	return (hist_get(el));
d781 1
a781 1
		return (CC_ERROR);
d784 1
a784 1
		return (CC_ERROR);
d788 1
a788 1
		return (CC_ERROR);
d809 1
a809 1
			return (CC_ERROR);
d814 1
a814 1
	return (hist_get(el));
d840 1
a840 1
		return (CC_ERROR);
d857 1
a857 1
	return (CC_CURSOR);
d880 1
a880 1
		return (CC_ERROR);
d891 1
a891 1
	return (CC_CURSOR);
@


1.8
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d152 1
a152 1
				term_writec(el, c);
d583 1
a583 1
	term_clear_screen(el);	/* clear the whole real screen */
d907 1
a907 1
	term__putc(el, '\n');
d910 1
a910 1
		term_beep(el);
@


1.7
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
a2 2
/*	$OpenBSD: common.c,v 1.6 2003/10/31 08:42:24 otto Exp $	*/
/*	$NetBSD: common.c,v 1.16 2003/08/07 16:44:30 agc Exp $	*/
d49 1
a49 1
ed_end_of_file(EditLine *el, int c __attribute__((__unused__)))
d63 1
a63 1
ed_insert(EditLine *el, int c)
d106 1
a106 1
ed_delete_prev_word(EditLine *el, int c __attribute__((__unused__)))
d108 1
a108 1
	char *cp, *p, *kp;
d120 1
a120 1
	c_delbefore(el, el->el_line.cursor - cp);	/* delete before dot */
d134 1
a134 1
ed_delete_next_char(EditLine *el, int c __attribute__((__unused__)))
d151 2
a152 3
				term_overwrite(el, STReof, 4);
					/* then do a EOF */
				term__flush();
d184 1
a184 1
ed_kill_line(EditLine *el, int c __attribute__((__unused__)))
d186 1
a186 1
	char *kp, *cp;
d205 1
a205 1
ed_move_to_end(EditLine *el, int c __attribute__((__unused__)))
a209 3
#ifdef VI_MOVE
		el->el_line.cursor--;
#endif
d214 3
d228 1
a228 1
ed_move_to_beg(EditLine *el, int c __attribute__((__unused__)))
d235 1
a235 1
		while (isspace((unsigned char) *el->el_line.cursor))
d251 1
a251 1
ed_transpose_chars(EditLine *el, int c)
d277 1
a277 1
ed_next_char(EditLine *el, int c __attribute__((__unused__)))
d279 1
a279 1
	char *lim = el->el_line.lastchar;
d306 1
a306 1
ed_prev_word(EditLine *el, int c __attribute__((__unused__)))
d332 1
a332 1
ed_prev_char(EditLine *el, int c __attribute__((__unused__)))
d356 1
a356 1
ed_quoted_insert(EditLine *el, int c)
d359 1
a359 1
	char tc;
d362 2
a363 2
	num = el_getc(el, &tc);
	c = (unsigned char) tc;
d376 1
a376 1
ed_digit(EditLine *el, int c)
d379 1
a379 1
	if (!isdigit(c))
d404 1
a404 1
ed_argument_digit(EditLine *el, int c)
d407 1
a407 1
	if (!isdigit(c))
d429 1
a429 1
ed_unassigned(EditLine *el, int c __attribute__((__unused__)))
d447 1
a447 1
	      int c __attribute__((__unused__)))
d461 1
a461 1
	     int c __attribute__((__unused__)))
d475 1
a475 1
		    int c __attribute__((__unused__)))
d489 1
a489 1
	       int c __attribute__((__unused__)))
d503 1
a503 1
	       int c __attribute__((__unused__)))
d517 1
a517 1
		   int c __attribute__((__unused__)))
d531 1
a531 1
		    int c __attribute__((__unused__)))
d544 1
a544 1
ed_newline(EditLine *el, int c __attribute__((__unused__)))
d560 1
a560 1
ed_delete_prev_char(EditLine *el, int c __attribute__((__unused__)))
d580 1
a580 1
ed_clear_screen(EditLine *el, int c __attribute__((__unused__)))
d596 1
a596 1
	     int c __attribute__((__unused__)))
d609 1
a609 1
ed_start_over(EditLine *el, int c __attribute__((__unused__)))
d612 1
a612 1
	ch_reset(el);
d624 1
a624 1
		    int c __attribute__((__unused__)))
d637 1
a637 1
ed_prev_history(EditLine *el, int c __attribute__((__unused__)))
d647 1
a647 1
		(void) strncpy(el->el_history.buf, el->el_line.buffer,
d657 1
a657 1
			return CC_ERROR;
d675 1
a675 1
ed_next_history(EditLine *el, int c __attribute__((__unused__)))
d702 1
a702 1
ed_search_prev_history(EditLine *el, int c __attribute__((__unused__)))
d704 1
a704 1
	const char *hp;
d720 1
a720 1
		(void) strncpy(el->el_history.buf, el->el_line.buffer,
d741 1
a741 1
		if ((strncmp(hp, el->el_line.buffer, (size_t)
d770 1
a770 1
ed_search_next_history(EditLine *el, int c __attribute__((__unused__)))
d772 1
a772 1
	const char *hp;
d796 1
a796 1
		if ((strncmp(hp, el->el_line.buffer, (size_t)
d824 1
a824 1
ed_prev_line(EditLine *el, int c __attribute__((__unused__)))
d826 1
a826 1
	char *ptr;
d867 1
a867 1
ed_next_line(EditLine *el, int c __attribute__((__unused__)))
d869 1
a869 1
	char *ptr;
d901 1
a901 1
ed_command(EditLine *el, int c __attribute__((__unused__)))
d903 1
a903 1
	char tmpbuf[EL_BUFSIZ];
d906 2
a907 2
	tmplen = c_gets(el, tmpbuf, "\n: ");
	term__putc('\n');
@


1.6
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 7
#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)common.c	8.1 (Berkeley) 6/4/93";
#else
static const char rcsid[] = "$OpenBSD$";
#endif
#endif /* not lint && not SCCSID */
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: common.c,v 1.4 2003/05/01 21:11:21 avsm Exp $	*/
/*	$NetBSD: common.c,v 1.3 1997/01/14 04:17:22 lukem Exp $	*/
d36 1
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.4 2003/05/01 21:11:21 avsm Exp $";
a47 1
#include "sys.h"
d50 1
a50 1
/* ed_end_of_file(): 
d56 1
a56 3
ed_end_of_file(el, c)
    EditLine *el;
    int c;
d58 4
a61 3
    re_goto_bottom(el);
    *el->el_line.lastchar = '\0';
    return CC_EOF;
d65 1
a65 1
/* ed_insert(): 
d70 1
a70 3
ed_insert(el, c)
    EditLine *el;
    int c;
d72 1
a72 1
    int i;
d74 2
a75 2
    if (c == '\0')
	return CC_ERROR;
d77 6
a82 3
    if (el->el_line.lastchar + el->el_state.argument >= 
	el->el_line.limit)
	return CC_ERROR;	/* end of buffer space */
d84 15
a98 24
    if (el->el_state.argument == 1) {
	if (el->el_state.inputmode != MODE_INSERT) {
	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize++] = 
		*el->el_line.cursor;
	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize] = '\0';
	    c_delafter(el, 1);   
    	}

        c_insert(el, 1);

	*el->el_line.cursor++ = c;
	el->el_state.doingarg = 0;		/* just in case */
	re_fastaddc(el);			/* fast refresh for one char. */
    }
    else {
	if (el->el_state.inputmode != MODE_INSERT) {

	    for(i = 0;i < el->el_state.argument; i++) 
		el->el_chared.c_undo.buf[el->el_chared.c_undo.isize++] = 
			el->el_line.cursor[i];

	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize] = '\0';
	    c_delafter(el, el->el_state.argument);   
    	}
d100 2
a101 1
        c_insert(el, el->el_state.argument);
d103 1
a103 9
	while (el->el_state.argument--)
	    *el->el_line.cursor++ = c;
	re_refresh(el);
    }

    if (el->el_state.inputmode == MODE_REPLACE_1)
	(void)vi_command_mode(el, 0);

    return CC_NORM;
d107 1
a107 1
/* ed_delete_prev_word(): 
d113 1
a113 3
ed_delete_prev_word(el, c)
    EditLine *el;
    int c;
d115 1
a115 1
    char *cp, *p, *kp;
d117 2
a118 2
    if (el->el_line.cursor == el->el_line.buffer)
	return CC_ERROR;
d120 2
a121 2
    cp = c__prev_word(el->el_line.cursor, el->el_line.buffer, 
		      el->el_state.argument, ce__isword);
d123 3
a125 3
    for (p = cp, kp = el->el_chared.c_kill.buf; p < el->el_line.cursor; p++)
	*kp++ = *p;
    el->el_chared.c_kill.last = kp;
d127 5
a131 5
    c_delbefore(el, el->el_line.cursor - cp);	/* delete before dot */
    el->el_line.cursor = cp;
    if (el->el_line.cursor < el->el_line.buffer)
	el->el_line.cursor = el->el_line.buffer;	/* bounds check */
    return CC_REFRESH;
d135 1
a135 1
/* ed_delete_next_char(): 
d141 8
a148 8
ed_delete_next_char(el, c)
    EditLine *el;
    int c;
{
#ifdef notdef /* XXX */
#define EL el->el_line
fprintf(stderr, "\nD(b: %x(%s)  c: %x(%s) last: %x(%s) limit: %x(%s)\n", 
	EL.buffer, EL.buffer, EL.cursor, EL.cursor, EL.lastchar, EL.lastchar, EL.limit, EL.limit);
d150 5
a154 4
    if (el->el_line.cursor == el->el_line.lastchar) {/* if I'm at the end */
	if (el->el_map.type == MAP_VI) {
	    if (el->el_line.cursor == el->el_line.buffer) {	
		/* if I'm also at the beginning */
d156 1
a156 1
		return CC_ERROR;
d158 4
a161 3
		term_overwrite(el, STReof, 4);/* then do a EOF */
		term__flush();
		return CC_EOF;
d163 1
a163 2
	    }
	    else  {
d165 1
a165 1
		el->el_line.cursor--;
d167 1
a167 1
		return CC_ERROR;
d169 7
a175 1
	    }
d177 6
a182 11
	else {
	    if (el->el_line.cursor != el->el_line.buffer)
		el->el_line.cursor--;
	    else
		return CC_ERROR;
	}
    }
    c_delafter(el, el->el_state.argument);	/* delete after dot */
    if (el->el_line.cursor >= el->el_line.lastchar && el->el_line.cursor > el->el_line.buffer)
	el->el_line.cursor = el->el_line.lastchar - 1;	/* bounds check */
    return CC_REFRESH;
d186 1
a186 1
/* ed_kill_line(): 
d192 1
a192 3
ed_kill_line(el, c)
    EditLine *el;
    int c;
d194 1
a194 1
    char *kp, *cp;
d196 8
a203 7
    cp = el->el_line.cursor;
    kp = el->el_chared.c_kill.buf;
    while (cp < el->el_line.lastchar)
	*kp++ = *cp++;		/* copy it */
    el->el_chared.c_kill.last = kp;
    el->el_line.lastchar = el->el_line.cursor; /* zap! -- delete to end */
    return CC_REFRESH;
d207 1
a207 1
/* ed_move_to_end(): 
d213 1
a213 3
ed_move_to_end(el, c)
    EditLine *el;
    int c;
d215 3
a217 2
    el->el_line.cursor = el->el_line.lastchar;
    if (el->el_map.type == MAP_VI) {
d219 1
a219 1
	el->el_line.cursor--;
d221 4
a224 3
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
d226 1
a226 2
    }
    return CC_CURSOR;
d230 1
a230 1
/* ed_move_to_beg(): 
d236 1
a236 3
ed_move_to_beg(el, c)
    EditLine *el;
    int c;
a237 1
    el->el_line.cursor = el->el_line.buffer;
d239 10
a248 7
    if (el->el_map.type == MAP_VI) {
        /* We want FIRST non space character */
        while (isspace(*el->el_line.cursor)) 
	    el->el_line.cursor++;
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
d250 1
a250 3
    }

    return CC_CURSOR;
d254 1
a254 1
/* ed_transpose_chars(): 
d259 17
a275 19
ed_transpose_chars(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor < el->el_line.lastchar) {
	if (el->el_line.lastchar <= &el->el_line.buffer[1])
	    return CC_ERROR;
	else 
	    el->el_line.cursor++;
    }
    if (el->el_line.cursor > &el->el_line.buffer[1]) {
	/* must have at least two chars entered */
	c = el->el_line.cursor[-2];
	el->el_line.cursor[-2] = el->el_line.cursor[-1];
	el->el_line.cursor[-1] = c;
	return CC_REFRESH;
    }
    else 
	return CC_ERROR;
d279 1
a279 1
/* ed_next_char(): 
d285 1
a285 3
ed_next_char(el, c)
    EditLine *el;
    int c;
d287 1
a287 2
    if (el->el_line.cursor >= el->el_line.lastchar)
	return CC_ERROR;
d289 9
a297 3
    el->el_line.cursor += el->el_state.argument;
    if (el->el_line.cursor > el->el_line.lastchar)
	el->el_line.cursor = el->el_line.lastchar;
d299 6
a304 7
    if (el->el_map.type == MAP_VI)
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}

    return CC_CURSOR;
d308 1
a308 1
/* ed_prev_word(): 
d314 1
a314 3
ed_prev_word(el, c)
    EditLine *el;
    int c;
a315 2
    if (el->el_line.cursor == el->el_line.buffer)
	return CC_ERROR;
d317 2
a318 3
    el->el_line.cursor = c__prev_word(el->el_line.cursor, el->el_line.buffer, 
				      el->el_state.argument, 
				      ce__isword);
d320 4
a323 5
    if (el->el_map.type == MAP_VI)
	if (el->el_chared.c_vcmd.action & DELETE) {
	    cv_delfini(el);
	    return CC_REFRESH;
	}
d325 6
a330 1
    return CC_CURSOR;
d334 1
a334 1
/* ed_prev_char(): 
d340 1
a340 3
ed_prev_char(el, c)
    EditLine *el;
    int c;
a341 4
    if (el->el_line.cursor > el->el_line.buffer) {
	el->el_line.cursor -= el->el_state.argument;
	if (el->el_line.cursor < el->el_line.buffer)
	    el->el_line.cursor = el->el_line.buffer;
d343 4
a346 5
	if (el->el_map.type == MAP_VI)
	    if (el->el_chared.c_vcmd.action & DELETE) {
		cv_delfini(el);
		return CC_REFRESH;
	    }
d348 8
a355 4
	return CC_CURSOR;
    }
    else 
	return CC_ERROR;
d359 1
a359 1
/* ed_quoted_insert(): 
d364 13
a376 15
ed_quoted_insert(el, c)
    EditLine *el;
    int c;
{
    int     num;
    char    tc;

    tty_quotemode(el);
    num = el_getc(el, &tc);
    c = (unsigned char) tc;
    tty_noquotemode(el);
    if (num == 1)
	return ed_insert(el, c);
    else
	return ed_end_of_file(el, 0);
d380 1
a380 1
/* ed_digit(): 
d384 20
a403 35
ed_digit(el, c)
    EditLine *el;
    int c;
{
    if (!isdigit(c))
	return CC_ERROR;

    if (el->el_state.doingarg) {	
	/* if doing an arg, add this in... */
	if (el->el_state.lastcmd == EM_UNIVERSAL_ARGUMENT)	
	    el->el_state.argument = c - '0';
	else {
	    if (el->el_state.argument > 1000000)
		return CC_ERROR;
	    el->el_state.argument = 
		(el->el_state.argument * 10) + (c - '0');
	}
	return CC_ARGHACK;
    }
    else {
	if (el->el_line.lastchar + 1 >= el->el_line.limit)
	    return CC_ERROR;

	if (el->el_state.inputmode != MODE_INSERT) {
	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize++] = 
		*el->el_line.cursor;
	    el->el_chared.c_undo.buf[el->el_chared.c_undo.isize] = '\0';
	    c_delafter(el, 1);  
    	}
	c_insert(el, 1);
	*el->el_line.cursor++ = c;
	el->el_state.doingarg = 0;
	re_fastaddc(el);
    }
    return CC_NORM;
d407 1
a407 1
/* ed_argument_digit(): 
d412 16
a427 17
ed_argument_digit(el, c)
    EditLine *el;
    register int c;
{
    if (!isdigit(c))
	return CC_ERROR;

    if (el->el_state.doingarg) {
	if (el->el_state.argument > 1000000)
	    return CC_ERROR;
	el->el_state.argument = (el->el_state.argument * 10) + (c - '0');
    }
    else {			/* else starting an argument */
	el->el_state.argument = c - '0';
	el->el_state.doingarg = 1;
    }
    return CC_ARGHACK;
d431 1
a431 1
/* ed_unassigned(): 
d437 4
a440 7
ed_unassigned(el, c)
    EditLine *el;
    int c;
{
    term_beep(el);
    term__flush();
    return CC_NORM;
d448 1
a448 1
/* ed_tty_sigint(): 
d454 5
a458 5
ed_tty_sigint(el, c)
    EditLine *el;
    int c;
{			
    return CC_NORM;
d462 1
a462 1
/* ed_tty_dsusp(): 
d468 2
a469 3
ed_tty_dsusp(el, c)
    EditLine *el;
    int c;
d471 2
a472 1
    return CC_NORM;
d476 1
a476 1
/* ed_tty_flush_output(): 
d482 2
a483 3
ed_tty_flush_output(el, c)
    EditLine *el;
    int c;
d485 2
a486 1
    return CC_NORM;
d490 1
a490 1
/* ed_tty_sigquit(): 
d496 2
a497 3
ed_tty_sigquit(el, c)
    EditLine *el;
    int c;
d499 2
a500 1
    return CC_NORM;
d504 1
a504 1
/* ed_tty_sigtstp(): 
d510 2
a511 3
ed_tty_sigtstp(el, c)
    EditLine *el;
    int c;
d513 2
a514 1
    return CC_NORM;
d518 1
a518 1
/* ed_tty_stop_output(): 
d524 2
a525 3
ed_tty_stop_output(el, c)
    EditLine *el;
    int c;
d527 2
a528 1
    return CC_NORM;
d532 1
a532 1
/* ed_tty_start_output(): 
d538 2
a539 3
ed_tty_start_output(el, c)
    EditLine *el;
    int c;
d541 2
a542 1
    return CC_NORM;
d546 1
a546 1
/* ed_newline(): 
d552 1
a552 3
ed_newline(el, c)
    EditLine *el;
    int c;
d554 5
a558 6
    re_goto_bottom(el);
    *el->el_line.lastchar++ = '\n';
    *el->el_line.lastchar = '\0';
    if (el->el_map.type == MAP_VI)
	el->el_chared.c_vcmd.ins = el->el_line.buffer;
    return CC_NEWLINE;
d562 1
a562 1
/* ed_delete_prev_char(): 
d568 11
a578 12
ed_delete_prev_char(el, c)
    EditLine *el;
    int c;
{
    if (el->el_line.cursor <= el->el_line.buffer) 
	return CC_ERROR;

    c_delbefore(el, el->el_state.argument);	
    el->el_line.cursor -= el->el_state.argument;
    if (el->el_line.cursor < el->el_line.buffer)
	el->el_line.cursor = el->el_line.buffer;
    return CC_REFRESH;
d582 1
a582 1
/* ed_clear_screen(): 
d588 1
a588 3
ed_clear_screen(el, c)
    EditLine *el;
    int c;
d590 4
a593 3
    term_clear_screen(el);	/* clear the whole real screen */
    re_clear_display(el);		/* reset everything */
    return CC_REFRESH;
d597 1
a597 1
/* ed_redisplay(): 
d603 2
a604 3
ed_redisplay(el, c)
    EditLine *el;
    int c;
d606 2
a607 1
    return CC_REDISPLAY;
d611 1
a611 1
/* ed_start_over(): 
d617 1
a617 3
ed_start_over(el, c)
    EditLine *el;
    int c;
d619 3
a621 2
    ch_reset(el);
    return CC_REFRESH;
d625 1
a625 1
/* ed_sequence_lead_in(): 
d631 2
a632 3
ed_sequence_lead_in(el, c)
    EditLine *el;
    int c;
d634 2
a635 1
    return CC_NORM;
d639 1
a639 1
/* ed_prev_history(): 
d645 1
a645 3
ed_prev_history(el, c)
    EditLine *el;
    int c;
d647 2
a648 1
    char    beep = 0;
d650 2
a651 2
    el->el_chared.c_undo.action = NOP;
    *el->el_line.lastchar = '\0';		/* just in case */
d653 8
a660 6
    if (el->el_history.eventno == 0) {	/* save the current buffer away */
	(void)strncpy(el->el_history.buf, el->el_line.buffer, EL_BUFSIZ - 1);
	el->el_history.buf[EL_BUFSIZ - 1] = '\0';
	el->el_history.last = el->el_history.buf + 
		(el->el_line.lastchar - el->el_line.buffer);
    }
d662 12
a673 13
    el->el_history.eventno += el->el_state.argument;

    if (hist_get(el) == CC_ERROR) {
	beep = 1;
	/* el->el_history.eventno was fixed by first call */
	(void)hist_get(el); 
    }

    re_refresh(el);
    if (beep)
	return CC_ERROR;
    else
	return CC_NORM;	/* was CC_UP_HIST */
d677 1
a677 1
/* ed_next_history(): 
d683 1
a683 3
ed_next_history(el, c)
    EditLine *el;
    int c;
d685 1
a685 2
    el->el_chared.c_undo.action = NOP;
    *el->el_line.lastchar = '\0';		/* just in case */
d687 2
a688 1
    el->el_history.eventno -= el->el_state.argument;
d690 10
a699 4
    if (el->el_history.eventno < 0) {
	el->el_history.eventno = 0;
	return CC_ERROR;	/* make it beep */
    }
a700 1
    return hist_get(el);
d704 1
a704 1
/* ed_search_prev_history(): 
d710 10
a719 12
ed_search_prev_history(el, c)
    EditLine *el;
    int c;
{
    const char *hp;
    int h;
    bool_t    found = 0;

    el->el_chared.c_vcmd.action = NOP;
    el->el_chared.c_undo.action = NOP;
    *el->el_line.lastchar = '\0';		/* just in case */
    if (el->el_history.eventno < 0) {
d721 2
a722 1
	(void)fprintf(el->el_errfile, "e_prev_search_hist(): eventno < 0;\n");
d724 11
a734 11
	el->el_history.eventno = 0;
	return CC_ERROR;
    }

    if (el->el_history.eventno == 0) {
	(void)strncpy(el->el_history.buf, el->el_line.buffer, EL_BUFSIZ - 1);
	el->el_history.buf[EL_BUFSIZ - 1] = '\0';
	el->el_history.last = el->el_history.buf + 
		(el->el_line.lastchar - el->el_line.buffer);
    }

d736 3
a738 2
    if (el->el_history.ref == NULL)
	return CC_ERROR;
d740 1
a740 3
    hp = HIST_FIRST(el);
    if (hp == NULL)
	return CC_ERROR;
d742 2
a743 1
    c_setpat(el);		/* Set search pattern !! */
d745 1
a745 4
    for (h = 1; h <= el->el_history.eventno; h++)
	hp = HIST_NEXT(el);

    while (hp != NULL) {
d747 1
a747 1
	(void)fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
d749 10
a758 10
	if ((strncmp(hp, el->el_line.buffer, 
		     el->el_line.lastchar - el->el_line.buffer) || 
	    hp[el->el_line.lastchar-el->el_line.buffer]) && 
	    c_hmatch(el, hp)) {
	    found++;
	    break;
	}
	h++;
	hp = HIST_NEXT(el);
    }
d760 1
a760 1
    if (!found) {
d762 1
a762 1
	(void)fprintf(el->el_errfile, "not found\n"); 
d764 3
a766 2
	return CC_ERROR;
    }
d768 1
a768 3
    el->el_history.eventno = h;

    return hist_get(el);
d772 1
a772 1
/* ed_search_next_history(): 
d778 1
a778 3
ed_search_next_history(el, c)
    EditLine *el;
    int c;
d780 3
a782 3
    const char *hp;
    int h;
    bool_t    found = 0;
d784 3
a786 3
    el->el_chared.c_vcmd.action = NOP;
    el->el_chared.c_undo.action = NOP;
    *el->el_line.lastchar = '\0';		/* just in case */
d788 2
a789 2
    if (el->el_history.eventno == 0)
	return CC_ERROR;
d791 2
a792 2
    if (el->el_history.ref == NULL)
	return CC_ERROR;
d794 3
a796 3
    hp = HIST_FIRST(el);
    if (hp == NULL)
	return CC_ERROR;
d798 1
a798 1
    c_setpat(el);		/* Set search pattern !! */
d800 1
a800 1
    for (h = 1; h < el->el_history.eventno && hp; h++) {
d802 1
a802 1
	(void)fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
d804 7
a810 7
	if ((strncmp(hp, el->el_line.buffer, 
		     el->el_line.lastchar - el->el_line.buffer) || 
	     hp[el->el_line.lastchar-el->el_line.buffer]) && 
	    c_hmatch(el, hp))
	    found = h;
	hp = HIST_NEXT(el);
    }
d812 2
a813 2
    if (!found) {		/* is it the current history number? */
	if (!c_hmatch(el, el->el_history.buf)) {
d815 1
a815 1
	    (void)fprintf(el->el_errfile, "not found\n"); 
d817 2
a818 1
	    return CC_ERROR;
d820 1
a820 3
    }

    el->el_history.eventno = found;
d822 1
a822 1
    return hist_get(el);
d832 34
a865 36
ed_prev_line(el, c)
    EditLine *el;
    int c;
{
    char *ptr;
    int nchars = c_hpos(el);
    
    /*
     * Move to the line requested
     */
    if (*(ptr = el->el_line.cursor) == '\n')
	ptr--;

    for (; ptr >= el->el_line.buffer; ptr--)
	if (*ptr == '\n' && --el->el_state.argument <= 0)
	    break;

    if (el->el_state.argument > 0)
	return CC_ERROR;

    /*
     * Move to the beginning of the line
     */
    for (ptr--; ptr >= el->el_line.buffer && *ptr != '\n'; ptr--)
	continue;
    
    /*
     * Move to the character requested
     */
    for (ptr++; 
	 nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n'; 
	 ptr++)
	continue;
    
    el->el_line.cursor = ptr;
    return CC_CURSOR;
d875 25
a899 27
ed_next_line(el, c)
    EditLine *el;
    int c;
{
    char *ptr;
    int nchars = c_hpos(el);

    /*
     * Move to the line requested
     */
    for (ptr = el->el_line.cursor; ptr < el->el_line.lastchar; ptr++)
	if (*ptr == '\n' && --el->el_state.argument <= 0)
	    break;

    if (el->el_state.argument > 0)
	return CC_ERROR;

    /*
     * Move to the character requested
     */
    for (ptr++;
	 nchars-- > 0 && ptr < el->el_line.lastchar && *ptr != '\n'; 
    	 ptr++)
	continue;
    
    el->el_line.cursor = ptr;
    return CC_CURSOR;
d903 1
a903 1
/* ed_command(): 
d909 13
a921 27
ed_command(el, c)
    EditLine *el;
    int c;
{
    char tmpbuf[EL_BUFSIZ];
    int tmplen;

    el->el_line.buffer[0] = '\0';
    el->el_line.lastchar = el->el_line.buffer;
    el->el_line.cursor = el->el_line.buffer;

    c_insert(el, 3);	/* prompt + ": " */
    *el->el_line.cursor++ = '\n';
    *el->el_line.cursor++ = ':';
    *el->el_line.cursor++ = ' ';
    re_refresh(el);

    tmplen = c_gets(el, tmpbuf);
    tmpbuf[tmplen] = '\0';

    el->el_line.buffer[0] = '\0';
    el->el_line.lastchar = el->el_line.buffer;
    el->el_line.cursor = el->el_line.buffer;

    if (parse_line(el, tmpbuf) == -1)
	return CC_ERROR;
    else
@


1.4
log
@is -Wall clean by making rcsid const
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.3 1997/03/14 05:12:43 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: common.c,v 1.3 1997/03/14 05:12:43 millert Exp $";
@


1.3
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: common.c,v 1.2 1997/01/16 05:18:30 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: common.c,v 1.2 1997/01/16 05:18:30 millert Exp $";
@


1.2
log
@Merge in NetBSD libedit changes and new man pages.  Also fix some
strncpy() usage in their code.  NetBSD change log was:
    * add a man page for the editline routines
    * add a man page describing editrc
    * fix bugs in el_parse():
      * didn't execute command when program name matched (test reversed)
      * was checking against empty string instead of program name
      * after checks, command to run also pointed to empty string
    * document ^char and \ escape sequences
    * when parsing ^char control chars, check the correct char when determining
      validity (previously, ^char was a NOP interpreted as the literal string
      because of this bug)
    * Implement CC_REDISPLAY, which (unlike CC_REFRESH) redraws the entire input
    * line (a la ^R). This is useful if the binding outputs information and
    * mucks up the input line. To be used in ``list-choices'' bindings (refer
    * to the ^D binding in csh when filec is set)
@
text
@d1 2
a2 1
/*	$OpenBSD: $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: $";
d121 1
a121 1
	(void) vi_command_mode(el, 0);
d710 1
a710 1
	(void) strncpy(el->el_history.buf, el->el_line.buffer, EL_BUFSIZ - 1);
d721 1
a721 1
	(void) hist_get(el); 
d775 1
a775 1
	(void) fprintf(el->el_errfile, "e_prev_search_hist(): eventno < 0;\n");
d782 1
a782 1
	(void) strncpy(el->el_history.buf, el->el_line.buffer, EL_BUFSIZ - 1);
d803 1
a803 1
	(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
d818 1
a818 1
	(void) fprintf(el->el_errfile, "not found\n"); 
d861 1
a861 1
	(void) fprintf(el->el_errfile, "Comparing with \"%s\"\n", hp);
d874 1
a874 1
	    (void) fprintf(el->el_errfile, "not found\n"); 
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
d42 3
d660 1
a660 3
    re_clear_lines(el);
    re_clear_display(el);
    return CC_REFRESH;
d709 2
a710 1
	(void) strncpy(el->el_history.buf, el->el_line.buffer, EL_BUFSIZ);
d781 2
a782 1
	(void) strncpy(el->el_history.buf, el->el_line.buffer, EL_BUFSIZ);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
