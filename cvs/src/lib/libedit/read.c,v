head	1.44;
access;
symbols
	OPENBSD_6_2:1.44.0.8
	OPENBSD_6_2_BASE:1.44
	OPENBSD_6_1:1.44.0.6
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.2
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.16
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.14
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.10
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.26
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.22
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.20
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.18
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.16
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.14
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.12
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.18
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.16
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2016.05.25.09.36.21;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	Wrup1DwoTHBxn4JR;

1.43
date	2016.05.25.09.23.49;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	8uuGVizA1k3gmrdl;

1.42
date	2016.05.24.18.06.30;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	nvK6NO7QqBzKe0Be;

1.41
date	2016.05.22.23.09.56;	author schwarze;	state Exp;
branches;
next	1.40;
commitid	JDRx6gbg98ixcAQq;

1.40
date	2016.05.20.15.30.17;	author schwarze;	state Exp;
branches;
next	1.39;
commitid	FRyPaNIGw56FlvYt;

1.39
date	2016.05.06.13.12.52;	author schwarze;	state Exp;
branches;
next	1.38;
commitid	HmIy04UbyUS0d1Sd;

1.38
date	2016.04.13.09.42.41;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	KOuuvdAOXEKGaLH0;

1.37
date	2016.04.12.09.07.21;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	ExV3A05NpBPejutA;

1.36
date	2016.04.12.09.04.02;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	0JsQE9vcJ83YRqdA;

1.35
date	2016.04.11.21.17.29;	author schwarze;	state Exp;
branches;
next	1.34;
commitid	I3AtNAFb4FywnTMT;

1.34
date	2016.04.11.20.43.33;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	OUneMOe0l7HombT5;

1.33
date	2016.04.11.19.54.54;	author schwarze;	state Exp;
branches;
next	1.32;
commitid	xizUpRlYj2C4Hcj6;

1.32
date	2016.04.09.20.15.26;	author schwarze;	state Exp;
branches;
next	1.31;
commitid	0bnhGLXZIvXlnMLp;

1.31
date	2016.04.09.19.31.55;	author schwarze;	state Exp;
branches;
next	1.30;
commitid	t22PDRfkb5DJX3rc;

1.30
date	2016.04.05.21.24.02;	author krw;	state Exp;
branches;
next	1.29;
commitid	3qdWFFf70QZsgEH7;

1.29
date	2016.03.22.11.32.18;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	IqABuRl0Ys8M4ewM;

1.28
date	2016.03.21.17.28.10;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	bxfYrS2VROPyQgXw;

1.27
date	2016.03.21.15.25.39;	author schwarze;	state Exp;
branches;
next	1.26;
commitid	Qq3DwK1S3lWtyR8X;

1.26
date	2016.03.21.00.11.56;	author schwarze;	state Exp;
branches;
next	1.25;
commitid	RIuv2IWtQOxtDmcB;

1.25
date	2016.03.20.23.48.27;	author schwarze;	state Exp;
branches;
next	1.24;
commitid	tRHhB2RN3ZD1GvoI;

1.24
date	2016.03.20.20.16.09;	author schwarze;	state Exp;
branches;
next	1.23;
commitid	BxYjngCBlp9HvsM6;

1.23
date	2016.03.20.19.33.16;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	QfpWh7MIpK70Anq8;

1.22
date	2016.03.20.18.20.10;	author schwarze;	state Exp;
branches;
next	1.21;
commitid	v5ODo7vVmcvJ95rC;

1.21
date	2016.03.20.17.19.48;	author schwarze;	state Exp;
branches;
next	1.20;
commitid	i7dvYVQoanOIP2WU;

1.20
date	2016.01.31.20.42.33;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	gD9lqwRuptCvbXUE;

1.19
date	2016.01.30.17.32.52;	author schwarze;	state Exp;
branches;
next	1.18;
commitid	wAt9MiELkmlnoi4U;

1.18
date	2016.01.30.12.22.20;	author schwarze;	state Exp;
branches;
next	1.17;
commitid	dCN84ovvbfYwqrqX;

1.17
date	2016.01.30.00.06.39;	author schwarze;	state Exp;
branches;
next	1.16;
commitid	tGf8IdK8wCurneJ7;

1.16
date	2016.01.29.19.32.33;	author schwarze;	state Exp;
branches;
next	1.15;
commitid	Ue1IcMCqgxm4S8jQ;

1.15
date	2014.10.17.06.07.50;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	bdUOvGFxUQgqZg7x;

1.14
date	2011.07.07.05.40.42;	author okan;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.30.00.05.35;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.27.23.59.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.25.20.12.38;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.31.08.42.24;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.20.18.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.01.21.11.21;	author avsm;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.26;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.08.20.03.30.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.06.29.23.40.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.06.10.20.10.13;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.03.14.05.12.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.16.05.18.42;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.42.41;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.42.41;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.44
log
@el_map.alt can never be NULL, delete dead code
OK czarkoff@@
@
text
@/*	$OpenBSD: read.c,v 1.43 2016/05/25 09:23:49 schwarze Exp $	*/
/*	$NetBSD: read.c,v 1.100 2016/05/24 19:31:27 christos Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Christos Zoulas of Cornell University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "config.h"

/*
 * read.c: Clean this junk up! This is horrible code.
 *	   Terminal read functions
 */
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "el.h"
#include "fcns.h"
#include "read.h"

#define	EL_MAXMACRO	10

struct macros {
	wchar_t	**macro;
	int	  level;
	int	  offset;
};

struct el_read_t {
	struct macros	 macros;
	el_rfunc_t	 read_char;	/* Function to read a character. */
	int		 read_errno;
};

static int	read__fixio(int, int);
static int	read_char(EditLine *, wchar_t *);
static int	read_getcmd(EditLine *, el_action_t *, wchar_t *);
static void	read_clearmacros(struct macros *);
static void	read_pop(struct macros *);

/* read_init():
 *	Initialize the read stuff
 */
protected int
read_init(EditLine *el)
{
	struct macros *ma;

	if ((el->el_read = malloc(sizeof(*el->el_read))) == NULL)
		return -1;

	ma = &el->el_read->macros;
	if ((ma->macro = reallocarray(NULL, EL_MAXMACRO,
	    sizeof(*ma->macro))) == NULL) {
		free(el->el_read);
		return -1;
	}
	ma->level = -1;
	ma->offset = 0;

	/* builtin read_char */
	el->el_read->read_char = read_char;
	return 0;
}

/* el_read_end():
 *	Free the data structures used by the read stuff.
 */
protected void
read_end(struct el_read_t *el_read)
{
	read_clearmacros(&el_read->macros);
	free(el_read->macros.macro);
	el_read->macros.macro = NULL;
}

/* el_read_setfn():
 *	Set the read char function to the one provided.
 *	If it is set to EL_BUILTIN_GETCFN, then reset to the builtin one.
 */
protected int
el_read_setfn(struct el_read_t *el_read, el_rfunc_t rc)
{
	el_read->read_char = (rc == EL_BUILTIN_GETCFN) ? read_char : rc;
	return 0;
}


/* el_read_getfn():
 *	return the current read char function, or EL_BUILTIN_GETCFN
 *	if it is the default one
 */
protected el_rfunc_t
el_read_getfn(struct el_read_t *el_read)
{
	return el_read->read_char == read_char ?
	    EL_BUILTIN_GETCFN : el_read->read_char;
}


/* read__fixio():
 *	Try to recover from a read error
 */
/* ARGSUSED */
static int
read__fixio(int fd __attribute__((__unused__)), int e)
{

	switch (e) {
	case -1:		/* Make sure that the code is reachable */

#ifdef EWOULDBLOCK
	case EWOULDBLOCK:
#ifndef TRY_AGAIN
#define TRY_AGAIN
#endif
#endif /* EWOULDBLOCK */

#if defined(POSIX) && defined(EAGAIN)
#if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
	case EAGAIN:
#ifndef TRY_AGAIN
#define TRY_AGAIN
#endif
#endif /* EWOULDBLOCK && EWOULDBLOCK != EAGAIN */
#endif /* POSIX && EAGAIN */

		e = 0;
#ifdef TRY_AGAIN
#if defined(F_SETFL) && defined(O_NDELAY)
		if ((e = fcntl(fd, F_GETFL)) == -1)
			return -1;

		if (fcntl(fd, F_SETFL, e & ~O_NDELAY) == -1)
			return -1;
		else
			e = 1;
#endif /* F_SETFL && O_NDELAY */

#ifdef FIONBIO
		{
			int zero = 0;

			if (ioctl(fd, FIONBIO, &zero) == -1)
				return -1;
			else
				e = 1;
		}
#endif /* FIONBIO */

#endif /* TRY_AGAIN */
		return e ? 0 : -1;

	case EINTR:
		return 0;

	default:
		return -1;
	}
}


/* el_push():
 *	Push a macro
 */
void
el_wpush(EditLine *el, const wchar_t *str)
{
	struct macros *ma = &el->el_read->macros;

	if (str != NULL && ma->level + 1 < EL_MAXMACRO) {
		ma->level++;
		if ((ma->macro[ma->level] = wcsdup(str)) != NULL)
			return;
		ma->level--;
	}
	terminal_beep(el);
	terminal__flush(el);
}


/* read_getcmd():
 *	Get next command from the input stream,
 *	return 0 on success or -1 on EOF or error.
 *	Character values > 255 are not looked up in the map, but inserted.
 */
static int
read_getcmd(EditLine *el, el_action_t *cmdnum, wchar_t *ch)
{
	static const wchar_t meta = (wchar_t)0x80;
	el_action_t cmd;
	int num;

	do {
		if ((num = el_wgetc(el, ch)) != 1)
			return -1;

#ifdef	KANJI
		if ((*ch & meta)) {
			el->el_state.metanext = 0;
			cmd = CcViMap[' '];
			break;
		} else
#endif /* KANJI */

		if (el->el_state.metanext) {
			el->el_state.metanext = 0;
			*ch |= meta;
		}
		if (*ch >= N_KEYS)
			cmd = ED_INSERT;
		else
			cmd = el->el_map.current[(unsigned char) *ch];
		if (cmd == ED_SEQUENCE_LEAD_IN) {
			keymacro_value_t val;
			switch (keymacro_get(el, ch, &val)) {
			case XK_CMD:
				cmd = val.cmd;
				break;
			case XK_STR:
				el_wpush(el, val.str);
				break;
			case XK_NOD:
				return -1;
			default:
				EL_ABORT((el->el_errfile, "Bad XK_ type \n"));
				break;
			}
		}
	} while (cmd == ED_SEQUENCE_LEAD_IN);
	*cmdnum = cmd;
	return 0;
}

/* read_char():
 *	Read a character from the tty.
 */
static int
read_char(EditLine *el, wchar_t *cp)
{
	ssize_t num_read;
	int tried = 0;
	char cbuf[MB_LEN_MAX];
	int cbp = 0;
	int save_errno = errno;

 again:
	el->el_signal->sig_no = 0;
	while ((num_read = read(el->el_infd, cbuf + cbp, 1)) == -1) {
		int e = errno;
		switch (el->el_signal->sig_no) {
		case SIGCONT:
			el_set(el, EL_REFRESH);
			/*FALLTHROUGH*/
		case SIGWINCH:
			sig_set(el);
			goto again;
		default:
			break;
		}
		if (!tried && read__fixio(el->el_infd, e) == 0) {
			errno = save_errno;
			tried = 1;
		} else {
			errno = e;
			*cp = L'\0';
			return -1;
		}
	}

	/* Test for EOF */
	if (num_read == 0) {
		*cp = L'\0';
		return 0;
	}

	for (;;) {
		mbstate_t mbs;

		++cbp;
		/* This only works because UTF8 is stateless. */
		memset(&mbs, 0, sizeof(mbs));
		switch (mbrtowc(cp, cbuf, cbp, &mbs)) {
		case (size_t)-1:
			if (cbp > 1) {
				/*
				 * Invalid sequence, discard all bytes
				 * except the last one.
				 */
				cbuf[0] = cbuf[cbp - 1];
				cbp = 0;
				break;
			} else {
				/* Invalid byte, discard it. */
				cbp = 0;
				goto again;
			}
		case (size_t)-2:
			/*
			 * We don't support other multibyte charsets.
			 * The second condition shouldn't happen
			 * and is here merely for additional safety.
			 */
			if ((el->el_flags & CHARSET_IS_UTF8) == 0 ||
			    cbp >= MB_LEN_MAX) {
				errno = EILSEQ;
				*cp = L'\0';
				return -1;
			}
			/* Incomplete sequence, read another byte. */
			goto again;
		default:
			/* Valid character, process it. */
			return 1;
		}
	}
}

/* read_pop():
 *	Pop a macro from the stack
 */
static void
read_pop(struct macros *ma)
{
	int i;

	free(ma->macro[0]);
	for (i = 0; i < ma->level; i++)
		ma->macro[i] = ma->macro[i + 1];
	ma->level--;
	ma->offset = 0;
}

static void
read_clearmacros(struct macros *ma)
{
	while (ma->level >= 0)
		free(ma->macro[ma->level--]);
	ma->offset = 0;
}

/* el_wgetc():
 *	Read a wide character
 */
int
el_wgetc(EditLine *el, wchar_t *cp)
{
	struct macros *ma = &el->el_read->macros;
	int num_read;

	terminal__flush(el);
	for (;;) {
		if (ma->level < 0)
			break;

		if (ma->macro[0][ma->offset] == '\0') {
			read_pop(ma);
			continue;
		}

		*cp = ma->macro[0][ma->offset++];

		if (ma->macro[0][ma->offset] == '\0') {
			/* Needed for QuoteMode On */
			read_pop(ma);
		}

		return 1;
	}

	if (tty_rawmode(el) < 0)/* make sure the tty is set up correctly */
		return 0;

	num_read = (*el->el_read->read_char)(el, cp);

	/*
	 * Remember the original reason of a read failure
	 * such that el_wgets() can restore it after doing
	 * various cleanup operation that might change errno.
	 */
	if (num_read < 0)
		el->el_read->read_errno = errno;

	return num_read;
}

protected void
read_prepare(EditLine *el)
{
	if (el->el_flags & HANDLE_SIGNALS)
		sig_set(el);
	if (el->el_flags & NO_TTY)
		return;
	if ((el->el_flags & (UNBUFFERED|EDIT_DISABLED)) == UNBUFFERED)
		tty_rawmode(el);

	/* This is relatively cheap, and things go terribly wrong if
	   we have the wrong size. */
	el_resize(el);
	re_clear_display(el);	/* reset the display stuff */
	ch_reset(el);
	re_refresh(el);		/* print the prompt */

	if (el->el_flags & UNBUFFERED)
		terminal__flush(el);
}

protected void
read_finish(EditLine *el)
{
	if ((el->el_flags & UNBUFFERED) == 0)
		(void) tty_cookedmode(el);
	if (el->el_flags & HANDLE_SIGNALS)
		sig_clr(el);
}

const wchar_t *
el_wgets(EditLine *el, int *nread)
{
	int retval;
	el_action_t cmdnum = 0;
	int num;		/* how many chars we have read at NL */
	wchar_t wc;
	wchar_t ch, *cp;
	int crlf = 0;
	int nrb;

	if (nread == NULL)
		nread = &nrb;
	*nread = 0;
	el->el_read->read_errno = 0;

	if (el->el_flags & NO_TTY) {
		size_t idx;

		cp = el->el_line.buffer;
		while ((num = (*el->el_read->read_char)(el, &wc)) == 1) {
			*cp = wc;
			/* make sure there is space for next character */
			if (cp + 1 >= el->el_line.limit) {
				idx = (cp - el->el_line.buffer);
				if (!ch_enlargebufs(el, 2))
					break;
				cp = &el->el_line.buffer[idx];
			}
			cp++;
			if (el->el_flags & UNBUFFERED)
				break;
			if (cp[-1] == '\r' || cp[-1] == '\n')
				break;
		}
		if (num == -1 && errno == EINTR)
			cp = el->el_line.buffer;
		goto noedit;
	}


#ifdef FIONREAD
	if (el->el_tty.t_mode == EX_IO && el->el_read->macros.level < 0) {
		int chrs = 0;

		(void) ioctl(el->el_infd, FIONREAD, &chrs);
		if (chrs == 0) {
			if (tty_rawmode(el) < 0) {
				errno = 0;
				*nread = 0;
				return NULL;
			}
		}
	}
#endif /* FIONREAD */

	if ((el->el_flags & UNBUFFERED) == 0)
		read_prepare(el);

	if (el->el_flags & EDIT_DISABLED) {
		size_t idx;

		if ((el->el_flags & UNBUFFERED) == 0)
			cp = el->el_line.buffer;
		else
			cp = el->el_line.lastchar;

		terminal__flush(el);

		while ((num = (*el->el_read->read_char)(el, &wc)) == 1) {
			*cp = wc;
			/* make sure there is space next character */
			if (cp + 1 >= el->el_line.limit) {
				idx = (cp - el->el_line.buffer);
				if (!ch_enlargebufs(el, 2))
					break;
				cp = &el->el_line.buffer[idx];
			}
			cp++;
			crlf = cp[-1] == '\r' || cp[-1] == '\n';
			if (el->el_flags & UNBUFFERED)
				break;
			if (crlf)
				break;
		}
		if (num == -1 && errno == EINTR)
			cp = el->el_line.buffer;
		goto noedit;
	}

	for (num = -1; num == -1;) {  /* while still editing this line */
		/* if EOF or error */
		if (read_getcmd(el, &cmdnum, &ch) == -1)
			break;
		if ((int)cmdnum >= el->el_map.nfunc) /* BUG CHECK command */
			continue;	/* try again */
		/* now do the real command */
		/* vi redo needs these way down the levels... */
		el->el_state.thiscmd = cmdnum;
		el->el_state.thisch = ch;
		if (el->el_map.type == MAP_VI &&
		    el->el_map.current == el->el_map.key &&
		    el->el_chared.c_redo.pos < el->el_chared.c_redo.lim) {
			if (cmdnum == VI_DELETE_PREV_CHAR &&
			    el->el_chared.c_redo.pos != el->el_chared.c_redo.buf
			    && iswprint(el->el_chared.c_redo.pos[-1]))
				el->el_chared.c_redo.pos--;
			else
				*el->el_chared.c_redo.pos++ = ch;
		}
		retval = (*el->el_map.func[cmdnum]) (el, ch);

		/* save the last command here */
		el->el_state.lastcmd = cmdnum;

		/* use any return value */
		switch (retval) {
		case CC_CURSOR:
			re_refresh_cursor(el);
			break;

		case CC_REDISPLAY:
			re_clear_lines(el);
			re_clear_display(el);
			/* FALLTHROUGH */

		case CC_REFRESH:
			re_refresh(el);
			break;

		case CC_REFRESH_BEEP:
			re_refresh(el);
			terminal_beep(el);
			break;

		case CC_NORM:	/* normal char */
			break;

		case CC_ARGHACK:	/* Suggested by Rich Salz */
			/* <rsalz@@pineapple.bbn.com> */
			continue;	/* keep going... */

		case CC_EOF:	/* end of file typed */
			if ((el->el_flags & UNBUFFERED) == 0)
				num = 0;
			else if (num == -1) {
				*el->el_line.lastchar++ = CONTROL('d');
				el->el_line.cursor = el->el_line.lastchar;
				num = 1;
			}
			break;

		case CC_NEWLINE:	/* normal end of line */
			num = (int)(el->el_line.lastchar - el->el_line.buffer);
			break;

		case CC_FATAL:	/* fatal error, reset to known state */
			/* put (real) cursor in a known place */
			re_clear_display(el);	/* reset the display stuff */
			ch_reset(el);	/* reset the input pointers */
			read_clearmacros(&el->el_read->macros);
			re_refresh(el); /* print the prompt again */
			break;

		case CC_ERROR:
		default:	/* functions we don't know about */
			terminal_beep(el);
			terminal__flush(el);
			break;
		}
		el->el_state.argument = 1;
		el->el_state.doingarg = 0;
		el->el_chared.c_vcmd.action = NOP;
		if (el->el_flags & UNBUFFERED)
			break;
	}

	terminal__flush(el);		/* flush any buffered output */
	/* make sure the tty is set up correctly */
	if ((el->el_flags & UNBUFFERED) == 0) {
		read_finish(el);
		*nread = num != -1 ? num : 0;
	} else {
		*nread = (int)(el->el_line.lastchar - el->el_line.buffer);
	}
	goto done;
noedit:
	el->el_line.cursor = el->el_line.lastchar = cp;
	*cp = '\0';
	*nread = (int)(el->el_line.cursor - el->el_line.buffer);
done:
	if (*nread == 0) {
		if (num == -1) {
			*nread = -1;
			if (el->el_read->read_errno)
				errno = el->el_read->read_errno;
		}
		return NULL;
	} else
		return el->el_line.buffer;
}
@


1.43
log
@Saving errno in el_errno is only needed for one purpose:
Restoring the original errno found in el_wgetc() after
el_wgets() did some cleanup that may have changed errno.

Improve clarity and robustness of the code by not setting and
inspecting el_errno where it isn't needed; in particular, let
keymacro_get() properly report read failure to read_getcmd().
Move el_errno to el_read_t because it's only used in read.c.
Never set errno back to zero.

Checked with a test program installing a USR1 signal handler
without SA_RESTART, for the cases read_getcmd(), ed_quoted_insert(),
keymacro_get(), ed_command(), and EL_EDITMODE=0.

OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.42 2016/05/24 18:06:30 schwarze Exp $	*/
/*	$NetBSD: read.c,v 1.97 2016/05/22 19:44:26 christos Exp $	*/
a262 2
		if (el->el_map.alt == NULL)
			el->el_map.current = el->el_map.key;
@


1.42
log
@Remove debugging ifdefs.
I'm debugging the read module for weeks now,
but these ifdefs aren't helpful.
OK cpp(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.41 2016/05/22 23:09:56 schwarze Exp $	*/
d65 1
a226 1
	el->el_errno = 0;
d228 1
a228 2
		if ((num = el_wgetc(el, ch)) != 1) {/* if EOF or error */
			el->el_errno = num == 0 ? 0 : errno;
a229 1
		}
d256 2
d410 6
d417 2
a418 1
		el->el_errno = errno;
d466 1
d487 2
a488 6
		if (num == -1) {
			if (errno == EINTR)
				cp = el->el_line.buffer;
			el->el_errno = errno;
		}

d537 2
a538 7

		if (num == -1) {
			if (errno == EINTR)
				cp = el->el_line.buffer;
			el->el_errno = errno;
		}

a545 6
		if (el->el_errno == EINTR) {
			el->el_line.buffer[0] = '\0';
			el->el_line.lastchar =
			    el->el_line.cursor = el->el_line.buffer;
			break;
		}
d646 2
a647 1
			errno = el->el_errno;
@


1.41
log
@Improve modularization at the chared/read boundary, no functional change.

Stop the read.c module from poking the el_chared.c_macro data
structure that used to belong to the chared.c module.  Given that
no other module, not even chared itself, is using that data, move it
into the read modules's own opaque data structure, struct el_read_t.

That gets rid of one struct, one #define, one struct member, and one
function argument in the chared.h interface.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.40 2016/05/20 15:30:17 schwarze Exp $	*/
a132 19
#ifdef DEBUG_EDIT
static void
read_debug(EditLine *el)
{

	if (el->el_line.cursor > el->el_line.lastchar)
		(void) fprintf(el->el_errfile, "cursor > lastchar\r\n");
	if (el->el_line.cursor < el->el_line.buffer)
		(void) fprintf(el->el_errfile, "cursor < buffer\r\n");
	if (el->el_line.cursor > el->el_line.limit)
		(void) fprintf(el->el_errfile, "cursor > limit\r\n");
	if (el->el_line.lastchar > el->el_line.limit)
		(void) fprintf(el->el_errfile, "lastchar > limit\r\n");
	if (el->el_line.limit != &el->el_line.buffer[EL_BUFSIZ - 2])
		(void) fprintf(el->el_errfile, "limit != &buffer[EL_BUFSIZ-2]\r\n");
}
#endif /* DEBUG_EDIT */


a405 3
#ifdef DEBUG_READ
	(void) fprintf(el->el_errfile, "Turning raw mode on\n");
#endif /* DEBUG_READ */
a408 3
#ifdef DEBUG_READ
	(void) fprintf(el->el_errfile, "Reading a character\n");
#endif /* DEBUG_READ */
a411 3
#ifdef DEBUG_READ
	(void) fprintf(el->el_errfile, "Got it %lc\n", *cp);
#endif /* DEBUG_READ */
a543 3
#ifdef DEBUG_EDIT
		read_debug(el);
#endif /* DEBUG_EDIT */
d545 1
a545 5
		if (read_getcmd(el, &cmdnum, &ch) == -1) {
#ifdef DEBUG_READ
			(void) fprintf(el->el_errfile,
			    "Returning from el_gets\n");
#endif /* DEBUG_READ */
a546 1
		}
d553 1
a553 5
		if ((unsigned int)cmdnum >= (unsigned int)el->el_map.nfunc) {	/* BUG CHECK command */
#ifdef DEBUG_EDIT
			(void) fprintf(el->el_errfile,
			    "ERROR: illegal command from key 0%o\r\n", ch);
#endif /* DEBUG_EDIT */
a554 1
		}
a555 14
#ifdef DEBUG_READ
		{
			el_bindings_t *b;
			for (b = el->el_map.help; b->name; b++)
				if (b->func == cmdnum)
					break;
			if (b->name)
				(void) fprintf(el->el_errfile,
				    "Executing %ls\n", b->name);
			else
				(void) fprintf(el->el_errfile,
				    "Error command = %d\n", cmdnum);
		}
#endif /* DEBUG_READ */
a569 4
#ifdef DEBUG_READ
		(void) fprintf(el->el_errfile,
			"Returned state %d\n", retval );
#endif /* DEBUG_READ */
a615 4
#ifdef DEBUG_READ
			(void) fprintf(el->el_errfile,
			    "*** editor fatal ERROR ***\r\n\n");
#endif /* DEBUG_READ */
a624 4
#ifdef DEBUG_READ
			(void) fprintf(el->el_errfile,
			    "*** editor ERROR ***\r\n\n");
#endif /* DEBUG_READ */
@


1.40
log
@Move the declaration of the function pointer type el_rfunc_t
from the private header "read.h" to the public header <histedit.h>.
That's not an interface change, it was already used and documented
publicly, merely not properly declared.

Improve encapsulation: Make el_read a pointer to an opaque struct
in struct editline, such that "read.h" no longer needs to be included
from "el.h" but only from the two files using it, read.c and el.c.
Only pass the required el_read_t to el_read_{s,g}etfn(),
do not pass the full struct editline.

OK czarkoff@@,
also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.39 2016/05/06 13:12:52 schwarze Exp $	*/
/*	$NetBSD: read.c,v 1.94 2016/04/18 17:01:19 christos Exp $	*/
d54 8
d63 1
d70 2
a71 1
static void	read_pop(c_macro_t *);
d79 2
d83 10
d98 10
d220 1
a220 1
	c_macro_t *ma = &el->el_chared.c_macro;
d377 1
a377 1
read_pop(c_macro_t *ma)
d388 8
d402 1
a403 1
	c_macro_t *ma = &el->el_chared.c_macro;
d457 1
a457 1
	ch_reset(el, 0);
d518 1
a518 1
	if (el->el_tty.t_mode == EX_IO && el->el_chared.c_macro.level < 0) {
d681 2
a682 1
			ch_reset(el, 1);	/* reset the input pointers */
@


1.39
log
@Replace the generated file "fcns.c" by a simpler header "func.h"
included only in the one file needing it, "map.c".
That allows to define el_action_t directly in "map.h",
which in turn allows to stop including "fcns.h" from "el.h"
and include it only in the modules needing it.
Now we no longer autogenerate any C files.

Feedback and OK martijn@@.
First version also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.38 2016/04/13 09:42:41 schwarze Exp $	*/
d52 5
d69 2
d72 1
a72 1
	el->el_read.read_char = read_char;
d82 1
a82 1
el_read_setfn(EditLine *el, el_rfunc_t rc)
d84 1
a84 1
	el->el_read.read_char = (rc == EL_BUILTIN_GETCFN) ? read_char : rc;
d94 1
a94 1
el_read_getfn(EditLine *el)
d96 2
a97 2
       return el->el_read.read_char == read_char ?
	    EL_BUILTIN_GETCFN : el->el_read.read_char;
d394 1
a394 1
	num_read = (*el->el_read.read_char)(el, cp);
d452 1
a452 1
		while ((num = (*el->el_read.read_char)(el, &wc)) == 1) {
d505 1
a505 1
		while ((num = (*el->el_read.read_char)(el, &wc)) == 1) {
@


1.38
log
@Re-introduce the following commit:
OpenBSD read.c rev. 1.4 1997/06/10 20:10:13 millert
FIONREAD takes int *, not long *

It got lost in the following merge from NetBSD:
OpenBSD read.c rev. 1.10 2003/10/31 08:42:24 otto

OK millert@@ martijn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.37 2016/04/12 09:07:21 schwarze Exp $	*/
/*	$NetBSD: read.c,v 1.92 2016/04/12 00:16:06 christos Exp $	*/
d51 1
@


1.37
log
@Cleanup, no functional change:
* Make the return value from read_getcmd() less confusing.
* No need to store that return value; testing it once is enough.
* Get rid of one #ifdef section in el_wgets().
OK czarkoff@@ martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.36 2016/04/12 09:04:02 schwarze Exp $	*/
d471 1
a471 1
		long chrs = 0;
@


1.36
log
@* Delete the unimplemented feature XK_EXE.
* Delete the unused macro MIN().
No functional change.
OK czarkoff@@ martijn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.35 2016/04/11 21:17:29 schwarze Exp $	*/
/*	$NetBSD: read.c,v 1.91 2016/04/11 18:56:31 christos Exp $	*/
a51 2
#define OKCMD	-1	/* must be -1! */

d194 2
a195 1
 *	Get next command from the input stream, return OKCMD on success.
d209 1
a209 1
			return 0;	/* not OKCMD */
d246 1
a246 1
	return OKCMD;
a434 3
#ifdef FIONREAD
	c_macro_t *ma = &el->el_chared.c_macro;
#endif /* FIONREAD */
d470 1
a470 1
	if (el->el_tty.t_mode == EX_IO && ma->level < 0) {
d523 1
a523 2
	for (num = OKCMD; num == OKCMD;) {	/* while still editing this
						 * line */
d528 1
a528 2
		if ((num = read_getcmd(el, &cmdnum, &ch)) != OKCMD) {
			num = -1;
d531 1
a531 1
			    "Returning from el_gets %d\n", num);
@


1.35
log
@delete the "private" and "public" preprocessor macros, just use standard C;
OK martijn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.34 2016/04/11 20:43:33 schwarze Exp $	*/
a94 4
#ifndef MIN
#define MIN(A,B) ((A) < (B) ? (A) : (B))
#endif

a237 6
#ifdef notyet
			case XK_EXE:
				/* XXX: In the future to run a user function */
				RunCommand(val.str);
				break;
#endif
@


1.34
log
@get rid of the non-standard data type "Char" in almost all files;
ok martijn@@
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.33 2016/04/11 19:54:54 schwarze Exp $	*/
/*	$NetBSD: read.c,v 1.90 2016/04/11 00:50:13 christos Exp $	*/
d54 4
a57 4
private int	read__fixio(int, int);
private int	read_char(EditLine *, wchar_t *);
private int	read_getcmd(EditLine *, el_action_t *, wchar_t *);
private void	read_pop(c_macro_t *);
d100 1
a100 1
private void
d122 1
a122 1
private int
d183 1
a183 1
public void
d203 1
a203 1
private int
d263 1
a263 1
private int
d347 1
a347 1
private void
d362 1
a362 1
public int
d436 1
a436 1
public const wchar_t *
@


1.33
log
@Move wrapper macros to the two files actually needing them:
FUNW, Strlen, Strdup, Strcmp, Strncmp, Strncpy, Strncat -> history.c
Strchr, tok_strdup -> tokenizer.c
FUN, TYPE, STR -> both of these files

OK martijn@@

Also proofread by Christian Heckendorf <mbie at ulmus dot me>
who reported some whitespace issues in parse.c.
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.32 2016/04/09 20:15:26 schwarze Exp $	*/
/*	$NetBSD: read.c,v 1.88 2016/04/09 18:43:17 christos Exp $	*/
d56 1
a56 1
private int	read_getcmd(EditLine *, el_action_t *, Char *);
d184 1
a184 1
el_wpush(EditLine *el, const Char *str)
d204 1
a204 1
read_getcmd(EditLine *el, el_action_t *cmdnum, Char *ch)
d206 1
a206 1
	static const Char meta = (Char)0x80;
a207 1
	wchar_t wc;
d212 1
a212 1
		if ((num = el_wgetc(el, &wc)) != 1) {/* if EOF or error */
a215 1
		*ch = (Char)wc;
d436 1
a436 1
public const Char *
d443 1
a443 1
	Char ch, *cp;
d459 1
a459 1
			*cp = (Char)wc;
d512 1
a512 1
			*cp = (Char)wc;
@


1.32
log
@Delete 26 wrapper macros and two wrapper functions that are no
longer needed now that we always compile with wide character support,
reducing code obfuscation.

OK czarkoff@@ martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.31 2016/04/09 19:31:55 schwarze Exp $	*/
d184 1
a184 1
FUN(el,push)(EditLine *el, const Char *str)
d190 1
a190 1
		if ((ma->macro[ma->level] = Strdup(str)) != NULL)
d242 1
a242 1
				FUN(el,push)(el, val.str);
d439 1
a439 1
FUN(el,gets)(EditLine *el, int *nread)
@


1.31
log
@Always compile with WIDECHAR on and delete that preprocessor switch.
OK martijn@@.
Diff also proofread by Christian Heckendorf <mbie at ulmus dot me>.
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.30 2016/04/05 21:24:02 krw Exp $	*/
/*	$NetBSD: read.c,v 1.81 2016/02/16 22:53:14 christos Exp $	*/
d308 1
a308 1
		/* This only works because UTF8 is stateless */
d310 1
a310 1
		switch (ct_mbrtowc(cp, cbuf, cbp, &mbs)) {
d575 1
a575 1
				    "Executing " FSTR "\n", b->name);
d589 1
a589 1
			    && Isprint(el->el_chared.c_redo.pos[-1]))
@


1.30
log
@Move more fcntl(,F_GETFL,0) -> fcntl(,F_GETFL).

No functional change.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.29 2016/03/22 11:32:18 schwarze Exp $	*/
a54 1
private int	read_preread(EditLine *);
a179 32
/* read_preread():
 *	Try to read the stuff in the input queue;
 */
private int
read_preread(EditLine *el)
{
	int chrs = 0;

	if (el->el_tty.t_mode == ED_IO)
		return 0;

#ifndef WIDECHAR
/* FIONREAD attempts to buffer up multiple bytes, and to make that work
 * properly with partial wide/UTF-8 characters would need some careful work. */
#ifdef FIONREAD
	(void) ioctl(el->el_infd, FIONREAD, &chrs);
	if (chrs > 0) {
		char buf[EL_BUFSIZ];

		chrs = read(el->el_infd, buf,
		    (size_t) MIN(chrs, EL_BUFSIZ - 1));
		if (chrs > 0) {
			buf[chrs] = '\0';
			el_push(el, buf);
		}
	}
#endif /* FIONREAD */
#endif
	return chrs > 0;
}


a230 1
#ifdef WIDECHAR
a233 1
#endif
a371 5
		if (ma->level < 0) {
			if (!read_preread(el))
				break;
		}

@


1.29
log
@format string fixes in debug code;
committing right away because this code is not even compiled by default
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.28 2016/03/21 17:28:10 schwarze Exp $	*/
d149 1
a149 1
		if ((e = fcntl(fd, F_GETFL, 0)) == -1)
@


1.28
log
@Make the read_char() function always take a wchar_t * argument.

On first sight, it might look as if this required a bump because
it seems to change the public type el_rfunc_t.  But we only compile
with WIDECHAR, and in that case, there is no change in the interface.

This also simplifies some logic by getting rid of the NARROW_READ flag
which was broken anyway.

OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.27 2016/03/21 15:25:39 schwarze Exp $	*/
d615 1
a615 1
				    "Executing %s\n", b->name);
@


1.27
log
@Reduce the FUN() macro madness by no longer applying it to el_[w]getc(3).
Always use el_wgetc(3) internally.  In the !WIDECHAR case, casting
the result to (Char) is safe because the function returns a byte
rather than a character in that case.
No functional change except for fixing a printf(3) format string issue
when compiled with DEBUG_READ and WIDECHAR.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.26 2016/03/21 00:11:56 schwarze Exp $	*/
d56 1
a56 1
private int	read_char(EditLine *, Char *);
d301 1
a301 1
read_char(EditLine *el, Char *cp)
d328 1
a328 1
			*cp = '\0';
d335 1
a335 1
		*cp = '\0';
d369 1
a369 1
				*cp = '\0';
a403 1
	Char cp_temp;
d439 1
a439 1
	num_read = (*el->el_read.read_char)(el, &cp_temp);
a441 5
	*cp = cp_temp;
#ifdef WIDECHAR
	if (el->el_flags & NARROW_READ)
		*cp = *(char *)(void *)cp;
#endif
d484 1
d500 2
a501 1
		while ((num = (*el->el_read.read_char)(el, cp)) == 1) {
d553 2
a554 1
		while ((num = (*el->el_read.read_char)(el, cp)) == 1) {
@


1.26
log
@Merge a few simple fixes from NetBSD:
NetBSD rev. 1.68 2012/09/10 christos (bugfixes from Steffen Nurpmeso)
* el_wgetc(): set el_errno after read_char() failure
* el_wgets(): flag error condition after read_getcmd() failure
NetBSD rev. 1.69 2012/09/11 christos (bugfix from Christos Zoulas)
* read_getcmd(): return failure after el_wgetc() failure
NetBSD rev. 1.75 2016/02/12 christos (cleanup from Christos Zoulas)
* read_getcmd(): use a constant rather than a magical number
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.25 2016/03/20 23:48:27 schwarze Exp $	*/
d241 1
d246 1
a246 1
		if ((num = FUN(el,getc)(el, ch)) != 1) {/* if EOF or error */
d250 1
d396 2
a397 2
/* el_getc():
 *	Read a character
d400 1
a400 1
FUN(el,getc)(EditLine *el, Char *cp)
d404 1
d440 1
a440 1
	num_read = (*el->el_read.read_char)(el, cp);
d443 1
d449 1
a449 1
	(void) fprintf(el->el_errfile, "Got it %c\n", *cp);
@


1.25
log
@Cleanup of standard header inclusion:

1. Add the missing <errno.h> to sig.c.
2. Do not include standard headers from private headers "chared.h"
and "el.h", include them directly where needed.
3. Delete a few needless inclusions of <ctype.h>.
4. Sort the standard headers.
5. Delete _GNU_SOURCE weirdness from histedit.h, that file doesn't even
need the access to wcsdup(3) mentioned in the comment.
6. Delete some trailing blanks and blanks before tabs.

OK czarkoff@@
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.24 2016/03/20 20:16:09 schwarze Exp $	*/
/*	$NetBSD: read.c,v 1.57 2010/07/21 18:18:52 christos Exp $	*/
d233 1
a233 1
 *	Return next command from the input stream.
d239 1
d247 1
a247 1
			return num;
d251 1
a251 1
		if ((*ch & 0200)) {
d260 1
a260 1
			*ch |= 0200;
d438 2
d585 1
@


1.24
log
@Get rid of "#ifdef WIDECHAR" and one goto in read_char(),
making the code more readable.  Instead, provide an mbrtowc(3)
replacement function in chartype.[hc], files that encapsulate
such system dependencies anyway.  No functional change.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.23 2016/03/20 19:33:16 schwarze Exp $	*/
d42 1
d45 3
d49 1
a49 2
#include <stdlib.h>
#include <limits.h>
@


1.23
log
@Delete the weird IGNORE_EXTCHARS flag, simplifying the code
in the generic low-level function read_char().
Until we fully enable UTF-8 support, instead filter out non-ASCII
characters in the more logical place in the high-level function
el_gets(3).
OK czarkoff@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.22 2016/03/20 18:20:10 schwarze Exp $	*/
d333 1
a333 2
#ifdef WIDECHAR
	do {
d335 1
a335 1
again_lastbyte:
d348 1
a348 1
				goto again_lastbyte;
d370 1
a370 1
			break;
d372 1
a372 6
	} while (/*CONSTCOND*/0);
#else
	*cp = (unsigned char)cbuf[0];
#endif

	return 1;
@


1.22
log
@Fix read_char() for the non-UTF-8 case, in particular for systems
supporting other multibyte locales or having an internal representation
of wchar_t that doesn't match UCS-4.
No functional change on OpenBSD, but it makes the code less confusing.
OK czarkoff@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.21 2016/03/20 17:19:48 schwarze Exp $	*/
a300 1
	int bytes = 0;
a335 1
		size_t rbytes;
d340 1
a340 1
		switch (rbytes = ct_mbrtowc(cp, cbuf, cbp, &mbs)) {
a370 1
			bytes = (int)rbytes;
d378 1
a378 6
	if ((el->el_flags & IGNORE_EXTCHARS) && bytes > 1) {
		cbp = 0; /* skip this character */
		goto again;
	}

	return (int)num_read;
@


1.21
log
@Fix the CHARSET_IS_UTF8 case in read_char().
For now, this mainly help programs explicitly using
wide-character functions like el_wgetc(3) and el_wgets(3).

1. After reading an invalid byte sequence, do not throw away additional
valid bytes; fix by me using mbrtowc(3), obsoleting utf8_islead().
2. When read(2) returns EOF, return that information to the caller,
do not prod on and potentially access garbage data in the buffer;
from Linas Vepstas via NetBSD read.c rev. 1.70 2013/05/27.
3. After read__fixio() failure, restore errno to the one set by read();
from Steffen Nurpmeso via NetBSD read.c rev. 1.68 2012/09/10.
4. After read__fixio() success, restore errno to the initial state
upon function entry; fix by me.

OK czarkoff@@.  Also committed to NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.20 2016/01/31 20:42:33 schwarze Exp $	*/
d335 1
a335 1
	if (el->el_flags & CHARSET_IS_UTF8) {
d358 7
a364 1
			if (cbp >= MB_LEN_MAX) { /* "shouldn't happen" */
d376 3
a378 1
	} else  /* we don't support other multibyte charsets */
a379 1
		*cp = (unsigned char)cbuf[0];
@


1.20
log
@remove some whitespace differences with NetBSD; no change with diff -b
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.19 2016/01/30 17:32:52 schwarze Exp $	*/
a290 12
#ifdef WIDECHAR
/* utf8_islead():
 *	Test whether a byte is a leading byte of a UTF-8 sequence.
 */
private int
utf8_islead(unsigned char c)
{
	return c < 0x80 ||	       /* single byte char */
	       (c >= 0xc2 && c <= 0xf4); /* start of multibyte sequence */
}
#endif

d302 1
d307 1
d318 2
a319 1
		if (!tried && read__fixio(el->el_infd, errno) == 0)
d321 2
a322 1
		else {
d328 6
d336 3
a338 2
		if (!utf8_islead((unsigned char)cbuf[0]))
			goto again; /* discard the byte we read and try again */
d340 18
a357 2
		if ((bytes = ct_mbtowc(cp, cbuf, cbp)) == -1) {
			ct_mbtowc_reset;
d359 1
d363 1
d365 4
@


1.19
log
@Fifth step in synching with NetBSD:
Delete the silly ptr_t and ioctl_t typedefs
and delete some "#ifdef notdef" code from "sys.h".
No functional change.
This makes hist.h identical to the NetBSD version.
It reduces the remaining diff from +1526 -734 to +1430 -592.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.18 2016/01/30 12:22:20 schwarze Exp $	*/
d49 1
a49 1
#define	OKCMD	-1	/* must be -1! */
d130 1
a130 1
#define	TRY_AGAIN
d138 1
a138 1
#define	TRY_AGAIN
d259 2
a260 2
                if (*ch >= N_KEYS)
                        cmd = ED_INSERT;
d263 1
a263 1
                        cmd = el->el_map.current[(unsigned char) *ch];
d293 1
a293 1
 *      Test whether a byte is a leading byte of a UTF-8 sequence.
d311 3
a313 3
        char cbuf[MB_LEN_MAX];
        int cbp = 0;
        int bytes = 0;
d670 1
a670 1
			re_refresh(el);	/* print the prompt again */
@


1.18
log
@Fourth step in synching with NetBSD:
KNF: Remove parentheses from return lines.  No object change.
This makes emacs.c and prompt.c identical to the NetBSD versions.
It reduces the remaining diff from +2053 -1261 to +1526 -734.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.17 2016/01/30 00:06:39 schwarze Exp $	*/
d159 1
a159 1
			if (ioctl(fd, FIONBIO, (ioctl_t) & zero) == -1)
d193 1
a193 1
	(void) ioctl(el->el_infd, FIONREAD, (ioctl_t) & chrs);
d509 1
a509 1
		(void) ioctl(el->el_infd, FIONREAD, (ioctl_t) & chrs);
@


1.17
log
@Third step in synching with NetBSD:
* rename fkey_t to funckey_t and el_term_t to el_terminal_t
* rename struct editline member el_term to el_terminal
* rename many functions in terminal.c from term_*() to terminal_*(),
for consistency with the file name and to not look related to <term.h>
No functional change.
This makes refresh.c and sig.c almost identical to the NetBSD versions.
It reduces the remaining diff from +2446 -1805 to +2053 -1420.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.16 2016/01/29 19:32:33 schwarze Exp $	*/
d88 1
a88 1
       return (el->el_read.read_char == read_char) ?
d147 1
a147 1
			return (-1);
d150 1
a150 1
			return (-1);
d160 1
a160 1
				return (-1);
d167 1
a167 1
		return (e ? 0 : -1);
d170 1
a170 1
		return (0);
d173 1
a173 1
		return (-1);
d187 1
a187 1
		return (0);
d206 1
a206 1
	return (chrs > 0);
d243 1
a243 1
			return (num);
d288 1
a288 1
	return (OKCMD);
d298 2
a299 2
        return (c < 0x80) ||             /* single byte char */
               (c >= 0xc2 && c <= 0xf4); /* start of multibyte sequence */
d332 1
a332 1
			return (-1);
d345 1
a345 1
				return (-1);
d407 1
a407 1
		return (1);
d414 1
a414 1
		return (0);
d427 1
a427 1
	return (num_read);
d514 1
a514 1
				return (NULL);
@


1.16
log
@Second step in synching with NetBSD:
* Rename some types from *key*_t to *keymacro*_t.
* Rename struct editline member el_key to el_keymacro.
* Rename some functions in keymacro.c from key*() to keymacro*().
This removes the conflict of key_clear(), key_end(), and key_print()
with macros in <term.h>.  No functional change.
This makes keymacro.h identical to the NetBSD version.
It reduces the remaining diff from +2640 -1998 to +2446 -1805.
OK czarkoff@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.15 2014/10/17 06:07:50 deraadt Exp $	*/
d224 2
a225 2
	term_beep(el);
	term__flush(el);
d385 1
a385 1
	term__flush(el);
d448 1
a448 1
		term__flush(el);
d531 1
a531 1
		term__flush(el);
d638 1
a638 1
			term_beep(el);
d679 2
a680 2
			term_beep(el);
			term__flush(el);
d690 1
a690 1
	term__flush(el);		/* flush any buffered output */
@


1.15
log
@Remove non-exposed malloc/realloc/free wrappers, and then substitute
reallocarray() where it helps.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.14 2011/07/07 05:40:42 okan Exp $	*/
d265 2
a266 2
			key_value_t val;
			switch (key_get(el, ch, &val)) {
@


1.14
log
@sync with upstream, retaining local modifications.

ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.13 2010/06/30 00:05:35 nicm Exp $	*/
d369 1
a369 1
	el_free(ma->macro[0]);
@


1.13
log
@Update libedit to bring it into sync with the latest version from NetBSD.

ok deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: read.c,v 1.55 2010/03/22 22:59:06 christos Exp $	*/
d318 5
a322 1
		if (el->el_signal->sig_no == SIGCONT) {
a323 1
			el_set(el, EL_REFRESH);
d325 2
d466 1
a466 1
	Char ch;
a477 1
		Char *cp = el->el_line.buffer;
d480 1
d501 1
a501 4
		el->el_line.cursor = el->el_line.lastchar = cp;
		*cp = '\0';
		*nread = (int)(el->el_line.cursor - el->el_line.buffer);
		goto done;
a523 1
		Char *cp;
d555 1
a555 3
		el->el_line.cursor = el->el_line.lastchar = cp;
		*cp = '\0';
		goto done;
d698 5
@


1.12
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.11 2003/11/25 20:12:38 otto Exp $	*/
/*	$NetBSD: read.c,v 1.30 2003/10/18 23:48:42 christos Exp $	*/
d46 1
d49 1
a49 1
#define	OKCMD	-1
d53 3
a55 2
private int	read_char(EditLine *, char *);
private int	read_getcmd(EditLine *, el_action_t *, char *);
d189 3
d205 1
a205 1

d214 1
a214 1
el_push(EditLine *el, char *str)
d220 1
a220 1
		if ((ma->macro[ma->level] = el_strdup(str)) != NULL)
d225 1
a225 1
	term__flush();
d231 1
d234 1
a234 1
read_getcmd(EditLine *el, el_action_t *cmdnum, char *ch)
d239 1
d241 2
a242 1
		if ((num = el_getc(el, ch)) != 1)	/* if EOF or error */
d244 1
d258 6
a263 1
		cmd = el->el_map.current[(unsigned char) *ch];
d271 1
a271 1
				el_push(el, val.str);
d291 11
d307 1
a307 1
read_char(EditLine *el, char *cp)
d309 1
a309 1
	int num_read;
d311 12
a322 2

	while ((num_read = read(el->el_infd, cp, 1)) == -1)
d329 23
d353 1
a353 1
	return (num_read);
d356 14
d375 1
a375 1
el_getc(EditLine *el, char *cp)
d380 1
a380 1
	term__flush();
d386 1
d390 2
a391 3
		if (ma->macro[ma->level][ma->offset] == '\0') {
			el_free(ma->macro[ma->level--]);
			ma->offset = 0;
d394 4
a397 2
		*cp = ma->macro[ma->level][ma->offset++] & 0377;
		if (ma->macro[ma->level][ma->offset] == '\0') {
d399 1
a399 2
			el_free(ma->macro[ma->level--]);
			ma->offset = 0;
d401 1
d415 4
d439 1
a439 1
	ch_reset(el);
d441 3
d455 2
a456 2
public const char *
el_gets(EditLine *el, int *nread)
d461 1
a461 1
	char ch;
d463 1
d468 4
d473 1
a473 1
		char *cp = el->el_line.buffer;
d476 1
a476 1
		while ((*el->el_read.read_char)(el, cp) == 1) {
d490 5
d498 2
a499 3
		if (nread)
			*nread = el->el_line.cursor - el->el_line.buffer;
		return (el->el_line.buffer);
d510 2
a511 2
				if (nread)
					*nread = 0;
d522 1
a522 1
		char *cp = el->el_line.buffer;
d525 6
a530 1
		term__flush();
d532 1
a532 1
		while ((*el->el_read.read_char)(el, cp) == 1) {
a539 2
			if (*cp == 4)	/* ought to be stty eof */
				break;
d548 6
d556 1
a556 3
		if (nread)
			*nread = el->el_line.cursor - el->el_line.buffer;
		return (el->el_line.buffer);
d572 7
a578 1
		if ((uint)cmdnum >= el->el_map.nfunc) {	/* BUG CHECK command */
d608 1
a608 1
			    && isprint(el->el_chared.c_redo.pos[-1]))
d653 1
a653 1
				*el->el_line.lastchar++ = CTRL('d');
d660 1
a660 1
			num = el->el_line.lastchar - el->el_line.buffer;
d670 1
a670 1
			ch_reset(el);	/* reset the input pointers */
d681 1
a681 1
			term__flush();
d691 1
a691 1
	term__flush();		/* flush any buffered output */
d695 1
a695 2
		if (nread)
			*nread = num;
d697 1
a697 2
		if (nread)
			*nread = el->el_line.lastchar - el->el_line.buffer;
d699 9
a707 1
	return (num ? el->el_line.buffer : NULL);
@


1.11
log
@Sync libedit to NetBSD libedit as of Nov 8, 2003.
Tested by jmc@@ djm@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.10 2003/10/31 08:42:24 otto Exp $	*/
a36 7
#if !defined(lint) && !defined(SCCSID)
#if 0
static char sccsid[] = "@@(#)read.c	8.1 (Berkeley) 6/4/93";
#else
static const char rcsid[] = "$OpenBSD: read.c,v 1.10 2003/10/31 08:42:24 otto Exp $";
#endif
#endif /* not lint && not SCCSID */
@


1.10
log
@Update to NetBSD libedit (from Oct 1, 2003), adding some string
cleaning and history bug fixes. The code includes GNU libreadline
functionality, but the corresponding header files are not installed,
since some libreadline functions are missing. There are some minor API
changes, notably:

old: EditLine *el_init(const char *, FILE *, FILE *);
new: EditLine *el_init(const char *, FILE *, FILE *, FILE *);

old: HistEvent *history(History *h, int op, ...);
new: int history(History *h, HistEvent *ev, int op, ...); plus some
changes in operation names. See editline(3) for details.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: read.c,v 1.28 2003/09/26 17:44:51 christos Exp $	*/
d41 1
a41 1
static const char rcsid[] = "$OpenBSD$";
a190 4
	if (el->el_chared.c_macro.nline) {
		el_free((ptr_t) el->el_chared.c_macro.nline);
		el->el_chared.c_macro.nline = NULL;
	}
d203 1
a203 2
			el->el_chared.c_macro.nline = strdup(buf);
			el_push(el, el->el_chared.c_macro.nline);
d222 3
a224 4
		ma->macro[ma->level] = str;
	} else {
		term_beep(el);
		term__flush();
d226 2
d324 3
a326 2
		if (*ma->macro[ma->level] == 0) {
			ma->level--;
d329 5
a333 4
		*cp = *ma->macro[ma->level]++ & 0377;
		if (*ma->macro[ma->level] == 0) {	/* Needed for QuoteMode
							 * On */
			ma->level--;
d554 7
a560 1
			num = 0;
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.8 2003/05/01 21:11:21 avsm Exp $	*/
/*	$NetBSD: read.c,v 1.4 1997/04/11 17:52:47 christos Exp $	*/
d36 1
d41 1
a41 1
static const char rcsid[] = "$OpenBSD: read.c,v 1.8 2003/05/01 21:11:21 avsm Exp $";
d49 2
a50 2
#include "sys.h"
#include <sys/errno.h>
a52 1
extern int errno;
d55 1
a55 1
#define OKCMD -1
d57 44
a100 3
private int read__fixio(int, int);
private int read_preread(EditLine *);
private int read_getcmd(EditLine *, el_action_t *, char *);
d104 1
a104 2
read_debug(el)
    EditLine *el;
d107 10
a116 10
    if (el->el_line.cursor > el->el_line.lastchar)
	(void)fprintf(el->el_errfile, "cursor > lastchar\r\n");
    if (el->el_line.cursor < el->el_line.buffer)
	(void)fprintf(el->el_errfile, "cursor < buffer\r\n");
    if (el->el_line.cursor > el->el_line.limit)
	(void)fprintf(el->el_errfile, "cursor > limit\r\n");
    if (el->el_line.lastchar > el->el_line.limit)
	(void)fprintf(el->el_errfile, "lastchar > limit\r\n");
    if (el->el_line.limit != &el->el_line.buffer[EL_BUFSIZ - 2])
	(void)fprintf(el->el_errfile, "limit != &buffer[EL_BUFSIZ-2]\r\n");
d120 1
d124 1
d126 1
a126 2
read__fixio(fd, e)
    int fd, e;
d128 3
a130 2
    switch (e) {
    case -1:	/* Make sure that the code is reachable */
d133 4
a136 4
    case EWOULDBLOCK:
# ifndef TRY_AGAIN
#  define TRY_AGAIN
# endif
d140 6
a145 6
# if defined(EWOULDBLOCK) && EWOULDBLOCK != EAGAIN
    case EAGAIN:
#  ifndef TRY_AGAIN
#   define TRY_AGAIN
#  endif
# endif /* EWOULDBLOCK && EWOULDBLOCK != EAGAIN */
d148 1
a148 1
	e = 0;
d150 20
a169 16
# if defined(F_SETFL) && defined(O_NDELAY)
	if ((e = fcntl(fd, F_GETFL, 0)) == -1)
	    return -1;

	if (fcntl(fd, F_SETFL, e & ~O_NDELAY) == -1)
	    return -1;
	else 
	    e = 1;
# endif /* F_SETFL && O_NDELAY */

# ifdef FIONBIO
	if (ioctl(fd, FIONBIO, (ioctl_t) &e) == -1)
	    return -1;
	else
	    e = 1;
# endif	/* FIONBIO */
d172 1
a172 1
	return e ? 0 : -1;
d174 2
a175 2
    case EINTR:
	return 0;
d177 3
a179 3
    default:
	return -1;
    }
d187 1
a187 2
read_preread(el)
    EditLine *el;
d189 1
a189 1
    int    chrs = 0;
d191 6
a196 7
    if (el->el_chared.c_macro.nline) {
	el_free((ptr_t) el->el_chared.c_macro.nline);
	el->el_chared.c_macro.nline = NULL;
    }

    if (el->el_tty.t_mode == ED_IO)
	return 0;
d199 3
a201 3
    (void)ioctl(el->el_infd, FIONREAD, (ioctl_t) &chrs);
    if (chrs > 0) {
	char    buf[EL_BUFSIZ];
d203 7
a209 5
	chrs = read(el->el_infd, buf, (size_t) MIN(chrs, EL_BUFSIZ - 1));
	if (chrs > 0) {
	    buf[chrs] = '\0';
	    el->el_chared.c_macro.nline = strdup(buf);
	    el_push(el, el->el_chared.c_macro.nline);
d211 1
a211 2
    }
#endif  /* FIONREAD */
d213 1
a213 1
    return chrs > 0;
d221 11
a231 14
el_push(el, str)
    EditLine *el;
    const char   *str;
{
    c_macro_t *ma = &el->el_chared.c_macro;

    if (str != NULL && ma->level + 1 < EL_MAXMACRO) {
	ma->level++;
	ma->macro[ma->level] = (char *) str;
    }
    else {
	term_beep(el);
	term__flush();
    }
d239 8
a246 11
read_getcmd(el, cmdnum, ch)
    EditLine *el;
    el_action_t *cmdnum;
    char *ch;
{
    el_action_t  cmd = 0;
    int     num;

    while (cmd == 0 || cmd == ED_SEQUENCE_LEAD_IN) {
	if ((num = el_getc(el, ch)) != 1)	/* if EOF or error */
	    return num;
d249 5
a253 6
	if ((*ch & 0200)) {
	    el->el_state.metanext = 0;
	    cmd = CcViMap[' '];
	    break;
	}
	else
d256 14
a269 14
	if (el->el_state.metanext) {
	    el->el_state.metanext = 0;
	    *ch |= 0200;
	}
	cmd = el->el_map.current[(unsigned char) *ch];
	if (cmd == ED_SEQUENCE_LEAD_IN) {
	    key_value_t val;
	    switch (key_get(el, ch, &val)) {
	    case XK_CMD:
		cmd = val.cmd;
		break;
	    case XK_STR:
		el_push(el, val.str);
		break;
d271 4
a274 4
	    case XK_EXE:
		/* XXX: In the future to run a user function */
		RunCommand(val.str);
		break;
d276 31
a306 10
	    default:
		abort();
		break;
	    }
	}
	if (el->el_map.alt == NULL) 
	    el->el_map.current = el->el_map.key;
    }
    *cmdnum = cmd;
    return OKCMD;
d314 24
a337 22
el_getc(el, cp)
    EditLine *el;
    char *cp;
{
    int num_read;
    unsigned char tcp;
    int tried = 0;

    c_macro_t *ma = &el->el_chared.c_macro;

    term__flush();
    for (;;) {
	if (ma->level < 0) {
	    if (!read_preread(el))
		break;
	}
	if (ma->level < 0) 
	    break;
   
	if (*ma->macro[ma->level] == 0) {
	    ma->level--;
	    continue;
a338 6
	*cp = *ma->macro[ma->level]++ & 0377;
	if (*ma->macro[ma->level] == 0) {	/* Needed for QuoteMode On */
	    ma->level--;
	}
	return 1;
    }
d341 1
a341 1
    (void)fprintf(el->el_errfile, "Turning raw mode on\n");
d343 2
a344 2
    if (tty_rawmode(el) < 0)	/* make sure the tty is set up correctly */
	return 0;
d347 1
a347 1
    (void)fprintf(el->el_errfile, "Reading a character\n");
d349 1
a349 7
    while ((num_read = read(el->el_infd, (char *) &tcp, 1)) == -1)
	if (!tried && read__fixio(el->el_infd, errno) == 0)
	    tried = 1;
	else {
	    *cp = '\0';
	    return -1;
	}
d351 1
a351 1
    (void)fprintf(el->el_errfile, "Got it %c\n", tcp);
d353 1
a353 2
    *cp = tcp;
    return num_read;
d356 17
d374 8
d384 7
a390 8
el_gets(el, nread)
    EditLine *el;
    int *nread;
{
    int retval;
    el_action_t  cmdnum = 0;
    int     num;		/* how many chars we have read at NL */
    char    ch;
d392 1
a392 1
    c_macro_t *ma = &el->el_chared.c_macro;
d395 25
a419 2
    if (el->el_flags & HANDLE_SIGNALS)
	sig_set(el);
a420 2
    re_clear_display(el);		/* reset the display stuff */
    ch_reset(el);
d423 2
a424 2
    if (el->el_tty.t_mode == EX_IO && ma->level < 0) {
	int    chrs = 0;
d426 8
a433 7
	(void)ioctl(el->el_infd, FIONREAD, (ioctl_t) &chrs);
	if (chrs == 0) {
	    if (tty_rawmode(el) < 0) {
		if (nread)
			*nread = 0;
		return NULL;
	    }
a434 1
    }
d437 2
a438 1
    re_refresh(el);			/* print the prompt */
d440 33
a472 1
    for (num = OKCMD; num == OKCMD;) {	/* while still editing this line */
d474 1
a474 1
	read_debug(el);
d476 2
a477 2
	/* if EOF or error */
	if ((num = read_getcmd(el, &cmdnum, &ch)) != OKCMD) {
d479 2
a480 1
	    (void)fprintf(el->el_errfile, "Returning from el_gets %d\n", num);
d482 3
a484 4
	    break;
	}

	if (cmdnum >= el->el_map.nfunc) {	/* BUG CHECK command */
d486 2
a487 2
	    (void)fprintf(el->el_errfile, 
			   "ERROR: illegal command from key 0%o\r\n", ch);
d489 31
a519 4
	    continue;		/* try again */
	}

	/* now do the real command */
d521 2
a522 10
	{
	    el_bindings_t *b;
	    for (b = el->el_map.help; b->name; b++)
		if (b->func == cmdnum)
		    break;
	    if (b->name)
		(void)fprintf(el->el_errfile, "Executing %s\n", b->name);
	    else
		(void)fprintf(el->el_errfile, "Error command = %d\n", cmdnum);
	}
a523 1
	retval = (*el->el_map.func[cmdnum])(el, ch);
d525 2
a526 2
	/* save the last command here */
	el->el_state.lastcmd = cmdnum;
d528 34
a561 35
	/* use any return value */
	switch (retval) {
	case CC_CURSOR:
	    el->el_state.argument = 1;
	    el->el_state.doingarg = 0;
	    re_refresh_cursor(el);
	    break;

	case CC_REDISPLAY:
	    re_clear_lines(el);
	    re_clear_display(el);
		/* FALLTHROUGH */

	case CC_REFRESH:
	    el->el_state.argument = 1;
	    el->el_state.doingarg = 0;
	    re_refresh(el);
	    break;

	case CC_NORM:		/* normal char */
	    el->el_state.argument = 1;
	    el->el_state.doingarg = 0;
	    break;

	case CC_ARGHACK:	/* Suggested by Rich Salz */
	    /* <rsalz@@pineapple.bbn.com> */
	    break;		/* keep going... */

	case CC_EOF:		/* end of file typed */
	    num = 0;
	    break;

	case CC_NEWLINE:	/* normal end of line */
	    num = el->el_line.lastchar - el->el_line.buffer;	
	    break;
d563 1
a563 1
	case CC_FATAL:		/* fatal error, reset to known state */
d565 2
a566 1
	    (void)fprintf(el->el_errfile, "*** editor fatal ERROR ***\r\n\n");
d568 5
a572 7
	    /* put (real) cursor in a known place */
	    re_clear_display(el);	/* reset the display stuff */
	    ch_reset(el);		/* reset the input pointers */
	    re_refresh(el);		/* print the prompt again */
	    el->el_state.argument = 1;
	    el->el_state.doingarg = 0;
	    break;
d574 2
a575 2
	case CC_ERROR:
	default:		/* functions we don't know about */
d577 2
a578 1
	    (void)fprintf(el->el_errfile, "*** editor ERROR ***\r\n\n");
d580 9
a588 5
	    el->el_state.argument = 1;
	    el->el_state.doingarg = 0;
	    term_beep(el);
	    term__flush();
	    break;
a589 1
    }
d591 11
a601 7
    (void)tty_cookedmode(el);	/* make sure the tty is set up correctly */
    term__flush();		/* flush any buffered output */
    if (el->el_flags & HANDLE_SIGNALS)
	sig_clr(el);
    if (nread)
	    *nread = num;
    return num ? el->el_line.buffer : NULL;
@


1.8
log
@is -Wall clean by making rcsid const
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.7 2002/02/16 21:27:26 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static const char rcsid[] = "$OpenBSD: read.c,v 1.7 2002/02/16 21:27:26 millert Exp $";
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.6 1997/08/20 03:30:13 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: read.c,v 1.6 1997/08/20 03:30:13 millert Exp $";
@


1.6
log
@Make this compile is FIONREAD is defined.  Guess this was
never tested.  Closed NetBSD PR#4012 from David Holland
<dholland@@bordeaux.eecs.harvard.edu>.
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.5 1997/06/29 23:40:50 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: read.c,v 1.5 1997/06/29 23:40:50 millert Exp $";
d61 3
a63 3
private int read__fixio		__P((int, int));
private int read_preread	__P((EditLine *));
private int read_getcmd		__P((EditLine *, el_action_t *, char *));
@


1.5
log
@Updates from NetBSD (christos@@netbsd.org)
  * Portability fixes:
	__const         -> const
	BADSIG          -> SIG_ERR
	int flags       -> u_int flags
	#if __STDC__    -> #ifdef __STDC__
  * Don't allow CSWTCH to interfere with CSUSP on __SVR4 systems.
  * Return -1 if the terminal set operation resulted in dumb terminal settings.
  * Handle properly the case where the last line in the sourced file does
    not have a trailing '\n'. From Jeffrey C Honig.
  * editrc -> editline in editline(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.4 1997/06/10 20:10:13 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: read.c,v 1.4 1997/06/10 20:10:13 millert Exp $";
d167 1
a167 1
	    el_push(el->el_chared.c_macro.nline);
d323 3
@


1.4
log
@Change a long to and int.
@
text
@d1 2
a2 2
/*	$OpenBSD: read.c,v 1.3 1997/03/14 05:12:58 millert Exp $	*/
/*	$NetBSD: read.c,v 1.3 1997/01/14 04:17:25 lukem Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: read.c,v 1.3 1997/03/14 05:12:58 millert Exp $";
d96 3
a98 1
# define TRY_AGAIN
d104 3
a106 1
#  define TRY_AGAIN
@


1.3
log
@fix el_source() - a block needed braces around it (from NetBSD)
Some strcpy() -> strncpy (from NetBSD)
Some KNF
Add current NetBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: read.c,v 1.2 1997/01/16 05:18:42 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: read.c,v 1.2 1997/01/16 05:18:42 millert Exp $";
d328 1
a328 1
	long    chrs = 0;
@


1.2
log
@Merge in NetBSD libedit changes and new man pages.  Also fix some
strncpy() usage in their code.  NetBSD change log was:
    * add a man page for the editline routines
    * add a man page describing editrc
    * fix bugs in el_parse():
      * didn't execute command when program name matched (test reversed)
      * was checking against empty string instead of program name
      * after checks, command to run also pointed to empty string
    * document ^char and \ escape sequences
    * when parsing ^char control chars, check the correct char when determining
      validity (previously, ^char was a NOP interpreted as the literal string
      because of this bug)
    * Implement CC_REDISPLAY, which (unlike CC_REFRESH) redraws the entire input
    * line (a la ^R). This is useful if the binding outputs information and
    * mucks up the input line. To be used in ``list-choices'' bindings (refer
    * to the ^D binding in csh when filec is set)
@
text
@d1 2
a2 1
/*	$OpenBSD: $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: $";
d72 1
a72 1
	(void) fprintf(el->el_errfile, "cursor > lastchar\r\n");
d74 1
a74 1
	(void) fprintf(el->el_errfile, "cursor < buffer\r\n");
d76 1
a76 1
	(void) fprintf(el->el_errfile, "cursor > limit\r\n");
d78 1
a78 1
	(void) fprintf(el->el_errfile, "lastchar > limit\r\n");
d80 1
a80 1
	(void) fprintf(el->el_errfile, "limit != &buffer[EL_BUFSIZ-2]\r\n");
d155 1
a155 1
    (void) ioctl(el->el_infd, FIONREAD, (ioctl_t) &chrs);
d286 1
a286 1
    (void) fprintf(el->el_errfile, "Turning raw mode on\n");
d292 1
a292 1
    (void) fprintf(el->el_errfile, "Reading a character\n");
d302 1
a302 1
    (void) fprintf(el->el_errfile, "Got it %c\n", tcp);
d330 1
a330 1
	(void) ioctl(el->el_infd, FIONREAD, (ioctl_t) &chrs);
d350 1
a350 1
	    (void) fprintf(el->el_errfile, "Returning from el_gets %d\n", num);
d357 1
a357 1
	    (void) fprintf(el->el_errfile, 
d371 1
a371 1
		(void) fprintf(el->el_errfile, "Executing %s\n", b->name);
d373 1
a373 1
		(void) fprintf(el->el_errfile, "Error command = %d\n", cmdnum);
d419 1
a419 1
	    (void) fprintf(el->el_errfile, "*** editor fatal ERROR ***\r\n\n");
d432 1
a432 1
	    (void) fprintf(el->el_errfile, "*** editor ERROR ***\r\n\n");
d442 1
a442 1
    (void) tty_cookedmode(el);	/* make sure the tty is set up correctly */
@


1.1
log
@Initial revision
@
text
@d1 2
d40 1
d42 4
a46 1
#endif /* not lint && not SCCSID */
d387 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
