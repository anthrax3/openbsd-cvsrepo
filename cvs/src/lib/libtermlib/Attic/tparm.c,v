head	1.7;
access;
symbols
	OPENBSD_2_8:1.6.0.12
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.10
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	initial:1.1.1.1
	tholo:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2000.12.05.17.57.53;	author millert;	state dead;
branches;
next	1.6;

1.6
date	97.12.16.03.10.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.07.25.20.30.26;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.03.28.00.39.08;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.09.16.02.41.53;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.02.23.47.51;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	96.05.31.05.40.02;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.05.31.05.40.02;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.7
log
@We haven't used this in years, remove it.
@
text
@/*	$OpenBSD: tparm.c,v 1.6 1997/12/16 03:10:05 millert Exp $	*/

/*
 * Copyright (c) 1996 SigmaSoft, Th. Lockert <tholo@@sigmasoft.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by SigmaSoft, Th.  Lockert.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef lint
static char rcsid[] = "$OpenBSD: tparm.c,v 1.6 1997/12/16 03:10:05 millert Exp $";
#endif

#include <stdio.h>
#include <stdlib.h>
#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif
#include <string.h>
#include <ctype.h>

#ifdef MAX
#undef MAX
#endif

#define	MAX(a, b)	((a) < (b) ? (b) : (a))

#define	STKSIZ		32
#define	MAXRETURNSIZE	256

static __inline void push __P((int));
static __inline int popnum __P((void));
static __inline char *popstr __P((void));

static char *_tparm __P((const char *, char *, size_t, va_list));

static union {
    unsigned int	num;
    char		*str;
} stack[STKSIZ];

static int stackidx;

static __inline void
push(value)
     int value;
{
    if (stackidx < STKSIZ)
	stack[stackidx++].num = value;
}

static __inline int
popnum()
{
    return stackidx > 0 ? stack[--stackidx].num : 0;
}

static __inline char *
popstr()
{
    return stackidx > 0 ? stack[--stackidx].str : NULL;
}

/*
 * This function is identical to the GNU tparam() but we don't
 * advertise it as such since it confuses emacs (and perhaps others).
 */
static char *
_tparm(str, buf, siz, ap)
     const char *str;
     char *buf;
     size_t siz;
     va_list ap;
{
    int param[10], variable[26];
    int pops, num, i, level;
    char scratch[64];
    char *bufp, len;
    const char *p;

    if (str == NULL)
	return NULL;

    for (p = str, pops = 0, num = 0; *p != '\0'; p++)
	if (*p == '%' && *(p + 1) != '\0') {
	    switch (p[1]) {
		case '%':
		    p++;
		    break;
		case 'i':
		    if (pops < 2)
			pops = 2;
		    break;
		case 'p':
		    p++;
		    if (isdigit(p[1])) {
			int n = p[1] - '0';

			if (n > pops)
			    pops = n;
		    }
		    break;
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
		case 'c':
		case 'd':
		case 's':
		    num++;
		    break;
	    }
	}

    for (i = 0; i < MAX(pops, num); i++)
	param[i] = va_arg(ap, int);	/* XXX  arg size might be different than int */

    stackidx = 0;
    bufp = buf;

    while (*str) {
	if (*str != '%') {
	    if (bufp >= buf + siz)
		return(NULL);
	    *bufp++ = *str;
	}
	else {
	    switch (*++str) {
		case '%':
		    if (bufp >= buf + siz)
			return(NULL);
		    *bufp++ = '%';
		    break;
		case 'd':
		    sprintf(scratch, "%d", popnum());
		    if (bufp + strlen(scratch) >= buf + siz)
			return(NULL);
		    strcpy(bufp, scratch);
		    bufp += strlen(bufp);
		    break;
		case '0':
		    len = *++str;
		    if (len == '2' || len == '3') {
			if (*++str == 'd') {
			    if (len == '2')
				sprintf(scratch, "%02d", popnum());
			    else
				sprintf(scratch, "%03d", popnum());
			    if (bufp + strlen(scratch) >= buf + siz)
				return(NULL);
			    strcpy(bufp, scratch);
			    bufp += strlen(bufp);
			}
			else if (*str == 'x') {
			    if (len == '2')
				sprintf(scratch, "%02x", popnum());
			    else
				sprintf(scratch, "%03x", popnum());
			    if (bufp + strlen(scratch) >= buf + siz)
				return(NULL);
			    strcpy(bufp, scratch);
			    bufp += strlen(bufp);
			}
		    }
		    break;
		case '2':
		    if (*++str == 'd') {
			sprintf(scratch, "%2d", popnum());
			if (bufp + strlen(scratch) >= buf + siz)
			    return(NULL);
			strcpy(bufp, scratch);
			bufp += strlen(bufp);
		    }
		    else if (*str == 'x') {
			sprintf(scratch, "%2x", popnum());
			if (bufp + strlen(scratch) >= buf + siz)
			    return(NULL);
			strcpy(bufp, scratch);
			bufp += strlen(bufp);
		    }
		    break;
		case '3':
		    if (*++str == 'd') {
			sprintf(scratch, "%3d", popnum());
			if (bufp + strlen(scratch) >= buf + siz)
			    return(NULL);
			strcpy(bufp, scratch);
			bufp += strlen(bufp);
		    }
		    else if (*str == 'x') {
			sprintf(scratch, "%3x", popnum());
			if (bufp + strlen(scratch) >= buf + siz)
			    return(NULL);
			strcpy(bufp, scratch);
			bufp += strlen(bufp);
		    }
		    break;
		case 'c':
		    if (bufp >= buf + siz)
			return(NULL);
		    *bufp++ = (char)popnum();
		    break;
		case 's':
		    if (bufp + strlen(p = popstr()) >= buf + siz)
			return(NULL);
		    strcpy(bufp, p);
		    bufp += strlen(bufp);
		    break;
		case 'p':
		    str++;
		    if (*str != '0' && isdigit(*str))
			push(param[*str - '1']);
		    break;
		case 'P':
		    str++;
		    if (islower(*str))
			variable[*str - 'a'] = popnum();
		    break;
		case 'g':
		    str++;
		    if (islower(*str))
			push(variable[*str - 'a']);
		    break;
		case '\'':
		    push(*++str & 0xFF);
		    str++;
		    break;
		case '{':
		    num = 0;
		    str++;
		    while (isdigit(*str))
			num = num * 10 + (*str++ - '0');
		    push(num);
		    break;
		case '+':
		    push(popnum() + popnum());
		    break;
		case '-':
		    num = popnum();
		    push(popnum() - num);
		    break;
		case '*':
		    push(popnum() * popnum());
		    break;
		case '/':
		    num = popnum();
		    push(popnum() / num);
		    break;
		case 'm':
		    num = popnum();
		    push(popnum() % num);
		    break;
		case 'A':
		    num = popnum();
		    push(popnum() && num);
		    break;
		case 'O':
		    num = popnum();
		    push(popnum() || num);
		    break;
		case '&':
		    push(popnum() & popnum());
		    break;
		case '|':
		    push(popnum() | popnum());
		    break;
		case '^':
		    push(popnum() ^ popnum());
		    break;
		case '=':
		    push(popnum() == popnum());
		    break;
		case '<':
		    push(popnum() > popnum());
		    break;
		case '>':
		    push(popnum() < popnum());
		    break;
		case '!':
		    push(!popnum());
		    break;
		case '~':
		    push(~popnum());
		    break;
		case 'i':
		    param[0]++;
		    param[1]++;
		    break;
		case '?':
		    break;
		case 't':
		    if (!popnum()) {
			str++;
			level = 0;
			while (*str) {
			    if (*str == '%') {
				if (*++str == '?')
				    level++;
				else if (*str == ';') {
				    if (level > 0)
					level--;
				    else
					break;
				}
				else if (*str == 'e' && level == 0)
				    break;
			    }
			    if (*str)
				str++;
			}
		    }
		    break;
		case 'e':
		    str++;
		    level = 0;
		    while (*str) {
			if (*str == '%') {
			    if (*++str == '?')
				level++;
			    else if (*str == ';') {
				if (level > 0)
				    level--;
				else
				    break;
			    }
			}
			if (*str)
			    str++;
		    }
		    break;
		case ';':
		    break;
		default:
		    break;
	    }
	}
	if (*str != '\0')
	    str++;
    }

    if (bufp >= buf + siz)
	return(NULL);
    *bufp = '\0';
    return(buf);
}

char *
#ifdef __STDC__
tparm(const char *str, ...)
#else
tparm(va_alist)
     va_dcl
#endif
{
    static char buf[MAXRETURNSIZE];
    va_list ap;
    char *p;
#ifndef __STDC__
    const char *str;

    va_start(ap);
    str = va_arg(ap, const char *);
#else
    /* LINTED pointer casts may be troublesome */
    va_start(ap, str);
#endif
    p = _tparm(str, buf, sizeof(buf), ap);
    /* LINTED expression has no effect */
    va_end(ap);
    return(p);
}
@


1.6
log
@tparm() now returns NULL for buffers that would be >= 256 (termcap
size limit).  Also, make _tparm take a size argument.  This isn't
strictly necesary as we know the size of the buffer and this function
is only used internally but this has the added benefit of making
_tparm == GNU tparam if we ever want to export it as such.  There
are reported to be problems with emacs when native libtermlib has
tparam() so we keep this private for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: tparm.c,v 1.5 1997/07/25 20:30:26 mickey Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: tparm.c,v 1.5 1997/07/25 20:30:26 mickey Exp $";
@


1.5
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: tparm.c,v 1.4 1997/03/28 00:39:08 tholo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: tparm.c,v 1.4 1997/03/28 00:39:08 tholo Exp $";
d60 1
a60 1
static char *_tparm __P((const char *, char *, va_list));
d89 4
d94 1
a94 1
_tparm(str, buf, ap)
d97 1
d146 2
a147 2
	    if (bufp >= buf + MAXRETURNSIZE)
		goto overflow;
d153 2
a154 2
		    if (bufp >= buf + MAXRETURNSIZE)
			goto overflow;
d159 2
a160 2
		    if (bufp + strlen(scratch) >= buf + MAXRETURNSIZE)
			goto overflow;
d172 2
a173 2
			    if (bufp + strlen(scratch) >= buf + MAXRETURNSIZE)
				goto overflow;
d182 2
a183 2
			    if (bufp + strlen(scratch) >= buf + MAXRETURNSIZE)
				goto overflow;
d192 2
a193 2
			if (bufp + strlen(scratch) >= buf + MAXRETURNSIZE)
			    goto overflow;
d199 2
a200 2
			if (bufp + strlen(scratch) >= buf + MAXRETURNSIZE)
			    goto overflow;
d208 2
a209 2
			if (bufp + strlen(scratch) >= buf + MAXRETURNSIZE)
			    goto overflow;
d215 2
a216 2
			if (bufp + strlen(scratch) >= buf + MAXRETURNSIZE)
			    goto overflow;
d222 2
a223 2
		    if (bufp >= buf + MAXRETURNSIZE)
			goto overflow;
d227 2
a228 2
		    if (bufp + strlen(p = popstr()) >= buf + MAXRETURNSIZE)
			goto overflow;
d364 2
a365 2
    if (bufp >= buf + MAXRETURNSIZE)
	goto overflow;
a367 3
overflow:
    strcpy(buf, "OVERFLOW!");
    return(buf);
d390 1
a390 1
    p = _tparm(str, buf, ap);
@


1.4
log
@Don't allow buffer overflows
@
text
@d1 1
a1 1
/*	$OpenBSD: tparm.c,v 1.3 1996/09/16 02:41:53 tholo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: tparm.c,v 1.3 1996/09/16 02:41:53 tholo Exp $";
d39 1
a39 1
#if __STDC__
d369 1
a369 1
#if __STDC__
d379 1
a379 1
#if !__STDC__
@


1.3
log
@Fix some warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: tparm.c,v 1.2 1996/06/02 23:47:51 tholo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: tparm.c,v 1.2 1996/06/02 23:47:51 tholo Exp $";
d53 2
a54 1
#define	STKSIZ	32
d97 1
d140 3
a142 1
	if (*str != '%')
d144 1
d148 2
d153 4
a156 1
		    sprintf(bufp, "%d", popnum());
d164 1
a164 1
				sprintf(bufp, "%02d", popnum());
d166 4
a169 1
				sprintf(bufp, "%03d", popnum());
d174 1
a174 1
				sprintf(bufp, "%02x", popnum());
d176 4
a179 1
				sprintf(bufp, "%03x", popnum());
d186 4
a189 1
			sprintf(bufp, "%2d", popnum());
d193 4
a196 1
			sprintf(bufp, "%2x", popnum());
d202 4
a205 1
			sprintf(bufp, "%3d", popnum());
d209 4
a212 1
			sprintf(bufp, "%3x", popnum());
d217 2
d222 3
a224 1
		    strcpy(bufp, popstr());
d359 2
d363 3
d376 1
a376 1
    static char buf[256];
@


1.2
log
@Some format strings were not handled entirely right, fixed.
Remove unused argument to internal _tparm
@
text
@d1 1
a1 1
/*	$OpenBSD: tparm.c,v 1.1.1.1 1996/05/31 05:40:02 tholo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: tparm.c,v 1.1.1.1 1996/05/31 05:40:02 tholo Exp $";
d348 1
d352 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD$";
d59 1
a59 1
static char *_tparm __P((const char *, char *, size_t, va_list));
d89 1
a89 1
_tparm(str, buf, len, ap)
a91 1
     size_t len;
d95 2
a96 1
    int pops, num, i, level, incr;
a97 1
    char *bufp;
d102 1
a102 1
    for (p = str, pops = 0, num = 0, incr = 0; *p != '\0'; p++)
a110 1
		    incr++;
a133 4
    if (pops == 0)
	for (i = pops = num; i > 0; i--)
	    push(param[i - 1]);

d150 1
a150 2
		    str++;
		    len = *str & 0xFF;
d197 1
a197 1
		    if (isdigit(*str))
d218 1
a218 1
			num = num * 10 + *str++ - '0';
a311 2
			    else if (*str == 'e' && level == 0)
				break;
d350 1
a350 1
    p = _tparm(str, buf, sizeof(buf) - 1, ap);
@


1.1.1.1
log
@Terminfo emulation library; currently understands only about reading from
termcap database using cgetent(3)
@
text
@@
