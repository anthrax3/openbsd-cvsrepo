head	1.10;
access;
symbols
	OPENBSD_4_8:1.9.0.30
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.8
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.6
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.10
date	2010.10.17.08.45.17;	author djm;	state dead;
branches;
next	1.9;

1.9
date	2003.04.02.22.57.51;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.02.17.02.05;	author rees;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.02.15.09.35;	author rees;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.30.20.05.39;	author rees;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.17.21.10.56;	author rees;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.02.20.07.08;	author rees;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.08.15.04.03;	author rees;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.07.16.10.00;	author rees;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.07.15.17.33;	author rees;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove libsectok; it hasn't been updated in years and doesn't work
with the current generation of tokens; ok markus@@ deraadt@@
@
text
@/* $Id: r1r2.c,v 1.9 2003/04/02 22:57:51 deraadt Exp $ */

/*
copyright 1999
the regents of the university of michigan
all rights reserved

permission is granted to use, copy, create derivative works 
and redistribute this software and such derivative works 
for any purpose, so long as the name of the university of 
michigan is not used in any advertising or publicity 
pertaining to the use or distribution of this software 
without specific, written prior authorization.  if the 
above copyright notice or any other identification of the 
university of michigan is included in any copy of any 
portion of this software, then the disclaimer below must 
also be included.

this software is provided as is, without representation 
from the university of michigan as to its fitness for any 
purpose, and without warranty by the university of 
michigan of any kind, either express or implied, including 
without limitation the implied warranties of 
merchantability and fitness for a particular purpose. the 
regents of the university of michigan shall not be liable 
for any damages, including special, indirect, incidental, or 
consequential damages, with respect to any claim arising 
out of or in connection with the use of the software, even 
if it has been or is hereafter advised of the possibility of 
such damages.
*/

/*
 * Return text for a given pair of sw1/sw2 status bytes
 */

#ifdef __palmos__
#include <Common.h>
#include <System/SysAll.h>
#include <System/Unix/sys_types.h>
#include <System/Unix/unix_stdlib.h>
#include <System/Unix/unix_string.h>
#include <UI/UIAll.h>
#include "field.h"
#else
#include <stdio.h>
#endif

#include "sectok.h"

static char *scsws(int sw);

static struct r1r2s {
    int sw;
    char *s;
} r1r2s[] = {
    {0x9000, "ok"},

    /* sectok errors */
    {0x0601, "no such tty"},
    {0x0602, "out of memory"},
    {0x0603, "timeout"},
    {0x0604, "slag!"},
    {0x0605, "card type not supported"},
    {0x0606, "no card in reader"},
    {0x0607, "not implemented"},
    {0x0608, "error loading driver"},
    {0x0609, "communications error"},
    {0x060a, "reader not open"},
    {0x060c, "config conflict"},
    {0x060d, "unknown error"},

    /* card errors */
    {0x61ff, "ok; response available %x"},
    {0x6234, "no such method"},
    {0x6239, "out of memory"},
    {0x6255, "null pointer"},
    {0x6257, "array index out of bounds"},
    {0x6258, "index out of bounds"},
    {0x6281, "rec is corrupt"},
    {0x6283, "invalid file"},
    {0x6300, "auth failed"},
    {0x6381, "invalid key"},
    {0x67ff, "invalid length; should be %x"},
    {0x6980, "bad param"},
    {0x6982, "permission denied"},
    {0x6983, "auth method blocked"},
    {0x6984, "data invalid"},
    {0x6985, "no file selected"},
    {0x6987, "busy/SM missing"},
    {0x6988, "SM wrong"},
    {0x6a80, "invalid file type"},
    {0x6a81, "function not supported"},
    {0x6a82, "file not found"},
    {0x6a83, "no such rec"},
    {0x6b00, "wrong mode"},
    {0x6cff, "wrong length; should be %x"},
    {0x6d00, "unknown instruction"},
    {0x6e00, "wrong class"},
    {0x6f14, "invalid applet state"},
    {0x6f15, "invalid state"},
    {0x6f19, "applet already running"},
    {0x6fb0, "uninitialized key"},
    {0x9481, "bad state"},
    {0x0000, NULL}
};

#ifdef TEST
main(int ac, char *av[])
{
    int sw;
    char *s;

    if (ac != 2) {
	fprintf(stderr, "usage: %s sw (in hex, please)\n", av[0]);
	exit(1);
    }
    sscanf(av[1], "%x", &sw);
    sectok_print_sw(sw);
    exit(0);
}
#endif

void sectok_print_sw(int sw)
{
    printf("%s\n", sectok_get_sw(sw));
}

char *sectok_get_sw(int sw)
{
    char *s;
    static char buf[64];

    s = scsws(sw);
    if (s)
	snprintf(buf, sizeof buf, "%04x %s", sw, s);
    else
	snprintf(buf, sizeof buf, "%04x", sw);
    return buf;
}

static char *scsws(int sw)
{
    int i, r1 = sectok_r1(sw), r2 = sectok_r2(sw), tr1, tr2;
    static char buf[64];

    for (i = 0; r1r2s[i].s; i++) {
	tr1 = sectok_r1(r1r2s[i].sw);
	tr2 = sectok_r2(r1r2s[i].sw);
	if (tr1 == r1 && (tr2 == r2 || tr2 == 0xff))
	    break;
    }

    if (sectok_r2(r1r2s[i].sw) != 0xff)
	return r1r2s[i].s;
    snprintf(buf, sizeof buf, r1r2s[i].s, r2);
    return buf;
}

#ifndef __palmos__
int
sectok_fdump_reply(FILE *f, unsigned char *p, int n, int sw)
{
    int i;

    for (i = 0; i < n; i++)
	fprintf(f, "%d:%x ", i + 1, p[i]);
    if (n)
	fprintf(f, "\n");
    if (sw)
	fprintf(f, "%s\n", sectok_get_sw(sw));
    return n;
}

int
sectok_dump_reply(unsigned char *p, int n, int sw)
{
    return sectok_fdump_reply(stdout, p, n, sw);
}
#else
int
sectok_dump_reply(unsigned char *p, int n, int sw)
{
    int i;

    hidefield(printfield->id);
    for (i = 0; i < n; i++)
	palmprintf("%d:%x ", i + 1, p[i]);
    if (n)
	palmprintf("\n");
    if (sw)
	palmprintf("%s\n", sectok_get_sw(sw));
    showfield(printfield->id);
    return n;
}
#endif
@


1.9
log
@the obvious simple snprintf changes
@
text
@d1 1
a1 1
/* $Id: r1r2.c,v 1.8 2001/08/02 17:02:05 rees Exp $ */
@


1.8
log
@stdio.h is evil on PalmOS
@
text
@d1 1
a1 1
/* $Id: r1r2.c,v 1.4 2001/08/02 16:41:32 rees Exp $ */
d136 1
a136 1
	sprintf(buf, "%04x %s", sw, s);
d138 1
a138 1
	sprintf(buf, "%04x", sw);
d156 1
a156 1
    sprintf(buf, r1r2s[i].s, r2);
@


1.7
log
@add Palm version of sectok_dump_reply()
@
text
@d1 1
a1 1
/* $Id: r1r2.c,v 1.3 2001/08/01 21:51:52 rees Exp $ */
d45 2
a47 1
#include <stdio.h>
@


1.6
log
@PalmOS mods
@
text
@d1 1
a1 1
/* $Id: r1r2.c,v 1.2 2001/07/30 20:02:08 rees Exp $ */
d178 16
@


1.5
log
@0x6982 "unreadable" -> "permission denied"
@
text
@d1 1
a1 1
/* $Id: r1r2.c,v 1.4 2001/07/02 20:07:08 rees Exp $ */
d38 8
a45 3
#define NULL 0
#define printf palmprintf
#else
a46 1
#endif
@


1.4
log
@separate sectok from sc7816 and give each its own include file
change status word to a single word instead of two bytes
add sc7816 layer for backward compatibility
other minor changes
@
text
@d1 1
a1 1
/* $Id: r1r2.c,v 1.3 2001/06/08 15:04:03 rees Exp $ */
d81 1
a81 1
    {0x6982, "unreadable"},
@


1.3
log
@Move copyright notice to top of file
@
text
@d1 1
a1 1
/* $Id: r1r2.c,v 1.5 2001/06/08 14:51:12 rees Exp $ */
d46 4
a49 2
struct r1r2s {
    int r1, r2;
d52 49
a100 33
    {0x90, 0x00, "ok"},
    {0x61, 0xff, "ok; response available %x"},
    {0x62, 0x34, "no such method"},
    {0x62, 0x39, "out of memory"},
    {0x62, 0x55, "null pointer"},
    {0x62, 0x57, "array index out of bounds"},
    {0x62, 0x58, "index out of bounds"},
    {0x62, 0x81, "rec is corrupt"},
    {0x62, 0x83, "invalid file"},
    {0x63, 0x00, "auth failed"},
    {0x63, 0x81, "invalid key"},
    {0x67, 0xff, "invalid length; should be %x"},
    {0x69, 0x80, "bad param"},
    {0x69, 0x82, "unreadable"},
    {0x69, 0x83, "auth method blocked"},
    {0x69, 0x84, "data invalid"},
    {0x69, 0x85, "no file selected"},
    {0x69, 0x87, "busy/SM missing"},
    {0x69, 0x88, "SM wrong"},
    {0x6a, 0x80, "invalid file type"},
    {0x6a, 0x81, "function not supported"},
    {0x6a, 0x82, "file not found"},
    {0x6a, 0x83, "no such rec"},
    {0x6b, 0x00, "wrong mode"},
    {0x6c, 0xff, "wrong length; should be %x"},
    {0x6d, 0x00, "unknown instruction"},
    {0x6e, 0x00, "wrong class"},
    {0x6f, 0x14, "invalid applet state"},
    {0x6f, 0x15, "invalid state"},
    {0x6f, 0x19, "applet already running"},
    {0x6f, 0xb0, "uninitialized key"},
    {0x94, 0x81, "bad state"},
    {0x00, 0x00, NULL}
d106 1
a106 1
    int r1, r2;
d109 2
a110 2
    if (ac != 3) {
	fprintf(stderr, "usage: %s sw1 sw2 (in hex, please)\n", av[0]);
d113 2
a114 3
    sscanf(av[1], "%x", &r1);
    sscanf(av[2], "%x", &r2);
    print_r1r2(r1, r2);
d119 1
a119 2
void
print_r1r2(int r1, int r2)
d121 1
a121 1
    printf("%s\n", get_r1r2s(r1, r2));
d124 1
a124 2
char *
get_r1r2s(int r1, int r2)
d129 1
a129 1
    s = scr1r2s(r1, r2);
d131 1
a131 1
	sprintf(buf, "%02x %02x %s", r1, r2, s);
d133 1
a133 1
	sprintf(buf, "%02x %02x", r1, r2);
d137 1
a137 2
char *
scr1r2s(int r1, int r2)
d139 1
a139 1
    int i;
d142 4
a145 2
    for (i = 0; r1r2s[i].s; i++)
	if (r1r2s[i].r1 == r1 && (r1r2s[i].r2 == r2 || r1r2s[i].r2 == 0xff))
d147 3
a149 1
    if (r1r2s[i].r2 != 0xff)
d157 1
a157 1
fdump_reply(FILE *f, unsigned char *p, int n, int r1, int r2)
d165 2
a166 2
    if (r1)
	fprintf(f, "%s\n", get_r1r2s(r1, r2));
d171 1
a171 1
dump_reply(unsigned char *p, int n, int r1, int r2)
d173 1
a173 1
    return fdump_reply(stdout, p, n, r1, r2);
@


1.2
log
@fix compiler warnings
@
text
@d1 32
a34 2
 *
 * See copyright notice at end of file
a35 1
static char *rcsid = "$Id: r1r2.c,v 1.4 2001/06/07 16:09:21 rees Exp $";
a157 30

/*
copyright 1999
the regents of the university of michigan
all rights reserved

permission is granted to use, copy, create derivative works 
and redistribute this software and such derivative works 
for any purpose, so long as the name of the university of 
michigan is not used in any advertising or publicity 
pertaining to the use or distribution of this software 
without specific, written prior authorization.  if the 
above copyright notice or any other identification of the 
university of michigan is included in any copy of any 
portion of this software, then the disclaimer below must 
also be included.

this software is provided as is, without representation 
from the university of michigan as to its fitness for any 
purpose, and without warranty by the university of 
michigan of any kind, either express or implied, including 
without limitation the implied warranties of 
merchantability and fitness for a particular purpose. the 
regents of the university of michigan shall not be liable 
for any damages, including special, indirect, incidental, or 
consequential damages, with respect to any claim arising 
out of or in connection with the use of the software, even 
if it has been or is hereafter advised of the possibility of 
such damages.
*/
@


1.1
log
@libsectok for secure tokens (smartcard, iButton, etc)
@
text
@d6 1
a6 1
static char *rcsid = "$Id: r1r2.c,v 1.1 2001/05/22 15:35:58 rees Exp $";
a96 1
    char *s;
d126 1
a126 1
    fdump_reply(stdout, p, n, r1, r2);
@

