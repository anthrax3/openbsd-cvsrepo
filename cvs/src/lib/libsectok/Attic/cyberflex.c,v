head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.38
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.34
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.36
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.32
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.30
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.28
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.26
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.24
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.22
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.20
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.18
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.16
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.14
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.12
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.10
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.8
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.6
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10;
locks; strict;
comment	@ * @;


1.11
date	2010.10.17.08.45.17;	author djm;	state dead;
branches;
next	1.10;

1.10
date	2001.08.02.17.02.05;	author rees;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.30.20.05.39;	author rees;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.26.22.15.04;	author rees;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.02.20.07.07;	author rees;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.28.21.27.54;	author rees;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.27.22.33.35;	author rees;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.26.23.25.11;	author rees;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.26.21.32.47;	author rees;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.25.23.14.29;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.25.19.59.37;	author rees;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove libsectok; it hasn't been updated in years and doesn't work
with the current generation of tokens; ok markus@@ deraadt@@
@
text
@/* $Id: cyberflex.c,v 1.10 2001/08/02 17:02:05 rees Exp $ */

/*
copyright 2000
the regents of the university of michigan
all rights reserved

permission is granted to use, copy, create derivative works
and redistribute this software and such derivative works
for any purpose, so long as the name of the university of
michigan is not used in any advertising or publicity
pertaining to the use or distribution of this software
without specific, written prior authorization.  if the
above copyright notice or any other identification of the
university of michigan is included in any copy of any
portion of this software, then the disclaimer below must
also be included.

this software is provided as is, without representation
from the university of michigan as to its fitness for any
purpose, and without warranty by the university of
michigan of any kind, either express or implied, including
without limitation the implied warranties of
merchantability and fitness for a particular purpose. the
regents of the university of michigan shall not be liable
for any damages, including special, indirect, incidental, or
consequential damages, with respect to any claim arising
out of or in connection with the use of the software, even
if it has been or is hereafter advised of the possibility of
such damages.
*/

/*
 * Cyberflex routines
 *
 * University of Michigan CITI, July 2001
 */

#ifdef __palmos__
#include <Common.h>
#include <System/SysAll.h>
#include <System/Unix/unix_stdlib.h>
#include <System/Unix/unix_string.h>
#include <UI/UIAll.h>
#include "field.h"
#else
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#endif

#include "sectok.h"

#define MAX_APDU_SIZE 0xfa
#define MAX_KEY_FILE_SIZE 1024
#define PRV_KEY_SIZE 64*6
#define key_number 0x10
#define key_type 0xc8 /* key type 0xc8 (1024 bit RSA private) */
#define KEY_FILE_HEADER_SIZE 8
#define BLOCK_SIZE 8

int
cyberflex_create_file_acl(int fd, int cla, unsigned char *fid, int size, int ftype, unsigned char *acl, int *swp)
{
    unsigned char data[16];

    size += 16;

    data[0] = (size >> 8);
    data[1] = (size & 0xff);
    data[2] = fid[0];
    data[3] = fid[1];
    data[4] = ftype;
    data[5] = 0x01;		/* status = 1 */
    data[6] = data[7] = 0x00;	/* record related */
    memcpy(&data[8], acl, 8);

    sectok_apdu(fd, cla, 0xe0, 0, 0, 0x10, data, 0, NULL, swp);
    if (!sectok_swOK(*swp))
	return -1;

    return sectok_selectfile(fd, cla, fid, swp);
}

/* Create a file with default acl "world: r w x/a inval rehab dec inc" */

int
cyberflex_create_file(int fd, int cla, unsigned char *fid, int size, int ftype, int *swp)
{
    static unsigned char acl[] = {0xff, 0, 0, 0, 0, 0, 0, 0};

    return cyberflex_create_file_acl(fd, cla, fid, size, ftype, acl, swp);
}

int
cyberflex_delete_file(int fd, int cla, unsigned char *fid, int *swp)
{
    sectok_apdu(fd, cla, 0xe4, 0, 0, 0x02, fid, 0, NULL, swp);
    if (!sectok_swOK(*swp))
	return -1;

    return 0;
}

int
cyberflex_load_rsa_pub(int fd, int cla, unsigned char *key_fid,
		       int key_len, unsigned char *key_data, int *swp)
{
    static unsigned char acl[] = {0x1, 0, 0, 0xb, 0, 0, 0, 0};

    if (sectok_selectfile(fd, cla, root_fid, swp) < 0)
	return -1;

    if (sectok_selectfile(fd, cla, key_fid, swp) < 0 && *swp == STENOFILE) {
	if (cyberflex_create_file_acl(fd, cla, key_fid, key_len, 3, acl, swp) < 0)
	    return -1;
    }

    /* Write the key data */
    sectok_apdu(fd, cla, 0xd6, 0, 0, key_len, key_data, 0, NULL, swp);
    if (!sectok_swOK(*swp))
	return -1;

    return 0;
}

/* download RSA private key into 3f.00/00.12 */
int
cyberflex_load_rsa_priv(int fd, int cla, unsigned char *key_fid,
			int nkey_elems, int key_len, unsigned char *key_elems[],
			int *swp)
{
    int i, j, offset = 0, size;
    unsigned char data[MAX_KEY_FILE_SIZE];
    static unsigned char acl[] = {0, 0, 0, 0xa, 0, 0, 0, 0}; /* AUT0: w inval */
    static unsigned char key_file_header[KEY_FILE_HEADER_SIZE] =
    {0xC2, 0x06, 0xC1, 0x08, 0x13, 0x00, 0x00, 0x05};
    static unsigned char key_header[3] = {0xC2, 0x41, 0x00};

    /* select 3f.00 */
    if (sectok_selectfile(fd, cla, root_fid, swp) < 0)
	return -1;

    /* select 00.12 */
    if (sectok_selectfile(fd, cla, key_fid, swp) < 0 && *swp == STENOFILE) {
	/* rv != 0, 00.12 does not exist.  create it. */
	if (cyberflex_create_file_acl(fd, cla, key_fid, PRV_KEY_SIZE, 3, acl, swp) < 0)
	    return -1;
    }

    /* burn the key */
    data[0] = 0x01;		/* key size, I guess */
    data[1] = 0x5b;		/* key size, I guess */
    data[2] = key_number;	/* key number */
    data[3] = key_type;
    offset = 4;
    for (j = 0 ; j < KEY_FILE_HEADER_SIZE ; j ++)
	data[offset++] = key_file_header[j];
    for (i = 0 ; i < nkey_elems; i ++) {
	/* put the key header */
	for (j = 0 ; j < 3 ; j ++) {
	    data[offset++] = key_header[j];
	}
	for (j = 0 ; j < key_len/2/8 ; j ++) {
	    data[offset++] = key_elems [i][j];
	}
    }
    for (j = 0 ; j < 2 ; j ++) data[offset++] = 0;

#ifdef DEBUG
    printf ("data:\n");
    for (i = 0 ; i < 0x015d; i ++) {
	printf ("%02x ", data[i]);
    }
    printf ("\n");
#endif

    /* now send this to the card */
    /* select private key file */
    if (sectok_selectfile(fd, cla, key_fid, swp) < 0)
	return -1;

    /* update binary */
    size = offset;

    for (i = 0; i < size; i += MAX_APDU_SIZE) {
	int send_size;

	/* compute the size to be sent */
	if (size - i > MAX_APDU_SIZE) send_size = MAX_APDU_SIZE;
	else send_size = size - i;

	sectok_apdu(fd, cla, 0xd6, i >> 8, i & 0xff, send_size, data + i, 0, NULL, swp);

	if (!sectok_swOK(*swp))
	    return -1;
    }

    return 0;
}

int
cyberflex_verify_AUT0(int fd, int cla, unsigned char *aut0, int aut0len)
{
    int sw;

    sectok_apdu(fd, cla, 0x2a, 0, 0, aut0len, aut0, 0, NULL, &sw);
    if (!sectok_swOK(sw))
	return -1;

    return 0;
}

/* fill the key block.

   Input
   dst     : destination buffer
   key_num : key number (0: AUT, 5: signed applet, etc.)
   alg_num : algorithm number
   key     : incoming 8 byte DES key

   The resulting format:
   00 0e key_num alg_num key(8 byte) 0a 0a

   total 14 byte
*/
void
cyberflex_fill_key_block (unsigned char *dst, int key_num,
			       int alg_num, unsigned char *key)
{
    int i;

    *(dst+0) = 0x00;		/* const */
    *(dst+1) = 0x0e;		/* const */
    *(dst+2) = key_num;		/* key number */
    *(dst+3) = alg_num;		/* algorithm number */
    for (i = 0; i < BLOCK_SIZE; i++)
	*(dst+i+4) = *(key+i);
    *(dst+12) = 0x0a;		/* const */
    *(dst+13) = 0x0a;		/* const */

    return;
}

int
cyberflex_inq_class(int fd)
{
    unsigned char buf[32];
    int n, sw;

    n = sectok_apdu(fd, 0x00, 0xca, 0, 1, 0, NULL, 0x16, buf, &sw);
    if (sectok_swOK(sw))
	return 0x00;

    if (n >= 0 && sectok_r1(sw) == 0x6d) {
        /* F0 card? */
        sectok_apdu(fd, 0xf0, 0xca, 0, 1, 0, NULL, 0x16, buf, &sw);
        if (sectok_swOK(sw))
	    return 0xf0;
    }

    return -1;
}
@


1.10
log
@stdio.h is evil on PalmOS
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.3 2001/08/02 16:41:32 rees Exp $ */
@


1.9
log
@PalmOS mods
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.2 2001/07/30 20:02:08 rees Exp $ */
a48 1
#endif
d51 1
@


1.8
log
@sectok_fmt_fid now takes a proper fid
add cyberflex_create_file_acl
put proper acls on public and private rsa key files
bump major version
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.7 2001/07/02 20:07:07 rees Exp $ */
d39 8
d49 1
a51 5
#ifdef __linux
#include <openssl/des.h>
#else /* __linux */
#include <des.h>
#endif
d77 1
a77 1
    memmove(&data[8], acl, 8);
@


1.7
log
@separate sectok from sc7816 and give each its own include file
change status word to a single word instead of two bytes
add sc7816 layer for backward compatibility
other minor changes
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.5 2001/06/27 22:33:35 rees Exp $ */
d60 1
a60 1
cyberflex_create_file(int fd, int cla, unsigned char *fid, int size, int ftype, int *swp)
a61 1
    int i;
d73 1
a73 3
    data[8] = 0xff;		/* ACL can do everything with AUT0 */
    for (i = 9; i < 16; i++ )
	data[i] = 0x00;		/* ACL : cannot do anything without AUT0 */
d82 10
d106 2
d112 1
a112 1
	if (cyberflex_create_file(fd, cla, key_fid, key_len, 3, swp) < 0)
d132 1
d144 1
a144 1
	if (cyberflex_create_file(fd, cla, key_fid, PRV_KEY_SIZE, 3, swp) < 0)
@


1.6
log
@remove printfs and add return codes
@
text
@d59 2
a60 2
int cyberflex_create_file(int fd, int cla, unsigned char *fid, int size, int ftype,
			  int *r1p, int *r2p)
d62 1
a62 1
    int i, n;
d78 2
a79 2
    n = scwrite(fd, cla, 0xe0, 0, 0, 0x10, data, r1p, r2p);
    if (n < 0 || (*r1p != 0x90 && *r1p != 0x61))
d82 1
a82 1
    return sectok_selectfile(fd, cla, fid, r1p, r2p);
d86 1
a86 1
cyberflex_delete_file(int fd, int cla, int f0, int f1, int *r1p, int *r2p)
d88 3
a90 2
    int n;
    unsigned char buf[2];
a91 8
    buf[0] = f0;
    buf[1] = f1;

    n = scwrite(fd, cla, 0xe4, 0, 0, 0x02, buf, r1p, r2p);
    if (n < 0 || (*r1p != 0x90 && *r1p != 0x61)) {
	/* error */
	return -1;
    }
d97 1
a97 1
		       int key_len, unsigned char *key_data, int *r1p, int *r2p)
d99 1
a99 3
    int rv;

    if (sectok_selectfile(fd, cla, root_fid, r1p, r2p) < 0)
d102 2
a103 2
    if (sectok_selectfile(fd, cla, key_fid, r1p, r2p)) {
	if (cyberflex_create_file(fd, cla, key_fid, key_len, 3, r1p, r2p) < 0)
d108 2
a109 2
    rv = scwrite(fd, cla, 0xd6, 0, 0, key_len, key_data, r1p, r2p);
    if (rv < 0 || (*r1p != 0x90 && *r1p != 0x61))
d112 1
a112 1
    return rv;
d119 1
a119 1
			int *r1p, int *r2p)
d121 1
a121 1
    int i, j, rv, offset = 0, size;
d128 2
a129 2
    rv = sectok_selectfile(fd, cla, root_fid, r1p, r2p);
    if (rv < 0) return rv;
d132 1
a132 2
    rv = sectok_selectfile(fd, cla, key_fid, r1p, r2p);
    if (rv < 0) {
d134 1
a134 2
	printf ("private key file does not exist.  create it.\n");
	if (cyberflex_create_file(fd, cla, key_fid, PRV_KEY_SIZE, 3, r1p, r2p) < 0)
d167 1
a167 1
    if (sectok_selectfile(fd, cla, key_fid, r1p, r2p) < 0)
d180 1
a180 6
	rv = scwrite(fd, cla, 0xd6,
		     i / 256,	/* offset, upper byte */
		     i % 256,	/* offset, lower byte */
		     send_size,
		     data + i,	/* key file */
		     r1p, r2p);
d182 1
a182 1
	if (*r1p != 0x90 && *r1p != 0x61)
a185 1
    printf ("rsa key loading done! :)\n");
d192 1
a192 1
    int n, r1, r2;
d194 2
a195 4
    n = scwrite(fd, cla, 0x2a, 0, 0, aut0len, aut0, &r1, &r2);
    if (n < 0 || r1 != 0x90) {
	if (n >= 0)
	    print_r1r2(r1, r2);
d197 1
a197 1
    }
d236 1
a236 1
    int n, r1, r2;
d238 2
a239 2
    n = scread(fd, 0x00, 0xca, 0, 1, 0x16, buf, &r1, &r2);
    if (n >= 0 && r1 == 0x90)
d242 1
a242 1
    if (n >= 0 && r1 == 0x6d) {
d244 2
a245 2
        n = scread(fd, 0xf0, 0xca, 0, 1, 0x16, buf, &r1, &r2);
        if (n >= 0 && r1 == 0x90)
@


1.5
log
@add cyberflex_fill_key_block, root_fid
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.4 2001/06/26 23:25:11 rees Exp $ */
d59 2
a60 1
int cyberflex_create_file(int fd, int cla, unsigned char *fid, int size)
d62 1
a62 1
    int i, n, r1, r2;
d71 1
a71 1
    data[4] = 0x02;		/* file type = 2 (binary file) */
d78 2
a79 2
    n = scwrite(fd, cla, 0xe0, 0, 0, 0x10, data, &r1, &r2);
    if (n < 0 || (r1 != 0x90 && r1 != 0x61))
d82 1
a82 3
    sectok_selectfile(fd, cla, fid, 0);

    return 0;
d86 1
a86 1
cyberflex_delete_file(int fd, int cla, int f0, int f1, int verbose)
d88 1
a88 1
    int n, r1, r2;
a89 1
    char fname[5];
d94 2
a95 4
    n = scwrite(fd, cla, 0xe4, 0, 0, 0x02, buf, &r1, &r2);
    if (n < 0)
	return -1;
    if (r1 != 0x90 && r1 != 0x61) {
a96 4
	if (verbose) {
	    sectok_fmt_fid(fname, f0, f1);
	    printf("delete_file %s: %s\n", fname, get_r1r2s(r1, r2));
	}
d104 1
a104 1
		       int key_len, unsigned char *key_data)
d106 1
a106 2
    int rv, r1, r2;
    char kfname[5];
d108 2
a109 3
    rv = sectok_selectfile(fd, cla, root_fid, 0);
    if (rv < 0)
	return rv;
d111 3
a113 5
    sectok_fmt_fid(kfname, key_fid[0], key_fid[1]);
    rv = sectok_selectfile(fd, cla, key_fid, 0);
    if (rv < 0) {
	printf ("public key file does not exist.  create it.\n");
	cyberflex_create_file(fd, cla, key_fid, key_len);
d117 2
a118 4
    rv = scwrite(fd, cla, 0xd6, 0, 0, key_len, key_data, &r1, &r2);
    if (r1 != 0x90 && r1 != 0x61) {
	/* error */
	printf("creating file %s: %s\n", kfname, get_r1r2s(r1, r2));
d120 1
a120 1
    }
d127 2
a128 1
			int nkey_elems, int key_len, unsigned char *key_elems[])
d130 1
a130 1
    int i, j, rv, r1, r2, offset=0, size;
a134 1
    char kfname[5];
d137 1
a137 1
    rv = sectok_selectfile(fd, cla, root_fid, 0);
d141 1
a141 2
    sectok_fmt_fid(kfname, key_fid[0], key_fid[1]);
    rv = sectok_selectfile(fd, cla, key_fid, 0);
d145 1
a145 18

	/* create private key file */
	data[0] = (PRV_KEY_SIZE + 16) / 256; /* size, upper byte */
	data[1] = (PRV_KEY_SIZE + 16) % 256; /* size, lower byte */
	data[2] = key_fid[0];
	data[3] = key_fid[1];
	data[4] = 0x03;		/* file type */
	data[5] = 0x01;		/* status = 1 */
	data[6] = data[7] = 0x00; /* record related */
	data[8] = 0xff;		/* ACL can do everything with AUT0 */
	for (i = 9; i < 16; i++ ) {
	    data[i] = 0x00;	/* ACL : cannot do anything without AUT0 */
	}

	rv = scwrite(fd, cla, 0xe0, 0, 0, 0x10, data, &r1, &r2);
	if (r1 != 0x90 && r1 != 0x61) {
	    /* error */
	    printf("creating file %s: %s\n", kfname, get_r1r2s(r1, r2));
a146 1
	}
d178 2
a179 2
    rv = sectok_selectfile(fd, cla, key_fid, 0);
    if (rv < 0) return rv;
d196 1
a196 1
		     &r1, &r2);
d198 1
a198 3
	if (r1 != 0x90 && r1 != 0x61) {
	    /* error */
	    printf("updating binary %s: %s\n", kfname, get_r1r2s(r1, r2));
a199 1
	}
@


1.4
log
@add sectok_parse_fname()
add cyberflex_create_file()
add cyberflex_delete_file()
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.3 2001/06/26 21:32:47 rees Exp $ */
d57 1
a57 2

static unsigned char root_fid[] = {0x3f, 0x00};
d66 1
a66 1
    data[0] = (size >> 16);
d254 31
@


1.3
log
@add cyberflex_inq_class()
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.2 2001/06/25 23:14:29 markus Exp $ */
d60 51
d115 1
a115 2
    int rv, i, r1, r2;
    unsigned char data[16];
d126 1
a126 19
	data[0] = 0x01;
	data[1] = 0x00;
	data[2] = key_fid[0];
	data[3] = key_fid[1];
	data[4] = 0x02;		/* file type = 2 (binary file) */
	data[5] = 0x01;		/* status = 1 */
	data[6] = data[7] = 0x00; /* record related */
	data[8] = 0xff;		/* ACL can do everything with AUT0 */
	for (i = 9; i < 16; i++ ) {
	    data[i] = 0x00;	/* ACL : cannot do anything without AUT0 */
	}

	rv = scwrite(fd, cla, 0xe0, 0, 0, 0x10, data, &r1, &r2);
	if (r1 != 0x90 && r1 != 0x61) {
	    /* error */
	    printf("creating file %s: %s\n", kfname, get_r1r2s(r1, r2));
	    return -1;
	}
	rv = sectok_selectfile(fd, cla, key_fid, 0);
@


1.2
log
@add cyberflex_verify_AUT0()
@
text
@d1 1
a1 1
/* $Id: cyberflex.c,v 1.1 2001/06/25 19:59:37 rees Exp $ */
d217 19
a235 1
    if (n >= 0 && cla == 0 && r1 == 0x6d) {
d237 3
a239 10
        n = scwrite(fd, 0xf0, 0x2a, 0, 0, aut0len, aut0, &r1, &r2);
        if (r1 == 0x90) {
            printf("class F0\n");
            cla = 0xf0;
        }
    }
    printf("Verify key: ");
    if (n < 0) {
        printf("scwrite failed\n");
        return -1;
d241 2
a242 2
    dump_reply(NULL, 0, r1, r2);
    return 0;
@


1.1
log
@add key Cyberflex key loading functions
@
text
@d1 1
a1 1
/* $Id: $ */
d208 23
@

