head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.32
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.28
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.24
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.26
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.18
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.38
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.34
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.32
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.30
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.28
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.26
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.24
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.22
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.20
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.18
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.16
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.14
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.12
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	ncurses:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.22.18.02.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.05.17.03.04.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.01.22.03.45.06;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.07.24.16.38.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.31.17;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.03.58.45;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.21.34.41;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.02.21.34.41;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2005,2008 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *   Author:  Juergen Pfeifer, 1995,1997                                    *
 ****************************************************************************/

/***************************************************************************
* Module m_driver                                                          *
* Central dispatching routine                                              *
***************************************************************************/

#include "menu.priv.h"

MODULE_ID("$Id: m_driver.c,v 1.27 2008/08/03 22:08:22 tom Exp $")

/* Macros */

/* Remove the last character from the match pattern buffer */
#define Remove_Character_From_Pattern(menu) \
  (menu)->pattern[--((menu)->pindex)] = '\0'

/* Add a new character to the match pattern buffer */
#define Add_Character_To_Pattern(menu,ch) \
  { (menu)->pattern[((menu)->pindex)++] = (ch);\
    (menu)->pattern[(menu)->pindex] = '\0'; }

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu
|   Function      :  static bool Is_Sub_String(
|                           bool IgnoreCaseFlag,
|                           const char *part,
|                           const char *string)
|
|   Description   :  Checks whether or not part is a substring of string.
|
|   Return Values :  TRUE   - if it is a substring
|                    FALSE  - if it is not a substring
+--------------------------------------------------------------------------*/
static bool
Is_Sub_String(
	       bool IgnoreCaseFlag,
	       const char *part,
	       const char *string
)
{
  assert(part && string);
  if (IgnoreCaseFlag)
    {
      while (*string && *part)
	{
	  if (toupper(UChar(*string++)) != toupper(UChar(*part)))
	    break;
	  part++;
	}
    }
  else
    {
      while (*string && *part)
	if (*part != *string++)
	  break;
      part++;
    }
  return ((*part) ? FALSE : TRUE);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu
|   Function      :  int _nc_Match_Next_Character_In_Item_Name(
|                           MENU *menu,
|                           int  ch,
|                           ITEM **item)
|
|   Description   :  This internal routine is called for a menu positioned
|                    at an item with three different classes of characters:
|                       - a printable character; the character is added to
|                         the current pattern and the next item matching
|                         this pattern is searched.
|                       - NUL; the pattern stays as it is and the next item
|                         matching the pattern is searched
|                       - BS; the pattern stays as it is and the previous
|                         item matching the pattern is searched
|
|                       The item parameter contains on call a pointer to
|                       the item where the search starts. On return - if
|                       a match was found - it contains a pointer to the
|                       matching item.
|
|   Return Values :  E_OK        - an item matching the pattern was found
|                    E_NO_MATCH  - nothing found
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
_nc_Match_Next_Character_In_Item_Name
(MENU * menu, int ch, ITEM ** item)
{
  bool found = FALSE, passed = FALSE;
  int idx, last;

  T((T_CALLED("_nc_Match_Next_Character(%p,%d,%p)"), menu, ch, item));

  assert(menu && item && *item);
  idx = (*item)->index;

  if (ch && ch != BS)
    {
      /* if we become to long, we need no further checking : there can't be
         a match ! */
      if ((menu->pindex + 1) > menu->namelen)
	RETURN(E_NO_MATCH);

      Add_Character_To_Pattern(menu, ch);
      /* we artificially position one item back, because in the do...while
         loop we start with the next item. This means, that with a new
         pattern search we always start the scan with the actual item. If
         we do a NEXT_PATTERN oder PREV_PATTERN search, we start with the
         one after or before the actual item. */
      if (--idx < 0)
	idx = menu->nitems - 1;
    }

  last = idx;			/* this closes the cycle */

  do
    {
      if (ch == BS)
	{			/* we have to go backward */
	  if (--idx < 0)
	    idx = menu->nitems - 1;
	}
      else
	{			/* otherwise we always go forward */
	  if (++idx >= menu->nitems)
	    idx = 0;
	}
      if (Is_Sub_String((bool)((menu->opt & O_IGNORECASE) != 0),
			menu->pattern,
			menu->items[idx]->name.str)
	)
	found = TRUE;
      else
	passed = TRUE;
    }
  while (!found && (idx != last));

  if (found)
    {
      if (!((idx == (*item)->index) && passed))
	{
	  *item = menu->items[idx];
	  RETURN(E_OK);
	}
      /* This point is reached, if we fully cycled through the item list
         and the only match we found is the starting item. With a NEXT_PATTERN
         or PREV_PATTERN scan this means, that there was no additional match.
         If we searched with an expanded new pattern, we should never reach
         this point, because if the expanded pattern matches also the actual
         item we will find it in the first attempt (passed==FALSE) and we
         will never cycle through the whole item array.
       */
      assert(ch == 0 || ch == BS);
    }
  else
    {
      if (ch && ch != BS && menu->pindex > 0)
	{
	  /* if we had no match with a new pattern, we have to restore it */
	  Remove_Character_From_Pattern(menu);
	}
    }
  RETURN(E_NO_MATCH);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu
|   Function      :  int menu_driver(MENU *menu, int c)
|
|   Description   :  Central dispatcher for the menu. Translates the logical
|                    request 'c' into a menu action.
|
|   Return Values :  E_OK            - success
|                    E_BAD_ARGUMENT  - invalid menu pointer
|                    E_BAD_STATE     - menu is in user hook routine
|                    E_NOT_POSTED    - menu is not posted
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
menu_driver(MENU * menu, int c)
{
#define NAVIGATE(dir) \
  if (!item->dir)\
     result = E_REQUEST_DENIED;\
  else\
     item = item->dir

  int result = E_OK;
  ITEM *item;
  int my_top_row, rdiff;

  T((T_CALLED("menu_driver(%p,%d)"), menu, c));

  if (!menu)
    RETURN(E_BAD_ARGUMENT);

  if (menu->status & _IN_DRIVER)
    RETURN(E_BAD_STATE);
  if (!(menu->status & _POSTED))
    RETURN(E_NOT_POSTED);

  item = menu->curitem;

  my_top_row = menu->toprow;
  assert(item);

  if ((c > KEY_MAX) && (c <= MAX_MENU_COMMAND))
    {
      if (!((c == REQ_BACK_PATTERN)
	    || (c == REQ_NEXT_MATCH) || (c == REQ_PREV_MATCH)))
	{
	  assert(menu->pattern);
	  Reset_Pattern(menu);
	}

      switch (c)
	{
	case REQ_LEFT_ITEM:
	    /*=================*/
	  NAVIGATE(left);
	  break;

	case REQ_RIGHT_ITEM:
	    /*==================*/
	  NAVIGATE(right);
	  break;

	case REQ_UP_ITEM:
	    /*===============*/
	  NAVIGATE(up);
	  break;

	case REQ_DOWN_ITEM:
	    /*=================*/
	  NAVIGATE(down);
	  break;

	case REQ_SCR_ULINE:
	    /*=================*/
	  if (my_top_row == 0 || !(item->up))
	    result = E_REQUEST_DENIED;
	  else
	    {
	      --my_top_row;
	      item = item->up;
	    }
	  break;

	case REQ_SCR_DLINE:
	    /*=================*/
	  if ((my_top_row + menu->arows >= menu->rows) || !(item->down))
	    {
	      /* only if the menu has less items than rows, we can deny the
	         request. Otherwise the epilogue of this routine adjusts the
	         top row if necessary */
	      result = E_REQUEST_DENIED;
	    }
	  else
	    {
	      my_top_row++;
	      item = item->down;
	    }
	  break;

	case REQ_SCR_DPAGE:
	    /*=================*/
	  rdiff = menu->rows - (menu->arows + my_top_row);
	  if (rdiff > menu->arows)
	    rdiff = menu->arows;
	  if (rdiff <= 0)
	    result = E_REQUEST_DENIED;
	  else
	    {
	      my_top_row += rdiff;
	      while (rdiff-- > 0 && item != 0 && item->down != 0)
		item = item->down;
	    }
	  break;

	case REQ_SCR_UPAGE:
	    /*=================*/
	  rdiff = (menu->arows < my_top_row) ? menu->arows : my_top_row;
	  if (rdiff <= 0)
	    result = E_REQUEST_DENIED;
	  else
	    {
	      my_top_row -= rdiff;
	      while (rdiff-- > 0 && item != 0 && item->up != 0)
		item = item->up;
	    }
	  break;

	case REQ_FIRST_ITEM:
	    /*==================*/
	  item = menu->items[0];
	  break;

	case REQ_LAST_ITEM:
	    /*=================*/
	  item = menu->items[menu->nitems - 1];
	  break;

	case REQ_NEXT_ITEM:
	    /*=================*/
	  if ((item->index + 1) >= menu->nitems)
	    {
	      if (menu->opt & O_NONCYCLIC)
		result = E_REQUEST_DENIED;
	      else
		item = menu->items[0];
	    }
	  else
	    item = menu->items[item->index + 1];
	  break;

	case REQ_PREV_ITEM:
	    /*=================*/
	  if (item->index <= 0)
	    {
	      if (menu->opt & O_NONCYCLIC)
		result = E_REQUEST_DENIED;
	      else
		item = menu->items[menu->nitems - 1];
	    }
	  else
	    item = menu->items[item->index - 1];
	  break;

	case REQ_TOGGLE_ITEM:
	    /*===================*/
	  if (menu->opt & O_ONEVALUE)
	    {
	      result = E_REQUEST_DENIED;
	    }
	  else
	    {
	      if (menu->curitem->opt & O_SELECTABLE)
		{
		  menu->curitem->value = !menu->curitem->value;
		  Move_And_Post_Item(menu, menu->curitem);
		  _nc_Show_Menu(menu);
		}
	      else
		result = E_NOT_SELECTABLE;
	    }
	  break;

	case REQ_CLEAR_PATTERN:
	    /*=====================*/
	  /* already cleared in prologue */
	  break;

	case REQ_BACK_PATTERN:
	    /*====================*/
	  if (menu->pindex > 0)
	    {
	      assert(menu->pattern);
	      Remove_Character_From_Pattern(menu);
	      pos_menu_cursor(menu);
	    }
	  else
	    result = E_REQUEST_DENIED;
	  break;

	case REQ_NEXT_MATCH:
	    /*==================*/
	  assert(menu->pattern);
	  if (menu->pattern[0])
	    result = _nc_Match_Next_Character_In_Item_Name(menu, 0, &item);
	  else
	    {
	      if ((item->index + 1) < menu->nitems)
		item = menu->items[item->index + 1];
	      else
		{
		  if (menu->opt & O_NONCYCLIC)
		    result = E_REQUEST_DENIED;
		  else
		    item = menu->items[0];
		}
	    }
	  break;

	case REQ_PREV_MATCH:
	    /*==================*/
	  assert(menu->pattern);
	  if (menu->pattern[0])
	    result = _nc_Match_Next_Character_In_Item_Name(menu, BS, &item);
	  else
	    {
	      if (item->index)
		item = menu->items[item->index - 1];
	      else
		{
		  if (menu->opt & O_NONCYCLIC)
		    result = E_REQUEST_DENIED;
		  else
		    item = menu->items[menu->nitems - 1];
		}
	    }
	  break;

	default:
	    /*======*/
	  result = E_UNKNOWN_COMMAND;
	  break;
	}
    }
  else
    {				/* not a command */
      if (!(c & ~((int)MAX_REGULAR_CHARACTER)) && isprint(UChar(c)))
	result = _nc_Match_Next_Character_In_Item_Name(menu, c, &item);
#ifdef NCURSES_MOUSE_VERSION
      else if (KEY_MOUSE == c)
	{
	  MEVENT event;
	  WINDOW *uwin = Get_Menu_UserWin(menu);

	  getmouse(&event);
	  if ((event.bstate & (BUTTON1_CLICKED |
			       BUTTON1_DOUBLE_CLICKED |
			       BUTTON1_TRIPLE_CLICKED))
	      && wenclose(uwin, event.y, event.x))
	    {			/* we react only if the click was in the userwin, that means
				 * inside the menu display area or at the decoration window.
				 */
	      WINDOW *sub = Get_Menu_Window(menu);
	      int ry = event.y, rx = event.x;	/* screen coordinates */

	      result = E_REQUEST_DENIED;
	      if (mouse_trafo(&ry, &rx, FALSE))
		{		/* rx, ry are now "curses" coordinates */
		  if (ry < sub->_begy)
		    {		/* we clicked above the display region; this is
				 * interpreted as "scroll up" request
				 */
		      if (event.bstate & BUTTON1_CLICKED)
			result = menu_driver(menu, REQ_SCR_ULINE);
		      else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
			result = menu_driver(menu, REQ_SCR_UPAGE);
		      else if (event.bstate & BUTTON1_TRIPLE_CLICKED)
			result = menu_driver(menu, REQ_FIRST_ITEM);
		      RETURN(result);
		    }
		  else if (ry > sub->_begy + sub->_maxy)
		    {		/* we clicked below the display region; this is
				 * interpreted as "scroll down" request
				 */
		      if (event.bstate & BUTTON1_CLICKED)
			result = menu_driver(menu, REQ_SCR_DLINE);
		      else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
			result = menu_driver(menu, REQ_SCR_DPAGE);
		      else if (event.bstate & BUTTON1_TRIPLE_CLICKED)
			result = menu_driver(menu, REQ_LAST_ITEM);
		      RETURN(result);
		    }
		  else if (wenclose(sub, event.y, event.x))
		    {		/* Inside the area we try to find the hit item */
		      int i, x, y, err;

		      ry = event.y;
		      rx = event.x;
		      if (wmouse_trafo(sub, &ry, &rx, FALSE))
			{
			  for (i = 0; i < menu->nitems; i++)
			    {
			      err = _nc_menu_cursor_pos(menu, menu->items[i],
							&y, &x);
			      if (E_OK == err)
				{
				  if ((ry == y) &&
				      (rx >= x) &&
				      (rx < x + menu->itemlen))
				    {
				      item = menu->items[i];
				      result = E_OK;
				      break;
				    }
				}
			    }
			  if (E_OK == result)
			    {	/* We found an item, now we can handle the click.
				 * A single click just positions the menu cursor
				 * to the clicked item. A double click toggles
				 * the item.
				 */
			      if (event.bstate & BUTTON1_DOUBLE_CLICKED)
				{
				  _nc_New_TopRow_and_CurrentItem(menu,
								 my_top_row,
								 item);
				  menu_driver(menu, REQ_TOGGLE_ITEM);
				  result = E_UNKNOWN_COMMAND;
				}
			    }
			}
		    }
		}
	    }
	  else
	    result = E_REQUEST_DENIED;
	}
#endif /* NCURSES_MOUSE_VERSION */
      else
	result = E_UNKNOWN_COMMAND;
    }

  if (E_OK == result)
    {
      /* Adjust the top row if it turns out that the current item unfortunately
         doesn't appear in the menu window */
      if (item->y < my_top_row)
	my_top_row = item->y;
      else if (item->y >= (my_top_row + menu->arows))
	my_top_row = item->y - menu->arows + 1;

      _nc_New_TopRow_and_CurrentItem(menu, my_top_row, item);

    }

  RETURN(result);
}

/* m_driver.c ends here */
@


1.7
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: m_driver.c,v 1.6 1999/05/17 03:04:20 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d32 1
a32 1
 *   Author: Juergen Pfeifer <juergen.pfeifer@@gmx.net> 1995,1997            *
d42 1
a42 1
MODULE_ID("$From: m_driver.c,v 1.18 2000/12/10 02:16:48 tom Exp $")
d67 6
a72 5
static bool Is_Sub_String(
			  bool  IgnoreCaseFlag,
			  const char *part,
			  const char *string
			 )
d74 2
a75 2
  assert( part && string );
  if ( IgnoreCaseFlag )
d77 1
a77 1
      while(*string && *part)
d79 2
a80 1
	  if (toupper(*string++)!=toupper(*part)) break;
d86 3
a88 2
      while( *string && *part )
	if (*part != *string++) break;
d91 1
a91 1
  return ( (*part) ? FALSE : TRUE );
d121 1
a121 1
(MENU *menu, int ch, ITEM **item)
d124 3
a126 1
  int  idx, last;
d128 1
a128 1
  assert( menu && item && *item);
d131 1
a131 1
  if (ch && ch!=BS)
d134 2
a135 2
	 a match ! */
      if ((menu->pindex+1) > menu->namelen)
d138 1
a138 1
      Add_Character_To_Pattern(menu,ch);
d140 4
a143 4
	 loop we start with the next item. This means, that with a new
	 pattern search we always start the scan with the actual item. If
	 we do a NEXT_PATTERN oder PREV_PATTERN search, we start with the
	 one after or before the actual item. */
d145 1
a145 1
	idx = menu->nitems-1;
d150 15
a164 14
  do{
    if (ch==BS)
      {			/* we have to go backward */
	if (--idx < 0)
	  idx = menu->nitems-1;
      }
    else
      {			/* otherwise we always go forward */
	if (++idx >= menu->nitems)
	  idx = 0;
      }
    if (Is_Sub_String((menu->opt & O_IGNORECASE) != 0,
		      menu->pattern,
		      menu->items[idx]->name.str)
d166 5
a170 4
      found = TRUE;
    else
      passed = TRUE;
  } while (!found && (idx != last));
d174 1
a174 1
      if (!((idx==(*item)->index) && passed))
d180 8
a187 8
	 and the only match we found is the starting item. With a NEXT_PATTERN
	 or PREV_PATTERN scan this means, that there was no additional match.
	 If we searched with an expanded new pattern, we should never reach
	 this point, because if the expanded pattern matches also the actual
	 item we will find it in the first attempt (passed==FALSE) and we
	 will never cycle through the whole item array.
	 */
      assert( ch==0 || ch==BS );
d191 1
a191 1
      if (ch && ch!=BS && menu->pindex>0)
d213 1
a213 1
menu_driver (MENU * menu, int   c)
d225 2
d230 1
a230 1
  if ( menu->status & _IN_DRIVER )
d232 1
a232 1
  if ( !( menu->status & _POSTED ) )
d237 2
a238 2
    my_top_row = menu->toprow;
    assert(item);
d240 12
a251 12
    if ((c > KEY_MAX) && (c<=MAX_MENU_COMMAND))
      {
	if (!((c==REQ_BACK_PATTERN)
	      || (c==REQ_NEXT_MATCH) || (c==REQ_PREV_MATCH)))
	  {
	    assert( menu->pattern );
	    Reset_Pattern(menu);
	  }

	switch(c)
	  {
	  case REQ_LEFT_ITEM:
d253 2
a254 2
	    NAVIGATE(left);
	    break;
d256 1
a256 1
	  case REQ_RIGHT_ITEM:
d258 2
a259 2
	    NAVIGATE(right);
	    break;
d261 1
a261 1
	  case REQ_UP_ITEM:
d263 2
a264 2
	    NAVIGATE(up);
	    break;
d266 1
a266 1
	  case REQ_DOWN_ITEM:
d268 2
a269 2
	    NAVIGATE(down);
	    break;
d271 1
a271 1
	  case REQ_SCR_ULINE:
d274 7
a280 7
	      result = E_REQUEST_DENIED;
	    else
	      {
		--my_top_row;
		item = item->up;
	      }
	    break;
d282 1
a282 1
	  case REQ_SCR_DLINE:
d285 9
a293 8
	      {
		/* only if the menu has less items than rows, we can deny the
		   request. Otherwise the epilogue of this routine adjusts the
		   top row if necessary */
		result = E_REQUEST_DENIED;
	      }
	  else {
	    my_top_row++;
d295 2
a296 2
	  }
	    break;
d298 1
a298 1
	  case REQ_SCR_DPAGE:
d301 11
a311 11
	    if (rdiff > menu->arows)
	      rdiff = menu->arows;
	  if (rdiff<=0)
	      result = E_REQUEST_DENIED;
	    else
	      {
		my_top_row += rdiff;
	      while(rdiff-- > 0 && item!=(ITEM*)0)
		  item = item->down;
	      }
	    break;
d313 1
a313 1
	  case REQ_SCR_UPAGE:
d316 9
a324 9
	  if (rdiff<=0)
	      result = E_REQUEST_DENIED;
	    else
	      {
		my_top_row -= rdiff;
	      while(rdiff-- && item!=(ITEM*)0)
		  item = item->up;
	      }
	    break;
d326 1
a326 1
	  case REQ_FIRST_ITEM:
d328 2
a329 2
	    item = menu->items[0];
	    break;
d331 1
a331 1
	  case REQ_LAST_ITEM:
d333 2
a334 2
	    item = menu->items[menu->nitems-1];
	    break;
d336 1
a336 1
	  case REQ_NEXT_ITEM:
d338 10
a347 10
	    if ((item->index+1)>=menu->nitems)
	      {
		if (menu->opt & O_NONCYCLIC)
		  result = E_REQUEST_DENIED;
		else
		  item = menu->items[0];
	      }
	    else
	      item = menu->items[item->index + 1];
	    break;
d349 1
a349 1
	  case REQ_PREV_ITEM:
d351 10
a360 10
	    if (item->index<=0)
	      {
		if (menu->opt & O_NONCYCLIC)
		  result = E_REQUEST_DENIED;
		else
		  item = menu->items[menu->nitems-1];
	      }
	    else
	      item = menu->items[item->index - 1];
	    break;
d362 1
a362 1
	  case REQ_TOGGLE_ITEM:
d364 16
a379 16
	    if (menu->opt & O_ONEVALUE)
	      {
		result = E_REQUEST_DENIED;
	      }
	    else
	      {
		if (menu->curitem->opt & O_SELECTABLE)
		  {
		    menu->curitem->value = !menu->curitem->value;
		    Move_And_Post_Item(menu,menu->curitem);
		    _nc_Show_Menu(menu);
		  }
		else
		  result = E_NOT_SELECTABLE;
	      }
	    break;
d381 1
a381 1
	  case REQ_CLEAR_PATTERN:
d383 2
a384 2
	    /* already cleared in prologue */
	    break;
d386 1
a386 1
	  case REQ_BACK_PATTERN:
d388 9
a396 9
	    if (menu->pindex>0)
	      {
		assert(menu->pattern);
		Remove_Character_From_Pattern(menu);
		pos_menu_cursor( menu );
	      }
	    else
	      result = E_REQUEST_DENIED;
	    break;
d398 1
a398 1
	  case REQ_NEXT_MATCH:
d400 16
a415 16
	    assert(menu->pattern);
	    if (menu->pattern[0])
	      result = _nc_Match_Next_Character_In_Item_Name(menu,0,&item);
	    else
	      {
		if ((item->index+1)<menu->nitems)
		  item=menu->items[item->index+1];
		else
		  {
		    if (menu->opt & O_NONCYCLIC)
		      result = E_REQUEST_DENIED;
		    else
		      item = menu->items[0];
		  }
	      }
	    break;
d417 1
a417 1
	  case REQ_PREV_MATCH:
d419 16
a434 16
	    assert(menu->pattern);
	    if (menu->pattern[0])
	      result = _nc_Match_Next_Character_In_Item_Name(menu,BS,&item);
	    else
	      {
		if (item->index)
		  item = menu->items[item->index-1];
		else
		  {
		    if (menu->opt & O_NONCYCLIC)
		      result = E_REQUEST_DENIED;
		    else
		      item = menu->items[menu->nitems-1];
		  }
	      }
	    break;
d436 1
a436 1
	  default:
d438 8
a445 8
	    result = E_UNKNOWN_COMMAND;
	    break;
	  }
      }
    else
      {				/* not a command */
	if ( !(c & ~((int)MAX_REGULAR_CHARACTER)) && isprint(c) )
	  result = _nc_Match_Next_Character_In_Item_Name( menu, c, &item );
d447 15
a461 15
        else if (KEY_MOUSE == c)
	  {
	    MEVENT	event;
	    WINDOW* uwin = Get_Menu_UserWin(menu);

	    getmouse(&event);
	    if ((event.bstate & (BUTTON1_CLICKED         |
				 BUTTON1_DOUBLE_CLICKED  |
				 BUTTON1_TRIPLE_CLICKED   ))
	     && wenclose(uwin,event.y, event.x))
	      { /* we react only if the click was in the userwin, that means
		 * inside the menu display area or at the decoration window.
		 */
		WINDOW* sub = Get_Menu_Window(menu);
		int ry = event.y, rx = event.x; /* screen coordinates */
d463 53
a515 51
		result = E_REQUEST_DENIED;
		if (mouse_trafo(&ry,&rx,FALSE))
		  { /* rx, ry are now "curses" coordinates */
		    if (ry < sub->_begy)
		      { /* we clicked above the display region; this is
			 * interpreted as "scroll up" request
			 */
			if (event.bstate & BUTTON1_CLICKED)
			  result = menu_driver(menu,REQ_SCR_ULINE);
			else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
			  result = menu_driver(menu,REQ_SCR_UPAGE);
			else if (event.bstate & BUTTON1_TRIPLE_CLICKED)
			  result = menu_driver(menu,REQ_FIRST_ITEM);
			RETURN(result);
		      }
		    else if (ry >= sub->_begy + sub->_maxy)
		      { /* we clicked below the display region; this is
			 * interpreted as "scroll down" request
			 */
			if (event.bstate & BUTTON1_CLICKED)
			  result = menu_driver(menu,REQ_SCR_DLINE);
			else if (event.bstate & BUTTON1_DOUBLE_CLICKED)
			  result = menu_driver(menu,REQ_SCR_DPAGE);
			else if (event.bstate & BUTTON1_TRIPLE_CLICKED)
			  result = menu_driver(menu,REQ_LAST_ITEM);
			RETURN(result);
		      }
		    else if (wenclose(sub,event.y,event.x))
		      { /* Inside the area we try to find the hit item */
			int i,x,y,err;
			ry = event.y; rx = event.x;
			if (wmouse_trafo(sub,&ry,&rx,FALSE))
			  {
			    for(i=0;i<menu->nitems;i++)
			      {
				err = _nc_menu_cursor_pos(menu,menu->items[i],
							  &y, &x);
				if (E_OK==err)
				  {
				    if ((ry==y)       &&
					(rx>=x)       &&
					(rx < x + menu->itemlen))
				      {
					item = menu->items[i];
					result = E_OK;
					break;
				      }
				  }
			      }
			    if (E_OK==result)
			      { /* We found an item, now we can handle the click.
d520 16
a535 16
				if (event.bstate & BUTTON1_DOUBLE_CLICKED)
				  {
				    _nc_New_TopRow_and_CurrentItem(menu,
								   my_top_row,
								   item);
				    menu_driver(menu,REQ_TOGGLE_ITEM);
				    result = E_UNKNOWN_COMMAND;
				  }
			      }
			  }
		      }
		  }
	      }
	    else
	        result = E_REQUEST_DENIED;
	  }
d537 3
a539 3
	else
	  result = E_UNKNOWN_COMMAND;
      }
d541 1
a541 1
  if (E_OK==result)
d543 6
a548 6
    /* Adjust the top row if it turns out that the current item unfortunately
       doesn't appear in the menu window */
    if ( item->y < my_top_row )
      my_top_row = item->y;
    else if ( item->y >= (my_top_row + menu->arows) )
      my_top_row = item->y - menu->arows + 1;
d550 1
a550 1
    _nc_New_TopRow_and_CurrentItem( menu, my_top_row, item );
@


1.6
log
@ncurses-4.2-990516; no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: m_driver.c,v 1.5 1999/01/22 03:45:06 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d42 1
a42 1
MODULE_ID("$From: m_driver.c,v 1.17 1999/05/16 17:24:55 juergen Exp $")
d116 3
a118 1
int _nc_Match_Next_Character_In_Item_Name(MENU *menu, int ch, ITEM **item)
d205 2
a206 1
int menu_driver(MENU * menu, int   c)
@


1.5
log
@updates changes from latest ncurses
@
text
@d1 1
a1 1
/*	$OpenBSD: m_driver.c,v 1.4 1998/07/24 16:38:54 millert Exp $	*/
d32 1
a32 1
 *   Author: Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de> 1995,1997        *
d42 1
a42 1
MODULE_ID("$From: m_driver.c,v 1.15 1999/01/07 23:23:04 juergen Exp $")
@


1.4
log
@libmenu from ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
MODULE_ID("$From: m_driver.c,v 1.10 1998/02/11 12:13:49 tom Exp $")
d56 2
a57 2
|   Facility      :  libnmenu  
|   Function      :  static bool Is_Sub_String( 
d61 1
a61 1
|   
d92 1
a92 1
|   Facility      :  libnmenu  
d97 1
a97 1
|   
d112 1
a112 1
|  
d120 1
a120 1
  
d123 1
a123 1
  
d128 1
a128 1
      if ((menu->pindex+1) > menu->namelen) 
d130 1
a130 1
      
d137 1
a137 1
      if (--idx < 0) 
d140 1
a140 1
  
d142 1
a142 1
  
d146 1
a146 1
	if (--idx < 0) 
d151 1
a151 1
	if (++idx >= menu->nitems) 
d160 1
a160 1
      passed = TRUE;    
d162 1
a162 1
  
d176 1
a176 1
	 will never cycle through the whole item array.   
d187 1
a187 1
    }		
d189 1
a189 1
}	
d192 1
a192 1
|   Facility      :  libnmenu  
d194 1
a194 1
|   
d214 1
a214 1
  
d217 1
a217 1
  
d222 40
a261 56
  
  my_top_row = menu->toprow;
  item    = menu->curitem;
  assert(item);
  
  if ((c > KEY_MAX) && (c<=MAX_MENU_COMMAND))
    {  
      if (!((c==REQ_BACK_PATTERN)
	    || (c==REQ_NEXT_MATCH) || (c==REQ_PREV_MATCH)))
	{
	  assert( menu->pattern );
	  Reset_Pattern(menu);
	}
      
      switch(c)
	{
	case REQ_LEFT_ITEM:
	  /*=================*/  
	  NAVIGATE(left);
	  break;
	  
	case REQ_RIGHT_ITEM:
	  /*==================*/  
	  NAVIGATE(right);
	  break;
	  
	case REQ_UP_ITEM:
	  /*===============*/  
	  NAVIGATE(up);
	  break;
	  
	case REQ_DOWN_ITEM:
	  /*=================*/  
	  NAVIGATE(down);
	  break;
	  
	case REQ_SCR_ULINE:
	  /*=================*/  
	  if (my_top_row == 0)
	    result = E_REQUEST_DENIED;
	  else
	    {
	      --my_top_row;
	      item = item->up;
	    }  
	  break;
	  
	case REQ_SCR_DLINE:
	  /*=================*/  
	  my_top_row++;
	  if ((menu->rows - menu->arows)>0)
	    {
	      /* only if the menu has less items than rows, we can deny the
		 request. Otherwise the epilogue of this routine adjusts the
		 top row if necessary */
	      my_top_row--;
d263 3
a265 30
	    }
	  else
	    item = item->down;
	  break;
	  
	case REQ_SCR_DPAGE:
	  /*=================*/  
	  rdiff = menu->rows - menu->arows - my_top_row;
	  if (rdiff > menu->arows) 
	    rdiff = menu->arows;
	  if (rdiff==0)
	    result = E_REQUEST_DENIED;
	  else
	    {
	      my_top_row += rdiff;
	      while(rdiff-- > 0)
		item = item->down;
	    }
	  break;
	  
	case REQ_SCR_UPAGE:
	  /*=================*/  
	  rdiff = (menu->arows < my_top_row) ?
	    menu->arows : my_top_row;
	  if (rdiff==0)
	    result = E_REQUEST_DENIED;
	  else
	    {
	      my_top_row -= rdiff;
	      while(rdiff--)
d267 10
a276 18
	    }
	  break;
	  
	case REQ_FIRST_ITEM:
	  /*==================*/  
	  item = menu->items[0];
	  break;
	  
	case REQ_LAST_ITEM:
	  /*=================*/  
	  item = menu->items[menu->nitems-1];
	  break;

	case REQ_NEXT_ITEM:
	  /*=================*/  
	  if ((item->index+1)>=menu->nitems)
	    {
	      if (menu->opt & O_NONCYCLIC)
d278 75
a352 12
	      else
		item = menu->items[0];
	    }
	  else
	    item = menu->items[item->index + 1];
	  break;
	  
	case REQ_PREV_ITEM:
	  /*=================*/  
	  if (item->index<=0)
	    {
	      if (menu->opt & O_NONCYCLIC)
d354 28
a381 11
	      else
		item = menu->items[menu->nitems-1];
	    }
	  else
	    item = menu->items[item->index - 1];
	  break;
	  
	case REQ_TOGGLE_ITEM:
	  /*===================*/  
	  if (menu->opt & O_ONEVALUE)
	    {
d383 140
a522 71
	    }
	  else
	    {
	      if (menu->curitem->opt & O_SELECTABLE)
		{
		  menu->curitem->value = !menu->curitem->value;
		  Move_And_Post_Item(menu,menu->curitem);
		  _nc_Show_Menu(menu);
		}
	      else
		result = E_NOT_SELECTABLE;
	    }
	  break;
	  
	case REQ_CLEAR_PATTERN:
	  /*=====================*/  
	  /* already cleared in prologue */
	  break;
	  
	case REQ_BACK_PATTERN:
	  /*====================*/  
	  if (menu->pindex>0)
	    {
	      assert(menu->pattern);
	      Remove_Character_From_Pattern(menu);
	      pos_menu_cursor( menu );
	    }
	  else
	    result = E_REQUEST_DENIED;
	  break;
	  
	case REQ_NEXT_MATCH:
	  /*==================*/  
	  assert(menu->pattern);
	  if (menu->pattern[0])
	    result = _nc_Match_Next_Character_In_Item_Name(menu,0,&item);
	  else
	    {
	      if ((item->index+1)<menu->nitems)
		item=menu->items[item->index+1];
	      else
		{
		  if (menu->opt & O_NONCYCLIC)
		    result = E_REQUEST_DENIED;
		  else
		    item = menu->items[0];
		}
	    }
	  break;	
	  
	case REQ_PREV_MATCH:
	  /*==================*/  
	  assert(menu->pattern);
	  if (menu->pattern[0])
	    result = _nc_Match_Next_Character_In_Item_Name(menu,BS,&item);
	  else
	    {
	      if (item->index)
		item = menu->items[item->index-1];
	      else
		{
		  if (menu->opt & O_NONCYCLIC)
		    result = E_REQUEST_DENIED;
		  else
		    item = menu->items[menu->nitems-1];
		}
	    }
	  break;
	  
	default:
	  /*======*/  
d524 13
a536 2
	  break;
	}
d538 1
a538 17
  else
    {				/* not a command */
      if ( !(c & ~((int)MAX_REGULAR_CHARACTER)) && isprint(c) )
	result = _nc_Match_Next_Character_In_Item_Name( menu, c, &item );
      else
	result = E_UNKNOWN_COMMAND;
    }
  
  /* Adjust the top row if it turns out that the current item unfortunately
     doesn't appear in the menu window */
  if ( item->y < my_top_row )
    my_top_row = item->y;
  else if ( item->y >= (my_top_row + menu->arows) )
    my_top_row = item->y - menu->arows + 1;
  
  _nc_New_TopRow_and_CurrentItem( menu, my_top_row, item );
  
@


1.3
log
@merge of ncurses-4.1-971129
@
text
@d3 31
a33 21
/*-----------------------------------------------------------------------------+
|           The ncurses menu library is  Copyright (C) 1995-1997               |
|             by Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de>                 |
|                          All Rights Reserved.                                |
|                                                                              |
| Permission to use, copy, modify, and distribute this software and its        |
| documentation for any purpose and without fee is hereby granted, provided    |
| that the above copyright notice appear in all copies and that both that      |
| copyright notice and this permission notice appear in supporting             |
| documentation, and that the name of the above listed copyright holder(s) not |
| be used in advertising or publicity pertaining to distribution of the        |
| software without specific, written prior permission.                         | 
|                                                                              |
| THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD TO  |
| THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FIT-  |
| NESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR   |
| ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RE- |
| SULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, |
| NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH    |
| THE USE OR PERFORMANCE OF THIS SOFTWARE.                                     |
+-----------------------------------------------------------------------------*/
d42 1
a42 1
MODULE_ID("Id: m_driver.c,v 1.9 1997/10/21 08:44:31 juergen Exp $")
@


1.2
log
@libmenu from ncurses 4.1.  Post 4.1 patches to be applied in a separate commit.
@
text
@d1 2
d26 2
a27 2
* Module menu_driver and menu_pattern                                      *
* Central dispatching routine and pattern matching handling                *
d32 1
a32 1
MODULE_ID("Id: m_driver.c,v 1.8 1997/05/01 16:47:26 juergen Exp $")
d83 1
a83 1
|   Function      :  static int Match_Next_Character_In_Item_Name(
d106 1
a106 1
static int Match_Next_Character_In_Item_Name(MENU *menu, int ch, ITEM **item)
a182 75
|   Function      :  char *menu_pattern(const MENU *menu)
|   
|   Description   :  Return the value of the pattern buffer.
|
|   Return Values :  NULL          - if there is no pattern buffer allocated
|                    EmptyString   - if there is a pattern buffer but no
|                                    pattern is stored
|                    PatternString - as expected
+--------------------------------------------------------------------------*/
char *menu_pattern(const MENU * menu)
{
  return (menu ? (menu->pattern ? menu->pattern : "") : (char *)0);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  int set_menu_pattern(MENU *menu, const char *p)
|   
|   Description   :  Set the match pattern for a menu and position to the
|                    first item that matches.
|
|   Return Values :  E_OK              - success
|                    E_BAD_ARGUMENT    - invalid menu or pattern pointer
|                    E_NOT_CONNECTED   - no items connected to menu
|                    E_BAD_STATE       - menu in user hook routine
|                    E_NO_MATCH        - no item matches pattern
+--------------------------------------------------------------------------*/
int set_menu_pattern(MENU *menu, const char *p)
{
  ITEM *matchitem;
  int   matchpos;
  
  if (!menu || !p)	
    RETURN(E_BAD_ARGUMENT);
  
  if (!(menu->items))
    RETURN(E_NOT_CONNECTED);
  
  if ( menu->status & _IN_DRIVER )
    RETURN(E_BAD_STATE);
  
  Reset_Pattern(menu);
  
  if (!(*p))
    {
      pos_menu_cursor(menu);
      RETURN(E_OK);
    }
  
  if (menu->status & _LINK_NEEDED) 
    _nc_Link_Items(menu);
  
  matchpos  = menu->toprow;
  matchitem = menu->curitem;
  assert(matchitem);
  
  while(*p)
    {
      if ( !isprint(*p) || 
	  (Match_Next_Character_In_Item_Name(menu,*p,&matchitem) != E_OK) )
	{
	  Reset_Pattern(menu);
	  pos_menu_cursor(menu);
	  RETURN(E_NO_MATCH);
	}
      p++;
    }			
  
  /* This is reached if there was a match. So we position to the new item */
  Adjust_Current_Item(menu,matchpos,matchitem);
  RETURN(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
d379 1
a379 1
	    result = Match_Next_Character_In_Item_Name(menu,0,&item);
d398 1
a398 1
	    result = Match_Next_Character_In_Item_Name(menu,BS,&item);
d422 1
a422 1
	result = Match_Next_Character_In_Item_Name( menu, c, &item );
@


1.1
log
@Initial revision
@
text
@d1 21
a21 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d30 2
d335 1
a335 1
	  if ((menu->rows - menu->height)>0)
d349 3
a351 3
	  rdiff = menu->rows - menu->height - my_top_row;
	  if (rdiff > menu->height) 
	    rdiff = menu->height;
d364 2
a365 2
	  rdiff = (menu->height < my_top_row) ?
	    menu->height : my_top_row;
d422 1
a422 1
		  menu->curitem->value = TRUE;
d504 2
a505 2
  else if ( item->y >= (my_top_row + menu->height) )
    my_top_row = item->y - menu->height + 1;
@


1.1.1.1
log
@SYSV-style menu library; from ncurses
@
text
@@
