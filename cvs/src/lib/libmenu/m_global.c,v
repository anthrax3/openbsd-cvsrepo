head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.30
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.28
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.24
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.26
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.18
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.30
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.26
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.24
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.22
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.20
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.18
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.16
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.8
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	ncurses:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2010.01.12.23.22.07;	author nicm;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.05.22.41.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.22.18.02.03;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.05.17.03.04.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.07.24.16.38.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.31.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.03.58.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.21.34.41;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.02.21.34.41;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2004,2005 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *   Author:  Juergen Pfeifer, 1995,1997                                    *
 ****************************************************************************/

/***************************************************************************
* Module m_global                                                          *
* Globally used internal routines and the default menu and item structures *
***************************************************************************/

#include "menu.priv.h"

MODULE_ID("$Id: m_global.c,v 1.23 2005/12/31 21:51:52 tom Exp $")

static char mark[] = "-";
/* *INDENT-OFF* */
NCURSES_EXPORT_VAR(MENU) _nc_Default_Menu = {
  16,				  /* Nr. of chars high */
  1,				  /* Nr. of chars wide */
  16,				  /* Nr. of items high */
  1,			          /* Nr. of items wide */
  16,				  /* Nr. of formatted items high */
  1,				  /* Nr. of formatted items wide */
  16,				  /* Nr. of items high (actual) */
  0,				  /* length of widest name */
  0,				  /* length of widest description */
  1,				  /* length of mark */
  1,				  /* length of one item */
  1,                              /* Spacing for descriptor */ 
  1,                              /* Spacing for columns */
  1,                              /* Spacing for rows */
  (char *)0,			  /* buffer used to store match chars */
  0,				  /* Index into pattern buffer */
  (WINDOW *)0,			  /* Window containing entire menu */
  (WINDOW *)0,			  /* Portion of menu displayed */
  (WINDOW *)0,			  /* User's window */
  (WINDOW *)0,			  /* User's subwindow */
  (ITEM **)0,			  /* List of items */
  0,				  /* Total Nr. of items in menu */
  (ITEM *)0,			  /* Current item */
  0,				  /* Top row of menu */
  (chtype)A_REVERSE,		  /* Attribute for selection */
  (chtype)A_NORMAL,		  /* Attribute for nonselection */
  (chtype)A_UNDERLINE,		  /* Attribute for inactive */	
  ' ',  			  /* Pad character */
  (Menu_Hook)0,			  /* Menu init */
  (Menu_Hook)0,			  /* Menu term */
  (Menu_Hook)0,			  /* Item init */
  (Menu_Hook)0,			  /* Item term */
  (void *)0,			  /* userptr */
  mark,				  /* mark */
  ALL_MENU_OPTS,                  /* options */
  0			          /* status */	    
};

NCURSES_EXPORT_VAR(ITEM) _nc_Default_Item = {
  { (char *)0, 0 },		  /* name */
  { (char *)0, 0 },		  /* description */
  (MENU *)0,		          /* Pointer to parent menu */
  (char *)0,			  /* Userpointer */
  ALL_ITEM_OPTS,		  /* options */
  0,				  /* Item Nr. */
  0,				  /* y */
  0,				  /* x */
  FALSE,			  /* value */
  (ITEM *)0,		          /* left */
  (ITEM *)0,		          /* right */
  (ITEM *)0,		          /* up */
  (ITEM *)0		          /* down */
  };
/* *INDENT-ON* */

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  static void ComputeMaximum_NameDesc_Lenths(MENU *menu)
|   
|   Description   :  Calculates the maximum name and description lengths
|                    of the items connected to the menu
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_INLINE static void
ComputeMaximum_NameDesc_Lengths(MENU * menu)
{
  unsigned MaximumNameLength = 0;
  unsigned MaximumDescriptionLength = 0;
  ITEM **items;
  unsigned check;

  assert(menu && menu->items);
  for (items = menu->items; *items; items++)
    {
      check = _nc_Calculate_Text_Width(&((*items)->name));
      if (check > MaximumNameLength)
	MaximumNameLength = check;

      check = _nc_Calculate_Text_Width(&((*items)->description));
      if (check > MaximumDescriptionLength)
	MaximumDescriptionLength = check;
    }

  menu->namelen = MaximumNameLength;
  menu->desclen = MaximumDescriptionLength;
  T(("ComputeMaximum_NameDesc_Lengths %d,%d", menu->namelen, menu->desclen));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  static void ResetConnectionInfo(MENU *, ITEM **)
|   
|   Description   :  Reset all informations in the menu and the items in
|                    the item array that indicates a connection
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_INLINE static void
ResetConnectionInfo(MENU * menu, ITEM ** items)
{
  ITEM **item;

  assert(menu && items);
  for (item = items; *item; item++)
    {
      (*item)->index = 0;
      (*item)->imenu = (MENU *) 0;
    }
  if (menu->pattern)
    free(menu->pattern);
  menu->pattern = (char *)0;
  menu->pindex = 0;
  menu->items = (ITEM **) 0;
  menu->nitems = 0;
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  bool _nc_Connect_Items(MENU *menu, ITEM **items)
|
|   Description   :  Connect the items in the item array to the menu.
|                    Decorate all the items with a number and a backward
|                    pointer to the menu.
|
|   Return Values :  TRUE       - successful connection
|                    FALSE      - connection failed
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(bool)
_nc_Connect_Items(MENU * menu, ITEM ** items)
{
  ITEM **item;
  unsigned int ItemCount = 0;

  if (menu && items)
    {
      for (item = items; *item; item++)
	{
	  if ((*item)->imenu)
	    {
	      /* if a item is already connected, reject connection */
	      break;
	    }
	}
      if (!(*item))
	/* we reached the end, so there was no connected item */
	{
	  for (item = items; *item; item++)
	    {
	      if (menu->opt & O_ONEVALUE)
		{
		  (*item)->value = FALSE;
		}
	      (*item)->index = ItemCount++;
	      (*item)->imenu = menu;
	    }
	}
    }
  else
    return (FALSE);

  if (ItemCount != 0)
    {
      menu->items = items;
      menu->nitems = ItemCount;
      ComputeMaximum_NameDesc_Lengths(menu);
      if ((menu->pattern = typeMalloc(char, (unsigned)(1 + menu->namelen))))
	{
	  Reset_Pattern(menu);
	  set_menu_format(menu, menu->frows, menu->fcols);
	  menu->curitem = *items;
	  menu->toprow = 0;
	  return (TRUE);
	}
    }

  /* If we fall through to this point, we have to reset all items connection 
     and inform about a reject connection */
  ResetConnectionInfo(menu, items);
  return (FALSE);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  void _nc_Disconnect_Items(MENU *menu)
|   
|   Description   :  Disconnect the menus item array from the menu
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(void)
_nc_Disconnect_Items(MENU * menu)
{
  if (menu && menu->items)
    ResetConnectionInfo(menu, menu->items);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  int _nc_Calculate_Text_Width(const TEXT * item)
|   
|   Description   :  Calculate the number of columns for a TEXT.
|
|   Return Values :  the width
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
_nc_Calculate_Text_Width(const TEXT * item /*FIXME: limit length */ )
{
#if USE_WIDEC_SUPPORT
  int result = item->length;

  T((T_CALLED("_nc_menu_text_width(%p)"), item));
  if (result != 0 && item->str != 0)
    {
      int count = mbstowcs(0, item->str, 0);
      wchar_t *temp = 0;

      if (count > 0
	  && (temp = typeMalloc(wchar_t, 2 + count)) != 0)
	{
	  int n;

	  result = 0;
	  mbstowcs(temp, item->str, (unsigned)count);
	  for (n = 0; n < count; ++n)
	    {
	      int test = wcwidth(temp[n]);

	      if (test <= 0)
		test = 1;
	      result += test;
	    }
	  free(temp);
	}
    }
  returnCode(result);
#else
  return item->length;
#endif
}

/*
 * Calculate the actual width of a menu entry for wide-characters.
 */
#if USE_WIDEC_SUPPORT
static int
calculate_actual_width(MENU * menu, bool name)
{
  int width = 0;
  int check = 0;
  ITEM **items;

  assert(menu && menu->items);

  if (menu->items != 0)
    {
      for (items = menu->items; *items; items++)
	{
	  if (name)
	    {
	      check = _nc_Calculate_Text_Width(&((*items)->name));
	    }
	  else
	    {
	      check = _nc_Calculate_Text_Width(&((*items)->description));
	    }
	  if (check > width)
	    width = check;
	}
    }
  else
    {
      width = (name ? menu->namelen : menu->desclen);
    }

  T(("calculate_actual_width %s = %d/%d",
     name ? "name" : "desc",
     width,
     name ? menu->namelen : menu->desclen));
  return width;
}
#else
#define calculate_actual_width(menu, name) (name ? menu->namelen : menu->desclen)
#endif

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  void _nc_Calculate_Item_Length_and_Width(MENU *menu)
|   
|   Description   :  Calculate the length of an item and the width of the
|                    whole menu.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(void)
_nc_Calculate_Item_Length_and_Width(MENU * menu)
{
  int l;

  assert(menu);

  menu->height = 1 + menu->spc_rows * (menu->arows - 1);

  l = calculate_actual_width(menu, TRUE);
  l += menu->marklen;

  if ((menu->opt & O_SHOWDESC) && (menu->desclen > 0))
    {
      l += calculate_actual_width(menu, FALSE);
      l += menu->spc_desc;
    }

  menu->itemlen = l;
  l *= menu->cols;
  l += (menu->cols - 1) * menu->spc_cols;	/* for the padding between the columns */
  menu->width = l;

  T(("_nc_CalculateItem_Length_and_Width columns %d, item %d, width %d",
     menu->cols,
     menu->itemlen,
     menu->width));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  void _nc_Link_Item(MENU *menu)
|   
|   Description   :  Statically calculate for every item its four neighbors.
|                    This depends on the orientation of the menu. This
|                    static approach simplifies navigation in the menu a lot.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(void)
_nc_Link_Items(MENU * menu)
{
  if (menu && menu->items && *(menu->items))
    {
      int i, j;
      ITEM *item;
      int Number_Of_Items = menu->nitems;
      int col = 0, row = 0;
      int Last_in_Row;
      int Last_in_Column;
      bool cycle = (menu->opt & O_NONCYCLIC) ? FALSE : TRUE;

      menu->status &= ~_LINK_NEEDED;

      if (menu->opt & O_ROWMAJOR)
	{
	  int Number_Of_Columns = menu->cols;

	  for (i = 0; i < Number_Of_Items; i++)
	    {
	      item = menu->items[i];

	      Last_in_Row = row * Number_Of_Columns + (Number_Of_Columns - 1);

	      item->left = (col) ?
	      /* if we are not in the leftmost column, we can use the
	         predecessor in the items array */
		menu->items[i - 1] :
		(cycle ? menu->items[(Last_in_Row >= Number_Of_Items) ?
				     Number_Of_Items - 1 :
				     Last_in_Row] :
		 (ITEM *) 0);

	      item->right = ((col < (Number_Of_Columns - 1)) &&
			     ((i + 1) < Number_Of_Items)
		)?
		menu->items[i + 1] :
		(cycle ? menu->items[row * Number_Of_Columns] :
		 (ITEM *) 0
		);

	      Last_in_Column = (menu->rows - 1) * Number_Of_Columns + col;

	      item->up = (row) ? menu->items[i - Number_Of_Columns] :
		(cycle ? menu->items[(Last_in_Column >= Number_Of_Items) ?
				     Number_Of_Items - 1 :
				     Last_in_Column] :
		 (ITEM *) 0);

	      item->down = ((i + Number_Of_Columns) < Number_Of_Items)
		?
		menu->items[i + Number_Of_Columns] :
		(cycle ? menu->items[(row + 1) < menu->rows ?
				     Number_Of_Items - 1 : col] :
		 (ITEM *) 0);
	      item->x = col;
	      item->y = row;
	      if (++col == Number_Of_Columns)
		{
		  row++;
		  col = 0;
		}
	    }
	}
      else
	{
	  int Number_Of_Rows = menu->rows;

	  for (j = 0; j < Number_Of_Items; j++)
	    {
	      item = menu->items[i = (col * Number_Of_Rows + row)];

	      Last_in_Column = (menu->cols - 1) * Number_Of_Rows + row;

	      item->left = (col) ?
		menu->items[i - Number_Of_Rows] :
		(cycle ? (Last_in_Column >= Number_Of_Items) ?
		 menu->items[Last_in_Column - Number_Of_Rows] :
		 menu->items[Last_in_Column] :
		 (ITEM *) 0);

	      item->right = ((i + Number_Of_Rows) < Number_Of_Items)
		?
		menu->items[i + Number_Of_Rows] :
		(cycle ? menu->items[row] : (ITEM *) 0);

	      Last_in_Row = col * Number_Of_Rows + (Number_Of_Rows - 1);

	      item->up = (row) ?
		menu->items[i - 1] :
		(cycle ?
		 menu->items[(Last_in_Row >= Number_Of_Items) ?
			     Number_Of_Items - 1 :
			     Last_in_Row] :
		 (ITEM *) 0);

	      item->down = (row < (Number_Of_Rows - 1))
		?
		(menu->items[((i + 1) < Number_Of_Items) ?
			     i + 1 :
			     (col - 1) * Number_Of_Rows + row + 1]) :
		(cycle ?
		 menu->items[col * Number_Of_Rows] :
		 (ITEM *) 0
		);

	      item->x = col;
	      item->y = row;
	      if ((++row) == Number_Of_Rows)
		{
		  col++;
		  row = 0;
		}
	    }
	}
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  void _nc_Show_Menu(const MENU *menu)
|   
|   Description   :  Update the window that is associated with the menu
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(void)
_nc_Show_Menu(const MENU * menu)
{
  WINDOW *win;
  int maxy, maxx;

  assert(menu);
  if ((menu->status & _POSTED) && !(menu->status & _IN_DRIVER))
    {
      /* adjust the internal subwindow to start on the current top */
      assert(menu->sub);
      mvderwin(menu->sub, menu->spc_rows * menu->toprow, 0);
      win = Get_Menu_Window(menu);

      maxy = getmaxy(win);
      maxx = getmaxx(win);

      if (menu->height < maxy)
	maxy = menu->height;
      if (menu->width < maxx)
	maxx = menu->width;

      copywin(menu->sub, win, 0, 0, 0, 0, maxy - 1, maxx - 1, 0);
      pos_menu_cursor(menu);
    }
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu  
|   Function      :  void _nc_New_TopRow_and_CurrentItem(
|                            MENU *menu, 
|                            int new_toprow, 
|                            ITEM *new_current_item)
|   
|   Description   :  Redisplay the menu so that the given row becomes the
|                    top row and the given item becomes the new current
|                    item.
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(void)
  _nc_New_TopRow_and_CurrentItem
  (MENU * menu, int new_toprow, ITEM * new_current_item)
{
  ITEM *cur_item;
  bool mterm_called = FALSE;
  bool iterm_called = FALSE;

  assert(menu);
  if (menu->status & _POSTED)
    {
      if (new_current_item != menu->curitem)
	{
	  Call_Hook(menu, itemterm);
	  iterm_called = TRUE;
	}
      if (new_toprow != menu->toprow)
	{
	  Call_Hook(menu, menuterm);
	  mterm_called = TRUE;
	}

      cur_item = menu->curitem;
      assert(cur_item);
      menu->toprow = new_toprow;
      menu->curitem = new_current_item;

      if (mterm_called)
	{
	  Call_Hook(menu, menuinit);
	}
      if (iterm_called)
	{
	  /* this means, move from the old current_item to the new one... */
	  Move_To_Current_Item(menu, cur_item);
	  Call_Hook(menu, iteminit);
	}
      if (mterm_called || iterm_called)
	{
	  _nc_Show_Menu(menu);
	}
      else
	pos_menu_cursor(menu);
    }
  else
    {				/* if we are not posted, this is quite simple */
      menu->toprow = new_toprow;
      menu->curitem = new_current_item;
    }
}

/* m_global.c ends here */
@


1.7
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: m_global.c,v 1.6 2001/01/22 18:02:03 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d32 1
a32 1
 *   Author: Juergen Pfeifer <juergen.pfeifer@@gmx.net> 1995,1997            *
d42 1
a42 1
MODULE_ID("$From: m_global.c,v 1.12 2000/12/10 02:16:48 tom Exp $")
d44 2
d80 1
a80 1
  "-",				  /* mark */
d100 1
d111 2
a112 1
INLINE static void ComputeMaximum_NameDesc_Lengths(MENU * menu)
d114 1
a114 1
  unsigned MaximumNameLength        = 0;
d117 2
a118 1
  
d120 1
a120 1
  for( items = menu->items; *items ; items++ )
d122 7
a128 5
      if (items[0]->name.length > MaximumNameLength )
	MaximumNameLength  = items[0]->name.length;
      
      if (items[0]->description.length > MaximumDescriptionLength)
	MaximumDescriptionLength = items[0]->description.length;
d130 1
a130 1
  
d133 1
d145 2
a146 1
INLINE static void ResetConnectionInfo(MENU *menu, ITEM **items)
d149 1
a149 1
  
d151 1
a151 1
  for(item=items; *item; item++)
d154 1
a154 1
      (*item)->imenu = (MENU *)0;		
d159 3
a161 3
  menu->pindex  = 0;
  menu->items   = (ITEM **)0;
  menu->nitems  = 0;
d176 1
a176 1
_nc_Connect_Items (MENU *menu, ITEM **items)
d180 4
a183 4
  
  if ( menu && items )
    {    
      for(item=items; *item ; item++)
d185 1
a185 1
	  if ( (*item)->imenu )
d191 1
a191 1
      if (! (*item) )		
d194 1
a194 1
	  for(item=items; *item ; item++)
d202 1
a202 1
	    }			
d206 2
a207 2
    return(FALSE);
  
d210 1
a210 1
      menu->items  = items;
d213 1
a213 1
      if ( (menu->pattern = (char *)malloc( (unsigned)(1 + menu->namelen))) )
d215 2
a216 2
	  Reset_Pattern(menu);	
	  set_menu_format(menu,menu->frows,menu->fcols);
d219 1
a219 1
	  return(TRUE);
d222 1
a222 1
  
d225 2
a226 2
  ResetConnectionInfo( menu, items );
  return(FALSE);
d238 1
a238 1
_nc_Disconnect_Items (MENU * menu)
d241 1
a241 1
    ResetConnectionInfo( menu, menu->items );
d246 88
d342 1
a342 1
_nc_Calculate_Item_Length_and_Width (MENU * menu)
d345 1
a345 1
  
d348 10
a357 1
  menu->height  = 1 + menu->spc_rows * (menu->arows - 1);
a358 4
  l = menu->namelen + menu->marklen;
  if ( (menu->opt & O_SHOWDESC) && (menu->desclen > 0) )
    l += (menu->desclen + menu->spc_desc);
  
d361 1
a361 1
  l += (menu->cols-1)*menu->spc_cols; /* for the padding between the columns */
d363 6
a368 1
}  
d374 1
a374 1
|   Description   :  Statically calculate for every item its four neighbours.
d376 1
a376 1
|                    static aproach simplifies navigation in the menu a lot.
d381 1
a381 1
_nc_Link_Items (MENU * menu)
d385 1
a385 1
      int i,j;
d392 1
a392 1
      
d394 1
a394 1
      
d398 2
a399 2
	  
	  for(i=0; i < Number_Of_Items; i++)
d402 34
a435 34
	      
	      Last_in_Row = row * Number_Of_Columns + (Number_Of_Columns-1);
	      
	      item->left  = (col) ? 
		/* if we are not in the leftmost column, we can use the
		   predecessor in the items array */
		menu->items[i-1] :
		  (cycle ? menu->items[(Last_in_Row>=Number_Of_Items) ? 
				       Number_Of_Items-1:
				       Last_in_Row] : 
		   (ITEM *)0 );
	      
	      item->right = (  (col < (Number_Of_Columns-1)) && 
			     ((i+1) < Number_Of_Items) 
			     ) ? 
			       menu->items[i+1] :
				 ( cycle ? menu->items[row * Number_Of_Columns] : 
				  (ITEM *)0
				  );
	      
	      Last_in_Column = (menu->rows-1) * Number_Of_Columns + col;
	      
	      item->up    = (row) ? menu->items[i-Number_Of_Columns] :
		(cycle ? menu->items[(Last_in_Column>=Number_Of_Items) ?
				     Number_Of_Items-1 : 
				     Last_in_Column] : 
		 (ITEM *)0);
	      
	      item->down  = ( (i+Number_Of_Columns) < Number_Of_Items ) 
		? 
		  menu->items[i + Number_Of_Columns] :
		    (cycle ? menu->items[(row+1)<menu->rows ?
					 Number_Of_Items-1:col] : 
		     (ITEM *)0);
d438 1
a438 1
	      if ( ++col == Number_Of_Columns )
d448 2
a449 2
	  
	  for(j=0; j<Number_Of_Items; j++)
d451 5
a455 5
	      item = menu->items[i=(col * Number_Of_Rows + row)];
	      
	      Last_in_Column = (menu->cols-1) * Number_Of_Rows + row;
	      
	      item->left  = (col) ? 
d457 10
a466 10
		  (cycle ? (Last_in_Column >= Number_Of_Items ) ? 
		   menu->items[Last_in_Column-Number_Of_Rows] : 
		   menu->items[Last_in_Column] : 
		   (ITEM *)0 );
	      
	      item->right = ((i + Number_Of_Rows) <Number_Of_Items) 
		? 
		  menu->items[i + Number_Of_Rows] :
		    (cycle ? menu->items[row] : (ITEM *)0);
	      
d468 19
a486 19
	      
	      item->up    = (row) ? 
		menu->items[i-1] :
		  (cycle ?
		   menu->items[(Last_in_Row>=Number_Of_Items) ? 
			       Number_Of_Items-1:
			       Last_in_Row] :
		   (ITEM *)0);
	      
	      item->down  = (row < (Number_Of_Rows-1)) 
		? 
		  (menu->items[((i+1)<Number_Of_Items) ? 
			       i+1 :
			       (col-1)*Number_Of_Rows + row + 1]) :
				 (cycle ?
				  menu->items[col * Number_Of_Rows] :
				  (ITEM *)0
				  );
	      
d489 1
a489 1
	      if ( (++row) == Number_Of_Rows )
d508 1
a508 1
_nc_Show_Menu (const MENU *menu)
d512 1
a512 1
  
d514 1
a514 1
  if ( (menu->status & _POSTED) && !(menu->status & _IN_DRIVER) )
d518 1
a518 1
      mvderwin(menu->sub,menu->spc_rows * menu->toprow,0);
d520 1
a520 1
      
d522 3
a524 3
      maxx = getmaxx(win);	 
      
      if (menu->height < maxy) 
d526 1
a526 1
      if (menu->width < maxx) 
d528 2
a529 2
      
      copywin(menu->sub,win,0,0,0,0,maxy-1,maxx-1,0);
d531 2
a532 2
    }	
}	
d548 2
a549 2
_nc_New_TopRow_and_CurrentItem
(MENU *menu, int new_toprow, ITEM *new_current_item)
d554 1
a554 1
  
d560 1
a560 1
	  Call_Hook(menu,itemterm);
d565 1
a565 1
	  Call_Hook(menu,menuterm);
d567 3
a569 3
	}			
      
      cur_item  = menu->curitem;
d571 3
a573 3
      menu->toprow  = new_toprow;
      menu->curitem = new_current_item;			
      
d576 1
a576 1
	  Call_Hook(menu,menuinit);
d581 2
a582 2
	  Move_To_Current_Item( menu, cur_item );
	  Call_Hook(menu,iteminit);
d592 2
a593 2
    { /* if we are not posted, this is quite simple */
      menu->toprow  = new_toprow;
@


1.6
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: m_global.c,v 1.5 1999/05/17 03:04:22 millert Exp $	*/
d163 1
a163 1
|   Return Values :  TRUE       - successfull connection
@


1.5
log
@ncurses-4.2-990516; no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: m_global.c,v 1.4 1998/07/24 16:38:57 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d42 1
a42 1
MODULE_ID("$From: m_global.c,v 1.11 1999/05/16 17:25:14 juergen Exp $")
d44 1
a44 1
MENU _nc_Default_Menu = {
d83 1
a83 1
ITEM _nc_Default_Item = {
d166 2
a167 1
bool _nc_Connect_Items(MENU *menu, ITEM **items)
d228 2
a229 1
void _nc_Disconnect_Items(MENU * menu)
d244 2
a245 1
void _nc_Calculate_Item_Length_and_Width(MENU * menu)
d273 2
a274 1
void _nc_Link_Items(MENU * menu)
d400 2
a401 1
void _nc_Show_Menu(const MENU *menu)
d440 3
a442 2
void _nc_New_TopRow_and_CurrentItem(MENU *menu, int new_toprow,
				    ITEM *new_current_item)
@


1.4
log
@libmenu from ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
 *   Author: Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de> 1995,1997        *
d42 1
a42 1
MODULE_ID("$From: m_global.c,v 1.9 1998/02/11 12:13:49 tom Exp $")
@


1.3
log
@merge of ncurses-4.1-971129
@
text
@d3 31
a33 21
/*-----------------------------------------------------------------------------+
|           The ncurses menu library is  Copyright (C) 1995-1997               |
|             by Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de>                 |
|                          All Rights Reserved.                                |
|                                                                              |
| Permission to use, copy, modify, and distribute this software and its        |
| documentation for any purpose and without fee is hereby granted, provided    |
| that the above copyright notice appear in all copies and that both that      |
| copyright notice and this permission notice appear in supporting             |
| documentation, and that the name of the above listed copyright holder(s) not |
| be used in advertising or publicity pertaining to distribution of the        |
| software without specific, written prior permission.                         | 
|                                                                              |
| THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD TO  |
| THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FIT-  |
| NESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR   |
| ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RE- |
| SULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, |
| NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH    |
| THE USE OR PERFORMANCE OF THIS SOFTWARE.                                     |
+-----------------------------------------------------------------------------*/
d42 1
a42 1
MODULE_ID("Id: m_global.c,v 1.8 1997/10/21 08:44:31 juergen Exp $")
@


1.2
log
@libmenu from ncurses 4.1.  Post 4.1 patches to be applied in a separate commit.
@
text
@d1 2
d26 1
a26 1
* Module menu_global                                                       *
d32 1
a32 1
MODULE_ID("Id: m_global.c,v 1.7 1997/05/01 16:47:26 juergen Exp $")
@


1.1
log
@Initial revision
@
text
@d1 21
a21 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d30 2
d39 1
d44 3
d186 1
a186 1
  if (ItemCount > 0)
d235 12
a246 12
  if (menu->items && *(menu->items))
    {
      l = menu->namelen + menu->marklen;
      if ( (menu->opt & O_SHOWDESC) && (menu->desclen > 0) )
	l += (menu->desclen + 1);
      
      menu->itemlen = l;
      l *= menu->cols;
      l += (menu->cols-1);	/* for the padding between the columns */
      menu->width = l;
    }
}
d394 1
a394 1
      mvderwin(menu->sub,menu->toprow,0);
@


1.1.1.1
log
@SYSV-style menu library; from ncurses
@
text
@@
