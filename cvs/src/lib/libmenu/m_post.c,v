head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.28
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.24
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.26
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.18
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.22
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.20
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.16
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.14
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.12
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.10
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.6
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.38
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.34
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.32
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.30
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.28
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.26
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.24
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.22
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.20
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.18
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.16
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.14
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.12
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.10
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.8
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.6
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	initial:1.1.1.1
	ncurses:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2010.01.12.23.22.08;	author nicm;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.22.18.02.06;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.05.17.03.04.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.07.24.16.39.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.12.03.05.31.25;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.26.03.58.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.06.02.21.34.41;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.06.02.21.34.41;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to ncurses 5.7, with local changes reapplied.

This is around eight years worth of changes (previously we were around ncurses
5.2), too many to list - many bug fixes and also a few new functions.

A major bump for libcurses, libpanel, libform and libmenu.

ok deraadt
@
text
@/* $OpenBSD$ */

/****************************************************************************
 * Copyright (c) 1998-2003,2004 Free Software Foundation, Inc.              *
 *                                                                          *
 * Permission is hereby granted, free of charge, to any person obtaining a  *
 * copy of this software and associated documentation files (the            *
 * "Software"), to deal in the Software without restriction, including      *
 * without limitation the rights to use, copy, modify, merge, publish,      *
 * distribute, distribute with modifications, sublicense, and/or sell       *
 * copies of the Software, and to permit persons to whom the Software is    *
 * furnished to do so, subject to the following conditions:                 *
 *                                                                          *
 * The above copyright notice and this permission notice shall be included  *
 * in all copies or substantial portions of the Software.                   *
 *                                                                          *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
 * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                          *
 * Except as contained in this notice, the name(s) of the above copyright   *
 * holders shall not be used in advertising or otherwise to promote the     *
 * sale, use or other dealings in this Software without prior written       *
 * authorization.                                                           *
 ****************************************************************************/

/****************************************************************************
 *   Author:  Juergen Pfeifer, 1995,1997                                    *
 ****************************************************************************/

/***************************************************************************
* Module m_post                                                            *
* Write or erase menus from associated subwindows                          *
***************************************************************************/

#include "menu.priv.h"

MODULE_ID("$Id: m_post.c,v 1.26 2004/12/25 23:57:04 tom Exp $")

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu
|   Function      :  void _nc_Post_Item(MENU *menu, ITEM *item)
|
|   Description   :  Draw the item in the menus window at the current
|                    window position
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(void)
_nc_Post_Item(const MENU * menu, const ITEM * item)
{
  int i;
  chtype ch;
  int item_x, item_y;
  int count = 0;
  bool isfore = FALSE, isback = FALSE, isgrey = FALSE;
  int name_len;
  int desc_len;

  assert(menu->win);

  getyx(menu->win, item_y, item_x);

  /* We need a marker iff
     - it is a onevalued menu and it is the current item
     - or it has a selection value
   */
  wattron(menu->win, menu->back);
  if (item->value || (item == menu->curitem))
    {
      if (menu->marklen)
	{
	  /* In a multi selection menu we use the fore attribute
	     for a selected marker that is not the current one.
	     This improves visualization of the menu, because now
	     always the 'normal' marker denotes the current
	     item. */
	  if (!(menu->opt & O_ONEVALUE) && item->value && item != menu->curitem)
	    {
	      wattron(menu->win, menu->fore);
	      isfore = TRUE;
	    }
	  waddstr(menu->win, menu->mark);
	  if (isfore)
	    {
	      wattron(menu->win, menu->fore);
	      isfore = FALSE;
	    }
	}
    }
  else				/* otherwise we have to wipe out the marker area */
    for (ch = ' ', i = menu->marklen; i > 0; i--)
      waddch(menu->win, ch);
  wattroff(menu->win, menu->back);
  count += menu->marklen;

  /* First we have to calculate the attribute depending on selectability
     and selection status
   */
  if (!(item->opt & O_SELECTABLE))
    {
      wattron(menu->win, menu->grey);
      isgrey = TRUE;
    }
  else
    {
      if (item->value || item == menu->curitem)
	{
	  wattron(menu->win, menu->fore);
	  isfore = TRUE;
	}
      else
	{
	  wattron(menu->win, menu->back);
	  isback = TRUE;
	}
    }

  waddnstr(menu->win, item->name.str, item->name.length);
  name_len = _nc_Calculate_Text_Width(&(item->name));
  for (ch = ' ', i = menu->namelen - name_len; i > 0; i--)
    {
      waddch(menu->win, ch);
    }
  count += menu->namelen;

  /* Show description if required and available */
  if ((menu->opt & O_SHOWDESC) && menu->desclen > 0)
    {
      int m = menu->spc_desc / 2;
      int cy = -1, cx = -1;

      for (ch = ' ', i = 0; i < menu->spc_desc; i++)
	{
	  if (i == m)
	    {
	      waddch(menu->win, menu->pad);
	      getyx(menu->win, cy, cx);
	    }
	  else
	    waddch(menu->win, ch);
	}
      if (item->description.length)
	waddnstr(menu->win, item->description.str, item->description.length);
      desc_len = _nc_Calculate_Text_Width(&(item->description));
      for (ch = ' ', i = menu->desclen - desc_len; i > 0; i--)
	{
	  waddch(menu->win, ch);
	}
      count += menu->desclen + menu->spc_desc;

      if (menu->spc_rows > 1)
	{
	  int j, k, ncy, ncx;

	  assert(cx >= 0 && cy >= 0);
	  getyx(menu->win, ncy, ncx);
	  if (isgrey)
	    wattroff(menu->win, menu->grey);
	  else if (isfore)
	    wattroff(menu->win, menu->fore);
	  wattron(menu->win, menu->back);
	  for (j = 1; j < menu->spc_rows; j++)
	    {
	      if ((item_y + j) < getmaxy(menu->win))
		{
		  wmove(menu->win, item_y + j, item_x);
		  for (k = 0; k < count; k++)
		    waddch(menu->win, ' ');
		}
	      if ((cy + j) < getmaxy(menu->win))
		mvwaddch(menu->win, cy + j, cx - 1, menu->pad);
	    }
	  wmove(menu->win, ncy, ncx);
	  if (!isback)
	    wattroff(menu->win, menu->back);
	}
    }

  /* Remove attributes */
  if (isfore)
    wattroff(menu->win, menu->fore);
  if (isback)
    wattroff(menu->win, menu->back);
  if (isgrey)
    wattroff(menu->win, menu->grey);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu
|   Function      :  void _nc_Draw_Menu(const MENU *)
|
|   Description   :  Display the menu in its windows
|
|   Return Values :  -
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(void)
_nc_Draw_Menu(const MENU * menu)
{
  ITEM *item = menu->items[0];
  ITEM *lasthor, *lastvert;
  ITEM *hitem;
  int y = 0;
  chtype s_bkgd;

  assert(item && menu->win);

  s_bkgd = getbkgd(menu->win);
  wbkgdset(menu->win, menu->back);
  werase(menu->win);
  wbkgdset(menu->win, s_bkgd);

  lastvert = (menu->opt & O_NONCYCLIC) ? (ITEM *) 0 : item;

  do
    {
      wmove(menu->win, y, 0);

      hitem = item;
      lasthor = (menu->opt & O_NONCYCLIC) ? (ITEM *) 0 : hitem;

      do
	{
	  _nc_Post_Item(menu, hitem);

	  wattron(menu->win, menu->back);
	  if (((hitem = hitem->right) != lasthor) && hitem)
	    {
	      int i, j, cy, cx;
	      chtype ch = ' ';

	      getyx(menu->win, cy, cx);
	      for (j = 0; j < menu->spc_rows; j++)
		{
		  wmove(menu->win, cy + j, cx);
		  for (i = 0; i < menu->spc_cols; i++)
		    {
		      waddch(menu->win, ch);
		    }
		}
	      wmove(menu->win, cy, cx + menu->spc_cols);
	    }
	}
      while (hitem && (hitem != lasthor));
      wattroff(menu->win, menu->back);

      item = item->down;
      y += menu->spc_rows;

    }
  while (item && (item != lastvert));
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu
|   Function      :  int post_menu(MENU *)
|
|   Description   :  Post a menu to the screen. This makes it visible.
|
|   Return Values :  E_OK                - success
|                    E_BAD_ARGUMENT      - not a valid menu pointer
|                    E_SYSTEM_ERROR      - error in lower layers
|                    E_NOT_CONNECTED     - No items connected to menu
|                    E_BAD_STATE         - Menu in userexit routine
|                    E_POSTED            - Menu already posted
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
post_menu(MENU * menu)
{
  T((T_CALLED("post_menu(%p)"), menu));

  if (!menu)
    RETURN(E_BAD_ARGUMENT);

  if (menu->status & _IN_DRIVER)
    RETURN(E_BAD_STATE);

  if (menu->status & _POSTED)
    RETURN(E_POSTED);

  if (menu->items && *(menu->items))
    {
      int y;
      int h = 1 + menu->spc_rows * (menu->rows - 1);

      WINDOW *win = Get_Menu_Window(menu);
      int maxy = getmaxy(win);

      if ((menu->win = newpad(h, menu->width)))
	{
	  y = (maxy >= h) ? h : maxy;
	  if (y >= menu->height)
	    y = menu->height;
	  if (!(menu->sub = subpad(menu->win, y, menu->width, 0, 0)))
	    RETURN(E_SYSTEM_ERROR);
	}
      else
	RETURN(E_SYSTEM_ERROR);

      if (menu->status & _LINK_NEEDED)
	_nc_Link_Items(menu);
    }
  else
    RETURN(E_NOT_CONNECTED);

  menu->status |= _POSTED;

  if (!(menu->opt & O_ONEVALUE))
    {
      ITEM **items;

      for (items = menu->items; *items; items++)
	{
	  (*items)->value = FALSE;
	}
    }

  _nc_Draw_Menu(menu);

  Call_Hook(menu, menuinit);
  Call_Hook(menu, iteminit);

  _nc_Show_Menu(menu);

  RETURN(E_OK);
}

/*---------------------------------------------------------------------------
|   Facility      :  libnmenu
|   Function      :  int unpost_menu(MENU *)
|
|   Description   :  Detach menu from screen
|
|   Return Values :  E_OK              - success
|                    E_BAD_ARGUMENT    - not a valid menu pointer
|                    E_BAD_STATE       - menu in userexit routine
|                    E_NOT_POSTED      - menu is not posted
+--------------------------------------------------------------------------*/
NCURSES_EXPORT(int)
unpost_menu(MENU * menu)
{
  WINDOW *win;

  T((T_CALLED("unpost_menu(%p)"), menu));

  if (!menu)
    RETURN(E_BAD_ARGUMENT);

  if (menu->status & _IN_DRIVER)
    RETURN(E_BAD_STATE);

  if (!(menu->status & _POSTED))
    RETURN(E_NOT_POSTED);

  Call_Hook(menu, itemterm);
  Call_Hook(menu, menuterm);

  win = Get_Menu_Window(menu);
  werase(win);
  wsyncup(win);

  assert(menu->sub);
  delwin(menu->sub);
  menu->sub = (WINDOW *)0;

  assert(menu->win);
  delwin(menu->win);
  menu->win = (WINDOW *)0;

  menu->status &= ~_POSTED;

  RETURN(E_OK);
}

/* m_post.c ends here */
@


1.6
log
@Update to ncurses-5.2-20010114
@
text
@d1 1
a1 1
/*	$OpenBSD: m_post.c,v 1.5 1999/05/17 03:04:25 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998,2000 Free Software Foundation, Inc.                   *
d32 1
a32 1
 *   Author: Juergen Pfeifer <juergen.pfeifer@@gmx.net> 1995,1997            *
d42 1
a42 1
MODULE_ID("$From: m_post.c,v 1.17 2000/12/10 02:16:48 tom Exp $")
d45 3
a47 3
|   Facility      :  libnmenu  
|   Function      :  void _nc_Post_Item(MENU *menu, ITEM *item)  
|   
d49 1
a49 1
|                    window position 
d54 1
a54 1
_nc_Post_Item (const MENU * menu, const ITEM * item)
d60 4
a63 2
  bool isfore = FALSE, isback=FALSE, isgrey = FALSE;
  
d65 3
a67 3
  
  getyx(menu->win,item_y,item_x);
  
d71 3
a73 3
     */
  wattron(menu->win,menu->back);
  if (item->value || (item==menu->curitem))
d75 1
a75 1
      if (menu->marklen) 
d82 1
a82 1
	  if (!(menu->opt & O_ONEVALUE) && item->value && item!=menu->curitem)
d84 1
a84 1
	      wattron(menu->win,menu->fore);
d87 1
a87 1
	  waddstr(menu->win,menu->mark);
d90 1
a90 1
	      wattron(menu->win,menu->fore);
d95 4
a98 4
  else			/* otherwise we have to wipe out the marker area */ 
    for(ch=' ',i=menu->marklen;i>0;i--) 
      waddch(menu->win,ch);
  wattroff(menu->win,menu->back);
d103 1
a103 1
     */
d106 1
a106 1
      wattron(menu->win,menu->grey);
d111 1
a111 1
      if (item->value || item==menu->curitem)
d113 1
a113 1
	  wattron(menu->win,menu->fore);
d118 1
a118 1
	  wattron(menu->win,menu->back);
d123 3
a125 2
  waddnstr(menu->win,item->name.str,item->name.length);
  for(ch=' ',i=menu->namelen-item->name.length;i>0;i--)
d127 1
a127 1
      waddch(menu->win,ch);
d132 1
a132 1
  if ( (menu->opt & O_SHOWDESC) && menu->desclen>0 )
d134 1
a134 1
      int m = menu->spc_desc/2;
d137 1
a137 1
      for(ch=' ',i=0; i < menu->spc_desc; i++)
d139 1
a139 1
	  if (i==m)
d141 2
a142 2
	      waddch(menu->win,menu->pad);
	      getyx(menu->win,cy,cx);
d145 1
a145 1
	    waddch(menu->win,ch);
d148 3
a150 2
	waddnstr(menu->win,item->description.str,item->description.length);
      for(ch=' ',i=menu->desclen-item->description.length; i>0; i--)
d152 1
a152 1
	  waddch(menu->win,ch);
d160 8
a167 6
	  assert(cx>=0 && cy>=0);
	  getyx(menu->win,ncy,ncx);
	  if (isgrey) wattroff(menu->win,menu->grey);
	  else if (isfore) wattroff(menu->win,menu->fore);
	  wattron(menu->win,menu->back);
	  for(j=1; j < menu->spc_rows;j++)
d169 1
a169 1
	      if ((item_y+j) < getmaxy(menu->win))
d171 3
a173 3
		  wmove (menu->win,item_y+j,item_x);
		  for(k=0;k<count;k++)
		    waddch(menu->win,' ');
d175 2
a176 2
	      if ((cy+j) < getmaxy(menu->win))
		mvwaddch(menu->win,cy+j,cx-1,menu->pad);
d178 1
a178 1
	  wmove(menu->win,ncy,ncx);
d180 1
a180 1
	    wattroff(menu->win,menu->back);
d183 1
a183 1
  
d186 1
a186 1
    wattroff(menu->win,menu->fore);
d188 1
a188 1
    wattroff(menu->win,menu->back);
d190 2
a191 2
    wattroff(menu->win,menu->grey);
}	
d194 1
a194 1
|   Facility      :  libnmenu  
d196 1
a196 1
|   
d202 1
a202 1
_nc_Draw_Menu (const MENU * menu)
d213 1
a213 1
  wbkgdset(menu->win,menu->back);
d215 1
a215 1
  wbkgdset(menu->win,s_bkgd);
d217 1
a217 1
  lastvert = (menu->opt & O_NONCYCLIC) ? (ITEM *)0 : item;  
d220 5
a224 2
    {  
      wmove(menu->win,y,0);
a225 3
      hitem   = item;
      lasthor = (menu->opt & O_NONCYCLIC) ? (ITEM *)0 : hitem;
      
d228 1
a228 1
	  _nc_Post_Item( menu, hitem);
d230 2
a231 2
	  wattron(menu->win,menu->back);
	  if ( ((hitem = hitem->right) != lasthor) && hitem )
d233 1
a233 1
	      int i,j, cy, cx;
d236 2
a237 2
	      getyx(menu->win,cy,cx);
	      for(j=0;j<menu->spc_rows;j++)
d239 2
a240 2
		  wmove(menu->win,cy+j,cx);
		  for(i=0; i < menu->spc_cols; i++)
d242 1
a242 1
		      waddch( menu->win,ch);
d245 1
a245 1
	      wmove(menu->win,cy,cx+menu->spc_cols);
d247 4
a250 3
	} while (hitem && (hitem != lasthor));
      wattroff(menu->win,menu->back);
      
d253 3
a255 2
      
    } while( item && (item != lastvert) );
d259 1
a259 1
|   Facility      :  libnmenu  
d261 1
a261 1
|   
a266 1
|                    E_NO_ROOM           - Menu to large for screen
d272 1
a272 1
post_menu (MENU * menu)
d274 2
d278 2
a279 2
  
  if ( menu->status & _IN_DRIVER )
d282 1
a282 1
  if ( menu->status & _POSTED )
d284 1
a284 1
  
a291 4
      int maxx = getmaxx(win);
      
      if (maxx < menu->width || maxy < menu->height)
	RETURN(E_NO_ROOM);
d293 1
a293 1
      if ( (menu->win = newpad(h,menu->width)) )
d296 1
a296 1
	  if (y>=menu->height) 
d298 1
a298 1
	  if(!(menu->sub = subpad(menu->win,y,menu->width,0,0)))
d301 4
a304 4
      else 
	RETURN(E_SYSTEM_ERROR);	
      
      if (menu->status & _LINK_NEEDED) 
d309 1
a309 1
  
d312 1
a312 1
  if (!(menu->opt&O_ONEVALUE))
d315 2
a316 2
  
      for(items=menu->items;*items;items++)
d321 1
a321 1
  
d323 4
a326 4
  
  Call_Hook(menu,menuinit);
  Call_Hook(menu,iteminit);
  
d328 1
a328 1
  
d333 1
a333 1
|   Facility      :  libnmenu  
d335 1
a335 1
|   
d344 1
a344 1
unpost_menu (MENU * menu)
d347 3
a349 1
  
d352 2
a353 2
  
  if ( menu->status & _IN_DRIVER )
d356 1
a356 1
  if ( !( menu->status & _POSTED ) )
d358 4
a361 4
  
  Call_Hook(menu,itemterm);
  Call_Hook(menu,menuterm);	
  
d365 1
a365 1
  
d369 1
a369 1
  
d373 1
a373 1
  
d375 1
a375 1
  
@


1.5
log
@ncurses-4.2-990516; no code changes
@
text
@d1 1
a1 1
/*	$OpenBSD: m_post.c,v 1.4 1998/07/24 16:39:14 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1998 Free Software Foundation, Inc.                        *
d42 1
a42 1
MODULE_ID("$From: m_post.c,v 1.16 1999/05/16 17:27:38 juergen Exp $")
d53 2
a54 1
void _nc_Post_Item(const MENU * menu, const ITEM * item)
d195 2
a196 1
void _nc_Draw_Menu(const MENU * menu)
d264 2
a265 1
int post_menu(MENU * menu)
d338 2
a339 1
int unpost_menu(MENU * menu)
@


1.4
log
@libmenu from ncurses-4.2-980718
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
 *   Author: Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de> 1995,1997        *
d42 1
a42 1
MODULE_ID("$From: m_post.c,v 1.14 1998/02/11 12:13:49 tom Exp $")
@


1.3
log
@merge of ncurses-4.1-971129
@
text
@d3 31
a33 21
/*-----------------------------------------------------------------------------+
|           The ncurses menu library is  Copyright (C) 1995-1997               |
|             by Juergen Pfeifer <Juergen.Pfeifer@@T-Online.de>                 |
|                          All Rights Reserved.                                |
|                                                                              |
| Permission to use, copy, modify, and distribute this software and its        |
| documentation for any purpose and without fee is hereby granted, provided    |
| that the above copyright notice appear in all copies and that both that      |
| copyright notice and this permission notice appear in supporting             |
| documentation, and that the name of the above listed copyright holder(s) not |
| be used in advertising or publicity pertaining to distribution of the        |
| software without specific, written prior permission.                         | 
|                                                                              |
| THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD TO  |
| THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FIT-  |
| NESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR   |
| ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RE- |
| SULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, |
| NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH    |
| THE USE OR PERFORMANCE OF THIS SOFTWARE.                                     |
+-----------------------------------------------------------------------------*/
d42 1
a42 1
MODULE_ID("Id: m_post.c,v 1.13 1997/10/21 08:44:31 juergen Exp $")
@


1.2
log
@libmenu from ncurses 4.1.  Post 4.1 patches to be applied in a separate commit.
@
text
@d1 2
d26 1
a26 1
* Module menu_post                                                         *
d32 1
a32 1
MODULE_ID("Id: m_post.c,v 1.12 1997/05/01 16:47:26 juergen Exp $")
@


1.1
log
@Initial revision
@
text
@d1 21
a21 20

/***************************************************************************
*                            COPYRIGHT NOTICE                              *
****************************************************************************
*                ncurses is copyright (C) 1992-1995                        *
*                          Zeyd M. Ben-Halim                               *
*                          zmbenhal@@netcom.com                             *
*                          Eric S. Raymond                                 *
*                          esr@@snark.thyrsus.com                           *
*                                                                          *
*        Permission is hereby granted to reproduce and distribute ncurses  *
*        by any means and for any fee, whether alone or as part of a       *
*        larger distribution, in source or in binary form, PROVIDED        *
*        this notice is included with any such distribution, and is not    *
*        removed from any of its header files. Mention of ncurses in any   *
*        applications linked with it is highly appreciated.                *
*                                                                          *
*        ncurses comes AS IS with no warranty, implied or expressed.       *
*                                                                          *
***************************************************************************/
d30 2
d45 2
d51 35
d107 1
a107 14
  
  /* We need a marker iff
     - it is a onevalued menu and it is the current item
     - or it has a selection value
     */
  if (item->value || ((menu->opt&O_ONEVALUE) && (item==menu->curitem))	)
    {
      if (menu->marklen) 
	waddstr(menu->win,menu->mark);
    }
  else			/* otherwise we have to wipe out the marker area */ 
    for(ch=menu->pad,i=menu->marklen;i>0;i--) 
      waddch(menu->win,ch);
  
d109 1
a109 1
  for(ch=menu->pad,i=menu->namelen-item->name.length;i>0;i--)
d113 2
a114 1
  
d118 13
a130 1
      waddch(menu->win,menu->pad);
d133 1
a133 1
      for(ch=menu->pad,i=menu->desclen-item->description.length; i>0; i--)
d137 26
d188 2
a189 1
  
d191 6
a196 1
  
d198 1
a198 1
  
d201 2
a202 2
      wmove(menu->win,y++,0);
      
d209 2
d213 13
a225 1
	      waddch( menu->win,menu->pad);
d228 1
d231 1
d233 1
a233 1
    } while( item && (item != lastvert) );	
d264 2
d273 1
a273 1
      if ( (menu->win = newpad(menu->rows,menu->width)) )
d275 1
a275 1
	  y = (maxy >= menu->rows) ? menu->rows : maxy;
@


1.1.1.1
log
@SYSV-style menu library; from ncurses
@
text
@@
