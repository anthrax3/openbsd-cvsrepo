head	1.2;
access;
symbols
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	from_mysql_3_22_4:1.1.1.2
	mit:1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.2
date	99.03.10.08.53.41;	author d;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.08.43.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.05;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.21.13.20.24;	author peter;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Goodbye, MIT pthreads... you were a handy reference implementation
@
text
@/* ==== sleep.c ============================================================
 * Copyright (c) 1993, 1994 by Chris Provenzano, proven@@mit.edu
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Chris Provenzano.
 * 4. The name of Chris Provenzano may not be used to endorse or promote 
 *	  products derived from this software without specific prior written
 *	  permission.
 *
 * THIS SOFTWARE IS PROVIDED BY CHRIS PROVENZANO ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL CHRIS PROVENZANO BE LIABLE FOR ANY 
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 *
 * Description : Condition cariable functions.
 *
 *  1.00 93/12/28 proven
 *      -Started coding this file.
 */

#ifndef lint
static const char rcsid[] = "$Id: sleep.c,v 1.1 1995/10/18 08:43:05 deraadt Exp $ $provenid: sleep.c,v 1.18 1994/02/07 02:19:31 proven Exp $";
#endif

#include <pthread.h>
#include <unistd.h>

struct pthread * pthread_sleep = NULL;
semaphore	sleep_semaphore = SEMAPHORE_CLEAR;


#include	<sys/time.h>
#include	<stdio.h>

/* ==========================================================================
 * machdep_start_timer()
 */
int machdep_start_timer(struct itimerval *start_time_val)
{
	setitimer(ITIMER_REAL, start_time_val, NULL);
	return(OK);
}

/* ==========================================================================
 * machdep_stop_timer()
 */
struct itimerval stop_time_val = { { 0, 0 }, { 0, 0 } };
int machdep_stop_timer(struct itimerval * current)
{
	setitimer(ITIMER_REAL, &stop_time_val, current);
	return(OK);
}

/* ==========================================================================
 * machdep_sub_timer()
 *
 * formula is: new -= current;
 */
static inline void machdep_sub_timer(struct itimerval * new,
  struct itimerval * current)
{
	new->it_value.tv_usec -= current->it_value.tv_usec;
	if (new->it_value.tv_usec < 0) {
		new->it_value.tv_usec += 1000000;
		new->it_value.tv_sec--;
	}
	new->it_value.tv_sec -= current->it_value.tv_sec;
}


/* ==========================================================================
 * sleep_basic_wakeup()
 *
 * The real work of sleep_wakeup is done here.
 */
static inline int sleep_basic_wakeup()
{
	struct pthread *pthread_sleep_next;
	struct itimerval current_time;
	semaphore *plock;

	machdep_stop_timer(&current_time);
	do {
		plock = &(pthread_sleep->lock);
		if (SEMAPHORE_TEST_AND_SET(plock)) {
			return(NOTOK);
		}

		/* return remaining time */
		pthread_sleep->time_sec = current_time.it_value.tv_sec;
		pthread_sleep->time_usec = current_time.it_value.tv_usec;

		if (pthread_sleep_next = pthread_sleep->sll) {
			pthread_sleep_next->time_usec += current_time.it_value.tv_usec;
			current_time.it_value.tv_usec = pthread_sleep_next->time_usec;
			pthread_sleep_next->time_sec += current_time.it_value.tv_sec;
			current_time.it_value.tv_sec = pthread_sleep_next->time_sec;
		}

		/* Clean up removed thread and start it runnng again. */
		pthread_sleep->state = PS_RUNNING;
		pthread_sleep->sll = NULL;
		SEMAPHORE_RESET(plock);

		/* Set top of queue to next queue item */
		pthread_sleep = pthread_sleep_next;

		if (current_time.it_value.tv_sec || current_time.it_value.tv_usec) {
			machdep_start_timer(&current_time);
			break;
		}

	} while(pthread_sleep);
	return(OK);
}

/* ==========================================================================
 * sleep_wakeup()
 *
 * This routine is called by the interrupt handler. It cannot call
 * pthread_yield() thenrfore it returns NOTOK to inform the handler
 * that it will have to be called at a later time.
 */
int sleep_wakeup()
{
	semaphore *lock, *plock;
	int ret;

	/* Lock sleep queue */
	lock = &(sleep_semaphore);
	if (SEMAPHORE_TEST_AND_SET(lock)) {
		return(NOTOK);
	}

	if (pthread_sleep) {
		ret = sleep_basic_wakeup();
	} else {
		ret = NOTOK;
	}

	SEMAPHORE_RESET(lock);
	return(ret);
}

/* ==========================================================================
 * sleep()
 */
unsigned int sleep(unsigned int seconds)
{
	struct pthread *pthread_sleep_current, *pthread_sleep_prev;
	struct itimerval current_time, new_time;
	semaphore *lock, *plock;

	if (seconds) {
		/* Lock current thread */
		plock = &(pthread_run->lock);
		while (SEMAPHORE_TEST_AND_SET(plock)) {
			pthread_yield();
		}

		/* Set new_time timer value */
		new_time.it_value.tv_usec 		= 0;
		new_time.it_value.tv_sec 		= seconds;
		new_time.it_interval.tv_usec 	= 0;
		new_time.it_interval.tv_sec 	= 0;

		/* Lock sleep queue */
		lock = &(sleep_semaphore);
		while (SEMAPHORE_TEST_AND_SET(lock)) {
			pthread_yield();
		}

		/* any threads? */
		if (pthread_sleep_current = pthread_sleep) {
			
			machdep_stop_timer(&current_time);

			/* Is remaining time left <= new thread time */
			if (current_time.it_value.tv_sec <= new_time.it_value.tv_sec) { 
				machdep_sub_timer(&new_time, &current_time);
				machdep_start_timer(&current_time);

				while (pthread_sleep_current->sll) {
					pthread_sleep_prev =  pthread_sleep_current;
					pthread_sleep_current = pthread_sleep_current->sll;
					current_time.it_value.tv_sec = pthread_sleep_current->time_sec;
					
					if ((current_time.it_value.tv_sec > new_time.it_value.tv_sec) ||
					  ((current_time.it_value.tv_sec == new_time.it_value.tv_sec) &&
					  (current_time.it_value.tv_usec > new_time.it_value.tv_usec))) {
						pthread_run->time_usec = new_time.it_value.tv_usec;
						pthread_run->time_sec = new_time.it_value.tv_sec;
						machdep_sub_timer(&current_time, &new_time);
						pthread_run->sll = pthread_sleep_current;
						pthread_sleep_prev->sll = pthread_run;

						/* Unlock sleep mutex */
						SEMAPHORE_RESET(lock);
	
						/* Reschedule thread */
						reschedule(PS_SLEEP_WAIT);

						return(pthread_run->time_sec);
					}
					machdep_sub_timer(&new_time, &current_time);

				} 

				/* No more threads in queue, attach pthread_run to end of list */
				pthread_sleep_current->sll = pthread_run;
				pthread_run->sll = NULL;

			} else {
				/* Start timer and enqueue thread */
				machdep_start_timer(&new_time);
				machdep_sub_timer(&current_time, &new_time);
				pthread_run->sll = pthread_sleep_current;
				pthread_sleep = pthread_run;
			}
		} else {
			/* Start timer and enqueue thread */
			machdep_start_timer(&new_time);
			pthread_sleep = pthread_run;
			pthread_run->sll = NULL;
		}

		pthread_run->time_usec = new_time.it_value.tv_usec;
		pthread_run->time_sec = new_time.it_value.tv_sec;

		/* Unlock sleep mutex */
		SEMAPHORE_RESET(lock);
	
		/* Reschedule thread */
		reschedule(PS_SLEEP_WAIT);

	}
	return(pthread_run->time_sec);
}

@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
static const char rcsid[] = "$Id: sleep.c,v 1.1 1994/02/07 22:04:30 proven Exp $ $provenid: sleep.c,v 1.18 1994/02/07 02:19:31 proven Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@Complete initial import from mySQL 3.22.4 (mit-pthreads/).
Lots of dross to move and remove yet.

At minimum:
o	remove GNU config and GNU Makefiles
o	build arch directory and migrate away machdep/
o	rebuild BSD Makefiles
o	move notes etc. into doc/
@
text
@d32 1
a32 1
 * Description : All the appropriate sleep routines.
a35 7
 *
 *	1.36 94/06/04 proven
 *		-Use new timer structure pthread_timer, that uses seconds
 *		-nano seconds. Rewrite all routines completely.
 *
 *	1.38 94/06/13 proven
 *		-switch pthread_timer to timespec
d39 1
a39 1
static const char rcsid[] = "$Id: sleep.c,v 1.65.4.2 1996/03/11 08:33:32 proven Exp $";
a42 2
#include <sys/time.h>
#include <signal.h>
a43 1
#include <sys/compat.h>
d46 5
d53 1
a53 1
 * sleep_compare_time()
d55 1
a55 3
/* static inline int sleep_compare_time(struct timespec * time1, 
  struct timespec * time2) */
static int sleep_compare_time(struct timespec * time1, struct timespec * time2)
d57 2
a58 8
	if ((time1->tv_sec < time2->tv_sec) || 
	  ((time1->tv_sec == time2->tv_sec) && (time1->tv_nsec < time2->tv_nsec))) {
		return(-1);
	}
	if ((time1->tv_sec == time2->tv_sec) && (time1->tv_nsec == time2->tv_nsec)){
		return(0);
	}
	return(1);
a62 2
 *
 * Returns the time left on the timer.
d64 2
a65 3
static struct itimerval timestop = { { 0, 0 }, { 0, 0 } };

void machdep_stop_timer(struct timespec *current)
d67 1
a67 38
	struct itimerval timenow;

	setitimer(ITIMER_REAL, & timestop, & timenow);
	__pthread_signal_delete(SIGALRM);
	if (current) {
		current->tv_nsec = timenow.it_value.tv_usec * 1000;
		current->tv_sec = timenow.it_value.tv_sec;
	}
}

/* ==========================================================================
 * machdep_start_timer()
 */
int machdep_start_timer(struct timespec *current, struct timespec *wakeup)
{
	struct itimerval timeout;

	timeout.it_value.tv_usec = (wakeup->tv_nsec - current->tv_nsec) / 1000;
	timeout.it_value.tv_sec = wakeup->tv_sec - current->tv_sec;
	timeout.it_interval.tv_usec = 0;
	timeout.it_interval.tv_sec = 0;
	if (timeout.it_value.tv_usec < 0) {
		timeout.it_value.tv_usec += 1000000;
		timeout.it_value.tv_sec--;
	}

	if ((!(timeout.it_value.tv_sec < 0)) &&
	  ((timeout.it_value.tv_usec) || (timeout.it_value.tv_sec))) {
	  if (setitimer(ITIMER_REAL, & timeout, NULL) < 0)
	    PANIC();
	} else {
		/*
		 * There is no time on the timer.
		 * This shouldn't happen,
		 * but isn't fatal.
		 */
		sig_handler_fake(SIGALRM);
	}
d72 1
a72 1
 * sleep_schedule()
d74 1
a74 2
 * Assumes that the current thread is the thread to be scheduled
 * and that the kthread is already locked.
d76 2
a77 1
void sleep_schedule(struct timespec *current_time, struct timespec *new_time)
d79 4
a82 38
	struct pthread * pthread_sleep_current, * pthread_sleep_prev;

	/* Record the new time as the current thread's wakeup time. */
	pthread_run->wakeup_time = *new_time;

	/* any threads? */
	if (pthread_sleep_current = pthread_sleep) {
		if (sleep_compare_time(&(pthread_sleep_current->wakeup_time),
		  new_time) <= 0) {
			/* Don't need to restart timer */
			while (pthread_sleep_current->sll) {

				pthread_sleep_prev =  pthread_sleep_current;
				pthread_sleep_current = pthread_sleep_current->sll;
				
				if (sleep_compare_time(&(pthread_sleep_current->wakeup_time),
				  new_time) > 0) {
					pthread_run->sll = pthread_sleep_current;
					pthread_sleep_prev->sll = pthread_run;
					return;
				}
			} 

			/* No more threads in queue, attach pthread_run to end of list */
			pthread_sleep_current->sll = pthread_run;
			pthread_run->sll = NULL;

		} else {
			/* Start timer and enqueue thread */
			machdep_start_timer(current_time, new_time);
			pthread_run->sll = pthread_sleep_current;
			pthread_sleep = pthread_run;
		}
	} else {
		/* Start timer and enqueue thread */
		machdep_start_timer(current_time, new_time);
		pthread_sleep = pthread_run;
		pthread_run->sll = NULL;
d84 1
d87 1
d89 1
a89 1
 * sleep_wakeup()
d91 1
a91 3
 * This routine is called by the interrupt handler, which has already
 * locked the current kthread. Since all threads on this list are owned
 * by the current kthread, rescheduling won't be a problem.
d93 1
a93 2
int sleep_spurious_wakeup = 0;
int sleep_wakeup()
d96 2
a97 13
	struct timespec current_time;
	int ret = 0;

	if (pthread_sleep == NULL) {
		return(NOTOK);
	} 

	machdep_gettimeofday(&current_time);
    if (sleep_compare_time(&(pthread_sleep->wakeup_time), &current_time) > 0) {
        machdep_start_timer(&current_time, &(pthread_sleep->wakeup_time));
        sleep_spurious_wakeup++;
        return(OK);
    }
d99 1
d101 3
a103 2
		if (pthread_sleep->pthread_priority > ret) {
			ret = pthread_sleep->pthread_priority;
d106 10
a115 15
		/*
		 * Clean up removed thread and start it running again. 
		 *
		 * Note: It is VERY important to remove the thread form the
		 * current queue before putting it on the run queue.
		 * Both queues use pthread_sleep->next, and the thread that points
		 * to pthread_sleep should point to pthread_sleep->next then
		 * pthread_sleep should be put on the run queue.
		 */
		if ((SET_PF_DONE_EVENT(pthread_sleep)) == OK) {
			if (pthread_sleep->queue)
				pthread_queue_remove(pthread_sleep->queue, pthread_sleep);
			pthread_prio_queue_enq(pthread_current_prio_queue, pthread_sleep);
			pthread_sleep->state = PS_RUNNING;
		} 
d117 2
a118 1
		pthread_sleep_next = pthread_sleep->sll;
d120 4
d125 3
a127 3
		if ((pthread_sleep = pthread_sleep_next) == NULL) {
			/* No more threads on sleep queue */
			return(ret);
a128 6
	} while (sleep_compare_time(&(pthread_sleep->wakeup_time), &(current_time)) <= 0);
		
	/* Start timer for next time interval */
	machdep_start_timer(&current_time, &(pthread_sleep->wakeup_time));
	return(ret);
}
d130 2
a131 28

/* ==========================================================================
 * __sleep()
 */
void __sleep(struct timespec * time_to_sleep)
{
	struct pthread *pthread_sleep_prev;
	struct timespec current_time, wakeup_time;

	pthread_sched_prevent();

	/* Get real time */
	machdep_gettimeofday(&current_time);
	wakeup_time.tv_sec = current_time.tv_sec + time_to_sleep->tv_sec;
	wakeup_time.tv_nsec = current_time.tv_nsec + time_to_sleep->tv_nsec;

	sleep_schedule(&current_time, &wakeup_time);

	/* Reschedule thread */
	SET_PF_WAIT_EVENT(pthread_run);
	SET_PF_AT_CANCEL_POINT(pthread_run); /* This is a cancel point */
	pthread_resched_resume(PS_SLEEP_WAIT);
	CLEAR_PF_AT_CANCEL_POINT(pthread_run); /* No longer at cancel point */
	CLEAR_PF_DONE_EVENT(pthread_run);

	/* Return actual time slept */
	time_to_sleep->tv_sec = pthread_run->wakeup_time.tv_sec;
	time_to_sleep->tv_nsec = pthread_run->wakeup_time.tv_nsec;
d135 5
a139 1
 * pthread_nanosleep()
d141 1
a141 1
unsigned int pthread_nanosleep(unsigned int nseconds)
d143 2
a144 1
	struct timespec time_to_sleep;
d146 4
a149 5
	if (nseconds) {
		time_to_sleep.tv_nsec = nseconds;
		time_to_sleep.tv_sec = 0;
		__sleep(&time_to_sleep);
		nseconds = time_to_sleep.tv_nsec;
a150 2
	return(nseconds);
}
d152 5
a156 6
/* ==========================================================================
 * usleep()
 */
void usleep(unsigned int useconds)
{
	struct timespec time_to_sleep;
d158 2
a159 5
	if (useconds) {
		time_to_sleep.tv_nsec = (useconds % 1000000) * 1000;
		time_to_sleep.tv_sec = useconds / 1000000;
		__sleep(&time_to_sleep);
	}
d167 3
a169 1
	struct timespec time_to_sleep;
d172 5
a176 7
		time_to_sleep.tv_sec = seconds;
		time_to_sleep.tv_nsec = 0;
		__sleep(&time_to_sleep);
		seconds = time_to_sleep.tv_sec;
	}
	return(seconds);
}
d178 11
a188 14
/* ==========================================================================
 * sleep_cancel()
 *
 * Cannot be called while kernel is locked.
 * Does not wake sleeping thread up, just remove it from the sleep queue.
 */
int sleep_cancel(struct pthread * pthread)
{
	struct timespec current_time, delta_time;
	struct pthread * pthread_last;
	int rval = NOTOK;

	/* Lock sleep queue, Note this may be on a different kthread queue */
	pthread_sched_prevent();
d190 46
a235 15
	if (pthread_sleep) {
		if (pthread == pthread_sleep) {
			rval = OK;
			machdep_stop_timer(&delta_time);
			if (pthread_sleep = pthread_sleep->sll) {
				current_time.tv_sec 	= delta_time.tv_sec;
				current_time.tv_nsec 	= delta_time.tv_nsec;
				current_time.tv_sec 	+= pthread_sleep->wakeup_time.tv_sec;
				current_time.tv_nsec 	+= pthread_sleep->wakeup_time.tv_nsec;
				while (current_time.tv_nsec > 1000000000) {
					current_time.tv_nsec -= 1000000000;
					current_time.tv_sec++;
				}
				machdep_start_timer(&(current_time), 
									&(pthread_sleep->wakeup_time));
d238 4
a241 8
			for (pthread_last = pthread_sleep; pthread_last;
				 pthread_last = pthread_last->sll) {
				if (pthread_last->sll == pthread) {
					pthread_last->sll = pthread->sll;
					rval = OK;
					break;
				}
			}
d243 10
d254 2
a256 4
	pthread_sched_resume();
	pthread->sll = NULL;
	return(rval);
}
@

