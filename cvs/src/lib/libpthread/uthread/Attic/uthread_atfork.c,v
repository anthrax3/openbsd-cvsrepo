head	1.4;
access;
symbols
	OPENBSD_5_2:1.3.0.28
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.26
	OPENBSD_5_0:1.3.0.24
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.22
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.20
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.16
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.18
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.14
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.12
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.10
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.8
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.6
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.2
	OPENBSD_3_9_BASE:1.3
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.09.01.00.32.23;	author guenther;	state dead;
branches;
next	1.3;

1.3
date	2005.10.30.03.37.34;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	99.06.15.00.07.39;	author d;	state dead;
branches;
next	1.1;

1.1
date	99.01.17.23.46.26;	author d;	state Exp;
branches;
next	;


desc
@@


1.4
log
@   So passes uthreads
Like autumn leaves on water
   don't fear the tedu@@
@
text
@/*	$OpenBSD: uthread_atfork.c,v 1.3 2005/10/30 03:37:34 brad Exp $	*/

/*
 * Copyright (c) 2003 Daniel Eischen <deischen@@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: /repoman/r/ncvs/src/lib/libc_r/uthread/uthread_atfork.c,v 1.1 2004/12/10 03:36:45 grog Exp $
 */

#include <errno.h>
#include <stdlib.h>
#ifdef _THREAD_SAFE
#include <pthread.h>
#include <sys/queue.h>
#include "pthread_private.h"

int
pthread_atfork(void (*prepare)(void), void (*parent)(void),
    void (*child)(void))
{
	struct pthread_atfork *af;

	if (_thread_initial == NULL)
		_thread_init();

	if ((af = malloc(sizeof(struct pthread_atfork))) == NULL)
		return (ENOMEM);

	af->prepare = prepare;
	af->parent = parent;
	af->child = child;
	pthread_mutex_lock(&_atfork_mutex);
	TAILQ_INSERT_TAIL(&_atfork_list, af, qe);
	pthread_mutex_unlock(&_atfork_mutex);
	return (0);
}
#endif
@


1.3
log
@Add pthread_atfork(3)

From FreeBSD

'looks ok' fgsch@@ miod@@
man page reviewed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@Remove pthread_atfork(). It was only part of draft 10 for a little while and was removed before stddization.
@
text
@d1 2
d4 25
a28 2
 * David Leonard <d@@openbsd.org>, 1999. Public domain.
 * $OpenBSD: uthread_atfork.c,v 1.1 1999/01/17 23:46:26 d Exp $
d31 1
a32 1
#include <sys/queue.h>
d35 1
d38 3
a40 12
struct atfork_entry {
	void (*handler)(void);
	TAILQ_ENTRY(atfork_entry) entries;
};

static TAILQ_HEAD(atfork_list, atfork_entry) atfork_head[3] =
	{ TAILQ_HEAD_INITIALIZER(atfork_head[PTHREAD_ATFORK_PREPARE]),
	  TAILQ_HEAD_INITIALIZER(atfork_head[PTHREAD_ATFORK_PARENT]),
	  TAILQ_HEAD_INITIALIZER(atfork_head[PTHREAD_ATFORK_CHILD]) };

void
_thread_atfork(which)
d42 1
a42 4
	struct atfork_list *head;
	struct atfork_entry *ae;

	head = &atfork_head[which];
d44 2
a45 4
	/* Call the fork handlers in order: */
	for (ae = head->tqh_first; ae != NULL; ae = ae->entries.tqe_next)
		(*ae->handler)();
}
d47 2
a48 55
int
pthread_atfork(prepare, parent, child)
	void (*prepare)(void);
	void (*parent)(void);
	void (*child)(void);
{
	int ret = 0;
	struct atfork_entry *prepare_entry = NULL;
	struct atfork_entry *parent_entry = NULL;
	struct atfork_entry *child_entry = NULL;

	if (ret == 0 && prepare != NULL) {
		/* Allocate space for the prepare handler: */
	        if ((prepare_entry = malloc(sizeof *prepare_entry)) != NULL)
			prepare_entry->handler = prepare;
	        else
			ret = -1;
	}

	if (ret == 0 && parent != NULL) {
		/* Allocate space for the parent handler: */
	        if ((parent_entry = malloc(sizeof *parent_entry)) != NULL)
			parent_entry->handler = parent;
	        else
			ret = -1;
	}

	if (ret == 0 && child != NULL) {
		/* Allocate space for the child handler: */
	        if ((child_entry = malloc(sizeof *child_entry)) != NULL)
			child_entry->handler = child;
	        else
			ret = -1;
	}

	if (ret == 0) {
		/* Insert the handlers into the handler lists: */
		if (prepare_entry != NULL)
			TAILQ_INSERT_HEAD(&atfork_head[PTHREAD_ATFORK_PREPARE],
			    prepare_entry, entries);
		if (parent_entry != NULL)
			TAILQ_INSERT_TAIL(&atfork_head[PTHREAD_ATFORK_PARENT],
			    parent_entry, entries);
		if (child_entry != NULL)
			TAILQ_INSERT_TAIL(&atfork_head[PTHREAD_ATFORK_CHILD],
			    child_entry, entries);
	} else {
		/* Release unused resources: */
		if (prepare_entry)
			free(prepare_entry);
		if (child_entry)
			free(child_entry);
		if (parent_entry)
			free(parent_entry);
	}
d50 7
a56 1
	return (ret);
@


1.1
log
@pthread_atfork()
@
text
@d3 1
a3 1
 * $OpenBSD$
@

