head	1.8;
access;
symbols
	OPENBSD_5_2:1.7.0.10
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.10
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.12
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.8
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.6
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.4
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.8
date	2012.09.01.00.32.23;	author guenther;	state dead;
branches;
next	1.7;

1.7
date	2010.04.12.01.54.23;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.18.19.28.50;	author kurt;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.01.06.22.14;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.07.05.17.15;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	99.11.25.07.01.42;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.12.23.22.49.46;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.11.09.03.13.20;	author d;	state Exp;
branches;
next	;


desc
@@


1.8
log
@   So passes uthreads
Like autumn leaves on water
   don't fear the tedu@@
@
text
@/*	$OpenBSD: uthread_rwlock.c,v 1.7 2010/04/12 01:54:23 tedu Exp $	*/
/*-
 * Copyright (c) 1998 Alex Nash
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: uthread_rwlock.c,v 1.9 2004/01/08 15:39:12 deischen Exp $
 */

#ifdef _THREAD_SAFE
#include <errno.h>
#include <limits.h>
#include <stdlib.h>

#include <pthread.h>
#include "pthread_private.h"

/* maximum number of times a read lock may be obtained */
#define	MAX_READ_LOCKS		(INT_MAX - 1)

static int init_static (pthread_rwlock_t *rwlock);

static spinlock_t static_init_lock = _SPINLOCK_INITIALIZER;

static int
init_static (pthread_rwlock_t *rwlock)
{
	int ret;

	_SPINLOCK(&static_init_lock);

	if (*rwlock == NULL)
		ret = pthread_rwlock_init(rwlock, NULL);
	else
		ret = 0;

	_SPINUNLOCK(&static_init_lock);

	return (ret);
}

int
pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
{
	int ret;

	if (rwlock == NULL)
		ret = EINVAL;
	else {
		pthread_rwlock_t prwlock;

		prwlock = *rwlock;

		pthread_mutex_destroy(&prwlock->lock);
		pthread_cond_destroy(&prwlock->read_signal);
		pthread_cond_destroy(&prwlock->write_signal);
		free(prwlock);

		*rwlock = NULL;

		ret = 0;
	}
	return (ret);
}

/* ARGSUSED */
int
pthread_rwlock_init (pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr)
{
	pthread_rwlock_t prwlock;
	int ret;

	/* allocate rwlock object */
	prwlock = (pthread_rwlock_t)malloc(sizeof(struct pthread_rwlock));

	if (prwlock == NULL)
		return(ENOMEM);

	/* initialize the lock */
	if ((ret = pthread_mutex_init(&prwlock->lock, NULL)) != 0)
		free(prwlock);
	else {
		/* initialize the read condition signal */
		ret = pthread_cond_init(&prwlock->read_signal, NULL);

		if (ret != 0) {
			pthread_mutex_destroy(&prwlock->lock);
			free(prwlock);
		} else {
			/* initialize the write condition signal */
			ret = pthread_cond_init(&prwlock->write_signal, NULL);

			if (ret != 0) {
				pthread_cond_destroy(&prwlock->read_signal);
				pthread_mutex_destroy(&prwlock->lock);
				free(prwlock);
			} else {
				/* success */
				prwlock->state = 0;
				prwlock->blocked_writers = 0;

				*rwlock = prwlock;
			}
		}
	}

	return (ret);
}

static int
rwlock_rdlock_common (pthread_rwlock_t *rwlock, const struct timespec *abstime)
{
	pthread_rwlock_t prwlock;
	struct pthread *curthread;
	int ret;

	if (rwlock == NULL)
		return(EINVAL);

	prwlock = *rwlock;

	/* check for static initialization */
	if (prwlock == NULL) {
		if ((ret = init_static(rwlock)) != 0)
			return(ret);

		prwlock = *rwlock;
	}

	/* grab the monitor lock */
	if ((ret = pthread_mutex_lock(&prwlock->lock)) != 0)
		return(ret);

	/* check lock count */
	if (prwlock->state == MAX_READ_LOCKS) {
		pthread_mutex_unlock(&prwlock->lock);
		return (EAGAIN);
	}

	curthread = _get_curthread();
	if ((curthread->rdlock_count > 0) && (prwlock->state > 0)) {
		/*
		 * To avoid having to track all the rdlocks held by
		 * a thread or all of the threads that hold a rdlock,
		 * we keep a simple count of all the rdlocks held by
		 * a thread.  If a thread holds any rdlocks it is
		 * possible that it is attempting to take a recursive
		 * rdlock.  If there are blocked writers and precedence
		 * is given to them, then that would result in the thread
		 * deadlocking.  So allowing a thread to take the rdlock
		 * when it already has one or more rdlocks avoids the
		 * deadlock.  I hope the reader can follow that logic ;-)
		 */
		;	/* nothing needed */
	} else {
		/* give writers priority over readers */
		while (prwlock->blocked_writers || prwlock->state < 0) {
			if (abstime) {
				ret = pthread_cond_timedwait(&prwlock->read_signal,
					&prwlock->lock, abstime);
			} else {
				ret = pthread_cond_wait(&prwlock->read_signal,
					&prwlock->lock);
			}

			if (ret != 0) {
				/* can't do a whole lot if this fails */
				pthread_mutex_unlock(&prwlock->lock);
				return(ret);
			}
		}
	}

	curthread->rdlock_count++;
	prwlock->state++; /* indicate we are locked for reading */

	/*
	 * Something is really wrong if this call fails.  Returning
	 * error won't do because we've already obtained the read
	 * lock.  Decrementing 'state' is no good because we probably
	 * don't have the monitor lock.
	 */
	pthread_mutex_unlock(&prwlock->lock);

	return (ret);
}

int
pthread_rwlock_rdlock (pthread_rwlock_t *rwlock)
{
	return rwlock_rdlock_common (rwlock, NULL);
}

int
pthread_rwlock_timedrdlock (pthread_rwlock_t *rwlock,
	 const struct timespec *abstime)
{
	return rwlock_rdlock_common(rwlock, abstime);
}

int
pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock)
{
	pthread_rwlock_t prwlock;
	struct pthread *curthread;
	int ret;

	if (rwlock == NULL)
		return(EINVAL);

	prwlock = *rwlock;

	/* check for static initialization */
	if (prwlock == NULL) {
		if ((ret = init_static(rwlock)) != 0)
			return(ret);

		prwlock = *rwlock;
	}

	/* grab the monitor lock */
	if ((ret = pthread_mutex_lock(&prwlock->lock)) != 0)
		return(ret);

	curthread = _get_curthread();
	if (prwlock->state == MAX_READ_LOCKS)
		ret = EAGAIN; /* too many read locks acquired */
	else if ((curthread->rdlock_count > 0) && (prwlock->state > 0)) {
		/* see comment for pthread_rwlock_rdlock() */
		curthread->rdlock_count++;
		prwlock->state++;
	}
	/* give writers priority over readers */
	else if (prwlock->blocked_writers || prwlock->state < 0)
		ret = EBUSY;
	else {
		prwlock->state++; /* indicate we are locked for reading */
		curthread->rdlock_count++;
	}

	/* see the comment on this in pthread_rwlock_rdlock */
	pthread_mutex_unlock(&prwlock->lock);

	return (ret);
}

int
pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock)
{
	pthread_rwlock_t prwlock;
	int ret;

	if (rwlock == NULL)
		return(EINVAL);

	prwlock = *rwlock;

	/* check for static initialization */
	if (prwlock == NULL) {
		if ((ret = init_static(rwlock)) != 0)
			return(ret);

		prwlock = *rwlock;
	}

	/* grab the monitor lock */
	if ((ret = pthread_mutex_lock(&prwlock->lock)) != 0)
		return(ret);

	if (prwlock->state != 0)
		ret = EBUSY;
	else
		/* indicate we are locked for writing */
		prwlock->state = -1;

	/* see the comment on this in pthread_rwlock_rdlock */
	pthread_mutex_unlock(&prwlock->lock);

	return (ret);
}

int
pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
{
	pthread_rwlock_t prwlock;
	struct pthread *curthread;
	int ret;

	if (rwlock == NULL)
		return(EINVAL);

	prwlock = *rwlock;

	if (prwlock == NULL)
		return(EINVAL);

	/* grab the monitor lock */
	if ((ret = pthread_mutex_lock(&prwlock->lock)) != 0)
		return(ret);

	curthread = _get_curthread();
	if (prwlock->state > 0) {
		curthread->rdlock_count--;
		prwlock->state--;
		if (prwlock->state == 0 && prwlock->blocked_writers)
			ret = pthread_cond_signal(&prwlock->write_signal);
	} else if (prwlock->state < 0) {
		prwlock->state = 0;

		if (prwlock->blocked_writers)
			ret = pthread_cond_signal(&prwlock->write_signal);
		else
			ret = pthread_cond_broadcast(&prwlock->read_signal);
	} else
		ret = EINVAL;

	/* see the comment on this in pthread_rwlock_rdlock */
	pthread_mutex_unlock(&prwlock->lock);

	return (ret);
}

static int
rwlock_wrlock_common (pthread_rwlock_t *rwlock, const struct timespec *abstime)
{
	pthread_rwlock_t prwlock;
	int ret;

	if (rwlock == NULL)
		return(EINVAL);

	prwlock = *rwlock;

	/* check for static initialization */
	if (prwlock == NULL) {
		if ((ret = init_static(rwlock)) != 0)
			return(ret);

		prwlock = *rwlock;
	}

	/* grab the monitor lock */
	if ((ret = pthread_mutex_lock(&prwlock->lock)) != 0)
		return(ret);

	while (prwlock->state != 0) {
		prwlock->blocked_writers++;

		if (abstime != NULL) {
			ret = pthread_cond_timedwait(&prwlock->write_signal,
				&prwlock->lock, abstime);
		} else {
			ret = pthread_cond_wait(&prwlock->write_signal,
				&prwlock->lock);
		}

		if (ret != 0) {
			prwlock->blocked_writers--;
			pthread_mutex_unlock(&prwlock->lock);
			return(ret);
		}

		prwlock->blocked_writers--;
	}

	/* indicate we are locked for writing */
	prwlock->state = -1;

	/* see the comment on this in pthread_rwlock_rdlock */
	pthread_mutex_unlock(&prwlock->lock);

	return (ret);
}

int
pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
{
	return rwlock_wrlock_common (rwlock, NULL);
}

int
pthread_rwlock_timedwrlock (pthread_rwlock_t *rwlock,
	const struct timespec *abstime)
{
	return rwlock_wrlock_common (rwlock, abstime);
}

#endif /* _THREAD_SAFE */
@


1.7
log
@Add support for pthread_rwlock_timed locks.
from brad.  ok kurt, who's too busy to commit
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_rwlock.c,v 1.6 2007/05/18 19:28:50 kurt Exp $	*/
@


1.6
log
@Eliminate many lint warnings by either: using the appropriate type,
casting when safe or adding ARGSUSED where needed. Reviewed and
improvements from millert@@ and marc@@. okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_rwlock.c,v 1.5 2004/02/01 06:22:14 brad Exp $	*/
d130 2
a131 2
int
pthread_rwlock_rdlock (pthread_rwlock_t *rwlock)
d178 7
a184 2
			ret = pthread_cond_wait(&prwlock->read_signal,
			    &prwlock->lock);
d209 13
d343 2
a344 2
int
pthread_rwlock_wrlock (pthread_rwlock_t *rwlock)
d369 7
a375 2
		ret = pthread_cond_wait(&prwlock->write_signal,
		    &prwlock->lock);
d393 13
@


1.5
log
@Add a simple work-around for deadlocking on recursive
readlocks on a rwlock while there are writers waiting.

From: FreeBSD's libc_r

ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_rwlock.c,v 1.4 2002/05/07 05:17:15 pvalchev Exp $	*/
d86 1
@


1.4
log
@return EBUSY, not EWOULDBLOCK for error when calling thread would block
for pthread_rwlock_wrlock & sie says Single Unix Specification; ok fgs
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_rwlock.c,v 1.3 1999/11/25 07:01:42 d Exp $	*/
d27 1
a27 1
 * $FreeBSD: uthread_rwlock.c,v 1.4 1999/08/28 00:03:45 peter Exp $
d59 1
a59 1
	return(ret);
d83 1
a83 2

	return(ret);
d89 2
a90 2
	pthread_rwlock_t	prwlock;
	int			ret;
d118 1
a118 1
				prwlock->state		 = 0;
d126 1
a126 1
	return(ret);
d132 3
a134 2
	pthread_rwlock_t 	prwlock;
	int			ret;
d153 26
a178 3
	/* give writers priority over readers */
	while (prwlock->blocked_writers || prwlock->state < 0) {
		ret = pthread_cond_wait(&prwlock->read_signal, &prwlock->lock);
d180 5
a184 4
		if (ret != 0) {
			/* can't do a whole lot if this fails */
			pthread_mutex_unlock(&prwlock->lock);
			return(ret);
d188 2
a189 5
	/* check lock count */
	if (prwlock->state == MAX_READ_LOCKS)
		ret = EAGAIN;
	else
		++prwlock->state; /* indicate we are locked for reading */
d199 1
a199 1
	return(ret);
d205 3
a207 2
	pthread_rwlock_t 	prwlock;
	int			ret;
d226 8
d235 1
a235 1
	if (prwlock->blocked_writers || prwlock->state < 0)
d237 4
a240 4
	else if (prwlock->state == MAX_READ_LOCKS)
		ret = EAGAIN; /* too many read locks acquired */
	else
		++prwlock->state; /* indicate we are locked for reading */
d245 1
a245 1
	return(ret);
d251 2
a252 2
	pthread_rwlock_t 	prwlock;
	int			ret;
d280 1
a280 1
	return(ret);
d286 3
a288 2
	pthread_rwlock_t 	prwlock;
	int			ret;
d302 1
d304 3
a306 1
		if (--prwlock->state == 0 && prwlock->blocked_writers)
d321 1
a321 1
	return(ret);
d327 2
a328 2
	pthread_rwlock_t 	prwlock;
	int			ret;
d348 1
a348 1
		++prwlock->blocked_writers;
d350 2
a351 1
		ret = pthread_cond_wait(&prwlock->write_signal, &prwlock->lock);
d354 1
a354 1
			--prwlock->blocked_writers;
d359 1
a359 1
		--prwlock->blocked_writers;
d368 1
a368 1
	return(ret);
@


1.3
log
@sync with FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d206 1
a206 1
		ret = EWOULDBLOCK;
d242 1
a242 1
		ret = EWOULDBLOCK;
@


1.2
log
@preserve FreeBSD idents
@
text
@d1 1
d27 1
a27 2
 *	$FreeBSD: uthread_rwlock.c,v 1.3 1998/09/07 21:07:59 alex Exp $
 *	$OpenBSD: uthread_rwlock.c,v 1.1 1998/11/09 03:13:20 d Exp $
@


1.1
log
@sync with FreeBSD (rwlock, gc thread, man pages)
add (broken) mips md stuff
fix some const warnings
add sigaltstack() stub
another hash at getting shlib auto-init to work (mips/elf and i386/a.out)
@
text
@d26 2
a27 2
 *	$OpenBSD$
 *	$Id: uthread_rwlock.c,v 1.3 1998/09/07 21:07:59 alex Exp $
@

