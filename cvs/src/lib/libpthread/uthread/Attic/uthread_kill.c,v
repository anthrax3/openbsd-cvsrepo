head	1.13;
access;
symbols
	OPENBSD_5_2:1.12.0.24
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.22
	OPENBSD_5_0:1.12.0.20
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.18
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.16
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.12
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.14
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.10
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.8
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.6
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10;
locks; strict;
comment	@ * @;


1.13
date	2012.09.01.00.32.23;	author guenther;	state dead;
branches;
next	1.12;

1.12
date	2007.01.28.16.47.41;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.30.17.54.17;	author marc;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.31.04.46.17;	author marc;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2003.01.27.22.22.30;	author marc;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.30.19.11.56;	author marc;	state Exp;
branches;
next	1.7;

1.7
date	99.11.25.07.01.37;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.05.26.00.18.24;	author d;	state Exp;
branches;
next	1.5;

1.5
date	99.01.06.05.29.24;	author d;	state Exp;
branches;
next	1.4;

1.4
date	98.12.10.00.40.19;	author d;	state Exp;
branches;
next	1.3;

1.3
date	98.11.20.12.13.32;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.11.09.03.13.20;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.08.27.09.01.08;	author d;	state Exp;
branches;
next	;

1.10.2.1
date	2003.05.13.04.57.38;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.13
log
@   So passes uthreads
Like autumn leaves on water
   don't fear the tedu@@
@
text
@/* $OpenBSD: uthread_kill.c,v 1.12 2007/01/28 16:47:41 kettenis Exp $ */
/* PUBLIC_DOMAIN <marc@@snafu.org> */

#include <errno.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#ifdef _THREAD_SAFE
#include <pthread.h>

#include "pthread_private.h"

/*
 * Fake up a minimal siginfo_t for the given signal unless one is already
 * pending. The signal number is assumed to be valid.
 */
void
_thread_kill_siginfo(int sig)
{
	struct sigstatus *ss = &_thread_sigq[sig - 1];

	_SPINLOCK(&ss->lock);
	if (ss->pending == 0) {
		ss->pending = 1;
		memset(&ss->siginfo, 0, sizeof ss->siginfo);
		ss->siginfo.si_signo = sig;
		ss->siginfo.si_code = SI_USER;
		ss->siginfo.si_errno = errno;
		ss->siginfo.si_pid = getpid();
	}
	_SPINUNLOCK(&ss->lock);
}

/*
 * Validate the signal number and thread.  If valid process the signal.
 */
int
pthread_kill(pthread_t pthread, int sig)
{
	int ret;

	if (sig >= 0 && sig < NSIG) {
		ret = _find_thread(pthread);
		if (ret == 0 && sig != 0) {
			if (_thread_sigact[sig - 1].sa_handler != SIG_IGN) {
				_thread_kern_sig_defer();
				if (pthread->state == PS_SIGWAIT &&
				    sigismember(pthread->data.sigwait, sig)) {
					PTHREAD_NEW_STATE(pthread,PS_RUNNING);
					pthread->signo = sig;
				} else {
					_thread_kill_siginfo(sig);
					_thread_signal(pthread,sig);
				}
				_thread_kern_sig_undefer();
			}
		}
	} else
		ret = EINVAL;

	return ret;
}
#endif
@


1.12
log
@Return ESRCH instead of segfaulting when a thread ID could not be found.

ok marc@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: uthread_kill.c,v 1.11 2003/04/30 17:54:17 marc Exp $ */
@


1.11
log
@fix for pr# 3179 and 3238.   Patch verified by author of 3179.
@
text
@d1 1
a1 1
/* $OpenBSD: uthread_kill.c,v 1.10 2003/01/31 04:46:17 marc Exp $ */
d44 1
a44 1
		if (sig != 0) {
@


1.10
log
@
Create a siginfo_t for thread-to-thread kill.
Clean up (compiler warning elimination).   Compile check options added
but commented out as they have not been checked on all architectures, yet.
@
text
@d1 1
a1 1
/* $OpenBSD: uthread_kill.c,v 1.9 2003/01/27 22:22:30 marc Exp $ */
d46 1
d55 1
@


1.10.2.1
log
@Pull patch from -current:
Fixes a pthread issue noticed by several users reports regarding
mysql crashing unexpectedly.
PR# 3179 adn 3238

marc@@ millert@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: uthread_kill.c,v 1.10 2003/01/31 04:46:17 marc Exp $ */
a45 1
				_thread_kern_sig_defer();
a53 1
				_thread_kern_sig_undefer();
@


1.9
log
@pthreads signal handling improvements.   With these changes all
of the thread regressions tests pass on i386, sparc, sparc64
(save the siginfo test on sparc64 due to a kernel issue) and alpha.
The tests should also pass on ppc.

In addition, it fixes the problems with the "mysql torture test"
provided by one of our users.   The python port also appears to
work correctly with these changes.

Summary of changes:

* check_pending removed from thread structure, no longer used.
* unused elements of sigstatus structure removed.   The sigstatus
  structure is now used to keep track of siginfo data instead of
  defining a local array in uthread_sig.c.
* _thread_kern_sched_sig removed
* _thread_sig_process goes away -- can't have a lock active when
  signal handlers are called.   Functions now call _thread_sig_handle
  directly.
* _thread_clear_pending now used lib wide to clear pending flags.
  It was named _clean_pending_flag and only used in uthread_sig.c.
  The function clears both per thread signals, and per process signals.
* _thread_sig_handle now returns a value.
* unused debugging macros removed from the thread kernel
* dispatch pending signals after switching to a thread providing
  that signal handling hasn't been deferred by the thread.
* process thread switchhooks before dispatching pending sigs
* check for thread cancellation before dispatching pending sigs
* re-wrote pthread-kill to do the correct thing.   It now does
  minimal thread-kill-specific processing and then calls the
  existing code in uthread_sig to process the generated signal.
* shut the compiler up when compiling uthread_mutex.c
* no more "signal_lock".   It does more harm than good.
* keep track of "per-process" signals.
* don't bother saving siginfo_t data for the scheduling signal.
* per posix: SIGSTOP cleared when SIGCONT received and vice versa.
* add _dispatch_signal to properly dispatch a signal to a thread.
  It sets the appropriate signal mask, something that was missing
  in the previous implementation.   This fixes several bugs.
  The previous method held a lock.  If the signal handler longjmp-ed
  the lock was never cleared and no more signals were processed.
@
text
@d1 1
a1 1
/* $OpenBSD: uthread_kill.c,v 1.8 2002/10/30 19:11:56 marc Exp $ */
d6 2
d10 1
d14 21
a35 1
 * ;;; need to fake up a siginfo_t and put it in the queue for this signal.
d50 2
a51 1
				} else
d53 1
@


1.8
log
@signal handling changes.   This corrects several signal
handling errors in the threads library.   Most of the libc_r regression
tests are now ok.   thread specific kill semantics are still not correct.
No negative comments after posting to tech@@ a week or so ago.
siginfo test fails on sparc64 due to sparc64 oddity.
@
text
@d1 3
a3 34
/*	$OpenBSD: uthread_kill.c,v 1.7 1999/11/25 07:01:37 d Exp $	*/
/*
 * Copyright (c) 1997 John Birrell <jb@@cimlogic.com.au>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John Birrell.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: uthread_kill.c,v 1.9 1999/08/28 00:03:38 peter Exp $
 */
d11 2
a12 4
 * XXX THIS IS WRONG! The signal has to either come through the OS to
 * get the proper siginfo, context, etc., or we need to gen up a
 * siginfo (assuming needed).   Signal reset and other semantics
 * also need to be obeyed.
d19 10
a28 67
	/* Check for invalid signal numbers: */
	if (sig < 0 || sig >= NSIG)
		/* Invalid signal: */
		ret = EINVAL;

	/*
	 * Ensure the thread is in the list of active threads, and the
	 * signal is valid (signal 0 specifies error checking only) and
	 * not being ignored:
	 */
	else if (((ret = _find_thread(pthread)) == 0) && (sig > 0) &&
	    (_thread_sigact[sig - 1].sa_handler != SIG_IGN)) {
		/*
		 * Defer signals to protect the scheduling queues from
		 * access by the signal handler:
		 */
		_thread_kern_sig_defer();

		switch (pthread->state) {
		case PS_SIGSUSPEND:
			/*
			 * Only wake up the thread if the signal is unblocked
			 * and there is a handler installed for the signal.
			 */
			if (!sigismember(&pthread->sigmask, sig) &&
			    _thread_sigact[sig - 1].sa_handler != SIG_DFL) {
				/* Change the state of the thread to run: */
				PTHREAD_NEW_STATE(pthread,PS_RUNNING);

				/* Return the signal number: */
				pthread->signo = sig;
			}
			sigaddset(&pthread->sigpend,sig);
			break;

		case PS_SIGWAIT:
			/* Wake up the thread if the signal is blocked. */
			if (sigismember(pthread->data.sigwait, sig)) {
				/* Change the state of the thread to run: */
				PTHREAD_NEW_STATE(pthread,PS_RUNNING);

				/* Return the signal number: */
				pthread->signo = sig;
			} else
				sigaddset(&pthread->sigpend,sig);
			break;

		case PS_FDR_WAIT:
		case PS_FDW_WAIT:
		case PS_POLL_WAIT:
		case PS_SLEEP_WAIT:
		case PS_SELECT_WAIT:
			if (!sigismember(&pthread->sigmask, sig) &&
			    (_thread_sigact[sig - 1].sa_handler != SIG_IGN)) {
				/* Flag the operation as interrupted: */
				pthread->interrupted = 1;

				if (pthread->flags & PTHREAD_FLAGS_IN_WORKQ)
					PTHREAD_WORKQ_REMOVE(pthread);

				/* Change the state of the thread to run: */
				PTHREAD_NEW_STATE(pthread,PS_RUNNING);

				/* Return the signal number: */
				pthread->signo = sig;
			} else {
				sigaddset(&pthread->sigpend,sig);
a29 6
			break;

		default:
			/* Increment the pending signal count: */
			sigaddset(&pthread->sigpend,sig);
			break;
d31 2
d34 1
a34 41

		/*
		 * Check that a custom handler is installed
		 * and if the signal is not blocked:
		 */
		if (_thread_sigact[sig - 1].sa_handler != SIG_DFL &&
		    _thread_sigact[sig - 1].sa_handler != SIG_IGN &&
		    sigismember(&pthread->sigpend, sig) &&
		    !sigismember(&pthread->sigmask, sig)) {
			pthread_t pthread_saved = _thread_run;

			/* Current thread inside critical region? */
			if (_thread_run->sig_defer_count > 0)
				pthread->sig_defer_count++;

			_thread_run = pthread;

			/* Clear the pending signal: */
			sigdelset(&pthread->sigpend, sig);

			/*
			 * Dispatch the signal via the custom signal
			 * handler: ;;; what about SA_SIGINFO???
			 */
			(*(_thread_sigact[sig - 1].sa_handler))(sig);

			_thread_run = pthread_saved;

			if (_thread_run->sig_defer_count > 0)
				pthread->sig_defer_count--;
		}

		/*
		 * Undefer and handle pending signals, yielding if
		 * necessary:
		 */
		_thread_kern_sig_undefer();
	}

	/* Return the completion status: */
	return (ret);
@


1.7
log
@sync with FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 6
a83 1
			/* Increment the pending signal count: */
a95 1
				/* Increment the pending signal count. */
a117 1
				/* Increment the pending signal count: */
d150 1
a150 1
			 * handler:
@


1.6
log
@sync with FreeBSD
@
text
@d24 1
a24 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d33 1
d51 7
a57 6
	/* Ignored signals get dropped on the floor. */
	else if (_thread_sigact[sig - 1].sa_handler == SIG_IGN)
		ret = 0;

	/* Find the thread in the list of active threads: */
	else if ((ret = _find_thread(pthread)) == 0) {
d59 2
a60 3
		 * Guard against preemption by a scheduling signal.
		 * A change of thread state modifies the waiting
		 * and priority queues.
d62 1
a62 1
		_thread_kern_sched_defer();
a94 1
		case PS_SELECT_WAIT:
d97 1
d99 1
d105 3
d125 32
d158 2
a159 2
		 * Reenable preemption and yield if a scheduling signal
		 * occurred while in the critical region.
d161 1
a161 1
		_thread_kern_sched_undefer();
@


1.5
log
@ident
@
text
@d1 1
a32 1
 * $OpenBSD$
d56 7
d119 6
@


1.4
log
@sync with FreeBSD
@
text
@d32 1
@


1.3
log
@sync with freebsd
@
text
@d94 1
a94 1
 
d97 1
a97 1
 
@


1.2
log
@sync with FreeBSD (rwlock, gc thread, man pages)
add (broken) mips md stuff
fix some const warnings
add sigaltstack() stub
another hash at getting shlib auto-init to work (mips/elf and i386/a.out)
@
text
@d86 20
@


1.1
log
@experimental threaded libc - kernel only
@
text
@d49 4
d55 30
a84 4
		if ((pthread->state == PS_SIGWAIT) &&
		    sigismember(&pthread->sigmask, sig)) {
			/* Change the state of the thread to run: */
			PTHREAD_NEW_STATE(pthread,PS_RUNNING);
d86 1
a86 3
			/* Return the signal number: */
			pthread->signo = sig;
		} else
d89 2
@

