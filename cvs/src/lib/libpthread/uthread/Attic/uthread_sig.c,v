head	1.29;
access;
symbols
	OPENBSD_5_2:1.28.0.4
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.2
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.12
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.8
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.20.0.14
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.12
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.10
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19;
locks; strict;
comment	@ * @;


1.29
date	2012.09.01.00.32.24;	author guenther;	state dead;
branches;
next	1.28;

1.28
date	2011.10.07.08.59.43;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2011.09.13.23.56.00;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.13.03.10.29;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.03.23.05.35;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.18.19.28.50;	author kurt;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.27.12.59.24;	author kurt;	state Exp;
branches;
next	1.22;

1.22
date	2006.09.26.14.18.28;	author kurt;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.22.19.04.33;	author kurt;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.30.17.54.17;	author marc;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.31.04.46.17;	author marc;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2003.01.27.22.22.30;	author marc;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.24.21.03.15;	author marc;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.08.23.18.25;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.02.23.52.46;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.30.19.11.56;	author marc;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.07.22.36.04;	author marc;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.31.18.23.15;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.18.03.47.52;	author marc;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.05.22.53.28;	author marc;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.02.20.37.20;	author marc;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.21.19.24.53;	author fgsch;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.01.06.07.20.52;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.11.25.07.01.44;	author d;	state Exp;
branches;
next	1.5;

1.5
date	99.05.26.00.18.26;	author d;	state Exp;
branches;
next	1.4;

1.4
date	99.01.06.05.29.27;	author d;	state Exp;
branches;
next	1.3;

1.3
date	98.12.21.07.42.54;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.11.09.03.13.20;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.08.27.09.01.20;	author d;	state Exp;
branches;
next	;

1.8.2.1
date	2002.07.26.19.00.42;	author miod;	state Exp;
branches;
next	;

1.19.2.1
date	2003.05.13.04.57.38;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.29
log
@   So passes uthreads
Like autumn leaves on water
   don't fear the tedu@@
@
text
@/*	$OpenBSD: uthread_sig.c,v 1.28 2011/10/07 08:59:43 fgsch Exp $	*/
/*
 * Copyright (c) 1995-1998 John Birrell <jb@@cimlogic.com.au>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John Birrell.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: uthread_sig.c,v 1.20 1999/09/29 15:18:39 marcel Exp $
 */
#include <string.h>
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#ifdef _THREAD_SAFE
#include <pthread.h>
#include "pthread_private.h"


/* Initialize signal handling facility: */
void
_thread_sig_init(void)
{
	int i;

	/* Clear local state */
	for (i = 1; i < NSIG; i++) {
		_SPINLOCK_INIT(&_thread_sigq[i - 1].lock);
		_thread_sigq[i - 1].pending = 0;
	}
}

/*
 * This is the only installed signal handler.   In addition to handling
 * thread kernel signals it is installed in place of application handlers
 * and dispatches signals appropriately.
 */
void
_thread_sig_handler(int sig, siginfo_t *info, struct sigcontext * scp)
{
	struct pthread	*curthread = _get_curthread();
	int	dispatch;
	char	c;

	if (sig == _SCHED_SIGNAL) {
		/* Update the scheduling clock: */
		gettimeofday((struct timeval *)&_sched_tod, NULL);
		_sched_ticks++;

		/* only process signal when scheduler isn't running */
		if (_thread_kern_in_sched == 0) {
			if (curthread->sig_defer_count > 0) {
				/*
				 * The scheduler interrupt has come when
				 * the currently running thread has deferred
				 * thread signals.
				 */
				curthread->yield_on_sig_undefer = 1;
			} else {
				/* Schedule the next thread. */
				_thread_kern_sched(scp);

				/*
				 * The scheduler currently returns here instead
				 * of calling sigreturn due to a sparc sigreturn
				 * bug.   We should also return.   That brings
				 * us back to the sigtramp code which will
				 * sigreturn to the context stored on the
				 * current stack (which is the same as scp,
				 * above). The code originally did this:
				 * 
				 * PANIC("Returned to signal function "
				 *	 "from scheduler");
				 */
				return;
			}
		}
	} else {
		/*
		 * save the info for this signal in a per signal queue of depth
		 * one.  Per a POSIX suggestion, only the info for the first
		 * of multiple activations of the same signal is kept.
		 */
		_SPINLOCK(&_thread_sigq[sig - 1].lock);
		if (_thread_sigq[sig - 1].pending == 0) {
			sigaddset(&_process_sigpending, sig);
			_thread_sigq[sig - 1].pending++;
			memcpy(&_thread_sigq[sig - 1].siginfo, info,
			       sizeof *info);
		}
		_SPINUNLOCK(&_thread_sigq[sig - 1].lock);

		if ((_queue_signals != 0) ||
		    ((_thread_kern_in_sched == 0) &&
		     (curthread->sig_defer_count > 0))) {
			/*
			 * The kernel has been interrupted while the scheduler
			 * is accessing the scheduling queues or there is a
			 * currently running thread that has deferred signals.
			 *
			 * Cast the signal number to a character variable
			 * and Write the signal number to the kernel pipe so
			 * that it will be ready to read when this signal
			 * handler returns. 
			 */
			c = (char)sig;
			_thread_sys_write(_thread_kern_pipe[1], &c, 1);
			_sigq_check_reqd = 1;
		} else {
			_queue_signals = 1;
			dispatch = _thread_sig_handle(sig, scp);
			_queue_signals = 0;
			if (dispatch)
				_dispatch_signals(scp);
		}
	}
}

/*
 * Clear the pending flag for the given signal on all threads
 * if per process, or only for the given thread if non null
 * and the signal doesn't exist in _process_sigpending.
 */
void
_thread_clear_pending(int sig, pthread_t thread)
{
	pthread_t pthread;

	_thread_sigq[sig - 1].pending = 0;
	if (sigismember(&_process_sigpending, sig)) {
		sigdelset(&_process_sigpending, sig);
		TAILQ_FOREACH(pthread, &_thread_list, tle) {
			sigdelset(&pthread->sigpend, sig);
		}
	} else if (thread)
		sigdelset(&thread->sigpend, sig);
}

void
_thread_nonblock_fds(void)
{
	int	i;

	/*
	 * Go through the file list and set all files to non-blocking
	 * again in case the child set some of them to block. Sigh.
	 */
	for (i = 0; i < _thread_max_fdtsize; i++)
		if (_thread_fd_table[i] != NULL &&
		    _thread_fd_table[i]->status_flags != NULL)
			_thread_sys_fcntl(i, F_SETFL,
			    (_thread_fd_table[i]->status_flags->flags & ~_FD_NOTSOCK) |
			    O_NONBLOCK);
}

/*
 * Process the given signal.   Returns 1 if the signal may be dispatched,
 * otherwise 0.   Signals MUST be defered when this function is called.
 */
/* ARGSUSED */
int
_thread_sig_handle(int sig, struct sigcontext * scp)
{
	struct pthread	*curthread = _get_curthread();
	pthread_t	pthread, pthread_next;

	if (sig == SIGINFO)
		_thread_dump_info();	/* Dump thread information */
	else if (sig == _SCHED_SIGNAL)
		; /* This shouldn't ever occur (should this panic?). */
	else {
		if (sig == SIGCHLD)
			_thread_nonblock_fds();

		/*
		 * If the handler is SIG_IGN the signal never happened.
		 * remove it from the pending list and return.
		 */
		if (_thread_sigact[sig - 1].sa_handler == SIG_IGN) {
			_thread_clear_pending(sig, curthread);
			return 0;
		}

		/*
		 * POSIX says that pending SIGCONT signals are discarded
		 * when one of these signals occurs and vice versa.
		 */
		if (sig == SIGSTOP || sig == SIGTSTP || sig == SIGTTIN ||
		    sig == SIGTTOU)
			_thread_clear_pending(SIGCONT, curthread);
		if (sig == SIGCONT) {
			_thread_clear_pending(SIGSTOP, curthread);
			_thread_clear_pending(SIGTSTP, curthread);
			_thread_clear_pending(SIGTTIN, curthread);
			_thread_clear_pending(SIGTTOU, curthread);
		}

		/*
		 * Enter a loop to process each thread in the waiting
		 * list that is sigwait-ing on a signal.  Since POSIX
		 * doesn't specify which thread will get the signal
		 * if there are multiple waiters, we'll give it to the
		 * first one we find.
		 */
		for (pthread = TAILQ_FIRST(&_waitingq);
		     pthread != NULL; pthread = pthread_next) {
			/*
			 * Grab the next thread before possibly destroying
			 * the link entry.
			 */
			pthread_next = TAILQ_NEXT(pthread, pqe);

			if ((pthread->state == PS_SIGWAIT) &&
			    sigismember(pthread->data.sigwait, sig)) {
				/*
				 * found a sigwaiter.   Mark its state as
				 * running, save the signal that will be
				 * returned, and mark the signal as no
				 * longer pending. 
				 */
				PTHREAD_NEW_STATE(pthread,PS_RUNNING);
				pthread->signo = sig;
				_thread_clear_pending(sig, pthread);
				return 0;
			}
		}

		/*
		 * mark the signal as pending for each thread
		 * and give the thread a chance to update
		 * its state.
		 */
		TAILQ_FOREACH(pthread, &_thread_list, tle) {
			/* Current thread inside critical region? */
			if (curthread->sig_defer_count > 0)
				pthread->sig_defer_count++;
			_thread_signal(pthread,sig);
			if (curthread->sig_defer_count > 0)
				pthread->sig_defer_count--;
		}
		return 1;
	}
	return 0;
}

/* Perform thread specific actions in response to a signal: */
void
_thread_signal(pthread_t pthread, int sig)
{
	int interrupted = 1;

	/* Flag the signal as pending. It may be dispatched later. */
	sigaddset(&pthread->sigpend,sig);

	/* skip this thread if signal is masked */
	if (sigismember(&pthread->sigmask, sig))
		return;

	/* Process according to thread state: */
	switch (pthread->state) {
	/*
	 * States which do not change when a signal is trapped:
	 */
	case PS_COND_WAIT:
	case PS_DEAD:
	case PS_FDLR_WAIT:
	case PS_FDLW_WAIT:
	case PS_FILE_WAIT:
	case PS_JOIN:
	case PS_MUTEX_WAIT:
	case PS_RUNNING:
	case PS_SIGTHREAD:
	case PS_SIGWAIT:
	case PS_SUSPENDED:
	case PS_SPINBLOCK:
	case PS_DEADLOCK:
	case PS_STATE_MAX: /* only here to quell a compiler warning */
		/* Nothing to do here. */
		break;

	/*
	 * The wait state is a special case due to the handling of
	 * SIGCHLD signals.
	 */
	case PS_WAIT_WAIT:
		/*
		 * Check for signals other than the death of a child
		 * process:
		 */
		if (sig != SIGCHLD)
			/* Flag the operation as interrupted: */
			pthread->interrupted = 1;

		/* Change the state of the thread to run: */
		PTHREAD_NEW_STATE(pthread,PS_RUNNING);

		/* Return the signal number: */
		pthread->signo = sig;
		break;

	/*
	 * States that are interrupted by the occurrence of a signal
	 * other than the scheduling alarm:
	 */
	case PS_FDR_WAIT:
	case PS_FDW_WAIT:
		if (_thread_sigact[sig - 1].sa_flags & SA_RESTART)
			interrupted = 0;
		/* FALLTHROUGH */

	case PS_CONNECT_WAIT:
	case PS_KEVENT_WAIT:
	case PS_POLL_WAIT:
	case PS_SLEEP_WAIT:
	case PS_SELECT_WAIT:
		if (sig != SIGCHLD ||
		    _thread_sigact[sig - 1].sa_handler != SIG_DFL) {
			/* Flag the operation as interrupted: */
			pthread->interrupted = interrupted;

			if (pthread->flags & PTHREAD_FLAGS_IN_WORKQ)
				PTHREAD_WORKQ_REMOVE(pthread);

			/* Change the state of the thread to run: */
			PTHREAD_NEW_STATE(pthread,PS_RUNNING);

			/* Return the signal number: */
			pthread->signo = sig;
		}
		break;

	case PS_SIGSUSPEND:
		/*
		 * Only wake up the thread if the signal is unblocked
		 * and there is a handler installed for the signal.
		 */
		if (_thread_sigact[sig - 1].sa_handler != SIG_DFL) {
			/* Change the state of the thread to run: */
			PTHREAD_NEW_STATE(pthread,PS_RUNNING);

			/* Return the signal number: */
			pthread->signo = sig;
		}
		break;
	}
}

/*
 * Dispatch a signal to the current thread after setting up the
 * appropriate signal mask.
 */
void
_dispatch_signal(int sig, struct sigcontext * scp)
{
	struct pthread	*curthread = _get_curthread();
	
	sigset_t set;
	sigset_t oset;
	struct sigaction act;
	void (*action)(int, siginfo_t *, void *);

	/* save off the action and set the signal mask */
	action = _thread_sigact[sig - 1].sa_sigaction;
	set = _thread_sigact[sig - 1].sa_mask;
	if ((_thread_sigact[sig-1].sa_flags & SA_NODEFER) == 0)
		sigaddset(&set, sig);
	oset = curthread->sigmask;
	curthread->sigmask |= set;

	/* clear custom handler if SA_RESETHAND set. */
	if (_thread_sigact[sig - 1].sa_flags & SA_RESETHAND) {
		act.sa_handler = SIG_DFL;
		act.sa_flags = 0;
		sigemptyset(&act.sa_mask);
		sigaction(sig, &act, NULL);
	}

	/*
	 * clear the pending flag, deliver the signal, then reset the
	 * signal mask
	 */
	_thread_clear_pending(sig, curthread);
	(*action)(sig, &_thread_sigq[sig - 1].siginfo, scp);
	curthread->sigmask = oset;
}

/*
 * possibly dispatch a signal to the current thread.
 */
void
_dispatch_signals(struct sigcontext * scp)
{
	struct pthread	*curthread = _get_curthread();
	int i;

	/*
	 * Check if there are pending signals for the running
	 * thread that aren't blocked:
	 */
	if ((curthread->sigpend & ~curthread->sigmask) != 0)
		/* Look for all possible pending signals: */
		for (i = 1; i < NSIG; i++)
			/*
			 * Check that a custom handler is installed
			 * and if the signal is not blocked:
			 */
			if (_thread_sigact[i - 1].sa_handler != SIG_DFL &&
			    _thread_sigact[i - 1].sa_handler != SIG_IGN &&
			    sigismember(&curthread->sigpend,i) &&
			    !sigismember(&curthread->sigmask,i))
				/* dispatch */
				_dispatch_signal(i, scp);
}
#endif
@


1.28
log
@threads waiting on PS_FDW_WAIT state should not be interruptible if
SA_RESTART is set, with connect(2) being the exception thus getting its
own state.
as pointed by kurt, threads on this and PS_FDR_WAIT states need to be
set to PS_RUNNING since the current signal dispatching code only looks
at the current thread.
ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.27 2011/09/13 23:56:00 fgsch Exp $	*/
@


1.27
log
@For threads in PS_FDR_WAIT state, check SA_RESTART before marking it as
interrupted, thus simulating the system call restart behaviour in the
non-pthreads case.
Add a state for kevent since it shouldn't be restarted regardless of
SA_RESTART being present.
guenther@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.26 2010/07/13 03:10:29 guenther Exp $	*/
d331 1
d336 1
a336 1
	case PS_FDW_WAIT:
@


1.26
log
@Fix PR 6376: restore more thread library state if execve fails,
including the scheduling timer, sigmask, fd nonblocking status, and
handling of the signals used by the thread library.

ok marc@@, additional testing by ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.25 2010/01/03 23:05:35 fgsch Exp $	*/
d275 2
d331 4
d336 1
d343 1
a343 1
			pthread->interrupted = 1;
@


1.25
log
@Make SO_RCVTIMEO and SO_SNDTIMEO work with pthreads. Fixes at least some of
the issues seen with www/varnish.
With input and help from guenther@@ and kurt@@. guenther@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.24 2007/05/18 19:28:50 kurt Exp $	*/
d164 16
a189 1
	int		i;
d197 2
a198 13
		if (sig == SIGCHLD) {
			/*
			 * Go through the file list and set all files
			 * to non-blocking again in case the child
			 * set some of them to block. Sigh.
			 */
			for (i = 0; i < _thread_max_fdtsize; i++)
				if (_thread_fd_table[i] != NULL &&
				    _thread_fd_table[i]->status_flags != NULL)
					_thread_sys_fcntl(i, F_SETFL,
					    (_thread_fd_table[i]->status_flags->flags & ~_FD_NOTSOCK) |
					    O_NONBLOCK);
		}
@


1.24
log
@Eliminate many lint warnings by either: using the appropriate type,
casting when safe or adding ARGSUSED where needed. Reviewed and
improvements from millert@@ and marc@@. okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.23 2007/04/27 12:59:24 kurt Exp $	*/
d192 1
a192 1
					    _thread_fd_table[i]->status_flags->flags |
@


1.23
log
@Use rlimit nofiles max to size fd/fdp tables instead of cur. Fixes
applications that increase nofiles using setrlimit(2). ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.22 2006/09/26 14:18:28 kurt Exp $	*/
d131 1
a131 1
			c = sig;
d169 1
@


1.22
log
@Part 2 of file descriptor race and deadlock corrections.

Adjust design of file descriptor table to eliminate races
with both opening and closing of file descriptor entries
and eliminates one class of deadlocks. One nice side effect
of this change in design should be better performance for
applications that open and close many file descriptors due
to reduced fd_table_lock contention and fd entry reuse.

- Add entry states to manage use of entry and eliminate
some closing races. fd entries are not deallocated upon
close() now.
- Call _thread_fd_table_init with one of five discreet
modes to properly initialize an entry and manage the
state transition to open.
- When closing an entry hold the entry spinlock locked
across the state transition and the _thread_sys_close
call to close another race.
- Introduce a new lock type FD_RDWR_CLOSE that transitions
either a closed entry or an open entry into closing state
and then waits for a RDWR lock so that the lock queue can
unwind normally. All subsequent fd lock attempts for that
entry are rejected with EBADF until the fd is fully closed,
or reopened by dup2(). Once a thread holds the FD_RDWR_LOCK
it is safe to close() it or dup2() on it.
- When a thread creates a new fd there is a window of time
when another thread could attempt to use the fd before the
creating thread has initialized the entry for it. This can
result in improper status_flags for the entry, so record
the entries init mode, detect when this has happened and
correct the status_flags when needed.

reviewed by marc@@ & brad@@, tested by several, okay brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.21 2006/09/22 19:04:33 kurt Exp $	*/
d187 1
a187 1
			for (i = 0; i < _thread_dtablesize; i++)
@


1.21
log
@Part 1 of file descriptor race and deadlock corrections.

File status flags should be shared for dup'ed file descriptors.
However fd_table_entry's should not be shared for dup'ed file
descriptors so they can be independently be closed without
interfering with dup'ed fd's.

- split out file status flags into its own structure
fs_flags to manage sharing of status flags between
dup'ed file descriptors.
- when duplicating a fd, initialize a new fd_table_entry
for the new fd, but share the status flags via status_flags.
- consolidate the code that sets the underlying system fd
to be non-blocking to a new function _thread_fs_flags_init()
- consolidate the code that sets the underlying system
fd back to blocking into a new function _thread_fs_flags_replace()

This change is needed as a prerequisite to the coming race
and deadlock corrections. okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.20 2003/04/30 17:54:17 marc Exp $	*/
d188 2
a189 1
				if (_thread_fd_table[i] != NULL)
@


1.20
log
@fix for pr# 3179 and 3238.   Patch verified by author of 3179.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.19 2003/01/31 04:46:17 marc Exp $	*/
d190 1
a190 1
					    _thread_fd_table[i]->flags |
@


1.19
log
@
Create a siginfo_t for thread-to-thread kill.
Clean up (compiler warning elimination).   Compile check options added
but commented out as they have not been checked on all architectures, yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.18 2003/01/27 22:22:30 marc Exp $	*/
d67 1
d135 4
a138 1
			if (_thread_sig_handle(sig, scp))
d167 1
a167 1
 * otherwise 0.
@


1.19.2.1
log
@Pull patch from -current:
Fixes a pthread issue noticed by several users reports regarding
mysql crashing unexpectedly.
PR# 3179 adn 3238

marc@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.19 2003/01/31 04:46:17 marc Exp $	*/
a66 1
	int	dispatch;
d134 1
a134 4
			_queue_signals = 1;
			dispatch = _thread_sig_handle(sig, scp);
			_queue_signals = 0;
			if (dispatch)
d163 1
a163 1
 * otherwise 0.   Signals MUST be defered when this function is called.
@


1.18
log
@pthreads signal handling improvements.   With these changes all
of the thread regressions tests pass on i386, sparc, sparc64
(save the siginfo test on sparc64 due to a kernel issue) and alpha.
The tests should also pass on ppc.

In addition, it fixes the problems with the "mysql torture test"
provided by one of our users.   The python port also appears to
work correctly with these changes.

Summary of changes:

* check_pending removed from thread structure, no longer used.
* unused elements of sigstatus structure removed.   The sigstatus
  structure is now used to keep track of siginfo data instead of
  defining a local array in uthread_sig.c.
* _thread_kern_sched_sig removed
* _thread_sig_process goes away -- can't have a lock active when
  signal handlers are called.   Functions now call _thread_sig_handle
  directly.
* _thread_clear_pending now used lib wide to clear pending flags.
  It was named _clean_pending_flag and only used in uthread_sig.c.
  The function clears both per thread signals, and per process signals.
* _thread_sig_handle now returns a value.
* unused debugging macros removed from the thread kernel
* dispatch pending signals after switching to a thread providing
  that signal handling hasn't been deferred by the thread.
* process thread switchhooks before dispatching pending sigs
* check for thread cancellation before dispatching pending sigs
* re-wrote pthread-kill to do the correct thing.   It now does
  minimal thread-kill-specific processing and then calls the
  existing code in uthread_sig to process the generated signal.
* shut the compiler up when compiling uthread_mutex.c
* no more "signal_lock".   It does more harm than good.
* keep track of "per-process" signals.
* don't bother saving siginfo_t data for the scheduling signal.
* per posix: SIGSTOP cleared when SIGCONT received and vice versa.
* add _dispatch_signal to properly dispatch a signal to a thread.
  It sets the appropriate signal mask, something that was missing
  in the previous implementation.   This fixes several bugs.
  The previous method held a lock.  If the signal handler longjmp-ed
  the lock was never cleared and no more signals were processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.17 2003/01/24 21:03:15 marc Exp $	*/
d53 1
d108 1
d115 1
d150 1
a151 1
		_thread_sigq[sig - 1].pending = 0;
a368 2
	_thread_clear_pending(sig, curthread);

d385 5
a389 1
	/* call the action and reset the signal mask */
@


1.17
log
@
save and restore fp state when switching threads.   This, with
an arch/i386 patch previously commited and arch/sparc64 patches
from jason@@ make the preemption_float test pass on those two
architectures.

Do not run signal handlers for a thread until the thread has
been made current, ensuring the proper context.   Solves several
(if not all) of the '_pq_insert_tail: Already in priority queue'
problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.16 2002/11/08 23:18:25 todd Exp $	*/
a43 5
/* Static variables: */
static _spinlock_lock_t	signal_lock = _SPINLOCK_UNLOCKED;
siginfo_t		info_queue[NSIG];
volatile sig_atomic_t	pending_sigs[NSIG];
volatile sig_atomic_t	check_pending = 0;
d53 1
a53 1
		pending_sigs[i - 1] = 0;
a54 24

	/* Clear the lock: */
	signal_lock = _SPINLOCK_UNLOCKED;
}

/*
 * Process a pending signal unless it is already in progress.  If the
 * SA_NODEFER  flag is on, process it any way.
 */
void
_thread_sig_process(int sig, struct sigcontext * scp)
{
	int locked = 0;

	if (_atomic_lock(&signal_lock) == 0)
		locked = 1;

	if (locked || _thread_sigact[sig - 1].sa_flags & SA_NODEFER) {
		pending_sigs[sig - 1] = 0;
		_thread_sig_handle(sig, scp);
	} else
		check_pending = 1;
	if (locked)
		signal_lock = _SPINLOCK_UNLOCKED;
a66 11
	int	i;

	/*
	 * save the info for this signal in a per signal queue of depth
	 * one.  Per a POSIX suggestion, only the info for the first
	 * of multiple activations of the same signal is kept.
	 */
	if (pending_sigs[sig - 1] == 0) {
		pending_sigs[sig - 1]++;
		memcpy(&info_queue[sig - 1], info, sizeof *info);
	}
a100 15
	} else if ((_queue_signals != 0) ||
		   ((_thread_kern_in_sched == 0) &&
		    (curthread->sig_defer_count > 0))) {
		/*
		 * The kernel has been interrupted while the scheduler
		 * is accessing the scheduling queues or there is a currently
		 * running thread that has deferred signals.
		 *
		 * Cast the signal number to a character variable and Write
		 * the signal number to the kernel pipe so that it will be
		 * ready to read when this signal handler returns.
		 */
		c = sig;
		_thread_sys_write(_thread_kern_pipe[1], &c, 1);
		_sigq_check_reqd = 1;
a101 2
		/* process the signal */
		_thread_sig_process(sig, scp);
d103 3
a105 4
		 * process pending signals unless a current signal handler
		 * is running (signal_lock is locked).   When locked
		 * the pending signals will be processed when the running
		 * handler returns.
d107 26
a132 6
		while (check_pending != 0 && _atomic_lock(&signal_lock) == 0) {
			check_pending = 0;
			signal_lock = _SPINLOCK_UNLOCKED;
			for (i = 1; i < NSIG; i++)
				if (pending_sigs[i - 1])
					_thread_sig_process(i, scp);
a134 1

d139 2
d143 1
a143 1
_clear_pending_flag(int sig)
d147 8
a154 3
	TAILQ_FOREACH(pthread, &_thread_list, tle) {
		sigdelset(&pthread->sigpend, sig);
	}
d159 2
a160 1
 * Process the given signal.
d162 1
a162 1
void
d188 11
a198 2
		 * POSIX says that pending SIGCONT signals are
		 * discarded when one of these signals occurs.
d200 9
a208 2
		if (sig == SIGTSTP || sig == SIGTTIN || sig == SIGTTOU)
			_clear_pending_flag(SIGCONT);
d227 6
a232 1
				/* Change the state of the thread to run: */
a233 2

				/* Return the signal number: */
d235 2
a236 6

				/*
				 * Do not attempt to deliver this signal
				 * to other threads.
				 */
				return;
d240 12
a251 21
		if (_thread_sigact[sig - 1].sa_handler != SIG_IGN) {
			/*
			 * mark the signal as pending for each thread
			 * and give the thread a chance to update
			 * its state.
			 */
			TAILQ_FOREACH(pthread, &_thread_list, tle) {
				/* Current thread inside critical region? */
				if (curthread->sig_defer_count > 0)
					pthread->sig_defer_count++;
				_thread_signal(pthread,sig);
				if (curthread->sig_defer_count > 0)
					pthread->sig_defer_count--;
			}
			/*
			 * Give the current thread a chance to dispatch
			 * the signals.  Other threads will get thier
			 * chance (if the signal is still pending) later.
			 */
			_dispatch_signals(scp);

d253 1
d255 1
d262 1
a262 3
	/*
	 * Flag the signal as pending. It may be dispatched later.
	 */
d269 1
a269 3
	/*
	 * Process according to thread state:
	 */
d353 37
a395 2
	struct sigaction act;
	void (*action)(int, siginfo_t *, void *);
d412 3
a414 19
			    !sigismember(&curthread->sigmask,i)) {
				action = _thread_sigact[i - 1].sa_sigaction;
				_clear_pending_flag(i);

				/* clear custom handler if SA_RESETHAND set. */
				if (_thread_sigact[i - 1].sa_flags &
				    SA_RESETHAND) {
					act.sa_handler = SIG_DFL;
					act.sa_flags = 0;
					sigemptyset(&act.sa_mask);
					sigaction(i, &act, NULL);
				}

				/*
				 * Dispatch the signal via the custom signal
				 * handler.
				 */
				(*action)(i, &info_queue[i - 1], scp);
			}
@


1.16
log
@kill two compiler warnings; ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.15 2002/11/02 23:52:46 millert Exp $	*/
d78 1
a79 1
		pending_sigs[sig - 1] = 0;
d170 1
a170 1
				    _thread_sig_process(i, scp);
d271 3
a273 2
			 * give each thread a chance to dispatch pending
			 * signals.
d275 2
a276 8
			TAILQ_FOREACH(pthread, &_thread_list, tle) {
				/* Current thread inside critical region? */
				if (curthread->sig_defer_count > 0)
					pthread->sig_defer_count++;
				_dispatch_signals(pthread, scp);
				if (curthread->sig_defer_count > 0)
					pthread->sig_defer_count--;
			}
a278 3

	/* Returns nothing. */
	return;
d380 1
a380 1
 * possibly dispatch a signal to the given thread.
d383 1
a383 1
_dispatch_signals(pthread_t pthread, struct sigcontext * scp)
d385 1
a385 1
	pthread_t pthread_saved;
d394 1
a394 1
	if ((pthread->sigpend & ~pthread->sigmask) != 0)
d403 2
a404 2
			    sigismember(&pthread->sigpend,i) &&
			    !sigismember(&pthread->sigmask,i)) {
a420 2
				pthread_saved = _get_curthread();
				_set_curthread(pthread);
a421 1
				_set_curthread(pthread_saved);
@


1.15
log
@Include string.h to get memcpy() prototype; OK marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.14 2002/10/30 19:11:56 marc Exp $	*/
d114 2
a115 2
		if (_thread_kern_in_sched == 0)
			if (curthread->sig_defer_count > 0)
d122 1
a122 1
			else {
d140 1
d322 1
@


1.14
log
@signal handling changes.   This corrects several signal
handling errors in the threads library.   Most of the libc_r regression
tests are now ok.   thread specific kill semantics are still not correct.
No negative comments after posting to tech@@ a week or so ago.
siginfo test fails on sparc64 due to sparc64 oddity.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.13 2002/10/07 22:36:04 marc Exp $	*/
d35 1
@


1.13
log
@handle the SA_RESETHAND flag.
Part of the prep for SA_SIGINFO support.   With this change the
new siginfo regression test will fail instead of loop on all arches.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.12 2001/12/31 18:23:15 fgsch Exp $	*/
d44 4
a47 4
static spinlock_t	signal_lock = _SPINLOCK_INITIALIZER;
unsigned int		pending_sigs[NSIG];
unsigned int		handled_sigs[NSIG];
int			volatile check_pending = 0;
d55 1
a55 1
	/* Clear pending and handled signal counts: */
a57 1
		handled_sigs[i - 1] = 0;
d61 1
a61 1
	signal_lock.access_lock = 0;
d64 26
d91 1
a91 1
_thread_sig_handler(int sig, int code, struct sigcontext * scp)
d97 10
a106 1
	/* Check if an interval timer signal: */
d112 30
a141 6
		if (_thread_kern_in_sched != 0) {
			/*
			 * The scheduler is already running; ignore this
			 * signal.
			 */
		}
d143 7
a149 3
		 * Check if the scheduler interrupt has come when
		 * the currently running thread has deferred thread
		 * signals.
a150 32
		else if (curthread->sig_defer_count > 0)
			curthread->yield_on_sig_undefer = 1;

		else {
			/*
			 * Schedule the next thread. This function is not
			 * expected to return because it will do a longjmp
			 * instead.
			 */
			_thread_kern_sched(scp);

			/* The scheduler currently returns here instead
			   of calling sigreturn due to a sparc sigreturn
			   bug.   We should also return.   That brings
			   us back to the sigtramp code which will
			   sigreturn to the context stored on the current
			   stack (which is the same as scp, above).
			   The code originally did this:

			   PANIC("Returned to signal function from scheduler");
			*/
			return;
		}
	}
	/*
	 * Check if the kernel has been interrupted while the scheduler
	 * is accessing the scheduling queues or if there is a currently
	 * running thread that has deferred signals.
	 */
	else if ((_queue_signals != 0) || ((_thread_kern_in_sched == 0) &&
	    (curthread->sig_defer_count > 0))) {
		/* Cast the signal number to a character variable: */
d152 5
a156 1

d158 4
a161 2
		 * Write the signal number to the kernel pipe so that it will
		 * be ready to read when this signal handler returns.
d163 8
a170 1
		_thread_sys_write(_thread_kern_pipe[1], &c, 1);
d172 1
a172 16
		/* Indicate that there are queued signals in the pipe. */
		_sigq_check_reqd = 1;
	}
	else {
		if (_atomic_lock(&signal_lock.access_lock)) {
			/* There is another signal handler running: */
			pending_sigs[sig - 1]++;
			check_pending = 1;
		}
		else {
			/* It's safe to handle the signal now. */
			_thread_sig_handle(sig, scp);

			/* Reset the pending and handled count back to 0: */
			pending_sigs[sig - 1] = 0;
			handled_sigs[sig - 1] = 0;
d174 7
a180 2
			signal_lock.access_lock = 0;
		}
d182 2
a183 10
		/* Enter a loop to process pending signals: */
		while ((check_pending != 0) &&
		    (_atomic_lock(&signal_lock.access_lock) == 0)) {
			check_pending = 0;
			for (i = 1; i < NSIG; i++) {
				if (pending_sigs[i - 1] > handled_sigs[i - 1])
					_thread_sig_handle(i, scp);
			}
			signal_lock.access_lock = 0;
		}
d187 4
a197 1
	/* Check if the signal requires a dump of thread information: */
d199 4
a202 10
		/* Dump thread information to file: */
		_thread_dump_info();

	/* Check if an interval timer signal: */
	else if (sig == _SCHED_SIGNAL) {
		/*
		 * This shouldn't ever occur (should this panic?).
		 */
	} else {
		/* Check if a child has terminated: */
d209 2
a210 7
			for (i = 0; i < _thread_dtablesize; i++) {
				/* Check if this file is used: */
				if (_thread_fd_table[i] != NULL) {
					/*
					 * Set the file descriptor to
					 * non-blocking:
					 */
a213 2
				}
			}
d220 2
a221 9
		if (sig == SIGTSTP || sig == SIGTTIN || sig == SIGTTOU) {
			/*
			 * Enter a loop to discard pending SIGCONT
			 * signals:
			 */
			TAILQ_FOREACH(pthread, &_thread_list, tle) {
				sigdelset(&pthread->sigpend,SIGCONT);
			}
		}
d231 1
a231 1
		    pthread != NULL; pthread = pthread_next) {
d254 1
a254 2
		/* Check if the signal is not being ignored: */
		if (_thread_sigact[sig - 1].sa_handler != SIG_IGN)
d256 3
a258 2
			 * Enter a loop to process each thread in the linked
			 * list:
a260 2
				pthread_t pthread_saved = curthread;

a263 1

d265 8
a272 9

				/*
				 * Dispatch pending signals to the
				 * running thread:
				 */
				_set_curthread(pthread);
				_dispatch_signals();
				_set_curthread(pthread_saved);

d275 3
d280 1
d384 3
a386 1
/* Dispatch pending signals to the running thread: */
d388 1
a388 1
_dispatch_signals()
d390 2
a391 1
	struct pthread	*curthread = _get_curthread();
d399 1
a399 1
	if ((curthread->sigpend & ~curthread->sigmask) != 0)
d408 2
a409 2
			    sigismember(&curthread->sigpend,i) &&
			    !sigismember(&curthread->sigmask,i)) {
d411 1
a411 3

				/* Clear the pending signal: */
				sigdelset(&curthread->sigpend,i);
d415 7
a421 3
				    SA_RESETHAND)
					_thread_sigact[i - 1].sa_handler =
						SIG_DFL;
d424 1
a424 1
				 * handler:
d426 4
a429 1
				(*action)(i, 0, 0);
@


1.12
log
@More changes from FreeBSD, including:

o Only poll file descriptors when needed.
o Change the way timing is achieved, counting scheduling ticks
  instead of calculating the elapsed time via gettimeofday().
o Prevent an overflow when polling.
o Use curthread instead of _thread_run.
o Remove extra spaces; indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.11 2001/12/18 03:47:52 marc Exp $	*/
d381 1
d399 2
d404 5
d413 1
a413 1
				(*(_thread_sigact[i - 1].sa_handler))(i);
@


1.11
log
@
Allow the scheduler to return to the signal handler and the signal
handler to return instead of calling sigreturn directly.   This works
around an apparent bug in sparc sigreturn handling. ok fgs@@ and noone
else has bitched
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.10 2001/11/05 22:53:28 marc Exp $	*/
d74 4
d96 1
a96 1
			 * instead. 
d250 1
a250 1
			 * list: 
d337 1
a337 1
	 * other than the scheduling alarm: 
@


1.10
log
@
Don't change the state of a thread as a result of a signal that is
masked by that thread.   This fixes the problem found with the
signal regression test.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.9 2001/11/02 20:37:20 marc Exp $	*/
d96 11
a106 5
			/*
			 * This point should not be reached, so abort the
			 * process: 
			 */
			PANIC("Returned to signal function from scheduler");
@


1.9
log
@
Fix signal dispatching.   No-one has reported any probs (other than
with regression tests that need to be fixed) and fgs@@ thinks it's OK.
I'll look at the pthreads regression tests, next
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.8 2001/08/21 19:24:53 fgsch Exp $	*/
d274 1
a274 1
	 * Flag the signal as pending. It will be dispatched later.
d278 4
d355 1
a355 2
		if (!sigismember(&pthread->sigmask, sig) &&
		    _thread_sigact[sig - 1].sa_handler != SIG_DFL) {
@


1.8
log
@Start syncing with FreeBSD:

o Implement _get_curthread() and _set_curthread(). Use it where possible.
o Add missing _thread_[enter|leave]_cancellation_point().
o Add a couple of not yet used vars to pthread_private.h.
o Remove return's from void functions.

This is by no means complete, but instead of doing a big commit, i'll
split it in small ones, minimizing diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.7 2000/01/06 07:20:52 d Exp $	*/
a248 1
				curthread = pthread;
d255 1
d257 1
a257 1
				curthread = pthread_saved;
@


1.8.2.1
log
@MFC (rev 1.9), proactively preempting popular demand.
Original commit message:
  Fix signal dispatching.   No-one has reported any probs (other than
  with regression tests that need to be fixed) and fgs@@ thinks it's OK.
  I'll look at the pthreads regression tests, next
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.9 2001/11/02 20:37:20 marc Exp $	*/
d249 1
a255 1
				_set_curthread(pthread);
d257 1
a257 1
				_set_curthread(pthread_saved);
@


1.7
log
@fill out cases with new thread states
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sig.c,v 1.6 1999/11/25 07:01:44 d Exp $	*/
d68 1
d85 2
a86 2
		else if (_thread_run->sig_defer_count > 0)
			_thread_run->yield_on_sig_undefer = 1;
d109 1
a109 1
	    (_thread_run->sig_defer_count > 0))) {
d155 1
d243 1
a243 1
				pthread_t pthread_saved = _thread_run;
d246 1
a246 1
				if (_thread_run->sig_defer_count > 0)
d249 1
a249 1
				_thread_run = pthread;
d257 1
a257 1
				_thread_run = pthread_saved;
d260 1
a260 1
				if (_thread_run->sig_defer_count > 0)
d367 1
d374 1
a374 1
	if ((_thread_run->sigpend & ~_thread_run->sigmask) != 0)
d383 2
a384 2
			    sigismember(&_thread_run->sigpend,i) &&
			    !sigismember(&_thread_run->sigmask,i)) {
d386 1
a386 1
				sigdelset(&_thread_run->sigpend,i);
@


1.6
log
@sync with FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a290 1
	case PS_STATE_MAX:
d294 2
@


1.5
log
@sync with FreeBSD
@
text
@d24 1
a24 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d33 1
a42 13
/*
 * State change macro for signal handler:
 */
#define PTHREAD_SIG_NEW_STATE(thrd, newstate) {				\
	if ((_thread_run->sched_defer_count == 0) &&			\
	    (_thread_kern_in_sched == 0)) {				\
		PTHREAD_NEW_STATE(thrd, newstate);			\
	} else {							\
		_waitingq_check_reqd = 1;				\
		PTHREAD_SET_STATE(thrd, newstate);			\
	}								\
}

d44 4
a47 12
static int		volatile yield_on_unlock_thread	= 0;
static spinlock_t	thread_link_list_lock	= _SPINLOCK_INITIALIZER;

int _thread_sig_statistics[NSIG];

/* Lock the thread list: */
void
_lock_thread_list()
{
	/* Lock the thread list: */
	_SPINLOCK(&thread_link_list_lock);
}
d49 1
a49 1
/* Lock the thread list: */
d51 1
a51 1
_unlock_thread_list()
d53 1
a53 2
	/* Unlock the thread list: */
	_SPINUNLOCK(&thread_link_list_lock);
d55 5
a59 7
	/*
	 * Check if a scheduler interrupt occurred while the thread
	 * list was locked:
	 */
	if (yield_on_unlock_thread) {
		/* Reset the interrupt flag: */
		yield_on_unlock_thread = 0;
d61 2
a62 3
		/* This thread has overstayed it's welcome: */
		sched_yield();
	}
d68 2
a69 3
	char            c;
	int             i;
	pthread_t       pthread;
d71 23
a93 4
	/*
	 * Record the number of times this signal has been received
	 */
	_thread_sig_statistics[sig]++;
d95 7
d103 3
a105 3
	 * Check if the pthread kernel has unblocked signals (or is about to)
	 * and was on its way into a _select when the current
	 * signal interrupted it: 
d107 2
a108 1
	if (_thread_kern_in_select) {
d114 1
a114 3
		 * be ready to read when this signal handler returns. This
		 * means that the _select call will complete
		 * immediately. 
d117 31
d149 7
a163 20
		/* Check if the scheduler interrupt has come at an
		 * unfortunate time which one of the threads is
		 * modifying the thread list:
		 */
		if (_atomic_is_locked(&thread_link_list_lock.access_lock))
			/*
			 * Set a flag so that the thread that has
			 * the lock yields when it unlocks the
			 * thread list:
			 */
			yield_on_unlock_thread = 1;

		/*
		 * Check if the scheduler interrupt has come when
		 * the currently running thread has deferred thread
		 * scheduling.
		 */
		else if (_thread_run->sched_defer_count)
			_thread_run->yield_on_sched_undefer = 1;

d165 1
a165 2
		 * Check if the kernel has not been interrupted while
		 * executing scheduler code:
a166 14
		else if (!_thread_kern_in_sched) {
			/*
			 * Schedule the next thread. This function is not
			 * expected to return because it will do a longjmp
			 * instead. 
			 */
			_thread_kern_sched(scp);

			/*
			 * This point should not be reached, so abort the
			 * process: 
			 */
			PANIC("Returned to signal function from scheduler");
		}
d198 1
a198 3
			for (pthread = _thread_link_list;
			    pthread != NULL;
			    pthread = pthread->nxt)
d200 1
d210 8
a217 1
		TAILQ_FOREACH(pthread, &_waitingq, pqe) {
d221 1
a221 1
				PTHREAD_SIG_NEW_STATE(pthread,PS_RUNNING);
d240 1
a240 2
			for (pthread = _thread_link_list; pthread != NULL;
			     pthread = pthread->nxt) {
d243 4
d249 1
d256 4
d312 1
a312 1
		PTHREAD_SIG_NEW_STATE(pthread,PS_RUNNING);
d324 1
d332 3
d336 1
a336 1
			PTHREAD_SIG_NEW_STATE(pthread,PS_RUNNING);
d351 1
a351 1
			PTHREAD_SIG_NEW_STATE(pthread,PS_RUNNING);
@


1.4
log
@ident
@
text
@d1 1
a32 1
 * $OpenBSD$
d42 13
d125 1
a125 1
	else if (sig == SIGVTALRM) {
d139 8
d202 1
a202 1
		 * Enter a loop to process each thread in the linked
d208 1
a208 2
		for (pthread = _thread_link_list; pthread != NULL;
		    pthread = pthread->nxt) {
d212 1
a212 1
				PTHREAD_NEW_STATE(pthread,PS_RUNNING);
d232 4
a235 1
			     pthread = pthread->nxt)
d237 7
a243 3

		/* Dispatch pending signals to the running thread: */
		_dispatch_signals();
d295 1
a295 1
		PTHREAD_NEW_STATE(pthread,PS_RUNNING);
d315 1
a315 1
			PTHREAD_NEW_STATE(pthread,PS_RUNNING);
d330 1
a330 1
			PTHREAD_NEW_STATE(pthread,PS_RUNNING);
@


1.3
log
@use md spinlock; signal statistics
@
text
@d32 1
@


1.2
log
@sync with FreeBSD (rwlock, gc thread, man pages)
add (broken) mips md stuff
fix some const warnings
add sigaltstack() stub
another hash at getting shlib auto-init to work (mips/elf and i386/a.out)
@
text
@d45 2
d83 5
d116 1
a116 1
		if (thread_link_list_lock.access_lock)
@


1.1
log
@experimental threaded libc - kernel only
@
text
@a41 1
static int		volatile yield_on_unlock_dead	= 0;
a42 1
static spinlock_t	thread_dead_lock	= _SPINLOCK_INITIALIZER;
a52 8
/* Lock the dead thread list: */
void
_lock_dead_thread_list()
{
	/* Lock the dead thread list: */
	_SPINLOCK(&thread_dead_lock);
}

a72 20
/* Lock the dead thread list: */
void
_unlock_dead_thread_list()
{
	/* Unlock the dead thread list: */
	_SPINUNLOCK(&thread_dead_lock);

	/*
	 * Check if a scheduler interrupt occurred while the dead
	 * thread list was locked:
	 */
	if (yield_on_unlock_dead) {
		/* Reset the interrupt flag: */
		yield_on_unlock_dead = 0;

		/* This thread has overstayed it's welcome: */
		sched_yield();
	}
}

a116 12
		/* Check if the scheduler interrupt has come at an
		 * unfortunate time which one of the threads is
		 * modifying the dead thread list:
		 */
		if (thread_dead_lock.access_lock)
			/*
			 * Set a flag so that the thread that has
			 * the lock yields when it unlocks the
			 * dead thread list:
			 */
			yield_on_unlock_dead = 1;

d159 1
a159 1
		 * discarded when one of there signals occurs.
d182 1
a182 1
			    sigismember(&pthread->sigmask, sig)) {
d279 15
@

