head	1.80;
access;
symbols
	OPENBSD_5_2:1.79.0.4
	OPENBSD_5_2_BASE:1.79
	OPENBSD_5_1_BASE:1.79
	OPENBSD_5_1:1.79.0.2
	OPENBSD_5_0:1.76.0.4
	OPENBSD_5_0_BASE:1.76
	OPENBSD_4_9:1.76.0.2
	OPENBSD_4_9_BASE:1.76
	OPENBSD_4_8:1.75.0.2
	OPENBSD_4_8_BASE:1.75
	OPENBSD_4_7:1.74.0.2
	OPENBSD_4_7_BASE:1.74
	OPENBSD_4_6:1.71.0.4
	OPENBSD_4_6_BASE:1.71
	OPENBSD_4_5:1.70.0.2
	OPENBSD_4_5_BASE:1.70
	OPENBSD_4_4:1.69.0.4
	OPENBSD_4_4_BASE:1.69
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.68.0.2
	OPENBSD_4_2_BASE:1.68
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.55.0.4
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.55.0.2
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.53.0.6
	OPENBSD_3_8_BASE:1.53
	OPENBSD_3_7:1.53.0.4
	OPENBSD_3_7_BASE:1.53
	OPENBSD_3_6:1.53.0.2
	OPENBSD_3_6_BASE:1.53
	OPENBSD_3_5:1.52.0.2
	OPENBSD_3_5_BASE:1.52
	OPENBSD_3_4:1.48.0.2
	OPENBSD_3_4_BASE:1.48
	OPENBSD_3_3:1.45.0.2
	OPENBSD_3_3_BASE:1.45;
locks; strict;
comment	@ * @;


1.80
date	2012.09.01.00.32.23;	author guenther;	state dead;
branches;
next	1.79;

1.79
date	2012.01.17.02.52.39;	author guenther;	state Exp;
branches;
next	1.78;

1.78
date	2011.10.07.08.59.42;	author fgsch;	state Exp;
branches;
next	1.77;

1.77
date	2011.09.13.23.56.00;	author fgsch;	state Exp;
branches;
next	1.76;

1.76
date	2010.10.28.15.02.41;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.13.03.10.29;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2010.01.03.23.05.35;	author fgsch;	state Exp;
branches;
next	1.73;

1.73
date	2009.12.06.17.54.59;	author kurt;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.27.20.06.29;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2009.04.21.12.43.01;	author kurt;	state Exp;
branches;
next	1.70;

1.70
date	2008.12.18.09.30.32;	author guenther;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.20.19.35.36;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2007.07.20.22.34.40;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.05.18.11.49;	author kurt;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.21.16.50.36;	author kurt;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.01.14.54.27;	author kurt;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.27.20.44.43;	author kurt;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.27.19.40.08;	author kurt;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.27.18.04.08;	author kurt;	state Exp;
branches;
next	1.61;

1.61
date	2007.04.27.12.59.24;	author kurt;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.26.18.13.10;	author kurt;	state Exp;
branches;
next	1.59;

1.59
date	2007.03.20.21.28.31;	author kurt;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.03.02.59.36;	author kurt;	state Exp;
branches;
next	1.57;

1.57
date	2006.09.26.14.18.28;	author kurt;	state Exp;
branches;
next	1.56;

1.56
date	2006.09.22.19.04.33;	author kurt;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.06.18.53.04;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2005.10.30.03.37.34;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.07.21.11.23;	author marc;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.01.06.22.14;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.15.22.22.11;	author marc;	state Exp;
branches;
next	1.50;

1.50
date	2003.12.31.22.15.28;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2003.11.10.23.15.18;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.01.19.50.23;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2003.07.08.00.17.18;	author marc;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.13.16.49.32;	author marc;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.14.03.58.42;	author marc;	state Exp;
branches;
next	1.44;

1.44
date	2003.02.04.22.14.27;	author marc;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.31.04.46.17;	author marc;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.27.22.22.30;	author marc;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.24.21.03.15;	author marc;	state Exp;
branches;
next	1.40;

1.40
date	2002.12.11.23.21.19;	author marc;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.08.04.06.01;	author marc;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.12.20.12.45;	author marc;	state Exp;
branches;
next	1.37;

1.37
date	2002.10.30.20.05.11;	author marc;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.30.19.11.56;	author marc;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.21.20.57.41;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.19.23.49.32;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.31.18.23.15;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.19.02.02.52;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.11.00.19.47;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.08.14.51.36;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.04.23.28.31;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.04.22.17.45;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.30.17.47.57;	author todd;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.30.07.40.47;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.29.18.33.54;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.26.00.49.03;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.21.19.24.53;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.15.23.50.34;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.06.17.18.47;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.04.05.55.35;	author d;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.06.07.13.56;	author d;	state Exp;
branches;
next	1.18;

1.18
date	99.11.25.07.01.30;	author d;	state Exp;
branches;
next	1.17;

1.17
date	99.09.08.08.21.47;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	99.06.15.00.07.39;	author d;	state Exp;
branches;
next	1.15;

1.15
date	99.06.09.07.06.54;	author d;	state Exp;
branches;
next	1.14;

1.14
date	99.05.26.00.18.21;	author d;	state Exp;
branches;
next	1.13;

1.13
date	99.02.16.16.44.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	99.01.18.00.03.35;	author d;	state Exp;
branches;
next	1.11;

1.11
date	99.01.18.00.00.32;	author d;	state Exp;
branches;
next	1.10;

1.10
date	99.01.10.22.32.23;	author d;	state Exp;
branches;
next	1.9;

1.9
date	99.01.08.05.44.53;	author d;	state Exp;
branches;
next	1.8;

1.8
date	99.01.08.05.42.18;	author d;	state Exp;
branches;
next	1.7;

1.7
date	99.01.08.04.59.50;	author d;	state Exp;
branches;
next	1.6;

1.6
date	98.12.23.22.49.46;	author d;	state Exp;
branches;
next	1.5;

1.5
date	98.12.21.07.41.31;	author d;	state Exp;
branches;
next	1.4;

1.4
date	98.11.20.12.13.32;	author d;	state Exp;
branches;
next	1.3;

1.3
date	98.11.20.11.04.00;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.11.09.03.13.18;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.08.27.09.00.50;	author d;	state Exp;
branches;
next	;


desc
@@


1.80
log
@   So passes uthreads
Like autumn leaves on water
   don't fear the tedu@@
@
text
@/*	$OpenBSD: pthread_private.h,v 1.79 2012/01/17 02:52:39 guenther Exp $	*/
/*
 * Copyright (c) 1995-1998 John Birrell <jb@@cimlogic.com.au>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John Birrell.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Private thread definitions for the uthread kernel.
 *
 * $FreeBSD: pthread_private.h,v 1.27 1999/09/29 15:18:38 marcel Exp $
 */

#ifndef _PTHREAD_PRIVATE_H
#define _PTHREAD_PRIVATE_H

/*
 * Evaluate the storage class specifier.
 */
#ifdef GLOBAL_PTHREAD_PRIVATE
#define SCLASS
#else
#define SCLASS extern
#endif

/*
 * Include files.
 */
#include <signal.h>
#include <stdio.h>
#include <sys/poll.h>
#include <sys/queue.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sched.h>
#include <spinlock.h>
#include <pthread_np.h>
#include "thread_private.h"
#include "uthread_machdep.h"

/*
 * Kernel fatal error handler macro.
 */
#define PANIC(string)   _thread_exit(__FILE__,__LINE__,string)

/* Output debug messages like this: */
#define	stdout_debug(_x)	_thread_sys_write(1,_x,strlen(_x));
#define	stderr_debug(_x)	_thread_sys_write(2,_x,strlen(_x));


/*
 * Priority queue manipulation macros (using pqe link):
 */
#define PTHREAD_PRIOQ_INSERT_HEAD(thrd)	_pq_insert_head(&_readyq,thrd)
#define PTHREAD_PRIOQ_INSERT_TAIL(thrd)	_pq_insert_tail(&_readyq,thrd)
#define PTHREAD_PRIOQ_REMOVE(thrd)	_pq_remove(&_readyq,thrd)
#define PTHREAD_PRIOQ_FIRST()		_pq_first(&_readyq)

/*
 * Waiting queue manipulation macros (using pqe link):
 */
#define PTHREAD_WAITQ_REMOVE(thrd)	_waitq_remove(thrd)
#define PTHREAD_WAITQ_INSERT(thrd)	_waitq_insert(thrd)

#if defined(_PTHREADS_INVARIANTS)
#define PTHREAD_WAITQ_CLEARACTIVE()	_waitq_clearactive()
#define PTHREAD_WAITQ_SETACTIVE()	_waitq_setactive()
#else
#define PTHREAD_WAITQ_CLEARACTIVE()
#define PTHREAD_WAITQ_SETACTIVE()
#endif

/*
 * Work queue manipulation macros (using qe link):
 */
#define PTHREAD_WORKQ_INSERT(thrd) do {					\
	TAILQ_INSERT_TAIL(&_workq,thrd,qe);				\
	(thrd)->flags |= PTHREAD_FLAGS_IN_WORKQ;			\
} while (0)
#define PTHREAD_WORKQ_REMOVE(thrd) do {					\
	TAILQ_REMOVE(&_workq,thrd,qe);					\
	(thrd)->flags &= ~PTHREAD_FLAGS_IN_WORKQ;			\
} while (0)


/*
 * State change macro without scheduling queue change:
 */
#define PTHREAD_SET_STATE(thrd, newstate) do {				\
	(thrd)->state = newstate;					\
	(thrd)->fname = __FILE__;					\
	(thrd)->lineno = __LINE__;					\
} while (0)

/*
 * State change macro with scheduling queue change - This must be
 * called with preemption deferred (see thread_kern_sched_[un]defer).
 */
#if defined(_PTHREADS_INVARIANTS)
#include <assert.h>
#define PTHREAD_ASSERT(cond, msg) do {	\
	if (!(cond))			\
		PANIC(msg);		\
} while (0)
#define PTHREAD_ASSERT_NOT_IN_SYNCQ(thrd) \
	PTHREAD_ASSERT((((thrd)->flags & PTHREAD_FLAGS_IN_SYNCQ) == 0),	\
	    "Illegal call from signal handler");
#define PTHREAD_NEW_STATE(thrd, newstate) do {				\
	if (_thread_kern_new_state != 0)				\
		PANIC("Recursive PTHREAD_NEW_STATE");			\
	_thread_kern_new_state = 1;					\
	if ((thrd)->state != newstate) {				\
		if ((thrd)->state == PS_RUNNING) {			\
			PTHREAD_PRIOQ_REMOVE(thrd);			\
			PTHREAD_WAITQ_INSERT(thrd);			\
		} else if (newstate == PS_RUNNING) { 			\
			PTHREAD_WAITQ_REMOVE(thrd);			\
			PTHREAD_PRIOQ_INSERT_TAIL(thrd);		\
		}							\
	}								\
	_thread_kern_new_state = 0;					\
	PTHREAD_SET_STATE(thrd, newstate);				\
} while (0)
#else
#define PTHREAD_ASSERT(cond, msg)
#define PTHREAD_ASSERT_NOT_IN_SYNCQ(thrd)
#define PTHREAD_NEW_STATE(thrd, newstate) do {				\
	if ((thrd)->state != newstate) {				\
		if ((thrd)->state == PS_RUNNING) {			\
			PTHREAD_PRIOQ_REMOVE(thrd);			\
			PTHREAD_WAITQ_INSERT(thrd);			\
		} else if (newstate == PS_RUNNING) { 			\
			PTHREAD_WAITQ_REMOVE(thrd);			\
			PTHREAD_PRIOQ_INSERT_TAIL(thrd);		\
		}							\
	}								\
	PTHREAD_SET_STATE(thrd, newstate);				\
} while (0)
#endif

/*
 * Define the signals to be used for scheduling.
 */
#if defined(_PTHREADS_COMPAT_SCHED) || defined(PROF)
#define _ITIMER_SCHED_TIMER	ITIMER_VIRTUAL
#define _SCHED_SIGNAL		SIGVTALRM
#else
#define _ITIMER_SCHED_TIMER	ITIMER_PROF
#define _SCHED_SIGNAL		SIGPROF
#endif

/* Lists with volatile elements */
#define V_TAILQ_HEAD(name, type)				\
volatile struct name {						\
	struct type * tqh_first;				\
	struct type * volatile * tqh_last; 			\
}

#define V_TAILQ_ENTRY(type)					\
volatile struct {						\
	struct type * tqe_next;					\
	struct type * volatile * tqe_prev; 			\
}

/* List of all threads: */
typedef V_TAILQ_HEAD(, pthread)	_thread_list_t;

/*
 * Priority queues.
 *
 * XXX It'd be nice if these were contained in uthread_priority_queue.[ch].
 */
typedef struct pq_list {
	_thread_list_t		pl_head; /* list of threads at this priority */
	TAILQ_ENTRY(pq_list)	pl_link; /* link for queue of priority lists */
	int			pl_prio; /* the priority of this list */
	int			pl_queued; /* is this in the priority queue */
} pq_list_t;

typedef struct pq_queue {
	TAILQ_HEAD(, pq_list)	 pq_queue; /* queue of priority lists */
	pq_list_t		*pq_lists; /* array of all priority lists */
	int			 pq_size;  /* number of priority lists */
} pq_queue_t;


/*
 * TailQ initialization values.
 */
#define TAILQ_INITIALIZER	{ NULL, NULL }

/* 
 * Mutex definitions.
 */
union pthread_mutex_data {
	void	*m_ptr;
	int	m_count;
};

struct pthread_mutex {
	enum pthread_mutextype		m_type;
	int				m_protocol;
	V_TAILQ_HEAD(mutex_head, pthread)	m_queue;
	struct pthread			*m_owner;
	union pthread_mutex_data	m_data;
	long				m_flags;
	int				m_refcount;

	/*
	 * Used for priority inheritence and protection.
	 *
	 *   m_prio       - For priority inheritence, the highest active
	 *                  priority (threads locking the mutex inherit
	 *                  this priority).  For priority protection, the
	 *                  ceiling priority of this mutex.
	 *   m_saved_prio - mutex owners inherited priority before
	 *                  taking the mutex, restored when the owner
	 *                  unlocks the mutex.
	 */
	int				m_prio;
	int				m_saved_prio;

	/*
	 * Link for list of all mutexes a thread currently owns.
	 */
	V_TAILQ_ENTRY(pthread_mutex volatile)	m_qe;

	/*
	 * Lock for accesses to this structure.
	 */
	spinlock_t			lock;
};

/*
 * Flags for mutexes.
 */
#define MUTEX_FLAGS_PRIVATE	0x01
#define MUTEX_FLAGS_INITED	0x02
#define MUTEX_FLAGS_BUSY	0x04

/*
 * Static mutex initialization values.
 */
#define PTHREAD_MUTEX_STATIC_INITIALIZER   \
	{ PTHREAD_MUTEX_DEFAULT, PTHREAD_PRIO_NONE, TAILQ_INITIALIZER, \
	NULL, { NULL }, MUTEX_FLAGS_PRIVATE, 0, 0, 0, TAILQ_INITIALIZER, \
	_SPINLOCK_INITIALIZER }

struct pthread_mutex_attr {
	enum pthread_mutextype	m_type;
	int			m_protocol;
	int			m_ceiling;
	long			m_flags;
};

#define PTHREAD_MUTEXATTR_STATIC_INITIALIZER \
	{ PTHREAD_MUTEX_DEFAULT, PTHREAD_PRIO_NONE, 0, MUTEX_FLAGS_PRIVATE }

/* 
 * Condition variable definitions.
 */
enum pthread_cond_type {
	COND_TYPE_FAST,
	COND_TYPE_MAX
};

struct pthread_cond {
	enum pthread_cond_type		c_type;
	V_TAILQ_HEAD(cond_head, pthread) c_queue;
	pthread_mutex_t			c_mutex;
	long				c_flags;
	int				c_seqno;

	/*
	 * Lock for accesses to this structure.
	 */
	spinlock_t			lock;
};

struct pthread_cond_attr {
	enum pthread_cond_type	c_type;
	long			c_flags;
};

/*
 * Flags for condition variables.
 */
#define COND_FLAGS_PRIVATE	0x01
#define COND_FLAGS_INITED	0x02
#define COND_FLAGS_BUSY		0x04

/*
 * Static cond initialization values.
 */
#define PTHREAD_COND_STATIC_INITIALIZER    \
	{ COND_TYPE_FAST, TAILQ_INITIALIZER, NULL, NULL, \
	0, 0, _SPINLOCK_INITIALIZER }

/*
 * Semaphore definitions.
 */
struct sem {
#define	SEM_MAGIC	((u_int32_t) 0x09fa4012)
	u_int32_t	magic;
	pthread_mutex_t	lock;
	pthread_cond_t	gtzero;
	u_int32_t	count;
	u_int32_t	nwaiters;
};

/*
 * Cleanup definitions.
 */
struct pthread_cleanup {
	struct pthread_cleanup	*next;
	void			(*routine)(void*);
	void			*routine_arg;
};

struct pthread_atfork {
	TAILQ_ENTRY(pthread_atfork) qe;
	void (*prepare)(void);
	void (*parent)(void);
	void (*child)(void);
};

struct pthread_attr {
	int	sched_policy;
	int	sched_inherit;
	int	sched_interval;
	int	prio;
	int	suspend;
	int	flags;
	void	*arg_attr;
	void	(*cleanup_attr)(void*);
	void	*stackaddr_attr;
	size_t	stacksize_attr;
	size_t	guardsize_attr;
};

/*
 * Thread creation state attributes.
 */
#define PTHREAD_CREATE_RUNNING			0
#define PTHREAD_CREATE_SUSPENDED		1

/*
 * Additional state for a thread suspended with pthread_suspend_np().
 */
enum pthread_susp {
	SUSP_NO,	/* Not suspended. */
	SUSP_YES,	/* Suspended. */
	SUSP_JOIN,	/* Suspended, joining. */
	SUSP_NOWAIT,	/* Suspended, was in a mutex or condition queue. */
	SUSP_MUTEX_WAIT,/* Suspended, still in a mutex queue. */
	SUSP_COND_WAIT	/* Suspended, still in a condition queue. */
};

/*
 * Miscellaneous definitions.
 */
#ifdef __LP64__
#define PTHREAD_STACK_DEFAULT			(512 * 1024)
#else
#define PTHREAD_STACK_DEFAULT			(256 * 1024)
#endif

/*
 * Maximum size of initial thread's stack.  This perhaps deserves to be larger
 * than the stacks of other threads, since many applications are likely to run
 * almost entirely on this stack.
 */
#define PTHREAD_STACK_INITIAL			0x100000

/*
 * Define the different priority ranges.  All applications have thread
 * priorities constrained within 0-31.  The threads library raises the
 * priority when delivering signals in order to ensure that signal
 * delivery happens (from the POSIX spec) "as soon as possible".
 * In the future, the threads library will also be able to map specific
 * threads into real-time (cooperating) processes or kernel threads.
 * The RT and SIGNAL priorities will be used internally and added to
 * thread base priorities so that the scheduling queue can handle both
 * normal and RT priority threads with and without signal handling.
 *
 * The approach taken is that, within each class, signal delivery
 * always has priority over thread execution.
 */
#define PTHREAD_DEFAULT_PRIORITY		15
#define PTHREAD_MIN_PRIORITY			0
#define PTHREAD_MAX_PRIORITY			31	/* 0x1F */
#define PTHREAD_SIGNAL_PRIORITY			32	/* 0x20 */
#define PTHREAD_RT_PRIORITY			64	/* 0x40 */
#define PTHREAD_FIRST_PRIORITY			PTHREAD_MIN_PRIORITY
#define PTHREAD_LAST_PRIORITY	\
	(PTHREAD_MAX_PRIORITY + PTHREAD_SIGNAL_PRIORITY + PTHREAD_RT_PRIORITY)
#define PTHREAD_BASE_PRIORITY(prio)	((prio) & PTHREAD_MAX_PRIORITY)

/*
 * Clock resolution in microseconds.
 */
#define CLOCK_RES_USEC				10000
#define CLOCK_RES_USEC_MIN			1000

/*
 * Time slice period in microseconds.
 */
#define TIMESLICE_USEC				20000

/*
 * Define a thread-safe macro to get the current time of day
 * which is updated at regular intervals by the scheduling signal
 * handler.
 */
#define	GET_CURRENT_TOD(tv)				\
	do {						\
		tv.tv_sec = _sched_tod.tv_sec;		\
		tv.tv_usec = _sched_tod.tv_usec;	\
	} while (tv.tv_sec != _sched_tod.tv_sec)


struct pthread_key {
	spinlock_t	lock;
	volatile int	allocated;
	volatile int	count;
	void            (*destructor)(void*);
};

struct pthread_rwlockattr {
	int		pshared;
};

struct pthread_rwlock {
	pthread_mutex_t	lock;	/* monitor lock */
	int		state;	/* 0 = idle  >0 = # of readers  -1 = writer */
	pthread_cond_t	read_signal;
	pthread_cond_t	write_signal;
	int		blocked_writers;
};

/*
 * Thread states.
 */
enum pthread_state {
	PS_RUNNING,
	PS_SIGTHREAD,
	PS_MUTEX_WAIT,
	PS_COND_WAIT,
	PS_FDLR_WAIT,
	PS_FDLW_WAIT,
	PS_FDR_WAIT,
	PS_FDW_WAIT,
	PS_FILE_WAIT,
	PS_POLL_WAIT,
	PS_SELECT_WAIT,
	PS_SLEEP_WAIT,
	PS_WAIT_WAIT,
	PS_SIGSUSPEND,
	PS_SIGWAIT,
	PS_SPINBLOCK,
	PS_JOIN,
	PS_SUSPENDED,
	PS_DEAD,
	PS_DEADLOCK,
	PS_KEVENT_WAIT,
	PS_CONNECT_WAIT,
	PS_STATE_MAX
};


/*
 * File descriptor locking definitions.
 */
#define FD_READ		0x1
#define FD_WRITE	0x2
#define FD_RDWR		(FD_READ | FD_WRITE)
#define FD_RDWR_CLOSE	(FD_RDWR | 0x4)

#define _FD_LOCK(_fd,_type,_ts)	_thread_fd_lock(_fd, _type, _ts)
#define _FD_UNLOCK(_fd,_type)	_thread_fd_unlock(_fd, _type)

/* Get a suitable argument for _thread_kern_set_timeout(), given an fd */
#define _FD_RCVTIMEO(_fd)	_thread_fd_timeout((_fd), 0)
#define _FD_SNDTIMEO(_fd)	_thread_fd_timeout((_fd), 1)

/*
 * File status flags structure - shared for dup'ed fd's
 */
struct fs_flags {
	int			flags;
#define _FD_NOTSOCK	O_EXCL		/* Not a socket. */
	int			refcnt;
	SLIST_ENTRY(fs_flags)	fe;     /* free list entry. */
};

/*
 * fd_table_entry states
 */
enum fd_entry_state {
	FD_ENTRY_OPEN,
	FD_ENTRY_CLOSING,
	FD_ENTRY_CLOSED
};

/*
 * Defines for _thread_fd_table_init init_mode
 */
enum fd_entry_mode {
	FD_INIT_UNKNOWN,	/* inherited or not created by pthreads wrapper */
	FD_INIT_NEW,		/* new fd opened by pthreads */
	FD_INIT_BLOCKING,	/* new user blocking fd opened by pthreads */
	FD_INIT_DUP,		/* new fd with passed flags */
	FD_INIT_DUP2,		/* replace status_flags and open */
};

/*
 * File descriptor table structure.
 */
struct fd_table_entry {
	_thread_list_t		r_queue;	/* Read queue.                */
	_thread_list_t		w_queue;	/* Write queue.               */
	struct pthread		*r_owner;	/* thread owning read lock.   */
	struct pthread		*w_owner;	/* thread owning write lock.  */
	const char		*r_fname;	/* read lock source file name */
	int			r_lineno;	/* Read lock source line no.  */
	const char		*w_fname;	/* write lock src file name   */
	int			w_lineno;	/* Write lock src line no.    */
	int			r_lockcount;	/* Count for FILE read locks. */
	int			w_lockcount;	/* Count for FILE write locks.*/
	struct fs_flags		*status_flags;	/* Shared file status flags.  */
	enum fd_entry_state	state;		/* Open, closing, or closed.  */
	enum fd_entry_mode	init_mode;	/* The mode used for init.    */
	SLIST_ENTRY(fd_table_entry) fe;		/* Free list entry.           */
};

struct pthread_poll_data {
	nfds_t	nfds;
	struct pollfd *fds;
};

union pthread_wait_data {
	pthread_mutex_t	mutex;
	pthread_cond_t	cond;
	const sigset_t	*sigwait;	/* Waiting on a signal in sigwait */
	struct {
		int		fd;	/* Used when thread waiting on fd */
		int		branch;	/* Line number, for debugging.    */
		const char	*fname;	/* Source file name for debugging.*/
	} fd;
	FILE		*fp;
	struct pthread_poll_data *poll_data;
	spinlock_t	*spinlock;
	struct pthread	*thread;
};

/* Spare thread stack. */
struct stack {
	SLIST_ENTRY(stack)	qe; /* Queue entry for this stack. */
	void 			*base;		/* Bottom of useful stack */
	size_t			size;		/* Size of useful stack */
	size_t			guardsize;	/* Size of red zone */
	void			*redzone;	/* Red zone location */
	void 			*storage;	/* allocated storage */
};

/*
 * Define a continuation routine that can be used to perform a
 * transfer of control:
 */
typedef void	(*thread_continuation_t) (struct pthread *);

typedef V_TAILQ_ENTRY(pthread) pthread_entry_t;

struct join_status {
	struct pthread	*thread;
	void		*ret;
	int		error;
};

/*
 * Thread structure.
 */
struct pthread {
	/*
	 * Magic value to help recognize a valid thread structure
	 * from an invalid one:
	 */
#define	PTHREAD_MAGIC		((u_int32_t) 0xd09ba115)
	u_int32_t		magic;
	char			*name;

	/*
	 * Lock for accesses to this thread structure.
	 */
	spinlock_t		lock;

	/* Queue entry for list of all threads: */
	pthread_entry_t		tle;

	/* Queue entry for list of dead threads: */
	pthread_entry_t		dle;

	/*
	 * Thread start routine, argument, stack pointer and thread
	 * attributes.
	 */
	void			*(*start_routine)(void *);
	void			*arg;
	struct stack		*stack;
	struct pthread_attr	attr;

	/*
	 * Saved signal context used in call to sigreturn by
	 * _thread_kern_sched if sig_saved is TRUE.
	 */
	struct  sigcontext saved_sigcontext;

	/*
	 * Machine-dependent context, valid if sig_saved is FALSE.
	 */
	struct _machdep_state	_machdep;

	/*
	 * TRUE if the last state saved was a signal context. FALSE if the
	 * last state saved was a jump buffer.
	 */
	int	sig_saved;

	/*
	 * Cancelability flags - the lower 2 bits are used by cancel
	 * definitions in pthread.h
	 */
#define PTHREAD_AT_CANCEL_POINT		0x0004
#define PTHREAD_CANCELLING		0x0008
#define PTHREAD_CANCEL_NEEDED		0x0010
	int	cancelflags;

	enum pthread_susp	suspended;

	thread_continuation_t	continuation;

	/*
	 * Current signal mask and pending signals.
	 */
	sigset_t	sigmask;
	sigset_t	sigpend;

	/* Thread state: */
	enum pthread_state	state;

	/* Scheduling clock when this thread was last made active. */
	long	last_active;

	/* Scheduling clock when this thread was last made inactive. */
	long	last_inactive;

	/*
	 * Number of microseconds accumulated by this thread when
	 * time slicing is active.
	 */
	long	slice_usec;

	/*
	 * Time to wake up thread. This is used for sleeping threads and
	 * for any operation which may time out (such as select).
	 */
	struct timespec	wakeup_time;

	/* TRUE if operation has timed out. */
	int	timeout;

	/*
	 * Error variable used instead of errno. The function __error()
	 * returns a pointer to this.
	 */
	int	error;

	/*
	 * The joiner is the thread that is joining to this thread.  The
	 * join status keeps track of a join operation to another thread.
	 */
	struct pthread		*joiner;
	struct join_status	join_status;

	/*
	 * The current thread can belong to only one scheduling queue at
	 * a time (ready or waiting queue).  It can also belong to:
	 *
	 *   o A queue of threads waiting for a mutex
	 *   o A queue of threads waiting for a condition variable
	 *   o A queue of threads waiting for a file descriptor lock
	 *   o A queue of threads needing work done by the kernel thread
	 *     (waiting for a spinlock or file I/O)
	 *
	 * A thread can also be joining a thread (the joiner field above).
	 *
	 * It must not be possible for a thread to belong to any of the
	 * above queues while it is handling a signal.  Signal handlers
	 * may longjmp back to previous stack frames circumventing normal
	 * control flow.  This could corrupt queue integrity if the thread
	 * retains membership in the queue.  Therefore, if a thread is a
	 * member of one of these queues when a signal handler is invoked,
	 * it must remove itself from the queue before calling the signal
	 * handler and reinsert itself after normal return of the handler.
	 *
	 * Use pqe for the scheduling queue link (both ready and waiting),
	 * sqe for synchronization (mutex and condition variable) queue
	 * links, and qe for all other links.
	 */

	pthread_entry_t		pqe;	/* priority queue link */
	pthread_entry_t		sqe;	/* synchronization queue link */
	pthread_entry_t		qe;	/* all other queues link */

	/* Wait data. */
	union pthread_wait_data data;

	/*
	 * Allocated for converting select into poll.
	 */
	struct pthread_poll_data poll_data;

	/*
	 * Set to TRUE if a blocking operation was
	 * interrupted by a signal:
	 */
	int		interrupted;

	/*
	 * Set to TRUE if a blocking operation was
	 * interrupted by a closing file descriptor.
	 */
	int		closing_fd;

	/* Signal number when in state PS_SIGWAIT: */
	int		signo;

	/*
	 * Set to non-zero when this thread has deferred signals.
	 * We allow for recursive deferral.
	 */
	int		sig_defer_count;

	/*
	 * Set to TRUE if this thread should yield after undeferring
	 * signals.
	 */
	int		yield_on_sig_undefer;

	/* Miscellaneous flags; only set with signals deferred. */
	int		flags;
#define PTHREAD_FLAGS_PRIVATE	0x0001
#define PTHREAD_EXITING		0x0002
#define PTHREAD_FLAGS_IN_WAITQ	0x0004	/* in waiting queue using pqe link */
#define PTHREAD_FLAGS_IN_PRIOQ	0x0008	/* in priority queue using pqe link */
#define PTHREAD_FLAGS_IN_WORKQ	0x0010	/* in work queue using qe link */
#define PTHREAD_FLAGS_IN_FILEQ	0x0020	/* in file lock queue using qe link */
#define PTHREAD_FLAGS_IN_FDQ	0x0040	/* in fd lock queue using qe link */
#define PTHREAD_FLAGS_IN_CONDQ	0x0080	/* in condition queue using sqe link */
#define PTHREAD_FLAGS_IN_MUTEXQ	0x0100	/* in mutex queue using sqe link */
#define PTHREAD_FLAGS_TRACE	0x0200	/* for debugging purposes */
#define PTHREAD_FLAGS_IN_SYNCQ	\
    (PTHREAD_FLAGS_IN_CONDQ | PTHREAD_FLAGS_IN_MUTEXQ)

	/*
	 * Base priority is the user setable and retrievable priority
	 * of the thread.  It is only affected by explicit calls to
	 * set thread priority and upon thread creation via a thread
	 * attribute or default priority.
	 */
	int		base_priority;

	/*
	 * Inherited priority is the priority a thread inherits by
	 * taking a priority inheritence or protection mutex.  It
	 * is not affected by base priority changes.  Inherited
	 * priority defaults to and remains 0 until a mutex is taken
	 * that is being waited on by any other thread whose priority
	 * is non-zero.
	 */
	int		inherited_priority;

	/*
	 * Active priority is always the maximum of the threads base
	 * priority and inherited priority.  When there is a change
	 * in either the base or inherited priority, the active
	 * priority must be recalculated.
	 */
	int		active_priority;

	/* Number of priority ceiling or protection mutexes owned. */
	int		priority_mutex_count;

	/* Number rwlocks rdlocks held. */
	int			rdlock_count;

	/*
	 * Queue of currently owned mutexes.
	 */
	V_TAILQ_HEAD(, pthread_mutex volatile)	mutexq;

	void		*ret;
	const void	**specific_data;
	int		specific_data_count;

	/* Cleanup handlers Link List */
	struct pthread_cleanup *cleanup;
	const char		*fname;	/* Ptr to source file name  */
	int			lineno;	/* Source line number.      */
};

/*
 * Flags and prototypes for the machine dependent layer
 */
void _thread_machdep_switch(struct _machdep_state *newstate, 
        struct _machdep_state *savestate);
void _thread_machdep_init(struct _machdep_state *state, void *stackbase, 
        int stacksize, void (*entry)(void));
void _thread_machdep_save_float_state(struct _machdep_state* statep);
void _thread_machdep_restore_float_state(struct _machdep_state* statep);

/*
 * Global variables for the uthread kernel.
 */

/* Kernel thread structure used when there are no running threads: */
SCLASS struct pthread	_thread_kern_thread;

/* Ptr to the thread structure for the running thread: */
SCLASS struct pthread	* volatile _thread_run
#ifdef GLOBAL_PTHREAD_PRIVATE
= &_thread_kern_thread;
#else
;
#endif

/* Ptr to the thread structure for the last user thread to run: */
SCLASS struct pthread	* volatile _last_user_thread
#ifdef GLOBAL_PTHREAD_PRIVATE
= &_thread_kern_thread;
#else
;
#endif

/*
 * Ptr to the thread running in single-threaded mode or NULL if
 * running multi-threaded (default POSIX behaviour).
 */
SCLASS struct pthread	* volatile _thread_single
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL;
#else
;
#endif

SCLASS _thread_list_t		_thread_list
#ifdef GLOBAL_PTHREAD_PRIVATE
= TAILQ_HEAD_INITIALIZER(_thread_list);
#else
;
#endif

/*
 * Array of kernel pipe file descriptors that are used to ensure that
 * no signals are missed in calls to _select.
 */
SCLASS int		_thread_kern_pipe[2]
#ifdef GLOBAL_PTHREAD_PRIVATE
= {
	-1,
	-1
};
#else
;
#endif
SCLASS int		volatile _queue_signals
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif
SCLASS int		volatile _thread_kern_in_sched
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

SCLASS int		_sig_in_handler
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

/* Time of day at last scheduling timer signal: */
SCLASS struct timeval volatile	_sched_tod
#ifdef GLOBAL_PTHREAD_PRIVATE
= { 0, 0 };
#else
;
#endif

/*
 * Current scheduling timer ticks; used as resource usage.
 */
SCLASS unsigned int volatile	_sched_ticks
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

/* Dead threads: */
SCLASS _thread_list_t		_dead_list
#ifdef GLOBAL_PTHREAD_PRIVATE
= TAILQ_HEAD_INITIALIZER(_dead_list);
#else
;
#endif

/* Initial thread: */
SCLASS struct pthread *_thread_initial
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL;
#else
;
#endif

SCLASS TAILQ_HEAD(atfork_head, pthread_atfork)	_atfork_list;
SCLASS pthread_mutex_t		_atfork_mutex;

/* Default thread attributes: */
SCLASS struct pthread_attr pthread_attr_default
#ifdef GLOBAL_PTHREAD_PRIVATE
= { SCHED_RR, 0, TIMESLICE_USEC, PTHREAD_DEFAULT_PRIORITY,
	PTHREAD_CREATE_RUNNING, PTHREAD_CREATE_JOINABLE, NULL, NULL, NULL,
	PTHREAD_STACK_DEFAULT, 0 /* set in _thread_init() */ };
#else
;
#endif

/* Default mutex attributes: */
SCLASS struct pthread_mutex_attr pthread_mutexattr_default
#ifdef GLOBAL_PTHREAD_PRIVATE
= { PTHREAD_MUTEX_DEFAULT, PTHREAD_PRIO_NONE, 0, 0 };
#else
;
#endif

/* Default condition variable attributes: */
SCLASS struct pthread_cond_attr pthread_condattr_default
#ifdef GLOBAL_PTHREAD_PRIVATE
= { COND_TYPE_FAST, 0 };
#else
;
#endif

/* File table information: */
SCLASS struct fd_table_entry **_thread_fd_table
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL;
#else
;
#endif

/* Table for polling file descriptors: */
SCLASS struct pollfd *_thread_pfd_table
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL;
#else
;
#endif

SCLASS int    _thread_init_fdtsize	/* Initial fd/pfd table size.	*/
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

SCLASS int    _thread_max_fdtsize	/* Max fd table size.	*/
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

SCLASS nfds_t _thread_max_pfdtsize	/* Max pfd table size.	*/
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0;
#else
;
#endif

SCLASS int    _clock_res_usec		/* Clock resolution in usec.	*/
#ifdef GLOBAL_PTHREAD_PRIVATE
= CLOCK_RES_USEC;
#else
;
#endif

/* Garbage collector mutex and condition variable. */
SCLASS	pthread_mutex_t _gc_mutex
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL
#endif
;
SCLASS	pthread_cond_t  _gc_cond
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL
#endif
;

/*
 * Array of signal actions for this process.
 */
SCLASS struct  sigaction _thread_sigact[NSIG];

/*
 * Array of counts of dummy handlers for SIG_DFL signals.  This is used to
 * assure that there is always a dummy signal handler installed while there is a
 * thread sigwait()ing on the corresponding signal.
 */
SCLASS int	_thread_dfl_count[NSIG];

/*
 * Pending signals and mask for this process:
 */
SCLASS sigset_t		_process_sigpending;
SCLASS sigset_t		_process_sigmask
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0
#endif
;

/*
 * Scheduling queues:
 */
SCLASS pq_queue_t		_readyq;
SCLASS _thread_list_t		_waitingq;

/*
 * Work queue:
 */
SCLASS _thread_list_t		_workq;

/* Tracks the number of threads blocked while waiting for a spinlock. */
SCLASS volatile int	_spinblock_count
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0
#endif
;

/* Used to maintain pending and active signals: */
struct sigstatus {
	spinlock_t	lock;		/* structure access lock */
	int		pending;	/* Is this a pending signal? */
	siginfo_t	siginfo;	/* arg 2 to signal handler */
};

SCLASS struct sigstatus	_thread_sigq[NSIG];

/* Indicates that the signal queue needs to be checked. */
SCLASS volatile int	_sigq_check_reqd
#ifdef GLOBAL_PTHREAD_PRIVATE
= 0
#endif
;

/* The signal stack. */
SCLASS struct sigaltstack _thread_sigstack;

/* Thread switch hook. */
SCLASS pthread_switch_routine_t _sched_switch_hook
#ifdef GLOBAL_PTHREAD_PRIVATE
= NULL
#endif
;

/*
 * Spare stack queue.  Stacks of default size are cached in order to reduce
 * thread creation time.  Spare stacks are used in LIFO order to increase cache
 * locality.
 */
typedef SLIST_HEAD(, stack)	_stack_list_t;
extern _stack_list_t		_stackq;

/* Used for _PTHREADS_INVARIANTS checking. */
SCLASS int	_thread_kern_new_state
#ifdef GLOBAL_PTHREAD_PRIVATE 
= 0;
#else
;
#endif

/* Undefine the storage class specifier: */
#undef SCLASS

/*
 * Function prototype definitions.
 */
__BEGIN_DECLS
int	*__error(void);
int     _find_thread(pthread_t);
struct pthread *_get_curthread(void);
void	_set_curthread(struct pthread *);
int     _thread_create(pthread_t *, const pthread_attr_t *,
		       void *(*start_routine)(void *), void *,pthread_t);
void    _dispatch_signal(int, struct sigcontext *);
void    _dispatch_signals(struct sigcontext *);
void    _thread_signal(pthread_t, int);
void	_thread_nonblock_fds(void);
int	_mutex_cv_lock(pthread_mutex_t *);
int	_mutex_cv_unlock(pthread_mutex_t *);
int	_mutex_reinit(pthread_mutex_t *);
void	_mutex_notify_priochange(struct pthread *);
int	_cond_reinit(pthread_cond_t *);
int	_pq_alloc(struct pq_queue *, int, int);
int	_pq_init(struct pq_queue *);
void	_pq_remove(struct pq_queue *pq, struct pthread *);
void	_pq_insert_head(struct pq_queue *pq, struct pthread *);
void	_pq_insert_tail(struct pq_queue *pq, struct pthread *);
struct pthread *_pq_first(struct pq_queue *pq);
void	_waitq_insert(pthread_t pthread);
void	_waitq_remove(pthread_t pthread);
#if defined(_PTHREADS_INVARIANTS)
void	_waitq_setactive(void);
void	_waitq_clearactive(void);
#endif
__dead void _thread_exit(const char *, int, const char *) __attribute__((__noreturn__));
void    *_thread_cleanup(pthread_t);
void    _thread_cleanupspecific(void);
void	_thread_clear_pending(int, pthread_t);
void	_thread_dump_data(const void *, int);
void    _thread_dump_info(void);
int	_thread_fd_lock(int, int, struct timespec *);
void	_thread_fd_unlock(int, int);
struct timespec	*_thread_fd_timeout(int, int);
void    _thread_init(void);
void	_thread_kern_lock(int);
void    _thread_kern_sched(struct sigcontext *);
void    _thread_kern_sched_state(enum pthread_state, const char *, int);
void	_thread_kern_sched_state_unlock(enum pthread_state, spinlock_t *,
					const char *, int);
void    _thread_kern_set_timeout(const struct timespec *);
void    _thread_kern_sig_defer(void);
void    _thread_kern_sig_undefer(void);
void	_thread_key_init(void);
void	_thread_kill_siginfo(int);
void    _thread_sig_handler(int, siginfo_t *, struct sigcontext *);
int	_thread_sig_handle(int, struct sigcontext *);
void	_thread_sig_init(void);
void    _thread_start(void);
void    _thread_start_sig_handler(void);
void	_thread_seterrno(pthread_t,int);
void	_thread_fs_flags_replace(int, struct fs_flags *);
int	_thread_fd_init_mem(void);
void	_thread_fd_init(void);
int     _thread_fd_table_init(int, enum fd_entry_mode, struct fs_flags *);
void	_thread_fd_entry_close(int);
pthread_addr_t _thread_gc(pthread_addr_t);
void	_thread_enter_cancellation_point(void);
void	_thread_leave_cancellation_point(void);
void	_thread_cancellation_point(void);
int	_thread_slow_atomic_lock(volatile _spinlock_lock_t *);
int	_thread_slow_atomic_is_locked(volatile _spinlock_lock_t *);
struct stack * _thread_stack_alloc(void *, size_t, size_t);
void	_thread_stack_free(struct stack *);


/* #include <signal.h> */
#ifdef _USER_SIGNAL_H
int	_thread_sys_kill(pid_t, int);
int     _thread_sys_sigaction(int, const struct sigaction *, struct sigaction *);
int	_thread_sys_sigblock(int);
int	_thread_sys_sigsetmask(int);
int     _thread_sys_sigpending(sigset_t *);
int     _thread_sys_sigprocmask(int, const sigset_t *, sigset_t *);
int     _thread_sys_sigsuspend(const sigset_t *);
int     _thread_sys_siginterrupt(int, int);
int     _thread_sys_sigpause(int);
int     _thread_sys_sigreturn(struct sigcontext *);
int     _thread_sys_sigaltstack(const struct sigaltstack *, struct sigaltstack *);
int     _thread_sys_sigvec(int, struct sigvec *, struct sigvec *);
void    _thread_sys_psignal(unsigned int, const char *);
void    (*_thread_sys_signal(int, void (*)(int)))(int);
#endif

/* #include <sys/stat.h> */
#ifdef  _SYS_STAT_H_
int     _thread_sys_fchmod(int, mode_t);
int     _thread_sys_fstat(int, struct stat *);
int     _thread_sys_fchflags(int, unsigned int);
#endif

/* #include <sys/mount.h> */
#ifdef  _SYS_MOUNT_H_
int     _thread_sys_fstatfs(int, struct statfs *);
#endif
int     _thread_sys_pipe(int *);

/* #include <sys/socket.h> */
#ifdef  _SYS_SOCKET_H_
int     _thread_sys_accept(int, struct sockaddr *, socklen_t *);
int     _thread_sys_bind(int, const struct sockaddr *, socklen_t);
int     _thread_sys_connect(int, const struct sockaddr *, socklen_t);
int     _thread_sys_getpeername(int, struct sockaddr *, socklen_t *);
int     _thread_sys_getsockname(int, struct sockaddr *, socklen_t *);
int     _thread_sys_getsockopt(int, int, int, void *, socklen_t *);
int     _thread_sys_listen(int, int);
int     _thread_sys_setsockopt(int, int, int, const void *, socklen_t);
int     _thread_sys_shutdown(int, int);
int     _thread_sys_socket(int, int, int);
int     _thread_sys_socketpair(int, int, int, int *);
ssize_t _thread_sys_recv(int, void *, size_t, int);
ssize_t _thread_sys_recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *);
ssize_t _thread_sys_recvmsg(int, struct msghdr *, int);
ssize_t _thread_sys_send(int, const void *, size_t, int);
ssize_t _thread_sys_sendmsg(int, const struct msghdr *, int);
ssize_t _thread_sys_sendto(int, const void *,size_t, int, const struct sockaddr *, socklen_t);
#endif

/* #include <stdio.h> */
#ifdef  _STDIO_H_
FILE    *_thread_sys_fdopen(int, const char *);
FILE    *_thread_sys_fopen(const char *, const char *);
FILE    *_thread_sys_freopen(const char *, const char *, FILE *);
FILE    *_thread_sys_popen(const char *, const char *);
FILE    *_thread_sys_tmpfile(void);
char    *_thread_sys_ctermid(char *);
char    *_thread_sys_cuserid(char *);
char    *_thread_sys_fgetln(FILE *, size_t *);
char    *_thread_sys_fgets(char *, int, FILE *);
char    *_thread_sys_gets(char *);
char    *_thread_sys_tempnam(const char *, const char *);
char    *_thread_sys_tmpnam(char *);
int     _thread_sys_fclose(FILE *);
int     _thread_sys_feof(FILE *);
int     _thread_sys_ferror(FILE *);
int     _thread_sys_fflush(FILE *);
int     _thread_sys_fgetc(FILE *);
int     _thread_sys_fgetpos(FILE *, fpos_t *);
int     _thread_sys_fileno(FILE *);
int     _thread_sys_fprintf(FILE *, const char *, ...);
int     _thread_sys_fpurge(FILE *);
int     _thread_sys_fputc(int, FILE *);
int     _thread_sys_fputs(const char *, FILE *);
int     _thread_sys_fscanf(FILE *, const char *, ...);
int     _thread_sys_fseek(FILE *, long, int);
int     _thread_sys_fsetpos(FILE *, const fpos_t *);
int     _thread_sys_getc(FILE *);
int     _thread_sys_getchar(void);
int     _thread_sys_getw(FILE *);
int     _thread_sys_pclose(FILE *);
int     _thread_sys_printf(const char *, ...);
int     _thread_sys_putc(int, FILE *);
int     _thread_sys_putchar(int);
int     _thread_sys_puts(const char *);
int     _thread_sys_putw(int, FILE *);
int     _thread_sys_remove(const char *);
int     _thread_sys_rename (const char *, const char *);
int     _thread_sys_scanf(const char *, ...);
int     _thread_sys_setlinebuf(FILE *);
int     _thread_sys_setvbuf(FILE *, char *, int, size_t);
int     _thread_sys_snprintf(char *, size_t, const char *, ...);
int     _thread_sys_sprintf(char *, const char *, ...);
int     _thread_sys_sscanf(const char *, const char *, ...);
int     _thread_sys_ungetc(int, FILE *);
int     _thread_sys_vfprintf(FILE *, const char *, __va_list);
int     _thread_sys_vprintf(const char *, __va_list);
int     _thread_sys_vscanf(const char *, __va_list);
int     _thread_sys_vsnprintf(char *, size_t, const char *, __va_list);
int     _thread_sys_vsprintf(char *, const char *, __va_list);
int     _thread_sys_vsscanf(const char *, const char *, __va_list);
long    _thread_sys_ftell(FILE *);
size_t  _thread_sys_fread(void *, size_t, size_t, FILE *);
size_t  _thread_sys_fwrite(const void *, size_t, size_t, FILE *);
void    _thread_sys_clearerr(FILE *);
void    _thread_sys_perror(const char *);
void    _thread_sys_rewind(FILE *);
void    _thread_sys_setbuf(FILE *, char *);
void    _thread_sys_setbuffer(FILE *, char *, int);
#endif

/* #include <unistd.h> */
#ifdef  _UNISTD_H_
char    *_thread_sys_ttyname(int);
int     _thread_sys_close(int);
int     _thread_sys_closefrom(int);
int     _thread_sys_dup(int);
int     _thread_sys_dup2(int, int);
int     _thread_sys_exect(const char *, char * const *, char * const *);
int     _thread_sys_execve(const char *, char * const *, char * const *);
int     _thread_sys_fchdir(int);
int     _thread_sys_fchown(int, uid_t, gid_t);
int     _thread_sys_fsync(int);
int     _thread_sys_ftruncate(int, off_t);
long	_thread_sys_fpathconf(int, int);
pid_t	_thread_sys_getpid(void);
int     _thread_sys_pipe(int *);
ssize_t	_thread_sys_pread(int, void *, size_t, off_t);
ssize_t	_thread_sys_pwrite(int, const void *, size_t, off_t);
int     _thread_sys_select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
off_t   _thread_sys_lseek(int, off_t, int);
pid_t   _thread_sys_fork(void);
pid_t   _thread_sys_vfork(void);
pid_t   _thread_sys_tcgetpgrp(int);
ssize_t _thread_sys_read(int, void *, size_t);
ssize_t _thread_sys_write(int, const void *, size_t);
__dead void	_thread_sys__exit(int) __attribute__((__noreturn__));
#endif

/* #include <fcntl.h> */
#ifdef  _SYS_FCNTL_H_
int     _thread_sys_creat(const char *, mode_t);
int     _thread_sys_fcntl(int, int, ...);
int     _thread_sys_flock(int, int);
int     _thread_sys_open(const char *, int, ...);
int	_thread_sys_openat(int, const char *, int, ...);
#endif

/* #include <sys/ioctl.h> */
#ifdef  _SYS_IOCTL_H_
int     _thread_sys_ioctl(int, unsigned long, ...);
#endif

/* #include <dirent.h> */
#ifdef  _DIRENT_H_
DIR     *___thread_sys_opendir2(const char *, int);
DIR     *_thread_sys_opendir(const char *);
int     _thread_sys_alphasort(const void *, const void *);
int     _thread_sys_scandir(const char *, struct dirent ***,
	int (*)(struct dirent *), int (*)(const void *, const void *));
int     _thread_sys_closedir(DIR *);
int     _thread_sys_getdirentries(int, char *, int, off_t *);
long    _thread_sys_telldir(const DIR *);
struct  dirent *_thread_sys_readdir(DIR *);
void    _thread_sys_rewinddir(DIR *);
void    _thread_sys_seekdir(DIR *, long);
#endif

/* #include <sys/uio.h> */
#ifdef  _SYS_UIO_H_
ssize_t	_thread_sys_preadv(int, const struct iovec *, int, off_t);
ssize_t	_thread_sys_pwritev(int, const struct iovec *, int, off_t);
ssize_t	_thread_sys_readv(int, const struct iovec *, int);
ssize_t	_thread_sys_writev(int, const struct iovec *, int);
#endif

/* #include <sys/wait.h> */
#ifdef  _SYS_WAIT_H_
pid_t   _thread_sys_wait(int *);
pid_t   _thread_sys_waitpid(pid_t, int *, int);
pid_t   _thread_sys_wait3(int *, int, struct rusage *);
pid_t   _thread_sys_wait4(pid_t, int *, int, struct rusage *);
#endif

/* #include <poll.h> */
#ifdef _SYS_POLL_H_
int 	_thread_sys_poll(struct pollfd *, unsigned, int);
#endif

/* #include <sys/event.h> */
#ifdef _SYS_EVENT_H_
int	_thread_sys_kqueue(void);
int     _thread_sys_kevent(int, const struct kevent *, int, struct kevent *,
	int, const struct timespec *);
#endif

/* #include <sys/mman.h> */
int	_thread_sys_msync(void *, size_t, int);

__END_DECLS

#endif  /* !_PTHREAD_PRIVATE_H */
@


1.79
log
@Make openat(), pread(), preadv(), pwrite(), and pwritev() cancellation
points.

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.78 2011/10/07 08:59:42 fgsch Exp $	*/
@


1.78
log
@threads waiting on PS_FDW_WAIT state should not be interruptible if
SA_RESTART is set, with connect(2) being the exception thus getting its
own state.
as pointed by kurt, threads on this and PS_FDR_WAIT states need to be
set to PS_RUNNING since the current signal dispatching code only looks
at the current thread.
ok kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.77 2011/09/13 23:56:00 fgsch Exp $	*/
d1326 2
d1344 1
d1369 4
a1372 2
ssize_t _thread_sys_readv(int, const struct iovec *, int);
ssize_t _thread_sys_writev(int, const struct iovec *, int);
@


1.77
log
@For threads in PS_FDR_WAIT state, check SA_RESTART before marking it as
interrupted, thus simulating the system call restart behaviour in the
non-pthreads case.
Add a state for kevent since it shouldn't be restarted regardless of
SA_RESTART being present.
guenther@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.76 2010/10/28 15:02:41 millert Exp $	*/
d490 1
@


1.76
log
@Change basep parameter of getdirentries() to be off_t *, not long *
so it works correctly with large offsets (and matches other systems).
This requires adding a new getdirentries syscall, with the old one
renamed to ogetdirentries.  All in-tree consumers of getdirentries()
have been updated.  Bump libc and libpthread major numbers.
OK and with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.75 2010/07/13 03:10:29 guenther Exp $	*/
d489 1
@


1.75
log
@Fix PR 6376: restore more thread library state if execve fails,
including the scheduling timer, sigmask, fd nonblocking status, and
handling of the signals used by the thread library.

ok marc@@, additional testing by ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.74 2010/01/03 23:05:35 fgsch Exp $	*/
d1355 1
a1355 1
int     _thread_sys_getdirentries(int, char *, int, long *);
@


1.74
log
@Make SO_RCVTIMEO and SO_SNDTIMEO work with pthreads. Fixes at least some of
the issues seen with www/varnish.
With input and help from guenther@@ and kurt@@. guenther@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.73 2009/12/06 17:54:59 kurt Exp $	*/
d1135 1
@


1.73
log
@Make internal file descriptor handling async-signal safe by eliminating
the use of spinlocks and malloc. All needed memory is allocated upfront
and _thread_kern_sig_defer/undefer() is now used to protect critical
sections. okay guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.72 2009/10/27 20:06:29 deraadt Exp $	*/
d504 4
d509 1
a509 1
 * File status flags struture - shared for dup'ed fd's
d513 1
d1160 1
@


1.72
log
@define ENOTSUP EOPNOTSUPP is no longer needed
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.71 2009/04/21 12:43:01 kurt Exp $	*/
a507 1
	spinlock_t		lock;
d510 1
a536 7
	/*
	 * Lock for accesses to this file descriptor table
	 * entry. This is passed to _spinlock() to provide atomic
	 * access to this structure. It does *not* represent the
	 * state of the lock on the file descriptor.
	 */
	spinlock_t		lock;
d550 1
d1173 1
@


1.71
log
@Increase default thread stack size to 256K on 32bit archs and 512K on
64bit archs to accommodate the growing number of ports that put large
buffers on the stack. Supported by many with no objections.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.70 2008/12/18 09:30:32 guenther Exp $	*/
a63 5

/*
 * Workaround until we have ENOTSUP in errno.h
 */
#define ENOTSUP			EOPNOTSUPP
@


1.70
log
@Add pthread_attr_[sg]etguardsize() to match rthread, including manpages
Bump lib minor

ok otto@@ kurt@@ marc@@; doc review by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.69 2007/11/20 19:35:36 deraadt Exp $	*/
d391 6
a396 1
#define PTHREAD_STACK_DEFAULT			65536
@


1.69
log
@make pthread vfork() not call fork(), but actually call vfork().  our
vfork() has only one semantic: "parent stalls until child does execve
or exit" and no other semantic.  it is unfair to act as if pthread
vfork() suddenly lacks that semantic.
ok kurt millert kettenis beck
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.68 2007/07/20 22:34:40 kettenis Exp $	*/
d584 1
d961 1
a961 1
	PTHREAD_STACK_DEFAULT };
d1188 1
a1188 1
struct stack * _thread_stack_alloc(void *, size_t);
@


1.68
log
@Initialize the locks in key_table.  On hppa _SPINLOCK_LOCKED is 0, so an
uninitialized lock ends up in a locked state.  This lead to a deadlock if we
called pthread_key_create().

ok marc@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.67 2007/06/05 18:11:49 kurt Exp $	*/
d1324 1
@


1.67
log
@_FD_LOCK/UNLOCK() is libpthread specific and not needed for librthread, so
isolate its usage to libpthread only and replace with generic non-static
mutex support in the one place it is needed:
 - remove _FD_LOCK/UNLOCK from lseek and ftruncate in libc and make the
   functions weak so that libpthread can override with its own new
   versions that do the locking.
 - remove _thread_fd_lock/unlock() weak functions from libc and adjust
   libpthread for the change.
 - add generic _thread_mutex_lock/unlock/destroy() weak functions in libc
   to support non-static mutexes in libc and add libpthread and librthread
   implementations for them. libc can utilize non-static mutexes via the
   new _MUTEX_LOCK/UNLOCK/DESTROY() macros. Actually these new macros can
   support both static and non-static mutexes but currently only using
   them for non-static.
 - make opendir/closedir/readdir/readdir_r/seekdir/telldir() thread-safe
   for both thread libraries by using a non-static mutex in the struct
   _dirdesc (typedef DIR), utilizing it in the *dir functions and remove
   remaining and incorrect _FD_LOCK/UNLOCK() use in libc.
 - add comments to both thread libraries to indicate libc depends on the
   current implementation of static mutex initialization. suggested by
   marc@@
 - major bump libc and libpthread due to function removal, structure
   change and weak symbol conversions.
okay marc@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.66 2007/05/21 16:50:36 kurt Exp $	*/
d1169 1
@


1.66
log
@clean up lint warnings related to the nfds_t type. okay marc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.65 2007/05/01 14:54:27 kurt Exp $	*/
d494 1
a494 1
 * File descriptor locking definitions are defined in "thread_private.h"
d496 7
d1158 2
@


1.65
log
@file descriptors are ints. make branch an int too for better structure
allignment. okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.64 2007/04/27 20:44:43 kurt Exp $	*/
d55 1
d553 1
a553 1
	int	nfds;
d997 8
a1004 1
SCLASS int    _thread_max_fdtsize	/* Max fd/pfd table size.	*/
@


1.64
log
@more lint warning reductions. use int for all priority vars. okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.63 2007/04/27 19:40:08 kurt Exp $	*/
d561 2
a562 2
		short		fd;	/* Used when thread waiting on fd */
		short		branch;	/* Line number, for debugging.    */
@


1.63
log
@fix thread_continuation_t typedef and use passed curthread instead of
calling _get_curthread() again. fixes some lint warnings. okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.62 2007/04/27 18:04:08 kurt Exp $	*/
d785 1
a785 1
	char		base_priority;
d795 1
a795 1
	char		inherited_priority;
d803 1
a803 1
	char		active_priority;
@


1.62
log
@Remove unused function _thread_fd_unlock_owned() and
merge _thread_fd_unlock_thread() into _thread_fd_unlock(). okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.61 2007/04/27 12:59:24 kurt Exp $	*/
d584 1
a584 1
typedef void	(*thread_continuation_t) (void *);
@


1.61
log
@Use rlimit nofiles max to size fd/fdp tables instead of cur. Fixes
applications that increase nofiles using setrlimit(2). ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.60 2007/04/26 18:13:10 kurt Exp $	*/
a1162 2
void	_thread_fd_unlock_owned(pthread_t);
void	_thread_fd_unlock_thread(struct pthread	*, int, int);
@


1.60
log
@remove unused var. okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.59 2007/03/20 21:28:31 kurt Exp $	*/
d989 8
a996 1
SCLASS int    _thread_dtablesize	/* Descriptor table size.	*/
@


1.59
log
@Remove duplicate definition of _POSIX_THREAD_ATTR_STACKSIZE and quiet
build warnings noticed by david@@. okay millert@@ marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.58 2006/10/03 02:59:36 kurt Exp $	*/
a988 6
SCLASS const int dtablecount
#ifdef GLOBAL_PTHREAD_PRIVATE
= 4096/sizeof(struct fd_table_entry);
#else
;
#endif
@


1.58
log
@Last Part of file descriptor race and deadlock corrections.

When a fd enters the closing state prevent any threads from
polling the fd and reschedule the thread with the closing_fd
flag set. This fixes a class of deadlocks where a thread is
blocked waiting for data (that may never arrive) and a later
thread calls close() or dup2() on the fd. okay brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.57 2006/09/26 14:18:28 kurt Exp $	*/
a396 3

/* Address immediately beyond the beginning of the initial thread stack. */
#define _POSIX_THREAD_ATTR_STACKSIZE
@


1.57
log
@Part 2 of file descriptor race and deadlock corrections.

Adjust design of file descriptor table to eliminate races
with both opening and closing of file descriptor entries
and eliminates one class of deadlocks. One nice side effect
of this change in design should be better performance for
applications that open and close many file descriptors due
to reduced fd_table_lock contention and fd entry reuse.

- Add entry states to manage use of entry and eliminate
some closing races. fd entries are not deallocated upon
close() now.
- Call _thread_fd_table_init with one of five discreet
modes to properly initialize an entry and manage the
state transition to open.
- When closing an entry hold the entry spinlock locked
across the state transition and the _thread_sys_close
call to close another race.
- Introduce a new lock type FD_RDWR_CLOSE that transitions
either a closed entry or an open entry into closing state
and then waits for a RDWR lock so that the lock queue can
unwind normally. All subsequent fd lock attempts for that
entry are rejected with EBADF until the fd is fully closed,
or reopened by dup2(). Once a thread holds the FD_RDWR_LOCK
it is safe to close() it or dup2() on it.
- When a thread creates a new fd there is a window of time
when another thread could attempt to use the fd before the
creating thread has initialized the entry for it. This can
result in improper status_flags for the entry, so record
the entries init mode, detect when this has happened and
correct the status_flags when needed.

reviewed by marc@@ & brad@@, tested by several, okay brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.56 2006/09/22 19:04:33 kurt Exp $	*/
d745 6
@


1.56
log
@Part 1 of file descriptor race and deadlock corrections.

File status flags should be shared for dup'ed file descriptors.
However fd_table_entry's should not be shared for dup'ed file
descriptors so they can be independently be closed without
interfering with dup'ed fd's.

- split out file status flags into its own structure
fs_flags to manage sharing of status flags between
dup'ed file descriptors.
- when duplicating a fd, initialize a new fd_table_entry
for the new fd, but share the status flags via status_flags.
- consolidate the code that sets the underlying system fd
to be non-blocking to a new function _thread_fs_flags_init()
- consolidate the code that sets the underlying system
fd back to blocking into a new function _thread_fs_flags_replace()

This change is needed as a prerequisite to the coming race
and deadlock corrections. okay marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.55 2006/01/06 18:53:04 millert Exp $	*/
d509 20
d550 2
d1157 2
a1158 3
int     _thread_fd_table_init(int, struct fs_flags *);
int     _thread_fd_table_dup(int, int);
void	_thread_fd_table_remove(int);
@


1.55
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.54 2005/10/30 03:37:34 brad Exp $	*/
d500 9
d529 1
a529 2
	int			flags;		/* Flags used in open.        */
	int			refcnt;		/* how many fds use this entry*/
d1133 1
d1135 1
a1135 1
int     _thread_fd_table_init(int);
@


1.54
log
@Add pthread_atfork(3)

From FreeBSD

'looks ok' fgsch@@ miod@@
man page reviewed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.53 2004/06/07 21:11:23 marc Exp $	*/
d1239 6
a1244 6
int     _thread_sys_vfprintf(FILE *, const char *, _BSD_VA_LIST_);
int     _thread_sys_vprintf(const char *, _BSD_VA_LIST_);
int     _thread_sys_vscanf(const char *, _BSD_VA_LIST_);
int     _thread_sys_vsnprintf(char *, size_t, const char *, _BSD_VA_LIST_);
int     _thread_sys_vsprintf(char *, const char *, _BSD_VA_LIST_);
int     _thread_sys_vsscanf(const char *, const char *, _BSD_VA_LIST_);
@


1.53
log
@
major bump to libc and libpthread to break the dependency of a
particular implementation of libpthread for libc.  libc no longer
needs pthread.h to compile.
OK millert@@, brad@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.52 2004/02/01 06:22:14 brad Exp $	*/
d348 7
d910 3
@


1.52
log
@Add a simple work-around for deadlocking on recursive
readlocks on a rwlock while there are writers waiting.

From: FreeBSD's libc_r

ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.51 2004/01/15 22:22:11 marc Exp $	*/
d1120 1
a1120 1
void	_thread_fd_unlock_thread(struct pthread	*, int, int, const char *, int);
@


1.51
log
@threaded version of closefrom
pthread_stackseg_np added.   Minor bump for these changes occurred
a day or so ago and will not be bumped again
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.50 2003/12/31 22:15:28 brad Exp $	*/
d767 3
@


1.50
log
@there is no pause() wrapper (thread_sys_pause) so remove the prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.49 2003/11/10 23:15:18 mickey Exp $	*/
d1246 1
@


1.49
log
@missing proto for kqueue(); marc@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.48 2003/08/01 19:50:23 millert Exp $	*/
a1255 1
int     _thread_sys_pause(void);
@


1.48
log
@Go back to using ITIMER_PROF for the non-profiled libpthread and use
ITIMER_VIRTUAL for the profiled version.  Fixes problems when programs
linked with libpthread try to use ITIMER_VIRTUAL (and have no way of
knowing that this will cause conflicts with the threads lib).
marc@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.47 2003/07/08 00:17:18 marc Exp $	*/
d1316 1
@


1.47
log
@remove variable never read
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.46 2003/05/13 16:49:32 marc Exp $	*/
d172 1
a172 1
#if defined(_PTHREADS_COMPAT_SCHED)
@


1.46
log
@
Add support for blocking thread switches during dlopen and other
non-thread-safe dl functions.   Only enabled for ELF architectures
at this time as needed dlxxx support has not yet been added to the
a.out run time loader.

'doesn't break xmms at least' tedu@@.   Tested by others with no comment
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.45 2003/02/14 03:58:42 marc Exp $	*/
a626 1
	int		sigmask_seqno;
@


1.45
log
@
fix bug that would leave an FD locked if dup'd, then closed.
Also, for safety lock the _thread_fd_table when removing entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.44 2003/02/04 22:14:27 marc Exp $	*/
d1098 1
@


1.44
log
@
Part 1 of thread fd handling fixes.  In the new scheme fd_table_entries
for dup-ed fds are shared to ensure proper flag handling.  A refcnt
was added to control when entries should be freed.  Specific changes:

close: don't free entry unless refcnt is zero
dup: rewrite to use new function _thread_fd_table_dup
dup2: rewrite to use new function _thread_fd_table_dup
fcntl: use _thread_fd_table_dup
uthread_fd: initialize thread fd table, searching for dup-ed fds.  Add
function to share _thread_fd_table entries when an fd is dup-ed.
uthread_init: make it readable.   Call fd init functions.

All current regression tests plus the mysql torture test pass.  The
new stdfiles regression test fails (I/O redirection problem). Part
2 is intended to fix that problem
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.43 2003/01/31 04:46:17 marc Exp $	*/
d1115 1
@


1.43
log
@
Create a siginfo_t for thread-to-thread kill.
Clean up (compiler warning elimination).   Compile check options added
but commented out as they have not been checked on all architectures, yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.42 2003/01/27 22:22:30 marc Exp $	*/
d503 12
a514 11
	_thread_list_t		r_queue;	/* Read queue.                        */
	_thread_list_t		w_queue;	/* Write queue.                       */
	struct pthread		*r_owner;	/* Ptr to thread owning read lock.    */
	struct pthread		*w_owner;	/* Ptr to thread owning write lock.   */
	const char		*r_fname;	/* Ptr to read lock source file name  */
	int			r_lineno;	/* Read lock source line number.      */
	const char		*w_fname;	/* Ptr to write lock source file name */
	int			w_lineno;	/* Write lock source line number.     */
	int			r_lockcount;	/* Count for FILE read locks.         */
	int			w_lockcount;	/* Count for FILE write locks.        */
	int			flags;		/* Flags used in open.                */
d1112 3
a1114 1
int     _thread_fd_table_init(int fd);
@


1.42
log
@pthreads signal handling improvements.   With these changes all
of the thread regressions tests pass on i386, sparc, sparc64
(save the siginfo test on sparc64 due to a kernel issue) and alpha.
The tests should also pass on ppc.

In addition, it fixes the problems with the "mysql torture test"
provided by one of our users.   The python port also appears to
work correctly with these changes.

Summary of changes:

* check_pending removed from thread structure, no longer used.
* unused elements of sigstatus structure removed.   The sigstatus
  structure is now used to keep track of siginfo data instead of
  defining a local array in uthread_sig.c.
* _thread_kern_sched_sig removed
* _thread_sig_process goes away -- can't have a lock active when
  signal handlers are called.   Functions now call _thread_sig_handle
  directly.
* _thread_clear_pending now used lib wide to clear pending flags.
  It was named _clean_pending_flag and only used in uthread_sig.c.
  The function clears both per thread signals, and per process signals.
* _thread_sig_handle now returns a value.
* unused debugging macros removed from the thread kernel
* dispatch pending signals after switching to a thread providing
  that signal handling hasn't been deferred by the thread.
* process thread switchhooks before dispatching pending sigs
* check for thread cancellation before dispatching pending sigs
* re-wrote pthread-kill to do the correct thing.   It now does
  minimal thread-kill-specific processing and then calls the
  existing code in uthread_sig to process the generated signal.
* shut the compiler up when compiling uthread_mutex.c
* no more "signal_lock".   It does more harm than good.
* keep track of "per-process" signals.
* don't bother saving siginfo_t data for the scheduling signal.
* per posix: SIGSTOP cleared when SIGCONT received and vice versa.
* add _dispatch_signal to properly dispatch a signal to a thread.
  It sets the appropriate signal mask, something that was missing
  in the previous implementation.   This fixes several bugs.
  The previous method held a lock.  If the signal handler longjmp-ed
  the lock was never cleared and no more signals were processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.41 2003/01/24 21:03:15 marc Exp $	*/
d344 1
a344 1
	void			(*routine) ();
d356 1
a356 1
	void	(*cleanup_attr) ();
d445 1
a445 1
	void            (*destructor) ();
d526 3
a528 3
		short	fd;		/* Used when thread waiting on fd */
		short	branch;		/* Line number, for debugging.    */
		char	*fname;		/* Source file name for debugging.*/
d779 1
a779 1
	char			*fname;	/* Ptr to source file name  */
d1017 1
d1064 1
d1070 1
d1098 3
a1100 3
void    _thread_kern_sched_state(enum pthread_state,char *fname,int lineno);
void	_thread_kern_sched_state_unlock(enum pthread_state state,
	    spinlock_t *lock, char *fname, int lineno);
d1104 1
d1112 2
d1128 2
@


1.41
log
@
save and restore fp state when switching threads.   This, with
an arch/i386 patch previously commited and arch/sparc64 patches
from jason@@ make the preemption_float test pass on those two
architectures.

Do not run signal handlers for a thread until the thread has
been made current, ensuring the proper context.   Solves several
(if not all) of the '_pq_insert_tail: Already in priority queue'
problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.40 2002/12/11 23:21:19 marc Exp $	*/
a626 1
	int		check_pending;
a1017 6
	int		blocked;	/*
					 * A handler is currently active for
					 * this signal; ignore subsequent
					 * signals until the handler is done.
					 */
	int		signo;		/* arg 1 to signal handler */
a1018 1
	struct sigcontext uc;		/* arg 3 to signal handler */
d1090 1
a1094 1
void    _thread_kern_sched_sig(void);
d1102 1
a1102 1
void    _thread_sig_handle(int, struct sigcontext *);
a1103 1
void	_thread_sig_process(int, struct sigcontext *);
@


1.40
log
@add a debugging function not normally called
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.39 2002/12/08 04:06:01 marc Exp $	*/
d1076 1
a1076 1
void    _dispatch_signals(pthread_t, struct sigcontext *);
@


1.39
log
@remove unused data member from pthread_cond.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.38 2002/11/12 20:12:45 marc Exp $	*/
d1098 1
@


1.38
log
@get rid of compiler warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.37 2002/10/30 20:05:11 marc Exp $	*/
a298 1
	void				*c_data;
@


1.37
log
@
removes duplicate functions and factor out common code so the needed (but
missing) _thread_fd_unlock_owned function can be added with minimal pain.
The incorrect special handling of the stdio fds was also removed.

Tested with the libc_r regression tests and the mysql regression tests.
No complaints from any developers
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.36 2002/10/30 19:11:56 marc Exp $	*/
a1089 1
#if defined(_PTHREADS_INVARIANTS)
d1092 1
@


1.36
log
@signal handling changes.   This corrects several signal
handling errors in the threads library.   Most of the libc_r regression
tests are now ok.   thread specific kill semantics are still not correct.
No negative comments after posting to tech@@ a week or so ago.
siginfo test fails on sparc64 due to sparc64 oddity.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.35 2002/02/21 20:57:41 fgsch Exp $	*/
d490 1
a490 1
 * File descriptor locking definitions.
a491 3
#define FD_READ             0x1
#define FD_WRITE            0x2
#define FD_RDWR             (FD_READ | FD_WRITE)
a927 7

/*
 * Standard I/O file descriptors need special flag treatment since
 * setting one to non-blocking does all on *BSD. Sigh. This array
 * is used to store the initial flag settings.
 */
SCLASS int	_pthread_stdio_flags[3];
@


1.35
log
@account for the process signal mask when dealing with signals; tested
a while ago by marc@@ and brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.34 2002/01/19 23:49:32 fgsch Exp $	*/
d1085 3
a1087 2
int     _thread_create(pthread_t *,const pthread_attr_t *,void *(*start_routine)(void *),void *,pthread_t);
void    _dispatch_signals(void);
d1119 1
a1119 1
void    _thread_sig_handler(int, int, struct sigcontext *);
d1122 1
@


1.34
log
@Instead of ifdef around ENOTSUP, move it to pthread_private.h and make
it EOPNOTSUPP.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.33 2001/12/31 18:23:15 fgsch Exp $	*/
d1000 10
d1111 1
@


1.33
log
@More changes from FreeBSD, including:

o Only poll file descriptors when needed.
o Change the way timing is achieved, counting scheduling ticks
  instead of calculating the elapsed time via gettimeofday().
o Prevent an overflow when polling.
o Use curthread instead of _thread_run.
o Remove extra spaces; indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.32 2001/12/19 02:02:52 fgsch Exp $	*/
d63 5
@


1.32
log
@More sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.31 2001/12/11 00:19:47 fgsch Exp $	*/
d258 1
a258 1
 * Flags for mutexes. 
d265 1
a265 1
 * Static mutex initialization values. 
d317 1
a317 1
 * Static cond initialization values. 
d415 1
a415 1
 * Clock resolution in nanoseconds.
d417 2
a418 1
#define CLOCK_RES_NSEC				10000000
d423 1
a423 1
#define TIMESLICE_USEC				100000
d631 2
a632 2
	/* Time that this thread was last made active. */
	struct  timeval		last_active;
d634 2
a635 2
	/* Time that this thread was last made inactive. */
	struct  timeval		last_inactive;
d654 1
a654 1
	 * returns a pointer to this. 
d963 1
a963 1
SCLASS int    _clock_res_nsec		/* Clock resolution in nsec.	*/
d965 1
a965 1
= CLOCK_RES_NSEC;
@


1.31
log
@More sync with freebsd code; join related code this time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.30 2001/12/08 14:51:36 fgsch Exp $	*/
d123 8
d148 2
d658 1
a658 1
	 * The joiner is the thread that is joining this thraed. The
d666 1
a666 2
	 * a time (ready or waiting queue).  It can also belong to (only)
	 * one of:
d674 11
d686 2
a687 1
	 * and qe for other links.
d690 3
a692 8
	/* Priority queue entry for this thread: */
	pthread_entry_t		pqe;

	/* Priority queue entry for this thread: */
	pthread_entry_t		sqe;

	/* Queue entry for this thread: */
	pthread_entry_t		qe;
d723 1
a723 1
	/* Miscellaneous data. */
d727 2
a728 2
#define PTHREAD_FLAGS_IN_WAITQ	0x0004	/* in waiting queue using pqe link*/
#define PTHREAD_FLAGS_IN_PRIOQ	0x0008	/* in priority queue using pqe link*/
d732 2
a733 2
#define PTHREAD_FLAGS_IN_CONDQ	0x0080	/* in condition queue using sqe link*/
#define PTHREAD_FLAGS_IN_MUTEXQ	0x0100	/* in mutex queue using sqe link*/
d735 1
a735 1
#define PTHREAD_FLAGS_IN_SYNQ	\
d1011 15
d1032 3
@


1.30
log
@Partially sync with FreeBSD; mostly pthread_cancel(3) related changes.
make includes is needed in case you want to play.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.29 2001/09/04 23:28:31 fgsch Exp $	*/
d541 6
d647 6
a652 2
	/* Join queue head and link for waiting threads: */
	V_TAILQ_HEAD(join_head, pthread)	join_queue;
a660 2
	 *   o A queue of threads waiting for another thread to terminate
	 *     (the join queue above)
d672 3
a1031 1
int     _find_dead_thread(pthread_t);
@


1.29
log
@Use _waitq_remove() and _waitq_insert() always; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.28 2001/09/04 22:17:45 fgsch Exp $	*/
a590 6
	 * Cancelability state.
	 */
	int	cancelstate;
	int	canceltype;

	/*
d700 10
a709 7
#define PTHREAD_FLAGS_IN_CONDQ	0x0004	/* in condition queue using qe link*/
#define PTHREAD_FLAGS_IN_WORKQ	0x0008	/* in work queue using qe link */
#define PTHREAD_FLAGS_IN_WAITQ	0x0010	/* in waiting queue using pqe link*/
#define PTHREAD_FLAGS_IN_PRIOQ	0x0020	/* in priority queue using pqe link*/
#define PTHREAD_FLAGS_TRACE	0x0040	/* for debugging purposes */
#define PTHREAD_FLAGS_CANCELED	0x1000	/* thread has been cancelled */
#define PTHREAD_FLAGS_CANCELPT	0x2000	/* thread at cancel point */
@


1.28
log
@put changes back, this time ALL the files.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.26 2001/08/30 07:40:47 fgsch Exp $	*/
a84 1
#if defined(_PTHREADS_INVARIANTS)
d87 2
a91 17
#define PTHREAD_WAITQ_REMOVE(thrd)	TAILQ_REMOVE(&_waitingq,thrd,pqe)
#define PTHREAD_WAITQ_INSERT(thrd) do {					\
	if ((thrd)->wakeup_time.tv_sec == -1)				\
		TAILQ_INSERT_TAIL(&_waitingq,thrd,pqe);			\
	else {								\
		pthread_t tid = TAILQ_FIRST(&_waitingq);		\
		while ((tid != NULL) && (tid->wakeup_time.tv_sec != -1) && \
		    ((tid->wakeup_time.tv_sec < (thrd)->wakeup_time.tv_sec) ||	\
		    ((tid->wakeup_time.tv_sec == (thrd)->wakeup_time.tv_sec) &&	\
		    (tid->wakeup_time.tv_nsec <= (thrd)->wakeup_time.tv_nsec)))) \
			tid = TAILQ_NEXT(tid, pqe);			\
		if (tid == NULL)					\
			TAILQ_INSERT_TAIL(&_waitingq,thrd,pqe);		\
		else							\
			TAILQ_INSERT_BEFORE(tid,thrd,pqe);		\
	}								\
} while (0)
@


1.27
log
@Back out fgsch@@'s tree breaking commits.
Test next time, ok?
@
text
@a648 6
	 * Incremental priority accumulated by thread while it is ready to
	 * run but is denied being run.
	 */
	int	inc_prio;

	/*
a875 3
/* Last time that an incremental priority update was performed: */
extern struct timeval   kern_inc_prio_time;

d979 7
d1070 1
a1070 1
void    _thread_kern_sched_state(enum pthread_state,const char *fname,int lineno);
@


1.26
log
@fix some const warnings.
more sync with freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.25 2001/08/29 18:33:54 fgsch Exp $	*/
d649 6
d882 3
a987 7
 * Array of counts of dummy handlers for SIG_DFL signals.  This is used to
 * assure that there is always a dummy signal handler installed while there is a
 * thread sigwait()ing on the corresponding signal.
 */
SCLASS int	_thread_dfl_count[NSIG];

/*
d1072 1
a1072 1
void    _thread_kern_sched_state(enum pthread_state,char *fname,int lineno);
@


1.25
log
@More sync with FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.24 2001/08/26 00:49:03 fgsch Exp $	*/
a648 6
	 * Incremental priority accumulated by thread while it is ready to
	 * run but is denied being run.
	 */
	int	inc_prio;

	/*
a875 3
/* Last time that an incremental priority update was performed: */
extern struct timeval   kern_inc_prio_time;

d979 7
d1070 1
a1070 1
void    _thread_kern_sched_state(enum pthread_state,const char *fname,int lineno);
@


1.24
log
@More syncing with FreeBSD, preparing for a commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.23 2001/08/21 19:24:53 fgsch Exp $	*/
d42 9
d795 1
a795 1
extern struct pthread   _thread_kern_thread;
d798 6
a803 1
extern struct pthread   * volatile _thread_run;
d806 6
a811 1
extern struct pthread   * volatile _last_user_thread;
d817 6
a822 1
extern struct pthread   * volatile _thread_single;
d824 6
a829 1
extern _thread_list_t		_thread_list;
d835 46
a880 3
extern int		_thread_kern_pipe[2];
extern volatile int	_queue_signals;
extern volatile int	_thread_kern_in_sched;
d886 6
a891 1
extern _thread_list_t		_dead_list;
d894 6
a899 1
extern struct pthread *_thread_initial;
d902 8
a909 1
extern struct pthread_attr pthread_attr_default;
d912 6
a917 1
extern struct pthread_mutex_attr pthread_mutexattr_default;
d920 6
a925 1
extern struct pthread_cond_attr pthread_condattr_default;
d932 1
a932 1
extern int	_pthread_stdio_flags[3];
d935 6
a940 1
extern struct fd_table_entry **_thread_fd_table;
d943 6
a948 1
extern struct pollfd *_thread_pfd_table;
d950 12
a961 2
extern const int dtablecount;
extern int    _thread_dtablesize;       /* Descriptor table size.           */
d963 6
a968 1
extern int    _clock_res_nsec;		/* Clock resolution in nsec.	*/
d971 10
a980 2
extern	pthread_mutex_t _gc_mutex;
extern	pthread_cond_t  _gc_cond;
d985 1
a985 1
extern struct  sigaction _thread_sigact[NSIG];
d990 2
a991 2
extern pq_queue_t		_readyq;
extern _thread_list_t		_waitingq;
d996 1
a996 1
extern _thread_list_t		_workq;
d999 5
a1003 1
extern	volatile int	_spinblock_count;
d1006 5
a1010 1
extern	volatile int	_sigq_check_reqd;
d1013 5
a1017 1
extern	pthread_switch_routine_t _sched_switch_hook;
d1028 9
a1036 1
extern int	_thread_kern_new_state;
@


1.23
log
@Start syncing with FreeBSD:

o Implement _get_curthread() and _set_curthread(). Use it where possible.
o Add missing _thread_[enter|leave]_cancellation_point().
o Add a couple of not yet used vars to pthread_private.h.
o Remove return's from void functions.

This is by no means complete, but instead of doing a big commit, i'll
split it in small ones, minimizing diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.22 2001/08/15 23:50:34 fgsch Exp $	*/
d45 1
a219 1

d266 1
a266 1
	NULL, { NULL }, 0, 0, 0, 0, TAILQ_INITIALIZER, \
d276 3
d318 13
a330 1
	0, _SPINLOCK_INITIALIZER }
d362 12
d383 1
d385 17
a401 2
#define PTHREAD_DEFAULT_PRIORITY		64
#define PTHREAD_MAX_PRIORITY			126
d403 7
a409 1
#define _POSIX_THREAD_ATTR_STACKSIZE
d421 12
d523 1
a523 1
		const char *fname;	/* Source file name for debugging.*/
d525 2
a526 1
	struct pthread_poll_data * poll_data;
d528 1
d540 6
d604 13
d621 2
d767 1
a767 1
	const char		*fname;	/* Ptr to source file name  */
@


1.22
log
@* kevent(2) support; from FreeBSD.
* change _thread_kern_set_timeout() parm to const.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.21 2000/12/06 17:18:47 deraadt Exp $	*/
d281 1
a281 1
#define COND_TYPE_MAX	((int)COND_TYPE_FAST + 1)
d290 1
d337 1
d414 2
a415 2
	PS_DEADLOCK
#define PS_STATE_MAX	((int)PS_DEADLOCK + 1)
d808 2
@


1.21
log
@use __x__ formats for __attribute__ arguments; guenther@@gac.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.20 2000/10/04 05:55:35 d Exp $	*/
d835 1
a835 1
void    _thread_kern_set_timeout(struct timespec *);
d1037 6
@


1.20
log
@switch to _machdep_switch() instead of setjmp/longjmp. For some reason this fixes sparc threads.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.19 2000/01/06 07:13:56 d Exp $	*/
d826 1
a826 1
__dead void _thread_exit(const char *, int, const char *) __attribute__((noreturn));
d989 1
a989 1
__dead void	_thread_sys__exit(int) __attribute__((noreturn));
@


1.19
log
@volatile; thread_private.h; locking defines moved out; kill(), getpid()
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread_private.h,v 1.18 1999/11/25 07:01:30 d Exp $	*/
a43 1
#include <setjmp.h>
a514 6
	/* 
	 * Saved jump buffer used in call to longjmp by _thread_kern_sched
	 * if sig_saved is FALSE.
	 */
	_machdep_jmp_buf	saved_jmp_buf;

d516 1
a516 1
	 * Further machine-dependent context, valid if sig_saved is FALSE.
d518 1
a518 1
	struct _machdep_struct	_machdep;
d686 10
d853 1
@


1.18
log
@sync with FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
d172 16
d194 1
a194 1
	TAILQ_HEAD(, pthread)	pl_head; /* list of threads at this priority */
d220 1
d224 1
a224 1
	TAILQ_HEAD(mutex_head, pthread)	m_queue;
d247 1
a247 1
	TAILQ_ENTRY(pthread_mutex)	m_qe;
d287 1
a287 1
	TAILQ_HEAD(cond_head, pthread)	c_queue;
d436 2
a437 2
	TAILQ_HEAD(, pthread)	r_queue;	/* Read queue.                        */
	TAILQ_HEAD(, pthread)	w_queue;	/* Write queue.                       */
d476 1
a476 1
typedef TAILQ_ENTRY(pthread) pthread_entry_t;
d582 1
a582 1
	TAILQ_HEAD(join_head, pthread)	join_queue;
d680 1
a680 1
	TAILQ_HEAD(, pthread_mutex)	mutexq;
a710 2
/* List of all threads: */
typedef TAILQ_HEAD(, pthread)	_thread_list_t;
d718 2
a719 2
extern int		volatile _queue_signals;
extern int              _thread_kern_in_sched;
d784 1
a784 1
extern pthread_switch_routine_t _sched_switch_hook;
a796 12
#ifdef	_LOCK_DEBUG
#define	_FD_LOCK(_fd,_type,_ts)		_thread_fd_lock_debug(_fd, _type, \
						_ts, __FILE__, __LINE__)
#define _FD_UNLOCK(_fd,_type)		_thread_fd_unlock_debug(_fd, _type, \
						__FILE__, __LINE__)
#else
#define	_FD_LOCK(_fd,_type,_ts)		_thread_fd_lock(_fd, _type, _ts)
#define _FD_UNLOCK(_fd,_type)		_thread_fd_unlock(_fd, _type)
#endif

extern int __isthreaded;

a803 2
int     _thread_fd_lock(int, int, struct timespec *);
int     _thread_fd_lock_debug(int, int, struct timespec *,const char *fname,int lineno);
a823 2
void    _thread_fd_unlock(int, int);
void    _thread_fd_unlock_debug(int, int, const char *, int);
d853 1
d976 1
@


1.17
log
@TAILQ_FOREACH now is in queue.h
@
text
@d1 1
d24 1
a24 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d35 1
a35 2
 * $OpenBSD: pthread_private.h,v 1.16 1999/06/15 00:07:39 d Exp $
 *
a40 2
#include <paths.h>

a51 1
#ifndef _NO_UTHREAD_MACHDEP
a52 1
#endif
d65 1
a65 1
 * Priority queue manipulation macros:
d70 1
a70 1
#define PTHREAD_PRIOQ_FIRST		_pq_first(&_readyq)
d73 1
a73 1
 * Waiting queue manipulation macros:
d75 6
a80 1
#define PTHREAD_WAITQ_INSERT(thrd)	TAILQ_INSERT_TAIL(&_waitingq,thrd,pqe)
d82 32
d118 1
a118 1
#define PTHREAD_SET_STATE(thrd, newstate) {				\
d122 1
a122 1
}
d128 19
a146 1
#define PTHREAD_NEW_STATE(thrd, newstate) {				\
d157 2
a158 1
}
a171 9
 * Queue definitions.
 */
struct pthread_queue {
	struct pthread	*q_next;
	struct pthread	*q_last;
	void		*q_data;
};

/*
a190 5
 * Static queue initialization values. 
 */
#define PTHREAD_QUEUE_INITIALIZER { NULL, NULL, NULL }

/*
d193 1
a193 1
#define TAILQ_INITIALIZER { NULL, NULL }
d264 1
a264 1
	COND_TYPE_MAX
d296 2
a297 2
 	{ COND_TYPE_FAST, PTHREAD_QUEUE_INITIALIZER, NULL, NULL, \
 	0, _SPINLOCK_INITIALIZER }
d331 7
a348 6
 * Number of microseconds between incremental priority updates for
 * threads that are ready to run, but denied being run.
 */
#define INC_PRIO_USEC				500000

/*
d385 1
d395 2
a396 2
	PS_DEADLOCK,
	PS_STATE_MAX
d418 2
a419 2
	struct pthread_queue	r_queue;	/* Read queue.                        */
	struct pthread_queue	w_queue;	/* Write queue.                       */
d431 1
a431 1
struct pthread_select_data {
d433 1
a433 3
	fd_set	readfds;
	fd_set	writefds;
	fd_set	exceptfds;
d445 1
a445 1
	struct pthread_select_data * select_data;
d449 11
d477 2
a478 4
	/*
	 * Pointer to the next thread in the thread linked list.
	 */
	struct pthread	*nxt;
d480 2
a481 4
	/*
	 * Pointer to the next thread in the dead thread linked list.
	 */
	struct pthread	*nxt_dead;
d489 1
a489 1
	void			*stack;
d498 11
a542 6
	 * Cumulative times spent in thread
	 */
	struct	timeval		ru_utime;
	struct	timeval		ru_stime;

	/*
d563 2
a564 2
	/* Join queue for waiting threads: */
	struct pthread_queue	join_queue;
d567 3
a569 5
	 * The current thread can belong to only one scheduling queue
	 * at a time (ready or waiting queue).  It can also belong to
	 * a queue of threads waiting on mutexes or condition variables.
	 * Use pqe for the scheduling queue link (both ready and waiting),
	 * and qe for other links (mutexes and condition variables).
d571 7
a577 1
	 * Pointer to queue (if any) on which the current thread is waiting.
d579 2
a580 2
	 * XXX The queuing should be changed to use the TAILQ entry below.
	 * XXX For the time being, it's hybrid.
a581 4
	struct pthread_queue	*queue;

	/* Pointer to next element in queue. */
	struct pthread	*qnxt;
d584 1
a584 1
	TAILQ_ENTRY(pthread)	pqe;
d587 1
a587 1
	TAILQ_ENTRY(pthread)	qe;
d593 5
d607 2
a608 2
	 * Set to non-zero when this thread has deferred thread
	 * scheduling.  We allow for recursive deferral.
d610 1
a610 1
	int		sched_defer_count;
d614 1
a614 1
	 * thread scheduling.
d616 1
a616 1
	int		yield_on_sched_undefer;
d622 7
a628 4
#define PTHREAD_FLAGS_QUEUED	0x0004	/* in queue (qe is used) */
#define PTHREAD_FLAGS_TRACE	0x0008
#define PTHREAD_CANCELLING	0x0010	/* thread has been cancelled */
#define PTHREAD_AT_CANCEL_POINT	0x0020	/* thread at cancel point */
d651 1
a651 1
	 * in either the real or inherited priority, the active
a671 11

	/* 
	 * Saved jump buffer used in call to longjmp by _thread_kern_sched
	 * if sig_saved is FALSE.
	 */
	_machdep_jmp_buf	saved_jmp_buf;

#ifndef _UTHREAD_MACHDEP
	/* Machine dependent information */
	struct _machdep_struct	_machdep;
#endif
d679 1
a679 2
extern struct pthread   volatile _thread_kern_thread;
extern struct pthread   * volatile _thread_kern_threadp;
d685 1
a685 1
extern struct pthread	* volatile _last_user_thread;
d693 3
a695 2
/* Ptr to the first thread in the thread linked list: */
extern struct pthread   * volatile _thread_link_list;
d701 2
a702 2
extern int              _thread_kern_pipe[2];
extern int              _thread_kern_in_select;
d709 1
a709 1
extern struct pthread * volatile _thread_dead;
d732 4
d737 3
a739 1
extern int    _thread_dtablesize;
d742 2
a743 2
extern pthread_mutex_t _gc_mutex;
extern pthread_cond_t _gc_cond;
d754 6
a759 2
typedef TAILQ_HEAD(, pthread)	_waitingq_t;
extern _waitingq_t		_waitingq;
d761 5
a765 2
/* Indicates that the waitingq now has threads ready to run. */
extern volatile int	_waitingq_check_reqd;
d771 3
a773 1
 * Where SIGINFO writes thread states when /dev/tty cannot be opened
d775 5
a779 1
#define INFO_DUMP_FILE  "/tmp/uthread.dump"
d791 2
a803 4
void    _lock_thread(void);
void    _lock_thread_list(void);
void    _unlock_thread(void);
void    _unlock_thread_list(void);
d806 1
d808 3
a810 1
int	_pq_init(struct pq_queue *pq, int, int);
d815 7
a821 2
void    _thread_exit(const char *, int, const char *)
		__attribute__((noreturn));
d823 1
a823 1
void    _thread_fd_unlock_debug(int, int, char *, int);
d829 1
a829 1
void    _thread_kern_sched_state(enum pthread_state, const char *, int);
d833 2
a834 2
void    _thread_kern_sched_defer(void);
void    _thread_kern_sched_undefer(void);
d836 2
a840 3
void    _thread_queue_init(struct pthread_queue *);
void    _thread_queue_enq(struct pthread_queue *, struct pthread *);
int     _thread_queue_remove(struct pthread_queue *, struct pthread *);
a841 2
struct pthread *_thread_queue_get(struct pthread_queue *);
struct pthread *_thread_queue_deq(struct pthread_queue *);
d848 2
d974 1
a974 1
long    _thread_sys_fpathconf(int, int);
d983 1
a983 2
void	_thread_sys__exit(int)
		__attribute__((noreturn));
d1021 1
a1021 1
#ifdef _SYS_WAIT_H_
d1028 1
a1028 1
/* #include <sys/poll.h> */
d1030 1
a1030 1
int	_thread_sys_poll(struct pollfd[], int, int);
@


1.16
log
@Remove pthread_atfork(). It was only part of draft 10 for a little while and was removed before stddization.
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.15 1999/06/09 07:06:54 d Exp $
a55 6
#endif

#ifdef __OpenBSD__
/* Steal TAILQ_FOREACH from FreeBSD's <sys/queue.h> */
#define TAILQ_FOREACH(var, head, field)                                 \
        for (var = TAILQ_FIRST(head); var; var = TAILQ_NEXT(var, field))
@


1.15
log
@sync with freebsd
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.14 1999/05/26 00:18:21 d Exp $
a303 4
#define PTHREAD_ATFORK_PREPARE			0
#define PTHREAD_ATFORK_PARENT			1
#define PTHREAD_ATFORK_CHILD			2

a782 1
void	_thread_atfork(int);
@


1.14
log
@sync with FreeBSD
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.13 1999/02/16 16:44:07 millert Exp $
d217 2
a218 1
	NULL, { NULL }, MUTEX_FLAGS_INITED, 0, 0, 0, TAILQ_INITIALIZER }
d264 2
a265 2
	{ COND_TYPE_FAST, PTHREAD_QUEUE_INITIALIZER, NULL, NULL, \
	COND_FLAGS_INITED }
@


1.13
log
@update prototypes now that socket functions take socklen_t as a length parameter
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.12 1999/01/18 00:03:35 d Exp $
d53 1
d58 6
d73 15
d89 1
a89 1
 * State change macro:
d91 1
a91 1
#define PTHREAD_NEW_STATE(thrd, newstate) {				\
d98 28
d135 19
d158 5
d173 2
a174 1
	struct pthread_queue		m_queue;
d178 20
d216 2
a217 2
	{ MUTEX_TYPE_FAST, PTHREAD_QUEUE_INITIALIZER, \
	NULL, { NULL }, MUTEX_FLAGS_INITED }
d221 2
d235 5
a239 4
	enum pthread_cond_type	c_type;
	struct pthread_queue	c_queue;
	void			*c_data;
	long			c_flags;
d244 1
a244 1
	spinlock_t		lock;
d263 2
a264 1
	{ COND_TYPE_FAST, PTHREAD_QUEUE_INITIALIZER, NULL, COND_FLAGS_INITED }
d276 3
a278 1
	int	schedparam_policy;
d360 1
d364 1
d408 2
a409 2
	pthread_mutex_t	*mutex;
	pthread_cond_t	*cond;
d417 1
d526 5
a530 1
	 * The current thread can belong to only one queue at a time.
d542 3
d546 1
a546 1
	TAILQ_ENTRY(pthread) qe;
d560 12
d574 41
a614 4
#define PTHREAD_EXITING		(0x0100)
#define PTHREAD_CANCELLING	(0x0200)	/* thread has been cancelled */
#define PTHREAD_AT_CANCEL_POINT	(0x0400)	/* thread at cancel point */
	char		pthread_priority;
d647 3
d694 1
d707 13
d749 8
d764 1
a764 1
void    _thread_init(void) /* __attribute__((constructor)) */;
d770 2
d913 1
a913 1
long	_thread_sys_fpathconf(int, int);
@


1.12
log
@move private spinlock protos out
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.11 1999/01/18 00:00:32 d Exp $
d633 6
a638 6
int     _thread_sys_accept(int, struct sockaddr *, int *);
int     _thread_sys_bind(int, const struct sockaddr *, int);
int     _thread_sys_connect(int, const struct sockaddr *, int);
int     _thread_sys_getpeername(int, struct sockaddr *, int *);
int     _thread_sys_getsockname(int, struct sockaddr *, int *);
int     _thread_sys_getsockopt(int, int, int, void *, int *);
d640 1
a640 1
int     _thread_sys_setsockopt(int, int, int, const void *, int);
d645 1
a645 1
ssize_t _thread_sys_recvfrom(int, void *, size_t, int, struct sockaddr *, int *);
d649 1
a649 1
ssize_t _thread_sys_sendto(int, const void *,size_t, int, const struct sockaddr *, int);
@


1.11
log
@sync with previous changes
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.10 1999/01/10 22:32:23 d Exp $
d600 2
@


1.10
log
@fix proto
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.9 1999/01/08 05:44:53 d Exp $
d53 1
d55 1
d202 4
a357 6
	/* 
	 * Saved jump buffer used in call to longjmp by _thread_kern_sched
	 * if sig_saved is FALSE.
	 */
	jmp_buf	saved_jmp_buf;

d365 6
d450 4
a453 2
	char		flags;
#define PTHREAD_EXITING		0x0100
d464 7
d473 1
d596 4
d783 3
@


1.9
log
@slight structure rearrange for gdb thread support
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.8 1999/01/08 05:42:18 d Exp $
d465 2
a466 1
extern struct pthread   * volatile _thread_kern_thread;
@


1.8
log
@add fchflags and fpathconf as well.
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.7 1999/01/08 04:59:50 d Exp $
a345 2
	struct _machdep_struct	_machdep;

d455 3
@


1.7
log
@add poll(2). This might help get X threaded.
@
text
@d34 1
a34 1
 * $OpenBSD: pthread_private.h,v 1.6 1998/12/23 22:49:46 d Exp $
d598 1
a598 1
int     _thread_sys_fchflags(int, u_long);
d702 1
@


1.6
log
@preserve FreeBSD idents
@
text
@d34 1
a34 1
 * $OpenBSD$
d464 1
a464 1
extern struct pthread   _thread_kern_thread;
d754 5
@


1.5
log
@resource accounting
@
text
@d34 2
@


1.4
log
@sync with freebsd
@
text
@d386 6
@


1.3
log
@fix strcat usage; deraadt
@
text
@d555 3
a557 1
void    _thread_kern_sched_state(enum pthread_state,const char *fname,int lineno);
d569 1
a569 2
pthread_addr_t	_thread_gc(pthread_addr_t);

@


1.2
log
@sync with FreeBSD (rwlock, gc thread, man pages)
add (broken) mips md stuff
fix some const warnings
add sigaltstack() stub
another hash at getting shlib auto-init to work (mips/elf and i386/a.out)
@
text
@d546 1
a546 1
void    _thread_exit(char *, int, char *)
@


1.1
log
@experimental threaded libc - kernel only
@
text
@d59 2
a60 2
#define	stdout_debug(_x)	_write(1,_x,strlen(_x));
#define	stderr_debug(_x)	_write(2,_x,strlen(_x));
d221 12
d249 1
d280 1
a280 1
	char			*r_fname;	/* Ptr to read lock source file name  */
d282 1
a282 1
	char			*w_fname;	/* Ptr to write lock source file name */
d303 1
a303 1
		char	*fname;		/* Source file name for debugging.*/
d331 5
d447 1
a447 1
	char			*fname;	/* Ptr to source file name  */
d507 4
d539 1
a539 1
int     _thread_fd_lock_debug(int, int, struct timespec *,char *fname,int lineno);
a541 1
void    _lock_dead_thread_list(void);
a543 1
void    _unlock_dead_thread_list(void);
d546 2
a547 1
void    _thread_exit(char *, int, char *);
d553 1
a553 1
void    _thread_init(void) __attribute__((constructor));
d555 1
a555 1
void    _thread_kern_sched_state(enum pthread_state,char *fname,int lineno);
d567 2
d579 1
a579 1
int     _thread_sys_sigstack(const struct sigstack *, struct sigstack *);
d701 2
a702 1
void	_thread_sys__exit(int);
@

