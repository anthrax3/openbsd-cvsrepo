head	1.14;
access;
symbols
	OPENBSD_5_2:1.13.0.40
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.38
	OPENBSD_5_0:1.13.0.36
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.34
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.32
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.28
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.30
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.26
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.24
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.22
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.20
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.18
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.16
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.14
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.12
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.10
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.8
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.6
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.4
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13;
locks; strict;
comment	@ * @;


1.14
date	2012.09.01.00.32.24;	author guenther;	state dead;
branches;
next	1.13;

1.13
date	2003.01.31.04.46.17;	author marc;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.27.22.22.30;	author marc;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.30.19.11.56;	author marc;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.21.20.57.41;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.21.19.24.53;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.06.07.21.14;	author d;	state Exp;
branches;
next	1.7;

1.7
date	99.11.25.07.01.45;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.06.09.07.16.17;	author d;	state Exp;
branches;
next	1.5;

1.5
date	99.05.26.00.18.26;	author d;	state Exp;
branches;
next	1.4;

1.4
date	99.01.17.23.57.27;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.01.06.05.29.28;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.11.09.03.13.21;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.08.27.09.01.23;	author d;	state Exp;
branches;
next	;


desc
@@


1.14
log
@   So passes uthreads
Like autumn leaves on water
   don't fear the tedu@@
@
text
@/*	$OpenBSD: uthread_sigwait.c,v 1.13 2003/01/31 04:46:17 marc Exp $	*/
/*
 * Copyright (c) 1997 John Birrell <jb@@cimlogic.com.au>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by John Birrell.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: uthread_sigwait.c,v 1.10 1999/09/30 14:51:31 marcel Exp $
 */
#include <signal.h>
#include <errno.h>
#ifdef _THREAD_SAFE
#include <pthread.h>
#include "pthread_private.h"

int
sigwait(const sigset_t * set, int *sig)
{
	struct pthread	*curthread = _get_curthread();
	int		ret = 0;
	int		i;
	sigset_t	tempset, waitset;
	struct sigaction act;
	
	_thread_enter_cancellation_point();

	/*
	 * Specify the thread kernel signal handler.
	 */
	act.sa_handler = (void (*) (int)) _thread_sig_handler;
	act.sa_flags = SA_SIGINFO | SA_RESTART;

	/* Ensure the signal handler cannot be interrupted by other signals: */
	sigfillset(&act.sa_mask);

	/*
	 * Initialize the set of signals that will be waited on:
	 */
	waitset = *set;

	/* These signals can't be waited on. */
	sigdelset(&waitset, SIGKILL);
	sigdelset(&waitset, SIGSTOP);
	sigdelset(&waitset, _SCHED_SIGNAL);
	sigdelset(&waitset, SIGCHLD);
	sigdelset(&waitset, SIGINFO);

	/* Check to see if a pending signal is in the wait mask. */
	tempset = curthread->sigpend;
	tempset |= _process_sigpending;
	tempset &= waitset;
	if (tempset != 0) {
		/* Enter a loop to find a pending signal: */
		for (i = 1; i < NSIG; i++) {
			if (sigismember(&tempset, i))
				break;
		}

		/* Clear the pending signal: */
		_thread_clear_pending(i, curthread);

		/* Return the signal number to the caller: */
		*sig = i;

		_thread_leave_cancellation_point();
		return (0);
	}

	/*
	 * Access the _thread_dfl_count array under the protection of signal
	 * deferral.
	 */
	_thread_kern_sig_defer();

	/*
	 * Enter a loop to find the signals that are SIG_DFL.  For
	 * these signals we must install a dummy signal handler in
	 * order for the kernel to pass them in to us.  POSIX says
	 * that the _application_ must explicitly install a dummy
	 * handler for signals that are SIG_IGN in order to sigwait
	 * on them.  Note that SIG_IGN signals are left in the
	 * mask because a subsequent sigaction could enable an
	 * ignored signal.
	 */
	sigemptyset(&tempset);
	for (i = 1; i < NSIG; i++) {
		if (sigismember(&waitset, i) &&
		    (_thread_sigact[i - 1].sa_handler == SIG_DFL)) {
			_thread_dfl_count[i]++;
			sigaddset(&tempset, i);
			if (_thread_dfl_count[i] == 1) {
				if (_thread_sys_sigaction(i, &act, NULL) != 0)
					ret = -1;
			}
		}
	}

	/* Done accessing _thread_dfl_count for now. */
	_thread_kern_sig_undefer();

	if (ret == 0) {
		/*
		 * Save the wait signal mask.  The wait signal
		 * mask is independent of the threads signal mask
		 * and requires separate storage.
		 */
		curthread->data.sigwait = &waitset;

		/* Wait for a signal: */
		_thread_kern_sched_state(PS_SIGWAIT, __FILE__, __LINE__);

		/* Return the signal number to the caller: */
		*sig = curthread->signo;

		/*
		 * Probably unnecessary, but since it's in a union struct
		 * we don't know how it could be used in the future.
		 */
		curthread->data.sigwait = NULL;
	}

	/*
	 * Access the _thread_dfl_count array under the protection of signal 
	 * deferral.
	 */
	_thread_kern_sig_defer();

	/* Restore the sigactions: */
	act.sa_handler = SIG_DFL;
	for (i = 1; i < NSIG; i++) {
		if (sigismember(&tempset, i)) {
			_thread_dfl_count[i]--;
			if ((_thread_sigact[i - 1].sa_handler == SIG_DFL) &&
			    (_thread_dfl_count[i] == 0)) {
				if (_thread_sys_sigaction(i, &act, NULL) != 0)
					ret = -1;
			}
		}
	}

	/* Done accessing _thread_dfl_count. */
	_thread_kern_sig_undefer();

	_thread_leave_cancellation_point();

	/* Return the completion status: */
	return (ret);
}
#endif
@


1.13
log
@
Create a siginfo_t for thread-to-thread kill.
Clean up (compiler warning elimination).   Compile check options added
but commented out as they have not been checked on all architectures, yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sigwait.c,v 1.12 2003/01/27 22:22:30 marc Exp $	*/
@


1.12
log
@pthreads signal handling improvements.   With these changes all
of the thread regressions tests pass on i386, sparc, sparc64
(save the siginfo test on sparc64 due to a kernel issue) and alpha.
The tests should also pass on ppc.

In addition, it fixes the problems with the "mysql torture test"
provided by one of our users.   The python port also appears to
work correctly with these changes.

Summary of changes:

* check_pending removed from thread structure, no longer used.
* unused elements of sigstatus structure removed.   The sigstatus
  structure is now used to keep track of siginfo data instead of
  defining a local array in uthread_sig.c.
* _thread_kern_sched_sig removed
* _thread_sig_process goes away -- can't have a lock active when
  signal handlers are called.   Functions now call _thread_sig_handle
  directly.
* _thread_clear_pending now used lib wide to clear pending flags.
  It was named _clean_pending_flag and only used in uthread_sig.c.
  The function clears both per thread signals, and per process signals.
* _thread_sig_handle now returns a value.
* unused debugging macros removed from the thread kernel
* dispatch pending signals after switching to a thread providing
  that signal handling hasn't been deferred by the thread.
* process thread switchhooks before dispatching pending sigs
* check for thread cancellation before dispatching pending sigs
* re-wrote pthread-kill to do the correct thing.   It now does
  minimal thread-kill-specific processing and then calls the
  existing code in uthread_sig to process the generated signal.
* shut the compiler up when compiling uthread_mutex.c
* no more "signal_lock".   It does more harm than good.
* keep track of "per-process" signals.
* don't bother saving siginfo_t data for the scheduling signal.
* per posix: SIGSTOP cleared when SIGCONT received and vice versa.
* add _dispatch_signal to properly dispatch a signal to a thread.
  It sets the appropriate signal mask, something that was missing
  in the previous implementation.   This fixes several bugs.
  The previous method held a lock.  If the signal handler longjmp-ed
  the lock was never cleared and no more signals were processed.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sigwait.c,v 1.11 2002/10/30 19:11:56 marc Exp $	*/
d55 1
a55 1
	act.sa_handler = (void (*) ()) _thread_sig_handler;
@


1.11
log
@signal handling changes.   This corrects several signal
handling errors in the threads library.   Most of the libc_r regression
tests are now ok.   thread specific kill semantics are still not correct.
No negative comments after posting to tech@@ a week or so ago.
siginfo test fails on sparc64 due to sparc64 oddity.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sigwait.c,v 1.10 2002/02/21 20:57:41 fgsch Exp $	*/
d85 1
a85 4
		if (sigismember(&curthread->sigpend, i))
			sigdelset(&curthread->sigpend, i);
		else
			sigdelset(&_process_sigpending, i);
@


1.10
log
@account for the process signal mask when dealing with signals; tested
a while ago by marc@@ and brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sigwait.c,v 1.9 2001/08/21 19:24:53 fgsch Exp $	*/
d56 1
a56 1
	act.sa_flags = SA_RESTART;
@


1.9
log
@Start syncing with FreeBSD:

o Implement _get_curthread() and _set_curthread(). Use it where possible.
o Add missing _thread_[enter|leave]_cancellation_point().
o Add a couple of not yet used vars to pthread_private.h.
o Remove return's from void functions.

This is by no means complete, but instead of doing a big commit, i'll
split it in small ones, minimizing diffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sigwait.c,v 1.8 2000/01/06 07:21:14 d Exp $	*/
a49 1
	/* This is a cancellation point: */
a56 1
	act.sa_mask = *set;
d58 2
a59 2
	/* Ensure the scheduling signal is masked: */
	sigaddset(&act.sa_mask, _SCHED_SIGNAL);
d74 4
a77 1
	if ((tempset = (curthread->sigpend & waitset)) != 0) {
d80 1
a80 1
			if (sigismember (&tempset, i))
d85 4
a88 1
		sigdelset(&curthread->sigpend,i);
a92 1
		/* No longer in a cancellation point: */
a93 1

d98 6
d113 1
d117 6
a122 2
			if (_thread_sys_sigaction(i,&act,NULL) != 0)
				ret = -1;
d125 4
a129 1

d150 6
d159 7
a165 4
		if (sigismember(&waitset, i) &&
		    (_thread_sigact[i - 1].sa_handler == SIG_DFL)) {
			if (_thread_sys_sigaction(i,&act,NULL) != 0)
				ret = -1;
d169 3
a171 1
	/* No longer in a cancellation point: */
@


1.8
log
@quieten gcc with extra parens
@
text
@d1 1
a1 1
/*	$OpenBSD: uthread_sigwait.c,v 1.7 1999/11/25 07:01:45 d Exp $	*/
d44 1
d76 1
a76 1
	if ((tempset = (_thread_run->sigpend & waitset)) != 0) {
d84 1
a84 1
		sigdelset(&_thread_run->sigpend,i);
d119 1
a119 1
		_thread_run->data.sigwait = &waitset;
d125 1
a125 1
		*sig = _thread_run->signo;
d131 1
a131 1
		_thread_run->data.sigwait = NULL;
@


1.7
log
@sync with FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 1
a75 1
	if (tempset = (_thread_run->sigpend & waitset)) {
@


1.6
log
@document cancellation point handling a bit better
@
text
@d1 1
d24 1
a24 1
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
d33 1
a33 1
 * $OpenBSD: uthread_sigwait.c,v 1.5 1999/05/26 00:18:26 d Exp $
d46 1
a46 1
	sigset_t	tempset;
d59 3
d63 1
a63 1
	 * These signals can't be waited on.
d65 8
a72 5
	sigdelset(&act.sa_mask, SIGKILL);
	sigdelset(&act.sa_mask, SIGSTOP);
	sigdelset(&act.sa_mask, _SCHED_SIGNAL);
	sigdelset(&act.sa_mask, SIGCHLD);
	sigdelset(&act.sa_mask, SIGINFO);
d75 1
a75 1
	if ((tempset = (_thread_run->sigpend & act.sa_mask))) {
d90 1
d98 1
a98 1
	 * that the application must explicitly install a dummy
d105 4
a108 4
		if (sigismember(&act.sa_mask, i)) {
			if (_thread_sigact[i - 1].sa_handler == SIG_DFL)
				if (_thread_sys_sigaction(i,&act,NULL) != 0)
					ret = -1;
d118 1
a118 1
		_thread_run->data.sigwait = &act.sa_mask;
d136 1
a136 1
		if (sigismember(&act.sa_mask, i) &&
@


1.5
log
@sync with FreeBSD
@
text
@d32 1
a32 1
 * $OpenBSD: uthread_sigwait.c,v 1.4 1999/01/17 23:57:27 d Exp $
d48 1
d50 1
d81 1
d135 1
@


1.4
log
@pthread_cancel() and cancellation points
@
text
@d32 1
a32 1
 * $OpenBSD: uthread_sigwait.c,v 1.3 1999/01/06 05:29:28 d Exp $
d61 1
a61 1
	sigdelset(&act.sa_mask, SIGVTALRM);
@


1.3
log
@ident
@
text
@d32 1
a32 1
 * $OpenBSD$
d48 1
d79 1
d131 2
@


1.2
log
@sync with FreeBSD (rwlock, gc thread, man pages)
add (broken) mips md stuff
fix some const warnings
add sigaltstack() stub
another hash at getting shlib auto-init to work (mips/elf and i386/a.out)
@
text
@d32 1
@


1.1
log
@experimental threaded libc - kernel only
@
text
@d44 1
a44 1
	sigset_t	oset;
d63 17
d86 3
a88 1
	 * on them, so we ignore SIG_IGN signals.
d92 1
a92 1
			if (_thread_sigact[i - 1].sa_handler == SIG_DFL) {
a94 3
			}
			else if (_thread_sigact[i - 1].sa_handler == SIG_IGN)
				sigdelset(&act.sa_mask, i);
d99 6
a104 5
		/* Save the current signal mask: */
		oset = _thread_run->sigmask;

		/* Combine the caller's mask with the current one: */
		_thread_run->sigmask |= act.sa_mask;
d112 5
a116 2
		/* Restore the signal mask: */
		_thread_run->sigmask = oset;
@

