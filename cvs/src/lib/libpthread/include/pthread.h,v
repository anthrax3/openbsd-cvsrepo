head	1.41;
access;
symbols
	OPENBSD_6_2:1.41.0.8
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.41.0.10
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.6
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.40.0.4
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.40.0.8
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.6
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.30.0.6
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.4
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.4
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.26.0.4
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.23.0.8
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17;
locks; strict;
comment	@ * @;


1.41
date	2015.03.19.21.18.59;	author kettenis;	state Exp;
branches;
next	1.40;
commitid	OCR7PM8QjF9cGeeD;

1.40
date	2013.06.17.19.11.54;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2012.12.05.23.20.05;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2012.11.05.08.58.39;	author landry;	state Exp;
branches;
next	1.37;

1.37
date	2012.05.14.23.21.35;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	2012.05.03.09.07.17;	author pirofti;	state Exp;
branches;
next	1.35;

1.35
date	2012.04.14.12.07.49;	author kurt;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.12.12.09.30;	author kurt;	state Exp;
branches;
next	1.33;

1.33
date	2012.04.11.10.18.46;	author pirofti;	state Exp;
branches;
next	1.32;

1.32
date	2012.02.23.04.43.06;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.03.16.53.48;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.12.01.54.23;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.18.09.30.32;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.25.14.58.54;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.15.12.42.39;	author kurt;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.30.19.13.04;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.31.20.48.30;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.30.04.00.38;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.24.00.49.43;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.22.23.59.26;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.22.06.25.33;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.16.22.48.40;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.27.21.56.15;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.23.22.37.03;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.27.07.03.21;	author cloder;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.17.19.42.24;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.25;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.10.00.45.30;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.08.14.51.36;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2000.12.06.17.18.47;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.06.07.06.00;	author d;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.04.22.34.23;	author alex;	state Exp;
branches;
next	1.9;

1.9
date	99.11.25.07.01.29;	author d;	state Exp;
branches;
next	1.8;

1.8
date	99.06.15.00.10.37;	author d;	state Exp;
branches;
next	1.7;

1.7
date	99.05.26.00.17.41;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.03.10.10.00.47;	author d;	state Exp;
branches;
next	1.5;

1.5
date	99.01.18.00.00.31;	author d;	state Exp;
branches;
next	1.4;

1.4
date	98.12.21.07.30.25;	author d;	state Exp;
branches;
next	1.3;

1.3
date	98.12.10.00.40.19;	author d;	state Exp;
branches;
next	1.2;

1.2
date	98.11.09.03.13.14;	author d;	state Exp;
branches;
next	1.1;

1.1
date	98.09.05.07.40.47;	author d;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Provide #defines for the mutex types as required by POSIX.  Pointed out by
guenther@@ and found out the hard way by landry@@

ok guenther@@
@
text
@/*	$OpenBSD: pthread.h,v 1.40 2013/06/17 19:11:54 guenther Exp $	*/

/*
 * Copyright (c) 1993, 1994 by Chris Provenzano, proven@@mit.edu
 * Copyright (c) 1995-1998 by John Birrell <jb@@cimlogic.com.au>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Chris Provenzano.
 * 4. The name of Chris Provenzano may not be used to endorse or promote 
 *	  products derived from this software without specific prior written
 *	  permission.
 *
 * THIS SOFTWARE IS PROVIDED BY CHRIS PROVENZANO ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL CHRIS PROVENZANO BE LIABLE FOR ANY 
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 *
 * $FreeBSD: pthread.h,v 1.13 1999/07/31 08:36:07 rse Exp $
 */
#ifndef _PTHREAD_H_
#define _PTHREAD_H_

/*
 * Header files.
 */
#include <sys/types.h>
#include <sys/time.h>
#include <sys/signal.h>
#include <limits.h>
#include <sched.h>

/*
 * Run-time invariant values:
 */
#define PTHREAD_DESTRUCTOR_ITERATIONS		4
#define PTHREAD_KEYS_MAX			256
#define PTHREAD_STACK_MIN			2048
#define PTHREAD_THREADS_MAX			ULONG_MAX

/*
 * Flags for threads and thread attributes.
 */
#define PTHREAD_DETACHED            0x1
#define PTHREAD_SCOPE_SYSTEM        0x2
#define PTHREAD_INHERIT_SCHED       0x4
#define PTHREAD_NOFLOAT             0x8

#define PTHREAD_CREATE_DETACHED     PTHREAD_DETACHED
#define PTHREAD_CREATE_JOINABLE     0
#define PTHREAD_SCOPE_PROCESS       0
#define PTHREAD_EXPLICIT_SCHED      0

/*
 * Flags for read/write lock attributes
 */
#define PTHREAD_PROCESS_PRIVATE     0
#define PTHREAD_PROCESS_SHARED      1	

/*
 * Flags for cancelling threads
 */
#define PTHREAD_CANCEL_ENABLE		0
#define PTHREAD_CANCEL_DISABLE		1
#define PTHREAD_CANCEL_DEFERRED		0
#define PTHREAD_CANCEL_ASYNCHRONOUS	2
#define PTHREAD_CANCELED		((void *) 1)

/*
 * Barrier flags
 */
#define PTHREAD_BARRIER_SERIAL_THREAD -1

/*
 * Forward structure definitions.
 *
 * These are mostly opaque to the user.
 */
struct pthread;
struct pthread_attr;
struct pthread_cond;
struct pthread_cond_attr;
struct pthread_mutex;
struct pthread_mutex_attr;
struct pthread_once;
struct pthread_rwlock;
struct pthread_rwlockattr;

/*
 * Primitive system data type definitions required by P1003.1c.
 *
 * Note that P1003.1c specifies that there are no defined comparison
 * or assignment operators for the types pthread_attr_t, pthread_cond_t,
 * pthread_condattr_t, pthread_mutex_t, pthread_mutexattr_t.
 */
typedef struct	pthread			*pthread_t;
typedef struct	pthread_attr		*pthread_attr_t;
typedef volatile struct pthread_mutex	*pthread_mutex_t;
typedef struct	pthread_mutex_attr	*pthread_mutexattr_t;
typedef struct	pthread_cond		*pthread_cond_t;
typedef struct	pthread_cond_attr	*pthread_condattr_t;
typedef int				pthread_key_t;
typedef struct	pthread_once		pthread_once_t;
typedef struct	pthread_rwlock		*pthread_rwlock_t;
typedef struct	pthread_rwlockattr	*pthread_rwlockattr_t;
typedef struct	pthread_barrier		*pthread_barrier_t;
typedef struct	pthread_barrierattr	*pthread_barrierattr_t;
typedef struct	pthread_spinlock	*pthread_spinlock_t;

/*
 * Additional type definitions:
 *
 * Note that P1003.1c reserves the prefixes pthread_ and PTHREAD_ for
 * use in header symbols.
 */
typedef void	*pthread_addr_t;
typedef void	*(*pthread_startroutine_t)(void *);

/*
 * Once definitions.
 */
struct pthread_once {
	int		state;
	pthread_mutex_t	mutex;
};

/*
 * Flags for once initialization.
 */
#define PTHREAD_NEEDS_INIT  0
#define PTHREAD_DONE_INIT   1

/*
 * Static once initialization values. 
 */
#define PTHREAD_ONCE_INIT   { PTHREAD_NEEDS_INIT, PTHREAD_MUTEX_INITIALIZER }

/*
 * Static initialization values. 
 */
#define PTHREAD_MUTEX_INITIALIZER	NULL
#define PTHREAD_COND_INITIALIZER	NULL
#define PTHREAD_RWLOCK_INITIALIZER	NULL

#define PTHREAD_PRIO_NONE	0
#define PTHREAD_PRIO_INHERIT	1
#define PTHREAD_PRIO_PROTECT	2

/*
 * Mutex types.
 */
enum pthread_mutextype {
	PTHREAD_MUTEX_ERRORCHECK	= 1,	/* Error checking mutex */
	PTHREAD_MUTEX_RECURSIVE		= 2,	/* Recursive mutex */
	PTHREAD_MUTEX_NORMAL		= 3,	/* No error checking */
	PTHREAD_MUTEX_STRICT_NP		= 4,	/* Strict error checking */
	PTHREAD_MUTEX_TYPE_MAX
};

#define PTHREAD_MUTEX_ERRORCHECK	PTHREAD_MUTEX_ERRORCHECK
#define PTHREAD_MUTEX_RECURSIVE		PTHREAD_MUTEX_RECURSIVE
#define PTHREAD_MUTEX_NORMAL		PTHREAD_MUTEX_NORMAL
#define PTHREAD_MUTEX_STRICT_NP		PTHREAD_MUTEX_STRICT_NP
#define PTHREAD_MUTEX_DEFAULT		PTHREAD_MUTEX_STRICT_NP

/*
 * Thread function prototype definitions:
 */
__BEGIN_DECLS
int		pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
int		pthread_attr_destroy(pthread_attr_t *);
int		pthread_attr_getstack(const pthread_attr_t *,
			void **, size_t *);
int		pthread_attr_getstacksize(const pthread_attr_t *, size_t *);
int		pthread_attr_getstackaddr(const pthread_attr_t *, void **);
int		pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
int		pthread_attr_getdetachstate(const pthread_attr_t *, int *);
int		pthread_attr_init(pthread_attr_t *);
int		pthread_attr_setstacksize(pthread_attr_t *, size_t);
int		pthread_attr_setstack(pthread_attr_t *, void *, size_t);
int		pthread_attr_setstackaddr(pthread_attr_t *, void *);
int		pthread_attr_setguardsize(pthread_attr_t *, size_t);
int		pthread_attr_setdetachstate(pthread_attr_t *, int);
void		pthread_cleanup_pop(int);
void		pthread_cleanup_push(void (*) (void *), void *routine_arg);
int		pthread_condattr_destroy(pthread_condattr_t *);
int		pthread_condattr_init(pthread_condattr_t *);

int		pthread_cond_broadcast(pthread_cond_t *);
int		pthread_cond_destroy(pthread_cond_t *);
int		pthread_cond_init(pthread_cond_t *,
			const pthread_condattr_t *);
int		pthread_cond_signal(pthread_cond_t *);
int		pthread_cond_timedwait(pthread_cond_t *,
			pthread_mutex_t *, const struct timespec *);
int		pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
int		pthread_create(pthread_t *, const pthread_attr_t *,
			void *(*) (void *), void *);
int		pthread_detach(pthread_t);
int		pthread_equal(pthread_t, pthread_t);
__dead void	pthread_exit(void *);
void		*pthread_getspecific(pthread_key_t);
int		pthread_join(pthread_t, void **);
int		pthread_key_create(pthread_key_t *,
			void (*) (void *));
int		pthread_key_delete(pthread_key_t);
int		pthread_kill(pthread_t, int);
int		pthread_mutexattr_init(pthread_mutexattr_t *);
int		pthread_mutexattr_destroy(pthread_mutexattr_t *);
int		pthread_mutexattr_gettype(pthread_mutexattr_t *, int *);
int		pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int		pthread_mutex_destroy(pthread_mutex_t *);
int		pthread_mutex_init(pthread_mutex_t *,
			const pthread_mutexattr_t *);
int		pthread_mutex_lock(pthread_mutex_t *);
int		pthread_mutex_timedlock(pthread_mutex_t *,
		    const struct timespec *);
int		pthread_mutex_trylock(pthread_mutex_t *);
int		pthread_mutex_unlock(pthread_mutex_t *);
int		pthread_once(pthread_once_t *, void (*) (void));
int		pthread_rwlock_destroy(pthread_rwlock_t *);
int		pthread_rwlock_init(pthread_rwlock_t *,
			const pthread_rwlockattr_t *);
int		pthread_rwlock_rdlock(pthread_rwlock_t *);
int		pthread_rwlock_timedrdlock(pthread_rwlock_t *,
			const struct timespec *);
int		pthread_rwlock_timedwrlock(pthread_rwlock_t *,
			const struct timespec *);
int		pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int		pthread_rwlock_trywrlock(pthread_rwlock_t *);
int		pthread_rwlock_unlock(pthread_rwlock_t *);
int		pthread_rwlock_wrlock(pthread_rwlock_t *);
int		pthread_rwlockattr_init(pthread_rwlockattr_t *);
int		pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *,
			int *);
int		pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
int		pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
pthread_t	pthread_self(void);
int		pthread_setspecific(pthread_key_t, const void *);

int		pthread_cancel(pthread_t);
int		pthread_setcancelstate(int, int *);
int		pthread_setcanceltype(int, int *);
void		pthread_testcancel(void);

int		pthread_getprio(pthread_t);
int		pthread_setprio(pthread_t, int);
void		pthread_yield(void);

int		pthread_mutexattr_getprioceiling(pthread_mutexattr_t *,
			int *);
int		pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,
			int);
int		pthread_mutex_getprioceiling(pthread_mutex_t *, int *);
int		pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *);

int		pthread_mutexattr_getprotocol(pthread_mutexattr_t *, int *);
int		pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

int		pthread_condattr_getclock(const pthread_condattr_t *,
		    clockid_t *);
int		pthread_condattr_setclock(pthread_condattr_t *, clockid_t);

int		pthread_attr_getinheritsched(const pthread_attr_t *, int *);
int		pthread_attr_getschedparam(const pthread_attr_t *,
			struct sched_param *);
int		pthread_attr_getschedpolicy(const pthread_attr_t *, int *);
int		pthread_attr_getscope(const pthread_attr_t *, int *);
int		pthread_attr_setinheritsched(pthread_attr_t *, int);
int		pthread_attr_setschedparam(pthread_attr_t *,
			const struct sched_param *);
int		pthread_attr_setschedpolicy(pthread_attr_t *, int);
int		pthread_attr_setscope(pthread_attr_t *, int);
int		pthread_getschedparam(pthread_t pthread, int *,
			struct sched_param *);
int		pthread_setschedparam(pthread_t, int,
			const struct sched_param *);
int		pthread_getconcurrency(void);
int		pthread_setconcurrency(int);
int		pthread_barrier_init(pthread_barrier_t *,
		    pthread_barrierattr_t *, unsigned int);
int		pthread_barrier_destroy(pthread_barrier_t *);
int		pthread_barrier_wait(pthread_barrier_t *);
int		pthread_barrierattr_init(pthread_barrierattr_t *);
int		pthread_barrierattr_destroy(pthread_barrierattr_t *);
int		pthread_barrierattr_getpshared(pthread_barrierattr_t *, int *);
int		pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
int		pthread_spin_init(pthread_spinlock_t *, int);
int		pthread_spin_destroy(pthread_spinlock_t *);
int		pthread_spin_trylock(pthread_spinlock_t *);
int		pthread_spin_lock(pthread_spinlock_t *);
int		pthread_spin_unlock(pthread_spinlock_t *);

#if __POSIX_VISIBLE >= 200112
int		pthread_getcpuclockid(pthread_t, clockid_t *);
#endif
__END_DECLS

#endif /* _PTHREAD_H_ */
@


1.40
log
@Add support for the _POSIX_CPUTIME and _POSIX_THREAD_CPUTIME options,
including CLOCK_{PROCESS,THREAD}_CPUTIME_ID constants and
{clock,pthread}_getcpuclockid() functions.

Worked out at t2k13 with help from tedu@@ and matthew@@ and testing by aja@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.39 2012/12/05 23:20:05 deraadt Exp $	*/
d166 1
a166 8
 * Mutex types (Single UNIX Specification, Version 2, 1997).
 *
 * Note that a mutex attribute with one of the following types:
 *
 *	PTHREAD_MUTEX_NORMAL
 *	PTHREAD_MUTEX_RECURSIVE
 *
 * will deviate from POSIX specified semantics.
d176 4
@


1.39
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.38 2012/11/05 08:58:39 landry Exp $	*/
d312 4
@


1.38
log
@typedef pthread_key_t to an int instead of a volatile int, reverts a chunk
from r1.11. This allows webkit with --enable-debug to build, and is in
line with what FreeBSD/NetBSD uses.
ok kettenis@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.37 2012/05/14 23:21:35 matthew Exp $	*/
a42 1
#include <sys/cdefs.h>
@


1.37
log
@More sysconf(3)-y and pathconf(3)-y goodness from Brad.
ok guenther, millert (and me); bulk build test by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.36 2012/05/03 09:07:17 pirofti Exp $	*/
d119 1
a119 1
typedef volatile int  			pthread_key_t;
@


1.36
log
@Add pthread spinlock support.

Implementation, documentation and naive regression tests for:
- pthread_spin_init()
- pthread_spin_destroy()
- pthread_spin_lock()
- pthread_spin_trylock()
- pthread_spin_unlock()

Implementation okay guenther@@, documentation okay jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.35 2012/04/14 12:07:49 kurt Exp $	*/
a56 14

/*
 * Compile time symbolic constants for portability specifications:
 *
 * Note that those commented out are not currently supported by the
 * implementation.
 */
#define _POSIX_THREADS				1
#define _POSIX_THREAD_ATTR_STACKADDR		1
#define _POSIX_THREAD_ATTR_STACKSIZE		1
#define _POSIX_THREAD_PRIORITY_SCHEDULING	1
#define _POSIX_THREAD_PRIO_INHERIT		1
#define _POSIX_THREAD_PRIO_PROTECT		1
/* #define _POSIX_THREAD_PROCESS_SHARED */
@


1.35
log
@Add new mutex type, PTHREAD_MUTEX_STRICT_NP which checks for application
errors similar to PTHREAD_MUTEX_ERRORCHECK, however upon error it aborts.
The rational is that many applications don't check the return values on
pthread functions and will miss the errors that ERRORCHECK returns.
PTHREAD_MUTEX_STRICT_NP will be our default mutex type for awhile
okay guenther@@ dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.34 2012/04/12 12:09:30 kurt Exp $	*/
d139 1
d322 5
@


1.34
log
@Remove incorrect -pthread preprocessor define _POSIX_THREADS and replace
with _REENTRANT. Also remove undef _POSIX_THREADS in phread.h.
From brad@@comstyle.com. okay guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.33 2012/04/11 10:18:46 pirofti Exp $	*/
d190 1
a190 1
	PTHREAD_MUTEX_ERRORCHECK	= 1,	/* Default POSIX mutex */
d193 1
d197 1
a197 1
#define PTHREAD_MUTEX_DEFAULT		PTHREAD_MUTEX_ERRORCHECK
@


1.33
log
@Add pthread barrier support.

Implementation and documentation for:
 - pthread_barrier_init()
 - pthread_barrier_destroy()
 - pthread_barrier_wait()
 - pthread_barrierattr_init()
 - pthread_barrierattr_destroy()
 - pthread_barrierattr_getpshared()
 - pthread_barrierattr_setpshared()

Currently only private barriers are supported.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.32 2012/02/23 04:43:06 guenther Exp $	*/
a38 5

/* Previous releases of OpenBSD used a hacked gcc that defined this */
#ifdef _POSIX_THREADS
#undef _POSIX_THREADS	/* Allow to be defined below */
#endif
@


1.32
log
@Add pthread_condattr_{get,set}clock(), requested by aja@@
Add pthread_mutex_timedlock(), requested by dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.31 2012/01/03 16:53:48 kettenis Exp $	*/
d106 5
d142 2
d317 8
@


1.31
log
@The prototype for pthread_sigmask(2) is supposed to live in <signal.h>
instead of <pthread.h>.

ok guenther@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.30 2010/04/12 01:54:23 tedu Exp $	*/
d246 2
d289 4
@


1.30
log
@Add support for pthread_rwlock_timed locks.
from brad.  ok kurt, who's too busy to commit
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.29 2008/12/18 09:30:32 guenther Exp $	*/
a267 1
int		pthread_sigmask(int, const sigset_t *, sigset_t *);
@


1.29
log
@Add pthread_attr_[sg]etguardsize() to match rthread, including manpages
Bump lib minor

ok otto@@ kurt@@ marc@@; doc review by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.28 2008/06/25 14:58:54 millert Exp $	*/
d253 4
@


1.28
log
@Move _POSIX_THREAD_SAFE_FUNCTIONS into unistd.h and set it to 200112
now that we support all the _r functions required by POSIX 1003.1-2001.
Also define _POSIX_REENTRANT_FUNCTIONS.  OK kurt@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.27 2007/03/15 12:42:39 kurt Exp $	*/
d206 1
d212 1
@


1.27
log
@give _POSIX_THREAD_* defines a value of 1 so applications that
conditionally compile code using these defines will work.
okay tedu@@, marc@@, milllert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.26 2006/05/30 19:13:04 otto Exp $	*/
a75 1
#define _POSIX_THREAD_SAFE_FUNCTIONS		1
@


1.26
log
@Bump minimum stack size; current setting causes hangs or illegal
instructions once every few runs. Problem noted by Botond Botyanszki.
ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.25 2005/10/31 20:48:30 brad Exp $	*/
d69 6
a74 6
#define _POSIX_THREADS
#define _POSIX_THREAD_ATTR_STACKADDR
#define _POSIX_THREAD_ATTR_STACKSIZE
#define _POSIX_THREAD_PRIORITY_SCHEDULING
#define _POSIX_THREAD_PRIO_INHERIT
#define _POSIX_THREAD_PRIO_PROTECT
d76 1
a76 1
#define _POSIX_THREAD_SAFE_FUNCTIONS
@


1.25
log
@- Prefix MUTEX_TYPE_MAX with PTHREAD_ to avoid namespace pollution.
- Remove the macros MUTEX_TYPE_FAST and MUTEX_TYPE_COUNTING_FAST.

From stefanf FreeBSD

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.24 2005/10/30 04:00:38 brad Exp $	*/
d60 1
a60 1
#define PTHREAD_STACK_MIN			1024
@


1.24
log
@and make sure the header change goes in too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.23 2004/02/24 00:49:43 brad Exp $	*/
a184 2
 *      MUTEX_TYPE_FAST (deprecated)
 *	MUTEX_TYPE_COUNTING_FAST (deprecated)
d192 1
a192 1
	MUTEX_TYPE_MAX
a195 2
#define MUTEX_TYPE_FAST			PTHREAD_MUTEX_NORMAL
#define MUTEX_TYPE_COUNTING_FAST	PTHREAD_MUTEX_RECURSIVE
@


1.23
log
@Sync closer to FreeBSD's pthread.h. Fixes up some prototypes
and formatting.

ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.19 2004/01/27 21:56:15 brad Exp $	*/
d205 1
@


1.22
log
@add pthread_attr_[get|set]stack

From: FreeBSD's libc_r

ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.21 2004/02/22 06:25:33 brad Exp $	*/
d212 1
a213 1
int		pthread_attr_setstacksize(pthread_attr_t *, size_t);
d216 4
a219 5
void		pthread_cleanup_pop(int execute);
void		pthread_cleanup_push(void (*routine)(void *),
		    void *routine_arg);
int		pthread_condattr_destroy(pthread_condattr_t *attr);
int		pthread_condattr_init(pthread_condattr_t *attr);
d223 2
a224 1
int		pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *);
d227 1
a227 1
		    pthread_mutex_t *, const struct timespec * abstime);
d230 1
a230 1
		    void *(*start_routine) (void *), void *);
d236 2
a237 1
int		pthread_key_create(pthread_key_t *, void (*routine)(void *));
d239 1
a239 1
int		pthread_kill(struct pthread *, int);
d246 1
a246 1
		    const pthread_mutexattr_t *);
d250 1
a250 1
int		pthread_once(pthread_once_t *, void (*)(void));
d253 1
a253 1
		    const pthread_rwlockattr_t *);
d261 1
a261 1
		    int *);
d278 1
a278 1
		    int *prioceiling);
d280 1
a280 1
		    int prioceiling);
d284 2
a285 11
int		pthread_mutexattr_getprotocol(pthread_mutexattr_t *,
		    int *protocol);
int		pthread_mutexattr_setprotocol(pthread_mutexattr_t *,
		    int protocol);

int		pthread_getschedparam(pthread_t pthread, int *policy,
		    struct sched_param * param);
int		pthread_setschedparam(pthread_t pthread, int policy,
		    const struct sched_param * param);
int		pthread_getconcurrency(void);
int		pthread_setconcurrency(int);
d289 1
a289 1
		    struct sched_param *);
d294 1
a294 1
		    const struct sched_param *);
d297 6
@


1.21
log
@Some cleanup of pthread.h. Don't conditionalize
inclusion of prototypes. Remove some prototypes
for functions we do not implement.

From: FreeBSD's libc_r

ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.20 2004/02/16 22:48:40 brad Exp $	*/
d206 2
d212 1
a304 1

@


1.20
log
@Add missing const for function parameters to match POSIX.

From: FreeBSD's libc_r

ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.19 2004/01/27 21:56:15 brad Exp $	*/
a174 1
#ifdef _POSIX_THREAD_PRIO_PROTECT
a176 1
#endif
a218 7
#if defined(_POSIX_THREAD_PROCESS_SHARED)
int		pthread_condattr_getpshared(const pthread_condattr_t *attr,
		    int *pshared);
int		pthread_condattr_setpshared(pthread_condattr_t *attr,
		    int pshared);
#endif

a272 8
#if defined(_POSIX_THREAD_PROCESS_SHARED)
int		pthread_mutexattr_getpshared(pthread_mutexattr_t *,
		    int *pshared);
int		pthread_mutexattr_setpshared(pthread_mutexattr_t *,
		    int pshared);
#endif

#if defined(_POSIX_THREAD_PRIO_PROTECT)
a278 1
#endif
a279 1
#if defined(_POSIX_THREAD_PRIO_PROTECT) || defined (_POSIX_THREAD_PRIO_INHERIT)
a283 1
#endif
a291 1
#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING)
a301 18
#endif

int		pthread_attr_setfloatstate(pthread_attr_t *, int);
int		pthread_attr_getfloatstate(pthread_attr_t *, int *);
int		pthread_attr_setcleanup(pthread_attr_t *,
		    void (*routine)(void *), void *);


#ifdef notyet
/*
 * Single Unix Specification v2 (UNIX98) defines these:
 */
#define PTHREAD_PRIO_INHERIT
#define PTHREAD_PRIO_NONE
#define PTHREAD_PRIO_PROTECT
int		pthread_attr_getguardsize(const pthread_attr_t *, size_t *);
int		pthread_attr_setguardsize(const pthread_attr_t *, size_t);
#endif	/* susv2 */
@


1.19
log
@remove redundant prototypes for pthread_[gs]etconcurrency
in-between #ifdef notyet
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.18 2003/12/23 22:37:03 brad Exp $	*/
d208 2
a209 2
int		pthread_attr_getstacksize(pthread_attr_t *, size_t *);
int		pthread_attr_getstackaddr(pthread_attr_t *, void **);
@


1.18
log
@Add stub implementations of pthread_[gs]etconcurrency

From: FreeBSD' libc_r

ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.17 2003/02/27 07:03:21 cloder Exp $	*/
a339 2
int		pthread_getconcurrency(void);
int		pthread_setconcurrency(int);
@


1.17
log
@Don't need to specify both __dead and __attribute__((__noreturn__)) for
pthread_exit prototype.  Replace with just __dead.
OK millert@@, marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.16 2002/02/17 19:42:24 millert Exp $	*/
d309 2
@


1.16
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.15 2002/02/16 21:27:25 millert Exp $	*/
d239 1
a239 1
__dead void	pthread_exit(void *) __attribute__((__noreturn__));
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.14 2002/01/10 00:45:30 fgsch Exp $	*/
d210 1
a210 2
int		pthread_attr_getdetachstate __P((const pthread_attr_t *,
			int *));
d216 2
a217 2
void		pthread_cleanup_push __P((void (*routine) (void *),
			void *routine_arg));
d222 4
a225 4
int		pthread_condattr_getpshared __P((const pthread_condattr_t *attr,
			int *pshared));
int		pthread_condattr_setpshared __P((pthread_condattr_t *attr,
			int pshared));
d230 1
a230 2
int		pthread_cond_init __P((pthread_cond_t *,
			const pthread_condattr_t *));
d232 2
a233 2
int		pthread_cond_timedwait __P((pthread_cond_t *,
			pthread_mutex_t *, const struct timespec * abstime));
d235 2
a236 2
int		pthread_create __P((pthread_t *, const pthread_attr_t *,
			void *(*start_routine) (void *), void *));
d242 1
a242 2
int		pthread_key_create __P((pthread_key_t *,
			void (*routine) (void *)));
d250 2
a251 2
int		pthread_mutex_init __P((pthread_mutex_t *,
			const pthread_mutexattr_t *));
d255 1
a255 2
int		pthread_once __P((pthread_once_t *,
			void (*) (void)));
d257 2
a258 2
int		pthread_rwlock_init __P((pthread_rwlock_t *,
			const pthread_rwlockattr_t *));
d265 3
a267 4
int		pthread_rwlockattr_getpshared __P((const pthread_rwlockattr_t *,
			int *));
int		pthread_rwlockattr_setpshared __P((pthread_rwlockattr_t *,
			int));
d283 4
a286 4
int		pthread_mutexattr_getpshared __P((pthread_mutexattr_t *,
			int *pshared));
int		pthread_mutexattr_setpshared __P((pthread_mutexattr_t *,
			int pshared));
d290 4
a293 4
int		pthread_mutexattr_getprioceiling __P((pthread_mutexattr_t *,
			int *prioceiling));
int		pthread_mutexattr_setprioceiling __P((pthread_mutexattr_t *,
			int prioceiling));
d295 1
a295 2
int		pthread_mutex_setprioceiling __P((pthread_mutex_t *, int,
			int *));
d299 4
a302 4
int		pthread_mutexattr_getprotocol __P((pthread_mutexattr_t *,
			int *protocol));
int		pthread_mutexattr_setprotocol __P((pthread_mutexattr_t *,
			int protocol));
d305 4
a308 4
int		pthread_getschedparam __P((pthread_t pthread, int *policy,
			struct sched_param * param));
int		pthread_setschedparam __P((pthread_t pthread, int policy,
			const struct sched_param * param));
d312 2
a313 2
int		pthread_attr_getschedparam __P((const pthread_attr_t *,
			struct sched_param *));
d317 2
a318 2
int		pthread_attr_setschedparam __P((pthread_attr_t *,
			const struct sched_param *));
d325 2
a326 2
int		pthread_attr_setcleanup __P((pthread_attr_t *,
			void (*routine) (void *), void *));
d336 2
a337 4
int		pthread_attr_getguardsize __P((const pthread_attr_t *, 
			size_t *));
int		pthread_attr_setguardsize __P((const pthread_attr_t *, 
			size_t));
@


1.14
log
@Change 1st arg in pthread_attr_getdetachstate to const.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.13 2001/12/08 14:51:36 fgsch Exp $	*/
d146 1
a146 1
typedef void	*(*pthread_startroutine_t) __P((void *));
d207 3
a209 3
int		pthread_attr_destroy __P((pthread_attr_t *));
int		pthread_attr_getstacksize __P((pthread_attr_t *, size_t *));
int		pthread_attr_getstackaddr __P((pthread_attr_t *, void **));
d212 5
a216 5
int		pthread_attr_init __P((pthread_attr_t *));
int		pthread_attr_setstacksize __P((pthread_attr_t *, size_t));
int		pthread_attr_setstackaddr __P((pthread_attr_t *, void *));
int		pthread_attr_setdetachstate __P((pthread_attr_t *, int));
void		pthread_cleanup_pop __P((int execute));
d219 2
a220 2
int		pthread_condattr_destroy __P((pthread_condattr_t *attr));
int		pthread_condattr_init __P((pthread_condattr_t *attr));
d229 2
a230 2
int		pthread_cond_broadcast __P((pthread_cond_t *));
int		pthread_cond_destroy __P((pthread_cond_t *));
d233 1
a233 1
int		pthread_cond_signal __P((pthread_cond_t *));
d236 1
a236 1
int		pthread_cond_wait __P((pthread_cond_t *, pthread_mutex_t *));
d239 5
a243 5
int		pthread_detach __P((pthread_t));
int		pthread_equal __P((pthread_t, pthread_t));
__dead void	pthread_exit __P((void *)) __attribute__((__noreturn__));
void		*pthread_getspecific __P((pthread_key_t));
int		pthread_join __P((pthread_t, void **));
d246 7
a252 7
int		pthread_key_delete __P((pthread_key_t));
int		pthread_kill __P((struct pthread *, int));
int		pthread_mutexattr_init __P((pthread_mutexattr_t *));
int		pthread_mutexattr_destroy __P((pthread_mutexattr_t *));
int		pthread_mutexattr_gettype __P((pthread_mutexattr_t *, int *));
int		pthread_mutexattr_settype __P((pthread_mutexattr_t *, int));
int		pthread_mutex_destroy __P((pthread_mutex_t *));
d255 3
a257 3
int		pthread_mutex_lock __P((pthread_mutex_t *));
int		pthread_mutex_trylock __P((pthread_mutex_t *));
int		pthread_mutex_unlock __P((pthread_mutex_t *));
d260 1
a260 1
int		pthread_rwlock_destroy __P((pthread_rwlock_t *));
d263 6
a268 6
int		pthread_rwlock_rdlock __P((pthread_rwlock_t *));
int		pthread_rwlock_tryrdlock __P((pthread_rwlock_t *));
int		pthread_rwlock_trywrlock __P((pthread_rwlock_t *));
int		pthread_rwlock_unlock __P((pthread_rwlock_t *));
int		pthread_rwlock_wrlock __P((pthread_rwlock_t *));
int		pthread_rwlockattr_init __P((pthread_rwlockattr_t *));
d273 13
a285 13
int		pthread_rwlockattr_destroy __P((pthread_rwlockattr_t *));
pthread_t	pthread_self __P((void));
int		pthread_setspecific __P((pthread_key_t, const void *));
int		pthread_sigmask __P((int, const sigset_t *, sigset_t *));

int		pthread_cancel __P((pthread_t));
int		pthread_setcancelstate __P((int, int *));
int		pthread_setcanceltype __P((int, int *));
void		pthread_testcancel __P((void));

int		pthread_getprio __P((pthread_t));
int		pthread_setprio __P((pthread_t, int));
void		pthread_yield __P((void));
d299 1
a299 1
int		pthread_mutex_getprioceiling __P((pthread_mutex_t *, int *));
d317 1
a317 1
int		pthread_attr_getinheritsched __P((const pthread_attr_t *, int *));
d320 3
a322 3
int		pthread_attr_getschedpolicy __P((const pthread_attr_t *, int *));
int		pthread_attr_getscope __P((const pthread_attr_t *, int *));
int		pthread_attr_setinheritsched __P((pthread_attr_t *, int));
d325 2
a326 2
int		pthread_attr_setschedpolicy __P((pthread_attr_t *, int));
int		pthread_attr_setscope __P((pthread_attr_t *, int));
d329 2
a330 2
int		pthread_attr_setfloatstate __P((pthread_attr_t *, int));
int		pthread_attr_getfloatstate __P((pthread_attr_t *, int *));
d346 2
a347 2
int		pthread_getconcurrency __P((void));
int		pthread_setconcurrency __P((int));
@


1.13
log
@Partially sync with FreeBSD; mostly pthread_cancel(3) related changes.
make includes is needed in case you want to play.
@
text
@d1 1
a1 1
/*	$OpenBSD: pthread.h,v 1.12 2000/12/06 17:18:47 deraadt Exp $	*/
d210 2
a211 1
int		pthread_attr_getdetachstate __P((pthread_attr_t *, int *));
@


1.12
log
@use __x__ formats for __attribute__ arguments; guenther@@gac.edu
@
text
@d1 2
a34 2
 * $OpenBSD: pthread.h,v 1.11 2000/01/06 07:06:00 d Exp $
 *
d103 1
a103 1
#define PTHREAD_CANCEL_ASYNCHRONOUS	1
d249 1
d310 5
a325 4
int		pthread_getschedparam __P((pthread_t pthread, int *policy,
			struct sched_param * param));
int		pthread_setschedparam __P((pthread_t pthread, int policy,
			const struct sched_param * param));
a345 2
int		pthread_mutexattr_gettype __P((const pthread_mutexattr_t *,
			int *));
@


1.11
log
@always define _POSIX_THREADS; volatile some types (mickey@@)
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.10 2000/01/04 22:34:23 alex Exp $
d240 1
a240 1
__dead void	pthread_exit __P((void *)) __attribute__((noreturn));
@


1.10
log
@Fix incorrect `pshared' argument type for pthread_rwlockattr_setpshared.
rse@@engelschall.com via FreeBSD.
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.9 1999/11/25 07:01:29 d Exp $
d40 1
d42 1
a42 4
#ifdef notyet
#warning -pthread option no longer needed - upgrade gcc
#endif
#undef _POSIX_THREADS
d130 1
a130 1
typedef struct	pthread_mutex		*pthread_mutex_t;
d134 1
a134 1
typedef int     			pthread_key_t;
@


1.9
log
@sync with FreeBSD
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.8 1999/06/15 00:10:37 d Exp $
d272 1
a272 1
			int *));
@


1.8
log
@Remove pthread_atfork()
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.7 1999/05/26 00:17:41 d Exp $
d35 1
d41 5
d71 1
a71 1

a121 1
struct sched_param;
a216 1
int		pthread_cancel __P((pthread_t));
d259 1
a259 1
			void (*init_routine) (void)));
d275 4
a280 2
int		pthread_setspecific __P((pthread_key_t, const void *));
int		pthread_sigmask __P((int, const sigset_t *, sigset_t *));
a282 1

d334 1
a334 1
#if 0
d336 1
a336 1
 * Single Unix Specification v2 (UNIX98) also wants these:
a337 1

a340 1

a348 1

a352 3
#else /* ! _POSIX_THREADS */
#warning "included <pthread.h> without -pthread compiler option"
#endif /* ! _POSIX_THREADS */
@


1.7
log
@sync with FreeBSD
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.6 1999/03/10 10:00:47 d Exp $
a203 1
int		pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
@


1.6
log
@missing const (freebsd)
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.5 1999/01/18 00:00:31 d Exp $
d68 3
a70 3
/* #define _POSIX_THREAD_PRIORITY_SCHEDULING */
/* #define _POSIX_THREAD_PRIO_INHERIT   */
/* #define _POSIX_THREAD_PRIO_PROTECT   */
d167 9
a175 3
#define PTHREAD_MUTEX_INITIALIZER	((pthread_mutex_t) NULL)
#define PTHREAD_COND_INITIALIZER	((pthread_cond_t) NULL)
#define PTHREAD_RWLOCK_INITIALIZER	((pthread_rwlock_t) NULL)
d177 12
d190 3
a192 4
	PTHREAD_MUTEX_DEFAULT		= 1,
	PTHREAD_MUTEX_RECURSIVE		= 2,
	PTHREAD_MUTEX_NORMAL		= 3,
	PTHREAD_MUTEX_ERRORCHECK	= 4,
d196 2
a197 1
#define MUTEX_TYPE_FAST			PTHREAD_MUTEX_DEFAULT
a205 5
int		pthread_attr_getinheritsched __P((const pthread_attr_t *, int *));
int		pthread_attr_getschedparam __P((const pthread_attr_t *,
			struct sched_param *));
int		pthread_attr_getschedpolicy __P((const pthread_attr_t *, int *));
int		pthread_attr_getscope __P((const pthread_attr_t *, int *));
a209 5
int		pthread_attr_setinheritsched __P((pthread_attr_t *, int));
int		pthread_attr_setschedparam __P((pthread_attr_t *,
			const struct sched_param *));
int		pthread_attr_setschedpolicy __P((pthread_attr_t *, int));
int		pthread_attr_setscope __P((pthread_attr_t *, int));
d219 2
d225 2
d246 1
a247 13
int		pthread_mutexattr_getprioceiling __P((pthread_mutexattr_t *,
			int *prioceiling));
int		pthread_mutexattr_getprotocol __P((pthread_mutexattr_t *,
			int *protocol));
int		pthread_mutexattr_getpshared __P((pthread_mutexattr_t *,
			int *pshared));
int		pthread_mutexattr_init __P((pthread_mutexattr_t *));
int		pthread_mutexattr_setprioceiling __P((pthread_mutexattr_t *,
			int prioceiling));
int		pthread_mutexattr_setprotocol __P((pthread_mutexattr_t *,
			int protocol));
int		pthread_mutexattr_setpshared __P((pthread_mutexattr_t *,
			int pshared));
a249 1
int		pthread_mutex_getprioceiling __P((pthread_mutex_t *));
a252 1
int		pthread_mutex_setprioceiling __P((pthread_mutex_t *));
d282 38
d322 2
a323 2
int		pthread_getschedparam __P((pthread_t pthread, int *policy,
			struct sched_param * param));
@


1.5
log
@sync with previous changes
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.4 1998/12/21 07:30:25 d Exp $
d211 1
a211 1
int		pthread_condattr_getpshared __P((pthread_condattr_t *attr,
@


1.4
log
@clean
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.3 1998/12/10 00:40:19 d Exp $
d94 9
d186 1
d188 2
a189 2
int		pthread_attr_getinheritsched __P((pthread_attr_t *, int *));
int		pthread_attr_getschedparam __P((pthread_attr_t *,
d191 2
a192 2
int		pthread_attr_getschedpolicy __P((pthread_attr_t *, int *));
int		pthread_attr_getscope __P((pthread_attr_t *, int *));
d199 1
a199 1
			struct sched_param *));
d205 1
d278 1
a278 1
int		pthread_testcancel __P((void));
d285 1
a285 1
			struct sched_param * param));
d298 1
a298 5
#define PTHREAD_CANCEL_ASYNCHRONOUS
#define PTHREAD_CANCEL_ENABLE
#define PTHREAD_CANCEL_DEFERRED
#define PTHREAD_CANCEL_DISABLE
#define PTHREAD_CANCELED
@


1.3
log
@sync with FreeBSD
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.2 1998/11/09 03:13:14 d Exp $
d49 1
a49 1
#include <sched.h>	/* SUSV2 */
d153 1
a153 1
#define PTHREAD_ONCE_INIT   { PTHREAD_NEEDS_INIT, NULL }
d158 3
a160 12
#define PTHREAD_MUTEX_INITIALIZER	NULL
#define PTHREAD_COND_INITIALIZER	NULL
#define PTHREAD_RWLOCK_INITIALIZER	NULL

/*
 * Default attribute arguments (draft 4, deprecated).
 */
#ifndef PTHREAD_KERNEL
#define pthread_condattr_default    NULL
#define pthread_mutexattr_default   NULL
#define pthread_attr_default        NULL
#endif
d285 1
a285 1
 * Single Unix Specification v2 wants these:
a291 5
#define PTHREAD_MUTEX_DEFAULT
#define PTHREAD_MUTEX_ERRORCHECK
#define PTHREAD_MUTEX_NORMAL
#define PTHREAD_MUTEX_INITIALIZER
#define PTHREAD_MUTEX_RECURSIVE
a294 2
#define PTHREAD_PROCESS_SHARED
#define PTHREAD_PROCESS_PRIVATE
d309 1
a309 1
#else
d311 2
a312 2
#endif _POSIX_THREADS
#endif
@


1.2
log
@sync with FreeBSD (rwlock, gc thread, man pages)
add (broken) mips md stuff
fix some const warnings
add sigaltstack() stub
another hash at getting shlib auto-init to work (mips/elf and i386/a.out)
@
text
@d33 1
a33 1
 * $OpenBSD: pthread.h,v 1.1 1998/09/05 07:40:47 d Exp $
d172 4
a175 2
	MUTEX_TYPE_FAST			= 1,
	MUTEX_TYPE_COUNTING_FAST	= 2,	/* Recursive */
d179 3
d246 1
a318 2
int		pthread_mutexattr_settype __P((const pthread_mutexattr_t *,
			int));
@


1.1
log
@missed these too. sigh
@
text
@d33 1
a33 1
 * $OpenBSD$
d88 6
d105 2
d124 2
d160 1
d251 14
a304 4
#define PTHREAD_RWLOCK_INITIALIZER

typedef void	*pthread_rwlock_t;
typedef void	*pthread_rwlockattr_t;
a313 14
			int));
int		pthread_rwlock_destroy __P((pthread_rwlock_t *));
int		pthread_rwlock_init __P((pthread_rwlock_t *,
			const pthread_rwlockattr_t *));
int		pthread_rwlock_rdlock __P((pthread_rwlock_t *));
int		pthread_rwlock_tryrdlock __P((pthread_rwlock_t *));
int		pthread_rwlock_trywrlock __P((pthread_rwlock_t *));
int		pthread_rwlock_unlock __P((pthread_rwlock_t *));
int		pthread_rwlock_wrlock __P((pthread_rwlock_t *));
int		pthread_rwlockattr_destroy __P((pthread_rwlockattr_t *));
int		pthread_rwlockattr_getpshared __P((const pthread_rwlockattr_t *,
			int *));
int		pthread_rwlockattr_init __P((pthread_rwlockattr_t *));
int		pthread_rwlockattr_setpshared __P((pthread_rwlockattr_t *,
@

