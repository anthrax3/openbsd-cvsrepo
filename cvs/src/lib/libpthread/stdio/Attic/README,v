head	1.2;
access;
symbols
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	from_mysql_3_22_4:1.1.1.2
	mit:1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.2
date	99.03.10.08.53.42;	author d;	state dead;
branches;
next	1.1;

1.1
date	95.10.18.08.43.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.05;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.21.13.20.30;	author peter;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Goodbye, MIT pthreads... you were a handy reference implementation
@
text
@This is a threadsafe stdio based on the BSD stdio written by Chris Torek.

INCLUDE FILES AND PORTING
To continue to make this package portable, some basic rules on includes
files must be followed.

pthread.h should be included first (if it is to be included).
stdio.h should be included.

INTERNAL LOCKING
1.	All functions that can be called by the user must have __flockfile at the
	begining and a __funlockfile at the end. __Flockfile is a counting mutex,
	The thread that owns the lock can call __flockfile as many times as
	it wants, but must call an equal number of __funlockfile before the
	lock will be released.
2.	All functions starting with __ shouldn't need addtional locking.
3.	Anything that writes the variable __sglue should lock __sfp_mutex,
 	check __sfp_state, and do a condion wait if it is set.
4.	Anything that checks fp->_flag for valididity should also lock
	__sfp_mutex.
5.	Anything that reads the variable __sglue should lock __sfp_mutex, increment
	__sfp_state, and then unlock the mutex. At function return it should
	lock the mutex again decrement __sfp_state and check if zero. If so
	do a cond_signal, and unlock the mutex.
6.	The functions fopen, fdopen, and freopen are the only functions that
	will change a fp->_file
7.	fdopen and fopen both allocate the next fp by locking __sfp_mutex
	checking fp->_flags and then setting it if free.
8.	freopen tries to preserve fp->_file. It sets __sfp_mutex, then it
	tries to lock fp->_file and close it.
9.	__sinit is done with a pthread_once routine.

Copyright (c) 1993 Chris Provenzano. All rights reserved.

This product includes software developed by the Univeristy of California,
Berkeley and its contributors.


Things to do.
Fix printf so it uses the ininf function.
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@


1.1.1.2
log
@Complete initial import from mySQL 3.22.4 (mit-pthreads/).
Lots of dross to move and remove yet.

At minimum:
o	remove GNU config and GNU Makefiles
o	build arch directory and migrate away machdep/
o	rebuild BSD Makefiles
o	move notes etc. into doc/
@
text
@a0 2
Copyright (c) 1993, 1994 Chris Provenzano. All rights reserved.

a1 2
This product includes software developed by the Univeristy of California,
Berkeley and its contributors.
d11 5
a15 5
1.	All functions that can be called by the user must have flockfile() at the
	begining and a funlockfile() at the end. The routine flockfile() is a
	counting mutex, The thread that owns the lock can call flockfile() as 
	many times as it wants, but must call an equal number of funlockfile()
	before the lock will be released.
d33 4
a39 1

@

