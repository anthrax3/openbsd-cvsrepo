head	1.30;
access;
symbols
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.19.0.4
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9;
locks; strict;
comment	@# @;


1.30
date	2004.08.06.12.05.08;	author espie;	state dead;
branches;
next	1.29;

1.29
date	2004.03.01.20.13.24;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.11.18.50.43;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.11.18.48.43;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.10.18.54.57;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.10.18.51.31;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.09.10.00.09;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.07.22.23.04;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.15.15.56.16;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.16.20.07.07;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.02.03.17.16;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.03.16.33.49;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.14.10.58.05;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.14.10.57.13;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.14.10.56.24;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.25.09.04.25;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.08.13.46.11;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.22.20.32.57;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.19.13.30.17;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.31.18.38.30;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.17.12.09.00;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.29.20.40.04;	author espie;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.04.26.15.44.18;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.23.22.14.28;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.12.20.46.18;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.04.15.31.06;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.31.15.56.59;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.31.15.55.06;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.05.22.15.16;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.03.18.10.48;	author espie;	state Exp;
branches;
next	;

1.9.2.1
date	2000.07.12.13.54.30;	author jason;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Reorganize makewhatis in smaller modules.
Avoid pulling unneeded code: for instance, if you have only formated
manpages in your system, Unformated will never be used; Check put aside
and only used in -p mode. -t mode won't pull Whatis. Find; File::Compare
and File::Copy and File::Temp likewise.

okay millert@@
@
text
@#!/usr/bin/perl -w
# ex:ts=8 sw=4:

# $OpenBSD: makewhatis.pl,v 1.29 2004/03/01 20:13:24 espie Exp $
#
# Copyright (c) 2000 Marc Espie.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
# PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

require 5.006_000;

use strict;
use File::Find;
use File::Temp qw/tempfile/;
use File::Compare;

use Getopt::Std;

my ($picky, $testmode);

# write_uniques($list, $file):
#
#   write $list to file named $file, removing duplicate entries.
#   Change $file mode/owners to expected values
#   Write to temporary file first, and do the copy only if changes happened.
#
sub write_uniques
{
    my $list = shift;
    my $f = shift;
    local $_;

    my ($out, $tempname);
    ($out, $tempname) = tempfile('/tmp/makewhatis.XXXXXXXXXX') or die "$0: Can't open temporary file";

    my @@sorted = sort @@$list;
    my $last;

    while ($_ = shift @@sorted) {
	print $out $_, "\n" unless defined $last and $_ eq $last;
	$last = $_;
    }
    close $out;
    if (compare($tempname, $f) == 0) {
    	unlink($tempname);
    } else {
    	use File::Copy;

	unlink($f);
	if (move($tempname, $f)) {
	    chmod 0444, $f;
	    chown 0, (getgrnam 'bin')[2], $f;
	} else {
	    print STDERR "$0: Can't create $f ($!)\n";
	    unlink($tempname);
	    exit 1;
	}
    }
}

sub found($$)
{
    my ($pattern, $filename) = @@_;
    my @@candidates = glob $pattern;
    if (@@candidates > 0) {
    	# quick check of inode, dev number
    	my ($dev_cmp, $inode_cmp) = (stat $filename)[0,1];
    	for my $f (@@candidates) {
	    my ($dev, $inode) = (stat $f)[0, 1];
	    if ($dev == $dev_cmp && $inode == $inode_cmp) {
		return 1;
	    }
	}
	# slow check with File::Compare
	for my $f (@@candidates) {
	    if (compare($f, $filename) == 0) {
		return 1;
	    }
	}
    }
    return 0;
}

# verify_subject($subject, $filename):
#
#   reparse the subject we're about to add, and check whether it makes
#   sense, e.g., is there a man page around.
sub verify_subject
{
    local $_ = shift;
    my $filename = shift;
    if (m/\s*(.*?)\s*\((.*?)\)\s-\s/) {
    	my $man = $1;
	my $section = $2;
	my @@mans = split(/\s*,\s*|\s+/, $man);
	my $base = $filename;
	if ($base =~ m|/|) {
	    $base =~ s,/[^/]*$,,;
	} else {
		$base = '.';
	}
	my @@notfound = ();
	for my $func (@@mans) {
	    my $i = $func;
	    next if found("$base/$i.*", $filename);
	    # try harder
	    $i =~ s/\(\)//;
	    $i =~ s/\-//g;
	    $i =~ s,^etc/,,;
	    next if found("$base/$i.*", $filename);
	    # and harder...
	    $i =~ tr/[A-Z]/[a-z]/;
	    next if found("$base/$i.*", $filename);
	    push(@@notfound, $func);
	}
	if (@@notfound > 0) {
	    print STDERR "Couldn't find ", join(', ', @@notfound), 
	    	" in $filename:\n$_\n" 
	}
    }
}


# add_unformated_subject($lines, $toadd, $section, $filename, $toexpand):
#
#   build subject from list of $toadd lines, and add it to the list
#   of current subjects as section $section
#
sub add_unformated_subject
{
    my $subjects = shift;
    my $toadd = shift;
    my $section = shift;
    my $filename = shift;
    my $toexpand = shift;

    my $exp = sub {
    	if (defined $toexpand->{$_[0]}) {
		return $toexpand->{$_[0]};
	} else {
		print STDERR "$filename: can't expand $_[0]\n";
		return "";
	}
    };

    local $_ = join(' ', @@$toadd);
	# do interpolations
    s/\\\*\((..)/&$exp($1)/ge;
    s/\\\*\[(.*?)\]/&$exp($1)/ge;

	# horizontal space adjustments
    while (s/\\s[-+]?\d+//g)
    	{}
	# unbreakable spaces
    s/\\\s+/ /g;
    	# unbreakable em dashes
    s/\\\|\\\(em\\\|/-/g;
	# em dashes
    s/\\\(em\s+/- /g;
    	# em dashes in the middle of lines
    s/\\\(em/-/g;
    s/\\\*[LO]//g;
    s/\\\(tm/(tm)/g;
	# font changes
    s/\\f[BIRP]//g;
    s/\\f\(..//g;
    	# fine space adjustments
    while (s/\\[vh]\'.*?\'//g)
    	{}
    unless (s/\s+\\-\s+/ ($section) - / || s/\s*\\\-/ ($section) -/ ||
    	s/\s-\s/ ($section) - /) {
	print STDERR "Weird subject line in $filename:\n$_\n" if $picky;
	    # Try guessing where the separation falls...
	s/\s+\:\s+/ ($section) - / || s/\S+\s+/$& ($section) - / || s/\s*$/ ($section) - (empty subject)/;
    }
	# other dashes
    s/\\-/-/g;
	# escaped characters
    s/\\\&(.)/$1/g;
    s/\\\|/|/g;
	# gremlins...
    s/\\c//g;
	# sequence of spaces
    s/\s+$//;
    s/^\s+//;
    s/\s+/ /g;
    	# some damage control
    if (m/^\Q($section) - \E/) {
    	print STDERR "Rejecting non-subject line from $filename:\n$_\n"
	    if $picky;
	return;
    }
    push(@@$subjects, $_);
    verify_subject($_, $filename) if $picky;
}

# $lines = handle_unformated($file)
#
#   handle an unformated manpage in $file
#
#   may return several subjects, perl(3p) do !
#
sub handle_unformated
{
    my $f = shift;
    my $filename = shift;
    my @@lines = ();
    my %toexpand = ();
    my $so_found = 0;
    local $_;
	# retrieve basename of file
    my ($name, $section) = $filename =~ m|(?:.*/)?(.*)\.([\w\d]+)|;
	# scan until macro
    while (<$f>) {
	next unless m/^\./;
	if (m/^\.\s*de/) {
	    while (<$f>) {
		last if m/^\.\s*\./;
	    }
	    next;
	}
	if (m/^\.\s*ds\s+(\S+)\s+/) {
	    chomp($toexpand{$1} = $');
	    next;
	}
	    # Some cross-refs just link to another manpage
	$so_found = 1 if m/^\.\s*so/;
	if (m/^\.\s*TH/ || m/^\.\s*th/) {
		# in pricky mode, we should try to match these
	    # ($name2, $section2) = m/^\.(?:TH|th)\s+(\S+)\s+(\S+)/;
	    	# scan until first section
	    while (<$f>) {
		if (m/^\.\s*de/) {
		    while (<$f>) {
			last if m/^\.\s*\./;
		    }
		    next;
		}
		if (m/^\.\s*ds\s+(\S+)\s+/) {
		    chomp($toexpand{$1} = $');
		    next;
		}
		next unless m/^\./;
		if (m/^\.\s*SH/ || m/^\.\s*sh/) {
		    my @@subject = ();
		    while (<$f>) {
			last if m/^\.\s*(?:SH|sh|SS|ss|nf|LI)/;
			    # several subjects in one manpage
			if (m/^\.\s*(?:PP|Pp|br|PD|LP|sp)/) {
			    add_unformated_subject(\@@lines, \@@subject,
				$section, $filename, \%toexpand)
				    if @@subject != 0;
			    @@subject = ();
			    next;
			}
			next if m/^\'/ || m/^\.\s*tr\s+/ || m/^\.\s*\\\"/ ||
			    m/^\.\s*sv/ || m/^\.\s*Vb\s+/ || m/\.\s*HP\s+/;
			if (m/^\.\s*de/) {
			    while (<$f>) {
				last if m/^\.\s*\./;
			    }
			    next;
			}
			if (m/^\.\s*ds\s+(\S+)\s+/) {
			    chomp($toexpand{$1} = $');
			    next;
			}
			# Motif index entries, don't do anything for now.
			next if m/^\.\s*iX/;
			# Some other index (cook)
			next if m/^\.\s*XX/;
			chomp;
			s/\.\s*(?:B|I|IR|SM|BR)\s+//;
			if (m/^\.\s*(\S\S)/) {
			    print STDERR "$filename: not grokking $_\n" 
				if $picky;
			    next;
			}
			push(@@subject, $_) unless m/^\s*$/;
		    }
		    add_unformated_subject(\@@lines, \@@subject, $section,
			$filename, \%toexpand) if @@subject != 0;
		    return \@@lines;
		}
	    }
	    print STDERR "Couldn't find subject in old manpage $filename\n";
	} elsif (m/^\.\s*Dt/) {
	    $section .= "/$1" if (m/^\.\s*Dt\s+\S+\s+\d\S*\s+(\S+)/);
	    while (<$f>) {
		next unless m/^\./;
		if (m/^\.\s*Sh/) {
		    # subject/keep is the only way to deal with Nm/Nd pairs
		    my @@subject = ();
		    my @@keep = ();
		    my $nd_seen = 0;
		    while (<$f>) {
		    	next if m/^\.\\\"/;
			last if m/^\.\s*Sh/;
			s/\s,/,/g;
			if (s/^\.\s*(\S\S)\s+//) {
			    my $macro = $1;
			    next if $macro eq "\\\"";
			    s/\"(.*?)\"/$1/g;
			    s/\\-/-/g;
			    $macro eq 'Xr' and s/^(\S+)\s+(\d\S*)/$1 ($2)/;
			    $macro eq 'Ox' and s/^/OpenBSD /;
			    $macro eq 'Nx' and s/^/NetBSD /;
			    if ($macro eq 'Nd') {
				if (@@keep != 0) {
				    add_unformated_subject(\@@lines, \@@keep, 
				    	$section, $filename, \%toexpand);
				    @@keep = ();
				}
				push(@@subject, "\\-");
				$nd_seen = 1;
			    }
			    if ($nd_seen && $macro eq 'Nm') {
				@@keep = @@subject;
				@@subject = ();
				$nd_seen = 0;
			    }
			}
			push(@@subject, $_) unless m/^\s*$/;
		    }
		    unshift(@@subject, @@keep) if @@keep != 0;
		    add_unformated_subject(\@@lines, \@@subject, $section,
		    	$filename, \%toexpand)
			    if @@subject != 0;
		    return \@@lines;
		}
	    }
	}
    }
    if ($so_found == 0) {
	print STDERR "Unknown manpage type $filename\n";
    }
    return \@@lines;
}
			
# add_formated_subject($subjects, $_, $section):
#   add subject $_ to the list of current $subjects, in section $section.
#
sub add_formated_subject
{
    my $subjects = shift;
    local $_ = shift;
    my $section = shift;
    my $filename = shift;

    # some twits underline the command name
    while (s/_\cH//g || s/(.)\cH\1/$1/g)
	{}
    if (m/-/) {
	s/([-+.\w\d,])\s+/$1 /g;
	s/([a-z][A-z])-\s+/$1/g;
	# some twits use: func -- description
	if (m/^[^-+.\w\d]*(.*?) -(?:-?)\s+(.*)/) {
	    my ($func, $descr) = ($1, $2);
	    $func =~ s/,\s*$//;
	    # nroff will tend to cut function names at the weirdest places
	    if (length($func) > 40 && $func =~ m/,/ && $section =~ /^3/) {
	    	$func =~ s/\b \b//g;
	    }
	    $_ = "$func ($section) - $descr";
	    verify_subject($_, $filename) if $picky;
	    push(@@$subjects, $_);
	    return;
	}
    }

    print STDERR "Weird subject line in $filename:\n$_\n" if $picky;

    # try to find subject in line anyway
    if (m/^\s*(.*\S)(?:\s{3,}|\(\)\s+)(.*?)\s*$/) {
    	my ($func, $descr) = ($1, $2);
	$func =~ s/\s+/ /g;
	$descr =~ s/\s+/ /g;
	$_ = "$func ($section) - $descr";
	verify_subject($_, $filename) if $picky;
	push(@@$subjects, $_);
	return;
    }

    print STDERR "Weird subject line in $filename:\n$_\n" unless $picky;
}

# $lines = handle_formated($file)
#
#   handle a formatted manpage in $file
#
#   may return several subjects, perl(3p) do !
#
sub handle_formated
{
    my $file = shift;
    my $filename = shift;
    local $_;
    my ($section, $subject);
    my @@lines=();
    while (<$file>) {
	next if /^$/;
	chomp;
	# Remove boldface from wide characters
	while (s/(..)\cH\cH\1/$1/g)
	    {}
	# Remove boldface and underlining
	while (s/_\cH//g || s/(.)\cH\1/$1/g)
	    {}
	if (m/\w[-+.\w\d]*\(([-+.\w\d\/]+)\)/) {
	    $section = $1;
	    # Find architecture
	    if (m/Manual\s+\((.*?)\)/) {
		$section = "$section/$1";
	    }
	}
	# Not all man pages are in english
	# weird hex is `Namae' in japanese
	if (m/^(?:NAME|NAMES|NAMN|Name|\xbe|\xcc\xbe\xbe\xce|\xcc\xbe\xc1\xb0)\s*$/) {
	    unless (defined $section) {
		# try to retrieve section from filename
		if ($filename =~ m/(?:cat|man)([\dln])\//) {
		    $section = $1;
		    print STDERR "Can't find section in $filename, deducting $section from context\n" if $picky;
		} else {
		    $section='??';
		    print STDERR "Can't find section in $filename\n";
		}
	    }
	    while (<$file>) {
		chomp;
		# perl aggregates several subjects in one manpage
		if (m/^$/) {
		    add_formated_subject(\@@lines, $subject, $section, $filename) 
			if defined $subject;
		    $subject = undef;
		} elsif (m/^\S/ || m/^\s+\*{3,}\s*$/) {
		    add_formated_subject(\@@lines, $subject, $section, $filename) 
			if defined $subject;
		    last;
		} else {
		    # deal with troff hyphenations
		    if (defined $subject and $subject =~ m/\xad\s*$/) {
		    	$subject =~ s/(?:\xad\cH)*\xad\s*$//;
			s/^\s*//;
		    }
		    # more troff hyphenation
		    if (defined $subject and $subject =~ m/\S(?:\-\cH)*\-$/) {
		    	$subject =~ s/(?:\-\cH)*\-$//;
			s/^\s*//;
		    }
		    s/^\s+/ /;
		    $subject.=$_;
		}
	    }
	last;
	}
    }

    print STDERR "Can't parse $filename (not a manpage ?)\n" if @@lines == 0;
    return \@@lines;
}

# $list = find_manpages($dir)
#
#   find all manpages under $dir, trim some duplicates.
#
sub find_manpages
{
    my $dir = shift;
    my ($list, %nodes);
    $list=[];
    find(
	sub {
	return unless /\.[\dln]\w*(?:\.Z|\.gz)?$/;
	return unless -f $_;
	my $unique = (stat _)[0]."/".(stat _)[1];
	return if defined $nodes{$unique};
	$nodes{$unique} = 1;
	push(@@$list, $File::Find::name);
	}, $dir);
    return $list;
}

# $subjects = scan_manpages($list)
#
#   scan a set of manpages, return list of subjects
#
sub scan_manpages
{
    my $list = shift;
    local $_;
    my ($done);
    $done=[];

    for (@@$list) {
	my ($file, $subjects);
	if (m/\.(?:Z|gz)$/) {
	    unless (open $file, '-|', "gzip -fdc $_") {
	    	warn "$0: Can't decompress $_\n";
		next;
	    }
	    $_ = $`;
	} else {
	    unless (open $file, '<', $_) {
	    	warn "$0: Can't read $_\n";
		next;
	    }
	}
	if (m/\.[1-9ln][^.]*$/) {
	    $subjects = handle_unformated($file, $_);
	} elsif (m/\.0$/) {
	    $subjects = handle_formated($file, $_);
	    # in test mode, we try harder
	} elsif ($testmode) {
	    $subjects = handle_unformated($file, $_);
	    if (@@$subjects == 0) {
	    	$subjects = handle_formated($file, $_);
	    }
	} else {
	    print STDERR "Can't find type of $_";
	    next;
	}
	push @@$done, @@$subjects;
    }
    return $done;
}

# build_index($dir)
#
#   build index for $dir
#
sub build_index
{
    my $dir = shift;
    my $list = find_manpages($dir);
    my $subjects = scan_manpages($list);
    write_uniques($subjects, "$dir/whatis.db");
}

# main code
    
my %opts;
getopts('tpd:u:', \%opts);

if (defined $opts{'p'}) {
    $picky = 1;
}
if (defined $opts{'t'}) {
    $testmode = 1;
    my $subjects = scan_manpages(\@@ARGV);
    print join("\n", @@$subjects), "\n";
    exit 0;
} 

if (defined $opts{'d'}) {
    my $mandir = $opts{'d'};
    unless (-d $mandir) {
	die "$0: $mandir: not a directory"
    }
    chdir $mandir;

    my $whatis = "$mandir/whatis.db";
    open(my $old, '<', $whatis) or
	die "$0 $whatis to merge with";
    my $subjects = scan_manpages(\@@ARGV);
    while (<$old>) {
	chomp;
	push(@@$subjects, $_);
    }
    close($old);
    write_uniques($subjects, $whatis);
    exit 0;
}
if (defined $opts{'u'}) {
    my $mandir = $opts{'u'};
    unless (-d $mandir) {
	die "$0: $mandir: not a directory"
    }
    chdir $mandir;

    my $whatis = "$mandir/whatis.db";
    open(my $old, '<', $whatis) or
	die "$0 $whatis to merge with";
    my $subjects = scan_manpages(\@@ARGV);
    my %remove = map {$_ => 1 } @@$subjects;
    $subjects = [];
    while (<$old>) {
	chomp;
	push(@@$subjects, $_) unless defined $remove{$_};
    }
    close($old);
    write_uniques($subjects, $whatis);
    exit 0;
}
if ($#ARGV == -1) {
    local $_;
    @@ARGV=();
    open(my $conf, '<', '/etc/man.conf') or 
	die "$0: Can't open /etc/man.conf";
    while (<$conf>) {
	chomp;
	push(@@ARGV, $1) if /^_whatdb\s+(.*)\/whatis\.db\s*$/;
    }
    close $conf;
}
	
for my $mandir (@@ARGV) {
    if (-d $mandir) {
	build_index($mandir);
    } elsif (-e $mandir || $picky) {
    	print STDERR "$0: $mandir is not a directory\n";
    }
}
@


1.29
log
@zap extra spaces. From a PR by Jared Yanovich.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.28 2004/02/11 18:50:43 espie Exp $
@


1.28
log
@some sections came out wrong (no space) in SDL.
ggi has func, func2, func3 : description, give it a fighting chance.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.27 2004/02/11 18:48:43 espie Exp $
d450 1
a450 1
		# perl agregates several subjects in one manpage
d470 1
d495 3
a497 3
	my $inode = (stat _)[1];
	return if defined $nodes{$inode};
	$nodes{$inode} = 1;
@


1.27
log
@more accurate .so test.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.26 2004/02/10 18:54:57 espie Exp $
d189 1
a189 1
    unless (s/\s+\\-\s+/ ($section) - / || s/\\\-/($section) -/ ||
d193 1
a193 1
	s/\S+\s+/$& ($section) - / || s/\s*$/ ($section) - (empty subject)/;
@


1.26
log
@misleading regexp -> pattern
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.25 2004/02/10 18:51:31 espie Exp $
d246 1
a246 1
	$so_found = 1 if m/\.so/;
@


1.25
log
@harder check in picky mode: find the page AND verify it is the same.
Prompted by jmc@@.

Stop at first isolated dash in line.

Handle more troff hyphenation.

okay millert@@, jmc@@
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.24 2003/07/09 10:00:09 espie Exp $
d82 2
a83 2
    my ($regexp, $filename) = @@_;
    my @@candidates = glob $regexp;
@


1.24
log
@-u option, remove manpages, symetrical to -d.
ok millert@@
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.23 2002/11/07 22:23:04 millert Exp $
d80 1
a80 1
sub found
d82 19
a100 2
    my @@candidates = glob shift;
    return @@candidates > 1 || @@candidates == 1 && -e $candidates[0];
d121 4
a124 2
	for my $i (@@mans) {
	    next if found("$base/$i.*");
d129 1
a129 1
	    next if found("$base/$i.*");
d132 6
a137 2
	    next if found("$base/$i.*");
	    print STDERR "Couldn't find $i in $filename:\n$_\n" 
d376 1
a376 1
	if (m/^[^-+.\w\d]*(.*) -(?:-?)\s+(.*)/) {
d463 5
@


1.23
log
@Don't complain about missing man dirs unless in picky mode or if
there is something other than a dir in the way.  Closes PR 2935.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.22 2002/10/15 15:56:16 millert Exp $
d533 1
a533 1
getopts('tpd:', \%opts);
d559 21
@


1.22
log
@Use old-style version number when requiring at least perl 5.6.0.
Fixes a portability warning from perl-5.8.0; espie@@ OK
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.21 2002/04/16 20:07:07 espie Exp $
d579 1
a579 1
    } else {
@


1.21
log
@skip over comment while parsing subject.
(Repair bus_space.9 parsing, not visible on formatted version)
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.20 2002/04/02 03:17:16 espie Exp $
d29 1
a29 1
require 5.6.0;
@


1.20
log
@A few improvements to accommodate more ports.
- recognize unbreakable em dashes from pod2man,
- handle some user-defined font changes,
- kill obvious non-subjects.

ok millert@@
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.19 2001/04/03 16:33:49 espie Exp $
d293 1
@


1.19
log
@throw \v and \h alignments out.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.18 2001/03/14 10:58:05 espie Exp $
d152 2
d162 1
d183 6
d243 1
a243 1
			last if m/^\.\s*(?:SH|sh|SS|ss|nf)/;
d247 1
a247 1
				$section, $filename, \%toexpand) 
@


1.18
log
@ad-hoc code to deal with troff hyphenation in preformatted pages.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.17 2001/03/14 10:57:13 espie Exp $
d160 3
@


1.17
log
@more bizarre constructs that occur in some man pages.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.16 2001/03/14 10:56:24 espie Exp $
d424 5
@


1.16
log
@Allow makewhatis -p -t filename, without full path.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.15 2001/02/25 09:04:25 espie Exp $
d154 3
@


1.15
log
@oops, add missing arguments in some calls.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.14 2000/12/08 13:46:11 espie Exp $
d99 5
a103 1
	$base =~ s,/[^/]*$,,;
@


1.14
log
@strip sequences of spaces AFTER stripping other weird characters.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.13 2000/11/22 20:32:57 espie Exp $
d116 1
a116 1
# add_unformated_subject($lines, $toadd, $section):
d286 2
a287 1
				    add_unformated_subject(\@@lines, \@@keep, $section);
d302 3
a304 2
		    add_unformated_subject(\@@lines, \@@subject, $section)
			if @@subject != 0;
@


1.13
log
@More tweaks  to recognize more weird cases:

- handle \s+n as well as \s-n,
- be smarter in finding name - subject delimitation in the presence of
multiple dashes, always prefer a dash with intervening spaces if one is
available,
- handle spaces in macros everywhere,
- recognize \(tm,
- recognize .SM as a font change,
- recognize .LP as another multiple subject separator,
- strip indexing facilities .iX and .XX,
- complain about unknown macros in picky mode, strip them anyways.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.12 2000/11/19 13:30:17 espie Exp $
a160 4
	# sequence of spaces
    s/\s+$//;
    s/^\s+//;
    s/\s+/ /g;
d166 4
@


1.12
log
@Handle more manpages oddities:

- recognizes \s<number> sequences (horizontal kerning) and removes them.
- escaped |

- parses .ds definitions, expands \*(ab and \*[abc...]
(missing built-ins, such as en and em).

- strips .HP, .VB
- recognizes .Pp

- handles some .   ds (space in between).

This fixes over 99% of all manpages generated from the ports tree.
This is still missing a few cleanups and some regression testing.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.11 2000/05/31 18:38:30 espie Exp $
d68 1
d144 1
a144 1
    while (s/\\s-?\d+//g)
d150 1
d153 2
a154 1
    unless (s/\\-/($section) -/ || s/\s-\s/ ($section) - /) {
d205 1
a205 1
	if (m/^\.TH/ || m/^\.th/) {
d221 1
a221 1
		if (m/^\.SH/ || m/^\.sh/) {
d224 1
a224 2
			last if m/^\.SH/ || m/^\.sh/ || m/^\.SS/ ||
			    m/^\.ss/ || m/^\.nf/;
d226 1
a226 2
			if (m/^\.PP/ || m/^\.Pp/ || m/^\.br/ || 
			    m/^\.PD/ || /^\.sp/) {
d233 2
a234 2
			next if m/^\'/ || m/^\.tr\s+/ || m/^\.\\\"/ ||
			    m/^\.sv/ || m/^\.Vb\s+/ || m/\.HP\s+/;
d245 4
d250 6
a255 1
			s/\.(?:B|I|IR|SM)\s+//;
d264 2
a265 2
	} elsif (m/^\.Dt/) {
	    $section .= "/$1" if (m/^\.Dt\s+\S+\s+\d\S*\s+(\S+)/);
d268 1
a268 1
		if (m/^\.Sh/) {
d274 1
a274 1
			last if m/^\.Sh/;
d276 1
a276 1
			if (s/^\.(..)\s+//) {
d331 1
a331 1
	if (m/^[^-+.\w\d]*(.*) -(?:-?)\s+(.*)$/) {
a555 2


@


1.11
log
@Request from Theo:

- name tmp file after makewhatis, make it easier to track in case of
trouble.

- remove tmp file always, two minutes to regenerate top
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.10 2000/05/17 12:09:00 espie Exp $
d126 11
d138 7
d160 1
d164 1
d182 1
d190 1
a190 1
	if (m/^\.de/) {
d192 1
a192 1
		last if m/^\.\./;
d196 4
d207 10
d224 2
a225 1
			if (m/^\.PP/ || m/^\.br/ || m/^\.PD/ || /^\.sp/) {
d227 2
a228 1
				$section, $filename) if @@subject != 0;
d232 3
a234 2
			next if m/^\'/ || m/^\.tr\s+/ || m/^\.\\\"/ || m/^\.sv/;
			if (m/^\.de/) {
d236 1
a236 1
				last if m/^\.\./;
d240 4
d249 1
a249 1
			$filename) if @@subject != 0;
@


1.10
log
@A non existent directory should not prevent makewhatis from looking
further. Noticed by Jon Ribbens <jon@@oaktree.co.uk>
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.9 2000/04/29 20:40:04 espie Exp $
d53 1
a53 1
    ($out, $tempname) = tempfile() or die "$0: Can't open temporary file";
d72 2
a73 1
	    print STDERR "$0: Can't create $f ($!), temporary result is in $tempname\n";
@


1.9
log
@Use perl 5.6.0 features:
- don't use IO::File, autovivify handles instead,
- use open 3 args mode for security,
- pipe return code is now useful, so use it.

Don't install the whatis.db file directly, instead put it in a tmp location,
and copy it only if it changed: this avoids spurious errors on ro /usr.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.8 2000/04/26 15:44:18 espie Exp $
d35 1
d497 4
a500 2
    unless (-d $mandir) {
	die "$0: $mandir: not a directory"
a501 1
    build_index($mandir);
@


1.9.2.1
log
@Pull in patch from current:
Fix (espie):
A non existent directory should not prevent makewhatis from looking
further. Noticed by Jon Ribbens <jon@@oaktree.co.uk>
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.9 2000/04/29 20:40:04 espie Exp $
a34 1

d496 2
a497 4
    if (-d $mandir) {
	build_index($mandir);
    } else {
    	print STDERR "$0: $mandir is not a directory\n";
d499 1
@


1.8
log
@Try harder to find a full subject line.

In pricky mode, verify the subject line: for each name,
check that there indeed is a man page with the right name around.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.7 2000/04/23 22:14:28 espie Exp $
d29 2
d33 2
a34 1
use IO::File;
d43 1
a48 1
    my ($out, $last);
d51 2
a52 1
    $out = new IO::File $f, "w" or die "$0: Can't open $f";
d55 1
d62 13
a74 2
    chmod 0444, $f;
    chown 0, (getgrnam 'bin')[2], $f;
d407 4
a410 1
	    $file = new IO::File "gzip -fdc $_|";
d413 1
a413 1
	    unless ($file = new IO::File $_) {
d472 1
a472 1
    my $old = new IO::File $whatis or 
d479 1
a479 1
    close $old;
d486 1
a486 2
    my $conf;
    $conf = new IO::File '/etc/man.conf' or 
@


1.7
log
@With perl 5.6.0, GetOpt::Std is functional, use it.
Add -p (prick) and -t (test) option.
reword error handling as follows:
makewhatis tries harder to find section and/or subject lines in man pages,
even when the formatting is slightly incorrect.
-p mode diagnoses problems.
-t can be used to quickly test a new man page.
Approved by millert@@.  aaron@@ would like `The options are as follows...'
style, but:
- I don't think this would be as clear,
- he hasn't come up with actual replacement text yet...

At least this is accurate documentation.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.6 2000/04/12 20:46:18 espie Exp $
d61 36
d107 1
d115 5
a119 1
    s/\\-/($section) -/ || s/\s-\s/ ($section) - /;
d130 1
d172 2
a173 2
			    add_unformated_subject(\@@lines, \@@subject, $section) 
				if @@subject != 0;
d188 2
a189 2
		    add_unformated_subject(\@@lines, \@@subject, $section) 
			if @@subject != 0;
d252 1
d264 7
a270 1
	    push(@@$subjects, "$func ($section) - $descr");
d275 1
a275 1
    print STDERR "Weird subject line in ", shift, ":\n", $_, "\n" if $picky;
d282 3
a284 1
	push(@@$subjects, "$func ($section) - $descr");
d288 1
a288 1
    print STDERR "Weird subject line in ", shift, ":\n", $_, "\n" unless $picky;
d322 1
a322 1
	if (m/^(?:NAME|NAMN|Name|\xbe|\xcc\xbe\xbe\xce|\xcc\xbe\xc1\xb0)\s*$/) {
@


1.6
log
@Limited EUC heuristics, should handle bold wide characters correctly,
and recognize `NAME' in japanese manpages.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.5 2000/04/04 15:31:06 espie Exp $
d32 1
d34 1
d61 6
a66 1
sub add_fsubject
d68 1
a68 1
    my $lines = shift;
d88 1
a88 1
    push(@@$lines, $_);
d91 6
d115 1
d118 1
d120 1
d128 1
d130 1
a130 1
			    add_fsubject(\@@lines, \@@subject, $section) 
d135 1
a135 1
			next if m/^\'/ || m/\.tr\s+/ || m/\.\\\"/;
d146 1
a146 1
		    add_fsubject(\@@lines, \@@subject, $section) 
d151 1
a151 1
	    warn "Couldn't find subject in old manpage $filename\n";
d174 1
a174 1
				    add_fsubject(\@@lines, \@@keep, $section);
d189 1
a189 1
		    add_fsubject(\@@lines, \@@subject, $section)
d197 1
a197 1
	warn "Unknown manpage type $filename\n";
d202 4
a205 3
	

sub add_subject
d207 1
a207 1
    my $lines = shift;
d211 3
a214 3
	# some twits underline the command name
	while (s/_\cH//g || s/(.)\cH\1/$1/g)
	    {}
d221 1
a221 1
	    push(@@$lines, "$func ($section) - $descr");
d225 13
a237 1
    print STDERR "Weird subject line $_ in ", shift, "\n";
d271 1
a271 1
	if (m/^(?:NAME|NAMN|Name|\xbe\xcc\xce\xbe)\s*$/) {
d273 8
a280 2
		print STDERR "Can't find section in $filename\n";
		$section='??';
d286 1
a286 1
		    add_subject(\@@lines, $subject, $section, $filename) 
d290 1
a290 1
		    add_subject(\@@lines, $subject, $section, $filename) 
d343 4
a346 1
	    $file = new IO::File $_ or die "$0: Can't read $_\n";
d352 6
d359 1
a359 1
	    warn "Can't find type of $_";
d370 1
a378 1

d381 19
a399 9
while ($#ARGV != -1 and $ARGV[0] =~ m/^-/) {
    my $opt = shift;
    last if $opt eq '--';
    if ($opt eq '-d') {
	my $mandir = shift;
	unless (-d $mandir) {
	    die "$0: $mandir: not a directory"
	}
	chdir $mandir;
d401 7
a407 13
	my $whatis = "$mandir/whatis.db";
	my $old = new IO::File $whatis or 
	    die "$0 $whatis to merge with";
	my $subjects = scan_manpages(\@@ARGV);
	while (<$old>) {
	    chomp;
	    push(@@$subjects, $_);
	}
	close $old;
	write_uniques($subjects, $whatis);
	exit 0;
    } else {
	die "$0: unknown option $opt\n";
d409 3
a412 1

a426 6
    if (-f $mandir) {
	my @@l = ($mandir);
	my $s = scan_manpages(\@@l);
	print join("\n", @@$s), "\n";
	exit 0;
    }
@


1.5
log
@Scan l and n sections as well.
Noticed by Hal Snyder.
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.4 2000/03/31 15:56:59 espie Exp $
d226 3
d240 2
a241 1
	if (m/^(?:NAME|NAMN|Name)\s*$/) {
@


1.4
log
@Reformat with ts=8, after some prodding from Tom Christiansen :)
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.3 2000/03/31 15:55:06 espie Exp $
d276 1
a276 1
	return unless /\.\d\w*(?:\.Z|\.gz)?$/;
d305 1
a305 1
	if (m/\.[1-9][^.]*$/) {
@


1.3
log
@Parse nroff source directly as well, don't use getNAME which is awful
at doing this.
@
text
@d2 1
a2 1
# ex:ts=4 sw=4:
d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.2 2000/02/05 22:15:16 espie Exp $
d36 2
a37 2
#	write $list to file named $file, removing duplicate entries.
#	Change $file mode/owners to expected values
d41 16
a56 16
	my $list = shift;
	my $f = shift;
	my ($out, $last);
	local $_;

	$out = new IO::File $f, "w" or die "$0: Can't open $f";

	my @@sorted = sort @@$list;

	while ($_ = shift @@sorted) {
		print $out $_, "\n" unless defined $last and $_ eq $last;
		$last = $_;
	}
	close $out;
	chmod 0444, $f;
	chown 0, (getgrnam 'bin')[2], $f;
d61 21
a81 21
	my $lines = shift;
	my $toadd = shift;
	my $section = shift;
	local $_ = join(' ', @@$toadd);
		# unbreakable spaces
	s/\\\s+/ /g;
		# em dashes
	s/\\\(em\s+/- /g;
		# font changes
	s/\\f[BIRP]//g;
	s/\\-/($section) -/ || s/\s-\s/ ($section) - /;
		# other dashes
	s/\\-/-/g;
		# sequence of spaces
	s/\s+$//;
	s/\s+/ /g;
		# escaped characters
	s/\\\&(.)/$1/g;
		# gremlins...
	s/\\c//g;
	push(@@$lines, $_);
d86 20
a105 9
	my $f = shift;
	my $filename = shift;
	my @@lines = ();
	my $so_found = 0;
	local $_;
		# retrieve basename of file
	my ($name, $section) = $filename =~ m|(?:.*/)?(.*)\.([\w\d]+)|;
		# scan until macro
	while (<$f>) {
d107 14
a120 2
		if (m/^\.de/) {
			while (<$f>) {
d122 2
d125 7
a131 1
			next;
d133 26
a158 73
		$so_found = 1 if m/\.so/;
		if (m/^\.TH/ || m/^\.th/) {
			# ($name2, $section2) = m/^\.(?:TH|th)\s+(\S+)\s+(\S+)/;
			while (<$f>) {
				next unless m/^\./;
				if (m/^\.SH/ || m/^\.sh/) {
					my @@subject = ();
					while (<$f>) {
						last if m/^\.SH/ || m/^\.sh/ || m/^\.SS/ ||
							m/^\.ss/ || m/^\.nf/;
						if (m/^\.PP/ || m/^\.br/ || m/^\.PD/ || /^\.sp/) {
							add_fsubject(\@@lines, \@@subject, $section) 
								if @@subject != 0;
							@@subject = ();
							next;
						}
						next if m/^\'/ || m/\.tr\s+/ || m/\.\\\"/;
						if (m/^\.de/) {
							while (<$f>) {
								last if m/^\.\./;
							}
							next;
						}
						chomp;
						s/\.(?:B|I|IR|SM)\s+//;
						push(@@subject, $_) unless m/^\s*$/;
					}
					add_fsubject(\@@lines, \@@subject, $section) 
						if @@subject != 0;
					return \@@lines;
				}
			}
			warn "Couldn't find subject in old manpage $filename\n";
		} elsif (m/^\.Dt/) {
			$section .= "/$1" if (m/^\.Dt\s+\S+\s+\d\S*\s+(\S+)/);
			while (<$f>) {
				next unless m/^\./;
				if (m/^\.Sh/) {
					# subject/keep is the only way to deal with Nm/Nd pairs
					my @@subject = ();
					my @@keep = ();
					my $nd_seen = 0;
					while (<$f>) {
						last if m/^\.Sh/;
						s/\s,/,/g;
						if (s/^\.(..)\s+//) {
							my $macro = $1;
							next if $macro eq "\\\"";
							s/\"(.*?)\"/$1/g;
							s/\\-/-/g;
							$macro eq 'Xr' and s/^(\S+)\s+(\d\S*)/$1 ($2)/;
							$macro eq 'Ox' and s/^/OpenBSD /;
							$macro eq 'Nx' and s/^/NetBSD /;
							if ($macro eq 'Nd') {
								if (@@keep != 0) {
									add_fsubject(\@@lines, \@@keep, $section);
									@@keep = ();
								}
								push(@@subject, "\\-");
								$nd_seen = 1;
							}
							if ($nd_seen && $macro eq 'Nm') {
								@@keep = @@subject;
								@@subject = ();
								$nd_seen = 0;
							}
						}
						push(@@subject, $_) unless m/^\s*$/;
					}
					unshift(@@subject, @@keep) if @@keep != 0;
					add_fsubject(\@@lines, \@@subject, $section)
						if @@subject != 0;
					return \@@lines;
d160 8
d169 6
d176 1
d178 5
a182 4
	if ($so_found == 0) {
		warn "Unknown manpage type $filename\n";
	}
	return \@@lines;
d184 2
a185 2
						
		
d189 16
a204 17
	my $lines = shift;
	local $_ = shift;
	my $section = shift;

	if (m/-/) {
		# some twits underline the command name
		while (s/_\cH//g || s/(.)\cH\1/$1/g)
			{}
		s/([-+.\w\d,])\s+/$1 /g;
		s/([a-z][A-z])-\s+/$1/g;
		# some twits use: func -- description
		if (m/^[^-+.\w\d]*(.*) -(?:-?)\s+(.*)$/) {
			my ($func, $descr) = ($1, $2);
			$func =~ s/,\s*$//;
			push(@@$lines, "$func ($section) - $descr");
			return;
		}
d206 2
a207 1
	print STDERR "Weird subject line $_ in ", shift, "\n";
d212 1
a212 1
#	handle a formatted manpage in $file
d214 1
a214 1
# 	may return several subjects, perl(3p) do !
d218 25
a242 7
	my $file = shift;
	my $filename = shift;
	local $_;
	my ($section, $subject);
	my @@lines=();
	while (<$file>) {
		next if /^$/;
d244 11
a254 32
		# Remove boldface and underlining
		while (s/_\cH//g || s/(.)\cH\1/$1/g)
			{}
		if (m/\w[-+.\w\d]*\(([-+.\w\d\/]+)\)/) {
			$section = $1;
			# Find architecture
			if (m/Manual\s+\((.*?)\)/) {
				$section = "$section/$1";
			}
		}
		# Not all man pages are in english
		if (m/^(?:NAME|NAMN|Name)\s*$/) {
			unless (defined $section) {
				print STDERR "Can't find section in $filename\n";
				$section='??';
			}
			while (<$file>) {
			    chomp;
			    # perl agregates several subjects in one manpage
				if (m/^$/) {
					add_subject(\@@lines, $subject, $section, $filename) 
						if defined $subject;
					$subject = undef;
				} elsif (m/^\S/ || m/^\s+\*{3,}\s*$/) {
					add_subject(\@@lines, $subject, $section, $filename) 
						if defined $subject;
					last;
				} else {
					$subject.=$_;
				}
			}
		last;
d256 2
d259 1
d261 2
a262 2
	print STDERR "Can't parse $filename (not a manpage ?)\n" if @@lines == 0;
	return \@@lines;
d267 1
a267 1
#	find all manpages under $dir, trim some duplicates.
d271 13
a283 13
	my $dir = shift;
	my ($list, %nodes);
	$list=[];
	find(
	    sub {
		return unless /\.\d\w*(?:\.Z|\.gz)?$/;
		return unless -f $_;
		my $inode = (stat _)[1];
		return if defined $nodes{$inode};
		$nodes{$inode} = 1;
		push(@@$list, $File::Find::name);
	    }, $dir);
	return $list;
d288 1
a288 1
#	scan a set of manpages, return list of subjects
d292 20
a311 22
	my $list = shift;
	local $_;
	my ($done);
	$done=[];

	for (@@$list) {
	    my ($file, $subjects);
		if (m/\.(?:Z|gz)$/) {
		    $file = new IO::File "gzip -fdc $_|";
			$_ = $`;
		} else {
		    $file = new IO::File $_ or die "$0: Can't read $_\n";
		}
	    if (m/\.[1-9][^.]*$/) {
			$subjects = handle_unformated($file, $_);
	    } elsif (m/\.0$/) {
			$subjects = handle_formated($file, $_);
	    } else {
			warn "Can't find type of $_";
			next;
	    }
	    push @@$done, @@$subjects;
d313 3
a315 1
	return $done;
d320 1
a320 1
#	build index for $dir
d323 4
a326 4
	my $dir = shift;
	my $list = find_manpages($dir);
	my $subjects = scan_manpages($list);
	write_uniques($subjects, "$dir/whatis.db");
d333 8
a340 8
	my $opt = shift;
	last if $opt eq '--';
	if ($opt eq '-d') {
		my $mandir = shift;
		unless (-d $mandir) {
			die "$0: $mandir: not a directory"
		}
		chdir $mandir;
d342 7
a348 13
		my $whatis = "$mandir/whatis.db";
		my $old = new IO::File $whatis or 
		    die "$0 $whatis to merge with";
		my $subjects = scan_manpages(\@@ARGV);
		while (<$old>) {
			chomp;
			push(@@$subjects, $_);
		}
		close $old;
		write_uniques($subjects, $whatis);
		exit 0;
	} else {
		die "$0: unknown option $opt\n";
d350 6
d359 10
a368 10
	local $_;
	@@ARGV=();
	my $conf;
	$conf = new IO::File '/etc/man.conf' or 
	    die "$0: Can't open /etc/man.conf";
	while (<$conf>) {
		chomp;
		push(@@ARGV, $1) if /^_whatdb\s+(.*)\/whatis\.db\s*$/;
	}
	close $conf;
d370 1
a370 1
		
d372 9
a380 9
	if (-f $mandir) {
		my @@l = ($mandir);
		my $s = scan_manpages(\@@l);
		print join("\n", @@$s), "\n";
		exit 0;
	}
	unless (-d $mandir) {
		die "$0: $mandir: not a directory"
	}
@


1.2
log
@Much better at handling formatted manpages.
- remove all boldface c^Hc -> c,
- handle `multiple subjets' manpages correctly (e.g. perl),
- warns about stuff that ought to be manpages, but isn't proper
(ffs_softupdates and safe_finger are missing subject lines, BTW).

So, all the perl documentation is finally grokked correctly.
Todd's baby is missing quite a few manpages links...
@
text
@d4 1
a4 1
# $OpenBSD: makewhatis.pl,v 1.1 2000/02/03 18:10:48 espie Exp $
d59 25
a83 5
# handle_unformated($result, $args)
#
#	handle a batch of unformated manpages $args,
#	push the subjects to $result
#
d86 4
a89 2
	my $result = shift;
	my $args = shift;
d91 90
a180 7
	my $cmd;

	$cmd = new IO::File "/usr/libexec/getNAME ".join(" ", @@$args)."|";
	while (<$cmd>) {
		chomp;
		s/ [a-zA-Z\d]* \\-/ -/;
		push(@@$result, $_);
d182 1
a182 1
	close $cmd;
d184 2
d231 4
d237 1
a237 1
		if (m/^(?:NAME|NAMN)\s*$/) {
d276 1
a276 1
		return unless /(?:\.[0-9]|0\.Z|0\.gz)$/;
d294 1
a294 1
	my (@@todo, $done);
d299 1
a299 8
	    if (m/\.[1-9]$/) {
		    push(@@todo, $_);
		    if (@@todo > 5000) {
			    handle_unformated($done, \@@todo);
			    @@todo = ();
		    }
		    next;
	    } elsif (m/\.0\.(?:Z|gz)$/) {
d301 8
d310 2
a311 1
		    $file = new IO::File $_ or die "$0: Can't read $_\n";
a312 2

	    $subjects = handle_formated($file, $_);
a314 3
	if (@@todo > 0) {
		handle_unformated($done, \@@todo);
	}
d372 6
@


1.1
log
@Switch to perl: *much* faster (about ten times), *much* more flexible,
simpler to understand (no more sed), and no temporary files.

Some useful comment by Matt Patton.

Ok'ed millert@@
@
text
@d2 1
d4 1
a4 1
# $OpenBSD$
d80 24
a103 1
# $line = handle_formated($file)
d107 2
d112 1
d115 1
d117 1
d119 4
a122 2
		last if m/^N\cHNA\cHAM\cHME\cHE/;
		if (m/\w[-+.\w\d]*\(([\/\-+.\w\d]+)\)/) {
d125 23
d149 3
a151 17
	while (<$file>) {
	    chomp;
	    last if m/^\S/;
	    # some twits underline the command name
	    s/_\cH//g;
	    $subject.=$_;
	}
	$_ = $subject;
	if (defined $_ and m/-/) {
		s/.\cH//g;
		s/([-+.,\w\d])\s+/$1 /g;
		s/([a-z][A-z])-\s+/$1/g;
		s/^[^-+.\w\d]*(.*) - (.*)$/$1 ($section) - $2/;
		return $_;
	} else {
		return undef;
	}
d187 1
a187 1
	    my ($file, $line);
d201 2
a202 2
	    $line = handle_formated($file);
	    push @@$done, $line if defined $line;
@

