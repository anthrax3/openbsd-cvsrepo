head	1.35;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.33.0.8
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.4
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.6
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.6
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.28.0.10
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.22
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.18
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.16
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.14
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.12
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.10
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.8
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.6
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.4
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.4
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2017.05.27.07.44.28;	author tedu;	state Exp;
branches;
next	1.34;
commitid	qgp82C7W90gILdBE;

1.34
date	2016.08.27.03.48.00;	author guenther;	state Exp;
branches;
next	1.33;
commitid	xh7Ys4iLevJxkOeo;

1.33
date	2015.01.16.06.39.50;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	Uu5nFG3wCl0LACBb;

1.32
date	2014.09.15.19.08.19;	author miod;	state Exp;
branches;
next	1.31;
commitid	uuiU9j2I8AUx0fez;

1.31
date	2014.07.08.17.19.23;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	EF98ch02VpFassUi;

1.30
date	2013.05.15.04.23.44;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.14.20.39.24;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.27.23.59.31;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.15.19.05.35;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2003.07.29.18.39.23;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.05.17.02.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.28.22.40.33;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.31;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.18.23.45.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.18.30;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.30.22.28.01;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.02.01.14.42;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.19.21.47.31;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.08.21.18.09;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.06.16.46;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.24.11.42.37;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.17.19.23.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.11.30.07.39.26;	author art;	state Exp;
branches;
next	1.10;

1.10
date	98.07.10.08.06.10;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.08.05.23.48.14;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	97.07.23.20.36.32;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.07.08.20.47.51;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.07.08.20.19.35;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	97.04.17.00.06.30;	author weingart;	state Exp;
branches;
next	1.4;

1.4
date	97.02.20.06.43.00;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	97.02.09.00.03.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.28.23.21.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.43.21;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.43.21;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.35
log
@bzero -> memset
@
text
@/*	$OpenBSD: rstat_proc.c,v 1.34 2016/08/27 03:48:00 guenther Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rstat service:  built with rstat.x and derived from rpc.rstatd.c
 */

#include <sys/types.h>
#include <sys/time.h>
#include <sys/sched.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <net/if.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <syslog.h>
#include <fcntl.h>
#include <limits.h>
#include <errno.h>
#include <ifaddrs.h>
#include "dkstats.h"

#undef FSHIFT			 /* Use protocol's shift and scale values */
#undef FSCALE
#undef DK_NDRIVE
#undef CPUSTATES
#undef if_ipackets
#undef if_ierrors
#undef if_opackets
#undef if_oerrors
#undef if_collisions
#include <rpcsvc/rstat.h>

int	cp_xlat[CPUSTATES] = { CP_USER, CP_NICE, CP_SYS, CP_IDLE };

extern int dk_ndrive;		/* from dkstats.c */
extern struct _disk cur, last;
char *memf = NULL, *nlistf = NULL;
int hz;

extern int from_inetd;
int sincelastreq = 0;		/* number of alarms since last request */
extern int closedown;

union {
	struct stats s1;
	struct statsswtch s2;
	struct statstime s3;
} stats_all;

void	updatestat(void);
void	updatestatsig(int sig);
void	setup(void);

volatile sig_atomic_t wantupdatestat;

static int stat_is_init = 0;

#ifndef FSCALE
#define FSCALE (1 << 8)
#endif

static void
stat_init(void)
{
	stat_is_init = 1;
	setup();
	updatestat();
	(void) signal(SIGALRM, updatestatsig);
	alarm(1);
}

statstime *
rstatproc_stats_3_svc(void *arg, struct svc_req *rqstp)
{
	if (!stat_is_init)
		stat_init();
	sincelastreq = 0;
	return (&stats_all.s3);
}

statsswtch *
rstatproc_stats_2_svc(void *arg, struct svc_req *rqstp)
{
	if (!stat_is_init)
		stat_init();
	sincelastreq = 0;
	return (&stats_all.s2);
}

stats *
rstatproc_stats_1_svc(void *arg, struct svc_req *rqstp)
{
	if (!stat_is_init)
		stat_init();
	sincelastreq = 0;
	return (&stats_all.s1);
}

u_int *
rstatproc_havedisk_3_svc(void *arg, struct svc_req *rqstp)
{
	static u_int have;

	if (!stat_is_init)
		stat_init();
	sincelastreq = 0;
	have = dk_ndrive != 0;
	return (&have);
}

u_int *
rstatproc_havedisk_2_svc(void *arg, struct svc_req *rqstp)
{
	return (rstatproc_havedisk_3_svc(arg, rqstp));
}

u_int *
rstatproc_havedisk_1_svc(void *arg, struct svc_req *rqstp)
{
	return (rstatproc_havedisk_3_svc(arg, rqstp));
}

/* ARGSUSED */
void
updatestatsig(int sig)
{
	wantupdatestat = 1;
}

void
updatestat(void)
{
	int i, mib[2], save_errno = errno;
	struct uvmexp uvmexp;
	size_t len;
	struct if_data *ifdp;
	struct ifaddrs *ifaddrs, *ifa;
	double avrun[3];
	struct timeval tm, btm;
	long *cp_time = cur.cp_time;

#ifdef DEBUG
	syslog(LOG_DEBUG, "entering updatestat");
#endif
	if (sincelastreq >= closedown) {
#ifdef DEBUG
		syslog(LOG_DEBUG, "about to closedown");
#endif
		if (from_inetd)
			_exit(0);
		else {
			stat_is_init = 0;
			errno = save_errno;
			return;
		}
	}
	sincelastreq++;

	/*
	 * dkreadstats reads in the "disk_count" as well as the "disklist"
	 * statistics.  It also retrieves "hz" and the "cp_time" array.
	 */
	dkreadstats();
	memset(stats_all.s1.dk_xfer, '\0', sizeof(stats_all.s1.dk_xfer));
	for (i = 0; i < dk_ndrive && i < DK_NDRIVE; i++)
		stats_all.s1.dk_xfer[i] = cur.dk_rxfer[i] + cur.dk_wxfer[i];

	for (i = 0; i < CPUSTATES; i++)
		stats_all.s1.cp_time[i] = cp_time[cp_xlat[i]];
	(void)getloadavg(avrun, sizeof(avrun) / sizeof(avrun[0]));
	stats_all.s2.avenrun[0] = avrun[0] * FSCALE;
	stats_all.s2.avenrun[1] = avrun[1] * FSCALE;
	stats_all.s2.avenrun[2] = avrun[2] * FSCALE;
	mib[0] = CTL_KERN;
	mib[1] = KERN_BOOTTIME;
	len = sizeof(btm);
	if (sysctl(mib, 2, &btm, &len, NULL, 0) < 0) {
		syslog(LOG_ERR, "can't sysctl kern.boottime: %m");
		_exit(1);
	}
	stats_all.s2.boottime.tv_sec = btm.tv_sec;
	stats_all.s2.boottime.tv_usec = btm.tv_usec;


#ifdef DEBUG
	syslog(LOG_DEBUG, "%d %d %d %d", stats_all.s1.cp_time[0],
	    stats_all.s1.cp_time[1], stats_all.s1.cp_time[2],
	    stats_all.s1.cp_time[3]);
#endif

	mib[0] = CTL_VM;
	mib[1] = VM_UVMEXP;
	len = sizeof(uvmexp);
	if (sysctl(mib, 2, &uvmexp, &len, NULL, 0) < 0) {
		syslog(LOG_ERR, "can't sysctl vm.uvmexp: %m");
		_exit(1);
	}
	stats_all.s1.v_pgpgin = uvmexp.fltanget;
	stats_all.s1.v_pgpgout = uvmexp.pdpageouts;
	stats_all.s1.v_pswpin = 0;
	stats_all.s1.v_pswpout = 0;
	stats_all.s1.v_intr = uvmexp.intrs;
	stats_all.s2.v_swtch = uvmexp.swtch;
	gettimeofday(&tm, (struct timezone *) 0);
	stats_all.s1.v_intr -= hz*(tm.tv_sec - btm.tv_sec) +
	    hz*(tm.tv_usec - btm.tv_usec)/1000000;
	stats_all.s1.if_ipackets = 0;
	stats_all.s1.if_opackets = 0;
	stats_all.s1.if_ierrors = 0;
	stats_all.s1.if_oerrors = 0;
	stats_all.s1.if_collisions = 0;
	if (getifaddrs(&ifaddrs) == -1) {
		syslog(LOG_ERR, "can't getifaddrs: %m");
		_exit(1);
	}
	for (ifa = ifaddrs; ifa != NULL; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;
		ifdp = (struct if_data *)ifa->ifa_data;
		stats_all.s1.if_ipackets += ifdp->ifi_ipackets;
		stats_all.s1.if_opackets += ifdp->ifi_opackets;
		stats_all.s1.if_ierrors += ifdp->ifi_ierrors;
		stats_all.s1.if_oerrors += ifdp->ifi_oerrors;
		stats_all.s1.if_collisions += ifdp->ifi_collisions;
	}
	freeifaddrs(ifaddrs);
	stats_all.s3.curtime.tv_sec = tm.tv_sec;
	stats_all.s3.curtime.tv_usec = tm.tv_usec;

	alarm(1);
	errno = save_errno;
}

void
setup(void)
{
	dkinit(0);
}

void	rstat_service(struct svc_req *, SVCXPRT *);

void
rstat_service(struct svc_req *rqstp, SVCXPRT *transp)
{
	char *(*local)(void *, struct svc_req *);
	xdrproc_t xdr_argument, xdr_result;
	union {
		int fill;
	} argument;
	char *result;

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void)svc_sendreply(transp, xdr_void, (char *)NULL);
		return;

	case RSTATPROC_STATS:
		xdr_argument = (xdrproc_t)xdr_void;
		xdr_result = (xdrproc_t)xdr_statstime;
		switch (rqstp->rq_vers) {
		case RSTATVERS_ORIG:
			local = (char *(*)(void *, struct svc_req *))
				rstatproc_stats_1_svc;
			break;
		case RSTATVERS_SWTCH:
			local = (char *(*)(void *, struct svc_req *))
				rstatproc_stats_2_svc;
			break;
		case RSTATVERS_TIME:
			local = (char *(*)(void *, struct svc_req *))
				rstatproc_stats_3_svc;
			break;
		default:
			svcerr_progvers(transp, RSTATVERS_ORIG, RSTATVERS_TIME);
			return;
		}
		break;

	case RSTATPROC_HAVEDISK:
		xdr_argument = (xdrproc_t)xdr_void;
		xdr_result = (xdrproc_t)xdr_u_int;
		switch (rqstp->rq_vers) {
		case RSTATVERS_ORIG:
			local = (char *(*)(void *, struct svc_req *))
				rstatproc_havedisk_1_svc;
			break;
		case RSTATVERS_SWTCH:
			local = (char *(*)(void *, struct svc_req *))
				rstatproc_havedisk_2_svc;
			break;
		case RSTATVERS_TIME:
			local = (char *(*)(void *, struct svc_req *))
				rstatproc_havedisk_3_svc;
			break;
		default:
			svcerr_progvers(transp, RSTATVERS_ORIG, RSTATVERS_TIME);
			return;
		}
		break;

	default:
		svcerr_noproc(transp);
		return;
	}
	memset(&argument, 0, sizeof(argument));
	if (!svc_getargs(transp, xdr_argument, (caddr_t)&argument)) {
		svcerr_decode(transp);
		return;
	}
	result = (*local)(&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, xdr_argument, (caddr_t)&argument)) {
		syslog(LOG_ERR, "unable to free arguments");
		exit(1);
	}
}
@


1.34
log
@Pull in <sys/time.h> for struct timespec

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.33 2015/01/16 06:39:50 deraadt Exp $	*/
d339 1
a339 1
	bzero((char *)&argument, sizeof(argument));
@


1.33
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.32 2014/09/15 19:08:19 miod Exp $	*/
d39 1
@


1.32
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.31 2014/07/08 17:19:23 deraadt Exp $	*/
d38 1
a38 1
#include <sys/param.h>
@


1.31
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.30 2013/05/15 04:23:44 miod Exp $	*/
d39 1
a39 1
#include <sys/dkstat.h>
@


1.30
log
@undo  malfunction
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.29 2013/05/14 20:39:24 miod Exp $	*/
a38 1
#include <sys/vmmeter.h>
a42 1
#include <uvm/uvm_extern.h>
@


1.29
log
@Don't display swapin/swapout uvmexp fields
@
text
@d1 1
a1 1
*	$OpenBSD: rstat_proc.c,v 1.28 2010/09/01 14:43:34 millert Exp $	*/
@


1.28
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.27 2009/10/27 23:59:31 deraadt Exp $	*/
d235 2
a236 2
	stats_all.s1.v_pswpin = uvmexp.swapins;
	stats_all.s1.v_pswpout = uvmexp.swapouts;
@


1.27
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.26 2004/09/15 19:05:35 deraadt Exp $	*/
d4 1
a4 6
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
d6 26
a31 19
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 *
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a35 2
 *
 * Copyright (c) 1984 by Sun Microsystems, Inc.
@


1.26
log
@ARGSUSED signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.25 2004/02/15 02:45:47 tedu Exp $	*/
a30 5
#ifndef lint
/*static char sccsid[] = "from: @@(#)rpc.rstatd.c 1.1 86/09/25 Copyr 1984 Sun Micro";*/
/*static char sccsid[] = "from: @@(#)rstat_proc.c	2.2 88/08/01 4.0 RPCSRC";*/
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.25 2004/02/15 02:45:47 tedu Exp $";
#endif
@


1.25
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.24 2003/07/29 18:39:23 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.24 2003/07/29 18:39:23 deraadt Exp $";
d163 1
@


1.24
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.23 2003/07/05 17:02:36 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.23 2003/07/05 17:02:36 deraadt Exp $";
d205 1
a205 1
		stats_all.s1.dk_xfer[i] = cur.dk_xfer[i];
@


1.23
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.22 2002/06/28 22:40:33 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.22 2002/06/28 22:40:33 deraadt Exp $";
d206 1
a206 1
	
@


1.22
log
@go back to running these as root from inetd.  however once rpc.{rusersd,rstatd}
starts, do a chroot to /var/empty and change to user nobody.
hi mom, i'm in jail!
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.21 2002/02/16 21:27:31 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.21 2002/02/16 21:27:31 millert Exp $";
d102 1
a102 1
void
d278 2
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.20 2001/11/18 23:45:39 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.20 2001/11/18 23:45:39 deraadt Exp $";
d103 1
a103 1
stat_init()
d113 1
a113 3
rstatproc_stats_3_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d122 1
a122 3
rstatproc_stats_2_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d131 1
a131 3
rstatproc_stats_1_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d140 1
a140 3
rstatproc_havedisk_3_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d152 1
a152 3
rstatproc_havedisk_2_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d158 1
a158 3
rstatproc_havedisk_1_svc(arg, rqstp)
	void *arg;
	struct svc_req *rqstp;
d170 1
a170 1
updatestat()
d274 1
a274 1
setup()
d280 1
a280 3
rstat_service(rqstp, transp)
	struct svc_req *rqstp;
	SVCXPRT *transp;
d282 2
a287 2
	xdrproc_t xdr_argument, xdr_result;
	char *(*local)(void *, struct svc_req *);
@


1.20
log
@create own svc_run(), which can do updating outside of a signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.19 2001/11/06 19:18:30 art Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.19 2001/11/06 19:18:30 art Exp $";
d301 1
a301 1
	char *(*local) __P((void *, struct svc_req *));
d313 1
a313 1
			local = (char *(*) __P((void *, struct svc_req *)))
d317 1
a317 1
			local = (char *(*) __P((void *, struct svc_req *)))
d321 1
a321 1
			local = (char *(*) __P((void *, struct svc_req *)))
d335 1
a335 1
			local = (char *(*) __P((void *, struct svc_req *)))
d339 1
a339 1
			local = (char *(*) __P((void *, struct svc_req *)))
d343 1
a343 1
			local = (char *(*) __P((void *, struct svc_req *)))
@


1.19
log
@new vm includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.18 2001/10/30 22:28:01 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.18 2001/10/30 22:28:01 deraadt Exp $";
d90 5
a94 3
int stats_service();
void updatestat(int);
void setup(void);
d107 2
a108 2
	updatestat(0);
	(void) signal(SIGALRM, updatestat);	/* XXX huge signal race */
d176 7
a182 1
updatestat(int sig)
@


1.18
log
@rstat_timeval is not the same as timeval
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.17 2001/10/02 01:14:42 millert Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.17 2001/10/02 01:14:42 millert Exp $";
a48 1
#include <vm/vm.h>
@


1.17
log
@o Remove #if{,n}def BSD stuff
o Replace nlist and kvm_* with sysctl() and getifaddrs(3)
Fixes an issue on alpha where we would run off the end of the interface list.
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.16 2001/09/19 21:47:31 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.16 2001/09/19 21:47:31 deraadt Exp $";
d271 3
a273 2
	gettimeofday((struct timeval *)&stats_all.s3.curtime,
	    (struct timezone *) 0);
@


1.16
log
@some signal race whacking
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.15 2001/07/08 21:18:09 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.15 2001/07/08 21:18:09 deraadt Exp $";
d43 9
d56 1
a57 1
#include <kvm.h>
a58 4
#include <rpc/rpc.h>
#include <sys/socket.h>
#include <nlist.h>
#include <syslog.h>
d60 1
a60 4
#include <sys/param.h>
#ifdef BSD
#include <sys/vmmeter.h>
#include <sys/dkstat.h>
a61 8
#else
#include <sys/dk.h>
#endif
#include <net/if.h>

#include <vm/vm.h>
#include <sys/sysctl.h>
#include <uvm/uvm_extern.h>
a73 2
#ifdef BSD
#define BSD_CPUSTATES	5	/* Use protocol's idea of CPU states */
a74 1
#endif
a75 20
struct nlist nl[] = {
#define	X_IFNET		0
	{ "_ifnet" },
#define	X_BOOTTIME	1
	{ "_boottime" },
#ifndef BSD
#define	X_HZ		2
	{ "_hz" },
#define	X_CPTIME	3
	{ "_cp_time" },
#define	X_DKXFER	4
	{ "_dk_xfer" },
#define	X_CNT		5
	{ "_cnt" },
#else
#endif
	{ NULL },
};

#ifdef BSD
a78 1
#endif
a80 3
struct ifnet_head ifnetq;	/* chain of ethernet interfaces */
int numintfs;

a83 1
kvm_t *kfd;
a93 1
int havedisk(void);
d154 1
a154 1
	have = havedisk();
a176 1
	long off;
d180 2
a181 1
	struct ifnet ifnet;
a183 1
#ifdef BSD
a184 1
#endif
a211 1
#ifdef BSD
a213 14
#else
	if (kvm_read(kfd, (long)nl[X_HZ].n_value, (char *)&hz, sizeof hz) !=
	    sizeof hz) {
		syslog(LOG_ERR, "can't read hz from kmem");
		_exit(1);
	}
 	if (kvm_read(kfd, (long)nl[X_CPTIME].n_value,
	    (char *)stats_all.s1.cp_time, sizeof (stats_all.s1.cp_time))
	    != sizeof (stats_all.s1.cp_time)) {
		syslog(LOG_ERR, "can't read cp_time from kmem");
		_exit(1);
	}
#endif
#ifdef BSD
a214 1
#endif
d218 5
a222 4
 	if (kvm_read(kfd, (long)nl[X_BOOTTIME].n_value,
	    (char *)&btm, sizeof (stats_all.s2.boottime)) !=
	    sizeof (stats_all.s2.boottime)) {
		syslog(LOG_ERR, "can't read boottime from kmem");
d239 1
a239 1
		syslog(LOG_ERR, "can't sysctl vm.uvmexp");
a250 10

#ifndef BSD
 	if (kvm_read(kfd, (long)nl[X_DKXFER].n_value,
	    (char *)stats_all.s1.dk_xfer, sizeof (stats_all.s1.dk_xfer)) !=
	    sizeof (stats_all.s1.dk_xfer)) {
		syslog(LOG_ERR, "can't read dk_xfer from kmem");
		_exit(1);
	}
#endif

d256 13
a268 12
	for (off = (long)ifnetq.tqh_first, i = 0; off && i < numintfs; i++) {
		if (kvm_read(kfd, off, (char *)&ifnet, sizeof ifnet) !=
		    sizeof ifnet) {
			syslog(LOG_ERR, "can't read ifnet from kmem");
			_exit(1);
		}
		stats_all.s1.if_ipackets += ifnet.if_data.ifi_ipackets;
		stats_all.s1.if_opackets += ifnet.if_data.ifi_opackets;
		stats_all.s1.if_ierrors += ifnet.if_data.ifi_ierrors;
		stats_all.s1.if_oerrors += ifnet.if_data.ifi_oerrors;
		stats_all.s1.if_collisions += ifnet.if_data.ifi_collisions;
		off = (long)ifnet.if_list.tqe_next;
d270 1
a279 32
	struct ifnet ifnet;
	long off;
	char errbuf[_POSIX2_LINE_MAX];

	kfd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
	if (kfd == NULL) {
		syslog(LOG_ERR, "%s", errbuf);
		exit (1);
	}

	if (kvm_nlist(kfd, nl) != 0) {
		syslog(LOG_ERR, "can't get namelist");
		exit (1);
	}

	if (kvm_read(kfd, (long)nl[X_IFNET].n_value, &ifnetq,
	    sizeof ifnetq) != sizeof ifnetq) {
		syslog(LOG_ERR, "can't read ifnet queue head from kmem");
		exit(1);
	}

	numintfs = 0;
	for (off = (long)ifnetq.tqh_first; off;) {
		if (kvm_read(kfd, off, (char *)&ifnet, sizeof ifnet) !=
		    sizeof ifnet) {
			syslog(LOG_ERR, "can't read ifnet from kmem");
			exit(1);
		}
		numintfs++;
		off = (long)ifnet.if_list.tqe_next;
	}
#ifdef BSD
a280 30
#endif
}

/*
 * returns true if have a disk
 */
int
havedisk()
{
#ifdef BSD
	return dk_ndrive != 0;
#else
	int i, cnt;
	long  xfer[DK_NDRIVE];

	if (kvm_nlist(kfd, nl) != 0) {
		syslog(LOG_ERR, "can't get namelist");
		exit (1);
	}

	if (kvm_read(kfd, (long)nl[X_DKXFER].n_value,
		     (char *)xfer, sizeof xfer) != sizeof xfer) {
		syslog(LOG_ERR, "can't read dk_xfer from kmem");
		exit(1);
	}
	cnt = 0;
	for (i=0; i < DK_NDRIVE; i++)
		cnt += xfer[i];
	return (cnt != 0);
#endif
@


1.15
log
@-Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.14 2001/06/27 06:16:46 art Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.14 2001/06/27 06:16:46 art Exp $";
d126 1
a126 1
void updatestat(void);
d141 1
a141 1
	updatestat();
d210 1
a210 1
updatestat()
d213 1
a213 1
	int i, save_errno = errno;
a214 1
	int mib[2];
d231 1
a231 1
			exit(0);
d234 1
d256 1
a256 1
		exit(1);
d262 1
a262 1
		exit(1);
d272 2
a273 2
	    (char *)&btm, sizeof (stats_all.s2.boottime))
	    != sizeof (stats_all.s2.boottime)) {
d275 1
a275 1
		exit(1);
d292 1
a292 1
		exit(1);
d306 2
a307 2
	    (char *)stats_all.s1.dk_xfer, sizeof (stats_all.s1.dk_xfer))
	    != sizeof (stats_all.s1.dk_xfer)) {
d309 1
a309 1
		exit(1);
d322 1
a322 1
			exit(1);
d332 1
a332 1
		(struct timezone *) 0);
@


1.14
log
@UVM is no longer an option
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.13 2001/01/24 11:42:37 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.13 2001/01/24 11:42:37 deraadt Exp $";
d54 1
a54 1
#include <sys/errno.h>
a112 1
int stats_service();
d125 6
a130 3
void updatestat();
static stat_is_init = 0;
extern int errno;
d136 1
d337 1
@


1.13
log
@sysctl() arg 4 is a size_t, not int
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.12 2001/01/17 19:23:26 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.12 2001/01/17 19:23:26 deraadt Exp $";
a64 1
#if defined(UVM)
a67 1
#endif
a99 4
#ifndef UVM
#define	X_CNT		2
	{ "_cnt" },
#endif
a210 1
#ifdef UVM
a213 3
#else
	struct vmmeter cnt;
#endif
a283 1
#ifdef UVM
a299 16
#else
 	if (kvm_read(kfd, (long)nl[X_CNT].n_value, (char *)&cnt, sizeof cnt) !=
	    sizeof cnt) {
		syslog(LOG_ERR, "can't read cnt from kmem");
		exit(1);
	}
	stats_all.s1.v_pgpgin = cnt.v_pgpgin;
	stats_all.s1.v_pgpgout = cnt.v_pgpgout;
	stats_all.s1.v_pswpin = cnt.v_pswpin;
	stats_all.s1.v_pswpout = cnt.v_pswpout;
	stats_all.s1.v_intr = cnt.v_intr;
	gettimeofday(&tm, (struct timezone *) 0);
	stats_all.s1.v_intr -= hz*(tm.tv_sec - btm.tv_sec) +
	    hz*(tm.tv_usec - btm.tv_usec)/1000000;
	stats_all.s2.v_swtch = cnt.v_swtch;
#endif
@


1.12
log
@use _exit() in signal handlers, and flag that the pmap_unset() calls are unsafe
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.11 1999/11/30 07:39:26 art Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.11 1999/11/30 07:39:26 art Exp $";
d219 2
a220 1
	int mib[2], len;
@


1.11
log
@UVM support (how could I miss this?). From jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.10 1998/07/10 08:06:10 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.10 1998/07/10 08:06:10 deraadt Exp $";
d145 1
a145 1
	(void) signal(SIGALRM, updatestat);
@


1.10
log
@do not syslog() with "\n"; skipped smtpd/named/ipmon; 12 minutes of dabbling
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.9 1997/08/05 23:48:14 angelos Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.9 1997/08/05 23:48:14 angelos Exp $";
d65 6
d88 1
a88 3
#define	X_CNT		0
	{ "_cnt" },
#define	X_IFNET		1
d90 1
a90 1
#define	X_BOOTTIME	2
d93 1
a93 1
#define	X_HZ		3
d95 1
a95 1
#define	X_CPTIME	4
d97 1
a97 1
#define	X_DKXFER	5
d99 7
d217 4
d222 1
d293 18
d325 1
@


1.9
log
@Errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.8 1997/07/23 20:36:32 kstailey Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.8 1997/07/23 20:36:32 kstailey Exp $";
d272 1
a272 1
	syslog(LOG_DEBUG, "%d %d %d %d\n", stats_all.s1.cp_time[0],
@


1.8
log
@tabify
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.7 1997/07/08 20:47:51 kstailey Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.7 1997/07/08 20:47:51 kstailey Exp $";
d205 1
a205 1
	int i;
d322 1
@


1.7
log
@Don't call exit(0) from rstat_service().  There is a alarm(3) that brings us
down in due time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.6 1997/07/08 20:19:35 kstailey Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.6 1997/07/08 20:19:35 kstailey Exp $";
d377 1
a377 1
        }
@


1.6
log
@daemons can't fprintf(stderr, "blah"), use syslog(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.5 1997/04/17 00:06:30 weingart Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.5 1997/04/17 00:06:30 weingart Exp $";
d406 1
a406 1
		goto leave;
d426 1
a426 1
			goto leave;
d448 1
a448 1
			goto leave;
d454 1
a454 1
		goto leave;
d459 1
a459 1
		goto leave;
a468 3
leave:
	if (from_inetd)
		exit(0);
@


1.5
log
@Use the real times returned by dkreadstat().

The use of FSHIFT and FSCALE need to be reviewed
in rpc.rstatd.  Does the protocol specify a value
for these, or are they system dependant?

Currently we pass the kernel values back unmodified,
which is not what the protocol specifies.  Check
sys/param.h and rpcsvc/rstat.x to see.
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.4 1997/02/20 06:43:00 tholo Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.4 1997/02/20 06:43:00 tholo Exp $";
d466 1
a466 1
		(void)fprintf(stderr, "unable to free arguments\n");
@


1.4
log
@Provide disk statistics; cleaned up from NetBSD PR 3200 [Jarle Greipsland]
@
text
@d1 1
a1 1
/*	$OpenBSD: rstat_proc.c,v 1.3 1997/02/09 00:03:32 deraadt Exp $	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD: rstat_proc.c,v 1.3 1997/02/09 00:03:32 deraadt Exp $";
d211 1
a211 1
	int cp_time[BSD_CPUSTATES];
@


1.3
log
@save 6% diskspace by moving to tabs
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
static char rcsid[] = "$OpenBSD$";
d59 1
d82 1
a82 3
#define	X_CPTIME	0
	{ "_cp_time" },
#define	X_CNT		1
d84 1
a84 1
#define	X_IFNET		2
d86 1
a86 3
#define	X_DKXFER	3
	{ "_dk_xfer" },
#define	X_BOOTTIME	4
d88 2
a89 1
#define X_HZ		5
d91 6
a96 1
	"",
d98 8
d205 1
a205 1
	int i, hz;
d230 13
a247 9
#ifdef BSD
	if (kvm_read(kfd, (long)nl[X_CPTIME].n_value, (char *)cp_time,
	    sizeof (cp_time)) != sizeof (cp_time)) {
		syslog(LOG_ERR, "can't read cp_time from kmem");
		exit(1);
	}
	for (i = 0; i < CPUSTATES; i++)
		stats_all.s1.cp_time[i] = cp_time[cp_xlat[i]];
#else
d292 1
d299 1
d357 3
d368 3
d372 1
a372 1
	long xfer[DK_NDRIVE];
d377 1
a377 1
	}
d380 1
a380 1
	    (char *)xfer, sizeof xfer) != sizeof xfer) {
d388 1
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d133 1
a133 1
	        stat_init();
d144 1
a144 1
	        stat_init();
d155 1
a155 1
	        stat_init();
d168 1
a168 1
	        stat_init();
d208 1
a208 1
                syslog(LOG_DEBUG, "about to closedown");
d210 6
a215 6
                if (from_inetd)
                        exit(0);
                else {
                        stat_is_init = 0;
                        return;
                }
d225 2
a226 3
 	if (kvm_read(kfd, (long)nl[X_CPTIME].n_value, (char *)cp_time,
		     sizeof (cp_time))
	    != sizeof (cp_time)) {
d234 1
a234 2
		     (char *)stats_all.s1.cp_time,
		     sizeof (stats_all.s1.cp_time))
d241 1
a241 1
        (void)getloadavg(avrun, sizeof(avrun) / sizeof(avrun[0]));
d247 1
a247 1
		     (char *)&btm, sizeof (stats_all.s2.boottime))
d258 2
a259 1
	    stats_all.s1.cp_time[1], stats_all.s1.cp_time[2], stats_all.s1.cp_time[3]);
d278 1
a278 2
		     (char *)stats_all.s1.dk_xfer,
		     sizeof (stats_all.s1.dk_xfer))
d322 1
a322 1
        }
d325 1
a325 1
                     sizeof ifnetq) != sizeof ifnetq)  {
d328 1
a328 1
        }
d349 1
a349 1
	long  xfer[DK_NDRIVE];
d354 1
a354 1
        }
d357 1
a357 1
		     (char *)xfer, sizeof xfer) != sizeof xfer) {
d387 3
a389 3
                switch (rqstp->rq_vers) {
                case RSTATVERS_ORIG:
                        local = (char *(*) __P((void *, struct svc_req *)))
d391 3
a393 3
                        break;
                case RSTATVERS_SWTCH:
                        local = (char *(*) __P((void *, struct svc_req *)))
d395 3
a397 3
                        break;
                case RSTATVERS_TIME:
                        local = (char *(*) __P((void *, struct svc_req *)))
d399 5
a403 5
                        break;
                default:
                        svcerr_progvers(transp, RSTATVERS_ORIG, RSTATVERS_TIME);
                        goto leave;
                }
d409 3
a411 3
                switch (rqstp->rq_vers) {
                case RSTATVERS_ORIG:
                        local = (char *(*) __P((void *, struct svc_req *)))
d413 3
a415 3
                        break;
                case RSTATVERS_SWTCH:
                        local = (char *(*) __P((void *, struct svc_req *)))
d417 3
a419 3
                        break;
                case RSTATVERS_TIME:
                        local = (char *(*) __P((void *, struct svc_req *)))
d421 5
a425 5
                        break;
                default:
                        svcerr_progvers(transp, RSTATVERS_ORIG, RSTATVERS_TIME);
                        goto leave;
                }
d446 2
a447 2
        if (from_inetd)
                exit(0);
@


1.1
log
@Initial revision
@
text
@d1 2
d34 1
a34 1
static char rcsid[] = "$Id: rstat_proc.c,v 1.14 1995/07/09 00:30:11 pk Exp $";
a92 4
#ifdef vax
#define	X_AVENRUN	6
	{ "_avenrun" },
#endif
a238 7
		exit(1);
	}
#endif
#ifdef vax
 	if (kvm_read(kfd, (long)nl[X_AVENRUN].n_value, (char *)avrun,
		     sizeof (avrun)) != sizeof (avrun)) {
		syslog(LOG_ERR, "can't read avenrun from kmem");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
